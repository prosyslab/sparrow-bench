/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 42 "/home/khheo/project/mit-scheme-9.2/src/microcode/object.h"
typedef unsigned long SCHEME_OBJECT;
#line 47 "/home/khheo/project/mit-scheme-9.2/src/microcode/object.h"
typedef unsigned char byte_t;
#line 37 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.h"
struct cc_entry_type_s;
#line 37 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.h"
typedef struct cc_entry_type_s cc_entry_type_t;
#line 136 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpintmd.h"
typedef byte_t insn_t;
#line 84 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.h"
enum __anonenum_cc_entry_type_marker_t_35 {
    CET_PROCEDURE = 0,
    CET_CONTINUATION = 1,
    CET_EXPRESSION = 2,
    CET_INTERNAL_PROCEDURE = 3,
    CET_INTERNAL_CONTINUATION = 4,
    CET_TRAMPOLINE = 5,
    CET_RETURN_TO_INTERPRETER = 6,
    CET_CLOSURE = 7
} ;
#line 84 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.h"
typedef enum __anonenum_cc_entry_type_marker_t_35 cc_entry_type_marker_t;
#line 96 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.h"
struct __anonstruct_for_procedure_37 {
   unsigned int n_required ;
   unsigned int n_optional ;
   _Bool rest_p ;
};
#line 96 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.h"
struct __anonstruct_for_continuation_38 {
   unsigned long offset ;
};
#line 96 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.h"
union __anonunion_args_36 {
   struct __anonstruct_for_procedure_37 for_procedure ;
   struct __anonstruct_for_continuation_38 for_continuation ;
};
#line 96 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.h"
struct cc_entry_type_s {
   cc_entry_type_marker_t marker ;
   union __anonunion_args_36 args ;
};
#line 209 "/home/khheo/project/mit-scheme-9.2/src/microcode/comutl.c"
typedef unsigned long thunk_t(void);
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 38 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.h"
struct cc_entry_offset_s;
#line 38 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.h"
typedef struct cc_entry_offset_s cc_entry_offset_t;
#line 131 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.h"
struct cc_entry_offset_s {
   unsigned long offset ;
   _Bool continued_p ;
};
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stddef.h"
typedef unsigned long size_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 231 "/home/khheo/project/mit-scheme-9.2/src/microcode/confshared.h"
enum __anonenum_cc_arch_t_30 {
    COMPILER_NONE_TYPE = 0,
    COMPILER_MC68020_TYPE = 1,
    COMPILER_VAX_TYPE = 2,
    COMPILER_SPECTRUM_TYPE = 3,
    COMPILER_OLD_MIPS_TYPE = 4,
    COMPILER_MC68040_TYPE = 5,
    COMPILER_SPARC_TYPE = 6,
    COMPILER_RS6000_TYPE = 7,
    COMPILER_MC88K_TYPE = 8,
    COMPILER_IA32_TYPE = 9,
    COMPILER_ALPHA_TYPE = 10,
    COMPILER_MIPS_TYPE = 11,
    COMPILER_C_TYPE = 12,
    COMPILER_SVM_TYPE = 13,
    COMPILER_X86_64_TYPE = 14
} ;
#line 231 "/home/khheo/project/mit-scheme-9.2/src/microcode/confshared.h"
typedef enum __anonenum_cc_arch_t_30 cc_arch_t;
#line 68 "/home/khheo/project/mit-scheme-9.2/src/microcode/dstack.h"
enum transaction_action_type {
    tat_abort = 0,
    tat_commit = 1,
    tat_always = 2
} ;
#line 35 "/home/khheo/project/mit-scheme-9.2/src/microcode/prim.h"
typedef SCHEME_OBJECT (*primitive_procedure_t)(void);
#line 207 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.h"
enum __anonenum_linkage_section_type_t_39 {
    LINKAGE_SECTION_TYPE_OPERATOR = 0,
    LINKAGE_SECTION_TYPE_REFERENCE = 1,
    LINKAGE_SECTION_TYPE_ASSIGNMENT = 2,
    LINKAGE_SECTION_TYPE_GLOBAL_OPERATOR = 3,
    N_LINKAGE_SECTION_TYPES = 4
} ;
#line 207 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.h"
typedef enum __anonenum_linkage_section_type_t_39 linkage_section_type_t;
#line 339
enum __anonenum_trampoline_type_t_40 {
    TRAMPOLINE_K_RETURN_TO_INTERPRETER = 0,
    TRAMPOLINE_K_APPLY = 1,
    TRAMPOLINE_K_ARITY = 2,
    TRAMPOLINE_K_ENTITY = 3,
    TRAMPOLINE_K_INTERPRETED = 4,
    TRAMPOLINE_K_LEXPR_PRIMITIVE = 5,
    TRAMPOLINE_K_PRIMITIVE = 6,
    TRAMPOLINE_K_LOOKUP = 7,
    TRAMPOLINE_K_1_0 = 8,
    TRAMPOLINE_K_2_1 = 9,
    TRAMPOLINE_K_2_0 = 10,
    TRAMPOLINE_K_3_2 = 11,
    TRAMPOLINE_K_3_1 = 12,
    TRAMPOLINE_K_3_0 = 13,
    TRAMPOLINE_K_4_3 = 14,
    TRAMPOLINE_K_4_2 = 15,
    TRAMPOLINE_K_4_1 = 16,
    TRAMPOLINE_K_4_0 = 17,
    TRAMPOLINE_K_REFLECT_TO_INTERFACE = 58
} ;
#line 339 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.h"
typedef enum __anonenum_trampoline_type_t_40 trampoline_type_t;
#line 365 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.h"
union __anonunion_extra_42 {
   long code_to_interpreter ;
   insn_t *entry_point ;
};
#line 365 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.h"
struct __anonstruct_utility_result_t_41 {
   void *interface_dispatch ;
   union __anonunion_extra_42 extra ;
};
#line 365 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.h"
typedef struct __anonstruct_utility_result_t_41 utility_result_t;
#line 383 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.h"
typedef void utility_proc_t(utility_result_t * , unsigned long  , unsigned long  ,
                            unsigned long  , unsigned long  );
#line 54 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
typedef long cache_handler_t(SCHEME_OBJECT  , SCHEME_OBJECT  , unsigned long  );
#line 56 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
struct __anonstruct_link_cc_state_t_43 {
   SCHEME_OBJECT *block_address ;
   SCHEME_OBJECT *scan ;
   unsigned long n_sections ;
   insn_t *return_address ;
   unsigned long n_linked_sections ;
   SCHEME_OBJECT *scan0 ;
   linkage_section_type_t type ;
   unsigned long n_entries ;
   unsigned long n_linked_entries ;
};
#line 56 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
typedef struct __anonstruct_link_cc_state_t_43 link_cc_state_t;
#line 165 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
typedef void c_func_t(void);
#line 896 "/usr/include/stdio.h"
struct obstack;
#line 128 "/home/khheo/project/mit-scheme-9.2/src/microcode/obstack.h"
struct _obstack_chunk {
   char *limit ;
   struct _obstack_chunk *prev ;
   char contents[4] ;
};
#line 135 "/home/khheo/project/mit-scheme-9.2/src/microcode/obstack.h"
struct obstack {
   long chunk_size ;
   struct _obstack_chunk *chunk ;
   char *object_base ;
   char *next_free ;
   char *chunk_limit ;
   long temp ;
   long alignment_mask ;
   struct _obstack_chunk *(*chunkfun)(long  ) ;
   void (*freefun)(void * ) ;
};
#line 75 "/usr/include/x86_64-linux-gnu/bits/fenv.h"
struct __anonstruct_fenv_t_45 {
   unsigned short __control_word ;
   unsigned short __glibc_reserved1 ;
   unsigned short __status_word ;
   unsigned short __glibc_reserved2 ;
   unsigned short __tags ;
   unsigned short __glibc_reserved3 ;
   unsigned int __eip ;
   unsigned short __cs_selector ;
   unsigned int __opcode : 11 ;
   unsigned int __glibc_reserved4 : 5 ;
   unsigned int __data_offset ;
   unsigned short __data_selector ;
   unsigned short __glibc_reserved5 ;
   unsigned int __mxcsr ;
};
#line 75 "/usr/include/x86_64-linux-gnu/bits/fenv.h"
typedef struct __anonstruct_fenv_t_45 fenv_t;
#line 36 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.h"
typedef unsigned long SCM;
#line 54 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.h"
typedef SCM (*CalloutTrampIn)(void);
#line 61 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.h"
typedef void (*CallbackKernel)(void);
#line 127 "/home/khheo/project/mit-scheme-9.2/src/microcode/tterm.c"
struct tc_env {
   char *string_buffer ;
   char *string_pointer ;
};
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 23 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned char cc_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int speed_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int tcflag_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/termios.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 715 "/home/khheo/project/mit-scheme-9.2/src/microcode/ux.h"
struct __anonstruct_Ttty_state_81 {
   struct termios tio ;
};
#line 715 "/home/khheo/project/mit-scheme-9.2/src/microcode/ux.h"
typedef struct __anonstruct_Ttty_state_81 Ttty_state;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ioctl-types.h"
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
#line 32 "/home/khheo/project/mit-scheme-9.2/src/microcode/os.h"
typedef unsigned int Tchannel;
#line 33 "/home/khheo/project/mit-scheme-9.2/src/microcode/osio.h"
enum channel_type {
    channel_type_unknown = 0,
    channel_type_file = 1,
    channel_type_unix_pipe = 2,
    channel_type_unix_fifo = 3,
    channel_type_terminal = 4,
    channel_type_unix_pty_master = 5,
    channel_type_unix_stream_socket = 6,
    channel_type_tcp_stream_socket = 7,
    channel_type_tcp_server_socket = 8,
    channel_type_directory = 9,
    channel_type_unix_character_device = 10,
    channel_type_unix_block_device = 11,
    channel_type_os2_console = 12,
    channel_type_os2_unnamed_pipe = 13,
    channel_type_os2_named_pipe = 14,
    channel_type_win32_anonymous_pipe = 15,
    channel_type_win32_named_pipe = 16
} ;
#line 32 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxio.h"
struct channel {
   int descriptor ;
   enum channel_type type ;
   unsigned int internal : 1 ;
   unsigned int nonblocking : 1 ;
};
#line 39 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __uint16_t;
#line 41 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uint32_t;
#line 44 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uint64_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_2 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_2 __sigset_t;
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef union sigval sigval_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef __clock_t __sigchld_clock_t;
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__kill_45 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__timer_46 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__rt_47 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigchld_48 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __sigchld_clock_t si_utime ;
   __sigchld_clock_t si_stime ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigfault_49 {
   void *si_addr ;
   short si_addr_lsb ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigpoll_50 {
   long si_band ;
   int si_fd ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigsys_51 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union __anonunion__sifields_44 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_45 _kill ;
   struct __anonstruct__timer_46 _timer ;
   struct __anonstruct__rt_47 _rt ;
   struct __anonstruct__sigchld_48 _sigchld ;
   struct __anonstruct__sigfault_49 _sigfault ;
   struct __anonstruct__sigpoll_50 _sigpoll ;
   struct __anonstruct__sigsys_51 _sigsys ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct_siginfo_t_43 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_44 _sifields ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef struct __anonstruct_siginfo_t_43 siginfo_t;
#line 49 "/usr/include/x86_64-linux-gnu/bits/sigstack.h"
struct sigaltstack {
   void *ss_sp ;
   int ss_flags ;
   size_t ss_size ;
};
#line 49 "/usr/include/x86_64-linux-gnu/bits/sigstack.h"
typedef struct sigaltstack stack_t;
#line 31 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
typedef long long greg_t;
#line 37 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
typedef greg_t gregset_t[23];
#line 92 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
struct _libc_fpxreg {
   unsigned short significand[4] ;
   unsigned short exponent ;
   unsigned short padding[3] ;
};
#line 99 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
struct _libc_xmmreg {
   __uint32_t element[4] ;
};
#line 104 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
struct _libc_fpstate {
   __uint16_t cwd ;
   __uint16_t swd ;
   __uint16_t ftw ;
   __uint16_t fop ;
   __uint64_t rip ;
   __uint64_t rdp ;
   __uint32_t mxcsr ;
   __uint32_t mxcr_mask ;
   struct _libc_fpxreg _st[8] ;
   struct _libc_xmmreg _xmm[16] ;
   __uint32_t padding[24] ;
};
#line 121 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
typedef struct _libc_fpstate *fpregset_t;
#line 124 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
struct __anonstruct_mcontext_t_67 {
   gregset_t gregs ;
   fpregset_t fpregs ;
   unsigned long long __reserved1[8] ;
};
#line 124 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
typedef struct __anonstruct_mcontext_t_67 mcontext_t;
#line 133 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
struct ucontext {
   unsigned long uc_flags ;
   struct ucontext *uc_link ;
   stack_t uc_stack ;
   mcontext_t uc_mcontext ;
   __sigset_t uc_sigmask ;
   struct _libc_fpstate __fpregs_mem ;
};
#line 133 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
typedef struct ucontext ucontext_t;
#line 819 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxtrap.h"
enum trap_state {
    trap_state_trapped = 0,
    trap_state_exit = 1,
    trap_state_suspend = 2,
    trap_state_query = 3,
    trap_state_recover = 4,
    trap_state_exitting_soft = 5,
    trap_state_exitting_hard = 6
} ;
#line 847 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxtrap.h"
struct trap_recovery_info {
   SCHEME_OBJECT state ;
   SCHEME_OBJECT pc_info_1 ;
   SCHEME_OBJECT pc_info_2 ;
   SCHEME_OBJECT extra_trap_info ;
};
#line 55 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxtrap.c"
struct ux_sig_code_desc {
   int signo ;
   unsigned long code_mask ;
   unsigned long code_value ;
   char const   *name ;
};
#line 77
enum pc_location {
    pcl_heap = 0,
    pcl_constant = 1,
    pcl_builtin = 2,
    pcl_utility = 3,
    pcl_primitive = 4,
    pcl_unknown = 5
} ;
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 120 "/home/khheo/project/mit-scheme-9.2/src/microcode/syscall.h"
enum syserr_names {
    syserr_unknown = 0,
    syserr_address_family_not_supported = 1,
    syserr_address_in_use = 2,
    syserr_address_not_available = 3,
    syserr_arg_list_too_long = 4,
    syserr_bad_address = 5,
    syserr_bad_file_descriptor = 6,
    syserr_broken_pipe = 7,
    syserr_connection_refused = 8,
    syserr_connection_reset = 9,
    syserr_directory_not_empty = 10,
    syserr_domain_error = 11,
    syserr_exec_format_error = 12,
    syserr_file_exists = 13,
    syserr_file_too_large = 14,
    syserr_filename_too_long = 15,
    syserr_function_not_implemented = 16,
    syserr_host_is_unreachable = 17,
    syserr_improper_link = 18,
    syserr_inappropriate_io_control_operation = 19,
    syserr_interrupted_function_call = 20,
    syserr_invalid_argument = 21,
    syserr_invalid_seek = 22,
    syserr_io_error = 23,
    syserr_is_a_directory = 24,
    syserr_no_child_processes = 25,
    syserr_no_locks_available = 26,
    syserr_no_space_left_on_device = 27,
    syserr_no_such_device = 28,
    syserr_no_such_device_or_address = 29,
    syserr_no_such_file_or_directory = 30,
    syserr_no_such_process = 31,
    syserr_not_a_directory = 32,
    syserr_not_enough_space = 33,
    syserr_operation_not_permitted = 34,
    syserr_permission_denied = 35,
    syserr_read_only_file_system = 36,
    syserr_resource_busy = 37,
    syserr_resource_deadlock_avoided = 38,
    syserr_resource_temporarily_unavailable = 39,
    syserr_result_too_large = 40,
    syserr_too_many_links = 41,
    syserr_too_many_open_files = 42,
    syserr_too_many_open_files_in_system = 43
} ;
#line 47
enum syscall_names {
    syscall_accept = 0,
    syscall_bind = 1,
    syscall_chdir = 2,
    syscall_chmod = 3,
    syscall_clock_gettime = 4,
    syscall_close = 5,
    syscall_connect = 6,
    syscall_fcntl_GETFL = 7,
    syscall_fcntl_FULLFSYNC = 8,
    syscall_fcntl_SETFL = 9,
    syscall_fdatasync = 10,
    syscall_fork = 11,
    syscall_fstat = 12,
    syscall_fstatfs = 13,
    syscall_fsync = 14,
    syscall_fsync_range = 15,
    syscall_ftruncate = 16,
    syscall_getcwd = 17,
    syscall_gethostname = 18,
    syscall_gettimeofday = 19,
    syscall_gmtime = 20,
    syscall_ioctl_TIOCGPGRP = 21,
    syscall_ioctl_TIOCSIGSEND = 22,
    syscall_kill = 23,
    syscall_link = 24,
    syscall_listen = 25,
    syscall_localtime = 26,
    syscall_lseek = 27,
    syscall_lstat = 28,
    syscall_malloc = 29,
    syscall_mkdir = 30,
    syscall_mktime = 31,
    syscall_ntp_adjtime = 32,
    syscall_ntp_gettime = 33,
    syscall_open = 34,
    syscall_opendir = 35,
    syscall_pause = 36,
    syscall_pipe = 37,
    syscall_read = 38,
    syscall_readlink = 39,
    syscall_realloc = 40,
    syscall_rename = 41,
    syscall_rmdir = 42,
    syscall_select = 43,
    syscall_setitimer = 44,
    syscall_setpgid = 45,
    syscall_setsockopt = 46,
    syscall_shutdown = 47,
    syscall_sighold = 48,
    syscall_sigprocmask = 49,
    syscall_sigsuspend = 50,
    syscall_sleep = 51,
    syscall_socket = 52,
    syscall_stat = 53,
    syscall_statfs = 54,
    syscall_symlink = 55,
    syscall_sync_file_range = 56,
    syscall_tcdrain = 57,
    syscall_tcflush = 58,
    syscall_tcgetpgrp = 59,
    syscall_tcsetpgrp = 60,
    syscall_terminal_get_state = 61,
    syscall_terminal_set_state = 62,
    syscall_time = 63,
    syscall_times = 64,
    syscall_unlink = 65,
    syscall_utime = 66,
    syscall_vfork = 67,
    syscall_write = 68
} ;
#line 61 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxterm.c"
struct terminal_state {
   int buffer ;
   Ttty_state state ;
};
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 36 "/usr/include/x86_64-linux-gnu/sys/poll.h"
typedef unsigned long nfds_t;
#line 39 "/usr/include/x86_64-linux-gnu/sys/poll.h"
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 90 "/usr/include/x86_64-linux-gnu/sys/socket.h"
struct sockaddr_in;
#line 90
struct sockaddr_un;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 100 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 257 "/usr/include/netdb.h"
struct servent {
   char *s_name ;
   char **s_aliases ;
   int s_port ;
   char *s_proto ;
};
#line 29 "/usr/include/x86_64-linux-gnu/sys/un.h"
struct sockaddr_un {
   sa_family_t sun_family ;
   char sun_path[108] ;
};
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 37 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __sigset_t sigset_t;
#line 32 "/home/khheo/project/mit-scheme-9.2/src/microcode/outf.h"
enum __anonenum_outf_channel_33 {
    CONSOLE_OUTPUT = 0,
    ERROR_OUTPUT = 1,
    FATAL_OUTPUT = 2
} ;
#line 32 "/home/khheo/project/mit-scheme-9.2/src/microcode/outf.h"
typedef enum __anonenum_outf_channel_33 outf_channel;
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion___sigaction_handler_63 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_63 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 315 "/home/khheo/project/mit-scheme-9.2/src/microcode/ux.h"
typedef void Tsignal_handler_result;
#line 322 "/home/khheo/project/mit-scheme-9.2/src/microcode/ux.h"
typedef void (*Tsignal_handler)(int  , siginfo_t * , void * );
#line 32 "/home/khheo/project/mit-scheme-9.2/src/microcode/ossig.h"
enum interrupt_handler {
    interrupt_handler_ignore = 0,
    interrupt_handler_default = 1,
    interrupt_handler_unknown = 2,
    interrupt_handler_terminate = 3,
    interrupt_handler_stop = 4,
    interrupt_handler_interactive = 5,
    interrupt_handler_control_b = 6,
    interrupt_handler_control_g = 7,
    interrupt_handler_control_u = 8,
    interrupt_handler_control_x = 9
} ;
#line 50 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.h"
struct signal_instance {
   int signo ;
   siginfo_t *info ;
   void *pscp ;
};
#line 235 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
enum dfl_action {
    dfl_terminate = 0,
    dfl_ignore = 1,
    dfl_stop = 2
} ;
#line 237 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
struct signal_descriptor {
   int signo ;
   char const   *name ;
   enum dfl_action action ;
   int flags ;
};
#line 32 "/home/khheo/project/mit-scheme-9.2/src/microcode/osproc.h"
typedef unsigned int Tprocess;
#line 34
enum process_status {
    process_status_free = 0,
    process_status_allocated = 1,
    process_status_running = 2,
    process_status_stopped = 3,
    process_status_exited = 4,
    process_status_signalled = 5
} ;
#line 44
enum process_jc_status {
    process_jc_status_no_ctty = 0,
    process_jc_status_unrelated = 1,
    process_jc_status_no_jc = 2,
    process_jc_status_jc = 3
} ;
#line 52
enum process_ctty_type {
    process_ctty_type_none = 0,
    process_ctty_type_inherit_bg = 1,
    process_ctty_type_inherit_fg = 2,
    process_ctty_type_explicit = 3
} ;
#line 68
enum process_channel_type {
    process_channel_type_none = 0,
    process_channel_type_inherit = 1,
    process_channel_type_ctty = 2,
    process_channel_type_explicit = 3
} ;
#line 32 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxproc.h"
struct process {
   pid_t id ;
   long tick ;
   long sync_tick ;
   unsigned short raw_reason ;
   unsigned short reason ;
   enum process_status raw_status ;
   enum process_status status ;
   enum process_jc_status jc_status ;
};
#line 726 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxproc.c"
union __anonunion_82 {
   int __in ;
   int __i ;
};
#line 729 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxproc.c"
union __anonunion_83 {
   int __in ;
   int __i ;
};
#line 732 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxproc.c"
union __anonunion_84 {
   int __in ;
   int __i ;
};
#line 731 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxproc.c"
union __anonunion_85 {
   int __in ;
   int __i ;
};
#line 728 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxproc.c"
union __anonunion_86 {
   int __in ;
   int __i ;
};
#line 725 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxproc.c"
union __anonunion_87 {
   int __in ;
   int __i ;
};
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 86 "/home/khheo/project/mit-scheme-9.2/src/microcode/osio.h"
typedef void *select_registry_t;
#line 428 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxio.c"
struct select_registry_s {
   unsigned int length ;
   unsigned int n_fds ;
   struct pollfd *entries ;
};
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 134 "/usr/include/x86_64-linux-gnu/bits/types.h"
struct __anonstruct___fsid_t_1 {
   int __val[2] ;
};
#line 134 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef struct __anonstruct___fsid_t_1 __fsid_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 162 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsblkcnt_t;
#line 166 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsfilcnt_t;
#line 170 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __fsword_t;
#line 86 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __off_t off_t;
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 32 "/home/khheo/project/mit-scheme-9.2/src/microcode/osfs.h"
enum file_existence {
    file_does_exist = 0,
    file_doesnt_exist = 1,
    file_is_link = 2
} ;
#line 34
enum file_type {
    file_type_nonexistent = -1,
    file_type_regular = 0,
    file_type_directory = 1,
    file_type_unix_symbolic_link = 2,
    file_type_unix_character_device = 3,
    file_type_unix_block_device = 4,
    file_type_unix_fifo = 5,
    file_type_unix_stream_socket = 6,
    file_type_os2_named_pipe = 7,
    file_type_win32_named_pipe = 8,
    file_type_unknown = 65535
} ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/statfs.h"
struct statfs {
   __fsword_t f_type ;
   __fsword_t f_bsize ;
   __fsblkcnt_t f_blocks ;
   __fsblkcnt_t f_bfree ;
   __fsblkcnt_t f_bavail ;
   __fsfilcnt_t f_files ;
   __fsfilcnt_t f_ffree ;
   __fsid_t f_fsid ;
   __fsword_t f_namelen ;
   __fsword_t f_frsize ;
   __fsword_t f_flags ;
   __fsword_t f_spare[4] ;
};
#line 70 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __mode_t mode_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 59 "/usr/include/time.h"
typedef __clock_t clock_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 91
enum __itimer_which {
    ITIMER_REAL = 0,
    ITIMER_VIRTUAL = 1,
    ITIMER_PROF = 2
} ;
#line 107 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct itimerval {
   struct timeval it_interval ;
   struct timeval it_value ;
};
#line 118 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef enum __itimer_which __itimer_which_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/timex.h"
struct timex {
   unsigned int modes ;
   __syscall_slong_t offset ;
   __syscall_slong_t freq ;
   __syscall_slong_t maxerror ;
   __syscall_slong_t esterror ;
   int status ;
   __syscall_slong_t constant ;
   __syscall_slong_t precision ;
   __syscall_slong_t tolerance ;
   struct timeval time ;
   __syscall_slong_t tick ;
   __syscall_slong_t ppsfreq ;
   __syscall_slong_t jitter ;
   int shift ;
   __syscall_slong_t stabil ;
   __syscall_slong_t jitcnt ;
   __syscall_slong_t calcnt ;
   __syscall_slong_t errcnt ;
   __syscall_slong_t stbcnt ;
   int tai ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
};
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 134 "/usr/include/stdint.h"
typedef long intmax_t;
#line 135 "/usr/include/stdint.h"
typedef unsigned long uintmax_t;
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 34 "/usr/include/x86_64-linux-gnu/sys/times.h"
struct tms {
   clock_t tms_utime ;
   clock_t tms_stime ;
   clock_t tms_cutime ;
   clock_t tms_cstime ;
};
#line 32 "/home/khheo/project/mit-scheme-9.2/src/microcode/osenv.h"
struct time_structure {
   unsigned int year ;
   unsigned int month ;
   unsigned int day ;
   unsigned int hour ;
   unsigned int minute ;
   unsigned int second ;
   unsigned int day_of_week ;
   int daylight_savings_time ;
   int time_zone ;
};
#line 45 "/home/khheo/project/mit-scheme-9.2/src/microcode/osenv.h"
struct scheme_nanotime {
   intmax_t seconds ;
   uint32_t nanoseconds ;
};
#line 36 "/home/khheo/project/mit-scheme-9.2/src/microcode/osctty.h"
typedef unsigned int Tinterrupt_enables;
#line 57 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxctty.c"
struct terminal_state_recording {
   int fd ;
   int recorded_p ;
   Ttty_state state ;
   int flags ;
};
#line 259 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxctty.c"
struct __anonstruct_Tinterrupt_chars_71 {
   cc_t quit ;
   cc_t intrpt ;
   cc_t tstp ;
   cc_t dtstp ;
};
#line 259 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxctty.c"
typedef struct __anonstruct_Tinterrupt_chars_71 Tinterrupt_chars;
#line 37 "/usr/include/utime.h"
struct utimbuf {
   __time_t actime ;
   __time_t modtime ;
};
#line 42 "/usr/include/grp.h"
struct group {
   char *gr_name ;
   char *gr_passwd ;
   __gid_t gr_gid ;
   char **gr_mem ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/setjmp.h"
typedef long __jmp_buf[8];
#line 34 "/usr/include/setjmp.h"
struct __jmp_buf_tag {
   __jmp_buf __jmpbuf ;
   int __mask_was_saved ;
   __sigset_t __saved_mask ;
};
#line 48 "/usr/include/setjmp.h"
typedef struct __jmp_buf_tag jmp_buf[1];
#line 32 "/home/khheo/project/mit-scheme-9.2/src/microcode/intext.h"
struct interruptable_extent {
   void *position ;
   jmp_buf control_point ;
   int interrupted ;
};
#line 48 "/home/khheo/project/mit-scheme-9.2/src/microcode/wind.c"
struct winding_record {
   struct winding_record *next ;
   void (*protector)(void *environment ) ;
   void *environment ;
};
#line 162 "/home/khheo/project/mit-scheme-9.2/src/microcode/wind.c"
struct binding_record {
   void **location ;
   void *value ;
};
#line 34 "/home/khheo/project/mit-scheme-9.2/src/microcode/gc.h"
enum __anonenum_gc_type_t_31 {
    GC_COMPILED = -4,
    GC_VECTOR = -3,
    GC_SPECIAL = -2,
    GC_UNDEFINED = -1,
    GC_NON_POINTER = 0,
    GC_CELL = 1,
    GC_PAIR = 2,
    GC_TRIPLE = 3,
    GC_QUADRUPLE = 4
} ;
#line 34 "/home/khheo/project/mit-scheme-9.2/src/microcode/gc.h"
typedef enum __anonenum_gc_type_t_31 gc_type_t;
#line 34 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.h"
typedef SCHEME_OBJECT bignum_type;
#line 41 "/home/khheo/project/mit-scheme-9.2/src/microcode/transact.c"
enum transaction_state {
    active = 0,
    aborting = 1,
    committing = 2
} ;
#line 43 "/home/khheo/project/mit-scheme-9.2/src/microcode/transact.c"
struct transaction {
   void *checkpoint ;
   enum transaction_state state ;
};
#line 97 "/home/khheo/project/mit-scheme-9.2/src/microcode/transact.c"
struct action {
   enum transaction_action_type type ;
   void (*procedure)(void *environment ) ;
   void *environment ;
};
#line 139 "/home/khheo/project/mit-scheme-9.2/src/microcode/interp.h"
struct interpreter_state_s;
#line 139 "/home/khheo/project/mit-scheme-9.2/src/microcode/interp.h"
typedef struct interpreter_state_s *interpreter_state_t;
#line 141 "/home/khheo/project/mit-scheme-9.2/src/microcode/interp.h"
struct interpreter_state_s {
   interpreter_state_t previous_state ;
   unsigned int nesting_level ;
   void *dstack_position ;
   jmp_buf catch_env ;
   int throw_argument ;
};
#line 72 "/home/khheo/project/mit-scheme-9.2/src/microcode/syntax.h"
enum syntaxcode {
    syntaxcode_whitespace = 0,
    syntaxcode_punct = 1,
    syntaxcode_word = 2,
    syntaxcode_symbol = 3,
    syntaxcode_open = 4,
    syntaxcode_close = 5,
    syntaxcode_quote = 6,
    syntaxcode_string = 7,
    syntaxcode_math = 8,
    syntaxcode_escape = 9,
    syntaxcode_charquote = 10,
    syntaxcode_comment = 11,
    syntaxcode_endcomment = 12,
    syntaxcode_max = 13
} ;
#line 724 "/home/khheo/project/mit-scheme-9.2/src/microcode/syntax.c"
struct levelstruct {
   unsigned char *last ;
   unsigned char *previous ;
};
#line 512 "/home/khheo/project/mit-scheme-9.2/src/microcode/string.c"
struct ht_record_s;
#line 512 "/home/khheo/project/mit-scheme-9.2/src/microcode/string.c"
typedef struct ht_record_s ht_record_t;
#line 513 "/home/khheo/project/mit-scheme-9.2/src/microcode/string.c"
struct ht_record_s {
   ht_record_t *next ;
   unsigned long n_bytes ;
};
#line 524 "/home/khheo/project/mit-scheme-9.2/src/microcode/string.c"
struct __anonstruct_hash_table_t_43 {
   unsigned long n_records ;
   unsigned long n_buckets ;
   ht_record_t **buckets ;
};
#line 524 "/home/khheo/project/mit-scheme-9.2/src/microcode/string.c"
typedef struct __anonstruct_hash_table_t_43 hash_table_t;
#line 71 "/home/khheo/project/mit-scheme-9.2/src/microcode/regex.h"
struct re_buffer {
   unsigned char *translation ;
   SCHEME_OBJECT syntax_table ;
   unsigned char *text ;
   unsigned char *text_start ;
   unsigned char *text_end ;
   unsigned char *gap_start ;
   unsigned char *gap_end ;
};
#line 94 "/home/khheo/project/mit-scheme-9.2/src/microcode/regex.h"
struct re_registers {
   long start[10] ;
   long end[10] ;
};
#line 106
enum regexpcode {
    regexpcode_unused = 0,
    regexpcode_exact_1 = 1,
    regexpcode_exact_n = 2,
    regexpcode_line_start = 3,
    regexpcode_line_end = 4,
    regexpcode_jump = 5,
    regexpcode_on_failure_jump = 6,
    regexpcode_finalize_jump = 7,
    regexpcode_maybe_finalize_jump = 8,
    regexpcode_dummy_failure_jump = 9,
    regexpcode_any_char = 10,
    regexpcode_char_set = 11,
    regexpcode_not_char_set = 12,
    regexpcode_start_memory = 13,
    regexpcode_stop_memory = 14,
    regexpcode_duplicate = 15,
    regexpcode_buffer_start = 16,
    regexpcode_buffer_end = 17,
    regexpcode_word_char = 18,
    regexpcode_not_word_char = 19,
    regexpcode_word_start = 20,
    regexpcode_word_end = 21,
    regexpcode_word_bound = 22,
    regexpcode_not_word_bound = 23,
    regexpcode_syntax_spec = 24,
    regexpcode_not_syntax_spec = 25
} ;
#line 44 "/home/khheo/project/mit-scheme-9.2/src/microcode/gccode.h"
typedef SCHEME_OBJECT *gc_handler_t(SCHEME_OBJECT * , SCHEME_OBJECT  );
#line 51 "/home/khheo/project/mit-scheme-9.2/src/microcode/gccode.h"
typedef SCHEME_OBJECT gc_tuple_handler_t(SCHEME_OBJECT  , unsigned int  );
#line 58 "/home/khheo/project/mit-scheme-9.2/src/microcode/gccode.h"
typedef SCHEME_OBJECT gc_vector_handler_t(SCHEME_OBJECT  , _Bool  );
#line 65 "/home/khheo/project/mit-scheme-9.2/src/microcode/gccode.h"
typedef SCHEME_OBJECT gc_object_handler_t(SCHEME_OBJECT  );
#line 72 "/home/khheo/project/mit-scheme-9.2/src/microcode/gccode.h"
typedef SCHEME_OBJECT *gc_precheck_from_t(SCHEME_OBJECT * );
#line 78 "/home/khheo/project/mit-scheme-9.2/src/microcode/gccode.h"
typedef SCHEME_OBJECT *gc_transport_words_t(SCHEME_OBJECT * , unsigned long  , _Bool  );
#line 85 "/home/khheo/project/mit-scheme-9.2/src/microcode/gccode.h"
typedef _Bool gc_ignore_object_p_t(SCHEME_OBJECT  );
#line 91 "/home/khheo/project/mit-scheme-9.2/src/microcode/gccode.h"
typedef SCHEME_OBJECT gc_raw_address_to_object_t(unsigned int  , SCHEME_OBJECT * );
#line 93 "/home/khheo/project/mit-scheme-9.2/src/microcode/gccode.h"
typedef SCHEME_OBJECT *gc_object_to_raw_address_t(SCHEME_OBJECT  );
#line 94 "/home/khheo/project/mit-scheme-9.2/src/microcode/gccode.h"
typedef SCHEME_OBJECT gc_raw_address_to_cc_entry_t(insn_t * );
#line 95 "/home/khheo/project/mit-scheme-9.2/src/microcode/gccode.h"
typedef insn_t *gc_cc_entry_to_raw_address_t(SCHEME_OBJECT  );
#line 97 "/home/khheo/project/mit-scheme-9.2/src/microcode/gccode.h"
struct __anonstruct_gc_table_t_46 {
   gc_handler_t *handlers[64] ;
   gc_tuple_handler_t *tuple_handler ;
   gc_vector_handler_t *vector_handler ;
   gc_object_handler_t *cc_entry_handler ;
   gc_precheck_from_t *precheck_from ;
   gc_transport_words_t *transport_words ;
   gc_ignore_object_p_t *ignore_object_p ;
   gc_raw_address_to_object_t *raw_address_to_object ;
   gc_object_to_raw_address_t *object_to_raw_address ;
   gc_raw_address_to_cc_entry_t *raw_address_to_cc_entry ;
   gc_cc_entry_to_raw_address_t *cc_entry_to_raw_address ;
};
#line 97 "/home/khheo/project/mit-scheme-9.2/src/microcode/gccode.h"
typedef struct __anonstruct_gc_table_t_46 gc_table_t;
#line 79 "/home/khheo/project/mit-scheme-9.2/src/microcode/dstack.h"
typedef unsigned long Tptrvec_index;
#line 80 "/home/khheo/project/mit-scheme-9.2/src/microcode/dstack.h"
typedef unsigned long Tptrvec_length;
#line 82 "/home/khheo/project/mit-scheme-9.2/src/microcode/dstack.h"
struct struct_ptrvec {
   Tptrvec_length length ;
   void **elements ;
};
#line 87 "/home/khheo/project/mit-scheme-9.2/src/microcode/dstack.h"
typedef struct struct_ptrvec *Tptrvec;
#line 328 "/home/khheo/project/mit-scheme-9.2/src/microcode/extern.h"
struct __anonstruct_prim_renumber_t_34 {
   unsigned long *internal ;
   unsigned long *external ;
   unsigned long next_code ;
};
#line 328 "/home/khheo/project/mit-scheme-9.2/src/microcode/extern.h"
typedef struct __anonstruct_prim_renumber_t_34 prim_renumber_t;
#line 32 "/home/khheo/project/mit-scheme-9.2/src/microcode/prename.h"
struct primitive_alias_s {
   char const   *alias ;
   char const   *name ;
};
#line 40 "/home/khheo/project/mit-scheme-9.2/src/microcode/avltree.h"
struct tree_node_s;
#line 40 "/home/khheo/project/mit-scheme-9.2/src/microcode/avltree.h"
typedef struct tree_node_s *tree_node;
#line 42 "/home/khheo/project/mit-scheme-9.2/src/microcode/avltree.h"
struct tree_node_s {
   int height ;
   tree_node left ;
   tree_node rite ;
   char const   *name ;
   unsigned long value ;
};
#line 197 "/home/khheo/project/mit-scheme-9.2/src/microcode/confshared.h"
enum __anonenum_fasl_arch_t_29 {
    FASL_UNKNOWN = 0,
    FASL_PDP10 = 1,
    FASL_VAX = 2,
    FASL_68020 = 3,
    FASL_68000 = 4,
    FASL_HP_9000_500 = 5,
    FASL_IA32 = 6,
    FASL_BFLY = 7,
    FASL_CYBER = 8,
    FASL_CELERITY = 9,
    FASL_HP_SPECTRUM = 10,
    FASL_UMAX = 11,
    FASL_PYR = 12,
    FASL_ALLIANT = 13,
    FASL_SPARC = 14,
    FASL_MIPS = 15,
    FASL_APOLLO_68K = 16,
    FASL_APOLLO_PRISM = 17,
    FASL_ALPHA = 18,
    FASL_RS6000 = 19,
    FASL_PPC32 = 20,
    FASL_X86_64 = 21,
    FASL_PPC64 = 22,
    FASL_IA64 = 23,
    FASL_ARM = 24
} ;
#line 197 "/home/khheo/project/mit-scheme-9.2/src/microcode/confshared.h"
typedef enum __anonenum_fasl_arch_t_29 fasl_arch_t;
#line 96 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasl.h"
enum __anonenum_fasl_version_t_43 {
    FASL_VERSION_NONE = 0,
    FASL_VERSION_LONG_HEADER = 3,
    FASL_VERSION_DENSE_TYPES = 4,
    FASL_VERSION_PADDED_STRINGS = 5,
    FASL_VERSION_REFERENCE_TRAP = 6,
    FASL_VERSION_MERGED_PRIMITIVES = 7,
    FASL_VERSION_INTERFACE_VERSION = 8,
    FASL_VERSION_NEW_BIGNUMS = 9,
    FASL_VERSION_C_CODE = 10,
    FASL_VERSION_STACK_END = 11,
    FASL_VERSION_EPHEMERONS = 12
} ;
#line 96 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasl.h"
typedef enum __anonenum_fasl_version_t_43 fasl_version_t;
#line 119 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasl.h"
struct __anonstruct_fasl_header_t_44 {
   fasl_version_t version ;
   fasl_arch_t arch ;
   unsigned int cc_version ;
   cc_arch_t cc_arch ;
   _Bool band_p ;
   SCHEME_OBJECT *memory_base ;
   SCHEME_OBJECT *root_pointer ;
   SCHEME_OBJECT *heap_start ;
   SCHEME_OBJECT *heap_end ;
   unsigned long heap_reserved ;
   SCHEME_OBJECT *constant_start ;
   SCHEME_OBJECT *constant_end ;
   SCHEME_OBJECT *stack_start ;
   SCHEME_OBJECT *stack_end ;
   unsigned long n_primitives ;
   unsigned long primitive_table_size ;
   unsigned long n_c_code_blocks ;
   unsigned long c_code_table_size ;
   SCHEME_OBJECT utilities_vector ;
   SCHEME_OBJECT *utilities_start ;
   SCHEME_OBJECT *utilities_end ;
   unsigned long ephemeron_count ;
};
#line 119 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasl.h"
typedef struct __anonstruct_fasl_header_t_44 fasl_header_t;
#line 182
enum __anonenum_fasl_read_status_t_45 {
    FASL_FILE_FINE = 0,
    FASL_FILE_TOO_SHORT = 1,
    FASL_FILE_NOT_FASL = 2,
    FASL_FILE_BAD_MACHINE = 3,
    FASL_FILE_BAD_VERSION = 4,
    FASL_FILE_BAD_SUBVERSION = 5,
    FASL_FILE_BAD_PROCESSOR = 6,
    FASL_FILE_BAD_INTERFACE = 7
} ;
#line 182 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasl.h"
typedef enum __anonenum_fasl_read_status_t_45 fasl_read_status_t;
#line 194 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasl.h"
typedef FILE *fasl_file_handle_t;
#line 386 "/home/khheo/project/mit-scheme-9.2/src/microcode/option.c"
struct option_descriptor {
   char const   *option ;
   _Bool argument_p ;
   void *value_cell ;
};
#line 30 "/home/khheo/project/mit-scheme-9.2/src/microcode/obstack.c"
struct fooalign {
   char x ;
   double d ;
};
#line 36 "/home/khheo/project/mit-scheme-9.2/src/microcode/obstack.c"
union fooround {
   long x ;
   double d ;
};
#line 184 "/home/khheo/project/mit-scheme-9.2/src/microcode/gccode.h"
typedef void gc_tospace_allocator_t(unsigned long  , SCHEME_OBJECT ** , SCHEME_OBJECT ** );
#line 186 "/home/khheo/project/mit-scheme-9.2/src/microcode/gccode.h"
typedef void gc_abort_handler_t(void);
#line 187 "/home/khheo/project/mit-scheme-9.2/src/microcode/gccode.h"
typedef _Bool gc_walk_proc_t(SCHEME_OBJECT * , SCHEME_OBJECT * , void * );
#line 39 "/home/khheo/project/mit-scheme-9.2/src/microcode/trap.h"
typedef unsigned long trap_kind_t;
#line 44 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.h"
enum bignum_comparison {
    bignum_comparison_equal = 0,
    bignum_comparison_less = 1,
    bignum_comparison_greater = 2
} ;
#line 49 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.h"
typedef void *bignum_procedure_context;
#line 61 "/home/khheo/project/mit-scheme-9.2/src/microcode/gc.h"
enum __anonenum_gc_ptr_type_t_33 {
    GC_POINTER_NORMAL = 0,
    GC_POINTER_COMPILED = 1,
    GC_POINTER_NOT = 2
} ;
#line 61 "/home/khheo/project/mit-scheme-9.2/src/microcode/gc.h"
typedef enum __anonenum_gc_ptr_type_t_33 gc_ptr_type_t;
#line 55 "/usr/include/stdint.h"
typedef unsigned long uint64_t;
#line 319 "/home/khheo/project/mit-scheme-9.2/src/microcode/flonum.c"
union __anonunion_double_uint64_t_cast_43 {
   double dbl ;
   uint64_t u64 ;
};
#line 319 "/home/khheo/project/mit-scheme-9.2/src/microcode/flonum.c"
typedef union __anonunion_double_uint64_t_cast_43 double_uint64_t_cast;
#line 363 "/home/khheo/project/mit-scheme-9.2/src/microcode/flonum.c"
union __anonunion_float_uint32_t_cast_44 {
   float f ;
   uint32_t u32 ;
};
#line 363 "/home/khheo/project/mit-scheme-9.2/src/microcode/flonum.c"
typedef union __anonunion_float_uint32_t_cast_44 float_uint32_t_cast;
#line 68 "/usr/include/x86_64-linux-gnu/bits/fenv.h"
typedef unsigned short fexcept_t;
#line 56 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasload.c"
struct load_band_termination_state {
   char const   *file_name ;
   _Bool no_return_p ;
};
#line 62 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasload.c"
typedef void (*cleanup_t)(void);
#line 65 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasdump.c"
enum __anonenum_env_mode_t_47 {
    FE_ERROR = 0,
    FE_DUMP = 1,
    FE_DROP_CC = 2
} ;
#line 65 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasdump.c"
typedef enum __anonenum_env_mode_t_47 env_mode_t;
#line 67 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasdump.c"
struct __anonstruct_fasl_file_info_t_48 {
   char const   *filename ;
   fasl_file_handle_t handle ;
};
#line 67 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasdump.c"
typedef struct __anonstruct_fasl_file_info_t_48 fasl_file_info_t;
#line 481 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasdump.c"
struct __anonstruct_fixup_t_49 {
   SCHEME_OBJECT *addr ;
   SCHEME_OBJECT object ;
};
#line 481 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasdump.c"
typedef struct __anonstruct_fixup_t_49 fixup_t;
#line 108 "/home/khheo/project/mit-scheme-9.2/src/microcode/dstack.h"
struct condition_type;
#line 108 "/home/khheo/project/mit-scheme-9.2/src/microcode/dstack.h"
typedef struct condition_type *Tcondition_type;
#line 109
struct condition;
#line 109 "/home/khheo/project/mit-scheme-9.2/src/microcode/dstack.h"
typedef struct condition *Tcondition;
#line 110
struct condition_restart;
#line 110 "/home/khheo/project/mit-scheme-9.2/src/microcode/dstack.h"
typedef struct condition_restart *Tcondition_restart;
#line 112 "/home/khheo/project/mit-scheme-9.2/src/microcode/dstack.h"
struct condition_type {
   unsigned long index ;
   void *name ;
   Tptrvec generalizations ;
   void (*reporter)(Tcondition  ) ;
};
#line 124 "/home/khheo/project/mit-scheme-9.2/src/microcode/dstack.h"
struct condition {
   Tcondition_type type ;
   Tptrvec irritants ;
};
#line 132 "/home/khheo/project/mit-scheme-9.2/src/microcode/dstack.h"
struct condition_restart {
   void *name ;
   Tcondition_type type ;
   void (*procedure)(void * ) ;
};
#line 34 "/home/khheo/project/mit-scheme-9.2/src/microcode/error.c"
struct handler_record {
   struct handler_record *next ;
   Tcondition_type type ;
   void (*handler)(Tcondition  ) ;
};
#line 41 "/home/khheo/project/mit-scheme-9.2/src/microcode/error.c"
struct restart_record {
   struct restart_record *next ;
   struct condition_restart contents ;
};
#line 599 "/home/khheo/project/mit-scheme-9.2/src/microcode/bitstr.c"
struct bitstr_to_bignm_context {
   unsigned char *source_ptr ;
   unsigned int mask ;
};
#line 37 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignmint.h"
typedef long bignum_digit_type;
#line 38 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignmint.h"
typedef long bignum_length_type;
#line 90 "/home/khheo/project/mit-scheme-9.2/src/microcode/prims.h"
 __attribute__((__noreturn__)) void signal_error_from_primitive(long error_code ) ;
#line 35 "/home/khheo/project/mit-scheme-9.2/src/microcode/usrdef.h"
SCHEME_OBJECT (*Static_Primitive_Procedure_Table[655])(void) ;
#line 36
int Static_Primitive_Arity_Table[655] ;
#line 37
int Static_Primitive_Count_Table[655] ;
#line 38
char const   *Static_Primitive_Name_Table[655] ;
#line 39
char const   *Static_Primitive_Documentation_Table[655] ;
#line 40
long MAX_STATIC_PRIMITIVE ;
#line 7 "/home/khheo/project/mit-scheme-9.2/src/microcode/usrdef.c"
long MAX_STATIC_PRIMITIVE  =    653L;
#line 9
SCHEME_OBJECT Prim_bignum_zero_p(void) ;
#line 9
SCHEME_OBJECT Prim_bignum_negative_p(void) ;
#line 9
SCHEME_OBJECT Prim_bignum_positive_p(void) ;
#line 9
SCHEME_OBJECT Prim_bignum_equal_p(void) ;
#line 9
SCHEME_OBJECT Prim_bignum_less_p(void) ;
#line 9
SCHEME_OBJECT Prim_bignum_add(void) ;
#line 9
SCHEME_OBJECT Prim_bignum_subtract(void) ;
#line 9
SCHEME_OBJECT Prim_bignum_multiply(void) ;
#line 9
SCHEME_OBJECT Prim_bignum_divide(void) ;
#line 9
SCHEME_OBJECT Prim_bignum_quotient(void) ;
#line 9
SCHEME_OBJECT Prim_bignum_remainder(void) ;
#line 9
SCHEME_OBJECT Prim_listify_bignum(void) ;
#line 9
SCHEME_OBJECT Prim_fixnum_to_bignum(void) ;
#line 9
SCHEME_OBJECT Prim_bignum_to_fixnum(void) ;
#line 9
SCHEME_OBJECT Prim_flonum_to_bignum(void) ;
#line 9
SCHEME_OBJECT Prim_bignum_to_flonum(void) ;
#line 9
SCHEME_OBJECT Prim_bignum_length_in_bits(void) ;
#line 9
SCHEME_OBJECT Prim_bit_string_allocate(void) ;
#line 9
SCHEME_OBJECT Prim_bit_string_p(void) ;
#line 9
SCHEME_OBJECT Prim_make_bit_string(void) ;
#line 9
SCHEME_OBJECT Prim_bit_string_fill_x(void) ;
#line 9
SCHEME_OBJECT Prim_bit_string_length(void) ;
#line 9
SCHEME_OBJECT Prim_bit_string_ref(void) ;
#line 9
SCHEME_OBJECT Prim_bit_string_clear_x(void) ;
#line 9
SCHEME_OBJECT Prim_bit_string_set_x(void) ;
#line 9
SCHEME_OBJECT Prim_bit_string_zero_p(void) ;
#line 9
SCHEME_OBJECT Prim_bit_string_equal_p(void) ;
#line 9
SCHEME_OBJECT Prim_bit_string_move_x(void) ;
#line 9
SCHEME_OBJECT Prim_bit_string_movec_x(void) ;
#line 9
SCHEME_OBJECT Prim_bit_string_or_x(void) ;
#line 9
SCHEME_OBJECT Prim_bit_string_and_x(void) ;
#line 9
SCHEME_OBJECT Prim_bit_string_andc_x(void) ;
#line 9
SCHEME_OBJECT Prim_bit_string_xor_x(void) ;
#line 9
SCHEME_OBJECT Prim_bit_substring_move_right_x(void) ;
#line 9
SCHEME_OBJECT Prim_unsigned_to_bit_string(void) ;
#line 9
SCHEME_OBJECT Prim_bit_string_to_unsigned(void) ;
#line 9
SCHEME_OBJECT Prim_read_bits_x(void) ;
#line 9
SCHEME_OBJECT Prim_write_bits_x(void) ;
#line 9
SCHEME_OBJECT Prim_bitstr_find_next_set_bit(void) ;
#line 9
SCHEME_OBJECT Prim_microcode_identify(void) ;
#line 9
SCHEME_OBJECT Prim_microcode_library_path(void) ;
#line 9
SCHEME_OBJECT Prim_get_command_line(void) ;
#line 9
SCHEME_OBJECT Prim_get_unused_command_line(void) ;
#line 9
SCHEME_OBJECT Prim_reload_save_string(void) ;
#line 9
SCHEME_OBJECT Prim_reload_retrieve_string(void) ;
#line 9
SCHEME_OBJECT Prim_batch_mode_p(void) ;
#line 9
SCHEME_OBJECT Prim_char_p(void) ;
#line 9
SCHEME_OBJECT Prim_make_char(void) ;
#line 9
SCHEME_OBJECT Prim_char_bits(void) ;
#line 9
SCHEME_OBJECT Prim_char_code(void) ;
#line 9
SCHEME_OBJECT Prim_char_to_integer(void) ;
#line 9
SCHEME_OBJECT Prim_integer_to_char(void) ;
#line 9
SCHEME_OBJECT Prim_char_downcase(void) ;
#line 9
SCHEME_OBJECT Prim_char_upcase(void) ;
#line 9
SCHEME_OBJECT Prim_ascii_to_char(void) ;
#line 9
SCHEME_OBJECT Prim_char_to_ascii(void) ;
#line 9
SCHEME_OBJECT Prim_char_ascii_p(void) ;
#line 9
SCHEME_OBJECT Prim_close_lost_open_files(void) ;
#line 9
SCHEME_OBJECT Prim_rehash(void) ;
#line 9
SCHEME_OBJECT Prim_debugging_printer(void) ;
#line 9
SCHEME_OBJECT Prim_verify_heap(void) ;
#line 9
SCHEME_OBJECT Prim_set_debug_flags(void) ;
#line 9
SCHEME_OBJECT Prim_floating_vector_cons(void) ;
#line 9
SCHEME_OBJECT Prim_floating_vector_ref(void) ;
#line 9
SCHEME_OBJECT Prim_floating_vector_set(void) ;
#line 9
SCHEME_OBJECT Prim_floating_vector_length(void) ;
#line 9
SCHEME_OBJECT Prim_map_code_to_address(void) ;
#line 9
SCHEME_OBJECT Prim_map_address_to_code(void) ;
#line 9
SCHEME_OBJECT Prim_primitive_procedure_arity(void) ;
#line 9
SCHEME_OBJECT Prim_primitive_procedure_doc(void) ;
#line 9
SCHEME_OBJECT Prim_get_primitive_counts(void) ;
#line 9
SCHEME_OBJECT Prim_get_primitive_name(void) ;
#line 9
SCHEME_OBJECT Prim_get_primitive_address(void) ;
#line 9
SCHEME_OBJECT Prim_prim_fasdump(void) ;
#line 9
SCHEME_OBJECT Prim_band_dump(void) ;
#line 9
SCHEME_OBJECT Prim_binary_fasload(void) ;
#line 9
SCHEME_OBJECT Prim_band_load(void) ;
#line 9
SCHEME_OBJECT Prim_reload_band_name(void) ;
#line 9
SCHEME_OBJECT Prim_zero_fixnum_p(void) ;
#line 9
SCHEME_OBJECT Prim_index_fixnum_p(void) ;
#line 9
SCHEME_OBJECT Prim_zero_fixnum(void) ;
#line 9
SCHEME_OBJECT Prim_negative_fixnum(void) ;
#line 9
SCHEME_OBJECT Prim_positive_fixnum(void) ;
#line 9
SCHEME_OBJECT Prim_equal_fixnum(void) ;
#line 9
SCHEME_OBJECT Prim_less_fixnum(void) ;
#line 9
SCHEME_OBJECT Prim_greater_fixnum(void) ;
#line 9
SCHEME_OBJECT Prim_one_plus_fixnum(void) ;
#line 9
SCHEME_OBJECT Prim_m_1_plus_fixnum(void) ;
#line 9
SCHEME_OBJECT Prim_plus_fixnum(void) ;
#line 9
SCHEME_OBJECT Prim_minus_fixnum(void) ;
#line 9
SCHEME_OBJECT Prim_fixnum_negate(void) ;
#line 9
SCHEME_OBJECT Prim_multiply_fixnum(void) ;
#line 9
SCHEME_OBJECT Prim_divide_fixnum(void) ;
#line 9
SCHEME_OBJECT Prim_fixnum_quotient(void) ;
#line 9
SCHEME_OBJECT Prim_fixnum_remainder(void) ;
#line 9
SCHEME_OBJECT Prim_gcd_fixnum(void) ;
#line 9
SCHEME_OBJECT Prim_fixnum_andc(void) ;
#line 9
SCHEME_OBJECT Prim_fixnum_and(void) ;
#line 9
SCHEME_OBJECT Prim_fixnum_or(void) ;
#line 9
SCHEME_OBJECT Prim_fixnum_xor(void) ;
#line 9
SCHEME_OBJECT Prim_fixnum_not(void) ;
#line 9
SCHEME_OBJECT Prim_fixnum_lsh(void) ;
#line 9
SCHEME_OBJECT Prim_fixnum_to_flonum(void) ;
#line 9
SCHEME_OBJECT Prim_float_environment(void) ;
#line 9
SCHEME_OBJECT Prim_set_float_environment(void) ;
#line 9
SCHEME_OBJECT Prim_defer_float_exception_traps(void) ;
#line 9
SCHEME_OBJECT Prim_update_float_environment(void) ;
#line 9
SCHEME_OBJECT Prim_float_rounding_modes(void) ;
#line 9
SCHEME_OBJECT Prim_get_float_rounding_mode(void) ;
#line 9
SCHEME_OBJECT Prim_set_float_rounding_mode(void) ;
#line 9
SCHEME_OBJECT Prim_float_invalid_operation_exception(void) ;
#line 9
SCHEME_OBJECT Prim_float_divide_by_zero_exception(void) ;
#line 9
SCHEME_OBJECT Prim_float_overflow_exception(void) ;
#line 9
SCHEME_OBJECT Prim_float_underflow_exception(void) ;
#line 9
SCHEME_OBJECT Prim_float_inexact_result_exception(void) ;
#line 9
SCHEME_OBJECT Prim_float_exceptions(void) ;
#line 9
SCHEME_OBJECT Prim_trappable_float_exceptions(void) ;
#line 9
SCHEME_OBJECT Prim_test_float_exceptions(void) ;
#line 9
SCHEME_OBJECT Prim_clear_float_exceptions(void) ;
#line 9
SCHEME_OBJECT Prim_raise_float_exceptions(void) ;
#line 9
SCHEME_OBJECT Prim_save_float_exception_flags(void) ;
#line 9
SCHEME_OBJECT Prim_test_float_exception_flags(void) ;
#line 9
SCHEME_OBJECT Prim_restore_float_exception_flags(void) ;
#line 9
SCHEME_OBJECT Prim_trapped_float_exceptions(void) ;
#line 9
SCHEME_OBJECT Prim_set_trapped_float_exceptions(void) ;
#line 9
SCHEME_OBJECT Prim_untrap_float_exceptions(void) ;
#line 9
SCHEME_OBJECT Prim_trap_float_exceptions(void) ;
#line 9
SCHEME_OBJECT Prim_flonum_add(void) ;
#line 9
SCHEME_OBJECT Prim_flonum_subtract(void) ;
#line 9
SCHEME_OBJECT Prim_flonum_multiply(void) ;
#line 9
SCHEME_OBJECT Prim_flonum_divide(void) ;
#line 9
SCHEME_OBJECT Prim_flonum_modulo(void) ;
#line 9
SCHEME_OBJECT Prim_flonum_negate(void) ;
#line 9
SCHEME_OBJECT Prim_flonum_abs(void) ;
#line 9
SCHEME_OBJECT Prim_flonum_equal_p(void) ;
#line 9
SCHEME_OBJECT Prim_flonum_less_p(void) ;
#line 9
SCHEME_OBJECT Prim_flonum_greater_p(void) ;
#line 9
SCHEME_OBJECT Prim_flonum_zero_p(void) ;
#line 9
SCHEME_OBJECT Prim_flonum_positive_p(void) ;
#line 9
SCHEME_OBJECT Prim_flonum_negative_p(void) ;
#line 9
SCHEME_OBJECT Prim_flonum_expm1(void) ;
#line 9
SCHEME_OBJECT Prim_flonum_log1p(void) ;
#line 9
SCHEME_OBJECT Prim_flonum_log(void) ;
#line 9
SCHEME_OBJECT Prim_flonum_exp(void) ;
#line 9
SCHEME_OBJECT Prim_flonum_sin(void) ;
#line 9
SCHEME_OBJECT Prim_flonum_cos(void) ;
#line 9
SCHEME_OBJECT Prim_flonum_tan(void) ;
#line 9
SCHEME_OBJECT Prim_flonum_asin(void) ;
#line 9
SCHEME_OBJECT Prim_flonum_acos(void) ;
#line 9
SCHEME_OBJECT Prim_flonum_atan(void) ;
#line 9
SCHEME_OBJECT Prim_flonum_atan2(void) ;
#line 9
SCHEME_OBJECT Prim_flonum_sqrt(void) ;
#line 9
SCHEME_OBJECT Prim_flonum_expt(void) ;
#line 9
SCHEME_OBJECT Prim_flonum_p(void) ;
#line 9
SCHEME_OBJECT Prim_flonum_integer_p(void) ;
#line 9
SCHEME_OBJECT Prim_flonum_floor(void) ;
#line 9
SCHEME_OBJECT Prim_flonum_ceiling(void) ;
#line 9
SCHEME_OBJECT Prim_flonum_truncate(void) ;
#line 9
SCHEME_OBJECT Prim_flonum_round(void) ;
#line 9
SCHEME_OBJECT Prim_flonum_truncate_to_exact(void) ;
#line 9
SCHEME_OBJECT Prim_flonum_floor_to_exact(void) ;
#line 9
SCHEME_OBJECT Prim_flonum_ceiling_to_exact(void) ;
#line 9
SCHEME_OBJECT Prim_flonum_round_to_exact(void) ;
#line 9
SCHEME_OBJECT Prim_flonum_normalize(void) ;
#line 9
SCHEME_OBJECT Prim_flonum_denormalize(void) ;
#line 9
SCHEME_OBJECT Prim_cast_ieee754_double_to_integer(void) ;
#line 9
SCHEME_OBJECT Prim_cast_integer_to_ieee754_double(void) ;
#line 9
SCHEME_OBJECT Prim_cast_ieee754_single_to_integer(void) ;
#line 9
SCHEME_OBJECT Prim_cast_integer_to_ieee754_single(void) ;
#line 9
SCHEME_OBJECT Prim_zero(void) ;
#line 9
SCHEME_OBJECT Prim_positive(void) ;
#line 9
SCHEME_OBJECT Prim_negative(void) ;
#line 9
SCHEME_OBJECT Prim_add_one(void) ;
#line 9
SCHEME_OBJECT Prim_subtract_one(void) ;
#line 9
SCHEME_OBJECT Prim_equal_number(void) ;
#line 9
SCHEME_OBJECT Prim_less(void) ;
#line 9
SCHEME_OBJECT Prim_greater(void) ;
#line 9
SCHEME_OBJECT Prim_add(void) ;
#line 9
SCHEME_OBJECT Prim_subtract(void) ;
#line 9
SCHEME_OBJECT Prim_multiply(void) ;
#line 9
SCHEME_OBJECT Prim_divide(void) ;
#line 9
SCHEME_OBJECT Prim_quotient(void) ;
#line 9
SCHEME_OBJECT Prim_remainder(void) ;
#line 9
SCHEME_OBJECT Prim_modulo(void) ;
#line 9
SCHEME_OBJECT Prim_apply(void) ;
#line 9
SCHEME_OBJECT Prim_catch(void) ;
#line 9
SCHEME_OBJECT Prim_within_control_point(void) ;
#line 9
SCHEME_OBJECT Prim_error_procedure(void) ;
#line 9
SCHEME_OBJECT Prim_scode_eval(void) ;
#line 9
SCHEME_OBJECT Prim_force(void) ;
#line 9
SCHEME_OBJECT Prim_get_interrupt_enables(void) ;
#line 9
SCHEME_OBJECT Prim_set_interrupt_enables(void) ;
#line 9
SCHEME_OBJECT Prim_clear_interrupts(void) ;
#line 9
SCHEME_OBJECT Prim_disable_interrupts(void) ;
#line 9
SCHEME_OBJECT Prim_enable_interrupts(void) ;
#line 9
SCHEME_OBJECT Prim_request_interrupts(void) ;
#line 9
SCHEME_OBJECT Prim_return_to_application(void) ;
#line 9
SCHEME_OBJECT Prim_with_stack_marker(void) ;
#line 9
SCHEME_OBJECT Prim_with_interrupt_mask(void) ;
#line 9
SCHEME_OBJECT Prim_with_interrupts_reduced(void) ;
#line 9
SCHEME_OBJECT Prim_set_current_history(void) ;
#line 9
SCHEME_OBJECT Prim_with_history_disabled(void) ;
#line 9
SCHEME_OBJECT Prim_get_fixed_objects_vector(void) ;
#line 9
SCHEME_OBJECT Prim_set_fixed_objects_vector(void) ;
#line 9
SCHEME_OBJECT Prim_hunk3_cons(void) ;
#line 9
SCHEME_OBJECT Prim_hunk3_cxr(void) ;
#line 9
SCHEME_OBJECT Prim_hunk3_set_cxr(void) ;
#line 9
SCHEME_OBJECT Prim_sys_h3_0(void) ;
#line 9
SCHEME_OBJECT Prim_sys_h3_1(void) ;
#line 9
SCHEME_OBJECT Prim_sys_h3_2(void) ;
#line 9
SCHEME_OBJECT Prim_sh3_set_0(void) ;
#line 9
SCHEME_OBJECT Prim_sh3_set_1(void) ;
#line 9
SCHEME_OBJECT Prim_sh3_set_2(void) ;
#line 9
SCHEME_OBJECT Prim_find_symbol(void) ;
#line 9
SCHEME_OBJECT Prim_string_to_symbol(void) ;
#line 9
SCHEME_OBJECT Prim_string_hash(void) ;
#line 9
SCHEME_OBJECT Prim_string_hash_mod(void) ;
#line 9
SCHEME_OBJECT Prim_integer_zero_p(void) ;
#line 9
SCHEME_OBJECT Prim_integer_negative_p(void) ;
#line 9
SCHEME_OBJECT Prim_integer_positive_p(void) ;
#line 9
SCHEME_OBJECT Prim_integer_equal_p(void) ;
#line 9
SCHEME_OBJECT Prim_integer_less_p(void) ;
#line 9
SCHEME_OBJECT Prim_integer_greater_p(void) ;
#line 9
SCHEME_OBJECT Prim_integer_add(void) ;
#line 9
SCHEME_OBJECT Prim_integer_subtract(void) ;
#line 9
SCHEME_OBJECT Prim_integer_multiply(void) ;
#line 9
SCHEME_OBJECT Prim_integer_hamming_distance(void) ;
#line 9
SCHEME_OBJECT Prim_integer_bitwise_and(void) ;
#line 9
SCHEME_OBJECT Prim_integer_bitwise_andc2(void) ;
#line 9
SCHEME_OBJECT Prim_integer_bitwise_andc1(void) ;
#line 9
SCHEME_OBJECT Prim_integer_bitwise_xor(void) ;
#line 9
SCHEME_OBJECT Prim_integer_bitwise_ior(void) ;
#line 9
SCHEME_OBJECT Prim_integer_bitwise_nor(void) ;
#line 9
SCHEME_OBJECT Prim_integer_bitwise_eqv(void) ;
#line 9
SCHEME_OBJECT Prim_integer_bitwise_orc2(void) ;
#line 9
SCHEME_OBJECT Prim_integer_bitwise_orc1(void) ;
#line 9
SCHEME_OBJECT Prim_integer_bitwise_nand(void) ;
#line 9
SCHEME_OBJECT Prim_integer_negate(void) ;
#line 9
SCHEME_OBJECT Prim_integer_add_1(void) ;
#line 9
SCHEME_OBJECT Prim_integer_subtract_1(void) ;
#line 9
SCHEME_OBJECT Prim_integer_length_in_bits(void) ;
#line 9
SCHEME_OBJECT Prim_integer_length(void) ;
#line 9
SCHEME_OBJECT Prim_integer_first_set_bit(void) ;
#line 9
SCHEME_OBJECT Prim_integer_bit_count(void) ;
#line 9
SCHEME_OBJECT Prim_integer_bitwise_not(void) ;
#line 9
SCHEME_OBJECT Prim_integer_divide(void) ;
#line 9
SCHEME_OBJECT Prim_integer_quotient(void) ;
#line 9
SCHEME_OBJECT Prim_integer_remainder(void) ;
#line 9
SCHEME_OBJECT Prim_integer_p(void) ;
#line 9
SCHEME_OBJECT Prim_integer_to_flonum(void) ;
#line 9
SCHEME_OBJECT Prim_integer_nonnegative_one_bits(void) ;
#line 9
SCHEME_OBJECT Prim_integer_negative_zero_bits(void) ;
#line 9
SCHEME_OBJECT Prim_integer_shift_left(void) ;
#line 9
SCHEME_OBJECT Prim_integer_shift_right(void) ;
#line 9
SCHEME_OBJECT Prim_list_to_integer(void) ;
#line 9
SCHEME_OBJECT Prim_pair(void) ;
#line 9
SCHEME_OBJECT Prim_cons(void) ;
#line 9
SCHEME_OBJECT Prim_car(void) ;
#line 9
SCHEME_OBJECT Prim_cdr(void) ;
#line 9
SCHEME_OBJECT Prim_set_car(void) ;
#line 9
SCHEME_OBJECT Prim_set_cdr(void) ;
#line 9
SCHEME_OBJECT Prim_general_car_cdr(void) ;
#line 9
SCHEME_OBJECT Prim_length(void) ;
#line 9
SCHEME_OBJECT Prim_memq(void) ;
#line 9
SCHEME_OBJECT Prim_assq(void) ;
#line 9
SCHEME_OBJECT Prim_sys_pair(void) ;
#line 9
SCHEME_OBJECT Prim_sys_pair_cons(void) ;
#line 9
SCHEME_OBJECT Prim_sys_pair_car(void) ;
#line 9
SCHEME_OBJECT Prim_sys_pair_cdr(void) ;
#line 9
SCHEME_OBJECT Prim_sys_set_car(void) ;
#line 9
SCHEME_OBJECT Prim_sys_set_cdr(void) ;
#line 9
SCHEME_OBJECT Prim_lexical_reference(void) ;
#line 9
SCHEME_OBJECT Prim_local_reference(void) ;
#line 9
SCHEME_OBJECT Prim_lexical_assignment(void) ;
#line 9
SCHEME_OBJECT Prim_local_assignment(void) ;
#line 9
SCHEME_OBJECT Prim_lexical_reference_type(void) ;
#line 9
SCHEME_OBJECT Prim_safe_lexical_reference(void) ;
#line 9
SCHEME_OBJECT Prim_unassigned_test(void) ;
#line 9
SCHEME_OBJECT Prim_unbound_test(void) ;
#line 9
SCHEME_OBJECT Prim_unreferenceable_test(void) ;
#line 9
SCHEME_OBJECT Prim_environment_link_name(void) ;
#line 9
SCHEME_OBJECT Prim_link_variables(void) ;
#line 9
SCHEME_OBJECT Prim_unbind_variable(void) ;
#line 9
SCHEME_OBJECT Prim_garbage_collect(void) ;
#line 9
SCHEME_OBJECT Prim_gc_trace_references(void) ;
#line 9
SCHEME_OBJECT Prim_make_ephemeron(void) ;
#line 9
SCHEME_OBJECT Prim_prim_obj_type(void) ;
#line 9
SCHEME_OBJECT Prim_prim_obj_type_p(void) ;
#line 9
SCHEME_OBJECT Prim_prim_obj_datum(void) ;
#line 9
SCHEME_OBJECT Prim_prim_obj_address(void) ;
#line 9
SCHEME_OBJECT Prim_prim_datum_to_addr(void) ;
#line 9
SCHEME_OBJECT Prim_prim_addr_to_datum(void) ;
#line 9
SCHEME_OBJECT Prim_make_non_ptr_object(void) ;
#line 9
SCHEME_OBJECT Prim_prim_obj_set_type(void) ;
#line 9
SCHEME_OBJECT Prim_prim_obj_eq_p(void) ;
#line 9
SCHEME_OBJECT Prim_prim_make_obj(void) ;
#line 9
SCHEME_OBJECT Prim_prim_obj_to_integer(void) ;
#line 9
SCHEME_OBJECT Prim_prim_integer_to_obj(void) ;
#line 9
SCHEME_OBJECT Prim_prim_obj_ref(void) ;
#line 9
SCHEME_OBJECT Prim_prim_obj_set(void) ;
#line 9
SCHEME_OBJECT Prim_object_type(void) ;
#line 9
SCHEME_OBJECT Prim_object_gc_type(void) ;
#line 9
SCHEME_OBJECT Prim_type_to_gc_type(void) ;
#line 9
SCHEME_OBJECT Prim_object_type_p(void) ;
#line 9
SCHEME_OBJECT Prim_object_datum(void) ;
#line 9
SCHEME_OBJECT Prim_object_set_type(void) ;
#line 9
SCHEME_OBJECT Prim_eq(void) ;
#line 9
SCHEME_OBJECT Prim_not(void) ;
#line 9
SCHEME_OBJECT Prim_null_p(void) ;
#line 9
SCHEME_OBJECT Prim_make_cell(void) ;
#line 9
SCHEME_OBJECT Prim_cell_p(void) ;
#line 9
SCHEME_OBJECT Prim_cell_contents(void) ;
#line 9
SCHEME_OBJECT Prim_set_cell_contents(void) ;
#line 9
SCHEME_OBJECT Prim_primitive_purify(void) ;
#line 9
SCHEME_OBJECT Prim_impurify(void) ;
#line 9
SCHEME_OBJECT Prim_constant_p(void) ;
#line 9
SCHEME_OBJECT Prim_pure_p(void) ;
#line 9
SCHEME_OBJECT Prim_re_char_set_adjoin(void) ;
#line 9
SCHEME_OBJECT Prim_re_compile_fastmap(void) ;
#line 9
SCHEME_OBJECT Prim_re_match_substring(void) ;
#line 9
SCHEME_OBJECT Prim_re_search_substr_forward(void) ;
#line 9
SCHEME_OBJECT Prim_re_search_substr_backward(void) ;
#line 9
SCHEME_OBJECT Prim_re_match_buffer(void) ;
#line 9
SCHEME_OBJECT Prim_re_search_buffer_forward(void) ;
#line 9
SCHEME_OBJECT Prim_re_search_buffer_backward(void) ;
#line 9
SCHEME_OBJECT Prim_eval_step(void) ;
#line 9
SCHEME_OBJECT Prim_apply_step(void) ;
#line 9
SCHEME_OBJECT Prim_return_step(void) ;
#line 9
SCHEME_OBJECT Prim_string_allocate(void) ;
#line 9
SCHEME_OBJECT Prim_string_p(void) ;
#line 9
SCHEME_OBJECT Prim_string_length(void) ;
#line 9
SCHEME_OBJECT Prim_string_maximum_length(void) ;
#line 9
SCHEME_OBJECT Prim_set_string_length(void) ;
#line 9
SCHEME_OBJECT Prim_set_string_maximum_length(void) ;
#line 9
SCHEME_OBJECT Prim_string_ref(void) ;
#line 9
SCHEME_OBJECT Prim_vec_8b_ref(void) ;
#line 9
SCHEME_OBJECT Prim_string_set(void) ;
#line 9
SCHEME_OBJECT Prim_vec_8b_set(void) ;
#line 9
SCHEME_OBJECT Prim_substring_move_right(void) ;
#line 9
SCHEME_OBJECT Prim_substring_move_left(void) ;
#line 9
SCHEME_OBJECT Prim_substring_upcase(void) ;
#line 9
SCHEME_OBJECT Prim_substring_downcase(void) ;
#line 9
SCHEME_OBJECT Prim_vec_8b_fill(void) ;
#line 9
SCHEME_OBJECT Prim_vec_8b_find_next_char(void) ;
#line 9
SCHEME_OBJECT Prim_vec_8b_find_prev_char(void) ;
#line 9
SCHEME_OBJECT Prim_vec_8b_find_next_char_ci(void) ;
#line 9
SCHEME_OBJECT Prim_vec_8b_find_prev_char_ci(void) ;
#line 9
SCHEME_OBJECT Prim_find_next_char_in_set(void) ;
#line 9
SCHEME_OBJECT Prim_find_prev_char_in_set(void) ;
#line 9
SCHEME_OBJECT Prim_substring_equal(void) ;
#line 9
SCHEME_OBJECT Prim_substring_ci_equal(void) ;
#line 9
SCHEME_OBJECT Prim_substring_less(void) ;
#line 9
SCHEME_OBJECT Prim_match_forward(void) ;
#line 9
SCHEME_OBJECT Prim_match_forward_ci(void) ;
#line 9
SCHEME_OBJECT Prim_match_backward(void) ;
#line 9
SCHEME_OBJECT Prim_match_backward_ci(void) ;
#line 9
SCHEME_OBJECT Prim_alloc_external_string(void) ;
#line 9
SCHEME_OBJECT Prim_external_string_p(void) ;
#line 9
SCHEME_OBJECT Prim_dealloc_external_string(void) ;
#line 9
SCHEME_OBJECT Prim_extended_string_length(void) ;
#line 9
SCHEME_OBJECT Prim_string_to_syntax_entry(void) ;
#line 9
SCHEME_OBJECT Prim_char_to_syntax_code(void) ;
#line 9
SCHEME_OBJECT Prim_quoted_char_p(void) ;
#line 9
SCHEME_OBJECT Prim_scan_backward_prefix_chars(void) ;
#line 9
SCHEME_OBJECT Prim_scan_forward_prefix_chars(void) ;
#line 9
SCHEME_OBJECT Prim_scan_forward_to_word(void) ;
#line 9
SCHEME_OBJECT Prim_scan_word_forward(void) ;
#line 9
SCHEME_OBJECT Prim_scan_word_backward(void) ;
#line 9
SCHEME_OBJECT Prim_scan_list_forward(void) ;
#line 9
SCHEME_OBJECT Prim_scan_list_backward(void) ;
#line 9
SCHEME_OBJECT Prim_scan_sexps_forward(void) ;
#line 9
SCHEME_OBJECT Prim_non_restartable_exit(void) ;
#line 9
SCHEME_OBJECT Prim_non_restartable_exit_with_value(void) ;
#line 9
SCHEME_OBJECT Prim_restartable_exit(void) ;
#line 9
SCHEME_OBJECT Prim_under_emacs_p(void) ;
#line 9
SCHEME_OBJECT Prim_set_trap_state(void) ;
#line 9
SCHEME_OBJECT Prim_heap_available_p(void) ;
#line 9
SCHEME_OBJECT Prim_get_free(void) ;
#line 9
SCHEME_OBJECT Prim_increment_free(void) ;
#line 9
SCHEME_OBJECT Prim_gc_space_status(void) ;
#line 9
SCHEME_OBJECT Prim_scheme_program_name(void) ;
#line 9
SCHEME_OBJECT Prim_read_byte_from_memory(void) ;
#line 9
SCHEME_OBJECT Prim_read_word_from_memory(void) ;
#line 9
SCHEME_OBJECT Prim_read_float_from_memory(void) ;
#line 9
SCHEME_OBJECT Prim_write_byte_to_memory(void) ;
#line 9
SCHEME_OBJECT Prim_write_word_to_memory(void) ;
#line 9
SCHEME_OBJECT Prim_write_float_to_memory(void) ;
#line 9
SCHEME_OBJECT Prim_cc_block_linkage_info(void) ;
#line 9
SCHEME_OBJECT Prim_vector_cons(void) ;
#line 9
SCHEME_OBJECT Prim_vector(void) ;
#line 9
SCHEME_OBJECT Prim_record(void) ;
#line 9
SCHEME_OBJECT Prim_vector_p(void) ;
#line 9
SCHEME_OBJECT Prim_record_p(void) ;
#line 9
SCHEME_OBJECT Prim_sys_vector(void) ;
#line 9
SCHEME_OBJECT Prim_vector_length(void) ;
#line 9
SCHEME_OBJECT Prim_record_length(void) ;
#line 9
SCHEME_OBJECT Prim_sys_vec_size(void) ;
#line 9
SCHEME_OBJECT Prim_vector_ref(void) ;
#line 9
SCHEME_OBJECT Prim_record_ref(void) ;
#line 9
SCHEME_OBJECT Prim_sys_vector_ref(void) ;
#line 9
SCHEME_OBJECT Prim_vector_set(void) ;
#line 9
SCHEME_OBJECT Prim_record_set(void) ;
#line 9
SCHEME_OBJECT Prim_sys_vec_set(void) ;
#line 9
SCHEME_OBJECT Prim_subvector_to_list(void) ;
#line 9
SCHEME_OBJECT Prim_sys_subvector_to_list(void) ;
#line 9
SCHEME_OBJECT Prim_list_to_vector(void) ;
#line 9
SCHEME_OBJECT Prim_sys_list_to_vector(void) ;
#line 9
SCHEME_OBJECT Prim_subvector_move_right(void) ;
#line 9
SCHEME_OBJECT Prim_subvector_move_left(void) ;
#line 9
SCHEME_OBJECT Prim_vector_fill(void) ;
#line 9
SCHEME_OBJECT Prim_nanotime_since_utc_epoch(void) ;
#line 9
SCHEME_OBJECT Prim_encoded_time(void) ;
#line 9
SCHEME_OBJECT Prim_decode_time(void) ;
#line 9
SCHEME_OBJECT Prim_decode_utc(void) ;
#line 9
SCHEME_OBJECT Prim_encode_time(void) ;
#line 9
SCHEME_OBJECT Prim_system_clock(void) ;
#line 9
SCHEME_OBJECT Prim_real_time_clock(void) ;
#line 9
SCHEME_OBJECT Prim_process_timer_clear(void) ;
#line 9
SCHEME_OBJECT Prim_process_timer_set(void) ;
#line 9
SCHEME_OBJECT Prim_real_timer_clear(void) ;
#line 9
SCHEME_OBJECT Prim_real_timer_set(void) ;
#line 9
SCHEME_OBJECT Prim_profile_timer_clear(void) ;
#line 9
SCHEME_OBJECT Prim_profile_timer_set(void) ;
#line 9
SCHEME_OBJECT Prim_setup_timer_interrupt(void) ;
#line 9
SCHEME_OBJECT Prim_working_dir_pathname(void) ;
#line 9
SCHEME_OBJECT Prim_set_working_dir_pathname(void) ;
#line 9
SCHEME_OBJECT Prim_system_call_error_message(void) ;
#line 9
SCHEME_OBJECT Prim_new_file_open_input_channel(void) ;
#line 9
SCHEME_OBJECT Prim_new_file_open_output_channel(void) ;
#line 9
SCHEME_OBJECT Prim_new_file_open_exclusive_output_channel(void) ;
#line 9
SCHEME_OBJECT Prim_new_file_open_io_channel(void) ;
#line 9
SCHEME_OBJECT Prim_new_file_open_append_channel(void) ;
#line 9
SCHEME_OBJECT Prim_file_open_input_channel(void) ;
#line 9
SCHEME_OBJECT Prim_file_open_output_channel(void) ;
#line 9
SCHEME_OBJECT Prim_file_open_exclusive_output_channel(void) ;
#line 9
SCHEME_OBJECT Prim_file_open_io_channel(void) ;
#line 9
SCHEME_OBJECT Prim_file_open_append_channel(void) ;
#line 9
SCHEME_OBJECT Prim_file_length_new(void) ;
#line 9
SCHEME_OBJECT Prim_file_position(void) ;
#line 9
SCHEME_OBJECT Prim_file_set_position(void) ;
#line 9
SCHEME_OBJECT Prim_file_truncate(void) ;
#line 9
SCHEME_OBJECT Prim_file_exists_p(void) ;
#line 9
SCHEME_OBJECT Prim_file_exists_direct_p(void) ;
#line 9
SCHEME_OBJECT Prim_file_type_direct(void) ;
#line 9
SCHEME_OBJECT Prim_file_type_indirect(void) ;
#line 9
SCHEME_OBJECT Prim_file_access(void) ;
#line 9
SCHEME_OBJECT Prim_file_directory_p(void) ;
#line 9
SCHEME_OBJECT Prim_file_soft_link_p(void) ;
#line 9
SCHEME_OBJECT Prim_file_remove(void) ;
#line 9
SCHEME_OBJECT Prim_file_remove_link(void) ;
#line 9
SCHEME_OBJECT Prim_file_rename(void) ;
#line 9
SCHEME_OBJECT Prim_file_link_hard(void) ;
#line 9
SCHEME_OBJECT Prim_file_link_soft(void) ;
#line 9
SCHEME_OBJECT Prim_link_file(void) ;
#line 9
SCHEME_OBJECT Prim_file_copy(void) ;
#line 9
SCHEME_OBJECT Prim_directory_make(void) ;
#line 9
SCHEME_OBJECT Prim_directory_delete(void) ;
#line 9
SCHEME_OBJECT Prim_file_touch(void) ;
#line 9
SCHEME_OBJECT Prim_new_directory_open(void) ;
#line 9
SCHEME_OBJECT Prim_new_directory_close(void) ;
#line 9
SCHEME_OBJECT Prim_new_directory_read(void) ;
#line 9
SCHEME_OBJECT Prim_new_directory_read_match(void) ;
#line 9
SCHEME_OBJECT Prim_channel_close(void) ;
#line 9
SCHEME_OBJECT Prim_channel_synchronize(void) ;
#line 9
SCHEME_OBJECT Prim_channel_table(void) ;
#line 9
SCHEME_OBJECT Prim_channel_type(void) ;
#line 9
SCHEME_OBJECT Prim_channel_type_name(void) ;
#line 9
SCHEME_OBJECT Prim_channel_read(void) ;
#line 9
SCHEME_OBJECT Prim_channel_write(void) ;
#line 9
SCHEME_OBJECT Prim_channel_blocking_p(void) ;
#line 9
SCHEME_OBJECT Prim_channel_nonblocking(void) ;
#line 9
SCHEME_OBJECT Prim_channel_blocking(void) ;
#line 9
SCHEME_OBJECT Prim_make_pipe(void) ;
#line 9
SCHEME_OBJECT Prim_new_make_pipe(void) ;
#line 9
SCHEME_OBJECT Prim_have_select_p(void) ;
#line 9
SCHEME_OBJECT Prim_alloc_selreg(void) ;
#line 9
SCHEME_OBJECT Prim_dealloc_selreg(void) ;
#line 9
SCHEME_OBJECT Prim_add_to_selreg(void) ;
#line 9
SCHEME_OBJECT Prim_rem_from_selreg(void) ;
#line 9
SCHEME_OBJECT Prim_selreg_length(void) ;
#line 9
SCHEME_OBJECT Prim_test_selreg(void) ;
#line 9
SCHEME_OBJECT Prim_test_sel_desc(void) ;
#line 9
SCHEME_OBJECT Prim_scheme_environment(void) ;
#line 9
SCHEME_OBJECT Prim_process_delete(void) ;
#line 9
SCHEME_OBJECT Prim_process_table(void) ;
#line 9
SCHEME_OBJECT Prim_process_id(void) ;
#line 9
SCHEME_OBJECT Prim_process_jc_status(void) ;
#line 9
SCHEME_OBJECT Prim_process_status_sync(void) ;
#line 9
SCHEME_OBJECT Prim_process_status_sync_all(void) ;
#line 9
SCHEME_OBJECT Prim_process_status(void) ;
#line 9
SCHEME_OBJECT Prim_process_reason(void) ;
#line 9
SCHEME_OBJECT Prim_process_signal(void) ;
#line 9
SCHEME_OBJECT Prim_process_kill(void) ;
#line 9
SCHEME_OBJECT Prim_process_interrupt(void) ;
#line 9
SCHEME_OBJECT Prim_process_quit(void) ;
#line 9
SCHEME_OBJECT Prim_process_hangup(void) ;
#line 9
SCHEME_OBJECT Prim_process_stop(void) ;
#line 9
SCHEME_OBJECT Prim_process_continue_background(void) ;
#line 9
SCHEME_OBJECT Prim_process_wait(void) ;
#line 9
SCHEME_OBJECT Prim_process_continue_foreground(void) ;
#line 9
SCHEME_OBJECT Prim_make_subprocess(void) ;
#line 9
SCHEME_OBJECT Prim_open_pty_master(void) ;
#line 9
SCHEME_OBJECT Prim_pty_master_send_signal(void) ;
#line 9
SCHEME_OBJECT Prim_pty_master_kill(void) ;
#line 9
SCHEME_OBJECT Prim_pty_master_stop(void) ;
#line 9
SCHEME_OBJECT Prim_pty_master_continue(void) ;
#line 9
SCHEME_OBJECT Prim_pty_master_interrupt(void) ;
#line 9
SCHEME_OBJECT Prim_pty_master_quit(void) ;
#line 9
SCHEME_OBJECT Prim_pty_master_hangup(void) ;
#line 9
SCHEME_OBJECT Prim_terminal_get_ispeed(void) ;
#line 9
SCHEME_OBJECT Prim_terminal_get_ospeed(void) ;
#line 9
SCHEME_OBJECT Prim_terminal_set_ispeed(void) ;
#line 9
SCHEME_OBJECT Prim_terminal_set_ospeed(void) ;
#line 9
SCHEME_OBJECT Prim_baud_index_to_rate(void) ;
#line 9
SCHEME_OBJECT Prim_baud_rate_to_index(void) ;
#line 9
SCHEME_OBJECT Prim_terminal_get_state(void) ;
#line 9
SCHEME_OBJECT Prim_terminal_set_state(void) ;
#line 9
SCHEME_OBJECT Prim_terminal_cooked_output_p(void) ;
#line 9
SCHEME_OBJECT Prim_terminal_raw_output(void) ;
#line 9
SCHEME_OBJECT Prim_terminal_cooked_output(void) ;
#line 9
SCHEME_OBJECT Prim_terminal_buffered_p(void) ;
#line 9
SCHEME_OBJECT Prim_terminal_buffered(void) ;
#line 9
SCHEME_OBJECT Prim_terminal_nonbuffered(void) ;
#line 9
SCHEME_OBJECT Prim_terminal_flush_input(void) ;
#line 9
SCHEME_OBJECT Prim_terminal_flush_output(void) ;
#line 9
SCHEME_OBJECT Prim_terminal_drain_output(void) ;
#line 9
SCHEME_OBJECT Prim_os_job_control_p(void) ;
#line 9
SCHEME_OBJECT Prim_have_ptys_p(void) ;
#line 9
SCHEME_OBJECT Prim_tty_input_channel(void) ;
#line 9
SCHEME_OBJECT Prim_tty_output_channel(void) ;
#line 9
SCHEME_OBJECT Prim_tty_x_size(void) ;
#line 9
SCHEME_OBJECT Prim_tty_y_size(void) ;
#line 9
SCHEME_OBJECT Prim_tty_command_beep(void) ;
#line 9
SCHEME_OBJECT Prim_tty_command_clear(void) ;
#line 9
SCHEME_OBJECT Prim_tty_next_interrupt_char(void) ;
#line 9
SCHEME_OBJECT Prim_tty_get_interrupt_enables(void) ;
#line 9
SCHEME_OBJECT Prim_tty_set_interrupt_enables(void) ;
#line 9
SCHEME_OBJECT Prim_tty_get_interrupt_chars(void) ;
#line 9
SCHEME_OBJECT Prim_tty_set_interrupt_chars(void) ;
#line 9
SCHEME_OBJECT Prim_get_service_by_name(void) ;
#line 9
SCHEME_OBJECT Prim_get_service_by_number(void) ;
#line 9
SCHEME_OBJECT Prim_host_address_length(void) ;
#line 9
SCHEME_OBJECT Prim_get_host_by_name(void) ;
#line 9
SCHEME_OBJECT Prim_get_host_name(void) ;
#line 9
SCHEME_OBJECT Prim_canonical_host_name(void) ;
#line 9
SCHEME_OBJECT Prim_get_host_by_address(void) ;
#line 9
SCHEME_OBJECT Prim_host_address_any(void) ;
#line 9
SCHEME_OBJECT Prim_host_address_loopback(void) ;
#line 9
SCHEME_OBJECT Prim_new_open_tcp_stream_socket(void) ;
#line 9
SCHEME_OBJECT Prim_new_open_unix_stream_socket(void) ;
#line 9
SCHEME_OBJECT Prim_shutdown_socket(void) ;
#line 9
SCHEME_OBJECT Prim_new_open_tcp_server_socket(void) ;
#line 9
SCHEME_OBJECT Prim_create_tcp_server_socket(void) ;
#line 9
SCHEME_OBJECT Prim_bind_tcp_server_socket(void) ;
#line 9
SCHEME_OBJECT Prim_listen_tcp_server_socket(void) ;
#line 9
SCHEME_OBJECT Prim_new_tcp_server_connection_accept(void) ;
#line 9
SCHEME_OBJECT Prim_file_time_to_string(void) ;
#line 9
SCHEME_OBJECT Prim_get_user_home_directory(void) ;
#line 9
SCHEME_OBJECT Prim_uid_to_string(void) ;
#line 9
SCHEME_OBJECT Prim_gid_to_string(void) ;
#line 9
SCHEME_OBJECT Prim_current_pid(void) ;
#line 9
SCHEME_OBJECT Prim_current_uid(void) ;
#line 9
SCHEME_OBJECT Prim_current_gid(void) ;
#line 9
SCHEME_OBJECT Prim_real_uid(void) ;
#line 9
SCHEME_OBJECT Prim_real_gid(void) ;
#line 9
SCHEME_OBJECT Prim_current_user_name(void) ;
#line 9
SCHEME_OBJECT Prim_current_user_home_directory(void) ;
#line 9
SCHEME_OBJECT Prim_system(void) ;
#line 9
SCHEME_OBJECT Prim_get_environment_variable(void) ;
#line 9
SCHEME_OBJECT Prim_full_hostname(void) ;
#line 9
SCHEME_OBJECT Prim_hostname(void) ;
#line 9
SCHEME_OBJECT Prim_instruction_address_to_compiled_code_block(void) ;
#line 9
SCHEME_OBJECT Prim_macosx_main_bundle_dir(void) ;
#line 9
SCHEME_OBJECT Prim_file_modes(void) ;
#line 9
SCHEME_OBJECT Prim_set_file_modes(void) ;
#line 9
SCHEME_OBJECT Prim_file_mod_time(void) ;
#line 9
SCHEME_OBJECT Prim_file_mod_time_indirect(void) ;
#line 9
SCHEME_OBJECT Prim_file_acc_time(void) ;
#line 9
SCHEME_OBJECT Prim_file_acc_time_indirect(void) ;
#line 9
SCHEME_OBJECT Prim_set_file_times(void) ;
#line 9
SCHEME_OBJECT Prim_channel_file_attributes(void) ;
#line 9
SCHEME_OBJECT Prim_file_attributes(void) ;
#line 9
SCHEME_OBJECT Prim_file_attributes_indirect(void) ;
#line 9
SCHEME_OBJECT Prim_file_eq_p(void) ;
#line 9
SCHEME_OBJECT Prim_file_system_type(void) ;
#line 9
SCHEME_OBJECT Prim_channel_descriptor(void) ;
#line 9
SCHEME_OBJECT Prim_UX_make_subprocess(void) ;
#line 9
SCHEME_OBJECT Prim_termcap_initialize(void) ;
#line 9
SCHEME_OBJECT Prim_termcap_get_number(void) ;
#line 9
SCHEME_OBJECT Prim_termcap_get_flag(void) ;
#line 9
SCHEME_OBJECT Prim_termcap_get_string(void) ;
#line 9
SCHEME_OBJECT Prim_termcap_param_string(void) ;
#line 9
SCHEME_OBJECT Prim_termcap_goto_string(void) ;
#line 9
SCHEME_OBJECT Prim_termcap_pad_string(void) ;
#line 9
SCHEME_OBJECT Prim_dld_load_file(void) ;
#line 9
SCHEME_OBJECT Prim_dld_lookup_symbol(void) ;
#line 9
SCHEME_OBJECT Prim_dld_unload_file(void) ;
#line 9
SCHEME_OBJECT Prim_invoke_C_thunk(void) ;
#line 9
SCHEME_OBJECT Prim_address_to_string(void) ;
#line 9
SCHEME_OBJECT Prim_peek_char(void) ;
#line 9
SCHEME_OBJECT Prim_peek_uchar(void) ;
#line 9
SCHEME_OBJECT Prim_peek_short(void) ;
#line 9
SCHEME_OBJECT Prim_peek_ushort(void) ;
#line 9
SCHEME_OBJECT Prim_peek_int(void) ;
#line 9
SCHEME_OBJECT Prim_peek_uint(void) ;
#line 9
SCHEME_OBJECT Prim_peek_long(void) ;
#line 9
SCHEME_OBJECT Prim_peek_ulong(void) ;
#line 9
SCHEME_OBJECT Prim_peek_float(void) ;
#line 9
SCHEME_OBJECT Prim_peek_double(void) ;
#line 9
SCHEME_OBJECT Prim_peek_pointer(void) ;
#line 9
SCHEME_OBJECT Prim_peek_cstring(void) ;
#line 9
SCHEME_OBJECT Prim_peek_cstring_bang(void) ;
#line 9
SCHEME_OBJECT Prim_peek_cstringp(void) ;
#line 9
SCHEME_OBJECT Prim_peek_cstringp_bang(void) ;
#line 9
SCHEME_OBJECT Prim_peek_bytes(void) ;
#line 9
SCHEME_OBJECT Prim_poke_char(void) ;
#line 9
SCHEME_OBJECT Prim_poke_uchar(void) ;
#line 9
SCHEME_OBJECT Prim_poke_short(void) ;
#line 9
SCHEME_OBJECT Prim_poke_ushort(void) ;
#line 9
SCHEME_OBJECT Prim_poke_int(void) ;
#line 9
SCHEME_OBJECT Prim_poke_uint(void) ;
#line 9
SCHEME_OBJECT Prim_poke_long(void) ;
#line 9
SCHEME_OBJECT Prim_poke_ulong(void) ;
#line 9
SCHEME_OBJECT Prim_poke_float(void) ;
#line 9
SCHEME_OBJECT Prim_poke_double(void) ;
#line 9
SCHEME_OBJECT Prim_poke_pointer(void) ;
#line 9
SCHEME_OBJECT Prim_poke_pointer_bang(void) ;
#line 9
SCHEME_OBJECT Prim_poke_string(void) ;
#line 9
SCHEME_OBJECT Prim_poke_string_bang(void) ;
#line 9
SCHEME_OBJECT Prim_poke_bytes(void) ;
#line 9
SCHEME_OBJECT Prim_c_malloc(void) ;
#line 9
SCHEME_OBJECT Prim_c_free(void) ;
#line 9
SCHEME_OBJECT Prim_c_call(void) ;
#line 9
SCHEME_OBJECT Prim_c_call_continue(void) ;
#line 9
SCHEME_OBJECT Prim_run_callback(void) ;
#line 9
SCHEME_OBJECT Prim_return_to_c(void) ;
#line 9
SCHEME_OBJECT Prim_outf_error(void) ;
#line 9
SCHEME_OBJECT Prim_comp_code_address_block(void) ;
#line 9
SCHEME_OBJECT Prim_comp_code_address_offset(void) ;
#line 9
SCHEME_OBJECT Prim_stack_top_address(void) ;
#line 9
SCHEME_OBJECT Prim_stack_address_offset(void) ;
#line 9
SCHEME_OBJECT Prim_compiled_entry_kind(void) ;
#line 9
SCHEME_OBJECT Prim_coerce_to_closure(void) ;
#line 9
SCHEME_OBJECT Prim_cc_closure_to_entry(void) ;
#line 9
SCHEME_OBJECT Prim_utility_index_to_name(void) ;
#line 9
SCHEME_OBJECT Prim_builtin_index_to_name(void) ;
#line 9
SCHEME_OBJECT Prim_initialize_C_compiled_block(void) ;
#line 9
SCHEME_OBJECT Prim_initialize_liarc_object_file(void) ;
#line 9
SCHEME_OBJECT Prim_declare_compiled_code_block(void) ;
#line 9
SCHEME_OBJECT Prim_liarc_compiled_code_blocks(void) ;
#line 9
SCHEME_OBJECT Prim_install_bkpt(void) ;
#line 9
SCHEME_OBJECT Prim_remove_bkpt(void) ;
#line 9
SCHEME_OBJECT Prim_bkpt_p(void) ;
#line 9
SCHEME_OBJECT Prim_bkpt_proceed(void) ;
#line 665 "/home/khheo/project/mit-scheme-9.2/src/microcode/usrdef.c"
SCHEME_OBJECT Prim_inexistent(void) 
{ 


  {
  {
#line 668
  while (1) {
    while_continue: /* CIL Label */ ;
#line 668
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 670
  signal_error_from_primitive(51L);
  }
#line 672
  return ((8UL << 58U) | 1UL);
}
}
#line 675 "/home/khheo/project/mit-scheme-9.2/src/microcode/usrdef.c"
SCHEME_OBJECT (*Static_Primitive_Procedure_Table[655])(void)  = 
#line 675
  {      & Prim_record,      & Prim_record_length,      & Prim_record_ref,      & Prim_record_set, 
        & Prim_record_p,      & Prim_multiply,      & Prim_add,      & Prim_subtract, 
        & Prim_divide,      & Prim_less,      & Prim_equal_number,      & Prim_greater, 
        & Prim_subtract_one,      & Prim_add_one,      & Prim_add_to_selreg,      & Prim_address_to_string, 
        & Prim_alloc_external_string,      & Prim_alloc_selreg,      & Prim_apply,      & Prim_ascii_to_char, 
        & Prim_assq,      & Prim_batch_mode_p,      & Prim_baud_index_to_rate,      & Prim_baud_rate_to_index, 
        & Prim_bignum_to_fixnum,      & Prim_bignum_to_flonum,      & Prim_bignum_add,      & Prim_bignum_divide, 
        & Prim_bignum_equal_p,      & Prim_bignum_length_in_bits,      & Prim_bignum_less_p,      & Prim_bignum_multiply, 
        & Prim_bignum_negative_p,      & Prim_bignum_positive_p,      & Prim_bignum_quotient,      & Prim_bignum_remainder, 
        & Prim_bignum_subtract,      & Prim_bignum_zero_p,      & Prim_binary_fasload,      & Prim_bind_tcp_server_socket, 
        & Prim_bit_string_to_unsigned,      & Prim_bit_string_allocate,      & Prim_bit_string_and_x,      & Prim_bit_string_andc_x, 
        & Prim_bit_string_clear_x,      & Prim_bit_string_fill_x,      & Prim_bit_string_length,      & Prim_bit_string_move_x, 
        & Prim_bit_string_movec_x,      & Prim_bit_string_or_x,      & Prim_bit_string_ref,      & Prim_bit_string_set_x, 
        & Prim_bit_string_xor_x,      & Prim_bit_string_zero_p,      & Prim_bit_string_equal_p,      & Prim_bit_string_p, 
        & Prim_bitstr_find_next_set_bit,      & Prim_bit_substring_move_right_x,      & Prim_install_bkpt,      & Prim_bkpt_proceed, 
        & Prim_remove_bkpt,      & Prim_bkpt_p,      & Prim_builtin_index_to_name,      & Prim_c_call, 
        & Prim_c_call_continue,      & Prim_c_free,      & Prim_c_malloc,      & Prim_peek_bytes, 
        & Prim_peek_char,      & Prim_peek_cstring,      & Prim_peek_cstring_bang,      & Prim_peek_cstringp, 
        & Prim_peek_cstringp_bang,      & Prim_peek_double,      & Prim_peek_float,      & Prim_peek_int, 
        & Prim_peek_long,      & Prim_peek_pointer,      & Prim_peek_short,      & Prim_peek_uchar, 
        & Prim_peek_uint,      & Prim_peek_ulong,      & Prim_peek_ushort,      & Prim_poke_bytes, 
        & Prim_poke_char,      & Prim_poke_double,      & Prim_poke_float,      & Prim_poke_int, 
        & Prim_poke_long,      & Prim_poke_pointer,      & Prim_poke_pointer_bang,      & Prim_poke_short, 
        & Prim_poke_string,      & Prim_poke_string_bang,      & Prim_poke_uchar,      & Prim_poke_uint, 
        & Prim_poke_ulong,      & Prim_poke_ushort,      & Prim_catch,      & Prim_canonical_host_name, 
        & Prim_car,      & Prim_cast_ieee754_double_to_integer,      & Prim_cast_ieee754_single_to_integer,      & Prim_cast_integer_to_ieee754_double, 
        & Prim_cast_integer_to_ieee754_single,      & Prim_cc_block_linkage_info,      & Prim_cdr,      & Prim_cell_contents, 
        & Prim_cell_p,      & Prim_channel_blocking,      & Prim_channel_blocking_p,      & Prim_channel_close, 
        & Prim_channel_descriptor,      & Prim_channel_file_attributes,      & Prim_channel_nonblocking,      & Prim_channel_read, 
        & Prim_channel_synchronize,      & Prim_channel_table,      & Prim_channel_type,      & Prim_channel_type_name, 
        & Prim_channel_write,      & Prim_char_to_ascii,      & Prim_char_to_integer,      & Prim_char_to_syntax_code, 
        & Prim_char_ascii_p,      & Prim_char_bits,      & Prim_char_code,      & Prim_char_downcase, 
        & Prim_char_upcase,      & Prim_char_p,      & Prim_clear_float_exceptions,      & Prim_clear_interrupts, 
        & Prim_close_lost_open_files,      & Prim_coerce_to_closure,      & Prim_cc_closure_to_entry,      & Prim_comp_code_address_block, 
        & Prim_comp_code_address_offset,      & Prim_compiled_entry_kind,      & Prim_cons,      & Prim_constant_p, 
        & Prim_create_tcp_server_socket,      & Prim_current_gid,      & Prim_current_pid,      & Prim_current_uid, 
        & Prim_current_user_home_directory,      & Prim_current_user_name,      & Prim_dealloc_external_string,      & Prim_dealloc_selreg, 
        & Prim_debugging_printer,      & Prim_declare_compiled_code_block,      & Prim_decode_time,      & Prim_decode_utc, 
        & Prim_defer_float_exception_traps,      & Prim_directory_delete,      & Prim_directory_make,      & Prim_disable_interrupts, 
        & Prim_divide_fixnum,      & Prim_dld_load_file,      & Prim_dld_lookup_symbol,      & Prim_dld_unload_file, 
        & Prim_band_dump,      & Prim_enable_interrupts,      & Prim_encode_time,      & Prim_encoded_time, 
        & Prim_environment_link_name,      & Prim_eq,      & Prim_equal_fixnum,      & Prim_error_procedure, 
        & Prim_non_restartable_exit,      & Prim_non_restartable_exit_with_value,      & Prim_extended_string_length,      & Prim_external_string_p, 
        & Prim_file_access,      & Prim_file_acc_time,      & Prim_file_acc_time_indirect,      & Prim_file_attributes, 
        & Prim_file_attributes_indirect,      & Prim_file_copy,      & Prim_file_directory_p,      & Prim_file_eq_p, 
        & Prim_file_exists_direct_p,      & Prim_file_exists_p,      & Prim_file_length_new,      & Prim_file_link_hard, 
        & Prim_file_link_soft,      & Prim_file_mod_time,      & Prim_file_mod_time_indirect,      & Prim_file_modes, 
        & Prim_file_open_append_channel,      & Prim_file_open_exclusive_output_channel,      & Prim_file_open_input_channel,      & Prim_file_open_io_channel, 
        & Prim_file_open_output_channel,      & Prim_file_position,      & Prim_file_remove,      & Prim_file_remove_link, 
        & Prim_file_rename,      & Prim_file_set_position,      & Prim_file_soft_link_p,      & Prim_file_system_type, 
        & Prim_file_time_to_string,      & Prim_file_touch,      & Prim_file_truncate,      & Prim_file_type_direct, 
        & Prim_file_type_indirect,      & Prim_find_symbol,      & Prim_fixnum_to_bignum,      & Prim_fixnum_to_flonum, 
        & Prim_fixnum_and,      & Prim_fixnum_andc,      & Prim_fixnum_lsh,      & Prim_fixnum_negate, 
        & Prim_fixnum_not,      & Prim_fixnum_or,      & Prim_fixnum_quotient,      & Prim_fixnum_remainder, 
        & Prim_fixnum_xor,      & Prim_zero_fixnum_p,      & Prim_float_divide_by_zero_exception,      & Prim_float_environment, 
        & Prim_float_exceptions,      & Prim_float_inexact_result_exception,      & Prim_float_invalid_operation_exception,      & Prim_float_overflow_exception, 
        & Prim_float_rounding_modes,      & Prim_float_underflow_exception,      & Prim_floating_vector_cons,      & Prim_floating_vector_length, 
        & Prim_floating_vector_ref,      & Prim_floating_vector_set,      & Prim_flonum_to_bignum,      & Prim_flonum_abs, 
        & Prim_flonum_acos,      & Prim_flonum_add,      & Prim_flonum_asin,      & Prim_flonum_atan, 
        & Prim_flonum_atan2,      & Prim_flonum_ceiling,      & Prim_flonum_ceiling_to_exact,      & Prim_flonum_cos, 
        & Prim_flonum_denormalize,      & Prim_flonum_divide,      & Prim_flonum_equal_p,      & Prim_flonum_exp, 
        & Prim_flonum_expm1,      & Prim_flonum_expt,      & Prim_flonum_floor,      & Prim_flonum_floor_to_exact, 
        & Prim_flonum_greater_p,      & Prim_flonum_integer_p,      & Prim_flonum_less_p,      & Prim_flonum_log, 
        & Prim_flonum_log1p,      & Prim_flonum_modulo,      & Prim_flonum_multiply,      & Prim_flonum_negate, 
        & Prim_flonum_negative_p,      & Prim_flonum_normalize,      & Prim_flonum_positive_p,      & Prim_flonum_round, 
        & Prim_flonum_round_to_exact,      & Prim_flonum_sin,      & Prim_flonum_sqrt,      & Prim_flonum_subtract, 
        & Prim_flonum_tan,      & Prim_flonum_truncate,      & Prim_flonum_truncate_to_exact,      & Prim_flonum_zero_p, 
        & Prim_flonum_p,      & Prim_force,      & Prim_full_hostname,      & Prim_garbage_collect, 
        & Prim_gc_space_status,      & Prim_gc_trace_references,      & Prim_gcd_fixnum,      & Prim_general_car_cdr, 
        & Prim_get_command_line,      & Prim_get_environment_variable,      & Prim_get_fixed_objects_vector,      & Prim_get_float_rounding_mode, 
        & Prim_get_host_by_address,      & Prim_get_host_by_name,      & Prim_get_host_name,      & Prim_get_interrupt_enables, 
        & Prim_get_primitive_address,      & Prim_get_primitive_counts,      & Prim_get_primitive_name,      & Prim_get_service_by_name, 
        & Prim_get_service_by_number,      & Prim_get_unused_command_line,      & Prim_get_user_home_directory,      & Prim_gid_to_string, 
        & Prim_greater_fixnum,      & Prim_restartable_exit,      & Prim_have_ptys_p,      & Prim_have_select_p, 
        & Prim_heap_available_p,      & Prim_host_address_any,      & Prim_host_address_length,      & Prim_host_address_loopback, 
        & Prim_hostname,      & Prim_hunk3_cons,      & Prim_hunk3_cxr,      & Prim_hunk3_set_cxr, 
        & Prim_index_fixnum_p,      & Prim_initialize_C_compiled_block,      & Prim_initialize_liarc_object_file,      & Prim_instruction_address_to_compiled_code_block, 
        & Prim_integer_to_char,      & Prim_integer_to_flonum,      & Prim_integer_add,      & Prim_integer_add_1, 
        & Prim_integer_bit_count,      & Prim_integer_bitwise_and,      & Prim_integer_bitwise_andc1,      & Prim_integer_bitwise_andc2, 
        & Prim_integer_bitwise_eqv,      & Prim_integer_bitwise_ior,      & Prim_integer_bitwise_nand,      & Prim_integer_bitwise_nor, 
        & Prim_integer_bitwise_not,      & Prim_integer_bitwise_orc1,      & Prim_integer_bitwise_orc2,      & Prim_integer_bitwise_xor, 
        & Prim_integer_divide,      & Prim_integer_equal_p,      & Prim_integer_first_set_bit,      & Prim_integer_greater_p, 
        & Prim_integer_hamming_distance,      & Prim_integer_length,      & Prim_integer_length_in_bits,      & Prim_integer_less_p, 
        & Prim_integer_multiply,      & Prim_integer_negate,      & Prim_integer_negative_zero_bits,      & Prim_integer_negative_p, 
        & Prim_integer_nonnegative_one_bits,      & Prim_integer_positive_p,      & Prim_integer_quotient,      & Prim_integer_remainder, 
        & Prim_integer_shift_left,      & Prim_integer_shift_right,      & Prim_integer_subtract,      & Prim_integer_subtract_1, 
        & Prim_integer_zero_p,      & Prim_integer_p,      & Prim_invoke_C_thunk,      & Prim_length, 
        & Prim_less_fixnum,      & Prim_lexical_assignment,      & Prim_lexical_reference,      & Prim_lexical_reference_type, 
        & Prim_unassigned_test,      & Prim_unbound_test,      & Prim_unreferenceable_test,      & Prim_liarc_compiled_code_blocks, 
        & Prim_link_file,      & Prim_link_variables,      & Prim_list_to_integer,      & Prim_list_to_vector, 
        & Prim_listen_tcp_server_socket,      & Prim_listify_bignum,      & Prim_band_load,      & Prim_local_assignment, 
        & Prim_local_reference,      & Prim_macosx_main_bundle_dir,      & Prim_make_bit_string,      & Prim_make_cell, 
        & Prim_make_char,      & Prim_make_ephemeron,      & Prim_make_non_ptr_object,      & Prim_make_pipe, 
        & Prim_make_subprocess,      & Prim_map_code_to_address,      & Prim_map_address_to_code,      & Prim_memq, 
        & Prim_microcode_identify,      & Prim_microcode_library_path,      & Prim_minus_fixnum,      & Prim_m_1_plus_fixnum, 
        & Prim_modulo,      & Prim_multiply_fixnum,      & Prim_nanotime_since_utc_epoch,      & Prim_negative_fixnum, 
        & Prim_negative,      & Prim_new_directory_close,      & Prim_new_directory_open,      & Prim_new_directory_read, 
        & Prim_new_directory_read_match,      & Prim_new_file_open_append_channel,      & Prim_new_file_open_exclusive_output_channel,      & Prim_new_file_open_input_channel, 
        & Prim_new_file_open_io_channel,      & Prim_new_file_open_output_channel,      & Prim_new_make_pipe,      & Prim_new_open_tcp_server_socket, 
        & Prim_new_open_tcp_stream_socket,      & Prim_new_open_unix_stream_socket,      & Prim_new_tcp_server_connection_accept,      & Prim_not, 
        & Prim_null_p,      & Prim_object_datum,      & Prim_object_gc_type,      & Prim_object_set_type, 
        & Prim_object_type,      & Prim_object_type_p,      & Prim_one_plus_fixnum,      & Prim_open_pty_master, 
        & Prim_os_job_control_p,      & Prim_outf_error,      & Prim_pair,      & Prim_plus_fixnum, 
        & Prim_positive_fixnum,      & Prim_positive,      & Prim_prim_addr_to_datum,      & Prim_apply_step, 
        & Prim_prim_datum_to_addr,      & Prim_eval_step,      & Prim_prim_fasdump,      & Prim_get_free, 
        & Prim_impurify,      & Prim_increment_free,      & Prim_prim_integer_to_obj,      & Prim_prim_make_obj, 
        & Prim_prim_obj_to_integer,      & Prim_prim_obj_address,      & Prim_prim_obj_datum,      & Prim_prim_obj_eq_p, 
        & Prim_prim_obj_ref,      & Prim_prim_obj_set,      & Prim_prim_obj_set_type,      & Prim_prim_obj_type, 
        & Prim_prim_obj_type_p,      & Prim_primitive_procedure_arity,      & Prim_primitive_procedure_doc,      & Prim_primitive_purify, 
        & Prim_return_step,      & Prim_process_continue_background,      & Prim_process_continue_foreground,      & Prim_process_delete, 
        & Prim_process_hangup,      & Prim_process_id,      & Prim_process_interrupt,      & Prim_process_jc_status, 
        & Prim_process_kill,      & Prim_process_quit,      & Prim_process_reason,      & Prim_process_signal, 
        & Prim_process_status,      & Prim_process_status_sync,      & Prim_process_status_sync_all,      & Prim_process_stop, 
        & Prim_process_table,      & Prim_process_timer_clear,      & Prim_process_timer_set,      & Prim_process_wait, 
        & Prim_profile_timer_clear,      & Prim_profile_timer_set,      & Prim_pty_master_continue,      & Prim_pty_master_hangup, 
        & Prim_pty_master_interrupt,      & Prim_pty_master_kill,      & Prim_pty_master_quit,      & Prim_pty_master_send_signal, 
        & Prim_pty_master_stop,      & Prim_pure_p,      & Prim_quoted_char_p,      & Prim_quotient, 
        & Prim_raise_float_exceptions,      & Prim_re_char_set_adjoin,      & Prim_re_compile_fastmap,      & Prim_re_match_buffer, 
        & Prim_re_match_substring,      & Prim_re_search_buffer_backward,      & Prim_re_search_buffer_forward,      & Prim_re_search_substr_backward, 
        & Prim_re_search_substr_forward,      & Prim_read_bits_x,      & Prim_read_byte_from_memory,      & Prim_read_float_from_memory, 
        & Prim_read_word_from_memory,      & Prim_real_gid,      & Prim_real_time_clock,      & Prim_real_timer_clear, 
        & Prim_real_timer_set,      & Prim_real_uid,      & Prim_rehash,      & Prim_reload_band_name, 
        & Prim_reload_retrieve_string,      & Prim_reload_save_string,      & Prim_remainder,      & Prim_rem_from_selreg, 
        & Prim_request_interrupts,      & Prim_restore_float_exception_flags,      & Prim_return_to_application,      & Prim_return_to_c, 
        & Prim_run_callback,      & Prim_safe_lexical_reference,      & Prim_save_float_exception_flags,      & Prim_scan_backward_prefix_chars, 
        & Prim_scan_forward_prefix_chars,      & Prim_scan_forward_to_word,      & Prim_scan_list_backward,      & Prim_scan_list_forward, 
        & Prim_scan_sexps_forward,      & Prim_scan_word_backward,      & Prim_scan_word_forward,      & Prim_scheme_environment, 
        & Prim_scheme_program_name,      & Prim_scode_eval,      & Prim_selreg_length,      & Prim_set_car, 
        & Prim_set_cdr,      & Prim_set_cell_contents,      & Prim_set_current_history,      & Prim_set_debug_flags, 
        & Prim_set_file_modes,      & Prim_set_file_times,      & Prim_set_fixed_objects_vector,      & Prim_set_float_environment, 
        & Prim_set_float_rounding_mode,      & Prim_set_interrupt_enables,      & Prim_set_string_length,      & Prim_set_string_maximum_length, 
        & Prim_set_trap_state,      & Prim_set_trapped_float_exceptions,      & Prim_set_working_dir_pathname,      & Prim_setup_timer_interrupt, 
        & Prim_shutdown_socket,      & Prim_stack_address_offset,      & Prim_stack_top_address,      & Prim_string_to_symbol, 
        & Prim_string_to_syntax_entry,      & Prim_string_allocate,      & Prim_string_hash,      & Prim_string_hash_mod, 
        & Prim_string_length,      & Prim_string_maximum_length,      & Prim_string_ref,      & Prim_string_set, 
        & Prim_string_p,      & Prim_substring_ci_equal,      & Prim_substring_downcase,      & Prim_find_next_char_in_set, 
        & Prim_find_prev_char_in_set,      & Prim_match_backward,      & Prim_match_backward_ci,      & Prim_match_forward, 
        & Prim_match_forward_ci,      & Prim_substring_move_left,      & Prim_substring_move_right,      & Prim_substring_upcase, 
        & Prim_substring_less,      & Prim_substring_equal,      & Prim_subvector_to_list,      & Prim_vector_fill, 
        & Prim_subvector_move_left,      & Prim_subvector_move_right,      & Prim_system,      & Prim_system_call_error_message, 
        & Prim_system_clock,      & Prim_sys_h3_0,      & Prim_sys_h3_1,      & Prim_sys_h3_2, 
        & Prim_sh3_set_0,      & Prim_sh3_set_1,      & Prim_sh3_set_2,      & Prim_sys_list_to_vector, 
        & Prim_sys_pair_car,      & Prim_sys_pair_cdr,      & Prim_sys_pair_cons,      & Prim_sys_set_car, 
        & Prim_sys_set_cdr,      & Prim_sys_pair,      & Prim_sys_subvector_to_list,      & Prim_sys_vector_ref, 
        & Prim_sys_vec_set,      & Prim_sys_vec_size,      & Prim_sys_vector,      & Prim_termcap_get_flag, 
        & Prim_termcap_get_number,      & Prim_termcap_get_string,      & Prim_termcap_goto_string,      & Prim_termcap_initialize, 
        & Prim_termcap_pad_string,      & Prim_termcap_param_string,      & Prim_terminal_buffered,      & Prim_terminal_buffered_p, 
        & Prim_terminal_cooked_output,      & Prim_terminal_cooked_output_p,      & Prim_terminal_drain_output,      & Prim_terminal_flush_input, 
        & Prim_terminal_flush_output,      & Prim_terminal_get_ispeed,      & Prim_terminal_get_ospeed,      & Prim_terminal_get_state, 
        & Prim_terminal_nonbuffered,      & Prim_terminal_raw_output,      & Prim_terminal_set_ispeed,      & Prim_terminal_set_ospeed, 
        & Prim_terminal_set_state,      & Prim_test_float_exception_flags,      & Prim_test_float_exceptions,      & Prim_test_sel_desc, 
        & Prim_test_selreg,      & Prim_trap_float_exceptions,      & Prim_trappable_float_exceptions,      & Prim_trapped_float_exceptions, 
        & Prim_tty_command_beep,      & Prim_tty_command_clear,      & Prim_tty_get_interrupt_chars,      & Prim_tty_get_interrupt_enables, 
        & Prim_tty_input_channel,      & Prim_tty_next_interrupt_char,      & Prim_tty_output_channel,      & Prim_tty_set_interrupt_chars, 
        & Prim_tty_set_interrupt_enables,      & Prim_tty_x_size,      & Prim_tty_y_size,      & Prim_type_to_gc_type, 
        & Prim_uid_to_string,      & Prim_unbind_variable,      & Prim_under_emacs_p,      & Prim_unsigned_to_bit_string, 
        & Prim_untrap_float_exceptions,      & Prim_update_float_environment,      & Prim_utility_index_to_name,      & Prim_UX_make_subprocess, 
        & Prim_vector,      & Prim_vec_8b_fill,      & Prim_vec_8b_find_next_char,      & Prim_vec_8b_find_next_char_ci, 
        & Prim_vec_8b_find_prev_char,      & Prim_vec_8b_find_prev_char_ci,      & Prim_vec_8b_ref,      & Prim_vec_8b_set, 
        & Prim_vector_cons,      & Prim_vector_length,      & Prim_vector_ref,      & Prim_vector_set, 
        & Prim_vector_p,      & Prim_verify_heap,      & Prim_with_history_disabled,      & Prim_with_interrupt_mask, 
        & Prim_with_interrupts_reduced,      & Prim_with_stack_marker,      & Prim_within_control_point,      & Prim_working_dir_pathname, 
        & Prim_write_bits_x,      & Prim_write_byte_to_memory,      & Prim_write_float_to_memory,      & Prim_write_word_to_memory, 
        & Prim_zero_fixnum,      & Prim_zero,      & Prim_inexistent};
#line 1333 "/home/khheo/project/mit-scheme-9.2/src/microcode/usrdef.c"
char const   *Static_Primitive_Name_Table[655]  = 
#line 1333
  {      "%RECORD",      "%RECORD-LENGTH",      "%RECORD-REF",      "%RECORD-SET!", 
        "%RECORD?",      "&*",      "&+",      "&-", 
        "&/",      "&<",      "&=",      "&>", 
        "-1+",      "1+",      "ADD-TO-SELECT-REGISTRY",      "ADDRESS-TO-STRING", 
        "ALLOCATE-EXTERNAL-STRING",      "ALLOCATE-SELECT-REGISTRY",      "APPLY",      "ASCII->CHAR", 
        "ASSQ",      "BATCH-MODE?",      "BAUD-INDEX->RATE",      "BAUD-RATE->INDEX", 
        "BIGNUM->FIXNUM",      "BIGNUM->FLONUM",      "BIGNUM-ADD",      "BIGNUM-DIVIDE", 
        "BIGNUM-EQUAL?",      "BIGNUM-LENGTH-IN-BITS",      "BIGNUM-LESS?",      "BIGNUM-MULTIPLY", 
        "BIGNUM-NEGATIVE?",      "BIGNUM-POSITIVE?",      "BIGNUM-QUOTIENT",      "BIGNUM-REMAINDER", 
        "BIGNUM-SUBTRACT",      "BIGNUM-ZERO?",      "BINARY-FASLOAD",      "BIND-TCP-SERVER-SOCKET", 
        "BIT-STRING->UNSIGNED-INTEGER",      "BIT-STRING-ALLOCATE",      "BIT-STRING-AND!",      "BIT-STRING-ANDC!", 
        "BIT-STRING-CLEAR!",      "BIT-STRING-FILL!",      "BIT-STRING-LENGTH",      "BIT-STRING-MOVE!", 
        "BIT-STRING-MOVEC!",      "BIT-STRING-OR!",      "BIT-STRING-REF",      "BIT-STRING-SET!", 
        "BIT-STRING-XOR!",      "BIT-STRING-ZERO?",      "BIT-STRING=?",      "BIT-STRING?", 
        "BIT-SUBSTRING-FIND-NEXT-SET-BIT",      "BIT-SUBSTRING-MOVE-RIGHT!",      "BKPT/INSTALL",      "BKPT/PROCEED", 
        "BKPT/REMOVE",      "BKPT?",      "BUILTIN-INDEX->NAME",      "C-CALL", 
        "C-CALL-CONTINUE",      "C-FREE",      "C-MALLOC",      "C-PEEK-BYTES", 
        "C-PEEK-CHAR",      "C-PEEK-CSTRING",      "C-PEEK-CSTRING!",      "C-PEEK-CSTRINGP", 
        "C-PEEK-CSTRINGP!",      "C-PEEK-DOUBLE",      "C-PEEK-FLOAT",      "C-PEEK-INT", 
        "C-PEEK-LONG",      "C-PEEK-POINTER",      "C-PEEK-SHORT",      "C-PEEK-UCHAR", 
        "C-PEEK-UINT",      "C-PEEK-ULONG",      "C-PEEK-USHORT",      "C-POKE-BYTES", 
        "C-POKE-CHAR",      "C-POKE-DOUBLE",      "C-POKE-FLOAT",      "C-POKE-INT", 
        "C-POKE-LONG",      "C-POKE-POINTER",      "C-POKE-POINTER!",      "C-POKE-SHORT", 
        "C-POKE-STRING",      "C-POKE-STRING!",      "C-POKE-UCHAR",      "C-POKE-UINT", 
        "C-POKE-ULONG",      "C-POKE-USHORT",      "CALL-WITH-CURRENT-CONTINUATION",      "CANONICAL-HOST-NAME", 
        "CAR",      "CAST-IEEE754-DOUBLE-TO-INTEGER",      "CAST-IEEE754-SINGLE-TO-INTEGER",      "CAST-INTEGER-TO-IEEE754-DOUBLE", 
        "CAST-INTEGER-TO-IEEE754-SINGLE",      "CC-BLOCK-LINKAGE-INFO",      "CDR",      "CELL-CONTENTS", 
        "CELL?",      "CHANNEL-BLOCKING",      "CHANNEL-BLOCKING?",      "CHANNEL-CLOSE", 
        "CHANNEL-DESCRIPTOR",      "CHANNEL-FILE-ATTRIBUTES",      "CHANNEL-NONBLOCKING",      "CHANNEL-READ", 
        "CHANNEL-SYNCHRONIZE",      "CHANNEL-TABLE",      "CHANNEL-TYPE",      "CHANNEL-TYPE-NAME", 
        "CHANNEL-WRITE",      "CHAR->ASCII",      "CHAR->INTEGER",      "CHAR->SYNTAX-CODE", 
        "CHAR-ASCII?",      "CHAR-BITS",      "CHAR-CODE",      "CHAR-DOWNCASE", 
        "CHAR-UPCASE",      "CHAR?",      "CLEAR-FLOAT-EXCEPTIONS",      "CLEAR-INTERRUPTS!", 
        "CLOSE-LOST-OPEN-FILES",      "COERCE-TO-COMPILED-PROCEDURE",      "COMPILED-CLOSURE->ENTRY",      "COMPILED-CODE-ADDRESS->BLOCK", 
        "COMPILED-CODE-ADDRESS->OFFSET",      "COMPILED-ENTRY-KIND",      "CONS",      "CONSTANT?", 
        "CREATE-TCP-SERVER-SOCKET",      "CURRENT-GID",      "CURRENT-PID",      "CURRENT-UID", 
        "CURRENT-USER-HOME-DIRECTORY",      "CURRENT-USER-NAME",      "DEALLOCATE-EXTERNAL-STRING",      "DEALLOCATE-SELECT-REGISTRY", 
        "DEBUGGING-PRINTER",      "DECLARE-COMPILED-CODE-BLOCK",      "DECODE-TIME",      "DECODE-UTC", 
        "DEFER-FLOAT-EXCEPTION-TRAPS",      "DIRECTORY-DELETE",      "DIRECTORY-MAKE",      "DISABLE-INTERRUPTS!", 
        "DIVIDE-FIXNUM",      "DLD-LOAD-FILE",      "DLD-LOOKUP-SYMBOL",      "DLD-UNLOAD-FILE", 
        "DUMP-BAND",      "ENABLE-INTERRUPTS!",      "ENCODE-TIME",      "ENCODED-TIME", 
        "ENVIRONMENT-LINK-NAME",      "EQ?",      "EQUAL-FIXNUM?",      "ERROR-PROCEDURE", 
        "EXIT",      "EXIT-WITH-VALUE",      "EXTENDED-STRING-LENGTH",      "EXTERNAL-STRING?", 
        "FILE-ACCESS",      "FILE-ACCESS-TIME",      "FILE-ACCESS-TIME-INDIRECT",      "FILE-ATTRIBUTES", 
        "FILE-ATTRIBUTES-INDIRECT",      "FILE-COPY",      "FILE-DIRECTORY?",      "FILE-EQ?", 
        "FILE-EXISTS-DIRECT?",      "FILE-EXISTS?",      "FILE-LENGTH-NEW",      "FILE-LINK-HARD", 
        "FILE-LINK-SOFT",      "FILE-MOD-TIME",      "FILE-MOD-TIME-INDIRECT",      "FILE-MODES", 
        "FILE-OPEN-APPEND-CHANNEL",      "FILE-OPEN-EXCLUSIVE-OUTPUT-CHANNEL",      "FILE-OPEN-INPUT-CHANNEL",      "FILE-OPEN-IO-CHANNEL", 
        "FILE-OPEN-OUTPUT-CHANNEL",      "FILE-POSITION",      "FILE-REMOVE",      "FILE-REMOVE-LINK", 
        "FILE-RENAME",      "FILE-SET-POSITION",      "FILE-SOFT-LINK?",      "FILE-SYSTEM-TYPE", 
        "FILE-TIME->STRING",      "FILE-TOUCH",      "FILE-TRUNCATE",      "FILE-TYPE-DIRECT", 
        "FILE-TYPE-INDIRECT",      "FIND-SYMBOL",      "FIXNUM->BIGNUM",      "FIXNUM->FLONUM", 
        "FIXNUM-AND",      "FIXNUM-ANDC",      "FIXNUM-LSH",      "FIXNUM-NEGATE", 
        "FIXNUM-NOT",      "FIXNUM-OR",      "FIXNUM-QUOTIENT",      "FIXNUM-REMAINDER", 
        "FIXNUM-XOR",      "FIXNUM?",      "FLOAT-DIVIDE-BY-ZERO-EXCEPTION",      "FLOAT-ENVIRONMENT", 
        "FLOAT-EXCEPTIONS",      "FLOAT-INEXACT-RESULT-EXCEPTION",      "FLOAT-INVALID-OPERATION-EXCEPTION",      "FLOAT-OVERFLOW-EXCEPTION", 
        "FLOAT-ROUNDING-MODES",      "FLOAT-UNDERFLOW-EXCEPTION",      "FLOATING-VECTOR-CONS",      "FLOATING-VECTOR-LENGTH", 
        "FLOATING-VECTOR-REF",      "FLOATING-VECTOR-SET!",      "FLONUM->BIGNUM",      "FLONUM-ABS", 
        "FLONUM-ACOS",      "FLONUM-ADD",      "FLONUM-ASIN",      "FLONUM-ATAN", 
        "FLONUM-ATAN2",      "FLONUM-CEILING",      "FLONUM-CEILING->EXACT",      "FLONUM-COS", 
        "FLONUM-DENORMALIZE",      "FLONUM-DIVIDE",      "FLONUM-EQUAL?",      "FLONUM-EXP", 
        "FLONUM-EXPM1",      "FLONUM-EXPT",      "FLONUM-FLOOR",      "FLONUM-FLOOR->EXACT", 
        "FLONUM-GREATER?",      "FLONUM-INTEGER?",      "FLONUM-LESS?",      "FLONUM-LOG", 
        "FLONUM-LOG1P",      "FLONUM-MODULO",      "FLONUM-MULTIPLY",      "FLONUM-NEGATE", 
        "FLONUM-NEGATIVE?",      "FLONUM-NORMALIZE",      "FLONUM-POSITIVE?",      "FLONUM-ROUND", 
        "FLONUM-ROUND->EXACT",      "FLONUM-SIN",      "FLONUM-SQRT",      "FLONUM-SUBTRACT", 
        "FLONUM-TAN",      "FLONUM-TRUNCATE",      "FLONUM-TRUNCATE->EXACT",      "FLONUM-ZERO?", 
        "FLONUM?",      "FORCE",      "FULL-HOSTNAME",      "GARBAGE-COLLECT", 
        "GC-SPACE-STATUS",      "GC-TRACE-REFERENCES",      "GCD-FIXNUM",      "GENERAL-CAR-CDR", 
        "GET-COMMAND-LINE",      "GET-ENVIRONMENT-VARIABLE",      "GET-FIXED-OBJECTS-VECTOR",      "GET-FLOAT-ROUNDING-MODE", 
        "GET-HOST-BY-ADDRESS",      "GET-HOST-BY-NAME",      "GET-HOST-NAME",      "GET-INTERRUPT-ENABLES", 
        "GET-PRIMITIVE-ADDRESS",      "GET-PRIMITIVE-COUNTS",      "GET-PRIMITIVE-NAME",      "GET-SERVICE-BY-NAME", 
        "GET-SERVICE-BY-NUMBER",      "GET-UNUSED-COMMAND-LINE",      "GET-USER-HOME-DIRECTORY",      "GID->STRING", 
        "GREATER-THAN-FIXNUM?",      "HALT",      "HAVE-PTYS?",      "HAVE-SELECT?", 
        "HEAP-AVAILABLE?",      "HOST-ADDRESS-ANY",      "HOST-ADDRESS-LENGTH",      "HOST-ADDRESS-LOOPBACK", 
        "HOSTNAME",      "HUNK3-CONS",      "HUNK3-CXR",      "HUNK3-SET-CXR!", 
        "INDEX-FIXNUM?",      "INITIALIZE-C-COMPILED-BLOCK",      "INITIALIZE-LIARC-OBJECT-FILE",      "INSTRUCTION-ADDRESS->COMPILED-CODE-BLOCK", 
        "INTEGER->CHAR",      "INTEGER->FLONUM",      "INTEGER-ADD",      "INTEGER-ADD-1", 
        "INTEGER-BIT-COUNT",      "INTEGER-BITWISE-AND",      "INTEGER-BITWISE-ANDC1",      "INTEGER-BITWISE-ANDC2", 
        "INTEGER-BITWISE-EQV",      "INTEGER-BITWISE-IOR",      "INTEGER-BITWISE-NAND",      "INTEGER-BITWISE-NOR", 
        "INTEGER-BITWISE-NOT",      "INTEGER-BITWISE-ORC1",      "INTEGER-BITWISE-ORC2",      "INTEGER-BITWISE-XOR", 
        "INTEGER-DIVIDE",      "INTEGER-EQUAL?",      "INTEGER-FIRST-SET-BIT",      "INTEGER-GREATER?", 
        "INTEGER-HAMMING-DISTANCE",      "INTEGER-LENGTH",      "INTEGER-LENGTH-IN-BITS",      "INTEGER-LESS?", 
        "INTEGER-MULTIPLY",      "INTEGER-NEGATE",      "INTEGER-NEGATIVE-ZERO-BITS",      "INTEGER-NEGATIVE?", 
        "INTEGER-NONNEGATIVE-ONE-BITS",      "INTEGER-POSITIVE?",      "INTEGER-QUOTIENT",      "INTEGER-REMAINDER", 
        "INTEGER-SHIFT-LEFT",      "INTEGER-SHIFT-RIGHT",      "INTEGER-SUBTRACT",      "INTEGER-SUBTRACT-1", 
        "INTEGER-ZERO?",      "INTEGER?",      "INVOKE-C-THUNK",      "LENGTH", 
        "LESS-THAN-FIXNUM?",      "LEXICAL-ASSIGNMENT",      "LEXICAL-REFERENCE",      "LEXICAL-REFERENCE-TYPE", 
        "LEXICAL-UNASSIGNED?",      "LEXICAL-UNBOUND?",      "LEXICAL-UNREFERENCEABLE?",      "LIARC-COMPILED-BLOCKS", 
        "LINK-FILE",      "LINK-VARIABLES",      "LIST->INTEGER",      "LIST->VECTOR", 
        "LISTEN-TCP-SERVER-SOCKET",      "LISTIFY-BIGNUM",      "LOAD-BAND",      "LOCAL-ASSIGNMENT", 
        "LOCAL-REFERENCE",      "MACOSX-MAIN-BUNDLE-DIR",      "MAKE-BIT-STRING",      "MAKE-CELL", 
        "MAKE-CHAR",      "MAKE-EPHEMERON",      "MAKE-NON-POINTER-OBJECT",      "MAKE-PIPE", 
        "MAKE-SUBPROCESS",      "MAP-CODE-TO-MACHINE-ADDRESS",      "MAP-MACHINE-ADDRESS-TO-CODE",      "MEMQ", 
        "MICROCODE-IDENTIFY",      "MICROCODE-LIBRARY-PATH",      "MINUS-FIXNUM",      "MINUS-ONE-PLUS-FIXNUM", 
        "MODULO",      "MULTIPLY-FIXNUM",      "NANOTIME-SINCE-UTC-EPOCH",      "NEGATIVE-FIXNUM?", 
        "NEGATIVE?",      "NEW-DIRECTORY-CLOSE",      "NEW-DIRECTORY-OPEN",      "NEW-DIRECTORY-READ", 
        "NEW-DIRECTORY-READ-MATCHING",      "NEW-FILE-OPEN-APPEND-CHANNEL",      "NEW-FILE-OPEN-EXCLUSIVE-OUTPUT-CHANNEL",      "NEW-FILE-OPEN-INPUT-CHANNEL", 
        "NEW-FILE-OPEN-IO-CHANNEL",      "NEW-FILE-OPEN-OUTPUT-CHANNEL",      "NEW-MAKE-PIPE",      "NEW-OPEN-TCP-SERVER-SOCKET", 
        "NEW-OPEN-TCP-STREAM-SOCKET",      "NEW-OPEN-UNIX-STREAM-SOCKET",      "NEW-TCP-SERVER-CONNECTION-ACCEPT",      "NOT", 
        "NULL?",      "OBJECT-DATUM",      "OBJECT-GC-TYPE",      "OBJECT-SET-TYPE", 
        "OBJECT-TYPE",      "OBJECT-TYPE?",      "ONE-PLUS-FIXNUM",      "OPEN-PTY-MASTER", 
        "OS-JOB-CONTROL?",      "OUTF-ERROR",      "PAIR?",      "PLUS-FIXNUM", 
        "POSITIVE-FIXNUM?",      "POSITIVE?",      "PRIMITIVE-ADDRESS->DATUM",      "PRIMITIVE-APPLY-STEP", 
        "PRIMITIVE-DATUM->ADDRESS",      "PRIMITIVE-EVAL-STEP",      "PRIMITIVE-FASDUMP",      "PRIMITIVE-GET-FREE", 
        "PRIMITIVE-IMPURIFY",      "PRIMITIVE-INCREMENT-FREE",      "PRIMITIVE-INTEGER->OBJECT",      "PRIMITIVE-MAKE-OBJECT", 
        "PRIMITIVE-OBJECT->INTEGER",      "PRIMITIVE-OBJECT-ADDRESS",      "PRIMITIVE-OBJECT-DATUM",      "PRIMITIVE-OBJECT-EQ?", 
        "PRIMITIVE-OBJECT-REF",      "PRIMITIVE-OBJECT-SET!",      "PRIMITIVE-OBJECT-SET-TYPE",      "PRIMITIVE-OBJECT-TYPE", 
        "PRIMITIVE-OBJECT-TYPE?",      "PRIMITIVE-PROCEDURE-ARITY",      "PRIMITIVE-PROCEDURE-DOCUMENTATION",      "PRIMITIVE-PURIFY", 
        "PRIMITIVE-RETURN-STEP",      "PROCESS-CONTINUE-BACKGROUND",      "PROCESS-CONTINUE-FOREGROUND",      "PROCESS-DELETE", 
        "PROCESS-HANGUP",      "PROCESS-ID",      "PROCESS-INTERRUPT",      "PROCESS-JOB-CONTROL-STATUS", 
        "PROCESS-KILL",      "PROCESS-QUIT",      "PROCESS-REASON",      "PROCESS-SIGNAL", 
        "PROCESS-STATUS",      "PROCESS-STATUS-SYNC",      "PROCESS-STATUS-SYNC-ALL",      "PROCESS-STOP", 
        "PROCESS-TABLE",      "PROCESS-TIMER-CLEAR",      "PROCESS-TIMER-SET",      "PROCESS-WAIT", 
        "PROFILE-TIMER-CLEAR",      "PROFILE-TIMER-SET",      "PTY-MASTER-CONTINUE",      "PTY-MASTER-HANGUP", 
        "PTY-MASTER-INTERRUPT",      "PTY-MASTER-KILL",      "PTY-MASTER-QUIT",      "PTY-MASTER-SEND-SIGNAL", 
        "PTY-MASTER-STOP",      "PURE?",      "QUOTED-CHAR?",      "QUOTIENT", 
        "RAISE-FLOAT-EXCEPTIONS",      "RE-CHAR-SET-ADJOIN!",      "RE-COMPILE-FASTMAP",      "RE-MATCH-BUFFER", 
        "RE-MATCH-SUBSTRING",      "RE-SEARCH-BUFFER-BACKWARD",      "RE-SEARCH-BUFFER-FORWARD",      "RE-SEARCH-SUBSTRING-BACKWARD", 
        "RE-SEARCH-SUBSTRING-FORWARD",      "READ-BITS!",      "READ-BYTE-FROM-MEMORY",      "READ-FLOAT-FROM-MEMORY", 
        "READ-WORD-FROM-MEMORY",      "REAL-GID",      "REAL-TIME-CLOCK",      "REAL-TIMER-CLEAR", 
        "REAL-TIMER-SET",      "REAL-UID",      "REHASH",      "RELOAD-BAND-NAME", 
        "RELOAD-RETRIEVE-STRING",      "RELOAD-SAVE-STRING",      "REMAINDER",      "REMOVE-FROM-SELECT-REGISTRY", 
        "REQUEST-INTERRUPTS!",      "RESTORE-FLOAT-EXCEPTION-FLAGS",      "RETURN-TO-APPLICATION",      "RETURN-TO-C", 
        "RUN-CALLBACK",      "SAFE-LEXICAL-REFERENCE",      "SAVE-FLOAT-EXCEPTION-FLAGS",      "SCAN-BACKWARD-PREFIX-CHARS", 
        "SCAN-FORWARD-PREFIX-CHARS",      "SCAN-FORWARD-TO-WORD",      "SCAN-LIST-BACKWARD",      "SCAN-LIST-FORWARD", 
        "SCAN-SEXPS-FORWARD",      "SCAN-WORD-BACKWARD",      "SCAN-WORD-FORWARD",      "SCHEME-ENVIRONMENT", 
        "SCHEME-PROGRAM-NAME",      "SCODE-EVAL",      "SELECT-REGISTRY-LENGTH",      "SET-CAR!", 
        "SET-CDR!",      "SET-CELL-CONTENTS!",      "SET-CURRENT-HISTORY!",      "SET-DEBUG-FLAGS!", 
        "SET-FILE-MODES!",      "SET-FILE-TIMES!",      "SET-FIXED-OBJECTS-VECTOR!",      "SET-FLOAT-ENVIRONMENT", 
        "SET-FLOAT-ROUNDING-MODE",      "SET-INTERRUPT-ENABLES!",      "SET-STRING-LENGTH!",      "SET-STRING-MAXIMUM-LENGTH!", 
        "SET-TRAP-STATE!",      "SET-TRAPPED-FLOAT-EXCEPTIONS",      "SET-WORKING-DIRECTORY-PATHNAME!",      "SETUP-TIMER-INTERRUPT", 
        "SHUTDOWN-SOCKET",      "STACK-ADDRESS-OFFSET",      "STACK-TOP-ADDRESS",      "STRING->SYMBOL", 
        "STRING->SYNTAX-ENTRY",      "STRING-ALLOCATE",      "STRING-HASH",      "STRING-HASH-MOD", 
        "STRING-LENGTH",      "STRING-MAXIMUM-LENGTH",      "STRING-REF",      "STRING-SET!", 
        "STRING?",      "SUBSTRING-CI=?",      "SUBSTRING-DOWNCASE!",      "SUBSTRING-FIND-NEXT-CHAR-IN-SET", 
        "SUBSTRING-FIND-PREVIOUS-CHAR-IN-SET",      "SUBSTRING-MATCH-BACKWARD",      "SUBSTRING-MATCH-BACKWARD-CI",      "SUBSTRING-MATCH-FORWARD", 
        "SUBSTRING-MATCH-FORWARD-CI",      "SUBSTRING-MOVE-LEFT!",      "SUBSTRING-MOVE-RIGHT!",      "SUBSTRING-UPCASE!", 
        "SUBSTRING<?",      "SUBSTRING=?",      "SUBVECTOR->LIST",      "SUBVECTOR-FILL!", 
        "SUBVECTOR-MOVE-LEFT!",      "SUBVECTOR-MOVE-RIGHT!",      "SYSTEM",      "SYSTEM-CALL-ERROR-MESSAGE", 
        "SYSTEM-CLOCK",      "SYSTEM-HUNK3-CXR0",      "SYSTEM-HUNK3-CXR1",      "SYSTEM-HUNK3-CXR2", 
        "SYSTEM-HUNK3-SET-CXR0!",      "SYSTEM-HUNK3-SET-CXR1!",      "SYSTEM-HUNK3-SET-CXR2!",      "SYSTEM-LIST-TO-VECTOR", 
        "SYSTEM-PAIR-CAR",      "SYSTEM-PAIR-CDR",      "SYSTEM-PAIR-CONS",      "SYSTEM-PAIR-SET-CAR!", 
        "SYSTEM-PAIR-SET-CDR!",      "SYSTEM-PAIR?",      "SYSTEM-SUBVECTOR-TO-LIST",      "SYSTEM-VECTOR-REF", 
        "SYSTEM-VECTOR-SET!",      "SYSTEM-VECTOR-SIZE",      "SYSTEM-VECTOR?",      "TERMCAP-GET-FLAG", 
        "TERMCAP-GET-NUMBER",      "TERMCAP-GET-STRING",      "TERMCAP-GOTO-STRING",      "TERMCAP-INITIALIZE", 
        "TERMCAP-PAD-STRING",      "TERMCAP-PARAM-STRING",      "TERMINAL-BUFFERED",      "TERMINAL-BUFFERED?", 
        "TERMINAL-COOKED-OUTPUT",      "TERMINAL-COOKED-OUTPUT?",      "TERMINAL-DRAIN-OUTPUT",      "TERMINAL-FLUSH-INPUT", 
        "TERMINAL-FLUSH-OUTPUT",      "TERMINAL-GET-ISPEED",      "TERMINAL-GET-OSPEED",      "TERMINAL-GET-STATE", 
        "TERMINAL-NONBUFFERED",      "TERMINAL-RAW-OUTPUT",      "TERMINAL-SET-ISPEED",      "TERMINAL-SET-OSPEED", 
        "TERMINAL-SET-STATE",      "TEST-FLOAT-EXCEPTION-FLAGS",      "TEST-FLOAT-EXCEPTIONS",      "TEST-SELECT-DESCRIPTOR", 
        "TEST-SELECT-REGISTRY",      "TRAP-FLOAT-EXCEPTIONS",      "TRAPPABLE-FLOAT-EXCEPTIONS",      "TRAPPED-FLOAT-EXCEPTIONS", 
        "TTY-COMMAND-BEEP",      "TTY-COMMAND-CLEAR",      "TTY-GET-INTERRUPT-CHARS",      "TTY-GET-INTERRUPT-ENABLES", 
        "TTY-INPUT-CHANNEL",      "TTY-NEXT-INTERRUPT-CHAR",      "TTY-OUTPUT-CHANNEL",      "TTY-SET-INTERRUPT-CHARS!", 
        "TTY-SET-INTERRUPT-ENABLES",      "TTY-X-SIZE",      "TTY-Y-SIZE",      "TYPE->GC-TYPE", 
        "UID->STRING",      "UNBIND-VARIABLE",      "UNDER-EMACS?",      "UNSIGNED-INTEGER->BIT-STRING", 
        "UNTRAP-FLOAT-EXCEPTIONS",      "UPDATE-FLOAT-ENVIRONMENT",      "UTILITY-INDEX->NAME",      "UX-MAKE-SUBPROCESS", 
        "VECTOR",      "VECTOR-8B-FILL!",      "VECTOR-8B-FIND-NEXT-CHAR",      "VECTOR-8B-FIND-NEXT-CHAR-CI", 
        "VECTOR-8B-FIND-PREVIOUS-CHAR",      "VECTOR-8B-FIND-PREVIOUS-CHAR-CI",      "VECTOR-8B-REF",      "VECTOR-8B-SET!", 
        "VECTOR-CONS",      "VECTOR-LENGTH",      "VECTOR-REF",      "VECTOR-SET!", 
        "VECTOR?",      "VERIFY-HEAP",      "WITH-HISTORY-DISABLED",      "WITH-INTERRUPT-MASK", 
        "WITH-INTERRUPTS-REDUCED",      "WITH-STACK-MARKER",      "WITHIN-CONTROL-POINT",      "WORKING-DIRECTORY-PATHNAME", 
        "WRITE-BITS!",      "WRITE-BYTE-TO-MEMORY",      "WRITE-FLOAT-TO-MEMORY",      "WRITE-WORD-TO-MEMORY", 
        "ZERO-FIXNUM?",      "ZERO?",      "INEXISTENT-PRIMITIVE"};
#line 1991 "/home/khheo/project/mit-scheme-9.2/src/microcode/usrdef.c"
char const   *Static_Primitive_Documentation_Table[655]  = 
#line 1991
  {      (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      "(ADDRESS)\nTreat ADDRESS, a Scheme integer corresponding to a C unsigned long, as\na C char * pointer.  Allocate and return a Scheme string with the same\ncontents.", 
        (char const   *)0,      (char const   *)0,      "(PROCEDURE ARG-LIST)\nInvokes PROCEDURE on the arguments in ARG-LIST.",      (char const   *)0, 
        "(object alist)\n  These procedures find the first pair in ALIST whose car field is\n  OBJECT, and return that pair; the returned pair is always an\n  *element* of ALIST, *not* one of the pairs from which ALIST is\n  composed.  If no pair in ALIST has OBJECT as its car, `#f\' (n.b.:\n  not the empty list) is returned.  `assq\' uses `eq?\' to compare\n  OBJECT with the car fields of the pairs in ALIST, while `assv\'\n  uses `eqv?\' and `assoc\' uses `equal?\'.\n  \n       (define e \'((a 1) (b 2) (c 3)))\n       (assq \'a e)                             =>  (a 1)\n       (assq \'b e)                             =>  (b 2)\n       (assq \'d e)                             =>  #f\n       (assq (list \'a) \'(((a)) ((b)) ((c))))   =>  #f\n       (assoc (list \'a) \'(((a)) ((b)) ((c))))  =>  ((a))\n       (assq 5 \'((2 3) (5 7) (11 13)))         =>  unspecified\n       (assv 5 \'((2 3) (5 7) (11 13)))         =>  (5 7)\n  \n  Although they are often used as predicates, `assq\', `assv\', and\n  `assoc\' do not have question marks in their names because they return\n  useful values rather than just `#t\' or `#f\'. ",      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      "(NAMESTRING)\nLoad the contents of the file NAMESTRING into memory.  The file was\npresumably made by a call to PRIMITIVE-FASDUMP, and may contain data\nfor the heap and/or the pure area.  The value returned is the object\nthat was dumped.",      (char const   *)0, 
        "(BIT-STRING)\nBIT-STRING is converted to the appropriate non-negative integer. This operation is the inverse of `unsigned-integer->bit-string\'.",      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        "(BIT-STRING INDEX)\nSets the indexed bit to zero, returning its previous value as a boolean.",      "(BIT-STRING INITIALIZATION)\nFills the bit string with zeros if the initialization is false, otherwise fills it with ones.",      "(BIT-STRING)\nReturns the number of bits in BIT-STRING.",      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      "(BIT-STRING INDEX)\nReturns the boolean value of the indexed bit.",      "(BIT-STRING INDEX)\nSets the indexed bit to one, returning its previous value as a boolean.", 
        (char const   *)0,      "(BIT-STRING)\nReturns true the argument has no \"set\" bits.",      "(BIT-STRING-1 BIT-STRING-2)\nReturns true iff the two bit strings contain the same bits.",      (char const   *)0, 
        "(BIT-STRING START END)",      "(SOURCE START1 END1 DESTINATION START2)\nDestructively copies the substring of SOURCE between START1 and END1 into DESTINATION at START2.  The copying is done from the MSB to the LSB (which only matters when SOURCE and DESTINATION are the same).",      "(compiled-entry-object)\nInstall a breakpoint trap in a compiled code object.\nReturns false or a handled needed by REMOVE-BKPT and ONE-STEP-PROCEED.",      "(compiled-entry-object handle state)\nProceed the computation from the current breakpoint.", 
        "(compiled-entry-object handle)\nRemove a breakpoint trap installed by INSTALL-BKPT.",      "(compiled-entry-object)\nTrue if there is a breakpoint trap in compiled-entry-object.",      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      "(PROCEDURE)\nInvoke PROCEDURE with a copy of the current control stack.",      (char const   *)0, 
        "(pair)\n  Returns the contents of the car field of PAIR.\n  Note that it is an error to take the CAR of an empty list. ",      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      "(pair)\n  Returns the contents of the cdr field of PAIR.\n  Note that it is an error to take the CDR of an empty list. ",      (char const   *)0, 
        (char const   *)0,      "Put CHANNEL in blocking mode.",      "Return #F iff CHANNEL is in non-blocking mode.\nOtherwise, CHANNEL is in blocking mode.\nIf CHANNEL can be put in non-blocking mode, #T is returned.\nIf it cannot, 0 is returned.",      "Close file CHANNEL-NUMBER.", 
        (char const   *)0,      (char const   *)0,      "Put CHANNEL in non-blocking mode.",      "Read characters from CHANNEL, storing them in STRING.\nThird and fourth args START and END specify the substring to use.\nAttempt to fill that substring unless end-of-file is reached.\nReturn the number of characters actually read from CHANNEL.", 
        "(CHANNEL)\nSynchronize CHANNEL with any permanent storage associated with it,\nforcing any buffered data to be written permanently.",      "Return a vector of all channels in the channel table.",      "Return (as a nonnegative integer) the type of CHANNEL.",      "Return (as a string) the type of CHANNEL.", 
        "Write characters to CHANNEL, reading them from STRING.\nThird and fourth args START and END specify the substring to use.",      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      "(INTERRUPT-MASK)\nClears the interrupt bits in INTERRUPT-MASK by clearing the\ncorresponding bits in the interrupt code.\nSee `get-interrupt-enables\' for more information on interrupts.", 
        (char const   *)0,      (char const   *)0,      "Given a compiled closure, return the entry point which it invokes.",      "(ADDRESS)\nGiven a compiled-code entry ADDRESS, return its block.", 
        "(ADDRESS)\nGiven a compiled-code entry ADDRESS, return its offset into its block.",      (char const   *)0,      "(obj1 obj2)\n  Returns a newly allocated pair whose car is OBJ1 and whose cdr is OBJ2.\n  The pair is guaranteed to be different (in the sense of EQV?) from other\n  previously existing object. ",      "(OBJECT)\nReturns #T iff OBJECT is in constant space.", 
        (char const   *)0,      "Return Scheme\'s effective GID.",      "Return Scheme\'s PID.",      "Return Scheme\'s effective UID.", 
        "Return the name of the current user\'s home directory.",      "Return (as a string) the user name of the user running Scheme.",      (char const   *)0,      (char const   *)0, 
        "A cheap, built-in printer intended for debugging the interpreter.",      "Ensure cache coherence for a compiled-code block newly constructed.",      "Fill a vector with the second argument decoded.\nThe vector\'s elements are:\n  #(TAG second minute hour day month year day-of-week dst zone)",      "Fill a vector with the second argument decoded.\nThe vector\'s elements are:\n  #(TAG second minute hour day month year day-of-week dst zone)", 
        (char const   *)0,      "Delete directory called NAME.",      "Create a new directory, called NAME.",      "(INTERRUPT-MASK)\nDisables the interrupts specified in INTERRUPT-MASK by clearing the\ncorresponding bits in the interrupt mask. Returns previous mask value.\nSee `get-interrupt-enables\' for more information on interrupts.", 
        (char const   *)0,      "(FILENAME WEAK-PAIR)\nLoad the shared library FILENAME and store its handle\nin the cdr of WEAK-PAIR.",      "(HANDLE STRING)\nLook up the symbol named STRING in the shared library specified by HANDLE.\nReturn the symbol\'s address, or #F if no such symbol.",      "(HANDLE)\nUnload the shared library specified by HANDLE.\nThe file is unmapped from memory, and its symbols become unbound.", 
        "(PROCEDURE NAMESTRING)\nSaves an image of the current world to the file NAMESTRING.\nWhen the file is reloaded, PROCEDURE is called with an argument of #F.",      "(INTERRUPT-MASK)\nEnables the interrupts specified in INTERRUPT-MASK by setting the\ncorresponding bits in the interrupt mask. Returns previous mask value.\nSee `get-interrupt-enables\' for more information on interrupts.",      "Return the file time corresponding to the time structure given.",      "Return the current time as an integer.", 
        "(ENV1 ENV2 SYMBOL)\nSYMBOL must be bound in ENV2.  Creates a new binding for SYMBOL in ENV1,\nsuch that the bindings in ENV1 and ENV2 share the same value cell.\nIf SYMBOL is already bound in ENV1, the existing binding is modified.",      (char const   *)0,      (char const   *)0,      "(MESSAGE IRRITANTS ENVIRONMENT)\nSignal an error.", 
        "Exit Scheme with no option to restart.",      "Exit Scheme with no option to restart, returning integer argument\nas exit status.",      (char const   *)0,      (char const   *)0, 
        "Return #T iff FILENAME exists and is accessible according to MODE.\nMODE is an integer between 0 and 7 inclusive, bitwise encoded:\n  4 ==> file is readable;\n  2 ==> file is writable;\n  1 ==> file is executable.",      (char const   *)0,      (char const   *)0,      "Given a file name, return attribute information about the file.\nIf the file exists and its status information is accessible, the result\nis a vector of 10 items (see the reference manual for details).  Otherwise\nthe result is #F.", 
        "Like FILE-ATTRIBUTES but indirect through symbolic links.",      "Make a new copy of the file FROM-NAME, called TO-NAME.",      "Return #T iff FILENAME refers to an existing directory.\nOtherwise #F is returned, meaning either that FILENAME doesn\'t exist\n or that it isn\'t a directory.",      "True iff the two file arguments are the same file.", 
        "Return #T iff FILENAME refers to an existing file.\nReturn #F if the file doesn\'t exist.\nReturn zero if it\'s a symbolic link.\nSignal an error if the file\'s existence is indeterminate.",      "Return #T iff FILENAME refers to an existing file.\nReturn #F if the file doesn\'t exist.\nReturn zero if it\'s a symbolic link that points to a nonexisting file.\nSignal an error if the file\'s existence is indeterminate.",      "Return the length of CHANNEL in characters.",      "Create a hard link from file FROM-NAME to file TO-NAME.\nTO-NAME becomes another name for the file FROM-NAME.", 
        "Create a soft link from file FROM-NAME to file TO-NAME.\nTO-NAME becomes a soft link containing the string FROM-NAME.",      (char const   *)0,      (char const   *)0,      "Return mode bits of FILE, as an integer.", 
        "Open an output file called FILENAME, returning a channel number.\nIf the file exists, output is appended to its contents.",      "Open an output file called FILENAME, returning a channel number.\nIf the file exists, an error is signalled.",      "Open an input file called FILENAME, returning a channel number.",      "Open a file called FILENAME, returning a channel number.\nThe file is opened for both input and output.\nIf the file exists, its contents are not disturbed.", 
        "Open an output file called FILENAME, returning a channel number.\nIf the file exists, it is rewritten.",      "Return the position of CHANNEL\'s file-pointer.\nThis is a non-negative number strictly less than the file\'s length.",      "Delete file FILENAME.\nIf FILENAME is a soft link, the link is deleted.",      "If file FILENAME is a link to another file (hard or soft), remove it.", 
        "Rename file FROM-NAME to TO-NAME.",      "Set the file-pointer of CHANNEL to POSITION.\nPOSITION must be a non-negative number strictly less than the file\'s length.",      "Iff FILENAME refers to an existing soft link, return the link contents.\nOtherwise #F is returned, meaning either that FILENAME doesn\'t exist\n or that it isn\'t a soft link.",      (char const   *)0, 
        "Convert a file system time stamp into a date/time string.",      "Given a file name, change the times of the file to the current time.\nIf the file does not exist, create it.\nBoth the access time and modification time are changed.\nReturn #F if the file existed and its time was modified.\nOtherwise the file did not exist and it was created.",      "Set the length of CHANNEL to LENGTH.\nLENGTH must be a non-negative number.",      "Return type of FILE, as an exact non-negative integer.\nDon\'t indirect through symbolic links.", 
        "Return type of FILE, as an exact non-negative integer.\nIndirect through symbolic links.",      "(STRING)\nReturns the symbol named STRING, or #F if no such symbol exists.",      (char const   *)0,      "(FIXNUM)\nEquivalent to (INTEGER->FLONUM FIXNUM 2)", 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      "(PROMISE)\nReturn the value memoized in PROMISE, computing it if it has not been\nmemoized yet.",      "Returns the full hostname (including domain if available) as a string.",      "(SAFETY-MARGIN)\nPerforms a garbage collection and returns the number of words\navailable for further allocation.  Also sets the \"safety margin\",\nwhich is the number of reserved words at the top of the heap, to\nSAFETY-MARGIN, which must be a non-negative integer.  Finally, runs\nthe primitive GC daemons before returning.", 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      "(object path)\n This procedure is a generalization of `car\' and `cdr\'. PATH\n encodes a particular sequence of `car\' and `cdr\' operations, which\n `general-car-cdr\' executes on OBJECT. PATH is an exact\n non-negative integer that encodes the operations in a bitwise\n fashion: a zero bit represents a `cdr\' operation, and a one bit\n represents a `car\'.  The bits are executed LSB to MSB, and the\n most significant one bit, rather than being interpreted as an\n operation, signals the end of the sequence.\n \n For example, the following are equivalent:\n      (general-car-cdr OBJECT #b1011)\n      (cdr (car (car OBJECT)))\n \n Here is a partial table of path/operation equivalents:\n \n      #b10    cdr\n      #b11    car\n      #b100   cddr\n      #b101   cdar\n      #b110   cadr\n      #b111   caar\n      #b1000  cdddr\n  \n  Note that PATH is restricted to a machine-dependent range,\n  usually the size of a machine word.  On many machines, this means that\n  the maximum length of PATH will be 30 operations (32 bits, less the\n  sign bit and the ", 
        (char const   *)0,      "Look up the value of a variable in the user\'s shell environment.\nThe argument, a variable name, must be a string.\nThe result is either a string (the variable\'s value),\n or #F indicating that the variable does not exist.",      "()\nReturn the fixed objects vector (TM).",      (char const   *)0, 
        (char const   *)0,      "Given HOST-NAME, return its internet host numbers.\nThe result is a vector of strings, or #F if no such host exists.",      (char const   *)0,      "()\nReturns the current interrupt mask.\nThere are two interrupt bit masks:\n- The interrupt mask has a one bit for every enabled interrupt.\n- The interrupt code has a one bit for every interrupt pending service.\nInterrupts are prioritized according to their bit position (LSB is highest).\nAt any interrupt polling point, the highest enabled pending interrupt is\nserviced.  The interrupt handler is a two-argument Scheme procedure\ninvoked with all interrupts disabled and with the interrupt code and mask\nas arguments.  The interrupt mask is restored on return from the interrupt\nhandler.  To prevent re-servicing the interrupt, the interrupt handler\nshould clear the corresponding interrupt bit.", 
        "Given a symbol NAME, return the primitive object of that name.\nARITY is the number of arguments which the primitive should expect.\nIf ARITY is #F, #F is returned if the primitive is not implemented,\neven if the name already exists.\nIf ARITY is an integer, a primitive object will always be returned,\nwhether the corresponding primitive is implemented or not.",      "Return a pair of integers which are the number of primitive procedures.\nThe car is the count of defined primitives;\nthe cdr is the count of undefined primitives that are referenced.",      "Return the (string) name of PRIMITIVE-PROCEDURE.",      "Given SERVICE-NAME and PROTOCOL-NAME, return a port number.\nThe result is a nonnegative integer, or #F if no such service exists.", 
        "Given PORT-NUMBER, return it in the network encoding.",      (char const   *)0,      "Return the file name of a given user\'s home directory.\nThe user name argument must be a string.\nIf no such user is known, #F is returned.",      "Return the group name corresponding to GID.\nIf the argument is not a known group ID, #F is returned.", 
        (char const   *)0,      "Exit Scheme, suspending it to that it can be restarted.",      (char const   *)0,      (char const   *)0, 
        "(N-WORDS)\nTests to see if there are at least N-WORDS words of heap storage available",      (char const   *)0,      "The length of a host address string, in characters.",      (char const   *)0, 
        "Returns the hostname of the machine as a string.",      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      "Given the tag of a compiled object, return the object.",      "(ADDRESS PREFIX)\nRun the object-file initialization thunk specified by ADDRESS,\nusing PREFIX as the rewriting prefix for the subparts.",      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      "(ADDRESS)\nTreat ADDRESS, a Scheme integer corresponding to a C unsigned long, as\nthe address of a C procedure of no arguments that returns an unsigned\nlong.  Invoke it, and return the corresponding Scheme integer.",      "(list)\n  Returns the length of LIST. ", 
        (char const   *)0,      "(ASSIGNMENT ENVIRONMENT SYMBOL VALUE)\nSets the value of the variable in ENVIRONMENT named SYMBOL to VALUE.\nReturns the previous value.\n\nIndistinguishable from evaluating (set! SYMBOL VALUE) in ENVIRONMENT.",      "(ENVIRONMENT SYMBOL)\nReturns the value of the variable in ENVIRONMENT named SYMBOL.\n\nIndistinguishable from evaluating SYMBOL in ENVIRONMENT.",      "(ENVIRONMENT SYMBOL)\nReturns a index integer indicating the type of object stored in the\nbinding of SYMBOL within ENVIRONMENT.  The following values are defined:\n\n0 means unbound\n1 means unassigned\n2 means a normal binding\n3 means a macro binding", 
        "(ENVIRONMENT SYMBOL)\nReturns #T if the variable corresponding to SYMBOL is bound\nbut has the special UNASSIGNED value in ENVIRONMENT.  Returns\n#F otherwise.  Does a complete lexical search for SYMBOL\nstarting in ENVIRONMENT.\nThe special form (unassigned? <symbol>) is built on top of this.",      "(ENVIRONMENT SYMBOL)\nReturns #T if the variable corresponding to SYMBOL has no binding in\nENVIRONMENT.  Returns #F otherwise.  Does a complete lexical search\nfor SYMBOL starting in ENVIRONMENT.",      "(ENVIRONMENT SYMBOL)\nReturns #T if looking up SYMBOL in ENVIRONMENT would cause an error.\nReturns #F otherwise.",      "Return a vector containing the names of registered compiled-code blocks.", 
        "This is an obsolete primitive.  Use `file-link-hard\' or `file-link-soft\'.\nCreate a new name for file FROM-NAME, called TO-NAME.\nIf third arg HARD? is #F, a soft link is created;\n otherwise a hard link is created.",      "(TARGET-ENV TARGET-NAME SOURCE-ENV SOURCE-NAME)\nDefine a new binding for TARGET-NAME in TARGET-ENV, which shares its\nvalue cell with the binding for SOURCE-NAME in SOURCE-ENV.\nSOURCE-NAME must be bound in SOURCE-ENV.",      "(list radix negative?)\nLIST is a non-null list of digits in RADIX, most-significant first.\nConverts the list to an integer.  NEGATIVE? specifies the sign.",      (char const   *)0, 
        (char const   *)0,      "Returns a list of the digits of BIGNUM in RADIX.",      "(NAMESTRING)\nRestores the heap and constant space from the contents of the file\nNAMESTRING, which is typically a file created by DUMP-BAND.  The file\ncan, however, be any file which can be loaded with BINARY-FASLOAD.",      "(ENVIRONMENT SYMBOL VALUE)\n    [Should be called LEXICAL-DEFINE.]\n\nIf the variable specified by SYMBOL already exists in the\nlexical ENVIRONMENT, then its value there is changed to VALUE.\nOtherwise a new binding is created in that environment linking\nthe specified variable to the value.  Returns SYMBOL.\n\nIndistinguishable from evaluating (define SYMBOL VALUE) in ENVIRONMENT.", 
        "(REFERENCE ENVIRONMENT SYMBOL)\nIdentical to LEXICAL_REFERENCE, here for hysterical reasons.",      (char const   *)0,      "(SIZE INITIALIZATION)\nReturns a bit string of the specified size with all the bits\nset to zero if the initialization is false, one otherwise.",      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      "(DATUM)\nConvert the unsigned integer DATUM into a fixnum.\nAssert: (= (OBJECT-DATUM (MAKE-NON-POINTER-OBJECT X)) X).",      "Return a cons of two channels, the reader and writer of a pipe.", 
        "Create a subprocess.\nFirst arg FILENAME is the program to run.\nSecond arg ARGV is a vector of strings to pass to the program as arguments.\nThird arg ENV is a vector of strings to pass as the program\'s environment;\n  #F means inherit Scheme\'s environment.\nFourth arg CTTY specifies the program\'s controlling terminal:\n  #F means none;\n  -1 means use Scheme\'s controlling terminal in background;\n  -2 means use Scheme\'s controlling terminal in foreground;\n  string means open that terminal.\nFifth arg STDIN is the input channel for the subprocess.\nSixth arg STDOUT is the output channel for the subprocess.\nSeventh arg STDERR is the error channel for the subprocess.\n  Each channel arg can take these values:\n  #F means none;\n  -1 means use the corresponding channel from Scheme;\n  -2 means use the controlling terminal (valid only when CTTY is a string);\n  otherwise the argument must be a channel.",      "For return codes and primitives, this returns the internal\nrepresentation of the return address or primitive address given the\nexternal representation.\n\nThis accepts two arguments, TYPE-CODE and VALUE-CODE.  TYPE-CODE is\nthe microcode type of the object to be returned; it must be either a\nreturn address or primitive procedure type.  VALUE-CODE is the index\nnumber (i.e. external representation) of the desired result.",      "This is the inverse operation of `map-code-to-machine-address\'.  Given\na machine ADDRESS and a TYPE-CODE (either return code or primitive\nprocedure), it finds the number for the external representation for\nthe internal address.",      "(object list)\n  Returns the first pair of LIST whose car is OBJECT;\n  the returned pair is always one from which LIST is composed.\n  If OBJECT does not occur in LIST, `#f\' (n.b.: not the\n  empty list) is returned.  `memq\' uses `eq?\' to compare OBJECT with\n  the elements of LIST, while `memv\' uses `eqv?\' and `member\' uses\n  `equal?\'.\n  \n       (memq \'a \'(a b c))                      =>  (a b c)\n       (memq \'b \'(a b c))                      =>  (b c)\n       (memq \'a \'(b c d))                      =>  #f\n       (memq (list \'a) \'(b (a) c))             =>  #f\n       (member (list \'a) \'(b (a) c))           =>  ((a) c)\n       (memq 101 \'(100 101 102))               =>  unspecified\n       (memv 101 \'(100 101 102))               =>  (101 102)\n  \n  Although they are often used as predicates, `memq\', `memv\', and\n  `member\' do not have question marks in their names because they return\n  useful values rather than just `#t\' or `#f\'. ", 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      "Close DIRECTORY.",      "Open the directory NAME for reading, returning a directory number.",      "Read and return a filename from DIRECTORY, or #F if no more files.", 
        "Read and return a filename from DIRECTORY.\nThe filename must begin with the STRING.\nReturn #F if there are no more matching files in the directory.",      "Open an output file called FILENAME.\nThe channel number is saved in the cdr of WEAK-PAIR.\nIf the file exists, output is appended to its contents.",      "Open an output file called FILENAME.\nThe channel number is saved in the cdr of WEAK-PAIR.\nIf the file exists, an error is signalled.",      "Open an input file called FILENAME.\nThe channel number is saved in the cdr of WEAK-PAIR.", 
        "Open a file called FILENAME.\nThe channel number is saved in the cdr of WEAK-PAIR.\nThe file is opened for both input and output.\nIf the file exists, its contents are not disturbed.",      "Open an output file called FILENAME.\nThe channel number is saved in the cdr of WEAK-PAIR.\nIf the file exists, it is rewritten.",      "Store the reader and writer of a new pipe in the cdrs of weak pairs.",      "Given PORT-NUMBER, open TCP server socket.\nThe opened socket is stored in the cdr of WEAK-PAIR.", 
        "Given HOST-ADDRESS and PORT-NUMBER, open a TCP stream socket.\nThe opened socket is stored in the cdr of WEAK-PAIR.",      "Open the unix stream socket FILENAME.\nThe opened socket is stored in the cdr of WEAK-PAIR.",      "Poll SERVER-SOCKET for a connection.\nIf a connection is available, it is opened and #T is returned;\nthe opened socket is stored in the cdr of WEAK-PAIR.\nOtherwise, if SERVER-SOCKET is non-blocking, returns #F.\nSecond argument PEER-ADDRESS, if not #F, must be a host address string.\nIt is filled with the peer\'s address if given.",      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      "Open a PTY master, returning the master\'s channel and the slave\'s name.\nReturns a vector #(CHANNEL MASTER-NAME SLAVE-NAME).", 
        (char const   *)0,      (char const   *)0,      "(object)\n  Returns #t if object is a pair; otherwise returns #f.",      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      "(ADDRESS)\nReturn the object datum corresponding to ADDRESS.",      (char const   *)0, 
        "(DATUM)\nReturn the memory address corresponding to DATUM.",      (char const   *)0,      "(OBJECT NAMESTRING FLAG)\nWrites a binary representation of OBJECT to the file NAMESTRING.\nReturns #T if the operation is successful, or #F otherwise.\n\nFLAG specifies how to handle environment objects that OBJECT points\nto: #F means generate an error; #T means write them as ordinary\nobjects; any other value is like #F except that environments pointed\nat by compiled code are ignored (and discarded).",      "(TYPE-CODE)\nReturn the value of the free pointer tagged with TYPE-CODE", 
        "(OBJECT)\nRemove OBJECT from pure space, allowing it to be modified.",      "(N-WORDS)\nAdvance the free pointer by N-WORDS words.",      "(INTEGER)\nReturn the object whose representation is INTEGER.",      "(TYPE DATUM)\nReturn a new object made from TYPE and DATUM.", 
        "(OBJECT)\nReturn the integer representation of OBJECT.",      "(OBJECT)\nReturn the address part of OBJECT as an unsigned integer.",      "Return the datum part of OBJECT as an unsigned integer.",      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      "(TYPE OBJECT)\nReturn a new object made from TYPE and the datum part of OBJECT.",      "Return the type code of OBJECT as an unsigned integer.", 
        "Return #T if TYPE-CODE is OBJECT\'s type code, else #F.",      "Given a primitive procedure, returns the number of arguments it requires.",      "Given a primitive procedure, return its documentation string.",      "(OBJECT PURE? SAFETY-MARGIN)\nCopy OBJECT from the heap into constant/pure space.\nPURE? is ignored.", 
        (char const   *)0,      "Continues process PROCESS-NUMBER in the background.",      "Continues process PROCESS-NUMBER in the foreground.\nThe process must have the same controlling terminal as Scheme.",      "Delete process PROCESS-NUMBER from the process table.", 
        "Sends the hangup signal to process PROCESS-NUMBER (unix SIGHUP).",      "Return the process ID of process PROCESS-NUMBER.",      "Interrupts process PROCESS-NUMBER (unix SIGINT).",      "Returns the job-control status of process PROCESS-NUMBER:\n  0 means this system doesn\'t support job control.\n  1 means the process doesn\'t have the same controlling terminal as Scheme.\n  2 means it\'s the same ctty but the OS doesn\'t have job control.\n  3 means it\'s the same ctty and the OS has job control.", 
        "Kills process PROCESS-NUMBER (unix SIGKILL).",      "Sends the quit signal to process PROCESS-NUMBER (unix SIGQUIT).",      "Return the termination reason of process PROCESS-NUMBER.\nThis is a nonnegative integer, which depends on the process\'s status:\n  running => zero;\n  stopped => the signal that stopped the process;\n  exited => the exit code returned by the process;\n  signalled => the signal that killed the process.\nThe value is from the last synchronization.",      "Send a signal to process PROCESS-NUMBER; second arg SIGNAL says which one.", 
        "Return the status of process PROCESS-NUMBER, a nonnegative integer:\n  0 = running; 1 = stopped; 2 = exited; 3 = signalled.\nThe value is from the last synchronization.",      "Synchronize the status of process PROCESS-NUMBER.\nReturn #F if it was previously synchronized, #T if not.",      (char const   *)0,      "Stops process PROCESS-NUMBER (unix SIGTSTP).", 
        "Return a vector of all processes in the process table.",      "Turn off the process timer.",      "Set the process timer.\nFirst arg FIRST says how long to wait until the first interrupt;\nsecond arg INTERVAL says how long to wait between interrupts after that.\nBoth arguments are in units of milliseconds.",      "Waits until process PROCESS-NUMBER is not running.", 
        "Turn off the profile timer.",      "Set the profile timer.\nFirst arg FIRST says how long to wait until the first interrupt;\nsecond arg INTERVAL says how long to wait between interrupts after that.\nBoth arguments are in units of milliseconds.",      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      "Send a signal to PTY-MASTER; second arg says which one.", 
        (char const   *)0,      "(OBJECT)\nReturns #T iff OBJECT is in constant space and is \'pure\'.",      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      "(POINTER OFFSET BIT-STRING)\nRead the contents of memory at the address (POINTER,OFFSET) into BIT-STRING.",      "(ADDRESS)\nRead a byte from memory at ADDRESS and return it as an unsigned integer.",      "(ADDRESS)\nRead a float from memory at ADDRESS and return it as a flonum.", 
        "(ADDRESS)\nRead a word from memory at ADDRESS and return it as an unsigned integer.",      "Return Scheme\'s real GID.",      "Return the current real time in units of milliseconds.",      "Turn off the real timer.", 
        "Set the real timer.\nFirst arg FIRST says how long to wait until the first interrupt;\nsecond arg INTERVAL says how long to wait between interrupts after that.\nBoth arguments are in units of milliseconds.",      "Return Scheme\'s real UID.",      (char const   *)0,      "()\nReturn the filename from which the runtime system was last restored.\nThe result is a string, or #F if the system was not restored.", 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        "(INTERRUPT-MASK)\nRequests the interrupt bits in INTERRUPT-MASK by setting the\ncorresponding bits in the interrupt code.\nSee `get-interrupt-enables\' for more information on interrupts.",      (char const   *)0,      "(THUNK PROCEDURE . ARGS)\nInvokes THUNK with no arguments and a special return address.\nThe return address calls PROCEDURE on ARGS.\nThis is used by the runtime system to create stack frames that can be\nidentified by the continuation parser.",      (char const   *)0, 
        (char const   *)0,      "(ENVIRONMENT SYMBOL)\nLooks up SYMBOL in ENVIRONMENT and returns its value.\nIf the variable is unbound, signals an error.\nIf the variable is unassigned or holds a macro transformer,\n returns the appropriate trap object.",      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      "(SCODE-EXPRESSION ENVIRONMENT)\nEvaluate SCODE-EXPRESSION in ENVIRONMENT.",      (char const   *)0,      "(pair object)\n  Store OBJECT in the car field of PAIR.\n  The value returned by SET-CAR! is unspecified. ", 
        "(pair object)\n  Store OBJECT in the cdr field of PAIR.\n  The value returned by SET-CDR! is unspecified. ",      (char const   *)0,      "(HISTORY)\nSet the interpreter\'s history object to HISTORY.",      "(FLAG_NUMBER BOOLEAN)", 
        "Set the mode bits of FILE to MODE.",      "Change the access and modification times of FILE.\nThe second and third arguments are the respective times.\nThe file must exist and you must be the owner (or superuser).",      "(NEW-FOV)\nSet the fixed objects vector (TM) to NEW-FOV.",      (char const   *)0, 
        (char const   *)0,      "(INTERRUPT-MASK)\nSets the interrupt mask to INTERRUPT-MASK; returns previous mask value.\nSee `get-interrupt-enables\' for more information on interrupts.",      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      "Change the current working directory to NAME.",      "This is an obsolete primitive; use `process-timer-set\' instead.", 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      "(STRING)\nReturns the interned symbol named STRING, constructing a new symbol\nif needed.", 
        (char const   *)0,      (char const   *)0,      "(STRING)\nReturns the hash value for STRING, using the hashing algorithm for\ninterning symbols.",      "(STRING DENOMINATOR)\nDENOMINATOR must be a nonnegative integer.\nEquivalent to (MODULO (STRING-HASH STRING) DENOMINATOR).", 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      "Invoke sh (the Bourne shell) on the string argument.\nWait until the shell terminates, returning its exit status as an integer.",      (char const   *)0, 
        "Return the current process time in units of milliseconds.",      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      "Put TERMINAL into buffered mode.",      "Return #F iff TERMINAL is not in buffered mode.", 
        "Put TERMINAL into cooked output mode.",      "Return #F iff TERMINAL is not in cooked output mode.",      "Wait until all characters in TERMINAL\'s output buffer have been sent.",      "Discard any characters in TERMINAL\'s input buffer.", 
        "Discard any characters in TERMINAL\'s output buffer.",      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        "Put TERMINAL into nonbuffered mode.",      "Put TERMINAL into raw output mode.",      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        "Return a string that, when written to the display, will make it beep.",      "Return a string that, when written to the display, will clear it.",      "Return the current interrupt characters as a string.",      "Return the current keyboard interrupt enables.", 
        "Return the standard input channel.",      "Return the next interrupt character in the console input buffer.\nThe character is returned as an unsigned integer.",      "Return the standard output channel.",      "Change the current interrupt characters to STRING.\nSTRING must be in the correct form for this operating system.", 
        "Change the keyboard interrupt enables to MASK.",      "Return the display width in character columns.",      "Return the display height in character lines.",      (char const   *)0, 
        "Return the user name corresponding to UID.\nIf the argument is not a known user ID, #F is returned.",      "(ENVIRONMENT SYMBOL)\nUnbind the variable SYMBOL in ENVIRONMENT.\nReturns #F if the variable was not previously bound, otherwise #T.",      (char const   *)0,      "(LENGTH INTEGER)\nINTEGER, which must be a non-negative integer, is converted to a bit-string of length LENGTH.  If INTEGER is too large, an error is signalled.", 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      "(FILENAME ARGV ENV WORK-DIR STDIN STDOUT STDERR)\nCreate a subprocess.\nFILENAME is the program to run.\nARGV is a vector of strings to pass to the program as arguments.\nENV is a vector of strings to pass as the program\'s environment;\n  #F means inherit Scheme\'s environment.\nWORK-DIR is a string to pass as the program\'s working directory;\n  #F means inherit Scheme\'s working directory.\nCTTY specifies the program\'s controlling terminal:\n  #F means none;\n  -1 means use Scheme\'s controlling terminal in background;\n  -2 means use Scheme\'s controlling terminal in foreground;\n  string means open that terminal.\nSTDIN is the input channel for the subprocess.\nSTDOUT is the output channel for the subprocess.\nSTDERR is the error channel for the subprocess.\n  Each channel arg can take these values:\n  #F means none;\n  -1 means use the corresponding channel from Scheme;\n  -2 means use the controlling terminal (valid only when CTTY is a string);\n  otherwise the argument must be a channel.", 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      "Validate the heap.\nComplains if a scan of the heap encounters anything unexpected.\nReturns #T if the scan was successful and #F if there were any complaints.",      "(THUNK)\nExecute THUNK with the interpreter\'s history OFF.",      "(MASK RECEIVER)\nSet the interrupt mask to MASK for the duration of the call to RECEIVER.\nRECEIVER is passed the old interrupt mask as its argument.", 
        "(MASK RECEIVER)\nLike WITH-INTERRUPT-MASK, but only disables interrupts.",      "(THUNK MARKER1 MARKER2)\nCall THUNK with a continuation that has a special marker.\nWhen THUNK returns, the marker is discarded.\nThe value of THUNK is returned to the continuation of this primitive.\nThe marker consists of MARKER1 and MARKER2.\nBy convention, MARKER1 is a tag identifying the kind of marker,\nand MARKER2 is data identifying the marker instance.",      "(CONTROL-POINT THUNK)\nInvoke THUNK with CONTROL-POINT as its control stack.",      "Return the current working directory as a string.", 
        "(POINTER OFFSET BIT-STRING)\nWrite the contents of BIT-STRING in memory at the address (POINTER,OFFSET).",      "(BYTE ADDRESS)\nWrite BYTE to memory at ADDRESS.",      "(FLOAT ADDRESS)\nWrite FLOAT to memory at ADDRESS.",      "(WORD ADDRESS)\nWrite WORD to memory at ADDRESS.", 
        (char const   *)0,      (char const   *)0,      (char const   *)((char *)0)};
#line 3091 "/home/khheo/project/mit-scheme-9.2/src/microcode/usrdef.c"
int Static_Primitive_Arity_Table[655]  = 
#line 3091
  {      -1,      1,      2,      3, 
        1,      2,      2,      2, 
        2,      2,      2,      2, 
        1,      1,      3,      1, 
        1,      0,      2,      1, 
        2,      0,      1,      1, 
        1,      1,      2,      2, 
        2,      1,      2,      2, 
        1,      1,      2,      2, 
        2,      1,      1,      3, 
        1,      1,      2,      2, 
        2,      2,      1,      2, 
        2,      2,      2,      2, 
        2,      1,      2,      1, 
        3,      5,      1,      3, 
        2,      1,      1,      -1, 
        -1,      1,      2,      5, 
        2,      2,      2,      2, 
        2,      2,      2,      2, 
        2,      3,      2,      2, 
        2,      2,      2,      5, 
        3,      3,      3,      3, 
        3,      3,      3,      3, 
        3,      3,      3,      3, 
        3,      3,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      4, 
        1,      0,      1,      1, 
        4,      1,      1,      2, 
        1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      2,      1,      1, 
        1,      1,      2,      1, 
        0,      0,      0,      0, 
        0,      0,      1,      1, 
        1,      1,      2,      2, 
        0,      1,      1,      1, 
        2,      2,      2,      1, 
        2,      1,      1,      0, 
        3,      2,      2,      3, 
        0,      1,      1,      1, 
        2,      1,      1,      1, 
        1,      2,      1,      2, 
        1,      1,      1,      2, 
        2,      1,      1,      1, 
        1,      2,      1,      1, 
        1,      1,      1,      1, 
        2,      2,      1,      1, 
        1,      1,      2,      1, 
        1,      1,      1,      1, 
        2,      2,      2,      1, 
        1,      2,      2,      2, 
        2,      1,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      1,      1, 
        2,      3,      1,      1, 
        1,      2,      1,      1, 
        2,      1,      1,      1, 
        2,      2,      2,      1, 
        1,      2,      1,      1, 
        2,      1,      2,      1, 
        1,      2,      2,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      2, 
        1,      1,      1,      1, 
        1,      1,      0,      1, 
        0,      2,      2,      2, 
        0,      1,      0,      0, 
        1,      1,      0,      0, 
        2,      0,      1,      2, 
        1,      0,      1,      1, 
        2,      0,      0,      0, 
        1,      0,      0,      0, 
        0,      3,      2,      3, 
        1,      1,      2,      1, 
        1,      2,      2,      1, 
        1,      2,      2,      2, 
        2,      2,      2,      2, 
        1,      2,      2,      2, 
        2,      2,      1,      2, 
        2,      1,      1,      2, 
        2,      1,      2,      1, 
        2,      1,      2,      2, 
        2,      2,      2,      1, 
        1,      1,      1,      1, 
        2,      3,      2,      2, 
        2,      2,      2,      0, 
        3,      4,      3,      1, 
        1,      2,      1,      3, 
        2,      0,      2,      1, 
        2,      2,      1,      0, 
        7,      2,      2,      2, 
        0,      0,      2,      1, 
        2,      2,      1,      1, 
        1,      1,      1,      1, 
        2,      2,      2,      2, 
        2,      2,      2,      2, 
        3,      2,      3,      1, 
        1,      1,      1,      2, 
        1,      2,      1,      0, 
        0,      1,      1,      2, 
        1,      1,      1,      3, 
        1,      3,      3,      1, 
        1,      1,      1,      2, 
        1,      1,      1,      2, 
        2,      3,      2,      1, 
        2,      1,      1,      3, 
        2,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      2, 
        1,      1,      0,      1, 
        0,      0,      2,      1, 
        0,      2,      1,      1, 
        1,      1,      1,      2, 
        1,      1,      4,      2, 
        1,      2,      4,      7, 
        7,      7,      7,      7, 
        7,      3,      1,      1, 
        1,      0,      0,      0, 
        2,      0,      2,      0, 
        0,      1,      2,      3, 
        1,      2,      -1,      0, 
        0,      2,      1,      4, 
        4,      4,      7,      7, 
        7,      4,      4,      0, 
        0,      2,      1,      2, 
        2,      2,      1,      2, 
        2,      3,      1,      1, 
        1,      1,      2,      2, 
        1,      1,      1,      2, 
        2,      1,      0,      1, 
        1,      1,      1,      2, 
        1,      1,      2,      3, 
        1,      6,      3,      4, 
        4,      6,      6,      6, 
        6,      5,      5,      3, 
        6,      6,      3,      4, 
        5,      5,      1,      1, 
        0,      1,      1,      1, 
        2,      2,      2,      2, 
        1,      1,      3,      2, 
        2,      1,      3,      2, 
        3,      1,      1,      1, 
        1,      1,      5,      1, 
        4,      5,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      2,      2, 
        2,      2,      1,      3, 
        4,      1,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      1, 
        1,      0,      0,      1, 
        1,      2,      0,      2, 
        1,      1,      1,      8, 
        -1,      4,      4,      4, 
        4,      4,      2,      3, 
        2,      1,      2,      3, 
        1,      0,      1,      2, 
        2,      3,      2,      0, 
        3,      2,      2,      2, 
        1,      1,      -1};
#line 3749 "/home/khheo/project/mit-scheme-9.2/src/microcode/usrdef.c"
int Static_Primitive_Count_Table[655]  = 
#line 3749
  {      -1 * (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      3 * (int )sizeof(SCHEME_OBJECT ), 
        (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ), 
        2 * (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ), 
        (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      3 * (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ), 
        (int )sizeof(SCHEME_OBJECT ),      0,      2 * (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ), 
        2 * (int )sizeof(SCHEME_OBJECT ),      0,      (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ), 
        (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ), 
        2 * (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ), 
        (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ), 
        2 * (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      3 * (int )sizeof(SCHEME_OBJECT ), 
        (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ), 
        2 * (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ), 
        2 * (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ), 
        2 * (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ), 
        3 * (int )sizeof(SCHEME_OBJECT ),      5 * (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      3 * (int )sizeof(SCHEME_OBJECT ), 
        2 * (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      -1 * (int )sizeof(SCHEME_OBJECT ), 
        -1 * (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      5 * (int )sizeof(SCHEME_OBJECT ), 
        2 * (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ), 
        2 * (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ), 
        2 * (int )sizeof(SCHEME_OBJECT ),      3 * (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ), 
        2 * (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      5 * (int )sizeof(SCHEME_OBJECT ), 
        3 * (int )sizeof(SCHEME_OBJECT ),      3 * (int )sizeof(SCHEME_OBJECT ),      3 * (int )sizeof(SCHEME_OBJECT ),      3 * (int )sizeof(SCHEME_OBJECT ), 
        3 * (int )sizeof(SCHEME_OBJECT ),      3 * (int )sizeof(SCHEME_OBJECT ),      3 * (int )sizeof(SCHEME_OBJECT ),      3 * (int )sizeof(SCHEME_OBJECT ), 
        3 * (int )sizeof(SCHEME_OBJECT ),      3 * (int )sizeof(SCHEME_OBJECT ),      3 * (int )sizeof(SCHEME_OBJECT ),      3 * (int )sizeof(SCHEME_OBJECT ), 
        3 * (int )sizeof(SCHEME_OBJECT ),      3 * (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ), 
        (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ), 
        (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ), 
        (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ), 
        (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      4 * (int )sizeof(SCHEME_OBJECT ), 
        (int )sizeof(SCHEME_OBJECT ),      0,      (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ), 
        4 * (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ), 
        (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ), 
        (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ), 
        (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ), 
        (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ), 
        0,      0,      0,      0, 
        0,      0,      (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ), 
        (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ), 
        0,      (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ), 
        2 * (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ), 
        2 * (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      0, 
        3 * (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      3 * (int )sizeof(SCHEME_OBJECT ), 
        0,      (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ), 
        2 * (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ), 
        (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ), 
        (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ), 
        2 * (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ), 
        (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ), 
        (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ), 
        2 * (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ), 
        (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ), 
        (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ), 
        2 * (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ), 
        (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ), 
        2 * (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      0,      0, 
        0,      0,      0,      0, 
        0,      0,      (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ), 
        2 * (int )sizeof(SCHEME_OBJECT ),      3 * (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ), 
        (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ), 
        2 * (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ), 
        2 * (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ), 
        (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ), 
        2 * (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ), 
        (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ), 
        (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ), 
        (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ), 
        (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ), 
        (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      0,      (int )sizeof(SCHEME_OBJECT ), 
        0,      2 * (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ), 
        0,      (int )sizeof(SCHEME_OBJECT ),      0,      0, 
        (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      0,      0, 
        2 * (int )sizeof(SCHEME_OBJECT ),      0,      (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ), 
        (int )sizeof(SCHEME_OBJECT ),      0,      (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ), 
        2 * (int )sizeof(SCHEME_OBJECT ),      0,      0,      0, 
        (int )sizeof(SCHEME_OBJECT ),      0,      0,      0, 
        0,      3 * (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      3 * (int )sizeof(SCHEME_OBJECT ), 
        (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ), 
        (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ), 
        (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ), 
        2 * (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ), 
        (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ), 
        2 * (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ), 
        2 * (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ), 
        2 * (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ), 
        2 * (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ), 
        2 * (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ), 
        (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ), 
        2 * (int )sizeof(SCHEME_OBJECT ),      3 * (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ), 
        2 * (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      0, 
        3 * (int )sizeof(SCHEME_OBJECT ),      4 * (int )sizeof(SCHEME_OBJECT ),      3 * (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ), 
        (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      3 * (int )sizeof(SCHEME_OBJECT ), 
        2 * (int )sizeof(SCHEME_OBJECT ),      0,      2 * (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ), 
        2 * (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      0, 
        7 * (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ), 
        0,      0,      2 * (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ), 
        2 * (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ), 
        (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ), 
        2 * (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ), 
        2 * (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ), 
        3 * (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      3 * (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ), 
        (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ), 
        (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      0, 
        0,      (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ), 
        (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      3 * (int )sizeof(SCHEME_OBJECT ), 
        (int )sizeof(SCHEME_OBJECT ),      3 * (int )sizeof(SCHEME_OBJECT ),      3 * (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ), 
        (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ), 
        (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ), 
        2 * (int )sizeof(SCHEME_OBJECT ),      3 * (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ), 
        2 * (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      3 * (int )sizeof(SCHEME_OBJECT ), 
        2 * (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ), 
        (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ), 
        (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ), 
        (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      0,      (int )sizeof(SCHEME_OBJECT ), 
        0,      0,      2 * (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ), 
        0,      2 * (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ), 
        (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ), 
        (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      4 * (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ), 
        (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      4 * (int )sizeof(SCHEME_OBJECT ),      7 * (int )sizeof(SCHEME_OBJECT ), 
        7 * (int )sizeof(SCHEME_OBJECT ),      7 * (int )sizeof(SCHEME_OBJECT ),      7 * (int )sizeof(SCHEME_OBJECT ),      7 * (int )sizeof(SCHEME_OBJECT ), 
        7 * (int )sizeof(SCHEME_OBJECT ),      3 * (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ), 
        (int )sizeof(SCHEME_OBJECT ),      0,      0,      0, 
        2 * (int )sizeof(SCHEME_OBJECT ),      0,      2 * (int )sizeof(SCHEME_OBJECT ),      0, 
        0,      (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      3 * (int )sizeof(SCHEME_OBJECT ), 
        (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      -1 * (int )sizeof(SCHEME_OBJECT ),      0, 
        0,      2 * (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      4 * (int )sizeof(SCHEME_OBJECT ), 
        4 * (int )sizeof(SCHEME_OBJECT ),      4 * (int )sizeof(SCHEME_OBJECT ),      7 * (int )sizeof(SCHEME_OBJECT ),      7 * (int )sizeof(SCHEME_OBJECT ), 
        7 * (int )sizeof(SCHEME_OBJECT ),      4 * (int )sizeof(SCHEME_OBJECT ),      4 * (int )sizeof(SCHEME_OBJECT ),      0, 
        0,      2 * (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ), 
        2 * (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ), 
        2 * (int )sizeof(SCHEME_OBJECT ),      3 * (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ), 
        (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ), 
        (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ), 
        2 * (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      0,      (int )sizeof(SCHEME_OBJECT ), 
        (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ), 
        (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      3 * (int )sizeof(SCHEME_OBJECT ), 
        (int )sizeof(SCHEME_OBJECT ),      6 * (int )sizeof(SCHEME_OBJECT ),      3 * (int )sizeof(SCHEME_OBJECT ),      4 * (int )sizeof(SCHEME_OBJECT ), 
        4 * (int )sizeof(SCHEME_OBJECT ),      6 * (int )sizeof(SCHEME_OBJECT ),      6 * (int )sizeof(SCHEME_OBJECT ),      6 * (int )sizeof(SCHEME_OBJECT ), 
        6 * (int )sizeof(SCHEME_OBJECT ),      5 * (int )sizeof(SCHEME_OBJECT ),      5 * (int )sizeof(SCHEME_OBJECT ),      3 * (int )sizeof(SCHEME_OBJECT ), 
        6 * (int )sizeof(SCHEME_OBJECT ),      6 * (int )sizeof(SCHEME_OBJECT ),      3 * (int )sizeof(SCHEME_OBJECT ),      4 * (int )sizeof(SCHEME_OBJECT ), 
        5 * (int )sizeof(SCHEME_OBJECT ),      5 * (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ), 
        0,      (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ), 
        2 * (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ), 
        (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      3 * (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ), 
        2 * (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      3 * (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ), 
        3 * (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ), 
        (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      5 * (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ), 
        4 * (int )sizeof(SCHEME_OBJECT ),      5 * (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ), 
        (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ), 
        (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ), 
        (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ), 
        2 * (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      3 * (int )sizeof(SCHEME_OBJECT ), 
        4 * (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      (int )sizeof(SCHEME_OBJECT ), 
        (int )sizeof(SCHEME_OBJECT ),      0,      0,      (int )sizeof(SCHEME_OBJECT ), 
        (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      0,      2 * (int )sizeof(SCHEME_OBJECT ), 
        (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      8 * (int )sizeof(SCHEME_OBJECT ), 
        -1 * (int )sizeof(SCHEME_OBJECT ),      4 * (int )sizeof(SCHEME_OBJECT ),      4 * (int )sizeof(SCHEME_OBJECT ),      4 * (int )sizeof(SCHEME_OBJECT ), 
        4 * (int )sizeof(SCHEME_OBJECT ),      4 * (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      3 * (int )sizeof(SCHEME_OBJECT ), 
        2 * (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      3 * (int )sizeof(SCHEME_OBJECT ), 
        (int )sizeof(SCHEME_OBJECT ),      0,      (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ), 
        2 * (int )sizeof(SCHEME_OBJECT ),      3 * (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      0, 
        3 * (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ),      2 * (int )sizeof(SCHEME_OBJECT ), 
        (int )sizeof(SCHEME_OBJECT ),      (int )sizeof(SCHEME_OBJECT ),      -1 * (int )sizeof(SCHEME_OBJECT )};
#line 57 "/home/khheo/project/mit-scheme-9.2/src/microcode/dstack.h"
void *dstack_position ;
#line 60
void dstack_set_position(void *position___1 ) ;
#line 64
void dstack_bind(void *location , void *value ) ;
#line 43 "/home/khheo/project/mit-scheme-9.2/src/microcode/outf.h"
void ( /* format attribute */  outf_fatal)(char const   *format  , ...) ;
#line 40 "/home/khheo/project/mit-scheme-9.2/src/microcode/extern.h"
SCHEME_OBJECT Registers[352] ;
#line 51
void set_ptr_register(unsigned int index___0 , SCHEME_OBJECT *p ) ;
#line 52
void set_ulong_register(unsigned int index___0 , unsigned long value ) ;
#line 141
SCHEME_OBJECT *Free ;
#line 142
SCHEME_OBJECT *Free_primitive ;
#line 143
SCHEME_OBJECT *heap_alloc_limit ;
#line 144
SCHEME_OBJECT *heap_start ;
#line 145
SCHEME_OBJECT *heap_end ;
#line 147
SCHEME_OBJECT *stack_pointer ;
#line 148
SCHEME_OBJECT *stack_guard ;
#line 149
SCHEME_OBJECT *stack_start ;
#line 150
SCHEME_OBJECT *stack_end ;
#line 191
SCHEME_OBJECT *memory_block_start ;
#line 197
unsigned long gc_space_needed ;
#line 217
SCHEME_OBJECT ulong_to_integer(unsigned long number ) ;
#line 283
SCHEME_OBJECT hunk3_cons(SCHEME_OBJECT cxr0 , SCHEME_OBJECT cxr1 , SCHEME_OBJECT cxr2 ) ;
#line 295
SCHEME_OBJECT char_pointer_to_string(char const   *cp ) ;
#line 352
 __attribute__((__noreturn__)) void Microcode_Termination(int code ) ;
#line 121 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.h"
_Bool read_cc_entry_type(cc_entry_type_t *cet , insn_t *address___0 ) ;
#line 168
unsigned long cc_entry_to_block_offset(SCHEME_OBJECT entry ) ;
#line 169
SCHEME_OBJECT cc_entry_to_block(SCHEME_OBJECT entry ) ;
#line 170
SCHEME_OBJECT *cc_entry_to_block_address(SCHEME_OBJECT entry ) ;
#line 223
long coerce_to_compiled(SCHEME_OBJECT procedure , unsigned int arity , SCHEME_OBJECT *location ) ;
#line 296
_Bool cc_entry_closure_p(SCHEME_OBJECT entry ) ;
#line 300
SCHEME_OBJECT cc_closure_to_entry(SCHEME_OBJECT entry ) ;
#line 401
SCHEME_OBJECT return_to_interpreter ;
#line 422
void declare_compiled_code_block(SCHEME_OBJECT block ) ;
#line 437
SCHEME_OBJECT bkpt_install(insn_t *ep ) ;
#line 438
SCHEME_OBJECT bkpt_closure_install(insn_t *ep ) ;
#line 439
_Bool bkpt_p(insn_t *ep ) ;
#line 440
SCHEME_OBJECT bkpt_proceed(insn_t *ep , SCHEME_OBJECT handle , SCHEME_OBJECT state ) ;
#line 442
void bkpt_remove(insn_t *ep , SCHEME_OBJECT handle ) ;
#line 445
char const   *utility_index_to_name(unsigned int index___0 ) ;
#line 447
char const   *builtin_index_to_name(unsigned int index___0 ) ;
#line 42 "/home/khheo/project/mit-scheme-9.2/src/microcode/osscheme.h"
 __attribute__((__noreturn__)) void error_unimplemented_primitive(void) ;
#line 91 "/home/khheo/project/mit-scheme-9.2/src/microcode/prims.h"
 __attribute__((__noreturn__)) void signal_interrupt_from_primitive(void) ;
#line 92
 __attribute__((__noreturn__)) void error_wrong_type_arg(int n ) ;
#line 93
 __attribute__((__noreturn__)) void error_bad_range_arg(int n ) ;
#line 102
unsigned long arg_ulong_integer(int arg_number ) ;
#line 39 "/home/khheo/project/mit-scheme-9.2/src/microcode/comutl.c"
SCHEME_OBJECT Prim_comp_code_address_block(void) 
{ 
  SCHEME_OBJECT tmp ;

  {
  {
#line 43
  while (1) {
    while_continue: /* CIL Label */ ;
#line 43
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 44
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 44
    if (! (*(stack_pointer + 0) >> 58U == 40UL)) {
      {
#line 44
      error_wrong_type_arg(1);
      }
    }
#line 44
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 45
  tmp = cc_entry_to_block(*(stack_pointer + 0));
  }
#line 45
  return (tmp);
}
}
#line 48 "/home/khheo/project/mit-scheme-9.2/src/microcode/comutl.c"
SCHEME_OBJECT Prim_comp_code_address_offset(void) 
{ 
  unsigned long tmp ;

  {
  {
#line 52
  while (1) {
    while_continue: /* CIL Label */ ;
#line 52
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 53
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 53
    if (! (*(stack_pointer + 0) >> 58U == 40UL)) {
      {
#line 53
      error_wrong_type_arg(1);
      }
    }
#line 53
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 54
  tmp = cc_entry_to_block_offset(*(stack_pointer + 0));
  }
#line 54
  return ((26UL << 58U) | tmp);
}
}
#line 57 "/home/khheo/project/mit-scheme-9.2/src/microcode/comutl.c"
SCHEME_OBJECT Prim_stack_top_address(void) 
{ 
  SCHEME_OBJECT tmp ;

  {
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;
#line 59
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 60
  tmp = ulong_to_integer((SCHEME_OBJECT )stack_end);
  }
#line 60
  return (tmp);
}
}
#line 63 "/home/khheo/project/mit-scheme-9.2/src/microcode/comutl.c"
SCHEME_OBJECT Prim_stack_address_offset(void) 
{ 
  SCHEME_OBJECT *address___0 ;
  SCHEME_OBJECT tmp ;

  {
  {
#line 65
  while (1) {
    while_continue: /* CIL Label */ ;
#line 65
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 67
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 67
    if (! (*(stack_pointer + 0) >> 58U == 59UL)) {
      {
#line 67
      error_wrong_type_arg(1);
      }
    }
#line 67
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 69
  address___0 = (SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL);
#line 70
  if ((unsigned long )address___0 >= (unsigned long )stack_start) {
#line 70
    if (! ((unsigned long )address___0 < (unsigned long )stack_end)) {
      {
#line 71
      error_bad_range_arg(1);
      }
    }
  } else {
    {
#line 71
    error_bad_range_arg(1);
    }
  }
  {
#line 72
  tmp = ulong_to_integer((unsigned long )(stack_end - address___0));
  }
#line 72
  return (tmp);
}
}
#line 77 "/home/khheo/project/mit-scheme-9.2/src/microcode/comutl.c"
SCHEME_OBJECT Prim_compiled_entry_kind(void) 
{ 
  cc_entry_type_t cet ;
  unsigned long kind ;
  unsigned long field1 ;
  long field2 ;
  _Bool tmp ;
  SCHEME_OBJECT tmp___0 ;

  {
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
#line 79
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 80
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 80
    if (! (*(stack_pointer + 0) >> 58U == 40UL)) {
      {
#line 80
      error_wrong_type_arg(1);
      }
    }
#line 80
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 83
  kind = 4UL;
#line 84
  field1 = 0UL;
#line 85
  field2 = 0L;
#line 87
  tmp = read_cc_entry_type(& cet, (insn_t *)((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL)));
  }
#line 87
  if (! tmp) {
    {
#line 90
    if ((unsigned int )cet.marker == 0U) {
#line 90
      goto case_0;
    }
#line 98
    if ((unsigned int )cet.marker == 1U) {
#line 98
      goto case_1;
    }
#line 104
    if ((unsigned int )cet.marker == 2U) {
#line 104
      goto case_2;
    }
#line 110
    if ((unsigned int )cet.marker == 4U) {
#line 110
      goto case_4;
    }
#line 117
    if ((unsigned int )cet.marker == 5U) {
#line 117
      goto case_5;
    }
#line 117
    if ((unsigned int )cet.marker == 3U) {
#line 117
      goto case_5;
    }
#line 123
    if ((unsigned int )cet.marker == 6U) {
#line 123
      goto case_6;
    }
#line 129
    if ((unsigned int )cet.marker == 7U) {
#line 129
      goto case_7;
    }
#line 88
    goto switch_break;
    case_0: /* CIL Label */ 
#line 91
    kind = 0UL;
#line 92
    field1 = (unsigned long )(1U + cet.args.for_procedure.n_required);
#line 93
    field2 = (long )(field1 + (unsigned long )cet.args.for_procedure.n_optional);
#line 94
    if (cet.args.for_procedure.rest_p) {
#line 95
      field2 = - (field2 + 1L);
    }
#line 96
    goto switch_break;
    case_1: /* CIL Label */ 
#line 99
    kind = 1UL;
#line 100
    field1 = 0UL;
#line 101
    field2 = (long )cet.args.for_continuation.offset;
#line 102
    goto switch_break;
    case_2: /* CIL Label */ 
#line 105
    kind = 2UL;
#line 106
    field1 = 0UL;
#line 107
    field2 = 0L;
#line 108
    goto switch_break;
    case_4: /* CIL Label */ 
#line 111
    kind = 1UL;
#line 112
    field1 = 1UL;
#line 113
    field2 = -1L;
#line 114
    goto switch_break;
    case_5: /* CIL Label */ 
    case_3: /* CIL Label */ 
#line 118
    kind = 3UL;
#line 119
    field1 = 1UL;
#line 120
    field2 = 0L;
#line 121
    goto switch_break;
    case_6: /* CIL Label */ 
#line 124
    kind = 1UL;
#line 125
    field1 = 2UL;
#line 126
    field2 = (long )(*(stack_pointer + 0) != return_to_interpreter);
#line 127
    goto switch_break;
    case_7: /* CIL Label */ 
#line 130
    kind = 3UL;
#line 131
    field1 = 0UL;
#line 132
    field2 = 0L;
#line 133
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  {
#line 135
  tmp___0 = hunk3_cons((26UL << 58U) | kind, (26UL << 58U) | field1, (26UL << 58U) | ((unsigned long )field2 & 288230376151711743UL));
  }
#line 135
  return (tmp___0);
}
}
#line 142 "/home/khheo/project/mit-scheme-9.2/src/microcode/comutl.c"
SCHEME_OBJECT Prim_coerce_to_closure(void) 
{ 
  SCHEME_OBJECT temp ;
  long result ;
  unsigned long tmp ;
  long tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;
  SCHEME_OBJECT *tmp___2 ;
  SCHEME_OBJECT *tmp___3 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 145
  while (1) {
    while_continue: /* CIL Label */ ;
#line 145
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 148
  tmp = arg_ulong_integer(2);
#line 148
  tmp___0 = coerce_to_compiled(*(stack_pointer + 0), (unsigned int )tmp, & temp);
#line 148
  result = tmp___0;
  }
  {
#line 152
  if (result == -1L) {
#line 152
    goto case_neg_1;
  }
#line 155
  if (result == -4L) {
#line 155
    goto case_neg_4;
  }
#line 160
  goto switch_default;
  case_neg_1: /* CIL Label */ 
#line 153
  goto switch_break;
  case_neg_4: /* CIL Label */ 
  {
#line 156
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 156
    if ((unsigned long )Free_primitive < (unsigned long )heap_start) {
      {
#line 156
      outf_fatal("\nMicrocode requested primitive GC outside primitive!\n");
#line 156
      Microcode_Termination(12);
      }
    }
#line 156
    if ((unsigned long )Free < (unsigned long )Free_primitive) {
      {
#line 156
      outf_fatal("\nFree has gone backwards!\n");
#line 156
      Microcode_Termination(12);
      }
    }
    {
#line 156
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 156
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 156
        set_ulong_register(12U, Registers[12] | 4UL);
        }
        {
#line 156
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 156
          if ((Registers[1] & Registers[12]) != 0UL) {
#line 156
            tmp___2 = memory_block_start;
          } else {
#line 156
            if ((Registers[1] & 4UL) != 0UL) {
#line 156
              tmp___1 = heap_alloc_limit;
            } else {
#line 156
              tmp___1 = heap_end;
            }
#line 156
            tmp___2 = tmp___1;
          }
          {
#line 156
          set_ptr_register(0U, tmp___2);
          }
#line 156
          if ((Registers[1] & 1UL) != 0UL) {
#line 156
            tmp___3 = stack_guard;
          } else {
#line 156
            tmp___3 = stack_start;
          }
          {
#line 156
          set_ptr_register(11U, tmp___3);
          }
#line 156
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 156
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 156
      gc_space_needed = (unsigned long )(10L + (Free - Free_primitive));
#line 156
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 156
    signal_interrupt_from_primitive();
    }
#line 156
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 158
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 161
  error_bad_range_arg(2);
  }
#line 163
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 165
  return (temp);
}
}
#line 169 "/home/khheo/project/mit-scheme-9.2/src/microcode/comutl.c"
SCHEME_OBJECT Prim_cc_closure_to_entry(void) 
{ 
  _Bool tmp ;
  SCHEME_OBJECT tmp___0 ;

  {
  {
#line 172
  while (1) {
    while_continue: /* CIL Label */ ;
#line 172
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 173
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 173
    if (! (*(stack_pointer + 0) >> 58U == 40UL)) {
      {
#line 173
      error_wrong_type_arg(1);
      }
    }
#line 173
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 174
  tmp = cc_entry_closure_p(*(stack_pointer + 0));
  }
#line 174
  if (! tmp) {
    {
#line 175
    error_bad_range_arg(1);
    }
  }
  {
#line 176
  tmp___0 = cc_closure_to_entry(*(stack_pointer + 0));
  }
#line 176
  return (tmp___0);
}
}
#line 179 "/home/khheo/project/mit-scheme-9.2/src/microcode/comutl.c"
SCHEME_OBJECT Prim_utility_index_to_name(void) 
{ 
  char const   *name ;
  unsigned long tmp ;
  char const   *tmp___0 ;
  SCHEME_OBJECT tmp___1 ;
  unsigned long tmp___2 ;

  {
  {
#line 181
  while (1) {
    while_continue: /* CIL Label */ ;
#line 181
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 183
  tmp = arg_ulong_integer(1);
#line 183
  tmp___0 = utility_index_to_name((unsigned int )tmp);
#line 183
  name = tmp___0;
  }
#line 184
  if ((unsigned long )name == (unsigned long )((char const   *)0)) {
#line 184
    tmp___2 = 0UL;
  } else {
    {
#line 184
    tmp___1 = char_pointer_to_string(name);
#line 184
    tmp___2 = tmp___1;
    }
  }
#line 184
  return (tmp___2);
}
}
#line 188 "/home/khheo/project/mit-scheme-9.2/src/microcode/comutl.c"
SCHEME_OBJECT Prim_builtin_index_to_name(void) 
{ 
  char const   *name ;
  unsigned long tmp ;
  char const   *tmp___0 ;
  SCHEME_OBJECT tmp___1 ;
  unsigned long tmp___2 ;

  {
  {
#line 190
  while (1) {
    while_continue: /* CIL Label */ ;
#line 190
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 192
  tmp = arg_ulong_integer(1);
#line 192
  tmp___0 = builtin_index_to_name((unsigned int )tmp);
#line 192
  name = tmp___0;
  }
#line 193
  if ((unsigned long )name == (unsigned long )((char const   *)0)) {
#line 193
    tmp___2 = 0UL;
  } else {
    {
#line 193
    tmp___1 = char_pointer_to_string(name);
#line 193
    tmp___2 = tmp___1;
    }
  }
#line 193
  return (tmp___2);
}
}
#line 197 "/home/khheo/project/mit-scheme-9.2/src/microcode/comutl.c"
SCHEME_OBJECT Prim_initialize_C_compiled_block(void) 
{ 


  {
  {
#line 201
  while (1) {
    while_continue: /* CIL Label */ ;
#line 201
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 205
  return (0UL);
}
}
#line 210 "/home/khheo/project/mit-scheme-9.2/src/microcode/comutl.c"
static char const   *ilof_prefix  =    (char const   *)0;
#line 212 "/home/khheo/project/mit-scheme-9.2/src/microcode/comutl.c"
SCHEME_OBJECT Prim_initialize_liarc_object_file(void) 
{ 
  thunk_t *thunk ;
  unsigned long tmp ;
  char const   *prefix ;
  char *tmp___0 ;
  void *p ;
  unsigned long value ;
  unsigned long tmp___1 ;
  SCHEME_OBJECT tmp___2 ;

  {
  {
#line 217
  while (1) {
    while_continue: /* CIL Label */ ;
#line 217
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 219
  tmp = arg_ulong_integer(1);
#line 219
  thunk = (thunk_t *)tmp;
  }
#line 220
  if (*(stack_pointer + 1) >> 58U == 30UL) {
#line 220
    tmp___0 = (char *)((SCHEME_OBJECT *)(*(stack_pointer + 1) & 288230376151711743UL) + 2);
  } else {
    {
#line 220
    error_wrong_type_arg(2);
#line 220
    tmp___0 = (char *)0;
    }
  }
  {
#line 220
  prefix = (char const   *)tmp___0;
#line 221
  p = dstack_position;
#line 222
  dstack_bind((void *)(& ilof_prefix), (void *)prefix);
#line 224
  tmp___1 = (*thunk)();
#line 224
  value = tmp___1;
#line 225
  dstack_set_position(p);
#line 226
  tmp___2 = ulong_to_integer(value);
  }
#line 226
  return (tmp___2);
}
}
#line 231 "/home/khheo/project/mit-scheme-9.2/src/microcode/comutl.c"
char const   *liarc_object_file_prefix(void) 
{ 


  {
#line 234
  return (ilof_prefix);
}
}
#line 238 "/home/khheo/project/mit-scheme-9.2/src/microcode/comutl.c"
SCHEME_OBJECT Prim_declare_compiled_code_block(void) 
{ 
  SCHEME_OBJECT new_cc_block ;

  {
  {
#line 242
  while (1) {
    while_continue: /* CIL Label */ ;
#line 242
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 244
  new_cc_block = *(stack_pointer + 0);
#line 245
  if (! (new_cc_block >> 58U == 61UL)) {
    {
#line 246
    error_wrong_type_arg(1);
    }
  }
  {
#line 247
  declare_compiled_code_block(new_cc_block);
  }
#line 248
  return (8UL << 58U);
}
}
#line 252 "/home/khheo/project/mit-scheme-9.2/src/microcode/comutl.c"
SCHEME_OBJECT Prim_liarc_compiled_code_blocks(void) 
{ 


  {
  {
#line 256
  while (1) {
    while_continue: /* CIL Label */ ;
#line 256
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 293
  error_unimplemented_primitive();
  }
#line 294
  return ((8UL << 58U) | 1UL);
}
}
#line 298 "/home/khheo/project/mit-scheme-9.2/src/microcode/comutl.c"
SCHEME_OBJECT Prim_install_bkpt(void) 
{ 
  SCHEME_OBJECT *entry ;
  SCHEME_OBJECT *block ;
  _Bool tmp ;
  SCHEME_OBJECT tmp___0 ;
  SCHEME_OBJECT tmp___1 ;

  {
  {
#line 303
  while (1) {
    while_continue: /* CIL Label */ ;
#line 303
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 304
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 304
    if (! (*(stack_pointer + 0) >> 58U == 40UL)) {
      {
#line 304
      error_wrong_type_arg(1);
      }
    }
#line 304
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 307
  entry = (SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL);
#line 310
  tmp = bkpt_p((insn_t *)((void *)entry));
  }
#line 310
  if (tmp) {
    {
#line 311
    error_bad_range_arg(1);
    }
  }
  {
#line 313
  block = cc_entry_to_block_address(*(stack_pointer + 0));
  }
#line 314
  if (*(block + 0) >> 58U == 13UL) {
    {
#line 315
    tmp___0 = bkpt_closure_install((insn_t *)((void *)entry));
    }
#line 315
    return (tmp___0);
  } else {
    {
#line 317
    tmp___1 = bkpt_install((insn_t *)((void *)entry));
    }
#line 317
    return (tmp___1);
  }
}
}
#line 321 "/home/khheo/project/mit-scheme-9.2/src/microcode/comutl.c"
SCHEME_OBJECT Prim_remove_bkpt(void) 
{ 
  SCHEME_OBJECT *entry ;
  SCHEME_OBJECT handle ;
  _Bool tmp ;

  {
  {
#line 325
  while (1) {
    while_continue: /* CIL Label */ ;
#line 325
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 326
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 326
    if (! (*(stack_pointer + 0) >> 58U == 40UL)) {
      {
#line 326
      error_wrong_type_arg(1);
      }
    }
#line 326
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 327
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 327
    if (! (*(stack_pointer + 1) >> 58U == 22UL)) {
      {
#line 327
      error_wrong_type_arg(2);
      }
    }
#line 327
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 330
  entry = (SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL);
#line 331
  handle = *(stack_pointer + 1);
#line 333
  tmp = bkpt_p((insn_t *)((void *)entry));
  }
#line 333
  if (! tmp) {
    {
#line 334
    error_bad_range_arg(1);
    }
  }
  {
#line 335
  bkpt_remove((insn_t *)((void *)entry), handle);
  }
#line 336
  return ((8UL << 58U) | 1UL);
}
}
#line 340 "/home/khheo/project/mit-scheme-9.2/src/microcode/comutl.c"
SCHEME_OBJECT Prim_bkpt_p(void) 
{ 
  unsigned long tmp___0 ;
  _Bool tmp___1 ;

  {
  {
#line 344
  while (1) {
    while_continue: /* CIL Label */ ;
#line 344
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 345
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 345
    if (! (*(stack_pointer + 0) >> 58U == 40UL)) {
      {
#line 345
      error_wrong_type_arg(1);
      }
    }
#line 345
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 347
  tmp___1 = bkpt_p((insn_t *)((void *)((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL))));
  }
#line 347
  if (tmp___1) {
#line 347
    tmp___0 = 8UL << 58U;
  } else {
#line 347
    tmp___0 = 0UL;
  }
#line 347
  return (tmp___0);
}
}
#line 351 "/home/khheo/project/mit-scheme-9.2/src/microcode/comutl.c"
SCHEME_OBJECT Prim_bkpt_proceed(void) 
{ 
  SCHEME_OBJECT tmp ;

  {
  {
#line 355
  while (1) {
    while_continue: /* CIL Label */ ;
#line 355
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 356
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 356
    if (! (*(stack_pointer + 0) >> 58U == 40UL)) {
      {
#line 356
      error_wrong_type_arg(1);
      }
    }
#line 356
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 357
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 357
    if (! (*(stack_pointer + 1) >> 58U == 22UL)) {
      {
#line 357
      error_wrong_type_arg(2);
      }
    }
#line 357
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 359
  tmp = bkpt_proceed((insn_t *)((void *)((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL))),
                     *(stack_pointer + 1), *(stack_pointer + 2));
  }
#line 359
  return (tmp);
}
}
#line 177 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpintmd.h"
extern void x86_64_interface_initialize(void) ;
#line 180
extern void asm_assignment_trap(void) ;
#line 182
extern void asm_error(void) ;
#line 183
extern void asm_fixnum_shift(void) ;
#line 184
extern void asm_generic_add(void) ;
#line 185
extern void asm_generic_decrement(void) ;
#line 186
extern void asm_generic_divide(void) ;
#line 187
extern void asm_generic_equal(void) ;
#line 188
extern void asm_generic_greater(void) ;
#line 189
extern void asm_generic_increment(void) ;
#line 190
extern void asm_generic_less(void) ;
#line 191
extern void asm_generic_modulo(void) ;
#line 192
extern void asm_generic_multiply(void) ;
#line 193
extern void asm_generic_negative(void) ;
#line 194
extern void asm_generic_positive(void) ;
#line 195
extern void asm_generic_quotient(void) ;
#line 196
extern void asm_generic_remainder(void) ;
#line 197
extern void asm_generic_subtract(void) ;
#line 198
extern void asm_generic_zero(void) ;
#line 199
extern void asm_interrupt_closure(void) ;
#line 200
extern void asm_interrupt_continuation(void) ;
#line 201
extern void asm_interrupt_continuation_2(void) ;
#line 202
extern void asm_interrupt_dlink(void) ;
#line 203
extern void asm_interrupt_procedure(void) ;
#line 204
extern void asm_link(void) ;
#line 220
extern void asm_primitive_apply(void) ;
#line 221
extern void asm_primitive_error(void) ;
#line 222
extern void asm_primitive_lexpr_apply(void) ;
#line 223
extern void asm_reference_trap(void) ;
#line 224
extern void asm_safe_reference_trap(void) ;
#line 225
extern void asm_sc_apply(void) ;
#line 226
extern void asm_sc_apply_size_1(void) ;
#line 227
extern void asm_sc_apply_size_2(void) ;
#line 228
extern void asm_sc_apply_size_3(void) ;
#line 229
extern void asm_sc_apply_size_4(void) ;
#line 230
extern void asm_sc_apply_size_5(void) ;
#line 231
extern void asm_sc_apply_size_6(void) ;
#line 232
extern void asm_sc_apply_size_7(void) ;
#line 233
extern void asm_sc_apply_size_8(void) ;
#line 234
extern void asm_scheme_to_interface(void) ;
#line 235
extern void asm_scheme_to_interface_call(void) ;
#line 237
extern void asm_trampoline_to_interface(void) ;
#line 239
insn_t *read_compiled_closure_target(insn_t *start ) ;
#line 240
insn_t *read_uuo_target(SCHEME_OBJECT *saddr ) ;
#line 241
void x86_64_reset_hook(void) ;
#line 122 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.h"
_Bool write_cc_entry_type(cc_entry_type_t *cet , insn_t *address___0 ) ;
#line 124
_Bool decode_old_style_format_word(cc_entry_type_t *cet , unsigned short fw ) ;
#line 125
_Bool encode_old_style_format_word(cc_entry_type_t *cet , unsigned short *fw_r ) ;
#line 137
_Bool read_cc_entry_offset(cc_entry_offset_t *ceo , insn_t *address___0 ) ;
#line 138
_Bool write_cc_entry_offset(cc_entry_offset_t *ceo , insn_t *address___0 ) ;
#line 226
SCHEME_OBJECT read_uuo_symbol(SCHEME_OBJECT *saddr ) ;
#line 227
insn_t *read_uuo_target_no_reloc(SCHEME_OBJECT *saddr ) ;
#line 228
void write_uuo_target(insn_t *target , SCHEME_OBJECT *saddr ) ;
#line 230
unsigned int read_uuo_frame_size(SCHEME_OBJECT *saddr ) ;
#line 260
unsigned long compiled_closure_count(SCHEME_OBJECT *block ) ;
#line 264
insn_t *compiled_closure_start(SCHEME_OBJECT *block ) ;
#line 272
insn_t *compiled_closure_entry(insn_t *start ) ;
#line 277
insn_t *compiled_closure_next(insn_t *start ) ;
#line 281
SCHEME_OBJECT *skip_compiled_closure_padding(insn_t *start ) ;
#line 285
SCHEME_OBJECT compiled_closure_entry_to_target(insn_t *entry ) ;
#line 289
void write_compiled_closure_target(insn_t *target , insn_t *start ) ;
#line 324
unsigned long trampoline_entry_size(unsigned long n_entries ) ;
#line 328
insn_t *trampoline_entry_addr(SCHEME_OBJECT *block , unsigned long index___0 ) ;
#line 333
_Bool store_trampoline_insns(insn_t *entry , byte_t code ) ;
#line 448
void declare_builtin(unsigned long builtin , char const   *name ) ;
#line 36 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpintmd.c"
_Bool read_cc_entry_type(cc_entry_type_t *cet , insn_t *address___0 ) 
{ 
  _Bool tmp ;

  {
  {
#line 39
  tmp = decode_old_style_format_word(cet, *((uint16_t *)address___0 + -2));
  }
#line 39
  return (tmp);
}
}
#line 42 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpintmd.c"
_Bool write_cc_entry_type(cc_entry_type_t *cet , insn_t *address___0 ) 
{ 
  _Bool tmp ;

  {
  {
#line 45
  tmp = encode_old_style_format_word(cet, (uint16_t *)address___0 - 2);
  }
#line 45
  return (tmp);
}
}
#line 48 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpintmd.c"
_Bool read_cc_entry_offset(cc_entry_offset_t *ceo , insn_t *address___0 ) 
{ 
  uint16_t n ;

  {
#line 51
  n = *((uint16_t *)address___0 + -1);
#line 52
  ceo->offset = (unsigned long )((int )n >> 1);
#line 53
  ceo->continued_p = (_Bool )(((int )n & 1) != 0);
#line 54
  return ((_Bool)0);
}
}
#line 57 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpintmd.c"
_Bool write_cc_entry_offset(cc_entry_offset_t *ceo , insn_t *address___0 ) 
{ 
  int tmp ;

  {
#line 60
  if (! (ceo->offset < 16384UL)) {
#line 61
    return ((_Bool)1);
  }
#line 62
  if (ceo->continued_p) {
#line 62
    tmp = 1;
  } else {
#line 62
    tmp = 0;
  }
#line 62
  *((uint16_t *)address___0 + -1) = (uint16_t )((ceo->offset << 1) | (unsigned long )tmp);
#line 64
  return ((_Bool)0);
}
}
#line 71 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpintmd.c"
insn_t *read_compiled_closure_target(insn_t *start ) 
{ 


  {
#line 74
  return (*((insn_t **)((start + 4) + 2)));
}
}
#line 77 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpintmd.c"
void write_compiled_closure_target(insn_t *target , insn_t *start ) 
{ 


  {
#line 80
  *((insn_t **)((start + 4) + 2)) = target;
#line 81
  return;
}
}
#line 83 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpintmd.c"
unsigned long compiled_closure_count(SCHEME_OBJECT *block ) 
{ 


  {
#line 88
  return ((unsigned long )*((uint32_t *)block));
}
}
#line 91 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpintmd.c"
insn_t *compiled_closure_start(SCHEME_OBJECT *block ) 
{ 


  {
#line 95
  return ((insn_t *)block + 4);
}
}
#line 98 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpintmd.c"
insn_t *compiled_closure_entry(insn_t *start ) 
{ 


  {
#line 101
  return (start + 4);
}
}
#line 104 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpintmd.c"
insn_t *compiled_closure_next(insn_t *start ) 
{ 


  {
#line 107
  return ((start + 4) + 12);
}
}
#line 110 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpintmd.c"
SCHEME_OBJECT *skip_compiled_closure_padding(insn_t *start ) 
{ 


  {
#line 114
  return ((SCHEME_OBJECT *)(start + 4));
}
}
#line 117 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpintmd.c"
SCHEME_OBJECT compiled_closure_entry_to_target(insn_t *entry ) 
{ 


  {
#line 122
  return ((40UL << 58U) | (SCHEME_OBJECT )((SCHEME_OBJECT *)*((long *)(entry + 2))));
}
}
#line 139 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpintmd.c"
SCHEME_OBJECT read_uuo_symbol(SCHEME_OBJECT *saddr ) 
{ 


  {
#line 142
  return (*(saddr + 1));
}
}
#line 145 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpintmd.c"
unsigned int read_uuo_frame_size(SCHEME_OBJECT *saddr ) 
{ 


  {
#line 148
  return ((unsigned int )*((uint16_t *)saddr));
}
}
#line 151 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpintmd.c"
insn_t *read_uuo_target(SCHEME_OBJECT *saddr ) 
{ 
  insn_t *mov_addr ;

  {
#line 154
  mov_addr = (insn_t *)(saddr + 1);
#line 155
  return (*((insn_t **)(mov_addr + 2)));
}
}
#line 158 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpintmd.c"
insn_t *read_uuo_target_no_reloc(SCHEME_OBJECT *saddr ) 
{ 
  insn_t *tmp ;

  {
  {
#line 161
  tmp = read_uuo_target(saddr);
  }
#line 161
  return (tmp);
}
}
#line 164 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpintmd.c"
void write_uuo_target(insn_t *target , SCHEME_OBJECT *saddr ) 
{ 
  insn_t *addr ;
  insn_t *tmp ;
  insn_t *tmp___0 ;
  insn_t *tmp___1 ;
  insn_t *tmp___2 ;

  {
#line 168
  addr = (insn_t *)(saddr + 1);
#line 169
  tmp = addr;
#line 169
  addr ++;
#line 169
  *tmp = (insn_t )72;
#line 170
  tmp___0 = addr;
#line 170
  addr ++;
#line 170
  *tmp___0 = (insn_t )184;
#line 171
  *((insn_t **)addr) = target;
#line 172
  addr += 8;
#line 173
  tmp___1 = addr;
#line 173
  addr ++;
#line 173
  *tmp___1 = (insn_t )255;
#line 174
  tmp___2 = addr;
#line 174
  addr ++;
#line 174
  *tmp___2 = (insn_t )224;
#line 175
  return;
}
}
#line 184 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpintmd.c"
unsigned long trampoline_entry_size(unsigned long n_entries ) 
{ 


  {
#line 187
  return (n_entries * 2UL);
}
}
#line 190 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpintmd.c"
insn_t *trampoline_entry_addr(SCHEME_OBJECT *block , unsigned long index___0 ) 
{ 


  {
#line 193
  return (((insn_t *)((block + 2) + index___0 * 2UL) + 4) + 4);
}
}
#line 197 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpintmd.c"
_Bool store_trampoline_insns(insn_t *entry , byte_t code ) 
{ 
  insn_t *tmp ;
  insn_t *tmp___0 ;
  insn_t *tmp___1 ;
  insn_t *tmp___2 ;

  {
#line 200
  tmp = entry;
#line 200
  entry ++;
#line 200
  *tmp = (insn_t )176;
#line 201
  tmp___0 = entry;
#line 201
  entry ++;
#line 201
  *tmp___0 = code;
#line 202
  tmp___1 = entry;
#line 202
  entry ++;
#line 202
  *tmp___1 = (insn_t )255;
#line 203
  tmp___2 = entry;
#line 203
  entry ++;
#line 203
  *tmp___2 = (insn_t )150;
#line 204
  *((uint32_t *)entry) = (uint32_t )144;
#line 205
  return ((_Bool)0);
}
}
#line 221 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpintmd.c"
void x86_64_reset_hook(void) 
{ 
  int offset ;
  unsigned char *rsi_value ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;

  {
  {
#line 224
  offset = (int )(16UL * sizeof(SCHEME_OBJECT ));
#line 225
  rsi_value = (unsigned char *)(Registers);
#line 227
  x86_64_interface_initialize();
  }
  {
#line 231
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 231
    *((unsigned long *)(rsi_value + offset)) = (unsigned long )(& asm_scheme_to_interface);
#line 231
    offset = (int )((unsigned long )offset + sizeof(SCHEME_OBJECT ));
#line 231
    declare_builtin((unsigned long )(& asm_scheme_to_interface), "asm_scheme_to_interface");
    }
#line 231
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 232
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 232
    *((unsigned long *)(rsi_value + offset)) = (unsigned long )(& asm_scheme_to_interface_call);
#line 232
    offset = (int )((unsigned long )offset + sizeof(SCHEME_OBJECT ));
#line 232
    declare_builtin((unsigned long )(& asm_scheme_to_interface_call), "asm_scheme_to_interface_call");
    }
#line 232
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 234
  if (offset != 144) {
    {
#line 236
    outf_fatal("\nx86_64_reset_hook: RSI_TRAMPOLINE_TO_INTERFACE_OFFSET\n");
#line 237
    Microcode_Termination(12);
    }
  }
  {
#line 239
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 239
    *((unsigned long *)(rsi_value + offset)) = (unsigned long )(& asm_trampoline_to_interface);
#line 239
    offset = (int )((unsigned long )offset + sizeof(SCHEME_OBJECT ));
#line 239
    declare_builtin((unsigned long )(& asm_trampoline_to_interface), "asm_trampoline_to_interface");
    }
#line 239
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 241
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 241
    *((unsigned long *)(rsi_value + offset)) = (unsigned long )(& asm_interrupt_procedure);
#line 241
    offset = (int )((unsigned long )offset + sizeof(SCHEME_OBJECT ));
#line 241
    declare_builtin((unsigned long )(& asm_interrupt_procedure), "asm_interrupt_procedure");
    }
#line 241
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 242
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 242
    *((unsigned long *)(rsi_value + offset)) = (unsigned long )(& asm_interrupt_continuation);
#line 242
    offset = (int )((unsigned long )offset + sizeof(SCHEME_OBJECT ));
#line 242
    declare_builtin((unsigned long )(& asm_interrupt_continuation), "asm_interrupt_continuation");
    }
#line 242
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 243
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 243
    *((unsigned long *)(rsi_value + offset)) = (unsigned long )(& asm_interrupt_closure);
#line 243
    offset = (int )((unsigned long )offset + sizeof(SCHEME_OBJECT ));
#line 243
    declare_builtin((unsigned long )(& asm_interrupt_closure), "asm_interrupt_closure");
    }
#line 243
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 244
  while (1) {
    while_continue___5: /* CIL Label */ ;
    {
#line 244
    *((unsigned long *)(rsi_value + offset)) = (unsigned long )(& asm_interrupt_dlink);
#line 244
    offset = (int )((unsigned long )offset + sizeof(SCHEME_OBJECT ));
#line 244
    declare_builtin((unsigned long )(& asm_interrupt_dlink), "asm_interrupt_dlink");
    }
#line 244
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 245
  while (1) {
    while_continue___6: /* CIL Label */ ;
    {
#line 245
    *((unsigned long *)(rsi_value + offset)) = (unsigned long )(& asm_primitive_apply);
#line 245
    offset = (int )((unsigned long )offset + sizeof(SCHEME_OBJECT ));
#line 245
    declare_builtin((unsigned long )(& asm_primitive_apply), "asm_primitive_apply");
    }
#line 245
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 246
  while (1) {
    while_continue___7: /* CIL Label */ ;
    {
#line 246
    *((unsigned long *)(rsi_value + offset)) = (unsigned long )(& asm_primitive_lexpr_apply);
#line 246
    offset = (int )((unsigned long )offset + sizeof(SCHEME_OBJECT ));
#line 246
    declare_builtin((unsigned long )(& asm_primitive_lexpr_apply), "asm_primitive_lexpr_apply");
    }
#line 246
    goto while_break___7;
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 247
  while (1) {
    while_continue___8: /* CIL Label */ ;
    {
#line 247
    *((unsigned long *)(rsi_value + offset)) = (unsigned long )(& asm_assignment_trap);
#line 247
    offset = (int )((unsigned long )offset + sizeof(SCHEME_OBJECT ));
#line 247
    declare_builtin((unsigned long )(& asm_assignment_trap), "asm_assignment_trap");
    }
#line 247
    goto while_break___8;
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 248
  while (1) {
    while_continue___9: /* CIL Label */ ;
    {
#line 248
    *((unsigned long *)(rsi_value + offset)) = (unsigned long )(& asm_reference_trap);
#line 248
    offset = (int )((unsigned long )offset + sizeof(SCHEME_OBJECT ));
#line 248
    declare_builtin((unsigned long )(& asm_reference_trap), "asm_reference_trap");
    }
#line 248
    goto while_break___9;
  }
  while_break___9: /* CIL Label */ ;
  }
  {
#line 249
  while (1) {
    while_continue___10: /* CIL Label */ ;
    {
#line 249
    *((unsigned long *)(rsi_value + offset)) = (unsigned long )(& asm_safe_reference_trap);
#line 249
    offset = (int )((unsigned long )offset + sizeof(SCHEME_OBJECT ));
#line 249
    declare_builtin((unsigned long )(& asm_safe_reference_trap), "asm_safe_reference_trap");
    }
#line 249
    goto while_break___10;
  }
  while_break___10: /* CIL Label */ ;
  }
  {
#line 250
  while (1) {
    while_continue___11: /* CIL Label */ ;
    {
#line 250
    *((unsigned long *)(rsi_value + offset)) = (unsigned long )(& asm_link);
#line 250
    offset = (int )((unsigned long )offset + sizeof(SCHEME_OBJECT ));
#line 250
    declare_builtin((unsigned long )(& asm_link), "asm_link");
    }
#line 250
    goto while_break___11;
  }
  while_break___11: /* CIL Label */ ;
  }
  {
#line 251
  while (1) {
    while_continue___12: /* CIL Label */ ;
    {
#line 251
    *((unsigned long *)(rsi_value + offset)) = (unsigned long )(& asm_error);
#line 251
    offset = (int )((unsigned long )offset + sizeof(SCHEME_OBJECT ));
#line 251
    declare_builtin((unsigned long )(& asm_error), "asm_error");
    }
#line 251
    goto while_break___12;
  }
  while_break___12: /* CIL Label */ ;
  }
  {
#line 252
  while (1) {
    while_continue___13: /* CIL Label */ ;
    {
#line 252
    *((unsigned long *)(rsi_value + offset)) = (unsigned long )(& asm_primitive_error);
#line 252
    offset = (int )((unsigned long )offset + sizeof(SCHEME_OBJECT ));
#line 252
    declare_builtin((unsigned long )(& asm_primitive_error), "asm_primitive_error");
    }
#line 252
    goto while_break___13;
  }
  while_break___13: /* CIL Label */ ;
  }
  {
#line 253
  while (1) {
    while_continue___14: /* CIL Label */ ;
    {
#line 253
    *((unsigned long *)(rsi_value + offset)) = (unsigned long )(& asm_generic_add);
#line 253
    offset = (int )((unsigned long )offset + sizeof(SCHEME_OBJECT ));
#line 253
    declare_builtin((unsigned long )(& asm_generic_add), "asm_generic_add");
    }
#line 253
    goto while_break___14;
  }
  while_break___14: /* CIL Label */ ;
  }
  {
#line 254
  while (1) {
    while_continue___15: /* CIL Label */ ;
    {
#line 254
    *((unsigned long *)(rsi_value + offset)) = (unsigned long )(& asm_generic_subtract);
#line 254
    offset = (int )((unsigned long )offset + sizeof(SCHEME_OBJECT ));
#line 254
    declare_builtin((unsigned long )(& asm_generic_subtract), "asm_generic_subtract");
    }
#line 254
    goto while_break___15;
  }
  while_break___15: /* CIL Label */ ;
  }
  {
#line 255
  while (1) {
    while_continue___16: /* CIL Label */ ;
    {
#line 255
    *((unsigned long *)(rsi_value + offset)) = (unsigned long )(& asm_generic_multiply);
#line 255
    offset = (int )((unsigned long )offset + sizeof(SCHEME_OBJECT ));
#line 255
    declare_builtin((unsigned long )(& asm_generic_multiply), "asm_generic_multiply");
    }
#line 255
    goto while_break___16;
  }
  while_break___16: /* CIL Label */ ;
  }
  {
#line 256
  while (1) {
    while_continue___17: /* CIL Label */ ;
    {
#line 256
    *((unsigned long *)(rsi_value + offset)) = (unsigned long )(& asm_generic_divide);
#line 256
    offset = (int )((unsigned long )offset + sizeof(SCHEME_OBJECT ));
#line 256
    declare_builtin((unsigned long )(& asm_generic_divide), "asm_generic_divide");
    }
#line 256
    goto while_break___17;
  }
  while_break___17: /* CIL Label */ ;
  }
  {
#line 257
  while (1) {
    while_continue___18: /* CIL Label */ ;
    {
#line 257
    *((unsigned long *)(rsi_value + offset)) = (unsigned long )(& asm_generic_equal);
#line 257
    offset = (int )((unsigned long )offset + sizeof(SCHEME_OBJECT ));
#line 257
    declare_builtin((unsigned long )(& asm_generic_equal), "asm_generic_equal");
    }
#line 257
    goto while_break___18;
  }
  while_break___18: /* CIL Label */ ;
  }
  {
#line 258
  while (1) {
    while_continue___19: /* CIL Label */ ;
    {
#line 258
    *((unsigned long *)(rsi_value + offset)) = (unsigned long )(& asm_generic_less);
#line 258
    offset = (int )((unsigned long )offset + sizeof(SCHEME_OBJECT ));
#line 258
    declare_builtin((unsigned long )(& asm_generic_less), "asm_generic_less");
    }
#line 258
    goto while_break___19;
  }
  while_break___19: /* CIL Label */ ;
  }
  {
#line 259
  while (1) {
    while_continue___20: /* CIL Label */ ;
    {
#line 259
    *((unsigned long *)(rsi_value + offset)) = (unsigned long )(& asm_generic_greater);
#line 259
    offset = (int )((unsigned long )offset + sizeof(SCHEME_OBJECT ));
#line 259
    declare_builtin((unsigned long )(& asm_generic_greater), "asm_generic_greater");
    }
#line 259
    goto while_break___20;
  }
  while_break___20: /* CIL Label */ ;
  }
  {
#line 260
  while (1) {
    while_continue___21: /* CIL Label */ ;
    {
#line 260
    *((unsigned long *)(rsi_value + offset)) = (unsigned long )(& asm_generic_increment);
#line 260
    offset = (int )((unsigned long )offset + sizeof(SCHEME_OBJECT ));
#line 260
    declare_builtin((unsigned long )(& asm_generic_increment), "asm_generic_increment");
    }
#line 260
    goto while_break___21;
  }
  while_break___21: /* CIL Label */ ;
  }
  {
#line 261
  while (1) {
    while_continue___22: /* CIL Label */ ;
    {
#line 261
    *((unsigned long *)(rsi_value + offset)) = (unsigned long )(& asm_generic_decrement);
#line 261
    offset = (int )((unsigned long )offset + sizeof(SCHEME_OBJECT ));
#line 261
    declare_builtin((unsigned long )(& asm_generic_decrement), "asm_generic_decrement");
    }
#line 261
    goto while_break___22;
  }
  while_break___22: /* CIL Label */ ;
  }
  {
#line 262
  while (1) {
    while_continue___23: /* CIL Label */ ;
    {
#line 262
    *((unsigned long *)(rsi_value + offset)) = (unsigned long )(& asm_generic_zero);
#line 262
    offset = (int )((unsigned long )offset + sizeof(SCHEME_OBJECT ));
#line 262
    declare_builtin((unsigned long )(& asm_generic_zero), "asm_generic_zero");
    }
#line 262
    goto while_break___23;
  }
  while_break___23: /* CIL Label */ ;
  }
  {
#line 263
  while (1) {
    while_continue___24: /* CIL Label */ ;
    {
#line 263
    *((unsigned long *)(rsi_value + offset)) = (unsigned long )(& asm_generic_positive);
#line 263
    offset = (int )((unsigned long )offset + sizeof(SCHEME_OBJECT ));
#line 263
    declare_builtin((unsigned long )(& asm_generic_positive), "asm_generic_positive");
    }
#line 263
    goto while_break___24;
  }
  while_break___24: /* CIL Label */ ;
  }
  {
#line 264
  while (1) {
    while_continue___25: /* CIL Label */ ;
    {
#line 264
    *((unsigned long *)(rsi_value + offset)) = (unsigned long )(& asm_generic_negative);
#line 264
    offset = (int )((unsigned long )offset + sizeof(SCHEME_OBJECT ));
#line 264
    declare_builtin((unsigned long )(& asm_generic_negative), "asm_generic_negative");
    }
#line 264
    goto while_break___25;
  }
  while_break___25: /* CIL Label */ ;
  }
  {
#line 265
  while (1) {
    while_continue___26: /* CIL Label */ ;
    {
#line 265
    *((unsigned long *)(rsi_value + offset)) = (unsigned long )(& asm_generic_quotient);
#line 265
    offset = (int )((unsigned long )offset + sizeof(SCHEME_OBJECT ));
#line 265
    declare_builtin((unsigned long )(& asm_generic_quotient), "asm_generic_quotient");
    }
#line 265
    goto while_break___26;
  }
  while_break___26: /* CIL Label */ ;
  }
  {
#line 266
  while (1) {
    while_continue___27: /* CIL Label */ ;
    {
#line 266
    *((unsigned long *)(rsi_value + offset)) = (unsigned long )(& asm_generic_remainder);
#line 266
    offset = (int )((unsigned long )offset + sizeof(SCHEME_OBJECT ));
#line 266
    declare_builtin((unsigned long )(& asm_generic_remainder), "asm_generic_remainder");
    }
#line 266
    goto while_break___27;
  }
  while_break___27: /* CIL Label */ ;
  }
  {
#line 267
  while (1) {
    while_continue___28: /* CIL Label */ ;
    {
#line 267
    *((unsigned long *)(rsi_value + offset)) = (unsigned long )(& asm_generic_modulo);
#line 267
    offset = (int )((unsigned long )offset + sizeof(SCHEME_OBJECT ));
#line 267
    declare_builtin((unsigned long )(& asm_generic_modulo), "asm_generic_modulo");
    }
#line 267
    goto while_break___28;
  }
  while_break___28: /* CIL Label */ ;
  }
  {
#line 268
  while (1) {
    while_continue___29: /* CIL Label */ ;
    {
#line 268
    *((unsigned long *)(rsi_value + offset)) = (unsigned long )(& asm_sc_apply);
#line 268
    offset = (int )((unsigned long )offset + sizeof(SCHEME_OBJECT ));
#line 268
    declare_builtin((unsigned long )(& asm_sc_apply), "asm_sc_apply");
    }
#line 268
    goto while_break___29;
  }
  while_break___29: /* CIL Label */ ;
  }
  {
#line 269
  while (1) {
    while_continue___30: /* CIL Label */ ;
    {
#line 269
    *((unsigned long *)(rsi_value + offset)) = (unsigned long )(& asm_sc_apply_size_1);
#line 269
    offset = (int )((unsigned long )offset + sizeof(SCHEME_OBJECT ));
#line 269
    declare_builtin((unsigned long )(& asm_sc_apply_size_1), "asm_sc_apply_size_1");
    }
#line 269
    goto while_break___30;
  }
  while_break___30: /* CIL Label */ ;
  }
  {
#line 270
  while (1) {
    while_continue___31: /* CIL Label */ ;
    {
#line 270
    *((unsigned long *)(rsi_value + offset)) = (unsigned long )(& asm_sc_apply_size_2);
#line 270
    offset = (int )((unsigned long )offset + sizeof(SCHEME_OBJECT ));
#line 270
    declare_builtin((unsigned long )(& asm_sc_apply_size_2), "asm_sc_apply_size_2");
    }
#line 270
    goto while_break___31;
  }
  while_break___31: /* CIL Label */ ;
  }
  {
#line 271
  while (1) {
    while_continue___32: /* CIL Label */ ;
    {
#line 271
    *((unsigned long *)(rsi_value + offset)) = (unsigned long )(& asm_sc_apply_size_3);
#line 271
    offset = (int )((unsigned long )offset + sizeof(SCHEME_OBJECT ));
#line 271
    declare_builtin((unsigned long )(& asm_sc_apply_size_3), "asm_sc_apply_size_3");
    }
#line 271
    goto while_break___32;
  }
  while_break___32: /* CIL Label */ ;
  }
  {
#line 272
  while (1) {
    while_continue___33: /* CIL Label */ ;
    {
#line 272
    *((unsigned long *)(rsi_value + offset)) = (unsigned long )(& asm_sc_apply_size_4);
#line 272
    offset = (int )((unsigned long )offset + sizeof(SCHEME_OBJECT ));
#line 272
    declare_builtin((unsigned long )(& asm_sc_apply_size_4), "asm_sc_apply_size_4");
    }
#line 272
    goto while_break___33;
  }
  while_break___33: /* CIL Label */ ;
  }
  {
#line 273
  while (1) {
    while_continue___34: /* CIL Label */ ;
    {
#line 273
    *((unsigned long *)(rsi_value + offset)) = (unsigned long )(& asm_sc_apply_size_5);
#line 273
    offset = (int )((unsigned long )offset + sizeof(SCHEME_OBJECT ));
#line 273
    declare_builtin((unsigned long )(& asm_sc_apply_size_5), "asm_sc_apply_size_5");
    }
#line 273
    goto while_break___34;
  }
  while_break___34: /* CIL Label */ ;
  }
  {
#line 274
  while (1) {
    while_continue___35: /* CIL Label */ ;
    {
#line 274
    *((unsigned long *)(rsi_value + offset)) = (unsigned long )(& asm_sc_apply_size_6);
#line 274
    offset = (int )((unsigned long )offset + sizeof(SCHEME_OBJECT ));
#line 274
    declare_builtin((unsigned long )(& asm_sc_apply_size_6), "asm_sc_apply_size_6");
    }
#line 274
    goto while_break___35;
  }
  while_break___35: /* CIL Label */ ;
  }
  {
#line 275
  while (1) {
    while_continue___36: /* CIL Label */ ;
    {
#line 275
    *((unsigned long *)(rsi_value + offset)) = (unsigned long )(& asm_sc_apply_size_7);
#line 275
    offset = (int )((unsigned long )offset + sizeof(SCHEME_OBJECT ));
#line 275
    declare_builtin((unsigned long )(& asm_sc_apply_size_7), "asm_sc_apply_size_7");
    }
#line 275
    goto while_break___36;
  }
  while_break___36: /* CIL Label */ ;
  }
  {
#line 276
  while (1) {
    while_continue___37: /* CIL Label */ ;
    {
#line 276
    *((unsigned long *)(rsi_value + offset)) = (unsigned long )(& asm_sc_apply_size_8);
#line 276
    offset = (int )((unsigned long )offset + sizeof(SCHEME_OBJECT ));
#line 276
    declare_builtin((unsigned long )(& asm_sc_apply_size_8), "asm_sc_apply_size_8");
    }
#line 276
    goto while_break___37;
  }
  while_break___37: /* CIL Label */ ;
  }
  {
#line 282
  while (1) {
    while_continue___38: /* CIL Label */ ;
    {
#line 282
    *((unsigned long *)(rsi_value + offset)) = (unsigned long )(& asm_interrupt_continuation_2);
#line 282
    offset = (int )((unsigned long )offset + sizeof(SCHEME_OBJECT ));
#line 282
    declare_builtin((unsigned long )(& asm_interrupt_continuation_2), "asm_interrupt_continuation_2");
    }
#line 282
    goto while_break___38;
  }
  while_break___38: /* CIL Label */ ;
  }
  {
#line 284
  while (1) {
    while_continue___39: /* CIL Label */ ;
    {
#line 284
    *((unsigned long *)(rsi_value + offset)) = (unsigned long )(& asm_fixnum_shift);
#line 284
    offset = (int )((unsigned long )offset + sizeof(SCHEME_OBJECT ));
#line 284
    declare_builtin((unsigned long )(& asm_fixnum_shift), "asm_fixnum_shift");
    }
#line 284
    goto while_break___39;
  }
  while_break___39: /* CIL Label */ ;
  }
#line 333
  return;
}
}
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 39 "/home/khheo/project/mit-scheme-9.2/src/microcode/dstack.h"
void *dstack_alloc(unsigned int length ) ;
#line 71
void transaction_begin(void) ;
#line 73
void transaction_commit(void) ;
#line 74
void transaction_record_action(enum transaction_action_type type , void (*procedure)(void *environment ) ,
                               void *environment ) ;
#line 92 "/home/khheo/project/mit-scheme-9.2/src/microcode/memmag.h"
 __attribute__((__noreturn__)) void stack_death(char const   *name ) ;
#line 155 "/home/khheo/project/mit-scheme-9.2/src/microcode/interp.h"
 __attribute__((__noreturn__)) void abort_to_interpreter(int argument ) ;
#line 159
long prim_apply_error_code ;
#line 40 "/home/khheo/project/mit-scheme-9.2/src/microcode/extern.h"
SCHEME_OBJECT Registers[352]  ;
#line 153
SCHEME_OBJECT *constant_start ;
#line 154
SCHEME_OBJECT *constant_end ;
#line 158
SCHEME_OBJECT *last_return_code ;
#line 159
SCHEME_OBJECT fixed_objects ;
#line 290
SCHEME_OBJECT make_vector(unsigned long length , SCHEME_OBJECT contents , _Bool gc_check_p ) ;
#line 321
SCHEME_OBJECT *copy_to_constant_space(SCHEME_OBJECT *source , unsigned long n_words ) ;
#line 354
 __attribute__((__noreturn__)) void termination_init_error(void) ;
#line 37 "/home/khheo/project/mit-scheme-9.2/src/microcode/prim.h"
primitive_procedure_t *Primitive_Procedure_Table ;
#line 38
int *Primitive_Arity_Table ;
#line 40
char const   **Primitive_Name_Table ;
#line 50
SCHEME_OBJECT Prim_unimplemented(void) ;
#line 116 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.h"
void make_compiled_procedure_type(cc_entry_type_t *cet , unsigned int n_required ,
                                  unsigned int n_optional , _Bool rest_p ) ;
#line 118
void make_compiled_continuation_type(cc_entry_type_t *cet , unsigned long offset ) ;
#line 119
void make_cc_entry_type(cc_entry_type_t *cet , cc_entry_type_marker_t marker ) ;
#line 171
SCHEME_OBJECT *cc_entry_address_to_block_address(insn_t *entry ) ;
#line 172
int plausible_cc_block_p(SCHEME_OBJECT *block ) ;
#line 216
linkage_section_type_t linkage_section_type(SCHEME_OBJECT marker ) ;
#line 217
unsigned long linkage_section_count(SCHEME_OBJECT marker ) ;
#line 218
SCHEME_OBJECT make_linkage_section_marker(linkage_section_type_t type , unsigned long count ) ;
#line 221
long make_uuo_link(SCHEME_OBJECT procedure , SCHEME_OBJECT cache , SCHEME_OBJECT block ,
                   unsigned long offset ) ;
#line 224
SCHEME_OBJECT read_uuo_link(SCHEME_OBJECT block , unsigned long offset ) ;
#line 232
void write_variable_cache(SCHEME_OBJECT cache , SCHEME_OBJECT block , unsigned long offset ) ;
#line 268
SCHEME_OBJECT *compiled_closure_objects(SCHEME_OBJECT *block ) ;
#line 293
_Bool cc_block_closure_p(SCHEME_OBJECT block ) ;
#line 337
SCHEME_OBJECT *trampoline_storage(SCHEME_OBJECT *block ) ;
#line 386
utility_proc_t *utility_table[62] ;
#line 396 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.h"
unsigned int compiler_interface_version  ;
#line 397 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.h"
cc_arch_t compiler_processor_type  ;
#line 398
unsigned long max_trampoline ;
#line 400 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.h"
SCHEME_OBJECT compiler_utilities  ;
#line 401 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.h"
SCHEME_OBJECT return_to_interpreter  ;
#line 402 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.h"
SCHEME_OBJECT reflect_to_interface  ;
#line 404
SCHEME_OBJECT cc_block_debugging_info(SCHEME_OBJECT block ) ;
#line 405
SCHEME_OBJECT cc_block_environment(SCHEME_OBJECT block ) ;
#line 406
SCHEME_OBJECT cc_block_linkage_info(SCHEME_OBJECT block ) ;
#line 408
long enter_compiled_expression(void) ;
#line 409
void guarantee_cc_return(unsigned long offset ) ;
#line 410
void guarantee_interp_return(void) ;
#line 411
long apply_compiled_procedure(void) ;
#line 412
long return_to_compiled_code(void) ;
#line 414
void apply_compiled_from_primitive(unsigned long n_args , SCHEME_OBJECT procedure ) ;
#line 415
void compiled_with_interrupt_mask(unsigned long old_mask , SCHEME_OBJECT receiver ,
                                  unsigned long new_mask ) ;
#line 417
void compiled_with_stack_marker(SCHEME_OBJECT thunk ) ;
#line 419
void compiler_initialize(_Bool fasl_p ) ;
#line 420
void compiler_reset(SCHEME_OBJECT new_block ) ;
#line 424
void compiler_interrupt_common(utility_result_t *DSU_result , insn_t *address___0 ,
                               SCHEME_OBJECT state ) ;
#line 427
long comp_link_caches_restart(void) ;
#line 428
long comp_op_lookup_trap_restart(void) ;
#line 429
long comp_interrupt_restart(void) ;
#line 430
long comp_assignment_trap_restart(void) ;
#line 431
long comp_cache_lookup_apply_restart(void) ;
#line 432
long comp_lookup_trap_restart(void) ;
#line 433
long comp_safe_lookup_trap_restart(void) ;
#line 434
long comp_unassigned_p_trap_restart(void) ;
#line 435
long comp_error_restart(void) ;
#line 441
long do_bkpt_proceed(insn_t **addr_r ) ;
#line 444
int pc_to_utility_index(unsigned long pc ) ;
#line 446
int pc_to_builtin_index(unsigned long pc ) ;
#line 450
void comutil_return_to_interpreter(utility_result_t *DSU_result , unsigned long TRAMP_store_raw ,
                                   unsigned long ignore2 , unsigned long ignore3 ,
                                   unsigned long ignore4 ) ;
#line 451
void comutil_operator_apply_trap(utility_result_t *DSU_result , unsigned long TRAMP_store_raw ,
                                 unsigned long ignore2 , unsigned long ignore3 , unsigned long ignore4 ) ;
#line 455
void comutil_operator_lexpr_trap(utility_result_t *DSU_result , unsigned long TRAMP_store_raw ,
                                 unsigned long ignore2 , unsigned long ignore3 , unsigned long ignore4 ) ;
#line 456
void comutil_operator_primitive_trap(utility_result_t *DSU_result , unsigned long TRAMP_store_raw ,
                                     unsigned long ignore2 , unsigned long ignore3 ,
                                     unsigned long ignore4 ) ;
#line 457
void comutil_operator_lookup_trap(utility_result_t *DSU_result , unsigned long TRAMP_store_raw ,
                                  unsigned long ignore2 , unsigned long ignore3 ,
                                  unsigned long ignore4 ) ;
#line 458
void comutil_operator_1_0_trap(utility_result_t *DSU_result , unsigned long TRAMP_store_raw ,
                               unsigned long ignore2 , unsigned long ignore3 , unsigned long ignore4 ) ;
#line 459
void comutil_operator_2_1_trap(utility_result_t *DSU_result , unsigned long TRAMP_store_raw ,
                               unsigned long ignore2 , unsigned long ignore3 , unsigned long ignore4 ) ;
#line 460
void comutil_operator_2_0_trap(utility_result_t *DSU_result , unsigned long TRAMP_store_raw ,
                               unsigned long ignore2 , unsigned long ignore3 , unsigned long ignore4 ) ;
#line 461
void comutil_operator_3_2_trap(utility_result_t *DSU_result , unsigned long TRAMP_store_raw ,
                               unsigned long ignore2 , unsigned long ignore3 , unsigned long ignore4 ) ;
#line 462
void comutil_operator_3_1_trap(utility_result_t *DSU_result , unsigned long TRAMP_store_raw ,
                               unsigned long ignore2 , unsigned long ignore3 , unsigned long ignore4 ) ;
#line 463
void comutil_operator_3_0_trap(utility_result_t *DSU_result , unsigned long TRAMP_store_raw ,
                               unsigned long ignore2 , unsigned long ignore3 , unsigned long ignore4 ) ;
#line 464
void comutil_operator_4_3_trap(utility_result_t *DSU_result , unsigned long TRAMP_store_raw ,
                               unsigned long ignore2 , unsigned long ignore3 , unsigned long ignore4 ) ;
#line 465
void comutil_operator_4_2_trap(utility_result_t *DSU_result , unsigned long TRAMP_store_raw ,
                               unsigned long ignore2 , unsigned long ignore3 , unsigned long ignore4 ) ;
#line 466
void comutil_operator_4_1_trap(utility_result_t *DSU_result , unsigned long TRAMP_store_raw ,
                               unsigned long ignore2 , unsigned long ignore3 , unsigned long ignore4 ) ;
#line 467
void comutil_operator_4_0_trap(utility_result_t *DSU_result , unsigned long TRAMP_store_raw ,
                               unsigned long ignore2 , unsigned long ignore3 , unsigned long ignore4 ) ;
#line 468
void comutil_primitive_apply(utility_result_t *DSU_result , unsigned long primitive_raw ,
                             unsigned long ignore2 , unsigned long ignore3 , unsigned long ignore4 ) ;
#line 469
void comutil_primitive_lexpr_apply(utility_result_t *DSU_result , unsigned long primitive_raw ,
                                   unsigned long ignore2 , unsigned long ignore3 ,
                                   unsigned long ignore4 ) ;
#line 470
void comutil_apply(utility_result_t *DSU_result , unsigned long procedure_raw , unsigned long frame_size_raw ,
                   unsigned long ignore3 , unsigned long ignore4 ) ;
#line 471
void comutil_error(utility_result_t *DSU_result , unsigned long frame_size_raw , unsigned long ignore2 ,
                   unsigned long ignore3 , unsigned long ignore4 ) ;
#line 472
void comutil_lexpr_apply(utility_result_t *DSU_result , unsigned long address_raw ,
                         unsigned long n_args_raw , unsigned long ignore3 , unsigned long ignore4 ) ;
#line 473
void comutil_link(utility_result_t *DSU_result , unsigned long return_addr_raw , unsigned long block_addr_raw ,
                  unsigned long constant_addr_raw , unsigned long n_sections_raw ) ;
#line 474
void comutil_interrupt_closure(utility_result_t *DSU_result , unsigned long ignore1 ,
                               unsigned long ignore2 , unsigned long ignore3 , unsigned long ignore4 ) ;
#line 475
void comutil_interrupt_dlink(utility_result_t *DSU_result , unsigned long entry_point_raw ,
                             unsigned long dlink_raw , unsigned long ignore3 , unsigned long ignore4 ) ;
#line 476
void comutil_interrupt_procedure(utility_result_t *DSU_result , unsigned long entry_point_raw ,
                                 unsigned long ignore2 , unsigned long ignore3 , unsigned long ignore4 ) ;
#line 477
void comutil_interrupt_continuation(utility_result_t *DSU_result , unsigned long return_addr_raw ,
                                    unsigned long ignore2 , unsigned long ignore3 ,
                                    unsigned long ignore4 ) ;
#line 478
void comutil_interrupt_ic_procedure(utility_result_t *DSU_result , unsigned long entry_point_raw ,
                                    unsigned long ignore2 , unsigned long ignore3 ,
                                    unsigned long ignore4 ) ;
#line 479
void comutil_assignment_trap(utility_result_t *DSU_result , unsigned long ret_addr_raw ,
                             unsigned long cache_addr_raw , unsigned long new_val_raw ,
                             unsigned long ignore4 ) ;
#line 480
void comutil_cache_lookup_apply(utility_result_t *DSU_result , unsigned long cache_addr_raw ,
                                unsigned long block_addr_raw , unsigned long frame_size_raw ,
                                unsigned long ignore4 ) ;
#line 481
void comutil_lookup_trap(utility_result_t *DSU_result , unsigned long ret_addr_raw ,
                         unsigned long cache_addr_raw , unsigned long ignore3 , unsigned long ignore4 ) ;
#line 482
void comutil_safe_lookup_trap(utility_result_t *DSU_result , unsigned long ret_addr_raw ,
                              unsigned long cache_addr_raw , unsigned long ignore3 ,
                              unsigned long ignore4 ) ;
#line 483
void comutil_unassigned_p_trap(utility_result_t *DSU_result , unsigned long ret_addr_raw ,
                               unsigned long cache_addr_raw , unsigned long ignore3 ,
                               unsigned long ignore4 ) ;
#line 484
void comutil_decrement(utility_result_t *DSU_result , unsigned long ignore1 , unsigned long ignore2 ,
                       unsigned long ignore3 , unsigned long ignore4 ) ;
#line 485
void comutil_divide(utility_result_t *DSU_result , unsigned long ignore1 , unsigned long ignore2 ,
                    unsigned long ignore3 , unsigned long ignore4 ) ;
#line 486
void comutil_equal(utility_result_t *DSU_result , unsigned long ignore1 , unsigned long ignore2 ,
                   unsigned long ignore3 , unsigned long ignore4 ) ;
#line 487
void comutil_greater(utility_result_t *DSU_result , unsigned long ignore1 , unsigned long ignore2 ,
                     unsigned long ignore3 , unsigned long ignore4 ) ;
#line 488
void comutil_increment(utility_result_t *DSU_result , unsigned long ignore1 , unsigned long ignore2 ,
                       unsigned long ignore3 , unsigned long ignore4 ) ;
#line 489
void comutil_less(utility_result_t *DSU_result , unsigned long ignore1 , unsigned long ignore2 ,
                  unsigned long ignore3 , unsigned long ignore4 ) ;
#line 490
void comutil_minus(utility_result_t *DSU_result , unsigned long ignore1 , unsigned long ignore2 ,
                   unsigned long ignore3 , unsigned long ignore4 ) ;
#line 491
void comutil_multiply(utility_result_t *DSU_result , unsigned long ignore1 , unsigned long ignore2 ,
                      unsigned long ignore3 , unsigned long ignore4 ) ;
#line 492
void comutil_negative(utility_result_t *DSU_result , unsigned long ignore1 , unsigned long ignore2 ,
                      unsigned long ignore3 , unsigned long ignore4 ) ;
#line 493
void comutil_plus(utility_result_t *DSU_result , unsigned long ignore1 , unsigned long ignore2 ,
                  unsigned long ignore3 , unsigned long ignore4 ) ;
#line 494
void comutil_positive(utility_result_t *DSU_result , unsigned long ignore1 , unsigned long ignore2 ,
                      unsigned long ignore3 , unsigned long ignore4 ) ;
#line 495
void comutil_zero(utility_result_t *DSU_result , unsigned long ignore1 , unsigned long ignore2 ,
                  unsigned long ignore3 , unsigned long ignore4 ) ;
#line 496
void comutil_primitive_error(utility_result_t *DSU_result , unsigned long ret_addr_raw ,
                             unsigned long primitive_raw , unsigned long ignore3 ,
                             unsigned long ignore4 ) ;
#line 497
void comutil_quotient(utility_result_t *DSU_result , unsigned long ignore1 , unsigned long ignore2 ,
                      unsigned long ignore3 , unsigned long ignore4 ) ;
#line 498
void comutil_remainder(utility_result_t *DSU_result , unsigned long ignore1 , unsigned long ignore2 ,
                       unsigned long ignore3 , unsigned long ignore4 ) ;
#line 499
void comutil_modulo(utility_result_t *DSU_result , unsigned long ignore1 , unsigned long ignore2 ,
                    unsigned long ignore3 , unsigned long ignore4 ) ;
#line 500
void comutil_reflect_to_interface(utility_result_t *DSU_result , unsigned long TRAMP_store_raw ,
                                  unsigned long ignore2 , unsigned long ignore3 ,
                                  unsigned long ignore4 ) ;
#line 501
void comutil_interrupt_continuation_2(utility_result_t *DSU_result , unsigned long ignore1 ,
                                      unsigned long ignore2 , unsigned long ignore3 ,
                                      unsigned long ignore4 ) ;
#line 502
void comutil_compiled_code_bkpt(utility_result_t *DSU_result , unsigned long entry_addr_raw ,
                                unsigned long state_raw , unsigned long ignore3 ,
                                unsigned long ignore4 ) ;
#line 503
void comutil_compiled_closure_bkpt(utility_result_t *DSU_result , unsigned long entry_addr_raw ,
                                   unsigned long ignore2 , unsigned long ignore3 ,
                                   unsigned long ignore4 ) ;
#line 94 "/home/khheo/project/mit-scheme-9.2/src/microcode/prims.h"
 __attribute__((__noreturn__)) void error_external_return(void) ;
#line 34 "/home/khheo/project/mit-scheme-9.2/src/microcode/lookup.h"
long lookup_variable(SCHEME_OBJECT environment , SCHEME_OBJECT symbol , SCHEME_OBJECT *value_ret ) ;
#line 36
long safe_lookup_variable(SCHEME_OBJECT environment , SCHEME_OBJECT symbol , SCHEME_OBJECT *value_ret ) ;
#line 38
long variable_unassigned_p(SCHEME_OBJECT environment , SCHEME_OBJECT symbol , SCHEME_OBJECT *value_ret ) ;
#line 44
long assign_variable(SCHEME_OBJECT environment , SCHEME_OBJECT symbol , SCHEME_OBJECT value ,
                     SCHEME_OBJECT *value_ret ) ;
#line 55
long compiler_cache_lookup(SCHEME_OBJECT name , SCHEME_OBJECT block , unsigned long offset ) ;
#line 57
long compiler_cache_assignment(SCHEME_OBJECT name , SCHEME_OBJECT block , unsigned long offset ) ;
#line 59
long compiler_cache_operator(SCHEME_OBJECT name , SCHEME_OBJECT block , unsigned long offset ) ;
#line 61
long compiler_cache_global_operator(SCHEME_OBJECT name , SCHEME_OBJECT block , unsigned long offset ) ;
#line 64
SCHEME_OBJECT compiler_var_error(SCHEME_OBJECT cache , SCHEME_OBJECT block , unsigned int reference_kind ) ;
#line 67
long compiler_lookup_trap(SCHEME_OBJECT cache , SCHEME_OBJECT *value_ret ) ;
#line 69
long compiler_operator_reference_trap(SCHEME_OBJECT cache , SCHEME_OBJECT *value_ret ) ;
#line 71
long compiler_safe_lookup_trap(SCHEME_OBJECT cache , SCHEME_OBJECT *value_ret ) ;
#line 73
long compiler_unassigned_p_trap(SCHEME_OBJECT cache , SCHEME_OBJECT *value_ret ) ;
#line 75
long compiler_assignment_trap(SCHEME_OBJECT cache , SCHEME_OBJECT value , SCHEME_OBJECT *value_ret ) ;
#line 89 "/home/khheo/project/mit-scheme-9.2/src/microcode/history.h"
void end_subproblem(void) ;
#line 90
void compiler_new_subproblem(void) ;
#line 91
void compiler_new_reduction(void) ;
#line 87 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
static trampoline_type_t trampoline_arity_table[16]  = 
#line 87 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
  {      (trampoline_type_t )8,      (trampoline_type_t )1,      (trampoline_type_t )1,      (trampoline_type_t )1, 
        (trampoline_type_t )10,      (trampoline_type_t )9,      (trampoline_type_t )1,      (trampoline_type_t )1, 
        (trampoline_type_t )13,      (trampoline_type_t )12,      (trampoline_type_t )11,      (trampoline_type_t )1, 
        (trampoline_type_t )17,      (trampoline_type_t )16,      (trampoline_type_t )15,      (trampoline_type_t )14};
#line 115 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
static _Bool linking_cc_block_p  =    (_Bool)0;
#line 117
static SCHEME_OBJECT make_compiler_utilities(void) ;
#line 118
static void open_stack_gap(unsigned long offset , unsigned long n_words ) ;
#line 119
static void close_stack_gap(unsigned long offset , unsigned long n_words ) ;
#line 120
static void recover_from_apply_error(SCHEME_OBJECT procedure , unsigned long n_args ) ;
#line 121
static long link_remaining_sections(link_cc_state_t *s ) ;
#line 122
static void start_linking_cc_block(void) ;
#line 123
static void end_linking_cc_block(link_cc_state_t *s ) ;
#line 124
static void abort_linking_cc_block(void *ap ) ;
#line 125
static void update_cache_after_link(link_cc_state_t *s ) ;
#line 126
static void start_linking_section(link_cc_state_t *s ) ;
#line 127
static long link_section(link_cc_state_t *s ) ;
#line 128
static _Bool link_section_handler(linkage_section_type_t type , cache_handler_t **handler_r ,
                                  _Bool *execute_p_r ) ;
#line 130
static void back_out_of_link_section(link_cc_state_t *s ) ;
#line 131
static void restore_link_cc_state(link_cc_state_t *s ) ;
#line 132
static void count_linkage_sections(SCHEME_OBJECT *const_addr , SCHEME_OBJECT *block_end ,
                                   unsigned long *n_sections , unsigned long *n_words ) ;
#line 134
static SCHEME_OBJECT read_linkage_sections(SCHEME_OBJECT *const_addr , SCHEME_OBJECT *block_end ,
                                           unsigned long n_sections , unsigned long n_words ) ;
#line 136
static _Bool section_execute_p(SCHEME_OBJECT h ) ;
#line 137
static void setup_compiled_invocation_from_primitive(SCHEME_OBJECT procedure , unsigned long n_args ) ;
#line 139
static long setup_compiled_invocation(SCHEME_OBJECT procedure , unsigned long n_args ) ;
#line 140
static long setup_lexpr_invocation(SCHEME_OBJECT procedure , unsigned long n_args ,
                                   unsigned long n_max ) ;
#line 142
static _Bool open_gap(unsigned long n_args , unsigned long n_needed ) ;
#line 143
static _Bool unlinked_section_start_p(SCHEME_OBJECT *mp , SCHEME_OBJECT *end ) ;
#line 144
static _Bool cc_block_address_closure_p(SCHEME_OBJECT *block_addr ) ;
#line 145
static void write_uuo_link(SCHEME_OBJECT target , SCHEME_OBJECT *cache_address ) ;
#line 146
static long make_fake_uuo_link(SCHEME_OBJECT cache , SCHEME_OBJECT block , unsigned long offset ) ;
#line 147
static long make_trampoline(SCHEME_OBJECT *slot , cc_entry_type_t *cet , trampoline_type_t kind ,
                            unsigned int n_values  , ...) ;
#line 149
static void make_trampoline_headers(unsigned long n_entries , unsigned long n_store ,
                                    SCHEME_OBJECT *h1_r , SCHEME_OBJECT *h2_r , unsigned long *n_words_r ) ;
#line 152
static _Bool fill_trampoline(SCHEME_OBJECT *block , unsigned long index___0 , cc_entry_type_t *cet ,
                             trampoline_type_t kind ) ;
#line 154
static long make_redirection_trampoline(SCHEME_OBJECT *slot , trampoline_type_t kind ,
                                        SCHEME_OBJECT procedure ) ;
#line 156
static long make_apply_trampoline(SCHEME_OBJECT *slot , trampoline_type_t kind , SCHEME_OBJECT procedure ,
                                  unsigned long frame_size ) ;
#line 192
extern c_func_t interface_to_C ;
#line 193
extern c_func_t interface_to_scheme ;
#line 196
extern long C_to_interface(insn_t * ) ;
#line 290 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
void compiler_initialize(_Bool fasl_p ) 
{ 
  SCHEME_OBJECT tmp ;

  {
#line 294
  Registers[8] = 0UL;
#line 295
  compiler_processor_type = (cc_arch_t )14;
#line 296
  compiler_interface_version = 3U;
#line 297
  if (fasl_p) {
    {
#line 298
    tmp = make_compiler_utilities();
#line 298
    compiler_reset(tmp);
    }
  } else {
#line 302
    compiler_utilities = 0UL;
#line 303
    return_to_interpreter = 0UL;
  }
#line 308
  return;
}
}
#line 313 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
static SCHEME_OBJECT make_compiler_utilities(void) 
{ 
  SCHEME_OBJECT h1 ;
  SCHEME_OBJECT h2 ;
  unsigned long n_words ;
  SCHEME_OBJECT *block ;
  cc_entry_type_t cet ;
  _Bool tmp ;
  _Bool tmp___0 ;
  SCHEME_OBJECT *store ;
  SCHEME_OBJECT *tmp___1 ;
  insn_t *tmp___2 ;
  insn_t *tmp___3 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 321
  make_trampoline_headers(2UL, 2UL, & h1, & h2, & n_words);
  }
#line 322
  if ((unsigned long )Free >= (unsigned long )heap_start) {
#line 322
    if ((unsigned long )Free < (unsigned long )heap_alloc_limit) {
#line 322
      if (! ((unsigned long )(Free + n_words) <= (unsigned long )heap_alloc_limit)) {
#line 322
        goto _L___0;
      }
    } else {
#line 322
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 322
  if ((Registers[1] & 4UL) != 0UL) {
    {
#line 324
    outf_fatal("Can\'t allocate compiler_utilities.\n");
#line 325
    Microcode_Termination(21);
    }
  }
  {
#line 327
  h1 &= 288230376151711743UL;
#line 329
  block = Free;
#line 330
  Free += n_words;
#line 331
  *(block + 0) = h1;
#line 332
  *(block + 1) = h2;
#line 336
  make_cc_entry_type(& cet, (cc_entry_type_marker_t )6);
#line 337
  tmp = fill_trampoline(block, 0UL, & cet, (trampoline_type_t )0);
  }
#line 337
  if (tmp) {
    {
#line 341
    outf_fatal("\nError in make_compiler_utilities\n");
#line 342
    Microcode_Termination(19);
    }
  } else {
    {
#line 337
    tmp___0 = fill_trampoline(block, 1UL, & cet, (trampoline_type_t )58);
    }
#line 337
    if (tmp___0) {
      {
#line 341
      outf_fatal("\nError in make_compiler_utilities\n");
#line 342
      Microcode_Termination(19);
      }
    }
  }
  {
#line 350
  tmp___1 = trampoline_storage(block);
#line 350
  store = tmp___1;
#line 351
  tmp___2 = trampoline_entry_addr(block, 0UL);
#line 351
  *(store + 0) = (SCHEME_OBJECT )(tmp___2 - (insn_t *)block);
#line 352
  tmp___3 = trampoline_entry_addr(block, 1UL);
#line 352
  *(store + 1) = (SCHEME_OBJECT )(tmp___3 - (insn_t *)block);
#line 355
  block = copy_to_constant_space(block, n_words);
  }
#line 356
  return ((61UL << 58U) | (SCHEME_OBJECT )block);
}
}
#line 359 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
void compiler_reset(SCHEME_OBJECT new_block ) 
{ 
  SCHEME_OBJECT h1 ;
  SCHEME_OBJECT h2 ;
  unsigned long n_words ;
  SCHEME_OBJECT *nbp ;
  insn_t *tmp ;
  insn_t *tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 368
  make_trampoline_headers(2UL, 2UL, & h1, & h2, & n_words);
#line 369
  h1 &= 288230376151711743UL;
  }
#line 370
  if (new_block >> 58U == 61UL) {
#line 370
    if (*((SCHEME_OBJECT *)(new_block & 288230376151711743UL) + 0) == h1) {
#line 370
      if (! (*((SCHEME_OBJECT *)(new_block & 288230376151711743UL) + 1) == h2)) {
        {
#line 374
        outf_fatal("\nThe world image being restored is incompatible with this microcode.\n");
#line 376
        Microcode_Termination(19);
        }
      }
    } else {
      {
#line 374
      outf_fatal("\nThe world image being restored is incompatible with this microcode.\n");
#line 376
      Microcode_Termination(19);
      }
    }
  } else {
    {
#line 374
    outf_fatal("\nThe world image being restored is incompatible with this microcode.\n");
#line 376
    Microcode_Termination(19);
    }
  }
  {
#line 380
  nbp = (SCHEME_OBJECT *)(new_block & 288230376151711743UL);
#line 381
  compiler_utilities = new_block;
#line 382
  tmp = trampoline_entry_addr(nbp, 0UL);
#line 382
  return_to_interpreter = (40UL << 58U) | (SCHEME_OBJECT )((SCHEME_OBJECT *)tmp);
#line 383
  tmp___0 = trampoline_entry_addr(nbp, 1UL);
#line 383
  reflect_to_interface = (40UL << 58U) | (SCHEME_OBJECT )((SCHEME_OBJECT *)tmp___0);
#line 384
  set_ptr_register(9U, (SCHEME_OBJECT *)0);
#line 385
  set_ptr_register(10U, (SCHEME_OBJECT *)0);
#line 386
  Registers[13] = reflect_to_interface;
#line 388
  x86_64_reset_hook();
  }
#line 389
  return;
}
}
#line 395 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
long enter_compiled_expression(void) 
{ 
  SCHEME_OBJECT entry ;
  cc_entry_type_t cet ;
  _Bool tmp ;
  long tmp___0 ;

  {
  {
#line 397
  entry = Registers[5];
#line 400
  tmp = read_cc_entry_type(& cet, (insn_t *)((SCHEME_OBJECT *)(entry & 288230376151711743UL)));
  }
#line 400
  if (tmp) {
#line 401
    return (49L);
  }
#line 402
  if ((unsigned int )cet.marker != 2U) {
#line 405
    Registers[2] = entry;
#line 406
    return (-1L);
  }
  {
#line 409
  guarantee_cc_return(0UL);
#line 410
  tmp___0 = C_to_interface((insn_t *)((SCHEME_OBJECT *)(entry & 288230376151711743UL)));
  }
#line 410
  return (tmp___0);
}
}
#line 413 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
long apply_compiled_procedure(void) 
{ 
  unsigned long n_args ;
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT procedure ;
  SCHEME_OBJECT *tmp___0 ;
  long code ;
  long tmp___1 ;
  long tmp___2 ;

  {
  {
#line 415
  tmp = stack_pointer;
#line 415
  stack_pointer ++;
#line 415
  n_args = (*tmp & 288230376151711743UL) - 1UL;
#line 416
  tmp___0 = stack_pointer;
#line 416
  stack_pointer ++;
#line 416
  procedure = *tmp___0;
#line 417
  tmp___1 = setup_compiled_invocation(procedure, n_args);
#line 417
  code = tmp___1;
  }
#line 418
  if (code != -1L) {
#line 419
    return (code);
  }
  {
#line 420
  tmp___2 = C_to_interface((insn_t *)((SCHEME_OBJECT *)(procedure & 288230376151711743UL)));
  }
#line 420
  return (tmp___2);
}
}
#line 423 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
long return_to_compiled_code(void) 
{ 
  SCHEME_OBJECT cont ;
  SCHEME_OBJECT *tmp ;
  cc_entry_type_t cet ;
  _Bool tmp___0 ;
  long tmp___1 ;

  {
  {
#line 425
  while (1) {
    while_continue: /* CIL Label */ ;
#line 425
    last_return_code = stack_pointer + (Registers[5] & 288230376151711743UL);
    {
#line 425
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 425
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 425
    end_subproblem();
    }
#line 425
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 427
  tmp = stack_pointer;
#line 427
  stack_pointer ++;
#line 427
  cont = *tmp;
#line 430
  tmp___0 = read_cc_entry_type(& cet, (insn_t *)((SCHEME_OBJECT *)(cont & 288230376151711743UL)));
  }
#line 430
  if (tmp___0) {
#line 430
    goto _L;
  } else
#line 430
  if (! ((unsigned int )cet.marker == 1U)) {
#line 430
    if (! ((unsigned int )cet.marker == 4U)) {
#line 430
      if (! ((unsigned int )cet.marker == 6U)) {
        _L: /* CIL Label */ 
#line 435
        stack_pointer --;
#line 435
        *stack_pointer = cont;
        {
#line 436
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 436
          stack_pointer --;
#line 436
          *stack_pointer = Registers[5];
#line 436
          stack_pointer --;
#line 436
          *stack_pointer = Registers[6];
#line 436
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 437
        return (3L);
      }
    }
  }
  {
#line 440
  tmp___1 = C_to_interface((insn_t *)((SCHEME_OBJECT *)(cont & 288230376151711743UL)));
  }
#line 440
  return (tmp___1);
}
}
#line 444 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
void guarantee_cc_return(unsigned long offset ) 
{ 
  unsigned long lrc ;

  {
#line 447
  if (*(stack_pointer + offset) >> 58U == 40UL) {
#line 448
    return;
  }
#line 450
  if (*(stack_pointer + offset) == ((11UL << 58U) | 29UL)) {
    {
#line 452
    lrc = *(stack_pointer + (offset + 1UL)) & 288230376151711743UL;
#line 453
    close_stack_gap(offset, 2UL);
#line 454
    last_return_code = stack_pointer + (offset + lrc);
    }
    {
#line 455
    while (1) {
      while_continue: /* CIL Label */ ;
#line 455
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 456
    end_subproblem();
    }
  } else {
#line 460
    last_return_code = stack_pointer + offset;
    {
#line 461
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 461
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 462
    open_stack_gap(offset, 1UL);
#line 463
    *(stack_pointer + offset) = return_to_interpreter;
    }
  }
#line 465
  return;
}
}
#line 467 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
void guarantee_interp_return(void) 
{ 
  unsigned long offset ;
  SCHEME_OBJECT *sp ;
  long SLRC_offset ;

  {
#line 470
  offset = 1UL + (*(stack_pointer + 0) & 288230376151711743UL);
#line 471
  if (*(stack_pointer + offset) >> 58U == 11UL) {
#line 472
    return;
  }
#line 474
  if (*(stack_pointer + offset) == return_to_interpreter) {
    {
#line 477
    close_stack_gap(offset, 1UL);
#line 478
    compiler_new_reduction();
    }
  } else {
    {
#line 482
    open_stack_gap(offset, 2UL);
#line 484
    sp = stack_pointer;
#line 485
    stack_pointer += offset + 2UL;
    }
    {
#line 486
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 486
      SLRC_offset = last_return_code - stack_pointer;
#line 486
      stack_pointer --;
#line 486
      *stack_pointer = (26UL << 58U) | ((unsigned long )SLRC_offset & 288230376151711743UL);
#line 486
      stack_pointer --;
#line 486
      *stack_pointer = (11UL << 58U) | 29UL;
#line 486
      compiler_new_subproblem();
      }
#line 486
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 487
    stack_pointer = sp;
  }
#line 490
  return;
}
}
#line 492 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
static void open_stack_gap(unsigned long offset , unsigned long n_words ) 
{ 
  SCHEME_OBJECT *scan_from ;
  SCHEME_OBJECT *scan_end ;
  SCHEME_OBJECT *scan_to ;
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT *tmp___0 ;

  {
#line 495
  scan_from = stack_pointer + 0;
#line 496
  scan_end = stack_pointer + offset;
#line 497
  scan_to = stack_pointer + - n_words;
  {
#line 498
  while (1) {
    while_continue: /* CIL Label */ ;
#line 498
    if (! ((unsigned long )scan_from != (unsigned long )scan_end)) {
#line 498
      goto while_break;
    }
#line 499
    tmp = scan_to;
#line 499
    scan_to ++;
#line 499
    tmp___0 = scan_from;
#line 499
    scan_from ++;
#line 499
    *tmp = *tmp___0;
  }
  while_break: /* CIL Label */ ;
  }
#line 500
  stack_pointer += - n_words;
#line 501
  return;
}
}
#line 503 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
static void close_stack_gap(unsigned long offset , unsigned long n_words ) 
{ 
  SCHEME_OBJECT *scan_from ;
  SCHEME_OBJECT *scan_end ;
  SCHEME_OBJECT *scan_to ;

  {
#line 506
  scan_from = stack_pointer + offset;
#line 507
  scan_end = stack_pointer + 0;
#line 508
  scan_to = stack_pointer + (offset + n_words);
  {
#line 509
  while (1) {
    while_continue: /* CIL Label */ ;
#line 509
    if (! ((unsigned long )scan_from != (unsigned long )scan_end)) {
#line 509
      goto while_break;
    }
#line 510
    scan_to --;
#line 510
    scan_from --;
#line 510
    *scan_to = *scan_from;
  }
  while_break: /* CIL Label */ ;
  }
#line 511
  stack_pointer += n_words;
#line 512
  return;
}
}
#line 514 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
static void recover_from_apply_error(SCHEME_OBJECT procedure , unsigned long n_args ) 
{ 


  {
  {
#line 517
  stack_pointer --;
#line 517
  *stack_pointer = procedure;
#line 518
  stack_pointer --;
#line 518
  *stack_pointer = n_args + 1UL;
#line 519
  guarantee_interp_return();
  }
#line 520
  return;
}
}
#line 601 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
void comutil_apply(utility_result_t *DSU_result , unsigned long procedure_raw , unsigned long frame_size_raw ,
                   unsigned long ignore3 , unsigned long ignore4 ) 
{ 
  SCHEME_OBJECT procedure ;
  unsigned long frame_size ;
  SCHEME_OBJECT data ;
  SCHEME_OBJECT operator ;
  long code ;
  long tmp ;
  int arity ;

  {
#line 603
  procedure = procedure_raw;
#line 604
  frame_size = frame_size_raw;
  {
#line 606
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 609
    if (procedure >> 58U == 16UL) {
#line 609
      goto case_16;
    }
#line 632
    if (procedure >> 58U == 40UL) {
#line 632
      goto case_40;
    }
#line 641
    if (procedure >> 58U == 24UL) {
#line 641
      goto case_24;
    }
#line 661
    goto handle_in_interpreter;
    case_16: /* CIL Label */ 
#line 611
    data = *((SCHEME_OBJECT *)(procedure & 288230376151711743UL) + 1);
#line 612
    if (data >> 58U == 10UL) {
#line 612
      if ((*((SCHEME_OBJECT *)(data & 288230376151711743UL) + 0) & 288230376151711743UL) > frame_size) {
#line 612
        if (*((SCHEME_OBJECT *)(data & 288230376151711743UL) + 1) == *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 52)) {
#line 612
          if (*((SCHEME_OBJECT *)(data & 288230376151711743UL) + (frame_size + 1UL)) != 0UL) {
#line 618
            procedure = *((SCHEME_OBJECT *)(data & 288230376151711743UL) + (frame_size + 1UL));
#line 619
            goto switch_break;
          }
        }
      }
    }
#line 623
    operator = *((SCHEME_OBJECT *)(procedure & 288230376151711743UL) + 0);
#line 624
    if (! (operator >> 58U == 40UL)) {
#line 625
      goto handle_in_interpreter;
    }
#line 626
    stack_pointer --;
#line 626
    *stack_pointer = procedure;
#line 627
    procedure = operator;
#line 628
    frame_size ++;
    case_40: /* CIL Label */ 
    {
#line 634
    tmp = setup_compiled_invocation(procedure, frame_size - 1UL);
#line 634
    code = tmp;
    }
#line 636
    if (code != -1L) {
      {
#line 637
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 637
        DSU_result->interface_dispatch = (void *)(& interface_to_C);
#line 637
        DSU_result->extra.code_to_interpreter = code;
#line 637
        return;
#line 637
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 639
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 639
      DSU_result->interface_dispatch = (void *)(& interface_to_scheme);
#line 639
      DSU_result->extra.entry_point = (insn_t *)((SCHEME_OBJECT *)(procedure & 288230376151711743UL));
#line 639
      return;
#line 639
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    case_24: /* CIL Label */ 
#line 642
    if ((unsigned long )*(Primitive_Procedure_Table + (procedure & 288230376151711743UL)) != (unsigned long )(& Prim_unimplemented)) {
#line 644
      arity = *(Primitive_Arity_Table + (procedure & 288230376151711743UL));
#line 645
      if ((unsigned long )arity == frame_size - 1UL) {
        {
#line 646
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
#line 646
          comutil_primitive_apply(DSU_result, procedure, 0UL, 0UL, 0UL);
          }
#line 646
          return;
#line 646
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
      } else
#line 647
      if (arity == -1) {
        {
#line 649
        set_ulong_register(7U, frame_size - 1UL);
        }
        {
#line 650
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 650
          comutil_primitive_lexpr_apply(DSU_result, procedure, 0UL, 0UL, 0UL);
          }
#line 650
          return;
#line 650
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
      } else {
        {
#line 654
        recover_from_apply_error(procedure, frame_size - 1UL);
        }
        {
#line 655
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 655
          DSU_result->interface_dispatch = (void *)(& interface_to_C);
#line 655
          DSU_result->extra.code_to_interpreter = 12L;
#line 655
          return;
#line 655
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
    }
    handle_in_interpreter: 
    switch_default: /* CIL Label */ 
    {
#line 663
    recover_from_apply_error(procedure, frame_size - 1UL);
    }
    {
#line 664
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 664
      DSU_result->interface_dispatch = (void *)(& interface_to_C);
#line 664
      DSU_result->extra.code_to_interpreter = -3L;
#line 664
      return;
#line 664
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 674 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
void comutil_lexpr_apply(utility_result_t *DSU_result , unsigned long address_raw ,
                         unsigned long n_args_raw , unsigned long ignore3 , unsigned long ignore4 ) 
{ 
  insn_t *address___0 ;
  unsigned long n_args ;
  cc_entry_type_t cet ;
  _Bool tmp ;
  long code ;
  long tmp___0 ;

  {
  {
#line 676
  address___0 = (insn_t *)address_raw;
#line 677
  n_args = n_args_raw;
#line 680
  tmp = read_cc_entry_type(& cet, address___0);
  }
#line 680
  if (tmp) {
    _L___1: /* CIL Label */ 
    {
#line 685
    recover_from_apply_error((40UL << 58U) | (SCHEME_OBJECT )((SCHEME_OBJECT *)address___0),
                             n_args);
    }
    {
#line 686
    while (1) {
      while_continue: /* CIL Label */ ;
#line 686
      DSU_result->interface_dispatch = (void *)(& interface_to_C);
#line 686
      DSU_result->extra.code_to_interpreter = 49L;
#line 686
      return;
#line 686
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 680
  if ((unsigned int )cet.marker == 0U) {
#line 680
    if (cet.args.for_procedure.rest_p) {
#line 680
      if (! (n_args >= (unsigned long )cet.args.for_procedure.n_required)) {
#line 680
        goto _L___1;
      }
    } else {
#line 680
      goto _L___1;
    }
  } else {
#line 680
    goto _L___1;
  }
  {
#line 689
  tmp___0 = setup_lexpr_invocation((40UL << 58U) | (SCHEME_OBJECT )((SCHEME_OBJECT *)address___0),
                                   n_args, (unsigned long )(cet.args.for_procedure.n_required + cet.args.for_procedure.n_optional));
#line 689
  code = tmp___0;
  }
#line 694
  if (code != -1L) {
    {
#line 695
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 695
      DSU_result->interface_dispatch = (void *)(& interface_to_C);
#line 695
      DSU_result->extra.code_to_interpreter = code;
#line 695
      return;
#line 695
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 697
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 697
    DSU_result->interface_dispatch = (void *)(& interface_to_scheme);
#line 697
    DSU_result->extra.entry_point = address___0;
#line 697
    return;
#line 697
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 698
  return;
}
}
#line 708 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
void comutil_primitive_apply(utility_result_t *DSU_result , unsigned long primitive_raw ,
                             unsigned long ignore2 , unsigned long ignore3 , unsigned long ignore4 ) 
{ 
  SCHEME_OBJECT primitive ;
  void *PRIMITIVE_APPLY_INTERNAL_position ;
  SCHEME_OBJECT *tmp ;
  char *__cil_tmp9 ;

  {
#line 710
  primitive = primitive_raw;
  {
#line 711
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 711
    PRIMITIVE_APPLY_INTERNAL_position = dstack_position;
#line 711
    Registers[8] = primitive;
#line 711
    Free_primitive = Free;
#line 711
    Registers[2] = (*(*(Primitive_Procedure_Table + (primitive & 288230376151711743UL))))();
    }
#line 711
    if ((unsigned long )PRIMITIVE_APPLY_INTERNAL_position != (unsigned long )dstack_position) {
      {
#line 711
      outf_fatal("\nPrimitive slipped the dynamic stack: %s\n", *(Primitive_Name_Table + (primitive & 288230376151711743UL)));
#line 711
      Microcode_Termination(12);
      }
    }
#line 711
    Free_primitive = (SCHEME_OBJECT *)0;
#line 711
    Registers[8] = 0UL;
#line 711
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 712
  stack_pointer += *(Primitive_Arity_Table + (primitive & 288230376151711743UL));
  {
#line 713
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 713
    if ((unsigned long )Free >= (unsigned long )((SCHEME_OBJECT *)Registers[0])) {
      {
#line 713
      compiler_interrupt_common(DSU_result, (insn_t *)0, Registers[2]);
      }
#line 713
      return;
    }
    {
#line 713
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 713
      DSU_result->interface_dispatch = (void *)(& interface_to_scheme);
#line 713
      tmp = stack_pointer;
#line 713
      stack_pointer ++;
#line 713
      DSU_result->extra.entry_point = (insn_t *)((SCHEME_OBJECT *)(*tmp & 288230376151711743UL));
#line 713
      return;
#line 713
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 713
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 714
  return;
}
}
#line 721 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
void comutil_primitive_lexpr_apply(utility_result_t *DSU_result , unsigned long primitive_raw ,
                                   unsigned long ignore2 , unsigned long ignore3 ,
                                   unsigned long ignore4 ) 
{ 
  SCHEME_OBJECT primitive ;
  void *PRIMITIVE_APPLY_INTERNAL_position ;
  SCHEME_OBJECT *tmp ;
  char *__cil_tmp9 ;

  {
#line 723
  primitive = primitive_raw;
  {
#line 724
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 724
    PRIMITIVE_APPLY_INTERNAL_position = dstack_position;
#line 724
    Registers[8] = primitive;
#line 724
    Free_primitive = Free;
#line 724
    Registers[2] = (*(*(Primitive_Procedure_Table + (primitive & 288230376151711743UL))))();
    }
#line 724
    if ((unsigned long )PRIMITIVE_APPLY_INTERNAL_position != (unsigned long )dstack_position) {
      {
#line 724
      outf_fatal("\nPrimitive slipped the dynamic stack: %s\n", *(Primitive_Name_Table + (primitive & 288230376151711743UL)));
#line 724
      Microcode_Termination(12);
      }
    }
#line 724
    Free_primitive = (SCHEME_OBJECT *)0;
#line 724
    Registers[8] = 0UL;
#line 724
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 725
  stack_pointer += Registers[7];
  {
#line 726
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 726
    if ((unsigned long )Free >= (unsigned long )((SCHEME_OBJECT *)Registers[0])) {
      {
#line 726
      compiler_interrupt_common(DSU_result, (insn_t *)0, Registers[2]);
      }
#line 726
      return;
    }
    {
#line 726
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 726
      DSU_result->interface_dispatch = (void *)(& interface_to_scheme);
#line 726
      tmp = stack_pointer;
#line 726
      stack_pointer ++;
#line 726
      DSU_result->extra.entry_point = (insn_t *)((SCHEME_OBJECT *)(*tmp & 288230376151711743UL));
#line 726
      return;
#line 726
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 726
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 727
  return;
}
}
#line 733 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
void comutil_error(utility_result_t *DSU_result , unsigned long frame_size_raw , unsigned long ignore2 ,
                   unsigned long ignore3 , unsigned long ignore4 ) 
{ 
  unsigned long frame_size ;

  {
#line 735
  frame_size = frame_size_raw;
  {
#line 736
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 736
    comutil_apply(DSU_result, *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 33),
                  frame_size, 0UL, 0UL);
    }
#line 736
    return;
#line 736
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 739
  return;
}
}
#line 749 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
void comutil_link(utility_result_t *DSU_result , unsigned long return_addr_raw , unsigned long block_addr_raw ,
                  unsigned long constant_addr_raw , unsigned long n_sections_raw ) 
{ 
  insn_t *return_addr ;
  SCHEME_OBJECT *block_addr ;
  SCHEME_OBJECT *constant_addr ;
  unsigned long n_sections ;
  link_cc_state_t s ;
  long result ;
  long tmp ;

  {
  {
#line 755
  return_addr = (insn_t *)return_addr_raw;
#line 756
  block_addr = (SCHEME_OBJECT *)block_addr_raw;
#line 757
  constant_addr = (SCHEME_OBJECT *)constant_addr_raw;
#line 758
  n_sections = n_sections_raw;
#line 761
  s.return_address = return_addr;
#line 762
  s.block_address = block_addr;
#line 763
  s.scan = constant_addr;
#line 764
  s.n_sections = n_sections;
#line 765
  s.n_linked_sections = 0UL;
#line 767
  start_linking_cc_block();
#line 769
  tmp = link_remaining_sections(& s);
#line 769
  result = tmp;
#line 770
  end_linking_cc_block(& s);
  }
#line 771
  if (result != -1L) {
    {
#line 772
    while (1) {
      while_continue: /* CIL Label */ ;
#line 772
      DSU_result->interface_dispatch = (void *)(& interface_to_C);
#line 772
      DSU_result->extra.code_to_interpreter = result;
#line 772
      return;
#line 772
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 774
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 774
    DSU_result->interface_dispatch = (void *)(& interface_to_scheme);
#line 774
    DSU_result->extra.entry_point = s.return_address;
#line 774
    return;
#line 774
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 775
  return;
}
}
#line 780 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
long comp_link_caches_restart(void) 
{ 
  link_cc_state_t s ;
  long result ;
  long tmp ;

  {
  {
#line 785
  restore_link_cc_state(& s);
#line 786
  Registers[3] = cc_block_environment((61UL << 58U) | (SCHEME_OBJECT )s.block_address);
#line 788
  start_linking_cc_block();
#line 790
  result = link_section(& s);
  }
#line 791
  if (result == -1L) {
    {
#line 792
    result = link_remaining_sections(& s);
    }
  }
  {
#line 794
  end_linking_cc_block(& s);
  }
#line 795
  if (result != -1L) {
#line 796
    return (result);
  }
  {
#line 798
  tmp = C_to_interface(s.return_address);
  }
#line 798
  return (tmp);
}
}
#line 801 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
static long link_remaining_sections(link_cc_state_t *s ) 
{ 
  long result ;
  long tmp ;

  {
  {
#line 804
  while (1) {
    while_continue: /* CIL Label */ ;
#line 804
    if (! (s->n_linked_sections < s->n_sections)) {
#line 804
      goto while_break;
    }
    {
#line 806
    start_linking_section(s);
#line 808
    tmp = link_section(s);
#line 808
    result = tmp;
    }
#line 809
    if (result != -1L) {
#line 810
      return (result);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 813
  return (-1L);
}
}
#line 816 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
static void start_linking_cc_block(void) 
{ 
  _Bool *ap ;
  void *tmp ;

  {
  {
#line 819
  tmp = dstack_alloc((unsigned int )sizeof(_Bool ));
#line 819
  ap = (_Bool *)tmp;
#line 820
  *ap = linking_cc_block_p;
#line 821
  transaction_begin();
#line 822
  transaction_record_action((enum transaction_action_type )2, & abort_linking_cc_block,
                            (void *)ap);
#line 823
  linking_cc_block_p = (_Bool)1;
  }
#line 824
  return;
}
}
#line 826 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
static void end_linking_cc_block(link_cc_state_t *s ) 
{ 


  {
  {
#line 829
  transaction_commit();
#line 830
  update_cache_after_link(s);
  }
#line 831
  return;
}
}
#line 833 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
static void abort_linking_cc_block(void *ap ) 
{ 


  {
#line 836
  linking_cc_block_p = *((_Bool *)ap);
#line 837
  return;
}
}
#line 839 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
static void update_cache_after_link(link_cc_state_t *s ) 
{ 


  {
#line 857
  return;
}
}
#line 859 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
static void start_linking_section(link_cc_state_t *s ) 
{ 
  SCHEME_OBJECT header ;
  SCHEME_OBJECT *tmp ;

  {
  {
#line 862
  s->scan0 = s->scan;
#line 863
  s->n_linked_entries = 0UL;
#line 865
  tmp = s->scan;
#line 865
  (s->scan) ++;
#line 865
  header = *tmp;
#line 866
  s->type = linkage_section_type(header);
#line 867
  s->n_entries = linkage_section_count(header);
  }
#line 869
  return;
}
}
#line 871 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
static long link_section(link_cc_state_t *s ) 
{ 
  SCHEME_OBJECT *scan1 ;
  SCHEME_OBJECT *scan ;
  SCHEME_OBJECT *block_address ;
  unsigned long n_linked ;
  unsigned long n_entries ;
  cache_handler_t *handler ;
  _Bool execute_p ;
  unsigned long entry_size ;
  long result ;
  _Bool tmp ;
  SCHEME_OBJECT tmp___0 ;
  SCHEME_OBJECT tmp___1 ;

  {
  {
#line 874
  scan1 = s->scan0 + 1;
#line 875
  scan = s->scan;
#line 876
  block_address = s->block_address;
#line 877
  n_linked = s->n_linked_entries;
#line 878
  n_entries = s->n_entries;
#line 882
  result = -1L;
#line 885
  tmp = link_section_handler(s->type, & handler, & execute_p);
  }
#line 885
  if (! tmp) {
#line 887
    result = 49L;
#line 888
    goto done;
  }
#line 891
  if (execute_p) {
#line 899
    if (n_linked == 0UL) {
      {
#line 900
      while (1) {
        while_continue: /* CIL Label */ ;
#line 900
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
      {
#line 902
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 902
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 903
    entry_size = 3UL;
  } else {
#line 906
    entry_size = 1UL;
  }
  {
#line 908
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 908
    if (! (n_linked < n_entries)) {
#line 908
      goto while_break___1;
    }
#line 910
    if (execute_p) {
      {
#line 910
      tmp___0 = read_uuo_symbol(scan);
#line 910
      tmp___1 = tmp___0;
      }
    } else {
#line 910
      tmp___1 = *scan;
    }
    {
#line 910
    result = (*handler)(tmp___1, (61UL << 58U) | (SCHEME_OBJECT )block_address, (unsigned long )(scan - block_address));
    }
#line 915
    if (result != -1L) {
#line 916
      goto while_break___1;
    }
#line 917
    scan += entry_size;
#line 918
    n_linked ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  done: 
#line 924
  if (n_linked == 0UL) {
#line 924
    s->scan = scan1;
  } else {
#line 924
    s->scan = scan;
  }
  {
#line 925
  s->n_linked_entries = n_linked;
#line 926
  *(s->scan0) = make_linkage_section_marker(s->type, n_linked);
  }
#line 927
  if (result == -1L) {
#line 928
    (s->n_linked_sections) ++;
  } else {
    {
#line 930
    back_out_of_link_section(s);
    }
  }
#line 931
  return (result);
}
}
#line 934 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
static _Bool link_section_handler(linkage_section_type_t type , cache_handler_t **handler_r ,
                                  _Bool *execute_p_r ) 
{ 


  {
  {
#line 941
  if ((unsigned int )type == 0U) {
#line 941
    goto case_0;
  }
#line 946
  if ((unsigned int )type == 3U) {
#line 946
    goto case_3;
  }
#line 951
  if ((unsigned int )type == 1U) {
#line 951
    goto case_1;
  }
#line 956
  if ((unsigned int )type == 2U) {
#line 956
    goto case_2;
  }
#line 961
  goto switch_default;
  case_0: /* CIL Label */ 
#line 942
  *handler_r = & compiler_cache_operator;
#line 943
  *execute_p_r = (_Bool)1;
#line 944
  return ((_Bool)1);
  case_3: /* CIL Label */ 
#line 947
  *handler_r = & compiler_cache_global_operator;
#line 948
  *execute_p_r = (_Bool)1;
#line 949
  return ((_Bool)1);
  case_1: /* CIL Label */ 
#line 952
  *handler_r = & compiler_cache_lookup;
#line 953
  *execute_p_r = (_Bool)0;
#line 954
  return ((_Bool)1);
  case_2: /* CIL Label */ 
#line 957
  *handler_r = & compiler_cache_assignment;
#line 958
  *execute_p_r = (_Bool)0;
#line 959
  return ((_Bool)1);
  switch_default: /* CIL Label */ 
#line 962
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 966 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
static void back_out_of_link_section(link_cc_state_t *s ) 
{ 
  long SLRC_offset ;

  {
#line 970
  stack_pointer --;
#line 970
  *stack_pointer = (40UL << 58U) | (SCHEME_OBJECT )((SCHEME_OBJECT *)s->return_address);
#line 971
  stack_pointer --;
#line 971
  *stack_pointer = (26UL << 58U) | (s->n_sections - s->n_linked_sections);
#line 972
  stack_pointer --;
#line 972
  *stack_pointer = (26UL << 58U) | (unsigned long )(s->scan0 - s->block_address);
#line 973
  stack_pointer --;
#line 973
  *stack_pointer = (26UL << 58U) | (unsigned long )(s->scan - s->block_address);
#line 974
  stack_pointer --;
#line 974
  *stack_pointer = (61UL << 58U) | (SCHEME_OBJECT )s->block_address;
#line 975
  stack_pointer --;
#line 975
  *stack_pointer = (26UL << 58U) | (s->n_entries - s->n_linked_entries);
#line 976
  stack_pointer --;
#line 976
  *stack_pointer = (26UL << 58U) | s->n_entries;
  {
#line 977
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 977
    SLRC_offset = last_return_code - stack_pointer;
#line 977
    stack_pointer --;
#line 977
    *stack_pointer = (26UL << 58U) | ((unsigned long )SLRC_offset & 288230376151711743UL);
#line 977
    stack_pointer --;
#line 977
    *stack_pointer = (11UL << 58U) | 91UL;
#line 977
    compiler_new_subproblem();
    }
#line 977
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 978
  return;
}
}
#line 980 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
static void restore_link_cc_state(link_cc_state_t *s ) 
{ 
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;
  SCHEME_OBJECT *tmp___2 ;
  SCHEME_OBJECT *tmp___3 ;
  SCHEME_OBJECT *tmp___4 ;
  SCHEME_OBJECT *tmp___5 ;

  {
  {
#line 983
  while (1) {
    while_continue: /* CIL Label */ ;
#line 983
    last_return_code = stack_pointer + (Registers[5] & 288230376151711743UL);
    {
#line 983
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 983
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 983
    end_subproblem();
    }
#line 983
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 984
  tmp = stack_pointer;
#line 984
  stack_pointer ++;
#line 984
  s->n_entries = *tmp & 288230376151711743UL;
#line 985
  tmp___0 = stack_pointer;
#line 985
  stack_pointer ++;
#line 985
  s->n_linked_entries = s->n_entries - (*tmp___0 & 288230376151711743UL);
#line 986
  tmp___1 = stack_pointer;
#line 986
  stack_pointer ++;
#line 986
  s->block_address = (SCHEME_OBJECT *)(*tmp___1 & 288230376151711743UL);
#line 987
  tmp___2 = stack_pointer;
#line 987
  stack_pointer ++;
#line 987
  s->scan = s->block_address + (*tmp___2 & 288230376151711743UL);
#line 988
  tmp___3 = stack_pointer;
#line 988
  stack_pointer ++;
#line 988
  s->scan0 = s->block_address + (*tmp___3 & 288230376151711743UL);
#line 989
  tmp___4 = stack_pointer;
#line 989
  stack_pointer ++;
#line 989
  s->n_sections = *tmp___4 & 288230376151711743UL;
#line 990
  tmp___5 = stack_pointer;
#line 990
  stack_pointer ++;
#line 990
  s->return_address = (insn_t *)((SCHEME_OBJECT *)(*tmp___5 & 288230376151711743UL));
#line 992
  s->n_linked_sections = 0UL;
#line 993
  s->type = linkage_section_type(*(s->scan0));
  }
#line 994
  return;
}
}
#line 996 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
SCHEME_OBJECT cc_block_linkage_info(SCHEME_OBJECT block ) 
{ 
  SCHEME_OBJECT *const_addr ;
  SCHEME_OBJECT *block_end ;
  unsigned long n_sections ;
  unsigned long n_words ;
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;
  SCHEME_OBJECT tmp___2 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 999
  const_addr = (SCHEME_OBJECT *)(block & 288230376151711743UL) + ((1UL + (*((SCHEME_OBJECT *)(((10UL << 58U) | (SCHEME_OBJECT )((SCHEME_OBJECT *)(block & 288230376151711743UL) + 1)) & 288230376151711743UL) + 0) & 288230376151711743UL)) + 1UL);
#line 1001
  block_end = (SCHEME_OBJECT *)(block & 288230376151711743UL) + ((*((SCHEME_OBJECT *)(block & 288230376151711743UL)) & 288230376151711743UL) + 1UL);
#line 1005
  count_linkage_sections(const_addr, block_end, & n_sections, & n_words);
  }
  {
#line 1006
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1006
    if ((unsigned long )Free >= (unsigned long )heap_start) {
#line 1006
      if ((unsigned long )Free < (unsigned long )heap_alloc_limit) {
#line 1006
        if (! ((unsigned long )(Free + n_words) <= (unsigned long )heap_alloc_limit)) {
#line 1006
          goto _L___0;
        }
      } else {
#line 1006
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1006
    if ((Registers[1] & 4UL) != 0UL) {
      {
#line 1006
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1006
        if ((unsigned long )Free_primitive < (unsigned long )heap_start) {
          {
#line 1006
          outf_fatal("\nMicrocode requested primitive GC outside primitive!\n");
#line 1006
          Microcode_Termination(12);
          }
        }
#line 1006
        if ((unsigned long )Free < (unsigned long )Free_primitive) {
          {
#line 1006
          outf_fatal("\nFree has gone backwards!\n");
#line 1006
          Microcode_Termination(12);
          }
        }
        {
#line 1006
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 1006
          while (1) {
            while_continue___2: /* CIL Label */ ;
            {
#line 1006
            set_ulong_register(12U, Registers[12] | 4UL);
            }
            {
#line 1006
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 1006
              if ((Registers[1] & Registers[12]) != 0UL) {
#line 1006
                tmp___0 = memory_block_start;
              } else {
#line 1006
                if ((Registers[1] & 4UL) != 0UL) {
#line 1006
                  tmp = heap_alloc_limit;
                } else {
#line 1006
                  tmp = heap_end;
                }
#line 1006
                tmp___0 = tmp;
              }
              {
#line 1006
              set_ptr_register(0U, tmp___0);
              }
#line 1006
              if ((Registers[1] & 1UL) != 0UL) {
#line 1006
                tmp___1 = stack_guard;
              } else {
#line 1006
                tmp___1 = stack_start;
              }
              {
#line 1006
              set_ptr_register(11U, tmp___1);
              }
#line 1006
              goto while_break___3;
            }
            while_break___3: /* CIL Label */ ;
            }
#line 1006
            goto while_break___2;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 1006
          gc_space_needed = n_words + (unsigned long )(Free - Free_primitive);
#line 1006
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 1006
        signal_interrupt_from_primitive();
        }
#line 1006
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 1006
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1007
  tmp___2 = read_linkage_sections(const_addr, block_end, n_sections, n_words);
  }
#line 1007
  return (tmp___2);
}
}
#line 1010 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
static void count_linkage_sections(SCHEME_OBJECT *const_addr , SCHEME_OBJECT *block_end ,
                                   unsigned long *n_sections , unsigned long *n_words ) 
{ 
  SCHEME_OBJECT *scan ;
  SCHEME_OBJECT h ;
  SCHEME_OBJECT *tmp ;
  unsigned long count ;
  unsigned long tmp___0 ;
  unsigned long tmp___2 ;
  _Bool tmp___3 ;
  _Bool tmp___4 ;

  {
#line 1016
  scan = const_addr;
#line 1017
  *n_sections = 0UL;
#line 1018
  *n_words = 1UL;
  {
#line 1019
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1019
    tmp___4 = unlinked_section_start_p(scan, block_end);
    }
#line 1019
    if (! tmp___4) {
#line 1019
      goto while_break;
    }
    {
#line 1021
    tmp = scan;
#line 1021
    scan ++;
#line 1021
    h = *tmp;
#line 1022
    tmp___0 = linkage_section_count(h);
#line 1022
    count = tmp___0;
#line 1023
    (*n_sections) ++;
#line 1026
    *n_words += 3UL + count;
#line 1027
    tmp___3 = section_execute_p(h);
    }
#line 1027
    if (tmp___3) {
#line 1027
      tmp___2 = count * 3UL;
    } else {
#line 1027
      tmp___2 = count;
    }
#line 1027
    scan += tmp___2;
  }
  while_break: /* CIL Label */ ;
  }
#line 1032
  return;
}
}
#line 1034 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
static SCHEME_OBJECT read_linkage_sections(SCHEME_OBJECT *const_addr , SCHEME_OBJECT *block_end ,
                                           unsigned long n_sections , unsigned long n_words ) 
{ 
  SCHEME_OBJECT *scan ;
  SCHEME_OBJECT sections ;
  SCHEME_OBJECT tmp ;
  SCHEME_OBJECT *sp ;
  SCHEME_OBJECT *spe ;
  SCHEME_OBJECT h ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT section ;
  unsigned long tmp___1 ;
  SCHEME_OBJECT tmp___2 ;
  SCHEME_OBJECT *p ;
  SCHEME_OBJECT *pe ;
  SCHEME_OBJECT *tmp___3 ;
  linkage_section_type_t tmp___4 ;
  SCHEME_OBJECT *tmp___5 ;
  SCHEME_OBJECT *tmp___6 ;
  SCHEME_OBJECT *tmp___7 ;
  _Bool tmp___8 ;
  SCHEME_OBJECT *tmp___9 ;

  {
  {
#line 1040
  scan = const_addr;
#line 1041
  tmp = make_vector(n_sections, 0UL, (_Bool)0);
#line 1041
  sections = tmp;
#line 1042
  sp = (SCHEME_OBJECT *)(sections & 288230376151711743UL) + 1;
#line 1043
  spe = (SCHEME_OBJECT *)(sections & 288230376151711743UL) + ((*((SCHEME_OBJECT *)(sections & 288230376151711743UL) + 0) & 288230376151711743UL) + 1UL);
  }
  {
#line 1044
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1044
    if (! ((unsigned long )sp < (unsigned long )spe)) {
#line 1044
      goto while_break;
    }
    {
#line 1046
    tmp___0 = scan;
#line 1046
    scan ++;
#line 1046
    h = *tmp___0;
#line 1047
    tmp___1 = linkage_section_count(h);
#line 1047
    tmp___2 = make_vector(1UL + tmp___1, 0UL, (_Bool)0);
#line 1047
    section = tmp___2;
#line 1049
    p = (SCHEME_OBJECT *)(section & 288230376151711743UL) + 1;
#line 1050
    pe = (SCHEME_OBJECT *)(section & 288230376151711743UL) + ((*((SCHEME_OBJECT *)(section & 288230376151711743UL) + 0) & 288230376151711743UL) + 1UL);
#line 1052
    tmp___3 = p;
#line 1052
    p ++;
#line 1052
    tmp___4 = linkage_section_type(h);
#line 1052
    *tmp___3 = (26UL << 58U) | (unsigned long )tmp___4;
#line 1053
    tmp___8 = section_execute_p(h);
    }
#line 1053
    if (tmp___8) {
#line 1055
      scan += 0;
      {
#line 1056
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1056
        if (! ((unsigned long )p < (unsigned long )pe)) {
#line 1056
          goto while_break___0;
        }
        {
#line 1058
        tmp___5 = p;
#line 1058
        p ++;
#line 1058
        *tmp___5 = read_uuo_symbol(scan);
#line 1059
        scan += 3;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
      {
#line 1063
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1063
        if (! ((unsigned long )p < (unsigned long )pe)) {
#line 1063
          goto while_break___1;
        }
#line 1064
        tmp___6 = p;
#line 1064
        p ++;
#line 1064
        tmp___7 = scan;
#line 1064
        scan ++;
#line 1064
        *tmp___6 = *tmp___7;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 1066
    tmp___9 = sp;
#line 1066
    sp ++;
#line 1066
    *tmp___9 = section;
  }
  while_break: /* CIL Label */ ;
  }
#line 1069
  return (sections);
}
}
#line 1072 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
static _Bool section_execute_p(SCHEME_OBJECT h ) 
{ 
  linkage_section_type_t type ;
  linkage_section_type_t tmp ;
  int tmp___0 ;

  {
  {
#line 1075
  tmp = linkage_section_type(h);
#line 1075
  type = tmp;
  }
#line 1076
  if ((unsigned int )type == 0U) {
#line 1076
    tmp___0 = 1;
  } else
#line 1076
  if ((unsigned int )type == 3U) {
#line 1076
    tmp___0 = 1;
  } else {
#line 1076
    tmp___0 = 0;
  }
#line 1076
  return ((_Bool )tmp___0);
}
}
#line 1095 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
void comutil_interrupt_closure(utility_result_t *DSU_result , unsigned long ignore1 ,
                               unsigned long ignore2 , unsigned long ignore3 , unsigned long ignore4 ) 
{ 


  {
  {
#line 1097
  compiler_interrupt_common(DSU_result, (insn_t *)0, 0UL);
  }
#line 1098
  return;
}
}
#line 1100 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
void comutil_interrupt_dlink(utility_result_t *DSU_result , unsigned long entry_point_raw ,
                             unsigned long dlink_raw , unsigned long ignore3 , unsigned long ignore4 ) 
{ 
  insn_t *entry_point ;
  SCHEME_OBJECT *dlink ;

  {
  {
#line 1102
  entry_point = (insn_t *)entry_point_raw;
#line 1103
  dlink = (SCHEME_OBJECT *)dlink_raw;
#line 1104
  compiler_interrupt_common(DSU_result, entry_point, (59UL << 58U) | (SCHEME_OBJECT )dlink);
  }
#line 1107
  return;
}
}
#line 1109 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
void comutil_interrupt_procedure(utility_result_t *DSU_result , unsigned long entry_point_raw ,
                                 unsigned long ignore2 , unsigned long ignore3 , unsigned long ignore4 ) 
{ 
  insn_t *entry_point ;

  {
  {
#line 1111
  entry_point = (insn_t *)entry_point_raw;
#line 1112
  compiler_interrupt_common(DSU_result, entry_point, 0UL);
  }
#line 1113
  return;
}
}
#line 1117 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
void comutil_interrupt_continuation(utility_result_t *DSU_result , unsigned long return_addr_raw ,
                                    unsigned long ignore2 , unsigned long ignore3 ,
                                    unsigned long ignore4 ) 
{ 
  insn_t *return_addr ;

  {
  {
#line 1119
  return_addr = (insn_t *)return_addr_raw;
#line 1120
  compiler_interrupt_common(DSU_result, return_addr, Registers[2]);
  }
#line 1121
  return;
}
}
#line 1125 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
void comutil_interrupt_ic_procedure(utility_result_t *DSU_result , unsigned long entry_point_raw ,
                                    unsigned long ignore2 , unsigned long ignore3 ,
                                    unsigned long ignore4 ) 
{ 
  insn_t *entry_point ;

  {
  {
#line 1127
  entry_point = (insn_t *)entry_point_raw;
#line 1128
  compiler_interrupt_common(DSU_result, entry_point, Registers[3]);
  }
#line 1129
  return;
}
}
#line 1131 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
void comutil_interrupt_continuation_2(utility_result_t *DSU_result , unsigned long ignore1 ,
                                      unsigned long ignore2 , unsigned long ignore3 ,
                                      unsigned long ignore4 ) 
{ 


  {
  {
#line 1133
  compiler_interrupt_common(DSU_result, (insn_t *)0, Registers[2]);
  }
#line 1134
  return;
}
}
#line 1136 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
void compiler_interrupt_common(utility_result_t *DSU_result , insn_t *address___0 ,
                               SCHEME_OBJECT state ) 
{ 
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;
  SCHEME_OBJECT *tmp___2 ;
  SCHEME_OBJECT *tmp___3 ;
  SCHEME_OBJECT *tmp___4 ;
  long SLRC_offset ;
  char *__cil_tmp11 ;

  {
#line 1141
  if ((unsigned long )Free >= (unsigned long )heap_start) {
#line 1141
    if (! ((unsigned long )Free < (unsigned long )heap_alloc_limit)) {
#line 1141
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 1142
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1142
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 1142
        set_ulong_register(12U, Registers[12] | 4UL);
        }
        {
#line 1142
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1142
          if ((Registers[1] & Registers[12]) != 0UL) {
#line 1142
            tmp___0 = memory_block_start;
          } else {
#line 1142
            if ((Registers[1] & 4UL) != 0UL) {
#line 1142
              tmp = heap_alloc_limit;
            } else {
#line 1142
              tmp = heap_end;
            }
#line 1142
            tmp___0 = tmp;
          }
          {
#line 1142
          set_ptr_register(0U, tmp___0);
          }
#line 1142
          if ((Registers[1] & 1UL) != 0UL) {
#line 1142
            tmp___1 = stack_guard;
          } else {
#line 1142
            tmp___1 = stack_start;
          }
          {
#line 1142
          set_ptr_register(11U, tmp___1);
          }
#line 1142
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1142
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1142
      gc_space_needed = (unsigned long )(Free - heap_alloc_limit);
#line 1142
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 1143
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1143
    if (! ((unsigned long )(stack_pointer + 0) >= (unsigned long )stack_guard)) {
      {
#line 1143
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1143
        if (*stack_start != ((34UL << 58U) | (SCHEME_OBJECT )stack_start)) {
          {
#line 1143
          stack_death("STACK_CHECK");
          }
        }
#line 1143
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 1143
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 1143
        set_ulong_register(12U, Registers[12] | 1UL);
        }
        {
#line 1143
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 1143
          if ((Registers[1] & Registers[12]) != 0UL) {
#line 1143
            tmp___3 = memory_block_start;
          } else {
#line 1143
            if ((Registers[1] & 4UL) != 0UL) {
#line 1143
              tmp___2 = heap_alloc_limit;
            } else {
#line 1143
              tmp___2 = heap_end;
            }
#line 1143
            tmp___3 = tmp___2;
          }
          {
#line 1143
          set_ptr_register(0U, tmp___3);
          }
#line 1143
          if ((Registers[1] & 1UL) != 0UL) {
#line 1143
            tmp___4 = stack_guard;
          } else {
#line 1143
            tmp___4 = stack_start;
          }
          {
#line 1143
          set_ptr_register(11U, tmp___4);
          }
#line 1143
          goto while_break___5;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 1143
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
#line 1143
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1144
  if ((unsigned long )address___0 != (unsigned long )((insn_t *)0)) {
#line 1145
    stack_pointer --;
#line 1145
    *stack_pointer = (40UL << 58U) | (SCHEME_OBJECT )((SCHEME_OBJECT *)address___0);
  }
#line 1146
  stack_pointer --;
#line 1146
  *stack_pointer = state;
  {
#line 1147
  while (1) {
    while_continue___6: /* CIL Label */ ;
    {
#line 1147
    SLRC_offset = last_return_code - stack_pointer;
#line 1147
    stack_pointer --;
#line 1147
    *stack_pointer = (26UL << 58U) | ((unsigned long )SLRC_offset & 288230376151711743UL);
#line 1147
    stack_pointer --;
#line 1147
    *stack_pointer = (11UL << 58U) | 67UL;
#line 1147
    compiler_new_subproblem();
    }
#line 1147
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 1148
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 1148
    DSU_result->interface_dispatch = (void *)(& interface_to_C);
#line 1148
    DSU_result->extra.code_to_interpreter = -4L;
#line 1148
    return;
#line 1148
    goto while_break___7;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 1149
  return;
}
}
#line 1151 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
long comp_interrupt_restart(void) 
{ 
  SCHEME_OBJECT state ;
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT *tmp___0 ;
  long tmp___1 ;

  {
  {
#line 1153
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1153
    last_return_code = stack_pointer + (Registers[5] & 288230376151711743UL);
    {
#line 1153
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1153
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1153
    end_subproblem();
    }
#line 1153
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1155
  tmp = stack_pointer;
#line 1155
  stack_pointer ++;
#line 1155
  state = *tmp;
#line 1156
  Registers[3] = state;
#line 1157
  Registers[2] = state;
#line 1159
  tmp___0 = stack_pointer;
#line 1159
  stack_pointer ++;
#line 1159
  tmp___1 = C_to_interface((insn_t *)((SCHEME_OBJECT *)(*tmp___0 & 288230376151711743UL)));
  }
#line 1159
  return (tmp___1);
}
}
#line 1166 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
void comutil_assignment_trap(utility_result_t *DSU_result , unsigned long ret_addr_raw ,
                             unsigned long cache_addr_raw , unsigned long new_val_raw ,
                             unsigned long ignore4 ) 
{ 
  insn_t *ret_addr ;
  SCHEME_OBJECT *cache_addr ;
  SCHEME_OBJECT new_val ;
  SCHEME_OBJECT cache ;
  SCHEME_OBJECT old_val ;
  long code ;
  long tmp ;
  SCHEME_OBJECT sra ;
  SCHEME_OBJECT block ;
  SCHEME_OBJECT tmp___0 ;
  long SLRC_offset ;

  {
  {
#line 1169
  ret_addr = (insn_t *)ret_addr_raw;
#line 1170
  cache_addr = (SCHEME_OBJECT *)cache_addr_raw;
#line 1171
  new_val = new_val_raw;
#line 1172
  cache = (36UL << 58U) | (SCHEME_OBJECT )cache_addr;
#line 1174
  tmp = compiler_assignment_trap(cache, new_val, & old_val);
#line 1174
  code = tmp;
  }
#line 1175
  if (code != -1L) {
    {
#line 1177
    sra = (40UL << 58U) | (SCHEME_OBJECT )((SCHEME_OBJECT *)ret_addr);
#line 1178
    tmp___0 = cc_entry_to_block(sra);
#line 1178
    block = tmp___0;
#line 1179
    stack_pointer --;
#line 1179
    *stack_pointer = sra;
#line 1180
    stack_pointer --;
#line 1180
    *stack_pointer = new_val;
#line 1181
    stack_pointer --;
#line 1181
    *stack_pointer = cc_block_environment(block);
#line 1182
    stack_pointer --;
#line 1182
    *stack_pointer = compiler_var_error(cache, block, 1U);
    }
    {
#line 1184
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1184
      SLRC_offset = last_return_code - stack_pointer;
#line 1184
      stack_pointer --;
#line 1184
      *stack_pointer = (26UL << 58U) | ((unsigned long )SLRC_offset & 288230376151711743UL);
#line 1184
      stack_pointer --;
#line 1184
      *stack_pointer = (11UL << 58U) | 84UL;
#line 1184
      compiler_new_subproblem();
      }
#line 1184
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1185
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1185
      DSU_result->interface_dispatch = (void *)(& interface_to_C);
#line 1185
      DSU_result->extra.code_to_interpreter = code;
#line 1185
      return;
#line 1185
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1187
  Registers[2] = old_val;
  {
#line 1188
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1188
    DSU_result->interface_dispatch = (void *)(& interface_to_scheme);
#line 1188
    DSU_result->extra.entry_point = ret_addr;
#line 1188
    return;
#line 1188
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1189
  return;
}
}
#line 1191 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
long comp_assignment_trap_restart(void) 
{ 
  SCHEME_OBJECT name ;
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT environment ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT new_val ;
  SCHEME_OBJECT *tmp___1 ;
  SCHEME_OBJECT old_val ;
  long code ;
  long tmp___2 ;
  long SLRC_offset ;
  SCHEME_OBJECT *tmp___3 ;
  long tmp___4 ;

  {
  {
#line 1193
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1193
    last_return_code = stack_pointer + (Registers[5] & 288230376151711743UL);
    {
#line 1193
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1193
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1193
    end_subproblem();
    }
#line 1193
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1195
  tmp = stack_pointer;
#line 1195
  stack_pointer ++;
#line 1195
  name = *tmp;
#line 1196
  tmp___0 = stack_pointer;
#line 1196
  stack_pointer ++;
#line 1196
  environment = *tmp___0;
#line 1197
  tmp___1 = stack_pointer;
#line 1197
  stack_pointer ++;
#line 1197
  new_val = *tmp___1;
#line 1199
  tmp___2 = assign_variable(environment, name, new_val, & old_val);
#line 1199
  code = tmp___2;
  }
#line 1200
  if (code != -1L) {
#line 1202
    stack_pointer --;
#line 1202
    *stack_pointer = new_val;
#line 1203
    stack_pointer --;
#line 1203
    *stack_pointer = environment;
#line 1204
    stack_pointer --;
#line 1204
    *stack_pointer = name;
    {
#line 1205
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1205
      SLRC_offset = last_return_code - stack_pointer;
#line 1205
      stack_pointer --;
#line 1205
      *stack_pointer = (26UL << 58U) | ((unsigned long )SLRC_offset & 288230376151711743UL);
#line 1205
      stack_pointer --;
#line 1205
      *stack_pointer = (11UL << 58U) | 84UL;
#line 1205
      compiler_new_subproblem();
      }
#line 1205
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1206
    return (code);
  }
  {
#line 1208
  Registers[2] = old_val;
#line 1209
  tmp___3 = stack_pointer;
#line 1209
  stack_pointer ++;
#line 1209
  tmp___4 = C_to_interface((insn_t *)((SCHEME_OBJECT *)(*tmp___3 & 288230376151711743UL)));
  }
#line 1209
  return (tmp___4);
}
}
#line 1213 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
void comutil_cache_lookup_apply(utility_result_t *DSU_result , unsigned long cache_addr_raw ,
                                unsigned long block_addr_raw , unsigned long frame_size_raw ,
                                unsigned long ignore4 ) 
{ 
  SCHEME_OBJECT *cache_addr ;
  SCHEME_OBJECT *block_addr ;
  unsigned long frame_size ;
  SCHEME_OBJECT cache ;
  SCHEME_OBJECT value ;
  long code ;
  long tmp ;
  SCHEME_OBJECT block ;
  long SLRC_offset ;

  {
  {
#line 1216
  cache_addr = (SCHEME_OBJECT *)cache_addr_raw;
#line 1217
  block_addr = (SCHEME_OBJECT *)block_addr_raw;
#line 1218
  frame_size = frame_size_raw;
#line 1219
  cache = (36UL << 58U) | (SCHEME_OBJECT )cache_addr;
#line 1221
  tmp = compiler_lookup_trap(cache, & value);
#line 1221
  code = tmp;
  }
#line 1222
  if (code != -1L) {
    {
#line 1224
    block = (61UL << 58U) | (SCHEME_OBJECT )block_addr;
#line 1225
    stack_pointer --;
#line 1225
    *stack_pointer = block;
#line 1226
    stack_pointer --;
#line 1226
    *stack_pointer = (26UL << 58U) | frame_size;
#line 1227
    stack_pointer --;
#line 1227
    *stack_pointer = cc_block_environment(block);
#line 1228
    stack_pointer --;
#line 1228
    *stack_pointer = compiler_var_error(cache, block, 2U);
    }
    {
#line 1230
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1230
      SLRC_offset = last_return_code - stack_pointer;
#line 1230
      stack_pointer --;
#line 1230
      *stack_pointer = (26UL << 58U) | ((unsigned long )SLRC_offset & 288230376151711743UL);
#line 1230
      stack_pointer --;
#line 1230
      *stack_pointer = (11UL << 58U) | 87UL;
#line 1230
      compiler_new_subproblem();
      }
#line 1230
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1231
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1231
      DSU_result->interface_dispatch = (void *)(& interface_to_C);
#line 1231
      DSU_result->extra.code_to_interpreter = code;
#line 1231
      return;
#line 1231
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 1233
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 1233
    comutil_apply(DSU_result, value, frame_size, 0UL, 0UL);
    }
#line 1233
    return;
#line 1233
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1234
  return;
}
}
#line 1236 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
long comp_cache_lookup_apply_restart(void) 
{ 
  SCHEME_OBJECT name ;
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT environment ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT frame_size ;
  SCHEME_OBJECT *tmp___1 ;
  SCHEME_OBJECT block ;
  SCHEME_OBJECT *tmp___2 ;
  SCHEME_OBJECT value ;
  long code ;
  long tmp___3 ;
  long SLRC_offset ;
  long tmp___4 ;

  {
  {
#line 1238
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1238
    last_return_code = stack_pointer + (Registers[5] & 288230376151711743UL);
    {
#line 1238
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1238
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1238
    end_subproblem();
    }
#line 1238
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1240
  tmp = stack_pointer;
#line 1240
  stack_pointer ++;
#line 1240
  name = *tmp;
#line 1241
  tmp___0 = stack_pointer;
#line 1241
  stack_pointer ++;
#line 1241
  environment = *tmp___0;
#line 1242
  tmp___1 = stack_pointer;
#line 1242
  stack_pointer ++;
#line 1242
  frame_size = *tmp___1;
#line 1243
  tmp___2 = stack_pointer;
#line 1243
  stack_pointer ++;
#line 1243
  block = *tmp___2;
#line 1246
  tmp___3 = lookup_variable(environment, name, & value);
#line 1246
  code = tmp___3;
  }
#line 1247
  if (code != -1L) {
#line 1249
    stack_pointer --;
#line 1249
    *stack_pointer = block;
#line 1250
    stack_pointer --;
#line 1250
    *stack_pointer = frame_size;
#line 1251
    stack_pointer --;
#line 1251
    *stack_pointer = environment;
#line 1252
    stack_pointer --;
#line 1252
    *stack_pointer = name;
    {
#line 1253
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1253
      SLRC_offset = last_return_code - stack_pointer;
#line 1253
      stack_pointer --;
#line 1253
      *stack_pointer = (26UL << 58U) | ((unsigned long )SLRC_offset & 288230376151711743UL);
#line 1253
      stack_pointer --;
#line 1253
      *stack_pointer = (11UL << 58U) | 87UL;
#line 1253
      compiler_new_subproblem();
      }
#line 1253
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1254
    return (code);
  }
#line 1257
  stack_pointer --;
#line 1257
  *stack_pointer = value;
#line 1258
  stack_pointer --;
#line 1258
  *stack_pointer = ((frame_size & 288230376151711743UL) - 1UL) + 1UL;
#line 1259
  if (value >> 58U == 40UL) {
    {
#line 1260
    tmp___4 = apply_compiled_procedure();
    }
#line 1260
    return (tmp___4);
  }
  {
#line 1261
  guarantee_interp_return();
  }
#line 1262
  return (-3L);
}
}
#line 1269 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
void comutil_lookup_trap(utility_result_t *DSU_result , unsigned long ret_addr_raw ,
                         unsigned long cache_addr_raw , unsigned long ignore3 , unsigned long ignore4 ) 
{ 
  insn_t *ret_addr ;
  SCHEME_OBJECT *cache_addr ;
  SCHEME_OBJECT cache ;
  SCHEME_OBJECT val ;
  long code ;
  long tmp ;
  SCHEME_OBJECT sra ;
  SCHEME_OBJECT block ;
  SCHEME_OBJECT tmp___0 ;
  long SLRC_offset ;

  {
  {
#line 1271
  ret_addr = (insn_t *)ret_addr_raw;
#line 1272
  cache_addr = (SCHEME_OBJECT *)cache_addr_raw;
#line 1273
  cache = (36UL << 58U) | (SCHEME_OBJECT )cache_addr;
#line 1275
  tmp = compiler_lookup_trap(cache, & val);
#line 1275
  code = tmp;
  }
#line 1276
  if (code != -1L) {
    {
#line 1278
    sra = (40UL << 58U) | (SCHEME_OBJECT )((SCHEME_OBJECT *)ret_addr);
#line 1279
    tmp___0 = cc_entry_to_block(sra);
#line 1279
    block = tmp___0;
#line 1280
    stack_pointer --;
#line 1280
    *stack_pointer = sra;
#line 1281
    stack_pointer --;
#line 1281
    *stack_pointer = cc_block_environment(block);
#line 1282
    stack_pointer --;
#line 1282
    *stack_pointer = compiler_var_error(cache, block, 0U);
    }
    {
#line 1283
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1283
      SLRC_offset = last_return_code - stack_pointer;
#line 1283
      stack_pointer --;
#line 1283
      *stack_pointer = (26UL << 58U) | ((unsigned long )SLRC_offset & 288230376151711743UL);
#line 1283
      stack_pointer --;
#line 1283
      *stack_pointer = (11UL << 58U) | 83UL;
#line 1283
      compiler_new_subproblem();
      }
#line 1283
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1284
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1284
      DSU_result->interface_dispatch = (void *)(& interface_to_C);
#line 1284
      DSU_result->extra.code_to_interpreter = code;
#line 1284
      return;
#line 1284
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1286
  Registers[2] = val;
  {
#line 1287
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1287
    DSU_result->interface_dispatch = (void *)(& interface_to_scheme);
#line 1287
    DSU_result->extra.entry_point = ret_addr;
#line 1287
    return;
#line 1287
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1288
  return;
}
}
#line 1290 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
long comp_lookup_trap_restart(void) 
{ 
  SCHEME_OBJECT name ;
  SCHEME_OBJECT environment ;
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT val ;
  long code ;
  long tmp___0 ;
  long SLRC_offset ;
  SCHEME_OBJECT *tmp___1 ;
  long tmp___2 ;

  {
  {
#line 1292
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1292
    last_return_code = stack_pointer + (Registers[5] & 288230376151711743UL);
    {
#line 1292
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1292
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1292
    end_subproblem();
    }
#line 1292
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1294
  name = Registers[5];
#line 1295
  tmp = stack_pointer;
#line 1295
  stack_pointer ++;
#line 1295
  environment = *tmp;
#line 1297
  tmp___0 = lookup_variable(environment, name, & val);
#line 1297
  code = tmp___0;
  }
#line 1298
  if (code != -1L) {
#line 1300
    stack_pointer --;
#line 1300
    *stack_pointer = environment;
#line 1301
    stack_pointer --;
#line 1301
    *stack_pointer = name;
    {
#line 1302
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1302
      SLRC_offset = last_return_code - stack_pointer;
#line 1302
      stack_pointer --;
#line 1302
      *stack_pointer = (26UL << 58U) | ((unsigned long )SLRC_offset & 288230376151711743UL);
#line 1302
      stack_pointer --;
#line 1302
      *stack_pointer = (11UL << 58U) | 83UL;
#line 1302
      compiler_new_subproblem();
      }
#line 1302
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1303
    return (code);
  }
  {
#line 1305
  Registers[2] = val;
#line 1306
  tmp___1 = stack_pointer;
#line 1306
  stack_pointer ++;
#line 1306
  tmp___2 = C_to_interface((insn_t *)((SCHEME_OBJECT *)(*tmp___1 & 288230376151711743UL)));
  }
#line 1306
  return (tmp___2);
}
}
#line 1310 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
void comutil_safe_lookup_trap(utility_result_t *DSU_result , unsigned long ret_addr_raw ,
                              unsigned long cache_addr_raw , unsigned long ignore3 ,
                              unsigned long ignore4 ) 
{ 
  insn_t *ret_addr ;
  SCHEME_OBJECT *cache_addr ;
  SCHEME_OBJECT cache ;
  SCHEME_OBJECT val ;
  long code ;
  long tmp ;
  SCHEME_OBJECT sra ;
  SCHEME_OBJECT block ;
  SCHEME_OBJECT tmp___0 ;
  long SLRC_offset ;

  {
  {
#line 1312
  ret_addr = (insn_t *)ret_addr_raw;
#line 1313
  cache_addr = (SCHEME_OBJECT *)cache_addr_raw;
#line 1314
  cache = (36UL << 58U) | (SCHEME_OBJECT )cache_addr;
#line 1316
  tmp = compiler_safe_lookup_trap(cache, & val);
#line 1316
  code = tmp;
  }
#line 1317
  if (code != -1L) {
    {
#line 1319
    sra = (40UL << 58U) | (SCHEME_OBJECT )((SCHEME_OBJECT *)ret_addr);
#line 1320
    tmp___0 = cc_entry_to_block(sra);
#line 1320
    block = tmp___0;
#line 1321
    stack_pointer --;
#line 1321
    *stack_pointer = sra;
#line 1322
    stack_pointer --;
#line 1322
    *stack_pointer = cc_block_environment(block);
#line 1323
    stack_pointer --;
#line 1323
    *stack_pointer = compiler_var_error(cache, block, 0U);
    }
    {
#line 1324
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1324
      SLRC_offset = last_return_code - stack_pointer;
#line 1324
      stack_pointer --;
#line 1324
      *stack_pointer = (26UL << 58U) | ((unsigned long )SLRC_offset & 288230376151711743UL);
#line 1324
      stack_pointer --;
#line 1324
      *stack_pointer = (11UL << 58U) | 88UL;
#line 1324
      compiler_new_subproblem();
      }
#line 1324
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1325
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1325
      DSU_result->interface_dispatch = (void *)(& interface_to_C);
#line 1325
      DSU_result->extra.code_to_interpreter = code;
#line 1325
      return;
#line 1325
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1327
  Registers[2] = val;
  {
#line 1328
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1328
    DSU_result->interface_dispatch = (void *)(& interface_to_scheme);
#line 1328
    DSU_result->extra.entry_point = ret_addr;
#line 1328
    return;
#line 1328
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1329
  return;
}
}
#line 1331 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
long comp_safe_lookup_trap_restart(void) 
{ 
  SCHEME_OBJECT name ;
  SCHEME_OBJECT environment ;
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT val ;
  long code ;
  long tmp___0 ;
  long SLRC_offset ;
  SCHEME_OBJECT *tmp___1 ;
  long tmp___2 ;

  {
  {
#line 1333
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1333
    last_return_code = stack_pointer + (Registers[5] & 288230376151711743UL);
    {
#line 1333
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1333
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1333
    end_subproblem();
    }
#line 1333
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1335
  name = Registers[5];
#line 1336
  tmp = stack_pointer;
#line 1336
  stack_pointer ++;
#line 1336
  environment = *tmp;
#line 1338
  tmp___0 = safe_lookup_variable(environment, name, & val);
#line 1338
  code = tmp___0;
  }
#line 1339
  if (code != -1L) {
#line 1341
    stack_pointer --;
#line 1341
    *stack_pointer = environment;
#line 1342
    stack_pointer --;
#line 1342
    *stack_pointer = name;
    {
#line 1343
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1343
      SLRC_offset = last_return_code - stack_pointer;
#line 1343
      stack_pointer --;
#line 1343
      *stack_pointer = (26UL << 58U) | ((unsigned long )SLRC_offset & 288230376151711743UL);
#line 1343
      stack_pointer --;
#line 1343
      *stack_pointer = (11UL << 58U) | 88UL;
#line 1343
      compiler_new_subproblem();
      }
#line 1343
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1344
    return (code);
  }
  {
#line 1346
  Registers[2] = val;
#line 1347
  tmp___1 = stack_pointer;
#line 1347
  stack_pointer ++;
#line 1347
  tmp___2 = C_to_interface((insn_t *)((SCHEME_OBJECT *)(*tmp___1 & 288230376151711743UL)));
  }
#line 1347
  return (tmp___2);
}
}
#line 1351 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
void comutil_unassigned_p_trap(utility_result_t *DSU_result , unsigned long ret_addr_raw ,
                               unsigned long cache_addr_raw , unsigned long ignore3 ,
                               unsigned long ignore4 ) 
{ 
  insn_t *ret_addr ;
  SCHEME_OBJECT *cache_addr ;
  SCHEME_OBJECT cache ;
  SCHEME_OBJECT val ;
  long code ;
  long tmp ;
  SCHEME_OBJECT sra ;
  SCHEME_OBJECT block ;
  SCHEME_OBJECT tmp___0 ;
  long SLRC_offset ;

  {
  {
#line 1353
  ret_addr = (insn_t *)ret_addr_raw;
#line 1354
  cache_addr = (SCHEME_OBJECT *)cache_addr_raw;
#line 1355
  cache = (36UL << 58U) | (SCHEME_OBJECT )cache_addr;
#line 1357
  tmp = compiler_unassigned_p_trap(cache, & val);
#line 1357
  code = tmp;
  }
#line 1358
  if (code != -1L) {
    {
#line 1360
    sra = (40UL << 58U) | (SCHEME_OBJECT )((SCHEME_OBJECT *)ret_addr);
#line 1361
    tmp___0 = cc_entry_to_block(sra);
#line 1361
    block = tmp___0;
#line 1362
    stack_pointer --;
#line 1362
    *stack_pointer = sra;
#line 1363
    stack_pointer --;
#line 1363
    *stack_pointer = cc_block_environment(block);
#line 1364
    stack_pointer --;
#line 1364
    *stack_pointer = compiler_var_error(cache, block, 0U);
    }
    {
#line 1365
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1365
      SLRC_offset = last_return_code - stack_pointer;
#line 1365
      stack_pointer --;
#line 1365
      *stack_pointer = (26UL << 58U) | ((unsigned long )SLRC_offset & 288230376151711743UL);
#line 1365
      stack_pointer --;
#line 1365
      *stack_pointer = (11UL << 58U) | 89UL;
#line 1365
      compiler_new_subproblem();
      }
#line 1365
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1366
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1366
      DSU_result->interface_dispatch = (void *)(& interface_to_C);
#line 1366
      DSU_result->extra.code_to_interpreter = code;
#line 1366
      return;
#line 1366
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1368
  Registers[2] = val;
  {
#line 1369
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1369
    DSU_result->interface_dispatch = (void *)(& interface_to_scheme);
#line 1369
    DSU_result->extra.entry_point = ret_addr;
#line 1369
    return;
#line 1369
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1370
  return;
}
}
#line 1372 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
long comp_unassigned_p_trap_restart(void) 
{ 
  SCHEME_OBJECT name ;
  SCHEME_OBJECT environment ;
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT val ;
  long code ;
  long tmp___0 ;
  long SLRC_offset ;
  SCHEME_OBJECT *tmp___1 ;
  long tmp___2 ;

  {
  {
#line 1374
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1374
    last_return_code = stack_pointer + (Registers[5] & 288230376151711743UL);
    {
#line 1374
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1374
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1374
    end_subproblem();
    }
#line 1374
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1376
  name = Registers[5];
#line 1377
  tmp = stack_pointer;
#line 1377
  stack_pointer ++;
#line 1377
  environment = *tmp;
#line 1379
  tmp___0 = variable_unassigned_p(environment, name, & val);
#line 1379
  code = tmp___0;
  }
#line 1380
  if (code != -1L) {
#line 1382
    stack_pointer --;
#line 1382
    *stack_pointer = environment;
#line 1383
    stack_pointer --;
#line 1383
    *stack_pointer = name;
    {
#line 1384
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1384
      SLRC_offset = last_return_code - stack_pointer;
#line 1384
      stack_pointer --;
#line 1384
      *stack_pointer = (26UL << 58U) | ((unsigned long )SLRC_offset & 288230376151711743UL);
#line 1384
      stack_pointer --;
#line 1384
      *stack_pointer = (11UL << 58U) | 89UL;
#line 1384
      compiler_new_subproblem();
      }
#line 1384
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1385
    return (code);
  }
  {
#line 1387
  Registers[2] = val;
#line 1388
  tmp___1 = stack_pointer;
#line 1388
  stack_pointer ++;
#line 1388
  tmp___2 = C_to_interface((insn_t *)((SCHEME_OBJECT *)(*tmp___1 & 288230376151711743UL)));
  }
#line 1388
  return (tmp___2);
}
}
#line 1404 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
void comutil_decrement(utility_result_t *DSU_result , unsigned long ignore1 , unsigned long ignore2 ,
                       unsigned long ignore3 , unsigned long ignore4 ) 
{ 


  {
  {
#line 1404
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1404
    comutil_apply(DSU_result, *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 41),
                  2UL, 0UL, 0UL);
    }
#line 1404
    return;
#line 1404
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1404
  return;
}
}
#line 1405 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
void comutil_divide(utility_result_t *DSU_result , unsigned long ignore1 , unsigned long ignore2 ,
                    unsigned long ignore3 , unsigned long ignore4 ) 
{ 


  {
  {
#line 1405
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1405
    comutil_apply(DSU_result, *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 48),
                  3UL, 0UL, 0UL);
    }
#line 1405
    return;
#line 1405
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1405
  return;
}
}
#line 1406 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
void comutil_equal(utility_result_t *DSU_result , unsigned long ignore1 , unsigned long ignore2 ,
                   unsigned long ignore3 , unsigned long ignore4 ) 
{ 


  {
  {
#line 1406
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1406
    comutil_apply(DSU_result, *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 42),
                  3UL, 0UL, 0UL);
    }
#line 1406
    return;
#line 1406
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1406
  return;
}
}
#line 1407 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
void comutil_greater(utility_result_t *DSU_result , unsigned long ignore1 , unsigned long ignore2 ,
                     unsigned long ignore3 , unsigned long ignore4 ) 
{ 


  {
  {
#line 1407
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1407
    comutil_apply(DSU_result, *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 44),
                  3UL, 0UL, 0UL);
    }
#line 1407
    return;
#line 1407
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1407
  return;
}
}
#line 1408 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
void comutil_increment(utility_result_t *DSU_result , unsigned long ignore1 , unsigned long ignore2 ,
                       unsigned long ignore3 , unsigned long ignore4 ) 
{ 


  {
  {
#line 1408
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1408
    comutil_apply(DSU_result, *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 40),
                  2UL, 0UL, 0UL);
    }
#line 1408
    return;
#line 1408
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1408
  return;
}
}
#line 1409 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
void comutil_less(utility_result_t *DSU_result , unsigned long ignore1 , unsigned long ignore2 ,
                  unsigned long ignore3 , unsigned long ignore4 ) 
{ 


  {
  {
#line 1409
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1409
    comutil_apply(DSU_result, *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 43),
                  3UL, 0UL, 0UL);
    }
#line 1409
    return;
#line 1409
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1409
  return;
}
}
#line 1410 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
void comutil_minus(utility_result_t *DSU_result , unsigned long ignore1 , unsigned long ignore2 ,
                   unsigned long ignore3 , unsigned long ignore4 ) 
{ 


  {
  {
#line 1410
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1410
    comutil_apply(DSU_result, *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 46),
                  3UL, 0UL, 0UL);
    }
#line 1410
    return;
#line 1410
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1410
  return;
}
}
#line 1411 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
void comutil_modulo(utility_result_t *DSU_result , unsigned long ignore1 , unsigned long ignore2 ,
                    unsigned long ignore3 , unsigned long ignore4 ) 
{ 


  {
  {
#line 1411
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1411
    comutil_apply(DSU_result, *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 51),
                  3UL, 0UL, 0UL);
    }
#line 1411
    return;
#line 1411
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1411
  return;
}
}
#line 1412 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
void comutil_multiply(utility_result_t *DSU_result , unsigned long ignore1 , unsigned long ignore2 ,
                      unsigned long ignore3 , unsigned long ignore4 ) 
{ 


  {
  {
#line 1412
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1412
    comutil_apply(DSU_result, *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 47),
                  3UL, 0UL, 0UL);
    }
#line 1412
    return;
#line 1412
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1412
  return;
}
}
#line 1413 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
void comutil_negative(utility_result_t *DSU_result , unsigned long ignore1 , unsigned long ignore2 ,
                      unsigned long ignore3 , unsigned long ignore4 ) 
{ 


  {
  {
#line 1413
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1413
    comutil_apply(DSU_result, *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 39),
                  2UL, 0UL, 0UL);
    }
#line 1413
    return;
#line 1413
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1413
  return;
}
}
#line 1414 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
void comutil_plus(utility_result_t *DSU_result , unsigned long ignore1 , unsigned long ignore2 ,
                  unsigned long ignore3 , unsigned long ignore4 ) 
{ 


  {
  {
#line 1414
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1414
    comutil_apply(DSU_result, *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 45),
                  3UL, 0UL, 0UL);
    }
#line 1414
    return;
#line 1414
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1414
  return;
}
}
#line 1415 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
void comutil_positive(utility_result_t *DSU_result , unsigned long ignore1 , unsigned long ignore2 ,
                      unsigned long ignore3 , unsigned long ignore4 ) 
{ 


  {
  {
#line 1415
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1415
    comutil_apply(DSU_result, *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 38),
                  2UL, 0UL, 0UL);
    }
#line 1415
    return;
#line 1415
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1415
  return;
}
}
#line 1416 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
void comutil_quotient(utility_result_t *DSU_result , unsigned long ignore1 , unsigned long ignore2 ,
                      unsigned long ignore3 , unsigned long ignore4 ) 
{ 


  {
  {
#line 1416
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1416
    comutil_apply(DSU_result, *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 49),
                  3UL, 0UL, 0UL);
    }
#line 1416
    return;
#line 1416
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1416
  return;
}
}
#line 1417 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
void comutil_remainder(utility_result_t *DSU_result , unsigned long ignore1 , unsigned long ignore2 ,
                       unsigned long ignore3 , unsigned long ignore4 ) 
{ 


  {
  {
#line 1417
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1417
    comutil_apply(DSU_result, *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 50),
                  3UL, 0UL, 0UL);
    }
#line 1417
    return;
#line 1417
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1417
  return;
}
}
#line 1418 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
void comutil_zero(utility_result_t *DSU_result , unsigned long ignore1 , unsigned long ignore2 ,
                  unsigned long ignore3 , unsigned long ignore4 ) 
{ 


  {
  {
#line 1418
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1418
    comutil_apply(DSU_result, *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 37),
                  2UL, 0UL, 0UL);
    }
#line 1418
    return;
#line 1418
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1418
  return;
}
}
#line 1420 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
void comutil_primitive_error(utility_result_t *DSU_result , unsigned long ret_addr_raw ,
                             unsigned long primitive_raw , unsigned long ignore3 ,
                             unsigned long ignore4 ) 
{ 
  insn_t *ret_addr ;
  SCHEME_OBJECT primitive ;
  long SLRC_offset ;

  {
#line 1422
  ret_addr = (insn_t *)ret_addr_raw;
#line 1423
  primitive = primitive_raw;
#line 1424
  stack_pointer --;
#line 1424
  *stack_pointer = (40UL << 58U) | (SCHEME_OBJECT )((SCHEME_OBJECT *)ret_addr);
#line 1425
  stack_pointer --;
#line 1425
  *stack_pointer = primitive;
  {
#line 1426
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1426
    SLRC_offset = last_return_code - stack_pointer;
#line 1426
    stack_pointer --;
#line 1426
    *stack_pointer = (26UL << 58U) | ((unsigned long )SLRC_offset & 288230376151711743UL);
#line 1426
    stack_pointer --;
#line 1426
    *stack_pointer = (11UL << 58U) | 94UL;
#line 1426
    compiler_new_subproblem();
    }
#line 1426
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1427
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1427
    DSU_result->interface_dispatch = (void *)(& interface_to_C);
#line 1427
    DSU_result->extra.code_to_interpreter = 49L;
#line 1427
    return;
#line 1427
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1428
  return;
}
}
#line 1430 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
long comp_error_restart(void) 
{ 
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT *tmp___0 ;
  long tmp___1 ;

  {
  {
#line 1432
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1432
    last_return_code = stack_pointer + (Registers[5] & 288230376151711743UL);
    {
#line 1432
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1432
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1432
    end_subproblem();
    }
#line 1432
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1433
  tmp = stack_pointer;
#line 1433
  stack_pointer ++;
#line 1434
  tmp___0 = stack_pointer;
#line 1434
  stack_pointer ++;
#line 1434
  tmp___1 = C_to_interface((insn_t *)((SCHEME_OBJECT *)(*tmp___0 & 288230376151711743UL)));
  }
#line 1434
  return (tmp___1);
}
}
#line 1437 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
void apply_compiled_from_primitive(unsigned long n_args , SCHEME_OBJECT procedure ) 
{ 
  unsigned long frame_size ;
  SCHEME_OBJECT data ;
  SCHEME_OBJECT operator ;

  {
  {
#line 1440
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1440
    if (! (procedure >> 58U == 16UL)) {
#line 1440
      goto while_break;
    }
#line 1443
    frame_size = n_args + 1UL;
#line 1444
    data = *((SCHEME_OBJECT *)(procedure & 288230376151711743UL) + 1);
#line 1445
    if (data >> 58U == 10UL) {
#line 1445
      if (frame_size < (*((SCHEME_OBJECT *)(data & 288230376151711743UL) + 0) & 288230376151711743UL)) {
#line 1445
        if (*((SCHEME_OBJECT *)(data & 288230376151711743UL) + (frame_size + 1UL)) >> 58U == 40UL) {
#line 1445
          if (*((SCHEME_OBJECT *)(data & 288230376151711743UL) + 1) == *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 52)) {
#line 1451
            procedure = *((SCHEME_OBJECT *)(data & 288230376151711743UL) + (frame_size + 1UL));
#line 1452
            goto while_continue;
          }
        }
      }
    }
#line 1456
    operator = *((SCHEME_OBJECT *)(procedure & 288230376151711743UL) + 0);
#line 1457
    if (operator >> 58U == 40UL) {
#line 1459
      stack_pointer --;
#line 1459
      *stack_pointer = procedure;
#line 1460
      n_args ++;
#line 1461
      procedure = operator;
    }
#line 1464
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1467
  if (procedure >> 58U == 40UL) {
    {
#line 1468
    setup_compiled_invocation_from_primitive(procedure, n_args);
    }
  } else {
#line 1471
    stack_pointer --;
#line 1471
    *stack_pointer = procedure;
#line 1472
    stack_pointer --;
#line 1472
    *stack_pointer = n_args + 1UL;
    {
#line 1473
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1473
      stack_pointer --;
#line 1473
      *stack_pointer = 26UL << 58U;
#line 1473
      stack_pointer --;
#line 1473
      *stack_pointer = reflect_to_interface;
#line 1473
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1475
  return;
}
}
#line 1477 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
void compiled_with_interrupt_mask(unsigned long old_mask , SCHEME_OBJECT receiver ,
                                  unsigned long new_mask ) 
{ 


  {
#line 1482
  stack_pointer --;
#line 1482
  *stack_pointer = (26UL << 58U) | old_mask;
  {
#line 1483
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1483
    stack_pointer --;
#line 1483
    *stack_pointer = (26UL << 58U) | 1UL;
#line 1483
    stack_pointer --;
#line 1483
    *stack_pointer = reflect_to_interface;
#line 1483
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1484
  stack_pointer --;
#line 1484
  *stack_pointer = (26UL << 58U) | new_mask;
#line 1485
  setup_compiled_invocation_from_primitive(receiver, 1UL);
  }
#line 1486
  return;
}
}
#line 1488 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
void compiled_with_stack_marker(SCHEME_OBJECT thunk ) 
{ 


  {
  {
#line 1491
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1491
    stack_pointer --;
#line 1491
    *stack_pointer = (26UL << 58U) | 2UL;
#line 1491
    stack_pointer --;
#line 1491
    *stack_pointer = reflect_to_interface;
#line 1491
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1492
  setup_compiled_invocation_from_primitive(thunk, 0UL);
  }
#line 1493
  return;
}
}
#line 1495 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
static void setup_compiled_invocation_from_primitive(SCHEME_OBJECT procedure , unsigned long n_args ) 
{ 
  long code ;
  long tmp ;

  {
  {
#line 1499
  tmp = setup_compiled_invocation(procedure, n_args);
#line 1499
  code = tmp;
  }
#line 1500
  if (code != -1L) {
#line 1502
    if (code != -9L) {
#line 1504
      prim_apply_error_code = code;
#line 1505
      code = -10L;
    }
    {
#line 1507
    abort_to_interpreter((int )code);
    }
  }
#line 1511
  stack_pointer --;
#line 1511
  *stack_pointer = procedure;
#line 1512
  return;
}
}
#line 1518 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
static long setup_compiled_invocation(SCHEME_OBJECT procedure , unsigned long n_args ) 
{ 
  cc_entry_type_t cet ;
  unsigned long n_min ;
  unsigned long n_max ;
  _Bool tmp ;
  long tmp___0 ;
  _Bool tmp___1 ;

  {
  {
#line 1525
  tmp = read_cc_entry_type(& cet, (insn_t *)((SCHEME_OBJECT *)(procedure & 288230376151711743UL)));
  }
#line 1525
  if (tmp) {
    {
#line 1527
    recover_from_apply_error(procedure, n_args);
    }
#line 1528
    return (49L);
  }
#line 1530
  if ((unsigned int )cet.marker != 0U) {
    {
#line 1532
    recover_from_apply_error(procedure, n_args);
    }
#line 1533
    return (3L);
  }
#line 1535
  n_min = (unsigned long )cet.args.for_procedure.n_required;
#line 1536
  if (n_args < n_min) {
    {
#line 1538
    recover_from_apply_error(procedure, n_args);
    }
#line 1539
    return (12L);
  }
#line 1541
  n_max = n_min + (unsigned long )cet.args.for_procedure.n_optional;
#line 1542
  if (cet.args.for_procedure.rest_p) {
    {
#line 1543
    tmp___0 = setup_lexpr_invocation(procedure, n_args, n_max);
    }
#line 1543
    return (tmp___0);
  }
#line 1544
  if (n_args == n_max) {
#line 1545
    return (-1L);
  }
#line 1546
  if (n_args > n_max) {
    {
#line 1548
    recover_from_apply_error(procedure, n_args);
    }
#line 1549
    return (12L);
  }
  {
#line 1551
  tmp___1 = open_gap(n_args, n_max);
  }
#line 1551
  if (tmp___1) {
    {
#line 1553
    recover_from_apply_error(procedure, n_args);
    }
#line 1554
    return (-9L);
  }
#line 1556
  return (-1L);
}
}
#line 1559 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
static long setup_lexpr_invocation(SCHEME_OBJECT procedure , unsigned long n_args ,
                                   unsigned long n_max ) 
{ 
  _Bool tmp ;
  unsigned long n_words ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;
  SCHEME_OBJECT *tmp___2 ;
  SCHEME_OBJECT rest_arg ;
  SCHEME_OBJECT *p1 ;
  unsigned long i ;
  SCHEME_OBJECT *tmp___3 ;
  SCHEME_OBJECT *p2 ;
  unsigned long i___0 ;

  {
#line 1564
  if (n_args <= n_max) {
    {
#line 1566
    tmp = open_gap(n_args, n_max + 1UL);
    }
#line 1566
    if (tmp) {
      {
#line 1568
      recover_from_apply_error(procedure, n_args);
      }
#line 1569
      return (-9L);
    }
#line 1571
    *(stack_pointer + n_max) = (8UL << 58U) | 9UL;
#line 1572
    return (-1L);
  }
#line 1575
  n_words = (n_args - n_max) * 2UL;
#line 1576
  if ((unsigned long )Free >= (unsigned long )heap_start) {
#line 1576
    if ((unsigned long )Free < (unsigned long )heap_alloc_limit) {
#line 1576
      if (! ((unsigned long )(Free + n_words) <= (unsigned long )heap_alloc_limit)) {
#line 1576
        goto _L___0;
      }
    } else {
#line 1576
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1576
  if ((Registers[1] & 4UL) != 0UL) {
    {
#line 1578
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1578
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 1578
        set_ulong_register(12U, Registers[12] | 4UL);
        }
        {
#line 1578
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1578
          if ((Registers[1] & Registers[12]) != 0UL) {
#line 1578
            tmp___1 = memory_block_start;
          } else {
#line 1578
            if ((Registers[1] & 4UL) != 0UL) {
#line 1578
              tmp___0 = heap_alloc_limit;
            } else {
#line 1578
              tmp___0 = heap_end;
            }
#line 1578
            tmp___1 = tmp___0;
          }
          {
#line 1578
          set_ptr_register(0U, tmp___1);
          }
#line 1578
          if ((Registers[1] & 1UL) != 0UL) {
#line 1578
            tmp___2 = stack_guard;
          } else {
#line 1578
            tmp___2 = stack_start;
          }
          {
#line 1578
          set_ptr_register(11U, tmp___2);
          }
#line 1578
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1578
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1578
      gc_space_needed = n_words;
#line 1578
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1579
    recover_from_apply_error(procedure, n_args);
    }
#line 1580
    return (-9L);
  }
#line 1584
  rest_arg = (1UL << 58U) | (SCHEME_OBJECT )Free;
#line 1585
  p1 = stack_pointer + n_max;
#line 1588
  i = n_max;
  {
#line 1588
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1588
    if (! (i < n_args)) {
#line 1588
      goto while_break___2;
    }
#line 1590
    tmp___3 = p1;
#line 1590
    p1 ++;
#line 1590
    *(Free + 0) = *tmp___3;
#line 1591
    *(Free + 1) = (1UL << 58U) | (SCHEME_OBJECT )(Free + 2);
#line 1592
    Free += 2;
#line 1588
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1595
  *(Free + -1) = (8UL << 58U) | 9UL;
#line 1596
  p1 --;
#line 1596
  *p1 = rest_arg;
#line 1598
  p2 = stack_pointer + n_max;
#line 1600
  i___0 = 0UL;
  {
#line 1600
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1600
    if (! (i___0 < n_max)) {
#line 1600
      goto while_break___3;
    }
#line 1601
    p1 --;
#line 1601
    p2 --;
#line 1601
    *p1 = *p2;
#line 1600
    i___0 ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1603
  stack_pointer = p1;
#line 1605
  return (-1L);
}
}
#line 1608 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
static _Bool open_gap(unsigned long n_args , unsigned long n_needed ) 
{ 
  unsigned long n_defaults ;
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;
  SCHEME_OBJECT *scan ;
  SCHEME_OBJECT *end ;
  SCHEME_OBJECT *tmp___2 ;
  char *__cil_tmp10 ;

  {
#line 1611
  n_defaults = n_needed - n_args;
  {
#line 1613
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1613
    if (! ((unsigned long )(stack_pointer + - n_defaults) >= (unsigned long )stack_guard)) {
      {
#line 1613
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1613
        if (*stack_start != ((34UL << 58U) | (SCHEME_OBJECT )stack_start)) {
          {
#line 1613
          stack_death("STACK_CHECK");
          }
        }
#line 1613
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1613
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 1613
        set_ulong_register(12U, Registers[12] | 1UL);
        }
        {
#line 1613
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1613
          if ((Registers[1] & Registers[12]) != 0UL) {
#line 1613
            tmp___0 = memory_block_start;
          } else {
#line 1613
            if ((Registers[1] & 4UL) != 0UL) {
#line 1613
              tmp = heap_alloc_limit;
            } else {
#line 1613
              tmp = heap_end;
            }
#line 1613
            tmp___0 = tmp;
          }
          {
#line 1613
          set_ptr_register(0U, tmp___0);
          }
#line 1613
          if ((Registers[1] & 1UL) != 0UL) {
#line 1613
            tmp___1 = stack_guard;
          } else {
#line 1613
            tmp___1 = stack_start;
          }
          {
#line 1613
          set_ptr_register(11U, tmp___1);
          }
#line 1613
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 1613
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 1613
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1614
  if ((Registers[1] & Registers[12]) != 0UL) {
#line 1615
    return ((_Bool)1);
  }
  {
#line 1617
  open_stack_gap(n_args, n_defaults);
#line 1619
  scan = stack_pointer + n_args;
#line 1620
  end = stack_pointer + n_needed;
  }
  {
#line 1621
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1621
    if (! ((unsigned long )scan != (unsigned long )end)) {
#line 1621
      goto while_break___3;
    }
#line 1622
    tmp___2 = scan;
#line 1622
    scan ++;
#line 1622
    *tmp___2 = (8UL << 58U) | 7UL;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1624
  return ((_Bool)0);
}
}
#line 1627 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
void make_compiled_procedure_type(cc_entry_type_t *cet , unsigned int n_required ,
                                  unsigned int n_optional , _Bool rest_p ) 
{ 


  {
#line 1633
  cet->marker = (cc_entry_type_marker_t )0;
#line 1634
  cet->args.for_procedure.n_required = n_required;
#line 1635
  cet->args.for_procedure.n_optional = n_optional;
#line 1636
  cet->args.for_procedure.rest_p = rest_p;
#line 1637
  return;
}
}
#line 1639 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
void make_compiled_continuation_type(cc_entry_type_t *cet , unsigned long offset ) 
{ 


  {
#line 1642
  cet->marker = (cc_entry_type_marker_t )1;
#line 1643
  cet->args.for_continuation.offset = offset;
#line 1644
  return;
}
}
#line 1646 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
void make_cc_entry_type(cc_entry_type_t *cet , cc_entry_type_marker_t marker ) 
{ 


  {
  {
#line 1650
  cet->marker = marker;
#line 1651
  memset((void *)(& cet->args), 0, sizeof(cet->marker));
  }
#line 1652
  return;
}
}
#line 1654 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
SCHEME_OBJECT cc_entry_to_block(SCHEME_OBJECT entry ) 
{ 
  SCHEME_OBJECT *tmp ;

  {
  {
#line 1657
  tmp = cc_entry_to_block_address(entry);
  }
#line 1657
  return ((61UL << 58U) | (SCHEME_OBJECT )tmp);
}
}
#line 1660 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
SCHEME_OBJECT *cc_entry_to_block_address(SCHEME_OBJECT entry ) 
{ 
  SCHEME_OBJECT *tmp ;

  {
  {
#line 1663
  tmp = cc_entry_address_to_block_address((insn_t *)((SCHEME_OBJECT *)(entry & 288230376151711743UL)));
  }
#line 1663
  return (tmp);
}
}
#line 1666 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
SCHEME_OBJECT *cc_entry_address_to_block_address(insn_t *entry ) 
{ 
  insn_t *p ;
  cc_entry_offset_t ceo ;

  {
#line 1669
  p = entry;
  {
#line 1670
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1673
    read_cc_entry_offset(& ceo, p);
#line 1674
    p -= ceo.offset;
    }
#line 1675
    if (! ceo.continued_p) {
#line 1680
      return ((SCHEME_OBJECT *)p);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1685 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
static _Bool plausible_first_cc_entry_p(insn_t *entry , insn_t *zero ) 
{ 
  cc_entry_type_t cet ;
  cc_entry_offset_t ceo ;
  _Bool tmp ;
  _Bool tmp___0 ;

  {
  {
#line 1691
  tmp = read_cc_entry_type(& cet, entry);
  }
#line 1691
  if (tmp) {
#line 1692
    return ((_Bool)0);
  }
  {
#line 1694
  tmp___0 = read_cc_entry_offset(& ceo, entry);
  }
#line 1694
  if (tmp___0) {
#line 1695
    return ((_Bool)0);
  }
#line 1697
  if (ceo.offset != (unsigned long )(entry - zero)) {
#line 1698
    return ((_Bool)0);
  }
#line 1700
  return ((_Bool)1);
}
}
#line 1703 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
int plausible_cc_block_p(SCHEME_OBJECT *block ) 
{ 
  insn_t *zero ;
  insn_t *entry ;
  _Bool tmp ;
  _Bool tmp___0 ;
  SCHEME_OBJECT *block_end ;
  int tmp___1 ;

  {
  {
#line 1706
  zero = (insn_t *)block;
#line 1707
  entry = (insn_t *)(block + 2) + 4;
#line 1709
  tmp___0 = plausible_first_cc_entry_p(entry, zero);
  }
#line 1709
  if (! tmp___0) {
    {
#line 1711
    entry += 6;
#line 1712
    tmp = plausible_first_cc_entry_p(entry, zero);
    }
#line 1712
    if (! tmp) {
#line 1713
      return (0);
    }
  }
#line 1717
  block_end = (block + ((*block & 288230376151711743UL) + 1UL)) - 1;
#line 1718
  if ((unsigned long )block >= (unsigned long )heap_start) {
#line 1718
    if ((unsigned long )block < (unsigned long )Free) {
#line 1718
      if ((unsigned long )block_end >= (unsigned long )heap_start) {
#line 1718
        if ((unsigned long )block_end < (unsigned long )Free) {
#line 1718
          goto _L;
        } else {
#line 1718
          goto _L___1;
        }
      } else {
#line 1718
        goto _L___1;
      }
    } else {
#line 1718
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 1718
  if ((unsigned long )block >= (unsigned long )constant_start) {
#line 1718
    if ((unsigned long )block < (unsigned long )constant_end) {
#line 1718
      if ((unsigned long )block_end >= (unsigned long )constant_start) {
#line 1718
        if ((unsigned long )block_end < (unsigned long )constant_end) {
          _L: /* CIL Label */ 
#line 1718
          if (*block_end >> 58U == 18UL) {
#line 1718
            tmp___1 = 1;
          } else
#line 1718
          if (*block_end == 0UL) {
#line 1718
            tmp___1 = 1;
          } else {
#line 1718
            tmp___1 = 0;
          }
        } else {
#line 1718
          tmp___1 = 0;
        }
      } else {
#line 1718
        tmp___1 = 0;
      }
    } else {
#line 1718
      tmp___1 = 0;
    }
  } else {
#line 1718
    tmp___1 = 0;
  }
#line 1718
  return (tmp___1);
}
}
#line 1726 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
static _Bool unlinked_section_start_p(SCHEME_OBJECT *mp , SCHEME_OBJECT *end ) 
{ 
  SCHEME_OBJECT marker ;
  int tmp ;

  {
#line 1729
  marker = *mp;
#line 1730
  if (marker >> 58U == 26UL) {
#line 1730
    if ((marker & 288230376151711743UL) >> 16 < 4UL) {
#line 1730
      if ((unsigned long )((mp + 1) + ((marker & 288230376151711743UL) & 65535UL)) < (unsigned long )end) {
#line 1730
        tmp = 1;
      } else {
#line 1730
        tmp = 0;
      }
    } else {
#line 1730
      tmp = 0;
    }
  } else {
#line 1730
    tmp = 0;
  }
#line 1730
  return ((_Bool )tmp);
}
}
#line 1736 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
linkage_section_type_t linkage_section_type(SCHEME_OBJECT marker ) 
{ 
  unsigned long type ;

  {
#line 1739
  type = (marker & 288230376151711743UL) >> 16;
#line 1741
  return ((linkage_section_type_t )type);
}
}
#line 1749 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
unsigned long linkage_section_count(SCHEME_OBJECT marker ) 
{ 
  linkage_section_type_t type ;
  linkage_section_type_t tmp ;
  unsigned long n_words ;
  unsigned long tmp___0 ;

  {
  {
#line 1752
  tmp = linkage_section_type(marker);
#line 1752
  type = tmp;
#line 1753
  n_words = (marker & 288230376151711743UL) & 65535UL;
  }
#line 1754
  if ((unsigned int )type == 0U) {
#line 1754
    tmp___0 = n_words / 3UL;
  } else
#line 1754
  if ((unsigned int )type == 3U) {
#line 1754
    tmp___0 = n_words / 3UL;
  } else {
#line 1754
    tmp___0 = n_words;
  }
#line 1754
  return (tmp___0);
}
}
#line 1760 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
SCHEME_OBJECT make_linkage_section_marker(linkage_section_type_t type , unsigned long count ) 
{ 
  unsigned long n_words ;

  {
#line 1766
  if ((unsigned int )type == 0U) {
#line 1766
    n_words = count * 3UL;
  } else
#line 1766
  if ((unsigned int )type == 3U) {
#line 1766
    n_words = count * 3UL;
  } else {
#line 1766
    n_words = count;
  }
#line 1772
  return ((57UL << 58U) | (((unsigned long )type << 16) | n_words));
}
}
#line 1782 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
SCHEME_OBJECT cc_block_debugging_info(SCHEME_OBJECT block ) 
{ 


  {
#line 1785
  return (*((SCHEME_OBJECT *)(block & 288230376151711743UL) + (((*((SCHEME_OBJECT *)(block & 288230376151711743UL) + 0) & 288230376151711743UL) - 2UL) + 1UL)));
}
}
#line 1790 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
SCHEME_OBJECT cc_block_environment(SCHEME_OBJECT block ) 
{ 


  {
#line 1793
  return (*((SCHEME_OBJECT *)(block & 288230376151711743UL) + (((*((SCHEME_OBJECT *)(block & 288230376151711743UL) + 0) & 288230376151711743UL) - 1UL) + 1UL)));
}
}
#line 1796 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
unsigned long cc_entry_to_block_offset(SCHEME_OBJECT entry ) 
{ 
  SCHEME_OBJECT *tmp ;

  {
  {
#line 1799
  tmp = cc_entry_to_block_address(entry);
  }
#line 1799
  return ((unsigned long )((insn_t *)((SCHEME_OBJECT *)(entry & 288230376151711743UL)) - (insn_t *)tmp));
}
}
#line 1803 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
_Bool cc_block_closure_p(SCHEME_OBJECT block ) 
{ 
  _Bool tmp ;

  {
  {
#line 1806
  tmp = cc_block_address_closure_p((SCHEME_OBJECT *)(block & 288230376151711743UL));
  }
#line 1806
  return (tmp);
}
}
#line 1809 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
_Bool cc_entry_closure_p(SCHEME_OBJECT entry ) 
{ 
  SCHEME_OBJECT *tmp ;
  _Bool tmp___0 ;

  {
  {
#line 1812
  tmp = cc_entry_to_block_address(entry);
#line 1812
  tmp___0 = cc_block_address_closure_p(tmp);
  }
#line 1812
  return (tmp___0);
}
}
#line 1815 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
static _Bool cc_block_address_closure_p(SCHEME_OBJECT *block_addr ) 
{ 
  SCHEME_OBJECT header_word ;

  {
#line 1818
  header_word = *block_addr;
#line 1819
  return ((_Bool )(header_word >> 58U == 13UL));
}
}
#line 1825 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
SCHEME_OBJECT cc_closure_to_entry(SCHEME_OBJECT entry ) 
{ 
  SCHEME_OBJECT tmp ;

  {
  {
#line 1828
  tmp = compiled_closure_entry_to_target((insn_t *)((SCHEME_OBJECT *)(entry & 288230376151711743UL)));
  }
#line 1828
  return (tmp);
}
}
#line 1831 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
void declare_compiled_code_block(SCHEME_OBJECT block ) 
{ 


  {
#line 1837
  return;
}
}
#line 1839 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
void write_variable_cache(SCHEME_OBJECT cache , SCHEME_OBJECT block , unsigned long offset ) 
{ 


  {
#line 1844
  *((SCHEME_OBJECT *)(block & 288230376151711743UL) + offset) = (SCHEME_OBJECT )((SCHEME_OBJECT *)(cache & 288230376151711743UL));
#line 1845
  return;
}
}
#line 1849 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
SCHEME_OBJECT read_uuo_link(SCHEME_OBJECT block , unsigned long offset ) 
{ 
  insn_t *tmp ;

  {
  {
#line 1852
  tmp = read_uuo_target_no_reloc((SCHEME_OBJECT *)(block & 288230376151711743UL) + offset);
  }
#line 1852
  return ((40UL << 58U) | (SCHEME_OBJECT )((SCHEME_OBJECT *)tmp));
}
}
#line 1856 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
static void write_uuo_link(SCHEME_OBJECT target , SCHEME_OBJECT *cache_address ) 
{ 


  {
  {
#line 1859
  write_uuo_target((insn_t *)((SCHEME_OBJECT *)(target & 288230376151711743UL)), cache_address);
  }
#line 1867
  return;
}
}
#line 1869 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
SCHEME_OBJECT *compiled_closure_objects(SCHEME_OBJECT *block ) 
{ 
  insn_t *start ;
  insn_t *tmp ;
  unsigned long count ;
  unsigned long tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;

  {
  {
#line 1872
  tmp = compiled_closure_start(block);
#line 1872
  start = tmp;
#line 1873
  tmp___0 = compiled_closure_count(block);
#line 1873
  count = tmp___0;
  }
  {
#line 1876
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1876
    if (! (count > 0UL)) {
#line 1876
      goto while_break;
    }
    {
#line 1878
    start = compiled_closure_next(start);
#line 1879
    count --;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1883
  tmp___1 = skip_compiled_closure_padding(start);
  }
#line 1883
  return (tmp___1);
}
}
#line 1886 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
_Bool decode_old_style_format_word(cc_entry_type_t *cet , unsigned short fw ) 
{ 
  uint16_t low ;
  uint16_t high ;
  _Bool rest_p ;

  {
#line 1889
  low = (uint16_t )((int )fw & 255);
#line 1890
  high = (uint16_t )(((int )fw & 65280) >> 8);
#line 1891
  rest_p = (_Bool)0;
#line 1893
  if ((int )high < 128) {
#line 1895
    if ((int )high == 0) {
#line 1898
      return ((_Bool)1);
    } else
#line 1895
    if ((int )low == 0) {
#line 1898
      return ((_Bool)1);
    } else
#line 1895
    if ((int )low == 128) {
#line 1898
      return ((_Bool)1);
    }
#line 1899
    if ((int )low > 128) {
#line 1901
      low = (uint16_t )(255 - (int )low);
#line 1902
      rest_p = (_Bool)1;
    }
#line 1904
    if (! ((int )high <= (int )low)) {
#line 1905
      return ((_Bool)1);
    }
    {
#line 1906
    make_compiled_procedure_type(cet, (unsigned int )((int )high - 1), (unsigned int )((int )low - (int )high),
                                 rest_p);
    }
#line 1907
    return ((_Bool)0);
  }
#line 1909
  if ((int )low < 128) {
#line 1910
    return ((_Bool)1);
  }
#line 1911
  if ((int )low < 224) {
    {
#line 1913
    make_compiled_continuation_type(cet, (unsigned long )((((int )low & 127) << 7) | ((int )high & 127)));
    }
#line 1916
    return ((_Bool)0);
  }
#line 1918
  if ((int )high != 255) {
#line 1919
    return ((_Bool)1);
  }
  {
#line 1922
  if ((int )low == 255) {
#line 1922
    goto case_255;
  }
#line 1925
  if ((int )low == 254) {
#line 1925
    goto case_254;
  }
#line 1928
  if ((int )low == 253) {
#line 1928
    goto case_253;
  }
#line 1931
  if ((int )low == 252) {
#line 1931
    goto case_252;
  }
#line 1934
  if ((int )low == 251) {
#line 1934
    goto case_251;
  }
#line 1937
  if ((int )low == 250) {
#line 1937
    goto case_250;
  }
#line 1940
  goto switch_default;
  case_255: /* CIL Label */ 
  {
#line 1923
  make_cc_entry_type(cet, (cc_entry_type_marker_t )2);
  }
#line 1924
  goto switch_break;
  case_254: /* CIL Label */ 
  {
#line 1926
  make_cc_entry_type(cet, (cc_entry_type_marker_t )3);
  }
#line 1927
  goto switch_break;
  case_253: /* CIL Label */ 
  {
#line 1929
  make_cc_entry_type(cet, (cc_entry_type_marker_t )5);
  }
#line 1930
  goto switch_break;
  case_252: /* CIL Label */ 
  {
#line 1932
  make_cc_entry_type(cet, (cc_entry_type_marker_t )4);
  }
#line 1933
  goto switch_break;
  case_251: /* CIL Label */ 
  {
#line 1935
  make_cc_entry_type(cet, (cc_entry_type_marker_t )6);
  }
#line 1936
  goto switch_break;
  case_250: /* CIL Label */ 
  {
#line 1938
  make_cc_entry_type(cet, (cc_entry_type_marker_t )7);
  }
#line 1939
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1941
  return ((_Bool)1);
  switch_break: /* CIL Label */ ;
  }
#line 1943
  return ((_Bool)0);
}
}
#line 1946 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
_Bool encode_old_style_format_word(cc_entry_type_t *cet , unsigned short *fw_r ) 
{ 
  unsigned int low ;
  unsigned int high ;
  unsigned long n ;

  {
  {
#line 1954
  if ((unsigned int )cet->marker == 0U) {
#line 1954
    goto case_0;
  }
#line 1963
  if ((unsigned int )cet->marker == 1U) {
#line 1963
    goto case_1;
  }
#line 1973
  if ((unsigned int )cet->marker == 2U) {
#line 1973
    goto case_2;
  }
#line 1978
  if ((unsigned int )cet->marker == 3U) {
#line 1978
    goto case_3;
  }
#line 1983
  if ((unsigned int )cet->marker == 5U) {
#line 1983
    goto case_5;
  }
#line 1988
  if ((unsigned int )cet->marker == 4U) {
#line 1988
    goto case_4;
  }
#line 1993
  if ((unsigned int )cet->marker == 6U) {
#line 1993
    goto case_6;
  }
#line 1998
  if ((unsigned int )cet->marker == 7U) {
#line 1998
    goto case_7;
  }
#line 2003
  goto switch_default;
  case_0: /* CIL Label */ 
#line 1955
  high = cet->args.for_procedure.n_required + 1U;
#line 1956
  low = high + cet->args.for_procedure.n_optional;
#line 1957
  if (! (low < 128U)) {
#line 1958
    return ((_Bool)1);
  }
#line 1959
  if (cet->args.for_procedure.rest_p) {
#line 1960
    low = 255U - low;
  }
#line 1961
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1965
  n = cet->args.for_continuation.offset;
#line 1966
  if (! (n < 12288UL)) {
#line 1967
    return ((_Bool)1);
  }
#line 1968
  high = (unsigned int )((n & 127UL) | 128UL);
#line 1969
  low = (unsigned int )((n >> 7) | 128UL);
#line 1971
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1974
  low = 255U;
#line 1975
  high = 255U;
#line 1976
  goto switch_break;
  case_3: /* CIL Label */ 
#line 1979
  low = 254U;
#line 1980
  high = 255U;
#line 1981
  goto switch_break;
  case_5: /* CIL Label */ 
#line 1984
  low = 253U;
#line 1985
  high = 255U;
#line 1986
  goto switch_break;
  case_4: /* CIL Label */ 
#line 1989
  low = 252U;
#line 1990
  high = 255U;
#line 1991
  goto switch_break;
  case_6: /* CIL Label */ 
#line 1994
  low = 251U;
#line 1995
  high = 255U;
#line 1996
  goto switch_break;
  case_7: /* CIL Label */ 
#line 1999
  low = 250U;
#line 2000
  high = 255U;
#line 2001
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 2004
  return ((_Bool)1);
  switch_break: /* CIL Label */ ;
  }
#line 2006
  *fw_r = (unsigned short )((high << 8) | low);
#line 2007
  return ((_Bool)0);
}
}
#line 2051 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
void comutil_return_to_interpreter(utility_result_t *DSU_result , unsigned long TRAMP_store_raw ,
                                   unsigned long ignore2 , unsigned long ignore3 ,
                                   unsigned long ignore4 ) 
{ 


  {
  {
#line 2053
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2053
    DSU_result->interface_dispatch = (void *)(& interface_to_C);
#line 2053
    DSU_result->extra.code_to_interpreter = -1L;
#line 2053
    return;
#line 2053
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2054
  return;
}
}
#line 2056 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
void comutil_reflect_to_interface(utility_result_t *DSU_result , unsigned long TRAMP_store_raw ,
                                  unsigned long ignore2 , unsigned long ignore3 ,
                                  unsigned long ignore4 ) 
{ 
  SCHEME_OBJECT code ;
  SCHEME_OBJECT *tmp ;
  unsigned long frame_size ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT procedure ;
  SCHEME_OBJECT *tmp___1 ;
  SCHEME_OBJECT *tmp___2 ;
  SCHEME_OBJECT *tmp___3 ;
  SCHEME_OBJECT *tmp___4 ;
  SCHEME_OBJECT *tmp___5 ;
  SCHEME_OBJECT *tmp___6 ;
  SCHEME_OBJECT *tmp___7 ;
  SCHEME_OBJECT *tmp___8 ;
  SCHEME_OBJECT *tmp___9 ;
  insn_t *addr ;
  long code___0 ;
  long tmp___10 ;

  {
#line 2058
  tmp = stack_pointer;
#line 2058
  stack_pointer ++;
#line 2058
  code = *tmp;
  {
#line 2062
  if ((code & 288230376151711743UL) == 0UL) {
#line 2062
    goto case_0;
  }
#line 2069
  if ((code & 288230376151711743UL) == 1UL) {
#line 2069
    goto case_1;
  }
#line 2073
  if ((code & 288230376151711743UL) == 2UL) {
#line 2073
    goto case_2;
  }
#line 2078
  if ((code & 288230376151711743UL) == 3UL) {
#line 2078
    goto case_3;
  }
#line 2097
  goto switch_default;
  case_0: /* CIL Label */ 
#line 2064
  tmp___0 = stack_pointer;
#line 2064
  stack_pointer ++;
#line 2064
  frame_size = *tmp___0 & 288230376151711743UL;
#line 2065
  tmp___1 = stack_pointer;
#line 2065
  stack_pointer ++;
#line 2065
  procedure = *tmp___1;
  {
#line 2066
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2066
    comutil_apply(DSU_result, procedure, frame_size, 0UL, 0UL);
    }
#line 2066
    return;
#line 2066
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  case_1: /* CIL Label */ 
  {
#line 2070
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 2070
    tmp___2 = stack_pointer;
#line 2070
    stack_pointer ++;
#line 2070
    set_ulong_register(1U, *tmp___2 & 288230376151711743UL);
    }
    {
#line 2070
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2070
      if ((Registers[1] & Registers[12]) != 0UL) {
#line 2070
        tmp___4 = memory_block_start;
      } else {
#line 2070
        if ((Registers[1] & 4UL) != 0UL) {
#line 2070
          tmp___3 = heap_alloc_limit;
        } else {
#line 2070
          tmp___3 = heap_end;
        }
#line 2070
        tmp___4 = tmp___3;
      }
      {
#line 2070
      set_ptr_register(0U, tmp___4);
      }
#line 2070
      if ((Registers[1] & 1UL) != 0UL) {
#line 2070
        tmp___5 = stack_guard;
      } else {
#line 2070
        tmp___5 = stack_start;
      }
      {
#line 2070
      set_ptr_register(11U, tmp___5);
      }
#line 2070
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2070
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2071
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2071
    if ((unsigned long )Free >= (unsigned long )((SCHEME_OBJECT *)Registers[0])) {
      {
#line 2071
      compiler_interrupt_common(DSU_result, (insn_t *)0, Registers[2]);
      }
#line 2071
      return;
    }
    {
#line 2071
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 2071
      DSU_result->interface_dispatch = (void *)(& interface_to_scheme);
#line 2071
      tmp___6 = stack_pointer;
#line 2071
      stack_pointer ++;
#line 2071
      DSU_result->extra.entry_point = (insn_t *)((SCHEME_OBJECT *)(*tmp___6 & 288230376151711743UL));
#line 2071
      return;
#line 2071
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 2071
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  case_2: /* CIL Label */ 
#line 2074
  tmp___7 = stack_pointer;
#line 2074
  stack_pointer ++;
#line 2075
  tmp___8 = stack_pointer;
#line 2075
  stack_pointer ++;
  {
#line 2076
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 2076
    if ((unsigned long )Free >= (unsigned long )((SCHEME_OBJECT *)Registers[0])) {
      {
#line 2076
      compiler_interrupt_common(DSU_result, (insn_t *)0, Registers[2]);
      }
#line 2076
      return;
    }
    {
#line 2076
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 2076
      DSU_result->interface_dispatch = (void *)(& interface_to_scheme);
#line 2076
      tmp___9 = stack_pointer;
#line 2076
      stack_pointer ++;
#line 2076
      DSU_result->extra.entry_point = (insn_t *)((SCHEME_OBJECT *)(*tmp___9 & 288230376151711743UL));
#line 2076
      return;
#line 2076
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 2076
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  case_3: /* CIL Label */ 
#line 2080
  if ((unsigned long )Free >= (unsigned long )((SCHEME_OBJECT *)Registers[0])) {
    {
#line 2082
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 2082
      stack_pointer --;
#line 2082
      *stack_pointer = (26UL << 58U) | 3UL;
#line 2082
      stack_pointer --;
#line 2082
      *stack_pointer = reflect_to_interface;
#line 2082
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
    {
#line 2083
    compiler_interrupt_common(DSU_result, (insn_t *)0, 0UL);
    }
#line 2084
    return;
  }
  {
#line 2088
  tmp___10 = do_bkpt_proceed(& addr);
#line 2088
  code___0 = tmp___10;
  }
#line 2089
  if (code___0 != -1L) {
#line 2091
    stack_pointer --;
#line 2091
    *stack_pointer = (SCHEME_OBJECT )code___0;
    {
#line 2092
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 2092
      DSU_result->interface_dispatch = (void *)(& interface_to_C);
#line 2092
      DSU_result->extra.code_to_interpreter = code___0;
#line 2092
      return;
#line 2092
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
  }
  {
#line 2094
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 2094
    DSU_result->interface_dispatch = (void *)(& interface_to_scheme);
#line 2094
    DSU_result->extra.entry_point = addr;
#line 2094
    return;
#line 2094
    goto while_break___8;
  }
  while_break___8: /* CIL Label */ ;
  }
  switch_default: /* CIL Label */ 
#line 2098
  stack_pointer --;
#line 2098
  *stack_pointer = code;
  {
#line 2099
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 2099
    DSU_result->interface_dispatch = (void *)(& interface_to_C);
#line 2099
    DSU_result->extra.code_to_interpreter = 10L;
#line 2099
    return;
#line 2099
    goto while_break___9;
  }
  while_break___9: /* CIL Label */ ;
  }
  switch_break: /* CIL Label */ ;
  }
#line 2101
  return;
}
}
#line 2103 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
void comutil_operator_apply_trap(utility_result_t *DSU_result , unsigned long TRAMP_store_raw ,
                                 unsigned long ignore2 , unsigned long ignore3 , unsigned long ignore4 ) 
{ 
  SCHEME_OBJECT *TRAMP_store ;
  SCHEME_OBJECT procedure ;
  SCHEME_OBJECT frame_header ;

  {
#line 2105
  TRAMP_store = (SCHEME_OBJECT *)TRAMP_store_raw;
#line 2105
  procedure = *(TRAMP_store + 0);
#line 2105
  frame_header = *(TRAMP_store + 1);
  {
#line 2106
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2106
    comutil_apply(DSU_result, procedure, frame_header & 288230376151711743UL, 0UL,
                  0UL);
    }
#line 2106
    return;
#line 2106
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2107
  return;
}
}
#line 2109 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
void comutil_operator_primitive_trap(utility_result_t *DSU_result , unsigned long TRAMP_store_raw ,
                                     unsigned long ignore2 , unsigned long ignore3 ,
                                     unsigned long ignore4 ) 
{ 
  SCHEME_OBJECT *TRAMP_store ;
  SCHEME_OBJECT primitive ;

  {
#line 2111
  TRAMP_store = (SCHEME_OBJECT *)TRAMP_store_raw;
#line 2111
  primitive = *(TRAMP_store + 0);
  {
#line 2112
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2112
    comutil_primitive_apply(DSU_result, primitive, 0UL, 0UL, 0UL);
    }
#line 2112
    return;
#line 2112
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2113
  return;
}
}
#line 2115 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
void comutil_operator_lexpr_trap(utility_result_t *DSU_result , unsigned long TRAMP_store_raw ,
                                 unsigned long ignore2 , unsigned long ignore3 , unsigned long ignore4 ) 
{ 
  SCHEME_OBJECT *TRAMP_store ;
  SCHEME_OBJECT procedure ;
  SCHEME_OBJECT frame_header ;

  {
  {
#line 2117
  TRAMP_store = (SCHEME_OBJECT *)TRAMP_store_raw;
#line 2117
  procedure = *(TRAMP_store + 0);
#line 2117
  frame_header = *(TRAMP_store + 1);
#line 2118
  set_ulong_register(7U, (frame_header & 288230376151711743UL) - 1UL);
  }
  {
#line 2119
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2119
    comutil_primitive_lexpr_apply(DSU_result, procedure, 0UL, 0UL, 0UL);
    }
#line 2119
    return;
#line 2119
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2120
  return;
}
}
#line 2129 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
void comutil_operator_1_0_trap(utility_result_t *DSU_result , unsigned long TRAMP_store_raw ,
                               unsigned long ignore2 , unsigned long ignore3 , unsigned long ignore4 ) 
{ 
  SCHEME_OBJECT *TRAMP_store ;
  SCHEME_OBJECT procedure ;

  {
#line 2131
  TRAMP_store = (SCHEME_OBJECT *)TRAMP_store_raw;
#line 2131
  procedure = *(TRAMP_store + 0);
#line 2132
  stack_pointer --;
#line 2132
  *stack_pointer = (8UL << 58U) | 7UL;
  {
#line 2133
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2133
    DSU_result->interface_dispatch = (void *)(& interface_to_scheme);
#line 2133
    DSU_result->extra.entry_point = (insn_t *)((SCHEME_OBJECT *)(procedure & 288230376151711743UL));
#line 2133
    return;
#line 2133
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2134
  return;
}
}
#line 2136 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
void comutil_operator_2_0_trap(utility_result_t *DSU_result , unsigned long TRAMP_store_raw ,
                               unsigned long ignore2 , unsigned long ignore3 , unsigned long ignore4 ) 
{ 
  SCHEME_OBJECT *TRAMP_store ;
  SCHEME_OBJECT procedure ;

  {
#line 2138
  TRAMP_store = (SCHEME_OBJECT *)TRAMP_store_raw;
#line 2138
  procedure = *(TRAMP_store + 0);
#line 2139
  stack_pointer --;
#line 2139
  *stack_pointer = (8UL << 58U) | 7UL;
#line 2140
  stack_pointer --;
#line 2140
  *stack_pointer = (8UL << 58U) | 7UL;
  {
#line 2141
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2141
    DSU_result->interface_dispatch = (void *)(& interface_to_scheme);
#line 2141
    DSU_result->extra.entry_point = (insn_t *)((SCHEME_OBJECT *)(procedure & 288230376151711743UL));
#line 2141
    return;
#line 2141
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2142
  return;
}
}
#line 2144 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
void comutil_operator_2_1_trap(utility_result_t *DSU_result , unsigned long TRAMP_store_raw ,
                               unsigned long ignore2 , unsigned long ignore3 , unsigned long ignore4 ) 
{ 
  SCHEME_OBJECT *TRAMP_store ;
  SCHEME_OBJECT procedure ;
  SCHEME_OBJECT a1 ;
  SCHEME_OBJECT *tmp ;

  {
#line 2146
  TRAMP_store = (SCHEME_OBJECT *)TRAMP_store_raw;
#line 2146
  procedure = *(TRAMP_store + 0);
#line 2148
  tmp = stack_pointer;
#line 2148
  stack_pointer ++;
#line 2148
  a1 = *tmp;
#line 2149
  stack_pointer --;
#line 2149
  *stack_pointer = (8UL << 58U) | 7UL;
#line 2150
  stack_pointer --;
#line 2150
  *stack_pointer = a1;
  {
#line 2152
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2152
    DSU_result->interface_dispatch = (void *)(& interface_to_scheme);
#line 2152
    DSU_result->extra.entry_point = (insn_t *)((SCHEME_OBJECT *)(procedure & 288230376151711743UL));
#line 2152
    return;
#line 2152
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2153
  return;
}
}
#line 2155 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
void comutil_operator_3_0_trap(utility_result_t *DSU_result , unsigned long TRAMP_store_raw ,
                               unsigned long ignore2 , unsigned long ignore3 , unsigned long ignore4 ) 
{ 
  SCHEME_OBJECT *TRAMP_store ;
  SCHEME_OBJECT procedure ;

  {
#line 2157
  TRAMP_store = (SCHEME_OBJECT *)TRAMP_store_raw;
#line 2157
  procedure = *(TRAMP_store + 0);
#line 2158
  stack_pointer --;
#line 2158
  *stack_pointer = (8UL << 58U) | 7UL;
#line 2159
  stack_pointer --;
#line 2159
  *stack_pointer = (8UL << 58U) | 7UL;
#line 2160
  stack_pointer --;
#line 2160
  *stack_pointer = (8UL << 58U) | 7UL;
  {
#line 2161
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2161
    DSU_result->interface_dispatch = (void *)(& interface_to_scheme);
#line 2161
    DSU_result->extra.entry_point = (insn_t *)((SCHEME_OBJECT *)(procedure & 288230376151711743UL));
#line 2161
    return;
#line 2161
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2162
  return;
}
}
#line 2164 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
void comutil_operator_3_1_trap(utility_result_t *DSU_result , unsigned long TRAMP_store_raw ,
                               unsigned long ignore2 , unsigned long ignore3 , unsigned long ignore4 ) 
{ 
  SCHEME_OBJECT *TRAMP_store ;
  SCHEME_OBJECT procedure ;
  SCHEME_OBJECT a1 ;
  SCHEME_OBJECT *tmp ;

  {
#line 2166
  TRAMP_store = (SCHEME_OBJECT *)TRAMP_store_raw;
#line 2166
  procedure = *(TRAMP_store + 0);
#line 2168
  tmp = stack_pointer;
#line 2168
  stack_pointer ++;
#line 2168
  a1 = *tmp;
#line 2169
  stack_pointer --;
#line 2169
  *stack_pointer = (8UL << 58U) | 7UL;
#line 2170
  stack_pointer --;
#line 2170
  *stack_pointer = (8UL << 58U) | 7UL;
#line 2171
  stack_pointer --;
#line 2171
  *stack_pointer = a1;
  {
#line 2173
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2173
    DSU_result->interface_dispatch = (void *)(& interface_to_scheme);
#line 2173
    DSU_result->extra.entry_point = (insn_t *)((SCHEME_OBJECT *)(procedure & 288230376151711743UL));
#line 2173
    return;
#line 2173
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2174
  return;
}
}
#line 2176 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
void comutil_operator_3_2_trap(utility_result_t *DSU_result , unsigned long TRAMP_store_raw ,
                               unsigned long ignore2 , unsigned long ignore3 , unsigned long ignore4 ) 
{ 
  SCHEME_OBJECT *TRAMP_store ;
  SCHEME_OBJECT procedure ;
  SCHEME_OBJECT a1 ;
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT a2 ;
  SCHEME_OBJECT *tmp___0 ;

  {
#line 2178
  TRAMP_store = (SCHEME_OBJECT *)TRAMP_store_raw;
#line 2178
  procedure = *(TRAMP_store + 0);
#line 2180
  tmp = stack_pointer;
#line 2180
  stack_pointer ++;
#line 2180
  a1 = *tmp;
#line 2181
  tmp___0 = stack_pointer;
#line 2181
  stack_pointer ++;
#line 2181
  a2 = *tmp___0;
#line 2182
  stack_pointer --;
#line 2182
  *stack_pointer = (8UL << 58U) | 7UL;
#line 2183
  stack_pointer --;
#line 2183
  *stack_pointer = a2;
#line 2184
  stack_pointer --;
#line 2184
  *stack_pointer = a1;
  {
#line 2186
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2186
    DSU_result->interface_dispatch = (void *)(& interface_to_scheme);
#line 2186
    DSU_result->extra.entry_point = (insn_t *)((SCHEME_OBJECT *)(procedure & 288230376151711743UL));
#line 2186
    return;
#line 2186
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2187
  return;
}
}
#line 2189 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
void comutil_operator_4_0_trap(utility_result_t *DSU_result , unsigned long TRAMP_store_raw ,
                               unsigned long ignore2 , unsigned long ignore3 , unsigned long ignore4 ) 
{ 
  SCHEME_OBJECT *TRAMP_store ;
  SCHEME_OBJECT procedure ;

  {
#line 2191
  TRAMP_store = (SCHEME_OBJECT *)TRAMP_store_raw;
#line 2191
  procedure = *(TRAMP_store + 0);
#line 2192
  stack_pointer --;
#line 2192
  *stack_pointer = (8UL << 58U) | 7UL;
#line 2193
  stack_pointer --;
#line 2193
  *stack_pointer = (8UL << 58U) | 7UL;
#line 2194
  stack_pointer --;
#line 2194
  *stack_pointer = (8UL << 58U) | 7UL;
#line 2195
  stack_pointer --;
#line 2195
  *stack_pointer = (8UL << 58U) | 7UL;
  {
#line 2196
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2196
    DSU_result->interface_dispatch = (void *)(& interface_to_scheme);
#line 2196
    DSU_result->extra.entry_point = (insn_t *)((SCHEME_OBJECT *)(procedure & 288230376151711743UL));
#line 2196
    return;
#line 2196
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2197
  return;
}
}
#line 2199 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
void comutil_operator_4_1_trap(utility_result_t *DSU_result , unsigned long TRAMP_store_raw ,
                               unsigned long ignore2 , unsigned long ignore3 , unsigned long ignore4 ) 
{ 
  SCHEME_OBJECT *TRAMP_store ;
  SCHEME_OBJECT procedure ;
  SCHEME_OBJECT a1 ;
  SCHEME_OBJECT *tmp ;

  {
#line 2201
  TRAMP_store = (SCHEME_OBJECT *)TRAMP_store_raw;
#line 2201
  procedure = *(TRAMP_store + 0);
#line 2203
  tmp = stack_pointer;
#line 2203
  stack_pointer ++;
#line 2203
  a1 = *tmp;
#line 2204
  stack_pointer --;
#line 2204
  *stack_pointer = (8UL << 58U) | 7UL;
#line 2205
  stack_pointer --;
#line 2205
  *stack_pointer = (8UL << 58U) | 7UL;
#line 2206
  stack_pointer --;
#line 2206
  *stack_pointer = (8UL << 58U) | 7UL;
#line 2207
  stack_pointer --;
#line 2207
  *stack_pointer = a1;
  {
#line 2209
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2209
    DSU_result->interface_dispatch = (void *)(& interface_to_scheme);
#line 2209
    DSU_result->extra.entry_point = (insn_t *)((SCHEME_OBJECT *)(procedure & 288230376151711743UL));
#line 2209
    return;
#line 2209
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2210
  return;
}
}
#line 2212 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
void comutil_operator_4_2_trap(utility_result_t *DSU_result , unsigned long TRAMP_store_raw ,
                               unsigned long ignore2 , unsigned long ignore3 , unsigned long ignore4 ) 
{ 
  SCHEME_OBJECT *TRAMP_store ;
  SCHEME_OBJECT procedure ;
  SCHEME_OBJECT a1 ;
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT a2 ;
  SCHEME_OBJECT *tmp___0 ;

  {
#line 2214
  TRAMP_store = (SCHEME_OBJECT *)TRAMP_store_raw;
#line 2214
  procedure = *(TRAMP_store + 0);
#line 2216
  tmp = stack_pointer;
#line 2216
  stack_pointer ++;
#line 2216
  a1 = *tmp;
#line 2217
  tmp___0 = stack_pointer;
#line 2217
  stack_pointer ++;
#line 2217
  a2 = *tmp___0;
#line 2218
  stack_pointer --;
#line 2218
  *stack_pointer = (8UL << 58U) | 7UL;
#line 2219
  stack_pointer --;
#line 2219
  *stack_pointer = (8UL << 58U) | 7UL;
#line 2220
  stack_pointer --;
#line 2220
  *stack_pointer = a2;
#line 2221
  stack_pointer --;
#line 2221
  *stack_pointer = a1;
  {
#line 2223
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2223
    DSU_result->interface_dispatch = (void *)(& interface_to_scheme);
#line 2223
    DSU_result->extra.entry_point = (insn_t *)((SCHEME_OBJECT *)(procedure & 288230376151711743UL));
#line 2223
    return;
#line 2223
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2224
  return;
}
}
#line 2226 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
void comutil_operator_4_3_trap(utility_result_t *DSU_result , unsigned long TRAMP_store_raw ,
                               unsigned long ignore2 , unsigned long ignore3 , unsigned long ignore4 ) 
{ 
  SCHEME_OBJECT *TRAMP_store ;
  SCHEME_OBJECT procedure ;
  SCHEME_OBJECT a1 ;
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT a2 ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT a3 ;
  SCHEME_OBJECT *tmp___1 ;

  {
#line 2228
  TRAMP_store = (SCHEME_OBJECT *)TRAMP_store_raw;
#line 2228
  procedure = *(TRAMP_store + 0);
#line 2230
  tmp = stack_pointer;
#line 2230
  stack_pointer ++;
#line 2230
  a1 = *tmp;
#line 2231
  tmp___0 = stack_pointer;
#line 2231
  stack_pointer ++;
#line 2231
  a2 = *tmp___0;
#line 2232
  tmp___1 = stack_pointer;
#line 2232
  stack_pointer ++;
#line 2232
  a3 = *tmp___1;
#line 2233
  stack_pointer --;
#line 2233
  *stack_pointer = (8UL << 58U) | 7UL;
#line 2234
  stack_pointer --;
#line 2234
  *stack_pointer = a3;
#line 2235
  stack_pointer --;
#line 2235
  *stack_pointer = a2;
#line 2236
  stack_pointer --;
#line 2236
  *stack_pointer = a1;
  {
#line 2238
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2238
    DSU_result->interface_dispatch = (void *)(& interface_to_scheme);
#line 2238
    DSU_result->extra.entry_point = (insn_t *)((SCHEME_OBJECT *)(procedure & 288230376151711743UL));
#line 2238
    return;
#line 2238
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2239
  return;
}
}
#line 2250 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
void comutil_operator_lookup_trap(utility_result_t *DSU_result , unsigned long TRAMP_store_raw ,
                                  unsigned long ignore2 , unsigned long ignore3 ,
                                  unsigned long ignore4 ) 
{ 
  SCHEME_OBJECT *TRAMP_store ;
  SCHEME_OBJECT cache ;
  SCHEME_OBJECT block ;
  SCHEME_OBJECT offset ;
  SCHEME_OBJECT *cache_addr ;
  unsigned long frame_size ;
  unsigned int tmp ;
  SCHEME_OBJECT procedure ;
  long code ;
  long tmp___0 ;
  insn_t *tmp___1 ;
  long SLRC_offset ;

  {
  {
#line 2252
  TRAMP_store = (SCHEME_OBJECT *)TRAMP_store_raw;
#line 2252
  cache = *(TRAMP_store + 0);
#line 2252
  block = *(TRAMP_store + 1);
#line 2252
  offset = *(TRAMP_store + 2);
#line 2253
  cache_addr = (SCHEME_OBJECT *)(block & 288230376151711743UL) + (offset & 288230376151711743UL);
#line 2254
  tmp = read_uuo_frame_size(cache_addr);
#line 2254
  frame_size = (unsigned long )tmp;
#line 2256
  tmp___0 = compiler_operator_reference_trap(cache, & procedure);
#line 2256
  code = tmp___0;
  }
#line 2257
  if (code != -1L) {
    {
#line 2259
    stack_pointer --;
#line 2259
    tmp___1 = read_uuo_target_no_reloc(cache_addr);
#line 2259
    *stack_pointer = (40UL << 58U) | (SCHEME_OBJECT )((SCHEME_OBJECT *)tmp___1);
#line 2261
    stack_pointer --;
#line 2261
    *stack_pointer = (26UL << 58U) | frame_size;
#line 2262
    stack_pointer --;
#line 2262
    *stack_pointer = cc_block_environment(block);
#line 2263
    stack_pointer --;
#line 2263
    *stack_pointer = compiler_var_error(cache, block, 2U);
    }
    {
#line 2265
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 2265
      SLRC_offset = last_return_code - stack_pointer;
#line 2265
      stack_pointer --;
#line 2265
      *stack_pointer = (26UL << 58U) | ((unsigned long )SLRC_offset & 288230376151711743UL);
#line 2265
      stack_pointer --;
#line 2265
      *stack_pointer = (11UL << 58U) | 86UL;
#line 2265
      compiler_new_subproblem();
      }
#line 2265
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 2266
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2266
      DSU_result->interface_dispatch = (void *)(& interface_to_C);
#line 2266
      DSU_result->extra.code_to_interpreter = code;
#line 2266
      return;
#line 2266
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 2268
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 2268
    comutil_apply(DSU_result, procedure, frame_size, 0UL, 0UL);
    }
#line 2268
    return;
#line 2268
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2269
  return;
}
}
#line 2275 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
long comp_op_lookup_trap_restart(void) 
{ 
  SCHEME_OBJECT *store ;
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;
  SCHEME_OBJECT block ;
  unsigned long offset ;
  insn_t *tmp___2 ;
  long tmp___3 ;

  {
  {
#line 2277
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2277
    last_return_code = stack_pointer + (Registers[5] & 288230376151711743UL);
    {
#line 2277
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2277
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 2277
    end_subproblem();
    }
#line 2277
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2279
  stack_pointer += 3;
#line 2281
  tmp = stack_pointer;
#line 2281
  stack_pointer ++;
#line 2281
  tmp___0 = cc_entry_to_block_address(*tmp);
#line 2281
  tmp___1 = trampoline_storage(tmp___0);
#line 2281
  store = tmp___1;
#line 2283
  block = *(store + 1);
#line 2284
  offset = *(store + 2) & 288230376151711743UL;
#line 2285
  tmp___2 = read_uuo_target_no_reloc((SCHEME_OBJECT *)(block & 288230376151711743UL) + offset);
#line 2285
  tmp___3 = C_to_interface(tmp___2);
  }
#line 2285
  return (tmp___3);
}
}
#line 2292 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
long make_uuo_link(SCHEME_OBJECT procedure , SCHEME_OBJECT cache , SCHEME_OBJECT block ,
                   unsigned long offset ) 
{ 
  SCHEME_OBJECT *cache_address ;
  unsigned long frame_size ;
  unsigned int tmp ;
  trampoline_type_t kind ;
  long result ;
  SCHEME_OBJECT trampoline ;
  long tmp___0 ;
  insn_t *entry ;
  unsigned long nargs ;
  cc_entry_type_t cet ;
  unsigned long nmin ;
  unsigned long nmax ;
  _Bool tmp___1 ;
  SCHEME_OBJECT data ;
  long arity ;
  long tmp___2 ;
  long tmp___3 ;

  {
  {
#line 2298
  cache_address = (SCHEME_OBJECT *)(block & 288230376151711743UL) + offset;
#line 2299
  tmp = read_uuo_frame_size(cache_address);
#line 2299
  frame_size = (unsigned long )tmp;
  }
#line 2304
  if (procedure >> 58U == 50UL) {
    {
#line 2305
    tmp___0 = make_fake_uuo_link(cache, block, offset);
    }
#line 2305
    return (tmp___0);
  }
  loop: 
  {
#line 2310
  if (procedure >> 58U == 40UL) {
#line 2310
    goto case_40;
  }
#line 2349
  if (procedure >> 58U == 16UL) {
#line 2349
    goto case_16;
  }
#line 2365
  if (procedure >> 58U == 24UL) {
#line 2365
    goto case_24;
  }
#line 2380
  goto switch_default;
  case_40: /* CIL Label */ 
  {
#line 2312
  entry = (insn_t *)((SCHEME_OBJECT *)(procedure & 288230376151711743UL));
#line 2313
  nargs = frame_size - 1UL;
#line 2318
  tmp___1 = read_cc_entry_type(& cet, entry);
  }
#line 2318
  if (tmp___1) {
#line 2320
    return (49L);
  } else
#line 2318
  if ((unsigned int )cet.marker != 0U) {
#line 2320
    return (49L);
  }
#line 2321
  nmin = (unsigned long )cet.args.for_procedure.n_required;
#line 2322
  nmax = nmin + (unsigned long )cet.args.for_procedure.n_optional;
#line 2323
  if (cet.args.for_procedure.rest_p) {
#line 2324
    kind = (trampoline_type_t )1;
  } else
#line 2325
  if (nargs == nmax) {
    {
#line 2328
    write_uuo_link(procedure, cache_address);
    }
#line 2329
    return (-1L);
  } else
#line 2331
  if (nargs < nmax) {
#line 2331
    if (nargs >= nmin) {
#line 2331
      if (nmin < nmax) {
#line 2331
        if (nmax <= 4UL) {
#line 2337
          kind = trampoline_arity_table[(nmax - 1UL) * 4UL + nargs];
#line 2341
          frame_size = 0UL;
        } else {
#line 2345
          kind = (trampoline_type_t )1;
        }
      } else {
#line 2345
        kind = (trampoline_type_t )1;
      }
    } else {
#line 2345
      kind = (trampoline_type_t )1;
    }
  } else {
#line 2345
    kind = (trampoline_type_t )1;
  }
#line 2346
  goto switch_break;
  case_16: /* CIL Label */ 
#line 2351
  data = *((SCHEME_OBJECT *)(procedure & 288230376151711743UL) + 1);
#line 2352
  if (data >> 58U == 10UL) {
#line 2352
    if (frame_size < (*((SCHEME_OBJECT *)(data & 288230376151711743UL) + 0) & 288230376151711743UL)) {
#line 2352
      if (*((SCHEME_OBJECT *)(data & 288230376151711743UL) + (frame_size + 1UL)) != 0UL) {
#line 2352
        if (*((SCHEME_OBJECT *)(data & 288230376151711743UL) + 1) == *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 52)) {
#line 2358
          procedure = *((SCHEME_OBJECT *)(data & 288230376151711743UL) + (frame_size + 1UL));
#line 2359
          goto loop;
        }
      }
    }
  }
#line 2361
  kind = (trampoline_type_t )1;
#line 2362
  goto switch_break;
  case_24: /* CIL Label */ 
#line 2367
  arity = (long )*(Primitive_Arity_Table + (procedure & 288230376151711743UL));
#line 2368
  if (arity == (long )(frame_size - 1UL)) {
#line 2370
    kind = (trampoline_type_t )6;
#line 2371
    frame_size = 0UL;
  } else
#line 2373
  if (arity == -1L) {
#line 2374
    kind = (trampoline_type_t )5;
  } else {
#line 2376
    kind = (trampoline_type_t )1;
  }
#line 2377
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 2381
  kind = (trampoline_type_t )1;
#line 2382
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2384
  if (frame_size == 0UL) {
    {
#line 2384
    tmp___2 = make_redirection_trampoline(& trampoline, kind, procedure);
#line 2384
    result = tmp___2;
    }
  } else {
    {
#line 2384
    tmp___3 = make_apply_trampoline(& trampoline, kind, procedure, frame_size);
#line 2384
    result = tmp___3;
    }
  }
#line 2388
  if (result == -1L) {
    {
#line 2389
    write_uuo_link(trampoline, cache_address);
    }
  }
#line 2390
  return (result);
}
}
#line 2393 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
static long make_fake_uuo_link(SCHEME_OBJECT cache , SCHEME_OBJECT block , unsigned long offset ) 
{ 
  cc_entry_type_t cet ;
  SCHEME_OBJECT trampoline ;
  long result ;
  long tmp ;
  SCHEME_OBJECT *cache_address ;

  {
  {
#line 2401
  make_cc_entry_type(& cet, (cc_entry_type_marker_t )5);
#line 2403
  tmp = make_trampoline(& trampoline, & cet, (trampoline_type_t )7, 3U, cache, block,
                        (26UL << 58U) | offset);
#line 2403
  result = tmp;
  }
#line 2410
  if (result != -1L) {
#line 2411
    return (result);
  }
  {
#line 2414
  cache_address = (SCHEME_OBJECT *)(block & 288230376151711743UL) + offset;
#line 2415
  write_uuo_link(trampoline, cache_address);
  }
#line 2417
  return (-1L);
}
}
#line 2420 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
long coerce_to_compiled(SCHEME_OBJECT procedure , unsigned int arity , SCHEME_OBJECT *location ) 
{ 
  cc_entry_type_t cet ;
  _Bool tmp ;
  long tmp___0 ;

  {
#line 2427
  if (procedure >> 58U == 40UL) {
    {
#line 2429
    tmp = read_cc_entry_type(& cet, (insn_t *)((SCHEME_OBJECT *)(procedure & 288230376151711743UL)));
    }
#line 2429
    if (tmp) {
#line 2430
      return (49L);
    }
#line 2431
    if ((unsigned int )cet.marker == 0U) {
#line 2433
      *location = procedure;
#line 2434
      return (-1L);
    }
  }
  {
#line 2437
  make_compiled_procedure_type(& cet, arity, 0U, (_Bool)0);
#line 2438
  tmp___0 = make_trampoline(location, & cet, (trampoline_type_t )1, 2U, procedure,
                            (26UL << 58U) | (unsigned long )(arity + 1U));
  }
#line 2438
  return (tmp___0);
}
}
#line 2446 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
static long make_trampoline(SCHEME_OBJECT *slot , cc_entry_type_t *cet , trampoline_type_t kind ,
                            unsigned int n_values  , ...) 
{ 
  SCHEME_OBJECT h1 ;
  SCHEME_OBJECT h2 ;
  unsigned long n_words ;
  SCHEME_OBJECT *block ;
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;
  _Bool tmp___2 ;
  SCHEME_OBJECT *p ;
  SCHEME_OBJECT *tmp___3 ;
  va_list ap ;
  SCHEME_OBJECT *tmp___4 ;
  SCHEME_OBJECT tmp___5 ;
  insn_t *tmp___6 ;

  {
  {
#line 2458
  make_trampoline_headers(1UL, (unsigned long )n_values, & h1, & h2, & n_words);
  }
#line 2459
  if ((unsigned long )Free >= (unsigned long )heap_start) {
#line 2459
    if ((unsigned long )Free < (unsigned long )heap_alloc_limit) {
#line 2459
      if (! ((unsigned long )(Free + n_words) <= (unsigned long )heap_alloc_limit)) {
#line 2459
        goto _L___0;
      }
    } else {
#line 2459
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 2459
  if ((Registers[1] & 4UL) != 0UL) {
    {
#line 2461
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 2461
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 2461
        set_ulong_register(12U, Registers[12] | 4UL);
        }
        {
#line 2461
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 2461
          if ((Registers[1] & Registers[12]) != 0UL) {
#line 2461
            tmp___0 = memory_block_start;
          } else {
#line 2461
            if ((Registers[1] & 4UL) != 0UL) {
#line 2461
              tmp = heap_alloc_limit;
            } else {
#line 2461
              tmp = heap_end;
            }
#line 2461
            tmp___0 = tmp;
          }
          {
#line 2461
          set_ptr_register(0U, tmp___0);
          }
#line 2461
          if ((Registers[1] & 1UL) != 0UL) {
#line 2461
            tmp___1 = stack_guard;
          } else {
#line 2461
            tmp___1 = stack_start;
          }
          {
#line 2461
          set_ptr_register(11U, tmp___1);
          }
#line 2461
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 2461
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 2461
      gc_space_needed = n_words;
#line 2461
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 2462
    return (-4L);
  }
  {
#line 2464
  block = Free;
#line 2465
  Free += n_words;
#line 2466
  *(block + 0) = h1;
#line 2467
  *(block + 1) = h2;
#line 2468
  tmp___2 = fill_trampoline(block, 0UL, cet, kind);
  }
#line 2468
  if (tmp___2) {
#line 2469
    return (49L);
  }
  {
#line 2471
  tmp___3 = trampoline_storage(block);
#line 2471
  p = tmp___3;
#line 2474
  __builtin_va_start(ap, n_values);
  }
  {
#line 2475
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2475
    if (! (n_values > 0U)) {
#line 2475
      goto while_break___2;
    }
    {
#line 2477
    tmp___4 = p;
#line 2477
    p ++;
#line 2477
    tmp___5 = __builtin_va_arg(ap, SCHEME_OBJECT );
#line 2477
    *tmp___4 = tmp___5;
#line 2478
    n_values --;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 2480
  __builtin_va_end(ap);
#line 2482
  tmp___6 = trampoline_entry_addr(block, 0UL);
#line 2482
  *slot = (40UL << 58U) | (SCHEME_OBJECT )((SCHEME_OBJECT *)tmp___6);
  }
#line 2483
  return (-1L);
}
}
#line 2486 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
static void make_trampoline_headers(unsigned long n_entries , unsigned long n_store ,
                                    SCHEME_OBJECT *h1_r , SCHEME_OBJECT *h2_r , unsigned long *n_words_r ) 
{ 
  unsigned long n1 ;
  unsigned long tmp ;
  unsigned long n2 ;

  {
  {
#line 2491
  tmp = trampoline_entry_size(n_entries);
#line 2491
  n1 = tmp;
#line 2492
  n2 = (1UL + n1) + n_store;
#line 2493
  *h1_r = (26UL << 58U) | n2;
#line 2494
  *h2_r = (39UL << 58U) | n1;
#line 2495
  *n_words_r = 1UL + n2;
  }
#line 2496
  return;
}
}
#line 2498 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
static _Bool fill_trampoline(SCHEME_OBJECT *block , unsigned long index___0 , cc_entry_type_t *cet ,
                             trampoline_type_t kind ) 
{ 
  insn_t *addr ;
  insn_t *tmp ;
  _Bool tmp___0 ;
  cc_entry_offset_t ceo ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;

  {
  {
#line 2504
  tmp = trampoline_entry_addr(block, index___0);
#line 2504
  addr = tmp;
#line 2505
  tmp___0 = write_cc_entry_type(cet, addr);
  }
#line 2505
  if (tmp___0) {
#line 2506
    return ((_Bool)1);
  }
  {
#line 2509
  ceo.offset = (unsigned long )(addr - (insn_t *)block);
#line 2510
  ceo.continued_p = (_Bool)0;
#line 2511
  tmp___1 = write_cc_entry_offset(& ceo, addr);
  }
#line 2511
  if (tmp___1) {
#line 2512
    return ((_Bool)1);
  }
  {
#line 2514
  tmp___2 = store_trampoline_insns(addr, (byte_t )kind);
  }
#line 2514
  return (tmp___2);
}
}
#line 2517 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
SCHEME_OBJECT *trampoline_storage(SCHEME_OBJECT *block ) 
{ 


  {
#line 2520
  return ((block + 2) + (*(block + 1) & 288230376151711743UL));
}
}
#line 2523 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
static long make_redirection_trampoline(SCHEME_OBJECT *slot , trampoline_type_t kind ,
                                        SCHEME_OBJECT procedure ) 
{ 
  cc_entry_type_t cet ;
  long tmp ;

  {
  {
#line 2529
  make_cc_entry_type(& cet, (cc_entry_type_marker_t )5);
#line 2530
  tmp = make_trampoline(slot, & cet, kind, 1U, procedure);
  }
#line 2530
  return (tmp);
}
}
#line 2533 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
static long make_apply_trampoline(SCHEME_OBJECT *slot , trampoline_type_t kind , SCHEME_OBJECT procedure ,
                                  unsigned long frame_size ) 
{ 
  cc_entry_type_t cet ;
  long tmp ;

  {
  {
#line 2540
  make_cc_entry_type(& cet, (cc_entry_type_marker_t )5);
#line 2541
  tmp = make_trampoline(slot, & cet, kind, 2U, procedure, (26UL << 58U) | frame_size);
  }
#line 2541
  return (tmp);
}
}
#line 2568 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
SCHEME_OBJECT bkpt_install(insn_t *ep ) 
{ 


  {
#line 2571
  return (0UL);
}
}
#line 2574 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
SCHEME_OBJECT bkpt_closure_install(insn_t *ep ) 
{ 


  {
#line 2577
  return (0UL);
}
}
#line 2580 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
void bkpt_remove(insn_t *ep , SCHEME_OBJECT handle ) 
{ 


  {
  {
#line 2583
  error_external_return();
  }
}
}
#line 2586 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
_Bool bkpt_p(insn_t *ep ) 
{ 


  {
#line 2589
  return ((_Bool)0);
}
}
#line 2592 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
SCHEME_OBJECT bkpt_proceed(insn_t *ep , SCHEME_OBJECT handle , SCHEME_OBJECT state ) 
{ 


  {
  {
#line 2595
  error_external_return();
  }
#line 2596
  return ((8UL << 58U) | 1UL);
}
}
#line 2599 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
long do_bkpt_proceed(insn_t **addr_r ) 
{ 


  {
#line 2602
  return (10L);
}
}
#line 2607 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
void comutil_compiled_code_bkpt(utility_result_t *DSU_result , unsigned long entry_addr_raw ,
                                unsigned long state_raw , unsigned long ignore3 ,
                                unsigned long ignore4 ) 
{ 
  insn_t *entry_addr ;
  void *state ;
  SCHEME_OBJECT entry ;
  cc_entry_type_t cet ;
  SCHEME_OBJECT to_save ;
  SCHEME_OBJECT stack_ptr ;
  _Bool tmp ;

  {
  {
#line 2609
  entry_addr = (insn_t *)entry_addr_raw;
#line 2610
  state = (void *)state_raw;
#line 2611
  entry = (40UL << 58U) | (SCHEME_OBJECT )((SCHEME_OBJECT *)entry_addr);
#line 2623
  tmp = read_cc_entry_type(& cet, entry_addr);
  }
#line 2623
  if (tmp) {
#line 2624
    to_save = 0UL;
  } else {
    {
#line 2628
    if ((unsigned int )cet.marker == 1U) {
#line 2628
      goto case_1;
    }
#line 2632
    if ((unsigned int )cet.marker == 4U) {
#line 2632
      goto case_4;
    }
#line 2636
    if ((unsigned int )cet.marker == 6U) {
#line 2636
      goto case_6;
    }
#line 2640
    if ((unsigned int )cet.marker == 7U) {
#line 2640
      goto case_7;
    }
#line 2644
    goto switch_default;
    case_1: /* CIL Label */ 
#line 2629
    to_save = Registers[2];
#line 2630
    goto switch_break;
    case_4: /* CIL Label */ 
#line 2633
    to_save = (59UL << 58U) | (SCHEME_OBJECT )((SCHEME_OBJECT *)state);
#line 2634
    goto switch_break;
    case_6: /* CIL Label */ 
#line 2637
    to_save = Registers[2];
#line 2638
    goto switch_break;
    case_7: /* CIL Label */ 
#line 2641
    to_save = (40UL << 58U) | (SCHEME_OBJECT )((SCHEME_OBJECT *)((insn_t *)state));
#line 2642
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 2645
    to_save = 0UL;
#line 2646
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 2649
  stack_pointer --;
#line 2649
  *stack_pointer = entry;
#line 2650
  stack_ptr = (59UL << 58U) | (SCHEME_OBJECT )stack_pointer;
#line 2651
  stack_pointer --;
#line 2651
  *stack_pointer = to_save;
#line 2652
  stack_pointer --;
#line 2652
  *stack_pointer = stack_ptr;
#line 2653
  stack_pointer --;
#line 2653
  *stack_pointer = entry;
  {
#line 2654
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2654
    comutil_apply(DSU_result, *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 64),
                  4UL, 0UL, 0UL);
    }
#line 2654
    return;
#line 2654
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2657
  return;
}
}
#line 2659 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
void comutil_compiled_closure_bkpt(utility_result_t *DSU_result , unsigned long entry_addr_raw ,
                                   unsigned long ignore2 , unsigned long ignore3 ,
                                   unsigned long ignore4 ) 
{ 
  insn_t *entry_addr ;
  SCHEME_OBJECT entry ;
  SCHEME_OBJECT stack_ptr ;

  {
#line 2661
  entry_addr = (insn_t *)entry_addr_raw;
#line 2662
  entry = (40UL << 58U) | (SCHEME_OBJECT )((SCHEME_OBJECT *)entry_addr);
#line 2665
  stack_pointer --;
#line 2665
  *stack_pointer = entry;
#line 2666
  stack_ptr = (59UL << 58U) | (SCHEME_OBJECT )stack_pointer;
#line 2667
  stack_pointer --;
#line 2667
  *stack_pointer = 0UL;
#line 2668
  stack_pointer --;
#line 2668
  *stack_pointer = stack_ptr;
#line 2669
  stack_pointer --;
#line 2669
  *stack_pointer = entry;
  {
#line 2670
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2670
    comutil_apply(DSU_result, *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 64),
                  4UL, 0UL, 0UL);
    }
#line 2670
    return;
#line 2670
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2673
  return;
}
}
#line 2682 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
utility_proc_t *utility_table[62]  = 
#line 2682
  {      & comutil_return_to_interpreter,      & comutil_operator_apply_trap,      & comutil_operator_apply_trap,      & comutil_operator_apply_trap, 
        & comutil_operator_apply_trap,      & comutil_operator_lexpr_trap,      & comutil_operator_primitive_trap,      & comutil_operator_lookup_trap, 
        & comutil_operator_1_0_trap,      & comutil_operator_2_1_trap,      & comutil_operator_2_0_trap,      & comutil_operator_3_2_trap, 
        & comutil_operator_3_1_trap,      & comutil_operator_3_0_trap,      & comutil_operator_4_3_trap,      & comutil_operator_4_2_trap, 
        & comutil_operator_4_1_trap,      & comutil_operator_4_0_trap,      & comutil_primitive_apply,      & comutil_primitive_lexpr_apply, 
        & comutil_apply,      & comutil_error,      & comutil_lexpr_apply,      & comutil_link, 
        & comutil_interrupt_closure,      & comutil_interrupt_dlink,      & comutil_interrupt_procedure,      & comutil_interrupt_continuation, 
        & comutil_interrupt_ic_procedure,      & comutil_assignment_trap,      & comutil_cache_lookup_apply,      & comutil_lookup_trap, 
        & comutil_safe_lookup_trap,      & comutil_unassigned_p_trap,      & comutil_decrement,      & comutil_divide, 
        & comutil_equal,      & comutil_greater,      & comutil_increment,      & comutil_less, 
        & comutil_minus,      & comutil_multiply,      & comutil_negative,      & comutil_plus, 
        & comutil_positive,      & comutil_zero,      (utility_proc_t *)0,      (utility_proc_t *)0, 
        (utility_proc_t *)0,      (utility_proc_t *)0,      (utility_proc_t *)0,      (utility_proc_t *)0, 
        (utility_proc_t *)0,      (utility_proc_t *)0,      & comutil_primitive_error,      & comutil_quotient, 
        & comutil_remainder,      & comutil_modulo,      & comutil_reflect_to_interface,      & comutil_interrupt_continuation_2, 
        & comutil_compiled_code_bkpt,      & comutil_compiled_closure_bkpt};
#line 2748 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
unsigned long max_trampoline  =    sizeof(utility_table) / sizeof(utility_proc_t *);
#line 2753 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
char const   *utility_index_to_name(unsigned int index___0 ) 
{ 


  {
#line 2756
  return ((char const   *)0);
}
}
#line 2759 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
int pc_to_utility_index(unsigned long pc ) 
{ 


  {
#line 2762
  return (-1);
}
}
#line 2765 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
static unsigned int n_builtins  =    0U;
#line 2766 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
static unsigned int s_builtins  =    0U;
#line 2767 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
static unsigned long *builtins  =    (unsigned long *)0;
#line 2768 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
static char const   **builtin_names  =    (char const   **)0;
#line 2770 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
void declare_builtin(unsigned long builtin , char const   *name ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  unsigned int low ;
  unsigned int high ;
  unsigned int middle ;
  unsigned int scan ;
  unsigned int tmp___3 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 2773
  if (n_builtins == s_builtins) {
#line 2775
    if (s_builtins == 0U) {
      {
#line 2777
      s_builtins = 30U;
#line 2778
      tmp = malloc((unsigned long )s_builtins * sizeof(unsigned long ));
#line 2778
      builtins = (unsigned long *)tmp;
#line 2779
      tmp___0 = malloc((unsigned long )s_builtins * sizeof(char *));
#line 2779
      builtin_names = (char const   **)tmp___0;
      }
    } else {
      {
#line 2783
      s_builtins += s_builtins;
#line 2784
      tmp___1 = realloc((void *)builtins, (unsigned long )s_builtins * sizeof(unsigned long ));
#line 2784
      builtins = (unsigned long *)tmp___1;
#line 2786
      tmp___2 = realloc((void *)builtin_names, (unsigned long )s_builtins * sizeof(char *));
#line 2786
      builtin_names = (char const   **)tmp___2;
      }
    }
#line 2789
    if ((unsigned long )builtins == (unsigned long )((unsigned long *)0)) {
      {
#line 2791
      outf_fatal("declare_builtin: malloc/realloc failed (size = %d).\n", s_builtins);
#line 2793
      termination_init_error();
      }
    } else
#line 2789
    if ((unsigned long )builtin_names == (unsigned long )((char const   **)0)) {
      {
#line 2791
      outf_fatal("declare_builtin: malloc/realloc failed (size = %d).\n", s_builtins);
#line 2793
      termination_init_error();
      }
    }
  }
#line 2797
  low = 0U;
#line 2798
  high = n_builtins;
  {
#line 2799
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2801
    if (low < high) {
#line 2803
      middle = (low + high) / 2U;
#line 2804
      if (builtin < *(builtins + middle)) {
#line 2805
        high = middle;
      } else
#line 2806
      if (builtin > *(builtins + middle)) {
#line 2807
        low = middle + 1U;
      } else {
#line 2810
        *(builtin_names + middle) = name;
#line 2811
        return;
      }
    } else {
#line 2816
      tmp___3 = n_builtins;
#line 2816
      n_builtins ++;
#line 2816
      scan = tmp___3;
      {
#line 2817
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2817
        if (! (low < scan)) {
#line 2817
          goto while_break___0;
        }
#line 2819
        *(builtins + scan) = *(builtins + (scan - 1U));
#line 2820
        *(builtin_names + scan) = *(builtin_names + (scan - 1U));
#line 2821
        scan --;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 2823
      *(builtins + low) = builtin;
#line 2824
      *(builtin_names + low) = name;
#line 2825
      return;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 2831 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
char const   *builtin_index_to_name(unsigned int index___0 ) 
{ 
  char const   *tmp ;

  {
#line 2834
  if (index___0 < n_builtins) {
#line 2834
    tmp = *(builtin_names + index___0);
  } else {
#line 2834
    tmp = (char const   *)0;
  }
#line 2834
  return (tmp);
}
}
#line 2837 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpint.c"
int pc_to_builtin_index(unsigned long pc ) 
{ 
  unsigned int low ;
  unsigned int high ;
  unsigned int middle ;
  unsigned int tmp ;

  {
#line 2840
  if ((unsigned long )builtins != (unsigned long )((unsigned long *)0)) {
#line 2840
    if (n_builtins > 0U) {
#line 2840
      if (pc >= *(builtins + 0)) {
#line 2840
        if (! (pc < *(builtins + (n_builtins - 1U)))) {
#line 2844
          return (-1);
        }
      } else {
#line 2844
        return (-1);
      }
    } else {
#line 2844
      return (-1);
    }
  } else {
#line 2844
    return (-1);
  }
#line 2846
  low = 0U;
#line 2847
  high = n_builtins - 1U;
  {
#line 2848
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2848
    if (! (low + 1U < high)) {
#line 2848
      goto while_break;
    }
#line 2850
    middle = (low + high) / 2U;
#line 2851
    if (pc < *(builtins + middle)) {
#line 2852
      high = middle;
    } else
#line 2853
    if (pc > *(builtins + middle)) {
#line 2854
      low = middle;
    } else {
#line 2856
      return ((int )middle);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2858
  if (pc == *(builtins + high)) {
#line 2858
    tmp = high;
  } else {
#line 2858
    tmp = low;
  }
#line 2858
  return ((int )tmp);
}
}
#line 483 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 152 "/home/khheo/project/mit-scheme-9.2/src/microcode/obstack.h"
void _obstack_newchunk(struct obstack *h , int length ) ;
#line 40 "/home/khheo/project/mit-scheme-9.2/src/microcode/outf.h"
void ( /* format attribute */  outf_error)(char const   *format  , ...) ;
#line 53
void outf_flush_error(void) ;
#line 185 "/home/khheo/project/mit-scheme-9.2/src/microcode/extern.h"
struct obstack ffi_obstack ;
#line 207
_Bool integer_to_long_p(SCHEME_OBJECT n ) ;
#line 208
long integer_to_long(SCHEME_OBJECT n ) ;
#line 211
SCHEME_OBJECT long_to_integer(long number ) ;
#line 213
_Bool integer_to_ulong_p(SCHEME_OBJECT n ) ;
#line 214
unsigned long integer_to_ulong(SCHEME_OBJECT n ) ;
#line 235
_Bool integer_zero_p(SCHEME_OBJECT n ) ;
#line 272
SCHEME_OBJECT double_to_flonum(double value ) ;
#line 273
_Bool real_number_to_double_p(SCHEME_OBJECT x ) ;
#line 274
double real_number_to_double(SCHEME_OBJECT x ) ;
#line 312
_Bool interpreter_applicable_p(SCHEME_OBJECT object ) ;
#line 317
unsigned char *lookup_external_string(SCHEME_OBJECT descriptor , unsigned long *lp ) ;
#line 347
SCHEME_OBJECT find_primitive_cname(char const   *name , _Bool intern_p , _Bool allow_p ,
                                   int arity ) ;
#line 364
void canonicalize_primitive_context(void) ;
#line 365
void back_out_of_primitive(void) ;
#line 367
void Interpret(int pop_return_p ) ;
#line 368
void Do_Micro_Error(long error_code , _Bool from_pop_return_p ) ;
#line 96 "/home/khheo/project/mit-scheme-9.2/src/microcode/prims.h"
long arg_integer(int arg_number ) ;
#line 99
long arg_index_integer(int arg_number , long upper_limit ) ;
#line 106
double arg_real_number(int arg_number ) ;
#line 85 "/home/khheo/project/mit-scheme-9.2/src/microcode/history.h"
void stop_history(void) ;
#line 104 "/usr/include/fenv.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fesetenv)(fenv_t const   *__envp ) ;
#line 38 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.h"
char *cstack_top(void) ;
#line 39
void cstack_push(void *addr , int bytes ) ;
#line 40
char *cstack_lpop(char *tos , int bytes ) ;
#line 41
void cstack_pop(char *tos ) ;
#line 55
void callout_seal(SCM (*tramp)(void) ) ;
#line 56
void callout_unseal(SCM (*expected)(void) ) ;
#line 57
SCM callout_continue(SCM (*tramp)(void) ) ;
#line 58
char *callout_lunseal(SCM (*expected)(void) ) ;
#line 59
void callout_pop(char *tos ) ;
#line 62
void callback_run_kernel(long callback_id , void (*kernel)(void) ) ;
#line 63
char *callback_lunseal(void (*expected)(void) ) ;
#line 64
void callback_run_handler(long callback_id , SCM arglist ) ;
#line 65
void callback_return(char *tos ) ;
#line 69
long arg_long(int argn ) ;
#line 70
unsigned long arg_ulong(int argn ) ;
#line 71
double arg_double(int argn ) ;
#line 72
void *arg_alien_entry(int argn ) ;
#line 73
void *arg_pointer(int argn ) ;
#line 75
SCM long_to_scm(long const   i ) ;
#line 76
SCM ulong_to_scm(unsigned long const   i ) ;
#line 77
SCM double_to_scm(double const   d ) ;
#line 78
SCM pointer_to_scm(void const   *p ) ;
#line 79
SCM struct_to_scm(void const   *p , int size ) ;
#line 81
SCM cons_alien(void const   *addr ) ;
#line 83
long long_value(void) ;
#line 84
unsigned long ulong_value(void) ;
#line 85
double double_value(void) ;
#line 86
void *pointer_value(void) ;
#line 90
void check_number_of_args(int num ) ;
#line 91
SCM unspecific(void) ;
#line 92
SCM empty_list(void) ;
#line 93
int flovec_length(SCM vector ) ;
#line 94
double *flovec_loc(SCM vector ) ;
#line 95
double flovec_ref(SCM vector , int index___0 ) ;
#line 47 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
int is_alien(SCM alien ) 
{ 
  SCM high ;
  SCM low ;

  {
#line 50
  if (alien >> 58U == 62UL) {
#line 50
    if ((*((SCHEME_OBJECT *)(alien & 288230376151711743UL) + 0) & 288230376151711743UL) == 4UL) {
#line 52
      high = *((SCHEME_OBJECT *)(alien & 288230376151711743UL) + 2);
#line 53
      low = *((SCHEME_OBJECT *)(alien & 288230376151711743UL) + 3);
#line 54
      if (high >> 58U == 26UL) {
#line 54
        if (! ((high & 144115188075855872UL) != 0UL)) {
#line 54
          if (low >> 58U == 26UL) {
#line 54
            if (! ((low & 144115188075855872UL) != 0UL)) {
#line 55
              return (1);
            }
          }
        }
      }
    }
  }
#line 57
  return (0);
}
}
#line 60 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
void *alien_address(SCM alien ) 
{ 
  unsigned long high ;
  unsigned long low ;

  {
#line 63
  high = *((SCHEME_OBJECT *)(alien & 288230376151711743UL) + 2) & 288230376151711743UL;
#line 64
  low = *((SCHEME_OBJECT *)(alien & 288230376151711743UL) + 3) & 288230376151711743UL;
#line 65
  return ((void *)((high << (sizeof(void *) * 8UL) / 2UL) + low));
}
}
#line 68 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
void set_alien_address(SCM alien , void const   *ptr ) 
{ 
  unsigned long addr ;

  {
#line 71
  addr = (unsigned long )ptr;
#line 72
  *((SCHEME_OBJECT *)(alien & 288230376151711743UL) + 2) = (26UL << 58U) | (addr >> (sizeof(void *) * 8UL) / 2UL);
#line 73
  *((SCHEME_OBJECT *)(alien & 288230376151711743UL) + 3) = (26UL << 58U) | (addr & ((1UL << (sizeof(void *) * 8UL) / 2UL) - 1UL));
#line 74
  return;
}
}
#line 76 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
SCM arg_alien(int argn ) 
{ 
  SCM alien ;
  int tmp ;

  {
  {
#line 79
  alien = *(stack_pointer + (argn - 1));
#line 80
  tmp = is_alien(alien);
  }
#line 80
  if (tmp) {
#line 81
    return (alien);
  }
  {
#line 82
  error_wrong_type_arg(argn);
  }
#line 83
  return ((SCM )0);
}
}
#line 86 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
void *arg_address(int argn ) 
{ 
  SCM alien ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 89
  alien = *(stack_pointer + (argn - 1));
#line 90
  tmp___0 = is_alien(alien);
  }
#line 90
  if (tmp___0) {
    {
#line 91
    tmp = alien_address(alien);
    }
#line 91
    return (tmp);
  }
  {
#line 92
  error_wrong_type_arg(argn);
  }
#line 93
  return ((void *)0);
}
}
#line 114 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
SCHEME_OBJECT Prim_peek_char(void) 
{ 
  void *tmp ;
  long tmp___0 ;

  {
  {
#line 115
  while (1) {
    while_continue: /* CIL Label */ ;
#line 115
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 115
  tmp = arg_address(1);
  }
#line 115
  if (*(stack_pointer + 1) >> 58U == 26UL) {
#line 115
    tmp___0 = (long )(*(stack_pointer + 1) & 288230376151711743UL);
  } else {
    {
#line 115
    error_wrong_type_arg(2);
#line 115
    tmp___0 = 0L;
    }
  }
#line 115
  return ((26UL << 58U) | ((unsigned long )*((char *)tmp + tmp___0) & 288230376151711743UL));
}
}
#line 117 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
SCHEME_OBJECT Prim_peek_uchar(void) 
{ 
  void *tmp ;
  long tmp___0 ;

  {
  {
#line 118
  while (1) {
    while_continue: /* CIL Label */ ;
#line 118
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 118
  tmp = arg_address(1);
  }
#line 118
  if (*(stack_pointer + 1) >> 58U == 26UL) {
#line 118
    tmp___0 = (long )(*(stack_pointer + 1) & 288230376151711743UL);
  } else {
    {
#line 118
    error_wrong_type_arg(2);
#line 118
    tmp___0 = 0L;
    }
  }
#line 118
  return ((26UL << 58U) | ((unsigned long )*((unsigned char *)((char *)tmp + tmp___0)) & 288230376151711743UL));
}
}
#line 120 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
SCHEME_OBJECT Prim_peek_short(void) 
{ 
  void *tmp ;
  long tmp___0 ;

  {
  {
#line 121
  while (1) {
    while_continue: /* CIL Label */ ;
#line 121
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 121
  tmp = arg_address(1);
  }
#line 121
  if (*(stack_pointer + 1) >> 58U == 26UL) {
#line 121
    tmp___0 = (long )(*(stack_pointer + 1) & 288230376151711743UL);
  } else {
    {
#line 121
    error_wrong_type_arg(2);
#line 121
    tmp___0 = 0L;
    }
  }
#line 121
  return ((26UL << 58U) | ((unsigned long )*((short *)((char *)tmp + tmp___0)) & 288230376151711743UL));
}
}
#line 123 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
SCHEME_OBJECT Prim_peek_ushort(void) 
{ 
  void *tmp ;
  long tmp___0 ;

  {
  {
#line 124
  while (1) {
    while_continue: /* CIL Label */ ;
#line 124
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 124
  tmp = arg_address(1);
  }
#line 124
  if (*(stack_pointer + 1) >> 58U == 26UL) {
#line 124
    tmp___0 = (long )(*(stack_pointer + 1) & 288230376151711743UL);
  } else {
    {
#line 124
    error_wrong_type_arg(2);
#line 124
    tmp___0 = 0L;
    }
  }
#line 124
  return ((26UL << 58U) | ((unsigned long )*((unsigned short *)((char *)tmp + tmp___0)) & 288230376151711743UL));
}
}
#line 126 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
SCHEME_OBJECT Prim_peek_int(void) 
{ 
  void *tmp ;
  long tmp___0 ;
  SCHEME_OBJECT tmp___1 ;

  {
  {
#line 127
  while (1) {
    while_continue: /* CIL Label */ ;
#line 127
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 127
  tmp = arg_address(1);
  }
#line 127
  if (*(stack_pointer + 1) >> 58U == 26UL) {
#line 127
    tmp___0 = (long )(*(stack_pointer + 1) & 288230376151711743UL);
  } else {
    {
#line 127
    error_wrong_type_arg(2);
#line 127
    tmp___0 = 0L;
    }
  }
  {
#line 127
  tmp___1 = long_to_integer((long )*((int *)((char *)tmp + tmp___0)));
  }
#line 127
  return (tmp___1);
}
}
#line 129 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
SCHEME_OBJECT Prim_peek_uint(void) 
{ 
  void *tmp ;
  long tmp___0 ;
  SCHEME_OBJECT tmp___1 ;

  {
  {
#line 130
  while (1) {
    while_continue: /* CIL Label */ ;
#line 130
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 130
  tmp = arg_address(1);
  }
#line 130
  if (*(stack_pointer + 1) >> 58U == 26UL) {
#line 130
    tmp___0 = (long )(*(stack_pointer + 1) & 288230376151711743UL);
  } else {
    {
#line 130
    error_wrong_type_arg(2);
#line 130
    tmp___0 = 0L;
    }
  }
  {
#line 130
  tmp___1 = ulong_to_integer((unsigned long )*((unsigned int *)((char *)tmp + tmp___0)));
  }
#line 130
  return (tmp___1);
}
}
#line 132 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
SCHEME_OBJECT Prim_peek_long(void) 
{ 
  void *tmp ;
  long tmp___0 ;
  SCHEME_OBJECT tmp___1 ;

  {
  {
#line 133
  while (1) {
    while_continue: /* CIL Label */ ;
#line 133
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 133
  tmp = arg_address(1);
  }
#line 133
  if (*(stack_pointer + 1) >> 58U == 26UL) {
#line 133
    tmp___0 = (long )(*(stack_pointer + 1) & 288230376151711743UL);
  } else {
    {
#line 133
    error_wrong_type_arg(2);
#line 133
    tmp___0 = 0L;
    }
  }
  {
#line 133
  tmp___1 = long_to_integer(*((long *)((char *)tmp + tmp___0)));
  }
#line 133
  return (tmp___1);
}
}
#line 135 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
SCHEME_OBJECT Prim_peek_ulong(void) 
{ 
  void *tmp ;
  long tmp___0 ;
  SCHEME_OBJECT tmp___1 ;

  {
  {
#line 136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 136
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 136
  tmp = arg_address(1);
  }
#line 136
  if (*(stack_pointer + 1) >> 58U == 26UL) {
#line 136
    tmp___0 = (long )(*(stack_pointer + 1) & 288230376151711743UL);
  } else {
    {
#line 136
    error_wrong_type_arg(2);
#line 136
    tmp___0 = 0L;
    }
  }
  {
#line 136
  tmp___1 = ulong_to_integer(*((unsigned long *)((char *)tmp + tmp___0)));
  }
#line 136
  return (tmp___1);
}
}
#line 138 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
SCHEME_OBJECT Prim_peek_float(void) 
{ 
  void *tmp ;
  long tmp___0 ;
  SCHEME_OBJECT tmp___1 ;

  {
  {
#line 139
  while (1) {
    while_continue: /* CIL Label */ ;
#line 139
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 139
  tmp = arg_address(1);
  }
#line 139
  if (*(stack_pointer + 1) >> 58U == 26UL) {
#line 139
    tmp___0 = (long )(*(stack_pointer + 1) & 288230376151711743UL);
  } else {
    {
#line 139
    error_wrong_type_arg(2);
#line 139
    tmp___0 = 0L;
    }
  }
  {
#line 139
  tmp___1 = double_to_flonum((double )*((float *)((char *)tmp + tmp___0)));
  }
#line 139
  return (tmp___1);
}
}
#line 141 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
SCHEME_OBJECT Prim_peek_double(void) 
{ 
  void *tmp ;
  long tmp___0 ;
  SCHEME_OBJECT tmp___1 ;

  {
  {
#line 142
  while (1) {
    while_continue: /* CIL Label */ ;
#line 142
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 142
  tmp = arg_address(1);
  }
#line 142
  if (*(stack_pointer + 1) >> 58U == 26UL) {
#line 142
    tmp___0 = (long )(*(stack_pointer + 1) & 288230376151711743UL);
  } else {
    {
#line 142
    error_wrong_type_arg(2);
#line 142
    tmp___0 = 0L;
    }
  }
  {
#line 142
  tmp___1 = double_to_flonum(*((double *)((char *)tmp + tmp___0)));
  }
#line 142
  return (tmp___1);
}
}
#line 144 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
SCHEME_OBJECT Prim_peek_pointer(void) 
{ 
  SCM alien ;
  SCHEME_OBJECT tmp ;
  void *tmp___0 ;
  long tmp___1 ;

  {
  {
#line 149
  while (1) {
    while_continue: /* CIL Label */ ;
#line 149
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 151
  if (*(stack_pointer + 2) >> 58U == 62UL) {
#line 151
    tmp = *(stack_pointer + 2);
  } else {
    {
#line 151
    error_wrong_type_arg(3);
#line 151
    tmp = (SCHEME_OBJECT )0;
    }
  }
  {
#line 151
  alien = tmp;
#line 152
  tmp___0 = arg_address(1);
  }
#line 152
  if (*(stack_pointer + 1) >> 58U == 26UL) {
#line 152
    tmp___1 = (long )(*(stack_pointer + 1) & 288230376151711743UL);
  } else {
    {
#line 152
    error_wrong_type_arg(2);
#line 152
    tmp___1 = 0L;
    }
  }
  {
#line 152
  set_alien_address(alien, (void const   *)*((void **)((char *)tmp___0 + tmp___1)));
  }
#line 153
  return (alien);
}
}
#line 157 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
SCHEME_OBJECT Prim_peek_cstring(void) 
{ 
  void *tmp ;
  long tmp___0 ;
  SCHEME_OBJECT tmp___1 ;

  {
  {
#line 159
  while (1) {
    while_continue: /* CIL Label */ ;
#line 159
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 160
  tmp = arg_address(1);
  }
#line 160
  if (*(stack_pointer + 1) >> 58U == 26UL) {
#line 160
    tmp___0 = (long )(*(stack_pointer + 1) & 288230376151711743UL);
  } else {
    {
#line 160
    error_wrong_type_arg(2);
#line 160
    tmp___0 = 0L;
    }
  }
  {
#line 160
  tmp___1 = char_pointer_to_string((char const   *)((char *)tmp + tmp___0));
  }
#line 160
  return (tmp___1);
}
}
#line 163 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
SCHEME_OBJECT Prim_peek_cstring_bang(void) 
{ 
  char *ptr ;
  void *tmp ;
  long tmp___0 ;
  SCM string ;
  SCHEME_OBJECT tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 169
  while (1) {
    while_continue: /* CIL Label */ ;
#line 169
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 171
  tmp = arg_address(1);
  }
#line 171
  if (*(stack_pointer + 1) >> 58U == 26UL) {
#line 171
    tmp___0 = (long )(*(stack_pointer + 1) & 288230376151711743UL);
  } else {
    {
#line 171
    error_wrong_type_arg(2);
#line 171
    tmp___0 = 0L;
    }
  }
  {
#line 171
  ptr = (char *)tmp + tmp___0;
#line 172
  tmp___1 = char_pointer_to_string((char const   *)ptr);
#line 172
  string = tmp___1;
#line 173
  tmp___2 = strlen((char const   *)ptr);
#line 173
  set_alien_address(*(stack_pointer + 0), (void const   *)((ptr + tmp___2) + 1));
  }
#line 174
  return (string);
}
}
#line 178 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
SCHEME_OBJECT Prim_peek_cstringp(void) 
{ 
  char **ptr ;
  void *tmp ;
  long tmp___0 ;
  SCHEME_OBJECT tmp___1 ;

  {
  {
#line 184
  while (1) {
    while_continue: /* CIL Label */ ;
#line 184
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 186
  tmp = arg_address(1);
  }
#line 186
  if (*(stack_pointer + 1) >> 58U == 26UL) {
#line 186
    tmp___0 = (long )(*(stack_pointer + 1) & 288230376151711743UL);
  } else {
    {
#line 186
    error_wrong_type_arg(2);
#line 186
    tmp___0 = 0L;
    }
  }
#line 186
  ptr = (char **)((char *)tmp + tmp___0);
#line 187
  if ((unsigned long )*ptr == (unsigned long )((void *)0)) {
#line 189
    return ((8UL << 58U) | 9UL);
  } else {
    {
#line 193
    tmp___1 = char_pointer_to_string((char const   *)*ptr);
    }
#line 193
    return (tmp___1);
  }
}
}
#line 198 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
SCHEME_OBJECT Prim_peek_cstringp_bang(void) 
{ 
  char **ptr ;
  void *tmp ;
  long tmp___0 ;
  SCM string ;
  SCHEME_OBJECT tmp___1 ;

  {
  {
#line 205
  while (1) {
    while_continue: /* CIL Label */ ;
#line 205
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 207
  tmp = arg_address(1);
  }
#line 207
  if (*(stack_pointer + 1) >> 58U == 26UL) {
#line 207
    tmp___0 = (long )(*(stack_pointer + 1) & 288230376151711743UL);
  } else {
    {
#line 207
    error_wrong_type_arg(2);
#line 207
    tmp___0 = 0L;
    }
  }
#line 207
  ptr = (char **)((char *)tmp + tmp___0);
#line 208
  if ((unsigned long )*ptr == (unsigned long )((void *)0)) {
#line 210
    return ((8UL << 58U) | 9UL);
  } else {
    {
#line 214
    tmp___1 = char_pointer_to_string((char const   *)*ptr);
#line 214
    string = tmp___1;
#line 215
    set_alien_address(*(stack_pointer + 0), (void const   *)(ptr + 1));
    }
#line 216
    return (string);
  }
}
}
#line 221 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
SCHEME_OBJECT Prim_peek_bytes(void) 
{ 
  void const   *src ;
  void *tmp ;
  long tmp___0 ;
  int count ;
  long tmp___1 ;
  SCM string ;
  int index___0 ;
  long tmp___2 ;
  void *dest ;

  {
  {
#line 225
  while (1) {
    while_continue: /* CIL Label */ ;
#line 225
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 226
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 226
    if (! (*(stack_pointer + 3) >> 58U == 30UL)) {
      {
#line 226
      error_wrong_type_arg(4);
      }
    }
#line 226
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 228
  tmp = arg_address(1);
  }
#line 228
  if (*(stack_pointer + 1) >> 58U == 26UL) {
#line 228
    tmp___0 = (long )(*(stack_pointer + 1) & 288230376151711743UL);
  } else {
    {
#line 228
    error_wrong_type_arg(2);
#line 228
    tmp___0 = 0L;
    }
  }
#line 228
  src = (void const   *)((void **)((char *)tmp + tmp___0));
#line 229
  if (*(stack_pointer + 2) >> 58U == 26UL) {
#line 229
    tmp___1 = (long )(*(stack_pointer + 2) & 288230376151711743UL);
  } else {
    {
#line 229
    error_wrong_type_arg(3);
#line 229
    tmp___1 = 0L;
    }
  }
  {
#line 229
  count = (int )tmp___1;
#line 230
  string = *(stack_pointer + 3);
#line 231
  tmp___2 = arg_index_integer(5, (long )(*((SCHEME_OBJECT *)(string & 288230376151711743UL) + 1) & 288230376151711743UL));
#line 231
  index___0 = (int )tmp___2;
#line 232
  dest = (void *)((unsigned char *)((SCHEME_OBJECT *)(string & 288230376151711743UL) + 2) + index___0);
#line 233
  memcpy((void */* __restrict  */)dest, (void const   */* __restrict  */)src, (size_t )count);
  }
#line 235
  return ((8UL << 58U) | 1UL);
}
}
#line 247 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
SCHEME_OBJECT Prim_poke_char(void) 
{ 
  void *tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
  {
#line 248
  while (1) {
    while_continue: /* CIL Label */ ;
#line 248
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 248
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 248
    tmp = arg_address(1);
    }
#line 248
    if (*(stack_pointer + 1) >> 58U == 26UL) {
#line 248
      tmp___0 = (long )(*(stack_pointer + 1) & 288230376151711743UL);
    } else {
      {
#line 248
      error_wrong_type_arg(2);
#line 248
      tmp___0 = 0L;
      }
    }
    {
#line 248
    tmp___1 = arg_integer(3);
#line 248
    *((char *)tmp + tmp___0) = (char )tmp___1;
    }
#line 248
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 248
  return ((8UL << 58U) | 1UL);
}
}
#line 250 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
SCHEME_OBJECT Prim_poke_uchar(void) 
{ 
  void *tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
  {
#line 251
  while (1) {
    while_continue: /* CIL Label */ ;
#line 251
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 251
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 251
    tmp = arg_address(1);
    }
#line 251
    if (*(stack_pointer + 1) >> 58U == 26UL) {
#line 251
      tmp___0 = (long )(*(stack_pointer + 1) & 288230376151711743UL);
    } else {
      {
#line 251
      error_wrong_type_arg(2);
#line 251
      tmp___0 = 0L;
      }
    }
    {
#line 251
    tmp___1 = arg_integer(3);
#line 251
    *((unsigned char *)((char *)tmp + tmp___0)) = (unsigned char )tmp___1;
    }
#line 251
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 251
  return ((8UL << 58U) | 1UL);
}
}
#line 253 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
SCHEME_OBJECT Prim_poke_short(void) 
{ 
  void *tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
  {
#line 254
  while (1) {
    while_continue: /* CIL Label */ ;
#line 254
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 254
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 254
    tmp = arg_address(1);
    }
#line 254
    if (*(stack_pointer + 1) >> 58U == 26UL) {
#line 254
      tmp___0 = (long )(*(stack_pointer + 1) & 288230376151711743UL);
    } else {
      {
#line 254
      error_wrong_type_arg(2);
#line 254
      tmp___0 = 0L;
      }
    }
    {
#line 254
    tmp___1 = arg_integer(3);
#line 254
    *((short *)((char *)tmp + tmp___0)) = (short )tmp___1;
    }
#line 254
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 254
  return ((8UL << 58U) | 1UL);
}
}
#line 256 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
SCHEME_OBJECT Prim_poke_ushort(void) 
{ 
  void *tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
  {
#line 257
  while (1) {
    while_continue: /* CIL Label */ ;
#line 257
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 257
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 257
    tmp = arg_address(1);
    }
#line 257
    if (*(stack_pointer + 1) >> 58U == 26UL) {
#line 257
      tmp___0 = (long )(*(stack_pointer + 1) & 288230376151711743UL);
    } else {
      {
#line 257
      error_wrong_type_arg(2);
#line 257
      tmp___0 = 0L;
      }
    }
    {
#line 257
    tmp___1 = arg_integer(3);
#line 257
    *((unsigned short *)((char *)tmp + tmp___0)) = (unsigned short )tmp___1;
    }
#line 257
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 257
  return ((8UL << 58U) | 1UL);
}
}
#line 259 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
SCHEME_OBJECT Prim_poke_int(void) 
{ 
  void *tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
  {
#line 260
  while (1) {
    while_continue: /* CIL Label */ ;
#line 260
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 260
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 260
    tmp = arg_address(1);
    }
#line 260
    if (*(stack_pointer + 1) >> 58U == 26UL) {
#line 260
      tmp___0 = (long )(*(stack_pointer + 1) & 288230376151711743UL);
    } else {
      {
#line 260
      error_wrong_type_arg(2);
#line 260
      tmp___0 = 0L;
      }
    }
    {
#line 260
    tmp___1 = arg_integer(3);
#line 260
    *((int *)((char *)tmp + tmp___0)) = (int )tmp___1;
    }
#line 260
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 260
  return ((8UL << 58U) | 1UL);
}
}
#line 262 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
SCHEME_OBJECT Prim_poke_uint(void) 
{ 
  void *tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
  {
#line 263
  while (1) {
    while_continue: /* CIL Label */ ;
#line 263
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 263
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 263
    tmp = arg_address(1);
    }
#line 263
    if (*(stack_pointer + 1) >> 58U == 26UL) {
#line 263
      tmp___0 = (long )(*(stack_pointer + 1) & 288230376151711743UL);
    } else {
      {
#line 263
      error_wrong_type_arg(2);
#line 263
      tmp___0 = 0L;
      }
    }
    {
#line 263
    tmp___1 = arg_integer(3);
#line 263
    *((unsigned int *)((char *)tmp + tmp___0)) = (unsigned int )tmp___1;
    }
#line 263
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 263
  return ((8UL << 58U) | 1UL);
}
}
#line 265 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
SCHEME_OBJECT Prim_poke_long(void) 
{ 
  void *tmp ;
  long tmp___0 ;

  {
  {
#line 266
  while (1) {
    while_continue: /* CIL Label */ ;
#line 266
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 266
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 266
    tmp = arg_address(1);
    }
#line 266
    if (*(stack_pointer + 1) >> 58U == 26UL) {
#line 266
      tmp___0 = (long )(*(stack_pointer + 1) & 288230376151711743UL);
    } else {
      {
#line 266
      error_wrong_type_arg(2);
#line 266
      tmp___0 = 0L;
      }
    }
    {
#line 266
    *((long *)((char *)tmp + tmp___0)) = arg_integer(3);
    }
#line 266
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 266
  return ((8UL << 58U) | 1UL);
}
}
#line 268 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
SCHEME_OBJECT Prim_poke_ulong(void) 
{ 
  void *tmp ;
  long tmp___0 ;

  {
  {
#line 269
  while (1) {
    while_continue: /* CIL Label */ ;
#line 269
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 269
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 269
    tmp = arg_address(1);
    }
#line 269
    if (*(stack_pointer + 1) >> 58U == 26UL) {
#line 269
      tmp___0 = (long )(*(stack_pointer + 1) & 288230376151711743UL);
    } else {
      {
#line 269
      error_wrong_type_arg(2);
#line 269
      tmp___0 = 0L;
      }
    }
    {
#line 269
    *((unsigned long *)((char *)tmp + tmp___0)) = arg_ulong_integer(3);
    }
#line 269
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 269
  return ((8UL << 58U) | 1UL);
}
}
#line 271 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
SCHEME_OBJECT Prim_poke_float(void) 
{ 
  void *tmp ;
  long tmp___0 ;
  double tmp___1 ;

  {
  {
#line 272
  while (1) {
    while_continue: /* CIL Label */ ;
#line 272
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 272
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 272
    tmp = arg_address(1);
    }
#line 272
    if (*(stack_pointer + 1) >> 58U == 26UL) {
#line 272
      tmp___0 = (long )(*(stack_pointer + 1) & 288230376151711743UL);
    } else {
      {
#line 272
      error_wrong_type_arg(2);
#line 272
      tmp___0 = 0L;
      }
    }
    {
#line 272
    tmp___1 = arg_real_number(3);
#line 272
    *((float *)((char *)tmp + tmp___0)) = (float )tmp___1;
    }
#line 272
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 272
  return ((8UL << 58U) | 1UL);
}
}
#line 274 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
SCHEME_OBJECT Prim_poke_double(void) 
{ 
  void *tmp ;
  long tmp___0 ;

  {
  {
#line 275
  while (1) {
    while_continue: /* CIL Label */ ;
#line 275
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 275
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 275
    tmp = arg_address(1);
    }
#line 275
    if (*(stack_pointer + 1) >> 58U == 26UL) {
#line 275
      tmp___0 = (long )(*(stack_pointer + 1) & 288230376151711743UL);
    } else {
      {
#line 275
      error_wrong_type_arg(2);
#line 275
      tmp___0 = 0L;
      }
    }
    {
#line 275
    *((double *)((char *)tmp + tmp___0)) = arg_real_number(3);
    }
#line 275
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 275
  return ((8UL << 58U) | 1UL);
}
}
#line 277 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
SCHEME_OBJECT Prim_poke_pointer(void) 
{ 
  void *tmp ;
  long tmp___0 ;

  {
  {
#line 278
  while (1) {
    while_continue: /* CIL Label */ ;
#line 278
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 278
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 278
    tmp = arg_address(1);
    }
#line 278
    if (*(stack_pointer + 1) >> 58U == 26UL) {
#line 278
      tmp___0 = (long )(*(stack_pointer + 1) & 288230376151711743UL);
    } else {
      {
#line 278
      error_wrong_type_arg(2);
#line 278
      tmp___0 = 0L;
      }
    }
    {
#line 278
    *((void **)((char *)tmp + tmp___0)) = arg_pointer(3);
    }
#line 278
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 278
  return ((8UL << 58U) | 1UL);
}
}
#line 280 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
SCHEME_OBJECT Prim_poke_pointer_bang(void) 
{ 
  void **ptr ;
  void *tmp ;
  long tmp___0 ;

  {
  {
#line 286
  while (1) {
    while_continue: /* CIL Label */ ;
#line 286
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 288
  tmp = arg_address(1);
  }
#line 288
  if (*(stack_pointer + 1) >> 58U == 26UL) {
#line 288
    tmp___0 = (long )(*(stack_pointer + 1) & 288230376151711743UL);
  } else {
    {
#line 288
    error_wrong_type_arg(2);
#line 288
    tmp___0 = 0L;
    }
  }
  {
#line 288
  ptr = (void **)((char *)tmp + tmp___0);
#line 289
  *ptr = arg_pointer(3);
#line 290
  set_alien_address(*(stack_pointer + 0), (void const   *)(ptr + 1));
  }
#line 292
  return ((8UL << 58U) | 1UL);
}
}
#line 295 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
SCHEME_OBJECT Prim_poke_string(void) 
{ 
  SCM string ;
  void *tmp ;
  long tmp___0 ;

  {
  {
#line 300
  while (1) {
    while_continue: /* CIL Label */ ;
#line 300
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 301
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 301
    if (! (*(stack_pointer + 2) >> 58U == 30UL)) {
      {
#line 301
      error_wrong_type_arg(3);
      }
    }
#line 301
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 303
  string = *(stack_pointer + 2);
#line 304
  tmp = arg_address(1);
  }
#line 304
  if (*(stack_pointer + 1) >> 58U == 26UL) {
#line 304
    tmp___0 = (long )(*(stack_pointer + 1) & 288230376151711743UL);
  } else {
    {
#line 304
    error_wrong_type_arg(2);
#line 304
    tmp___0 = 0L;
    }
  }
  {
#line 304
  strncpy((char */* __restrict  */)((char *)tmp + tmp___0), (char const   */* __restrict  */)((char *)((SCHEME_OBJECT *)(string & 288230376151711743UL) + 2)),
          (*((SCHEME_OBJECT *)(string & 288230376151711743UL) + 1) & 288230376151711743UL) + 1UL);
  }
#line 308
  return ((8UL << 58U) | 1UL);
}
}
#line 311 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
SCHEME_OBJECT Prim_poke_string_bang(void) 
{ 
  char *ptr ;
  void *tmp ;
  long tmp___0 ;
  SCM string ;
  unsigned long n_chars ;

  {
  {
#line 317
  while (1) {
    while_continue: /* CIL Label */ ;
#line 317
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 318
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 318
    if (! (*(stack_pointer + 2) >> 58U == 30UL)) {
      {
#line 318
      error_wrong_type_arg(3);
      }
    }
#line 318
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 320
  tmp = arg_address(1);
  }
#line 320
  if (*(stack_pointer + 1) >> 58U == 26UL) {
#line 320
    tmp___0 = (long )(*(stack_pointer + 1) & 288230376151711743UL);
  } else {
    {
#line 320
    error_wrong_type_arg(2);
#line 320
    tmp___0 = 0L;
    }
  }
  {
#line 320
  ptr = (char *)tmp + tmp___0;
#line 321
  string = *(stack_pointer + 2);
#line 322
  n_chars = (*((SCHEME_OBJECT *)(string & 288230376151711743UL) + 1) & 288230376151711743UL) + 1UL;
#line 323
  strncpy((char */* __restrict  */)ptr, (char const   */* __restrict  */)((char *)((SCHEME_OBJECT *)(string & 288230376151711743UL) + 2)),
          n_chars);
#line 324
  set_alien_address(*(stack_pointer + 0), (void const   *)(ptr + n_chars));
  }
#line 326
  return ((8UL << 58U) | 1UL);
}
}
#line 329 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
SCHEME_OBJECT Prim_poke_bytes(void) 
{ 
  void *dest ;
  void *tmp ;
  long tmp___0 ;
  int count ;
  long tmp___1 ;
  SCM string ;
  int index___0 ;
  long tmp___2 ;
  void const   *src ;

  {
  {
#line 333
  while (1) {
    while_continue: /* CIL Label */ ;
#line 333
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 334
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 334
    if (! (*(stack_pointer + 3) >> 58U == 30UL)) {
      {
#line 334
      error_wrong_type_arg(4);
      }
    }
#line 334
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 336
  tmp = arg_address(1);
  }
#line 336
  if (*(stack_pointer + 1) >> 58U == 26UL) {
#line 336
    tmp___0 = (long )(*(stack_pointer + 1) & 288230376151711743UL);
  } else {
    {
#line 336
    error_wrong_type_arg(2);
#line 336
    tmp___0 = 0L;
    }
  }
#line 336
  dest = (void *)((void **)((char *)tmp + tmp___0));
#line 337
  if (*(stack_pointer + 2) >> 58U == 26UL) {
#line 337
    tmp___1 = (long )(*(stack_pointer + 2) & 288230376151711743UL);
  } else {
    {
#line 337
    error_wrong_type_arg(3);
#line 337
    tmp___1 = 0L;
    }
  }
  {
#line 337
  count = (int )tmp___1;
#line 338
  string = *(stack_pointer + 3);
#line 339
  tmp___2 = arg_index_integer(5, (long )(*((SCHEME_OBJECT *)(string & 288230376151711743UL) + 1) & 288230376151711743UL));
#line 339
  index___0 = (int )tmp___2;
#line 340
  src = (void const   *)((unsigned char *)((SCHEME_OBJECT *)(string & 288230376151711743UL) + 2) + index___0);
#line 341
  memcpy((void */* __restrict  */)dest, (void const   */* __restrict  */)src, (size_t )count);
  }
#line 343
  return ((8UL << 58U) | 1UL);
}
}
#line 348 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
SCHEME_OBJECT Prim_c_malloc(void) 
{ 
  unsigned long tmp ;
  void *tmp___0 ;
  SCM tmp___1 ;

  {
  {
#line 350
  while (1) {
    while_continue: /* CIL Label */ ;
#line 350
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 351
  tmp = arg_ulong_integer(2);
#line 351
  tmp___0 = malloc(tmp);
#line 351
  tmp___1 = arg_alien(1);
#line 351
  set_alien_address(tmp___1, (void const   *)tmp___0);
  }
#line 352
  return ((8UL << 58U) | 1UL);
}
}
#line 355 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
SCHEME_OBJECT Prim_c_free(void) 
{ 
  void *addr ;
  void *tmp ;

  {
  {
#line 357
  while (1) {
    while_continue: /* CIL Label */ ;
#line 357
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 359
  tmp = arg_address(1);
#line 359
  addr = tmp;
  }
#line 360
  if ((unsigned long )addr != (unsigned long )((void *)0)) {
    {
#line 361
    free(addr);
    }
  }
#line 363
  return ((8UL << 58U) | 1UL);
}
}
#line 368 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
char *cstack_top(void) 
{ 


  {
#line 371
  return (ffi_obstack.next_free);
}
}
#line 374 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
void cstack_push(void *addr , int bytes ) 
{ 
  struct obstack *__o ;
  int __len ;

  {
#line 377
  __o = & ffi_obstack;
#line 377
  __len = bytes;
#line 377
  if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
    {
#line 377
    _obstack_newchunk(__o, __len);
    }
  }
  {
#line 377
  memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)addr,
         (size_t )__len);
#line 377
  __o->next_free += __len;
  }
#line 378
  return;
}
}
#line 380 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
char *cstack_lpop(char *tos , int bytes ) 
{ 
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 383
  tos -= bytes;
#line 384
  if ((unsigned long )tos < (unsigned long )ffi_obstack.object_base) {
    {
#line 386
    outf_error("\ninternal error: C stack exhausted\n");
#line 387
    outf_error("\tCould not pop %d bytes.\n", bytes);
#line 388
    outf_flush_error();
#line 389
    signal_error_from_primitive(10L);
    }
  }
#line 391
  return (tos);
}
}
#line 394 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
void cstack_pop(char *tos ) 
{ 
  char *__cil_tmp2 ;

  {
#line 397
  if ((unsigned long )tos < (unsigned long )ffi_obstack.object_base) {
    {
#line 399
    outf_error("\ninternal error: C stack over-popped.\n");
#line 400
    outf_flush_error();
#line 401
    signal_error_from_primitive(10L);
    }
  }
#line 403
  ffi_obstack.next_free = tos;
#line 404
  return;
}
}
#line 407 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
int cstack_depth  =    0;
#line 411 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
SCHEME_OBJECT Prim_c_call(void) 
{ 
  SCM (*tramp)(void) ;
  void *tmp ;
  SCM tmp___0 ;

  {
  {
#line 415
  while (1) {
    while_continue: /* CIL Label */ ;
#line 415
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 416
  canonicalize_primitive_context();
#line 420
  tmp = arg_alien_entry(1);
#line 420
  tramp = (SCM (*)(void))tmp;
#line 421
  tmp___0 = (*tramp)();
  }
#line 421
  return (tmp___0);
}
}
#line 425 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
void alienate_float_environment(void) 
{ 
  int s ;
  char *__cil_tmp2 ;

  {
  {
#line 431
  s = fesetenv((fenv_t const   *)-1);
  }
#line 432
  if (s != 0) {
    {
#line 434
    outf_error("Error status from fesetenv: %d\n", s);
#line 435
    outf_flush_error();
    }
  }
#line 463
  return;
}
}
#line 465 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
static SCM c_call_continue  =    0UL;
#line 467 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
void callout_seal(SCM (*tramp)(void) ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
#line 477
  if (c_call_continue == 0UL) {
    {
#line 479
    c_call_continue = find_primitive_cname("C-CALL-CONTINUE", (_Bool)0, (_Bool)0,
                                           -1);
    }
#line 482
    if (c_call_continue == 0UL) {
      {
#line 484
      outf_error("\nNo C-CALL-CONTINUE primitive!\n");
#line 485
      outf_flush_error();
#line 486
      signal_error_from_primitive(10L);
      }
    }
  }
  {
#line 489
  cstack_depth ++;
#line 490
  cstack_push((void *)(& cstack_depth), (int )sizeof(int ));
#line 491
  cstack_push((void *)(& tramp), (int )sizeof(SCM (*)(void)));
#line 494
  Registers[8] = c_call_continue;
#line 495
  back_out_of_primitive();
#line 496
  alienate_float_environment();
  }
#line 497
  return;
}
}
#line 499 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
void callout_unseal(SCM (*expected)(void) ) 
{ 
  char *tos ;
  SCM (*found)(void) ;
  int depth ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 509
  tos = cstack_top();
#line 510
  tos = cstack_lpop(tos, (int )sizeof(SCM (*)(void)));
#line 510
  found = *((CalloutTrampIn *)tos);
#line 511
  tos = cstack_lpop(tos, (int )sizeof(int ));
#line 511
  depth = *((int *)tos);
  }
#line 512
  if ((unsigned long )found != (unsigned long )expected) {
    {
#line 514
    outf_error("\ninternal error: slipped in 1st part of callout\n");
#line 515
    outf_flush_error();
#line 516
    signal_error_from_primitive(10L);
    }
  } else
#line 512
  if (depth != cstack_depth) {
    {
#line 514
    outf_error("\ninternal error: slipped in 1st part of callout\n");
#line 515
    outf_flush_error();
#line 516
    signal_error_from_primitive(10L);
    }
  }
  {
#line 518
  cstack_pop(tos);
  }
#line 519
  return;
}
}
#line 521 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
SCM callout_continue(SCM (*tramp)(void) ) 
{ 
  SCM val ;
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT *tmp___0 ;

  {
  {
#line 529
  cstack_push((void *)(& cstack_depth), (int )sizeof(int ));
#line 530
  cstack_push((void *)(& tramp), (int )sizeof(SCM (*)(void)));
#line 538
  Registers[8] = 0UL;
  }
  {
#line 539
  while (1) {
    while_continue: /* CIL Label */ ;
#line 539
    tmp = stack_pointer;
#line 539
    stack_pointer ++;
#line 539
    Registers[6] = *tmp;
#line 539
    tmp___0 = stack_pointer;
#line 539
    stack_pointer ++;
#line 539
    Registers[5] = *tmp___0;
#line 539
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 541
  set_ulong_register(7U, (*(stack_pointer + 0) & 288230376151711743UL) - 1UL);
#line 542
  stack_pointer += 2;
#line 543
  Registers[5] = *(stack_pointer + 1);
#line 546
  val = (*tramp)();
  }
#line 547
  return (val);
}
}
#line 550 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
SCHEME_OBJECT Prim_c_call_continue(void) 
{ 
  char *tos ;
  SCM (*tramp)(void) ;
  int depth ;
  SCM val ;
  char *__cil_tmp5 ;

  {
  {
#line 554
  while (1) {
    while_continue: /* CIL Label */ ;
#line 554
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 561
  tos = cstack_top();
#line 562
  tos = cstack_lpop(tos, (int )sizeof(SCM (*)(void)));
#line 562
  tramp = *((CalloutTrampIn *)tos);
#line 563
  tos = cstack_lpop(tos, (int )sizeof(int ));
#line 563
  depth = *((int *)tos);
  }
#line 564
  if (depth != cstack_depth) {
    {
#line 566
    outf_error("\ninternal error: slipped in 2nd part of callout\n");
#line 567
    outf_flush_error();
#line 568
    signal_error_from_primitive(10L);
    }
  }
  {
#line 570
  val = (*tramp)();
  }
#line 571
  return (val);
}
}
#line 575 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
char *callout_lunseal(SCM (*expected)(void) ) 
{ 
  char *tos ;
  SCM (*found)(void) ;
  int depth ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 585
  tos = cstack_top();
#line 586
  tos = cstack_lpop(tos, (int )sizeof(SCM (*)(void)));
#line 586
  found = *((CalloutTrampIn *)tos);
#line 587
  tos = cstack_lpop(tos, (int )sizeof(int ));
#line 587
  depth = *((int *)tos);
  }
#line 588
  if (depth != cstack_depth) {
    {
#line 590
    outf_error("\ninternal error: slipped in 1st part of callout\n");
#line 591
    outf_flush_error();
#line 592
    signal_error_from_primitive(10L);
    }
  } else
#line 588
  if ((unsigned long )found != (unsigned long )expected) {
    {
#line 590
    outf_error("\ninternal error: slipped in 1st part of callout\n");
#line 591
    outf_flush_error();
#line 592
    signal_error_from_primitive(10L);
    }
  }
#line 594
  return (tos);
}
}
#line 597 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
void callout_pop(char *tos ) 
{ 


  {
  {
#line 602
  cstack_depth --;
#line 603
  cstack_pop(tos);
  }
#line 604
  return;
}
}
#line 608 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
static SCM run_callback  =    0UL;
#line 609 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
static SCM return_to_c  =    0UL;
#line 611 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
void callback_run_kernel(long callback_id , void (*kernel)(void) ) 
{ 
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 620
  if (run_callback == 0UL) {
    {
#line 622
    run_callback = find_primitive_cname("RUN-CALLBACK", (_Bool)0, (_Bool)0, 0);
#line 623
    return_to_c = find_primitive_cname("RETURN-TO-C", (_Bool)0, (_Bool)0, 0);
    }
#line 624
    if (run_callback == 0UL) {
      {
#line 626
      outf_error("\nWarning: punted callback #%ld.  Missing primitives!\n", callback_id);
#line 629
      outf_flush_error();
#line 630
      Registers[2] = 26UL << 58U;
      }
#line 631
      return;
    } else
#line 624
    if (return_to_c == 0UL) {
      {
#line 626
      outf_error("\nWarning: punted callback #%ld.  Missing primitives!\n", callback_id);
#line 629
      outf_flush_error();
#line 630
      Registers[2] = 26UL << 58U;
      }
#line 631
      return;
    }
  }
#line 636
  if (! ((unsigned long )(stack_pointer + -8) >= (unsigned long )stack_guard)) {
    {
#line 638
    outf_error("\nWarning: punted callback #%ld.  No room on stack!\n", callback_id);
#line 640
    outf_flush_error();
#line 641
    Registers[2] = 26UL << 58U;
    }
#line 642
    return;
  }
  {
#line 645
  cstack_depth ++;
#line 646
  cstack_push((void *)(& cstack_depth), (int )sizeof(int ));
#line 647
  cstack_push((void *)(& kernel), (int )sizeof(void (*)(void)));
#line 649
  stack_pointer --;
#line 649
  *stack_pointer = return_to_c;
#line 650
  stack_pointer --;
#line 650
  *stack_pointer = 1UL;
#line 651
  Registers[6] = (11UL << 58U) | 3UL;
  }
  {
#line 652
  while (1) {
    while_continue: /* CIL Label */ ;
#line 652
    stack_pointer --;
#line 652
    *stack_pointer = Registers[5];
#line 652
    stack_pointer --;
#line 652
    *stack_pointer = Registers[6];
#line 652
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 653
  stack_pointer --;
#line 653
  *stack_pointer = run_callback;
#line 654
  stack_pointer --;
#line 654
  *stack_pointer = 1UL;
  {
#line 655
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 655
    stack_pointer --;
#line 655
    *stack_pointer = Registers[5];
#line 655
    stack_pointer --;
#line 655
    *stack_pointer = Registers[6];
#line 655
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 656
  Interpret(1);
#line 657
  alienate_float_environment();
#line 658
  cstack_depth --;
  }
#line 659
  return;
}
}
#line 661 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
SCHEME_OBJECT Prim_run_callback(void) 
{ 
  char *tos ;
  void (*kernel)(void) ;
  int depth ;
  char *__cil_tmp4 ;

  {
  {
#line 665
  while (1) {
    while_continue: /* CIL Label */ ;
#line 665
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 671
  tos = cstack_top();
#line 672
  tos = cstack_lpop(tos, (int )sizeof(void (*)(void)));
#line 672
  kernel = *((CallbackKernel *)tos);
#line 673
  tos = cstack_lpop(tos, (int )sizeof(int ));
#line 673
  depth = *((int *)tos);
  }
#line 674
  if (depth != cstack_depth) {
    {
#line 676
    outf_error("\nWarning: C data stack slipped in run-callback!\n");
#line 677
    outf_flush_error();
#line 678
    signal_error_from_primitive(10L);
    }
  }
  {
#line 681
  (*kernel)();
  }
#line 683
  return ((8UL << 58U) | 1UL);
}
}
#line 687 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
SCHEME_OBJECT Prim_return_to_c(void) 
{ 
  SCM primitive ;
  long nargs ;

  {
  {
#line 692
  while (1) {
    while_continue: /* CIL Label */ ;
#line 692
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 693
  canonicalize_primitive_context();
#line 698
  primitive = Registers[8];
  }
#line 700
  if (*(Primitive_Arity_Table + (primitive & 288230376151711743UL)) == -1) {
#line 700
    nargs = (long )Registers[7];
  } else {
#line 700
    nargs = (long )*(Primitive_Arity_Table + (primitive & 288230376151711743UL));
  }
  {
#line 701
  stack_pointer += nargs;
#line 702
  Registers[5] = 0UL;
#line 703
  abort_to_interpreter(-12);
  }
#line 705
  return ((8UL << 58U) | 1UL);
}
}
#line 711 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
void abort_to_c(void) 
{ 


  {
  {
#line 714
  abort_to_interpreter(-12);
  }
}
}
#line 718 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
char *callback_lunseal(void (*expected)(void) ) 
{ 
  char *tos ;
  void (*found)(void) ;
  int depth ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 728
  tos = cstack_top();
#line 729
  tos = cstack_lpop(tos, (int )sizeof(void (*)(void)));
#line 729
  found = *((CallbackKernel *)tos);
#line 730
  tos = cstack_lpop(tos, (int )sizeof(int ));
#line 730
  depth = *((int *)tos);
  }
#line 731
  if (depth != cstack_depth) {
    {
#line 733
    outf_error("\ninternal error: slipped in callback kernel\n");
#line 734
    outf_flush_error();
#line 735
    signal_error_from_primitive(10L);
    }
  } else
#line 731
  if ((unsigned long )found != (unsigned long )expected) {
    {
#line 733
    outf_error("\ninternal error: slipped in callback kernel\n");
#line 734
    outf_flush_error();
#line 735
    signal_error_from_primitive(10L);
    }
  }
#line 737
  return (tos);
}
}
#line 740
static SCM valid_callback_handler(void) ;
#line 741
static SCM valid_callback_id(long id ) ;
#line 743 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
void callback_run_handler(long callback_id , SCM arglist ) 
{ 
  SCM handler ;
  SCM fixnum_id ;
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;
  char *__cil_tmp8 ;

  {
  {
#line 756
  handler = valid_callback_handler();
#line 757
  fixnum_id = valid_callback_id(callback_id);
#line 759
  stop_history();
  }
  {
#line 761
  while (1) {
    while_continue: /* CIL Label */ ;
#line 761
    if (! ((unsigned long )(stack_pointer + -4) >= (unsigned long )stack_guard)) {
      {
#line 761
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 761
        if (*stack_start != ((34UL << 58U) | (SCHEME_OBJECT )stack_start)) {
          {
#line 761
          stack_death("STACK_CHECK");
          }
        }
#line 761
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 761
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 761
        set_ulong_register(12U, Registers[12] | 1UL);
        }
        {
#line 761
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 761
          if ((Registers[1] & Registers[12]) != 0UL) {
#line 761
            tmp___0 = memory_block_start;
          } else {
#line 761
            if ((Registers[1] & 4UL) != 0UL) {
#line 761
              tmp = heap_alloc_limit;
            } else {
#line 761
              tmp = heap_end;
            }
#line 761
            tmp___0 = tmp;
          }
          {
#line 761
          set_ptr_register(0U, tmp___0);
          }
#line 761
          if ((Registers[1] & 1UL) != 0UL) {
#line 761
            tmp___1 = stack_guard;
          } else {
#line 761
            tmp___1 = stack_start;
          }
          {
#line 761
          set_ptr_register(11U, tmp___1);
          }
#line 761
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 761
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 761
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 762
  stack_pointer --;
#line 762
  *stack_pointer = arglist;
#line 763
  stack_pointer --;
#line 763
  *stack_pointer = fixnum_id;
#line 764
  stack_pointer --;
#line 764
  *stack_pointer = handler;
#line 765
  stack_pointer --;
#line 765
  *stack_pointer = 3UL;
#line 767
  return;
}
}
#line 769 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
static SCM valid_callback_handler(void) 
{ 
  SCM handler ;
  _Bool tmp ;
  char *__cil_tmp3 ;

  {
  {
#line 776
  handler = *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 66);
#line 777
  tmp = interpreter_applicable_p(handler);
  }
#line 777
  if (! tmp) {
    {
#line 779
    outf_error("\nWarning: bogus callback handler: 0x%x.\n", (unsigned int )handler);
#line 781
    outf_flush_error();
#line 782
    Do_Micro_Error(3L, (_Bool)1);
#line 783
    abort_to_interpreter(-3);
    }
  }
#line 786
  return (handler);
}
}
#line 789 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
static SCM valid_callback_id(long id ) 
{ 


  {
#line 794
  if (((unsigned long )id & 0xfe00000000000000UL) == 0UL) {
#line 795
    return ((26UL << 58U) | (unsigned long )id);
  }
  {
#line 796
  signal_error_from_primitive(16L);
  }
#line 798
  return (26UL << 58U);
}
}
#line 801 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
void callback_return(char *tos ) 
{ 


  {
  {
#line 804
  cstack_pop(tos);
#line 805
  abort_to_interpreter(-3);
  }
}
}
#line 810 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
long arg_long(int argn ) 
{ 
  long tmp ;

  {
  {
#line 813
  tmp = arg_integer(argn);
  }
#line 813
  return (tmp);
}
}
#line 816 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
unsigned long arg_ulong(int argn ) 
{ 
  unsigned long tmp ;

  {
  {
#line 819
  tmp = arg_ulong_integer(argn);
  }
#line 819
  return (tmp);
}
}
#line 822 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
double arg_double(int argn ) 
{ 
  double tmp ;

  {
  {
#line 827
  tmp = arg_real_number(argn);
  }
#line 827
  return (tmp);
}
}
#line 830 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
void *arg_alien_entry(int argn ) 
{ 
  SCM alienf ;
  SCHEME_OBJECT tmp ;
  int length ;
  void *tmp___0 ;

  {
#line 835
  if (*(stack_pointer + (argn - 1)) >> 58U == 10UL) {
#line 835
    tmp = *(stack_pointer + (argn - 1));
  } else {
    {
#line 835
    error_wrong_type_arg(argn);
#line 835
    tmp = (SCHEME_OBJECT )0;
    }
  }
#line 835
  alienf = tmp;
#line 836
  length = (int )(*((SCHEME_OBJECT *)(alienf & 288230376151711743UL) + 0) & 288230376151711743UL);
#line 837
  if (length < 3) {
    {
#line 838
    error_wrong_type_arg(argn);
    }
  }
  {
#line 839
  tmp___0 = alien_address(alienf);
  }
#line 839
  return (tmp___0);
}
}
#line 842 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
void *arg_pointer(int argn ) 
{ 
  SCM arg ;
  _Bool tmp ;
  unsigned char *result ;
  unsigned char *tmp___0 ;
  _Bool tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
#line 848
  arg = *(stack_pointer + (argn - 1));
#line 849
  if (arg >> 58U == 26UL) {
#line 849
    goto _L;
  } else
#line 849
  if (arg >> 58U == 14UL) {
    _L: /* CIL Label */ 
    {
#line 849
    tmp = integer_zero_p(arg);
    }
#line 849
    if (tmp) {
#line 850
      return ((void *)0);
    }
  }
#line 851
  if (arg >> 58U == 30UL) {
#line 852
    return ((void *)((char *)((SCHEME_OBJECT *)(arg & 288230376151711743UL) + 2)));
  }
#line 853
  if (arg >> 58U == 26UL) {
#line 853
    goto _L___0;
  } else
#line 853
  if (arg >> 58U == 14UL) {
    _L___0: /* CIL Label */ 
    {
#line 853
    tmp___1 = integer_to_ulong_p(arg);
    }
#line 853
    if (tmp___1) {
      {
#line 855
      tmp___0 = lookup_external_string(arg, (unsigned long *)((void *)0));
#line 855
      result = tmp___0;
      }
#line 856
      if ((unsigned long )result == (unsigned long )((unsigned char *)0)) {
        {
#line 857
        error_wrong_type_arg(argn);
        }
      }
#line 858
      return ((void *)result);
    }
  }
  {
#line 860
  tmp___3 = is_alien(arg);
  }
#line 860
  if (tmp___3) {
    {
#line 861
    tmp___2 = alien_address(arg);
    }
#line 861
    return (tmp___2);
  }
#line 862
  if (arg >> 58U == 6UL) {
#line 863
    return ((void *)((SCHEME_OBJECT *)(arg & 288230376151711743UL)));
  }
  {
#line 865
  error_wrong_type_arg(argn);
  }
#line 867
  return ((void *)0);
}
}
#line 870 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
SCM long_to_scm(long const   i ) 
{ 
  SCHEME_OBJECT tmp ;

  {
  {
#line 873
  tmp = long_to_integer((long )i);
  }
#line 873
  return (tmp);
}
}
#line 876 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
SCM ulong_to_scm(unsigned long const   i ) 
{ 
  SCHEME_OBJECT tmp ;

  {
  {
#line 879
  tmp = ulong_to_integer((unsigned long )i);
  }
#line 879
  return (tmp);
}
}
#line 882 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
SCM double_to_scm(double const   d ) 
{ 
  SCHEME_OBJECT tmp ;

  {
  {
#line 885
  tmp = double_to_flonum((double )d);
  }
#line 885
  return (tmp);
}
}
#line 888 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
SCM pointer_to_scm(void const   *p ) 
{ 
  SCM arg ;
  int tmp ;

  {
#line 894
  arg = *(stack_pointer + 1);
#line 895
  if (arg == 0UL) {
#line 896
    return ((8UL << 58U) | 1UL);
  }
  {
#line 897
  tmp = is_alien(arg);
  }
#line 897
  if (tmp) {
    {
#line 899
    set_alien_address(arg, p);
    }
#line 900
    return (arg);
  }
  {
#line 903
  error_wrong_type_arg(2);
  }
#line 905
  return (0UL);
}
}
#line 908 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
SCM struct_to_scm(void const   *p , int size ) 
{ 
  SCM arg ;
  void *tmp ;
  int tmp___0 ;

  {
#line 915
  arg = *(stack_pointer + 1);
#line 916
  if (arg == 0UL) {
#line 917
    return ((8UL << 58U) | 1UL);
  }
  {
#line 918
  tmp___0 = is_alien(arg);
  }
#line 918
  if (tmp___0) {
    {
#line 920
    tmp = alien_address(arg);
#line 920
    memcpy((void */* __restrict  */)tmp, (void const   */* __restrict  */)p, (size_t )size);
    }
#line 921
    return (arg);
  }
  {
#line 924
  error_wrong_type_arg(2);
  }
#line 926
  return (0UL);
}
}
#line 929 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
SCM cons_alien(void const   *addr ) 
{ 
  SCM alien ;
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;
  SCHEME_OBJECT *tmp___2 ;
  SCHEME_OBJECT *tmp___3 ;
  SCHEME_OBJECT *tmp___4 ;
  SCHEME_OBJECT *tmp___5 ;
  SCHEME_OBJECT *tmp___6 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 938
  while (1) {
    while_continue: /* CIL Label */ ;
#line 938
    if ((unsigned long )Free >= (unsigned long )heap_start) {
#line 938
      if ((unsigned long )Free < (unsigned long )heap_alloc_limit) {
#line 938
        if (! ((unsigned long )(Free + 5) <= (unsigned long )heap_alloc_limit)) {
#line 938
          goto _L___0;
        }
      } else {
#line 938
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 938
    if ((Registers[1] & 4UL) != 0UL) {
      {
#line 938
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 938
        if ((unsigned long )Free_primitive < (unsigned long )heap_start) {
          {
#line 938
          outf_fatal("\nMicrocode requested primitive GC outside primitive!\n");
#line 938
          Microcode_Termination(12);
          }
        }
#line 938
        if ((unsigned long )Free < (unsigned long )Free_primitive) {
          {
#line 938
          outf_fatal("\nFree has gone backwards!\n");
#line 938
          Microcode_Termination(12);
          }
        }
        {
#line 938
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 938
          while (1) {
            while_continue___2: /* CIL Label */ ;
            {
#line 938
            set_ulong_register(12U, Registers[12] | 4UL);
            }
            {
#line 938
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 938
              if ((Registers[1] & Registers[12]) != 0UL) {
#line 938
                tmp___0 = memory_block_start;
              } else {
#line 938
                if ((Registers[1] & 4UL) != 0UL) {
#line 938
                  tmp = heap_alloc_limit;
                } else {
#line 938
                  tmp = heap_end;
                }
#line 938
                tmp___0 = tmp;
              }
              {
#line 938
              set_ptr_register(0U, tmp___0);
              }
#line 938
              if ((Registers[1] & 1UL) != 0UL) {
#line 938
                tmp___1 = stack_guard;
              } else {
#line 938
                tmp___1 = stack_start;
              }
              {
#line 938
              set_ptr_register(11U, tmp___1);
              }
#line 938
              goto while_break___3;
            }
            while_break___3: /* CIL Label */ ;
            }
#line 938
            goto while_break___2;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 938
          gc_space_needed = (unsigned long )(5L + (Free - Free_primitive));
#line 938
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 938
        signal_interrupt_from_primitive();
        }
#line 938
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 938
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 939
  alien = (62UL << 58U) | (SCHEME_OBJECT )Free;
#line 940
  tmp___2 = Free;
#line 940
  Free ++;
#line 940
  *tmp___2 = 4UL;
#line 941
  tmp___3 = Free;
#line 941
  Free ++;
#line 941
  *tmp___3 = 0UL;
#line 942
  tmp___4 = Free;
#line 942
  Free ++;
#line 942
  *tmp___4 = 26UL << 58U;
#line 943
  tmp___5 = Free;
#line 943
  Free ++;
#line 943
  *tmp___5 = 26UL << 58U;
#line 944
  tmp___6 = Free;
#line 944
  Free ++;
#line 944
  *tmp___6 = 0UL;
#line 945
  set_alien_address(alien, addr);
  }
#line 946
  return (alien);
}
}
#line 949 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
long long_value(void) 
{ 
  SCM value ;
  _Bool tmp ;
  long tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 955
  value = Registers[2];
#line 956
  if (value >> 58U == 2UL) {
#line 957
    return ((long )(value & ((1UL << 8) - 1UL)));
  }
#line 958
  if (! (value >> 58U == 26UL)) {
#line 958
    if (! (value >> 58U == 14UL)) {
      {
#line 961
      outf_error("\nWarning: Callback did not return an integer!\n");
#line 962
      outf_flush_error();
      }
#line 963
      return (0L);
    }
  }
  {
#line 965
  tmp = integer_to_long_p(value);
  }
#line 965
  if (! tmp) {
    {
#line 968
    outf_error("\nWarning: Callback returned an integer larger than a C long!\n");
#line 970
    outf_flush_error();
    }
#line 971
    return (0L);
  }
  {
#line 973
  tmp___0 = integer_to_long(value);
  }
#line 973
  return (tmp___0);
}
}
#line 976 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
unsigned long ulong_value(void) 
{ 
  SCM value ;
  _Bool tmp ;
  unsigned long tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 982
  value = Registers[2];
#line 983
  if (value >> 58U == 2UL) {
#line 984
    return (value & ((1UL << 8) - 1UL));
  }
#line 985
  if (! (value >> 58U == 26UL)) {
#line 985
    if (! (value >> 58U == 14UL)) {
      {
#line 988
      outf_error("\nWarning: Callback did not return an integer!\n");
#line 989
      outf_flush_error();
      }
#line 990
      return (0UL);
    }
  }
  {
#line 992
  tmp = integer_to_ulong_p(value);
  }
#line 992
  if (! tmp) {
    {
#line 995
    outf_error("\nWarning: Callback returned an integer larger than a C unsigned long!\n");
#line 998
    outf_flush_error();
    }
#line 999
    return (0UL);
  }
  {
#line 1001
  tmp___0 = integer_to_ulong(value);
  }
#line 1001
  return (tmp___0);
}
}
#line 1004 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
double double_value(void) 
{ 
  SCM value ;
  _Bool tmp ;
  double tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 1009
  value = Registers[2];
#line 1011
  if (! (value >> 58U == 26UL)) {
#line 1011
    if (! (value >> 58U == 14UL)) {
#line 1011
      if (! (value >> 58U == 6UL)) {
        {
#line 1014
        outf_error("\nWarning: Callback did not return a real.\n");
#line 1015
        outf_flush_error();
        }
#line 1016
        return (0.0);
      }
    }
  }
  {
#line 1018
  tmp = real_number_to_double_p(value);
  }
#line 1018
  if (! tmp) {
    {
#line 1021
    outf_error("\nWarning: Callback returned a real larger than a C double!\n");
#line 1023
    outf_flush_error();
    }
#line 1024
    return (0.0);
  }
  {
#line 1026
  tmp___0 = real_number_to_double(value);
  }
#line 1026
  return (tmp___0);
}
}
#line 1029 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
void *pointer_value(void) 
{ 
  SCM value ;
  _Bool tmp ;
  unsigned char *result ;
  unsigned char *tmp___0 ;
  _Bool tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 1032
  value = Registers[2];
#line 1034
  tmp = integer_zero_p(value);
  }
#line 1034
  if (tmp) {
#line 1035
    return ((void *)0);
  }
#line 1037
  if (value >> 58U == 26UL) {
#line 1037
    goto _L;
  } else
#line 1037
  if (value >> 58U == 14UL) {
    _L: /* CIL Label */ 
    {
#line 1037
    tmp___1 = integer_to_ulong_p(value);
    }
#line 1037
    if (tmp___1) {
      {
#line 1039
      tmp___0 = lookup_external_string(value, (unsigned long *)((void *)0));
#line 1039
      result = tmp___0;
      }
#line 1040
      if ((unsigned long )result == (unsigned long )((unsigned char *)0)) {
        {
#line 1042
        outf_error("\nWarning: Callback returned a bogus xstring.\n");
#line 1043
        outf_flush_error();
        }
#line 1044
        return ((void *)0);
      }
#line 1046
      return ((void *)result);
    }
  }
  {
#line 1048
  tmp___3 = is_alien(value);
  }
#line 1048
  if (tmp___3) {
    {
#line 1049
    tmp___2 = alien_address(value);
    }
#line 1049
    return (tmp___2);
  }
  {
#line 1051
  outf_error("\nWarning: Callback did not return a pointer.\n");
#line 1052
  outf_flush_error();
  }
#line 1053
  return ((void *)0);
}
}
#line 1058 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
void check_number_of_args(int num ) 
{ 


  {
#line 1061
  if (Registers[7] < (unsigned long )num) {
    {
#line 1063
    signal_error_from_primitive(12L);
    }
  }
#line 1065
  return;
}
}
#line 1067 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
SCM unspecific(void) 
{ 


  {
#line 1070
  return ((8UL << 58U) | 1UL);
}
}
#line 1073 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
SCM empty_list(void) 
{ 


  {
#line 1076
  return ((8UL << 58U) | 9UL);
}
}
#line 1079 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
int flovec_length(SCM vector ) 
{ 


  {
#line 1082
  return ((int )((*((SCHEME_OBJECT *)(vector & 288230376151711743UL) + 0) & 288230376151711743UL) / ((sizeof(double ) + (sizeof(SCHEME_OBJECT ) - 1UL)) / sizeof(SCHEME_OBJECT ))));
}
}
#line 1085 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
double *flovec_loc(SCM vector ) 
{ 


  {
#line 1088
  return ((double *)((SCHEME_OBJECT *)(vector & 288230376151711743UL) + 1UL));
}
}
#line 1091 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
double flovec_ref(SCM vector , int index___0 ) 
{ 
  int len ;

  {
#line 1094
  len = (int )((*((SCHEME_OBJECT *)(vector & 288230376151711743UL) + 0) & 288230376151711743UL) / ((sizeof(double ) + (sizeof(SCHEME_OBJECT ) - 1UL)) / sizeof(SCHEME_OBJECT )));
#line 1095
  if (0 <= index___0) {
#line 1095
    if (index___0 < len) {
#line 1096
      return (*((double *)((SCHEME_OBJECT *)(vector & 288230376151711743UL) + ((unsigned long )index___0 * ((sizeof(double ) + (sizeof(SCHEME_OBJECT ) - 1UL)) / sizeof(SCHEME_OBJECT )) + 1UL))));
    }
  }
  {
#line 1097
  error_external_return();
  }
}
}
#line 1100 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxffi.c"
SCHEME_OBJECT Prim_outf_error(void) 
{ 
  SCM arg ;
  char *string ;
  char *__cil_tmp3 ;

  {
  {
#line 1104
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1104
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1106
  arg = *(stack_pointer + 0);
#line 1107
  if (arg >> 58U == 30UL) {
    {
#line 1109
    string = (char *)((unsigned char *)((SCHEME_OBJECT *)(arg & 288230376151711743UL) + 2) + 0);
#line 1110
    outf_error("%s", string);
#line 1111
    outf_flush_error();
    }
  } else {
    {
#line 1115
    error_wrong_type_arg(1);
    }
  }
#line 1117
  return ((8UL << 58U) | 1UL);
}
}
#line 288 "/home/khheo/project/mit-scheme-9.2/src/microcode/extern.h"
SCHEME_OBJECT allocate_marked_vector(unsigned int type , unsigned long length , _Bool gc_check_p ) ;
#line 313
void add_reload_cleanup(void (*cleanup_procedure)(void) ) ;
#line 95 "/home/khheo/project/mit-scheme-9.2/src/microcode/prims.h"
 __attribute__((__noreturn__)) void error_with_argument(SCHEME_OBJECT argument ) ;
#line 35 "/home/khheo/project/mit-scheme-9.2/src/microcode/os.h"
void *OS_malloc(size_t size ) ;
#line 36
void *OS_realloc(void *ptr , size_t size ) ;
#line 37
void OS_free(void *ptr ) ;
#line 56 "/usr/include/dlfcn.h"
extern  __attribute__((__nothrow__)) void *dlopen(char const   *__file , int __mode ) ;
#line 60
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) dlclose)(void *__handle ) ;
#line 64
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(2), __leaf__)) dlsym)(void * __restrict  __handle ,
                                                                                              char const   * __restrict  __name ) ;
#line 82
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) dlerror)(void) ;
#line 37 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxdld.c"
static _Bool cleanup_registered_p  =    (_Bool)0;
#line 38 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxdld.c"
static unsigned int loaded_handles_size  =    0U;
#line 39 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxdld.c"
static unsigned int n_loaded_handles  =    0U;
#line 40 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxdld.c"
static void **loaded_handles  =    (void **)0;
#line 42
static void *dld_load(char const   *path ) ;
#line 43
static void dld_unload(void *handle ) ;
#line 44
static void dld_unload_all(void) ;
#line 45
static void *dld_lookup(void *handle , char const   *symbol ) ;
#line 49 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxdld.c"
SCHEME_OBJECT Prim_dld_load_file(void) 
{ 
  char *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 54
  while (1) {
    while_continue: /* CIL Label */ ;
#line 54
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 55
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 55
    if (! (*(stack_pointer + 1) >> 58U == 55UL)) {
      {
#line 55
      error_wrong_type_arg(2);
      }
    }
#line 55
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 56
  if (*(stack_pointer + 0) == 0UL) {
#line 56
    tmp___0 = (char *)0;
  } else {
#line 56
    if (*(stack_pointer + 0) >> 58U == 30UL) {
#line 56
      tmp = (char *)((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 2);
    } else {
      {
#line 56
      error_wrong_type_arg(1);
#line 56
      tmp = (char *)0;
      }
    }
#line 56
    tmp___0 = tmp;
  }
  {
#line 56
  tmp___1 = dld_load((char const   *)tmp___0);
#line 56
  *((SCHEME_OBJECT *)(*(stack_pointer + 1) & 288230376151711743UL) + 1) = ulong_to_integer((unsigned long )tmp___1);
  }
#line 62
  return ((8UL << 58U) | 1UL);
}
}
#line 65 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxdld.c"
SCHEME_OBJECT Prim_dld_lookup_symbol(void) 
{ 
  char *tmp ;
  unsigned long tmp___0 ;
  void *tmp___1 ;
  SCHEME_OBJECT tmp___2 ;

  {
  {
#line 70
  while (1) {
    while_continue: /* CIL Label */ ;
#line 70
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 71
  if (*(stack_pointer + 1) >> 58U == 30UL) {
#line 71
    tmp = (char *)((SCHEME_OBJECT *)(*(stack_pointer + 1) & 288230376151711743UL) + 2);
  } else {
    {
#line 71
    error_wrong_type_arg(2);
#line 71
    tmp = (char *)0;
    }
  }
  {
#line 71
  tmp___0 = arg_ulong_integer(1);
#line 71
  tmp___1 = dld_lookup((void *)tmp___0, (char const   *)tmp);
#line 71
  tmp___2 = ulong_to_integer((unsigned long )tmp___1);
  }
#line 71
  return (tmp___2);
}
}
#line 76 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxdld.c"
SCHEME_OBJECT Prim_dld_unload_file(void) 
{ 
  unsigned long tmp ;

  {
  {
#line 81
  while (1) {
    while_continue: /* CIL Label */ ;
#line 81
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 82
  tmp = arg_ulong_integer(1);
#line 82
  dld_unload((void *)tmp);
  }
#line 83
  return ((8UL << 58U) | 1UL);
}
}
#line 86 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxdld.c"
SCHEME_OBJECT Prim_invoke_C_thunk(void) 
{ 
  unsigned long tmp ;
  unsigned long tmp___0 ;
  SCHEME_OBJECT tmp___1 ;

  {
  {
#line 92
  while (1) {
    while_continue: /* CIL Label */ ;
#line 92
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 93
  tmp = arg_ulong_integer(1);
#line 93
  tmp___0 = (*((unsigned long (*)(void))tmp))();
#line 93
  tmp___1 = ulong_to_integer(tmp___0);
  }
#line 93
  return (tmp___1);
}
}
#line 99 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxdld.c"
SCHEME_OBJECT Prim_address_to_string(void) 
{ 
  unsigned long tmp ;
  SCHEME_OBJECT tmp___0 ;

  {
  {
#line 105
  while (1) {
    while_continue: /* CIL Label */ ;
#line 105
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 106
  tmp = arg_ulong_integer(1);
#line 106
  tmp___0 = char_pointer_to_string((char const   *)((char *)tmp));
  }
#line 106
  return (tmp___0);
}
}
#line 109 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxdld.c"
static void *dld_load(char const   *path ) 
{ 
  void *handle ;
  SCHEME_OBJECT v ;
  SCHEME_OBJECT tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  unsigned int tmp___3 ;
  char *__cil_tmp9 ;

  {
#line 114
  if (! cleanup_registered_p) {
    {
#line 116
    add_reload_cleanup(& dld_unload_all);
#line 117
    cleanup_registered_p = (_Bool)1;
    }
  }
  {
#line 120
  handle = dlopen(path, 258);
  }
#line 121
  if ((unsigned long )handle == (unsigned long )((void *)0)) {
    {
#line 123
    tmp = allocate_marked_vector(10U, 3UL, (_Bool)1);
#line 123
    v = tmp;
#line 124
    *((SCHEME_OBJECT *)(v & 288230376151711743UL) + 1) = (26UL << 58U) | 4UL;
#line 125
    *((SCHEME_OBJECT *)(v & 288230376151711743UL) + 2) = char_pointer_to_string("dlopen");
#line 126
    tmp___0 = dlerror();
#line 126
    *((SCHEME_OBJECT *)(v & 288230376151711743UL) + 3) = char_pointer_to_string((char const   *)tmp___0);
#line 127
    error_with_argument(v);
    }
  }
#line 129
  if (n_loaded_handles == loaded_handles_size) {
#line 131
    if (loaded_handles_size == 0U) {
      {
#line 133
      loaded_handles_size = 16U;
#line 134
      tmp___1 = OS_malloc((unsigned long )loaded_handles_size * sizeof(void *));
#line 134
      loaded_handles = (void **)tmp___1;
      }
    } else {
      {
#line 139
      loaded_handles_size *= 2U;
#line 140
      tmp___2 = OS_realloc((void *)loaded_handles, (unsigned long )loaded_handles_size * sizeof(void *));
#line 140
      loaded_handles = (void **)tmp___2;
      }
    }
  }
#line 145
  tmp___3 = n_loaded_handles;
#line 145
  n_loaded_handles ++;
#line 145
  *(loaded_handles + tmp___3) = handle;
#line 146
  return (handle);
}
}
#line 149 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxdld.c"
static void dld_finalize(void *handle ) 
{ 
  void *address___0 ;
  void *tmp ;
  void (*finalize)(void) ;

  {
  {
#line 152
  tmp = dlsym((void */* __restrict  */)handle, (char const   */* __restrict  */)"dld_finalize_file");
#line 152
  address___0 = tmp;
  }
#line 153
  if ((unsigned long )address___0 != (unsigned long )((void *)0)) {
    {
#line 155
    finalize = (void (*)(void))address___0;
#line 156
    (*finalize)();
    }
  }
#line 158
  return;
}
}
#line 160 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxdld.c"
static void dld_unload(void *handle ) 
{ 
  SCHEME_OBJECT v ;
  SCHEME_OBJECT tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  void **scan ;
  void **end ;
  char *__cil_tmp8 ;

  {
  {
#line 163
  dld_finalize(handle);
#line 164
  tmp___1 = dlclose(handle);
  }
#line 164
  if (tmp___1 != 0) {
    {
#line 166
    tmp = allocate_marked_vector(10U, 3UL, (_Bool)1);
#line 166
    v = tmp;
#line 167
    *((SCHEME_OBJECT *)(v & 288230376151711743UL) + 1) = (26UL << 58U) | 4UL;
#line 168
    *((SCHEME_OBJECT *)(v & 288230376151711743UL) + 2) = char_pointer_to_string("dlclose");
#line 169
    tmp___0 = dlerror();
#line 169
    *((SCHEME_OBJECT *)(v & 288230376151711743UL) + 3) = char_pointer_to_string((char const   *)tmp___0);
#line 170
    error_with_argument(v);
    }
  }
#line 173
  scan = loaded_handles;
#line 174
  end = scan + n_loaded_handles;
  {
#line 175
  while (1) {
    while_continue: /* CIL Label */ ;
#line 175
    if (! ((unsigned long )scan < (unsigned long )end)) {
#line 175
      goto while_break;
    }
#line 176
    if ((unsigned long )*scan == (unsigned long )handle) {
#line 178
      *scan = *(end - 1);
#line 179
      n_loaded_handles --;
#line 180
      goto while_break;
    }
#line 175
    scan ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 183
  return;
}
}
#line 185 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxdld.c"
static void dld_unload_all(void) 
{ 
  void **scan ;
  void **end ;
  void *handle ;
  void **tmp ;

  {
#line 188
  if (loaded_handles_size > 0U) {
#line 190
    scan = loaded_handles;
#line 191
    end = scan + n_loaded_handles;
    {
#line 192
    while (1) {
      while_continue: /* CIL Label */ ;
#line 192
      if (! ((unsigned long )scan < (unsigned long )end)) {
#line 192
        goto while_break;
      }
      {
#line 194
      tmp = scan;
#line 194
      scan ++;
#line 194
      handle = *tmp;
#line 195
      dld_finalize(handle);
#line 196
      dlclose(handle);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 199
    OS_free((void *)loaded_handles);
#line 200
    loaded_handles_size = 0U;
#line 201
    n_loaded_handles = 0U;
#line 202
    loaded_handles = (void **)0;
    }
  }
#line 204
  return;
}
}
#line 206 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxdld.c"
static void *dld_lookup(void *handle , char const   *symbol ) 
{ 
  void *address___0 ;
  char const   *error_string ;
  char *tmp ;
  SCHEME_OBJECT v ;
  SCHEME_OBJECT tmp___0 ;
  char *__cil_tmp8 ;

  {
  {
#line 212
  dlerror();
#line 213
  address___0 = dlsym((void */* __restrict  */)handle, (char const   */* __restrict  */)symbol);
#line 214
  tmp = dlerror();
#line 214
  error_string = (char const   *)tmp;
  }
#line 215
  if ((unsigned long )error_string != (unsigned long )((char const   *)0)) {
    {
#line 217
    tmp___0 = allocate_marked_vector(10U, 3UL, (_Bool)1);
#line 217
    v = tmp___0;
#line 218
    *((SCHEME_OBJECT *)(v & 288230376151711743UL) + 1) = (26UL << 58U) | 4UL;
#line 219
    *((SCHEME_OBJECT *)(v & 288230376151711743UL) + 2) = char_pointer_to_string("dlsym");
#line 220
    *((SCHEME_OBJECT *)(v & 288230376151711743UL) + 3) = char_pointer_to_string(error_string);
#line 221
    error_with_argument(v);
    }
  }
#line 223
  return (address___0);
}
}
#line 43 "/home/khheo/project/mit-scheme-9.2/src/microcode/dstack.h"
void dstack_protect(void (*protector)(void *environment ) , void *environment ) ;
#line 293 "/home/khheo/project/mit-scheme-9.2/src/microcode/extern.h"
SCHEME_OBJECT memory_to_string(unsigned long n_bytes , void const   *vp ) ;
#line 98 "/home/khheo/project/mit-scheme-9.2/src/microcode/prims.h"
long arg_nonnegative_integer(int arg_number ) ;
#line 40 "/home/khheo/project/mit-scheme-9.2/src/microcode/osterm.h"
unsigned int arg_baud_index(unsigned int argument ) ;
#line 57 "/usr/include/termcap.h"
extern char PC ;
#line 58
extern char *UP ;
#line 59
extern char *BC ;
#line 60
extern short ospeed ;
#line 63
extern char const   *tgetstr(char const   * , char ** ) ;
#line 64
extern char *tgoto(char const   * , int  , int  ) ;
#line 65
extern int tgetent(char * , char const   * ) ;
#line 66
extern int tgetflag(char const   * ) ;
#line 67
extern int tgetnum(char const   * ) ;
#line 68
extern int tputs(char const   * , int  , int (*)(int  ) ) ;
#line 71 "/home/khheo/project/mit-scheme-9.2/src/microcode/tterm.c"
extern char *tparam(char const   * , void * , int   , ...) ;
#line 77 "/home/khheo/project/mit-scheme-9.2/src/microcode/tterm.c"
static char termcap_buffer[2048]  ;
#line 78 "/home/khheo/project/mit-scheme-9.2/src/microcode/tterm.c"
static char tgetstr_buffer[2048]  ;
#line 79 "/home/khheo/project/mit-scheme-9.2/src/microcode/tterm.c"
static char *tgetstr_pointer  ;
#line 81 "/home/khheo/project/mit-scheme-9.2/src/microcode/tterm.c"
static char tputs_output[2048]  ;
#line 82 "/home/khheo/project/mit-scheme-9.2/src/microcode/tterm.c"
static char *tputs_output_scan  ;
#line 84 "/home/khheo/project/mit-scheme-9.2/src/microcode/tterm.c"
static int tputs_write_char(int c ) 
{ 
  char *tmp ;

  {
#line 87
  if ((unsigned long )tputs_output_scan >= (unsigned long )(tputs_output + 2048)) {
    {
#line 88
    error_external_return();
    }
  }
#line 89
  tmp = tputs_output_scan;
#line 89
  tputs_output_scan ++;
#line 89
  *tmp = (char )c;
#line 90
  return (c);
}
}
#line 93 "/home/khheo/project/mit-scheme-9.2/src/microcode/tterm.c"
SCHEME_OBJECT Prim_termcap_initialize(void) 
{ 
  unsigned long tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;
#line 95
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 96
  tgetstr_pointer = tgetstr_buffer;
#line 97
  if (*(stack_pointer + 0) >> 58U == 30UL) {
#line 97
    tmp___2 = (char *)((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 2);
  } else {
    {
#line 97
    error_wrong_type_arg(1);
#line 97
    tmp___2 = (char *)0;
    }
  }
  {
#line 97
  tmp___3 = tgetent(termcap_buffer, (char const   *)tmp___2);
  }
#line 97
  if (tmp___3 > 0) {
#line 97
    tmp___1 = 8UL << 58U;
  } else {
#line 97
    tmp___1 = 0UL;
  }
#line 97
  return (tmp___1);
}
}
#line 101 "/home/khheo/project/mit-scheme-9.2/src/microcode/tterm.c"
SCHEME_OBJECT Prim_termcap_get_number(void) 
{ 
  int result ;
  char *tmp ;
  int tmp___0 ;
  SCHEME_OBJECT tmp___1 ;
  unsigned long tmp___2 ;

  {
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
#line 103
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 105
  if (*(stack_pointer + 0) >> 58U == 30UL) {
#line 105
    tmp = (char *)((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 2);
  } else {
    {
#line 105
    error_wrong_type_arg(1);
#line 105
    tmp = (char *)0;
    }
  }
  {
#line 105
  tmp___0 = tgetnum((char const   *)tmp);
#line 105
  result = tmp___0;
  }
#line 106
  if (result < 0) {
#line 106
    tmp___2 = 0UL;
  } else {
    {
#line 106
    tmp___1 = long_to_integer((long )result);
#line 106
    tmp___2 = tmp___1;
    }
  }
#line 106
  return (tmp___2);
}
}
#line 110 "/home/khheo/project/mit-scheme-9.2/src/microcode/tterm.c"
SCHEME_OBJECT Prim_termcap_get_flag(void) 
{ 
  unsigned long tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 112
  while (1) {
    while_continue: /* CIL Label */ ;
#line 112
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 113
  if (*(stack_pointer + 0) >> 58U == 30UL) {
#line 113
    tmp___2 = (char *)((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 2);
  } else {
    {
#line 113
    error_wrong_type_arg(1);
#line 113
    tmp___2 = (char *)0;
    }
  }
  {
#line 113
  tmp___3 = tgetflag((char const   *)tmp___2);
  }
#line 113
  if (tmp___3 != 0) {
#line 113
    tmp___1 = 8UL << 58U;
  } else {
#line 113
    tmp___1 = 0UL;
  }
#line 113
  return (tmp___1);
}
}
#line 116 "/home/khheo/project/mit-scheme-9.2/src/microcode/tterm.c"
SCHEME_OBJECT Prim_termcap_get_string(void) 
{ 
  char *result ;
  char *tmp ;
  char *tmp___0 ;
  SCHEME_OBJECT tmp___1 ;
  unsigned long tmp___2 ;

  {
  {
#line 118
  while (1) {
    while_continue: /* CIL Label */ ;
#line 118
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 120
  if (*(stack_pointer + 0) >> 58U == 30UL) {
#line 120
    tmp = (char *)((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 2);
  } else {
    {
#line 120
    error_wrong_type_arg(1);
#line 120
    tmp = (char *)0;
    }
  }
  {
#line 120
  tmp___0 = (char *)tgetstr((char const   *)tmp, & tgetstr_pointer);
#line 120
  result = tmp___0;
  }
#line 121
  if ((unsigned long )result == (unsigned long )((char *)0)) {
#line 121
    tmp___2 = 0UL;
  } else {
    {
#line 121
    tmp___1 = char_pointer_to_string((char const   *)result);
#line 121
    tmp___2 = tmp___1;
    }
  }
#line 121
  return (tmp___2);
}
}
#line 133 "/home/khheo/project/mit-scheme-9.2/src/microcode/tterm.c"
static void protect_tc(void *environment ) 
{ 
  struct tc_env *env ;
  char *pointer ;

  {
#line 136
  env = (struct tc_env *)environment;
#line 137
  pointer = env->string_pointer;
#line 138
  if ((unsigned long )pointer != (unsigned long )((char *)0)) {
#line 138
    if ((unsigned long )pointer != (unsigned long )env->string_buffer) {
      {
#line 139
      free((void *)pointer);
      }
    }
  }
#line 140
  return;
}
}
#line 142 "/home/khheo/project/mit-scheme-9.2/src/microcode/tterm.c"
SCHEME_OBJECT Prim_termcap_param_string(void) 
{ 
  char string_buffer[4096] ;
  struct tc_env env ;
  SCHEME_OBJECT string ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  char *tmp___3 ;
  void *__cil_tmp9 ;

  {
  {
#line 144
  while (1) {
    while_continue: /* CIL Label */ ;
#line 144
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 148
  string = (8UL << 58U) | 1UL;
#line 149
  env.string_buffer = string_buffer;
#line 150
  env.string_pointer = (char *)0;
#line 151
  transaction_begin();
#line 152
  dstack_protect(& protect_tc, (void *)(& env));
#line 153
  tmp = arg_nonnegative_integer(5);
#line 153
  tmp___0 = arg_nonnegative_integer(4);
#line 153
  tmp___1 = arg_nonnegative_integer(3);
#line 153
  tmp___2 = arg_nonnegative_integer(2);
  }
#line 153
  if (*(stack_pointer + 0) >> 58U == 30UL) {
#line 153
    tmp___3 = (char *)((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 2);
  } else {
    {
#line 153
    error_wrong_type_arg(1);
#line 153
    tmp___3 = (char *)0;
    }
  }
  {
#line 153
  env.string_pointer = tparam((char const   *)tmp___3, (void *)(string_buffer), (int )sizeof(string_buffer),
                              tmp___2, tmp___1, tmp___0, tmp);
  }
#line 159
  if ((unsigned long )env.string_pointer == (unsigned long )((char *)0)) {
    {
#line 160
    error_external_return();
    }
  }
  {
#line 161
  string = char_pointer_to_string((char const   *)env.string_pointer);
#line 162
  transaction_commit();
  }
#line 163
  return (string);
}
}
#line 167 "/home/khheo/project/mit-scheme-9.2/src/microcode/tterm.c"
static void protect_free(void *environment ) 
{ 
  char *pointer ;

  {
#line 170
  pointer = *((char **)environment);
#line 171
  if ((unsigned long )pointer != (unsigned long )((char *)0)) {
    {
#line 172
    free((void *)pointer);
    }
  }
#line 173
  return;
}
}
#line 175 "/home/khheo/project/mit-scheme-9.2/src/microcode/tterm.c"
SCHEME_OBJECT Prim_termcap_goto_string(void) 
{ 
  char *string_pointer ;
  SCHEME_OBJECT string ;
  char *tmp ;
  char *tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 177
  while (1) {
    while_continue: /* CIL Label */ ;
#line 177
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 179
  string_pointer = (char *)0;
#line 180
  string = (8UL << 58U) | 1UL;
#line 181
  if (*(stack_pointer + 3) == 0UL) {
#line 181
    BC = (char *)0;
  } else {
#line 181
    if (*(stack_pointer + 3) >> 58U == 30UL) {
#line 181
      tmp = (char *)((SCHEME_OBJECT *)(*(stack_pointer + 3) & 288230376151711743UL) + 2);
    } else {
      {
#line 181
      error_wrong_type_arg(4);
#line 181
      tmp = (char *)0;
      }
    }
#line 181
    BC = tmp;
  }
#line 182
  if (*(stack_pointer + 4) == 0UL) {
#line 182
    UP = (char *)0;
  } else {
#line 182
    if (*(stack_pointer + 4) >> 58U == 30UL) {
#line 182
      tmp___0 = (char *)((SCHEME_OBJECT *)(*(stack_pointer + 4) & 288230376151711743UL) + 2);
    } else {
      {
#line 182
      error_wrong_type_arg(5);
#line 182
      tmp___0 = (char *)0;
      }
    }
#line 182
    UP = tmp___0;
  }
  {
#line 183
  transaction_begin();
#line 184
  dstack_protect(& protect_free, (void *)(& string_pointer));
#line 185
  tmp___1 = arg_nonnegative_integer(3);
#line 185
  tmp___2 = arg_nonnegative_integer(2);
  }
#line 185
  if (*(stack_pointer + 0) >> 58U == 30UL) {
#line 185
    tmp___3 = (char *)((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 2);
  } else {
    {
#line 185
    error_wrong_type_arg(1);
#line 185
    tmp___3 = (char *)0;
    }
  }
  {
#line 185
  string_pointer = tgoto((char const   *)tmp___3, (int )tmp___2, (int )tmp___1);
  }
#line 189
  if ((unsigned long )string_pointer == (unsigned long )((char *)0)) {
    {
#line 190
    error_external_return();
    }
  }
  {
#line 191
  string = char_pointer_to_string((char const   *)string_pointer);
#line 192
  transaction_commit();
  }
#line 193
  return (string);
}
}
#line 197 "/home/khheo/project/mit-scheme-9.2/src/microcode/tterm.c"
SCHEME_OBJECT Prim_termcap_pad_string(void) 
{ 
  unsigned int tmp ;
  char *tmp___0 ;
  long tmp___1 ;
  char *tmp___2 ;
  SCHEME_OBJECT tmp___3 ;

  {
  {
#line 199
  while (1) {
    while_continue: /* CIL Label */ ;
#line 199
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 200
  tmp = arg_baud_index(3U);
#line 200
  ospeed = (short )tmp;
  }
#line 201
  if (*(stack_pointer + 3) == 0UL) {
#line 201
    PC = (char )'\000';
  } else {
#line 201
    if (*(stack_pointer + 3) >> 58U == 30UL) {
#line 201
      tmp___0 = (char *)((SCHEME_OBJECT *)(*(stack_pointer + 3) & 288230376151711743UL) + 2);
    } else {
      {
#line 201
      error_wrong_type_arg(4);
#line 201
      tmp___0 = (char *)0;
      }
    }
#line 201
    PC = *(tmp___0 + 0);
  }
  {
#line 202
  tputs_output_scan = tputs_output;
#line 203
  tmp___1 = arg_nonnegative_integer(2);
  }
#line 203
  if (*(stack_pointer + 0) >> 58U == 30UL) {
#line 203
    tmp___2 = (char *)((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 2);
  } else {
    {
#line 203
    error_wrong_type_arg(1);
#line 203
    tmp___2 = (char *)0;
    }
  }
  {
#line 203
  tputs((char const   *)tmp___2, (int )tmp___1, & tputs_write_char);
#line 204
  tmp___3 = memory_to_string((unsigned long )(tputs_output_scan - tputs_output), (void const   *)((unsigned char *)(tputs_output)));
  }
#line 204
  return (tmp___3);
}
}
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 28 "/home/khheo/project/mit-scheme-9.2/src/microcode/terminfo.c"
extern char *tparm(char const   *  , ...) ;
#line 36 "/home/khheo/project/mit-scheme-9.2/src/microcode/terminfo.c"
char *tparam(char const   *string , char *outstring , int len , int arg1 , int arg2 ,
             int arg3 , int arg4 , int arg5 , int arg6 , int arg7 , int arg8 , int arg9 ) 
{ 
  char *temp ;
  char *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 50
  tmp = tparm(string, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
#line 50
  temp = tmp;
  }
#line 51
  if ((unsigned long )outstring == (unsigned long )((char *)0)) {
    {
#line 52
    tmp___0 = strlen((char const   *)temp);
#line 52
    tmp___1 = malloc(tmp___0 + 1UL);
#line 52
    outstring = (char *)tmp___1;
    }
  }
  {
#line 53
  strcpy((char */* __restrict  */)outstring, (char const   */* __restrict  */)temp);
  }
#line 54
  return (outstring);
}
}
#line 435 "/usr/include/libio.h"
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 359 "/home/khheo/project/mit-scheme-9.2/src/microcode/extern.h"
 __attribute__((__noreturn__)) void termination_eof(void) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 360 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 764 "/home/khheo/project/mit-scheme-9.2/src/microcode/ux.h"
int UX_terminal_get_state(int fd , Ttty_state *s ) ;
#line 765
int UX_terminal_set_state(int fd , Ttty_state *s ) ;
#line 32 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxutil.h"
char const   *char_description(unsigned char c , int long_p ) ;
#line 33
void userio_buffered_input(void) ;
#line 34
char userio_read_char(void) ;
#line 35
char userio_read_char_raw(void) ;
#line 36
char userio_choose_option(char const   *herald , char const   *prompt , char const   **choices ) ;
#line 38
int userio_confirm(char const   *prompt ) ;
#line 32 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxutil.c"
void terminal_state_raw(Ttty_state *s , int fd ) ;
#line 37 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxutil.c"
static char buffer[5]  ;
#line 34 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxutil.c"
static char const   *char_description_brief(unsigned char c ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 40
  if ((int )c == 32) {
#line 40
    goto case_32;
  }
#line 41
  if ((int )c == 9) {
#line 41
    goto case_9;
  }
#line 42
  if ((int )c == 13) {
#line 42
    goto case_13;
  }
#line 43
  if ((int )c == 10) {
#line 43
    goto case_10;
  }
#line 44
  if ((int )c == 27) {
#line 44
    goto case_27;
  }
#line 45
  if ((int )c == 127) {
#line 45
    goto case_127;
  }
#line 46
  goto switch_default;
  case_32: /* CIL Label */ 
#line 40
  return ("SPC");
  case_9: /* CIL Label */ 
#line 41
  return ("TAB");
  case_13: /* CIL Label */ 
#line 42
  return ("RET");
  case_10: /* CIL Label */ 
#line 43
  return ("LFD");
  case_27: /* CIL Label */ 
#line 44
  return ("ESC");
  case_127: /* CIL Label */ 
#line 45
  return ("DEL");
  switch_default: /* CIL Label */ 
#line 47
  if ((int )c < 32) {
#line 49
    buffer[0] = (char )'^';
#line 50
    buffer[1] = (char )((int )c + 64);
#line 51
    buffer[2] = (char )'\000';
  } else
#line 53
  if ((int )c < 127) {
#line 55
    buffer[0] = (char )c;
#line 56
    buffer[1] = (char )'\000';
  } else {
#line 60
    buffer[0] = (char )'\\';
#line 61
    buffer[1] = (char )((int )c >> 6);
#line 62
    buffer[2] = (char )(((int )c >> 3) & 7);
#line 63
    buffer[3] = (char )((int )c & 7);
#line 64
    buffer[4] = (char )'\000';
  }
#line 66
  return ((char const   *)(buffer));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 73 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxutil.c"
static char buffer___0[64]  ;
#line 70 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxutil.c"
char const   *char_description(unsigned char c , int long_p ) 
{ 
  char const   *description ;
  char const   *tmp ;
  int meta ;
  int cc ;
  int control ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
#line 74
  tmp = char_description_brief(c);
#line 74
  description = tmp;
  }
#line 75
  if (long_p) {
#line 77
    meta = (int )c >= 128;
#line 78
    cc = (int )c & 127;
#line 79
    control = cc < 32;
#line 80
    if (meta) {
#line 80
      goto _L;
    } else
#line 80
    if (control) {
      _L: /* CIL Label */ 
#line 82
      if (control) {
#line 82
        tmp___0 = cc + 64;
      } else {
#line 82
        tmp___0 = cc;
      }
#line 82
      if (control) {
#line 82
        tmp___1 = "control-";
      } else {
#line 82
        tmp___1 = "";
      }
#line 82
      if (meta) {
#line 82
        tmp___2 = "meta-";
      } else {
#line 82
        tmp___2 = "";
      }
      {
#line 82
      sprintf((char */* __restrict  */)(buffer___0), (char const   */* __restrict  */)"`%s\' (%s%s%c)",
              description, tmp___2, tmp___1, tmp___0);
      }
#line 87
      return ((char const   *)(buffer___0));
    }
  }
  {
#line 90
  sprintf((char */* __restrict  */)(buffer___0), (char const   */* __restrict  */)"`%s\'",
          description);
  }
#line 91
  return ((char const   *)(buffer___0));
}
}
#line 94 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxutil.c"
static Ttty_state original_tty_state  ;
#line 96 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxutil.c"
void UX_initialize_userio(void) 
{ 


  {
  {
#line 99
  UX_terminal_get_state(0, & original_tty_state);
  }
#line 100
  return;
}
}
#line 102 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxutil.c"
static void restore_input_state(void *ap ) 
{ 


  {
  {
#line 105
  UX_terminal_set_state(0, (Ttty_state *)ap);
  }
#line 106
  return;
}
}
#line 108 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxutil.c"
static Ttty_state *save_input_state(void) 
{ 
  Ttty_state *s ;
  void *tmp ;

  {
  {
#line 111
  tmp = dstack_alloc((unsigned int )sizeof(Ttty_state ));
#line 111
  s = (Ttty_state *)tmp;
#line 112
  UX_terminal_get_state(0, s);
#line 113
  transaction_record_action((enum transaction_action_type )2, & restore_input_state,
                            (void *)s);
  }
#line 114
  return (s);
}
}
#line 117 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxutil.c"
void userio_buffered_input(void) 
{ 


  {
  {
#line 120
  save_input_state();
#line 121
  UX_terminal_set_state(0, & original_tty_state);
  }
#line 122
  return;
}
}
#line 124 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxutil.c"
char userio_read_char(void) 
{ 
  char c ;
  int nread ;
  int *tmp ;
  ssize_t tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 128
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 132
    tmp = __errno_location();
#line 132
    *tmp = 0;
#line 133
    tmp___0 = read(0, (void *)(& c), (size_t )1);
#line 133
    nread = (int )tmp___0;
    }
#line 134
    if (nread == 1) {
#line 135
      goto while_break;
    }
    {
#line 136
    tmp___1 = __errno_location();
    }
#line 136
    if (*tmp___1 != 4) {
#line 138
      c = (char )'\000';
#line 139
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 142
  return (c);
}
}
#line 145 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxutil.c"
char userio_read_char_raw(void) 
{ 
  Ttty_state state ;
  Ttty_state *tmp ;
  char c ;
  char tmp___0 ;
  void *__cil_tmp5 ;

  {
  {
#line 148
  transaction_begin();
#line 153
  tmp = save_input_state();
#line 153
  state = *tmp;
#line 154
  terminal_state_raw(& state, 0);
#line 155
  UX_terminal_set_state(0, & state);
#line 158
  tmp___0 = userio_read_char();
#line 158
  c = tmp___0;
#line 159
  transaction_commit();
  }
#line 160
  return (c);
}
}
#line 164 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxutil.c"
char userio_choose_option(char const   *herald , char const   *prompt , char const   **choices ) 
{ 
  char const   **scan ;
  char const   *choice ;
  char const   **tmp ;
  unsigned char command ;
  char tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  unsigned short const   **tmp___3 ;
  char const   **scan___0 ;
  char const   *choice___0 ;
  char const   **tmp___4 ;
  unsigned char option ;
  int tmp___5 ;
  unsigned short const   **tmp___6 ;

  {
  {
#line 169
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 171
    fputs((char const   */* __restrict  */)herald, (FILE */* __restrict  */)stdout);
#line 172
    _IO_putc('\n', stdout);
#line 174
    scan = choices;
    }
    {
#line 175
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 177
      tmp = scan;
#line 177
      scan ++;
#line 177
      choice = *tmp;
#line 178
      if ((unsigned long )choice == (unsigned long )((char const   *)0)) {
#line 179
        goto while_break___0;
      }
      {
#line 180
      fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"  %s\n",
              choice);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 183
    fputs((char const   */* __restrict  */)prompt, (FILE */* __restrict  */)stdout);
#line 184
    fflush(stdout);
#line 186
    tmp___0 = userio_read_char_raw();
#line 186
    command = (unsigned char )tmp___0;
    }
#line 187
    if ((int )command == 0) {
      {
#line 187
      tmp___1 = __errno_location();
      }
#line 187
      if (*tmp___1 != 0) {
#line 188
        return ((char )command);
      }
    }
    {
#line 189
    _IO_putc('\n', stdout);
#line 190
    fflush(stdout);
#line 191
    tmp___3 = __ctype_b_loc();
    }
#line 191
    if ((int const   )*(*tmp___3 + (int )command) & 512) {
      {
#line 192
      tmp___2 = toupper((int )command);
#line 192
      command = (unsigned char )tmp___2;
      }
    }
#line 194
    scan___0 = choices;
    {
#line 195
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 197
      tmp___4 = scan___0;
#line 197
      scan___0 ++;
#line 197
      choice___0 = *tmp___4;
#line 198
      if ((unsigned long )choice___0 == (unsigned long )((char const   *)0)) {
#line 199
        goto while_break___1;
      }
      {
#line 201
      option = (unsigned char )*choice___0;
#line 202
      tmp___6 = __ctype_b_loc();
      }
#line 202
      if ((int const   )*(*tmp___6 + (int )option) & 512) {
        {
#line 203
        tmp___5 = toupper((int )option);
#line 203
        option = (unsigned char )tmp___5;
        }
      }
#line 204
      if ((int )command == (int )option) {
#line 205
        return ((char )option);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 213 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxutil.c"
int userio_confirm(char const   *prompt ) 
{ 
  char tmp ;
  int *tmp___0 ;

  {
  {
#line 216
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 218
    fputs((char const   */* __restrict  */)prompt, (FILE */* __restrict  */)stdout);
#line 219
    fflush(stdout);
#line 220
    tmp = userio_read_char_raw();
    }
    {
#line 223
    if ((int )tmp == 89) {
#line 223
      goto case_89;
    }
#line 223
    if ((int )tmp == 121) {
#line 223
      goto case_89;
    }
#line 226
    if ((int )tmp == 78) {
#line 226
      goto case_78;
    }
#line 226
    if ((int )tmp == 110) {
#line 226
      goto case_78;
    }
#line 228
    if ((int )tmp == 0) {
#line 228
      goto case_0;
    }
#line 220
    goto switch_break;
    case_89: /* CIL Label */ 
    case_121: /* CIL Label */ 
#line 224
    return (1);
    case_78: /* CIL Label */ 
    case_110: /* CIL Label */ 
#line 227
    return (0);
    case_0: /* CIL Label */ 
    {
#line 229
    tmp___0 = __errno_location();
    }
#line 229
    if (*tmp___0 != 0) {
      {
#line 232
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Problems reading keyboard input -- exiting.\n");
#line 233
      termination_eof();
      }
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 38 "/home/khheo/project/mit-scheme-9.2/src/microcode/option.h"
_Bool option_emacs_subprocess ;
#line 779 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 32 "/home/khheo/project/mit-scheme-9.2/src/microcode/ostty.h"
Tchannel OS_tty_input_channel(void) ;
#line 33
Tchannel OS_tty_output_channel(void) ;
#line 34
unsigned int OS_tty_x_size(void) ;
#line 35
unsigned int OS_tty_y_size(void) ;
#line 36
char const   *OS_tty_command_beep(void) ;
#line 37
char const   *OS_tty_command_clear(void) ;
#line 59 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxio.h"
struct channel *channel_table ;
#line 35 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxtty.c"
Tchannel OS_open_fd(int fd ) ;
#line 45 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxtty.c"
static Tchannel input_channel  ;
#line 46 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxtty.c"
static Tchannel output_channel  ;
#line 48 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxtty.c"
static int tty_x_size  ;
#line 49 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxtty.c"
static int tty_y_size  ;
#line 50 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxtty.c"
static char const   *tty_command_beep  ;
#line 51 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxtty.c"
static char const   *tty_command_clear  ;
#line 53 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxtty.c"
static _Bool tty_size_synchronized_p  ;
#line 54
static void UX_synchronize_tty_size(void) ;
#line 56 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxtty.c"
Tchannel OS_tty_input_channel(void) 
{ 


  {
#line 59
  return (input_channel);
}
}
#line 62 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxtty.c"
Tchannel OS_tty_output_channel(void) 
{ 


  {
#line 65
  return (output_channel);
}
}
#line 68 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxtty.c"
unsigned int OS_tty_x_size(void) 
{ 


  {
  {
#line 71
  UX_synchronize_tty_size();
  }
#line 72
  return ((unsigned int )tty_x_size);
}
}
#line 75 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxtty.c"
unsigned int OS_tty_y_size(void) 
{ 


  {
  {
#line 78
  UX_synchronize_tty_size();
  }
#line 79
  return ((unsigned int )tty_y_size);
}
}
#line 82 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxtty.c"
char const   *OS_tty_command_beep(void) 
{ 


  {
#line 85
  return (tty_command_beep);
}
}
#line 88 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxtty.c"
char const   *OS_tty_command_clear(void) 
{ 


  {
#line 91
  return (tty_command_clear);
}
}
#line 118 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxtty.c"
static char tputs_output___0[2048]  ;
#line 119 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxtty.c"
static char *tputs_output_scan___0  ;
#line 121 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxtty.c"
static void tputs_write_char___0(char c ) 
{ 
  char *tmp ;

  {
#line 124
  tmp = tputs_output_scan___0;
#line 124
  tputs_output_scan___0 ++;
#line 124
  *tmp = c;
#line 125
  return;
}
}
#line 127 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxtty.c"
static void UX_tty_with_termcap(void (*procedure)(void) ) 
{ 
  char termcap_buffer___0[2048] ;
  char const   *term ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 130
  tputs_output_scan___0 = tputs_output___0;
#line 134
  tmp = isatty(1);
  }
#line 134
  if (tmp) {
#line 134
    if (! option_emacs_subprocess) {
      {
#line 134
      tmp___0 = getenv("TERM");
#line 134
      term = (char const   *)tmp___0;
      }
#line 134
      if ((unsigned long )term != (unsigned long )((char const   *)0)) {
        {
#line 134
        tmp___1 = tgetent((void *)(termcap_buffer___0), term);
        }
#line 134
        if (tmp___1 > 0) {
          {
#line 138
          (*procedure)();
          }
        }
      }
    }
  }
#line 140
  return;
}
}
#line 142 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxtty.c"
static void UX_synchronize_tty_size_with_termcap(void) 
{ 


  {
  {
#line 145
  tty_x_size = tgetnum("co");
#line 146
  tty_y_size = tgetnum("li");
  }
#line 147
  return;
}
}
#line 150 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxtty.c"
static void UX_synchronize_tty_size(void) 
{ 
  struct winsize size ;
  int tmp ;
  char const   *columns ;
  char *tmp___0 ;
  char const   *lines ;
  char *tmp___1 ;
  int x ;
  int tmp___2 ;
  int y ;
  int tmp___3 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 153
  if (tty_size_synchronized_p) {
#line 154
    return;
  }
  {
#line 156
  tty_x_size = -1;
#line 157
  tty_y_size = -1;
#line 166
  tmp = ioctl(1, 21523UL, & size);
  }
#line 166
  if (tmp >= 0) {
#line 168
    tty_x_size = (int )size.ws_col;
#line 169
    tty_y_size = (int )size.ws_row;
  }
#line 174
  if (tty_x_size <= 0) {
#line 174
    goto _L;
  } else
#line 174
  if (tty_y_size <= 0) {
    _L: /* CIL Label */ 
    {
#line 176
    tmp___0 = getenv("COLUMNS");
#line 176
    columns = (char const   *)tmp___0;
#line 177
    tmp___1 = getenv("LINES");
#line 177
    lines = (char const   *)tmp___1;
    }
#line 178
    if ((unsigned long )columns != (unsigned long )((char const   *)0)) {
#line 178
      if ((unsigned long )lines != (unsigned long )((char const   *)0)) {
        {
#line 180
        tmp___2 = atoi(columns);
#line 180
        x = tmp___2;
#line 181
        tmp___3 = atoi(lines);
#line 181
        y = tmp___3;
        }
#line 182
        if (x > 0) {
#line 182
          if (y > 0) {
#line 184
            tty_x_size = x;
#line 185
            tty_y_size = y;
          }
        }
      }
    }
  }
#line 191
  if (tty_x_size <= 0) {
    {
#line 192
    UX_tty_with_termcap(& UX_synchronize_tty_size_with_termcap);
    }
  } else
#line 191
  if (tty_y_size <= 0) {
    {
#line 192
    UX_tty_with_termcap(& UX_synchronize_tty_size_with_termcap);
    }
  }
#line 195
  if (tty_x_size <= 0) {
#line 197
    tty_x_size = 80;
#line 198
    tty_y_size = 24;
  } else
#line 195
  if (tty_y_size <= 0) {
#line 197
    tty_x_size = 80;
#line 198
    tty_y_size = 24;
  }
#line 201
  tty_size_synchronized_p = (_Bool)1;
#line 202
  return;
}
}
#line 208 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxtty.c"
static char tgetstr_buffer___0[2048]  ;
#line 205 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxtty.c"
static void UX_initialize_tty_with_termcap(void) 
{ 
  char *tbp ;

  {
  {
#line 209
  tbp = tgetstr_buffer___0;
#line 210
  tty_command_clear = tgetstr("cl", & tbp);
  }
#line 211
  return;
}
}
#line 214 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxtty.c"
void UX_initialize_tty(void) 
{ 
  char *command ;
  char *tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 217
  input_channel = OS_open_fd(0);
#line 218
  (channel_table + input_channel)->internal = 1U;
#line 219
  output_channel = OS_open_fd(1);
#line 220
  (channel_table + output_channel)->internal = 1U;
#line 221
  tty_size_synchronized_p = (_Bool)0;
#line 222
  UX_synchronize_tty_size();
#line 223
  tty_command_beep = "\a";
#line 227
  tty_command_clear = (char const   *)0;
#line 228
  UX_tty_with_termcap(& UX_initialize_tty_with_termcap);
  }
#line 229
  if ((unsigned long )tty_command_clear == (unsigned long )((char const   *)0)) {
#line 230
    tty_command_clear = "\f";
  } else {
    {
#line 233
    command = tputs_output_scan___0;
#line 234
    tputs(tty_command_clear, tty_y_size, & tputs_write_char___0);
#line 235
    tmp = tputs_output_scan___0;
#line 235
    tputs_output_scan___0 ++;
#line 235
    *tmp = (char )'\000';
#line 236
    tty_command_clear = (char const   *)command;
    }
  }
#line 239
  return;
}
}
#line 241 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxtty.c"
void UX_reinitialize_tty(void) 
{ 


  {
#line 244
  tty_size_synchronized_p = (_Bool)0;
#line 245
  return;
}
}
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 34 "/home/khheo/project/mit-scheme-9.2/src/microcode/critsec.h"
char const   *critical_section_name ;
#line 35
_Bool critical_section_hook_p ;
#line 36
void (*critical_section_hook)(char const   * ) ;
#line 281 "/home/khheo/project/mit-scheme-9.2/src/microcode/extern.h"
SCHEME_OBJECT cons(SCHEME_OBJECT car , SCHEME_OBJECT cdr ) ;
#line 356
 __attribute__((__noreturn__)) void termination_trap(void) ;
#line 78 "/home/khheo/project/mit-scheme-9.2/src/microcode/history.h"
SCHEME_OBJECT *history_register ;
#line 82
SCHEME_OBJECT *make_dummy_history(void) ;
#line 603 "/usr/include/unistd.h"
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 41 "/home/khheo/project/mit-scheme-9.2/src/microcode/intext.h"
void reset_interruptable_extent(void) ;
#line 802 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxtrap.h"
extern unsigned int _init ;
#line 803
extern unsigned int etext ;
#line 830
void UX_initialize_trap_recovery(void) ;
#line 831
enum trap_state OS_set_trap_state(enum trap_state state ) ;
#line 832
void hard_reset(ucontext_t *scp ) ;
#line 833
void soft_reset(void) ;
#line 834
void trap_handler(char const   *message , int signo , siginfo_t *info , ucontext_t *scp ) ;
#line 837
SCHEME_OBJECT find_ccblock(unsigned long pc ) ;
#line 40 "/home/khheo/project/mit-scheme-9.2/src/microcode/option.h"
_Bool option_disable_core_dump ;
#line 40 "/home/khheo/project/mit-scheme-9.2/src/microcode/ostop.h"
void OS_restore_external_state(void) ;
#line 51 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxtrap.c"
char const   *find_signal_name(int signo ) ;
#line 52
void UX_dump_core(void) ;
#line 63 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxtrap.c"
static struct ux_sig_code_desc ux_signal_codes[64]  ;
#line 97 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxtrap.c"
static enum trap_state trap_state  ;
#line 98 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxtrap.c"
static enum trap_state user_trap_state  ;
#line 99 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxtrap.c"
static enum trap_state saved_trap_state  ;
#line 100 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxtrap.c"
static int saved_signo  ;
#line 101 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxtrap.c"
static siginfo_t *saved_info  ;
#line 102 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxtrap.c"
static ucontext_t *saved_scp  ;
#line 104
static void continue_from_trap(int signo , siginfo_t *info , ucontext_t *scp ) ;
#line 108
static SCHEME_OBJECT *find_heap_address(unsigned long pc ) ;
#line 109
static SCHEME_OBJECT *find_constant_address(unsigned long pc ) ;
#line 111
static SCHEME_OBJECT *find_block_address(unsigned long pc , SCHEME_OBJECT *area_start ) ;
#line 115
static void setup_trap_frame(int signo , siginfo_t *info , ucontext_t *scp , struct trap_recovery_info *trinfo ,
                             SCHEME_OBJECT *new_stack_pointer ) ;
#line 122
static void initialize_ux_signal_codes(void) ;
#line 123
static SCHEME_OBJECT find_signal_code_name(int signo , siginfo_t *info , ucontext_t *scp ) ;
#line 125
static enum pc_location classify_pc(unsigned long pc , SCHEME_OBJECT **r_block_addr ,
                                    unsigned int *r_index ) ;
#line 128
static void trap_normal_termination(void) ;
#line 129
static void trap_immediate_termination(void) ;
#line 130
static void trap_dump_core(void) ;
#line 131
static void trap_recover(void) ;
#line 133 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxtrap.c"
void UX_initialize_trap_recovery(void) 
{ 


  {
  {
#line 136
  trap_state = (enum trap_state )4;
#line 137
  user_trap_state = (enum trap_state )4;
#line 138
  initialize_ux_signal_codes();
  }
#line 139
  return;
}
}
#line 141 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxtrap.c"
enum trap_state OS_set_trap_state(enum trap_state state ) 
{ 
  enum trap_state old_trap_state ;

  {
#line 144
  old_trap_state = user_trap_state;
#line 145
  user_trap_state = state;
#line 146
  trap_state = state;
#line 147
  return (old_trap_state);
}
}
#line 150 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxtrap.c"
void hard_reset(ucontext_t *scp ) 
{ 


  {
  {
#line 154
  continue_from_trap(0, (siginfo_t *)0, scp);
  }
#line 155
  return;
}
}
#line 157 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxtrap.c"
void soft_reset(void) 
{ 
  struct trap_recovery_info trinfo ;
  SCHEME_OBJECT *new_stack_pointer ;
  SCHEME_OBJECT *tmp ;

  {
#line 162
  if ((unsigned long )stack_pointer >= (unsigned long )stack_guard) {
#line 162
    tmp = stack_pointer;
  } else {
#line 162
    tmp = (SCHEME_OBJECT *)0;
  }
#line 162
  new_stack_pointer = tmp;
#line 164
  if (Registers[8] != 0UL) {
#line 166
    trinfo.state = (26UL << 58U) | 1UL;
#line 167
    trinfo.pc_info_1 = Registers[8];
#line 168
    trinfo.pc_info_2 = (26UL << 58U) | Registers[7];
#line 169
    trinfo.extra_trap_info = 0UL;
  } else {
#line 173
    trinfo.state = 26UL << 58U;
#line 174
    trinfo.pc_info_1 = 0UL;
#line 175
    trinfo.pc_info_2 = 0UL;
#line 176
    trinfo.extra_trap_info = 0UL;
  }
#line 178
  if ((unsigned long )Free >= (unsigned long )heap_start) {
#line 178
    if (! ((unsigned long )Free < (unsigned long )heap_end)) {
#line 179
      Free = heap_alloc_limit;
    }
  } else {
#line 179
    Free = heap_alloc_limit;
  }
  {
#line 180
  setup_trap_frame(0, (siginfo_t *)0, (ucontext_t *)0, & trinfo, new_stack_pointer);
  }
#line 181
  return;
}
}
#line 184 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxtrap.c"
SCHEME_OBJECT find_ccblock(unsigned long pc ) 
{ 
  SCHEME_OBJECT *block_addr ;
  unsigned int index___0 ;
  unsigned long tmp ;

  {
  {
#line 190
  block_addr = (SCHEME_OBJECT *)0;
#line 191
  classify_pc(pc, & block_addr, & index___0);
  }
#line 192
  if ((unsigned long )block_addr != (unsigned long )((SCHEME_OBJECT *)0)) {
#line 192
    tmp = (61UL << 58U) | (SCHEME_OBJECT )block_addr;
  } else {
#line 192
    tmp = 0UL;
  }
#line 192
  return (tmp);
}
}
#line 285 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxtrap.c"
static char const   *trap_query_choices[6]  = {      "D = dump core",      "I = terminate immediately",      "N = terminate normally",      "R = attempt recovery", 
        "Q = terminate normally",      (char const   *)0};
#line 196 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxtrap.c"
void trap_handler(char const   *message , int signo , siginfo_t *info , ucontext_t *scp ) 
{ 
  int code ;
  _Bool stack_overflowed_p ;
  enum trap_state old_trap_state ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char tmp___3 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 202
  code = info->si_code;
#line 203
  stack_overflowed_p = (_Bool )(*stack_start != ((34UL << 58U) | (SCHEME_OBJECT )stack_start));
#line 204
  old_trap_state = trap_state;
#line 206
  if ((unsigned int )old_trap_state == 6U) {
    {
#line 207
    _exit(1);
    }
  }
#line 208
  if ((unsigned int )old_trap_state == 5U) {
    {
#line 209
    trap_immediate_termination();
    }
  }
#line 210
  trap_state = (enum trap_state )0;
#line 212
  if ((unsigned long )critical_section_name != (unsigned long )((char const   *)0)) {
    {
#line 214
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\n>> A %s has occurred within critical section \"%s\".\n",
            message, critical_section_name);
#line 217
    tmp = find_signal_name(signo);
#line 217
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)">> [signal %d (%s), code %d]\n",
            signo, tmp, code);
    }
  } else
#line 220
  if (stack_overflowed_p) {
    {
#line 222
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\n>> A %s has occurred.\n",
            message);
#line 223
    tmp___0 = find_signal_name(signo);
#line 223
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)">> [signal %d (%s), code %d]\n",
            signo, tmp___0, code);
    }
  } else
#line 220
  if ((unsigned int )old_trap_state != 4U) {
    {
#line 222
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\n>> A %s has occurred.\n",
            message);
#line 223
    tmp___0 = find_signal_name(signo);
#line 223
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)">> [signal %d (%s), code %d]\n",
            signo, tmp___0, code);
    }
  }
#line 226
  if (stack_overflowed_p) {
    {
#line 228
    fputs((char const   */* __restrict  */)">> The stack has overflowed overwriting adjacent memory.\n",
          (FILE */* __restrict  */)stdout);
#line 230
    fputs((char const   */* __restrict  */)">> This was probably caused by a runaway recursion.\n",
          (FILE */* __restrict  */)stdout);
    }
  }
  {
#line 232
  fflush(stdout);
  }
  {
#line 236
  if ((unsigned int )old_trap_state == 0U) {
#line 236
    goto case_0;
  }
#line 256
  if ((unsigned int )old_trap_state == 4U) {
#line 256
    goto case_4;
  }
#line 269
  if ((unsigned int )old_trap_state == 1U) {
#line 269
    goto case_1;
  }
#line 273
  goto switch_default;
  case_0: /* CIL Label */ 
#line 237
  if ((unsigned int )saved_trap_state == 4U) {
#line 237
    goto _L;
  } else
#line 237
  if ((unsigned int )saved_trap_state == 3U) {
    _L: /* CIL Label */ 
    {
#line 240
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)">> The trap occurred while processing an earlier trap.\n");
#line 242
    tmp___1 = find_signal_name(saved_signo);
#line 242
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)">> [The earlier trap raised signal %d (%s), code %d.]\n",
            saved_signo, tmp___1, saved_info->si_code);
    }
#line 249
    if ((unsigned long )critical_section_name != (unsigned long )((char const   *)0)) {
#line 249
      tmp___2 = "extremely ";
    } else {
#line 249
      tmp___2 = "";
    }
    {
#line 249
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)">> Successful recovery is %sunlikely.\n",
            tmp___2);
    }
  } else {
    {
#line 253
    trap_immediate_termination();
    }
  }
#line 254
  goto switch_break;
  case_4: /* CIL Label */ 
#line 257
  if ((unsigned long )critical_section_name != (unsigned long )((char const   *)0)) {
    {
#line 258
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)">> Successful recovery is unlikely.\n");
    }
  } else
#line 257
  if (stack_overflowed_p) {
    {
#line 258
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)">> Successful recovery is unlikely.\n");
    }
  } else {
    {
#line 261
    saved_trap_state = old_trap_state;
#line 262
    saved_signo = signo;
#line 263
    saved_info = info;
#line 264
    saved_scp = scp;
#line 265
    trap_recover();
    }
  }
#line 267
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 270
  termination_trap();
  }
#line 271
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 274
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 277
  fflush(stdout);
#line 278
  saved_trap_state = old_trap_state;
#line 279
  saved_signo = signo;
#line 280
  saved_info = info;
#line 281
  saved_scp = scp;
  }
  {
#line 283
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 294
    tmp___3 = userio_choose_option("Choose one of the following actions:", "Action -> ",
                                   trap_query_choices);
    }
    {
#line 299
    if ((int )tmp___3 == 73) {
#line 299
      goto case_73;
    }
#line 302
    if ((int )tmp___3 == 68) {
#line 302
      goto case_68;
    }
#line 308
    if ((int )tmp___3 == 81) {
#line 308
      goto case_81;
    }
#line 308
    if ((int )tmp___3 == 78) {
#line 308
      goto case_81;
    }
#line 308
    if ((int )tmp___3 == 0) {
#line 308
      goto case_81;
    }
#line 311
    if ((int )tmp___3 == 82) {
#line 311
      goto case_82;
    }
#line 294
    goto switch_break___0;
    case_73: /* CIL Label */ 
    {
#line 300
    trap_immediate_termination();
    }
#line 301
    goto switch_break___0;
    case_68: /* CIL Label */ 
    {
#line 303
    trap_dump_core();
    }
#line 304
    goto switch_break___0;
    case_81: /* CIL Label */ 
    case_78: /* CIL Label */ 
    case_0___0: /* CIL Label */ 
    {
#line 309
    trap_normal_termination();
    }
#line 310
    goto switch_break___0;
    case_82: /* CIL Label */ 
    {
#line 312
    trap_recover();
    }
#line 313
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 343 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxtrap.c"
static void continue_from_trap(int signo , siginfo_t *info , ucontext_t *scp ) 
{ 
  unsigned long pc ;
  SCHEME_OBJECT primitive ;
  SCHEME_OBJECT *block_addr ;
  unsigned int index___0 ;
  SCHEME_OBJECT *new_sp ;
  struct trap_recovery_info recovery_info ;
  enum pc_location tmp ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;
  SCHEME_OBJECT *tmp___2 ;
  unsigned long *scan ;
  unsigned long *end ;
  SCHEME_OBJECT *tmp___3 ;
  unsigned long *tmp___4 ;

  {
  {
#line 346
  pc = (unsigned long )scp->uc_mcontext.gregs[16];
#line 347
  primitive = Registers[8];
#line 350
  new_sp = (SCHEME_OBJECT *)0;
#line 358
  tmp = classify_pc(pc, & block_addr, & index___0);
  }
  {
#line 360
  if ((unsigned int )tmp == 4U) {
#line 360
    goto case_4;
  }
#line 367
  if ((unsigned int )tmp == 1U) {
#line 367
    goto case_1;
  }
#line 367
  if ((unsigned int )tmp == 0U) {
#line 367
    goto case_1;
  }
#line 378
  if ((unsigned int )tmp == 3U) {
#line 378
    goto case_3;
  }
#line 385
  if ((unsigned int )tmp == 2U) {
#line 385
    goto case_2;
  }
#line 393
  if ((unsigned int )tmp == 5U) {
#line 393
    goto case_5;
  }
#line 358
  goto switch_break;
  case_4: /* CIL Label */ 
#line 361
  new_sp = stack_pointer;
  {
#line 362
  while (1) {
    while_continue: /* CIL Label */ ;
#line 362
    recovery_info.state = (26UL << 58U) | 1UL;
#line 362
    recovery_info.pc_info_1 = primitive;
#line 362
    recovery_info.pc_info_2 = (26UL << 58U) | Registers[7];
#line 362
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 364
  goto switch_break;
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 369
  new_sp = (SCHEME_OBJECT *)scp->uc_mcontext.gregs[15];
#line 370
  Free = (SCHEME_OBJECT *)scp->uc_mcontext.gregs[8];
  {
#line 371
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 371
    recovery_info.state = (26UL << 58U) | 2UL;
#line 371
    recovery_info.pc_info_1 = (61UL << 58U) | (SCHEME_OBJECT )block_addr;
#line 371
    recovery_info.pc_info_2 = (26UL << 58U) | (pc - (unsigned long )block_addr);
#line 371
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 375
  goto switch_break;
  case_3: /* CIL Label */ 
#line 380
  new_sp = stack_pointer;
  {
#line 381
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 381
    recovery_info.state = (26UL << 58U) | 5UL;
#line 381
    recovery_info.pc_info_1 = (26UL << 58U) | (unsigned long )index___0;
#line 381
    recovery_info.pc_info_2 = (8UL << 58U) | 1UL;
#line 381
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 382
  goto switch_break;
  case_2: /* CIL Label */ 
#line 387
  new_sp = (SCHEME_OBJECT *)scp->uc_mcontext.gregs[15];
#line 388
  Free = (SCHEME_OBJECT *)scp->uc_mcontext.gregs[8];
  {
#line 389
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 389
    recovery_info.state = (26UL << 58U) | 4UL;
#line 389
    recovery_info.pc_info_1 = (26UL << 58U) | (unsigned long )index___0;
#line 389
    recovery_info.pc_info_2 = (8UL << 58U) | 1UL;
#line 389
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 390
  goto switch_break;
  case_5: /* CIL Label */ 
#line 394
  new_sp = (SCHEME_OBJECT *)0;
  {
#line 395
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 395
    recovery_info.state = 26UL << 58U;
#line 395
    recovery_info.pc_info_1 = (26UL << 58U) | pc;
#line 395
    recovery_info.pc_info_2 = (8UL << 58U) | 1UL;
#line 395
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 399
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 403
  if ((unsigned long )new_sp >= (unsigned long )stack_start) {
#line 403
    if ((unsigned long )new_sp < (unsigned long )stack_end) {
#line 403
      if (! (((unsigned long )new_sp & (sizeof(SCHEME_OBJECT ) - 1UL)) == 0UL)) {
#line 404
        new_sp = (SCHEME_OBJECT *)0;
      }
    } else {
#line 404
      new_sp = (SCHEME_OBJECT *)0;
    }
  } else {
#line 404
    new_sp = (SCHEME_OBJECT *)0;
  }
#line 407
  if ((unsigned long )new_sp != (unsigned long )((SCHEME_OBJECT *)0)) {
#line 407
    if ((unsigned long )Free >= (unsigned long )heap_start) {
#line 407
      if ((unsigned long )Free < (unsigned long )heap_end) {
#line 407
        if (! (((unsigned long )Free & (sizeof(SCHEME_OBJECT ) - 1UL)) == 0UL)) {
#line 415
          Free = heap_alloc_limit;
        }
      } else {
#line 415
        Free = heap_alloc_limit;
      }
    } else {
#line 415
      Free = heap_alloc_limit;
    }
  } else {
#line 415
    Free = heap_alloc_limit;
  }
#line 419
  recovery_info.extra_trap_info = (22UL << 58U) | (SCHEME_OBJECT )Free;
#line 421
  tmp___0 = Free;
#line 421
  Free ++;
#line 421
  *tmp___0 = (39UL << 58U) | 25UL;
#line 423
  tmp___1 = Free;
#line 423
  Free ++;
#line 423
  *tmp___1 = pc;
#line 424
  tmp___2 = Free;
#line 424
  Free ++;
#line 424
  *tmp___2 = (SCHEME_OBJECT )scp->uc_mcontext.gregs[15];
#line 426
  scan = (unsigned long *)(& scp->uc_mcontext.gregs[0]);
#line 428
  end = scan + 23;
  {
#line 429
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 429
    if (! ((unsigned long )scan < (unsigned long )end)) {
#line 429
      goto while_break___4;
    }
#line 430
    tmp___3 = Free;
#line 430
    Free ++;
#line 430
    tmp___4 = scan;
#line 430
    scan ++;
#line 430
    *tmp___3 = *tmp___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 433
  setup_trap_frame(signo, info, scp, & recovery_info, new_sp);
  }
#line 434
  return;
}
}
#line 440 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxtrap.c"
static SCHEME_OBJECT *find_heap_address(unsigned long pc ) 
{ 
  SCHEME_OBJECT *tmp ;

  {
  {
#line 443
  tmp = find_block_address(pc, heap_start);
  }
#line 443
  return (tmp);
}
}
#line 446 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxtrap.c"
static SCHEME_OBJECT *find_constant_address(unsigned long pc ) 
{ 
  SCHEME_OBJECT *tmp ;

  {
  {
#line 449
  tmp = find_block_address(pc, constant_start);
  }
#line 449
  return (tmp);
}
}
#line 456 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxtrap.c"
static SCHEME_OBJECT *find_block_address(unsigned long pc , SCHEME_OBJECT *area_start ) 
{ 
  SCHEME_OBJECT *pcp ;
  SCHEME_OBJECT *first_valid ;
  SCHEME_OBJECT *area ;
  SCHEME_OBJECT object ;
  unsigned long count ;
  unsigned long tmp ;
  linkage_section_type_t tmp___0 ;
  unsigned long count___0 ;
  SCHEME_OBJECT *block ;
  SCHEME_OBJECT *tmp___2 ;
  int tmp___3 ;

  {
#line 459
  pcp = (SCHEME_OBJECT *)(pc & ~ (sizeof(SCHEME_OBJECT ) - 1UL));
#line 460
  first_valid = area_start;
#line 461
  area = area_start;
  {
#line 463
  while (1) {
    while_continue: /* CIL Label */ ;
#line 463
    if (! ((unsigned long )area < (unsigned long )pcp)) {
#line 463
      goto while_break;
    }
#line 465
    object = *area;
    {
#line 468
    if (object >> 58U == 57UL) {
#line 468
      goto case_57;
    }
#line 486
    if (object >> 58U == 13UL) {
#line 486
      goto case_13;
    }
#line 490
    if (object >> 58U == 39UL) {
#line 490
      goto case_39;
    }
#line 513
    goto switch_default___0;
    case_57: /* CIL Label */ 
    {
#line 470
    tmp = linkage_section_count(object);
#line 470
    count = tmp;
#line 471
    area ++;
#line 472
    tmp___0 = linkage_section_type(object);
    }
    {
#line 475
    if ((unsigned int )tmp___0 == 0U) {
#line 475
      goto case_0;
    }
#line 475
    if ((unsigned int )tmp___0 == 3U) {
#line 475
      goto case_0;
    }
#line 479
    goto switch_default;
    case_0: /* CIL Label */ 
    case_3: /* CIL Label */ 
#line 476
    area += count * 3UL;
#line 477
    goto switch_break___0;
    switch_default: /* CIL Label */ 
#line 480
    area += count;
#line 481
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 484
    goto switch_break;
    case_13: /* CIL Label */ 
    {
#line 487
    area = compiled_closure_objects(area + 1);
    }
#line 488
    goto switch_break;
    case_39: /* CIL Label */ 
#line 492
    count___0 = object & 288230376151711743UL;
#line 493
    if ((unsigned long )(area + (count___0 + 1UL)) < (unsigned long )pcp) {
#line 495
      area += count___0 + 1UL;
#line 496
      first_valid = area;
    } else {
#line 500
      block = area - 1;
#line 501
      if ((unsigned long )area != (unsigned long )first_valid) {
#line 501
        if (*block >> 58U == 0UL) {
#line 501
          goto _L;
        } else
#line 501
        if (*block >> 58U == 26UL) {
          _L: /* CIL Label */ 
#line 501
          if ((*block & 288230376151711743UL) >= count___0 + 1UL) {
            {
#line 501
            tmp___3 = plausible_cc_block_p(block);
            }
#line 501
            if (tmp___3) {
#line 501
              tmp___2 = block;
            } else {
#line 501
              tmp___2 = (SCHEME_OBJECT *)0;
            }
          } else {
#line 501
            tmp___2 = (SCHEME_OBJECT *)0;
          }
        } else {
#line 501
          tmp___2 = (SCHEME_OBJECT *)0;
        }
      } else {
#line 501
        tmp___2 = (SCHEME_OBJECT *)0;
      }
#line 501
      return (tmp___2);
    }
#line 511
    goto switch_break;
    switch_default___0: /* CIL Label */ 
#line 514
    area ++;
#line 515
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 518
  return ((SCHEME_OBJECT *)0);
}
}
#line 557 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxtrap.c"
static void setup_trap_frame(int signo , siginfo_t *info , ucontext_t *scp , struct trap_recovery_info *trinfo ,
                             SCHEME_OBJECT *new_stack_pointer ) 
{ 
  unsigned long saved_mask ;
  SCHEME_OBJECT handler ;
  SCHEME_OBJECT signal_name ;
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;
  _Bool tmp___2 ;
  char const   *tmp___3 ;
  SCHEME_OBJECT tmp___4 ;
  SCHEME_OBJECT *tmp___5 ;
  SCHEME_OBJECT *tmp___6 ;
  SCHEME_OBJECT *tmp___7 ;
  SCHEME_OBJECT *tmp___8 ;
  SCHEME_OBJECT *tmp___9 ;
  SCHEME_OBJECT *tmp___10 ;
  SCHEME_OBJECT *tmp___11 ;
  SCHEME_OBJECT *tmp___12 ;
  SCHEME_OBJECT *tmp___13 ;
  SCHEME_OBJECT *tmp___14 ;
  SCHEME_OBJECT *tmp___15 ;
  SCHEME_OBJECT *tmp___16 ;
  SCHEME_OBJECT *tmp___17 ;
  SCHEME_OBJECT *tmp___18 ;
  SCHEME_OBJECT *tmp___19 ;
  SCHEME_OBJECT *tmp___20 ;
  SCHEME_OBJECT *tmp___21 ;
  SCHEME_OBJECT *tmp___22 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;

  {
#line 564
  saved_mask = Registers[1];
  {
#line 568
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 568
    set_ulong_register(1U, 0UL);
    }
    {
#line 568
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 568
      if ((Registers[1] & Registers[12]) != 0UL) {
#line 568
        tmp___0 = memory_block_start;
      } else {
#line 568
        if ((Registers[1] & 4UL) != 0UL) {
#line 568
          tmp = heap_alloc_limit;
        } else {
#line 568
          tmp = heap_end;
        }
#line 568
        tmp___0 = tmp;
      }
      {
#line 568
      set_ptr_register(0U, tmp___0);
      }
#line 568
      if ((Registers[1] & 1UL) != 0UL) {
#line 568
        tmp___1 = stack_guard;
      } else {
#line 568
        tmp___1 = stack_start;
      }
      {
#line 568
      set_ptr_register(11U, tmp___1);
      }
#line 568
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 568
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 570
  if (fixed_objects >> 58U == 10UL) {
#line 570
    handler = *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 13);
  } else {
#line 570
    handler = 0UL;
  }
  {
#line 574
  tmp___2 = interpreter_applicable_p(handler);
  }
#line 574
  if (! tmp___2) {
    {
#line 576
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"There is no trap handler for recovery!\n");
#line 577
    fflush(stderr);
#line 578
    termination_trap();
    }
  }
#line 581
  if (signo != 0) {
    {
#line 581
    tmp___3 = find_signal_name(signo);
#line 581
    tmp___4 = char_pointer_to_string(tmp___3);
#line 581
    signal_name = tmp___4;
    }
  } else {
#line 581
    signal_name = 0UL;
  }
#line 586
  if ((unsigned long )Free >= (unsigned long )heap_start) {
#line 586
    if (! ((unsigned long )Free < (unsigned long )heap_alloc_limit)) {
#line 586
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 587
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 587
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 587
        set_ulong_register(12U, Registers[12] | 4UL);
        }
        {
#line 587
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 587
          if ((Registers[1] & Registers[12]) != 0UL) {
#line 587
            tmp___6 = memory_block_start;
          } else {
#line 587
            if ((Registers[1] & 4UL) != 0UL) {
#line 587
              tmp___5 = heap_alloc_limit;
            } else {
#line 587
              tmp___5 = heap_end;
            }
#line 587
            tmp___6 = tmp___5;
          }
          {
#line 587
          set_ptr_register(0U, tmp___6);
          }
#line 587
          if ((Registers[1] & 1UL) != 0UL) {
#line 587
            tmp___7 = stack_guard;
          } else {
#line 587
            tmp___7 = stack_start;
          }
          {
#line 587
          set_ptr_register(11U, tmp___7);
          }
#line 587
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 587
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 587
      gc_space_needed = 0UL;
#line 587
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 589
  if ((unsigned long )new_stack_pointer != (unsigned long )((SCHEME_OBJECT *)0)) {
#line 590
    stack_pointer = new_stack_pointer;
  } else {
    {
#line 593
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 593
      stack_pointer = stack_end;
#line 593
      *stack_start = (34UL << 58U) | (SCHEME_OBJECT )stack_start;
#line 593
      stack_guard = stack_start + 4096;
      {
#line 593
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 593
        if ((Registers[1] & Registers[12]) != 0UL) {
#line 593
          tmp___9 = memory_block_start;
        } else {
#line 593
          if ((Registers[1] & 4UL) != 0UL) {
#line 593
            tmp___8 = heap_alloc_limit;
          } else {
#line 593
            tmp___8 = heap_end;
          }
#line 593
          tmp___9 = tmp___8;
        }
        {
#line 593
        set_ptr_register(0U, tmp___9);
        }
#line 593
        if ((Registers[1] & 1UL) != 0UL) {
#line 593
          tmp___10 = stack_guard;
        } else {
#line 593
          tmp___10 = stack_start;
        }
        {
#line 593
        set_ptr_register(11U, tmp___10);
        }
#line 593
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 593
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 594
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 594
      if (! ((unsigned long )(stack_pointer + -2) >= (unsigned long )stack_guard)) {
        {
#line 594
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 594
          if (*stack_start != ((34UL << 58U) | (SCHEME_OBJECT )stack_start)) {
            {
#line 594
            stack_death("STACK_CHECK");
            }
          }
#line 594
          goto while_break___7;
        }
        while_break___7: /* CIL Label */ ;
        }
        {
#line 594
        while (1) {
          while_continue___8: /* CIL Label */ ;
          {
#line 594
          set_ulong_register(12U, Registers[12] | 1UL);
          }
          {
#line 594
          while (1) {
            while_continue___9: /* CIL Label */ ;
#line 594
            if ((Registers[1] & Registers[12]) != 0UL) {
#line 594
              tmp___12 = memory_block_start;
            } else {
#line 594
              if ((Registers[1] & 4UL) != 0UL) {
#line 594
                tmp___11 = heap_alloc_limit;
              } else {
#line 594
                tmp___11 = heap_end;
              }
#line 594
              tmp___12 = tmp___11;
            }
            {
#line 594
            set_ptr_register(0U, tmp___12);
            }
#line 594
            if ((Registers[1] & 1UL) != 0UL) {
#line 594
              tmp___13 = stack_guard;
            } else {
#line 594
              tmp___13 = stack_start;
            }
            {
#line 594
            set_ptr_register(11U, tmp___13);
            }
#line 594
            goto while_break___9;
          }
          while_break___9: /* CIL Label */ ;
          }
#line 594
          goto while_break___8;
        }
        while_break___8: /* CIL Label */ ;
        }
      }
#line 594
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 595
    Registers[6] = 11UL << 58U;
#line 596
    Registers[5] = 0UL;
    {
#line 597
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 597
      stack_pointer --;
#line 597
      *stack_pointer = Registers[5];
#line 597
      stack_pointer --;
#line 597
      *stack_pointer = Registers[6];
#line 597
      goto while_break___10;
    }
    while_break___10: /* CIL Label */ ;
    }
  }
  {
#line 601
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 601
    if (! ((unsigned long )(stack_pointer + -9) >= (unsigned long )stack_guard)) {
      {
#line 601
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 601
        if (*stack_start != ((34UL << 58U) | (SCHEME_OBJECT )stack_start)) {
          {
#line 601
          stack_death("STACK_CHECK");
          }
        }
#line 601
        goto while_break___12;
      }
      while_break___12: /* CIL Label */ ;
      }
      {
#line 601
      while (1) {
        while_continue___13: /* CIL Label */ ;
        {
#line 601
        set_ulong_register(12U, Registers[12] | 1UL);
        }
        {
#line 601
        while (1) {
          while_continue___14: /* CIL Label */ ;
#line 601
          if ((Registers[1] & Registers[12]) != 0UL) {
#line 601
            tmp___15 = memory_block_start;
          } else {
#line 601
            if ((Registers[1] & 4UL) != 0UL) {
#line 601
              tmp___14 = heap_alloc_limit;
            } else {
#line 601
              tmp___14 = heap_end;
            }
#line 601
            tmp___15 = tmp___14;
          }
          {
#line 601
          set_ptr_register(0U, tmp___15);
          }
#line 601
          if ((Registers[1] & 1UL) != 0UL) {
#line 601
            tmp___16 = stack_guard;
          } else {
#line 601
            tmp___16 = stack_start;
          }
          {
#line 601
          set_ptr_register(11U, tmp___16);
          }
#line 601
          goto while_break___14;
        }
        while_break___14: /* CIL Label */ ;
        }
#line 601
        goto while_break___13;
      }
      while_break___13: /* CIL Label */ ;
      }
    }
#line 601
    goto while_break___11;
  }
  while_break___11: /* CIL Label */ ;
  }
#line 602
  stack_pointer --;
#line 602
  *stack_pointer = trinfo->extra_trap_info;
#line 603
  stack_pointer --;
#line 603
  *stack_pointer = trinfo->pc_info_2;
#line 604
  stack_pointer --;
#line 604
  *stack_pointer = trinfo->pc_info_1;
#line 605
  stack_pointer --;
#line 605
  *stack_pointer = trinfo->state;
#line 606
  stack_pointer --;
#line 606
  if ((unsigned long )new_stack_pointer != (unsigned long )((SCHEME_OBJECT *)0)) {
#line 606
    *stack_pointer = 8UL << 58U;
  } else {
#line 606
    *stack_pointer = 0UL;
  }
  {
#line 607
  stack_pointer --;
#line 607
  *stack_pointer = find_signal_code_name(signo, info, scp);
#line 608
  stack_pointer --;
#line 608
  *stack_pointer = signal_name;
#line 609
  Registers[6] = (11UL << 58U) | 92UL;
#line 610
  Registers[5] = long_to_integer((long )signo);
  }
  {
#line 611
  while (1) {
    while_continue___15: /* CIL Label */ ;
#line 611
    stack_pointer --;
#line 611
    *stack_pointer = Registers[5];
#line 611
    stack_pointer --;
#line 611
    *stack_pointer = Registers[6];
#line 611
    goto while_break___15;
  }
  while_break___15: /* CIL Label */ ;
  }
#line 614
  if ((unsigned long )new_stack_pointer != (unsigned long )((SCHEME_OBJECT *)0)) {
#line 614
    if (trinfo->state == ((26UL << 58U) | 2UL)) {
      {
#line 617
      stop_history();
      }
    }
  }
  {
#line 618
  history_register = make_dummy_history();
  }
  {
#line 620
  while (1) {
    while_continue___16: /* CIL Label */ ;
#line 620
    if (! ((unsigned long )(stack_pointer + -3) >= (unsigned long )stack_guard)) {
      {
#line 620
      while (1) {
        while_continue___17: /* CIL Label */ ;
#line 620
        if (*stack_start != ((34UL << 58U) | (SCHEME_OBJECT )stack_start)) {
          {
#line 620
          stack_death("STACK_CHECK");
          }
        }
#line 620
        goto while_break___17;
      }
      while_break___17: /* CIL Label */ ;
      }
      {
#line 620
      while (1) {
        while_continue___18: /* CIL Label */ ;
        {
#line 620
        set_ulong_register(12U, Registers[12] | 1UL);
        }
        {
#line 620
        while (1) {
          while_continue___19: /* CIL Label */ ;
#line 620
          if ((Registers[1] & Registers[12]) != 0UL) {
#line 620
            tmp___18 = memory_block_start;
          } else {
#line 620
            if ((Registers[1] & 4UL) != 0UL) {
#line 620
              tmp___17 = heap_alloc_limit;
            } else {
#line 620
              tmp___17 = heap_end;
            }
#line 620
            tmp___18 = tmp___17;
          }
          {
#line 620
          set_ptr_register(0U, tmp___18);
          }
#line 620
          if ((Registers[1] & 1UL) != 0UL) {
#line 620
            tmp___19 = stack_guard;
          } else {
#line 620
            tmp___19 = stack_start;
          }
          {
#line 620
          set_ptr_register(11U, tmp___19);
          }
#line 620
          goto while_break___19;
        }
        while_break___19: /* CIL Label */ ;
        }
#line 620
        goto while_break___18;
      }
      while_break___18: /* CIL Label */ ;
      }
    }
#line 620
    goto while_break___16;
  }
  while_break___16: /* CIL Label */ ;
  }
#line 621
  stack_pointer --;
#line 621
  *stack_pointer = signal_name;
#line 622
  stack_pointer --;
#line 622
  *stack_pointer = handler;
#line 623
  stack_pointer --;
#line 623
  *stack_pointer = 2UL;
  {
#line 626
  while (1) {
    while_continue___20: /* CIL Label */ ;
    {
#line 626
    set_ulong_register(1U, saved_mask);
    }
    {
#line 626
    while (1) {
      while_continue___21: /* CIL Label */ ;
#line 626
      if ((Registers[1] & Registers[12]) != 0UL) {
#line 626
        tmp___21 = memory_block_start;
      } else {
#line 626
        if ((Registers[1] & 4UL) != 0UL) {
#line 626
          tmp___20 = heap_alloc_limit;
        } else {
#line 626
          tmp___20 = heap_end;
        }
#line 626
        tmp___21 = tmp___20;
      }
      {
#line 626
      set_ptr_register(0U, tmp___21);
      }
#line 626
      if ((Registers[1] & 1UL) != 0UL) {
#line 626
        tmp___22 = stack_guard;
      } else {
#line 626
        tmp___22 = stack_start;
      }
      {
#line 626
      set_ptr_register(11U, tmp___22);
      }
#line 626
      goto while_break___21;
    }
    while_break___21: /* CIL Label */ ;
    }
#line 626
    goto while_break___20;
  }
  while_break___20: /* CIL Label */ ;
  }
  {
#line 627
  abort_to_interpreter(-3);
  }
}
}
#line 630 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxtrap.c"
static void initialize_ux_signal_codes(void) 
{ 
  unsigned int i ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;

  {
#line 633
  i = 0U;
#line 634
  ux_signal_codes[i].signo = 8;
#line 634
  ux_signal_codes[i].code_mask = (unsigned long )(~ 0L);
#line 634
  ux_signal_codes[i].code_value = 1UL;
#line 634
  ux_signal_codes[i].name = "integer divide by 0 trap";
#line 634
  i ++;
#line 634
  ux_signal_codes[i].signo = 8;
#line 634
  ux_signal_codes[i].code_mask = (unsigned long )(~ 0L);
#line 634
  ux_signal_codes[i].code_value = 2UL;
#line 634
  ux_signal_codes[i].name = "integer overflow trap";
#line 634
  i ++;
#line 634
  ux_signal_codes[i].signo = 8;
#line 634
  ux_signal_codes[i].code_mask = (unsigned long )(~ 0L);
#line 634
  ux_signal_codes[i].code_value = 3UL;
#line 634
  ux_signal_codes[i].name = "floating-point divide by 0 trap";
#line 634
  i ++;
#line 634
  ux_signal_codes[i].signo = 8;
#line 634
  ux_signal_codes[i].code_mask = (unsigned long )(~ 0L);
#line 634
  ux_signal_codes[i].code_value = 4UL;
#line 634
  ux_signal_codes[i].name = "floating-point overflow trap";
#line 634
  i ++;
#line 634
  ux_signal_codes[i].signo = 8;
#line 634
  ux_signal_codes[i].code_mask = (unsigned long )(~ 0L);
#line 634
  ux_signal_codes[i].code_value = 5UL;
#line 634
  ux_signal_codes[i].name = "floating-point underflow trap";
#line 634
  i ++;
#line 634
  ux_signal_codes[i].signo = 8;
#line 634
  ux_signal_codes[i].code_mask = (unsigned long )(~ 0L);
#line 634
  ux_signal_codes[i].code_value = 6UL;
#line 634
  ux_signal_codes[i].name = "floating-point inexact result";
#line 634
  i ++;
#line 634
  ux_signal_codes[i].signo = 8;
#line 634
  ux_signal_codes[i].code_mask = (unsigned long )(~ 0L);
#line 634
  ux_signal_codes[i].code_value = 8UL;
#line 634
  ux_signal_codes[i].name = "subscript-range trap";
#line 634
  i ++;
#line 634
  ux_signal_codes[i].signo = 8;
#line 634
  ux_signal_codes[i].code_mask = (unsigned long )(~ 0L);
#line 634
  ux_signal_codes[i].code_value = 7UL;
#line 634
  ux_signal_codes[i].name = "invalid floating-point operation";
#line 634
  i ++;
#line 634
  ux_signal_codes[i].signo = 4;
#line 634
  ux_signal_codes[i].code_mask = (unsigned long )(~ 0L);
#line 634
  ux_signal_codes[i].code_value = 1UL;
#line 634
  ux_signal_codes[i].name = "illegal opcode trap";
#line 634
  i ++;
#line 634
  ux_signal_codes[i].signo = 4;
#line 634
  ux_signal_codes[i].code_mask = (unsigned long )(~ 0L);
#line 634
  ux_signal_codes[i].code_value = 2UL;
#line 634
  ux_signal_codes[i].name = "illegal operand trap";
#line 634
  i ++;
#line 634
  ux_signal_codes[i].signo = 4;
#line 634
  ux_signal_codes[i].code_mask = (unsigned long )(~ 0L);
#line 634
  ux_signal_codes[i].code_value = 3UL;
#line 634
  ux_signal_codes[i].name = "illegal addressing mode trap";
#line 634
  i ++;
#line 634
  ux_signal_codes[i].signo = 4;
#line 634
  ux_signal_codes[i].code_mask = (unsigned long )(~ 0L);
#line 634
  ux_signal_codes[i].code_value = 4UL;
#line 634
  ux_signal_codes[i].name = "illegal trap";
#line 634
  i ++;
#line 634
  ux_signal_codes[i].signo = 4;
#line 634
  ux_signal_codes[i].code_mask = (unsigned long )(~ 0L);
#line 634
  ux_signal_codes[i].code_value = 5UL;
#line 634
  ux_signal_codes[i].name = "privileged opcode trap";
#line 634
  i ++;
#line 634
  ux_signal_codes[i].signo = 4;
#line 634
  ux_signal_codes[i].code_mask = (unsigned long )(~ 0L);
#line 634
  ux_signal_codes[i].code_value = 6UL;
#line 634
  ux_signal_codes[i].name = "privileged register trap";
#line 634
  i ++;
#line 634
  ux_signal_codes[i].signo = 4;
#line 634
  ux_signal_codes[i].code_mask = (unsigned long )(~ 0L);
#line 634
  ux_signal_codes[i].code_value = 7UL;
#line 634
  ux_signal_codes[i].name = "co-processor trap";
#line 634
  i ++;
#line 634
  ux_signal_codes[i].signo = 4;
#line 634
  ux_signal_codes[i].code_mask = (unsigned long )(~ 0L);
#line 634
  ux_signal_codes[i].code_value = 8UL;
#line 634
  ux_signal_codes[i].name = "bad stack trap";
#line 634
  i ++;
#line 634
  ux_signal_codes[i].signo = 11;
#line 634
  ux_signal_codes[i].code_mask = (unsigned long )(~ 0L);
#line 634
  ux_signal_codes[i].code_value = 1UL;
#line 634
  ux_signal_codes[i].name = "address not mapped to object";
#line 634
  i ++;
#line 634
  ux_signal_codes[i].signo = 11;
#line 634
  ux_signal_codes[i].code_mask = (unsigned long )(~ 0L);
#line 634
  ux_signal_codes[i].code_value = 2UL;
#line 634
  ux_signal_codes[i].name = "invalid permissions for mapped object";
#line 634
  i ++;
#line 634
  ux_signal_codes[i].signo = 7;
#line 634
  ux_signal_codes[i].code_mask = (unsigned long )(~ 0L);
#line 634
  ux_signal_codes[i].code_value = 1UL;
#line 634
  ux_signal_codes[i].name = "invalid address alignment";
#line 634
  i ++;
#line 634
  ux_signal_codes[i].signo = 7;
#line 634
  ux_signal_codes[i].code_mask = (unsigned long )(~ 0L);
#line 634
  ux_signal_codes[i].code_value = 2UL;
#line 634
  ux_signal_codes[i].name = "nonexistent physical address";
#line 634
  i ++;
#line 634
  ux_signal_codes[i].signo = 7;
#line 634
  ux_signal_codes[i].code_mask = (unsigned long )(~ 0L);
#line 634
  ux_signal_codes[i].code_value = 3UL;
#line 634
  ux_signal_codes[i].name = "object-specific hardware error";
#line 634
  i ++;
#line 634
  ux_signal_codes[i].signo = 5;
#line 634
  ux_signal_codes[i].code_mask = (unsigned long )(~ 0L);
#line 634
  ux_signal_codes[i].code_value = 1UL;
#line 634
  ux_signal_codes[i].name = "process breakpoint";
#line 634
  i ++;
#line 634
  ux_signal_codes[i].signo = 5;
#line 634
  ux_signal_codes[i].code_mask = (unsigned long )(~ 0L);
#line 634
  ux_signal_codes[i].code_value = 2UL;
#line 634
  ux_signal_codes[i].name = "process trace trap";
#line 634
  i ++;
#line 637
  ux_signal_codes[i].signo = -1;
#line 637
  ux_signal_codes[i].code_mask = (unsigned long )(~ 0L);
#line 637
  ux_signal_codes[i].code_value = 0UL;
#line 637
  ux_signal_codes[i].name = "signal sent by kill";
#line 637
  i ++;
#line 639
  ux_signal_codes[i].signo = -1;
#line 639
  ux_signal_codes[i].code_mask = (unsigned long )(~ 0L);
#line 639
  ux_signal_codes[i].code_value = 0xffffffffffffffffUL;
#line 639
  ux_signal_codes[i].name = "signal sent by sigqueue";
#line 639
  i ++;
#line 641
  ux_signal_codes[i].signo = -1;
#line 641
  ux_signal_codes[i].code_mask = (unsigned long )(~ 0L);
#line 641
  ux_signal_codes[i].code_value = 0xfffffffffffffffeUL;
#line 641
  ux_signal_codes[i].name = "signal generated by timer expiration";
#line 641
  i ++;
#line 643
  ux_signal_codes[i].signo = -1;
#line 643
  ux_signal_codes[i].code_mask = (unsigned long )(~ 0L);
#line 643
  ux_signal_codes[i].code_value = 0xfffffffffffffffcUL;
#line 643
  ux_signal_codes[i].name = "signal generated by asynchronous I/O completion";
#line 643
  i ++;
#line 645
  ux_signal_codes[i].signo = -1;
#line 645
  ux_signal_codes[i].code_mask = (unsigned long )(~ 0L);
#line 645
  ux_signal_codes[i].code_value = 0xfffffffffffffffdUL;
#line 645
  ux_signal_codes[i].name = "signal generated by message queue arrival";
#line 645
  i ++;
#line 649
  ux_signal_codes[i].signo = 0;
#line 649
  ux_signal_codes[i].code_mask = 0UL;
#line 649
  ux_signal_codes[i].code_value = 0UL;
#line 649
  ux_signal_codes[i].name = (char const   *)0;
#line 649
  i ++;
#line 650
  return;
}
}
#line 652 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxtrap.c"
static SCHEME_OBJECT find_signal_code_name(int signo , siginfo_t *info , ucontext_t *scp ) 
{ 
  unsigned long code ;
  char const   *name ;
  struct ux_sig_code_desc *entry ;
  SCHEME_OBJECT tmp ;
  unsigned long tmp___0 ;
  SCHEME_OBJECT tmp___1 ;
  SCHEME_OBJECT tmp___2 ;

  {
#line 655
  code = 0UL;
#line 656
  name = (char const   *)0;
#line 659
  code = (unsigned long )info->si_code;
#line 661
  if ((unsigned long )name == (unsigned long )((char const   *)0)) {
#line 663
    entry = & ux_signal_codes[0];
    {
#line 664
    while (1) {
      while_continue: /* CIL Label */ ;
#line 664
      if (! (entry->signo != 0)) {
#line 664
        goto while_break;
      }
#line 665
      if (entry->signo < 0) {
#line 665
        goto _L;
      } else
#line 665
      if (entry->signo == signo) {
        _L: /* CIL Label */ 
#line 665
        if ((entry->code_mask & code) == entry->code_value) {
#line 668
          name = entry->name;
#line 669
          goto while_break;
        } else {
#line 672
          entry ++;
        }
      } else {
#line 672
        entry ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 675
  if ((unsigned long )name == (unsigned long )((char const   *)0)) {
#line 675
    tmp___0 = 0UL;
  } else {
    {
#line 675
    tmp = char_pointer_to_string(name);
#line 675
    tmp___0 = tmp;
    }
  }
  {
#line 675
  tmp___1 = ulong_to_integer(code);
#line 675
  tmp___2 = cons(tmp___1, tmp___0);
  }
#line 675
  return (tmp___2);
}
}
#line 682 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxtrap.c"
static enum pc_location classify_pc(unsigned long pc , SCHEME_OBJECT **r_block_addr ,
                                    unsigned int *r_index ) 
{ 
  SCHEME_OBJECT *block_addr ;
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT *block_addr___0 ;
  SCHEME_OBJECT *tmp___0 ;
  int index___0 ;
  int tmp___1 ;

  {
#line 690
  if ((unsigned long )((SCHEME_OBJECT *)pc) >= (unsigned long )heap_start) {
#line 690
    if ((unsigned long )((SCHEME_OBJECT *)pc) < (unsigned long )Free) {
      {
#line 692
      tmp = find_heap_address(pc);
#line 692
      block_addr = tmp;
      }
#line 693
      if ((unsigned long )block_addr == (unsigned long )((SCHEME_OBJECT *)0)) {
#line 694
        return ((enum pc_location )5);
      }
#line 695
      if ((unsigned long )r_block_addr != (unsigned long )((SCHEME_OBJECT **)0)) {
#line 696
        *r_block_addr = block_addr;
      }
#line 697
      return ((enum pc_location )0);
    }
  }
#line 699
  if ((unsigned long )((SCHEME_OBJECT *)pc) >= (unsigned long )constant_start) {
#line 699
    if ((unsigned long )((SCHEME_OBJECT *)pc) < (unsigned long )constant_end) {
      {
#line 701
      tmp___0 = find_constant_address(pc);
#line 701
      block_addr___0 = tmp___0;
      }
#line 702
      if ((unsigned long )block_addr___0 == (unsigned long )((SCHEME_OBJECT *)0)) {
#line 703
        return ((enum pc_location )5);
      }
#line 704
      if ((unsigned long )r_block_addr != (unsigned long )((SCHEME_OBJECT **)0)) {
#line 705
        *r_block_addr = block_addr___0;
      }
#line 706
      return ((enum pc_location )1);
    }
  }
#line 708
  if ((unsigned long )((unsigned int *)pc) >= (unsigned long )(& _init)) {
#line 708
    if ((unsigned long )((unsigned int *)pc) <= (unsigned long )(& etext)) {
      {
#line 710
      tmp___1 = pc_to_builtin_index(pc);
#line 710
      index___0 = tmp___1;
      }
#line 711
      if (index___0 >= 0) {
#line 713
        if ((unsigned long )r_index != (unsigned long )((unsigned int *)0)) {
#line 714
          *r_index = (unsigned int )index___0;
        }
#line 715
        return ((enum pc_location )2);
      }
      {
#line 717
      index___0 = pc_to_utility_index(pc);
      }
#line 718
      if (index___0 >= 0) {
#line 720
        if ((unsigned long )r_index != (unsigned long )((unsigned int *)0)) {
#line 721
          *r_index = (unsigned int )index___0;
        }
#line 722
        return ((enum pc_location )3);
      }
#line 724
      if (Registers[8] >> 58U == 24UL) {
#line 725
        return ((enum pc_location )4);
      }
    }
  }
#line 733
  return ((enum pc_location )5);
}
}
#line 736 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxtrap.c"
static void trap_normal_termination(void) 
{ 


  {
  {
#line 739
  trap_state = (enum trap_state )5;
#line 740
  termination_trap();
  }
}
}
#line 743 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxtrap.c"
static void trap_immediate_termination(void) 
{ 


  {
  {
#line 746
  trap_state = (enum trap_state )6;
#line 747
  OS_restore_external_state();
#line 748
  exit(1);
  }
}
}
#line 751 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxtrap.c"
static void trap_dump_core(void) 
{ 


  {
#line 754
  if (! option_disable_core_dump) {
    {
#line 755
    UX_dump_core();
    }
  } else {
    {
#line 758
    fputs((char const   */* __restrict  */)">> Core dumps are disabled - Terminating normally.\n",
          (FILE */* __restrict  */)stdout);
#line 759
    fflush(stdout);
#line 760
    termination_trap();
    }
  }
#line 762
  return;
}
}
#line 764 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxtrap.c"
static void trap_recover(void) 
{ 
  char const   *name ;

  {
#line 767
  if ((unsigned long )critical_section_name != (unsigned long )((char const   *)0)) {
#line 769
    critical_section_hook_p = (_Bool)0;
    {
#line 770
    while (1) {
      while_continue: /* CIL Label */ ;
#line 770
      if (critical_section_hook_p) {
        {
#line 770
        name = critical_section_name;
#line 770
        critical_section_hook_p = (_Bool)0;
#line 770
        critical_section_name = (char const   *)0;
#line 770
        (*critical_section_hook)(name);
        }
      } else {
#line 770
        critical_section_name = (char const   *)0;
      }
#line 770
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 772
  reset_interruptable_extent();
#line 773
  continue_from_trap(saved_signo, saved_info, saved_scp);
  }
#line 774
  return;
}
}
#line 94 "/usr/include/x86_64-linux-gnu/sys/mman.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) madvise)(void *__addr ,
                                                                              size_t __len ,
                                                                              int __advice ) ;
#line 98
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) posix_madvise)(void *__addr ,
                                                                                    size_t __len ,
                                                                                    int __advice ) ;
#line 515 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 413 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 978 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getpagesize)(void)  __attribute__((__const__)) ;
#line 40 "/home/khheo/project/mit-scheme-9.2/src/microcode/intext.h"
void initialize_interruptable_extent(void) ;
#line 174 "/home/khheo/project/mit-scheme-9.2/src/microcode/syscall.h"
enum syserr_names OS_error_code_to_syserr(int code ) ;
#line 32 "/home/khheo/project/mit-scheme-9.2/src/microcode/ostop.h"
int OS_under_emacs_p(void) ;
#line 33
void OS_initialize(void) ;
#line 34
void OS_reset(void) ;
#line 35
void OS_quit(int code , int abnormal_p ) ;
#line 37
void OS_save_external_state(void) ;
#line 38
void OS_save_internal_state(void) ;
#line 39
void OS_restore_internal_state(void) ;
#line 41
char const   *OS_error_code_to_message(unsigned int syserr ) ;
#line 42
void OS_expect_sequential_access(void *start , void *end ) ;
#line 43
void OS_expect_normal_access(void *start , void *end ) ;
#line 44
void OS_free_pages(void *start , void *end ) ;
#line 34 "/home/khheo/project/mit-scheme-9.2/src/microcode/osctty.h"
int OS_ctty_interrupt_control(void) ;
#line 39 "/home/khheo/project/mit-scheme-9.2/src/microcode/option.h"
_Bool option_force_interactive ;
#line 41
_Bool option_batch_mode ;
#line 182 "/home/khheo/project/mit-scheme-9.2/src/microcode/extern.h"
char const   *OS_Name ;
#line 183
char const   *OS_Variant ;
#line 314
void execute_reload_cleanups(void) ;
#line 44 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxtop.c"
void UX_initialize_channels(void) ;
#line 45
void UX_initialize_ctty(int interactive___0 ) ;
#line 46
void UX_initialize_directory_reader(void) ;
#line 47
void UX_initialize_environment(void) ;
#line 48
void UX_initialize_processes(void) ;
#line 49
void UX_initialize_signals(void) ;
#line 50
void UX_initialize_terminals(void) ;
#line 55
void UX_reset_channels(void) ;
#line 56
void UX_reset_processes(void) ;
#line 57
void UX_reset_terminals(void) ;
#line 59
cc_t OS_ctty_quit_char(void) ;
#line 60
void UX_ctty_save_external_state(void) ;
#line 61
void UX_ctty_save_internal_state(void) ;
#line 62
void UX_ctty_restore_internal_state(void) ;
#line 63
void UX_ctty_restore_external_state(void) ;
#line 65 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxtop.c"
static int interactive  ;
#line 67 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxtop.c"
int OS_under_emacs_p(void) 
{ 


  {
#line 70
  return ((int )option_emacs_subprocess);
}
}
#line 73 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxtop.c"
void OS_initialize(void) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 76
  initialize_interruptable_extent();
  }
#line 78
  if (option_force_interactive) {
#line 78
    tmp___2 = 1;
  } else {
    {
#line 78
    tmp = isatty(0);
    }
#line 78
    if (tmp) {
#line 78
      tmp___2 = 1;
    } else {
      {
#line 78
      tmp___0 = isatty(1);
      }
#line 78
      if (tmp___0) {
#line 78
        tmp___2 = 1;
      } else {
        {
#line 78
        tmp___1 = isatty(2);
        }
#line 78
        if (tmp___1) {
#line 78
          tmp___2 = 1;
        } else {
#line 78
          tmp___2 = 0;
        }
      }
    }
  }
#line 78
  interactive = tmp___2;
#line 83
  if (option_batch_mode) {
#line 84
    interactive = 0;
  }
  {
#line 88
  UX_initialize_ctty(interactive);
#line 90
  UX_initialize_channels();
#line 91
  UX_initialize_terminals();
#line 92
  UX_initialize_environment();
#line 93
  UX_initialize_tty();
#line 94
  UX_initialize_userio();
#line 95
  UX_initialize_signals();
#line 96
  UX_initialize_processes();
#line 97
  UX_initialize_trap_recovery();
#line 98
  UX_initialize_directory_reader();
#line 99
  OS_Name = "unix";
#line 100
  OS_Variant = "GNU/Linux";
  }
#line 114
  return;
}
}
#line 116 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxtop.c"
void OS_announcement(void) 
{ 
  cc_t tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;

  {
#line 119
  if (! option_emacs_subprocess) {
    {
#line 119
    tmp___1 = OS_ctty_interrupt_control();
    }
#line 119
    if (tmp___1) {
      {
#line 120
      tmp = OS_ctty_quit_char();
#line 120
      tmp___0 = char_description(tmp, 1);
#line 120
      fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Type %s followed by `H\' to obtain information about interrupts.\n",
              tmp___0);
      }
    }
  }
#line 124
  return;
}
}
#line 126 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxtop.c"
void OS_reset(void) 
{ 


  {
  {
#line 131
  UX_reset_channels();
#line 132
  UX_reset_terminals();
#line 133
  UX_reset_processes();
#line 134
  execute_reload_cleanups();
  }
#line 135
  return;
}
}
#line 137 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxtop.c"
void OS_quit(int code , int abnormal_p ) 
{ 
  int dump_core ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 140
  fflush(stdout);
  }
#line 141
  if (abnormal_p) {
#line 141
    if (interactive) {
#line 141
      if (! (code == 22)) {
#line 141
        if (! (code == 14)) {
          {
#line 145
          fputs((char const   */* __restrict  */)"\nScheme has terminated abnormally!\n",
                (FILE */* __restrict  */)stdout);
          }
#line 147
          if (! option_disable_core_dump) {
            {
#line 147
            tmp = userio_confirm("Would you like a core dump? [Y or N] ");
            }
#line 147
            if (tmp) {
              {
#line 147
              tmp___0 = userio_confirm("Do you really want a core dump? [Y or N] ");
              }
#line 147
              if (tmp___0) {
#line 147
                tmp___1 = 1;
              } else {
#line 147
                tmp___1 = 0;
              }
            } else {
#line 147
              tmp___1 = 0;
            }
          } else {
#line 147
            tmp___1 = 0;
          }
          {
#line 147
          dump_core = tmp___1;
#line 151
          _IO_putc('\n', stdout);
#line 152
          fflush(stdout);
          }
#line 153
          if (dump_core) {
            {
#line 154
            UX_dump_core();
            }
          }
        }
      }
    }
  }
  {
#line 157
  OS_restore_external_state();
  }
#line 158
  return;
}
}
#line 160 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxtop.c"
void UX_dump_core(void) 
{ 


  {
  {
#line 163
  OS_restore_external_state();
#line 165
  signal(6, (void (*)(int  ))0);
#line 166
  abort();
  }
}
}
#line 169 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxtop.c"
void OS_save_external_state(void) 
{ 


  {
  {
#line 172
  UX_ctty_save_external_state();
  }
#line 173
  return;
}
}
#line 175 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxtop.c"
void OS_save_internal_state(void) 
{ 


  {
  {
#line 178
  UX_ctty_save_internal_state();
  }
#line 179
  return;
}
}
#line 181 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxtop.c"
void OS_restore_internal_state(void) 
{ 


  {
  {
#line 184
  UX_ctty_restore_internal_state();
  }
#line 185
  return;
}
}
#line 187 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxtop.c"
void OS_restore_external_state(void) 
{ 


  {
  {
#line 190
  UX_ctty_restore_external_state();
  }
#line 191
  return;
}
}
#line 252 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxtop.c"
enum syserr_names OS_error_code_to_syserr(int code ) 
{ 


  {
  {
#line 257
  if (code == 7) {
#line 257
    goto case_7;
  }
#line 258
  if (code == 13) {
#line 258
    goto case_13;
  }
#line 260
  if (code == 98) {
#line 260
    goto case_98;
  }
#line 263
  if (code == 99) {
#line 263
    goto case_99;
  }
#line 266
  if (code == 97) {
#line 266
    goto case_97;
  }
#line 268
  if (code == 11) {
#line 268
    goto case_11;
  }
#line 269
  if (code == 9) {
#line 269
    goto case_9;
  }
#line 270
  if (code == 16) {
#line 270
    goto case_16;
  }
#line 271
  if (code == 10) {
#line 271
    goto case_10;
  }
#line 273
  if (code == 111) {
#line 273
    goto case_111;
  }
#line 276
  if (code == 104) {
#line 276
    goto case_104;
  }
#line 278
  if (code == 35) {
#line 278
    goto case_35;
  }
#line 279
  if (code == 33) {
#line 279
    goto case_33;
  }
#line 280
  if (code == 17) {
#line 280
    goto case_17;
  }
#line 281
  if (code == 14) {
#line 281
    goto case_14;
  }
#line 282
  if (code == 27) {
#line 282
    goto case_27;
  }
#line 284
  if (code == 113) {
#line 284
    goto case_113;
  }
#line 286
  if (code == 4) {
#line 286
    goto case_4;
  }
#line 287
  if (code == 22) {
#line 287
    goto case_22;
  }
#line 288
  if (code == 5) {
#line 288
    goto case_5;
  }
#line 289
  if (code == 21) {
#line 289
    goto case_21;
  }
#line 290
  if (code == 24) {
#line 290
    goto case_24;
  }
#line 291
  if (code == 31) {
#line 291
    goto case_31;
  }
#line 293
  if (code == 36) {
#line 293
    goto case_36;
  }
#line 295
  if (code == 23) {
#line 295
    goto case_23;
  }
#line 296
  if (code == 19) {
#line 296
    goto case_19;
  }
#line 297
  if (code == 2) {
#line 297
    goto case_2;
  }
#line 298
  if (code == 8) {
#line 298
    goto case_8;
  }
#line 300
  if (code == 37) {
#line 300
    goto case_37;
  }
#line 302
  if (code == 12) {
#line 302
    goto case_12;
  }
#line 303
  if (code == 28) {
#line 303
    goto case_28;
  }
#line 304
  if (code == 38) {
#line 304
    goto case_38;
  }
#line 305
  if (code == 20) {
#line 305
    goto case_20;
  }
#line 307
  if (code == 39) {
#line 307
    goto case_39;
  }
#line 309
  if (code == 25) {
#line 309
    goto case_25;
  }
#line 310
  if (code == 6) {
#line 310
    goto case_6;
  }
#line 311
  if (code == 1) {
#line 311
    goto case_1;
  }
#line 312
  if (code == 32) {
#line 312
    goto case_32;
  }
#line 313
  if (code == 34) {
#line 313
    goto case_34;
  }
#line 314
  if (code == 30) {
#line 314
    goto case_30;
  }
#line 315
  if (code == 29) {
#line 315
    goto case_29;
  }
#line 316
  if (code == 3) {
#line 316
    goto case_3;
  }
#line 317
  if (code == 18) {
#line 317
    goto case_18;
  }
#line 318
  goto switch_default;
  case_7: /* CIL Label */ 
#line 257
  return ((enum syserr_names )4);
  case_13: /* CIL Label */ 
#line 258
  return ((enum syserr_names )35);
  case_98: /* CIL Label */ 
#line 260
  return ((enum syserr_names )2);
  case_99: /* CIL Label */ 
#line 263
  return ((enum syserr_names )3);
  case_97: /* CIL Label */ 
#line 266
  return ((enum syserr_names )1);
  case_11: /* CIL Label */ 
#line 268
  return ((enum syserr_names )39);
  case_9: /* CIL Label */ 
#line 269
  return ((enum syserr_names )6);
  case_16: /* CIL Label */ 
#line 270
  return ((enum syserr_names )37);
  case_10: /* CIL Label */ 
#line 271
  return ((enum syserr_names )25);
  case_111: /* CIL Label */ 
#line 273
  return ((enum syserr_names )8);
  case_104: /* CIL Label */ 
#line 276
  return ((enum syserr_names )9);
  case_35: /* CIL Label */ 
#line 278
  return ((enum syserr_names )38);
  case_33: /* CIL Label */ 
#line 279
  return ((enum syserr_names )11);
  case_17: /* CIL Label */ 
#line 280
  return ((enum syserr_names )13);
  case_14: /* CIL Label */ 
#line 281
  return ((enum syserr_names )5);
  case_27: /* CIL Label */ 
#line 282
  return ((enum syserr_names )14);
  case_113: /* CIL Label */ 
#line 284
  return ((enum syserr_names )17);
  case_4: /* CIL Label */ 
#line 286
  return ((enum syserr_names )20);
  case_22: /* CIL Label */ 
#line 287
  return ((enum syserr_names )21);
  case_5: /* CIL Label */ 
#line 288
  return ((enum syserr_names )23);
  case_21: /* CIL Label */ 
#line 289
  return ((enum syserr_names )24);
  case_24: /* CIL Label */ 
#line 290
  return ((enum syserr_names )42);
  case_31: /* CIL Label */ 
#line 291
  return ((enum syserr_names )41);
  case_36: /* CIL Label */ 
#line 293
  return ((enum syserr_names )15);
  case_23: /* CIL Label */ 
#line 295
  return ((enum syserr_names )43);
  case_19: /* CIL Label */ 
#line 296
  return ((enum syserr_names )28);
  case_2: /* CIL Label */ 
#line 297
  return ((enum syserr_names )30);
  case_8: /* CIL Label */ 
#line 298
  return ((enum syserr_names )12);
  case_37: /* CIL Label */ 
#line 300
  return ((enum syserr_names )26);
  case_12: /* CIL Label */ 
#line 302
  return ((enum syserr_names )33);
  case_28: /* CIL Label */ 
#line 303
  return ((enum syserr_names )27);
  case_38: /* CIL Label */ 
#line 304
  return ((enum syserr_names )16);
  case_20: /* CIL Label */ 
#line 305
  return ((enum syserr_names )32);
  case_39: /* CIL Label */ 
#line 307
  return ((enum syserr_names )10);
  case_25: /* CIL Label */ 
#line 309
  return ((enum syserr_names )19);
  case_6: /* CIL Label */ 
#line 310
  return ((enum syserr_names )29);
  case_1: /* CIL Label */ 
#line 311
  return ((enum syserr_names )34);
  case_32: /* CIL Label */ 
#line 312
  return ((enum syserr_names )7);
  case_34: /* CIL Label */ 
#line 313
  return ((enum syserr_names )40);
  case_30: /* CIL Label */ 
#line 314
  return ((enum syserr_names )36);
  case_29: /* CIL Label */ 
#line 315
  return ((enum syserr_names )22);
  case_3: /* CIL Label */ 
#line 316
  return ((enum syserr_names )31);
  case_18: /* CIL Label */ 
#line 317
  return ((enum syserr_names )18);
  switch_default: /* CIL Label */ 
#line 318
  return ((enum syserr_names )0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 322 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxtop.c"
static int syserr_to_error_code(enum syserr_names syserr ) 
{ 


  {
  {
#line 328
  if ((unsigned int )syserr == 1U) {
#line 328
    goto case_1;
  }
#line 331
  if ((unsigned int )syserr == 2U) {
#line 331
    goto case_2;
  }
#line 334
  if ((unsigned int )syserr == 3U) {
#line 334
    goto case_3;
  }
#line 336
  if ((unsigned int )syserr == 4U) {
#line 336
    goto case_4;
  }
#line 337
  if ((unsigned int )syserr == 5U) {
#line 337
    goto case_5;
  }
#line 338
  if ((unsigned int )syserr == 6U) {
#line 338
    goto case_6;
  }
#line 339
  if ((unsigned int )syserr == 7U) {
#line 339
    goto case_7;
  }
#line 341
  if ((unsigned int )syserr == 8U) {
#line 341
    goto case_8;
  }
#line 344
  if ((unsigned int )syserr == 9U) {
#line 344
    goto case_9;
  }
#line 347
  if ((unsigned int )syserr == 10U) {
#line 347
    goto case_10;
  }
#line 349
  if ((unsigned int )syserr == 11U) {
#line 349
    goto case_11;
  }
#line 350
  if ((unsigned int )syserr == 12U) {
#line 350
    goto case_12;
  }
#line 351
  if ((unsigned int )syserr == 13U) {
#line 351
    goto case_13;
  }
#line 352
  if ((unsigned int )syserr == 14U) {
#line 352
    goto case_14;
  }
#line 354
  if ((unsigned int )syserr == 15U) {
#line 354
    goto case_15;
  }
#line 356
  if ((unsigned int )syserr == 16U) {
#line 356
    goto case_16;
  }
#line 358
  if ((unsigned int )syserr == 17U) {
#line 358
    goto case_17;
  }
#line 360
  if ((unsigned int )syserr == 18U) {
#line 360
    goto case_18;
  }
#line 361
  if ((unsigned int )syserr == 19U) {
#line 361
    goto case_19;
  }
#line 362
  if ((unsigned int )syserr == 20U) {
#line 362
    goto case_20;
  }
#line 363
  if ((unsigned int )syserr == 21U) {
#line 363
    goto case_21;
  }
#line 364
  if ((unsigned int )syserr == 22U) {
#line 364
    goto case_22;
  }
#line 365
  if ((unsigned int )syserr == 23U) {
#line 365
    goto case_23;
  }
#line 366
  if ((unsigned int )syserr == 24U) {
#line 366
    goto case_24;
  }
#line 367
  if ((unsigned int )syserr == 25U) {
#line 367
    goto case_25;
  }
#line 369
  if ((unsigned int )syserr == 26U) {
#line 369
    goto case_26;
  }
#line 371
  if ((unsigned int )syserr == 27U) {
#line 371
    goto case_27;
  }
#line 372
  if ((unsigned int )syserr == 28U) {
#line 372
    goto case_28;
  }
#line 373
  if ((unsigned int )syserr == 29U) {
#line 373
    goto case_29;
  }
#line 374
  if ((unsigned int )syserr == 30U) {
#line 374
    goto case_30;
  }
#line 375
  if ((unsigned int )syserr == 31U) {
#line 375
    goto case_31;
  }
#line 376
  if ((unsigned int )syserr == 32U) {
#line 376
    goto case_32;
  }
#line 377
  if ((unsigned int )syserr == 33U) {
#line 377
    goto case_33;
  }
#line 378
  if ((unsigned int )syserr == 34U) {
#line 378
    goto case_34;
  }
#line 379
  if ((unsigned int )syserr == 35U) {
#line 379
    goto case_35;
  }
#line 380
  if ((unsigned int )syserr == 36U) {
#line 380
    goto case_36;
  }
#line 381
  if ((unsigned int )syserr == 37U) {
#line 381
    goto case_37;
  }
#line 382
  if ((unsigned int )syserr == 38U) {
#line 382
    goto case_38;
  }
#line 383
  if ((unsigned int )syserr == 39U) {
#line 383
    goto case_39;
  }
#line 384
  if ((unsigned int )syserr == 40U) {
#line 384
    goto case_40;
  }
#line 385
  if ((unsigned int )syserr == 41U) {
#line 385
    goto case_41;
  }
#line 386
  if ((unsigned int )syserr == 42U) {
#line 386
    goto case_42;
  }
#line 387
  if ((unsigned int )syserr == 43U) {
#line 387
    goto case_43;
  }
#line 388
  goto switch_default;
  case_1: /* CIL Label */ 
#line 328
  return (97);
  case_2: /* CIL Label */ 
#line 331
  return (98);
  case_3: /* CIL Label */ 
#line 334
  return (99);
  case_4: /* CIL Label */ 
#line 336
  return (7);
  case_5: /* CIL Label */ 
#line 337
  return (14);
  case_6: /* CIL Label */ 
#line 338
  return (9);
  case_7: /* CIL Label */ 
#line 339
  return (32);
  case_8: /* CIL Label */ 
#line 341
  return (111);
  case_9: /* CIL Label */ 
#line 344
  return (104);
  case_10: /* CIL Label */ 
#line 347
  return (39);
  case_11: /* CIL Label */ 
#line 349
  return (33);
  case_12: /* CIL Label */ 
#line 350
  return (8);
  case_13: /* CIL Label */ 
#line 351
  return (17);
  case_14: /* CIL Label */ 
#line 352
  return (27);
  case_15: /* CIL Label */ 
#line 354
  return (36);
  case_16: /* CIL Label */ 
#line 356
  return (38);
  case_17: /* CIL Label */ 
#line 358
  return (113);
  case_18: /* CIL Label */ 
#line 360
  return (18);
  case_19: /* CIL Label */ 
#line 361
  return (25);
  case_20: /* CIL Label */ 
#line 362
  return (4);
  case_21: /* CIL Label */ 
#line 363
  return (22);
  case_22: /* CIL Label */ 
#line 364
  return (29);
  case_23: /* CIL Label */ 
#line 365
  return (5);
  case_24: /* CIL Label */ 
#line 366
  return (21);
  case_25: /* CIL Label */ 
#line 367
  return (10);
  case_26: /* CIL Label */ 
#line 369
  return (37);
  case_27: /* CIL Label */ 
#line 371
  return (28);
  case_28: /* CIL Label */ 
#line 372
  return (19);
  case_29: /* CIL Label */ 
#line 373
  return (6);
  case_30: /* CIL Label */ 
#line 374
  return (2);
  case_31: /* CIL Label */ 
#line 375
  return (3);
  case_32: /* CIL Label */ 
#line 376
  return (20);
  case_33: /* CIL Label */ 
#line 377
  return (12);
  case_34: /* CIL Label */ 
#line 378
  return (1);
  case_35: /* CIL Label */ 
#line 379
  return (13);
  case_36: /* CIL Label */ 
#line 380
  return (30);
  case_37: /* CIL Label */ 
#line 381
  return (16);
  case_38: /* CIL Label */ 
#line 382
  return (35);
  case_39: /* CIL Label */ 
#line 383
  return (11);
  case_40: /* CIL Label */ 
#line 384
  return (34);
  case_41: /* CIL Label */ 
#line 385
  return (31);
  case_42: /* CIL Label */ 
#line 386
  return (24);
  case_43: /* CIL Label */ 
#line 387
  return (23);
  switch_default: /* CIL Label */ 
#line 388
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 394 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxtop.c"
char const   *OS_error_code_to_message(unsigned int syserr ) 
{ 
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 397
  if (syserr == 0U) {
#line 397
    tmp___1 = (char *)0;
  } else {
    {
#line 397
    tmp = syserr_to_error_code((enum syserr_names )syserr);
#line 397
    tmp___0 = strerror(tmp);
#line 397
    tmp___1 = tmp___0;
    }
  }
#line 397
  return ((char const   *)tmp___1);
}
}
#line 423 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxtop.c"
static char const   *syscall_names_table[69]  = 
#line 423
  {      "accept",      "bind",      "chdir",      "chmod", 
        "clock_gettime",      "close",      "connect",      "fcntl-getfl", 
        "fcntl-fullfsync",      "fcntl-setfl",      "fdatasync",      "fork", 
        "fstat",      "fstatfs",      "fsync",      "fsync_range", 
        "ftruncate",      "getcwd",      "gethostname",      "gettimeofday", 
        "gmtime",      "ioctl-tiocgpgrp",      "ioctl-tiocsigsend",      "kill", 
        "link",      "listen",      "localtime",      "lseek", 
        "lstat",      "malloc",      "mkdir",      "mktime", 
        "ntp_adjtime",      "ntp_gettime",      "open",      "opendir", 
        "pause",      "pipe",      "read",      "readlink", 
        "realloc",      "rename",      "rmdir",      "select", 
        "setitimer",      "setpgid",      "setsockopt",      "shutdown", 
        "sighold",      "sigprocmask",      "sigsuspend",      "sleep", 
        "socket",      "stat",      "statfs",      "symlink", 
        "sync_file_range",      "tcdrain",      "tcflush",      "tcgetpgrp", 
        "tcsetpgrp",      "terminal-get-state",      "terminal-set-state",      "time", 
        "times",      "unlink",      "utime",      "vfork", 
        "write"};
#line 496 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxtop.c"
void OS_syscall_names(unsigned long *length , char const   ***names ) 
{ 


  {
#line 499
  *length = sizeof(syscall_names_table) / sizeof(char *);
#line 500
  *names = syscall_names_table;
#line 501
  return;
}
}
#line 503 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxtop.c"
static char const   *syserr_names_table[44]  = 
#line 503
  {      "unknown",      "address-family-not-supported",      "address-in-use",      "address-not-available", 
        "arg-list-too-long",      "bad-address",      "bad-file-descriptor",      "broken-pipe", 
        "connection-refused",      "connection-reset",      "directory-not-empty",      "domain-error", 
        "exec-format-error",      "file-exists",      "file-too-large",      "filename-too-long", 
        "function-not-implemented",      "host-is-unreachable",      "improper-link",      "inappropriate-io-control-operation", 
        "interrupted-function-call",      "invalid-argument",      "invalid-seek",      "io-error", 
        "is-a-directory",      "no-child-processes",      "no-locks-available",      "no-space-left-on-device", 
        "no-such-device",      "no-such-device-or-address",      "no-such-file-or-directory",      "no-such-process", 
        "not-a-directory",      "not-enough-space",      "operation-not-permitted",      "permission-denied", 
        "read-only-file-system",      "resource-busy",      "resource-deadlock-avoided",      "resource-temporarily-unavailable", 
        "result-too-large",      "too-many-links",      "too-many-open-files",      "too-many-open-files"};
#line 551 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxtop.c"
void OS_syserr_names(unsigned long *length , char const   ***names ) 
{ 


  {
#line 554
  *length = sizeof(syserr_names_table) / sizeof(char *);
#line 555
  *names = syserr_names_table;
#line 556
  return;
}
}
#line 558 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxtop.c"
static unsigned long round_up(unsigned long n , unsigned long factor ) 
{ 


  {
#line 561
  return (((n + (factor - 1UL)) / factor) * factor);
}
}
#line 564 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxtop.c"
static unsigned long round_down(unsigned long n , unsigned long factor ) 
{ 


  {
#line 567
  return ((n / factor) * factor);
}
}
#line 570 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxtop.c"
static void estimate_pages(void *start , void *end , unsigned long (*round_start)(unsigned long  ,
                                                                                  unsigned long  ) ,
                           unsigned long (*round_end)(unsigned long  , unsigned long  ) ,
                           void **addr , size_t *len ) 
{ 
  unsigned long page_size ;
  int tmp ;
  char *page_start ;
  unsigned long tmp___0 ;
  char *page_end ;
  unsigned long tmp___1 ;

  {
#line 576
  if ((unsigned long )end <= (unsigned long )start) {
#line 578
    *addr = start;
#line 579
    *len = (size_t )0;
#line 580
    return;
  }
  {
#line 584
  tmp = getpagesize();
#line 584
  page_size = (unsigned long )tmp;
#line 585
  tmp___0 = (*round_start)((unsigned long )start, page_size);
#line 585
  page_start = (char *)tmp___0;
#line 587
  tmp___1 = (*round_end)((unsigned long )end, page_size);
#line 587
  page_end = (char *)tmp___1;
#line 589
  *addr = (void *)page_start;
  }
#line 590
  if ((unsigned long )page_start < (unsigned long )page_end) {
#line 590
    *len = (size_t )(page_end - page_start);
  } else {
#line 590
    *len = (size_t )0;
  }
#line 592
  return;
}
}
#line 594 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxtop.c"
static void underestimate_pages(void *start , void *end , void **addr , size_t *len ) 
{ 


  {
  {
#line 597
  estimate_pages(start, end, & round_up, & round_down, addr, len);
  }
#line 598
  return;
}
}
#line 600 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxtop.c"
static void overestimate_pages(void *start , void *end , void **addr , size_t *len ) 
{ 


  {
  {
#line 603
  estimate_pages(start, end, & round_down, & round_up, addr, len);
  }
#line 604
  return;
}
}
#line 606 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxtop.c"
void OS_expect_sequential_access(void *start , void *end ) 
{ 
  void *addr ;
  size_t len ;

  {
  {
#line 611
  overestimate_pages(start, end, & addr, & len);
#line 613
  posix_madvise(addr, len, 2);
  }
#line 617
  return;
}
}
#line 619 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxtop.c"
void OS_expect_normal_access(void *start , void *end ) 
{ 
  void *addr ;
  size_t len ;

  {
  {
#line 624
  overestimate_pages(start, end, & addr, & len);
#line 626
  posix_madvise(addr, len, 0);
  }
#line 630
  return;
}
}
#line 647 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxtop.c"
void OS_free_pages(void *start , void *end ) 
{ 
  void *addr ;
  size_t len ;

  {
  {
#line 652
  underestimate_pages(start, end, & addr, & len);
#line 654
  madvise(addr, len, 4);
  }
#line 656
  return;
}
}
#line 48 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) speed_t ( __attribute__((__leaf__)) cfgetospeed)(struct termios  const  *__termios_p ) ;
#line 51
extern  __attribute__((__nothrow__)) speed_t ( __attribute__((__leaf__)) cfgetispeed)(struct termios  const  *__termios_p ) ;
#line 54
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) cfsetospeed)(struct termios *__termios_p ,
                                                                                  speed_t __speed ) ;
#line 57
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) cfsetispeed)(struct termios *__termios_p ,
                                                                                  speed_t __speed ) ;
#line 86
extern int tcdrain(int __fd ) ;
#line 90
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcflush)(int __fd ,
                                                                              int __queue_selector ) ;
#line 916 "/usr/include/stdlib.h"
extern int posix_openpt(int __oflag ) ;
#line 924
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) grantpt)(int __fd ) ;
#line 928
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) unlockpt)(int __fd ) ;
#line 933
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) ptsname)(int __fd ) ;
#line 56 "/home/khheo/project/mit-scheme-9.2/src/microcode/osscheme.h"
void deliver_pending_interrupts(void) ;
#line 887 "/home/khheo/project/mit-scheme-9.2/src/microcode/ux.h"
cc_t UX_PC_VDISABLE(int fildes ) ;
#line 929
void UX_prim_check_errno(enum syscall_names name ) ;
#line 34 "/home/khheo/project/mit-scheme-9.2/src/microcode/osterm.h"
unsigned int OS_terminal_get_ispeed(Tchannel channel ) ;
#line 35
unsigned int OS_terminal_get_ospeed(Tchannel channel ) ;
#line 36
void OS_terminal_set_ispeed(Tchannel channel , unsigned int baud ) ;
#line 38
void OS_terminal_set_ospeed(Tchannel channel , unsigned int baud ) ;
#line 41
unsigned int OS_baud_index_to_rate(unsigned int index___0 ) ;
#line 42
int OS_baud_rate_to_index(unsigned int rate ) ;
#line 43
unsigned int OS_terminal_state_size(void) ;
#line 44
void OS_terminal_get_state(Tchannel channel , void *statep ) ;
#line 45
void OS_terminal_set_state(Tchannel channel , void *statep ) ;
#line 46
int OS_terminal_cooked_output_p(Tchannel channel ) ;
#line 47
void OS_terminal_raw_output(Tchannel channel ) ;
#line 48
void OS_terminal_cooked_output(Tchannel channel ) ;
#line 49
int OS_terminal_buffered_p(Tchannel channel ) ;
#line 50
void OS_terminal_buffered(Tchannel channel ) ;
#line 51
void OS_terminal_nonbuffered(Tchannel channel ) ;
#line 52
void OS_terminal_flush_input(Tchannel channel ) ;
#line 53
void OS_terminal_flush_output(Tchannel channel ) ;
#line 54
void OS_terminal_drain_output(Tchannel channel ) ;
#line 55
int OS_job_control_p(void) ;
#line 56
int OS_have_ptys_p(void) ;
#line 32 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxterm.h"
int terminal_state_buffered_p(Ttty_state *s ) ;
#line 33
void terminal_state_buffered(Ttty_state *s , Tchannel channel ) ;
#line 34
void terminal_state_nonbuffered(Ttty_state *s , int fd , int polling ) ;
#line 36
void get_terminal_state(Tchannel channel , Ttty_state *s ) ;
#line 37
void set_terminal_state(Tchannel channel , Ttty_state *s ) ;
#line 54 "/home/khheo/project/mit-scheme-9.2/src/microcode/osio.h"
Tchannel OS_channel_table_size ;
#line 60 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxio.h"
Tchannel channel_allocate(void) ;
#line 32 "/home/khheo/project/mit-scheme-9.2/src/microcode/ospty.h"
char const   *OS_open_pty_master(Tchannel *master_fd , char const   **master_fname ) ;
#line 34
void OS_pty_master_send_signal(Tchannel channel , int sig ) ;
#line 35
void OS_pty_master_kill(Tchannel channel ) ;
#line 36
void OS_pty_master_stop(Tchannel channel ) ;
#line 37
void OS_pty_master_continue(Tchannel channel ) ;
#line 38
void OS_pty_master_interrupt(Tchannel channel ) ;
#line 39
void OS_pty_master_quit(Tchannel channel ) ;
#line 40
void OS_pty_master_hangup(Tchannel channel ) ;
#line 33 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxterm.c"
int UX_terminal_control_ok(int fd ) ;
#line 67 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxterm.c"
static size_t terminal_table_size  ;
#line 68 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxterm.c"
static struct terminal_state *terminal_table  ;
#line 72 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxterm.c"
void UX_initialize_terminals(void) 
{ 
  void *tmp ;
  int __cil_tmp2 ;
  void *__cil_tmp3 ;

  {
  {
#line 75
  terminal_table_size = (size_t )OS_channel_table_size;
#line 76
  tmp = malloc(terminal_table_size * sizeof(struct terminal_state ));
#line 76
  terminal_table = (struct terminal_state *)tmp;
  }
#line 78
  if ((unsigned long )terminal_table == (unsigned long )((struct terminal_state *)0)) {
    {
#line 80
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nUnable to allocate terminal table.\n");
#line 81
    fflush(stderr);
#line 82
    termination_init_error();
    }
  }
#line 84
  return;
}
}
#line 86 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxterm.c"
void UX_reset_terminals(void) 
{ 


  {
  {
#line 89
  free((void *)terminal_table);
#line 90
  terminal_table = (struct terminal_state *)0;
#line 91
  terminal_table_size = (size_t )0;
  }
#line 92
  return;
}
}
#line 95 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxterm.c"
void terminal_open(Tchannel channel ) 
{ 
  void *tmp ;

  {
#line 98
  if (terminal_table_size != (size_t )OS_channel_table_size) {
    {
#line 100
    terminal_table_size = (size_t )OS_channel_table_size;
#line 101
    tmp = OS_realloc((void *)terminal_table, terminal_table_size * sizeof(struct terminal_state ));
#line 101
    terminal_table = (struct terminal_state *)tmp;
    }
  }
  {
#line 106
  (terminal_table + channel)->buffer = -1;
#line 107
  get_terminal_state(channel, & (terminal_table + channel)->state);
  }
#line 108
  return;
}
}
#line 110 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxterm.c"
void get_terminal_state(Tchannel channel , Ttty_state *s ) 
{ 
  int tmp ;

  {
  {
#line 113
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 113
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 113
      tmp = UX_terminal_get_state((channel_table + channel)->descriptor, s);
      }
#line 113
      if (! (tmp < 0)) {
#line 113
        goto while_break___0;
      }
      {
#line 113
      UX_prim_check_errno((enum syscall_names )61);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 113
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 116
  return;
}
}
#line 118 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxterm.c"
void set_terminal_state(Tchannel channel , Ttty_state *s ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 121
  tmp___0 = UX_terminal_control_ok((channel_table + channel)->descriptor);
  }
#line 121
  if (tmp___0) {
    {
#line 122
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 122
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 122
        tmp = UX_terminal_set_state((channel_table + channel)->descriptor, s);
        }
#line 122
        if (! (tmp < 0)) {
#line 122
          goto while_break___0;
        }
        {
#line 122
        UX_prim_check_errno((enum syscall_names )62);
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 122
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 125
  return;
}
}
#line 127 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxterm.c"
unsigned int terminal_state_get_ospeed(Ttty_state *s ) 
{ 
  speed_t tmp ;

  {
  {
#line 131
  tmp = cfgetospeed((struct termios  const  *)(& s->tio));
  }
#line 131
  return (tmp);
}
}
#line 143 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxterm.c"
unsigned int terminal_state_get_ispeed(Ttty_state *s ) 
{ 
  speed_t tmp ;

  {
  {
#line 147
  tmp = cfgetispeed((struct termios  const  *)(& s->tio));
  }
#line 147
  return (tmp);
}
}
#line 159 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxterm.c"
void terminal_state_set_ospeed(Ttty_state *s , unsigned int b ) 
{ 


  {
  {
#line 163
  cfsetospeed(& s->tio, b);
  }
#line 173
  return;
}
}
#line 175 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxterm.c"
void terminal_state_set_ispeed(Ttty_state *s , unsigned int b ) 
{ 


  {
  {
#line 179
  cfsetispeed(& s->tio, b);
  }
#line 190
  return;
}
}
#line 192 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxterm.c"
int terminal_state_cooked_output_p(Ttty_state *s ) 
{ 


  {
#line 196
  return ((s->tio.c_oflag & 1U) != 0U);
}
}
#line 204 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxterm.c"
void terminal_state_raw_output(Ttty_state *s ) 
{ 


  {
#line 208
  s->tio.c_oflag &= 4294967294U;
#line 215
  return;
}
}
#line 217 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxterm.c"
void terminal_state_cooked_output(Ttty_state *s , Tchannel channel ) 
{ 
  Ttty_state *os ;

  {
#line 220
  os = & (terminal_table + channel)->state;
#line 222
  s->tio.c_oflag |= os->tio.c_oflag & 1U;
#line 230
  return;
}
}
#line 232 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxterm.c"
int terminal_state_buffered_p(Ttty_state *s ) 
{ 


  {
#line 236
  return ((s->tio.c_lflag & 2U) != 0U);
}
}
#line 244 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxterm.c"
void terminal_state_nonbuffered(Ttty_state *s , int fd , int polling ) 
{ 
  cc_t disable ;
  cc_t tmp ;

  {
#line 249
  s->tio.c_lflag &= 4294967285U;
#line 251
  s->tio.c_lflag &= 4294934527U;
#line 253
  s->tio.c_lflag |= 1U;
#line 254
  s->tio.c_iflag |= 1U;
#line 255
  s->tio.c_iflag &= 4294965983U;
#line 256
  s->tio.c_cflag |= 48U;
#line 257
  s->tio.c_cflag &= 4294967039U;
#line 258
  if (polling) {
#line 258
    s->tio.c_cc[6] = (cc_t )0;
  } else {
#line 258
    s->tio.c_cc[6] = (cc_t )1;
  }
  {
#line 259
  s->tio.c_cc[5] = (cc_t )0;
#line 262
  tmp = UX_PC_VDISABLE(fd);
#line 262
  disable = tmp;
#line 263
  s->tio.c_cc[9] = disable;
#line 264
  s->tio.c_cc[8] = disable;
  }
#line 287
  return;
}
}
#line 289 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxterm.c"
void terminal_state_raw(Ttty_state *s , int fd ) 
{ 


  {
  {
#line 292
  terminal_state_nonbuffered(s, fd, 0);
#line 296
  s->tio.c_lflag &= 4294967294U;
  }
#line 312
  return;
}
}
#line 314 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxterm.c"
void terminal_state_buffered(Ttty_state *s , Tchannel channel ) 
{ 
  Ttty_state *os ;

  {
#line 317
  os = & (terminal_table + channel)->state;
#line 321
  s->tio.c_lflag |= 3U;
#line 322
  s->tio.c_lflag |= os->tio.c_lflag & 8U;
#line 324
  s->tio.c_lflag |= os->tio.c_lflag & 32768U;
#line 326
  s->tio.c_iflag = os->tio.c_iflag;
#line 327
  s->tio.c_cflag |= 48U;
#line 328
  s->tio.c_cflag &= 4294967039U;
#line 329
  s->tio.c_cc[6] = os->tio.c_cc[6];
#line 330
  s->tio.c_cc[5] = os->tio.c_cc[5];
#line 332
  s->tio.c_cc[9] = os->tio.c_cc[9];
#line 333
  s->tio.c_cc[8] = os->tio.c_cc[8];
#line 361
  return;
}
}
#line 363 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxterm.c"
unsigned int OS_terminal_get_ispeed(Tchannel channel ) 
{ 
  Ttty_state s ;
  unsigned int tmp ;
  void *__cil_tmp4 ;

  {
  {
#line 367
  get_terminal_state(channel, & s);
#line 368
  tmp = terminal_state_get_ispeed(& s);
  }
#line 368
  return (tmp);
}
}
#line 371 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxterm.c"
unsigned int OS_terminal_get_ospeed(Tchannel channel ) 
{ 
  Ttty_state s ;
  unsigned int tmp ;
  void *__cil_tmp4 ;

  {
  {
#line 375
  get_terminal_state(channel, & s);
#line 376
  tmp = terminal_state_get_ospeed(& s);
  }
#line 376
  return (tmp);
}
}
#line 379 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxterm.c"
void OS_terminal_set_ispeed(Tchannel channel , unsigned int baud ) 
{ 
  Ttty_state s ;
  void *__cil_tmp4 ;

  {
  {
#line 383
  get_terminal_state(channel, & s);
#line 384
  terminal_state_set_ispeed(& s, baud);
#line 385
  set_terminal_state(channel, & s);
  }
#line 386
  return;
}
}
#line 388 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxterm.c"
void OS_terminal_set_ospeed(Tchannel channel , unsigned int baud ) 
{ 
  Ttty_state s ;
  void *__cil_tmp4 ;

  {
  {
#line 392
  get_terminal_state(channel, & s);
#line 393
  terminal_state_set_ospeed(& s, baud);
#line 394
  set_terminal_state(channel, & s);
  }
#line 395
  return;
}
}
#line 397 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxterm.c"
unsigned int arg_baud_index(unsigned int argument ) 
{ 
  unsigned long index___0 ;
  unsigned long tmp ;

  {
  {
#line 400
  tmp = arg_ulong_integer((int )argument);
#line 400
  index___0 = tmp;
  }
  {
#line 462
  if (index___0 == 4111UL) {
#line 462
    goto case_4111;
  }
#line 462
  if (index___0 == 4110UL) {
#line 462
    goto case_4111;
  }
#line 462
  if (index___0 == 4109UL) {
#line 462
    goto case_4111;
  }
#line 462
  if (index___0 == 4108UL) {
#line 462
    goto case_4111;
  }
#line 462
  if (index___0 == 4107UL) {
#line 462
    goto case_4111;
  }
#line 462
  if (index___0 == 4106UL) {
#line 462
    goto case_4111;
  }
#line 462
  if (index___0 == 4105UL) {
#line 462
    goto case_4111;
  }
#line 462
  if (index___0 == 4104UL) {
#line 462
    goto case_4111;
  }
#line 462
  if (index___0 == 4103UL) {
#line 462
    goto case_4111;
  }
#line 462
  if (index___0 == 4102UL) {
#line 462
    goto case_4111;
  }
#line 462
  if (index___0 == 4101UL) {
#line 462
    goto case_4111;
  }
#line 462
  if (index___0 == 4100UL) {
#line 462
    goto case_4111;
  }
#line 462
  if (index___0 == 4099UL) {
#line 462
    goto case_4111;
  }
#line 462
  if (index___0 == 4098UL) {
#line 462
    goto case_4111;
  }
#line 462
  if (index___0 == 4097UL) {
#line 462
    goto case_4111;
  }
#line 462
  if (index___0 == 15UL) {
#line 462
    goto case_4111;
  }
#line 462
  if (index___0 == 14UL) {
#line 462
    goto case_4111;
  }
#line 462
  if (index___0 == 13UL) {
#line 462
    goto case_4111;
  }
#line 462
  if (index___0 == 12UL) {
#line 462
    goto case_4111;
  }
#line 462
  if (index___0 == 11UL) {
#line 462
    goto case_4111;
  }
#line 462
  if (index___0 == 10UL) {
#line 462
    goto case_4111;
  }
#line 462
  if (index___0 == 9UL) {
#line 462
    goto case_4111;
  }
#line 462
  if (index___0 == 8UL) {
#line 462
    goto case_4111;
  }
#line 462
  if (index___0 == 7UL) {
#line 462
    goto case_4111;
  }
#line 462
  if (index___0 == 6UL) {
#line 462
    goto case_4111;
  }
#line 462
  if (index___0 == 5UL) {
#line 462
    goto case_4111;
  }
#line 462
  if (index___0 == 4UL) {
#line 462
    goto case_4111;
  }
#line 462
  if (index___0 == 3UL) {
#line 462
    goto case_4111;
  }
#line 462
  if (index___0 == 2UL) {
#line 462
    goto case_4111;
  }
#line 462
  if (index___0 == 1UL) {
#line 462
    goto case_4111;
  }
#line 462
  if (index___0 == 0UL) {
#line 462
    goto case_4111;
  }
#line 465
  goto switch_default;
  case_4111: /* CIL Label */ 
  case_4110: /* CIL Label */ 
  case_4109: /* CIL Label */ 
  case_4108: /* CIL Label */ 
  case_4107: /* CIL Label */ 
  case_4106: /* CIL Label */ 
  case_4105: /* CIL Label */ 
  case_4104: /* CIL Label */ 
  case_4103: /* CIL Label */ 
  case_4102: /* CIL Label */ 
  case_4101: /* CIL Label */ 
  case_4100: /* CIL Label */ 
  case_4099: /* CIL Label */ 
  case_4098: /* CIL Label */ 
  case_4097: /* CIL Label */ 
  case_15: /* CIL Label */ 
  case_14: /* CIL Label */ 
  case_13: /* CIL Label */ 
  case_12: /* CIL Label */ 
  case_11: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 464
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 466
  error_bad_range_arg((int )argument);
  }
  switch_break: /* CIL Label */ ;
  }
#line 468
  return ((unsigned int )index___0);
}
}
#line 471 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxterm.c"
unsigned int OS_baud_index_to_rate(unsigned int index___0 ) 
{ 


  {
  {
#line 476
  if (index___0 == 0U) {
#line 476
    goto case_0;
  }
#line 477
  if (index___0 == 1U) {
#line 477
    goto case_1;
  }
#line 478
  if (index___0 == 2U) {
#line 478
    goto case_2;
  }
#line 479
  if (index___0 == 3U) {
#line 479
    goto case_3;
  }
#line 480
  if (index___0 == 4U) {
#line 480
    goto case_4;
  }
#line 481
  if (index___0 == 5U) {
#line 481
    goto case_5;
  }
#line 482
  if (index___0 == 6U) {
#line 482
    goto case_6;
  }
#line 483
  if (index___0 == 7U) {
#line 483
    goto case_7;
  }
#line 484
  if (index___0 == 8U) {
#line 484
    goto case_8;
  }
#line 485
  if (index___0 == 9U) {
#line 485
    goto case_9;
  }
#line 486
  if (index___0 == 10U) {
#line 486
    goto case_10;
  }
#line 487
  if (index___0 == 11U) {
#line 487
    goto case_11;
  }
#line 488
  if (index___0 == 12U) {
#line 488
    goto case_12;
  }
#line 489
  if (index___0 == 13U) {
#line 489
    goto case_13;
  }
#line 490
  if (index___0 == 14U) {
#line 490
    goto case_14;
  }
#line 491
  if (index___0 == 15U) {
#line 491
    goto case_15;
  }
#line 493
  if (index___0 == 4097U) {
#line 493
    goto case_4097;
  }
#line 496
  if (index___0 == 4098U) {
#line 496
    goto case_4098;
  }
#line 499
  if (index___0 == 4099U) {
#line 499
    goto case_4099;
  }
#line 502
  if (index___0 == 4100U) {
#line 502
    goto case_4100;
  }
#line 505
  if (index___0 == 4101U) {
#line 505
    goto case_4101;
  }
#line 508
  if (index___0 == 4102U) {
#line 508
    goto case_4102;
  }
#line 511
  if (index___0 == 4103U) {
#line 511
    goto case_4103;
  }
#line 514
  if (index___0 == 4104U) {
#line 514
    goto case_4104;
  }
#line 517
  if (index___0 == 4105U) {
#line 517
    goto case_4105;
  }
#line 520
  if (index___0 == 4106U) {
#line 520
    goto case_4106;
  }
#line 523
  if (index___0 == 4107U) {
#line 523
    goto case_4107;
  }
#line 526
  if (index___0 == 4108U) {
#line 526
    goto case_4108;
  }
#line 529
  if (index___0 == 4109U) {
#line 529
    goto case_4109;
  }
#line 532
  if (index___0 == 4110U) {
#line 532
    goto case_4110;
  }
#line 535
  if (index___0 == 4111U) {
#line 535
    goto case_4111;
  }
#line 537
  goto switch_default;
  case_0: /* CIL Label */ 
#line 476
  return (0U);
  case_1: /* CIL Label */ 
#line 477
  return (50U);
  case_2: /* CIL Label */ 
#line 478
  return (75U);
  case_3: /* CIL Label */ 
#line 479
  return (110U);
  case_4: /* CIL Label */ 
#line 480
  return (134U);
  case_5: /* CIL Label */ 
#line 481
  return (150U);
  case_6: /* CIL Label */ 
#line 482
  return (200U);
  case_7: /* CIL Label */ 
#line 483
  return (300U);
  case_8: /* CIL Label */ 
#line 484
  return (600U);
  case_9: /* CIL Label */ 
#line 485
  return (1200U);
  case_10: /* CIL Label */ 
#line 486
  return (1800U);
  case_11: /* CIL Label */ 
#line 487
  return (2400U);
  case_12: /* CIL Label */ 
#line 488
  return (4800U);
  case_13: /* CIL Label */ 
#line 489
  return (9600U);
  case_14: /* CIL Label */ 
#line 490
  return (19200U);
  case_15: /* CIL Label */ 
#line 491
  return (38400U);
  case_4097: /* CIL Label */ 
#line 493
  return (57600U);
  case_4098: /* CIL Label */ 
#line 496
  return (115200U);
  case_4099: /* CIL Label */ 
#line 499
  return (230400U);
  case_4100: /* CIL Label */ 
#line 502
  return (460800U);
  case_4101: /* CIL Label */ 
#line 505
  return (500000U);
  case_4102: /* CIL Label */ 
#line 508
  return (576000U);
  case_4103: /* CIL Label */ 
#line 511
  return (921600U);
  case_4104: /* CIL Label */ 
#line 514
  return (1000000U);
  case_4105: /* CIL Label */ 
#line 517
  return (1152000U);
  case_4106: /* CIL Label */ 
#line 520
  return (1500000U);
  case_4107: /* CIL Label */ 
#line 523
  return (2000000U);
  case_4108: /* CIL Label */ 
#line 526
  return (2500000U);
  case_4109: /* CIL Label */ 
#line 529
  return (3000000U);
  case_4110: /* CIL Label */ 
#line 532
  return (3500000U);
  case_4111: /* CIL Label */ 
#line 535
  return (4000000U);
  switch_default: /* CIL Label */ 
  {
#line 537
  abort();
  }
#line 537
  return (0U);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 541 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxterm.c"
int OS_baud_rate_to_index(unsigned int rate ) 
{ 


  {
  {
#line 546
  if (rate == 0U) {
#line 546
    goto case_0;
  }
#line 547
  if (rate == 50U) {
#line 547
    goto case_50;
  }
#line 548
  if (rate == 75U) {
#line 548
    goto case_75;
  }
#line 549
  if (rate == 110U) {
#line 549
    goto case_110;
  }
#line 550
  if (rate == 134U) {
#line 550
    goto case_134;
  }
#line 551
  if (rate == 150U) {
#line 551
    goto case_150;
  }
#line 552
  if (rate == 200U) {
#line 552
    goto case_200;
  }
#line 553
  if (rate == 300U) {
#line 553
    goto case_300;
  }
#line 554
  if (rate == 600U) {
#line 554
    goto case_600;
  }
#line 555
  if (rate == 1200U) {
#line 555
    goto case_1200;
  }
#line 556
  if (rate == 1800U) {
#line 556
    goto case_1800;
  }
#line 557
  if (rate == 2400U) {
#line 557
    goto case_2400;
  }
#line 558
  if (rate == 4800U) {
#line 558
    goto case_4800;
  }
#line 559
  if (rate == 9600U) {
#line 559
    goto case_9600;
  }
#line 560
  if (rate == 19200U) {
#line 560
    goto case_19200;
  }
#line 561
  if (rate == 38400U) {
#line 561
    goto case_38400;
  }
#line 563
  if (rate == 57600U) {
#line 563
    goto case_57600;
  }
#line 566
  if (rate == 115200U) {
#line 566
    goto case_115200;
  }
#line 569
  if (rate == 230400U) {
#line 569
    goto case_230400;
  }
#line 572
  if (rate == 460800U) {
#line 572
    goto case_460800;
  }
#line 575
  if (rate == 500000U) {
#line 575
    goto case_500000;
  }
#line 578
  if (rate == 576000U) {
#line 578
    goto case_576000;
  }
#line 581
  if (rate == 921600U) {
#line 581
    goto case_921600;
  }
#line 584
  if (rate == 1000000U) {
#line 584
    goto case_1000000;
  }
#line 587
  if (rate == 1152000U) {
#line 587
    goto case_1152000;
  }
#line 590
  if (rate == 1500000U) {
#line 590
    goto case_1500000;
  }
#line 593
  if (rate == 2000000U) {
#line 593
    goto case_2000000;
  }
#line 596
  if (rate == 2500000U) {
#line 596
    goto case_2500000;
  }
#line 599
  if (rate == 3000000U) {
#line 599
    goto case_3000000;
  }
#line 602
  if (rate == 3500000U) {
#line 602
    goto case_3500000;
  }
#line 605
  if (rate == 4000000U) {
#line 605
    goto case_4000000;
  }
#line 607
  goto switch_default;
  case_0: /* CIL Label */ 
#line 546
  return (0);
  case_50: /* CIL Label */ 
#line 547
  return (1);
  case_75: /* CIL Label */ 
#line 548
  return (2);
  case_110: /* CIL Label */ 
#line 549
  return (3);
  case_134: /* CIL Label */ 
#line 550
  return (4);
  case_150: /* CIL Label */ 
#line 551
  return (5);
  case_200: /* CIL Label */ 
#line 552
  return (6);
  case_300: /* CIL Label */ 
#line 553
  return (7);
  case_600: /* CIL Label */ 
#line 554
  return (8);
  case_1200: /* CIL Label */ 
#line 555
  return (9);
  case_1800: /* CIL Label */ 
#line 556
  return (10);
  case_2400: /* CIL Label */ 
#line 557
  return (11);
  case_4800: /* CIL Label */ 
#line 558
  return (12);
  case_9600: /* CIL Label */ 
#line 559
  return (13);
  case_19200: /* CIL Label */ 
#line 560
  return (14);
  case_38400: /* CIL Label */ 
#line 561
  return (15);
  case_57600: /* CIL Label */ 
#line 563
  return (4097);
  case_115200: /* CIL Label */ 
#line 566
  return (4098);
  case_230400: /* CIL Label */ 
#line 569
  return (4099);
  case_460800: /* CIL Label */ 
#line 572
  return (4100);
  case_500000: /* CIL Label */ 
#line 575
  return (4101);
  case_576000: /* CIL Label */ 
#line 578
  return (4102);
  case_921600: /* CIL Label */ 
#line 581
  return (4103);
  case_1000000: /* CIL Label */ 
#line 584
  return (4104);
  case_1152000: /* CIL Label */ 
#line 587
  return (4105);
  case_1500000: /* CIL Label */ 
#line 590
  return (4106);
  case_2000000: /* CIL Label */ 
#line 593
  return (4107);
  case_2500000: /* CIL Label */ 
#line 596
  return (4108);
  case_3000000: /* CIL Label */ 
#line 599
  return (4109);
  case_3500000: /* CIL Label */ 
#line 602
  return (4110);
  case_4000000: /* CIL Label */ 
#line 605
  return (4111);
  switch_default: /* CIL Label */ 
#line 607
  return (-1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 611 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxterm.c"
unsigned int OS_terminal_state_size(void) 
{ 


  {
#line 614
  return ((unsigned int )sizeof(Ttty_state ));
}
}
#line 617 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxterm.c"
void OS_terminal_get_state(Tchannel channel , void *statep ) 
{ 


  {
  {
#line 620
  get_terminal_state(channel, (Ttty_state *)statep);
  }
#line 621
  return;
}
}
#line 623 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxterm.c"
void OS_terminal_set_state(Tchannel channel , void *statep ) 
{ 


  {
  {
#line 626
  set_terminal_state(channel, (Ttty_state *)statep);
  }
#line 627
  return;
}
}
#line 629 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxterm.c"
int OS_terminal_cooked_output_p(Tchannel channel ) 
{ 
  Ttty_state s ;
  int tmp ;
  void *__cil_tmp4 ;

  {
  {
#line 633
  get_terminal_state(channel, & s);
#line 634
  tmp = terminal_state_cooked_output_p(& s);
  }
#line 634
  return (tmp);
}
}
#line 637 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxterm.c"
void OS_terminal_raw_output(Tchannel channel ) 
{ 
  Ttty_state s ;
  void *__cil_tmp3 ;

  {
  {
#line 641
  get_terminal_state(channel, & s);
#line 642
  terminal_state_raw_output(& s);
#line 643
  set_terminal_state(channel, & s);
  }
#line 644
  return;
}
}
#line 646 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxterm.c"
void OS_terminal_cooked_output(Tchannel channel ) 
{ 
  Ttty_state s ;
  void *__cil_tmp3 ;

  {
  {
#line 650
  get_terminal_state(channel, & s);
#line 651
  terminal_state_cooked_output(& s, channel);
#line 652
  set_terminal_state(channel, & s);
  }
#line 653
  return;
}
}
#line 655 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxterm.c"
int OS_terminal_buffered_p(Tchannel channel ) 
{ 
  Ttty_state s ;
  int tmp ;
  void *__cil_tmp4 ;

  {
  {
#line 659
  get_terminal_state(channel, & s);
#line 660
  tmp = terminal_state_buffered_p(& s);
  }
#line 660
  return (tmp);
}
}
#line 663 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxterm.c"
void OS_terminal_buffered(Tchannel channel ) 
{ 
  Ttty_state s ;
  void *__cil_tmp3 ;

  {
  {
#line 667
  get_terminal_state(channel, & s);
#line 668
  terminal_state_buffered(& s, channel);
#line 669
  set_terminal_state(channel, & s);
  }
#line 670
  return;
}
}
#line 672 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxterm.c"
void OS_terminal_nonbuffered(Tchannel channel ) 
{ 
  Ttty_state s ;
  void *__cil_tmp3 ;

  {
  {
#line 676
  get_terminal_state(channel, & s);
#line 677
  terminal_state_nonbuffered(& s, (channel_table + channel)->descriptor, 0);
#line 678
  set_terminal_state(channel, & s);
  }
#line 679
  return;
}
}
#line 681 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxterm.c"
void OS_terminal_flush_input(Tchannel channel ) 
{ 
  int tmp ;

  {
  {
#line 684
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 684
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 684
      tmp = tcflush((channel_table + channel)->descriptor, 0);
      }
#line 684
      if (! (tmp < 0)) {
#line 684
        goto while_break___0;
      }
      {
#line 684
      UX_prim_check_errno((enum syscall_names )58);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 684
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 686
  return;
}
}
#line 688 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxterm.c"
void OS_terminal_flush_output(Tchannel channel ) 
{ 
  int tmp ;

  {
  {
#line 691
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 691
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 691
      tmp = tcflush((channel_table + channel)->descriptor, 1);
      }
#line 691
      if (! (tmp < 0)) {
#line 691
        goto while_break___0;
      }
      {
#line 691
      UX_prim_check_errno((enum syscall_names )58);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 691
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 693
  return;
}
}
#line 695 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxterm.c"
void OS_terminal_drain_output(Tchannel channel ) 
{ 
  int tmp ;

  {
  {
#line 698
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 698
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 698
      tmp = tcdrain((channel_table + channel)->descriptor);
      }
#line 698
      if (! (tmp < 0)) {
#line 698
        goto while_break___0;
      }
      {
#line 698
      UX_prim_check_errno((enum syscall_names )57);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 698
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 700
  return;
}
}
#line 702 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxterm.c"
int OS_job_control_p(void) 
{ 


  {
#line 705
  return (1);
}
}
#line 708 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxterm.c"
int OS_have_ptys_p(void) 
{ 


  {
#line 712
  return (1);
}
}
#line 802 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxterm.c"
static char slave_name[24]  ;
#line 796 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxterm.c"
char const   *OS_open_pty_master(Tchannel *master_fd , char const   **master_fname ) 
{ 
  int fd ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  Tchannel MAKE_CHANNEL_temp ;
  Tchannel tmp___2 ;
  char *__cil_tmp9 ;

  {
  {
#line 800
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 804
    tmp = posix_openpt(258);
#line 804
    fd = tmp;
    }
#line 824
    if (fd < 0) {
      {
#line 826
      tmp___0 = __errno_location();
      }
#line 826
      if (*tmp___0 == 4) {
        {
#line 828
        deliver_pending_interrupts();
        }
#line 829
        goto while_continue;
      }
#line 836
      return ((char const   *)0);
    }
    {
#line 842
    grantpt(fd);
#line 843
    unlockpt(fd);
#line 844
    tmp___1 = ptsname(fd);
#line 844
    strcpy((char */* __restrict  */)(slave_name), (char const   */* __restrict  */)tmp___1);
#line 848
    tmp___2 = channel_allocate();
#line 848
    MAKE_CHANNEL_temp = tmp___2;
#line 848
    (channel_table + MAKE_CHANNEL_temp)->descriptor = fd;
#line 848
    (channel_table + MAKE_CHANNEL_temp)->type = (enum channel_type )5;
#line 848
    (channel_table + MAKE_CHANNEL_temp)->internal = 0U;
#line 848
    (channel_table + MAKE_CHANNEL_temp)->nonblocking = 0U;
#line 848
    *master_fd = MAKE_CHANNEL_temp;
#line 849
    *master_fname = "/dev/ptmx";
    }
#line 850
    return ((char const   *)(slave_name));
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 862 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxterm.c"
void OS_pty_master_send_signal(Tchannel channel , int sig ) 
{ 
  int tmp ;

  {
  {
#line 866
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 866
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 866
      tmp = ioctl((channel_table + channel)->descriptor, (unsigned long )(((1U << 30) | (unsigned int )(84 << 8)) | 54U) | (sizeof(int ) << 16),
                  sig);
      }
#line 866
      if (! (tmp < 0)) {
#line 866
        goto while_break___0;
      }
      {
#line 866
      UX_prim_check_errno((enum syscall_names )22);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 866
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 880
  return;
}
}
#line 882 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxterm.c"
void OS_pty_master_kill(Tchannel channel ) 
{ 


  {
  {
#line 885
  OS_pty_master_send_signal(channel, 9);
  }
#line 886
  return;
}
}
#line 888 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxterm.c"
void OS_pty_master_stop(Tchannel channel ) 
{ 


  {
  {
#line 891
  OS_pty_master_send_signal(channel, 20);
  }
#line 892
  return;
}
}
#line 894 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxterm.c"
void OS_pty_master_continue(Tchannel channel ) 
{ 


  {
  {
#line 897
  OS_pty_master_send_signal(channel, 18);
  }
#line 898
  return;
}
}
#line 900 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxterm.c"
void OS_pty_master_interrupt(Tchannel channel ) 
{ 


  {
  {
#line 903
  OS_pty_master_send_signal(channel, 2);
  }
#line 904
  return;
}
}
#line 906 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxterm.c"
void OS_pty_master_quit(Tchannel channel ) 
{ 


  {
  {
#line 909
  OS_pty_master_send_signal(channel, 3);
  }
#line 910
  return;
}
}
#line 912 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxterm.c"
void OS_pty_master_hangup(Tchannel channel ) 
{ 


  {
  {
#line 915
  OS_pty_master_send_signal(channel, 1);
  }
#line 916
  return;
}
}
#line 879 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gethostname)(char *__name ,
                                                                                                  size_t __len ) ;
#line 57 "/usr/include/x86_64-linux-gnu/sys/poll.h"
extern int poll(struct pollfd *__fds , nfds_t __nfds , int __timeout ) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 123
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  * __restrict  __addr ,
                                                                           socklen_t __len ) ;
#line 137
extern int connect(int __fd , struct sockaddr  const  * __restrict  __addr , socklen_t __len ) ;
#line 219
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void * __restrict  __optval ,
                                                                                 socklen_t * __restrict  __optlen ) ;
#line 226
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void const   *__optval ,
                                                                                 socklen_t __optlen ) ;
#line 233
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) listen)(int __fd ,
                                                                             int __n ) ;
#line 243
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 261
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) shutdown)(int __fd ,
                                                                               int __how ) ;
#line 377 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) htonl)(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 379
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 137 "/usr/include/netdb.h"
extern struct hostent *gethostbyaddr(void const   *__addr , __socklen_t __len , int __type ) ;
#line 144
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 290
extern struct servent *getservbyname(char const   *__name , char const   *__proto ) ;
#line 173 "/home/khheo/project/mit-scheme-9.2/src/microcode/syscall.h"
 __attribute__((__noreturn__)) void error_system_call(int code , enum syscall_names name ) ;
#line 930 "/home/khheo/project/mit-scheme-9.2/src/microcode/ux.h"
void UX_prim_check_fd_errno(enum syscall_names name ) ;
#line 931
_Bool UX_out_of_files_p ;
#line 59 "/home/khheo/project/mit-scheme-9.2/src/microcode/osio.h"
void OS_channel_close_on_abort(Tchannel channel ) ;
#line 32 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsock.h"
Tchannel OS_open_tcp_stream_socket(void *host , unsigned int port ) ;
#line 33
void OS_shutdown_socket(Tchannel channel , unsigned long stype ) ;
#line 34
int OS_get_service_by_name(char const   *service_name , char const   *protocol_name ) ;
#line 35
unsigned long OS_get_service_by_number(unsigned long const   port_number ) ;
#line 36
unsigned int OS_host_address_length(void) ;
#line 37
char **OS_get_host_by_name(char const   *host_name ) ;
#line 38
char const   *OS_get_host_name(void) ;
#line 39
char const   *OS_canonical_host_name(char const   *host_name ) ;
#line 40
char const   *OS_get_host_by_address(char const   *host_addr ) ;
#line 41
void OS_host_address_any(void *addr ) ;
#line 42
void OS_host_address_loopback(void *addr ) ;
#line 45
Tchannel OS_open_unix_stream_socket(char const   *filename ) ;
#line 48
Tchannel OS_create_tcp_server_socket(void) ;
#line 49
void OS_bind_tcp_server_socket(Tchannel channel , void *host , unsigned int port ) ;
#line 50
void OS_listen_tcp_server_socket(Tchannel channel ) ;
#line 51
Tchannel OS_server_connection_accept(Tchannel channel , void *peer_host , unsigned int *peer_port ) ;
#line 36 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsock.c"
static void do_connect(int s , struct sockaddr *address___0 , socklen_t addr_len ) ;
#line 38 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsock.c"
Tchannel OS_open_tcp_stream_socket(void *host , unsigned int port ) 
{ 
  int s ;
  Tchannel channel ;
  Tchannel MAKE_CHANNEL_temp ;
  Tchannel tmp ;
  struct sockaddr_in address___0 ;
  void *__cil_tmp8 ;

  {
  {
#line 44
  transaction_begin();
  }
  {
#line 45
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 45
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 45
      s = socket(2, 1, 0);
      }
#line 45
      if (! (s < 0)) {
#line 45
        goto while_break___0;
      }
      {
#line 45
      UX_prim_check_fd_errno((enum syscall_names )52);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 45
    UX_out_of_files_p = (_Bool)0;
#line 45
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 47
  tmp = channel_allocate();
#line 47
  MAKE_CHANNEL_temp = tmp;
#line 47
  (channel_table + MAKE_CHANNEL_temp)->descriptor = s;
#line 47
  (channel_table + MAKE_CHANNEL_temp)->type = (enum channel_type )7;
#line 47
  (channel_table + MAKE_CHANNEL_temp)->internal = 0U;
#line 47
  (channel_table + MAKE_CHANNEL_temp)->nonblocking = 0U;
#line 47
  channel = MAKE_CHANNEL_temp;
#line 48
  OS_channel_close_on_abort(channel);
#line 51
  memset((void *)(& address___0), 0, sizeof(address___0));
#line 52
  address___0.sin_family = (sa_family_t )2;
#line 53
  memcpy((void */* __restrict  */)(& address___0.sin_addr), (void const   */* __restrict  */)host,
         sizeof(address___0.sin_addr));
#line 54
  address___0.sin_port = (in_port_t )port;
#line 55
  do_connect(s, (struct sockaddr *)(& address___0), (socklen_t )sizeof(address___0));
#line 57
  transaction_commit();
  }
#line 58
  return (channel);
}
}
#line 61 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsock.c"
static void do_connect(int s , struct sockaddr *address___0 , socklen_t addr_len ) 
{ 
  int *tmp ;
  int *tmp___0 ;
  struct pollfd fds ;
  int nfds ;
  int *tmp___1 ;
  int *tmp___2 ;
  int error___1 ;
  socklen_t len ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 64
  tmp___4 = connect(s, (struct sockaddr  const  */* __restrict  */)address___0, addr_len);
  }
#line 64
  if (tmp___4 < 0) {
    {
#line 66
    tmp___0 = __errno_location();
    }
#line 66
    if (*tmp___0 != 4) {
      {
#line 67
      tmp = __errno_location();
#line 67
      error_system_call(*tmp, (enum syscall_names )6);
      }
    }
    {
#line 68
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 70
      deliver_pending_interrupts();
#line 79
      fds.fd = s;
#line 80
      fds.events = (short)5;
#line 81
      nfds = poll(& fds, (nfds_t )1, 0);
      }
#line 82
      if (nfds > 0) {
#line 82
        if (((int )fds.revents & 5) != 0) {
#line 83
          goto while_break;
        }
      }
#line 84
      if (nfds < 0) {
        {
#line 84
        tmp___2 = __errno_location();
        }
#line 84
        if (*tmp___2 != 4) {
          {
#line 85
          tmp___1 = __errno_location();
#line 85
          error_system_call(*tmp___1, (enum syscall_names )43);
          }
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 112
    len = (socklen_t )sizeof(error___1);
#line 113
    tmp___3 = getsockopt(s, 1, 4, (void */* __restrict  */)(& error___1), (socklen_t */* __restrict  */)(& len));
    }
#line 113
    if (tmp___3 < 0) {
      {
#line 115
      error_system_call(error___1, (enum syscall_names )6);
      }
    } else
#line 113
    if (error___1 != 0) {
      {
#line 115
      error_system_call(error___1, (enum syscall_names )6);
      }
    }
  }
#line 118
  return;
}
}
#line 120 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsock.c"
void OS_shutdown_socket(Tchannel channel , unsigned long stype ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 123
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 123
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 123
      if ((stype & 3UL) == 1UL) {
#line 123
        tmp___0 = 0;
      } else {
#line 123
        if ((stype & 3UL) == 2UL) {
#line 123
          tmp = 1;
        } else {
#line 123
          tmp = 2;
        }
#line 123
        tmp___0 = tmp;
      }
      {
#line 123
      tmp___1 = shutdown((channel_table + channel)->descriptor, tmp___0);
      }
#line 123
      if (! (tmp___1 < 0)) {
#line 123
        goto while_break___0;
      }
      {
#line 123
      UX_prim_check_errno((enum syscall_names )47);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 123
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 131
  return;
}
}
#line 133 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsock.c"
int OS_get_service_by_name(char const   *service_name , char const   *protocol_name ) 
{ 
  struct servent *entry ;
  struct servent *tmp ;
  int tmp___0 ;

  {
  {
#line 136
  tmp = getservbyname(service_name, protocol_name);
#line 136
  entry = tmp;
  }
#line 137
  if ((unsigned long )entry == (unsigned long )((struct servent *)0)) {
#line 137
    tmp___0 = -1;
  } else {
#line 137
    tmp___0 = entry->s_port;
  }
#line 137
  return (tmp___0);
}
}
#line 140 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsock.c"
unsigned long OS_get_service_by_number(unsigned long const   port_number ) 
{ 
  uint16_t tmp ;

  {
  {
#line 143
  tmp = htons((unsigned short )port_number);
  }
#line 143
  return ((unsigned long )tmp);
}
}
#line 146 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsock.c"
unsigned int OS_host_address_length(void) 
{ 


  {
#line 149
  return ((unsigned int )sizeof(struct in_addr ));
}
}
#line 152 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsock.c"
char **OS_get_host_by_name(char const   *host_name ) 
{ 
  struct hostent *entry ;
  struct hostent *tmp ;

  {
  {
#line 155
  tmp = gethostbyname(host_name);
#line 155
  entry = tmp;
  }
#line 156
  if ((unsigned long )entry == (unsigned long )((struct hostent *)0)) {
#line 157
    return ((char **)0);
  }
#line 159
  return (entry->h_addr_list);
}
}
#line 172 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsock.c"
char const   *OS_get_host_name(void) 
{ 
  char host_name[1024] ;
  int tmp ;
  char *result ;
  size_t tmp___0 ;
  void *tmp___1 ;
  void *__cil_tmp6 ;

  {
  {
#line 176
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 176
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 176
      tmp = gethostname(host_name, (size_t )1024);
      }
#line 176
      if (! (tmp < 0)) {
#line 176
        goto while_break___0;
      }
      {
#line 176
      UX_prim_check_errno((enum syscall_names )18);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 176
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 179
  tmp___0 = strlen((char const   *)(host_name));
#line 179
  tmp___1 = OS_malloc(tmp___0 + 1UL);
#line 179
  result = (char *)tmp___1;
#line 180
  strcpy((char */* __restrict  */)result, (char const   */* __restrict  */)(host_name));
  }
#line 181
  return ((char const   *)result);
}
}
#line 185 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsock.c"
char const   *OS_canonical_host_name(char const   *host_name ) 
{ 
  struct hostent *entry ;
  struct hostent *tmp ;
  char *result ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 188
  tmp = gethostbyname(host_name);
#line 188
  entry = tmp;
  }
#line 189
  if ((unsigned long )entry == (unsigned long )((struct hostent *)0)) {
#line 190
    return ((char const   *)0);
  }
  {
#line 192
  tmp___0 = strlen((char const   *)entry->h_name);
#line 192
  tmp___1 = OS_malloc(tmp___0 + 1UL);
#line 192
  result = (char *)tmp___1;
#line 193
  strcpy((char */* __restrict  */)result, (char const   */* __restrict  */)entry->h_name);
  }
#line 194
  return ((char const   *)result);
}
}
#line 198 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsock.c"
char const   *OS_get_host_by_address(char const   *host_addr ) 
{ 
  struct hostent *entry ;
  unsigned int tmp ;
  struct hostent *tmp___0 ;
  char *result ;
  size_t tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 201
  tmp = OS_host_address_length();
#line 201
  tmp___0 = gethostbyaddr((void const   *)host_addr, tmp, 2);
#line 201
  entry = tmp___0;
  }
#line 203
  if ((unsigned long )entry == (unsigned long )((struct hostent *)0)) {
#line 204
    return ((char const   *)0);
  }
  {
#line 206
  tmp___1 = strlen((char const   *)entry->h_name);
#line 206
  tmp___2 = OS_malloc(tmp___1 + 1UL);
#line 206
  result = (char *)tmp___2;
#line 207
  strcpy((char */* __restrict  */)result, (char const   */* __restrict  */)entry->h_name);
  }
#line 208
  return ((char const   *)result);
}
}
#line 212 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsock.c"
void OS_host_address_any(void *addr ) 
{ 


  {
  {
#line 215
  ((struct in_addr *)addr)->s_addr = htonl((in_addr_t )0);
  }
#line 216
  return;
}
}
#line 218 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsock.c"
void OS_host_address_loopback(void *addr ) 
{ 


  {
  {
#line 221
  ((struct in_addr *)addr)->s_addr = htonl((in_addr_t )2130706433);
  }
#line 222
  return;
}
}
#line 225 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsock.c"
Tchannel OS_open_unix_stream_socket(char const   *filename ) 
{ 
  int s ;
  Tchannel channel ;
  Tchannel MAKE_CHANNEL_temp ;
  Tchannel tmp ;
  struct sockaddr_un address___0 ;
  void *__cil_tmp7 ;

  {
  {
#line 231
  transaction_begin();
  }
  {
#line 232
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 232
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 232
      s = socket(1, 1, 0);
      }
#line 232
      if (! (s < 0)) {
#line 232
        goto while_break___0;
      }
      {
#line 232
      UX_prim_check_fd_errno((enum syscall_names )52);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 232
    UX_out_of_files_p = (_Bool)0;
#line 232
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 234
  tmp = channel_allocate();
#line 234
  MAKE_CHANNEL_temp = tmp;
#line 234
  (channel_table + MAKE_CHANNEL_temp)->descriptor = s;
#line 234
  (channel_table + MAKE_CHANNEL_temp)->type = (enum channel_type )6;
#line 234
  (channel_table + MAKE_CHANNEL_temp)->internal = 0U;
#line 234
  (channel_table + MAKE_CHANNEL_temp)->nonblocking = 0U;
#line 234
  channel = MAKE_CHANNEL_temp;
#line 235
  OS_channel_close_on_abort(channel);
#line 238
  memset((void *)(& address___0), 0, sizeof(address___0));
#line 239
  address___0.sun_family = (sa_family_t )1;
#line 240
  strncpy((char */* __restrict  */)(address___0.sun_path), (char const   */* __restrict  */)filename,
          sizeof(address___0.sun_path));
#line 241
  do_connect(s, (struct sockaddr *)(& address___0), (socklen_t )sizeof(address___0));
#line 243
  transaction_commit();
  }
#line 244
  return (channel);
}
}
#line 248 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsock.c"
Tchannel OS_create_tcp_server_socket(void) 
{ 
  int s ;
  Tchannel MAKE_CHANNEL_temp ;
  Tchannel tmp ;

  {
  {
#line 252
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 252
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 252
      s = socket(2, 1, 0);
      }
#line 252
      if (! (s < 0)) {
#line 252
        goto while_break___0;
      }
      {
#line 252
      UX_prim_check_fd_errno((enum syscall_names )52);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 252
    UX_out_of_files_p = (_Bool)0;
#line 252
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 254
  tmp = channel_allocate();
#line 254
  MAKE_CHANNEL_temp = tmp;
#line 254
  (channel_table + MAKE_CHANNEL_temp)->descriptor = s;
#line 254
  (channel_table + MAKE_CHANNEL_temp)->type = (enum channel_type )8;
#line 254
  (channel_table + MAKE_CHANNEL_temp)->internal = 0U;
#line 254
  (channel_table + MAKE_CHANNEL_temp)->nonblocking = 0U;
  }
#line 254
  return (MAKE_CHANNEL_temp);
}
}
#line 257 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsock.c"
void OS_bind_tcp_server_socket(Tchannel channel , void *host , unsigned int port ) 
{ 
  struct sockaddr_in address___0 ;
  int one ;
  int tmp ;
  int tmp___0 ;
  void *__cil_tmp8 ;

  {
  {
#line 261
  one = 1;
#line 263
  memset((void *)(& address___0), 0, sizeof(address___0));
#line 264
  address___0.sin_family = (sa_family_t )2;
#line 265
  memcpy((void */* __restrict  */)(& address___0.sin_addr), (void const   */* __restrict  */)host,
         sizeof(address___0.sin_addr));
#line 266
  address___0.sin_port = (in_port_t )port;
  }
  {
#line 268
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 268
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 268
      tmp = setsockopt((channel_table + channel)->descriptor, 1, 2, (void const   *)(& one),
                       (socklen_t )sizeof(one));
      }
#line 268
      if (! (tmp < 0)) {
#line 268
        goto while_break___0;
      }
      {
#line 268
      UX_prim_check_errno((enum syscall_names )46);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 268
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 275
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 275
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 275
      tmp___0 = bind((channel_table + channel)->descriptor, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& address___0)),
                     (socklen_t )sizeof(struct sockaddr_in ));
      }
#line 275
      if (! (tmp___0 < 0)) {
#line 275
        goto while_break___2;
      }
      {
#line 275
      UX_prim_check_errno((enum syscall_names )1);
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 275
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 280
  return;
}
}
#line 286 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsock.c"
void OS_listen_tcp_server_socket(Tchannel channel ) 
{ 
  int tmp ;

  {
  {
#line 289
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 289
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 289
      tmp = listen((channel_table + channel)->descriptor, 1024);
      }
#line 289
      if (! (tmp < 0)) {
#line 289
        goto while_break___0;
      }
      {
#line 289
      UX_prim_check_errno((enum syscall_names )25);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 289
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 292
  return;
}
}
#line 299 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsock.c"
static struct sockaddr_in address  ;
#line 294 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsock.c"
Tchannel OS_server_connection_accept(Tchannel channel , void *peer_host , unsigned int *peer_port ) 
{ 
  socklen_t address_length ;
  int s ;
  int *tmp ;
  int *tmp___0 ;
  Tchannel MAKE_CHANNEL_temp ;
  Tchannel tmp___1 ;

  {
  {
#line 300
  address_length = (socklen_t )sizeof(struct sockaddr_in );
#line 302
  memset((void *)(& address), 0, sizeof(address));
  }
  {
#line 303
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 305
    s = accept((channel_table + channel)->descriptor, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& address)),
               (socklen_t */* __restrict  */)(& address_length));
    }
#line 308
    if (s >= 0) {
#line 309
      goto while_break;
    }
    {
#line 311
    tmp = __errno_location();
    }
#line 311
    if (*tmp == 11) {
#line 312
      return ((Tchannel )-1);
    }
    {
#line 315
    tmp___0 = __errno_location();
    }
#line 315
    if (*tmp___0 == 11) {
#line 316
      return ((Tchannel )-1);
    }
    {
#line 318
    UX_prim_check_fd_errno((enum syscall_names )0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 320
  UX_out_of_files_p = (_Bool)0;
#line 321
  if ((unsigned long )peer_host != (unsigned long )((void *)0)) {
    {
#line 322
    memcpy((void */* __restrict  */)peer_host, (void const   */* __restrict  */)(& address.sin_addr),
           sizeof(address.sin_addr));
    }
  }
#line 325
  if ((unsigned long )peer_port != (unsigned long )((unsigned int *)0)) {
#line 326
    *peer_port = (unsigned int )address.sin_port;
  }
  {
#line 327
  tmp___1 = channel_allocate();
#line 327
  MAKE_CHANNEL_temp = tmp___1;
#line 327
  (channel_table + MAKE_CHANNEL_temp)->descriptor = s;
#line 327
  (channel_table + MAKE_CHANNEL_temp)->type = (enum channel_type )7;
#line 327
  (channel_table + MAKE_CHANNEL_temp)->internal = 0U;
#line 327
  (channel_table + MAKE_CHANNEL_temp)->nonblocking = 0U;
  }
#line 327
  return (MAKE_CHANNEL_temp);
}
}
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 49 "/home/khheo/project/mit-scheme-9.2/src/microcode/dstack.h"
void dstack_alloc_and_protect(unsigned int length , void (*initializer)(void *environment ) ,
                              void (*protector)(void *environment ) ) ;
#line 72
void transaction_abort(void) ;
#line 37 "/home/khheo/project/mit-scheme-9.2/src/microcode/outf.h"
void ( /* format attribute */  outf_console)(char const   *format  , ...) ;
#line 52
void outf_flush_console(void) ;
#line 353 "/home/khheo/project/mit-scheme-9.2/src/microcode/extern.h"
 __attribute__((__noreturn__)) void termination_normal(int const   value ) ;
#line 360
 __attribute__((__noreturn__)) void termination_signal(char const   *signal_name ) ;
#line 178 "/home/khheo/project/mit-scheme-9.2/src/microcode/cmpintmd.h"
extern void within_c_stack(void (*)(void * ) , void * ) ;
#line 127 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                           int __sig ) ;
#line 215
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigemptyset)(sigset_t *__set ) ;
#line 218
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigfillset)(sigset_t *__set ) ;
#line 221
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigaddset)(sigset_t *__set ,
                                                                                                int __signo ) ;
#line 248
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigprocmask)(int __how ,
                                                                                  sigset_t const   * __restrict  __set ,
                                                                                  sigset_t * __restrict  __oset ) ;
#line 259
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigaction)(int __sig ,
                                                                                struct sigaction  const  * __restrict  __act ,
                                                                                struct sigaction * __restrict  __oact ) ;
#line 598 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) nice)(int __inc ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 125 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 43 "/home/khheo/project/mit-scheme-9.2/src/microcode/intext.h"
int enter_interruption_extent(void) ;
#line 44
void exit_interruption_extent(void) ;
#line 37 "/home/khheo/project/mit-scheme-9.2/src/microcode/osscheme.h"
void debug_edit_flags(void) ;
#line 38
void debug_back_trace(outf_channel stream ) ;
#line 39
void debug_examine_memory(long address___0 , char const   *label ) ;
#line 52
void request_console_resize_interrupt(void) ;
#line 54
void request_timer_interrupt(void) ;
#line 55
void request_suspend_interrupt(void) ;
#line 39 "/home/khheo/project/mit-scheme-9.2/src/microcode/ostty.h"
cc_t OS_tty_map_interrupt_char(cc_t int_char ) ;
#line 36 "/home/khheo/project/mit-scheme-9.2/src/microcode/ostop.h"
void OS_restartable_exit(void) ;
#line 40 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
cc_t OS_ctty_int_char(void) ;
#line 41
cc_t OS_ctty_tstp_char(void) ;
#line 42
cc_t OS_ctty_disabled_char(void) ;
#line 43
void tty_set_next_interrupt_char(cc_t c ) ;
#line 63 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
static Tsignal_handler current_handler(int signo ) 
{ 
  struct sigaction act ;
  void *__cil_tmp3 ;

  {
  {
#line 67
  sigaction(signo, (struct sigaction  const  */* __restrict  */)0, (struct sigaction */* __restrict  */)(& act));
  }
#line 68
  return (act.__sigaction_handler.sa_sigaction);
}
}
#line 71 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
void INSTALL_HANDLER(int signo , void (*handler)(int  , siginfo_t * , void * ) ) 
{ 
  struct sigaction act ;
  void *__cil_tmp4 ;

  {
#line 75
  if ((unsigned long )handler == (unsigned long )((void (*)(int  , siginfo_t * , void * ))((void (*)(int  ))1))) {
#line 78
    act.__sigaction_handler.sa_handler = (void (*)(int  ))((void *)handler);
#line 79
    act.sa_flags = 0;
  } else
#line 75
  if ((unsigned long )handler == (unsigned long )((void (*)(int  , siginfo_t * , void * ))((void (*)(int  ))0))) {
#line 78
    act.__sigaction_handler.sa_handler = (void (*)(int  ))((void *)handler);
#line 79
    act.sa_flags = 0;
  } else {
#line 83
    act.__sigaction_handler.sa_sigaction = handler;
#line 84
    act.sa_flags = 4;
  }
  {
#line 90
  sigemptyset(& act.sa_mask);
#line 91
  sigaddset(& act.sa_mask, signo);
#line 92
  sigaction(signo, (struct sigaction  const  */* __restrict  */)(& act), (struct sigaction */* __restrict  */)0);
  }
#line 93
  return;
}
}
#line 134 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
static void restore_signal_mask(void *environment ) 
{ 


  {
  {
#line 137
  sigprocmask(2, (sigset_t const   */* __restrict  */)((sigset_t *)environment), (sigset_t */* __restrict  */)0);
  }
#line 138
  return;
}
}
#line 140 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
static void save_signal_mask(void *environment ) 
{ 


  {
  {
#line 143
  sigprocmask(2, (sigset_t const   */* __restrict  */)0, (sigset_t */* __restrict  */)((sigset_t *)environment));
  }
#line 144
  return;
}
}
#line 146 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
void preserve_signal_mask(void) 
{ 


  {
  {
#line 149
  dstack_alloc_and_protect((unsigned int )sizeof(sigset_t ), & save_signal_mask, & restore_signal_mask);
  }
#line 151
  return;
}
}
#line 153 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
static sigset_t blocked_signals  ;
#line 155 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
void block_signals(void) 
{ 
  sigset_t all_signals ;
  void *__cil_tmp2 ;

  {
  {
#line 159
  sigfillset(& all_signals);
#line 160
  sigprocmask(0, (sigset_t const   */* __restrict  */)(& all_signals), (sigset_t */* __restrict  */)(& blocked_signals));
  }
#line 161
  return;
}
}
#line 163 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
void unblock_signals(void) 
{ 


  {
  {
#line 166
  sigprocmask(2, (sigset_t const   */* __restrict  */)(& blocked_signals), (sigset_t */* __restrict  */)0);
  }
#line 167
  return;
}
}
#line 188 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
void deactivate_handler(int signo ) 
{ 


  {
  {
#line 191
  INSTALL_HANDLER(signo, (void (*)(int  , siginfo_t * , void * ))((void (*)(int  ))1));
  }
#line 192
  return;
}
}
#line 194 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
void activate_handler(int signo , void (*handler)(int  , siginfo_t * , void * ) ) 
{ 


  {
  {
#line 197
  INSTALL_HANDLER(signo, handler);
  }
#line 198
  return;
}
}
#line 251 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
static struct signal_descriptor *signal_descriptors  ;
#line 252 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
static unsigned int signal_descriptors_length  ;
#line 253 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
static unsigned int signal_descriptors_limit  ;
#line 255 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
static void defsignal(int signo , char const   *name , enum dfl_action action , int flags ) 
{ 
  void *tmp ;
  struct signal_descriptor *sd ;
  unsigned int tmp___0 ;

  {
#line 258
  if (signo == 0) {
#line 259
    return;
  }
#line 260
  if (signal_descriptors_length == signal_descriptors_limit) {
    {
#line 262
    signal_descriptors_limit += 8U;
#line 263
    tmp = realloc((void *)signal_descriptors, (unsigned long )signal_descriptors_limit * sizeof(struct signal_descriptor ));
#line 263
    signal_descriptors = (struct signal_descriptor *)tmp;
    }
#line 267
    if ((unsigned long )signal_descriptors == (unsigned long )((struct signal_descriptor *)0)) {
      {
#line 269
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nUnable to grow signal definitions table.\n");
#line 270
      fflush(stderr);
#line 271
      termination_init_error();
      }
    }
  }
#line 275
  tmp___0 = signal_descriptors_length;
#line 275
  signal_descriptors_length ++;
#line 275
  sd = signal_descriptors + tmp___0;
#line 277
  sd->signo = signo;
#line 278
  sd->name = name;
#line 279
  sd->action = action;
#line 280
  sd->flags = flags;
#line 282
  return;
}
}
#line 284 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
static struct signal_descriptor *find_signal_descriptor(int signo ) 
{ 
  struct signal_descriptor *scan ;
  struct signal_descriptor *end ;

  {
#line 287
  scan = signal_descriptors;
#line 288
  end = scan + signal_descriptors_length;
  {
#line 289
  while (1) {
    while_continue: /* CIL Label */ ;
#line 289
    if (! ((unsigned long )scan < (unsigned long )end)) {
#line 289
      goto while_break;
    }
#line 290
    if (scan->signo == signo) {
#line 291
      return (scan);
    }
#line 289
    scan ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 292
  return ((struct signal_descriptor *)0);
}
}
#line 298 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
static char buffer___1[32]  ;
#line 295 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
char const   *find_signal_name(int signo ) 
{ 
  struct signal_descriptor *descriptor ;
  struct signal_descriptor *tmp ;
  char *__cil_tmp4 ;

  {
  {
#line 299
  tmp = find_signal_descriptor(signo);
#line 299
  descriptor = tmp;
  }
#line 300
  if ((unsigned long )descriptor != (unsigned long )((struct signal_descriptor *)0)) {
#line 301
    return (descriptor->name);
  }
  {
#line 302
  sprintf((char */* __restrict  */)(buffer___1), (char const   */* __restrict  */)"unknown signal %d",
          signo);
  }
#line 303
  return ((char const   *)(buffer___1));
}
}
#line 311 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
static void initialize_signal_descriptors(void) 
{ 
  void *tmp ;
  int __cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;

  {
  {
#line 314
  signal_descriptors_length = 0U;
#line 315
  signal_descriptors_limit = 32U;
#line 316
  tmp = malloc((unsigned long )signal_descriptors_limit * sizeof(struct signal_descriptor ));
#line 316
  signal_descriptors = (struct signal_descriptor *)tmp;
  }
#line 319
  if ((unsigned long )signal_descriptors == (unsigned long )((struct signal_descriptor *)0)) {
    {
#line 321
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nUnable to allocate signal definitions table.\n");
#line 322
    fflush(stderr);
#line 323
    termination_init_error();
    }
  }
  {
#line 325
  defsignal(1, "SIGHUP", (enum dfl_action )0, 0);
#line 326
  defsignal(2, "SIGINT", (enum dfl_action )0, 0);
#line 327
  defsignal(3, "SIGQUIT", (enum dfl_action )0, 8);
#line 328
  defsignal(4, "SIGILL", (enum dfl_action )0, 8);
#line 329
  defsignal(5, "SIGTRAP", (enum dfl_action )0, 8);
#line 330
  defsignal(6, "SIGIOT", (enum dfl_action )0, 8);
#line 331
  defsignal(0, "SIGEMT", (enum dfl_action )0, 8);
#line 333
  defsignal(8, "SIGFPE", (enum dfl_action )0, 8);
#line 335
  defsignal(9, "SIGKILL", (enum dfl_action )0, 7);
#line 336
  defsignal(7, "SIGBUS", (enum dfl_action )0, 8);
#line 337
  defsignal(11, "SIGSEGV", (enum dfl_action )0, 8);
#line 338
  defsignal(31, "SIGSYS", (enum dfl_action )0, 8);
#line 339
  defsignal(13, "SIGPIPE", (enum dfl_action )0, 0);
#line 340
  defsignal(14, "SIGALRM", (enum dfl_action )0, 0);
#line 341
  defsignal(15, "SIGTERM", (enum dfl_action )0, 0);
#line 342
  defsignal(10, "SIGUSR1", (enum dfl_action )0, 0);
#line 343
  defsignal(12, "SIGUSR2", (enum dfl_action )0, 0);
#line 344
  defsignal(0, "SIGABRT", (enum dfl_action )0, 8);
#line 345
  defsignal(29, "SIGIO", (enum dfl_action )1, 0);
#line 346
  defsignal(23, "SIGURG", (enum dfl_action )1, 0);
#line 347
  defsignal(26, "SIGVTALRM", (enum dfl_action )0, 0);
#line 348
  defsignal(27, "SIGPROF", (enum dfl_action )0, 0);
#line 349
  defsignal(19, "SIGSTOP", (enum dfl_action )2, 7);
#line 350
  defsignal(20, "SIGTSTP", (enum dfl_action )2, 0);
#line 351
  defsignal(18, "SIGCONT", (enum dfl_action )1, 3);
#line 352
  defsignal(17, "SIGCHLD", (enum dfl_action )1, 0);
#line 353
  defsignal(21, "SIGTTIN", (enum dfl_action )2, 0);
#line 354
  defsignal(22, "SIGTTOU", (enum dfl_action )2, 0);
#line 355
  defsignal(0, "SIGLOST", (enum dfl_action )0, 0);
#line 356
  defsignal(24, "SIGXCPU", (enum dfl_action )0, 0);
#line 357
  defsignal(25, "SIGXFSZ", (enum dfl_action )0, 0);
#line 358
  defsignal(30, "SIGPWR", (enum dfl_action )1, 0);
#line 359
  defsignal(0, "SIGWINDOW", (enum dfl_action )1, 0);
#line 360
  defsignal(28, "SIGWINCH", (enum dfl_action )1, 0);
  }
#line 361
  return;
}
}
#line 368 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
static void echo_keyboard_interrupt(cc_t c , cc_t dc ) 
{ 
  cc_t tmp ;

  {
  {
#line 371
  tmp = OS_ctty_disabled_char();
  }
#line 371
  if ((int )c == (int )tmp) {
#line 372
    c = dc;
  }
#line 373
  c = (cc_t )((int )c & 127);
#line 374
  if ((int )c == 7) {
    {
#line 375
    _IO_putc((int )c, stdout);
    }
  } else
#line 376
  if ((int )c < 32) {
    {
#line 378
    _IO_putc('^', stdout);
#line 379
    _IO_putc((int )c + 64, stdout);
    }
  } else
#line 381
  if ((int )c == 127) {
    {
#line 382
    fputs((char const   */* __restrict  */)"^?", (FILE */* __restrict  */)stdout);
    }
  } else {
    {
#line 384
    _IO_putc((int )c, stdout);
    }
  }
  {
#line 385
  fflush(stdout);
  }
#line 386
  return;
}
}
#line 388 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
static Tsignal_handler_result sighnd_control_g_body(int signo , siginfo_t *info ,
                                                    void *pscp ) 
{ 
  int STD_HANDLER_abortp ;
  ucontext_t *scp  __attribute__((__unused__)) ;
  cc_t tmp ;

  {
  {
#line 389
  scp = (ucontext_t *)pscp;
#line 389
  STD_HANDLER_abortp = enter_interruption_extent();
#line 389
  tmp = OS_ctty_int_char();
#line 389
  echo_keyboard_interrupt(tmp, (cc_t )'\a');
#line 389
  tty_set_next_interrupt_char((cc_t )'G');
  }
#line 389
  if (STD_HANDLER_abortp) {
    {
#line 389
    exit_interruption_extent();
    }
  }
#line 389
  return;
}
}
#line 389 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
void sighnd_control_g_wrapper(void *context ) 
{ 
  struct signal_instance *i ;

  {
  {
#line 389
  i = (struct signal_instance *)context;
#line 389
  sighnd_control_g_body(i->signo, i->info, i->pscp);
  }
#line 389
  return;
}
}
#line 389 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
Tsignal_handler_result sighnd_control_g(int signo , siginfo_t *info , void *pscp ) 
{ 
  struct signal_instance i ;

  {
  {
#line 389
  i.signo = signo;
#line 389
  i.info = info;
#line 389
  i.pscp = pscp;
#line 389
  within_c_stack(& sighnd_control_g_wrapper, (void *)(& i));
  }
#line 389
  return;
}
}
#line 395 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
static Tsignal_handler_result sighnd_control_u_body(int signo , siginfo_t *info ,
                                                    void *pscp ) 
{ 
  int STD_HANDLER_abortp ;
  ucontext_t *scp  __attribute__((__unused__)) ;

  {
  {
#line 396
  scp = (ucontext_t *)pscp;
#line 396
  STD_HANDLER_abortp = enter_interruption_extent();
#line 396
  tty_set_next_interrupt_char((cc_t )'U');
  }
#line 396
  if (STD_HANDLER_abortp) {
    {
#line 396
    exit_interruption_extent();
    }
  }
#line 396
  return;
}
}
#line 396 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
void sighnd_control_u_wrapper(void *context ) 
{ 
  struct signal_instance *i ;

  {
  {
#line 396
  i = (struct signal_instance *)context;
#line 396
  sighnd_control_u_body(i->signo, i->info, i->pscp);
  }
#line 396
  return;
}
}
#line 396 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
Tsignal_handler_result sighnd_control_u(int signo , siginfo_t *info , void *pscp ) 
{ 
  struct signal_instance i ;

  {
  {
#line 396
  i.signo = signo;
#line 396
  i.info = info;
#line 396
  i.pscp = pscp;
#line 396
  within_c_stack(& sighnd_control_u_wrapper, (void *)(& i));
  }
#line 396
  return;
}
}
#line 401 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
static Tsignal_handler_result sighnd_control_x_body(int signo , siginfo_t *info ,
                                                    void *pscp ) 
{ 
  int STD_HANDLER_abortp ;
  ucontext_t *scp  __attribute__((__unused__)) ;

  {
  {
#line 402
  scp = (ucontext_t *)pscp;
#line 402
  STD_HANDLER_abortp = enter_interruption_extent();
#line 402
  tty_set_next_interrupt_char((cc_t )'X');
  }
#line 402
  if (STD_HANDLER_abortp) {
    {
#line 402
    exit_interruption_extent();
    }
  }
#line 402
  return;
}
}
#line 402 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
void sighnd_control_x_wrapper(void *context ) 
{ 
  struct signal_instance *i ;

  {
  {
#line 402
  i = (struct signal_instance *)context;
#line 402
  sighnd_control_x_body(i->signo, i->info, i->pscp);
  }
#line 402
  return;
}
}
#line 402 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
Tsignal_handler_result sighnd_control_x(int signo , siginfo_t *info , void *pscp ) 
{ 
  struct signal_instance i ;

  {
  {
#line 402
  i.signo = signo;
#line 402
  i.info = info;
#line 402
  i.pscp = pscp;
#line 402
  within_c_stack(& sighnd_control_x_wrapper, (void *)(& i));
  }
#line 402
  return;
}
}
#line 407 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
static Tsignal_handler_result sighnd_control_b_body(int signo , siginfo_t *info ,
                                                    void *pscp ) 
{ 
  int STD_HANDLER_abortp ;
  ucontext_t *scp  __attribute__((__unused__)) ;

  {
  {
#line 408
  scp = (ucontext_t *)pscp;
#line 408
  STD_HANDLER_abortp = enter_interruption_extent();
#line 408
  tty_set_next_interrupt_char((cc_t )'B');
  }
#line 408
  if (STD_HANDLER_abortp) {
    {
#line 408
    exit_interruption_extent();
    }
  }
#line 408
  return;
}
}
#line 408 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
void sighnd_control_b_wrapper(void *context ) 
{ 
  struct signal_instance *i ;

  {
  {
#line 408
  i = (struct signal_instance *)context;
#line 408
  sighnd_control_b_body(i->signo, i->info, i->pscp);
  }
#line 408
  return;
}
}
#line 408 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
Tsignal_handler_result sighnd_control_b(int signo , siginfo_t *info , void *pscp ) 
{ 
  struct signal_instance i ;

  {
  {
#line 408
  i.signo = signo;
#line 408
  i.info = info;
#line 408
  i.pscp = pscp;
#line 408
  within_c_stack(& sighnd_control_b_wrapper, (void *)(& i));
  }
#line 408
  return;
}
}
#line 413
static void interactive_interrupt_handler(ucontext_t *scp ) ;
#line 415 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
static Tsignal_handler_result sighnd_interactive_body(int signo , siginfo_t *info ,
                                                      void *pscp ) 
{ 
  int STD_HANDLER_abortp ;
  ucontext_t *scp  __attribute__((__unused__)) ;

  {
  {
#line 416
  scp = (ucontext_t *)pscp;
#line 416
  STD_HANDLER_abortp = enter_interruption_extent();
#line 416
  interactive_interrupt_handler(scp);
  }
#line 416
  if (STD_HANDLER_abortp) {
    {
#line 416
    exit_interruption_extent();
    }
  }
#line 416
  return;
}
}
#line 416 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
void sighnd_interactive_wrapper(void *context ) 
{ 
  struct signal_instance *i ;

  {
  {
#line 416
  i = (struct signal_instance *)context;
#line 416
  sighnd_interactive_body(i->signo, i->info, i->pscp);
  }
#line 416
  return;
}
}
#line 416 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
Tsignal_handler_result sighnd_interactive(int signo , siginfo_t *info , void *pscp ) 
{ 
  struct signal_instance i ;

  {
  {
#line 416
  i.signo = signo;
#line 416
  i.info = info;
#line 416
  i.pscp = pscp;
#line 416
  within_c_stack(& sighnd_interactive_wrapper, (void *)(& i));
  }
#line 416
  return;
}
}
#line 419 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
void stop_signal_default(int signo ) 
{ 
  sigset_t signo_mask ;
  sigset_t old_mask ;
  void (*handler)(int  , siginfo_t * , void * ) ;
  __pid_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp8 ;
  void *__cil_tmp9 ;

  {
  {
#line 423
  tmp___0 = isatty(0);
  }
#line 423
  if (tmp___0) {
    {
#line 423
    tmp___1 = isatty(1);
    }
#line 423
    if (tmp___1) {
#line 423
      if (! option_emacs_subprocess) {
        {
#line 434
        OS_save_internal_state();
#line 435
        OS_restore_external_state();
#line 438
        handler = current_handler(signo);
#line 439
        INSTALL_HANDLER(signo, (void (*)(int  , siginfo_t * , void * ))((void (*)(int  ))0));
#line 442
        sigemptyset(& signo_mask);
#line 443
        sigaddset(& signo_mask, signo);
#line 444
        sigprocmask(1, (sigset_t const   */* __restrict  */)(& signo_mask), (sigset_t */* __restrict  */)(& old_mask));
#line 445
        tmp = getpid();
#line 445
        kill(tmp, signo);
#line 446
        sigprocmask(2, (sigset_t const   */* __restrict  */)(& old_mask), (sigset_t */* __restrict  */)0);
#line 449
        INSTALL_HANDLER(signo, handler);
#line 452
        OS_save_external_state();
#line 453
        OS_restore_internal_state();
        }
      }
    }
  }
#line 456
  return;
}
}
#line 458 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
void (*stop_signal_hook)(int signo )  ;
#line 466 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
static Tsignal_handler_result sighnd_stop_body(int signo , siginfo_t *info , void *pscp ) 
{ 
  int STD_HANDLER_abortp ;
  ucontext_t *scp  __attribute__((__unused__)) ;
  sigset_t old_mask ;
  sigset_t jc_mask ;
  void *__cil_tmp8 ;
  void *__cil_tmp9 ;

  {
  {
#line 467
  scp = (ucontext_t *)pscp;
#line 467
  STD_HANDLER_abortp = enter_interruption_extent();
  }
  {
#line 467
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 467
    sigemptyset(& jc_mask);
#line 467
    sigaddset(& jc_mask, 22);
#line 467
    sigaddset(& jc_mask, 21);
#line 467
    sigaddset(& jc_mask, 20);
#line 467
    sigaddset(& jc_mask, 19);
#line 467
    sigaddset(& jc_mask, 17);
#line 467
    sigprocmask(0, (sigset_t const   */* __restrict  */)(& jc_mask), (sigset_t */* __restrict  */)(& old_mask));
    }
#line 467
    if ((unsigned long )stop_signal_hook == (unsigned long )((void (*)(int signo ))0)) {
      {
#line 467
      stop_signal_default(signo);
      }
    } else {
      {
#line 467
      (*stop_signal_hook)(signo);
      }
    }
    {
#line 467
    sigprocmask(2, (sigset_t const   */* __restrict  */)(& old_mask), (sigset_t */* __restrict  */)0);
    }
#line 467
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 467
  if (STD_HANDLER_abortp) {
    {
#line 467
    exit_interruption_extent();
    }
  }
#line 467
  return;
}
}
#line 467 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
void sighnd_stop_wrapper(void *context ) 
{ 
  struct signal_instance *i ;

  {
  {
#line 467
  i = (struct signal_instance *)context;
#line 467
  sighnd_stop_body(i->signo, i->info, i->pscp);
  }
#line 467
  return;
}
}
#line 467 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
Tsignal_handler_result sighnd_stop(int signo , siginfo_t *info , void *pscp ) 
{ 
  struct signal_instance i ;

  {
  {
#line 467
  i.signo = signo;
#line 467
  i.info = info;
#line 467
  i.pscp = pscp;
#line 467
  within_c_stack(& sighnd_stop_wrapper, (void *)(& i));
  }
#line 467
  return;
}
}
#line 495 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
void OS_restartable_exit(void) 
{ 


  {
  {
#line 498
  stop_signal_default(20);
  }
#line 499
  return;
}
}
#line 501 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
static Tsignal_handler_result sighnd_console_resize_body(int signo , siginfo_t *info ,
                                                         void *pscp ) 
{ 
  int STD_HANDLER_abortp ;
  ucontext_t *scp  __attribute__((__unused__)) ;

  {
  {
#line 502
  scp = (ucontext_t *)pscp;
#line 502
  STD_HANDLER_abortp = enter_interruption_extent();
#line 502
  UX_reinitialize_tty();
#line 502
  request_console_resize_interrupt();
  }
#line 502
  if (STD_HANDLER_abortp) {
    {
#line 502
    exit_interruption_extent();
    }
  }
#line 502
  return;
}
}
#line 502 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
void sighnd_console_resize_wrapper(void *context ) 
{ 
  struct signal_instance *i ;

  {
  {
#line 502
  i = (struct signal_instance *)context;
#line 502
  sighnd_console_resize_body(i->signo, i->info, i->pscp);
  }
#line 502
  return;
}
}
#line 502 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
Tsignal_handler_result sighnd_console_resize(int signo , siginfo_t *info , void *pscp ) 
{ 
  struct signal_instance i ;

  {
  {
#line 502
  i.signo = signo;
#line 502
  i.info = info;
#line 502
  i.pscp = pscp;
#line 502
  within_c_stack(& sighnd_console_resize_wrapper, (void *)(& i));
  }
#line 502
  return;
}
}
#line 515 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
static Tsignal_handler_result sighnd_timer_body(int signo , siginfo_t *info , void *pscp ) 
{ 
  int STD_HANDLER_abortp ;
  ucontext_t *scp  __attribute__((__unused__)) ;

  {
  {
#line 516
  scp = (ucontext_t *)pscp;
#line 516
  STD_HANDLER_abortp = enter_interruption_extent();
#line 516
  request_timer_interrupt();
  }
#line 516
  if (STD_HANDLER_abortp) {
    {
#line 516
    exit_interruption_extent();
    }
  }
#line 516
  return;
}
}
#line 516 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
void sighnd_timer_wrapper(void *context ) 
{ 
  struct signal_instance *i ;

  {
  {
#line 516
  i = (struct signal_instance *)context;
#line 516
  sighnd_timer_body(i->signo, i->info, i->pscp);
  }
#line 516
  return;
}
}
#line 516 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
Tsignal_handler_result sighnd_timer(int signo , siginfo_t *info , void *pscp ) 
{ 
  struct signal_instance i ;

  {
  {
#line 516
  i.signo = signo;
#line 516
  i.info = info;
#line 516
  i.pscp = pscp;
#line 516
  within_c_stack(& sighnd_timer_wrapper, (void *)(& i));
  }
#line 516
  return;
}
}
#line 534 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
static Tsignal_handler_result sighnd_save_then_terminate_body(int signo , siginfo_t *info ,
                                                              void *pscp ) 
{ 
  int STD_HANDLER_abortp ;
  ucontext_t *scp  __attribute__((__unused__)) ;

  {
  {
#line 535
  scp = (ucontext_t *)pscp;
#line 535
  STD_HANDLER_abortp = enter_interruption_extent();
#line 535
  request_suspend_interrupt();
  }
#line 535
  if (STD_HANDLER_abortp) {
    {
#line 535
    exit_interruption_extent();
    }
  }
#line 535
  return;
}
}
#line 535 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
void sighnd_save_then_terminate_wrapper(void *context ) 
{ 
  struct signal_instance *i ;

  {
  {
#line 535
  i = (struct signal_instance *)context;
#line 535
  sighnd_save_then_terminate_body(i->signo, i->info, i->pscp);
  }
#line 535
  return;
}
}
#line 535 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
Tsignal_handler_result sighnd_save_then_terminate(int signo , siginfo_t *info , void *pscp ) 
{ 
  struct signal_instance i ;

  {
  {
#line 535
  i.signo = signo;
#line 535
  i.info = info;
#line 535
  i.pscp = pscp;
#line 535
  within_c_stack(& sighnd_save_then_terminate_wrapper, (void *)(& i));
  }
#line 535
  return;
}
}
#line 538 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
static Tsignal_handler_result sighnd_terminate_body(int signo , siginfo_t *info ,
                                                    void *pscp ) 
{ 
  int STD_HANDLER_abortp ;
  ucontext_t *scp  __attribute__((__unused__)) ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 539
  scp = (ucontext_t *)pscp;
#line 539
  STD_HANDLER_abortp = enter_interruption_extent();
  }
#line 539
  if (option_emacs_subprocess) {
#line 539
    if (signo == 1) {
#line 539
      tmp___0 = (char const   *)0;
    } else {
      {
#line 539
      tmp = find_signal_name(signo);
#line 539
      tmp___0 = tmp;
      }
    }
  } else {
    {
#line 539
    tmp = find_signal_name(signo);
#line 539
    tmp___0 = tmp;
    }
  }
  {
#line 539
  termination_signal(tmp___0);
  }
#line 539
  if (STD_HANDLER_abortp) {
    {
#line 539
    exit_interruption_extent();
    }
  }
#line 539
  return;
}
}
#line 539 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
void sighnd_terminate_wrapper(void *context ) 
{ 
  struct signal_instance *i ;

  {
  {
#line 539
  i = (struct signal_instance *)context;
#line 539
  sighnd_terminate_body(i->signo, i->info, i->pscp);
  }
#line 539
  return;
}
}
#line 539 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
Tsignal_handler_result sighnd_terminate(int signo , siginfo_t *info , void *pscp ) 
{ 
  struct signal_instance i ;

  {
  {
#line 539
  i.signo = signo;
#line 539
  i.info = info;
#line 539
  i.pscp = pscp;
#line 539
  within_c_stack(& sighnd_terminate_wrapper, (void *)(& i));
  }
#line 539
  return;
}
}
#line 546
void clear_float_exceptions(void) ;
#line 548 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
static Tsignal_handler_result sighnd_fpe_body(int signo , siginfo_t *info , void *pscp ) 
{ 
  int STD_HANDLER_abortp ;
  ucontext_t *scp  __attribute__((__unused__)) ;
  char *__cil_tmp6 ;

  {
  {
#line 549
  scp = (ucontext_t *)pscp;
#line 549
  STD_HANDLER_abortp = enter_interruption_extent();
#line 549
  clear_float_exceptions();
#line 549
  trap_handler("floating-point exception", signo, info, scp);
  }
#line 549
  if (STD_HANDLER_abortp) {
    {
#line 549
    exit_interruption_extent();
    }
  }
#line 549
  return;
}
}
#line 549 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
void sighnd_fpe_wrapper(void *context ) 
{ 
  struct signal_instance *i ;

  {
  {
#line 549
  i = (struct signal_instance *)context;
#line 549
  sighnd_fpe_body(i->signo, i->info, i->pscp);
  }
#line 549
  return;
}
}
#line 549 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
Tsignal_handler_result sighnd_fpe(int signo , siginfo_t *info , void *pscp ) 
{ 
  struct signal_instance i ;

  {
  {
#line 549
  i.signo = signo;
#line 549
  i.info = info;
#line 549
  i.pscp = pscp;
#line 549
  within_c_stack(& sighnd_fpe_wrapper, (void *)(& i));
  }
#line 549
  return;
}
}
#line 556 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
static Tsignal_handler_result sighnd_hardware_trap_body(int signo , siginfo_t *info ,
                                                        void *pscp ) 
{ 
  int STD_HANDLER_abortp ;
  ucontext_t *scp  __attribute__((__unused__)) ;
  char *__cil_tmp6 ;

  {
  {
#line 557
  scp = (ucontext_t *)pscp;
#line 557
  STD_HANDLER_abortp = enter_interruption_extent();
#line 557
  trap_handler("hardware fault", signo, info, scp);
  }
#line 557
  if (STD_HANDLER_abortp) {
    {
#line 557
    exit_interruption_extent();
    }
  }
#line 557
  return;
}
}
#line 557 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
void sighnd_hardware_trap_wrapper(void *context ) 
{ 
  struct signal_instance *i ;

  {
  {
#line 557
  i = (struct signal_instance *)context;
#line 557
  sighnd_hardware_trap_body(i->signo, i->info, i->pscp);
  }
#line 557
  return;
}
}
#line 557 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
Tsignal_handler_result sighnd_hardware_trap(int signo , siginfo_t *info , void *pscp ) 
{ 
  struct signal_instance i ;

  {
  {
#line 557
  i.signo = signo;
#line 557
  i.info = info;
#line 557
  i.pscp = pscp;
#line 557
  within_c_stack(& sighnd_hardware_trap_wrapper, (void *)(& i));
  }
#line 557
  return;
}
}
#line 560 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
static Tsignal_handler_result sighnd_software_trap_body(int signo , siginfo_t *info ,
                                                        void *pscp ) 
{ 
  int STD_HANDLER_abortp ;
  ucontext_t *scp  __attribute__((__unused__)) ;
  char *__cil_tmp6 ;

  {
  {
#line 561
  scp = (ucontext_t *)pscp;
#line 561
  STD_HANDLER_abortp = enter_interruption_extent();
#line 561
  trap_handler("system software fault", signo, info, scp);
  }
#line 561
  if (STD_HANDLER_abortp) {
    {
#line 561
    exit_interruption_extent();
    }
  }
#line 561
  return;
}
}
#line 561 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
void sighnd_software_trap_wrapper(void *context ) 
{ 
  struct signal_instance *i ;

  {
  {
#line 561
  i = (struct signal_instance *)context;
#line 561
  sighnd_software_trap_body(i->signo, i->info, i->pscp);
  }
#line 561
  return;
}
}
#line 561 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
Tsignal_handler_result sighnd_software_trap(int signo , siginfo_t *info , void *pscp ) 
{ 
  struct signal_instance i ;

  {
  {
#line 561
  i.signo = signo;
#line 561
  i.info = info;
#line 561
  i.pscp = pscp;
#line 561
  within_c_stack(& sighnd_software_trap_wrapper, (void *)(& i));
  }
#line 561
  return;
}
}
#line 570 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
static Tsignal_handler_result sighnd_renice_body(int signo , siginfo_t *info , void *pscp ) 
{ 
  int STD_HANDLER_abortp ;
  ucontext_t *scp  __attribute__((__unused__)) ;
  int tmp ;

  {
  {
#line 571
  scp = (ucontext_t *)pscp;
#line 571
  STD_HANDLER_abortp = enter_interruption_extent();
#line 571
  tmp = nice(5);
#line 571
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n;;; Renicing! New nice value = %d\n",
          tmp + 20);
#line 571
  fflush(stderr);
  }
#line 571
  if (STD_HANDLER_abortp) {
    {
#line 571
    exit_interruption_extent();
    }
  }
#line 571
  return;
}
}
#line 571 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
void sighnd_renice_wrapper(void *context ) 
{ 
  struct signal_instance *i ;

  {
  {
#line 571
  i = (struct signal_instance *)context;
#line 571
  sighnd_renice_body(i->signo, i->info, i->pscp);
  }
#line 571
  return;
}
}
#line 571 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
Tsignal_handler_result sighnd_renice(int signo , siginfo_t *info , void *pscp ) 
{ 
  struct signal_instance i ;

  {
  {
#line 571
  i.signo = signo;
#line 571
  i.info = info;
#line 571
  i.pscp = pscp;
#line 571
  within_c_stack(& sighnd_renice_wrapper, (void *)(& i));
  }
#line 571
  return;
}
}
#line 596 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
void (*subprocess_death_hook)(pid_t pid , int *status )  ;
#line 606 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
static Tsignal_handler_result sighnd_dead_subprocess_body(int signo , siginfo_t *info ,
                                                          void *pscp ) 
{ 
  int STD_HANDLER_abortp ;
  ucontext_t *scp  __attribute__((__unused__)) ;
  int status ;
  pid_t pid ;
  __pid_t tmp ;

  {
  {
#line 607
  scp = (ucontext_t *)pscp;
#line 607
  STD_HANDLER_abortp = enter_interruption_extent();
  }
  {
#line 607
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 607
    tmp = waitpid(-1, & status, 3);
#line 607
    pid = tmp;
    }
#line 607
    if (pid <= 0) {
#line 607
      goto while_break;
    }
#line 607
    if ((unsigned long )subprocess_death_hook != (unsigned long )((void (*)(pid_t pid ,
                                                                            int *status ))0)) {
      {
#line 607
      (*subprocess_death_hook)(pid, & status);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 607
  if (STD_HANDLER_abortp) {
    {
#line 607
    exit_interruption_extent();
    }
  }
#line 607
  return;
}
}
#line 607 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
void sighnd_dead_subprocess_wrapper(void *context ) 
{ 
  struct signal_instance *i ;

  {
  {
#line 607
  i = (struct signal_instance *)context;
#line 607
  sighnd_dead_subprocess_body(i->signo, i->info, i->pscp);
  }
#line 607
  return;
}
}
#line 607 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
Tsignal_handler_result sighnd_dead_subprocess(int signo , siginfo_t *info , void *pscp ) 
{ 
  struct signal_instance i ;

  {
  {
#line 607
  i.signo = signo;
#line 607
  i.info = info;
#line 607
  i.pscp = pscp;
#line 607
  within_c_stack(& sighnd_dead_subprocess_wrapper, (void *)(& i));
  }
#line 607
  return;
}
}
#line 623 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
static void bind_handler(int signo , void (*handler)(int  , siginfo_t * , void * ) ) 
{ 
  void (*old_handler)(int  , siginfo_t * , void * ) ;
  Tsignal_handler tmp ;
  void (*tmp___0)(int  , siginfo_t * , void * ) ;

  {
#line 626
  if (signo == 0) {
#line 626
    tmp___0 = (void (*)(int  , siginfo_t * , void * ))((void (*)(int  ))0);
  } else {
    {
#line 626
    tmp = current_handler(signo);
#line 626
    tmp___0 = tmp;
    }
  }
#line 626
  old_handler = tmp___0;
#line 631
  if (signo != 0) {
#line 631
    if ((unsigned long )old_handler == (unsigned long )((void (*)(int  , siginfo_t * ,
                                                                  void * ))((void (*)(int  ))0))) {
#line 631
      goto _L;
    } else
#line 631
    if ((unsigned long )old_handler == (unsigned long )((void (*)(int  , siginfo_t * ,
                                                                  void * ))((void (*)(int  ))1))) {
#line 631
      if (signo == 17) {
        _L: /* CIL Label */ 
#line 631
        if ((unsigned long )handler != (unsigned long )(& sighnd_stop)) {
          {
#line 637
          INSTALL_HANDLER(signo, handler);
          }
        } else {
          {
#line 637
          INSTALL_HANDLER(signo, handler);
          }
        }
      }
    }
  }
#line 638
  return;
}
}
#line 640 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
static void unblock_all_signals(void) 
{ 
  sigset_t empty_mask ;
  void *__cil_tmp2 ;

  {
  {
#line 647
  sigemptyset(& empty_mask);
#line 648
  sigprocmask(2, (sigset_t const   */* __restrict  */)(& empty_mask), (sigset_t */* __restrict  */)0);
  }
#line 658
  return;
}
}
#line 660 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
void UX_initialize_signals(void) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  struct signal_descriptor *scan ;
  struct signal_descriptor *end ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 663
  stop_signal_hook = (void (*)(int signo ))0;
#line 664
  subprocess_death_hook = (void (*)(pid_t pid , int *status ))0;
#line 665
  initialize_signal_descriptors();
#line 667
  bind_handler(2, & sighnd_control_g);
#line 669
  bind_handler(8, & sighnd_fpe);
#line 671
  bind_handler(14, & sighnd_timer);
#line 672
  bind_handler(26, & sighnd_timer);
#line 673
  bind_handler(10, & sighnd_save_then_terminate);
#line 675
  bind_handler(12, & sighnd_renice);
#line 677
  bind_handler(17, & sighnd_dead_subprocess);
#line 681
  bind_handler(13, (void (*)(int  , siginfo_t * , void * ))((void (*)(int  ))1));
#line 682
  tmp___2 = isatty(0);
  }
#line 682
  if (tmp___2) {
#line 682
    goto _L;
  } else
#line 682
  if (option_emacs_subprocess) {
    _L: /* CIL Label */ 
    {
#line 684
    tmp = getenv("USE_SCHEMATIK_STYLE_INTERRUPTS");
    }
#line 684
    if (tmp) {
      {
#line 685
      bind_handler(1, & sighnd_control_b);
      }
    } else
#line 686
    if (! option_emacs_subprocess) {
      {
#line 687
      bind_handler(1, & sighnd_save_then_terminate);
      }
    }
    {
#line 688
    tmp___0 = getenv("USE_SCHEMATIK_STYLE_INTERRUPTS");
    }
#line 688
    if (tmp___0) {
      {
#line 689
      bind_handler(3, & sighnd_control_u);
      }
    } else {
      {
#line 691
      bind_handler(3, & sighnd_interactive);
      }
    }
    {
#line 692
    bind_handler(30, & sighnd_save_then_terminate);
#line 693
    bind_handler(20, & sighnd_stop);
#line 694
    bind_handler(4, & sighnd_hardware_trap);
#line 695
    bind_handler(5, & sighnd_hardware_trap);
#line 696
    bind_handler(7, & sighnd_hardware_trap);
#line 697
    bind_handler(11, & sighnd_hardware_trap);
#line 698
    tmp___1 = getenv("USE_SCHEMATIK_STYLE_INTERRUPTS");
    }
#line 698
    if (tmp___1) {
      {
#line 699
      bind_handler(6, & sighnd_control_x);
      }
    } else {
      {
#line 701
      bind_handler(6, & sighnd_software_trap);
      }
    }
    {
#line 702
    bind_handler(0, & sighnd_software_trap);
#line 703
    bind_handler(31, & sighnd_software_trap);
#line 704
    bind_handler(0, & sighnd_software_trap);
#line 705
    bind_handler(27, & sighnd_software_trap);
#line 706
    bind_handler(28, & sighnd_console_resize);
    }
  }
#line 709
  scan = signal_descriptors;
#line 710
  end = scan + signal_descriptors_length;
  {
#line 711
  while (1) {
    while_continue: /* CIL Label */ ;
#line 711
    if (! ((unsigned long )scan < (unsigned long )end)) {
#line 711
      goto while_break;
    }
#line 713
    if ((scan->flags & 4) == 0) {
      {
#line 716
      if ((unsigned int )scan->action == 0U) {
#line 716
        goto case_0;
      }
#line 719
      if ((unsigned int )scan->action == 2U) {
#line 719
        goto case_2;
      }
#line 722
      if ((unsigned int )scan->action == 1U) {
#line 722
        goto case_1;
      }
#line 714
      goto switch_break;
      case_0: /* CIL Label */ 
      {
#line 717
      bind_handler(scan->signo, & sighnd_terminate);
      }
#line 718
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 720
      bind_handler(scan->signo, & sighnd_stop);
      }
#line 721
      goto switch_break;
      case_1: /* CIL Label */ 
#line 723
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
#line 725
    scan ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 728
  unblock_all_signals();
  }
#line 729
  return;
}
}
#line 733 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
void UX_initialize_child_signals(void) 
{ 


  {
  {
#line 736
  unblock_all_signals();
#line 739
  INSTALL_HANDLER(13, (void (*)(int  , siginfo_t * , void * ))((void (*)(int  ))0));
  }
#line 740
  return;
}
}
#line 747 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
cc_t OS_tty_map_interrupt_char(cc_t int_char ) 
{ 


  {
#line 750
  return (int_char);
}
}
#line 753
static void print_interactive_help(void) ;
#line 754
static void print_interrupt_chars(void) ;
#line 755
static void examine_memory(void) ;
#line 756
static void reset_query(ucontext_t *scp ) ;
#line 757
static void interactive_back_trace(void) ;
#line 768 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
static void interactive_interrupt_handler(ucontext_t *scp ) 
{ 
  char const   *tmp ;
  char tmp___0 ;
  char const   *tmp___1 ;
  int *tmp___2 ;

  {
#line 771
  if (! option_emacs_subprocess) {
    {
#line 773
    tmp = OS_tty_command_beep();
#line 773
    fputs((char const   */* __restrict  */)tmp, (FILE */* __restrict  */)stdout);
#line 774
    _IO_putc('\n', stdout);
#line 775
    fflush(stdout);
    }
  }
  {
#line 777
  while (1) {
    while_continue: /* CIL Label */ ;
#line 779
    if (! option_emacs_subprocess) {
      {
#line 781
      fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Interrupt option (? for help): ");
#line 782
      fflush(stdout);
      }
    }
    {
#line 784
    tmp___0 = userio_read_char_raw();
    }
    {
#line 788
    if ((int )tmp___0 == 98) {
#line 788
      goto case_98;
    }
#line 788
    if ((int )tmp___0 == 66) {
#line 788
      goto case_98;
    }
#line 788
    if ((int )tmp___0 == 2) {
#line 788
      goto case_98;
    }
#line 794
    if ((int )tmp___0 == 103) {
#line 794
      goto case_103;
    }
#line 794
    if ((int )tmp___0 == 71) {
#line 794
      goto case_103;
    }
#line 794
    if ((int )tmp___0 == 7) {
#line 794
      goto case_103;
    }
#line 794
    if ((int )tmp___0 == 3) {
#line 794
      goto case_103;
    }
#line 799
    if ((int )tmp___0 == 117) {
#line 799
      goto case_117;
    }
#line 799
    if ((int )tmp___0 == 85) {
#line 799
      goto case_117;
    }
#line 799
    if ((int )tmp___0 == 21) {
#line 799
      goto case_117;
    }
#line 804
    if ((int )tmp___0 == 120) {
#line 804
      goto case_120;
    }
#line 804
    if ((int )tmp___0 == 88) {
#line 804
      goto case_120;
    }
#line 804
    if ((int )tmp___0 == 24) {
#line 804
      goto case_120;
    }
#line 808
    if ((int )tmp___0 == 101) {
#line 808
      goto case_101;
    }
#line 808
    if ((int )tmp___0 == 69) {
#line 808
      goto case_101;
    }
#line 813
    if ((int )tmp___0 == 100) {
#line 813
      goto case_100;
    }
#line 813
    if ((int )tmp___0 == 68) {
#line 813
      goto case_100;
    }
#line 818
    if ((int )tmp___0 == 116) {
#line 818
      goto case_116;
    }
#line 818
    if ((int )tmp___0 == 84) {
#line 818
      goto case_116;
    }
#line 823
    if ((int )tmp___0 == 122) {
#line 823
      goto case_122;
    }
#line 823
    if ((int )tmp___0 == 90) {
#line 823
      goto case_122;
    }
#line 828
    if ((int )tmp___0 == 113) {
#line 828
      goto case_113;
    }
#line 828
    if ((int )tmp___0 == 81) {
#line 828
      goto case_113;
    }
#line 832
    if ((int )tmp___0 == 12) {
#line 832
      goto case_12;
    }
#line 840
    if ((int )tmp___0 == 114) {
#line 840
      goto case_114;
    }
#line 840
    if ((int )tmp___0 == 82) {
#line 840
      goto case_114;
    }
#line 844
    if ((int )tmp___0 == 104) {
#line 844
      goto case_104;
    }
#line 844
    if ((int )tmp___0 == 72) {
#line 844
      goto case_104;
    }
#line 849
    if ((int )tmp___0 == 105) {
#line 849
      goto case_105;
    }
#line 849
    if ((int )tmp___0 == 73) {
#line 849
      goto case_105;
    }
#line 856
    if ((int )tmp___0 == 0) {
#line 856
      goto case_0;
    }
#line 863
    goto switch_default;
    case_98: /* CIL Label */ 
    case_66: /* CIL Label */ 
    case_2: /* CIL Label */ 
    {
#line 789
    tty_set_next_interrupt_char((cc_t )'B');
    }
#line 790
    return;
    case_103: /* CIL Label */ 
    case_71: /* CIL Label */ 
    case_7: /* CIL Label */ 
    case_3: /* CIL Label */ 
    {
#line 795
    tty_set_next_interrupt_char((cc_t )'G');
    }
#line 796
    return;
    case_117: /* CIL Label */ 
    case_85: /* CIL Label */ 
    case_21: /* CIL Label */ 
    {
#line 800
    tty_set_next_interrupt_char((cc_t )'U');
    }
#line 801
    return;
    case_120: /* CIL Label */ 
    case_88: /* CIL Label */ 
    case_24: /* CIL Label */ 
    {
#line 805
    tty_set_next_interrupt_char((cc_t )'X');
    }
#line 806
    return;
    case_101: /* CIL Label */ 
    case_69: /* CIL Label */ 
#line 809
    if (! option_emacs_subprocess) {
      {
#line 809
      _IO_putc('\n', stdout);
#line 809
      fflush(stdout);
      }
    }
    {
#line 810
    examine_memory();
    }
#line 811
    return;
    case_100: /* CIL Label */ 
    case_68: /* CIL Label */ 
#line 814
    if (! option_emacs_subprocess) {
      {
#line 814
      _IO_putc('\n', stdout);
#line 814
      fflush(stdout);
      }
    }
    {
#line 815
    debug_edit_flags();
    }
#line 816
    return;
    case_116: /* CIL Label */ 
    case_84: /* CIL Label */ 
#line 819
    if (! option_emacs_subprocess) {
      {
#line 819
      _IO_putc('\n', stdout);
#line 819
      fflush(stdout);
      }
    }
    {
#line 820
    interactive_back_trace();
    }
#line 821
    return;
    case_122: /* CIL Label */ 
    case_90: /* CIL Label */ 
#line 824
    if (! option_emacs_subprocess) {
      {
#line 824
      _IO_putc('\n', stdout);
#line 824
      fflush(stdout);
      }
    }
    {
#line 825
    OS_restartable_exit();
    }
#line 826
    return;
    case_113: /* CIL Label */ 
    case_81: /* CIL Label */ 
#line 829
    if (! option_emacs_subprocess) {
      {
#line 829
      _IO_putc('\n', stdout);
#line 829
      fflush(stdout);
      }
    }
    {
#line 830
    termination_normal((int const   )0);
    }
#line 831
    return;
    case_12: /* CIL Label */ 
#line 833
    if (! option_emacs_subprocess) {
      {
#line 835
      tmp___1 = OS_tty_command_clear();
#line 835
      fputs((char const   */* __restrict  */)tmp___1, (FILE */* __restrict  */)stdout);
#line 836
      fflush(stdout);
      }
    }
#line 838
    return;
    case_114: /* CIL Label */ 
    case_82: /* CIL Label */ 
    {
#line 841
    reset_query(scp);
    }
#line 842
    return;
    case_104: /* CIL Label */ 
    case_72: /* CIL Label */ 
#line 845
    if (! option_emacs_subprocess) {
      {
#line 846
      print_interrupt_chars();
      }
    }
#line 847
    goto switch_break;
    case_105: /* CIL Label */ 
    case_73: /* CIL Label */ 
#line 850
    if (! option_emacs_subprocess) {
      {
#line 852
      fputs((char const   */* __restrict  */)"Ignored.  Resuming Scheme.\n", (FILE */* __restrict  */)stdout);
#line 853
      fflush(stdout);
      }
    }
#line 855
    return;
    case_0: /* CIL Label */ 
    {
#line 857
    tmp___2 = __errno_location();
    }
#line 857
    if (*tmp___2 != 0) {
      {
#line 860
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Problems reading keyboard input -- Exitting.\n");
#line 861
      termination_eof();
      }
    }
    switch_default: /* CIL Label */ 
#line 864
    if (! option_emacs_subprocess) {
      {
#line 865
      print_interactive_help();
      }
    }
#line 866
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 871 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
static enum interrupt_handler encode_interrupt_handler(void (*handler)(int  , siginfo_t * ,
                                                                       void * ) ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 874
  if ((unsigned long )handler == (unsigned long )(& sighnd_control_g)) {
#line 874
    tmp___4 = 7;
  } else {
#line 874
    if ((unsigned long )handler == (unsigned long )(& sighnd_interactive)) {
#line 874
      tmp___3 = 5;
    } else {
#line 874
      if ((unsigned long )handler == (unsigned long )(& sighnd_stop)) {
#line 874
        tmp___2 = 4;
      } else {
#line 874
        if ((unsigned long )handler == (unsigned long )(& sighnd_terminate)) {
#line 874
          tmp___1 = 3;
        } else {
#line 874
          if ((unsigned long )handler == (unsigned long )((void (*)(int  , siginfo_t * ,
                                                                    void * ))((void (*)(int  ))1))) {
#line 874
            tmp___0 = 0;
          } else {
#line 874
            if ((unsigned long )handler == (unsigned long )((void (*)(int  , siginfo_t * ,
                                                                      void * ))((void (*)(int  ))0))) {
#line 874
              tmp = 1;
            } else {
#line 874
              tmp = 2;
            }
#line 874
            tmp___0 = tmp;
          }
#line 874
          tmp___1 = tmp___0;
        }
#line 874
        tmp___2 = tmp___1;
      }
#line 874
      tmp___3 = tmp___2;
    }
#line 874
    tmp___4 = tmp___3;
  }
#line 874
  return ((enum interrupt_handler )tmp___4);
}
}
#line 890 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
static Tsignal_handler decode_interrupt_handler(enum interrupt_handler encoding ) 
{ 
  void (*tmp)(int  , siginfo_t * , void * ) ;
  void (*tmp___0)(int  , siginfo_t * , void * ) ;
  void (*tmp___1)(int  , siginfo_t * , void * ) ;
  void (*tmp___2)(int  , siginfo_t * , void * ) ;
  void (*tmp___3)(int  , siginfo_t * , void * ) ;
  void (*tmp___4)(int  , siginfo_t * , void * ) ;

  {
#line 893
  if ((unsigned int )encoding == 7U) {
#line 893
    tmp___4 = & sighnd_control_g;
  } else {
#line 893
    if ((unsigned int )encoding == 5U) {
#line 893
      tmp___3 = & sighnd_interactive;
    } else {
#line 893
      if ((unsigned int )encoding == 4U) {
#line 893
        tmp___2 = & sighnd_stop;
      } else {
#line 893
        if ((unsigned int )encoding == 3U) {
#line 893
          tmp___1 = & sighnd_terminate;
        } else {
#line 893
          if ((unsigned int )encoding == 0U) {
#line 893
            tmp___0 = (void (*)(int  , siginfo_t * , void * ))((void (*)(int  ))1);
          } else {
#line 893
            if ((unsigned int )encoding == 1U) {
#line 893
              tmp = (void (*)(int  , siginfo_t * , void * ))((void (*)(int  ))0);
            } else {
#line 893
              tmp = (void (*)(int  , siginfo_t * , void * ))0;
            }
#line 893
            tmp___0 = tmp;
          }
#line 893
          tmp___1 = tmp___0;
        }
#line 893
        tmp___2 = tmp___1;
      }
#line 893
      tmp___3 = tmp___2;
    }
#line 893
    tmp___4 = tmp___3;
  }
#line 893
  return (tmp___4);
}
}
#line 909 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
enum interrupt_handler OS_signal_quit_handler(void) 
{ 
  Tsignal_handler tmp ;
  enum interrupt_handler tmp___0 ;

  {
  {
#line 912
  tmp = current_handler(3);
#line 912
  tmp___0 = encode_interrupt_handler(tmp);
  }
#line 912
  return (tmp___0);
}
}
#line 915 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
enum interrupt_handler OS_signal_int_handler(void) 
{ 
  Tsignal_handler tmp ;
  enum interrupt_handler tmp___0 ;

  {
  {
#line 918
  tmp = current_handler(2);
#line 918
  tmp___0 = encode_interrupt_handler(tmp);
  }
#line 918
  return (tmp___0);
}
}
#line 921 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
enum interrupt_handler OS_signal_tstp_handler(void) 
{ 
  Tsignal_handler tmp ;
  enum interrupt_handler tmp___0 ;

  {
  {
#line 924
  tmp = current_handler(20);
#line 924
  tmp___0 = encode_interrupt_handler(tmp);
  }
#line 924
  return ((enum interrupt_handler )((unsigned int )tmp___0));
}
}
#line 930 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
void OS_signal_set_interrupt_handlers(enum interrupt_handler quit_handler , enum interrupt_handler int_handler ,
                                      enum interrupt_handler tstp_handler ) 
{ 
  void (*handler)(int  , siginfo_t * , void * ) ;
  Tsignal_handler tmp ;
  void (*handler___0)(int  , siginfo_t * , void * ) ;
  Tsignal_handler tmp___0 ;
  void (*handler___1)(int  , siginfo_t * , void * ) ;
  Tsignal_handler tmp___1 ;

  {
  {
#line 936
  tmp = decode_interrupt_handler(quit_handler);
#line 936
  handler = tmp;
  }
#line 937
  if ((unsigned long )handler != (unsigned long )((void (*)(int  , siginfo_t * , void * ))0)) {
    {
#line 938
    INSTALL_HANDLER(3, handler);
    }
  }
  {
#line 941
  tmp___0 = decode_interrupt_handler(int_handler);
#line 941
  handler___0 = tmp___0;
  }
#line 942
  if ((unsigned long )handler___0 != (unsigned long )((void (*)(int  , siginfo_t * ,
                                                                void * ))0)) {
    {
#line 943
    INSTALL_HANDLER(2, handler___0);
    }
  }
  {
#line 947
  tmp___1 = decode_interrupt_handler(tstp_handler);
#line 947
  handler___1 = tmp___1;
  }
#line 948
  if ((unsigned long )handler___1 != (unsigned long )((void (*)(int  , siginfo_t * ,
                                                                void * ))0)) {
    {
#line 949
    INSTALL_HANDLER(20, handler___1);
    }
  }
#line 951
  return;
}
}
#line 953 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
static void describe_sighnd(int signo , unsigned char c ) 
{ 
  Tsignal_handler tmp ;
  enum interrupt_handler tmp___0 ;
  char const   *tmp___1 ;
  struct signal_descriptor *descriptor ;
  struct signal_descriptor *tmp___2 ;

  {
  {
#line 956
  tmp = current_handler(signo);
#line 956
  tmp___0 = encode_interrupt_handler(tmp);
  }
  {
#line 958
  if ((unsigned int )tmp___0 == 7U) {
#line 958
    goto case_7;
  }
#line 964
  if ((unsigned int )tmp___0 == 5U) {
#line 964
    goto case_5;
  }
#line 969
  if ((unsigned int )tmp___0 == 3U) {
#line 969
    goto describe_terminate;
  }
#line 973
  if ((unsigned int )tmp___0 == 4U) {
#line 973
    goto describe_stop;
  }
#line 977
  if ((unsigned int )tmp___0 == 0U) {
#line 977
    goto describe_ignore;
  }
#line 981
  if ((unsigned int )tmp___0 == 1U) {
#line 981
    goto case_1;
  }
#line 993
  goto switch_default;
  case_7: /* CIL Label */ 
  {
#line 959
  fputs((char const   */* __restrict  */)"When typed, scheme will get the ^G character interrupt.\n",
        (FILE */* __restrict  */)stdout);
#line 961
  fputs((char const   */* __restrict  */)"The default action is to abort the running program,\n",
        (FILE */* __restrict  */)stdout);
#line 962
  fputs((char const   */* __restrict  */)"and to resume the top level read-eval-print loop.\n",
        (FILE */* __restrict  */)stdout);
  }
#line 963
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 965
  fputs((char const   */* __restrict  */)"When typed, various interrupt options are offered.\n",
        (FILE */* __restrict  */)stdout);
#line 966
  tmp___1 = char_description(c, 0);
#line 966
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Type %s followed by `?\' for a list of options.\n",
          tmp___1);
  }
#line 968
  goto switch_break;
  describe_terminate: 
  case_3: /* CIL Label */ 
  {
#line 971
  fputs((char const   */* __restrict  */)"When typed, scheme will terminate.\n", (FILE */* __restrict  */)stdout);
  }
#line 972
  goto switch_break;
  describe_stop: 
  case_4: /* CIL Label */ 
  {
#line 975
  fputs((char const   */* __restrict  */)"When typed, scheme will suspend execution.\n",
        (FILE */* __restrict  */)stdout);
  }
#line 976
  goto switch_break;
  describe_ignore: 
  case_0: /* CIL Label */ 
  {
#line 979
  fputs((char const   */* __restrict  */)"When typed, this character will be ignored.\n",
        (FILE */* __restrict  */)stdout);
  }
#line 980
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 983
  tmp___2 = find_signal_descriptor(signo);
#line 983
  descriptor = tmp___2;
  }
#line 985
  if ((unsigned long )descriptor != (unsigned long )((struct signal_descriptor *)0)) {
    {
#line 988
    if ((unsigned int )descriptor->action == 1U) {
#line 988
      goto case_1___0;
    }
#line 989
    if ((unsigned int )descriptor->action == 2U) {
#line 989
      goto case_2;
    }
#line 990
    if ((unsigned int )descriptor->action == 0U) {
#line 990
      goto case_0___0;
    }
#line 986
    goto switch_break___0;
    case_1___0: /* CIL Label */ 
#line 988
    goto describe_ignore;
    case_2: /* CIL Label */ 
#line 989
    goto describe_stop;
    case_0___0: /* CIL Label */ 
#line 990
    goto describe_terminate;
    switch_break___0: /* CIL Label */ ;
    }
  }
  switch_default: /* CIL Label */ 
  {
#line 994
  fputs((char const   */* __restrict  */)"When typed, this character will have an unknown effect.\n",
        (FILE */* __restrict  */)stdout);
  }
#line 996
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 998
  return;
}
}
#line 1000 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
static void print_interrupt_chars(void) 
{ 
  unsigned char quit_char ;
  cc_t tmp ;
  char const   *tmp___0 ;
  unsigned char int_char ;
  cc_t tmp___1 ;
  char const   *tmp___2 ;
  unsigned char tstp_char ;
  cc_t tmp___3 ;
  char const   *tmp___4 ;

  {
  {
#line 1004
  tmp = OS_ctty_quit_char();
#line 1004
  quit_char = tmp;
#line 1005
  tmp___0 = char_description(quit_char, 1);
#line 1005
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\n\nThe quit character is %s.\n",
          tmp___0);
#line 1007
  describe_sighnd(3, quit_char);
#line 1010
  tmp___1 = OS_ctty_int_char();
#line 1010
  int_char = tmp___1;
#line 1011
  tmp___2 = char_description(int_char, 1);
#line 1011
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\nThe interrupt character is %s.\n",
          tmp___2);
#line 1013
  describe_sighnd(2, int_char);
#line 1017
  tmp___3 = OS_ctty_tstp_char();
#line 1017
  tstp_char = tmp___3;
#line 1018
  tmp___4 = char_description(tstp_char, 1);
#line 1018
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\nThe terminal stop character is %s.\n",
          tmp___4);
#line 1020
  describe_sighnd(20, tstp_char);
#line 1022
  _IO_putc('\n', stdout);
#line 1023
  fflush(stdout);
  }
#line 1024
  return;
}
}
#line 1026 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
static void print_interactive_help(void) 
{ 


  {
  {
#line 1029
  fputs((char const   */* __restrict  */)"\n\n", (FILE */* __restrict  */)stdout);
#line 1030
  fputs((char const   */* __restrict  */)"^B: Enter a breakpoint loop.\n", (FILE */* __restrict  */)stdout);
#line 1031
  fputs((char const   */* __restrict  */)"^C: Goto to top level read-eval-print (REP) loop.\n",
        (FILE */* __restrict  */)stdout);
#line 1032
  fputs((char const   */* __restrict  */)"^L: Clear the screen.\n", (FILE */* __restrict  */)stdout);
#line 1033
  fputs((char const   */* __restrict  */)"^U: Up to previous (lower numbered) REP loop.\n",
        (FILE */* __restrict  */)stdout);
#line 1034
  fputs((char const   */* __restrict  */)"^X: Abort to current REP loop.\n", (FILE */* __restrict  */)stdout);
#line 1035
  fputs((char const   */* __restrict  */)"D: Debugging: change interpreter flags.\n",
        (FILE */* __restrict  */)stdout);
#line 1036
  fputs((char const   */* __restrict  */)"E: Examine memory location.\n", (FILE */* __restrict  */)stdout);
#line 1037
  fputs((char const   */* __restrict  */)"H: Print simple information on interrupts.\n",
        (FILE */* __restrict  */)stdout);
#line 1038
  fputs((char const   */* __restrict  */)"I: Ignore interrupt request.\n", (FILE */* __restrict  */)stdout);
#line 1039
  fputs((char const   */* __restrict  */)"Q: Quit instantly, killing Scheme.\n", (FILE */* __restrict  */)stdout);
#line 1040
  fputs((char const   */* __restrict  */)"R: Hard reset, possibly killing Scheme in the process.\n",
        (FILE */* __restrict  */)stdout);
#line 1041
  fputs((char const   */* __restrict  */)"T: Stack trace.\n", (FILE */* __restrict  */)stdout);
#line 1043
  fputs((char const   */* __restrict  */)"Z: Quit instantly, suspending Scheme.\n",
        (FILE */* __restrict  */)stdout);
#line 1044
  fputs((char const   */* __restrict  */)"\n", (FILE */* __restrict  */)stdout);
  }
#line 1045
  return;
}
}
#line 1047 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
static void invoke_soft_reset(char const   *name ) 
{ 


  {
  {
#line 1050
  soft_reset();
  }
#line 1052
  return;
}
}
#line 1061 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
static char const   *reset_choices[4]  = {      "D = delay reset until the end of the critical section",      "N = attempt reset now",      "P = punt reset",      (char const   *)0};
#line 1054 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
static void reset_query(ucontext_t *scp ) 
{ 
  char tmp ;
  char const   *name ;
  int tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 1057
  _IO_putc('\n', stdout);
#line 1058
  fflush(stdout);
  }
#line 1059
  if ((unsigned long )critical_section_name != (unsigned long )((char const   *)0)) {
    {
#line 1068
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Scheme is executing within critical section \"%s\".\n",
            critical_section_name);
#line 1071
    fputs((char const   */* __restrict  */)"Resetting now is likely to kill Scheme.\n",
          (FILE */* __restrict  */)stdout);
#line 1072
    fflush(stdout);
#line 1073
    tmp = userio_choose_option("Choose one of the following actions:", "Action -> ",
                               reset_choices);
    }
    {
#line 1078
    if ((int )tmp == 0) {
#line 1078
      goto case_0;
    }
#line 1082
    if ((int )tmp == 68) {
#line 1082
      goto case_68;
    }
#line 1085
    if ((int )tmp == 78) {
#line 1085
      goto case_78;
    }
#line 1090
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 1080
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Problems reading keyboard input -- exitting.\n");
#line 1081
    termination_eof();
    }
    case_68: /* CIL Label */ 
    {
#line 1083
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1083
      critical_section_hook = & invoke_soft_reset;
#line 1083
      critical_section_hook_p = (_Bool)1;
#line 1083
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 1084
    return;
    case_78: /* CIL Label */ 
#line 1086
    critical_section_hook_p = (_Bool)0;
    {
#line 1087
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1087
      if (critical_section_hook_p) {
        {
#line 1087
        name = critical_section_name;
#line 1087
        critical_section_hook_p = (_Bool)0;
#line 1087
        critical_section_name = (char const   *)0;
#line 1087
        (*critical_section_hook)(name);
        }
      } else {
#line 1087
        critical_section_name = (char const   *)0;
      }
#line 1087
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1088
    hard_reset(scp);
    }
    switch_default: /* CIL Label */ 
#line 1091
    return;
    switch_break: /* CIL Label */ ;
    }
  }
  {
#line 1094
  tmp___0 = userio_confirm("Do you really want to reset? [Y or N] ");
  }
#line 1094
  if (tmp___0) {
    {
#line 1095
    hard_reset(scp);
    }
  }
#line 1096
  return;
}
}
#line 1102 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
static int userio_read_line(char *line , int size ) 
{ 
  int result ;
  char *scan ;
  char *end ;
  char c ;
  char tmp ;
  int *tmp___0 ;

  {
  {
#line 1105
  result = 1;
#line 1106
  transaction_begin();
#line 1107
  userio_buffered_input();
#line 1109
  scan = line;
#line 1110
  end = line + size;
  }
  {
#line 1111
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1111
    if (! ((unsigned long )scan < (unsigned long )end)) {
#line 1111
      goto while_break;
    }
    {
#line 1113
    tmp = userio_read_char();
#line 1113
    c = tmp;
    }
#line 1114
    if ((int )c == 0) {
      {
#line 1114
      tmp___0 = __errno_location();
      }
#line 1114
      if (*tmp___0 != 0) {
#line 1117
        result = 2;
#line 1118
        goto while_break;
      }
    }
#line 1120
    if ((int )c == 10) {
#line 1121
      c = (char )'\000';
    }
#line 1122
    *scan = c;
#line 1123
    if ((int )c == 0) {
#line 1125
      result = 0;
#line 1126
      goto while_break;
    }
#line 1128
    scan ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1131
  transaction_commit();
  }
#line 1132
  return (result);
}
}
#line 1135 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
static void examine_memory(void) 
{ 
  char input_string[256] ;
  int tmp ;
  long input ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 1139
  fputs((char const   */* __restrict  */)"Enter location to examine (0x prefix for hex): ",
        (FILE */* __restrict  */)stdout);
#line 1140
  fflush(stdout);
#line 1141
  tmp = userio_read_line(& input_string[0], (int )sizeof(input_string));
  }
#line 1141
  if (tmp == 2) {
    {
#line 1144
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Problems reading keyboard input -- exiting.\n");
#line 1145
    termination_eof();
    }
  }
#line 1149
  if ((int )input_string[0] == 48) {
#line 1149
    if ((int )input_string[1] == 120) {
      {
#line 1149
      tmp___0 = sscanf((char const   */* __restrict  */)(& input_string[2]), (char const   */* __restrict  */)"%lx",
                       & input);
#line 1149
      tmp___2 = tmp___0;
      }
    } else {
      {
#line 1149
      tmp___1 = sscanf((char const   */* __restrict  */)(input_string), (char const   */* __restrict  */)"%ld",
                       & input);
#line 1149
      tmp___2 = tmp___1;
      }
    }
  } else {
    {
#line 1149
    tmp___1 = sscanf((char const   */* __restrict  */)(input_string), (char const   */* __restrict  */)"%ld",
                     & input);
#line 1149
    tmp___2 = tmp___1;
    }
  }
#line 1149
  if (tmp___2 == 1) {
    {
#line 1153
    debug_examine_memory(input, "contents");
    }
  }
  {
#line 1155
  _IO_putc('\n', stdout);
#line 1156
  fflush(stdout);
  }
#line 1157
  return;
}
}
#line 1159 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
void eta_fclose(void *stream ) 
{ 


  {
  {
#line 1162
  fclose((FILE *)stream);
  }
#line 1163
  return;
}
}
#line 1166 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxsig.c"
static void interactive_back_trace(void) 
{ 
  char input_string[256] ;
  int tmp ;
  FILE *to_dump ;
  FILE *tmp___0 ;
  size_t tmp___1 ;
  void *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 1170
  fputs((char const   */* __restrict  */)"Enter the stack trace filename (default: terminal): ",
        (FILE */* __restrict  */)stdout);
#line 1171
  fflush(stdout);
#line 1172
  tmp = userio_read_line(& input_string[0], (int )sizeof(input_string));
  }
#line 1172
  if (tmp == 2) {
    {
#line 1175
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Problems reading keyboard input -- exiting.\n");
#line 1176
    termination_eof();
    }
  }
#line 1178
  if (! option_emacs_subprocess) {
    {
#line 1178
    _IO_putc('\n', stdout);
#line 1178
    fflush(stdout);
    }
  }
  {
#line 1179
  tmp___1 = strlen((char const   *)(& input_string[0]));
  }
#line 1179
  if (tmp___1 == 0UL) {
    {
#line 1180
    debug_back_trace((outf_channel )0);
    }
  } else {
    {
#line 1183
    transaction_begin();
#line 1185
    tmp___0 = fopen((char const   */* __restrict  */)(& input_string[0]), (char const   */* __restrict  */)"w");
#line 1185
    to_dump = tmp___0;
    }
#line 1186
    if ((unsigned long )to_dump == (unsigned long )((FILE *)((void *)0))) {
      {
#line 1188
      outf_error("Error opening \"%s\".\n", & input_string[0]);
#line 1189
      transaction_abort();
      }
#line 1190
      return;
    }
    {
#line 1192
    transaction_record_action((enum transaction_action_type )2, & eta_fclose, (void *)to_dump);
#line 1195
    outf_console("Writing the stack trace to file \"%s\" -- ", & input_string[0]);
#line 1197
    outf_flush_console();
#line 1198
    debug_back_trace((outf_channel )to_dump);
#line 1199
    outf_console("Done.\n");
#line 1200
    outf_flush_console();
#line 1202
    transaction_commit();
    }
  }
#line 1204
  return;
}
}
#line 66 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcgetattr)(int __fd ,
                                                                                struct termios *__termios_p ) ;
#line 70
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcsetattr)(int __fd ,
                                                                                int __optional_actions ,
                                                                                struct termios  const  *__termios_p ) ;
#line 256 "/usr/include/signal.h"
extern int ( __attribute__((__nonnull__(1))) sigsuspend)(sigset_t const   *__set ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 497
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 531
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup)(int __fd ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 545
extern char **environ ;
#line 551
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execve)(char const   *__path ,
                                                                                               char * const  *__argv ,
                                                                                               char * const  *__envp ) ;
#line 634
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpgrp)(void) ;
#line 646
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setpgid)(__pid_t __pid ,
                                                                              __pid_t __pgid ) ;
#line 667
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) setsid)(void) ;
#line 764
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) vfork)(void) ;
#line 839
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) tcgetpgrp)(int __fd ) ;
#line 842
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcsetpgrp)(int __fd ,
                                                                                __pid_t __pgrp_id ) ;
#line 156 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 43 "/home/khheo/project/mit-scheme-9.2/src/microcode/osscheme.h"
 __attribute__((__noreturn__)) void error_out_of_processes(void) ;
#line 45
 __attribute__((__noreturn__)) void error_process_terminated(void) ;
#line 57
int pending_interrupts_p(void) ;
#line 171 "/home/khheo/project/mit-scheme-9.2/src/microcode/syscall.h"
 __attribute__((__noreturn__)) void error_in_system_call(enum syserr_names err , enum syscall_names name ) ;
#line 642 "/home/khheo/project/mit-scheme-9.2/src/microcode/ux.h"
int UX_closefrom(int fd ) ;
#line 76 "/home/khheo/project/mit-scheme-9.2/src/microcode/osproc.h"
Tprocess OS_process_table_size  ;
#line 78 "/home/khheo/project/mit-scheme-9.2/src/microcode/osproc.h"
enum process_jc_status scheme_jc_status  ;
#line 81
Tprocess OS_make_subprocess(char const   *filename , char const   **argv , char const   ** volatile  envp ,
                            char const   *working_directory , enum process_ctty_type ctty_type ,
                            char *ctty_name , enum process_channel_type channel_in_type ,
                            Tchannel channel_in , enum process_channel_type channel_out_type ,
                            Tchannel channel_out , enum process_channel_type channel_err_type ,
                            Tchannel channel_err ) ;
#line 94
void OS_process_deallocate(Tprocess process ) ;
#line 96
int OS_process_valid_p(Tprocess process ) ;
#line 97
int OS_process_continuable_p(Tprocess process ) ;
#line 98
int OS_process_foregroundable_p(Tprocess process ) ;
#line 100
pid_t OS_process_id(Tprocess process ) ;
#line 101
enum process_jc_status OS_process_jc_status(Tprocess process ) ;
#line 102
int OS_process_status_sync(Tprocess process ) ;
#line 103
int OS_process_status_sync_all(void) ;
#line 104
int OS_process_any_status_change(void) ;
#line 105
enum process_status OS_process_status(Tprocess process ) ;
#line 106
unsigned short OS_process_reason(Tprocess process ) ;
#line 108
void OS_process_send_signal(Tprocess process , int sig ) ;
#line 109
void OS_process_kill(Tprocess process ) ;
#line 110
void OS_process_stop(Tprocess process ) ;
#line 111
void OS_process_interrupt(Tprocess process ) ;
#line 112
void OS_process_quit(Tprocess process ) ;
#line 113
void OS_process_hangup(Tprocess process ) ;
#line 115
void OS_process_continue_background(Tprocess process ) ;
#line 116
void OS_process_continue_foreground(Tprocess process ) ;
#line 117
void OS_process_wait(Tprocess process ) ;
#line 53 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxproc.h"
struct process *process_table  ;
#line 41 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxproc.c"
int OS_ctty_fd(void) ;
#line 44
static void subprocess_death(pid_t pid , int *status ) ;
#line 45
static void stop_signal_handler(int signo ) ;
#line 46
static void give_terminal_to(Tprocess process ) ;
#line 47
static void get_terminal_back(void) ;
#line 48
static void process_wait(Tprocess process ) ;
#line 49
static int child_setup_tty(int fd ) ;
#line 55 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxproc.c"
static int scheme_ctty_fd  ;
#line 56 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxproc.c"
static Tprocess foreground_child_process  ;
#line 58 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxproc.c"
static long process_tick  ;
#line 59 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxproc.c"
static long sync_tick  ;
#line 82 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxproc.c"
static void restore_signal_mask___0(void *environment ) 
{ 


  {
  {
#line 85
  sigprocmask(2, (sigset_t const   */* __restrict  */)((sigset_t *)environment), (sigset_t */* __restrict  */)0);
  }
#line 86
  return;
}
}
#line 88 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxproc.c"
static void block_sigchld(void) 
{ 
  sigset_t *outside ;
  void *tmp ;
  sigset_t sigchld ;
  void *__cil_tmp4 ;

  {
  {
#line 91
  tmp = dstack_alloc((unsigned int )sizeof(sigset_t ));
#line 91
  outside = (sigset_t *)tmp;
#line 93
  sigemptyset(& sigchld);
#line 94
  sigaddset(& sigchld, 17);
#line 95
  sigprocmask(0, (sigset_t const   */* __restrict  */)(& sigchld), (sigset_t */* __restrict  */)outside);
#line 96
  transaction_record_action((enum transaction_action_type )2, & restore_signal_mask___0,
                            (void *)outside);
  }
#line 97
  return;
}
}
#line 99 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxproc.c"
static void block_jc_signals(void) 
{ 
  sigset_t *outside ;
  void *tmp ;
  sigset_t jc_signals ;
  void *__cil_tmp4 ;

  {
  {
#line 102
  tmp = dstack_alloc((unsigned int )sizeof(sigset_t ));
#line 102
  outside = (sigset_t *)tmp;
#line 104
  sigemptyset(& jc_signals);
#line 105
  sigaddset(& jc_signals, 17);
#line 106
  sigaddset(& jc_signals, 22);
#line 107
  sigaddset(& jc_signals, 21);
#line 108
  sigaddset(& jc_signals, 20);
#line 109
  sigaddset(& jc_signals, 19);
#line 110
  sigprocmask(0, (sigset_t const   */* __restrict  */)(& jc_signals), (sigset_t */* __restrict  */)outside);
#line 111
  transaction_record_action((enum transaction_action_type )2, & restore_signal_mask___0,
                            (void *)outside);
  }
#line 112
  return;
}
}
#line 114 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxproc.c"
static sigset_t grabbed_signal_mask  ;
#line 116 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxproc.c"
static void grab_signal_mask(void) 
{ 


  {
  {
#line 119
  sigprocmask(0, (sigset_t const   */* __restrict  */)0, (sigset_t */* __restrict  */)(& grabbed_signal_mask));
  }
#line 120
  return;
}
}
#line 150 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxproc.c"
void UX_initialize_processes(void) 
{ 
  void *tmp ;
  Tprocess process ;
  int __cil_tmp3 ;

  {
  {
#line 153
  OS_process_table_size = (Tprocess )64;
#line 154
  tmp = malloc((unsigned long )OS_process_table_size * sizeof(struct process ));
#line 154
  process_table = (struct process *)tmp;
  }
#line 156
  if ((unsigned long )process_table == (unsigned long )((struct process *)0)) {
    {
#line 158
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nUnable to allocate process table.\n");
#line 159
    fflush(stderr);
#line 160
    termination_init_error();
    }
  }
#line 164
  process = (Tprocess )0;
  {
#line 164
  while (1) {
    while_continue: /* CIL Label */ ;
#line 164
    if (! (process < OS_process_table_size)) {
#line 164
      goto while_break;
    }
    {
#line 165
    OS_process_deallocate(process);
#line 164
    process ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 167
  scheme_ctty_fd = OS_ctty_fd();
  }
#line 168
  if (scheme_ctty_fd < 0) {
#line 168
    scheme_jc_status = (enum process_jc_status )0;
  } else {
#line 168
    scheme_jc_status = (enum process_jc_status )3;
  }
#line 172
  foreground_child_process = (Tprocess )-1;
#line 173
  subprocess_death_hook = & subprocess_death;
#line 174
  stop_signal_hook = & stop_signal_handler;
#line 175
  process_tick = 0L;
#line 176
  sync_tick = 0L;
#line 177
  return;
}
}
#line 179 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxproc.c"
void UX_reset_processes(void) 
{ 


  {
  {
#line 182
  free((void *)process_table);
#line 183
  process_table = (struct process *)0;
#line 184
  OS_process_table_size = (Tprocess )0;
  }
#line 185
  return;
}
}
#line 187 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxproc.c"
static void process_allocate_abort(void *environment ) 
{ 
  Tprocess process ;

  {
#line 190
  process = *((Tprocess *)environment);
  {
#line 194
  if ((unsigned int )(process_table + process)->raw_status == 2U) {
#line 194
    goto case_2;
  }
#line 194
  if ((unsigned int )(process_table + process)->raw_status == 3U) {
#line 194
    goto case_2;
  }
#line 197
  goto switch_default;
  case_2: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 195
  kill((process_table + process)->id, 9);
  }
#line 196
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 198
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 200
  OS_process_deallocate(process);
  }
#line 201
  return;
}
}
#line 203 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxproc.c"
static Tprocess process_allocate(void) 
{ 
  Tprocess process ;
  size_t old_size ;
  size_t new_size ;
  struct process *new_table ;
  void *tmp ;
  Tprocess *pp ;
  void *tmp___0 ;

  {
#line 207
  process = (Tprocess )0;
  {
#line 207
  while (1) {
    while_continue: /* CIL Label */ ;
#line 207
    if (! (process < OS_process_table_size)) {
#line 207
      goto while_break;
    }
#line 208
    if ((unsigned int )(process_table + process)->raw_status == 0U) {
#line 210
      (process_table + process)->raw_status = (enum process_status )1;
#line 211
      goto while_break;
    }
#line 207
    process ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 213
  if (process == OS_process_table_size) {
    {
#line 215
    old_size = (size_t )OS_process_table_size;
#line 216
    new_size = (old_size * 5UL) / 4UL;
#line 217
    tmp = realloc((void *)process_table, new_size * sizeof(struct process ));
#line 217
    new_table = (struct process *)tmp;
    }
#line 219
    if ((unsigned long )new_table == (unsigned long )((struct process *)0)) {
      {
#line 221
      error_out_of_processes();
      }
#line 222
      return ((Tprocess )-1);
    }
#line 224
    OS_process_table_size = (Tprocess )new_size;
#line 225
    process_table = new_table;
#line 226
    process = (Tprocess )old_size;
    {
#line 226
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 226
      if (! ((size_t )process < new_size)) {
#line 226
        goto while_break___0;
      }
      {
#line 227
      OS_process_deallocate(process);
#line 226
      process ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 228
    process = (Tprocess )old_size;
  }
  {
#line 231
  tmp___0 = dstack_alloc((unsigned int )sizeof(Tprocess ));
#line 231
  pp = (Tprocess *)tmp___0;
#line 232
  *pp = process;
#line 233
  transaction_record_action((enum transaction_action_type )0, & process_allocate_abort,
                            (void *)pp);
  }
#line 235
  return (process);
}
}
#line 238 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxproc.c"
void OS_process_deallocate(Tprocess process ) 
{ 


  {
#line 241
  (process_table + process)->id = 0;
#line 242
  (process_table + process)->raw_status = (enum process_status )0;
#line 243
  return;
}
}
#line 245 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxproc.c"
Tprocess OS_make_subprocess(char const   *filename , char const   **argv , char const   ** volatile  envp ,
                            char const   *working_directory , enum process_ctty_type ctty_type ,
                            char *ctty_name , enum process_channel_type channel_in_type ,
                            Tchannel channel_in , enum process_channel_type channel_out_type ,
                            Tchannel channel_out , enum process_channel_type channel_err_type ,
                            Tchannel channel_err ) 
{ 
  pid_t child_pid ;
  Tprocess volatile   child ;
  enum process_jc_status  volatile  child_jc_status ;
  Tprocess tmp ;
  int tmp___0 ;
  int in_fd ;
  int out_fd ;
  int err_fd ;
  int tmp___1 ;
  __pid_t tmp___2 ;
  __pid_t tmp___3 ;
  int tmp___4 ;
  __pid_t tmp___5 ;
  int fd ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;

  {
#line 261
  child_jc_status = (enum process_jc_status  volatile  )0;
#line 263
  if ((unsigned long )envp == (unsigned long )((char const   **/* volatile  */)0)) {
#line 264
    envp = (char const   **/* volatile  */)((char const   **)environ);
  }
  {
#line 267
  if ((unsigned int )ctty_type == 0U) {
#line 267
    goto case_0;
  }
#line 270
  if ((unsigned int )ctty_type == 3U) {
#line 270
    goto case_3;
  }
#line 274
  if ((unsigned int )ctty_type == 2U) {
#line 274
    goto case_2;
  }
#line 274
  if ((unsigned int )ctty_type == 1U) {
#line 274
    goto case_2;
  }
#line 265
  goto switch_break;
  case_0: /* CIL Label */ 
#line 268
  child_jc_status = (enum process_jc_status  volatile  )0;
#line 269
  goto switch_break;
  case_3: /* CIL Label */ 
#line 271
  child_jc_status = (enum process_jc_status  volatile  )1;
#line 272
  goto switch_break;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 275
  child_jc_status = (enum process_jc_status  volatile  )scheme_jc_status;
#line 276
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 279
  transaction_begin();
#line 280
  tmp = process_allocate();
#line 280
  child = (Tprocess volatile   )tmp;
#line 281
  grab_signal_mask();
  }
#line 282
  if ((unsigned int )ctty_type == 2U) {
    {
#line 283
    block_jc_signals();
    }
  } else {
    {
#line 285
    block_sigchld();
    }
  }
  {
#line 286
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 286
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 286
      child_pid = vfork();
      }
#line 286
      if (! (child_pid < 0)) {
#line 286
        goto while_break___0;
      }
      {
#line 286
      UX_prim_check_errno((enum syscall_names )67);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 286
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 288
  if (child_pid > 0) {
#line 291
    (process_table + child)->id = child_pid;
#line 292
    (process_table + child)->jc_status = (enum process_jc_status )child_jc_status;
#line 293
    (process_table + child)->raw_status = (enum process_status )2;
#line 294
    (process_table + child)->raw_reason = (unsigned short)0;
#line 295
    (process_table + child)->tick = process_tick;
    {
#line 296
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 296
      (process_table + child)->status = (process_table + child)->raw_status;
#line 296
      (process_table + child)->reason = (process_table + child)->raw_reason;
#line 296
      (process_table + child)->sync_tick = (process_table + child)->tick;
#line 296
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 302
    if ((unsigned int volatile   )child_jc_status == (unsigned int volatile   )3) {
      {
#line 316
      setpgid(child_pid, child_pid);
      }
    }
#line 318
    if ((unsigned int )ctty_type == 2U) {
      {
#line 320
      give_terminal_to((Tprocess )child);
#line 321
      process_wait((Tprocess )child);
      }
    }
    {
#line 324
    transaction_commit();
    }
#line 325
    return ((Tprocess )child);
  }
  {
#line 329
  child_pid = getpid();
  }
#line 333
  if ((unsigned long )working_directory != (unsigned long )((char const   *)0)) {
    {
#line 333
    tmp___0 = chdir(working_directory);
    }
#line 333
    if (tmp___0 < 0) {
#line 334
      goto kill_child;
    }
  }
#line 336
  in_fd = -1;
#line 337
  out_fd = -1;
#line 338
  err_fd = -1;
#line 340
  if ((unsigned int )channel_in_type == 3U) {
#line 341
    in_fd = (channel_table + channel_in)->descriptor;
  }
#line 342
  if ((unsigned int )channel_out_type == 3U) {
#line 343
    out_fd = (channel_table + channel_out)->descriptor;
  }
#line 344
  if ((unsigned int )channel_err_type == 3U) {
#line 345
    err_fd = (channel_table + channel_err)->descriptor;
  }
#line 347
  if ((unsigned int )ctty_type == 1U) {
#line 347
    goto _L___0;
  } else
#line 347
  if ((unsigned int )ctty_type == 2U) {
    _L___0: /* CIL Label */ 
#line 352
    if ((unsigned int volatile   )child_jc_status == (unsigned int volatile   )3) {
      {
#line 354
      tmp___1 = setpgid(child_pid, child_pid);
      }
#line 354
      if (tmp___1 < 0) {
#line 358
        goto kill_child;
      } else
#line 354
      if ((unsigned int )ctty_type == 2U) {
        {
#line 354
        tmp___2 = tcgetpgrp(scheme_ctty_fd);
#line 354
        tmp___3 = getpgrp();
        }
#line 354
        if (tmp___2 == tmp___3) {
          {
#line 354
          tmp___4 = tcsetpgrp(scheme_ctty_fd, child_pid);
          }
#line 354
          if (tmp___4 < 0) {
#line 358
            goto kill_child;
          }
        }
      }
    }
  } else {
    {
#line 365
    tmp___5 = setsid();
    }
#line 365
    if (tmp___5 < 0) {
#line 366
      goto kill_child;
    }
#line 369
    if ((unsigned int )ctty_type == 3U) {
      {
#line 371
      tmp___6 = open((char const   *)ctty_name, 2, 0);
#line 371
      fd = tmp___6;
      }
#line 372
      if (fd < 0) {
#line 383
        goto kill_child;
      } else {
        {
#line 372
        tmp___7 = isatty(fd);
        }
#line 372
        if (tmp___7) {
          {
#line 372
          tmp___8 = ioctl(fd, 21518UL, 0);
          }
#line 372
          if (tmp___8 < 0) {
#line 383
            goto kill_child;
          } else {
            {
#line 372
            tmp___9 = tcsetpgrp(fd, child_pid);
            }
#line 372
            if (tmp___9 < 0) {
              {
#line 372
              tmp___10 = __errno_location();
              }
#line 372
              if (*tmp___10 != 38) {
#line 383
                goto kill_child;
              } else {
#line 372
                goto _L;
              }
            } else {
              _L: /* CIL Label */ 
              {
#line 372
              tmp___11 = child_setup_tty(fd);
              }
#line 372
              if (tmp___11 < 0) {
#line 383
                goto kill_child;
              }
            }
          }
        } else {
#line 383
          goto kill_child;
        }
      }
#line 385
      if ((unsigned int )channel_in_type == 2U) {
#line 386
        in_fd = fd;
      }
#line 387
      if ((unsigned int )channel_out_type == 2U) {
#line 388
        out_fd = fd;
      }
#line 389
      if ((unsigned int )channel_err_type == 2U) {
#line 390
        err_fd = fd;
      }
    }
  }
#line 395
  if (in_fd >= 0) {
#line 395
    if (in_fd != 0) {
#line 397
      if (out_fd == 0) {
        {
#line 397
        out_fd = dup(out_fd);
        }
#line 397
        if (out_fd < 0) {
#line 398
          goto kill_child;
        }
      }
#line 399
      if (err_fd == 0) {
        {
#line 399
        err_fd = dup(err_fd);
        }
#line 399
        if (err_fd < 0) {
#line 400
          goto kill_child;
        }
      }
      {
#line 401
      tmp___12 = dup2(in_fd, 0);
      }
#line 401
      if (tmp___12 < 0) {
#line 402
        goto kill_child;
      }
    }
  }
#line 404
  if (out_fd >= 0) {
#line 404
    if (out_fd != 1) {
#line 406
      if (err_fd == 1) {
        {
#line 406
        err_fd = dup(err_fd);
        }
#line 406
        if (err_fd < 0) {
#line 407
          goto kill_child;
        }
      }
      {
#line 408
      tmp___13 = dup2(out_fd, 1);
      }
#line 408
      if (tmp___13 < 0) {
#line 409
        goto kill_child;
      }
    }
  }
#line 411
  if (err_fd >= 0) {
#line 411
    if (err_fd != 2) {
      {
#line 413
      tmp___14 = dup2(err_fd, 2);
      }
#line 413
      if (tmp___14 < 0) {
#line 414
        goto kill_child;
      }
    }
  }
#line 419
  if ((unsigned int )channel_in_type == 0U) {
    {
#line 420
    close(0);
    }
  }
#line 421
  if ((unsigned int )channel_out_type == 0U) {
    {
#line 422
    close(1);
    }
  }
#line 423
  if ((unsigned int )channel_err_type == 0U) {
    {
#line 424
    close(2);
    }
  }
  {
#line 426
  UX_closefrom(3);
#line 429
  UX_initialize_child_signals();
#line 432
  execve(filename, (char * const  *)argv, (char * const  *)envp);
  }
  kill_child: 
  {
#line 434
  _exit(1);
  }
}
}
#line 444 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxproc.c"
pid_t OS_process_id(Tprocess process ) 
{ 


  {
#line 444
  return ((process_table + process)->id);
}
}
#line 445 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxproc.c"
enum process_status OS_process_status(Tprocess process ) 
{ 


  {
#line 445
  return ((process_table + process)->status);
}
}
#line 446 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxproc.c"
unsigned short OS_process_reason(Tprocess process ) 
{ 


  {
#line 446
  return ((process_table + process)->reason);
}
}
#line 447 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxproc.c"
enum process_jc_status OS_process_jc_status(Tprocess process ) 
{ 


  {
#line 447
  return ((process_table + process)->jc_status);
}
}
#line 450 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxproc.c"
int OS_process_valid_p(Tprocess process ) 
{ 


  {
#line 453
  if (process > OS_process_table_size) {
#line 454
    return (0);
  }
  {
#line 460
  if ((unsigned int )(process_table + process)->raw_status == 2U) {
#line 460
    goto case_2;
  }
#line 460
  if ((unsigned int )(process_table + process)->raw_status == 3U) {
#line 460
    goto case_2;
  }
#line 460
  if ((unsigned int )(process_table + process)->raw_status == 5U) {
#line 460
    goto case_2;
  }
#line 460
  if ((unsigned int )(process_table + process)->raw_status == 4U) {
#line 460
    goto case_2;
  }
#line 462
  goto switch_default;
  case_2: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
#line 461
  return (1);
  switch_default: /* CIL Label */ 
#line 463
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 467 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxproc.c"
int OS_process_continuable_p(Tprocess process ) 
{ 


  {
  {
#line 473
  if ((unsigned int )(process_table + process)->raw_status == 2U) {
#line 473
    goto case_2;
  }
#line 473
  if ((unsigned int )(process_table + process)->raw_status == 3U) {
#line 473
    goto case_2;
  }
#line 475
  goto switch_default;
  case_2: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 474
  return (1);
  switch_default: /* CIL Label */ 
#line 476
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 480 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxproc.c"
int OS_process_foregroundable_p(Tprocess process ) 
{ 


  {
  {
#line 486
  if ((unsigned int )(process_table + process)->jc_status == 3U) {
#line 486
    goto case_3;
  }
#line 486
  if ((unsigned int )(process_table + process)->jc_status == 2U) {
#line 486
    goto case_3;
  }
#line 488
  goto switch_default;
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 487
  return (1);
  switch_default: /* CIL Label */ 
#line 489
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 493 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxproc.c"
int OS_process_status_sync(Tprocess process ) 
{ 
  int result ;

  {
  {
#line 496
  transaction_begin();
#line 497
  block_sigchld();
#line 499
  result = (process_table + process)->tick != (process_table + process)->sync_tick;
  }
#line 500
  if (result) {
    {
#line 500
    while (1) {
      while_continue: /* CIL Label */ ;
#line 500
      (process_table + process)->status = (process_table + process)->raw_status;
#line 500
      (process_table + process)->reason = (process_table + process)->raw_reason;
#line 500
      (process_table + process)->sync_tick = (process_table + process)->tick;
#line 500
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 501
  transaction_commit();
  }
#line 502
  return (result);
}
}
#line 506 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxproc.c"
int OS_process_status_sync_all(void) 
{ 
  int result ;

  {
  {
#line 509
  transaction_begin();
#line 510
  block_sigchld();
#line 512
  result = process_tick != sync_tick;
  }
#line 513
  if (result) {
#line 513
    sync_tick = process_tick;
  }
  {
#line 514
  transaction_commit();
  }
#line 515
  return (result);
}
}
#line 519 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxproc.c"
int OS_process_any_status_change(void) 
{ 


  {
#line 522
  return (process_tick != sync_tick);
}
}
#line 525 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxproc.c"
static void process_send_signal(Tprocess process , int sig ) 
{ 
  pid_t tmp ;
  int tmp___0 ;

  {
  {
#line 528
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 528
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 528
      if ((unsigned int )(process_table + process)->jc_status == 3U) {
#line 528
        tmp = - (process_table + process)->id;
      } else {
#line 528
        tmp = (process_table + process)->id;
      }
      {
#line 528
      tmp___0 = kill(tmp, sig);
      }
#line 528
      if (! (tmp___0 < 0)) {
#line 528
        goto while_break___0;
      }
      {
#line 528
      UX_prim_check_errno((enum syscall_names )23);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 528
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 534
  return;
}
}
#line 536 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxproc.c"
void OS_process_send_signal(Tprocess process , int sig ) 
{ 


  {
  {
#line 545
  transaction_begin();
#line 546
  block_sigchld();
  }
  {
#line 550
  if ((unsigned int )(process_table + process)->raw_status == 3U) {
#line 550
    goto case_3;
  }
#line 550
  if ((unsigned int )(process_table + process)->raw_status == 2U) {
#line 550
    goto case_3;
  }
#line 555
  if ((unsigned int )(process_table + process)->raw_status == 5U) {
#line 555
    goto case_5;
  }
#line 555
  if ((unsigned int )(process_table + process)->raw_status == 4U) {
#line 555
    goto case_5;
  }
#line 565
  goto switch_default;
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  {
#line 551
  process_send_signal(process, sig);
  }
#line 552
  goto switch_break;
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  {
#line 560
  error_process_terminated();
  }
  switch_default: /* CIL Label */ 
  {
#line 566
  error_in_system_call((enum syserr_names )31, (enum syscall_names )23);
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 568
  transaction_commit();
  }
#line 569
  return;
}
}
#line 571 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxproc.c"
void OS_process_kill(Tprocess process ) 
{ 


  {
  {
#line 574
  OS_process_send_signal(process, 9);
  }
#line 575
  return;
}
}
#line 577 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxproc.c"
void OS_process_stop(Tprocess process ) 
{ 


  {
  {
#line 580
  OS_process_send_signal(process, 20);
  }
#line 581
  return;
}
}
#line 583 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxproc.c"
void OS_process_interrupt(Tprocess process ) 
{ 


  {
  {
#line 586
  OS_process_send_signal(process, 2);
  }
#line 587
  return;
}
}
#line 589 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxproc.c"
void OS_process_quit(Tprocess process ) 
{ 


  {
  {
#line 592
  OS_process_send_signal(process, 3);
  }
#line 593
  return;
}
}
#line 595 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxproc.c"
void OS_process_hangup(Tprocess process ) 
{ 


  {
  {
#line 598
  OS_process_send_signal(process, 1);
  }
#line 599
  return;
}
}
#line 601 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxproc.c"
void OS_process_continue_background(Tprocess process ) 
{ 


  {
  {
#line 604
  transaction_begin();
#line 605
  block_sigchld();
  }
#line 606
  if ((unsigned int )(process_table + process)->raw_status == 3U) {
    {
#line 608
    while (1) {
      while_continue: /* CIL Label */ ;
#line 608
      (process_table + process)->raw_status = (enum process_status )2;
#line 608
      (process_table + process)->raw_reason = (unsigned short)0;
#line 608
      process_tick ++;
#line 608
      (process_table + process)->tick = process_tick;
#line 608
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 609
    process_send_signal(process, 18);
    }
  }
  {
#line 611
  transaction_commit();
  }
#line 612
  return;
}
}
#line 614 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxproc.c"
void OS_process_continue_foreground(Tprocess process ) 
{ 


  {
  {
#line 617
  transaction_begin();
#line 618
  grab_signal_mask();
#line 619
  block_jc_signals();
#line 620
  give_terminal_to(process);
  }
#line 621
  if ((unsigned int )(process_table + process)->raw_status == 3U) {
    {
#line 623
    while (1) {
      while_continue: /* CIL Label */ ;
#line 623
      (process_table + process)->raw_status = (enum process_status )2;
#line 623
      (process_table + process)->raw_reason = (unsigned short)0;
#line 623
      process_tick ++;
#line 623
      (process_table + process)->tick = process_tick;
#line 623
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 624
    process_send_signal(process, 18);
    }
  }
  {
#line 626
  process_wait(process);
#line 627
  transaction_commit();
  }
#line 628
  return;
}
}
#line 630 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxproc.c"
void OS_process_wait(Tprocess process ) 
{ 


  {
  {
#line 633
  transaction_begin();
#line 634
  grab_signal_mask();
#line 635
  block_jc_signals();
#line 636
  process_wait(process);
#line 637
  transaction_commit();
  }
#line 638
  return;
}
}
#line 640 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxproc.c"
static void get_terminal_back_1(void *environment ) 
{ 


  {
  {
#line 643
  get_terminal_back();
  }
#line 644
  return;
}
}
#line 646 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxproc.c"
static void give_terminal_to(Tprocess process ) 
{ 
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  __pid_t tmp___3 ;
  __pid_t tmp___4 ;

  {
#line 649
  if ((unsigned int )(process_table + process)->jc_status == 3U) {
    {
#line 649
    tmp___3 = tcgetpgrp(scheme_ctty_fd);
#line 649
    tmp___4 = getpgrp();
    }
#line 649
    if (tmp___3 == tmp___4) {
      {
#line 652
      transaction_record_action((enum transaction_action_type )2, & get_terminal_back_1,
                                (void *)0);
#line 653
      foreground_child_process = process;
#line 654
      OS_save_internal_state();
#line 655
      OS_restore_external_state();
      }
      {
#line 656
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 656
        tmp___2 = tcsetpgrp(scheme_ctty_fd, (process_table + process)->id);
        }
#line 656
        if (! (tmp___2 < 0)) {
#line 656
          goto while_break;
        }
        {
#line 658
        tmp = __errno_location();
        }
#line 658
        if (*tmp == 38) {
#line 659
          goto while_break;
        }
        {
#line 660
        tmp___1 = __errno_location();
        }
#line 660
        if (*tmp___1 != 4) {
          {
#line 661
          tmp___0 = __errno_location();
#line 661
          error_system_call(*tmp___0, (enum syscall_names )60);
          }
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 664
  return;
}
}
#line 666 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxproc.c"
static void get_terminal_back(void) 
{ 
  int *tmp ;
  __pid_t tmp___0 ;
  int tmp___1 ;

  {
#line 669
  if (foreground_child_process != 4294967295U) {
    {
#line 671
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 671
      tmp___0 = getpgrp();
#line 671
      tmp___1 = tcsetpgrp(scheme_ctty_fd, tmp___0);
      }
#line 671
      if (! (tmp___1 < 0)) {
#line 671
        goto while_break;
      }
      {
#line 672
      tmp = __errno_location();
      }
#line 672
      if (*tmp != 4) {
#line 676
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 677
    OS_save_external_state();
#line 678
    OS_restore_internal_state();
#line 679
    foreground_child_process = (Tprocess )-1;
    }
  }
#line 681
  return;
}
}
#line 683 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxproc.c"
static void process_wait(Tprocess process ) 
{ 
  int tmp ;

  {
  {
#line 687
  while (1) {
    while_continue: /* CIL Label */ ;
#line 687
    if ((unsigned int )(process_table + process)->raw_status == 2U) {
      {
#line 687
      tmp = pending_interrupts_p();
      }
#line 687
      if (tmp) {
#line 687
        goto while_break;
      }
    } else {
#line 687
      goto while_break;
    }
    {
#line 689
    sigsuspend((sigset_t const   *)(& grabbed_signal_mask));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 707
  return;
}
}
#line 709 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxproc.c"
static Tprocess find_process(pid_t pid ) 
{ 
  Tprocess process ;

  {
#line 713
  process = (Tprocess )0;
  {
#line 713
  while (1) {
    while_continue: /* CIL Label */ ;
#line 713
    if (! (process < OS_process_table_size)) {
#line 713
      goto while_break;
    }
#line 714
    if ((process_table + process)->id == pid) {
#line 715
      return (process);
    }
#line 713
    process ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 716
  return ((Tprocess )-1);
}
}
#line 719 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxproc.c"
static void subprocess_death(pid_t pid , int *status ) 
{ 
  Tprocess process ;
  Tprocess tmp ;
  union __anonunion_82 __constr_expr_0 ;
  union __anonunion_83 __constr_expr_1 ;
  union __anonunion_84 __constr_expr_2 ;
  union __anonunion_85 __constr_expr_3 ;
  union __anonunion_86 __constr_expr_4 ;
  union __anonunion_87 __constr_expr_5 ;

  {
  {
#line 722
  tmp = find_process(pid);
#line 722
  process = tmp;
  }
#line 723
  if (process != 4294967295U) {
#line 725
    __constr_expr_5.__in = *status;
#line 725
    if ((__constr_expr_5.__i & 127) == 0) {
      {
#line 726
      while (1) {
        while_continue: /* CIL Label */ ;
#line 726
        (process_table + process)->raw_status = (enum process_status )4;
#line 726
        __constr_expr_0.__in = *status;
#line 726
        (process_table + process)->raw_reason = (unsigned short )((__constr_expr_0.__i & 65280) >> 8);
#line 726
        process_tick ++;
#line 726
        (process_table + process)->tick = process_tick;
#line 726
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 728
      __constr_expr_4.__in = *status;
#line 728
      if ((__constr_expr_4.__i & 255) == 127) {
        {
#line 729
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 729
          (process_table + process)->raw_status = (enum process_status )3;
#line 729
          __constr_expr_1.__in = *status;
#line 729
          (process_table + process)->raw_reason = (unsigned short )((__constr_expr_1.__i & 65280) >> 8);
#line 729
          process_tick ++;
#line 729
          (process_table + process)->tick = process_tick;
#line 729
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
      } else {
#line 731
        __constr_expr_3.__in = *status;
#line 731
        if ((int )((signed char )((__constr_expr_3.__i & 127) + 1)) >> 1 > 0) {
          {
#line 732
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 732
            (process_table + process)->raw_status = (enum process_status )5;
#line 732
            __constr_expr_2.__in = *status;
#line 732
            (process_table + process)->raw_reason = (unsigned short )(__constr_expr_2.__i & 127);
#line 732
            process_tick ++;
#line 732
            (process_table + process)->tick = process_tick;
#line 732
            goto while_break___1;
          }
          while_break___1: /* CIL Label */ ;
          }
        }
      }
    }
  }
#line 735
  return;
}
}
#line 737 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxproc.c"
static void stop_signal_handler(int signo ) 
{ 


  {
  {
#line 744
  get_terminal_back();
#line 745
  stop_signal_default(signo);
  }
#line 746
  return;
}
}
#line 783 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxproc.c"
static int child_setup_tty(int fd ) 
{ 
  cc_t disabled_char ;
  cc_t tmp ;
  struct termios s ;
  int tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp7 ;

  {
  {
#line 786
  tmp = UX_PC_VDISABLE(fd);
#line 786
  disabled_char = tmp;
#line 788
  tmp___0 = tcgetattr(fd, & s);
  }
#line 788
  if (tmp___0 < 0) {
#line 789
    return (-1);
  }
  {
#line 790
  s.c_iflag &= 4294966783U;
#line 791
  s.c_oflag |= 1U;
#line 792
  s.c_oflag &= 4294902009U;
#line 794
  s.c_lflag &= 4294967175U;
#line 795
  s.c_lflag |= 3U;
#line 796
  s.c_cc[4] = (cc_t )'\004';
#line 797
  s.c_cc[2] = disabled_char;
#line 798
  s.c_cc[3] = disabled_char;
#line 799
  cfsetispeed(& s, (speed_t )13);
#line 800
  cfsetospeed(& s, (speed_t )13);
#line 801
  tmp___1 = tcsetattr(fd, 1, (struct termios  const  *)(& s));
  }
#line 801
  return (tmp___1);
}
}
#line 366 "/usr/include/unistd.h"
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 417
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pipe)(int *__pipedes ) ;
#line 956
extern int fsync(int __fd ) ;
#line 1112
extern int fdatasync(int __fildes ) ;
#line 354 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h"
extern int sync_file_range(int __fd , __off64_t __offset , __off64_t __count , unsigned int __flags ) ;
#line 146 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 66 "/usr/include/x86_64-linux-gnu/sys/poll.h"
extern int ppoll(struct pollfd *__fds , nfds_t __nfds , struct timespec  const  *__timeout ,
                 __sigset_t const   *__ss ) ;
#line 41 "/home/khheo/project/mit-scheme-9.2/src/microcode/osscheme.h"
 __attribute__((__noreturn__)) void error_out_of_channels(void) ;
#line 54 "/home/khheo/project/mit-scheme-9.2/src/microcode/osio.h"
Tchannel OS_channel_table_size  ;
#line 56
int OS_channel_open_p(Tchannel channel ) ;
#line 57
void OS_channel_close(Tchannel channel ) ;
#line 58
void OS_channel_close_noerror(Tchannel channel ) ;
#line 60
void OS_channel_synchronize(Tchannel channel ) ;
#line 61
enum channel_type OS_channel_type(Tchannel channel ) ;
#line 62
size_t OS_channel_read_load_file(Tchannel channel , void *buffer___2 , size_t nbytes ) ;
#line 64
size_t OS_channel_write_dump_file(Tchannel channel , void const   *buffer___2 , size_t nbytes ) ;
#line 66
long OS_channel_read(Tchannel channel , void *buffer___2 , size_t nbytes ) ;
#line 68
long OS_channel_write(Tchannel channel , void const   *buffer___2 , size_t nbytes ) ;
#line 70
void OS_channel_write_string(Tchannel channel , char const   *string ) ;
#line 72
void OS_make_pipe(Tchannel *readerp , Tchannel *writerp ) ;
#line 74
int OS_channel_nonblocking_p(Tchannel channel ) ;
#line 75
void OS_channel_nonblocking(Tchannel channel ) ;
#line 76
void OS_channel_blocking(Tchannel channel ) ;
#line 83
int const   OS_have_select_p ;
#line 95
select_registry_t OS_allocate_select_registry(void) ;
#line 97
void OS_deallocate_select_registry(select_registry_t registry ) ;
#line 99
void OS_add_to_select_registry(select_registry_t registry , int fd , unsigned int mode ) ;
#line 101
void OS_remove_from_select_registry(select_registry_t registry , int fd , unsigned int mode ) ;
#line 103
unsigned int OS_select_registry_length(select_registry_t registry ) ;
#line 105
void OS_select_registry_result(select_registry_t registry , unsigned int index___0 ,
                               int *fd_r , unsigned int *mode_r ) ;
#line 108
int OS_test_select_registry(select_registry_t registry , int blockp ) ;
#line 110
int OS_test_select_descriptor(int fd , int blockp , unsigned int mode ) ;
#line 112
int OS_pause(void) ;
#line 59 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxio.h"
struct channel *channel_table  ;
#line 42 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxio.c"
static void UX_channel_close_all(void) 
{ 
  Tchannel channel ;

  {
#line 46
  channel = (Tchannel )0;
  {
#line 46
  while (1) {
    while_continue: /* CIL Label */ ;
#line 46
    if (! (channel < OS_channel_table_size)) {
#line 46
      goto while_break;
    }
#line 47
    if ((channel_table + channel)->descriptor >= 0) {
      {
#line 48
      OS_channel_close_noerror(channel);
      }
    }
#line 46
    channel ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 49
  return;
}
}
#line 51 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxio.c"
void UX_initialize_channels(void) 
{ 
  void *tmp ;
  Tchannel channel ;
  int __cil_tmp3 ;

  {
  {
#line 54
  OS_channel_table_size = (Tchannel )64;
#line 55
  tmp = malloc((unsigned long )OS_channel_table_size * sizeof(struct channel ));
#line 55
  channel_table = (struct channel *)tmp;
  }
#line 57
  if ((unsigned long )channel_table == (unsigned long )((struct channel *)0)) {
    {
#line 59
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nUnable to allocate channel table.\n");
#line 60
    fflush(stderr);
#line 61
    termination_init_error();
    }
  }
#line 65
  channel = (Tchannel )0;
  {
#line 65
  while (1) {
    while_continue: /* CIL Label */ ;
#line 65
    if (! (channel < OS_channel_table_size)) {
#line 65
      goto while_break;
    }
#line 66
    (channel_table + channel)->descriptor = -1;
#line 65
    channel ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 68
  add_reload_cleanup(& UX_channel_close_all);
  }
#line 75
  return;
}
}
#line 77 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxio.c"
void UX_reset_channels(void) 
{ 


  {
  {
#line 80
  free((void *)channel_table);
#line 81
  channel_table = (struct channel *)0;
#line 82
  OS_channel_table_size = (Tchannel )0;
  }
#line 83
  return;
}
}
#line 85 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxio.c"
Tchannel channel_allocate(void) 
{ 
  Tchannel channel ;
  size_t old_size ;
  size_t new_size ;
  struct channel *new_table ;
  void *tmp ;

  {
#line 89
  channel = (Tchannel )0;
  {
#line 89
  while (1) {
    while_continue: /* CIL Label */ ;
#line 89
    if (! (channel < OS_channel_table_size)) {
#line 89
      goto while_break;
    }
#line 90
    if ((channel_table + channel)->descriptor < 0) {
#line 91
      return (channel);
    }
#line 89
    channel ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 93
  old_size = (size_t )OS_channel_table_size;
#line 94
  new_size = (old_size * 5UL) / 4UL;
#line 95
  tmp = realloc((void *)channel_table, new_size * sizeof(struct channel ));
#line 95
  new_table = (struct channel *)tmp;
  }
#line 97
  if ((unsigned long )new_table == (unsigned long )((struct channel *)0)) {
    {
#line 99
    error_out_of_channels();
    }
#line 100
    return ((Tchannel )-1);
  }
#line 102
  OS_channel_table_size = (Tchannel )new_size;
#line 103
  channel_table = new_table;
#line 104
  channel = (Tchannel )old_size;
  {
#line 104
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 104
    if (! ((size_t )channel < new_size)) {
#line 104
      goto while_break___0;
    }
#line 105
    (channel_table + channel)->descriptor = -1;
#line 104
    channel ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 106
  return ((Tchannel )old_size);
}
}
#line 110 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxio.c"
int UX_channel_descriptor(Tchannel channel ) 
{ 


  {
#line 113
  return ((channel_table + channel)->descriptor);
}
}
#line 116 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxio.c"
int OS_channel_open_p(Tchannel channel ) 
{ 


  {
#line 119
  return ((channel_table + channel)->descriptor >= 0);
}
}
#line 122 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxio.c"
void OS_channel_close(Tchannel channel ) 
{ 
  int status ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 125
  if (! (channel_table + channel)->internal) {
    {
#line 127
    tmp = close((channel_table + channel)->descriptor);
#line 127
    status = tmp;
#line 128
    (channel_table + channel)->descriptor = -1;
    }
#line 129
    if (status < 0) {
      {
#line 130
      tmp___0 = __errno_location();
      }
      {
#line 132
      if (*tmp___0 == 4) {
#line 132
        goto case_4;
      }
#line 133
      if (*tmp___0 == 9) {
#line 133
        goto case_9;
      }
#line 130
      goto switch_break;
      case_4: /* CIL Label */ 
      {
#line 132
      deliver_pending_interrupts();
      }
#line 132
      goto switch_break;
      case_9: /* CIL Label */ 
      {
#line 133
      tmp___1 = __errno_location();
#line 133
      error_system_call(*tmp___1, (enum syscall_names )5);
      }
#line 133
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 136
  return;
}
}
#line 138 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxio.c"
void OS_channel_close_noerror(Tchannel channel ) 
{ 


  {
#line 141
  if (! (channel_table + channel)->internal) {
    {
#line 143
    close((channel_table + channel)->descriptor);
#line 144
    (channel_table + channel)->descriptor = -1;
    }
  }
#line 146
  return;
}
}
#line 148 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxio.c"
static void channel_close_on_abort_1(void *cp ) 
{ 


  {
  {
#line 151
  OS_channel_close(*((Tchannel *)cp));
  }
#line 152
  return;
}
}
#line 154 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxio.c"
void OS_channel_close_on_abort(Tchannel channel ) 
{ 
  Tchannel *cp ;
  void *tmp ;

  {
  {
#line 157
  tmp = dstack_alloc((unsigned int )sizeof(Tchannel ));
#line 157
  cp = (Tchannel *)tmp;
#line 158
  *cp = channel;
#line 159
  transaction_record_action((enum transaction_action_type )0, & channel_close_on_abort_1,
                            (void *)cp);
  }
#line 160
  return;
}
}
#line 165 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxio.c"
static _Bool fsync_check_errno(enum syscall_names syscall_name ) 
{ 
  int *tmp ;
  int *tmp___0 ;

  {
  {
#line 168
  tmp = __errno_location();
  }
  {
#line 170
  if (*tmp == 4) {
#line 170
    goto case_4;
  }
#line 180
  if (*tmp == 30) {
#line 180
    goto case_30;
  }
#line 180
  if (*tmp == 25) {
#line 180
    goto case_30;
  }
#line 180
  if (*tmp == 38) {
#line 180
    goto case_30;
  }
#line 180
  if (*tmp == 22) {
#line 180
    goto case_30;
  }
#line 180
  if (*tmp == 9) {
#line 180
    goto case_30;
  }
#line 183
  goto switch_default;
  case_4: /* CIL Label */ 
  {
#line 171
  deliver_pending_interrupts();
  }
#line 172
  return ((_Bool)0);
  case_30: /* CIL Label */ 
  case_25: /* CIL Label */ 
  case_38: /* CIL Label */ 
  case_22: /* CIL Label */ 
  case_9: /* CIL Label */ 
#line 181
  return ((_Bool)1);
  switch_default: /* CIL Label */ 
  {
#line 184
  tmp___0 = __errno_location();
#line 184
  error_system_call(*tmp___0, syscall_name);
  }
  switch_break: /* CIL Label */ ;
  }
}
}
#line 195 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxio.c"
void OS_channel_synchronize(Tchannel channel ) 
{ 
  int fd ;
  _Bool tmp ;
  int tmp___0 ;
  _Bool tmp___1 ;
  int tmp___2 ;
  _Bool tmp___3 ;
  int tmp___4 ;

  {
#line 198
  fd = (channel_table + channel)->descriptor;
  {
#line 200
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 200
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 200
      tmp___0 = fdatasync(fd);
      }
#line 200
      if (! (tmp___0 < 0)) {
#line 200
        goto while_break___0;
      }
      {
#line 200
      tmp = fsync_check_errno((enum syscall_names )10);
      }
#line 200
      if (tmp) {
#line 200
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 200
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 217
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 217
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 217
      tmp___2 = sync_file_range(fd, (__off64_t )0, (__off64_t )0, 7U);
      }
#line 217
      if (! (tmp___2 < 0)) {
#line 217
        goto while_break___2;
      }
      {
#line 217
      tmp___1 = fsync_check_errno((enum syscall_names )56);
      }
#line 217
      if (tmp___1) {
#line 217
        goto while_break___2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 217
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 226
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 226
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 226
      tmp___4 = fsync(fd);
      }
#line 226
      if (! (tmp___4 < 0)) {
#line 226
        goto while_break___4;
      }
      {
#line 226
      tmp___3 = fsync_check_errno((enum syscall_names )14);
      }
#line 226
      if (tmp___3) {
#line 226
        goto while_break___4;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 226
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 232
  return;
}
}
#line 236 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxio.c"
enum channel_type OS_channel_type(Tchannel channel ) 
{ 


  {
#line 239
  return ((channel_table + channel)->type);
}
}
#line 242 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxio.c"
long OS_channel_read(Tchannel channel , void *buffer___2 , size_t nbytes ) 
{ 
  long scr ;
  ssize_t tmp ;
  int *tmp___0 ;

  {
#line 245
  if (nbytes == 0UL) {
#line 246
    return (0L);
  }
  {
#line 247
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 249
    tmp = read((channel_table + channel)->descriptor, buffer___2, nbytes);
#line 249
    scr = tmp;
    }
#line 250
    if (scr < 0L) {
      {
#line 268
      tmp___0 = __errno_location();
      }
#line 268
      if (*tmp___0 == 11) {
#line 269
        return (-1L);
      }
      {
#line 272
      UX_prim_check_errno((enum syscall_names )38);
      }
#line 273
      goto while_continue;
    }
#line 275
    if ((size_t )scr > nbytes) {
      {
#line 276
      error_external_return();
      }
    }
#line 280
    return (scr);
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 285 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxio.c"
long OS_channel_write(Tchannel channel , void const   *buffer___2 , size_t nbytes ) 
{ 
  long scr ;
  ssize_t tmp ;
  int *tmp___0 ;
  long tmp___1 ;

  {
#line 288
  if (nbytes == 0UL) {
#line 289
    return (0L);
  }
  {
#line 290
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 292
    tmp = write((channel_table + channel)->descriptor, buffer___2, nbytes);
#line 292
    scr = tmp;
    }
#line 293
    if (scr < 0L) {
      {
#line 296
      tmp___0 = __errno_location();
      }
#line 296
      if (*tmp___0 == 11) {
#line 297
        return (-1L);
      }
      {
#line 299
      UX_prim_check_errno((enum syscall_names )68);
      }
#line 300
      goto while_continue;
    }
#line 302
    if ((size_t )scr > nbytes) {
      {
#line 303
      error_external_return();
      }
    }
#line 304
    if (scr > 0L) {
#line 304
      tmp___1 = scr;
    } else {
#line 304
      tmp___1 = -1L;
    }
#line 304
    return (tmp___1);
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 308 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxio.c"
size_t OS_channel_read_load_file(Tchannel channel , void *buffer___2 , size_t nbytes ) 
{ 
  int scr ;
  ssize_t tmp ;
  int tmp___0 ;

  {
  {
#line 311
  tmp = read((channel_table + channel)->descriptor, buffer___2, nbytes);
#line 311
  scr = (int )tmp;
  }
#line 312
  if (scr < 0) {
#line 312
    tmp___0 = 0;
  } else {
#line 312
    tmp___0 = scr;
  }
#line 312
  return ((size_t )tmp___0);
}
}
#line 315 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxio.c"
size_t OS_channel_write_dump_file(Tchannel channel , void const   *buffer___2 , size_t nbytes ) 
{ 
  int scr ;
  ssize_t tmp ;
  int tmp___0 ;

  {
  {
#line 320
  tmp = write((channel_table + channel)->descriptor, buffer___2, nbytes);
#line 320
  scr = (int )tmp;
  }
#line 321
  if (scr < 0) {
#line 321
    tmp___0 = 0;
  } else {
#line 321
    tmp___0 = scr;
  }
#line 321
  return ((size_t )tmp___0);
}
}
#line 324 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxio.c"
void OS_channel_write_string(Tchannel channel , char const   *string ) 
{ 
  unsigned long length ;
  size_t tmp ;
  long tmp___0 ;

  {
  {
#line 327
  tmp = strlen(string);
#line 327
  length = tmp;
#line 328
  tmp___0 = OS_channel_write(channel, (void const   *)string, length);
  }
#line 328
  if ((unsigned long )tmp___0 != length) {
    {
#line 329
    error_external_return();
    }
  }
#line 330
  return;
}
}
#line 332 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxio.c"
void OS_make_pipe(Tchannel *readerp , Tchannel *writerp ) 
{ 
  int pv[2] ;
  int tmp ;
  Tchannel MAKE_CHANNEL_temp ;
  Tchannel tmp___0 ;
  Tchannel MAKE_CHANNEL_temp___0 ;
  Tchannel tmp___1 ;
  void *__cil_tmp9 ;

  {
  {
#line 336
  transaction_begin();
  }
  {
#line 337
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 337
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 337
      tmp = pipe((int *)(pv));
      }
#line 337
      if (! (tmp < 0)) {
#line 337
        goto while_break___0;
      }
      {
#line 337
      UX_prim_check_fd_errno((enum syscall_names )37);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 337
    UX_out_of_files_p = (_Bool)0;
#line 337
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 338
  tmp___0 = channel_allocate();
#line 338
  MAKE_CHANNEL_temp = tmp___0;
#line 338
  (channel_table + MAKE_CHANNEL_temp)->descriptor = pv[0];
#line 338
  (channel_table + MAKE_CHANNEL_temp)->type = (enum channel_type )2;
#line 338
  (channel_table + MAKE_CHANNEL_temp)->internal = 0U;
#line 338
  (channel_table + MAKE_CHANNEL_temp)->nonblocking = 0U;
#line 338
  *readerp = MAKE_CHANNEL_temp;
#line 339
  OS_channel_close_on_abort(*readerp);
#line 340
  tmp___1 = channel_allocate();
#line 340
  MAKE_CHANNEL_temp___0 = tmp___1;
#line 340
  (channel_table + MAKE_CHANNEL_temp___0)->descriptor = pv[1];
#line 340
  (channel_table + MAKE_CHANNEL_temp___0)->type = (enum channel_type )2;
#line 340
  (channel_table + MAKE_CHANNEL_temp___0)->internal = 0U;
#line 340
  (channel_table + MAKE_CHANNEL_temp___0)->nonblocking = 0U;
#line 340
  *writerp = MAKE_CHANNEL_temp___0;
#line 341
  transaction_commit();
  }
#line 342
  return;
}
}
#line 346 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxio.c"
static int get_flags(int fd ) 
{ 
  int scr ;

  {
  {
#line 350
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 350
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 350
      scr = fcntl(fd, 3, 0);
      }
#line 350
      if (! (scr < 0)) {
#line 350
        goto while_break___0;
      }
      {
#line 350
      UX_prim_check_errno((enum syscall_names )7);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 350
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 351
  return (scr);
}
}
#line 354 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxio.c"
static void set_flags(int fd , int flags ) 
{ 
  int tmp ;

  {
  {
#line 357
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 357
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 357
      tmp = fcntl(fd, 4, flags);
      }
#line 357
      if (! (tmp < 0)) {
#line 357
        goto while_break___0;
      }
      {
#line 357
      UX_prim_check_errno((enum syscall_names )9);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 357
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 358
  return;
}
}
#line 360 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxio.c"
int OS_channel_nonblocking_p(Tchannel channel ) 
{ 


  {
#line 363
  return ((int )(channel_table + channel)->nonblocking);
}
}
#line 366 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxio.c"
void OS_channel_nonblocking(Tchannel channel ) 
{ 
  int fd ;
  int flags ;
  int tmp ;

  {
  {
#line 369
  fd = (channel_table + channel)->descriptor;
#line 370
  tmp = get_flags(fd);
#line 370
  flags = tmp;
  }
#line 371
  if ((flags & 2048) == 0) {
    {
#line 372
    set_flags(fd, flags | 2048);
    }
  }
#line 382
  (channel_table + channel)->nonblocking = 1U;
#line 383
  return;
}
}
#line 385 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxio.c"
void OS_channel_blocking(Tchannel channel ) 
{ 
  int fd ;
  int flags ;
  int tmp ;

  {
  {
#line 388
  fd = (channel_table + channel)->descriptor;
#line 389
  tmp = get_flags(fd);
#line 389
  flags = tmp;
  }
#line 390
  if ((flags & 2048) != 0) {
    {
#line 391
    set_flags(fd, flags & -2049);
    }
  }
#line 400
  (channel_table + channel)->nonblocking = 0U;
#line 401
  return;
}
}
#line 426 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxio.c"
int const   OS_have_select_p  =    (int const   )1;
#line 453 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxio.c"
select_registry_t OS_allocate_select_registry(void) 
{ 
  struct select_registry_s *r ;
  void *tmp ;
  void *tmp___0 ;
  int __cil_tmp4 ;

  {
  {
#line 456
  tmp = malloc(sizeof(struct select_registry_s ));
#line 456
  r = (struct select_registry_s *)tmp;
#line 458
  r->length = 4U;
#line 459
  r->n_fds = 0U;
#line 460
  tmp___0 = malloc(sizeof(struct pollfd ) * 4UL);
#line 460
  r->entries = (struct pollfd *)tmp___0;
  }
#line 461
  return ((select_registry_t )r);
}
}
#line 464 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxio.c"
void OS_deallocate_select_registry(select_registry_t registry ) 
{ 
  struct select_registry_s *r ;

  {
  {
#line 467
  r = (struct select_registry_s *)registry;
#line 468
  free((void *)r->entries);
#line 469
  free((void *)r);
  }
#line 470
  return;
}
}
#line 472 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxio.c"
void OS_add_to_select_registry(select_registry_t registry , int fd , unsigned int mode ) 
{ 
  struct select_registry_s *r ;
  unsigned int i ;
  int tmp ;
  int tmp___0 ;
  unsigned int length ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 477
  r = (struct select_registry_s *)registry;
#line 478
  i = 0U;
  {
#line 479
  while (1) {
    while_continue: /* CIL Label */ ;
#line 479
    if (! (i < r->n_fds)) {
#line 479
      goto while_break;
    }
#line 481
    if ((r->entries + i)->fd == fd) {
#line 483
      if ((mode & 1U) != 0U) {
#line 483
        tmp = 1;
      } else {
#line 483
        tmp = 0;
      }
#line 483
      if ((mode & 2U) != 0U) {
#line 483
        tmp___0 = 4;
      } else {
#line 483
        tmp___0 = 0;
      }
#line 483
      (r->entries + i)->events = (short )((int )(r->entries + i)->events | (tmp | tmp___0));
#line 484
      return;
    }
#line 486
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 488
  if (i == r->length) {
    {
#line 490
    length = r->length * 2U;
#line 491
    tmp___1 = realloc((void *)r->entries, sizeof(struct pollfd ) * (unsigned long )length);
#line 491
    r->entries = (struct pollfd *)tmp___1;
#line 492
    r->length = length;
    }
  }
#line 494
  (r->entries + i)->fd = fd;
#line 495
  if ((mode & 1U) != 0U) {
#line 495
    tmp___2 = 1;
  } else {
#line 495
    tmp___2 = 0;
  }
#line 495
  if ((mode & 2U) != 0U) {
#line 495
    tmp___3 = 4;
  } else {
#line 495
    tmp___3 = 0;
  }
#line 495
  (r->entries + i)->events = (short )(tmp___2 | tmp___3);
#line 496
  (r->n_fds) ++;
#line 497
  return;
}
}
#line 499 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxio.c"
void OS_remove_from_select_registry(select_registry_t registry , int fd , unsigned int mode ) 
{ 
  struct select_registry_s *r ;
  unsigned int i ;
  int tmp ;
  int tmp___0 ;
  unsigned int length ;
  void *tmp___1 ;

  {
#line 504
  r = (struct select_registry_s *)registry;
#line 505
  i = 0U;
  {
#line 506
  while (1) {
    while_continue: /* CIL Label */ ;
#line 508
    if (i == r->n_fds) {
#line 509
      return;
    }
#line 510
    if ((r->entries + i)->fd == fd) {
#line 512
      if ((mode & 1U) != 0U) {
#line 512
        tmp = 1;
      } else {
#line 512
        tmp = 0;
      }
#line 512
      if ((mode & 2U) != 0U) {
#line 512
        tmp___0 = 4;
      } else {
#line 512
        tmp___0 = 0;
      }
#line 512
      (r->entries + i)->events = (short )((int )(r->entries + i)->events & ~ (tmp | tmp___0));
#line 513
      if ((int )(r->entries + i)->events == 0) {
#line 514
        goto while_break;
      }
#line 515
      return;
    }
#line 517
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 519
  (r->n_fds) --;
  {
#line 520
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 520
    if (! (i < r->n_fds)) {
#line 520
      goto while_break___0;
    }
#line 522
    *(r->entries + i) = *(r->entries + (i + 1U));
#line 523
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 525
  if (i < r->length / 2U) {
#line 525
    if (r->length > 4U) {
      {
#line 528
      length = r->length / 2U;
#line 529
      tmp___1 = realloc((void *)r->entries, sizeof(struct pollfd ) * (unsigned long )length);
#line 529
      r->entries = (struct pollfd *)tmp___1;
#line 530
      r->length = length;
      }
    }
  }
#line 532
  return;
}
}
#line 534 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxio.c"
unsigned int OS_select_registry_length(select_registry_t registry ) 
{ 
  struct select_registry_s *r ;

  {
#line 537
  r = (struct select_registry_s *)registry;
#line 538
  return (r->n_fds);
}
}
#line 541 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxio.c"
void OS_select_registry_result(select_registry_t registry , unsigned int index___0 ,
                               int *fd_r , unsigned int *mode_r ) 
{ 
  struct select_registry_s *r ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 547
  r = (struct select_registry_s *)registry;
#line 548
  *fd_r = (r->entries + index___0)->fd;
#line 549
  if (((int )(r->entries + index___0)->revents & 1) != 0) {
#line 549
    tmp = 1;
  } else {
#line 549
    tmp = 0;
  }
#line 549
  if (((int )(r->entries + index___0)->revents & 4) != 0) {
#line 549
    tmp___0 = 2;
  } else {
#line 549
    tmp___0 = 0;
  }
#line 549
  if (((int )(r->entries + index___0)->revents & 8) != 0) {
#line 549
    tmp___1 = 4;
  } else {
#line 549
    tmp___1 = 0;
  }
#line 549
  if (((int )(r->entries + index___0)->revents & 16) != 0) {
#line 549
    tmp___2 = 8;
  } else {
#line 549
    tmp___2 = 0;
  }
#line 549
  *mode_r = (unsigned int )(((tmp | tmp___0) | tmp___1) | tmp___2);
#line 550
  return;
}
}
#line 552 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxio.c"
static int safe_poll(struct pollfd *fds , nfds_t nfds , int blockp ) 
{ 
  int n ;
  sigset_t old ;
  sigset_t new ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp10 ;
  void *__cil_tmp11 ;

  {
#line 558
  if (! blockp) {
    {
#line 560
    n = poll(fds, nfds, 0);
    }
  } else {
    {
#line 566
    sigfillset(& new);
#line 567
    sigprocmask(2, (sigset_t const   */* __restrict  */)(& new), (sigset_t */* __restrict  */)(& old));
#line 568
    tmp___0 = OS_process_any_status_change();
    }
#line 568
    if (tmp___0) {
      {
#line 571
      tmp = __errno_location();
#line 571
      *tmp = 4;
#line 572
      n = -1;
      }
    } else {
      {
#line 568
      tmp___1 = pending_interrupts_p();
      }
#line 568
      if (tmp___1) {
        {
#line 571
        tmp = __errno_location();
#line 571
        *tmp = 4;
#line 572
        n = -1;
        }
      } else {
        {
#line 576
        n = ppoll(fds, nfds, (struct timespec  const  *)((void *)0), (__sigset_t const   *)(& old));
        }
      }
    }
    {
#line 578
    sigprocmask(2, (sigset_t const   */* __restrict  */)(& old), (sigset_t */* __restrict  */)((void *)0));
    }
  }
#line 589
  return (n);
}
}
#line 592 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxio.c"
int OS_test_select_registry(select_registry_t registry , int blockp ) 
{ 
  struct select_registry_s *r ;
  int nfds ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 595
  r = (struct select_registry_s *)registry;
  {
#line 596
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 598
    tmp = safe_poll(r->entries, (nfds_t )r->n_fds, blockp);
#line 598
    nfds = tmp;
    }
#line 599
    if (nfds >= 0) {
#line 600
      return (nfds);
    }
    {
#line 601
    tmp___1 = __errno_location();
    }
#line 601
    if (*tmp___1 != 4) {
      {
#line 602
      tmp___0 = __errno_location();
#line 602
      error_system_call(*tmp___0, (enum syscall_names )43);
      }
    }
    {
#line 603
    tmp___2 = OS_process_any_status_change();
    }
#line 603
    if (tmp___2) {
#line 604
      return (-2);
    }
    {
#line 605
    tmp___3 = pending_interrupts_p();
    }
#line 605
    if (tmp___3) {
#line 606
      return (-1);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 610 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxio.c"
int OS_test_select_descriptor(int fd , int blockp , unsigned int mode ) 
{ 
  struct pollfd pfds[1] ;
  int tmp ;
  int tmp___0 ;
  int nfds ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  void *__cil_tmp17 ;
  int __cil_tmp18 ;

  {
#line 614
  pfds[0].fd = fd;
#line 615
  if ((mode & 1U) != 0U) {
#line 615
    tmp = 1;
  } else {
#line 615
    tmp = 0;
  }
#line 615
  if ((mode & 2U) != 0U) {
#line 615
    tmp___0 = 4;
  } else {
#line 615
    tmp___0 = 0;
  }
#line 615
  pfds[0].events = (short )(tmp | tmp___0);
  {
#line 616
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 618
    tmp___1 = safe_poll(pfds, (nfds_t )1, blockp);
#line 618
    nfds = tmp___1;
    }
#line 619
    if (nfds > 0) {
#line 620
      if (((int )pfds[0].revents & 1) != 0) {
#line 620
        tmp___2 = 1;
      } else {
#line 620
        tmp___2 = 0;
      }
#line 620
      if (((int )pfds[0].revents & 4) != 0) {
#line 620
        tmp___3 = 2;
      } else {
#line 620
        tmp___3 = 0;
      }
#line 620
      if (((int )pfds[0].revents & 8) != 0) {
#line 620
        tmp___4 = 4;
      } else {
#line 620
        tmp___4 = 0;
      }
#line 620
      if (((int )pfds[0].revents & 16) != 0) {
#line 620
        tmp___5 = 8;
      } else {
#line 620
        tmp___5 = 0;
      }
#line 620
      return (((tmp___2 | tmp___3) | tmp___4) | tmp___5);
    }
#line 621
    if (nfds == 0) {
#line 622
      return (0);
    }
    {
#line 623
    tmp___7 = __errno_location();
    }
#line 623
    if (*tmp___7 != 4) {
      {
#line 624
      tmp___6 = __errno_location();
#line 624
      error_system_call(*tmp___6, (enum syscall_names )43);
      }
    }
    {
#line 625
    tmp___8 = OS_process_any_status_change();
    }
#line 625
    if (tmp___8) {
#line 626
      return (-2);
    }
    {
#line 627
    tmp___9 = pending_interrupts_p();
    }
#line 627
    if (tmp___9) {
#line 628
      return (-1);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 855 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxio.c"
int OS_pause(void) 
{ 
  sigset_t old ;
  sigset_t new ;
  int n ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp7 ;
  void *__cil_tmp8 ;

  {
  {
#line 862
  sigfillset(& new);
#line 863
  sigprocmask(2, (sigset_t const   */* __restrict  */)(& new), (sigset_t */* __restrict  */)(& old));
#line 864
  tmp___1 = OS_process_any_status_change();
  }
#line 864
  if (tmp___1) {
#line 865
    n = -2;
  } else {
    {
#line 866
    tmp___0 = pending_interrupts_p();
    }
#line 866
    if (tmp___0) {
#line 867
      n = -1;
    } else {
      {
#line 870
      sigsuspend((sigset_t const   *)(& old));
#line 871
      tmp = OS_process_any_status_change();
      }
#line 871
      if (tmp) {
#line 872
        n = -2;
      } else {
#line 874
        n = -1;
      }
    }
  }
  {
#line 876
  sigprocmask(2, (sigset_t const   */* __restrict  */)(& old), (sigset_t */* __restrict  */)((void *)0));
  }
#line 877
  return (n);
}
}
#line 180 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rename)(char const   *__old ,
                                                                             char const   *__new ) ;
#line 147 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 214
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 263
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) lstat)(char const   * __restrict  __file ,
                                                                                              struct stat * __restrict  __buf ) ;
#line 321
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) mkdir)(char const   *__path ,
                                                                                            __mode_t __mode ) ;
#line 287 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *__name ,
                                                                                             int __type ) ;
#line 334
extern  __attribute__((__nothrow__)) __off_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                __off_t __offset ,
                                                                                int __whence ) ;
#line 790
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) link)(char const   *__from ,
                                                                                             char const   *__to ) ;
#line 803
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) symlink)(char const   *__from ,
                                                                                                char const   *__to ) ;
#line 809
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__nonnull__(1,2), __leaf__)) readlink)(char const   * __restrict  __path ,
                                                                                                     char * __restrict  __buf ,
                                                                                                     size_t __len ) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 835
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) rmdir)(char const   *__path ) ;
#line 1016
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ftruncate)(int __fd ,
                                                                                __off_t __length ) ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 162
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 49 "/home/khheo/project/mit-scheme-9.2/src/microcode/osfs.h"
enum file_existence OS_file_existence_test(char const   *name ) ;
#line 50
enum file_existence OS_file_existence_test_direct(char const   *name ) ;
#line 51
enum file_type OS_file_type_direct(char const   *name ) ;
#line 52
enum file_type OS_file_type_indirect(char const   *name ) ;
#line 53
int OS_file_access(char const   *name , unsigned int mode ) ;
#line 54
int OS_file_directory_p(char const   *name ) ;
#line 55
char const   *OS_file_soft_link_p(char const   *name ) ;
#line 56
void OS_file_remove(char const   *name ) ;
#line 57
void OS_file_remove_link(char const   *name ) ;
#line 58
void OS_file_rename(char const   *from_name , char const   *to_name ) ;
#line 59
void OS_file_link_hard(char const   *from_name , char const   *to_name ) ;
#line 60
void OS_file_link_soft(char const   *from_name , char const   *to_name ) ;
#line 61
void OS_directory_make(char const   *name ) ;
#line 62
void OS_directory_delete(char const   *name ) ;
#line 63
int OS_file_touch(char const   *filename ) ;
#line 64
unsigned int OS_directory_open(char const   *name ) ;
#line 65
int OS_directory_valid_p(unsigned int index___0 ) ;
#line 66
void OS_directory_close(unsigned int index___0 ) ;
#line 67
char const   *OS_directory_read(unsigned int index___0 ) ;
#line 68
char const   *OS_directory_read_matching(unsigned int index___0 , char const   *prefix ) ;
#line 70
void OS_file_copy(char const   *from_name , char const   *to_name ) ;
#line 32 "/home/khheo/project/mit-scheme-9.2/src/microcode/osfile.h"
Tchannel OS_open_input_file(char const   *filename ) ;
#line 33
Tchannel OS_open_output_file(char const   *filename ) ;
#line 39
off_t OS_file_length(Tchannel channel ) ;
#line 31 "/usr/include/x86_64-linux-gnu/sys/statfs.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) statfs)(char const   *__file ,
                                                                                               struct statfs *__buf ) ;
#line 138 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxfs.c"
void UX_read_fd_status(int fd , struct stat *s ) 
{ 
  int tmp ;

  {
  {
#line 141
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 141
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 141
      tmp = fstat(fd, s);
      }
#line 141
      if (! (tmp < 0)) {
#line 141
        goto while_break___0;
      }
      {
#line 141
      UX_prim_check_errno((enum syscall_names )12);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 141
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 142
  return;
}
}
#line 144 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxfs.c"
int UX_read_file_status(char const   *filename , struct stat *s ) 
{ 
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 147
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 147
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 147
      tmp___3 = lstat((char const   */* __restrict  */)filename, (struct stat */* __restrict  */)s);
      }
#line 147
      if (! (tmp___3 < 0)) {
#line 147
        goto while_break___0;
      }
      {
#line 147
      tmp = __errno_location();
      }
#line 147
      if (*tmp == 2) {
#line 147
        return (0);
      } else {
        {
#line 147
        tmp___0 = __errno_location();
        }
#line 147
        if (*tmp___0 == 20) {
#line 147
          return (0);
        }
      }
      {
#line 147
      tmp___2 = __errno_location();
      }
#line 147
      if (*tmp___2 != 4) {
        {
#line 147
        tmp___1 = __errno_location();
#line 147
        error_system_call(*tmp___1, (enum syscall_names )28);
        }
      }
      {
#line 147
      deliver_pending_interrupts();
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 147
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 148
  return (1);
}
}
#line 151 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxfs.c"
int UX_read_file_status_indirect(char const   *filename , struct stat *s ) 
{ 
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 154
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 154
      tmp___3 = stat((char const   */* __restrict  */)filename, (struct stat */* __restrict  */)s);
      }
#line 154
      if (! (tmp___3 < 0)) {
#line 154
        goto while_break___0;
      }
      {
#line 154
      tmp = __errno_location();
      }
#line 154
      if (*tmp == 2) {
#line 154
        return (0);
      } else {
        {
#line 154
        tmp___0 = __errno_location();
        }
#line 154
        if (*tmp___0 == 20) {
#line 154
          return (0);
        }
      }
      {
#line 154
      tmp___2 = __errno_location();
      }
#line 154
      if (*tmp___2 != 4) {
        {
#line 154
        tmp___1 = __errno_location();
#line 154
        error_system_call(*tmp___1, (enum syscall_names )53);
        }
      }
      {
#line 154
      deliver_pending_interrupts();
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 154
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 155
  return (1);
}
}
#line 158 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxfs.c"
enum file_existence OS_file_existence_test(char const   *name ) 
{ 
  struct stat s ;
  int tmp ;
  int tmp___0 ;
  void *__cil_tmp5 ;

  {
  {
#line 162
  tmp = UX_read_file_status(name, & s);
  }
#line 162
  if (! tmp) {
#line 163
    return ((enum file_existence )1);
  }
#line 165
  if ((s.st_mode & 61440U) == 40960U) {
    {
#line 167
    tmp___0 = UX_read_file_status_indirect(name, & s);
    }
#line 167
    if (tmp___0) {
#line 168
      return ((enum file_existence )0);
    } else {
#line 170
      return ((enum file_existence )2);
    }
  }
#line 173
  return ((enum file_existence )0);
}
}
#line 176 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxfs.c"
enum file_existence OS_file_existence_test_direct(char const   *name ) 
{ 
  struct stat s ;
  int tmp ;
  void *__cil_tmp4 ;

  {
  {
#line 180
  tmp = UX_read_file_status(name, & s);
  }
#line 180
  if (! tmp) {
#line 181
    return ((enum file_existence )1);
  }
#line 183
  if ((s.st_mode & 61440U) == 40960U) {
#line 184
    return ((enum file_existence )2);
  }
#line 186
  return ((enum file_existence )0);
}
}
#line 234 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxfs.c"
enum file_type OS_file_type_direct(char const   *name ) 
{ 
  struct stat s ;
  int tmp ;
  void *__cil_tmp4 ;

  {
  {
#line 236
  tmp = UX_read_file_status(name, & s);
  }
#line 236
  if (tmp) {
#line 236
    if ((s.st_mode & 61440U) == 32768U) {
#line 236
      return ((enum file_type )0);
    } else
#line 236
    if ((s.st_mode & 61440U) == 16384U) {
#line 236
      return ((enum file_type )1);
    } else
#line 236
    if ((s.st_mode & 61440U) == 40960U) {
#line 236
      return ((enum file_type )2);
    } else
#line 236
    if ((s.st_mode & 61440U) == 8192U) {
#line 236
      return ((enum file_type )3);
    } else
#line 236
    if ((s.st_mode & 61440U) == 24576U) {
#line 236
      return ((enum file_type )4);
    } else
#line 236
    if ((s.st_mode & 61440U) == 4096U) {
#line 236
      return ((enum file_type )5);
    } else
#line 236
    if ((s.st_mode & 61440U) == 49152U) {
#line 236
      return ((enum file_type )6);
    } else {
#line 236
      return ((enum file_type )65535);
    }
  } else {
#line 236
    return ((enum file_type )-1);
  }
}
}
#line 238 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxfs.c"
enum file_type OS_file_type_indirect(char const   *name ) 
{ 
  struct stat s ;
  int tmp ;
  void *__cil_tmp4 ;

  {
  {
#line 240
  tmp = UX_read_file_status_indirect(name, & s);
  }
#line 240
  if (tmp) {
#line 240
    if ((s.st_mode & 61440U) == 32768U) {
#line 240
      return ((enum file_type )0);
    } else
#line 240
    if ((s.st_mode & 61440U) == 16384U) {
#line 240
      return ((enum file_type )1);
    } else
#line 240
    if ((s.st_mode & 61440U) == 40960U) {
#line 240
      return ((enum file_type )2);
    } else
#line 240
    if ((s.st_mode & 61440U) == 8192U) {
#line 240
      return ((enum file_type )3);
    } else
#line 240
    if ((s.st_mode & 61440U) == 24576U) {
#line 240
      return ((enum file_type )4);
    } else
#line 240
    if ((s.st_mode & 61440U) == 4096U) {
#line 240
      return ((enum file_type )5);
    } else
#line 240
    if ((s.st_mode & 61440U) == 49152U) {
#line 240
      return ((enum file_type )6);
    } else {
#line 240
      return ((enum file_type )65535);
    }
  } else {
#line 240
    return ((enum file_type )-1);
  }
}
}
#line 242 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxfs.c"
char const   *UX_file_system_type(char const   *name ) 
{ 
  struct statfs s ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  void *__cil_tmp8 ;
  void *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;

  {
  {
#line 247
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 247
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 247
      tmp___3 = statfs(name, & s);
      }
#line 247
      if (! (tmp___3 < 0)) {
#line 247
        goto while_break___0;
      }
      {
#line 247
      tmp = __errno_location();
      }
#line 247
      if (*tmp == 2) {
#line 247
        return ((char const   *)0);
      } else {
        {
#line 247
        tmp___0 = __errno_location();
        }
#line 247
        if (*tmp___0 == 20) {
#line 247
          return ((char const   *)0);
        }
      }
      {
#line 247
      tmp___2 = __errno_location();
      }
#line 247
      if (*tmp___2 != 4) {
        {
#line 247
        tmp___1 = __errno_location();
#line 247
        error_system_call(*tmp___1, (enum syscall_names )54);
        }
      }
      {
#line 247
      deliver_pending_interrupts();
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 247
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 252
  if (s.f_type == 4283649346L) {
#line 252
    goto case_4283649346;
  }
#line 253
  if (s.f_type == 19920823L) {
#line 253
    goto case_19920823;
  }
#line 254
  if (s.f_type == 4989L) {
#line 254
    goto case_4989;
  }
#line 255
  if (s.f_type == 61267L) {
#line 255
    goto case_61267;
  }
#line 256
  if (s.f_type == 4187351113L) {
#line 256
    goto case_4187351113;
  }
#line 257
  if (s.f_type == 38496L) {
#line 257
    goto case_38496;
  }
#line 258
  if (s.f_type == 4991L) {
#line 258
    goto case_4991;
  }
#line 259
  if (s.f_type == 5007L) {
#line 259
    goto case_5007;
  }
#line 260
  if (s.f_type == 9320L) {
#line 260
    goto case_9320;
  }
#line 261
  if (s.f_type == 9336L) {
#line 261
    goto case_9336;
  }
#line 262
  if (s.f_type == 19780L) {
#line 262
    goto case_19780;
  }
#line 263
  if (s.f_type == 22092L) {
#line 263
    goto case_22092;
  }
#line 264
  if (s.f_type == 26985L) {
#line 264
    goto case_26985;
  }
#line 265
  if (s.f_type == 1397118030L) {
#line 265
    goto case_1397118030;
  }
#line 266
  if (s.f_type == 40864L) {
#line 266
    goto case_40864;
  }
#line 267
  if (s.f_type == 20859L) {
#line 267
    goto case_20859;
  }
#line 268
  if (s.f_type == 19920822L) {
#line 268
    goto case_19920822;
  }
#line 269
  if (s.f_type == 19920821L) {
#line 269
    goto case_19920821;
  }
#line 270
  if (s.f_type == 19920820L) {
#line 270
    goto case_19920820;
  }
#line 271
  if (s.f_type == 19911021L) {
#line 271
    goto case_19911021;
  }
#line 250
  goto switch_break;
  case_4283649346: /* CIL Label */ 
#line 252
  return ("cifs");
  case_19920823: /* CIL Label */ 
#line 253
  return ("coherent");
  case_4989: /* CIL Label */ 
#line 254
  return ("ext");
  case_61267: /* CIL Label */ 
#line 255
  return ("ext2");
  case_4187351113: /* CIL Label */ 
#line 256
  return ("hpfs");
  case_38496: /* CIL Label */ 
#line 257
  return ("iso9660");
  case_4991: /* CIL Label */ 
#line 258
  return ("minix1");
  case_5007: /* CIL Label */ 
#line 259
  return ("minix1-30");
  case_9320: /* CIL Label */ 
#line 260
  return ("minix2");
  case_9336: /* CIL Label */ 
#line 261
  return ("minix2-30");
  case_19780: /* CIL Label */ 
#line 262
  return ("fat");
  case_22092: /* CIL Label */ 
#line 263
  return ("ncp");
  case_26985: /* CIL Label */ 
#line 264
  return ("nfs");
  case_1397118030: /* CIL Label */ 
#line 265
  return ("ntfs");
  case_40864: /* CIL Label */ 
#line 266
  return ("proc");
  case_20859: /* CIL Label */ 
#line 267
  return ("smb");
  case_19920822: /* CIL Label */ 
#line 268
  return ("sysv2");
  case_19920821: /* CIL Label */ 
#line 269
  return ("sysv4");
  case_19920820: /* CIL Label */ 
#line 270
  return ("xenix");
  case_19911021: /* CIL Label */ 
#line 271
  return ("xiafs");
  switch_break: /* CIL Label */ ;
  }
#line 285
  return ((char const   *)0);
}
}
#line 288 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxfs.c"
int OS_file_directory_p(char const   *name ) 
{ 
  struct stat s ;
  int tmp ;
  int tmp___0 ;
  void *__cil_tmp5 ;

  {
  {
#line 292
  tmp = UX_read_file_status_indirect(name, & s);
  }
#line 292
  if (tmp) {
#line 292
    if ((s.st_mode & 61440U) == 16384U) {
#line 292
      tmp___0 = 1;
    } else {
#line 292
      tmp___0 = 0;
    }
  } else {
#line 292
    tmp___0 = 0;
  }
#line 292
  return (tmp___0);
}
}
#line 297 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxfs.c"
char const   *OS_file_soft_link_p(char const   *name ) 
{ 
  struct stat s ;
  int tmp ;
  int scr ;
  int buffer_length ;
  char *buffer___2 ;
  void *tmp___0 ;
  ssize_t tmp___1 ;
  void *tmp___2 ;
  void *__cil_tmp10 ;

  {
  {
#line 302
  tmp = UX_read_file_status(name, & s);
  }
#line 302
  if (tmp) {
#line 302
    if (! ((s.st_mode & 61440U) == 40960U)) {
#line 304
      return ((char const   *)0);
    }
  } else {
#line 304
    return ((char const   *)0);
  }
  {
#line 307
  buffer_length = 100;
#line 308
  tmp___0 = malloc((size_t )buffer_length);
#line 308
  buffer___2 = (char *)tmp___0;
  }
#line 309
  if ((unsigned long )buffer___2 == (unsigned long )((char *)0)) {
    {
#line 310
    error_system_call(12, (enum syscall_names )29);
    }
  }
  {
#line 311
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 313
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 313
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 313
        tmp___1 = readlink((char const   */* __restrict  */)name, (char */* __restrict  */)buffer___2,
                           (size_t )buffer_length);
#line 313
        scr = (int )tmp___1;
        }
#line 313
        if (! (scr < 0)) {
#line 313
          goto while_break___1;
        }
        {
#line 313
        UX_prim_check_errno((enum syscall_names )39);
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 313
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 315
    if (scr < buffer_length) {
#line 316
      goto while_break;
    }
    {
#line 317
    buffer_length *= 2;
#line 318
    tmp___2 = realloc((void *)buffer___2, (size_t )buffer_length);
#line 318
    buffer___2 = (char *)tmp___2;
    }
#line 319
    if ((unsigned long )buffer___2 == (unsigned long )((char *)0)) {
      {
#line 320
      error_system_call(12, (enum syscall_names )40);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 322
  *(buffer___2 + scr) = (char )'\000';
#line 323
  return ((char const   *)buffer___2);
}
}
#line 330 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxfs.c"
int OS_file_access(char const   *name , unsigned int mode ) 
{ 
  int tmp ;

  {
  {
#line 333
  tmp = access(name, (int )mode);
  }
#line 333
  return (tmp == 0);
}
}
#line 336 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxfs.c"
void OS_file_remove(char const   *name ) 
{ 
  int tmp ;

  {
  {
#line 339
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 339
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 339
      tmp = unlink(name);
      }
#line 339
      if (! (tmp < 0)) {
#line 339
        goto while_break___0;
      }
      {
#line 339
      UX_prim_check_errno((enum syscall_names )65);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 339
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 340
  return;
}
}
#line 342 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxfs.c"
void OS_file_remove_link(char const   *name ) 
{ 
  struct stat s ;
  int tmp ;
  void *__cil_tmp4 ;

  {
  {
#line 346
  tmp = UX_read_file_status(name, & s);
  }
#line 346
  if (tmp) {
#line 346
    if ((s.st_mode & 61440U) == 32768U) {
      {
#line 352
      unlink(name);
      }
    } else
#line 346
    if ((s.st_mode & 61440U) == 40960U) {
      {
#line 352
      unlink(name);
      }
    }
  }
#line 353
  return;
}
}
#line 355 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxfs.c"
void OS_file_link_hard(char const   *from_name , char const   *to_name ) 
{ 
  int tmp ;

  {
  {
#line 358
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 358
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 358
      tmp = link(from_name, to_name);
      }
#line 358
      if (! (tmp < 0)) {
#line 358
        goto while_break___0;
      }
      {
#line 358
      UX_prim_check_errno((enum syscall_names )24);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 358
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 359
  return;
}
}
#line 361 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxfs.c"
void OS_file_link_soft(char const   *from_name , char const   *to_name ) 
{ 
  int tmp ;

  {
  {
#line 365
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 365
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 365
      tmp = symlink(from_name, to_name);
      }
#line 365
      if (! (tmp < 0)) {
#line 365
        goto while_break___0;
      }
      {
#line 365
      UX_prim_check_errno((enum syscall_names )55);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 365
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 369
  return;
}
}
#line 371 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxfs.c"
void OS_file_rename(char const   *from_name , char const   *to_name ) 
{ 
  int tmp ;

  {
  {
#line 374
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 374
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 374
      tmp = rename(from_name, to_name);
      }
#line 374
      if (! (tmp < 0)) {
#line 374
        goto while_break___0;
      }
      {
#line 374
      UX_prim_check_errno((enum syscall_names )41);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 374
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 375
  return;
}
}
#line 381 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxfs.c"
void OS_file_copy(char const   *from_name , char const   *to_name ) 
{ 
  Tchannel src ;
  Tchannel dst ;
  off_t src_len ;
  off_t len ;
  char buffer___2[8192] ;
  long nread ;
  long nwrite ;
  int *tmp ;
  int *tmp___0 ;
  void *__cil_tmp12 ;

  {
  {
#line 389
  src = OS_open_input_file(from_name);
#line 390
  OS_channel_close_on_abort(src);
#line 391
  dst = OS_open_output_file(to_name);
#line 392
  OS_channel_close_on_abort(dst);
#line 393
  src_len = OS_file_length(src);
#line 394
  len = (off_t )sizeof(buffer___2);
  }
  {
#line 395
  while (1) {
    while_continue: /* CIL Label */ ;
#line 395
    if (! (src_len > 0L)) {
#line 395
      goto while_break;
    }
#line 397
    if (src_len < len) {
#line 398
      len = src_len;
    }
    {
#line 399
    nread = OS_channel_read(src, (void *)(buffer___2), (size_t )len);
    }
#line 400
    if (nread < 0L) {
      {
#line 401
      tmp = __errno_location();
#line 401
      error_system_call(*tmp, (enum syscall_names )38);
      }
    } else
#line 402
    if (nread == 0L) {
#line 403
      goto while_break;
    }
    {
#line 404
    nwrite = OS_channel_write(dst, (void const   *)(buffer___2), (size_t )nread);
    }
#line 405
    if (nwrite < 0L) {
      {
#line 406
      tmp___0 = __errno_location();
#line 406
      error_system_call(*tmp___0, (enum syscall_names )68);
      }
    } else
#line 407
    if (nwrite < nread) {
      {
#line 408
      error_system_call(28, (enum syscall_names )68);
      }
    }
#line 409
    src_len -= nread;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 411
  OS_channel_close(src);
#line 412
  OS_channel_close(dst);
  }
#line 413
  return;
}
}
#line 415 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxfs.c"
void OS_directory_make(char const   *name ) 
{ 
  int tmp ;

  {
  {
#line 418
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 418
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 418
      tmp = mkdir(name, (__mode_t )(((((((384 | (256 >> 3)) | (128 >> 3)) | ((256 >> 3) >> 3)) | ((128 >> 3) >> 3)) | 64) | (64 >> 3)) | ((64 >> 3) >> 3)));
      }
#line 418
      if (! (tmp < 0)) {
#line 418
        goto while_break___0;
      }
      {
#line 418
      UX_prim_check_errno((enum syscall_names )30);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 418
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 419
  return;
}
}
#line 421 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxfs.c"
void OS_directory_delete(char const   *name ) 
{ 
  int tmp ;

  {
  {
#line 424
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 424
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 424
      tmp = rmdir(name);
      }
#line 424
      if (! (tmp < 0)) {
#line 424
        goto while_break___0;
      }
      {
#line 424
      UX_prim_check_errno((enum syscall_names )42);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 424
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 425
  return;
}
}
#line 427
static void protect_fd(int fd ) ;
#line 429 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxfs.c"
int OS_file_touch(char const   *filename ) 
{ 
  int fd ;
  unsigned int count ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  struct stat file_status ;
  int tmp___3 ;
  char buf[1] ;
  ssize_t tmp___4 ;
  int tmp___5 ;
  char buf___0[1] ;
  int scr ;
  ssize_t tmp___6 ;
  __off_t tmp___7 ;
  ssize_t tmp___8 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;

  {
  {
#line 433
  transaction_begin();
#line 435
  count = 0U;
  }
  {
#line 436
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 438
    count ++;
#line 440
    fd = open(filename, 194, (((384 | (256 >> 3)) | (128 >> 3)) | ((256 >> 3) >> 3)) | ((128 >> 3) >> 3));
    }
#line 441
    if (fd >= 0) {
      {
#line 443
      protect_fd(fd);
#line 444
      transaction_commit();
      }
#line 445
      return (1);
    }
    {
#line 447
    tmp___1 = __errno_location();
    }
#line 447
    if (*tmp___1 == 17) {
      {
#line 449
      fd = open(filename, 2, (((384 | (256 >> 3)) | (128 >> 3)) | ((256 >> 3) >> 3)) | ((128 >> 3) >> 3));
      }
#line 450
      if (fd >= 0) {
        {
#line 452
        protect_fd(fd);
        }
#line 453
        goto while_break;
      } else {
        {
#line 455
        tmp = __errno_location();
        }
#line 455
        if (*tmp == 2) {
#line 460
          goto while_continue;
        } else {
          {
#line 455
          tmp___0 = __errno_location();
          }
#line 455
          if (*tmp___0 == 116) {
#line 460
            goto while_continue;
          }
        }
      }
    }
#line 462
    if (count >= 5U) {
      {
#line 463
      tmp___2 = __errno_location();
#line 463
      error_system_call(*tmp___2, (enum syscall_names )34);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 468
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 468
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 468
      tmp___3 = fstat(fd, & file_status);
      }
#line 468
      if (! (tmp___3 < 0)) {
#line 468
        goto while_break___1;
      }
      {
#line 468
      UX_prim_check_errno((enum syscall_names )12);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 468
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 469
  if ((file_status.st_mode & 61440U) != 32768U) {
#line 470
    return (-1);
  }
#line 472
  if (file_status.st_size == 0L) {
#line 475
    buf[0] = (char )'\000';
    {
#line 476
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 476
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 476
        tmp___4 = write(fd, (void const   *)(buf), (size_t )1);
        }
#line 476
        if (! (tmp___4 < 0L)) {
#line 476
          goto while_break___3;
        }
        {
#line 476
        UX_prim_check_errno((enum syscall_names )68);
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 476
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 478
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 478
      while (1) {
        while_continue___5: /* CIL Label */ ;
        {
#line 478
        tmp___5 = ftruncate(fd, (__off_t )0);
        }
#line 478
        if (! (tmp___5 < 0)) {
#line 478
          goto while_break___5;
        }
        {
#line 478
        UX_prim_check_errno((enum syscall_names )16);
        }
      }
      while_break___5: /* CIL Label */ ;
      }
#line 478
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 479
    transaction_commit();
    }
#line 487
    return (0);
  }
  {
#line 494
  while (1) {
    while_continue___6: /* CIL Label */ ;
    {
#line 494
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 494
      tmp___6 = read(fd, (void *)(buf___0), (size_t )1);
#line 494
      scr = (int )tmp___6;
      }
#line 494
      if (! (scr < 0)) {
#line 494
        goto while_break___7;
      }
      {
#line 494
      UX_prim_check_errno((enum syscall_names )38);
      }
    }
    while_break___7: /* CIL Label */ ;
    }
#line 494
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 495
  if (scr > 0) {
    {
#line 497
    while (1) {
      while_continue___8: /* CIL Label */ ;
      {
#line 497
      while (1) {
        while_continue___9: /* CIL Label */ ;
        {
#line 497
        tmp___7 = lseek(fd, (__off_t )0, 0);
        }
#line 497
        if (! (tmp___7 < 0L)) {
#line 497
          goto while_break___9;
        }
        {
#line 497
        UX_prim_check_errno((enum syscall_names )27);
        }
      }
      while_break___9: /* CIL Label */ ;
      }
#line 497
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 498
    while (1) {
      while_continue___10: /* CIL Label */ ;
      {
#line 498
      while (1) {
        while_continue___11: /* CIL Label */ ;
        {
#line 498
        tmp___8 = write(fd, (void const   *)(buf___0), (size_t )1);
        }
#line 498
        if (! (tmp___8 < 0L)) {
#line 498
          goto while_break___11;
        }
        {
#line 498
        UX_prim_check_errno((enum syscall_names )68);
        }
      }
      while_break___11: /* CIL Label */ ;
      }
#line 498
      goto while_break___10;
    }
    while_break___10: /* CIL Label */ ;
    }
  }
  {
#line 501
  transaction_commit();
  }
#line 502
  return (0);
}
}
#line 505 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxfs.c"
static void protect_fd_close(void *ap ) 
{ 


  {
  {
#line 508
  close(*((int *)ap));
  }
#line 509
  return;
}
}
#line 511 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxfs.c"
static void protect_fd(int fd ) 
{ 
  int *p ;
  void *tmp ;

  {
  {
#line 514
  tmp = dstack_alloc((unsigned int )sizeof(int ));
#line 514
  p = (int *)tmp;
#line 515
  *p = fd;
#line 516
  transaction_record_action((enum transaction_action_type )2, & protect_fd_close,
                            (void *)p);
  }
#line 517
  return;
}
}
#line 519 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxfs.c"
static DIR **directory_pointers  ;
#line 520 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxfs.c"
static unsigned int n_directory_pointers  ;
#line 522 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxfs.c"
static void close_all_directories(void) 
{ 
  DIR **scan ;
  DIR **end ;

  {
#line 525
  scan = directory_pointers;
#line 526
  end = scan + n_directory_pointers;
  {
#line 527
  while (1) {
    while_continue: /* CIL Label */ ;
#line 527
    if (! ((unsigned long )scan < (unsigned long )end)) {
#line 527
      goto while_break;
    }
#line 529
    if ((unsigned long )*scan != (unsigned long )((DIR *)0)) {
      {
#line 531
      closedir(*scan);
#line 532
      *scan = (DIR *)0;
      }
    }
#line 534
    scan ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 536
  directory_pointers = (DIR **)0;
#line 537
  n_directory_pointers = 0U;
#line 538
  return;
}
}
#line 540 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxfs.c"
void UX_initialize_directory_reader(void) 
{ 


  {
  {
#line 543
  directory_pointers = (DIR **)0;
#line 544
  n_directory_pointers = 0U;
#line 545
  add_reload_cleanup(& close_all_directories);
  }
#line 546
  return;
}
}
#line 548 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxfs.c"
static unsigned int allocate_directory_pointer(DIR *pointer ) 
{ 
  DIR **pointers ;
  void *tmp ;
  DIR **scan ;
  DIR **end ;
  DIR **tmp___0 ;
  DIR **tmp___1 ;
  DIR **scan___0 ;
  DIR **end___0 ;
  DIR **tmp___2 ;
  unsigned int result ;
  unsigned int n_pointers ;
  DIR **pointers___0 ;
  void *tmp___3 ;
  DIR **scan___1 ;
  DIR **end___1 ;
  DIR **tmp___4 ;
  DIR **tmp___5 ;

  {
#line 551
  if (n_directory_pointers == 0U) {
    {
#line 553
    tmp = malloc(sizeof(DIR *) * 4UL);
#line 553
    pointers = (DIR **)tmp;
    }
#line 554
    if ((unsigned long )pointers == (unsigned long )((DIR **)0)) {
      {
#line 555
      error_system_call(12, (enum syscall_names )29);
      }
    }
#line 556
    directory_pointers = pointers;
#line 557
    n_directory_pointers = 4U;
#line 559
    scan = directory_pointers;
#line 560
    end = scan + n_directory_pointers;
#line 561
    tmp___0 = scan;
#line 561
    scan ++;
#line 561
    *tmp___0 = pointer;
    {
#line 562
    while (1) {
      while_continue: /* CIL Label */ ;
#line 562
      if (! ((unsigned long )scan < (unsigned long )end)) {
#line 562
        goto while_break;
      }
#line 563
      tmp___1 = scan;
#line 563
      scan ++;
#line 563
      *tmp___1 = (DIR *)0;
    }
    while_break: /* CIL Label */ ;
    }
#line 565
    return (0U);
  }
#line 568
  scan___0 = directory_pointers;
#line 569
  end___0 = scan___0 + n_directory_pointers;
  {
#line 570
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 570
    if (! ((unsigned long )scan___0 < (unsigned long )end___0)) {
#line 570
      goto while_break___0;
    }
#line 571
    tmp___2 = scan___0;
#line 571
    scan___0 ++;
#line 571
    if ((unsigned long )*tmp___2 == (unsigned long )((DIR *)0)) {
#line 573
      scan___0 --;
#line 573
      *scan___0 = pointer;
#line 574
      return ((unsigned int )(scan___0 - directory_pointers));
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 578
  result = n_directory_pointers;
#line 579
  n_pointers = 2U * n_directory_pointers;
#line 580
  tmp___3 = realloc((void *)directory_pointers, sizeof(DIR *) * (unsigned long )n_pointers);
#line 580
  pointers___0 = (DIR **)tmp___3;
  }
#line 584
  if ((unsigned long )pointers___0 == (unsigned long )((DIR **)0)) {
    {
#line 585
    error_system_call(12, (enum syscall_names )40);
    }
  }
#line 587
  scan___1 = pointers___0 + result;
#line 588
  end___1 = pointers___0 + n_pointers;
#line 589
  tmp___4 = scan___1;
#line 589
  scan___1 ++;
#line 589
  *tmp___4 = pointer;
  {
#line 590
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 590
    if (! ((unsigned long )scan___1 < (unsigned long )end___1)) {
#line 590
      goto while_break___1;
    }
#line 591
    tmp___5 = scan___1;
#line 591
    scan___1 ++;
#line 591
    *tmp___5 = (DIR *)0;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 593
  directory_pointers = pointers___0;
#line 594
  n_directory_pointers = n_pointers;
#line 595
  return (result);
}
}
#line 602 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxfs.c"
int OS_directory_valid_p(unsigned int index___0 ) 
{ 
  int tmp ;

  {
#line 605
  if (index___0 < n_directory_pointers) {
#line 605
    if ((unsigned long )*(directory_pointers + index___0) != (unsigned long )((DIR *)0)) {
#line 605
      tmp = 1;
    } else {
#line 605
      tmp = 0;
    }
  } else {
#line 605
    tmp = 0;
  }
#line 605
  return (tmp);
}
}
#line 610 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxfs.c"
unsigned int OS_directory_open(char const   *name ) 
{ 
  DIR *pointer ;
  unsigned int tmp ;

  {
  {
#line 614
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 614
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 614
      pointer = opendir(name);
      }
#line 614
      if (! ((unsigned long )pointer == (unsigned long )((DIR *)0))) {
#line 614
        goto while_break___0;
      }
      {
#line 614
      UX_prim_check_errno((enum syscall_names )35);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 614
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 618
  tmp = allocate_directory_pointer(pointer);
  }
#line 618
  return (tmp);
}
}
#line 621 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxfs.c"
char const   *OS_directory_read(unsigned int index___0 ) 
{ 
  struct dirent *entry ;
  struct dirent *tmp ;
  char *tmp___0 ;

  {
  {
#line 624
  tmp = readdir(*(directory_pointers + index___0));
#line 624
  entry = tmp;
  }
#line 625
  if ((unsigned long )entry == (unsigned long )((struct dirent *)0)) {
#line 625
    tmp___0 = (char *)0;
  } else {
#line 625
    tmp___0 = entry->d_name;
  }
#line 625
  return ((char const   *)tmp___0);
}
}
#line 628 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxfs.c"
char const   *OS_directory_read_matching(unsigned int index___0 , char const   *prefix ) 
{ 
  DIR *pointer ;
  unsigned int n ;
  size_t tmp ;
  struct dirent *entry ;
  struct dirent *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 631
  pointer = *(directory_pointers + index___0);
#line 632
  tmp = strlen(prefix);
#line 632
  n = (unsigned int )tmp;
  }
  {
#line 633
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 635
    tmp___0 = readdir(pointer);
#line 635
    entry = tmp___0;
    }
#line 636
    if ((unsigned long )entry == (unsigned long )((struct dirent *)0)) {
#line 637
      return ((char const   *)0);
    }
    {
#line 638
    tmp___1 = strncmp(prefix, (char const   *)(entry->d_name), (size_t )n);
    }
#line 638
    if (tmp___1 == 0) {
#line 639
      return ((char const   *)(entry->d_name));
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 643 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxfs.c"
void OS_directory_close(unsigned int index___0 ) 
{ 


  {
  {
#line 646
  closedir(*(directory_pointers + index___0));
#line 647
  *(directory_pointers + index___0) = (DIR *)0;
  }
#line 648
  return;
}
}
#line 34 "/home/khheo/project/mit-scheme-9.2/src/microcode/osfile.h"
Tchannel OS_open_exclusive_output_file(char const   *filename ) ;
#line 35
Tchannel OS_open_io_file(char const   *filename ) ;
#line 36
Tchannel OS_open_append_file(char const   *filename ) ;
#line 37
Tchannel OS_open_load_file(char const   *filename ) ;
#line 38
Tchannel OS_open_dump_file(char const   *filename ) ;
#line 40
off_t OS_file_position(Tchannel channel ) ;
#line 41
void OS_file_set_position(Tchannel channel , off_t position___1 ) ;
#line 42
void OS_file_truncate(Tchannel channel , off_t length ) ;
#line 35 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxfile.c"
static enum channel_type fd_channel_type(int fd ) 
{ 
  struct stat stat_buf ;
  int tmp ;
  mode_t type ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  void *__cil_tmp13 ;

  {
  {
#line 39
  tmp = fstat(fd, & stat_buf);
  }
#line 39
  if (tmp < 0) {
#line 40
    return ((enum channel_type )0);
  }
#line 42
  type = stat_buf.st_mode & 61440U;
#line 43
  if (type == 32768U) {
#line 43
    tmp___7 = 1;
  } else {
#line 43
    if (type == 8192U) {
      {
#line 43
      tmp___2 = isatty(fd);
      }
#line 43
      if (tmp___2) {
#line 43
        tmp___1 = 4;
      } else {
#line 43
        tmp___1 = 10;
      }
#line 43
      tmp___6 = tmp___1;
    } else {
#line 43
      if (type == 4096U) {
#line 43
        tmp___5 = 3;
      } else {
#line 43
        if (type == 24576U) {
#line 43
          tmp___4 = 11;
        } else {
#line 43
          if (type == 16384U) {
#line 43
            tmp___3 = 9;
          } else {
#line 43
            tmp___3 = 0;
          }
#line 43
          tmp___4 = tmp___3;
        }
#line 43
        tmp___5 = tmp___4;
      }
#line 43
      tmp___6 = tmp___5;
    }
#line 43
    tmp___7 = tmp___6;
  }
#line 43
  return ((enum channel_type )tmp___7);
}
}
#line 60 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxfile.c"
Tchannel OS_open_fd(int fd ) 
{ 
  enum channel_type type ;
  enum channel_type tmp ;
  Tchannel channel ;
  Tchannel MAKE_CHANNEL_temp ;
  Tchannel tmp___0 ;

  {
  {
#line 63
  tmp = fd_channel_type(fd);
#line 63
  type = tmp;
#line 65
  tmp___0 = channel_allocate();
#line 65
  MAKE_CHANNEL_temp = tmp___0;
#line 65
  (channel_table + MAKE_CHANNEL_temp)->descriptor = fd;
#line 65
  (channel_table + MAKE_CHANNEL_temp)->type = type;
#line 65
  (channel_table + MAKE_CHANNEL_temp)->internal = 0U;
#line 65
  (channel_table + MAKE_CHANNEL_temp)->nonblocking = 0U;
#line 65
  channel = MAKE_CHANNEL_temp;
  }
#line 66
  if ((unsigned int )type == 4U) {
    {
#line 67
    terminal_open(channel);
    }
  }
#line 68
  return (channel);
}
}
#line 71 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxfile.c"
static Tchannel open_file(char const   *filename , int oflag ) 
{ 
  int fd ;
  Tchannel tmp ;

  {
  {
#line 75
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 75
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 75
      fd = open(filename, oflag, (((384 | (256 >> 3)) | (128 >> 3)) | ((256 >> 3) >> 3)) | ((128 >> 3) >> 3));
      }
#line 75
      if (! (fd < 0)) {
#line 75
        goto while_break___0;
      }
      {
#line 75
      UX_prim_check_fd_errno((enum syscall_names )34);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 75
    UX_out_of_files_p = (_Bool)0;
#line 75
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 85
  tmp = OS_open_fd(fd);
  }
#line 85
  return (tmp);
}
}
#line 95 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxfile.c"
Tchannel OS_open_input_file(char const   *filename ) 
{ 
  Tchannel tmp ;

  {
  {
#line 95
  tmp = open_file(filename, 0);
  }
#line 95
  return (tmp);
}
}
#line 96 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxfile.c"
Tchannel OS_open_output_file(char const   *filename ) 
{ 
  Tchannel tmp ;

  {
  {
#line 96
  tmp = open_file(filename, 577);
  }
#line 96
  return (tmp);
}
}
#line 97 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxfile.c"
Tchannel OS_open_exclusive_output_file(char const   *filename ) 
{ 
  Tchannel tmp ;

  {
  {
#line 97
  tmp = open_file(filename, 193);
  }
#line 97
  return (tmp);
}
}
#line 98 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxfile.c"
Tchannel OS_open_io_file(char const   *filename ) 
{ 
  Tchannel tmp ;

  {
  {
#line 98
  tmp = open_file(filename, 66);
  }
#line 98
  return (tmp);
}
}
#line 102 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxfile.c"
Tchannel OS_open_append_file(char const   *filename ) 
{ 
  Tchannel tmp ;

  {
  {
#line 102
  tmp = open_file(filename, 1089);
  }
#line 102
  return (tmp);
}
}
#line 115 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxfile.c"
static Tchannel make_load_channel(int fd ) 
{ 
  enum channel_type type ;
  enum channel_type tmp ;
  Tchannel MAKE_CHANNEL_temp ;
  Tchannel tmp___0 ;

  {
  {
#line 118
  tmp = fd_channel_type(fd);
#line 118
  type = tmp;
  }
#line 119
  if ((unsigned int )type == 4U) {
#line 122
    return ((Tchannel )-1);
  } else
#line 119
  if ((unsigned int )type == 9U) {
#line 122
    return ((Tchannel )-1);
  } else
#line 119
  if ((unsigned int )type == 0U) {
#line 122
    return ((Tchannel )-1);
  }
  {
#line 123
  tmp___0 = channel_allocate();
#line 123
  MAKE_CHANNEL_temp = tmp___0;
#line 123
  (channel_table + MAKE_CHANNEL_temp)->descriptor = fd;
#line 123
  (channel_table + MAKE_CHANNEL_temp)->type = type;
#line 123
  (channel_table + MAKE_CHANNEL_temp)->internal = 0U;
#line 123
  (channel_table + MAKE_CHANNEL_temp)->nonblocking = 0U;
  }
#line 123
  return (MAKE_CHANNEL_temp);
}
}
#line 126 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxfile.c"
Tchannel OS_open_load_file(char const   *filename ) 
{ 
  int fd ;
  int tmp ;
  Tchannel tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 129
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 131
    tmp = open(filename, 0, (((384 | (256 >> 3)) | (128 >> 3)) | ((256 >> 3) >> 3)) | ((128 >> 3) >> 3));
#line 131
    fd = tmp;
    }
#line 132
    if (fd >= 0) {
      {
#line 133
      tmp___0 = make_load_channel(fd);
      }
#line 133
      return (tmp___0);
    }
    {
#line 134
    tmp___1 = __errno_location();
    }
#line 134
    if (*tmp___1 != 4) {
#line 135
      return ((Tchannel )-1);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 139 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxfile.c"
Tchannel OS_open_dump_file(char const   *filename ) 
{ 
  int fd ;
  int tmp ;
  Tchannel tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 142
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 144
    tmp = open(filename, 577, (((384 | (256 >> 3)) | (128 >> 3)) | ((256 >> 3) >> 3)) | ((128 >> 3) >> 3));
#line 144
    fd = tmp;
    }
#line 145
    if (fd >= 0) {
      {
#line 146
      tmp___0 = make_load_channel(fd);
      }
#line 146
      return (tmp___0);
    }
    {
#line 147
    tmp___1 = __errno_location();
    }
#line 147
    if (*tmp___1 != 4) {
#line 148
      return ((Tchannel )-1);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 152 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxfile.c"
off_t OS_file_length(Tchannel channel ) 
{ 
  struct stat stat_buf ;
  int tmp ;
  void *__cil_tmp4 ;

  {
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 156
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 156
      tmp = fstat((channel_table + channel)->descriptor, & stat_buf);
      }
#line 156
      if (! (tmp < 0)) {
#line 156
        goto while_break___0;
      }
      {
#line 156
      UX_prim_check_errno((enum syscall_names )12);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 156
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 158
  return (stat_buf.st_size);
}
}
#line 161 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxfile.c"
off_t OS_file_position(Tchannel channel ) 
{ 
  off_t result ;

  {
  {
#line 165
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 165
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 165
      result = lseek((channel_table + channel)->descriptor, 0L, 1);
      }
#line 165
      if (! (result < 0L)) {
#line 165
        goto while_break___0;
      }
      {
#line 165
      UX_prim_check_errno((enum syscall_names )27);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 165
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 169
  return (result);
}
}
#line 172 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxfile.c"
void OS_file_set_position(Tchannel channel , off_t position___1 ) 
{ 
  off_t result ;

  {
  {
#line 176
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 176
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 176
      result = lseek((channel_table + channel)->descriptor, position___1, 0);
      }
#line 176
      if (! (result < 0L)) {
#line 176
        goto while_break___0;
      }
      {
#line 176
      UX_prim_check_errno((enum syscall_names )27);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 176
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 180
  if (result != position___1) {
    {
#line 181
    error_external_return();
    }
  }
#line 182
  return;
}
}
#line 184 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxfile.c"
void OS_file_truncate(Tchannel channel , off_t length ) 
{ 
  int tmp ;

  {
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 187
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 187
      tmp = ftruncate((channel_table + channel)->descriptor, length);
      }
#line 187
      if (! (tmp < 0)) {
#line 187
        goto while_break___0;
      }
      {
#line 187
      UX_prim_check_errno((enum syscall_names )16);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 187
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 190
  return;
}
}
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 131
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setitimer)(__itimer_which_t __which ,
                                                                                struct itimerval  const  * __restrict  __new ,
                                                                                struct itimerval * __restrict  __old ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 199
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) mktime)(struct tm *__tp ) ;
#line 239
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) gmtime)(time_t const   *__timer ) ;
#line 243
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 110 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 116
extern struct passwd *getpwnam(char const   *__name ) ;
#line 48 "/usr/include/x86_64-linux-gnu/sys/times.h"
extern  __attribute__((__nothrow__)) clock_t ( __attribute__((__leaf__)) times)(struct tms *__buffer ) ;
#line 511 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) getcwd)(char *__buf ,
                                                                               size_t __size ) ;
#line 675
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 678
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) geteuid)(void) ;
#line 849
extern char *getlogin(void) ;
#line 67 "/usr/include/x86_64-linux-gnu/sys/timex.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ntp_adjtime)(struct timex *__tntx ) ;
#line 888 "/home/khheo/project/mit-scheme-9.2/src/microcode/ux.h"
clock_t UX_SC_CLK_TCK(void) ;
#line 61 "/home/khheo/project/mit-scheme-9.2/src/microcode/osenv.h"
void OS_nanotime_since_utc_epoch(struct scheme_nanotime *t ) ;
#line 62
time_t OS_encoded_time(void) ;
#line 63
void OS_decode_time(time_t t , struct time_structure *buffer___2 ) ;
#line 64
void OS_decode_utc(time_t t , struct time_structure *buffer___2 ) ;
#line 65
time_t OS_encode_time(struct time_structure *buffer___2 ) ;
#line 66
double OS_process_clock(void) ;
#line 67
double OS_real_time_clock(void) ;
#line 68
void OS_process_timer_set(clock_t first , clock_t interval ) ;
#line 69
void OS_process_timer_clear(void) ;
#line 70
void OS_profile_timer_set(clock_t first , clock_t interval ) ;
#line 71
void OS_profile_timer_clear(void) ;
#line 72
void OS_real_timer_set(clock_t first , clock_t interval ) ;
#line 73
void OS_real_timer_clear(void) ;
#line 74
char const   *OS_working_dir_pathname(void) ;
#line 75
void OS_set_working_dir_pathname(char const   *name ) ;
#line 114 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxenv.c"
static intmax_t utc_epoch_minus_unix_epoch  =    63072000L;
#line 116 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxenv.c"
static long guess_n_leap_seconds(long tai ) 
{ 
  long tmp ;

  {
#line 119
  if (tai < 10L) {
#line 119
    tmp = tai;
  } else {
#line 119
    tmp = tai - 10L;
  }
#line 119
  return (tmp);
}
}
#line 122 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxenv.c"
static intmax_t guess_time_from_posix(intmax_t posix , long tai ) 
{ 
  long tmp ;

  {
  {
#line 133
  tmp = guess_n_leap_seconds(tai);
  }
#line 133
  return ((posix - utc_epoch_minus_unix_epoch) + tmp);
}
}
#line 170 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxenv.c"
static struct timex  const  zero_tx  ;
#line 167 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxenv.c"
void OS_nanotime_since_utc_epoch(struct scheme_nanotime *t ) 
{ 
  struct timex tx ;
  int tmp ;
  unsigned long tmp___0 ;

  {
#line 171
  tx = zero_tx;
  {
#line 176
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 176
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 176
      tmp = ntp_adjtime(& tx);
      }
#line 176
      if (! (tmp < 0)) {
#line 176
        goto while_break___0;
      }
      {
#line 176
      UX_prim_check_errno((enum syscall_names )32);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 176
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 177
  t->seconds = guess_time_from_posix(tx.time.tv_sec, (long )tx.tai);
  }
#line 179
  if (tx.time.tv_usec < 0L) {
#line 179
    t->nanoseconds = (uint32_t )0;
  } else {
#line 179
    if ((uintmax_t )tx.time.tv_usec < 1000000UL) {
#line 179
      tmp___0 = 1000UL * (unsigned long )((uint32_t )tx.time.tv_usec);
    } else {
#line 179
      tmp___0 = 999999UL;
    }
#line 179
    t->nanoseconds = (uint32_t )tmp___0;
  }
#line 180
  return;
}
}
#line 218 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxenv.c"
time_t OS_encoded_time(void) 
{ 
  time_t t ;

  {
  {
#line 222
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 222
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 222
      t = time((time_t *)0);
      }
#line 222
      if (! (t < 0L)) {
#line 222
        goto while_break___0;
      }
      {
#line 222
      UX_prim_check_errno((enum syscall_names )63);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 222
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 223
  return (t);
}
}
#line 226 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxenv.c"
void OS_decode_time(time_t t , struct time_structure *buffer___2 ) 
{ 
  struct tm *ts ;
  int wday ;

  {
  {
#line 230
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 230
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 230
      ts = localtime((time_t const   *)(& t));
      }
#line 230
      if (! ((unsigned long )ts == (unsigned long )((struct tm *)0))) {
#line 230
        goto while_break___0;
      }
      {
#line 230
      UX_prim_check_errno((enum syscall_names )26);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 230
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 231
  buffer___2->year = (unsigned int )(ts->tm_year + 1900);
#line 232
  buffer___2->month = (unsigned int )(ts->tm_mon + 1);
#line 233
  buffer___2->day = (unsigned int )ts->tm_mday;
#line 234
  buffer___2->hour = (unsigned int )ts->tm_hour;
#line 235
  buffer___2->minute = (unsigned int )ts->tm_min;
#line 236
  buffer___2->second = (unsigned int )ts->tm_sec;
#line 237
  buffer___2->daylight_savings_time = ts->tm_isdst;
#line 240
  buffer___2->time_zone = (int )(- ts->tm_gmtoff);
#line 241
  if (ts->tm_isdst > 0) {
#line 242
    buffer___2->time_zone += 3600;
  }
#line 252
  wday = ts->tm_wday;
#line 253
  if (wday == 0) {
#line 253
    buffer___2->day_of_week = 6U;
  } else {
#line 253
    buffer___2->day_of_week = (unsigned int )(wday - 1);
  }
#line 255
  return;
}
}
#line 257 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxenv.c"
void OS_decode_utc(time_t t , struct time_structure *buffer___2 ) 
{ 
  struct tm *ts ;
  int wday ;

  {
  {
#line 261
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 261
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 261
      ts = gmtime((time_t const   *)(& t));
      }
#line 261
      if (! ((unsigned long )ts == (unsigned long )((struct tm *)0))) {
#line 261
        goto while_break___0;
      }
      {
#line 261
      UX_prim_check_errno((enum syscall_names )20);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 261
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 262
  buffer___2->year = (unsigned int )(ts->tm_year + 1900);
#line 263
  buffer___2->month = (unsigned int )(ts->tm_mon + 1);
#line 264
  buffer___2->day = (unsigned int )ts->tm_mday;
#line 265
  buffer___2->hour = (unsigned int )ts->tm_hour;
#line 266
  buffer___2->minute = (unsigned int )ts->tm_min;
#line 267
  buffer___2->second = (unsigned int )ts->tm_sec;
#line 268
  buffer___2->daylight_savings_time = 0;
#line 269
  buffer___2->time_zone = 0;
#line 272
  wday = ts->tm_wday;
#line 273
  if (wday == 0) {
#line 273
    buffer___2->day_of_week = 6U;
  } else {
#line 273
    buffer___2->day_of_week = (unsigned int )(wday - 1);
  }
#line 275
  return;
}
}
#line 277 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxenv.c"
time_t OS_encode_time(struct time_structure *buffer___2 ) 
{ 
  time_t t ;
  struct tm ts ;
  long assumed_zone ;

  {
#line 281
  t = (time_t )0;
#line 283
  ts.tm_year = (int )(buffer___2->year - 1900U);
#line 284
  ts.tm_mon = (int )(buffer___2->month - 1U);
#line 285
  ts.tm_mday = (int )buffer___2->day;
#line 286
  ts.tm_hour = (int )buffer___2->hour;
#line 287
  ts.tm_min = (int )buffer___2->minute;
#line 288
  ts.tm_sec = (int )buffer___2->second;
#line 289
  ts.tm_isdst = buffer___2->daylight_savings_time;
  {
#line 290
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 290
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 290
      t = mktime(& ts);
      }
#line 290
      if (! (t < 0L)) {
#line 290
        goto while_break___0;
      }
      {
#line 290
      UX_prim_check_errno((enum syscall_names )31);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 290
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 296
  if (buffer___2->time_zone != 2147483647) {
#line 298
    assumed_zone = - ts.tm_gmtoff;
#line 299
    if (ts.tm_isdst > 0) {
#line 300
      assumed_zone += 3600L;
    }
#line 301
    if ((long )buffer___2->time_zone != assumed_zone) {
#line 302
      t = (t - assumed_zone) + (time_t )buffer___2->time_zone;
    }
  }
#line 313
  return (t);
}
}
#line 321 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxenv.c"
static void initialize_timezone(void) 
{ 


  {
#line 327
  return;
}
}
#line 331 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxenv.c"
static clock_t initial_process_clock  ;
#line 342 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxenv.c"
static void initialize_process_clock(void) 
{ 
  struct tms buffer___2 ;
  int *tmp ;
  clock_t tmp___0 ;

  {
  {
#line 346
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 346
    tmp___0 = times(& buffer___2);
    }
#line 346
    if (! (tmp___0 == -1L)) {
#line 346
      goto while_break;
    }
    {
#line 347
    tmp = __errno_location();
    }
#line 347
    if (*tmp != 4) {
#line 349
      initial_process_clock = (clock_t )0;
#line 350
      return;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 352
  initial_process_clock = buffer___2.tms_utime + buffer___2.tms_stime;
#line 353
  return;
}
}
#line 355 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxenv.c"
double OS_process_clock(void) 
{ 
  double ct ;
  clock_t tmp ;
  struct tms buffer___2 ;
  clock_t t ;
  int *tmp___0 ;
  clock_t tmp___1 ;

  {
  {
#line 358
  tmp = UX_SC_CLK_TCK();
#line 358
  ct = (double )tmp;
  }
  {
#line 364
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 364
    tmp___1 = times(& buffer___2);
    }
#line 364
    if (! (tmp___1 == -1L)) {
#line 364
      goto while_break;
    }
    {
#line 365
    tmp___0 = __errno_location();
    }
#line 365
    if (*tmp___0 == 4) {
      {
#line 366
      deliver_pending_interrupts();
      }
    } else {
#line 369
      t = initial_process_clock;
#line 370
      goto finish;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 372
  t = buffer___2.tms_utime + buffer___2.tms_stime;
  finish: 
#line 374
  return (((double )(t - initial_process_clock) * 2000.0 + ct) / (2.0 * ct));
}
}
#line 398 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxenv.c"
static struct timeval initial_rtc  ;
#line 400 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxenv.c"
static void initialize_real_time_clock(void) 
{ 
  struct timezone tz ;
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 404
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 404
    tmp___0 = gettimeofday((struct timeval */* __restrict  */)(& initial_rtc), (__timezone_ptr_t )(& tz));
    }
#line 404
    if (! (tmp___0 == -1)) {
#line 404
      goto while_break;
    }
    {
#line 405
    tmp = __errno_location();
    }
#line 405
    if (*tmp != 4) {
#line 407
      initial_rtc.tv_sec = (__time_t )0;
#line 408
      initial_rtc.tv_usec = (__suseconds_t )0;
#line 409
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 411
  return;
}
}
#line 413 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxenv.c"
double OS_real_time_clock(void) 
{ 
  struct timeval rtc ;
  struct timezone tz ;
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 418
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 418
    tmp___0 = gettimeofday((struct timeval */* __restrict  */)(& rtc), (__timezone_ptr_t )(& tz));
    }
#line 418
    if (! (tmp___0 == -1)) {
#line 418
      goto while_break;
    }
    {
#line 419
    tmp = __errno_location();
    }
#line 419
    if (*tmp == 4) {
      {
#line 420
      deliver_pending_interrupts();
      }
    } else {
#line 423
      rtc = initial_rtc;
#line 424
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 426
  return ((double )(rtc.tv_sec - initial_rtc.tv_sec) * 1000.0 + ((double )(rtc.tv_usec - initial_rtc.tv_usec) + 500.0) / 1000.0);
}
}
#line 504 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxenv.c"
static void set_timer(int which , clock_t first , clock_t interval ) 
{ 
  struct itimerval value ;
  struct itimerval ovalue ;
  int tmp ;

  {
#line 511
  value.it_value.tv_sec = first / 1000L;
#line 512
  value.it_value.tv_usec = (first % 1000L) * 1000L;
#line 513
  value.it_interval.tv_sec = interval / 1000L;
#line 514
  value.it_interval.tv_usec = (interval % 1000L) * 1000L;
  {
#line 515
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 515
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 515
      tmp = setitimer((__itimer_which_t )which, (struct itimerval  const  */* __restrict  */)(& value),
                      (struct itimerval */* __restrict  */)(& ovalue));
      }
#line 515
      if (! (tmp < 0)) {
#line 515
        goto while_break___0;
      }
      {
#line 515
      UX_prim_check_errno((enum syscall_names )44);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 515
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 517
  return;
}
}
#line 519 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxenv.c"
void OS_process_timer_set(clock_t first , clock_t interval ) 
{ 


  {
  {
#line 523
  set_timer(1, first, interval);
  }
#line 524
  return;
}
}
#line 526 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxenv.c"
void OS_process_timer_clear(void) 
{ 


  {
  {
#line 529
  set_timer(1, (clock_t )0, (clock_t )0);
  }
#line 530
  return;
}
}
#line 532 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxenv.c"
void OS_profile_timer_set(clock_t first , clock_t interval ) 
{ 


  {
  {
#line 536
  set_timer(2, first, interval);
  }
#line 537
  return;
}
}
#line 539 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxenv.c"
void OS_profile_timer_clear(void) 
{ 


  {
  {
#line 542
  set_timer(2, (clock_t )0, (clock_t )0);
  }
#line 543
  return;
}
}
#line 545 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxenv.c"
void OS_real_timer_set(clock_t first , clock_t interval ) 
{ 


  {
  {
#line 549
  set_timer(0, first, interval);
  }
#line 550
  return;
}
}
#line 552 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxenv.c"
void OS_real_timer_clear(void) 
{ 


  {
  {
#line 555
  set_timer(0, (clock_t )0, (clock_t )0);
  }
#line 556
  return;
}
}
#line 611 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxenv.c"
void UX_initialize_environment(void) 
{ 


  {
  {
#line 614
  initialize_timezone();
#line 615
  initialize_process_clock();
#line 616
  initialize_real_time_clock();
  }
#line 620
  return;
}
}
#line 622 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxenv.c"
static size_t current_dir_path_size  =    (size_t )0;
#line 623 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxenv.c"
static char *current_dir_path  =    (char *)0;
#line 625 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxenv.c"
char const   *OS_working_dir_pathname(void) 
{ 
  void *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  char *new_current_dir_path ;
  void *tmp___3 ;

  {
#line 628
  if (current_dir_path) {
#line 629
    return ((char const   *)current_dir_path);
  }
#line 631
  if (current_dir_path_size == 0UL) {
    {
#line 633
    tmp = malloc((size_t )1024);
#line 633
    current_dir_path = (char *)tmp;
    }
#line 634
    if ((unsigned long )current_dir_path == (unsigned long )((char *)0)) {
      {
#line 635
      error_system_call(12, (enum syscall_names )29);
      }
    }
#line 636
    current_dir_path_size = (size_t )1024;
  }
  {
#line 638
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 640
    tmp___0 = getcwd(current_dir_path, current_dir_path_size);
    }
#line 640
    if ((unsigned long )tmp___0 != (unsigned long )((char *)0)) {
#line 641
      return ((char const   *)current_dir_path);
    }
    {
#line 642
    tmp___2 = __errno_location();
    }
#line 642
    if (*tmp___2 != 34) {
      {
#line 643
      tmp___1 = __errno_location();
#line 643
      error_system_call(*tmp___1, (enum syscall_names )17);
      }
    }
    {
#line 644
    current_dir_path_size *= 2UL;
#line 646
    tmp___3 = realloc((void *)current_dir_path, current_dir_path_size);
#line 646
    new_current_dir_path = (char *)tmp___3;
    }
#line 648
    if ((unsigned long )new_current_dir_path == (unsigned long )((char *)0)) {
      {
#line 651
      error_system_call(12, (enum syscall_names )40);
      }
    }
#line 652
    current_dir_path = new_current_dir_path;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 657 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxenv.c"
void OS_set_working_dir_pathname(char const   *name ) 
{ 
  size_t name_size ;
  size_t tmp ;
  int tmp___0 ;
  char *new_current_dir_path ;
  void *tmp___1 ;

  {
  {
#line 660
  tmp = strlen(name);
#line 660
  name_size = tmp;
  }
  {
#line 661
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 661
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 661
      tmp___0 = chdir(name);
      }
#line 661
      if (! (tmp___0 < 0)) {
#line 661
        goto while_break___0;
      }
      {
#line 661
      UX_prim_check_errno((enum syscall_names )2);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 661
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 662
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 663
    if (name_size < current_dir_path_size) {
      {
#line 664
      strcpy((char */* __restrict  */)current_dir_path, (char const   */* __restrict  */)name);
      }
#line 665
      return;
    }
    {
#line 667
    current_dir_path_size *= 2UL;
#line 669
    tmp___1 = realloc((void *)current_dir_path, current_dir_path_size);
#line 669
    new_current_dir_path = (char *)tmp___1;
    }
#line 671
    if ((unsigned long )new_current_dir_path == (unsigned long )((char *)0)) {
      {
#line 672
      error_system_call(12, (enum syscall_names )40);
      }
    }
#line 673
    current_dir_path = new_current_dir_path;
  }
  while_break___1: /* CIL Label */ ;
  }
}
}
#line 678 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxenv.c"
char const   *OS_current_user_name(void) 
{ 
  char const   *result ;
  char *tmp ;
  struct passwd *entry ;
  __uid_t tmp___0 ;
  struct passwd *tmp___1 ;

  {
  {
#line 682
  tmp = getlogin();
#line 682
  result = (char const   *)tmp;
  }
#line 683
  if ((unsigned long )result != (unsigned long )((char const   *)0)) {
#line 683
    if ((int const   )*result != 0) {
#line 684
      return (result);
    }
  }
  {
#line 687
  tmp___0 = geteuid();
#line 687
  tmp___1 = getpwuid(tmp___0);
#line 687
  entry = tmp___1;
  }
#line 688
  if ((unsigned long )entry != (unsigned long )((struct passwd *)0)) {
#line 689
    return ((char const   *)entry->pw_name);
  }
  {
#line 691
  error_external_return();
  }
#line 692
  return ((char const   *)0);
}
}
#line 695 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxenv.c"
char const   *OS_current_user_home_directory(void) 
{ 
  char *user_name ;
  char *tmp ;
  struct passwd *entry ;
  struct passwd *tmp___0 ;
  struct passwd *entry___0 ;
  __uid_t tmp___1 ;
  struct passwd *tmp___2 ;

  {
  {
#line 699
  tmp = getlogin();
#line 699
  user_name = tmp;
  }
#line 700
  if ((unsigned long )user_name != (unsigned long )((char *)0)) {
    {
#line 702
    tmp___0 = getpwnam((char const   *)user_name);
#line 702
    entry = tmp___0;
    }
#line 703
    if ((unsigned long )entry != (unsigned long )((struct passwd *)0)) {
#line 704
      return ((char const   *)entry->pw_dir);
    }
  }
  {
#line 708
  tmp___1 = getuid();
#line 708
  tmp___2 = getpwuid(tmp___1);
#line 708
  entry___0 = tmp___2;
  }
#line 709
  if ((unsigned long )entry___0 != (unsigned long )((struct passwd *)0)) {
#line 710
    return ((char const   *)entry___0->pw_dir);
  }
  {
#line 712
  error_external_return();
  }
#line 713
  return ((char const   *)0);
}
}
#line 885 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) ctermid)(char *__s ) ;
#line 37 "/home/khheo/project/mit-scheme-9.2/src/microcode/osctty.h"
void OS_ctty_get_interrupt_enables(Tinterrupt_enables *mask ) ;
#line 38
void OS_ctty_set_interrupt_enables(Tinterrupt_enables *mask ) ;
#line 40
unsigned int OS_ctty_num_int_chars(void) ;
#line 41
cc_t *OS_ctty_get_int_chars(void) ;
#line 42
cc_t *OS_ctty_get_int_char_handlers(void) ;
#line 43
void OS_ctty_set_int_chars(cc_t *int_chars___0 ) ;
#line 44
void OS_ctty_set_int_char_handlers(cc_t *int_handlers___0 ) ;
#line 36 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxctty.c"
static int ctty_fildes  ;
#line 46 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxctty.c"
int scheme_in_foreground  ;
#line 50 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxctty.c"
static int permit_ctty_control  ;
#line 65 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxctty.c"
static struct terminal_state_recording outside_ctty_state  ;
#line 66 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxctty.c"
static struct terminal_state_recording outside_stdin_state  ;
#line 67 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxctty.c"
static struct terminal_state_recording outside_stdout_state  ;
#line 68 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxctty.c"
static struct terminal_state_recording inside_ctty_state  ;
#line 69 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxctty.c"
static struct terminal_state_recording inside_stdin_state  ;
#line 70 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxctty.c"
static struct terminal_state_recording inside_stdout_state  ;
#line 72
static void ctty_update_interrupt_chars(void) ;
#line 74 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxctty.c"
static int get_terminal_state___0(int fd , Ttty_state *s ) 
{ 
  int scr ;
  int tmp ;
  int *tmp___0 ;

  {
  {
#line 77
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 79
    tmp = UX_terminal_get_state(fd, s);
#line 79
    scr = tmp;
    }
#line 80
    if (scr >= 0) {
#line 81
      return (scr);
    } else {
      {
#line 80
      tmp___0 = __errno_location();
      }
#line 80
      if (*tmp___0 != 4) {
#line 81
        return (scr);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 85 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxctty.c"
static int set_terminal_state___0(int fd , Ttty_state *s ) 
{ 
  int scr ;
  int tmp ;
  int *tmp___0 ;

  {
  {
#line 88
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 90
    tmp = UX_terminal_set_state(fd, s);
#line 90
    scr = tmp;
    }
#line 91
    if (scr >= 0) {
#line 92
      return (scr);
    } else {
      {
#line 91
      tmp___0 = __errno_location();
      }
#line 91
      if (*tmp___0 != 4) {
#line 92
        return (scr);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 97 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxctty.c"
static int get_flags___0(int fd , int *flags ) 
{ 
  int scr ;
  int tmp ;
  int *tmp___0 ;

  {
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 103
    tmp = fcntl(fd, 3, 0);
#line 103
    scr = tmp;
    }
#line 104
    if (scr >= 0) {
#line 106
      *flags = scr;
#line 107
      return (0);
    }
    {
#line 109
    tmp___0 = __errno_location();
    }
#line 109
    if (*tmp___0 != 4) {
#line 110
      return (-1);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 117 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxctty.c"
static int set_flags___0(int fd , int *flags ) 
{ 
  int scr ;
  int tmp ;
  int *tmp___0 ;

  {
  {
#line 121
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 123
    tmp = fcntl(fd, 4, *flags);
#line 123
    scr = tmp;
    }
#line 124
    if (scr >= 0) {
#line 125
      return (scr);
    } else {
      {
#line 124
      tmp___0 = __errno_location();
      }
#line 124
      if (*tmp___0 != 4) {
#line 125
        return (scr);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 132 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxctty.c"
static void save_external_state(struct terminal_state_recording *s ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 135
  if (scheme_in_foreground) {
    {
#line 135
    tmp = isatty(s->fd);
    }
#line 135
    if (tmp) {
      {
#line 135
      tmp___0 = get_terminal_state___0(s->fd, & s->state);
      }
#line 135
      if (tmp___0 >= 0) {
        {
#line 135
        tmp___1 = get_flags___0(s->fd, & s->flags);
        }
#line 135
        if (tmp___1 >= 0) {
#line 135
          tmp___2 = 1;
        } else {
#line 135
          tmp___2 = 0;
        }
      } else {
#line 135
        tmp___2 = 0;
      }
    } else {
#line 135
      tmp___2 = 0;
    }
  } else {
#line 135
    tmp___2 = 0;
  }
#line 135
  s->recorded_p = tmp___2;
#line 140
  return;
}
}
#line 142 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxctty.c"
static void restore_external_state(struct terminal_state_recording *s ) 
{ 


  {
#line 145
  if (s->recorded_p) {
    {
#line 147
    set_terminal_state___0(s->fd, & s->state);
#line 148
    set_flags___0(s->fd, & s->flags);
#line 149
    s->recorded_p = 0;
    }
  }
#line 151
  return;
}
}
#line 153 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxctty.c"
void save_internal_state(struct terminal_state_recording *s , struct terminal_state_recording *es ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 160
  if (es->recorded_p) {
    {
#line 161
    tmp = get_terminal_state___0(s->fd, & s->state);
    }
#line 161
    if (tmp >= 0) {
      {
#line 161
      tmp___0 = get_flags___0(s->fd, & s->flags);
      }
#line 161
      if (tmp___0 >= 0) {
#line 161
        tmp___1 = 1;
      } else {
#line 161
        tmp___1 = 0;
      }
    } else {
#line 161
      tmp___1 = 0;
    }
#line 161
    s->recorded_p = tmp___1;
  }
#line 164
  return;
}
}
#line 166 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxctty.c"
static void restore_internal_state(struct terminal_state_recording *s , struct terminal_state_recording *es ) 
{ 


  {
#line 181
  if (s->recorded_p) {
#line 183
    if (es->recorded_p) {
      {
#line 185
      set_terminal_state___0(s->fd, & s->state);
#line 186
      set_flags___0(s->fd, & s->flags);
      }
    }
#line 188
    s->recorded_p = 0;
  }
#line 190
  return;
}
}
#line 192 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxctty.c"
void UX_ctty_save_external_state(void) 
{ 
  pid_t pgrp_id ;
  __pid_t tmp ;
  int *tmp___0 ;
  __pid_t tmp___1 ;

  {
#line 195
  if (permit_ctty_control) {
#line 195
    if (ctty_fildes >= 0) {
      {
#line 197
      tmp = tcgetpgrp(ctty_fildes);
#line 197
      pgrp_id = tmp;
      }
#line 198
      if (pgrp_id < 0) {
        {
#line 198
        tmp___0 = __errno_location();
#line 198
        scheme_in_foreground = *tmp___0 == 38;
        }
      } else {
        {
#line 198
        tmp___1 = getpgrp();
#line 198
        scheme_in_foreground = tmp___1 == pgrp_id;
        }
      }
    } else {
#line 205
      scheme_in_foreground = 0;
    }
  } else {
#line 205
    scheme_in_foreground = 0;
  }
  {
#line 206
  save_external_state(& outside_ctty_state);
#line 207
  save_external_state(& outside_stdin_state);
#line 208
  save_external_state(& outside_stdout_state);
  }
#line 209
  return;
}
}
#line 211 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxctty.c"
void UX_ctty_restore_external_state(void) 
{ 


  {
  {
#line 214
  restore_external_state(& outside_ctty_state);
#line 215
  restore_external_state(& outside_stdin_state);
#line 216
  restore_external_state(& outside_stdout_state);
  }
#line 217
  return;
}
}
#line 219 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxctty.c"
void UX_ctty_save_internal_state(void) 
{ 


  {
  {
#line 222
  save_internal_state(& inside_ctty_state, & outside_ctty_state);
#line 223
  save_internal_state(& inside_stdin_state, & outside_stdin_state);
#line 224
  save_internal_state(& inside_stdout_state, & outside_stdout_state);
  }
#line 225
  return;
}
}
#line 227 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxctty.c"
void UX_ctty_restore_internal_state(void) 
{ 
  int do_update ;
  int tmp ;

  {
#line 230
  if (inside_ctty_state.recorded_p) {
#line 230
    if (outside_ctty_state.recorded_p) {
#line 230
      tmp = 1;
    } else {
#line 230
      tmp = 0;
    }
  } else {
#line 230
    tmp = 0;
  }
  {
#line 230
  do_update = tmp;
#line 233
  restore_internal_state(& inside_ctty_state, & outside_ctty_state);
#line 234
  restore_internal_state(& inside_stdin_state, & outside_stdin_state);
#line 235
  restore_internal_state(& inside_stdout_state, & outside_stdout_state);
  }
#line 236
  if (do_update) {
    {
#line 237
    ctty_update_interrupt_chars();
    }
  }
#line 238
  return;
}
}
#line 240 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxctty.c"
int OS_ctty_interrupt_control(void) 
{ 


  {
#line 243
  return (outside_ctty_state.recorded_p);
}
}
#line 246 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxctty.c"
int UX_terminal_control_ok(int fd ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 249
  if (fd == 0) {
#line 249
    tmp___0 = outside_stdin_state.recorded_p;
  } else {
#line 249
    if (fd == 1) {
#line 249
      tmp = outside_stdout_state.recorded_p;
    } else {
#line 249
      tmp = 1;
    }
#line 249
    tmp___0 = tmp;
  }
#line 249
  return (tmp___0);
}
}
#line 267 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxctty.c"
static Tinterrupt_enables current_interrupt_enables  ;
#line 268 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxctty.c"
static Tinterrupt_chars current_interrupt_chars  ;
#line 279 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxctty.c"
cc_t OS_ctty_quit_char(void) 
{ 


  {
#line 282
  return (current_interrupt_chars.quit);
}
}
#line 285 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxctty.c"
cc_t OS_ctty_int_char(void) 
{ 


  {
#line 288
  return (current_interrupt_chars.intrpt);
}
}
#line 291 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxctty.c"
cc_t OS_ctty_tstp_char(void) 
{ 


  {
#line 294
  return (current_interrupt_chars.tstp);
}
}
#line 297 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxctty.c"
cc_t OS_ctty_disabled_char(void) 
{ 
  cc_t tmp ;
  int tmp___0 ;

  {
#line 300
  if (ctty_fildes >= 0) {
    {
#line 300
    tmp = UX_PC_VDISABLE(ctty_fildes);
#line 300
    tmp___0 = (int )tmp;
    }
  } else {
#line 300
    tmp___0 = '\377';
  }
#line 300
  return ((cc_t )tmp___0);
}
}
#line 303 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxctty.c"
int OS_ctty_fd(void) 
{ 


  {
#line 306
  return (ctty_fildes);
}
}
#line 378 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxctty.c"
static void ctty_set_interrupt_chars(Tinterrupt_chars *ic ) 
{ 
  Ttty_state s ;
  int tmp ;
  void *__cil_tmp4 ;

  {
  {
#line 382
  tmp = get_terminal_state___0(ctty_fildes, & s);
  }
#line 382
  if (tmp == 0) {
    {
#line 385
    s.tio.c_cc[1] = ic->quit;
#line 386
    s.tio.c_cc[0] = ic->intrpt;
#line 387
    s.tio.c_cc[10] = ic->tstp;
#line 420
    set_terminal_state___0(ctty_fildes, & s);
    }
  }
#line 422
  return;
}
}
#line 424 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxctty.c"
static void ctty_update_interrupt_chars(void) 
{ 
  cc_t disabled_char ;
  cc_t tmp ;
  Tinterrupt_chars active_interrupt_chars ;

  {
#line 427
  if (outside_ctty_state.recorded_p) {
    {
#line 429
    tmp = UX_PC_VDISABLE(ctty_fildes);
#line 429
    disabled_char = tmp;
#line 433
    active_interrupt_chars = current_interrupt_chars;
    }
#line 434
    if ((current_interrupt_enables & 1U) == 0U) {
#line 435
      active_interrupt_chars.quit = disabled_char;
    }
#line 436
    if ((current_interrupt_enables & 2U) == 0U) {
#line 437
      active_interrupt_chars.intrpt = disabled_char;
    }
#line 438
    if ((current_interrupt_enables & 4U) == 0U) {
#line 439
      active_interrupt_chars.tstp = disabled_char;
    }
    {
#line 440
    active_interrupt_chars.dtstp = disabled_char;
#line 441
    ctty_set_interrupt_chars(& active_interrupt_chars);
    }
  }
#line 443
  return;
}
}
#line 445 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxctty.c"
void OS_ctty_get_interrupt_enables(Tinterrupt_enables *mask ) 
{ 


  {
#line 448
  *mask = current_interrupt_enables;
#line 449
  return;
}
}
#line 451 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxctty.c"
void OS_ctty_set_interrupt_enables(Tinterrupt_enables *mask ) 
{ 


  {
  {
#line 454
  current_interrupt_enables = *mask;
#line 455
  ctty_update_interrupt_chars();
  }
#line 456
  return;
}
}
#line 472 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxctty.c"
unsigned int OS_ctty_num_int_chars(void) 
{ 


  {
#line 475
  return (3U);
}
}
#line 481 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxctty.c"
static cc_t int_chars[3]  ;
#line 478 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxctty.c"
cc_t *OS_ctty_get_int_chars(void) 
{ 


  {
#line 483
  int_chars[0] = current_interrupt_chars.quit;
#line 484
  int_chars[1] = current_interrupt_chars.intrpt;
#line 485
  int_chars[2] = current_interrupt_chars.tstp;
#line 486
  return (& int_chars[0]);
}
}
#line 489 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxctty.c"
void OS_ctty_set_int_chars(cc_t *int_chars___0 ) 
{ 


  {
  {
#line 492
  current_interrupt_chars.quit = *(int_chars___0 + 0);
#line 493
  current_interrupt_chars.intrpt = *(int_chars___0 + 1);
#line 494
  current_interrupt_chars.tstp = *(int_chars___0 + 2);
#line 495
  ctty_update_interrupt_chars();
  }
#line 496
  return;
}
}
#line 510 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxctty.c"
static cc_t int_handlers[3]  ;
#line 507 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxctty.c"
cc_t *OS_ctty_get_int_char_handlers(void) 
{ 
  enum interrupt_handler tmp ;
  enum interrupt_handler tmp___0 ;
  enum interrupt_handler tmp___1 ;

  {
  {
#line 512
  tmp = OS_signal_quit_handler();
#line 512
  int_handlers[0] = (cc_t )tmp;
#line 513
  tmp___0 = OS_signal_int_handler();
#line 513
  int_handlers[1] = (cc_t )tmp___0;
#line 514
  tmp___1 = OS_signal_tstp_handler();
#line 514
  int_handlers[2] = (cc_t )tmp___1;
  }
#line 515
  return (& int_handlers[0]);
}
}
#line 518 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxctty.c"
void OS_ctty_set_int_char_handlers(cc_t *int_handlers___0 ) 
{ 


  {
  {
#line 521
  OS_signal_set_interrupt_handlers((enum interrupt_handler )*(int_handlers___0 + 0),
                                   (enum interrupt_handler )*(int_handlers___0 + 1),
                                   (enum interrupt_handler )*(int_handlers___0 + 2));
  }
#line 525
  return;
}
}
#line 528 "/home/khheo/project/mit-scheme-9.2/src/microcode/uxctty.c"
void UX_initialize_ctty(int interactive___0 ) 
{ 
  char buffer___2[9] ;
  char *tty ;
  char *tmp ;
  int tmp___0 ;
  void *__cil_tmp6 ;

  {
  {
#line 533
  tmp = ctermid(buffer___2);
#line 533
  tty = tmp;
  }
#line 534
  if ((unsigned long )tty == (unsigned long )((char *)0)) {
#line 534
    ctty_fildes = -1;
  } else
#line 534
  if ((int )*(tty + 0) == 0) {
#line 534
    ctty_fildes = -1;
  } else {
    {
#line 534
    tmp___0 = open((char const   *)tty, 2, 0);
#line 534
    ctty_fildes = tmp___0;
    }
  }
  {
#line 539
  permit_ctty_control = interactive___0;
#line 540
  outside_ctty_state.fd = ctty_fildes;
#line 540
  inside_ctty_state.fd = outside_ctty_state.fd;
#line 541
  outside_stdin_state.fd = 0;
#line 541
  inside_stdin_state.fd = outside_stdin_state.fd;
#line 542
  outside_stdout_state.fd = 1;
#line 542
  inside_stdout_state.fd = outside_stdout_state.fd;
#line 543
  UX_ctty_save_external_state();
#line 544
  inside_ctty_state.recorded_p = 0;
#line 545
  inside_stdin_state.recorded_p = 0;
#line 546
  inside_stdout_state.recorded_p = 0;
#line 547
  current_interrupt_chars.quit = (cc_t )'\003';
#line 548
  current_interrupt_chars.intrpt = (cc_t )'\a';
#line 549
  current_interrupt_chars.tstp = (cc_t )'\032';
#line 550
  current_interrupt_chars.dtstp = UX_PC_VDISABLE(ctty_fildes);
#line 551
  current_interrupt_enables = (Tinterrupt_enables )7;
  }
#line 552
  if (outside_ctty_state.recorded_p) {
    {
#line 553
    ctty_set_interrupt_chars(& current_interrupt_chars);
    }
  }
#line 554
  return;
}
}
#line 57 "/usr/include/x86_64-linux-gnu/sys/mman.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) mmap)(void *__addr ,
                                                                             size_t __len ,
                                                                             int __prot ,
                                                                             int __flags ,
                                                                             int __fd ,
                                                                             __off_t __offset ) ;
#line 76
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) munmap)(void *__addr ,
                                                                             size_t __len ) ;
#line 386 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 425
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...) ;
#line 531
extern int fgetc(FILE *__stream ) ;
#line 691 "/home/khheo/project/mit-scheme-9.2/src/microcode/confshared.h"
void *mmap_heap_malloc(unsigned long requested_length ) ;
#line 619 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) sysconf)(int __name ) ;
#line 34 "/home/khheo/project/mit-scheme-9.2/src/microcode/os.h"
void *OS_malloc_init(size_t size ) ;
#line 34 "/home/khheo/project/mit-scheme-9.2/src/microcode/ux.c"
void UX_prim_check_errno(enum syscall_names name ) 
{ 
  int *tmp ;
  int *tmp___0 ;

  {
  {
#line 37
  tmp___0 = __errno_location();
  }
#line 37
  if (*tmp___0 != 4) {
    {
#line 38
    tmp = __errno_location();
#line 38
    error_system_call(*tmp, name);
    }
  }
  {
#line 39
  deliver_pending_interrupts();
  }
#line 40
  return;
}
}
#line 42 "/home/khheo/project/mit-scheme-9.2/src/microcode/ux.c"
_Bool UX_out_of_files_p  =    (_Bool)0;
#line 44 "/home/khheo/project/mit-scheme-9.2/src/microcode/ux.c"
void UX_prim_check_fd_errno(enum syscall_names name ) 
{ 
  int *tmp ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;
  SCHEME_OBJECT *tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 47
  tmp = __errno_location();
  }
  {
#line 49
  if (*tmp == 4) {
#line 49
    goto case_4;
  }
#line 54
  if (*tmp == 23) {
#line 54
    goto case_23;
  }
#line 54
  if (*tmp == 24) {
#line 54
    goto case_23;
  }
#line 63
  goto switch_default;
  case_4: /* CIL Label */ 
  {
#line 50
  deliver_pending_interrupts();
  }
#line 51
  goto switch_break;
  case_23: /* CIL Label */ 
  case_24: /* CIL Label */ 
#line 55
  if (! UX_out_of_files_p) {
#line 57
    UX_out_of_files_p = (_Bool)1;
    {
#line 58
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 58
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 58
        set_ulong_register(12U, Registers[12] | 4UL);
        }
        {
#line 58
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 58
          if ((Registers[1] & Registers[12]) != 0UL) {
#line 58
            tmp___1 = memory_block_start;
          } else {
#line 58
            if ((Registers[1] & 4UL) != 0UL) {
#line 58
              tmp___0 = heap_alloc_limit;
            } else {
#line 58
              tmp___0 = heap_end;
            }
#line 58
            tmp___1 = tmp___0;
          }
          {
#line 58
          set_ptr_register(0U, tmp___1);
          }
#line 58
          if ((Registers[1] & 1UL) != 0UL) {
#line 58
            tmp___2 = stack_guard;
          } else {
#line 58
            tmp___2 = stack_start;
          }
          {
#line 58
          set_ptr_register(11U, tmp___2);
          }
#line 58
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 58
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 58
      gc_space_needed = 0UL;
#line 58
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 59
    deliver_pending_interrupts();
    }
  }
  switch_default: /* CIL Label */ 
  {
#line 64
  tmp___3 = __errno_location();
#line 64
  error_system_call(*tmp___3, name);
  }
  switch_break: /* CIL Label */ ;
  }
#line 66
  return;
}
}
#line 70 "/home/khheo/project/mit-scheme-9.2/src/microcode/ux.c"
int UX_terminal_get_state(int fd , Ttty_state *s ) 
{ 
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 73
  tmp___1 = tcgetattr(fd, & s->tio);
  }
#line 73
  if (tmp___1 < 0) {
#line 73
    tmp___0 = -1;
  } else {
#line 73
    tmp___0 = 0;
  }
#line 73
  return (tmp___0);
}
}
#line 81 "/home/khheo/project/mit-scheme-9.2/src/microcode/ux.c"
int UX_terminal_set_state(int fd , Ttty_state *s ) 
{ 
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 84
  tmp___1 = tcsetattr(fd, 0, (struct termios  const  *)(& s->tio));
  }
#line 84
  if (tmp___1 < 0) {
#line 84
    tmp___0 = -1;
  } else {
#line 84
    tmp___0 = 0;
  }
#line 84
  return (tmp___0);
}
}
#line 415 "/home/khheo/project/mit-scheme-9.2/src/microcode/ux.c"
cc_t UX_PC_VDISABLE(int fildes ) 
{ 


  {
#line 419
  return ((cc_t )'\000');
}
}
#line 426 "/home/khheo/project/mit-scheme-9.2/src/microcode/ux.c"
static clock_t memoized_clk_tck  =    (clock_t )0;
#line 428 "/home/khheo/project/mit-scheme-9.2/src/microcode/ux.c"
clock_t UX_SC_CLK_TCK(void) 
{ 
  long tmp ;

  {
#line 431
  if (memoized_clk_tck == 0L) {
    {
#line 432
    tmp = sysconf(2);
#line 432
    memoized_clk_tck = tmp;
    }
  }
#line 433
  return (memoized_clk_tck);
}
}
#line 630 "/home/khheo/project/mit-scheme-9.2/src/microcode/ux.c"
int UX_closefrom(int fd ) 
{ 
  int fd_limit ;
  long tmp ;
  int status ;
  int error___1 ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 645
  tmp = sysconf(4);
#line 645
  fd_limit = (int )((size_t )tmp);
#line 646
  status = 0;
#line 646
  error___1 = 0;
  }
  {
#line 647
  while (1) {
    while_continue: /* CIL Label */ ;
#line 647
    if (! (fd < fd_limit)) {
#line 647
      goto while_break;
    }
    {
#line 648
    tmp___1 = fd;
#line 648
    fd ++;
#line 648
    tmp___2 = close(tmp___1);
    }
#line 648
    if (tmp___2 < 0) {
      {
#line 648
      tmp___3 = __errno_location();
      }
#line 648
      if (*tmp___3 != 9) {
        {
#line 649
        status = -1;
#line 649
        tmp___0 = __errno_location();
#line 649
        error___1 = *tmp___0;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 650
  tmp___4 = __errno_location();
#line 650
  *tmp___4 = error___1;
  }
#line 651
  return (status);
}
}
#line 657 "/home/khheo/project/mit-scheme-9.2/src/microcode/ux.c"
void *OS_malloc_init(size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 660
  tmp = malloc(size);
  }
#line 660
  return (tmp);
}
}
#line 663 "/home/khheo/project/mit-scheme-9.2/src/microcode/ux.c"
void *OS_malloc(size_t size ) 
{ 
  void *result ;
  void *tmp ;

  {
  {
#line 666
  tmp = malloc(size);
#line 666
  result = tmp;
  }
#line 667
  if ((unsigned long )result == (unsigned long )((void *)0)) {
    {
#line 668
    error_system_call(12, (enum syscall_names )29);
    }
  }
#line 669
  return (result);
}
}
#line 672 "/home/khheo/project/mit-scheme-9.2/src/microcode/ux.c"
void *OS_realloc(void *ptr , size_t size ) 
{ 
  void *result ;
  void *tmp ;

  {
  {
#line 675
  tmp = realloc(ptr, size);
#line 675
  result = tmp;
  }
#line 676
  if ((unsigned long )result == (unsigned long )((void *)0)) {
    {
#line 677
    error_system_call(12, (enum syscall_names )40);
    }
  }
#line 678
  return (result);
}
}
#line 681 "/home/khheo/project/mit-scheme-9.2/src/microcode/ux.c"
void OS_free(void *ptr ) 
{ 


  {
  {
#line 684
  free(ptr);
  }
#line 685
  return;
}
}
#line 718
static void *mmap_heap_malloc_search(unsigned long request , unsigned long min_result ,
                                     unsigned long max_result ) ;
#line 720
static void *mmap_heap_malloc_search_procfs(unsigned long request , unsigned long min_result ,
                                            unsigned long max_result ) ;
#line 723 "/home/khheo/project/mit-scheme-9.2/src/microcode/ux.c"
void *mmap_heap_malloc(unsigned long requested_length ) 
{ 
  unsigned long pagesize ;
  int tmp ;
  unsigned long min_result ;
  int tmp___0 ;
  unsigned long max_result ;
  unsigned long request ;
  void *addr ;
  void *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 726
  tmp = getpagesize();
#line 726
  pagesize = (unsigned long )tmp;
#line 727
  tmp___0 = getpagesize();
#line 727
  min_result = (unsigned long )tmp___0;
#line 728
  max_result = 1UL << 58U;
#line 729
  request = ((requested_length + (pagesize - 1UL)) / pagesize) * pagesize;
#line 731
  tmp___1 = mmap_heap_malloc_search(request, min_result, max_result);
#line 731
  addr = tmp___1;
  }
#line 734
  if ((unsigned long )addr != (unsigned long )((void *)0)) {
#line 736
    if ((unsigned long )addr >= min_result) {
#line 736
      if ((unsigned long )addr + request <= max_result) {
#line 742
        return (addr);
      }
    }
    {
#line 744
    tmp___2 = munmap(addr, request);
    }
#line 744
    if (tmp___2 == -1) {
      {
#line 745
      outf_error("unable to unmap heap: %lx bytes at %p", request, addr);
      }
    }
  }
  {
#line 749
  outf_error("unable to mmap executable heap -- native code will probably fail");
#line 752
  tmp___3 = OS_malloc(requested_length);
  }
#line 752
  return (tmp___3);
}
}
#line 759 "/home/khheo/project/mit-scheme-9.2/src/microcode/ux.c"
static void *mmap_heap_malloc_try(unsigned long address___0 , unsigned long request ,
                                  int flags ) 
{ 
  void *addr ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 763
  tmp = mmap((void *)address___0, request, 7, 34 | flags, -1, (__off_t )0);
#line 763
  addr = tmp;
  }
#line 770
  if ((unsigned long )addr == (unsigned long )((void *)-1)) {
#line 770
    tmp___0 = (void *)0;
  } else {
#line 770
    tmp___0 = addr;
  }
#line 770
  return (tmp___0);
}
}
#line 773 "/home/khheo/project/mit-scheme-9.2/src/microcode/ux.c"
static void *mmap_heap_malloc_search(unsigned long request , unsigned long min_result ,
                                     unsigned long max_result ) 
{ 
  void *addr ;

  {
  {
#line 789
  addr = mmap_heap_malloc_search_procfs(request, min_result, max_result);
  }
#line 790
  if ((unsigned long )addr == (unsigned long )((void *)0)) {
    {
#line 791
    addr = mmap_heap_malloc_try(min_result, request, 0);
    }
  }
#line 792
  if ((unsigned long )addr == (unsigned long )((void *)0)) {
    {
#line 793
    addr = mmap_heap_malloc_try(0UL, request, 0);
    }
  }
#line 796
  return (addr);
}
}
#line 811 "/home/khheo/project/mit-scheme-9.2/src/microcode/ux.c"
static int discard_line(FILE *s ) 
{ 
  int c ;
  int tmp ;

  {
  {
#line 814
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 816
    tmp = fgetc(s);
#line 816
    c = tmp;
    }
#line 817
    if (c == -1) {
#line 818
      return (0);
    }
#line 819
    if (c == 10) {
#line 820
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 824 "/home/khheo/project/mit-scheme-9.2/src/microcode/ux.c"
static void *mmap_heap_malloc_search_procfs(unsigned long request , unsigned long min_result ,
                                            unsigned long max_result ) 
{ 
  char fn[64] ;
  FILE *s ;
  unsigned long start ;
  unsigned long new_min_result ;
  int rc ;
  int tmp ;
  __pid_t tmp___0 ;
  unsigned long end ;
  unsigned long next_start ;
  int rc___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  void *__cil_tmp17 ;

  {
  {
#line 835
  s = fopen((char const   */* __restrict  */)"/proc/sys/vm/mmap_min_addr", (char const   */* __restrict  */)"r");
  }
#line 836
  if ((unsigned long )s != (unsigned long )((FILE *)0)) {
    {
#line 839
    tmp = fscanf((FILE */* __restrict  */)s, (char const   */* __restrict  */)"%lu",
                 & new_min_result);
#line 839
    rc = tmp;
#line 840
    fclose(s);
    }
#line 841
    if (rc == 1) {
#line 841
      if (new_min_result > min_result) {
#line 842
        min_result = new_min_result;
      }
    }
  }
  {
#line 845
  tmp___0 = getpid();
#line 845
  snprintf((char */* __restrict  */)(fn), sizeof(fn), (char const   */* __restrict  */)"/proc/%d/maps",
           tmp___0);
#line 846
  s = fopen((char const   */* __restrict  */)(fn), (char const   */* __restrict  */)"r");
  }
#line 847
  if ((unsigned long )s == (unsigned long )((FILE *)0)) {
#line 848
    return ((void *)0);
  }
#line 850
  start = min_result;
  {
#line 851
  while (1) {
    while_continue: /* CIL Label */ ;
#line 851
    if (! (start + request <= max_result)) {
#line 851
      goto while_break;
    }
    {
#line 855
    tmp___1 = fscanf((FILE */* __restrict  */)s, (char const   */* __restrict  */)"%lx-%lx ",
                     & end, & next_start);
#line 855
    rc___0 = tmp___1;
    }
#line 856
    if (rc___0 == -1) {
      {
#line 858
      fclose(s);
      }
#line 859
      return ((void *)0);
    }
#line 861
    if (rc___0 == 2) {
#line 861
      if (end <= next_start) {
        {
#line 861
        tmp___2 = discard_line(s);
        }
#line 861
        if (! tmp___2) {
          {
#line 863
          fclose(s);
          }
#line 864
          return ((void *)0);
        }
      } else {
        {
#line 863
        fclose(s);
        }
#line 864
        return ((void *)0);
      }
    } else {
      {
#line 863
      fclose(s);
      }
#line 864
      return ((void *)0);
    }
#line 866
    if (start + request <= end) {
      {
#line 868
      fclose(s);
#line 870
      tmp___3 = mmap_heap_malloc_try(start, request, 16);
      }
#line 870
      return (tmp___3);
    }
#line 872
    start = next_start;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 875
  fclose(s);
  }
#line 876
  return ((void *)0);
}
}
#line 33 "/home/khheo/project/mit-scheme-9.2/src/microcode/osscheme.h"
Tchannel arg_channel(int arg_number ) ;
#line 38 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxio.c"
static char const   **string_vector_arg(int arg ) ;
#line 39
static int string_vector_p(SCHEME_OBJECT vector ) ;
#line 40
static char const   **convert_string_vector(SCHEME_OBJECT vector ) ;
#line 42 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxio.c"
SCHEME_OBJECT Prim_channel_descriptor(void) 
{ 
  Tchannel tmp ;
  int tmp___0 ;
  SCHEME_OBJECT tmp___1 ;

  {
  {
#line 44
  while (1) {
    while_continue: /* CIL Label */ ;
#line 44
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 45
  tmp = arg_channel(1);
#line 45
  tmp___0 = UX_channel_descriptor(tmp);
#line 45
  tmp___1 = long_to_integer((long )tmp___0);
  }
#line 45
  return (tmp___1);
}
}
#line 67 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxio.c"
SCHEME_OBJECT Prim_UX_make_subprocess(void) 
{ 
  void *position___1 ;
  char const   *filename ;
  char *tmp ;
  char const   **argv ;
  char const   **tmp___0 ;
  char const   **env ;
  char const   **tmp___1 ;
  char const   **tmp___2 ;
  char const   *working_directory ;
  char *tmp___3 ;
  char *tmp___4 ;
  enum process_ctty_type ctty_type ;
  char *ctty_name ;
  enum process_channel_type channel_in_type ;
  Tchannel channel_in ;
  enum process_channel_type channel_out_type ;
  Tchannel channel_out ;
  enum process_channel_type channel_err_type ;
  Tchannel channel_err ;
  Tprocess process ;
  Tprocess tmp___5 ;
  SCHEME_OBJECT tmp___6 ;

  {
  {
#line 90
  while (1) {
    while_continue: /* CIL Label */ ;
#line 90
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 92
  position___1 = dstack_position;
#line 93
  if (*(stack_pointer + 0) >> 58U == 30UL) {
#line 93
    tmp = (char *)((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 2);
  } else {
    {
#line 93
    error_wrong_type_arg(1);
#line 93
    tmp = (char *)0;
    }
  }
  {
#line 93
  filename = (char const   *)tmp;
#line 94
  tmp___0 = string_vector_arg(2);
#line 94
  argv = tmp___0;
  }
#line 95
  if (*(stack_pointer + 2) == 0UL) {
#line 95
    tmp___2 = (char const   **)0;
  } else {
    {
#line 95
    tmp___1 = string_vector_arg(3);
#line 95
    tmp___2 = tmp___1;
    }
  }
#line 95
  env = tmp___2;
#line 97
  if (*(stack_pointer + 3) == 0UL) {
#line 97
    tmp___4 = (char *)0;
  } else {
#line 97
    if (*(stack_pointer + 3) >> 58U == 30UL) {
#line 97
      tmp___3 = (char *)((SCHEME_OBJECT *)(*(stack_pointer + 3) & 288230376151711743UL) + 2);
    } else {
      {
#line 97
      error_wrong_type_arg(4);
#line 97
      tmp___3 = (char *)0;
      }
    }
#line 97
    tmp___4 = tmp___3;
  }
#line 97
  working_directory = (char const   *)tmp___4;
#line 100
  ctty_name = (char *)0;
#line 102
  channel_in = (Tchannel )-1;
#line 104
  channel_out = (Tchannel )-1;
#line 106
  channel_err = (Tchannel )-1;
#line 108
  if (*(stack_pointer + 4) == 0UL) {
#line 109
    ctty_type = (enum process_ctty_type )0;
  } else
#line 110
  if (*(stack_pointer + 4) == ((26UL << 58U) | 288230376151711743UL)) {
#line 111
    ctty_type = (enum process_ctty_type )1;
  } else
#line 112
  if (*(stack_pointer + 4) == ((26UL << 58U) | 288230376151711742UL)) {
#line 113
    ctty_type = (enum process_ctty_type )2;
  } else {
#line 116
    ctty_type = (enum process_ctty_type )3;
#line 117
    if (*(stack_pointer + 4) >> 58U == 30UL) {
#line 117
      ctty_name = (char *)((SCHEME_OBJECT *)(*(stack_pointer + 4) & 288230376151711743UL) + 2);
    } else {
      {
#line 117
      error_wrong_type_arg(5);
#line 117
      ctty_name = (char *)0;
      }
    }
  }
#line 119
  if (*(stack_pointer + 5) == 0UL) {
#line 119
    channel_in_type = (enum process_channel_type )0;
  } else
#line 119
  if (*(stack_pointer + 5) == ((26UL << 58U) | 288230376151711743UL)) {
#line 119
    channel_in_type = (enum process_channel_type )1;
  } else
#line 119
  if (*(stack_pointer + 5) == ((26UL << 58U) | 288230376151711742UL)) {
#line 119
    if ((unsigned int )ctty_type != 3U) {
      {
#line 119
      error_bad_range_arg(6);
      }
    }
#line 119
    channel_in_type = (enum process_channel_type )2;
  } else {
    {
#line 119
    channel_in_type = (enum process_channel_type )3;
#line 119
    channel_in = arg_channel(6);
    }
  }
#line 120
  if (*(stack_pointer + 6) == 0UL) {
#line 120
    channel_out_type = (enum process_channel_type )0;
  } else
#line 120
  if (*(stack_pointer + 6) == ((26UL << 58U) | 288230376151711743UL)) {
#line 120
    channel_out_type = (enum process_channel_type )1;
  } else
#line 120
  if (*(stack_pointer + 6) == ((26UL << 58U) | 288230376151711742UL)) {
#line 120
    if ((unsigned int )ctty_type != 3U) {
      {
#line 120
      error_bad_range_arg(7);
      }
    }
#line 120
    channel_out_type = (enum process_channel_type )2;
  } else {
    {
#line 120
    channel_out_type = (enum process_channel_type )3;
#line 120
    channel_out = arg_channel(7);
    }
  }
#line 121
  if (*(stack_pointer + 7) == 0UL) {
#line 121
    channel_err_type = (enum process_channel_type )0;
  } else
#line 121
  if (*(stack_pointer + 7) == ((26UL << 58U) | 288230376151711743UL)) {
#line 121
    channel_err_type = (enum process_channel_type )1;
  } else
#line 121
  if (*(stack_pointer + 7) == ((26UL << 58U) | 288230376151711742UL)) {
#line 121
    if ((unsigned int )ctty_type != 3U) {
      {
#line 121
      error_bad_range_arg(8);
      }
    }
#line 121
    channel_err_type = (enum process_channel_type )2;
  } else {
    {
#line 121
    channel_err_type = (enum process_channel_type )3;
#line 121
    channel_err = arg_channel(8);
    }
  }
  {
#line 123
  tmp___5 = OS_make_subprocess(filename, argv, env, working_directory, ctty_type,
                               ctty_name, channel_in_type, channel_in, channel_out_type,
                               channel_out, channel_err_type, channel_err);
#line 123
  process = tmp___5;
#line 130
  dstack_set_position(position___1);
#line 131
  tmp___6 = long_to_integer((long )process);
  }
#line 131
  return (tmp___6);
}
}
#line 136 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxio.c"
static char const   **string_vector_arg(int arg ) 
{ 
  SCHEME_OBJECT vector ;
  int tmp ;
  char const   **tmp___0 ;

  {
  {
#line 139
  vector = *(stack_pointer + (arg - 1));
#line 140
  tmp = string_vector_p(vector);
  }
#line 140
  if (! tmp) {
    {
#line 141
    error_wrong_type_arg(arg);
    }
  }
  {
#line 142
  tmp___0 = convert_string_vector(vector);
  }
#line 142
  return (tmp___0);
}
}
#line 145 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxio.c"
static int string_vector_p(SCHEME_OBJECT vector ) 
{ 
  unsigned long length ;
  SCHEME_OBJECT *scan ;
  SCHEME_OBJECT *end ;
  SCHEME_OBJECT *tmp ;

  {
#line 148
  if (! (vector >> 58U == 10UL)) {
#line 149
    return (0);
  }
#line 151
  length = *((SCHEME_OBJECT *)(vector & 288230376151711743UL) + 0) & 288230376151711743UL;
#line 152
  scan = (SCHEME_OBJECT *)(vector & 288230376151711743UL) + 1;
#line 153
  end = scan + length;
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if (! ((unsigned long )scan < (unsigned long )end)) {
#line 154
      goto while_break;
    }
#line 155
    tmp = scan;
#line 155
    scan ++;
#line 155
    if (! (*tmp >> 58U == 30UL)) {
#line 156
      return (0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 158
  return (1);
}
}
#line 161 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxio.c"
static char const   **convert_string_vector(SCHEME_OBJECT vector ) 
{ 
  unsigned long length ;
  char **result ;
  void *tmp ;
  SCHEME_OBJECT *scan ;
  SCHEME_OBJECT *end ;
  char **scan_result ;
  char **tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;

  {
  {
#line 164
  length = *((SCHEME_OBJECT *)(vector & 288230376151711743UL) + 0) & 288230376151711743UL;
#line 165
  tmp = dstack_alloc((unsigned int )((length + 1UL) * sizeof(char *)));
#line 165
  result = (char **)tmp;
#line 166
  scan = (SCHEME_OBJECT *)(vector & 288230376151711743UL) + 1;
#line 167
  end = scan + length;
#line 168
  scan_result = result;
  }
  {
#line 169
  while (1) {
    while_continue: /* CIL Label */ ;
#line 169
    if (! ((unsigned long )scan < (unsigned long )end)) {
#line 169
      goto while_break;
    }
#line 170
    tmp___0 = scan_result;
#line 170
    scan_result ++;
#line 170
    tmp___1 = scan;
#line 170
    scan ++;
#line 170
    *tmp___0 = (char *)((SCHEME_OBJECT *)(*tmp___1 & 288230376151711743UL) + 2);
  }
  while_break: /* CIL Label */ ;
  }
#line 171
  *scan_result = (char *)0;
#line 172
  return ((char const   **)result);
}
}
#line 212 "/home/khheo/project/mit-scheme-9.2/src/microcode/extern.h"
SCHEME_OBJECT intmax_to_integer(intmax_t number ) ;
#line 291
SCHEME_OBJECT allocate_string(unsigned long nbytes ) ;
#line 100 "/home/khheo/project/mit-scheme-9.2/src/microcode/prims.h"
intmax_t arg_index_integer_to_intmax(int arg_number , intmax_t upper_limit ) ;
#line 284 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chmod)(char const   *__file ,
                                                                                            __mode_t __mode ) ;
#line 45 "/usr/include/utime.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) utime)(char const   *__file ,
                                                                                            struct utimbuf  const  *__file_times ) ;
#line 42 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxfs.c"
static SCHEME_OBJECT file_attributes_internal(struct stat *s ) ;
#line 43
static void file_mode_string(struct stat *s , char *a ) ;
#line 44
static char file_type_letter(struct stat *s ) ;
#line 45
static void rwx(unsigned short bits , char *chars ) ;
#line 47 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxfs.c"
SCHEME_OBJECT Prim_file_modes(void) 
{ 
  struct stat stat_result ;
  unsigned long tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  void *__cil_tmp7 ;

  {
  {
#line 51
  while (1) {
    while_continue: /* CIL Label */ ;
#line 51
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 52
  if (*(stack_pointer + 0) >> 58U == 30UL) {
#line 52
    tmp___2 = (char *)((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 2);
  } else {
    {
#line 52
    error_wrong_type_arg(1);
#line 52
    tmp___2 = (char *)0;
    }
  }
  {
#line 52
  tmp___3 = UX_read_file_status_indirect((char const   *)tmp___2, & stat_result);
  }
#line 52
  if (tmp___3) {
#line 52
    tmp___1 = (26UL << 58U) | (unsigned long )(stat_result.st_mode & 4095U);
  } else {
#line 52
    tmp___1 = 0UL;
  }
#line 52
  return (tmp___1);
}
}
#line 58 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxfs.c"
SCHEME_OBJECT Prim_set_file_modes(void) 
{ 
  int *tmp ;
  long tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
#line 61
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 62
  tmp___0 = arg_index_integer(2, 4096L);
  }
#line 62
  if (*(stack_pointer + 0) >> 58U == 30UL) {
#line 62
    tmp___1 = (char *)((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 2);
  } else {
    {
#line 62
    error_wrong_type_arg(1);
#line 62
    tmp___1 = (char *)0;
    }
  }
  {
#line 62
  tmp___2 = chmod((char const   *)tmp___1, (__mode_t )tmp___0);
  }
#line 62
  if (tmp___2 < 0) {
    {
#line 63
    tmp = __errno_location();
#line 63
    error_system_call(*tmp, (enum syscall_names )3);
    }
  }
#line 64
  return (0UL);
}
}
#line 67 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxfs.c"
SCHEME_OBJECT Prim_file_mod_time(void) 
{ 
  struct stat s ;
  SCHEME_OBJECT tmp___1 ;
  SCHEME_OBJECT tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  void *__cil_tmp8 ;

  {
  {
#line 70
  while (1) {
    while_continue: /* CIL Label */ ;
#line 70
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 71
  if (*(stack_pointer + 0) >> 58U == 30UL) {
#line 71
    tmp___3 = (char *)((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 2);
  } else {
    {
#line 71
    error_wrong_type_arg(1);
#line 71
    tmp___3 = (char *)0;
    }
  }
  {
#line 71
  tmp___4 = UX_read_file_status((char const   *)tmp___3, & s);
  }
#line 71
  if (tmp___4) {
    {
#line 71
    tmp___1 = intmax_to_integer(s.st_mtim.tv_sec);
#line 71
    tmp___2 = tmp___1;
    }
  } else {
#line 71
    tmp___2 = 0UL;
  }
#line 71
  return (tmp___2);
}
}
#line 77 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxfs.c"
SCHEME_OBJECT Prim_file_mod_time_indirect(void) 
{ 
  struct stat s ;
  SCHEME_OBJECT tmp___1 ;
  SCHEME_OBJECT tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  void *__cil_tmp8 ;

  {
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
#line 80
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 81
  if (*(stack_pointer + 0) >> 58U == 30UL) {
#line 81
    tmp___3 = (char *)((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 2);
  } else {
    {
#line 81
    error_wrong_type_arg(1);
#line 81
    tmp___3 = (char *)0;
    }
  }
  {
#line 81
  tmp___4 = UX_read_file_status_indirect((char const   *)tmp___3, & s);
  }
#line 81
  if (tmp___4) {
    {
#line 81
    tmp___1 = intmax_to_integer(s.st_mtim.tv_sec);
#line 81
    tmp___2 = tmp___1;
    }
  } else {
#line 81
    tmp___2 = 0UL;
  }
#line 81
  return (tmp___2);
}
}
#line 87 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxfs.c"
SCHEME_OBJECT Prim_file_acc_time(void) 
{ 
  struct stat s ;
  SCHEME_OBJECT tmp___1 ;
  SCHEME_OBJECT tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  void *__cil_tmp8 ;

  {
  {
#line 90
  while (1) {
    while_continue: /* CIL Label */ ;
#line 90
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 91
  if (*(stack_pointer + 0) >> 58U == 30UL) {
#line 91
    tmp___3 = (char *)((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 2);
  } else {
    {
#line 91
    error_wrong_type_arg(1);
#line 91
    tmp___3 = (char *)0;
    }
  }
  {
#line 91
  tmp___4 = UX_read_file_status((char const   *)tmp___3, & s);
  }
#line 91
  if (tmp___4) {
    {
#line 91
    tmp___1 = intmax_to_integer(s.st_atim.tv_sec);
#line 91
    tmp___2 = tmp___1;
    }
  } else {
#line 91
    tmp___2 = 0UL;
  }
#line 91
  return (tmp___2);
}
}
#line 97 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxfs.c"
SCHEME_OBJECT Prim_file_acc_time_indirect(void) 
{ 
  struct stat s ;
  SCHEME_OBJECT tmp___1 ;
  SCHEME_OBJECT tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  void *__cil_tmp8 ;

  {
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 100
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 101
  if (*(stack_pointer + 0) >> 58U == 30UL) {
#line 101
    tmp___3 = (char *)((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 2);
  } else {
    {
#line 101
    error_wrong_type_arg(1);
#line 101
    tmp___3 = (char *)0;
    }
  }
  {
#line 101
  tmp___4 = UX_read_file_status_indirect((char const   *)tmp___3, & s);
  }
#line 101
  if (tmp___4) {
    {
#line 101
    tmp___1 = intmax_to_integer(s.st_atim.tv_sec);
#line 101
    tmp___2 = tmp___1;
    }
  } else {
#line 101
    tmp___2 = 0UL;
  }
#line 101
  return (tmp___2);
}
}
#line 107 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxfs.c"
SCHEME_OBJECT Prim_set_file_times(void) 
{ 
  struct utimbuf times___0 ;
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 113
  while (1) {
    while_continue: /* CIL Label */ ;
#line 113
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 114
  times___0.actime = arg_index_integer_to_intmax(2, 9223372036854775807L);
#line 115
  times___0.modtime = arg_index_integer_to_intmax(3, 9223372036854775807L);
  }
  {
#line 116
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 116
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 116
      if (*(stack_pointer + 0) >> 58U == 30UL) {
#line 116
        tmp = (char *)((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 2);
      } else {
        {
#line 116
        error_wrong_type_arg(1);
#line 116
        tmp = (char *)0;
        }
      }
      {
#line 116
      tmp___0 = utime((char const   *)tmp, (struct utimbuf  const  *)(& times___0));
      }
#line 116
      if (! (tmp___0 < 0)) {
#line 116
        goto while_break___1;
      }
      {
#line 116
      UX_prim_check_errno((enum syscall_names )66);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 116
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 118
  return ((8UL << 58U) | 1UL);
}
}
#line 138 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxfs.c"
SCHEME_OBJECT Prim_channel_file_attributes(void) 
{ 
  struct stat s ;
  Tchannel tmp ;
  SCHEME_OBJECT tmp___0 ;
  void *__cil_tmp4 ;

  {
  {
#line 141
  while (1) {
    while_continue: /* CIL Label */ ;
#line 141
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 142
  tmp = arg_channel(1);
#line 142
  UX_read_fd_status((channel_table + tmp)->descriptor, & s);
#line 143
  tmp___0 = file_attributes_internal(& s);
  }
#line 143
  return (tmp___0);
}
}
#line 156 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxfs.c"
SCHEME_OBJECT Prim_file_attributes(void) 
{ 
  struct stat s ;
  SCHEME_OBJECT tmp___1 ;
  SCHEME_OBJECT tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  void *__cil_tmp8 ;

  {
  {
#line 161
  while (1) {
    while_continue: /* CIL Label */ ;
#line 161
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 161
  if (*(stack_pointer + 0) >> 58U == 30UL) {
#line 161
    tmp___3 = (char *)((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 2);
  } else {
    {
#line 161
    error_wrong_type_arg(1);
#line 161
    tmp___3 = (char *)0;
    }
  }
  {
#line 161
  tmp___4 = UX_read_file_status((char const   *)tmp___3, & s);
  }
#line 161
  if (tmp___4) {
    {
#line 161
    tmp___1 = file_attributes_internal(& s);
#line 161
    tmp___2 = tmp___1;
    }
  } else {
#line 161
    tmp___2 = 0UL;
  }
#line 161
  return (tmp___2);
}
}
#line 163 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxfs.c"
SCHEME_OBJECT Prim_file_attributes_indirect(void) 
{ 
  struct stat s ;
  SCHEME_OBJECT tmp___1 ;
  SCHEME_OBJECT tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  void *__cil_tmp8 ;

  {
  {
#line 165
  while (1) {
    while_continue: /* CIL Label */ ;
#line 165
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 165
  if (*(stack_pointer + 0) >> 58U == 30UL) {
#line 165
    tmp___3 = (char *)((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 2);
  } else {
    {
#line 165
    error_wrong_type_arg(1);
#line 165
    tmp___3 = (char *)0;
    }
  }
  {
#line 165
  tmp___4 = UX_read_file_status_indirect((char const   *)tmp___3, & s);
  }
#line 165
  if (tmp___4) {
    {
#line 165
    tmp___1 = file_attributes_internal(& s);
#line 165
    tmp___2 = tmp___1;
    }
  } else {
#line 165
    tmp___2 = 0UL;
  }
#line 165
  return (tmp___2);
}
}
#line 167 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxfs.c"
static SCHEME_OBJECT file_attributes_internal(struct stat *s ) 
{ 
  SCHEME_OBJECT result ;
  SCHEME_OBJECT tmp ;
  SCHEME_OBJECT modes ;
  SCHEME_OBJECT tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 170
  tmp = allocate_marked_vector(10U, 10UL, (_Bool)1);
#line 170
  result = tmp;
#line 171
  tmp___0 = allocate_string(10UL);
#line 171
  modes = tmp___0;
  }
  {
#line 174
  if ((s->st_mode & 61440U) == 16384U) {
#line 174
    goto case_16384;
  }
#line 178
  if ((s->st_mode & 61440U) == 40960U) {
#line 178
    goto case_40960;
  }
#line 184
  goto switch_default;
  case_16384: /* CIL Label */ 
#line 175
  *((SCHEME_OBJECT *)(result & 288230376151711743UL) + 1) = 8UL << 58U;
#line 176
  goto switch_break;
  case_40960: /* CIL Label */ 
  {
#line 179
  tmp___1 = OS_file_soft_link_p((char const   *)((char *)((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 2)));
#line 179
  *((SCHEME_OBJECT *)(result & 288230376151711743UL) + 1) = char_pointer_to_string(tmp___1);
  }
#line 182
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 185
  *((SCHEME_OBJECT *)(result & 288230376151711743UL) + 1) = 0UL;
#line 186
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 188
  *((SCHEME_OBJECT *)(result & 288230376151711743UL) + 2) = intmax_to_integer((intmax_t )s->st_nlink);
#line 189
  *((SCHEME_OBJECT *)(result & 288230376151711743UL) + 3) = intmax_to_integer((intmax_t )s->st_uid);
#line 190
  *((SCHEME_OBJECT *)(result & 288230376151711743UL) + 4) = intmax_to_integer((intmax_t )s->st_gid);
#line 191
  *((SCHEME_OBJECT *)(result & 288230376151711743UL) + 5) = intmax_to_integer(s->st_atim.tv_sec);
#line 192
  *((SCHEME_OBJECT *)(result & 288230376151711743UL) + 6) = intmax_to_integer(s->st_mtim.tv_sec);
#line 193
  *((SCHEME_OBJECT *)(result & 288230376151711743UL) + 7) = intmax_to_integer(s->st_ctim.tv_sec);
#line 194
  *((SCHEME_OBJECT *)(result & 288230376151711743UL) + 8) = intmax_to_integer(s->st_size);
#line 195
  file_mode_string(s, (char *)((SCHEME_OBJECT *)(modes & 288230376151711743UL) + 2));
#line 196
  *((SCHEME_OBJECT *)(result & 288230376151711743UL) + 9) = modes;
#line 197
  *((SCHEME_OBJECT *)(result & 288230376151711743UL) + 10) = intmax_to_integer((intmax_t )s->st_ino);
  }
#line 198
  return (result);
}
}
#line 232 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxfs.c"
static void file_mode_string(struct stat *s , char *a ) 
{ 


  {
  {
#line 235
  *(a + 0) = file_type_letter(s);
#line 236
  rwx((unsigned short )(s->st_mode & 448U), a + 1);
#line 237
  rwx((unsigned short )((s->st_mode & 56U) << 3), a + 4);
#line 238
  rwx((unsigned short )((s->st_mode & 7U) << 6), a + 7);
  }
#line 240
  if ((s->st_mode & 2048U) != 0U) {
#line 241
    if ((int )*(a + 3) == 120) {
#line 241
      *(a + 3) = (char )'s';
    } else {
#line 241
      *(a + 3) = (char )'S';
    }
  }
#line 244
  if ((s->st_mode & 1024U) != 0U) {
#line 245
    if ((int )*(a + 6) == 120) {
#line 245
      *(a + 6) = (char )'s';
    } else {
#line 245
      *(a + 6) = (char )'S';
    }
  }
#line 248
  if ((s->st_mode & 512U) != 0U) {
#line 249
    if ((int )*(a + 9) == 120) {
#line 249
      *(a + 9) = (char )'t';
    } else {
#line 249
      *(a + 9) = (char )'T';
    }
  }
#line 251
  return;
}
}
#line 253 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxfs.c"
static char file_type_letter(struct stat *s ) 
{ 


  {
  {
#line 258
  if ((s->st_mode & 61440U) == 16384U) {
#line 258
    goto case_16384;
  }
#line 260
  if ((s->st_mode & 61440U) == 8192U) {
#line 260
    goto case_8192;
  }
#line 262
  if ((s->st_mode & 61440U) == 24576U) {
#line 262
    goto case_24576;
  }
#line 265
  if ((s->st_mode & 61440U) == 40960U) {
#line 265
    goto case_40960;
  }
#line 275
  if ((s->st_mode & 61440U) == 49152U) {
#line 275
    goto case_49152;
  }
#line 279
  if ((s->st_mode & 61440U) == 4096U) {
#line 279
    goto case_4096;
  }
#line 286
  goto switch_default;
  case_16384: /* CIL Label */ 
#line 259
  return ((char )'d');
  case_8192: /* CIL Label */ 
#line 261
  return ((char )'c');
  case_24576: /* CIL Label */ 
#line 263
  return ((char )'b');
  case_40960: /* CIL Label */ 
#line 266
  return ((char )'l');
  case_49152: /* CIL Label */ 
#line 276
  return ((char )'s');
  case_4096: /* CIL Label */ 
#line 280
  return ((char )'p');
  switch_default: /* CIL Label */ 
#line 287
  return ((char )'-');
  switch_break: /* CIL Label */ ;
  }
}
}
#line 291 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxfs.c"
static void rwx(unsigned short bits , char *chars ) 
{ 


  {
#line 294
  if (((int )bits & 256) != 0) {
#line 294
    *(chars + 0) = (char )'r';
  } else {
#line 294
    *(chars + 0) = (char )'-';
  }
#line 295
  if (((int )bits & 128) != 0) {
#line 295
    *(chars + 1) = (char )'w';
  } else {
#line 295
    *(chars + 1) = (char )'-';
  }
#line 296
  if (((int )bits & 64) != 0) {
#line 296
    *(chars + 2) = (char )'x';
  } else {
#line 296
    *(chars + 2) = (char )'-';
  }
#line 297
  return;
}
}
#line 299 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxfs.c"
SCHEME_OBJECT Prim_file_eq_p(void) 
{ 
  struct stat s1 ;
  struct stat s2 ;
  unsigned long tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;

  {
  {
#line 302
  while (1) {
    while_continue: /* CIL Label */ ;
#line 302
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 306
  if (*(stack_pointer + 0) >> 58U == 30UL) {
#line 306
    tmp___4 = (char *)((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 2);
  } else {
    {
#line 306
    error_wrong_type_arg(1);
#line 306
    tmp___4 = (char *)0;
    }
  }
  {
#line 306
  tmp___5 = UX_read_file_status((char const   *)tmp___4, & s1);
  }
#line 306
  if (tmp___5) {
#line 306
    if (*(stack_pointer + 1) >> 58U == 30UL) {
#line 306
      tmp___6 = (char *)((SCHEME_OBJECT *)(*(stack_pointer + 1) & 288230376151711743UL) + 2);
    } else {
      {
#line 306
      error_wrong_type_arg(2);
#line 306
      tmp___6 = (char *)0;
      }
    }
    {
#line 306
    tmp___7 = UX_read_file_status((char const   *)tmp___6, & s2);
    }
#line 306
    if (tmp___7) {
#line 306
      if (s1.st_dev == s2.st_dev) {
#line 306
        if (s1.st_ino == s2.st_ino) {
#line 306
          tmp___3 = 8UL << 58U;
        } else {
#line 306
          tmp___3 = 0UL;
        }
      } else {
#line 306
        tmp___3 = 0UL;
      }
    } else {
#line 306
      tmp___3 = 0UL;
    }
  } else {
#line 306
    tmp___3 = 0UL;
  }
#line 306
  return (tmp___3);
}
}
#line 315 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxfs.c"
SCHEME_OBJECT Prim_file_system_type(void) 
{ 
  char const   *result ;
  char *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  SCHEME_OBJECT tmp___2 ;
  char *__cil_tmp6 ;

  {
  {
#line 317
  while (1) {
    while_continue: /* CIL Label */ ;
#line 317
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 319
  if (*(stack_pointer + 0) >> 58U == 30UL) {
#line 319
    tmp = (char *)((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 2);
  } else {
    {
#line 319
    error_wrong_type_arg(1);
#line 319
    tmp = (char *)0;
    }
  }
  {
#line 319
  tmp___0 = UX_file_system_type((char const   *)tmp);
#line 319
  result = tmp___0;
  }
#line 320
  if ((unsigned long )result == (unsigned long )((char const   *)0)) {
#line 320
    tmp___1 = "unknown";
  } else {
#line 320
    tmp___1 = result;
  }
  {
#line 320
  tmp___2 = char_pointer_to_string(tmp___1);
  }
#line 320
  return (tmp___2);
}
}
#line 264 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) ctime)(time_t const   *__timer ) ;
#line 717 "/usr/include/stdlib.h"
extern int system(char const   *__command ) ;
#line 105 "/usr/include/grp.h"
extern struct group *getgrgid(__gid_t __gid ) ;
#line 681 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __gid_t ( __attribute__((__leaf__)) getgid)(void) ;
#line 684
extern  __attribute__((__nothrow__)) __gid_t ( __attribute__((__leaf__)) getegid)(void) ;
#line 42 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxenv.c"
SCHEME_OBJECT Prim_file_time_to_string(void) 
{ 
  time_t clock___0 ;
  intmax_t tmp ;
  char *time_string ;
  char *tmp___0 ;
  SCHEME_OBJECT tmp___1 ;

  {
  {
#line 45
  while (1) {
    while_continue: /* CIL Label */ ;
#line 45
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 46
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 46
    if (! (*(stack_pointer + 0) >> 58U == 26UL)) {
#line 46
      if (! (*(stack_pointer + 0) >> 58U == 14UL)) {
        {
#line 46
        error_wrong_type_arg(1);
        }
      }
    }
#line 46
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 48
  tmp = arg_index_integer_to_intmax(1, 9223372036854775807L);
#line 48
  clock___0 = tmp;
#line 49
  tmp___0 = ctime((time_t const   *)(& clock___0));
#line 49
  time_string = tmp___0;
#line 50
  *(time_string + 24) = (char )'\000';
#line 51
  tmp___1 = char_pointer_to_string((char const   *)time_string);
  }
#line 51
  return (tmp___1);
}
}
#line 55 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxenv.c"
SCHEME_OBJECT Prim_get_user_home_directory(void) 
{ 
  struct passwd *entry ;
  char *tmp ;
  struct passwd *tmp___0 ;
  SCHEME_OBJECT tmp___1 ;
  unsigned long tmp___2 ;

  {
  {
#line 60
  while (1) {
    while_continue: /* CIL Label */ ;
#line 60
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 62
  if (*(stack_pointer + 0) >> 58U == 30UL) {
#line 62
    tmp = (char *)((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 2);
  } else {
    {
#line 62
    error_wrong_type_arg(1);
#line 62
    tmp = (char *)0;
    }
  }
  {
#line 62
  tmp___0 = getpwnam((char const   *)tmp);
#line 62
  entry = tmp___0;
  }
#line 63
  if ((unsigned long )entry == (unsigned long )((struct passwd *)0)) {
#line 63
    tmp___2 = 0UL;
  } else {
    {
#line 63
    tmp___1 = char_pointer_to_string((char const   *)entry->pw_dir);
#line 63
    tmp___2 = tmp___1;
    }
  }
#line 63
  return (tmp___2);
}
}
#line 69 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxenv.c"
SCHEME_OBJECT Prim_uid_to_string(void) 
{ 
  struct passwd *entry ;
  long tmp ;
  struct passwd *tmp___0 ;
  SCHEME_OBJECT tmp___1 ;
  unsigned long tmp___2 ;

  {
  {
#line 73
  while (1) {
    while_continue: /* CIL Label */ ;
#line 73
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 75
  tmp = arg_nonnegative_integer(1);
#line 75
  tmp___0 = getpwuid((__uid_t )tmp);
#line 75
  entry = tmp___0;
  }
#line 76
  if ((unsigned long )entry == (unsigned long )((struct passwd *)0)) {
#line 76
    tmp___2 = 0UL;
  } else {
    {
#line 76
    tmp___1 = char_pointer_to_string((char const   *)entry->pw_name);
#line 76
    tmp___2 = tmp___1;
    }
  }
#line 76
  return (tmp___2);
}
}
#line 82 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxenv.c"
SCHEME_OBJECT Prim_gid_to_string(void) 
{ 
  struct group *entry ;
  long tmp ;
  struct group *tmp___0 ;
  SCHEME_OBJECT tmp___1 ;
  unsigned long tmp___2 ;

  {
  {
#line 86
  while (1) {
    while_continue: /* CIL Label */ ;
#line 86
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 88
  tmp = arg_nonnegative_integer(1);
#line 88
  tmp___0 = getgrgid((__gid_t )tmp);
#line 88
  entry = tmp___0;
  }
#line 89
  if ((unsigned long )entry == (unsigned long )((struct group *)0)) {
#line 89
    tmp___2 = 0UL;
  } else {
    {
#line 89
    tmp___1 = char_pointer_to_string((char const   *)entry->gr_name);
#line 89
    tmp___2 = tmp___1;
    }
  }
#line 89
  return (tmp___2);
}
}
#line 95 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxenv.c"
SCHEME_OBJECT Prim_current_pid(void) 
{ 
  __pid_t tmp ;
  SCHEME_OBJECT tmp___0 ;

  {
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 99
  tmp = getpid();
#line 99
  tmp___0 = long_to_integer((long )tmp);
  }
#line 99
  return (tmp___0);
}
}
#line 102 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxenv.c"
SCHEME_OBJECT Prim_current_uid(void) 
{ 
  __uid_t tmp ;
  SCHEME_OBJECT tmp___0 ;

  {
  {
#line 105
  while (1) {
    while_continue: /* CIL Label */ ;
#line 105
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 106
  tmp = geteuid();
#line 106
  tmp___0 = long_to_integer((long )tmp);
  }
#line 106
  return (tmp___0);
}
}
#line 109 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxenv.c"
SCHEME_OBJECT Prim_current_gid(void) 
{ 
  __gid_t tmp ;
  SCHEME_OBJECT tmp___0 ;

  {
  {
#line 112
  while (1) {
    while_continue: /* CIL Label */ ;
#line 112
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 113
  tmp = getegid();
#line 113
  tmp___0 = long_to_integer((long )tmp);
  }
#line 113
  return (tmp___0);
}
}
#line 116 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxenv.c"
SCHEME_OBJECT Prim_real_uid(void) 
{ 
  __uid_t tmp ;
  SCHEME_OBJECT tmp___0 ;

  {
  {
#line 119
  while (1) {
    while_continue: /* CIL Label */ ;
#line 119
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 120
  tmp = getuid();
#line 120
  tmp___0 = long_to_integer((long )tmp);
  }
#line 120
  return (tmp___0);
}
}
#line 123 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxenv.c"
SCHEME_OBJECT Prim_real_gid(void) 
{ 
  __gid_t tmp ;
  SCHEME_OBJECT tmp___0 ;

  {
  {
#line 126
  while (1) {
    while_continue: /* CIL Label */ ;
#line 126
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 127
  tmp = getgid();
#line 127
  tmp___0 = long_to_integer((long )tmp);
  }
#line 127
  return (tmp___0);
}
}
#line 130 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxenv.c"
SCHEME_OBJECT Prim_current_user_name(void) 
{ 
  char const   *tmp ;
  SCHEME_OBJECT tmp___0 ;

  {
  {
#line 133
  while (1) {
    while_continue: /* CIL Label */ ;
#line 133
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 134
  tmp = OS_current_user_name();
#line 134
  tmp___0 = char_pointer_to_string(tmp);
  }
#line 134
  return (tmp___0);
}
}
#line 137 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxenv.c"
SCHEME_OBJECT Prim_current_user_home_directory(void) 
{ 
  char const   *tmp ;
  SCHEME_OBJECT tmp___0 ;

  {
  {
#line 140
  while (1) {
    while_continue: /* CIL Label */ ;
#line 140
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 141
  tmp = OS_current_user_home_directory();
#line 141
  tmp___0 = char_pointer_to_string(tmp);
  }
#line 141
  return (tmp___0);
}
}
#line 145 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxenv.c"
SCHEME_OBJECT Prim_system(void) 
{ 
  char *tmp ;
  int tmp___0 ;
  SCHEME_OBJECT tmp___1 ;

  {
  {
#line 149
  while (1) {
    while_continue: /* CIL Label */ ;
#line 149
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 150
  if (*(stack_pointer + 0) >> 58U == 30UL) {
#line 150
    tmp = (char *)((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 2);
  } else {
    {
#line 150
    error_wrong_type_arg(1);
#line 150
    tmp = (char *)0;
    }
  }
  {
#line 150
  tmp___0 = system((char const   *)tmp);
#line 150
  tmp___1 = long_to_integer((long )tmp___0);
  }
#line 150
  return (tmp___1);
}
}
#line 153 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxenv.c"
SCHEME_OBJECT Prim_get_environment_variable(void) 
{ 
  char const   *variable_value ;
  char *tmp ;
  char *tmp___0 ;
  SCHEME_OBJECT tmp___1 ;
  unsigned long tmp___2 ;

  {
  {
#line 159
  while (1) {
    while_continue: /* CIL Label */ ;
#line 159
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 161
  if (*(stack_pointer + 0) >> 58U == 30UL) {
#line 161
    tmp = (char *)((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 2);
  } else {
    {
#line 161
    error_wrong_type_arg(1);
#line 161
    tmp = (char *)0;
    }
  }
  {
#line 161
  tmp___0 = getenv((char const   *)tmp);
#line 161
  variable_value = (char const   *)tmp___0;
  }
#line 162
  if ((unsigned long )variable_value == (unsigned long )((char const   *)0)) {
#line 162
    tmp___2 = 0UL;
  } else {
    {
#line 162
    tmp___1 = char_pointer_to_string(variable_value);
#line 162
    tmp___2 = tmp___1;
    }
  }
#line 162
  return (tmp___2);
}
}
#line 170 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxenv.c"
SCHEME_OBJECT Prim_full_hostname(void) 
{ 
  char this_host_name[1024] ;
  struct hostent *this_host_entry ;
  int tmp ;
  SCHEME_OBJECT tmp___0 ;
  unsigned long tmp___1 ;
  void *__cil_tmp6 ;

  {
  {
#line 173
  while (1) {
    while_continue: /* CIL Label */ ;
#line 173
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 179
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 179
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 179
      tmp = gethostname(this_host_name, (size_t )1024);
      }
#line 179
      if (! (tmp < 0)) {
#line 179
        goto while_break___1;
      }
      {
#line 179
      UX_prim_check_errno((enum syscall_names )18);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 179
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 187
  this_host_entry = gethostbyname((char const   *)(this_host_name));
  }
#line 188
  if ((unsigned long )this_host_entry == (unsigned long )((struct hostent *)0)) {
#line 188
    tmp___1 = 0UL;
  } else {
    {
#line 188
    tmp___0 = char_pointer_to_string((char const   *)this_host_entry->h_name);
#line 188
    tmp___1 = tmp___0;
    }
  }
#line 188
  return (tmp___1);
}
}
#line 197 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxenv.c"
SCHEME_OBJECT Prim_hostname(void) 
{ 
  char this_host_name[1024] ;
  int tmp ;
  SCHEME_OBJECT tmp___0 ;
  void *__cil_tmp4 ;

  {
  {
#line 200
  while (1) {
    while_continue: /* CIL Label */ ;
#line 200
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 205
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 205
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 205
      tmp = gethostname(this_host_name, (size_t )1024);
      }
#line 205
      if (! (tmp < 0)) {
#line 205
        goto while_break___1;
      }
      {
#line 205
      UX_prim_check_errno((enum syscall_names )18);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 205
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 210
  tmp___0 = char_pointer_to_string((char const   *)(this_host_name));
  }
#line 210
  return (tmp___0);
}
}
#line 214 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxenv.c"
SCHEME_OBJECT Prim_instruction_address_to_compiled_code_block(void) 
{ 
  SCHEME_OBJECT object ;
  unsigned long pc ;
  _Bool tmp ;
  SCHEME_OBJECT tmp___0 ;

  {
  {
#line 217
  while (1) {
    while_continue: /* CIL Label */ ;
#line 217
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 220
  object = *(stack_pointer + 0);
#line 222
  if (object >> 58U == 26UL) {
#line 222
    goto _L;
  } else
#line 222
  if (object >> 58U == 14UL) {
    _L: /* CIL Label */ 
    {
#line 224
    tmp = integer_to_ulong_p(object);
    }
#line 224
    if (! tmp) {
      {
#line 225
      error_bad_range_arg(1);
      }
    }
    {
#line 226
    pc = integer_to_ulong(object);
    }
  } else {
#line 230
    if (! (object >> 58U == 40UL)) {
      {
#line 231
      error_bad_range_arg(1);
      }
    }
#line 232
    pc = (unsigned long )((insn_t *)((SCHEME_OBJECT *)(object & 288230376151711743UL)));
  }
  {
#line 234
  tmp___0 = find_ccblock(pc);
  }
#line 234
  return (tmp___0);
}
}
#line 242 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxenv.c"
SCHEME_OBJECT Prim_macosx_main_bundle_dir(void) 
{ 


  {
  {
#line 245
  while (1) {
    while_continue: /* CIL Label */ ;
#line 245
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 265
  error_unimplemented_primitive();
  }
#line 266
  return ((8UL << 58U) | 1UL);
}
}
#line 74 "/usr/include/setjmp.h"
extern  __attribute__((__nothrow__, __noreturn__)) void longjmp(struct __jmp_buf_tag *__env ,
                                                                int __val ) ;
#line 39 "/home/khheo/project/mit-scheme-9.2/src/microcode/intext.h"
struct interruptable_extent *current_interruptable_extent  ;
#line 42
struct interruptable_extent *enter_interruptable_extent(void) ;
#line 33 "/home/khheo/project/mit-scheme-9.2/src/microcode/intext.c"
void initialize_interruptable_extent(void) 
{ 


  {
#line 36
  current_interruptable_extent = (struct interruptable_extent *)0;
#line 37
  return;
}
}
#line 39 "/home/khheo/project/mit-scheme-9.2/src/microcode/intext.c"
void reset_interruptable_extent(void) 
{ 


  {
#line 42
  current_interruptable_extent = (struct interruptable_extent *)0;
#line 43
  return;
}
}
#line 45 "/home/khheo/project/mit-scheme-9.2/src/microcode/intext.c"
struct interruptable_extent *enter_interruptable_extent(void) 
{ 
  void *position___1 ;
  struct interruptable_extent *frame ;
  void *tmp ;

  {
  {
#line 48
  position___1 = dstack_position;
#line 55
  preserve_signal_mask();
#line 56
  tmp = dstack_alloc((unsigned int )sizeof(struct interruptable_extent ));
#line 56
  frame = (struct interruptable_extent *)tmp;
#line 57
  frame->position = position___1;
#line 58
  frame->interrupted = 0;
#line 61
  dstack_bind((void *)(& current_interruptable_extent), (void *)current_interruptable_extent);
  }
#line 62
  return (frame);
}
}
#line 72 "/home/khheo/project/mit-scheme-9.2/src/microcode/intext.c"
int enter_interruption_extent(void) 
{ 


  {
#line 75
  if ((unsigned long )current_interruptable_extent == (unsigned long )((struct interruptable_extent *)0)) {
#line 77
    return (0);
  } else
#line 75
  if (current_interruptable_extent->interrupted) {
#line 77
    return (0);
  }
#line 78
  current_interruptable_extent->interrupted = 1;
#line 79
  return (1);
}
}
#line 82 "/home/khheo/project/mit-scheme-9.2/src/microcode/intext.c"
void exit_interruption_extent(void) 
{ 


  {
  {
#line 85
  longjmp((struct __jmp_buf_tag *)(current_interruptable_extent->control_point), 1);
  }
}
}
#line 104 "/home/khheo/project/mit-scheme-9.2/src/microcode/prims.h"
unsigned long arg_ulong_integer_in_range(int arg_number , unsigned long lower_limit ,
                                         unsigned long upper_limit ) ;
#line 58 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxsock.c"
static void *arg_host(unsigned int arg ) 
{ 
  unsigned int tmp ;

  {
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
#line 61
    if (! (*(stack_pointer + (arg - 1U)) >> 58U == 30UL)) {
      {
#line 61
      error_wrong_type_arg((int )arg);
      }
    }
#line 61
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 62
  tmp = OS_host_address_length();
  }
#line 62
  if ((*((SCHEME_OBJECT *)(*(stack_pointer + (arg - 1U)) & 288230376151711743UL) + 1) & 288230376151711743UL) != (unsigned long )tmp) {
    {
#line 63
    error_bad_range_arg((int )arg);
    }
  }
#line 64
  return ((void *)((char *)((SCHEME_OBJECT *)(*(stack_pointer + (arg - 1U)) & 288230376151711743UL) + 2)));
}
}
#line 67 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxsock.c"
static Tchannel arg_client_socket(unsigned int arg ) 
{ 
  Tchannel socket___0 ;
  unsigned long tmp ;
  enum channel_type tmp___0 ;
  enum channel_type tmp___1 ;

  {
  {
#line 70
  tmp = arg_ulong_integer((int )arg);
#line 70
  socket___0 = (Tchannel )tmp;
#line 71
  tmp___0 = OS_channel_type(socket___0);
  }
#line 71
  if (! ((unsigned int )tmp___0 == 7U)) {
    {
#line 71
    tmp___1 = OS_channel_type(socket___0);
    }
#line 71
    if (! ((unsigned int )tmp___1 == 6U)) {
      {
#line 73
      error_bad_range_arg((int )arg);
      }
    }
  }
#line 74
  return (socket___0);
}
}
#line 77 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxsock.c"
static Tchannel arg_server_socket(unsigned int arg ) 
{ 
  Tchannel server_socket ;
  long tmp ;
  enum channel_type tmp___0 ;

  {
  {
#line 80
  tmp = arg_nonnegative_integer((int )arg);
#line 80
  server_socket = (Tchannel )tmp;
#line 81
  tmp___0 = OS_channel_type(server_socket);
  }
#line 81
  if ((unsigned int )tmp___0 != 8U) {
    {
#line 82
    error_bad_range_arg((int )arg);
    }
  }
#line 83
  return (server_socket);
}
}
#line 96 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxsock.c"
SCHEME_OBJECT Prim_get_service_by_name(void) 
{ 
  int result ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  SCHEME_OBJECT tmp___2 ;
  unsigned long tmp___3 ;

  {
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 100
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 101
  if (*(stack_pointer + 1) >> 58U == 30UL) {
#line 101
    tmp = (char *)((SCHEME_OBJECT *)(*(stack_pointer + 1) & 288230376151711743UL) + 2);
  } else {
    {
#line 101
    error_wrong_type_arg(2);
#line 101
    tmp = (char *)0;
    }
  }
#line 101
  if (*(stack_pointer + 0) >> 58U == 30UL) {
#line 101
    tmp___0 = (char *)((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 2);
  } else {
    {
#line 101
    error_wrong_type_arg(1);
#line 101
    tmp___0 = (char *)0;
    }
  }
  {
#line 101
  tmp___1 = OS_get_service_by_name((char const   *)tmp___0, (char const   *)tmp);
#line 101
  result = tmp___1;
  }
#line 101
  if (result < 0) {
#line 101
    tmp___3 = 0UL;
  } else {
    {
#line 101
    tmp___2 = long_to_integer((long )result);
#line 101
    tmp___3 = tmp___2;
    }
  }
#line 101
  return (tmp___3);
}
}
#line 109 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxsock.c"
SCHEME_OBJECT Prim_get_service_by_number(void) 
{ 
  unsigned long tmp ;
  unsigned long tmp___0 ;
  SCHEME_OBJECT tmp___1 ;

  {
  {
#line 112
  while (1) {
    while_continue: /* CIL Label */ ;
#line 112
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 113
  tmp = arg_ulong_integer(1);
#line 113
  tmp___0 = OS_get_service_by_number((unsigned long const   )tmp);
#line 113
  tmp___1 = ulong_to_integer(tmp___0);
  }
#line 113
  return (tmp___1);
}
}
#line 120 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxsock.c"
SCHEME_OBJECT Prim_host_address_length(void) 
{ 
  unsigned int tmp ;
  SCHEME_OBJECT tmp___0 ;

  {
  {
#line 123
  while (1) {
    while_continue: /* CIL Label */ ;
#line 123
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 124
  tmp = OS_host_address_length();
#line 124
  tmp___0 = long_to_integer((long )tmp);
  }
#line 124
  return (tmp___0);
}
}
#line 130 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxsock.c"
SCHEME_OBJECT Prim_get_host_by_name(void) 
{ 
  char **addresses ;
  char *tmp ;
  char **tmp___0 ;
  char **end ;
  char **tmp___1 ;
  SCHEME_OBJECT result ;
  SCHEME_OBJECT tmp___2 ;
  SCHEME_OBJECT *scan_result ;
  unsigned int length ;
  unsigned int tmp___3 ;
  SCHEME_OBJECT *tmp___4 ;
  char **tmp___5 ;

  {
  {
#line 134
  while (1) {
    while_continue: /* CIL Label */ ;
#line 134
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 135
  if (*(stack_pointer + 0) >> 58U == 30UL) {
#line 135
    tmp = (char *)((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 2);
  } else {
    {
#line 135
    error_wrong_type_arg(1);
#line 135
    tmp = (char *)0;
    }
  }
  {
#line 135
  tmp___0 = OS_get_host_by_name((char const   *)tmp);
#line 135
  addresses = tmp___0;
  }
#line 135
  if ((unsigned long )addresses == (unsigned long )((char **)0)) {
#line 135
    return (0UL);
  }
#line 135
  end = addresses;
  {
#line 135
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 135
    tmp___1 = end;
#line 135
    end ++;
#line 135
    if (! ((unsigned long )*tmp___1 != (unsigned long )((char *)0))) {
#line 135
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 135
  end --;
#line 135
  tmp___2 = allocate_marked_vector(10U, (unsigned long )(end - addresses), (_Bool)1);
#line 135
  result = tmp___2;
#line 135
  scan_result = (SCHEME_OBJECT *)(result & 288230376151711743UL) + 1;
#line 135
  tmp___3 = OS_host_address_length();
#line 135
  length = tmp___3;
  }
  {
#line 135
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 135
    if (! ((unsigned long )addresses < (unsigned long )end)) {
#line 135
      goto while_break___1;
    }
    {
#line 135
    tmp___4 = scan_result;
#line 135
    scan_result ++;
#line 135
    tmp___5 = addresses;
#line 135
    addresses ++;
#line 135
    *tmp___4 = memory_to_string((unsigned long )length, (void const   *)((unsigned char *)*tmp___5));
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 135
  return (result);
}
}
#line 158 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxsock.c"
SCHEME_OBJECT Prim_get_host_name(void) 
{ 
  char const   *host_name ;
  char const   *tmp ;
  SCHEME_OBJECT result ;
  SCHEME_OBJECT tmp___0 ;

  {
  {
#line 160
  while (1) {
    while_continue: /* CIL Label */ ;
#line 160
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 161
  tmp = OS_get_host_name();
#line 161
  host_name = tmp;
  }
#line 161
  if ((unsigned long )host_name == (unsigned long )((char const   *)0)) {
#line 161
    return (0UL);
  }
  {
#line 161
  tmp___0 = char_pointer_to_string(host_name);
#line 161
  result = tmp___0;
#line 161
  OS_free((void *)host_name);
  }
#line 161
  return (result);
}
}
#line 174 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxsock.c"
SCHEME_OBJECT Prim_canonical_host_name(void) 
{ 
  char const   *host_name ;
  char *tmp ;
  char const   *tmp___0 ;
  SCHEME_OBJECT result ;
  SCHEME_OBJECT tmp___1 ;

  {
  {
#line 176
  while (1) {
    while_continue: /* CIL Label */ ;
#line 176
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 177
  if (*(stack_pointer + 0) >> 58U == 30UL) {
#line 177
    tmp = (char *)((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 2);
  } else {
    {
#line 177
    error_wrong_type_arg(1);
#line 177
    tmp = (char *)0;
    }
  }
  {
#line 177
  tmp___0 = OS_canonical_host_name((char const   *)tmp);
#line 177
  host_name = tmp___0;
  }
#line 177
  if ((unsigned long )host_name == (unsigned long )((char const   *)0)) {
#line 177
    return (0UL);
  }
  {
#line 177
  tmp___1 = char_pointer_to_string(host_name);
#line 177
  result = tmp___1;
#line 177
  OS_free((void *)host_name);
  }
#line 177
  return (result);
}
}
#line 190 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxsock.c"
SCHEME_OBJECT Prim_get_host_by_address(void) 
{ 
  char const   *host_name ;
  char *tmp ;
  char const   *tmp___0 ;
  SCHEME_OBJECT result ;
  SCHEME_OBJECT tmp___1 ;

  {
  {
#line 192
  while (1) {
    while_continue: /* CIL Label */ ;
#line 192
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 193
  if (*(stack_pointer + 0) >> 58U == 30UL) {
#line 193
    tmp = (char *)((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 2);
  } else {
    {
#line 193
    error_wrong_type_arg(1);
#line 193
    tmp = (char *)0;
    }
  }
  {
#line 193
  tmp___0 = OS_get_host_by_address((char const   *)tmp);
#line 193
  host_name = tmp___0;
  }
#line 193
  if ((unsigned long )host_name == (unsigned long )((char const   *)0)) {
#line 193
    return (0UL);
  }
  {
#line 193
  tmp___1 = char_pointer_to_string(host_name);
#line 193
  result = tmp___1;
#line 193
  OS_free((void *)host_name);
  }
#line 193
  return (result);
}
}
#line 206 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxsock.c"
SCHEME_OBJECT Prim_host_address_any(void) 
{ 
  SCHEME_OBJECT result ;
  unsigned int tmp ;
  SCHEME_OBJECT tmp___0 ;

  {
  {
#line 208
  while (1) {
    while_continue: /* CIL Label */ ;
#line 208
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 209
  tmp = OS_host_address_length();
#line 209
  tmp___0 = allocate_string((unsigned long )tmp);
#line 209
  result = tmp___0;
#line 209
  OS_host_address_any((void *)((char *)((SCHEME_OBJECT *)(result & 288230376151711743UL) + 2)));
  }
#line 209
  return (result);
}
}
#line 217 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxsock.c"
SCHEME_OBJECT Prim_host_address_loopback(void) 
{ 
  SCHEME_OBJECT result ;
  unsigned int tmp ;
  SCHEME_OBJECT tmp___0 ;

  {
  {
#line 219
  while (1) {
    while_continue: /* CIL Label */ ;
#line 219
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 220
  tmp = OS_host_address_length();
#line 220
  tmp___0 = allocate_string((unsigned long )tmp);
#line 220
  result = tmp___0;
#line 220
  OS_host_address_loopback((void *)((char *)((SCHEME_OBJECT *)(result & 288230376151711743UL) + 2)));
  }
#line 220
  return (result);
}
}
#line 228 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxsock.c"
SCHEME_OBJECT Prim_new_open_tcp_stream_socket(void) 
{ 
  long tmp ;
  void *tmp___0 ;
  Tchannel tmp___1 ;

  {
  {
#line 232
  while (1) {
    while_continue: /* CIL Label */ ;
#line 232
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 233
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 233
    if (! (*(stack_pointer + 2) >> 58U == 55UL)) {
      {
#line 233
      error_wrong_type_arg(3);
      }
    }
#line 233
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 234
  tmp = arg_nonnegative_integer(2);
#line 234
  tmp___0 = arg_host(1U);
#line 234
  tmp___1 = OS_open_tcp_stream_socket(tmp___0, (unsigned int )tmp);
#line 234
  *((SCHEME_OBJECT *)(*(stack_pointer + 2) & 288230376151711743UL) + 1) = long_to_integer((long )tmp___1);
  }
#line 234
  return (8UL << 58U);
}
}
#line 245 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxsock.c"
SCHEME_OBJECT Prim_new_open_unix_stream_socket(void) 
{ 
  char *tmp ;
  Tchannel tmp___0 ;

  {
  {
#line 249
  while (1) {
    while_continue: /* CIL Label */ ;
#line 249
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 250
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 250
    if (! (*(stack_pointer + 1) >> 58U == 55UL)) {
      {
#line 250
      error_wrong_type_arg(2);
      }
    }
#line 250
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 252
  if (*(stack_pointer + 0) >> 58U == 30UL) {
#line 252
    tmp = (char *)((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 2);
  } else {
    {
#line 252
    error_wrong_type_arg(1);
#line 252
    tmp = (char *)0;
    }
  }
  {
#line 252
  tmp___0 = OS_open_unix_stream_socket((char const   *)tmp);
#line 252
  *((SCHEME_OBJECT *)(*(stack_pointer + 1) & 288230376151711743UL) + 1) = long_to_integer((long )tmp___0);
  }
#line 258
  return (8UL << 58U);
}
}
#line 261 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxsock.c"
SCHEME_OBJECT Prim_shutdown_socket(void) 
{ 
  unsigned long tmp ;
  Tchannel tmp___0 ;

  {
  {
#line 263
  while (1) {
    while_continue: /* CIL Label */ ;
#line 263
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 264
  tmp = arg_ulong_integer_in_range(2, 1UL, 4UL);
#line 264
  tmp___0 = arg_client_socket(1U);
#line 264
  OS_shutdown_socket(tmp___0, tmp);
  }
#line 264
  return ((8UL << 58U) | 1UL);
}
}
#line 272 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxsock.c"
SCHEME_OBJECT Prim_new_open_tcp_server_socket(void) 
{ 
  Tchannel channel ;
  Tchannel tmp ;
  void *address___0 ;
  unsigned int tmp___0 ;
  void *tmp___1 ;
  long tmp___2 ;

  {
  {
#line 276
  while (1) {
    while_continue: /* CIL Label */ ;
#line 276
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 277
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 277
    if (! (*(stack_pointer + 1) >> 58U == 55UL)) {
      {
#line 277
      error_wrong_type_arg(2);
      }
    }
#line 277
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 278
  tmp = OS_create_tcp_server_socket();
#line 278
  channel = tmp;
#line 278
  tmp___0 = OS_host_address_length();
#line 278
  tmp___1 = OS_malloc((size_t )tmp___0);
#line 278
  address___0 = tmp___1;
#line 278
  OS_host_address_any(address___0);
#line 278
  tmp___2 = arg_nonnegative_integer(1);
#line 278
  OS_bind_tcp_server_socket(channel, address___0, (unsigned int )tmp___2);
#line 278
  OS_free(address___0);
#line 278
  OS_listen_tcp_server_socket(channel);
#line 278
  *((SCHEME_OBJECT *)(*(stack_pointer + 1) & 288230376151711743UL) + 1) = long_to_integer((long )channel);
  }
#line 278
  return (8UL << 58U);
}
}
#line 292 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxsock.c"
SCHEME_OBJECT Prim_create_tcp_server_socket(void) 
{ 
  Tchannel tmp ;
  SCHEME_OBJECT tmp___0 ;

  {
  {
#line 294
  while (1) {
    while_continue: /* CIL Label */ ;
#line 294
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 295
  tmp = OS_create_tcp_server_socket();
#line 295
  tmp___0 = long_to_integer((long )tmp);
  }
#line 295
  return (tmp___0);
}
}
#line 301 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxsock.c"
SCHEME_OBJECT Prim_bind_tcp_server_socket(void) 
{ 
  long tmp ;
  void *tmp___0 ;
  Tchannel tmp___1 ;

  {
  {
#line 303
  while (1) {
    while_continue: /* CIL Label */ ;
#line 303
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 304
  tmp = arg_nonnegative_integer(3);
#line 304
  tmp___0 = arg_host(2U);
#line 304
  tmp___1 = arg_server_socket(1U);
#line 304
  OS_bind_tcp_server_socket(tmp___1, tmp___0, (unsigned int )tmp);
  }
#line 304
  return ((8UL << 58U) | 1UL);
}
}
#line 313 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxsock.c"
SCHEME_OBJECT Prim_listen_tcp_server_socket(void) 
{ 
  Tchannel tmp ;

  {
  {
#line 315
  while (1) {
    while_continue: /* CIL Label */ ;
#line 315
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 316
  tmp = arg_server_socket(1U);
#line 316
  OS_listen_tcp_server_socket(tmp);
  }
#line 316
  return ((8UL << 58U) | 1UL);
}
}
#line 323 "/home/khheo/project/mit-scheme-9.2/src/microcode/pruxsock.c"
SCHEME_OBJECT Prim_new_tcp_server_connection_accept(void) 
{ 
  Tchannel server_socket ;
  Tchannel tmp ;
  void *peer_host ;
  void *tmp___0 ;
  void *tmp___1 ;
  Tchannel connection ;
  Tchannel tmp___2 ;

  {
  {
#line 331
  while (1) {
    while_continue: /* CIL Label */ ;
#line 331
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 332
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 332
    if (! (*(stack_pointer + 2) >> 58U == 55UL)) {
      {
#line 332
      error_wrong_type_arg(3);
      }
    }
#line 332
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 333
  tmp = arg_server_socket(1U);
#line 333
  server_socket = tmp;
  }
#line 333
  if (*(stack_pointer + 1) == 0UL) {
#line 333
    tmp___1 = (void *)0;
  } else {
    {
#line 333
    tmp___0 = arg_host(2U);
#line 333
    tmp___1 = tmp___0;
    }
  }
  {
#line 333
  peer_host = tmp___1;
#line 333
  tmp___2 = OS_server_connection_accept(server_socket, peer_host, (unsigned int *)0);
#line 333
  connection = tmp___2;
  }
#line 333
  if (connection == 4294967295U) {
#line 333
    return (0UL);
  }
  {
#line 333
  *((SCHEME_OBJECT *)(*(stack_pointer + 2) & 288230376151711743UL) + 1) = long_to_integer((long )connection);
  }
#line 333
  return (8UL << 58U);
}
}
#line 38 "/home/khheo/project/mit-scheme-9.2/src/microcode/ostty.h"
cc_t OS_tty_next_interrupt_char(void) ;
#line 36 "/home/khheo/project/mit-scheme-9.2/src/microcode/prostty.c"
SCHEME_OBJECT Prim_tty_input_channel(void) 
{ 
  Tchannel tmp ;
  SCHEME_OBJECT tmp___0 ;

  {
  {
#line 39
  while (1) {
    while_continue: /* CIL Label */ ;
#line 39
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 40
  tmp = OS_tty_input_channel();
#line 40
  tmp___0 = long_to_integer((long )tmp);
  }
#line 40
  return (tmp___0);
}
}
#line 43 "/home/khheo/project/mit-scheme-9.2/src/microcode/prostty.c"
SCHEME_OBJECT Prim_tty_output_channel(void) 
{ 
  Tchannel tmp ;
  SCHEME_OBJECT tmp___0 ;

  {
  {
#line 46
  while (1) {
    while_continue: /* CIL Label */ ;
#line 46
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 47
  tmp = OS_tty_output_channel();
#line 47
  tmp___0 = long_to_integer((long )tmp);
  }
#line 47
  return (tmp___0);
}
}
#line 50 "/home/khheo/project/mit-scheme-9.2/src/microcode/prostty.c"
SCHEME_OBJECT Prim_tty_x_size(void) 
{ 
  unsigned int tmp ;
  SCHEME_OBJECT tmp___0 ;

  {
  {
#line 53
  while (1) {
    while_continue: /* CIL Label */ ;
#line 53
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 54
  tmp = OS_tty_x_size();
#line 54
  tmp___0 = long_to_integer((long )tmp);
  }
#line 54
  return (tmp___0);
}
}
#line 57 "/home/khheo/project/mit-scheme-9.2/src/microcode/prostty.c"
SCHEME_OBJECT Prim_tty_y_size(void) 
{ 
  unsigned int tmp ;
  SCHEME_OBJECT tmp___0 ;

  {
  {
#line 60
  while (1) {
    while_continue: /* CIL Label */ ;
#line 60
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 61
  tmp = OS_tty_y_size();
#line 61
  tmp___0 = long_to_integer((long )tmp);
  }
#line 61
  return (tmp___0);
}
}
#line 64 "/home/khheo/project/mit-scheme-9.2/src/microcode/prostty.c"
SCHEME_OBJECT Prim_tty_command_beep(void) 
{ 
  char const   *tmp ;
  SCHEME_OBJECT tmp___0 ;

  {
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
#line 67
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 68
  tmp = OS_tty_command_beep();
#line 68
  tmp___0 = char_pointer_to_string(tmp);
  }
#line 68
  return (tmp___0);
}
}
#line 71 "/home/khheo/project/mit-scheme-9.2/src/microcode/prostty.c"
SCHEME_OBJECT Prim_tty_command_clear(void) 
{ 
  char const   *tmp ;
  SCHEME_OBJECT tmp___0 ;

  {
  {
#line 74
  while (1) {
    while_continue: /* CIL Label */ ;
#line 74
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 75
  tmp = OS_tty_command_clear();
#line 75
  tmp___0 = char_pointer_to_string(tmp);
  }
#line 75
  return (tmp___0);
}
}
#line 78 "/home/khheo/project/mit-scheme-9.2/src/microcode/prostty.c"
SCHEME_OBJECT Prim_tty_next_interrupt_char(void) 
{ 
  cc_t tmp ;
  SCHEME_OBJECT tmp___0 ;

  {
  {
#line 82
  while (1) {
    while_continue: /* CIL Label */ ;
#line 82
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 83
  tmp = OS_tty_next_interrupt_char();
#line 83
  tmp___0 = long_to_integer((long )tmp);
  }
#line 83
  return (tmp___0);
}
}
#line 86 "/home/khheo/project/mit-scheme-9.2/src/microcode/prostty.c"
SCHEME_OBJECT Prim_tty_get_interrupt_enables(void) 
{ 
  Tinterrupt_enables mask ;
  SCHEME_OBJECT tmp ;

  {
  {
#line 89
  while (1) {
    while_continue: /* CIL Label */ ;
#line 89
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 92
  OS_ctty_get_interrupt_enables(& mask);
#line 93
  tmp = long_to_integer((long )mask);
  }
#line 93
  return (tmp);
}
}
#line 97 "/home/khheo/project/mit-scheme-9.2/src/microcode/prostty.c"
SCHEME_OBJECT Prim_tty_set_interrupt_enables(void) 
{ 
  Tinterrupt_enables mask ;
  long tmp ;

  {
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 100
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 102
  tmp = arg_integer(1);
#line 102
  mask = (Tinterrupt_enables )tmp;
#line 103
  OS_ctty_set_interrupt_enables(& mask);
  }
#line 105
  return ((8UL << 58U) | 1UL);
}
}
#line 108 "/home/khheo/project/mit-scheme-9.2/src/microcode/prostty.c"
SCHEME_OBJECT Prim_tty_get_interrupt_chars(void) 
{ 
  unsigned int i ;
  unsigned int num_chars ;
  unsigned int tmp ;
  SCHEME_OBJECT result ;
  SCHEME_OBJECT tmp___0 ;
  cc_t *int_chars___0 ;
  cc_t *tmp___1 ;
  cc_t *int_handlers___0 ;
  cc_t *tmp___2 ;
  char *scan ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 111
  while (1) {
    while_continue: /* CIL Label */ ;
#line 111
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 114
  tmp = OS_ctty_num_int_chars();
#line 114
  num_chars = tmp;
#line 115
  tmp___0 = allocate_string((unsigned long )(num_chars * 2U));
#line 115
  result = tmp___0;
#line 116
  tmp___1 = OS_ctty_get_int_chars();
#line 116
  int_chars___0 = tmp___1;
#line 117
  tmp___2 = OS_ctty_get_int_char_handlers();
#line 117
  int_handlers___0 = tmp___2;
#line 118
  scan = (char *)((SCHEME_OBJECT *)(result & 288230376151711743UL) + 2);
#line 120
  i = 0U;
  }
  {
#line 120
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 120
    if (! (i < num_chars)) {
#line 120
      goto while_break___0;
    }
#line 122
    tmp___3 = scan;
#line 122
    scan ++;
#line 122
    *tmp___3 = (char )*(int_chars___0 + i);
#line 123
    tmp___4 = scan;
#line 123
    scan ++;
#line 123
    *tmp___4 = (char )*(int_handlers___0 + i);
#line 120
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 125
  return (result);
}
}
#line 129 "/home/khheo/project/mit-scheme-9.2/src/microcode/prostty.c"
SCHEME_OBJECT Prim_tty_set_interrupt_chars(void) 
{ 
  unsigned int i ;
  unsigned int num_chars ;
  unsigned int tmp ;
  cc_t *int_chars___0 ;
  cc_t *tmp___0 ;
  cc_t *int_handlers___0 ;
  cc_t *tmp___1 ;
  SCHEME_OBJECT argument ;
  char *scan ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 133
  while (1) {
    while_continue: /* CIL Label */ ;
#line 133
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 136
  tmp = OS_ctty_num_int_chars();
#line 136
  num_chars = tmp;
#line 137
  tmp___0 = OS_ctty_get_int_chars();
#line 137
  int_chars___0 = tmp___0;
#line 138
  tmp___1 = OS_ctty_get_int_char_handlers();
#line 138
  int_handlers___0 = tmp___1;
#line 139
  argument = *(stack_pointer + 0);
  }
#line 142
  if (argument >> 58U == 30UL) {
#line 142
    if (! ((unsigned int )(*((SCHEME_OBJECT *)(argument & 288230376151711743UL) + 1) & 288230376151711743UL) == num_chars * 2U)) {
      {
#line 145
      error_wrong_type_arg(1);
      }
    }
  } else {
    {
#line 145
    error_wrong_type_arg(1);
    }
  }
#line 147
  i = 0U;
#line 147
  scan = (char *)((SCHEME_OBJECT *)(argument & 288230376151711743UL) + 2);
  {
#line 147
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 147
    if (! (i < num_chars)) {
#line 147
      goto while_break___0;
    }
#line 149
    tmp___2 = scan;
#line 149
    scan ++;
#line 149
    *(int_chars___0 + i) = (cc_t )*tmp___2;
#line 150
    tmp___3 = scan;
#line 150
    scan ++;
#line 150
    *(int_handlers___0 + i) = (cc_t )*tmp___3;
#line 147
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 152
  OS_ctty_set_int_chars(int_chars___0);
#line 153
  OS_ctty_set_int_char_handlers(int_handlers___0);
  }
#line 155
  return ((8UL << 58U) | 1UL);
}
}
#line 32 "/home/khheo/project/mit-scheme-9.2/src/microcode/osterm.h"
Tchannel arg_terminal(int argument_number ) ;
#line 35 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosterm.c"
Tchannel arg_terminal(int argument_number ) 
{ 
  Tchannel channel ;
  Tchannel tmp ;
  enum channel_type type ;
  enum channel_type tmp___0 ;

  {
  {
#line 38
  tmp = arg_channel(argument_number);
#line 38
  channel = tmp;
#line 39
  tmp___0 = OS_channel_type(channel);
#line 39
  type = tmp___0;
  }
#line 40
  if (! ((unsigned int )type == 4U)) {
#line 40
    if (! ((unsigned int )type == 5U)) {
#line 40
      if (! ((unsigned int )type == 12U)) {
        {
#line 43
        error_bad_range_arg(argument_number);
        }
      }
    }
  }
#line 44
  return (channel);
}
}
#line 47 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosterm.c"
SCHEME_OBJECT Prim_terminal_get_ispeed(void) 
{ 
  Tchannel tmp ;
  unsigned int tmp___0 ;
  SCHEME_OBJECT tmp___1 ;

  {
  {
#line 49
  while (1) {
    while_continue: /* CIL Label */ ;
#line 49
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 50
  tmp = arg_terminal(1);
#line 50
  tmp___0 = OS_terminal_get_ispeed(tmp);
#line 50
  tmp___1 = long_to_integer((long )tmp___0);
  }
#line 50
  return (tmp___1);
}
}
#line 54 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosterm.c"
SCHEME_OBJECT Prim_terminal_get_ospeed(void) 
{ 
  Tchannel tmp ;
  unsigned int tmp___0 ;
  SCHEME_OBJECT tmp___1 ;

  {
  {
#line 56
  while (1) {
    while_continue: /* CIL Label */ ;
#line 56
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 57
  tmp = arg_terminal(1);
#line 57
  tmp___0 = OS_terminal_get_ospeed(tmp);
#line 57
  tmp___1 = long_to_integer((long )tmp___0);
  }
#line 57
  return (tmp___1);
}
}
#line 61 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosterm.c"
SCHEME_OBJECT Prim_terminal_set_ispeed(void) 
{ 
  unsigned int tmp ;
  Tchannel tmp___0 ;

  {
  {
#line 63
  while (1) {
    while_continue: /* CIL Label */ ;
#line 63
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 64
  tmp = arg_baud_index(2U);
#line 64
  tmp___0 = arg_terminal(1);
#line 64
  OS_terminal_set_ispeed(tmp___0, tmp);
  }
#line 65
  return ((8UL << 58U) | 1UL);
}
}
#line 68 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosterm.c"
SCHEME_OBJECT Prim_terminal_set_ospeed(void) 
{ 
  unsigned int tmp ;
  Tchannel tmp___0 ;

  {
  {
#line 70
  while (1) {
    while_continue: /* CIL Label */ ;
#line 70
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 71
  tmp = arg_baud_index(2U);
#line 71
  tmp___0 = arg_terminal(1);
#line 71
  OS_terminal_set_ospeed(tmp___0, tmp);
  }
#line 72
  return ((8UL << 58U) | 1UL);
}
}
#line 75 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosterm.c"
SCHEME_OBJECT Prim_baud_index_to_rate(void) 
{ 
  unsigned int tmp ;
  unsigned int tmp___0 ;
  SCHEME_OBJECT tmp___1 ;

  {
  {
#line 77
  while (1) {
    while_continue: /* CIL Label */ ;
#line 77
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 78
  tmp = arg_baud_index(1U);
#line 78
  tmp___0 = OS_baud_index_to_rate(tmp);
#line 78
  tmp___1 = long_to_integer((long )tmp___0);
  }
#line 78
  return (tmp___1);
}
}
#line 82 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosterm.c"
SCHEME_OBJECT Prim_baud_rate_to_index(void) 
{ 
  int index___0 ;
  long tmp ;
  int tmp___0 ;
  SCHEME_OBJECT tmp___1 ;

  {
  {
#line 84
  while (1) {
    while_continue: /* CIL Label */ ;
#line 84
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 86
  tmp = arg_nonnegative_integer(1);
#line 86
  tmp___0 = OS_baud_rate_to_index((unsigned int )tmp);
#line 86
  index___0 = tmp___0;
  }
#line 87
  if (index___0 < 0) {
    {
#line 88
    error_bad_range_arg(1);
    }
  }
  {
#line 89
  tmp___1 = long_to_integer((long )index___0);
  }
#line 89
  return (tmp___1);
}
}
#line 93 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosterm.c"
SCHEME_OBJECT Prim_terminal_get_state(void) 
{ 
  SCHEME_OBJECT result ;
  unsigned int tmp ;
  SCHEME_OBJECT tmp___0 ;
  Tchannel tmp___1 ;

  {
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;
#line 95
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 97
  tmp = OS_terminal_state_size();
#line 97
  tmp___0 = allocate_string((unsigned long )tmp);
#line 97
  result = tmp___0;
#line 98
  tmp___1 = arg_terminal(1);
#line 98
  OS_terminal_get_state(tmp___1, (void *)((char *)((SCHEME_OBJECT *)(result & 288230376151711743UL) + 2)));
  }
#line 99
  return (result);
}
}
#line 103 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosterm.c"
SCHEME_OBJECT Prim_terminal_set_state(void) 
{ 
  SCHEME_OBJECT state ;
  unsigned int tmp ;
  Tchannel tmp___0 ;

  {
  {
#line 105
  while (1) {
    while_continue: /* CIL Label */ ;
#line 105
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 106
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 106
    if (! (*(stack_pointer + 1) >> 58U == 30UL)) {
      {
#line 106
      error_wrong_type_arg(2);
      }
    }
#line 106
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 108
  state = *(stack_pointer + 1);
#line 109
  tmp = OS_terminal_state_size();
  }
#line 109
  if ((unsigned int )(*((SCHEME_OBJECT *)(state & 288230376151711743UL) + 1) & 288230376151711743UL) != tmp) {
    {
#line 111
    error_bad_range_arg(2);
    }
  }
  {
#line 112
  tmp___0 = arg_terminal(1);
#line 112
  OS_terminal_set_state(tmp___0, (void *)((char *)((SCHEME_OBJECT *)(state & 288230376151711743UL) + 2)));
  }
#line 114
  return ((8UL << 58U) | 1UL);
}
}
#line 117 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosterm.c"
SCHEME_OBJECT Prim_terminal_cooked_output_p(void) 
{ 
  unsigned long tmp___1 ;
  Tchannel tmp___2 ;
  int tmp___3 ;

  {
  {
#line 120
  while (1) {
    while_continue: /* CIL Label */ ;
#line 120
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 121
  tmp___2 = arg_terminal(1);
#line 121
  tmp___3 = OS_terminal_cooked_output_p(tmp___2);
  }
#line 121
  if (tmp___3) {
#line 121
    tmp___1 = 8UL << 58U;
  } else {
#line 121
    tmp___1 = 0UL;
  }
#line 121
  return (tmp___1);
}
}
#line 125 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosterm.c"
SCHEME_OBJECT Prim_terminal_raw_output(void) 
{ 
  Tchannel tmp ;

  {
  {
#line 128
  while (1) {
    while_continue: /* CIL Label */ ;
#line 128
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 129
  tmp = arg_terminal(1);
#line 129
  OS_terminal_raw_output(tmp);
  }
#line 130
  return ((8UL << 58U) | 1UL);
}
}
#line 133 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosterm.c"
SCHEME_OBJECT Prim_terminal_cooked_output(void) 
{ 
  Tchannel tmp ;

  {
  {
#line 136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 136
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 137
  tmp = arg_terminal(1);
#line 137
  OS_terminal_cooked_output(tmp);
  }
#line 138
  return ((8UL << 58U) | 1UL);
}
}
#line 141 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosterm.c"
SCHEME_OBJECT Prim_terminal_buffered_p(void) 
{ 
  unsigned long tmp___1 ;
  Tchannel tmp___2 ;
  int tmp___3 ;

  {
  {
#line 144
  while (1) {
    while_continue: /* CIL Label */ ;
#line 144
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 145
  tmp___2 = arg_terminal(1);
#line 145
  tmp___3 = OS_terminal_buffered_p(tmp___2);
  }
#line 145
  if (tmp___3) {
#line 145
    tmp___1 = 8UL << 58U;
  } else {
#line 145
    tmp___1 = 0UL;
  }
#line 145
  return (tmp___1);
}
}
#line 149 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosterm.c"
SCHEME_OBJECT Prim_terminal_buffered(void) 
{ 
  Tchannel tmp ;

  {
  {
#line 152
  while (1) {
    while_continue: /* CIL Label */ ;
#line 152
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 153
  tmp = arg_terminal(1);
#line 153
  OS_terminal_buffered(tmp);
  }
#line 154
  return ((8UL << 58U) | 1UL);
}
}
#line 157 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosterm.c"
SCHEME_OBJECT Prim_terminal_nonbuffered(void) 
{ 
  Tchannel tmp ;

  {
  {
#line 160
  while (1) {
    while_continue: /* CIL Label */ ;
#line 160
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 161
  tmp = arg_terminal(1);
#line 161
  OS_terminal_nonbuffered(tmp);
  }
#line 162
  return ((8UL << 58U) | 1UL);
}
}
#line 165 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosterm.c"
SCHEME_OBJECT Prim_terminal_flush_input(void) 
{ 
  Tchannel tmp ;

  {
  {
#line 168
  while (1) {
    while_continue: /* CIL Label */ ;
#line 168
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 169
  tmp = arg_terminal(1);
#line 169
  OS_terminal_flush_input(tmp);
  }
#line 170
  return ((8UL << 58U) | 1UL);
}
}
#line 173 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosterm.c"
SCHEME_OBJECT Prim_terminal_flush_output(void) 
{ 
  Tchannel tmp ;

  {
  {
#line 176
  while (1) {
    while_continue: /* CIL Label */ ;
#line 176
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 177
  tmp = arg_terminal(1);
#line 177
  OS_terminal_flush_output(tmp);
  }
#line 178
  return ((8UL << 58U) | 1UL);
}
}
#line 181 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosterm.c"
SCHEME_OBJECT Prim_terminal_drain_output(void) 
{ 
  Tchannel tmp ;

  {
  {
#line 184
  while (1) {
    while_continue: /* CIL Label */ ;
#line 184
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 185
  tmp = arg_terminal(1);
#line 185
  OS_terminal_drain_output(tmp);
  }
#line 186
  return ((8UL << 58U) | 1UL);
}
}
#line 189 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosterm.c"
SCHEME_OBJECT Prim_os_job_control_p(void) 
{ 
  unsigned long tmp___0 ;
  int tmp___1 ;

  {
  {
#line 191
  while (1) {
    while_continue: /* CIL Label */ ;
#line 191
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 192
  tmp___1 = OS_job_control_p();
  }
#line 192
  if (tmp___1) {
#line 192
    tmp___0 = 8UL << 58U;
  } else {
#line 192
    tmp___0 = 0UL;
  }
#line 192
  return (tmp___0);
}
}
#line 195 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosterm.c"
SCHEME_OBJECT Prim_have_ptys_p(void) 
{ 
  unsigned long tmp___0 ;
  int tmp___1 ;

  {
  {
#line 197
  while (1) {
    while_continue: /* CIL Label */ ;
#line 197
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 198
  tmp___1 = OS_have_ptys_p();
  }
#line 198
  if (tmp___1) {
#line 198
    tmp___0 = 8UL << 58U;
  } else {
#line 198
    tmp___0 = 0UL;
  }
#line 198
  return (tmp___0);
}
}
#line 36 "/home/khheo/project/mit-scheme-9.2/src/microcode/prospty.c"
static Tchannel arg_pty_master(unsigned int arg ) 
{ 
  Tchannel channel ;
  Tchannel tmp ;
  enum channel_type tmp___0 ;

  {
  {
#line 39
  tmp = arg_channel(1);
#line 39
  channel = tmp;
#line 40
  tmp___0 = OS_channel_type(channel);
  }
#line 40
  if ((unsigned int )tmp___0 != 5U) {
    {
#line 41
    error_bad_range_arg(1);
    }
  }
#line 42
  return (channel);
}
}
#line 45 "/home/khheo/project/mit-scheme-9.2/src/microcode/prospty.c"
SCHEME_OBJECT Prim_open_pty_master(void) 
{ 
  Tchannel channel ;
  char const   *master_name ;
  char const   *slave_name___0 ;
  char const   *tmp ;
  SCHEME_OBJECT vector ;
  SCHEME_OBJECT tmp___0 ;

  {
  {
#line 49
  while (1) {
    while_continue: /* CIL Label */ ;
#line 49
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 53
  tmp = OS_open_pty_master(& channel, & master_name);
#line 53
  slave_name___0 = tmp;
#line 55
  transaction_begin();
#line 56
  OS_channel_close_on_abort(channel);
#line 58
  tmp___0 = allocate_marked_vector(10U, 3UL, (_Bool)1);
#line 58
  vector = tmp___0;
#line 59
  *((SCHEME_OBJECT *)(vector & 288230376151711743UL) + 1) = long_to_integer((long )channel);
#line 60
  *((SCHEME_OBJECT *)(vector & 288230376151711743UL) + 2) = char_pointer_to_string(master_name);
#line 61
  *((SCHEME_OBJECT *)(vector & 288230376151711743UL) + 3) = char_pointer_to_string(slave_name___0);
#line 62
  transaction_commit();
  }
#line 63
  return (vector);
}
}
#line 68 "/home/khheo/project/mit-scheme-9.2/src/microcode/prospty.c"
SCHEME_OBJECT Prim_pty_master_send_signal(void) 
{ 
  long tmp ;
  Tchannel tmp___0 ;

  {
  {
#line 71
  while (1) {
    while_continue: /* CIL Label */ ;
#line 71
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 72
  tmp = arg_nonnegative_integer(2);
#line 72
  tmp___0 = arg_pty_master(1U);
#line 72
  OS_pty_master_send_signal(tmp___0, (int )tmp);
  }
#line 74
  return ((8UL << 58U) | 1UL);
}
}
#line 77 "/home/khheo/project/mit-scheme-9.2/src/microcode/prospty.c"
SCHEME_OBJECT Prim_pty_master_kill(void) 
{ 
  Tchannel tmp ;

  {
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
#line 79
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 80
  tmp = arg_pty_master(1U);
#line 80
  OS_pty_master_kill(tmp);
  }
#line 81
  return ((8UL << 58U) | 1UL);
}
}
#line 84 "/home/khheo/project/mit-scheme-9.2/src/microcode/prospty.c"
SCHEME_OBJECT Prim_pty_master_stop(void) 
{ 
  Tchannel tmp ;

  {
  {
#line 86
  while (1) {
    while_continue: /* CIL Label */ ;
#line 86
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 87
  tmp = arg_pty_master(1U);
#line 87
  OS_pty_master_stop(tmp);
  }
#line 88
  return ((8UL << 58U) | 1UL);
}
}
#line 91 "/home/khheo/project/mit-scheme-9.2/src/microcode/prospty.c"
SCHEME_OBJECT Prim_pty_master_continue(void) 
{ 
  Tchannel tmp ;

  {
  {
#line 93
  while (1) {
    while_continue: /* CIL Label */ ;
#line 93
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 94
  tmp = arg_pty_master(1U);
#line 94
  OS_pty_master_continue(tmp);
  }
#line 95
  return ((8UL << 58U) | 1UL);
}
}
#line 98 "/home/khheo/project/mit-scheme-9.2/src/microcode/prospty.c"
SCHEME_OBJECT Prim_pty_master_interrupt(void) 
{ 
  Tchannel tmp ;

  {
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 100
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 101
  tmp = arg_pty_master(1U);
#line 101
  OS_pty_master_interrupt(tmp);
  }
#line 102
  return ((8UL << 58U) | 1UL);
}
}
#line 105 "/home/khheo/project/mit-scheme-9.2/src/microcode/prospty.c"
SCHEME_OBJECT Prim_pty_master_quit(void) 
{ 
  Tchannel tmp ;

  {
  {
#line 107
  while (1) {
    while_continue: /* CIL Label */ ;
#line 107
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 108
  tmp = arg_pty_master(1U);
#line 108
  OS_pty_master_quit(tmp);
  }
#line 109
  return ((8UL << 58U) | 1UL);
}
}
#line 112 "/home/khheo/project/mit-scheme-9.2/src/microcode/prospty.c"
SCHEME_OBJECT Prim_pty_master_hangup(void) 
{ 
  Tchannel tmp ;

  {
  {
#line 114
  while (1) {
    while_continue: /* CIL Label */ ;
#line 114
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 115
  tmp = arg_pty_master(1U);
#line 115
  OS_pty_master_hangup(tmp);
  }
#line 116
  return ((8UL << 58U) | 1UL);
}
}
#line 167 "/home/khheo/project/mit-scheme-9.2/src/microcode/obstack.h"
void obstack_free(struct obstack *h , void *obj ) ;
#line 184 "/home/khheo/project/mit-scheme-9.2/src/microcode/extern.h"
struct obstack scratch_obstack ;
#line 40 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosproc.c"
static Tprocess arg_process(int argument_number ) 
{ 
  Tprocess process ;
  unsigned long tmp ;
  int tmp___0 ;

  {
  {
#line 43
  tmp = arg_ulong_integer(argument_number);
#line 43
  process = (Tprocess )tmp;
#line 44
  tmp___0 = OS_process_valid_p(process);
  }
#line 44
  if (! tmp___0) {
    {
#line 45
    error_bad_range_arg(argument_number);
    }
  }
#line 46
  return (process);
}
}
#line 49 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosproc.c"
SCHEME_OBJECT Prim_scheme_environment(void) 
{ 
  char **scan_environ ;
  char **end_environ ;
  SCHEME_OBJECT result ;
  SCHEME_OBJECT tmp ;
  SCHEME_OBJECT *scan_result ;
  SCHEME_OBJECT *tmp___0 ;
  char **tmp___1 ;

  {
  {
#line 51
  while (1) {
    while_continue: /* CIL Label */ ;
#line 51
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 53
  scan_environ = environ;
#line 54
  end_environ = scan_environ;
  {
#line 55
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 55
    if (! ((unsigned long )*end_environ != (unsigned long )((char *)0))) {
#line 55
      goto while_break___0;
    }
#line 56
    end_environ ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 58
  tmp = allocate_marked_vector(10U, (unsigned long )(end_environ - environ), (_Bool)1);
#line 58
  result = tmp;
#line 60
  scan_result = (SCHEME_OBJECT *)(result & 288230376151711743UL) + 1;
  }
  {
#line 61
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 61
    if (! ((unsigned long )scan_environ < (unsigned long )end_environ)) {
#line 61
      goto while_break___1;
    }
    {
#line 62
    tmp___0 = scan_result;
#line 62
    scan_result ++;
#line 62
    tmp___1 = scan_environ;
#line 62
    scan_environ ++;
#line 62
    *tmp___0 = char_pointer_to_string((char const   *)*tmp___1);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 63
  return (result);
}
}
#line 68 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosproc.c"
SCHEME_OBJECT Prim_process_delete(void) 
{ 
  Tprocess tmp ;

  {
  {
#line 71
  while (1) {
    while_continue: /* CIL Label */ ;
#line 71
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 72
  tmp = arg_process(1);
#line 72
  OS_process_deallocate(tmp);
  }
#line 73
  return ((8UL << 58U) | 1UL);
}
}
#line 76 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosproc.c"
SCHEME_OBJECT Prim_process_table(void) 
{ 
  Tprocess process ;
  struct obstack *__o ;
  int __len ;
  int tmp ;
  unsigned int n_processes ;
  struct obstack *__o___0 ;
  Tprocess *processes ;
  struct obstack *__o___1 ;
  void *value ;
  Tprocess *scan_processes ;
  SCHEME_OBJECT vector ;
  SCHEME_OBJECT tmp___0 ;
  SCHEME_OBJECT *scan_vector ;
  SCHEME_OBJECT *end_vector ;
  SCHEME_OBJECT *tmp___1 ;
  Tprocess *tmp___2 ;
  struct obstack *__o___2 ;
  void *__obj ;
  char *tmp___3 ;

  {
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
#line 79
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 82
  process = (Tprocess )0;
  {
#line 82
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 82
    if (! (process < OS_process_table_size)) {
#line 82
      goto while_break___0;
    }
    {
#line 83
    tmp = OS_process_valid_p(process);
    }
#line 83
    if (tmp) {
#line 84
      __o = & scratch_obstack;
#line 84
      __len = (int )sizeof(Tprocess );
#line 84
      if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
        {
#line 84
        _obstack_newchunk(__o, __len);
        }
      }
      {
#line 84
      memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)(& process),
             (size_t )__len);
#line 84
      __o->next_free += __len;
      }
    }
#line 82
    process ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 88
  __o___0 = & scratch_obstack;
#line 88
  n_processes = (unsigned int )((unsigned long )((unsigned int )(__o___0->next_free - __o___0->object_base)) / sizeof(Tprocess ));
#line 89
  if (n_processes == 0U) {
#line 90
    return (0UL);
  }
#line 92
  __o___1 = & scratch_obstack;
#line 92
  value = (void *)__o___1->object_base;
#line 92
  __o___1->next_free = (char *)((void *)((char *)0 + (((__o___1->next_free - (char *)0) + __o___1->alignment_mask) & ~ __o___1->alignment_mask)));
#line 92
  if (__o___1->next_free - (char *)__o___1->chunk > __o___1->chunk_limit - (char *)__o___1->chunk) {
#line 92
    __o___1->next_free = __o___1->chunk_limit;
  }
  {
#line 92
  __o___1->object_base = __o___1->next_free;
#line 92
  processes = (Tprocess *)value;
#line 93
  scan_processes = processes;
#line 94
  tmp___0 = allocate_marked_vector(10U, (unsigned long )n_processes, (_Bool)1);
#line 94
  vector = tmp___0;
#line 96
  scan_vector = (SCHEME_OBJECT *)(vector & 288230376151711743UL) + 1;
#line 97
  end_vector = scan_vector + n_processes;
  }
  {
#line 98
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 98
    if (! ((unsigned long )scan_vector < (unsigned long )end_vector)) {
#line 98
      goto while_break___1;
    }
    {
#line 99
    tmp___1 = scan_vector;
#line 99
    scan_vector ++;
#line 99
    tmp___2 = scan_processes;
#line 99
    scan_processes ++;
#line 99
    *tmp___1 = long_to_integer((long )*tmp___2);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 100
  __o___2 = & scratch_obstack;
#line 100
  __obj = (void *)processes;
#line 100
  if ((unsigned long )__obj > (unsigned long )((void *)__o___2->chunk)) {
#line 100
    if ((unsigned long )__obj < (unsigned long )((void *)__o___2->chunk_limit)) {
#line 100
      tmp___3 = (char *)__obj;
#line 100
      __o___2->object_base = tmp___3;
#line 100
      __o___2->next_free = tmp___3;
    } else {
      {
#line 100
      obstack_free(__o___2, __obj);
      }
    }
  } else {
    {
#line 100
    obstack_free(__o___2, __obj);
    }
  }
#line 101
  return (vector);
}
}
#line 106 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosproc.c"
SCHEME_OBJECT Prim_process_id(void) 
{ 
  Tprocess tmp ;
  pid_t tmp___0 ;
  SCHEME_OBJECT tmp___1 ;

  {
  {
#line 109
  while (1) {
    while_continue: /* CIL Label */ ;
#line 109
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 110
  tmp = arg_process(1);
#line 110
  tmp___0 = OS_process_id(tmp);
#line 110
  tmp___1 = ulong_to_integer((unsigned long )tmp___0);
  }
#line 110
  return (tmp___1);
}
}
#line 113 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosproc.c"
SCHEME_OBJECT Prim_process_jc_status(void) 
{ 
  Tprocess tmp ;
  enum process_jc_status tmp___0 ;

  {
  {
#line 120
  while (1) {
    while_continue: /* CIL Label */ ;
#line 120
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 121
  tmp = arg_process(1);
#line 121
  tmp___0 = OS_process_jc_status(tmp);
  }
  {
#line 123
  if ((unsigned int )tmp___0 == 0U) {
#line 123
    goto case_0;
  }
#line 125
  if ((unsigned int )tmp___0 == 1U) {
#line 125
    goto case_1;
  }
#line 127
  if ((unsigned int )tmp___0 == 2U) {
#line 127
    goto case_2;
  }
#line 129
  if ((unsigned int )tmp___0 == 3U) {
#line 129
    goto case_3;
  }
#line 131
  goto switch_default;
  case_0: /* CIL Label */ 
#line 124
  return (26UL << 58U);
  case_1: /* CIL Label */ 
#line 126
  return ((26UL << 58U) | 1UL);
  case_2: /* CIL Label */ 
#line 128
  return ((26UL << 58U) | 2UL);
  case_3: /* CIL Label */ 
#line 130
  return ((26UL << 58U) | 3UL);
  switch_default: /* CIL Label */ 
  {
#line 132
  error_bad_range_arg(1);
  }
#line 133
  return ((8UL << 58U) | 1UL);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 137 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosproc.c"
SCHEME_OBJECT Prim_process_status_sync(void) 
{ 
  unsigned long tmp___1 ;
  Tprocess tmp___2 ;
  int tmp___3 ;

  {
  {
#line 141
  while (1) {
    while_continue: /* CIL Label */ ;
#line 141
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 142
  tmp___2 = arg_process(1);
#line 142
  tmp___3 = OS_process_status_sync(tmp___2);
  }
#line 142
  if (tmp___3) {
#line 142
    tmp___1 = 8UL << 58U;
  } else {
#line 142
    tmp___1 = 0UL;
  }
#line 142
  return (tmp___1);
}
}
#line 146 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosproc.c"
SCHEME_OBJECT Prim_process_status_sync_all(void) 
{ 
  unsigned long tmp___0 ;
  int tmp___1 ;

  {
  {
#line 148
  while (1) {
    while_continue: /* CIL Label */ ;
#line 148
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 149
  tmp___1 = OS_process_status_sync_all();
  }
#line 149
  if (tmp___1) {
#line 149
    tmp___0 = 8UL << 58U;
  } else {
#line 149
    tmp___0 = 0UL;
  }
#line 149
  return (tmp___0);
}
}
#line 152 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosproc.c"
SCHEME_OBJECT Prim_process_status(void) 
{ 
  Tprocess tmp ;
  enum process_status tmp___0 ;

  {
  {
#line 157
  while (1) {
    while_continue: /* CIL Label */ ;
#line 157
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 158
  tmp = arg_process(1);
#line 158
  tmp___0 = OS_process_status(tmp);
  }
  {
#line 160
  if ((unsigned int )tmp___0 == 2U) {
#line 160
    goto case_2;
  }
#line 162
  if ((unsigned int )tmp___0 == 3U) {
#line 162
    goto case_3;
  }
#line 164
  if ((unsigned int )tmp___0 == 4U) {
#line 164
    goto case_4;
  }
#line 166
  if ((unsigned int )tmp___0 == 5U) {
#line 166
    goto case_5;
  }
#line 168
  goto switch_default;
  case_2: /* CIL Label */ 
#line 161
  return (26UL << 58U);
  case_3: /* CIL Label */ 
#line 163
  return ((26UL << 58U) | 1UL);
  case_4: /* CIL Label */ 
#line 165
  return ((26UL << 58U) | 2UL);
  case_5: /* CIL Label */ 
#line 167
  return ((26UL << 58U) | 3UL);
  switch_default: /* CIL Label */ 
  {
#line 169
  error_external_return();
  }
#line 170
  return ((8UL << 58U) | 1UL);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 174 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosproc.c"
SCHEME_OBJECT Prim_process_reason(void) 
{ 
  Tprocess tmp ;
  unsigned short tmp___0 ;
  SCHEME_OBJECT tmp___1 ;

  {
  {
#line 183
  while (1) {
    while_continue: /* CIL Label */ ;
#line 183
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 184
  tmp = arg_process(1);
#line 184
  tmp___0 = OS_process_reason(tmp);
#line 184
  tmp___1 = long_to_integer((long )tmp___0);
  }
#line 184
  return (tmp___1);
}
}
#line 187 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosproc.c"
SCHEME_OBJECT Prim_process_signal(void) 
{ 
  long tmp ;
  Tprocess tmp___0 ;

  {
  {
#line 190
  while (1) {
    while_continue: /* CIL Label */ ;
#line 190
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 191
  tmp = arg_nonnegative_integer(2);
#line 191
  tmp___0 = arg_process(1);
#line 191
  OS_process_send_signal(tmp___0, (int )tmp);
  }
#line 192
  return ((8UL << 58U) | 1UL);
}
}
#line 202 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosproc.c"
SCHEME_OBJECT Prim_process_kill(void) 
{ 
  Tprocess tmp ;

  {
  {
#line 204
  while (1) {
    while_continue: /* CIL Label */ ;
#line 204
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 204
  tmp = arg_process(1);
#line 204
  OS_process_kill(tmp);
  }
#line 204
  return ((8UL << 58U) | 1UL);
}
}
#line 206 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosproc.c"
SCHEME_OBJECT Prim_process_interrupt(void) 
{ 
  Tprocess tmp ;

  {
  {
#line 208
  while (1) {
    while_continue: /* CIL Label */ ;
#line 208
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 208
  tmp = arg_process(1);
#line 208
  OS_process_interrupt(tmp);
  }
#line 208
  return ((8UL << 58U) | 1UL);
}
}
#line 210 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosproc.c"
SCHEME_OBJECT Prim_process_quit(void) 
{ 
  Tprocess tmp ;

  {
  {
#line 212
  while (1) {
    while_continue: /* CIL Label */ ;
#line 212
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 212
  tmp = arg_process(1);
#line 212
  OS_process_quit(tmp);
  }
#line 212
  return ((8UL << 58U) | 1UL);
}
}
#line 214 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosproc.c"
SCHEME_OBJECT Prim_process_hangup(void) 
{ 
  Tprocess tmp ;

  {
  {
#line 216
  while (1) {
    while_continue: /* CIL Label */ ;
#line 216
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 216
  tmp = arg_process(1);
#line 216
  OS_process_hangup(tmp);
  }
#line 216
  return ((8UL << 58U) | 1UL);
}
}
#line 218 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosproc.c"
SCHEME_OBJECT Prim_process_stop(void) 
{ 
  Tprocess tmp ;

  {
  {
#line 220
  while (1) {
    while_continue: /* CIL Label */ ;
#line 220
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 220
  tmp = arg_process(1);
#line 220
  OS_process_stop(tmp);
  }
#line 220
  return ((8UL << 58U) | 1UL);
}
}
#line 222 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosproc.c"
SCHEME_OBJECT Prim_process_continue_background(void) 
{ 
  Tprocess process ;
  Tprocess tmp ;
  int tmp___0 ;

  {
  {
#line 225
  while (1) {
    while_continue: /* CIL Label */ ;
#line 225
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 227
  tmp = arg_process(1);
#line 227
  process = tmp;
#line 228
  tmp___0 = OS_process_continuable_p(process);
  }
#line 228
  if (! tmp___0) {
    {
#line 229
    error_bad_range_arg(1);
    }
  }
  {
#line 230
  OS_process_continue_background(process);
  }
#line 232
  return ((8UL << 58U) | 1UL);
}
}
#line 235 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosproc.c"
SCHEME_OBJECT Prim_process_wait(void) 
{ 
  Tprocess tmp ;

  {
  {
#line 238
  while (1) {
    while_continue: /* CIL Label */ ;
#line 238
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 239
  tmp = arg_process(1);
#line 239
  OS_process_wait(tmp);
  }
#line 240
  return ((8UL << 58U) | 1UL);
}
}
#line 243 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosproc.c"
SCHEME_OBJECT Prim_process_continue_foreground(void) 
{ 
  Tprocess process ;
  Tprocess tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 247
  while (1) {
    while_continue: /* CIL Label */ ;
#line 247
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 249
  tmp = arg_process(1);
#line 249
  process = tmp;
#line 250
  tmp___0 = OS_process_foregroundable_p(process);
  }
#line 250
  if (tmp___0) {
    {
#line 250
    tmp___1 = OS_process_continuable_p(process);
    }
#line 250
    if (! tmp___1) {
      {
#line 252
      error_bad_range_arg(1);
      }
    }
  } else {
    {
#line 252
    error_bad_range_arg(1);
    }
  }
  {
#line 253
  OS_process_continue_foreground(process);
  }
#line 254
  return ((8UL << 58U) | 1UL);
}
}
#line 260
static int string_vector_p___0(SCHEME_OBJECT vector ) ;
#line 261
static char const   **convert_string_vector___0(SCHEME_OBJECT vector ) ;
#line 282 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosproc.c"
SCHEME_OBJECT Prim_make_subprocess(void) 
{ 
  int tmp ;
  void *position___1 ;
  char const   *filename ;
  char *tmp___0 ;
  char const   **argv ;
  char const   **tmp___1 ;
  SCHEME_OBJECT env_object ;
  char const   **env ;
  char const   *working_directory ;
  enum process_ctty_type ctty_type ;
  char *ctty_name ;
  enum process_channel_type channel_in_type ;
  Tchannel channel_in ;
  enum process_channel_type channel_out_type ;
  Tchannel channel_out ;
  enum process_channel_type channel_err_type ;
  Tchannel channel_err ;
  int tmp___2 ;
  Tprocess process ;
  Tprocess tmp___3 ;
  SCHEME_OBJECT tmp___4 ;

  {
  {
#line 302
  while (1) {
    while_continue: /* CIL Label */ ;
#line 302
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 303
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 303
    tmp = string_vector_p___0(*(stack_pointer + 1));
    }
#line 303
    if (! tmp) {
      {
#line 303
      error_wrong_type_arg(2);
      }
    }
#line 303
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 305
  position___1 = dstack_position;
#line 306
  if (*(stack_pointer + 0) >> 58U == 30UL) {
#line 306
    tmp___0 = (char *)((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 2);
  } else {
    {
#line 306
    error_wrong_type_arg(1);
#line 306
    tmp___0 = (char *)0;
    }
  }
  {
#line 306
  filename = (char const   *)tmp___0;
#line 307
  tmp___1 = convert_string_vector___0(*(stack_pointer + 1));
#line 307
  argv = tmp___1;
#line 308
  env_object = *(stack_pointer + 2);
#line 309
  env = (char const   **)0;
#line 310
  working_directory = (char const   *)0;
#line 312
  ctty_name = (char *)0;
#line 314
  channel_in = (Tchannel )-1;
#line 316
  channel_out = (Tchannel )-1;
#line 318
  channel_err = (Tchannel )-1;
  }
#line 320
  if (env_object >> 58U == 1UL) {
#line 320
    if (*((SCHEME_OBJECT *)(env_object & 288230376151711743UL) + 1) >> 58U == 30UL) {
#line 322
      working_directory = (char const   *)((char *)((SCHEME_OBJECT *)(*((SCHEME_OBJECT *)(env_object & 288230376151711743UL) + 1) & 288230376151711743UL) + 2));
#line 323
      env_object = *((SCHEME_OBJECT *)(env_object & 288230376151711743UL) + 0);
    }
  }
#line 325
  if (env_object != 0UL) {
    {
#line 327
    tmp___2 = string_vector_p___0(env_object);
    }
#line 327
    if (! tmp___2) {
      {
#line 328
      error_wrong_type_arg(3);
      }
    }
    {
#line 329
    env = convert_string_vector___0(env_object);
    }
  }
#line 331
  if (*(stack_pointer + 3) == 0UL) {
#line 332
    ctty_type = (enum process_ctty_type )0;
  } else
#line 333
  if (*(stack_pointer + 3) == ((26UL << 58U) | 288230376151711743UL)) {
#line 334
    ctty_type = (enum process_ctty_type )1;
  } else
#line 335
  if (*(stack_pointer + 3) == ((26UL << 58U) | 288230376151711742UL)) {
#line 336
    ctty_type = (enum process_ctty_type )2;
  } else {
#line 339
    ctty_type = (enum process_ctty_type )3;
#line 340
    if (*(stack_pointer + 3) >> 58U == 30UL) {
#line 340
      ctty_name = (char *)((SCHEME_OBJECT *)(*(stack_pointer + 3) & 288230376151711743UL) + 2);
    } else {
      {
#line 340
      error_wrong_type_arg(4);
#line 340
      ctty_name = (char *)0;
      }
    }
  }
#line 342
  if (*(stack_pointer + 4) == 0UL) {
#line 342
    channel_in_type = (enum process_channel_type )0;
  } else
#line 342
  if (*(stack_pointer + 4) == ((26UL << 58U) | 288230376151711743UL)) {
#line 342
    channel_in_type = (enum process_channel_type )1;
  } else
#line 342
  if (*(stack_pointer + 4) == ((26UL << 58U) | 288230376151711742UL)) {
#line 342
    if ((unsigned int )ctty_type != 3U) {
      {
#line 342
      error_bad_range_arg(5);
      }
    }
#line 342
    channel_in_type = (enum process_channel_type )2;
  } else {
    {
#line 342
    channel_in_type = (enum process_channel_type )3;
#line 342
    channel_in = arg_channel(5);
    }
  }
#line 343
  if (*(stack_pointer + 5) == 0UL) {
#line 343
    channel_out_type = (enum process_channel_type )0;
  } else
#line 343
  if (*(stack_pointer + 5) == ((26UL << 58U) | 288230376151711743UL)) {
#line 343
    channel_out_type = (enum process_channel_type )1;
  } else
#line 343
  if (*(stack_pointer + 5) == ((26UL << 58U) | 288230376151711742UL)) {
#line 343
    if ((unsigned int )ctty_type != 3U) {
      {
#line 343
      error_bad_range_arg(6);
      }
    }
#line 343
    channel_out_type = (enum process_channel_type )2;
  } else {
    {
#line 343
    channel_out_type = (enum process_channel_type )3;
#line 343
    channel_out = arg_channel(6);
    }
  }
#line 344
  if (*(stack_pointer + 6) == 0UL) {
#line 344
    channel_err_type = (enum process_channel_type )0;
  } else
#line 344
  if (*(stack_pointer + 6) == ((26UL << 58U) | 288230376151711743UL)) {
#line 344
    channel_err_type = (enum process_channel_type )1;
  } else
#line 344
  if (*(stack_pointer + 6) == ((26UL << 58U) | 288230376151711742UL)) {
#line 344
    if ((unsigned int )ctty_type != 3U) {
      {
#line 344
      error_bad_range_arg(7);
      }
    }
#line 344
    channel_err_type = (enum process_channel_type )2;
  } else {
    {
#line 344
    channel_err_type = (enum process_channel_type )3;
#line 344
    channel_err = arg_channel(7);
    }
  }
  {
#line 346
  tmp___3 = OS_make_subprocess(filename, argv, env, working_directory, ctty_type,
                               ctty_name, channel_in_type, channel_in, channel_out_type,
                               channel_out, channel_err_type, channel_err);
#line 346
  process = tmp___3;
#line 353
  dstack_set_position(position___1);
#line 354
  tmp___4 = long_to_integer((long )process);
  }
#line 354
  return (tmp___4);
}
}
#line 359 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosproc.c"
static int string_vector_p___0(SCHEME_OBJECT vector ) 
{ 
  unsigned long length ;
  SCHEME_OBJECT *scan ;
  SCHEME_OBJECT *end ;
  SCHEME_OBJECT *tmp ;

  {
#line 362
  if (! (vector >> 58U == 10UL)) {
#line 363
    return (0);
  }
#line 365
  length = *((SCHEME_OBJECT *)(vector & 288230376151711743UL) + 0) & 288230376151711743UL;
#line 366
  scan = (SCHEME_OBJECT *)(vector & 288230376151711743UL) + 1;
#line 367
  end = scan + length;
  {
#line 368
  while (1) {
    while_continue: /* CIL Label */ ;
#line 368
    if (! ((unsigned long )scan < (unsigned long )end)) {
#line 368
      goto while_break;
    }
#line 369
    tmp = scan;
#line 369
    scan ++;
#line 369
    if (! (*tmp >> 58U == 30UL)) {
#line 370
      return (0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 372
  return (1);
}
}
#line 375 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosproc.c"
static char const   **convert_string_vector___0(SCHEME_OBJECT vector ) 
{ 
  unsigned long length ;
  char **result ;
  void *tmp ;
  SCHEME_OBJECT *scan ;
  SCHEME_OBJECT *end ;
  char **scan_result ;
  char **tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;

  {
  {
#line 378
  length = *((SCHEME_OBJECT *)(vector & 288230376151711743UL) + 0) & 288230376151711743UL;
#line 379
  tmp = dstack_alloc((unsigned int )((length + 1UL) * sizeof(char *)));
#line 379
  result = (char **)tmp;
#line 380
  scan = (SCHEME_OBJECT *)(vector & 288230376151711743UL) + 1;
#line 381
  end = scan + length;
#line 382
  scan_result = result;
  }
  {
#line 383
  while (1) {
    while_continue: /* CIL Label */ ;
#line 383
    if (! ((unsigned long )scan < (unsigned long )end)) {
#line 383
      goto while_break;
    }
#line 384
    tmp___0 = scan_result;
#line 384
    scan_result ++;
#line 384
    tmp___1 = scan;
#line 384
    scan ++;
#line 384
    *tmp___0 = (char *)((SCHEME_OBJECT *)(*tmp___1 & 288230376151711743UL) + 2);
  }
  while_break: /* CIL Label */ ;
  }
#line 385
  *scan_result = (char *)0;
#line 386
  return ((char const   **)result);
}
}
#line 103 "/home/khheo/project/mit-scheme-9.2/src/microcode/prims.h"
unsigned long arg_ulong_index_integer(int arg_number , unsigned long upper_limit ) ;
#line 121
unsigned char *arg_extended_string(unsigned int n , unsigned long *lp ) ;
#line 37 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosio.c"
Tchannel arg_to_channel(SCHEME_OBJECT argument , int arg_number ) 
{ 
  unsigned long channel ;
  unsigned long tmp ;

  {
  {
#line 40
  tmp = arg_ulong_integer(arg_number);
#line 40
  channel = tmp;
  }
#line 41
  if (! (channel < (unsigned long )OS_channel_table_size)) {
    {
#line 42
    error_wrong_type_arg(arg_number);
    }
  }
#line 43
  return ((Tchannel )channel);
}
}
#line 46 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosio.c"
Tchannel arg_channel(int arg_number ) 
{ 
  Tchannel channel ;
  Tchannel tmp ;
  int tmp___0 ;

  {
  {
#line 49
  tmp = arg_to_channel(*(stack_pointer + (arg_number - 1)), arg_number);
#line 49
  channel = tmp;
#line 50
  tmp___0 = OS_channel_open_p(channel);
  }
#line 50
  if (! tmp___0) {
    {
#line 51
    error_bad_range_arg(arg_number);
    }
  }
#line 52
  return (channel);
}
}
#line 55 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosio.c"
SCHEME_OBJECT Prim_channel_close(void) 
{ 
  Tchannel channel ;
  Tchannel tmp ;
  int tmp___0 ;

  {
  {
#line 58
  while (1) {
    while_continue: /* CIL Label */ ;
#line 58
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 60
  tmp = arg_to_channel(*(stack_pointer + 0), 1);
#line 60
  channel = tmp;
#line 61
  tmp___0 = OS_channel_open_p(channel);
  }
#line 61
  if (tmp___0) {
    {
#line 64
    OS_channel_close(channel);
    }
  }
#line 67
  return ((8UL << 58U) | 1UL);
}
}
#line 70 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosio.c"
SCHEME_OBJECT Prim_channel_synchronize(void) 
{ 
  Tchannel tmp ;

  {
  {
#line 75
  while (1) {
    while_continue: /* CIL Label */ ;
#line 75
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 76
  tmp = arg_channel(1);
#line 76
  OS_channel_synchronize(tmp);
  }
#line 77
  return ((8UL << 58U) | 1UL);
}
}
#line 80 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosio.c"
SCHEME_OBJECT Prim_channel_table(void) 
{ 
  Tchannel channel ;
  struct obstack *__o ;
  int __len ;
  int tmp ;
  unsigned int n_channels ;
  struct obstack *__o___0 ;
  Tchannel *channels ;
  struct obstack *__o___1 ;
  void *value ;
  Tchannel *scan_channels ;
  SCHEME_OBJECT vector ;
  SCHEME_OBJECT tmp___0 ;
  SCHEME_OBJECT *scan_vector ;
  SCHEME_OBJECT *end_vector ;
  SCHEME_OBJECT *tmp___1 ;
  Tchannel *tmp___2 ;
  struct obstack *__o___2 ;
  void *__obj ;
  char *tmp___3 ;

  {
  {
#line 83
  while (1) {
    while_continue: /* CIL Label */ ;
#line 83
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 86
  channel = (Tchannel )0;
  {
#line 86
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 86
    if (! (channel < OS_channel_table_size)) {
#line 86
      goto while_break___0;
    }
    {
#line 87
    tmp = OS_channel_open_p(channel);
    }
#line 87
    if (tmp) {
#line 88
      __o = & scratch_obstack;
#line 88
      __len = (int )sizeof(Tchannel );
#line 88
      if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
        {
#line 88
        _obstack_newchunk(__o, __len);
        }
      }
      {
#line 88
      memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)(& channel),
             (size_t )__len);
#line 88
      __o->next_free += __len;
      }
    }
#line 86
    channel ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 92
  __o___0 = & scratch_obstack;
#line 92
  n_channels = (unsigned int )((unsigned long )((unsigned int )(__o___0->next_free - __o___0->object_base)) / sizeof(Tchannel ));
#line 93
  if (n_channels == 0U) {
#line 94
    return (0UL);
  }
#line 96
  __o___1 = & scratch_obstack;
#line 96
  value = (void *)__o___1->object_base;
#line 96
  __o___1->next_free = (char *)((void *)((char *)0 + (((__o___1->next_free - (char *)0) + __o___1->alignment_mask) & ~ __o___1->alignment_mask)));
#line 96
  if (__o___1->next_free - (char *)__o___1->chunk > __o___1->chunk_limit - (char *)__o___1->chunk) {
#line 96
    __o___1->next_free = __o___1->chunk_limit;
  }
  {
#line 96
  __o___1->object_base = __o___1->next_free;
#line 96
  channels = (Tchannel *)value;
#line 97
  scan_channels = channels;
#line 98
  tmp___0 = allocate_marked_vector(10U, (unsigned long )n_channels, (_Bool)1);
#line 98
  vector = tmp___0;
#line 100
  scan_vector = (SCHEME_OBJECT *)(vector & 288230376151711743UL) + 1;
#line 101
  end_vector = scan_vector + n_channels;
  }
  {
#line 102
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 102
    if (! ((unsigned long )scan_vector < (unsigned long )end_vector)) {
#line 102
      goto while_break___1;
    }
    {
#line 103
    tmp___1 = scan_vector;
#line 103
    scan_vector ++;
#line 103
    tmp___2 = scan_channels;
#line 103
    scan_channels ++;
#line 103
    *tmp___1 = long_to_integer((long )*tmp___2);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 104
  __o___2 = & scratch_obstack;
#line 104
  __obj = (void *)channels;
#line 104
  if ((unsigned long )__obj > (unsigned long )((void *)__o___2->chunk)) {
#line 104
    if ((unsigned long )__obj < (unsigned long )((void *)__o___2->chunk_limit)) {
#line 104
      tmp___3 = (char *)__obj;
#line 104
      __o___2->object_base = tmp___3;
#line 104
      __o___2->next_free = tmp___3;
    } else {
      {
#line 104
      obstack_free(__o___2, __obj);
      }
    }
  } else {
    {
#line 104
    obstack_free(__o___2, __obj);
    }
  }
#line 105
  return (vector);
}
}
#line 110 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosio.c"
SCHEME_OBJECT Prim_channel_type(void) 
{ 
  Tchannel tmp ;
  enum channel_type tmp___0 ;
  SCHEME_OBJECT tmp___1 ;

  {
  {
#line 113
  while (1) {
    while_continue: /* CIL Label */ ;
#line 113
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 114
  tmp = arg_channel(1);
#line 114
  tmp___0 = OS_channel_type(tmp);
#line 114
  tmp___1 = long_to_integer((long )tmp___0);
  }
#line 114
  return (tmp___1);
}
}
#line 119 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosio.c"
static char const   *channel_type_names[17]  = 
#line 119
  {      "unknown",      "file",      "unix-pipe",      "unix-fifo", 
        "terminal",      "unix-pty-master",      "unix-stream-socket",      "tcp-stream-socket", 
        "tcp-server-socket",      "directory",      "unix-character-device",      "unix-block-device", 
        "os/2-console",      "os/2-unnamed-pipe",      "os/2-named-pipe",      "win32-anonymous-pipe", 
        "win32-named-pipe"};
#line 140 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosio.c"
SCHEME_OBJECT Prim_channel_type_name(void) 
{ 
  enum channel_type type ;
  unsigned int index___0 ;
  Tchannel tmp ;
  SCHEME_OBJECT tmp___0 ;

  {
  {
#line 145
  while (1) {
    while_continue: /* CIL Label */ ;
#line 145
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 146
  tmp = arg_channel(1);
#line 146
  type = OS_channel_type(tmp);
  }
#line 147
  if ((unsigned int )type == 0U) {
#line 148
    return (0UL);
  }
#line 149
  index___0 = (unsigned int )type;
#line 150
  if ((unsigned long )index___0 >= sizeof(channel_type_names) / sizeof(char *)) {
#line 151
    return (0UL);
  }
  {
#line 152
  tmp___0 = char_pointer_to_string(channel_type_names[index___0]);
  }
#line 152
  return (tmp___0);
}
}
#line 155 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosio.c"
SCHEME_OBJECT Prim_channel_read(void) 
{ 
  unsigned long length ;
  unsigned char *buffer___2 ;
  unsigned char *tmp ;
  unsigned long end ;
  unsigned long tmp___0 ;
  unsigned long start ;
  unsigned long tmp___1 ;
  long nread ;
  Tchannel tmp___2 ;
  long tmp___3 ;
  SCHEME_OBJECT tmp___4 ;
  unsigned long tmp___5 ;

  {
  {
#line 161
  while (1) {
    while_continue: /* CIL Label */ ;
#line 161
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 164
  tmp = arg_extended_string(2U, & length);
#line 164
  buffer___2 = tmp;
#line 165
  tmp___0 = arg_ulong_index_integer(4, length + 1UL);
#line 165
  end = tmp___0;
#line 166
  tmp___1 = arg_ulong_index_integer(3, end + 1UL);
#line 166
  start = tmp___1;
#line 167
  tmp___2 = arg_channel(1);
#line 167
  tmp___3 = OS_channel_read(tmp___2, (void *)(buffer___2 + start), end - start);
#line 167
  nread = tmp___3;
  }
#line 171
  if (nread < 0L) {
#line 171
    tmp___5 = 0UL;
  } else {
    {
#line 171
    tmp___4 = long_to_integer(nread);
#line 171
    tmp___5 = tmp___4;
    }
  }
#line 171
  return (tmp___5);
}
}
#line 175 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosio.c"
SCHEME_OBJECT Prim_channel_write(void) 
{ 
  unsigned long length ;
  unsigned char const   *buffer___2 ;
  unsigned char *tmp ;
  unsigned long end ;
  unsigned long tmp___0 ;
  unsigned long start ;
  unsigned long tmp___1 ;
  long nwritten ;
  Tchannel tmp___2 ;
  long tmp___3 ;
  SCHEME_OBJECT tmp___4 ;
  unsigned long tmp___5 ;

  {
  {
#line 179
  while (1) {
    while_continue: /* CIL Label */ ;
#line 179
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 182
  tmp = arg_extended_string(2U, & length);
#line 182
  buffer___2 = (unsigned char const   *)tmp;
#line 183
  tmp___0 = arg_ulong_index_integer(4, length + 1UL);
#line 183
  end = tmp___0;
#line 184
  tmp___1 = arg_ulong_index_integer(3, end + 1UL);
#line 184
  start = tmp___1;
#line 185
  tmp___2 = arg_channel(1);
#line 185
  tmp___3 = OS_channel_write(tmp___2, (void const   *)(buffer___2 + start), end - start);
#line 185
  nwritten = tmp___3;
  }
#line 189
  if (nwritten < 0L) {
#line 189
    tmp___5 = 0UL;
  } else {
    {
#line 189
    tmp___4 = long_to_integer(nwritten);
#line 189
    tmp___5 = tmp___4;
    }
  }
#line 189
  return (tmp___5);
}
}
#line 193 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosio.c"
SCHEME_OBJECT Prim_channel_blocking_p(void) 
{ 
  int result ;
  Tchannel tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;

  {
  {
#line 199
  while (1) {
    while_continue: /* CIL Label */ ;
#line 199
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 201
  tmp = arg_channel(1);
#line 201
  tmp___0 = OS_channel_nonblocking_p(tmp);
#line 201
  result = tmp___0;
  }
#line 202
  if (result < 0) {
#line 202
    tmp___2 = 26UL << 58U;
  } else {
#line 202
    if (result == 0) {
#line 202
      tmp___1 = 8UL << 58U;
    } else {
#line 202
      tmp___1 = 0UL;
    }
#line 202
    tmp___2 = tmp___1;
  }
#line 202
  return (tmp___2);
}
}
#line 209 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosio.c"
SCHEME_OBJECT Prim_channel_nonblocking(void) 
{ 
  Tchannel tmp ;

  {
  {
#line 212
  while (1) {
    while_continue: /* CIL Label */ ;
#line 212
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 213
  tmp = arg_channel(1);
#line 213
  OS_channel_nonblocking(tmp);
  }
#line 214
  return ((8UL << 58U) | 1UL);
}
}
#line 217 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosio.c"
SCHEME_OBJECT Prim_channel_blocking(void) 
{ 
  Tchannel tmp ;

  {
  {
#line 220
  while (1) {
    while_continue: /* CIL Label */ ;
#line 220
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 221
  tmp = arg_channel(1);
#line 221
  OS_channel_blocking(tmp);
  }
#line 222
  return ((8UL << 58U) | 1UL);
}
}
#line 225 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosio.c"
SCHEME_OBJECT Prim_make_pipe(void) 
{ 
  SCHEME_OBJECT result ;
  SCHEME_OBJECT tmp ;
  Tchannel reader ;
  Tchannel writer ;

  {
  {
#line 228
  while (1) {
    while_continue: /* CIL Label */ ;
#line 228
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 230
  tmp = cons(0UL, 0UL);
#line 230
  result = tmp;
#line 233
  OS_make_pipe(& reader, & writer);
#line 234
  *((SCHEME_OBJECT *)(result & 288230376151711743UL) + 0) = long_to_integer((long )reader);
#line 235
  *((SCHEME_OBJECT *)(result & 288230376151711743UL) + 1) = long_to_integer((long )writer);
  }
#line 236
  return (result);
}
}
#line 240 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosio.c"
SCHEME_OBJECT Prim_new_make_pipe(void) 
{ 
  Tchannel reader ;
  Tchannel writer ;

  {
  {
#line 243
  while (1) {
    while_continue: /* CIL Label */ ;
#line 243
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 244
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 244
    if (! (*(stack_pointer + 0) >> 58U == 55UL)) {
      {
#line 244
      error_wrong_type_arg(1);
      }
    }
#line 244
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 245
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 245
    if (! (*(stack_pointer + 1) >> 58U == 55UL)) {
      {
#line 245
      error_wrong_type_arg(2);
      }
    }
#line 245
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 249
  OS_make_pipe(& reader, & writer);
#line 250
  *((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 1) = long_to_integer((long )reader);
#line 251
  *((SCHEME_OBJECT *)(*(stack_pointer + 1) & 288230376151711743UL) + 1) = long_to_integer((long )writer);
  }
#line 252
  return ((8UL << 58U) | 1UL);
}
}
#line 258 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosio.c"
static select_registry_t arg_select_registry(int arg_number ) 
{ 
  unsigned long tmp ;

  {
  {
#line 261
  tmp = arg_ulong_integer(arg_number);
  }
#line 261
  return ((select_registry_t )tmp);
}
}
#line 264 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosio.c"
static unsigned int arg_sr_mode(int arg_number ) 
{ 
  unsigned long n ;
  unsigned long tmp ;

  {
  {
#line 267
  tmp = arg_ulong_integer(arg_number);
#line 267
  n = tmp;
  }
#line 268
  if (n >= 1UL) {
#line 268
    if (! (n <= 3UL)) {
      {
#line 269
      error_bad_range_arg(arg_number);
      }
    }
  } else {
    {
#line 269
    error_bad_range_arg(arg_number);
    }
  }
#line 270
  return ((unsigned int )n);
}
}
#line 273 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosio.c"
SCHEME_OBJECT Prim_have_select_p(void) 
{ 
  unsigned long tmp ;

  {
  {
#line 275
  while (1) {
    while_continue: /* CIL Label */ ;
#line 275
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 276
  if (OS_have_select_p) {
#line 276
    tmp = 8UL << 58U;
  } else {
#line 276
    tmp = 0UL;
  }
#line 276
  return (tmp);
}
}
#line 279 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosio.c"
SCHEME_OBJECT Prim_alloc_selreg(void) 
{ 
  select_registry_t tmp ;
  SCHEME_OBJECT tmp___0 ;

  {
  {
#line 281
  while (1) {
    while_continue: /* CIL Label */ ;
#line 281
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 282
  tmp = OS_allocate_select_registry();
#line 282
  tmp___0 = ulong_to_integer((unsigned long )tmp);
  }
#line 282
  return (tmp___0);
}
}
#line 287 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosio.c"
SCHEME_OBJECT Prim_dealloc_selreg(void) 
{ 
  select_registry_t tmp ;

  {
  {
#line 289
  while (1) {
    while_continue: /* CIL Label */ ;
#line 289
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 290
  tmp = arg_select_registry(1);
#line 290
  OS_deallocate_select_registry(tmp);
  }
#line 291
  return ((8UL << 58U) | 1UL);
}
}
#line 294 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosio.c"
SCHEME_OBJECT Prim_add_to_selreg(void) 
{ 
  unsigned int tmp ;
  long tmp___0 ;
  select_registry_t tmp___1 ;

  {
  {
#line 296
  while (1) {
    while_continue: /* CIL Label */ ;
#line 296
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 297
  tmp = arg_sr_mode(3);
#line 297
  tmp___0 = arg_nonnegative_integer(2);
#line 297
  tmp___1 = arg_select_registry(1);
#line 297
  OS_add_to_select_registry(tmp___1, (int )tmp___0, tmp);
  }
#line 300
  return ((8UL << 58U) | 1UL);
}
}
#line 303 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosio.c"
SCHEME_OBJECT Prim_rem_from_selreg(void) 
{ 
  unsigned int tmp ;
  long tmp___0 ;
  select_registry_t tmp___1 ;

  {
  {
#line 305
  while (1) {
    while_continue: /* CIL Label */ ;
#line 305
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 306
  tmp = arg_sr_mode(3);
#line 306
  tmp___0 = arg_nonnegative_integer(2);
#line 306
  tmp___1 = arg_select_registry(1);
#line 306
  OS_remove_from_select_registry(tmp___1, (int )tmp___0, tmp);
  }
#line 309
  return ((8UL << 58U) | 1UL);
}
}
#line 312 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosio.c"
SCHEME_OBJECT Prim_selreg_length(void) 
{ 
  select_registry_t tmp ;
  unsigned int tmp___0 ;
  SCHEME_OBJECT tmp___1 ;

  {
  {
#line 314
  while (1) {
    while_continue: /* CIL Label */ ;
#line 314
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 315
  tmp = arg_select_registry(1);
#line 315
  tmp___0 = OS_select_registry_length(tmp);
#line 315
  tmp___1 = ulong_to_integer((unsigned long )tmp___0);
  }
#line 315
  return (tmp___1);
}
}
#line 319 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosio.c"
SCHEME_OBJECT Prim_test_selreg(void) 
{ 
  select_registry_t r ;
  select_registry_t tmp ;
  unsigned int rl ;
  unsigned int tmp___0 ;
  int blockp ;
  SCHEME_OBJECT vfd ;
  SCHEME_OBJECT tmp___1 ;
  SCHEME_OBJECT vmode ;
  SCHEME_OBJECT tmp___2 ;
  int result ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  unsigned int i ;
  unsigned int iv ;
  int fd ;
  unsigned int mode ;
  SCHEME_OBJECT tmp___6 ;

  {
  {
#line 321
  while (1) {
    while_continue: /* CIL Label */ ;
#line 321
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 323
  tmp = arg_select_registry(1);
#line 323
  r = tmp;
#line 324
  tmp___0 = OS_select_registry_length(r);
#line 324
  rl = tmp___0;
#line 325
  blockp = *(stack_pointer + 1) != 0UL;
  }
#line 326
  if (*(stack_pointer + 2) >> 58U == 10UL) {
#line 326
    tmp___1 = *(stack_pointer + 2);
  } else {
    {
#line 326
    error_wrong_type_arg(3);
#line 326
    tmp___1 = (SCHEME_OBJECT )0;
    }
  }
#line 326
  vfd = tmp___1;
#line 327
  if (*(stack_pointer + 3) >> 58U == 10UL) {
#line 327
    tmp___2 = *(stack_pointer + 3);
  } else {
    {
#line 327
    error_wrong_type_arg(4);
#line 327
    tmp___2 = (SCHEME_OBJECT )0;
    }
  }
#line 327
  vmode = tmp___2;
#line 330
  if ((*((SCHEME_OBJECT *)(vfd & 288230376151711743UL) + 0) & 288230376151711743UL) < (unsigned long )rl) {
    {
#line 331
    error_bad_range_arg(3);
    }
  }
#line 332
  if ((*((SCHEME_OBJECT *)(vmode & 288230376151711743UL) + 0) & 288230376151711743UL) < (unsigned long )rl) {
    {
#line 333
    error_bad_range_arg(4);
    }
  }
#line 334
  if (rl == 0U) {
#line 334
    if (blockp) {
      {
#line 334
      tmp___3 = OS_pause();
#line 334
      tmp___4 = tmp___3;
      }
    } else {
#line 334
      tmp___4 = -1;
    }
#line 334
    result = tmp___4;
  } else {
    {
#line 334
    tmp___5 = OS_test_select_registry(r, blockp);
#line 334
    result = tmp___5;
    }
  }
#line 337
  if (result > 0) {
#line 339
    i = 0U;
#line 340
    iv = 0U;
    {
#line 341
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 341
      if (! (i < rl)) {
#line 341
        goto while_break___0;
      }
      {
#line 346
      OS_select_registry_result(r, i, & fd, & mode);
      }
#line 347
      if (mode > 0U) {
        {
#line 349
        *((SCHEME_OBJECT *)(vfd & 288230376151711743UL) + (iv + 1U)) = long_to_integer((long )fd);
#line 350
        *((SCHEME_OBJECT *)(vmode & 288230376151711743UL) + (iv + 1U)) = ulong_to_integer((unsigned long )mode);
#line 351
        iv ++;
        }
      }
#line 353
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 356
  tmp___6 = long_to_integer((long )result);
  }
#line 356
  return (tmp___6);
}
}
#line 360 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosio.c"
SCHEME_OBJECT Prim_test_sel_desc(void) 
{ 
  unsigned int tmp ;
  long tmp___0 ;
  int tmp___1 ;
  SCHEME_OBJECT tmp___2 ;

  {
  {
#line 362
  while (1) {
    while_continue: /* CIL Label */ ;
#line 362
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 363
  tmp = arg_sr_mode(3);
#line 363
  tmp___0 = arg_nonnegative_integer(1);
#line 363
  tmp___1 = OS_test_select_descriptor((int )tmp___0, *(stack_pointer + 1) != 0UL,
                                      tmp);
#line 363
  tmp___2 = long_to_integer((long )tmp___1);
  }
#line 363
  return (tmp___2);
}
}
#line 69 "/home/khheo/project/mit-scheme-9.2/src/microcode/osfs.h"
int OS_channel_copy(off_t source_length , Tchannel source_channel , Tchannel destination_channel ) ;
#line 44 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosfs.c"
SCHEME_OBJECT Prim_file_exists_p(void) 
{ 
  enum file_existence result ;
  char *tmp ;
  enum file_existence tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;

  {
  {
#line 50
  while (1) {
    while_continue: /* CIL Label */ ;
#line 50
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 52
  if (*(stack_pointer + 0) >> 58U == 30UL) {
#line 52
    tmp = (char *)((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 2);
  } else {
    {
#line 52
    error_wrong_type_arg(1);
#line 52
    tmp = (char *)0;
    }
  }
  {
#line 52
  tmp___0 = OS_file_existence_test((char const   *)tmp);
#line 52
  result = tmp___0;
  }
#line 53
  if ((unsigned int )result == 1U) {
#line 53
    tmp___2 = 0UL;
  } else {
#line 53
    if ((unsigned int )result == 0U) {
#line 53
      tmp___1 = 8UL << 58U;
    } else {
#line 53
      tmp___1 = 26UL << 58U;
    }
#line 53
    tmp___2 = tmp___1;
  }
#line 53
  return (tmp___2);
}
}
#line 62 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosfs.c"
SCHEME_OBJECT Prim_file_exists_direct_p(void) 
{ 
  enum file_existence result ;
  char *tmp ;
  enum file_existence tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;

  {
  {
#line 68
  while (1) {
    while_continue: /* CIL Label */ ;
#line 68
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 70
  if (*(stack_pointer + 0) >> 58U == 30UL) {
#line 70
    tmp = (char *)((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 2);
  } else {
    {
#line 70
    error_wrong_type_arg(1);
#line 70
    tmp = (char *)0;
    }
  }
  {
#line 70
  tmp___0 = OS_file_existence_test_direct((char const   *)tmp);
#line 70
  result = tmp___0;
  }
#line 72
  if ((unsigned int )result == 1U) {
#line 72
    tmp___2 = 0UL;
  } else {
#line 72
    if ((unsigned int )result == 0U) {
#line 72
      tmp___1 = 8UL << 58U;
    } else {
#line 72
      tmp___1 = 26UL << 58U;
    }
#line 72
    tmp___2 = tmp___1;
  }
#line 72
  return (tmp___2);
}
}
#line 81 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosfs.c"
SCHEME_OBJECT Prim_file_type_direct(void) 
{ 
  enum file_type t ;
  char *tmp ;
  enum file_type tmp___0 ;
  SCHEME_OBJECT tmp___1 ;
  unsigned long tmp___2 ;

  {
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
#line 85
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 87
  if (*(stack_pointer + 0) >> 58U == 30UL) {
#line 87
    tmp = (char *)((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 2);
  } else {
    {
#line 87
    error_wrong_type_arg(1);
#line 87
    tmp = (char *)0;
    }
  }
  {
#line 87
  tmp___0 = OS_file_type_direct((char const   *)tmp);
#line 87
  t = tmp___0;
  }
#line 88
  if ((int )t == -1) {
#line 88
    tmp___2 = 0UL;
  } else {
    {
#line 88
    tmp___1 = ulong_to_integer((unsigned long )t);
#line 88
    tmp___2 = tmp___1;
    }
  }
#line 88
  return (tmp___2);
}
}
#line 95 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosfs.c"
SCHEME_OBJECT Prim_file_type_indirect(void) 
{ 
  enum file_type t ;
  char *tmp ;
  enum file_type tmp___0 ;
  SCHEME_OBJECT tmp___1 ;
  unsigned long tmp___2 ;

  {
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 101
  if (*(stack_pointer + 0) >> 58U == 30UL) {
#line 101
    tmp = (char *)((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 2);
  } else {
    {
#line 101
    error_wrong_type_arg(1);
#line 101
    tmp = (char *)0;
    }
  }
  {
#line 101
  tmp___0 = OS_file_type_indirect((char const   *)tmp);
#line 101
  t = tmp___0;
  }
#line 102
  if ((int )t == -1) {
#line 102
    tmp___2 = 0UL;
  } else {
    {
#line 102
    tmp___1 = ulong_to_integer((unsigned long )t);
#line 102
    tmp___2 = tmp___1;
    }
  }
#line 102
  return (tmp___2);
}
}
#line 109 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosfs.c"
SCHEME_OBJECT Prim_file_access(void) 
{ 
  unsigned long tmp___2 ;
  long tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
  {
#line 116
  while (1) {
    while_continue: /* CIL Label */ ;
#line 116
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 117
  tmp___3 = arg_index_integer(2, 8L);
  }
#line 117
  if (*(stack_pointer + 0) >> 58U == 30UL) {
#line 117
    tmp___4 = (char *)((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 2);
  } else {
    {
#line 117
    error_wrong_type_arg(1);
#line 117
    tmp___4 = (char *)0;
    }
  }
  {
#line 117
  tmp___5 = OS_file_access((char const   *)tmp___4, (unsigned int )tmp___3);
  }
#line 117
  if (tmp___5) {
#line 117
    tmp___2 = 8UL << 58U;
  } else {
#line 117
    tmp___2 = 0UL;
  }
#line 117
  return (tmp___2);
}
}
#line 122 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosfs.c"
SCHEME_OBJECT Prim_file_directory_p(void) 
{ 
  unsigned long tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 127
  while (1) {
    while_continue: /* CIL Label */ ;
#line 127
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 128
  if (*(stack_pointer + 0) >> 58U == 30UL) {
#line 128
    tmp___2 = (char *)((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 2);
  } else {
    {
#line 128
    error_wrong_type_arg(1);
#line 128
    tmp___2 = (char *)0;
    }
  }
  {
#line 128
  tmp___3 = OS_file_directory_p((char const   *)tmp___2);
  }
#line 128
  if (tmp___3) {
#line 128
    tmp___1 = 8UL << 58U;
  } else {
#line 128
    tmp___1 = 0UL;
  }
#line 128
  return (tmp___1);
}
}
#line 131 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosfs.c"
SCHEME_OBJECT Prim_file_soft_link_p(void) 
{ 
  char const   *result ;
  char *tmp ;
  char const   *tmp___0 ;
  SCHEME_OBJECT tmp___1 ;
  unsigned long tmp___2 ;

  {
  {
#line 136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 136
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 137
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 137
    if (*(stack_pointer + 0) >> 58U == 30UL) {
#line 137
      tmp = (char *)((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 2);
    } else {
      {
#line 137
      error_wrong_type_arg(1);
#line 137
      tmp = (char *)0;
      }
    }
    {
#line 137
    tmp___0 = OS_file_soft_link_p((char const   *)tmp);
#line 137
    result = tmp___0;
    }
#line 137
    if ((unsigned long )result == (unsigned long )((char const   *)0)) {
#line 137
      tmp___2 = 0UL;
    } else {
      {
#line 137
      tmp___1 = char_pointer_to_string(result);
#line 137
      tmp___2 = tmp___1;
      }
    }
#line 137
    return (tmp___2);
#line 137
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 138
  return (0UL);
}
}
#line 140 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosfs.c"
SCHEME_OBJECT Prim_file_remove(void) 
{ 
  char *tmp ;

  {
  {
#line 144
  while (1) {
    while_continue: /* CIL Label */ ;
#line 144
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 145
  if (*(stack_pointer + 0) >> 58U == 30UL) {
#line 145
    tmp = (char *)((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 2);
  } else {
    {
#line 145
    error_wrong_type_arg(1);
#line 145
    tmp = (char *)0;
    }
  }
  {
#line 145
  OS_file_remove((char const   *)tmp);
  }
#line 146
  return ((8UL << 58U) | 1UL);
}
}
#line 149 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosfs.c"
SCHEME_OBJECT Prim_file_remove_link(void) 
{ 
  char *tmp ;

  {
  {
#line 152
  while (1) {
    while_continue: /* CIL Label */ ;
#line 152
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 153
  if (*(stack_pointer + 0) >> 58U == 30UL) {
#line 153
    tmp = (char *)((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 2);
  } else {
    {
#line 153
    error_wrong_type_arg(1);
#line 153
    tmp = (char *)0;
    }
  }
  {
#line 153
  OS_file_remove_link((char const   *)tmp);
  }
#line 154
  return ((8UL << 58U) | 1UL);
}
}
#line 157 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosfs.c"
SCHEME_OBJECT Prim_file_rename(void) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 160
  while (1) {
    while_continue: /* CIL Label */ ;
#line 160
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 161
  if (*(stack_pointer + 1) >> 58U == 30UL) {
#line 161
    tmp = (char *)((SCHEME_OBJECT *)(*(stack_pointer + 1) & 288230376151711743UL) + 2);
  } else {
    {
#line 161
    error_wrong_type_arg(2);
#line 161
    tmp = (char *)0;
    }
  }
#line 161
  if (*(stack_pointer + 0) >> 58U == 30UL) {
#line 161
    tmp___0 = (char *)((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 2);
  } else {
    {
#line 161
    error_wrong_type_arg(1);
#line 161
    tmp___0 = (char *)0;
    }
  }
  {
#line 161
  OS_file_rename((char const   *)tmp___0, (char const   *)tmp);
  }
#line 162
  return ((8UL << 58U) | 1UL);
}
}
#line 165 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosfs.c"
SCHEME_OBJECT Prim_file_link_hard(void) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 169
  while (1) {
    while_continue: /* CIL Label */ ;
#line 169
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 170
  if (*(stack_pointer + 1) >> 58U == 30UL) {
#line 170
    tmp = (char *)((SCHEME_OBJECT *)(*(stack_pointer + 1) & 288230376151711743UL) + 2);
  } else {
    {
#line 170
    error_wrong_type_arg(2);
#line 170
    tmp = (char *)0;
    }
  }
#line 170
  if (*(stack_pointer + 0) >> 58U == 30UL) {
#line 170
    tmp___0 = (char *)((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 2);
  } else {
    {
#line 170
    error_wrong_type_arg(1);
#line 170
    tmp___0 = (char *)0;
    }
  }
  {
#line 170
  OS_file_link_hard((char const   *)tmp___0, (char const   *)tmp);
  }
#line 171
  return ((8UL << 58U) | 1UL);
}
}
#line 174 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosfs.c"
SCHEME_OBJECT Prim_file_link_soft(void) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 178
  while (1) {
    while_continue: /* CIL Label */ ;
#line 178
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 179
  if (*(stack_pointer + 1) >> 58U == 30UL) {
#line 179
    tmp = (char *)((SCHEME_OBJECT *)(*(stack_pointer + 1) & 288230376151711743UL) + 2);
  } else {
    {
#line 179
    error_wrong_type_arg(2);
#line 179
    tmp = (char *)0;
    }
  }
#line 179
  if (*(stack_pointer + 0) >> 58U == 30UL) {
#line 179
    tmp___0 = (char *)((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 2);
  } else {
    {
#line 179
    error_wrong_type_arg(1);
#line 179
    tmp___0 = (char *)0;
    }
  }
  {
#line 179
  OS_file_link_soft((char const   *)tmp___0, (char const   *)tmp);
  }
#line 180
  return ((8UL << 58U) | 1UL);
}
}
#line 183 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosfs.c"
SCHEME_OBJECT Prim_link_file(void) 
{ 
  char const   *from_name ;
  char *tmp ;
  char const   *to_name ;
  char *tmp___0 ;

  {
  {
#line 189
  while (1) {
    while_continue: /* CIL Label */ ;
#line 189
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 191
  if (*(stack_pointer + 0) >> 58U == 30UL) {
#line 191
    tmp = (char *)((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 2);
  } else {
    {
#line 191
    error_wrong_type_arg(1);
#line 191
    tmp = (char *)0;
    }
  }
#line 191
  from_name = (char const   *)tmp;
#line 192
  if (*(stack_pointer + 1) >> 58U == 30UL) {
#line 192
    tmp___0 = (char *)((SCHEME_OBJECT *)(*(stack_pointer + 1) & 288230376151711743UL) + 2);
  } else {
    {
#line 192
    error_wrong_type_arg(2);
#line 192
    tmp___0 = (char *)0;
    }
  }
#line 192
  to_name = (char const   *)tmp___0;
#line 193
  if (*(stack_pointer + 2) != 0UL) {
    {
#line 194
    OS_file_link_hard(from_name, to_name);
    }
  } else {
    {
#line 196
    OS_file_link_soft(from_name, to_name);
    }
  }
#line 198
  return ((8UL << 58U) | 1UL);
}
}
#line 205 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosfs.c"
int OS_channel_copy(off_t source_length , Tchannel source_channel , Tchannel destination_channel ) 
{ 
  char buffer___2[8192] ;
  off_t transfer_length ;
  unsigned long tmp ;
  long nread ;
  long tmp___0 ;
  long tmp___1 ;
  void *__cil_tmp10 ;

  {
#line 211
  if ((unsigned long )source_length > sizeof(buffer___2)) {
#line 211
    tmp = sizeof(buffer___2);
  } else {
#line 211
    tmp = (unsigned long )source_length;
  }
#line 211
  transfer_length = (off_t )tmp;
  {
#line 214
  while (1) {
    while_continue: /* CIL Label */ ;
#line 214
    if (! (source_length > 0L)) {
#line 214
      goto while_break;
    }
    {
#line 216
    tmp___0 = OS_channel_read(source_channel, (void *)(buffer___2), (size_t )transfer_length);
#line 216
    nread = tmp___0;
    }
#line 218
    if (nread <= 0L) {
#line 220
      return (-1);
    }
    {
#line 222
    tmp___1 = OS_channel_write(destination_channel, (void const   *)(buffer___2),
                               (size_t )nread);
    }
#line 222
    if (tmp___1 < nread) {
#line 225
      return (-1);
    }
#line 227
    source_length -= nread;
#line 228
    if ((unsigned long )source_length < sizeof(buffer___2)) {
#line 229
      transfer_length = source_length;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 231
  return (0);
}
}
#line 234 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosfs.c"
SCHEME_OBJECT Prim_file_copy(void) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 237
  while (1) {
    while_continue: /* CIL Label */ ;
#line 237
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 238
  if (*(stack_pointer + 1) >> 58U == 30UL) {
#line 238
    tmp = (char *)((SCHEME_OBJECT *)(*(stack_pointer + 1) & 288230376151711743UL) + 2);
  } else {
    {
#line 238
    error_wrong_type_arg(2);
#line 238
    tmp = (char *)0;
    }
  }
#line 238
  if (*(stack_pointer + 0) >> 58U == 30UL) {
#line 238
    tmp___0 = (char *)((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 2);
  } else {
    {
#line 238
    error_wrong_type_arg(1);
#line 238
    tmp___0 = (char *)0;
    }
  }
  {
#line 238
  OS_file_copy((char const   *)tmp___0, (char const   *)tmp);
  }
#line 239
  return ((8UL << 58U) | 1UL);
}
}
#line 242 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosfs.c"
SCHEME_OBJECT Prim_directory_make(void) 
{ 
  char *tmp ;

  {
  {
#line 245
  while (1) {
    while_continue: /* CIL Label */ ;
#line 245
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 246
  if (*(stack_pointer + 0) >> 58U == 30UL) {
#line 246
    tmp = (char *)((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 2);
  } else {
    {
#line 246
    error_wrong_type_arg(1);
#line 246
    tmp = (char *)0;
    }
  }
  {
#line 246
  OS_directory_make((char const   *)tmp);
  }
#line 247
  return ((8UL << 58U) | 1UL);
}
}
#line 250 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosfs.c"
SCHEME_OBJECT Prim_directory_delete(void) 
{ 
  char *tmp ;

  {
  {
#line 253
  while (1) {
    while_continue: /* CIL Label */ ;
#line 253
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 254
  if (*(stack_pointer + 0) >> 58U == 30UL) {
#line 254
    tmp = (char *)((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 2);
  } else {
    {
#line 254
    error_wrong_type_arg(1);
#line 254
    tmp = (char *)0;
    }
  }
  {
#line 254
  OS_directory_delete((char const   *)tmp);
  }
#line 255
  return ((8UL << 58U) | 1UL);
}
}
#line 258 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosfs.c"
SCHEME_OBJECT Prim_file_touch(void) 
{ 
  int rc ;
  char *tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;

  {
  {
#line 265
  while (1) {
    while_continue: /* CIL Label */ ;
#line 265
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 267
  if (*(stack_pointer + 0) >> 58U == 30UL) {
#line 267
    tmp = (char *)((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 2);
  } else {
    {
#line 267
    error_wrong_type_arg(1);
#line 267
    tmp = (char *)0;
    }
  }
  {
#line 267
  tmp___0 = OS_file_touch((char const   *)tmp);
#line 267
  rc = tmp___0;
  }
#line 268
  if (rc < 0) {
    {
#line 269
    error_bad_range_arg(1);
    }
  }
#line 270
  if (rc) {
#line 270
    tmp___1 = 8UL << 58U;
  } else {
#line 270
    tmp___1 = 0UL;
  }
#line 270
  return (tmp___1);
}
}
#line 274 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosfs.c"
SCHEME_OBJECT Prim_new_directory_open(void) 
{ 
  char *tmp ;
  unsigned int tmp___0 ;
  SCHEME_OBJECT tmp___1 ;

  {
  {
#line 277
  while (1) {
    while_continue: /* CIL Label */ ;
#line 277
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 278
  if (*(stack_pointer + 0) >> 58U == 30UL) {
#line 278
    tmp = (char *)((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 2);
  } else {
    {
#line 278
    error_wrong_type_arg(1);
#line 278
    tmp = (char *)0;
    }
  }
  {
#line 278
  tmp___0 = OS_directory_open((char const   *)tmp);
#line 278
  tmp___1 = long_to_integer((long )tmp___0);
  }
#line 278
  return (tmp___1);
}
}
#line 281 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosfs.c"
static unsigned int arg_directory_index(unsigned int argument ) 
{ 
  unsigned int index___0 ;
  unsigned long tmp ;
  int tmp___0 ;

  {
  {
#line 284
  tmp = arg_ulong_integer((int )argument);
#line 284
  index___0 = (unsigned int )tmp;
#line 285
  tmp___0 = OS_directory_valid_p(index___0);
  }
#line 285
  if (! tmp___0) {
    {
#line 286
    error_bad_range_arg((int )argument);
    }
  }
#line 287
  return (index___0);
}
}
#line 290 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosfs.c"
SCHEME_OBJECT Prim_new_directory_close(void) 
{ 
  unsigned int tmp ;

  {
  {
#line 293
  while (1) {
    while_continue: /* CIL Label */ ;
#line 293
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 294
  tmp = arg_directory_index(1U);
#line 294
  OS_directory_close(tmp);
  }
#line 295
  return ((8UL << 58U) | 1UL);
}
}
#line 298 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosfs.c"
SCHEME_OBJECT Prim_new_directory_read(void) 
{ 
  char const   *result ;
  unsigned int tmp ;
  char const   *tmp___0 ;
  SCHEME_OBJECT tmp___1 ;
  unsigned long tmp___2 ;

  {
  {
#line 301
  while (1) {
    while_continue: /* CIL Label */ ;
#line 301
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 302
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 302
    tmp = arg_directory_index(1U);
#line 302
    tmp___0 = OS_directory_read(tmp);
#line 302
    result = tmp___0;
    }
#line 302
    if ((unsigned long )result == (unsigned long )((char const   *)0)) {
#line 302
      tmp___2 = 0UL;
    } else {
      {
#line 302
      tmp___1 = char_pointer_to_string(result);
#line 302
      tmp___2 = tmp___1;
      }
    }
#line 302
    return (tmp___2);
#line 302
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 303
  return (0UL);
}
}
#line 305 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosfs.c"
SCHEME_OBJECT Prim_new_directory_read_match(void) 
{ 
  char const   *result ;
  char *tmp ;
  unsigned int tmp___0 ;
  char const   *tmp___1 ;
  SCHEME_OBJECT tmp___2 ;
  unsigned long tmp___3 ;

  {
  {
#line 310
  while (1) {
    while_continue: /* CIL Label */ ;
#line 310
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 311
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 311
    if (*(stack_pointer + 1) >> 58U == 30UL) {
#line 311
      tmp = (char *)((SCHEME_OBJECT *)(*(stack_pointer + 1) & 288230376151711743UL) + 2);
    } else {
      {
#line 311
      error_wrong_type_arg(2);
#line 311
      tmp = (char *)0;
      }
    }
    {
#line 311
    tmp___0 = arg_directory_index(1U);
#line 311
    tmp___1 = OS_directory_read_matching(tmp___0, (char const   *)tmp);
#line 311
    result = tmp___1;
    }
#line 311
    if ((unsigned long )result == (unsigned long )((char const   *)0)) {
#line 311
      tmp___3 = 0UL;
    } else {
      {
#line 311
      tmp___2 = char_pointer_to_string(result);
#line 311
      tmp___3 = tmp___2;
      }
    }
#line 311
    return (tmp___3);
#line 311
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 313
  return (0UL);
}
}
#line 51 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosfile.c"
SCHEME_OBJECT Prim_new_file_open_input_channel(void) 
{ 
  Tchannel channel ;
  char *tmp ;
  Tchannel tmp___0 ;

  {
  {
#line 55
  while (1) {
    while_continue: /* CIL Label */ ;
#line 55
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 55
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 55
    if (! (*(stack_pointer + 1) >> 58U == 55UL)) {
      {
#line 55
      error_wrong_type_arg(2);
      }
    }
#line 55
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 55
  if (*(stack_pointer + 0) >> 58U == 30UL) {
#line 55
    tmp = (char *)((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 2);
  } else {
    {
#line 55
    error_wrong_type_arg(1);
#line 55
    tmp = (char *)0;
    }
  }
  {
#line 55
  tmp___0 = OS_open_input_file((char const   *)tmp);
#line 55
  channel = tmp___0;
#line 55
  *((SCHEME_OBJECT *)(*(stack_pointer + 1) & 288230376151711743UL) + 1) = long_to_integer((long )channel);
  }
#line 55
  return (8UL << 58U);
}
}
#line 57 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosfile.c"
SCHEME_OBJECT Prim_new_file_open_output_channel(void) 
{ 
  Tchannel channel ;
  char *tmp ;
  Tchannel tmp___0 ;

  {
  {
#line 62
  while (1) {
    while_continue: /* CIL Label */ ;
#line 62
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 62
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 62
    if (! (*(stack_pointer + 1) >> 58U == 55UL)) {
      {
#line 62
      error_wrong_type_arg(2);
      }
    }
#line 62
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 62
  if (*(stack_pointer + 0) >> 58U == 30UL) {
#line 62
    tmp = (char *)((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 2);
  } else {
    {
#line 62
    error_wrong_type_arg(1);
#line 62
    tmp = (char *)0;
    }
  }
  {
#line 62
  tmp___0 = OS_open_output_file((char const   *)tmp);
#line 62
  channel = tmp___0;
#line 62
  *((SCHEME_OBJECT *)(*(stack_pointer + 1) & 288230376151711743UL) + 1) = long_to_integer((long )channel);
  }
#line 62
  return (8UL << 58U);
}
}
#line 68 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosfile.c"
SCHEME_OBJECT Prim_new_file_open_exclusive_output_channel(void) 
{ 
  Tchannel channel ;
  char *tmp ;
  Tchannel tmp___0 ;

  {
  {
#line 73
  while (1) {
    while_continue: /* CIL Label */ ;
#line 73
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 73
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 73
    if (! (*(stack_pointer + 1) >> 58U == 55UL)) {
      {
#line 73
      error_wrong_type_arg(2);
      }
    }
#line 73
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 73
  if (*(stack_pointer + 0) >> 58U == 30UL) {
#line 73
    tmp = (char *)((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 2);
  } else {
    {
#line 73
    error_wrong_type_arg(1);
#line 73
    tmp = (char *)0;
    }
  }
  {
#line 73
  tmp___0 = OS_open_exclusive_output_file((char const   *)tmp);
#line 73
  channel = tmp___0;
#line 73
  *((SCHEME_OBJECT *)(*(stack_pointer + 1) & 288230376151711743UL) + 1) = long_to_integer((long )channel);
  }
#line 73
  return (8UL << 58U);
}
}
#line 75 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosfile.c"
SCHEME_OBJECT Prim_new_file_open_io_channel(void) 
{ 
  Tchannel channel ;
  char *tmp ;
  Tchannel tmp___0 ;

  {
  {
#line 81
  while (1) {
    while_continue: /* CIL Label */ ;
#line 81
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 81
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 81
    if (! (*(stack_pointer + 1) >> 58U == 55UL)) {
      {
#line 81
      error_wrong_type_arg(2);
      }
    }
#line 81
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 81
  if (*(stack_pointer + 0) >> 58U == 30UL) {
#line 81
    tmp = (char *)((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 2);
  } else {
    {
#line 81
    error_wrong_type_arg(1);
#line 81
    tmp = (char *)0;
    }
  }
  {
#line 81
  tmp___0 = OS_open_io_file((char const   *)tmp);
#line 81
  channel = tmp___0;
#line 81
  *((SCHEME_OBJECT *)(*(stack_pointer + 1) & 288230376151711743UL) + 1) = long_to_integer((long )channel);
  }
#line 81
  return (8UL << 58U);
}
}
#line 83 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosfile.c"
SCHEME_OBJECT Prim_new_file_open_append_channel(void) 
{ 
  Tchannel channel ;
  char *tmp ;
  Tchannel tmp___0 ;

  {
  {
#line 88
  while (1) {
    while_continue: /* CIL Label */ ;
#line 88
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 88
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 88
    if (! (*(stack_pointer + 1) >> 58U == 55UL)) {
      {
#line 88
      error_wrong_type_arg(2);
      }
    }
#line 88
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 88
  if (*(stack_pointer + 0) >> 58U == 30UL) {
#line 88
    tmp = (char *)((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 2);
  } else {
    {
#line 88
    error_wrong_type_arg(1);
#line 88
    tmp = (char *)0;
    }
  }
  {
#line 88
  tmp___0 = OS_open_append_file((char const   *)tmp);
#line 88
  channel = tmp___0;
#line 88
  *((SCHEME_OBJECT *)(*(stack_pointer + 1) & 288230376151711743UL) + 1) = long_to_integer((long )channel);
  }
#line 88
  return (8UL << 58U);
}
}
#line 100 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosfile.c"
SCHEME_OBJECT Prim_file_open_input_channel(void) 
{ 
  Tchannel channel ;
  char *tmp ;
  Tchannel tmp___0 ;
  SCHEME_OBJECT tmp___1 ;

  {
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
#line 103
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 103
  if (*(stack_pointer + 0) >> 58U == 30UL) {
#line 103
    tmp = (char *)((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 2);
  } else {
    {
#line 103
    error_wrong_type_arg(1);
#line 103
    tmp = (char *)0;
    }
  }
  {
#line 103
  tmp___0 = OS_open_input_file((char const   *)tmp);
#line 103
  channel = tmp___0;
#line 103
  tmp___1 = long_to_integer((long )channel);
  }
#line 103
  return (tmp___1);
}
}
#line 105 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosfile.c"
SCHEME_OBJECT Prim_file_open_output_channel(void) 
{ 
  Tchannel channel ;
  char *tmp ;
  Tchannel tmp___0 ;
  SCHEME_OBJECT tmp___1 ;

  {
  {
#line 109
  while (1) {
    while_continue: /* CIL Label */ ;
#line 109
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 109
  if (*(stack_pointer + 0) >> 58U == 30UL) {
#line 109
    tmp = (char *)((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 2);
  } else {
    {
#line 109
    error_wrong_type_arg(1);
#line 109
    tmp = (char *)0;
    }
  }
  {
#line 109
  tmp___0 = OS_open_output_file((char const   *)tmp);
#line 109
  channel = tmp___0;
#line 109
  tmp___1 = long_to_integer((long )channel);
  }
#line 109
  return (tmp___1);
}
}
#line 111 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosfile.c"
SCHEME_OBJECT Prim_file_open_exclusive_output_channel(void) 
{ 
  Tchannel channel ;
  char *tmp ;
  Tchannel tmp___0 ;
  SCHEME_OBJECT tmp___1 ;

  {
  {
#line 115
  while (1) {
    while_continue: /* CIL Label */ ;
#line 115
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 115
  if (*(stack_pointer + 0) >> 58U == 30UL) {
#line 115
    tmp = (char *)((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 2);
  } else {
    {
#line 115
    error_wrong_type_arg(1);
#line 115
    tmp = (char *)0;
    }
  }
  {
#line 115
  tmp___0 = OS_open_exclusive_output_file((char const   *)tmp);
#line 115
  channel = tmp___0;
#line 115
  tmp___1 = long_to_integer((long )channel);
  }
#line 115
  return (tmp___1);
}
}
#line 117 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosfile.c"
SCHEME_OBJECT Prim_file_open_io_channel(void) 
{ 
  Tchannel channel ;
  char *tmp ;
  Tchannel tmp___0 ;
  SCHEME_OBJECT tmp___1 ;

  {
  {
#line 121
  while (1) {
    while_continue: /* CIL Label */ ;
#line 121
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 121
  if (*(stack_pointer + 0) >> 58U == 30UL) {
#line 121
    tmp = (char *)((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 2);
  } else {
    {
#line 121
    error_wrong_type_arg(1);
#line 121
    tmp = (char *)0;
    }
  }
  {
#line 121
  tmp___0 = OS_open_io_file((char const   *)tmp);
#line 121
  channel = tmp___0;
#line 121
  tmp___1 = long_to_integer((long )channel);
  }
#line 121
  return (tmp___1);
}
}
#line 123 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosfile.c"
SCHEME_OBJECT Prim_file_open_append_channel(void) 
{ 
  Tchannel channel ;
  char *tmp ;
  Tchannel tmp___0 ;
  SCHEME_OBJECT tmp___1 ;

  {
  {
#line 127
  while (1) {
    while_continue: /* CIL Label */ ;
#line 127
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 127
  if (*(stack_pointer + 0) >> 58U == 30UL) {
#line 127
    tmp = (char *)((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 2);
  } else {
    {
#line 127
    error_wrong_type_arg(1);
#line 127
    tmp = (char *)0;
    }
  }
  {
#line 127
  tmp___0 = OS_open_append_file((char const   *)tmp);
#line 127
  channel = tmp___0;
#line 127
  tmp___1 = long_to_integer((long )channel);
  }
#line 127
  return (tmp___1);
}
}
#line 129 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosfile.c"
SCHEME_OBJECT Prim_file_length_new(void) 
{ 
  Tchannel tmp ;
  off_t tmp___0 ;
  SCHEME_OBJECT tmp___1 ;

  {
  {
#line 132
  while (1) {
    while_continue: /* CIL Label */ ;
#line 132
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 133
  tmp = arg_channel(1);
#line 133
  tmp___0 = OS_file_length(tmp);
#line 133
  tmp___1 = intmax_to_integer(tmp___0);
  }
#line 133
  return (tmp___1);
}
}
#line 136 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosfile.c"
SCHEME_OBJECT Prim_file_position(void) 
{ 
  Tchannel tmp ;
  off_t tmp___0 ;
  SCHEME_OBJECT tmp___1 ;

  {
  {
#line 140
  while (1) {
    while_continue: /* CIL Label */ ;
#line 140
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 141
  tmp = arg_channel(1);
#line 141
  tmp___0 = OS_file_position(tmp);
#line 141
  tmp___1 = intmax_to_integer(tmp___0);
  }
#line 141
  return (tmp___1);
}
}
#line 144 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosfile.c"
SCHEME_OBJECT Prim_file_set_position(void) 
{ 
  intmax_t tmp ;
  Tchannel tmp___0 ;

  {
  {
#line 148
  while (1) {
    while_continue: /* CIL Label */ ;
#line 148
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 149
  tmp = arg_index_integer_to_intmax(2, 9223372036854775807L);
#line 149
  tmp___0 = arg_channel(1);
#line 149
  OS_file_set_position(tmp___0, tmp);
  }
#line 151
  return ((8UL << 58U) | 1UL);
}
}
#line 154 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosfile.c"
SCHEME_OBJECT Prim_file_truncate(void) 
{ 
  intmax_t tmp ;
  Tchannel tmp___0 ;

  {
  {
#line 158
  while (1) {
    while_continue: /* CIL Label */ ;
#line 158
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 159
  tmp = arg_index_integer_to_intmax(2, 9223372036854775807L);
#line 159
  tmp___0 = arg_channel(1);
#line 159
  OS_file_truncate(tmp___0, tmp);
  }
#line 161
  return ((8UL << 58U) | 1UL);
}
}
#line 218 "/home/khheo/project/mit-scheme-9.2/src/microcode/extern.h"
SCHEME_OBJECT uintmax_to_integer(uintmax_t number ) ;
#line 221
SCHEME_OBJECT double_to_integer(double x ) ;
#line 34 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosenv.c"
SCHEME_OBJECT Prim_nanotime_since_utc_epoch(void) 
{ 
  struct scheme_nanotime t ;

  {
  {
#line 37
  while (1) {
    while_continue: /* CIL Label */ ;
#line 37
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 38
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 38
    if (! (*(stack_pointer + 0) >> 58U == 1UL)) {
      {
#line 38
      error_wrong_type_arg(1);
      }
    }
#line 38
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 39
  OS_nanotime_since_utc_epoch(& t);
#line 40
  *((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 0) = intmax_to_integer(t.seconds);
#line 41
  *((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 1) = uintmax_to_integer((uintmax_t )t.nanoseconds);
  }
#line 42
  return ((8UL << 58U) | 1UL);
}
}
#line 45 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosenv.c"
SCHEME_OBJECT Prim_encoded_time(void) 
{ 
  time_t tmp ;
  SCHEME_OBJECT tmp___0 ;

  {
  {
#line 48
  tmp = OS_encoded_time();
#line 48
  tmp___0 = intmax_to_integer(tmp);
  }
#line 48
  return (tmp___0);
}
}
#line 82 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosenv.c"
SCHEME_OBJECT Prim_decode_time(void) 
{ 
  SCHEME_OBJECT vec ;
  SCHEME_OBJECT tmp ;
  unsigned int len ;
  struct time_structure ts ;
  intmax_t tmp___0 ;
  SCHEME_OBJECT tmp___1 ;
  SCHEME_OBJECT tmp___2 ;

  {
  {
#line 86
  while (1) {
    while_continue: /* CIL Label */ ;
#line 86
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 86
  if (*(stack_pointer + 0) >> 58U == 10UL) {
#line 86
    tmp = *(stack_pointer + 0);
  } else {
    {
#line 86
    error_wrong_type_arg(1);
#line 86
    tmp = (SCHEME_OBJECT )0;
    }
  }
#line 86
  vec = tmp;
#line 86
  len = (unsigned int )(*((SCHEME_OBJECT *)(vec & 288230376151711743UL) + 0) & 288230376151711743UL);
#line 86
  if (! (len >= 10U)) {
    {
#line 86
    error_bad_range_arg(1);
    }
  }
  {
#line 86
  tmp___0 = arg_index_integer_to_intmax(2, 9223372036854775807L);
#line 86
  OS_decode_time(tmp___0, & ts);
#line 86
  *((SCHEME_OBJECT *)(vec & 288230376151711743UL) + 2) = ulong_to_integer((unsigned long )ts.second);
#line 86
  *((SCHEME_OBJECT *)(vec & 288230376151711743UL) + 3) = ulong_to_integer((unsigned long )ts.minute);
#line 86
  *((SCHEME_OBJECT *)(vec & 288230376151711743UL) + 4) = ulong_to_integer((unsigned long )ts.hour);
#line 86
  *((SCHEME_OBJECT *)(vec & 288230376151711743UL) + 5) = ulong_to_integer((unsigned long )ts.day);
#line 86
  *((SCHEME_OBJECT *)(vec & 288230376151711743UL) + 6) = ulong_to_integer((unsigned long )ts.month);
#line 86
  *((SCHEME_OBJECT *)(vec & 288230376151711743UL) + 7) = ulong_to_integer((unsigned long )ts.year);
#line 86
  *((SCHEME_OBJECT *)(vec & 288230376151711743UL) + 8) = ulong_to_integer((unsigned long )ts.day_of_week);
  }
#line 86
  if (ts.daylight_savings_time < 0) {
#line 86
    *((SCHEME_OBJECT *)(vec & 288230376151711743UL) + 9) = 0UL;
  } else {
    {
#line 86
    tmp___1 = long_to_integer((long )ts.daylight_savings_time);
#line 86
    *((SCHEME_OBJECT *)(vec & 288230376151711743UL) + 9) = tmp___1;
    }
  }
#line 86
  if (ts.time_zone == 2147483647) {
#line 86
    *((SCHEME_OBJECT *)(vec & 288230376151711743UL) + 10) = 0UL;
  } else {
    {
#line 86
    tmp___2 = long_to_integer((long )ts.time_zone);
#line 86
    *((SCHEME_OBJECT *)(vec & 288230376151711743UL) + 10) = tmp___2;
    }
  }
#line 86
  return ((8UL << 58U) | 1UL);
}
}
#line 88 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosenv.c"
SCHEME_OBJECT Prim_decode_utc(void) 
{ 
  SCHEME_OBJECT vec ;
  SCHEME_OBJECT tmp ;
  unsigned int len ;
  struct time_structure ts ;
  intmax_t tmp___0 ;
  SCHEME_OBJECT tmp___1 ;
  SCHEME_OBJECT tmp___2 ;

  {
  {
#line 92
  while (1) {
    while_continue: /* CIL Label */ ;
#line 92
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 92
  if (*(stack_pointer + 0) >> 58U == 10UL) {
#line 92
    tmp = *(stack_pointer + 0);
  } else {
    {
#line 92
    error_wrong_type_arg(1);
#line 92
    tmp = (SCHEME_OBJECT )0;
    }
  }
#line 92
  vec = tmp;
#line 92
  len = (unsigned int )(*((SCHEME_OBJECT *)(vec & 288230376151711743UL) + 0) & 288230376151711743UL);
#line 92
  if (! (len >= 10U)) {
    {
#line 92
    error_bad_range_arg(1);
    }
  }
  {
#line 92
  tmp___0 = arg_index_integer_to_intmax(2, 9223372036854775807L);
#line 92
  OS_decode_utc(tmp___0, & ts);
#line 92
  *((SCHEME_OBJECT *)(vec & 288230376151711743UL) + 2) = ulong_to_integer((unsigned long )ts.second);
#line 92
  *((SCHEME_OBJECT *)(vec & 288230376151711743UL) + 3) = ulong_to_integer((unsigned long )ts.minute);
#line 92
  *((SCHEME_OBJECT *)(vec & 288230376151711743UL) + 4) = ulong_to_integer((unsigned long )ts.hour);
#line 92
  *((SCHEME_OBJECT *)(vec & 288230376151711743UL) + 5) = ulong_to_integer((unsigned long )ts.day);
#line 92
  *((SCHEME_OBJECT *)(vec & 288230376151711743UL) + 6) = ulong_to_integer((unsigned long )ts.month);
#line 92
  *((SCHEME_OBJECT *)(vec & 288230376151711743UL) + 7) = ulong_to_integer((unsigned long )ts.year);
#line 92
  *((SCHEME_OBJECT *)(vec & 288230376151711743UL) + 8) = ulong_to_integer((unsigned long )ts.day_of_week);
  }
#line 92
  if (ts.daylight_savings_time < 0) {
#line 92
    *((SCHEME_OBJECT *)(vec & 288230376151711743UL) + 9) = 0UL;
  } else {
    {
#line 92
    tmp___1 = long_to_integer((long )ts.daylight_savings_time);
#line 92
    *((SCHEME_OBJECT *)(vec & 288230376151711743UL) + 9) = tmp___1;
    }
  }
#line 92
  if (ts.time_zone == 2147483647) {
#line 92
    *((SCHEME_OBJECT *)(vec & 288230376151711743UL) + 10) = 0UL;
  } else {
    {
#line 92
    tmp___2 = long_to_integer((long )ts.time_zone);
#line 92
    *((SCHEME_OBJECT *)(vec & 288230376151711743UL) + 10) = tmp___2;
    }
  }
#line 92
  return ((8UL << 58U) | 1UL);
}
}
#line 94 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosenv.c"
SCHEME_OBJECT Prim_encode_time(void) 
{ 
  SCHEME_OBJECT vec ;
  unsigned int len ;
  struct time_structure ts ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  long tmp___6 ;
  long tmp___8 ;
  _Bool tmp___9 ;
  time_t tmp___10 ;
  SCHEME_OBJECT tmp___11 ;

  {
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 100
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 102
  if (*(stack_pointer + 0) >> 58U == 10UL) {
#line 102
    vec = *(stack_pointer + 0);
  } else {
    {
#line 102
    error_wrong_type_arg(1);
#line 102
    vec = (SCHEME_OBJECT )0;
    }
  }
#line 103
  len = (unsigned int )(*((SCHEME_OBJECT *)(vec & 288230376151711743UL) + 0) & 288230376151711743UL);
#line 104
  if (! (len >= 8U)) {
    {
#line 105
    error_bad_range_arg(1);
    }
  }
  {
#line 106
  tmp = integer_to_ulong(*((SCHEME_OBJECT *)(vec & 288230376151711743UL) + 2));
#line 106
  ts.second = (unsigned int )tmp;
#line 107
  tmp___0 = integer_to_ulong(*((SCHEME_OBJECT *)(vec & 288230376151711743UL) + 3));
#line 107
  ts.minute = (unsigned int )tmp___0;
#line 108
  tmp___1 = integer_to_ulong(*((SCHEME_OBJECT *)(vec & 288230376151711743UL) + 4));
#line 108
  ts.hour = (unsigned int )tmp___1;
#line 109
  tmp___2 = integer_to_ulong(*((SCHEME_OBJECT *)(vec & 288230376151711743UL) + 5));
#line 109
  ts.day = (unsigned int )tmp___2;
#line 110
  tmp___3 = integer_to_ulong(*((SCHEME_OBJECT *)(vec & 288230376151711743UL) + 6));
#line 110
  ts.month = (unsigned int )tmp___3;
#line 111
  tmp___4 = integer_to_ulong(*((SCHEME_OBJECT *)(vec & 288230376151711743UL) + 7));
#line 111
  ts.year = (unsigned int )tmp___4;
#line 112
  tmp___5 = integer_to_ulong(*((SCHEME_OBJECT *)(vec & 288230376151711743UL) + 8));
#line 112
  ts.day_of_week = (unsigned int )tmp___5;
  }
#line 113
  if (len > 8U) {
#line 113
    if (*((SCHEME_OBJECT *)(vec & 288230376151711743UL) + 9) >> 58U == 26UL) {
      {
#line 113
      tmp___6 = integer_to_long(*((SCHEME_OBJECT *)(vec & 288230376151711743UL) + 9));
#line 113
      ts.daylight_savings_time = (int )tmp___6;
      }
    } else
#line 113
    if (*((SCHEME_OBJECT *)(vec & 288230376151711743UL) + 9) >> 58U == 14UL) {
      {
#line 113
      tmp___6 = integer_to_long(*((SCHEME_OBJECT *)(vec & 288230376151711743UL) + 9));
#line 113
      ts.daylight_savings_time = (int )tmp___6;
      }
    } else {
#line 113
      ts.daylight_savings_time = -1;
    }
  } else {
#line 113
    ts.daylight_savings_time = -1;
  }
#line 117
  if (len > 9U) {
#line 117
    if (*((SCHEME_OBJECT *)(vec & 288230376151711743UL) + 10) >> 58U == 26UL) {
#line 117
      goto _L;
    } else
#line 117
    if (*((SCHEME_OBJECT *)(vec & 288230376151711743UL) + 10) >> 58U == 14UL) {
      _L: /* CIL Label */ 
      {
#line 117
      tmp___9 = integer_to_long_p(*((SCHEME_OBJECT *)(vec & 288230376151711743UL) + 10));
      }
#line 117
      if (tmp___9) {
        {
#line 117
        tmp___8 = integer_to_long(*((SCHEME_OBJECT *)(vec & 288230376151711743UL) + 10));
#line 117
        ts.time_zone = (int )tmp___8;
        }
      } else {
#line 117
        ts.time_zone = 2147483647;
      }
    } else {
#line 117
      ts.time_zone = 2147483647;
    }
  } else {
#line 117
    ts.time_zone = 2147483647;
  }
  {
#line 123
  tmp___10 = OS_encode_time(& ts);
#line 123
  tmp___11 = intmax_to_integer(tmp___10);
  }
#line 123
  return (tmp___11);
}
}
#line 126 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosenv.c"
SCHEME_OBJECT Prim_system_clock(void) 
{ 
  double tmp ;
  SCHEME_OBJECT tmp___0 ;

  {
  {
#line 129
  while (1) {
    while_continue: /* CIL Label */ ;
#line 129
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 130
  tmp = OS_process_clock();
#line 130
  tmp___0 = double_to_integer(tmp);
  }
#line 130
  return (tmp___0);
}
}
#line 133 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosenv.c"
SCHEME_OBJECT Prim_real_time_clock(void) 
{ 
  double tmp ;
  SCHEME_OBJECT tmp___0 ;

  {
  {
#line 136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 136
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 137
  tmp = OS_real_time_clock();
#line 137
  tmp___0 = double_to_integer(tmp);
  }
#line 137
  return (tmp___0);
}
}
#line 140 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosenv.c"
SCHEME_OBJECT Prim_process_timer_clear(void) 
{ 


  {
  {
#line 143
  while (1) {
    while_continue: /* CIL Label */ ;
#line 143
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 144
  OS_process_timer_clear();
  }
#line 145
  return ((8UL << 58U) | 1UL);
}
}
#line 148 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosenv.c"
SCHEME_OBJECT Prim_process_timer_set(void) 
{ 
  long tmp ;
  long tmp___0 ;

  {
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 155
  tmp = arg_nonnegative_integer(2);
#line 155
  tmp___0 = arg_nonnegative_integer(1);
#line 155
  OS_process_timer_set(tmp___0, tmp);
  }
#line 157
  return ((8UL << 58U) | 1UL);
}
}
#line 160 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosenv.c"
SCHEME_OBJECT Prim_real_timer_clear(void) 
{ 


  {
  {
#line 163
  while (1) {
    while_continue: /* CIL Label */ ;
#line 163
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 164
  OS_real_timer_clear();
  }
#line 165
  return ((8UL << 58U) | 1UL);
}
}
#line 168 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosenv.c"
SCHEME_OBJECT Prim_real_timer_set(void) 
{ 
  long tmp ;
  long tmp___0 ;

  {
  {
#line 174
  while (1) {
    while_continue: /* CIL Label */ ;
#line 174
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 175
  tmp = arg_nonnegative_integer(2);
#line 175
  tmp___0 = arg_nonnegative_integer(1);
#line 175
  OS_real_timer_set(tmp___0, tmp);
  }
#line 177
  return ((8UL << 58U) | 1UL);
}
}
#line 180 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosenv.c"
SCHEME_OBJECT Prim_profile_timer_clear(void) 
{ 


  {
  {
#line 183
  while (1) {
    while_continue: /* CIL Label */ ;
#line 183
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 184
  OS_profile_timer_clear();
  }
#line 185
  return ((8UL << 58U) | 1UL);
}
}
#line 188 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosenv.c"
SCHEME_OBJECT Prim_profile_timer_set(void) 
{ 
  long tmp ;
  long tmp___0 ;

  {
  {
#line 194
  while (1) {
    while_continue: /* CIL Label */ ;
#line 194
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 195
  tmp = arg_nonnegative_integer(2);
#line 195
  tmp___0 = arg_nonnegative_integer(1);
#line 195
  OS_profile_timer_set(tmp___0, tmp);
  }
#line 197
  return ((8UL << 58U) | 1UL);
}
}
#line 200 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosenv.c"
SCHEME_OBJECT Prim_setup_timer_interrupt(void) 
{ 
  unsigned long days ;
  long tmp ;
  unsigned long centisec ;
  long tmp___0 ;

  {
  {
#line 203
  while (1) {
    while_continue: /* CIL Label */ ;
#line 203
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 204
  if (*(stack_pointer + 0) == 0UL) {
#line 204
    if (*(stack_pointer + 1) == 0UL) {
      {
#line 205
      OS_process_timer_clear();
      }
    } else {
      {
#line 208
      tmp = arg_nonnegative_integer(1);
#line 208
      days = (unsigned long )tmp;
#line 209
      tmp___0 = arg_nonnegative_integer(2);
#line 209
      centisec = (unsigned long )tmp___0;
#line 210
      OS_process_timer_set((clock_t )(((((days * 24UL) * 60UL) * 60UL) * 100UL + centisec) * 10UL),
                           (clock_t )0);
      }
    }
  } else {
    {
#line 208
    tmp = arg_nonnegative_integer(1);
#line 208
    days = (unsigned long )tmp;
#line 209
    tmp___0 = arg_nonnegative_integer(2);
#line 209
    centisec = (unsigned long )tmp___0;
#line 210
    OS_process_timer_set((clock_t )(((((days * 24UL) * 60UL) * 60UL) * 100UL + centisec) * 10UL),
                         (clock_t )0);
    }
  }
#line 213
  return ((8UL << 58U) | 1UL);
}
}
#line 216 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosenv.c"
SCHEME_OBJECT Prim_working_dir_pathname(void) 
{ 
  char const   *tmp ;
  SCHEME_OBJECT tmp___0 ;

  {
  {
#line 219
  while (1) {
    while_continue: /* CIL Label */ ;
#line 219
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 220
  tmp = OS_working_dir_pathname();
#line 220
  tmp___0 = char_pointer_to_string(tmp);
  }
#line 220
  return (tmp___0);
}
}
#line 223 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosenv.c"
SCHEME_OBJECT Prim_set_working_dir_pathname(void) 
{ 
  char *tmp ;

  {
  {
#line 226
  while (1) {
    while_continue: /* CIL Label */ ;
#line 226
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 227
  if (*(stack_pointer + 0) >> 58U == 30UL) {
#line 227
    tmp = (char *)((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 2);
  } else {
    {
#line 227
    error_wrong_type_arg(1);
#line 227
    tmp = (char *)0;
    }
  }
  {
#line 227
  OS_set_working_dir_pathname((char const   *)tmp);
  }
#line 228
  return ((8UL << 58U) | 1UL);
}
}
#line 231 "/home/khheo/project/mit-scheme-9.2/src/microcode/prosenv.c"
SCHEME_OBJECT Prim_system_call_error_message(void) 
{ 
  char const   *message ;
  long tmp ;
  char const   *tmp___0 ;
  SCHEME_OBJECT tmp___1 ;
  unsigned long tmp___2 ;

  {
  {
#line 233
  while (1) {
    while_continue: /* CIL Label */ ;
#line 233
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 235
  tmp = arg_nonnegative_integer(1);
#line 235
  tmp___0 = OS_error_code_to_message((unsigned int )tmp);
#line 235
  message = tmp___0;
  }
#line 237
  if ((unsigned long )message == (unsigned long )((char const   *)0)) {
#line 237
    tmp___2 = 0UL;
  } else {
    {
#line 237
    tmp___1 = char_pointer_to_string(message);
#line 237
    tmp___2 = tmp___1;
    }
  }
#line 237
  return (tmp___2);
}
}
#line 154 "/home/khheo/project/mit-scheme-9.2/src/microcode/obstack.h"
void _obstack_begin(struct obstack *h , int size , long alignment , void *(*chunkfun)(size_t  ) ,
                    void (*freefun)(void * ) ) ;
#line 33 "/home/khheo/project/mit-scheme-9.2/src/microcode/dstack.h"
void dstack_initialize(void) ;
#line 36
void dstack_reset(void) ;
#line 57 "/home/khheo/project/mit-scheme-9.2/src/microcode/dstack.h"
void *dstack_position  ;
#line 54 "/home/khheo/project/mit-scheme-9.2/src/microcode/outf.h"
void outf_flush_fatal(void) ;
#line 38 "/home/khheo/project/mit-scheme-9.2/src/microcode/wind.c"
static  __attribute__((__noreturn__)) void error(char const   *procedure_name , char const   *message ) ;
#line 40
static  __attribute__((__noreturn__)) void error(char const   *procedure_name , char const   *message ) ;
#line 40 "/home/khheo/project/mit-scheme-9.2/src/microcode/wind.c"
static void error(char const   *procedure_name , char const   *message ) 
{ 
  char *__cil_tmp3 ;

  {
  {
#line 43
  outf_fatal("%s: %s\n", procedure_name, message);
#line 44
  outf_flush_fatal();
#line 45
  abort();
  }
}
}
#line 55 "/home/khheo/project/mit-scheme-9.2/src/microcode/wind.c"
static struct obstack dstack  ;
#line 56 "/home/khheo/project/mit-scheme-9.2/src/microcode/wind.c"
static struct winding_record *current_winding_record  ;
#line 59 "/home/khheo/project/mit-scheme-9.2/src/microcode/wind.c"
void dstack_initialize(void) 
{ 


  {
  {
#line 62
  _obstack_begin(& dstack, 0, 0L, & OS_malloc, (void (*)(void * ))(& free));
#line 63
  dstack_position = (void *)0;
#line 64
  current_winding_record = (struct winding_record *)0;
  }
#line 65
  return;
}
}
#line 67 "/home/khheo/project/mit-scheme-9.2/src/microcode/wind.c"
void dstack_reset(void) 
{ 
  struct obstack *__o ;
  void *__obj ;
  char *tmp ;

  {
  {
#line 70
  block_signals();
#line 71
  __o = & dstack;
#line 71
  __obj = (void *)0;
  }
#line 71
  if ((unsigned long )__obj > (unsigned long )((void *)__o->chunk)) {
#line 71
    if ((unsigned long )__obj < (unsigned long )((void *)__o->chunk_limit)) {
#line 71
      tmp = (char *)__obj;
#line 71
      __o->object_base = tmp;
#line 71
      __o->next_free = tmp;
    } else {
      {
#line 71
      obstack_free(__o, __obj);
      }
    }
  } else {
    {
#line 71
    obstack_free(__o, __obj);
    }
  }
  {
#line 72
  dstack_initialize();
#line 73
  unblock_signals();
  }
#line 74
  return;
}
}
#line 78 "/home/khheo/project/mit-scheme-9.2/src/microcode/wind.c"
void *dstack_alloc(unsigned int length ) 
{ 
  void *chunk ;
  struct obstack *__h ;
  struct obstack *__o ;
  int __len ;
  struct obstack *__o___0 ;
  void *value ;

  {
  {
#line 82
  block_signals();
#line 83
  __h = & dstack;
#line 83
  __o = __h;
#line 83
  __len = (int )(sizeof(void *) + (unsigned long )length);
  }
#line 83
  if (__o->chunk_limit - __o->next_free < (long )__len) {
    {
#line 83
    _obstack_newchunk(__o, __len);
    }
  }
#line 83
  __o->next_free += __len;
#line 83
  __o___0 = __h;
#line 83
  value = (void *)__o___0->object_base;
#line 83
  __o___0->next_free = (char *)((void *)((char *)0 + (((__o___0->next_free - (char *)0) + __o___0->alignment_mask) & ~ __o___0->alignment_mask)));
#line 83
  if (__o___0->next_free - (char *)__o___0->chunk > __o___0->chunk_limit - (char *)__o___0->chunk) {
#line 83
    __o___0->next_free = __o___0->chunk_limit;
  }
  {
#line 83
  __o___0->object_base = __o___0->next_free;
#line 83
  chunk = value;
#line 84
  *((void **)chunk) = dstack_position;
#line 85
  dstack_position = chunk;
#line 86
  unblock_signals();
  }
#line 87
  return ((void *)((char *)chunk + sizeof(void *)));
}
}
#line 90 "/home/khheo/project/mit-scheme-9.2/src/microcode/wind.c"
void dstack_protect(void (*protector)(void *environment ) , void *environment ) 
{ 
  struct winding_record *record ;
  void *tmp ;

  {
  {
#line 94
  tmp = dstack_alloc((unsigned int )sizeof(struct winding_record ));
#line 94
  record = (struct winding_record *)tmp;
#line 96
  record->next = current_winding_record;
#line 97
  record->protector = protector;
#line 98
  record->environment = environment;
#line 99
  current_winding_record = record;
  }
#line 100
  return;
}
}
#line 102 "/home/khheo/project/mit-scheme-9.2/src/microcode/wind.c"
void dstack_alloc_and_protect(unsigned int length , void (*initializer)(void *environment ) ,
                              void (*protector)(void *environment ) ) 
{ 
  struct winding_record *record ;
  void *tmp ;
  void *environment ;

  {
  {
#line 107
  tmp = dstack_alloc((unsigned int )(sizeof(struct winding_record ) + (unsigned long )length));
#line 107
  record = (struct winding_record *)tmp;
#line 109
  environment = (void *)((char *)record + sizeof(struct winding_record ));
#line 110
  (*initializer)(environment);
#line 111
  record->next = current_winding_record;
#line 112
  record->protector = protector;
#line 113
  record->environment = environment;
#line 114
  current_winding_record = record;
  }
#line 115
  return;
}
}
#line 117 "/home/khheo/project/mit-scheme-9.2/src/microcode/wind.c"
void dstack_set_position(void *position___1 ) 
{ 
  void **sp ;
  void *sp___0 ;
  struct winding_record *record ;
  void **sp___1 ;
  struct obstack *__o ;
  void *__obj ;
  char *tmp ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 120
  block_signals();
#line 124
  sp = (void **)dstack_position;
  }
  {
#line 125
  while (1) {
    while_continue: /* CIL Label */ ;
#line 125
    if (! ((unsigned long )sp != (unsigned long )position___1)) {
#line 125
      goto while_break;
    }
#line 127
    if ((unsigned long )sp == (unsigned long )((void **)0)) {
      {
#line 128
      error("dstack_set_position", "position argument not found");
      }
    }
#line 129
    sp = (void **)*sp;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 133
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 133
    if (! ((unsigned long )dstack_position != (unsigned long )position___1)) {
#line 133
      goto while_break___0;
    }
#line 135
    if ((unsigned long )dstack_position == (unsigned long )((void *)0)) {
      {
#line 136
      error("dstack_set_position", "no more stack");
      }
    }
#line 137
    if ((unsigned long )((void *)((char *)dstack_position + sizeof(void *))) == (unsigned long )current_winding_record) {
      {
#line 139
      sp___0 = dstack_position;
#line 140
      record = current_winding_record;
#line 146
      unblock_signals();
#line 147
      (*(record->protector))(record->environment);
#line 148
      block_signals();
      }
#line 149
      if ((unsigned long )sp___0 != (unsigned long )dstack_position) {
        {
#line 150
        error("dstack_set_position", "stack slipped during unwind");
        }
      }
#line 151
      current_winding_record = record->next;
    }
#line 154
    sp___1 = (void **)dstack_position;
#line 155
    dstack_position = *sp___1;
#line 156
    __o = & dstack;
#line 156
    __obj = (void *)sp___1;
#line 156
    if ((unsigned long )__obj > (unsigned long )((void *)__o->chunk)) {
#line 156
      if ((unsigned long )__obj < (unsigned long )((void *)__o->chunk_limit)) {
#line 156
        tmp = (char *)__obj;
#line 156
        __o->object_base = tmp;
#line 156
        __o->next_free = tmp;
      } else {
        {
#line 156
        obstack_free(__o, __obj);
        }
      }
    } else {
      {
#line 156
      obstack_free(__o, __obj);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 159
  unblock_signals();
  }
#line 160
  return;
}
}
#line 168 "/home/khheo/project/mit-scheme-9.2/src/microcode/wind.c"
static void undo_binding(void *environment ) 
{ 


  {
#line 171
  *(((struct binding_record *)environment)->location) = ((struct binding_record *)environment)->value;
#line 173
  return;
}
}
#line 175 "/home/khheo/project/mit-scheme-9.2/src/microcode/wind.c"
static void **save_binding_location  ;
#line 177 "/home/khheo/project/mit-scheme-9.2/src/microcode/wind.c"
static void save_binding(void *environment ) 
{ 


  {
#line 180
  ((struct binding_record *)environment)->location = save_binding_location;
#line 182
  ((struct binding_record *)environment)->value = *save_binding_location;
#line 184
  return;
}
}
#line 186 "/home/khheo/project/mit-scheme-9.2/src/microcode/wind.c"
void dstack_bind(void *location , void *value ) 
{ 


  {
  {
#line 189
  save_binding_location = (void **)location;
#line 190
  dstack_alloc_and_protect((unsigned int )sizeof(struct binding_record ), & save_binding,
                           & undo_binding);
#line 192
  *((void **)location) = value;
  }
#line 193
  return;
}
}
#line 69 "/home/khheo/project/mit-scheme-9.2/src/microcode/gc.h"
gc_type_t gc_type_code(unsigned int type_code ) ;
#line 284 "/home/khheo/project/mit-scheme-9.2/src/microcode/extern.h"
SCHEME_OBJECT allocate_vector(unsigned int type , unsigned int manifest_type , unsigned long length ,
                              SCHEME_OBJECT **fp ) ;
#line 286
SCHEME_OBJECT allocate_non_marked_vector(unsigned int type , unsigned long length ,
                                         _Bool gc_check_p ) ;
#line 50 "/home/khheo/project/mit-scheme-9.2/src/microcode/vector.c"
SCHEME_OBJECT allocate_vector(unsigned int type , unsigned int manifest_type , unsigned long length ,
                              SCHEME_OBJECT **fp ) 
{ 
  SCHEME_OBJECT result ;
  SCHEME_OBJECT *tmp ;

  {
#line 56
  result = ((unsigned long )type << 58U) | (SCHEME_OBJECT )*fp;
#line 57
  tmp = *fp;
#line 57
  (*fp) ++;
#line 57
  *tmp = ((unsigned long )manifest_type << 58U) | length;
#line 58
  *fp += length;
#line 59
  return (result);
}
}
#line 62 "/home/khheo/project/mit-scheme-9.2/src/microcode/vector.c"
SCHEME_OBJECT allocate_non_marked_vector(unsigned int type , unsigned long length ,
                                         _Bool gc_check_p ) 
{ 
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;
  SCHEME_OBJECT tmp___2 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 67
  if (gc_check_p) {
    {
#line 68
    while (1) {
      while_continue: /* CIL Label */ ;
#line 68
      if ((unsigned long )Free >= (unsigned long )heap_start) {
#line 68
        if ((unsigned long )Free < (unsigned long )heap_alloc_limit) {
#line 68
          if (! ((unsigned long )(Free + (1UL + length)) <= (unsigned long )heap_alloc_limit)) {
#line 68
            goto _L___0;
          }
        } else {
#line 68
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 68
      if ((Registers[1] & 4UL) != 0UL) {
        {
#line 68
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 68
          if ((unsigned long )Free_primitive < (unsigned long )heap_start) {
            {
#line 68
            outf_fatal("\nMicrocode requested primitive GC outside primitive!\n");
#line 68
            Microcode_Termination(12);
            }
          }
#line 68
          if ((unsigned long )Free < (unsigned long )Free_primitive) {
            {
#line 68
            outf_fatal("\nFree has gone backwards!\n");
#line 68
            Microcode_Termination(12);
            }
          }
          {
#line 68
          while (1) {
            while_continue___1: /* CIL Label */ ;
            {
#line 68
            while (1) {
              while_continue___2: /* CIL Label */ ;
              {
#line 68
              set_ulong_register(12U, Registers[12] | 4UL);
              }
              {
#line 68
              while (1) {
                while_continue___3: /* CIL Label */ ;
#line 68
                if ((Registers[1] & Registers[12]) != 0UL) {
#line 68
                  tmp___0 = memory_block_start;
                } else {
#line 68
                  if ((Registers[1] & 4UL) != 0UL) {
#line 68
                    tmp = heap_alloc_limit;
                  } else {
#line 68
                    tmp = heap_end;
                  }
#line 68
                  tmp___0 = tmp;
                }
                {
#line 68
                set_ptr_register(0U, tmp___0);
                }
#line 68
                if ((Registers[1] & 1UL) != 0UL) {
#line 68
                  tmp___1 = stack_guard;
                } else {
#line 68
                  tmp___1 = stack_start;
                }
                {
#line 68
                set_ptr_register(11U, tmp___1);
                }
#line 68
                goto while_break___3;
              }
              while_break___3: /* CIL Label */ ;
              }
#line 68
              goto while_break___2;
            }
            while_break___2: /* CIL Label */ ;
            }
#line 68
            gc_space_needed = (1UL + length) + (unsigned long )(Free - Free_primitive);
#line 68
            goto while_break___1;
          }
          while_break___1: /* CIL Label */ ;
          }
          {
#line 68
          signal_interrupt_from_primitive();
          }
#line 68
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 68
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 69
  tmp___2 = allocate_vector(type, 39U, length, & Free);
  }
#line 69
  return (tmp___2);
}
}
#line 72 "/home/khheo/project/mit-scheme-9.2/src/microcode/vector.c"
SCHEME_OBJECT allocate_marked_vector(unsigned int type , unsigned long length , _Bool gc_check_p ) 
{ 
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;
  SCHEME_OBJECT tmp___2 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 77
  if (gc_check_p) {
    {
#line 78
    while (1) {
      while_continue: /* CIL Label */ ;
#line 78
      if ((unsigned long )Free >= (unsigned long )heap_start) {
#line 78
        if ((unsigned long )Free < (unsigned long )heap_alloc_limit) {
#line 78
          if (! ((unsigned long )(Free + (1UL + length)) <= (unsigned long )heap_alloc_limit)) {
#line 78
            goto _L___0;
          }
        } else {
#line 78
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 78
      if ((Registers[1] & 4UL) != 0UL) {
        {
#line 78
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 78
          if ((unsigned long )Free_primitive < (unsigned long )heap_start) {
            {
#line 78
            outf_fatal("\nMicrocode requested primitive GC outside primitive!\n");
#line 78
            Microcode_Termination(12);
            }
          }
#line 78
          if ((unsigned long )Free < (unsigned long )Free_primitive) {
            {
#line 78
            outf_fatal("\nFree has gone backwards!\n");
#line 78
            Microcode_Termination(12);
            }
          }
          {
#line 78
          while (1) {
            while_continue___1: /* CIL Label */ ;
            {
#line 78
            while (1) {
              while_continue___2: /* CIL Label */ ;
              {
#line 78
              set_ulong_register(12U, Registers[12] | 4UL);
              }
              {
#line 78
              while (1) {
                while_continue___3: /* CIL Label */ ;
#line 78
                if ((Registers[1] & Registers[12]) != 0UL) {
#line 78
                  tmp___0 = memory_block_start;
                } else {
#line 78
                  if ((Registers[1] & 4UL) != 0UL) {
#line 78
                    tmp = heap_alloc_limit;
                  } else {
#line 78
                    tmp = heap_end;
                  }
#line 78
                  tmp___0 = tmp;
                }
                {
#line 78
                set_ptr_register(0U, tmp___0);
                }
#line 78
                if ((Registers[1] & 1UL) != 0UL) {
#line 78
                  tmp___1 = stack_guard;
                } else {
#line 78
                  tmp___1 = stack_start;
                }
                {
#line 78
                set_ptr_register(11U, tmp___1);
                }
#line 78
                goto while_break___3;
              }
              while_break___3: /* CIL Label */ ;
              }
#line 78
              goto while_break___2;
            }
            while_break___2: /* CIL Label */ ;
            }
#line 78
            gc_space_needed = (1UL + length) + (unsigned long )(Free - Free_primitive);
#line 78
            goto while_break___1;
          }
          while_break___1: /* CIL Label */ ;
          }
          {
#line 78
          signal_interrupt_from_primitive();
          }
#line 78
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 78
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 79
  tmp___2 = allocate_vector(type, 0U, length, & Free);
  }
#line 79
  return (tmp___2);
}
}
#line 82 "/home/khheo/project/mit-scheme-9.2/src/microcode/vector.c"
SCHEME_OBJECT make_vector(unsigned long length , SCHEME_OBJECT contents , _Bool gc_check_p ) 
{ 
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;
  SCHEME_OBJECT result ;
  SCHEME_OBJECT *tmp___2 ;
  SCHEME_OBJECT *tmp___3 ;
  unsigned long tmp___4 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 85
  if (gc_check_p) {
    {
#line 86
    while (1) {
      while_continue: /* CIL Label */ ;
#line 86
      if ((unsigned long )Free >= (unsigned long )heap_start) {
#line 86
        if ((unsigned long )Free < (unsigned long )heap_alloc_limit) {
#line 86
          if (! ((unsigned long )(Free + (length + 1UL)) <= (unsigned long )heap_alloc_limit)) {
#line 86
            goto _L___0;
          }
        } else {
#line 86
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 86
      if ((Registers[1] & 4UL) != 0UL) {
        {
#line 86
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 86
          if ((unsigned long )Free_primitive < (unsigned long )heap_start) {
            {
#line 86
            outf_fatal("\nMicrocode requested primitive GC outside primitive!\n");
#line 86
            Microcode_Termination(12);
            }
          }
#line 86
          if ((unsigned long )Free < (unsigned long )Free_primitive) {
            {
#line 86
            outf_fatal("\nFree has gone backwards!\n");
#line 86
            Microcode_Termination(12);
            }
          }
          {
#line 86
          while (1) {
            while_continue___1: /* CIL Label */ ;
            {
#line 86
            while (1) {
              while_continue___2: /* CIL Label */ ;
              {
#line 86
              set_ulong_register(12U, Registers[12] | 4UL);
              }
              {
#line 86
              while (1) {
                while_continue___3: /* CIL Label */ ;
#line 86
                if ((Registers[1] & Registers[12]) != 0UL) {
#line 86
                  tmp___0 = memory_block_start;
                } else {
#line 86
                  if ((Registers[1] & 4UL) != 0UL) {
#line 86
                    tmp = heap_alloc_limit;
                  } else {
#line 86
                    tmp = heap_end;
                  }
#line 86
                  tmp___0 = tmp;
                }
                {
#line 86
                set_ptr_register(0U, tmp___0);
                }
#line 86
                if ((Registers[1] & 1UL) != 0UL) {
#line 86
                  tmp___1 = stack_guard;
                } else {
#line 86
                  tmp___1 = stack_start;
                }
                {
#line 86
                set_ptr_register(11U, tmp___1);
                }
#line 86
                goto while_break___3;
              }
              while_break___3: /* CIL Label */ ;
              }
#line 86
              goto while_break___2;
            }
            while_break___2: /* CIL Label */ ;
            }
#line 86
            gc_space_needed = (length + 1UL) + (unsigned long )(Free - Free_primitive);
#line 86
            goto while_break___1;
          }
          while_break___1: /* CIL Label */ ;
          }
          {
#line 86
          signal_interrupt_from_primitive();
          }
#line 86
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 86
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 88
  result = (10UL << 58U) | (SCHEME_OBJECT )Free;
#line 89
  tmp___2 = Free;
#line 89
  Free ++;
#line 89
  *tmp___2 = length;
  {
#line 90
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 90
    tmp___4 = length;
#line 90
    length --;
#line 90
    if (! (tmp___4 > 0UL)) {
#line 90
      goto while_break___4;
    }
#line 91
    tmp___3 = Free;
#line 91
    Free ++;
#line 91
    *tmp___3 = contents;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 92
  return (result);
}
}
#line 96 "/home/khheo/project/mit-scheme-9.2/src/microcode/vector.c"
SCHEME_OBJECT Prim_vector_cons(void) 
{ 
  long tmp ;
  SCHEME_OBJECT tmp___0 ;

  {
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 99
  tmp = arg_nonnegative_integer(1);
#line 99
  tmp___0 = make_vector((unsigned long )tmp, *(stack_pointer + 1), (_Bool)1);
  }
#line 99
  return (tmp___0);
}
}
#line 103 "/home/khheo/project/mit-scheme-9.2/src/microcode/vector.c"
SCHEME_OBJECT Prim_vector(void) 
{ 
  SCHEME_OBJECT result ;
  SCHEME_OBJECT tmp ;
  SCHEME_OBJECT *argument_scan ;
  SCHEME_OBJECT *argument_limit ;
  SCHEME_OBJECT *result_scan ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;

  {
  {
#line 105
  while (1) {
    while_continue: /* CIL Label */ ;
#line 105
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 107
  tmp = allocate_marked_vector(10U, Registers[7], (_Bool)1);
#line 107
  result = tmp;
#line 109
  argument_scan = stack_pointer + 0;
#line 110
  argument_limit = stack_pointer + ((Registers[7] + 1UL) - 1UL);
#line 111
  result_scan = (SCHEME_OBJECT *)(result & 288230376151711743UL) + 1;
  }
  {
#line 112
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 112
    if (! ((unsigned long )argument_scan != (unsigned long )argument_limit)) {
#line 112
      goto while_break___0;
    }
#line 113
    tmp___0 = result_scan;
#line 113
    result_scan ++;
#line 113
    tmp___1 = argument_scan;
#line 113
    argument_scan ++;
#line 113
    *tmp___0 = *tmp___1;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 114
  return (result);
}
}
#line 118 "/home/khheo/project/mit-scheme-9.2/src/microcode/vector.c"
SCHEME_OBJECT Prim_record(void) 
{ 
  unsigned long nargs ;
  SCHEME_OBJECT result ;
  SCHEME_OBJECT tmp ;
  SCHEME_OBJECT *argument_scan ;
  SCHEME_OBJECT *argument_limit ;
  SCHEME_OBJECT *result_scan ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;

  {
  {
#line 120
  while (1) {
    while_continue: /* CIL Label */ ;
#line 120
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 122
  nargs = Registers[7];
#line 123
  if (nargs < 1UL) {
    {
#line 124
    signal_error_from_primitive(12L);
    }
  }
  {
#line 126
  tmp = allocate_marked_vector(62U, nargs, (_Bool)1);
#line 126
  result = tmp;
#line 127
  argument_scan = stack_pointer + 0;
#line 128
  argument_limit = stack_pointer + ((nargs + 1UL) - 1UL);
#line 129
  result_scan = (SCHEME_OBJECT *)(result & 288230376151711743UL) + 1;
  }
  {
#line 130
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 130
    if (! ((unsigned long )argument_scan != (unsigned long )argument_limit)) {
#line 130
      goto while_break___0;
    }
#line 131
    tmp___0 = result_scan;
#line 131
    result_scan ++;
#line 131
    tmp___1 = argument_scan;
#line 131
    argument_scan ++;
#line 131
    *tmp___0 = *tmp___1;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 132
  return (result);
}
}
#line 137 "/home/khheo/project/mit-scheme-9.2/src/microcode/vector.c"
SCHEME_OBJECT Prim_vector_p(void) 
{ 
  SCHEME_OBJECT object ;
  unsigned long tmp ;

  {
  {
#line 140
  while (1) {
    while_continue: /* CIL Label */ ;
#line 140
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 141
  object = *(stack_pointer + 0);
#line 142
  if (object >> 58U == 10UL) {
#line 142
    tmp = 8UL << 58U;
  } else {
#line 142
    tmp = 0UL;
  }
#line 142
  return (tmp);
}
}
#line 145 "/home/khheo/project/mit-scheme-9.2/src/microcode/vector.c"
SCHEME_OBJECT Prim_record_p(void) 
{ 
  SCHEME_OBJECT object ;
  unsigned long tmp ;

  {
  {
#line 148
  while (1) {
    while_continue: /* CIL Label */ ;
#line 148
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 149
  object = *(stack_pointer + 0);
#line 150
  if (object >> 58U == 62UL) {
#line 150
    tmp = 8UL << 58U;
  } else {
#line 150
    tmp = 0UL;
  }
#line 150
  return (tmp);
}
}
#line 153 "/home/khheo/project/mit-scheme-9.2/src/microcode/vector.c"
SCHEME_OBJECT Prim_sys_vector(void) 
{ 
  SCHEME_OBJECT object ;
  unsigned long tmp___0 ;
  gc_type_t tmp___1 ;

  {
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
#line 156
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 157
  object = *(stack_pointer + 0);
#line 158
  tmp___1 = gc_type_code((unsigned int )(object >> 58U));
  }
#line 158
  if ((int )tmp___1 == -3) {
#line 158
    tmp___0 = 8UL << 58U;
  } else {
#line 158
    tmp___0 = 0UL;
  }
#line 158
  return (tmp___0);
}
}
#line 167 "/home/khheo/project/mit-scheme-9.2/src/microcode/vector.c"
SCHEME_OBJECT Prim_vector_length(void) 
{ 
  SCHEME_OBJECT tmp ;
  SCHEME_OBJECT tmp___0 ;

  {
  {
#line 168
  while (1) {
    while_continue: /* CIL Label */ ;
#line 168
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 168
  if (*(stack_pointer + 0) >> 58U == 10UL) {
#line 168
    tmp = *(stack_pointer + 0);
  } else {
    {
#line 168
    error_wrong_type_arg(1);
#line 168
    tmp = (SCHEME_OBJECT )0;
    }
  }
  {
#line 168
  tmp___0 = long_to_integer((long )(*((SCHEME_OBJECT *)(tmp & 288230376151711743UL) + 0) & 288230376151711743UL));
  }
#line 168
  return (tmp___0);
}
}
#line 170 "/home/khheo/project/mit-scheme-9.2/src/microcode/vector.c"
SCHEME_OBJECT Prim_record_length(void) 
{ 
  SCHEME_OBJECT tmp ;
  SCHEME_OBJECT tmp___0 ;

  {
  {
#line 171
  while (1) {
    while_continue: /* CIL Label */ ;
#line 171
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 171
  if (*(stack_pointer + 0) >> 58U == 62UL) {
#line 171
    tmp = *(stack_pointer + 0);
  } else {
    {
#line 171
    error_wrong_type_arg(1);
#line 171
    tmp = (SCHEME_OBJECT )0;
    }
  }
  {
#line 171
  tmp___0 = long_to_integer((long )(*((SCHEME_OBJECT *)(tmp & 288230376151711743UL) + 0) & 288230376151711743UL));
  }
#line 171
  return (tmp___0);
}
}
#line 173 "/home/khheo/project/mit-scheme-9.2/src/microcode/vector.c"
SCHEME_OBJECT Prim_sys_vec_size(void) 
{ 
  SCHEME_OBJECT tmp___0 ;
  gc_type_t tmp___1 ;
  SCHEME_OBJECT tmp___2 ;

  {
  {
#line 174
  while (1) {
    while_continue: /* CIL Label */ ;
#line 174
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 174
  tmp___1 = gc_type_code((unsigned int )(*(stack_pointer + 0) >> 58U));
  }
#line 174
  if ((int )tmp___1 == -3) {
#line 174
    tmp___0 = *(stack_pointer + 0);
  } else {
    {
#line 174
    error_wrong_type_arg(1);
#line 174
    tmp___0 = (SCHEME_OBJECT )0;
    }
  }
  {
#line 174
  tmp___2 = long_to_integer((long )(*((SCHEME_OBJECT *)(tmp___0 & 288230376151711743UL) + 0) & 288230376151711743UL));
  }
#line 174
  return (tmp___2);
}
}
#line 185 "/home/khheo/project/mit-scheme-9.2/src/microcode/vector.c"
SCHEME_OBJECT Prim_vector_ref(void) 
{ 
  SCHEME_OBJECT vector ;
  long tmp ;

  {
  {
#line 186
  while (1) {
    while_continue: /* CIL Label */ ;
#line 186
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 186
  if (*(stack_pointer + 0) >> 58U == 10UL) {
#line 186
    vector = *(stack_pointer + 0);
  } else {
    {
#line 186
    error_wrong_type_arg(1);
#line 186
    vector = (SCHEME_OBJECT )0;
    }
  }
  {
#line 186
  tmp = arg_index_integer(2, (long )(*((SCHEME_OBJECT *)(vector & 288230376151711743UL) + 0) & 288230376151711743UL));
  }
#line 186
  return (*((SCHEME_OBJECT *)(vector & 288230376151711743UL) + (tmp + 1L)));
}
}
#line 188 "/home/khheo/project/mit-scheme-9.2/src/microcode/vector.c"
SCHEME_OBJECT Prim_record_ref(void) 
{ 
  SCHEME_OBJECT vector ;
  long tmp ;

  {
  {
#line 189
  while (1) {
    while_continue: /* CIL Label */ ;
#line 189
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 189
  if (*(stack_pointer + 0) >> 58U == 62UL) {
#line 189
    vector = *(stack_pointer + 0);
  } else {
    {
#line 189
    error_wrong_type_arg(1);
#line 189
    vector = (SCHEME_OBJECT )0;
    }
  }
  {
#line 189
  tmp = arg_index_integer(2, (long )(*((SCHEME_OBJECT *)(vector & 288230376151711743UL) + 0) & 288230376151711743UL));
  }
#line 189
  return (*((SCHEME_OBJECT *)(vector & 288230376151711743UL) + (tmp + 1L)));
}
}
#line 191 "/home/khheo/project/mit-scheme-9.2/src/microcode/vector.c"
SCHEME_OBJECT Prim_sys_vector_ref(void) 
{ 
  SCHEME_OBJECT vector ;
  gc_type_t tmp___0 ;
  long tmp___1 ;

  {
  {
#line 192
  while (1) {
    while_continue: /* CIL Label */ ;
#line 192
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 192
  tmp___0 = gc_type_code((unsigned int )(*(stack_pointer + 0) >> 58U));
  }
#line 192
  if ((int )tmp___0 == -3) {
#line 192
    vector = *(stack_pointer + 0);
  } else {
    {
#line 192
    error_wrong_type_arg(1);
#line 192
    vector = (SCHEME_OBJECT )0;
    }
  }
  {
#line 192
  tmp___1 = arg_index_integer(2, (long )(*((SCHEME_OBJECT *)(vector & 288230376151711743UL) + 0) & 288230376151711743UL));
  }
#line 192
  return (*((SCHEME_OBJECT *)(vector & 288230376151711743UL) + (tmp___1 + 1L)));
}
}
#line 206 "/home/khheo/project/mit-scheme-9.2/src/microcode/vector.c"
SCHEME_OBJECT Prim_vector_set(void) 
{ 
  SCHEME_OBJECT vector ;
  SCHEME_OBJECT new_value ;
  long tmp ;

  {
  {
#line 207
  while (1) {
    while_continue: /* CIL Label */ ;
#line 207
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 207
  if (*(stack_pointer + 0) >> 58U == 10UL) {
#line 207
    vector = *(stack_pointer + 0);
  } else {
    {
#line 207
    error_wrong_type_arg(1);
#line 207
    vector = (SCHEME_OBJECT )0;
    }
  }
  {
#line 207
  new_value = *(stack_pointer + 2);
#line 207
  tmp = arg_index_integer(2, (long )(*((SCHEME_OBJECT *)(vector & 288230376151711743UL) + 0) & 288230376151711743UL));
#line 207
  *((SCHEME_OBJECT *)(vector & 288230376151711743UL) + (tmp + 1L)) = new_value;
  }
#line 207
  return ((8UL << 58U) | 1UL);
}
}
#line 209 "/home/khheo/project/mit-scheme-9.2/src/microcode/vector.c"
SCHEME_OBJECT Prim_record_set(void) 
{ 
  SCHEME_OBJECT vector ;
  SCHEME_OBJECT new_value ;
  long tmp ;

  {
  {
#line 210
  while (1) {
    while_continue: /* CIL Label */ ;
#line 210
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 210
  if (*(stack_pointer + 0) >> 58U == 62UL) {
#line 210
    vector = *(stack_pointer + 0);
  } else {
    {
#line 210
    error_wrong_type_arg(1);
#line 210
    vector = (SCHEME_OBJECT )0;
    }
  }
  {
#line 210
  new_value = *(stack_pointer + 2);
#line 210
  tmp = arg_index_integer(2, (long )(*((SCHEME_OBJECT *)(vector & 288230376151711743UL) + 0) & 288230376151711743UL));
#line 210
  *((SCHEME_OBJECT *)(vector & 288230376151711743UL) + (tmp + 1L)) = new_value;
  }
#line 210
  return ((8UL << 58U) | 1UL);
}
}
#line 212 "/home/khheo/project/mit-scheme-9.2/src/microcode/vector.c"
SCHEME_OBJECT Prim_sys_vec_set(void) 
{ 
  SCHEME_OBJECT vector ;
  gc_type_t tmp___0 ;
  SCHEME_OBJECT new_value ;
  long tmp___1 ;

  {
  {
#line 213
  while (1) {
    while_continue: /* CIL Label */ ;
#line 213
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 213
  tmp___0 = gc_type_code((unsigned int )(*(stack_pointer + 0) >> 58U));
  }
#line 213
  if ((int )tmp___0 == -3) {
#line 213
    vector = *(stack_pointer + 0);
  } else {
    {
#line 213
    error_wrong_type_arg(1);
#line 213
    vector = (SCHEME_OBJECT )0;
    }
  }
  {
#line 213
  new_value = *(stack_pointer + 2);
#line 213
  tmp___1 = arg_index_integer(2, (long )(*((SCHEME_OBJECT *)(vector & 288230376151711743UL) + 0) & 288230376151711743UL));
#line 213
  *((SCHEME_OBJECT *)(vector & 288230376151711743UL) + (tmp___1 + 1L)) = new_value;
  }
#line 213
  return ((8UL << 58U) | 1UL);
}
}
#line 231 "/home/khheo/project/mit-scheme-9.2/src/microcode/vector.c"
static SCHEME_OBJECT subvector_to_list(SCHEME_OBJECT vector , long start , long end ) 
{ 
  SCHEME_OBJECT result ;
  SCHEME_OBJECT *scan ;
  SCHEME_OBJECT *end_scan ;
  SCHEME_OBJECT *pair_scan ;
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;
  SCHEME_OBJECT *tmp___2 ;
  SCHEME_OBJECT *tmp___3 ;
  SCHEME_OBJECT *tmp___4 ;
  SCHEME_OBJECT *tmp___5 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 238
  if (start == end) {
#line 239
    return ((8UL << 58U) | 9UL);
  }
  {
#line 240
  while (1) {
    while_continue: /* CIL Label */ ;
#line 240
    if ((unsigned long )Free >= (unsigned long )heap_start) {
#line 240
      if ((unsigned long )Free < (unsigned long )heap_alloc_limit) {
#line 240
        if (! ((unsigned long )(Free + 2L * (end - start)) <= (unsigned long )heap_alloc_limit)) {
#line 240
          goto _L___0;
        }
      } else {
#line 240
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 240
    if ((Registers[1] & 4UL) != 0UL) {
      {
#line 240
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 240
        if ((unsigned long )Free_primitive < (unsigned long )heap_start) {
          {
#line 240
          outf_fatal("\nMicrocode requested primitive GC outside primitive!\n");
#line 240
          Microcode_Termination(12);
          }
        }
#line 240
        if ((unsigned long )Free < (unsigned long )Free_primitive) {
          {
#line 240
          outf_fatal("\nFree has gone backwards!\n");
#line 240
          Microcode_Termination(12);
          }
        }
        {
#line 240
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 240
          while (1) {
            while_continue___2: /* CIL Label */ ;
            {
#line 240
            set_ulong_register(12U, Registers[12] | 4UL);
            }
            {
#line 240
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 240
              if ((Registers[1] & Registers[12]) != 0UL) {
#line 240
                tmp___0 = memory_block_start;
              } else {
#line 240
                if ((Registers[1] & 4UL) != 0UL) {
#line 240
                  tmp = heap_alloc_limit;
                } else {
#line 240
                  tmp = heap_end;
                }
#line 240
                tmp___0 = tmp;
              }
              {
#line 240
              set_ptr_register(0U, tmp___0);
              }
#line 240
              if ((Registers[1] & 1UL) != 0UL) {
#line 240
                tmp___1 = stack_guard;
              } else {
#line 240
                tmp___1 = stack_start;
              }
              {
#line 240
              set_ptr_register(11U, tmp___1);
              }
#line 240
              goto while_break___3;
            }
            while_break___3: /* CIL Label */ ;
            }
#line 240
            goto while_break___2;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 240
          gc_space_needed = (unsigned long )(2L * (end - start) + (Free - Free_primitive));
#line 240
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 240
        signal_interrupt_from_primitive();
        }
#line 240
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 240
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 241
  result = (1UL << 58U) | (SCHEME_OBJECT )Free;
#line 242
  scan = (SCHEME_OBJECT *)(vector & 288230376151711743UL) + (start + 1L);
#line 243
  end_scan = (SCHEME_OBJECT *)(vector & 288230376151711743UL) + ((end - 1L) + 1L);
#line 244
  pair_scan = Free;
  {
#line 245
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 245
    if (! ((unsigned long )scan < (unsigned long )end_scan)) {
#line 245
      goto while_break___4;
    }
#line 247
    Free += 2;
#line 248
    tmp___2 = pair_scan;
#line 248
    pair_scan ++;
#line 248
    tmp___3 = scan;
#line 248
    scan ++;
#line 248
    *tmp___2 = *tmp___3;
#line 249
    tmp___4 = pair_scan;
#line 249
    pair_scan ++;
#line 249
    *tmp___4 = (1UL << 58U) | (SCHEME_OBJECT )Free;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 251
  Free += 2;
#line 252
  tmp___5 = pair_scan;
#line 252
  pair_scan ++;
#line 252
  *tmp___5 = *scan;
#line 253
  *pair_scan = (8UL << 58U) | 9UL;
#line 254
  return (result);
}
}
#line 257 "/home/khheo/project/mit-scheme-9.2/src/microcode/vector.c"
SCHEME_OBJECT Prim_subvector_to_list(void) 
{ 
  SCHEME_OBJECT vector ;
  long start ;
  long end ;
  SCHEME_OBJECT tmp ;

  {
  {
#line 258
  while (1) {
    while_continue: /* CIL Label */ ;
#line 258
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 258
  if (*(stack_pointer + 0) >> 58U == 10UL) {
#line 258
    vector = *(stack_pointer + 0);
  } else {
    {
#line 258
    error_wrong_type_arg(1);
#line 258
    vector = (SCHEME_OBJECT )0;
    }
  }
  {
#line 258
  start = arg_nonnegative_integer(2);
#line 258
  end = arg_nonnegative_integer(3);
  }
#line 258
  if (end > (long )(*((SCHEME_OBJECT *)(vector & 288230376151711743UL) + 0) & 288230376151711743UL)) {
    {
#line 258
    error_bad_range_arg(3);
    }
  }
#line 258
  if (start > end) {
    {
#line 258
    error_bad_range_arg(2);
    }
  }
  {
#line 258
  tmp = subvector_to_list(vector, start, end);
  }
#line 258
  return (tmp);
}
}
#line 260 "/home/khheo/project/mit-scheme-9.2/src/microcode/vector.c"
SCHEME_OBJECT Prim_sys_subvector_to_list(void) 
{ 
  SCHEME_OBJECT vector ;
  long start ;
  long end ;
  gc_type_t tmp___0 ;
  SCHEME_OBJECT tmp___1 ;

  {
  {
#line 261
  while (1) {
    while_continue: /* CIL Label */ ;
#line 261
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 261
  tmp___0 = gc_type_code((unsigned int )(*(stack_pointer + 0) >> 58U));
  }
#line 261
  if ((int )tmp___0 == -3) {
#line 261
    vector = *(stack_pointer + 0);
  } else {
    {
#line 261
    error_wrong_type_arg(1);
#line 261
    vector = (SCHEME_OBJECT )0;
    }
  }
  {
#line 261
  start = arg_nonnegative_integer(2);
#line 261
  end = arg_nonnegative_integer(3);
  }
#line 261
  if (end > (long )(*((SCHEME_OBJECT *)(vector & 288230376151711743UL) + 0) & 288230376151711743UL)) {
    {
#line 261
    error_bad_range_arg(3);
    }
  }
#line 261
  if (start > end) {
    {
#line 261
    error_bad_range_arg(2);
    }
  }
  {
#line 261
  tmp___1 = subvector_to_list(vector, start, end);
  }
#line 261
  return (tmp___1);
}
}
#line 263 "/home/khheo/project/mit-scheme-9.2/src/microcode/vector.c"
static SCHEME_OBJECT list_to_vector(unsigned long result_type , long argument_number ) 
{ 
  SCHEME_OBJECT list ;
  unsigned long count ;
  SCHEME_OBJECT *result ;
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;
  SCHEME_OBJECT *tmp___2 ;
  SCHEME_OBJECT *tmp___3 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 270
  list = *(stack_pointer + (argument_number - 1L));
#line 271
  count = 0UL;
#line 272
  tmp = Free;
#line 272
  Free ++;
#line 272
  result = tmp;
  {
#line 273
  while (1) {
    while_continue: /* CIL Label */ ;
#line 273
    if (! (list >> 58U == 1UL)) {
#line 273
      goto while_break;
    }
    {
#line 275
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 275
      if ((unsigned long )Free >= (unsigned long )heap_start) {
#line 275
        if ((unsigned long )Free < (unsigned long )heap_alloc_limit) {
#line 275
          if (! ((unsigned long )(Free + 0) <= (unsigned long )heap_alloc_limit)) {
#line 275
            goto _L___0;
          }
        } else {
#line 275
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 275
      if ((Registers[1] & 4UL) != 0UL) {
        {
#line 275
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 275
          if ((unsigned long )Free_primitive < (unsigned long )heap_start) {
            {
#line 275
            outf_fatal("\nMicrocode requested primitive GC outside primitive!\n");
#line 275
            Microcode_Termination(12);
            }
          }
#line 275
          if ((unsigned long )Free < (unsigned long )Free_primitive) {
            {
#line 275
            outf_fatal("\nFree has gone backwards!\n");
#line 275
            Microcode_Termination(12);
            }
          }
          {
#line 275
          while (1) {
            while_continue___2: /* CIL Label */ ;
            {
#line 275
            while (1) {
              while_continue___3: /* CIL Label */ ;
              {
#line 275
              set_ulong_register(12U, Registers[12] | 4UL);
              }
              {
#line 275
              while (1) {
                while_continue___4: /* CIL Label */ ;
#line 275
                if ((Registers[1] & Registers[12]) != 0UL) {
#line 275
                  tmp___1 = memory_block_start;
                } else {
#line 275
                  if ((Registers[1] & 4UL) != 0UL) {
#line 275
                    tmp___0 = heap_alloc_limit;
                  } else {
#line 275
                    tmp___0 = heap_end;
                  }
#line 275
                  tmp___1 = tmp___0;
                }
                {
#line 275
                set_ptr_register(0U, tmp___1);
                }
#line 275
                if ((Registers[1] & 1UL) != 0UL) {
#line 275
                  tmp___2 = stack_guard;
                } else {
#line 275
                  tmp___2 = stack_start;
                }
                {
#line 275
                set_ptr_register(11U, tmp___2);
                }
#line 275
                goto while_break___4;
              }
              while_break___4: /* CIL Label */ ;
              }
#line 275
              goto while_break___3;
            }
            while_break___3: /* CIL Label */ ;
            }
#line 275
            gc_space_needed = (unsigned long )(Free - Free_primitive);
#line 275
            goto while_break___2;
          }
          while_break___2: /* CIL Label */ ;
          }
          {
#line 275
          signal_interrupt_from_primitive();
          }
#line 275
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 275
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 276
    count ++;
#line 277
    tmp___3 = Free;
#line 277
    Free ++;
#line 277
    *tmp___3 = *((SCHEME_OBJECT *)(list & 288230376151711743UL) + 0);
#line 278
    list = *((SCHEME_OBJECT *)(list & 288230376151711743UL) + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 280
  if (! (list == ((8UL << 58U) | 9UL))) {
    {
#line 281
    error_wrong_type_arg((int )argument_number);
    }
  }
#line 282
  *result = count;
#line 283
  return ((result_type << 58U) | (SCHEME_OBJECT )result);
}
}
#line 286 "/home/khheo/project/mit-scheme-9.2/src/microcode/vector.c"
SCHEME_OBJECT Prim_list_to_vector(void) 
{ 
  SCHEME_OBJECT tmp ;

  {
  {
#line 288
  while (1) {
    while_continue: /* CIL Label */ ;
#line 288
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 290
  tmp = list_to_vector(10UL, 1L);
  }
#line 290
  return (tmp);
}
}
#line 293 "/home/khheo/project/mit-scheme-9.2/src/microcode/vector.c"
SCHEME_OBJECT Prim_sys_list_to_vector(void) 
{ 
  unsigned long type_code ;
  gc_type_t tmp ;
  SCHEME_OBJECT tmp___0 ;

  {
  {
#line 296
  while (1) {
    while_continue: /* CIL Label */ ;
#line 296
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 298
  type_code = arg_ulong_index_integer(1, 64UL);
#line 299
  tmp = gc_type_code((unsigned int )type_code);
  }
#line 299
  if ((int )tmp != -3) {
    {
#line 300
    error_bad_range_arg(1);
    }
  }
  {
#line 301
  tmp___0 = list_to_vector(type_code, 2L);
  }
#line 301
  return (tmp___0);
}
}
#line 326 "/home/khheo/project/mit-scheme-9.2/src/microcode/vector.c"
SCHEME_OBJECT Prim_subvector_move_right(void) 
{ 
  SCHEME_OBJECT vector1 ;
  SCHEME_OBJECT vector2 ;
  long start1 ;
  long end1 ;
  long start2 ;
  long end2 ;
  long length ;
  SCHEME_OBJECT *scan1 ;
  SCHEME_OBJECT *scan2 ;
  long tmp ;

  {
  {
#line 328
  while (1) {
    while_continue: /* CIL Label */ ;
#line 328
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 328
  if (*(stack_pointer + 0) >> 58U == 10UL) {
#line 328
    vector1 = *(stack_pointer + 0);
  } else {
    {
#line 328
    error_wrong_type_arg(1);
#line 328
    vector1 = (SCHEME_OBJECT )0;
    }
  }
  {
#line 328
  start1 = arg_nonnegative_integer(2);
#line 328
  end1 = arg_nonnegative_integer(3);
  }
#line 328
  if (*(stack_pointer + 3) >> 58U == 10UL) {
#line 328
    vector2 = *(stack_pointer + 3);
  } else {
    {
#line 328
    error_wrong_type_arg(4);
#line 328
    vector2 = (SCHEME_OBJECT )0;
    }
  }
  {
#line 328
  start2 = arg_nonnegative_integer(5);
  }
#line 328
  if (end1 > (long )(*((SCHEME_OBJECT *)(vector1 & 288230376151711743UL) + 0) & 288230376151711743UL)) {
    {
#line 328
    error_bad_range_arg(3);
    }
  }
#line 328
  if (start1 > end1) {
    {
#line 328
    error_bad_range_arg(2);
    }
  }
#line 328
  length = end1 - start1;
#line 328
  end2 = start2 + length;
#line 328
  if (end2 > (long )(*((SCHEME_OBJECT *)(vector2 & 288230376151711743UL) + 0) & 288230376151711743UL)) {
    {
#line 328
    error_bad_range_arg(5);
    }
  }
#line 329
  scan1 = (SCHEME_OBJECT *)(vector1 & 288230376151711743UL) + (end1 + 1L);
#line 330
  scan2 = (SCHEME_OBJECT *)(vector2 & 288230376151711743UL) + (end2 + 1L);
  {
#line 331
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 331
    tmp = length;
#line 331
    length --;
#line 331
    if (! (tmp > 0L)) {
#line 331
      goto while_break___0;
    }
#line 332
    scan2 --;
#line 332
    scan1 --;
#line 332
    *scan2 = *scan1;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 333
  return ((8UL << 58U) | 1UL);
}
}
#line 336 "/home/khheo/project/mit-scheme-9.2/src/microcode/vector.c"
SCHEME_OBJECT Prim_subvector_move_left(void) 
{ 
  SCHEME_OBJECT vector1 ;
  SCHEME_OBJECT vector2 ;
  long start1 ;
  long end1 ;
  long start2 ;
  long end2 ;
  long length ;
  SCHEME_OBJECT *scan1 ;
  SCHEME_OBJECT *scan2 ;
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT *tmp___0 ;
  long tmp___1 ;

  {
  {
#line 338
  while (1) {
    while_continue: /* CIL Label */ ;
#line 338
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 338
  if (*(stack_pointer + 0) >> 58U == 10UL) {
#line 338
    vector1 = *(stack_pointer + 0);
  } else {
    {
#line 338
    error_wrong_type_arg(1);
#line 338
    vector1 = (SCHEME_OBJECT )0;
    }
  }
  {
#line 338
  start1 = arg_nonnegative_integer(2);
#line 338
  end1 = arg_nonnegative_integer(3);
  }
#line 338
  if (*(stack_pointer + 3) >> 58U == 10UL) {
#line 338
    vector2 = *(stack_pointer + 3);
  } else {
    {
#line 338
    error_wrong_type_arg(4);
#line 338
    vector2 = (SCHEME_OBJECT )0;
    }
  }
  {
#line 338
  start2 = arg_nonnegative_integer(5);
  }
#line 338
  if (end1 > (long )(*((SCHEME_OBJECT *)(vector1 & 288230376151711743UL) + 0) & 288230376151711743UL)) {
    {
#line 338
    error_bad_range_arg(3);
    }
  }
#line 338
  if (start1 > end1) {
    {
#line 338
    error_bad_range_arg(2);
    }
  }
#line 338
  length = end1 - start1;
#line 338
  end2 = start2 + length;
#line 338
  if (end2 > (long )(*((SCHEME_OBJECT *)(vector2 & 288230376151711743UL) + 0) & 288230376151711743UL)) {
    {
#line 338
    error_bad_range_arg(5);
    }
  }
#line 339
  scan1 = (SCHEME_OBJECT *)(vector1 & 288230376151711743UL) + (start1 + 1L);
#line 340
  scan2 = (SCHEME_OBJECT *)(vector2 & 288230376151711743UL) + (start2 + 1L);
  {
#line 341
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 341
    tmp___1 = length;
#line 341
    length --;
#line 341
    if (! (tmp___1 > 0L)) {
#line 341
      goto while_break___0;
    }
#line 342
    tmp = scan2;
#line 342
    scan2 ++;
#line 342
    tmp___0 = scan1;
#line 342
    scan1 ++;
#line 342
    *tmp = *tmp___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 343
  return ((8UL << 58U) | 1UL);
}
}
#line 346 "/home/khheo/project/mit-scheme-9.2/src/microcode/vector.c"
SCHEME_OBJECT Prim_vector_fill(void) 
{ 
  SCHEME_OBJECT vector ;
  long start ;
  long end ;
  SCHEME_OBJECT fill_value ;
  SCHEME_OBJECT *scan ;
  long length ;
  SCHEME_OBJECT *tmp ;
  long tmp___0 ;

  {
  {
#line 353
  while (1) {
    while_continue: /* CIL Label */ ;
#line 353
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 354
  if (*(stack_pointer + 0) >> 58U == 10UL) {
#line 354
    vector = *(stack_pointer + 0);
  } else {
    {
#line 354
    error_wrong_type_arg(1);
#line 354
    vector = (SCHEME_OBJECT )0;
    }
  }
  {
#line 355
  start = arg_nonnegative_integer(2);
#line 356
  end = arg_nonnegative_integer(3);
#line 357
  fill_value = *(stack_pointer + 3);
  }
#line 358
  if (end > (long )(*((SCHEME_OBJECT *)(vector & 288230376151711743UL) + 0) & 288230376151711743UL)) {
    {
#line 359
    error_bad_range_arg(3);
    }
  }
#line 360
  if (start > end) {
    {
#line 361
    error_bad_range_arg(2);
    }
  }
#line 362
  length = end - start;
#line 363
  scan = (SCHEME_OBJECT *)(vector & 288230376151711743UL) + (start + 1L);
  {
#line 364
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 364
    tmp___0 = length;
#line 364
    length --;
#line 364
    if (! (tmp___0 > 0L)) {
#line 364
      goto while_break___0;
    }
#line 365
    tmp = scan;
#line 365
    scan ++;
#line 365
    *tmp = fill_value;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 366
  return ((8UL << 58U) | 1UL);
}
}
#line 34 "/home/khheo/project/mit-scheme-9.2/src/microcode/outf.h"
void ( /* format attribute */  outf)(outf_channel chan , char const   *format  , ...) ;
#line 174 "/home/khheo/project/mit-scheme-9.2/src/microcode/extern.h"
char const   *Error_Names[64] ;
#line 209
_Bool integer_to_intmax_p(SCHEME_OBJECT n ) ;
#line 210
intmax_t integer_to_intmax(SCHEME_OBJECT n ) ;
#line 228
_Bool flonum_is_finite_p(SCHEME_OBJECT x ) ;
#line 357
 __attribute__((__noreturn__)) void termination_no_error_handler(void) ;
#line 362
void setup_interrupt(unsigned long masked_interrupts ) ;
#line 363
void preserve_interrupt_mask(void) ;
#line 369
 __attribute__((__noreturn__)) void Stack_Death(void) ;
#line 376
void Back_Trace(outf_channel stream ) ;
#line 76 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.h"
double bignum_to_double(bignum_type bignum ) ;
#line 77
int bignum_fits_in_word_p(bignum_type bignum , long word_length , int twos_complement_p ) ;
#line 97 "/home/khheo/project/mit-scheme-9.2/src/microcode/prims.h"
intmax_t arg_integer_to_intmax(int arg_number ) ;
#line 101
long arg_integer_in_range(int arg_number , long lower_limit , long upper_limit ) ;
#line 107
double arg_real_in_range(int arg_number , double lower_limit , double upper_limit ) ;
#line 78 "/home/khheo/project/mit-scheme-9.2/src/microcode/history.h"
SCHEME_OBJECT *history_register  ;
#line 79 "/home/khheo/project/mit-scheme-9.2/src/microcode/history.h"
unsigned long prev_restore_history_offset  ;
#line 81
void reset_history(void) ;
#line 83
void save_history(unsigned long rc ) ;
#line 84
_Bool restore_history(SCHEME_OBJECT hist_obj ) ;
#line 86
void new_subproblem(SCHEME_OBJECT expression , SCHEME_OBJECT environment ) ;
#line 87
void reuse_subproblem(SCHEME_OBJECT expression , SCHEME_OBJECT environment ) ;
#line 88
void new_reduction(SCHEME_OBJECT expression , SCHEME_OBJECT environment ) ;
#line 41 "/home/khheo/project/mit-scheme-9.2/src/microcode/utils.c"
static SCHEME_OBJECT copy_history(SCHEME_OBJECT hist_obj ) ;
#line 42
static  __attribute__((__noreturn__)) void error_death(long code , char const   *message ) ;
#line 46 "/home/khheo/project/mit-scheme-9.2/src/microcode/utils.c"
static unsigned long compute_interrupt_number(unsigned long masked_interrupts ) 
{ 
  unsigned long interrupt_number ;
  unsigned long bit_mask ;

  {
#line 49
  interrupt_number = 0UL;
#line 50
  bit_mask = 1UL;
  {
#line 51
  while (1) {
    while_continue: /* CIL Label */ ;
#line 51
    if (interrupt_number <= 15UL) {
#line 51
      if (! ((masked_interrupts & bit_mask) == 0UL)) {
#line 51
        goto while_break;
      }
    } else {
#line 51
      goto while_break;
    }
#line 54
    interrupt_number ++;
#line 55
    bit_mask <<= 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 57
  return (interrupt_number);
}
}
#line 60 "/home/khheo/project/mit-scheme-9.2/src/microcode/utils.c"
static unsigned long compute_interrupt_handler_mask(SCHEME_OBJECT interrupt_masks ,
                                                    unsigned long interrupt_number ) 
{ 
  SCHEME_OBJECT mask ;
  unsigned long tmp ;
  _Bool tmp___0 ;
  unsigned long tmp___1 ;

  {
#line 64
  if (interrupt_masks >> 58U == 10UL) {
#line 64
    if (interrupt_number <= (*((SCHEME_OBJECT *)(interrupt_masks & 288230376151711743UL) + 0) & 288230376151711743UL)) {
#line 67
      mask = *((SCHEME_OBJECT *)(interrupt_masks & 288230376151711743UL) + (interrupt_number + 1UL));
#line 69
      if (mask >> 58U == 26UL) {
#line 69
        goto _L;
      } else
#line 69
      if (mask >> 58U == 14UL) {
        _L: /* CIL Label */ 
        {
#line 69
        tmp___0 = integer_to_ulong_p(mask);
        }
#line 69
        if (tmp___0) {
          {
#line 71
          tmp = integer_to_ulong(mask);
          }
#line 71
          return (tmp & ~ (1UL << interrupt_number));
        }
      }
    }
  }
#line 73
  if (interrupt_number <= 15UL) {
#line 73
    tmp___1 = (1UL << interrupt_number) - 1UL;
  } else {
#line 73
    tmp___1 = Registers[1];
  }
#line 73
  return (tmp___1);
}
}
#line 79 "/home/khheo/project/mit-scheme-9.2/src/microcode/utils.c"
static void terminate_no_interrupt_handler(unsigned long masked_interrupts ) 
{ 
  char *__cil_tmp2 ;

  {
  {
#line 82
  outf_fatal("\nInterrupts = %#08lx, Mask = %#08lx, Masked = %#08lx\n", Registers[12],
             Registers[1], masked_interrupts);
#line 86
  Microcode_Termination(10);
  }
}
}
#line 89 "/home/khheo/project/mit-scheme-9.2/src/microcode/utils.c"
SCHEME_OBJECT initialize_interrupt_handler_vector(void) 
{ 
  SCHEME_OBJECT tmp ;

  {
  {
#line 92
  tmp = make_vector(17UL, 0UL, (_Bool)0);
  }
#line 92
  return (tmp);
}
}
#line 95 "/home/khheo/project/mit-scheme-9.2/src/microcode/utils.c"
SCHEME_OBJECT initialize_interrupt_mask_vector(void) 
{ 
  SCHEME_OBJECT v ;
  SCHEME_OBJECT tmp ;
  unsigned long interrupt_number ;

  {
  {
#line 98
  tmp = make_vector(17UL, 0UL, (_Bool)0);
#line 98
  v = tmp;
#line 99
  interrupt_number = 0UL;
  }
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 100
    if (! (interrupt_number <= 15UL)) {
#line 100
      goto while_break;
    }
    {
#line 102
    *((SCHEME_OBJECT *)(v & 288230376151711743UL) + (interrupt_number + 1UL)) = ulong_to_integer((1UL << interrupt_number) - 1UL);
#line 105
    interrupt_number ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 107
  return (v);
}
}
#line 113 "/home/khheo/project/mit-scheme-9.2/src/microcode/utils.c"
void setup_interrupt(unsigned long masked_interrupts ) 
{ 
  SCHEME_OBJECT interrupt_handlers ;
  SCHEME_OBJECT interrupt_masks ;
  unsigned long interrupt_number ;
  unsigned long tmp ;
  unsigned long interrupt_mask ;
  SCHEME_OBJECT interrupt_handler ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;
  SCHEME_OBJECT *tmp___2 ;
  SCHEME_OBJECT *tmp___3 ;
  SCHEME_OBJECT *tmp___4 ;
  SCHEME_OBJECT *tmp___5 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
#line 116
  interrupt_handlers = 0UL;
#line 117
  interrupt_masks = 0UL;
#line 118
  tmp = compute_interrupt_number(masked_interrupts);
#line 118
  interrupt_number = tmp;
  }
#line 130
  if (! (fixed_objects >> 58U == 10UL)) {
    {
#line 132
    outf_fatal("\nInvalid fixed-objects vector");
#line 133
    terminate_no_interrupt_handler(masked_interrupts);
    }
  }
#line 135
  interrupt_handlers = *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 2);
#line 136
  interrupt_masks = *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 7);
#line 137
  if (interrupt_handlers >> 58U == 10UL) {
#line 137
    if (! (interrupt_number < (*((SCHEME_OBJECT *)(interrupt_handlers & 288230376151711743UL) + 0) & 288230376151711743UL))) {
      {
#line 140
      outf_fatal("\nUnable to get interrupt handler.");
#line 141
      terminate_no_interrupt_handler(masked_interrupts);
      }
    }
  } else {
    {
#line 140
    outf_fatal("\nUnable to get interrupt handler.");
#line 141
    terminate_no_interrupt_handler(masked_interrupts);
    }
  }
  {
#line 143
  interrupt_mask = compute_interrupt_handler_mask(interrupt_masks, interrupt_number);
#line 145
  interrupt_handler = *((SCHEME_OBJECT *)(interrupt_handlers & 288230376151711743UL) + (interrupt_number + 1UL));
#line 147
  stop_history();
#line 148
  preserve_interrupt_mask();
  }
  {
#line 149
  while (1) {
    while_continue: /* CIL Label */ ;
#line 149
    if (! ((unsigned long )(stack_pointer + -4) >= (unsigned long )stack_guard)) {
      {
#line 149
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 149
        if (*stack_start != ((34UL << 58U) | (SCHEME_OBJECT )stack_start)) {
          {
#line 149
          stack_death("STACK_CHECK");
          }
        }
#line 149
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 149
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 149
        set_ulong_register(12U, Registers[12] | 1UL);
        }
        {
#line 149
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 149
          if ((Registers[1] & Registers[12]) != 0UL) {
#line 149
            tmp___1 = memory_block_start;
          } else {
#line 149
            if ((Registers[1] & 4UL) != 0UL) {
#line 149
              tmp___0 = heap_alloc_limit;
            } else {
#line 149
              tmp___0 = heap_end;
            }
#line 149
            tmp___1 = tmp___0;
          }
          {
#line 149
          set_ptr_register(0U, tmp___1);
          }
#line 149
          if ((Registers[1] & 1UL) != 0UL) {
#line 149
            tmp___2 = stack_guard;
          } else {
#line 149
            tmp___2 = stack_start;
          }
          {
#line 149
          set_ptr_register(11U, tmp___2);
          }
#line 149
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 149
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 149
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 158
  stack_pointer --;
#line 158
  *stack_pointer = (26UL << 58U) | Registers[1];
#line 159
  stack_pointer --;
#line 159
  *stack_pointer = (26UL << 58U) | Registers[12];
#line 160
  stack_pointer --;
#line 160
  *stack_pointer = interrupt_handler;
#line 161
  stack_pointer --;
#line 161
  *stack_pointer = 3UL;
  {
#line 164
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 164
    set_ulong_register(1U, interrupt_mask);
    }
    {
#line 164
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 164
      if ((Registers[1] & Registers[12]) != 0UL) {
#line 164
        tmp___4 = memory_block_start;
      } else {
#line 164
        if ((Registers[1] & 4UL) != 0UL) {
#line 164
          tmp___3 = heap_alloc_limit;
        } else {
#line 164
          tmp___3 = heap_end;
        }
#line 164
        tmp___4 = tmp___3;
      }
      {
#line 164
      set_ptr_register(0U, tmp___4);
      }
#line 164
      if ((Registers[1] & 1UL) != 0UL) {
#line 164
        tmp___5 = stack_guard;
      } else {
#line 164
        tmp___5 = stack_start;
      }
      {
#line 164
      set_ptr_register(11U, tmp___5);
      }
#line 164
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 164
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 165
  return;
}
}
#line 169 "/home/khheo/project/mit-scheme-9.2/src/microcode/utils.c"
void err_print(long error_code , outf_channel where ) 
{ 
  char const   *message ;
  char const   *tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 172
  if (error_code <= 63L) {
#line 172
    tmp = Error_Names[error_code];
  } else {
#line 172
    tmp = (char const   *)0;
  }
#line 172
  message = tmp;
#line 176
  if ((unsigned long )message == (unsigned long )((char const   *)0)) {
    {
#line 177
    outf(where, "Unknown error code %#lx.\n", error_code);
    }
  } else {
    {
#line 179
    outf(where, "Error code %#lx (%s).\n", error_code, message);
    }
  }
#line 180
  return;
}
}
#line 182 "/home/khheo/project/mit-scheme-9.2/src/microcode/utils.c"
long death_blow  ;
#line 184
static  __attribute__((__noreturn__)) void error_death(long code , char const   *message ) ;
#line 184 "/home/khheo/project/mit-scheme-9.2/src/microcode/utils.c"
static void error_death(long code , char const   *message ) 
{ 
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 187
  death_blow = code;
#line 188
  outf_fatal("\nMicrocode Error: %s.\n", message);
#line 189
  err_print(code, (outf_channel )2);
#line 190
  outf_error("\n**** Stack Trace ****\n\n");
#line 191
  Back_Trace((outf_channel )1);
#line 192
  termination_no_error_handler();
  }
}
}
#line 196
 __attribute__((__noreturn__)) void Stack_Death(void) ;
#line 196 "/home/khheo/project/mit-scheme-9.2/src/microcode/utils.c"
void Stack_Death(void) 
{ 
  char *__cil_tmp1 ;

  {
  {
#line 199
  outf_fatal("\nWill_Push vs. Pushed inconsistency.\n");
#line 200
  Microcode_Termination(6);
  }
}
}
#line 204 "/home/khheo/project/mit-scheme-9.2/src/microcode/utils.c"
void preserve_interrupt_mask(void) 
{ 
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;
  char *__cil_tmp4 ;

  {
  {
#line 207
  while (1) {
    while_continue: /* CIL Label */ ;
#line 207
    if (! ((unsigned long )(stack_pointer + -2) >= (unsigned long )stack_guard)) {
      {
#line 207
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 207
        if (*stack_start != ((34UL << 58U) | (SCHEME_OBJECT )stack_start)) {
          {
#line 207
          stack_death("STACK_CHECK");
          }
        }
#line 207
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 207
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 207
        set_ulong_register(12U, Registers[12] | 1UL);
        }
        {
#line 207
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 207
          if ((Registers[1] & Registers[12]) != 0UL) {
#line 207
            tmp___0 = memory_block_start;
          } else {
#line 207
            if ((Registers[1] & 4UL) != 0UL) {
#line 207
              tmp = heap_alloc_limit;
            } else {
#line 207
              tmp = heap_end;
            }
#line 207
            tmp___0 = tmp;
          }
          {
#line 207
          set_ptr_register(0U, tmp___0);
          }
#line 207
          if ((Registers[1] & 1UL) != 0UL) {
#line 207
            tmp___1 = stack_guard;
          } else {
#line 207
            tmp___1 = stack_start;
          }
          {
#line 207
          set_ptr_register(11U, tmp___1);
          }
#line 207
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 207
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 207
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 208
  Registers[6] = (11UL << 58U) | 69UL;
#line 209
  Registers[5] = (26UL << 58U) | Registers[1];
  {
#line 210
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 210
    stack_pointer --;
#line 210
    *stack_pointer = Registers[5];
#line 210
    stack_pointer --;
#line 210
    *stack_pointer = Registers[6];
#line 210
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 212
  return;
}
}
#line 220 "/home/khheo/project/mit-scheme-9.2/src/microcode/utils.c"
void canonicalize_primitive_context(void) 
{ 
  SCHEME_OBJECT primitive ;
  unsigned long n_args ;

  {
#line 223
  primitive = Registers[8];
#line 227
  if (*(Primitive_Arity_Table + (primitive & 288230376151711743UL)) == -1) {
#line 227
    n_args = Registers[7];
  } else {
#line 227
    n_args = (unsigned long )*(Primitive_Arity_Table + (primitive & 288230376151711743UL));
  }
#line 230
  if (*(stack_pointer + n_args) >> 58U == 40UL) {
    {
#line 233
    stack_pointer --;
#line 233
    *stack_pointer = primitive;
#line 234
    stack_pointer --;
#line 234
    *stack_pointer = n_args + 1UL;
#line 235
    guarantee_interp_return();
#line 236
    Registers[8] = 0UL;
#line 237
    abort_to_interpreter(-3);
    }
  }
#line 241
  return;
}
}
#line 247 "/home/khheo/project/mit-scheme-9.2/src/microcode/utils.c"
void back_out_of_primitive(void) 
{ 
  SCHEME_OBJECT primitive ;
  unsigned long tmp ;

  {
#line 250
  primitive = Registers[8];
#line 252
  stack_pointer --;
#line 252
  *stack_pointer = primitive;
#line 253
  stack_pointer --;
#line 253
  if (*(Primitive_Arity_Table + (primitive & 288230376151711743UL)) == -1) {
#line 253
    tmp = Registers[7];
  } else {
#line 253
    tmp = (unsigned long )*(Primitive_Arity_Table + (primitive & 288230376151711743UL));
  }
  {
#line 253
  *stack_pointer = tmp + 1UL;
#line 254
  guarantee_interp_return();
#line 255
  Registers[8] = 0UL;
#line 256
  Registers[5] = 0UL;
#line 257
  Registers[6] = (11UL << 58U) | 3UL;
  }
  {
#line 258
  while (1) {
    while_continue: /* CIL Label */ ;
#line 258
    stack_pointer --;
#line 258
    *stack_pointer = Registers[5];
#line 258
    stack_pointer --;
#line 258
    *stack_pointer = Registers[6];
#line 258
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 259
  Registers[3] = 1UL;
#line 260
  Registers[2] = 0UL;
#line 261
  return;
}
}
#line 271
 __attribute__((__noreturn__)) void signal_error_from_primitive(long error_code ) ;
#line 271 "/home/khheo/project/mit-scheme-9.2/src/microcode/utils.c"
void signal_error_from_primitive(long error_code ) 
{ 


  {
  {
#line 274
  abort_to_interpreter((int )error_code);
  }
}
}
#line 278
 __attribute__((__noreturn__)) void signal_interrupt_from_primitive(void) ;
#line 278 "/home/khheo/project/mit-scheme-9.2/src/microcode/utils.c"
void signal_interrupt_from_primitive(void) 
{ 


  {
  {
#line 281
  abort_to_interpreter(-4);
  }
}
}
#line 285
 __attribute__((__noreturn__)) void error_wrong_type_arg(int n ) ;
#line 285 "/home/khheo/project/mit-scheme-9.2/src/microcode/utils.c"
void error_wrong_type_arg(int n ) 
{ 
  long error_code ;

  {
  {
#line 292
  if (n == 1) {
#line 292
    goto case_1;
  }
#line 293
  if (n == 2) {
#line 293
    goto case_2;
  }
#line 294
  if (n == 3) {
#line 294
    goto case_3;
  }
#line 295
  if (n == 4) {
#line 295
    goto case_4;
  }
#line 296
  if (n == 5) {
#line 296
    goto case_5;
  }
#line 297
  if (n == 6) {
#line 297
    goto case_6;
  }
#line 298
  if (n == 7) {
#line 298
    goto case_7;
  }
#line 299
  if (n == 8) {
#line 299
    goto case_8;
  }
#line 300
  if (n == 9) {
#line 300
    goto case_9;
  }
#line 301
  if (n == 10) {
#line 301
    goto case_10;
  }
#line 302
  goto switch_default;
  case_1: /* CIL Label */ 
#line 292
  error_code = 13L;
#line 292
  goto switch_break;
  case_2: /* CIL Label */ 
#line 293
  error_code = 14L;
#line 293
  goto switch_break;
  case_3: /* CIL Label */ 
#line 294
  error_code = 15L;
#line 294
  goto switch_break;
  case_4: /* CIL Label */ 
#line 295
  error_code = 41L;
#line 295
  goto switch_break;
  case_5: /* CIL Label */ 
#line 296
  error_code = 42L;
#line 296
  goto switch_break;
  case_6: /* CIL Label */ 
#line 297
  error_code = 43L;
#line 297
  goto switch_break;
  case_7: /* CIL Label */ 
#line 298
  error_code = 44L;
#line 298
  goto switch_break;
  case_8: /* CIL Label */ 
#line 299
  error_code = 45L;
#line 299
  goto switch_break;
  case_9: /* CIL Label */ 
#line 300
  error_code = 46L;
#line 300
  goto switch_break;
  case_10: /* CIL Label */ 
#line 301
  error_code = 47L;
#line 301
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 302
  error_code = 10L;
#line 302
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 304
  signal_error_from_primitive(error_code);
  }
}
}
#line 307
 __attribute__((__noreturn__)) void error_bad_range_arg(int n ) ;
#line 307 "/home/khheo/project/mit-scheme-9.2/src/microcode/utils.c"
void error_bad_range_arg(int n ) 
{ 
  long error_code ;

  {
  {
#line 314
  if (n == 1) {
#line 314
    goto case_1;
  }
#line 315
  if (n == 2) {
#line 315
    goto case_2;
  }
#line 316
  if (n == 3) {
#line 316
    goto case_3;
  }
#line 317
  if (n == 4) {
#line 317
    goto case_4;
  }
#line 318
  if (n == 5) {
#line 318
    goto case_5;
  }
#line 319
  if (n == 6) {
#line 319
    goto case_6;
  }
#line 320
  if (n == 7) {
#line 320
    goto case_7;
  }
#line 321
  if (n == 8) {
#line 321
    goto case_8;
  }
#line 322
  if (n == 9) {
#line 322
    goto case_9;
  }
#line 323
  if (n == 10) {
#line 323
    goto case_10;
  }
#line 324
  goto switch_default;
  case_1: /* CIL Label */ 
#line 314
  error_code = 16L;
#line 314
  goto switch_break;
  case_2: /* CIL Label */ 
#line 315
  error_code = 17L;
#line 315
  goto switch_break;
  case_3: /* CIL Label */ 
#line 316
  error_code = 18L;
#line 316
  goto switch_break;
  case_4: /* CIL Label */ 
#line 317
  error_code = 34L;
#line 317
  goto switch_break;
  case_5: /* CIL Label */ 
#line 318
  error_code = 35L;
#line 318
  goto switch_break;
  case_6: /* CIL Label */ 
#line 319
  error_code = 36L;
#line 319
  goto switch_break;
  case_7: /* CIL Label */ 
#line 320
  error_code = 37L;
#line 320
  goto switch_break;
  case_8: /* CIL Label */ 
#line 321
  error_code = 38L;
#line 321
  goto switch_break;
  case_9: /* CIL Label */ 
#line 322
  error_code = 39L;
#line 322
  goto switch_break;
  case_10: /* CIL Label */ 
#line 323
  error_code = 40L;
#line 323
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 324
  error_code = 10L;
#line 324
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 326
  signal_error_from_primitive(error_code);
  }
}
}
#line 329
 __attribute__((__noreturn__)) void error_external_return(void) ;
#line 329 "/home/khheo/project/mit-scheme-9.2/src/microcode/utils.c"
void error_external_return(void) 
{ 


  {
  {
#line 332
  signal_error_from_primitive(10L);
  }
}
}
#line 335 "/home/khheo/project/mit-scheme-9.2/src/microcode/utils.c"
static SCHEME_OBJECT error_argument  ;
#line 337
 __attribute__((__noreturn__)) void error_with_argument(SCHEME_OBJECT argument ) ;
#line 337 "/home/khheo/project/mit-scheme-9.2/src/microcode/utils.c"
void error_with_argument(SCHEME_OBJECT argument ) 
{ 
  int tmp ;

  {
#line 340
  error_argument = argument;
#line 341
  if (argument >> 58U == 10UL) {
#line 341
    if ((*((SCHEME_OBJECT *)(argument & 288230376151711743UL) + 0) & 288230376151711743UL) > 0UL) {
#line 341
      if (*((SCHEME_OBJECT *)(argument & 288230376151711743UL) + 1) == ((26UL << 58U) | 4UL)) {
#line 341
        tmp = 4;
      } else {
#line 341
        tmp = 5;
      }
    } else {
#line 341
      tmp = 5;
    }
  } else {
#line 341
    tmp = 5;
  }
  {
#line 341
  signal_error_from_primitive((long )tmp);
  }
}
}
#line 351
 __attribute__((__noreturn__)) void error_in_system_call(enum syserr_names err , enum syscall_names name ) ;
#line 351 "/home/khheo/project/mit-scheme-9.2/src/microcode/utils.c"
void error_in_system_call(enum syserr_names err , enum syscall_names name ) 
{ 
  SCHEME_OBJECT v ;
  SCHEME_OBJECT tmp ;

  {
  {
#line 356
  tmp = allocate_marked_vector(10U, 3UL, (_Bool)0);
#line 356
  v = tmp;
#line 357
  *((SCHEME_OBJECT *)(v & 288230376151711743UL) + 1) = (26UL << 58U) | 4UL;
#line 358
  *((SCHEME_OBJECT *)(v & 288230376151711743UL) + 2) = (26UL << 58U) | (unsigned long )((unsigned int )err);
#line 359
  *((SCHEME_OBJECT *)(v & 288230376151711743UL) + 3) = (26UL << 58U) | (unsigned long )((unsigned int )name);
#line 360
  error_argument = v;
#line 361
  signal_error_from_primitive(4L);
  }
}
}
#line 365
 __attribute__((__noreturn__)) void error_system_call(int code , enum syscall_names name ) ;
#line 365 "/home/khheo/project/mit-scheme-9.2/src/microcode/utils.c"
void error_system_call(int code , enum syscall_names name ) 
{ 
  enum syserr_names tmp ;

  {
  {
#line 368
  tmp = OS_error_code_to_syserr(code);
#line 368
  error_in_system_call(tmp, name);
  }
}
}
#line 372 "/home/khheo/project/mit-scheme-9.2/src/microcode/utils.c"
long arg_integer(int arg_number ) 
{ 
  SCHEME_OBJECT object ;
  _Bool tmp ;
  long tmp___0 ;

  {
#line 375
  object = *(stack_pointer + (arg_number - 1));
#line 376
  if (! (object >> 58U == 26UL)) {
#line 376
    if (! (object >> 58U == 14UL)) {
      {
#line 377
      error_wrong_type_arg(arg_number);
      }
    }
  }
  {
#line 378
  tmp = integer_to_long_p(object);
  }
#line 378
  if (! tmp) {
    {
#line 379
    error_bad_range_arg(arg_number);
    }
  }
  {
#line 380
  tmp___0 = integer_to_long(object);
  }
#line 380
  return (tmp___0);
}
}
#line 383 "/home/khheo/project/mit-scheme-9.2/src/microcode/utils.c"
intmax_t arg_integer_to_intmax(int arg_number ) 
{ 
  SCHEME_OBJECT object ;
  _Bool tmp ;
  intmax_t tmp___0 ;

  {
#line 386
  object = *(stack_pointer + (arg_number - 1));
#line 387
  if (! (object >> 58U == 26UL)) {
#line 387
    if (! (object >> 58U == 14UL)) {
      {
#line 388
      error_wrong_type_arg(arg_number);
      }
    }
  }
  {
#line 389
  tmp = integer_to_intmax_p(object);
  }
#line 389
  if (! tmp) {
    {
#line 390
    error_bad_range_arg(arg_number);
    }
  }
  {
#line 391
  tmp___0 = integer_to_intmax(object);
  }
#line 391
  return (tmp___0);
}
}
#line 394 "/home/khheo/project/mit-scheme-9.2/src/microcode/utils.c"
long arg_nonnegative_integer(int arg_number ) 
{ 
  long result ;
  long tmp ;

  {
  {
#line 397
  tmp = arg_integer(arg_number);
#line 397
  result = tmp;
  }
#line 398
  if (result < 0L) {
    {
#line 399
    error_bad_range_arg(arg_number);
    }
  }
#line 400
  return (result);
}
}
#line 403 "/home/khheo/project/mit-scheme-9.2/src/microcode/utils.c"
long arg_index_integer(int arg_number , long upper_limit ) 
{ 
  long result ;
  long tmp ;

  {
  {
#line 406
  tmp = arg_integer(arg_number);
#line 406
  result = tmp;
  }
#line 407
  if (result < 0L) {
    {
#line 408
    error_bad_range_arg(arg_number);
    }
  } else
#line 407
  if (result >= upper_limit) {
    {
#line 408
    error_bad_range_arg(arg_number);
    }
  }
#line 409
  return (result);
}
}
#line 412 "/home/khheo/project/mit-scheme-9.2/src/microcode/utils.c"
intmax_t arg_index_integer_to_intmax(int arg_number , intmax_t upper_limit ) 
{ 
  intmax_t result ;
  intmax_t tmp ;

  {
  {
#line 415
  tmp = arg_integer_to_intmax(arg_number);
#line 415
  result = tmp;
  }
#line 416
  if (result < 0L) {
    {
#line 417
    error_bad_range_arg(arg_number);
    }
  } else
#line 416
  if (result >= upper_limit) {
    {
#line 417
    error_bad_range_arg(arg_number);
    }
  }
#line 418
  return (result);
}
}
#line 421 "/home/khheo/project/mit-scheme-9.2/src/microcode/utils.c"
long arg_integer_in_range(int arg_number , long lower_limit , long upper_limit ) 
{ 
  long result ;
  long tmp ;

  {
  {
#line 424
  tmp = arg_integer(arg_number);
#line 424
  result = tmp;
  }
#line 425
  if (result < lower_limit) {
    {
#line 426
    error_bad_range_arg(arg_number);
    }
  } else
#line 425
  if (result >= upper_limit) {
    {
#line 426
    error_bad_range_arg(arg_number);
    }
  }
#line 427
  return (result);
}
}
#line 430 "/home/khheo/project/mit-scheme-9.2/src/microcode/utils.c"
unsigned long arg_ulong_integer(int arg_number ) 
{ 
  SCHEME_OBJECT object ;
  _Bool tmp ;
  unsigned long tmp___0 ;

  {
#line 433
  object = *(stack_pointer + (arg_number - 1));
#line 434
  if (! (object >> 58U == 26UL)) {
#line 434
    if (! (object >> 58U == 14UL)) {
      {
#line 435
      error_wrong_type_arg(arg_number);
      }
    }
  }
  {
#line 436
  tmp = integer_to_ulong_p(object);
  }
#line 436
  if (! tmp) {
    {
#line 437
    error_bad_range_arg(arg_number);
    }
  }
  {
#line 438
  tmp___0 = integer_to_ulong(object);
  }
#line 438
  return (tmp___0);
}
}
#line 441 "/home/khheo/project/mit-scheme-9.2/src/microcode/utils.c"
unsigned long arg_ulong_index_integer(int arg_number , unsigned long upper_limit ) 
{ 
  unsigned long result ;
  unsigned long tmp ;

  {
  {
#line 444
  tmp = arg_ulong_integer(arg_number);
#line 444
  result = tmp;
  }
#line 445
  if (result >= upper_limit) {
    {
#line 446
    error_bad_range_arg(arg_number);
    }
  }
#line 447
  return (result);
}
}
#line 450 "/home/khheo/project/mit-scheme-9.2/src/microcode/utils.c"
unsigned long arg_ulong_integer_in_range(int arg_number , unsigned long lower_limit ,
                                         unsigned long upper_limit ) 
{ 
  unsigned long result ;
  unsigned long tmp ;

  {
  {
#line 455
  tmp = arg_ulong_integer(arg_number);
#line 455
  result = tmp;
  }
#line 456
  if (result >= lower_limit) {
#line 456
    if (! (result < upper_limit)) {
      {
#line 457
      error_bad_range_arg(arg_number);
      }
    }
  } else {
    {
#line 457
    error_bad_range_arg(arg_number);
    }
  }
#line 458
  return (result);
}
}
#line 461 "/home/khheo/project/mit-scheme-9.2/src/microcode/utils.c"
_Bool real_number_to_double_p(SCHEME_OBJECT x ) 
{ 
  int tmp ;
  _Bool tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 464
  if (x >> 58U == 14UL) {
    {
#line 464
    tmp = bignum_fits_in_word_p(x, 1025L, 1);
#line 464
    tmp___2 = tmp;
    }
  } else {
#line 464
    if (x >> 58U == 6UL) {
      {
#line 464
      tmp___0 = flonum_is_finite_p(x);
#line 464
      tmp___1 = (int )tmp___0;
      }
    } else {
#line 464
      tmp___1 = 1;
    }
#line 464
    tmp___2 = tmp___1;
  }
#line 464
  return ((_Bool )tmp___2);
}
}
#line 472 "/home/khheo/project/mit-scheme-9.2/src/microcode/utils.c"
double real_number_to_double(SCHEME_OBJECT x ) 
{ 
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;

  {
#line 475
  if (x >> 58U == 26UL) {
#line 475
    tmp___1 = (double )((long )((x ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL)));
  } else {
#line 475
    if (x >> 58U == 14UL) {
      {
#line 475
      tmp = bignum_to_double(x);
#line 475
      tmp___0 = tmp;
      }
    } else {
#line 475
      tmp___0 = *((double *)((SCHEME_OBJECT *)(x & 288230376151711743UL) + 1));
    }
#line 475
    tmp___1 = tmp___0;
  }
#line 475
  return (tmp___1);
}
}
#line 483 "/home/khheo/project/mit-scheme-9.2/src/microcode/utils.c"
double arg_real_number(int arg_number ) 
{ 
  SCHEME_OBJECT number ;
  _Bool tmp ;
  double tmp___0 ;

  {
#line 486
  number = *(stack_pointer + (arg_number - 1));
#line 487
  if (! (number >> 58U == 26UL)) {
#line 487
    if (! (number >> 58U == 14UL)) {
#line 487
      if (! (number >> 58U == 6UL)) {
        {
#line 488
        error_wrong_type_arg(arg_number);
        }
      }
    }
  }
  {
#line 489
  tmp = real_number_to_double_p(number);
  }
#line 489
  if (! tmp) {
    {
#line 490
    error_bad_range_arg(arg_number);
    }
  }
  {
#line 491
  tmp___0 = real_number_to_double(number);
  }
#line 491
  return (tmp___0);
}
}
#line 494 "/home/khheo/project/mit-scheme-9.2/src/microcode/utils.c"
double arg_real_in_range(int arg_number , double lower_limit , double upper_limit ) 
{ 
  double result ;
  double tmp ;

  {
  {
#line 497
  tmp = arg_real_number(arg_number);
#line 497
  result = tmp;
  }
#line 498
  if (result < lower_limit) {
    {
#line 499
    error_bad_range_arg(arg_number);
    }
  } else
#line 498
  if (result > upper_limit) {
    {
#line 499
    error_bad_range_arg(arg_number);
    }
  }
#line 500
  return (result);
}
}
#line 503 "/home/khheo/project/mit-scheme-9.2/src/microcode/utils.c"
_Bool interpreter_applicable_p(SCHEME_OBJECT object ) 
{ 
  cc_entry_type_t cet ;
  int tmp___0 ;
  _Bool tmp___1 ;

  {
  tail_recurse: 
  {
#line 512
  if (object >> 58U == 28UL) {
#line 512
    goto case_28;
  }
#line 512
  if (object >> 58U == 9UL) {
#line 512
    goto case_28;
  }
#line 512
  if (object >> 58U == 15UL) {
#line 512
    goto case_28;
  }
#line 512
  if (object >> 58U == 24UL) {
#line 512
    goto case_28;
  }
#line 515
  if (object >> 58U == 16UL) {
#line 515
    goto case_16;
  }
#line 521
  if (object >> 58U == 40UL) {
#line 521
    goto case_40;
  }
#line 530
  goto switch_default;
  case_28: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_15: /* CIL Label */ 
  case_24: /* CIL Label */ 
#line 513
  return ((_Bool)1);
  case_16: /* CIL Label */ 
#line 517
  object = *((SCHEME_OBJECT *)(object & 288230376151711743UL) + 0);
#line 518
  goto tail_recurse;
  case_40: /* CIL Label */ 
  {
#line 524
  tmp___1 = read_cc_entry_type(& cet, (insn_t *)((SCHEME_OBJECT *)(object & 288230376151711743UL)));
  }
#line 524
  if (tmp___1) {
#line 524
    tmp___0 = 0;
  } else {
#line 524
    tmp___0 = (unsigned int )cet.marker == 0U;
  }
#line 524
  return ((_Bool )tmp___0);
  switch_default: /* CIL Label */ 
#line 531
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 545 "/home/khheo/project/mit-scheme-9.2/src/microcode/utils.c"
void Do_Micro_Error(long error_code , _Bool from_pop_return_p ) 
{ 
  SCHEME_OBJECT handler ;
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  SCHEME_OBJECT error_vector ;
  SCHEME_OBJECT *tmp___4 ;
  SCHEME_OBJECT *tmp___5 ;
  SCHEME_OBJECT *tmp___6 ;
  SCHEME_OBJECT *tmp___7 ;
  SCHEME_OBJECT *tmp___8 ;
  SCHEME_OBJECT *tmp___9 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 548
  handler = 0UL;
  {
#line 590
  while (1) {
    while_continue: /* CIL Label */ ;
#line 590
    if (from_pop_return_p) {
#line 590
      tmp___2 = 0;
    } else {
#line 590
      tmp___2 = 1;
    }
#line 590
    if (! ((unsigned long )(stack_pointer + - (2 + tmp___2)) >= (unsigned long )stack_guard)) {
      {
#line 590
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 590
        if (*stack_start != ((34UL << 58U) | (SCHEME_OBJECT )stack_start)) {
          {
#line 590
          stack_death("STACK_CHECK");
          }
        }
#line 590
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 590
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 590
        set_ulong_register(12U, Registers[12] | 1UL);
        }
        {
#line 590
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 590
          if ((Registers[1] & Registers[12]) != 0UL) {
#line 590
            tmp___0 = memory_block_start;
          } else {
#line 590
            if ((Registers[1] & 4UL) != 0UL) {
#line 590
              tmp = heap_alloc_limit;
            } else {
#line 590
              tmp = heap_end;
            }
#line 590
            tmp___0 = tmp;
          }
          {
#line 590
          set_ptr_register(0U, tmp___0);
          }
#line 590
          if ((Registers[1] & 1UL) != 0UL) {
#line 590
            tmp___1 = stack_guard;
          } else {
#line 590
            tmp___1 = stack_start;
          }
          {
#line 590
          set_ptr_register(11U, tmp___1);
          }
#line 590
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 590
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 590
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 591
  if (from_pop_return_p) {
#line 592
    Registers[5] = Registers[2];
  } else {
#line 594
    stack_pointer --;
#line 594
    *stack_pointer = Registers[3];
  }
#line 595
  if (from_pop_return_p) {
#line 595
    tmp___3 = 64;
  } else {
#line 595
    tmp___3 = 65;
  }
#line 595
  Registers[6] = (11UL << 58U) | (unsigned long )tmp___3;
  {
#line 596
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 596
    stack_pointer --;
#line 596
    *stack_pointer = Registers[5];
#line 596
    stack_pointer --;
#line 596
    *stack_pointer = Registers[6];
#line 596
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 600
  error_vector = 0UL;
#line 601
  if (fixed_objects >> 58U == 10UL) {
#line 602
    error_vector = *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 3);
  }
#line 603
  if (! (error_vector >> 58U == 10UL)) {
    {
#line 604
    error_death(error_code, "No error handlers");
    }
  }
#line 605
  if (error_code >= 0L) {
#line 605
    if ((unsigned long )error_code < (*((SCHEME_OBJECT *)(error_vector & 288230376151711743UL) + 0) & 288230376151711743UL)) {
#line 606
      handler = *((SCHEME_OBJECT *)(error_vector & 288230376151711743UL) + (error_code + 1L));
    } else {
#line 605
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 607
  if (0UL < (*((SCHEME_OBJECT *)(error_vector & 288230376151711743UL) + 0) & 288230376151711743UL)) {
#line 608
    handler = *((SCHEME_OBJECT *)(error_vector & 288230376151711743UL) + 1);
  } else {
    {
#line 610
    error_death(error_code, "No error handlers");
    }
  }
  {
#line 614
  stop_history();
#line 615
  preserve_interrupt_mask();
  }
  {
#line 617
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 617
    if (! ((unsigned long )(stack_pointer + -4) >= (unsigned long )stack_guard)) {
      {
#line 617
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 617
        if (*stack_start != ((34UL << 58U) | (SCHEME_OBJECT )stack_start)) {
          {
#line 617
          stack_death("STACK_CHECK");
          }
        }
#line 617
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 617
      while (1) {
        while_continue___6: /* CIL Label */ ;
        {
#line 617
        set_ulong_register(12U, Registers[12] | 1UL);
        }
        {
#line 617
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 617
          if ((Registers[1] & Registers[12]) != 0UL) {
#line 617
            tmp___5 = memory_block_start;
          } else {
#line 617
            if ((Registers[1] & 4UL) != 0UL) {
#line 617
              tmp___4 = heap_alloc_limit;
            } else {
#line 617
              tmp___4 = heap_end;
            }
#line 617
            tmp___5 = tmp___4;
          }
          {
#line 617
          set_ptr_register(0U, tmp___5);
          }
#line 617
          if ((Registers[1] & 1UL) != 0UL) {
#line 617
            tmp___6 = stack_guard;
          } else {
#line 617
            tmp___6 = stack_start;
          }
          {
#line 617
          set_ptr_register(11U, tmp___6);
          }
#line 617
          goto while_break___7;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 617
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
#line 617
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 619
  stack_pointer --;
#line 619
  *stack_pointer = (26UL << 58U) | Registers[1];
#line 621
  if (error_code == 5L) {
#line 622
    stack_pointer --;
#line 622
    *stack_pointer = error_argument;
  } else
#line 621
  if (error_code == 4L) {
#line 622
    stack_pointer --;
#line 622
    *stack_pointer = error_argument;
  } else {
    {
#line 624
    stack_pointer --;
#line 624
    *stack_pointer = long_to_integer(error_code);
    }
  }
#line 625
  stack_pointer --;
#line 625
  *stack_pointer = handler;
#line 626
  stack_pointer --;
#line 626
  *stack_pointer = 3UL;
  {
#line 630
  while (1) {
    while_continue___8: /* CIL Label */ ;
    {
#line 630
    set_ulong_register(1U, 0UL);
    }
    {
#line 630
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 630
      if ((Registers[1] & Registers[12]) != 0UL) {
#line 630
        tmp___8 = memory_block_start;
      } else {
#line 630
        if ((Registers[1] & 4UL) != 0UL) {
#line 630
          tmp___7 = heap_alloc_limit;
        } else {
#line 630
          tmp___7 = heap_end;
        }
#line 630
        tmp___8 = tmp___7;
      }
      {
#line 630
      set_ptr_register(0U, tmp___8);
      }
#line 630
      if ((Registers[1] & 1UL) != 0UL) {
#line 630
        tmp___9 = stack_guard;
      } else {
#line 630
        tmp___9 = stack_start;
      }
      {
#line 630
      set_ptr_register(11U, tmp___9);
      }
#line 630
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 630
    goto while_break___8;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 631
  return;
}
}
#line 635 "/home/khheo/project/mit-scheme-9.2/src/microcode/utils.c"
void reset_history(void) 
{ 
  SCHEME_OBJECT *tmp ;

  {
#line 638
  prev_restore_history_offset = 0UL;
#line 639
  if (fixed_objects >> 58U == 10UL) {
#line 639
    if (*((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 20) != 0UL) {
#line 639
      history_register = (SCHEME_OBJECT *)(*((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 20) & 288230376151711743UL);
    } else {
      {
#line 639
      tmp = make_dummy_history();
#line 639
      history_register = tmp;
      }
    }
  } else {
    {
#line 639
    tmp = make_dummy_history();
#line 639
    history_register = tmp;
    }
  }
#line 644
  return;
}
}
#line 646 "/home/khheo/project/mit-scheme-9.2/src/microcode/utils.c"
SCHEME_OBJECT *make_dummy_history(void) 
{ 
  SCHEME_OBJECT *rib ;
  SCHEME_OBJECT *history ;

  {
#line 649
  rib = Free;
#line 650
  *(Free + 0) = 0UL;
#line 651
  *(Free + 1) = 0UL;
#line 652
  *(Free + 2) = (32UL << 58U) | (SCHEME_OBJECT )rib;
#line 654
  Free += 3;
#line 656
  history = Free;
#line 657
  *(Free + 0) = (32UL << 58U) | (SCHEME_OBJECT )rib;
#line 659
  *(Free + 1) = (32UL << 58U) | (SCHEME_OBJECT )history;
#line 661
  *(Free + 2) = (32UL << 58U) | (SCHEME_OBJECT )history;
#line 663
  Free += 3;
#line 664
  return (history);
}
}
#line 676 "/home/khheo/project/mit-scheme-9.2/src/microcode/utils.c"
void save_history(unsigned long rc ) 
{ 
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;
  char *__cil_tmp5 ;

  {
  {
#line 679
  while (1) {
    while_continue: /* CIL Label */ ;
#line 679
    if (! ((unsigned long )(stack_pointer + -4) >= (unsigned long )stack_guard)) {
      {
#line 679
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 679
        if (*stack_start != ((34UL << 58U) | (SCHEME_OBJECT )stack_start)) {
          {
#line 679
          stack_death("STACK_CHECK");
          }
        }
#line 679
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 679
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 679
        set_ulong_register(12U, Registers[12] | 1UL);
        }
        {
#line 679
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 679
          if ((Registers[1] & Registers[12]) != 0UL) {
#line 679
            tmp___0 = memory_block_start;
          } else {
#line 679
            if ((Registers[1] & 4UL) != 0UL) {
#line 679
              tmp = heap_alloc_limit;
            } else {
#line 679
              tmp = heap_end;
            }
#line 679
            tmp___0 = tmp;
          }
          {
#line 679
          set_ptr_register(0U, tmp___0);
          }
#line 679
          if ((Registers[1] & 1UL) != 0UL) {
#line 679
            tmp___1 = stack_guard;
          } else {
#line 679
            tmp___1 = stack_start;
          }
          {
#line 679
          set_ptr_register(11U, tmp___1);
          }
#line 679
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 679
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 679
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 680
  stack_pointer --;
#line 680
  *stack_pointer = 0UL;
#line 681
  stack_pointer --;
#line 681
  *stack_pointer = (26UL << 58U) | prev_restore_history_offset;
#line 682
  Registers[5] = (32UL << 58U) | (SCHEME_OBJECT )history_register;
#line 683
  Registers[6] = (11UL << 58U) | rc;
  {
#line 684
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 684
    stack_pointer --;
#line 684
    *stack_pointer = Registers[5];
#line 684
    stack_pointer --;
#line 684
    *stack_pointer = Registers[6];
#line 684
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 686
  history_register = (SCHEME_OBJECT *)(*((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 20) & 288230376151711743UL);
#line 687
  return;
}
}
#line 693 "/home/khheo/project/mit-scheme-9.2/src/microcode/utils.c"
_Bool restore_history(SCHEME_OBJECT hist_obj ) 
{ 
  SCHEME_OBJECT new_hist ;
  SCHEME_OBJECT tmp ;

  {
  {
#line 696
  tmp = copy_history(hist_obj);
#line 696
  new_hist = tmp;
  }
#line 697
  if (new_hist == 0UL) {
#line 698
    return ((_Bool)0);
  }
#line 699
  history_register = (SCHEME_OBJECT *)(new_hist & 288230376151711743UL);
#line 700
  return ((_Bool)1);
}
}
#line 710 "/home/khheo/project/mit-scheme-9.2/src/microcode/utils.c"
void stop_history(void) 
{ 
  SCHEME_OBJECT exp___0 ;
  SCHEME_OBJECT ret ;

  {
  {
#line 713
  exp___0 = Registers[5];
#line 714
  ret = Registers[6];
#line 715
  save_history(47UL);
#line 716
  prev_restore_history_offset = (unsigned long )(stack_end - stack_pointer);
#line 717
  Registers[6] = ret;
#line 718
  Registers[5] = exp___0;
  }
#line 719
  return;
}
}
#line 721 "/home/khheo/project/mit-scheme-9.2/src/microcode/utils.c"
void new_subproblem(SCHEME_OBJECT expression , SCHEME_OBJECT environment ) 
{ 
  SCHEME_OBJECT *rib ;

  {
#line 724
  history_register = (SCHEME_OBJECT *)(*(history_register + 1) & 288230376151711743UL);
#line 725
  *(history_register + 1) |= 4UL << 58U;
#line 727
  rib = (SCHEME_OBJECT *)(*(history_register + 0) & 288230376151711743UL);
#line 728
  *(rib + 2) |= 4UL << 58U;
#line 729
  *(rib + 1) = environment;
#line 730
  *(rib + 0) = expression;
#line 732
  return;
}
}
#line 734 "/home/khheo/project/mit-scheme-9.2/src/microcode/utils.c"
void reuse_subproblem(SCHEME_OBJECT expression , SCHEME_OBJECT environment ) 
{ 
  SCHEME_OBJECT *rib ;

  {
#line 737
  rib = (SCHEME_OBJECT *)(*(history_register + 0) & 288230376151711743UL);
#line 738
  *(rib + 2) |= 4UL << 58U;
#line 739
  *(rib + 1) = environment;
#line 740
  *(rib + 0) = expression;
#line 741
  return;
}
}
#line 743 "/home/khheo/project/mit-scheme-9.2/src/microcode/utils.c"
void new_reduction(SCHEME_OBJECT expression , SCHEME_OBJECT environment ) 
{ 
  SCHEME_OBJECT *rib ;

  {
#line 746
  rib = (SCHEME_OBJECT *)(*((SCHEME_OBJECT *)(*(history_register + 0) & 288230376151711743UL) + 2) & 288230376151711743UL);
#line 749
  *(history_register + 0) = (32UL << 58U) | (SCHEME_OBJECT )rib;
#line 751
  *(rib + 1) = environment;
#line 752
  *(rib + 0) = expression;
#line 753
  *(rib + 2) &= ~ (4UL << 58U);
#line 754
  return;
}
}
#line 756 "/home/khheo/project/mit-scheme-9.2/src/microcode/utils.c"
void end_subproblem(void) 
{ 


  {
#line 759
  *(history_register + 1) &= ~ (4UL << 58U);
#line 760
  history_register = (SCHEME_OBJECT *)(*(history_register + 2) & 288230376151711743UL);
#line 761
  return;
}
}
#line 763 "/home/khheo/project/mit-scheme-9.2/src/microcode/utils.c"
void compiler_new_subproblem(void) 
{ 


  {
  {
#line 766
  new_subproblem(0UL, (11UL << 58U) | 41UL);
  }
#line 767
  return;
}
}
#line 769 "/home/khheo/project/mit-scheme-9.2/src/microcode/utils.c"
void compiler_new_reduction(void) 
{ 


  {
  {
#line 772
  new_reduction(0UL, (11UL << 58U) | 41UL);
  }
#line 773
  return;
}
}
#line 777 "/home/khheo/project/mit-scheme-9.2/src/microcode/utils.c"
static SCHEME_OBJECT copy_history(SCHEME_OBJECT hist_obj ) 
{ 
  unsigned long space_left ;
  unsigned long vert_type ;
  unsigned long rib_type ;
  SCHEME_OBJECT new_hunk ;
  SCHEME_OBJECT *last_hunk ;
  SCHEME_OBJECT *hist_ptr ;
  SCHEME_OBJECT *orig_hist ;
  SCHEME_OBJECT temp ;
  SCHEME_OBJECT *orig_rib ;
  SCHEME_OBJECT *source_rib ;
  SCHEME_OBJECT *rib_slot ;
  long tmp ;
  unsigned long tmp___0 ;

  {
#line 786
  if ((Registers[1] & 4UL) != 0UL) {
#line 786
    if ((unsigned long )Free >= (unsigned long )heap_start) {
#line 786
      if ((unsigned long )Free < (unsigned long )heap_alloc_limit) {
#line 786
        tmp = heap_alloc_limit - Free;
      } else {
#line 786
        tmp = 0L;
      }
    } else {
#line 786
      tmp = 0L;
    }
#line 786
    space_left = (unsigned long )tmp;
  } else {
#line 786
    if ((unsigned long )Free >= (unsigned long )heap_start) {
#line 786
      if ((unsigned long )Free < (unsigned long )heap_end) {
#line 786
        tmp___0 = (unsigned long )(heap_end - Free);
      } else {
#line 786
        tmp___0 = 0UL;
      }
    } else {
#line 786
      tmp___0 = 0UL;
    }
#line 786
    space_left = tmp___0;
  }
#line 787
  if (space_left < 3UL) {
#line 788
    return (0UL);
  }
#line 789
  space_left -= 3UL;
#line 791
  vert_type = hist_obj >> 58U;
#line 792
  orig_hist = (SCHEME_OBJECT *)(hist_obj & 288230376151711743UL);
#line 793
  hist_ptr = orig_hist;
#line 794
  last_hunk = heap_end - 3;
  {
#line 796
  while (1) {
    while_continue: /* CIL Label */ ;
#line 799
    if (space_left < 3UL) {
#line 800
      return (0UL);
    }
#line 801
    space_left -= 3UL;
#line 803
    new_hunk = (vert_type << 58U) | (SCHEME_OBJECT )Free;
#line 804
    *(last_hunk + 1) = new_hunk;
#line 806
    *(Free + 2) = ((*(hist_ptr + 2) >> 58U) << 58U) | (SCHEME_OBJECT )last_hunk;
#line 809
    last_hunk = Free;
#line 810
    Free += 3;
#line 813
    temp = *(hist_ptr + 0);
#line 814
    rib_type = temp >> 58U;
#line 815
    orig_rib = (SCHEME_OBJECT *)(temp & 288230376151711743UL);
#line 816
    rib_slot = last_hunk + 0;
#line 818
    source_rib = orig_rib;
    {
#line 820
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 822
      if (space_left < 3UL) {
#line 823
        return (0UL);
      }
#line 824
      space_left -= 3UL;
#line 826
      *rib_slot = (rib_type << 58U) | (SCHEME_OBJECT )Free;
#line 827
      *(Free + 0) = *(source_rib + 0);
#line 828
      *(Free + 1) = *(source_rib + 1);
#line 829
      rib_slot = Free + 2;
#line 830
      Free += 3;
#line 831
      temp = *(source_rib + 2);
#line 832
      rib_type = temp >> 58U;
#line 833
      source_rib = (SCHEME_OBJECT *)(temp & 288230376151711743UL);
#line 820
      if (! ((unsigned long )source_rib != (unsigned long )orig_rib)) {
#line 820
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 837
    *rib_slot = (rib_type << 58U) | (*(last_hunk + 0) & 288230376151711743UL);
#line 839
    temp = *(hist_ptr + 1);
#line 840
    vert_type = temp >> 58U;
#line 841
    hist_ptr = (SCHEME_OBJECT *)(temp & 288230376151711743UL);
#line 796
    if (! ((unsigned long )hist_ptr != (unsigned long )orig_hist)) {
#line 796
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 845
  new_hunk = *(heap_end + -2);
#line 846
  *(last_hunk + 1) = (vert_type << 58U) | (new_hunk & 288230376151711743UL);
#line 847
  *((SCHEME_OBJECT *)(new_hunk & 288230376151711743UL) + 2) = ((*(hist_ptr + 2) >> 58U) << 58U) | (SCHEME_OBJECT )last_hunk;
#line 851
  return (new_hunk);
}
}
#line 1008 "/home/khheo/project/mit-scheme-9.2/src/microcode/utils.c"
void set_ptr_register(unsigned int index___0 , SCHEME_OBJECT *p ) 
{ 


  {
#line 1011
  Registers[index___0] = (SCHEME_OBJECT )p;
#line 1012
  return;
}
}
#line 1014 "/home/khheo/project/mit-scheme-9.2/src/microcode/utils.c"
void set_ulong_register(unsigned int index___0 , unsigned long value ) 
{ 


  {
#line 1017
  Registers[index___0] = value;
#line 1018
  return;
}
}
#line 171 "/home/khheo/project/mit-scheme-9.2/src/microcode/extern.h"
char const   *Return_Names[95] ;
#line 172
char const   *type_names[64] ;
#line 175
char const   *Term_Names[27] ;
#line 177
char const   *fixed_objects_names[70] ;
#line 302
SCHEME_OBJECT char_pointer_to_symbol(char const   *string ) ;
#line 346
SCHEME_OBJECT make_primitive(char const   *name , int arity ) ;
#line 67 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.h"
bignum_type long_to_bignum(long n ) ;
#line 40 "/home/khheo/project/mit-scheme-9.2/src/microcode/utabmd.c"
SCHEME_OBJECT initialize_history(void) ;
#line 44
static char const   *cc_arch_name(void) ;
#line 45
static SCHEME_OBJECT fixed_objects_syscall_names(void) ;
#line 46
static SCHEME_OBJECT fixed_objects_syserr_names(void) ;
#line 47
static SCHEME_OBJECT names_to_vector(unsigned long length , char const   **names ) ;
#line 65 "/home/khheo/project/mit-scheme-9.2/src/microcode/utabmd.c"
static char const   *identity_names[13]  = 
#line 65
  {      "system-release-string",      "microcode-version",      (char const   *)0,      "console-width", 
        "console-height",      "newline-char",      "flonum-mantissa-length",      "flonum-epsilon", 
        "os-name-string",      "os-variant-string",      "stack-type-string",      "machine-type-string", 
        "cc-arch-string"};
#line 82 "/home/khheo/project/mit-scheme-9.2/src/microcode/utabmd.c"
SCHEME_OBJECT make_microcode_identification_vector(void) 
{ 
  SCHEME_OBJECT v ;
  SCHEME_OBJECT tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  char const   *name ;
  char const   *tmp___2 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 85
  tmp = make_vector(20UL, 0UL, (_Bool)1);
#line 85
  v = tmp;
#line 86
  *((SCHEME_OBJECT *)(v & 288230376151711743UL) + 1) = 0UL;
#line 87
  *((SCHEME_OBJECT *)(v & 288230376151711743UL) + 2) = char_pointer_to_string("15.3");
#line 88
  tmp___0 = OS_tty_x_size();
#line 88
  *((SCHEME_OBJECT *)(v & 288230376151711743UL) + 4) = (26UL << 58U) | (unsigned long )tmp___0;
#line 89
  tmp___1 = OS_tty_y_size();
#line 89
  *((SCHEME_OBJECT *)(v & 288230376151711743UL) + 5) = (26UL << 58U) | (unsigned long )tmp___1;
#line 90
  *((SCHEME_OBJECT *)(v & 288230376151711743UL) + 6) = (2UL << 58U) | 10UL;
#line 91
  *((SCHEME_OBJECT *)(v & 288230376151711743UL) + 7) = (26UL << 58U) | 53UL;
#line 92
  *((SCHEME_OBJECT *)(v & 288230376151711743UL) + 8) = double_to_flonum((double )2.22044604925031308085e-16L);
#line 93
  *((SCHEME_OBJECT *)(v & 288230376151711743UL) + 9) = char_pointer_to_string(OS_Name);
#line 94
  *((SCHEME_OBJECT *)(v & 288230376151711743UL) + 10) = char_pointer_to_string(OS_Variant);
#line 95
  *((SCHEME_OBJECT *)(v & 288230376151711743UL) + 11) = char_pointer_to_string("standard");
#line 96
  *((SCHEME_OBJECT *)(v & 288230376151711743UL) + 12) = char_pointer_to_string("x86-64");
#line 98
  tmp___2 = cc_arch_name();
#line 98
  name = tmp___2;
  }
#line 99
  if ((unsigned long )name != (unsigned long )((char const   *)0)) {
    {
#line 100
    *((SCHEME_OBJECT *)(v & 288230376151711743UL) + 13) = char_pointer_to_string(name);
    }
  }
#line 102
  return (v);
}
}
#line 105 "/home/khheo/project/mit-scheme-9.2/src/microcode/utabmd.c"
static char const   *cc_arch_name(void) 
{ 
  char *__cil_tmp1 ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 110
  if ((unsigned int )compiler_processor_type == 0U) {
#line 110
    goto case_0;
  }
#line 111
  if ((unsigned int )compiler_processor_type == 1U) {
#line 111
    goto case_1;
  }
#line 112
  if ((unsigned int )compiler_processor_type == 2U) {
#line 112
    goto case_2;
  }
#line 113
  if ((unsigned int )compiler_processor_type == 3U) {
#line 113
    goto case_3;
  }
#line 114
  if ((unsigned int )compiler_processor_type == 5U) {
#line 114
    goto case_5;
  }
#line 115
  if ((unsigned int )compiler_processor_type == 6U) {
#line 115
    goto case_6;
  }
#line 116
  if ((unsigned int )compiler_processor_type == 9U) {
#line 116
    goto case_9;
  }
#line 117
  if ((unsigned int )compiler_processor_type == 10U) {
#line 117
    goto case_10;
  }
#line 118
  if ((unsigned int )compiler_processor_type == 11U) {
#line 118
    goto case_11;
  }
#line 119
  if ((unsigned int )compiler_processor_type == 12U) {
#line 119
    goto case_12;
  }
#line 120
  if ((unsigned int )compiler_processor_type == 13U) {
#line 120
    goto case_13;
  }
#line 121
  if ((unsigned int )compiler_processor_type == 14U) {
#line 121
    goto case_14;
  }
#line 122
  goto switch_default;
  case_0: /* CIL Label */ 
#line 110
  return ("none");
  case_1: /* CIL Label */ 
#line 111
  return ("mc68k");
  case_2: /* CIL Label */ 
#line 112
  return ("vax");
  case_3: /* CIL Label */ 
#line 113
  return ("hppa");
  case_5: /* CIL Label */ 
#line 114
  return ("mc68k");
  case_6: /* CIL Label */ 
#line 115
  return ("sparc");
  case_9: /* CIL Label */ 
#line 116
  return ("i386");
  case_10: /* CIL Label */ 
#line 117
  return ("alpha");
  case_11: /* CIL Label */ 
#line 118
  return ("mips");
  case_12: /* CIL Label */ 
#line 119
  return ("c");
  case_13: /* CIL Label */ 
#line 120
  return ("svm1");
  case_14: /* CIL Label */ 
#line 121
  return ("x86-64");
  switch_default: /* CIL Label */ 
#line 122
  return ((char const   *)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 135 "/home/khheo/project/mit-scheme-9.2/src/microcode/utabmd.c"
void initialize_fixed_objects_vector(void) 
{ 
  char *__cil_tmp1 ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 138
  fixed_objects = make_vector(69UL, 0UL, (_Bool)0);
#line 139
  *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 1) = (8UL << 58U) | 2UL;
#line 140
  *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 2) = initialize_interrupt_handler_vector();
#line 142
  *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 7) = initialize_interrupt_mask_vector();
#line 145
  *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 3) = 0UL;
#line 148
  *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 4) = make_vector(32771UL,
                                                                               (8UL << 58U) | 9UL,
                                                                               (_Bool)0);
#line 150
  *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 5) = names_to_vector((unsigned long )(1 << 6),
                                                                                   type_names);
#line 151
  *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 6) = names_to_vector(95UL,
                                                                                   Return_Names);
#line 152
  *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 8) = names_to_vector(64UL,
                                                                                   Error_Names);
#line 153
  *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 23) = names_to_vector(27UL,
                                                                                    Term_Names);
#line 154
  *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 16) = names_to_vector(70UL,
                                                                                    fixed_objects_names);
#line 156
  *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 9) = names_to_vector(13UL,
                                                                                   identity_names);
#line 158
  *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 20) = initialize_history();
#line 159
  *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 21) = long_to_bignum(1L);
#line 160
  *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 14) = (8UL << 58U) | 9UL;
#line 161
  *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 17) = (8UL << 58U) | 9UL;
#line 162
  *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 10) = fixed_objects_syscall_names();
#line 163
  *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 11) = fixed_objects_syserr_names();
#line 165
  *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 37) = make_primitive("INTEGER-ZERO?",
                                                                                   1);
#line 166
  *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 38) = make_primitive("INTEGER-POSITIVE?",
                                                                                   1);
#line 167
  *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 39) = make_primitive("INTEGER-NEGATIVE?",
                                                                                   1);
#line 168
  *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 40) = make_primitive("INTEGER-ADD-1",
                                                                                   1);
#line 169
  *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 41) = make_primitive("INTEGER-SUBTRACT-1",
                                                                                   1);
#line 170
  *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 42) = make_primitive("INTEGER-EQUAL?",
                                                                                   2);
#line 171
  *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 43) = make_primitive("INTEGER-LESS?",
                                                                                   2);
#line 172
  *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 44) = make_primitive("INTEGER-GREATER?",
                                                                                   2);
#line 173
  *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 45) = make_primitive("INTEGER-ADD",
                                                                                   2);
#line 174
  *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 46) = make_primitive("INTEGER-SUBTRACT",
                                                                                   2);
#line 175
  *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 47) = make_primitive("INTEGER-MULTIPLY",
                                                                                   2);
#line 177
  *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 48) = 0UL;
#line 178
  *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 49) = 0UL;
#line 179
  *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 50) = 0UL;
#line 180
  *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 51) = 0UL;
#line 182
  *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 52) = char_pointer_to_symbol("#[(microcode)arity-dispatcher-tag]");
  }
#line 189
  return;
}
}
#line 191 "/home/khheo/project/mit-scheme-9.2/src/microcode/utabmd.c"
static SCHEME_OBJECT fixed_objects_syscall_names(void) 
{ 
  unsigned long length ;
  char const   **names ;
  SCHEME_OBJECT tmp ;

  {
  {
#line 196
  OS_syscall_names(& length, & names);
#line 197
  tmp = names_to_vector(length, names);
  }
#line 197
  return (tmp);
}
}
#line 200 "/home/khheo/project/mit-scheme-9.2/src/microcode/utabmd.c"
static SCHEME_OBJECT fixed_objects_syserr_names(void) 
{ 
  unsigned long length ;
  char const   **names ;
  SCHEME_OBJECT tmp ;

  {
  {
#line 205
  OS_syserr_names(& length, & names);
#line 206
  tmp = names_to_vector(length, names);
  }
#line 206
  return (tmp);
}
}
#line 209 "/home/khheo/project/mit-scheme-9.2/src/microcode/utabmd.c"
static SCHEME_OBJECT names_to_vector(unsigned long length , char const   **names ) 
{ 
  SCHEME_OBJECT v ;
  SCHEME_OBJECT tmp ;
  unsigned long i ;
  SCHEME_OBJECT tmp___0 ;

  {
  {
#line 212
  tmp = allocate_marked_vector(10U, length, (_Bool)1);
#line 212
  v = tmp;
#line 214
  i = 0UL;
  }
  {
#line 214
  while (1) {
    while_continue: /* CIL Label */ ;
#line 214
    if (! (i < length)) {
#line 214
      goto while_break;
    }
#line 215
    if ((unsigned long )*(names + i) == (unsigned long )((char const   *)0)) {
#line 215
      *((SCHEME_OBJECT *)(v & 288230376151711743UL) + (i + 1UL)) = 0UL;
    } else {
      {
#line 215
      tmp___0 = char_pointer_to_symbol(*(names + i));
#line 215
      *((SCHEME_OBJECT *)(v & 288230376151711743UL) + (i + 1UL)) = tmp___0;
      }
    }
#line 214
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 219
  return (v);
}
}
#line 70 "/home/khheo/project/mit-scheme-9.2/src/microcode/dstack.h"
void transaction_initialize(void) ;
#line 31 "/home/khheo/project/mit-scheme-9.2/src/microcode/transact.c"
static  __attribute__((__noreturn__)) void error___0(char const   *procedure_name ,
                                                     char const   *message ) ;
#line 33
static  __attribute__((__noreturn__)) void error___0(char const   *procedure_name ,
                                                     char const   *message ) ;
#line 33 "/home/khheo/project/mit-scheme-9.2/src/microcode/transact.c"
static void error___0(char const   *procedure_name , char const   *message ) 
{ 
  char *__cil_tmp3 ;

  {
  {
#line 36
  outf_fatal("%s: %s\n", procedure_name, message);
#line 37
  outf_flush_fatal();
#line 38
  abort();
  }
}
}
#line 49 "/home/khheo/project/mit-scheme-9.2/src/microcode/transact.c"
static struct transaction *current_transaction  ;
#line 51 "/home/khheo/project/mit-scheme-9.2/src/microcode/transact.c"
static void guarantee_current_transaction(char const   *proc ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 54
  if ((unsigned long )current_transaction == (unsigned long )((struct transaction *)0)) {
    {
#line 55
    error___0(proc, "no transaction");
    }
  }
  {
#line 58
  if ((unsigned int )current_transaction->state == 2U) {
#line 58
    goto case_2;
  }
#line 59
  if ((unsigned int )current_transaction->state == 1U) {
#line 59
    goto case_1;
  }
#line 60
  if ((unsigned int )current_transaction->state == 0U) {
#line 60
    goto case_0;
  }
#line 56
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 58
  error___0(proc, "commit in progress");
  }
#line 58
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 59
  error___0(proc, "abort in progress");
  }
#line 59
  goto switch_break;
  case_0: /* CIL Label */ 
#line 60
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 62
  return;
}
}
#line 64 "/home/khheo/project/mit-scheme-9.2/src/microcode/transact.c"
void transaction_initialize(void) 
{ 


  {
#line 67
  current_transaction = (struct transaction *)0;
#line 68
  return;
}
}
#line 70 "/home/khheo/project/mit-scheme-9.2/src/microcode/transact.c"
void transaction_begin(void) 
{ 
  void *checkpoint ;
  struct transaction *transaction ;
  void *tmp ;

  {
  {
#line 73
  checkpoint = dstack_position;
#line 74
  tmp = dstack_alloc((unsigned int )sizeof(struct transaction ));
#line 74
  transaction = (struct transaction *)tmp;
#line 76
  transaction->checkpoint = checkpoint;
#line 77
  transaction->state = (enum transaction_state )0;
#line 78
  dstack_bind((void *)(& current_transaction), (void *)transaction);
  }
#line 79
  return;
}
}
#line 81 "/home/khheo/project/mit-scheme-9.2/src/microcode/transact.c"
void transaction_abort(void) 
{ 
  char *__cil_tmp1 ;

  {
  {
#line 84
  guarantee_current_transaction("transaction_abort");
#line 85
  current_transaction->state = (enum transaction_state )1;
#line 86
  dstack_set_position(current_transaction->checkpoint);
  }
#line 87
  return;
}
}
#line 89 "/home/khheo/project/mit-scheme-9.2/src/microcode/transact.c"
void transaction_commit(void) 
{ 
  char *__cil_tmp1 ;

  {
  {
#line 92
  guarantee_current_transaction("transaction_commit");
#line 93
  current_transaction->state = (enum transaction_state )2;
#line 94
  dstack_set_position(current_transaction->checkpoint);
  }
#line 95
  return;
}
}
#line 104 "/home/khheo/project/mit-scheme-9.2/src/microcode/transact.c"
static void execute_action(void *action ) 
{ 
  int tmp ;

  {
#line 107
  if ((unsigned int )current_transaction->state == 2U) {
#line 107
    tmp = 0;
  } else {
#line 107
    tmp = 1;
  }
#line 107
  if ((unsigned int )((struct action *)action)->type != (unsigned int )tmp) {
    {
#line 110
    (*(((struct action *)action)->procedure))(((struct action *)action)->environment);
    }
  }
#line 112
  return;
}
}
#line 114 "/home/khheo/project/mit-scheme-9.2/src/microcode/transact.c"
void transaction_record_action(enum transaction_action_type type , void (*procedure)(void *environment ) ,
                               void *environment ) 
{ 
  struct action *action ;
  void *tmp ;
  char *__cil_tmp6 ;

  {
  {
#line 119
  guarantee_current_transaction("transaction_record_action");
#line 121
  tmp = dstack_alloc((unsigned int )sizeof(struct action ));
#line 121
  action = (struct action *)tmp;
#line 122
  action->type = type;
#line 123
  action->procedure = procedure;
#line 124
  action->environment = environment;
#line 125
  dstack_protect(& execute_action, (void *)action);
  }
#line 127
  return;
}
}
#line 63 "/usr/include/setjmp.h"
extern  __attribute__((__nothrow__)) int _setjmp(struct __jmp_buf_tag *__env ) ;
#line 158 "/home/khheo/project/mit-scheme-9.2/src/microcode/interp.h"
interpreter_state_t interpreter_state ;
#line 160
void bind_interpreter_state(interpreter_state_t s ) ;
#line 161
void unbind_interpreter_state(interpreter_state_t s ) ;
#line 176 "/home/khheo/project/mit-scheme-9.2/src/microcode/extern.h"
char const   *term_messages[27] ;
#line 324
void reset_memory(void) ;
#line 355
 __attribute__((__noreturn__)) void termination_end_of_computation(void) ;
#line 358
 __attribute__((__noreturn__)) void termination_gc_out_of_space(void) ;
#line 381
void Print_Expression(SCHEME_OBJECT expression , char const   *string ) ;
#line 36 "/home/khheo/project/mit-scheme-9.2/src/microcode/term.c"
void get_band_parameters(unsigned long *heap_size , unsigned long *const_size ) ;
#line 46
static void edwin_auto_save(void) ;
#line 47
static void delete_temp_files(void) ;
#line 60 "/home/khheo/project/mit-scheme-9.2/src/microcode/term.c"
void init_exit_scheme(void) 
{ 


  {
#line 66
  return;
}
}
#line 68 "/home/khheo/project/mit-scheme-9.2/src/microcode/term.c"
static void attempt_termination_backout(int code ) 
{ 
  SCHEME_OBJECT Term_Vector ;
  SCHEME_OBJECT Handler ;
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp9 ;

  {
  {
#line 71
  outf_flush_error();
  }
#line 72
  if ((unsigned long )critical_section_name != (unsigned long )((char const   *)0)) {
#line 75
    return;
  } else
#line 72
  if (code == 0) {
#line 75
    return;
  } else
#line 72
  if (! (fixed_objects >> 58U == 10UL)) {
#line 75
    return;
  }
#line 77
  Term_Vector = *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 24);
#line 79
  if (! (Term_Vector >> 58U == 10UL)) {
#line 81
    return;
  } else
#line 79
  if ((long )(*((SCHEME_OBJECT *)(Term_Vector & 288230376151711743UL) + 0) & 288230376151711743UL) <= (long )code) {
#line 81
    return;
  }
#line 83
  Handler = *((SCHEME_OBJECT *)(Term_Vector & 288230376151711743UL) + (code + 1));
#line 84
  if (Handler == 0UL) {
#line 85
    return;
  }
  {
#line 86
  while (1) {
    while_continue: /* CIL Label */ ;
#line 86
    if (code == 9) {
#line 86
      tmp___2 = 5;
    } else {
#line 86
      tmp___2 = 4;
    }
#line 86
    if (! ((unsigned long )(stack_pointer + - (3 + tmp___2)) >= (unsigned long )stack_guard)) {
      {
#line 86
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 86
        if (*stack_start != ((34UL << 58U) | (SCHEME_OBJECT )stack_start)) {
          {
#line 86
          stack_death("STACK_CHECK");
          }
        }
#line 86
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 86
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 86
        set_ulong_register(12U, Registers[12] | 1UL);
        }
        {
#line 86
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 86
          if ((Registers[1] & Registers[12]) != 0UL) {
#line 86
            tmp___0 = memory_block_start;
          } else {
#line 86
            if ((Registers[1] & 4UL) != 0UL) {
#line 86
              tmp = heap_alloc_limit;
            } else {
#line 86
              tmp = heap_end;
            }
#line 86
            tmp___0 = tmp;
          }
          {
#line 86
          set_ptr_register(0U, tmp___0);
          }
#line 86
          if ((Registers[1] & 1UL) != 0UL) {
#line 86
            tmp___1 = stack_guard;
          } else {
#line 86
            tmp___1 = stack_start;
          }
          {
#line 86
          set_ptr_register(11U, tmp___1);
          }
#line 86
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 86
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 86
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 89
  Registers[6] = (11UL << 58U) | 70UL;
#line 90
  Registers[5] = (26UL << 58U) | (unsigned long )code;
  {
#line 91
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 91
    stack_pointer --;
#line 91
    *stack_pointer = Registers[5];
#line 91
    stack_pointer --;
#line 91
    *stack_pointer = Registers[6];
#line 91
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 92
  if (code == 9) {
#line 93
    stack_pointer --;
#line 93
    *stack_pointer = (26UL << 58U) | (unsigned long )death_blow;
  }
#line 94
  stack_pointer --;
#line 94
  *stack_pointer = Registers[2];
#line 95
  stack_pointer --;
#line 95
  *stack_pointer = Registers[3];
#line 96
  stack_pointer --;
#line 96
  *stack_pointer = Registers[5];
#line 97
  stack_pointer --;
#line 97
  *stack_pointer = Handler;
#line 98
  stack_pointer --;
#line 98
  if (code == 9) {
#line 98
    tmp___3 = 4;
  } else {
#line 98
    tmp___3 = 3;
  }
  {
#line 98
  *stack_pointer = (unsigned long )(tmp___3 + 1);
#line 100
  abort_to_interpreter(-6);
  }
}
}
#line 105 "/home/khheo/project/mit-scheme-9.2/src/microcode/term.c"
static void termination_prefix(int code ) 
{ 
  char const   *msg ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 108
  attempt_termination_backout(code);
#line 109
  OS_restore_external_state();
  }
#line 112
  if (code == 0) {
#line 114
    if (! option_batch_mode) {
      {
#line 116
      outf_console("\n%s.\n", term_messages[code]);
#line 117
      outf_flush_console();
      }
    }
  } else {
    {
#line 125
    outf_fatal("\n");
#line 127
    msg = (char const   *)0;
    }
#line 128
    if (code >= 0) {
#line 128
      if (code <= 26) {
#line 129
        msg = term_messages[code];
      }
    }
#line 130
    if ((unsigned long )msg == (unsigned long )((char const   *)0)) {
      {
#line 131
      outf_fatal("Unknown termination code %#x", code);
      }
    } else {
      {
#line 133
      outf_fatal("%s", msg);
      }
    }
#line 135
    if ((unsigned long )critical_section_name != (unsigned long )((char const   *)0)) {
      {
#line 136
      outf_fatal(" within critical section \"%s\"", critical_section_name);
      }
    }
    {
#line 138
    outf_fatal(".");
#line 140
    outf_fatal("\n");
    }
  }
#line 143
  return;
}
}
#line 145
static  __attribute__((__noreturn__)) void termination_suffix(int code , int value ,
                                                              _Bool abnormal_p ) ;
#line 146
static  __attribute__((__noreturn__)) void termination_suffix_trace(int code ) ;
#line 148
static  __attribute__((__noreturn__)) void termination_suffix(int code , int value ,
                                                              _Bool abnormal_p ) ;
#line 148 "/home/khheo/project/mit-scheme-9.2/src/microcode/term.c"
static void termination_suffix(int code , int value , _Bool abnormal_p ) 
{ 


  {
  {
#line 154
  edwin_auto_save();
#line 155
  delete_temp_files();
#line 160
  outf_flush_fatal();
#line 161
  reset_memory();
#line 162
  exit(value);
  }
}
}
#line 165
static  __attribute__((__noreturn__)) void termination_suffix_trace(int code ) ;
#line 165 "/home/khheo/project/mit-scheme-9.2/src/microcode/term.c"
static void termination_suffix_trace(int code ) 
{ 


  {
  {
#line 173
  termination_suffix(code, 1, (_Bool)1);
  }
}
}
#line 176
 __attribute__((__noreturn__)) void Microcode_Termination(int code ) ;
#line 176 "/home/khheo/project/mit-scheme-9.2/src/microcode/term.c"
void Microcode_Termination(int code ) 
{ 


  {
  {
#line 179
  termination_prefix(code);
#line 180
  termination_suffix_trace(code);
  }
}
}
#line 183
 __attribute__((__noreturn__)) void termination_normal(int const   value ) ;
#line 183 "/home/khheo/project/mit-scheme-9.2/src/microcode/term.c"
void termination_normal(int const   value ) 
{ 


  {
  {
#line 186
  termination_prefix(0);
#line 187
  termination_suffix(0, (int )value, (_Bool)0);
  }
}
}
#line 190
 __attribute__((__noreturn__)) void termination_init_error(void) ;
#line 190 "/home/khheo/project/mit-scheme-9.2/src/microcode/term.c"
void termination_init_error(void) 
{ 


  {
  {
#line 193
  termination_prefix(12);
#line 194
  termination_suffix(12, 1, (_Bool)1);
  }
}
}
#line 197
 __attribute__((__noreturn__)) void termination_end_of_computation(void) ;
#line 197 "/home/khheo/project/mit-scheme-9.2/src/microcode/term.c"
void termination_end_of_computation(void) 
{ 
  char *__cil_tmp1 ;
  char *__cil_tmp2 ;

  {
  {
#line 200
  termination_prefix(17);
#line 201
  Print_Expression(Registers[2], "Final result");
#line 202
  outf_console("\n");
#line 203
  termination_suffix(17, 0, (_Bool)0);
  }
}
}
#line 206
 __attribute__((__noreturn__)) void termination_trap(void) ;
#line 206 "/home/khheo/project/mit-scheme-9.2/src/microcode/term.c"
void termination_trap(void) 
{ 


  {
  {
#line 211
  termination_prefix(25);
#line 212
  termination_suffix(25, 1, (_Bool)0);
  }
}
}
#line 215
 __attribute__((__noreturn__)) void termination_no_error_handler(void) ;
#line 215 "/home/khheo/project/mit-scheme-9.2/src/microcode/term.c"
void termination_no_error_handler(void) 
{ 
  unsigned long heap_size ;
  unsigned long const_size ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 219
  termination_prefix(9);
  }
#line 220
  if (death_blow == 23L) {
    {
#line 224
    get_band_parameters(& heap_size, & const_size);
#line 225
    outf_fatal("Try again with values at least as large as\n");
#line 226
    outf_fatal("  --heap %lu\n", 50UL + (heap_size + 1023UL) / 1024UL);
#line 228
    outf_fatal("  --constant %lu\n", (const_size + 1023UL) / 1024UL);
    }
  }
  {
#line 230
  termination_suffix(9, 1, (_Bool)1);
  }
}
}
#line 233
 __attribute__((__noreturn__)) void termination_gc_out_of_space(void) ;
#line 233 "/home/khheo/project/mit-scheme-9.2/src/microcode/term.c"
void termination_gc_out_of_space(void) 
{ 
  long tmp ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 236
  termination_prefix(20);
#line 237
  outf_fatal("You are out of space at the end of a garbage collection!\n");
#line 238
  outf_fatal("Free = %#lx; heap_alloc_limit = %#lx; heap_end = %#lx\n", (unsigned long )Free,
             (unsigned long )heap_alloc_limit, (unsigned long )heap_end);
  }
#line 243
  if ((unsigned long )Free >= (unsigned long )heap_start) {
#line 243
    if ((unsigned long )Free < (unsigned long )heap_alloc_limit) {
#line 243
      tmp = heap_alloc_limit - Free;
    } else {
#line 243
      tmp = 0L;
    }
  } else {
#line 243
    tmp = 0L;
  }
  {
#line 243
  outf_fatal("# words needed = %lu; # words available = %lu\n", gc_space_needed, (unsigned long )tmp);
#line 245
  termination_suffix_trace(20);
  }
}
}
#line 248
 __attribute__((__noreturn__)) void termination_eof(void) ;
#line 248 "/home/khheo/project/mit-scheme-9.2/src/microcode/term.c"
void termination_eof(void) 
{ 


  {
  {
#line 251
  Microcode_Termination(14);
  }
}
}
#line 254
 __attribute__((__noreturn__)) void termination_signal(char const   *signal_name ) ;
#line 254 "/home/khheo/project/mit-scheme-9.2/src/microcode/term.c"
void termination_signal(char const   *signal_name ) 
{ 
  char *__cil_tmp2 ;

  {
#line 257
  if ((unsigned long )signal_name != (unsigned long )((char const   *)0)) {
    {
#line 259
    termination_prefix(22);
#line 260
    outf_fatal("Killed by %s.\n", signal_name);
    }
  } else {
    {
#line 263
    attempt_termination_backout(22);
    }
  }
  {
#line 264
  termination_suffix_trace(22);
  }
}
}
#line 270 "/home/khheo/project/mit-scheme-9.2/src/microcode/term.c"
static SCHEME_OBJECT position  ;
#line 271 "/home/khheo/project/mit-scheme-9.2/src/microcode/term.c"
static struct interpreter_state_s new_state  ;
#line 267 "/home/khheo/project/mit-scheme-9.2/src/microcode/term.c"
static void edwin_auto_save(void) 
{ 
  SCHEME_OBJECT entry ;
  SCHEME_OBJECT group ;
  char *namestring ;
  unsigned long length ;
  unsigned char *start ;
  unsigned char *tmp ;
  unsigned char *end ;
  unsigned char *gap_start ;
  unsigned char *gap_end ;
  Tchannel channel ;
  int tmp___0 ;
  char *__cil_tmp12 ;

  {
#line 273
  if (fixed_objects >> 58U == 10UL) {
#line 273
    position = *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 14);
  } else {
#line 273
    position = (8UL << 58U) | 9UL;
  }
  {
#line 277
  while (1) {
    while_continue: /* CIL Label */ ;
#line 277
    if (! (position >> 58U == 1UL)) {
#line 277
      goto while_break;
    }
#line 279
    entry = *((SCHEME_OBJECT *)(position & 288230376151711743UL) + 0);
#line 280
    position = *((SCHEME_OBJECT *)(position & 288230376151711743UL) + 1);
#line 281
    if (entry >> 58U == 1UL) {
#line 281
      if (*((SCHEME_OBJECT *)(entry & 288230376151711743UL) + 0) >> 58U == 10UL) {
#line 281
        if (*((SCHEME_OBJECT *)(entry & 288230376151711743UL) + 1) >> 58U == 30UL) {
#line 281
          if (*((SCHEME_OBJECT *)(*((SCHEME_OBJECT *)(entry & 288230376151711743UL) + 0) & 288230376151711743UL) + 17) == 8UL << 58U) {
            {
#line 286
            group = *((SCHEME_OBJECT *)(entry & 288230376151711743UL) + 0);
#line 287
            namestring = (char *)((SCHEME_OBJECT *)(*((SCHEME_OBJECT *)(entry & 288230376151711743UL) + 1) & 288230376151711743UL) + 2);
#line 289
            tmp = lookup_external_string(*((SCHEME_OBJECT *)(group & 288230376151711743UL) + 2),
                                         & length);
#line 289
            start = tmp;
#line 290
            end = start + length;
#line 291
            gap_start = start + (*((SCHEME_OBJECT *)(group & 288230376151711743UL) + 3) & 288230376151711743UL);
#line 292
            gap_end = start + (*((SCHEME_OBJECT *)(group & 288230376151711743UL) + 5) & 288230376151711743UL);
            }
#line 293
            if ((unsigned long )start < (unsigned long )gap_start) {
#line 293
              goto _L;
            } else
#line 293
            if ((unsigned long )gap_end < (unsigned long )end) {
              _L: /* CIL Label */ 
              {
#line 295
              bind_interpreter_state(& new_state);
#line 296
              tmp___0 = _setjmp((struct __jmp_buf_tag *)(interpreter_state->catch_env));
              }
#line 296
              if (tmp___0 == 0) {
                {
#line 299
                outf_error("Auto-saving file \"%s\"\n", namestring);
#line 300
                outf_flush_error();
#line 301
                channel = OS_open_output_file((char const   *)namestring);
                }
#line 302
                if ((unsigned long )start < (unsigned long )gap_start) {
                  {
#line 303
                  OS_channel_write(channel, (void const   *)start, (size_t )(gap_start - start));
                  }
                }
#line 304
                if ((unsigned long )gap_end < (unsigned long )end) {
                  {
#line 305
                  OS_channel_write(channel, (void const   *)gap_end, (size_t )(end - gap_end));
                  }
                }
                {
#line 306
                OS_channel_close(channel);
                }
              }
              {
#line 308
              unbind_interpreter_state(& new_state);
              }
            }
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 312
  return;
}
}
#line 317 "/home/khheo/project/mit-scheme-9.2/src/microcode/term.c"
static SCHEME_OBJECT position___0  ;
#line 318 "/home/khheo/project/mit-scheme-9.2/src/microcode/term.c"
static struct interpreter_state_s new_state___0  ;
#line 314 "/home/khheo/project/mit-scheme-9.2/src/microcode/term.c"
static void delete_temp_files(void) 
{ 
  SCHEME_OBJECT entry ;
  int tmp ;

  {
#line 320
  if (fixed_objects >> 58U == 10UL) {
#line 320
    position___0 = *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 17);
  } else {
#line 320
    position___0 = (8UL << 58U) | 9UL;
  }
  {
#line 324
  while (1) {
    while_continue: /* CIL Label */ ;
#line 324
    if (! (position___0 >> 58U == 1UL)) {
#line 324
      goto while_break;
    }
#line 326
    entry = *((SCHEME_OBJECT *)(position___0 & 288230376151711743UL) + 0);
#line 327
    position___0 = *((SCHEME_OBJECT *)(position___0 & 288230376151711743UL) + 1);
#line 328
    if (entry >> 58U == 30UL) {
      {
#line 330
      bind_interpreter_state(& new_state___0);
#line 331
      tmp = _setjmp((struct __jmp_buf_tag *)(interpreter_state->catch_env));
      }
#line 331
      if (tmp == 0) {
        {
#line 332
        OS_file_remove((char const   *)((char *)((SCHEME_OBJECT *)(entry & 288230376151711743UL) + 2)));
        }
      }
      {
#line 333
      unbind_interpreter_state(& new_state___0);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 336
  return;
}
}
#line 152 "/home/khheo/project/mit-scheme-9.2/src/microcode/extern.h"
SCHEME_OBJECT *constant_alloc_next ;
#line 181
char const   *scheme_program_name ;
#line 37 "/home/khheo/project/mit-scheme-9.2/src/microcode/sysprim.c"
double arg_flonum(int arg_number ) ;
#line 41 "/home/khheo/project/mit-scheme-9.2/src/microcode/sysprim.c"
SCHEME_OBJECT Prim_non_restartable_exit(void) 
{ 


  {
  {
#line 44
  while (1) {
    while_continue: /* CIL Label */ ;
#line 44
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 45
  termination_normal((int const   )0);
  }
#line 46
  return ((8UL << 58U) | 1UL);
}
}
#line 49 "/home/khheo/project/mit-scheme-9.2/src/microcode/sysprim.c"
SCHEME_OBJECT Prim_non_restartable_exit_with_value(void) 
{ 
  long tmp ;

  {
  {
#line 54
  while (1) {
    while_continue: /* CIL Label */ ;
#line 54
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 55
  tmp = arg_integer(1);
#line 55
  termination_normal((int const   )((int )tmp));
  }
#line 56
  return ((8UL << 58U) | 1UL);
}
}
#line 59 "/home/khheo/project/mit-scheme-9.2/src/microcode/sysprim.c"
SCHEME_OBJECT Prim_restartable_exit(void) 
{ 


  {
  {
#line 62
  while (1) {
    while_continue: /* CIL Label */ ;
#line 62
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 63
  OS_restartable_exit();
  }
#line 64
  return ((8UL << 58U) | 1UL);
}
}
#line 67 "/home/khheo/project/mit-scheme-9.2/src/microcode/sysprim.c"
SCHEME_OBJECT Prim_under_emacs_p(void) 
{ 
  unsigned long tmp___0 ;
  int tmp___1 ;

  {
  {
#line 69
  while (1) {
    while_continue: /* CIL Label */ ;
#line 69
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 70
  tmp___1 = OS_under_emacs_p();
  }
#line 70
  if (tmp___1) {
#line 70
    tmp___0 = 8UL << 58U;
  } else {
#line 70
    tmp___0 = 0UL;
  }
#line 70
  return (tmp___0);
}
}
#line 73 "/home/khheo/project/mit-scheme-9.2/src/microcode/sysprim.c"
SCHEME_OBJECT Prim_set_trap_state(void) 
{ 
  long result ;
  long tmp ;

  {
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
#line 76
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 78
  tmp = arg_nonnegative_integer(1);
#line 78
  result = OS_set_trap_state(tmp);
  }
#line 79
  if (result < 0L) {
    {
#line 81
    error_bad_range_arg(1);
    }
  }
#line 84
  return ((26UL << 58U) | (unsigned long )result);
}
}
#line 87 "/home/khheo/project/mit-scheme-9.2/src/microcode/sysprim.c"
SCHEME_OBJECT Prim_heap_available_p(void) 
{ 
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;

  {
  {
#line 91
  while (1) {
    while_continue: /* CIL Label */ ;
#line 91
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 92
  if ((unsigned long )Free >= (unsigned long )heap_start) {
#line 92
    if ((unsigned long )Free < (unsigned long )heap_alloc_limit) {
      {
#line 92
      tmp___1 = arg_ulong_integer(1);
      }
#line 92
      if ((unsigned long )(Free + tmp___1) <= (unsigned long )heap_alloc_limit) {
#line 92
        tmp___0 = 8UL << 58U;
      } else {
#line 92
        tmp___0 = 0UL;
      }
    } else {
#line 92
      tmp___0 = 0UL;
    }
  } else {
#line 92
    tmp___0 = 0UL;
  }
#line 92
  return (tmp___0);
}
}
#line 96 "/home/khheo/project/mit-scheme-9.2/src/microcode/sysprim.c"
SCHEME_OBJECT Prim_get_free(void) 
{ 
  unsigned long tmp ;

  {
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 100
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 101
  tmp = arg_ulong_index_integer(1, 64UL);
  }
#line 101
  return ((tmp << 58U) | (SCHEME_OBJECT )Free);
}
}
#line 105 "/home/khheo/project/mit-scheme-9.2/src/microcode/sysprim.c"
SCHEME_OBJECT Prim_increment_free(void) 
{ 
  unsigned long tmp ;

  {
  {
#line 109
  while (1) {
    while_continue: /* CIL Label */ ;
#line 109
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 110
  tmp = arg_ulong_integer(1);
#line 110
  Free += tmp;
  }
#line 111
  return ((8UL << 58U) | 1UL);
}
}
#line 117 "/home/khheo/project/mit-scheme-9.2/src/microcode/sysprim.c"
SCHEME_OBJECT Prim_gc_space_status(void) 
{ 
  SCHEME_OBJECT v ;
  SCHEME_OBJECT tmp ;

  {
  {
#line 119
  while (1) {
    while_continue: /* CIL Label */ ;
#line 119
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 121
  tmp = make_vector(12UL, 0UL, (_Bool)1);
#line 121
  v = tmp;
#line 122
  *((SCHEME_OBJECT *)(v & 288230376151711743UL) + 1) = (26UL << 58U) | sizeof(SCHEME_OBJECT );
#line 123
  *((SCHEME_OBJECT *)(v & 288230376151711743UL) + 2) = ulong_to_integer((SCHEME_OBJECT )constant_start);
#line 124
  *((SCHEME_OBJECT *)(v & 288230376151711743UL) + 3) = ulong_to_integer((SCHEME_OBJECT )constant_alloc_next);
#line 125
  *((SCHEME_OBJECT *)(v & 288230376151711743UL) + 4) = ulong_to_integer((SCHEME_OBJECT )constant_end);
#line 126
  *((SCHEME_OBJECT *)(v & 288230376151711743UL) + 5) = ulong_to_integer((SCHEME_OBJECT )heap_start);
#line 127
  *((SCHEME_OBJECT *)(v & 288230376151711743UL) + 6) = ulong_to_integer((SCHEME_OBJECT )Free);
#line 128
  *((SCHEME_OBJECT *)(v & 288230376151711743UL) + 7) = ulong_to_integer((SCHEME_OBJECT )heap_alloc_limit);
#line 129
  *((SCHEME_OBJECT *)(v & 288230376151711743UL) + 8) = ulong_to_integer((SCHEME_OBJECT )heap_end);
#line 130
  *((SCHEME_OBJECT *)(v & 288230376151711743UL) + 9) = ulong_to_integer((SCHEME_OBJECT )stack_start);
#line 131
  *((SCHEME_OBJECT *)(v & 288230376151711743UL) + 10) = ulong_to_integer((SCHEME_OBJECT )stack_pointer);
#line 132
  *((SCHEME_OBJECT *)(v & 288230376151711743UL) + 11) = ulong_to_integer((SCHEME_OBJECT )stack_guard);
#line 133
  *((SCHEME_OBJECT *)(v & 288230376151711743UL) + 12) = ulong_to_integer((SCHEME_OBJECT )stack_end);
  }
#line 134
  return (v);
}
}
#line 138 "/home/khheo/project/mit-scheme-9.2/src/microcode/sysprim.c"
SCHEME_OBJECT Prim_scheme_program_name(void) 
{ 
  SCHEME_OBJECT tmp ;

  {
  {
#line 140
  while (1) {
    while_continue: /* CIL Label */ ;
#line 140
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 141
  tmp = char_pointer_to_string(scheme_program_name);
  }
#line 141
  return (tmp);
}
}
#line 144 "/home/khheo/project/mit-scheme-9.2/src/microcode/sysprim.c"
SCHEME_OBJECT Prim_read_byte_from_memory(void) 
{ 
  unsigned long tmp ;
  SCHEME_OBJECT tmp___0 ;

  {
  {
#line 148
  while (1) {
    while_continue: /* CIL Label */ ;
#line 148
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 149
  tmp = arg_ulong_integer(1);
#line 149
  tmp___0 = ulong_to_integer((unsigned long )*((unsigned char *)tmp));
  }
#line 149
  return (tmp___0);
}
}
#line 153 "/home/khheo/project/mit-scheme-9.2/src/microcode/sysprim.c"
SCHEME_OBJECT Prim_read_word_from_memory(void) 
{ 
  unsigned long tmp ;
  SCHEME_OBJECT tmp___0 ;

  {
  {
#line 157
  while (1) {
    while_continue: /* CIL Label */ ;
#line 157
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 158
  tmp = arg_ulong_integer(1);
#line 158
  tmp___0 = ulong_to_integer(*((unsigned long *)tmp));
  }
#line 158
  return (tmp___0);
}
}
#line 162 "/home/khheo/project/mit-scheme-9.2/src/microcode/sysprim.c"
SCHEME_OBJECT Prim_read_float_from_memory(void) 
{ 
  unsigned long tmp ;
  SCHEME_OBJECT tmp___0 ;

  {
  {
#line 166
  while (1) {
    while_continue: /* CIL Label */ ;
#line 166
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 167
  tmp = arg_ulong_integer(1);
#line 167
  tmp___0 = double_to_flonum(*((double *)tmp));
  }
#line 167
  return (tmp___0);
}
}
#line 170 "/home/khheo/project/mit-scheme-9.2/src/microcode/sysprim.c"
SCHEME_OBJECT Prim_write_byte_to_memory(void) 
{ 
  unsigned long tmp ;
  long tmp___0 ;

  {
  {
#line 174
  while (1) {
    while_continue: /* CIL Label */ ;
#line 174
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 175
  tmp = arg_ulong_integer(2);
#line 175
  tmp___0 = arg_index_integer(1, 256L);
#line 175
  *((unsigned char *)tmp) = (unsigned char )tmp___0;
  }
#line 177
  return ((8UL << 58U) | 1UL);
}
}
#line 180 "/home/khheo/project/mit-scheme-9.2/src/microcode/sysprim.c"
SCHEME_OBJECT Prim_write_word_to_memory(void) 
{ 
  unsigned long tmp ;

  {
  {
#line 184
  while (1) {
    while_continue: /* CIL Label */ ;
#line 184
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 185
  tmp = arg_ulong_integer(2);
#line 185
  *((unsigned long *)tmp) = arg_ulong_integer(1);
  }
#line 186
  return ((8UL << 58U) | 1UL);
}
}
#line 189 "/home/khheo/project/mit-scheme-9.2/src/microcode/sysprim.c"
SCHEME_OBJECT Prim_write_float_to_memory(void) 
{ 
  unsigned long tmp ;

  {
  {
#line 193
  while (1) {
    while_continue: /* CIL Label */ ;
#line 193
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 194
  tmp = arg_ulong_integer(2);
#line 194
  *((double *)tmp) = arg_flonum(1);
  }
#line 195
  return ((8UL << 58U) | 1UL);
}
}
#line 198 "/home/khheo/project/mit-scheme-9.2/src/microcode/sysprim.c"
SCHEME_OBJECT Prim_cc_block_linkage_info(void) 
{ 
  SCHEME_OBJECT tmp ;

  {
  {
#line 200
  while (1) {
    while_continue: /* CIL Label */ ;
#line 200
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 201
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 201
    if (! (*(stack_pointer + 0) >> 58U == 61UL)) {
      {
#line 201
      error_wrong_type_arg(1);
      }
    }
#line 201
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 202
  tmp = cc_block_linkage_info(*(stack_pointer + 0));
  }
#line 202
  return (tmp);
}
}
#line 108 "/home/khheo/project/mit-scheme-9.2/src/microcode/prims.h"
long arg_ascii_char(int n ) ;
#line 97 "/home/khheo/project/mit-scheme-9.2/src/microcode/syntax.h"
unsigned char syntax_spec_code[128] ;
#line 46 "/home/khheo/project/mit-scheme-9.2/src/microcode/syntax.c"
unsigned char syntax_spec_code[128]  = 
#line 46 "/home/khheo/project/mit-scheme-9.2/src/microcode/syntax.c"
  {      (unsigned char)13,      (unsigned char)13,      (unsigned char)13,      (unsigned char)13, 
        (unsigned char)13,      (unsigned char)13,      (unsigned char)13,      (unsigned char)13, 
        (unsigned char)13,      (unsigned char)13,      (unsigned char)13,      (unsigned char)13, 
        (unsigned char)13,      (unsigned char)13,      (unsigned char)13,      (unsigned char)13, 
        (unsigned char)13,      (unsigned char)13,      (unsigned char)13,      (unsigned char)13, 
        (unsigned char)13,      (unsigned char)13,      (unsigned char)13,      (unsigned char)13, 
        (unsigned char)13,      (unsigned char)13,      (unsigned char)13,      (unsigned char)13, 
        (unsigned char)13,      (unsigned char)13,      (unsigned char)13,      (unsigned char)13, 
        (unsigned char)0,      (unsigned char)13,      (unsigned char)7,      (unsigned char)13, 
        (unsigned char)8,      (unsigned char)13,      (unsigned char)13,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)13,      (unsigned char)13, 
        (unsigned char)13,      (unsigned char)0,      (unsigned char)1,      (unsigned char)10, 
        (unsigned char)13,      (unsigned char)13,      (unsigned char)13,      (unsigned char)13, 
        (unsigned char)13,      (unsigned char)13,      (unsigned char)13,      (unsigned char)13, 
        (unsigned char)13,      (unsigned char)13,      (unsigned char)13,      (unsigned char)13, 
        (unsigned char)11,      (unsigned char)13,      (unsigned char)12,      (unsigned char)13, 
        (unsigned char)13,      (unsigned char)13,      (unsigned char)13,      (unsigned char)13, 
        (unsigned char)13,      (unsigned char)13,      (unsigned char)13,      (unsigned char)13, 
        (unsigned char)13,      (unsigned char)13,      (unsigned char)13,      (unsigned char)13, 
        (unsigned char)13,      (unsigned char)13,      (unsigned char)13,      (unsigned char)13, 
        (unsigned char)13,      (unsigned char)13,      (unsigned char)13,      (unsigned char)13, 
        (unsigned char)13,      (unsigned char)13,      (unsigned char)13,      (unsigned char)2, 
        (unsigned char)13,      (unsigned char)13,      (unsigned char)13,      (unsigned char)13, 
        (unsigned char)9,      (unsigned char)13,      (unsigned char)13,      (unsigned char)3, 
        (unsigned char)13,      (unsigned char)13,      (unsigned char)13,      (unsigned char)13, 
        (unsigned char)13,      (unsigned char)13,      (unsigned char)13,      (unsigned char)13, 
        (unsigned char)13,      (unsigned char)13,      (unsigned char)13,      (unsigned char)13, 
        (unsigned char)13,      (unsigned char)13,      (unsigned char)13,      (unsigned char)13, 
        (unsigned char)13,      (unsigned char)13,      (unsigned char)13,      (unsigned char)13, 
        (unsigned char)13,      (unsigned char)13,      (unsigned char)13,      (unsigned char)2, 
        (unsigned char)13,      (unsigned char)13,      (unsigned char)13,      (unsigned char)13, 
        (unsigned char)13,      (unsigned char)13,      (unsigned char)13,      (unsigned char)13};
#line 120 "/home/khheo/project/mit-scheme-9.2/src/microcode/syntax.c"
unsigned char syntax_code_spec[13]  = 
#line 120
  {      (unsigned char )' ',      (unsigned char )'.',      (unsigned char )'w',      (unsigned char )'_', 
        (unsigned char )'(',      (unsigned char )')',      (unsigned char )'\'',      (unsigned char )'\"', 
        (unsigned char )'$',      (unsigned char )'\\',      (unsigned char )'/',      (unsigned char )'<', 
        (unsigned char )'>'};
#line 134 "/home/khheo/project/mit-scheme-9.2/src/microcode/syntax.c"
SCHEME_OBJECT Prim_string_to_syntax_entry(void) 
{ 
  unsigned long length ;
  unsigned long result ;
  unsigned char *scan ;
  unsigned long c ;
  unsigned char *tmp ;
  unsigned long c___0 ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned long tmp___2 ;

  {
  {
#line 139
  while (1) {
    while_continue: /* CIL Label */ ;
#line 139
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 141
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 141
    if (! (*(stack_pointer + 0) >> 58U == 30UL)) {
      {
#line 141
      error_wrong_type_arg(1);
      }
    }
#line 141
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 142
  length = *((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 1) & 288230376151711743UL;
#line 143
  scan = (unsigned char *)((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 2) + 0;
#line 145
  if (length > 0UL) {
#line 147
    tmp = scan;
#line 147
    scan ++;
#line 147
    c = (unsigned long )*tmp;
#line 148
    length --;
#line 149
    if (c >= 128UL) {
      {
#line 149
      error_bad_range_arg(1);
      }
    }
#line 150
    result = (unsigned long )syntax_spec_code[c];
#line 151
    if (result == 13UL) {
      {
#line 151
      error_bad_range_arg(1);
      }
    }
  } else {
#line 154
    result = 0UL;
  }
#line 156
  if (length > 0UL) {
#line 158
    tmp___0 = scan;
#line 158
    scan ++;
#line 158
    c___0 = (unsigned long )*tmp___0;
#line 159
    length --;
#line 160
    if (c___0 != 32UL) {
#line 160
      result |= c___0 << 4;
    }
  }
  {
#line 163
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 163
    tmp___2 = length;
#line 163
    length --;
#line 163
    if (! (tmp___2 > 0UL)) {
#line 163
      goto while_break___1;
    }
#line 164
    tmp___1 = scan;
#line 164
    scan ++;
    {
#line 166
    if ((int )*tmp___1 == 49) {
#line 166
      goto case_49;
    }
#line 167
    if ((int )*tmp___1 == 50) {
#line 167
      goto case_50;
    }
#line 168
    if ((int )*tmp___1 == 51) {
#line 168
      goto case_51;
    }
#line 169
    if ((int )*tmp___1 == 52) {
#line 169
      goto case_52;
    }
#line 170
    if ((int )*tmp___1 == 53) {
#line 170
      goto case_53;
    }
#line 171
    if ((int )*tmp___1 == 54) {
#line 171
      goto case_54;
    }
#line 172
    if ((int )*tmp___1 == 55) {
#line 172
      goto case_55;
    }
#line 173
    if ((int )*tmp___1 == 56) {
#line 173
      goto case_56;
    }
#line 174
    if ((int )*tmp___1 == 98) {
#line 174
      goto case_98;
    }
#line 182
    if ((int )*tmp___1 == 112) {
#line 182
      goto case_112;
    }
#line 183
    if ((int )*tmp___1 == 32) {
#line 183
      goto case_32;
    }
#line 184
    goto switch_default___0;
    case_49: /* CIL Label */ 
    {
#line 166
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 166
      if ((result & (unsigned long )(64 << 12)) != 0UL) {
        {
#line 166
        error_bad_range_arg(1);
        }
      }
#line 166
      result |= (unsigned long )(64 << 12);
#line 166
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 166
    goto switch_break;
    case_50: /* CIL Label */ 
    {
#line 167
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 167
      if ((result & (unsigned long )(16 << 12)) != 0UL) {
        {
#line 167
        error_bad_range_arg(1);
        }
      }
#line 167
      result |= (unsigned long )(16 << 12);
#line 167
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 167
    goto switch_break;
    case_51: /* CIL Label */ 
    {
#line 168
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 168
      if ((result & (unsigned long )(4 << 12)) != 0UL) {
        {
#line 168
        error_bad_range_arg(1);
        }
      }
#line 168
      result |= (unsigned long )(4 << 12);
#line 168
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 168
    goto switch_break;
    case_52: /* CIL Label */ 
    {
#line 169
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 169
      if ((result & (unsigned long )(1 << 12)) != 0UL) {
        {
#line 169
        error_bad_range_arg(1);
        }
      }
#line 169
      result |= (unsigned long )(1 << 12);
#line 169
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 169
    goto switch_break;
    case_53: /* CIL Label */ 
    {
#line 170
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 170
      if ((result & (unsigned long )(128 << 12)) != 0UL) {
        {
#line 170
        error_bad_range_arg(1);
        }
      }
#line 170
      result |= (unsigned long )(128 << 12);
#line 170
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 170
    goto switch_break;
    case_54: /* CIL Label */ 
    {
#line 171
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 171
      if ((result & (unsigned long )(32 << 12)) != 0UL) {
        {
#line 171
        error_bad_range_arg(1);
        }
      }
#line 171
      result |= (unsigned long )(32 << 12);
#line 171
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 171
    goto switch_break;
    case_55: /* CIL Label */ 
    {
#line 172
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 172
      if ((result & (unsigned long )(8 << 12)) != 0UL) {
        {
#line 172
        error_bad_range_arg(1);
        }
      }
#line 172
      result |= (unsigned long )(8 << 12);
#line 172
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 172
    goto switch_break;
    case_56: /* CIL Label */ 
    {
#line 173
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 173
      if ((result & (unsigned long )(2 << 12)) != 0UL) {
        {
#line 173
        error_bad_range_arg(1);
        }
      }
#line 173
      result |= (unsigned long )(2 << 12);
#line 173
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 173
    goto switch_break;
    case_98: /* CIL Label */ 
    {
#line 177
    if ((unsigned int )((enum syntaxcode )(result & 15UL)) == 11U) {
#line 177
      goto case_11;
    }
#line 178
    if ((unsigned int )((enum syntaxcode )(result & 15UL)) == 12U) {
#line 178
      goto case_12;
    }
#line 179
    goto switch_default;
    case_11: /* CIL Label */ 
    {
#line 177
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 177
      if ((result & (unsigned long )(64 << 12)) != 0UL) {
        {
#line 177
        error_bad_range_arg(1);
        }
      }
#line 177
      result |= (unsigned long )(64 << 12);
#line 177
      goto while_break___10;
    }
    while_break___10: /* CIL Label */ ;
    }
#line 177
    goto switch_break___0;
    case_12: /* CIL Label */ 
    {
#line 178
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 178
      if ((result & (unsigned long )(4 << 12)) != 0UL) {
        {
#line 178
        error_bad_range_arg(1);
        }
      }
#line 178
      result |= (unsigned long )(4 << 12);
#line 178
      goto while_break___11;
    }
    while_break___11: /* CIL Label */ ;
    }
#line 178
    goto switch_break___0;
    switch_default: /* CIL Label */ 
#line 179
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 181
    goto switch_break;
    case_112: /* CIL Label */ 
    {
#line 182
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 182
      if ((result & (unsigned long )(1 << 20)) != 0UL) {
        {
#line 182
        error_bad_range_arg(1);
        }
      }
#line 182
      result |= (unsigned long )(1 << 20);
#line 182
      goto while_break___12;
    }
    while_break___12: /* CIL Label */ ;
    }
#line 182
    goto switch_break;
    case_32: /* CIL Label */ 
#line 183
    goto switch_break;
    switch_default___0: /* CIL Label */ 
    {
#line 184
    error_bad_range_arg(1);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 186
  if ((unsigned int )((enum syntaxcode )(result & 15UL)) == 11U) {
#line 186
    if (! (((result >> 12) & 255UL) & 192UL)) {
      {
#line 188
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 188
        if ((result & (unsigned long )(128 << 12)) != 0UL) {
          {
#line 188
          error_bad_range_arg(1);
          }
        }
#line 188
        result |= (unsigned long )(128 << 12);
#line 188
        goto while_break___13;
      }
      while_break___13: /* CIL Label */ ;
      }
    }
  }
#line 189
  if ((unsigned int )((enum syntaxcode )(result & 15UL)) == 12U) {
#line 189
    if (! (((result >> 12) & 255UL) & 12UL)) {
      {
#line 191
      while (1) {
        while_continue___14: /* CIL Label */ ;
#line 191
        if ((result & (unsigned long )(8 << 12)) != 0UL) {
          {
#line 191
          error_bad_range_arg(1);
          }
        }
#line 191
        result |= (unsigned long )(8 << 12);
#line 191
        goto while_break___14;
      }
      while_break___14: /* CIL Label */ ;
      }
    }
  }
#line 192
  return ((26UL << 58U) | result);
}
}
#line 195 "/home/khheo/project/mit-scheme-9.2/src/microcode/syntax.c"
SCHEME_OBJECT Prim_char_to_syntax_code(void) 
{ 
  long tmp ;

  {
  {
#line 197
  while (1) {
    while_continue: /* CIL Label */ ;
#line 197
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 198
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 198
    if (*(stack_pointer + 0) >> 58U == 10UL) {
#line 198
      if (! ((*((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 0) & 288230376151711743UL) == 256UL)) {
        {
#line 198
        error_wrong_type_arg(1);
        }
      }
    } else {
      {
#line 198
      error_wrong_type_arg(1);
      }
    }
#line 198
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 199
  tmp = arg_ascii_char(2);
  }
#line 199
  return ((2UL << 58U) | (unsigned long )syntax_code_spec[(int )((enum syntaxcode )(*((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + ((tmp & 255L) + 1L)) & 15UL))]);
}
}
#line 345 "/home/khheo/project/mit-scheme-9.2/src/microcode/syntax.c"
SCHEME_OBJECT Prim_quoted_char_p(void) 
{ 
  _Bool quoted ;
  unsigned char *gap_start ;
  unsigned char *gap_end ;
  SCHEME_OBJECT syntax_table ;
  SCHEME_OBJECT group ;
  unsigned char *start ;
  unsigned char *first_char ;
  unsigned char *end ;
  long gap_length ;
  long tmp ;
  long tmp___0 ;
  unsigned char *scan ;
  long sentry ;
  unsigned long tmp___1 ;

  {
  {
#line 348
  while (1) {
    while_continue: /* CIL Label */ ;
#line 348
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 348
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 348
    if (*(stack_pointer + 0) >> 58U == 10UL) {
#line 348
      if (! ((*((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 0) & 288230376151711743UL) == 256UL)) {
        {
#line 348
        error_wrong_type_arg(1);
        }
      }
    } else {
      {
#line 348
      error_wrong_type_arg(1);
      }
    }
#line 348
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 348
  syntax_table = *(stack_pointer + 0);
  {
#line 348
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 348
    if (! (*(stack_pointer + 1) >> 58U == 10UL)) {
      {
#line 348
      error_wrong_type_arg(2);
      }
    }
#line 348
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 348
  group = *(stack_pointer + 1);
#line 348
  first_char = lookup_external_string(*((SCHEME_OBJECT *)(group & 288230376151711743UL) + 2),
                                      (unsigned long *)0);
#line 348
  tmp = arg_nonnegative_integer(3);
#line 348
  start = first_char + tmp;
#line 348
  tmp___0 = arg_nonnegative_integer(4);
#line 348
  end = first_char + tmp___0;
#line 348
  gap_start = first_char + (*((SCHEME_OBJECT *)(group & 288230376151711743UL) + 3) & 288230376151711743UL);
#line 348
  gap_length = (long )(*((SCHEME_OBJECT *)(group & 288230376151711743UL) + 4) & 288230376151711743UL);
#line 348
  gap_end = first_char + (*((SCHEME_OBJECT *)(group & 288230376151711743UL) + 5) & 288230376151711743UL);
  }
#line 348
  if ((unsigned long )start > (unsigned long )gap_start) {
#line 348
    start += gap_length;
  }
#line 348
  if ((unsigned long )end > (unsigned long )gap_start) {
#line 348
    end += gap_length;
  }
  {
#line 350
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 350
    scan = start;
    {
#line 350
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 350
      quoted = (_Bool)0;
      {
#line 350
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 350
        if ((unsigned long )scan <= (unsigned long )end) {
#line 350
          goto while_break___4;
        }
        {
#line 350
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 350
          scan --;
#line 350
          sentry = (long )*((SCHEME_OBJECT *)(syntax_table & 288230376151711743UL) + (((int )*scan & 255) + 1));
#line 350
          if ((unsigned long )scan == (unsigned long )gap_end) {
#line 350
            scan = gap_start;
          }
#line 350
          goto while_break___5;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 350
        if (! ((unsigned int )((enum syntaxcode )(sentry & 15L)) == 9U)) {
#line 350
          if (! ((unsigned int )((enum syntaxcode )(sentry & 15L)) == 10U)) {
#line 350
            goto while_break___4;
          }
        }
#line 350
        quoted = (_Bool )(! quoted);
      }
      while_break___4: /* CIL Label */ ;
      }
#line 350
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 350
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 351
  if (quoted) {
#line 351
    tmp___1 = 8UL << 58U;
  } else {
#line 351
    tmp___1 = 0UL;
  }
#line 351
  return (tmp___1);
}
}
#line 357 "/home/khheo/project/mit-scheme-9.2/src/microcode/syntax.c"
SCHEME_OBJECT Prim_scan_backward_prefix_chars(void) 
{ 
  _Bool quoted ;
  unsigned char *gap_start ;
  unsigned char *gap_end ;
  SCHEME_OBJECT syntax_table ;
  SCHEME_OBJECT group ;
  unsigned char *start ;
  unsigned char *first_char ;
  unsigned char *end ;
  long gap_length ;
  long tmp ;
  long tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *scan ;
  long sentry ;
  unsigned char *tmp___2 ;
  long sentry___0 ;
  unsigned char *tmp___3 ;

  {
  {
#line 360
  while (1) {
    while_continue: /* CIL Label */ ;
#line 360
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 360
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 360
    if (*(stack_pointer + 0) >> 58U == 10UL) {
#line 360
      if (! ((*((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 0) & 288230376151711743UL) == 256UL)) {
        {
#line 360
        error_wrong_type_arg(1);
        }
      }
    } else {
      {
#line 360
      error_wrong_type_arg(1);
      }
    }
#line 360
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 360
  syntax_table = *(stack_pointer + 0);
  {
#line 360
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 360
    if (! (*(stack_pointer + 1) >> 58U == 10UL)) {
      {
#line 360
      error_wrong_type_arg(2);
      }
    }
#line 360
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 360
  group = *(stack_pointer + 1);
#line 360
  first_char = lookup_external_string(*((SCHEME_OBJECT *)(group & 288230376151711743UL) + 2),
                                      (unsigned long *)0);
#line 360
  tmp = arg_nonnegative_integer(3);
#line 360
  start = first_char + tmp;
#line 360
  tmp___0 = arg_nonnegative_integer(4);
#line 360
  end = first_char + tmp___0;
#line 360
  gap_start = first_char + (*((SCHEME_OBJECT *)(group & 288230376151711743UL) + 3) & 288230376151711743UL);
#line 360
  gap_length = (long )(*((SCHEME_OBJECT *)(group & 288230376151711743UL) + 4) & 288230376151711743UL);
#line 360
  gap_end = first_char + (*((SCHEME_OBJECT *)(group & 288230376151711743UL) + 5) & 288230376151711743UL);
  }
#line 360
  if ((unsigned long )start > (unsigned long )gap_start) {
#line 360
    start += gap_length;
  }
#line 360
  if ((unsigned long )end > (unsigned long )gap_start) {
#line 360
    end += gap_length;
  }
  {
#line 362
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 364
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 364
      if ((unsigned long )start <= (unsigned long )end) {
#line 364
        if ((unsigned long )start > (unsigned long )gap_start) {
#line 364
          tmp___1 = start - gap_length;
        } else {
#line 364
          tmp___1 = start;
        }
#line 364
        return ((26UL << 58U) | (unsigned long )(tmp___1 - first_char));
      }
#line 364
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 365
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 365
      scan = start;
      {
#line 365
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 365
        scan --;
#line 365
        if ((unsigned long )scan == (unsigned long )gap_end) {
#line 365
          scan = gap_start;
        }
#line 365
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 365
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 365
        quoted = (_Bool)0;
        {
#line 365
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 365
          if ((unsigned long )scan <= (unsigned long )end) {
#line 365
            goto while_break___7;
          }
          {
#line 365
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 365
            scan --;
#line 365
            sentry = (long )*((SCHEME_OBJECT *)(syntax_table & 288230376151711743UL) + (((int )*scan & 255) + 1));
#line 365
            if ((unsigned long )scan == (unsigned long )gap_end) {
#line 365
              scan = gap_start;
            }
#line 365
            goto while_break___8;
          }
          while_break___8: /* CIL Label */ ;
          }
#line 365
          if (! ((unsigned int )((enum syntaxcode )(sentry & 15L)) == 9U)) {
#line 365
            if (! ((unsigned int )((enum syntaxcode )(sentry & 15L)) == 10U)) {
#line 365
              goto while_break___7;
            }
          }
#line 365
          quoted = (_Bool )(! quoted);
        }
        while_break___7: /* CIL Label */ ;
        }
#line 365
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 365
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 366
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 366
      if (quoted) {
#line 366
        if ((unsigned long )start > (unsigned long )gap_start) {
#line 366
          tmp___2 = start - gap_length;
        } else {
#line 366
          tmp___2 = start;
        }
#line 366
        return ((26UL << 58U) | (unsigned long )(tmp___2 - first_char));
      }
#line 366
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 368
    sentry___0 = (long )*((SCHEME_OBJECT *)(syntax_table & 288230376151711743UL) + (((int )*(start + -1) & 255) + 1));
    {
#line 369
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 369
      if (! ((unsigned int )((enum syntaxcode )(sentry___0 & 15L)) == 6U)) {
#line 369
        if (! ((sentry___0 >> 20) & 1L)) {
#line 369
          if ((unsigned long )start > (unsigned long )gap_start) {
#line 369
            tmp___3 = start - gap_length;
          } else {
#line 369
            tmp___3 = start;
          }
#line 369
          return ((26UL << 58U) | (unsigned long )(tmp___3 - first_char));
        }
      }
#line 369
      goto while_break___10;
    }
    while_break___10: /* CIL Label */ ;
    }
    {
#line 372
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 372
      start --;
#line 372
      if ((unsigned long )start == (unsigned long )gap_end) {
#line 372
        start = gap_start;
      }
#line 372
      goto while_break___11;
    }
    while_break___11: /* CIL Label */ ;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
}
}
#line 376 "/home/khheo/project/mit-scheme-9.2/src/microcode/syntax.c"
SCHEME_OBJECT Prim_scan_forward_prefix_chars(void) 
{ 
  _Bool quoted ;
  unsigned char *gap_start ;
  unsigned char *gap_end ;
  SCHEME_OBJECT syntax_table ;
  SCHEME_OBJECT group ;
  unsigned char *start ;
  unsigned char *first_char ;
  unsigned char *end ;
  long gap_length ;
  long tmp ;
  long tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *scan ;
  long sentry ;
  unsigned char *tmp___2 ;
  long sentry___0 ;
  unsigned char *tmp___3 ;

  {
  {
#line 379
  while (1) {
    while_continue: /* CIL Label */ ;
#line 379
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 379
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 379
    if (*(stack_pointer + 0) >> 58U == 10UL) {
#line 379
      if (! ((*((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 0) & 288230376151711743UL) == 256UL)) {
        {
#line 379
        error_wrong_type_arg(1);
        }
      }
    } else {
      {
#line 379
      error_wrong_type_arg(1);
      }
    }
#line 379
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 379
  syntax_table = *(stack_pointer + 0);
  {
#line 379
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 379
    if (! (*(stack_pointer + 1) >> 58U == 10UL)) {
      {
#line 379
      error_wrong_type_arg(2);
      }
    }
#line 379
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 379
  group = *(stack_pointer + 1);
#line 379
  first_char = lookup_external_string(*((SCHEME_OBJECT *)(group & 288230376151711743UL) + 2),
                                      (unsigned long *)0);
#line 379
  tmp = arg_nonnegative_integer(3);
#line 379
  start = first_char + tmp;
#line 379
  tmp___0 = arg_nonnegative_integer(4);
#line 379
  end = first_char + tmp___0;
#line 379
  gap_start = first_char + (*((SCHEME_OBJECT *)(group & 288230376151711743UL) + 3) & 288230376151711743UL);
#line 379
  gap_length = (long )(*((SCHEME_OBJECT *)(group & 288230376151711743UL) + 4) & 288230376151711743UL);
#line 379
  gap_end = first_char + (*((SCHEME_OBJECT *)(group & 288230376151711743UL) + 5) & 288230376151711743UL);
  }
#line 379
  if ((unsigned long )start >= (unsigned long )gap_start) {
#line 379
    start += gap_length;
  }
#line 379
  if ((unsigned long )end >= (unsigned long )gap_start) {
#line 379
    end += gap_length;
  }
  {
#line 381
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 383
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 383
      if ((unsigned long )start >= (unsigned long )end) {
#line 383
        if ((unsigned long )start > (unsigned long )gap_start) {
#line 383
          tmp___1 = start - gap_length;
        } else {
#line 383
          tmp___1 = start;
        }
#line 383
        return ((26UL << 58U) | (unsigned long )(tmp___1 - first_char));
      }
#line 383
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 384
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 384
      scan = start;
      {
#line 384
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 384
        quoted = (_Bool)0;
        {
#line 384
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 384
          if ((unsigned long )scan <= (unsigned long )end) {
#line 384
            goto while_break___6;
          }
          {
#line 384
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 384
            scan --;
#line 384
            sentry = (long )*((SCHEME_OBJECT *)(syntax_table & 288230376151711743UL) + (((int )*scan & 255) + 1));
#line 384
            if ((unsigned long )scan == (unsigned long )gap_end) {
#line 384
              scan = gap_start;
            }
#line 384
            goto while_break___7;
          }
          while_break___7: /* CIL Label */ ;
          }
#line 384
          if (! ((unsigned int )((enum syntaxcode )(sentry & 15L)) == 9U)) {
#line 384
            if (! ((unsigned int )((enum syntaxcode )(sentry & 15L)) == 10U)) {
#line 384
              goto while_break___6;
            }
          }
#line 384
          quoted = (_Bool )(! quoted);
        }
        while_break___6: /* CIL Label */ ;
        }
#line 384
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 384
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 385
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 385
      if (quoted) {
#line 385
        if ((unsigned long )start > (unsigned long )gap_start) {
#line 385
          tmp___2 = start - gap_length;
        } else {
#line 385
          tmp___2 = start;
        }
#line 385
        return ((26UL << 58U) | (unsigned long )(tmp___2 - first_char));
      }
#line 385
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 387
    sentry___0 = (long )*((SCHEME_OBJECT *)(syntax_table & 288230376151711743UL) + (((int )*start & 255) + 1));
    {
#line 388
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 388
      if (! ((unsigned int )((enum syntaxcode )(sentry___0 & 15L)) == 6U)) {
#line 388
        if (! ((sentry___0 >> 20) & 1L)) {
#line 388
          if ((unsigned long )start > (unsigned long )gap_start) {
#line 388
            tmp___3 = start - gap_length;
          } else {
#line 388
            tmp___3 = start;
          }
#line 388
          return ((26UL << 58U) | (unsigned long )(tmp___3 - first_char));
        }
      }
#line 388
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
    {
#line 391
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 391
      start ++;
#line 391
      if ((unsigned long )start == (unsigned long )gap_start) {
#line 391
        start = gap_end;
      }
#line 391
      goto while_break___10;
    }
    while_break___10: /* CIL Label */ ;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
}
}
#line 397 "/home/khheo/project/mit-scheme-9.2/src/microcode/syntax.c"
SCHEME_OBJECT Prim_scan_forward_to_word(void) 
{ 
  unsigned char *gap_start ;
  unsigned char *gap_end ;
  SCHEME_OBJECT syntax_table ;
  SCHEME_OBJECT group ;
  unsigned char *start ;
  unsigned char *first_char ;
  unsigned char *end ;
  long gap_length ;
  long tmp ;
  long tmp___0 ;
  unsigned char *tmp___1 ;

  {
  {
#line 399
  while (1) {
    while_continue: /* CIL Label */ ;
#line 399
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 399
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 399
    if (*(stack_pointer + 0) >> 58U == 10UL) {
#line 399
      if (! ((*((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 0) & 288230376151711743UL) == 256UL)) {
        {
#line 399
        error_wrong_type_arg(1);
        }
      }
    } else {
      {
#line 399
      error_wrong_type_arg(1);
      }
    }
#line 399
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 399
  syntax_table = *(stack_pointer + 0);
  {
#line 399
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 399
    if (! (*(stack_pointer + 1) >> 58U == 10UL)) {
      {
#line 399
      error_wrong_type_arg(2);
      }
    }
#line 399
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 399
  group = *(stack_pointer + 1);
#line 399
  first_char = lookup_external_string(*((SCHEME_OBJECT *)(group & 288230376151711743UL) + 2),
                                      (unsigned long *)0);
#line 399
  tmp = arg_nonnegative_integer(3);
#line 399
  start = first_char + tmp;
#line 399
  tmp___0 = arg_nonnegative_integer(4);
#line 399
  end = first_char + tmp___0;
#line 399
  gap_start = first_char + (*((SCHEME_OBJECT *)(group & 288230376151711743UL) + 3) & 288230376151711743UL);
#line 399
  gap_length = (long )(*((SCHEME_OBJECT *)(group & 288230376151711743UL) + 4) & 288230376151711743UL);
#line 399
  gap_end = first_char + (*((SCHEME_OBJECT *)(group & 288230376151711743UL) + 5) & 288230376151711743UL);
  }
#line 399
  if ((unsigned long )start >= (unsigned long )gap_start) {
#line 399
    start += gap_length;
  }
#line 399
  if ((unsigned long )end >= (unsigned long )gap_start) {
#line 399
    end += gap_length;
  }
  {
#line 401
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 403
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 403
      if ((unsigned long )start >= (unsigned long )end) {
#line 403
        return (0UL);
      }
#line 403
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 404
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 404
      if ((unsigned int )((enum syntaxcode )(*((SCHEME_OBJECT *)(syntax_table & 288230376151711743UL) + (((int )*start & 255) + 1)) & 15UL)) == 2U) {
#line 404
        if ((unsigned long )start > (unsigned long )gap_start) {
#line 404
          tmp___1 = start - gap_length;
        } else {
#line 404
          tmp___1 = start;
        }
#line 404
        return ((26UL << 58U) | (unsigned long )(tmp___1 - first_char));
      }
#line 404
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 405
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 405
      start ++;
#line 405
      if ((unsigned long )start == (unsigned long )gap_start) {
#line 405
        start = gap_end;
      }
#line 405
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
}
}
#line 409 "/home/khheo/project/mit-scheme-9.2/src/microcode/syntax.c"
SCHEME_OBJECT Prim_scan_word_forward(void) 
{ 
  unsigned char *gap_start ;
  unsigned char *gap_end ;
  SCHEME_OBJECT syntax_table ;
  SCHEME_OBJECT group ;
  unsigned char *start ;
  unsigned char *first_char ;
  unsigned char *end ;
  long gap_length ;
  long tmp ;
  long tmp___0 ;
  long sentry ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;
  unsigned char *tmp___3 ;

  {
  {
#line 411
  while (1) {
    while_continue: /* CIL Label */ ;
#line 411
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 411
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 411
    if (*(stack_pointer + 0) >> 58U == 10UL) {
#line 411
      if (! ((*((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 0) & 288230376151711743UL) == 256UL)) {
        {
#line 411
        error_wrong_type_arg(1);
        }
      }
    } else {
      {
#line 411
      error_wrong_type_arg(1);
      }
    }
#line 411
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 411
  syntax_table = *(stack_pointer + 0);
  {
#line 411
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 411
    if (! (*(stack_pointer + 1) >> 58U == 10UL)) {
      {
#line 411
      error_wrong_type_arg(2);
      }
    }
#line 411
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 411
  group = *(stack_pointer + 1);
#line 411
  first_char = lookup_external_string(*((SCHEME_OBJECT *)(group & 288230376151711743UL) + 2),
                                      (unsigned long *)0);
#line 411
  tmp = arg_nonnegative_integer(3);
#line 411
  start = first_char + tmp;
#line 411
  tmp___0 = arg_nonnegative_integer(4);
#line 411
  end = first_char + tmp___0;
#line 411
  gap_start = first_char + (*((SCHEME_OBJECT *)(group & 288230376151711743UL) + 3) & 288230376151711743UL);
#line 411
  gap_length = (long )(*((SCHEME_OBJECT *)(group & 288230376151711743UL) + 4) & 288230376151711743UL);
#line 411
  gap_end = first_char + (*((SCHEME_OBJECT *)(group & 288230376151711743UL) + 5) & 288230376151711743UL);
  }
#line 411
  if ((unsigned long )start >= (unsigned long )gap_start) {
#line 411
    start += gap_length;
  }
#line 411
  if ((unsigned long )end >= (unsigned long )gap_start) {
#line 411
    end += gap_length;
  }
  {
#line 413
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 416
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 416
      if ((unsigned long )start >= (unsigned long )end) {
#line 416
        return (0UL);
      }
#line 416
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 417
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 417
      tmp___1 = start;
#line 417
      start ++;
#line 417
      sentry = (long )*((SCHEME_OBJECT *)(syntax_table & 288230376151711743UL) + (((int )*tmp___1 & 255) + 1));
#line 417
      if ((unsigned long )start == (unsigned long )gap_start) {
#line 417
        start = gap_end;
      }
#line 417
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 418
    if ((unsigned int )((enum syntaxcode )(sentry & 15L)) == 2U) {
#line 419
      goto while_break___2;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 421
  while (1) {
    while_continue___5: /* CIL Label */ ;
    {
#line 423
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 423
      if ((unsigned long )start >= (unsigned long )end) {
#line 423
        if ((unsigned long )start > (unsigned long )gap_start) {
#line 423
          tmp___2 = start - gap_length;
        } else {
#line 423
          tmp___2 = start;
        }
#line 423
        return ((26UL << 58U) | (unsigned long )(tmp___2 - first_char));
      }
#line 423
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
    {
#line 424
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 424
      if ((unsigned int )((enum syntaxcode )(*((SCHEME_OBJECT *)(syntax_table & 288230376151711743UL) + (((int )*start & 255) + 1)) & 15UL)) != 2U) {
#line 424
        if ((unsigned long )start > (unsigned long )gap_start) {
#line 424
          tmp___3 = start - gap_length;
        } else {
#line 424
          tmp___3 = start;
        }
#line 424
        return ((26UL << 58U) | (unsigned long )(tmp___3 - first_char));
      }
#line 424
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
    {
#line 425
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 425
      start ++;
#line 425
      if ((unsigned long )start == (unsigned long )gap_start) {
#line 425
        start = gap_end;
      }
#line 425
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
}
}
#line 429 "/home/khheo/project/mit-scheme-9.2/src/microcode/syntax.c"
SCHEME_OBJECT Prim_scan_word_backward(void) 
{ 
  unsigned char *gap_start ;
  unsigned char *gap_end ;
  SCHEME_OBJECT syntax_table ;
  SCHEME_OBJECT group ;
  unsigned char *start ;
  unsigned char *first_char ;
  unsigned char *end ;
  long gap_length ;
  long tmp ;
  long tmp___0 ;
  long sentry ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;

  {
  {
#line 431
  while (1) {
    while_continue: /* CIL Label */ ;
#line 431
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 431
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 431
    if (*(stack_pointer + 0) >> 58U == 10UL) {
#line 431
      if (! ((*((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 0) & 288230376151711743UL) == 256UL)) {
        {
#line 431
        error_wrong_type_arg(1);
        }
      }
    } else {
      {
#line 431
      error_wrong_type_arg(1);
      }
    }
#line 431
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 431
  syntax_table = *(stack_pointer + 0);
  {
#line 431
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 431
    if (! (*(stack_pointer + 1) >> 58U == 10UL)) {
      {
#line 431
      error_wrong_type_arg(2);
      }
    }
#line 431
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 431
  group = *(stack_pointer + 1);
#line 431
  first_char = lookup_external_string(*((SCHEME_OBJECT *)(group & 288230376151711743UL) + 2),
                                      (unsigned long *)0);
#line 431
  tmp = arg_nonnegative_integer(3);
#line 431
  start = first_char + tmp;
#line 431
  tmp___0 = arg_nonnegative_integer(4);
#line 431
  end = first_char + tmp___0;
#line 431
  gap_start = first_char + (*((SCHEME_OBJECT *)(group & 288230376151711743UL) + 3) & 288230376151711743UL);
#line 431
  gap_length = (long )(*((SCHEME_OBJECT *)(group & 288230376151711743UL) + 4) & 288230376151711743UL);
#line 431
  gap_end = first_char + (*((SCHEME_OBJECT *)(group & 288230376151711743UL) + 5) & 288230376151711743UL);
  }
#line 431
  if ((unsigned long )start > (unsigned long )gap_start) {
#line 431
    start += gap_length;
  }
#line 431
  if ((unsigned long )end > (unsigned long )gap_start) {
#line 431
    end += gap_length;
  }
  {
#line 433
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 436
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 436
      if ((unsigned long )start <= (unsigned long )end) {
#line 436
        return (0UL);
      }
#line 436
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 437
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 437
      start --;
#line 437
      sentry = (long )*((SCHEME_OBJECT *)(syntax_table & 288230376151711743UL) + (((int )*start & 255) + 1));
#line 437
      if ((unsigned long )start == (unsigned long )gap_end) {
#line 437
        start = gap_start;
      }
#line 437
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 438
    if ((unsigned int )((enum syntaxcode )(sentry & 15L)) == 2U) {
#line 439
      goto while_break___2;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 441
  while (1) {
    while_continue___5: /* CIL Label */ ;
    {
#line 443
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 443
      if ((unsigned long )start <= (unsigned long )end) {
#line 443
        if ((unsigned long )start > (unsigned long )gap_start) {
#line 443
          tmp___1 = start - gap_length;
        } else {
#line 443
          tmp___1 = start;
        }
#line 443
        return ((26UL << 58U) | (unsigned long )(tmp___1 - first_char));
      }
#line 443
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
    {
#line 444
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 444
      if ((unsigned int )((enum syntaxcode )(*((SCHEME_OBJECT *)(syntax_table & 288230376151711743UL) + (((int )*(start + -1) & 255) + 1)) & 15UL)) != 2U) {
#line 444
        if ((unsigned long )start > (unsigned long )gap_start) {
#line 444
          tmp___2 = start - gap_length;
        } else {
#line 444
          tmp___2 = start;
        }
#line 444
        return ((26UL << 58U) | (unsigned long )(tmp___2 - first_char));
      }
#line 444
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
    {
#line 445
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 445
      start --;
#line 445
      if ((unsigned long )start == (unsigned long )gap_end) {
#line 445
        start = gap_start;
      }
#line 445
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
}
}
#line 451 "/home/khheo/project/mit-scheme-9.2/src/microcode/syntax.c"
SCHEME_OBJECT Prim_scan_list_forward(void) 
{ 
  long depth ;
  long min_depth ;
  _Bool sexp_flag ;
  _Bool math_exit ;
  int c ;
  unsigned char *gap_start ;
  unsigned char *gap_end ;
  SCHEME_OBJECT syntax_table ;
  SCHEME_OBJECT group ;
  unsigned char *start ;
  unsigned char *first_char ;
  unsigned char *end ;
  long gap_length ;
  long tmp ;
  long tmp___0 ;
  long sentry ;
  unsigned char *tmp___1 ;
  unsigned int style ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  unsigned char *tmp___8 ;
  unsigned char *tmp___9 ;
  unsigned char *tmp___10 ;
  unsigned char *tmp___11 ;
  unsigned char *tmp___12 ;
  unsigned char *tmp___13 ;
  unsigned char *tmp___14 ;
  unsigned char *tmp___15 ;
  unsigned char *tmp___16 ;

  {
  {
#line 453
  while (1) {
    while_continue: /* CIL Label */ ;
#line 453
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 453
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 453
    if (*(stack_pointer + 0) >> 58U == 10UL) {
#line 453
      if (! ((*((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 0) & 288230376151711743UL) == 256UL)) {
        {
#line 453
        error_wrong_type_arg(1);
        }
      }
    } else {
      {
#line 453
      error_wrong_type_arg(1);
      }
    }
#line 453
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 453
  syntax_table = *(stack_pointer + 0);
  {
#line 453
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 453
    if (! (*(stack_pointer + 1) >> 58U == 10UL)) {
      {
#line 453
      error_wrong_type_arg(2);
      }
    }
#line 453
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 453
  group = *(stack_pointer + 1);
#line 453
  first_char = lookup_external_string(*((SCHEME_OBJECT *)(group & 288230376151711743UL) + 2),
                                      (unsigned long *)0);
#line 453
  tmp = arg_nonnegative_integer(3);
#line 453
  start = first_char + tmp;
#line 453
  tmp___0 = arg_nonnegative_integer(4);
#line 453
  end = first_char + tmp___0;
#line 453
  gap_start = first_char + (*((SCHEME_OBJECT *)(group & 288230376151711743UL) + 3) & 288230376151711743UL);
#line 453
  gap_length = (long )(*((SCHEME_OBJECT *)(group & 288230376151711743UL) + 4) & 288230376151711743UL);
#line 453
  gap_end = first_char + (*((SCHEME_OBJECT *)(group & 288230376151711743UL) + 5) & 288230376151711743UL);
  }
#line 453
  if ((unsigned long )start >= (unsigned long )gap_start) {
#line 453
    start += gap_length;
  }
#line 453
  if ((unsigned long )end >= (unsigned long )gap_start) {
#line 453
    end += gap_length;
  }
  {
#line 453
  depth = arg_integer(5);
  }
#line 453
  if (depth >= 0L) {
#line 453
    min_depth = 0L;
  } else {
#line 453
    min_depth = depth;
  }
#line 453
  sexp_flag = (_Bool )(*(stack_pointer + 5) != 0UL);
#line 453
  math_exit = (_Bool)0;
  {
#line 455
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 458
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 458
      if ((unsigned long )start >= (unsigned long )end) {
#line 458
        return (0UL);
      }
#line 458
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 459
    c = (int )*start;
    {
#line 460
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 460
      tmp___1 = start;
#line 460
      start ++;
#line 460
      sentry = (long )*((SCHEME_OBJECT *)(syntax_table & 288230376151711743UL) + (((int )*tmp___1 & 255) + 1));
#line 460
      if ((unsigned long )start == (unsigned long )gap_start) {
#line 460
        start = gap_end;
      }
#line 460
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 463
    style = 0U;
#line 464
    if ((unsigned int )((enum syntaxcode )(sentry & 15L)) == 11U) {
#line 465
      if ((((sentry >> 12) & 255L) & 192L) & 170L) {
#line 465
        tmp___2 = 170;
      } else {
#line 465
        tmp___2 = 0;
      }
#line 465
      if ((((sentry >> 12) & 255L) & 192L) & 85L) {
#line 465
        tmp___3 = 85;
      } else {
#line 465
        tmp___3 = 0;
      }
#line 465
      style = (unsigned int )(tmp___2 | tmp___3);
    } else
#line 466
    if (! ((unsigned long )start >= (unsigned long )end)) {
#line 468
      if ((((sentry >> 12) & 255L) & 192L) & 170L) {
#line 468
        tmp___4 = 170;
      } else {
#line 468
        tmp___4 = 0;
      }
#line 468
      if ((((sentry >> 12) & 255L) & 192L) & 85L) {
#line 468
        tmp___5 = 85;
      } else {
#line 468
        tmp___5 = 0;
      }
#line 468
      if ((((*((SCHEME_OBJECT *)(syntax_table & 288230376151711743UL) + (((int )*start & 255) + 1)) >> 12) & 255UL) & 48UL) & 170UL) {
#line 468
        tmp___6 = 170;
      } else {
#line 468
        tmp___6 = 0;
      }
#line 468
      if ((((*((SCHEME_OBJECT *)(syntax_table & 288230376151711743UL) + (((int )*start & 255) + 1)) >> 12) & 255UL) & 48UL) & 85UL) {
#line 468
        tmp___7 = 85;
      } else {
#line 468
        tmp___7 = 0;
      }
#line 468
      style = (unsigned int )((tmp___4 | tmp___5) & (tmp___6 | tmp___7));
#line 472
      if (style != 0U) {
        {
#line 473
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 473
          start ++;
#line 473
          if ((unsigned long )start == (unsigned long )gap_start) {
#line 473
            start = gap_end;
          }
#line 473
          goto while_break___5;
        }
        while_break___5: /* CIL Label */ ;
        }
      }
    }
#line 475
    if (style != 0U) {
      {
#line 477
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 477
        if ((unsigned long )start >= (unsigned long )end) {
#line 477
          return (0UL);
        }
#line 477
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 478
      while (1) {
        while_continue___7: /* CIL Label */ ;
        {
#line 480
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 480
          tmp___8 = start;
#line 480
          start ++;
#line 480
          sentry = (long )*((SCHEME_OBJECT *)(syntax_table & 288230376151711743UL) + (((int )*tmp___8 & 255) + 1));
#line 480
          if ((unsigned long )start == (unsigned long )gap_start) {
#line 480
            start = gap_end;
          }
#line 480
          goto while_break___8;
        }
        while_break___8: /* CIL Label */ ;
        }
#line 481
        if ((((sentry >> 12) & 255L) & 12L) & (long )style) {
#line 485
          if ((unsigned int )((enum syntaxcode )(sentry & 15L)) == 12U) {
#line 487
            goto while_break___7;
          }
          {
#line 488
          while (1) {
            while_continue___9: /* CIL Label */ ;
#line 488
            if ((unsigned long )start >= (unsigned long )end) {
#line 488
              return (0UL);
            }
#line 488
            goto while_break___9;
          }
          while_break___9: /* CIL Label */ ;
          }
#line 489
          if ((((*((SCHEME_OBJECT *)(syntax_table & 288230376151711743UL) + (((int )*start & 255) + 1)) >> 12) & 255UL) & 3UL) & (unsigned long )style) {
            {
#line 493
            while (1) {
              while_continue___10: /* CIL Label */ ;
#line 493
              start ++;
#line 493
              if ((unsigned long )start == (unsigned long )gap_start) {
#line 493
                start = gap_end;
              }
#line 493
              goto while_break___10;
            }
            while_break___10: /* CIL Label */ ;
            }
#line 494
            goto while_break___7;
          }
        }
      }
      while_break___7: /* CIL Label */ ;
      }
#line 498
      goto while_continue___2;
    }
#line 501
    if ((sentry >> 20) & 1L) {
#line 502
      goto while_continue___2;
    }
    {
#line 507
    if ((unsigned int )((enum syntaxcode )(sentry & 15L)) == 10U) {
#line 507
      goto case_10;
    }
#line 507
    if ((unsigned int )((enum syntaxcode )(sentry & 15L)) == 9U) {
#line 507
      goto case_10;
    }
#line 512
    if ((unsigned int )((enum syntaxcode )(sentry & 15L)) == 3U) {
#line 512
      goto case_3;
    }
#line 512
    if ((unsigned int )((enum syntaxcode )(sentry & 15L)) == 2U) {
#line 512
      goto case_3;
    }
#line 535
    if ((unsigned int )((enum syntaxcode )(sentry & 15L)) == 8U) {
#line 535
      goto case_8;
    }
#line 553
    if ((unsigned int )((enum syntaxcode )(sentry & 15L)) == 4U) {
#line 553
      goto case_4;
    }
#line 557
    if ((unsigned int )((enum syntaxcode )(sentry & 15L)) == 5U) {
#line 557
      goto case_5;
    }
#line 562
    if ((unsigned int )((enum syntaxcode )(sentry & 15L)) == 7U) {
#line 562
      goto case_7;
    }
#line 579
    goto switch_default___0;
    case_10: /* CIL Label */ 
    case_9: /* CIL Label */ 
    {
#line 508
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 508
      if ((unsigned long )start >= (unsigned long )end) {
#line 508
        return (0UL);
      }
#line 508
      goto while_break___11;
    }
    while_break___11: /* CIL Label */ ;
    }
    {
#line 509
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 509
      start ++;
#line 509
      if ((unsigned long )start == (unsigned long )gap_start) {
#line 509
        start = gap_end;
      }
#line 509
      goto while_break___12;
    }
    while_break___12: /* CIL Label */ ;
    }
    case_3: /* CIL Label */ 
    case_2: /* CIL Label */ 
#line 513
    if (depth != 0L) {
#line 514
      goto switch_break;
    } else
#line 513
    if (! sexp_flag) {
#line 514
      goto switch_break;
    }
    {
#line 515
    while (1) {
      while_continue___13: /* CIL Label */ ;
      {
#line 517
      while (1) {
        while_continue___14: /* CIL Label */ ;
#line 517
        if ((unsigned long )start >= (unsigned long )end) {
#line 517
          if ((unsigned long )start > (unsigned long )gap_start) {
#line 517
            tmp___9 = start - gap_length;
          } else {
#line 517
            tmp___9 = start;
          }
#line 517
          return ((26UL << 58U) | (unsigned long )(tmp___9 - first_char));
        }
#line 517
        goto while_break___14;
      }
      while_break___14: /* CIL Label */ ;
      }
      {
#line 521
      if ((unsigned int )((enum syntaxcode )(*((SCHEME_OBJECT *)(syntax_table & 288230376151711743UL) + (((int )*start & 255) + 1)) & 15UL)) == 10U) {
#line 521
        goto case_10___0;
      }
#line 521
      if ((unsigned int )((enum syntaxcode )(*((SCHEME_OBJECT *)(syntax_table & 288230376151711743UL) + (((int )*start & 255) + 1)) & 15UL)) == 9U) {
#line 521
        goto case_10___0;
      }
#line 526
      if ((unsigned int )((enum syntaxcode )(*((SCHEME_OBJECT *)(syntax_table & 288230376151711743UL) + (((int )*start & 255) + 1)) & 15UL)) == 3U) {
#line 526
        goto case_3___0;
      }
#line 526
      if ((unsigned int )((enum syntaxcode )(*((SCHEME_OBJECT *)(syntax_table & 288230376151711743UL) + (((int )*start & 255) + 1)) & 15UL)) == 2U) {
#line 526
        goto case_3___0;
      }
#line 530
      goto switch_default;
      case_10___0: /* CIL Label */ 
      case_9___0: /* CIL Label */ 
      {
#line 522
      while (1) {
        while_continue___15: /* CIL Label */ ;
#line 522
        start ++;
#line 522
        if ((unsigned long )start == (unsigned long )gap_start) {
#line 522
          start = gap_end;
        }
#line 522
        goto while_break___15;
      }
      while_break___15: /* CIL Label */ ;
      }
      {
#line 523
      while (1) {
        while_continue___16: /* CIL Label */ ;
#line 523
        if ((unsigned long )start >= (unsigned long )end) {
#line 523
          return (0UL);
        }
#line 523
        goto while_break___16;
      }
      while_break___16: /* CIL Label */ ;
      }
      case_3___0: /* CIL Label */ 
      case_2___0: /* CIL Label */ 
      {
#line 527
      while (1) {
        while_continue___17: /* CIL Label */ ;
#line 527
        start ++;
#line 527
        if ((unsigned long )start == (unsigned long )gap_start) {
#line 527
          start = gap_end;
        }
#line 527
        goto while_break___17;
      }
      while_break___17: /* CIL Label */ ;
      }
#line 528
      goto switch_break___0;
      switch_default: /* CIL Label */ 
      {
#line 531
      while (1) {
        while_continue___18: /* CIL Label */ ;
#line 531
        if ((unsigned long )start > (unsigned long )gap_start) {
#line 531
          tmp___10 = start - gap_length;
        } else {
#line 531
          tmp___10 = start;
        }
#line 531
        return ((26UL << 58U) | (unsigned long )(tmp___10 - first_char));
#line 531
        goto while_break___18;
      }
      while_break___18: /* CIL Label */ ;
      }
      switch_break___0: /* CIL Label */ ;
      }
    }
    while_break___13: /* CIL Label */ ;
    }
    case_8: /* CIL Label */ 
#line 536
    if (! sexp_flag) {
#line 537
      goto switch_break;
    }
#line 538
    if (! ((unsigned long )start >= (unsigned long )end)) {
#line 538
      if (c == (int )*start) {
        {
#line 539
        while (1) {
          while_continue___19: /* CIL Label */ ;
#line 539
          start ++;
#line 539
          if ((unsigned long )start == (unsigned long )gap_start) {
#line 539
            start = gap_end;
          }
#line 539
          goto while_break___19;
        }
        while_break___19: /* CIL Label */ ;
        }
      }
    }
#line 540
    if (math_exit) {
      {
#line 542
      while (1) {
        while_continue___20: /* CIL Label */ ;
#line 542
        depth --;
#line 542
        if (depth == 0L) {
#line 542
          if ((unsigned long )start > (unsigned long )gap_start) {
#line 542
            tmp___11 = start - gap_length;
          } else {
#line 542
            tmp___11 = start;
          }
#line 542
          return ((26UL << 58U) | (unsigned long )(tmp___11 - first_char));
        }
#line 542
        goto while_break___20;
      }
      while_break___20: /* CIL Label */ ;
      }
      {
#line 543
      while (1) {
        while_continue___21: /* CIL Label */ ;
#line 543
        if (depth < min_depth) {
#line 543
          return (0UL);
        }
#line 543
        goto while_break___21;
      }
      while_break___21: /* CIL Label */ ;
      }
#line 544
      math_exit = (_Bool)0;
    } else {
      {
#line 548
      while (1) {
        while_continue___22: /* CIL Label */ ;
#line 548
        depth ++;
#line 548
        if (depth == 0L) {
#line 548
          if ((unsigned long )start > (unsigned long )gap_start) {
#line 548
            tmp___12 = start - gap_length;
          } else {
#line 548
            tmp___12 = start;
          }
#line 548
          return ((26UL << 58U) | (unsigned long )(tmp___12 - first_char));
        }
#line 548
        goto while_break___22;
      }
      while_break___22: /* CIL Label */ ;
      }
#line 549
      math_exit = (_Bool)1;
    }
#line 551
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 554
    while (1) {
      while_continue___23: /* CIL Label */ ;
#line 554
      depth ++;
#line 554
      if (depth == 0L) {
#line 554
        if ((unsigned long )start > (unsigned long )gap_start) {
#line 554
          tmp___13 = start - gap_length;
        } else {
#line 554
          tmp___13 = start;
        }
#line 554
        return ((26UL << 58U) | (unsigned long )(tmp___13 - first_char));
      }
#line 554
      goto while_break___23;
    }
    while_break___23: /* CIL Label */ ;
    }
#line 555
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 558
    while (1) {
      while_continue___24: /* CIL Label */ ;
#line 558
      depth --;
#line 558
      if (depth == 0L) {
#line 558
        if ((unsigned long )start > (unsigned long )gap_start) {
#line 558
          tmp___14 = start - gap_length;
        } else {
#line 558
          tmp___14 = start;
        }
#line 558
        return ((26UL << 58U) | (unsigned long )(tmp___14 - first_char));
      }
#line 558
      goto while_break___24;
    }
    while_break___24: /* CIL Label */ ;
    }
    {
#line 559
    while (1) {
      while_continue___25: /* CIL Label */ ;
#line 559
      if (depth < min_depth) {
#line 559
        return (0UL);
      }
#line 559
      goto while_break___25;
    }
    while_break___25: /* CIL Label */ ;
    }
#line 560
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 563
    while (1) {
      while_continue___26: /* CIL Label */ ;
      {
#line 565
      while (1) {
        while_continue___27: /* CIL Label */ ;
#line 565
        if ((unsigned long )start >= (unsigned long )end) {
#line 565
          return (0UL);
        }
#line 565
        goto while_break___27;
      }
      while_break___27: /* CIL Label */ ;
      }
#line 566
      if (c == (int )*start) {
#line 567
        goto while_break___26;
      }
      {
#line 568
      while (1) {
        while_continue___28: /* CIL Label */ ;
#line 568
        tmp___15 = start;
#line 568
        start ++;
#line 568
        sentry = (long )*((SCHEME_OBJECT *)(syntax_table & 288230376151711743UL) + (((int )*tmp___15 & 255) + 1));
#line 568
        if ((unsigned long )start == (unsigned long )gap_start) {
#line 568
          start = gap_end;
        }
#line 568
        goto while_break___28;
      }
      while_break___28: /* CIL Label */ ;
      }
#line 569
      if ((unsigned int )((enum syntaxcode )(sentry & 15L)) == 9U) {
#line 569
        goto _L;
      } else
#line 569
      if ((unsigned int )((enum syntaxcode )(sentry & 15L)) == 10U) {
        _L: /* CIL Label */ 
        {
#line 571
        while (1) {
          while_continue___29: /* CIL Label */ ;
#line 571
          if ((unsigned long )start >= (unsigned long )end) {
#line 571
            return (0UL);
          }
#line 571
          goto while_break___29;
        }
        while_break___29: /* CIL Label */ ;
        }
        {
#line 572
        while (1) {
          while_continue___30: /* CIL Label */ ;
#line 572
          start ++;
#line 572
          if ((unsigned long )start == (unsigned long )gap_start) {
#line 572
            start = gap_end;
          }
#line 572
          goto while_break___30;
        }
        while_break___30: /* CIL Label */ ;
        }
      }
    }
    while_break___26: /* CIL Label */ ;
    }
    {
#line 575
    while (1) {
      while_continue___31: /* CIL Label */ ;
#line 575
      start ++;
#line 575
      if ((unsigned long )start == (unsigned long )gap_start) {
#line 575
        start = gap_end;
      }
#line 575
      goto while_break___31;
    }
    while_break___31: /* CIL Label */ ;
    }
    {
#line 576
    while (1) {
      while_continue___32: /* CIL Label */ ;
#line 576
      if (depth == 0L) {
#line 576
        if (sexp_flag) {
#line 576
          if ((unsigned long )start > (unsigned long )gap_start) {
#line 576
            tmp___16 = start - gap_length;
          } else {
#line 576
            tmp___16 = start;
          }
#line 576
          return ((26UL << 58U) | (unsigned long )(tmp___16 - first_char));
        }
      }
#line 576
      goto while_break___32;
    }
    while_break___32: /* CIL Label */ ;
    }
#line 577
    goto switch_break;
    switch_default___0: /* CIL Label */ 
#line 580
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
}
}
#line 585 "/home/khheo/project/mit-scheme-9.2/src/microcode/syntax.c"
SCHEME_OBJECT Prim_scan_list_backward(void) 
{ 
  _Bool quoted ;
  _Bool ignore_comments ;
  long depth ;
  long min_depth ;
  _Bool sexp_flag ;
  _Bool math_exit ;
  int c ;
  unsigned char *gap_start ;
  unsigned char *gap_end ;
  SCHEME_OBJECT syntax_table ;
  SCHEME_OBJECT group ;
  unsigned char *start ;
  unsigned char *first_char ;
  unsigned char *end ;
  long gap_length ;
  long tmp ;
  long tmp___0 ;
  long sentry ;
  unsigned char *scan ;
  long sentry___0 ;
  unsigned int style ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned char *scan___0 ;
  long sentry___1 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  unsigned char *tmp___7 ;
  unsigned char *scan___1 ;
  long sentry___2 ;
  unsigned char *tmp___8 ;
  unsigned char *tmp___9 ;
  unsigned char *tmp___10 ;
  unsigned char *tmp___11 ;
  unsigned char *tmp___12 ;
  unsigned char *scan___2 ;
  long sentry___3 ;
  unsigned char *tmp___13 ;

  {
#line 588
  ignore_comments = (_Bool )(*(stack_pointer + 6) != 0UL);
  {
#line 589
  while (1) {
    while_continue: /* CIL Label */ ;
#line 589
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 589
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 589
    if (*(stack_pointer + 0) >> 58U == 10UL) {
#line 589
      if (! ((*((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 0) & 288230376151711743UL) == 256UL)) {
        {
#line 589
        error_wrong_type_arg(1);
        }
      }
    } else {
      {
#line 589
      error_wrong_type_arg(1);
      }
    }
#line 589
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 589
  syntax_table = *(stack_pointer + 0);
  {
#line 589
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 589
    if (! (*(stack_pointer + 1) >> 58U == 10UL)) {
      {
#line 589
      error_wrong_type_arg(2);
      }
    }
#line 589
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 589
  group = *(stack_pointer + 1);
#line 589
  first_char = lookup_external_string(*((SCHEME_OBJECT *)(group & 288230376151711743UL) + 2),
                                      (unsigned long *)0);
#line 589
  tmp = arg_nonnegative_integer(3);
#line 589
  start = first_char + tmp;
#line 589
  tmp___0 = arg_nonnegative_integer(4);
#line 589
  end = first_char + tmp___0;
#line 589
  gap_start = first_char + (*((SCHEME_OBJECT *)(group & 288230376151711743UL) + 3) & 288230376151711743UL);
#line 589
  gap_length = (long )(*((SCHEME_OBJECT *)(group & 288230376151711743UL) + 4) & 288230376151711743UL);
#line 589
  gap_end = first_char + (*((SCHEME_OBJECT *)(group & 288230376151711743UL) + 5) & 288230376151711743UL);
  }
#line 589
  if ((unsigned long )start > (unsigned long )gap_start) {
#line 589
    start += gap_length;
  }
#line 589
  if ((unsigned long )end > (unsigned long )gap_start) {
#line 589
    end += gap_length;
  }
  {
#line 589
  depth = arg_integer(5);
  }
#line 589
  if (depth >= 0L) {
#line 589
    min_depth = 0L;
  } else {
#line 589
    min_depth = depth;
  }
#line 589
  sexp_flag = (_Bool )(*(stack_pointer + 5) != 0UL);
#line 589
  math_exit = (_Bool)0;
  {
#line 591
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 594
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 594
      if ((unsigned long )start <= (unsigned long )end) {
#line 594
        return (0UL);
      }
#line 594
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 595
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 595
      scan = start;
      {
#line 595
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 595
        scan --;
#line 595
        if ((unsigned long )scan == (unsigned long )gap_end) {
#line 595
          scan = gap_start;
        }
#line 595
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 595
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 595
        quoted = (_Bool)0;
        {
#line 595
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 595
          if ((unsigned long )scan <= (unsigned long )end) {
#line 595
            goto while_break___7;
          }
          {
#line 595
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 595
            scan --;
#line 595
            sentry___0 = (long )*((SCHEME_OBJECT *)(syntax_table & 288230376151711743UL) + (((int )*scan & 255) + 1));
#line 595
            if ((unsigned long )scan == (unsigned long )gap_end) {
#line 595
              scan = gap_start;
            }
#line 595
            goto while_break___8;
          }
          while_break___8: /* CIL Label */ ;
          }
#line 595
          if (! ((unsigned int )((enum syntaxcode )(sentry___0 & 15L)) == 9U)) {
#line 595
            if (! ((unsigned int )((enum syntaxcode )(sentry___0 & 15L)) == 10U)) {
#line 595
              goto while_break___7;
            }
          }
#line 595
          quoted = (_Bool )(! quoted);
        }
        while_break___7: /* CIL Label */ ;
        }
#line 595
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 595
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 596
    if (quoted) {
      {
#line 598
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 598
        start --;
#line 598
        if ((unsigned long )start == (unsigned long )gap_end) {
#line 598
          start = gap_start;
        }
#line 598
        goto while_break___9;
      }
      while_break___9: /* CIL Label */ ;
      }
      {
#line 600
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 600
        start --;
#line 600
        sentry = (long )*((SCHEME_OBJECT *)(syntax_table & 288230376151711743UL) + (((int )*start & 255) + 1));
#line 600
        if ((unsigned long )start == (unsigned long )gap_end) {
#line 600
          start = gap_start;
        }
#line 600
        goto while_break___10;
      }
      while_break___10: /* CIL Label */ ;
      }
#line 601
      goto word_entry;
    }
#line 603
    c = (int )*(start + -1);
    {
#line 604
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 604
      start --;
#line 604
      sentry = (long )*((SCHEME_OBJECT *)(syntax_table & 288230376151711743UL) + (((int )*start & 255) + 1));
#line 604
      if ((unsigned long )start == (unsigned long )gap_end) {
#line 604
        start = gap_start;
      }
#line 604
      goto while_break___11;
    }
    while_break___11: /* CIL Label */ ;
    }
#line 607
    style = 0U;
#line 608
    if ((unsigned int )((enum syntaxcode )(sentry & 15L)) == 12U) {
#line 610
      if (ignore_comments) {
#line 611
        if ((((sentry >> 12) & 255L) & 3L) & 170L) {
#line 611
          tmp___1 = 170;
        } else {
#line 611
          tmp___1 = 0;
        }
#line 611
        if ((((sentry >> 12) & 255L) & 3L) & 85L) {
#line 611
          tmp___2 = 85;
        } else {
#line 611
          tmp___2 = 0;
        }
#line 611
        style = (unsigned int )(tmp___1 | tmp___2);
      }
    } else
#line 613
    if (! ((unsigned long )start <= (unsigned long )end)) {
      {
#line 615
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 615
        scan___0 = start;
        {
#line 615
        while (1) {
          while_continue___13: /* CIL Label */ ;
#line 615
          scan___0 --;
#line 615
          if ((unsigned long )scan___0 == (unsigned long )gap_end) {
#line 615
            scan___0 = gap_start;
          }
#line 615
          goto while_break___13;
        }
        while_break___13: /* CIL Label */ ;
        }
        {
#line 615
        while (1) {
          while_continue___14: /* CIL Label */ ;
#line 615
          quoted = (_Bool)0;
          {
#line 615
          while (1) {
            while_continue___15: /* CIL Label */ ;
#line 615
            if ((unsigned long )scan___0 <= (unsigned long )end) {
#line 615
              goto while_break___15;
            }
            {
#line 615
            while (1) {
              while_continue___16: /* CIL Label */ ;
#line 615
              scan___0 --;
#line 615
              sentry___1 = (long )*((SCHEME_OBJECT *)(syntax_table & 288230376151711743UL) + (((int )*scan___0 & 255) + 1));
#line 615
              if ((unsigned long )scan___0 == (unsigned long )gap_end) {
#line 615
                scan___0 = gap_start;
              }
#line 615
              goto while_break___16;
            }
            while_break___16: /* CIL Label */ ;
            }
#line 615
            if (! ((unsigned int )((enum syntaxcode )(sentry___1 & 15L)) == 9U)) {
#line 615
              if (! ((unsigned int )((enum syntaxcode )(sentry___1 & 15L)) == 10U)) {
#line 615
                goto while_break___15;
              }
            }
#line 615
            quoted = (_Bool )(! quoted);
          }
          while_break___15: /* CIL Label */ ;
          }
#line 615
          goto while_break___14;
        }
        while_break___14: /* CIL Label */ ;
        }
#line 615
        goto while_break___12;
      }
      while_break___12: /* CIL Label */ ;
      }
#line 616
      if (! quoted) {
#line 618
        if ((((sentry >> 12) & 255L) & 3L) & 170L) {
#line 618
          tmp___3 = 170;
        } else {
#line 618
          tmp___3 = 0;
        }
#line 618
        if ((((sentry >> 12) & 255L) & 3L) & 85L) {
#line 618
          tmp___4 = 85;
        } else {
#line 618
          tmp___4 = 0;
        }
#line 618
        if ((((*((SCHEME_OBJECT *)(syntax_table & 288230376151711743UL) + (((int )*(start + -1) & 255) + 1)) >> 12) & 255UL) & 12UL) & 170UL) {
#line 618
          tmp___5 = 170;
        } else {
#line 618
          tmp___5 = 0;
        }
#line 618
        if ((((*((SCHEME_OBJECT *)(syntax_table & 288230376151711743UL) + (((int )*(start + -1) & 255) + 1)) >> 12) & 255UL) & 12UL) & 85UL) {
#line 618
          tmp___6 = 85;
        } else {
#line 618
          tmp___6 = 0;
        }
#line 618
        style = (unsigned int )((tmp___3 | tmp___4) & (tmp___5 | tmp___6));
#line 622
        if (style != 0U) {
          {
#line 623
          while (1) {
            while_continue___17: /* CIL Label */ ;
#line 623
            start --;
#line 623
            if ((unsigned long )start == (unsigned long )gap_end) {
#line 623
              start = gap_start;
            }
#line 623
            goto while_break___17;
          }
          while_break___17: /* CIL Label */ ;
          }
        }
      }
    }
#line 626
    if (style != 0U) {
      {
#line 628
      while (1) {
        while_continue___18: /* CIL Label */ ;
#line 628
        if ((unsigned long )start <= (unsigned long )end) {
#line 628
          return (0UL);
        }
#line 628
        goto while_break___18;
      }
      while_break___18: /* CIL Label */ ;
      }
      {
#line 629
      while (1) {
        while_continue___19: /* CIL Label */ ;
        {
#line 631
        while (1) {
          while_continue___20: /* CIL Label */ ;
#line 631
          start --;
#line 631
          sentry = (long )*((SCHEME_OBJECT *)(syntax_table & 288230376151711743UL) + (((int )*start & 255) + 1));
#line 631
          if ((unsigned long )start == (unsigned long )gap_end) {
#line 631
            start = gap_start;
          }
#line 631
          goto while_break___20;
        }
        while_break___20: /* CIL Label */ ;
        }
#line 632
        if ((unsigned int )((enum syntaxcode )(sentry & 15L)) == 11U) {
#line 632
          if ((((sentry >> 12) & 255L) & 192L) & (long )style) {
#line 636
            goto while_break___19;
          }
        }
        {
#line 637
        while (1) {
          while_continue___21: /* CIL Label */ ;
#line 637
          if ((unsigned long )start <= (unsigned long )end) {
#line 637
            return (0UL);
          }
#line 637
          goto while_break___21;
        }
        while_break___21: /* CIL Label */ ;
        }
#line 638
        if ((((sentry >> 12) & 255L) & 48L) & (long )style) {
#line 638
          if ((((*((SCHEME_OBJECT *)(syntax_table & 288230376151711743UL) + (((int )*(start + -1) & 255) + 1)) >> 12) & 255UL) & 192UL) & (unsigned long )style) {
            {
#line 645
            while (1) {
              while_continue___22: /* CIL Label */ ;
#line 645
              start --;
#line 645
              if ((unsigned long )start == (unsigned long )gap_end) {
#line 645
                start = gap_start;
              }
#line 645
              goto while_break___22;
            }
            while_break___22: /* CIL Label */ ;
            }
#line 646
            goto while_break___19;
          }
        }
      }
      while_break___19: /* CIL Label */ ;
      }
#line 649
      goto while_continue___2;
    }
    {
#line 656
    if ((unsigned int )((enum syntaxcode )(sentry & 15L)) == 3U) {
#line 656
      goto word_entry;
    }
#line 656
    if ((unsigned int )((enum syntaxcode )(sentry & 15L)) == 2U) {
#line 656
      goto word_entry;
    }
#line 675
    if ((unsigned int )((enum syntaxcode )(sentry & 15L)) == 8U) {
#line 675
      goto case_8;
    }
#line 693
    if ((unsigned int )((enum syntaxcode )(sentry & 15L)) == 5U) {
#line 693
      goto case_5;
    }
#line 697
    if ((unsigned int )((enum syntaxcode )(sentry & 15L)) == 4U) {
#line 697
      goto case_4;
    }
#line 702
    if ((unsigned int )((enum syntaxcode )(sentry & 15L)) == 7U) {
#line 702
      goto case_7;
    }
#line 715
    goto switch_default;
    word_entry: 
    case_3: /* CIL Label */ 
    case_2: /* CIL Label */ 
#line 658
    if (depth != 0L) {
#line 659
      goto switch_break;
    } else
#line 658
    if (! sexp_flag) {
#line 659
      goto switch_break;
    }
    {
#line 660
    while (1) {
      while_continue___23: /* CIL Label */ ;
      {
#line 662
      while (1) {
        while_continue___24: /* CIL Label */ ;
#line 662
        if ((unsigned long )start <= (unsigned long )end) {
#line 662
          if ((unsigned long )start > (unsigned long )gap_start) {
#line 662
            tmp___7 = start - gap_length;
          } else {
#line 662
            tmp___7 = start;
          }
#line 662
          return ((26UL << 58U) | (unsigned long )(tmp___7 - first_char));
        }
#line 662
        goto while_break___24;
      }
      while_break___24: /* CIL Label */ ;
      }
      {
#line 663
      while (1) {
        while_continue___25: /* CIL Label */ ;
#line 663
        scan___1 = start;
        {
#line 663
        while (1) {
          while_continue___26: /* CIL Label */ ;
#line 663
          scan___1 --;
#line 663
          if ((unsigned long )scan___1 == (unsigned long )gap_end) {
#line 663
            scan___1 = gap_start;
          }
#line 663
          goto while_break___26;
        }
        while_break___26: /* CIL Label */ ;
        }
        {
#line 663
        while (1) {
          while_continue___27: /* CIL Label */ ;
#line 663
          quoted = (_Bool)0;
          {
#line 663
          while (1) {
            while_continue___28: /* CIL Label */ ;
#line 663
            if ((unsigned long )scan___1 <= (unsigned long )end) {
#line 663
              goto while_break___28;
            }
            {
#line 663
            while (1) {
              while_continue___29: /* CIL Label */ ;
#line 663
              scan___1 --;
#line 663
              sentry___2 = (long )*((SCHEME_OBJECT *)(syntax_table & 288230376151711743UL) + (((int )*scan___1 & 255) + 1));
#line 663
              if ((unsigned long )scan___1 == (unsigned long )gap_end) {
#line 663
                scan___1 = gap_start;
              }
#line 663
              goto while_break___29;
            }
            while_break___29: /* CIL Label */ ;
            }
#line 663
            if (! ((unsigned int )((enum syntaxcode )(sentry___2 & 15L)) == 9U)) {
#line 663
              if (! ((unsigned int )((enum syntaxcode )(sentry___2 & 15L)) == 10U)) {
#line 663
                goto while_break___28;
              }
            }
#line 663
            quoted = (_Bool )(! quoted);
          }
          while_break___28: /* CIL Label */ ;
          }
#line 663
          goto while_break___27;
        }
        while_break___27: /* CIL Label */ ;
        }
#line 663
        goto while_break___25;
      }
      while_break___25: /* CIL Label */ ;
      }
#line 664
      if (quoted) {
        {
#line 665
        while (1) {
          while_continue___30: /* CIL Label */ ;
#line 665
          start --;
#line 665
          if ((unsigned long )start == (unsigned long )gap_end) {
#line 665
            start = gap_start;
          }
#line 665
          goto while_break___30;
        }
        while_break___30: /* CIL Label */ ;
        }
      } else {
#line 668
        sentry = (long )*((SCHEME_OBJECT *)(syntax_table & 288230376151711743UL) + (((int )*(start + -1) & 255) + 1));
        {
#line 669
        while (1) {
          while_continue___31: /* CIL Label */ ;
#line 669
          if ((unsigned int )((enum syntaxcode )(sentry & 15L)) != 2U) {
#line 669
            if ((unsigned int )((enum syntaxcode )(sentry & 15L)) != 3U) {
#line 669
              if ((unsigned long )start > (unsigned long )gap_start) {
#line 669
                tmp___8 = start - gap_length;
              } else {
#line 669
                tmp___8 = start;
              }
#line 669
              return ((26UL << 58U) | (unsigned long )(tmp___8 - first_char));
            }
          }
#line 669
          goto while_break___31;
        }
        while_break___31: /* CIL Label */ ;
        }
      }
      {
#line 672
      while (1) {
        while_continue___32: /* CIL Label */ ;
#line 672
        start --;
#line 672
        if ((unsigned long )start == (unsigned long )gap_end) {
#line 672
          start = gap_start;
        }
#line 672
        goto while_break___32;
      }
      while_break___32: /* CIL Label */ ;
      }
    }
    while_break___23: /* CIL Label */ ;
    }
    case_8: /* CIL Label */ 
#line 676
    if (! sexp_flag) {
#line 677
      goto switch_break;
    }
#line 678
    if (! ((unsigned long )start <= (unsigned long )end)) {
#line 678
      if (c == (int )*(start + -1)) {
        {
#line 679
        while (1) {
          while_continue___33: /* CIL Label */ ;
#line 679
          start --;
#line 679
          if ((unsigned long )start == (unsigned long )gap_end) {
#line 679
            start = gap_start;
          }
#line 679
          goto while_break___33;
        }
        while_break___33: /* CIL Label */ ;
        }
      }
    }
#line 680
    if (math_exit) {
      {
#line 682
      while (1) {
        while_continue___34: /* CIL Label */ ;
#line 682
        depth --;
#line 682
        if (depth == 0L) {
#line 682
          if ((unsigned long )start > (unsigned long )gap_start) {
#line 682
            tmp___9 = start - gap_length;
          } else {
#line 682
            tmp___9 = start;
          }
#line 682
          return ((26UL << 58U) | (unsigned long )(tmp___9 - first_char));
        }
#line 682
        goto while_break___34;
      }
      while_break___34: /* CIL Label */ ;
      }
      {
#line 683
      while (1) {
        while_continue___35: /* CIL Label */ ;
#line 683
        if (depth < min_depth) {
#line 683
          return (0UL);
        }
#line 683
        goto while_break___35;
      }
      while_break___35: /* CIL Label */ ;
      }
#line 684
      math_exit = (_Bool)0;
    } else {
      {
#line 688
      while (1) {
        while_continue___36: /* CIL Label */ ;
#line 688
        depth ++;
#line 688
        if (depth == 0L) {
#line 688
          if ((unsigned long )start > (unsigned long )gap_start) {
#line 688
            tmp___10 = start - gap_length;
          } else {
#line 688
            tmp___10 = start;
          }
#line 688
          return ((26UL << 58U) | (unsigned long )(tmp___10 - first_char));
        }
#line 688
        goto while_break___36;
      }
      while_break___36: /* CIL Label */ ;
      }
#line 689
      math_exit = (_Bool)1;
    }
#line 691
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 694
    while (1) {
      while_continue___37: /* CIL Label */ ;
#line 694
      depth ++;
#line 694
      if (depth == 0L) {
#line 694
        if ((unsigned long )start > (unsigned long )gap_start) {
#line 694
          tmp___11 = start - gap_length;
        } else {
#line 694
          tmp___11 = start;
        }
#line 694
        return ((26UL << 58U) | (unsigned long )(tmp___11 - first_char));
      }
#line 694
      goto while_break___37;
    }
    while_break___37: /* CIL Label */ ;
    }
#line 695
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 698
    while (1) {
      while_continue___38: /* CIL Label */ ;
#line 698
      depth --;
#line 698
      if (depth == 0L) {
#line 698
        if ((unsigned long )start > (unsigned long )gap_start) {
#line 698
          tmp___12 = start - gap_length;
        } else {
#line 698
          tmp___12 = start;
        }
#line 698
        return ((26UL << 58U) | (unsigned long )(tmp___12 - first_char));
      }
#line 698
      goto while_break___38;
    }
    while_break___38: /* CIL Label */ ;
    }
    {
#line 699
    while (1) {
      while_continue___39: /* CIL Label */ ;
#line 699
      if (depth < min_depth) {
#line 699
        return (0UL);
      }
#line 699
      goto while_break___39;
    }
    while_break___39: /* CIL Label */ ;
    }
#line 700
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 703
    while (1) {
      while_continue___40: /* CIL Label */ ;
      {
#line 705
      while (1) {
        while_continue___41: /* CIL Label */ ;
#line 705
        if ((unsigned long )start <= (unsigned long )end) {
#line 705
          return (0UL);
        }
#line 705
        goto while_break___41;
      }
      while_break___41: /* CIL Label */ ;
      }
      {
#line 706
      while (1) {
        while_continue___42: /* CIL Label */ ;
#line 706
        scan___2 = start;
        {
#line 706
        while (1) {
          while_continue___43: /* CIL Label */ ;
#line 706
          scan___2 --;
#line 706
          if ((unsigned long )scan___2 == (unsigned long )gap_end) {
#line 706
            scan___2 = gap_start;
          }
#line 706
          goto while_break___43;
        }
        while_break___43: /* CIL Label */ ;
        }
        {
#line 706
        while (1) {
          while_continue___44: /* CIL Label */ ;
#line 706
          quoted = (_Bool)0;
          {
#line 706
          while (1) {
            while_continue___45: /* CIL Label */ ;
#line 706
            if ((unsigned long )scan___2 <= (unsigned long )end) {
#line 706
              goto while_break___45;
            }
            {
#line 706
            while (1) {
              while_continue___46: /* CIL Label */ ;
#line 706
              scan___2 --;
#line 706
              sentry___3 = (long )*((SCHEME_OBJECT *)(syntax_table & 288230376151711743UL) + (((int )*scan___2 & 255) + 1));
#line 706
              if ((unsigned long )scan___2 == (unsigned long )gap_end) {
#line 706
                scan___2 = gap_start;
              }
#line 706
              goto while_break___46;
            }
            while_break___46: /* CIL Label */ ;
            }
#line 706
            if (! ((unsigned int )((enum syntaxcode )(sentry___3 & 15L)) == 9U)) {
#line 706
              if (! ((unsigned int )((enum syntaxcode )(sentry___3 & 15L)) == 10U)) {
#line 706
                goto while_break___45;
              }
            }
#line 706
            quoted = (_Bool )(! quoted);
          }
          while_break___45: /* CIL Label */ ;
          }
#line 706
          goto while_break___44;
        }
        while_break___44: /* CIL Label */ ;
        }
#line 706
        goto while_break___42;
      }
      while_break___42: /* CIL Label */ ;
      }
#line 707
      if (! quoted) {
#line 707
        if (c == (int )*(start + -1)) {
#line 708
          goto while_break___40;
        }
      }
      {
#line 709
      while (1) {
        while_continue___47: /* CIL Label */ ;
#line 709
        start --;
#line 709
        if ((unsigned long )start == (unsigned long )gap_end) {
#line 709
          start = gap_start;
        }
#line 709
        goto while_break___47;
      }
      while_break___47: /* CIL Label */ ;
      }
    }
    while_break___40: /* CIL Label */ ;
    }
    {
#line 711
    while (1) {
      while_continue___48: /* CIL Label */ ;
#line 711
      start --;
#line 711
      if ((unsigned long )start == (unsigned long )gap_end) {
#line 711
        start = gap_start;
      }
#line 711
      goto while_break___48;
    }
    while_break___48: /* CIL Label */ ;
    }
    {
#line 712
    while (1) {
      while_continue___49: /* CIL Label */ ;
#line 712
      if (depth == 0L) {
#line 712
        if (sexp_flag) {
#line 712
          if ((unsigned long )start > (unsigned long )gap_start) {
#line 712
            tmp___13 = start - gap_length;
          } else {
#line 712
            tmp___13 = start;
          }
#line 712
          return ((26UL << 58U) | (unsigned long )(tmp___13 - first_char));
        }
      }
#line 712
      goto while_break___49;
    }
    while_break___49: /* CIL Label */ ;
    }
#line 713
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 716
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
}
}
#line 751 "/home/khheo/project/mit-scheme-9.2/src/microcode/syntax.c"
SCHEME_OBJECT Prim_scan_sexps_forward(void) 
{ 
  long target_depth ;
  _Bool stop_before ;
  SCHEME_OBJECT state_argument ;
  long depth ;
  long in_string ;
  unsigned int in_comment ;
  unsigned int comment_style ;
  unsigned char *comment_start ;
  _Bool quoted ;
  struct levelstruct level_start[100] ;
  struct levelstruct *level ;
  struct levelstruct *level_end ;
  int c ;
  long sentry ;
  SCHEME_OBJECT result ;
  unsigned char *gap_start ;
  unsigned char *gap_end ;
  SCHEME_OBJECT syntax_table ;
  SCHEME_OBJECT group ;
  unsigned char *start ;
  unsigned char *first_char ;
  unsigned char *end ;
  long gap_length ;
  long tmp ;
  long tmp___0 ;
  SCHEME_OBJECT temp ;
  SCHEME_OBJECT *tmp___1 ;
  SCHEME_OBJECT *tmp___2 ;
  SCHEME_OBJECT *tmp___3 ;
  unsigned char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  unsigned char *tmp___9 ;
  unsigned char *tmp___10 ;
  unsigned int tmp___11 ;
  unsigned int tmp___12 ;
  unsigned char *tmp___13 ;
  unsigned char *tmp___14 ;
  unsigned char *tmp___15 ;
  unsigned char *tmp___16 ;
  unsigned char *tmp___17 ;
  void *__cil_tmp44 ;
  int __cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;

  {
#line 756
  depth = 0L;
#line 757
  in_string = -1L;
#line 763
  in_comment = 0U;
#line 764
  comment_style = 170U;
#line 765
  comment_start = (unsigned char *)0;
#line 766
  quoted = (_Bool)0;
#line 770
  c = 0;
#line 771
  sentry = 0L;
  {
#line 773
  while (1) {
    while_continue: /* CIL Label */ ;
#line 773
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 773
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 773
    if (*(stack_pointer + 0) >> 58U == 10UL) {
#line 773
      if (! ((*((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 0) & 288230376151711743UL) == 256UL)) {
        {
#line 773
        error_wrong_type_arg(1);
        }
      }
    } else {
      {
#line 773
      error_wrong_type_arg(1);
      }
    }
#line 773
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 773
  syntax_table = *(stack_pointer + 0);
  {
#line 773
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 773
    if (! (*(stack_pointer + 1) >> 58U == 10UL)) {
      {
#line 773
      error_wrong_type_arg(2);
      }
    }
#line 773
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 773
  group = *(stack_pointer + 1);
#line 773
  first_char = lookup_external_string(*((SCHEME_OBJECT *)(group & 288230376151711743UL) + 2),
                                      (unsigned long *)0);
#line 773
  tmp = arg_nonnegative_integer(3);
#line 773
  start = first_char + tmp;
#line 773
  tmp___0 = arg_nonnegative_integer(4);
#line 773
  end = first_char + tmp___0;
#line 773
  gap_start = first_char + (*((SCHEME_OBJECT *)(group & 288230376151711743UL) + 3) & 288230376151711743UL);
#line 773
  gap_length = (long )(*((SCHEME_OBJECT *)(group & 288230376151711743UL) + 4) & 288230376151711743UL);
#line 773
  gap_end = first_char + (*((SCHEME_OBJECT *)(group & 288230376151711743UL) + 5) & 288230376151711743UL);
  }
#line 773
  if ((unsigned long )start >= (unsigned long )gap_start) {
#line 773
    start += gap_length;
  }
#line 773
  if ((unsigned long )end >= (unsigned long )gap_start) {
#line 773
    end += gap_length;
  }
  {
#line 775
  target_depth = arg_integer(5);
#line 776
  stop_before = (_Bool )(*(stack_pointer + 5) != 0UL);
#line 777
  state_argument = *(stack_pointer + 6);
#line 779
  level = level_start;
#line 780
  level_end = level_start + 100;
#line 781
  level->previous = (unsigned char *)((void *)0);
  }
#line 785
  if (state_argument == 0UL) {
#line 787
    depth = 0L;
#line 788
    in_string = -1L;
#line 789
    in_comment = 0U;
#line 790
    quoted = (_Bool)0;
  } else
#line 792
  if (state_argument >> 58U == 10UL) {
#line 792
    if ((*((SCHEME_OBJECT *)(state_argument & 288230376151711743UL) + 0) & 288230376151711743UL) == 9UL) {
#line 797
      temp = *((SCHEME_OBJECT *)(state_argument & 288230376151711743UL) + 1);
#line 798
      if (temp >> 58U == 26UL) {
#line 799
        depth = (long )((temp ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL));
      } else {
        {
#line 801
        error_bad_range_arg(7);
        }
      }
#line 803
      temp = *((SCHEME_OBJECT *)(state_argument & 288230376151711743UL) + 2);
#line 804
      if (temp == 0UL) {
#line 805
        in_string = -1L;
      } else
#line 806
      if (temp >> 58U == 26UL) {
#line 806
        if (! ((temp & 144115188075855872UL) != 0UL)) {
#line 806
          if ((unsigned long )((long )(temp & 288230376151711743UL)) < 1UL << 8) {
#line 808
            in_string = (long )(temp & 288230376151711743UL);
          } else {
            {
#line 810
            error_bad_range_arg(7);
            }
          }
        } else {
          {
#line 810
          error_bad_range_arg(7);
          }
        }
      } else {
        {
#line 810
        error_bad_range_arg(7);
        }
      }
#line 812
      temp = *((SCHEME_OBJECT *)(state_argument & 288230376151711743UL) + 3);
#line 813
      if (temp == 0UL) {
#line 814
        in_comment = 0U;
      } else
#line 815
      if (temp == ((26UL << 58U) | 1UL)) {
#line 817
        in_comment = 1U;
#line 818
        comment_style = 170U;
      } else
#line 820
      if (temp == ((26UL << 58U) | 2UL)) {
#line 822
        in_comment = 2U;
#line 823
        comment_style = 170U;
      } else
#line 825
      if (temp == ((26UL << 58U) | 3UL)) {
#line 827
        in_comment = 3U;
#line 828
        comment_style = 170U;
      } else
#line 830
      if (temp == ((26UL << 58U) | 4UL)) {
#line 832
        in_comment = 2U;
#line 833
        comment_style = 255U;
      } else
#line 835
      if (temp == ((26UL << 58U) | 5UL)) {
#line 837
        in_comment = 1U;
#line 838
        comment_style = 85U;
      } else
#line 840
      if (temp == ((26UL << 58U) | 6UL)) {
#line 842
        in_comment = 2U;
#line 843
        comment_style = 85U;
      } else
#line 845
      if (temp == ((26UL << 58U) | 7UL)) {
#line 847
        in_comment = 3U;
#line 848
        comment_style = 85U;
      } else {
        {
#line 851
        error_bad_range_arg(7);
        }
      }
#line 853
      quoted = (_Bool )(*((SCHEME_OBJECT *)(state_argument & 288230376151711743UL) + 4) != 0UL);
#line 855
      if (in_comment != 0U) {
#line 857
        temp = *((SCHEME_OBJECT *)(state_argument & 288230376151711743UL) + 9);
#line 858
        if (temp >> 58U == 62UL) {
#line 859
          if ((unsigned long )(first_char + (long )(*((SCHEME_OBJECT *)(temp & 288230376151711743UL) + 3) & 288230376151711743UL)) > (unsigned long )gap_start) {
#line 859
            comment_start = (first_char + (long )(*((SCHEME_OBJECT *)(temp & 288230376151711743UL) + 3) & 288230376151711743UL)) + gap_length;
          } else {
#line 859
            comment_start = first_char + (long )(*((SCHEME_OBJECT *)(temp & 288230376151711743UL) + 3) & 288230376151711743UL);
          }
        } else
#line 860
        if (temp >> 58U == 26UL) {
#line 860
          if (! ((temp & 144115188075855872UL) != 0UL)) {
#line 861
            if ((unsigned long )(first_char + (long )(temp & 288230376151711743UL)) > (unsigned long )gap_start) {
#line 861
              comment_start = (first_char + (long )(temp & 288230376151711743UL)) + gap_length;
            } else {
#line 861
              comment_start = first_char + (long )(temp & 288230376151711743UL);
            }
          } else {
            {
#line 863
            error_bad_range_arg(7);
            }
          }
        } else {
          {
#line 863
          error_bad_range_arg(7);
          }
        }
      }
#line 865
      if (in_comment != 0U) {
#line 865
        if (in_string != -1L) {
          {
#line 866
          error_bad_range_arg(7);
          }
        } else
#line 865
        if ((int )quoted != 0) {
          {
#line 866
          error_bad_range_arg(7);
          }
        }
      }
    } else {
      {
#line 869
      error_bad_range_arg(7);
      }
    }
  } else {
    {
#line 869
    error_bad_range_arg(7);
    }
  }
  {
#line 873
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 873
    if ((unsigned long )Free >= (unsigned long )heap_start) {
#line 873
      if ((unsigned long )Free < (unsigned long )heap_alloc_limit) {
#line 873
        if (! ((unsigned long )(Free + 9) <= (unsigned long )heap_alloc_limit)) {
#line 873
          goto _L___0;
        }
      } else {
#line 873
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 873
    if ((Registers[1] & 4UL) != 0UL) {
      {
#line 873
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 873
        if ((unsigned long )Free_primitive < (unsigned long )heap_start) {
          {
#line 873
          outf_fatal("\nMicrocode requested primitive GC outside primitive!\n");
#line 873
          Microcode_Termination(12);
          }
        }
#line 873
        if ((unsigned long )Free < (unsigned long )Free_primitive) {
          {
#line 873
          outf_fatal("\nFree has gone backwards!\n");
#line 873
          Microcode_Termination(12);
          }
        }
        {
#line 873
        while (1) {
          while_continue___4: /* CIL Label */ ;
          {
#line 873
          while (1) {
            while_continue___5: /* CIL Label */ ;
            {
#line 873
            set_ulong_register(12U, Registers[12] | 4UL);
            }
            {
#line 873
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 873
              if ((Registers[1] & Registers[12]) != 0UL) {
#line 873
                tmp___2 = memory_block_start;
              } else {
#line 873
                if ((Registers[1] & 4UL) != 0UL) {
#line 873
                  tmp___1 = heap_alloc_limit;
                } else {
#line 873
                  tmp___1 = heap_end;
                }
#line 873
                tmp___2 = tmp___1;
              }
              {
#line 873
              set_ptr_register(0U, tmp___2);
              }
#line 873
              if ((Registers[1] & 1UL) != 0UL) {
#line 873
                tmp___3 = stack_guard;
              } else {
#line 873
                tmp___3 = stack_start;
              }
              {
#line 873
              set_ptr_register(11U, tmp___3);
              }
#line 873
              goto while_break___6;
            }
            while_break___6: /* CIL Label */ ;
            }
#line 873
            goto while_break___5;
          }
          while_break___5: /* CIL Label */ ;
          }
#line 873
          gc_space_needed = (unsigned long )(9L + (Free - Free_primitive));
#line 873
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
        {
#line 873
        signal_interrupt_from_primitive();
        }
#line 873
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 873
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 879
  if (in_comment == 1U) {
#line 879
    goto case_1;
  }
#line 880
  if (in_comment == 2U) {
#line 880
    goto case_2;
  }
#line 881
  if (in_comment == 3U) {
#line 881
    goto case_3;
  }
#line 877
  goto switch_break;
  case_1: /* CIL Label */ 
#line 879
  goto in_comment_1;
  case_2: /* CIL Label */ 
#line 880
  goto in_comment_2;
  case_3: /* CIL Label */ 
#line 881
  goto in_comment_3;
  switch_break: /* CIL Label */ ;
  }
#line 883
  if (quoted) {
#line 885
    quoted = (_Bool)0;
#line 886
    if (in_string != -1L) {
#line 887
      goto start_quoted_in_string;
    } else {
#line 889
      goto start_quoted;
    }
  }
#line 891
  if (in_string != -1L) {
#line 892
    goto start_in_string;
  }
  {
#line 894
  while (1) {
    while_continue___7: /* CIL Label */ ;
    {
#line 896
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 896
      if ((unsigned long )start >= (unsigned long )end) {
#line 896
        goto done;
      }
#line 896
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 897
    c = (int )*start;
#line 898
    comment_start = start;
    {
#line 899
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 899
      tmp___4 = start;
#line 899
      start ++;
#line 899
      sentry = (long )*((SCHEME_OBJECT *)(syntax_table & 288230376151711743UL) + (((int )*tmp___4 & 255) + 1));
#line 899
      if ((unsigned long )start == (unsigned long )gap_start) {
#line 899
        start = gap_end;
      }
#line 899
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 900
    if ((((sentry >> 12) & 255L) & 192L) & 170L) {
#line 900
      tmp___5 = 170;
    } else {
#line 900
      tmp___5 = 0;
    }
#line 900
    if ((((sentry >> 12) & 255L) & 192L) & 85L) {
#line 900
      tmp___6 = 85;
    } else {
#line 900
      tmp___6 = 0;
    }
#line 900
    comment_style = (unsigned int )(tmp___5 | tmp___6);
#line 901
    if ((unsigned int )((enum syntaxcode )(sentry & 15L)) == 11U) {
#line 902
      goto in_comment_1;
    }
#line 903
    if (comment_style == 0U) {
#line 904
      goto not_in_comment;
    }
    in_comment_2: 
#line 907
    in_comment = 2U;
    {
#line 908
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 908
      if ((unsigned long )start >= (unsigned long )end) {
#line 908
        goto done;
      }
#line 908
      goto while_break___10;
    }
    while_break___10: /* CIL Label */ ;
    }
#line 909
    if ((((*((SCHEME_OBJECT *)(syntax_table & 288230376151711743UL) + (((int )*start & 255) + 1)) >> 12) & 255UL) & 48UL) & 170UL) {
#line 909
      tmp___7 = 170;
    } else {
#line 909
      tmp___7 = 0;
    }
#line 909
    if ((((*((SCHEME_OBJECT *)(syntax_table & 288230376151711743UL) + (((int )*start & 255) + 1)) >> 12) & 255UL) & 48UL) & 85UL) {
#line 909
      tmp___8 = 85;
    } else {
#line 909
      tmp___8 = 0;
    }
#line 909
    comment_style &= (unsigned int )(tmp___7 | tmp___8);
#line 912
    if (comment_style == 0U) {
#line 913
      goto not_in_comment;
    }
    {
#line 914
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 914
      start ++;
#line 914
      if ((unsigned long )start == (unsigned long )gap_start) {
#line 914
        start = gap_end;
      }
#line 914
      goto while_break___11;
    }
    while_break___11: /* CIL Label */ ;
    }
    in_comment_1: 
    {
#line 917
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 919
      in_comment = 1U;
      {
#line 920
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 920
        if ((unsigned long )start >= (unsigned long )end) {
#line 920
          goto done;
        }
#line 920
        goto while_break___13;
      }
      while_break___13: /* CIL Label */ ;
      }
      {
#line 921
      while (1) {
        while_continue___14: /* CIL Label */ ;
#line 921
        tmp___9 = start;
#line 921
        start ++;
#line 921
        sentry = (long )*((SCHEME_OBJECT *)(syntax_table & 288230376151711743UL) + (((int )*tmp___9 & 255) + 1));
#line 921
        if ((unsigned long )start == (unsigned long )gap_start) {
#line 921
          start = gap_end;
        }
#line 921
        goto while_break___14;
      }
      while_break___14: /* CIL Label */ ;
      }
#line 922
      if ((((sentry >> 12) & 255L) & 12L) & (long )comment_style) {
#line 926
        if ((unsigned int )((enum syntaxcode )(sentry & 15L)) == 12U) {
#line 927
          goto while_break___12;
        }
        in_comment_3: 
#line 929
        in_comment = 3U;
        {
#line 930
        while (1) {
          while_continue___15: /* CIL Label */ ;
#line 930
          if ((unsigned long )start >= (unsigned long )end) {
#line 930
            goto done;
          }
#line 930
          goto while_break___15;
        }
        while_break___15: /* CIL Label */ ;
        }
#line 931
        if ((((*((SCHEME_OBJECT *)(syntax_table & 288230376151711743UL) + (((int )*start & 255) + 1)) >> 12) & 255UL) & 3UL) & (unsigned long )comment_style) {
          {
#line 935
          while (1) {
            while_continue___16: /* CIL Label */ ;
#line 935
            start ++;
#line 935
            if ((unsigned long )start == (unsigned long )gap_start) {
#line 935
              start = gap_end;
            }
#line 935
            goto while_break___16;
          }
          while_break___16: /* CIL Label */ ;
          }
#line 936
          goto while_break___12;
        }
      }
    }
    while_break___12: /* CIL Label */ ;
    }
#line 940
    in_comment = 0U;
#line 941
    goto while_continue___7;
    not_in_comment: 
#line 944
    in_comment = 0U;
#line 945
    if ((sentry >> 20) & 1L) {
#line 946
      goto while_continue___7;
    }
    {
#line 951
    if ((unsigned int )((enum syntaxcode )(sentry & 15L)) == 10U) {
#line 951
      goto case_10;
    }
#line 951
    if ((unsigned int )((enum syntaxcode )(sentry & 15L)) == 9U) {
#line 951
      goto case_10;
    }
#line 963
    if ((unsigned int )((enum syntaxcode )(sentry & 15L)) == 3U) {
#line 963
      goto case_3___0;
    }
#line 963
    if ((unsigned int )((enum syntaxcode )(sentry & 15L)) == 2U) {
#line 963
      goto case_3___0;
    }
#line 992
    if ((unsigned int )((enum syntaxcode )(sentry & 15L)) == 4U) {
#line 992
      goto case_4;
    }
#line 1003
    if ((unsigned int )((enum syntaxcode )(sentry & 15L)) == 5U) {
#line 1003
      goto case_5;
    }
#line 1011
    if ((unsigned int )((enum syntaxcode )(sentry & 15L)) == 7U) {
#line 1011
      goto case_7;
    }
#line 1037
    goto switch_default___0;
    case_10: /* CIL Label */ 
    case_9: /* CIL Label */ 
    {
#line 952
    while (1) {
      while_continue___17: /* CIL Label */ ;
#line 952
      if (stop_before) {
#line 952
        goto stop;
      }
#line 952
      level->last = start;
#line 952
      goto while_break___17;
    }
    while_break___17: /* CIL Label */ ;
    }
    start_quoted: 
#line 954
    if ((unsigned long )start >= (unsigned long )end) {
#line 956
      quoted = (_Bool)1;
      {
#line 957
      while (1) {
        while_continue___18: /* CIL Label */ ;
#line 957
        goto done;
#line 957
        goto while_break___18;
      }
      while_break___18: /* CIL Label */ ;
      }
    }
    {
#line 959
    while (1) {
      while_continue___19: /* CIL Label */ ;
#line 959
      start ++;
#line 959
      if ((unsigned long )start == (unsigned long )gap_start) {
#line 959
        start = gap_end;
      }
#line 959
      goto while_break___19;
    }
    while_break___19: /* CIL Label */ ;
    }
#line 960
    goto start_atom;
    case_3___0: /* CIL Label */ 
    case_2___0: /* CIL Label */ 
    {
#line 964
    while (1) {
      while_continue___20: /* CIL Label */ ;
#line 964
      if (stop_before) {
#line 964
        goto stop;
      }
#line 964
      level->last = start;
#line 964
      goto while_break___20;
    }
    while_break___20: /* CIL Label */ ;
    }
    start_atom: 
    {
#line 966
    while (1) {
      while_continue___21: /* CIL Label */ ;
#line 966
      if (! (! ((unsigned long )start >= (unsigned long )end))) {
#line 966
        goto while_break___21;
      }
      {
#line 971
      if ((unsigned int )((enum syntaxcode )(*((SCHEME_OBJECT *)(syntax_table & 288230376151711743UL) + (((int )*start & 255) + 1)) & 15UL)) == 10U) {
#line 971
        goto case_10___0;
      }
#line 971
      if ((unsigned int )((enum syntaxcode )(*((SCHEME_OBJECT *)(syntax_table & 288230376151711743UL) + (((int )*start & 255) + 1)) & 15UL)) == 9U) {
#line 971
        goto case_10___0;
      }
#line 980
      if ((unsigned int )((enum syntaxcode )(*((SCHEME_OBJECT *)(syntax_table & 288230376151711743UL) + (((int )*start & 255) + 1)) & 15UL)) == 3U) {
#line 980
        goto case_3___1;
      }
#line 980
      if ((unsigned int )((enum syntaxcode )(*((SCHEME_OBJECT *)(syntax_table & 288230376151711743UL) + (((int )*start & 255) + 1)) & 15UL)) == 2U) {
#line 980
        goto case_3___1;
      }
#line 984
      goto switch_default;
      case_10___0: /* CIL Label */ 
      case_9___0: /* CIL Label */ 
      {
#line 972
      while (1) {
        while_continue___22: /* CIL Label */ ;
#line 972
        start ++;
#line 972
        if ((unsigned long )start == (unsigned long )gap_start) {
#line 972
          start = gap_end;
        }
#line 972
        goto while_break___22;
      }
      while_break___22: /* CIL Label */ ;
      }
#line 973
      if ((unsigned long )start >= (unsigned long )end) {
#line 975
        quoted = (_Bool)1;
        {
#line 976
        while (1) {
          while_continue___23: /* CIL Label */ ;
#line 976
          goto done;
#line 976
          goto while_break___23;
        }
        while_break___23: /* CIL Label */ ;
        }
      }
      case_3___1: /* CIL Label */ 
      case_2___1: /* CIL Label */ 
      {
#line 981
      while (1) {
        while_continue___24: /* CIL Label */ ;
#line 981
        start ++;
#line 981
        if ((unsigned long )start == (unsigned long )gap_start) {
#line 981
          start = gap_end;
        }
#line 981
        goto while_break___24;
      }
      while_break___24: /* CIL Label */ ;
      }
#line 982
      goto switch_break___1;
      switch_default: /* CIL Label */ 
#line 985
      goto end_atom;
      switch_break___1: /* CIL Label */ ;
      }
    }
    while_break___21: /* CIL Label */ ;
    }
    end_atom: 
#line 989
    level->previous = level->last;
#line 990
    goto switch_break___0;
    case_4: /* CIL Label */ 
    {
#line 993
    while (1) {
      while_continue___25: /* CIL Label */ ;
#line 993
      if (stop_before) {
#line 993
        goto stop;
      }
#line 993
      level->last = start;
#line 993
      goto while_break___25;
    }
    while_break___25: /* CIL Label */ ;
    }
#line 994
    depth ++;
#line 995
    level ++;
#line 996
    if ((unsigned long )level == (unsigned long )level_end) {
      {
#line 997
      error_bad_range_arg(5);
      }
    }
#line 998
    level->last = (unsigned char *)((void *)0);
#line 999
    level->previous = (unsigned char *)((void *)0);
    {
#line 1000
    while (1) {
      while_continue___26: /* CIL Label */ ;
#line 1000
      target_depth --;
#line 1000
      if (target_depth == 0L) {
#line 1000
        goto done;
      }
#line 1000
      goto while_break___26;
    }
    while_break___26: /* CIL Label */ ;
    }
#line 1001
    goto switch_break___0;
    case_5: /* CIL Label */ 
#line 1004
    depth --;
#line 1005
    if ((unsigned long )level != (unsigned long )(level_start)) {
#line 1006
      level --;
    }
#line 1007
    level->previous = level->last;
    {
#line 1008
    while (1) {
      while_continue___27: /* CIL Label */ ;
#line 1008
      target_depth ++;
#line 1008
      if (target_depth == 0L) {
#line 1008
        goto done;
      }
#line 1008
      goto while_break___27;
    }
    while_break___27: /* CIL Label */ ;
    }
#line 1009
    goto switch_break___0;
    case_7: /* CIL Label */ 
    {
#line 1012
    while (1) {
      while_continue___28: /* CIL Label */ ;
#line 1012
      if (stop_before) {
#line 1012
        goto stop;
      }
#line 1012
      level->last = start;
#line 1012
      goto while_break___28;
    }
    while_break___28: /* CIL Label */ ;
    }
#line 1013
    in_string = (long )c;
    start_in_string: 
    {
#line 1015
    while (1) {
      while_continue___29: /* CIL Label */ ;
      {
#line 1017
      while (1) {
        while_continue___30: /* CIL Label */ ;
#line 1017
        if ((unsigned long )start >= (unsigned long )end) {
#line 1017
          goto done;
        }
#line 1017
        goto while_break___30;
      }
      while_break___30: /* CIL Label */ ;
      }
#line 1018
      if (in_string == (long )*start) {
#line 1019
        goto while_break___29;
      }
      {
#line 1020
      while (1) {
        while_continue___31: /* CIL Label */ ;
#line 1020
        tmp___10 = start;
#line 1020
        start ++;
#line 1020
        sentry = (long )*((SCHEME_OBJECT *)(syntax_table & 288230376151711743UL) + (((int )*tmp___10 & 255) + 1));
#line 1020
        if ((unsigned long )start == (unsigned long )gap_start) {
#line 1020
          start = gap_end;
        }
#line 1020
        goto while_break___31;
      }
      while_break___31: /* CIL Label */ ;
      }
#line 1021
      if ((unsigned int )((enum syntaxcode )(sentry & 15L)) == 9U) {
#line 1021
        goto start_quoted_in_string;
      } else
#line 1021
      if ((unsigned int )((enum syntaxcode )(sentry & 15L)) == 10U) {
        start_quoted_in_string: 
#line 1024
        if ((unsigned long )start >= (unsigned long )end) {
#line 1026
          quoted = (_Bool)1;
          {
#line 1027
          while (1) {
            while_continue___32: /* CIL Label */ ;
#line 1027
            goto done;
#line 1027
            goto while_break___32;
          }
          while_break___32: /* CIL Label */ ;
          }
        }
        {
#line 1029
        while (1) {
          while_continue___33: /* CIL Label */ ;
#line 1029
          start ++;
#line 1029
          if ((unsigned long )start == (unsigned long )gap_start) {
#line 1029
            start = gap_end;
          }
#line 1029
          goto while_break___33;
        }
        while_break___33: /* CIL Label */ ;
        }
      }
    }
    while_break___29: /* CIL Label */ ;
    }
#line 1032
    in_string = -1L;
#line 1033
    level->previous = level->last;
    {
#line 1034
    while (1) {
      while_continue___34: /* CIL Label */ ;
#line 1034
      start ++;
#line 1034
      if ((unsigned long )start == (unsigned long )gap_start) {
#line 1034
        start = gap_end;
      }
#line 1034
      goto while_break___34;
    }
    while_break___34: /* CIL Label */ ;
    }
#line 1035
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 1038
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break___7: /* CIL Label */ ;
  }
  stop: 
#line 1045
  if ((unsigned long )start == (unsigned long )gap_end) {
#line 1046
    start = gap_start;
  }
#line 1047
  start --;
  done: 
  {
#line 1050
  result = allocate_marked_vector(10U, 9UL, (_Bool)1);
#line 1051
  *((SCHEME_OBJECT *)(result & 288230376151711743UL) + 1) = (26UL << 58U) | ((unsigned long )depth & 288230376151711743UL);
  }
#line 1052
  if (in_string == -1L) {
#line 1052
    *((SCHEME_OBJECT *)(result & 288230376151711743UL) + 2) = 0UL;
  } else {
#line 1052
    *((SCHEME_OBJECT *)(result & 288230376151711743UL) + 2) = (26UL << 58U) | (unsigned long )in_string;
  }
#line 1057
  if (in_comment == 0U) {
#line 1057
    *((SCHEME_OBJECT *)(result & 288230376151711743UL) + 3) = 0UL;
  } else {
#line 1057
    if (in_comment == 2U) {
#line 1057
      if (comment_style == 255U) {
#line 1057
        tmp___12 = 4U;
      } else {
#line 1057
        goto _L___2;
      }
    } else {
      _L___2: /* CIL Label */ 
#line 1057
      if (comment_style == 170U) {
#line 1057
        tmp___11 = in_comment;
      } else {
#line 1057
        tmp___11 = in_comment + 4U;
      }
#line 1057
      tmp___12 = tmp___11;
    }
#line 1057
    *((SCHEME_OBJECT *)(result & 288230376151711743UL) + 3) = (26UL << 58U) | (unsigned long )tmp___12;
  }
#line 1068
  if (quoted) {
#line 1068
    *((SCHEME_OBJECT *)(result & 288230376151711743UL) + 4) = 8UL << 58U;
  } else {
#line 1068
    *((SCHEME_OBJECT *)(result & 288230376151711743UL) + 4) = 0UL;
  }
#line 1069
  if ((unsigned long )level->last == (unsigned long )((void *)0)) {
#line 1069
    *((SCHEME_OBJECT *)(result & 288230376151711743UL) + 5) = 0UL;
  } else {
#line 1069
    if ((unsigned long )level->last > (unsigned long )gap_start) {
#line 1069
      tmp___13 = level->last - gap_length;
    } else {
#line 1069
      tmp___13 = level->last;
    }
#line 1069
    *((SCHEME_OBJECT *)(result & 288230376151711743UL) + 5) = (26UL << 58U) | (unsigned long )((tmp___13 - first_char) - 1L);
  }
#line 1074
  if ((unsigned long )level->previous == (unsigned long )((void *)0)) {
#line 1074
    *((SCHEME_OBJECT *)(result & 288230376151711743UL) + 6) = 0UL;
  } else {
#line 1074
    if ((unsigned long )level->previous > (unsigned long )gap_start) {
#line 1074
      tmp___14 = level->previous - gap_length;
    } else {
#line 1074
      tmp___14 = level->previous;
    }
#line 1074
    *((SCHEME_OBJECT *)(result & 288230376151711743UL) + 6) = (26UL << 58U) | (unsigned long )((tmp___14 - first_char) - 1L);
  }
#line 1079
  if ((unsigned long )level == (unsigned long )(level_start)) {
#line 1079
    *((SCHEME_OBJECT *)(result & 288230376151711743UL) + 7) = 0UL;
  } else
#line 1079
  if ((unsigned long )(level - 1)->last == (unsigned long )((void *)0)) {
#line 1079
    *((SCHEME_OBJECT *)(result & 288230376151711743UL) + 7) = 0UL;
  } else {
#line 1079
    if ((unsigned long )(level - 1)->last > (unsigned long )gap_start) {
#line 1079
      tmp___15 = (level - 1)->last - gap_length;
    } else {
#line 1079
      tmp___15 = (level - 1)->last;
    }
#line 1079
    *((SCHEME_OBJECT *)(result & 288230376151711743UL) + 7) = (26UL << 58U) | (unsigned long )((tmp___15 - first_char) - 1L);
  }
#line 1085
  if ((unsigned long )start > (unsigned long )gap_start) {
#line 1085
    tmp___16 = start - gap_length;
  } else {
#line 1085
    tmp___16 = start;
  }
#line 1085
  *((SCHEME_OBJECT *)(result & 288230376151711743UL) + 8) = (26UL << 58U) | (unsigned long )(tmp___16 - first_char);
#line 1088
  if (in_comment == 0U) {
#line 1088
    *((SCHEME_OBJECT *)(result & 288230376151711743UL) + 9) = 0UL;
  } else {
#line 1088
    if ((unsigned long )comment_start > (unsigned long )gap_start) {
#line 1088
      tmp___17 = comment_start - gap_length;
    } else {
#line 1088
      tmp___17 = comment_start;
    }
#line 1088
    *((SCHEME_OBJECT *)(result & 288230376151711743UL) + 9) = (26UL << 58U) | (unsigned long )(tmp___17 - first_char);
  }
#line 1093
  return (result);
}
}
#line 277 "/home/khheo/project/mit-scheme-9.2/src/microcode/extern.h"
long char_downcase(long c ) ;
#line 278
long char_upcase(long c ) ;
#line 292
SCHEME_OBJECT allocate_string_no_gc(unsigned long nbytes ) ;
#line 294
SCHEME_OBJECT memory_to_string_no_gc(unsigned long n_bytes , void const   *vp ) ;
#line 296
SCHEME_OBJECT char_pointer_to_string_no_gc(char const   *cp ) ;
#line 109 "/home/khheo/project/mit-scheme-9.2/src/microcode/prims.h"
long arg_ascii_integer(int n ) ;
#line 32 "/home/khheo/project/mit-scheme-9.2/src/microcode/string.c"
SCHEME_OBJECT allocate_string(unsigned long nbytes ) 
{ 
  SCHEME_OBJECT result ;
  SCHEME_OBJECT tmp ;

  {
  {
#line 35
  tmp = allocate_non_marked_vector(30U, ((nbytes + 1UL) + (sizeof(SCHEME_OBJECT ) - 1UL)) / sizeof(SCHEME_OBJECT ) + 1UL,
                                   (_Bool)1);
#line 35
  result = tmp;
  }
  {
#line 39
  while (1) {
    while_continue: /* CIL Label */ ;
#line 39
    *((SCHEME_OBJECT *)(result & 288230376151711743UL) + 1) = nbytes;
#line 39
    *((unsigned char *)((SCHEME_OBJECT *)(result & 288230376151711743UL) + 2) + nbytes) = (unsigned char )'\000';
#line 39
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 40
  return (result);
}
}
#line 43 "/home/khheo/project/mit-scheme-9.2/src/microcode/string.c"
SCHEME_OBJECT allocate_string_no_gc(unsigned long nbytes ) 
{ 
  SCHEME_OBJECT result ;
  SCHEME_OBJECT tmp ;

  {
  {
#line 46
  tmp = allocate_non_marked_vector(30U, ((nbytes + 1UL) + (sizeof(SCHEME_OBJECT ) - 1UL)) / sizeof(SCHEME_OBJECT ) + 1UL,
                                   (_Bool)0);
#line 46
  result = tmp;
  }
  {
#line 50
  while (1) {
    while_continue: /* CIL Label */ ;
#line 50
    *((SCHEME_OBJECT *)(result & 288230376151711743UL) + 1) = nbytes;
#line 50
    *((unsigned char *)((SCHEME_OBJECT *)(result & 288230376151711743UL) + 2) + nbytes) = (unsigned char )'\000';
#line 50
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 51
  return (result);
}
}
#line 54 "/home/khheo/project/mit-scheme-9.2/src/microcode/string.c"
SCHEME_OBJECT memory_to_string(unsigned long n_bytes , void const   *vp ) 
{ 
  SCHEME_OBJECT result ;
  SCHEME_OBJECT tmp ;

  {
  {
#line 57
  tmp = allocate_string(n_bytes);
#line 57
  result = tmp;
#line 58
  memcpy((void */* __restrict  */)((char *)((SCHEME_OBJECT *)(result & 288230376151711743UL) + 2)),
         (void const   */* __restrict  */)vp, n_bytes);
  }
#line 59
  return (result);
}
}
#line 62 "/home/khheo/project/mit-scheme-9.2/src/microcode/string.c"
SCHEME_OBJECT memory_to_string_no_gc(unsigned long n_bytes , void const   *vp ) 
{ 
  SCHEME_OBJECT result ;
  SCHEME_OBJECT tmp ;

  {
  {
#line 65
  tmp = allocate_string_no_gc(n_bytes);
#line 65
  result = tmp;
#line 66
  memcpy((void */* __restrict  */)((char *)((SCHEME_OBJECT *)(result & 288230376151711743UL) + 2)),
         (void const   */* __restrict  */)vp, n_bytes);
  }
#line 67
  return (result);
}
}
#line 70 "/home/khheo/project/mit-scheme-9.2/src/microcode/string.c"
SCHEME_OBJECT char_pointer_to_string(char const   *cp ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;
  SCHEME_OBJECT tmp___1 ;

  {
#line 73
  if ((unsigned long )cp == (unsigned long )((char const   *)0)) {
#line 73
    tmp___0 = (size_t )0;
  } else {
    {
#line 73
    tmp = strlen(cp);
#line 73
    tmp___0 = tmp;
    }
  }
  {
#line 73
  tmp___1 = memory_to_string(tmp___0, (void const   *)cp);
  }
#line 73
  return (tmp___1);
}
}
#line 76 "/home/khheo/project/mit-scheme-9.2/src/microcode/string.c"
SCHEME_OBJECT char_pointer_to_string_no_gc(char const   *cp ) 
{ 
  char const   *scan ;
  char const   *tmp ;
  SCHEME_OBJECT tmp___0 ;

  {
#line 79
  scan = cp;
#line 80
  if ((unsigned long )scan == (unsigned long )((char const   *)0)) {
#line 81
    scan ++;
  } else {
    {
#line 83
    while (1) {
      while_continue: /* CIL Label */ ;
#line 83
      tmp = scan;
#line 83
      scan ++;
#line 83
      if (! ((int const   )*tmp != 0)) {
#line 83
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 85
  tmp___0 = memory_to_string_no_gc((unsigned long )((scan - 1) - cp), (void const   *)cp);
  }
#line 85
  return (tmp___0);
}
}
#line 91 "/home/khheo/project/mit-scheme-9.2/src/microcode/string.c"
SCHEME_OBJECT Prim_string_allocate(void) 
{ 
  long tmp ;
  SCHEME_OBJECT tmp___0 ;

  {
  {
#line 93
  while (1) {
    while_continue: /* CIL Label */ ;
#line 93
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 94
  tmp = arg_nonnegative_integer(1);
#line 94
  tmp___0 = allocate_string((unsigned long )tmp);
  }
#line 94
  return (tmp___0);
}
}
#line 97 "/home/khheo/project/mit-scheme-9.2/src/microcode/string.c"
SCHEME_OBJECT Prim_string_p(void) 
{ 
  unsigned long tmp ;

  {
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 100
  if (*(stack_pointer + 0) >> 58U == 30UL) {
#line 100
    tmp = 8UL << 58U;
  } else {
#line 100
    tmp = 0UL;
  }
#line 100
  return (tmp);
}
}
#line 103 "/home/khheo/project/mit-scheme-9.2/src/microcode/string.c"
SCHEME_OBJECT Prim_string_length(void) 
{ 


  {
  {
#line 105
  while (1) {
    while_continue: /* CIL Label */ ;
#line 105
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 106
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 106
    if (! (*(stack_pointer + 0) >> 58U == 30UL)) {
      {
#line 106
      error_wrong_type_arg(1);
      }
    }
#line 106
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 107
  return ((26UL << 58U) | (*((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 1) & 288230376151711743UL));
}
}
#line 110 "/home/khheo/project/mit-scheme-9.2/src/microcode/string.c"
SCHEME_OBJECT Prim_string_maximum_length(void) 
{ 


  {
  {
#line 112
  while (1) {
    while_continue: /* CIL Label */ ;
#line 112
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 113
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 113
    if (! (*(stack_pointer + 0) >> 58U == 30UL)) {
      {
#line 113
      error_wrong_type_arg(1);
      }
    }
#line 113
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 114
  return ((26UL << 58U) | (((*((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 0) & 288230376151711743UL) - 1UL) * sizeof(SCHEME_OBJECT ) - 1UL));
}
}
#line 118 "/home/khheo/project/mit-scheme-9.2/src/microcode/string.c"
SCHEME_OBJECT Prim_set_string_length(void) 
{ 
  SCHEME_OBJECT string ;
  long tmp ;
  long tmp___0 ;

  {
  {
#line 120
  while (1) {
    while_continue: /* CIL Label */ ;
#line 120
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 121
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 121
    if (! (*(stack_pointer + 0) >> 58U == 30UL)) {
      {
#line 121
      error_wrong_type_arg(1);
      }
    }
#line 121
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 123
  string = *(stack_pointer + 0);
  {
#line 124
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 124
    tmp = arg_index_integer(2, (long )((((*((SCHEME_OBJECT *)(string & 288230376151711743UL) + 0) & 288230376151711743UL) - 1UL) * sizeof(SCHEME_OBJECT ) - 1UL) + 1UL));
#line 124
    *((SCHEME_OBJECT *)(string & 288230376151711743UL) + 1) = (unsigned long )tmp;
#line 124
    tmp___0 = arg_index_integer(2, (long )((((*((SCHEME_OBJECT *)(string & 288230376151711743UL) + 0) & 288230376151711743UL) - 1UL) * sizeof(SCHEME_OBJECT ) - 1UL) + 1UL));
#line 124
    *((unsigned char *)((SCHEME_OBJECT *)(string & 288230376151711743UL) + 2) + tmp___0) = (unsigned char )'\000';
    }
#line 124
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 128
  return ((8UL << 58U) | 1UL);
}
}
#line 131 "/home/khheo/project/mit-scheme-9.2/src/microcode/string.c"
SCHEME_OBJECT Prim_set_string_maximum_length(void) 
{ 
  SCHEME_OBJECT string ;
  long length ;
  long tmp ;

  {
  {
#line 133
  while (1) {
    while_continue: /* CIL Label */ ;
#line 133
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 134
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 134
    if (! (*(stack_pointer + 0) >> 58U == 30UL)) {
      {
#line 134
      error_wrong_type_arg(1);
      }
    }
#line 134
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 136
  string = *(stack_pointer + 0);
#line 137
  tmp = arg_index_integer(2, (long )((((*((SCHEME_OBJECT *)(string & 288230376151711743UL) + 0) & 288230376151711743UL) - 1UL) * sizeof(SCHEME_OBJECT ) - 1UL) + 1UL));
#line 137
  length = tmp;
  }
#line 139
  if ((unsigned long )length < (*((SCHEME_OBJECT *)(string & 288230376151711743UL) + 1) & 288230376151711743UL)) {
    {
#line 140
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 140
      *((SCHEME_OBJECT *)(string & 288230376151711743UL) + 1) = (unsigned long )length;
#line 140
      *((unsigned char *)((SCHEME_OBJECT *)(string & 288230376151711743UL) + 2) + length) = (unsigned char )'\000';
#line 140
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 141
  *((SCHEME_OBJECT *)(string & 288230376151711743UL) + 0) = (39UL << 58U) | (((unsigned long )(length + 1L) + (sizeof(SCHEME_OBJECT ) - 1UL)) / sizeof(SCHEME_OBJECT ) + 1UL);
#line 147
  return ((8UL << 58U) | 1UL);
}
}
#line 163 "/home/khheo/project/mit-scheme-9.2/src/microcode/string.c"
SCHEME_OBJECT Prim_string_ref(void) 
{ 
  SCHEME_OBJECT string ;
  long tmp ;

  {
  {
#line 164
  while (1) {
    while_continue: /* CIL Label */ ;
#line 164
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 164
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 164
    if (! (*(stack_pointer + 0) >> 58U == 30UL)) {
      {
#line 164
      error_wrong_type_arg(1);
      }
    }
#line 164
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 164
  string = *(stack_pointer + 0);
#line 164
  tmp = arg_index_integer(2, (long )(*((SCHEME_OBJECT *)(string & 288230376151711743UL) + 1) & 288230376151711743UL));
  }
#line 164
  return ((2UL << 58U) | (unsigned long )*((unsigned char *)((SCHEME_OBJECT *)(string & 288230376151711743UL) + 2) + tmp));
}
}
#line 166 "/home/khheo/project/mit-scheme-9.2/src/microcode/string.c"
SCHEME_OBJECT Prim_vec_8b_ref(void) 
{ 
  SCHEME_OBJECT string ;
  long tmp ;

  {
  {
#line 167
  while (1) {
    while_continue: /* CIL Label */ ;
#line 167
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 167
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 167
    if (! (*(stack_pointer + 0) >> 58U == 30UL)) {
      {
#line 167
      error_wrong_type_arg(1);
      }
    }
#line 167
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 167
  string = *(stack_pointer + 0);
#line 167
  tmp = arg_index_integer(2, (long )(*((SCHEME_OBJECT *)(string & 288230376151711743UL) + 1) & 288230376151711743UL));
  }
#line 167
  return ((26UL << 58U) | (unsigned long )*((unsigned char *)((SCHEME_OBJECT *)(string & 288230376151711743UL) + 2) + tmp));
}
}
#line 183 "/home/khheo/project/mit-scheme-9.2/src/microcode/string.c"
SCHEME_OBJECT Prim_string_set(void) 
{ 
  SCHEME_OBJECT string ;
  long tmp ;
  long tmp___0 ;

  {
  {
#line 184
  while (1) {
    while_continue: /* CIL Label */ ;
#line 184
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 184
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 184
    if (! (*(stack_pointer + 0) >> 58U == 30UL)) {
      {
#line 184
      error_wrong_type_arg(1);
      }
    }
#line 184
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 184
  string = *(stack_pointer + 0);
#line 184
  tmp = arg_index_integer(2, (long )(*((SCHEME_OBJECT *)(string & 288230376151711743UL) + 1) & 288230376151711743UL));
#line 184
  tmp___0 = arg_ascii_char(3);
#line 184
  *((unsigned char *)((SCHEME_OBJECT *)(string & 288230376151711743UL) + 2) + tmp) = (unsigned char )tmp___0;
  }
#line 184
  return ((8UL << 58U) | 1UL);
}
}
#line 186 "/home/khheo/project/mit-scheme-9.2/src/microcode/string.c"
SCHEME_OBJECT Prim_vec_8b_set(void) 
{ 
  SCHEME_OBJECT string ;
  long tmp ;
  long tmp___0 ;

  {
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 187
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 187
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 187
    if (! (*(stack_pointer + 0) >> 58U == 30UL)) {
      {
#line 187
      error_wrong_type_arg(1);
      }
    }
#line 187
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 187
  string = *(stack_pointer + 0);
#line 187
  tmp = arg_index_integer(2, (long )(*((SCHEME_OBJECT *)(string & 288230376151711743UL) + 1) & 288230376151711743UL));
#line 187
  tmp___0 = arg_ascii_integer(3);
#line 187
  *((unsigned char *)((SCHEME_OBJECT *)(string & 288230376151711743UL) + 2) + tmp) = (unsigned char )tmp___0;
  }
#line 187
  return ((8UL << 58U) | 1UL);
}
}
#line 205 "/home/khheo/project/mit-scheme-9.2/src/microcode/string.c"
SCHEME_OBJECT Prim_substring_move_right(void) 
{ 
  unsigned char *ptr1 ;
  unsigned char *ptr2 ;
  unsigned long len1 ;
  unsigned long len2 ;
  unsigned long start1 ;
  unsigned long end1 ;
  unsigned long start2 ;
  unsigned long end2 ;
  unsigned long length ;
  unsigned char *scan1 ;
  unsigned char *scan2 ;
  unsigned char *limit ;

  {
  {
#line 207
  while (1) {
    while_continue: /* CIL Label */ ;
#line 207
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 207
  ptr1 = arg_extended_string(1U, & len1);
#line 207
  end1 = arg_ulong_index_integer(3, len1 + 1UL);
#line 207
  start1 = arg_ulong_index_integer(2, end1 + 1UL);
#line 207
  ptr2 = arg_extended_string(4U, & len2);
#line 207
  start2 = arg_ulong_index_integer(5, len2 + 1UL);
#line 207
  length = end1 - start1;
#line 207
  end2 = start2 + length;
  }
#line 207
  if (end2 > len2) {
    {
#line 207
    error_bad_range_arg(5);
    }
  }
#line 208
  scan1 = ptr1 + end1;
#line 209
  scan2 = ptr2 + end2;
#line 210
  limit = scan1 - length;
  {
#line 211
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 211
    if (! ((unsigned long )scan1 > (unsigned long )limit)) {
#line 211
      goto while_break___0;
    }
#line 212
    scan2 --;
#line 212
    scan1 --;
#line 212
    *scan2 = *scan1;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 213
  return ((8UL << 58U) | 1UL);
}
}
#line 216 "/home/khheo/project/mit-scheme-9.2/src/microcode/string.c"
SCHEME_OBJECT Prim_substring_move_left(void) 
{ 
  unsigned char *ptr1 ;
  unsigned char *ptr2 ;
  unsigned long len1 ;
  unsigned long len2 ;
  unsigned long start1 ;
  unsigned long end1 ;
  unsigned long start2 ;
  unsigned long end2 ;
  unsigned long length ;
  unsigned char *scan1 ;
  unsigned char *scan2 ;
  unsigned char *limit ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;

  {
  {
#line 218
  while (1) {
    while_continue: /* CIL Label */ ;
#line 218
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 218
  ptr1 = arg_extended_string(1U, & len1);
#line 218
  end1 = arg_ulong_index_integer(3, len1 + 1UL);
#line 218
  start1 = arg_ulong_index_integer(2, end1 + 1UL);
#line 218
  ptr2 = arg_extended_string(4U, & len2);
#line 218
  start2 = arg_ulong_index_integer(5, len2 + 1UL);
#line 218
  length = end1 - start1;
#line 218
  end2 = start2 + length;
  }
#line 218
  if (end2 > len2) {
    {
#line 218
    error_bad_range_arg(5);
    }
  }
#line 219
  scan1 = ptr1 + start1;
#line 220
  scan2 = ptr2 + start2;
#line 221
  limit = scan1 + length;
  {
#line 222
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 222
    if (! ((unsigned long )scan1 < (unsigned long )limit)) {
#line 222
      goto while_break___0;
    }
#line 223
    tmp = scan2;
#line 223
    scan2 ++;
#line 223
    tmp___0 = scan1;
#line 223
    scan1 ++;
#line 223
    *tmp = *tmp___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 224
  return ((8UL << 58U) | 1UL);
}
}
#line 252 "/home/khheo/project/mit-scheme-9.2/src/microcode/string.c"
SCHEME_OBJECT Prim_substring_upcase(void) 
{ 
  SCHEME_OBJECT string ;
  long start ;
  long end ;
  long length ;
  unsigned char *scan ;
  unsigned char temp ;
  unsigned char *tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
  {
#line 253
  while (1) {
    while_continue: /* CIL Label */ ;
#line 253
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 253
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 253
    if (! (*(stack_pointer + 0) >> 58U == 30UL)) {
      {
#line 253
      error_wrong_type_arg(1);
      }
    }
#line 253
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 253
  string = *(stack_pointer + 0);
#line 253
  start = arg_nonnegative_integer(2);
#line 253
  end = arg_nonnegative_integer(3);
  }
#line 253
  if ((unsigned long )end > (*((SCHEME_OBJECT *)(string & 288230376151711743UL) + 1) & 288230376151711743UL)) {
    {
#line 253
    error_bad_range_arg(3);
    }
  }
#line 253
  if (start > end) {
    {
#line 253
    error_bad_range_arg(2);
    }
  }
#line 253
  length = end - start;
#line 253
  scan = (unsigned char *)((SCHEME_OBJECT *)(string & 288230376151711743UL) + 2) + start;
  {
#line 253
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 253
    tmp___1 = length;
#line 253
    length --;
#line 253
    if (! (tmp___1 > 0L)) {
#line 253
      goto while_break___1;
    }
    {
#line 253
    temp = *scan;
#line 253
    tmp = scan;
#line 253
    scan ++;
#line 253
    tmp___0 = char_upcase((long )temp);
#line 253
    *tmp = (unsigned char )tmp___0;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 253
  return ((8UL << 58U) | 1UL);
}
}
#line 255 "/home/khheo/project/mit-scheme-9.2/src/microcode/string.c"
SCHEME_OBJECT Prim_substring_downcase(void) 
{ 
  SCHEME_OBJECT string ;
  long start ;
  long end ;
  long length ;
  unsigned char *scan ;
  unsigned char temp ;
  unsigned char *tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
  {
#line 256
  while (1) {
    while_continue: /* CIL Label */ ;
#line 256
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 256
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 256
    if (! (*(stack_pointer + 0) >> 58U == 30UL)) {
      {
#line 256
      error_wrong_type_arg(1);
      }
    }
#line 256
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 256
  string = *(stack_pointer + 0);
#line 256
  start = arg_nonnegative_integer(2);
#line 256
  end = arg_nonnegative_integer(3);
  }
#line 256
  if ((unsigned long )end > (*((SCHEME_OBJECT *)(string & 288230376151711743UL) + 1) & 288230376151711743UL)) {
    {
#line 256
    error_bad_range_arg(3);
    }
  }
#line 256
  if (start > end) {
    {
#line 256
    error_bad_range_arg(2);
    }
  }
#line 256
  length = end - start;
#line 256
  scan = (unsigned char *)((SCHEME_OBJECT *)(string & 288230376151711743UL) + 2) + start;
  {
#line 256
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 256
    tmp___1 = length;
#line 256
    length --;
#line 256
    if (! (tmp___1 > 0L)) {
#line 256
      goto while_break___1;
    }
    {
#line 256
    temp = *scan;
#line 256
    tmp = scan;
#line 256
    scan ++;
#line 256
    tmp___0 = char_downcase((long )temp);
#line 256
    *tmp = (unsigned char )tmp___0;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 256
  return ((8UL << 58U) | 1UL);
}
}
#line 281 "/home/khheo/project/mit-scheme-9.2/src/microcode/string.c"
SCHEME_OBJECT Prim_vec_8b_fill(void) 
{ 
  unsigned long start ;
  unsigned long end ;
  unsigned long length ;
  unsigned long ascii ;
  unsigned char *string_start ;
  unsigned char *scan ;
  unsigned char *limit ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  unsigned char *tmp___2 ;

  {
  {
#line 283
  while (1) {
    while_continue: /* CIL Label */ ;
#line 283
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 283
  string_start = arg_extended_string(1U, & length);
#line 283
  tmp = arg_nonnegative_integer(2);
#line 283
  start = (unsigned long )tmp;
#line 283
  tmp___0 = arg_nonnegative_integer(3);
#line 283
  end = (unsigned long )tmp___0;
#line 283
  tmp___1 = arg_ascii_integer(4);
#line 283
  ascii = (unsigned long )tmp___1;
  }
#line 283
  if (end > length) {
    {
#line 283
    error_bad_range_arg(3);
    }
  }
#line 283
  if (start > end) {
    {
#line 283
    error_bad_range_arg(2);
    }
  }
#line 283
  scan = string_start + start;
#line 283
  limit = string_start + end;
  {
#line 284
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 284
    if (! ((unsigned long )scan < (unsigned long )limit)) {
#line 284
      goto while_break___0;
    }
#line 285
    tmp___2 = scan;
#line 285
    scan ++;
#line 285
    *tmp___2 = (unsigned char )ascii;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 286
  return ((8UL << 58U) | 1UL);
}
}
#line 289 "/home/khheo/project/mit-scheme-9.2/src/microcode/string.c"
SCHEME_OBJECT Prim_vec_8b_find_next_char(void) 
{ 
  unsigned long start ;
  unsigned long end ;
  unsigned long length ;
  unsigned long ascii ;
  unsigned char *string_start ;
  unsigned char *scan ;
  unsigned char *limit ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  unsigned char *tmp___2 ;

  {
  {
#line 291
  while (1) {
    while_continue: /* CIL Label */ ;
#line 291
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 291
  string_start = arg_extended_string(1U, & length);
#line 291
  tmp = arg_nonnegative_integer(2);
#line 291
  start = (unsigned long )tmp;
#line 291
  tmp___0 = arg_nonnegative_integer(3);
#line 291
  end = (unsigned long )tmp___0;
#line 291
  tmp___1 = arg_ascii_integer(4);
#line 291
  ascii = (unsigned long )tmp___1;
  }
#line 291
  if (end > length) {
    {
#line 291
    error_bad_range_arg(3);
    }
  }
#line 291
  if (start > end) {
    {
#line 291
    error_bad_range_arg(2);
    }
  }
#line 291
  scan = string_start + start;
#line 291
  limit = string_start + end;
  {
#line 292
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 292
    if (! ((unsigned long )scan < (unsigned long )limit)) {
#line 292
      goto while_break___0;
    }
#line 293
    tmp___2 = scan;
#line 293
    scan ++;
#line 293
    if ((unsigned long )*tmp___2 == ascii) {
#line 294
      return ((26UL << 58U) | (unsigned long )((scan - 1) - string_start));
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 295
  return (0UL);
}
}
#line 298 "/home/khheo/project/mit-scheme-9.2/src/microcode/string.c"
SCHEME_OBJECT Prim_vec_8b_find_prev_char(void) 
{ 
  unsigned long start ;
  unsigned long end ;
  unsigned long length ;
  unsigned long ascii ;
  unsigned char *string_start ;
  unsigned char *scan ;
  unsigned char *limit ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
  {
#line 300
  while (1) {
    while_continue: /* CIL Label */ ;
#line 300
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 300
  string_start = arg_extended_string(1U, & length);
#line 300
  tmp = arg_nonnegative_integer(2);
#line 300
  start = (unsigned long )tmp;
#line 300
  tmp___0 = arg_nonnegative_integer(3);
#line 300
  end = (unsigned long )tmp___0;
#line 300
  tmp___1 = arg_ascii_integer(4);
#line 300
  ascii = (unsigned long )tmp___1;
  }
#line 300
  if (end > length) {
    {
#line 300
    error_bad_range_arg(3);
    }
  }
#line 300
  if (start > end) {
    {
#line 300
    error_bad_range_arg(2);
    }
  }
#line 300
  scan = string_start + end;
#line 300
  limit = string_start + start;
  {
#line 301
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 301
    if (! ((unsigned long )scan > (unsigned long )limit)) {
#line 301
      goto while_break___0;
    }
#line 302
    scan --;
#line 302
    if ((unsigned long )*scan == ascii) {
#line 303
      return ((26UL << 58U) | (unsigned long )(scan - string_start));
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 304
  return (0UL);
}
}
#line 307 "/home/khheo/project/mit-scheme-9.2/src/microcode/string.c"
SCHEME_OBJECT Prim_vec_8b_find_next_char_ci(void) 
{ 
  unsigned long start ;
  unsigned long end ;
  unsigned long length ;
  unsigned long ascii ;
  unsigned char *string_start ;
  unsigned char *scan ;
  unsigned char *limit ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  unsigned char char1 ;
  long tmp___2 ;
  unsigned char *tmp___3 ;
  long tmp___4 ;

  {
  {
#line 309
  while (1) {
    while_continue: /* CIL Label */ ;
#line 309
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 309
  string_start = arg_extended_string(1U, & length);
#line 309
  tmp = arg_nonnegative_integer(2);
#line 309
  start = (unsigned long )tmp;
#line 309
  tmp___0 = arg_nonnegative_integer(3);
#line 309
  end = (unsigned long )tmp___0;
#line 309
  tmp___1 = arg_ascii_integer(4);
#line 309
  ascii = (unsigned long )tmp___1;
  }
#line 309
  if (end > length) {
    {
#line 309
    error_bad_range_arg(3);
    }
  }
#line 309
  if (start > end) {
    {
#line 309
    error_bad_range_arg(2);
    }
  }
  {
#line 309
  scan = string_start + start;
#line 309
  limit = string_start + end;
#line 311
  tmp___2 = char_upcase((long )ascii);
#line 311
  char1 = (unsigned char )tmp___2;
  }
  {
#line 312
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 312
    if (! ((unsigned long )scan < (unsigned long )limit)) {
#line 312
      goto while_break___0;
    }
    {
#line 313
    tmp___3 = scan;
#line 313
    scan ++;
#line 313
    tmp___4 = char_upcase((long )*tmp___3);
    }
#line 313
    if (tmp___4 == (long )char1) {
#line 314
      return ((26UL << 58U) | (unsigned long )((scan - 1) - string_start));
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 316
  return (0UL);
}
}
#line 319 "/home/khheo/project/mit-scheme-9.2/src/microcode/string.c"
SCHEME_OBJECT Prim_vec_8b_find_prev_char_ci(void) 
{ 
  unsigned long start ;
  unsigned long end ;
  unsigned long length ;
  unsigned long ascii ;
  unsigned char *string_start ;
  unsigned char *scan ;
  unsigned char *limit ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  unsigned char char1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
  {
#line 321
  while (1) {
    while_continue: /* CIL Label */ ;
#line 321
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 321
  string_start = arg_extended_string(1U, & length);
#line 321
  tmp = arg_nonnegative_integer(2);
#line 321
  start = (unsigned long )tmp;
#line 321
  tmp___0 = arg_nonnegative_integer(3);
#line 321
  end = (unsigned long )tmp___0;
#line 321
  tmp___1 = arg_ascii_integer(4);
#line 321
  ascii = (unsigned long )tmp___1;
  }
#line 321
  if (end > length) {
    {
#line 321
    error_bad_range_arg(3);
    }
  }
#line 321
  if (start > end) {
    {
#line 321
    error_bad_range_arg(2);
    }
  }
  {
#line 321
  scan = string_start + end;
#line 321
  limit = string_start + start;
#line 323
  tmp___2 = char_upcase((long )ascii);
#line 323
  char1 = (unsigned char )tmp___2;
  }
  {
#line 324
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 324
    if (! ((unsigned long )scan > (unsigned long )limit)) {
#line 324
      goto while_break___0;
    }
    {
#line 325
    scan --;
#line 325
    tmp___3 = char_upcase((long )*scan);
    }
#line 325
    if (tmp___3 == (long )char1) {
#line 326
      return ((26UL << 58U) | (unsigned long )(scan - string_start));
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 328
  return (0UL);
}
}
#line 347 "/home/khheo/project/mit-scheme-9.2/src/microcode/string.c"
SCHEME_OBJECT Prim_find_next_char_in_set(void) 
{ 
  unsigned long start ;
  unsigned long end ;
  unsigned long length ;
  unsigned char *char_set ;
  unsigned char *string_start ;
  unsigned char *scan ;
  unsigned char *limit ;
  long tmp ;
  long tmp___0 ;
  unsigned char *tmp___1 ;

  {
  {
#line 349
  while (1) {
    while_continue: /* CIL Label */ ;
#line 349
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 349
  string_start = arg_extended_string(1U, & length);
#line 349
  tmp = arg_nonnegative_integer(2);
#line 349
  start = (unsigned long )tmp;
#line 349
  tmp___0 = arg_nonnegative_integer(3);
#line 349
  end = (unsigned long )tmp___0;
  }
  {
#line 349
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 349
    if (! (*(stack_pointer + 3) >> 58U == 30UL)) {
      {
#line 349
      error_wrong_type_arg(4);
      }
    }
#line 349
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 349
  char_set = (unsigned char *)((SCHEME_OBJECT *)(*(stack_pointer + 3) & 288230376151711743UL) + 2) + 0;
#line 349
  if (end > length) {
    {
#line 349
    error_bad_range_arg(3);
    }
  }
#line 349
  if (start > end) {
    {
#line 349
    error_bad_range_arg(2);
    }
  }
#line 349
  if ((*((SCHEME_OBJECT *)(*(stack_pointer + 3) & 288230376151711743UL) + 1) & 288230376151711743UL) != 1UL << 8) {
    {
#line 349
    error_bad_range_arg(4);
    }
  }
#line 350
  scan = string_start + start;
#line 351
  limit = string_start + end;
  {
#line 352
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 352
    if (! ((unsigned long )scan < (unsigned long )limit)) {
#line 352
      goto while_break___1;
    }
#line 353
    tmp___1 = scan;
#line 353
    scan ++;
#line 353
    if ((int )*(char_set + *tmp___1) != 0) {
#line 354
      return ((26UL << 58U) | (unsigned long )((scan - 1) - string_start));
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 355
  return (0UL);
}
}
#line 358 "/home/khheo/project/mit-scheme-9.2/src/microcode/string.c"
SCHEME_OBJECT Prim_find_prev_char_in_set(void) 
{ 
  unsigned long start ;
  unsigned long end ;
  unsigned long length ;
  unsigned char *char_set ;
  unsigned char *string_start ;
  unsigned char *scan ;
  unsigned char *limit ;
  long tmp ;
  long tmp___0 ;

  {
  {
#line 360
  while (1) {
    while_continue: /* CIL Label */ ;
#line 360
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 360
  string_start = arg_extended_string(1U, & length);
#line 360
  tmp = arg_nonnegative_integer(2);
#line 360
  start = (unsigned long )tmp;
#line 360
  tmp___0 = arg_nonnegative_integer(3);
#line 360
  end = (unsigned long )tmp___0;
  }
  {
#line 360
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 360
    if (! (*(stack_pointer + 3) >> 58U == 30UL)) {
      {
#line 360
      error_wrong_type_arg(4);
      }
    }
#line 360
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 360
  char_set = (unsigned char *)((SCHEME_OBJECT *)(*(stack_pointer + 3) & 288230376151711743UL) + 2) + 0;
#line 360
  if (end > length) {
    {
#line 360
    error_bad_range_arg(3);
    }
  }
#line 360
  if (start > end) {
    {
#line 360
    error_bad_range_arg(2);
    }
  }
#line 360
  if ((*((SCHEME_OBJECT *)(*(stack_pointer + 3) & 288230376151711743UL) + 1) & 288230376151711743UL) != 1UL << 8) {
    {
#line 360
    error_bad_range_arg(4);
    }
  }
#line 361
  scan = string_start + end;
#line 362
  limit = string_start + start;
  {
#line 363
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 363
    if (! ((unsigned long )scan > (unsigned long )limit)) {
#line 363
      goto while_break___1;
    }
#line 364
    scan --;
#line 364
    if ((int )*(char_set + *scan) != 0) {
#line 365
      return ((26UL << 58U) | (unsigned long )(scan - string_start));
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 366
  return (0UL);
}
}
#line 399 "/home/khheo/project/mit-scheme-9.2/src/microcode/string.c"
SCHEME_OBJECT Prim_substring_equal(void) 
{ 
  unsigned char *scan1 ;
  unsigned char *scan2 ;
  unsigned char *limit ;
  long start1 ;
  long end1 ;
  long start2 ;
  long end2 ;
  unsigned char *string1_start ;
  unsigned char *string2_start ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;

  {
  {
#line 401
  while (1) {
    while_continue: /* CIL Label */ ;
#line 401
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 401
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 401
    if (! (*(stack_pointer + 0) >> 58U == 30UL)) {
      {
#line 401
      error_wrong_type_arg(1);
      }
    }
#line 401
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 401
  string1_start = (unsigned char *)((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 2) + 0;
#line 401
  start1 = arg_nonnegative_integer(2);
#line 401
  end1 = arg_nonnegative_integer(3);
  }
  {
#line 401
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 401
    if (! (*(stack_pointer + 3) >> 58U == 30UL)) {
      {
#line 401
      error_wrong_type_arg(4);
      }
    }
#line 401
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 401
  string2_start = (unsigned char *)((SCHEME_OBJECT *)(*(stack_pointer + 3) & 288230376151711743UL) + 2) + 0;
#line 401
  start2 = arg_nonnegative_integer(5);
#line 401
  end2 = arg_nonnegative_integer(6);
  }
#line 401
  if ((unsigned long )end1 > (*((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 1) & 288230376151711743UL)) {
    {
#line 401
    error_bad_range_arg(3);
    }
  }
#line 401
  if (start1 > end1) {
    {
#line 401
    error_bad_range_arg(2);
    }
  }
#line 401
  if ((unsigned long )end2 > (*((SCHEME_OBJECT *)(*(stack_pointer + 3) & 288230376151711743UL) + 1) & 288230376151711743UL)) {
    {
#line 401
    error_bad_range_arg(6);
    }
  }
#line 401
  if (start2 > end2) {
    {
#line 401
    error_bad_range_arg(5);
    }
  }
#line 401
  if (end1 - start1 != end2 - start2) {
#line 401
    return (0UL);
  }
#line 401
  scan1 = string1_start + start1;
#line 401
  limit = string1_start + end1;
#line 401
  scan2 = string2_start + start2;
  {
#line 402
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 402
    if (! ((unsigned long )scan1 < (unsigned long )limit)) {
#line 402
      goto while_break___2;
    }
#line 403
    tmp = scan1;
#line 403
    scan1 ++;
#line 403
    tmp___0 = scan2;
#line 403
    scan2 ++;
#line 403
    if ((int )*tmp != (int )*tmp___0) {
#line 404
      return (0UL);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 405
  return (8UL << 58U);
}
}
#line 408 "/home/khheo/project/mit-scheme-9.2/src/microcode/string.c"
SCHEME_OBJECT Prim_substring_ci_equal(void) 
{ 
  unsigned char *scan1 ;
  unsigned char *scan2 ;
  unsigned char *limit ;
  long start1 ;
  long end1 ;
  long start2 ;
  long end2 ;
  unsigned char *string1_start ;
  unsigned char *string2_start ;
  unsigned char *tmp ;
  long tmp___0 ;
  unsigned char *tmp___1 ;
  long tmp___2 ;

  {
  {
#line 410
  while (1) {
    while_continue: /* CIL Label */ ;
#line 410
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 410
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 410
    if (! (*(stack_pointer + 0) >> 58U == 30UL)) {
      {
#line 410
      error_wrong_type_arg(1);
      }
    }
#line 410
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 410
  string1_start = (unsigned char *)((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 2) + 0;
#line 410
  start1 = arg_nonnegative_integer(2);
#line 410
  end1 = arg_nonnegative_integer(3);
  }
  {
#line 410
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 410
    if (! (*(stack_pointer + 3) >> 58U == 30UL)) {
      {
#line 410
      error_wrong_type_arg(4);
      }
    }
#line 410
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 410
  string2_start = (unsigned char *)((SCHEME_OBJECT *)(*(stack_pointer + 3) & 288230376151711743UL) + 2) + 0;
#line 410
  start2 = arg_nonnegative_integer(5);
#line 410
  end2 = arg_nonnegative_integer(6);
  }
#line 410
  if ((unsigned long )end1 > (*((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 1) & 288230376151711743UL)) {
    {
#line 410
    error_bad_range_arg(3);
    }
  }
#line 410
  if (start1 > end1) {
    {
#line 410
    error_bad_range_arg(2);
    }
  }
#line 410
  if ((unsigned long )end2 > (*((SCHEME_OBJECT *)(*(stack_pointer + 3) & 288230376151711743UL) + 1) & 288230376151711743UL)) {
    {
#line 410
    error_bad_range_arg(6);
    }
  }
#line 410
  if (start2 > end2) {
    {
#line 410
    error_bad_range_arg(5);
    }
  }
#line 410
  if (end1 - start1 != end2 - start2) {
#line 410
    return (0UL);
  }
#line 410
  scan1 = string1_start + start1;
#line 410
  limit = string1_start + end1;
#line 410
  scan2 = string2_start + start2;
  {
#line 411
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 411
    if (! ((unsigned long )scan1 < (unsigned long )limit)) {
#line 411
      goto while_break___2;
    }
    {
#line 412
    tmp = scan1;
#line 412
    scan1 ++;
#line 412
    tmp___0 = char_upcase((long )*tmp);
#line 412
    tmp___1 = scan2;
#line 412
    scan2 ++;
#line 412
    tmp___2 = char_upcase((long )*tmp___1);
    }
#line 412
    if (tmp___0 != tmp___2) {
#line 413
      return (0UL);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 414
  return (8UL << 58U);
}
}
#line 417 "/home/khheo/project/mit-scheme-9.2/src/microcode/string.c"
SCHEME_OBJECT Prim_substring_less(void) 
{ 
  long start1 ;
  long end1 ;
  long start2 ;
  long end2 ;
  unsigned char *string1_start ;
  unsigned char *string2_start ;
  unsigned char *scan1 ;
  unsigned char *scan2 ;
  long length1 ;
  long length2 ;
  unsigned char *limit ;
  long tmp ;
  unsigned long tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;
  unsigned long tmp___3 ;

  {
  {
#line 419
  while (1) {
    while_continue: /* CIL Label */ ;
#line 419
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 419
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 419
    if (! (*(stack_pointer + 0) >> 58U == 30UL)) {
      {
#line 419
      error_wrong_type_arg(1);
      }
    }
#line 419
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 419
  string1_start = (unsigned char *)((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 2) + 0;
#line 419
  start1 = arg_nonnegative_integer(2);
#line 419
  end1 = arg_nonnegative_integer(3);
  }
  {
#line 419
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 419
    if (! (*(stack_pointer + 3) >> 58U == 30UL)) {
      {
#line 419
      error_wrong_type_arg(4);
      }
    }
#line 419
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 419
  string2_start = (unsigned char *)((SCHEME_OBJECT *)(*(stack_pointer + 3) & 288230376151711743UL) + 2) + 0;
#line 419
  start2 = arg_nonnegative_integer(5);
#line 419
  end2 = arg_nonnegative_integer(6);
  }
#line 419
  if ((unsigned long )end1 > (*((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 1) & 288230376151711743UL)) {
    {
#line 419
    error_bad_range_arg(3);
    }
  }
#line 419
  if (start1 > end1) {
    {
#line 419
    error_bad_range_arg(2);
    }
  }
#line 419
  if ((unsigned long )end2 > (*((SCHEME_OBJECT *)(*(stack_pointer + 3) & 288230376151711743UL) + 1) & 288230376151711743UL)) {
    {
#line 419
    error_bad_range_arg(6);
    }
  }
#line 419
  if (start2 > end2) {
    {
#line 419
    error_bad_range_arg(5);
    }
  }
#line 421
  scan1 = string1_start + start1;
#line 422
  scan2 = string2_start + start2;
#line 423
  length1 = end1 - start1;
#line 424
  length2 = end2 - start2;
#line 425
  if (length1 < length2) {
#line 425
    tmp = length1;
  } else {
#line 425
    tmp = length2;
  }
#line 425
  limit = scan1 + tmp;
  {
#line 427
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 427
    if (! ((unsigned long )scan1 < (unsigned long )limit)) {
#line 427
      goto while_break___2;
    }
#line 428
    tmp___1 = scan1;
#line 428
    scan1 ++;
#line 428
    tmp___2 = scan2;
#line 428
    scan2 ++;
#line 428
    if ((int )*tmp___1 != (int )*tmp___2) {
#line 429
      if ((int )*(scan1 + -1) < (int )*(scan2 + -1)) {
#line 429
        tmp___0 = 8UL << 58U;
      } else {
#line 429
        tmp___0 = 0UL;
      }
#line 429
      return (tmp___0);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 430
  if (length1 < length2) {
#line 430
    tmp___3 = 8UL << 58U;
  } else {
#line 430
    tmp___3 = 0UL;
  }
#line 430
  return (tmp___3);
}
}
#line 434 "/home/khheo/project/mit-scheme-9.2/src/microcode/string.c"
static long substring_length_min(long start1 , long end1 , long start2 , long end2 ) 
{ 
  long length1 ;
  long length2 ;
  long tmp ;

  {
#line 440
  length1 = end1 - start1;
#line 441
  length2 = end2 - start2;
#line 442
  if (length1 < length2) {
#line 442
    tmp = length1;
  } else {
#line 442
    tmp = length2;
  }
#line 442
  return (tmp);
}
}
#line 452 "/home/khheo/project/mit-scheme-9.2/src/microcode/string.c"
SCHEME_OBJECT Prim_match_forward(void) 
{ 
  unsigned char *scan1 ;
  unsigned char *scan2 ;
  unsigned char *limit ;
  long length ;
  unsigned char *scan1_start ;
  long start1 ;
  long end1 ;
  long start2 ;
  long end2 ;
  unsigned char *string1_start ;
  unsigned char *string2_start ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;

  {
  {
#line 454
  while (1) {
    while_continue: /* CIL Label */ ;
#line 454
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 454
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 454
    if (! (*(stack_pointer + 0) >> 58U == 30UL)) {
      {
#line 454
      error_wrong_type_arg(1);
      }
    }
#line 454
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 454
  string1_start = (unsigned char *)((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 2) + 0;
#line 454
  start1 = arg_nonnegative_integer(2);
#line 454
  end1 = arg_nonnegative_integer(3);
  }
  {
#line 454
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 454
    if (! (*(stack_pointer + 3) >> 58U == 30UL)) {
      {
#line 454
      error_wrong_type_arg(4);
      }
    }
#line 454
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 454
  string2_start = (unsigned char *)((SCHEME_OBJECT *)(*(stack_pointer + 3) & 288230376151711743UL) + 2) + 0;
#line 454
  start2 = arg_nonnegative_integer(5);
#line 454
  end2 = arg_nonnegative_integer(6);
  }
#line 454
  if ((unsigned long )end1 > (*((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 1) & 288230376151711743UL)) {
    {
#line 454
    error_bad_range_arg(3);
    }
  }
#line 454
  if (start1 > end1) {
    {
#line 454
    error_bad_range_arg(2);
    }
  }
#line 454
  if ((unsigned long )end2 > (*((SCHEME_OBJECT *)(*(stack_pointer + 3) & 288230376151711743UL) + 1) & 288230376151711743UL)) {
    {
#line 454
    error_bad_range_arg(6);
    }
  }
#line 454
  if (start2 > end2) {
    {
#line 454
    error_bad_range_arg(5);
    }
  }
  {
#line 454
  length = substring_length_min(start1, end1, start2, end2);
#line 455
  scan1 = string1_start + start1;
#line 456
  scan2 = string2_start + start2;
#line 457
  limit = scan1 + length;
#line 458
  scan1_start = scan1;
  }
  {
#line 459
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 459
    if (! ((unsigned long )scan1 < (unsigned long )limit)) {
#line 459
      goto while_break___2;
    }
#line 460
    tmp = scan1;
#line 460
    scan1 ++;
#line 460
    tmp___0 = scan2;
#line 460
    scan2 ++;
#line 460
    if ((int )*tmp != (int )*tmp___0) {
#line 461
      return ((26UL << 58U) | (unsigned long )((scan1 - 1) - scan1_start));
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 462
  return ((26UL << 58U) | (unsigned long )length);
}
}
#line 465 "/home/khheo/project/mit-scheme-9.2/src/microcode/string.c"
SCHEME_OBJECT Prim_match_forward_ci(void) 
{ 
  unsigned char *scan1 ;
  unsigned char *scan2 ;
  unsigned char *limit ;
  long length ;
  unsigned char *scan1_start ;
  long start1 ;
  long end1 ;
  long start2 ;
  long end2 ;
  unsigned char *string1_start ;
  unsigned char *string2_start ;
  unsigned char *tmp ;
  long tmp___0 ;
  unsigned char *tmp___1 ;
  long tmp___2 ;

  {
  {
#line 467
  while (1) {
    while_continue: /* CIL Label */ ;
#line 467
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 467
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 467
    if (! (*(stack_pointer + 0) >> 58U == 30UL)) {
      {
#line 467
      error_wrong_type_arg(1);
      }
    }
#line 467
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 467
  string1_start = (unsigned char *)((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 2) + 0;
#line 467
  start1 = arg_nonnegative_integer(2);
#line 467
  end1 = arg_nonnegative_integer(3);
  }
  {
#line 467
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 467
    if (! (*(stack_pointer + 3) >> 58U == 30UL)) {
      {
#line 467
      error_wrong_type_arg(4);
      }
    }
#line 467
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 467
  string2_start = (unsigned char *)((SCHEME_OBJECT *)(*(stack_pointer + 3) & 288230376151711743UL) + 2) + 0;
#line 467
  start2 = arg_nonnegative_integer(5);
#line 467
  end2 = arg_nonnegative_integer(6);
  }
#line 467
  if ((unsigned long )end1 > (*((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 1) & 288230376151711743UL)) {
    {
#line 467
    error_bad_range_arg(3);
    }
  }
#line 467
  if (start1 > end1) {
    {
#line 467
    error_bad_range_arg(2);
    }
  }
#line 467
  if ((unsigned long )end2 > (*((SCHEME_OBJECT *)(*(stack_pointer + 3) & 288230376151711743UL) + 1) & 288230376151711743UL)) {
    {
#line 467
    error_bad_range_arg(6);
    }
  }
#line 467
  if (start2 > end2) {
    {
#line 467
    error_bad_range_arg(5);
    }
  }
  {
#line 467
  length = substring_length_min(start1, end1, start2, end2);
#line 468
  scan1 = string1_start + start1;
#line 469
  scan2 = string2_start + start2;
#line 470
  limit = scan1 + length;
#line 471
  scan1_start = scan1;
  }
  {
#line 472
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 472
    if (! ((unsigned long )scan1 < (unsigned long )limit)) {
#line 472
      goto while_break___2;
    }
    {
#line 473
    tmp = scan1;
#line 473
    scan1 ++;
#line 473
    tmp___0 = char_upcase((long )*tmp);
#line 473
    tmp___1 = scan2;
#line 473
    scan2 ++;
#line 473
    tmp___2 = char_upcase((long )*tmp___1);
    }
#line 473
    if (tmp___0 != tmp___2) {
#line 474
      return ((26UL << 58U) | (unsigned long )((scan1 - 1) - scan1_start));
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 475
  return ((26UL << 58U) | (unsigned long )length);
}
}
#line 478 "/home/khheo/project/mit-scheme-9.2/src/microcode/string.c"
SCHEME_OBJECT Prim_match_backward(void) 
{ 
  unsigned char *scan1 ;
  unsigned char *scan2 ;
  unsigned char *limit ;
  long length ;
  unsigned char *scan1_start ;
  long start1 ;
  long end1 ;
  long start2 ;
  long end2 ;
  unsigned char *string1_start ;
  unsigned char *string2_start ;

  {
  {
#line 480
  while (1) {
    while_continue: /* CIL Label */ ;
#line 480
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 480
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 480
    if (! (*(stack_pointer + 0) >> 58U == 30UL)) {
      {
#line 480
      error_wrong_type_arg(1);
      }
    }
#line 480
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 480
  string1_start = (unsigned char *)((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 2) + 0;
#line 480
  start1 = arg_nonnegative_integer(2);
#line 480
  end1 = arg_nonnegative_integer(3);
  }
  {
#line 480
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 480
    if (! (*(stack_pointer + 3) >> 58U == 30UL)) {
      {
#line 480
      error_wrong_type_arg(4);
      }
    }
#line 480
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 480
  string2_start = (unsigned char *)((SCHEME_OBJECT *)(*(stack_pointer + 3) & 288230376151711743UL) + 2) + 0;
#line 480
  start2 = arg_nonnegative_integer(5);
#line 480
  end2 = arg_nonnegative_integer(6);
  }
#line 480
  if ((unsigned long )end1 > (*((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 1) & 288230376151711743UL)) {
    {
#line 480
    error_bad_range_arg(3);
    }
  }
#line 480
  if (start1 > end1) {
    {
#line 480
    error_bad_range_arg(2);
    }
  }
#line 480
  if ((unsigned long )end2 > (*((SCHEME_OBJECT *)(*(stack_pointer + 3) & 288230376151711743UL) + 1) & 288230376151711743UL)) {
    {
#line 480
    error_bad_range_arg(6);
    }
  }
#line 480
  if (start2 > end2) {
    {
#line 480
    error_bad_range_arg(5);
    }
  }
  {
#line 480
  length = substring_length_min(start1, end1, start2, end2);
#line 481
  scan1 = string1_start + end1;
#line 482
  scan2 = string2_start + end2;
#line 483
  limit = scan1 - length;
#line 484
  scan1_start = scan1;
  }
  {
#line 485
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 485
    if (! ((unsigned long )scan1 > (unsigned long )limit)) {
#line 485
      goto while_break___2;
    }
#line 486
    scan1 --;
#line 486
    scan2 --;
#line 486
    if ((int )*scan1 != (int )*scan2) {
#line 487
      return ((26UL << 58U) | (unsigned long )(scan1_start - (scan1 + 1)));
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 488
  return ((26UL << 58U) | (unsigned long )length);
}
}
#line 491 "/home/khheo/project/mit-scheme-9.2/src/microcode/string.c"
SCHEME_OBJECT Prim_match_backward_ci(void) 
{ 
  unsigned char *scan1 ;
  unsigned char *scan2 ;
  unsigned char *limit ;
  long length ;
  unsigned char *scan1_start ;
  long start1 ;
  long end1 ;
  long start2 ;
  long end2 ;
  unsigned char *string1_start ;
  unsigned char *string2_start ;
  long tmp ;
  long tmp___0 ;

  {
  {
#line 493
  while (1) {
    while_continue: /* CIL Label */ ;
#line 493
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 493
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 493
    if (! (*(stack_pointer + 0) >> 58U == 30UL)) {
      {
#line 493
      error_wrong_type_arg(1);
      }
    }
#line 493
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 493
  string1_start = (unsigned char *)((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 2) + 0;
#line 493
  start1 = arg_nonnegative_integer(2);
#line 493
  end1 = arg_nonnegative_integer(3);
  }
  {
#line 493
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 493
    if (! (*(stack_pointer + 3) >> 58U == 30UL)) {
      {
#line 493
      error_wrong_type_arg(4);
      }
    }
#line 493
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 493
  string2_start = (unsigned char *)((SCHEME_OBJECT *)(*(stack_pointer + 3) & 288230376151711743UL) + 2) + 0;
#line 493
  start2 = arg_nonnegative_integer(5);
#line 493
  end2 = arg_nonnegative_integer(6);
  }
#line 493
  if ((unsigned long )end1 > (*((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 1) & 288230376151711743UL)) {
    {
#line 493
    error_bad_range_arg(3);
    }
  }
#line 493
  if (start1 > end1) {
    {
#line 493
    error_bad_range_arg(2);
    }
  }
#line 493
  if ((unsigned long )end2 > (*((SCHEME_OBJECT *)(*(stack_pointer + 3) & 288230376151711743UL) + 1) & 288230376151711743UL)) {
    {
#line 493
    error_bad_range_arg(6);
    }
  }
#line 493
  if (start2 > end2) {
    {
#line 493
    error_bad_range_arg(5);
    }
  }
  {
#line 493
  length = substring_length_min(start1, end1, start2, end2);
#line 494
  scan1 = string1_start + end1;
#line 495
  scan2 = string2_start + end2;
#line 496
  limit = scan1 - length;
#line 497
  scan1_start = scan1;
  }
  {
#line 498
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 498
    if (! ((unsigned long )scan1 > (unsigned long )limit)) {
#line 498
      goto while_break___2;
    }
    {
#line 499
    scan1 --;
#line 499
    tmp = char_upcase((long )*scan1);
#line 499
    scan2 --;
#line 499
    tmp___0 = char_upcase((long )*scan2);
    }
#line 499
    if (tmp != tmp___0) {
#line 500
      return ((26UL << 58U) | (unsigned long )(scan1_start - (scan1 + 1)));
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 501
  return ((26UL << 58U) | (unsigned long )length);
}
}
#line 538
static hash_table_t *make_hash_table(void) ;
#line 539
static void ht_resize(hash_table_t *table___3 , unsigned long new_n_buckets ) ;
#line 540
static void zero_ht_buckets(hash_table_t *table___3 ) ;
#line 541
static ht_record_t *ht_records_list(hash_table_t *table___3 ) ;
#line 542
static ht_record_t *ht_lookup(hash_table_t *table___3 , unsigned long key ) ;
#line 543
static unsigned long ht_insert(hash_table_t *table___3 , ht_record_t *record ) ;
#line 544
static ht_record_t *ht_delete(hash_table_t *table___3 , unsigned long key ) ;
#line 546 "/home/khheo/project/mit-scheme-9.2/src/microcode/string.c"
static hash_table_t *external_strings  =    (hash_table_t *)0;
#line 548 "/home/khheo/project/mit-scheme-9.2/src/microcode/string.c"
SCHEME_OBJECT Prim_alloc_external_string(void) 
{ 
  unsigned long n_bytes ;
  unsigned long tmp ;
  ht_record_t *result ;
  void *tmp___0 ;
  unsigned long tmp___1 ;
  SCHEME_OBJECT tmp___2 ;

  {
  {
#line 550
  while (1) {
    while_continue: /* CIL Label */ ;
#line 550
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 552
  tmp = arg_ulong_integer(1);
#line 552
  n_bytes = tmp;
#line 553
  tmp___0 = malloc((n_bytes + 1UL) + sizeof(ht_record_t ));
#line 553
  result = (ht_record_t *)tmp___0;
  }
#line 554
  if ((unsigned long )result == (unsigned long )((ht_record_t *)0)) {
    {
#line 555
    error_bad_range_arg(1);
    }
  }
#line 556
  if ((unsigned long )external_strings == (unsigned long )((hash_table_t *)0)) {
    {
#line 557
    external_strings = make_hash_table();
    }
  }
  {
#line 558
  result->n_bytes = n_bytes;
#line 560
  *((char *)((void *)(result + 1)) + n_bytes) = (char )'\000';
#line 561
  tmp___1 = ht_insert(external_strings, result);
#line 561
  tmp___2 = ulong_to_integer(tmp___1);
  }
#line 561
  return (tmp___2);
}
}
#line 565 "/home/khheo/project/mit-scheme-9.2/src/microcode/string.c"
SCHEME_OBJECT Prim_external_string_p(void) 
{ 
  SCHEME_OBJECT x ;
  ht_record_t *record ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  _Bool tmp___1 ;

  {
  {
#line 567
  while (1) {
    while_continue: /* CIL Label */ ;
#line 567
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 569
  x = *(stack_pointer + 0);
#line 570
  if (x >> 58U == 26UL) {
#line 570
    goto _L;
  } else
#line 570
  if (x >> 58U == 14UL) {
    _L: /* CIL Label */ 
    {
#line 570
    tmp___1 = integer_to_ulong_p(x);
    }
#line 570
    if (tmp___1) {
#line 573
      if ((unsigned long )external_strings == (unsigned long )((hash_table_t *)0)) {
        {
#line 574
        external_strings = make_hash_table();
        }
      }
      {
#line 575
      tmp = integer_to_ulong(x);
#line 575
      record = ht_lookup(external_strings, tmp);
      }
#line 576
      if ((unsigned long )record != (unsigned long )((ht_record_t *)0)) {
#line 576
        tmp___0 = 8UL << 58U;
      } else {
#line 576
        tmp___0 = 0UL;
      }
#line 576
      return (tmp___0);
    } else {
#line 579
      return (0UL);
    }
  } else {
#line 579
    return (0UL);
  }
}
}
#line 583 "/home/khheo/project/mit-scheme-9.2/src/microcode/string.c"
SCHEME_OBJECT Prim_dealloc_external_string(void) 
{ 
  unsigned long n ;
  unsigned long tmp ;
  ht_record_t *record ;

  {
  {
#line 585
  while (1) {
    while_continue: /* CIL Label */ ;
#line 585
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 587
  tmp = arg_ulong_integer(1);
#line 587
  n = tmp;
  }
#line 589
  if ((unsigned long )external_strings == (unsigned long )((hash_table_t *)0)) {
    {
#line 590
    external_strings = make_hash_table();
    }
  }
  {
#line 591
  record = ht_delete(external_strings, n);
  }
#line 592
  if ((unsigned long )record == (unsigned long )((ht_record_t *)0)) {
    {
#line 593
    error_wrong_type_arg(1);
    }
  }
  {
#line 594
  free((void *)record);
  }
#line 595
  return ((8UL << 58U) | 1UL);
}
}
#line 599 "/home/khheo/project/mit-scheme-9.2/src/microcode/string.c"
SCHEME_OBJECT Prim_extended_string_length(void) 
{ 
  unsigned long len ;
  SCHEME_OBJECT tmp ;

  {
  {
#line 601
  while (1) {
    while_continue: /* CIL Label */ ;
#line 601
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 604
  arg_extended_string(1U, & len);
#line 605
  tmp = ulong_to_integer(len);
  }
#line 605
  return (tmp);
}
}
#line 609 "/home/khheo/project/mit-scheme-9.2/src/microcode/string.c"
unsigned char *lookup_external_string(SCHEME_OBJECT descriptor , unsigned long *lp ) 
{ 
  ht_record_t *record ;
  unsigned long tmp ;

  {
#line 613
  if ((unsigned long )external_strings == (unsigned long )((hash_table_t *)0)) {
    {
#line 614
    external_strings = make_hash_table();
    }
  }
  {
#line 615
  tmp = integer_to_ulong(descriptor);
#line 615
  record = ht_lookup(external_strings, tmp);
  }
#line 616
  if ((unsigned long )record == (unsigned long )((ht_record_t *)0)) {
#line 617
    return ((unsigned char *)0);
  }
#line 618
  if ((unsigned long )lp != (unsigned long )((unsigned long *)0)) {
#line 619
    *lp = record->n_bytes;
  }
#line 620
  return ((unsigned char *)((void *)(record + 1)));
}
}
#line 623 "/home/khheo/project/mit-scheme-9.2/src/microcode/string.c"
unsigned char *arg_extended_string(unsigned int n , unsigned long *lp ) 
{ 
  SCHEME_OBJECT object ;
  unsigned char *result ;
  unsigned char *tmp ;
  _Bool tmp___0 ;

  {
#line 626
  object = *(stack_pointer + (n - 1U));
#line 627
  if (object >> 58U == 30UL) {
#line 629
    if ((unsigned long )lp != (unsigned long )((unsigned long *)0)) {
#line 630
      *lp = *((SCHEME_OBJECT *)(object & 288230376151711743UL) + 1) & 288230376151711743UL;
    }
#line 631
    return ((unsigned char *)((char *)((SCHEME_OBJECT *)(object & 288230376151711743UL) + 2)));
  } else
#line 633
  if (object >> 58U == 26UL) {
#line 633
    goto _L;
  } else
#line 633
  if (object >> 58U == 14UL) {
    _L: /* CIL Label */ 
    {
#line 633
    tmp___0 = integer_to_ulong_p(object);
    }
#line 633
    if (tmp___0) {
      {
#line 635
      tmp = lookup_external_string(object, lp);
#line 635
      result = tmp;
      }
#line 636
      if ((unsigned long )result == (unsigned long )((unsigned char *)0)) {
        {
#line 637
        error_wrong_type_arg((int )n);
        }
      }
#line 638
      return (result);
    } else {
      {
#line 642
      error_wrong_type_arg((int )n);
      }
#line 643
      return ((unsigned char *)0);
    }
  } else {
    {
#line 642
    error_wrong_type_arg((int )n);
    }
#line 643
    return ((unsigned char *)0);
  }
}
}
#line 652 "/home/khheo/project/mit-scheme-9.2/src/microcode/string.c"
static hash_table_t *make_hash_table(void) 
{ 
  unsigned long n ;
  hash_table_t *table___3 ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 655
  n = (unsigned long )((1 << 4) - 1);
#line 656
  tmp = malloc(sizeof(hash_table_t ));
#line 656
  table___3 = (hash_table_t *)tmp;
  }
#line 657
  if ((unsigned long )table___3 == (unsigned long )((hash_table_t *)0)) {
    {
#line 658
    abort();
    }
  }
  {
#line 659
  table___3->n_records = 0UL;
#line 660
  table___3->n_buckets = n;
#line 661
  tmp___0 = malloc(n * sizeof(ht_record_t *));
#line 661
  table___3->buckets = (ht_record_t **)tmp___0;
  }
#line 662
  if ((unsigned long )table___3->buckets == (unsigned long )((ht_record_t **)0)) {
    {
#line 663
    abort();
    }
  }
  {
#line 664
  zero_ht_buckets(table___3);
  }
#line 665
  return (table___3);
}
}
#line 668 "/home/khheo/project/mit-scheme-9.2/src/microcode/string.c"
static void ht_resize(hash_table_t *table___3 , unsigned long new_n_buckets ) 
{ 
  ht_record_t **new_buckets ;
  void *tmp ;
  ht_record_t *records ;
  ht_record_t *tmp___0 ;
  ht_record_t *next ;

  {
  {
#line 672
  tmp = malloc(new_n_buckets * sizeof(ht_record_t *));
#line 672
  new_buckets = (ht_record_t **)tmp;
  }
#line 674
  if ((unsigned long )new_buckets != (unsigned long )((ht_record_t **)0)) {
    {
#line 676
    tmp___0 = ht_records_list(table___3);
#line 676
    records = tmp___0;
#line 677
    table___3->buckets = new_buckets;
#line 678
    table___3->n_buckets = new_n_buckets;
#line 679
    table___3->n_records = 0UL;
#line 680
    zero_ht_buckets(table___3);
    }
    {
#line 681
    while (1) {
      while_continue: /* CIL Label */ ;
#line 681
      if (! ((unsigned long )records != (unsigned long )((ht_record_t *)0))) {
#line 681
        goto while_break;
      }
      {
#line 683
      next = records->next;
#line 684
      ht_insert(table___3, records);
#line 685
      records = next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 688
  return;
}
}
#line 690 "/home/khheo/project/mit-scheme-9.2/src/microcode/string.c"
static void zero_ht_buckets(hash_table_t *table___3 ) 
{ 
  ht_record_t **scan ;
  ht_record_t **end ;
  ht_record_t **tmp ;

  {
#line 693
  scan = table___3->buckets;
#line 694
  end = scan + table___3->n_buckets;
  {
#line 695
  while (1) {
    while_continue: /* CIL Label */ ;
#line 695
    if (! ((unsigned long )scan < (unsigned long )end)) {
#line 695
      goto while_break;
    }
#line 696
    tmp = scan;
#line 696
    scan ++;
#line 696
    *tmp = (ht_record_t *)0;
  }
  while_break: /* CIL Label */ ;
  }
#line 697
  return;
}
}
#line 699 "/home/khheo/project/mit-scheme-9.2/src/microcode/string.c"
static ht_record_t *ht_records_list(hash_table_t *table___3 ) 
{ 
  ht_record_t **scan_buckets ;
  ht_record_t **end_buckets ;
  ht_record_t *result ;
  ht_record_t *scan ;
  ht_record_t *next ;
  ht_record_t **tmp ;

  {
#line 702
  scan_buckets = table___3->buckets;
#line 703
  end_buckets = scan_buckets + table___3->n_buckets;
#line 704
  result = (ht_record_t *)0;
  {
#line 705
  while (1) {
    while_continue: /* CIL Label */ ;
#line 705
    if (! ((unsigned long )scan_buckets < (unsigned long )end_buckets)) {
#line 705
      goto while_break;
    }
#line 707
    scan = *scan_buckets;
    {
#line 708
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 708
      if (! ((unsigned long )scan != (unsigned long )((ht_record_t *)0))) {
#line 708
        goto while_break___0;
      }
#line 710
      next = scan->next;
#line 711
      scan->next = result;
#line 712
      result = scan;
#line 713
      scan = next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 715
    tmp = scan_buckets;
#line 715
    scan_buckets ++;
#line 715
    *tmp = (ht_record_t *)0;
  }
  while_break: /* CIL Label */ ;
  }
#line 717
  return (result);
}
}
#line 720 "/home/khheo/project/mit-scheme-9.2/src/microcode/string.c"
static ht_record_t *ht_lookup(hash_table_t *table___3 , unsigned long key ) 
{ 
  unsigned long index___0 ;
  ht_record_t *record ;

  {
#line 724
  index___0 = key % table___3->n_buckets;
#line 725
  record = *(table___3->buckets + index___0);
  {
#line 726
  while (1) {
    while_continue: /* CIL Label */ ;
#line 726
    if (! ((unsigned long )record != (unsigned long )((ht_record_t *)0))) {
#line 726
      goto while_break;
    }
#line 728
    if ((unsigned long )(record + 1) == key) {
#line 729
      return (record);
    }
#line 730
    record = record->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 732
  return ((ht_record_t *)0);
}
}
#line 735 "/home/khheo/project/mit-scheme-9.2/src/microcode/string.c"
static unsigned long ht_insert(hash_table_t *table___3 , ht_record_t *record ) 
{ 
  unsigned long index___0 ;
  ht_record_t *scan ;
  unsigned int e ;
  unsigned long n ;

  {
#line 739
  index___0 = (unsigned long )(record + 1) % table___3->n_buckets;
#line 740
  scan = *(table___3->buckets + index___0);
#line 741
  record->next = (ht_record_t *)0;
#line 742
  if ((unsigned long )scan == (unsigned long )((ht_record_t *)0)) {
#line 743
    *(table___3->buckets + index___0) = record;
  } else {
    {
#line 746
    while (1) {
      while_continue: /* CIL Label */ ;
#line 746
      if (! ((unsigned long )scan->next != (unsigned long )((ht_record_t *)0))) {
#line 746
        goto while_break;
      }
#line 747
      scan = scan->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 748
    scan->next = record;
  }
#line 750
  (table___3->n_records) ++;
#line 751
  if (table___3->n_records >= table___3->n_buckets) {
#line 751
    if (table___3->n_buckets < (unsigned long )((1 << 24) - 1)) {
#line 754
      e = 4U;
      {
#line 755
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 755
        if (! (e <= 24U)) {
#line 755
          goto while_break___0;
        }
#line 757
        n = (unsigned long )((1 << e) - 1);
#line 758
        if (n > table___3->n_buckets) {
          {
#line 760
          ht_resize(table___3, n);
          }
#line 761
          goto while_break___0;
        }
#line 763
        e ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
#line 766
  return ((unsigned long )(record + 1));
}
}
#line 769 "/home/khheo/project/mit-scheme-9.2/src/microcode/string.c"
static ht_record_t *ht_delete(hash_table_t *table___3 , unsigned long key ) 
{ 
  unsigned long index___0 ;
  ht_record_t *scan ;
  ht_record_t *prev ;
  unsigned int e ;
  unsigned long n ;

  {
#line 773
  index___0 = key % table___3->n_buckets;
#line 774
  scan = *(table___3->buckets + index___0);
#line 775
  prev = (ht_record_t *)0;
  {
#line 776
  while (1) {
    while_continue: /* CIL Label */ ;
#line 778
    if ((unsigned long )scan == (unsigned long )((ht_record_t *)0)) {
#line 779
      return ((ht_record_t *)0);
    }
#line 780
    if ((unsigned long )(scan + 1) == key) {
#line 781
      goto while_break;
    }
#line 782
    prev = scan;
#line 783
    scan = scan->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 785
  if ((unsigned long )prev == (unsigned long )((ht_record_t *)0)) {
#line 786
    *(table___3->buckets + index___0) = scan->next;
  } else {
#line 788
    prev->next = scan->next;
  }
#line 789
  (table___3->n_records) --;
#line 790
  if (table___3->n_records < (table___3->n_buckets + 1UL) / 2UL - 1UL) {
#line 790
    if (table___3->n_buckets > (unsigned long )((1 << 4) - 1)) {
#line 793
      e = 24U;
      {
#line 794
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 794
        if (! (e >= 4U)) {
#line 794
          goto while_break___0;
        }
#line 796
        n = (unsigned long )((1 << e) - 1);
#line 797
        if (n < table___3->n_buckets) {
          {
#line 799
          ht_resize(table___3, n);
          }
#line 800
          goto while_break___0;
        }
#line 802
        e --;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
#line 805
  return (scan);
}
}
#line 141 "/home/khheo/project/mit-scheme-9.2/src/microcode/extern.h"
SCHEME_OBJECT *Free  ;
#line 143 "/home/khheo/project/mit-scheme-9.2/src/microcode/extern.h"
SCHEME_OBJECT *heap_alloc_limit  ;
#line 144 "/home/khheo/project/mit-scheme-9.2/src/microcode/extern.h"
SCHEME_OBJECT *heap_start  ;
#line 145 "/home/khheo/project/mit-scheme-9.2/src/microcode/extern.h"
SCHEME_OBJECT *heap_end  ;
#line 147 "/home/khheo/project/mit-scheme-9.2/src/microcode/extern.h"
SCHEME_OBJECT *stack_pointer  ;
#line 148 "/home/khheo/project/mit-scheme-9.2/src/microcode/extern.h"
SCHEME_OBJECT *stack_guard  ;
#line 149 "/home/khheo/project/mit-scheme-9.2/src/microcode/extern.h"
SCHEME_OBJECT *stack_start  ;
#line 150 "/home/khheo/project/mit-scheme-9.2/src/microcode/extern.h"
SCHEME_OBJECT *stack_end  ;
#line 152 "/home/khheo/project/mit-scheme-9.2/src/microcode/extern.h"
SCHEME_OBJECT *constant_alloc_next  ;
#line 153 "/home/khheo/project/mit-scheme-9.2/src/microcode/extern.h"
SCHEME_OBJECT *constant_start  ;
#line 154 "/home/khheo/project/mit-scheme-9.2/src/microcode/extern.h"
SCHEME_OBJECT *constant_end  ;
#line 158 "/home/khheo/project/mit-scheme-9.2/src/microcode/extern.h"
SCHEME_OBJECT *last_return_code  ;
#line 159 "/home/khheo/project/mit-scheme-9.2/src/microcode/extern.h"
SCHEME_OBJECT fixed_objects  ;
#line 161
SCHEME_OBJECT ephemeron_array ;
#line 162
unsigned long ephemeron_count ;
#line 164
char const   *CONT_PRINT_RETURN_MESSAGE ;
#line 165
char const   *CONT_PRINT_EXPR_MESSAGE ;
#line 166
char const   *RESTORE_CONT_RETURN_MESSAGE ;
#line 167
char const   *RESTORE_CONT_EXPR_MESSAGE ;
#line 169
unsigned long MAX_RETURN ;
#line 173
char const   *Abort_Names[13] ;
#line 179 "/home/khheo/project/mit-scheme-9.2/src/microcode/extern.h"
_Bool trapping  ;
#line 187 "/home/khheo/project/mit-scheme-9.2/src/microcode/extern.h"
unsigned long n_heap_blocks  ;
#line 188 "/home/khheo/project/mit-scheme-9.2/src/microcode/extern.h"
unsigned long n_constant_blocks  ;
#line 189 "/home/khheo/project/mit-scheme-9.2/src/microcode/extern.h"
unsigned long n_stack_blocks  ;
#line 191 "/home/khheo/project/mit-scheme-9.2/src/microcode/extern.h"
SCHEME_OBJECT *memory_block_start  ;
#line 192 "/home/khheo/project/mit-scheme-9.2/src/microcode/extern.h"
SCHEME_OBJECT *memory_block_end  ;
#line 194 "/home/khheo/project/mit-scheme-9.2/src/microcode/extern.h"
unsigned long heap_reserved  ;
#line 197 "/home/khheo/project/mit-scheme-9.2/src/microcode/extern.h"
unsigned long gc_space_needed  ;
#line 200 "/home/khheo/project/mit-scheme-9.2/src/microcode/extern.h"
unsigned long n_ephemerons_requested  ;
#line 201 "/home/khheo/project/mit-scheme-9.2/src/microcode/extern.h"
_Bool ephemeron_request_hard_p  ;
#line 39 "/home/khheo/project/mit-scheme-9.2/src/microcode/storage.c"
SCHEME_OBJECT *Free_primitive  =    (SCHEME_OBJECT *)0;
#line 75 "/home/khheo/project/mit-scheme-9.2/src/microcode/storage.c"
SCHEME_OBJECT ephemeron_array  =    0UL;
#line 76 "/home/khheo/project/mit-scheme-9.2/src/microcode/storage.c"
unsigned long ephemeron_count  =    0UL;
#line 123 "/home/khheo/project/mit-scheme-9.2/src/microcode/storage.c"
char const   *CONT_PRINT_RETURN_MESSAGE  =    "SAVE_CONT, return code";
#line 124 "/home/khheo/project/mit-scheme-9.2/src/microcode/storage.c"
char const   *CONT_PRINT_EXPR_MESSAGE  =    "SAVE_CONT, expression";
#line 125 "/home/khheo/project/mit-scheme-9.2/src/microcode/storage.c"
char const   *RESTORE_CONT_RETURN_MESSAGE  =    "RESTORE_CONT, return code";
#line 126 "/home/khheo/project/mit-scheme-9.2/src/microcode/storage.c"
char const   *RESTORE_CONT_EXPR_MESSAGE  =    "RESTORE_CONT, expression";
#line 130 "/home/khheo/project/mit-scheme-9.2/src/microcode/storage.c"
unsigned long MAX_RETURN  =    94UL;
#line 132 "/home/khheo/project/mit-scheme-9.2/src/microcode/storage.c"
char const   *Return_Names[95]  = 
#line 132
  {      "non-existent-continuation",      "join-stacklets",      (char const   *)0,      "internal-apply", 
        (char const   *)0,      "restore-history",      (char const   *)0,      (char const   *)0, 
        "assignment-continue",      "definition-continue",      "access-continue",      (char const   *)0, 
        "sequence-continue",      (char const   *)0,      (char const   *)0,      "conditional-decide", 
        "disjunction-decide",      (char const   *)0,      "combination-apply",      (char const   *)0, 
        (char const   *)0,      "combination-save-value",      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        "force-snap-thunk",      "reenter-compiled-code",      (char const   *)0,      (char const   *)0, 
        "normal-garbage-collect-done",      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      "pop-from-compiled-code",      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      "restore-value",      "restore-dont-copy-history", 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        "pop-return-error",      "eval-error",      "stack-marker",      "compiler-interrupt-restart", 
        (char const   *)0,      "restore-interrupt-mask",      "halt",      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      "compiler-reference-trap-restart", 
        "compiler-assignment-trap-restart",      (char const   *)0,      "compiler-operator-lookup-trap-restart",      "compiler-lookup-apply-trap-restart", 
        "compiler-safe-reference-trap-restart",      "compiler-unassigned?-trap-restart",      (char const   *)0,      "compiler-link-caches-restart", 
        "hardware-trap",      "internal-apply-val",      "compiler-error-restart"};
#line 133 "/home/khheo/project/mit-scheme-9.2/src/microcode/storage.c"
char const   *type_names[64]  = 
#line 133
  {      "false",      "pair",      "character",      "quotation", 
        (char const   *)0,      "uninterned-symbol",      "flonum",      (char const   *)0, 
        "constant",      "extended-procedure",      "vector",      "return-code", 
        (char const   *)0,      "manifest-closure",      "bignum",      "procedure", 
        "entity",      "delay",      "environment",      "promise", 
        "extended-lambda",      "comment",      "non-marked-vector",      "lambda", 
        "primitive",      "sequence",      "fixnum",      (char const   *)0, 
        "control-point",      "interned-symbol",      "string",      "access", 
        "hunk3-a",      "definition",      "broken-heart",      "assignment", 
        "triple",      (char const   *)0,      "combination",      "manifest-nm-vector", 
        "compiled-entry",      "lexpr",      (char const   *)0,      "ephemeron", 
        "variable",      "the-environment",      "syntax-error",      "vector-1b", 
        (char const   *)0,      "vector-16b",      "reference-trap",      (char const   *)0, 
        "conditional",      "disjunction",      "cell",      "weak-cons", 
        "quad",      "linkage-section",      "ratnum",      "stack-environment", 
        "recnum",      "compiled-code-block",      "record",      (char const   *)0};
#line 134 "/home/khheo/project/mit-scheme-9.2/src/microcode/storage.c"
char const   *Abort_Names[13]  = 
#line 134
  {      "DONE",      "DO-EXPRESSION",      "APPLY",      "INTERRUPT", 
        "NO-TRAP-EVAL",      "NO-TRAP_APPLY",      "POP-RETURN",      "TOUCH", 
        "APPLY-INTERRUPT",      "REENTER",      "NO-TRAP-POP-RETURN",      "RETURN-TO-C", 
        "ABORT-TO-C"};
#line 135 "/home/khheo/project/mit-scheme-9.2/src/microcode/storage.c"
char const   *Error_Names[64]  = 
#line 135
  {      "bad-error-code",      "unbound-variable",      "unassigned-variable",      "undefined-procedure", 
        "system-call",      "error-with-argument",      "bad-frame",      (char const   *)0, 
        (char const   *)0,      "undefined-primitive-operation",      "external-return",      "execute-manifest-vector", 
        "wrong-number-of-arguments",      "wrong-type-argument-0",      "wrong-type-argument-1",      "wrong-type-argument-2", 
        "bad-range-argument-0",      "bad-range-argument-1",      "bad-range-argument-2",      "macro-binding", 
        "fasdump-object-too-large",      "syntax-error",      (char const   *)0,      "fasl-file-too-big", 
        "fasl-file-bad-data",      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        "out-of-file-handles",      (char const   *)0,      "bad-range-argument-3",      "bad-range-argument-4", 
        "bad-range-argument-5",      "bad-range-argument-6",      "bad-range-argument-7",      "bad-range-argument-8", 
        "bad-range-argument-9",      "wrong-type-argument-3",      "wrong-type-argument-4",      "wrong-type-argument-5", 
        "wrong-type-argument-6",      "wrong-type-argument-7",      "wrong-type-argument-8",      "wrong-type-argument-9", 
        "inapplicable-continuation",      "compiled-code-error",      "floating-overflow",      "unimplemented-primitive", 
        "illegal-reference-trap",      (char const   *)0,      "wrong-arity-primitives",      (char const   *)0, 
        "fasdump-environment",      "fasload-band",      "fasload-compiled-mismatch",      (char const   *)0, 
        (char const   *)0,      "stack-has-slipped",      "cannot-recurse",      "process-terminated"};
#line 136 "/home/khheo/project/mit-scheme-9.2/src/microcode/storage.c"
char const   *Term_Names[27]  = 
#line 136
  {      "halt",      "disk-restore",      "broken-heart",      "non-pointer-relocation", 
        "bad-root",      "non-existent-continuation",      "bad-stack",      "stack-overflow", 
        "stack-allocation-failed",      "no-error-handler",      "no-interrupt-handler",      "unimplemented-continuation", 
        "exit",      "bad-primitive-during-error",      "eof",      "bad-primitive", 
        "termination-handler",      "end-of-computation",      "invalid-type-code",      "compiler-death", 
        "gc-out-of-space",      "no-space",      "signal",      (char const   *)0, 
        "save-and-exit",      "trap",      "bad-back-out"};
#line 137 "/home/khheo/project/mit-scheme-9.2/src/microcode/storage.c"
char const   *term_messages[27]  = 
#line 137
  {      "Moriturus te saluto",      "Unrecoverable error while loading a band",      "Broken heart encountered",      "Non pointer relocation", 
        "Cannot restore control state from band",      "Nonexistent return code",      "Control stack messed up",      "Stack overflow: Maximum recursion depth exceeded", 
        "Not enough space for stack!",      "No error handler",      "No interrupt handler",      "Unimplemented return code", 
        "Inconsistency detected",      "Error during unknown primitive",      "End of input stream reached",      "Bad primitive invoked", 
        "Termination handler returned",      "End of computation",      "Unknown type encountered",      "Mismatch between compiled code and compiled code support", 
        "Out of space after garbage collection",      "Out of memory: Available memory exceeded",      "Unhandled signal received",      (char const   *)0, 
        "Halt requested by external source",      "User requested termination after trap",      "Backing out of non-primitive"};
#line 138 "/home/khheo/project/mit-scheme-9.2/src/microcode/storage.c"
char const   *fixed_objects_names[70]  = 
#line 138
  {      "non-object",      "system-interrupt-vector",      "system-error-vector",      "obarray", 
        "microcode-types-vector",      "microcode-returns-vector",      "interrupt-mask-vector",      "microcode-errors-vector", 
        "microcode-identification-vector",      "system-call-names",      "system-call-errors",      "gc-daemon", 
        "trap-handler",      "edwin-auto-save",      "stepper-state",      "microcode-fixed-objects-slots", 
        "files-to-delete",      (char const   *)0,      (char const   *)0,      "dummy-history", 
        "bignum-one",      (char const   *)0,      "microcode-terminations-vector",      "microcode-terminations-procedures", 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      "error-procedure",      (char const   *)0,      (char const   *)0, 
        "compiler-error-procedure",      (char const   *)0,      (char const   *)0,      "primitive-profiling-table", 
        "generic-trampoline-zero?",      "generic-trampoline-positive?",      "generic-trampoline-negative?",      "generic-trampoline-add-1", 
        "generic-trampoline-subtract-1",      "generic-trampoline-equal?",      "generic-trampoline-less?",      "generic-trampoline-greater?", 
        "generic-trampoline-add",      "generic-trampoline-subtract",      "generic-trampoline-multiply",      "generic-trampoline-divide", 
        "generic-trampoline-quotient",      "generic-trampoline-remainder",      "generic-trampoline-modulo",      "arity-dispatcher-tag", 
        "pc-sample/builtin-table",      "pc-sample/utility-table",      "pc-sample/primitive-table",      "pc-sample/code-block-table", 
        "pc-sample/purified-code-block-block-buffer",      "pc-sample/purified-code-block-offset-buffer",      "pc-sample/heathen-code-block-block-buffer",      "pc-sample/heathen-code-block-offset-buffer", 
        "pc-sample/interp-proc-buffer",      "pc-sample/prob-comp-table",      "pc-sample/ufo-table",      "compiled-code-bkpt-handler", 
        "gc-wabbit-descwiptor",      "callback-handler",      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0};
#line 36 "/home/khheo/project/mit-scheme-9.2/src/microcode/step.c"
static void install_traps(SCHEME_OBJECT state ) 
{ 
  int tmp ;

  {
#line 39
  *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 15) = state;
#line 40
  if (*((SCHEME_OBJECT *)(state & 288230376151711743UL) + 0) != 0UL) {
#line 40
    tmp = 1;
  } else
#line 40
  if (*((SCHEME_OBJECT *)(state & 288230376151711743UL) + 1) != 0UL) {
#line 40
    tmp = 1;
  } else
#line 40
  if (*((SCHEME_OBJECT *)(state & 288230376151711743UL) + 2) != 0UL) {
#line 40
    tmp = 1;
  } else {
#line 40
    tmp = 0;
  }
#line 40
  trapping = (_Bool )tmp;
#line 44
  return;
}
}
#line 52 "/home/khheo/project/mit-scheme-9.2/src/microcode/step.c"
SCHEME_OBJECT Prim_eval_step(void) 
{ 
  SCHEME_OBJECT expression ;
  SCHEME_OBJECT environment ;
  SCHEME_OBJECT hooks ;

  {
  {
#line 54
  while (1) {
    while_continue: /* CIL Label */ ;
#line 54
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 55
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 55
    if (! (*(stack_pointer + 2) >> 58U == 32UL)) {
#line 55
      if (! (*(stack_pointer + 2) >> 58U == 36UL)) {
        {
#line 55
        error_wrong_type_arg(3);
        }
      }
    }
#line 55
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 57
  expression = *(stack_pointer + 0);
#line 58
  environment = *(stack_pointer + 1);
#line 59
  hooks = *(stack_pointer + 2);
#line 60
  canonicalize_primitive_context();
#line 61
  stack_pointer += 3;
#line 62
  install_traps(hooks);
#line 63
  Registers[5] = expression;
#line 64
  Registers[3] = environment;
#line 66
  abort_to_interpreter(-5);
  }
#line 68
  return ((8UL << 58U) | 1UL);
}
}
#line 80 "/home/khheo/project/mit-scheme-9.2/src/microcode/step.c"
SCHEME_OBJECT Prim_apply_step(void) 
{ 
  SCHEME_OBJECT hooks ;
  long number_of_args ;
  SCHEME_OBJECT procedure ;
  SCHEME_OBJECT argument_list ;
  SCHEME_OBJECT scan_list ;
  SCHEME_OBJECT *scan_stack ;
  SCHEME_OBJECT scan_list___0 ;
  long i ;
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;
  SCHEME_OBJECT *tmp___2 ;
  char *__cil_tmp13 ;

  {
  {
#line 82
  while (1) {
    while_continue: /* CIL Label */ ;
#line 82
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 83
  canonicalize_primitive_context();
  }
  {
#line 84
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 84
    if (! (*(stack_pointer + 2) >> 58U == 32UL)) {
#line 84
      if (! (*(stack_pointer + 2) >> 58U == 36UL)) {
        {
#line 84
        error_wrong_type_arg(3);
        }
      }
    }
#line 84
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 86
  hooks = *(stack_pointer + 2);
#line 87
  number_of_args = 0L;
#line 89
  procedure = *(stack_pointer + 0);
#line 90
  argument_list = *(stack_pointer + 1);
#line 93
  scan_list = argument_list;
  {
#line 94
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 94
    if (! (scan_list >> 58U == 1UL)) {
#line 94
      goto while_break___1;
    }
#line 96
    number_of_args ++;
#line 97
    scan_list = *((SCHEME_OBJECT *)(scan_list & 288230376151711743UL) + 1);
  }
  while_break___1: /* CIL Label */ ;
  }
#line 99
  if (! (scan_list == ((8UL << 58U) | 9UL))) {
    {
#line 100
    error_wrong_type_arg(2);
    }
  }
  {
#line 102
  stack_pointer += 3;
#line 103
  install_traps(hooks);
#line 105
  scan_stack = stack_pointer + - number_of_args;
  }
  {
#line 108
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 108
    if (! ((unsigned long )(stack_pointer + - ((number_of_args + 1L) + 1L)) >= (unsigned long )stack_guard)) {
      {
#line 108
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 108
        if (*stack_start != ((34UL << 58U) | (SCHEME_OBJECT )stack_start)) {
          {
#line 108
          stack_death("STACK_CHECK");
          }
        }
#line 108
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 108
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 108
        set_ulong_register(12U, Registers[12] | 1UL);
        }
        {
#line 108
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 108
          if ((Registers[1] & Registers[12]) != 0UL) {
#line 108
            tmp___0 = memory_block_start;
          } else {
#line 108
            if ((Registers[1] & 4UL) != 0UL) {
#line 108
              tmp = heap_alloc_limit;
            } else {
#line 108
              tmp = heap_end;
            }
#line 108
            tmp___0 = tmp;
          }
          {
#line 108
          set_ptr_register(0U, tmp___0);
          }
#line 108
          if ((Registers[1] & 1UL) != 0UL) {
#line 108
            tmp___1 = stack_guard;
          } else {
#line 108
            tmp___1 = stack_start;
          }
          {
#line 108
          set_ptr_register(11U, tmp___1);
          }
#line 108
          goto while_break___5;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 108
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
#line 108
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 109
  stack_pointer = scan_stack;
#line 110
  scan_list___0 = argument_list;
#line 111
  i = number_of_args;
  {
#line 111
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 111
    if (! (i > 0L)) {
#line 111
      goto while_break___6;
    }
#line 113
    tmp___2 = scan_stack;
#line 113
    scan_stack ++;
#line 113
    *tmp___2 = *((SCHEME_OBJECT *)(scan_list___0 & 288230376151711743UL) + 0);
#line 114
    scan_list___0 = *((SCHEME_OBJECT *)(scan_list___0 & 288230376151711743UL) + 1);
#line 111
    i --;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 116
  stack_pointer --;
#line 116
  *stack_pointer = procedure;
#line 117
  stack_pointer --;
#line 117
  *stack_pointer = (unsigned long )(number_of_args + 1L);
#line 122
  abort_to_interpreter(-6);
  }
#line 124
  return ((8UL << 58U) | 1UL);
}
}
#line 133 "/home/khheo/project/mit-scheme-9.2/src/microcode/step.c"
SCHEME_OBJECT Prim_return_step(void) 
{ 
  SCHEME_OBJECT value ;
  SCHEME_OBJECT hooks ;

  {
  {
#line 135
  while (1) {
    while_continue: /* CIL Label */ ;
#line 135
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 136
  canonicalize_primitive_context();
  }
  {
#line 137
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 137
    if (! (*(stack_pointer + 1) >> 58U == 32UL)) {
#line 137
      if (! (*(stack_pointer + 1) >> 58U == 36UL)) {
        {
#line 137
        error_wrong_type_arg(2);
        }
      }
    }
#line 137
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 139
  value = *(stack_pointer + 0);
#line 140
  hooks = *(stack_pointer + 1);
#line 142
  stack_pointer += 2;
#line 143
  install_traps(hooks);
#line 144
  Registers[2] = value;
#line 145
  abort_to_interpreter(-11);
  }
#line 146
  return ((8UL << 58U) | 1UL);
}
}
#line 190 "/home/khheo/project/mit-scheme-9.2/src/microcode/regex.h"
void re_buffer_initialize(struct re_buffer *buffer___2 , unsigned char *translation ,
                          SCHEME_OBJECT syntax_table , unsigned char *text , unsigned long text_start_index ,
                          unsigned long text_end_index , unsigned long gap_start_index ,
                          unsigned long gap_end_index ) ;
#line 195
int re_compile_fastmap(unsigned char *pattern_start , unsigned char *pattern_end ,
                       unsigned char *translation , SCHEME_OBJECT syntax_table , unsigned char *fastmap ) ;
#line 199
int re_match(unsigned char *pattern_start , unsigned char *pattern_end , struct re_buffer *buffer___2 ,
             struct re_registers *registers , unsigned char *match_start , unsigned char *match_end ) ;
#line 203
int re_search_forward(unsigned char *pattern_start , unsigned char *pattern_end ,
                      struct re_buffer *buffer___2 , struct re_registers *registers ,
                      unsigned char *match_start , unsigned char *match_end ) ;
#line 207
int re_search_backward(unsigned char *pattern_start , unsigned char *pattern_end ,
                       struct re_buffer *buffer___2 , struct re_registers *registers ,
                       unsigned char *match_start , unsigned char *match_end ) ;
#line 35 "/home/khheo/project/mit-scheme-9.2/src/microcode/rgxprim.c"
int re_max_failures ;
#line 91 "/home/khheo/project/mit-scheme-9.2/src/microcode/rgxprim.c"
SCHEME_OBJECT Prim_re_char_set_adjoin(void) 
{ 
  int ascii ;
  long tmp ;

  {
  {
#line 94
  while (1) {
    while_continue: /* CIL Label */ ;
#line 94
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 95
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 95
    if (*(stack_pointer + 0) >> 58U == 30UL) {
#line 95
      if (! ((*((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 1) & 288230376151711743UL) == (1UL << 8) / 8UL)) {
        {
#line 95
        error_wrong_type_arg(1);
        }
      }
    } else {
      {
#line 95
      error_wrong_type_arg(1);
      }
    }
#line 95
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 96
  tmp = arg_ascii_integer(2);
#line 96
  ascii = (int )tmp;
#line 97
  *((unsigned char *)((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 2) + ascii / 8) = (unsigned char )((int )*((unsigned char *)((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 2) + ascii / 8) | (1 << ascii % 8));
  }
#line 99
  return ((8UL << 58U) | 1UL);
}
}
#line 102 "/home/khheo/project/mit-scheme-9.2/src/microcode/rgxprim.c"
SCHEME_OBJECT Prim_re_compile_fastmap(void) 
{ 
  SCHEME_OBJECT pattern ;
  int can_be_null ;
  SCHEME_OBJECT tmp ;

  {
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
#line 106
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 107
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 107
    if (! (*(stack_pointer + 0) >> 58U == 30UL)) {
      {
#line 107
      error_wrong_type_arg(1);
      }
    }
#line 107
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 108
  pattern = *(stack_pointer + 0);
  {
#line 109
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 109
    if (*(stack_pointer + 1) >> 58U == 30UL) {
#line 109
      if (! ((*((SCHEME_OBJECT *)(*(stack_pointer + 1) & 288230376151711743UL) + 1) & 288230376151711743UL) == 1UL << 8)) {
        {
#line 109
        error_wrong_type_arg(2);
        }
      }
    } else {
      {
#line 109
      error_wrong_type_arg(2);
      }
    }
#line 109
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 110
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 110
    if (*(stack_pointer + 2) >> 58U == 10UL) {
#line 110
      if (! ((*((SCHEME_OBJECT *)(*(stack_pointer + 2) & 288230376151711743UL) + 0) & 288230376151711743UL) == 256UL)) {
        {
#line 110
        error_wrong_type_arg(3);
        }
      }
    } else {
      {
#line 110
      error_wrong_type_arg(3);
      }
    }
#line 110
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 111
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 111
    if (*(stack_pointer + 3) >> 58U == 30UL) {
#line 111
      if (! ((*((SCHEME_OBJECT *)(*(stack_pointer + 3) & 288230376151711743UL) + 1) & 288230376151711743UL) == 1UL << 8)) {
        {
#line 111
        error_wrong_type_arg(4);
        }
      }
    } else {
      {
#line 111
      error_wrong_type_arg(4);
      }
    }
#line 111
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 112
  can_be_null = re_compile_fastmap((unsigned char *)((SCHEME_OBJECT *)(pattern & 288230376151711743UL) + 2) + 0,
                                   (unsigned char *)((SCHEME_OBJECT *)(pattern & 288230376151711743UL) + 2) + (*((SCHEME_OBJECT *)(pattern & 288230376151711743UL) + 1) & 288230376151711743UL),
                                   (unsigned char *)((SCHEME_OBJECT *)(*(stack_pointer + 1) & 288230376151711743UL) + 2) + 0,
                                   *(stack_pointer + 2), (unsigned char *)((SCHEME_OBJECT *)(*(stack_pointer + 3) & 288230376151711743UL) + 2) + 0);
  }
#line 119
  if (can_be_null >= 0) {
    {
#line 120
    tmp = long_to_integer((long )can_be_null);
    }
#line 120
    return (tmp);
  } else
#line 121
  if (can_be_null == -2) {
    {
#line 122
    error_bad_range_arg(1);
    }
  } else {
    {
#line 124
    error_external_return();
    }
  }
#line 126
  return ((SCHEME_OBJECT )0);
}
}
#line 172 "/home/khheo/project/mit-scheme-9.2/src/microcode/rgxprim.c"
SCHEME_OBJECT Prim_re_match_substring(void) 
{ 
  SCHEME_OBJECT regexp ;
  long match_start ;
  long match_end ;
  long text_end ;
  unsigned char *text ;
  struct re_buffer buffer___2 ;
  struct re_registers registers ;
  int result ;
  struct re_registers *tmp ;
  int i ;
  long index___0 ;
  SCHEME_OBJECT tmp___0 ;
  SCHEME_OBJECT tmp___1 ;
  SCHEME_OBJECT tmp___2 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;

  {
  {
#line 173
  while (1) {
    while_continue: /* CIL Label */ ;
#line 173
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 173
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 173
    if (! (*(stack_pointer + 0) >> 58U == 30UL)) {
      {
#line 173
      error_wrong_type_arg(1);
      }
    }
#line 173
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 173
  regexp = *(stack_pointer + 0);
  {
#line 173
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 173
    if (*(stack_pointer + 1) >> 58U == 30UL) {
#line 173
      if (! ((*((SCHEME_OBJECT *)(*(stack_pointer + 1) & 288230376151711743UL) + 1) & 288230376151711743UL) == 1UL << 8)) {
        {
#line 173
        error_wrong_type_arg(2);
        }
      }
    } else {
      {
#line 173
      error_wrong_type_arg(2);
      }
    }
#line 173
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 173
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 173
    if (*(stack_pointer + 2) >> 58U == 10UL) {
#line 173
      if (! ((*((SCHEME_OBJECT *)(*(stack_pointer + 2) & 288230376151711743UL) + 0) & 288230376151711743UL) == 256UL)) {
        {
#line 173
        error_wrong_type_arg(3);
        }
      }
    } else {
      {
#line 173
      error_wrong_type_arg(3);
      }
    }
#line 173
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 173
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 173
    if (! (*(stack_pointer + 3) == 0UL)) {
#line 173
      if (*(stack_pointer + 3) >> 58U == 10UL) {
#line 173
        if (! ((*((SCHEME_OBJECT *)(*(stack_pointer + 3) & 288230376151711743UL) + 0) & 288230376151711743UL) == 20UL)) {
          {
#line 173
          error_wrong_type_arg(4);
          }
        }
      } else {
        {
#line 173
        error_wrong_type_arg(4);
        }
      }
    }
#line 173
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 173
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 173
    if (! (*(stack_pointer + 4) >> 58U == 30UL)) {
      {
#line 173
      error_wrong_type_arg(5);
      }
    }
#line 173
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 173
  match_start = arg_nonnegative_integer(6);
#line 173
  match_end = arg_nonnegative_integer(7);
#line 173
  text = (unsigned char *)((SCHEME_OBJECT *)(*(stack_pointer + 4) & 288230376151711743UL) + 2) + 0;
#line 173
  text_end = (long )(*((SCHEME_OBJECT *)(*(stack_pointer + 4) & 288230376151711743UL) + 1) & 288230376151711743UL);
  }
#line 173
  if (match_end > text_end) {
    {
#line 173
    error_bad_range_arg(7);
    }
  }
#line 173
  if (match_start > match_end) {
    {
#line 173
    error_bad_range_arg(6);
    }
  }
  {
#line 173
  re_max_failures = 20000;
#line 173
  re_buffer_initialize(& buffer___2, (unsigned char *)((SCHEME_OBJECT *)(*(stack_pointer + 1) & 288230376151711743UL) + 2) + 0,
                       *(stack_pointer + 2), text, 0UL, (unsigned long )text_end,
                       (unsigned long )text_end, (unsigned long )text_end);
  }
#line 173
  if (*(stack_pointer + 3) == 0UL) {
#line 173
    tmp = (struct re_registers *)((void *)0);
  } else {
#line 173
    tmp = & registers;
  }
  {
#line 173
  result = re_match((unsigned char *)((SCHEME_OBJECT *)(regexp & 288230376151711743UL) + 2) + 0,
                    (unsigned char *)((SCHEME_OBJECT *)(regexp & 288230376151711743UL) + 2) + (*((SCHEME_OBJECT *)(regexp & 288230376151711743UL) + 1) & 288230376151711743UL),
                    & buffer___2, tmp, text + match_start, text + match_end);
  }
  {
#line 173
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 173
    if (result >= 0) {
#line 173
      if (*(stack_pointer + 3) != 0UL) {
#line 173
        i = 0;
        {
#line 173
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 173
          if (! (i < 10)) {
#line 173
            goto while_break___6;
          }
#line 173
          index___0 = registers.start[i];
#line 173
          if (index___0 == -1L) {
#line 173
            *((SCHEME_OBJECT *)(*(stack_pointer + 3) & 288230376151711743UL) + (i + 1)) = 0UL;
          } else {
            {
#line 173
            tmp___0 = long_to_integer(index___0);
#line 173
            *((SCHEME_OBJECT *)(*(stack_pointer + 3) & 288230376151711743UL) + (i + 1)) = tmp___0;
            }
          }
#line 173
          index___0 = registers.end[i];
#line 173
          if (index___0 == -1L) {
#line 173
            *((SCHEME_OBJECT *)(*(stack_pointer + 3) & 288230376151711743UL) + ((i + 10) + 1)) = 0UL;
          } else {
            {
#line 173
            tmp___1 = long_to_integer(index___0);
#line 173
            *((SCHEME_OBJECT *)(*(stack_pointer + 3) & 288230376151711743UL) + ((i + 10) + 1)) = tmp___1;
            }
          }
#line 173
          i ++;
        }
        while_break___6: /* CIL Label */ ;
        }
      }
      {
#line 173
      tmp___2 = long_to_integer((long )result);
      }
#line 173
      return (tmp___2);
    } else
#line 173
    if (result == -1) {
#line 173
      return (0UL);
    } else
#line 173
    if (result == -4) {
#line 173
      return (0UL);
    } else
#line 173
    if (result == -2) {
      {
#line 173
      error_bad_range_arg(1);
      }
    } else {
      {
#line 173
      error_external_return();
      }
    }
#line 173
    return ((SCHEME_OBJECT )0);
#line 173
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 173
  return (0UL);
}
}
#line 175 "/home/khheo/project/mit-scheme-9.2/src/microcode/rgxprim.c"
SCHEME_OBJECT Prim_re_search_substr_forward(void) 
{ 
  SCHEME_OBJECT regexp ;
  long match_start ;
  long match_end ;
  long text_end ;
  unsigned char *text ;
  struct re_buffer buffer___2 ;
  struct re_registers registers ;
  int result ;
  struct re_registers *tmp ;
  int i ;
  long index___0 ;
  SCHEME_OBJECT tmp___0 ;
  SCHEME_OBJECT tmp___1 ;
  SCHEME_OBJECT tmp___2 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;

  {
  {
#line 176
  while (1) {
    while_continue: /* CIL Label */ ;
#line 176
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 176
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 176
    if (! (*(stack_pointer + 0) >> 58U == 30UL)) {
      {
#line 176
      error_wrong_type_arg(1);
      }
    }
#line 176
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 176
  regexp = *(stack_pointer + 0);
  {
#line 176
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 176
    if (*(stack_pointer + 1) >> 58U == 30UL) {
#line 176
      if (! ((*((SCHEME_OBJECT *)(*(stack_pointer + 1) & 288230376151711743UL) + 1) & 288230376151711743UL) == 1UL << 8)) {
        {
#line 176
        error_wrong_type_arg(2);
        }
      }
    } else {
      {
#line 176
      error_wrong_type_arg(2);
      }
    }
#line 176
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 176
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 176
    if (*(stack_pointer + 2) >> 58U == 10UL) {
#line 176
      if (! ((*((SCHEME_OBJECT *)(*(stack_pointer + 2) & 288230376151711743UL) + 0) & 288230376151711743UL) == 256UL)) {
        {
#line 176
        error_wrong_type_arg(3);
        }
      }
    } else {
      {
#line 176
      error_wrong_type_arg(3);
      }
    }
#line 176
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 176
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 176
    if (! (*(stack_pointer + 3) == 0UL)) {
#line 176
      if (*(stack_pointer + 3) >> 58U == 10UL) {
#line 176
        if (! ((*((SCHEME_OBJECT *)(*(stack_pointer + 3) & 288230376151711743UL) + 0) & 288230376151711743UL) == 20UL)) {
          {
#line 176
          error_wrong_type_arg(4);
          }
        }
      } else {
        {
#line 176
        error_wrong_type_arg(4);
        }
      }
    }
#line 176
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 176
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 176
    if (! (*(stack_pointer + 4) >> 58U == 30UL)) {
      {
#line 176
      error_wrong_type_arg(5);
      }
    }
#line 176
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 176
  match_start = arg_nonnegative_integer(6);
#line 176
  match_end = arg_nonnegative_integer(7);
#line 176
  text = (unsigned char *)((SCHEME_OBJECT *)(*(stack_pointer + 4) & 288230376151711743UL) + 2) + 0;
#line 176
  text_end = (long )(*((SCHEME_OBJECT *)(*(stack_pointer + 4) & 288230376151711743UL) + 1) & 288230376151711743UL);
  }
#line 176
  if (match_end > text_end) {
    {
#line 176
    error_bad_range_arg(7);
    }
  }
#line 176
  if (match_start > match_end) {
    {
#line 176
    error_bad_range_arg(6);
    }
  }
  {
#line 176
  re_max_failures = 20000;
#line 176
  re_buffer_initialize(& buffer___2, (unsigned char *)((SCHEME_OBJECT *)(*(stack_pointer + 1) & 288230376151711743UL) + 2) + 0,
                       *(stack_pointer + 2), text, 0UL, (unsigned long )text_end,
                       (unsigned long )text_end, (unsigned long )text_end);
  }
#line 176
  if (*(stack_pointer + 3) == 0UL) {
#line 176
    tmp = (struct re_registers *)((void *)0);
  } else {
#line 176
    tmp = & registers;
  }
  {
#line 176
  result = re_search_forward((unsigned char *)((SCHEME_OBJECT *)(regexp & 288230376151711743UL) + 2) + 0,
                             (unsigned char *)((SCHEME_OBJECT *)(regexp & 288230376151711743UL) + 2) + (*((SCHEME_OBJECT *)(regexp & 288230376151711743UL) + 1) & 288230376151711743UL),
                             & buffer___2, tmp, text + match_start, text + match_end);
  }
  {
#line 176
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 176
    if (result >= 0) {
#line 176
      if (*(stack_pointer + 3) != 0UL) {
#line 176
        i = 0;
        {
#line 176
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 176
          if (! (i < 10)) {
#line 176
            goto while_break___6;
          }
#line 176
          index___0 = registers.start[i];
#line 176
          if (index___0 == -1L) {
#line 176
            *((SCHEME_OBJECT *)(*(stack_pointer + 3) & 288230376151711743UL) + (i + 1)) = 0UL;
          } else {
            {
#line 176
            tmp___0 = long_to_integer(index___0);
#line 176
            *((SCHEME_OBJECT *)(*(stack_pointer + 3) & 288230376151711743UL) + (i + 1)) = tmp___0;
            }
          }
#line 176
          index___0 = registers.end[i];
#line 176
          if (index___0 == -1L) {
#line 176
            *((SCHEME_OBJECT *)(*(stack_pointer + 3) & 288230376151711743UL) + ((i + 10) + 1)) = 0UL;
          } else {
            {
#line 176
            tmp___1 = long_to_integer(index___0);
#line 176
            *((SCHEME_OBJECT *)(*(stack_pointer + 3) & 288230376151711743UL) + ((i + 10) + 1)) = tmp___1;
            }
          }
#line 176
          i ++;
        }
        while_break___6: /* CIL Label */ ;
        }
      }
      {
#line 176
      tmp___2 = long_to_integer((long )result);
      }
#line 176
      return (tmp___2);
    } else
#line 176
    if (result == -1) {
#line 176
      return (0UL);
    } else
#line 176
    if (result == -4) {
#line 176
      return (0UL);
    } else
#line 176
    if (result == -2) {
      {
#line 176
      error_bad_range_arg(1);
      }
    } else {
      {
#line 176
      error_external_return();
      }
    }
#line 176
    return ((SCHEME_OBJECT )0);
#line 176
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 176
  return (0UL);
}
}
#line 178 "/home/khheo/project/mit-scheme-9.2/src/microcode/rgxprim.c"
SCHEME_OBJECT Prim_re_search_substr_backward(void) 
{ 
  SCHEME_OBJECT regexp ;
  long match_start ;
  long match_end ;
  long text_end ;
  unsigned char *text ;
  struct re_buffer buffer___2 ;
  struct re_registers registers ;
  int result ;
  struct re_registers *tmp ;
  int i ;
  long index___0 ;
  SCHEME_OBJECT tmp___0 ;
  SCHEME_OBJECT tmp___1 ;
  SCHEME_OBJECT tmp___2 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;

  {
  {
#line 179
  while (1) {
    while_continue: /* CIL Label */ ;
#line 179
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 179
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 179
    if (! (*(stack_pointer + 0) >> 58U == 30UL)) {
      {
#line 179
      error_wrong_type_arg(1);
      }
    }
#line 179
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 179
  regexp = *(stack_pointer + 0);
  {
#line 179
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 179
    if (*(stack_pointer + 1) >> 58U == 30UL) {
#line 179
      if (! ((*((SCHEME_OBJECT *)(*(stack_pointer + 1) & 288230376151711743UL) + 1) & 288230376151711743UL) == 1UL << 8)) {
        {
#line 179
        error_wrong_type_arg(2);
        }
      }
    } else {
      {
#line 179
      error_wrong_type_arg(2);
      }
    }
#line 179
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 179
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 179
    if (*(stack_pointer + 2) >> 58U == 10UL) {
#line 179
      if (! ((*((SCHEME_OBJECT *)(*(stack_pointer + 2) & 288230376151711743UL) + 0) & 288230376151711743UL) == 256UL)) {
        {
#line 179
        error_wrong_type_arg(3);
        }
      }
    } else {
      {
#line 179
      error_wrong_type_arg(3);
      }
    }
#line 179
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 179
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 179
    if (! (*(stack_pointer + 3) == 0UL)) {
#line 179
      if (*(stack_pointer + 3) >> 58U == 10UL) {
#line 179
        if (! ((*((SCHEME_OBJECT *)(*(stack_pointer + 3) & 288230376151711743UL) + 0) & 288230376151711743UL) == 20UL)) {
          {
#line 179
          error_wrong_type_arg(4);
          }
        }
      } else {
        {
#line 179
        error_wrong_type_arg(4);
        }
      }
    }
#line 179
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 179
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 179
    if (! (*(stack_pointer + 4) >> 58U == 30UL)) {
      {
#line 179
      error_wrong_type_arg(5);
      }
    }
#line 179
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 179
  match_start = arg_nonnegative_integer(6);
#line 179
  match_end = arg_nonnegative_integer(7);
#line 179
  text = (unsigned char *)((SCHEME_OBJECT *)(*(stack_pointer + 4) & 288230376151711743UL) + 2) + 0;
#line 179
  text_end = (long )(*((SCHEME_OBJECT *)(*(stack_pointer + 4) & 288230376151711743UL) + 1) & 288230376151711743UL);
  }
#line 179
  if (match_end > text_end) {
    {
#line 179
    error_bad_range_arg(7);
    }
  }
#line 179
  if (match_start > match_end) {
    {
#line 179
    error_bad_range_arg(6);
    }
  }
  {
#line 179
  re_max_failures = 20000;
#line 179
  re_buffer_initialize(& buffer___2, (unsigned char *)((SCHEME_OBJECT *)(*(stack_pointer + 1) & 288230376151711743UL) + 2) + 0,
                       *(stack_pointer + 2), text, 0UL, (unsigned long )text_end,
                       (unsigned long )text_end, (unsigned long )text_end);
  }
#line 179
  if (*(stack_pointer + 3) == 0UL) {
#line 179
    tmp = (struct re_registers *)((void *)0);
  } else {
#line 179
    tmp = & registers;
  }
  {
#line 179
  result = re_search_backward((unsigned char *)((SCHEME_OBJECT *)(regexp & 288230376151711743UL) + 2) + 0,
                              (unsigned char *)((SCHEME_OBJECT *)(regexp & 288230376151711743UL) + 2) + (*((SCHEME_OBJECT *)(regexp & 288230376151711743UL) + 1) & 288230376151711743UL),
                              & buffer___2, tmp, text + match_start, text + match_end);
  }
  {
#line 179
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 179
    if (result >= 0) {
#line 179
      if (*(stack_pointer + 3) != 0UL) {
#line 179
        i = 0;
        {
#line 179
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 179
          if (! (i < 10)) {
#line 179
            goto while_break___6;
          }
#line 179
          index___0 = registers.start[i];
#line 179
          if (index___0 == -1L) {
#line 179
            *((SCHEME_OBJECT *)(*(stack_pointer + 3) & 288230376151711743UL) + (i + 1)) = 0UL;
          } else {
            {
#line 179
            tmp___0 = long_to_integer(index___0);
#line 179
            *((SCHEME_OBJECT *)(*(stack_pointer + 3) & 288230376151711743UL) + (i + 1)) = tmp___0;
            }
          }
#line 179
          index___0 = registers.end[i];
#line 179
          if (index___0 == -1L) {
#line 179
            *((SCHEME_OBJECT *)(*(stack_pointer + 3) & 288230376151711743UL) + ((i + 10) + 1)) = 0UL;
          } else {
            {
#line 179
            tmp___1 = long_to_integer(index___0);
#line 179
            *((SCHEME_OBJECT *)(*(stack_pointer + 3) & 288230376151711743UL) + ((i + 10) + 1)) = tmp___1;
            }
          }
#line 179
          i ++;
        }
        while_break___6: /* CIL Label */ ;
        }
      }
      {
#line 179
      tmp___2 = long_to_integer((long )result);
      }
#line 179
      return (tmp___2);
    } else
#line 179
    if (result == -1) {
#line 179
      return (0UL);
    } else
#line 179
    if (result == -4) {
#line 179
      return (0UL);
    } else
#line 179
    if (result == -2) {
      {
#line 179
      error_bad_range_arg(1);
      }
    } else {
      {
#line 179
      error_external_return();
      }
    }
#line 179
    return ((SCHEME_OBJECT )0);
#line 179
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 179
  return (0UL);
}
}
#line 228 "/home/khheo/project/mit-scheme-9.2/src/microcode/rgxprim.c"
SCHEME_OBJECT Prim_re_match_buffer(void) 
{ 
  SCHEME_OBJECT regexp ;
  SCHEME_OBJECT group ;
  long match_start ;
  long match_end ;
  long text_start ;
  long text_end ;
  long gap_start ;
  unsigned char *text ;
  struct re_buffer buffer___2 ;
  struct re_registers registers ;
  int result ;
  struct re_registers *tmp ;
  int i ;
  long index___0 ;
  SCHEME_OBJECT tmp___0 ;
  SCHEME_OBJECT tmp___1 ;
  SCHEME_OBJECT tmp___2 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;

  {
  {
#line 229
  while (1) {
    while_continue: /* CIL Label */ ;
#line 229
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 229
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 229
    if (! (*(stack_pointer + 0) >> 58U == 30UL)) {
      {
#line 229
      error_wrong_type_arg(1);
      }
    }
#line 229
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 229
  regexp = *(stack_pointer + 0);
  {
#line 229
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 229
    if (*(stack_pointer + 1) >> 58U == 30UL) {
#line 229
      if (! ((*((SCHEME_OBJECT *)(*(stack_pointer + 1) & 288230376151711743UL) + 1) & 288230376151711743UL) == 1UL << 8)) {
        {
#line 229
        error_wrong_type_arg(2);
        }
      }
    } else {
      {
#line 229
      error_wrong_type_arg(2);
      }
    }
#line 229
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 229
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 229
    if (*(stack_pointer + 2) >> 58U == 10UL) {
#line 229
      if (! ((*((SCHEME_OBJECT *)(*(stack_pointer + 2) & 288230376151711743UL) + 0) & 288230376151711743UL) == 256UL)) {
        {
#line 229
        error_wrong_type_arg(3);
        }
      }
    } else {
      {
#line 229
      error_wrong_type_arg(3);
      }
    }
#line 229
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 229
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 229
    if (! (*(stack_pointer + 3) == 0UL)) {
#line 229
      if (*(stack_pointer + 3) >> 58U == 10UL) {
#line 229
        if (! ((*((SCHEME_OBJECT *)(*(stack_pointer + 3) & 288230376151711743UL) + 0) & 288230376151711743UL) == 20UL)) {
          {
#line 229
          error_wrong_type_arg(4);
          }
        }
      } else {
        {
#line 229
        error_wrong_type_arg(4);
        }
      }
    }
#line 229
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 229
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 229
    if (! (*(stack_pointer + 4) >> 58U == 10UL)) {
      {
#line 229
      error_wrong_type_arg(5);
      }
    }
#line 229
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 229
  group = *(stack_pointer + 4);
#line 229
  match_start = arg_nonnegative_integer(6);
#line 229
  match_end = arg_nonnegative_integer(7);
#line 229
  text = lookup_external_string(*((SCHEME_OBJECT *)(group & 288230376151711743UL) + 2),
                                (unsigned long *)0);
#line 229
  text_start = (long )(*((SCHEME_OBJECT *)(*((SCHEME_OBJECT *)(group & 288230376151711743UL) + 7) & 288230376151711743UL) + 3) & 288230376151711743UL);
#line 229
  text_end = (long )(*((SCHEME_OBJECT *)(*((SCHEME_OBJECT *)(group & 288230376151711743UL) + 8) & 288230376151711743UL) + 3) & 288230376151711743UL);
#line 229
  gap_start = (long )(*((SCHEME_OBJECT *)(group & 288230376151711743UL) + 3) & 288230376151711743UL);
  }
#line 229
  if (text_end > gap_start) {
#line 229
    text_end = (long )((unsigned long )text_end + (*((SCHEME_OBJECT *)(group & 288230376151711743UL) + 4) & 288230376151711743UL));
  }
#line 229
  if (match_end > gap_start) {
#line 229
    match_end = (long )((unsigned long )match_end + (*((SCHEME_OBJECT *)(group & 288230376151711743UL) + 4) & 288230376151711743UL));
#line 229
    if (match_start >= gap_start) {
#line 229
      match_start = (long )((unsigned long )match_start + (*((SCHEME_OBJECT *)(group & 288230376151711743UL) + 4) & 288230376151711743UL));
    }
  }
#line 229
  if (match_start > match_end) {
    {
#line 229
    error_bad_range_arg(6);
    }
  }
#line 229
  if (match_end > text_end) {
    {
#line 229
    error_bad_range_arg(7);
    }
  }
#line 229
  if (match_start < text_start) {
    {
#line 229
    error_bad_range_arg(6);
    }
  }
  {
#line 229
  re_max_failures = 20000;
#line 229
  re_buffer_initialize(& buffer___2, (unsigned char *)((SCHEME_OBJECT *)(*(stack_pointer + 1) & 288230376151711743UL) + 2) + 0,
                       *(stack_pointer + 2), text, (unsigned long )text_start, (unsigned long )text_end,
                       (unsigned long )gap_start, *((SCHEME_OBJECT *)(group & 288230376151711743UL) + 5) & 288230376151711743UL);
  }
#line 229
  if (*(stack_pointer + 3) == 0UL) {
#line 229
    tmp = (struct re_registers *)((void *)0);
  } else {
#line 229
    tmp = & registers;
  }
  {
#line 229
  result = re_match((unsigned char *)((SCHEME_OBJECT *)(regexp & 288230376151711743UL) + 2) + 0,
                    (unsigned char *)((SCHEME_OBJECT *)(regexp & 288230376151711743UL) + 2) + (*((SCHEME_OBJECT *)(regexp & 288230376151711743UL) + 1) & 288230376151711743UL),
                    & buffer___2, tmp, text + match_start, text + match_end);
  }
  {
#line 229
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 229
    if (result >= 0) {
#line 229
      if (*(stack_pointer + 3) != 0UL) {
#line 229
        i = 0;
        {
#line 229
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 229
          if (! (i < 10)) {
#line 229
            goto while_break___6;
          }
#line 229
          index___0 = registers.start[i];
#line 229
          if (index___0 == -1L) {
#line 229
            *((SCHEME_OBJECT *)(*(stack_pointer + 3) & 288230376151711743UL) + (i + 1)) = 0UL;
          } else {
            {
#line 229
            tmp___0 = long_to_integer(index___0);
#line 229
            *((SCHEME_OBJECT *)(*(stack_pointer + 3) & 288230376151711743UL) + (i + 1)) = tmp___0;
            }
          }
#line 229
          index___0 = registers.end[i];
#line 229
          if (index___0 == -1L) {
#line 229
            *((SCHEME_OBJECT *)(*(stack_pointer + 3) & 288230376151711743UL) + ((i + 10) + 1)) = 0UL;
          } else {
            {
#line 229
            tmp___1 = long_to_integer(index___0);
#line 229
            *((SCHEME_OBJECT *)(*(stack_pointer + 3) & 288230376151711743UL) + ((i + 10) + 1)) = tmp___1;
            }
          }
#line 229
          i ++;
        }
        while_break___6: /* CIL Label */ ;
        }
      }
      {
#line 229
      tmp___2 = long_to_integer((long )result);
      }
#line 229
      return (tmp___2);
    } else
#line 229
    if (result == -1) {
#line 229
      return (0UL);
    } else
#line 229
    if (result == -4) {
#line 229
      return (0UL);
    } else
#line 229
    if (result == -2) {
      {
#line 229
      error_bad_range_arg(1);
      }
    } else {
      {
#line 229
      error_external_return();
      }
    }
#line 229
    return ((SCHEME_OBJECT )0);
#line 229
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 229
  return (0UL);
}
}
#line 231 "/home/khheo/project/mit-scheme-9.2/src/microcode/rgxprim.c"
SCHEME_OBJECT Prim_re_search_buffer_forward(void) 
{ 
  SCHEME_OBJECT regexp ;
  SCHEME_OBJECT group ;
  long match_start ;
  long match_end ;
  long text_start ;
  long text_end ;
  long gap_start ;
  unsigned char *text ;
  struct re_buffer buffer___2 ;
  struct re_registers registers ;
  int result ;
  struct re_registers *tmp ;
  int i ;
  long index___0 ;
  SCHEME_OBJECT tmp___0 ;
  SCHEME_OBJECT tmp___1 ;
  SCHEME_OBJECT tmp___2 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;

  {
  {
#line 232
  while (1) {
    while_continue: /* CIL Label */ ;
#line 232
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 232
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 232
    if (! (*(stack_pointer + 0) >> 58U == 30UL)) {
      {
#line 232
      error_wrong_type_arg(1);
      }
    }
#line 232
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 232
  regexp = *(stack_pointer + 0);
  {
#line 232
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 232
    if (*(stack_pointer + 1) >> 58U == 30UL) {
#line 232
      if (! ((*((SCHEME_OBJECT *)(*(stack_pointer + 1) & 288230376151711743UL) + 1) & 288230376151711743UL) == 1UL << 8)) {
        {
#line 232
        error_wrong_type_arg(2);
        }
      }
    } else {
      {
#line 232
      error_wrong_type_arg(2);
      }
    }
#line 232
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 232
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 232
    if (*(stack_pointer + 2) >> 58U == 10UL) {
#line 232
      if (! ((*((SCHEME_OBJECT *)(*(stack_pointer + 2) & 288230376151711743UL) + 0) & 288230376151711743UL) == 256UL)) {
        {
#line 232
        error_wrong_type_arg(3);
        }
      }
    } else {
      {
#line 232
      error_wrong_type_arg(3);
      }
    }
#line 232
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 232
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 232
    if (! (*(stack_pointer + 3) == 0UL)) {
#line 232
      if (*(stack_pointer + 3) >> 58U == 10UL) {
#line 232
        if (! ((*((SCHEME_OBJECT *)(*(stack_pointer + 3) & 288230376151711743UL) + 0) & 288230376151711743UL) == 20UL)) {
          {
#line 232
          error_wrong_type_arg(4);
          }
        }
      } else {
        {
#line 232
        error_wrong_type_arg(4);
        }
      }
    }
#line 232
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 232
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 232
    if (! (*(stack_pointer + 4) >> 58U == 10UL)) {
      {
#line 232
      error_wrong_type_arg(5);
      }
    }
#line 232
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 232
  group = *(stack_pointer + 4);
#line 232
  match_start = arg_nonnegative_integer(6);
#line 232
  match_end = arg_nonnegative_integer(7);
#line 232
  text = lookup_external_string(*((SCHEME_OBJECT *)(group & 288230376151711743UL) + 2),
                                (unsigned long *)0);
#line 232
  text_start = (long )(*((SCHEME_OBJECT *)(*((SCHEME_OBJECT *)(group & 288230376151711743UL) + 7) & 288230376151711743UL) + 3) & 288230376151711743UL);
#line 232
  text_end = (long )(*((SCHEME_OBJECT *)(*((SCHEME_OBJECT *)(group & 288230376151711743UL) + 8) & 288230376151711743UL) + 3) & 288230376151711743UL);
#line 232
  gap_start = (long )(*((SCHEME_OBJECT *)(group & 288230376151711743UL) + 3) & 288230376151711743UL);
  }
#line 232
  if (text_end > gap_start) {
#line 232
    text_end = (long )((unsigned long )text_end + (*((SCHEME_OBJECT *)(group & 288230376151711743UL) + 4) & 288230376151711743UL));
  }
#line 232
  if (match_end > gap_start) {
#line 232
    match_end = (long )((unsigned long )match_end + (*((SCHEME_OBJECT *)(group & 288230376151711743UL) + 4) & 288230376151711743UL));
#line 232
    if (match_start >= gap_start) {
#line 232
      match_start = (long )((unsigned long )match_start + (*((SCHEME_OBJECT *)(group & 288230376151711743UL) + 4) & 288230376151711743UL));
    }
  }
#line 232
  if (match_start > match_end) {
    {
#line 232
    error_bad_range_arg(6);
    }
  }
#line 232
  if (match_end > text_end) {
    {
#line 232
    error_bad_range_arg(7);
    }
  }
#line 232
  if (match_start < text_start) {
    {
#line 232
    error_bad_range_arg(6);
    }
  }
  {
#line 232
  re_max_failures = 20000;
#line 232
  re_buffer_initialize(& buffer___2, (unsigned char *)((SCHEME_OBJECT *)(*(stack_pointer + 1) & 288230376151711743UL) + 2) + 0,
                       *(stack_pointer + 2), text, (unsigned long )text_start, (unsigned long )text_end,
                       (unsigned long )gap_start, *((SCHEME_OBJECT *)(group & 288230376151711743UL) + 5) & 288230376151711743UL);
  }
#line 232
  if (*(stack_pointer + 3) == 0UL) {
#line 232
    tmp = (struct re_registers *)((void *)0);
  } else {
#line 232
    tmp = & registers;
  }
  {
#line 232
  result = re_search_forward((unsigned char *)((SCHEME_OBJECT *)(regexp & 288230376151711743UL) + 2) + 0,
                             (unsigned char *)((SCHEME_OBJECT *)(regexp & 288230376151711743UL) + 2) + (*((SCHEME_OBJECT *)(regexp & 288230376151711743UL) + 1) & 288230376151711743UL),
                             & buffer___2, tmp, text + match_start, text + match_end);
  }
  {
#line 232
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 232
    if (result >= 0) {
#line 232
      if (*(stack_pointer + 3) != 0UL) {
#line 232
        i = 0;
        {
#line 232
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 232
          if (! (i < 10)) {
#line 232
            goto while_break___6;
          }
#line 232
          index___0 = registers.start[i];
#line 232
          if (index___0 == -1L) {
#line 232
            *((SCHEME_OBJECT *)(*(stack_pointer + 3) & 288230376151711743UL) + (i + 1)) = 0UL;
          } else {
            {
#line 232
            tmp___0 = long_to_integer(index___0);
#line 232
            *((SCHEME_OBJECT *)(*(stack_pointer + 3) & 288230376151711743UL) + (i + 1)) = tmp___0;
            }
          }
#line 232
          index___0 = registers.end[i];
#line 232
          if (index___0 == -1L) {
#line 232
            *((SCHEME_OBJECT *)(*(stack_pointer + 3) & 288230376151711743UL) + ((i + 10) + 1)) = 0UL;
          } else {
            {
#line 232
            tmp___1 = long_to_integer(index___0);
#line 232
            *((SCHEME_OBJECT *)(*(stack_pointer + 3) & 288230376151711743UL) + ((i + 10) + 1)) = tmp___1;
            }
          }
#line 232
          i ++;
        }
        while_break___6: /* CIL Label */ ;
        }
      }
      {
#line 232
      tmp___2 = long_to_integer((long )result);
      }
#line 232
      return (tmp___2);
    } else
#line 232
    if (result == -1) {
#line 232
      return (0UL);
    } else
#line 232
    if (result == -4) {
#line 232
      return (0UL);
    } else
#line 232
    if (result == -2) {
      {
#line 232
      error_bad_range_arg(1);
      }
    } else {
      {
#line 232
      error_external_return();
      }
    }
#line 232
    return ((SCHEME_OBJECT )0);
#line 232
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 232
  return (0UL);
}
}
#line 234 "/home/khheo/project/mit-scheme-9.2/src/microcode/rgxprim.c"
SCHEME_OBJECT Prim_re_search_buffer_backward(void) 
{ 
  SCHEME_OBJECT regexp ;
  SCHEME_OBJECT group ;
  long match_start ;
  long match_end ;
  long text_start ;
  long text_end ;
  long gap_start ;
  unsigned char *text ;
  struct re_buffer buffer___2 ;
  struct re_registers registers ;
  int result ;
  struct re_registers *tmp ;
  int i ;
  long index___0 ;
  SCHEME_OBJECT tmp___0 ;
  SCHEME_OBJECT tmp___1 ;
  SCHEME_OBJECT tmp___2 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;

  {
  {
#line 235
  while (1) {
    while_continue: /* CIL Label */ ;
#line 235
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 235
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 235
    if (! (*(stack_pointer + 0) >> 58U == 30UL)) {
      {
#line 235
      error_wrong_type_arg(1);
      }
    }
#line 235
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 235
  regexp = *(stack_pointer + 0);
  {
#line 235
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 235
    if (*(stack_pointer + 1) >> 58U == 30UL) {
#line 235
      if (! ((*((SCHEME_OBJECT *)(*(stack_pointer + 1) & 288230376151711743UL) + 1) & 288230376151711743UL) == 1UL << 8)) {
        {
#line 235
        error_wrong_type_arg(2);
        }
      }
    } else {
      {
#line 235
      error_wrong_type_arg(2);
      }
    }
#line 235
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 235
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 235
    if (*(stack_pointer + 2) >> 58U == 10UL) {
#line 235
      if (! ((*((SCHEME_OBJECT *)(*(stack_pointer + 2) & 288230376151711743UL) + 0) & 288230376151711743UL) == 256UL)) {
        {
#line 235
        error_wrong_type_arg(3);
        }
      }
    } else {
      {
#line 235
      error_wrong_type_arg(3);
      }
    }
#line 235
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 235
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 235
    if (! (*(stack_pointer + 3) == 0UL)) {
#line 235
      if (*(stack_pointer + 3) >> 58U == 10UL) {
#line 235
        if (! ((*((SCHEME_OBJECT *)(*(stack_pointer + 3) & 288230376151711743UL) + 0) & 288230376151711743UL) == 20UL)) {
          {
#line 235
          error_wrong_type_arg(4);
          }
        }
      } else {
        {
#line 235
        error_wrong_type_arg(4);
        }
      }
    }
#line 235
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 235
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 235
    if (! (*(stack_pointer + 4) >> 58U == 10UL)) {
      {
#line 235
      error_wrong_type_arg(5);
      }
    }
#line 235
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 235
  group = *(stack_pointer + 4);
#line 235
  match_start = arg_nonnegative_integer(6);
#line 235
  match_end = arg_nonnegative_integer(7);
#line 235
  text = lookup_external_string(*((SCHEME_OBJECT *)(group & 288230376151711743UL) + 2),
                                (unsigned long *)0);
#line 235
  text_start = (long )(*((SCHEME_OBJECT *)(*((SCHEME_OBJECT *)(group & 288230376151711743UL) + 7) & 288230376151711743UL) + 3) & 288230376151711743UL);
#line 235
  text_end = (long )(*((SCHEME_OBJECT *)(*((SCHEME_OBJECT *)(group & 288230376151711743UL) + 8) & 288230376151711743UL) + 3) & 288230376151711743UL);
#line 235
  gap_start = (long )(*((SCHEME_OBJECT *)(group & 288230376151711743UL) + 3) & 288230376151711743UL);
  }
#line 235
  if (text_end > gap_start) {
#line 235
    text_end = (long )((unsigned long )text_end + (*((SCHEME_OBJECT *)(group & 288230376151711743UL) + 4) & 288230376151711743UL));
  }
#line 235
  if (match_end > gap_start) {
#line 235
    match_end = (long )((unsigned long )match_end + (*((SCHEME_OBJECT *)(group & 288230376151711743UL) + 4) & 288230376151711743UL));
#line 235
    if (match_start >= gap_start) {
#line 235
      match_start = (long )((unsigned long )match_start + (*((SCHEME_OBJECT *)(group & 288230376151711743UL) + 4) & 288230376151711743UL));
    }
  }
#line 235
  if (match_start > match_end) {
    {
#line 235
    error_bad_range_arg(6);
    }
  }
#line 235
  if (match_end > text_end) {
    {
#line 235
    error_bad_range_arg(7);
    }
  }
#line 235
  if (match_start < text_start) {
    {
#line 235
    error_bad_range_arg(6);
    }
  }
  {
#line 235
  re_max_failures = 20000;
#line 235
  re_buffer_initialize(& buffer___2, (unsigned char *)((SCHEME_OBJECT *)(*(stack_pointer + 1) & 288230376151711743UL) + 2) + 0,
                       *(stack_pointer + 2), text, (unsigned long )text_start, (unsigned long )text_end,
                       (unsigned long )gap_start, *((SCHEME_OBJECT *)(group & 288230376151711743UL) + 5) & 288230376151711743UL);
  }
#line 235
  if (*(stack_pointer + 3) == 0UL) {
#line 235
    tmp = (struct re_registers *)((void *)0);
  } else {
#line 235
    tmp = & registers;
  }
  {
#line 235
  result = re_search_backward((unsigned char *)((SCHEME_OBJECT *)(regexp & 288230376151711743UL) + 2) + 0,
                              (unsigned char *)((SCHEME_OBJECT *)(regexp & 288230376151711743UL) + 2) + (*((SCHEME_OBJECT *)(regexp & 288230376151711743UL) + 1) & 288230376151711743UL),
                              & buffer___2, tmp, text + match_start, text + match_end);
  }
  {
#line 235
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 235
    if (result >= 0) {
#line 235
      if (*(stack_pointer + 3) != 0UL) {
#line 235
        i = 0;
        {
#line 235
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 235
          if (! (i < 10)) {
#line 235
            goto while_break___6;
          }
#line 235
          index___0 = registers.start[i];
#line 235
          if (index___0 == -1L) {
#line 235
            *((SCHEME_OBJECT *)(*(stack_pointer + 3) & 288230376151711743UL) + (i + 1)) = 0UL;
          } else {
            {
#line 235
            tmp___0 = long_to_integer(index___0);
#line 235
            *((SCHEME_OBJECT *)(*(stack_pointer + 3) & 288230376151711743UL) + (i + 1)) = tmp___0;
            }
          }
#line 235
          index___0 = registers.end[i];
#line 235
          if (index___0 == -1L) {
#line 235
            *((SCHEME_OBJECT *)(*(stack_pointer + 3) & 288230376151711743UL) + ((i + 10) + 1)) = 0UL;
          } else {
            {
#line 235
            tmp___1 = long_to_integer(index___0);
#line 235
            *((SCHEME_OBJECT *)(*(stack_pointer + 3) & 288230376151711743UL) + ((i + 10) + 1)) = tmp___1;
            }
          }
#line 235
          i ++;
        }
        while_break___6: /* CIL Label */ ;
        }
      }
      {
#line 235
      tmp___2 = long_to_integer((long )result);
      }
#line 235
      return (tmp___2);
    } else
#line 235
    if (result == -1) {
#line 235
      return (0UL);
    } else
#line 235
    if (result == -4) {
#line 235
      return (0UL);
    } else
#line 235
    if (result == -2) {
      {
#line 235
      error_bad_range_arg(1);
      }
    } else {
      {
#line 235
      error_external_return();
      }
    }
#line 235
    return ((SCHEME_OBJECT )0);
#line 235
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 235
  return (0UL);
}
}
#line 167 "/home/khheo/project/mit-scheme-9.2/src/microcode/regex.c"
void re_buffer_initialize(struct re_buffer *buffer___2 , unsigned char *translation ,
                          SCHEME_OBJECT syntax_table , unsigned char *text , unsigned long text_start_index ,
                          unsigned long text_end_index , unsigned long gap_start_index ,
                          unsigned long gap_end_index ) 
{ 
  unsigned char *text_start ;
  unsigned char *text_end ;
  unsigned char *gap_start ;
  unsigned char *gap_end ;

  {
#line 184
  text_start = text + text_start_index;
#line 185
  text_end = text + text_end_index;
#line 186
  gap_start = text + gap_start_index;
#line 187
  gap_end = text + gap_end_index;
#line 189
  buffer___2->translation = translation;
#line 190
  buffer___2->syntax_table = syntax_table;
#line 191
  buffer___2->text = text;
#line 192
  if ((unsigned long )text_start == (unsigned long )gap_start) {
#line 192
    buffer___2->text_start = gap_end;
  } else {
#line 192
    buffer___2->text_start = text_start;
  }
#line 193
  if ((unsigned long )text_end == (unsigned long )gap_end) {
#line 193
    buffer___2->text_end = gap_start;
  } else {
#line 193
    buffer___2->text_end = text_end;
  }
#line 194
  buffer___2->gap_start = gap_start;
#line 195
  buffer___2->gap_end = gap_end;
#line 196
  return;
}
}
#line 220 "/home/khheo/project/mit-scheme-9.2/src/microcode/regex.c"
int re_compile_fastmap(unsigned char *pattern_start , unsigned char *pattern_end ,
                       unsigned char *translation , SCHEME_OBJECT syntax_table , unsigned char *fastmap ) 
{ 
  unsigned char *pattern_pc ;
  unsigned char *stack_start___0[512] ;
  unsigned char **stack_pointer___0 ;
  int return_value ;
  int i ;
  unsigned char *tmp ;
  int tmp___0 ;
  int ascii ;
  unsigned char *tmp___1 ;
  int tmp___2 ;
  int length ;
  int _len ;
  unsigned char *tmp___3 ;
  int tmp___4 ;
  int ascii___0 ;
  int tmp___5 ;
  int length___0 ;
  int ascii___1 ;
  int _len___0 ;
  unsigned char *tmp___6 ;
  int tmp___7 ;
  int length___1 ;
  int ascii___2 ;
  int _len___1 ;
  unsigned char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int ascii___3 ;
  int tmp___11 ;
  int ascii___4 ;
  int tmp___12 ;
  enum syntaxcode code ;
  int ascii___5 ;
  unsigned char *tmp___13 ;
  int tmp___14 ;
  enum syntaxcode code___0 ;
  int ascii___6 ;
  unsigned char *tmp___15 ;
  int tmp___16 ;
  int register_number ;
  unsigned char *tmp___17 ;
  int register_number___0 ;
  int ascii___7 ;
  unsigned char *tmp___18 ;
  int offset ;
  signed char _fetched ;
  unsigned char *tmp___19 ;
  unsigned char *tmp___20 ;
  signed char _fetched___0 ;
  unsigned char *tmp___21 ;
  unsigned char *tmp___22 ;
  int offset___0 ;
  signed char _fetched___1 ;
  unsigned char *tmp___23 ;
  unsigned char *tmp___24 ;
  unsigned char **tmp___25 ;
  void *__cil_tmp62 ;

  {
#line 232
  pattern_pc = pattern_start;
#line 233
  return_value = 0;
#line 234
  stack_pointer___0 = stack_start___0;
#line 239
  i = 0;
  {
#line 239
  while (1) {
    while_continue: /* CIL Label */ ;
#line 239
    if (! ((unsigned long )i < 1UL << 8)) {
#line 239
      goto while_break;
    }
#line 240
    *(fastmap + i) = (unsigned char )'\000';
#line 239
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  loop: 
#line 244
  if ((unsigned long )pattern_pc >= (unsigned long )pattern_end) {
#line 245
    return_value = 1;
#line 245
    goto return_point;
  }
#line 247
  tmp = pattern_pc;
#line 247
  pattern_pc ++;
  {
#line 256
  if ((unsigned int )((enum regexpcode )*tmp) == 23U) {
#line 256
    goto case_23;
  }
#line 256
  if ((unsigned int )((enum regexpcode )*tmp) == 22U) {
#line 256
    goto case_23;
  }
#line 256
  if ((unsigned int )((enum regexpcode )*tmp) == 21U) {
#line 256
    goto case_23;
  }
#line 256
  if ((unsigned int )((enum regexpcode )*tmp) == 20U) {
#line 256
    goto case_23;
  }
#line 256
  if ((unsigned int )((enum regexpcode )*tmp) == 17U) {
#line 256
    goto case_23;
  }
#line 256
  if ((unsigned int )((enum regexpcode )*tmp) == 16U) {
#line 256
    goto case_23;
  }
#line 256
  if ((unsigned int )((enum regexpcode )*tmp) == 3U) {
#line 256
    goto case_23;
  }
#line 256
  if ((unsigned int )((enum regexpcode )*tmp) == 0U) {
#line 256
    goto case_23;
  }
#line 259
  if ((unsigned int )((enum regexpcode )*tmp) == 4U) {
#line 259
    goto case_4;
  }
#line 267
  if ((unsigned int )((enum regexpcode )*tmp) == 1U) {
#line 267
    goto case_1;
  }
#line 276
  if ((unsigned int )((enum regexpcode )*tmp) == 2U) {
#line 276
    goto case_2;
  }
#line 287
  if ((unsigned int )((enum regexpcode )*tmp) == 10U) {
#line 287
    goto case_10;
  }
#line 298
  if ((unsigned int )((enum regexpcode )*tmp) == 11U) {
#line 298
    goto case_11;
  }
#line 311
  if ((unsigned int )((enum regexpcode )*tmp) == 12U) {
#line 311
    goto case_12;
  }
#line 326
  if ((unsigned int )((enum regexpcode )*tmp) == 18U) {
#line 326
    goto case_18;
  }
#line 335
  if ((unsigned int )((enum regexpcode )*tmp) == 19U) {
#line 335
    goto case_19;
  }
#line 344
  if ((unsigned int )((enum regexpcode )*tmp) == 24U) {
#line 344
    goto case_24;
  }
#line 355
  if ((unsigned int )((enum regexpcode )*tmp) == 25U) {
#line 355
    goto case_25;
  }
#line 368
  if ((unsigned int )((enum regexpcode )*tmp) == 14U) {
#line 368
    goto case_14;
  }
#line 368
  if ((unsigned int )((enum regexpcode )*tmp) == 13U) {
#line 368
    goto case_14;
  }
#line 376
  if ((unsigned int )((enum regexpcode )*tmp) == 15U) {
#line 376
    goto case_15;
  }
#line 390
  if ((unsigned int )((enum regexpcode )*tmp) == 9U) {
#line 390
    goto case_9;
  }
#line 390
  if ((unsigned int )((enum regexpcode )*tmp) == 8U) {
#line 390
    goto case_9;
  }
#line 390
  if ((unsigned int )((enum regexpcode )*tmp) == 7U) {
#line 390
    goto case_9;
  }
#line 390
  if ((unsigned int )((enum regexpcode )*tmp) == 5U) {
#line 390
    goto case_9;
  }
#line 418
  if ((unsigned int )((enum regexpcode )*tmp) == 6U) {
#line 418
    goto case_6;
  }
#line 427
  goto switch_default;
  case_23: /* CIL Label */ 
  case_22: /* CIL Label */ 
  case_21: /* CIL Label */ 
  case_20: /* CIL Label */ 
  case_17: /* CIL Label */ 
  case_16: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 257
  goto loop;
  case_4: /* CIL Label */ 
#line 261
  if ((unsigned long )translation == (unsigned long )((void *)0)) {
#line 261
    tmp___0 = '\n';
  } else {
#line 261
    tmp___0 = (int )*(translation + '\n');
  }
#line 261
  *(fastmap + tmp___0) = (unsigned char )'\001';
#line 262
  if (return_value == 0) {
#line 263
    return_value = 2;
  }
#line 264
  goto next;
  case_1: /* CIL Label */ 
  {
#line 271
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 271
    if ((unsigned long )pattern_pc >= (unsigned long )pattern_end) {
#line 271
      return_value = -2;
#line 271
      goto return_point;
    }
#line 271
    tmp___1 = pattern_pc;
#line 271
    pattern_pc ++;
#line 271
    ascii = (int )*tmp___1;
#line 271
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 272
  if ((unsigned long )translation == (unsigned long )((void *)0)) {
#line 272
    tmp___2 = ascii;
  } else {
#line 272
    tmp___2 = (int )*(translation + ascii);
  }
#line 272
  *(fastmap + tmp___2) = (unsigned char )'\001';
#line 273
  goto next;
  case_2: /* CIL Label */ 
  {
#line 280
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 280
    if ((unsigned long )pattern_pc >= (unsigned long )pattern_end) {
#line 280
      return_value = -2;
#line 280
      goto return_point;
    }
#line 280
    tmp___3 = pattern_pc;
#line 280
    pattern_pc ++;
#line 280
    _len = (int )*tmp___3;
#line 280
    if ((unsigned long )(pattern_pc + _len) > (unsigned long )pattern_end) {
#line 280
      return_value = -2;
#line 280
      goto return_point;
    }
#line 280
    length = _len;
#line 280
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 281
  if (length == 0) {
#line 282
    goto loop;
  }
#line 283
  if ((unsigned long )translation == (unsigned long )((void *)0)) {
#line 283
    tmp___4 = (int )*(pattern_pc + 0);
  } else {
#line 283
    tmp___4 = (int )*(translation + *(pattern_pc + 0));
  }
#line 283
  *(fastmap + tmp___4) = (unsigned char )'\001';
#line 284
  goto next;
  case_10: /* CIL Label */ 
#line 291
  ascii___0 = 0;
  {
#line 291
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 291
    if (! ((unsigned long )ascii___0 < 1UL << 8)) {
#line 291
      goto while_break___2;
    }
#line 291
    if (ascii___0 != 10) {
#line 292
      if ((unsigned long )translation == (unsigned long )((void *)0)) {
#line 292
        tmp___5 = ascii___0;
      } else {
#line 292
        tmp___5 = (int )*(translation + ascii___0);
      }
#line 292
      *(fastmap + tmp___5) = (unsigned char )'\001';
    }
#line 291
    ascii___0 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 293
  if (return_value != 0) {
#line 294
    goto return_point;
  }
#line 295
  goto next;
  case_11: /* CIL Label */ 
  {
#line 303
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 303
    if ((unsigned long )pattern_pc >= (unsigned long )pattern_end) {
#line 303
      return_value = -2;
#line 303
      goto return_point;
    }
#line 303
    tmp___6 = pattern_pc;
#line 303
    pattern_pc ++;
#line 303
    _len___0 = (int )*tmp___6;
#line 303
    if ((unsigned long )(pattern_pc + _len___0) > (unsigned long )pattern_end) {
#line 303
      return_value = -2;
#line 303
      goto return_point;
    }
#line 303
    length___0 = _len___0;
#line 303
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 304
  length___0 *= 8;
#line 305
  ascii___1 = 0;
  {
#line 305
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 305
    if (! (ascii___1 < length___0)) {
#line 305
      goto while_break___4;
    }
#line 306
    if (((int )*(pattern_pc + ascii___1 / 8) & (1 << ascii___1 % 8)) != 0) {
#line 307
      if ((unsigned long )translation == (unsigned long )((void *)0)) {
#line 307
        tmp___7 = ascii___1;
      } else {
#line 307
        tmp___7 = (int )*(translation + ascii___1);
      }
#line 307
      *(fastmap + tmp___7) = (unsigned char )'\001';
    }
#line 305
    ascii___1 ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 308
  goto next;
  case_12: /* CIL Label */ 
  {
#line 316
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 316
    if ((unsigned long )pattern_pc >= (unsigned long )pattern_end) {
#line 316
      return_value = -2;
#line 316
      goto return_point;
    }
#line 316
    tmp___8 = pattern_pc;
#line 316
    pattern_pc ++;
#line 316
    _len___1 = (int )*tmp___8;
#line 316
    if ((unsigned long )(pattern_pc + _len___1) > (unsigned long )pattern_end) {
#line 316
      return_value = -2;
#line 316
      goto return_point;
    }
#line 316
    length___1 = _len___1;
#line 316
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 317
  length___1 *= 8;
#line 318
  ascii___2 = 0;
  {
#line 318
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 318
    if (! (ascii___2 < length___1)) {
#line 318
      goto while_break___6;
    }
#line 319
    if (! (((int )*(pattern_pc + ascii___2 / 8) & (1 << ascii___2 % 8)) != 0)) {
#line 320
      if ((unsigned long )translation == (unsigned long )((void *)0)) {
#line 320
        tmp___9 = ascii___2;
      } else {
#line 320
        tmp___9 = (int )*(translation + ascii___2);
      }
#line 320
      *(fastmap + tmp___9) = (unsigned char )'\001';
    }
#line 318
    ascii___2 ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 321
  ascii___2 = length___1;
  {
#line 321
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 321
    if (! ((unsigned long )ascii___2 < 1UL << 8)) {
#line 321
      goto while_break___7;
    }
#line 322
    if ((unsigned long )translation == (unsigned long )((void *)0)) {
#line 322
      tmp___10 = ascii___2;
    } else {
#line 322
      tmp___10 = (int )*(translation + ascii___2);
    }
#line 322
    *(fastmap + tmp___10) = (unsigned char )'\001';
#line 321
    ascii___2 ++;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 323
  goto next;
  case_18: /* CIL Label */ 
#line 330
  ascii___3 = 0;
  {
#line 330
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 330
    if (! ((unsigned long )ascii___3 < 1UL << 8)) {
#line 330
      goto while_break___8;
    }
#line 330
    if ((unsigned int )((enum syntaxcode )(*((SCHEME_OBJECT *)(syntax_table & 288230376151711743UL) + ((ascii___3 & 255) + 1)) & 15UL)) == 2U) {
#line 331
      if ((unsigned long )translation == (unsigned long )((void *)0)) {
#line 331
        tmp___11 = ascii___3;
      } else {
#line 331
        tmp___11 = (int )*(translation + ascii___3);
      }
#line 331
      *(fastmap + tmp___11) = (unsigned char )'\001';
    }
#line 330
    ascii___3 ++;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 332
  goto next;
  case_19: /* CIL Label */ 
#line 339
  ascii___4 = 0;
  {
#line 339
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 339
    if (! ((unsigned long )ascii___4 < 1UL << 8)) {
#line 339
      goto while_break___9;
    }
#line 339
    if (! ((unsigned int )((enum syntaxcode )(*((SCHEME_OBJECT *)(syntax_table & 288230376151711743UL) + ((ascii___4 & 255) + 1)) & 15UL)) == 2U)) {
#line 340
      if ((unsigned long )translation == (unsigned long )((void *)0)) {
#line 340
        tmp___12 = ascii___4;
      } else {
#line 340
        tmp___12 = (int )*(translation + ascii___4);
      }
#line 340
      *(fastmap + tmp___12) = (unsigned char )'\001';
    }
#line 339
    ascii___4 ++;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 341
  goto next;
  case_24: /* CIL Label */ 
  {
#line 349
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 349
    if ((unsigned long )pattern_pc >= (unsigned long )pattern_end) {
#line 349
      return_value = -2;
#line 349
      goto return_point;
    } else {
#line 349
      tmp___13 = pattern_pc;
#line 349
      pattern_pc ++;
#line 349
      code = (enum syntaxcode )*tmp___13;
#line 349
      if ((int )code >= 13) {
#line 349
        return_value = -2;
#line 349
        goto return_point;
      }
    }
#line 349
    goto while_break___10;
  }
  while_break___10: /* CIL Label */ ;
  }
#line 350
  ascii___5 = 0;
  {
#line 350
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 350
    if (! ((unsigned long )ascii___5 < 1UL << 8)) {
#line 350
      goto while_break___11;
    }
#line 350
    if ((unsigned int )((enum syntaxcode )(*((SCHEME_OBJECT *)(syntax_table & 288230376151711743UL) + ((ascii___5 & 255) + 1)) & 15UL)) == (unsigned int )code) {
#line 351
      if ((unsigned long )translation == (unsigned long )((void *)0)) {
#line 351
        tmp___14 = ascii___5;
      } else {
#line 351
        tmp___14 = (int )*(translation + ascii___5);
      }
#line 351
      *(fastmap + tmp___14) = (unsigned char )'\001';
    }
#line 350
    ascii___5 ++;
  }
  while_break___11: /* CIL Label */ ;
  }
#line 352
  goto next;
  case_25: /* CIL Label */ 
  {
#line 360
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 360
    if ((unsigned long )pattern_pc >= (unsigned long )pattern_end) {
#line 360
      return_value = -2;
#line 360
      goto return_point;
    } else {
#line 360
      tmp___15 = pattern_pc;
#line 360
      pattern_pc ++;
#line 360
      code___0 = (enum syntaxcode )*tmp___15;
#line 360
      if ((int )code___0 >= 13) {
#line 360
        return_value = -2;
#line 360
        goto return_point;
      }
    }
#line 360
    goto while_break___12;
  }
  while_break___12: /* CIL Label */ ;
  }
#line 361
  ascii___6 = 0;
  {
#line 361
  while (1) {
    while_continue___13: /* CIL Label */ ;
#line 361
    if (! ((unsigned long )ascii___6 < 1UL << 8)) {
#line 361
      goto while_break___13;
    }
#line 361
    if (! ((unsigned int )((enum syntaxcode )(*((SCHEME_OBJECT *)(syntax_table & 288230376151711743UL) + ((ascii___6 & 255) + 1)) & 15UL)) == (unsigned int )code___0)) {
#line 363
      if ((unsigned long )translation == (unsigned long )((void *)0)) {
#line 363
        tmp___16 = ascii___6;
      } else {
#line 363
        tmp___16 = (int )*(translation + ascii___6);
      }
#line 363
      *(fastmap + tmp___16) = (unsigned char )'\001';
    }
#line 361
    ascii___6 ++;
  }
  while_break___13: /* CIL Label */ ;
  }
#line 364
  goto next;
  case_14: /* CIL Label */ 
  case_13: /* CIL Label */ 
  {
#line 372
  while (1) {
    while_continue___14: /* CIL Label */ ;
#line 372
    if ((unsigned long )pattern_pc >= (unsigned long )pattern_end) {
#line 372
      return_value = -2;
#line 372
      goto return_point;
    } else {
#line 372
      tmp___17 = pattern_pc;
#line 372
      pattern_pc ++;
#line 372
      register_number = (int )*tmp___17;
#line 372
      if (register_number >= 10) {
#line 372
        return_value = -2;
#line 372
        goto return_point;
      }
    }
#line 372
    goto while_break___14;
  }
  while_break___14: /* CIL Label */ ;
  }
#line 373
  goto loop;
  case_15: /* CIL Label */ 
  {
#line 381
  while (1) {
    while_continue___15: /* CIL Label */ ;
#line 381
    if ((unsigned long )pattern_pc >= (unsigned long )pattern_end) {
#line 381
      return_value = -2;
#line 381
      goto return_point;
    } else {
#line 381
      tmp___18 = pattern_pc;
#line 381
      pattern_pc ++;
#line 381
      register_number___0 = (int )*tmp___18;
#line 381
      if (register_number___0 >= 10) {
#line 381
        return_value = -2;
#line 381
        goto return_point;
      }
    }
#line 381
    goto while_break___15;
  }
  while_break___15: /* CIL Label */ ;
  }
#line 382
  ascii___7 = 0;
  {
#line 382
  while (1) {
    while_continue___16: /* CIL Label */ ;
#line 382
    if (! ((unsigned long )ascii___7 < 1UL << 8)) {
#line 382
      goto while_break___16;
    }
#line 383
    *(fastmap + ascii___7) = (unsigned char )'\001';
#line 382
    ascii___7 ++;
  }
  while_break___16: /* CIL Label */ ;
  }
#line 384
  return_value = 1;
#line 384
  goto return_point;
  case_9: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_5: /* CIL Label */ 
#line 394
  return_value = 1;
  {
#line 395
  while (1) {
    while_continue___17: /* CIL Label */ ;
#line 395
    if ((unsigned long )(pattern_pc + 1) >= (unsigned long )pattern_end) {
#line 395
      return_value = -2;
#line 395
      goto return_point;
    }
#line 395
    tmp___19 = pattern_pc;
#line 395
    pattern_pc ++;
#line 395
    offset = (int )*tmp___19;
#line 395
    tmp___20 = pattern_pc;
#line 395
    pattern_pc ++;
#line 395
    _fetched = *((signed char *)tmp___20);
#line 395
    offset += (int )_fetched << 8;
#line 395
    if ((unsigned long )(pattern_pc + offset) < (unsigned long )pattern_start) {
#line 395
      return_value = -2;
#line 395
      goto return_point;
    } else
#line 395
    if ((unsigned long )(pattern_pc + offset) > (unsigned long )pattern_end) {
#line 395
      return_value = -2;
#line 395
      goto return_point;
    }
#line 395
    goto while_break___17;
  }
  while_break___17: /* CIL Label */ ;
  }
#line 396
  pattern_pc += offset;
#line 397
  if (offset > 0) {
#line 398
    goto loop;
  }
#line 405
  if ((unsigned long )pattern_pc >= (unsigned long )pattern_end) {
#line 406
    return_value = -2;
#line 406
    goto return_point;
  }
#line 407
  if ((unsigned int )((enum regexpcode )*(pattern_pc + 0)) != 6U) {
#line 409
    goto loop;
  }
  {
#line 410
  while (1) {
    while_continue___18: /* CIL Label */ ;
#line 410
    if ((unsigned long )(pattern_pc + 1) >= (unsigned long )pattern_end) {
#line 410
      return_value = -2;
#line 410
      goto return_point;
    }
#line 410
    tmp___21 = pattern_pc;
#line 410
    pattern_pc ++;
#line 410
    offset = (int )*tmp___21;
#line 410
    tmp___22 = pattern_pc;
#line 410
    pattern_pc ++;
#line 410
    _fetched___0 = *((signed char *)tmp___22);
#line 410
    offset += (int )_fetched___0 << 8;
#line 410
    if ((unsigned long )(pattern_pc + offset) < (unsigned long )pattern_start) {
#line 410
      return_value = -2;
#line 410
      goto return_point;
    } else
#line 410
    if ((unsigned long )(pattern_pc + offset) > (unsigned long )pattern_end) {
#line 410
      return_value = -2;
#line 410
      goto return_point;
    }
#line 410
    goto while_break___18;
  }
  while_break___18: /* CIL Label */ ;
  }
#line 411
  pattern_pc += offset;
#line 412
  if ((unsigned long )stack_pointer___0 != (unsigned long )(stack_start___0)) {
#line 412
    if ((unsigned long )*(stack_pointer___0 + -1) == (unsigned long )pattern_pc) {
#line 414
      stack_pointer___0 --;
    }
  }
#line 415
  goto loop;
  case_6: /* CIL Label */ 
  {
#line 422
  while (1) {
    while_continue___19: /* CIL Label */ ;
#line 422
    if ((unsigned long )(pattern_pc + 1) >= (unsigned long )pattern_end) {
#line 422
      return_value = -2;
#line 422
      goto return_point;
    }
#line 422
    tmp___23 = pattern_pc;
#line 422
    pattern_pc ++;
#line 422
    offset___0 = (int )*tmp___23;
#line 422
    tmp___24 = pattern_pc;
#line 422
    pattern_pc ++;
#line 422
    _fetched___1 = *((signed char *)tmp___24);
#line 422
    offset___0 += (int )_fetched___1 << 8;
#line 422
    if ((unsigned long )(pattern_pc + offset___0) < (unsigned long )pattern_start) {
#line 422
      return_value = -2;
#line 422
      goto return_point;
    } else
#line 422
    if ((unsigned long )(pattern_pc + offset___0) > (unsigned long )pattern_end) {
#line 422
      return_value = -2;
#line 422
      goto return_point;
    }
#line 422
    goto while_break___19;
  }
  while_break___19: /* CIL Label */ ;
  }
#line 423
  tmp___25 = stack_pointer___0;
#line 423
  stack_pointer___0 ++;
#line 423
  *tmp___25 = pattern_pc + offset___0;
#line 424
  goto loop;
  switch_default: /* CIL Label */ 
#line 428
  return_value = -2;
#line 428
  goto return_point;
  switch_break: /* CIL Label */ ;
  }
  next: 
#line 432
  if ((unsigned long )stack_pointer___0 != (unsigned long )(stack_start___0)) {
#line 434
    stack_pointer___0 --;
#line 434
    pattern_pc = *stack_pointer___0;
#line 435
    goto loop;
  }
  return_point: 
#line 439
  return (return_value);
}
}
#line 485 "/home/khheo/project/mit-scheme-9.2/src/microcode/regex.c"
static _Bool beq_translate(unsigned char *scan1 , unsigned char *scan2 , long length ,
                           unsigned char *translation ) 
{ 
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  int tmp___1 ;
  unsigned char *tmp___2 ;
  unsigned char *tmp___3 ;
  int tmp___4 ;
  long tmp___5 ;

  {
  {
#line 491
  while (1) {
    while_continue: /* CIL Label */ ;
#line 491
    tmp___5 = length;
#line 491
    length --;
#line 491
    if (! (tmp___5 > 0L)) {
#line 491
      goto while_break;
    }
#line 492
    if ((unsigned long )translation == (unsigned long )((void *)0)) {
#line 492
      tmp = scan1;
#line 492
      scan1 ++;
#line 492
      tmp___1 = (int )*tmp;
    } else {
#line 492
      tmp___0 = scan1;
#line 492
      scan1 ++;
#line 492
      tmp___1 = (int )*(translation + *tmp___0);
    }
#line 492
    if ((unsigned long )translation == (unsigned long )((void *)0)) {
#line 492
      tmp___2 = scan2;
#line 492
      scan2 ++;
#line 492
      tmp___4 = (int )*tmp___2;
    } else {
#line 492
      tmp___3 = scan2;
#line 492
      scan2 ++;
#line 492
      tmp___4 = (int )*(translation + *tmp___3);
    }
#line 492
    if (tmp___1 != tmp___4) {
#line 493
      return ((_Bool)0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 494
  return ((_Bool)1);
}
}
#line 497 "/home/khheo/project/mit-scheme-9.2/src/microcode/regex.c"
int re_max_failures  =    1000;
#line 499 "/home/khheo/project/mit-scheme-9.2/src/microcode/regex.c"
int re_match(unsigned char *pattern_start , unsigned char *pattern_end , struct re_buffer *buffer___2 ,
             struct re_registers *registers , unsigned char *match_start , unsigned char *match_end ) 
{ 
  unsigned char *pattern_pc ;
  unsigned char *match_pc ;
  unsigned char *gap_start ;
  unsigned char *gap_end ;
  unsigned char *translation ;
  SCHEME_OBJECT syntax_table ;
  long gap_length ;
  int return_value ;
  unsigned char **stack_start___0 ;
  unsigned char **stack_end___0 ;
  unsigned char **stack_pointer___0 ;
  unsigned char *register_start[10] ;
  unsigned char *register_end[10] ;
  void *tmp ;
  int i ;
  int i___0 ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;
  unsigned char *tmp___3 ;
  int ascii ;
  int ascii_p ;
  unsigned char *tmp___4 ;
  unsigned char *tmp___5 ;
  unsigned char *tmp___6 ;
  int length ;
  int ascii___0 ;
  int _len ;
  unsigned char *tmp___7 ;
  unsigned char *tmp___8 ;
  unsigned char *tmp___9 ;
  unsigned char *tmp___10 ;
  int tmp___11 ;
  int ascii___1 ;
  unsigned char *tmp___12 ;
  unsigned char *tmp___13 ;
  int ascii___2 ;
  int length___0 ;
  unsigned char *tmp___14 ;
  unsigned char *tmp___15 ;
  int _len___0 ;
  unsigned char *tmp___16 ;
  int ascii___3 ;
  int length___1 ;
  unsigned char *tmp___17 ;
  unsigned char *tmp___18 ;
  int _len___1 ;
  unsigned char *tmp___19 ;
  int register_number ;
  unsigned char *tmp___20 ;
  int register_number___0 ;
  unsigned char *tmp___21 ;
  int register_number___1 ;
  unsigned char *start ;
  unsigned char *end ;
  unsigned char *new_end ;
  long length___2 ;
  unsigned char *tmp___22 ;
  long length1 ;
  long length2 ;
  _Bool tmp___23 ;
  _Bool tmp___24 ;
  long length1___0 ;
  long length2___0 ;
  _Bool tmp___25 ;
  _Bool tmp___26 ;
  _Bool tmp___27 ;
  unsigned char *tmp___28 ;
  unsigned char *tmp___29 ;
  unsigned char *tmp___30 ;
  unsigned char *tmp___31 ;
  unsigned char *tmp___32 ;
  unsigned char *tmp___33 ;
  unsigned char *tmp___34 ;
  unsigned char *tmp___35 ;
  int tmp___36 ;
  unsigned char *tmp___37 ;
  unsigned char *tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  int tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;
  int tmp___71 ;
  int ascii___4 ;
  enum syntaxcode code ;
  unsigned char *tmp___72 ;
  unsigned char *tmp___73 ;
  unsigned char *tmp___74 ;
  int ascii___5 ;
  enum syntaxcode code___0 ;
  unsigned char *tmp___75 ;
  unsigned char *tmp___76 ;
  unsigned char *tmp___77 ;
  int ascii___6 ;
  unsigned char *tmp___78 ;
  unsigned char *tmp___79 ;
  int ascii___7 ;
  unsigned char *tmp___80 ;
  unsigned char *tmp___81 ;
  long offset ;
  signed char _fetched ;
  unsigned char *tmp___82 ;
  unsigned char *tmp___83 ;
  long stack_length ;
  unsigned char **stack_temporary ;
  void *tmp___84 ;
  unsigned char **tmp___85 ;
  unsigned char **tmp___86 ;
  long offset___0 ;
  long ascii___8 ;
  signed char _fetched___0 ;
  unsigned char *tmp___87 ;
  unsigned char *tmp___88 ;
  long offset___1 ;
  signed char _fetched___1 ;
  unsigned char *tmp___89 ;
  unsigned char *tmp___90 ;
  long stack_length___0 ;
  unsigned char **stack_temporary___0 ;
  void *tmp___91 ;
  unsigned char **tmp___92 ;
  unsigned char **tmp___93 ;
  void *__cil_tmp157 ;
  void *__cil_tmp158 ;

  {
  {
#line 538
  pattern_pc = pattern_start;
#line 539
  match_pc = match_start;
#line 540
  gap_start = buffer___2->gap_start;
#line 541
  gap_end = buffer___2->gap_end;
#line 542
  gap_length = gap_end - gap_start;
#line 543
  translation = buffer___2->translation;
#line 544
  syntax_table = buffer___2->syntax_table;
#line 546
  tmp = malloc(1024UL * sizeof(*stack_start___0));
#line 546
  stack_start___0 = (unsigned char **)tmp;
  }
#line 547
  if ((unsigned long )stack_start___0 == (unsigned long )((void *)0)) {
#line 548
    return_value = -3;
#line 548
    goto return_point;
  }
#line 550
  stack_end___0 = stack_start___0 + 1024;
#line 551
  stack_pointer___0 = stack_start___0;
#line 556
  i = 0;
  {
#line 556
  while (1) {
    while_continue: /* CIL Label */ ;
#line 556
    if (! (i < 10)) {
#line 556
      goto while_break;
    }
#line 558
    register_start[i] = (unsigned char *)((void *)0);
#line 559
    register_end[i] = (unsigned char *)((void *)0);
#line 556
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  re_match_loop: 
#line 564
  if ((unsigned long )pattern_pc >= (unsigned long )pattern_end) {
#line 567
    if ((unsigned long )registers != (unsigned long )((void *)0)) {
#line 571
      register_start[0] = match_start;
#line 572
      register_end[0] = match_pc;
#line 573
      i___0 = 0;
      {
#line 573
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 573
        if (! (i___0 < 10)) {
#line 573
          goto while_break___0;
        }
#line 575
        if ((unsigned long )register_start[i___0] == (unsigned long )((void *)0)) {
#line 575
          registers->start[i___0] = -1L;
        } else {
#line 575
          if ((unsigned long )register_start[i___0] > (unsigned long )gap_start) {
#line 575
            tmp___0 = register_start[i___0] - gap_length;
          } else {
#line 575
            tmp___0 = register_start[i___0];
          }
#line 575
          registers->start[i___0] = tmp___0 - buffer___2->text;
        }
#line 579
        if ((unsigned long )register_end[i___0] == (unsigned long )((void *)0)) {
#line 579
          registers->end[i___0] = -1L;
        } else {
#line 579
          if ((unsigned long )register_end[i___0] > (unsigned long )gap_start) {
#line 579
            tmp___1 = register_end[i___0] - gap_length;
          } else {
#line 579
            tmp___1 = register_end[i___0];
          }
#line 579
          registers->end[i___0] = tmp___1 - buffer___2->text;
        }
#line 573
        i___0 ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 585
    if ((unsigned long )match_pc > (unsigned long )gap_start) {
#line 585
      tmp___2 = match_pc - gap_length;
    } else {
#line 585
      tmp___2 = match_pc;
    }
#line 585
    return_value = (int )(tmp___2 - buffer___2->text);
#line 585
    goto return_point;
  }
#line 588
  tmp___3 = pattern_pc;
#line 588
  pattern_pc ++;
  {
#line 590
  if ((unsigned int )((enum regexpcode )*tmp___3) == 0U) {
#line 590
    goto case_0;
  }
#line 593
  if ((unsigned int )((enum regexpcode )*tmp___3) == 1U) {
#line 593
    goto case_1;
  }
#line 605
  if ((unsigned int )((enum regexpcode )*tmp___3) == 2U) {
#line 605
    goto case_2;
  }
#line 620
  if ((unsigned int )((enum regexpcode )*tmp___3) == 10U) {
#line 620
    goto case_10;
  }
#line 649
  if ((unsigned int )((enum regexpcode )*tmp___3) == 11U) {
#line 649
    goto case_11;
  }
#line 652
  if ((unsigned int )((enum regexpcode )*tmp___3) == 12U) {
#line 652
    goto case_12;
  }
#line 664
  if ((unsigned int )((enum regexpcode )*tmp___3) == 13U) {
#line 664
    goto case_13;
  }
#line 673
  if ((unsigned int )((enum regexpcode )*tmp___3) == 14U) {
#line 673
    goto case_14;
  }
#line 683
  if ((unsigned int )((enum regexpcode )*tmp___3) == 15U) {
#line 683
    goto case_15;
  }
#line 734
  if ((unsigned int )((enum regexpcode )*tmp___3) == 16U) {
#line 734
    goto case_16;
  }
#line 742
  if ((unsigned int )((enum regexpcode )*tmp___3) == 17U) {
#line 742
    goto case_17;
  }
#line 750
  if ((unsigned int )((enum regexpcode )*tmp___3) == 3U) {
#line 750
    goto case_3;
  }
#line 762
  if ((unsigned int )((enum regexpcode )*tmp___3) == 4U) {
#line 762
    goto case_4;
  }
#line 786
  if ((unsigned int )((enum regexpcode )*tmp___3) == 22U) {
#line 786
    goto case_22;
  }
#line 791
  if ((unsigned int )((enum regexpcode )*tmp___3) == 23U) {
#line 791
    goto case_23;
  }
#line 796
  if ((unsigned int )((enum regexpcode )*tmp___3) == 20U) {
#line 796
    goto case_20;
  }
#line 801
  if ((unsigned int )((enum regexpcode )*tmp___3) == 21U) {
#line 801
    goto case_21;
  }
#line 808
  if ((unsigned int )((enum regexpcode )*tmp___3) == 24U) {
#line 808
    goto case_24;
  }
#line 820
  if ((unsigned int )((enum regexpcode )*tmp___3) == 25U) {
#line 820
    goto case_25;
  }
#line 832
  if ((unsigned int )((enum regexpcode )*tmp___3) == 18U) {
#line 832
    goto case_18;
  }
#line 842
  if ((unsigned int )((enum regexpcode )*tmp___3) == 19U) {
#line 842
    goto case_19;
  }
#line 868
  if ((unsigned int )((enum regexpcode )*tmp___3) == 6U) {
#line 868
    goto case_6;
  }
#line 880
  if ((unsigned int )((enum regexpcode )*tmp___3) == 8U) {
#line 880
    goto case_8;
  }
#line 962
  if ((unsigned int )((enum regexpcode )*tmp___3) == 7U) {
#line 962
    goto re_match_finalize_jump;
  }
#line 969
  if ((unsigned int )((enum regexpcode )*tmp___3) == 5U) {
#line 969
    goto re_match_jump;
  }
#line 979
  if ((unsigned int )((enum regexpcode )*tmp___3) == 9U) {
#line 979
    goto case_9;
  }
#line 985
  goto switch_default___1;
  case_0: /* CIL Label */ 
#line 591
  goto re_match_loop;
  case_1: /* CIL Label */ 
  {
#line 598
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 598
    if ((unsigned long )match_pc >= (unsigned long )match_end) {
#line 598
      goto re_match_fail;
    }
#line 598
    if ((unsigned long )translation == (unsigned long )((void *)0)) {
#line 598
      tmp___4 = match_pc;
#line 598
      match_pc ++;
#line 598
      ascii = (int )*tmp___4;
    } else {
#line 598
      tmp___5 = match_pc;
#line 598
      match_pc ++;
#line 598
      ascii = (int )*(translation + *tmp___5);
    }
#line 598
    if ((unsigned long )match_pc == (unsigned long )gap_start) {
#line 598
      match_pc = gap_end;
    }
#line 598
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 599
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 599
    if ((unsigned long )pattern_pc >= (unsigned long )pattern_end) {
#line 599
      return_value = -2;
#line 599
      goto return_point;
    }
#line 599
    tmp___6 = pattern_pc;
#line 599
    pattern_pc ++;
#line 599
    ascii_p = (int )*tmp___6;
#line 599
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 600
  if (ascii == ascii_p) {
#line 601
    goto re_match_loop;
  }
#line 602
  goto re_match_fail;
  case_2: /* CIL Label */ 
  {
#line 610
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 610
    if ((unsigned long )pattern_pc >= (unsigned long )pattern_end) {
#line 610
      return_value = -2;
#line 610
      goto return_point;
    }
#line 610
    tmp___7 = pattern_pc;
#line 610
    pattern_pc ++;
#line 610
    _len = (int )*tmp___7;
#line 610
    if ((unsigned long )(pattern_pc + _len) > (unsigned long )pattern_end) {
#line 610
      return_value = -2;
#line 610
      goto return_point;
    }
#line 610
    length = _len;
#line 610
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 611
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 611
    tmp___11 = length;
#line 611
    length --;
#line 611
    if (! (tmp___11 > 0)) {
#line 611
      goto while_break___4;
    }
    {
#line 613
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 613
      if ((unsigned long )match_pc >= (unsigned long )match_end) {
#line 613
        goto re_match_fail;
      }
#line 613
      if ((unsigned long )translation == (unsigned long )((void *)0)) {
#line 613
        tmp___8 = match_pc;
#line 613
        match_pc ++;
#line 613
        ascii___0 = (int )*tmp___8;
      } else {
#line 613
        tmp___9 = match_pc;
#line 613
        match_pc ++;
#line 613
        ascii___0 = (int )*(translation + *tmp___9);
      }
#line 613
      if ((unsigned long )match_pc == (unsigned long )gap_start) {
#line 613
        match_pc = gap_end;
      }
#line 613
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 614
    tmp___10 = pattern_pc;
#line 614
    pattern_pc ++;
#line 614
    if (ascii___0 != (int )*tmp___10) {
#line 615
      goto re_match_fail;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
#line 617
  goto re_match_loop;
  case_10: /* CIL Label */ 
  {
#line 624
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 624
    if ((unsigned long )match_pc >= (unsigned long )match_end) {
#line 624
      goto re_match_fail;
    }
#line 624
    if ((unsigned long )translation == (unsigned long )((void *)0)) {
#line 624
      tmp___12 = match_pc;
#line 624
      match_pc ++;
#line 624
      ascii___1 = (int )*tmp___12;
    } else {
#line 624
      tmp___13 = match_pc;
#line 624
      match_pc ++;
#line 624
      ascii___1 = (int )*(translation + *tmp___13);
    }
#line 624
    if ((unsigned long )match_pc == (unsigned long )gap_start) {
#line 624
      match_pc = gap_end;
    }
#line 624
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 625
  if (ascii___1 == 10) {
#line 626
    goto re_match_fail;
  }
#line 627
  goto re_match_loop;
  case_11: /* CIL Label */ 
  {
#line 650
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 650
    if ((unsigned long )match_pc >= (unsigned long )match_end) {
#line 650
      goto re_match_fail;
    }
#line 650
    if ((unsigned long )translation == (unsigned long )((void *)0)) {
#line 650
      tmp___14 = match_pc;
#line 650
      match_pc ++;
#line 650
      ascii___2 = (int )*tmp___14;
    } else {
#line 650
      tmp___15 = match_pc;
#line 650
      match_pc ++;
#line 650
      ascii___2 = (int )*(translation + *tmp___15);
    }
#line 650
    if ((unsigned long )match_pc == (unsigned long )gap_start) {
#line 650
      match_pc = gap_end;
    }
#line 650
    goto while_break___7;
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 650
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 650
    if ((unsigned long )pattern_pc >= (unsigned long )pattern_end) {
#line 650
      return_value = -2;
#line 650
      goto return_point;
    }
#line 650
    tmp___16 = pattern_pc;
#line 650
    pattern_pc ++;
#line 650
    _len___0 = (int )*tmp___16;
#line 650
    if ((unsigned long )(pattern_pc + _len___0) > (unsigned long )pattern_end) {
#line 650
      return_value = -2;
#line 650
      goto return_point;
    }
#line 650
    length___0 = _len___0;
#line 650
    goto while_break___8;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 650
  if (ascii___2 < length___0 * 8) {
#line 650
    if (((int )*(pattern_pc + ascii___2 / 8) & (1 << ascii___2 % 8)) != 0) {
#line 650
      pattern_pc += length___0;
#line 650
      goto re_match_loop;
    } else {
#line 650
      pattern_pc += length___0;
#line 650
      goto re_match_fail;
    }
  } else {
#line 650
    pattern_pc += length___0;
#line 650
    goto re_match_fail;
  }
  case_12: /* CIL Label */ 
  {
#line 653
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 653
    if ((unsigned long )match_pc >= (unsigned long )match_end) {
#line 653
      goto re_match_fail;
    }
#line 653
    if ((unsigned long )translation == (unsigned long )((void *)0)) {
#line 653
      tmp___17 = match_pc;
#line 653
      match_pc ++;
#line 653
      ascii___3 = (int )*tmp___17;
    } else {
#line 653
      tmp___18 = match_pc;
#line 653
      match_pc ++;
#line 653
      ascii___3 = (int )*(translation + *tmp___18);
    }
#line 653
    if ((unsigned long )match_pc == (unsigned long )gap_start) {
#line 653
      match_pc = gap_end;
    }
#line 653
    goto while_break___9;
  }
  while_break___9: /* CIL Label */ ;
  }
  {
#line 653
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 653
    if ((unsigned long )pattern_pc >= (unsigned long )pattern_end) {
#line 653
      return_value = -2;
#line 653
      goto return_point;
    }
#line 653
    tmp___19 = pattern_pc;
#line 653
    pattern_pc ++;
#line 653
    _len___1 = (int )*tmp___19;
#line 653
    if ((unsigned long )(pattern_pc + _len___1) > (unsigned long )pattern_end) {
#line 653
      return_value = -2;
#line 653
      goto return_point;
    }
#line 653
    length___1 = _len___1;
#line 653
    goto while_break___10;
  }
  while_break___10: /* CIL Label */ ;
  }
#line 653
  if (ascii___3 < length___1 * 8) {
#line 653
    if (((int )*(pattern_pc + ascii___3 / 8) & (1 << ascii___3 % 8)) != 0) {
#line 653
      pattern_pc += length___1;
#line 653
      goto re_match_fail;
    } else {
#line 653
      pattern_pc += length___1;
#line 653
      goto re_match_loop;
    }
  } else {
#line 653
    pattern_pc += length___1;
#line 653
    goto re_match_loop;
  }
  case_13: /* CIL Label */ 
  {
#line 668
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 668
    if ((unsigned long )pattern_pc >= (unsigned long )pattern_end) {
#line 668
      return_value = -2;
#line 668
      goto return_point;
    } else {
#line 668
      tmp___20 = pattern_pc;
#line 668
      pattern_pc ++;
#line 668
      register_number = (int )*tmp___20;
#line 668
      if (register_number >= 10) {
#line 668
        return_value = -2;
#line 668
        goto return_point;
      }
    }
#line 668
    goto while_break___11;
  }
  while_break___11: /* CIL Label */ ;
  }
#line 669
  register_start[register_number] = match_pc;
#line 670
  goto re_match_loop;
  case_14: /* CIL Label */ 
  {
#line 677
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 677
    if ((unsigned long )pattern_pc >= (unsigned long )pattern_end) {
#line 677
      return_value = -2;
#line 677
      goto return_point;
    } else {
#line 677
      tmp___21 = pattern_pc;
#line 677
      pattern_pc ++;
#line 677
      register_number___0 = (int )*tmp___21;
#line 677
      if (register_number___0 >= 10) {
#line 677
        return_value = -2;
#line 677
        goto return_point;
      }
    }
#line 677
    goto while_break___12;
  }
  while_break___12: /* CIL Label */ ;
  }
#line 678
  if ((unsigned long )match_pc == (unsigned long )gap_end) {
#line 678
    register_end[register_number___0] = gap_start;
  } else {
#line 678
    register_end[register_number___0] = match_pc;
  }
#line 680
  goto re_match_loop;
  case_15: /* CIL Label */ 
  {
#line 689
  while (1) {
    while_continue___13: /* CIL Label */ ;
#line 689
    if ((unsigned long )pattern_pc >= (unsigned long )pattern_end) {
#line 689
      return_value = -2;
#line 689
      goto return_point;
    } else {
#line 689
      tmp___22 = pattern_pc;
#line 689
      pattern_pc ++;
#line 689
      register_number___1 = (int )*tmp___22;
#line 689
      if (register_number___1 >= 10) {
#line 689
        return_value = -2;
#line 689
        goto return_point;
      }
    }
#line 689
    goto while_break___13;
  }
  while_break___13: /* CIL Label */ ;
  }
#line 690
  start = register_start[register_number___1];
#line 691
  end = register_end[register_number___1];
#line 692
  length___2 = end - start;
#line 693
  if (length___2 <= 0L) {
#line 694
    goto re_match_loop;
  }
#line 695
  new_end = match_pc + length___2;
#line 696
  if ((unsigned long )new_end > (unsigned long )match_end) {
#line 697
    goto re_match_fail;
  }
#line 698
  if ((unsigned long )match_pc <= (unsigned long )gap_start) {
#line 698
    if ((unsigned long )new_end > (unsigned long )gap_start) {
#line 702
      new_end += gap_length;
#line 703
      if ((unsigned long )new_end > (unsigned long )match_end) {
#line 704
        goto re_match_fail;
      }
      {
#line 705
      length1 = gap_start - match_pc;
#line 706
      length2 = length___2 - length1;
#line 707
      tmp___23 = beq_translate(match_pc, start, length1, translation);
      }
#line 707
      if (tmp___23) {
        {
#line 707
        tmp___24 = beq_translate(gap_end, start + length1, length2, translation);
        }
#line 707
        if (! tmp___24) {
#line 711
          goto re_match_fail;
        }
      } else {
#line 711
        goto re_match_fail;
      }
    } else {
#line 698
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 713
  if ((unsigned long )start <= (unsigned long )gap_start) {
#line 713
    if ((unsigned long )end > (unsigned long )gap_start) {
      {
#line 717
      length1___0 = gap_start - start;
#line 718
      length2___0 = end - gap_end;
#line 719
      tmp___25 = beq_translate(match_pc, start, length1___0, translation);
      }
#line 719
      if (tmp___25) {
        {
#line 719
        tmp___26 = beq_translate(match_pc + length1___0, gap_end, length2___0, translation);
        }
#line 719
        if (! tmp___26) {
#line 723
          goto re_match_fail;
        }
      } else {
#line 723
        goto re_match_fail;
      }
    } else {
#line 713
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 727
    tmp___27 = beq_translate(match_pc, start, length___2, translation);
    }
#line 727
    if (! tmp___27) {
#line 728
      goto re_match_fail;
    }
  }
#line 730
  if ((unsigned long )new_end == (unsigned long )gap_start) {
#line 730
    match_pc = gap_end;
  } else {
#line 730
    match_pc = new_end;
  }
#line 731
  goto re_match_loop;
  case_16: /* CIL Label */ 
#line 736
  if ((unsigned long )match_pc > (unsigned long )gap_start) {
#line 736
    tmp___28 = match_pc - gap_length;
  } else {
#line 736
    tmp___28 = match_pc;
  }
#line 736
  if ((unsigned long )buffer___2->text_start > (unsigned long )gap_start) {
#line 736
    tmp___29 = buffer___2->text_start - gap_length;
  } else {
#line 736
    tmp___29 = buffer___2->text_start;
  }
#line 736
  if (tmp___28 - buffer___2->text == tmp___29 - buffer___2->text) {
#line 738
    goto re_match_loop;
  }
#line 739
  goto re_match_fail;
  case_17: /* CIL Label */ 
#line 744
  if ((unsigned long )match_pc > (unsigned long )gap_start) {
#line 744
    tmp___30 = match_pc - gap_length;
  } else {
#line 744
    tmp___30 = match_pc;
  }
#line 744
  if ((unsigned long )buffer___2->text_end > (unsigned long )gap_start) {
#line 744
    tmp___31 = buffer___2->text_end - gap_length;
  } else {
#line 744
    tmp___31 = buffer___2->text_end;
  }
#line 744
  if (tmp___30 - buffer___2->text == tmp___31 - buffer___2->text) {
#line 746
    goto re_match_loop;
  }
#line 747
  goto re_match_fail;
  case_3: /* CIL Label */ 
#line 752
  if ((unsigned long )match_pc > (unsigned long )gap_start) {
#line 752
    tmp___32 = match_pc - gap_length;
  } else {
#line 752
    tmp___32 = match_pc;
  }
#line 752
  if ((unsigned long )buffer___2->text_start > (unsigned long )gap_start) {
#line 752
    tmp___33 = buffer___2->text_start - gap_length;
  } else {
#line 752
    tmp___33 = buffer___2->text_start;
  }
#line 752
  if (tmp___32 - buffer___2->text == tmp___33 - buffer___2->text) {
#line 754
    goto re_match_loop;
  }
#line 755
  if ((unsigned long )translation == (unsigned long )((void *)0)) {
#line 755
    if ((unsigned long )match_pc == (unsigned long )gap_end) {
#line 755
      tmp___34 = gap_start;
    } else {
#line 755
      tmp___34 = match_pc;
    }
#line 755
    tmp___36 = (int )*(tmp___34 + -1);
  } else {
#line 755
    if ((unsigned long )match_pc == (unsigned long )gap_end) {
#line 755
      tmp___35 = gap_start;
    } else {
#line 755
      tmp___35 = match_pc;
    }
#line 755
    tmp___36 = (int )*(translation + *(tmp___35 + -1));
  }
#line 755
  if (tmp___36 == 10) {
#line 758
    goto re_match_loop;
  }
#line 759
  goto re_match_fail;
  case_4: /* CIL Label */ 
#line 764
  if ((unsigned long )match_pc > (unsigned long )gap_start) {
#line 764
    tmp___37 = match_pc - gap_length;
  } else {
#line 764
    tmp___37 = match_pc;
  }
#line 764
  if ((unsigned long )buffer___2->text_end > (unsigned long )gap_start) {
#line 764
    tmp___38 = buffer___2->text_end - gap_length;
  } else {
#line 764
    tmp___38 = buffer___2->text_end;
  }
#line 764
  if (tmp___37 - buffer___2->text == tmp___38 - buffer___2->text) {
#line 767
    goto re_match_loop;
  } else {
#line 764
    if ((unsigned long )translation == (unsigned long )((void *)0)) {
#line 764
      tmp___39 = (int )*(match_pc + 0);
    } else {
#line 764
      tmp___39 = (int )*(translation + *(match_pc + 0));
    }
#line 764
    if (tmp___39 == 10) {
#line 767
      goto re_match_loop;
    }
  }
#line 768
  goto re_match_fail;
  case_22: /* CIL Label */ 
#line 788
  if ((unsigned long )match_pc == (unsigned long )gap_end) {
#line 788
    if ((unsigned long )gap_start != (unsigned long )buffer___2->text_start) {
#line 788
      if ((unsigned long )translation == (unsigned long )((void *)0)) {
#line 788
        tmp___40 = (int )*(gap_start + -1);
      } else {
#line 788
        tmp___40 = (int )*(translation + *(gap_start + -1));
      }
#line 788
      if ((unsigned int )((enum syntaxcode )(*((SCHEME_OBJECT *)(syntax_table & 288230376151711743UL) + ((tmp___40 & 255) + 1)) & 15UL)) == 2U) {
#line 788
        tmp___41 = 1;
      } else {
#line 788
        tmp___41 = 0;
      }
    } else {
#line 788
      tmp___41 = 0;
    }
#line 788
    if ((unsigned long )gap_end != (unsigned long )buffer___2->text_end) {
#line 788
      if ((unsigned long )translation == (unsigned long )((void *)0)) {
#line 788
        tmp___42 = (int )*(gap_end + 0);
      } else {
#line 788
        tmp___42 = (int )*(translation + *(gap_end + 0));
      }
#line 788
      if ((unsigned int )((enum syntaxcode )(*((SCHEME_OBJECT *)(syntax_table & 288230376151711743UL) + ((tmp___42 & 255) + 1)) & 15UL)) == 2U) {
#line 788
        tmp___43 = 1;
      } else {
#line 788
        tmp___43 = 0;
      }
    } else {
#line 788
      tmp___43 = 0;
    }
#line 788
    tmp___48 = tmp___41 != tmp___43;
  } else {
#line 788
    if ((unsigned long )match_pc != (unsigned long )buffer___2->text_start) {
#line 788
      if ((unsigned long )translation == (unsigned long )((void *)0)) {
#line 788
        tmp___44 = (int )*(match_pc + -1);
      } else {
#line 788
        tmp___44 = (int )*(translation + *(match_pc + -1));
      }
#line 788
      if ((unsigned int )((enum syntaxcode )(*((SCHEME_OBJECT *)(syntax_table & 288230376151711743UL) + ((tmp___44 & 255) + 1)) & 15UL)) == 2U) {
#line 788
        tmp___45 = 1;
      } else {
#line 788
        tmp___45 = 0;
      }
    } else {
#line 788
      tmp___45 = 0;
    }
#line 788
    if ((unsigned long )match_pc != (unsigned long )buffer___2->text_end) {
#line 788
      if ((unsigned long )translation == (unsigned long )((void *)0)) {
#line 788
        tmp___46 = (int )*(match_pc + 0);
      } else {
#line 788
        tmp___46 = (int )*(translation + *(match_pc + 0));
      }
#line 788
      if ((unsigned int )((enum syntaxcode )(*((SCHEME_OBJECT *)(syntax_table & 288230376151711743UL) + ((tmp___46 & 255) + 1)) & 15UL)) == 2U) {
#line 788
        tmp___47 = 1;
      } else {
#line 788
        tmp___47 = 0;
      }
    } else {
#line 788
      tmp___47 = 0;
    }
#line 788
    tmp___48 = tmp___45 != tmp___47;
  }
#line 788
  if (tmp___48) {
#line 788
    goto re_match_loop;
  }
#line 788
  goto re_match_fail;
  case_23: /* CIL Label */ 
#line 793
  if ((unsigned long )match_pc == (unsigned long )gap_end) {
#line 793
    if ((unsigned long )gap_start != (unsigned long )buffer___2->text_start) {
#line 793
      if ((unsigned long )translation == (unsigned long )((void *)0)) {
#line 793
        tmp___49 = (int )*(gap_start + -1);
      } else {
#line 793
        tmp___49 = (int )*(translation + *(gap_start + -1));
      }
#line 793
      if ((unsigned int )((enum syntaxcode )(*((SCHEME_OBJECT *)(syntax_table & 288230376151711743UL) + ((tmp___49 & 255) + 1)) & 15UL)) == 2U) {
#line 793
        tmp___50 = 1;
      } else {
#line 793
        tmp___50 = 0;
      }
    } else {
#line 793
      tmp___50 = 0;
    }
#line 793
    if ((unsigned long )gap_end != (unsigned long )buffer___2->text_end) {
#line 793
      if ((unsigned long )translation == (unsigned long )((void *)0)) {
#line 793
        tmp___51 = (int )*(gap_end + 0);
      } else {
#line 793
        tmp___51 = (int )*(translation + *(gap_end + 0));
      }
#line 793
      if ((unsigned int )((enum syntaxcode )(*((SCHEME_OBJECT *)(syntax_table & 288230376151711743UL) + ((tmp___51 & 255) + 1)) & 15UL)) == 2U) {
#line 793
        tmp___52 = 1;
      } else {
#line 793
        tmp___52 = 0;
      }
    } else {
#line 793
      tmp___52 = 0;
    }
#line 793
    tmp___57 = tmp___50 == tmp___52;
  } else {
#line 793
    if ((unsigned long )match_pc != (unsigned long )buffer___2->text_start) {
#line 793
      if ((unsigned long )translation == (unsigned long )((void *)0)) {
#line 793
        tmp___53 = (int )*(match_pc + -1);
      } else {
#line 793
        tmp___53 = (int )*(translation + *(match_pc + -1));
      }
#line 793
      if ((unsigned int )((enum syntaxcode )(*((SCHEME_OBJECT *)(syntax_table & 288230376151711743UL) + ((tmp___53 & 255) + 1)) & 15UL)) == 2U) {
#line 793
        tmp___54 = 1;
      } else {
#line 793
        tmp___54 = 0;
      }
    } else {
#line 793
      tmp___54 = 0;
    }
#line 793
    if ((unsigned long )match_pc != (unsigned long )buffer___2->text_end) {
#line 793
      if ((unsigned long )translation == (unsigned long )((void *)0)) {
#line 793
        tmp___55 = (int )*(match_pc + 0);
      } else {
#line 793
        tmp___55 = (int )*(translation + *(match_pc + 0));
      }
#line 793
      if ((unsigned int )((enum syntaxcode )(*((SCHEME_OBJECT *)(syntax_table & 288230376151711743UL) + ((tmp___55 & 255) + 1)) & 15UL)) == 2U) {
#line 793
        tmp___56 = 1;
      } else {
#line 793
        tmp___56 = 0;
      }
    } else {
#line 793
      tmp___56 = 0;
    }
#line 793
    tmp___57 = tmp___54 == tmp___56;
  }
#line 793
  if (tmp___57) {
#line 793
    goto re_match_loop;
  }
#line 793
  goto re_match_fail;
  case_20: /* CIL Label */ 
#line 798
  if ((unsigned long )match_pc == (unsigned long )gap_end) {
#line 798
    if ((unsigned long )gap_start != (unsigned long )buffer___2->text_start) {
#line 798
      if ((unsigned long )translation == (unsigned long )((void *)0)) {
#line 798
        tmp___58 = (int )*(gap_start + -1);
      } else {
#line 798
        tmp___58 = (int )*(translation + *(gap_start + -1));
      }
#line 798
      if ((unsigned int )((enum syntaxcode )(*((SCHEME_OBJECT *)(syntax_table & 288230376151711743UL) + ((tmp___58 & 255) + 1)) & 15UL)) == 2U) {
#line 798
        tmp___60 = 0;
      } else {
#line 798
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 798
    if ((unsigned long )gap_end != (unsigned long )buffer___2->text_end) {
#line 798
      if ((unsigned long )translation == (unsigned long )((void *)0)) {
#line 798
        tmp___59 = (int )*(gap_end + 0);
      } else {
#line 798
        tmp___59 = (int )*(translation + *(gap_end + 0));
      }
#line 798
      if ((unsigned int )((enum syntaxcode )(*((SCHEME_OBJECT *)(syntax_table & 288230376151711743UL) + ((tmp___59 & 255) + 1)) & 15UL)) == 2U) {
#line 798
        tmp___60 = 1;
      } else {
#line 798
        tmp___60 = 0;
      }
    } else {
#line 798
      tmp___60 = 0;
    }
#line 798
    tmp___64 = tmp___60;
  } else {
#line 798
    if ((unsigned long )match_pc != (unsigned long )buffer___2->text_start) {
#line 798
      if ((unsigned long )translation == (unsigned long )((void *)0)) {
#line 798
        tmp___61 = (int )*(match_pc + -1);
      } else {
#line 798
        tmp___61 = (int )*(translation + *(match_pc + -1));
      }
#line 798
      if ((unsigned int )((enum syntaxcode )(*((SCHEME_OBJECT *)(syntax_table & 288230376151711743UL) + ((tmp___61 & 255) + 1)) & 15UL)) == 2U) {
#line 798
        tmp___63 = 0;
      } else {
#line 798
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 798
    if ((unsigned long )match_pc != (unsigned long )buffer___2->text_end) {
#line 798
      if ((unsigned long )translation == (unsigned long )((void *)0)) {
#line 798
        tmp___62 = (int )*(match_pc + 0);
      } else {
#line 798
        tmp___62 = (int )*(translation + *(match_pc + 0));
      }
#line 798
      if ((unsigned int )((enum syntaxcode )(*((SCHEME_OBJECT *)(syntax_table & 288230376151711743UL) + ((tmp___62 & 255) + 1)) & 15UL)) == 2U) {
#line 798
        tmp___63 = 1;
      } else {
#line 798
        tmp___63 = 0;
      }
    } else {
#line 798
      tmp___63 = 0;
    }
#line 798
    tmp___64 = tmp___63;
  }
#line 798
  if (tmp___64) {
#line 798
    goto re_match_loop;
  }
#line 798
  goto re_match_fail;
  case_21: /* CIL Label */ 
#line 803
  if ((unsigned long )match_pc == (unsigned long )gap_end) {
#line 803
    if ((unsigned long )gap_start != (unsigned long )buffer___2->text_start) {
#line 803
      if ((unsigned long )translation == (unsigned long )((void *)0)) {
#line 803
        tmp___65 = (int )*(gap_start + -1);
      } else {
#line 803
        tmp___65 = (int )*(translation + *(gap_start + -1));
      }
#line 803
      if ((unsigned int )((enum syntaxcode )(*((SCHEME_OBJECT *)(syntax_table & 288230376151711743UL) + ((tmp___65 & 255) + 1)) & 15UL)) == 2U) {
#line 803
        if ((unsigned long )gap_end != (unsigned long )buffer___2->text_end) {
#line 803
          if ((unsigned long )translation == (unsigned long )((void *)0)) {
#line 803
            tmp___66 = (int )*(gap_end + 0);
          } else {
#line 803
            tmp___66 = (int )*(translation + *(gap_end + 0));
          }
#line 803
          if ((unsigned int )((enum syntaxcode )(*((SCHEME_OBJECT *)(syntax_table & 288230376151711743UL) + ((tmp___66 & 255) + 1)) & 15UL)) == 2U) {
#line 803
            tmp___67 = 0;
          } else {
#line 803
            tmp___67 = 1;
          }
        } else {
#line 803
          tmp___67 = 1;
        }
      } else {
#line 803
        tmp___67 = 0;
      }
    } else {
#line 803
      tmp___67 = 0;
    }
#line 803
    tmp___71 = tmp___67;
  } else {
#line 803
    if ((unsigned long )match_pc != (unsigned long )buffer___2->text_start) {
#line 803
      if ((unsigned long )translation == (unsigned long )((void *)0)) {
#line 803
        tmp___68 = (int )*(match_pc + -1);
      } else {
#line 803
        tmp___68 = (int )*(translation + *(match_pc + -1));
      }
#line 803
      if ((unsigned int )((enum syntaxcode )(*((SCHEME_OBJECT *)(syntax_table & 288230376151711743UL) + ((tmp___68 & 255) + 1)) & 15UL)) == 2U) {
#line 803
        if ((unsigned long )match_pc != (unsigned long )buffer___2->text_end) {
#line 803
          if ((unsigned long )translation == (unsigned long )((void *)0)) {
#line 803
            tmp___69 = (int )*(match_pc + 0);
          } else {
#line 803
            tmp___69 = (int )*(translation + *(match_pc + 0));
          }
#line 803
          if ((unsigned int )((enum syntaxcode )(*((SCHEME_OBJECT *)(syntax_table & 288230376151711743UL) + ((tmp___69 & 255) + 1)) & 15UL)) == 2U) {
#line 803
            tmp___70 = 0;
          } else {
#line 803
            tmp___70 = 1;
          }
        } else {
#line 803
          tmp___70 = 1;
        }
      } else {
#line 803
        tmp___70 = 0;
      }
    } else {
#line 803
      tmp___70 = 0;
    }
#line 803
    tmp___71 = tmp___70;
  }
#line 803
  if (tmp___71) {
#line 803
    goto re_match_loop;
  }
#line 803
  goto re_match_fail;
  case_24: /* CIL Label */ 
  {
#line 813
  while (1) {
    while_continue___14: /* CIL Label */ ;
#line 813
    if ((unsigned long )match_pc >= (unsigned long )match_end) {
#line 813
      goto re_match_fail;
    }
#line 813
    if ((unsigned long )translation == (unsigned long )((void *)0)) {
#line 813
      tmp___72 = match_pc;
#line 813
      match_pc ++;
#line 813
      ascii___4 = (int )*tmp___72;
    } else {
#line 813
      tmp___73 = match_pc;
#line 813
      match_pc ++;
#line 813
      ascii___4 = (int )*(translation + *tmp___73);
    }
#line 813
    if ((unsigned long )match_pc == (unsigned long )gap_start) {
#line 813
      match_pc = gap_end;
    }
#line 813
    goto while_break___14;
  }
  while_break___14: /* CIL Label */ ;
  }
  {
#line 814
  while (1) {
    while_continue___15: /* CIL Label */ ;
#line 814
    if ((unsigned long )pattern_pc >= (unsigned long )pattern_end) {
#line 814
      return_value = -2;
#line 814
      goto return_point;
    } else {
#line 814
      tmp___74 = pattern_pc;
#line 814
      pattern_pc ++;
#line 814
      code = (enum syntaxcode )*tmp___74;
#line 814
      if ((int )code >= 13) {
#line 814
        return_value = -2;
#line 814
        goto return_point;
      }
    }
#line 814
    goto while_break___15;
  }
  while_break___15: /* CIL Label */ ;
  }
#line 815
  if ((unsigned int )((enum syntaxcode )(*((SCHEME_OBJECT *)(syntax_table & 288230376151711743UL) + ((ascii___4 & 255) + 1)) & 15UL)) == (unsigned int )code) {
#line 816
    goto re_match_loop;
  }
#line 817
  goto re_match_fail;
  case_25: /* CIL Label */ 
  {
#line 825
  while (1) {
    while_continue___16: /* CIL Label */ ;
#line 825
    if ((unsigned long )match_pc >= (unsigned long )match_end) {
#line 825
      goto re_match_fail;
    }
#line 825
    if ((unsigned long )translation == (unsigned long )((void *)0)) {
#line 825
      tmp___75 = match_pc;
#line 825
      match_pc ++;
#line 825
      ascii___5 = (int )*tmp___75;
    } else {
#line 825
      tmp___76 = match_pc;
#line 825
      match_pc ++;
#line 825
      ascii___5 = (int )*(translation + *tmp___76);
    }
#line 825
    if ((unsigned long )match_pc == (unsigned long )gap_start) {
#line 825
      match_pc = gap_end;
    }
#line 825
    goto while_break___16;
  }
  while_break___16: /* CIL Label */ ;
  }
  {
#line 826
  while (1) {
    while_continue___17: /* CIL Label */ ;
#line 826
    if ((unsigned long )pattern_pc >= (unsigned long )pattern_end) {
#line 826
      return_value = -2;
#line 826
      goto return_point;
    } else {
#line 826
      tmp___77 = pattern_pc;
#line 826
      pattern_pc ++;
#line 826
      code___0 = (enum syntaxcode )*tmp___77;
#line 826
      if ((int )code___0 >= 13) {
#line 826
        return_value = -2;
#line 826
        goto return_point;
      }
    }
#line 826
    goto while_break___17;
  }
  while_break___17: /* CIL Label */ ;
  }
#line 827
  if (! ((unsigned int )((enum syntaxcode )(*((SCHEME_OBJECT *)(syntax_table & 288230376151711743UL) + ((ascii___5 & 255) + 1)) & 15UL)) == (unsigned int )code___0)) {
#line 828
    goto re_match_loop;
  }
#line 829
  goto re_match_fail;
  case_18: /* CIL Label */ 
  {
#line 836
  while (1) {
    while_continue___18: /* CIL Label */ ;
#line 836
    if ((unsigned long )match_pc >= (unsigned long )match_end) {
#line 836
      goto re_match_fail;
    }
#line 836
    if ((unsigned long )translation == (unsigned long )((void *)0)) {
#line 836
      tmp___78 = match_pc;
#line 836
      match_pc ++;
#line 836
      ascii___6 = (int )*tmp___78;
    } else {
#line 836
      tmp___79 = match_pc;
#line 836
      match_pc ++;
#line 836
      ascii___6 = (int )*(translation + *tmp___79);
    }
#line 836
    if ((unsigned long )match_pc == (unsigned long )gap_start) {
#line 836
      match_pc = gap_end;
    }
#line 836
    goto while_break___18;
  }
  while_break___18: /* CIL Label */ ;
  }
#line 837
  if ((unsigned int )((enum syntaxcode )(*((SCHEME_OBJECT *)(syntax_table & 288230376151711743UL) + ((ascii___6 & 255) + 1)) & 15UL)) == 2U) {
#line 838
    goto re_match_loop;
  }
#line 839
  goto re_match_fail;
  case_19: /* CIL Label */ 
  {
#line 846
  while (1) {
    while_continue___19: /* CIL Label */ ;
#line 846
    if ((unsigned long )match_pc >= (unsigned long )match_end) {
#line 846
      goto re_match_fail;
    }
#line 846
    if ((unsigned long )translation == (unsigned long )((void *)0)) {
#line 846
      tmp___80 = match_pc;
#line 846
      match_pc ++;
#line 846
      ascii___7 = (int )*tmp___80;
    } else {
#line 846
      tmp___81 = match_pc;
#line 846
      match_pc ++;
#line 846
      ascii___7 = (int )*(translation + *tmp___81);
    }
#line 846
    if ((unsigned long )match_pc == (unsigned long )gap_start) {
#line 846
      match_pc = gap_end;
    }
#line 846
    goto while_break___19;
  }
  while_break___19: /* CIL Label */ ;
  }
#line 847
  if (! ((unsigned int )((enum syntaxcode )(*((SCHEME_OBJECT *)(syntax_table & 288230376151711743UL) + ((ascii___7 & 255) + 1)) & 15UL)) == 2U)) {
#line 848
    goto re_match_loop;
  }
#line 849
  goto re_match_fail;
  case_6: /* CIL Label */ 
  {
#line 872
  while (1) {
    while_continue___20: /* CIL Label */ ;
#line 872
    if ((unsigned long )(pattern_pc + 1) >= (unsigned long )pattern_end) {
#line 872
      return_value = -2;
#line 872
      goto return_point;
    }
#line 872
    tmp___82 = pattern_pc;
#line 872
    pattern_pc ++;
#line 872
    offset = (long )*tmp___82;
#line 872
    tmp___83 = pattern_pc;
#line 872
    pattern_pc ++;
#line 872
    _fetched = *((signed char *)tmp___83);
#line 872
    offset += (long )((int )_fetched << 8);
#line 872
    if ((unsigned long )(pattern_pc + offset) < (unsigned long )pattern_start) {
#line 872
      return_value = -2;
#line 872
      goto return_point;
    } else
#line 872
    if ((unsigned long )(pattern_pc + offset) > (unsigned long )pattern_end) {
#line 872
      return_value = -2;
#line 872
      goto return_point;
    }
#line 872
    goto while_break___20;
  }
  while_break___20: /* CIL Label */ ;
  }
  {
#line 873
  while (1) {
    while_continue___21: /* CIL Label */ ;
#line 873
    if ((unsigned long )stack_pointer___0 == (unsigned long )stack_end___0) {
#line 873
      stack_length = (stack_end___0 - stack_start___0) * 2L;
#line 873
      if (stack_length > (long )(re_max_failures * 2)) {
#line 873
        return_value = -4;
#line 873
        goto return_point;
      }
      {
#line 873
      tmp___84 = realloc((void *)stack_start___0, (unsigned long )stack_length * sizeof(unsigned char *));
#line 873
      stack_temporary = (unsigned char **)tmp___84;
      }
#line 873
      if ((unsigned long )stack_temporary == (unsigned long )((void *)0)) {
#line 873
        return_value = -3;
#line 873
        goto return_point;
      }
#line 873
      stack_end___0 = stack_temporary + stack_length;
#line 873
      stack_pointer___0 = stack_temporary + (stack_pointer___0 - stack_start___0);
#line 873
      stack_start___0 = stack_temporary;
    }
#line 873
    tmp___85 = stack_pointer___0;
#line 873
    stack_pointer___0 ++;
#line 873
    *tmp___85 = pattern_pc + offset;
#line 873
    tmp___86 = stack_pointer___0;
#line 873
    stack_pointer___0 ++;
#line 873
    *tmp___86 = match_pc;
#line 873
    goto while_break___21;
  }
  while_break___21: /* CIL Label */ ;
  }
#line 874
  goto re_match_loop;
  case_8: /* CIL Label */ 
  {
#line 885
  while (1) {
    while_continue___22: /* CIL Label */ ;
#line 885
    if ((unsigned long )(pattern_pc + 1) >= (unsigned long )pattern_end) {
#line 885
      return_value = -2;
#line 885
      goto return_point;
    }
#line 885
    tmp___87 = pattern_pc;
#line 885
    pattern_pc ++;
#line 885
    offset___0 = (long )*tmp___87;
#line 885
    tmp___88 = pattern_pc;
#line 885
    pattern_pc ++;
#line 885
    _fetched___0 = *((signed char *)tmp___88);
#line 885
    offset___0 += (long )((int )_fetched___0 << 8);
#line 885
    if ((unsigned long )(pattern_pc + offset___0) < (unsigned long )pattern_start) {
#line 885
      return_value = -2;
#line 885
      goto return_point;
    } else
#line 885
    if ((unsigned long )(pattern_pc + offset___0) > (unsigned long )pattern_end) {
#line 885
      return_value = -2;
#line 885
      goto return_point;
    }
#line 885
    goto while_break___22;
  }
  while_break___22: /* CIL Label */ ;
  }
#line 886
  if ((unsigned long )pattern_pc == (unsigned long )pattern_end) {
#line 887
    goto finalize_jump;
  }
  {
#line 895
  if ((unsigned int )((enum regexpcode )*(pattern_pc + 0)) == 1U) {
#line 895
    goto case_1___0;
  }
#line 899
  if ((unsigned int )((enum regexpcode )*(pattern_pc + 0)) == 2U) {
#line 899
    goto case_2___0;
  }
#line 903
  if ((unsigned int )((enum regexpcode )*(pattern_pc + 0)) == 4U) {
#line 903
    goto case_4___0;
  }
#line 907
  goto switch_default;
  case_1___0: /* CIL Label */ 
#line 896
  ascii___8 = (long )*(pattern_pc + 1);
#line 897
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
#line 900
  ascii___8 = (long )*(pattern_pc + 2);
#line 901
  goto switch_break___0;
  case_4___0: /* CIL Label */ 
#line 904
  ascii___8 = (long )'\n';
#line 905
  goto switch_break___0;
  switch_default: /* CIL Label */ 
#line 908
  goto dont_finalize_jump;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 915
  if ((unsigned int )((enum regexpcode )*(pattern_pc + offset___0)) == 1U) {
#line 915
    goto case_1___1;
  }
#line 922
  if ((unsigned int )((enum regexpcode )*(pattern_pc + offset___0)) == 2U) {
#line 922
    goto case_2___1;
  }
#line 929
  if ((unsigned int )((enum regexpcode )*(pattern_pc + offset___0)) == 11U) {
#line 929
    goto case_11___0;
  }
#line 938
  if ((unsigned int )((enum regexpcode )*(pattern_pc + offset___0)) == 12U) {
#line 938
    goto case_12___0;
  }
#line 947
  goto switch_default___0;
  case_1___1: /* CIL Label */ 
#line 917
  if (ascii___8 != (long )*(pattern_pc + (offset___0 + 1L))) {
#line 918
    goto finalize_jump;
  }
#line 919
  goto dont_finalize_jump;
  case_2___1: /* CIL Label */ 
#line 924
  if (ascii___8 != (long )*(pattern_pc + (offset___0 + 2L))) {
#line 925
    goto finalize_jump;
  }
#line 926
  goto dont_finalize_jump;
  case_11___0: /* CIL Label */ 
#line 931
  if (ascii___8 < (long )((int )*(pattern_pc + (offset___0 + 1L)) * 8)) {
#line 931
    if (((int )*((pattern_pc + (offset___0 + 2L)) + ascii___8 / 8L) & (1 << ascii___8 % 8L)) != 0) {
#line 934
      goto dont_finalize_jump;
    }
  }
#line 935
  goto finalize_jump;
  case_12___0: /* CIL Label */ 
#line 940
  if (ascii___8 < (long )((int )*(pattern_pc + (offset___0 + 1L)) * 8)) {
#line 940
    if (((int )*((pattern_pc + (offset___0 + 2L)) + ascii___8 / 8L) & (1 << ascii___8 % 8L)) != 0) {
#line 943
      goto finalize_jump;
    }
  }
#line 944
  goto dont_finalize_jump;
  switch_default___0: /* CIL Label */ 
#line 948
  goto dont_finalize_jump;
  switch_break___1: /* CIL Label */ ;
  }
  finalize_jump: 
#line 952
  pattern_pc -= 2;
#line 953
  *(pattern_pc + -1) = (unsigned char)7;
#line 954
  goto re_match_finalize_jump;
  dont_finalize_jump: 
#line 957
  pattern_pc -= 2;
#line 958
  *(pattern_pc + -1) = (unsigned char)5;
#line 959
  goto re_match_jump;
  re_match_finalize_jump: 
  case_7: /* CIL Label */ 
#line 965
  stack_pointer___0 -= 2;
#line 966
  goto re_match_jump;
  re_match_jump: 
  case_5: /* CIL Label */ 
  {
#line 974
  while (1) {
    while_continue___23: /* CIL Label */ ;
#line 974
    if ((unsigned long )(pattern_pc + 1) >= (unsigned long )pattern_end) {
#line 974
      return_value = -2;
#line 974
      goto return_point;
    }
#line 974
    tmp___89 = pattern_pc;
#line 974
    pattern_pc ++;
#line 974
    offset___1 = (long )*tmp___89;
#line 974
    tmp___90 = pattern_pc;
#line 974
    pattern_pc ++;
#line 974
    _fetched___1 = *((signed char *)tmp___90);
#line 974
    offset___1 += (long )((int )_fetched___1 << 8);
#line 974
    if ((unsigned long )(pattern_pc + offset___1) < (unsigned long )pattern_start) {
#line 974
      return_value = -2;
#line 974
      goto return_point;
    } else
#line 974
    if ((unsigned long )(pattern_pc + offset___1) > (unsigned long )pattern_end) {
#line 974
      return_value = -2;
#line 974
      goto return_point;
    }
#line 974
    goto while_break___23;
  }
  while_break___23: /* CIL Label */ ;
  }
#line 975
  pattern_pc += offset___1;
#line 976
  goto re_match_loop;
  case_9: /* CIL Label */ 
  {
#line 981
  while (1) {
    while_continue___24: /* CIL Label */ ;
#line 981
    if ((unsigned long )stack_pointer___0 == (unsigned long )stack_end___0) {
#line 981
      stack_length___0 = (stack_end___0 - stack_start___0) * 2L;
#line 981
      if (stack_length___0 > (long )(re_max_failures * 2)) {
#line 981
        return_value = -4;
#line 981
        goto return_point;
      }
      {
#line 981
      tmp___91 = realloc((void *)stack_start___0, (unsigned long )stack_length___0 * sizeof(unsigned char *));
#line 981
      stack_temporary___0 = (unsigned char **)tmp___91;
      }
#line 981
      if ((unsigned long )stack_temporary___0 == (unsigned long )((void *)0)) {
#line 981
        return_value = -3;
#line 981
        goto return_point;
      }
#line 981
      stack_end___0 = stack_temporary___0 + stack_length___0;
#line 981
      stack_pointer___0 = stack_temporary___0 + (stack_pointer___0 - stack_start___0);
#line 981
      stack_start___0 = stack_temporary___0;
    }
#line 981
    tmp___92 = stack_pointer___0;
#line 981
    stack_pointer___0 ++;
#line 981
    *tmp___92 = (unsigned char *)((void *)0);
#line 981
    tmp___93 = stack_pointer___0;
#line 981
    stack_pointer___0 ++;
#line 981
    *tmp___93 = (unsigned char *)((void *)0);
#line 981
    goto while_break___24;
  }
  while_break___24: /* CIL Label */ ;
  }
#line 982
  goto re_match_jump;
  switch_default___1: /* CIL Label */ 
#line 987
  return_value = -2;
#line 987
  goto return_point;
  switch_break: /* CIL Label */ ;
  }
  re_match_fail: 
#line 992
  if ((unsigned long )stack_pointer___0 == (unsigned long )stack_start___0) {
#line 993
    return_value = -1;
#line 993
    goto return_point;
  }
#line 994
  stack_pointer___0 --;
#line 994
  match_pc = *stack_pointer___0;
#line 995
  stack_pointer___0 --;
#line 995
  pattern_pc = *stack_pointer___0;
#line 996
  if ((unsigned long )pattern_pc != (unsigned long )((void *)0)) {
#line 997
    goto re_match_loop;
  }
#line 998
  goto re_match_fail;
  return_point: 
#line 1001
  if ((unsigned long )stack_start___0 != (unsigned long )((void *)0)) {
    {
#line 1002
    free((void *)stack_start___0);
    }
  }
#line 1003
  return (return_value);
}
}
#line 1061 "/home/khheo/project/mit-scheme-9.2/src/microcode/regex.c"
int re_search_forward(unsigned char *pattern_start , unsigned char *pattern_end ,
                      struct re_buffer *buffer___2 , struct re_registers *registers ,
                      unsigned char *match_start , unsigned char *match_end ) 
{ 
  int can_be_null ;
  unsigned char *translation ;
  int match_result ;
  unsigned char *match_pc ;
  unsigned char *match_limit ;
  unsigned char *gap_start ;
  unsigned char *fastmap ;
  unsigned char fastmap_array[1UL << 8] ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  int tmp___1 ;
  unsigned char *tmp___2 ;
  unsigned char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  void *__cil_tmp23 ;

  {
  {
#line 1063
  fastmap = & fastmap_array[0];
#line 1063
  translation = buffer___2->translation;
#line 1063
  can_be_null = re_compile_fastmap(pattern_start, pattern_end, translation, buffer___2->syntax_table,
                                   fastmap);
  }
#line 1063
  if (can_be_null < 0) {
#line 1063
    return (can_be_null);
  }
#line 1063
  match_pc = match_start;
#line 1063
  match_limit = match_end;
#line 1063
  gap_start = buffer___2->gap_start;
#line 1065
  if (can_be_null != 1) {
#line 1067
    if ((unsigned long )match_pc < (unsigned long )gap_start) {
#line 1067
      if ((unsigned long )gap_start < (unsigned long )match_limit) {
        {
#line 1068
        while (1) {
          while_continue: /* CIL Label */ ;
          {
#line 1068
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 1068
            if ((unsigned long )match_pc >= (unsigned long )gap_start) {
#line 1068
              goto while_break___0;
            }
#line 1068
            if ((unsigned long )translation == (unsigned long )((void *)0)) {
#line 1068
              tmp = match_pc;
#line 1068
              match_pc ++;
#line 1068
              tmp___1 = (int )*tmp;
            } else {
#line 1068
              tmp___0 = match_pc;
#line 1068
              match_pc ++;
#line 1068
              tmp___1 = (int )*(translation + *tmp___0);
            }
#line 1068
            if ((int )*(fastmap + tmp___1) == 0) {
#line 1068
              goto while_continue___0;
            }
            {
#line 1068
            match_result = re_match(pattern_start, pattern_end, buffer___2, registers,
                                    match_pc - 1, match_end);
            }
#line 1068
            if (match_result == -1) {
#line 1068
              goto while_continue___0;
            } else
#line 1068
            if (match_result == -4) {
#line 1068
              goto while_continue___0;
            }
#line 1068
            return (match_result);
          }
          while_break___0: /* CIL Label */ ;
          }
#line 1068
          goto while_break;
        }
        while_break: /* CIL Label */ ;
        }
      }
    }
#line 1069
    if ((unsigned long )match_pc == (unsigned long )gap_start) {
#line 1070
      match_pc = buffer___2->gap_end;
    }
    {
#line 1071
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1071
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1071
        if ((unsigned long )match_pc >= (unsigned long )match_limit) {
#line 1071
          goto while_break___2;
        }
#line 1071
        if ((unsigned long )translation == (unsigned long )((void *)0)) {
#line 1071
          tmp___2 = match_pc;
#line 1071
          match_pc ++;
#line 1071
          tmp___4 = (int )*tmp___2;
        } else {
#line 1071
          tmp___3 = match_pc;
#line 1071
          match_pc ++;
#line 1071
          tmp___4 = (int )*(translation + *tmp___3);
        }
#line 1071
        if ((int )*(fastmap + tmp___4) == 0) {
#line 1071
          goto while_continue___2;
        }
        {
#line 1071
        match_result = re_match(pattern_start, pattern_end, buffer___2, registers,
                                match_pc - 1, match_end);
        }
#line 1071
        if (match_result == -1) {
#line 1071
          goto while_continue___2;
        } else
#line 1071
        if (match_result == -4) {
#line 1071
          goto while_continue___2;
        }
#line 1071
        return (match_result);
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1071
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1072
    if (can_be_null == 0) {
#line 1072
      tmp___6 = -1;
    } else {
      {
#line 1072
      tmp___5 = re_match(pattern_start, pattern_end, buffer___2, registers, match_limit,
                         match_end);
#line 1072
      tmp___6 = tmp___5;
      }
    }
#line 1072
    return (tmp___6);
  } else {
    {
#line 1079
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 1081
      match_result = re_match(pattern_start, pattern_end, buffer___2, registers, match_pc,
                              match_end);
      }
#line 1082
      if (! (match_result == -1)) {
#line 1082
        if (! (match_result == -4)) {
#line 1083
          return (match_result);
        }
      }
#line 1084
      match_pc ++;
#line 1085
      if ((unsigned long )match_pc == (unsigned long )gap_start) {
#line 1086
        match_pc = buffer___2->gap_end;
      }
#line 1087
      if ((unsigned long )match_pc > (unsigned long )match_limit) {
#line 1088
        return (match_result);
      }
    }
    while_break___3: /* CIL Label */ ;
    }
  }
}
}
#line 1120 "/home/khheo/project/mit-scheme-9.2/src/microcode/regex.c"
int re_search_backward(unsigned char *pattern_start , unsigned char *pattern_end ,
                       struct re_buffer *buffer___2 , struct re_registers *registers ,
                       unsigned char *match_start , unsigned char *match_end ) 
{ 
  int can_be_null ;
  unsigned char *translation ;
  int match_result ;
  unsigned char *match_pc ;
  unsigned char *match_limit ;
  unsigned char *gap_end ;
  unsigned char *fastmap ;
  unsigned char fastmap_array[1UL << 8] ;
  int tmp ;
  unsigned char *tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  unsigned char *tmp___3 ;
  long tmp___4 ;
  unsigned char *tmp___5 ;
  long tmp___6 ;
  unsigned char *tmp___7 ;
  long tmp___8 ;
  unsigned char *tmp___9 ;
  long tmp___10 ;
  void *__cil_tmp27 ;

  {
  {
#line 1122
  fastmap = & fastmap_array[0];
#line 1122
  translation = buffer___2->translation;
#line 1122
  can_be_null = re_compile_fastmap(pattern_start, pattern_end, translation, buffer___2->syntax_table,
                                   fastmap);
  }
#line 1122
  if (can_be_null < 0) {
#line 1122
    return (can_be_null);
  }
#line 1122
  match_pc = match_end;
#line 1122
  match_limit = match_start;
#line 1122
  gap_end = buffer___2->gap_end;
#line 1124
  if (can_be_null != 1) {
#line 1126
    if ((unsigned long )match_pc > (unsigned long )gap_end) {
#line 1126
      if ((unsigned long )gap_end > (unsigned long )match_limit) {
        {
#line 1127
        while (1) {
          while_continue: /* CIL Label */ ;
          {
#line 1127
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 1127
            if ((unsigned long )match_pc <= (unsigned long )gap_end) {
#line 1127
              goto while_break___0;
            }
#line 1127
            if ((unsigned long )translation == (unsigned long )((void *)0)) {
#line 1127
              match_pc --;
#line 1127
              tmp = (int )*match_pc;
            } else {
#line 1127
              match_pc --;
#line 1127
              tmp = (int )*(translation + *match_pc);
            }
#line 1127
            if ((int )*(fastmap + tmp) == 0) {
#line 1127
              goto while_continue___0;
            }
            {
#line 1127
            match_result = re_match(pattern_start, pattern_end, buffer___2, registers,
                                    match_pc, match_end);
            }
#line 1127
            if (match_result == -1) {
#line 1127
              goto while_continue___0;
            } else
#line 1127
            if (match_result == -4) {
#line 1127
              goto while_continue___0;
            }
#line 1127
            if (match_result < 0) {
#line 1127
              tmp___1 = (long )match_result;
            } else {
#line 1127
              if ((unsigned long )match_pc > (unsigned long )buffer___2->gap_start) {
#line 1127
                tmp___0 = match_pc - (gap_end - buffer___2->gap_start);
              } else {
#line 1127
                tmp___0 = match_pc;
              }
#line 1127
              tmp___1 = tmp___0 - buffer___2->text;
            }
#line 1127
            return ((int )tmp___1);
          }
          while_break___0: /* CIL Label */ ;
          }
#line 1127
          goto while_break;
        }
        while_break: /* CIL Label */ ;
        }
      }
    }
#line 1128
    if ((unsigned long )match_pc == (unsigned long )gap_end) {
#line 1129
      match_pc = buffer___2->gap_start;
    }
    {
#line 1130
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1130
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1130
        if ((unsigned long )match_pc <= (unsigned long )match_limit) {
#line 1130
          goto while_break___2;
        }
#line 1130
        if ((unsigned long )translation == (unsigned long )((void *)0)) {
#line 1130
          match_pc --;
#line 1130
          tmp___2 = (int )*match_pc;
        } else {
#line 1130
          match_pc --;
#line 1130
          tmp___2 = (int )*(translation + *match_pc);
        }
#line 1130
        if ((int )*(fastmap + tmp___2) == 0) {
#line 1130
          goto while_continue___2;
        }
        {
#line 1130
        match_result = re_match(pattern_start, pattern_end, buffer___2, registers,
                                match_pc, match_end);
        }
#line 1130
        if (match_result == -1) {
#line 1130
          goto while_continue___2;
        } else
#line 1130
        if (match_result == -4) {
#line 1130
          goto while_continue___2;
        }
#line 1130
        if (match_result < 0) {
#line 1130
          tmp___4 = (long )match_result;
        } else {
#line 1130
          if ((unsigned long )match_pc > (unsigned long )buffer___2->gap_start) {
#line 1130
            tmp___3 = match_pc - (gap_end - buffer___2->gap_start);
          } else {
#line 1130
            tmp___3 = match_pc;
          }
#line 1130
          tmp___4 = tmp___3 - buffer___2->text;
        }
#line 1130
        return ((int )tmp___4);
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1130
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1131
    if (can_be_null == 0) {
#line 1132
      return (-1);
    }
    {
#line 1133
    match_result = re_match(pattern_start, pattern_end, buffer___2, registers, match_limit,
                            match_end);
    }
#line 1134
    if (match_result < 0) {
#line 1134
      tmp___6 = (long )match_result;
    } else {
#line 1134
      if ((unsigned long )match_limit > (unsigned long )buffer___2->gap_start) {
#line 1134
        tmp___5 = match_limit - (gap_end - buffer___2->gap_start);
      } else {
#line 1134
        tmp___5 = match_limit;
      }
#line 1134
      tmp___6 = tmp___5 - buffer___2->text;
    }
#line 1134
    return ((int )tmp___6);
  } else {
    {
#line 1138
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 1140
      match_result = re_match(pattern_start, pattern_end, buffer___2, registers, match_pc,
                              match_end);
      }
#line 1141
      if (! (match_result == -1)) {
#line 1141
        if (! (match_result == -4)) {
#line 1142
          if (match_result < 0) {
#line 1142
            tmp___8 = (long )match_result;
          } else {
#line 1142
            if ((unsigned long )match_pc > (unsigned long )buffer___2->gap_start) {
#line 1142
              tmp___7 = match_pc - (gap_end - buffer___2->gap_start);
            } else {
#line 1142
              tmp___7 = match_pc;
            }
#line 1142
            tmp___8 = tmp___7 - buffer___2->text;
          }
#line 1142
          return ((int )tmp___8);
        }
      }
#line 1143
      if ((unsigned long )match_pc == (unsigned long )gap_end) {
#line 1144
        match_pc = buffer___2->gap_start;
      }
#line 1145
      match_pc --;
#line 1146
      if ((unsigned long )match_pc < (unsigned long )match_limit) {
#line 1147
        if (match_result < 0) {
#line 1147
          tmp___10 = (long )match_result;
        } else {
#line 1147
          if ((unsigned long )match_pc > (unsigned long )buffer___2->gap_start) {
#line 1147
            tmp___9 = match_pc - (gap_end - buffer___2->gap_start);
          } else {
#line 1147
            tmp___9 = match_pc;
          }
#line 1147
          tmp___10 = tmp___9 - buffer___2->text;
        }
#line 1147
        return ((int )tmp___10);
      }
    }
    while_break___3: /* CIL Label */ ;
    }
  }
}
}
#line 71 "/home/khheo/project/mit-scheme-9.2/src/microcode/gc.h"
SCHEME_OBJECT *get_object_address(SCHEME_OBJECT object ) ;
#line 320 "/home/khheo/project/mit-scheme-9.2/src/microcode/extern.h"
_Bool object_in_constant_space_p(SCHEME_OBJECT object ) ;
#line 32 "/home/khheo/project/mit-scheme-9.2/src/microcode/purutl.c"
SCHEME_OBJECT Prim_impurify(void) 
{ 


  {
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
#line 36
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 37
  return (*(stack_pointer + 0));
}
}
#line 40 "/home/khheo/project/mit-scheme-9.2/src/microcode/purutl.c"
SCHEME_OBJECT Prim_constant_p(void) 
{ 
  unsigned long tmp___0 ;
  _Bool tmp___1 ;

  {
  {
#line 44
  while (1) {
    while_continue: /* CIL Label */ ;
#line 44
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 45
  tmp___1 = object_in_constant_space_p(*(stack_pointer + 0));
  }
#line 45
  if (tmp___1) {
#line 45
    tmp___0 = 8UL << 58U;
  } else {
#line 45
    tmp___0 = 0UL;
  }
#line 45
  return (tmp___0);
}
}
#line 49 "/home/khheo/project/mit-scheme-9.2/src/microcode/purutl.c"
SCHEME_OBJECT Prim_pure_p(void) 
{ 


  {
  {
#line 53
  while (1) {
    while_continue: /* CIL Label */ ;
#line 53
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 54
  return (0UL);
}
}
#line 57 "/home/khheo/project/mit-scheme-9.2/src/microcode/purutl.c"
_Bool object_in_constant_space_p(SCHEME_OBJECT object ) 
{ 
  SCHEME_OBJECT *address___0 ;
  SCHEME_OBJECT *tmp ;
  int tmp___0 ;

  {
  {
#line 60
  tmp = get_object_address(object);
#line 60
  address___0 = tmp;
  }
#line 61
  if ((unsigned long )address___0 != (unsigned long )((SCHEME_OBJECT *)0)) {
#line 61
    if ((unsigned long )address___0 >= (unsigned long )constant_start) {
#line 61
      if ((unsigned long )address___0 < (unsigned long )constant_end) {
#line 61
        tmp___0 = 1;
      } else {
#line 61
        tmp___0 = 0;
      }
    } else {
#line 61
      tmp___0 = 0;
    }
  } else {
#line 61
    tmp___0 = 0;
  }
#line 61
  return ((_Bool )tmp___0);
}
}
#line 64 "/home/khheo/project/mit-scheme-9.2/src/microcode/purutl.c"
SCHEME_OBJECT *copy_to_constant_space(SCHEME_OBJECT *source , unsigned long n_words ) 
{ 
  SCHEME_OBJECT *result ;
  SCHEME_OBJECT *limit ;
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT *tmp___0 ;
  char *__cil_tmp7 ;

  {
#line 70
  if (n_words > (unsigned long )(constant_end - constant_alloc_next)) {
    {
#line 72
    outf_fatal("\nInsufficient constant space!\n");
#line 73
    Microcode_Termination(21);
    }
  }
#line 75
  result = constant_alloc_next;
#line 76
  limit = constant_alloc_next + n_words;
  {
#line 77
  while (1) {
    while_continue: /* CIL Label */ ;
#line 77
    if (! ((unsigned long )constant_alloc_next < (unsigned long )limit)) {
#line 77
      goto while_break;
    }
#line 78
    tmp = constant_alloc_next;
#line 78
    constant_alloc_next ++;
#line 78
    tmp___0 = source;
#line 78
    source ++;
#line 78
    *tmp = *tmp___0;
  }
  while_break: /* CIL Label */ ;
  }
#line 79
  return (result);
}
}
#line 90 "/home/khheo/project/mit-scheme-9.2/src/microcode/memmag.h"
void std_gc_pt1(void) ;
#line 91
void std_gc_pt2(void) ;
#line 151 "/home/khheo/project/mit-scheme-9.2/src/microcode/gccode.h"
gc_table_t *current_gc_table ;
#line 193
void resize_tospace(unsigned long n_words ) ;
#line 194
void open_tospace(SCHEME_OBJECT *start ) ;
#line 196
void add_to_tospace(SCHEME_OBJECT object ) ;
#line 199
void increment_tospace_ptr(unsigned long n_words ) ;
#line 200
SCHEME_OBJECT *get_newspace_ptr(void) ;
#line 206
void initialize_weak_chain(void) ;
#line 209
gc_table_t *std_gc_table(void) ;
#line 211
void gc_scan_tospace(SCHEME_OBJECT *scan , SCHEME_OBJECT *end ) ;
#line 33 "/home/khheo/project/mit-scheme-9.2/src/microcode/purify.c"
static void purify(SCHEME_OBJECT object ) ;
#line 41 "/home/khheo/project/mit-scheme-9.2/src/microcode/purify.c"
SCHEME_OBJECT Prim_primitive_purify(void) 
{ 
  SCHEME_OBJECT object ;
  unsigned long safety_margin ;
  SCHEME_OBJECT daemon ;
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;
  long tmp___3 ;
  unsigned long tmp___4 ;
  long tmp___5 ;
  SCHEME_OBJECT *tmp___6 ;
  SCHEME_OBJECT *tmp___7 ;
  SCHEME_OBJECT *tmp___8 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
  {
#line 49
  while (1) {
    while_continue: /* CIL Label */ ;
#line 49
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 51
  canonicalize_primitive_context();
  }
  {
#line 52
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 52
    if (*stack_start != ((34UL << 58U) | (SCHEME_OBJECT )stack_start)) {
      {
#line 52
      stack_death("PURIFY");
      }
    }
#line 52
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 54
  object = *(stack_pointer + 0);
#line 55
  safety_margin = arg_ulong_index_integer(3, (unsigned long )((heap_end - heap_start) / 2L));
#line 56
  stack_pointer += 3;
#line 58
  critical_section_name = "purify";
#line 59
  heap_reserved = safety_margin;
#line 60
  purify(object);
  }
  {
#line 62
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 62
    if (! ((unsigned long )(stack_pointer + -2) >= (unsigned long )stack_guard)) {
      {
#line 62
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 62
        if (*stack_start != ((34UL << 58U) | (SCHEME_OBJECT )stack_start)) {
          {
#line 62
          stack_death("STACK_CHECK");
          }
        }
#line 62
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 62
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 62
        set_ulong_register(12U, Registers[12] | 1UL);
        }
        {
#line 62
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 62
          if ((Registers[1] & Registers[12]) != 0UL) {
#line 62
            tmp___0 = memory_block_start;
          } else {
#line 62
            if ((Registers[1] & 4UL) != 0UL) {
#line 62
              tmp = heap_alloc_limit;
            } else {
#line 62
              tmp = heap_end;
            }
#line 62
            tmp___0 = tmp;
          }
          {
#line 62
          set_ptr_register(0U, tmp___0);
          }
#line 62
          if ((Registers[1] & 1UL) != 0UL) {
#line 62
            tmp___1 = stack_guard;
          } else {
#line 62
            tmp___1 = stack_start;
          }
          {
#line 62
          set_ptr_register(11U, tmp___1);
          }
#line 62
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 62
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 62
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 63
  Registers[6] = (11UL << 58U) | 32UL;
#line 64
  if ((unsigned long )Free >= (unsigned long )heap_start) {
#line 64
    if ((unsigned long )Free < (unsigned long )heap_alloc_limit) {
#line 64
      tmp___5 = heap_alloc_limit - Free;
    } else {
#line 64
      tmp___5 = 0L;
    }
  } else {
#line 64
    tmp___5 = 0L;
  }
#line 64
  if ((unsigned long )tmp___5 > gc_space_needed) {
#line 64
    if ((unsigned long )Free >= (unsigned long )heap_start) {
#line 64
      if ((unsigned long )Free < (unsigned long )heap_alloc_limit) {
#line 64
        tmp___3 = heap_alloc_limit - Free;
      } else {
#line 64
        tmp___3 = 0L;
      }
    } else {
#line 64
      tmp___3 = 0L;
    }
#line 64
    tmp___4 = (unsigned long )tmp___3 - gc_space_needed;
  } else {
#line 64
    tmp___4 = 0UL;
  }
  {
#line 64
  Registers[5] = cons(8UL << 58U, (26UL << 58U) | tmp___4);
  }
  {
#line 69
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 69
    stack_pointer --;
#line 69
    *stack_pointer = Registers[5];
#line 69
    stack_pointer --;
#line 69
    *stack_pointer = Registers[6];
#line 69
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 72
  critical_section_name = "purify daemon";
#line 73
  daemon = *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 12);
#line 74
  if (daemon != 0UL) {
    {
#line 76
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 76
      if (! ((unsigned long )(stack_pointer + -2) >= (unsigned long )stack_guard)) {
        {
#line 76
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 76
          if (*stack_start != ((34UL << 58U) | (SCHEME_OBJECT )stack_start)) {
            {
#line 76
            stack_death("STACK_CHECK");
            }
          }
#line 76
          goto while_break___7;
        }
        while_break___7: /* CIL Label */ ;
        }
        {
#line 76
        while (1) {
          while_continue___8: /* CIL Label */ ;
          {
#line 76
          set_ulong_register(12U, Registers[12] | 1UL);
          }
          {
#line 76
          while (1) {
            while_continue___9: /* CIL Label */ ;
#line 76
            if ((Registers[1] & Registers[12]) != 0UL) {
#line 76
              tmp___7 = memory_block_start;
            } else {
#line 76
              if ((Registers[1] & 4UL) != 0UL) {
#line 76
                tmp___6 = heap_alloc_limit;
              } else {
#line 76
                tmp___6 = heap_end;
              }
#line 76
              tmp___7 = tmp___6;
            }
            {
#line 76
            set_ptr_register(0U, tmp___7);
            }
#line 76
            if ((Registers[1] & 1UL) != 0UL) {
#line 76
              tmp___8 = stack_guard;
            } else {
#line 76
              tmp___8 = stack_start;
            }
            {
#line 76
            set_ptr_register(11U, tmp___8);
            }
#line 76
            goto while_break___9;
          }
          while_break___9: /* CIL Label */ ;
          }
#line 76
          goto while_break___8;
        }
        while_break___8: /* CIL Label */ ;
        }
      }
#line 76
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
    {
#line 77
    stack_pointer --;
#line 77
    *stack_pointer = daemon;
#line 78
    stack_pointer --;
#line 78
    *stack_pointer = 1UL;
#line 80
    abort_to_interpreter(-3);
    }
  }
  {
#line 82
  abort_to_interpreter(-7);
  }
#line 84
  return ((8UL << 58U) | 1UL);
}
}
#line 87 "/home/khheo/project/mit-scheme-9.2/src/microcode/purify.c"
static void purify(SCHEME_OBJECT object ) 
{ 
  SCHEME_OBJECT *start_copy ;
  SCHEME_OBJECT *new_constant_alloc_next ;
  SCHEME_OBJECT *heap_copy_start ;
  char *__cil_tmp5 ;

  {
  {
#line 94
  while (1) {
    while_continue: /* CIL Label */ ;
#line 94
    if (*stack_start != ((34UL << 58U) | (SCHEME_OBJECT )stack_start)) {
      {
#line 94
      stack_death("PURIFY");
      }
    }
#line 94
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 96
  open_tospace(constant_alloc_next);
#line 97
  initialize_weak_chain();
#line 99
  start_copy = get_newspace_ptr();
#line 100
  add_to_tospace(object);
#line 102
  current_gc_table = std_gc_table();
#line 103
  gc_scan_tospace(start_copy, (SCHEME_OBJECT *)0);
#line 105
  new_constant_alloc_next = get_newspace_ptr();
#line 106
  increment_tospace_ptr(128UL);
#line 107
  heap_copy_start = get_newspace_ptr();
#line 109
  std_gc_pt1();
#line 111
  constant_alloc_next = new_constant_alloc_next;
#line 112
  constant_end = heap_copy_start;
#line 113
  heap_start = constant_end;
#line 115
  std_gc_pt2();
#line 117
  resize_tospace((unsigned long )(heap_end - heap_start));
  }
#line 118
  return;
}
}
#line 95 "/home/khheo/project/mit-scheme-9.2/src/microcode/dstack.h"
Tptrvec ptrvec_allocate(Tptrvec_length length ) ;
#line 96
void ptrvec_deallocate(Tptrvec ptrvec ) ;
#line 97
void ptrvec_set_length(Tptrvec ptrvec , Tptrvec_length length ) ;
#line 98
Tptrvec ptrvec_copy(Tptrvec ptrvec ) ;
#line 99
void ptrvec_adjoin(Tptrvec ptrvec , void *element ) ;
#line 100
int ptrvec_memq(Tptrvec ptrvec , void *element ) ;
#line 101
void ptrvec_move_left(Tptrvec source , Tptrvec_index source_start , Tptrvec_index source_end ,
                      Tptrvec target , Tptrvec_index target_start ) ;
#line 104
void ptrvec_move_right(Tptrvec source , Tptrvec_index source_start , Tptrvec_index source_end ,
                       Tptrvec target , Tptrvec_index target_start ) ;
#line 32 "/home/khheo/project/mit-scheme-9.2/src/microcode/ptrvec.c"
Tptrvec ptrvec_allocate(Tptrvec_length length ) 
{ 
  Tptrvec ptrvec ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 35
  tmp = OS_malloc(sizeof(struct struct_ptrvec ));
#line 35
  ptrvec = (Tptrvec )tmp;
#line 36
  ptrvec->length = length;
  }
#line 37
  if (length > 0UL) {
    {
#line 37
    tmp___0 = OS_malloc(length * sizeof(void *));
#line 37
    ptrvec->elements = (void **)tmp___0;
    }
  } else {
#line 37
    ptrvec->elements = (void **)0;
  }
#line 39
  return (ptrvec);
}
}
#line 42 "/home/khheo/project/mit-scheme-9.2/src/microcode/ptrvec.c"
void ptrvec_deallocate(Tptrvec ptrvec ) 
{ 


  {
#line 45
  if (ptrvec->length > 0UL) {
    {
#line 46
    OS_free((void *)ptrvec->elements);
    }
  }
  {
#line 47
  OS_free((void *)ptrvec);
  }
#line 48
  return;
}
}
#line 50 "/home/khheo/project/mit-scheme-9.2/src/microcode/ptrvec.c"
void ptrvec_set_length(Tptrvec ptrvec , Tptrvec_length length ) 
{ 
  void *tmp ;

  {
#line 54
  ptrvec->length = length;
#line 55
  if (length > 0UL) {
    {
#line 55
    tmp = OS_realloc((void *)ptrvec->elements, length * sizeof(void *));
#line 55
    ptrvec->elements = (void **)tmp;
    }
  } else {
#line 55
    ptrvec->elements = (void **)0;
  }
#line 59
  return;
}
}
#line 61 "/home/khheo/project/mit-scheme-9.2/src/microcode/ptrvec.c"
Tptrvec ptrvec_copy(Tptrvec ptrvec ) 
{ 
  Tptrvec_length length ;
  Tptrvec result ;
  Tptrvec tmp ;
  void **scan_source ;
  void **end_source ;
  void **scan_result ;
  void **tmp___0 ;
  void **tmp___1 ;

  {
  {
#line 64
  length = ptrvec->length;
#line 65
  tmp = ptrvec_allocate(length);
#line 65
  result = tmp;
#line 66
  scan_source = ptrvec->elements + 0;
#line 67
  end_source = scan_source + length;
#line 68
  scan_result = result->elements + 0;
  }
  {
#line 69
  while (1) {
    while_continue: /* CIL Label */ ;
#line 69
    if (! ((unsigned long )scan_source < (unsigned long )end_source)) {
#line 69
      goto while_break;
    }
#line 70
    tmp___0 = scan_result;
#line 70
    scan_result ++;
#line 70
    tmp___1 = scan_source;
#line 70
    scan_source ++;
#line 70
    *tmp___0 = *tmp___1;
  }
  while_break: /* CIL Label */ ;
  }
#line 71
  return (result);
}
}
#line 74 "/home/khheo/project/mit-scheme-9.2/src/microcode/ptrvec.c"
void ptrvec_adjoin(Tptrvec ptrvec , void *element ) 
{ 
  Tptrvec_length length ;

  {
  {
#line 77
  length = ptrvec->length;
#line 78
  ptrvec_set_length(ptrvec, length + 1UL);
#line 79
  *(ptrvec->elements + length) = element;
  }
#line 80
  return;
}
}
#line 82 "/home/khheo/project/mit-scheme-9.2/src/microcode/ptrvec.c"
int ptrvec_memq(Tptrvec ptrvec , void *element ) 
{ 
  void **scan ;
  void **end ;
  void **tmp ;

  {
#line 85
  scan = ptrvec->elements + 0;
#line 86
  end = scan + ptrvec->length;
  {
#line 87
  while (1) {
    while_continue: /* CIL Label */ ;
#line 87
    if (! ((unsigned long )scan < (unsigned long )end)) {
#line 87
      goto while_break;
    }
#line 88
    tmp = scan;
#line 88
    scan ++;
#line 88
    if ((unsigned long )element == (unsigned long )*tmp) {
#line 89
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 90
  return (0);
}
}
#line 93 "/home/khheo/project/mit-scheme-9.2/src/microcode/ptrvec.c"
void ptrvec_move_left(Tptrvec source , Tptrvec_index source_start , Tptrvec_index source_end ,
                      Tptrvec target , Tptrvec_index target_start ) 
{ 
  void **scan_source ;
  void **end_source ;
  void **scan_target ;
  void **tmp ;
  void **tmp___0 ;

  {
#line 100
  scan_source = source->elements + source_start;
#line 101
  end_source = source->elements + source_end;
#line 102
  scan_target = target->elements + target_start;
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
#line 103
    if (! ((unsigned long )scan_source < (unsigned long )end_source)) {
#line 103
      goto while_break;
    }
#line 104
    tmp = scan_target;
#line 104
    scan_target ++;
#line 104
    tmp___0 = scan_source;
#line 104
    scan_source ++;
#line 104
    *tmp = *tmp___0;
  }
  while_break: /* CIL Label */ ;
  }
#line 105
  return;
}
}
#line 107 "/home/khheo/project/mit-scheme-9.2/src/microcode/ptrvec.c"
void ptrvec_move_right(Tptrvec source , Tptrvec_index source_start , Tptrvec_index source_end ,
                       Tptrvec target , Tptrvec_index target_start ) 
{ 
  void **end_source ;
  void **scan_source ;
  void **scan_target ;

  {
#line 114
  end_source = source->elements + source_start;
#line 115
  scan_source = source->elements + source_end;
#line 116
  scan_target = target->elements + (target_start + (source_end - source_start));
  {
#line 118
  while (1) {
    while_continue: /* CIL Label */ ;
#line 118
    if (! ((unsigned long )scan_source > (unsigned long )end_source)) {
#line 118
      goto while_break;
    }
#line 119
    scan_target --;
#line 119
    scan_source --;
#line 119
    *scan_target = *scan_source;
  }
  while_break: /* CIL Label */ ;
  }
#line 120
  return;
}
}
#line 311 "/home/khheo/project/mit-scheme-9.2/src/microcode/extern.h"
int strcmp_ci(char const   *s1 , char const   *s2 ) ;
#line 335
prim_renumber_t *make_prim_renumber(void) ;
#line 336
SCHEME_OBJECT renumber_primitive(SCHEME_OBJECT primitive , prim_renumber_t *pr ) ;
#line 337
unsigned long renumbered_primitives_export_length(prim_renumber_t *pr ) ;
#line 338
void export_renumbered_primitives(SCHEME_OBJECT *start , prim_renumber_t *pr ) ;
#line 339
unsigned long primitive_table_export_length(void) ;
#line 340
void export_primitive_table(SCHEME_OBJECT *start ) ;
#line 342
void import_primitive_table(SCHEME_OBJECT *entries , unsigned long n_entries , SCHEME_OBJECT *primitives ) ;
#line 345
void initialize_primitives(void) ;
#line 348
SCHEME_OBJECT find_primitive(SCHEME_OBJECT sname , _Bool intern_p , _Bool allow_p ,
                             int arity ) ;
#line 39 "/home/khheo/project/mit-scheme-9.2/src/microcode/prim.h"
int *Primitive_Count_Table ;
#line 41
char const   **Primitive_Documentation_Table ;
#line 42
unsigned long MAX_PRIMITIVE ;
#line 44
SCHEME_OBJECT declare_primitive(char const   *name , SCHEME_OBJECT (*code)(void) ,
                                int nargs_lo , int nargs_hi , char const   *docstr ) ;
#line 47
SCHEME_OBJECT install_primitive(char const   *name , SCHEME_OBJECT (*code)(void) ,
                                int nargs_lo , int nargs_hi , char const   *docstr ) ;
#line 38 "/home/khheo/project/mit-scheme-9.2/src/microcode/prename.h"
static struct primitive_alias_s primitive_aliases[17]  = 
#line 38 "/home/khheo/project/mit-scheme-9.2/src/microcode/prename.h"
  {      {"FALSE?", "NOT"}, 
        {"PRIMITIVE-TYPE", "OBJECT-TYPE"}, 
        {"PRIMITIVE-TYPE?", "OBJECT-TYPE?"}, 
        {"&MAKE-OBJECT", "PRIMITIVE-OBJECT-SET-TYPE"}, 
        {"SYSTEM-MEMORY-REF", "PRIMITIVE-OBJECT-REF"}, 
        {"PRIMITIVE-OBJECT-NEW-TYPE", "PRIMITIVE-OBJECT-SET-TYPE"}, 
        {"FILE-CLOSE-CHANNEL", "CHANNEL-CLOSE"}, 
        {"GET-NEXT-INTERRUPT-CHARACTER", "TTY-NEXT-INTERRUPT-CHAR"}, 
        {"REMOVE-FILE", "FILE-REMOVE"}, 
        {"RENAME-FILE", "FILE-RENAME"}, 
        {"COPY-FILE", "FILE-COPY"}, 
        {"MAKE-DIRECTORY", "DIRECTORY-MAKE"}, 
        {"SCREEN-X-SIZE", "TTY-X-SIZE"}, 
        {"SCREEN-Y-SIZE", "TTY-Y-SIZE"}, 
        {"FILE-SYMLINK?", "FILE-SOFT-LINK?"}, 
        {"X-GRAPHICS-SET-CLASS-HINT", "X-WINDOW-SET-CLASS-HINT"}, 
        {"CURRENT-FILE-TIME", "ENCODED-TIME"}};
#line 37 "/home/khheo/project/mit-scheme-9.2/src/microcode/avltree.h"
char const   *tree_error_message ;
#line 38
char const   *tree_error_noise ;
#line 51
tree_node tree_build(unsigned long high , char const   **names , unsigned long value ) ;
#line 52
tree_node tree_lookup(tree_node tree , char const   *name ) ;
#line 53
tree_node tree_insert(tree_node tree , char const   *name , unsigned long value ) ;
#line 54 "/home/khheo/project/mit-scheme-9.2/src/microcode/primutl.c"
static prim_renumber_t *make_prim_renumber_1(unsigned long n_entries ) ;
#line 55
static void free_prim_renumber(void *vpr ) ;
#line 56
static SCHEME_OBJECT *make_table_entry(unsigned long code , SCHEME_OBJECT *start ) ;
#line 57
static unsigned long table_entry_length(unsigned long code ) ;
#line 62 "/home/khheo/project/mit-scheme-9.2/src/microcode/primutl.c"
unsigned long MAX_PRIMITIVE  =    0UL;
#line 64 "/home/khheo/project/mit-scheme-9.2/src/microcode/primutl.c"
primitive_procedure_t *Primitive_Procedure_Table  =    (primitive_procedure_t *)0;
#line 66 "/home/khheo/project/mit-scheme-9.2/src/microcode/primutl.c"
int *Primitive_Arity_Table  =    (int *)0;
#line 68 "/home/khheo/project/mit-scheme-9.2/src/microcode/primutl.c"
int *Primitive_Count_Table  =    (int *)0;
#line 70 "/home/khheo/project/mit-scheme-9.2/src/microcode/primutl.c"
char const   **Primitive_Name_Table  =    (char const   **)0;
#line 72 "/home/khheo/project/mit-scheme-9.2/src/microcode/primutl.c"
char const   **Primitive_Documentation_Table  =    (char const   **)0;
#line 74 "/home/khheo/project/mit-scheme-9.2/src/microcode/primutl.c"
SCHEME_OBJECT *load_renumber_table  =    (SCHEME_OBJECT *)0;
#line 78 "/home/khheo/project/mit-scheme-9.2/src/microcode/primutl.c"
int strcmp_ci(char const   *s1 , char const   *s2 ) 
{ 
  unsigned char const   *p1 ;
  unsigned char const   *p2 ;
  int c1 ;
  unsigned char const   *tmp ;
  int c2 ;
  unsigned char const   *tmp___0 ;
  int tmp___1 ;

  {
#line 81
  p1 = (unsigned char const   *)((unsigned char *)s1);
#line 82
  p2 = (unsigned char const   *)((unsigned char *)s2);
  {
#line 83
  while (1) {
    while_continue: /* CIL Label */ ;
#line 85
    tmp = p1;
#line 85
    p1 ++;
#line 85
    c1 = (int )*tmp;
#line 86
    tmp___0 = p2;
#line 86
    p2 ++;
#line 86
    c2 = (int )*tmp___0;
#line 87
    if (c1 == 0) {
#line 88
      if (c2 == 0) {
#line 88
        tmp___1 = 0;
      } else {
#line 88
        tmp___1 = -1;
      }
#line 88
      return (tmp___1);
    }
#line 89
    if (c2 == 0) {
#line 90
      return (1);
    }
    {
#line 91
    c1 = toupper(c1);
#line 92
    c2 = toupper(c2);
    }
#line 93
    if (c1 < c2) {
#line 94
      return (-1);
    }
#line 95
    if (c1 > c2) {
#line 96
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 100 "/home/khheo/project/mit-scheme-9.2/src/microcode/primutl.c"
SCHEME_OBJECT Prim_unimplemented(void) 
{ 


  {
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
#line 103
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 105
  signal_error_from_primitive(51L);
  }
#line 107
  return ((8UL << 58U) | 1UL);
}
}
#line 110 "/home/khheo/project/mit-scheme-9.2/src/microcode/primutl.c"
static void initialization_error(char const   *reason , char const   *item ) 
{ 
  char *__cil_tmp3 ;

  {
  {
#line 113
  outf_fatal("initialize_primitives: Error %s %s.\n", reason, item);
#line 114
  termination_init_error();
  }
}
}
#line 117 "/home/khheo/project/mit-scheme-9.2/src/microcode/primutl.c"
static unsigned long prim_table_size  =    0UL;
#line 137 "/home/khheo/project/mit-scheme-9.2/src/microcode/primutl.c"
static void grow_primitive_tables(void) 
{ 
  unsigned long new_size ;
  int *from ;
  int *from_end ;
  int *to ;
  void *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  void *tmp___2 ;
  int *from___0 ;
  int *from_end___0 ;
  int *to___0 ;
  void *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  void *tmp___6 ;
  char const   **from___1 ;
  char const   **from_end___1 ;
  char **to___1 ;
  void *tmp___7 ;
  char **tmp___8 ;
  char const   **tmp___9 ;
  void *tmp___10 ;
  char const   **from___2 ;
  char const   **from_end___2 ;
  char **to___2 ;
  void *tmp___11 ;
  char **tmp___12 ;
  char const   **tmp___13 ;
  void *tmp___14 ;
  primitive_procedure_t *from___3 ;
  primitive_procedure_t *from_end___3 ;
  primitive_procedure_t *to___3 ;
  void *tmp___15 ;
  primitive_procedure_t *tmp___16 ;
  primitive_procedure_t *tmp___17 ;
  void *tmp___18 ;

  {
#line 140
  new_size = MAX_PRIMITIVE + MAX_PRIMITIVE / 10UL;
  {
#line 141
  while (1) {
    while_continue: /* CIL Label */ ;
#line 141
    if ((unsigned long )Primitive_Arity_Table == (unsigned long )((int *)0)) {
      {
#line 141
      from = & Static_Primitive_Arity_Table[0];
#line 141
      from_end = & Static_Primitive_Arity_Table[MAX_STATIC_PRIMITIVE + 1L];
#line 141
      tmp = OS_malloc(new_size * sizeof(int ));
#line 141
      Primitive_Arity_Table = (int *)tmp;
#line 141
      to = Primitive_Arity_Table;
      }
      {
#line 141
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 141
        if (! ((unsigned long )from < (unsigned long )from_end)) {
#line 141
          goto while_break___0;
        }
#line 141
        tmp___0 = to;
#line 141
        to ++;
#line 141
        tmp___1 = from;
#line 141
        from ++;
#line 141
        *tmp___0 = *tmp___1;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
      {
#line 141
      tmp___2 = OS_realloc((void *)Primitive_Arity_Table, new_size * sizeof(int ));
#line 141
      Primitive_Arity_Table = (int *)tmp___2;
      }
    }
#line 141
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 142
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 142
    if ((unsigned long )Primitive_Count_Table == (unsigned long )((int *)0)) {
      {
#line 142
      from___0 = & Static_Primitive_Count_Table[0];
#line 142
      from_end___0 = & Static_Primitive_Count_Table[MAX_STATIC_PRIMITIVE + 1L];
#line 142
      tmp___3 = OS_malloc(new_size * sizeof(int ));
#line 142
      Primitive_Count_Table = (int *)tmp___3;
#line 142
      to___0 = Primitive_Count_Table;
      }
      {
#line 142
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 142
        if (! ((unsigned long )from___0 < (unsigned long )from_end___0)) {
#line 142
          goto while_break___2;
        }
#line 142
        tmp___4 = to___0;
#line 142
        to___0 ++;
#line 142
        tmp___5 = from___0;
#line 142
        from___0 ++;
#line 142
        *tmp___4 = *tmp___5;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else {
      {
#line 142
      tmp___6 = OS_realloc((void *)Primitive_Count_Table, new_size * sizeof(int ));
#line 142
      Primitive_Count_Table = (int *)tmp___6;
      }
    }
#line 142
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 143
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 143
    if ((unsigned long )Primitive_Name_Table == (unsigned long )((char const   **)0)) {
      {
#line 143
      from___1 = & Static_Primitive_Name_Table[0];
#line 143
      from_end___1 = & Static_Primitive_Name_Table[MAX_STATIC_PRIMITIVE + 1L];
#line 143
      tmp___7 = OS_malloc(new_size * sizeof(char *));
#line 143
      Primitive_Name_Table = (char const   **)tmp___7;
#line 143
      to___1 = (char **)Primitive_Name_Table;
      }
      {
#line 143
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 143
        if (! ((unsigned long )from___1 < (unsigned long )from_end___1)) {
#line 143
          goto while_break___4;
        }
#line 143
        tmp___8 = to___1;
#line 143
        to___1 ++;
#line 143
        tmp___9 = from___1;
#line 143
        from___1 ++;
#line 143
        *tmp___8 = (char *)*tmp___9;
      }
      while_break___4: /* CIL Label */ ;
      }
    } else {
      {
#line 143
      tmp___10 = OS_realloc((void *)Primitive_Name_Table, new_size * sizeof(char *));
#line 143
      Primitive_Name_Table = (char const   **)tmp___10;
      }
    }
#line 143
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 147
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 147
    if ((unsigned long )Primitive_Documentation_Table == (unsigned long )((char const   **)0)) {
      {
#line 147
      from___2 = & Static_Primitive_Documentation_Table[0];
#line 147
      from_end___2 = & Static_Primitive_Documentation_Table[MAX_STATIC_PRIMITIVE + 1L];
#line 147
      tmp___11 = OS_malloc(new_size * sizeof(char *));
#line 147
      Primitive_Documentation_Table = (char const   **)tmp___11;
#line 147
      to___2 = (char **)Primitive_Documentation_Table;
      }
      {
#line 147
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 147
        if (! ((unsigned long )from___2 < (unsigned long )from_end___2)) {
#line 147
          goto while_break___6;
        }
#line 147
        tmp___12 = to___2;
#line 147
        to___2 ++;
#line 147
        tmp___13 = from___2;
#line 147
        from___2 ++;
#line 147
        *tmp___12 = (char *)*tmp___13;
      }
      while_break___6: /* CIL Label */ ;
      }
    } else {
      {
#line 147
      tmp___14 = OS_realloc((void *)Primitive_Documentation_Table, new_size * sizeof(char *));
#line 147
      Primitive_Documentation_Table = (char const   **)tmp___14;
      }
    }
#line 147
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 151
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 151
    if ((unsigned long )Primitive_Procedure_Table == (unsigned long )((primitive_procedure_t *)0)) {
      {
#line 151
      from___3 = & Static_Primitive_Procedure_Table[0];
#line 151
      from_end___3 = & Static_Primitive_Procedure_Table[MAX_STATIC_PRIMITIVE + 1L];
#line 151
      tmp___15 = OS_malloc(new_size * sizeof(SCHEME_OBJECT (*)(void)));
#line 151
      Primitive_Procedure_Table = (primitive_procedure_t *)tmp___15;
#line 151
      to___3 = Primitive_Procedure_Table;
      }
      {
#line 151
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 151
        if (! ((unsigned long )from___3 < (unsigned long )from_end___3)) {
#line 151
          goto while_break___8;
        }
#line 151
        tmp___16 = to___3;
#line 151
        to___3 ++;
#line 151
        tmp___17 = from___3;
#line 151
        from___3 ++;
#line 151
        *tmp___16 = *tmp___17;
      }
      while_break___8: /* CIL Label */ ;
      }
    } else {
      {
#line 151
      tmp___18 = OS_realloc((void *)Primitive_Procedure_Table, new_size * sizeof(SCHEME_OBJECT (*)(void)));
#line 151
      Primitive_Procedure_Table = (primitive_procedure_t *)tmp___18;
      }
    }
#line 151
    goto while_break___7;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 155
  prim_table_size = new_size;
  {
#line 156
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 156
    goto while_break___9;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 157
  return;
}
}
#line 159 "/home/khheo/project/mit-scheme-9.2/src/microcode/primutl.c"
static tree_node prim_procedure_tree  =    (tree_node )((void *)0);
#line 161 "/home/khheo/project/mit-scheme-9.2/src/microcode/primutl.c"
void initialize_primitives(void) 
{ 
  unsigned long counter ;
  unsigned long index___0 ;
  tree_node new ;
  tree_node orig ;
  tree_node tmp ;
  SCHEME_OBJECT old ;
  SCHEME_OBJECT tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 168
  MAX_PRIMITIVE = (unsigned long )(MAX_STATIC_PRIMITIVE + 1L);
#line 169
  grow_primitive_tables();
#line 171
  tree_error_message = (char const   *)((char *)((void *)0));
#line 172
  prim_procedure_tree = tree_build(MAX_PRIMITIVE, Primitive_Name_Table, 0UL);
  }
#line 173
  if ((unsigned long )tree_error_message != (unsigned long )((char *)((void *)0))) {
    {
#line 175
    outf_fatal(tree_error_message, tree_error_noise);
#line 176
    initialization_error("building", "prim_procedure_tree");
    }
  }
#line 179
  counter = 0UL;
  {
#line 179
  while (1) {
    while_continue: /* CIL Label */ ;
#line 179
    if (! (counter < sizeof(primitive_aliases) / sizeof(struct primitive_alias_s ))) {
#line 179
      goto while_break;
    }
    {
#line 183
    tmp = tree_lookup(prim_procedure_tree, primitive_aliases[counter].name);
#line 183
    orig = tmp;
    }
#line 186
    if ((unsigned long )orig != (unsigned long )((tree_node )((void *)0))) {
#line 187
      index___0 = orig->value;
    } else {
      {
#line 190
      tmp___0 = make_primitive(primitive_aliases[counter].name, -2);
#line 190
      old = tmp___0;
      }
#line 193
      if (old == 0UL) {
        {
#line 195
        outf_fatal("Error declaring unknown primitive %s.\n", primitive_aliases[counter].name);
#line 197
        initialization_error("aliasing", primitive_aliases[counter].alias);
        }
      }
#line 199
      index___0 = old & 288230376151711743UL;
    }
    {
#line 202
    new = tree_insert(prim_procedure_tree, primitive_aliases[counter].alias, index___0);
    }
#line 205
    if ((unsigned long )tree_error_message != (unsigned long )((char *)((void *)0))) {
      {
#line 207
      outf_fatal(tree_error_message, tree_error_noise);
#line 208
      initialization_error("aliasing", primitive_aliases[counter].alias);
      }
    }
#line 210
    prim_procedure_tree = new;
#line 179
    counter ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 212
  return;
}
}
#line 215 "/home/khheo/project/mit-scheme-9.2/src/microcode/primutl.c"
static SCHEME_OBJECT declare_primitive_internal(_Bool override_p , char const   *name ,
                                                SCHEME_OBJECT (*code)(void) , int nargs_lo ,
                                                int nargs_hi , char const   *docstr ) 
{ 
  unsigned long index___0 ;
  SCHEME_OBJECT primitive ;
  char const   *ndocstr ;
  tree_node prim ;
  tree_node tmp ;

  {
  {
#line 226
  ndocstr = docstr;
#line 227
  tmp = tree_lookup(prim_procedure_tree, name);
#line 227
  prim = tmp;
  }
#line 229
  if ((unsigned long )prim != (unsigned long )((tree_node )((void *)0))) {
#line 231
    index___0 = prim->value;
#line 232
    primitive = (24UL << 58U) | prim->value;
#line 233
    if (*(Primitive_Arity_Table + (primitive & 288230376151711743UL)) != nargs_hi) {
#line 233
      if (*(Primitive_Arity_Table + (primitive & 288230376151711743UL)) != -2) {
#line 236
        return ((26UL << 58U) | (primitive & 288230376151711743UL));
      } else {
#line 233
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 233
    if ((unsigned long )*(Primitive_Procedure_Table + (primitive & 288230376151711743UL)) != (unsigned long )(& Prim_unimplemented)) {
#line 233
      if (! override_p) {
#line 236
        return ((26UL << 58U) | (primitive & 288230376151711743UL));
      }
    }
#line 237
    if ((unsigned long )docstr == (unsigned long )((char const   *)0)) {
#line 238
      ndocstr = *(Primitive_Documentation_Table + index___0);
    }
  } else {
#line 242
    if (MAX_PRIMITIVE == prim_table_size) {
      {
#line 243
      grow_primitive_tables();
      }
    }
    {
#line 247
    index___0 = MAX_PRIMITIVE;
#line 248
    prim = tree_insert(prim_procedure_tree, name, index___0);
    }
#line 249
    if ((unsigned long )tree_error_message != (unsigned long )((char *)((void *)0))) {
      {
#line 251
      outf_error(tree_error_message, tree_error_noise);
#line 252
      tree_error_message = (char const   *)((char *)((void *)0));
      }
#line 253
      return (0UL);
    }
#line 255
    prim_procedure_tree = prim;
#line 257
    MAX_PRIMITIVE ++;
#line 258
    primitive = (24UL << 58U) | index___0;
#line 259
    *(Primitive_Name_Table + index___0) = name;
  }
#line 262
  *(Primitive_Procedure_Table + index___0) = code;
#line 263
  *(Primitive_Arity_Table + index___0) = nargs_hi;
#line 264
  *(Primitive_Count_Table + index___0) = (int )((unsigned long )nargs_hi * sizeof(SCHEME_OBJECT ));
#line 265
  *(Primitive_Documentation_Table + index___0) = ndocstr;
  {
#line 266
  while (1) {
    while_continue: /* CIL Label */ ;
#line 266
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 267
  return (primitive);
}
}
#line 281 "/home/khheo/project/mit-scheme-9.2/src/microcode/primutl.c"
SCHEME_OBJECT declare_primitive(char const   *name , SCHEME_OBJECT (*code)(void) ,
                                int nargs_lo , int nargs_hi , char const   *docstr ) 
{ 
  SCHEME_OBJECT tmp ;

  {
  {
#line 288
  tmp = declare_primitive_internal((_Bool)0, name, code, nargs_lo, nargs_hi, docstr);
  }
#line 288
  return (tmp);
}
}
#line 298 "/home/khheo/project/mit-scheme-9.2/src/microcode/primutl.c"
SCHEME_OBJECT install_primitive(char const   *name , SCHEME_OBJECT (*code)(void) ,
                                int nargs_lo , int nargs_hi , char const   *docstr ) 
{ 
  SCHEME_OBJECT tmp ;

  {
  {
#line 305
  tmp = declare_primitive_internal((_Bool)1, name, code, nargs_lo, nargs_hi, docstr);
  }
#line 305
  return (tmp);
}
}
#line 309 "/home/khheo/project/mit-scheme-9.2/src/microcode/primutl.c"
SCHEME_OBJECT make_primitive(char const   *name , int arity ) 
{ 
  tree_node prim ;
  char *cname ;
  SCHEME_OBJECT result ;
  size_t tmp ;
  void *tmp___0 ;
  unsigned long tmp___1 ;

  {
  {
#line 317
  prim = tree_lookup(prim_procedure_tree, name);
  }
#line 318
  if ((unsigned long )prim != (unsigned long )((tree_node )0)) {
#line 319
    cname = (char *)prim->name;
  } else {
    {
#line 322
    tmp = strlen(name);
#line 322
    tmp___0 = OS_malloc(tmp + 1UL);
#line 322
    cname = (char *)tmp___0;
#line 323
    strcpy((char */* __restrict  */)cname, (char const   */* __restrict  */)name);
    }
  }
  {
#line 325
  result = declare_primitive((char const   *)cname, & Prim_unimplemented, arity, arity,
                             (char const   *)0);
  }
#line 326
  if (result == 0UL) {
#line 326
    tmp___1 = 0UL;
  } else {
#line 326
    tmp___1 = (24UL << 58U) | (result & 288230376151711743UL);
  }
#line 326
  return (tmp___1);
}
}
#line 332 "/home/khheo/project/mit-scheme-9.2/src/microcode/primutl.c"
SCHEME_OBJECT find_primitive_cname(char const   *name , _Bool intern_p , _Bool allow_p ,
                                   int arity ) 
{ 
  tree_node prim ;
  tree_node tmp ;
  SCHEME_OBJECT primitive ;
  size_t n_bytes ;
  size_t tmp___0 ;
  char *cname ;
  void *tmp___1 ;
  SCHEME_OBJECT primitive___0 ;
  int tmp___2 ;
  SCHEME_OBJECT tmp___3 ;

  {
  {
#line 335
  tmp = tree_lookup(prim_procedure_tree, name);
#line 335
  prim = tmp;
  }
#line 336
  if ((unsigned long )prim != (unsigned long )((tree_node )0)) {
#line 338
    primitive = (24UL << 58U) | prim->value;
#line 340
    if (! allow_p) {
#line 340
      if (! ((unsigned long )*(Primitive_Procedure_Table + (primitive & 288230376151711743UL)) != (unsigned long )(& Prim_unimplemented))) {
#line 341
        return (0UL);
      }
    }
#line 343
    if (arity == -2) {
#line 345
      return (primitive);
    } else
#line 343
    if (arity == *(Primitive_Arity_Table + (primitive & 288230376151711743UL))) {
#line 345
      return (primitive);
    }
#line 347
    if (*(Primitive_Arity_Table + (primitive & 288230376151711743UL)) == -2) {
#line 350
      *(Primitive_Arity_Table + (primitive & 288230376151711743UL)) = arity;
#line 351
      return (primitive);
    }
#line 355
    return ((26UL << 58U) | ((unsigned long )*(Primitive_Arity_Table + (primitive & 288230376151711743UL)) & 288230376151711743UL));
  }
#line 358
  if (! intern_p) {
#line 359
    return (0UL);
  }
  {
#line 362
  tmp___0 = strlen(name);
#line 362
  n_bytes = tmp___0 + 1UL;
#line 363
  tmp___1 = OS_malloc(n_bytes);
#line 363
  cname = (char *)tmp___1;
#line 364
  memcpy((void */* __restrict  */)cname, (void const   */* __restrict  */)name, n_bytes);
  }
#line 366
  if (arity < 0) {
#line 366
    tmp___2 = 0;
  } else {
#line 366
    tmp___2 = arity;
  }
  {
#line 366
  tmp___3 = declare_primitive((char const   *)cname, & Prim_unimplemented, tmp___2,
                              arity, (char const   *)0);
#line 366
  primitive___0 = tmp___3;
  }
#line 372
  if (primitive___0 == 0UL) {
    {
#line 373
    error_in_system_call((enum syserr_names )33, (enum syscall_names )29);
    }
  }
#line 374
  return (primitive___0);
}
}
#line 379 "/home/khheo/project/mit-scheme-9.2/src/microcode/primutl.c"
SCHEME_OBJECT find_primitive(SCHEME_OBJECT sname , _Bool intern_p , _Bool allow_p ,
                             int arity ) 
{ 
  SCHEME_OBJECT tmp ;

  {
  {
#line 382
  tmp = find_primitive_cname((char const   *)((char *)((SCHEME_OBJECT *)(sname & 288230376151711743UL) + 2)),
                             intern_p, allow_p, arity);
  }
#line 382
  return (tmp);
}
}
#line 391 "/home/khheo/project/mit-scheme-9.2/src/microcode/primutl.c"
prim_renumber_t *make_prim_renumber(void) 
{ 
  prim_renumber_t *tmp ;

  {
  {
#line 394
  tmp = make_prim_renumber_1(MAX_PRIMITIVE);
  }
#line 394
  return (tmp);
}
}
#line 397 "/home/khheo/project/mit-scheme-9.2/src/microcode/primutl.c"
static prim_renumber_t *make_prim_renumber_1(unsigned long n_entries ) 
{ 
  prim_renumber_t *pr ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  unsigned long i ;

  {
  {
#line 400
  tmp = OS_malloc(sizeof(prim_renumber_t ));
#line 400
  pr = (prim_renumber_t *)tmp;
#line 401
  tmp___0 = OS_malloc(n_entries * sizeof(unsigned long ));
#line 401
  pr->internal = (unsigned long *)tmp___0;
#line 402
  tmp___1 = OS_malloc(n_entries * sizeof(unsigned long ));
#line 402
  pr->external = (unsigned long *)tmp___1;
#line 403
  pr->next_code = 0UL;
#line 406
  i = 0UL;
  }
  {
#line 406
  while (1) {
    while_continue: /* CIL Label */ ;
#line 406
    if (! (i < n_entries)) {
#line 406
      goto while_break;
    }
#line 408
    *(pr->internal + i) = 0xffffffffffffffffUL;
#line 409
    *(pr->external + i) = 0xffffffffffffffffUL;
#line 406
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 412
  transaction_record_action((enum transaction_action_type )2, & free_prim_renumber,
                            (void *)pr);
  }
#line 413
  return (pr);
}
}
#line 416 "/home/khheo/project/mit-scheme-9.2/src/microcode/primutl.c"
static void free_prim_renumber(void *vpr ) 
{ 
  prim_renumber_t *pr ;

  {
  {
#line 419
  pr = (prim_renumber_t *)vpr;
#line 420
  OS_free((void *)pr->internal);
#line 421
  OS_free((void *)pr->external);
#line 422
  OS_free((void *)pr);
  }
#line 423
  return;
}
}
#line 425 "/home/khheo/project/mit-scheme-9.2/src/microcode/primutl.c"
SCHEME_OBJECT renumber_primitive(SCHEME_OBJECT primitive , prim_renumber_t *pr ) 
{ 
  unsigned long old ;
  unsigned long new ;
  unsigned long tmp ;

  {
#line 428
  old = primitive & 288230376151711743UL;
#line 429
  new = *(pr->internal + old);
#line 430
  if (new == 0xffffffffffffffffUL) {
#line 432
    tmp = pr->next_code;
#line 432
    (pr->next_code) ++;
#line 432
    new = tmp;
#line 433
    *(pr->internal + old) = new;
#line 434
    *(pr->external + new) = old;
  }
#line 436
  return (((primitive >> 58U) << 58U) | new);
}
}
#line 439 "/home/khheo/project/mit-scheme-9.2/src/microcode/primutl.c"
unsigned long renumbered_primitives_export_length(prim_renumber_t *pr ) 
{ 
  unsigned long result ;
  unsigned long i ;
  unsigned long tmp ;

  {
#line 442
  result = 0UL;
#line 445
  i = 0UL;
  {
#line 445
  while (1) {
    while_continue: /* CIL Label */ ;
#line 445
    if (! (i < pr->next_code)) {
#line 445
      goto while_break;
    }
    {
#line 446
    tmp = table_entry_length(*(pr->external + i));
#line 446
    result += tmp;
#line 445
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 447
  return (result);
}
}
#line 450 "/home/khheo/project/mit-scheme-9.2/src/microcode/primutl.c"
void export_renumbered_primitives(SCHEME_OBJECT *start , prim_renumber_t *pr ) 
{ 
  unsigned long i ;

  {
#line 454
  i = 0UL;
  {
#line 454
  while (1) {
    while_continue: /* CIL Label */ ;
#line 454
    if (! (i < pr->next_code)) {
#line 454
      goto while_break;
    }
    {
#line 455
    start = make_table_entry(*(pr->external + i), start);
#line 454
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 456
  return;
}
}
#line 460 "/home/khheo/project/mit-scheme-9.2/src/microcode/primutl.c"
unsigned long primitive_table_export_length(void) 
{ 
  unsigned long result ;
  unsigned long i ;
  unsigned long tmp ;

  {
#line 463
  result = 0UL;
#line 466
  i = 0UL;
  {
#line 466
  while (1) {
    while_continue: /* CIL Label */ ;
#line 466
    if (! (i < MAX_PRIMITIVE)) {
#line 466
      goto while_break;
    }
    {
#line 467
    tmp = table_entry_length(i);
#line 467
    result += tmp;
#line 466
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 468
  return (result);
}
}
#line 471 "/home/khheo/project/mit-scheme-9.2/src/microcode/primutl.c"
void export_primitive_table(SCHEME_OBJECT *start ) 
{ 
  unsigned long i ;

  {
#line 475
  i = 0UL;
  {
#line 475
  while (1) {
    while_continue: /* CIL Label */ ;
#line 475
    if (! (i < MAX_PRIMITIVE)) {
#line 475
      goto while_break;
    }
    {
#line 476
    start = make_table_entry(i, start);
#line 475
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 477
  return;
}
}
#line 482 "/home/khheo/project/mit-scheme-9.2/src/microcode/primutl.c"
static char const   *null_string  =    "\000";
#line 479 "/home/khheo/project/mit-scheme-9.2/src/microcode/primutl.c"
static SCHEME_OBJECT *make_table_entry(unsigned long code , SCHEME_OBJECT *start ) 
{ 
  char const   *source ;
  char const   *tmp ;
  unsigned long n_chars ;
  size_t tmp___0 ;
  unsigned long n_words ;
  SCHEME_OBJECT *tmp___1 ;
  SCHEME_OBJECT *tmp___2 ;

  {
#line 483
  if ((unsigned long )*(Primitive_Name_Table + code) == (unsigned long )((char const   *)0)) {
#line 483
    tmp = null_string;
  } else {
#line 483
    tmp = *(Primitive_Name_Table + code);
  }
  {
#line 483
  source = tmp;
#line 487
  tmp___0 = strlen(source);
#line 487
  n_chars = tmp___0;
#line 488
  n_words = ((n_chars + 1UL) + (sizeof(SCHEME_OBJECT ) - 1UL)) / sizeof(SCHEME_OBJECT ) + 1UL;
#line 490
  tmp___1 = start;
#line 490
  start ++;
#line 490
  *tmp___1 = (26UL << 58U) | ((unsigned long )*(Primitive_Arity_Table + code) & 288230376151711743UL);
#line 491
  tmp___2 = start;
#line 491
  start ++;
#line 491
  *tmp___2 = (39UL << 58U) | n_words;
#line 492
  *start = n_chars;
#line 493
  memcpy((void */* __restrict  */)(start + 1), (void const   */* __restrict  */)source,
         n_chars + 1UL);
  }
#line 494
  return (start + n_words);
}
}
#line 497 "/home/khheo/project/mit-scheme-9.2/src/microcode/primutl.c"
static unsigned long table_entry_length(unsigned long code ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 500
  if ((unsigned long )*(Primitive_Name_Table + code) == (unsigned long )((char const   *)0)) {
#line 500
    tmp___0 = (size_t )0;
  } else {
    {
#line 500
    tmp = strlen(*(Primitive_Name_Table + code));
#line 500
    tmp___0 = tmp;
    }
  }
#line 500
  return ((((tmp___0 + 1UL) + (sizeof(SCHEME_OBJECT ) - 1UL)) / sizeof(SCHEME_OBJECT ) + 1UL) + 2UL);
}
}
#line 507 "/home/khheo/project/mit-scheme-9.2/src/microcode/primutl.c"
void import_primitive_table(SCHEME_OBJECT *entries , unsigned long n_entries , SCHEME_OBJECT *primitives ) 
{ 
  unsigned long i ;
  long arity ;
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT prim ;
  SCHEME_OBJECT tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;

  {
#line 513
  i = 0UL;
  {
#line 513
  while (1) {
    while_continue: /* CIL Label */ ;
#line 513
    if (! (i < n_entries)) {
#line 513
      goto while_break;
    }
    {
#line 515
    tmp = entries;
#line 515
    entries ++;
#line 515
    arity = (long )((*tmp ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL));
#line 516
    tmp___0 = find_primitive((30UL << 58U) | (SCHEME_OBJECT )entries, (_Bool)1, (_Bool)1,
                             (int )arity);
#line 516
    prim = tmp___0;
    }
#line 521
    if (! (prim >> 58U == 24UL)) {
      {
#line 522
      signal_error_from_primitive(54L);
      }
    }
#line 524
    tmp___1 = primitives;
#line 524
    primitives ++;
#line 524
    *tmp___1 = prim;
#line 525
    entries += 1UL + (*entries & 288230376151711743UL);
#line 513
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 527
  return;
}
}
#line 32 "/home/khheo/project/mit-scheme-9.2/src/microcode/prim.c"
static unsigned long arg_type(int arg ) 
{ 
  unsigned long tmp ;

  {
  {
#line 35
  tmp = arg_ulong_index_integer(arg, (unsigned long )(1L << 6U));
  }
#line 35
  return (tmp);
}
}
#line 38 "/home/khheo/project/mit-scheme-9.2/src/microcode/prim.c"
static unsigned long arg_datum(int arg ) 
{ 
  unsigned long tmp ;

  {
  {
#line 41
  tmp = arg_ulong_index_integer(arg, (unsigned long )(1L << 58U));
  }
#line 41
  return (tmp);
}
}
#line 46 "/home/khheo/project/mit-scheme-9.2/src/microcode/prim.c"
SCHEME_OBJECT Prim_prim_obj_type(void) 
{ 


  {
  {
#line 49
  while (1) {
    while_continue: /* CIL Label */ ;
#line 49
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 50
  return ((26UL << 58U) | (*(stack_pointer + 0) >> 58U));
}
}
#line 53 "/home/khheo/project/mit-scheme-9.2/src/microcode/prim.c"
SCHEME_OBJECT Prim_prim_obj_type_p(void) 
{ 
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;

  {
  {
#line 56
  while (1) {
    while_continue: /* CIL Label */ ;
#line 56
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 57
  tmp___1 = arg_type(1);
  }
#line 57
  if (*(stack_pointer + 1) >> 58U == tmp___1) {
#line 57
    tmp___0 = 8UL << 58U;
  } else {
#line 57
    tmp___0 = 0UL;
  }
#line 57
  return (tmp___0);
}
}
#line 61 "/home/khheo/project/mit-scheme-9.2/src/microcode/prim.c"
SCHEME_OBJECT Prim_prim_obj_datum(void) 
{ 
  SCHEME_OBJECT tmp ;

  {
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
#line 64
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 65
  tmp = ulong_to_integer(*(stack_pointer + 0) & 288230376151711743UL);
  }
#line 65
  return (tmp);
}
}
#line 68 "/home/khheo/project/mit-scheme-9.2/src/microcode/prim.c"
SCHEME_OBJECT Prim_prim_obj_address(void) 
{ 
  SCHEME_OBJECT tmp ;

  {
  {
#line 72
  while (1) {
    while_continue: /* CIL Label */ ;
#line 72
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 73
  tmp = ulong_to_integer((unsigned long )((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL)));
  }
#line 73
  return (tmp);
}
}
#line 77 "/home/khheo/project/mit-scheme-9.2/src/microcode/prim.c"
SCHEME_OBJECT Prim_prim_datum_to_addr(void) 
{ 
  unsigned long tmp ;
  SCHEME_OBJECT tmp___0 ;

  {
  {
#line 81
  while (1) {
    while_continue: /* CIL Label */ ;
#line 81
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 82
  tmp = arg_datum(1);
#line 82
  tmp___0 = ulong_to_integer((unsigned long )((SCHEME_OBJECT *)tmp));
  }
#line 82
  return (tmp___0);
}
}
#line 86 "/home/khheo/project/mit-scheme-9.2/src/microcode/prim.c"
SCHEME_OBJECT Prim_prim_addr_to_datum(void) 
{ 
  unsigned long tmp ;
  SCHEME_OBJECT tmp___0 ;

  {
  {
#line 90
  while (1) {
    while_continue: /* CIL Label */ ;
#line 90
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 91
  tmp = arg_ulong_integer(1);
#line 91
  tmp___0 = ulong_to_integer((SCHEME_OBJECT )((SCHEME_OBJECT *)tmp));
  }
#line 91
  return (tmp___0);
}
}
#line 96 "/home/khheo/project/mit-scheme-9.2/src/microcode/prim.c"
SCHEME_OBJECT Prim_make_non_ptr_object(void) 
{ 
  unsigned long tmp ;

  {
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;
#line 101
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 102
  tmp = arg_datum(1);
  }
#line 102
  return ((26UL << 58U) | tmp);
}
}
#line 105 "/home/khheo/project/mit-scheme-9.2/src/microcode/prim.c"
SCHEME_OBJECT Prim_prim_obj_set_type(void) 
{ 
  unsigned long tmp ;

  {
  {
#line 109
  while (1) {
    while_continue: /* CIL Label */ ;
#line 109
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 110
  tmp = arg_type(1);
  }
#line 110
  return ((tmp << 58U) | (*(stack_pointer + 1) & 288230376151711743UL));
}
}
#line 113 "/home/khheo/project/mit-scheme-9.2/src/microcode/prim.c"
SCHEME_OBJECT Prim_prim_obj_eq_p(void) 
{ 
  unsigned long tmp ;

  {
  {
#line 115
  while (1) {
    while_continue: /* CIL Label */ ;
#line 115
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 116
  if (*(stack_pointer + 0) == *(stack_pointer + 1)) {
#line 116
    tmp = 8UL << 58U;
  } else {
#line 116
    tmp = 0UL;
  }
#line 116
  return (tmp);
}
}
#line 119 "/home/khheo/project/mit-scheme-9.2/src/microcode/prim.c"
SCHEME_OBJECT Prim_prim_make_obj(void) 
{ 
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
  {
#line 123
  while (1) {
    while_continue: /* CIL Label */ ;
#line 123
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 124
  tmp = arg_type(1);
#line 124
  tmp___0 = arg_datum(2);
  }
#line 124
  return ((tmp << 58U) | tmp___0);
}
}
#line 127 "/home/khheo/project/mit-scheme-9.2/src/microcode/prim.c"
SCHEME_OBJECT Prim_prim_obj_to_integer(void) 
{ 
  SCHEME_OBJECT tmp ;

  {
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;
#line 131
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 132
  tmp = ulong_to_integer(*(stack_pointer + 0));
  }
#line 132
  return (tmp);
}
}
#line 135 "/home/khheo/project/mit-scheme-9.2/src/microcode/prim.c"
SCHEME_OBJECT Prim_prim_integer_to_obj(void) 
{ 
  unsigned long tmp ;

  {
  {
#line 139
  while (1) {
    while_continue: /* CIL Label */ ;
#line 139
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 140
  tmp = arg_ulong_integer(1);
  }
#line 140
  return (tmp);
}
}
#line 154 "/home/khheo/project/mit-scheme-9.2/src/microcode/prim.c"
SCHEME_OBJECT Prim_prim_obj_ref(void) 
{ 
  long tmp ;

  {
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
#line 156
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 157
  tmp = arg_nonnegative_integer(2);
  }
#line 157
  return (*((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + tmp));
}
}
#line 164 "/home/khheo/project/mit-scheme-9.2/src/microcode/prim.c"
SCHEME_OBJECT Prim_prim_obj_set(void) 
{ 
  long tmp ;

  {
  {
#line 166
  while (1) {
    while_continue: /* CIL Label */ ;
#line 166
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 167
  tmp = arg_nonnegative_integer(2);
#line 167
  *((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + tmp) = *(stack_pointer + 2);
  }
#line 168
  return ((8UL << 58U) | 1UL);
}
}
#line 173 "/home/khheo/project/mit-scheme-9.2/src/microcode/prim.c"
SCHEME_OBJECT Prim_object_type(void) 
{ 


  {
  {
#line 175
  while (1) {
    while_continue: /* CIL Label */ ;
#line 175
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 176
  return ((26UL << 58U) | (*(stack_pointer + 0) >> 58U));
}
}
#line 179 "/home/khheo/project/mit-scheme-9.2/src/microcode/prim.c"
SCHEME_OBJECT Prim_object_gc_type(void) 
{ 
  gc_type_t tmp ;

  {
  {
#line 181
  while (1) {
    while_continue: /* CIL Label */ ;
#line 181
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 182
  tmp = gc_type_code((unsigned int )(*(stack_pointer + 0) >> 58U));
  }
#line 182
  return ((26UL << 58U) | ((unsigned long )((int )tmp) & 288230376151711743UL));
}
}
#line 185 "/home/khheo/project/mit-scheme-9.2/src/microcode/prim.c"
SCHEME_OBJECT Prim_type_to_gc_type(void) 
{ 
  unsigned long tmp ;
  gc_type_t tmp___0 ;

  {
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 187
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 188
  tmp = arg_type(1);
#line 188
  tmp___0 = gc_type_code((unsigned int )tmp);
  }
#line 188
  return ((26UL << 58U) | ((unsigned long )((int )tmp___0) & 288230376151711743UL));
}
}
#line 192 "/home/khheo/project/mit-scheme-9.2/src/microcode/prim.c"
SCHEME_OBJECT Prim_object_type_p(void) 
{ 
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;

  {
  {
#line 194
  while (1) {
    while_continue: /* CIL Label */ ;
#line 194
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 195
  tmp___1 = arg_type(1);
  }
#line 195
  if (*(stack_pointer + 1) >> 58U == tmp___1) {
#line 195
    tmp___0 = 8UL << 58U;
  } else {
#line 195
    tmp___0 = 0UL;
  }
#line 195
  return (tmp___0);
}
}
#line 199 "/home/khheo/project/mit-scheme-9.2/src/microcode/prim.c"
SCHEME_OBJECT Prim_object_datum(void) 
{ 
  SCHEME_OBJECT tmp ;

  {
  {
#line 201
  while (1) {
    while_continue: /* CIL Label */ ;
#line 201
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 202
  tmp = long_to_integer((long )(*(stack_pointer + 0) & 288230376151711743UL));
  }
#line 202
  return (tmp);
}
}
#line 205 "/home/khheo/project/mit-scheme-9.2/src/microcode/prim.c"
SCHEME_OBJECT Prim_object_set_type(void) 
{ 
  unsigned long type_code ;
  unsigned long tmp ;
  SCHEME_OBJECT object ;
  gc_type_t gc_type ;
  gc_type_t tmp___0 ;
  gc_type_t tmp___1 ;

  {
  {
#line 207
  while (1) {
    while_continue: /* CIL Label */ ;
#line 207
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 209
  tmp = arg_type(1);
#line 209
  type_code = tmp;
#line 210
  object = *(stack_pointer + 1);
#line 211
  tmp___0 = gc_type_code((unsigned int )type_code);
#line 211
  gc_type = tmp___0;
  }
#line 212
  if ((int )gc_type == -1) {
    {
#line 215
    error_bad_range_arg(1);
    }
  } else
#line 212
  if ((int )gc_type != 0) {
    {
#line 212
    tmp___1 = gc_type_code((unsigned int )(object >> 58U));
    }
#line 212
    if ((int )gc_type != (int )tmp___1) {
      {
#line 215
      error_bad_range_arg(1);
      }
    }
  }
#line 216
  return ((type_code << 58U) | (object & 288230376151711743UL));
}
}
#line 225 "/home/khheo/project/mit-scheme-9.2/src/microcode/prim.c"
SCHEME_OBJECT Prim_eq(void) 
{ 
  unsigned long tmp ;

  {
  {
#line 227
  while (1) {
    while_continue: /* CIL Label */ ;
#line 227
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 228
  if (*(stack_pointer + 0) == *(stack_pointer + 1)) {
#line 228
    tmp = 8UL << 58U;
  } else {
#line 228
    tmp = 0UL;
  }
#line 228
  return (tmp);
}
}
#line 236 "/home/khheo/project/mit-scheme-9.2/src/microcode/prim.c"
SCHEME_OBJECT Prim_not(void) 
{ 
  unsigned long tmp ;

  {
  {
#line 238
  while (1) {
    while_continue: /* CIL Label */ ;
#line 238
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 239
  if (*(stack_pointer + 0) == 0UL) {
#line 239
    tmp = 8UL << 58U;
  } else {
#line 239
    tmp = 0UL;
  }
#line 239
  return (tmp);
}
}
#line 246 "/home/khheo/project/mit-scheme-9.2/src/microcode/prim.c"
SCHEME_OBJECT Prim_null_p(void) 
{ 
  unsigned long tmp ;

  {
  {
#line 248
  while (1) {
    while_continue: /* CIL Label */ ;
#line 248
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 249
  if (*(stack_pointer + 0) == ((8UL << 58U) | 9UL)) {
#line 249
    tmp = 8UL << 58U;
  } else {
#line 249
    tmp = 0UL;
  }
#line 249
  return (tmp);
}
}
#line 257 "/home/khheo/project/mit-scheme-9.2/src/microcode/prim.c"
SCHEME_OBJECT Prim_make_cell(void) 
{ 
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;
  SCHEME_OBJECT *tmp___2 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 259
  while (1) {
    while_continue: /* CIL Label */ ;
#line 259
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 260
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 260
    if ((unsigned long )Free >= (unsigned long )heap_start) {
#line 260
      if ((unsigned long )Free < (unsigned long )heap_alloc_limit) {
#line 260
        if (! ((unsigned long )(Free + 1) <= (unsigned long )heap_alloc_limit)) {
#line 260
          goto _L___0;
        }
      } else {
#line 260
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 260
    if ((Registers[1] & 4UL) != 0UL) {
      {
#line 260
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 260
        if ((unsigned long )Free_primitive < (unsigned long )heap_start) {
          {
#line 260
          outf_fatal("\nMicrocode requested primitive GC outside primitive!\n");
#line 260
          Microcode_Termination(12);
          }
        }
#line 260
        if ((unsigned long )Free < (unsigned long )Free_primitive) {
          {
#line 260
          outf_fatal("\nFree has gone backwards!\n");
#line 260
          Microcode_Termination(12);
          }
        }
        {
#line 260
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
#line 260
          while (1) {
            while_continue___3: /* CIL Label */ ;
            {
#line 260
            set_ulong_register(12U, Registers[12] | 4UL);
            }
            {
#line 260
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 260
              if ((Registers[1] & Registers[12]) != 0UL) {
#line 260
                tmp___0 = memory_block_start;
              } else {
#line 260
                if ((Registers[1] & 4UL) != 0UL) {
#line 260
                  tmp = heap_alloc_limit;
                } else {
#line 260
                  tmp = heap_end;
                }
#line 260
                tmp___0 = tmp;
              }
              {
#line 260
              set_ptr_register(0U, tmp___0);
              }
#line 260
              if ((Registers[1] & 1UL) != 0UL) {
#line 260
                tmp___1 = stack_guard;
              } else {
#line 260
                tmp___1 = stack_start;
              }
              {
#line 260
              set_ptr_register(11U, tmp___1);
              }
#line 260
              goto while_break___4;
            }
            while_break___4: /* CIL Label */ ;
            }
#line 260
            goto while_break___3;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 260
          gc_space_needed = (unsigned long )(1L + (Free - Free_primitive));
#line 260
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 260
        signal_interrupt_from_primitive();
        }
#line 260
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 260
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 261
  tmp___2 = Free;
#line 261
  Free ++;
#line 261
  *tmp___2 = *(stack_pointer + 0);
#line 262
  return ((54UL << 58U) | (SCHEME_OBJECT )(Free - 1));
}
}
#line 268 "/home/khheo/project/mit-scheme-9.2/src/microcode/prim.c"
SCHEME_OBJECT Prim_cell_p(void) 
{ 
  unsigned long tmp ;

  {
  {
#line 270
  while (1) {
    while_continue: /* CIL Label */ ;
#line 270
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 271
  if (*(stack_pointer + 0) >> 58U == 54UL) {
#line 271
    tmp = 8UL << 58U;
  } else {
#line 271
    tmp = 0UL;
  }
#line 271
  return (tmp);
}
}
#line 277 "/home/khheo/project/mit-scheme-9.2/src/microcode/prim.c"
SCHEME_OBJECT Prim_cell_contents(void) 
{ 
  SCHEME_OBJECT tmp ;

  {
  {
#line 279
  while (1) {
    while_continue: /* CIL Label */ ;
#line 279
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 280
  if (*(stack_pointer + 0) >> 58U == 54UL) {
#line 280
    tmp = *(stack_pointer + 0);
  } else {
    {
#line 280
    error_wrong_type_arg(1);
#line 280
    tmp = (SCHEME_OBJECT )0;
    }
  }
#line 280
  return (*((SCHEME_OBJECT *)(tmp & 288230376151711743UL) + 0));
}
}
#line 287 "/home/khheo/project/mit-scheme-9.2/src/microcode/prim.c"
SCHEME_OBJECT Prim_set_cell_contents(void) 
{ 
  SCHEME_OBJECT cell ;
  SCHEME_OBJECT object ;

  {
  {
#line 291
  while (1) {
    while_continue: /* CIL Label */ ;
#line 291
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 292
  if (*(stack_pointer + 0) >> 58U == 54UL) {
#line 292
    cell = *(stack_pointer + 0);
  } else {
    {
#line 292
    error_wrong_type_arg(1);
#line 292
    cell = (SCHEME_OBJECT )0;
    }
  }
#line 293
  object = *(stack_pointer + 1);
#line 294
  *((SCHEME_OBJECT *)(cell & 288230376151711743UL) + 0) = object;
#line 295
  return ((8UL << 58U) | 1UL);
}
}
#line 371 "/usr/include/stdio.h"
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 46 "/home/khheo/project/mit-scheme-9.2/src/microcode/outf.h"
void voutf(outf_channel chan , char const   *format , va_list ap ) ;
#line 47
void voutf_console(char const   *format , va_list args ) ;
#line 48
void voutf_error(char const   *format , va_list args ) ;
#line 49
void voutf_fatal(char const   *format , va_list args ) ;
#line 51
void outf_flush(outf_channel chan ) ;
#line 58 "/home/khheo/project/mit-scheme-9.2/src/microcode/outf.c"
void ( /* format attribute */  outf)(outf_channel chan , char const   *format  , ...) 
{ 
  va_list ap ;

  {
  {
#line 62
  __builtin_va_start(ap, format);
#line 63
  voutf(chan, format, ap);
#line 64
  __builtin_va_end(ap);
  }
#line 65
  return;
}
}
#line 67 "/home/khheo/project/mit-scheme-9.2/src/microcode/outf.c"
void voutf(outf_channel chan , char const   *format , va_list ap ) 
{ 


  {
  {
#line 72
  if ((unsigned int )chan == 0U) {
#line 72
    goto case_0;
  }
#line 73
  if ((unsigned int )chan == 1U) {
#line 73
    goto case_1;
  }
#line 74
  if ((unsigned int )chan == 2U) {
#line 74
    goto case_2;
  }
#line 70
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 72
  voutf_console(format, ap);
  }
#line 72
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 73
  voutf_error(format, ap);
  }
#line 73
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 74
  voutf_fatal(format, ap);
  }
#line 74
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 76
  return;
}
}
#line 78 "/home/khheo/project/mit-scheme-9.2/src/microcode/outf.c"
void outf_flush(outf_channel chan ) 
{ 


  {
  {
#line 83
  if ((unsigned int )chan == 0U) {
#line 83
    goto case_0;
  }
#line 84
  if ((unsigned int )chan == 1U) {
#line 84
    goto case_1;
  }
#line 85
  if ((unsigned int )chan == 2U) {
#line 85
    goto case_2;
  }
#line 81
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 83
  outf_flush_console();
  }
#line 83
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 84
  outf_flush_error();
  }
#line 84
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 85
  outf_flush_fatal();
  }
#line 85
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 87
  return;
}
}
#line 89 "/home/khheo/project/mit-scheme-9.2/src/microcode/outf.c"
void ( /* format attribute */  outf_console)(char const   *format  , ...) 
{ 
  va_list args ;

  {
  {
#line 93
  __builtin_va_start(args, format);
#line 94
  voutf_console(format, args);
#line 95
  __builtin_va_end(args);
  }
#line 96
  return;
}
}
#line 98 "/home/khheo/project/mit-scheme-9.2/src/microcode/outf.c"
void ( /* format attribute */  outf_error)(char const   *format  , ...) 
{ 
  va_list args ;

  {
  {
#line 102
  __builtin_va_start(args, format);
#line 103
  voutf_error(format, args);
#line 104
  __builtin_va_end(args);
  }
#line 105
  return;
}
}
#line 107 "/home/khheo/project/mit-scheme-9.2/src/microcode/outf.c"
void ( /* format attribute */  outf_fatal)(char const   *format  , ...) 
{ 
  va_list args ;

  {
  {
#line 111
  __builtin_va_start(args, format);
#line 112
  voutf_fatal(format, args);
#line 113
  __builtin_va_end(args);
  }
#line 114
  return;
}
}
#line 239 "/home/khheo/project/mit-scheme-9.2/src/microcode/outf.c"
void voutf_console(char const   *format , va_list args ) 
{ 


  {
  {
#line 242
  vfprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)format,
           args);
  }
#line 243
  return;
}
}
#line 245 "/home/khheo/project/mit-scheme-9.2/src/microcode/outf.c"
void outf_flush_console(void) 
{ 


  {
  {
#line 248
  fflush(stdout);
  }
#line 249
  return;
}
}
#line 251 "/home/khheo/project/mit-scheme-9.2/src/microcode/outf.c"
void voutf_error(char const   *format , va_list args ) 
{ 


  {
  {
#line 254
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)format,
           args);
  }
#line 255
  return;
}
}
#line 257 "/home/khheo/project/mit-scheme-9.2/src/microcode/outf.c"
void outf_flush_error(void) 
{ 


  {
  {
#line 260
  fflush(stderr);
  }
#line 261
  return;
}
}
#line 263 "/home/khheo/project/mit-scheme-9.2/src/microcode/outf.c"
void voutf_fatal(char const   *format , va_list args ) 
{ 


  {
  {
#line 266
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)format,
           args);
  }
#line 267
  return;
}
}
#line 269 "/home/khheo/project/mit-scheme-9.2/src/microcode/outf.c"
void outf_flush_fatal(void) 
{ 


  {
  {
#line 272
  fflush(stderr);
  }
#line 273
  return;
}
}
#line 53 "/home/khheo/project/mit-scheme-9.2/src/microcode/osscheme.h"
void request_character_interrupt(void) ;
#line 31 "/home/khheo/project/mit-scheme-9.2/src/microcode/ostty.c"
static cc_t next_interrupt_char  ;
#line 33 "/home/khheo/project/mit-scheme-9.2/src/microcode/ostty.c"
void tty_set_next_interrupt_char(cc_t c ) 
{ 


  {
#line 36
  if ((int )next_interrupt_char == 0) {
    {
#line 38
    next_interrupt_char = c;
#line 39
    request_character_interrupt();
    }
  }
#line 41
  return;
}
}
#line 43 "/home/khheo/project/mit-scheme-9.2/src/microcode/ostty.c"
cc_t OS_tty_next_interrupt_char(void) 
{ 
  cc_t result ;
  cc_t tmp ;

  {
#line 46
  if ((int )next_interrupt_char == 0) {
    {
#line 47
    error_external_return();
    }
  }
  {
#line 54
  tmp = OS_tty_map_interrupt_char(next_interrupt_char);
#line 54
  result = tmp;
#line 55
  next_interrupt_char = (cc_t )'\000';
  }
#line 56
  return (result);
}
}
#line 35 "/home/khheo/project/mit-scheme-9.2/src/microcode/osscheme.h"
int executing_scheme_primitive_p(void) ;
#line 44
 __attribute__((__noreturn__)) void error_floating_point_exception(void) ;
#line 58
unsigned long get_interrupt_mask(void) ;
#line 59
void set_interrupt_mask(unsigned long mask ) ;
#line 31 "/home/khheo/project/mit-scheme-9.2/src/microcode/osscheme.c"
 __attribute__((__noreturn__)) void error_out_of_channels(void) ;
#line 31 "/home/khheo/project/mit-scheme-9.2/src/microcode/osscheme.c"
void error_out_of_channels(void) 
{ 


  {
  {
#line 34
  signal_error_from_primitive(32L);
  }
}
}
#line 37
 __attribute__((__noreturn__)) void error_out_of_processes(void) ;
#line 37 "/home/khheo/project/mit-scheme-9.2/src/microcode/osscheme.c"
void error_out_of_processes(void) 
{ 


  {
  {
#line 40
  signal_error_from_primitive(32L);
  }
}
}
#line 43
 __attribute__((__noreturn__)) void error_unimplemented_primitive(void) ;
#line 43 "/home/khheo/project/mit-scheme-9.2/src/microcode/osscheme.c"
void error_unimplemented_primitive(void) 
{ 


  {
  {
#line 46
  signal_error_from_primitive(9L);
  }
}
}
#line 49
 __attribute__((__noreturn__)) void error_floating_point_exception(void) ;
#line 49 "/home/khheo/project/mit-scheme-9.2/src/microcode/osscheme.c"
void error_floating_point_exception(void) 
{ 


  {
  {
#line 52
  signal_error_from_primitive(50L);
  }
}
}
#line 55
 __attribute__((__noreturn__)) void error_process_terminated(void) ;
#line 55 "/home/khheo/project/mit-scheme-9.2/src/microcode/osscheme.c"
void error_process_terminated(void) 
{ 


  {
  {
#line 58
  signal_error_from_primitive(63L);
  }
}
}
#line 61 "/home/khheo/project/mit-scheme-9.2/src/microcode/osscheme.c"
int executing_scheme_primitive_p(void) 
{ 


  {
#line 64
  return (Registers[8] >> 58U == 24UL);
}
}
#line 88 "/home/khheo/project/mit-scheme-9.2/src/microcode/osscheme.c"
void request_console_resize_interrupt(void) 
{ 
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;

  {
  {
#line 91
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 91
    set_ulong_register(12U, Registers[12] | 128UL);
    }
    {
#line 91
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 91
      if ((Registers[1] & Registers[12]) != 0UL) {
#line 91
        tmp___0 = memory_block_start;
      } else {
#line 91
        if ((Registers[1] & 4UL) != 0UL) {
#line 91
          tmp = heap_alloc_limit;
        } else {
#line 91
          tmp = heap_end;
        }
#line 91
        tmp___0 = tmp;
      }
      {
#line 91
      set_ptr_register(0U, tmp___0);
      }
#line 91
      if ((Registers[1] & 1UL) != 0UL) {
#line 91
        tmp___1 = stack_guard;
      } else {
#line 91
        tmp___1 = stack_start;
      }
      {
#line 91
      set_ptr_register(11U, tmp___1);
      }
#line 91
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 91
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 92
  return;
}
}
#line 94 "/home/khheo/project/mit-scheme-9.2/src/microcode/osscheme.c"
void request_character_interrupt(void) 
{ 
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;

  {
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 97
    set_ulong_register(12U, Registers[12] | 16UL);
    }
    {
#line 97
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 97
      if ((Registers[1] & Registers[12]) != 0UL) {
#line 97
        tmp___0 = memory_block_start;
      } else {
#line 97
        if ((Registers[1] & 4UL) != 0UL) {
#line 97
          tmp = heap_alloc_limit;
        } else {
#line 97
          tmp = heap_end;
        }
#line 97
        tmp___0 = tmp;
      }
      {
#line 97
      set_ptr_register(0U, tmp___0);
      }
#line 97
      if ((Registers[1] & 1UL) != 0UL) {
#line 97
        tmp___1 = stack_guard;
      } else {
#line 97
        tmp___1 = stack_start;
      }
      {
#line 97
      set_ptr_register(11U, tmp___1);
      }
#line 97
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 97
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  return;
}
}
#line 100 "/home/khheo/project/mit-scheme-9.2/src/microcode/osscheme.c"
void request_timer_interrupt(void) 
{ 
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;

  {
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 103
    set_ulong_register(12U, Registers[12] | 64UL);
    }
    {
#line 103
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 103
      if ((Registers[1] & Registers[12]) != 0UL) {
#line 103
        tmp___0 = memory_block_start;
      } else {
#line 103
        if ((Registers[1] & 4UL) != 0UL) {
#line 103
          tmp = heap_alloc_limit;
        } else {
#line 103
          tmp = heap_end;
        }
#line 103
        tmp___0 = tmp;
      }
      {
#line 103
      set_ptr_register(0U, tmp___0);
      }
#line 103
      if ((Registers[1] & 1UL) != 0UL) {
#line 103
        tmp___1 = stack_guard;
      } else {
#line 103
        tmp___1 = stack_start;
      }
      {
#line 103
      set_ptr_register(11U, tmp___1);
      }
#line 103
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 103
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 104
  return;
}
}
#line 106 "/home/khheo/project/mit-scheme-9.2/src/microcode/osscheme.c"
void request_suspend_interrupt(void) 
{ 
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;

  {
  {
#line 109
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 109
    set_ulong_register(12U, Registers[12] | 256UL);
    }
    {
#line 109
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 109
      if ((Registers[1] & Registers[12]) != 0UL) {
#line 109
        tmp___0 = memory_block_start;
      } else {
#line 109
        if ((Registers[1] & 4UL) != 0UL) {
#line 109
          tmp = heap_alloc_limit;
        } else {
#line 109
          tmp = heap_end;
        }
#line 109
        tmp___0 = tmp;
      }
      {
#line 109
      set_ptr_register(0U, tmp___0);
      }
#line 109
      if ((Registers[1] & 1UL) != 0UL) {
#line 109
        tmp___1 = stack_guard;
      } else {
#line 109
        tmp___1 = stack_start;
      }
      {
#line 109
      set_ptr_register(11U, tmp___1);
      }
#line 109
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 109
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 110
  return;
}
}
#line 112 "/home/khheo/project/mit-scheme-9.2/src/microcode/osscheme.c"
int pending_interrupts_p(void) 
{ 


  {
#line 115
  return (((Registers[1] & Registers[12]) & ((1UL << 16UL) - 1UL)) != 0UL);
}
}
#line 118 "/home/khheo/project/mit-scheme-9.2/src/microcode/osscheme.c"
void deliver_pending_interrupts(void) 
{ 


  {
#line 121
  if (((Registers[1] & Registers[12]) & ((1UL << 16UL) - 1UL)) != 0UL) {
    {
#line 122
    signal_interrupt_from_primitive();
    }
  }
#line 123
  return;
}
}
#line 125 "/home/khheo/project/mit-scheme-9.2/src/microcode/osscheme.c"
unsigned long get_interrupt_mask(void) 
{ 


  {
#line 128
  return (Registers[1]);
}
}
#line 131 "/home/khheo/project/mit-scheme-9.2/src/microcode/osscheme.c"
void set_interrupt_mask(unsigned long mask ) 
{ 
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;

  {
  {
#line 134
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 134
    set_ulong_register(1U, mask & ((1UL << 16UL) - 1UL));
    }
    {
#line 134
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 134
      if ((Registers[1] & Registers[12]) != 0UL) {
#line 134
        tmp___0 = memory_block_start;
      } else {
#line 134
        if ((Registers[1] & 4UL) != 0UL) {
#line 134
          tmp = heap_alloc_limit;
        } else {
#line 134
          tmp = heap_end;
        }
#line 134
        tmp___0 = tmp;
      }
      {
#line 134
      set_ptr_register(0U, tmp___0);
      }
#line 134
      if ((Registers[1] & 1UL) != 0UL) {
#line 134
        tmp___1 = stack_guard;
      } else {
#line 134
        tmp___1 = stack_start;
      }
      {
#line 134
      set_ptr_register(11U, tmp___1);
      }
#line 134
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 134
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 135
  return;
}
}
#line 137 "/home/khheo/project/mit-scheme-9.2/src/microcode/osscheme.c"
void debug_back_trace(outf_channel stream ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
  {
#line 140
  outf(stream, "*** Scheme Microcode Back Trace: ***\n");
#line 141
  Back_Trace(stream);
#line 142
  outf(stream, "*** End of Back Trace ***\n");
#line 143
  outf_flush(stream);
  }
#line 144
  return;
}
}
#line 146 "/home/khheo/project/mit-scheme-9.2/src/microcode/osscheme.c"
void debug_examine_memory(long address___0 , char const   *label ) 
{ 


  {
  {
#line 149
  Print_Expression(*((SCHEME_OBJECT *)address___0), (char const   *)((char *)label));
  }
#line 150
  return;
}
}
#line 187 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 200 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasl.h"
_Bool open_fasl_input_file(char const   *filename , fasl_file_handle_t *handle_r ) ;
#line 201
_Bool close_fasl_input_file(fasl_file_handle_t handle ) ;
#line 202
_Bool read_fasl_header(fasl_header_t *h , fasl_file_handle_t handle ) ;
#line 210
fasl_read_status_t check_fasl_version(fasl_header_t *fh___1 ) ;
#line 211
fasl_read_status_t check_fasl_cc_version(fasl_header_t *fh___1 , unsigned long version ,
                                         unsigned long type ) ;
#line 87 "/home/khheo/project/mit-scheme-9.2/src/microcode/option.c"
static _Bool option_summary  ;
#line 89 "/home/khheo/project/mit-scheme-9.2/src/microcode/option.c"
static char const   *option_raw_library  ;
#line 90 "/home/khheo/project/mit-scheme-9.2/src/microcode/option.c"
static char const   *option_raw_band  ;
#line 91 "/home/khheo/project/mit-scheme-9.2/src/microcode/option.c"
static char const   *option_raw_heap  ;
#line 92 "/home/khheo/project/mit-scheme-9.2/src/microcode/option.c"
static char const   *option_raw_constant  ;
#line 93 "/home/khheo/project/mit-scheme-9.2/src/microcode/option.c"
static char const   *option_raw_stack  ;
#line 96 "/home/khheo/project/mit-scheme-9.2/src/microcode/option.c"
int option_saved_argc  ;
#line 97 "/home/khheo/project/mit-scheme-9.2/src/microcode/option.c"
char const   **option_saved_argv  ;
#line 98 "/home/khheo/project/mit-scheme-9.2/src/microcode/option.c"
int option_unused_argc  ;
#line 99 "/home/khheo/project/mit-scheme-9.2/src/microcode/option.c"
char const   **option_unused_argv  ;
#line 102 "/home/khheo/project/mit-scheme-9.2/src/microcode/option.c"
_Bool option_emacs_subprocess  ;
#line 103 "/home/khheo/project/mit-scheme-9.2/src/microcode/option.c"
_Bool option_force_interactive  ;
#line 104 "/home/khheo/project/mit-scheme-9.2/src/microcode/option.c"
_Bool option_disable_core_dump  ;
#line 105 "/home/khheo/project/mit-scheme-9.2/src/microcode/option.c"
_Bool option_batch_mode  ;
#line 106 "/home/khheo/project/mit-scheme-9.2/src/microcode/option.c"
_Bool option_show_version  ;
#line 107 "/home/khheo/project/mit-scheme-9.2/src/microcode/option.c"
_Bool option_show_help  ;
#line 113 "/home/khheo/project/mit-scheme-9.2/src/microcode/option.c"
char const   **option_library_path  =    (char const   **)0;
#line 114 "/home/khheo/project/mit-scheme-9.2/src/microcode/option.c"
char const   *option_band_file  =    (char const   *)0;
#line 115 "/home/khheo/project/mit-scheme-9.2/src/microcode/option.c"
char const   *option_fasl_file  =    (char const   *)0;
#line 118 "/home/khheo/project/mit-scheme-9.2/src/microcode/option.c"
unsigned long option_heap_size  ;
#line 119 "/home/khheo/project/mit-scheme-9.2/src/microcode/option.c"
unsigned long option_constant_size  ;
#line 120 "/home/khheo/project/mit-scheme-9.2/src/microcode/option.c"
unsigned long option_stack_size  ;
#line 122 "/home/khheo/project/mit-scheme-9.2/src/microcode/option.c"
void print_help(void) 
{ 
  char *__cil_tmp1 ;
  char *__cil_tmp2 ;

  {
  {
#line 125
  outf_fatal("Usage: mit-scheme --OPTION ARG ... --OPTION ARG ...\n\nThis machine accepts the following command-line options.  The options\nmay appear in any order, but they must all appear before any options\nfor the band.\n\n--library PATH\n  Sets the library search path to PATH.  This is a colon-separated\n  list of directories that is searched to find various library files,\n  such as bands.  If this option is not given, the value of the\n  environment variable MITSCHEME_LIBRARY_PATH is used; if that isn\'t\n  defined, \"/usr/local/lib/mit-scheme\" is used.\n\n--band FILENAME\n  Specifies the initial band to be loaded.  Searches for FILENAME in\n  the working directory and the library directories, returning the\n  full pathname of the first readable file of that name.  If this\n  option isn\'t given, the filename is the value of the environment\n  variable MITSCHEME_BAND, or if that isn\'t defined, \"runtime.com\"; in\n  these cases the library directories are searched, but not the\n  working directory.\n\n--fasl FILENAME\n  Specifies that a cold load should be performed, using FILENAME as\n  the initial file to be loaded.  If this option isn\'t given, a normal\n  load is performed instead.  This option may not be used together\n  with the \"--band\" option.\n\n--heap BLOCKS\n  Specifies the size of the heap in 1024-word blocks.  Overrides any\n  default.\n\n--constant BLOCKS\n  Specifies the size of constant space in 1024-word blocks.  Overrides\n  any default.\n\n--stack BLOCKS\n  Specifies the size of the stack in 1024-word blocks.  Overrides any\n  default.\n\n--option-summary\n  Causes Scheme to write option values to standard error.\n\n--help\n  Causes Scheme to report the available command line options.\n\n--version\n  Causes Scheme to report versions and copyrights, then exit.\n\n--batch-mode, --quiet, --silent\n  Suppresses the startup report of versions and copyrights, and the\n  valediction.\n\n--emacs\n  Specifies that Scheme is running as a subprocess of GNU Emacs.\n  This option is automatically supplied by GNU Emacs, and should not\n  be given under other circumstances.\n\n--interactive\n  If this option isn\'t specified, and Scheme\'s standard I/O is not a\n  terminal, Scheme will detach itself from its controlling terminal.\n  This will prevent it from getting signals sent to the process group\n  of that terminal.  If this option is specified, Scheme will not\n  detach itself from the controlling terminal.\n\n--nocore\n  Specifies that Scheme should not generate a core dump under any\n  circumstances.\n\nPlease report bugs to %s.\n\nAdditional options may be supported by the band (and described below).\n\n",
             "bug-mit-scheme@gnu.org");
  }
#line 208
  return;
}
}
#line 258 "/home/khheo/project/mit-scheme-9.2/src/microcode/option.c"
static int string_compare_ci(char const   *string1 , char const   *string2 ) 
{ 
  char const   *scan1 ;
  unsigned int length1 ;
  size_t tmp ;
  char const   *scan2 ;
  unsigned int length2 ;
  size_t tmp___0 ;
  unsigned int length ;
  unsigned int tmp___1 ;
  char const   *end1 ;
  char const   *end2 ;
  int c1 ;
  char const   *tmp___2 ;
  int c2 ;
  char const   *tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  unsigned short const   **tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 261
  scan1 = string1;
#line 262
  tmp = strlen(string1);
#line 262
  length1 = (unsigned int )tmp;
#line 263
  scan2 = string2;
#line 264
  tmp___0 = strlen(string2);
#line 264
  length2 = (unsigned int )tmp___0;
  }
#line 265
  if (length1 < length2) {
#line 265
    tmp___1 = length1;
  } else {
#line 265
    tmp___1 = length2;
  }
#line 265
  length = tmp___1;
#line 266
  end1 = scan1 + length;
#line 267
  end2 = scan2 + length;
  {
#line 268
  while (1) {
    while_continue: /* CIL Label */ ;
#line 268
    if ((unsigned long )scan1 < (unsigned long )end1) {
#line 268
      if (! ((unsigned long )scan2 < (unsigned long )end2)) {
#line 268
        goto while_break;
      }
    } else {
#line 268
      goto while_break;
    }
    {
#line 270
    tmp___2 = scan1;
#line 270
    scan1 ++;
#line 270
    c1 = (int )*tmp___2;
#line 271
    tmp___3 = scan2;
#line 271
    scan2 ++;
#line 271
    c2 = (int )*tmp___3;
#line 272
    tmp___6 = __ctype_b_loc();
    }
#line 272
    if ((int const   )*(*tmp___6 + c1) & 512) {
      {
#line 274
      tmp___4 = __ctype_b_loc();
      }
#line 274
      if (! ((int const   )*(*tmp___4 + c2) & 512)) {
        {
#line 275
        c1 = toupper(c1);
        }
      }
    } else {
      {
#line 279
      tmp___5 = __ctype_b_loc();
      }
#line 279
      if ((int const   )*(*tmp___5 + c2) & 512) {
        {
#line 280
        c2 = toupper(c2);
        }
      }
    }
#line 282
    if (c1 != c2) {
#line 283
      if (c1 < c2) {
#line 283
        tmp___7 = -1;
      } else {
#line 283
        tmp___7 = 1;
      }
#line 283
      return (tmp___7);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 285
  if (length1 == length2) {
#line 285
    tmp___9 = 0;
  } else {
#line 285
    if (length1 < length2) {
#line 285
      tmp___8 = -1;
    } else {
#line 285
      tmp___8 = 1;
    }
#line 285
    tmp___9 = tmp___8;
  }
#line 285
  return (tmp___9);
}
}
#line 291 "/home/khheo/project/mit-scheme-9.2/src/microcode/option.c"
static char *string_copy(char const   *s ) 
{ 
  char *result ;
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 294
  tmp = strlen(s);
#line 294
  tmp___0 = OS_malloc(tmp + 1UL);
#line 294
  result = (char *)tmp___0;
#line 295
  strcpy((char */* __restrict  */)result, (char const   */* __restrict  */)s);
  }
#line 296
  return (result);
}
}
#line 299 "/home/khheo/project/mit-scheme-9.2/src/microcode/option.c"
static char *string_copy_limited(char const   *s , char const   *e ) 
{ 
  unsigned int n_chars ;
  char *result ;
  void *tmp ;

  {
  {
#line 302
  n_chars = (unsigned int )(e - s);
#line 303
  tmp = OS_malloc((size_t )(n_chars + 1U));
#line 303
  result = (char *)tmp;
#line 304
  strncpy((char */* __restrict  */)result, (char const   */* __restrict  */)s, (size_t )n_chars);
  }
#line 305
  return (result);
}
}
#line 353 "/home/khheo/project/mit-scheme-9.2/src/microcode/option.c"
static unsigned int strlen_after_unquoting(char const   *s ) 
{ 
  char const   *scan ;
  unsigned int n_chars ;
  int c ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 356
  scan = s;
#line 357
  n_chars = 0U;
  {
#line 358
  while (1) {
    while_continue: /* CIL Label */ ;
#line 360
    tmp = scan;
#line 360
    scan ++;
#line 360
    c = (int )*tmp;
#line 361
    if (c == 92) {
#line 362
      tmp___0 = scan;
#line 362
      scan ++;
#line 362
      c = (int )*tmp___0;
    }
#line 363
    if (c == 0) {
#line 364
      return (n_chars);
    }
#line 365
    n_chars ++;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 369 "/home/khheo/project/mit-scheme-9.2/src/microcode/option.c"
static char *unquote_string(char const   *s ) 
{ 
  char const   *scan_in ;
  char *result ;
  unsigned int tmp ;
  void *tmp___0 ;
  char *scan_out ;
  int c ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 372
  scan_in = s;
#line 373
  tmp = strlen_after_unquoting(s);
#line 373
  tmp___0 = OS_malloc((size_t )(tmp + 1U));
#line 373
  result = (char *)tmp___0;
#line 374
  scan_out = result;
  }
  {
#line 375
  while (1) {
    while_continue: /* CIL Label */ ;
#line 377
    tmp___1 = scan_in;
#line 377
    scan_in ++;
#line 377
    c = (int )*tmp___1;
#line 378
    if (c == 92) {
#line 379
      tmp___2 = scan_in;
#line 379
      scan_in ++;
#line 379
      c = (int )*tmp___2;
    }
#line 380
    tmp___3 = scan_out;
#line 380
    scan_out ++;
#line 380
    *tmp___3 = (char )c;
#line 381
    if (c == 0) {
#line 382
      return (result);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 393 "/home/khheo/project/mit-scheme-9.2/src/microcode/option.c"
static void option_argument(char const   *option , _Bool argument_p , void *value_cell ) 
{ 
  struct option_descriptor descriptor ;
  struct obstack *__o ;
  int __len ;

  {
#line 397
  descriptor.option = option;
#line 398
  descriptor.argument_p = argument_p;
#line 399
  descriptor.value_cell = value_cell;
#line 400
  __o = & scratch_obstack;
#line 400
  __len = (int )sizeof(descriptor);
#line 400
  if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
    {
#line 400
    _obstack_newchunk(__o, __len);
    }
  }
  {
#line 400
  memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)(& descriptor),
         (size_t )__len);
#line 400
  __o->next_free += __len;
  }
#line 401
  return;
}
}
#line 403 "/home/khheo/project/mit-scheme-9.2/src/microcode/option.c"
static void parse_options(int argc , char const   **argv ) 
{ 
  char const   **scan_argv ;
  char const   **end_argv ;
  unsigned int n_descriptors ;
  struct obstack *__o ;
  struct option_descriptor *descriptors ;
  struct obstack *__o___0 ;
  void *value ;
  struct option_descriptor *end_desc ;
  struct option_descriptor *scan_desc ;
  char const   **value_cell ;
  _Bool *value_cell___0 ;
  char const   *option ;
  char const   **tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char const   **value_cell___1 ;
  char const   **tmp___2 ;
  _Bool *value_cell___2 ;
  int tmp___3 ;
  struct obstack *__o___1 ;
  void *__obj ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *__cil_tmp27 ;

  {
#line 406
  scan_argv = argv + 1;
#line 407
  end_argv = scan_argv + (argc - 1);
#line 409
  __o = & scratch_obstack;
#line 409
  n_descriptors = (unsigned int )((unsigned long )((unsigned int )(__o->next_free - __o->object_base)) / sizeof(struct option_descriptor ));
#line 411
  __o___0 = & scratch_obstack;
#line 411
  value = (void *)__o___0->object_base;
#line 411
  __o___0->next_free = (char *)((void *)((char *)0 + (((__o___0->next_free - (char *)0) + __o___0->alignment_mask) & ~ __o___0->alignment_mask)));
#line 411
  if (__o___0->next_free - (char *)__o___0->chunk > __o___0->chunk_limit - (char *)__o___0->chunk) {
#line 411
    __o___0->next_free = __o___0->chunk_limit;
  }
#line 411
  __o___0->object_base = __o___0->next_free;
#line 411
  descriptors = (struct option_descriptor *)value;
#line 412
  end_desc = descriptors + n_descriptors;
#line 414
  scan_desc = descriptors;
  {
#line 414
  while (1) {
    while_continue: /* CIL Label */ ;
#line 414
    if (! ((unsigned long )scan_desc < (unsigned long )end_desc)) {
#line 414
      goto while_break;
    }
#line 415
    if (scan_desc->argument_p) {
#line 417
      value_cell = (char const   **)scan_desc->value_cell;
#line 418
      if ((unsigned long )value_cell != (unsigned long )((char const   **)0)) {
#line 419
        *value_cell = (char const   *)0;
      }
    } else {
#line 423
      value_cell___0 = (_Bool *)scan_desc->value_cell;
#line 424
      if ((unsigned long )value_cell___0 != (unsigned long )((_Bool *)0)) {
#line 425
        *value_cell___0 = (_Bool)0;
      }
    }
#line 414
    scan_desc ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 427
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 427
    if (! ((unsigned long )scan_argv < (unsigned long )end_argv)) {
#line 427
      goto while_break___0;
    }
    {
#line 429
    tmp = scan_argv;
#line 429
    scan_argv ++;
#line 429
    option = *tmp;
#line 430
    tmp___1 = strncmp("--", option, (size_t )2);
    }
#line 430
    if (tmp___1 == 0) {
#line 431
      option += 2;
    } else {
      {
#line 432
      tmp___0 = strncmp("-", option, (size_t )1);
      }
#line 432
      if (tmp___0 == 0) {
#line 433
        option ++;
      } else {
#line 436
        scan_argv --;
#line 437
        goto while_break___0;
      }
    }
#line 439
    scan_desc = descriptors;
    {
#line 439
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 439
      if (! ((unsigned long )scan_desc < (unsigned long )end_desc)) {
#line 439
        goto while_break___1;
      }
      {
#line 440
      tmp___3 = string_compare_ci(option, scan_desc->option);
      }
#line 440
      if (tmp___3 == 0) {
#line 442
        if (scan_desc->argument_p) {
#line 444
          value_cell___1 = (char const   **)scan_desc->value_cell;
#line 445
          if ((unsigned long )scan_argv < (unsigned long )end_argv) {
#line 447
            if ((unsigned long )value_cell___1 != (unsigned long )((char const   **)0)) {
#line 448
              tmp___2 = scan_argv;
#line 448
              scan_argv ++;
#line 448
              *value_cell___1 = *tmp___2;
            }
          } else {
            {
#line 452
            outf_fatal("%s: option --%s requires an argument.\n", scheme_program_name,
                       option);
#line 454
            termination_init_error();
            }
          }
        } else {
#line 459
          value_cell___2 = (_Bool *)scan_desc->value_cell;
#line 460
          if ((unsigned long )value_cell___2 != (unsigned long )((_Bool *)0)) {
#line 461
            *value_cell___2 = (_Bool)1;
          }
        }
#line 463
        goto while_break___1;
      }
#line 439
      scan_desc ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 465
    if ((unsigned long )scan_desc == (unsigned long )end_desc) {
#line 467
      scan_argv --;
#line 468
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 471
  __o___1 = & scratch_obstack;
#line 471
  __obj = (void *)descriptors;
#line 471
  if ((unsigned long )__obj > (unsigned long )((void *)__o___1->chunk)) {
#line 471
    if ((unsigned long )__obj < (unsigned long )((void *)__o___1->chunk_limit)) {
#line 471
      tmp___4 = (char *)__obj;
#line 471
      __o___1->object_base = tmp___4;
#line 471
      __o___1->next_free = tmp___4;
    } else {
      {
#line 471
      obstack_free(__o___1, __obj);
      }
    }
  } else {
    {
#line 471
    obstack_free(__o___1, __obj);
    }
  }
  {
#line 473
  tmp___5 = strncmp("--version", *(scan_argv + -1), (size_t )9);
  }
#line 473
  if (tmp___5 == 0) {
#line 474
    scan_argv --;
  }
  {
#line 475
  tmp___6 = strncmp("--help", *(scan_argv + -1), (size_t )6);
  }
#line 475
  if (tmp___6 == 0) {
#line 476
    scan_argv --;
  }
#line 478
  option_saved_argc = argc;
#line 479
  option_saved_argv = argv;
#line 480
  option_unused_argc = (int )(end_argv - scan_argv);
#line 481
  option_unused_argv = scan_argv;
#line 482
  return;
}
}
#line 484 "/home/khheo/project/mit-scheme-9.2/src/microcode/option.c"
static void parse_standard_options(int argc , char const   **argv ) 
{ 
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
  {
#line 487
  option_argument("band", (_Bool)1, (void *)(& option_raw_band));
#line 488
  option_argument("batch-mode", (_Bool)0, (void *)(& option_batch_mode));
#line 489
  option_argument("constant", (_Bool)1, (void *)(& option_raw_constant));
#line 490
  option_argument("emacs", (_Bool)0, (void *)(& option_emacs_subprocess));
#line 491
  option_argument("fasl", (_Bool)1, (void *)(& option_fasl_file));
#line 492
  option_argument("heap", (_Bool)1, (void *)(& option_raw_heap));
#line 493
  option_argument("help", (_Bool)0, (void *)(& option_show_help));
#line 494
  option_argument("interactive", (_Bool)0, (void *)(& option_force_interactive));
#line 495
  option_argument("library", (_Bool)1, (void *)(& option_raw_library));
#line 499
  option_argument("nocore", (_Bool)0, (void *)(& option_disable_core_dump));
#line 500
  option_argument("option-summary", (_Bool)0, (void *)(& option_summary));
#line 501
  option_argument("quiet", (_Bool)0, (void *)(& option_batch_mode));
#line 502
  option_argument("silent", (_Bool)0, (void *)(& option_batch_mode));
#line 503
  option_argument("stack", (_Bool)1, (void *)(& option_raw_stack));
#line 504
  option_argument("version", (_Bool)0, (void *)(& option_show_version));
#line 507
  option_argument("compiler", (_Bool)0, (void *)0);
#line 508
  option_argument("edwin", (_Bool)0, (void *)0);
#line 509
  option_argument("large", (_Bool)0, (void *)0);
#line 510
  option_argument("utab", (_Bool)1, (void *)0);
#line 511
  option_argument("utabmd", (_Bool)1, (void *)0);
#line 513
  parse_options(argc, argv);
  }
#line 514
  return;
}
}
#line 516 "/home/khheo/project/mit-scheme-9.2/src/microcode/option.c"
static char const   *standard_string_option(char const   *option , char const   *variable ,
                                            char const   *defval ) 
{ 
  char const   *t ;
  char *tmp ;
  char const   *tmp___0 ;

  {
#line 521
  if ((unsigned long )option != (unsigned long )((char const   *)0)) {
#line 522
    return (option);
  }
  {
#line 524
  tmp = getenv(variable);
#line 524
  t = (char const   *)tmp;
  }
#line 525
  if ((unsigned long )t != (unsigned long )((char const   *)0)) {
#line 525
    tmp___0 = t;
  } else {
#line 525
    tmp___0 = defval;
  }
#line 525
  return (tmp___0);
}
}
#line 529 "/home/khheo/project/mit-scheme-9.2/src/microcode/option.c"
static unsigned long standard_numeric_option(char const   *option , char const   *optval ,
                                             char const   *variable , unsigned long defval ) 
{ 
  char *end ;
  unsigned long n ;
  unsigned long tmp ;
  char const   *t ;
  char *tmp___0 ;
  char *end___0 ;
  unsigned long n___0 ;
  unsigned long tmp___1 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 535
  if ((unsigned long )optval != (unsigned long )((char const   *)0)) {
    {
#line 538
    tmp = strtoul((char const   */* __restrict  */)optval, (char **/* __restrict  */)(& end),
                  0);
#line 538
    n = tmp;
    }
#line 539
    if ((unsigned long )end == (unsigned long )optval) {
      {
#line 541
      outf_fatal("%s: illegal argument for option --%s: %s\n", scheme_program_name,
                 option, optval);
#line 543
      termination_init_error();
      }
    } else
#line 539
    if ((int )*end != 0) {
      {
#line 541
      outf_fatal("%s: illegal argument for option --%s: %s\n", scheme_program_name,
                 option, optval);
#line 543
      termination_init_error();
      }
    }
#line 545
    return (n);
  }
#line 547
  if ((unsigned long )variable != (unsigned long )((char const   *)0)) {
    {
#line 549
    tmp___0 = getenv(variable);
#line 549
    t = (char const   *)tmp___0;
    }
#line 550
    if ((unsigned long )t != (unsigned long )((char const   *)0)) {
      {
#line 553
      tmp___1 = strtoul((char const   */* __restrict  */)t, (char **/* __restrict  */)(& end___0),
                        0);
#line 553
      n___0 = tmp___1;
      }
#line 554
      if ((unsigned long )end___0 == (unsigned long )t) {
        {
#line 556
        outf_fatal("%s: illegal value for environment variable %s: %s\n", scheme_program_name,
                   variable, t);
#line 559
        termination_init_error();
        }
      } else
#line 554
      if ((int )*end___0 != 0) {
        {
#line 556
        outf_fatal("%s: illegal value for environment variable %s: %s\n", scheme_program_name,
                   variable, t);
#line 559
        termination_init_error();
        }
      }
#line 561
      return (n___0);
    }
  }
#line 564
  return (defval);
}
}
#line 567 "/home/khheo/project/mit-scheme-9.2/src/microcode/option.c"
static char const   *get_wd(void) 
{ 
  char const   *wd ;
  char const   *tmp ;
  unsigned int len ;
  size_t tmp___0 ;
  char *result ;
  void *tmp___1 ;
  char *scan_result ;
  char const   *scan_wd ;
  char const   *end_wd ;
  char *tmp___2 ;
  char const   *tmp___3 ;

  {
  {
#line 570
  tmp = OS_working_dir_pathname();
#line 570
  wd = tmp;
#line 571
  tmp___0 = strlen(wd);
#line 571
  len = (unsigned int )tmp___0;
  }
#line 572
  if ((int const   )*(wd + (len - 1U)) == 47) {
#line 573
    len --;
  }
  {
#line 575
  tmp___1 = OS_malloc((size_t )(len + 1U));
#line 575
  result = (char *)tmp___1;
#line 576
  scan_result = result;
#line 577
  scan_wd = wd;
#line 578
  end_wd = scan_wd + len;
  }
  {
#line 579
  while (1) {
    while_continue: /* CIL Label */ ;
#line 579
    if (! ((unsigned long )scan_wd < (unsigned long )end_wd)) {
#line 579
      goto while_break;
    }
#line 580
    tmp___2 = scan_result;
#line 580
    scan_result ++;
#line 580
    tmp___3 = scan_wd;
#line 580
    scan_wd ++;
#line 580
    *tmp___2 = (char )*tmp___3;
  }
  while_break: /* CIL Label */ ;
  }
#line 581
  *scan_result = (char )'\000';
#line 582
  return ((char const   *)result);
}
}
#line 586 "/home/khheo/project/mit-scheme-9.2/src/microcode/option.c"
static char const   *find_path_delimiter(char const   *s ) 
{ 
  char const   *scan ;
  int c ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 589
  scan = s;
  {
#line 590
  while (1) {
    while_continue: /* CIL Label */ ;
#line 592
    tmp = scan;
#line 592
    scan ++;
#line 592
    c = (int )*tmp;
#line 593
    if (c == 58) {
#line 594
      return (scan - 1);
    }
#line 595
    if (c == 92) {
#line 596
      tmp___0 = scan;
#line 596
      scan ++;
#line 596
      c = (int )*tmp___0;
    }
#line 597
    if (c == 0) {
#line 598
      return ((char const   *)0);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 602 "/home/khheo/project/mit-scheme-9.2/src/microcode/option.c"
static char const   **parse_path_string(char const   *path ) 
{ 
  char const   *start ;
  char const   *wd ;
  char const   *tmp ;
  unsigned int lwd ;
  size_t tmp___0 ;
  char const   *delim ;
  char const   *tmp___1 ;
  char *unquoted ;
  char *end ;
  char *element ;
  char const   *copy ;
  char *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  char *tmp___6 ;
  struct obstack *__o ;
  struct obstack *__o___0 ;
  unsigned int n_bytes ;
  struct obstack *__o___1 ;
  char const   **elements ;
  struct obstack *__o___2 ;
  void *value ;
  char const   **scan ;
  char const   **end___0 ;
  char const   **result ;
  void *tmp___7 ;
  char const   **scan_result ;
  char const   **tmp___8 ;
  char const   **tmp___9 ;
  struct obstack *__o___3 ;
  void *__obj ;
  char *tmp___10 ;

  {
  {
#line 605
  start = path;
#line 610
  tmp = get_wd();
#line 610
  wd = tmp;
#line 611
  tmp___0 = strlen(wd);
#line 611
  lwd = (unsigned int )tmp___0;
  }
  {
#line 612
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 614
    tmp___1 = find_path_delimiter(start);
#line 614
    delim = tmp___1;
    }
#line 618
    if ((unsigned long )delim != (unsigned long )((char const   *)0)) {
      {
#line 620
      tmp___2 = string_copy_limited(start, delim);
#line 620
      copy = (char const   *)tmp___2;
#line 621
      unquoted = unquote_string(copy);
#line 622
      OS_free((void *)copy);
      }
    } else {
      {
#line 625
      unquoted = unquote_string(start);
      }
    }
    {
#line 627
    tmp___3 = strlen((char const   *)unquoted);
#line 627
    end = unquoted + tmp___3;
    }
#line 628
    if ((unsigned long )end > (unsigned long )unquoted) {
#line 628
      if ((int )*(end - 1) == 47) {
#line 629
        end --;
#line 629
        *end = (char )'\000';
      }
    }
#line 630
    if ((int )*(unquoted + 0) == 47) {
#line 631
      element = unquoted;
    } else {
#line 634
      if ((int )*unquoted == 0) {
        {
#line 635
        element = string_copy(wd);
        }
      } else {
        {
#line 638
        tmp___4 = strlen((char const   *)unquoted);
#line 638
        tmp___5 = OS_malloc(((size_t )lwd + tmp___4) + 2UL);
#line 638
        element = (char *)tmp___5;
#line 639
        strcpy((char */* __restrict  */)element, (char const   */* __restrict  */)wd);
#line 640
        end = element + lwd;
#line 641
        tmp___6 = end;
#line 641
        end ++;
#line 641
        *tmp___6 = (char )'/';
#line 642
        strcpy((char */* __restrict  */)end, (char const   */* __restrict  */)unquoted);
        }
      }
      {
#line 644
      OS_free((void *)unquoted);
      }
    }
#line 646
    __o = & scratch_obstack;
#line 646
    if ((unsigned long )(__o->next_free + sizeof(void *)) > (unsigned long )__o->chunk_limit) {
      {
#line 646
      _obstack_newchunk(__o, (int )sizeof(void *));
      }
    }
#line 646
    *((void **)__o->next_free) = (void *)element;
#line 646
    __o->next_free += sizeof(void *);
#line 647
    if ((unsigned long )delim == (unsigned long )((char const   *)0)) {
#line 648
      goto while_break;
    }
#line 649
    start = delim + 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 651
  __o___0 = & scratch_obstack;
#line 651
  if ((unsigned long )(__o___0->next_free + sizeof(void *)) > (unsigned long )__o___0->chunk_limit) {
    {
#line 651
    _obstack_newchunk(__o___0, (int )sizeof(void *));
    }
  }
#line 651
  *((void **)__o___0->next_free) = (void *)0;
#line 651
  __o___0->next_free += sizeof(void *);
#line 652
  if ((unsigned long )wd != (unsigned long )((char const   *)0)) {
    {
#line 653
    OS_free((void *)wd);
    }
  }
#line 655
  __o___1 = & scratch_obstack;
#line 655
  n_bytes = (unsigned int )(__o___1->next_free - __o___1->object_base);
#line 656
  __o___2 = & scratch_obstack;
#line 656
  value = (void *)__o___2->object_base;
#line 656
  __o___2->next_free = (char *)((void *)((char *)0 + (((__o___2->next_free - (char *)0) + __o___2->alignment_mask) & ~ __o___2->alignment_mask)));
#line 656
  if (__o___2->next_free - (char *)__o___2->chunk > __o___2->chunk_limit - (char *)__o___2->chunk) {
#line 656
    __o___2->next_free = __o___2->chunk_limit;
  }
  {
#line 656
  __o___2->object_base = __o___2->next_free;
#line 656
  elements = (char const   **)value;
#line 657
  scan = elements;
#line 658
  end___0 = scan + (unsigned long )n_bytes / sizeof(char *);
#line 659
  tmp___7 = OS_malloc((size_t )n_bytes);
#line 659
  result = (char const   **)tmp___7;
#line 660
  scan_result = result;
  }
  {
#line 661
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 661
    if (! ((unsigned long )scan < (unsigned long )end___0)) {
#line 661
      goto while_break___0;
    }
#line 662
    tmp___8 = scan_result;
#line 662
    scan_result ++;
#line 662
    tmp___9 = scan;
#line 662
    scan ++;
#line 662
    *tmp___8 = *tmp___9;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 663
  __o___3 = & scratch_obstack;
#line 663
  __obj = (void *)elements;
#line 663
  if ((unsigned long )__obj > (unsigned long )((void *)__o___3->chunk)) {
#line 663
    if ((unsigned long )__obj < (unsigned long )((void *)__o___3->chunk_limit)) {
#line 663
      tmp___10 = (char *)__obj;
#line 663
      __o___3->object_base = tmp___10;
#line 663
      __o___3->next_free = tmp___10;
    } else {
      {
#line 663
      obstack_free(__o___3, __obj);
      }
    }
  } else {
    {
#line 663
    obstack_free(__o___3, __obj);
    }
  }
#line 664
  return (result);
}
}
#line 668 "/home/khheo/project/mit-scheme-9.2/src/microcode/option.c"
static void free_parsed_path(char const   **path ) 
{ 
  char const   **scan ;
  char const   *element ;
  char const   **tmp ;

  {
#line 671
  scan = path;
  {
#line 672
  while (1) {
    while_continue: /* CIL Label */ ;
#line 674
    tmp = scan;
#line 674
    scan ++;
#line 674
    element = *tmp;
#line 675
    if ((unsigned long )element == (unsigned long )((char const   *)0)) {
#line 676
      goto while_break;
    }
    {
#line 677
    OS_free((void *)element);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 679
  OS_free((void *)path);
  }
#line 680
  return;
}
}
#line 700 "/home/khheo/project/mit-scheme-9.2/src/microcode/option.c"
char const   *search_for_library_file(char const   *filename ) 
{ 
  unsigned int flen ;
  size_t tmp ;
  char const   **scan_path ;
  char const   *directory ;
  char const   **tmp___0 ;
  unsigned int dlen ;
  char const   *fullname ;
  size_t tmp___1 ;
  struct obstack *__o ;
  int __len ;
  struct obstack *__o___0 ;
  char *tmp___2 ;
  struct obstack *__o___1 ;
  int __len___0 ;
  struct obstack *__o___2 ;
  char *tmp___3 ;
  struct obstack *__o___3 ;
  void *value ;
  char const   *result ;
  char *tmp___4 ;
  struct obstack *__o___4 ;
  void *__obj ;
  char *tmp___5 ;
  int tmp___6 ;
  struct obstack *__o___5 ;
  void *__obj___0 ;
  char *tmp___7 ;

  {
  {
#line 703
  tmp = strlen(filename);
#line 703
  flen = (unsigned int )tmp;
#line 704
  scan_path = option_library_path;
  }
  {
#line 705
  while (1) {
    while_continue: /* CIL Label */ ;
#line 707
    tmp___0 = scan_path;
#line 707
    scan_path ++;
#line 707
    directory = *tmp___0;
#line 710
    if ((unsigned long )directory == (unsigned long )((char const   *)0)) {
#line 711
      return ((char const   *)0);
    }
    {
#line 712
    tmp___1 = strlen(directory);
#line 712
    dlen = (unsigned int )tmp___1;
    }
#line 713
    if (dlen > 0U) {
#line 715
      __o = & scratch_obstack;
#line 715
      __len = (int )dlen;
#line 715
      if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
        {
#line 715
        _obstack_newchunk(__o, __len);
        }
      }
      {
#line 715
      memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)directory,
             (size_t )__len);
#line 715
      __o->next_free += __len;
#line 716
      __o___0 = & scratch_obstack;
      }
#line 716
      if ((unsigned long )(__o___0->next_free + 1) > (unsigned long )__o___0->chunk_limit) {
        {
#line 716
        _obstack_newchunk(__o___0, 1);
        }
      }
#line 716
      tmp___2 = __o___0->next_free;
#line 716
      (__o___0->next_free) ++;
#line 716
      *tmp___2 = (char )'/';
    }
#line 718
    __o___1 = & scratch_obstack;
#line 718
    __len___0 = (int )flen;
#line 718
    if ((unsigned long )(__o___1->next_free + __len___0) > (unsigned long )__o___1->chunk_limit) {
      {
#line 718
      _obstack_newchunk(__o___1, __len___0);
      }
    }
    {
#line 718
    memcpy((void */* __restrict  */)__o___1->next_free, (void const   */* __restrict  */)filename,
           (size_t )__len___0);
#line 718
    __o___1->next_free += __len___0;
#line 719
    __o___2 = & scratch_obstack;
    }
#line 719
    if ((unsigned long )(__o___2->next_free + 1) > (unsigned long )__o___2->chunk_limit) {
      {
#line 719
      _obstack_newchunk(__o___2, 1);
      }
    }
#line 719
    tmp___3 = __o___2->next_free;
#line 719
    (__o___2->next_free) ++;
#line 719
    *tmp___3 = (char )'\000';
#line 720
    __o___3 = & scratch_obstack;
#line 720
    value = (void *)__o___3->object_base;
#line 720
    __o___3->next_free = (char *)((void *)((char *)0 + (((__o___3->next_free - (char *)0) + __o___3->alignment_mask) & ~ __o___3->alignment_mask)));
#line 720
    if (__o___3->next_free - (char *)__o___3->chunk > __o___3->chunk_limit - (char *)__o___3->chunk) {
#line 720
      __o___3->next_free = __o___3->chunk_limit;
    }
    {
#line 720
    __o___3->object_base = __o___3->next_free;
#line 720
    fullname = (char const   *)value;
#line 721
    tmp___6 = OS_file_access(fullname, 4U);
    }
#line 721
    if (tmp___6) {
      {
#line 723
      tmp___4 = string_copy(fullname);
#line 723
      result = (char const   *)tmp___4;
#line 724
      __o___4 = & scratch_obstack;
#line 724
      __obj = (void *)((char *)fullname);
      }
#line 724
      if ((unsigned long )__obj > (unsigned long )((void *)__o___4->chunk)) {
#line 724
        if ((unsigned long )__obj < (unsigned long )((void *)__o___4->chunk_limit)) {
#line 724
          tmp___5 = (char *)__obj;
#line 724
          __o___4->object_base = tmp___5;
#line 724
          __o___4->next_free = tmp___5;
        } else {
          {
#line 724
          obstack_free(__o___4, __obj);
          }
        }
      } else {
        {
#line 724
        obstack_free(__o___4, __obj);
        }
      }
#line 725
      return (result);
    }
#line 727
    __o___5 = & scratch_obstack;
#line 727
    __obj___0 = (void *)((char *)fullname);
#line 727
    if ((unsigned long )__obj___0 > (unsigned long )((void *)__o___5->chunk)) {
#line 727
      if ((unsigned long )__obj___0 < (unsigned long )((void *)__o___5->chunk_limit)) {
#line 727
        tmp___7 = (char *)__obj___0;
#line 727
        __o___5->object_base = tmp___7;
#line 727
        __o___5->next_free = tmp___7;
      } else {
        {
#line 727
        obstack_free(__o___5, __obj___0);
        }
      }
    } else {
      {
#line 727
      obstack_free(__o___5, __obj___0);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 731 "/home/khheo/project/mit-scheme-9.2/src/microcode/option.c"
char const   *search_path_for_file(char const   *option , char const   *filename ,
                                   _Bool default_p , _Bool fail_p ) 
{ 
  char const   *result ;
  char const   *tmp ;
  char const   **scan_path ;
  char const   *tmp___0 ;
  char const   *element ;
  char const   **tmp___1 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
  {
#line 737
  tmp = search_for_library_file(filename);
#line 737
  result = tmp;
  }
#line 738
  if ((unsigned long )result != (unsigned long )((char const   *)0)) {
#line 739
    return (result);
  }
#line 740
  if (! fail_p) {
#line 741
    return (filename);
  } else {
#line 744
    scan_path = option_library_path;
#line 745
    if (default_p) {
#line 745
      tmp___0 = "default";
    } else {
#line 745
      tmp___0 = "file";
    }
    {
#line 745
    outf_fatal("%s: can\'t find a readable %s", scheme_program_name, tmp___0);
    }
#line 748
    if ((unsigned long )option != (unsigned long )((char const   *)0)) {
      {
#line 749
      outf_fatal(" for option --%s", option);
      }
    }
    {
#line 750
    outf_fatal(".\n");
#line 751
    outf_fatal("\tsearched for file %s in these directories:\n", filename);
    }
#line 752
    if (! default_p) {
      {
#line 753
      outf_fatal("\t.\n");
      }
    }
    {
#line 754
    while (1) {
      while_continue: /* CIL Label */ ;
#line 756
      tmp___1 = scan_path;
#line 756
      scan_path ++;
#line 756
      element = *tmp___1;
#line 757
      if ((unsigned long )element == (unsigned long )((char const   *)0)) {
#line 758
        goto while_break;
      }
      {
#line 759
      outf_fatal("\t%s\n", element);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 761
    termination_init_error();
    }
#line 763
    return ((char const   *)0);
  }
}
}
#line 767 "/home/khheo/project/mit-scheme-9.2/src/microcode/option.c"
static char const   *standard_filename_option(char const   *option , char const   *optval ,
                                              char const   *variable , char const   *defval ,
                                              _Bool fail_p ) 
{ 
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char const   *filename ;
  char *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  char const   *tmp___6 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 774
  if ((unsigned long )optval != (unsigned long )((char const   *)0)) {
    {
#line 776
    tmp___0 = OS_file_access(optval, 4U);
    }
#line 776
    if (tmp___0) {
      {
#line 777
      tmp = string_copy(optval);
      }
#line 777
      return ((char const   *)tmp);
    }
#line 778
    if ((int const   )*(optval + 0) == 47) {
#line 780
      if (fail_p) {
        {
#line 782
        outf_fatal("%s: can\'t read file %s for option --%s.\n", scheme_program_name,
                   optval, option);
#line 784
        termination_init_error();
        }
      }
      {
#line 786
      tmp___1 = string_copy(optval);
      }
#line 786
      return ((char const   *)tmp___1);
    }
    {
#line 788
    tmp___2 = search_path_for_file(option, optval, (_Bool)0, fail_p);
    }
#line 788
    return (tmp___2);
  }
  {
#line 791
  tmp___3 = getenv(variable);
#line 791
  filename = (char const   *)tmp___3;
  }
#line 792
  if ((unsigned long )filename == (unsigned long )((char const   *)0)) {
#line 793
    filename = defval;
  }
#line 794
  if ((int const   )*(filename + 0) == 47) {
    {
#line 796
    tmp___4 = OS_file_access(filename, 4U);
    }
#line 796
    if (! tmp___4) {
#line 796
      if (fail_p) {
        {
#line 798
        outf_fatal("%s: can\'t read default file %s for option --%s.\n", scheme_program_name,
                   filename, option);
#line 800
        termination_init_error();
        }
      }
    }
    {
#line 802
    tmp___5 = string_copy(filename);
    }
#line 802
    return ((char const   *)tmp___5);
  } else {
    {
#line 805
    tmp___6 = search_path_for_file(option, filename, (_Bool)1, fail_p);
    }
#line 805
    return (tmp___6);
  }
}
}
#line 809 "/home/khheo/project/mit-scheme-9.2/src/microcode/option.c"
static void conflicting_options(char const   *option1 , char const   *option2 ) 
{ 
  char *__cil_tmp3 ;

  {
  {
#line 812
  outf_fatal("%s: can\'t specify both options --%s and --%s.\n", scheme_program_name,
             option1, option2);
#line 814
  termination_init_error();
  }
}
}
#line 819 "/home/khheo/project/mit-scheme-9.2/src/microcode/option.c"
static int read_band_sizes(char const   *filename , unsigned long *constant_size ,
                           unsigned long *heap_size ) 
{ 
  fasl_file_handle_t handle ;
  fasl_header_t h ;
  _Bool ok ;
  _Bool tmp ;
  _Bool tmp___0 ;
  fasl_read_status_t tmp___1 ;
  fasl_read_status_t tmp___2 ;

  {
  {
#line 828
  tmp = open_fasl_input_file(filename, & handle);
  }
#line 828
  if (! tmp) {
#line 829
    return (0);
  }
  {
#line 830
  ok = read_fasl_header(& h, handle);
#line 831
  tmp___0 = close_fasl_input_file(handle);
  }
#line 831
  if (tmp___0) {
#line 831
    if (! ok) {
#line 832
      return (0);
    }
  } else {
#line 832
    return (0);
  }
  {
#line 833
  tmp___1 = check_fasl_version(& h);
  }
#line 833
  if ((unsigned int )tmp___1 != 0U) {
#line 834
    return (0);
  }
  {
#line 835
  tmp___2 = check_fasl_cc_version(& h, 3UL, 14UL);
  }
#line 835
  if ((unsigned int )tmp___2 != 0U) {
#line 839
    return (0);
  }
#line 840
  *constant_size = ((unsigned long )(h.constant_end - h.constant_start) + 1023UL) / 1024UL;
#line 841
  *heap_size = ((unsigned long )(h.heap_end - h.heap_start) + 1023UL) / 1024UL;
#line 842
  return (1);
}
}
#line 845 "/home/khheo/project/mit-scheme-9.2/src/microcode/option.c"
static void describe_boolean_option(char const   *name , int value ) 
{ 
  char const   *tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 848
  if (value) {
#line 848
    tmp = "yes";
  } else {
#line 848
    tmp = "no";
  }
  {
#line 848
  outf_fatal("  %s: %s\n", name, tmp);
  }
#line 849
  return;
}
}
#line 851 "/home/khheo/project/mit-scheme-9.2/src/microcode/option.c"
static void describe_string_option(char const   *name , char const   *value ) 
{ 
  char *__cil_tmp3 ;

  {
  {
#line 854
  outf_fatal("  %s: %s\n", name, value);
  }
#line 855
  return;
}
}
#line 857 "/home/khheo/project/mit-scheme-9.2/src/microcode/option.c"
static void describe_size_option(char const   *name , unsigned int value ) 
{ 
  char *__cil_tmp3 ;

  {
  {
#line 860
  outf_fatal("  %s size: %d\n", name, value);
  }
#line 861
  return;
}
}
#line 863 "/home/khheo/project/mit-scheme-9.2/src/microcode/option.c"
static void describe_path_option(char const   *name , char const   **value ) 
{ 
  char const   **scan ;
  char const   **tmp ;
  char const   *element ;
  char const   **tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 866
  outf_fatal("  %s: ", name);
#line 868
  scan = value;
#line 869
  tmp = scan;
#line 869
  scan ++;
#line 869
  outf_fatal("%s", *tmp);
  }
  {
#line 870
  while (1) {
    while_continue: /* CIL Label */ ;
#line 872
    tmp___0 = scan;
#line 872
    scan ++;
#line 872
    element = *tmp___0;
#line 873
    if ((unsigned long )element == (unsigned long )((char const   *)0)) {
#line 873
      goto while_break;
    }
    {
#line 874
    outf_fatal(":%s", element);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 877
  outf_fatal("\n");
  }
#line 878
  return;
}
}
#line 880 "/home/khheo/project/mit-scheme-9.2/src/microcode/option.c"
static void describe_options(void) 
{ 
  char const   **scan ;
  char const   **end ;
  char const   **tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
  {
#line 883
  outf_fatal("Summary of configuration options:\n");
#line 884
  describe_size_option("heap", (unsigned int )option_heap_size);
#line 885
  describe_size_option("constant-space", (unsigned int )option_constant_size);
#line 886
  describe_size_option("stack", (unsigned int )option_stack_size);
#line 887
  describe_path_option("library path", option_library_path);
  }
#line 888
  if ((unsigned long )option_fasl_file != (unsigned long )((char const   *)0)) {
    {
#line 889
    describe_string_option("FASL file", option_fasl_file);
    }
  } else {
    {
#line 891
    describe_string_option("band", option_band_file);
    }
  }
  {
#line 892
  describe_boolean_option("emacs subprocess", (int )option_emacs_subprocess);
#line 893
  describe_boolean_option("force interactive", (int )option_force_interactive);
#line 894
  describe_boolean_option("disable core dump", (int )option_disable_core_dump);
#line 895
  describe_boolean_option("suppress noise", (int )option_batch_mode);
  }
#line 896
  if (option_unused_argc == 0) {
    {
#line 897
    outf_fatal("  no unused arguments\n");
    }
  } else {
    {
#line 900
    scan = option_unused_argv;
#line 901
    end = scan + option_unused_argc;
#line 902
    outf_fatal("  unused arguments:");
    }
    {
#line 903
    while (1) {
      while_continue: /* CIL Label */ ;
#line 903
      if (! ((unsigned long )scan < (unsigned long )end)) {
#line 903
        goto while_break;
      }
      {
#line 904
      tmp = scan;
#line 904
      scan ++;
#line 904
      outf_fatal(" %s", *tmp);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 905
    outf_fatal("\n");
    }
  }
#line 907
  return;
}
}
#line 909 "/home/khheo/project/mit-scheme-9.2/src/microcode/option.c"
void read_command_line_options(int argc , char const   **argv ) 
{ 
  _Bool band_sizes_valid ;
  unsigned long band_constant_size ;
  unsigned long band_heap_size ;
  char const   *default_library_path ;
  char const   *tmp ;
  int tmp___0 ;
  char const   *default_band ;
  char const   *bands[5] ;
  unsigned int i ;
  char const   *tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  void *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;

  {
  {
#line 912
  band_sizes_valid = (_Bool)0;
#line 913
  band_constant_size = 0UL;
#line 914
  band_heap_size = 0UL;
#line 915
  default_library_path = "/usr/local/lib/mit-scheme-x86-64";
#line 917
  parse_standard_options(argc, argv);
  }
#line 918
  if ((unsigned long )option_library_path != (unsigned long )((char const   **)0)) {
    {
#line 919
    free_parsed_path(option_library_path);
    }
  }
  {
#line 929
  tmp = standard_string_option(option_raw_library, "MITSCHEME_LIBRARY_PATH", default_library_path);
#line 929
  option_library_path = parse_path_string(tmp);
  }
#line 935
  if ((unsigned long )option_band_file != (unsigned long )((char const   *)0)) {
    {
#line 937
    OS_free((void *)option_band_file);
#line 938
    option_band_file = (char const   *)0;
    }
  }
#line 940
  if ((unsigned long )option_fasl_file != (unsigned long )((char const   *)0)) {
#line 942
    if ((unsigned long )option_raw_band != (unsigned long )((char const   *)0)) {
      {
#line 943
      conflicting_options("fasl", "band");
      }
    }
    {
#line 945
    tmp___0 = OS_file_access(option_fasl_file, 4U);
    }
#line 945
    if (! tmp___0) {
      {
#line 948
      outf_fatal("%s: can\'t read option file: --fasl %s\n", scheme_program_name,
                 option_fasl_file);
#line 950
      termination_init_error();
      }
    }
  } else {
#line 956
    default_band = "all.com";
#line 957
    bands[0] = "all.com";
#line 957
    bands[1] = "runtime.com";
#line 957
    bands[2] = "mechanics.com";
#line 957
    bands[3] = "edwin-mechanics.com";
#line 957
    bands[4] = (char const   *)0;
#line 965
    i = 0U;
    {
#line 966
    while (1) {
      while_continue: /* CIL Label */ ;
#line 966
      if (! ((unsigned long )bands[i] != (unsigned long )((char const   *)0))) {
#line 966
        goto while_break;
      }
      {
#line 967
      tmp___1 = search_for_library_file(bands[i]);
      }
#line 967
      if (tmp___1) {
#line 969
        default_band = bands[i];
#line 970
        goto while_break;
      }
#line 966
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 972
    option_band_file = standard_filename_option("band", option_raw_band, "MITSCHEME_BAND",
                                                default_band, (_Bool)1);
    }
  }
#line 979
  if ((unsigned long )option_band_file != (unsigned long )((char const   *)0)) {
    {
#line 980
    tmp___2 = read_band_sizes(option_band_file, & band_constant_size, & band_heap_size);
#line 980
    band_sizes_valid = (_Bool )tmp___2;
    }
  }
  {
#line 985
  option_heap_size = standard_numeric_option("heap", option_raw_heap, "MITSCHEME_HEAP_SIZE",
                                             16384UL);
  }
#line 990
  if (band_sizes_valid) {
#line 991
    option_heap_size += band_heap_size;
  } else
#line 992
  if ((unsigned long )option_fasl_file != (unsigned long )((char const   *)0)) {
#line 992
    if (option_heap_size < 2048UL) {
#line 994
      option_heap_size = 2048UL;
    }
  }
#line 995
  if (band_sizes_valid) {
#line 995
    tmp___3 = band_constant_size;
  } else {
#line 995
    tmp___3 = 1024UL;
  }
  {
#line 995
  option_constant_size = standard_numeric_option("constant", option_raw_constant,
                                                 (char const   *)0, tmp___3);
#line 1002
  option_stack_size = standard_numeric_option("stack", option_raw_stack, "MITSCHEME_STACK_SIZE",
                                              128UL);
  }
#line 1007
  if (option_show_version) {
    {
#line 1009
    outf_console("%s\n", "MIT/GNU Scheme microcode 15.3");
#line 1010
    outf_flush_console();
    }
  }
#line 1012
  if (option_show_help) {
    {
#line 1013
    print_help();
    }
  }
#line 1014
  if (option_summary) {
    {
#line 1015
    describe_options();
    }
  }
#line 1016
  return;
}
}
#line 153 "/home/khheo/project/mit-scheme-9.2/src/microcode/obstack.h"
void _obstack_free(struct obstack *h , void *obj ) ;
#line 50 "/home/khheo/project/mit-scheme-9.2/src/microcode/obstack.c"
struct obstack *_obstack  ;
#line 57 "/home/khheo/project/mit-scheme-9.2/src/microcode/obstack.c"
void _obstack_begin(struct obstack *h , int size , long alignment , void *(*chunkfun)(size_t  ) ,
                    void (*freefun)(void * ) ) 
{ 
  struct _obstack_chunk *chunk ;
  int extra ;
  struct _obstack_chunk *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 66
  if (alignment == 0L) {
#line 67
    alignment = (char *)(& ((struct fooalign *)0)->d) - (char *)0;
  }
#line 68
  if (size == 0) {
#line 79
    extra = (int )(((((((12UL + sizeof(union fooround )) - 1UL) & ~ (sizeof(union fooround ) - 1UL)) + 4UL) + sizeof(union fooround )) - 1UL) & ~ (sizeof(union fooround ) - 1UL));
#line 82
    size = 4096 - extra;
  }
  {
#line 85
  h->chunkfun = (struct _obstack_chunk *(*)(long  ))chunkfun;
#line 86
  h->freefun = freefun;
#line 87
  h->chunk_size = (long )size;
#line 88
  h->alignment_mask = alignment - 1L;
#line 90
  tmp = (*(h->chunkfun))(h->chunk_size);
#line 90
  h->chunk = tmp;
#line 90
  chunk = tmp;
#line 91
  tmp___0 = chunk->contents;
#line 91
  h->object_base = tmp___0;
#line 91
  h->next_free = tmp___0;
#line 92
  tmp___1 = (char *)chunk + h->chunk_size;
#line 92
  chunk->limit = tmp___1;
#line 92
  h->chunk_limit = tmp___1;
#line 94
  chunk->prev = (struct _obstack_chunk *)0;
  }
#line 95
  return;
}
}
#line 103 "/home/khheo/project/mit-scheme-9.2/src/microcode/obstack.c"
void _obstack_newchunk(struct obstack *h , int length ) 
{ 
  struct _obstack_chunk *old_chunk ;
  struct _obstack_chunk *new_chunk ;
  long new_size ;
  int obj_size ;
  int i ;
  int already ;
  struct _obstack_chunk *tmp ;
  char *tmp___0 ;

  {
#line 106
  old_chunk = h->chunk;
#line 109
  obj_size = (int )(h->next_free - h->object_base);
#line 114
  new_size = (long )(((obj_size + length) + (obj_size >> 3)) + 100);
#line 115
  if (new_size < h->chunk_size) {
#line 116
    new_size = h->chunk_size;
  }
  {
#line 119
  tmp = (*(h->chunkfun))(new_size);
#line 119
  h->chunk = tmp;
#line 119
  new_chunk = tmp;
#line 120
  new_chunk->prev = old_chunk;
#line 121
  tmp___0 = (char *)new_chunk + new_size;
#line 121
  h->chunk_limit = tmp___0;
#line 121
  new_chunk->limit = tmp___0;
  }
#line 126
  if (h->alignment_mask + 1L >= (char *)(& ((struct fooalign *)0)->d) - (char *)0) {
#line 128
    i = (int )((unsigned long )obj_size / sizeof(int ) - 1UL);
    {
#line 128
    while (1) {
      while_continue: /* CIL Label */ ;
#line 128
      if (! (i >= 0)) {
#line 128
        goto while_break;
      }
#line 130
      *((int *)(new_chunk->contents) + i) = *((int *)h->object_base + i);
#line 128
      i --;
    }
    while_break: /* CIL Label */ ;
    }
#line 135
    already = (int )(((unsigned long )obj_size / sizeof(int )) * sizeof(int ));
  } else {
#line 138
    already = 0;
  }
#line 140
  i = already;
  {
#line 140
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 140
    if (! (i < obj_size)) {
#line 140
      goto while_break___0;
    }
#line 141
    new_chunk->contents[i] = *(h->object_base + i);
#line 140
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 145
  if ((unsigned long )h->object_base == (unsigned long )(old_chunk->contents)) {
    {
#line 147
    new_chunk->prev = old_chunk->prev;
#line 148
    (*(h->freefun))((void *)old_chunk);
    }
  }
#line 151
  h->object_base = new_chunk->contents;
#line 152
  h->next_free = h->object_base + obj_size;
#line 153
  return;
}
}
#line 159 "/home/khheo/project/mit-scheme-9.2/src/microcode/obstack.c"
int _obstack_allocated_p(struct obstack *h , void *obj ) 
{ 
  struct _obstack_chunk *lp ;
  struct _obstack_chunk *plp ;

  {
#line 165
  lp = h->chunk;
  {
#line 166
  while (1) {
    while_continue: /* CIL Label */ ;
#line 166
    if ((unsigned long )lp != (unsigned long )((struct _obstack_chunk *)0)) {
#line 166
      if (! ((unsigned long )((void *)lp) > (unsigned long )obj)) {
#line 166
        if (! ((unsigned long )((void *)lp->limit) < (unsigned long )obj)) {
#line 166
          goto while_break;
        }
      }
    } else {
#line 166
      goto while_break;
    }
#line 168
    plp = lp->prev;
#line 169
    lp = plp;
  }
  while_break: /* CIL Label */ ;
  }
#line 171
  return ((unsigned long )lp != (unsigned long )((struct _obstack_chunk *)0));
}
}
#line 179 "/home/khheo/project/mit-scheme-9.2/src/microcode/obstack.c"
void obstack_free(struct obstack *h , void *obj ) 
{ 
  struct _obstack_chunk *lp ;
  struct _obstack_chunk *plp ;
  char *tmp ;

  {
#line 185
  lp = h->chunk;
  {
#line 189
  while (1) {
    while_continue: /* CIL Label */ ;
#line 189
    if ((unsigned long )lp != (unsigned long )((struct _obstack_chunk *)0)) {
#line 189
      if (! ((unsigned long )((void *)lp) >= (unsigned long )obj)) {
#line 189
        if (! ((unsigned long )((void *)lp->limit) < (unsigned long )obj)) {
#line 189
          goto while_break;
        }
      }
    } else {
#line 189
      goto while_break;
    }
    {
#line 191
    plp = lp->prev;
#line 192
    (*(h->freefun))((void *)lp);
#line 193
    lp = plp;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 195
  if (lp) {
#line 197
    tmp = (char *)obj;
#line 197
    h->next_free = tmp;
#line 197
    h->object_base = tmp;
#line 198
    h->chunk_limit = lp->limit;
#line 199
    h->chunk = lp;
  } else
#line 201
  if ((unsigned long )obj != (unsigned long )((void *)0)) {
    {
#line 203
    abort();
    }
  }
#line 204
  return;
}
}
#line 208 "/home/khheo/project/mit-scheme-9.2/src/microcode/obstack.c"
void _obstack_free(struct obstack *h , void *obj ) 
{ 


  {
  {
#line 211
  obstack_free(h, obj);
  }
#line 212
  return;
}
}
#line 50 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 87 "/home/khheo/project/mit-scheme-9.2/src/microcode/memmag.h"
_Bool allocations_ok_p(unsigned long n_constant , unsigned long n_heap , unsigned long n_reserved ) ;
#line 88
void reset_allocator_parameters(unsigned long n_constant , unsigned long reserved ) ;
#line 89
_Bool object_in_heap_p(SCHEME_OBJECT object ) ;
#line 307 "/home/khheo/project/mit-scheme-9.2/src/microcode/extern.h"
unsigned long compute_extra_ephemeron_space(unsigned long n ) ;
#line 308
void guarantee_extra_ephemeron_space(unsigned long n ) ;
#line 323
void setup_memory(unsigned long heap_size , unsigned long stack_size , unsigned long constant_size ) ;
#line 189 "/home/khheo/project/mit-scheme-9.2/src/microcode/gccode.h"
void initialize_gc(unsigned long n_words , SCHEME_OBJECT **pf_start , SCHEME_OBJECT **pf_end ,
                   gc_tospace_allocator_t *allocator ,  __attribute__((__noreturn__)) gc_abort_handler_t *abort_handler ) ;
#line 201
void *tospace_to_newspace(void *addr ) ;
#line 203
_Bool save_tospace(gc_walk_proc_t *proc , void *ctx ) ;
#line 207
void update_weak_pointers(void) ;
#line 210
void gc_scan_oldspace(SCHEME_OBJECT *scan , SCHEME_OBJECT *end ) ;
#line 70 "/home/khheo/project/mit-scheme-9.2/src/microcode/memmag.c"
static unsigned long saved_heap_size  ;
#line 71 "/home/khheo/project/mit-scheme-9.2/src/microcode/memmag.c"
static unsigned long saved_constant_size  ;
#line 72 "/home/khheo/project/mit-scheme-9.2/src/microcode/memmag.c"
static unsigned long saved_stack_size  ;
#line 74
static void allocate_tospace(unsigned long n_words , SCHEME_OBJECT **start_r , SCHEME_OBJECT **end_r ) ;
#line 75
static  __attribute__((__noreturn__)) void abort_gc(void) ;
#line 76
static _Bool save_tospace_copy(SCHEME_OBJECT *start , SCHEME_OBJECT *end , void *p ) ;
#line 78
static unsigned long compute_ephemeron_array_length(unsigned long n ) ;
#line 109 "/home/khheo/project/mit-scheme-9.2/src/microcode/memmag.c"
void setup_memory(unsigned long heap_size , unsigned long stack_size , unsigned long constant_size ) 
{ 
  unsigned long _space ;
  SCHEME_OBJECT *_low ;
  void *tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 114
  while (1) {
    while_continue: /* CIL Label */ ;
#line 114
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 117
  if (heap_size == 0UL) {
    {
#line 119
    outf_fatal("Configuration won\'t hold initial data.\n");
#line 120
    outf_flush_fatal();
#line 121
    exit(1);
    }
  } else
#line 117
  if (stack_size == 0UL) {
    {
#line 119
    outf_fatal("Configuration won\'t hold initial data.\n");
#line 120
    outf_flush_fatal();
#line 121
    exit(1);
    }
  }
#line 125
  if ((stack_size + heap_size) + constant_size >= 288230376151711743UL) {
#line 126
    goto allocation_too_large;
  }
  {
#line 129
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 129
    _space = (stack_size + heap_size) + constant_size;
#line 129
    tmp = mmap_heap_malloc(sizeof(SCHEME_OBJECT ) * _space);
#line 129
    _low = (SCHEME_OBJECT *)tmp;
#line 129
    memory_block_start = _low;
#line 129
    memory_block_end = _low + _space;
    }
#line 129
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 134
  if ((unsigned long )memory_block_start == (unsigned long )((SCHEME_OBJECT *)0)) {
    {
#line 136
    outf_fatal("Not enough memory for this configuration.\n");
#line 137
    outf_flush_fatal();
#line 138
    exit(1);
    }
  }
#line 142
  if ((SCHEME_OBJECT )memory_block_end > 288230376151711743UL) {
    allocation_too_large: 
    {
#line 145
    outf_fatal("Requested allocation is too large.\n");
#line 146
    outf_fatal("Try again with a smaller argument to \'--heap\'.\n");
#line 147
    outf_flush_fatal();
#line 148
    reset_memory();
#line 149
    exit(1);
    }
  }
  {
#line 152
  saved_stack_size = stack_size;
#line 153
  saved_constant_size = constant_size;
#line 154
  saved_heap_size = heap_size;
#line 155
  reset_allocator_parameters(0UL, 0UL);
#line 156
  initialize_gc(heap_size, & heap_start, & Free, & allocate_tospace, & abort_gc);
  }
#line 157
  return;
}
}
#line 159 "/home/khheo/project/mit-scheme-9.2/src/microcode/memmag.c"
void reset_memory(void) 
{ 


  {
  {
#line 163
  while (1) {
    while_continue: /* CIL Label */ ;
#line 163
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 164
  return;
}
}
#line 166 "/home/khheo/project/mit-scheme-9.2/src/microcode/memmag.c"
_Bool allocations_ok_p(unsigned long n_constant , unsigned long n_heap , unsigned long n_reserved ) 
{ 
  unsigned long tmp ;

  {
#line 171
  if (n_reserved == 0UL) {
#line 171
    tmp = 4500UL;
  } else {
#line 171
    tmp = n_reserved;
  }
#line 171
  return ((_Bool )((unsigned long )(((((memory_block_start + saved_stack_size) + n_constant) + 128) + n_heap) + tmp) < (unsigned long )memory_block_end));
}
}
#line 179 "/home/khheo/project/mit-scheme-9.2/src/microcode/memmag.c"
void reset_allocator_parameters(unsigned long n_constant , unsigned long reserved ) 
{ 
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;
  SCHEME_OBJECT *tmp___2 ;
  SCHEME_OBJECT *tmp___3 ;
  SCHEME_OBJECT *tmp___4 ;

  {
#line 182
  if (reserved == 0UL) {
#line 182
    heap_reserved = 4500UL;
  } else {
#line 182
    heap_reserved = reserved;
  }
#line 183
  gc_space_needed = 0UL;
  {
#line 184
  while (1) {
    while_continue: /* CIL Label */ ;
#line 184
    stack_start = memory_block_start;
#line 184
    stack_end = stack_start + saved_stack_size;
#line 184
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 185
  constant_start = memory_block_start + saved_stack_size;
#line 186
  constant_alloc_next = constant_start;
#line 187
  constant_end = (constant_alloc_next + n_constant) + 128;
#line 188
  heap_start = constant_end;
#line 189
  Free = heap_start;
#line 190
  heap_end = memory_block_end;
  {
#line 192
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 192
    heap_alloc_limit = heap_end - heap_reserved;
    {
#line 192
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 192
      if ((Registers[1] & Registers[12]) != 0UL) {
#line 192
        tmp___0 = memory_block_start;
      } else {
#line 192
        if ((Registers[1] & 4UL) != 0UL) {
#line 192
          tmp = heap_alloc_limit;
        } else {
#line 192
          tmp = heap_end;
        }
#line 192
        tmp___0 = tmp;
      }
      {
#line 192
      set_ptr_register(0U, tmp___0);
      }
#line 192
      if ((Registers[1] & 1UL) != 0UL) {
#line 192
        tmp___1 = stack_guard;
      } else {
#line 192
        tmp___1 = stack_start;
      }
      {
#line 192
      set_ptr_register(11U, tmp___1);
      }
#line 192
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 192
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 193
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 193
    stack_pointer = stack_end;
#line 193
    *stack_start = (34UL << 58U) | (SCHEME_OBJECT )stack_start;
#line 193
    stack_guard = stack_start + 4096;
    {
#line 193
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 193
      if ((Registers[1] & Registers[12]) != 0UL) {
#line 193
        tmp___3 = memory_block_start;
      } else {
#line 193
        if ((Registers[1] & 4UL) != 0UL) {
#line 193
          tmp___2 = heap_alloc_limit;
        } else {
#line 193
          tmp___2 = heap_end;
        }
#line 193
        tmp___3 = tmp___2;
      }
      {
#line 193
      set_ptr_register(0U, tmp___3);
      }
#line 193
      if ((Registers[1] & 1UL) != 0UL) {
#line 193
        tmp___4 = stack_guard;
      } else {
#line 193
        tmp___4 = stack_start;
      }
      {
#line 193
      set_ptr_register(11U, tmp___4);
      }
#line 193
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 193
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 194
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 194
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 195
  return;
}
}
#line 197 "/home/khheo/project/mit-scheme-9.2/src/microcode/memmag.c"
static void allocate_tospace(unsigned long n_words , SCHEME_OBJECT **start_r , SCHEME_OBJECT **end_r ) 
{ 
  SCHEME_OBJECT *p ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  char *__cil_tmp8 ;

  {
#line 201
  if (n_words > 0UL) {
#line 203
    if ((unsigned long )*start_r == (unsigned long )((SCHEME_OBJECT *)0)) {
      {
#line 203
      tmp = malloc(n_words * 8UL);
#line 203
      tmp___1 = tmp;
      }
    } else {
      {
#line 203
      tmp___0 = realloc((void *)*start_r, n_words * 8UL);
#line 203
      tmp___1 = tmp___0;
      }
    }
#line 203
    p = (SCHEME_OBJECT *)tmp___1;
#line 207
    if ((unsigned long )p == (unsigned long )((SCHEME_OBJECT *)0)) {
      {
#line 209
      outf_fatal("Unable to allocate temporary heap for GC.\n");
#line 210
      outf_flush_fatal();
#line 211
      exit(1);
      }
    }
#line 213
    *start_r = p;
#line 214
    *end_r = p + n_words;
  } else
#line 216
  if ((unsigned long )*start_r != (unsigned long )((SCHEME_OBJECT *)0)) {
    {
#line 218
    free((void *)*start_r);
#line 219
    *start_r = (SCHEME_OBJECT *)0;
#line 220
    *end_r = (SCHEME_OBJECT *)0;
    }
  }
#line 222
  return;
}
}
#line 224
static  __attribute__((__noreturn__)) void abort_gc(void) ;
#line 224 "/home/khheo/project/mit-scheme-9.2/src/microcode/memmag.c"
static void abort_gc(void) 
{ 


  {
  {
#line 227
  Microcode_Termination(12);
  }
}
}
#line 230 "/home/khheo/project/mit-scheme-9.2/src/microcode/memmag.c"
_Bool object_in_heap_p(SCHEME_OBJECT object ) 
{ 
  SCHEME_OBJECT *address___0 ;
  SCHEME_OBJECT *tmp ;
  int tmp___0 ;

  {
  {
#line 233
  tmp = get_object_address(object);
#line 233
  address___0 = tmp;
  }
#line 234
  if ((unsigned long )address___0 != (unsigned long )((SCHEME_OBJECT *)0)) {
#line 234
    if ((unsigned long )address___0 >= (unsigned long )heap_start) {
#line 234
      if ((unsigned long )address___0 < (unsigned long )heap_end) {
#line 234
        tmp___0 = 1;
      } else {
#line 234
        tmp___0 = 0;
      }
    } else {
#line 234
      tmp___0 = 0;
    }
  } else {
#line 234
    tmp___0 = 0;
  }
#line 234
  return ((_Bool )tmp___0);
}
}
#line 237 "/home/khheo/project/mit-scheme-9.2/src/microcode/memmag.c"
SCHEME_OBJECT Prim_garbage_collect(void) 
{ 
  unsigned long tmp ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;
  SCHEME_OBJECT *tmp___2 ;
  long tmp___4 ;
  unsigned long tmp___5 ;
  long tmp___6 ;
  SCHEME_OBJECT daemon ;
  SCHEME_OBJECT *tmp___7 ;
  SCHEME_OBJECT *tmp___8 ;
  SCHEME_OBJECT *tmp___9 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
#line 245
  while (1) {
    while_continue: /* CIL Label */ ;
#line 245
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 246
  canonicalize_primitive_context();
  }
  {
#line 248
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 248
    if (*stack_start != ((34UL << 58U) | (SCHEME_OBJECT )stack_start)) {
      {
#line 248
      stack_death("GC");
      }
    }
#line 248
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 249
  if ((unsigned long )Free > (unsigned long )heap_end) {
    {
#line 251
    outf_fatal("\nGC has been delayed too long!\n");
#line 252
    outf_fatal("Free = %#lx; heap_alloc_limit = %#lx; heap_end = %#lx\n", (unsigned long )Free,
               (unsigned long )heap_alloc_limit, (unsigned long )heap_end);
#line 257
    Microcode_Termination(21);
    }
  }
  {
#line 260
  tmp = arg_ulong_index_integer(1, (unsigned long )((heap_end - heap_start) / 2L));
  }
#line 260
  if (tmp < (unsigned long )(heap_end - heap_start)) {
    {
#line 262
    heap_reserved = arg_ulong_index_integer(1, (unsigned long )((heap_end - heap_start) / 2L));
#line 263
    heap_alloc_limit = heap_end - heap_reserved;
    }
  }
  {
#line 265
  stack_pointer ++;
#line 267
  critical_section_name = "garbage collector";
#line 273
  open_tospace(heap_start);
#line 274
  initialize_weak_chain();
#line 275
  ephemeron_count = 0UL;
#line 277
  std_gc_pt1();
#line 278
  std_gc_pt2();
  }
  {
#line 280
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 280
    if (! ((unsigned long )(stack_pointer + -2) >= (unsigned long )stack_guard)) {
      {
#line 280
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 280
        if (*stack_start != ((34UL << 58U) | (SCHEME_OBJECT )stack_start)) {
          {
#line 280
          stack_death("STACK_CHECK");
          }
        }
#line 280
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 280
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 280
        set_ulong_register(12U, Registers[12] | 1UL);
        }
        {
#line 280
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 280
          if ((Registers[1] & Registers[12]) != 0UL) {
#line 280
            tmp___1 = memory_block_start;
          } else {
#line 280
            if ((Registers[1] & 4UL) != 0UL) {
#line 280
              tmp___0 = heap_alloc_limit;
            } else {
#line 280
              tmp___0 = heap_end;
            }
#line 280
            tmp___1 = tmp___0;
          }
          {
#line 280
          set_ptr_register(0U, tmp___1);
          }
#line 280
          if ((Registers[1] & 1UL) != 0UL) {
#line 280
            tmp___2 = stack_guard;
          } else {
#line 280
            tmp___2 = stack_start;
          }
          {
#line 280
          set_ptr_register(11U, tmp___2);
          }
#line 280
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 280
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 280
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 281
  Registers[6] = (11UL << 58U) | 32UL;
#line 282
  if ((unsigned long )Free >= (unsigned long )heap_start) {
#line 282
    if ((unsigned long )Free < (unsigned long )heap_alloc_limit) {
#line 282
      tmp___6 = heap_alloc_limit - Free;
    } else {
#line 282
      tmp___6 = 0L;
    }
  } else {
#line 282
    tmp___6 = 0L;
  }
#line 282
  if ((unsigned long )tmp___6 > gc_space_needed) {
#line 282
    if ((unsigned long )Free >= (unsigned long )heap_start) {
#line 282
      if ((unsigned long )Free < (unsigned long )heap_alloc_limit) {
#line 282
        tmp___4 = heap_alloc_limit - Free;
      } else {
#line 282
        tmp___4 = 0L;
      }
    } else {
#line 282
      tmp___4 = 0L;
    }
#line 282
    tmp___5 = (unsigned long )tmp___4 - gc_space_needed;
  } else {
#line 282
    tmp___5 = 0UL;
  }
#line 282
  Registers[5] = (26UL << 58U) | tmp___5;
  {
#line 285
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 285
    stack_pointer --;
#line 285
    *stack_pointer = Registers[5];
#line 285
    stack_pointer --;
#line 285
    *stack_pointer = Registers[6];
#line 285
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 288
  critical_section_name = "garbage collector daemon";
#line 290
  daemon = *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 12);
#line 291
  if (daemon == 0UL) {
    {
#line 292
    abort_to_interpreter(-7);
    }
  }
  {
#line 294
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 294
    if (! ((unsigned long )(stack_pointer + -2) >= (unsigned long )stack_guard)) {
      {
#line 294
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 294
        if (*stack_start != ((34UL << 58U) | (SCHEME_OBJECT )stack_start)) {
          {
#line 294
          stack_death("STACK_CHECK");
          }
        }
#line 294
        goto while_break___7;
      }
      while_break___7: /* CIL Label */ ;
      }
      {
#line 294
      while (1) {
        while_continue___8: /* CIL Label */ ;
        {
#line 294
        set_ulong_register(12U, Registers[12] | 1UL);
        }
        {
#line 294
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 294
          if ((Registers[1] & Registers[12]) != 0UL) {
#line 294
            tmp___8 = memory_block_start;
          } else {
#line 294
            if ((Registers[1] & 4UL) != 0UL) {
#line 294
              tmp___7 = heap_alloc_limit;
            } else {
#line 294
              tmp___7 = heap_end;
            }
#line 294
            tmp___8 = tmp___7;
          }
          {
#line 294
          set_ptr_register(0U, tmp___8);
          }
#line 294
          if ((Registers[1] & 1UL) != 0UL) {
#line 294
            tmp___9 = stack_guard;
          } else {
#line 294
            tmp___9 = stack_start;
          }
          {
#line 294
          set_ptr_register(11U, tmp___9);
          }
#line 294
          goto while_break___9;
        }
        while_break___9: /* CIL Label */ ;
        }
#line 294
        goto while_break___8;
      }
      while_break___8: /* CIL Label */ ;
      }
    }
#line 294
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 295
  stack_pointer --;
#line 295
  *stack_pointer = daemon;
#line 296
  stack_pointer --;
#line 296
  *stack_pointer = 1UL;
#line 298
  abort_to_interpreter(-3);
  }
#line 301
  return ((8UL << 58U) | 1UL);
}
}
#line 304 "/home/khheo/project/mit-scheme-9.2/src/microcode/memmag.c"
static SCHEME_OBJECT *saved_to  ;
#line 306 "/home/khheo/project/mit-scheme-9.2/src/microcode/memmag.c"
void std_gc_pt1(void) 
{ 


  {
  {
#line 313
  saved_to = get_newspace_ptr();
#line 314
  add_to_tospace(fixed_objects);
#line 315
  add_to_tospace((32UL << 58U) | (SCHEME_OBJECT )history_register);
#line 318
  current_gc_table = std_gc_table();
#line 319
  gc_scan_oldspace(stack_pointer, stack_end);
#line 320
  gc_scan_oldspace(constant_start, constant_alloc_next);
#line 321
  gc_scan_tospace(saved_to, (SCHEME_OBJECT *)0);
#line 326
  update_weak_pointers();
  }
#line 327
  return;
}
}
#line 329 "/home/khheo/project/mit-scheme-9.2/src/microcode/memmag.c"
void std_gc_pt2(void) 
{ 
  SCHEME_OBJECT *p ;
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;
  unsigned long length ;
  unsigned long tmp___2 ;
  SCHEME_OBJECT *tmp___3 ;
  SCHEME_OBJECT *tmp___4 ;
  SCHEME_OBJECT *tmp___5 ;

  {
  {
#line 332
  tmp = get_newspace_ptr();
#line 332
  p = tmp;
#line 333
  save_tospace(& save_tospace_copy, (void *)0);
#line 334
  Free = p;
#line 336
  tmp___0 = saved_to;
#line 336
  saved_to ++;
#line 336
  fixed_objects = *tmp___0;
#line 337
  tmp___1 = saved_to;
#line 337
  saved_to ++;
#line 337
  history_register = (SCHEME_OBJECT *)(*tmp___1 & 288230376151711743UL);
#line 338
  saved_to = (SCHEME_OBJECT *)0;
#line 341
  tmp___2 = compute_ephemeron_array_length(ephemeron_count + n_ephemerons_requested);
#line 341
  length = tmp___2;
  }
#line 344
  if ((unsigned long )Free >= (unsigned long )heap_start) {
#line 344
    if ((unsigned long )Free < (unsigned long )heap_alloc_limit) {
#line 344
      if (! ((unsigned long )(Free + ((1UL + length) + n_ephemerons_requested * 5UL)) <= (unsigned long )heap_alloc_limit)) {
#line 344
        goto _L___0;
      }
    } else {
#line 344
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 347
    if (ephemeron_request_hard_p) {
#line 348
      gc_space_needed += 1UL + length;
    }
    {
#line 349
    length = compute_ephemeron_array_length(ephemeron_count);
    }
  }
  {
#line 358
  ephemeron_array = make_vector(length, 0UL, (_Bool)0);
#line 359
  n_ephemerons_requested = 0UL;
#line 360
  ephemeron_request_hard_p = (_Bool)0;
  }
  {
#line 363
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 363
    set_ptr_register(9U, (SCHEME_OBJECT *)0);
#line 363
    set_ptr_register(10U, (SCHEME_OBJECT *)0);
    }
    {
#line 363
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 363
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 363
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 364
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 364
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 364
      set_ulong_register(12U, Registers[12] & 0xfffffffffffffffbUL);
      }
      {
#line 364
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 364
        if ((Registers[1] & Registers[12]) != 0UL) {
#line 364
          tmp___4 = memory_block_start;
        } else {
#line 364
          if ((Registers[1] & 4UL) != 0UL) {
#line 364
            tmp___3 = heap_alloc_limit;
          } else {
#line 364
            tmp___3 = heap_end;
          }
#line 364
          tmp___4 = tmp___3;
        }
        {
#line 364
        set_ptr_register(0U, tmp___4);
        }
#line 364
        if ((Registers[1] & 1UL) != 0UL) {
#line 364
          tmp___5 = stack_guard;
        } else {
#line 364
          tmp___5 = stack_start;
        }
        {
#line 364
        set_ptr_register(11U, tmp___5);
        }
#line 364
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 364
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 364
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 365
  return;
}
}
#line 367 "/home/khheo/project/mit-scheme-9.2/src/microcode/memmag.c"
static _Bool save_tospace_copy(SCHEME_OBJECT *start , SCHEME_OBJECT *end , void *p ) 
{ 
  void *tmp ;

  {
  {
#line 370
  tmp = tospace_to_newspace((void *)start);
#line 370
  memmove(tmp, (void const   *)start, (size_t )((end - start) * 8L));
  }
#line 373
  return ((_Bool)1);
}
}
#line 376
 __attribute__((__noreturn__)) void stack_death(char const   *name ) ;
#line 376 "/home/khheo/project/mit-scheme-9.2/src/microcode/memmag.c"
void stack_death(char const   *name ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
  {
#line 379
  outf_fatal("\n%s: The stack has overflowed and overwritten adjacent memory.\n",
             name);
#line 382
  outf_fatal("This was probably caused by a runaway recursion.\n");
#line 383
  Microcode_Termination(7);
  }
}
}
#line 387 "/home/khheo/project/mit-scheme-9.2/src/microcode/memmag.c"
SCHEME_OBJECT Prim_gc_trace_references(void) 
{ 
  SCHEME_OBJECT collector ;

  {
  {
#line 389
  while (1) {
    while_continue: /* CIL Label */ ;
#line 389
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 391
  collector = *(stack_pointer + 1);
#line 392
  if (! (collector == 0UL)) {
#line 392
    if (collector >> 58U == 10UL) {
#line 392
      if (! ((*((SCHEME_OBJECT *)(collector & 288230376151711743UL) + 0) & 288230376151711743UL) >= 1UL)) {
        {
#line 395
        error_wrong_type_arg(2);
        }
      }
    } else {
      {
#line 395
      error_wrong_type_arg(2);
      }
    }
  }
  {
#line 399
  error_external_return();
  }
#line 402
  return ((8UL << 58U) | 1UL);
}
}
#line 405 "/home/khheo/project/mit-scheme-9.2/src/microcode/memmag.c"
static unsigned long primes[28]  = 
#line 405
  {      11UL,      23UL,      53UL,      97UL, 
        193UL,      389UL,      769UL,      1543UL, 
        3079UL,      6151UL,      12289UL,      24593UL, 
        49157UL,      98317UL,      196613UL,      393241UL, 
        786433UL,      1572869UL,      3145739UL,      6291469UL, 
        12582917UL,      25165843UL,      50331653UL,      100663319UL, 
        201326611UL,      402653189UL,      805306457UL,      1610612741UL};
#line 416 "/home/khheo/project/mit-scheme-9.2/src/microcode/memmag.c"
static unsigned long compute_ephemeron_array_length(unsigned long n ) 
{ 
  unsigned int start ;
  unsigned int end ;
  unsigned int index___0 ;

  {
#line 419
  start = 0U;
#line 419
  end = (unsigned int )(sizeof(primes) / sizeof(primes[0]));
#line 422
  if (primes[end - 1U] < n) {
#line 423
    return (primes[end - 1U]);
  }
  {
#line 425
  while (1) {
    while_continue: /* CIL Label */ ;
#line 426
    index___0 = start + (end - start) / 2U;
#line 427
    if (primes[index___0] < n) {
#line 428
      start = index___0 + 1U;
    } else
#line 429
    if (n < primes[index___0]) {
#line 430
      end = index___0;
    } else {
#line 432
      return (primes[index___0]);
    }
#line 425
    if (! (start < end)) {
#line 425
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 435
  return (primes[start]);
}
}
#line 438 "/home/khheo/project/mit-scheme-9.2/src/microcode/memmag.c"
static _Bool ephemeron_array_big_enough_p(unsigned long n ) 
{ 
  int tmp ;

  {
#line 441
  if (n == 0UL) {
#line 441
    tmp = 1;
  } else
#line 441
  if (ephemeron_array >> 58U == 10UL) {
#line 441
    if (n <= (*((SCHEME_OBJECT *)(ephemeron_array & 288230376151711743UL) + 0) & 288230376151711743UL)) {
#line 441
      tmp = 1;
    } else {
#line 441
      tmp = 0;
    }
  } else {
#line 441
    tmp = 0;
  }
#line 441
  return ((_Bool )tmp);
}
}
#line 447 "/home/khheo/project/mit-scheme-9.2/src/microcode/memmag.c"
unsigned long compute_extra_ephemeron_space(unsigned long n ) 
{ 
  unsigned long tmp ;
  _Bool tmp___0 ;

  {
  {
#line 450
  tmp___0 = ephemeron_array_big_enough_p(n);
  }
#line 450
  if (tmp___0) {
#line 451
    return (0UL);
  } else {
    {
#line 453
    tmp = compute_ephemeron_array_length(n);
    }
#line 453
    return (1UL + tmp);
  }
}
}
#line 456 "/home/khheo/project/mit-scheme-9.2/src/microcode/memmag.c"
void guarantee_extra_ephemeron_space(unsigned long n ) 
{ 
  unsigned long length ;
  unsigned long tmp ;
  _Bool tmp___0 ;

  {
  {
#line 459
  ephemeron_count = n;
#line 460
  tmp___0 = ephemeron_array_big_enough_p(n);
  }
#line 460
  if (! tmp___0) {
    {
#line 462
    tmp = compute_ephemeron_array_length(n);
#line 462
    length = tmp;
#line 464
    ephemeron_array = make_vector(length, 0UL, (_Bool)0);
    }
  }
#line 466
  return;
}
}
#line 468 "/home/khheo/project/mit-scheme-9.2/src/microcode/memmag.c"
static void gc_if_needed_for_ephemeron(unsigned long extra_space ) 
{ 
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 471
  if ((unsigned long )Free >= (unsigned long )heap_start) {
#line 471
    if ((unsigned long )Free < (unsigned long )heap_alloc_limit) {
#line 471
      if (! ((unsigned long )(Free + (5UL + extra_space)) <= (unsigned long )heap_alloc_limit)) {
#line 471
        goto _L___0;
      }
    } else {
#line 471
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 471
  if ((Registers[1] & 4UL) != 0UL) {
#line 473
    n_ephemerons_requested = 1UL;
#line 474
    ephemeron_request_hard_p = (_Bool)1;
    {
#line 475
    while (1) {
      while_continue: /* CIL Label */ ;
#line 475
      if ((unsigned long )Free_primitive < (unsigned long )heap_start) {
        {
#line 475
        outf_fatal("\nMicrocode requested primitive GC outside primitive!\n");
#line 475
        Microcode_Termination(12);
        }
      }
#line 475
      if ((unsigned long )Free < (unsigned long )Free_primitive) {
        {
#line 475
        outf_fatal("\nFree has gone backwards!\n");
#line 475
        Microcode_Termination(12);
        }
      }
      {
#line 475
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 475
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 475
          set_ulong_register(12U, Registers[12] | 4UL);
          }
          {
#line 475
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 475
            if ((Registers[1] & Registers[12]) != 0UL) {
#line 475
              tmp___0 = memory_block_start;
            } else {
#line 475
              if ((Registers[1] & 4UL) != 0UL) {
#line 475
                tmp = heap_alloc_limit;
              } else {
#line 475
                tmp = heap_end;
              }
#line 475
              tmp___0 = tmp;
            }
            {
#line 475
            set_ptr_register(0U, tmp___0);
            }
#line 475
            if ((Registers[1] & 1UL) != 0UL) {
#line 475
              tmp___1 = stack_guard;
            } else {
#line 475
              tmp___1 = stack_start;
            }
            {
#line 475
            set_ptr_register(11U, tmp___1);
            }
#line 475
            goto while_break___2;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 475
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 475
        gc_space_needed = (unsigned long )(5L + (Free - Free_primitive));
#line 475
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 475
      signal_interrupt_from_primitive();
      }
#line 475
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 477
  return;
}
}
#line 479 "/home/khheo/project/mit-scheme-9.2/src/microcode/memmag.c"
SCHEME_OBJECT Prim_make_ephemeron(void) 
{ 
  unsigned long length ;
  unsigned long tmp ;
  _Bool tmp___0 ;
  SCHEME_OBJECT *addr ;
  SCHEME_OBJECT *tmp___1 ;
  SCHEME_OBJECT *tmp___2 ;
  SCHEME_OBJECT *tmp___3 ;
  SCHEME_OBJECT *tmp___4 ;
  SCHEME_OBJECT *tmp___5 ;

  {
  {
#line 481
  while (1) {
    while_continue: /* CIL Label */ ;
#line 481
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 482
  ephemeron_count ++;
#line 483
  tmp___0 = ephemeron_array_big_enough_p(ephemeron_count);
  }
#line 483
  if (tmp___0) {
    {
#line 484
    gc_if_needed_for_ephemeron(0UL);
    }
  } else {
    {
#line 487
    tmp = compute_ephemeron_array_length(ephemeron_count);
#line 487
    length = tmp;
#line 489
    gc_if_needed_for_ephemeron(1UL + length);
#line 490
    ephemeron_array = make_vector(length, 0UL, (_Bool)0);
    }
  }
#line 493
  addr = Free;
#line 494
  tmp___1 = Free;
#line 494
  Free ++;
#line 494
  *tmp___1 = 4UL;
#line 495
  tmp___2 = Free;
#line 495
  Free ++;
#line 495
  *tmp___2 = *(stack_pointer + 0);
#line 496
  tmp___3 = Free;
#line 496
  Free ++;
#line 496
  *tmp___3 = *(stack_pointer + 1);
#line 497
  tmp___4 = Free;
#line 497
  Free ++;
#line 497
  *tmp___4 = 0UL;
#line 498
  tmp___5 = Free;
#line 498
  Free ++;
#line 498
  *tmp___5 = 0UL;
#line 500
  return ((43UL << 58U) | (SCHEME_OBJECT )addr);
}
}
#line 305 "/home/khheo/project/mit-scheme-9.2/src/microcode/extern.h"
void strengthen_symbol(SCHEME_OBJECT symbol ) ;
#line 306
void weaken_symbol(SCHEME_OBJECT symbol ) ;
#line 40 "/home/khheo/project/mit-scheme-9.2/src/microcode/lookup.h"
long variable_unbound_p(SCHEME_OBJECT environment , SCHEME_OBJECT symbol , SCHEME_OBJECT *value_ret ) ;
#line 42
long variable_unreferenceable_p(SCHEME_OBJECT environment , SCHEME_OBJECT symbol ,
                                SCHEME_OBJECT *value_ret ) ;
#line 46
long define_variable(SCHEME_OBJECT environment , SCHEME_OBJECT symbol , SCHEME_OBJECT value ) ;
#line 48
long link_variables(SCHEME_OBJECT target_environment , SCHEME_OBJECT target_symbol ,
                    SCHEME_OBJECT source_environment , SCHEME_OBJECT source_symbol ) ;
#line 50
long unbind_variable(SCHEME_OBJECT environment , SCHEME_OBJECT symbol , SCHEME_OBJECT *value_ret ) ;
#line 53
trap_kind_t get_trap_kind(SCHEME_OBJECT object ) ;
#line 134 "/home/khheo/project/mit-scheme-9.2/src/microcode/lookup.c"
static long lookup_variable_cache(SCHEME_OBJECT cache , SCHEME_OBJECT *value_ret ) ;
#line 136
static long assign_variable_end(SCHEME_OBJECT *cell , SCHEME_OBJECT value , SCHEME_OBJECT *value_ret ,
                                int force_p ) ;
#line 138
static long assign_variable_cache(SCHEME_OBJECT cache , SCHEME_OBJECT value , SCHEME_OBJECT *value_ret ,
                                  int force_p ) ;
#line 140
static long guarantee_extension_space(SCHEME_OBJECT environment ) ;
#line 142
static long allocate_frame_extension(unsigned long length , SCHEME_OBJECT procedure ,
                                     SCHEME_OBJECT *extension_ret ) ;
#line 144
static long unbind_cached_variable(SCHEME_OBJECT *cell , SCHEME_OBJECT frame , SCHEME_OBJECT symbol ) ;
#line 146
static void unbind_variable_1(SCHEME_OBJECT *cell , SCHEME_OBJECT frame , SCHEME_OBJECT symbol ) ;
#line 148
static unsigned long update_cache_refs_space(SCHEME_OBJECT from_cache , SCHEME_OBJECT environment ,
                                             SCHEME_OBJECT symbol ) ;
#line 150
static unsigned long update_cache_refs_space_1(SCHEME_OBJECT from_cache , unsigned int kind ,
                                               SCHEME_OBJECT environment , SCHEME_OBJECT symbol ) ;
#line 152
static long update_cache_references(SCHEME_OBJECT from_cache , SCHEME_OBJECT *to_cell ,
                                    SCHEME_OBJECT environment , SCHEME_OBJECT symbol ) ;
#line 154
static SCHEME_OBJECT *find_binding_cell(SCHEME_OBJECT environment , SCHEME_OBJECT symbol ,
                                        SCHEME_OBJECT *frame_ret ) ;
#line 156
static SCHEME_OBJECT *scan_frame(SCHEME_OBJECT frame , SCHEME_OBJECT symbol , int find_unbound_p ) ;
#line 158
static SCHEME_OBJECT *scan_procedure_bindings(SCHEME_OBJECT procedure , SCHEME_OBJECT frame ,
                                              SCHEME_OBJECT symbol , int find_unbound_p ) ;
#line 160
static unsigned long count_references(SCHEME_OBJECT *palist ) ;
#line 162
static void update_assignment_references(SCHEME_OBJECT cache ) ;
#line 164
static long guarantee_cache(SCHEME_OBJECT *cell ) ;
#line 166
static void update_clone(SCHEME_OBJECT cache ) ;
#line 168
static long make_cache(SCHEME_OBJECT value , SCHEME_OBJECT clone , SCHEME_OBJECT references ,
                       SCHEME_OBJECT *cache_ret ) ;
#line 173
static long update_uuo_links(SCHEME_OBJECT cache , SCHEME_OBJECT new_value ) ;
#line 175
static void move_all_references(SCHEME_OBJECT from_cache , SCHEME_OBJECT to_cache ,
                                unsigned int reference_kind ) ;
#line 177
static long add_cache_reference(SCHEME_OBJECT environment , SCHEME_OBJECT symbol ,
                                SCHEME_OBJECT block , unsigned long offset , unsigned int reference_kind ) ;
#line 179
static void add_reference(SCHEME_OBJECT *palist , SCHEME_OBJECT symbol , SCHEME_OBJECT block ,
                          unsigned long offset ) ;
#line 181
static void install_cache(SCHEME_OBJECT cache , SCHEME_OBJECT block , unsigned long offset ,
                          unsigned int reference_kind ) ;
#line 183
static void install_operator_cache(SCHEME_OBJECT cache , SCHEME_OBJECT block , unsigned long offset ) ;
#line 185
static unsigned long ref_pairs_to_move(SCHEME_OBJECT *palist , SCHEME_OBJECT environment ,
                                       SCHEME_OBJECT symbol ) ;
#line 187
static void delete_ref_pairs(SCHEME_OBJECT from_cache , unsigned int kind , SCHEME_OBJECT environment ,
                             SCHEME_OBJECT symbol ) ;
#line 189
static void move_ref_pairs(SCHEME_OBJECT from_cache , SCHEME_OBJECT to_cache , unsigned int reference_kind ,
                           SCHEME_OBJECT environment , SCHEME_OBJECT symbol ) ;
#line 191
static SCHEME_OBJECT *new_alist_entry(SCHEME_OBJECT *to_palist , SCHEME_OBJECT symbol ) ;
#line 193
static int move_ref_pair_p(SCHEME_OBJECT ref_pair , SCHEME_OBJECT ancestor ) ;
#line 195
static SCHEME_OBJECT *find_references_named(SCHEME_OBJECT *palist , SCHEME_OBJECT symbol ) ;
#line 197
static long make_cache_reference(SCHEME_OBJECT block , unsigned long offset , SCHEME_OBJECT *ref_ret ) ;
#line 204 "/home/khheo/project/mit-scheme-9.2/src/microcode/lookup.c"
long lookup_variable(SCHEME_OBJECT environment , SCHEME_OBJECT symbol , SCHEME_OBJECT *value_ret ) 
{ 
  SCHEME_OBJECT *cell ;
  SCHEME_OBJECT value ;
  trap_kind_t tmp ;
  long tmp___0 ;

  {
#line 211
  if (environment >> 58U == 18UL) {
#line 211
    goto _L;
  } else
#line 211
  if (environment == 0UL) {
    _L: /* CIL Label */ 
#line 211
    if (! (symbol >> 58U == 29UL)) {
#line 211
      if (! (symbol >> 58U == 5UL)) {
#line 212
        return (6L);
      }
    }
  } else {
#line 212
    return (6L);
  }
  {
#line 214
  cell = find_binding_cell(environment, symbol, (SCHEME_OBJECT *)0);
  }
#line 215
  if ((unsigned long )cell == (unsigned long )((SCHEME_OBJECT *)0)) {
#line 216
    return (1L);
  }
  {
#line 218
  value = *cell;
#line 219
  tmp = get_trap_kind(value);
  }
  {
#line 221
  if (tmp == 32UL) {
#line 221
    goto case_32;
  }
#line 225
  if (tmp == 0UL) {
#line 225
    goto case_0;
  }
#line 228
  if (tmp == 2UL) {
#line 228
    goto case_2;
  }
#line 231
  if (tmp == 15UL) {
#line 231
    goto case_15;
  }
#line 235
  if (tmp == 14UL) {
#line 235
    goto case_14;
  }
#line 238
  goto switch_default;
  case_32: /* CIL Label */ 
#line 222
  *value_ret = value;
#line 223
  return (-1L);
  case_0: /* CIL Label */ 
#line 226
  return (2L);
  case_2: /* CIL Label */ 
#line 229
  return (1L);
  case_15: /* CIL Label */ 
#line 232
  *value_ret = value;
#line 233
  return (19L);
  case_14: /* CIL Label */ 
  {
#line 236
  tmp___0 = lookup_variable_cache(*((SCHEME_OBJECT *)(value & 288230376151711743UL) + 1),
                                  value_ret);
  }
#line 236
  return (tmp___0);
  switch_default: /* CIL Label */ 
#line 239
  return (52L);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 243 "/home/khheo/project/mit-scheme-9.2/src/microcode/lookup.c"
static long lookup_variable_cache(SCHEME_OBJECT cache , SCHEME_OBJECT *value_ret ) 
{ 
  SCHEME_OBJECT value ;
  trap_kind_t tmp ;

  {
  {
#line 246
  value = *((SCHEME_OBJECT *)(cache & 288230376151711743UL) + 0);
#line 247
  tmp = get_trap_kind(value);
  }
  {
#line 249
  if (tmp == 32UL) {
#line 249
    goto case_32;
  }
#line 253
  if (tmp == 0UL) {
#line 253
    goto case_0;
  }
#line 256
  if (tmp == 2UL) {
#line 256
    goto case_2;
  }
#line 259
  if (tmp == 15UL) {
#line 259
    goto case_15;
  }
#line 263
  goto switch_default;
  case_32: /* CIL Label */ 
#line 250
  *value_ret = value;
#line 251
  return (-1L);
  case_0: /* CIL Label */ 
#line 254
  return (2L);
  case_2: /* CIL Label */ 
#line 257
  return (1L);
  case_15: /* CIL Label */ 
#line 260
  *value_ret = value;
#line 261
  return (19L);
  switch_default: /* CIL Label */ 
#line 264
  return (52L);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 268 "/home/khheo/project/mit-scheme-9.2/src/microcode/lookup.c"
long safe_lookup_variable(SCHEME_OBJECT environment , SCHEME_OBJECT symbol , SCHEME_OBJECT *value_ret ) 
{ 
  long result ;
  long tmp ;

  {
  {
#line 272
  tmp = lookup_variable(environment, symbol, value_ret);
#line 272
  result = tmp;
  }
#line 273
  if (result == 2L) {
#line 275
    *value_ret = *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 1);
#line 276
    return (-1L);
  }
#line 278
  return (result);
}
}
#line 281 "/home/khheo/project/mit-scheme-9.2/src/microcode/lookup.c"
long variable_unassigned_p(SCHEME_OBJECT environment , SCHEME_OBJECT symbol , SCHEME_OBJECT *value_ret ) 
{ 
  SCHEME_OBJECT dummy_value ;
  long result ;
  long tmp ;

  {
  {
#line 286
  tmp = lookup_variable(environment, symbol, & dummy_value);
#line 286
  result = tmp;
  }
  {
#line 289
  if (result == 2L) {
#line 289
    goto case_2;
  }
#line 293
  if (result == -1L) {
#line 293
    goto case_neg_1;
  }
#line 297
  goto switch_default;
  case_2: /* CIL Label */ 
#line 290
  *value_ret = 8UL << 58U;
#line 291
  return (-1L);
  case_neg_1: /* CIL Label */ 
#line 294
  *value_ret = 0UL;
#line 295
  return (-1L);
  switch_default: /* CIL Label */ 
#line 298
  return (result);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 302 "/home/khheo/project/mit-scheme-9.2/src/microcode/lookup.c"
long variable_unbound_p(SCHEME_OBJECT environment , SCHEME_OBJECT symbol , SCHEME_OBJECT *value_ret ) 
{ 
  SCHEME_OBJECT dummy_value ;
  long result ;
  long tmp ;

  {
  {
#line 307
  tmp = lookup_variable(environment, symbol, & dummy_value);
#line 307
  result = tmp;
  }
  {
#line 310
  if (result == 1L) {
#line 310
    goto case_1;
  }
#line 316
  if (result == -1L) {
#line 316
    goto case_neg_1;
  }
#line 316
  if (result == 19L) {
#line 316
    goto case_neg_1;
  }
#line 316
  if (result == 2L) {
#line 316
    goto case_neg_1;
  }
#line 320
  goto switch_default;
  case_1: /* CIL Label */ 
#line 311
  *value_ret = 8UL << 58U;
#line 312
  return (-1L);
  case_neg_1: /* CIL Label */ 
  case_19: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 317
  *value_ret = 0UL;
#line 318
  return (-1L);
  switch_default: /* CIL Label */ 
#line 321
  return (result);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 325 "/home/khheo/project/mit-scheme-9.2/src/microcode/lookup.c"
long variable_unreferenceable_p(SCHEME_OBJECT environment , SCHEME_OBJECT symbol ,
                                SCHEME_OBJECT *value_ret ) 
{ 
  SCHEME_OBJECT dummy_value ;
  long result ;
  long tmp ;

  {
  {
#line 330
  tmp = lookup_variable(environment, symbol, & dummy_value);
#line 330
  result = tmp;
  }
  {
#line 335
  if (result == 19L) {
#line 335
    goto case_19;
  }
#line 335
  if (result == 2L) {
#line 335
    goto case_19;
  }
#line 335
  if (result == 1L) {
#line 335
    goto case_19;
  }
#line 339
  if (result == -1L) {
#line 339
    goto case_neg_1;
  }
#line 343
  goto switch_default;
  case_19: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 336
  *value_ret = 8UL << 58U;
#line 337
  return (-1L);
  case_neg_1: /* CIL Label */ 
#line 340
  *value_ret = 0UL;
#line 341
  return (-1L);
  switch_default: /* CIL Label */ 
#line 344
  return (result);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 348 "/home/khheo/project/mit-scheme-9.2/src/microcode/lookup.c"
long assign_variable(SCHEME_OBJECT environment , SCHEME_OBJECT symbol , SCHEME_OBJECT value ,
                     SCHEME_OBJECT *value_ret ) 
{ 
  SCHEME_OBJECT *cell ;
  SCHEME_OBJECT *tmp ;
  long tmp___0 ;

  {
#line 352
  if (! (environment >> 58U == 18UL)) {
#line 352
    if (! (environment == 0UL)) {
#line 352
      if (! (symbol >> 58U == 29UL)) {
#line 352
        if (! (symbol >> 58U == 5UL)) {
#line 353
          return (6L);
        }
      }
    }
  }
  {
#line 355
  tmp = find_binding_cell(environment, symbol, (SCHEME_OBJECT *)0);
#line 355
  cell = tmp;
  }
#line 356
  if ((unsigned long )cell == (unsigned long )((SCHEME_OBJECT *)0)) {
#line 357
    return (1L);
  }
  {
#line 358
  tmp___0 = assign_variable_end(cell, value, value_ret, 0);
  }
#line 358
  return (tmp___0);
}
}
#line 362 "/home/khheo/project/mit-scheme-9.2/src/microcode/lookup.c"
static long assign_variable_end(SCHEME_OBJECT *cell , SCHEME_OBJECT value , SCHEME_OBJECT *value_ret ,
                                int force_p ) 
{ 
  SCHEME_OBJECT old_value ;
  trap_kind_t tmp ;
  long tmp___0 ;

  {
  {
#line 366
  old_value = *cell;
#line 367
  tmp = get_trap_kind(old_value);
  }
  {
#line 370
  if (tmp == 0UL) {
#line 370
    goto case_0;
  }
#line 370
  if (tmp == 32UL) {
#line 370
    goto case_0;
  }
#line 373
  if (tmp == 2UL) {
#line 373
    goto case_2;
  }
#line 378
  if (tmp == 15UL) {
#line 378
    goto case_15;
  }
#line 383
  if (tmp == 14UL) {
#line 383
    goto case_14;
  }
#line 388
  goto switch_default;
  case_0: /* CIL Label */ 
  case_32: /* CIL Label */ 
#line 371
  goto switch_break;
  case_2: /* CIL Label */ 
#line 374
  if (force_p) {
#line 375
    goto switch_break;
  }
#line 376
  return (1L);
  case_15: /* CIL Label */ 
#line 379
  if (force_p) {
#line 380
    goto switch_break;
  }
#line 381
  return (19L);
  case_14: /* CIL Label */ 
  {
#line 384
  tmp___0 = assign_variable_cache(*((SCHEME_OBJECT *)(old_value & 288230376151711743UL) + 1),
                                  value, value_ret, force_p);
  }
#line 384
  return (tmp___0);
  switch_default: /* CIL Label */ 
#line 389
  return (52L);
  switch_break: /* CIL Label */ ;
  }
#line 391
  if (old_value == 50UL << 58U) {
#line 391
    *value_ret = *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 1);
  } else {
#line 391
    *value_ret = old_value;
  }
#line 392
  if (value == *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 1)) {
#line 392
    *cell = 50UL << 58U;
  } else {
#line 392
    *cell = value;
  }
#line 393
  return (-1L);
}
}
#line 396 "/home/khheo/project/mit-scheme-9.2/src/microcode/lookup.c"
static long assign_variable_cache(SCHEME_OBJECT cache , SCHEME_OBJECT value , SCHEME_OBJECT *value_ret ,
                                  int force_p ) 
{ 
  SCHEME_OBJECT old_value ;
  trap_kind_t tmp ;
  unsigned long tmp___0 ;
  long tmp___1 ;

  {
  {
#line 400
  old_value = *((SCHEME_OBJECT *)(cache & 288230376151711743UL) + 0);
#line 401
  tmp = get_trap_kind(old_value);
  }
  {
#line 404
  if (tmp == 0UL) {
#line 404
    goto case_0;
  }
#line 404
  if (tmp == 32UL) {
#line 404
    goto case_0;
  }
#line 407
  if (tmp == 2UL) {
#line 407
    goto case_2;
  }
#line 412
  if (tmp == 15UL) {
#line 412
    goto case_15;
  }
#line 417
  goto switch_default;
  case_0: /* CIL Label */ 
  case_32: /* CIL Label */ 
#line 405
  goto switch_break;
  case_2: /* CIL Label */ 
#line 408
  if (force_p) {
#line 409
    goto switch_break;
  }
#line 410
  return (1L);
  case_15: /* CIL Label */ 
#line 413
  if (force_p) {
#line 414
    goto switch_break;
  }
#line 415
  return (19L);
  switch_default: /* CIL Label */ 
#line 418
  return (52L);
  switch_break: /* CIL Label */ ;
  }
#line 420
  if (old_value == 50UL << 58U) {
#line 420
    *value_ret = *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 1);
  } else {
#line 420
    *value_ret = old_value;
  }
#line 424
  if (*((SCHEME_OBJECT *)(*((SCHEME_OBJECT *)(cache & 288230376151711743UL) + 2) & 288230376151711743UL) + 2) >> 58U == 1UL) {
#line 425
    if (value == *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 1)) {
#line 425
      tmp___0 = 50UL << 58U;
    } else {
#line 425
      tmp___0 = value;
    }
    {
#line 425
    tmp___1 = update_uuo_links(cache, tmp___0);
    }
#line 425
    return (tmp___1);
  }
#line 427
  if (value == *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 1)) {
#line 427
    *((SCHEME_OBJECT *)(cache & 288230376151711743UL) + 0) = 50UL << 58U;
  } else {
#line 427
    *((SCHEME_OBJECT *)(cache & 288230376151711743UL) + 0) = value;
  }
#line 428
  return (-1L);
}
}
#line 432 "/home/khheo/project/mit-scheme-9.2/src/microcode/lookup.c"
static long update_uuo_links(SCHEME_OBJECT cache , SCHEME_OBJECT new_value ) 
{ 
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  SCHEME_OBJECT *WR_palist ;
  SCHEME_OBJECT *WR_prefs ;
  SCHEME_OBJECT reference ;

  {
#line 435
  if ((unsigned long )Free >= (unsigned long )heap_start) {
#line 435
    if ((unsigned long )Free < (unsigned long )heap_alloc_limit) {
      {
#line 435
      tmp___3 = count_references((SCHEME_OBJECT *)(*((SCHEME_OBJECT *)(cache & 288230376151711743UL) + 2) & 288230376151711743UL) + 2);
      }
#line 435
      if (! ((unsigned long )(Free + (tmp___3 * 10UL + 3UL)) <= (unsigned long )heap_alloc_limit)) {
#line 435
        goto _L___0;
      }
    } else {
#line 435
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 435
  if ((Registers[1] & 4UL) != 0UL) {
    {
#line 435
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 435
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 435
        set_ulong_register(12U, Registers[12] | 4UL);
        }
        {
#line 435
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 435
          if ((Registers[1] & Registers[12]) != 0UL) {
#line 435
            tmp___0 = memory_block_start;
          } else {
#line 435
            if ((Registers[1] & 4UL) != 0UL) {
#line 435
              tmp = heap_alloc_limit;
            } else {
#line 435
              tmp = heap_end;
            }
#line 435
            tmp___0 = tmp;
          }
          {
#line 435
          set_ptr_register(0U, tmp___0);
          }
#line 435
          if ((Registers[1] & 1UL) != 0UL) {
#line 435
            tmp___1 = stack_guard;
          } else {
#line 435
            tmp___1 = stack_start;
          }
          {
#line 435
          set_ptr_register(11U, tmp___1);
          }
#line 435
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 435
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 435
      tmp___2 = count_references((SCHEME_OBJECT *)(*((SCHEME_OBJECT *)(cache & 288230376151711743UL) + 2) & 288230376151711743UL) + 2);
#line 435
      gc_space_needed = tmp___2 * 10UL + 3UL;
      }
#line 435
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 435
    return (-4L);
  }
  {
#line 439
  *((SCHEME_OBJECT *)(cache & 288230376151711743UL) + 0) = new_value;
#line 440
  update_clone(cache);
#line 441
  WR_palist = (SCHEME_OBJECT *)(*((SCHEME_OBJECT *)(cache & 288230376151711743UL) + 2) & 288230376151711743UL) + 2;
  }
  {
#line 441
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 441
    if (! (*WR_palist >> 58U == 1UL)) {
#line 441
      goto while_break___2;
    }
#line 441
    WR_prefs = (SCHEME_OBJECT *)(*((SCHEME_OBJECT *)(*WR_palist & 288230376151711743UL) + 0) & 288230376151711743UL) + 1;
    {
#line 441
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 441
      if (! (*WR_prefs >> 58U == 1UL)) {
#line 441
        goto while_break___3;
      }
#line 441
      reference = *((SCHEME_OBJECT *)(*WR_prefs & 288230376151711743UL) + 0);
#line 441
      if (*((SCHEME_OBJECT *)(reference & 288230376151711743UL) + 0) == 0UL) {
#line 441
        *WR_prefs = *((SCHEME_OBJECT *)(*WR_prefs & 288230376151711743UL) + 1);
#line 441
        goto while_continue___3;
      }
      {
#line 441
      install_operator_cache(cache, *((SCHEME_OBJECT *)(reference & 288230376151711743UL) + 0),
                             *((SCHEME_OBJECT *)(reference & 288230376151711743UL) + 1) & 288230376151711743UL);
      }
      {
#line 441
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 441
        WR_prefs = (SCHEME_OBJECT *)(*WR_prefs & 288230376151711743UL) + 1;
#line 441
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 441
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 441
      if (*((SCHEME_OBJECT *)(*((SCHEME_OBJECT *)(*WR_palist & 288230376151711743UL) + 0) & 288230376151711743UL) + 1) >> 58U == 1UL) {
#line 441
        WR_palist = (SCHEME_OBJECT *)(*WR_palist & 288230376151711743UL) + 1;
      } else {
#line 441
        *WR_palist = *((SCHEME_OBJECT *)(*WR_palist & 288230376151711743UL) + 1);
      }
#line 441
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 449
  return (-1L);
}
}
#line 453 "/home/khheo/project/mit-scheme-9.2/src/microcode/lookup.c"
long define_variable(SCHEME_OBJECT environment , SCHEME_OBJECT symbol , SCHEME_OBJECT value ) 
{ 
  SCHEME_OBJECT *cell ;
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT old_value ;
  long tmp___0 ;
  long RIE_result ;
  long tmp___1 ;
  SCHEME_OBJECT *shadowed_cell ;
  SCHEME_OBJECT *tmp___2 ;
  SCHEME_OBJECT old_cache ;
  SCHEME_OBJECT tmp___4 ;
  trap_kind_t tmp___5 ;
  unsigned long length ;
  SCHEME_OBJECT pair ;
  SCHEME_OBJECT *tmp___6 ;
  SCHEME_OBJECT *tmp___7 ;
  SCHEME_OBJECT *tmp___8 ;
  unsigned long tmp___9 ;
  unsigned long tmp___10 ;
  unsigned long tmp___11 ;
  unsigned long tmp___12 ;
  unsigned long tmp___13 ;
  long tmp___14 ;
  long tmp___15 ;

  {
#line 457
  if (! (environment >> 58U == 18UL)) {
#line 457
    if (! (environment == 0UL)) {
#line 457
      if (! (symbol >> 58U == 29UL)) {
#line 457
        if (! (symbol >> 58U == 5UL)) {
#line 458
          return (6L);
        }
      }
    }
  }
  {
#line 462
  tmp = scan_frame(environment, symbol, 1);
#line 462
  cell = tmp;
  }
#line 464
  if ((unsigned long )cell != (unsigned long )((SCHEME_OBJECT *)0)) {
#line 466
    if (environment == 0UL) {
      {
#line 467
      strengthen_symbol(symbol);
      }
    }
    {
#line 468
    tmp___0 = assign_variable_end(cell, value, & old_value, 1);
    }
#line 468
    return (tmp___0);
  }
  {
#line 476
  tmp___1 = guarantee_extension_space(environment);
#line 476
  RIE_result = tmp___1;
  }
#line 476
  if (RIE_result != -1L) {
#line 476
    return (RIE_result);
  }
  {
#line 482
  tmp___2 = find_binding_cell(*((SCHEME_OBJECT *)(*((SCHEME_OBJECT *)(environment & 288230376151711743UL) + 1) & 288230376151711743UL) + 1),
                              symbol, (SCHEME_OBJECT *)0);
#line 482
  shadowed_cell = tmp___2;
  }
#line 484
  if ((unsigned long )shadowed_cell != (unsigned long )((SCHEME_OBJECT *)0)) {
    {
#line 484
    tmp___5 = get_trap_kind(*shadowed_cell);
    }
#line 484
    if (tmp___5 == 14UL) {
#line 484
      tmp___4 = *((SCHEME_OBJECT *)(*shadowed_cell & 288230376151711743UL) + 1);
    } else {
#line 484
      tmp___4 = 0UL;
    }
  } else {
#line 484
    tmp___4 = 0UL;
  }
#line 484
  old_cache = tmp___4;
#line 489
  length = (unsigned long )((long )(*((SCHEME_OBJECT *)(*((SCHEME_OBJECT *)(environment & 288230376151711743UL) + 1) & 288230376151711743UL) + 3) & 288230376151711743UL));
#line 494
  if ((unsigned long )Free >= (unsigned long )heap_start) {
#line 494
    if ((unsigned long )Free < (unsigned long )heap_alloc_limit) {
#line 494
      if (old_cache != 0UL) {
        {
#line 494
        tmp___11 = update_cache_refs_space(old_cache, environment, symbol);
#line 494
        tmp___12 = tmp___11;
        }
      } else {
#line 494
        tmp___12 = 0UL;
      }
#line 494
      if (! ((unsigned long )(Free + (2UL + tmp___12)) <= (unsigned long )heap_alloc_limit)) {
#line 494
        goto _L___0;
      }
    } else {
#line 494
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 494
  if ((Registers[1] & 4UL) != 0UL) {
    {
#line 494
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 494
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 494
        set_ulong_register(12U, Registers[12] | 4UL);
        }
        {
#line 494
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 494
          if ((Registers[1] & Registers[12]) != 0UL) {
#line 494
            tmp___7 = memory_block_start;
          } else {
#line 494
            if ((Registers[1] & 4UL) != 0UL) {
#line 494
              tmp___6 = heap_alloc_limit;
            } else {
#line 494
              tmp___6 = heap_end;
            }
#line 494
            tmp___7 = tmp___6;
          }
          {
#line 494
          set_ptr_register(0U, tmp___7);
          }
#line 494
          if ((Registers[1] & 1UL) != 0UL) {
#line 494
            tmp___8 = stack_guard;
          } else {
#line 494
            tmp___8 = stack_start;
          }
          {
#line 494
          set_ptr_register(11U, tmp___8);
          }
#line 494
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 494
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 494
      if (old_cache != 0UL) {
        {
#line 494
        tmp___9 = update_cache_refs_space(old_cache, environment, symbol);
#line 494
        tmp___10 = tmp___9;
        }
      } else {
#line 494
        tmp___10 = 0UL;
      }
#line 494
      gc_space_needed = 2UL + tmp___10;
#line 494
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 494
    return (-4L);
  }
#line 501
  if (value == *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 1)) {
#line 501
    tmp___13 = 50UL << 58U;
  } else {
#line 501
    tmp___13 = value;
  }
  {
#line 501
  pair = cons(symbol, tmp___13);
#line 502
  *(((SCHEME_OBJECT *)(*((SCHEME_OBJECT *)(environment & 288230376151711743UL) + 1) & 288230376151711743UL) + 4) + length) = pair;
#line 503
  *((SCHEME_OBJECT *)(*((SCHEME_OBJECT *)(environment & 288230376151711743UL) + 1) & 288230376151711743UL) + 3) = (26UL << 58U) | (length + 1UL);
  }
#line 506
  if (old_cache != 0UL) {
    {
#line 506
    tmp___14 = update_cache_references(old_cache, (SCHEME_OBJECT *)(pair & 288230376151711743UL) + 1,
                                       environment, symbol);
#line 506
    tmp___15 = tmp___14;
    }
  } else {
#line 506
    tmp___15 = -1L;
  }
#line 506
  return (tmp___15);
}
}
#line 514 "/home/khheo/project/mit-scheme-9.2/src/microcode/lookup.c"
static long guarantee_extension_space(SCHEME_OBJECT environment ) 
{ 
  unsigned long length ;
  SCHEME_OBJECT extension ;
  long RIE_result ;
  long tmp ;
  SCHEME_OBJECT extension___0 ;
  long RIE_result___0 ;
  long tmp___0 ;

  {
#line 517
  if (*((SCHEME_OBJECT *)(environment & 288230376151711743UL) + 1) >> 58U == 10UL) {
#line 520
    length = (unsigned long )((long )(*((SCHEME_OBJECT *)(*((SCHEME_OBJECT *)(environment & 288230376151711743UL) + 1) & 288230376151711743UL) + 3) & 288230376151711743UL));
#line 521
    if (length == (*((SCHEME_OBJECT *)(*((SCHEME_OBJECT *)(environment & 288230376151711743UL) + 1) & 288230376151711743UL) + 0) & 288230376151711743UL) - 3UL) {
      {
#line 524
      tmp = allocate_frame_extension(2UL * length, *((SCHEME_OBJECT *)(*((SCHEME_OBJECT *)(environment & 288230376151711743UL) + 1) & 288230376151711743UL) + 2),
                                     & extension);
#line 524
      RIE_result = tmp;
      }
#line 524
      if (RIE_result != -1L) {
#line 524
        return (RIE_result);
      }
      {
#line 529
      memcpy((void */* __restrict  */)((SCHEME_OBJECT *)(extension & 288230376151711743UL) + 4),
             (void const   */* __restrict  */)((SCHEME_OBJECT *)(*((SCHEME_OBJECT *)(environment & 288230376151711743UL) + 1) & 288230376151711743UL) + 4),
             length * sizeof(SCHEME_OBJECT ));
#line 532
      *((SCHEME_OBJECT *)(extension & 288230376151711743UL) + 3) = (26UL << 58U) | length;
#line 533
      *((SCHEME_OBJECT *)(environment & 288230376151711743UL) + 1) = extension;
      }
    }
  } else {
    {
#line 540
    tmp___0 = allocate_frame_extension(16UL, *((SCHEME_OBJECT *)(environment & 288230376151711743UL) + 1),
                                       & extension___0);
#line 540
    RIE_result___0 = tmp___0;
    }
#line 540
    if (RIE_result___0 != -1L) {
#line 540
      return (RIE_result___0);
    }
#line 544
    *((SCHEME_OBJECT *)(environment & 288230376151711743UL) + 1) = extension___0;
  }
#line 546
  return (-1L);
}
}
#line 549 "/home/khheo/project/mit-scheme-9.2/src/microcode/lookup.c"
static long allocate_frame_extension(unsigned long length , SCHEME_OBJECT procedure ,
                                     SCHEME_OBJECT *extension_ret ) 
{ 
  unsigned long n_words ;
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;
  SCHEME_OBJECT extension ;
  SCHEME_OBJECT tmp___2 ;

  {
#line 553
  n_words = 4UL + length;
#line 554
  if ((unsigned long )Free >= (unsigned long )heap_start) {
#line 554
    if ((unsigned long )Free < (unsigned long )heap_alloc_limit) {
#line 554
      if (! ((unsigned long )(Free + n_words) <= (unsigned long )heap_alloc_limit)) {
#line 554
        goto _L___0;
      }
    } else {
#line 554
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 554
  if ((Registers[1] & 4UL) != 0UL) {
    {
#line 554
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 554
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 554
        set_ulong_register(12U, Registers[12] | 4UL);
        }
        {
#line 554
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 554
          if ((Registers[1] & Registers[12]) != 0UL) {
#line 554
            tmp___0 = memory_block_start;
          } else {
#line 554
            if ((Registers[1] & 4UL) != 0UL) {
#line 554
              tmp = heap_alloc_limit;
            } else {
#line 554
              tmp = heap_end;
            }
#line 554
            tmp___0 = tmp;
          }
          {
#line 554
          set_ptr_register(0U, tmp___0);
          }
#line 554
          if ((Registers[1] & 1UL) != 0UL) {
#line 554
            tmp___1 = stack_guard;
          } else {
#line 554
            tmp___1 = stack_start;
          }
          {
#line 554
          set_ptr_register(11U, tmp___1);
          }
#line 554
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 554
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 554
      gc_space_needed = n_words;
#line 554
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 554
    return (-4L);
  }
  {
#line 556
  tmp___2 = make_vector(n_words - 1UL, 0UL, (_Bool)0);
#line 556
  extension = tmp___2;
#line 557
  *((SCHEME_OBJECT *)(extension & 288230376151711743UL) + 1) = *((SCHEME_OBJECT *)(procedure & 288230376151711743UL) + 1);
#line 559
  *((SCHEME_OBJECT *)(extension & 288230376151711743UL) + 2) = procedure;
#line 560
  *((SCHEME_OBJECT *)(extension & 288230376151711743UL) + 3) = 26UL << 58U;
#line 561
  *extension_ret = extension;
  }
#line 562
  return (-1L);
}
}
#line 566 "/home/khheo/project/mit-scheme-9.2/src/microcode/lookup.c"
long link_variables(SCHEME_OBJECT target_environment , SCHEME_OBJECT target_symbol ,
                    SCHEME_OBJECT source_environment , SCHEME_OBJECT source_symbol ) 
{ 
  SCHEME_OBJECT *source_cell ;
  trap_kind_t source_kind ;
  SCHEME_OBJECT *target_cell ;
  SCHEME_OBJECT target_cache ;
  SCHEME_OBJECT source_cache ;
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  trap_kind_t tmp___4 ;
  long RIE_result ;
  long tmp___5 ;
  long tmp___6 ;

  {
#line 574
  if (target_environment >> 58U == 18UL) {
#line 574
    goto _L___1;
  } else
#line 574
  if (target_environment == 0UL) {
    _L___1: /* CIL Label */ 
#line 574
    if (source_environment >> 58U == 18UL) {
#line 574
      goto _L___0;
    } else
#line 574
    if (source_environment == 0UL) {
      _L___0: /* CIL Label */ 
#line 574
      if (target_symbol >> 58U == 29UL) {
#line 574
        goto _L;
      } else
#line 574
      if (target_symbol >> 58U == 5UL) {
        _L: /* CIL Label */ 
#line 574
        if (! (source_symbol >> 58U == 29UL)) {
#line 574
          if (! (source_symbol >> 58U == 5UL)) {
#line 578
            return (6L);
          }
        }
      } else {
#line 578
        return (6L);
      }
    } else {
#line 578
      return (6L);
    }
  } else {
#line 578
    return (6L);
  }
  {
#line 580
  source_cell = find_binding_cell(source_environment, source_symbol, (SCHEME_OBJECT *)0);
  }
#line 581
  if ((unsigned long )source_cell == (unsigned long )((SCHEME_OBJECT *)0)) {
#line 582
    return (1L);
  }
  {
#line 584
  source_kind = get_trap_kind(*source_cell);
  }
#line 585
  if (source_kind == 2UL) {
#line 586
    return (1L);
  }
  {
#line 588
  target_cell = scan_frame(target_environment, target_symbol, 1);
  }
#line 589
  if ((unsigned long )target_cell == (unsigned long )source_cell) {
#line 590
    return (-1L);
  }
#line 592
  if ((unsigned long )target_cell != (unsigned long )((SCHEME_OBJECT *)0)) {
#line 592
    if (target_environment == 0UL) {
      {
#line 593
      strengthen_symbol(target_symbol);
      }
    }
  }
#line 595
  if ((unsigned long )target_cell != (unsigned long )((SCHEME_OBJECT *)0)) {
    {
#line 595
    tmp___4 = get_trap_kind(*target_cell);
    }
#line 595
    if (tmp___4 == 14UL) {
#line 598
      target_cache = *((SCHEME_OBJECT *)(*target_cell & 288230376151711743UL) + 1);
#line 599
      if (source_kind == 14UL) {
#line 601
        source_cache = *((SCHEME_OBJECT *)(*source_cell & 288230376151711743UL) + 1);
#line 602
        if (source_cache == target_cache) {
#line 604
          return (-1L);
        }
#line 605
        if ((unsigned long )Free >= (unsigned long )heap_start) {
#line 605
          if ((unsigned long )Free < (unsigned long )heap_alloc_limit) {
            {
#line 605
            tmp___3 = count_references((SCHEME_OBJECT *)(*((SCHEME_OBJECT *)(target_cache & 288230376151711743UL) + 2) & 288230376151711743UL) + 2);
            }
#line 605
            if (! ((unsigned long )(Free + (tmp___3 * 10UL + 6UL)) <= (unsigned long )heap_alloc_limit)) {
#line 605
              goto _L___3;
            }
          } else {
#line 605
            goto _L___3;
          }
        } else
        _L___3: /* CIL Label */ 
#line 605
        if ((Registers[1] & 4UL) != 0UL) {
          {
#line 605
          while (1) {
            while_continue: /* CIL Label */ ;
            {
#line 605
            while (1) {
              while_continue___0: /* CIL Label */ ;
              {
#line 605
              set_ulong_register(12U, Registers[12] | 4UL);
              }
              {
#line 605
              while (1) {
                while_continue___1: /* CIL Label */ ;
#line 605
                if ((Registers[1] & Registers[12]) != 0UL) {
#line 605
                  tmp___0 = memory_block_start;
                } else {
#line 605
                  if ((Registers[1] & 4UL) != 0UL) {
#line 605
                    tmp = heap_alloc_limit;
                  } else {
#line 605
                    tmp = heap_end;
                  }
#line 605
                  tmp___0 = tmp;
                }
                {
#line 605
                set_ptr_register(0U, tmp___0);
                }
#line 605
                if ((Registers[1] & 1UL) != 0UL) {
#line 605
                  tmp___1 = stack_guard;
                } else {
#line 605
                  tmp___1 = stack_start;
                }
                {
#line 605
                set_ptr_register(11U, tmp___1);
                }
#line 605
                goto while_break___1;
              }
              while_break___1: /* CIL Label */ ;
              }
#line 605
              goto while_break___0;
            }
            while_break___0: /* CIL Label */ ;
            }
            {
#line 605
            tmp___2 = count_references((SCHEME_OBJECT *)(*((SCHEME_OBJECT *)(target_cache & 288230376151711743UL) + 2) & 288230376151711743UL) + 2);
#line 605
            gc_space_needed = tmp___2 * 10UL + 6UL;
            }
#line 605
            goto while_break;
          }
          while_break: /* CIL Label */ ;
          }
#line 605
          return (-4L);
        }
        {
#line 609
        *((SCHEME_OBJECT *)(target_cache & 288230376151711743UL) + 0) = *((SCHEME_OBJECT *)(source_cache & 288230376151711743UL) + 0);
#line 611
        move_all_references(source_cache, target_cache, 0U);
#line 613
        move_all_references(source_cache, target_cache, 1U);
#line 615
        move_all_references(source_cache, target_cache, 2U);
#line 618
        update_clone(source_cache);
#line 619
        update_clone(target_cache);
#line 622
        *((SCHEME_OBJECT *)(*source_cell & 288230376151711743UL) + 1) = target_cache;
        }
      } else {
#line 625
        *((SCHEME_OBJECT *)(target_cache & 288230376151711743UL) + 0) = *source_cell;
      }
#line 626
      *source_cell = *target_cell;
#line 627
      return (-1L);
    }
  }
  {
#line 630
  tmp___5 = guarantee_cache(source_cell);
#line 630
  RIE_result = tmp___5;
  }
#line 630
  if (RIE_result != -1L) {
#line 630
    return (RIE_result);
  }
  {
#line 631
  tmp___6 = define_variable(target_environment, target_symbol, *source_cell);
  }
#line 631
  return (tmp___6);
}
}
#line 635 "/home/khheo/project/mit-scheme-9.2/src/microcode/lookup.c"
static void move_all_references(SCHEME_OBJECT from_cache , SCHEME_OBJECT to_cache ,
                                unsigned int reference_kind ) 
{ 
  SCHEME_OBJECT *pfrom ;
  SCHEME_OBJECT *pto ;
  SCHEME_OBJECT *WR_palist ;
  SCHEME_OBJECT *WR_prefs ;
  SCHEME_OBJECT reference ;

  {
#line 639
  pfrom = (SCHEME_OBJECT *)(*((SCHEME_OBJECT *)(from_cache & 288230376151711743UL) + 2) & 288230376151711743UL) + reference_kind;
#line 640
  pto = (SCHEME_OBJECT *)(*((SCHEME_OBJECT *)(to_cache & 288230376151711743UL) + 2) & 288230376151711743UL) + reference_kind;
#line 642
  WR_palist = pfrom;
  {
#line 642
  while (1) {
    while_continue: /* CIL Label */ ;
#line 642
    if (! (*WR_palist >> 58U == 1UL)) {
#line 642
      goto while_break;
    }
#line 642
    WR_prefs = (SCHEME_OBJECT *)(*((SCHEME_OBJECT *)(*WR_palist & 288230376151711743UL) + 0) & 288230376151711743UL) + 1;
    {
#line 642
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 642
      if (! (*WR_prefs >> 58U == 1UL)) {
#line 642
        goto while_break___0;
      }
#line 642
      reference = *((SCHEME_OBJECT *)(*WR_prefs & 288230376151711743UL) + 0);
#line 642
      if (*((SCHEME_OBJECT *)(reference & 288230376151711743UL) + 0) == 0UL) {
#line 642
        *WR_prefs = *((SCHEME_OBJECT *)(*WR_prefs & 288230376151711743UL) + 1);
#line 642
        goto while_continue___0;
      }
      {
#line 642
      install_cache(to_cache, *((SCHEME_OBJECT *)(reference & 288230376151711743UL) + 0),
                    *((SCHEME_OBJECT *)(reference & 288230376151711743UL) + 1) & 288230376151711743UL,
                    reference_kind);
      }
      {
#line 642
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 642
        WR_prefs = (SCHEME_OBJECT *)(*WR_prefs & 288230376151711743UL) + 1;
#line 642
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 642
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 642
      if (*((SCHEME_OBJECT *)(*((SCHEME_OBJECT *)(*WR_palist & 288230376151711743UL) + 0) & 288230376151711743UL) + 1) >> 58U == 1UL) {
#line 642
        WR_palist = (SCHEME_OBJECT *)(*WR_palist & 288230376151711743UL) + 1;
      } else {
#line 642
        *WR_palist = *((SCHEME_OBJECT *)(*WR_palist & 288230376151711743UL) + 1);
      }
#line 642
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 652
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 652
    if (! (*pto >> 58U == 1UL)) {
#line 652
      goto while_break___3;
    }
#line 653
    pto = (SCHEME_OBJECT *)(*pto & 288230376151711743UL) + 1;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 654
  *pto = *pfrom;
#line 655
  *pfrom = (8UL << 58U) | 9UL;
#line 656
  return;
}
}
#line 659 "/home/khheo/project/mit-scheme-9.2/src/microcode/lookup.c"
long unbind_variable(SCHEME_OBJECT environment , SCHEME_OBJECT symbol , SCHEME_OBJECT *value_ret ) 
{ 
  SCHEME_OBJECT frame ;
  SCHEME_OBJECT *cell ;
  SCHEME_OBJECT *tmp ;
  trap_kind_t tmp___0 ;
  trap_kind_t tmp___1 ;
  SCHEME_OBJECT cache ;
  trap_kind_t tmp___2 ;
  long RIE_result ;
  long tmp___3 ;

  {
  {
#line 664
  tmp = find_binding_cell(environment, symbol, & frame);
#line 664
  cell = tmp;
  }
#line 665
  if (frame == 0UL) {
    {
#line 666
    weaken_symbol(symbol);
    }
  }
#line 667
  if ((unsigned long )cell == (unsigned long )((SCHEME_OBJECT *)0)) {
#line 667
    tmp___1 = (trap_kind_t )2;
  } else {
    {
#line 667
    tmp___0 = get_trap_kind(*cell);
#line 667
    tmp___1 = tmp___0;
    }
  }
  {
#line 669
  if (tmp___1 == 2UL) {
#line 669
    goto case_2;
  }
#line 675
  if (tmp___1 == 15UL) {
#line 675
    goto case_15;
  }
#line 675
  if (tmp___1 == 0UL) {
#line 675
    goto case_15;
  }
#line 675
  if (tmp___1 == 32UL) {
#line 675
    goto case_15;
  }
#line 680
  if (tmp___1 == 14UL) {
#line 680
    goto case_14;
  }
#line 709
  goto switch_default___0;
  case_2: /* CIL Label */ 
#line 670
  *value_ret = 0UL;
#line 671
  return (-1L);
  case_15: /* CIL Label */ 
  case_0: /* CIL Label */ 
  case_32: /* CIL Label */ 
  {
#line 676
  unbind_variable_1(cell, frame, symbol);
#line 677
  *value_ret = 8UL << 58U;
  }
#line 678
  return (-1L);
  case_14: /* CIL Label */ 
  {
#line 682
  cache = *((SCHEME_OBJECT *)(*cell & 288230376151711743UL) + 1);
#line 683
  tmp___2 = get_trap_kind(*((SCHEME_OBJECT *)(cache & 288230376151711743UL) + 0));
  }
  {
#line 685
  if (tmp___2 == 2UL) {
#line 685
    goto case_2___0;
  }
#line 691
  if (tmp___2 == 15UL) {
#line 691
    goto case_15___0;
  }
#line 691
  if (tmp___2 == 0UL) {
#line 691
    goto case_15___0;
  }
#line 691
  if (tmp___2 == 32UL) {
#line 691
    goto case_15___0;
  }
#line 704
  goto switch_default;
  case_2___0: /* CIL Label */ 
#line 686
  *value_ret = 0UL;
#line 687
  return (-1L);
  case_15___0: /* CIL Label */ 
  case_0___0: /* CIL Label */ 
  case_32___0: /* CIL Label */ 
#line 692
  if (frame >> 58U == 18UL) {
    {
#line 694
    tmp___3 = unbind_cached_variable(cell, frame, symbol);
#line 694
    RIE_result = tmp___3;
    }
#line 694
    if (RIE_result != -1L) {
#line 694
      return (RIE_result);
    }
  } else {
#line 699
    *((SCHEME_OBJECT *)(cache & 288230376151711743UL) + 0) = (50UL << 58U) | 2UL;
  }
#line 701
  *value_ret = 8UL << 58U;
#line 702
  return (-1L);
  switch_default: /* CIL Label */ 
#line 705
  return (52L);
  switch_break___0: /* CIL Label */ ;
  }
  switch_default___0: /* CIL Label */ 
#line 710
  return (52L);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 714 "/home/khheo/project/mit-scheme-9.2/src/microcode/lookup.c"
static long unbind_cached_variable(SCHEME_OBJECT *cell , SCHEME_OBJECT frame , SCHEME_OBJECT symbol ) 
{ 
  SCHEME_OBJECT cache ;
  SCHEME_OBJECT *shadowed_cell ;
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;
  SCHEME_OBJECT *tmp___2 ;
  unsigned long tmp___3 ;
  long tmp___4 ;

  {
  {
#line 718
  cache = *((SCHEME_OBJECT *)(*cell & 288230376151711743UL) + 1);
#line 719
  tmp = find_binding_cell(*((SCHEME_OBJECT *)(*((SCHEME_OBJECT *)(frame & 288230376151711743UL) + 1) & 288230376151711743UL) + 1),
                          symbol, (SCHEME_OBJECT *)0);
#line 719
  shadowed_cell = tmp;
  }
#line 721
  if ((unsigned long )Free >= (unsigned long )heap_start) {
#line 721
    if ((unsigned long )Free < (unsigned long )heap_alloc_limit) {
      {
#line 721
      tmp___3 = update_cache_refs_space(cache, frame, symbol);
      }
#line 721
      if (! ((unsigned long )(Free + tmp___3) <= (unsigned long )heap_alloc_limit)) {
#line 721
        goto _L___0;
      }
    } else {
#line 721
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 721
  if ((Registers[1] & 4UL) != 0UL) {
    {
#line 721
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 721
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 721
        set_ulong_register(12U, Registers[12] | 4UL);
        }
        {
#line 721
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 721
          if ((Registers[1] & Registers[12]) != 0UL) {
#line 721
            tmp___1 = memory_block_start;
          } else {
#line 721
            if ((Registers[1] & 4UL) != 0UL) {
#line 721
              tmp___0 = heap_alloc_limit;
            } else {
#line 721
              tmp___0 = heap_end;
            }
#line 721
            tmp___1 = tmp___0;
          }
          {
#line 721
          set_ptr_register(0U, tmp___1);
          }
#line 721
          if ((Registers[1] & 1UL) != 0UL) {
#line 721
            tmp___2 = stack_guard;
          } else {
#line 721
            tmp___2 = stack_start;
          }
          {
#line 721
          set_ptr_register(11U, tmp___2);
          }
#line 721
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 721
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 721
      gc_space_needed = update_cache_refs_space(cache, frame, symbol);
      }
#line 721
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 721
    return (-4L);
  }
  {
#line 722
  unbind_variable_1(cell, frame, symbol);
#line 723
  tmp___4 = update_cache_references(cache, shadowed_cell, frame, symbol);
  }
#line 723
  return (tmp___4);
}
}
#line 726 "/home/khheo/project/mit-scheme-9.2/src/microcode/lookup.c"
static void unbind_variable_1(SCHEME_OBJECT *cell , SCHEME_OBJECT frame , SCHEME_OBJECT symbol ) 
{ 
  SCHEME_OBJECT *start ;
  unsigned long length ;
  unsigned long index___0 ;

  {
#line 730
  if (frame >> 58U == 18UL) {
#line 730
    if (*((SCHEME_OBJECT *)(frame & 288230376151711743UL) + 1) >> 58U == 10UL) {
#line 732
      start = (SCHEME_OBJECT *)(*((SCHEME_OBJECT *)(frame & 288230376151711743UL) + 1) & 288230376151711743UL) + 4;
#line 733
      length = (unsigned long )((long )(*((SCHEME_OBJECT *)(*((SCHEME_OBJECT *)(frame & 288230376151711743UL) + 1) & 288230376151711743UL) + 3) & 288230376151711743UL));
#line 734
      index___0 = 0UL;
      {
#line 735
      while (1) {
        while_continue: /* CIL Label */ ;
#line 735
        if (! (index___0 < length)) {
#line 735
          goto while_break;
        }
#line 737
        if (*((SCHEME_OBJECT *)(*(start + index___0) & 288230376151711743UL) + 0) == symbol) {
#line 739
          if (index___0 < length - 1UL) {
#line 740
            *(start + index___0) = *(start + (length - 1UL));
          }
#line 741
          *((SCHEME_OBJECT *)(*((SCHEME_OBJECT *)(frame & 288230376151711743UL) + 1) & 288230376151711743UL) + 3) = (26UL << 58U) | (length - 1UL);
#line 742
          *(start + (length - 1UL)) = 0UL;
#line 743
          return;
        }
#line 745
        index___0 ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 748
  *cell = (50UL << 58U) | 2UL;
#line 749
  return;
}
}
#line 755 "/home/khheo/project/mit-scheme-9.2/src/microcode/lookup.c"
long compiler_cache_lookup(SCHEME_OBJECT name , SCHEME_OBJECT block , unsigned long offset ) 
{ 
  SCHEME_OBJECT tmp ;
  long tmp___0 ;

  {
  {
#line 759
  tmp = cc_block_environment(block);
#line 759
  tmp___0 = add_cache_reference(tmp, name, block, offset, 0U);
  }
#line 759
  return (tmp___0);
}
}
#line 765 "/home/khheo/project/mit-scheme-9.2/src/microcode/lookup.c"
long compiler_cache_assignment(SCHEME_OBJECT name , SCHEME_OBJECT block , unsigned long offset ) 
{ 
  SCHEME_OBJECT tmp ;
  long tmp___0 ;

  {
  {
#line 769
  tmp = cc_block_environment(block);
#line 769
  tmp___0 = add_cache_reference(tmp, name, block, offset, 1U);
  }
#line 769
  return (tmp___0);
}
}
#line 775 "/home/khheo/project/mit-scheme-9.2/src/microcode/lookup.c"
long compiler_cache_operator(SCHEME_OBJECT name , SCHEME_OBJECT block , unsigned long offset ) 
{ 
  SCHEME_OBJECT tmp ;
  long tmp___0 ;

  {
  {
#line 779
  tmp = cc_block_environment(block);
#line 779
  tmp___0 = add_cache_reference(tmp, name, block, offset, 2U);
  }
#line 779
  return (tmp___0);
}
}
#line 785 "/home/khheo/project/mit-scheme-9.2/src/microcode/lookup.c"
long compiler_cache_global_operator(SCHEME_OBJECT name , SCHEME_OBJECT block , unsigned long offset ) 
{ 
  long tmp ;

  {
  {
#line 789
  tmp = add_cache_reference(0UL, name, block, offset, 2U);
  }
#line 789
  return (tmp);
}
}
#line 795 "/home/khheo/project/mit-scheme-9.2/src/microcode/lookup.c"
SCHEME_OBJECT compiler_var_error(SCHEME_OBJECT cache , SCHEME_OBJECT block , unsigned int reference_kind ) 
{ 
  SCHEME_OBJECT *WR_palist ;
  SCHEME_OBJECT *WR_prefs ;
  SCHEME_OBJECT reference ;

  {
#line 799
  WR_palist = (SCHEME_OBJECT *)(*((SCHEME_OBJECT *)(cache & 288230376151711743UL) + 2) & 288230376151711743UL) + reference_kind;
  {
#line 799
  while (1) {
    while_continue: /* CIL Label */ ;
#line 799
    if (! (*WR_palist >> 58U == 1UL)) {
#line 799
      goto while_break;
    }
#line 799
    WR_prefs = (SCHEME_OBJECT *)(*((SCHEME_OBJECT *)(*WR_palist & 288230376151711743UL) + 0) & 288230376151711743UL) + 1;
    {
#line 799
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 799
      if (! (*WR_prefs >> 58U == 1UL)) {
#line 799
        goto while_break___0;
      }
#line 799
      reference = *((SCHEME_OBJECT *)(*WR_prefs & 288230376151711743UL) + 0);
#line 799
      if (*((SCHEME_OBJECT *)(reference & 288230376151711743UL) + 0) == 0UL) {
#line 799
        *WR_prefs = *((SCHEME_OBJECT *)(*WR_prefs & 288230376151711743UL) + 1);
#line 799
        goto while_continue___0;
      }
#line 799
      if (*((SCHEME_OBJECT *)(reference & 288230376151711743UL) + 0) == block) {
#line 799
        return (*((SCHEME_OBJECT *)(*((SCHEME_OBJECT *)(*WR_palist & 288230376151711743UL) + 0) & 288230376151711743UL) + 0));
      }
      {
#line 799
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 799
        WR_prefs = (SCHEME_OBJECT *)(*WR_prefs & 288230376151711743UL) + 1;
#line 799
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 799
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 799
      if (*((SCHEME_OBJECT *)(*((SCHEME_OBJECT *)(*WR_palist & 288230376151711743UL) + 0) & 288230376151711743UL) + 1) >> 58U == 1UL) {
#line 799
        WR_palist = (SCHEME_OBJECT *)(*WR_palist & 288230376151711743UL) + 1;
      } else {
#line 799
        *WR_palist = *((SCHEME_OBJECT *)(*WR_palist & 288230376151711743UL) + 1);
      }
#line 799
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 808
  return (0UL);
}
}
#line 811 "/home/khheo/project/mit-scheme-9.2/src/microcode/lookup.c"
long compiler_lookup_trap(SCHEME_OBJECT cache , SCHEME_OBJECT *value_ret ) 
{ 
  long tmp ;

  {
  {
#line 814
  tmp = lookup_variable_cache(cache, value_ret);
  }
#line 814
  return (tmp);
}
}
#line 817 "/home/khheo/project/mit-scheme-9.2/src/microcode/lookup.c"
long compiler_safe_lookup_trap(SCHEME_OBJECT cache , SCHEME_OBJECT *value_ret ) 
{ 
  long result ;
  long tmp ;

  {
  {
#line 820
  tmp = lookup_variable_cache(cache, value_ret);
#line 820
  result = tmp;
  }
#line 821
  if (result == 2L) {
#line 823
    *value_ret = *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 1);
#line 824
    return (-1L);
  }
#line 826
  return (result);
}
}
#line 829 "/home/khheo/project/mit-scheme-9.2/src/microcode/lookup.c"
long compiler_unassigned_p_trap(SCHEME_OBJECT cache , SCHEME_OBJECT *value_ret ) 
{ 
  SCHEME_OBJECT dummy_value ;
  long result ;
  long tmp ;

  {
  {
#line 833
  tmp = lookup_variable_cache(cache, & dummy_value);
#line 833
  result = tmp;
  }
  {
#line 836
  if (result == 2L) {
#line 836
    goto case_2;
  }
#line 840
  if (result == -1L) {
#line 840
    goto case_neg_1;
  }
#line 844
  goto switch_default;
  case_2: /* CIL Label */ 
#line 837
  *value_ret = 8UL << 58U;
#line 838
  return (-1L);
  case_neg_1: /* CIL Label */ 
#line 841
  *value_ret = 0UL;
#line 842
  return (-1L);
  switch_default: /* CIL Label */ 
#line 845
  return (result);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 849 "/home/khheo/project/mit-scheme-9.2/src/microcode/lookup.c"
long compiler_assignment_trap(SCHEME_OBJECT cache , SCHEME_OBJECT value , SCHEME_OBJECT *value_ret ) 
{ 
  SCHEME_OBJECT tmp ;
  long tmp___0 ;

  {
#line 853
  if (*((SCHEME_OBJECT *)(cache & 288230376151711743UL) + 0) == ((50UL << 58U) | 6UL)) {
#line 853
    tmp = *((SCHEME_OBJECT *)(cache & 288230376151711743UL) + 1);
  } else {
#line 853
    tmp = cache;
  }
  {
#line 853
  tmp___0 = assign_variable_cache(tmp, value, value_ret, 0);
  }
#line 853
  return (tmp___0);
}
}
#line 864 "/home/khheo/project/mit-scheme-9.2/src/microcode/lookup.c"
long compiler_operator_reference_trap(SCHEME_OBJECT cache , SCHEME_OBJECT *value_ret ) 
{ 
  long tmp ;

  {
  {
#line 868
  tmp = lookup_variable_cache(cache, value_ret);
  }
#line 868
  return (tmp);
}
}
#line 911 "/home/khheo/project/mit-scheme-9.2/src/microcode/lookup.c"
static long add_cache_reference(SCHEME_OBJECT environment , SCHEME_OBJECT symbol ,
                                SCHEME_OBJECT block , unsigned long offset , unsigned int reference_kind ) 
{ 
  SCHEME_OBJECT frame ;
  SCHEME_OBJECT *cell ;
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT dummy_cell ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;
  SCHEME_OBJECT *tmp___2 ;
  long tmp___3 ;
  SCHEME_OBJECT cache ;
  char *__cil_tmp15 ;

  {
  {
#line 916
  frame = (SCHEME_OBJECT )0;
#line 917
  tmp = find_binding_cell(environment, symbol, & frame);
#line 917
  cell = tmp;
#line 918
  dummy_cell = (50UL << 58U) | 2UL;
  }
#line 919
  if ((unsigned long )cell == (unsigned long )((SCHEME_OBJECT *)0)) {
#line 924
    cell = & dummy_cell;
  } else
#line 925
  if (frame == 0UL) {
    {
#line 926
    strengthen_symbol(symbol);
    }
  }
#line 930
  if ((unsigned long )Free >= (unsigned long )heap_start) {
#line 930
    if ((unsigned long )Free < (unsigned long )heap_alloc_limit) {
#line 930
      if (! ((unsigned long )(Free + 24) <= (unsigned long )heap_alloc_limit)) {
#line 930
        goto _L___0;
      }
    } else {
#line 930
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 930
  if ((Registers[1] & 4UL) != 0UL) {
    {
#line 930
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 930
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 930
        set_ulong_register(12U, Registers[12] | 4UL);
        }
        {
#line 930
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 930
          if ((Registers[1] & Registers[12]) != 0UL) {
#line 930
            tmp___1 = memory_block_start;
          } else {
#line 930
            if ((Registers[1] & 4UL) != 0UL) {
#line 930
              tmp___0 = heap_alloc_limit;
            } else {
#line 930
              tmp___0 = heap_end;
            }
#line 930
            tmp___1 = tmp___0;
          }
          {
#line 930
          set_ptr_register(0U, tmp___1);
          }
#line 930
          if ((Registers[1] & 1UL) != 0UL) {
#line 930
            tmp___2 = stack_guard;
          } else {
#line 930
            tmp___2 = stack_start;
          }
          {
#line 930
          set_ptr_register(11U, tmp___2);
          }
#line 930
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 930
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 930
      gc_space_needed = 24UL;
#line 930
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 930
    return (-4L);
  }
  {
#line 931
  tmp___3 = guarantee_cache(cell);
  }
#line 931
  if (tmp___3 != -1L) {
    {
#line 931
    outf_fatal("\nRan out of guaranteed space!\n");
#line 931
    Microcode_Termination(12);
    }
  }
  {
#line 933
  cache = *((SCHEME_OBJECT *)(*cell & 288230376151711743UL) + 1);
#line 934
  add_reference((SCHEME_OBJECT *)(*((SCHEME_OBJECT *)(cache & 288230376151711743UL) + 2) & 288230376151711743UL) + reference_kind,
                symbol, block, offset);
#line 936
  update_clone(cache);
#line 937
  install_cache(cache, block, offset, reference_kind);
  }
#line 939
  return (-1L);
}
}
#line 946 "/home/khheo/project/mit-scheme-9.2/src/microcode/lookup.c"
static void add_reference(SCHEME_OBJECT *palist , SCHEME_OBJECT symbol , SCHEME_OBJECT block ,
                          unsigned long offset ) 
{ 
  SCHEME_OBJECT *prefs ;
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT reference ;
  long tmp___0 ;
  SCHEME_OBJECT reference___0 ;
  SCHEME_OBJECT alist ;
  long tmp___1 ;
  SCHEME_OBJECT tmp___2 ;
  SCHEME_OBJECT tmp___3 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
#line 950
  tmp = find_references_named(palist, symbol);
#line 950
  prefs = tmp;
  }
#line 951
  if ((unsigned long )prefs != (unsigned long )((SCHEME_OBJECT *)0)) {
    {
#line 953
    while (1) {
      while_continue: /* CIL Label */ ;
#line 953
      if (! (*prefs >> 58U == 1UL)) {
#line 953
        goto while_break;
      }
#line 955
      if (*((SCHEME_OBJECT *)(*((SCHEME_OBJECT *)(*prefs & 288230376151711743UL) + 0) & 288230376151711743UL) + 0) == 0UL) {
#line 958
        *((SCHEME_OBJECT *)(*((SCHEME_OBJECT *)(*prefs & 288230376151711743UL) + 0) & 288230376151711743UL) + 0) = block;
#line 959
        *((SCHEME_OBJECT *)(*((SCHEME_OBJECT *)(*prefs & 288230376151711743UL) + 0) & 288230376151711743UL) + 1) = (26UL << 58U) | offset;
#line 960
        return;
      }
      {
#line 962
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 962
        prefs = (SCHEME_OBJECT *)(*prefs & 288230376151711743UL) + 1;
#line 962
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 966
    tmp___0 = make_cache_reference(block, offset, & reference);
    }
#line 966
    if (tmp___0 != -1L) {
      {
#line 966
      outf_fatal("\nRan out of guaranteed space!\n");
#line 966
      Microcode_Termination(12);
      }
    }
    {
#line 967
    *prefs = cons(reference, (8UL << 58U) | 9UL);
    }
#line 969
    return;
  }
  {
#line 974
  tmp___1 = make_cache_reference(block, offset, & reference___0);
  }
#line 974
  if (tmp___1 != -1L) {
    {
#line 974
    outf_fatal("\nRan out of guaranteed space!\n");
#line 974
    Microcode_Termination(12);
    }
  }
  {
#line 975
  alist = *palist;
#line 976
  tmp___2 = cons(reference___0, (8UL << 58U) | 9UL);
#line 976
  tmp___3 = cons(symbol, tmp___2);
#line 976
  *palist = cons(tmp___3, alist);
  }
#line 978
  return;
}
}
#line 980 "/home/khheo/project/mit-scheme-9.2/src/microcode/lookup.c"
static void install_cache(SCHEME_OBJECT cache , SCHEME_OBJECT block , unsigned long offset ,
                          unsigned int reference_kind ) 
{ 
  SCHEME_OBJECT tmp ;

  {
  {
#line 986
  if (reference_kind == 0U) {
#line 986
    goto case_0;
  }
#line 990
  if (reference_kind == 1U) {
#line 990
    goto case_1;
  }
#line 999
  if (reference_kind == 2U) {
#line 999
    goto case_2;
  }
#line 1003
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 987
  write_variable_cache(cache, block, offset);
  }
#line 988
  goto switch_break;
  case_1: /* CIL Label */ 
#line 991
  if (*((SCHEME_OBJECT *)(cache & 288230376151711743UL) + 1) != 0UL) {
#line 991
    tmp = *((SCHEME_OBJECT *)(cache & 288230376151711743UL) + 1);
  } else {
#line 991
    tmp = cache;
  }
  {
#line 991
  write_variable_cache(tmp, block, offset);
  }
#line 997
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1000
  install_operator_cache(cache, block, offset);
  }
#line 1001
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1004
  abort();
  }
#line 1005
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1007
  return;
}
}
#line 1009 "/home/khheo/project/mit-scheme-9.2/src/microcode/lookup.c"
static void install_operator_cache(SCHEME_OBJECT cache , SCHEME_OBJECT block , unsigned long offset ) 
{ 
  SCHEME_OBJECT value ;
  long tmp ;
  char *__cil_tmp6 ;

  {
  {
#line 1013
  value = *((SCHEME_OBJECT *)(cache & 288230376151711743UL) + 0);
#line 1014
  tmp = make_uuo_link(value, cache, block, offset);
  }
#line 1014
  if (tmp != -1L) {
    {
#line 1014
    outf_fatal("\nRan out of guaranteed space!\n");
#line 1014
    Microcode_Termination(12);
    }
  }
#line 1015
  return;
}
}
#line 1019 "/home/khheo/project/mit-scheme-9.2/src/microcode/lookup.c"
static unsigned long update_cache_refs_space(SCHEME_OBJECT from_cache , SCHEME_OBJECT environment ,
                                             SCHEME_OBJECT symbol ) 
{ 
  unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;

  {
  {
#line 1024
  tmp = update_cache_refs_space_1(from_cache, 0U, environment, symbol);
#line 1024
  tmp___0 = update_cache_refs_space_1(from_cache, 1U, environment, symbol);
#line 1024
  tmp___1 = update_cache_refs_space_1(from_cache, 2U, environment, symbol);
  }
#line 1024
  return ((tmp + tmp___0) + tmp___1);
}
}
#line 1039 "/home/khheo/project/mit-scheme-9.2/src/microcode/lookup.c"
static unsigned long update_cache_refs_space_1(SCHEME_OBJECT from_cache , unsigned int kind ,
                                               SCHEME_OBJECT environment , SCHEME_OBJECT symbol ) 
{ 
  SCHEME_OBJECT *from_palist ;
  unsigned long n_refs ;
  unsigned long tmp ;
  unsigned long result ;

  {
  {
#line 1043
  from_palist = (SCHEME_OBJECT *)(*((SCHEME_OBJECT *)(from_cache & 288230376151711743UL) + 2) & 288230376151711743UL) + kind;
#line 1044
  tmp = ref_pairs_to_move(from_palist, environment, symbol);
#line 1044
  n_refs = tmp;
#line 1045
  result = 0UL;
  }
#line 1046
  if (n_refs > 0UL) {
#line 1049
    result += 7UL;
#line 1050
    if (kind == 2U) {
#line 1052
      result += n_refs * 10UL;
    }
  }
#line 1054
  return (result);
}
}
#line 1057 "/home/khheo/project/mit-scheme-9.2/src/microcode/lookup.c"
static long update_cache_references(SCHEME_OBJECT from_cache , SCHEME_OBJECT *to_cell ,
                                    SCHEME_OBJECT environment , SCHEME_OBJECT symbol ) 
{ 
  long tmp ;
  SCHEME_OBJECT to_cache ;
  char *__cil_tmp7 ;

  {
#line 1061
  if ((unsigned long )to_cell != (unsigned long )((SCHEME_OBJECT *)0)) {
    {
#line 1063
    tmp = guarantee_cache(to_cell);
    }
#line 1063
    if (tmp != -1L) {
      {
#line 1063
      outf_fatal("\nRan out of guaranteed space!\n");
#line 1063
      Microcode_Termination(12);
      }
    }
    {
#line 1065
    to_cache = *((SCHEME_OBJECT *)(*to_cell & 288230376151711743UL) + 1);
#line 1067
    move_ref_pairs(from_cache, to_cache, 0U, environment, symbol);
#line 1070
    move_ref_pairs(from_cache, to_cache, 1U, environment, symbol);
#line 1073
    move_ref_pairs(from_cache, to_cache, 2U, environment, symbol);
#line 1077
    update_clone(to_cache);
    }
  } else {
    {
#line 1083
    delete_ref_pairs(from_cache, 0U, environment, symbol);
#line 1085
    delete_ref_pairs(from_cache, 1U, environment, symbol);
#line 1087
    delete_ref_pairs(from_cache, 2U, environment, symbol);
    }
  }
  {
#line 1091
  update_clone(from_cache);
  }
#line 1092
  return (-1L);
}
}
#line 1097 "/home/khheo/project/mit-scheme-9.2/src/microcode/lookup.c"
static unsigned long ref_pairs_to_move(SCHEME_OBJECT *palist , SCHEME_OBJECT environment ,
                                       SCHEME_OBJECT symbol ) 
{ 
  SCHEME_OBJECT *prefs ;
  SCHEME_OBJECT *tmp ;
  unsigned long n_refs ;
  int tmp___0 ;

  {
  {
#line 1101
  tmp = find_references_named(palist, symbol);
#line 1101
  prefs = tmp;
#line 1102
  n_refs = 0UL;
  }
#line 1103
  if ((unsigned long )prefs != (unsigned long )((SCHEME_OBJECT *)0)) {
    {
#line 1104
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1104
      if (! (*prefs >> 58U == 1UL)) {
#line 1104
        goto while_break;
      }
#line 1106
      if (*((SCHEME_OBJECT *)(*((SCHEME_OBJECT *)(*prefs & 288230376151711743UL) + 0) & 288230376151711743UL) + 0) == 0UL) {
#line 1106
        *prefs = *((SCHEME_OBJECT *)(*prefs & 288230376151711743UL) + 1);
#line 1106
        goto while_continue;
      }
      {
#line 1107
      tmp___0 = move_ref_pair_p(*prefs, environment);
      }
#line 1107
      if (tmp___0) {
#line 1108
        n_refs ++;
      }
      {
#line 1109
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1109
        prefs = (SCHEME_OBJECT *)(*prefs & 288230376151711743UL) + 1;
#line 1109
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1111
  return (n_refs);
}
}
#line 1114 "/home/khheo/project/mit-scheme-9.2/src/microcode/lookup.c"
static void delete_ref_pairs(SCHEME_OBJECT from_cache , unsigned int kind , SCHEME_OBJECT environment ,
                             SCHEME_OBJECT symbol ) 
{ 
  SCHEME_OBJECT *from_palist ;
  SCHEME_OBJECT *from_prefs ;
  SCHEME_OBJECT *tmp ;
  int tmp___0 ;

  {
  {
#line 1118
  from_palist = (SCHEME_OBJECT *)(*((SCHEME_OBJECT *)(from_cache & 288230376151711743UL) + 2) & 288230376151711743UL) + kind;
#line 1119
  tmp = find_references_named(from_palist, symbol);
#line 1119
  from_prefs = tmp;
  }
#line 1120
  if ((unsigned long )from_prefs != (unsigned long )((SCHEME_OBJECT *)0)) {
    {
#line 1121
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1121
      if (! (*from_prefs >> 58U == 1UL)) {
#line 1121
        goto while_break;
      }
#line 1123
      if (*((SCHEME_OBJECT *)(*((SCHEME_OBJECT *)(*from_prefs & 288230376151711743UL) + 0) & 288230376151711743UL) + 0) == 0UL) {
#line 1123
        *from_prefs = *((SCHEME_OBJECT *)(*from_prefs & 288230376151711743UL) + 1);
#line 1123
        goto while_continue;
      }
      {
#line 1124
      tmp___0 = move_ref_pair_p(*from_prefs, environment);
      }
#line 1124
      if (tmp___0) {
#line 1126
        *from_prefs = *((SCHEME_OBJECT *)(*from_prefs & 288230376151711743UL) + 1);
#line 1127
        goto while_continue;
      }
      {
#line 1129
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1129
        from_prefs = (SCHEME_OBJECT *)(*from_prefs & 288230376151711743UL) + 1;
#line 1129
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1131
  return;
}
}
#line 1133 "/home/khheo/project/mit-scheme-9.2/src/microcode/lookup.c"
static void move_ref_pairs(SCHEME_OBJECT from_cache , SCHEME_OBJECT to_cache , unsigned int reference_kind ,
                           SCHEME_OBJECT environment , SCHEME_OBJECT symbol ) 
{ 
  SCHEME_OBJECT *from_palist ;
  SCHEME_OBJECT *to_palist ;
  SCHEME_OBJECT *from_prefs ;
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT *to_prefs ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT p ;
  int tmp___1 ;

  {
  {
#line 1138
  from_palist = (SCHEME_OBJECT *)(*((SCHEME_OBJECT *)(from_cache & 288230376151711743UL) + 2) & 288230376151711743UL) + reference_kind;
#line 1140
  to_palist = (SCHEME_OBJECT *)(*((SCHEME_OBJECT *)(to_cache & 288230376151711743UL) + 2) & 288230376151711743UL) + reference_kind;
#line 1142
  tmp = find_references_named(from_palist, symbol);
#line 1142
  from_prefs = tmp;
#line 1143
  tmp___0 = find_references_named(to_palist, symbol);
#line 1143
  to_prefs = tmp___0;
  }
#line 1144
  if ((unsigned long )from_prefs != (unsigned long )((SCHEME_OBJECT *)0)) {
    {
#line 1145
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1145
      if (! (*from_prefs >> 58U == 1UL)) {
#line 1145
        goto while_break;
      }
#line 1147
      if (*((SCHEME_OBJECT *)(*((SCHEME_OBJECT *)(*from_prefs & 288230376151711743UL) + 0) & 288230376151711743UL) + 0) == 0UL) {
#line 1147
        *from_prefs = *((SCHEME_OBJECT *)(*from_prefs & 288230376151711743UL) + 1);
#line 1147
        goto while_continue;
      }
      {
#line 1148
      tmp___1 = move_ref_pair_p(*from_prefs, environment);
      }
#line 1148
      if (tmp___1) {
#line 1150
        p = *from_prefs;
#line 1151
        *from_prefs = *((SCHEME_OBJECT *)(p & 288230376151711743UL) + 1);
#line 1152
        if ((unsigned long )to_prefs == (unsigned long )((SCHEME_OBJECT *)0)) {
          {
#line 1153
          to_prefs = new_alist_entry(to_palist, symbol);
          }
        }
        {
#line 1154
        *((SCHEME_OBJECT *)(p & 288230376151711743UL) + 1) = *to_prefs;
#line 1155
        *to_prefs = p;
#line 1156
        install_cache(to_cache, *((SCHEME_OBJECT *)(*((SCHEME_OBJECT *)(p & 288230376151711743UL) + 0) & 288230376151711743UL) + 0),
                      *((SCHEME_OBJECT *)(*((SCHEME_OBJECT *)(p & 288230376151711743UL) + 0) & 288230376151711743UL) + 1) & 288230376151711743UL,
                      reference_kind);
        }
#line 1160
        goto while_continue;
      }
      {
#line 1162
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1162
        from_prefs = (SCHEME_OBJECT *)(*from_prefs & 288230376151711743UL) + 1;
#line 1162
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1164
  return;
}
}
#line 1166 "/home/khheo/project/mit-scheme-9.2/src/microcode/lookup.c"
static SCHEME_OBJECT *new_alist_entry(SCHEME_OBJECT *to_palist , SCHEME_OBJECT symbol ) 
{ 
  SCHEME_OBJECT entry ;
  SCHEME_OBJECT tmp ;
  SCHEME_OBJECT head ;

  {
  {
#line 1169
  tmp = cons(symbol, (8UL << 58U) | 9UL);
#line 1169
  entry = tmp;
#line 1170
  head = *to_palist;
#line 1171
  *to_palist = cons(entry, head);
  }
#line 1172
  return ((SCHEME_OBJECT *)(entry & 288230376151711743UL) + 1);
}
}
#line 1175 "/home/khheo/project/mit-scheme-9.2/src/microcode/lookup.c"
static int move_ref_pair_p(SCHEME_OBJECT ref_pair , SCHEME_OBJECT ancestor ) 
{ 
  SCHEME_OBJECT descendant ;
  SCHEME_OBJECT tmp ;

  {
  {
#line 1178
  tmp = cc_block_environment(*((SCHEME_OBJECT *)(*((SCHEME_OBJECT *)(ref_pair & 288230376151711743UL) + 0) & 288230376151711743UL) + 0));
#line 1178
  descendant = tmp;
  }
  {
#line 1181
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1181
    if (! (descendant >> 58U == 18UL)) {
#line 1181
      goto while_break;
    }
#line 1183
    if (descendant == ancestor) {
#line 1184
      return (1);
    }
#line 1185
    descendant = *((SCHEME_OBJECT *)(*((SCHEME_OBJECT *)(descendant & 288230376151711743UL) + 1) & 288230376151711743UL) + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 1187
  return (descendant == ancestor);
}
}
#line 1194 "/home/khheo/project/mit-scheme-9.2/src/microcode/lookup.c"
static SCHEME_OBJECT *find_binding_cell(SCHEME_OBJECT environment , SCHEME_OBJECT symbol ,
                                        SCHEME_OBJECT *frame_ret ) 
{ 
  SCHEME_OBJECT frame ;
  SCHEME_OBJECT *cell ;
  SCHEME_OBJECT *tmp ;

  {
#line 1198
  frame = environment;
  {
#line 1199
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1201
    tmp = scan_frame(frame, symbol, 0);
#line 1201
    cell = tmp;
    }
#line 1202
    if ((unsigned long )cell != (unsigned long )((SCHEME_OBJECT *)0)) {
#line 1202
      goto _L;
    } else
#line 1202
    if (! (frame >> 58U == 18UL)) {
      _L: /* CIL Label */ 
#line 1204
      if ((unsigned long )frame_ret != (unsigned long )((SCHEME_OBJECT *)0)) {
#line 1205
        *frame_ret = frame;
      }
#line 1206
      return (cell);
    }
#line 1208
    frame = *((SCHEME_OBJECT *)(*((SCHEME_OBJECT *)(frame & 288230376151711743UL) + 1) & 288230376151711743UL) + 1);
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1212 "/home/khheo/project/mit-scheme-9.2/src/microcode/lookup.c"
static SCHEME_OBJECT *scan_frame(SCHEME_OBJECT frame , SCHEME_OBJECT symbol , int find_unbound_p ) 
{ 
  SCHEME_OBJECT *scan ;
  SCHEME_OBJECT *end ;
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT *tmp___0 ;

  {
#line 1215
  if (frame >> 58U == 18UL) {
#line 1217
    if (*((SCHEME_OBJECT *)(frame & 288230376151711743UL) + 1) >> 58U == 10UL) {
#line 1220
      scan = (SCHEME_OBJECT *)(*((SCHEME_OBJECT *)(frame & 288230376151711743UL) + 1) & 288230376151711743UL) + 4;
#line 1221
      end = scan + (long )(*((SCHEME_OBJECT *)(*((SCHEME_OBJECT *)(frame & 288230376151711743UL) + 1) & 288230376151711743UL) + 3) & 288230376151711743UL);
      {
#line 1222
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1222
        if (! ((unsigned long )scan < (unsigned long )end)) {
#line 1222
          goto while_break;
        }
#line 1224
        if (*((SCHEME_OBJECT *)(*scan & 288230376151711743UL) + 0) == symbol) {
#line 1225
          return ((SCHEME_OBJECT *)(*scan & 288230376151711743UL) + 1);
        }
#line 1226
        scan ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 1228
      tmp = scan_procedure_bindings(*((SCHEME_OBJECT *)(*((SCHEME_OBJECT *)(frame & 288230376151711743UL) + 1) & 288230376151711743UL) + 2),
                                    frame, symbol, find_unbound_p);
      }
#line 1228
      return (tmp);
    }
    {
#line 1232
    tmp___0 = scan_procedure_bindings(*((SCHEME_OBJECT *)(frame & 288230376151711743UL) + 1),
                                      frame, symbol, find_unbound_p);
    }
#line 1232
    return (tmp___0);
  } else
#line 1236
  if (frame == 0UL) {
#line 1237
    return ((SCHEME_OBJECT *)(symbol & 288230376151711743UL) + 1);
  } else {
#line 1239
    return ((SCHEME_OBJECT *)0);
  }
}
}
#line 1242 "/home/khheo/project/mit-scheme-9.2/src/microcode/lookup.c"
static SCHEME_OBJECT *scan_procedure_bindings(SCHEME_OBJECT procedure , SCHEME_OBJECT frame ,
                                              SCHEME_OBJECT symbol , int find_unbound_p ) 
{ 
  SCHEME_OBJECT lambda ;
  SCHEME_OBJECT *start ;
  SCHEME_OBJECT *scan ;
  SCHEME_OBJECT *end ;
  SCHEME_OBJECT *cell ;

  {
#line 1246
  lambda = *((SCHEME_OBJECT *)(procedure & 288230376151711743UL) + 0);
#line 1247
  start = (SCHEME_OBJECT *)(*((SCHEME_OBJECT *)(lambda & 288230376151711743UL) + 1) & 288230376151711743UL) + 2;
#line 1248
  scan = start;
#line 1249
  end = scan + ((*((SCHEME_OBJECT *)(*((SCHEME_OBJECT *)(lambda & 288230376151711743UL) + 1) & 288230376151711743UL) + 0) & 288230376151711743UL) - 1UL);
  {
#line 1250
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1250
    if (! ((unsigned long )scan < (unsigned long )end)) {
#line 1250
      goto while_break;
    }
#line 1252
    if (*scan == symbol) {
#line 1254
      cell = (SCHEME_OBJECT *)(frame & 288230376151711743UL) + (2L + (scan - start));
#line 1255
      if (find_unbound_p) {
#line 1256
        return (cell);
      } else
#line 1255
      if (*cell != ((50UL << 58U) | 2UL)) {
#line 1256
        return (cell);
      }
    }
#line 1258
    scan ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1260
  return ((SCHEME_OBJECT *)0);
}
}
#line 1263 "/home/khheo/project/mit-scheme-9.2/src/microcode/lookup.c"
trap_kind_t get_trap_kind(SCHEME_OBJECT object ) 
{ 
  unsigned long datum ;
  unsigned long tmp ;

  {
#line 1266
  if (object >> 58U == 50UL) {
#line 1268
    datum = object & 288230376151711743UL;
#line 1269
    if (datum <= 9UL) {
#line 1269
      tmp = datum;
    } else {
#line 1269
      tmp = *((SCHEME_OBJECT *)(object & 288230376151711743UL) + 0) & 288230376151711743UL;
    }
#line 1269
    return (tmp);
  } else {
#line 1275
    return ((trap_kind_t )32);
  }
}
}
#line 1278 "/home/khheo/project/mit-scheme-9.2/src/microcode/lookup.c"
static unsigned long count_references(SCHEME_OBJECT *palist ) 
{ 
  unsigned long n_references ;
  SCHEME_OBJECT *WR_palist ;
  SCHEME_OBJECT *WR_prefs ;
  SCHEME_OBJECT reference ;

  {
#line 1281
  n_references = 0UL;
#line 1282
  WR_palist = palist;
  {
#line 1282
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1282
    if (! (*WR_palist >> 58U == 1UL)) {
#line 1282
      goto while_break;
    }
#line 1282
    WR_prefs = (SCHEME_OBJECT *)(*((SCHEME_OBJECT *)(*WR_palist & 288230376151711743UL) + 0) & 288230376151711743UL) + 1;
    {
#line 1282
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1282
      if (! (*WR_prefs >> 58U == 1UL)) {
#line 1282
        goto while_break___0;
      }
#line 1282
      reference = *((SCHEME_OBJECT *)(*WR_prefs & 288230376151711743UL) + 0);
#line 1282
      if (*((SCHEME_OBJECT *)(reference & 288230376151711743UL) + 0) == 0UL) {
#line 1282
        *WR_prefs = *((SCHEME_OBJECT *)(*WR_prefs & 288230376151711743UL) + 1);
#line 1282
        goto while_continue___0;
      }
#line 1282
      n_references ++;
      {
#line 1282
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1282
        WR_prefs = (SCHEME_OBJECT *)(*WR_prefs & 288230376151711743UL) + 1;
#line 1282
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1282
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1282
      if (*((SCHEME_OBJECT *)(*((SCHEME_OBJECT *)(*WR_palist & 288230376151711743UL) + 0) & 288230376151711743UL) + 1) >> 58U == 1UL) {
#line 1282
        WR_palist = (SCHEME_OBJECT *)(*WR_palist & 288230376151711743UL) + 1;
      } else {
#line 1282
        *WR_palist = *((SCHEME_OBJECT *)(*WR_palist & 288230376151711743UL) + 1);
      }
#line 1282
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1283
  return (n_references);
}
}
#line 1287 "/home/khheo/project/mit-scheme-9.2/src/microcode/lookup.c"
static SCHEME_OBJECT *find_references_named(SCHEME_OBJECT *palist , SCHEME_OBJECT symbol ) 
{ 


  {
  {
#line 1290
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1290
    if (! (*palist >> 58U == 1UL)) {
#line 1290
      goto while_break;
    }
#line 1292
    if (*((SCHEME_OBJECT *)(*((SCHEME_OBJECT *)(*palist & 288230376151711743UL) + 0) & 288230376151711743UL) + 0) == symbol) {
#line 1293
      return ((SCHEME_OBJECT *)(*((SCHEME_OBJECT *)(*palist & 288230376151711743UL) + 0) & 288230376151711743UL) + 1);
    }
#line 1294
    palist = (SCHEME_OBJECT *)(*palist & 288230376151711743UL) + 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 1296
  return ((SCHEME_OBJECT *)0);
}
}
#line 1300 "/home/khheo/project/mit-scheme-9.2/src/microcode/lookup.c"
static void update_assignment_references(SCHEME_OBJECT cache ) 
{ 
  SCHEME_OBJECT reference_cache ;
  SCHEME_OBJECT tmp ;
  SCHEME_OBJECT *WR_palist ;
  SCHEME_OBJECT *WR_prefs ;
  SCHEME_OBJECT reference ;

  {
#line 1304
  if (*((SCHEME_OBJECT *)(cache & 288230376151711743UL) + 1) != 0UL) {
#line 1304
    tmp = *((SCHEME_OBJECT *)(cache & 288230376151711743UL) + 1);
  } else {
#line 1304
    tmp = cache;
  }
#line 1304
  reference_cache = tmp;
#line 1308
  WR_palist = (SCHEME_OBJECT *)(*((SCHEME_OBJECT *)(cache & 288230376151711743UL) + 2) & 288230376151711743UL) + 1;
  {
#line 1308
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1308
    if (! (*WR_palist >> 58U == 1UL)) {
#line 1308
      goto while_break;
    }
#line 1308
    WR_prefs = (SCHEME_OBJECT *)(*((SCHEME_OBJECT *)(*WR_palist & 288230376151711743UL) + 0) & 288230376151711743UL) + 1;
    {
#line 1308
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1308
      if (! (*WR_prefs >> 58U == 1UL)) {
#line 1308
        goto while_break___0;
      }
#line 1308
      reference = *((SCHEME_OBJECT *)(*WR_prefs & 288230376151711743UL) + 0);
#line 1308
      if (*((SCHEME_OBJECT *)(reference & 288230376151711743UL) + 0) == 0UL) {
#line 1308
        *WR_prefs = *((SCHEME_OBJECT *)(*WR_prefs & 288230376151711743UL) + 1);
#line 1308
        goto while_continue___0;
      }
      {
#line 1308
      write_variable_cache(reference_cache, *((SCHEME_OBJECT *)(reference & 288230376151711743UL) + 0),
                           *((SCHEME_OBJECT *)(reference & 288230376151711743UL) + 1) & 288230376151711743UL);
      }
      {
#line 1308
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1308
        WR_prefs = (SCHEME_OBJECT *)(*WR_prefs & 288230376151711743UL) + 1;
#line 1308
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1308
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1308
      if (*((SCHEME_OBJECT *)(*((SCHEME_OBJECT *)(*WR_palist & 288230376151711743UL) + 0) & 288230376151711743UL) + 1) >> 58U == 1UL) {
#line 1308
        WR_palist = (SCHEME_OBJECT *)(*WR_palist & 288230376151711743UL) + 1;
      } else {
#line 1308
        *WR_palist = *((SCHEME_OBJECT *)(*WR_palist & 288230376151711743UL) + 1);
      }
#line 1308
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1318
  return;
}
}
#line 1320 "/home/khheo/project/mit-scheme-9.2/src/microcode/lookup.c"
static long guarantee_cache(SCHEME_OBJECT *cell ) 
{ 
  SCHEME_OBJECT references ;
  SCHEME_OBJECT cache ;
  trap_kind_t tmp ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;
  SCHEME_OBJECT *tmp___2 ;
  SCHEME_OBJECT *tmp___3 ;
  SCHEME_OBJECT *tmp___4 ;
  SCHEME_OBJECT *tmp___5 ;
  long RIE_result ;
  long tmp___6 ;
  SCHEME_OBJECT *tmp___7 ;
  SCHEME_OBJECT *tmp___8 ;
  SCHEME_OBJECT *tmp___9 ;
  SCHEME_OBJECT *tmp___10 ;
  SCHEME_OBJECT *tmp___11 ;

  {
  {
#line 1326
  tmp = get_trap_kind(*cell);
  }
#line 1326
  if (tmp == 14UL) {
#line 1327
    return (-1L);
  }
#line 1329
  if ((unsigned long )Free >= (unsigned long )heap_start) {
#line 1329
    if ((unsigned long )Free < (unsigned long )heap_alloc_limit) {
#line 1329
      if (! ((unsigned long )(Free + 3) <= (unsigned long )heap_alloc_limit)) {
#line 1329
        goto _L___0;
      }
    } else {
#line 1329
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1329
  if ((Registers[1] & 4UL) != 0UL) {
    {
#line 1329
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1329
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 1329
        set_ulong_register(12U, Registers[12] | 4UL);
        }
        {
#line 1329
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1329
          if ((Registers[1] & Registers[12]) != 0UL) {
#line 1329
            tmp___1 = memory_block_start;
          } else {
#line 1329
            if ((Registers[1] & 4UL) != 0UL) {
#line 1329
              tmp___0 = heap_alloc_limit;
            } else {
#line 1329
              tmp___0 = heap_end;
            }
#line 1329
            tmp___1 = tmp___0;
          }
          {
#line 1329
          set_ptr_register(0U, tmp___1);
          }
#line 1329
          if ((Registers[1] & 1UL) != 0UL) {
#line 1329
            tmp___2 = stack_guard;
          } else {
#line 1329
            tmp___2 = stack_start;
          }
          {
#line 1329
          set_ptr_register(11U, tmp___2);
          }
#line 1329
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1329
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1329
      gc_space_needed = 3UL;
#line 1329
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 1329
    return (-4L);
  }
  {
#line 1330
  references = (36UL << 58U) | (SCHEME_OBJECT )Free;
#line 1331
  tmp___3 = Free;
#line 1331
  Free ++;
#line 1331
  *tmp___3 = (8UL << 58U) | 9UL;
#line 1332
  tmp___4 = Free;
#line 1332
  Free ++;
#line 1332
  *tmp___4 = (8UL << 58U) | 9UL;
#line 1333
  tmp___5 = Free;
#line 1333
  Free ++;
#line 1333
  *tmp___5 = (8UL << 58U) | 9UL;
#line 1335
  tmp___6 = make_cache(*cell, 0UL, references, & cache);
#line 1335
  RIE_result = tmp___6;
  }
#line 1335
  if (RIE_result != -1L) {
#line 1335
    return (RIE_result);
  }
#line 1337
  if ((unsigned long )Free >= (unsigned long )heap_start) {
#line 1337
    if ((unsigned long )Free < (unsigned long )heap_alloc_limit) {
#line 1337
      if (! ((unsigned long )(Free + 2) <= (unsigned long )heap_alloc_limit)) {
#line 1337
        goto _L___2;
      }
    } else {
#line 1337
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 1337
  if ((Registers[1] & 4UL) != 0UL) {
    {
#line 1337
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 1337
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 1337
        set_ulong_register(12U, Registers[12] | 4UL);
        }
        {
#line 1337
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 1337
          if ((Registers[1] & Registers[12]) != 0UL) {
#line 1337
            tmp___8 = memory_block_start;
          } else {
#line 1337
            if ((Registers[1] & 4UL) != 0UL) {
#line 1337
              tmp___7 = heap_alloc_limit;
            } else {
#line 1337
              tmp___7 = heap_end;
            }
#line 1337
            tmp___8 = tmp___7;
          }
          {
#line 1337
          set_ptr_register(0U, tmp___8);
          }
#line 1337
          if ((Registers[1] & 1UL) != 0UL) {
#line 1337
            tmp___9 = stack_guard;
          } else {
#line 1337
            tmp___9 = stack_start;
          }
          {
#line 1337
          set_ptr_register(11U, tmp___9);
          }
#line 1337
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 1337
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 1337
      gc_space_needed = 2UL;
#line 1337
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1337
    return (-4L);
  }
#line 1338
  tmp___10 = Free;
#line 1338
  Free ++;
#line 1338
  *tmp___10 = (26UL << 58U) | 14UL;
#line 1339
  tmp___11 = Free;
#line 1339
  Free ++;
#line 1339
  *tmp___11 = cache;
#line 1340
  *cell = (50UL << 58U) | (SCHEME_OBJECT )(Free - 2);
#line 1341
  return (-1L);
}
}
#line 1344 "/home/khheo/project/mit-scheme-9.2/src/microcode/lookup.c"
static void update_clone(SCHEME_OBJECT cache ) 
{ 
  SCHEME_OBJECT clone ;
  long tmp ;
  char *__cil_tmp4 ;

  {
#line 1347
  if (*((SCHEME_OBJECT *)(*((SCHEME_OBJECT *)(cache & 288230376151711743UL) + 2) & 288230376151711743UL) + 1) >> 58U == 1UL) {
#line 1347
    if (*((SCHEME_OBJECT *)(*((SCHEME_OBJECT *)(cache & 288230376151711743UL) + 2) & 288230376151711743UL) + 2) >> 58U == 1UL) {
#line 1350
      if (*((SCHEME_OBJECT *)(cache & 288230376151711743UL) + 1) == 0UL) {
        {
#line 1353
        tmp = make_cache((50UL << 58U) | 6UL, cache, *((SCHEME_OBJECT *)(cache & 288230376151711743UL) + 2),
                         & clone);
        }
#line 1353
        if (tmp != -1L) {
          {
#line 1353
          outf_fatal("\nRan out of guaranteed space!\n");
#line 1353
          Microcode_Termination(12);
          }
        }
        {
#line 1358
        *((SCHEME_OBJECT *)(cache & 288230376151711743UL) + 1) = clone;
#line 1359
        update_assignment_references(cache);
        }
      }
    } else {
#line 1347
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1364
  if (*((SCHEME_OBJECT *)(cache & 288230376151711743UL) + 1) != 0UL) {
    {
#line 1366
    *((SCHEME_OBJECT *)(cache & 288230376151711743UL) + 1) = 0UL;
#line 1367
    update_assignment_references(cache);
    }
  }
#line 1370
  return;
}
}
#line 1372 "/home/khheo/project/mit-scheme-9.2/src/microcode/lookup.c"
static long make_cache(SCHEME_OBJECT value , SCHEME_OBJECT clone , SCHEME_OBJECT references ,
                       SCHEME_OBJECT *cache_ret ) 
{ 
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;
  SCHEME_OBJECT *tmp___2 ;
  SCHEME_OBJECT *tmp___3 ;
  SCHEME_OBJECT *tmp___4 ;

  {
#line 1376
  if ((unsigned long )Free >= (unsigned long )heap_start) {
#line 1376
    if ((unsigned long )Free < (unsigned long )heap_alloc_limit) {
#line 1376
      if (! ((unsigned long )(Free + 3) <= (unsigned long )heap_alloc_limit)) {
#line 1376
        goto _L___0;
      }
    } else {
#line 1376
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1376
  if ((Registers[1] & 4UL) != 0UL) {
    {
#line 1376
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1376
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 1376
        set_ulong_register(12U, Registers[12] | 4UL);
        }
        {
#line 1376
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1376
          if ((Registers[1] & Registers[12]) != 0UL) {
#line 1376
            tmp___0 = memory_block_start;
          } else {
#line 1376
            if ((Registers[1] & 4UL) != 0UL) {
#line 1376
              tmp = heap_alloc_limit;
            } else {
#line 1376
              tmp = heap_end;
            }
#line 1376
            tmp___0 = tmp;
          }
          {
#line 1376
          set_ptr_register(0U, tmp___0);
          }
#line 1376
          if ((Registers[1] & 1UL) != 0UL) {
#line 1376
            tmp___1 = stack_guard;
          } else {
#line 1376
            tmp___1 = stack_start;
          }
          {
#line 1376
          set_ptr_register(11U, tmp___1);
          }
#line 1376
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1376
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1376
      gc_space_needed = 3UL;
#line 1376
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 1376
    return (-4L);
  }
#line 1377
  tmp___2 = Free;
#line 1377
  Free ++;
#line 1377
  *tmp___2 = value;
#line 1378
  tmp___3 = Free;
#line 1378
  Free ++;
#line 1378
  *tmp___3 = clone;
#line 1379
  tmp___4 = Free;
#line 1379
  Free ++;
#line 1379
  *tmp___4 = references;
#line 1380
  *cache_ret = (36UL << 58U) | (SCHEME_OBJECT )(Free - 3);
#line 1381
  return (-1L);
}
}
#line 1385 "/home/khheo/project/mit-scheme-9.2/src/microcode/lookup.c"
static long make_cache_reference(SCHEME_OBJECT block , unsigned long offset , SCHEME_OBJECT *ref_ret ) 
{ 
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;
  SCHEME_OBJECT *tmp___2 ;
  SCHEME_OBJECT *tmp___3 ;

  {
#line 1389
  if ((unsigned long )Free >= (unsigned long )heap_start) {
#line 1389
    if ((unsigned long )Free < (unsigned long )heap_alloc_limit) {
#line 1389
      if (! ((unsigned long )(Free + 2) <= (unsigned long )heap_alloc_limit)) {
#line 1389
        goto _L___0;
      }
    } else {
#line 1389
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1389
  if ((Registers[1] & 4UL) != 0UL) {
    {
#line 1389
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1389
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 1389
        set_ulong_register(12U, Registers[12] | 4UL);
        }
        {
#line 1389
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1389
          if ((Registers[1] & Registers[12]) != 0UL) {
#line 1389
            tmp___0 = memory_block_start;
          } else {
#line 1389
            if ((Registers[1] & 4UL) != 0UL) {
#line 1389
              tmp = heap_alloc_limit;
            } else {
#line 1389
              tmp = heap_end;
            }
#line 1389
            tmp___0 = tmp;
          }
          {
#line 1389
          set_ptr_register(0U, tmp___0);
          }
#line 1389
          if ((Registers[1] & 1UL) != 0UL) {
#line 1389
            tmp___1 = stack_guard;
          } else {
#line 1389
            tmp___1 = stack_start;
          }
          {
#line 1389
          set_ptr_register(11U, tmp___1);
          }
#line 1389
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1389
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1389
      gc_space_needed = 2UL;
#line 1389
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 1389
    return (-4L);
  }
#line 1390
  tmp___2 = Free;
#line 1390
  Free ++;
#line 1390
  *tmp___2 = block;
#line 1391
  tmp___3 = Free;
#line 1391
  Free ++;
#line 1391
  *tmp___3 = (26UL << 58U) | offset;
#line 1392
  *ref_ret = (55UL << 58U) | (SCHEME_OBJECT )(Free - 2);
#line 1393
  return (-1L);
}
}
#line 47 "/home/khheo/project/mit-scheme-9.2/src/microcode/lookprm.c"
SCHEME_OBJECT Prim_lexical_reference(void) 
{ 
  SCHEME_OBJECT value ;
  long SL_result ;
  long tmp ;

  {
  {
#line 53
  while (1) {
    while_continue: /* CIL Label */ ;
#line 53
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 54
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 54
    if (! (*(stack_pointer + 0) >> 58U == 18UL)) {
#line 54
      if (! (*(stack_pointer + 0) == 0UL)) {
        {
#line 54
        error_wrong_type_arg(1);
        }
      }
    }
#line 54
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 55
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 55
    if (! (*(stack_pointer + 1) >> 58U == 29UL)) {
#line 55
      if (! (*(stack_pointer + 1) >> 58U == 5UL)) {
        {
#line 55
        error_wrong_type_arg(2);
        }
      }
    }
#line 55
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 58
  tmp = lookup_variable(*(stack_pointer + 0), *(stack_pointer + 1), & value);
#line 58
  SL_result = tmp;
  }
#line 58
  if (SL_result != -1L) {
#line 58
    if (SL_result == -4L) {
      {
#line 58
      signal_interrupt_from_primitive();
      }
    } else {
      {
#line 58
      signal_error_from_primitive(SL_result);
      }
    }
  }
#line 59
  return (value);
}
}
#line 63 "/home/khheo/project/mit-scheme-9.2/src/microcode/lookprm.c"
SCHEME_OBJECT Prim_local_reference(void) 
{ 
  SCHEME_OBJECT value ;
  long SL_result ;
  long tmp ;

  {
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
#line 67
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 68
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 68
    if (! (*(stack_pointer + 0) >> 58U == 18UL)) {
#line 68
      if (! (*(stack_pointer + 0) == 0UL)) {
        {
#line 68
        error_wrong_type_arg(1);
        }
      }
    }
#line 68
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 69
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 69
    if (! (*(stack_pointer + 1) >> 58U == 29UL)) {
#line 69
      if (! (*(stack_pointer + 1) >> 58U == 5UL)) {
        {
#line 69
        error_wrong_type_arg(2);
        }
      }
    }
#line 69
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 72
  tmp = lookup_variable(*(stack_pointer + 0), *(stack_pointer + 1), & value);
#line 72
  SL_result = tmp;
  }
#line 72
  if (SL_result != -1L) {
#line 72
    if (SL_result == -4L) {
      {
#line 72
      signal_interrupt_from_primitive();
      }
    } else {
      {
#line 72
      signal_error_from_primitive(SL_result);
      }
    }
  }
#line 73
  return (value);
}
}
#line 77 "/home/khheo/project/mit-scheme-9.2/src/microcode/lookprm.c"
SCHEME_OBJECT Prim_lexical_assignment(void) 
{ 
  SCHEME_OBJECT value ;
  long SL_result ;
  long tmp ;

  {
  {
#line 84
  while (1) {
    while_continue: /* CIL Label */ ;
#line 84
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 85
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 85
    if (! (*(stack_pointer + 0) >> 58U == 18UL)) {
#line 85
      if (! (*(stack_pointer + 0) == 0UL)) {
        {
#line 85
        error_wrong_type_arg(1);
        }
      }
    }
#line 85
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 86
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 86
    if (! (*(stack_pointer + 1) >> 58U == 29UL)) {
#line 86
      if (! (*(stack_pointer + 1) >> 58U == 5UL)) {
        {
#line 86
        error_wrong_type_arg(2);
        }
      }
    }
#line 86
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 89
  tmp = assign_variable(*(stack_pointer + 0), *(stack_pointer + 1), *(stack_pointer + 2),
                        & value);
#line 89
  SL_result = tmp;
  }
#line 89
  if (SL_result != -1L) {
#line 89
    if (SL_result == -4L) {
      {
#line 89
      signal_interrupt_from_primitive();
      }
    } else {
      {
#line 89
      signal_error_from_primitive(SL_result);
      }
    }
  }
#line 92
  return (value);
}
}
#line 96 "/home/khheo/project/mit-scheme-9.2/src/microcode/lookprm.c"
SCHEME_OBJECT Prim_local_assignment(void) 
{ 
  long SL_result ;
  long tmp ;

  {
  {
#line 107
  while (1) {
    while_continue: /* CIL Label */ ;
#line 107
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 108
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 108
    if (! (*(stack_pointer + 0) >> 58U == 18UL)) {
#line 108
      if (! (*(stack_pointer + 0) == 0UL)) {
        {
#line 108
        error_wrong_type_arg(1);
        }
      }
    }
#line 108
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 109
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 109
    if (! (*(stack_pointer + 1) >> 58U == 29UL)) {
#line 109
      if (! (*(stack_pointer + 1) >> 58U == 5UL)) {
        {
#line 109
        error_wrong_type_arg(2);
        }
      }
    }
#line 109
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 110
  tmp = define_variable(*(stack_pointer + 0), *(stack_pointer + 1), *(stack_pointer + 2));
#line 110
  SL_result = tmp;
  }
#line 110
  if (SL_result != -1L) {
#line 110
    if (SL_result == -4L) {
      {
#line 110
      signal_interrupt_from_primitive();
      }
    } else {
      {
#line 110
      signal_error_from_primitive(SL_result);
      }
    }
  }
#line 111
  return (*(stack_pointer + 1));
}
}
#line 114 "/home/khheo/project/mit-scheme-9.2/src/microcode/lookprm.c"
SCHEME_OBJECT Prim_lexical_reference_type(void) 
{ 
  SCHEME_OBJECT value ;
  long result ;
  long tmp ;

  {
  {
#line 124
  while (1) {
    while_continue: /* CIL Label */ ;
#line 124
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 125
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 125
    if (! (*(stack_pointer + 0) >> 58U == 18UL)) {
#line 125
      if (! (*(stack_pointer + 0) == 0UL)) {
        {
#line 125
        error_wrong_type_arg(1);
        }
      }
    }
#line 125
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 126
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 126
    if (! (*(stack_pointer + 1) >> 58U == 29UL)) {
#line 126
      if (! (*(stack_pointer + 1) >> 58U == 5UL)) {
        {
#line 126
        error_wrong_type_arg(2);
        }
      }
    }
#line 126
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 129
  tmp = lookup_variable(*(stack_pointer + 0), *(stack_pointer + 1), & value);
#line 129
  result = tmp;
  }
  {
#line 132
  if (result == 1L) {
#line 132
    goto case_1;
  }
#line 134
  if (result == 2L) {
#line 134
    goto case_2;
  }
#line 136
  if (result == -1L) {
#line 136
    goto case_neg_1;
  }
#line 138
  if (result == 19L) {
#line 138
    goto case_19;
  }
#line 140
  if (result == -4L) {
#line 140
    goto case_neg_4;
  }
#line 143
  goto switch_default;
  case_1: /* CIL Label */ 
#line 133
  return (26UL << 58U);
  case_2: /* CIL Label */ 
#line 135
  return ((26UL << 58U) | 1UL);
  case_neg_1: /* CIL Label */ 
#line 137
  return ((26UL << 58U) | 2UL);
  case_19: /* CIL Label */ 
#line 139
  return ((26UL << 58U) | 3UL);
  case_neg_4: /* CIL Label */ 
  {
#line 141
  signal_interrupt_from_primitive();
  }
#line 142
  return ((8UL << 58U) | 1UL);
  switch_default: /* CIL Label */ 
  {
#line 144
  signal_error_from_primitive(result);
  }
#line 145
  return ((8UL << 58U) | 1UL);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 150 "/home/khheo/project/mit-scheme-9.2/src/microcode/lookprm.c"
SCHEME_OBJECT Prim_safe_lexical_reference(void) 
{ 
  SCHEME_OBJECT value ;
  long result ;
  long tmp ;

  {
  {
#line 157
  while (1) {
    while_continue: /* CIL Label */ ;
#line 157
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 158
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 158
    if (! (*(stack_pointer + 0) >> 58U == 18UL)) {
#line 158
      if (! (*(stack_pointer + 0) == 0UL)) {
        {
#line 158
        error_wrong_type_arg(1);
        }
      }
    }
#line 158
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 159
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 159
    if (! (*(stack_pointer + 1) >> 58U == 29UL)) {
#line 159
      if (! (*(stack_pointer + 1) >> 58U == 5UL)) {
        {
#line 159
        error_wrong_type_arg(2);
        }
      }
    }
#line 159
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 162
  tmp = lookup_variable(*(stack_pointer + 0), *(stack_pointer + 1), & value);
#line 162
  result = tmp;
  }
  {
#line 166
  if (result == 19L) {
#line 166
    goto case_19;
  }
#line 166
  if (result == -1L) {
#line 166
    goto case_19;
  }
#line 168
  if (result == 2L) {
#line 168
    goto case_2;
  }
#line 170
  if (result == -4L) {
#line 170
    goto case_neg_4;
  }
#line 173
  goto switch_default;
  case_19: /* CIL Label */ 
  case_neg_1: /* CIL Label */ 
#line 167
  return (value);
  case_2: /* CIL Label */ 
#line 169
  return (50UL << 58U);
  case_neg_4: /* CIL Label */ 
  {
#line 171
  signal_interrupt_from_primitive();
  }
#line 172
  return ((8UL << 58U) | 1UL);
  switch_default: /* CIL Label */ 
  {
#line 174
  signal_error_from_primitive(result);
  }
#line 175
  return ((8UL << 58U) | 1UL);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 180 "/home/khheo/project/mit-scheme-9.2/src/microcode/lookprm.c"
SCHEME_OBJECT Prim_unassigned_test(void) 
{ 
  SCHEME_OBJECT value ;
  long SL_result ;
  long tmp ;

  {
  {
#line 188
  while (1) {
    while_continue: /* CIL Label */ ;
#line 188
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 189
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 189
    if (! (*(stack_pointer + 0) >> 58U == 18UL)) {
#line 189
      if (! (*(stack_pointer + 0) == 0UL)) {
        {
#line 189
        error_wrong_type_arg(1);
        }
      }
    }
#line 189
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 190
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 190
    if (! (*(stack_pointer + 1) >> 58U == 29UL)) {
#line 190
      if (! (*(stack_pointer + 1) >> 58U == 5UL)) {
        {
#line 190
        error_wrong_type_arg(2);
        }
      }
    }
#line 190
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 193
  tmp = variable_unassigned_p(*(stack_pointer + 0), *(stack_pointer + 1), & value);
#line 193
  SL_result = tmp;
  }
#line 193
  if (SL_result != -1L) {
#line 193
    if (SL_result == -4L) {
      {
#line 193
      signal_interrupt_from_primitive();
      }
    } else {
      {
#line 193
      signal_error_from_primitive(SL_result);
      }
    }
  }
#line 195
  return (value);
}
}
#line 199 "/home/khheo/project/mit-scheme-9.2/src/microcode/lookprm.c"
SCHEME_OBJECT Prim_unbound_test(void) 
{ 
  SCHEME_OBJECT value ;
  long SL_result ;
  long tmp ;

  {
  {
#line 205
  while (1) {
    while_continue: /* CIL Label */ ;
#line 205
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 206
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 206
    if (! (*(stack_pointer + 0) >> 58U == 18UL)) {
#line 206
      if (! (*(stack_pointer + 0) == 0UL)) {
        {
#line 206
        error_wrong_type_arg(1);
        }
      }
    }
#line 206
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 207
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 207
    if (! (*(stack_pointer + 1) >> 58U == 29UL)) {
#line 207
      if (! (*(stack_pointer + 1) >> 58U == 5UL)) {
        {
#line 207
        error_wrong_type_arg(2);
        }
      }
    }
#line 207
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 210
  tmp = variable_unbound_p(*(stack_pointer + 0), *(stack_pointer + 1), & value);
#line 210
  SL_result = tmp;
  }
#line 210
  if (SL_result != -1L) {
#line 210
    if (SL_result == -4L) {
      {
#line 210
      signal_interrupt_from_primitive();
      }
    } else {
      {
#line 210
      signal_error_from_primitive(SL_result);
      }
    }
  }
#line 211
  return (value);
}
}
#line 215 "/home/khheo/project/mit-scheme-9.2/src/microcode/lookprm.c"
SCHEME_OBJECT Prim_unreferenceable_test(void) 
{ 
  SCHEME_OBJECT value ;
  long SL_result ;
  long tmp ;

  {
  {
#line 220
  while (1) {
    while_continue: /* CIL Label */ ;
#line 220
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 223
  tmp = variable_unreferenceable_p(*(stack_pointer + 0), *(stack_pointer + 1), & value);
#line 223
  SL_result = tmp;
  }
#line 223
  if (SL_result != -1L) {
#line 223
    if (SL_result == -4L) {
      {
#line 223
      signal_interrupt_from_primitive();
      }
    } else {
      {
#line 223
      signal_error_from_primitive(SL_result);
      }
    }
  }
#line 225
  return (value);
}
}
#line 229 "/home/khheo/project/mit-scheme-9.2/src/microcode/lookprm.c"
SCHEME_OBJECT Prim_environment_link_name(void) 
{ 
  long SL_result ;
  long tmp ;

  {
  {
#line 235
  while (1) {
    while_continue: /* CIL Label */ ;
#line 235
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 236
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 236
    if (! (*(stack_pointer + 0) >> 58U == 18UL)) {
#line 236
      if (! (*(stack_pointer + 0) == 0UL)) {
        {
#line 236
        error_wrong_type_arg(1);
        }
      }
    }
#line 236
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 237
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 237
    if (! (*(stack_pointer + 1) >> 58U == 18UL)) {
#line 237
      if (! (*(stack_pointer + 1) == 0UL)) {
        {
#line 237
        error_wrong_type_arg(2);
        }
      }
    }
#line 237
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 238
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 238
    if (! (*(stack_pointer + 2) >> 58U == 29UL)) {
#line 238
      if (! (*(stack_pointer + 2) >> 58U == 5UL)) {
        {
#line 238
        error_wrong_type_arg(3);
        }
      }
    }
#line 238
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 239
  tmp = link_variables(*(stack_pointer + 0), *(stack_pointer + 2), *(stack_pointer + 1),
                       *(stack_pointer + 2));
#line 239
  SL_result = tmp;
  }
#line 239
  if (SL_result != -1L) {
#line 239
    if (SL_result == -4L) {
      {
#line 239
      signal_interrupt_from_primitive();
      }
    } else {
      {
#line 239
      signal_error_from_primitive(SL_result);
      }
    }
  }
#line 242
  return ((8UL << 58U) | 1UL);
}
}
#line 245 "/home/khheo/project/mit-scheme-9.2/src/microcode/lookprm.c"
SCHEME_OBJECT Prim_link_variables(void) 
{ 
  long SL_result ;
  long tmp ;

  {
  {
#line 251
  while (1) {
    while_continue: /* CIL Label */ ;
#line 251
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 252
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 252
    if (! (*(stack_pointer + 0) >> 58U == 18UL)) {
#line 252
      if (! (*(stack_pointer + 0) == 0UL)) {
        {
#line 252
        error_wrong_type_arg(1);
        }
      }
    }
#line 252
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 253
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 253
    if (! (*(stack_pointer + 1) >> 58U == 29UL)) {
#line 253
      if (! (*(stack_pointer + 1) >> 58U == 5UL)) {
        {
#line 253
        error_wrong_type_arg(2);
        }
      }
    }
#line 253
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 254
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 254
    if (! (*(stack_pointer + 2) >> 58U == 18UL)) {
#line 254
      if (! (*(stack_pointer + 2) == 0UL)) {
        {
#line 254
        error_wrong_type_arg(3);
        }
      }
    }
#line 254
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 255
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 255
    if (! (*(stack_pointer + 3) >> 58U == 29UL)) {
#line 255
      if (! (*(stack_pointer + 3) >> 58U == 5UL)) {
        {
#line 255
        error_wrong_type_arg(4);
        }
      }
    }
#line 255
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 256
  tmp = link_variables(*(stack_pointer + 0), *(stack_pointer + 1), *(stack_pointer + 2),
                       *(stack_pointer + 3));
#line 256
  SL_result = tmp;
  }
#line 256
  if (SL_result != -1L) {
#line 256
    if (SL_result == -4L) {
      {
#line 256
      signal_interrupt_from_primitive();
      }
    } else {
      {
#line 256
      signal_error_from_primitive(SL_result);
      }
    }
  }
#line 259
  return ((8UL << 58U) | 1UL);
}
}
#line 262 "/home/khheo/project/mit-scheme-9.2/src/microcode/lookprm.c"
SCHEME_OBJECT Prim_unbind_variable(void) 
{ 
  SCHEME_OBJECT value ;
  long SL_result ;
  long tmp ;

  {
  {
#line 267
  while (1) {
    while_continue: /* CIL Label */ ;
#line 267
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 268
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 268
    if (! (*(stack_pointer + 0) >> 58U == 18UL)) {
#line 268
      if (! (*(stack_pointer + 0) == 0UL)) {
        {
#line 268
        error_wrong_type_arg(1);
        }
      }
    }
#line 268
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 269
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 269
    if (! (*(stack_pointer + 1) >> 58U == 29UL)) {
#line 269
      if (! (*(stack_pointer + 1) >> 58U == 5UL)) {
        {
#line 269
        error_wrong_type_arg(2);
        }
      }
    }
#line 269
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 272
  tmp = unbind_variable(*(stack_pointer + 0), *(stack_pointer + 1), & value);
#line 272
  SL_result = tmp;
  }
#line 272
  if (SL_result != -1L) {
#line 272
    if (SL_result == -4L) {
      {
#line 272
      signal_interrupt_from_primitive();
      }
    } else {
      {
#line 272
      signal_error_from_primitive(SL_result);
      }
    }
  }
#line 273
  return (value);
}
}
#line 282 "/home/khheo/project/mit-scheme-9.2/src/microcode/extern.h"
SCHEME_OBJECT system_pair_cons(long type , SCHEME_OBJECT car , SCHEME_OBJECT cdr ) ;
#line 32 "/home/khheo/project/mit-scheme-9.2/src/microcode/list.c"
SCHEME_OBJECT Prim_pair(void) 
{ 
  SCHEME_OBJECT object ;
  unsigned long tmp ;

  {
  {
#line 38
  while (1) {
    while_continue: /* CIL Label */ ;
#line 38
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 39
  object = *(stack_pointer + 0);
#line 40
  if (object >> 58U == 1UL) {
#line 40
    tmp = 8UL << 58U;
  } else {
#line 40
    tmp = 0UL;
  }
#line 40
  return (tmp);
}
}
#line 43 "/home/khheo/project/mit-scheme-9.2/src/microcode/list.c"
SCHEME_OBJECT cons(SCHEME_OBJECT car , SCHEME_OBJECT cdr ) 
{ 
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;
  SCHEME_OBJECT *tmp___2 ;
  SCHEME_OBJECT *tmp___3 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 47
  while (1) {
    while_continue: /* CIL Label */ ;
#line 47
    if ((unsigned long )Free >= (unsigned long )heap_start) {
#line 47
      if ((unsigned long )Free < (unsigned long )heap_alloc_limit) {
#line 47
        if (! ((unsigned long )(Free + 2) <= (unsigned long )heap_alloc_limit)) {
#line 47
          goto _L___0;
        }
      } else {
#line 47
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 47
    if ((Registers[1] & 4UL) != 0UL) {
      {
#line 47
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 47
        if ((unsigned long )Free_primitive < (unsigned long )heap_start) {
          {
#line 47
          outf_fatal("\nMicrocode requested primitive GC outside primitive!\n");
#line 47
          Microcode_Termination(12);
          }
        }
#line 47
        if ((unsigned long )Free < (unsigned long )Free_primitive) {
          {
#line 47
          outf_fatal("\nFree has gone backwards!\n");
#line 47
          Microcode_Termination(12);
          }
        }
        {
#line 47
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 47
          while (1) {
            while_continue___2: /* CIL Label */ ;
            {
#line 47
            set_ulong_register(12U, Registers[12] | 4UL);
            }
            {
#line 47
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 47
              if ((Registers[1] & Registers[12]) != 0UL) {
#line 47
                tmp___0 = memory_block_start;
              } else {
#line 47
                if ((Registers[1] & 4UL) != 0UL) {
#line 47
                  tmp = heap_alloc_limit;
                } else {
#line 47
                  tmp = heap_end;
                }
#line 47
                tmp___0 = tmp;
              }
              {
#line 47
              set_ptr_register(0U, tmp___0);
              }
#line 47
              if ((Registers[1] & 1UL) != 0UL) {
#line 47
                tmp___1 = stack_guard;
              } else {
#line 47
                tmp___1 = stack_start;
              }
              {
#line 47
              set_ptr_register(11U, tmp___1);
              }
#line 47
              goto while_break___3;
            }
            while_break___3: /* CIL Label */ ;
            }
#line 47
            goto while_break___2;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 47
          gc_space_needed = (unsigned long )(2L + (Free - Free_primitive));
#line 47
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 47
        signal_interrupt_from_primitive();
        }
#line 47
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 47
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 48
  tmp___2 = Free;
#line 48
  Free ++;
#line 48
  *tmp___2 = car;
#line 49
  tmp___3 = Free;
#line 49
  Free ++;
#line 49
  *tmp___3 = cdr;
#line 50
  return ((1UL << 58U) | (SCHEME_OBJECT )(Free - 2));
}
}
#line 53 "/home/khheo/project/mit-scheme-9.2/src/microcode/list.c"
SCHEME_OBJECT Prim_cons(void) 
{ 
  SCHEME_OBJECT tmp ;

  {
  {
#line 60
  while (1) {
    while_continue: /* CIL Label */ ;
#line 60
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 61
  tmp = cons(*(stack_pointer + 0), *(stack_pointer + 1));
  }
#line 61
  return (tmp);
}
}
#line 64 "/home/khheo/project/mit-scheme-9.2/src/microcode/list.c"
SCHEME_OBJECT Prim_car(void) 
{ 


  {
  {
#line 70
  while (1) {
    while_continue: /* CIL Label */ ;
#line 70
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 71
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 71
    if (! (*(stack_pointer + 0) >> 58U == 1UL)) {
      {
#line 71
      error_wrong_type_arg(1);
      }
    }
#line 71
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 72
  return (*((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 0));
}
}
#line 75 "/home/khheo/project/mit-scheme-9.2/src/microcode/list.c"
SCHEME_OBJECT Prim_cdr(void) 
{ 


  {
  {
#line 81
  while (1) {
    while_continue: /* CIL Label */ ;
#line 81
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 82
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 82
    if (! (*(stack_pointer + 0) >> 58U == 1UL)) {
      {
#line 82
      error_wrong_type_arg(1);
      }
    }
#line 82
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 83
  return (*((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 1));
}
}
#line 86 "/home/khheo/project/mit-scheme-9.2/src/microcode/list.c"
SCHEME_OBJECT Prim_set_car(void) 
{ 
  SCHEME_OBJECT pair ;
  SCHEME_OBJECT car ;

  {
  {
#line 92
  while (1) {
    while_continue: /* CIL Label */ ;
#line 92
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 93
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 93
    if (! (*(stack_pointer + 0) >> 58U == 1UL)) {
      {
#line 93
      error_wrong_type_arg(1);
      }
    }
#line 93
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 95
  pair = *(stack_pointer + 0);
#line 96
  car = *(stack_pointer + 1);
#line 97
  *((SCHEME_OBJECT *)(pair & 288230376151711743UL) + 0) = car;
#line 99
  return ((8UL << 58U) | 1UL);
}
}
#line 102 "/home/khheo/project/mit-scheme-9.2/src/microcode/list.c"
SCHEME_OBJECT Prim_set_cdr(void) 
{ 
  SCHEME_OBJECT pair ;
  SCHEME_OBJECT cdr ;

  {
  {
#line 108
  while (1) {
    while_continue: /* CIL Label */ ;
#line 108
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 109
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 109
    if (! (*(stack_pointer + 0) >> 58U == 1UL)) {
      {
#line 109
      error_wrong_type_arg(1);
      }
    }
#line 109
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 111
  pair = *(stack_pointer + 0);
#line 112
  cdr = *(stack_pointer + 1);
#line 113
  *((SCHEME_OBJECT *)(pair & 288230376151711743UL) + 1) = cdr;
#line 115
  return ((8UL << 58U) | 1UL);
}
}
#line 126 "/home/khheo/project/mit-scheme-9.2/src/microcode/list.c"
SCHEME_OBJECT Prim_general_car_cdr(void) 
{ 
  SCHEME_OBJECT object ;
  long CAR_CDR_Pattern ;
  long tmp ;

  {
  {
#line 157
  while (1) {
    while_continue: /* CIL Label */ ;
#line 157
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 159
  object = *(stack_pointer + 0);
#line 160
  tmp = arg_nonnegative_integer(2);
#line 160
  CAR_CDR_Pattern = tmp;
  }
  {
#line 161
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 161
    if (! (CAR_CDR_Pattern > 1L)) {
#line 161
      goto while_break___0;
    }
#line 163
    if (! (object >> 58U == 1UL)) {
      {
#line 164
      error_wrong_type_arg(1);
      }
    }
#line 165
    if ((CAR_CDR_Pattern & 1L) == 0L) {
#line 165
      object = *((SCHEME_OBJECT *)(object & 288230376151711743UL) + 1);
    } else {
#line 165
      object = *((SCHEME_OBJECT *)(object & 288230376151711743UL) + 0);
    }
#line 169
    CAR_CDR_Pattern >>= 1;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 171
  return (object);
}
}
#line 175 "/home/khheo/project/mit-scheme-9.2/src/microcode/list.c"
SCHEME_OBJECT Prim_length(void) 
{ 
  SCHEME_OBJECT list ;
  long i ;

  {
#line 181
  i = 0L;
  {
#line 182
  while (1) {
    while_continue: /* CIL Label */ ;
#line 182
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 184
  list = *(stack_pointer + 0);
  {
#line 185
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 185
    if (! (list >> 58U == 1UL)) {
#line 185
      goto while_break___0;
    }
#line 187
    i ++;
#line 188
    list = *((SCHEME_OBJECT *)(list & 288230376151711743UL) + 1);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 190
  if (! (list == ((8UL << 58U) | 9UL))) {
    {
#line 191
    error_wrong_type_arg(1);
    }
  }
#line 192
  return ((26UL << 58U) | (unsigned long )i);
}
}
#line 195 "/home/khheo/project/mit-scheme-9.2/src/microcode/list.c"
SCHEME_OBJECT Prim_memq(void) 
{ 
  SCHEME_OBJECT key ;
  SCHEME_OBJECT list ;
  SCHEME_OBJECT list_key ;

  {
  {
#line 220
  while (1) {
    while_continue: /* CIL Label */ ;
#line 220
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 221
  key = *(stack_pointer + 0);
#line 222
  list = *(stack_pointer + 1);
  {
#line 223
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 223
    if (! (list >> 58U == 1UL)) {
#line 223
      goto while_break___0;
    }
#line 225
    list_key = *((SCHEME_OBJECT *)(list & 288230376151711743UL) + 0);
#line 226
    if (list_key == key) {
#line 227
      return (list);
    }
#line 228
    list = *((SCHEME_OBJECT *)(list & 288230376151711743UL) + 1);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 230
  if (! (list == ((8UL << 58U) | 9UL))) {
    {
#line 231
    error_wrong_type_arg(2);
    }
  }
#line 232
  return (0UL);
}
}
#line 235 "/home/khheo/project/mit-scheme-9.2/src/microcode/list.c"
SCHEME_OBJECT Prim_assq(void) 
{ 
  SCHEME_OBJECT key ;
  SCHEME_OBJECT alist ;
  SCHEME_OBJECT association ;
  SCHEME_OBJECT association_key ;

  {
  {
#line 263
  while (1) {
    while_continue: /* CIL Label */ ;
#line 263
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 265
  key = *(stack_pointer + 0);
#line 266
  alist = *(stack_pointer + 1);
  {
#line 267
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 267
    if (! (alist >> 58U == 1UL)) {
#line 267
      goto while_break___0;
    }
#line 269
    association = *((SCHEME_OBJECT *)(alist & 288230376151711743UL) + 0);
#line 270
    if (! (association >> 58U == 1UL)) {
      {
#line 271
      error_wrong_type_arg(2);
      }
    }
#line 272
    association_key = *((SCHEME_OBJECT *)(association & 288230376151711743UL) + 0);
#line 273
    if (association_key == key) {
#line 274
      return (association);
    }
#line 275
    alist = *((SCHEME_OBJECT *)(alist & 288230376151711743UL) + 1);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 277
  if (! (alist == ((8UL << 58U) | 9UL))) {
    {
#line 278
    error_wrong_type_arg(2);
    }
  }
#line 279
  return (0UL);
}
}
#line 282 "/home/khheo/project/mit-scheme-9.2/src/microcode/list.c"
SCHEME_OBJECT Prim_sys_pair(void) 
{ 
  SCHEME_OBJECT object ;
  unsigned long tmp___0 ;
  gc_type_t tmp___1 ;

  {
  {
#line 285
  while (1) {
    while_continue: /* CIL Label */ ;
#line 285
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 286
  object = *(stack_pointer + 0);
#line 287
  tmp___1 = gc_type_code((unsigned int )(object >> 58U));
  }
#line 287
  if ((int )tmp___1 == 2) {
#line 287
    tmp___0 = 8UL << 58U;
  } else {
#line 287
    tmp___0 = 0UL;
  }
#line 287
  return (tmp___0);
}
}
#line 290 "/home/khheo/project/mit-scheme-9.2/src/microcode/list.c"
SCHEME_OBJECT system_pair_cons(long type , SCHEME_OBJECT car , SCHEME_OBJECT cdr ) 
{ 
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;
  SCHEME_OBJECT *tmp___2 ;
  SCHEME_OBJECT *tmp___3 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 295
  while (1) {
    while_continue: /* CIL Label */ ;
#line 295
    if ((unsigned long )Free >= (unsigned long )heap_start) {
#line 295
      if ((unsigned long )Free < (unsigned long )heap_alloc_limit) {
#line 295
        if (! ((unsigned long )(Free + 2) <= (unsigned long )heap_alloc_limit)) {
#line 295
          goto _L___0;
        }
      } else {
#line 295
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 295
    if ((Registers[1] & 4UL) != 0UL) {
      {
#line 295
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 295
        if ((unsigned long )Free_primitive < (unsigned long )heap_start) {
          {
#line 295
          outf_fatal("\nMicrocode requested primitive GC outside primitive!\n");
#line 295
          Microcode_Termination(12);
          }
        }
#line 295
        if ((unsigned long )Free < (unsigned long )Free_primitive) {
          {
#line 295
          outf_fatal("\nFree has gone backwards!\n");
#line 295
          Microcode_Termination(12);
          }
        }
        {
#line 295
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 295
          while (1) {
            while_continue___2: /* CIL Label */ ;
            {
#line 295
            set_ulong_register(12U, Registers[12] | 4UL);
            }
            {
#line 295
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 295
              if ((Registers[1] & Registers[12]) != 0UL) {
#line 295
                tmp___0 = memory_block_start;
              } else {
#line 295
                if ((Registers[1] & 4UL) != 0UL) {
#line 295
                  tmp = heap_alloc_limit;
                } else {
#line 295
                  tmp = heap_end;
                }
#line 295
                tmp___0 = tmp;
              }
              {
#line 295
              set_ptr_register(0U, tmp___0);
              }
#line 295
              if ((Registers[1] & 1UL) != 0UL) {
#line 295
                tmp___1 = stack_guard;
              } else {
#line 295
                tmp___1 = stack_start;
              }
              {
#line 295
              set_ptr_register(11U, tmp___1);
              }
#line 295
              goto while_break___3;
            }
            while_break___3: /* CIL Label */ ;
            }
#line 295
            goto while_break___2;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 295
          gc_space_needed = (unsigned long )(2L + (Free - Free_primitive));
#line 295
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 295
        signal_interrupt_from_primitive();
        }
#line 295
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 295
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 296
  tmp___2 = Free;
#line 296
  Free ++;
#line 296
  *tmp___2 = car;
#line 297
  tmp___3 = Free;
#line 297
  Free ++;
#line 297
  *tmp___3 = cdr;
#line 298
  return (((unsigned long )type << 58U) | (SCHEME_OBJECT )(Free - 2));
}
}
#line 301 "/home/khheo/project/mit-scheme-9.2/src/microcode/list.c"
SCHEME_OBJECT Prim_sys_pair_cons(void) 
{ 
  unsigned long type ;
  unsigned long tmp ;
  gc_type_t tmp___0 ;
  SCHEME_OBJECT tmp___1 ;

  {
  {
#line 303
  while (1) {
    while_continue: /* CIL Label */ ;
#line 303
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 305
  tmp = arg_ulong_index_integer(1, 64UL);
#line 305
  type = tmp;
#line 306
  tmp___0 = gc_type_code((unsigned int )type);
  }
#line 306
  if ((int )tmp___0 != 2) {
    {
#line 307
    error_bad_range_arg(1);
    }
  }
  {
#line 308
  tmp___1 = system_pair_cons((long )type, *(stack_pointer + 1), *(stack_pointer + 2));
  }
#line 308
  return (tmp___1);
}
}
#line 312 "/home/khheo/project/mit-scheme-9.2/src/microcode/list.c"
SCHEME_OBJECT Prim_sys_pair_car(void) 
{ 
  gc_type_t tmp ;

  {
  {
#line 314
  while (1) {
    while_continue: /* CIL Label */ ;
#line 314
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 315
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 315
    tmp = gc_type_code((unsigned int )(*(stack_pointer + 0) >> 58U));
    }
#line 315
    if (! ((int )tmp == 2)) {
      {
#line 315
      error_wrong_type_arg(1);
      }
    }
#line 315
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 316
  return (*((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 0));
}
}
#line 319 "/home/khheo/project/mit-scheme-9.2/src/microcode/list.c"
SCHEME_OBJECT Prim_sys_pair_cdr(void) 
{ 
  gc_type_t tmp ;

  {
  {
#line 321
  while (1) {
    while_continue: /* CIL Label */ ;
#line 321
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 322
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 322
    tmp = gc_type_code((unsigned int )(*(stack_pointer + 0) >> 58U));
    }
#line 322
    if (! ((int )tmp == 2)) {
      {
#line 322
      error_wrong_type_arg(1);
      }
    }
#line 322
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 323
  return (*((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 1));
}
}
#line 326 "/home/khheo/project/mit-scheme-9.2/src/microcode/list.c"
SCHEME_OBJECT Prim_sys_set_car(void) 
{ 
  gc_type_t tmp ;
  SCHEME_OBJECT pair ;
  SCHEME_OBJECT car ;

  {
  {
#line 328
  while (1) {
    while_continue: /* CIL Label */ ;
#line 328
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 329
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 329
    tmp = gc_type_code((unsigned int )(*(stack_pointer + 0) >> 58U));
    }
#line 329
    if (! ((int )tmp == 2)) {
      {
#line 329
      error_wrong_type_arg(1);
      }
    }
#line 329
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 331
  pair = *(stack_pointer + 0);
#line 332
  car = *(stack_pointer + 1);
#line 333
  *((SCHEME_OBJECT *)(pair & 288230376151711743UL) + 0) = car;
#line 335
  return ((8UL << 58U) | 1UL);
}
}
#line 338 "/home/khheo/project/mit-scheme-9.2/src/microcode/list.c"
SCHEME_OBJECT Prim_sys_set_cdr(void) 
{ 
  gc_type_t tmp ;
  SCHEME_OBJECT pair ;
  SCHEME_OBJECT cdr ;

  {
  {
#line 340
  while (1) {
    while_continue: /* CIL Label */ ;
#line 340
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 341
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 341
    tmp = gc_type_code((unsigned int )(*(stack_pointer + 0) >> 58U));
    }
#line 341
    if (! ((int )tmp == 2)) {
      {
#line 341
      error_wrong_type_arg(1);
      }
    }
#line 341
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 343
  pair = *(stack_pointer + 0);
#line 344
  cdr = *(stack_pointer + 1);
#line 345
  *((SCHEME_OBJECT *)(pair & 288230376151711743UL) + 1) = cdr;
#line 347
  return ((8UL << 58U) | 1UL);
}
}
#line 225 "/home/khheo/project/mit-scheme-9.2/src/microcode/extern.h"
SCHEME_OBJECT bignum_to_integer(SCHEME_OBJECT bignum ) ;
#line 236
_Bool integer_negative_p(SCHEME_OBJECT n ) ;
#line 237
_Bool integer_positive_p(SCHEME_OBJECT n ) ;
#line 238
_Bool integer_equal_p(SCHEME_OBJECT n , SCHEME_OBJECT m ) ;
#line 239
_Bool integer_less_p(SCHEME_OBJECT n , SCHEME_OBJECT m ) ;
#line 240
SCHEME_OBJECT integer_negate(SCHEME_OBJECT n ) ;
#line 241
SCHEME_OBJECT integer_add(SCHEME_OBJECT n , SCHEME_OBJECT m ) ;
#line 242
SCHEME_OBJECT integer_add_1(SCHEME_OBJECT n ) ;
#line 243
SCHEME_OBJECT integer_subtract(SCHEME_OBJECT n , SCHEME_OBJECT m ) ;
#line 244
SCHEME_OBJECT integer_subtract_1(SCHEME_OBJECT n ) ;
#line 245
SCHEME_OBJECT integer_multiply(SCHEME_OBJECT n , SCHEME_OBJECT m ) ;
#line 246
_Bool integer_divide(SCHEME_OBJECT n , SCHEME_OBJECT d , SCHEME_OBJECT *q , SCHEME_OBJECT *r ) ;
#line 248
SCHEME_OBJECT integer_quotient(SCHEME_OBJECT n , SCHEME_OBJECT d ) ;
#line 249
SCHEME_OBJECT integer_remainder(SCHEME_OBJECT n , SCHEME_OBJECT d ) ;
#line 250
SCHEME_OBJECT integer_length_in_bits(SCHEME_OBJECT n ) ;
#line 251
SCHEME_OBJECT integer_length(SCHEME_OBJECT n ) ;
#line 252
SCHEME_OBJECT integer_first_set_bit(SCHEME_OBJECT n ) ;
#line 253
SCHEME_OBJECT integer_bit_count(SCHEME_OBJECT n ) ;
#line 254
SCHEME_OBJECT integer_hamming_distance(SCHEME_OBJECT n , SCHEME_OBJECT m ) ;
#line 255
SCHEME_OBJECT integer_bitwise_not(SCHEME_OBJECT n ) ;
#line 256
SCHEME_OBJECT integer_bitwise_and(SCHEME_OBJECT n , SCHEME_OBJECT m ) ;
#line 257
SCHEME_OBJECT integer_bitwise_andc2(SCHEME_OBJECT n , SCHEME_OBJECT m ) ;
#line 258
SCHEME_OBJECT integer_bitwise_andc1(SCHEME_OBJECT n , SCHEME_OBJECT m ) ;
#line 259
SCHEME_OBJECT integer_bitwise_xor(SCHEME_OBJECT n , SCHEME_OBJECT m ) ;
#line 260
SCHEME_OBJECT integer_bitwise_ior(SCHEME_OBJECT n , SCHEME_OBJECT m ) ;
#line 261
SCHEME_OBJECT integer_bitwise_nor(SCHEME_OBJECT n , SCHEME_OBJECT m ) ;
#line 262
SCHEME_OBJECT integer_bitwise_eqv(SCHEME_OBJECT n , SCHEME_OBJECT m ) ;
#line 263
SCHEME_OBJECT integer_bitwise_orc2(SCHEME_OBJECT n , SCHEME_OBJECT m ) ;
#line 264
SCHEME_OBJECT integer_bitwise_orc1(SCHEME_OBJECT n , SCHEME_OBJECT m ) ;
#line 265
SCHEME_OBJECT integer_bitwise_nand(SCHEME_OBJECT n , SCHEME_OBJECT m ) ;
#line 266
SCHEME_OBJECT integer_nonnegative_one_bits(unsigned long n , unsigned long m ) ;
#line 267
SCHEME_OBJECT integer_negative_zero_bits(unsigned long n , unsigned long m ) ;
#line 268
SCHEME_OBJECT integer_shift_left(SCHEME_OBJECT n , unsigned long m ) ;
#line 269
SCHEME_OBJECT integer_shift_right(SCHEME_OBJECT n , unsigned long m ) ;
#line 53 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.h"
enum bignum_comparison bignum_test(bignum_type bignum ) ;
#line 110
bignum_type digit_stream_to_bignum(unsigned int n_digits , unsigned int (*producer)(bignum_procedure_context  ) ,
                                   bignum_procedure_context context , unsigned int radix ,
                                   int negative_p ) ;
#line 120
long bignum_max_digit_stream_radix(void) ;
#line 39 "/home/khheo/project/mit-scheme-9.2/src/microcode/intprm.c"
SCHEME_OBJECT Prim_integer_zero_p(void) 
{ 
  unsigned long tmp___0 ;
  _Bool tmp___1 ;

  {
  {
#line 40
  while (1) {
    while_continue: /* CIL Label */ ;
#line 40
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 40
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 40
    if (! (*(stack_pointer + 0) >> 58U == 26UL)) {
#line 40
      if (! (*(stack_pointer + 0) >> 58U == 14UL)) {
        {
#line 40
        error_wrong_type_arg(1);
        }
      }
    }
#line 40
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 40
  tmp___1 = integer_zero_p(*(stack_pointer + 0));
  }
#line 40
  if (tmp___1) {
#line 40
    tmp___0 = 8UL << 58U;
  } else {
#line 40
    tmp___0 = 0UL;
  }
#line 40
  return (tmp___0);
}
}
#line 41 "/home/khheo/project/mit-scheme-9.2/src/microcode/intprm.c"
SCHEME_OBJECT Prim_integer_negative_p(void) 
{ 
  unsigned long tmp___0 ;
  _Bool tmp___1 ;

  {
  {
#line 42
  while (1) {
    while_continue: /* CIL Label */ ;
#line 42
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 42
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 42
    if (! (*(stack_pointer + 0) >> 58U == 26UL)) {
#line 42
      if (! (*(stack_pointer + 0) >> 58U == 14UL)) {
        {
#line 42
        error_wrong_type_arg(1);
        }
      }
    }
#line 42
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 42
  tmp___1 = integer_negative_p(*(stack_pointer + 0));
  }
#line 42
  if (tmp___1) {
#line 42
    tmp___0 = 8UL << 58U;
  } else {
#line 42
    tmp___0 = 0UL;
  }
#line 42
  return (tmp___0);
}
}
#line 43 "/home/khheo/project/mit-scheme-9.2/src/microcode/intprm.c"
SCHEME_OBJECT Prim_integer_positive_p(void) 
{ 
  unsigned long tmp___0 ;
  _Bool tmp___1 ;

  {
  {
#line 44
  while (1) {
    while_continue: /* CIL Label */ ;
#line 44
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 44
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 44
    if (! (*(stack_pointer + 0) >> 58U == 26UL)) {
#line 44
      if (! (*(stack_pointer + 0) >> 58U == 14UL)) {
        {
#line 44
        error_wrong_type_arg(1);
        }
      }
    }
#line 44
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 44
  tmp___1 = integer_positive_p(*(stack_pointer + 0));
  }
#line 44
  if (tmp___1) {
#line 44
    tmp___0 = 8UL << 58U;
  } else {
#line 44
    tmp___0 = 0UL;
  }
#line 44
  return (tmp___0);
}
}
#line 55 "/home/khheo/project/mit-scheme-9.2/src/microcode/intprm.c"
SCHEME_OBJECT Prim_integer_equal_p(void) 
{ 
  unsigned long tmp___0 ;
  _Bool tmp___1 ;

  {
  {
#line 56
  while (1) {
    while_continue: /* CIL Label */ ;
#line 56
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 56
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 56
    if (! (*(stack_pointer + 0) >> 58U == 26UL)) {
#line 56
      if (! (*(stack_pointer + 0) >> 58U == 14UL)) {
        {
#line 56
        error_wrong_type_arg(1);
        }
      }
    }
#line 56
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 56
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 56
    if (! (*(stack_pointer + 1) >> 58U == 26UL)) {
#line 56
      if (! (*(stack_pointer + 1) >> 58U == 14UL)) {
        {
#line 56
        error_wrong_type_arg(2);
        }
      }
    }
#line 56
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 56
  tmp___1 = integer_equal_p(*(stack_pointer + 0), *(stack_pointer + 1));
  }
#line 56
  if (tmp___1) {
#line 56
    tmp___0 = 8UL << 58U;
  } else {
#line 56
    tmp___0 = 0UL;
  }
#line 56
  return (tmp___0);
}
}
#line 57 "/home/khheo/project/mit-scheme-9.2/src/microcode/intprm.c"
SCHEME_OBJECT Prim_integer_less_p(void) 
{ 
  unsigned long tmp___0 ;
  _Bool tmp___1 ;

  {
  {
#line 58
  while (1) {
    while_continue: /* CIL Label */ ;
#line 58
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 58
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 58
    if (! (*(stack_pointer + 0) >> 58U == 26UL)) {
#line 58
      if (! (*(stack_pointer + 0) >> 58U == 14UL)) {
        {
#line 58
        error_wrong_type_arg(1);
        }
      }
    }
#line 58
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 58
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 58
    if (! (*(stack_pointer + 1) >> 58U == 26UL)) {
#line 58
      if (! (*(stack_pointer + 1) >> 58U == 14UL)) {
        {
#line 58
        error_wrong_type_arg(2);
        }
      }
    }
#line 58
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 58
  tmp___1 = integer_less_p(*(stack_pointer + 0), *(stack_pointer + 1));
  }
#line 58
  if (tmp___1) {
#line 58
    tmp___0 = 8UL << 58U;
  } else {
#line 58
    tmp___0 = 0UL;
  }
#line 58
  return (tmp___0);
}
}
#line 60 "/home/khheo/project/mit-scheme-9.2/src/microcode/intprm.c"
SCHEME_OBJECT Prim_integer_greater_p(void) 
{ 
  unsigned long tmp___0 ;
  _Bool tmp___1 ;

  {
  {
#line 62
  while (1) {
    while_continue: /* CIL Label */ ;
#line 62
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 63
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 63
    if (! (*(stack_pointer + 0) >> 58U == 26UL)) {
#line 63
      if (! (*(stack_pointer + 0) >> 58U == 14UL)) {
        {
#line 63
        error_wrong_type_arg(1);
        }
      }
    }
#line 63
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 64
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 64
    if (! (*(stack_pointer + 1) >> 58U == 26UL)) {
#line 64
      if (! (*(stack_pointer + 1) >> 58U == 14UL)) {
        {
#line 64
        error_wrong_type_arg(2);
        }
      }
    }
#line 64
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 65
  tmp___1 = integer_less_p(*(stack_pointer + 1), *(stack_pointer + 0));
  }
#line 65
  if (tmp___1) {
#line 65
    tmp___0 = 8UL << 58U;
  } else {
#line 65
    tmp___0 = 0UL;
  }
#line 65
  return (tmp___0);
}
}
#line 77 "/home/khheo/project/mit-scheme-9.2/src/microcode/intprm.c"
SCHEME_OBJECT Prim_integer_add(void) 
{ 
  SCHEME_OBJECT tmp ;

  {
  {
#line 78
  while (1) {
    while_continue: /* CIL Label */ ;
#line 78
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 78
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 78
    if (! (*(stack_pointer + 0) >> 58U == 26UL)) {
#line 78
      if (! (*(stack_pointer + 0) >> 58U == 14UL)) {
        {
#line 78
        error_wrong_type_arg(1);
        }
      }
    }
#line 78
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 78
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 78
    if (! (*(stack_pointer + 1) >> 58U == 26UL)) {
#line 78
      if (! (*(stack_pointer + 1) >> 58U == 14UL)) {
        {
#line 78
        error_wrong_type_arg(2);
        }
      }
    }
#line 78
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 78
  tmp = integer_add(*(stack_pointer + 0), *(stack_pointer + 1));
  }
#line 78
  return (tmp);
}
}
#line 79 "/home/khheo/project/mit-scheme-9.2/src/microcode/intprm.c"
SCHEME_OBJECT Prim_integer_subtract(void) 
{ 
  SCHEME_OBJECT tmp ;

  {
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
#line 80
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 80
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 80
    if (! (*(stack_pointer + 0) >> 58U == 26UL)) {
#line 80
      if (! (*(stack_pointer + 0) >> 58U == 14UL)) {
        {
#line 80
        error_wrong_type_arg(1);
        }
      }
    }
#line 80
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 80
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 80
    if (! (*(stack_pointer + 1) >> 58U == 26UL)) {
#line 80
      if (! (*(stack_pointer + 1) >> 58U == 14UL)) {
        {
#line 80
        error_wrong_type_arg(2);
        }
      }
    }
#line 80
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 80
  tmp = integer_subtract(*(stack_pointer + 0), *(stack_pointer + 1));
  }
#line 80
  return (tmp);
}
}
#line 81 "/home/khheo/project/mit-scheme-9.2/src/microcode/intprm.c"
SCHEME_OBJECT Prim_integer_multiply(void) 
{ 
  SCHEME_OBJECT tmp ;

  {
  {
#line 82
  while (1) {
    while_continue: /* CIL Label */ ;
#line 82
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 82
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 82
    if (! (*(stack_pointer + 0) >> 58U == 26UL)) {
#line 82
      if (! (*(stack_pointer + 0) >> 58U == 14UL)) {
        {
#line 82
        error_wrong_type_arg(1);
        }
      }
    }
#line 82
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 82
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 82
    if (! (*(stack_pointer + 1) >> 58U == 26UL)) {
#line 82
      if (! (*(stack_pointer + 1) >> 58U == 14UL)) {
        {
#line 82
        error_wrong_type_arg(2);
        }
      }
    }
#line 82
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 82
  tmp = integer_multiply(*(stack_pointer + 0), *(stack_pointer + 1));
  }
#line 82
  return (tmp);
}
}
#line 83 "/home/khheo/project/mit-scheme-9.2/src/microcode/intprm.c"
SCHEME_OBJECT Prim_integer_hamming_distance(void) 
{ 
  SCHEME_OBJECT tmp ;

  {
  {
#line 84
  while (1) {
    while_continue: /* CIL Label */ ;
#line 84
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 84
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 84
    if (! (*(stack_pointer + 0) >> 58U == 26UL)) {
#line 84
      if (! (*(stack_pointer + 0) >> 58U == 14UL)) {
        {
#line 84
        error_wrong_type_arg(1);
        }
      }
    }
#line 84
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 84
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 84
    if (! (*(stack_pointer + 1) >> 58U == 26UL)) {
#line 84
      if (! (*(stack_pointer + 1) >> 58U == 14UL)) {
        {
#line 84
        error_wrong_type_arg(2);
        }
      }
    }
#line 84
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 84
  tmp = integer_hamming_distance(*(stack_pointer + 0), *(stack_pointer + 1));
  }
#line 84
  return (tmp);
}
}
#line 85 "/home/khheo/project/mit-scheme-9.2/src/microcode/intprm.c"
SCHEME_OBJECT Prim_integer_bitwise_and(void) 
{ 
  SCHEME_OBJECT tmp ;

  {
  {
#line 86
  while (1) {
    while_continue: /* CIL Label */ ;
#line 86
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 86
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 86
    if (! (*(stack_pointer + 0) >> 58U == 26UL)) {
#line 86
      if (! (*(stack_pointer + 0) >> 58U == 14UL)) {
        {
#line 86
        error_wrong_type_arg(1);
        }
      }
    }
#line 86
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 86
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 86
    if (! (*(stack_pointer + 1) >> 58U == 26UL)) {
#line 86
      if (! (*(stack_pointer + 1) >> 58U == 14UL)) {
        {
#line 86
        error_wrong_type_arg(2);
        }
      }
    }
#line 86
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 86
  tmp = integer_bitwise_and(*(stack_pointer + 0), *(stack_pointer + 1));
  }
#line 86
  return (tmp);
}
}
#line 87 "/home/khheo/project/mit-scheme-9.2/src/microcode/intprm.c"
SCHEME_OBJECT Prim_integer_bitwise_andc2(void) 
{ 
  SCHEME_OBJECT tmp ;

  {
  {
#line 88
  while (1) {
    while_continue: /* CIL Label */ ;
#line 88
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 88
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 88
    if (! (*(stack_pointer + 0) >> 58U == 26UL)) {
#line 88
      if (! (*(stack_pointer + 0) >> 58U == 14UL)) {
        {
#line 88
        error_wrong_type_arg(1);
        }
      }
    }
#line 88
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 88
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 88
    if (! (*(stack_pointer + 1) >> 58U == 26UL)) {
#line 88
      if (! (*(stack_pointer + 1) >> 58U == 14UL)) {
        {
#line 88
        error_wrong_type_arg(2);
        }
      }
    }
#line 88
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 88
  tmp = integer_bitwise_andc2(*(stack_pointer + 0), *(stack_pointer + 1));
  }
#line 88
  return (tmp);
}
}
#line 89 "/home/khheo/project/mit-scheme-9.2/src/microcode/intprm.c"
SCHEME_OBJECT Prim_integer_bitwise_andc1(void) 
{ 
  SCHEME_OBJECT tmp ;

  {
  {
#line 90
  while (1) {
    while_continue: /* CIL Label */ ;
#line 90
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 90
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 90
    if (! (*(stack_pointer + 0) >> 58U == 26UL)) {
#line 90
      if (! (*(stack_pointer + 0) >> 58U == 14UL)) {
        {
#line 90
        error_wrong_type_arg(1);
        }
      }
    }
#line 90
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 90
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 90
    if (! (*(stack_pointer + 1) >> 58U == 26UL)) {
#line 90
      if (! (*(stack_pointer + 1) >> 58U == 14UL)) {
        {
#line 90
        error_wrong_type_arg(2);
        }
      }
    }
#line 90
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 90
  tmp = integer_bitwise_andc1(*(stack_pointer + 0), *(stack_pointer + 1));
  }
#line 90
  return (tmp);
}
}
#line 91 "/home/khheo/project/mit-scheme-9.2/src/microcode/intprm.c"
SCHEME_OBJECT Prim_integer_bitwise_xor(void) 
{ 
  SCHEME_OBJECT tmp ;

  {
  {
#line 92
  while (1) {
    while_continue: /* CIL Label */ ;
#line 92
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 92
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 92
    if (! (*(stack_pointer + 0) >> 58U == 26UL)) {
#line 92
      if (! (*(stack_pointer + 0) >> 58U == 14UL)) {
        {
#line 92
        error_wrong_type_arg(1);
        }
      }
    }
#line 92
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 92
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 92
    if (! (*(stack_pointer + 1) >> 58U == 26UL)) {
#line 92
      if (! (*(stack_pointer + 1) >> 58U == 14UL)) {
        {
#line 92
        error_wrong_type_arg(2);
        }
      }
    }
#line 92
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 92
  tmp = integer_bitwise_xor(*(stack_pointer + 0), *(stack_pointer + 1));
  }
#line 92
  return (tmp);
}
}
#line 93 "/home/khheo/project/mit-scheme-9.2/src/microcode/intprm.c"
SCHEME_OBJECT Prim_integer_bitwise_ior(void) 
{ 
  SCHEME_OBJECT tmp ;

  {
  {
#line 94
  while (1) {
    while_continue: /* CIL Label */ ;
#line 94
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 94
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 94
    if (! (*(stack_pointer + 0) >> 58U == 26UL)) {
#line 94
      if (! (*(stack_pointer + 0) >> 58U == 14UL)) {
        {
#line 94
        error_wrong_type_arg(1);
        }
      }
    }
#line 94
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 94
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 94
    if (! (*(stack_pointer + 1) >> 58U == 26UL)) {
#line 94
      if (! (*(stack_pointer + 1) >> 58U == 14UL)) {
        {
#line 94
        error_wrong_type_arg(2);
        }
      }
    }
#line 94
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 94
  tmp = integer_bitwise_ior(*(stack_pointer + 0), *(stack_pointer + 1));
  }
#line 94
  return (tmp);
}
}
#line 95 "/home/khheo/project/mit-scheme-9.2/src/microcode/intprm.c"
SCHEME_OBJECT Prim_integer_bitwise_nor(void) 
{ 
  SCHEME_OBJECT tmp ;

  {
  {
#line 96
  while (1) {
    while_continue: /* CIL Label */ ;
#line 96
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 96
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 96
    if (! (*(stack_pointer + 0) >> 58U == 26UL)) {
#line 96
      if (! (*(stack_pointer + 0) >> 58U == 14UL)) {
        {
#line 96
        error_wrong_type_arg(1);
        }
      }
    }
#line 96
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 96
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 96
    if (! (*(stack_pointer + 1) >> 58U == 26UL)) {
#line 96
      if (! (*(stack_pointer + 1) >> 58U == 14UL)) {
        {
#line 96
        error_wrong_type_arg(2);
        }
      }
    }
#line 96
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 96
  tmp = integer_bitwise_nor(*(stack_pointer + 0), *(stack_pointer + 1));
  }
#line 96
  return (tmp);
}
}
#line 97 "/home/khheo/project/mit-scheme-9.2/src/microcode/intprm.c"
SCHEME_OBJECT Prim_integer_bitwise_eqv(void) 
{ 
  SCHEME_OBJECT tmp ;

  {
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 98
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 98
    if (! (*(stack_pointer + 0) >> 58U == 26UL)) {
#line 98
      if (! (*(stack_pointer + 0) >> 58U == 14UL)) {
        {
#line 98
        error_wrong_type_arg(1);
        }
      }
    }
#line 98
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 98
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 98
    if (! (*(stack_pointer + 1) >> 58U == 26UL)) {
#line 98
      if (! (*(stack_pointer + 1) >> 58U == 14UL)) {
        {
#line 98
        error_wrong_type_arg(2);
        }
      }
    }
#line 98
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 98
  tmp = integer_bitwise_eqv(*(stack_pointer + 0), *(stack_pointer + 1));
  }
#line 98
  return (tmp);
}
}
#line 99 "/home/khheo/project/mit-scheme-9.2/src/microcode/intprm.c"
SCHEME_OBJECT Prim_integer_bitwise_orc2(void) 
{ 
  SCHEME_OBJECT tmp ;

  {
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 100
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 100
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 100
    if (! (*(stack_pointer + 0) >> 58U == 26UL)) {
#line 100
      if (! (*(stack_pointer + 0) >> 58U == 14UL)) {
        {
#line 100
        error_wrong_type_arg(1);
        }
      }
    }
#line 100
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 100
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 100
    if (! (*(stack_pointer + 1) >> 58U == 26UL)) {
#line 100
      if (! (*(stack_pointer + 1) >> 58U == 14UL)) {
        {
#line 100
        error_wrong_type_arg(2);
        }
      }
    }
#line 100
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 100
  tmp = integer_bitwise_orc2(*(stack_pointer + 0), *(stack_pointer + 1));
  }
#line 100
  return (tmp);
}
}
#line 101 "/home/khheo/project/mit-scheme-9.2/src/microcode/intprm.c"
SCHEME_OBJECT Prim_integer_bitwise_orc1(void) 
{ 
  SCHEME_OBJECT tmp ;

  {
  {
#line 102
  while (1) {
    while_continue: /* CIL Label */ ;
#line 102
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 102
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 102
    if (! (*(stack_pointer + 0) >> 58U == 26UL)) {
#line 102
      if (! (*(stack_pointer + 0) >> 58U == 14UL)) {
        {
#line 102
        error_wrong_type_arg(1);
        }
      }
    }
#line 102
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 102
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 102
    if (! (*(stack_pointer + 1) >> 58U == 26UL)) {
#line 102
      if (! (*(stack_pointer + 1) >> 58U == 14UL)) {
        {
#line 102
        error_wrong_type_arg(2);
        }
      }
    }
#line 102
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 102
  tmp = integer_bitwise_orc1(*(stack_pointer + 0), *(stack_pointer + 1));
  }
#line 102
  return (tmp);
}
}
#line 103 "/home/khheo/project/mit-scheme-9.2/src/microcode/intprm.c"
SCHEME_OBJECT Prim_integer_bitwise_nand(void) 
{ 
  SCHEME_OBJECT tmp ;

  {
  {
#line 104
  while (1) {
    while_continue: /* CIL Label */ ;
#line 104
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 104
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 104
    if (! (*(stack_pointer + 0) >> 58U == 26UL)) {
#line 104
      if (! (*(stack_pointer + 0) >> 58U == 14UL)) {
        {
#line 104
        error_wrong_type_arg(1);
        }
      }
    }
#line 104
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 104
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 104
    if (! (*(stack_pointer + 1) >> 58U == 26UL)) {
#line 104
      if (! (*(stack_pointer + 1) >> 58U == 14UL)) {
        {
#line 104
        error_wrong_type_arg(2);
        }
      }
    }
#line 104
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 104
  tmp = integer_bitwise_nand(*(stack_pointer + 0), *(stack_pointer + 1));
  }
#line 104
  return (tmp);
}
}
#line 113 "/home/khheo/project/mit-scheme-9.2/src/microcode/intprm.c"
SCHEME_OBJECT Prim_integer_negate(void) 
{ 
  SCHEME_OBJECT tmp ;

  {
  {
#line 114
  while (1) {
    while_continue: /* CIL Label */ ;
#line 114
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 114
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 114
    if (! (*(stack_pointer + 0) >> 58U == 26UL)) {
#line 114
      if (! (*(stack_pointer + 0) >> 58U == 14UL)) {
        {
#line 114
        error_wrong_type_arg(1);
        }
      }
    }
#line 114
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 114
  tmp = integer_negate(*(stack_pointer + 0));
  }
#line 114
  return (tmp);
}
}
#line 115 "/home/khheo/project/mit-scheme-9.2/src/microcode/intprm.c"
SCHEME_OBJECT Prim_integer_add_1(void) 
{ 
  SCHEME_OBJECT tmp ;

  {
  {
#line 116
  while (1) {
    while_continue: /* CIL Label */ ;
#line 116
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 116
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 116
    if (! (*(stack_pointer + 0) >> 58U == 26UL)) {
#line 116
      if (! (*(stack_pointer + 0) >> 58U == 14UL)) {
        {
#line 116
        error_wrong_type_arg(1);
        }
      }
    }
#line 116
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 116
  tmp = integer_add_1(*(stack_pointer + 0));
  }
#line 116
  return (tmp);
}
}
#line 117 "/home/khheo/project/mit-scheme-9.2/src/microcode/intprm.c"
SCHEME_OBJECT Prim_integer_subtract_1(void) 
{ 
  SCHEME_OBJECT tmp ;

  {
  {
#line 118
  while (1) {
    while_continue: /* CIL Label */ ;
#line 118
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 118
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 118
    if (! (*(stack_pointer + 0) >> 58U == 26UL)) {
#line 118
      if (! (*(stack_pointer + 0) >> 58U == 14UL)) {
        {
#line 118
        error_wrong_type_arg(1);
        }
      }
    }
#line 118
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 118
  tmp = integer_subtract_1(*(stack_pointer + 0));
  }
#line 118
  return (tmp);
}
}
#line 119 "/home/khheo/project/mit-scheme-9.2/src/microcode/intprm.c"
SCHEME_OBJECT Prim_integer_length_in_bits(void) 
{ 
  SCHEME_OBJECT tmp ;

  {
  {
#line 120
  while (1) {
    while_continue: /* CIL Label */ ;
#line 120
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 120
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 120
    if (! (*(stack_pointer + 0) >> 58U == 26UL)) {
#line 120
      if (! (*(stack_pointer + 0) >> 58U == 14UL)) {
        {
#line 120
        error_wrong_type_arg(1);
        }
      }
    }
#line 120
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 120
  tmp = integer_length_in_bits(*(stack_pointer + 0));
  }
#line 120
  return (tmp);
}
}
#line 121 "/home/khheo/project/mit-scheme-9.2/src/microcode/intprm.c"
SCHEME_OBJECT Prim_integer_length(void) 
{ 
  SCHEME_OBJECT tmp ;

  {
  {
#line 122
  while (1) {
    while_continue: /* CIL Label */ ;
#line 122
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 122
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 122
    if (! (*(stack_pointer + 0) >> 58U == 26UL)) {
#line 122
      if (! (*(stack_pointer + 0) >> 58U == 14UL)) {
        {
#line 122
        error_wrong_type_arg(1);
        }
      }
    }
#line 122
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 122
  tmp = integer_length(*(stack_pointer + 0));
  }
#line 122
  return (tmp);
}
}
#line 123 "/home/khheo/project/mit-scheme-9.2/src/microcode/intprm.c"
SCHEME_OBJECT Prim_integer_first_set_bit(void) 
{ 
  SCHEME_OBJECT tmp ;

  {
  {
#line 124
  while (1) {
    while_continue: /* CIL Label */ ;
#line 124
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 124
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 124
    if (! (*(stack_pointer + 0) >> 58U == 26UL)) {
#line 124
      if (! (*(stack_pointer + 0) >> 58U == 14UL)) {
        {
#line 124
        error_wrong_type_arg(1);
        }
      }
    }
#line 124
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 124
  tmp = integer_first_set_bit(*(stack_pointer + 0));
  }
#line 124
  return (tmp);
}
}
#line 125 "/home/khheo/project/mit-scheme-9.2/src/microcode/intprm.c"
SCHEME_OBJECT Prim_integer_bit_count(void) 
{ 
  SCHEME_OBJECT tmp ;

  {
  {
#line 126
  while (1) {
    while_continue: /* CIL Label */ ;
#line 126
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 126
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 126
    if (! (*(stack_pointer + 0) >> 58U == 26UL)) {
#line 126
      if (! (*(stack_pointer + 0) >> 58U == 14UL)) {
        {
#line 126
        error_wrong_type_arg(1);
        }
      }
    }
#line 126
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 126
  tmp = integer_bit_count(*(stack_pointer + 0));
  }
#line 126
  return (tmp);
}
}
#line 127 "/home/khheo/project/mit-scheme-9.2/src/microcode/intprm.c"
SCHEME_OBJECT Prim_integer_bitwise_not(void) 
{ 
  SCHEME_OBJECT tmp ;

  {
  {
#line 128
  while (1) {
    while_continue: /* CIL Label */ ;
#line 128
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 128
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 128
    if (! (*(stack_pointer + 0) >> 58U == 26UL)) {
#line 128
      if (! (*(stack_pointer + 0) >> 58U == 14UL)) {
        {
#line 128
        error_wrong_type_arg(1);
        }
      }
    }
#line 128
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 128
  tmp = integer_bitwise_not(*(stack_pointer + 0));
  }
#line 128
  return (tmp);
}
}
#line 130 "/home/khheo/project/mit-scheme-9.2/src/microcode/intprm.c"
SCHEME_OBJECT Prim_integer_divide(void) 
{ 
  SCHEME_OBJECT quotient ;
  SCHEME_OBJECT remainder___0 ;
  _Bool tmp ;
  SCHEME_OBJECT tmp___0 ;

  {
  {
#line 134
  while (1) {
    while_continue: /* CIL Label */ ;
#line 134
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 135
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 135
    if (! (*(stack_pointer + 0) >> 58U == 26UL)) {
#line 135
      if (! (*(stack_pointer + 0) >> 58U == 14UL)) {
        {
#line 135
        error_wrong_type_arg(1);
        }
      }
    }
#line 135
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 136
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 136
    if (! (*(stack_pointer + 1) >> 58U == 26UL)) {
#line 136
      if (! (*(stack_pointer + 1) >> 58U == 14UL)) {
        {
#line 136
        error_wrong_type_arg(2);
        }
      }
    }
#line 136
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 137
  tmp = integer_divide(*(stack_pointer + 0), *(stack_pointer + 1), & quotient, & remainder___0);
  }
#line 137
  if (tmp) {
    {
#line 138
    error_bad_range_arg(2);
    }
  }
  {
#line 139
  tmp___0 = cons(quotient, remainder___0);
  }
#line 139
  return (tmp___0);
}
}
#line 154 "/home/khheo/project/mit-scheme-9.2/src/microcode/intprm.c"
SCHEME_OBJECT Prim_integer_quotient(void) 
{ 
  SCHEME_OBJECT result ;

  {
  {
#line 155
  while (1) {
    while_continue: /* CIL Label */ ;
#line 155
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 155
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 155
    if (! (*(stack_pointer + 0) >> 58U == 26UL)) {
#line 155
      if (! (*(stack_pointer + 0) >> 58U == 14UL)) {
        {
#line 155
        error_wrong_type_arg(1);
        }
      }
    }
#line 155
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 155
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 155
    if (! (*(stack_pointer + 1) >> 58U == 26UL)) {
#line 155
      if (! (*(stack_pointer + 1) >> 58U == 14UL)) {
        {
#line 155
        error_wrong_type_arg(2);
        }
      }
    }
#line 155
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 155
  result = integer_quotient(*(stack_pointer + 0), *(stack_pointer + 1));
  }
#line 155
  if (result == 0UL) {
    {
#line 155
    error_bad_range_arg(2);
    }
  }
#line 155
  return (result);
}
}
#line 156 "/home/khheo/project/mit-scheme-9.2/src/microcode/intprm.c"
SCHEME_OBJECT Prim_integer_remainder(void) 
{ 
  SCHEME_OBJECT result ;

  {
  {
#line 157
  while (1) {
    while_continue: /* CIL Label */ ;
#line 157
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 157
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 157
    if (! (*(stack_pointer + 0) >> 58U == 26UL)) {
#line 157
      if (! (*(stack_pointer + 0) >> 58U == 14UL)) {
        {
#line 157
        error_wrong_type_arg(1);
        }
      }
    }
#line 157
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 157
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 157
    if (! (*(stack_pointer + 1) >> 58U == 26UL)) {
#line 157
      if (! (*(stack_pointer + 1) >> 58U == 14UL)) {
        {
#line 157
        error_wrong_type_arg(2);
        }
      }
    }
#line 157
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 157
  result = integer_remainder(*(stack_pointer + 0), *(stack_pointer + 1));
  }
#line 157
  if (result == 0UL) {
    {
#line 157
    error_bad_range_arg(2);
    }
  }
#line 157
  return (result);
}
}
#line 159 "/home/khheo/project/mit-scheme-9.2/src/microcode/intprm.c"
SCHEME_OBJECT Prim_integer_p(void) 
{ 
  SCHEME_OBJECT integer ;
  unsigned long tmp ;

  {
  {
#line 161
  while (1) {
    while_continue: /* CIL Label */ ;
#line 161
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 163
  integer = *(stack_pointer + 0);
#line 164
  if (integer >> 58U == 26UL) {
#line 164
    tmp = 8UL << 58U;
  } else
#line 164
  if (integer >> 58U == 14UL) {
#line 164
    tmp = 8UL << 58U;
  } else {
#line 164
    tmp = 0UL;
  }
#line 164
  return (tmp);
}
}
#line 168 "/home/khheo/project/mit-scheme-9.2/src/microcode/intprm.c"
SCHEME_OBJECT Prim_integer_to_flonum(void) 
{ 
  SCHEME_OBJECT integer ;
  long control ;
  long tmp ;
  double d ;
  SCHEME_OBJECT tmp___0 ;
  double tmp___1 ;
  SCHEME_OBJECT tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 170
  while (1) {
    while_continue: /* CIL Label */ ;
#line 170
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 171
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 171
    if (! (*(stack_pointer + 0) >> 58U == 26UL)) {
#line 171
      if (! (*(stack_pointer + 0) >> 58U == 14UL)) {
        {
#line 171
        error_wrong_type_arg(1);
        }
      }
    }
#line 171
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 173
  integer = *(stack_pointer + 0);
#line 174
  tmp = arg_index_integer(2, 4L);
#line 174
  control = tmp;
  }
#line 175
  if (integer >> 58U == 26UL) {
#line 177
    d = (double )((long )((integer ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL)));
#line 178
    if (0L == (control & 1L)) {
      {
#line 181
      tmp___0 = double_to_flonum(d);
      }
#line 181
      return (tmp___0);
    } else
#line 178
    if (d > (double )-144115188075855873L) {
#line 178
      if (d < (double )144115188075855872L) {
#line 178
        if (integer == ((26UL << 58U) | ((unsigned long )((long )d) & 288230376151711743UL))) {
          {
#line 181
          tmp___0 = double_to_flonum(d);
          }
#line 181
          return (tmp___0);
        }
      }
    }
#line 182
    if ((control & 2L) != 0L) {
      {
#line 183
      error_bad_range_arg(1);
      }
    }
#line 184
    return (0UL);
  }
#line 186
  if ((control & 1L) != 0L) {
    {
#line 186
    tmp___3 = bignum_fits_in_word_p(integer, 54L, 1);
#line 186
    tmp___5 = tmp___3;
    }
  } else {
    {
#line 186
    tmp___4 = bignum_fits_in_word_p(integer, 1025L, 1);
#line 186
    tmp___5 = tmp___4;
    }
  }
#line 186
  if (tmp___5) {
    {
#line 189
    tmp___1 = bignum_to_double(integer);
#line 189
    tmp___2 = double_to_flonum(tmp___1);
    }
#line 189
    return (tmp___2);
  }
#line 190
  if ((control & 2L) != 0L) {
    {
#line 191
    error_bad_range_arg(1);
    }
  }
#line 192
  return (0UL);
}
}
#line 196 "/home/khheo/project/mit-scheme-9.2/src/microcode/intprm.c"
SCHEME_OBJECT Prim_integer_nonnegative_one_bits(void) 
{ 
  unsigned long tmp ;
  unsigned long tmp___0 ;
  SCHEME_OBJECT tmp___1 ;

  {
  {
#line 198
  while (1) {
    while_continue: /* CIL Label */ ;
#line 198
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 199
  tmp = arg_ulong_integer(2);
#line 199
  tmp___0 = arg_ulong_integer(1);
#line 199
  tmp___1 = integer_nonnegative_one_bits(tmp___0, tmp);
  }
#line 199
  return (tmp___1);
}
}
#line 204 "/home/khheo/project/mit-scheme-9.2/src/microcode/intprm.c"
SCHEME_OBJECT Prim_integer_negative_zero_bits(void) 
{ 
  unsigned long tmp ;
  unsigned long tmp___0 ;
  SCHEME_OBJECT tmp___1 ;

  {
  {
#line 206
  while (1) {
    while_continue: /* CIL Label */ ;
#line 206
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 207
  tmp = arg_ulong_integer(2);
#line 207
  tmp___0 = arg_ulong_integer(1);
#line 207
  tmp___1 = integer_negative_zero_bits(tmp___0, tmp);
  }
#line 207
  return (tmp___1);
}
}
#line 212 "/home/khheo/project/mit-scheme-9.2/src/microcode/intprm.c"
SCHEME_OBJECT Prim_integer_shift_left(void) 
{ 
  unsigned long tmp ;
  SCHEME_OBJECT tmp___0 ;

  {
  {
#line 214
  while (1) {
    while_continue: /* CIL Label */ ;
#line 214
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 215
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 215
    if (! (*(stack_pointer + 0) >> 58U == 26UL)) {
#line 215
      if (! (*(stack_pointer + 0) >> 58U == 14UL)) {
        {
#line 215
        error_wrong_type_arg(1);
        }
      }
    }
#line 215
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 216
  tmp = arg_ulong_integer(2);
#line 216
  tmp___0 = integer_shift_left(*(stack_pointer + 0), tmp);
  }
#line 216
  return (tmp___0);
}
}
#line 220 "/home/khheo/project/mit-scheme-9.2/src/microcode/intprm.c"
SCHEME_OBJECT Prim_integer_shift_right(void) 
{ 
  SCHEME_OBJECT n ;
  SCHEME_OBJECT m ;
  SCHEME_OBJECT tmp ;
  enum bignum_comparison tmp___0 ;

  {
  {
#line 222
  while (1) {
    while_continue: /* CIL Label */ ;
#line 222
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 223
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 223
    if (! (*(stack_pointer + 0) >> 58U == 26UL)) {
#line 223
      if (! (*(stack_pointer + 0) >> 58U == 14UL)) {
        {
#line 223
        error_wrong_type_arg(1);
        }
      }
    }
#line 223
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 225
  n = *(stack_pointer + 0);
#line 226
  m = *(stack_pointer + 1);
#line 227
  if (m >> 58U == 26UL) {
#line 229
    if ((m & 144115188075855872UL) != 0UL) {
      {
#line 230
      error_bad_range_arg(2);
      }
    }
    {
#line 231
    tmp = integer_shift_right(n, m & 288230376151711743UL);
    }
#line 231
    return (tmp);
  } else
#line 233
  if (m >> 58U == 14UL) {
    {
#line 235
    tmp___0 = bignum_test(m);
    }
#line 235
    if ((unsigned int )tmp___0 == 1U) {
      {
#line 236
      error_bad_range_arg(2);
      }
    }
#line 237
    return (26UL << 58U);
  } else {
    {
#line 240
    error_wrong_type_arg(2);
    }
  }
}
}
#line 244 "/home/khheo/project/mit-scheme-9.2/src/microcode/intprm.c"
static unsigned int list_to_integer_producer(void *context ) 
{ 
  SCHEME_OBJECT *digits ;
  unsigned int digit ;

  {
#line 247
  digits = (SCHEME_OBJECT *)context;
#line 248
  digit = (unsigned int )((long )(*((SCHEME_OBJECT *)(*digits & 288230376151711743UL) + 0) & 288230376151711743UL));
#line 249
  *digits = *((SCHEME_OBJECT *)(*digits & 288230376151711743UL) + 1);
#line 250
  return (digit);
}
}
#line 253 "/home/khheo/project/mit-scheme-9.2/src/microcode/intprm.c"
SCHEME_OBJECT Prim_list_to_integer(void) 
{ 
  SCHEME_OBJECT digits ;
  unsigned long radix ;
  unsigned long tmp ;
  unsigned int n_digits ;
  long tmp___0 ;
  SCHEME_OBJECT scan ;
  SCHEME_OBJECT digit ;
  bignum_type tmp___1 ;
  SCHEME_OBJECT tmp___2 ;

  {
  {
#line 258
  while (1) {
    while_continue: /* CIL Label */ ;
#line 258
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 259
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 259
    if (! (*(stack_pointer + 0) >> 58U == 1UL)) {
      {
#line 259
      error_wrong_type_arg(1);
      }
    }
#line 259
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 261
  digits = *(stack_pointer + 0);
#line 262
  tmp = arg_ulong_integer(2);
#line 262
  radix = tmp;
  }
#line 264
  if (radix < 2UL) {
    {
#line 266
    error_bad_range_arg(2);
    }
  } else {
    {
#line 264
    tmp___0 = bignum_max_digit_stream_radix();
    }
#line 264
    if (radix >= (unsigned long )tmp___0) {
      {
#line 266
      error_bad_range_arg(2);
      }
    }
  }
#line 268
  scan = digits;
#line 269
  n_digits = 0U;
  {
#line 270
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 272
    digit = *((SCHEME_OBJECT *)(scan & 288230376151711743UL) + 0);
#line 273
    if (digit >> 58U == 26UL) {
#line 273
      if (! (! ((digit & 144115188075855872UL) != 0UL))) {
        {
#line 274
        error_wrong_type_arg(1);
        }
      }
    } else {
      {
#line 274
      error_wrong_type_arg(1);
      }
    }
#line 275
    if ((unsigned long )((long )(digit & 288230376151711743UL)) >= radix) {
      {
#line 276
      error_bad_range_arg(1);
      }
    }
#line 277
    n_digits ++;
#line 278
    scan = *((SCHEME_OBJECT *)(scan & 288230376151711743UL) + 1);
#line 279
    if (scan == ((8UL << 58U) | 9UL)) {
#line 280
      goto while_break___1;
    }
#line 281
    if (! (scan >> 58U == 1UL)) {
      {
#line 282
      error_wrong_type_arg(1);
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 285
  tmp___1 = digit_stream_to_bignum(n_digits, & list_to_integer_producer, (bignum_procedure_context )(& digits),
                                   (unsigned int )radix, *(stack_pointer + 2) != 0UL);
#line 285
  tmp___2 = bignum_to_integer(tmp___1);
  }
#line 285
  return (tmp___2);
}
}
#line 156 "/home/khheo/project/mit-scheme-9.2/src/microcode/interp.h"
int abort_to_interpreter_argument(void) ;
#line 159 "/home/khheo/project/mit-scheme-9.2/src/microcode/interp.h"
long prim_apply_error_code  ;
#line 372 "/home/khheo/project/mit-scheme-9.2/src/microcode/extern.h"
void unpack_control_point(SCHEME_OBJECT cp ) ;
#line 34 "/home/khheo/project/mit-scheme-9.2/src/microcode/interp.c"
void *obstack_chunk_alloc(size_t size ) ;
#line 37
void fixup_float_environment(void) ;
#line 199 "/home/khheo/project/mit-scheme-9.2/src/microcode/interp.c"
interpreter_state_t interpreter_state  =    (interpreter_state_t )0;
#line 201 "/home/khheo/project/mit-scheme-9.2/src/microcode/interp.c"
void bind_interpreter_state(interpreter_state_t s ) 
{ 


  {
#line 204
  s->previous_state = interpreter_state;
#line 205
  if ((unsigned long )interpreter_state == (unsigned long )((interpreter_state_t )0)) {
#line 205
    s->nesting_level = 0U;
  } else {
#line 205
    s->nesting_level = 1U + interpreter_state->nesting_level;
  }
#line 209
  s->dstack_position = dstack_position;
#line 210
  interpreter_state = s;
#line 211
  return;
}
}
#line 213 "/home/khheo/project/mit-scheme-9.2/src/microcode/interp.c"
void unbind_interpreter_state(interpreter_state_t s ) 
{ 
  unsigned long old_mask ;
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;
  SCHEME_OBJECT *tmp___2 ;
  SCHEME_OBJECT *tmp___3 ;
  SCHEME_OBJECT *tmp___4 ;

  {
#line 216
  interpreter_state = s;
#line 218
  old_mask = Registers[1];
  {
#line 219
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 219
    set_ulong_register(1U, 0UL);
    }
    {
#line 219
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 219
      if ((Registers[1] & Registers[12]) != 0UL) {
#line 219
        tmp___0 = memory_block_start;
      } else {
#line 219
        if ((Registers[1] & 4UL) != 0UL) {
#line 219
          tmp = heap_alloc_limit;
        } else {
#line 219
          tmp = heap_end;
        }
#line 219
        tmp___0 = tmp;
      }
      {
#line 219
      set_ptr_register(0U, tmp___0);
      }
#line 219
      if ((Registers[1] & 1UL) != 0UL) {
#line 219
        tmp___1 = stack_guard;
      } else {
#line 219
        tmp___1 = stack_start;
      }
      {
#line 219
      set_ptr_register(11U, tmp___1);
      }
#line 219
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 219
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 220
  dstack_set_position(s->dstack_position);
  }
  {
#line 221
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 221
    set_ulong_register(1U, old_mask);
    }
    {
#line 221
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 221
      if ((Registers[1] & Registers[12]) != 0UL) {
#line 221
        tmp___3 = memory_block_start;
      } else {
#line 221
        if ((Registers[1] & 4UL) != 0UL) {
#line 221
          tmp___2 = heap_alloc_limit;
        } else {
#line 221
          tmp___2 = heap_end;
        }
#line 221
        tmp___3 = tmp___2;
      }
      {
#line 221
      set_ptr_register(0U, tmp___3);
      }
#line 221
      if ((Registers[1] & 1UL) != 0UL) {
#line 221
        tmp___4 = stack_guard;
      } else {
#line 221
        tmp___4 = stack_start;
      }
      {
#line 221
      set_ptr_register(11U, tmp___4);
      }
#line 221
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 221
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 223
  interpreter_state = s->previous_state;
#line 224
  return;
}
}
#line 226
 __attribute__((__noreturn__)) void abort_to_interpreter(int argument ) ;
#line 226 "/home/khheo/project/mit-scheme-9.2/src/microcode/interp.c"
void abort_to_interpreter(int argument ) 
{ 
  unsigned long old_mask ;
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;
  SCHEME_OBJECT *tmp___2 ;
  SCHEME_OBJECT *tmp___3 ;
  SCHEME_OBJECT *tmp___4 ;
  struct obstack *__o ;
  void *__obj ;
  char *tmp___5 ;
  char *__cil_tmp12 ;

  {
#line 229
  if ((unsigned long )interpreter_state == (unsigned long )((interpreter_state_t )0)) {
    {
#line 231
    outf_fatal("abort_to_interpreter: Interpreter not set up.\n");
#line 232
    termination_init_error();
    }
  }
#line 235
  interpreter_state->throw_argument = argument;
#line 237
  old_mask = Registers[1];
  {
#line 238
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 238
    set_ulong_register(1U, 0UL);
    }
    {
#line 238
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 238
      if ((Registers[1] & Registers[12]) != 0UL) {
#line 238
        tmp___0 = memory_block_start;
      } else {
#line 238
        if ((Registers[1] & 4UL) != 0UL) {
#line 238
          tmp = heap_alloc_limit;
        } else {
#line 238
          tmp = heap_end;
        }
#line 238
        tmp___0 = tmp;
      }
      {
#line 238
      set_ptr_register(0U, tmp___0);
      }
#line 238
      if ((Registers[1] & 1UL) != 0UL) {
#line 238
        tmp___1 = stack_guard;
      } else {
#line 238
        tmp___1 = stack_start;
      }
      {
#line 238
      set_ptr_register(11U, tmp___1);
      }
#line 238
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 238
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 239
  dstack_set_position(interpreter_state->dstack_position);
  }
  {
#line 240
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 240
    set_ulong_register(1U, old_mask);
    }
    {
#line 240
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 240
      if ((Registers[1] & Registers[12]) != 0UL) {
#line 240
        tmp___3 = memory_block_start;
      } else {
#line 240
        if ((Registers[1] & 4UL) != 0UL) {
#line 240
          tmp___2 = heap_alloc_limit;
        } else {
#line 240
          tmp___2 = heap_end;
        }
#line 240
        tmp___3 = tmp___2;
      }
      {
#line 240
      set_ptr_register(0U, tmp___3);
      }
#line 240
      if ((Registers[1] & 1UL) != 0UL) {
#line 240
        tmp___4 = stack_guard;
      } else {
#line 240
        tmp___4 = stack_start;
      }
      {
#line 240
      set_ptr_register(11U, tmp___4);
      }
#line 240
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 240
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 242
  __o = & scratch_obstack;
#line 242
  __obj = (void *)0;
#line 242
  if ((unsigned long )__obj > (unsigned long )((void *)__o->chunk)) {
#line 242
    if ((unsigned long )__obj < (unsigned long )((void *)__o->chunk_limit)) {
#line 242
      tmp___5 = (char *)__obj;
#line 242
      __o->object_base = tmp___5;
#line 242
      __o->next_free = tmp___5;
    } else {
      {
#line 242
      obstack_free(__o, __obj);
      }
    }
  } else {
    {
#line 242
    obstack_free(__o, __obj);
    }
  }
  {
#line 243
  _obstack_begin(& scratch_obstack, 0, 0L, & obstack_chunk_alloc, (void (*)(void * ))(& free));
#line 244
  longjmp((struct __jmp_buf_tag *)(interpreter_state->catch_env), argument);
  }
}
}
#line 247 "/home/khheo/project/mit-scheme-9.2/src/microcode/interp.c"
int abort_to_interpreter_argument(void) 
{ 


  {
#line 250
  return (interpreter_state->throw_argument);
}
}
#line 255 "/home/khheo/project/mit-scheme-9.2/src/microcode/interp.c"
void Interpret(int pop_return_p ) 
{ 
  long dispatch_code ;
  struct interpreter_state_s new_state___1 ;
  int tmp ;
  SCHEME_OBJECT temp ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;
  SCHEME_OBJECT *tmp___2 ;
  SCHEME_OBJECT *tmp___3 ;
  SCHEME_OBJECT *tmp___4 ;
  SCHEME_OBJECT *tmp___5 ;
  SCHEME_OBJECT *tmp___6 ;
  SCHEME_OBJECT *tmp___7 ;
  SCHEME_OBJECT *tmp___8 ;
  long length ;
  SCHEME_OBJECT *tmp___9 ;
  SCHEME_OBJECT *tmp___10 ;
  SCHEME_OBJECT *tmp___11 ;
  SCHEME_OBJECT *tmp___12 ;
  SCHEME_OBJECT *tmp___13 ;
  SCHEME_OBJECT *tmp___14 ;
  SCHEME_OBJECT *tmp___15 ;
  SCHEME_OBJECT *tmp___16 ;
  SCHEME_OBJECT *tmp___17 ;
  SCHEME_OBJECT *tmp___18 ;
  SCHEME_OBJECT *tmp___19 ;
  SCHEME_OBJECT *tmp___20 ;
  SCHEME_OBJECT *tmp___21 ;
  SCHEME_OBJECT *tmp___22 ;
  SCHEME_OBJECT *tmp___23 ;
  SCHEME_OBJECT val ;
  SCHEME_OBJECT name ;
  long temp___0 ;
  long tmp___24 ;
  SCHEME_OBJECT *tmp___25 ;
  SCHEME_OBJECT *tmp___26 ;
  SCHEME_OBJECT *tmp___27 ;
  SCHEME_OBJECT *tmp___28 ;
  SCHEME_OBJECT *tmp___29 ;
  SCHEME_OBJECT *tmp___30 ;
  SCHEME_OBJECT *tmp___31 ;
  SCHEME_OBJECT *tmp___32 ;
  long Arg_Number ;
  SCHEME_OBJECT *tmp___33 ;
  SCHEME_OBJECT *tmp___34 ;
  int tmp___35 ;
  SCHEME_OBJECT *tmp___36 ;
  interpreter_state_t previous_state ;
  SCHEME_OBJECT *tmp___37 ;
  SCHEME_OBJECT val___0 ;
  long code ;
  SCHEME_OBJECT temp___1 ;
  SCHEME_OBJECT variable ;
  SCHEME_OBJECT old_val ;
  long code___0 ;
  SCHEME_OBJECT *tmp___38 ;
  SCHEME_OBJECT temp___2 ;
  SCHEME_OBJECT name___0 ;
  SCHEME_OBJECT value ;
  long result ;
  SCHEME_OBJECT *tmp___39 ;
  SCHEME_OBJECT temp___3 ;
  SCHEME_OBJECT info ;
  SCHEME_OBJECT handler ;
  SCHEME_OBJECT *tmp___40 ;
  SCHEME_OBJECT *tmp___41 ;
  SCHEME_OBJECT *tmp___42 ;
  unsigned long frame_size ;
  unsigned long interrupts ;
  SCHEME_OBJECT temp___4 ;
  SCHEME_OBJECT Function ;
  unsigned long frame_size___0 ;
  SCHEME_OBJECT data ;
  SCHEME_OBJECT *tmp___43 ;
  SCHEME_OBJECT *tmp___44 ;
  SCHEME_OBJECT *tmp___45 ;
  unsigned long frame_size___1 ;
  SCHEME_OBJECT formals ;
  SCHEME_OBJECT temp___5 ;
  SCHEME_OBJECT *tmp___46 ;
  SCHEME_OBJECT *tmp___47 ;
  SCHEME_OBJECT *tmp___48 ;
  SCHEME_OBJECT *end ;
  SCHEME_OBJECT env ;
  SCHEME_OBJECT *tmp___49 ;
  SCHEME_OBJECT *tmp___50 ;
  SCHEME_OBJECT *tmp___51 ;
  SCHEME_OBJECT *tmp___52 ;
  unsigned long n_args ;
  SCHEME_OBJECT *APFI_saved_history ;
  void *PRIMITIVE_APPLY_INTERNAL_position ;
  SCHEME_OBJECT lambda ;
  SCHEME_OBJECT temp___6 ;
  unsigned long nargs ;
  unsigned long nparams ;
  unsigned long formals___0 ;
  unsigned long params ;
  unsigned long auxes ;
  long rest_flag ;
  long size ;
  long i ;
  SCHEME_OBJECT *scan ;
  SCHEME_OBJECT *tmp___53 ;
  SCHEME_OBJECT temp___7 ;
  SCHEME_OBJECT *tmp___54 ;
  SCHEME_OBJECT *tmp___55 ;
  SCHEME_OBJECT *tmp___56 ;
  unsigned long tmp___57 ;
  unsigned long tmp___58 ;
  SCHEME_OBJECT *tmp___59 ;
  SCHEME_OBJECT *tmp___60 ;
  SCHEME_OBJECT *tmp___61 ;
  SCHEME_OBJECT *tmp___62 ;
  SCHEME_OBJECT *tmp___63 ;
  SCHEME_OBJECT *tmp___64 ;
  SCHEME_OBJECT list ;
  SCHEME_OBJECT *tmp___65 ;
  SCHEME_OBJECT *tmp___66 ;
  SCHEME_OBJECT *tmp___67 ;
  SCHEME_OBJECT *tmp___68 ;
  SCHEME_OBJECT *tmp___69 ;
  SCHEME_OBJECT *tmp___70 ;
  SCHEME_OBJECT temp___8 ;
  char const   *name___1 ;
  SCHEME_OBJECT *tmp___71 ;
  SCHEME_OBJECT *tmp___72 ;
  SCHEME_OBJECT *tmp___73 ;
  SCHEME_OBJECT *tmp___74 ;
  SCHEME_OBJECT *tmp___75 ;
  SCHEME_OBJECT *tmp___76 ;
  SCHEME_OBJECT *tmp___77 ;
  SCHEME_OBJECT *tmp___78 ;
  long tmp___79 ;
  _Bool tmp___80 ;
  SCHEME_OBJECT *tmp___81 ;
  SCHEME_OBJECT *tmp___82 ;
  SCHEME_OBJECT *tmp___83 ;
  SCHEME_OBJECT *tmp___84 ;
  SCHEME_OBJECT *tmp___85 ;
  SCHEME_OBJECT *tmp___86 ;
  SCHEME_OBJECT *tmp___87 ;
  SCHEME_OBJECT *tmp___88 ;
  SCHEME_OBJECT *tmp___89 ;
  void *__cil_tmp144 ;
  int __cil_tmp145 ;
  void *__cil_tmp146 ;
  void *__cil_tmp147 ;
  char *__cil_tmp148 ;
  char *__cil_tmp149 ;
  char *__cil_tmp150 ;
  char *__cil_tmp151 ;
  char *__cil_tmp152 ;
  char *__cil_tmp153 ;
  char *__cil_tmp154 ;
  char *__cil_tmp155 ;
  char *__cil_tmp156 ;
  char *__cil_tmp157 ;
  char *__cil_tmp158 ;
  char *__cil_tmp159 ;
  char *__cil_tmp160 ;
  char *__cil_tmp161 ;
  char *__cil_tmp162 ;

  {
  {
#line 269
  bind_interpreter_state(& new_state___1);
#line 270
  tmp = _setjmp((struct __jmp_buf_tag *)(interpreter_state->catch_env));
#line 270
  dispatch_code = (long )tmp;
#line 271
  preserve_signal_mask();
#line 272
  fixup_float_environment();
  }
  {
#line 276
  if (dispatch_code == 0L) {
#line 276
    goto case_0;
  }
#line 282
  if (dispatch_code == -3L) {
#line 282
    goto case_neg_3;
  }
#line 286
  if (dispatch_code == -6L) {
#line 286
    goto case_neg_6;
  }
#line 290
  if (dispatch_code == -9L) {
#line 290
    goto case_neg_9;
  }
#line 295
  if (dispatch_code == -10L) {
#line 295
    goto case_neg_10;
  }
#line 299
  if (dispatch_code == -2L) {
#line 299
    goto case_neg_2;
  }
#line 304
  if (dispatch_code == -5L) {
#line 304
    goto case_neg_5;
  }
#line 310
  if (dispatch_code == -7L) {
#line 310
    goto case_neg_7;
  }
#line 314
  if (dispatch_code == -12L) {
#line 314
    goto case_neg_12;
  }
#line 319
  if (dispatch_code == -11L) {
#line 319
    goto case_neg_11;
  }
#line 323
  if (dispatch_code == -4L) {
#line 323
    goto case_neg_4;
  }
#line 327
  if (dispatch_code == -13L) {
#line 327
    goto case_neg_13;
  }
#line 332
  if (dispatch_code == 13L) {
#line 332
    goto case_13;
  }
#line 337
  if (dispatch_code == 14L) {
#line 337
    goto case_14;
  }
#line 342
  if (dispatch_code == 15L) {
#line 342
    goto case_15;
  }
#line 347
  goto switch_default;
  case_0: /* CIL Label */ 
#line 277
  if (pop_return_p) {
#line 278
    goto pop_return;
  } else {
#line 280
    goto switch_break;
  }
  case_neg_3: /* CIL Label */ 
#line 283
  Registers[8] = 0UL;
#line 284
  goto internal_apply;
  case_neg_6: /* CIL Label */ 
#line 287
  Registers[8] = 0UL;
#line 288
  goto Apply_Non_Trapping;
  case_neg_9: /* CIL Label */ 
#line 291
  Registers[8] = 0UL;
#line 292
  Registers[5] = 0UL;
#line 292
  temp = *(stack_pointer + 1);
#line 292
  Registers[6] = (11UL << 58U) | 93UL;
  {
#line 292
  while (1) {
    while_continue: /* CIL Label */ ;
#line 292
    stack_pointer --;
#line 292
    *stack_pointer = Registers[5];
#line 292
    stack_pointer --;
#line 292
    *stack_pointer = Registers[6];
#line 292
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 292
  Registers[6] = (11UL << 58U) | 46UL;
#line 292
  Registers[5] = temp;
  {
#line 292
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 292
    stack_pointer --;
#line 292
    *stack_pointer = Registers[5];
#line 292
    stack_pointer --;
#line 292
    *stack_pointer = Registers[6];
#line 292
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 293
  setup_interrupt(Registers[1] & Registers[12]);
  }
#line 293
  goto perform_application;
  case_neg_10: /* CIL Label */ 
#line 296
  Registers[8] = 0UL;
  {
#line 297
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 297
    Registers[5] = 0UL;
#line 297
    Registers[6] = (11UL << 58U) | 93UL;
    {
#line 297
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 297
      stack_pointer --;
#line 297
      *stack_pointer = Registers[5];
#line 297
      stack_pointer --;
#line 297
      *stack_pointer = Registers[6];
#line 297
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 297
    Registers[2] = *(stack_pointer + 1);
#line 297
    Do_Micro_Error(prim_apply_error_code, (_Bool)1);
    }
#line 297
    goto internal_apply;
#line 297
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  case_neg_2: /* CIL Label */ 
#line 300
  Registers[2] = Registers[5];
#line 301
  Registers[8] = 0UL;
  {
#line 302
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 302
    Registers[5] = Registers[2];
#line 302
    new_reduction(Registers[5], Registers[3]);
    }
#line 302
    goto do_expression;
#line 302
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  case_neg_5: /* CIL Label */ 
  {
#line 305
  Registers[2] = Registers[5];
#line 306
  Registers[8] = 0UL;
#line 307
  new_reduction(Registers[2], Registers[3]);
  }
#line 308
  goto eval_non_trapping;
  case_neg_7: /* CIL Label */ 
#line 311
  Registers[8] = 0UL;
#line 312
  goto pop_return;
  case_neg_12: /* CIL Label */ 
  {
#line 315
  Registers[8] = 0UL;
#line 316
  unbind_interpreter_state(interpreter_state);
  }
#line 317
  return;
  case_neg_11: /* CIL Label */ 
#line 320
  Registers[8] = 0UL;
#line 321
  goto pop_return_non_trapping;
  case_neg_4: /* CIL Label */ 
  {
#line 324
  back_out_of_primitive();
#line 325
  setup_interrupt(Registers[1] & Registers[12]);
  }
#line 325
  goto perform_application;
  case_neg_13: /* CIL Label */ 
  {
#line 328
  back_out_of_primitive();
#line 329
  unbind_interpreter_state(interpreter_state);
  }
#line 330
  return;
  case_13: /* CIL Label */ 
  {
#line 333
  back_out_of_primitive();
#line 334
  Do_Micro_Error(13L, (_Bool)1);
  }
#line 335
  goto internal_apply;
  case_14: /* CIL Label */ 
  {
#line 338
  back_out_of_primitive();
#line 339
  Do_Micro_Error(14L, (_Bool)1);
  }
#line 340
  goto internal_apply;
  case_15: /* CIL Label */ 
  {
#line 343
  back_out_of_primitive();
#line 344
  Do_Micro_Error(15L, (_Bool)1);
  }
#line 345
  goto internal_apply;
  switch_default: /* CIL Label */ 
  {
#line 348
  back_out_of_primitive();
#line 349
  Do_Micro_Error(dispatch_code, (_Bool)1);
  }
#line 350
  goto internal_apply;
  switch_break: /* CIL Label */ ;
  }
  do_expression: 
#line 387
  if (trapping) {
#line 387
    if (! ((unsigned long )critical_section_name != (unsigned long )((char const   *)0))) {
#line 387
      if (*((SCHEME_OBJECT *)(*((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 15) & 288230376151711743UL) + 0) != 0UL) {
#line 391
        trapping = (_Bool)0;
        {
#line 392
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 392
          if (! ((unsigned long )(stack_pointer + -4) >= (unsigned long )stack_guard)) {
            {
#line 392
            while (1) {
              while_continue___5: /* CIL Label */ ;
#line 392
              if (*stack_start != ((34UL << 58U) | (SCHEME_OBJECT )stack_start)) {
                {
#line 392
                stack_death("STACK_CHECK");
                }
              }
#line 392
              goto while_break___5;
            }
            while_break___5: /* CIL Label */ ;
            }
            {
#line 392
            while (1) {
              while_continue___6: /* CIL Label */ ;
              {
#line 392
              set_ulong_register(12U, Registers[12] | 1UL);
              }
              {
#line 392
              while (1) {
                while_continue___7: /* CIL Label */ ;
#line 392
                if ((Registers[1] & Registers[12]) != 0UL) {
#line 392
                  tmp___1 = memory_block_start;
                } else {
#line 392
                  if ((Registers[1] & 4UL) != 0UL) {
#line 392
                    tmp___0 = heap_alloc_limit;
                  } else {
#line 392
                    tmp___0 = heap_end;
                  }
#line 392
                  tmp___1 = tmp___0;
                }
                {
#line 392
                set_ptr_register(0U, tmp___1);
                }
#line 392
                if ((Registers[1] & 1UL) != 0UL) {
#line 392
                  tmp___2 = stack_guard;
                } else {
#line 392
                  tmp___2 = stack_start;
                }
                {
#line 392
                set_ptr_register(11U, tmp___2);
                }
#line 392
                goto while_break___7;
              }
              while_break___7: /* CIL Label */ ;
              }
#line 392
              goto while_break___6;
            }
            while_break___6: /* CIL Label */ ;
            }
          }
#line 392
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 393
        stack_pointer --;
#line 393
        *stack_pointer = Registers[3];
#line 394
        stack_pointer --;
#line 394
        *stack_pointer = Registers[5];
#line 395
        stack_pointer --;
#line 395
        *stack_pointer = *((SCHEME_OBJECT *)(*((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 15) & 288230376151711743UL) + 0);
#line 396
        stack_pointer --;
#line 396
        *stack_pointer = 3UL;
#line 398
        goto Apply_Non_Trapping;
      }
    }
  }
  eval_non_trapping: 
  {
#line 441
  if (Registers[5] >> 58U == 31UL) {
#line 441
    goto case_31;
  }
#line 445
  if (Registers[5] >> 58U == 35UL) {
#line 445
    goto case_35;
  }
#line 450
  if (Registers[5] >> 58U == 34UL) {
#line 450
    goto case_34;
  }
#line 453
  if (Registers[5] >> 58U == 38UL) {
#line 453
    goto case_38;
  }
#line 470
  if (Registers[5] >> 58U == 21UL) {
#line 470
    goto case_21;
  }
#line 473
  if (Registers[5] >> 58U == 52UL) {
#line 473
    goto case_52;
  }
#line 479
  if (Registers[5] >> 58U == 40UL) {
#line 479
    goto case_40;
  }
#line 484
  if (Registers[5] >> 58U == 33UL) {
#line 484
    goto case_33;
  }
#line 489
  if (Registers[5] >> 58U == 17UL) {
#line 489
    goto case_17;
  }
#line 497
  if (Registers[5] >> 58U == 53UL) {
#line 497
    goto case_53;
  }
#line 502
  if (Registers[5] >> 58U == 20UL) {
#line 502
    goto case_20;
  }
#line 511
  if (Registers[5] >> 58U == 41UL) {
#line 511
    goto case_41;
  }
#line 511
  if (Registers[5] >> 58U == 23UL) {
#line 511
    goto case_41;
  }
#line 519
  if (Registers[5] >> 58U == 39UL) {
#line 519
    goto case_39;
  }
#line 522
  if (Registers[5] >> 58U == 3UL) {
#line 522
    goto case_3;
  }
#line 526
  if (Registers[5] >> 58U == 25UL) {
#line 526
    goto case_25;
  }
#line 531
  if (Registers[5] >> 58U == 46UL) {
#line 531
    goto case_46;
  }
#line 534
  if (Registers[5] >> 58U == 45UL) {
#line 534
    goto case_45;
  }
#line 538
  if (Registers[5] >> 58U == 44UL) {
#line 538
    goto case_44;
  }
#line 437
  goto switch_default___0;
  switch_default___0: /* CIL Label */ 
#line 438
  Registers[2] = Registers[5];
#line 439
  goto switch_break___0;
  case_31: /* CIL Label */ 
  {
#line 442
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 442
    if (! ((unsigned long )(stack_pointer + -2) >= (unsigned long )stack_guard)) {
      {
#line 442
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 442
        if (*stack_start != ((34UL << 58U) | (SCHEME_OBJECT )stack_start)) {
          {
#line 442
          stack_death("STACK_CHECK");
          }
        }
#line 442
        goto while_break___9;
      }
      while_break___9: /* CIL Label */ ;
      }
      {
#line 442
      while (1) {
        while_continue___10: /* CIL Label */ ;
        {
#line 442
        set_ulong_register(12U, Registers[12] | 1UL);
        }
        {
#line 442
        while (1) {
          while_continue___11: /* CIL Label */ ;
#line 442
          if ((Registers[1] & Registers[12]) != 0UL) {
#line 442
            tmp___4 = memory_block_start;
          } else {
#line 442
            if ((Registers[1] & 4UL) != 0UL) {
#line 442
              tmp___3 = heap_alloc_limit;
            } else {
#line 442
              tmp___3 = heap_end;
            }
#line 442
            tmp___4 = tmp___3;
          }
          {
#line 442
          set_ptr_register(0U, tmp___4);
          }
#line 442
          if ((Registers[1] & 1UL) != 0UL) {
#line 442
            tmp___5 = stack_guard;
          } else {
#line 442
            tmp___5 = stack_start;
          }
          {
#line 442
          set_ptr_register(11U, tmp___5);
          }
#line 442
          goto while_break___11;
        }
        while_break___11: /* CIL Label */ ;
        }
#line 442
        goto while_break___10;
      }
      while_break___10: /* CIL Label */ ;
      }
    }
#line 442
    goto while_break___8;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 443
  Registers[6] = (11UL << 58U) | 10UL;
  {
#line 443
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 443
    stack_pointer --;
#line 443
    *stack_pointer = Registers[5];
#line 443
    stack_pointer --;
#line 443
    *stack_pointer = Registers[6];
#line 443
    goto while_break___12;
  }
  while_break___12: /* CIL Label */ ;
  }
  {
#line 443
  Registers[5] = *((SCHEME_OBJECT *)(Registers[5] & 288230376151711743UL) + 0);
#line 443
  new_subproblem(Registers[5], Registers[3]);
  }
#line 443
  goto do_expression;
  case_35: /* CIL Label */ 
  {
#line 446
  while (1) {
    while_continue___13: /* CIL Label */ ;
#line 446
    if (! ((unsigned long )(stack_pointer + -3) >= (unsigned long )stack_guard)) {
      {
#line 446
      while (1) {
        while_continue___14: /* CIL Label */ ;
#line 446
        if (*stack_start != ((34UL << 58U) | (SCHEME_OBJECT )stack_start)) {
          {
#line 446
          stack_death("STACK_CHECK");
          }
        }
#line 446
        goto while_break___14;
      }
      while_break___14: /* CIL Label */ ;
      }
      {
#line 446
      while (1) {
        while_continue___15: /* CIL Label */ ;
        {
#line 446
        set_ulong_register(12U, Registers[12] | 1UL);
        }
        {
#line 446
        while (1) {
          while_continue___16: /* CIL Label */ ;
#line 446
          if ((Registers[1] & Registers[12]) != 0UL) {
#line 446
            tmp___7 = memory_block_start;
          } else {
#line 446
            if ((Registers[1] & 4UL) != 0UL) {
#line 446
              tmp___6 = heap_alloc_limit;
            } else {
#line 446
              tmp___6 = heap_end;
            }
#line 446
            tmp___7 = tmp___6;
          }
          {
#line 446
          set_ptr_register(0U, tmp___7);
          }
#line 446
          if ((Registers[1] & 1UL) != 0UL) {
#line 446
            tmp___8 = stack_guard;
          } else {
#line 446
            tmp___8 = stack_start;
          }
          {
#line 446
          set_ptr_register(11U, tmp___8);
          }
#line 446
          goto while_break___16;
        }
        while_break___16: /* CIL Label */ ;
        }
#line 446
        goto while_break___15;
      }
      while_break___15: /* CIL Label */ ;
      }
    }
#line 446
    goto while_break___13;
  }
  while_break___13: /* CIL Label */ ;
  }
#line 447
  stack_pointer --;
#line 447
  *stack_pointer = Registers[3];
#line 448
  Registers[6] = (11UL << 58U) | 8UL;
  {
#line 448
  while (1) {
    while_continue___17: /* CIL Label */ ;
#line 448
    stack_pointer --;
#line 448
    *stack_pointer = Registers[5];
#line 448
    stack_pointer --;
#line 448
    *stack_pointer = Registers[6];
#line 448
    goto while_break___17;
  }
  while_break___17: /* CIL Label */ ;
  }
  {
#line 448
  Registers[5] = *((SCHEME_OBJECT *)(Registers[5] & 288230376151711743UL) + 1);
#line 448
  new_subproblem(Registers[5], Registers[3]);
  }
#line 448
  goto do_expression;
  case_34: /* CIL Label */ 
  {
#line 451
  Microcode_Termination(2);
  }
  case_38: /* CIL Label */ 
#line 455
  length = (long )((*((SCHEME_OBJECT *)(Registers[5] & 288230376151711743UL) + 0) & 288230376151711743UL) - 1UL);
  {
#line 456
  while (1) {
    while_continue___18: /* CIL Label */ ;
#line 456
    if (! ((unsigned long )(stack_pointer + - ((length + 2L) + 2L)) >= (unsigned long )stack_guard)) {
      {
#line 456
      while (1) {
        while_continue___19: /* CIL Label */ ;
#line 456
        if (*stack_start != ((34UL << 58U) | (SCHEME_OBJECT )stack_start)) {
          {
#line 456
          stack_death("STACK_CHECK");
          }
        }
#line 456
        goto while_break___19;
      }
      while_break___19: /* CIL Label */ ;
      }
      {
#line 456
      while (1) {
        while_continue___20: /* CIL Label */ ;
        {
#line 456
        set_ulong_register(12U, Registers[12] | 1UL);
        }
        {
#line 456
        while (1) {
          while_continue___21: /* CIL Label */ ;
#line 456
          if ((Registers[1] & Registers[12]) != 0UL) {
#line 456
            tmp___10 = memory_block_start;
          } else {
#line 456
            if ((Registers[1] & 4UL) != 0UL) {
#line 456
              tmp___9 = heap_alloc_limit;
            } else {
#line 456
              tmp___9 = heap_end;
            }
#line 456
            tmp___10 = tmp___9;
          }
          {
#line 456
          set_ptr_register(0U, tmp___10);
          }
#line 456
          if ((Registers[1] & 1UL) != 0UL) {
#line 456
            tmp___11 = stack_guard;
          } else {
#line 456
            tmp___11 = stack_start;
          }
          {
#line 456
          set_ptr_register(11U, tmp___11);
          }
#line 456
          goto while_break___21;
        }
        while_break___21: /* CIL Label */ ;
        }
#line 456
        goto while_break___20;
      }
      while_break___20: /* CIL Label */ ;
      }
    }
#line 456
    goto while_break___18;
  }
  while_break___18: /* CIL Label */ ;
  }
#line 457
  stack_pointer += - length;
#line 458
  stack_pointer --;
#line 458
  *stack_pointer = (39UL << 58U) | (unsigned long )length;
#line 461
  if (length == 0L) {
#line 463
    stack_pointer --;
#line 463
    *stack_pointer = 1UL;
    {
#line 464
    while (1) {
      while_continue___22: /* CIL Label */ ;
#line 464
      Registers[6] = (11UL << 58U) | 18UL;
      {
#line 464
      while (1) {
        while_continue___23: /* CIL Label */ ;
#line 464
        stack_pointer --;
#line 464
        *stack_pointer = Registers[5];
#line 464
        stack_pointer --;
#line 464
        *stack_pointer = Registers[6];
#line 464
        goto while_break___23;
      }
      while_break___23: /* CIL Label */ ;
      }
      {
#line 464
      Registers[5] = *((SCHEME_OBJECT *)(Registers[5] & 288230376151711743UL) + 1);
#line 464
      new_subproblem(Registers[5], Registers[3]);
      }
#line 464
      goto do_expression;
#line 464
      goto while_break___22;
    }
    while_break___22: /* CIL Label */ ;
    }
  }
#line 466
  stack_pointer --;
#line 466
  *stack_pointer = Registers[3];
  {
#line 467
  while (1) {
    while_continue___24: /* CIL Label */ ;
#line 467
    Registers[6] = (11UL << 58U) | 21UL;
    {
#line 467
    while (1) {
      while_continue___25: /* CIL Label */ ;
#line 467
      stack_pointer --;
#line 467
      *stack_pointer = Registers[5];
#line 467
      stack_pointer --;
#line 467
      *stack_pointer = Registers[6];
#line 467
      goto while_break___25;
    }
    while_break___25: /* CIL Label */ ;
    }
    {
#line 467
    Registers[5] = *((SCHEME_OBJECT *)(Registers[5] & 288230376151711743UL) + (length + 1L));
#line 467
    new_subproblem(Registers[5], Registers[3]);
    }
#line 467
    goto do_expression;
#line 467
    goto while_break___24;
  }
  while_break___24: /* CIL Label */ ;
  }
  case_21: /* CIL Label */ 
  {
#line 471
  while (1) {
    while_continue___26: /* CIL Label */ ;
    {
#line 471
    Registers[5] = *((SCHEME_OBJECT *)(Registers[5] & 288230376151711743UL) + 0);
#line 471
    new_reduction(Registers[5], Registers[3]);
    }
#line 471
    goto do_expression;
#line 471
    goto while_break___26;
  }
  while_break___26: /* CIL Label */ ;
  }
  case_52: /* CIL Label */ 
  {
#line 474
  while (1) {
    while_continue___27: /* CIL Label */ ;
#line 474
    if (! ((unsigned long )(stack_pointer + -3) >= (unsigned long )stack_guard)) {
      {
#line 474
      while (1) {
        while_continue___28: /* CIL Label */ ;
#line 474
        if (*stack_start != ((34UL << 58U) | (SCHEME_OBJECT )stack_start)) {
          {
#line 474
          stack_death("STACK_CHECK");
          }
        }
#line 474
        goto while_break___28;
      }
      while_break___28: /* CIL Label */ ;
      }
      {
#line 474
      while (1) {
        while_continue___29: /* CIL Label */ ;
        {
#line 474
        set_ulong_register(12U, Registers[12] | 1UL);
        }
        {
#line 474
        while (1) {
          while_continue___30: /* CIL Label */ ;
#line 474
          if ((Registers[1] & Registers[12]) != 0UL) {
#line 474
            tmp___13 = memory_block_start;
          } else {
#line 474
            if ((Registers[1] & 4UL) != 0UL) {
#line 474
              tmp___12 = heap_alloc_limit;
            } else {
#line 474
              tmp___12 = heap_end;
            }
#line 474
            tmp___13 = tmp___12;
          }
          {
#line 474
          set_ptr_register(0U, tmp___13);
          }
#line 474
          if ((Registers[1] & 1UL) != 0UL) {
#line 474
            tmp___14 = stack_guard;
          } else {
#line 474
            tmp___14 = stack_start;
          }
          {
#line 474
          set_ptr_register(11U, tmp___14);
          }
#line 474
          goto while_break___30;
        }
        while_break___30: /* CIL Label */ ;
        }
#line 474
        goto while_break___29;
      }
      while_break___29: /* CIL Label */ ;
      }
    }
#line 474
    goto while_break___27;
  }
  while_break___27: /* CIL Label */ ;
  }
#line 475
  stack_pointer --;
#line 475
  *stack_pointer = Registers[3];
#line 476
  Registers[6] = (11UL << 58U) | 15UL;
  {
#line 476
  while (1) {
    while_continue___31: /* CIL Label */ ;
#line 476
    stack_pointer --;
#line 476
    *stack_pointer = Registers[5];
#line 476
    stack_pointer --;
#line 476
    *stack_pointer = Registers[6];
#line 476
    goto while_break___31;
  }
  while_break___31: /* CIL Label */ ;
  }
  {
#line 476
  Registers[5] = *((SCHEME_OBJECT *)(Registers[5] & 288230376151711743UL) + 0);
#line 476
  new_subproblem(Registers[5], Registers[3]);
  }
#line 476
  goto do_expression;
  case_40: /* CIL Label */ 
  {
#line 480
  dispatch_code = enter_compiled_expression();
  }
#line 481
  goto return_from_compiled_code;
  case_33: /* CIL Label */ 
  {
#line 485
  while (1) {
    while_continue___32: /* CIL Label */ ;
#line 485
    if (! ((unsigned long )(stack_pointer + -3) >= (unsigned long )stack_guard)) {
      {
#line 485
      while (1) {
        while_continue___33: /* CIL Label */ ;
#line 485
        if (*stack_start != ((34UL << 58U) | (SCHEME_OBJECT )stack_start)) {
          {
#line 485
          stack_death("STACK_CHECK");
          }
        }
#line 485
        goto while_break___33;
      }
      while_break___33: /* CIL Label */ ;
      }
      {
#line 485
      while (1) {
        while_continue___34: /* CIL Label */ ;
        {
#line 485
        set_ulong_register(12U, Registers[12] | 1UL);
        }
        {
#line 485
        while (1) {
          while_continue___35: /* CIL Label */ ;
#line 485
          if ((Registers[1] & Registers[12]) != 0UL) {
#line 485
            tmp___16 = memory_block_start;
          } else {
#line 485
            if ((Registers[1] & 4UL) != 0UL) {
#line 485
              tmp___15 = heap_alloc_limit;
            } else {
#line 485
              tmp___15 = heap_end;
            }
#line 485
            tmp___16 = tmp___15;
          }
          {
#line 485
          set_ptr_register(0U, tmp___16);
          }
#line 485
          if ((Registers[1] & 1UL) != 0UL) {
#line 485
            tmp___17 = stack_guard;
          } else {
#line 485
            tmp___17 = stack_start;
          }
          {
#line 485
          set_ptr_register(11U, tmp___17);
          }
#line 485
          goto while_break___35;
        }
        while_break___35: /* CIL Label */ ;
        }
#line 485
        goto while_break___34;
      }
      while_break___34: /* CIL Label */ ;
      }
    }
#line 485
    goto while_break___32;
  }
  while_break___32: /* CIL Label */ ;
  }
#line 486
  stack_pointer --;
#line 486
  *stack_pointer = Registers[3];
#line 487
  Registers[6] = (11UL << 58U) | 9UL;
  {
#line 487
  while (1) {
    while_continue___36: /* CIL Label */ ;
#line 487
    stack_pointer --;
#line 487
    *stack_pointer = Registers[5];
#line 487
    stack_pointer --;
#line 487
    *stack_pointer = Registers[6];
#line 487
    goto while_break___36;
  }
  while_break___36: /* CIL Label */ ;
  }
  {
#line 487
  Registers[5] = *((SCHEME_OBJECT *)(Registers[5] & 288230376151711743UL) + 1);
#line 487
  new_subproblem(Registers[5], Registers[3]);
  }
#line 487
  goto do_expression;
  case_17: /* CIL Label */ 
#line 491
  Registers[2] = (19UL << 58U) | (SCHEME_OBJECT )Free;
#line 492
  *(Free + 0) = Registers[3];
#line 493
  *(Free + 1) = *((SCHEME_OBJECT *)(Registers[5] & 288230376151711743UL) + 0);
#line 494
  Free += 2;
#line 495
  goto switch_break___0;
  case_53: /* CIL Label */ 
  {
#line 498
  while (1) {
    while_continue___37: /* CIL Label */ ;
#line 498
    if (! ((unsigned long )(stack_pointer + -3) >= (unsigned long )stack_guard)) {
      {
#line 498
      while (1) {
        while_continue___38: /* CIL Label */ ;
#line 498
        if (*stack_start != ((34UL << 58U) | (SCHEME_OBJECT )stack_start)) {
          {
#line 498
          stack_death("STACK_CHECK");
          }
        }
#line 498
        goto while_break___38;
      }
      while_break___38: /* CIL Label */ ;
      }
      {
#line 498
      while (1) {
        while_continue___39: /* CIL Label */ ;
        {
#line 498
        set_ulong_register(12U, Registers[12] | 1UL);
        }
        {
#line 498
        while (1) {
          while_continue___40: /* CIL Label */ ;
#line 498
          if ((Registers[1] & Registers[12]) != 0UL) {
#line 498
            tmp___19 = memory_block_start;
          } else {
#line 498
            if ((Registers[1] & 4UL) != 0UL) {
#line 498
              tmp___18 = heap_alloc_limit;
            } else {
#line 498
              tmp___18 = heap_end;
            }
#line 498
            tmp___19 = tmp___18;
          }
          {
#line 498
          set_ptr_register(0U, tmp___19);
          }
#line 498
          if ((Registers[1] & 1UL) != 0UL) {
#line 498
            tmp___20 = stack_guard;
          } else {
#line 498
            tmp___20 = stack_start;
          }
          {
#line 498
          set_ptr_register(11U, tmp___20);
          }
#line 498
          goto while_break___40;
        }
        while_break___40: /* CIL Label */ ;
        }
#line 498
        goto while_break___39;
      }
      while_break___39: /* CIL Label */ ;
      }
    }
#line 498
    goto while_break___37;
  }
  while_break___37: /* CIL Label */ ;
  }
#line 499
  stack_pointer --;
#line 499
  *stack_pointer = Registers[3];
#line 500
  Registers[6] = (11UL << 58U) | 16UL;
  {
#line 500
  while (1) {
    while_continue___41: /* CIL Label */ ;
#line 500
    stack_pointer --;
#line 500
    *stack_pointer = Registers[5];
#line 500
    stack_pointer --;
#line 500
    *stack_pointer = Registers[6];
#line 500
    goto while_break___41;
  }
  while_break___41: /* CIL Label */ ;
  }
  {
#line 500
  Registers[5] = *((SCHEME_OBJECT *)(Registers[5] & 288230376151711743UL) + 0);
#line 500
  new_subproblem(Registers[5], Registers[3]);
  }
#line 500
  goto do_expression;
  case_20: /* CIL Label */ 
#line 504
  Registers[2] = (9UL << 58U) | (SCHEME_OBJECT )Free;
#line 505
  *(Free + 0) = Registers[5];
#line 506
  *(Free + 1) = Registers[3];
#line 507
  Free += 2;
#line 508
  goto switch_break___0;
  case_41: /* CIL Label */ 
  case_23: /* CIL Label */ 
#line 513
  Registers[2] = (15UL << 58U) | (SCHEME_OBJECT )Free;
#line 514
  *(Free + 0) = Registers[5];
#line 515
  *(Free + 1) = Registers[3];
#line 516
  Free += 2;
#line 517
  goto switch_break___0;
  case_39: /* CIL Label */ 
  {
#line 520
  while (1) {
    while_continue___42: /* CIL Label */ ;
    {
#line 520
    Do_Micro_Error(11L, (_Bool)0);
    }
#line 520
    goto internal_apply;
#line 520
    goto while_break___42;
  }
  while_break___42: /* CIL Label */ ;
  }
  case_3: /* CIL Label */ 
#line 523
  Registers[2] = *((SCHEME_OBJECT *)(Registers[5] & 288230376151711743UL) + 0);
#line 524
  goto switch_break___0;
  case_25: /* CIL Label */ 
  {
#line 527
  while (1) {
    while_continue___43: /* CIL Label */ ;
#line 527
    if (! ((unsigned long )(stack_pointer + -3) >= (unsigned long )stack_guard)) {
      {
#line 527
      while (1) {
        while_continue___44: /* CIL Label */ ;
#line 527
        if (*stack_start != ((34UL << 58U) | (SCHEME_OBJECT )stack_start)) {
          {
#line 527
          stack_death("STACK_CHECK");
          }
        }
#line 527
        goto while_break___44;
      }
      while_break___44: /* CIL Label */ ;
      }
      {
#line 527
      while (1) {
        while_continue___45: /* CIL Label */ ;
        {
#line 527
        set_ulong_register(12U, Registers[12] | 1UL);
        }
        {
#line 527
        while (1) {
          while_continue___46: /* CIL Label */ ;
#line 527
          if ((Registers[1] & Registers[12]) != 0UL) {
#line 527
            tmp___22 = memory_block_start;
          } else {
#line 527
            if ((Registers[1] & 4UL) != 0UL) {
#line 527
              tmp___21 = heap_alloc_limit;
            } else {
#line 527
              tmp___21 = heap_end;
            }
#line 527
            tmp___22 = tmp___21;
          }
          {
#line 527
          set_ptr_register(0U, tmp___22);
          }
#line 527
          if ((Registers[1] & 1UL) != 0UL) {
#line 527
            tmp___23 = stack_guard;
          } else {
#line 527
            tmp___23 = stack_start;
          }
          {
#line 527
          set_ptr_register(11U, tmp___23);
          }
#line 527
          goto while_break___46;
        }
        while_break___46: /* CIL Label */ ;
        }
#line 527
        goto while_break___45;
      }
      while_break___45: /* CIL Label */ ;
      }
    }
#line 527
    goto while_break___43;
  }
  while_break___43: /* CIL Label */ ;
  }
#line 528
  stack_pointer --;
#line 528
  *stack_pointer = Registers[3];
#line 529
  Registers[6] = (11UL << 58U) | 12UL;
  {
#line 529
  while (1) {
    while_continue___47: /* CIL Label */ ;
#line 529
    stack_pointer --;
#line 529
    *stack_pointer = Registers[5];
#line 529
    stack_pointer --;
#line 529
    *stack_pointer = Registers[6];
#line 529
    goto while_break___47;
  }
  while_break___47: /* CIL Label */ ;
  }
  {
#line 529
  Registers[5] = *((SCHEME_OBJECT *)(Registers[5] & 288230376151711743UL) + 0);
#line 529
  new_subproblem(Registers[5], Registers[3]);
  }
#line 529
  goto do_expression;
  case_46: /* CIL Label */ 
  {
#line 532
  while (1) {
    while_continue___48: /* CIL Label */ ;
    {
#line 532
    Do_Micro_Error(21L, (_Bool)0);
    }
#line 532
    goto internal_apply;
#line 532
    goto while_break___48;
  }
  while_break___48: /* CIL Label */ ;
  }
  case_45: /* CIL Label */ 
#line 535
  Registers[2] = Registers[3];
#line 536
  goto switch_break___0;
  case_44: /* CIL Label */ 
  {
#line 540
  val = Registers[2];
#line 541
  name = *((SCHEME_OBJECT *)(Registers[5] & 288230376151711743UL) + 0);
#line 542
  tmp___24 = lookup_variable(Registers[3], name, & val);
#line 542
  temp___0 = tmp___24;
  }
#line 543
  if (temp___0 != -1L) {
#line 546
    if (temp___0 == -4L) {
      {
#line 548
      while (1) {
        while_continue___49: /* CIL Label */ ;
        {
#line 548
        while (1) {
          while_continue___50: /* CIL Label */ ;
#line 548
          if (! ((unsigned long )(stack_pointer + -3) >= (unsigned long )stack_guard)) {
            {
#line 548
            while (1) {
              while_continue___51: /* CIL Label */ ;
#line 548
              if (*stack_start != ((34UL << 58U) | (SCHEME_OBJECT )stack_start)) {
                {
#line 548
                stack_death("STACK_CHECK");
                }
              }
#line 548
              goto while_break___51;
            }
            while_break___51: /* CIL Label */ ;
            }
            {
#line 548
            while (1) {
              while_continue___52: /* CIL Label */ ;
              {
#line 548
              set_ulong_register(12U, Registers[12] | 1UL);
              }
              {
#line 548
              while (1) {
                while_continue___53: /* CIL Label */ ;
#line 548
                if ((Registers[1] & Registers[12]) != 0UL) {
#line 548
                  tmp___26 = memory_block_start;
                } else {
#line 548
                  if ((Registers[1] & 4UL) != 0UL) {
#line 548
                    tmp___25 = heap_alloc_limit;
                  } else {
#line 548
                    tmp___25 = heap_end;
                  }
#line 548
                  tmp___26 = tmp___25;
                }
                {
#line 548
                set_ptr_register(0U, tmp___26);
                }
#line 548
                if ((Registers[1] & 1UL) != 0UL) {
#line 548
                  tmp___27 = stack_guard;
                } else {
#line 548
                  tmp___27 = stack_start;
                }
                {
#line 548
                set_ptr_register(11U, tmp___27);
                }
#line 548
                goto while_break___53;
              }
              while_break___53: /* CIL Label */ ;
              }
#line 548
              goto while_break___52;
            }
            while_break___52: /* CIL Label */ ;
            }
          }
#line 548
          goto while_break___50;
        }
        while_break___50: /* CIL Label */ ;
        }
#line 548
        stack_pointer --;
#line 548
        *stack_pointer = Registers[3];
#line 548
        Registers[6] = (11UL << 58U) | 65UL;
        {
#line 548
        while (1) {
          while_continue___54: /* CIL Label */ ;
#line 548
          stack_pointer --;
#line 548
          *stack_pointer = Registers[5];
#line 548
          stack_pointer --;
#line 548
          *stack_pointer = Registers[6];
#line 548
          goto while_break___54;
        }
        while_break___54: /* CIL Label */ ;
        }
#line 548
        goto while_break___49;
      }
      while_break___49: /* CIL Label */ ;
      }
      {
#line 549
      setup_interrupt(Registers[1] & Registers[12]);
      }
#line 549
      goto perform_application;
    }
    {
#line 551
    while (1) {
      while_continue___55: /* CIL Label */ ;
      {
#line 551
      Do_Micro_Error(temp___0, (_Bool)0);
      }
#line 551
      goto internal_apply;
#line 551
      goto while_break___55;
    }
    while_break___55: /* CIL Label */ ;
    }
  }
#line 553
  Registers[2] = val;
  switch_break___0: /* CIL Label */ ;
  }
  pop_return: 
#line 563
  if (trapping) {
#line 563
    if (! ((unsigned long )critical_section_name != (unsigned long )((char const   *)0))) {
#line 563
      if (*((SCHEME_OBJECT *)(*((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 15) & 288230376151711743UL) + 2) != 0UL) {
        {
#line 567
        while (1) {
          while_continue___56: /* CIL Label */ ;
#line 567
          if (! ((unsigned long )(stack_pointer + -3) >= (unsigned long )stack_guard)) {
            {
#line 567
            while (1) {
              while_continue___57: /* CIL Label */ ;
#line 567
              if (*stack_start != ((34UL << 58U) | (SCHEME_OBJECT )stack_start)) {
                {
#line 567
                stack_death("STACK_CHECK");
                }
              }
#line 567
              goto while_break___57;
            }
            while_break___57: /* CIL Label */ ;
            }
            {
#line 567
            while (1) {
              while_continue___58: /* CIL Label */ ;
              {
#line 567
              set_ulong_register(12U, Registers[12] | 1UL);
              }
              {
#line 567
              while (1) {
                while_continue___59: /* CIL Label */ ;
#line 567
                if ((Registers[1] & Registers[12]) != 0UL) {
#line 567
                  tmp___29 = memory_block_start;
                } else {
#line 567
                  if ((Registers[1] & 4UL) != 0UL) {
#line 567
                    tmp___28 = heap_alloc_limit;
                  } else {
#line 567
                    tmp___28 = heap_end;
                  }
#line 567
                  tmp___29 = tmp___28;
                }
                {
#line 567
                set_ptr_register(0U, tmp___29);
                }
#line 567
                if ((Registers[1] & 1UL) != 0UL) {
#line 567
                  tmp___30 = stack_guard;
                } else {
#line 567
                  tmp___30 = stack_start;
                }
                {
#line 567
                set_ptr_register(11U, tmp___30);
                }
#line 567
                goto while_break___59;
              }
              while_break___59: /* CIL Label */ ;
              }
#line 567
              goto while_break___58;
            }
            while_break___58: /* CIL Label */ ;
            }
          }
#line 567
          goto while_break___56;
        }
        while_break___56: /* CIL Label */ ;
        }
#line 568
        trapping = (_Bool)0;
#line 569
        stack_pointer --;
#line 569
        *stack_pointer = Registers[2];
#line 570
        stack_pointer --;
#line 570
        *stack_pointer = *((SCHEME_OBJECT *)(*((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 15) & 288230376151711743UL) + 2);
#line 571
        stack_pointer --;
#line 571
        *stack_pointer = 2UL;
#line 573
        goto Apply_Non_Trapping;
      }
    }
  }
  pop_return_non_trapping: 
  {
#line 581
  while (1) {
    while_continue___60: /* CIL Label */ ;
#line 581
    tmp___31 = stack_pointer;
#line 581
    stack_pointer ++;
#line 581
    Registers[6] = *tmp___31;
#line 581
    tmp___32 = stack_pointer;
#line 581
    stack_pointer ++;
#line 581
    Registers[5] = *tmp___32;
#line 581
    goto while_break___60;
  }
  while_break___60: /* CIL Label */ ;
  }
  {
#line 599
  if ((Registers[6] & 288230376151711743UL) == 18UL) {
#line 599
    goto case_18;
  }
#line 603
  if ((Registers[6] & 288230376151711743UL) == 21UL) {
#line 603
    goto case_21___0;
  }
#line 634
  if ((Registers[6] & 288230376151711743UL) == 67UL) {
#line 634
    goto case_67;
  }
#line 637
  if ((Registers[6] & 288230376151711743UL) == 83UL) {
#line 637
    goto case_83;
  }
#line 640
  if ((Registers[6] & 288230376151711743UL) == 84UL) {
#line 640
    goto case_84;
  }
#line 643
  if ((Registers[6] & 288230376151711743UL) == 86UL) {
#line 643
    goto case_86;
  }
#line 646
  if ((Registers[6] & 288230376151711743UL) == 87UL) {
#line 646
    goto case_87;
  }
#line 649
  if ((Registers[6] & 288230376151711743UL) == 88UL) {
#line 649
    goto case_88;
  }
#line 652
  if ((Registers[6] & 288230376151711743UL) == 89UL) {
#line 652
    goto case_89;
  }
#line 655
  if ((Registers[6] & 288230376151711743UL) == 91UL) {
#line 655
    goto case_91;
  }
#line 658
  if ((Registers[6] & 288230376151711743UL) == 94UL) {
#line 658
    goto case_94;
  }
#line 661
  if ((Registers[6] & 288230376151711743UL) == 29UL) {
#line 661
    goto case_29;
  }
#line 667
  if ((Registers[6] & 288230376151711743UL) == 15UL) {
#line 667
    goto case_15___0;
  }
#line 673
  if ((Registers[6] & 288230376151711743UL) == 16UL) {
#line 673
    goto case_16;
  }
#line 681
  if ((Registers[6] & 288230376151711743UL) == 0UL) {
#line 681
    goto case_0___0;
  }
#line 700
  if ((Registers[6] & 288230376151711743UL) == 65UL) {
#line 700
    goto case_65;
  }
#line 705
  if ((Registers[6] & 288230376151711743UL) == 10UL) {
#line 705
    goto case_10;
  }
#line 726
  if ((Registers[6] & 288230376151711743UL) == 8UL) {
#line 726
    goto case_8;
  }
#line 758
  if ((Registers[6] & 288230376151711743UL) == 9UL) {
#line 758
    goto case_9;
  }
#line 783
  if ((Registers[6] & 288230376151711743UL) == 70UL) {
#line 783
    goto case_70;
  }
#line 786
  if ((Registers[6] & 288230376151711743UL) == 92UL) {
#line 786
    goto case_92;
  }
#line 824
  if ((Registers[6] & 288230376151711743UL) == 93UL) {
#line 824
    goto internal_apply_val;
  }
#line 829
  if ((Registers[6] & 288230376151711743UL) == 3UL) {
#line 829
    goto internal_apply;
  }
#line 1073
  if ((Registers[6] & 288230376151711743UL) == 1UL) {
#line 1073
    goto case_1;
  }
#line 1077
  if ((Registers[6] & 288230376151711743UL) == 32UL) {
#line 1077
    goto case_32;
  }
#line 1087
  if ((Registers[6] & 288230376151711743UL) == 46UL) {
#line 1087
    goto case_46___0;
  }
#line 1087
  if ((Registers[6] & 288230376151711743UL) == 64UL) {
#line 1087
    goto case_46___0;
  }
#line 1098
  if ((Registers[6] & 288230376151711743UL) == 47UL) {
#line 1098
    goto case_47;
  }
#line 1106
  if ((Registers[6] & 288230376151711743UL) == 5UL) {
#line 1106
    goto case_5;
  }
#line 1127
  if ((Registers[6] & 288230376151711743UL) == 69UL) {
#line 1127
    goto case_69;
  }
#line 1140
  if ((Registers[6] & 288230376151711743UL) == 66UL) {
#line 1140
    goto case_66;
  }
#line 1147
  if ((Registers[6] & 288230376151711743UL) == 12UL) {
#line 1147
    goto case_12___0;
  }
#line 1152
  if ((Registers[6] & 288230376151711743UL) == 28UL) {
#line 1152
    goto case_28___0;
  }
#line 1164
  goto switch_default___3;
  case_18: /* CIL Label */ 
  {
#line 600
  end_subproblem();
  }
#line 601
  goto internal_apply_val;
  case_21___0: /* CIL Label */ 
#line 607
  tmp___33 = stack_pointer;
#line 607
  stack_pointer ++;
#line 607
  Registers[3] = *tmp___33;
#line 608
  Arg_Number = (long )((*(stack_pointer + 0) & 288230376151711743UL) - 1UL);
#line 609
  *(stack_pointer + (1L + Arg_Number)) = Registers[2];
#line 610
  *(stack_pointer + 0) = (39UL << 58U) | (unsigned long )Arg_Number;
#line 614
  if (Arg_Number > 0L) {
#line 616
    stack_pointer --;
#line 616
    *stack_pointer = Registers[3];
    {
#line 617
    while (1) {
      while_continue___61: /* CIL Label */ ;
#line 617
      Registers[6] = (11UL << 58U) | 21UL;
      {
#line 617
      while (1) {
        while_continue___62: /* CIL Label */ ;
#line 617
        stack_pointer --;
#line 617
        *stack_pointer = Registers[5];
#line 617
        stack_pointer --;
#line 617
        *stack_pointer = Registers[6];
#line 617
        goto while_break___62;
      }
      while_break___62: /* CIL Label */ ;
      }
      {
#line 617
      Registers[5] = *((SCHEME_OBJECT *)(Registers[5] & 288230376151711743UL) + (1L + Arg_Number));
#line 617
      reuse_subproblem(Registers[5], Registers[3]);
      }
#line 617
      goto do_expression;
#line 617
      goto while_break___61;
    }
    while_break___61: /* CIL Label */ ;
    }
  }
#line 621
  stack_pointer --;
#line 621
  *stack_pointer = *((SCHEME_OBJECT *)(Registers[5] & 288230376151711743UL) + 0);
  {
#line 622
  while (1) {
    while_continue___63: /* CIL Label */ ;
#line 622
    Registers[6] = (11UL << 58U) | 18UL;
    {
#line 622
    while (1) {
      while_continue___64: /* CIL Label */ ;
#line 622
      stack_pointer --;
#line 622
      *stack_pointer = Registers[5];
#line 622
      stack_pointer --;
#line 622
      *stack_pointer = Registers[6];
#line 622
      goto while_break___64;
    }
    while_break___64: /* CIL Label */ ;
    }
    {
#line 622
    Registers[5] = *((SCHEME_OBJECT *)(Registers[5] & 288230376151711743UL) + 1);
#line 622
    reuse_subproblem(Registers[5], Registers[3]);
    }
#line 622
    goto do_expression;
#line 622
    goto while_break___63;
  }
  while_break___63: /* CIL Label */ ;
  }
  case_67: /* CIL Label */ 
  {
#line 634
  dispatch_code = comp_interrupt_restart();
  }
#line 634
  goto return_from_compiled_code;
  case_83: /* CIL Label */ 
  {
#line 637
  dispatch_code = comp_lookup_trap_restart();
  }
#line 637
  goto return_from_compiled_code;
  case_84: /* CIL Label */ 
  {
#line 640
  dispatch_code = comp_assignment_trap_restart();
  }
#line 640
  goto return_from_compiled_code;
  case_86: /* CIL Label */ 
  {
#line 643
  dispatch_code = comp_op_lookup_trap_restart();
  }
#line 643
  goto return_from_compiled_code;
  case_87: /* CIL Label */ 
  {
#line 646
  dispatch_code = comp_cache_lookup_apply_restart();
  }
#line 646
  goto return_from_compiled_code;
  case_88: /* CIL Label */ 
  {
#line 649
  dispatch_code = comp_safe_lookup_trap_restart();
  }
#line 649
  goto return_from_compiled_code;
  case_89: /* CIL Label */ 
  {
#line 652
  dispatch_code = comp_unassigned_p_trap_restart();
  }
#line 652
  goto return_from_compiled_code;
  case_91: /* CIL Label */ 
  {
#line 655
  dispatch_code = comp_link_caches_restart();
  }
#line 655
  goto return_from_compiled_code;
  case_94: /* CIL Label */ 
  {
#line 658
  dispatch_code = comp_error_restart();
  }
#line 658
  goto return_from_compiled_code;
  case_29: /* CIL Label */ 
  {
#line 662
  dispatch_code = return_to_compiled_code();
  }
#line 663
  goto return_from_compiled_code;
  case_15___0: /* CIL Label */ 
  {
#line 668
  end_subproblem();
#line 669
  tmp___34 = stack_pointer;
#line 669
  stack_pointer ++;
#line 669
  Registers[3] = *tmp___34;
  }
  {
#line 670
  while (1) {
    while_continue___65: /* CIL Label */ ;
#line 670
    if (Registers[2] == 0UL) {
#line 670
      tmp___35 = 2;
    } else {
#line 670
      tmp___35 = 1;
    }
    {
#line 670
    Registers[5] = *((SCHEME_OBJECT *)(Registers[5] & 288230376151711743UL) + tmp___35);
#line 670
    new_reduction(Registers[5], Registers[3]);
    }
#line 670
    goto do_expression;
#line 670
    goto while_break___65;
  }
  while_break___65: /* CIL Label */ ;
  }
  case_16: /* CIL Label */ 
  {
#line 675
  end_subproblem();
#line 676
  tmp___36 = stack_pointer;
#line 676
  stack_pointer ++;
#line 676
  Registers[3] = *tmp___36;
  }
#line 677
  if (Registers[2] != 0UL) {
#line 678
    goto pop_return;
  }
  {
#line 679
  while (1) {
    while_continue___66: /* CIL Label */ ;
    {
#line 679
    Registers[5] = *((SCHEME_OBJECT *)(Registers[5] & 288230376151711743UL) + 1);
#line 679
    new_reduction(Registers[5], Registers[3]);
    }
#line 679
    goto do_expression;
#line 679
    goto while_break___66;
  }
  while_break___66: /* CIL Label */ ;
  }
  case_0___0: /* CIL Label */ 
#line 686
  previous_state = interpreter_state->previous_state;
#line 687
  if ((unsigned long )previous_state == (unsigned long )((interpreter_state_t )0)) {
    {
#line 689
    termination_end_of_computation();
    }
  } else {
#line 694
    dstack_position = interpreter_state->dstack_position;
#line 695
    interpreter_state = previous_state;
#line 696
    return;
  }
  case_65: /* CIL Label */ 
#line 702
  tmp___37 = stack_pointer;
#line 702
  stack_pointer ++;
#line 702
  Registers[3] = *tmp___37;
  {
#line 703
  while (1) {
    while_continue___67: /* CIL Label */ ;
    {
#line 703
    Registers[5] = Registers[5];
#line 703
    new_reduction(Registers[5], Registers[3]);
    }
#line 703
    goto do_expression;
#line 703
    goto while_break___67;
  }
  while_break___67: /* CIL Label */ ;
  }
  case_10: /* CIL Label */ 
  {
#line 710
  code = lookup_variable(Registers[2], *((SCHEME_OBJECT *)(Registers[5] & 288230376151711743UL) + 1),
                         & val___0);
  }
#line 713
  if (code == -1L) {
#line 714
    Registers[2] = val___0;
  } else
#line 715
  if (code == -4L) {
#line 717
    temp___1 = Registers[2];
#line 717
    Registers[6] = (11UL << 58U) | 10UL;
    {
#line 717
    while (1) {
      while_continue___68: /* CIL Label */ ;
#line 717
      stack_pointer --;
#line 717
      *stack_pointer = Registers[5];
#line 717
      stack_pointer --;
#line 717
      *stack_pointer = Registers[6];
#line 717
      goto while_break___68;
    }
    while_break___68: /* CIL Label */ ;
    }
#line 717
    Registers[6] = (11UL << 58U) | 46UL;
#line 717
    Registers[5] = temp___1;
    {
#line 717
    while (1) {
      while_continue___69: /* CIL Label */ ;
#line 717
      stack_pointer --;
#line 717
      *stack_pointer = Registers[5];
#line 717
      stack_pointer --;
#line 717
      *stack_pointer = Registers[6];
#line 717
      goto while_break___69;
    }
    while_break___69: /* CIL Label */ ;
    }
    {
#line 718
    setup_interrupt(Registers[1] & Registers[12]);
    }
#line 718
    goto perform_application;
  } else {
    {
#line 721
    while (1) {
      while_continue___70: /* CIL Label */ ;
      {
#line 721
      while (1) {
        while_continue___71: /* CIL Label */ ;
#line 721
        stack_pointer --;
#line 721
        *stack_pointer = Registers[5];
#line 721
        stack_pointer --;
#line 721
        *stack_pointer = Registers[6];
#line 721
        goto while_break___71;
      }
      while_break___71: /* CIL Label */ ;
      }
      {
#line 721
      Do_Micro_Error(code, (_Bool)1);
      }
#line 721
      goto internal_apply;
#line 721
      goto while_break___70;
    }
    while_break___70: /* CIL Label */ ;
    }
  }
  {
#line 723
  end_subproblem();
  }
#line 724
  goto switch_break___1;
  case_8: /* CIL Label */ 
#line 728
  variable = *((SCHEME_OBJECT *)(Registers[5] & 288230376151711743UL) + 0);
#line 732
  tmp___38 = stack_pointer;
#line 732
  stack_pointer ++;
#line 732
  Registers[3] = *tmp___38;
#line 733
  if (44UL == variable >> 58U) {
    {
#line 734
    code___0 = assign_variable(Registers[3], *((SCHEME_OBJECT *)(variable & 288230376151711743UL) + 0),
                               Registers[2], & old_val);
    }
  } else {
#line 739
    code___0 = 6L;
  }
#line 740
  if (code___0 == -1L) {
#line 741
    Registers[2] = old_val;
  } else {
#line 744
    stack_pointer --;
#line 744
    *stack_pointer = Registers[3];
#line 745
    if (code___0 == -4L) {
#line 747
      temp___2 = Registers[2];
#line 747
      Registers[6] = (11UL << 58U) | 8UL;
      {
#line 747
      while (1) {
        while_continue___72: /* CIL Label */ ;
#line 747
        stack_pointer --;
#line 747
        *stack_pointer = Registers[5];
#line 747
        stack_pointer --;
#line 747
        *stack_pointer = Registers[6];
#line 747
        goto while_break___72;
      }
      while_break___72: /* CIL Label */ ;
      }
#line 747
      Registers[6] = (11UL << 58U) | 46UL;
#line 747
      Registers[5] = temp___2;
      {
#line 747
      while (1) {
        while_continue___73: /* CIL Label */ ;
#line 747
        stack_pointer --;
#line 747
        *stack_pointer = Registers[5];
#line 747
        stack_pointer --;
#line 747
        *stack_pointer = Registers[6];
#line 747
        goto while_break___73;
      }
      while_break___73: /* CIL Label */ ;
      }
      {
#line 749
      setup_interrupt(Registers[1] & Registers[12]);
      }
#line 749
      goto perform_application;
    } else {
      {
#line 752
      while (1) {
        while_continue___74: /* CIL Label */ ;
        {
#line 752
        while (1) {
          while_continue___75: /* CIL Label */ ;
#line 752
          stack_pointer --;
#line 752
          *stack_pointer = Registers[5];
#line 752
          stack_pointer --;
#line 752
          *stack_pointer = Registers[6];
#line 752
          goto while_break___75;
        }
        while_break___75: /* CIL Label */ ;
        }
        {
#line 752
        Do_Micro_Error(code___0, (_Bool)1);
        }
#line 752
        goto internal_apply;
#line 752
        goto while_break___74;
      }
      while_break___74: /* CIL Label */ ;
      }
    }
  }
  {
#line 755
  end_subproblem();
  }
#line 756
  goto switch_break___1;
  case_9: /* CIL Label */ 
  {
#line 760
  name___0 = *((SCHEME_OBJECT *)(Registers[5] & 288230376151711743UL) + 0);
#line 761
  value = Registers[2];
#line 764
  tmp___39 = stack_pointer;
#line 764
  stack_pointer ++;
#line 764
  Registers[3] = *tmp___39;
#line 765
  result = define_variable(Registers[3], name___0, value);
  }
#line 766
  if (result == -1L) {
    {
#line 768
    end_subproblem();
#line 769
    Registers[2] = name___0;
    }
#line 770
    goto switch_break___1;
  }
#line 772
  stack_pointer --;
#line 772
  *stack_pointer = Registers[3];
#line 773
  if (result == -4L) {
#line 775
    temp___3 = value;
#line 775
    Registers[6] = (11UL << 58U) | 9UL;
    {
#line 775
    while (1) {
      while_continue___76: /* CIL Label */ ;
#line 775
      stack_pointer --;
#line 775
      *stack_pointer = Registers[5];
#line 775
      stack_pointer --;
#line 775
      *stack_pointer = Registers[6];
#line 775
      goto while_break___76;
    }
    while_break___76: /* CIL Label */ ;
    }
#line 775
    Registers[6] = (11UL << 58U) | 46UL;
#line 775
    Registers[5] = temp___3;
    {
#line 775
    while (1) {
      while_continue___77: /* CIL Label */ ;
#line 775
      stack_pointer --;
#line 775
      *stack_pointer = Registers[5];
#line 775
      stack_pointer --;
#line 775
      *stack_pointer = Registers[6];
#line 775
      goto while_break___77;
    }
    while_break___77: /* CIL Label */ ;
    }
    {
#line 777
    setup_interrupt(Registers[1] & Registers[12]);
    }
#line 777
    goto perform_application;
  }
#line 779
  Registers[2] = value;
  {
#line 780
  while (1) {
    while_continue___78: /* CIL Label */ ;
    {
#line 780
    while (1) {
      while_continue___79: /* CIL Label */ ;
#line 780
      stack_pointer --;
#line 780
      *stack_pointer = Registers[5];
#line 780
      stack_pointer --;
#line 780
      *stack_pointer = Registers[6];
#line 780
      goto while_break___79;
    }
    while_break___79: /* CIL Label */ ;
    }
    {
#line 780
    Do_Micro_Error(result, (_Bool)1);
    }
#line 780
    goto internal_apply;
#line 780
    goto while_break___78;
  }
  while_break___78: /* CIL Label */ ;
  }
  case_70: /* CIL Label */ 
  {
#line 784
  Microcode_Termination(16);
  }
  case_92: /* CIL Label */ 
#line 789
  info = *(stack_pointer + 0);
#line 790
  handler = 0UL;
  {
#line 791
  while (1) {
    while_continue___80: /* CIL Label */ ;
#line 791
    stack_pointer --;
#line 791
    *stack_pointer = Registers[5];
#line 791
    stack_pointer --;
#line 791
    *stack_pointer = Registers[6];
#line 791
    goto while_break___80;
  }
  while_break___80: /* CIL Label */ ;
  }
#line 792
  if (fixed_objects >> 58U == 10UL) {
#line 793
    handler = *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 13);
  }
#line 794
  if (handler == 0UL) {
    {
#line 796
    outf_fatal("There is no trap handler for recovery!\n");
#line 797
    termination_trap();
    }
  }
  {
#line 800
  while (1) {
    while_continue___81: /* CIL Label */ ;
#line 800
    if (! ((unsigned long )(stack_pointer + -3) >= (unsigned long )stack_guard)) {
      {
#line 800
      while (1) {
        while_continue___82: /* CIL Label */ ;
#line 800
        if (*stack_start != ((34UL << 58U) | (SCHEME_OBJECT )stack_start)) {
          {
#line 800
          stack_death("STACK_CHECK");
          }
        }
#line 800
        goto while_break___82;
      }
      while_break___82: /* CIL Label */ ;
      }
      {
#line 800
      while (1) {
        while_continue___83: /* CIL Label */ ;
        {
#line 800
        set_ulong_register(12U, Registers[12] | 1UL);
        }
        {
#line 800
        while (1) {
          while_continue___84: /* CIL Label */ ;
#line 800
          if ((Registers[1] & Registers[12]) != 0UL) {
#line 800
            tmp___41 = memory_block_start;
          } else {
#line 800
            if ((Registers[1] & 4UL) != 0UL) {
#line 800
              tmp___40 = heap_alloc_limit;
            } else {
#line 800
              tmp___40 = heap_end;
            }
#line 800
            tmp___41 = tmp___40;
          }
          {
#line 800
          set_ptr_register(0U, tmp___41);
          }
#line 800
          if ((Registers[1] & 1UL) != 0UL) {
#line 800
            tmp___42 = stack_guard;
          } else {
#line 800
            tmp___42 = stack_start;
          }
          {
#line 800
          set_ptr_register(11U, tmp___42);
          }
#line 800
          goto while_break___84;
        }
        while_break___84: /* CIL Label */ ;
        }
#line 800
        goto while_break___83;
      }
      while_break___83: /* CIL Label */ ;
      }
    }
#line 800
    goto while_break___81;
  }
  while_break___81: /* CIL Label */ ;
  }
#line 801
  stack_pointer --;
#line 801
  *stack_pointer = info;
#line 802
  stack_pointer --;
#line 802
  *stack_pointer = handler;
#line 803
  stack_pointer --;
#line 803
  *stack_pointer = 2UL;
#line 806
  goto internal_apply;
  internal_apply_val: 
  case_93: /* CIL Label */ 
#line 827
  *(stack_pointer + 1) = Registers[2];
  internal_apply: 
  case_3___0: /* CIL Label */ 
#line 833
  if (trapping) {
#line 833
    if (! ((unsigned long )critical_section_name != (unsigned long )((char const   *)0))) {
#line 833
      if (*((SCHEME_OBJECT *)(*((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 15) & 288230376151711743UL) + 1) != 0UL) {
#line 837
        frame_size = *(stack_pointer + 0) & 288230376151711743UL;
#line 838
        *(stack_pointer + 0) = *((SCHEME_OBJECT *)(*((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 15) & 288230376151711743UL) + 1);
#line 839
        stack_pointer --;
#line 839
        *stack_pointer = frame_size + 1UL;
#line 840
        trapping = (_Bool)0;
      }
    }
  }
  Apply_Non_Trapping: 
#line 845
  if ((Registers[1] & Registers[12]) != 0UL) {
#line 847
    interrupts = Registers[1] & Registers[12];
#line 848
    Registers[5] = 0UL;
#line 848
    temp___4 = *(stack_pointer + 1);
#line 848
    Registers[6] = (11UL << 58U) | 93UL;
    {
#line 848
    while (1) {
      while_continue___85: /* CIL Label */ ;
#line 848
      stack_pointer --;
#line 848
      *stack_pointer = Registers[5];
#line 848
      stack_pointer --;
#line 848
      *stack_pointer = Registers[6];
#line 848
      goto while_break___85;
    }
    while_break___85: /* CIL Label */ ;
    }
#line 848
    Registers[6] = (11UL << 58U) | 46UL;
#line 848
    Registers[5] = temp___4;
    {
#line 848
    while (1) {
      while_continue___86: /* CIL Label */ ;
#line 848
      stack_pointer --;
#line 848
      *stack_pointer = Registers[5];
#line 848
      stack_pointer --;
#line 848
      *stack_pointer = Registers[6];
#line 848
      goto while_break___86;
    }
    while_break___86: /* CIL Label */ ;
    }
    {
#line 849
    setup_interrupt(interrupts);
    }
#line 849
    goto perform_application;
  }
  perform_application: 
#line 857
  Function = *(stack_pointer + 1);
  apply_dispatch: 
  {
#line 862
  if (Function >> 58U == 16UL) {
#line 862
    goto case_16___0;
  }
#line 887
  if (Function >> 58U == 15UL) {
#line 887
    goto case_15___1;
  }
#line 918
  if (Function >> 58U == 28UL) {
#line 918
    goto case_28;
  }
#line 929
  if (Function >> 58U == 24UL) {
#line 929
    goto case_24;
  }
#line 951
  if (Function >> 58U == 9UL) {
#line 951
    goto case_9___0;
  }
#line 1036
  if (Function >> 58U == 40UL) {
#line 1036
    goto case_40___0;
  }
#line 1068
  goto switch_default___2;
  case_16___0: /* CIL Label */ 
#line 864
  frame_size___0 = *(stack_pointer + 0) & 288230376151711743UL;
#line 865
  data = *((SCHEME_OBJECT *)(Function & 288230376151711743UL) + 1);
#line 866
  if (data >> 58U == 10UL) {
#line 866
    if (frame_size___0 < (*((SCHEME_OBJECT *)(data & 288230376151711743UL) + 0) & 288230376151711743UL)) {
#line 866
      if (*((SCHEME_OBJECT *)(data & 288230376151711743UL) + (frame_size___0 + 1UL)) != 0UL) {
#line 866
        if (*((SCHEME_OBJECT *)(data & 288230376151711743UL) + 1) == *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 52)) {
#line 872
          Function = *((SCHEME_OBJECT *)(data & 288230376151711743UL) + (frame_size___0 + 1UL));
#line 873
          *(stack_pointer + 1) = Function;
#line 874
          goto apply_dispatch;
        }
      }
    }
  }
#line 877
  *(stack_pointer + 0) = *((SCHEME_OBJECT *)(Function & 288230376151711743UL) + 0);
#line 878
  stack_pointer --;
#line 878
  *stack_pointer = frame_size___0 + 1UL;
  {
#line 883
  while (1) {
    while_continue___87: /* CIL Label */ ;
#line 883
    if (! ((unsigned long )(stack_pointer + 0) >= (unsigned long )stack_guard)) {
      {
#line 883
      while (1) {
        while_continue___88: /* CIL Label */ ;
#line 883
        if (*stack_start != ((34UL << 58U) | (SCHEME_OBJECT )stack_start)) {
          {
#line 883
          stack_death("STACK_CHECK");
          }
        }
#line 883
        goto while_break___88;
      }
      while_break___88: /* CIL Label */ ;
      }
      {
#line 883
      while (1) {
        while_continue___89: /* CIL Label */ ;
        {
#line 883
        set_ulong_register(12U, Registers[12] | 1UL);
        }
        {
#line 883
        while (1) {
          while_continue___90: /* CIL Label */ ;
#line 883
          if ((Registers[1] & Registers[12]) != 0UL) {
#line 883
            tmp___44 = memory_block_start;
          } else {
#line 883
            if ((Registers[1] & 4UL) != 0UL) {
#line 883
              tmp___43 = heap_alloc_limit;
            } else {
#line 883
              tmp___43 = heap_end;
            }
#line 883
            tmp___44 = tmp___43;
          }
          {
#line 883
          set_ptr_register(0U, tmp___44);
          }
#line 883
          if ((Registers[1] & 1UL) != 0UL) {
#line 883
            tmp___45 = stack_guard;
          } else {
#line 883
            tmp___45 = stack_start;
          }
          {
#line 883
          set_ptr_register(11U, tmp___45);
          }
#line 883
          goto while_break___90;
        }
        while_break___90: /* CIL Label */ ;
        }
#line 883
        goto while_break___89;
      }
      while_break___89: /* CIL Label */ ;
      }
    }
#line 883
    goto while_break___87;
  }
  while_break___87: /* CIL Label */ ;
  }
#line 884
  goto internal_apply;
  case_15___1: /* CIL Label */ 
#line 889
  frame_size___1 = *(stack_pointer + 0) & 288230376151711743UL;
#line 890
  Function = *((SCHEME_OBJECT *)(Function & 288230376151711743UL) + 0);
#line 892
  formals = *((SCHEME_OBJECT *)(Function & 288230376151711743UL) + 1);
#line 895
  if (frame_size___1 != (*((SCHEME_OBJECT *)(formals & 288230376151711743UL) + 0) & 288230376151711743UL)) {
#line 895
    if (Function >> 58U != 41UL) {
#line 895
      goto _L;
    } else
#line 895
    if (frame_size___1 < (*((SCHEME_OBJECT *)(formals & 288230376151711743UL) + 0) & 288230376151711743UL)) {
      _L: /* CIL Label */ 
      {
#line 898
      while (1) {
        while_continue___91: /* CIL Label */ ;
#line 898
        Registers[5] = 0UL;
#line 898
        Registers[6] = (11UL << 58U) | 93UL;
        {
#line 898
        while (1) {
          while_continue___92: /* CIL Label */ ;
#line 898
          stack_pointer --;
#line 898
          *stack_pointer = Registers[5];
#line 898
          stack_pointer --;
#line 898
          *stack_pointer = Registers[6];
#line 898
          goto while_break___92;
        }
        while_break___92: /* CIL Label */ ;
        }
        {
#line 898
        Registers[2] = *(stack_pointer + 1);
#line 898
        Do_Micro_Error(12L, (_Bool)1);
        }
#line 898
        goto internal_apply;
#line 898
        goto while_break___91;
      }
      while_break___91: /* CIL Label */ ;
      }
    }
  }
#line 900
  if ((unsigned long )Free >= (unsigned long )heap_start) {
#line 900
    if ((unsigned long )Free < (unsigned long )heap_alloc_limit) {
#line 900
      if (! ((unsigned long )(Free + (frame_size___1 + 1UL)) <= (unsigned long )heap_alloc_limit)) {
#line 900
        goto _L___1;
      }
    } else {
#line 900
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 900
  if ((Registers[1] & 4UL) != 0UL) {
#line 902
    Registers[5] = 0UL;
#line 902
    temp___5 = *(stack_pointer + 1);
#line 902
    Registers[6] = (11UL << 58U) | 93UL;
    {
#line 902
    while (1) {
      while_continue___93: /* CIL Label */ ;
#line 902
      stack_pointer --;
#line 902
      *stack_pointer = Registers[5];
#line 902
      stack_pointer --;
#line 902
      *stack_pointer = Registers[6];
#line 902
      goto while_break___93;
    }
    while_break___93: /* CIL Label */ ;
    }
#line 902
    Registers[6] = (11UL << 58U) | 46UL;
#line 902
    Registers[5] = temp___5;
    {
#line 902
    while (1) {
      while_continue___94: /* CIL Label */ ;
#line 902
      stack_pointer --;
#line 902
      *stack_pointer = Registers[5];
#line 902
      stack_pointer --;
#line 902
      *stack_pointer = Registers[6];
#line 902
      goto while_break___94;
    }
    while_break___94: /* CIL Label */ ;
    }
    {
#line 903
    while (1) {
      while_continue___95: /* CIL Label */ ;
      {
#line 903
      while (1) {
        while_continue___96: /* CIL Label */ ;
        {
#line 903
        set_ulong_register(12U, Registers[12] | 4UL);
        }
        {
#line 903
        while (1) {
          while_continue___97: /* CIL Label */ ;
#line 903
          if ((Registers[1] & Registers[12]) != 0UL) {
#line 903
            tmp___47 = memory_block_start;
          } else {
#line 903
            if ((Registers[1] & 4UL) != 0UL) {
#line 903
              tmp___46 = heap_alloc_limit;
            } else {
#line 903
              tmp___46 = heap_end;
            }
#line 903
            tmp___47 = tmp___46;
          }
          {
#line 903
          set_ptr_register(0U, tmp___47);
          }
#line 903
          if ((Registers[1] & 1UL) != 0UL) {
#line 903
            tmp___48 = stack_guard;
          } else {
#line 903
            tmp___48 = stack_start;
          }
          {
#line 903
          set_ptr_register(11U, tmp___48);
          }
#line 903
          goto while_break___97;
        }
        while_break___97: /* CIL Label */ ;
        }
#line 903
        goto while_break___96;
      }
      while_break___96: /* CIL Label */ ;
      }
#line 903
      gc_space_needed = frame_size___1 + 1UL;
#line 903
      goto while_break___95;
    }
    while_break___95: /* CIL Label */ ;
    }
    {
#line 903
    setup_interrupt(Registers[1] & Registers[12]);
    }
#line 903
    goto perform_application;
  }
#line 906
  end = (Free + 1) + frame_size___1;
#line 907
  env = (18UL << 58U) | (SCHEME_OBJECT )Free;
#line 909
  tmp___49 = Free;
#line 909
  Free ++;
#line 909
  *tmp___49 = frame_size___1;
#line 910
  tmp___50 = stack_pointer;
#line 910
  stack_pointer ++;
  {
#line 911
  while (1) {
    while_continue___98: /* CIL Label */ ;
#line 911
    if (! ((unsigned long )Free < (unsigned long )end)) {
#line 911
      goto while_break___98;
    }
#line 912
    tmp___51 = Free;
#line 912
    Free ++;
#line 912
    tmp___52 = stack_pointer;
#line 912
    stack_pointer ++;
#line 912
    *tmp___51 = *tmp___52;
  }
  while_break___98: /* CIL Label */ ;
  }
#line 913
  Registers[3] = env;
  {
#line 914
  while (1) {
    while_continue___99: /* CIL Label */ ;
    {
#line 914
    Registers[5] = *((SCHEME_OBJECT *)(Function & 288230376151711743UL) + 0);
#line 914
    new_reduction(Registers[5], Registers[3]);
    }
#line 914
    goto do_expression;
#line 914
    goto while_break___99;
  }
  while_break___99: /* CIL Label */ ;
  }
  case_28: /* CIL Label */ 
#line 919
  if ((*(stack_pointer + 0) & 288230376151711743UL) != 2UL) {
    {
#line 920
    while (1) {
      while_continue___100: /* CIL Label */ ;
#line 920
      Registers[5] = 0UL;
#line 920
      Registers[6] = (11UL << 58U) | 93UL;
      {
#line 920
      while (1) {
        while_continue___101: /* CIL Label */ ;
#line 920
        stack_pointer --;
#line 920
        *stack_pointer = Registers[5];
#line 920
        stack_pointer --;
#line 920
        *stack_pointer = Registers[6];
#line 920
        goto while_break___101;
      }
      while_break___101: /* CIL Label */ ;
      }
      {
#line 920
      Registers[2] = *(stack_pointer + 1);
#line 920
      Do_Micro_Error(12L, (_Bool)1);
      }
#line 920
      goto internal_apply;
#line 920
      goto while_break___100;
    }
    while_break___100: /* CIL Label */ ;
    }
  }
  {
#line 921
  Registers[2] = *(stack_pointer + 2);
#line 922
  unpack_control_point(Function);
#line 923
  reset_history();
  }
#line 924
  goto pop_return;
  case_24: /* CIL Label */ 
#line 930
  if (! ((unsigned long )*(Primitive_Procedure_Table + (Function & 288230376151711743UL)) != (unsigned long )(& Prim_unimplemented))) {
    {
#line 931
    while (1) {
      while_continue___102: /* CIL Label */ ;
#line 931
      Registers[5] = 0UL;
#line 931
      Registers[6] = (11UL << 58U) | 93UL;
      {
#line 931
      while (1) {
        while_continue___103: /* CIL Label */ ;
#line 931
        stack_pointer --;
#line 931
        *stack_pointer = Registers[5];
#line 931
        stack_pointer --;
#line 931
        *stack_pointer = Registers[6];
#line 931
        goto while_break___103;
      }
      while_break___103: /* CIL Label */ ;
      }
      {
#line 931
      Registers[2] = *(stack_pointer + 1);
#line 931
      Do_Micro_Error(51L, (_Bool)1);
      }
#line 931
      goto internal_apply;
#line 931
      goto while_break___102;
    }
    while_break___102: /* CIL Label */ ;
    }
  }
#line 933
  n_args = (*(stack_pointer + 0) & 288230376151711743UL) - 1UL;
#line 938
  if (n_args != (unsigned long )*(Primitive_Arity_Table + (Function & 288230376151711743UL))) {
#line 940
    if (*(Primitive_Arity_Table + (Function & 288230376151711743UL)) != -1) {
      {
#line 941
      while (1) {
        while_continue___104: /* CIL Label */ ;
#line 941
        Registers[5] = 0UL;
#line 941
        Registers[6] = (11UL << 58U) | 93UL;
        {
#line 941
        while (1) {
          while_continue___105: /* CIL Label */ ;
#line 941
          stack_pointer --;
#line 941
          *stack_pointer = Registers[5];
#line 941
          stack_pointer --;
#line 941
          *stack_pointer = Registers[6];
#line 941
          goto while_break___105;
        }
        while_break___105: /* CIL Label */ ;
        }
        {
#line 941
        Registers[2] = *(stack_pointer + 1);
#line 941
        Do_Micro_Error(12L, (_Bool)1);
        }
#line 941
        goto internal_apply;
#line 941
        goto while_break___104;
      }
      while_break___104: /* CIL Label */ ;
      }
    }
    {
#line 942
    set_ulong_register(7U, n_args);
    }
  }
#line 944
  stack_pointer += 2;
#line 945
  Registers[5] = Function;
  {
#line 946
  while (1) {
    while_continue___106: /* CIL Label */ ;
#line 946
    APFI_saved_history = history_register;
    {
#line 946
    while (1) {
      while_continue___107: /* CIL Label */ ;
      {
#line 946
      PRIMITIVE_APPLY_INTERNAL_position = dstack_position;
#line 946
      Registers[8] = Function;
#line 946
      Free_primitive = Free;
#line 946
      Registers[2] = (*(*(Primitive_Procedure_Table + (Function & 288230376151711743UL))))();
      }
#line 946
      if ((unsigned long )PRIMITIVE_APPLY_INTERNAL_position != (unsigned long )dstack_position) {
        {
#line 946
        outf_fatal("\nPrimitive slipped the dynamic stack: %s\n", *(Primitive_Name_Table + (Function & 288230376151711743UL)));
#line 946
        Microcode_Termination(12);
        }
      }
#line 946
      Free_primitive = (SCHEME_OBJECT *)0;
#line 946
      Registers[8] = 0UL;
#line 946
      goto while_break___107;
    }
    while_break___107: /* CIL Label */ ;
    }
#line 946
    history_register = APFI_saved_history;
#line 946
    goto while_break___106;
  }
  while_break___106: /* CIL Label */ ;
  }
#line 947
  stack_pointer += n_args;
#line 948
  goto pop_return;
  case_9___0: /* CIL Label */ 
#line 965
  tmp___53 = stack_pointer;
#line 965
  stack_pointer ++;
#line 965
  nargs = (*tmp___53 & 288230376151711743UL) - 1UL;
#line 966
  lambda = *((SCHEME_OBJECT *)(Function & 288230376151711743UL) + 0);
#line 967
  Function = *((SCHEME_OBJECT *)(lambda & 288230376151711743UL) + 1);
#line 968
  nparams = (*((SCHEME_OBJECT *)(Function & 288230376151711743UL) + 0) & 288230376151711743UL) - 1UL;
#line 969
  Function = *((SCHEME_OBJECT *)(lambda & 288230376151711743UL) + 2);
#line 970
  formals___0 = (unsigned long )(((long )Function & 65280L) >> 8);
#line 971
  params = (unsigned long )((long )Function & 255L) + formals___0;
#line 972
  rest_flag = ((long )Function & 65536L) >> 16;
#line 973
  auxes = nparams - (params + (unsigned long )rest_flag);
#line 975
  if (nargs < formals___0) {
#line 975
    goto _L___2;
  } else
#line 975
  if (! rest_flag) {
#line 975
    if (nargs > params) {
      _L___2: /* CIL Label */ 
#line 977
      stack_pointer --;
#line 977
      *stack_pointer = nargs + 1UL;
      {
#line 978
      while (1) {
        while_continue___108: /* CIL Label */ ;
#line 978
        Registers[5] = 0UL;
#line 978
        Registers[6] = (11UL << 58U) | 93UL;
        {
#line 978
        while (1) {
          while_continue___109: /* CIL Label */ ;
#line 978
          stack_pointer --;
#line 978
          *stack_pointer = Registers[5];
#line 978
          stack_pointer --;
#line 978
          *stack_pointer = Registers[6];
#line 978
          goto while_break___109;
        }
        while_break___109: /* CIL Label */ ;
        }
        {
#line 978
        Registers[2] = *(stack_pointer + 1);
#line 978
        Do_Micro_Error(12L, (_Bool)1);
        }
#line 978
        goto internal_apply;
#line 978
        goto while_break___108;
      }
      while_break___108: /* CIL Label */ ;
      }
    }
  }
#line 981
  size = (long )(((params + (unsigned long )rest_flag) + auxes) + 1UL);
#line 982
  if ((unsigned long )Free >= (unsigned long )heap_start) {
#line 982
    if ((unsigned long )Free < (unsigned long )heap_alloc_limit) {
#line 982
      if (nargs > params) {
#line 982
        tmp___58 = 2UL * (nargs - params);
      } else {
#line 982
        tmp___58 = 0UL;
      }
#line 982
      if (! ((unsigned long )(Free + ((unsigned long )(size + 1L) + tmp___58)) <= (unsigned long )heap_alloc_limit)) {
#line 982
        goto _L___4;
      }
    } else {
#line 982
      goto _L___4;
    }
  } else
  _L___4: /* CIL Label */ 
#line 982
  if ((Registers[1] & 4UL) != 0UL) {
#line 988
    stack_pointer --;
#line 988
    *stack_pointer = nargs + 1UL;
#line 989
    Registers[5] = 0UL;
#line 989
    temp___7 = *(stack_pointer + 1);
#line 989
    Registers[6] = (11UL << 58U) | 93UL;
    {
#line 989
    while (1) {
      while_continue___110: /* CIL Label */ ;
#line 989
      stack_pointer --;
#line 989
      *stack_pointer = Registers[5];
#line 989
      stack_pointer --;
#line 989
      *stack_pointer = Registers[6];
#line 989
      goto while_break___110;
    }
    while_break___110: /* CIL Label */ ;
    }
#line 989
    Registers[6] = (11UL << 58U) | 46UL;
#line 989
    Registers[5] = temp___7;
    {
#line 989
    while (1) {
      while_continue___111: /* CIL Label */ ;
#line 989
      stack_pointer --;
#line 989
      *stack_pointer = Registers[5];
#line 989
      stack_pointer --;
#line 989
      *stack_pointer = Registers[6];
#line 989
      goto while_break___111;
    }
    while_break___111: /* CIL Label */ ;
    }
    {
#line 990
    while (1) {
      while_continue___112: /* CIL Label */ ;
      {
#line 990
      while (1) {
        while_continue___113: /* CIL Label */ ;
        {
#line 990
        set_ulong_register(12U, Registers[12] | 4UL);
        }
        {
#line 990
        while (1) {
          while_continue___114: /* CIL Label */ ;
#line 990
          if ((Registers[1] & Registers[12]) != 0UL) {
#line 990
            tmp___55 = memory_block_start;
          } else {
#line 990
            if ((Registers[1] & 4UL) != 0UL) {
#line 990
              tmp___54 = heap_alloc_limit;
            } else {
#line 990
              tmp___54 = heap_end;
            }
#line 990
            tmp___55 = tmp___54;
          }
          {
#line 990
          set_ptr_register(0U, tmp___55);
          }
#line 990
          if ((Registers[1] & 1UL) != 0UL) {
#line 990
            tmp___56 = stack_guard;
          } else {
#line 990
            tmp___56 = stack_start;
          }
          {
#line 990
          set_ptr_register(11U, tmp___56);
          }
#line 990
          goto while_break___114;
        }
        while_break___114: /* CIL Label */ ;
        }
#line 990
        goto while_break___113;
      }
      while_break___113: /* CIL Label */ ;
      }
#line 990
      if (nargs > params) {
#line 990
        tmp___57 = 2UL * (nargs - params);
      } else {
#line 990
        tmp___57 = 0UL;
      }
#line 990
      gc_space_needed = (unsigned long )(size + 1L) + tmp___57;
#line 990
      goto while_break___112;
    }
    while_break___112: /* CIL Label */ ;
    }
    {
#line 990
    setup_interrupt(Registers[1] & Registers[12]);
    }
#line 990
    goto perform_application;
  }
#line 996
  scan = Free;
#line 997
  temp___6 = (18UL << 58U) | (SCHEME_OBJECT )scan;
#line 998
  tmp___59 = scan;
#line 998
  scan ++;
#line 998
  *tmp___59 = (unsigned long )size;
#line 999
  if (nargs <= params) {
#line 1001
    i = (long )(nargs + 1UL);
    {
#line 1001
    while (1) {
      while_continue___115: /* CIL Label */ ;
#line 1001
      i --;
#line 1001
      if (! (i >= 0L)) {
#line 1001
        goto while_break___115;
      }
#line 1002
      tmp___60 = scan;
#line 1002
      scan ++;
#line 1002
      tmp___61 = stack_pointer;
#line 1002
      stack_pointer ++;
#line 1002
      *tmp___60 = *tmp___61;
    }
    while_break___115: /* CIL Label */ ;
    }
#line 1003
    i = (long )(params - nargs);
    {
#line 1003
    while (1) {
      while_continue___116: /* CIL Label */ ;
#line 1003
      i --;
#line 1003
      if (! (i >= 0L)) {
#line 1003
        goto while_break___116;
      }
#line 1004
      tmp___62 = scan;
#line 1004
      scan ++;
#line 1004
      *tmp___62 = (8UL << 58U) | 7UL;
    }
    while_break___116: /* CIL Label */ ;
    }
#line 1005
    if (rest_flag) {
#line 1006
      tmp___63 = scan;
#line 1006
      scan ++;
#line 1006
      *tmp___63 = (8UL << 58U) | 9UL;
    }
#line 1007
    i = (long )auxes;
    {
#line 1007
    while (1) {
      while_continue___117: /* CIL Label */ ;
#line 1007
      i --;
#line 1007
      if (! (i >= 0L)) {
#line 1007
        goto while_break___117;
      }
#line 1008
      tmp___64 = scan;
#line 1008
      scan ++;
#line 1008
      *tmp___64 = 50UL << 58U;
    }
    while_break___117: /* CIL Label */ ;
    }
  } else {
#line 1013
    list = (1UL << 58U) | (SCHEME_OBJECT )(scan + size);
#line 1015
    i = (long )(params + 1UL);
    {
#line 1015
    while (1) {
      while_continue___118: /* CIL Label */ ;
#line 1015
      i --;
#line 1015
      if (! (i >= 0L)) {
#line 1015
        goto while_break___118;
      }
#line 1016
      tmp___65 = scan;
#line 1016
      scan ++;
#line 1016
      tmp___66 = stack_pointer;
#line 1016
      stack_pointer ++;
#line 1016
      *tmp___65 = *tmp___66;
    }
    while_break___118: /* CIL Label */ ;
    }
#line 1017
    tmp___67 = scan;
#line 1017
    scan ++;
#line 1017
    *tmp___67 = list;
#line 1018
    i = (long )auxes;
    {
#line 1018
    while (1) {
      while_continue___119: /* CIL Label */ ;
#line 1018
      i --;
#line 1018
      if (! (i >= 0L)) {
#line 1018
        goto while_break___119;
      }
#line 1019
      tmp___68 = scan;
#line 1019
      scan ++;
#line 1019
      *tmp___68 = 50UL << 58U;
    }
    while_break___119: /* CIL Label */ ;
    }
#line 1021
    i = (long )(nargs - params);
    {
#line 1021
    while (1) {
      while_continue___120: /* CIL Label */ ;
#line 1021
      i --;
#line 1021
      if (! (i >= 0L)) {
#line 1021
        goto while_break___120;
      }
#line 1023
      tmp___69 = scan;
#line 1023
      scan ++;
#line 1023
      tmp___70 = stack_pointer;
#line 1023
      stack_pointer ++;
#line 1023
      *tmp___69 = *tmp___70;
#line 1024
      *scan = (1UL << 58U) | (SCHEME_OBJECT )(scan + 1);
#line 1025
      scan ++;
    }
    while_break___120: /* CIL Label */ ;
    }
#line 1027
    *(scan + -1) = (8UL << 58U) | 9UL;
  }
#line 1030
  Free = scan;
#line 1031
  Registers[3] = temp___6;
  {
#line 1032
  while (1) {
    while_continue___121: /* CIL Label */ ;
    {
#line 1032
    Registers[5] = *((SCHEME_OBJECT *)(lambda & 288230376151711743UL) + 0);
#line 1032
    new_reduction(Registers[5], Registers[3]);
    }
#line 1032
    goto do_expression;
#line 1032
    goto while_break___121;
  }
  while_break___121: /* CIL Label */ ;
  }
  case_40___0: /* CIL Label */ 
  {
#line 1038
  guarantee_cc_return(1UL + (*(stack_pointer + 0) & 288230376151711743UL));
#line 1039
  dispatch_code = apply_compiled_procedure();
  }
  return_from_compiled_code: 
  {
#line 1044
  if (dispatch_code == -1L) {
#line 1044
    goto case_neg_1;
  }
#line 1047
  if (dispatch_code == -3L) {
#line 1047
    goto case_neg_3___0;
  }
#line 1050
  if (dispatch_code == -4L) {
#line 1050
    goto case_neg_4___0;
  }
#line 1053
  if (dispatch_code == -9L) {
#line 1053
    goto case_neg_9___0;
  }
#line 1058
  if (dispatch_code == 12L) {
#line 1058
    goto case_12;
  }
#line 1058
  if (dispatch_code == 3L) {
#line 1058
    goto case_12;
  }
#line 1061
  goto switch_default___1;
  case_neg_1: /* CIL Label */ 
#line 1045
  goto pop_return;
  case_neg_3___0: /* CIL Label */ 
#line 1048
  goto internal_apply;
  case_neg_4___0: /* CIL Label */ 
  {
#line 1051
  setup_interrupt(Registers[1] & Registers[12]);
  }
#line 1051
  goto perform_application;
  case_neg_9___0: /* CIL Label */ 
#line 1054
  Registers[5] = 0UL;
#line 1054
  temp___8 = *(stack_pointer + 1);
#line 1054
  Registers[6] = (11UL << 58U) | 93UL;
  {
#line 1054
  while (1) {
    while_continue___122: /* CIL Label */ ;
#line 1054
    stack_pointer --;
#line 1054
    *stack_pointer = Registers[5];
#line 1054
    stack_pointer --;
#line 1054
    *stack_pointer = Registers[6];
#line 1054
    goto while_break___122;
  }
  while_break___122: /* CIL Label */ ;
  }
#line 1054
  Registers[6] = (11UL << 58U) | 46UL;
#line 1054
  Registers[5] = temp___8;
  {
#line 1054
  while (1) {
    while_continue___123: /* CIL Label */ ;
#line 1054
    stack_pointer --;
#line 1054
    *stack_pointer = Registers[5];
#line 1054
    stack_pointer --;
#line 1054
    *stack_pointer = Registers[6];
#line 1054
    goto while_break___123;
  }
  while_break___123: /* CIL Label */ ;
  }
  {
#line 1055
  setup_interrupt(Registers[1] & Registers[12]);
  }
#line 1055
  goto perform_application;
  case_12: /* CIL Label */ 
  case_3___1: /* CIL Label */ 
  {
#line 1059
  while (1) {
    while_continue___124: /* CIL Label */ ;
#line 1059
    Registers[5] = 0UL;
#line 1059
    Registers[6] = (11UL << 58U) | 93UL;
    {
#line 1059
    while (1) {
      while_continue___125: /* CIL Label */ ;
#line 1059
      stack_pointer --;
#line 1059
      *stack_pointer = Registers[5];
#line 1059
      stack_pointer --;
#line 1059
      *stack_pointer = Registers[6];
#line 1059
      goto while_break___125;
    }
    while_break___125: /* CIL Label */ ;
    }
    {
#line 1059
    Registers[2] = *(stack_pointer + 1);
#line 1059
    Do_Micro_Error(dispatch_code, (_Bool)1);
    }
#line 1059
    goto internal_apply;
#line 1059
    goto while_break___124;
  }
  while_break___124: /* CIL Label */ ;
  }
  switch_default___1: /* CIL Label */ 
  {
#line 1062
  Do_Micro_Error(dispatch_code, (_Bool)1);
  }
#line 1063
  goto internal_apply;
  switch_break___3: /* CIL Label */ ;
  }
  switch_default___2: /* CIL Label */ 
  {
#line 1069
  while (1) {
    while_continue___126: /* CIL Label */ ;
#line 1069
    Registers[5] = 0UL;
#line 1069
    Registers[6] = (11UL << 58U) | 93UL;
    {
#line 1069
    while (1) {
      while_continue___127: /* CIL Label */ ;
#line 1069
      stack_pointer --;
#line 1069
      *stack_pointer = Registers[5];
#line 1069
      stack_pointer --;
#line 1069
      *stack_pointer = Registers[6];
#line 1069
      goto while_break___127;
    }
    while_break___127: /* CIL Label */ ;
    }
    {
#line 1069
    Registers[2] = *(stack_pointer + 1);
#line 1069
    Do_Micro_Error(3L, (_Bool)1);
    }
#line 1069
    goto internal_apply;
#line 1069
    goto while_break___126;
  }
  while_break___126: /* CIL Label */ ;
  }
  switch_break___2: /* CIL Label */ ;
  }
  case_1: /* CIL Label */ 
  {
#line 1074
  unpack_control_point(Registers[5]);
  }
#line 1075
  goto switch_break___1;
  case_32: /* CIL Label */ 
#line 1078
  Registers[2] = Registers[5];
#line 1080
  if ((unsigned long )Free >= (unsigned long )heap_start) {
#line 1080
    if ((unsigned long )Free < (unsigned long )heap_alloc_limit) {
#line 1080
      if (! ((unsigned long )(Free + gc_space_needed) <= (unsigned long )heap_alloc_limit)) {
#line 1080
        goto _L___6;
      }
    } else {
#line 1080
      goto _L___6;
    }
  } else
  _L___6: /* CIL Label */ 
#line 1080
  if ((Registers[1] & 4UL) != 0UL) {
    {
#line 1081
    termination_gc_out_of_space();
    }
  }
#line 1082
  gc_space_needed = 0UL;
  {
#line 1083
  while (1) {
    while_continue___128: /* CIL Label */ ;
#line 1083
    if (critical_section_hook_p) {
      {
#line 1083
      while (1) {
        while_continue___129: /* CIL Label */ ;
#line 1083
        stack_pointer --;
#line 1083
        *stack_pointer = Registers[5];
#line 1083
        stack_pointer --;
#line 1083
        *stack_pointer = Registers[6];
#line 1083
        goto while_break___129;
      }
      while_break___129: /* CIL Label */ ;
      }
      {
#line 1083
      name___1 = critical_section_name;
#line 1083
      critical_section_hook_p = (_Bool)0;
#line 1083
      critical_section_name = (char const   *)0;
#line 1083
      (*critical_section_hook)(name___1);
      }
    } else {
#line 1083
      critical_section_name = (char const   *)0;
    }
#line 1083
    goto while_break___128;
  }
  while_break___128: /* CIL Label */ ;
  }
#line 1084
  goto switch_break___1;
  case_46___0: /* CIL Label */ 
  case_64: /* CIL Label */ 
#line 1088
  Registers[2] = Registers[5];
#line 1089
  goto switch_break___1;
  case_47: /* CIL Label */ 
#line 1100
  tmp___71 = stack_pointer;
#line 1100
  stack_pointer ++;
#line 1100
  prev_restore_history_offset = *tmp___71 & 288230376151711743UL;
#line 1101
  tmp___72 = stack_pointer;
#line 1101
  stack_pointer ++;
#line 1102
  history_register = (SCHEME_OBJECT *)(Registers[5] & 288230376151711743UL);
#line 1103
  goto switch_break___1;
  case_5: /* CIL Label */ 
  {
#line 1108
  tmp___80 = restore_history(Registers[5]);
  }
#line 1108
  if (! tmp___80) {
    {
#line 1110
    while (1) {
      while_continue___130: /* CIL Label */ ;
#line 1110
      stack_pointer --;
#line 1110
      *stack_pointer = Registers[5];
#line 1110
      stack_pointer --;
#line 1110
      *stack_pointer = Registers[6];
#line 1110
      goto while_break___130;
    }
    while_break___130: /* CIL Label */ ;
    }
    {
#line 1111
    while (1) {
      while_continue___131: /* CIL Label */ ;
#line 1111
      if (! ((unsigned long )(stack_pointer + -2) >= (unsigned long )stack_guard)) {
        {
#line 1111
        while (1) {
          while_continue___132: /* CIL Label */ ;
#line 1111
          if (*stack_start != ((34UL << 58U) | (SCHEME_OBJECT )stack_start)) {
            {
#line 1111
            stack_death("STACK_CHECK");
            }
          }
#line 1111
          goto while_break___132;
        }
        while_break___132: /* CIL Label */ ;
        }
        {
#line 1111
        while (1) {
          while_continue___133: /* CIL Label */ ;
          {
#line 1111
          set_ulong_register(12U, Registers[12] | 1UL);
          }
          {
#line 1111
          while (1) {
            while_continue___134: /* CIL Label */ ;
#line 1111
            if ((Registers[1] & Registers[12]) != 0UL) {
#line 1111
              tmp___74 = memory_block_start;
            } else {
#line 1111
              if ((Registers[1] & 4UL) != 0UL) {
#line 1111
                tmp___73 = heap_alloc_limit;
              } else {
#line 1111
                tmp___73 = heap_end;
              }
#line 1111
              tmp___74 = tmp___73;
            }
            {
#line 1111
            set_ptr_register(0U, tmp___74);
            }
#line 1111
            if ((Registers[1] & 1UL) != 0UL) {
#line 1111
              tmp___75 = stack_guard;
            } else {
#line 1111
              tmp___75 = stack_start;
            }
            {
#line 1111
            set_ptr_register(11U, tmp___75);
            }
#line 1111
            goto while_break___134;
          }
          while_break___134: /* CIL Label */ ;
          }
#line 1111
          goto while_break___133;
        }
        while_break___133: /* CIL Label */ ;
        }
      }
#line 1111
      goto while_break___131;
    }
    while_break___131: /* CIL Label */ ;
    }
#line 1112
    Registers[5] = Registers[2];
#line 1113
    Registers[6] = (11UL << 58U) | 46UL;
    {
#line 1114
    while (1) {
      while_continue___135: /* CIL Label */ ;
#line 1114
      stack_pointer --;
#line 1114
      *stack_pointer = Registers[5];
#line 1114
      stack_pointer --;
#line 1114
      *stack_pointer = Registers[6];
#line 1114
      goto while_break___135;
    }
    while_break___135: /* CIL Label */ ;
    }
    {
#line 1116
    while (1) {
      while_continue___136: /* CIL Label */ ;
      {
#line 1116
      while (1) {
        while_continue___137: /* CIL Label */ ;
        {
#line 1116
        set_ulong_register(12U, Registers[12] | 4UL);
        }
        {
#line 1116
        while (1) {
          while_continue___138: /* CIL Label */ ;
#line 1116
          if ((Registers[1] & Registers[12]) != 0UL) {
#line 1116
            tmp___77 = memory_block_start;
          } else {
#line 1116
            if ((Registers[1] & 4UL) != 0UL) {
#line 1116
              tmp___76 = heap_alloc_limit;
            } else {
#line 1116
              tmp___76 = heap_end;
            }
#line 1116
            tmp___77 = tmp___76;
          }
          {
#line 1116
          set_ptr_register(0U, tmp___77);
          }
#line 1116
          if ((Registers[1] & 1UL) != 0UL) {
#line 1116
            tmp___78 = stack_guard;
          } else {
#line 1116
            tmp___78 = stack_start;
          }
          {
#line 1116
          set_ptr_register(11U, tmp___78);
          }
#line 1116
          goto while_break___138;
        }
        while_break___138: /* CIL Label */ ;
        }
#line 1116
        goto while_break___137;
      }
      while_break___137: /* CIL Label */ ;
      }
#line 1116
      if ((unsigned long )Free >= (unsigned long )heap_start) {
#line 1116
        if ((unsigned long )Free < (unsigned long )heap_alloc_limit) {
#line 1116
          tmp___79 = heap_alloc_limit - Free;
        } else {
#line 1116
          tmp___79 = 0L;
        }
      } else {
#line 1116
        tmp___79 = 0L;
      }
#line 1116
      gc_space_needed = (unsigned long )tmp___79;
#line 1116
      goto while_break___136;
    }
    while_break___136: /* CIL Label */ ;
    }
    {
#line 1116
    setup_interrupt(Registers[1] & Registers[12]);
    }
#line 1116
    goto perform_application;
  }
#line 1118
  tmp___81 = stack_pointer;
#line 1118
  stack_pointer ++;
#line 1118
  prev_restore_history_offset = *tmp___81 & 288230376151711743UL;
#line 1119
  tmp___82 = stack_pointer;
#line 1119
  stack_pointer ++;
#line 1120
  if (prev_restore_history_offset > 0UL) {
#line 1121
    *(stack_end + - prev_restore_history_offset) = (11UL << 58U) | 5UL;
  }
#line 1124
  goto switch_break___1;
  case_69: /* CIL Label */ 
  {
#line 1128
  while (1) {
    while_continue___139: /* CIL Label */ ;
    {
#line 1128
    set_ulong_register(1U, (unsigned long )((long )(Registers[5] & 288230376151711743UL)));
    }
    {
#line 1128
    while (1) {
      while_continue___140: /* CIL Label */ ;
#line 1128
      if ((Registers[1] & Registers[12]) != 0UL) {
#line 1128
        tmp___84 = memory_block_start;
      } else {
#line 1128
        if ((Registers[1] & 4UL) != 0UL) {
#line 1128
          tmp___83 = heap_alloc_limit;
        } else {
#line 1128
          tmp___83 = heap_end;
        }
#line 1128
        tmp___84 = tmp___83;
      }
      {
#line 1128
      set_ptr_register(0U, tmp___84);
      }
#line 1128
      if ((Registers[1] & 1UL) != 0UL) {
#line 1128
        tmp___85 = stack_guard;
      } else {
#line 1128
        tmp___85 = stack_start;
      }
      {
#line 1128
      set_ptr_register(11U, tmp___85);
      }
#line 1128
      goto while_break___140;
    }
    while_break___140: /* CIL Label */ ;
    }
#line 1128
    goto while_break___139;
  }
  while_break___139: /* CIL Label */ ;
  }
#line 1129
  if ((unsigned long )Free >= (unsigned long )heap_start) {
#line 1129
    if ((unsigned long )Free < (unsigned long )heap_alloc_limit) {
#line 1129
      if (! ((unsigned long )(Free + 0) <= (unsigned long )heap_alloc_limit)) {
#line 1129
        goto _L___8;
      }
    } else {
#line 1129
      goto _L___8;
    }
  } else
  _L___8: /* CIL Label */ 
#line 1129
  if ((Registers[1] & 4UL) != 0UL) {
    {
#line 1130
    while (1) {
      while_continue___141: /* CIL Label */ ;
      {
#line 1130
      while (1) {
        while_continue___142: /* CIL Label */ ;
        {
#line 1130
        set_ulong_register(12U, Registers[12] | 4UL);
        }
        {
#line 1130
        while (1) {
          while_continue___143: /* CIL Label */ ;
#line 1130
          if ((Registers[1] & Registers[12]) != 0UL) {
#line 1130
            tmp___87 = memory_block_start;
          } else {
#line 1130
            if ((Registers[1] & 4UL) != 0UL) {
#line 1130
              tmp___86 = heap_alloc_limit;
            } else {
#line 1130
              tmp___86 = heap_end;
            }
#line 1130
            tmp___87 = tmp___86;
          }
          {
#line 1130
          set_ptr_register(0U, tmp___87);
          }
#line 1130
          if ((Registers[1] & 1UL) != 0UL) {
#line 1130
            tmp___88 = stack_guard;
          } else {
#line 1130
            tmp___88 = stack_start;
          }
          {
#line 1130
          set_ptr_register(11U, tmp___88);
          }
#line 1130
          goto while_break___143;
        }
        while_break___143: /* CIL Label */ ;
        }
#line 1130
        goto while_break___142;
      }
      while_break___142: /* CIL Label */ ;
      }
#line 1130
      gc_space_needed = 0UL;
#line 1130
      goto while_break___141;
    }
    while_break___141: /* CIL Label */ ;
    }
  }
#line 1131
  if ((Registers[1] & Registers[12]) != 0UL) {
#line 1133
    Registers[6] = (11UL << 58U) | 46UL;
#line 1134
    Registers[5] = Registers[2];
    {
#line 1135
    while (1) {
      while_continue___144: /* CIL Label */ ;
#line 1135
      stack_pointer --;
#line 1135
      *stack_pointer = Registers[5];
#line 1135
      stack_pointer --;
#line 1135
      *stack_pointer = Registers[6];
#line 1135
      goto while_break___144;
    }
    while_break___144: /* CIL Label */ ;
    }
    {
#line 1136
    setup_interrupt(Registers[1] & Registers[12]);
    }
#line 1136
    goto perform_application;
  }
#line 1138
  goto switch_break___1;
  case_66: /* CIL Label */ 
#line 1144
  stack_pointer ++;
#line 1145
  goto switch_break___1;
  case_12___0: /* CIL Label */ 
  {
#line 1148
  end_subproblem();
#line 1149
  tmp___89 = stack_pointer;
#line 1149
  stack_pointer ++;
#line 1149
  Registers[3] = *tmp___89;
  }
  {
#line 1150
  while (1) {
    while_continue___145: /* CIL Label */ ;
    {
#line 1150
    Registers[5] = *((SCHEME_OBJECT *)(Registers[5] & 288230376151711743UL) + 1);
#line 1150
    new_reduction(Registers[5], Registers[3]);
    }
#line 1150
    goto do_expression;
#line 1150
    goto while_break___145;
  }
  while_break___145: /* CIL Label */ ;
  }
  case_28___0: /* CIL Label */ 
#line 1155
  if (*((SCHEME_OBJECT *)(Registers[5] & 288230376151711743UL) + 0) == 8UL << 58U) {
#line 1156
    Registers[2] = *((SCHEME_OBJECT *)(Registers[5] & 288230376151711743UL) + 1);
  } else {
#line 1159
    *((SCHEME_OBJECT *)(Registers[5] & 288230376151711743UL) + 0) = 8UL << 58U;
#line 1160
    *((SCHEME_OBJECT *)(Registers[5] & 288230376151711743UL) + 1) = Registers[2];
  }
#line 1162
  goto switch_break___1;
  switch_default___3: /* CIL Label */ 
  {
#line 1165
  while (1) {
    while_continue___146: /* CIL Label */ ;
    {
#line 1165
    while (1) {
      while_continue___147: /* CIL Label */ ;
#line 1165
      stack_pointer --;
#line 1165
      *stack_pointer = Registers[5];
#line 1165
      stack_pointer --;
#line 1165
      *stack_pointer = Registers[6];
#line 1165
      goto while_break___147;
    }
    while_break___147: /* CIL Label */ ;
    }
    {
#line 1165
    Do_Micro_Error(48L, (_Bool)1);
    }
#line 1165
    goto internal_apply;
#line 1165
    goto while_break___146;
  }
  while_break___146: /* CIL Label */ ;
  }
  switch_break___1: /* CIL Label */ ;
  }
#line 1167
  goto pop_return;
}
}
#line 69 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 298 "/home/khheo/project/mit-scheme-9.2/src/microcode/extern.h"
char const   *arg_symbol(int n ) ;
#line 299
char const   *arg_interned_symbol(int n ) ;
#line 300
SCHEME_OBJECT intern_symbol(SCHEME_OBJECT symbol ) ;
#line 301
SCHEME_OBJECT string_to_symbol(SCHEME_OBJECT string ) ;
#line 303
SCHEME_OBJECT memory_to_symbol(unsigned long length , void const   *string ) ;
#line 304
SCHEME_OBJECT find_symbol(unsigned long length , char const   *string ) ;
#line 35 "/home/khheo/project/mit-scheme-9.2/src/microcode/intern.c"
static uint32_t string_hash(long length , char const   *string ) 
{ 
  unsigned char const   *scan ;
  unsigned char const   *end ;
  uint32_t result ;
  unsigned char const   *tmp ;

  {
#line 38
  scan = (unsigned char const   *)string;
#line 39
  end = scan + length;
#line 40
  result = 2166136261U;
  {
#line 41
  while (1) {
    while_continue: /* CIL Label */ ;
#line 41
    if (! ((unsigned long )scan < (unsigned long )end)) {
#line 41
      goto while_break;
    }
#line 42
    tmp = scan;
#line 42
    scan ++;
#line 42
    result = result * 16777619U ^ (uint32_t )*tmp;
  }
  while_break: /* CIL Label */ ;
  }
#line 44
  return (result);
}
}
#line 51 "/home/khheo/project/mit-scheme-9.2/src/microcode/intern.c"
static SCHEME_OBJECT *find_symbol_internal(unsigned long length , char const   *string ) 
{ 
  SCHEME_OBJECT obarray ;
  SCHEME_OBJECT *bucket ;
  uint32_t tmp ;
  SCHEME_OBJECT list ;
  SCHEME_OBJECT symbol ;
  SCHEME_OBJECT name ;
  int tmp___0 ;

  {
  {
#line 54
  obarray = *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 4);
#line 55
  tmp = string_hash((long )length, string);
#line 55
  bucket = (SCHEME_OBJECT *)(obarray & 288230376151711743UL) + ((unsigned long )tmp % (*((SCHEME_OBJECT *)(obarray & 288230376151711743UL) + 0) & 288230376151711743UL) + 1UL);
  }
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;
#line 61
    list = *bucket;
#line 62
    if (list >> 58U == 55UL) {
#line 62
      goto _L;
    } else
#line 62
    if (list >> 58U == 1UL) {
      _L: /* CIL Label */ 
#line 64
      symbol = *((SCHEME_OBJECT *)(list & 288230376151711743UL) + 0);
#line 65
      if (symbol >> 58U == 29UL) {
#line 67
        name = *((SCHEME_OBJECT *)(symbol & 288230376151711743UL) + 0);
#line 68
        if ((*((SCHEME_OBJECT *)(name & 288230376151711743UL) + 1) & 288230376151711743UL) == length) {
          {
#line 68
          tmp___0 = memcmp((void const   *)((char *)((SCHEME_OBJECT *)(name & 288230376151711743UL) + 2)),
                           (void const   *)string, length);
          }
#line 68
          if (tmp___0 == 0) {
#line 71
            return ((SCHEME_OBJECT *)(list & 288230376151711743UL) + 0);
          } else {
#line 73
            bucket = (SCHEME_OBJECT *)(list & 288230376151711743UL) + 1;
          }
        } else {
#line 73
          bucket = (SCHEME_OBJECT *)(list & 288230376151711743UL) + 1;
        }
      } else {
#line 76
        *bucket = *((SCHEME_OBJECT *)(list & 288230376151711743UL) + 1);
      }
    } else {
#line 79
      return (bucket);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 83 "/home/khheo/project/mit-scheme-9.2/src/microcode/intern.c"
static void replace_symbol_bucket_type(SCHEME_OBJECT symbol , unsigned int type ) 
{ 
  SCHEME_OBJECT obarray ;
  SCHEME_OBJECT string ;
  SCHEME_OBJECT *bucket ;
  long length ;
  char const   *char_pointer ;
  uint32_t tmp ;
  SCHEME_OBJECT list ;
  SCHEME_OBJECT element ;

  {
#line 90
  if (symbol >> 58U == 5UL) {
#line 90
    return;
  }
  {
#line 93
  obarray = *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 4);
#line 94
  string = *((SCHEME_OBJECT *)(symbol & 288230376151711743UL) + 0);
#line 95
  length = (long )(*((SCHEME_OBJECT *)(string & 288230376151711743UL) + 1) & 288230376151711743UL);
#line 96
  char_pointer = (char const   *)((char *)((SCHEME_OBJECT *)(string & 288230376151711743UL) + 2));
#line 97
  tmp = string_hash(length, char_pointer);
#line 97
  bucket = (SCHEME_OBJECT *)(obarray & 288230376151711743UL) + ((unsigned long )tmp % (*((SCHEME_OBJECT *)(obarray & 288230376151711743UL) + 0) & 288230376151711743UL) + 1UL);
  }
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;
#line 103
    list = *bucket;
#line 107
    element = *((SCHEME_OBJECT *)(list & 288230376151711743UL) + 0);
#line 109
    if (element >> 58U == 29UL) {
#line 111
      if (element == symbol) {
#line 113
        *bucket = ((unsigned long )type << 58U) | (list & 288230376151711743UL);
#line 114
        return;
      }
#line 116
      bucket = (SCHEME_OBJECT *)(list & 288230376151711743UL) + 1;
    } else {
#line 119
      *bucket = *((SCHEME_OBJECT *)(list & 288230376151711743UL) + 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 123 "/home/khheo/project/mit-scheme-9.2/src/microcode/intern.c"
void strengthen_symbol(SCHEME_OBJECT symbol ) 
{ 


  {
  {
#line 126
  replace_symbol_bucket_type(symbol, 1U);
  }
#line 127
  return;
}
}
#line 129 "/home/khheo/project/mit-scheme-9.2/src/microcode/intern.c"
void weaken_symbol(SCHEME_OBJECT symbol ) 
{ 


  {
  {
#line 132
  replace_symbol_bucket_type(symbol, 55U);
  }
#line 133
  return;
}
}
#line 135 "/home/khheo/project/mit-scheme-9.2/src/microcode/intern.c"
static SCHEME_OBJECT make_symbol(SCHEME_OBJECT string , SCHEME_OBJECT *cell ) 
{ 
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;
  SCHEME_OBJECT symbol ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 138
  while (1) {
    while_continue: /* CIL Label */ ;
#line 138
    if ((unsigned long )Free >= (unsigned long )heap_start) {
#line 138
      if ((unsigned long )Free < (unsigned long )heap_alloc_limit) {
#line 138
        if (! ((unsigned long )(Free + 4) <= (unsigned long )heap_alloc_limit)) {
#line 138
          goto _L___0;
        }
      } else {
#line 138
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 138
    if ((Registers[1] & 4UL) != 0UL) {
      {
#line 138
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 138
        if ((unsigned long )Free_primitive < (unsigned long )heap_start) {
          {
#line 138
          outf_fatal("\nMicrocode requested primitive GC outside primitive!\n");
#line 138
          Microcode_Termination(12);
          }
        }
#line 138
        if ((unsigned long )Free < (unsigned long )Free_primitive) {
          {
#line 138
          outf_fatal("\nFree has gone backwards!\n");
#line 138
          Microcode_Termination(12);
          }
        }
        {
#line 138
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 138
          while (1) {
            while_continue___2: /* CIL Label */ ;
            {
#line 138
            set_ulong_register(12U, Registers[12] | 4UL);
            }
            {
#line 138
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 138
              if ((Registers[1] & Registers[12]) != 0UL) {
#line 138
                tmp___0 = memory_block_start;
              } else {
#line 138
                if ((Registers[1] & 4UL) != 0UL) {
#line 138
                  tmp = heap_alloc_limit;
                } else {
#line 138
                  tmp = heap_end;
                }
#line 138
                tmp___0 = tmp;
              }
              {
#line 138
              set_ptr_register(0U, tmp___0);
              }
#line 138
              if ((Registers[1] & 1UL) != 0UL) {
#line 138
                tmp___1 = stack_guard;
              } else {
#line 138
                tmp___1 = stack_start;
              }
              {
#line 138
              set_ptr_register(11U, tmp___1);
              }
#line 138
              goto while_break___3;
            }
            while_break___3: /* CIL Label */ ;
            }
#line 138
            goto while_break___2;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 138
          gc_space_needed = (unsigned long )(4L + (Free - Free_primitive));
#line 138
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 138
        signal_interrupt_from_primitive();
        }
#line 138
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 138
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 140
  symbol = (29UL << 58U) | (SCHEME_OBJECT )Free;
#line 141
  Free += 2;
#line 142
  *((SCHEME_OBJECT *)(symbol & 288230376151711743UL) + 0) = string;
#line 143
  *((SCHEME_OBJECT *)(symbol & 288230376151711743UL) + 1) = (50UL << 58U) | 2UL;
#line 144
  *cell = system_pair_cons(55L, symbol, (8UL << 58U) | 9UL);
  }
#line 145
  return (symbol);
}
}
#line 149 "/home/khheo/project/mit-scheme-9.2/src/microcode/intern.c"
SCHEME_OBJECT find_symbol(unsigned long length , char const   *string ) 
{ 
  SCHEME_OBJECT *cell ;
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT tmp___0 ;

  {
  {
#line 152
  tmp = find_symbol_internal(length, string);
#line 152
  cell = tmp;
  }
#line 153
  if (*cell >> 58U == 29UL) {
#line 153
    tmp___0 = *cell;
  } else {
#line 153
    tmp___0 = 0UL;
  }
#line 153
  return (tmp___0);
}
}
#line 156 "/home/khheo/project/mit-scheme-9.2/src/microcode/intern.c"
SCHEME_OBJECT memory_to_symbol(unsigned long length , void const   *string ) 
{ 
  SCHEME_OBJECT *cell ;
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT tmp___0 ;
  SCHEME_OBJECT tmp___1 ;
  SCHEME_OBJECT tmp___2 ;

  {
  {
#line 159
  tmp = find_symbol_internal(length, (char const   *)string);
#line 159
  cell = tmp;
  }
#line 160
  if (*cell >> 58U == 29UL) {
#line 160
    tmp___2 = *cell;
  } else {
    {
#line 160
    tmp___0 = memory_to_string(length, string);
#line 160
    tmp___1 = make_symbol(tmp___0, cell);
#line 160
    tmp___2 = tmp___1;
    }
  }
#line 160
  return (tmp___2);
}
}
#line 166 "/home/khheo/project/mit-scheme-9.2/src/microcode/intern.c"
SCHEME_OBJECT char_pointer_to_symbol(char const   *string ) 
{ 
  size_t tmp ;
  SCHEME_OBJECT tmp___0 ;

  {
  {
#line 169
  tmp = strlen(string);
#line 169
  tmp___0 = memory_to_symbol(tmp, (void const   *)string);
  }
#line 169
  return (tmp___0);
}
}
#line 172 "/home/khheo/project/mit-scheme-9.2/src/microcode/intern.c"
SCHEME_OBJECT string_to_symbol(SCHEME_OBJECT string ) 
{ 
  SCHEME_OBJECT *cell ;
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT tmp___0 ;
  SCHEME_OBJECT tmp___1 ;

  {
  {
#line 175
  tmp = find_symbol_internal(*((SCHEME_OBJECT *)(string & 288230376151711743UL) + 1) & 288230376151711743UL,
                             (char const   *)((char *)((SCHEME_OBJECT *)(string & 288230376151711743UL) + 2)));
#line 175
  cell = tmp;
  }
#line 178
  if (*cell >> 58U == 29UL) {
#line 178
    tmp___1 = *cell;
  } else {
    {
#line 178
    tmp___0 = make_symbol(string, cell);
#line 178
    tmp___1 = tmp___0;
    }
  }
#line 178
  return (tmp___1);
}
}
#line 183 "/home/khheo/project/mit-scheme-9.2/src/microcode/intern.c"
SCHEME_OBJECT intern_symbol(SCHEME_OBJECT symbol ) 
{ 
  SCHEME_OBJECT name ;
  SCHEME_OBJECT *cell ;
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT result ;

  {
  {
#line 186
  name = *((SCHEME_OBJECT *)(symbol & 288230376151711743UL) + 0);
#line 187
  tmp = find_symbol_internal(*((SCHEME_OBJECT *)(name & 288230376151711743UL) + 1) & 288230376151711743UL,
                             (char const   *)((char *)((SCHEME_OBJECT *)(name & 288230376151711743UL) + 2)));
#line 187
  cell = tmp;
  }
#line 190
  if (*cell >> 58U == 29UL) {
#line 191
    return (*cell);
  } else {
    {
#line 194
    result = (29UL << 58U) | (symbol & 288230376151711743UL);
#line 195
    *cell = system_pair_cons(55L, result, (8UL << 58U) | 9UL);
    }
#line 196
    return (result);
  }
}
}
#line 200 "/home/khheo/project/mit-scheme-9.2/src/microcode/intern.c"
char const   *arg_symbol(int n ) 
{ 


  {
  {
#line 203
  while (1) {
    while_continue: /* CIL Label */ ;
#line 203
    if (! (*(stack_pointer + (n - 1)) >> 58U == 29UL)) {
#line 203
      if (! (*(stack_pointer + (n - 1)) >> 58U == 5UL)) {
        {
#line 203
        error_wrong_type_arg(n);
        }
      }
    }
#line 203
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 204
  return ((char const   *)((char *)((SCHEME_OBJECT *)(*((SCHEME_OBJECT *)(*(stack_pointer + (n - 1)) & 288230376151711743UL) + 0) & 288230376151711743UL) + 2)));
}
}
#line 207 "/home/khheo/project/mit-scheme-9.2/src/microcode/intern.c"
char const   *arg_interned_symbol(int n ) 
{ 


  {
  {
#line 210
  while (1) {
    while_continue: /* CIL Label */ ;
#line 210
    if (! (*(stack_pointer + (n - 1)) >> 58U == 29UL)) {
      {
#line 210
      error_wrong_type_arg(n);
      }
    }
#line 210
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 211
  return ((char const   *)((char *)((SCHEME_OBJECT *)(*((SCHEME_OBJECT *)(*(stack_pointer + (n - 1)) & 288230376151711743UL) + 0) & 288230376151711743UL) + 2)));
}
}
#line 214 "/home/khheo/project/mit-scheme-9.2/src/microcode/intern.c"
SCHEME_OBJECT Prim_find_symbol(void) 
{ 
  SCHEME_OBJECT string ;
  SCHEME_OBJECT tmp ;

  {
  {
#line 218
  while (1) {
    while_continue: /* CIL Label */ ;
#line 218
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 219
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 219
    if (! (*(stack_pointer + 0) >> 58U == 30UL)) {
      {
#line 219
      error_wrong_type_arg(1);
      }
    }
#line 219
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 221
  string = *(stack_pointer + 0);
#line 222
  tmp = find_symbol(*((SCHEME_OBJECT *)(string & 288230376151711743UL) + 1) & 288230376151711743UL,
                    (char const   *)((char *)((SCHEME_OBJECT *)(string & 288230376151711743UL) + 2)));
  }
#line 222
  return (tmp);
}
}
#line 227 "/home/khheo/project/mit-scheme-9.2/src/microcode/intern.c"
SCHEME_OBJECT Prim_string_to_symbol(void) 
{ 
  SCHEME_OBJECT tmp ;

  {
  {
#line 232
  while (1) {
    while_continue: /* CIL Label */ ;
#line 232
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 233
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 233
    if (! (*(stack_pointer + 0) >> 58U == 30UL)) {
      {
#line 233
      error_wrong_type_arg(1);
      }
    }
#line 233
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 234
  tmp = string_to_symbol(*(stack_pointer + 0));
  }
#line 234
  return (tmp);
}
}
#line 237 "/home/khheo/project/mit-scheme-9.2/src/microcode/intern.c"
SCHEME_OBJECT Prim_string_hash(void) 
{ 
  SCHEME_OBJECT string ;
  uint32_t tmp ;

  {
  {
#line 243
  while (1) {
    while_continue: /* CIL Label */ ;
#line 243
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 244
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 244
    if (! (*(stack_pointer + 0) >> 58U == 30UL)) {
      {
#line 244
      error_wrong_type_arg(1);
      }
    }
#line 244
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 246
  string = *(stack_pointer + 0);
#line 247
  tmp = string_hash((long )(*((SCHEME_OBJECT *)(string & 288230376151711743UL) + 1) & 288230376151711743UL),
                    (char const   *)((char *)((SCHEME_OBJECT *)(string & 288230376151711743UL) + 2)));
  }
#line 247
  return ((26UL << 58U) | (unsigned long )tmp);
}
}
#line 253 "/home/khheo/project/mit-scheme-9.2/src/microcode/intern.c"
SCHEME_OBJECT Prim_string_hash_mod(void) 
{ 
  SCHEME_OBJECT string ;
  uint32_t tmp ;
  unsigned long tmp___0 ;

  {
  {
#line 258
  while (1) {
    while_continue: /* CIL Label */ ;
#line 258
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 259
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 259
    if (! (*(stack_pointer + 0) >> 58U == 30UL)) {
      {
#line 259
      error_wrong_type_arg(1);
      }
    }
#line 259
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 261
  string = *(stack_pointer + 0);
#line 262
  tmp = string_hash((long )(*((SCHEME_OBJECT *)(string & 288230376151711743UL) + 1) & 288230376151711743UL),
                    (char const   *)((char *)((SCHEME_OBJECT *)(string & 288230376151711743UL) + 2)));
#line 262
  tmp___0 = arg_ulong_integer(2);
  }
#line 262
  return ((26UL << 58U) | (unsigned long )tmp % tmp___0);
}
}
#line 32 "/home/khheo/project/mit-scheme-9.2/src/microcode/hunk.c"
SCHEME_OBJECT hunk3_cons(SCHEME_OBJECT cxr0 , SCHEME_OBJECT cxr1 , SCHEME_OBJECT cxr2 ) 
{ 
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;
  SCHEME_OBJECT *tmp___2 ;
  SCHEME_OBJECT *tmp___3 ;
  SCHEME_OBJECT *tmp___4 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 37
  while (1) {
    while_continue: /* CIL Label */ ;
#line 37
    if ((unsigned long )Free >= (unsigned long )heap_start) {
#line 37
      if ((unsigned long )Free < (unsigned long )heap_alloc_limit) {
#line 37
        if (! ((unsigned long )(Free + 3) <= (unsigned long )heap_alloc_limit)) {
#line 37
          goto _L___0;
        }
      } else {
#line 37
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 37
    if ((Registers[1] & 4UL) != 0UL) {
      {
#line 37
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 37
        if ((unsigned long )Free_primitive < (unsigned long )heap_start) {
          {
#line 37
          outf_fatal("\nMicrocode requested primitive GC outside primitive!\n");
#line 37
          Microcode_Termination(12);
          }
        }
#line 37
        if ((unsigned long )Free < (unsigned long )Free_primitive) {
          {
#line 37
          outf_fatal("\nFree has gone backwards!\n");
#line 37
          Microcode_Termination(12);
          }
        }
        {
#line 37
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 37
          while (1) {
            while_continue___2: /* CIL Label */ ;
            {
#line 37
            set_ulong_register(12U, Registers[12] | 4UL);
            }
            {
#line 37
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 37
              if ((Registers[1] & Registers[12]) != 0UL) {
#line 37
                tmp___0 = memory_block_start;
              } else {
#line 37
                if ((Registers[1] & 4UL) != 0UL) {
#line 37
                  tmp = heap_alloc_limit;
                } else {
#line 37
                  tmp = heap_end;
                }
#line 37
                tmp___0 = tmp;
              }
              {
#line 37
              set_ptr_register(0U, tmp___0);
              }
#line 37
              if ((Registers[1] & 1UL) != 0UL) {
#line 37
                tmp___1 = stack_guard;
              } else {
#line 37
                tmp___1 = stack_start;
              }
              {
#line 37
              set_ptr_register(11U, tmp___1);
              }
#line 37
              goto while_break___3;
            }
            while_break___3: /* CIL Label */ ;
            }
#line 37
            goto while_break___2;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 37
          gc_space_needed = (unsigned long )(3L + (Free - Free_primitive));
#line 37
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 37
        signal_interrupt_from_primitive();
        }
#line 37
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 37
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 38
  tmp___2 = Free;
#line 38
  Free ++;
#line 38
  *tmp___2 = cxr0;
#line 39
  tmp___3 = Free;
#line 39
  Free ++;
#line 39
  *tmp___3 = cxr1;
#line 40
  tmp___4 = Free;
#line 40
  Free ++;
#line 40
  *tmp___4 = cxr2;
#line 41
  return ((36UL << 58U) | (SCHEME_OBJECT )(Free - 3));
}
}
#line 44 "/home/khheo/project/mit-scheme-9.2/src/microcode/hunk.c"
SCHEME_OBJECT Prim_hunk3_cons(void) 
{ 
  SCHEME_OBJECT tmp ;

  {
  {
#line 46
  while (1) {
    while_continue: /* CIL Label */ ;
#line 46
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 47
  tmp = hunk3_cons(*(stack_pointer + 0), *(stack_pointer + 1), *(stack_pointer + 2));
  }
#line 47
  return (tmp);
}
}
#line 50 "/home/khheo/project/mit-scheme-9.2/src/microcode/hunk.c"
SCHEME_OBJECT Prim_hunk3_cxr(void) 
{ 
  long tmp ;

  {
  {
#line 52
  while (1) {
    while_continue: /* CIL Label */ ;
#line 52
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 53
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 53
    if (! (*(stack_pointer + 0) >> 58U == 32UL)) {
#line 53
      if (! (*(stack_pointer + 0) >> 58U == 36UL)) {
        {
#line 53
        error_wrong_type_arg(1);
        }
      }
    }
#line 53
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 54
  tmp = arg_index_integer(2, 3L);
  }
#line 54
  return (*((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + tmp));
}
}
#line 57 "/home/khheo/project/mit-scheme-9.2/src/microcode/hunk.c"
SCHEME_OBJECT Prim_hunk3_set_cxr(void) 
{ 
  SCHEME_OBJECT hunk3 ;
  long index___0 ;
  long tmp ;
  SCHEME_OBJECT object ;

  {
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;
#line 59
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 60
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 60
    if (! (*(stack_pointer + 0) >> 58U == 32UL)) {
#line 60
      if (! (*(stack_pointer + 0) >> 58U == 36UL)) {
        {
#line 60
        error_wrong_type_arg(1);
        }
      }
    }
#line 60
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 62
  hunk3 = *(stack_pointer + 0);
#line 63
  tmp = arg_index_integer(2, 3L);
#line 63
  index___0 = tmp;
#line 64
  object = *(stack_pointer + 2);
#line 65
  *((SCHEME_OBJECT *)(hunk3 & 288230376151711743UL) + index___0) = object;
  }
#line 67
  return ((8UL << 58U) | 1UL);
}
}
#line 75 "/home/khheo/project/mit-scheme-9.2/src/microcode/hunk.c"
SCHEME_OBJECT Prim_sys_h3_0(void) 
{ 
  SCHEME_OBJECT tmp___0 ;
  gc_type_t tmp___1 ;

  {
  {
#line 77
  while (1) {
    while_continue: /* CIL Label */ ;
#line 77
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 78
  tmp___1 = gc_type_code((unsigned int )(*(stack_pointer + 0) >> 58U));
  }
#line 78
  if ((int )tmp___1 == 3) {
#line 78
    tmp___0 = *(stack_pointer + 0);
  } else {
    {
#line 78
    error_wrong_type_arg(1);
#line 78
    tmp___0 = (SCHEME_OBJECT )0;
    }
  }
#line 78
  return (*((SCHEME_OBJECT *)(tmp___0 & 288230376151711743UL) + 0));
}
}
#line 81 "/home/khheo/project/mit-scheme-9.2/src/microcode/hunk.c"
SCHEME_OBJECT Prim_sys_h3_1(void) 
{ 
  SCHEME_OBJECT tmp___0 ;
  gc_type_t tmp___1 ;

  {
  {
#line 83
  while (1) {
    while_continue: /* CIL Label */ ;
#line 83
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 84
  tmp___1 = gc_type_code((unsigned int )(*(stack_pointer + 0) >> 58U));
  }
#line 84
  if ((int )tmp___1 == 3) {
#line 84
    tmp___0 = *(stack_pointer + 0);
  } else {
    {
#line 84
    error_wrong_type_arg(1);
#line 84
    tmp___0 = (SCHEME_OBJECT )0;
    }
  }
#line 84
  return (*((SCHEME_OBJECT *)(tmp___0 & 288230376151711743UL) + 1));
}
}
#line 87 "/home/khheo/project/mit-scheme-9.2/src/microcode/hunk.c"
SCHEME_OBJECT Prim_sys_h3_2(void) 
{ 
  SCHEME_OBJECT tmp___0 ;
  gc_type_t tmp___1 ;

  {
  {
#line 89
  while (1) {
    while_continue: /* CIL Label */ ;
#line 89
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 90
  tmp___1 = gc_type_code((unsigned int )(*(stack_pointer + 0) >> 58U));
  }
#line 90
  if ((int )tmp___1 == 3) {
#line 90
    tmp___0 = *(stack_pointer + 0);
  } else {
    {
#line 90
    error_wrong_type_arg(1);
#line 90
    tmp___0 = (SCHEME_OBJECT )0;
    }
  }
#line 90
  return (*((SCHEME_OBJECT *)(tmp___0 & 288230376151711743UL) + 2));
}
}
#line 93 "/home/khheo/project/mit-scheme-9.2/src/microcode/hunk.c"
SCHEME_OBJECT Prim_sh3_set_0(void) 
{ 
  SCHEME_OBJECT hunk3 ;
  SCHEME_OBJECT tmp___0 ;
  gc_type_t tmp___1 ;
  SCHEME_OBJECT object ;

  {
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;
#line 95
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 97
  tmp___1 = gc_type_code((unsigned int )(*(stack_pointer + 0) >> 58U));
  }
#line 97
  if ((int )tmp___1 == 3) {
#line 97
    tmp___0 = *(stack_pointer + 0);
  } else {
    {
#line 97
    error_wrong_type_arg(1);
#line 97
    tmp___0 = (SCHEME_OBJECT )0;
    }
  }
#line 97
  hunk3 = tmp___0;
#line 98
  object = *(stack_pointer + 1);
#line 99
  *((SCHEME_OBJECT *)(hunk3 & 288230376151711743UL) + 0) = object;
#line 101
  return ((8UL << 58U) | 1UL);
}
}
#line 104 "/home/khheo/project/mit-scheme-9.2/src/microcode/hunk.c"
SCHEME_OBJECT Prim_sh3_set_1(void) 
{ 
  SCHEME_OBJECT hunk3 ;
  SCHEME_OBJECT tmp___0 ;
  gc_type_t tmp___1 ;
  SCHEME_OBJECT object ;

  {
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
#line 106
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 108
  tmp___1 = gc_type_code((unsigned int )(*(stack_pointer + 0) >> 58U));
  }
#line 108
  if ((int )tmp___1 == 3) {
#line 108
    tmp___0 = *(stack_pointer + 0);
  } else {
    {
#line 108
    error_wrong_type_arg(1);
#line 108
    tmp___0 = (SCHEME_OBJECT )0;
    }
  }
#line 108
  hunk3 = tmp___0;
#line 109
  object = *(stack_pointer + 1);
#line 110
  *((SCHEME_OBJECT *)(hunk3 & 288230376151711743UL) + 1) = object;
#line 112
  return ((8UL << 58U) | 1UL);
}
}
#line 115 "/home/khheo/project/mit-scheme-9.2/src/microcode/hunk.c"
SCHEME_OBJECT Prim_sh3_set_2(void) 
{ 
  SCHEME_OBJECT hunk3 ;
  SCHEME_OBJECT tmp___0 ;
  gc_type_t tmp___1 ;
  SCHEME_OBJECT object ;

  {
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
#line 117
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 119
  tmp___1 = gc_type_code((unsigned int )(*(stack_pointer + 0) >> 58U));
  }
#line 119
  if ((int )tmp___1 == 3) {
#line 119
    tmp___0 = *(stack_pointer + 0);
  } else {
    {
#line 119
    error_wrong_type_arg(1);
#line 119
    tmp___0 = (SCHEME_OBJECT )0;
    }
  }
#line 119
  hunk3 = tmp___0;
#line 120
  object = *(stack_pointer + 1);
#line 121
  *((SCHEME_OBJECT *)(hunk3 & 288230376151711743UL) + 2) = object;
#line 123
  return ((8UL << 58U) | 1UL);
}
}
#line 370 "/home/khheo/project/mit-scheme-9.2/src/microcode/extern.h"
SCHEME_OBJECT *control_point_start(SCHEME_OBJECT cp ) ;
#line 371
SCHEME_OBJECT *control_point_end(SCHEME_OBJECT cp ) ;
#line 34 "/home/khheo/project/mit-scheme-9.2/src/microcode/hooks.c"
static SCHEME_OBJECT allocate_control_point(unsigned long n , _Bool gc_p ) ;
#line 35
static void with_new_interrupt_mask(unsigned long new_mask ) ;
#line 41 "/home/khheo/project/mit-scheme-9.2/src/microcode/hooks.c"
SCHEME_OBJECT Prim_apply(void) 
{ 
  SCHEME_OBJECT procedure ;
  SCHEME_OBJECT args ;
  unsigned long n_args ;
  SCHEME_OBJECT p1 ;
  SCHEME_OBJECT p2 ;
  SCHEME_OBJECT p1___0 ;
  SCHEME_OBJECT *sp ;
  SCHEME_OBJECT *s1 ;
  SCHEME_OBJECT *tmp ;

  {
  {
#line 44
  while (1) {
    while_continue: /* CIL Label */ ;
#line 44
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 46
  procedure = *(stack_pointer + 0);
#line 47
  args = *(stack_pointer + 1);
#line 48
  n_args = 0UL;
#line 58
  p1 = args;
#line 59
  p2 = p1;
  {
#line 61
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 61
    if (! (p1 >> 58U == 1UL)) {
#line 61
      goto while_break___0;
    }
#line 63
    p1 = *((SCHEME_OBJECT *)(p1 & 288230376151711743UL) + 1);
#line 64
    n_args ++;
#line 65
    if (p1 == p2) {
      {
#line 66
      error_bad_range_arg(2);
      }
    }
#line 67
    if (! (p1 >> 58U == 1UL)) {
#line 68
      goto while_break___0;
    }
#line 70
    p1 = *((SCHEME_OBJECT *)(p1 & 288230376151711743UL) + 1);
#line 71
    n_args ++;
#line 72
    if (p1 == p2) {
      {
#line 73
      error_bad_range_arg(2);
      }
    }
#line 74
    if (! (p1 >> 58U == 1UL)) {
#line 75
      goto while_break___0;
    }
#line 77
    p2 = *((SCHEME_OBJECT *)(p2 & 288230376151711743UL) + 1);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 79
  if (! (p1 == ((8UL << 58U) | 9UL))) {
    {
#line 80
    error_wrong_type_arg(2);
    }
  }
#line 83
  if (! ((unsigned long )(stack_pointer + - (n_args + 2UL)) >= (unsigned long )stack_guard)) {
    {
#line 84
    error_bad_range_arg(2);
    }
  }
#line 85
  stack_pointer += 2;
#line 88
  p1___0 = args;
#line 89
  sp = stack_pointer + - n_args;
#line 90
  s1 = sp;
  {
#line 91
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 91
    if (! ((unsigned long )s1 != (unsigned long )stack_pointer)) {
#line 91
      goto while_break___1;
    }
#line 93
    tmp = s1;
#line 93
    s1 ++;
#line 93
    *tmp = *((SCHEME_OBJECT *)(p1___0 & 288230376151711743UL) + 0);
#line 94
    p1___0 = *((SCHEME_OBJECT *)(p1___0 & 288230376151711743UL) + 1);
  }
  while_break___1: /* CIL Label */ ;
  }
#line 96
  stack_pointer = sp;
#line 100
  if (*(stack_pointer + n_args) >> 58U == 40UL) {
    {
#line 102
    apply_compiled_from_primitive(n_args, procedure);
#line 103
    stack_pointer += -2;
    }
#line 104
    return ((8UL << 58U) | 1UL);
  }
  {
#line 108
  stack_pointer --;
#line 108
  *stack_pointer = procedure;
#line 109
  stack_pointer --;
#line 109
  *stack_pointer = n_args + 1UL;
#line 110
  abort_to_interpreter(-3);
  }
#line 112
  return ((8UL << 58U) | 1UL);
}
}
#line 124 "/home/khheo/project/mit-scheme-9.2/src/microcode/hooks.c"
SCHEME_OBJECT Prim_catch(void) 
{ 
  SCHEME_OBJECT procedure ;
  SCHEME_OBJECT cp ;
  SCHEME_OBJECT *scan ;
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;
  SCHEME_OBJECT *tmp___2 ;
  SCHEME_OBJECT *tmp___3 ;
  SCHEME_OBJECT *tmp___4 ;

  {
  {
#line 128
  while (1) {
    while_continue: /* CIL Label */ ;
#line 128
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 129
  canonicalize_primitive_context();
#line 131
  procedure = *(stack_pointer + 0);
  }
#line 138
  if ((unsigned long )(stack_pointer + 3) == (unsigned long )stack_end) {
#line 138
    if (*(stack_pointer + 1) == ((11UL << 58U) | 1UL)) {
#line 138
      if (*(stack_pointer + 2) >> 58U == 28UL) {
#line 142
        cp = *(stack_pointer + 2);
#line 143
        history_register = (SCHEME_OBJECT *)(*((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 20) & 288230376151711743UL);
#line 144
        stack_pointer ++;
        {
#line 145
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 145
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
      } else {
#line 138
        goto _L___0;
      }
    } else {
#line 138
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    {
#line 149
    cp = allocate_control_point((unsigned long )(6L + ((stack_end - stack_pointer) - 1L)),
                                (_Bool)1);
#line 153
    stack_pointer ++;
#line 155
    save_history(5UL);
#line 156
    preserve_interrupt_mask();
#line 157
    prev_restore_history_offset = 0UL;
#line 159
    tmp = control_point_start(cp);
#line 159
    scan = tmp;
    }
    {
#line 160
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 160
      if (! (stack_end - stack_pointer > 0L)) {
#line 160
        goto while_break___1;
      }
#line 161
      tmp___0 = scan;
#line 161
      scan ++;
#line 161
      tmp___1 = stack_pointer;
#line 161
      stack_pointer ++;
#line 161
      *tmp___0 = *tmp___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 168
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 168
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 168
        set_ulong_register(12U, Registers[12] & 0xfffffffffffffffeUL);
        }
        {
#line 168
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 168
          if ((Registers[1] & Registers[12]) != 0UL) {
#line 168
            tmp___3 = memory_block_start;
          } else {
#line 168
            if ((Registers[1] & 4UL) != 0UL) {
#line 168
              tmp___2 = heap_alloc_limit;
            } else {
#line 168
              tmp___2 = heap_end;
            }
#line 168
            tmp___3 = tmp___2;
          }
          {
#line 168
          set_ptr_register(0U, tmp___3);
          }
#line 168
          if ((Registers[1] & 1UL) != 0UL) {
#line 168
            tmp___4 = stack_guard;
          } else {
#line 168
            tmp___4 = stack_start;
          }
          {
#line 168
          set_ptr_register(11U, tmp___4);
          }
#line 168
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 168
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 168
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 169
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 169
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 170
    Registers[6] = (11UL << 58U) | 1UL;
#line 171
    Registers[5] = cp;
    {
#line 172
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 172
      stack_pointer --;
#line 172
      *stack_pointer = Registers[5];
#line 172
      stack_pointer --;
#line 172
      *stack_pointer = Registers[6];
#line 172
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
  }
  {
#line 175
  stack_pointer --;
#line 175
  *stack_pointer = cp;
#line 176
  stack_pointer --;
#line 176
  *stack_pointer = procedure;
#line 177
  stack_pointer --;
#line 177
  *stack_pointer = 2UL;
#line 179
  abort_to_interpreter(-3);
  }
#line 181
  return ((8UL << 58U) | 1UL);
}
}
#line 195 "/home/khheo/project/mit-scheme-9.2/src/microcode/hooks.c"
SCHEME_OBJECT Prim_within_control_point(void) 
{ 
  SCHEME_OBJECT control_point ;
  SCHEME_OBJECT thunk ;
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;
  SCHEME_OBJECT *tmp___2 ;
  SCHEME_OBJECT *tmp___3 ;
  SCHEME_OBJECT *tmp___4 ;
  SCHEME_OBJECT *tmp___5 ;
  SCHEME_OBJECT *tmp___6 ;
  SCHEME_OBJECT *tmp___7 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 200
  while (1) {
    while_continue: /* CIL Label */ ;
#line 200
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 202
  canonicalize_primitive_context();
  }
  {
#line 203
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 203
    if (! (*(stack_pointer + 0) >> 58U == 28UL)) {
      {
#line 203
      error_wrong_type_arg(1);
      }
    }
#line 203
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 204
  control_point = *(stack_pointer + 0);
#line 205
  thunk = *(stack_pointer + 1);
#line 207
  stack_pointer = stack_end;
#line 209
  prev_restore_history_offset = 0UL;
  {
#line 210
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 210
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 210
      set_ulong_register(12U, Registers[12] & 0xfffffffffffffffeUL);
      }
      {
#line 210
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 210
        if ((Registers[1] & Registers[12]) != 0UL) {
#line 210
          tmp___0 = memory_block_start;
        } else {
#line 210
          if ((Registers[1] & 4UL) != 0UL) {
#line 210
            tmp = heap_alloc_limit;
          } else {
#line 210
            tmp = heap_end;
          }
#line 210
          tmp___0 = tmp;
        }
        {
#line 210
        set_ptr_register(0U, tmp___0);
        }
#line 210
        if ((Registers[1] & 1UL) != 0UL) {
#line 210
          tmp___1 = stack_guard;
        } else {
#line 210
          tmp___1 = stack_start;
        }
        {
#line 210
        set_ptr_register(11U, tmp___1);
        }
#line 210
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 210
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 210
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 212
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 212
    if (! ((unsigned long )(stack_pointer + -2) >= (unsigned long )stack_guard)) {
      {
#line 212
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 212
        if (*stack_start != ((34UL << 58U) | (SCHEME_OBJECT )stack_start)) {
          {
#line 212
          stack_death("STACK_CHECK");
          }
        }
#line 212
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 212
      while (1) {
        while_continue___6: /* CIL Label */ ;
        {
#line 212
        set_ulong_register(12U, Registers[12] | 1UL);
        }
        {
#line 212
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 212
          if ((Registers[1] & Registers[12]) != 0UL) {
#line 212
            tmp___3 = memory_block_start;
          } else {
#line 212
            if ((Registers[1] & 4UL) != 0UL) {
#line 212
              tmp___2 = heap_alloc_limit;
            } else {
#line 212
              tmp___2 = heap_end;
            }
#line 212
            tmp___3 = tmp___2;
          }
          {
#line 212
          set_ptr_register(0U, tmp___3);
          }
#line 212
          if ((Registers[1] & 1UL) != 0UL) {
#line 212
            tmp___4 = stack_guard;
          } else {
#line 212
            tmp___4 = stack_start;
          }
          {
#line 212
          set_ptr_register(11U, tmp___4);
          }
#line 212
          goto while_break___7;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 212
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
#line 212
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 213
  Registers[5] = control_point;
#line 214
  Registers[6] = (11UL << 58U) | 1UL;
  {
#line 215
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 215
    stack_pointer --;
#line 215
    *stack_pointer = Registers[5];
#line 215
    stack_pointer --;
#line 215
    *stack_pointer = Registers[6];
#line 215
    goto while_break___8;
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 218
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 218
    if (! ((unsigned long )(stack_pointer + -2) >= (unsigned long )stack_guard)) {
      {
#line 218
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 218
        if (*stack_start != ((34UL << 58U) | (SCHEME_OBJECT )stack_start)) {
          {
#line 218
          stack_death("STACK_CHECK");
          }
        }
#line 218
        goto while_break___10;
      }
      while_break___10: /* CIL Label */ ;
      }
      {
#line 218
      while (1) {
        while_continue___11: /* CIL Label */ ;
        {
#line 218
        set_ulong_register(12U, Registers[12] | 1UL);
        }
        {
#line 218
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 218
          if ((Registers[1] & Registers[12]) != 0UL) {
#line 218
            tmp___6 = memory_block_start;
          } else {
#line 218
            if ((Registers[1] & 4UL) != 0UL) {
#line 218
              tmp___5 = heap_alloc_limit;
            } else {
#line 218
              tmp___5 = heap_end;
            }
#line 218
            tmp___6 = tmp___5;
          }
          {
#line 218
          set_ptr_register(0U, tmp___6);
          }
#line 218
          if ((Registers[1] & 1UL) != 0UL) {
#line 218
            tmp___7 = stack_guard;
          } else {
#line 218
            tmp___7 = stack_start;
          }
          {
#line 218
          set_ptr_register(11U, tmp___7);
          }
#line 218
          goto while_break___12;
        }
        while_break___12: /* CIL Label */ ;
        }
#line 218
        goto while_break___11;
      }
      while_break___11: /* CIL Label */ ;
      }
    }
#line 218
    goto while_break___9;
  }
  while_break___9: /* CIL Label */ ;
  }
  {
#line 219
  stack_pointer --;
#line 219
  *stack_pointer = thunk;
#line 220
  stack_pointer --;
#line 220
  *stack_pointer = 1UL;
#line 223
  abort_to_interpreter(-3);
  }
#line 225
  return ((8UL << 58U) | 1UL);
}
}
#line 228 "/home/khheo/project/mit-scheme-9.2/src/microcode/hooks.c"
static SCHEME_OBJECT allocate_control_point(unsigned long n , _Bool gc_p ) 
{ 
  SCHEME_OBJECT cp ;
  SCHEME_OBJECT tmp ;

  {
  {
#line 231
  tmp = allocate_marked_vector(28U, n + 2UL, gc_p);
#line 231
  cp = tmp;
#line 233
  *((SCHEME_OBJECT *)(cp & 288230376151711743UL) + 1) = 0UL;
#line 234
  *((SCHEME_OBJECT *)(cp & 288230376151711743UL) + 2) = 39UL << 58U;
  }
#line 235
  return (cp);
}
}
#line 238 "/home/khheo/project/mit-scheme-9.2/src/microcode/hooks.c"
SCHEME_OBJECT *control_point_start(SCHEME_OBJECT cp ) 
{ 


  {
#line 241
  return ((SCHEME_OBJECT *)(cp & 288230376151711743UL) + 3);
}
}
#line 244 "/home/khheo/project/mit-scheme-9.2/src/microcode/hooks.c"
SCHEME_OBJECT *control_point_end(SCHEME_OBJECT cp ) 
{ 


  {
#line 247
  return ((SCHEME_OBJECT *)(cp & 288230376151711743UL) + ((*((SCHEME_OBJECT *)(cp & 288230376151711743UL) + 0) & 288230376151711743UL) + 1UL));
}
}
#line 250 "/home/khheo/project/mit-scheme-9.2/src/microcode/hooks.c"
void unpack_control_point(SCHEME_OBJECT cp ) 
{ 
  SCHEME_OBJECT *scan_from ;
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT *end_from ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;
  SCHEME_OBJECT *tmp___2 ;
  SCHEME_OBJECT *tmp___3 ;
  SCHEME_OBJECT *tmp___4 ;
  SCHEME_OBJECT *tmp___5 ;
  SCHEME_OBJECT *tmp___6 ;
  char *__cil_tmp12 ;

  {
  {
#line 253
  while (1) {
    while_continue: /* CIL Label */ ;
#line 253
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 259
  tmp = control_point_end(cp);
#line 259
  scan_from = tmp;
#line 260
  tmp___0 = control_point_start(cp);
#line 260
  end_from = tmp___0;
#line 262
  stack_pointer = stack_end;
  }
  {
#line 263
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 263
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 263
      set_ulong_register(12U, Registers[12] & 0xfffffffffffffffeUL);
      }
      {
#line 263
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 263
        if ((Registers[1] & Registers[12]) != 0UL) {
#line 263
          tmp___2 = memory_block_start;
        } else {
#line 263
          if ((Registers[1] & 4UL) != 0UL) {
#line 263
            tmp___1 = heap_alloc_limit;
          } else {
#line 263
            tmp___1 = heap_end;
          }
#line 263
          tmp___2 = tmp___1;
        }
        {
#line 263
        set_ptr_register(0U, tmp___2);
        }
#line 263
        if ((Registers[1] & 1UL) != 0UL) {
#line 263
          tmp___3 = stack_guard;
        } else {
#line 263
          tmp___3 = stack_start;
        }
        {
#line 263
        set_ptr_register(11U, tmp___3);
        }
#line 263
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 263
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 263
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 264
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 264
    if (! ((unsigned long )(stack_pointer + - (end_from - scan_from)) >= (unsigned long )stack_guard)) {
      {
#line 264
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 264
        if (*stack_start != ((34UL << 58U) | (SCHEME_OBJECT )stack_start)) {
          {
#line 264
          stack_death("STACK_CHECK");
          }
        }
#line 264
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 264
      while (1) {
        while_continue___5: /* CIL Label */ ;
        {
#line 264
        set_ulong_register(12U, Registers[12] | 1UL);
        }
        {
#line 264
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 264
          if ((Registers[1] & Registers[12]) != 0UL) {
#line 264
            tmp___5 = memory_block_start;
          } else {
#line 264
            if ((Registers[1] & 4UL) != 0UL) {
#line 264
              tmp___4 = heap_alloc_limit;
            } else {
#line 264
              tmp___4 = heap_end;
            }
#line 264
            tmp___5 = tmp___4;
          }
          {
#line 264
          set_ptr_register(0U, tmp___5);
          }
#line 264
          if ((Registers[1] & 1UL) != 0UL) {
#line 264
            tmp___6 = stack_guard;
          } else {
#line 264
            tmp___6 = stack_start;
          }
          {
#line 264
          set_ptr_register(11U, tmp___6);
          }
#line 264
          goto while_break___6;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 264
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
#line 264
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 266
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 266
    if (! ((unsigned long )scan_from > (unsigned long )end_from)) {
#line 266
      goto while_break___7;
    }
#line 267
    stack_pointer --;
#line 267
    scan_from --;
#line 267
    *stack_pointer = *scan_from;
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 269
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 269
    goto while_break___8;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 270
  return;
}
}
#line 272 "/home/khheo/project/mit-scheme-9.2/src/microcode/hooks.c"
SCHEME_OBJECT Prim_error_procedure(void) 
{ 
  SCHEME_OBJECT message ;
  SCHEME_OBJECT irritants ;
  SCHEME_OBJECT environment ;
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;
  char *__cil_tmp7 ;

  {
  {
#line 275
  while (1) {
    while_continue: /* CIL Label */ ;
#line 275
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 276
  canonicalize_primitive_context();
#line 278
  message = *(stack_pointer + 0);
#line 279
  irritants = *(stack_pointer + 1);
#line 280
  environment = *(stack_pointer + 2);
#line 284
  back_out_of_primitive();
  }
  {
#line 285
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 285
    if (! ((unsigned long )(stack_pointer + -9) >= (unsigned long )stack_guard)) {
      {
#line 285
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 285
        if (*stack_start != ((34UL << 58U) | (SCHEME_OBJECT )stack_start)) {
          {
#line 285
          stack_death("STACK_CHECK");
          }
        }
#line 285
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 285
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 285
        set_ulong_register(12U, Registers[12] | 1UL);
        }
        {
#line 285
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 285
          if ((Registers[1] & Registers[12]) != 0UL) {
#line 285
            tmp___0 = memory_block_start;
          } else {
#line 285
            if ((Registers[1] & 4UL) != 0UL) {
#line 285
              tmp = heap_alloc_limit;
            } else {
#line 285
              tmp = heap_end;
            }
#line 285
            tmp___0 = tmp;
          }
          {
#line 285
          set_ptr_register(0U, tmp___0);
          }
#line 285
          if ((Registers[1] & 1UL) != 0UL) {
#line 285
            tmp___1 = stack_guard;
          } else {
#line 285
            tmp___1 = stack_start;
          }
          {
#line 285
          set_ptr_register(11U, tmp___1);
          }
#line 285
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 285
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 285
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 286
  stop_history();
#line 288
  stack_pointer --;
#line 288
  *stack_pointer = environment;
#line 289
  stack_pointer --;
#line 289
  *stack_pointer = irritants;
#line 290
  stack_pointer --;
#line 290
  *stack_pointer = message;
#line 291
  stack_pointer --;
#line 291
  *stack_pointer = *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 30);
#line 292
  stack_pointer --;
#line 292
  *stack_pointer = 4UL;
#line 294
  abort_to_interpreter(-3);
  }
#line 296
  return ((8UL << 58U) | 1UL);
}
}
#line 300 "/home/khheo/project/mit-scheme-9.2/src/microcode/hooks.c"
SCHEME_OBJECT Prim_scode_eval(void) 
{ 
  SCHEME_OBJECT expression ;
  SCHEME_OBJECT environment ;

  {
  {
#line 304
  while (1) {
    while_continue: /* CIL Label */ ;
#line 304
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 305
  canonicalize_primitive_context();
  }
  {
#line 306
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 306
    if (! (*(stack_pointer + 1) >> 58U == 18UL)) {
#line 306
      if (! (*(stack_pointer + 1) == 0UL)) {
        {
#line 306
        error_wrong_type_arg(2);
        }
      }
    }
#line 306
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 308
  expression = *(stack_pointer + 0);
#line 309
  environment = *(stack_pointer + 1);
#line 310
  stack_pointer += 2;
#line 311
  Registers[3] = environment;
#line 312
  Registers[5] = expression;
#line 314
  abort_to_interpreter(-2);
  }
#line 316
  return ((8UL << 58U) | 1UL);
}
}
#line 319 "/home/khheo/project/mit-scheme-9.2/src/microcode/hooks.c"
SCHEME_OBJECT Prim_force(void) 
{ 
  SCHEME_OBJECT thunk ;
  SCHEME_OBJECT State ;
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;
  SCHEME_OBJECT *tmp___2 ;
  SCHEME_OBJECT *tmp___3 ;
  SCHEME_OBJECT *tmp___4 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 324
  while (1) {
    while_continue: /* CIL Label */ ;
#line 324
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 325
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 325
    if (! (*(stack_pointer + 0) >> 58U == 19UL)) {
      {
#line 325
      error_wrong_type_arg(1);
      }
    }
#line 325
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 327
  thunk = *(stack_pointer + 0);
#line 328
  State = *((SCHEME_OBJECT *)(thunk & 288230376151711743UL) + 0);
#line 329
  if (State == 8UL << 58U) {
#line 330
    return (*((SCHEME_OBJECT *)(thunk & 288230376151711743UL) + 1));
  } else
#line 331
  if (State == 26UL << 58U) {
    {
#line 334
    canonicalize_primitive_context();
#line 335
    stack_pointer ++;
    }
    {
#line 336
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 336
      if (! ((unsigned long )(stack_pointer + -4) >= (unsigned long )stack_guard)) {
        {
#line 336
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 336
          if (*stack_start != ((34UL << 58U) | (SCHEME_OBJECT )stack_start)) {
            {
#line 336
            stack_death("STACK_CHECK");
            }
          }
#line 336
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 336
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 336
          set_ulong_register(12U, Registers[12] | 1UL);
          }
          {
#line 336
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 336
            if ((Registers[1] & Registers[12]) != 0UL) {
#line 336
              tmp___0 = memory_block_start;
            } else {
#line 336
              if ((Registers[1] & 4UL) != 0UL) {
#line 336
                tmp = heap_alloc_limit;
              } else {
#line 336
                tmp = heap_end;
              }
#line 336
              tmp___0 = tmp;
            }
            {
#line 336
            set_ptr_register(0U, tmp___0);
            }
#line 336
            if ((Registers[1] & 1UL) != 0UL) {
#line 336
              tmp___1 = stack_guard;
            } else {
#line 336
              tmp___1 = stack_start;
            }
            {
#line 336
            set_ptr_register(11U, tmp___1);
            }
#line 336
            goto while_break___4;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 336
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 336
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 337
    Registers[6] = (11UL << 58U) | 28UL;
#line 338
    Registers[5] = thunk;
    {
#line 339
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 339
      stack_pointer --;
#line 339
      *stack_pointer = Registers[5];
#line 339
      stack_pointer --;
#line 339
      *stack_pointer = Registers[6];
#line 339
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 340
    stack_pointer --;
#line 340
    *stack_pointer = *((SCHEME_OBJECT *)(thunk & 288230376151711743UL) + 1);
#line 341
    stack_pointer --;
#line 341
    *stack_pointer = 1UL;
#line 343
    abort_to_interpreter(-3);
    }
#line 345
    return ((8UL << 58U) | 1UL);
  } else {
    {
#line 350
    canonicalize_primitive_context();
#line 351
    stack_pointer ++;
    }
    {
#line 352
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 352
      if (! ((unsigned long )(stack_pointer + -2) >= (unsigned long )stack_guard)) {
        {
#line 352
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 352
          if (*stack_start != ((34UL << 58U) | (SCHEME_OBJECT )stack_start)) {
            {
#line 352
            stack_death("STACK_CHECK");
            }
          }
#line 352
          goto while_break___7;
        }
        while_break___7: /* CIL Label */ ;
        }
        {
#line 352
        while (1) {
          while_continue___8: /* CIL Label */ ;
          {
#line 352
          set_ulong_register(12U, Registers[12] | 1UL);
          }
          {
#line 352
          while (1) {
            while_continue___9: /* CIL Label */ ;
#line 352
            if ((Registers[1] & Registers[12]) != 0UL) {
#line 352
              tmp___3 = memory_block_start;
            } else {
#line 352
              if ((Registers[1] & 4UL) != 0UL) {
#line 352
                tmp___2 = heap_alloc_limit;
              } else {
#line 352
                tmp___2 = heap_end;
              }
#line 352
              tmp___3 = tmp___2;
            }
            {
#line 352
            set_ptr_register(0U, tmp___3);
            }
#line 352
            if ((Registers[1] & 1UL) != 0UL) {
#line 352
              tmp___4 = stack_guard;
            } else {
#line 352
              tmp___4 = stack_start;
            }
            {
#line 352
            set_ptr_register(11U, tmp___4);
            }
#line 352
            goto while_break___9;
          }
          while_break___9: /* CIL Label */ ;
          }
#line 352
          goto while_break___8;
        }
        while_break___8: /* CIL Label */ ;
        }
      }
#line 352
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 353
    Registers[6] = (11UL << 58U) | 28UL;
#line 354
    Registers[5] = thunk;
    {
#line 355
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 355
      stack_pointer --;
#line 355
      *stack_pointer = Registers[5];
#line 355
      stack_pointer --;
#line 355
      *stack_pointer = Registers[6];
#line 355
      goto while_break___10;
    }
    while_break___10: /* CIL Label */ ;
    }
    {
#line 357
    Registers[3] = *((SCHEME_OBJECT *)(thunk & 288230376151711743UL) + 0);
#line 358
    Registers[5] = *((SCHEME_OBJECT *)(thunk & 288230376151711743UL) + 1);
#line 359
    abort_to_interpreter(-2);
    }
#line 361
    return ((8UL << 58U) | 1UL);
  }
}
}
#line 368 "/home/khheo/project/mit-scheme-9.2/src/microcode/hooks.c"
SCHEME_OBJECT Prim_get_interrupt_enables(void) 
{ 


  {
  {
#line 382
  while (1) {
    while_continue: /* CIL Label */ ;
#line 382
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 383
  return ((26UL << 58U) | Registers[1]);
}
}
#line 386 "/home/khheo/project/mit-scheme-9.2/src/microcode/hooks.c"
SCHEME_OBJECT Prim_set_interrupt_enables(void) 
{ 
  unsigned long previous ;
  unsigned long tmp ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;
  SCHEME_OBJECT *tmp___2 ;

  {
  {
#line 391
  while (1) {
    while_continue: /* CIL Label */ ;
#line 391
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 393
  previous = Registers[1];
  {
#line 394
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 394
    tmp = arg_ulong_integer(1);
#line 394
    set_ulong_register(1U, tmp & ((1UL << 16UL) - 1UL));
    }
    {
#line 394
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 394
      if ((Registers[1] & Registers[12]) != 0UL) {
#line 394
        tmp___1 = memory_block_start;
      } else {
#line 394
        if ((Registers[1] & 4UL) != 0UL) {
#line 394
          tmp___0 = heap_alloc_limit;
        } else {
#line 394
          tmp___0 = heap_end;
        }
#line 394
        tmp___1 = tmp___0;
      }
      {
#line 394
      set_ptr_register(0U, tmp___1);
      }
#line 394
      if ((Registers[1] & 1UL) != 0UL) {
#line 394
        tmp___2 = stack_guard;
      } else {
#line 394
        tmp___2 = stack_start;
      }
      {
#line 394
      set_ptr_register(11U, tmp___2);
      }
#line 394
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 394
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 395
  return ((26UL << 58U) | previous);
}
}
#line 399 "/home/khheo/project/mit-scheme-9.2/src/microcode/hooks.c"
SCHEME_OBJECT Prim_clear_interrupts(void) 
{ 
  unsigned long tmp ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;
  SCHEME_OBJECT *tmp___2 ;

  {
  {
#line 405
  while (1) {
    while_continue: /* CIL Label */ ;
#line 405
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 406
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 406
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 406
      tmp = arg_ulong_integer(1);
#line 406
      set_ulong_register(12U, Registers[12] & ~ (tmp & ((1UL << 16UL) - 1UL)));
      }
      {
#line 406
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 406
        if ((Registers[1] & Registers[12]) != 0UL) {
#line 406
          tmp___1 = memory_block_start;
        } else {
#line 406
          if ((Registers[1] & 4UL) != 0UL) {
#line 406
            tmp___0 = heap_alloc_limit;
          } else {
#line 406
            tmp___0 = heap_end;
          }
#line 406
          tmp___1 = tmp___0;
        }
        {
#line 406
        set_ptr_register(0U, tmp___1);
        }
#line 406
        if ((Registers[1] & 1UL) != 0UL) {
#line 406
          tmp___2 = stack_guard;
        } else {
#line 406
          tmp___2 = stack_start;
        }
        {
#line 406
        set_ptr_register(11U, tmp___2);
        }
#line 406
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 406
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 406
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 407
  return ((8UL << 58U) | 1UL);
}
}
#line 410 "/home/khheo/project/mit-scheme-9.2/src/microcode/hooks.c"
SCHEME_OBJECT Prim_disable_interrupts(void) 
{ 
  unsigned long previous ;
  unsigned long tmp ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;
  SCHEME_OBJECT *tmp___2 ;

  {
  {
#line 416
  while (1) {
    while_continue: /* CIL Label */ ;
#line 416
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 418
  previous = Registers[1];
  {
#line 419
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 419
    tmp = arg_ulong_integer(1);
#line 419
    set_ulong_register(1U, previous & ~ (tmp & ((1UL << 16UL) - 1UL)));
    }
    {
#line 419
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 419
      if ((Registers[1] & Registers[12]) != 0UL) {
#line 419
        tmp___1 = memory_block_start;
      } else {
#line 419
        if ((Registers[1] & 4UL) != 0UL) {
#line 419
          tmp___0 = heap_alloc_limit;
        } else {
#line 419
          tmp___0 = heap_end;
        }
#line 419
        tmp___1 = tmp___0;
      }
      {
#line 419
      set_ptr_register(0U, tmp___1);
      }
#line 419
      if ((Registers[1] & 1UL) != 0UL) {
#line 419
        tmp___2 = stack_guard;
      } else {
#line 419
        tmp___2 = stack_start;
      }
      {
#line 419
      set_ptr_register(11U, tmp___2);
      }
#line 419
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 419
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 420
  return ((26UL << 58U) | previous);
}
}
#line 424 "/home/khheo/project/mit-scheme-9.2/src/microcode/hooks.c"
SCHEME_OBJECT Prim_enable_interrupts(void) 
{ 
  unsigned long previous ;
  unsigned long tmp ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;
  SCHEME_OBJECT *tmp___2 ;

  {
  {
#line 430
  while (1) {
    while_continue: /* CIL Label */ ;
#line 430
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 432
  previous = Registers[1];
  {
#line 433
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 433
    tmp = arg_ulong_integer(1);
#line 433
    set_ulong_register(1U, previous | (tmp & ((1UL << 16UL) - 1UL)));
    }
    {
#line 433
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 433
      if ((Registers[1] & Registers[12]) != 0UL) {
#line 433
        tmp___1 = memory_block_start;
      } else {
#line 433
        if ((Registers[1] & 4UL) != 0UL) {
#line 433
          tmp___0 = heap_alloc_limit;
        } else {
#line 433
          tmp___0 = heap_end;
        }
#line 433
        tmp___1 = tmp___0;
      }
      {
#line 433
      set_ptr_register(0U, tmp___1);
      }
#line 433
      if ((Registers[1] & 1UL) != 0UL) {
#line 433
        tmp___2 = stack_guard;
      } else {
#line 433
        tmp___2 = stack_start;
      }
      {
#line 433
      set_ptr_register(11U, tmp___2);
      }
#line 433
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 433
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 434
  return ((26UL << 58U) | previous);
}
}
#line 438 "/home/khheo/project/mit-scheme-9.2/src/microcode/hooks.c"
SCHEME_OBJECT Prim_request_interrupts(void) 
{ 
  unsigned long tmp ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;
  SCHEME_OBJECT *tmp___2 ;

  {
  {
#line 444
  while (1) {
    while_continue: /* CIL Label */ ;
#line 444
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 445
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 445
    tmp = arg_ulong_integer(1);
#line 445
    set_ulong_register(12U, Registers[12] | (tmp & ((1UL << 16UL) - 1UL)));
    }
    {
#line 445
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 445
      if ((Registers[1] & Registers[12]) != 0UL) {
#line 445
        tmp___1 = memory_block_start;
      } else {
#line 445
        if ((Registers[1] & 4UL) != 0UL) {
#line 445
          tmp___0 = heap_alloc_limit;
        } else {
#line 445
          tmp___0 = heap_end;
        }
#line 445
        tmp___1 = tmp___0;
      }
      {
#line 445
      set_ptr_register(0U, tmp___1);
      }
#line 445
      if ((Registers[1] & 1UL) != 0UL) {
#line 445
        tmp___2 = stack_guard;
      } else {
#line 445
        tmp___2 = stack_start;
      }
      {
#line 445
      set_ptr_register(11U, tmp___2);
      }
#line 445
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 445
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 446
  return ((8UL << 58U) | 1UL);
}
}
#line 449 "/home/khheo/project/mit-scheme-9.2/src/microcode/hooks.c"
SCHEME_OBJECT Prim_return_to_application(void) 
{ 
  unsigned long nargs ;
  SCHEME_OBJECT thunk ;
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;
  SCHEME_OBJECT *tmp___2 ;
  char *__cil_tmp7 ;

  {
  {
#line 457
  while (1) {
    while_continue: /* CIL Label */ ;
#line 457
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 458
  canonicalize_primitive_context();
#line 460
  nargs = Registers[7];
  }
#line 461
  if (nargs < 2UL) {
    {
#line 462
    signal_error_from_primitive(12L);
    }
  }
#line 464
  tmp = stack_pointer;
#line 464
  stack_pointer ++;
#line 464
  thunk = *tmp;
#line 465
  stack_pointer --;
#line 465
  *stack_pointer = (nargs - 2UL) + 1UL;
#line 466
  Registers[3] = 1UL;
#line 467
  Registers[5] = 0UL;
#line 468
  Registers[6] = (11UL << 58U) | 3UL;
  {
#line 469
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 469
    stack_pointer --;
#line 469
    *stack_pointer = Registers[5];
#line 469
    stack_pointer --;
#line 469
    *stack_pointer = Registers[6];
#line 469
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 470
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 470
    if (! ((unsigned long )(stack_pointer + -2) >= (unsigned long )stack_guard)) {
      {
#line 470
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 470
        if (*stack_start != ((34UL << 58U) | (SCHEME_OBJECT )stack_start)) {
          {
#line 470
          stack_death("STACK_CHECK");
          }
        }
#line 470
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 470
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 470
        set_ulong_register(12U, Registers[12] | 1UL);
        }
        {
#line 470
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 470
          if ((Registers[1] & Registers[12]) != 0UL) {
#line 470
            tmp___1 = memory_block_start;
          } else {
#line 470
            if ((Registers[1] & 4UL) != 0UL) {
#line 470
              tmp___0 = heap_alloc_limit;
            } else {
#line 470
              tmp___0 = heap_end;
            }
#line 470
            tmp___1 = tmp___0;
          }
          {
#line 470
          set_ptr_register(0U, tmp___1);
          }
#line 470
          if ((Registers[1] & 1UL) != 0UL) {
#line 470
            tmp___2 = stack_guard;
          } else {
#line 470
            tmp___2 = stack_start;
          }
          {
#line 470
          set_ptr_register(11U, tmp___2);
          }
#line 470
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 470
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 470
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 471
  stack_pointer --;
#line 471
  *stack_pointer = thunk;
#line 472
  stack_pointer --;
#line 472
  *stack_pointer = 1UL;
#line 476
  abort_to_interpreter(-3);
  }
#line 478
  return ((8UL << 58U) | 1UL);
}
}
#line 481 "/home/khheo/project/mit-scheme-9.2/src/microcode/hooks.c"
SCHEME_OBJECT Prim_with_stack_marker(void) 
{ 
  SCHEME_OBJECT thunk ;
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;
  SCHEME_OBJECT *tmp___2 ;
  SCHEME_OBJECT *tmp___3 ;
  char *__cil_tmp7 ;

  {
  {
#line 490
  while (1) {
    while_continue: /* CIL Label */ ;
#line 490
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 492
  thunk = *(stack_pointer + 0);
#line 494
  if (*(stack_pointer + 3) >> 58U == 40UL) {
#line 494
    if (thunk >> 58U == 40UL) {
      {
#line 496
      tmp = stack_pointer;
#line 496
      stack_pointer ++;
#line 497
      compiled_with_stack_marker(thunk);
#line 498
      stack_pointer += -3;
      }
    } else {
#line 494
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 503
    canonicalize_primitive_context();
#line 504
    tmp___0 = stack_pointer;
#line 504
    stack_pointer ++;
#line 505
    stack_pointer --;
#line 505
    *stack_pointer = (11UL << 58U) | 66UL;
    }
    {
#line 506
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 506
      if (! ((unsigned long )(stack_pointer + -2) >= (unsigned long )stack_guard)) {
        {
#line 506
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 506
          if (*stack_start != ((34UL << 58U) | (SCHEME_OBJECT )stack_start)) {
            {
#line 506
            stack_death("STACK_CHECK");
            }
          }
#line 506
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 506
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
#line 506
          set_ulong_register(12U, Registers[12] | 1UL);
          }
          {
#line 506
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 506
            if ((Registers[1] & Registers[12]) != 0UL) {
#line 506
              tmp___2 = memory_block_start;
            } else {
#line 506
              if ((Registers[1] & 4UL) != 0UL) {
#line 506
                tmp___1 = heap_alloc_limit;
              } else {
#line 506
                tmp___1 = heap_end;
              }
#line 506
              tmp___2 = tmp___1;
            }
            {
#line 506
            set_ptr_register(0U, tmp___2);
            }
#line 506
            if ((Registers[1] & 1UL) != 0UL) {
#line 506
              tmp___3 = stack_guard;
            } else {
#line 506
              tmp___3 = stack_start;
            }
            {
#line 506
            set_ptr_register(11U, tmp___3);
            }
#line 506
            goto while_break___3;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 506
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
#line 506
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 507
    stack_pointer --;
#line 507
    *stack_pointer = thunk;
#line 508
    stack_pointer --;
#line 508
    *stack_pointer = 1UL;
#line 510
    abort_to_interpreter(-3);
    }
  }
#line 514
  return ((8UL << 58U) | 1UL);
}
}
#line 517 "/home/khheo/project/mit-scheme-9.2/src/microcode/hooks.c"
SCHEME_OBJECT Prim_with_interrupt_mask(void) 
{ 
  long tmp ;

  {
  {
#line 522
  while (1) {
    while_continue: /* CIL Label */ ;
#line 522
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 523
  tmp = arg_integer(1);
#line 523
  with_new_interrupt_mask(((1UL << 16UL) - 1UL) & (unsigned long )tmp);
  }
#line 524
  return ((8UL << 58U) | 1UL);
}
}
#line 527 "/home/khheo/project/mit-scheme-9.2/src/microcode/hooks.c"
SCHEME_OBJECT Prim_with_interrupts_reduced(void) 
{ 
  unsigned long old_mask ;
  unsigned long new_mask ;
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
  {
#line 532
  while (1) {
    while_continue: /* CIL Label */ ;
#line 532
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 534
  old_mask = Registers[1];
#line 535
  tmp = arg_ulong_integer(1);
#line 535
  new_mask = ((1UL << 16UL) - 1UL) & tmp;
  }
#line 536
  if (new_mask > old_mask) {
#line 536
    tmp___0 = new_mask;
  } else {
#line 536
    tmp___0 = new_mask & old_mask;
  }
  {
#line 536
  with_new_interrupt_mask(tmp___0);
  }
#line 538
  return ((8UL << 58U) | 1UL);
}
}
#line 541 "/home/khheo/project/mit-scheme-9.2/src/microcode/hooks.c"
static void with_new_interrupt_mask(unsigned long new_mask ) 
{ 
  SCHEME_OBJECT receiver ;
  unsigned long current_mask ;
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;
  SCHEME_OBJECT *tmp___2 ;
  SCHEME_OBJECT *tmp___3 ;
  SCHEME_OBJECT *tmp___4 ;
  SCHEME_OBJECT *tmp___5 ;
  SCHEME_OBJECT *tmp___6 ;
  SCHEME_OBJECT *tmp___7 ;
  char *__cil_tmp13 ;

  {
#line 544
  receiver = *(stack_pointer + 1);
#line 547
  if (*(stack_pointer + 2) >> 58U == 40UL) {
#line 547
    if (receiver >> 58U == 40UL) {
      {
#line 549
      current_mask = Registers[1];
#line 550
      stack_pointer += 2;
#line 551
      compiled_with_interrupt_mask(current_mask, receiver, new_mask);
#line 552
      stack_pointer += -2;
      }
      {
#line 553
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 553
        set_ulong_register(1U, new_mask);
        }
        {
#line 553
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 553
          if ((Registers[1] & Registers[12]) != 0UL) {
#line 553
            tmp___0 = memory_block_start;
          } else {
#line 553
            if ((Registers[1] & 4UL) != 0UL) {
#line 553
              tmp = heap_alloc_limit;
            } else {
#line 553
              tmp = heap_end;
            }
#line 553
            tmp___0 = tmp;
          }
          {
#line 553
          set_ptr_register(0U, tmp___0);
          }
#line 553
          if ((Registers[1] & 1UL) != 0UL) {
#line 553
            tmp___1 = stack_guard;
          } else {
#line 553
            tmp___1 = stack_start;
          }
          {
#line 553
          set_ptr_register(11U, tmp___1);
          }
#line 553
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 553
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 547
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 558
    canonicalize_primitive_context();
#line 559
    stack_pointer += 2;
#line 560
    preserve_interrupt_mask();
    }
    {
#line 561
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 561
      if (! ((unsigned long )(stack_pointer + -3) >= (unsigned long )stack_guard)) {
        {
#line 561
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 561
          if (*stack_start != ((34UL << 58U) | (SCHEME_OBJECT )stack_start)) {
            {
#line 561
            stack_death("STACK_CHECK");
            }
          }
#line 561
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 561
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 561
          set_ulong_register(12U, Registers[12] | 1UL);
          }
          {
#line 561
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 561
            if ((Registers[1] & Registers[12]) != 0UL) {
#line 561
              tmp___3 = memory_block_start;
            } else {
#line 561
              if ((Registers[1] & 4UL) != 0UL) {
#line 561
                tmp___2 = heap_alloc_limit;
              } else {
#line 561
                tmp___2 = heap_end;
              }
#line 561
              tmp___3 = tmp___2;
            }
            {
#line 561
            set_ptr_register(0U, tmp___3);
            }
#line 561
            if ((Registers[1] & 1UL) != 0UL) {
#line 561
              tmp___4 = stack_guard;
            } else {
#line 561
              tmp___4 = stack_start;
            }
            {
#line 561
            set_ptr_register(11U, tmp___4);
            }
#line 561
            goto while_break___4;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 561
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 561
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 562
    stack_pointer --;
#line 562
    *stack_pointer = (26UL << 58U) | Registers[1];
#line 563
    stack_pointer --;
#line 563
    *stack_pointer = receiver;
#line 564
    stack_pointer --;
#line 564
    *stack_pointer = 2UL;
    {
#line 566
    while (1) {
      while_continue___5: /* CIL Label */ ;
      {
#line 566
      set_ulong_register(1U, new_mask);
      }
      {
#line 566
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 566
        if ((Registers[1] & Registers[12]) != 0UL) {
#line 566
          tmp___6 = memory_block_start;
        } else {
#line 566
          if ((Registers[1] & 4UL) != 0UL) {
#line 566
            tmp___5 = heap_alloc_limit;
          } else {
#line 566
            tmp___5 = heap_end;
          }
#line 566
          tmp___6 = tmp___5;
        }
        {
#line 566
        set_ptr_register(0U, tmp___6);
        }
#line 566
        if ((Registers[1] & 1UL) != 0UL) {
#line 566
          tmp___7 = stack_guard;
        } else {
#line 566
          tmp___7 = stack_start;
        }
        {
#line 566
        set_ptr_register(11U, tmp___7);
        }
#line 566
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 566
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 567
    abort_to_interpreter(-3);
    }
  }
#line 569
  return;
}
}
#line 573 "/home/khheo/project/mit-scheme-9.2/src/microcode/hooks.c"
SCHEME_OBJECT initialize_history(void) 
{ 
  SCHEME_OBJECT *tmp ;

  {
  {
#line 577
  history_register = make_dummy_history();
#line 578
  tmp = make_dummy_history();
  }
#line 578
  return ((32UL << 58U) | (SCHEME_OBJECT )tmp);
}
}
#line 582 "/home/khheo/project/mit-scheme-9.2/src/microcode/hooks.c"
SCHEME_OBJECT Prim_set_current_history(void) 
{ 


  {
  {
#line 586
  while (1) {
    while_continue: /* CIL Label */ ;
#line 586
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 587
  canonicalize_primitive_context();
  }
  {
#line 588
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 588
    if (! (*(stack_pointer + 0) >> 58U == 32UL)) {
#line 588
      if (! (*(stack_pointer + 0) >> 58U == 36UL)) {
        {
#line 588
        error_wrong_type_arg(1);
        }
      }
    }
#line 588
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 589
  Registers[2] = *history_register;
#line 591
  history_register = (SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL);
#line 595
  stack_pointer ++;
#line 596
  abort_to_interpreter(-7);
  }
#line 598
  return ((8UL << 58U) | 1UL);
}
}
#line 601 "/home/khheo/project/mit-scheme-9.2/src/microcode/hooks.c"
SCHEME_OBJECT Prim_with_history_disabled(void) 
{ 
  SCHEME_OBJECT thunk ;
  SCHEME_OBJECT *first_rib ;
  SCHEME_OBJECT *second_rib ;
  SCHEME_OBJECT *rib ;
  SCHEME_OBJECT *next_rib ;
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;
  char *__cil_tmp9 ;

  {
  {
#line 604
  while (1) {
    while_continue: /* CIL Label */ ;
#line 604
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 605
  canonicalize_primitive_context();
#line 607
  thunk = *(stack_pointer + 0);
#line 609
  first_rib = (SCHEME_OBJECT *)(*(history_register + 0) & 288230376151711743UL);
#line 610
  second_rib = (SCHEME_OBJECT *)(*(first_rib + 2) & 288230376151711743UL);
  }
#line 612
  if ((unsigned long )first_rib != (unsigned long )second_rib) {
#line 612
    if (! ((*(first_rib + 2) & (4UL << 58U)) != 0UL)) {
#line 615
      *(second_rib + 2) |= 4UL << 58U;
#line 617
      rib = first_rib;
      {
#line 618
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 620
        next_rib = (SCHEME_OBJECT *)(*(rib + 2) & 288230376151711743UL);
#line 622
        if ((unsigned long )next_rib == (unsigned long )first_rib) {
#line 623
          goto while_break___0;
        }
#line 624
        rib = next_rib;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 627
      *(history_register + 0) = ((*(history_register + 0) >> 58U) << 58U) | (SCHEME_OBJECT )rib;
    }
  }
  {
#line 632
  stack_pointer ++;
#line 633
  stop_history();
  }
  {
#line 634
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 634
    if (! ((unsigned long )(stack_pointer + -2) >= (unsigned long )stack_guard)) {
      {
#line 634
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 634
        if (*stack_start != ((34UL << 58U) | (SCHEME_OBJECT )stack_start)) {
          {
#line 634
          stack_death("STACK_CHECK");
          }
        }
#line 634
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 634
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 634
        set_ulong_register(12U, Registers[12] | 1UL);
        }
        {
#line 634
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 634
          if ((Registers[1] & Registers[12]) != 0UL) {
#line 634
            tmp___0 = memory_block_start;
          } else {
#line 634
            if ((Registers[1] & 4UL) != 0UL) {
#line 634
              tmp = heap_alloc_limit;
            } else {
#line 634
              tmp = heap_end;
            }
#line 634
            tmp___0 = tmp;
          }
          {
#line 634
          set_ptr_register(0U, tmp___0);
          }
#line 634
          if ((Registers[1] & 1UL) != 0UL) {
#line 634
            tmp___1 = stack_guard;
          } else {
#line 634
            tmp___1 = stack_start;
          }
          {
#line 634
          set_ptr_register(11U, tmp___1);
          }
#line 634
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 634
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 634
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 635
  stack_pointer --;
#line 635
  *stack_pointer = thunk;
#line 636
  stack_pointer --;
#line 636
  *stack_pointer = 1UL;
#line 638
  abort_to_interpreter(-3);
  }
#line 640
  return ((8UL << 58U) | 1UL);
}
}
#line 644 "/home/khheo/project/mit-scheme-9.2/src/microcode/hooks.c"
SCHEME_OBJECT Prim_get_fixed_objects_vector(void) 
{ 


  {
  {
#line 649
  while (1) {
    while_continue: /* CIL Label */ ;
#line 649
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 650
  return (fixed_objects);
}
}
#line 653 "/home/khheo/project/mit-scheme-9.2/src/microcode/hooks.c"
SCHEME_OBJECT Prim_set_fixed_objects_vector(void) 
{ 
  SCHEME_OBJECT old ;
  SCHEME_OBJECT new ;

  {
  {
#line 658
  while (1) {
    while_continue: /* CIL Label */ ;
#line 658
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 659
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 659
    if (! (*(stack_pointer + 0) >> 58U == 10UL)) {
      {
#line 659
      error_wrong_type_arg(1);
      }
    }
#line 659
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 661
  old = fixed_objects;
#line 662
  new = *(stack_pointer + 0);
#line 663
  if ((*((SCHEME_OBJECT *)(new & 288230376151711743UL) + 0) & 288230376151711743UL) < 69UL) {
    {
#line 664
    error_bad_range_arg(1);
    }
  }
#line 665
  fixed_objects = new;
#line 666
  return (old);
}
}
#line 53 "/home/khheo/project/mit-scheme-9.2/src/microcode/generic.c"
SCHEME_OBJECT Prim_zero(void) 
{ 
  SCHEME_OBJECT x ;
  unsigned long tmp ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;
  SCHEME_OBJECT *tmp___2 ;
  char *__cil_tmp6 ;

  {
  {
#line 54
  while (1) {
    while_continue: /* CIL Label */ ;
#line 54
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 54
  x = *(stack_pointer + 0);
#line 54
  if (x >> 58U == 26UL) {
#line 54
    if ((x & 288230376151711743UL) == 0UL) {
#line 54
      tmp = 8UL << 58U;
    } else {
#line 54
      tmp = 0UL;
    }
#line 54
    return (tmp);
  }
  {
#line 54
  canonicalize_primitive_context();
  }
  {
#line 54
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 54
    if (! ((unsigned long )(stack_pointer + -2) >= (unsigned long )stack_guard)) {
      {
#line 54
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 54
        if (*stack_start != ((34UL << 58U) | (SCHEME_OBJECT )stack_start)) {
          {
#line 54
          stack_death("STACK_CHECK");
          }
        }
#line 54
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 54
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 54
        set_ulong_register(12U, Registers[12] | 1UL);
        }
        {
#line 54
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 54
          if ((Registers[1] & Registers[12]) != 0UL) {
#line 54
            tmp___1 = memory_block_start;
          } else {
#line 54
            if ((Registers[1] & 4UL) != 0UL) {
#line 54
              tmp___0 = heap_alloc_limit;
            } else {
#line 54
              tmp___0 = heap_end;
            }
#line 54
            tmp___1 = tmp___0;
          }
          {
#line 54
          set_ptr_register(0U, tmp___1);
          }
#line 54
          if ((Registers[1] & 1UL) != 0UL) {
#line 54
            tmp___2 = stack_guard;
          } else {
#line 54
            tmp___2 = stack_start;
          }
          {
#line 54
          set_ptr_register(11U, tmp___2);
          }
#line 54
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 54
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 54
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 54
  stack_pointer --;
#line 54
  *stack_pointer = *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 37);
#line 54
  stack_pointer --;
#line 54
  *stack_pointer = 2UL;
#line 54
  abort_to_interpreter(-3);
  }
#line 54
  return ((8UL << 58U) | 1UL);
}
}
#line 55 "/home/khheo/project/mit-scheme-9.2/src/microcode/generic.c"
SCHEME_OBJECT Prim_positive(void) 
{ 
  SCHEME_OBJECT x ;
  unsigned long tmp ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;
  SCHEME_OBJECT *tmp___2 ;
  char *__cil_tmp6 ;

  {
  {
#line 56
  while (1) {
    while_continue: /* CIL Label */ ;
#line 56
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 56
  x = *(stack_pointer + 0);
#line 56
  if (x >> 58U == 26UL) {
#line 56
    if ((x & 288230376151711743UL) == 0UL) {
#line 56
      tmp = 0UL;
    } else
#line 56
    if ((x & 144115188075855872UL) != 0UL) {
#line 56
      tmp = 0UL;
    } else {
#line 56
      tmp = 8UL << 58U;
    }
#line 56
    return (tmp);
  }
  {
#line 56
  canonicalize_primitive_context();
  }
  {
#line 56
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 56
    if (! ((unsigned long )(stack_pointer + -2) >= (unsigned long )stack_guard)) {
      {
#line 56
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 56
        if (*stack_start != ((34UL << 58U) | (SCHEME_OBJECT )stack_start)) {
          {
#line 56
          stack_death("STACK_CHECK");
          }
        }
#line 56
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 56
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 56
        set_ulong_register(12U, Registers[12] | 1UL);
        }
        {
#line 56
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 56
          if ((Registers[1] & Registers[12]) != 0UL) {
#line 56
            tmp___1 = memory_block_start;
          } else {
#line 56
            if ((Registers[1] & 4UL) != 0UL) {
#line 56
              tmp___0 = heap_alloc_limit;
            } else {
#line 56
              tmp___0 = heap_end;
            }
#line 56
            tmp___1 = tmp___0;
          }
          {
#line 56
          set_ptr_register(0U, tmp___1);
          }
#line 56
          if ((Registers[1] & 1UL) != 0UL) {
#line 56
            tmp___2 = stack_guard;
          } else {
#line 56
            tmp___2 = stack_start;
          }
          {
#line 56
          set_ptr_register(11U, tmp___2);
          }
#line 56
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 56
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 56
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 56
  stack_pointer --;
#line 56
  *stack_pointer = *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 38);
#line 56
  stack_pointer --;
#line 56
  *stack_pointer = 2UL;
#line 56
  abort_to_interpreter(-3);
  }
#line 56
  return ((8UL << 58U) | 1UL);
}
}
#line 57 "/home/khheo/project/mit-scheme-9.2/src/microcode/generic.c"
SCHEME_OBJECT Prim_negative(void) 
{ 
  SCHEME_OBJECT x ;
  unsigned long tmp ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;
  SCHEME_OBJECT *tmp___2 ;
  char *__cil_tmp6 ;

  {
  {
#line 58
  while (1) {
    while_continue: /* CIL Label */ ;
#line 58
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 58
  x = *(stack_pointer + 0);
#line 58
  if (x >> 58U == 26UL) {
#line 58
    if ((x & 144115188075855872UL) != 0UL) {
#line 58
      tmp = 8UL << 58U;
    } else {
#line 58
      tmp = 0UL;
    }
#line 58
    return (tmp);
  }
  {
#line 58
  canonicalize_primitive_context();
  }
  {
#line 58
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 58
    if (! ((unsigned long )(stack_pointer + -2) >= (unsigned long )stack_guard)) {
      {
#line 58
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 58
        if (*stack_start != ((34UL << 58U) | (SCHEME_OBJECT )stack_start)) {
          {
#line 58
          stack_death("STACK_CHECK");
          }
        }
#line 58
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 58
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 58
        set_ulong_register(12U, Registers[12] | 1UL);
        }
        {
#line 58
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 58
          if ((Registers[1] & Registers[12]) != 0UL) {
#line 58
            tmp___1 = memory_block_start;
          } else {
#line 58
            if ((Registers[1] & 4UL) != 0UL) {
#line 58
              tmp___0 = heap_alloc_limit;
            } else {
#line 58
              tmp___0 = heap_end;
            }
#line 58
            tmp___1 = tmp___0;
          }
          {
#line 58
          set_ptr_register(0U, tmp___1);
          }
#line 58
          if ((Registers[1] & 1UL) != 0UL) {
#line 58
            tmp___2 = stack_guard;
          } else {
#line 58
            tmp___2 = stack_start;
          }
          {
#line 58
          set_ptr_register(11U, tmp___2);
          }
#line 58
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 58
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 58
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 58
  stack_pointer --;
#line 58
  *stack_pointer = *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 39);
#line 58
  stack_pointer --;
#line 58
  *stack_pointer = 2UL;
#line 58
  abort_to_interpreter(-3);
  }
#line 58
  return ((8UL << 58U) | 1UL);
}
}
#line 71 "/home/khheo/project/mit-scheme-9.2/src/microcode/generic.c"
SCHEME_OBJECT Prim_add_one(void) 
{ 
  SCHEME_OBJECT x ;
  SCHEME_OBJECT tmp ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;
  SCHEME_OBJECT *tmp___2 ;
  char *__cil_tmp6 ;

  {
  {
#line 72
  while (1) {
    while_continue: /* CIL Label */ ;
#line 72
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 72
  x = *(stack_pointer + 0);
#line 72
  if (x >> 58U == 26UL) {
    {
#line 72
    tmp = long_to_integer((long )((x ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL)) + 1L);
    }
#line 72
    return (tmp);
  }
  {
#line 72
  canonicalize_primitive_context();
  }
  {
#line 72
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 72
    if (! ((unsigned long )(stack_pointer + -2) >= (unsigned long )stack_guard)) {
      {
#line 72
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 72
        if (*stack_start != ((34UL << 58U) | (SCHEME_OBJECT )stack_start)) {
          {
#line 72
          stack_death("STACK_CHECK");
          }
        }
#line 72
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 72
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 72
        set_ulong_register(12U, Registers[12] | 1UL);
        }
        {
#line 72
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 72
          if ((Registers[1] & Registers[12]) != 0UL) {
#line 72
            tmp___1 = memory_block_start;
          } else {
#line 72
            if ((Registers[1] & 4UL) != 0UL) {
#line 72
              tmp___0 = heap_alloc_limit;
            } else {
#line 72
              tmp___0 = heap_end;
            }
#line 72
            tmp___1 = tmp___0;
          }
          {
#line 72
          set_ptr_register(0U, tmp___1);
          }
#line 72
          if ((Registers[1] & 1UL) != 0UL) {
#line 72
            tmp___2 = stack_guard;
          } else {
#line 72
            tmp___2 = stack_start;
          }
          {
#line 72
          set_ptr_register(11U, tmp___2);
          }
#line 72
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 72
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 72
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 72
  stack_pointer --;
#line 72
  *stack_pointer = *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 40);
#line 72
  stack_pointer --;
#line 72
  *stack_pointer = 2UL;
#line 72
  abort_to_interpreter(-3);
  }
#line 72
  return ((8UL << 58U) | 1UL);
}
}
#line 73 "/home/khheo/project/mit-scheme-9.2/src/microcode/generic.c"
SCHEME_OBJECT Prim_subtract_one(void) 
{ 
  SCHEME_OBJECT x ;
  SCHEME_OBJECT tmp ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;
  SCHEME_OBJECT *tmp___2 ;
  char *__cil_tmp6 ;

  {
  {
#line 74
  while (1) {
    while_continue: /* CIL Label */ ;
#line 74
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 74
  x = *(stack_pointer + 0);
#line 74
  if (x >> 58U == 26UL) {
    {
#line 74
    tmp = long_to_integer((long )((x ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL)) - 1L);
    }
#line 74
    return (tmp);
  }
  {
#line 74
  canonicalize_primitive_context();
  }
  {
#line 74
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 74
    if (! ((unsigned long )(stack_pointer + -2) >= (unsigned long )stack_guard)) {
      {
#line 74
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 74
        if (*stack_start != ((34UL << 58U) | (SCHEME_OBJECT )stack_start)) {
          {
#line 74
          stack_death("STACK_CHECK");
          }
        }
#line 74
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 74
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 74
        set_ulong_register(12U, Registers[12] | 1UL);
        }
        {
#line 74
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 74
          if ((Registers[1] & Registers[12]) != 0UL) {
#line 74
            tmp___1 = memory_block_start;
          } else {
#line 74
            if ((Registers[1] & 4UL) != 0UL) {
#line 74
              tmp___0 = heap_alloc_limit;
            } else {
#line 74
              tmp___0 = heap_end;
            }
#line 74
            tmp___1 = tmp___0;
          }
          {
#line 74
          set_ptr_register(0U, tmp___1);
          }
#line 74
          if ((Registers[1] & 1UL) != 0UL) {
#line 74
            tmp___2 = stack_guard;
          } else {
#line 74
            tmp___2 = stack_start;
          }
          {
#line 74
          set_ptr_register(11U, tmp___2);
          }
#line 74
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 74
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 74
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 74
  stack_pointer --;
#line 74
  *stack_pointer = *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 41);
#line 74
  stack_pointer --;
#line 74
  *stack_pointer = 2UL;
#line 74
  abort_to_interpreter(-3);
  }
#line 74
  return ((8UL << 58U) | 1UL);
}
}
#line 90 "/home/khheo/project/mit-scheme-9.2/src/microcode/generic.c"
SCHEME_OBJECT Prim_equal_number(void) 
{ 
  SCHEME_OBJECT x ;
  SCHEME_OBJECT y ;
  unsigned long tmp ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;
  SCHEME_OBJECT *tmp___2 ;
  char *__cil_tmp7 ;

  {
  {
#line 91
  while (1) {
    while_continue: /* CIL Label */ ;
#line 91
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 91
  x = *(stack_pointer + 0);
#line 91
  y = *(stack_pointer + 1);
#line 91
  if (x >> 58U == 26UL) {
#line 91
    if (y >> 58U == 26UL) {
#line 91
      if ((x & 288230376151711743UL) == (y & 288230376151711743UL)) {
#line 91
        tmp = 8UL << 58U;
      } else {
#line 91
        tmp = 0UL;
      }
#line 91
      return (tmp);
    }
  }
  {
#line 91
  canonicalize_primitive_context();
  }
  {
#line 91
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 91
    if (! ((unsigned long )(stack_pointer + -2) >= (unsigned long )stack_guard)) {
      {
#line 91
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 91
        if (*stack_start != ((34UL << 58U) | (SCHEME_OBJECT )stack_start)) {
          {
#line 91
          stack_death("STACK_CHECK");
          }
        }
#line 91
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 91
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 91
        set_ulong_register(12U, Registers[12] | 1UL);
        }
        {
#line 91
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 91
          if ((Registers[1] & Registers[12]) != 0UL) {
#line 91
            tmp___1 = memory_block_start;
          } else {
#line 91
            if ((Registers[1] & 4UL) != 0UL) {
#line 91
              tmp___0 = heap_alloc_limit;
            } else {
#line 91
              tmp___0 = heap_end;
            }
#line 91
            tmp___1 = tmp___0;
          }
          {
#line 91
          set_ptr_register(0U, tmp___1);
          }
#line 91
          if ((Registers[1] & 1UL) != 0UL) {
#line 91
            tmp___2 = stack_guard;
          } else {
#line 91
            tmp___2 = stack_start;
          }
          {
#line 91
          set_ptr_register(11U, tmp___2);
          }
#line 91
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 91
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 91
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 91
  stack_pointer --;
#line 91
  *stack_pointer = *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 42);
#line 91
  stack_pointer --;
#line 91
  *stack_pointer = 3UL;
#line 91
  abort_to_interpreter(-3);
  }
#line 91
  return ((8UL << 58U) | 1UL);
}
}
#line 92 "/home/khheo/project/mit-scheme-9.2/src/microcode/generic.c"
SCHEME_OBJECT Prim_less(void) 
{ 
  SCHEME_OBJECT x ;
  SCHEME_OBJECT y ;
  unsigned long tmp ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;
  SCHEME_OBJECT *tmp___2 ;
  char *__cil_tmp7 ;

  {
  {
#line 93
  while (1) {
    while_continue: /* CIL Label */ ;
#line 93
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 93
  x = *(stack_pointer + 0);
#line 93
  y = *(stack_pointer + 1);
#line 93
  if (x >> 58U == 26UL) {
#line 93
    if (y >> 58U == 26UL) {
#line 93
      if ((long )((x ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL)) < (long )((y ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL))) {
#line 93
        tmp = 8UL << 58U;
      } else {
#line 93
        tmp = 0UL;
      }
#line 93
      return (tmp);
    }
  }
  {
#line 93
  canonicalize_primitive_context();
  }
  {
#line 93
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 93
    if (! ((unsigned long )(stack_pointer + -2) >= (unsigned long )stack_guard)) {
      {
#line 93
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 93
        if (*stack_start != ((34UL << 58U) | (SCHEME_OBJECT )stack_start)) {
          {
#line 93
          stack_death("STACK_CHECK");
          }
        }
#line 93
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 93
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 93
        set_ulong_register(12U, Registers[12] | 1UL);
        }
        {
#line 93
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 93
          if ((Registers[1] & Registers[12]) != 0UL) {
#line 93
            tmp___1 = memory_block_start;
          } else {
#line 93
            if ((Registers[1] & 4UL) != 0UL) {
#line 93
              tmp___0 = heap_alloc_limit;
            } else {
#line 93
              tmp___0 = heap_end;
            }
#line 93
            tmp___1 = tmp___0;
          }
          {
#line 93
          set_ptr_register(0U, tmp___1);
          }
#line 93
          if ((Registers[1] & 1UL) != 0UL) {
#line 93
            tmp___2 = stack_guard;
          } else {
#line 93
            tmp___2 = stack_start;
          }
          {
#line 93
          set_ptr_register(11U, tmp___2);
          }
#line 93
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 93
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 93
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 93
  stack_pointer --;
#line 93
  *stack_pointer = *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 43);
#line 93
  stack_pointer --;
#line 93
  *stack_pointer = 3UL;
#line 93
  abort_to_interpreter(-3);
  }
#line 93
  return ((8UL << 58U) | 1UL);
}
}
#line 94 "/home/khheo/project/mit-scheme-9.2/src/microcode/generic.c"
SCHEME_OBJECT Prim_greater(void) 
{ 
  SCHEME_OBJECT x ;
  SCHEME_OBJECT y ;
  unsigned long tmp ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;
  SCHEME_OBJECT *tmp___2 ;
  char *__cil_tmp7 ;

  {
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;
#line 95
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 95
  x = *(stack_pointer + 0);
#line 95
  y = *(stack_pointer + 1);
#line 95
  if (x >> 58U == 26UL) {
#line 95
    if (y >> 58U == 26UL) {
#line 95
      if ((long )((y ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL)) < (long )((x ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL))) {
#line 95
        tmp = 8UL << 58U;
      } else {
#line 95
        tmp = 0UL;
      }
#line 95
      return (tmp);
    }
  }
  {
#line 95
  canonicalize_primitive_context();
  }
  {
#line 95
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 95
    if (! ((unsigned long )(stack_pointer + -2) >= (unsigned long )stack_guard)) {
      {
#line 95
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 95
        if (*stack_start != ((34UL << 58U) | (SCHEME_OBJECT )stack_start)) {
          {
#line 95
          stack_death("STACK_CHECK");
          }
        }
#line 95
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 95
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 95
        set_ulong_register(12U, Registers[12] | 1UL);
        }
        {
#line 95
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 95
          if ((Registers[1] & Registers[12]) != 0UL) {
#line 95
            tmp___1 = memory_block_start;
          } else {
#line 95
            if ((Registers[1] & 4UL) != 0UL) {
#line 95
              tmp___0 = heap_alloc_limit;
            } else {
#line 95
              tmp___0 = heap_end;
            }
#line 95
            tmp___1 = tmp___0;
          }
          {
#line 95
          set_ptr_register(0U, tmp___1);
          }
#line 95
          if ((Registers[1] & 1UL) != 0UL) {
#line 95
            tmp___2 = stack_guard;
          } else {
#line 95
            tmp___2 = stack_start;
          }
          {
#line 95
          set_ptr_register(11U, tmp___2);
          }
#line 95
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 95
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 95
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 95
  stack_pointer --;
#line 95
  *stack_pointer = *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 44);
#line 95
  stack_pointer --;
#line 95
  *stack_pointer = 3UL;
#line 95
  abort_to_interpreter(-3);
  }
#line 95
  return ((8UL << 58U) | 1UL);
}
}
#line 110 "/home/khheo/project/mit-scheme-9.2/src/microcode/generic.c"
SCHEME_OBJECT Prim_add(void) 
{ 
  SCHEME_OBJECT x ;
  SCHEME_OBJECT y ;
  SCHEME_OBJECT tmp ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;
  SCHEME_OBJECT *tmp___2 ;
  char *__cil_tmp7 ;

  {
  {
#line 111
  while (1) {
    while_continue: /* CIL Label */ ;
#line 111
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 111
  x = *(stack_pointer + 0);
#line 111
  y = *(stack_pointer + 1);
#line 111
  if (x >> 58U == 26UL) {
#line 111
    if (y >> 58U == 26UL) {
      {
#line 111
      tmp = long_to_integer((long )((x ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL)) + (long )((y ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL)));
      }
#line 111
      return (tmp);
    }
  }
  {
#line 111
  canonicalize_primitive_context();
  }
  {
#line 111
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 111
    if (! ((unsigned long )(stack_pointer + -2) >= (unsigned long )stack_guard)) {
      {
#line 111
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 111
        if (*stack_start != ((34UL << 58U) | (SCHEME_OBJECT )stack_start)) {
          {
#line 111
          stack_death("STACK_CHECK");
          }
        }
#line 111
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 111
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 111
        set_ulong_register(12U, Registers[12] | 1UL);
        }
        {
#line 111
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 111
          if ((Registers[1] & Registers[12]) != 0UL) {
#line 111
            tmp___1 = memory_block_start;
          } else {
#line 111
            if ((Registers[1] & 4UL) != 0UL) {
#line 111
              tmp___0 = heap_alloc_limit;
            } else {
#line 111
              tmp___0 = heap_end;
            }
#line 111
            tmp___1 = tmp___0;
          }
          {
#line 111
          set_ptr_register(0U, tmp___1);
          }
#line 111
          if ((Registers[1] & 1UL) != 0UL) {
#line 111
            tmp___2 = stack_guard;
          } else {
#line 111
            tmp___2 = stack_start;
          }
          {
#line 111
          set_ptr_register(11U, tmp___2);
          }
#line 111
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 111
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 111
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 111
  stack_pointer --;
#line 111
  *stack_pointer = *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 45);
#line 111
  stack_pointer --;
#line 111
  *stack_pointer = 3UL;
#line 111
  abort_to_interpreter(-3);
  }
#line 111
  return ((8UL << 58U) | 1UL);
}
}
#line 112 "/home/khheo/project/mit-scheme-9.2/src/microcode/generic.c"
SCHEME_OBJECT Prim_subtract(void) 
{ 
  SCHEME_OBJECT x ;
  SCHEME_OBJECT y ;
  SCHEME_OBJECT tmp ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;
  SCHEME_OBJECT *tmp___2 ;
  char *__cil_tmp7 ;

  {
  {
#line 113
  while (1) {
    while_continue: /* CIL Label */ ;
#line 113
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 113
  x = *(stack_pointer + 0);
#line 113
  y = *(stack_pointer + 1);
#line 113
  if (x >> 58U == 26UL) {
#line 113
    if (y >> 58U == 26UL) {
      {
#line 113
      tmp = long_to_integer((long )((x ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL)) - (long )((y ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL)));
      }
#line 113
      return (tmp);
    }
  }
  {
#line 113
  canonicalize_primitive_context();
  }
  {
#line 113
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 113
    if (! ((unsigned long )(stack_pointer + -2) >= (unsigned long )stack_guard)) {
      {
#line 113
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 113
        if (*stack_start != ((34UL << 58U) | (SCHEME_OBJECT )stack_start)) {
          {
#line 113
          stack_death("STACK_CHECK");
          }
        }
#line 113
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 113
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 113
        set_ulong_register(12U, Registers[12] | 1UL);
        }
        {
#line 113
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 113
          if ((Registers[1] & Registers[12]) != 0UL) {
#line 113
            tmp___1 = memory_block_start;
          } else {
#line 113
            if ((Registers[1] & 4UL) != 0UL) {
#line 113
              tmp___0 = heap_alloc_limit;
            } else {
#line 113
              tmp___0 = heap_end;
            }
#line 113
            tmp___1 = tmp___0;
          }
          {
#line 113
          set_ptr_register(0U, tmp___1);
          }
#line 113
          if ((Registers[1] & 1UL) != 0UL) {
#line 113
            tmp___2 = stack_guard;
          } else {
#line 113
            tmp___2 = stack_start;
          }
          {
#line 113
          set_ptr_register(11U, tmp___2);
          }
#line 113
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 113
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 113
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 113
  stack_pointer --;
#line 113
  *stack_pointer = *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 46);
#line 113
  stack_pointer --;
#line 113
  *stack_pointer = 3UL;
#line 113
  abort_to_interpreter(-3);
  }
#line 113
  return ((8UL << 58U) | 1UL);
}
}
#line 121 "/home/khheo/project/mit-scheme-9.2/src/microcode/generic.c"
SCHEME_OBJECT Prim_multiply(void) 
{ 
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;
  char *__cil_tmp4 ;

  {
  {
#line 122
  while (1) {
    while_continue: /* CIL Label */ ;
#line 122
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 122
  canonicalize_primitive_context();
  }
  {
#line 122
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 122
    if (! ((unsigned long )(stack_pointer + -2) >= (unsigned long )stack_guard)) {
      {
#line 122
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 122
        if (*stack_start != ((34UL << 58U) | (SCHEME_OBJECT )stack_start)) {
          {
#line 122
          stack_death("STACK_CHECK");
          }
        }
#line 122
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 122
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 122
        set_ulong_register(12U, Registers[12] | 1UL);
        }
        {
#line 122
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 122
          if ((Registers[1] & Registers[12]) != 0UL) {
#line 122
            tmp___0 = memory_block_start;
          } else {
#line 122
            if ((Registers[1] & 4UL) != 0UL) {
#line 122
              tmp = heap_alloc_limit;
            } else {
#line 122
              tmp = heap_end;
            }
#line 122
            tmp___0 = tmp;
          }
          {
#line 122
          set_ptr_register(0U, tmp___0);
          }
#line 122
          if ((Registers[1] & 1UL) != 0UL) {
#line 122
            tmp___1 = stack_guard;
          } else {
#line 122
            tmp___1 = stack_start;
          }
          {
#line 122
          set_ptr_register(11U, tmp___1);
          }
#line 122
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 122
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 122
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 122
  stack_pointer --;
#line 122
  *stack_pointer = *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 47);
#line 122
  stack_pointer --;
#line 122
  *stack_pointer = 3UL;
#line 122
  abort_to_interpreter(-3);
  }
#line 122
  return ((8UL << 58U) | 1UL);
}
}
#line 123 "/home/khheo/project/mit-scheme-9.2/src/microcode/generic.c"
SCHEME_OBJECT Prim_divide(void) 
{ 
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;
  char *__cil_tmp4 ;

  {
  {
#line 124
  while (1) {
    while_continue: /* CIL Label */ ;
#line 124
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 124
  canonicalize_primitive_context();
  }
  {
#line 124
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 124
    if (! ((unsigned long )(stack_pointer + -2) >= (unsigned long )stack_guard)) {
      {
#line 124
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 124
        if (*stack_start != ((34UL << 58U) | (SCHEME_OBJECT )stack_start)) {
          {
#line 124
          stack_death("STACK_CHECK");
          }
        }
#line 124
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 124
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 124
        set_ulong_register(12U, Registers[12] | 1UL);
        }
        {
#line 124
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 124
          if ((Registers[1] & Registers[12]) != 0UL) {
#line 124
            tmp___0 = memory_block_start;
          } else {
#line 124
            if ((Registers[1] & 4UL) != 0UL) {
#line 124
              tmp = heap_alloc_limit;
            } else {
#line 124
              tmp = heap_end;
            }
#line 124
            tmp___0 = tmp;
          }
          {
#line 124
          set_ptr_register(0U, tmp___0);
          }
#line 124
          if ((Registers[1] & 1UL) != 0UL) {
#line 124
            tmp___1 = stack_guard;
          } else {
#line 124
            tmp___1 = stack_start;
          }
          {
#line 124
          set_ptr_register(11U, tmp___1);
          }
#line 124
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 124
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 124
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 124
  stack_pointer --;
#line 124
  *stack_pointer = *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 48);
#line 124
  stack_pointer --;
#line 124
  *stack_pointer = 3UL;
#line 124
  abort_to_interpreter(-3);
  }
#line 124
  return ((8UL << 58U) | 1UL);
}
}
#line 125 "/home/khheo/project/mit-scheme-9.2/src/microcode/generic.c"
SCHEME_OBJECT Prim_quotient(void) 
{ 
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;
  char *__cil_tmp4 ;

  {
  {
#line 126
  while (1) {
    while_continue: /* CIL Label */ ;
#line 126
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 126
  canonicalize_primitive_context();
  }
  {
#line 126
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 126
    if (! ((unsigned long )(stack_pointer + -2) >= (unsigned long )stack_guard)) {
      {
#line 126
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 126
        if (*stack_start != ((34UL << 58U) | (SCHEME_OBJECT )stack_start)) {
          {
#line 126
          stack_death("STACK_CHECK");
          }
        }
#line 126
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 126
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 126
        set_ulong_register(12U, Registers[12] | 1UL);
        }
        {
#line 126
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 126
          if ((Registers[1] & Registers[12]) != 0UL) {
#line 126
            tmp___0 = memory_block_start;
          } else {
#line 126
            if ((Registers[1] & 4UL) != 0UL) {
#line 126
              tmp = heap_alloc_limit;
            } else {
#line 126
              tmp = heap_end;
            }
#line 126
            tmp___0 = tmp;
          }
          {
#line 126
          set_ptr_register(0U, tmp___0);
          }
#line 126
          if ((Registers[1] & 1UL) != 0UL) {
#line 126
            tmp___1 = stack_guard;
          } else {
#line 126
            tmp___1 = stack_start;
          }
          {
#line 126
          set_ptr_register(11U, tmp___1);
          }
#line 126
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 126
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 126
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 126
  stack_pointer --;
#line 126
  *stack_pointer = *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 49);
#line 126
  stack_pointer --;
#line 126
  *stack_pointer = 3UL;
#line 126
  abort_to_interpreter(-3);
  }
#line 126
  return ((8UL << 58U) | 1UL);
}
}
#line 127 "/home/khheo/project/mit-scheme-9.2/src/microcode/generic.c"
SCHEME_OBJECT Prim_remainder(void) 
{ 
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;
  char *__cil_tmp4 ;

  {
  {
#line 128
  while (1) {
    while_continue: /* CIL Label */ ;
#line 128
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 128
  canonicalize_primitive_context();
  }
  {
#line 128
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 128
    if (! ((unsigned long )(stack_pointer + -2) >= (unsigned long )stack_guard)) {
      {
#line 128
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 128
        if (*stack_start != ((34UL << 58U) | (SCHEME_OBJECT )stack_start)) {
          {
#line 128
          stack_death("STACK_CHECK");
          }
        }
#line 128
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 128
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 128
        set_ulong_register(12U, Registers[12] | 1UL);
        }
        {
#line 128
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 128
          if ((Registers[1] & Registers[12]) != 0UL) {
#line 128
            tmp___0 = memory_block_start;
          } else {
#line 128
            if ((Registers[1] & 4UL) != 0UL) {
#line 128
              tmp = heap_alloc_limit;
            } else {
#line 128
              tmp = heap_end;
            }
#line 128
            tmp___0 = tmp;
          }
          {
#line 128
          set_ptr_register(0U, tmp___0);
          }
#line 128
          if ((Registers[1] & 1UL) != 0UL) {
#line 128
            tmp___1 = stack_guard;
          } else {
#line 128
            tmp___1 = stack_start;
          }
          {
#line 128
          set_ptr_register(11U, tmp___1);
          }
#line 128
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 128
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 128
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 128
  stack_pointer --;
#line 128
  *stack_pointer = *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 50);
#line 128
  stack_pointer --;
#line 128
  *stack_pointer = 3UL;
#line 128
  abort_to_interpreter(-3);
  }
#line 128
  return ((8UL << 58U) | 1UL);
}
}
#line 129 "/home/khheo/project/mit-scheme-9.2/src/microcode/generic.c"
SCHEME_OBJECT Prim_modulo(void) 
{ 
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;
  char *__cil_tmp4 ;

  {
  {
#line 130
  while (1) {
    while_continue: /* CIL Label */ ;
#line 130
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 130
  canonicalize_primitive_context();
  }
  {
#line 130
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 130
    if (! ((unsigned long )(stack_pointer + -2) >= (unsigned long )stack_guard)) {
      {
#line 130
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 130
        if (*stack_start != ((34UL << 58U) | (SCHEME_OBJECT )stack_start)) {
          {
#line 130
          stack_death("STACK_CHECK");
          }
        }
#line 130
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 130
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 130
        set_ulong_register(12U, Registers[12] | 1UL);
        }
        {
#line 130
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 130
          if ((Registers[1] & Registers[12]) != 0UL) {
#line 130
            tmp___0 = memory_block_start;
          } else {
#line 130
            if ((Registers[1] & 4UL) != 0UL) {
#line 130
              tmp = heap_alloc_limit;
            } else {
#line 130
              tmp = heap_end;
            }
#line 130
            tmp___0 = tmp;
          }
          {
#line 130
          set_ptr_register(0U, tmp___0);
          }
#line 130
          if ((Registers[1] & 1UL) != 0UL) {
#line 130
            tmp___1 = stack_guard;
          } else {
#line 130
            tmp___1 = stack_start;
          }
          {
#line 130
          set_ptr_register(11U, tmp___1);
          }
#line 130
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 130
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 130
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 130
  stack_pointer --;
#line 130
  *stack_pointer = *((SCHEME_OBJECT *)(fixed_objects & 288230376151711743UL) + 51);
#line 130
  stack_pointer --;
#line 130
  *stack_pointer = 3UL;
#line 130
  abort_to_interpreter(-3);
  }
#line 130
  return ((8UL << 58U) | 1UL);
}
}
#line 68 "/home/khheo/project/mit-scheme-9.2/src/microcode/gc.h"
gc_type_t gc_type_map[64] ;
#line 70
gc_ptr_type_t gc_ptr_type(SCHEME_OBJECT object ) ;
#line 151 "/home/khheo/project/mit-scheme-9.2/src/microcode/gccode.h"
gc_table_t *current_gc_table  ;
#line 153
SCHEME_OBJECT *gc_handle_non_pointer(SCHEME_OBJECT *scan , SCHEME_OBJECT object ) ;
#line 154
SCHEME_OBJECT *gc_handle_cell(SCHEME_OBJECT *scan , SCHEME_OBJECT object ) ;
#line 155
SCHEME_OBJECT *gc_handle_pair(SCHEME_OBJECT *scan , SCHEME_OBJECT object ) ;
#line 156
SCHEME_OBJECT *gc_handle_triple(SCHEME_OBJECT *scan , SCHEME_OBJECT object ) ;
#line 157
SCHEME_OBJECT *gc_handle_quadruple(SCHEME_OBJECT *scan , SCHEME_OBJECT object ) ;
#line 158
SCHEME_OBJECT *gc_handle_weak_pair(SCHEME_OBJECT *scan , SCHEME_OBJECT object ) ;
#line 159
SCHEME_OBJECT *gc_handle_ephemeron(SCHEME_OBJECT *scan , SCHEME_OBJECT object ) ;
#line 160
SCHEME_OBJECT *gc_handle_cc_entry(SCHEME_OBJECT *scan , SCHEME_OBJECT object ) ;
#line 161
SCHEME_OBJECT *gc_handle_aligned_vector(SCHEME_OBJECT *scan , SCHEME_OBJECT object ) ;
#line 162
SCHEME_OBJECT *gc_handle_unaligned_vector(SCHEME_OBJECT *scan , SCHEME_OBJECT object ) ;
#line 163
SCHEME_OBJECT *gc_handle_broken_heart(SCHEME_OBJECT *scan , SCHEME_OBJECT object ) ;
#line 164
SCHEME_OBJECT *gc_handle_nmv(SCHEME_OBJECT *scan , SCHEME_OBJECT object ) ;
#line 165
SCHEME_OBJECT *gc_handle_reference_trap(SCHEME_OBJECT *scan , SCHEME_OBJECT object ) ;
#line 166
SCHEME_OBJECT *gc_handle_linkage_section(SCHEME_OBJECT *scan , SCHEME_OBJECT object ) ;
#line 167
SCHEME_OBJECT *gc_handle_manifest_closure(SCHEME_OBJECT *scan , SCHEME_OBJECT object ) ;
#line 168
SCHEME_OBJECT *gc_handle_undefined(SCHEME_OBJECT *scan , SCHEME_OBJECT object ) ;
#line 170
SCHEME_OBJECT gc_tuple(SCHEME_OBJECT tuple , unsigned int n_words ) ;
#line 171
SCHEME_OBJECT gc_vector(SCHEME_OBJECT vector , _Bool align_p ) ;
#line 172
SCHEME_OBJECT gc_cc_entry(SCHEME_OBJECT object ) ;
#line 173
SCHEME_OBJECT *gc_precheck_from(SCHEME_OBJECT *from ) ;
#line 174
SCHEME_OBJECT *gc_precheck_from_no_transport(SCHEME_OBJECT *from ) ;
#line 175
SCHEME_OBJECT *gc_transport_words(SCHEME_OBJECT *from , unsigned long n_words , _Bool align_p ) ;
#line 176
SCHEME_OBJECT *gc_no_transport_words(SCHEME_OBJECT *from , unsigned long n_words ,
                                     _Bool align_p ) ;
#line 177
SCHEME_OBJECT gc_raw_address_to_object(unsigned int type , SCHEME_OBJECT *address___0 ) ;
#line 178
SCHEME_OBJECT *gc_object_to_raw_address(SCHEME_OBJECT object ) ;
#line 179
SCHEME_OBJECT gc_raw_address_to_cc_entry(insn_t *address___0 ) ;
#line 180
insn_t *gc_cc_entry_to_raw_address(SCHEME_OBJECT entry ) ;
#line 182
void initialize_gc_table(gc_table_t *table___3 , _Bool transport_p ) ;
#line 195
_Bool tospace_available_p(unsigned long n_words ) ;
#line 197
SCHEME_OBJECT read_tospace(SCHEME_OBJECT *addr ) ;
#line 198
void write_tospace(SCHEME_OBJECT *addr , SCHEME_OBJECT object ) ;
#line 202
void *newspace_to_tospace(void *addr ) ;
#line 204
void discard_tospace(void) ;
#line 213
 __attribute__((__noreturn__)) void ( /* format attribute */  std_gc_death)(char const   *format 
                                                                            , ...) ;
#line 215
 __attribute__((__noreturn__)) void gc_no_cc_support(void) ;
#line 216
 __attribute__((__noreturn__)) void gc_bad_type(SCHEME_OBJECT object ) ;
#line 72 "/home/khheo/project/mit-scheme-9.2/src/microcode/gcloop.c"
static SCHEME_OBJECT **p_fromspace_start  ;
#line 73 "/home/khheo/project/mit-scheme-9.2/src/microcode/gcloop.c"
static SCHEME_OBJECT **p_fromspace_end  ;
#line 74 "/home/khheo/project/mit-scheme-9.2/src/microcode/gcloop.c"
static gc_tospace_allocator_t *gc_tospace_allocator  ;
#line 75 "/home/khheo/project/mit-scheme-9.2/src/microcode/gcloop.c"
static  __attribute__((__noreturn__)) gc_abort_handler_t *gc_abort_handler  ;
#line 77 "/home/khheo/project/mit-scheme-9.2/src/microcode/gcloop.c"
static SCHEME_OBJECT *tospace_start  ;
#line 78 "/home/khheo/project/mit-scheme-9.2/src/microcode/gcloop.c"
static SCHEME_OBJECT *tospace_next  ;
#line 79 "/home/khheo/project/mit-scheme-9.2/src/microcode/gcloop.c"
static SCHEME_OBJECT *tospace_end  ;
#line 80 "/home/khheo/project/mit-scheme-9.2/src/microcode/gcloop.c"
static SCHEME_OBJECT *newspace_start  ;
#line 81 "/home/khheo/project/mit-scheme-9.2/src/microcode/gcloop.c"
static SCHEME_OBJECT *newspace_next  ;
#line 82 "/home/khheo/project/mit-scheme-9.2/src/microcode/gcloop.c"
static SCHEME_OBJECT *newspace_end  ;
#line 85 "/home/khheo/project/mit-scheme-9.2/src/microcode/gcloop.c"
static SCHEME_OBJECT *current_scan  ;
#line 86 "/home/khheo/project/mit-scheme-9.2/src/microcode/gcloop.c"
static SCHEME_OBJECT current_object  ;
#line 138 "/home/khheo/project/mit-scheme-9.2/src/microcode/gcloop.c"
static SCHEME_OBJECT *weak_chain  ;
#line 139 "/home/khheo/project/mit-scheme-9.2/src/microcode/gcloop.c"
static SCHEME_OBJECT ephemeron_list  =    0UL;
#line 140 "/home/khheo/project/mit-scheme-9.2/src/microcode/gcloop.c"
static SCHEME_OBJECT ephemeron_queue  =    0UL;
#line 141 "/home/khheo/project/mit-scheme-9.2/src/microcode/gcloop.c"
static _Bool scanning_ephemerons_p  =    (_Bool)0;
#line 146
static void queue_ephemerons_for_key(SCHEME_OBJECT *addr ) ;
#line 147
static SCHEME_OBJECT gc_transport_weak_pair(SCHEME_OBJECT pair ) ;
#line 148
static SCHEME_OBJECT gc_transport_ephemeron(SCHEME_OBJECT old_ephemeron ) ;
#line 150
static void run_gc_loop(SCHEME_OBJECT *scan , SCHEME_OBJECT **pend ) ;
#line 151
static  __attribute__((__noreturn__)) void tospace_closed(void) ;
#line 152
static  __attribute__((__noreturn__)) void tospace_open(void) ;
#line 191 "/home/khheo/project/mit-scheme-9.2/src/microcode/gcloop.c"
void initialize_gc(unsigned long n_words , SCHEME_OBJECT **pf_start , SCHEME_OBJECT **pf_end ,
                   gc_tospace_allocator_t *allocator ,  __attribute__((__noreturn__)) gc_abort_handler_t *abort_handler ) 
{ 


  {
#line 198
  p_fromspace_start = pf_start;
#line 199
  p_fromspace_end = pf_end;
#line 200
  gc_tospace_allocator = allocator;
#line 201
  gc_abort_handler = abort_handler;
  {
#line 202
  while (1) {
    while_continue: /* CIL Label */ ;
#line 202
    tospace_next = (SCHEME_OBJECT *)0;
#line 202
    newspace_start = (SCHEME_OBJECT *)0;
#line 202
    newspace_next = (SCHEME_OBJECT *)0;
#line 202
    newspace_end = (SCHEME_OBJECT *)0;
#line 202
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 203
  tospace_start = (SCHEME_OBJECT *)0;
#line 204
  tospace_end = (SCHEME_OBJECT *)0;
#line 205
  (*gc_tospace_allocator)(n_words, & tospace_start, & tospace_end);
  }
#line 206
  return;
}
}
#line 208 "/home/khheo/project/mit-scheme-9.2/src/microcode/gcloop.c"
void resize_tospace(unsigned long n_words ) 
{ 


  {
  {
#line 211
  while (1) {
    while_continue: /* CIL Label */ ;
#line 211
    if ((unsigned long )tospace_next != (unsigned long )((SCHEME_OBJECT *)0)) {
      {
#line 211
      tospace_open();
      }
    }
#line 211
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 212
  (*gc_tospace_allocator)(n_words, & tospace_start, & tospace_end);
  }
#line 213
  return;
}
}
#line 215 "/home/khheo/project/mit-scheme-9.2/src/microcode/gcloop.c"
void open_tospace(SCHEME_OBJECT *start ) 
{ 


  {
  {
#line 218
  while (1) {
    while_continue: /* CIL Label */ ;
#line 218
    if ((unsigned long )tospace_next != (unsigned long )((SCHEME_OBJECT *)0)) {
      {
#line 218
      tospace_open();
      }
    }
#line 218
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 219
  tospace_next = tospace_start;
#line 220
  newspace_start = start;
#line 221
  newspace_next = start;
#line 222
  newspace_end = start + (tospace_end - tospace_start);
#line 223
  return;
}
}
#line 225 "/home/khheo/project/mit-scheme-9.2/src/microcode/gcloop.c"
_Bool save_tospace(gc_walk_proc_t *proc , void *ctx ) 
{ 
  _Bool ok ;

  {
  {
#line 230
  while (1) {
    while_continue: /* CIL Label */ ;
#line 230
    if ((unsigned long )tospace_next == (unsigned long )((SCHEME_OBJECT *)0)) {
      {
#line 230
      tospace_closed();
      }
    }
#line 230
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 231
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 231
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 232
  ok = (*proc)(tospace_start, tospace_next, ctx);
#line 233
  OS_free_pages((void *)tospace_start, (void *)tospace_end);
  }
  {
#line 234
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 234
    tospace_next = (SCHEME_OBJECT *)0;
#line 234
    newspace_start = (SCHEME_OBJECT *)0;
#line 234
    newspace_next = (SCHEME_OBJECT *)0;
#line 234
    newspace_end = (SCHEME_OBJECT *)0;
#line 234
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 235
  return (ok);
}
}
#line 238 "/home/khheo/project/mit-scheme-9.2/src/microcode/gcloop.c"
void discard_tospace(void) 
{ 


  {
  {
#line 241
  while (1) {
    while_continue: /* CIL Label */ ;
#line 241
    if ((unsigned long )tospace_next == (unsigned long )((SCHEME_OBJECT *)0)) {
      {
#line 241
      tospace_closed();
      }
    }
#line 241
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 242
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 242
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 243
  OS_free_pages((void *)tospace_start, (void *)tospace_end);
  }
  {
#line 244
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 244
    tospace_next = (SCHEME_OBJECT *)0;
#line 244
    newspace_start = (SCHEME_OBJECT *)0;
#line 244
    newspace_next = (SCHEME_OBJECT *)0;
#line 244
    newspace_end = (SCHEME_OBJECT *)0;
#line 244
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 245
  return;
}
}
#line 247 "/home/khheo/project/mit-scheme-9.2/src/microcode/gcloop.c"
_Bool tospace_available_p(unsigned long n_words ) 
{ 


  {
  {
#line 250
  while (1) {
    while_continue: /* CIL Label */ ;
#line 250
    if ((unsigned long )tospace_next == (unsigned long )((SCHEME_OBJECT *)0)) {
      {
#line 250
      tospace_closed();
      }
    }
#line 250
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 251
  return ((_Bool )((unsigned long )(tospace_end - tospace_next) >= n_words));
}
}
#line 254 "/home/khheo/project/mit-scheme-9.2/src/microcode/gcloop.c"
void add_to_tospace(SCHEME_OBJECT object ) 
{ 
  SCHEME_OBJECT *tmp ;

  {
  {
#line 257
  while (1) {
    while_continue: /* CIL Label */ ;
#line 257
    if ((unsigned long )tospace_next == (unsigned long )((SCHEME_OBJECT *)0)) {
      {
#line 257
      tospace_closed();
      }
    }
#line 257
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 258
  tmp = tospace_next;
#line 258
  tospace_next ++;
#line 258
  *tmp = object;
#line 259
  newspace_next ++;
#line 260
  return;
}
}
#line 262 "/home/khheo/project/mit-scheme-9.2/src/microcode/gcloop.c"
SCHEME_OBJECT read_tospace(SCHEME_OBJECT *addr ) 
{ 


  {
  {
#line 265
  while (1) {
    while_continue: /* CIL Label */ ;
#line 265
    if ((unsigned long )tospace_next == (unsigned long )((SCHEME_OBJECT *)0)) {
      {
#line 265
      tospace_closed();
      }
    }
#line 265
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 266
  return (*(tospace_start + (addr - newspace_start)));
}
}
#line 269 "/home/khheo/project/mit-scheme-9.2/src/microcode/gcloop.c"
void write_tospace(SCHEME_OBJECT *addr , SCHEME_OBJECT object ) 
{ 


  {
  {
#line 272
  while (1) {
    while_continue: /* CIL Label */ ;
#line 272
    if ((unsigned long )tospace_next == (unsigned long )((SCHEME_OBJECT *)0)) {
      {
#line 272
      tospace_closed();
      }
    }
#line 272
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 273
  *(tospace_start + (addr - newspace_start)) = object;
#line 274
  return;
}
}
#line 276 "/home/khheo/project/mit-scheme-9.2/src/microcode/gcloop.c"
void increment_tospace_ptr(unsigned long n_words ) 
{ 


  {
  {
#line 279
  while (1) {
    while_continue: /* CIL Label */ ;
#line 279
    if ((unsigned long )tospace_next == (unsigned long )((SCHEME_OBJECT *)0)) {
      {
#line 279
      tospace_closed();
      }
    }
#line 279
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 280
  tospace_next += n_words;
#line 281
  newspace_next += n_words;
#line 282
  return;
}
}
#line 284 "/home/khheo/project/mit-scheme-9.2/src/microcode/gcloop.c"
SCHEME_OBJECT *get_newspace_ptr(void) 
{ 


  {
#line 287
  return (newspace_next);
}
}
#line 290 "/home/khheo/project/mit-scheme-9.2/src/microcode/gcloop.c"
void *tospace_to_newspace(void *addr ) 
{ 
  byte_t *tmp ;

  {
#line 293
  if ((unsigned long )addr >= (unsigned long )((void *)tospace_start)) {
#line 293
    if ((unsigned long )addr <= (unsigned long )((void *)tospace_end)) {
#line 293
      tmp = (byte_t *)newspace_start + ((byte_t *)addr - (byte_t *)tospace_start);
    } else {
#line 293
      tmp = (byte_t *)addr;
    }
  } else {
#line 293
    tmp = (byte_t *)addr;
  }
#line 293
  return ((void *)tmp);
}
}
#line 301 "/home/khheo/project/mit-scheme-9.2/src/microcode/gcloop.c"
void *newspace_to_tospace(void *addr ) 
{ 
  byte_t *tmp ;

  {
#line 304
  if ((unsigned long )addr >= (unsigned long )((void *)newspace_start)) {
#line 304
    if ((unsigned long )addr <= (unsigned long )((void *)newspace_end)) {
#line 304
      tmp = (byte_t *)tospace_start + ((byte_t *)addr - (byte_t *)newspace_start);
    } else {
#line 304
      tmp = (byte_t *)addr;
    }
  } else {
#line 304
    tmp = (byte_t *)addr;
  }
#line 304
  return ((void *)tmp);
}
}
#line 316 "/home/khheo/project/mit-scheme-9.2/src/microcode/gcloop.c"
void initialize_gc_table(gc_table_t *table___3 , _Bool transport_p ) 
{ 
  unsigned int i ;
  char *__cil_tmp4 ;

  {
#line 320
  i = 0U;
  {
#line 320
  while (1) {
    while_continue: /* CIL Label */ ;
#line 320
    if (! (i < 64U)) {
#line 320
      goto while_break;
    }
    {
#line 323
    if ((int )gc_type_map[i] == 0) {
#line 323
      goto case_0;
    }
#line 324
    if ((int )gc_type_map[i] == 1) {
#line 324
      goto case_1;
    }
#line 325
    if ((int )gc_type_map[i] == 2) {
#line 325
      goto case_2;
    }
#line 326
    if ((int )gc_type_map[i] == 3) {
#line 326
      goto case_3;
    }
#line 327
    if ((int )gc_type_map[i] == 4) {
#line 327
      goto case_4;
    }
#line 328
    if ((int )gc_type_map[i] == -3) {
#line 328
      goto case_neg_3;
    }
#line 329
    if ((int )gc_type_map[i] == -4) {
#line 329
      goto case_neg_4;
    }
#line 330
    if ((int )gc_type_map[i] == -1) {
#line 330
      goto case_neg_1;
    }
#line 332
    if ((int )gc_type_map[i] == -2) {
#line 332
      goto case_neg_2;
    }
#line 321
    goto switch_break;
    case_0: /* CIL Label */ 
#line 323
    table___3->handlers[i] = & gc_handle_non_pointer;
#line 323
    goto switch_break;
    case_1: /* CIL Label */ 
#line 324
    table___3->handlers[i] = & gc_handle_cell;
#line 324
    goto switch_break;
    case_2: /* CIL Label */ 
#line 325
    table___3->handlers[i] = & gc_handle_pair;
#line 325
    goto switch_break;
    case_3: /* CIL Label */ 
#line 326
    table___3->handlers[i] = & gc_handle_triple;
#line 326
    goto switch_break;
    case_4: /* CIL Label */ 
#line 327
    table___3->handlers[i] = & gc_handle_quadruple;
#line 327
    goto switch_break;
    case_neg_3: /* CIL Label */ 
#line 328
    table___3->handlers[i] = & gc_handle_unaligned_vector;
#line 328
    goto switch_break;
    case_neg_4: /* CIL Label */ 
#line 329
    table___3->handlers[i] = & gc_handle_cc_entry;
#line 329
    goto switch_break;
    case_neg_1: /* CIL Label */ 
#line 330
    table___3->handlers[i] = & gc_handle_undefined;
#line 330
    goto switch_break;
    case_neg_2: /* CIL Label */ 
    {
#line 335
    if (i == 34U) {
#line 335
      goto case_34;
    }
#line 338
    if (i == 50U) {
#line 338
      goto case_50;
    }
#line 341
    if (i == 57U) {
#line 341
      goto case_57;
    }
#line 344
    if (i == 13U) {
#line 344
      goto case_13;
    }
#line 347
    if (i == 39U) {
#line 347
      goto case_39;
    }
#line 350
    goto switch_default;
    case_34: /* CIL Label */ 
#line 336
    table___3->handlers[i] = & gc_handle_broken_heart;
#line 336
    goto switch_break___0;
    case_50: /* CIL Label */ 
#line 339
    table___3->handlers[i] = & gc_handle_reference_trap;
#line 339
    goto switch_break___0;
    case_57: /* CIL Label */ 
#line 342
    table___3->handlers[i] = & gc_handle_linkage_section;
#line 342
    goto switch_break___0;
    case_13: /* CIL Label */ 
#line 345
    table___3->handlers[i] = & gc_handle_manifest_closure;
#line 345
    goto switch_break___0;
    case_39: /* CIL Label */ 
#line 348
    table___3->handlers[i] = & gc_handle_nmv;
#line 348
    goto switch_break___0;
    switch_default: /* CIL Label */ 
    {
#line 351
    std_gc_death("unknown GC special type: %#02x\n", i);
    }
#line 352
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 354
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 320
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 356
  table___3->handlers[55] = & gc_handle_weak_pair;
#line 357
  table___3->handlers[43] = & gc_handle_ephemeron;
#line 358
  table___3->handlers[6] = & gc_handle_aligned_vector;
#line 359
  table___3->handlers[61] = & gc_handle_aligned_vector;
#line 360
  table___3->tuple_handler = & gc_tuple;
#line 361
  table___3->vector_handler = & gc_vector;
#line 362
  table___3->cc_entry_handler = & gc_cc_entry;
#line 363
  if (transport_p) {
#line 365
    table___3->precheck_from = & gc_precheck_from;
#line 366
    table___3->transport_words = & gc_transport_words;
  } else {
#line 370
    table___3->precheck_from = & gc_precheck_from_no_transport;
#line 371
    table___3->transport_words = & gc_no_transport_words;
  }
#line 373
  table___3->ignore_object_p = (gc_ignore_object_p_t *)0;
#line 374
  table___3->raw_address_to_object = & gc_raw_address_to_object;
#line 375
  table___3->object_to_raw_address = & gc_object_to_raw_address;
#line 376
  table___3->raw_address_to_cc_entry = & gc_raw_address_to_cc_entry;
#line 377
  table___3->cc_entry_to_raw_address = & gc_cc_entry_to_raw_address;
#line 378
  return;
}
}
#line 383 "/home/khheo/project/mit-scheme-9.2/src/microcode/gcloop.c"
static _Bool initialized_p  =    (_Bool)0;
#line 384 "/home/khheo/project/mit-scheme-9.2/src/microcode/gcloop.c"
static gc_table_t table  ;
#line 380 "/home/khheo/project/mit-scheme-9.2/src/microcode/gcloop.c"
gc_table_t *std_gc_table(void) 
{ 


  {
#line 385
  if (! initialized_p) {
    {
#line 387
    initialize_gc_table(& table, (_Bool)1);
#line 388
    initialized_p = (_Bool)1;
    }
  }
#line 390
  return (& table);
}
}
#line 393 "/home/khheo/project/mit-scheme-9.2/src/microcode/gcloop.c"
void gc_scan_oldspace(SCHEME_OBJECT *scan , SCHEME_OBJECT *end ) 
{ 


  {
  {
#line 396
  OS_expect_sequential_access((void *)scan, (void *)end);
#line 397
  run_gc_loop(scan, & end);
#line 403
  OS_expect_normal_access((void *)scan, (void *)end);
  }
#line 404
  return;
}
}
#line 406 "/home/khheo/project/mit-scheme-9.2/src/microcode/gcloop.c"
void gc_scan_tospace(SCHEME_OBJECT *scan , SCHEME_OBJECT *end ) 
{ 
  SCHEME_OBJECT *tend ;

  {
#line 409
  if ((unsigned long )end == (unsigned long )((SCHEME_OBJECT *)0)) {
    {
#line 410
    run_gc_loop(tospace_start + (scan - newspace_start), & tospace_next);
    }
  } else {
    {
#line 413
    tend = tospace_start + (end - newspace_start);
#line 414
    run_gc_loop(tospace_start + (scan - newspace_start), & tend);
    }
  }
#line 416
  return;
}
}
#line 418 "/home/khheo/project/mit-scheme-9.2/src/microcode/gcloop.c"
static void run_gc_loop(SCHEME_OBJECT *scan , SCHEME_OBJECT **pend ) 
{ 
  gc_ignore_object_p_t *ignore_object_p ;
  SCHEME_OBJECT object ;
  _Bool tmp ;

  {
#line 421
  ignore_object_p = current_gc_table->ignore_object_p;
  {
#line 423
  while (1) {
    while_continue: /* CIL Label */ ;
#line 423
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 424
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 424
    if (! ((unsigned long )scan < (unsigned long )*pend)) {
#line 424
      goto while_break___0;
    }
#line 426
    object = *scan;
    {
#line 427
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 427
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 428
    if ((unsigned long )ignore_object_p != (unsigned long )((gc_ignore_object_p_t *)0)) {
      {
#line 428
      tmp = (*ignore_object_p)(object);
      }
#line 428
      if (tmp) {
#line 429
        scan ++;
      } else {
        {
#line 432
        current_scan = scan;
#line 433
        current_object = object;
#line 434
        scan = (*(current_gc_table->handlers[object >> 58U]))(scan, object);
        }
      }
    } else {
      {
#line 432
      current_scan = scan;
#line 433
      current_object = object;
#line 434
      scan = (*(current_gc_table->handlers[object >> 58U]))(scan, object);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 439
  return;
}
}
#line 441 "/home/khheo/project/mit-scheme-9.2/src/microcode/gcloop.c"
SCHEME_OBJECT gc_tuple(SCHEME_OBJECT tuple , unsigned int n_words ) 
{ 
  SCHEME_OBJECT *from ;
  SCHEME_OBJECT *new_address ;
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;

  {
  {
#line 443
  from = (SCHEME_OBJECT *)(tuple & 288230376151711743UL);
#line 444
  tmp = (*(current_gc_table->precheck_from))(from);
#line 444
  new_address = tmp;
  }
#line 445
  if ((unsigned long )new_address != (unsigned long )((SCHEME_OBJECT *)0)) {
#line 445
    tmp___1 = new_address;
  } else {
    {
#line 445
    tmp___0 = (*(current_gc_table->transport_words))(from, (unsigned long )n_words,
                                                     (_Bool)0);
#line 445
    tmp___1 = tmp___0;
    }
  }
#line 445
  return (((tuple >> 58U) << 58U) | (SCHEME_OBJECT )tmp___1);
}
}
#line 452 "/home/khheo/project/mit-scheme-9.2/src/microcode/gcloop.c"
SCHEME_OBJECT gc_vector(SCHEME_OBJECT vector , _Bool align_p ) 
{ 
  SCHEME_OBJECT *from ;
  SCHEME_OBJECT *new_address ;
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;

  {
  {
#line 454
  from = (SCHEME_OBJECT *)(vector & 288230376151711743UL);
#line 455
  tmp = (*(current_gc_table->precheck_from))(from);
#line 455
  new_address = tmp;
  }
#line 456
  if ((unsigned long )new_address != (unsigned long )((SCHEME_OBJECT *)0)) {
#line 456
    tmp___1 = new_address;
  } else {
    {
#line 456
    tmp___0 = (*(current_gc_table->transport_words))(from, 1UL + (*from & 288230376151711743UL),
                                                     align_p);
#line 456
    tmp___1 = tmp___0;
    }
  }
#line 456
  return (((vector >> 58U) << 58U) | (SCHEME_OBJECT )tmp___1);
}
}
#line 465 "/home/khheo/project/mit-scheme-9.2/src/microcode/gcloop.c"
SCHEME_OBJECT gc_cc_entry(SCHEME_OBJECT object ) 
{ 
  SCHEME_OBJECT old_block ;
  SCHEME_OBJECT tmp ;
  SCHEME_OBJECT new_block ;
  SCHEME_OBJECT tmp___0 ;

  {
  {
#line 468
  tmp = cc_entry_to_block(object);
#line 468
  old_block = tmp;
#line 469
  tmp___0 = (*(current_gc_table->vector_handler))(old_block, (_Bool)1);
#line 469
  new_block = tmp___0;
  }
#line 470
  return (((object >> 58U) << 58U) | (SCHEME_OBJECT )((insn_t *)((SCHEME_OBJECT *)(new_block & 288230376151711743UL)) + ((insn_t *)((SCHEME_OBJECT *)(object & 288230376151711743UL)) - (insn_t *)((SCHEME_OBJECT *)(old_block & 288230376151711743UL)))));
}
}
#line 479 "/home/khheo/project/mit-scheme-9.2/src/microcode/gcloop.c"
SCHEME_OBJECT *gc_precheck_from(SCHEME_OBJECT *from ) 
{ 


  {
#line 487
  if ((unsigned long )((void *)from) >= (unsigned long )((void *)*p_fromspace_start)) {
#line 487
    if (! ((unsigned long )((void *)from) < (unsigned long )((void *)*p_fromspace_end))) {
#line 488
      return (from);
    }
  } else {
#line 488
    return (from);
  }
#line 489
  if (*from >> 58U == 34UL) {
#line 490
    return ((SCHEME_OBJECT *)(*from & 288230376151711743UL));
  }
#line 491
  if (scanning_ephemerons_p) {
    {
#line 496
    queue_ephemerons_for_key(from);
    }
  }
#line 497
  return ((SCHEME_OBJECT *)0);
}
}
#line 500 "/home/khheo/project/mit-scheme-9.2/src/microcode/gcloop.c"
SCHEME_OBJECT *gc_precheck_from_no_transport(SCHEME_OBJECT *from ) 
{ 


  {
#line 508
  return (from);
}
}
#line 511 "/home/khheo/project/mit-scheme-9.2/src/microcode/gcloop.c"
SCHEME_OBJECT *gc_transport_words(SCHEME_OBJECT *from , unsigned long n_words , _Bool align_p ) 
{ 
  SCHEME_OBJECT *from_start ;
  SCHEME_OBJECT *from_end ;
  SCHEME_OBJECT *new_address ;
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;

  {
#line 513
  from_start = from;
#line 514
  from_end = from_start + n_words;
  {
#line 517
  while (1) {
    while_continue: /* CIL Label */ ;
#line 517
    if ((unsigned long )tospace_next == (unsigned long )((SCHEME_OBJECT *)0)) {
      {
#line 517
      tospace_closed();
      }
    }
#line 517
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 518
  if (align_p) {
    {
#line 519
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 519
      goto while_break___0;
#line 521
      tmp = tospace_next;
#line 521
      tospace_next ++;
#line 521
      *tmp = 39UL << 58U;
#line 522
      newspace_next ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 541
  new_address = newspace_next;
  {
#line 542
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 542
    if (! ((unsigned long )from < (unsigned long )from_end)) {
#line 542
      goto while_break___1;
    }
    {
#line 544
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 544
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 545
    tmp___0 = tospace_next;
#line 545
    tospace_next ++;
#line 545
    tmp___1 = from;
#line 545
    from ++;
#line 545
    *tmp___0 = *tmp___1;
#line 546
    newspace_next ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 548
  *from_start = (34UL << 58U) | (SCHEME_OBJECT )new_address;
#line 549
  return (new_address);
}
}
#line 552 "/home/khheo/project/mit-scheme-9.2/src/microcode/gcloop.c"
SCHEME_OBJECT *gc_no_transport_words(SCHEME_OBJECT *from , unsigned long n_words ,
                                     _Bool align_p ) 
{ 


  {
  {
#line 554
  tospace_closed();
  }
#line 555
  return (from);
}
}
#line 558 "/home/khheo/project/mit-scheme-9.2/src/microcode/gcloop.c"
SCHEME_OBJECT *gc_handle_non_pointer(SCHEME_OBJECT *scan , SCHEME_OBJECT object ) 
{ 


  {
#line 560
  return (scan + 1);
}
}
#line 563 "/home/khheo/project/mit-scheme-9.2/src/microcode/gcloop.c"
SCHEME_OBJECT *gc_handle_cell(SCHEME_OBJECT *scan , SCHEME_OBJECT object ) 
{ 


  {
  {
#line 565
  *scan = (*(current_gc_table->tuple_handler))(object, 1U);
  }
#line 566
  return (scan + 1);
}
}
#line 569 "/home/khheo/project/mit-scheme-9.2/src/microcode/gcloop.c"
SCHEME_OBJECT *gc_handle_pair(SCHEME_OBJECT *scan , SCHEME_OBJECT object ) 
{ 


  {
  {
#line 571
  *scan = (*(current_gc_table->tuple_handler))(object, 2U);
  }
#line 572
  return (scan + 1);
}
}
#line 575 "/home/khheo/project/mit-scheme-9.2/src/microcode/gcloop.c"
SCHEME_OBJECT *gc_handle_triple(SCHEME_OBJECT *scan , SCHEME_OBJECT object ) 
{ 


  {
  {
#line 577
  *scan = (*(current_gc_table->tuple_handler))(object, 3U);
  }
#line 578
  return (scan + 1);
}
}
#line 581 "/home/khheo/project/mit-scheme-9.2/src/microcode/gcloop.c"
SCHEME_OBJECT *gc_handle_quadruple(SCHEME_OBJECT *scan , SCHEME_OBJECT object ) 
{ 


  {
  {
#line 583
  *scan = (*(current_gc_table->tuple_handler))(object, 4U);
  }
#line 584
  return (scan + 1);
}
}
#line 587 "/home/khheo/project/mit-scheme-9.2/src/microcode/gcloop.c"
SCHEME_OBJECT *gc_handle_weak_pair(SCHEME_OBJECT *scan , SCHEME_OBJECT object ) 
{ 
  SCHEME_OBJECT *new_address ;
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT tmp___0 ;

  {
  {
#line 589
  tmp = (*(current_gc_table->precheck_from))((SCHEME_OBJECT *)(object & 288230376151711743UL));
#line 589
  new_address = tmp;
  }
#line 590
  if ((unsigned long )new_address != (unsigned long )((SCHEME_OBJECT *)0)) {
#line 590
    *scan = ((object >> 58U) << 58U) | (SCHEME_OBJECT )new_address;
  } else {
    {
#line 590
    tmp___0 = gc_transport_weak_pair(object);
#line 590
    *scan = tmp___0;
    }
  }
#line 594
  return (scan + 1);
}
}
#line 597 "/home/khheo/project/mit-scheme-9.2/src/microcode/gcloop.c"
SCHEME_OBJECT *gc_handle_ephemeron(SCHEME_OBJECT *scan , SCHEME_OBJECT object ) 
{ 
  SCHEME_OBJECT *new_address ;
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT tmp___0 ;

  {
  {
#line 599
  tmp = (*(current_gc_table->precheck_from))((SCHEME_OBJECT *)(object & 288230376151711743UL));
#line 599
  new_address = tmp;
  }
#line 600
  if ((unsigned long )new_address != (unsigned long )((SCHEME_OBJECT *)0)) {
#line 600
    *scan = ((object >> 58U) << 58U) | (SCHEME_OBJECT )new_address;
  } else {
    {
#line 600
    tmp___0 = gc_transport_ephemeron(object);
#line 600
    *scan = tmp___0;
    }
  }
#line 604
  return (scan + 1);
}
}
#line 607 "/home/khheo/project/mit-scheme-9.2/src/microcode/gcloop.c"
SCHEME_OBJECT *gc_handle_cc_entry(SCHEME_OBJECT *scan , SCHEME_OBJECT object ) 
{ 


  {
  {
#line 609
  *scan = (*(current_gc_table->cc_entry_handler))(object);
  }
#line 610
  return (scan + 1);
}
}
#line 613 "/home/khheo/project/mit-scheme-9.2/src/microcode/gcloop.c"
SCHEME_OBJECT *gc_handle_aligned_vector(SCHEME_OBJECT *scan , SCHEME_OBJECT object ) 
{ 


  {
  {
#line 615
  *scan = (*(current_gc_table->vector_handler))(object, (_Bool)1);
  }
#line 616
  return (scan + 1);
}
}
#line 619 "/home/khheo/project/mit-scheme-9.2/src/microcode/gcloop.c"
SCHEME_OBJECT *gc_handle_unaligned_vector(SCHEME_OBJECT *scan , SCHEME_OBJECT object ) 
{ 


  {
  {
#line 621
  *scan = (*(current_gc_table->vector_handler))(object, (_Bool)0);
  }
#line 622
  return (scan + 1);
}
}
#line 625 "/home/khheo/project/mit-scheme-9.2/src/microcode/gcloop.c"
SCHEME_OBJECT *gc_handle_broken_heart(SCHEME_OBJECT *scan , SCHEME_OBJECT object ) 
{ 
  char *__cil_tmp3 ;

  {
  {
#line 627
  std_gc_death("broken heart in scan: %#lx", object);
  }
#line 628
  return (scan);
}
}
#line 631 "/home/khheo/project/mit-scheme-9.2/src/microcode/gcloop.c"
SCHEME_OBJECT *gc_handle_nmv(SCHEME_OBJECT *scan , SCHEME_OBJECT object ) 
{ 


  {
#line 633
  return ((scan + 1) + (object & 288230376151711743UL));
}
}
#line 636 "/home/khheo/project/mit-scheme-9.2/src/microcode/gcloop.c"
SCHEME_OBJECT *gc_handle_reference_trap(SCHEME_OBJECT *scan , SCHEME_OBJECT object ) 
{ 
  SCHEME_OBJECT tmp ;

  {
#line 638
  if ((object & 288230376151711743UL) <= 9UL) {
#line 638
    *scan = object;
  } else {
    {
#line 638
    tmp = (*(current_gc_table->tuple_handler))(object, 2U);
#line 638
    *scan = tmp;
    }
  }
#line 641
  return (scan + 1);
}
}
#line 644 "/home/khheo/project/mit-scheme-9.2/src/microcode/gcloop.c"
SCHEME_OBJECT gc_raw_address_to_object(unsigned int type , SCHEME_OBJECT *address___0 ) 
{ 


  {
#line 647
  return (((unsigned long )type << 58U) | (SCHEME_OBJECT )address___0);
}
}
#line 650 "/home/khheo/project/mit-scheme-9.2/src/microcode/gcloop.c"
SCHEME_OBJECT *gc_object_to_raw_address(SCHEME_OBJECT object ) 
{ 


  {
#line 653
  return ((SCHEME_OBJECT *)(object & 288230376151711743UL));
}
}
#line 656 "/home/khheo/project/mit-scheme-9.2/src/microcode/gcloop.c"
SCHEME_OBJECT gc_raw_address_to_cc_entry(insn_t *address___0 ) 
{ 


  {
#line 659
  return ((40UL << 58U) | (SCHEME_OBJECT )((SCHEME_OBJECT *)address___0));
}
}
#line 662 "/home/khheo/project/mit-scheme-9.2/src/microcode/gcloop.c"
insn_t *gc_cc_entry_to_raw_address(SCHEME_OBJECT entry ) 
{ 


  {
#line 665
  return ((insn_t *)((SCHEME_OBJECT *)(entry & 288230376151711743UL)));
}
}
#line 668 "/home/khheo/project/mit-scheme-9.2/src/microcode/gcloop.c"
SCHEME_OBJECT *gc_handle_linkage_section(SCHEME_OBJECT *scan , SCHEME_OBJECT object ) 
{ 
  unsigned long count ;
  unsigned long tmp ;
  linkage_section_type_t tmp___0 ;
  SCHEME_OBJECT tmp___1 ;
  SCHEME_OBJECT tmp___2 ;
  insn_t *tmp___3 ;
  SCHEME_OBJECT tmp___4 ;
  SCHEME_OBJECT tmp___5 ;
  insn_t *tmp___6 ;
  char *__cil_tmp12 ;

  {
  {
#line 671
  tmp = linkage_section_count(object);
#line 671
  count = tmp;
#line 672
  scan ++;
#line 673
  tmp___0 = linkage_section_type(object);
  }
  {
#line 676
  if ((unsigned int )tmp___0 == 2U) {
#line 676
    goto case_2;
  }
#line 676
  if ((unsigned int )tmp___0 == 1U) {
#line 676
    goto case_2;
  }
#line 693
  if ((unsigned int )tmp___0 == 3U) {
#line 693
    goto case_3;
  }
#line 693
  if ((unsigned int )tmp___0 == 0U) {
#line 693
    goto case_3;
  }
#line 711
  goto switch_default;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 677
  while (1) {
    while_continue: /* CIL Label */ ;
#line 677
    if (! (count > 0UL)) {
#line 677
      goto while_break;
    }
    {
#line 679
    tmp___1 = (*(current_gc_table->raw_address_to_object))(36U, *((SCHEME_OBJECT **)scan));
#line 679
    tmp___2 = (*(current_gc_table->tuple_handler))(tmp___1, 3U);
#line 679
    *((SCHEME_OBJECT **)scan) = (*(current_gc_table->object_to_raw_address))(tmp___2);
#line 687
    scan ++;
#line 688
    count --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 690
  goto switch_break;
  case_3: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 696
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 696
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 697
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 697
    if (! (count > 0UL)) {
#line 697
      goto while_break___1;
    }
    {
#line 699
    tmp___3 = read_uuo_target(scan);
#line 699
    tmp___4 = (*(current_gc_table->raw_address_to_cc_entry))(tmp___3);
#line 699
    tmp___5 = (*(current_gc_table->cc_entry_handler))(tmp___4);
#line 699
    tmp___6 = (*(current_gc_table->cc_entry_to_raw_address))(tmp___5);
#line 699
    write_uuo_target(tmp___6, scan);
#line 705
    scan += 3;
#line 706
    count --;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 709
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 712
  std_gc_death("Unknown linkage-section type.");
  }
#line 713
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 715
  return (scan);
}
}
#line 722 "/home/khheo/project/mit-scheme-9.2/src/microcode/gcloop.c"
SCHEME_OBJECT *gc_handle_manifest_closure(SCHEME_OBJECT *scan , SCHEME_OBJECT object ) 
{ 
  insn_t *start ;
  insn_t *tmp ;
  unsigned long count ;
  unsigned long tmp___0 ;
  insn_t *tmp___1 ;
  SCHEME_OBJECT tmp___2 ;
  SCHEME_OBJECT tmp___3 ;
  insn_t *tmp___4 ;

  {
  {
#line 727
  while (1) {
    while_continue: /* CIL Label */ ;
#line 727
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 728
  scan ++;
#line 730
  tmp = compiled_closure_start(scan);
#line 730
  start = tmp;
#line 731
  tmp___0 = compiled_closure_count(scan);
#line 731
  count = tmp___0;
  }
  {
#line 732
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 732
    if (! (count > 0UL)) {
#line 732
      goto while_break___0;
    }
    {
#line 734
    tmp___1 = read_compiled_closure_target(start);
#line 734
    tmp___2 = (*(current_gc_table->raw_address_to_cc_entry))(tmp___1);
#line 734
    tmp___3 = (*(current_gc_table->cc_entry_handler))(tmp___2);
#line 734
    tmp___4 = (*(current_gc_table->cc_entry_to_raw_address))(tmp___3);
#line 734
    write_compiled_closure_target(tmp___4, start);
#line 740
    start = compiled_closure_next(start);
#line 741
    count --;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 743
  scan = skip_compiled_closure_padding(start);
  }
#line 745
  return (scan);
}
}
#line 755 "/home/khheo/project/mit-scheme-9.2/src/microcode/gcloop.c"
SCHEME_OBJECT *gc_handle_undefined(SCHEME_OBJECT *scan , SCHEME_OBJECT object ) 
{ 


  {
  {
#line 757
  gc_bad_type(object);
  }
#line 758
  return (scan + 1);
}
}
#line 795 "/home/khheo/project/mit-scheme-9.2/src/microcode/gcloop.c"
static SCHEME_OBJECT *weak_referent_address(SCHEME_OBJECT object ) 
{ 
  gc_ptr_type_t tmp ;
  SCHEME_OBJECT *tmp___0 ;

  {
  {
#line 798
  tmp = gc_ptr_type(object);
  }
  {
#line 800
  if ((unsigned int )tmp == 0U) {
#line 800
    goto case_0;
  }
#line 803
  if ((unsigned int )tmp == 1U) {
#line 803
    goto case_1;
  }
#line 810
  goto switch_default;
  case_0: /* CIL Label */ 
#line 801
  return ((SCHEME_OBJECT *)(object & 288230376151711743UL));
  case_1: /* CIL Label */ 
  {
#line 805
  tmp___0 = cc_entry_address_to_block_address((insn_t *)((SCHEME_OBJECT *)(object & 288230376151711743UL)));
  }
#line 805
  return (tmp___0);
  switch_default: /* CIL Label */ 
#line 811
  return ((SCHEME_OBJECT *)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 815 "/home/khheo/project/mit-scheme-9.2/src/microcode/gcloop.c"
static SCHEME_OBJECT weak_referent_forward(SCHEME_OBJECT object ) 
{ 
  SCHEME_OBJECT *addr ;
  gc_ptr_type_t tmp ;
  char *__cil_tmp4 ;

  {
  {
#line 820
  tmp = gc_ptr_type(object);
  }
  {
#line 822
  if ((unsigned int )tmp == 0U) {
#line 822
    goto case_0;
  }
#line 828
  if ((unsigned int )tmp == 1U) {
#line 828
    goto case_1;
  }
#line 839
  goto switch_default;
  case_0: /* CIL Label */ 
#line 823
  addr = (SCHEME_OBJECT *)(object & 288230376151711743UL);
#line 824
  if (*addr >> 58U == 34UL) {
#line 825
    return (((object >> 58U) << 58U) | (*addr & 288230376151711743UL));
  }
#line 826
  return (0UL);
  case_1: /* CIL Label */ 
  {
#line 830
  addr = cc_entry_address_to_block_address((insn_t *)((SCHEME_OBJECT *)(object & 288230376151711743UL)));
  }
#line 831
  if (*addr >> 58U == 34UL) {
#line 832
    return (((object >> 58U) << 58U) | (SCHEME_OBJECT )((insn_t *)((SCHEME_OBJECT *)(*addr & 288230376151711743UL)) + ((insn_t *)((SCHEME_OBJECT *)(object & 288230376151711743UL)) - (insn_t *)addr)));
  }
#line 836
  return (0UL);
  switch_default: /* CIL Label */ 
  {
#line 840
  std_gc_death("Non-pointer cannot be a weak reference.");
  }
#line 841
  return (0UL);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 845 "/home/khheo/project/mit-scheme-9.2/src/microcode/gcloop.c"
static void queue_ephemerons_for_key(SCHEME_OBJECT *addr ) 
{ 
  SCHEME_OBJECT ht ;
  unsigned long index___0 ;
  SCHEME_OBJECT *entry_loc ;
  SCHEME_OBJECT entry ;
  SCHEME_OBJECT *entry_addr ;
  SCHEME_OBJECT *next_loc ;
  SCHEME_OBJECT *key_addr ;
  SCHEME_OBJECT *tmp ;

  {
#line 848
  ht = ephemeron_array;
#line 849
  index___0 = (unsigned long )addr % (*((SCHEME_OBJECT *)(ht & 288230376151711743UL) + 0) & 288230376151711743UL);
#line 850
  entry_loc = (SCHEME_OBJECT *)(ht & 288230376151711743UL) + (index___0 + 1UL);
  {
#line 861
  while (1) {
    while_continue: /* CIL Label */ ;
#line 861
    entry = *entry_loc;
#line 861
    if (! (entry >> 58U == 43UL)) {
#line 861
      goto while_break;
    }
    {
#line 863
    entry_addr = (SCHEME_OBJECT *)(entry & 288230376151711743UL);
#line 864
    next_loc = tospace_start + ((entry_addr + 4) - newspace_start);
#line 866
    tmp = weak_referent_address(*(tospace_start + ((entry_addr + 1) - newspace_start)));
#line 866
    key_addr = tmp;
    }
#line 868
    if ((unsigned long )addr == (unsigned long )key_addr) {
#line 870
      *entry_loc = *next_loc;
#line 871
      *next_loc = ephemeron_queue;
#line 872
      ephemeron_queue = entry;
    }
#line 874
    entry_loc = next_loc;
  }
  while_break: /* CIL Label */ ;
  }
#line 876
  return;
}
}
#line 878 "/home/khheo/project/mit-scheme-9.2/src/microcode/gcloop.c"
static SCHEME_OBJECT gc_transport_weak_pair(SCHEME_OBJECT pair ) 
{ 
  SCHEME_OBJECT *old_addr ;
  SCHEME_OBJECT *new_addr ;
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT old_car ;
  SCHEME_OBJECT *caddr ;
  SCHEME_OBJECT *tmp___0 ;

  {
  {
#line 881
  old_addr = (SCHEME_OBJECT *)(pair & 288230376151711743UL);
#line 882
  tmp = (*(current_gc_table->transport_words))(old_addr, 2UL, (_Bool)0);
#line 882
  new_addr = tmp;
#line 883
  old_car = *(tospace_start + (new_addr - newspace_start));
#line 884
  tmp___0 = weak_referent_address(old_car);
#line 884
  caddr = tmp___0;
  }
#line 886
  if ((unsigned long )caddr != (unsigned long )((SCHEME_OBJECT *)0)) {
#line 886
    if ((unsigned long )((void *)caddr) >= (unsigned long )((void *)*p_fromspace_start)) {
#line 886
      if ((unsigned long )((void *)caddr) < (unsigned long )((void *)*p_fromspace_end)) {
#line 888
        *(tospace_start + (new_addr - newspace_start)) = old_car & 288230376151711743UL;
#line 889
        if ((unsigned long )weak_chain == (unsigned long )((SCHEME_OBJECT *)0)) {
#line 889
          *(old_addr + 1) = (old_car >> 58U) << 58U;
        } else {
#line 889
          *(old_addr + 1) = ((old_car >> 58U) << 58U) | (SCHEME_OBJECT )weak_chain;
        }
#line 893
        weak_chain = old_addr;
      }
    }
  }
#line 898
  return (((pair >> 58U) << 58U) | (SCHEME_OBJECT )new_addr);
}
}
#line 901 "/home/khheo/project/mit-scheme-9.2/src/microcode/gcloop.c"
static SCHEME_OBJECT gc_transport_ephemeron(SCHEME_OBJECT old_ephemeron ) 
{ 
  SCHEME_OBJECT *old_addr ;
  SCHEME_OBJECT *new_addr ;
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT new_ephemeron ;
  SCHEME_OBJECT old_key ;
  SCHEME_OBJECT *old_key_addr ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT index___0 ;
  SCHEME_OBJECT ht ;
  SCHEME_OBJECT tmp___1 ;

  {
  {
#line 904
  old_addr = (SCHEME_OBJECT *)(old_ephemeron & 288230376151711743UL);
#line 905
  tmp = (*(current_gc_table->transport_words))(old_addr, 5UL, (_Bool)0);
#line 905
  new_addr = tmp;
#line 907
  new_ephemeron = ((old_ephemeron >> 58U) << 58U) | (SCHEME_OBJECT )new_addr;
#line 908
  old_key = *(tospace_start + ((new_addr + 1) - newspace_start));
#line 909
  tmp___0 = weak_referent_address(old_key);
#line 909
  old_key_addr = tmp___0;
#line 911
  ht = ephemeron_array;
#line 913
  ephemeron_count ++;
  }
#line 918
  if ((unsigned long )old_key_addr == (unsigned long )((SCHEME_OBJECT *)0)) {
#line 922
    *(tospace_start + (new_addr - newspace_start)) = 4UL;
#line 923
    return (new_ephemeron);
  } else
#line 918
  if ((unsigned long )((void *)old_key_addr) >= (unsigned long )((void *)*p_fromspace_start)) {
#line 918
    if ((unsigned long )((void *)old_key_addr) < (unsigned long )((void *)*p_fromspace_end)) {
      {
#line 918
      tmp___1 = weak_referent_forward(old_key);
      }
#line 918
      if (0UL != tmp___1) {
#line 922
        *(tospace_start + (new_addr - newspace_start)) = 4UL;
#line 923
        return (new_ephemeron);
      }
    } else {
#line 922
      *(tospace_start + (new_addr - newspace_start)) = 4UL;
#line 923
      return (new_ephemeron);
    }
  } else {
#line 922
    *(tospace_start + (new_addr - newspace_start)) = 4UL;
#line 923
    return (new_ephemeron);
  }
#line 927
  *(tospace_start + (new_addr - newspace_start)) = (39UL << 58U) | 4UL;
#line 930
  index___0 = (unsigned long )old_key_addr % (*((SCHEME_OBJECT *)(ht & 288230376151711743UL) + 0) & 288230376151711743UL);
#line 931
  *(tospace_start + ((new_addr + 4) - newspace_start)) = *((SCHEME_OBJECT *)(ht & 288230376151711743UL) + (index___0 + 1UL));
#line 932
  *((SCHEME_OBJECT *)(ht & 288230376151711743UL) + (index___0 + 1UL)) = new_ephemeron;
#line 935
  *(tospace_start + ((new_addr + 3) - newspace_start)) = ephemeron_list;
#line 936
  ephemeron_list = new_ephemeron;
#line 938
  return (new_ephemeron);
}
}
#line 941 "/home/khheo/project/mit-scheme-9.2/src/microcode/gcloop.c"
static void scan_newspace_addr(SCHEME_OBJECT *addr ) 
{ 
  gc_ignore_object_p_t *ignore_object_p ;
  SCHEME_OBJECT *scan ;
  SCHEME_OBJECT object ;
  _Bool tmp ;

  {
#line 944
  ignore_object_p = current_gc_table->ignore_object_p;
#line 949
  addr = tospace_start + (addr - newspace_start);
#line 950
  scan = addr;
  {
#line 952
  while (1) {
    while_continue: /* CIL Label */ ;
#line 952
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 953
  object = *scan;
  {
#line 954
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 954
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 955
  if ((unsigned long )ignore_object_p != (unsigned long )((gc_ignore_object_p_t *)0)) {
    {
#line 955
    tmp = (*ignore_object_p)(object);
    }
#line 955
    if (tmp) {
#line 956
      return;
    }
  }
  {
#line 958
  current_scan = scan;
#line 959
  current_object = object;
#line 960
  scan = (*(current_gc_table->handlers[object >> 58U]))(scan, object);
  }
#line 968
  return;
}
}
#line 970 "/home/khheo/project/mit-scheme-9.2/src/microcode/gcloop.c"
static void scan_ephemerons(void) 
{ 
  SCHEME_OBJECT ephemeron ;
  SCHEME_OBJECT *saved_newspace_next ;
  SCHEME_OBJECT *ephemeron_addr ;
  SCHEME_OBJECT old_key ;
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT tmp___0 ;
  SCHEME_OBJECT *ephemeron_addr___0 ;

  {
#line 973
  ephemeron = ephemeron_list;
#line 975
  scanning_ephemerons_p = (_Bool)1;
  {
#line 976
  while (1) {
    while_continue: /* CIL Label */ ;
#line 976
    if (! (ephemeron >> 58U == 43UL)) {
#line 976
      goto while_break;
    }
    {
#line 978
    ephemeron_addr = (SCHEME_OBJECT *)(ephemeron & 288230376151711743UL);
#line 979
    old_key = *(tospace_start + ((ephemeron_addr + 1) - newspace_start));
#line 980
    ephemeron = *(tospace_start + ((ephemeron_addr + 3) - newspace_start));
#line 989
    tmp___0 = weak_referent_forward(old_key);
    }
#line 989
    if (0UL != tmp___0) {
      {
#line 990
      tmp = weak_referent_address(old_key);
#line 990
      queue_ephemerons_for_key(tmp);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 992
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 992
    ephemeron = ephemeron_queue;
#line 992
    if (! (ephemeron >> 58U == 43UL)) {
#line 992
      goto while_break___0;
    }
    {
#line 994
    ephemeron_addr___0 = (SCHEME_OBJECT *)(ephemeron & 288230376151711743UL);
#line 1003
    ephemeron_queue = *(tospace_start + ((ephemeron_addr___0 + 4) - newspace_start));
#line 1004
    saved_newspace_next = newspace_next;
#line 1005
    scan_newspace_addr(ephemeron_addr___0 + 2);
#line 1006
    gc_scan_tospace(saved_newspace_next, (SCHEME_OBJECT *)0);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1008
  scanning_ephemerons_p = (_Bool)0;
#line 1009
  return;
}
}
#line 1011 "/home/khheo/project/mit-scheme-9.2/src/microcode/gcloop.c"
void initialize_weak_chain(void) 
{ 


  {
#line 1014
  weak_chain = (SCHEME_OBJECT *)0;
#line 1021
  return;
}
}
#line 1023 "/home/khheo/project/mit-scheme-9.2/src/microcode/gcloop.c"
static void update_ephemerons(void) 
{ 
  SCHEME_OBJECT ephemeron ;
  SCHEME_OBJECT *ephemeron_addr ;
  SCHEME_OBJECT *key_loc ;
  SCHEME_OBJECT old_key ;
  SCHEME_OBJECT new_key ;
  SCHEME_OBJECT tmp ;

  {
#line 1026
  ephemeron = ephemeron_list;
  {
#line 1027
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1027
    if (! (ephemeron >> 58U == 43UL)) {
#line 1027
      goto while_break;
    }
    {
#line 1029
    ephemeron_addr = (SCHEME_OBJECT *)(ephemeron & 288230376151711743UL);
#line 1030
    key_loc = ephemeron_addr + 1;
#line 1031
    old_key = *(tospace_start + (key_loc - newspace_start));
#line 1032
    tmp = weak_referent_forward(old_key);
#line 1032
    new_key = tmp;
#line 1033
    *(tospace_start + (ephemeron_addr - newspace_start)) = 4UL;
#line 1034
    *(tospace_start + (key_loc - newspace_start)) = new_key;
#line 1036
    ephemeron = *(tospace_start + ((ephemeron_addr + 3) - newspace_start));
#line 1037
    *(tospace_start + ((ephemeron_addr + 3) - newspace_start)) = 0UL;
#line 1038
    *(tospace_start + ((ephemeron_addr + 4) - newspace_start)) = 0UL;
    }
#line 1039
    if (new_key == 0UL) {
#line 1040
      *(tospace_start + ((ephemeron_addr + 2) - newspace_start)) = 0UL;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1042
  ephemeron_list = 0UL;
#line 1043
  return;
}
}
#line 1045 "/home/khheo/project/mit-scheme-9.2/src/microcode/gcloop.c"
static void update_weak_pairs(void) 
{ 
  SCHEME_OBJECT *new_addr ;
  SCHEME_OBJECT obj ;
  SCHEME_OBJECT old_car ;

  {
  {
#line 1054
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1054
    if (! ((unsigned long )weak_chain != (unsigned long )((SCHEME_OBJECT *)0))) {
#line 1054
      goto while_break;
    }
    {
#line 1056
    new_addr = (SCHEME_OBJECT *)(*(weak_chain + 0) & 288230376151711743UL);
#line 1057
    obj = *(weak_chain + 1);
#line 1058
    old_car = ((obj >> 58U) << 58U) | (*(tospace_start + (new_addr - newspace_start)) & 288230376151711743UL);
#line 1062
    *(tospace_start + (new_addr - newspace_start)) = weak_referent_forward(old_car);
    }
#line 1063
    if ((obj & 288230376151711743UL) == 0UL) {
#line 1063
      weak_chain = (SCHEME_OBJECT *)0;
    } else {
#line 1063
      weak_chain = (SCHEME_OBJECT *)(obj & 288230376151711743UL);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1065
  return;
}
}
#line 1067 "/home/khheo/project/mit-scheme-9.2/src/microcode/gcloop.c"
void update_weak_pointers(void) 
{ 


  {
  {
#line 1070
  scan_ephemerons();
#line 1071
  update_ephemerons();
#line 1072
  update_weak_pairs();
  }
#line 1073
  return;
}
}
#line 1075
 __attribute__((__noreturn__)) void ( /* format attribute */  std_gc_death)(char const   *format 
                                                                            , ...) ;
#line 1075 "/home/khheo/project/mit-scheme-9.2/src/microcode/gcloop.c"
void ( /* format attribute */  std_gc_death)(char const   *format  , ...) 
{ 
  va_list ap ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 1080
  __builtin_va_start(ap, format);
#line 1081
  outf_fatal("\n");
#line 1082
  voutf_fatal(format, ap);
#line 1083
  outf_fatal("\n");
  }
#line 1084
  if ((unsigned long )current_scan != (unsigned long )((SCHEME_OBJECT *)0)) {
    {
#line 1086
    outf_fatal("scan = 0x%lx", (unsigned long )current_scan);
    }
#line 1087
    if ((unsigned long )tospace_next != (unsigned long )((SCHEME_OBJECT *)0)) {
      {
#line 1088
      outf_fatal("; to = 0x%lx", (unsigned long )tospace_next);
      }
    }
    {
#line 1089
    outf_fatal("\n");
    }
  }
  {
#line 1091
  __builtin_va_end(ap);
  }
#line 1092
  if ((unsigned long )gc_abort_handler != (unsigned long )((gc_abort_handler_t *)0)) {
    {
#line 1093
    (*gc_abort_handler)();
    }
  }
  {
#line 1094
  exit(1);
  }
}
}
#line 1097
static  __attribute__((__noreturn__)) void tospace_closed(void) ;
#line 1097 "/home/khheo/project/mit-scheme-9.2/src/microcode/gcloop.c"
static void tospace_closed(void) 
{ 
  char *__cil_tmp1 ;

  {
  {
#line 1100
  std_gc_death("GC transport not allowed here");
  }
}
}
#line 1103
static  __attribute__((__noreturn__)) void tospace_open(void) ;
#line 1103 "/home/khheo/project/mit-scheme-9.2/src/microcode/gcloop.c"
static void tospace_open(void) 
{ 
  char *__cil_tmp1 ;

  {
  {
#line 1106
  std_gc_death("tospace is open, should be closed");
  }
}
}
#line 1109
 __attribute__((__noreturn__)) void gc_no_cc_support(void) ;
#line 1109 "/home/khheo/project/mit-scheme-9.2/src/microcode/gcloop.c"
void gc_no_cc_support(void) 
{ 
  char *__cil_tmp1 ;

  {
  {
#line 1112
  std_gc_death("No compiled-code support.");
  }
}
}
#line 1115
 __attribute__((__noreturn__)) void gc_bad_type(SCHEME_OBJECT object ) ;
#line 1115 "/home/khheo/project/mit-scheme-9.2/src/microcode/gcloop.c"
void gc_bad_type(SCHEME_OBJECT object ) 
{ 
  char *__cil_tmp2 ;

  {
  {
#line 1118
  std_gc_death("bad type code: %#02lx %#lx", object >> 58U, object);
  }
}
}
#line 1245 "/home/khheo/project/mit-scheme-9.2/src/microcode/gcloop.c"
gc_type_t gc_type_map[64]  = 
#line 1245
  {      (gc_type_t )0,      (gc_type_t )2,      (gc_type_t )0,      (gc_type_t )2, 
        (gc_type_t )3,      (gc_type_t )2,      (gc_type_t )-3,      (gc_type_t )2, 
        (gc_type_t )0,      (gc_type_t )2,      (gc_type_t )-3,      (gc_type_t )0, 
        (gc_type_t )3,      (gc_type_t )-2,      (gc_type_t )-3,      (gc_type_t )2, 
        (gc_type_t )2,      (gc_type_t )2,      (gc_type_t )-3,      (gc_type_t )2, 
        (gc_type_t )3,      (gc_type_t )2,      (gc_type_t )-3,      (gc_type_t )2, 
        (gc_type_t )0,      (gc_type_t )2,      (gc_type_t )0,      (gc_type_t )2, 
        (gc_type_t )-3,      (gc_type_t )2,      (gc_type_t )-3,      (gc_type_t )2, 
        (gc_type_t )3,      (gc_type_t )2,      (gc_type_t )-2,      (gc_type_t )2, 
        (gc_type_t )3,      (gc_type_t )-1,      (gc_type_t )-3,      (gc_type_t )-2, 
        (gc_type_t )-4,      (gc_type_t )2,      (gc_type_t )-3,      (gc_type_t )-3, 
        (gc_type_t )3,      (gc_type_t )0,      (gc_type_t )2,      (gc_type_t )-3, 
        (gc_type_t )0,      (gc_type_t )-3,      (gc_type_t )-2,      (gc_type_t )-1, 
        (gc_type_t )3,      (gc_type_t )2,      (gc_type_t )1,      (gc_type_t )2, 
        (gc_type_t )4,      (gc_type_t )-2,      (gc_type_t )2,      (gc_type_t )0, 
        (gc_type_t )2,      (gc_type_t )-3,      (gc_type_t )-3,      (gc_type_t )-1};
#line 1317 "/home/khheo/project/mit-scheme-9.2/src/microcode/gcloop.c"
gc_type_t gc_type_code(unsigned int type_code ) 
{ 


  {
#line 1320
  return (gc_type_map[type_code]);
}
}
#line 1323 "/home/khheo/project/mit-scheme-9.2/src/microcode/gcloop.c"
gc_ptr_type_t gc_ptr_type(SCHEME_OBJECT object ) 
{ 
  gc_type_t tmp ;
  int tmp___0 ;

  {
  {
#line 1326
  tmp = gc_type_code((unsigned int )(object >> 58U));
  }
  {
#line 1328
  if ((int )tmp == -2) {
#line 1328
    goto case_neg_2;
  }
#line 1339
  if ((int )tmp == -3) {
#line 1339
    goto case_neg_3;
  }
#line 1339
  if ((int )tmp == 4) {
#line 1339
    goto case_neg_3;
  }
#line 1339
  if ((int )tmp == 3) {
#line 1339
    goto case_neg_3;
  }
#line 1339
  if ((int )tmp == 2) {
#line 1339
    goto case_neg_3;
  }
#line 1339
  if ((int )tmp == 1) {
#line 1339
    goto case_neg_3;
  }
#line 1342
  if ((int )tmp == -4) {
#line 1342
    goto case_neg_4;
  }
#line 1346
  goto switch_default;
  case_neg_2: /* CIL Label */ 
#line 1329
  if (object >> 58U == 50UL) {
#line 1329
    if ((object & 288230376151711743UL) >= 9UL) {
#line 1329
      tmp___0 = 0;
    } else {
#line 1329
      tmp___0 = 2;
    }
  } else {
#line 1329
    tmp___0 = 2;
  }
#line 1329
  return ((gc_ptr_type_t )tmp___0);
  case_neg_3: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 1340
  return ((gc_ptr_type_t )0);
  case_neg_4: /* CIL Label */ 
#line 1343
  return ((gc_ptr_type_t )1);
#line 1344
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1347
  return ((gc_ptr_type_t )2);
  switch_break: /* CIL Label */ ;
  }
#line 1349
  return ((enum __anonenum_gc_ptr_type_t_33 )0);
}
}
#line 1351 "/home/khheo/project/mit-scheme-9.2/src/microcode/gcloop.c"
SCHEME_OBJECT *get_object_address(SCHEME_OBJECT object ) 
{ 
  gc_ptr_type_t tmp ;
  SCHEME_OBJECT *tmp___0 ;

  {
  {
#line 1354
  tmp = gc_ptr_type(object);
  }
  {
#line 1356
  if ((unsigned int )tmp == 0U) {
#line 1356
    goto case_0;
  }
#line 1359
  if ((unsigned int )tmp == 1U) {
#line 1359
    goto case_1;
  }
#line 1364
  goto switch_default;
  case_0: /* CIL Label */ 
#line 1357
  return ((SCHEME_OBJECT *)(object & 288230376151711743UL));
  case_1: /* CIL Label */ 
  {
#line 1361
  tmp___0 = cc_entry_to_block_address(object);
  }
#line 1361
  return (tmp___0);
  switch_default: /* CIL Label */ 
#line 1365
  return ((SCHEME_OBJECT *)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 54 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) acos)(double __x ) ;
#line 56
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) asin)(double __x ) ;
#line 58
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) atan)(double __x ) ;
#line 60
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) atan2)(double __y ,
                                                                               double __x ) ;
#line 63
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) cos)(double __x ) ;
#line 65
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) sin)(double __x ) ;
#line 67
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) tan)(double __x ) ;
#line 100
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) exp)(double __x ) ;
#line 109
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) log)(double __x ) ;
#line 128
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) expm1)(double __x ) ;
#line 131
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) log1p)(double __x ) ;
#line 153
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) pow)(double __x ,
                                                                             double __y ) ;
#line 156
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) sqrt)(double __x ) ;
#line 187
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) fmod)(double __x ,
                                                                              double __y ) ;
#line 216 "/home/khheo/project/mit-scheme-9.2/src/microcode/extern.h"
uintmax_t integer_to_uintmax(SCHEME_OBJECT n ) ;
#line 222
double double_truncate(double x ) ;
#line 227
_Bool finite_flonum_p(SCHEME_OBJECT x ) ;
#line 229
_Bool flonum_integer_p(SCHEME_OBJECT x ) ;
#line 230
SCHEME_OBJECT flonum_floor(SCHEME_OBJECT x ) ;
#line 231
SCHEME_OBJECT flonum_ceiling(SCHEME_OBJECT x ) ;
#line 232
SCHEME_OBJECT flonum_round(SCHEME_OBJECT x ) ;
#line 233
SCHEME_OBJECT flonum_normalize(SCHEME_OBJECT x ) ;
#line 234
SCHEME_OBJECT flonum_denormalize(SCHEME_OBJECT x , SCHEME_OBJECT e ) ;
#line 34 "/home/khheo/project/mit-scheme-9.2/src/microcode/flonum.c"
double arg_flonum(int arg_number ) 
{ 
  SCHEME_OBJECT argument ;

  {
#line 37
  argument = *(stack_pointer + (arg_number - 1));
#line 38
  if (! (argument >> 58U == 6UL)) {
    {
#line 39
    error_wrong_type_arg(arg_number);
    }
  }
#line 40
  return (*((double *)((SCHEME_OBJECT *)(argument & 288230376151711743UL) + 1)));
}
}
#line 46 "/home/khheo/project/mit-scheme-9.2/src/microcode/flonum.c"
SCHEME_OBJECT double_to_flonum(double value ) 
{ 
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;
  SCHEME_OBJECT *tmp___2 ;
  SCHEME_OBJECT result ;
  SCHEME_OBJECT *tmp___3 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 49
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 49
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 49
      goto while_break___0;
#line 49
      tmp = Free;
#line 49
      Free ++;
#line 49
      *tmp = 39UL << 58U;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 49
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 50
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 50
    if ((unsigned long )Free >= (unsigned long )heap_start) {
#line 50
      if ((unsigned long )Free < (unsigned long )heap_alloc_limit) {
#line 50
        if (! ((unsigned long )(Free + ((sizeof(double ) + (sizeof(SCHEME_OBJECT ) - 1UL)) / sizeof(SCHEME_OBJECT ) + 1UL)) <= (unsigned long )heap_alloc_limit)) {
#line 50
          goto _L___0;
        }
      } else {
#line 50
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 50
    if ((Registers[1] & 4UL) != 0UL) {
      {
#line 50
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 50
        if ((unsigned long )Free_primitive < (unsigned long )heap_start) {
          {
#line 50
          outf_fatal("\nMicrocode requested primitive GC outside primitive!\n");
#line 50
          Microcode_Termination(12);
          }
        }
#line 50
        if ((unsigned long )Free < (unsigned long )Free_primitive) {
          {
#line 50
          outf_fatal("\nFree has gone backwards!\n");
#line 50
          Microcode_Termination(12);
          }
        }
        {
#line 50
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 50
          while (1) {
            while_continue___4: /* CIL Label */ ;
            {
#line 50
            set_ulong_register(12U, Registers[12] | 4UL);
            }
            {
#line 50
            while (1) {
              while_continue___5: /* CIL Label */ ;
#line 50
              if ((Registers[1] & Registers[12]) != 0UL) {
#line 50
                tmp___1 = memory_block_start;
              } else {
#line 50
                if ((Registers[1] & 4UL) != 0UL) {
#line 50
                  tmp___0 = heap_alloc_limit;
                } else {
#line 50
                  tmp___0 = heap_end;
                }
#line 50
                tmp___1 = tmp___0;
              }
              {
#line 50
              set_ptr_register(0U, tmp___1);
              }
#line 50
              if ((Registers[1] & 1UL) != 0UL) {
#line 50
                tmp___2 = stack_guard;
              } else {
#line 50
                tmp___2 = stack_start;
              }
              {
#line 50
              set_ptr_register(11U, tmp___2);
              }
#line 50
              goto while_break___5;
            }
            while_break___5: /* CIL Label */ ;
            }
#line 50
            goto while_break___4;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 50
          gc_space_needed = ((sizeof(double ) + (sizeof(SCHEME_OBJECT ) - 1UL)) / sizeof(SCHEME_OBJECT ) + 1UL) + (unsigned long )(Free - Free_primitive);
#line 50
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 50
        signal_interrupt_from_primitive();
        }
#line 50
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 50
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 52
  result = (6UL << 58U) | (SCHEME_OBJECT )Free;
#line 53
  tmp___3 = Free;
#line 53
  Free ++;
#line 53
  *tmp___3 = (39UL << 58U) | (sizeof(double ) + (sizeof(SCHEME_OBJECT ) - 1UL)) / sizeof(SCHEME_OBJECT );
#line 54
  *((double *)Free) = value;
#line 55
  Free += (sizeof(double ) + (sizeof(SCHEME_OBJECT ) - 1UL)) / sizeof(SCHEME_OBJECT );
#line 56
  return (result);
}
}
#line 66 "/home/khheo/project/mit-scheme-9.2/src/microcode/flonum.c"
SCHEME_OBJECT Prim_flonum_add(void) 
{ 
  double tmp ;
  double tmp___0 ;
  SCHEME_OBJECT tmp___1 ;

  {
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
#line 67
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 67
  tmp = arg_flonum(1);
#line 67
  tmp___0 = arg_flonum(2);
#line 67
  tmp___1 = double_to_flonum(tmp + tmp___0);
  }
#line 67
  return (tmp___1);
}
}
#line 68 "/home/khheo/project/mit-scheme-9.2/src/microcode/flonum.c"
SCHEME_OBJECT Prim_flonum_subtract(void) 
{ 
  double tmp ;
  double tmp___0 ;
  SCHEME_OBJECT tmp___1 ;

  {
  {
#line 69
  while (1) {
    while_continue: /* CIL Label */ ;
#line 69
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 69
  tmp = arg_flonum(1);
#line 69
  tmp___0 = arg_flonum(2);
#line 69
  tmp___1 = double_to_flonum(tmp - tmp___0);
  }
#line 69
  return (tmp___1);
}
}
#line 70 "/home/khheo/project/mit-scheme-9.2/src/microcode/flonum.c"
SCHEME_OBJECT Prim_flonum_multiply(void) 
{ 
  double tmp ;
  double tmp___0 ;
  SCHEME_OBJECT tmp___1 ;

  {
  {
#line 71
  while (1) {
    while_continue: /* CIL Label */ ;
#line 71
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 71
  tmp = arg_flonum(1);
#line 71
  tmp___0 = arg_flonum(2);
#line 71
  tmp___1 = double_to_flonum(tmp * tmp___0);
  }
#line 71
  return (tmp___1);
}
}
#line 73 "/home/khheo/project/mit-scheme-9.2/src/microcode/flonum.c"
SCHEME_OBJECT Prim_flonum_divide(void) 
{ 
  double denominator ;
  double tmp ;
  double tmp___0 ;
  SCHEME_OBJECT tmp___1 ;

  {
  {
#line 75
  while (1) {
    while_continue: /* CIL Label */ ;
#line 75
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 77
  tmp = arg_flonum(2);
#line 77
  denominator = tmp;
  }
#line 78
  if (denominator == (double )0) {
    {
#line 79
    error_bad_range_arg(2);
    }
  }
  {
#line 80
  tmp___0 = arg_flonum(1);
#line 80
  tmp___1 = double_to_flonum(tmp___0 / denominator);
  }
#line 80
  return (tmp___1);
}
}
#line 84 "/home/khheo/project/mit-scheme-9.2/src/microcode/flonum.c"
SCHEME_OBJECT Prim_flonum_modulo(void) 
{ 
  double denominator ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  SCHEME_OBJECT tmp___2 ;

  {
  {
#line 87
  while (1) {
    while_continue: /* CIL Label */ ;
#line 87
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 89
  tmp = arg_flonum(2);
#line 89
  denominator = tmp;
  }
#line 90
  if (denominator == (double )0) {
    {
#line 91
    error_bad_range_arg(2);
    }
  }
  {
#line 92
  tmp___0 = arg_flonum(1);
#line 92
  tmp___1 = fmod(tmp___0, denominator);
#line 92
  tmp___2 = double_to_flonum(tmp___1);
  }
#line 92
  return (tmp___2);
}
}
#line 102 "/home/khheo/project/mit-scheme-9.2/src/microcode/flonum.c"
SCHEME_OBJECT Prim_flonum_negate(void) 
{ 
  double tmp ;
  SCHEME_OBJECT tmp___0 ;

  {
  {
#line 104
  while (1) {
    while_continue: /* CIL Label */ ;
#line 104
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 105
  tmp = arg_flonum(1);
#line 105
  tmp___0 = double_to_flonum(- tmp);
  }
#line 105
  return (tmp___0);
}
}
#line 108 "/home/khheo/project/mit-scheme-9.2/src/microcode/flonum.c"
SCHEME_OBJECT Prim_flonum_abs(void) 
{ 
  double x ;
  double tmp ;
  double tmp___0 ;
  SCHEME_OBJECT tmp___1 ;

  {
  {
#line 110
  while (1) {
    while_continue: /* CIL Label */ ;
#line 110
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 112
  tmp = arg_flonum(1);
#line 112
  x = tmp;
  }
#line 113
  if (x < (double )0) {
#line 113
    tmp___0 = - x;
  } else {
#line 113
    tmp___0 = x;
  }
  {
#line 113
  tmp___1 = double_to_flonum(tmp___0);
  }
#line 113
  return (tmp___1);
}
}
#line 123 "/home/khheo/project/mit-scheme-9.2/src/microcode/flonum.c"
SCHEME_OBJECT Prim_flonum_equal_p(void) 
{ 
  unsigned long tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;

  {
  {
#line 124
  while (1) {
    while_continue: /* CIL Label */ ;
#line 124
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 124
  tmp___2 = arg_flonum(1);
#line 124
  tmp___3 = arg_flonum(2);
  }
#line 124
  if (tmp___2 == tmp___3) {
#line 124
    tmp___1 = 8UL << 58U;
  } else {
#line 124
    tmp___1 = 0UL;
  }
#line 124
  return (tmp___1);
}
}
#line 125 "/home/khheo/project/mit-scheme-9.2/src/microcode/flonum.c"
SCHEME_OBJECT Prim_flonum_less_p(void) 
{ 
  unsigned long tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;

  {
  {
#line 126
  while (1) {
    while_continue: /* CIL Label */ ;
#line 126
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 126
  tmp___2 = arg_flonum(1);
#line 126
  tmp___3 = arg_flonum(2);
  }
#line 126
  if (tmp___2 < tmp___3) {
#line 126
    tmp___1 = 8UL << 58U;
  } else {
#line 126
    tmp___1 = 0UL;
  }
#line 126
  return (tmp___1);
}
}
#line 127 "/home/khheo/project/mit-scheme-9.2/src/microcode/flonum.c"
SCHEME_OBJECT Prim_flonum_greater_p(void) 
{ 
  unsigned long tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;

  {
  {
#line 128
  while (1) {
    while_continue: /* CIL Label */ ;
#line 128
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 128
  tmp___2 = arg_flonum(1);
#line 128
  tmp___3 = arg_flonum(2);
  }
#line 128
  if (tmp___2 > tmp___3) {
#line 128
    tmp___1 = 8UL << 58U;
  } else {
#line 128
    tmp___1 = 0UL;
  }
#line 128
  return (tmp___1);
}
}
#line 136 "/home/khheo/project/mit-scheme-9.2/src/microcode/flonum.c"
SCHEME_OBJECT Prim_flonum_zero_p(void) 
{ 
  unsigned long tmp___0 ;
  double tmp___1 ;

  {
  {
#line 137
  while (1) {
    while_continue: /* CIL Label */ ;
#line 137
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 137
  tmp___1 = arg_flonum(1);
  }
#line 137
  if (tmp___1 == (double )0) {
#line 137
    tmp___0 = 8UL << 58U;
  } else {
#line 137
    tmp___0 = 0UL;
  }
#line 137
  return (tmp___0);
}
}
#line 138 "/home/khheo/project/mit-scheme-9.2/src/microcode/flonum.c"
SCHEME_OBJECT Prim_flonum_positive_p(void) 
{ 
  unsigned long tmp___0 ;
  double tmp___1 ;

  {
  {
#line 139
  while (1) {
    while_continue: /* CIL Label */ ;
#line 139
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 139
  tmp___1 = arg_flonum(1);
  }
#line 139
  if (tmp___1 > (double )0) {
#line 139
    tmp___0 = 8UL << 58U;
  } else {
#line 139
    tmp___0 = 0UL;
  }
#line 139
  return (tmp___0);
}
}
#line 140 "/home/khheo/project/mit-scheme-9.2/src/microcode/flonum.c"
SCHEME_OBJECT Prim_flonum_negative_p(void) 
{ 
  unsigned long tmp___0 ;
  double tmp___1 ;

  {
  {
#line 141
  while (1) {
    while_continue: /* CIL Label */ ;
#line 141
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 141
  tmp___1 = arg_flonum(1);
  }
#line 141
  if (tmp___1 < (double )0) {
#line 141
    tmp___0 = 8UL << 58U;
  } else {
#line 141
    tmp___0 = 0UL;
  }
#line 141
  return (tmp___0);
}
}
#line 169 "/home/khheo/project/mit-scheme-9.2/src/microcode/flonum.c"
SCHEME_OBJECT Prim_flonum_expm1(void) 
{ 
  double x ;
  double result ;
  int *tmp ;
  int *tmp___0 ;
  SCHEME_OBJECT tmp___1 ;

  {
  {
#line 171
  while (1) {
    while_continue: /* CIL Label */ ;
#line 171
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 171
  x = arg_flonum(1);
  }
#line 171
  if (x >= - 0.69314718055994530942) {
#line 171
    if (! (x <= 0.69314718055994530942)) {
      {
#line 171
      error_bad_range_arg(1);
      }
    }
  } else {
    {
#line 171
    error_bad_range_arg(1);
    }
  }
  {
#line 171
  tmp = __errno_location();
#line 171
  *tmp = 0;
#line 171
  result = expm1(x);
#line 171
  tmp___0 = __errno_location();
  }
#line 171
  if (*tmp___0 != 0) {
    {
#line 171
    error_bad_range_arg(1);
    }
  }
  {
#line 171
  tmp___1 = double_to_flonum(result);
  }
#line 171
  return (tmp___1);
}
}
#line 180 "/home/khheo/project/mit-scheme-9.2/src/microcode/flonum.c"
SCHEME_OBJECT Prim_flonum_log1p(void) 
{ 
  double x ;
  double result ;
  int *tmp ;
  int *tmp___0 ;
  SCHEME_OBJECT tmp___1 ;

  {
  {
#line 182
  while (1) {
    while_continue: /* CIL Label */ ;
#line 182
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 182
  x = arg_flonum(1);
  }
#line 182
  if (x >= 0.70710678118654752440 - 1.0) {
#line 182
    if (! (x <= 1.0 - 0.70710678118654752440)) {
      {
#line 182
      error_bad_range_arg(1);
      }
    }
  } else {
    {
#line 182
    error_bad_range_arg(1);
    }
  }
  {
#line 182
  tmp = __errno_location();
#line 182
  *tmp = 0;
#line 182
  result = log1p(x);
#line 182
  tmp___0 = __errno_location();
  }
#line 182
  if (*tmp___0 != 0) {
    {
#line 182
    error_bad_range_arg(1);
    }
  }
  {
#line 182
  tmp___1 = double_to_flonum(result);
  }
#line 182
  return (tmp___1);
}
}
#line 191 "/home/khheo/project/mit-scheme-9.2/src/microcode/flonum.c"
SCHEME_OBJECT Prim_flonum_log(void) 
{ 
  double x ;
  double result ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  SCHEME_OBJECT tmp___2 ;

  {
  {
#line 195
  while (1) {
    while_continue: /* CIL Label */ ;
#line 195
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 196
  x = arg_flonum(1);
  }
#line 197
  if (! (x >= (double )0)) {
    {
#line 198
    error_bad_range_arg(1);
    }
  }
  {
#line 199
  tmp = __errno_location();
#line 199
  *tmp = 0;
#line 200
  result = log(x);
#line 201
  tmp___0 = __errno_location();
  }
#line 201
  if (*tmp___0 != 0) {
#line 201
    if (x != (double )0) {
      {
#line 202
      error_bad_range_arg(1);
      }
    } else {
      {
#line 201
      tmp___1 = __errno_location();
      }
#line 201
      if (*tmp___1 != 34) {
        {
#line 202
        error_bad_range_arg(1);
        }
      }
    }
  }
  {
#line 203
  tmp___2 = double_to_flonum(result);
  }
#line 203
  return (tmp___2);
}
}
#line 206 "/home/khheo/project/mit-scheme-9.2/src/microcode/flonum.c"
SCHEME_OBJECT Prim_flonum_exp(void) 
{ 
  double result ;
  int *tmp ;
  double tmp___0 ;
  int *tmp___1 ;
  SCHEME_OBJECT tmp___2 ;

  {
  {
#line 207
  while (1) {
    while_continue: /* CIL Label */ ;
#line 207
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 207
  tmp = __errno_location();
#line 207
  *tmp = 0;
#line 207
  tmp___0 = arg_flonum(1);
#line 207
  result = exp(tmp___0);
#line 207
  tmp___1 = __errno_location();
  }
#line 207
  if (*tmp___1 != 0) {
    {
#line 207
    error_bad_range_arg(1);
    }
  }
  {
#line 207
  tmp___2 = double_to_flonum(result);
  }
#line 207
  return (tmp___2);
}
}
#line 208 "/home/khheo/project/mit-scheme-9.2/src/microcode/flonum.c"
SCHEME_OBJECT Prim_flonum_sin(void) 
{ 
  double result ;
  int *tmp ;
  double tmp___0 ;
  int *tmp___1 ;
  SCHEME_OBJECT tmp___2 ;

  {
  {
#line 209
  while (1) {
    while_continue: /* CIL Label */ ;
#line 209
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 209
  tmp = __errno_location();
#line 209
  *tmp = 0;
#line 209
  tmp___0 = arg_flonum(1);
#line 209
  result = sin(tmp___0);
#line 209
  tmp___1 = __errno_location();
  }
#line 209
  if (*tmp___1 != 0) {
    {
#line 209
    error_bad_range_arg(1);
    }
  }
  {
#line 209
  tmp___2 = double_to_flonum(result);
  }
#line 209
  return (tmp___2);
}
}
#line 210 "/home/khheo/project/mit-scheme-9.2/src/microcode/flonum.c"
SCHEME_OBJECT Prim_flonum_cos(void) 
{ 
  double result ;
  int *tmp ;
  double tmp___0 ;
  int *tmp___1 ;
  SCHEME_OBJECT tmp___2 ;

  {
  {
#line 211
  while (1) {
    while_continue: /* CIL Label */ ;
#line 211
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 211
  tmp = __errno_location();
#line 211
  *tmp = 0;
#line 211
  tmp___0 = arg_flonum(1);
#line 211
  result = cos(tmp___0);
#line 211
  tmp___1 = __errno_location();
  }
#line 211
  if (*tmp___1 != 0) {
    {
#line 211
    error_bad_range_arg(1);
    }
  }
  {
#line 211
  tmp___2 = double_to_flonum(result);
  }
#line 211
  return (tmp___2);
}
}
#line 212 "/home/khheo/project/mit-scheme-9.2/src/microcode/flonum.c"
SCHEME_OBJECT Prim_flonum_tan(void) 
{ 
  double result ;
  int *tmp ;
  double tmp___0 ;
  int *tmp___1 ;
  SCHEME_OBJECT tmp___2 ;

  {
  {
#line 213
  while (1) {
    while_continue: /* CIL Label */ ;
#line 213
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 213
  tmp = __errno_location();
#line 213
  *tmp = 0;
#line 213
  tmp___0 = arg_flonum(1);
#line 213
  result = tan(tmp___0);
#line 213
  tmp___1 = __errno_location();
  }
#line 213
  if (*tmp___1 != 0) {
    {
#line 213
    error_bad_range_arg(1);
    }
  }
  {
#line 213
  tmp___2 = double_to_flonum(result);
  }
#line 213
  return (tmp___2);
}
}
#line 214 "/home/khheo/project/mit-scheme-9.2/src/microcode/flonum.c"
SCHEME_OBJECT Prim_flonum_asin(void) 
{ 
  double x ;
  double result ;
  int *tmp ;
  int *tmp___0 ;
  SCHEME_OBJECT tmp___1 ;

  {
  {
#line 215
  while (1) {
    while_continue: /* CIL Label */ ;
#line 215
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 215
  x = arg_flonum(1);
  }
#line 215
  if (x >= (double )-1) {
#line 215
    if (! (x <= (double )1)) {
      {
#line 215
      error_bad_range_arg(1);
      }
    }
  } else {
    {
#line 215
    error_bad_range_arg(1);
    }
  }
  {
#line 215
  tmp = __errno_location();
#line 215
  *tmp = 0;
#line 215
  result = asin(x);
#line 215
  tmp___0 = __errno_location();
  }
#line 215
  if (*tmp___0 != 0) {
    {
#line 215
    error_bad_range_arg(1);
    }
  }
  {
#line 215
  tmp___1 = double_to_flonum(result);
  }
#line 215
  return (tmp___1);
}
}
#line 216 "/home/khheo/project/mit-scheme-9.2/src/microcode/flonum.c"
SCHEME_OBJECT Prim_flonum_acos(void) 
{ 
  double x ;
  double result ;
  int *tmp ;
  int *tmp___0 ;
  SCHEME_OBJECT tmp___1 ;

  {
  {
#line 217
  while (1) {
    while_continue: /* CIL Label */ ;
#line 217
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 217
  x = arg_flonum(1);
  }
#line 217
  if (x >= (double )-1) {
#line 217
    if (! (x <= (double )1)) {
      {
#line 217
      error_bad_range_arg(1);
      }
    }
  } else {
    {
#line 217
    error_bad_range_arg(1);
    }
  }
  {
#line 217
  tmp = __errno_location();
#line 217
  *tmp = 0;
#line 217
  result = acos(x);
#line 217
  tmp___0 = __errno_location();
  }
#line 217
  if (*tmp___0 != 0) {
    {
#line 217
    error_bad_range_arg(1);
    }
  }
  {
#line 217
  tmp___1 = double_to_flonum(result);
  }
#line 217
  return (tmp___1);
}
}
#line 218 "/home/khheo/project/mit-scheme-9.2/src/microcode/flonum.c"
SCHEME_OBJECT Prim_flonum_atan(void) 
{ 
  double result ;
  int *tmp ;
  double tmp___0 ;
  int *tmp___1 ;
  SCHEME_OBJECT tmp___2 ;

  {
  {
#line 219
  while (1) {
    while_continue: /* CIL Label */ ;
#line 219
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 219
  tmp = __errno_location();
#line 219
  *tmp = 0;
#line 219
  tmp___0 = arg_flonum(1);
#line 219
  result = atan(tmp___0);
#line 219
  tmp___1 = __errno_location();
  }
#line 219
  if (*tmp___1 != 0) {
    {
#line 219
    error_bad_range_arg(1);
    }
  }
  {
#line 219
  tmp___2 = double_to_flonum(result);
  }
#line 219
  return (tmp___2);
}
}
#line 221 "/home/khheo/project/mit-scheme-9.2/src/microcode/flonum.c"
SCHEME_OBJECT Prim_flonum_atan2(void) 
{ 
  double y ;
  double tmp ;
  double x ;
  double tmp___0 ;
  double tmp___1 ;
  SCHEME_OBJECT tmp___2 ;

  {
  {
#line 223
  while (1) {
    while_continue: /* CIL Label */ ;
#line 223
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 225
  tmp = arg_flonum(1);
#line 225
  y = tmp;
#line 226
  tmp___0 = arg_flonum(2);
#line 226
  x = tmp___0;
  }
#line 227
  if (x == (double )0) {
#line 227
    if (y == (double )0) {
      {
#line 228
      error_bad_range_arg(2);
      }
    }
  }
  {
#line 229
  tmp___1 = atan2(y, x);
#line 229
  tmp___2 = double_to_flonum(tmp___1);
  }
#line 229
  return (tmp___2);
}
}
#line 233 "/home/khheo/project/mit-scheme-9.2/src/microcode/flonum.c"
SCHEME_OBJECT Prim_flonum_sqrt(void) 
{ 
  double x ;
  double result ;
  int *tmp ;
  int *tmp___0 ;
  SCHEME_OBJECT tmp___1 ;

  {
  {
#line 234
  while (1) {
    while_continue: /* CIL Label */ ;
#line 234
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 234
  x = arg_flonum(1);
  }
#line 234
  if (! (x >= (double )0)) {
    {
#line 234
    error_bad_range_arg(1);
    }
  }
  {
#line 234
  tmp = __errno_location();
#line 234
  *tmp = 0;
#line 234
  result = sqrt(x);
#line 234
  tmp___0 = __errno_location();
  }
#line 234
  if (*tmp___0 != 0) {
    {
#line 234
    error_bad_range_arg(1);
    }
  }
  {
#line 234
  tmp___1 = double_to_flonum(result);
  }
#line 234
  return (tmp___1);
}
}
#line 236 "/home/khheo/project/mit-scheme-9.2/src/microcode/flonum.c"
SCHEME_OBJECT Prim_flonum_expt(void) 
{ 
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  SCHEME_OBJECT tmp___2 ;

  {
  {
#line 238
  while (1) {
    while_continue: /* CIL Label */ ;
#line 238
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 239
  tmp = arg_flonum(2);
#line 239
  tmp___0 = arg_flonum(1);
#line 239
  tmp___1 = pow(tmp___0, tmp);
#line 239
  tmp___2 = double_to_flonum(tmp___1);
  }
#line 239
  return (tmp___2);
}
}
#line 242 "/home/khheo/project/mit-scheme-9.2/src/microcode/flonum.c"
SCHEME_OBJECT Prim_flonum_p(void) 
{ 
  unsigned long tmp ;

  {
  {
#line 244
  while (1) {
    while_continue: /* CIL Label */ ;
#line 244
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 245
  if (*(stack_pointer + 0) >> 58U == 6UL) {
#line 245
    tmp = 8UL << 58U;
  } else {
#line 245
    tmp = 0UL;
  }
#line 245
  return (tmp);
}
}
#line 248 "/home/khheo/project/mit-scheme-9.2/src/microcode/flonum.c"
SCHEME_OBJECT Prim_flonum_integer_p(void) 
{ 
  unsigned long tmp___1 ;
  _Bool tmp___2 ;
  unsigned long tmp___3 ;
  _Bool tmp___4 ;

  {
  {
#line 250
  while (1) {
    while_continue: /* CIL Label */ ;
#line 250
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 251
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 251
    if (! (*(stack_pointer + 0) >> 58U == 6UL)) {
      {
#line 251
      error_wrong_type_arg(1);
      }
    }
#line 251
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 252
  tmp___4 = flonum_is_finite_p(*(stack_pointer + 0));
  }
#line 252
  if (tmp___4) {
    {
#line 252
    tmp___2 = flonum_integer_p(*(stack_pointer + 0));
    }
#line 252
    if (tmp___2) {
#line 252
      tmp___1 = 8UL << 58U;
    } else {
#line 252
      tmp___1 = 0UL;
    }
#line 252
    tmp___3 = tmp___1;
  } else {
#line 252
    tmp___3 = 0UL;
  }
#line 252
  return (tmp___3);
}
}
#line 268 "/home/khheo/project/mit-scheme-9.2/src/microcode/flonum.c"
SCHEME_OBJECT Prim_flonum_floor(void) 
{ 
  SCHEME_OBJECT tmp___0 ;
  SCHEME_OBJECT tmp___1 ;
  _Bool tmp___2 ;

  {
  {
#line 269
  while (1) {
    while_continue: /* CIL Label */ ;
#line 269
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 269
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 269
    if (! (*(stack_pointer + 0) >> 58U == 6UL)) {
      {
#line 269
      error_wrong_type_arg(1);
      }
    }
#line 269
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 269
  tmp___2 = flonum_is_finite_p(*(stack_pointer + 0));
  }
#line 269
  if (tmp___2) {
    {
#line 269
    tmp___0 = flonum_floor(*(stack_pointer + 0));
#line 269
    tmp___1 = tmp___0;
    }
  } else {
#line 269
    tmp___1 = *(stack_pointer + 0);
  }
#line 269
  return (tmp___1);
}
}
#line 270 "/home/khheo/project/mit-scheme-9.2/src/microcode/flonum.c"
SCHEME_OBJECT Prim_flonum_ceiling(void) 
{ 
  SCHEME_OBJECT tmp___0 ;
  SCHEME_OBJECT tmp___1 ;
  _Bool tmp___2 ;

  {
  {
#line 271
  while (1) {
    while_continue: /* CIL Label */ ;
#line 271
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 271
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 271
    if (! (*(stack_pointer + 0) >> 58U == 6UL)) {
      {
#line 271
      error_wrong_type_arg(1);
      }
    }
#line 271
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 271
  tmp___2 = flonum_is_finite_p(*(stack_pointer + 0));
  }
#line 271
  if (tmp___2) {
    {
#line 271
    tmp___0 = flonum_ceiling(*(stack_pointer + 0));
#line 271
    tmp___1 = tmp___0;
    }
  } else {
#line 271
    tmp___1 = *(stack_pointer + 0);
  }
#line 271
  return (tmp___1);
}
}
#line 272 "/home/khheo/project/mit-scheme-9.2/src/microcode/flonum.c"
SCHEME_OBJECT Prim_flonum_truncate(void) 
{ 
  double tmp___0 ;
  SCHEME_OBJECT tmp___1 ;
  SCHEME_OBJECT tmp___2 ;
  _Bool tmp___3 ;

  {
  {
#line 273
  while (1) {
    while_continue: /* CIL Label */ ;
#line 273
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 273
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 273
    if (! (*(stack_pointer + 0) >> 58U == 6UL)) {
      {
#line 273
      error_wrong_type_arg(1);
      }
    }
#line 273
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 273
  tmp___3 = flonum_is_finite_p(*(stack_pointer + 0));
  }
#line 273
  if (tmp___3) {
    {
#line 273
    tmp___0 = double_truncate(*((double *)((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 1)));
#line 273
    tmp___1 = double_to_flonum(tmp___0);
#line 273
    tmp___2 = tmp___1;
    }
  } else {
#line 273
    tmp___2 = *(stack_pointer + 0);
  }
#line 273
  return (tmp___2);
}
}
#line 274 "/home/khheo/project/mit-scheme-9.2/src/microcode/flonum.c"
SCHEME_OBJECT Prim_flonum_round(void) 
{ 
  SCHEME_OBJECT tmp___0 ;
  SCHEME_OBJECT tmp___1 ;
  _Bool tmp___2 ;

  {
  {
#line 275
  while (1) {
    while_continue: /* CIL Label */ ;
#line 275
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 275
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 275
    if (! (*(stack_pointer + 0) >> 58U == 6UL)) {
      {
#line 275
      error_wrong_type_arg(1);
      }
    }
#line 275
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 275
  tmp___2 = flonum_is_finite_p(*(stack_pointer + 0));
  }
#line 275
  if (tmp___2) {
    {
#line 275
    tmp___0 = flonum_round(*(stack_pointer + 0));
#line 275
    tmp___1 = tmp___0;
    }
  } else {
#line 275
    tmp___1 = *(stack_pointer + 0);
  }
#line 275
  return (tmp___1);
}
}
#line 277 "/home/khheo/project/mit-scheme-9.2/src/microcode/flonum.c"
SCHEME_OBJECT Prim_flonum_truncate_to_exact(void) 
{ 
  _Bool tmp ;
  SCHEME_OBJECT tmp___0 ;

  {
  {
#line 279
  while (1) {
    while_continue: /* CIL Label */ ;
#line 279
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 280
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 280
    tmp = finite_flonum_p(*(stack_pointer + 0));
    }
#line 280
    if (! tmp) {
      {
#line 280
      error_wrong_type_arg(1);
      }
    }
#line 280
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 281
  tmp___0 = double_to_integer(*((double *)((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 1)));
  }
#line 281
  return (tmp___0);
}
}
#line 290 "/home/khheo/project/mit-scheme-9.2/src/microcode/flonum.c"
SCHEME_OBJECT Prim_flonum_floor_to_exact(void) 
{ 
  _Bool tmp ;
  SCHEME_OBJECT tmp___0 ;
  SCHEME_OBJECT tmp___1 ;

  {
  {
#line 291
  while (1) {
    while_continue: /* CIL Label */ ;
#line 291
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 291
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 291
    tmp = finite_flonum_p(*(stack_pointer + 0));
    }
#line 291
    if (! tmp) {
      {
#line 291
      error_wrong_type_arg(1);
      }
    }
#line 291
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 291
  tmp___0 = flonum_floor(*(stack_pointer + 0));
#line 291
  tmp___1 = double_to_integer(*((double *)((SCHEME_OBJECT *)(tmp___0 & 288230376151711743UL) + 1)));
  }
#line 291
  return (tmp___1);
}
}
#line 292 "/home/khheo/project/mit-scheme-9.2/src/microcode/flonum.c"
SCHEME_OBJECT Prim_flonum_ceiling_to_exact(void) 
{ 
  _Bool tmp ;
  SCHEME_OBJECT tmp___0 ;
  SCHEME_OBJECT tmp___1 ;

  {
  {
#line 293
  while (1) {
    while_continue: /* CIL Label */ ;
#line 293
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 293
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 293
    tmp = finite_flonum_p(*(stack_pointer + 0));
    }
#line 293
    if (! tmp) {
      {
#line 293
      error_wrong_type_arg(1);
      }
    }
#line 293
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 293
  tmp___0 = flonum_ceiling(*(stack_pointer + 0));
#line 293
  tmp___1 = double_to_integer(*((double *)((SCHEME_OBJECT *)(tmp___0 & 288230376151711743UL) + 1)));
  }
#line 293
  return (tmp___1);
}
}
#line 294 "/home/khheo/project/mit-scheme-9.2/src/microcode/flonum.c"
SCHEME_OBJECT Prim_flonum_round_to_exact(void) 
{ 
  _Bool tmp ;
  SCHEME_OBJECT tmp___0 ;
  SCHEME_OBJECT tmp___1 ;

  {
  {
#line 295
  while (1) {
    while_continue: /* CIL Label */ ;
#line 295
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 295
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 295
    tmp = finite_flonum_p(*(stack_pointer + 0));
    }
#line 295
    if (! tmp) {
      {
#line 295
      error_wrong_type_arg(1);
      }
    }
#line 295
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 295
  tmp___0 = flonum_round(*(stack_pointer + 0));
#line 295
  tmp___1 = double_to_integer(*((double *)((SCHEME_OBJECT *)(tmp___0 & 288230376151711743UL) + 1)));
  }
#line 295
  return (tmp___1);
}
}
#line 297 "/home/khheo/project/mit-scheme-9.2/src/microcode/flonum.c"
SCHEME_OBJECT Prim_flonum_normalize(void) 
{ 
  _Bool tmp ;
  SCHEME_OBJECT tmp___0 ;

  {
  {
#line 299
  while (1) {
    while_continue: /* CIL Label */ ;
#line 299
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 300
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 300
    tmp = finite_flonum_p(*(stack_pointer + 0));
    }
#line 300
    if (! tmp) {
      {
#line 300
      error_wrong_type_arg(1);
      }
    }
#line 300
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 301
  tmp___0 = flonum_normalize(*(stack_pointer + 0));
  }
#line 301
  return (tmp___0);
}
}
#line 304 "/home/khheo/project/mit-scheme-9.2/src/microcode/flonum.c"
SCHEME_OBJECT Prim_flonum_denormalize(void) 
{ 
  _Bool tmp ;
  SCHEME_OBJECT tmp___0 ;

  {
  {
#line 306
  while (1) {
    while_continue: /* CIL Label */ ;
#line 306
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 307
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 307
    tmp = finite_flonum_p(*(stack_pointer + 0));
    }
#line 307
    if (! tmp) {
      {
#line 307
      error_wrong_type_arg(1);
      }
    }
#line 307
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 308
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 308
    if (! (*(stack_pointer + 1) >> 58U == 26UL)) {
#line 308
      if (! (*(stack_pointer + 1) >> 58U == 14UL)) {
        {
#line 308
        error_wrong_type_arg(2);
        }
      }
    }
#line 308
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 309
  tmp___0 = flonum_denormalize(*(stack_pointer + 0), *(stack_pointer + 1));
  }
#line 309
  return (tmp___0);
}
}
#line 327 "/home/khheo/project/mit-scheme-9.2/src/microcode/flonum.c"
SCHEME_OBJECT Prim_cast_ieee754_double_to_integer(void) 
{ 
  double_uint64_t_cast cast ;
  SCHEME_OBJECT tmp ;

  {
  {
#line 329
  while (1) {
    while_continue: /* CIL Label */ ;
#line 329
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 331
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 331
    if (! (*(stack_pointer + 0) >> 58U == 6UL)) {
      {
#line 331
      error_wrong_type_arg(1);
      }
    }
#line 331
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 335
  cast.dbl = *((double *)((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 1));
#line 337
  tmp = uintmax_to_integer(cast.u64);
  }
#line 337
  return (tmp);
}
}
#line 345 "/home/khheo/project/mit-scheme-9.2/src/microcode/flonum.c"
SCHEME_OBJECT Prim_cast_integer_to_ieee754_double(void) 
{ 
  double_uint64_t_cast cast ;
  SCHEME_OBJECT tmp ;

  {
  {
#line 347
  while (1) {
    while_continue: /* CIL Label */ ;
#line 347
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 349
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 349
    if (! (*(stack_pointer + 0) >> 58U == 26UL)) {
#line 349
      if (! (*(stack_pointer + 0) >> 58U == 14UL)) {
        {
#line 349
        error_wrong_type_arg(1);
        }
      }
    }
#line 349
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 353
  cast.u64 = integer_to_uintmax(*(stack_pointer + 0));
#line 355
  tmp = double_to_flonum(cast.dbl);
  }
#line 355
  return (tmp);
}
}
#line 370 "/home/khheo/project/mit-scheme-9.2/src/microcode/flonum.c"
SCHEME_OBJECT Prim_cast_ieee754_single_to_integer(void) 
{ 
  float_uint32_t_cast cast ;
  SCHEME_OBJECT tmp ;

  {
  {
#line 372
  while (1) {
    while_continue: /* CIL Label */ ;
#line 372
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 373
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 373
    if (! (*(stack_pointer + 0) >> 58U == 6UL)) {
      {
#line 373
      error_wrong_type_arg(1);
      }
    }
#line 373
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 377
  cast.f = (float )*((double *)((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 1));
#line 379
  tmp = uintmax_to_integer((uintmax_t )cast.u32);
  }
#line 379
  return (tmp);
}
}
#line 383 "/home/khheo/project/mit-scheme-9.2/src/microcode/flonum.c"
SCHEME_OBJECT Prim_cast_integer_to_ieee754_single(void) 
{ 
  float_uint32_t_cast cast ;
  uintmax_t tmp ;
  SCHEME_OBJECT tmp___0 ;

  {
  {
#line 385
  while (1) {
    while_continue: /* CIL Label */ ;
#line 385
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 386
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 386
    if (! (*(stack_pointer + 0) >> 58U == 26UL)) {
#line 386
      if (! (*(stack_pointer + 0) >> 58U == 14UL)) {
        {
#line 386
        error_wrong_type_arg(1);
        }
      }
    }
#line 386
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 390
  tmp = integer_to_uintmax(*(stack_pointer + 0));
#line 390
  cast.u32 = (uint32_t )tmp;
#line 392
  tmp___0 = double_to_flonum((double )cast.f);
  }
#line 392
  return (tmp___0);
}
}
#line 64 "/usr/include/fenv.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feclearexcept)(int __excepts ) ;
#line 68
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fegetexceptflag)(fexcept_t *__flagp ,
                                                                                      int __excepts ) ;
#line 71
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feraiseexcept)(int __excepts ) ;
#line 75
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fesetexceptflag)(fexcept_t const   *__flagp ,
                                                                                      int __excepts ) ;
#line 79
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fetestexcept)(int __excepts ) ;
#line 85
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fegetround)(void) ;
#line 88
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fesetround)(int __rounding_direction ) ;
#line 95
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fegetenv)(fenv_t *__envp ) ;
#line 100
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feholdexcept)(fenv_t *__envp ) ;
#line 109
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feupdateenv)(fenv_t const   *__envp ) ;
#line 122
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feenableexcept)(int __excepts ) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fedisableexcept)(int __excepts ) ;
#line 130
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fegetexcept)(void) ;
#line 44 "/home/khheo/project/mit-scheme-9.2/src/microcode/floenv.c"
static SCHEME_OBJECT arg_vector_8b(int n ) 
{ 


  {
  {
#line 47
  while (1) {
    while_continue: /* CIL Label */ ;
#line 47
    if (! (*(stack_pointer + (n - 1)) >> 58U == 30UL)) {
      {
#line 47
      error_wrong_type_arg(n);
      }
    }
#line 47
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 48
  return (*(stack_pointer + (n - 1)));
}
}
#line 59 "/home/khheo/project/mit-scheme-9.2/src/microcode/floenv.c"
static _Bool scheme_fenv_p  =    (_Bool)0;
#line 60 "/home/khheo/project/mit-scheme-9.2/src/microcode/floenv.c"
static fenv_t scheme_fenv  ;
#line 62 "/home/khheo/project/mit-scheme-9.2/src/microcode/floenv.c"
static void cache_float_environment(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 66
  tmp = fegetenv(& scheme_fenv);
  }
#line 66
  if (0 != tmp) {
    {
#line 67
    error_external_return();
    }
  }
  {
#line 68
  scheme_fenv_p = (_Bool)1;
#line 72
  tmp___0 = fesetenv((fenv_t const   *)(& scheme_fenv));
  }
#line 72
  if (0 != tmp___0) {
    {
#line 73
    error_external_return();
    }
  }
#line 76
  return;
}
}
#line 78 "/home/khheo/project/mit-scheme-9.2/src/microcode/floenv.c"
void fixup_float_environment(void) 
{ 


  {
#line 82
  if (scheme_fenv_p) {
    {
#line 83
    fesetenv((fenv_t const   *)(& scheme_fenv));
    }
  }
#line 85
  return;
}
}
#line 87 "/home/khheo/project/mit-scheme-9.2/src/microcode/floenv.c"
void clear_float_exceptions(void) 
{ 


  {
  {
#line 91
  feclearexcept(61);
  }
#line 93
  return;
}
}
#line 97 "/home/khheo/project/mit-scheme-9.2/src/microcode/floenv.c"
static SCHEME_OBJECT allocate_fenv(fenv_t **envp_loc ) 
{ 
  SCHEME_OBJECT environment ;
  SCHEME_OBJECT tmp ;

  {
  {
#line 100
  tmp = allocate_string(sizeof(fenv_t ));
#line 100
  environment = tmp;
#line 101
  *envp_loc = (fenv_t *)((char *)((SCHEME_OBJECT *)(environment & 288230376151711743UL) + 2));
  }
#line 102
  return (environment);
}
}
#line 105 "/home/khheo/project/mit-scheme-9.2/src/microcode/floenv.c"
static fenv_t *arg_fenv(int n ) 
{ 
  SCHEME_OBJECT environment ;
  SCHEME_OBJECT tmp ;

  {
  {
#line 108
  tmp = arg_vector_8b(n);
#line 108
  environment = tmp;
  }
#line 109
  if (sizeof(fenv_t ) != (*((SCHEME_OBJECT *)(environment & 288230376151711743UL) + 1) & 288230376151711743UL)) {
    {
#line 110
    error_bad_range_arg(n);
    }
  }
#line 111
  return ((fenv_t *)((char *)((SCHEME_OBJECT *)(environment & 288230376151711743UL) + 2)));
}
}
#line 114 "/home/khheo/project/mit-scheme-9.2/src/microcode/floenv.c"
static SCHEME_OBJECT allocate_fexcept(fexcept_t **flagp_loc ) 
{ 
  SCHEME_OBJECT flags ;
  SCHEME_OBJECT tmp ;

  {
  {
#line 117
  tmp = allocate_string(sizeof(fexcept_t ));
#line 117
  flags = tmp;
#line 118
  *flagp_loc = (fexcept_t *)((char *)((SCHEME_OBJECT *)(flags & 288230376151711743UL) + 2));
  }
#line 119
  return (flags);
}
}
#line 122 "/home/khheo/project/mit-scheme-9.2/src/microcode/floenv.c"
static fexcept_t *arg_fexcept(int n ) 
{ 
  SCHEME_OBJECT flags ;
  SCHEME_OBJECT tmp ;

  {
  {
#line 125
  tmp = arg_vector_8b(n);
#line 125
  flags = tmp;
  }
#line 126
  if (sizeof(fexcept_t ) != (*((SCHEME_OBJECT *)(flags & 288230376151711743UL) + 1) & 288230376151711743UL)) {
    {
#line 127
    error_bad_range_arg(n);
    }
  }
#line 128
  return ((fexcept_t *)((char *)((SCHEME_OBJECT *)(flags & 288230376151711743UL) + 2)));
}
}
#line 131 "/home/khheo/project/mit-scheme-9.2/src/microcode/floenv.c"
SCHEME_OBJECT Prim_float_environment(void) 
{ 
  fenv_t *envp ;
  SCHEME_OBJECT environment ;
  SCHEME_OBJECT tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 133
  while (1) {
    while_continue: /* CIL Label */ ;
#line 133
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 137
  tmp = allocate_fenv(& envp);
#line 137
  environment = tmp;
#line 138
  tmp___0 = fegetenv(envp);
  }
#line 138
  if (0 != tmp___0) {
    {
#line 139
    error_external_return();
    }
  }
  {
#line 142
  tmp___1 = fesetenv((fenv_t const   *)envp);
  }
#line 142
  if (0 != tmp___1) {
    {
#line 143
    error_external_return();
    }
  }
#line 145
  return (environment);
}
}
#line 153 "/home/khheo/project/mit-scheme-9.2/src/microcode/floenv.c"
SCHEME_OBJECT Prim_set_float_environment(void) 
{ 
  fenv_t *tmp ;
  int tmp___0 ;

  {
  {
#line 155
  while (1) {
    while_continue: /* CIL Label */ ;
#line 155
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 157
  tmp = arg_fenv(1);
#line 157
  tmp___0 = fesetenv((fenv_t const   *)tmp);
  }
#line 157
  if (0 != tmp___0) {
    {
#line 158
    error_external_return();
    }
  }
  {
#line 159
  cache_float_environment();
  }
#line 163
  return ((8UL << 58U) | 1UL);
}
}
#line 166 "/home/khheo/project/mit-scheme-9.2/src/microcode/floenv.c"
SCHEME_OBJECT Prim_defer_float_exception_traps(void) 
{ 
  fenv_t *envp ;
  SCHEME_OBJECT environment ;
  SCHEME_OBJECT tmp ;
  int tmp___0 ;

  {
  {
#line 168
  while (1) {
    while_continue: /* CIL Label */ ;
#line 168
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 172
  tmp = allocate_fenv(& envp);
#line 172
  environment = tmp;
#line 173
  tmp___0 = feholdexcept(envp);
  }
#line 173
  if (0 != tmp___0) {
    {
#line 174
    error_external_return();
    }
  }
  {
#line 175
  cache_float_environment();
  }
#line 176
  return (environment);
}
}
#line 184 "/home/khheo/project/mit-scheme-9.2/src/microcode/floenv.c"
SCHEME_OBJECT Prim_update_float_environment(void) 
{ 
  fenv_t *tmp ;
  int tmp___0 ;

  {
  {
#line 186
  while (1) {
    while_continue: /* CIL Label */ ;
#line 186
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 188
  tmp = arg_fenv(1);
#line 188
  tmp___0 = feupdateenv((fenv_t const   *)tmp);
  }
#line 188
  if (0 != tmp___0) {
    {
#line 189
    error_external_return();
    }
  }
  {
#line 190
  cache_float_environment();
  }
#line 194
  return ((8UL << 58U) | 1UL);
}
}
#line 199 "/home/khheo/project/mit-scheme-9.2/src/microcode/floenv.c"
SCHEME_OBJECT Prim_float_rounding_modes(void) 
{ 
  unsigned int modes ;
  SCHEME_OBJECT tmp ;

  {
#line 201
  modes = 0U;
  {
#line 202
  while (1) {
    while_continue: /* CIL Label */ ;
#line 202
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 205
  modes |= 1U;
#line 208
  modes |= (unsigned int )(1 << 1);
#line 211
  modes |= (unsigned int )(1 << 2);
#line 214
  modes |= (unsigned int )(1 << 3);
#line 217
  tmp = ulong_to_integer((unsigned long )modes);
  }
#line 217
  return (tmp);
}
}
#line 220 "/home/khheo/project/mit-scheme-9.2/src/microcode/floenv.c"
SCHEME_OBJECT Prim_get_float_rounding_mode(void) 
{ 
  int mode ;
  int tmp ;
  SCHEME_OBJECT tmp___0 ;
  SCHEME_OBJECT tmp___1 ;
  SCHEME_OBJECT tmp___2 ;
  SCHEME_OBJECT tmp___3 ;

  {
  {
#line 222
  while (1) {
    while_continue: /* CIL Label */ ;
#line 222
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 225
  tmp = fegetround();
#line 225
  mode = tmp;
  }
#line 226
  if (mode < 0) {
    {
#line 227
    error_external_return();
    }
  }
  {
#line 231
  if (mode == 0) {
#line 231
    goto case_0;
  }
#line 234
  if (mode == 3072) {
#line 234
    goto case_3072;
  }
#line 237
  if (mode == 1024) {
#line 237
    goto case_1024;
  }
#line 240
  if (mode == 2048) {
#line 240
    goto case_2048;
  }
#line 242
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 231
  tmp___0 = ulong_to_integer(0UL);
  }
#line 231
  return (tmp___0);
  case_3072: /* CIL Label */ 
  {
#line 234
  tmp___1 = ulong_to_integer(1UL);
  }
#line 234
  return (tmp___1);
  case_1024: /* CIL Label */ 
  {
#line 237
  tmp___2 = ulong_to_integer(2UL);
  }
#line 237
  return (tmp___2);
  case_2048: /* CIL Label */ 
  {
#line 240
  tmp___3 = ulong_to_integer(3UL);
  }
#line 240
  return (tmp___3);
  switch_default: /* CIL Label */ 
#line 242
  return (0UL);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 251 "/home/khheo/project/mit-scheme-9.2/src/microcode/floenv.c"
SCHEME_OBJECT Prim_set_float_rounding_mode(void) 
{ 
  int mode ;
  unsigned long tmp ;
  int tmp___0 ;

  {
  {
#line 253
  while (1) {
    while_continue: /* CIL Label */ ;
#line 253
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 256
  mode = -1;
#line 257
  tmp = arg_ulong_integer(1);
  }
  {
#line 260
  if (tmp == 0UL) {
#line 260
    goto case_0;
  }
#line 263
  if (tmp == 1UL) {
#line 263
    goto case_1;
  }
#line 266
  if (tmp == 2UL) {
#line 266
    goto case_2;
  }
#line 269
  if (tmp == 3UL) {
#line 269
    goto case_3;
  }
#line 271
  goto switch_default;
  case_0: /* CIL Label */ 
#line 260
  mode = 0;
#line 260
  goto switch_break;
  case_1: /* CIL Label */ 
#line 263
  mode = 3072;
#line 263
  goto switch_break;
  case_2: /* CIL Label */ 
#line 266
  mode = 1024;
#line 266
  goto switch_break;
  case_3: /* CIL Label */ 
#line 269
  mode = 2048;
#line 269
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 271
  error_bad_range_arg(1);
  }
#line 271
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 273
  tmp___0 = fesetround(mode);
  }
#line 273
  if (tmp___0 != 0) {
    {
#line 274
    error_external_return();
    }
  }
  {
#line 275
  cache_float_environment();
  }
#line 280
  return ((8UL << 58U) | 1UL);
}
}
#line 295 "/home/khheo/project/mit-scheme-9.2/src/microcode/floenv.c"
static int arg_float_exceptions(int n ) 
{ 
  unsigned long scheme_exceptions ;

  {
  {
#line 298
  while (1) {
    while_continue: /* CIL Label */ ;
#line 298
    if (*(stack_pointer + (n - 1)) >> 58U == 26UL) {
#line 298
      if (! (! ((*(stack_pointer + (n - 1)) & 144115188075855872UL) != 0UL))) {
        {
#line 298
        error_wrong_type_arg(n);
        }
      }
    } else {
      {
#line 298
      error_wrong_type_arg(n);
      }
    }
#line 298
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 300
  scheme_exceptions = *(stack_pointer + (n - 1)) & 288230376151711743UL;
#line 301
  if (scheme_exceptions & 0xffffffffffffffc2UL) {
    {
#line 302
    error_bad_range_arg(n);
    }
  }
#line 303
  return ((int )scheme_exceptions);
}
}
#line 312 "/home/khheo/project/mit-scheme-9.2/src/microcode/floenv.c"
static int const   non_trappable_exceptions  =    (int const   )32;
#line 319 "/home/khheo/project/mit-scheme-9.2/src/microcode/floenv.c"
static int arg_untrappable_float_exceptions(int n ) 
{ 
  int tmp ;

  {
  {
#line 322
  tmp = arg_float_exceptions(n);
  }
#line 322
  return ((int )(non_trappable_exceptions | (int const   )tmp));
}
}
#line 327 "/home/khheo/project/mit-scheme-9.2/src/microcode/floenv.c"
static int arg_trappable_float_exceptions(int n ) 
{ 
  int exceptions ;
  int tmp ;

  {
  {
#line 330
  tmp = arg_float_exceptions(n);
#line 330
  exceptions = tmp;
  }
#line 331
  if (exceptions & (int )non_trappable_exceptions) {
    {
#line 332
    error_bad_range_arg(n);
    }
  }
#line 333
  return (exceptions);
}
}
#line 338 "/home/khheo/project/mit-scheme-9.2/src/microcode/floenv.c"
static int arg_float_exceptions_to_trap(int n ) 
{ 
  int exceptions ;
  int tmp ;

  {
  {
#line 341
  tmp = arg_float_exceptions(n);
#line 341
  exceptions = tmp;
  }
#line 342
  if (exceptions & (int )non_trappable_exceptions) {
    {
#line 343
    error_bad_range_arg(n);
    }
  }
#line 344
  return (exceptions);
}
}
#line 361 "/home/khheo/project/mit-scheme-9.2/src/microcode/floenv.c"
SCHEME_OBJECT Prim_float_invalid_operation_exception(void) 
{ 


  {
  {
#line 363
  while (1) {
    while_continue: /* CIL Label */ ;
#line 363
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 363
  return ((26UL << 58U) | 1UL);
}
}
#line 368 "/home/khheo/project/mit-scheme-9.2/src/microcode/floenv.c"
SCHEME_OBJECT Prim_float_divide_by_zero_exception(void) 
{ 


  {
  {
#line 370
  while (1) {
    while_continue: /* CIL Label */ ;
#line 370
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 370
  return ((26UL << 58U) | 4UL);
}
}
#line 375 "/home/khheo/project/mit-scheme-9.2/src/microcode/floenv.c"
SCHEME_OBJECT Prim_float_overflow_exception(void) 
{ 


  {
  {
#line 377
  while (1) {
    while_continue: /* CIL Label */ ;
#line 377
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 377
  return ((26UL << 58U) | 8UL);
}
}
#line 382 "/home/khheo/project/mit-scheme-9.2/src/microcode/floenv.c"
SCHEME_OBJECT Prim_float_underflow_exception(void) 
{ 


  {
  {
#line 384
  while (1) {
    while_continue: /* CIL Label */ ;
#line 384
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 384
  return ((26UL << 58U) | 16UL);
}
}
#line 389 "/home/khheo/project/mit-scheme-9.2/src/microcode/floenv.c"
SCHEME_OBJECT Prim_float_inexact_result_exception(void) 
{ 


  {
  {
#line 391
  while (1) {
    while_continue: /* CIL Label */ ;
#line 391
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 391
  return ((26UL << 58U) | 32UL);
}
}
#line 396 "/home/khheo/project/mit-scheme-9.2/src/microcode/floenv.c"
SCHEME_OBJECT Prim_float_exceptions(void) 
{ 


  {
  {
#line 397
  while (1) {
    while_continue: /* CIL Label */ ;
#line 397
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 397
  return ((26UL << 58U) | 61UL);
}
}
#line 399 "/home/khheo/project/mit-scheme-9.2/src/microcode/floenv.c"
SCHEME_OBJECT Prim_trappable_float_exceptions(void) 
{ 


  {
  {
#line 400
  while (1) {
    while_continue: /* CIL Label */ ;
#line 400
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 400
  return ((26UL << 58U) | (unsigned long )(61 & (int )(~ non_trappable_exceptions)));
}
}
#line 402 "/home/khheo/project/mit-scheme-9.2/src/microcode/floenv.c"
SCHEME_OBJECT Prim_test_float_exceptions(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 404
  while (1) {
    while_continue: /* CIL Label */ ;
#line 404
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 406
  tmp = arg_float_exceptions(1);
#line 406
  tmp___0 = fetestexcept(tmp);
  }
#line 406
  return ((26UL << 58U) | (unsigned long )tmp___0);
}
}
#line 413 "/home/khheo/project/mit-scheme-9.2/src/microcode/floenv.c"
SCHEME_OBJECT Prim_clear_float_exceptions(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 415
  while (1) {
    while_continue: /* CIL Label */ ;
#line 415
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 417
  tmp = arg_float_exceptions(1);
#line 417
  tmp___0 = feclearexcept(tmp);
  }
#line 417
  if (0 != tmp___0) {
    {
#line 418
    error_external_return();
    }
  }
  {
#line 419
  cache_float_environment();
  }
#line 423
  return ((8UL << 58U) | 1UL);
}
}
#line 426 "/home/khheo/project/mit-scheme-9.2/src/microcode/floenv.c"
SCHEME_OBJECT Prim_raise_float_exceptions(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 428
  while (1) {
    while_continue: /* CIL Label */ ;
#line 428
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 430
  tmp = arg_float_exceptions(1);
#line 430
  tmp___0 = feraiseexcept(tmp);
  }
#line 430
  if (0 != tmp___0) {
    {
#line 431
    error_external_return();
    }
  }
#line 436
  return ((8UL << 58U) | 1UL);
}
}
#line 439 "/home/khheo/project/mit-scheme-9.2/src/microcode/floenv.c"
SCHEME_OBJECT Prim_save_float_exception_flags(void) 
{ 
  fexcept_t *flagp ;
  SCHEME_OBJECT flags ;
  SCHEME_OBJECT tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 441
  while (1) {
    while_continue: /* CIL Label */ ;
#line 441
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 445
  tmp = allocate_fexcept(& flagp);
#line 445
  flags = tmp;
#line 446
  tmp___0 = arg_float_exceptions(1);
#line 446
  tmp___1 = fegetexceptflag(flagp, tmp___0);
  }
#line 446
  if (0 != tmp___1) {
    {
#line 447
    error_external_return();
    }
  }
#line 448
  return (flags);
}
}
#line 456 "/home/khheo/project/mit-scheme-9.2/src/microcode/floenv.c"
SCHEME_OBJECT Prim_test_float_exception_flags(void) 
{ 


  {
  {
#line 458
  while (1) {
    while_continue: /* CIL Label */ ;
#line 458
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 461
  error_unimplemented_primitive();
  }
#line 462
  return ((8UL << 58U) | 1UL);
}
}
#line 465 "/home/khheo/project/mit-scheme-9.2/src/microcode/floenv.c"
SCHEME_OBJECT Prim_restore_float_exception_flags(void) 
{ 
  int tmp ;
  fexcept_t *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 467
  while (1) {
    while_continue: /* CIL Label */ ;
#line 467
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 469
  tmp = arg_float_exceptions(2);
#line 469
  tmp___0 = arg_fexcept(1);
#line 469
  tmp___1 = fesetexceptflag((fexcept_t const   *)tmp___0, tmp);
  }
#line 469
  if (0 > tmp___1) {
    {
#line 470
    error_external_return();
    }
  }
  {
#line 471
  cache_float_environment();
  }
#line 475
  return ((8UL << 58U) | 1UL);
}
}
#line 478 "/home/khheo/project/mit-scheme-9.2/src/microcode/floenv.c"
SCHEME_OBJECT Prim_trapped_float_exceptions(void) 
{ 
  int exceptions ;
  int tmp ;

  {
  {
#line 480
  while (1) {
    while_continue: /* CIL Label */ ;
#line 480
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 483
  tmp = fegetexcept();
#line 483
  exceptions = tmp;
  }
#line 484
  if (exceptions < 0) {
    {
#line 484
    error_external_return();
    }
  }
#line 485
  return ((26UL << 58U) | (unsigned long )exceptions);
}
}
#line 492 "/home/khheo/project/mit-scheme-9.2/src/microcode/floenv.c"
SCHEME_OBJECT Prim_set_trapped_float_exceptions(void) 
{ 
  int exceptions ;
  int tmp ;
  int previous_exceptions ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 494
  while (1) {
    while_continue: /* CIL Label */ ;
#line 494
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 497
  tmp = arg_float_exceptions_to_trap(1);
#line 497
  exceptions = tmp;
#line 498
  tmp___0 = feenableexcept(exceptions);
#line 498
  previous_exceptions = tmp___0;
  }
#line 499
  if (0 > previous_exceptions) {
    {
#line 501
    error_external_return();
    }
  } else {
    {
#line 499
    tmp___1 = fedisableexcept(61 & ~ exceptions);
    }
#line 499
    if (0 > tmp___1) {
      {
#line 501
      error_external_return();
      }
    }
  }
  {
#line 502
  cache_float_environment();
  }
#line 503
  return ((26UL << 58U) | (unsigned long )previous_exceptions);
}
}
#line 510 "/home/khheo/project/mit-scheme-9.2/src/microcode/floenv.c"
SCHEME_OBJECT Prim_untrap_float_exceptions(void) 
{ 
  int exceptions ;
  int tmp ;
  int previous_exceptions ;
  int tmp___0 ;

  {
  {
#line 512
  while (1) {
    while_continue: /* CIL Label */ ;
#line 512
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 515
  tmp = arg_untrappable_float_exceptions(1);
#line 515
  exceptions = tmp;
#line 516
  tmp___0 = fedisableexcept(exceptions);
#line 516
  previous_exceptions = tmp___0;
  }
#line 517
  if (previous_exceptions < 0) {
    {
#line 517
    error_external_return();
    }
  }
  {
#line 518
  cache_float_environment();
  }
#line 519
  return ((26UL << 58U) | (unsigned long )previous_exceptions);
}
}
#line 527 "/home/khheo/project/mit-scheme-9.2/src/microcode/floenv.c"
SCHEME_OBJECT Prim_trap_float_exceptions(void) 
{ 
  int exceptions ;
  int tmp ;
  int previous_exceptions ;
  int tmp___0 ;

  {
  {
#line 529
  while (1) {
    while_continue: /* CIL Label */ ;
#line 529
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 532
  tmp = arg_trappable_float_exceptions(1);
#line 532
  exceptions = tmp;
#line 533
  tmp___0 = feenableexcept(exceptions);
#line 533
  previous_exceptions = tmp___0;
  }
#line 534
  if (previous_exceptions < 0) {
    {
#line 534
    error_external_return();
    }
  }
  {
#line 535
  cache_float_environment();
  }
#line 536
  return ((26UL << 58U) | (unsigned long )previous_exceptions);
}
}
#line 204 "/home/khheo/project/mit-scheme-9.2/src/microcode/extern.h"
SCHEME_OBJECT Mul(SCHEME_OBJECT Arg1 , SCHEME_OBJECT Arg2 ) ;
#line 36 "/home/khheo/project/mit-scheme-9.2/src/microcode/fixnum.c"
static long arg_fixnum(int n ) 
{ 
  SCHEME_OBJECT argument ;

  {
#line 39
  argument = *(stack_pointer + (n - 1));
#line 40
  if (! (argument >> 58U == 26UL)) {
    {
#line 41
    error_wrong_type_arg(n);
    }
  }
#line 42
  return ((long )((argument ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL)));
}
}
#line 45 "/home/khheo/project/mit-scheme-9.2/src/microcode/fixnum.c"
static unsigned long arg_unsigned_fixnum(int n ) 
{ 
  SCHEME_OBJECT argument ;

  {
#line 48
  argument = *(stack_pointer + (n - 1));
#line 49
  if (! (argument >> 58U == 26UL)) {
    {
#line 50
    error_wrong_type_arg(n);
    }
  }
#line 51
  return (argument & 288230376151711743UL);
}
}
#line 59 "/home/khheo/project/mit-scheme-9.2/src/microcode/fixnum.c"
SCHEME_OBJECT Prim_zero_fixnum_p(void) 
{ 
  unsigned long tmp ;

  {
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
#line 61
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 62
  if (*(stack_pointer + 0) >> 58U == 26UL) {
#line 62
    tmp = 8UL << 58U;
  } else {
#line 62
    tmp = 0UL;
  }
#line 62
  return (tmp);
}
}
#line 65 "/home/khheo/project/mit-scheme-9.2/src/microcode/fixnum.c"
SCHEME_OBJECT Prim_index_fixnum_p(void) 
{ 
  unsigned long tmp ;

  {
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
#line 67
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 68
  if (*(stack_pointer + 0) >> 58U == 26UL) {
#line 68
    if (! ((*(stack_pointer + 0) & 144115188075855872UL) != 0UL)) {
#line 68
      tmp = 8UL << 58U;
    } else {
#line 68
      tmp = 0UL;
    }
  } else {
#line 68
    tmp = 0UL;
  }
#line 68
  return (tmp);
}
}
#line 71 "/home/khheo/project/mit-scheme-9.2/src/microcode/fixnum.c"
SCHEME_OBJECT Prim_zero_fixnum(void) 
{ 
  unsigned long tmp___0 ;
  long tmp___1 ;

  {
  {
#line 73
  while (1) {
    while_continue: /* CIL Label */ ;
#line 73
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 74
  tmp___1 = arg_fixnum(1);
  }
#line 74
  if (tmp___1 == 0L) {
#line 74
    tmp___0 = 8UL << 58U;
  } else {
#line 74
    tmp___0 = 0UL;
  }
#line 74
  return (tmp___0);
}
}
#line 77 "/home/khheo/project/mit-scheme-9.2/src/microcode/fixnum.c"
SCHEME_OBJECT Prim_negative_fixnum(void) 
{ 
  unsigned long tmp___0 ;
  long tmp___1 ;

  {
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
#line 79
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 80
  tmp___1 = arg_fixnum(1);
  }
#line 80
  if (tmp___1 < 0L) {
#line 80
    tmp___0 = 8UL << 58U;
  } else {
#line 80
    tmp___0 = 0UL;
  }
#line 80
  return (tmp___0);
}
}
#line 83 "/home/khheo/project/mit-scheme-9.2/src/microcode/fixnum.c"
SCHEME_OBJECT Prim_positive_fixnum(void) 
{ 
  unsigned long tmp___0 ;
  long tmp___1 ;

  {
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
#line 85
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 86
  tmp___1 = arg_fixnum(1);
  }
#line 86
  if (tmp___1 > 0L) {
#line 86
    tmp___0 = 8UL << 58U;
  } else {
#line 86
    tmp___0 = 0UL;
  }
#line 86
  return (tmp___0);
}
}
#line 89 "/home/khheo/project/mit-scheme-9.2/src/microcode/fixnum.c"
SCHEME_OBJECT Prim_equal_fixnum(void) 
{ 
  unsigned long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
  {
#line 91
  while (1) {
    while_continue: /* CIL Label */ ;
#line 91
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 92
  tmp___2 = arg_fixnum(1);
#line 92
  tmp___3 = arg_fixnum(2);
  }
#line 92
  if (tmp___2 == tmp___3) {
#line 92
    tmp___1 = 8UL << 58U;
  } else {
#line 92
    tmp___1 = 0UL;
  }
#line 92
  return (tmp___1);
}
}
#line 95 "/home/khheo/project/mit-scheme-9.2/src/microcode/fixnum.c"
SCHEME_OBJECT Prim_less_fixnum(void) 
{ 
  unsigned long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;
#line 97
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 98
  tmp___2 = arg_fixnum(1);
#line 98
  tmp___3 = arg_fixnum(2);
  }
#line 98
  if (tmp___2 < tmp___3) {
#line 98
    tmp___1 = 8UL << 58U;
  } else {
#line 98
    tmp___1 = 0UL;
  }
#line 98
  return (tmp___1);
}
}
#line 101 "/home/khheo/project/mit-scheme-9.2/src/microcode/fixnum.c"
SCHEME_OBJECT Prim_greater_fixnum(void) 
{ 
  unsigned long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
#line 103
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 104
  tmp___2 = arg_fixnum(1);
#line 104
  tmp___3 = arg_fixnum(2);
  }
#line 104
  if (tmp___2 > tmp___3) {
#line 104
    tmp___1 = 8UL << 58U;
  } else {
#line 104
    tmp___1 = 0UL;
  }
#line 104
  return (tmp___1);
}
}
#line 117 "/home/khheo/project/mit-scheme-9.2/src/microcode/fixnum.c"
SCHEME_OBJECT Prim_one_plus_fixnum(void) 
{ 
  long result ;
  long tmp ;

  {
  {
#line 119
  while (1) {
    while_continue: /* CIL Label */ ;
#line 119
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 120
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 120
    tmp = arg_fixnum(1);
#line 120
    result = tmp + 1L;
    }
#line 120
    if (! (((unsigned long )result & 0xfe00000000000000UL) == 0UL)) {
#line 120
      if (! (((unsigned long )result & 0xfe00000000000000UL) == 0xfe00000000000000UL)) {
        {
#line 120
        error_bad_range_arg(1);
        }
      }
    }
#line 120
    return ((26UL << 58U) | ((unsigned long )result & 288230376151711743UL));
#line 120
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 121
  return (0UL);
}
}
#line 123 "/home/khheo/project/mit-scheme-9.2/src/microcode/fixnum.c"
SCHEME_OBJECT Prim_m_1_plus_fixnum(void) 
{ 
  long result ;
  long tmp ;

  {
  {
#line 125
  while (1) {
    while_continue: /* CIL Label */ ;
#line 125
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 126
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 126
    tmp = arg_fixnum(1);
#line 126
    result = tmp - 1L;
    }
#line 126
    if (! (((unsigned long )result & 0xfe00000000000000UL) == 0UL)) {
#line 126
      if (! (((unsigned long )result & 0xfe00000000000000UL) == 0xfe00000000000000UL)) {
        {
#line 126
        error_bad_range_arg(1);
        }
      }
    }
#line 126
    return ((26UL << 58U) | ((unsigned long )result & 288230376151711743UL));
#line 126
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 127
  return (0UL);
}
}
#line 129 "/home/khheo/project/mit-scheme-9.2/src/microcode/fixnum.c"
SCHEME_OBJECT Prim_plus_fixnum(void) 
{ 
  long result ;
  long tmp ;
  long tmp___0 ;

  {
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;
#line 131
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 132
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 132
    tmp = arg_fixnum(1);
#line 132
    tmp___0 = arg_fixnum(2);
#line 132
    result = tmp + tmp___0;
    }
#line 132
    if (! (((unsigned long )result & 0xfe00000000000000UL) == 0UL)) {
#line 132
      if (! (((unsigned long )result & 0xfe00000000000000UL) == 0xfe00000000000000UL)) {
        {
#line 132
        error_bad_range_arg(1);
        }
      }
    }
#line 132
    return ((26UL << 58U) | ((unsigned long )result & 288230376151711743UL));
#line 132
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 133
  return (0UL);
}
}
#line 135 "/home/khheo/project/mit-scheme-9.2/src/microcode/fixnum.c"
SCHEME_OBJECT Prim_minus_fixnum(void) 
{ 
  long result ;
  long tmp ;
  long tmp___0 ;

  {
  {
#line 137
  while (1) {
    while_continue: /* CIL Label */ ;
#line 137
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 138
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 138
    tmp = arg_fixnum(1);
#line 138
    tmp___0 = arg_fixnum(2);
#line 138
    result = tmp - tmp___0;
    }
#line 138
    if (! (((unsigned long )result & 0xfe00000000000000UL) == 0UL)) {
#line 138
      if (! (((unsigned long )result & 0xfe00000000000000UL) == 0xfe00000000000000UL)) {
        {
#line 138
        error_bad_range_arg(1);
        }
      }
    }
#line 138
    return ((26UL << 58U) | ((unsigned long )result & 288230376151711743UL));
#line 138
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 139
  return (0UL);
}
}
#line 141 "/home/khheo/project/mit-scheme-9.2/src/microcode/fixnum.c"
SCHEME_OBJECT Prim_fixnum_negate(void) 
{ 
  long result ;
  long tmp ;

  {
  {
#line 143
  while (1) {
    while_continue: /* CIL Label */ ;
#line 143
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 144
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 144
    tmp = arg_fixnum(1);
#line 144
    result = - tmp;
    }
#line 144
    if (! (((unsigned long )result & 0xfe00000000000000UL) == 0UL)) {
#line 144
      if (! (((unsigned long )result & 0xfe00000000000000UL) == 0xfe00000000000000UL)) {
        {
#line 144
        error_bad_range_arg(1);
        }
      }
    }
#line 144
    return ((26UL << 58U) | ((unsigned long )result & 288230376151711743UL));
#line 144
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 145
  return (0UL);
}
}
#line 205 "/home/khheo/project/mit-scheme-9.2/src/microcode/mul.c"
SCHEME_OBJECT Mul(SCHEME_OBJECT Arg1 , SCHEME_OBJECT Arg2 ) 
{ 
  long A ;
  long B ;
  long C ;
  unsigned long Hi_A ;
  unsigned long Hi_B ;
  unsigned long Lo_A ;
  unsigned long Lo_B ;
  unsigned long Lo_C ;
  unsigned long Middle_C ;
  _Bool Sign ;

  {
#line 213
  A = (long )((Arg1 ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL));
#line 214
  B = (long )((Arg2 ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL));
#line 215
  Sign = (_Bool )((A < 0L) == (B < 0L));
#line 216
  if (A < 0L) {
#line 216
    A = - A;
  } else {
#line 216
    A = A;
  }
#line 217
  if (B < 0L) {
#line 217
    B = - B;
  } else {
#line 217
    B = B;
  }
#line 218
  Hi_A = (unsigned long )(A >> (sizeof(long ) * 8UL) / 2UL) & ((1UL << (sizeof(long ) * 8UL) / 2UL) - 1UL);
#line 219
  Hi_B = (unsigned long )(B >> (sizeof(long ) * 8UL) / 2UL) & ((1UL << (sizeof(long ) * 8UL) / 2UL) - 1UL);
#line 220
  if (Hi_A > 0UL) {
#line 220
    if (Hi_B > 0UL) {
#line 221
      return (0UL);
    }
  }
#line 222
  Lo_A = (unsigned long )A & ((1UL << (sizeof(long ) * 8UL) / 2UL) - 1UL);
#line 223
  Lo_B = (unsigned long )B & ((1UL << (sizeof(long ) * 8UL) / 2UL) - 1UL);
#line 224
  Lo_C = Lo_A * Lo_B;
#line 225
  if (Lo_C >= 144115188075855872UL) {
#line 226
    return (0UL);
  }
#line 227
  Middle_C = Lo_A * Hi_B + Hi_A * Lo_B;
#line 228
  if (Middle_C >= 1UL << (57UL - (sizeof(long ) * 8UL) / 2UL)) {
#line 229
    return (0UL);
  }
#line 230
  C = (long )(Lo_C + (Middle_C << (sizeof(long ) * 8UL) / 2UL));
#line 231
  if (((unsigned long )C & 0xfe00000000000000UL) == 0UL) {
#line 231
    goto _L;
  } else
#line 231
  if (((unsigned long )C & 0xfe00000000000000UL) == 0xfe00000000000000UL) {
    _L: /* CIL Label */ 
#line 233
    if (Sign) {
#line 234
      return ((26UL << 58U) | (unsigned long )C);
    } else
#line 233
    if (C == 0L) {
#line 234
      return ((26UL << 58U) | (unsigned long )C);
    } else {
#line 236
      return ((26UL << 58U) | ((1UL << 58U) - (unsigned long )C));
    }
  }
#line 238
  return (0UL);
}
}
#line 150 "/home/khheo/project/mit-scheme-9.2/src/microcode/fixnum.c"
SCHEME_OBJECT Prim_multiply_fixnum(void) 
{ 
  long result ;
  SCHEME_OBJECT tmp ;

  {
  {
#line 152
  while (1) {
    while_continue: /* CIL Label */ ;
#line 152
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 153
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 153
    if (! (*(stack_pointer + 0) >> 58U == 26UL)) {
      {
#line 153
      error_wrong_type_arg(1);
      }
    }
#line 153
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 154
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 154
    if (! (*(stack_pointer + 1) >> 58U == 26UL)) {
      {
#line 154
      error_wrong_type_arg(2);
      }
    }
#line 154
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 156
  tmp = Mul(*(stack_pointer + 0), *(stack_pointer + 1));
#line 156
  result = (long )tmp;
  }
#line 157
  if ((unsigned long )result == 0UL) {
    {
#line 158
    error_bad_range_arg(1);
    }
  }
#line 159
  return ((SCHEME_OBJECT )result);
}
}
#line 163 "/home/khheo/project/mit-scheme-9.2/src/microcode/fixnum.c"
SCHEME_OBJECT Prim_divide_fixnum(void) 
{ 
  long numerator ;
  long denominator ;
  long quotient ;
  long remainder___0 ;
  SCHEME_OBJECT tmp ;

  {
  {
#line 169
  while (1) {
    while_continue: /* CIL Label */ ;
#line 169
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 170
  numerator = arg_fixnum(1);
#line 171
  denominator = arg_fixnum(2);
  }
#line 172
  if (denominator == 0L) {
    {
#line 173
    error_bad_range_arg(2);
    }
  }
#line 177
  if (numerator < 0L) {
#line 179
    numerator = - numerator;
#line 180
    if (denominator < 0L) {
#line 182
      denominator = - denominator;
#line 183
      quotient = numerator / denominator;
    } else {
#line 186
      quotient = - (numerator / denominator);
    }
#line 187
    remainder___0 = - (numerator % denominator);
  } else {
#line 191
    if (denominator < 0L) {
#line 193
      denominator = - denominator;
#line 194
      quotient = - (numerator / denominator);
    } else {
#line 197
      quotient = numerator / denominator;
    }
#line 198
    remainder___0 = numerator % denominator;
  }
#line 200
  if (! (((unsigned long )quotient & 0xfe00000000000000UL) == 0UL)) {
#line 200
    if (! (((unsigned long )quotient & 0xfe00000000000000UL) == 0xfe00000000000000UL)) {
      {
#line 201
      error_bad_range_arg(1);
      }
    }
  }
  {
#line 202
  tmp = cons((26UL << 58U) | ((unsigned long )quotient & 288230376151711743UL), (26UL << 58U) | ((unsigned long )remainder___0 & 288230376151711743UL));
  }
#line 202
  return (tmp);
}
}
#line 206 "/home/khheo/project/mit-scheme-9.2/src/microcode/fixnum.c"
SCHEME_OBJECT Prim_fixnum_quotient(void) 
{ 
  long numerator ;
  long tmp ;
  long denominator ;
  long tmp___0 ;
  long result ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
  {
#line 208
  while (1) {
    while_continue: /* CIL Label */ ;
#line 208
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 210
  tmp = arg_fixnum(1);
#line 210
  numerator = tmp;
#line 211
  tmp___0 = arg_fixnum(2);
#line 211
  denominator = tmp___0;
  }
#line 212
  if (denominator == 0L) {
    {
#line 213
    error_bad_range_arg(2);
    }
  }
  {
#line 214
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 214
    if (denominator > 0L) {
#line 214
      if (numerator >= 0L) {
#line 214
        tmp___1 = numerator / denominator;
      } else {
#line 214
        tmp___1 = - (- numerator / denominator);
      }
#line 214
      tmp___3 = tmp___1;
    } else {
#line 214
      if (numerator >= 0L) {
#line 214
        tmp___2 = - (numerator / - denominator);
      } else {
#line 214
        tmp___2 = - numerator / - denominator;
      }
#line 214
      tmp___3 = tmp___2;
    }
#line 214
    result = tmp___3;
#line 214
    if (! (((unsigned long )result & 0xfe00000000000000UL) == 0UL)) {
#line 214
      if (! (((unsigned long )result & 0xfe00000000000000UL) == 0xfe00000000000000UL)) {
        {
#line 214
        error_bad_range_arg(1);
        }
      }
    }
#line 214
    return ((26UL << 58U) | ((unsigned long )result & 288230376151711743UL));
#line 214
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 216
  return (0UL);
}
}
#line 218 "/home/khheo/project/mit-scheme-9.2/src/microcode/fixnum.c"
SCHEME_OBJECT Prim_fixnum_remainder(void) 
{ 
  long numerator ;
  long tmp ;
  long denominator ;
  long tmp___0 ;
  long result ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
  {
#line 220
  while (1) {
    while_continue: /* CIL Label */ ;
#line 220
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 222
  tmp = arg_fixnum(1);
#line 222
  numerator = tmp;
#line 223
  tmp___0 = arg_fixnum(2);
#line 223
  denominator = tmp___0;
  }
#line 224
  if (denominator == 0L) {
    {
#line 225
    error_bad_range_arg(2);
    }
  }
  {
#line 226
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 226
    if (denominator > 0L) {
#line 226
      if (numerator >= 0L) {
#line 226
        tmp___1 = numerator % denominator;
      } else {
#line 226
        tmp___1 = - (- numerator % denominator);
      }
#line 226
      tmp___3 = tmp___1;
    } else {
#line 226
      if (numerator >= 0L) {
#line 226
        tmp___2 = numerator % - denominator;
      } else {
#line 226
        tmp___2 = - (- numerator % - denominator);
      }
#line 226
      tmp___3 = tmp___2;
    }
#line 226
    result = tmp___3;
#line 226
    if (! (((unsigned long )result & 0xfe00000000000000UL) == 0UL)) {
#line 226
      if (! (((unsigned long )result & 0xfe00000000000000UL) == 0xfe00000000000000UL)) {
        {
#line 226
        error_bad_range_arg(1);
        }
      }
    }
#line 226
    return ((26UL << 58U) | ((unsigned long )result & 288230376151711743UL));
#line 226
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 228
  return (0UL);
}
}
#line 230 "/home/khheo/project/mit-scheme-9.2/src/microcode/fixnum.c"
SCHEME_OBJECT Prim_gcd_fixnum(void) 
{ 
  long x ;
  long tmp ;
  long y ;
  long tmp___0 ;
  long z ;

  {
  {
#line 232
  while (1) {
    while_continue: /* CIL Label */ ;
#line 232
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 234
  tmp = arg_fixnum(1);
#line 234
  x = tmp;
#line 235
  tmp___0 = arg_fixnum(2);
#line 235
  y = tmp___0;
  }
#line 236
  if (x < 0L) {
#line 236
    x = - x;
  }
#line 237
  if (y < 0L) {
#line 237
    y = - y;
  }
  {
#line 238
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 238
    if (! (y != 0L)) {
#line 238
      goto while_break___0;
    }
#line 240
    z = x;
#line 241
    x = y;
#line 242
    y = z % y;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 244
  return ((26UL << 58U) | ((unsigned long )x & 288230376151711743UL));
}
}
#line 260 "/home/khheo/project/mit-scheme-9.2/src/microcode/fixnum.c"
SCHEME_OBJECT Prim_fixnum_andc(void) 
{ 
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
  {
#line 261
  while (1) {
    while_continue: /* CIL Label */ ;
#line 261
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 261
  tmp = arg_unsigned_fixnum(1);
#line 261
  tmp___0 = arg_unsigned_fixnum(2);
  }
#line 261
  return ((26UL << 58U) | ((tmp & ~ tmp___0) & 288230376151711743UL));
}
}
#line 263 "/home/khheo/project/mit-scheme-9.2/src/microcode/fixnum.c"
SCHEME_OBJECT Prim_fixnum_and(void) 
{ 
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
  {
#line 264
  while (1) {
    while_continue: /* CIL Label */ ;
#line 264
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 264
  tmp = arg_unsigned_fixnum(1);
#line 264
  tmp___0 = arg_unsigned_fixnum(2);
  }
#line 264
  return ((26UL << 58U) | ((tmp & tmp___0) & 288230376151711743UL));
}
}
#line 266 "/home/khheo/project/mit-scheme-9.2/src/microcode/fixnum.c"
SCHEME_OBJECT Prim_fixnum_or(void) 
{ 
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
  {
#line 267
  while (1) {
    while_continue: /* CIL Label */ ;
#line 267
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 267
  tmp = arg_unsigned_fixnum(1);
#line 267
  tmp___0 = arg_unsigned_fixnum(2);
  }
#line 267
  return ((26UL << 58U) | ((tmp | tmp___0) & 288230376151711743UL));
}
}
#line 269 "/home/khheo/project/mit-scheme-9.2/src/microcode/fixnum.c"
SCHEME_OBJECT Prim_fixnum_xor(void) 
{ 
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
  {
#line 270
  while (1) {
    while_continue: /* CIL Label */ ;
#line 270
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 270
  tmp = arg_unsigned_fixnum(1);
#line 270
  tmp___0 = arg_unsigned_fixnum(2);
  }
#line 270
  return ((26UL << 58U) | ((tmp ^ tmp___0) & 288230376151711743UL));
}
}
#line 272 "/home/khheo/project/mit-scheme-9.2/src/microcode/fixnum.c"
SCHEME_OBJECT Prim_fixnum_not(void) 
{ 
  unsigned long tmp ;

  {
  {
#line 274
  while (1) {
    while_continue: /* CIL Label */ ;
#line 274
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 275
  tmp = arg_unsigned_fixnum(1);
  }
#line 275
  return ((26UL << 58U) | (~ tmp & 288230376151711743UL));
}
}
#line 278 "/home/khheo/project/mit-scheme-9.2/src/microcode/fixnum.c"
SCHEME_OBJECT Prim_fixnum_lsh(void) 
{ 
  unsigned long x ;
  unsigned long tmp ;
  long y ;
  long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;

  {
  {
#line 280
  while (1) {
    while_continue: /* CIL Label */ ;
#line 280
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 282
  tmp = arg_unsigned_fixnum(1);
#line 282
  x = tmp;
#line 283
  tmp___0 = arg_fixnum(2);
#line 283
  y = tmp___0;
  }
#line 285
  if (y >= 0L) {
#line 285
    if (y > 58L) {
#line 285
      tmp___1 = 0UL;
    } else {
#line 285
      tmp___1 = x << y;
    }
#line 285
    tmp___3 = tmp___1;
  } else {
#line 285
    if (- y > 58L) {
#line 285
      tmp___2 = 0UL;
    } else {
#line 285
      tmp___2 = (x & 288230376151711743UL) >> - y;
    }
#line 285
    tmp___3 = tmp___2;
  }
#line 285
  return ((26UL << 58U) | (tmp___3 & 288230376151711743UL));
}
}
#line 289 "/home/khheo/project/mit-scheme-9.2/src/microcode/fixnum.c"
SCHEME_OBJECT Prim_fixnum_to_flonum(void) 
{ 
  long tmp ;
  SCHEME_OBJECT tmp___0 ;

  {
  {
#line 293
  while (1) {
    while_continue: /* CIL Label */ ;
#line 293
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 294
  tmp = arg_fixnum(1);
#line 294
  tmp___0 = double_to_flonum((double )tmp);
  }
#line 294
  return (tmp___0);
}
}
#line 203 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasl.h"
_Bool read_from_fasl_file(void *start , size_t n_words , fasl_file_handle_t handle ) ;
#line 204
SCHEME_OBJECT *fasl_object_address(SCHEME_OBJECT o , fasl_header_t *h ) ;
#line 205
insn_t *fasl_cc_address(SCHEME_OBJECT o , fasl_header_t *h ) ;
#line 206
SCHEME_OBJECT fasl_raw_address_to_object(unsigned int type , SCHEME_OBJECT *address___0 ,
                                         fasl_header_t *h ) ;
#line 208
SCHEME_OBJECT fasl_raw_address_to_cc_entry(insn_t *address___0 , fasl_header_t *h ) ;
#line 209
SCHEME_OBJECT *faslhdr_utilities_end(fasl_header_t *h ) ;
#line 42 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasload.c"
static fasl_header_t fasl_header  ;
#line 43 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasload.c"
static fasl_header_t *fh  ;
#line 44 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasload.c"
static SCHEME_OBJECT *new_heap_start  ;
#line 45 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasload.c"
static SCHEME_OBJECT *new_constant_start  ;
#line 46 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasload.c"
static SCHEME_OBJECT *new_stack_start  ;
#line 47 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasload.c"
static SCHEME_OBJECT *new_stack_end  ;
#line 48 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasload.c"
static SCHEME_OBJECT *new_utilities  ;
#line 49 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasload.c"
static SCHEME_OBJECT *new_prim_table  ;
#line 64 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasload.c"
static char const   *reload_band_name  =    (char const   *)0;
#line 65 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasload.c"
static Tptrvec reload_cleanups  =    (Tptrvec )0;
#line 66 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasload.c"
static unsigned long reload_heap_size  =    0UL;
#line 67 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasload.c"
static unsigned long reload_constant_size  =    0UL;
#line 69
static void init_fasl_file(char const   *file_name , _Bool band_p , fasl_file_handle_t *handle ) ;
#line 70
static void close_fasl_file(void *p ) ;
#line 72
static SCHEME_OBJECT load_file(fasl_file_handle_t handle , unsigned long old_ephemeron_count ) ;
#line 73
static void *read_from_file(void *p , size_t n_words , fasl_file_handle_t handle ) ;
#line 74
static _Bool primitive_numbers_unchanged_p(SCHEME_OBJECT *table___3 ) ;
#line 76
static gc_table_t *relocate_block_table(void) ;
#line 77
static SCHEME_OBJECT *handle_primitive(SCHEME_OBJECT *scan , SCHEME_OBJECT object ) ;
#line 78
static SCHEME_OBJECT fasload_tuple(SCHEME_OBJECT tuple , unsigned int n_words ) ;
#line 79
static SCHEME_OBJECT fasload_vector(SCHEME_OBJECT vector , _Bool align_p ) ;
#line 80
static SCHEME_OBJECT fasload_cc_entry(SCHEME_OBJECT object ) ;
#line 81
static SCHEME_OBJECT fasload_raw_address_to_object(unsigned int type , SCHEME_OBJECT *address___0 ) ;
#line 82
static SCHEME_OBJECT fasload_raw_address_to_cc_entry(insn_t *address___0 ) ;
#line 83
static void *relocate_address(void *vaddr ) ;
#line 85
static gc_table_t *intern_block_table(void) ;
#line 86
static SCHEME_OBJECT *intern_handle_symbol(SCHEME_OBJECT *scan , SCHEME_OBJECT object ) ;
#line 87
static SCHEME_OBJECT intern_tuple(SCHEME_OBJECT tuple , unsigned int n_words ) ;
#line 88
static SCHEME_OBJECT intern_vector(SCHEME_OBJECT vector , _Bool align_p ) ;
#line 89
static SCHEME_OBJECT intern_cc_entry(SCHEME_OBJECT object ) ;
#line 91
static SCHEME_OBJECT read_band_file(SCHEME_OBJECT s ) ;
#line 92
static void terminate_band_load(void *ap ) ;
#line 101 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasload.c"
static unsigned long failed_heap_length  =    0UL;
#line 94 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasload.c"
SCHEME_OBJECT Prim_binary_fasload(void) 
{ 
  fasl_file_handle_t handle ;
  unsigned long heap_length ;
  unsigned long n_ephemerons ;
  unsigned long extra_ephemeron_space ;
  SCHEME_OBJECT result ;
  char *tmp ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;
  SCHEME_OBJECT *tmp___2 ;

  {
#line 103
  n_ephemerons = 0UL;
#line 104
  extra_ephemeron_space = 0UL;
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
#line 106
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 108
  canonicalize_primitive_context();
#line 109
  transaction_begin();
  }
#line 111
  if (*(stack_pointer + 0) >> 58U == 30UL) {
#line 111
    tmp = (char *)((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 2);
  } else {
    {
#line 111
    error_wrong_type_arg(1);
#line 111
    tmp = (char *)0;
    }
  }
  {
#line 111
  init_fasl_file((char const   *)tmp, (_Bool)0, & handle);
  }
#line 112
  if ((unsigned long )(fh->constant_end - fh->constant_start) > 0UL) {
    {
#line 113
    signal_error_from_primitive(23L);
    }
  }
#line 115
  heap_length = ((unsigned long )(fh->heap_end - fh->heap_start) + fh->n_primitives) + fh->primitive_table_size;
#line 116
  if ((unsigned int )fh->version >= 12U) {
    {
#line 118
    n_ephemerons = fh->ephemeron_count;
#line 119
    extra_ephemeron_space = compute_extra_ephemeron_space(ephemeron_count + n_ephemerons);
    }
  }
#line 122
  if ((unsigned long )Free >= (unsigned long )heap_start) {
#line 122
    if ((unsigned long )Free < (unsigned long )heap_alloc_limit) {
#line 122
      if (! ((unsigned long )(Free + (heap_length + extra_ephemeron_space)) <= (unsigned long )heap_alloc_limit)) {
#line 122
        goto _L___0;
      }
    } else {
#line 122
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 122
  if ((Registers[1] & 4UL) != 0UL) {
#line 124
    if (heap_length == failed_heap_length) {
      {
#line 125
      signal_error_from_primitive(23L);
      }
    }
#line 126
    failed_heap_length = heap_length;
#line 127
    n_ephemerons_requested = n_ephemerons;
#line 128
    ephemeron_request_hard_p = (_Bool)0;
    {
#line 129
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 129
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 129
        set_ulong_register(12U, Registers[12] | 4UL);
        }
        {
#line 129
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 129
          if ((Registers[1] & Registers[12]) != 0UL) {
#line 129
            tmp___1 = memory_block_start;
          } else {
#line 129
            if ((Registers[1] & 4UL) != 0UL) {
#line 129
              tmp___0 = heap_alloc_limit;
            } else {
#line 129
              tmp___0 = heap_end;
            }
#line 129
            tmp___1 = tmp___0;
          }
          {
#line 129
          set_ptr_register(0U, tmp___1);
          }
#line 129
          if ((Registers[1] & 1UL) != 0UL) {
#line 129
            tmp___2 = stack_guard;
          } else {
#line 129
            tmp___2 = stack_start;
          }
          {
#line 129
          set_ptr_register(11U, tmp___2);
          }
#line 129
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 129
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 129
      gc_space_needed = heap_length;
#line 129
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 130
    signal_interrupt_from_primitive();
    }
  }
  {
#line 132
  failed_heap_length = 0UL;
#line 134
  result = load_file(handle, ephemeron_count);
#line 135
  transaction_commit();
  }
#line 136
  return (result);
}
}
#line 139 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasload.c"
static void init_fasl_file(char const   *file_name , _Bool band_p , fasl_file_handle_t *handle ) 
{ 
  _Bool tmp ;
  _Bool tmp___0 ;
  fasl_read_status_t tmp___1 ;
  fasl_read_status_t tmp___2 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 143
  tmp = open_fasl_input_file(file_name, handle);
  }
#line 143
  if (! tmp) {
    {
#line 144
    error_bad_range_arg(1);
    }
  }
  {
#line 145
  transaction_record_action((enum transaction_action_type )2, & close_fasl_file, (void *)handle);
#line 147
  fh = & fasl_header;
#line 148
  tmp___0 = read_fasl_header(fh, *handle);
  }
#line 148
  if (! tmp___0) {
    {
#line 149
    signal_error_from_primitive(24L);
    }
  }
  {
#line 152
  tmp___1 = check_fasl_version(fh);
  }
#line 152
  if ((unsigned int )tmp___1 != 0U) {
    {
#line 154
    outf_error("\nBad version in FASL File: %s\n", file_name);
#line 155
    outf_error("File has: version %u architecture %u.\n", (unsigned int )fh->version,
               (unsigned int )fh->arch);
#line 158
    outf_error("Expected: version between %u and %u architecture %u.\n", 10, 12, 21);
#line 163
    signal_error_from_primitive(24L);
    }
  }
  {
#line 168
  tmp___2 = check_fasl_cc_version(fh, (unsigned long )compiler_interface_version,
                                  (unsigned long )compiler_processor_type);
  }
#line 168
  if ((unsigned int )tmp___2 != 0U) {
    {
#line 173
    outf_error("\nBad compiled-code version in FASL File: %s\n", file_name);
#line 174
    outf_error("File has: compiled-code interface %u; architecture %u.\n", fh->cc_version,
               (unsigned int )fh->cc_arch);
#line 177
    outf_error("Expected: compiled-code interface %u; architecture %u.\n", compiler_interface_version,
               (unsigned int )compiler_processor_type);
#line 180
    signal_error_from_primitive(58L);
    }
  }
#line 184
  if ((int )fh->band_p != (int )band_p) {
    {
#line 185
    signal_error_from_primitive(57L);
    }
  }
#line 186
  return;
}
}
#line 188 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasload.c"
static void close_fasl_file(void *p ) 
{ 


  {
  {
#line 191
  close_fasl_input_file(*((fasl_file_handle_t *)p));
  }
#line 192
  return;
}
}
#line 194 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasload.c"
SCHEME_OBJECT Prim_band_load(void) 
{ 
  SCHEME_OBJECT result ;
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;
  char const   *name ;

  {
  {
#line 200
  while (1) {
    while_continue: /* CIL Label */ ;
#line 200
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 202
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 202
    if (! (*(stack_pointer + 0) >> 58U == 30UL)) {
      {
#line 202
      error_wrong_type_arg(1);
      }
    }
#line 202
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 203
  canonicalize_primitive_context();
#line 204
  result = read_band_file(*(stack_pointer + 0));
  }
  {
#line 207
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 207
    set_ulong_register(1U, 0UL);
#line 207
    set_ulong_register(12U, 0UL);
    }
    {
#line 207
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 207
      if ((Registers[1] & Registers[12]) != 0UL) {
#line 207
        tmp___0 = memory_block_start;
      } else {
#line 207
        if ((Registers[1] & 4UL) != 0UL) {
#line 207
          tmp = heap_alloc_limit;
        } else {
#line 207
          tmp = heap_end;
        }
#line 207
        tmp___0 = tmp;
      }
      {
#line 207
      set_ptr_register(0U, tmp___0);
      }
#line 207
      if ((Registers[1] & 1UL) != 0UL) {
#line 207
        tmp___1 = stack_guard;
      } else {
#line 207
        tmp___1 = stack_start;
      }
      {
#line 207
      set_ptr_register(11U, tmp___1);
      }
#line 207
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 207
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 209
  compiler_utilities = *((SCHEME_OBJECT *)(result & 288230376151711743UL) + 1);
#line 210
  if (compiler_utilities != 0UL) {
    {
#line 211
    compiler_reset(compiler_utilities);
    }
  } else {
    {
#line 213
    compiler_initialize((_Bool)1);
    }
  }
#line 215
  fixed_objects = 0UL;
#line 218
  Registers[6] = 11UL << 58U;
#line 219
  Registers[5] = 0UL;
  {
#line 220
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 220
    stack_pointer --;
#line 220
    *stack_pointer = Registers[5];
#line 220
    stack_pointer --;
#line 220
    *stack_pointer = Registers[6];
#line 220
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 221
  Registers[5] = *((SCHEME_OBJECT *)(result & 288230376151711743UL) + 0);
#line 222
  Registers[3] = 0UL;
#line 225
  trapping = (_Bool)0;
#line 226
  history_register = make_dummy_history();
#line 227
  prev_restore_history_offset = 0UL;
  }
  {
#line 228
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 228
    set_ptr_register(9U, (SCHEME_OBJECT *)0);
#line 228
    set_ptr_register(10U, (SCHEME_OBJECT *)0);
    }
    {
#line 228
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 228
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 228
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 229
  execute_reload_cleanups();
  }
  {
#line 230
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 230
    if (critical_section_hook_p) {
      {
#line 230
      name = critical_section_name;
#line 230
      critical_section_hook_p = (_Bool)0;
#line 230
      critical_section_name = (char const   *)0;
#line 230
      (*critical_section_hook)(name);
      }
    } else {
#line 230
      critical_section_name = (char const   *)0;
    }
#line 230
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 233
  abort_to_interpreter(-2);
  }
#line 235
  return ((8UL << 58U) | 1UL);
}
}
#line 238 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasload.c"
static SCHEME_OBJECT read_band_file(SCHEME_OBJECT s ) 
{ 
  char const   *file_name ;
  struct load_band_termination_state *state ;
  fasl_file_handle_t handle ;
  SCHEME_OBJECT result ;
  void *old_name ;
  void *tmp ;
  void *tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  _Bool tmp___3 ;
  char *__cil_tmp12 ;

  {
  {
#line 247
  transaction_begin();
#line 248
  tmp = OS_malloc((*((SCHEME_OBJECT *)(s & 288230376151711743UL) + 1) & 288230376151711743UL) + 1UL);
#line 248
  file_name = (char const   *)tmp;
#line 249
  strcpy((char */* __restrict  */)((char *)file_name), (char const   */* __restrict  */)((char *)((SCHEME_OBJECT *)(s & 288230376151711743UL) + 2)));
#line 250
  tmp___0 = dstack_alloc((unsigned int )sizeof(struct load_band_termination_state ));
#line 250
  state = (struct load_band_termination_state *)tmp___0;
#line 251
  state->file_name = file_name;
#line 252
  state->no_return_p = (_Bool)0;
#line 253
  transaction_record_action((enum transaction_action_type )0, & terminate_band_load,
                            (void *)state);
#line 255
  init_fasl_file(file_name, (_Bool)1, & handle);
  }
#line 256
  if ((unsigned int )fh->version >= 12U) {
    {
#line 256
    tmp___1 = compute_extra_ephemeron_space(fh->ephemeron_count);
#line 256
    tmp___2 = tmp___1;
    }
  } else {
#line 256
    tmp___2 = 0UL;
  }
  {
#line 256
  tmp___3 = allocations_ok_p((unsigned long )(fh->constant_end - fh->constant_start),
                             (((unsigned long )(fh->heap_end - fh->heap_start) + fh->n_primitives) + fh->primitive_table_size) + tmp___2,
                             fh->heap_reserved);
  }
#line 256
  if (! tmp___3) {
    {
#line 263
    signal_error_from_primitive(23L);
    }
  }
  {
#line 267
  critical_section_name = "band load";
#line 268
  state->no_return_p = (_Bool)1;
#line 270
  reset_allocator_parameters((unsigned long )(fh->constant_end - fh->constant_start),
                             fh->heap_reserved);
#line 273
  ephemeron_array = 0UL;
#line 274
  result = load_file(handle, 0UL);
#line 277
  transaction_commit();
#line 280
  old_name = (void *)reload_band_name;
#line 281
  reload_band_name = file_name;
  }
#line 282
  if ((unsigned long )old_name != (unsigned long )((void *)0)) {
    {
#line 283
    OS_free(old_name);
    }
  }
#line 285
  return (result);
}
}
#line 288 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasload.c"
static void terminate_band_load(void *ap ) 
{ 
  struct load_band_termination_state *state ;
  int abort_value ;
  char const   *message ;
  char const   *tmp ;
  char const   *name ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 291
  state = (struct load_band_termination_state *)ap;
#line 294
  if (! state->no_return_p) {
    {
#line 296
    OS_free((void *)state->file_name);
    }
#line 297
    return;
  }
  {
#line 300
  abort_value = abort_to_interpreter_argument();
#line 302
  fputs((char const   */* __restrict  */)"\nload-band: ", (FILE */* __restrict  */)stderr);
  }
#line 303
  if (abort_value > 0) {
#line 305
    if (abort_value <= 63) {
#line 305
      tmp = Error_Names[abort_value];
    } else {
#line 305
      tmp = (char const   *)0;
    }
#line 305
    message = tmp;
#line 309
    if ((unsigned long )message == (unsigned long )((char const   *)0)) {
      {
#line 310
      outf_fatal("Unknown error %#lx", (unsigned long )abort_value);
      }
    } else {
      {
#line 312
      outf_fatal("Error %#lx (%s)", (unsigned long )abort_value, message);
      }
    }
  } else {
    {
#line 316
    abort_value = - abort_value - 1;
#line 317
    outf_fatal("Abort %d (%s)", abort_value, Abort_Names[abort_value]);
    }
  }
  {
#line 319
  outf_fatal(" past the point of no return.\n");
#line 320
  outf_fatal("file name = \"%s\".\n", state->file_name);
#line 321
  OS_free((void *)state->file_name);
#line 323
  execute_reload_cleanups();
  }
  {
#line 324
  while (1) {
    while_continue: /* CIL Label */ ;
#line 324
    if (critical_section_hook_p) {
      {
#line 324
      name = critical_section_name;
#line 324
      critical_section_hook_p = (_Bool)0;
#line 324
      critical_section_name = (char const   *)0;
#line 324
      (*critical_section_hook)(name);
      }
    } else {
#line 324
      critical_section_name = (char const   *)0;
    }
#line 324
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 325
  Microcode_Termination(1);
  }
}
}
#line 329 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasload.c"
SCHEME_OBJECT Prim_reload_band_name(void) 
{ 
  SCHEME_OBJECT tmp ;
  SCHEME_OBJECT tmp___0 ;
  SCHEME_OBJECT tmp___1 ;
  SCHEME_OBJECT tmp___2 ;

  {
  {
#line 333
  while (1) {
    while_continue: /* CIL Label */ ;
#line 333
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 334
  if ((unsigned long )reload_band_name != (unsigned long )((char const   *)0)) {
    {
#line 334
    tmp = char_pointer_to_string(reload_band_name);
#line 334
    tmp___2 = tmp;
    }
  } else {
#line 334
    if ((unsigned long )option_band_file != (unsigned long )((char const   *)0)) {
      {
#line 334
      tmp___0 = char_pointer_to_string(option_band_file);
#line 334
      tmp___1 = tmp___0;
      }
    } else {
#line 334
      tmp___1 = 0UL;
    }
#line 334
    tmp___2 = tmp___1;
  }
#line 334
  return (tmp___2);
}
}
#line 342 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasload.c"
void get_band_parameters(unsigned long *heap_size , unsigned long *const_size ) 
{ 


  {
#line 345
  *heap_size = reload_heap_size;
#line 346
  *const_size = reload_constant_size;
#line 347
  return;
}
}
#line 349 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasload.c"
void add_reload_cleanup(void (*cleanup_procedure)(void) ) 
{ 


  {
#line 352
  if ((unsigned long )reload_cleanups == (unsigned long )((Tptrvec )0)) {
    {
#line 354
    reload_cleanups = ptrvec_allocate((Tptrvec_length )1);
#line 355
    *((cleanup_t *)(reload_cleanups->elements + 0)) = cleanup_procedure;
    }
  } else {
    {
#line 359
    ptrvec_adjoin(reload_cleanups, (void *)cleanup_procedure);
    }
  }
#line 360
  return;
}
}
#line 362 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasload.c"
void execute_reload_cleanups(void) 
{ 
  void **scan ;
  void **end ;
  void **tmp ;

  {
#line 365
  scan = reload_cleanups->elements + 0;
#line 366
  end = reload_cleanups->elements + reload_cleanups->length;
  {
#line 367
  while (1) {
    while_continue: /* CIL Label */ ;
#line 367
    if (! ((unsigned long )scan < (unsigned long )end)) {
#line 367
      goto while_break;
    }
    {
#line 368
    tmp = scan;
#line 368
    scan ++;
#line 368
    (*(*((cleanup_t *)tmp)))();
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 369
  return;
}
}
#line 371 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasload.c"
static SCHEME_OBJECT load_file(fasl_file_handle_t handle , unsigned long old_ephemeron_count ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  SCHEME_OBJECT *raw_prim_table ;
  _Bool tmp___1 ;
  void *tmp___2 ;

  {
#line 374
  new_heap_start = Free;
#line 375
  new_constant_start = constant_alloc_next;
#line 376
  new_stack_start = stack_start;
#line 377
  new_stack_end = stack_end;
#line 378
  if (compiler_utilities == 0UL) {
#line 378
    new_utilities = (SCHEME_OBJECT *)0;
  } else {
#line 378
    new_utilities = (SCHEME_OBJECT *)(compiler_utilities & 288230376151711743UL);
  }
  {
#line 383
  tmp = read_from_file((void *)Free, (unsigned long )(fh->heap_end - fh->heap_start),
                       handle);
#line 383
  Free = (SCHEME_OBJECT *)tmp;
#line 384
  tmp___0 = read_from_file((void *)constant_alloc_next, (unsigned long )(fh->constant_end - fh->constant_start),
                           handle);
#line 384
  constant_alloc_next = (SCHEME_OBJECT *)tmp___0;
#line 389
  new_prim_table = Free;
#line 391
  raw_prim_table = Free + fh->n_primitives;
#line 392
  read_from_file((void *)raw_prim_table, fh->primitive_table_size, handle);
#line 395
  import_primitive_table(raw_prim_table, fh->n_primitives, new_prim_table);
  }
#line 412
  if (! fh->band_p) {
#line 412
    if (fh->utilities_vector != 0UL) {
#line 412
      if (compiler_utilities == 0UL) {
        {
#line 417
        signal_error_from_primitive(58L);
        }
      }
    }
  }
#line 419
  if (fh->band_p) {
#line 419
    if ((unsigned long )fh->heap_start == (unsigned long )new_heap_start) {
#line 419
      if ((unsigned long )fh->constant_start == (unsigned long )new_constant_start) {
#line 419
        goto _L___0;
      } else
#line 419
      if ((unsigned long )fh->constant_start == (unsigned long )fh->constant_end) {
        _L___0: /* CIL Label */ 
#line 419
        if ((unsigned long )fh->stack_start == (unsigned long )((SCHEME_OBJECT *)0)) {
#line 419
          goto _L;
        } else
#line 419
        if ((unsigned long )fh->stack_start == (unsigned long )new_stack_start) {
          _L: /* CIL Label */ 
#line 419
          if ((unsigned long )fh->stack_end == (unsigned long )new_stack_end) {
            {
#line 419
            tmp___1 = primitive_numbers_unchanged_p(new_prim_table);
            }
#line 419
            if (! tmp___1) {
              {
#line 431
              current_gc_table = relocate_block_table();
#line 432
              gc_scan_oldspace(new_heap_start, Free);
#line 433
              gc_scan_oldspace(new_constant_start, constant_alloc_next);
              }
            }
          } else {
            {
#line 431
            current_gc_table = relocate_block_table();
#line 432
            gc_scan_oldspace(new_heap_start, Free);
#line 433
            gc_scan_oldspace(new_constant_start, constant_alloc_next);
            }
          }
        } else {
          {
#line 431
          current_gc_table = relocate_block_table();
#line 432
          gc_scan_oldspace(new_heap_start, Free);
#line 433
          gc_scan_oldspace(new_constant_start, constant_alloc_next);
          }
        }
      } else {
        {
#line 431
        current_gc_table = relocate_block_table();
#line 432
        gc_scan_oldspace(new_heap_start, Free);
#line 433
        gc_scan_oldspace(new_constant_start, constant_alloc_next);
        }
      }
    } else {
      {
#line 431
      current_gc_table = relocate_block_table();
#line 432
      gc_scan_oldspace(new_heap_start, Free);
#line 433
      gc_scan_oldspace(new_constant_start, constant_alloc_next);
      }
    }
  } else {
    {
#line 431
    current_gc_table = relocate_block_table();
#line 432
    gc_scan_oldspace(new_heap_start, Free);
#line 433
    gc_scan_oldspace(new_constant_start, constant_alloc_next);
    }
  }
#line 435
  if (! fh->band_p) {
    {
#line 437
    current_gc_table = intern_block_table();
#line 438
    gc_scan_oldspace(new_heap_start, Free);
#line 439
    gc_scan_oldspace(new_constant_start, constant_alloc_next);
    }
  }
#line 452
  if ((unsigned int )fh->version >= 12U) {
    {
#line 453
    guarantee_extra_ephemeron_space(old_ephemeron_count + fh->ephemeron_count);
    }
  }
  {
#line 456
  tmp___2 = relocate_address((void *)fh->root_pointer);
  }
#line 456
  return (*((SCHEME_OBJECT *)tmp___2));
}
}
#line 461 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasload.c"
static void *read_from_file(void *p , size_t n_words , fasl_file_handle_t handle ) 
{ 
  _Bool tmp ;

  {
  {
#line 464
  tmp = read_from_fasl_file(p, n_words, handle);
  }
#line 464
  if (! tmp) {
    {
#line 465
    signal_error_from_primitive(24L);
    }
  }
#line 466
  return ((void *)((char *)p + n_words * 8UL));
}
}
#line 469 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasload.c"
static _Bool primitive_numbers_unchanged_p(SCHEME_OBJECT *table___3 ) 
{ 
  unsigned long count ;

  {
#line 474
  count = 0UL;
  {
#line 474
  while (1) {
    while_continue: /* CIL Label */ ;
#line 474
    if (! (count < fh->n_primitives)) {
#line 474
      goto while_break;
    }
#line 475
    if (*(table___3 + count) != ((24UL << 58U) | count)) {
#line 476
      return ((_Bool)0);
    }
#line 474
    count ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 477
  return ((_Bool)1);
}
}
#line 483 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasload.c"
static _Bool initialized_p___0  =    (_Bool)0;
#line 484 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasload.c"
static gc_table_t table___0  ;
#line 480 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasload.c"
static gc_table_t *relocate_block_table(void) 
{ 


  {
#line 486
  if (! initialized_p___0) {
    {
#line 488
    initialize_gc_table(& table___0, (_Bool)0);
#line 490
    table___0.tuple_handler = & fasload_tuple;
#line 491
    table___0.vector_handler = & fasload_vector;
#line 492
    table___0.cc_entry_handler = & fasload_cc_entry;
#line 493
    table___0.raw_address_to_object = & fasload_raw_address_to_object;
#line 494
    table___0.raw_address_to_cc_entry = & fasload_raw_address_to_cc_entry;
#line 496
    table___0.handlers[55] = & gc_handle_pair;
#line 497
    table___0.handlers[43] = & gc_handle_unaligned_vector;
#line 498
    table___0.handlers[24] = & handle_primitive;
#line 499
    table___0.handlers[34] = & gc_handle_non_pointer;
#line 501
    initialized_p___0 = (_Bool)1;
    }
  }
#line 503
  return (& table___0);
}
}
#line 506 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasload.c"
static SCHEME_OBJECT *handle_primitive(SCHEME_OBJECT *scan , SCHEME_OBJECT object ) 
{ 
  unsigned long datum ;
  unsigned long high_bits ;
  unsigned long tmp ;

  {
#line 509
  datum = object & 288230376151711743UL;
#line 510
  high_bits = datum >> 29U;
#line 511
  if (high_bits != 0UL) {
#line 511
    tmp = high_bits;
  } else {
#line 511
    tmp = datum;
  }
#line 511
  *scan = ((object >> 58U) << 58U) | (*(new_prim_table + tmp) & 288230376151711743UL);
#line 515
  return (scan + 1);
}
}
#line 521 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasload.c"
static SCHEME_OBJECT fasload_raw_address_to_object(unsigned int type , SCHEME_OBJECT *address___0 ) 
{ 
  SCHEME_OBJECT tmp ;

  {
  {
#line 524
  tmp = fasl_raw_address_to_object(type, address___0, fh);
  }
#line 524
  return (tmp);
}
}
#line 527 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasload.c"
static SCHEME_OBJECT fasload_raw_address_to_cc_entry(insn_t *address___0 ) 
{ 
  SCHEME_OBJECT tmp ;

  {
  {
#line 530
  tmp = fasl_raw_address_to_cc_entry(address___0, fh);
  }
#line 530
  return (tmp);
}
}
#line 538 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasload.c"
static SCHEME_OBJECT fasload_tuple(SCHEME_OBJECT tuple , unsigned int n_words ) 
{ 
  SCHEME_OBJECT *tmp ;
  void *tmp___0 ;

  {
  {
#line 541
  tmp = fasl_object_address(tuple, fh);
#line 541
  tmp___0 = relocate_address((void *)tmp);
  }
#line 541
  return (((tuple >> 58U) << 58U) | (SCHEME_OBJECT )((SCHEME_OBJECT *)tmp___0));
}
}
#line 544 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasload.c"
static SCHEME_OBJECT fasload_vector(SCHEME_OBJECT vector , _Bool align_p ) 
{ 
  SCHEME_OBJECT *tmp ;
  void *tmp___0 ;

  {
  {
#line 547
  tmp = fasl_object_address(vector, fh);
#line 547
  tmp___0 = relocate_address((void *)tmp);
  }
#line 547
  return (((vector >> 58U) << 58U) | (SCHEME_OBJECT )((SCHEME_OBJECT *)tmp___0));
}
}
#line 550 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasload.c"
static SCHEME_OBJECT fasload_cc_entry(SCHEME_OBJECT object ) 
{ 
  insn_t *tmp ;
  void *tmp___0 ;

  {
  {
#line 554
  tmp = fasl_cc_address(object, fh);
#line 554
  tmp___0 = relocate_address((void *)tmp);
  }
#line 554
  return (((object >> 58U) << 58U) | (SCHEME_OBJECT )((insn_t *)tmp___0));
}
}
#line 565 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasload.c"
static void *relocate_address(void *vaddr ) 
{ 
  byte_t *caddr ;
  byte_t *result ;
  SCHEME_OBJECT *tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 568
  caddr = (byte_t *)vaddr;
#line 571
  if ((unsigned long )caddr >= (unsigned long )((byte_t *)fh->heap_start)) {
#line 571
    if ((unsigned long )caddr < (unsigned long )((byte_t *)fh->heap_end)) {
#line 573
      result = (byte_t *)new_heap_start + (caddr - (byte_t *)fh->heap_start);
    } else {
#line 571
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 576
  if ((unsigned long )caddr >= (unsigned long )((byte_t *)fh->constant_start)) {
#line 576
    if ((unsigned long )caddr < (unsigned long )((byte_t *)fh->constant_end)) {
#line 578
      result = (byte_t *)new_constant_start + (caddr - (byte_t *)fh->constant_start);
    } else {
#line 576
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 581
  if ((unsigned long )caddr >= (unsigned long )((byte_t *)fh->utilities_start)) {
    {
#line 581
    tmp = faslhdr_utilities_end(fh);
    }
#line 581
    if ((unsigned long )caddr < (unsigned long )((byte_t *)tmp)) {
#line 583
      result = (byte_t *)new_utilities + (caddr - (byte_t *)fh->utilities_start);
    } else {
#line 581
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 586
  if ((unsigned long )caddr >= (unsigned long )((byte_t *)fh->stack_start)) {
#line 586
    if ((unsigned long )caddr < (unsigned long )((byte_t *)fh->stack_end)) {
#line 589
      result = (byte_t *)new_stack_end - ((byte_t *)fh->stack_end - caddr);
    } else {
      {
#line 598
      outf_fatal("Pointer out of range: %#lx\n", (unsigned long )caddr);
#line 599
      outf_fatal("Heap: %#lx-%#lx, Constant: %#lx-%#lx, Stack: %#lx-%#lx\n", (unsigned long )fh->heap_start,
                 (unsigned long )fh->heap_end, (unsigned long )fh->constant_start,
                 (unsigned long )fh->constant_end, (unsigned long )fh->stack_start,
                 (unsigned long )fh->stack_end);
#line 606
      signal_error_from_primitive(24L);
      }
    }
  } else {
    {
#line 598
    outf_fatal("Pointer out of range: %#lx\n", (unsigned long )caddr);
#line 599
    outf_fatal("Heap: %#lx-%#lx, Constant: %#lx-%#lx, Stack: %#lx-%#lx\n", (unsigned long )fh->heap_start,
               (unsigned long )fh->heap_end, (unsigned long )fh->constant_start, (unsigned long )fh->constant_end,
               (unsigned long )fh->stack_start, (unsigned long )fh->stack_end);
#line 606
    signal_error_from_primitive(24L);
    }
  }
#line 608
  return ((void *)result);
}
}
#line 614 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasload.c"
static _Bool initialized_p___1  =    (_Bool)0;
#line 615 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasload.c"
static gc_table_t table___1  ;
#line 611 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasload.c"
static gc_table_t *intern_block_table(void) 
{ 


  {
#line 617
  if (! initialized_p___1) {
    {
#line 619
    initialize_gc_table(& table___1, (_Bool)0);
#line 621
    table___1.tuple_handler = & intern_tuple;
#line 622
    table___1.vector_handler = & intern_vector;
#line 623
    table___1.cc_entry_handler = & intern_cc_entry;
#line 625
    table___1.handlers[55] = & gc_handle_pair;
#line 626
    table___1.handlers[43] = & gc_handle_unaligned_vector;
#line 627
    table___1.handlers[29] = & intern_handle_symbol;
#line 628
    table___1.handlers[34] = & gc_handle_non_pointer;
#line 630
    initialized_p___1 = (_Bool)1;
    }
  }
#line 633
  return (& table___1);
}
}
#line 636 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasload.c"
static SCHEME_OBJECT *intern_handle_symbol(SCHEME_OBJECT *scan , SCHEME_OBJECT object ) 
{ 
  SCHEME_OBJECT new ;
  SCHEME_OBJECT tmp ;

  {
#line 639
  if (*((SCHEME_OBJECT *)(object & 288230376151711743UL) + 1) >> 58U == 34UL) {
    {
#line 641
    *((SCHEME_OBJECT *)(object & 288230376151711743UL) + 1) = (50UL << 58U) | 2UL;
#line 643
    tmp = intern_symbol(object);
#line 643
    new = tmp;
    }
#line 644
    if (new != object) {
#line 646
      *scan = new;
#line 647
      *((SCHEME_OBJECT *)(object & 288230376151711743UL) + 0) = (34UL << 58U) | (new & 288230376151711743UL);
    }
  } else
#line 651
  if (*((SCHEME_OBJECT *)(object & 288230376151711743UL) + 0) >> 58U == 34UL) {
#line 652
    *scan = ((object >> 58U) << 58U) | (*((SCHEME_OBJECT *)(object & 288230376151711743UL) + 0) & 288230376151711743UL);
  }
#line 655
  return (scan + 1);
}
}
#line 658 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasload.c"
static SCHEME_OBJECT intern_tuple(SCHEME_OBJECT tuple , unsigned int n_words ) 
{ 


  {
#line 661
  return (tuple);
}
}
#line 664 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasload.c"
static SCHEME_OBJECT intern_vector(SCHEME_OBJECT vector , _Bool align_p ) 
{ 


  {
#line 667
  return (vector);
}
}
#line 670 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasload.c"
static SCHEME_OBJECT intern_cc_entry(SCHEME_OBJECT object ) 
{ 


  {
#line 673
  return (object);
}
}
#line 709 "/usr/include/stdio.h"
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 196 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasl.h"
_Bool open_fasl_output_file(char const   *filename , fasl_file_handle_t *handle_r ) ;
#line 197
_Bool close_fasl_output_file(fasl_file_handle_t handle ) ;
#line 198
_Bool write_fasl_header(fasl_header_t *h , fasl_file_handle_t handle ) ;
#line 199
_Bool write_to_fasl_file(void const   *start , size_t n_words , fasl_file_handle_t handle ) ;
#line 32 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasl.c"
static void encode_fasl_header(SCHEME_OBJECT *raw , fasl_header_t *h ) ;
#line 33
static _Bool decode_fasl_header(SCHEME_OBJECT *raw , fasl_header_t *h ) ;
#line 35 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasl.c"
_Bool open_fasl_output_file(char const   *filename , fasl_file_handle_t *handle_r ) 
{ 
  FILE *s ;
  FILE *tmp ;

  {
  {
#line 38
  tmp = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"wb");
#line 38
  s = tmp;
  }
#line 39
  if ((unsigned long )s == (unsigned long )((FILE *)0)) {
#line 40
    return ((_Bool)0);
  }
#line 41
  *handle_r = s;
#line 42
  return ((_Bool)1);
}
}
#line 45 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasl.c"
_Bool close_fasl_output_file(fasl_file_handle_t handle ) 
{ 
  int tmp ;

  {
  {
#line 48
  tmp = fclose(handle);
  }
#line 48
  return ((_Bool )(tmp == 0));
}
}
#line 51 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasl.c"
_Bool write_fasl_header(fasl_header_t *h , fasl_file_handle_t handle ) 
{ 
  SCHEME_OBJECT raw[50] ;
  _Bool tmp ;
  void *__cil_tmp5 ;

  {
  {
#line 56
  encode_fasl_header(raw, h);
#line 57
  tmp = write_to_fasl_file((void const   *)(raw), (size_t )50, handle);
  }
#line 57
  return (tmp);
}
}
#line 60 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasl.c"
_Bool write_to_fasl_file(void const   *start , size_t n_words , fasl_file_handle_t handle ) 
{ 
  size_t tmp ;

  {
  {
#line 64
  tmp = fwrite((void const   */* __restrict  */)start, (size_t )8, n_words, (FILE */* __restrict  */)handle);
  }
#line 64
  return ((_Bool )(tmp == n_words));
}
}
#line 67 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasl.c"
_Bool open_fasl_input_file(char const   *filename , fasl_file_handle_t *handle_r ) 
{ 
  FILE *s ;
  FILE *tmp ;

  {
  {
#line 70
  tmp = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"rb");
#line 70
  s = tmp;
  }
#line 71
  if ((unsigned long )s == (unsigned long )((FILE *)0)) {
#line 72
    return ((_Bool)0);
  }
#line 73
  *handle_r = s;
#line 74
  return ((_Bool)1);
}
}
#line 77 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasl.c"
_Bool close_fasl_input_file(fasl_file_handle_t handle ) 
{ 
  int tmp ;

  {
  {
#line 80
  tmp = fclose(handle);
  }
#line 80
  return ((_Bool )(tmp == 0));
}
}
#line 83 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasl.c"
_Bool read_fasl_header(fasl_header_t *h , fasl_file_handle_t handle ) 
{ 
  SCHEME_OBJECT raw[50] ;
  _Bool tmp ;
  _Bool tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp7 ;

  {
  {
#line 87
  tmp = read_from_fasl_file((void *)(raw), (size_t )50, handle);
  }
#line 87
  if (tmp) {
    {
#line 87
    tmp___0 = decode_fasl_header(raw, h);
    }
#line 87
    if (tmp___0) {
#line 87
      tmp___1 = 1;
    } else {
#line 87
      tmp___1 = 0;
    }
  } else {
#line 87
    tmp___1 = 0;
  }
#line 87
  return ((_Bool )tmp___1);
}
}
#line 92 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasl.c"
_Bool read_from_fasl_file(void *start , size_t n_words , fasl_file_handle_t handle ) 
{ 
  size_t tmp ;

  {
  {
#line 95
  tmp = fread((void */* __restrict  */)start, (size_t )8, n_words, (FILE */* __restrict  */)handle);
  }
#line 95
  return ((_Bool )(tmp == n_words));
}
}
#line 98 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasl.c"
fasl_read_status_t check_fasl_version(fasl_header_t *fh___1 ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 101
  if ((unsigned int )fh___1->version >= 10U) {
#line 101
    if ((unsigned int )fh___1->version <= 12U) {
#line 101
      if ((unsigned int )fh___1->arch == 21U) {
#line 101
        tmp = 0;
      } else {
#line 101
        tmp = 3;
      }
#line 101
      tmp___0 = tmp;
    } else {
#line 101
      tmp___0 = 4;
    }
  } else {
#line 101
    tmp___0 = 4;
  }
#line 101
  return ((fasl_read_status_t )tmp___0);
}
}
#line 110 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasl.c"
fasl_read_status_t check_fasl_cc_version(fasl_header_t *fh___1 , unsigned long version ,
                                         unsigned long type ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 114
  if (fh___1->cc_version == 0U) {
#line 114
    if ((unsigned int )fh___1->cc_arch == 0U) {
#line 114
      tmp___1 = 0;
    } else {
#line 114
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 114
    if ((unsigned long )fh___1->cc_version == version) {
#line 114
      if ((unsigned long )fh___1->cc_arch == type) {
#line 114
        tmp = 0;
      } else {
#line 114
        tmp = 6;
      }
#line 114
      tmp___0 = tmp;
    } else {
#line 114
      tmp___0 = 7;
    }
#line 114
    tmp___1 = tmp___0;
  }
#line 114
  return ((fasl_read_status_t )tmp___1);
}
}
#line 125 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasl.c"
static void encode_fasl_header(SCHEME_OBJECT *raw , fasl_header_t *h ) 
{ 
  SCHEME_OBJECT *p ;
  SCHEME_OBJECT *e ;
  SCHEME_OBJECT *tmp ;
  int tmp___0 ;

  {
#line 129
  p = raw;
#line 130
  e = raw + 50;
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;
#line 131
    if (! ((unsigned long )p < (unsigned long )e)) {
#line 131
      goto while_break;
    }
#line 132
    tmp = p;
#line 132
    p ++;
#line 132
    *tmp = 0UL;
  }
  while_break: /* CIL Label */ ;
  }
#line 145
  *(raw + 0) = 0xfafafafafafafafaUL;
#line 147
  *(raw + 6) = (1UL << 58U) | (((unsigned long )h->version << 32U) | (unsigned long )h->arch);
#line 149
  if (h->band_p) {
#line 149
    tmp___0 = 8;
  } else {
#line 149
    tmp___0 = 0;
  }
#line 149
  *(raw + 10) = ((unsigned long )tmp___0 << 58U) | (((unsigned long )h->cc_version << 29U) | (unsigned long )h->cc_arch);
#line 154
  *(raw + 15) = (SCHEME_OBJECT )h->memory_base;
#line 157
  *(raw + 3) = (34UL << 58U) | (SCHEME_OBJECT )h->root_pointer;
#line 160
  *(raw + 2) = (34UL << 58U) | (SCHEME_OBJECT )h->heap_start;
#line 162
  *(raw + 1) = (34UL << 58U) | (unsigned long )(h->heap_end - h->heap_start);
#line 165
  if ((unsigned int )h->version >= 11U) {
#line 166
    *(raw + 17) = (34UL << 58U) | h->heap_reserved;
  }
#line 169
  *(raw + 5) = (34UL << 58U) | (SCHEME_OBJECT )h->constant_start;
#line 171
  *(raw + 4) = (34UL << 58U) | (unsigned long )(h->constant_end - h->constant_start);
#line 174
  if ((unsigned int )h->version >= 11U) {
#line 176
    *(raw + 7) = (34UL << 58U) | (SCHEME_OBJECT )h->stack_start;
#line 178
    *(raw + 16) = (34UL << 58U) | (unsigned long )(h->stack_end - h->stack_start);
  } else {
#line 182
    *(raw + 7) = (34UL << 58U) | (SCHEME_OBJECT )h->stack_end;
  }
#line 185
  *(raw + 8) = (34UL << 58U) | h->n_primitives;
#line 187
  *(raw + 9) = (34UL << 58U) | h->primitive_table_size;
#line 190
  *(raw + 13) = (34UL << 58U) | h->n_c_code_blocks;
#line 192
  *(raw + 14) = (34UL << 58U) | h->c_code_table_size;
#line 195
  *(raw + 11) = h->utilities_vector;
#line 197
  if ((unsigned int )h->version >= 12U) {
#line 198
    *(raw + 18) = (34UL << 58U) | h->ephemeron_count;
  }
#line 200
  return;
}
}
#line 202 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasl.c"
static _Bool decode_fasl_header(SCHEME_OBJECT *raw , fasl_header_t *h ) 
{ 
  SCHEME_OBJECT object ;
  SCHEME_OBJECT object___0 ;
  SCHEME_OBJECT *fasl_memory_base ;
  SCHEME_OBJECT ruv ;
  SCHEME_OBJECT fuv ;
  SCHEME_OBJECT *tmp ;

  {
#line 205
  if (*(raw + 0) != 0xfafafafafafafafaUL) {
#line 206
    return ((_Bool)0);
  }
  {
#line 208
  object = *(raw + 6);
#line 209
  h->version = (fasl_version_t )((object >> 32U) & ((1UL << 26U) - 1UL));
#line 210
  h->arch = (fasl_arch_t )(object & ((1UL << 32U) - 1UL));
#line 213
  object___0 = *(raw + 10);
#line 214
  h->cc_version = (unsigned int )((object___0 >> 29U) & 536870911UL);
#line 215
  h->cc_arch = (cc_arch_t )(object___0 & 536870911UL);
#line 216
  h->band_p = (_Bool )(object___0 >> 58U == 8UL);
#line 219
  fasl_memory_base = (SCHEME_OBJECT *)*(raw + 15);
#line 221
  h->memory_base = fasl_memory_base;
#line 223
  h->root_pointer = fasl_object_address(*(raw + 3), h);
#line 226
  h->heap_start = fasl_object_address(*(raw + 2), h);
#line 228
  h->heap_end = h->heap_start + (*(raw + 1) & 288230376151711743UL);
  }
#line 231
  if ((unsigned int )h->version >= 11U) {
#line 231
    h->heap_reserved = *(raw + 17) & 288230376151711743UL;
  } else {
#line 231
    h->heap_reserved = 0UL;
  }
  {
#line 236
  h->constant_start = fasl_object_address(*(raw + 5), h);
#line 238
  h->constant_end = h->constant_start + (*(raw + 4) & 288230376151711743UL);
  }
#line 242
  if ((unsigned int )h->version >= 11U) {
    {
#line 244
    h->stack_start = fasl_object_address(*(raw + 7), h);
#line 246
    h->stack_end = h->stack_start + (*(raw + 16) & 288230376151711743UL);
    }
  } else {
    {
#line 255
    h->stack_end = fasl_object_address(*(raw + 7), h);
#line 260
    h->stack_start = fasl_memory_base;
    }
  }
#line 263
  h->n_primitives = *(raw + 8) & 288230376151711743UL;
#line 265
  h->primitive_table_size = *(raw + 9) & 288230376151711743UL;
#line 268
  h->n_c_code_blocks = *(raw + 13) & 288230376151711743UL;
#line 270
  h->c_code_table_size = *(raw + 14) & 288230376151711743UL;
#line 274
  ruv = *(raw + 11);
#line 275
  if (ruv == 0UL) {
#line 277
    h->utilities_vector = 0UL;
#line 278
    h->utilities_start = (SCHEME_OBJECT *)0;
  } else {
    {
#line 282
    tmp = fasl_object_address(ruv, h);
#line 282
    fuv = ((ruv >> 58U) << 58U) | (SCHEME_OBJECT )tmp;
#line 284
    h->utilities_vector = fuv;
#line 285
    h->utilities_start = (SCHEME_OBJECT *)(fuv & 288230376151711743UL);
    }
  }
#line 288
  h->utilities_end = (SCHEME_OBJECT *)0;
#line 290
  if ((unsigned int )h->version >= 12U) {
#line 291
    h->ephemeron_count = *(raw + 18) & 288230376151711743UL;
  }
#line 293
  return ((_Bool)1);
}
}
#line 296 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasl.c"
SCHEME_OBJECT *fasl_object_address(SCHEME_OBJECT o , fasl_header_t *h ) 
{ 


  {
#line 299
  if ((unsigned long )h->memory_base != (unsigned long )((SCHEME_OBJECT *)0)) {
#line 300
    return (h->memory_base + (o & 288230376151711743UL));
  }
#line 301
  if ((unsigned int )h->arch == 21U) {
#line 302
    return ((SCHEME_OBJECT *)(o & 288230376151711743UL));
  }
  {
#line 303
  abort();
  }
#line 304
  return ((SCHEME_OBJECT *)0);
}
}
#line 307 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasl.c"
insn_t *fasl_cc_address(SCHEME_OBJECT o , fasl_header_t *h ) 
{ 


  {
#line 310
  if ((unsigned long )h->memory_base != (unsigned long )((SCHEME_OBJECT *)0)) {
#line 311
    return ((insn_t *)h->memory_base + (o & 288230376151711743UL));
  }
#line 312
  if ((unsigned int )h->arch == 21U) {
#line 313
    return ((insn_t *)((SCHEME_OBJECT *)(o & 288230376151711743UL)));
  }
  {
#line 314
  abort();
  }
#line 315
  return ((insn_t *)0);
}
}
#line 318 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasl.c"
SCHEME_OBJECT fasl_raw_address_to_object(unsigned int type , SCHEME_OBJECT *address___0 ,
                                         fasl_header_t *h ) 
{ 


  {
#line 323
  if ((unsigned long )h->memory_base != (unsigned long )((SCHEME_OBJECT *)0)) {
#line 324
    return (((unsigned long )type << 58U) | (unsigned long )(address___0 - h->memory_base));
  }
#line 325
  if ((unsigned int )h->arch == 21U) {
#line 326
    return (((unsigned long )type << 58U) | (SCHEME_OBJECT )address___0);
  }
  {
#line 327
  abort();
  }
#line 328
  return ((8UL << 58U) | 1UL);
}
}
#line 331 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasl.c"
SCHEME_OBJECT fasl_raw_address_to_cc_entry(insn_t *address___0 , fasl_header_t *h ) 
{ 


  {
#line 334
  if ((unsigned long )h->memory_base != (unsigned long )((SCHEME_OBJECT *)0)) {
#line 335
    return ((40UL << 58U) | (unsigned long )(address___0 - (insn_t *)h->memory_base));
  }
#line 337
  if ((unsigned int )h->arch == 21U) {
#line 338
    return ((40UL << 58U) | (SCHEME_OBJECT )((SCHEME_OBJECT *)address___0));
  }
  {
#line 339
  abort();
  }
#line 340
  return ((8UL << 58U) | 1UL);
}
}
#line 343 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasl.c"
SCHEME_OBJECT *faslhdr_utilities_end(fasl_header_t *h ) 
{ 


  {
#line 346
  if ((unsigned long )h->utilities_end == (unsigned long )((SCHEME_OBJECT *)0)) {
#line 346
    if (h->utilities_vector >> 58U == 10UL) {
#line 348
      h->utilities_end = (SCHEME_OBJECT *)(h->utilities_vector & 288230376151711743UL) + ((*((SCHEME_OBJECT *)(h->utilities_vector & 288230376151711743UL) + 0) & 288230376151711743UL) + 1UL);
    }
  }
#line 351
  return (h->utilities_end);
}
}
#line 73 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasdump.c"
static void close_fasl_file___0(void *p ) ;
#line 74
static void abort_fasdump(void *p ) ;
#line 75
static _Bool save_tospace_write(SCHEME_OBJECT *start , SCHEME_OBJECT *end , void *p ) ;
#line 77 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasdump.c"
static fasl_header_t fasl_header___0  ;
#line 78 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasdump.c"
static fasl_header_t *fh___0  ;
#line 79 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasdump.c"
static env_mode_t current_env_mode  ;
#line 80 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasdump.c"
static prim_renumber_t *current_pr  ;
#line 81 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasdump.c"
static _Bool cc_seen_p  ;
#line 82 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasdump.c"
static unsigned long dumped_ephemeron_count  ;
#line 84
static gc_table_t *fasdump_table(void) ;
#line 85
static SCHEME_OBJECT *handle_primitive___0(SCHEME_OBJECT *scan , SCHEME_OBJECT object ) ;
#line 86
static SCHEME_OBJECT *handle_manifest_closure(SCHEME_OBJECT *scan , SCHEME_OBJECT object ) ;
#line 87
static SCHEME_OBJECT *handle_linkage_section(SCHEME_OBJECT *scan , SCHEME_OBJECT object ) ;
#line 88
static SCHEME_OBJECT *handle_symbol(SCHEME_OBJECT *scan , SCHEME_OBJECT object ) ;
#line 89
static SCHEME_OBJECT *handle_broken_heart(SCHEME_OBJECT *scan , SCHEME_OBJECT object ) ;
#line 90
static SCHEME_OBJECT *handle_variable(SCHEME_OBJECT *scan , SCHEME_OBJECT object ) ;
#line 91
static SCHEME_OBJECT *handle_environment(SCHEME_OBJECT *scan , SCHEME_OBJECT object ) ;
#line 92
static SCHEME_OBJECT *handle_ephemeron(SCHEME_OBJECT *scan , SCHEME_OBJECT object ) ;
#line 94
static SCHEME_OBJECT fasdump_cc_entry(SCHEME_OBJECT object ) ;
#line 95
static SCHEME_OBJECT *fasdump_precheck_from(SCHEME_OBJECT *from ) ;
#line 96
static SCHEME_OBJECT *fasdump_transport_words(SCHEME_OBJECT *from , unsigned long n_words ,
                                              _Bool align_p ) ;
#line 98
static void initialize_fixups(void) ;
#line 99
static void add_fixup(SCHEME_OBJECT *addr ) ;
#line 100
static void run_fixups(void *p ) ;
#line 102
static void initialize_fasl_header(_Bool cc_p , _Bool band_p ) ;
#line 103
static void finalize_fasl_header(unsigned long ephemeron_count___0 ) ;
#line 104
static _Bool write_fasl_file(SCHEME_OBJECT *prim_table_start , SCHEME_OBJECT *c_code_table_start ,
                             fasl_file_handle_t handle ) ;
#line 118 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasdump.c"
SCHEME_OBJECT Prim_prim_fasdump(void) 
{ 
  fasl_file_info_t ff_info ;
  SCHEME_OBJECT *new_heap_start___0 ;
  SCHEME_OBJECT *prim_table_start ;
  unsigned long prim_table_length ;
  _Bool ok ;
  _Bool tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;
  int tmp___4 ;
  unsigned long tmp___5 ;

  {
  {
#line 133
  while (1) {
    while_continue: /* CIL Label */ ;
#line 133
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 135
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 135
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 136
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 136
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 138
  transaction_begin();
  }
#line 139
  if (*(stack_pointer + 1) >> 58U == 30UL) {
#line 139
    ff_info.filename = (char const   *)((char *)((SCHEME_OBJECT *)(*(stack_pointer + 1) & 288230376151711743UL) + 2));
  } else {
    {
#line 139
    error_wrong_type_arg(2);
#line 139
    ff_info.filename = (char const   *)((char *)0);
    }
  }
  {
#line 140
  tmp = open_fasl_output_file(ff_info.filename, & ff_info.handle);
  }
#line 140
  if (! tmp) {
    {
#line 141
    error_bad_range_arg(2);
    }
  }
  {
#line 142
  transaction_record_action((enum transaction_action_type )2, & close_fasl_file___0,
                            (void *)(& ff_info));
#line 144
  open_tospace(heap_start);
#line 146
  transaction_record_action((enum transaction_action_type )0, & abort_fasdump, (void *)0);
#line 147
  initialize_fixups();
#line 149
  new_heap_start___0 = get_newspace_ptr();
#line 150
  add_to_tospace(*(stack_pointer + 0));
#line 151
  dumped_ephemeron_count = 0UL;
#line 153
  transaction_begin();
#line 155
  current_gc_table = fasdump_table();
  }
#line 156
  if (*(stack_pointer + 2) == 0UL) {
#line 156
    current_env_mode = (env_mode_t )0;
  } else {
#line 156
    if (*(stack_pointer + 2) == 8UL << 58U) {
#line 156
      tmp___0 = 1;
    } else {
#line 156
      tmp___0 = 2;
    }
#line 156
    current_env_mode = (env_mode_t )tmp___0;
  }
  {
#line 162
  current_pr = make_prim_renumber();
#line 163
  cc_seen_p = (_Bool)0;
#line 164
  gc_scan_tospace(new_heap_start___0, (SCHEME_OBJECT *)0);
#line 166
  prim_table_start = get_newspace_ptr();
#line 167
  prim_table_length = renumbered_primitives_export_length(current_pr);
#line 168
  increment_tospace_ptr(prim_table_length);
#line 169
  tmp___1 = newspace_to_tospace((void *)prim_table_start);
#line 169
  export_renumbered_primitives((SCHEME_OBJECT *)tmp___1, current_pr);
#line 172
  transaction_commit();
#line 174
  initialize_fasl_header(cc_seen_p, (_Bool)0);
#line 175
  fh___0->constant_start = new_heap_start___0;
#line 176
  fh___0->constant_end = new_heap_start___0;
#line 177
  fh___0->heap_start = new_heap_start___0;
#line 178
  fh___0->heap_end = prim_table_start;
#line 179
  fh___0->root_pointer = new_heap_start___0;
#line 180
  fh___0->n_primitives = current_pr->next_code;
#line 181
  fh___0->primitive_table_size = prim_table_length;
#line 182
  finalize_fasl_header(dumped_ephemeron_count);
#line 184
  tmp___2 = write_fasl_header(fh___0, ff_info.handle);
  }
#line 184
  if (tmp___2) {
    {
#line 184
    tmp___3 = save_tospace(& save_tospace_write, (void *)(& ff_info));
    }
#line 184
    if (tmp___3) {
#line 184
      tmp___4 = 1;
    } else {
#line 184
      tmp___4 = 0;
    }
  } else {
#line 184
    tmp___4 = 0;
  }
  {
#line 184
  ok = (_Bool )tmp___4;
#line 186
  transaction_commit();
  }
  {
#line 188
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 188
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 189
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 189
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 191
  if (ok) {
#line 191
    tmp___5 = 8UL << 58U;
  } else {
#line 191
    tmp___5 = 0UL;
  }
#line 191
  return (tmp___5);
}
}
#line 194 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasdump.c"
static void close_fasl_file___0(void *p ) 
{ 
  fasl_file_info_t *ff_info ;
  _Bool tmp ;

  {
  {
#line 197
  ff_info = (fasl_file_info_t *)p;
#line 198
  tmp = close_fasl_output_file(ff_info->handle);
  }
#line 198
  if (! tmp) {
    {
#line 199
    OS_file_remove(ff_info->filename);
    }
  }
#line 200
  return;
}
}
#line 202 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasdump.c"
static void abort_fasdump(void *p ) 
{ 


  {
  {
#line 205
  discard_tospace();
  }
#line 206
  return;
}
}
#line 208 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasdump.c"
static _Bool save_tospace_write(SCHEME_OBJECT *start , SCHEME_OBJECT *end , void *p ) 
{ 
  fasl_file_info_t *ff_info ;
  _Bool tmp ;

  {
  {
#line 211
  ff_info = (fasl_file_info_t *)p;
#line 212
  tmp = write_to_fasl_file((void const   *)start, (size_t )(end - start), ff_info->handle);
  }
#line 212
  return (tmp);
}
}
#line 327 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasdump.c"
static _Bool initialized_p___2  =    (_Bool)0;
#line 328 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasdump.c"
static gc_table_t table___2  ;
#line 324 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasdump.c"
static gc_table_t *fasdump_table(void) 
{ 


  {
#line 330
  if (! initialized_p___2) {
    {
#line 332
    initialize_gc_table(& table___2, (_Bool)1);
#line 334
    table___2.cc_entry_handler = & fasdump_cc_entry;
#line 335
    table___2.precheck_from = & fasdump_precheck_from;
#line 336
    table___2.transport_words = & fasdump_transport_words;
#line 338
    table___2.handlers[24] = & handle_primitive___0;
#line 339
    table___2.handlers[13] = & handle_manifest_closure;
#line 340
    table___2.handlers[57] = & handle_linkage_section;
#line 341
    table___2.handlers[29] = & handle_symbol;
#line 342
    table___2.handlers[34] = & handle_broken_heart;
#line 343
    table___2.handlers[5] = & handle_symbol;
#line 344
    table___2.handlers[44] = & handle_variable;
#line 345
    table___2.handlers[18] = & handle_environment;
#line 346
    table___2.handlers[55] = & gc_handle_pair;
#line 347
    table___2.handlers[43] = & handle_ephemeron;
#line 349
    initialized_p___2 = (_Bool)1;
    }
  }
#line 351
  return (& table___2);
}
}
#line 354 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasdump.c"
static SCHEME_OBJECT fasdump_cc_entry(SCHEME_OBJECT object ) 
{ 
  SCHEME_OBJECT *old_addr ;
  SCHEME_OBJECT *new_addr ;
  unsigned long length ;
  SCHEME_OBJECT *eptr ;
  SCHEME_OBJECT tmp ;

  {
  {
#line 363
  cc_seen_p = (_Bool)1;
#line 364
  old_addr = cc_entry_to_block_address(object);
  }
#line 365
  if ((unsigned long )old_addr == (unsigned long )((SCHEME_OBJECT *)(compiler_utilities & 288230376151711743UL))) {
#line 366
    return (object);
  }
  {
#line 367
  new_addr = (*(current_gc_table->precheck_from))(old_addr);
  }
#line 368
  if ((unsigned long )new_addr == (unsigned long )((SCHEME_OBJECT *)0)) {
    {
#line 370
    length = *old_addr & 288230376151711743UL;
#line 371
    new_addr = (*(current_gc_table->transport_words))(old_addr, 1UL + length, (_Bool)1);
#line 372
    eptr = new_addr + length;
    }
#line 373
    if ((unsigned int )current_env_mode == 2U) {
      {
#line 373
      tmp = read_tospace(eptr);
      }
#line 373
      if (tmp >> 58U == 18UL) {
        {
#line 375
        write_tospace(eptr, 0UL);
        }
      }
    }
  }
#line 377
  return (((object >> 58U) << 58U) | (SCHEME_OBJECT )((insn_t *)new_addr + ((insn_t *)((SCHEME_OBJECT *)(object & 288230376151711743UL)) - (insn_t *)old_addr)));
}
}
#line 384 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasdump.c"
static SCHEME_OBJECT *fasdump_precheck_from(SCHEME_OBJECT *from ) 
{ 
  SCHEME_OBJECT *tmp ;

  {
#line 387
  if (*from >> 58U == 34UL) {
#line 387
    tmp = (SCHEME_OBJECT *)(*from & 288230376151711743UL);
  } else {
#line 387
    tmp = (SCHEME_OBJECT *)0;
  }
#line 387
  return (tmp);
}
}
#line 390 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasdump.c"
static SCHEME_OBJECT *fasdump_transport_words(SCHEME_OBJECT *from , unsigned long n_words ,
                                              _Bool align_p ) 
{ 
  _Bool tmp ;
  SCHEME_OBJECT *tmp___0 ;

  {
  {
#line 395
  tmp = tospace_available_p(n_words);
  }
#line 395
  if (! tmp) {
    {
#line 396
    signal_error_from_primitive(20L);
    }
  }
  {
#line 397
  add_fixup(from);
#line 398
  tmp___0 = gc_transport_words(from, n_words, align_p);
  }
#line 398
  return (tmp___0);
}
}
#line 401 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasdump.c"
static SCHEME_OBJECT *handle_primitive___0(SCHEME_OBJECT *scan , SCHEME_OBJECT object ) 
{ 


  {
  {
#line 404
  *scan = renumber_primitive(object, current_pr);
  }
#line 405
  return (scan + 1);
}
}
#line 408 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasdump.c"
static SCHEME_OBJECT *handle_manifest_closure(SCHEME_OBJECT *scan , SCHEME_OBJECT object ) 
{ 
  SCHEME_OBJECT *tmp ;

  {
  {
#line 411
  cc_seen_p = (_Bool)1;
#line 412
  tmp = gc_handle_manifest_closure(scan, object);
  }
#line 412
  return (tmp);
}
}
#line 415 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasdump.c"
static SCHEME_OBJECT *handle_linkage_section(SCHEME_OBJECT *scan , SCHEME_OBJECT object ) 
{ 
  SCHEME_OBJECT *tmp ;

  {
  {
#line 418
  cc_seen_p = (_Bool)1;
#line 419
  tmp = gc_handle_linkage_section(scan, object);
  }
#line 419
  return (tmp);
}
}
#line 422 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasdump.c"
static SCHEME_OBJECT *handle_symbol(SCHEME_OBJECT *scan , SCHEME_OBJECT object ) 
{ 
  SCHEME_OBJECT *from ;
  SCHEME_OBJECT *new_address ;
  SCHEME_OBJECT *tmp ;
  unsigned long tmp___0 ;

  {
  {
#line 425
  from = (SCHEME_OBJECT *)(object & 288230376151711743UL);
#line 426
  tmp = (*(current_gc_table->precheck_from))(from);
#line 426
  new_address = tmp;
  }
#line 427
  if ((unsigned long )new_address == (unsigned long )((SCHEME_OBJECT *)0)) {
    {
#line 429
    new_address = (*(current_gc_table->transport_words))(from, 2UL, (_Bool)0);
    }
#line 430
    if (object >> 58U == 29UL) {
#line 430
      tmp___0 = 34UL << 58U;
    } else {
#line 430
      tmp___0 = (50UL << 58U) | 2UL;
    }
    {
#line 430
    write_tospace(new_address + 1, tmp___0);
    }
  }
#line 435
  *scan = ((object >> 58U) << 58U) | (SCHEME_OBJECT )new_address;
#line 436
  return (scan + 1);
}
}
#line 439 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasdump.c"
static SCHEME_OBJECT *handle_broken_heart(SCHEME_OBJECT *scan , SCHEME_OBJECT object ) 
{ 
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT *tmp___0 ;

  {
#line 442
  if ((object & 288230376151711743UL) == 0UL) {
#line 442
    tmp___0 = scan + 1;
  } else {
    {
#line 442
    tmp = gc_handle_broken_heart(scan, object);
#line 442
    tmp___0 = tmp;
    }
  }
#line 442
  return (tmp___0);
}
}
#line 448 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasdump.c"
static SCHEME_OBJECT *handle_variable(SCHEME_OBJECT *scan , SCHEME_OBJECT object ) 
{ 
  SCHEME_OBJECT *from ;
  SCHEME_OBJECT *new_address ;
  SCHEME_OBJECT *tmp ;

  {
  {
#line 451
  from = (SCHEME_OBJECT *)(object & 288230376151711743UL);
#line 452
  tmp = (*(current_gc_table->precheck_from))(from);
#line 452
  new_address = tmp;
  }
#line 453
  if ((unsigned long )new_address == (unsigned long )((SCHEME_OBJECT *)0)) {
    {
#line 455
    new_address = (*(current_gc_table->transport_words))(from, 3UL, (_Bool)0);
#line 456
    write_tospace(new_address + 1, 8UL << 58U);
#line 457
    write_tospace(new_address + 2, 0UL);
    }
  }
#line 459
  *scan = ((object >> 58U) << 58U) | (SCHEME_OBJECT )new_address;
#line 460
  return (scan + 1);
}
}
#line 463 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasdump.c"
static SCHEME_OBJECT *handle_environment(SCHEME_OBJECT *scan , SCHEME_OBJECT object ) 
{ 


  {
#line 466
  if ((unsigned int )current_env_mode != 1U) {
    {
#line 467
    signal_error_from_primitive(56L);
    }
  }
  {
#line 468
  *scan = (*(current_gc_table->vector_handler))(object, (_Bool)0);
  }
#line 469
  return (scan + 1);
}
}
#line 472 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasdump.c"
static SCHEME_OBJECT *handle_ephemeron(SCHEME_OBJECT *scan , SCHEME_OBJECT object ) 
{ 
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT *tmp___0 ;

  {
  {
#line 476
  tmp = (*(current_gc_table->precheck_from))((SCHEME_OBJECT *)(object & 288230376151711743UL));
  }
#line 476
  if ((unsigned long )((SCHEME_OBJECT *)0) == (unsigned long )tmp) {
#line 477
    dumped_ephemeron_count ++;
  }
  {
#line 478
  tmp___0 = gc_handle_unaligned_vector(scan, object);
  }
#line 478
  return (tmp___0);
}
}
#line 487 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasdump.c"
static fixup_t *fixups_start  ;
#line 488 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasdump.c"
static fixup_t *fixups_next  ;
#line 489 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasdump.c"
static fixup_t *fixups_end  ;
#line 491 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasdump.c"
static void initialize_fixups(void) 
{ 
  fixup_t *data ;
  void *tmp ;

  {
  {
#line 494
  tmp = OS_malloc(64UL * sizeof(fixup_t ));
#line 494
  data = (fixup_t *)tmp;
#line 495
  fixups_start = data;
#line 496
  fixups_next = data;
#line 497
  fixups_end = data + 64;
#line 498
  transaction_record_action((enum transaction_action_type )2, & run_fixups, (void *)0);
  }
#line 499
  return;
}
}
#line 501 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasdump.c"
static void add_fixup(SCHEME_OBJECT *addr ) 
{ 
  unsigned long n ;
  unsigned long m ;
  fixup_t *data ;
  void *tmp ;

  {
#line 504
  if ((unsigned long )fixups_next >= (unsigned long )fixups_end) {
    {
#line 506
    n = (unsigned long )((fixups_end - fixups_start) * 2L);
#line 507
    m = (unsigned long )(fixups_next - fixups_start);
#line 508
    tmp = OS_realloc((void *)fixups_start, n * sizeof(fixup_t ));
#line 508
    data = (fixup_t *)tmp;
#line 509
    fixups_start = data;
#line 510
    fixups_next = data + m;
#line 511
    fixups_end = data + n;
    }
  }
#line 513
  fixups_next->addr = addr;
#line 514
  fixups_next->object = *addr;
#line 515
  fixups_next ++;
#line 516
  return;
}
}
#line 518 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasdump.c"
static void run_fixups(void *p ) 
{ 
  fixup_t *scan ;

  {
#line 521
  scan = fixups_start;
  {
#line 522
  while (1) {
    while_continue: /* CIL Label */ ;
#line 522
    if (! ((unsigned long )scan < (unsigned long )fixups_next)) {
#line 522
      goto while_break;
    }
#line 524
    *(scan->addr) = scan->object;
#line 525
    scan ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 527
  OS_free((void *)fixups_start);
  }
#line 528
  return;
}
}
#line 530 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasdump.c"
SCHEME_OBJECT Prim_band_dump(void) 
{ 
  SCHEME_OBJECT *to ;
  SCHEME_OBJECT *prim_table_start ;
  SCHEME_OBJECT *c_code_table_start ;
  _Bool result ;
  _Bool tmp ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;
  SCHEME_OBJECT *tmp___2 ;
  SCHEME_OBJECT comb ;
  SCHEME_OBJECT root ;
  SCHEME_OBJECT *tmp___3 ;
  SCHEME_OBJECT *tmp___4 ;
  SCHEME_OBJECT *tmp___5 ;
  char const   *filename ;
  fasl_file_handle_t handle ;
  _Bool tmp___6 ;
  _Bool tmp___7 ;
  unsigned long tmp___8 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 535
  to = Free;
  {
#line 539
  while (1) {
    while_continue: /* CIL Label */ ;
#line 539
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 541
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 541
    tmp = interpreter_applicable_p(*(stack_pointer + 0));
    }
#line 541
    if (! tmp) {
      {
#line 541
      error_wrong_type_arg(1);
      }
    }
#line 541
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 542
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 542
    if (! (*(stack_pointer + 1) >> 58U == 30UL)) {
      {
#line 542
      error_wrong_type_arg(2);
      }
    }
#line 542
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 544
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 544
    if ((unsigned long )Free >= (unsigned long )heap_start) {
#line 544
      if ((unsigned long )Free < (unsigned long )heap_alloc_limit) {
#line 544
        if (! ((unsigned long )(Free + 5) <= (unsigned long )heap_alloc_limit)) {
#line 544
          goto _L___0;
        }
      } else {
#line 544
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 544
    if ((Registers[1] & 4UL) != 0UL) {
      {
#line 544
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 544
        if ((unsigned long )Free_primitive < (unsigned long )heap_start) {
          {
#line 544
          outf_fatal("\nMicrocode requested primitive GC outside primitive!\n");
#line 544
          Microcode_Termination(12);
          }
        }
#line 544
        if ((unsigned long )Free < (unsigned long )Free_primitive) {
          {
#line 544
          outf_fatal("\nFree has gone backwards!\n");
#line 544
          Microcode_Termination(12);
          }
        }
        {
#line 544
        while (1) {
          while_continue___4: /* CIL Label */ ;
          {
#line 544
          while (1) {
            while_continue___5: /* CIL Label */ ;
            {
#line 544
            set_ulong_register(12U, Registers[12] | 4UL);
            }
            {
#line 544
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 544
              if ((Registers[1] & Registers[12]) != 0UL) {
#line 544
                tmp___1 = memory_block_start;
              } else {
#line 544
                if ((Registers[1] & 4UL) != 0UL) {
#line 544
                  tmp___0 = heap_alloc_limit;
                } else {
#line 544
                  tmp___0 = heap_end;
                }
#line 544
                tmp___1 = tmp___0;
              }
              {
#line 544
              set_ptr_register(0U, tmp___1);
              }
#line 544
              if ((Registers[1] & 1UL) != 0UL) {
#line 544
                tmp___2 = stack_guard;
              } else {
#line 544
                tmp___2 = stack_start;
              }
              {
#line 544
              set_ptr_register(11U, tmp___2);
              }
#line 544
              goto while_break___6;
            }
            while_break___6: /* CIL Label */ ;
            }
#line 544
            goto while_break___5;
          }
          while_break___5: /* CIL Label */ ;
          }
#line 544
          gc_space_needed = (unsigned long )(5L + (Free - Free_primitive));
#line 544
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
        {
#line 544
        signal_interrupt_from_primitive();
        }
#line 544
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 544
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 545
  initialize_fasl_header((_Bool)1, (_Bool)1);
#line 550
  comb = (38UL << 58U) | (SCHEME_OBJECT )to;
#line 551
  *(to + 0) = 2UL;
#line 552
  *(to + 1) = *(stack_pointer + 0);
#line 553
  *(to + 2) = 0UL;
#line 554
  to += 3;
#line 556
  root = (1UL << 58U) | (SCHEME_OBJECT )to;
#line 557
  tmp___3 = to;
#line 557
  to ++;
#line 557
  *tmp___3 = comb;
#line 558
  tmp___4 = to;
#line 558
  to ++;
#line 558
  *tmp___4 = compiler_utilities;
#line 560
  fh___0->root_pointer = to;
#line 561
  tmp___5 = to;
#line 561
  to ++;
#line 561
  *tmp___5 = root;
#line 564
  prim_table_start = to;
#line 565
  fh___0->n_primitives = MAX_PRIMITIVE;
#line 566
  fh___0->primitive_table_size = primitive_table_export_length();
#line 567
  to += fh___0->primitive_table_size;
#line 569
  c_code_table_start = to;
  }
#line 576
  if ((unsigned long )to > (unsigned long )heap_end) {
#line 577
    result = (_Bool)0;
  } else {
    {
#line 580
    filename = (char const   *)((char *)((SCHEME_OBJECT *)(*(stack_pointer + 1) & 288230376151711743UL) + 2));
#line 583
    export_primitive_table(prim_table_start);
#line 588
    fh___0->heap_start = heap_start;
#line 589
    fh___0->heap_end = prim_table_start;
#line 590
    fh___0->constant_start = constant_start;
#line 591
    fh___0->constant_end = constant_alloc_next;
#line 592
    finalize_fasl_header(ephemeron_count);
#line 594
    OS_file_remove_link(filename);
#line 595
    tmp___6 = open_fasl_output_file(filename, & handle);
    }
#line 595
    if (! tmp___6) {
      {
#line 596
      error_bad_range_arg(2);
      }
    }
    {
#line 598
    result = write_fasl_file(prim_table_start, c_code_table_start, handle);
#line 601
    tmp___7 = close_fasl_output_file(handle);
    }
#line 601
    if (! tmp___7) {
      {
#line 602
      OS_file_remove(filename);
      }
    }
  }
#line 604
  if (result) {
#line 604
    tmp___8 = 8UL << 58U;
  } else {
#line 604
    tmp___8 = 0UL;
  }
#line 604
  return (tmp___8);
}
}
#line 607 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasdump.c"
static void initialize_fasl_header(_Bool cc_p , _Bool band_p ) 
{ 


  {
#line 610
  fh___0 = & fasl_header___0;
#line 615
  if (band_p) {
#line 615
    fh___0->version = (fasl_version_t )11;
  } else {
#line 615
    fh___0->version = (fasl_version_t )10;
  }
#line 617
  fh___0->arch = (fasl_arch_t )21;
#line 618
  fh___0->band_p = band_p;
#line 621
  fh___0->memory_base = (SCHEME_OBJECT *)0;
#line 625
  if (band_p) {
#line 625
    fh___0->heap_reserved = heap_reserved;
  } else {
#line 625
    fh___0->heap_reserved = 0UL;
  }
#line 627
  fh___0->stack_start = stack_start;
#line 628
  fh___0->stack_end = stack_end;
#line 630
  if (cc_p) {
#line 632
    fh___0->cc_version = compiler_interface_version;
#line 633
    fh___0->cc_arch = compiler_processor_type;
#line 634
    fh___0->utilities_vector = compiler_utilities;
  } else {
#line 638
    fh___0->cc_version = 0U;
#line 639
    fh___0->cc_arch = (cc_arch_t )0;
#line 640
    fh___0->utilities_vector = 0UL;
  }
#line 642
  fh___0->n_c_code_blocks = 0UL;
#line 643
  fh___0->c_code_table_size = 0UL;
#line 644
  return;
}
}
#line 646 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasdump.c"
static void finalize_fasl_header(unsigned long ephemeron_count___0 ) 
{ 


  {
#line 649
  if (ephemeron_count___0 != 0UL) {
#line 651
    fh___0->version = (fasl_version_t )12;
#line 652
    fh___0->ephemeron_count = ephemeron_count___0;
  }
#line 654
  return;
}
}
#line 656 "/home/khheo/project/mit-scheme-9.2/src/microcode/fasdump.c"
static _Bool write_fasl_file(SCHEME_OBJECT *prim_table_start , SCHEME_OBJECT *c_code_table_start ,
                             fasl_file_handle_t handle ) 
{ 
  _Bool tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;
  int tmp___4 ;

  {
  {
#line 661
  tmp = write_fasl_header(fh___0, handle);
  }
#line 661
  if (tmp) {
    {
#line 661
    tmp___0 = write_to_fasl_file((void const   *)fh___0->heap_start, (unsigned long )(fh___0->heap_end - fh___0->heap_start),
                                 handle);
    }
#line 661
    if (tmp___0) {
      {
#line 661
      tmp___1 = write_to_fasl_file((void const   *)fh___0->constant_start, (unsigned long )(fh___0->constant_end - fh___0->constant_start),
                                   handle);
      }
#line 661
      if (tmp___1) {
        {
#line 661
        tmp___2 = write_to_fasl_file((void const   *)prim_table_start, fh___0->primitive_table_size,
                                     handle);
        }
#line 661
        if (tmp___2) {
          {
#line 661
          tmp___3 = write_to_fasl_file((void const   *)c_code_table_start, fh___0->c_code_table_size,
                                       handle);
          }
#line 661
          if (tmp___3) {
#line 661
            tmp___4 = 1;
          } else {
#line 661
            tmp___4 = 0;
          }
        } else {
#line 661
          tmp___4 = 0;
        }
      } else {
#line 661
        tmp___4 = 0;
      }
    } else {
#line 661
      tmp___4 = 0;
    }
  } else {
#line 661
    tmp___4 = 0;
  }
#line 661
  return ((_Bool )tmp___4);
}
}
#line 33 "/home/khheo/project/mit-scheme-9.2/src/microcode/extern.c"
SCHEME_OBJECT Prim_map_code_to_address(void) 
{ 
  long tc ;
  long number ;

  {
  {
#line 44
  while (1) {
    while_continue: /* CIL Label */ ;
#line 44
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 45
  tc = arg_nonnegative_integer(1);
#line 46
  number = arg_nonnegative_integer(2);
  }
  {
#line 49
  if (tc == 11L) {
#line 49
    goto case_11;
  }
#line 54
  if (tc == 24L) {
#line 54
    goto case_24;
  }
#line 59
  goto switch_default;
  case_11: /* CIL Label */ 
#line 50
  if (number > 94L) {
    {
#line 51
    error_bad_range_arg(2);
    }
  }
#line 52
  return (((unsigned long )tc << 58U) | (unsigned long )number);
  case_24: /* CIL Label */ 
#line 55
  if ((unsigned long )number > MAX_PRIMITIVE) {
    {
#line 56
    error_bad_range_arg(2);
    }
  }
#line 57
  return ((24UL << 58U) | (unsigned long )number);
  switch_default: /* CIL Label */ 
  {
#line 60
  error_bad_range_arg(1);
  }
  switch_break: /* CIL Label */ ;
  }
#line 63
  return ((SCHEME_OBJECT )0);
}
}
#line 66 "/home/khheo/project/mit-scheme-9.2/src/microcode/extern.c"
SCHEME_OBJECT Prim_map_address_to_code(void) 
{ 
  SCHEME_OBJECT tc ;
  SCHEME_OBJECT address___0 ;
  long tmp ;
  long number ;

  {
  {
#line 74
  while (1) {
    while_continue: /* CIL Label */ ;
#line 74
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 75
  tmp = arg_nonnegative_integer(1);
#line 75
  tc = (SCHEME_OBJECT )tmp;
#line 76
  address___0 = *(stack_pointer + 1);
  }
#line 77
  if (address___0 >> 58U != tc) {
    {
#line 78
    error_wrong_type_arg(2);
    }
  }
  {
#line 81
  if (tc == 11UL) {
#line 81
    goto case_11;
  }
#line 89
  if (tc == 24UL) {
#line 89
    goto case_24;
  }
#line 92
  goto switch_default;
  case_11: /* CIL Label */ 
#line 83
  number = (long )(address___0 & 288230376151711743UL);
#line 84
  if (number > 94L) {
    {
#line 85
    error_bad_range_arg(2);
    }
  }
#line 86
  return ((26UL << 58U) | (unsigned long )number);
  case_24: /* CIL Label */ 
#line 90
  return ((26UL << 58U) | (address___0 & 288230376151711743UL));
  switch_default: /* CIL Label */ 
  {
#line 93
  error_bad_range_arg(1);
  }
  switch_break: /* CIL Label */ ;
  }
#line 96
  return ((SCHEME_OBJECT )0);
}
}
#line 99 "/home/khheo/project/mit-scheme-9.2/src/microcode/extern.c"
SCHEME_OBJECT Prim_primitive_procedure_arity(void) 
{ 
  SCHEME_OBJECT primitive ;

  {
  {
#line 102
  while (1) {
    while_continue: /* CIL Label */ ;
#line 102
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 103
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 103
    if (! (*(stack_pointer + 0) >> 58U == 24UL)) {
      {
#line 103
      error_wrong_type_arg(1);
      }
    }
#line 103
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 105
  primitive = *(stack_pointer + 0);
#line 106
  if ((primitive & 288230376151711743UL) > MAX_PRIMITIVE) {
    {
#line 108
    error_bad_range_arg(1);
    }
  }
#line 109
  return ((26UL << 58U) | ((unsigned long )*(Primitive_Arity_Table + (primitive & 288230376151711743UL)) & 288230376151711743UL));
}
}
#line 113 "/home/khheo/project/mit-scheme-9.2/src/microcode/extern.c"
SCHEME_OBJECT Prim_primitive_procedure_doc(void) 
{ 
  SCHEME_OBJECT primitive ;
  char const   *answer ;
  SCHEME_OBJECT tmp ;
  unsigned long tmp___0 ;

  {
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
#line 117
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 118
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 118
    if (! (*(stack_pointer + 0) >> 58U == 24UL)) {
      {
#line 118
      error_wrong_type_arg(1);
      }
    }
#line 118
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 120
  primitive = *(stack_pointer + 0);
#line 121
  if ((primitive & 288230376151711743UL) > MAX_PRIMITIVE) {
    {
#line 123
    error_bad_range_arg(1);
    }
  }
#line 125
  answer = *(Primitive_Documentation_Table + (primitive & 288230376151711743UL));
#line 126
  if ((unsigned long )answer == (unsigned long )((char const   *)0)) {
#line 126
    tmp___0 = 0UL;
  } else {
    {
#line 126
    tmp = char_pointer_to_string(answer);
#line 126
    tmp___0 = tmp;
    }
  }
#line 126
  return (tmp___0);
}
}
#line 134 "/home/khheo/project/mit-scheme-9.2/src/microcode/extern.c"
SCHEME_OBJECT Prim_get_primitive_counts(void) 
{ 
  SCHEME_OBJECT tmp ;

  {
  {
#line 139
  while (1) {
    while_continue: /* CIL Label */ ;
#line 139
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 140
  tmp = cons((26UL << 58U) | MAX_PRIMITIVE, 26UL << 58U);
  }
#line 140
  return (tmp);
}
}
#line 145 "/home/khheo/project/mit-scheme-9.2/src/microcode/extern.c"
SCHEME_OBJECT Prim_get_primitive_name(void) 
{ 
  SCHEME_OBJECT primitive ;
  long number ;
  SCHEME_OBJECT tmp ;

  {
  {
#line 148
  while (1) {
    while_continue: /* CIL Label */ ;
#line 148
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 150
  primitive = *(stack_pointer + 0);
#line 151
  if (! (primitive >> 58U == 24UL)) {
#line 151
    if (! (primitive >> 58U == 26UL)) {
      {
#line 152
      error_wrong_type_arg(1);
      }
    }
  }
#line 154
  number = (long )(primitive & 288230376151711743UL);
#line 155
  if (number < 0L) {
    {
#line 156
    error_bad_range_arg(1);
    }
  } else
#line 155
  if ((unsigned long )number > MAX_PRIMITIVE) {
    {
#line 156
    error_bad_range_arg(1);
    }
  }
  {
#line 157
  tmp = char_pointer_to_string(*(Primitive_Name_Table + (primitive & 288230376151711743UL)));
  }
#line 157
  return (tmp);
}
}
#line 162 "/home/khheo/project/mit-scheme-9.2/src/microcode/extern.c"
SCHEME_OBJECT Prim_get_primitive_address(void) 
{ 
  SCHEME_OBJECT name ;
  SCHEME_OBJECT arity_arg ;
  _Bool intern_p ;
  _Bool allow_p ;
  long arity ;
  SCHEME_OBJECT tmp ;

  {
  {
#line 174
  while (1) {
    while_continue: /* CIL Label */ ;
#line 174
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 175
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 175
    if (! (*(stack_pointer + 0) >> 58U == 29UL)) {
#line 175
      if (! (*(stack_pointer + 0) >> 58U == 5UL)) {
        {
#line 175
        error_wrong_type_arg(1);
        }
      }
    }
#line 175
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 176
  name = *(stack_pointer + 0);
#line 177
  arity_arg = *(stack_pointer + 1);
#line 178
  if (arity_arg == 0UL) {
#line 180
    allow_p = (_Bool)0;
#line 181
    intern_p = (_Bool)0;
#line 182
    arity = -2L;
  } else
#line 184
  if (arity_arg == 8UL << 58U) {
#line 186
    allow_p = (_Bool)1;
#line 187
    intern_p = (_Bool)0;
#line 188
    arity = -2L;
  } else {
    {
#line 192
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 192
      if (! (*(stack_pointer + 1) >> 58U == 26UL)) {
        {
#line 192
        error_wrong_type_arg(2);
        }
      }
#line 192
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 193
    allow_p = (_Bool)1;
#line 194
    intern_p = (_Bool)1;
#line 195
    arity = (long )((arity_arg ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL));
  }
  {
#line 197
  tmp = find_primitive(*((SCHEME_OBJECT *)(name & 288230376151711743UL) + 0), intern_p,
                       allow_p, (int )arity);
  }
#line 197
  return (tmp);
}
}
#line 143 "/home/khheo/project/mit-scheme-9.2/src/microcode/dstack.h"
Tcondition_type condition_type_allocate(void *name , Tptrvec generalizations , void (*reporter)(Tcondition condition ) ) ;
#line 149
void condition_type_deallocate(Tcondition_type type ) ;
#line 152
Tcondition condition_allocate(Tcondition_type type , Tptrvec irritants ) ;
#line 156
void condition_deallocate(Tcondition condition ) ;
#line 159
void condition_handler_bind(Tcondition_type type , void (*handler)(Tcondition condition ) ) ;
#line 163
void condition_signal(Tcondition condition ) ;
#line 167
void condition_restart_bind(void *name , Tcondition_type type , void (*procedure)(void *argument ) ) ;
#line 175
Tcondition_restart condition_restart_find(void *name , Tcondition condition ) ;
#line 180
Tptrvec condition_restarts(Tcondition condition ) ;
#line 32 "/home/khheo/project/mit-scheme-9.2/src/microcode/error.c"
static Tptrvec generalizations_union(Tptrvec generalizations ) ;
#line 47 "/home/khheo/project/mit-scheme-9.2/src/microcode/error.c"
static unsigned long next_condition_type_index  ;
#line 48 "/home/khheo/project/mit-scheme-9.2/src/microcode/error.c"
static struct handler_record *current_handler_record  ;
#line 49 "/home/khheo/project/mit-scheme-9.2/src/microcode/error.c"
static struct restart_record *current_restart_record  ;
#line 51 "/home/khheo/project/mit-scheme-9.2/src/microcode/error.c"
void initialize_condition_system(void) 
{ 


  {
#line 54
  next_condition_type_index = 0UL;
#line 55
  current_handler_record = (struct handler_record *)0;
#line 56
  current_restart_record = (struct restart_record *)0;
#line 57
  return;
}
}
#line 59 "/home/khheo/project/mit-scheme-9.2/src/microcode/error.c"
Tcondition_type condition_type_allocate(void *name , Tptrvec generalizations , void (*reporter)(Tcondition condition ) ) 
{ 
  Tcondition_type type ;
  void *tmp ;
  Tptrvec g ;
  Tptrvec tmp___0 ;
  unsigned long tmp___1 ;

  {
  {
#line 64
  tmp = OS_malloc(sizeof(struct condition_type ));
#line 64
  type = (Tcondition_type )tmp;
#line 65
  tmp___0 = generalizations_union(generalizations);
#line 65
  g = tmp___0;
#line 66
  ptrvec_adjoin(g, (void *)type);
#line 67
  tmp___1 = next_condition_type_index;
#line 67
  next_condition_type_index ++;
#line 67
  type->index = tmp___1;
#line 68
  type->name = name;
#line 69
  type->generalizations = g;
#line 70
  type->reporter = reporter;
  }
#line 71
  return (type);
}
}
#line 74 "/home/khheo/project/mit-scheme-9.2/src/microcode/error.c"
void condition_type_deallocate(Tcondition_type type ) 
{ 


  {
  {
#line 77
  ptrvec_deallocate(type->generalizations);
#line 78
  free((void *)type);
  }
#line 79
  return;
}
}
#line 81 "/home/khheo/project/mit-scheme-9.2/src/microcode/error.c"
Tcondition condition_allocate(Tcondition_type type , Tptrvec irritants ) 
{ 
  Tcondition condition ;
  void *tmp ;

  {
  {
#line 85
  tmp = OS_malloc(sizeof(struct condition ));
#line 85
  condition = (Tcondition )tmp;
#line 86
  condition->type = type;
#line 87
  condition->irritants = irritants;
  }
#line 88
  return (condition);
}
}
#line 91 "/home/khheo/project/mit-scheme-9.2/src/microcode/error.c"
void condition_deallocate(Tcondition condition ) 
{ 


  {
  {
#line 94
  ptrvec_deallocate(condition->irritants);
#line 95
  free((void *)condition);
  }
#line 96
  return;
}
}
#line 98 "/home/khheo/project/mit-scheme-9.2/src/microcode/error.c"
static Tptrvec generalizations_union_2(Tptrvec x , Tptrvec y ) 
{ 
  void **scan_x ;
  void **end_x ;
  void **scan_y ;
  void **end_y ;
  Tptrvec_length length ;
  unsigned long ix ;
  unsigned long iy ;
  Tptrvec result ;
  void **scan_result ;
  void **tmp ;
  void **tmp___0 ;
  void **tmp___1 ;
  void **tmp___2 ;
  void **tmp___3 ;
  void **tmp___4 ;
  void **tmp___5 ;
  void **tmp___6 ;
  void **tmp___7 ;

  {
#line 101
  scan_x = x->elements + 0;
#line 102
  end_x = scan_x + x->length;
#line 103
  scan_y = y->elements + 0;
#line 104
  end_y = scan_y + y->length;
#line 105
  length = (Tptrvec_length )0;
  {
#line 110
  while (1) {
    while_continue: /* CIL Label */ ;
#line 112
    if ((unsigned long )scan_x == (unsigned long )end_x) {
#line 114
      length += (Tptrvec_length )(end_y - scan_y);
#line 115
      goto while_break;
    }
#line 117
    if ((unsigned long )scan_y == (unsigned long )end_y) {
#line 119
      length += (Tptrvec_length )(end_x - scan_x);
#line 120
      goto while_break;
    }
#line 122
    length ++;
#line 123
    ix = ((Tcondition_type )*scan_x)->index;
#line 124
    iy = ((Tcondition_type )*scan_y)->index;
#line 125
    if (ix <= iy) {
#line 125
      scan_x ++;
    }
#line 126
    if (iy <= ix) {
#line 126
      scan_y ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 128
  result = ptrvec_allocate(length);
#line 129
  scan_result = result->elements + 0;
  }
  {
#line 130
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 132
    if ((unsigned long )scan_x == (unsigned long )end_x) {
      {
#line 134
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 134
        if (! ((unsigned long )scan_y < (unsigned long )end_y)) {
#line 134
          goto while_break___1;
        }
#line 134
        tmp = scan_result;
#line 134
        scan_result ++;
#line 134
        tmp___0 = scan_y;
#line 134
        scan_y ++;
#line 134
        *tmp = *tmp___0;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 135
      goto while_break___0;
    }
#line 137
    if ((unsigned long )scan_y == (unsigned long )end_y) {
      {
#line 139
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 139
        if (! ((unsigned long )scan_x < (unsigned long )end_x)) {
#line 139
          goto while_break___2;
        }
#line 139
        tmp___1 = scan_result;
#line 139
        scan_result ++;
#line 139
        tmp___2 = scan_x;
#line 139
        scan_x ++;
#line 139
        *tmp___1 = *tmp___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 140
      goto while_break___0;
    }
#line 142
    ix = ((Tcondition_type )*scan_x)->index;
#line 143
    iy = ((Tcondition_type )*scan_y)->index;
#line 144
    if (ix == iy) {
#line 146
      tmp___3 = scan_result;
#line 146
      scan_result ++;
#line 146
      tmp___4 = scan_x;
#line 146
      scan_x ++;
#line 146
      *tmp___3 = *tmp___4;
#line 147
      scan_y ++;
    } else {
#line 150
      tmp___5 = scan_result;
#line 150
      scan_result ++;
#line 150
      if (ix < iy) {
#line 150
        tmp___6 = scan_x;
#line 150
        scan_x ++;
#line 150
        *tmp___5 = *tmp___6;
      } else {
#line 150
        tmp___7 = scan_y;
#line 150
        scan_y ++;
#line 150
        *tmp___5 = *tmp___7;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 152
  return (result);
}
}
#line 155 "/home/khheo/project/mit-scheme-9.2/src/microcode/error.c"
static Tptrvec generalizations_union(Tptrvec generalizations ) 
{ 
  Tptrvec_length length ;
  Tptrvec tmp ;
  Tptrvec tmp___0 ;
  void **scan ;
  void **end ;
  Tptrvec result ;
  void **tmp___1 ;
  void **tmp___2 ;
  Tptrvec v ;
  void **tmp___3 ;
  Tptrvec tmp___4 ;

  {
#line 158
  length = generalizations->length;
#line 159
  if (length == 0UL) {
    {
#line 160
    tmp = ptrvec_allocate((Tptrvec_length )0);
    }
#line 160
    return (tmp);
  }
#line 161
  if (length == 1UL) {
    {
#line 162
    tmp___0 = ptrvec_copy((Tptrvec )*(generalizations->elements + 0));
    }
#line 162
    return (tmp___0);
  }
  {
#line 164
  scan = generalizations->elements + 0;
#line 165
  end = scan + length;
#line 166
  tmp___1 = scan;
#line 166
  scan ++;
#line 166
  result = (Tptrvec )*tmp___1;
#line 167
  tmp___2 = scan;
#line 167
  scan ++;
#line 167
  result = generalizations_union_2(result, (Tptrvec )*tmp___2);
  }
  {
#line 168
  while (1) {
    while_continue: /* CIL Label */ ;
#line 168
    if (! ((unsigned long )scan < (unsigned long )end)) {
#line 168
      goto while_break;
    }
    {
#line 170
    tmp___3 = scan;
#line 170
    scan ++;
#line 170
    tmp___4 = generalizations_union_2(result, (Tptrvec )*tmp___3);
#line 170
    v = tmp___4;
#line 171
    ptrvec_deallocate(result);
#line 172
    result = v;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 174
  return (result);
}
}
#line 178 "/home/khheo/project/mit-scheme-9.2/src/microcode/error.c"
void condition_handler_bind(Tcondition_type type , void (*handler)(Tcondition condition ) ) 
{ 
  struct handler_record *record ;
  void *tmp ;

  {
  {
#line 182
  tmp = dstack_alloc((unsigned int )sizeof(struct handler_record ));
#line 182
  record = (struct handler_record *)tmp;
#line 184
  record->next = current_handler_record;
#line 185
  record->type = type;
#line 186
  record->handler = handler;
#line 187
  dstack_bind((void *)(& current_handler_record), (void *)record);
  }
#line 188
  return;
}
}
#line 193 "/home/khheo/project/mit-scheme-9.2/src/microcode/error.c"
void condition_signal(Tcondition condition ) 
{ 
  Tptrvec generalizations ;
  struct handler_record *record ;
  Tcondition_type type ;
  void *position___1 ;
  int tmp ;

  {
#line 196
  generalizations = (condition->type)->generalizations;
#line 197
  record = current_handler_record;
  {
#line 198
  while (1) {
    while_continue: /* CIL Label */ ;
#line 198
    if (! ((unsigned long )record != (unsigned long )((struct handler_record *)0))) {
#line 198
      goto while_break;
    }
#line 200
    type = record->type;
#line 201
    if ((unsigned long )type == (unsigned long )((Tcondition_type )0)) {
      {
#line 203
      position___1 = dstack_position;
#line 204
      dstack_bind((void *)(& current_handler_record), (void *)record->next);
#line 205
      (*(record->handler))(condition);
#line 206
      dstack_set_position(position___1);
      }
    } else {
      {
#line 201
      tmp = ptrvec_memq(generalizations, (void *)type);
      }
#line 201
      if (tmp) {
        {
#line 203
        position___1 = dstack_position;
#line 204
        dstack_bind((void *)(& current_handler_record), (void *)record->next);
#line 205
        (*(record->handler))(condition);
#line 206
        dstack_set_position(position___1);
        }
      }
    }
#line 208
    record = record->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 210
  return;
}
}
#line 212 "/home/khheo/project/mit-scheme-9.2/src/microcode/error.c"
void condition_restart_bind(void *name , Tcondition_type type , void (*procedure)(void *argument ) ) 
{ 
  struct restart_record *record ;
  void *tmp ;

  {
  {
#line 217
  tmp = dstack_alloc((unsigned int )sizeof(struct restart_record ));
#line 217
  record = (struct restart_record *)tmp;
#line 219
  record->next = current_restart_record;
#line 220
  record->contents.name = name;
#line 221
  record->contents.type = type;
#line 222
  record->contents.procedure = procedure;
#line 223
  dstack_bind((void *)(& current_restart_record), (void *)record);
  }
#line 224
  return;
}
}
#line 226 "/home/khheo/project/mit-scheme-9.2/src/microcode/error.c"
Tcondition_restart condition_restart_find(void *name , Tcondition condition ) 
{ 
  struct restart_record *record ;
  Tptrvec generalizations ;
  int tmp ;

  {
#line 230
  record = current_restart_record;
#line 231
  if ((unsigned long )condition == (unsigned long )((Tcondition )0)) {
    {
#line 232
    while (1) {
      while_continue: /* CIL Label */ ;
#line 232
      if (! ((unsigned long )record != (unsigned long )((struct restart_record *)0))) {
#line 232
        goto while_break;
      }
#line 234
      if ((unsigned long )record->contents.name == (unsigned long )name) {
#line 235
        return (& record->contents);
      }
#line 236
      record = record->next;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 240
    generalizations = (condition->type)->generalizations;
    {
#line 241
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 241
      if (! ((unsigned long )record != (unsigned long )((struct restart_record *)0))) {
#line 241
        goto while_break___0;
      }
#line 243
      if ((unsigned long )record->contents.name == (unsigned long )name) {
        {
#line 243
        tmp = ptrvec_memq(generalizations, (void *)record->contents.type);
        }
#line 243
        if (tmp) {
#line 245
          return (& record->contents);
        }
      }
#line 246
      record = record->next;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 249
  return ((Tcondition_restart )0);
}
}
#line 252 "/home/khheo/project/mit-scheme-9.2/src/microcode/error.c"
Tptrvec condition_restarts(Tcondition condition ) 
{ 
  struct restart_record *record ;
  Tptrvec_length length ;
  Tptrvec generalizations ;
  Tptrvec result ;
  void **scan_result ;
  int tmp ;
  void **tmp___0 ;
  void **tmp___1 ;
  int tmp___2 ;

  {
#line 255
  record = current_restart_record;
#line 256
  length = (Tptrvec_length )0;
#line 257
  generalizations = (Tptrvec )0;
#line 260
  if ((unsigned long )condition == (unsigned long )((Tcondition )0)) {
    {
#line 261
    while (1) {
      while_continue: /* CIL Label */ ;
#line 261
      if (! ((unsigned long )record != (unsigned long )((struct restart_record *)0))) {
#line 261
        goto while_break;
      }
#line 263
      length ++;
#line 264
      record = record->next;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 268
    generalizations = (condition->type)->generalizations;
    {
#line 269
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 269
      if (! ((unsigned long )record != (unsigned long )((struct restart_record *)0))) {
#line 269
        goto while_break___0;
      }
      {
#line 271
      tmp = ptrvec_memq(generalizations, (void *)record->contents.type);
      }
#line 271
      if (tmp) {
#line 272
        length ++;
      }
#line 273
      record = record->next;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 276
  result = ptrvec_allocate(length);
#line 277
  scan_result = result->elements + 0;
#line 278
  record = current_restart_record;
  }
#line 279
  if ((unsigned long )condition == (unsigned long )((Tcondition )0)) {
    {
#line 280
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 280
      if (! ((unsigned long )record != (unsigned long )((struct restart_record *)0))) {
#line 280
        goto while_break___1;
      }
#line 282
      tmp___0 = scan_result;
#line 282
      scan_result ++;
#line 282
      *tmp___0 = (void *)(& record->contents);
#line 283
      record = record->next;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else {
    {
#line 286
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 286
      if (! ((unsigned long )record != (unsigned long )((struct restart_record *)0))) {
#line 286
        goto while_break___2;
      }
      {
#line 288
      tmp___2 = ptrvec_memq(generalizations, (void *)record->contents.type);
      }
#line 288
      if (tmp___2) {
#line 289
        tmp___1 = scan_result;
#line 289
        scan_result ++;
#line 289
        *tmp___1 = (void *)(& record->contents);
      }
#line 290
      record = record->next;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 292
  return (result);
}
}
#line 35 "/home/khheo/project/mit-scheme-9.2/src/microcode/dfloat.c"
SCHEME_OBJECT Prim_floating_vector_cons(void) 
{ 
  long length ;
  long tmp ;
  long length_in_words ;
  SCHEME_OBJECT result ;
  double *vect ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;
  SCHEME_OBJECT *tmp___2 ;
  SCHEME_OBJECT *tmp___3 ;
  SCHEME_OBJECT *tmp___4 ;
  double *tmp___5 ;
  long tmp___6 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 37
  while (1) {
    while_continue: /* CIL Label */ ;
#line 37
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 39
  tmp = arg_nonnegative_integer(1);
#line 39
  length = tmp;
#line 40
  length_in_words = (long )((unsigned long )length * ((sizeof(double ) + (sizeof(SCHEME_OBJECT ) - 1UL)) / sizeof(SCHEME_OBJECT )));
  }
  {
#line 44
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 44
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 44
      goto while_break___1;
#line 44
      tmp___0 = Free;
#line 44
      Free ++;
#line 44
      *tmp___0 = 39UL << 58U;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 44
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 45
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 45
    if ((unsigned long )Free >= (unsigned long )heap_start) {
#line 45
      if ((unsigned long )Free < (unsigned long )heap_alloc_limit) {
#line 45
        if (! ((unsigned long )(Free + (length_in_words + 1L)) <= (unsigned long )heap_alloc_limit)) {
#line 45
          goto _L___0;
        }
      } else {
#line 45
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 45
    if ((Registers[1] & 4UL) != 0UL) {
      {
#line 45
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 45
        if ((unsigned long )Free_primitive < (unsigned long )heap_start) {
          {
#line 45
          outf_fatal("\nMicrocode requested primitive GC outside primitive!\n");
#line 45
          Microcode_Termination(12);
          }
        }
#line 45
        if ((unsigned long )Free < (unsigned long )Free_primitive) {
          {
#line 45
          outf_fatal("\nFree has gone backwards!\n");
#line 45
          Microcode_Termination(12);
          }
        }
        {
#line 45
        while (1) {
          while_continue___4: /* CIL Label */ ;
          {
#line 45
          while (1) {
            while_continue___5: /* CIL Label */ ;
            {
#line 45
            set_ulong_register(12U, Registers[12] | 4UL);
            }
            {
#line 45
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 45
              if ((Registers[1] & Registers[12]) != 0UL) {
#line 45
                tmp___2 = memory_block_start;
              } else {
#line 45
                if ((Registers[1] & 4UL) != 0UL) {
#line 45
                  tmp___1 = heap_alloc_limit;
                } else {
#line 45
                  tmp___1 = heap_end;
                }
#line 45
                tmp___2 = tmp___1;
              }
              {
#line 45
              set_ptr_register(0U, tmp___2);
              }
#line 45
              if ((Registers[1] & 1UL) != 0UL) {
#line 45
                tmp___3 = stack_guard;
              } else {
#line 45
                tmp___3 = stack_start;
              }
              {
#line 45
              set_ptr_register(11U, tmp___3);
              }
#line 45
              goto while_break___6;
            }
            while_break___6: /* CIL Label */ ;
            }
#line 45
            goto while_break___5;
          }
          while_break___5: /* CIL Label */ ;
          }
#line 45
          gc_space_needed = (unsigned long )((length_in_words + 1L) + (Free - Free_primitive));
#line 45
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
        {
#line 45
        signal_interrupt_from_primitive();
        }
#line 45
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 45
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 46
  result = (6UL << 58U) | (SCHEME_OBJECT )Free;
#line 47
  tmp___4 = Free;
#line 47
  Free ++;
#line 47
  *tmp___4 = (39UL << 58U) | (unsigned long )length_in_words;
#line 48
  vect = (double *)Free;
  {
#line 49
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 49
    tmp___6 = length;
#line 49
    length --;
#line 49
    if (! (tmp___6 > 0L)) {
#line 49
      goto while_break___7;
    }
#line 49
    tmp___5 = vect;
#line 49
    vect ++;
#line 49
    *tmp___5 = 0.0;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 50
  Free = (SCHEME_OBJECT *)vect;
#line 51
  return (result);
}
}
#line 55 "/home/khheo/project/mit-scheme-9.2/src/microcode/dfloat.c"
SCHEME_OBJECT Prim_floating_vector_ref(void) 
{ 
  SCHEME_OBJECT vector ;
  SCHEME_OBJECT tmp ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;
  SCHEME_OBJECT *tmp___2 ;
  long tmp___3 ;
  SCHEME_OBJECT tmp___4 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 57
  while (1) {
    while_continue: /* CIL Label */ ;
#line 57
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 59
  if (*(stack_pointer + 0) >> 58U == 6UL) {
#line 59
    tmp = *(stack_pointer + 0);
  } else {
    {
#line 59
    error_wrong_type_arg(1);
#line 59
    tmp = (SCHEME_OBJECT )0;
    }
  }
#line 59
  vector = tmp;
  {
#line 60
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 60
    if ((unsigned long )Free >= (unsigned long )heap_start) {
#line 60
      if ((unsigned long )Free < (unsigned long )heap_alloc_limit) {
#line 60
        if (! ((unsigned long )(Free + ((sizeof(double ) + (sizeof(SCHEME_OBJECT ) - 1UL)) / sizeof(SCHEME_OBJECT ) + 1UL)) <= (unsigned long )heap_alloc_limit)) {
#line 60
          goto _L___0;
        }
      } else {
#line 60
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 60
    if ((Registers[1] & 4UL) != 0UL) {
      {
#line 60
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 60
        if ((unsigned long )Free_primitive < (unsigned long )heap_start) {
          {
#line 60
          outf_fatal("\nMicrocode requested primitive GC outside primitive!\n");
#line 60
          Microcode_Termination(12);
          }
        }
#line 60
        if ((unsigned long )Free < (unsigned long )Free_primitive) {
          {
#line 60
          outf_fatal("\nFree has gone backwards!\n");
#line 60
          Microcode_Termination(12);
          }
        }
        {
#line 60
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
#line 60
          while (1) {
            while_continue___3: /* CIL Label */ ;
            {
#line 60
            set_ulong_register(12U, Registers[12] | 4UL);
            }
            {
#line 60
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 60
              if ((Registers[1] & Registers[12]) != 0UL) {
#line 60
                tmp___1 = memory_block_start;
              } else {
#line 60
                if ((Registers[1] & 4UL) != 0UL) {
#line 60
                  tmp___0 = heap_alloc_limit;
                } else {
#line 60
                  tmp___0 = heap_end;
                }
#line 60
                tmp___1 = tmp___0;
              }
              {
#line 60
              set_ptr_register(0U, tmp___1);
              }
#line 60
              if ((Registers[1] & 1UL) != 0UL) {
#line 60
                tmp___2 = stack_guard;
              } else {
#line 60
                tmp___2 = stack_start;
              }
              {
#line 60
              set_ptr_register(11U, tmp___2);
              }
#line 60
              goto while_break___4;
            }
            while_break___4: /* CIL Label */ ;
            }
#line 60
            goto while_break___3;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 60
          gc_space_needed = ((sizeof(double ) + (sizeof(SCHEME_OBJECT ) - 1UL)) / sizeof(SCHEME_OBJECT ) + 1UL) + (unsigned long )(Free - Free_primitive);
#line 60
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 60
        signal_interrupt_from_primitive();
        }
#line 60
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 60
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 61
  tmp___3 = arg_index_integer(2, (long )((*((SCHEME_OBJECT *)(vector & 288230376151711743UL) + 0) & 288230376151711743UL) / ((sizeof(double ) + (sizeof(SCHEME_OBJECT ) - 1UL)) / sizeof(SCHEME_OBJECT ))));
#line 61
  tmp___4 = double_to_flonum(*((double *)((SCHEME_OBJECT *)(vector & 288230376151711743UL) + ((unsigned long )tmp___3 * ((sizeof(double ) + (sizeof(SCHEME_OBJECT ) - 1UL)) / sizeof(SCHEME_OBJECT )) + 1UL))));
  }
#line 61
  return (tmp___4);
}
}
#line 70 "/home/khheo/project/mit-scheme-9.2/src/microcode/dfloat.c"
SCHEME_OBJECT Prim_floating_vector_set(void) 
{ 
  SCHEME_OBJECT vector ;
  SCHEME_OBJECT tmp ;
  long tmp___0 ;
  double tmp___1 ;

  {
  {
#line 72
  while (1) {
    while_continue: /* CIL Label */ ;
#line 72
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 74
  if (*(stack_pointer + 0) >> 58U == 6UL) {
#line 74
    tmp = *(stack_pointer + 0);
  } else {
    {
#line 74
    error_wrong_type_arg(1);
#line 74
    tmp = (SCHEME_OBJECT )0;
    }
  }
  {
#line 74
  vector = tmp;
#line 75
  tmp___0 = arg_index_integer(2, (long )((*((SCHEME_OBJECT *)(vector & 288230376151711743UL) + 0) & 288230376151711743UL) / ((sizeof(double ) + (sizeof(SCHEME_OBJECT ) - 1UL)) / sizeof(SCHEME_OBJECT ))));
#line 75
  tmp___1 = arg_flonum(3);
#line 75
  *((double *)((SCHEME_OBJECT *)(vector & 288230376151711743UL) + ((unsigned long )tmp___0 * ((sizeof(double ) + (sizeof(SCHEME_OBJECT ) - 1UL)) / sizeof(SCHEME_OBJECT )) + 1UL))) = tmp___1;
  }
#line 80
  return ((8UL << 58U) | 1UL);
}
}
#line 83 "/home/khheo/project/mit-scheme-9.2/src/microcode/dfloat.c"
SCHEME_OBJECT Prim_floating_vector_length(void) 
{ 
  SCHEME_OBJECT tmp ;

  {
  {
#line 86
  while (1) {
    while_continue: /* CIL Label */ ;
#line 86
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 87
  if (*(stack_pointer + 0) >> 58U == 6UL) {
#line 87
    tmp = *(stack_pointer + 0);
  } else {
    {
#line 87
    error_wrong_type_arg(1);
#line 87
    tmp = (SCHEME_OBJECT )0;
    }
  }
#line 87
  return ((26UL << 58U) | (*((SCHEME_OBJECT *)(tmp & 288230376151711743UL) + 0) & 288230376151711743UL) / ((sizeof(double ) + (sizeof(SCHEME_OBJECT ) - 1UL)) / sizeof(SCHEME_OBJECT )));
}
}
#line 377 "/home/khheo/project/mit-scheme-9.2/src/microcode/extern.h"
extern void Debug_Stack_Trace(void) ;
#line 378
extern void Debug_Print(SCHEME_OBJECT Expr , _Bool Detailed ) ;
#line 379
void Show_Env(SCHEME_OBJECT The_Env ) ;
#line 380
void Print_Return(char const   *String ) ;
#line 382
void Print_Primitive(SCHEME_OBJECT primitive ) ;
#line 35 "/home/khheo/project/mit-scheme-9.2/src/microcode/debug.c"
static SCHEME_OBJECT compiled_entry_debug_filename(SCHEME_OBJECT entry ) ;
#line 36
static SCHEME_OBJECT compiled_block_debug_filename(SCHEME_OBJECT block ) ;
#line 39
static void do_printing(outf_channel stream , SCHEME_OBJECT Expr , _Bool Detailed ) ;
#line 40
static _Bool print_primitive_name(outf_channel stream , SCHEME_OBJECT primitive ) ;
#line 41
static void print_expression(outf_channel stream , SCHEME_OBJECT expression , char const   *string ) ;
#line 47 "/home/khheo/project/mit-scheme-9.2/src/microcode/debug.c"
char const   *compiled_entry_filename(SCHEME_OBJECT entry ) 
{ 
  SCHEME_OBJECT result ;
  SCHEME_OBJECT tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char *__cil_tmp6 ;

  {
  {
#line 50
  tmp = compiled_entry_debug_filename(entry);
#line 50
  result = tmp;
  }
#line 51
  if (result >> 58U == 30UL) {
#line 51
    tmp___1 = (char const   *)((char *)((SCHEME_OBJECT *)(result & 288230376151711743UL) + 2));
  } else {
#line 51
    if (result >> 58U == 1UL) {
#line 51
      tmp___0 = (char const   *)((char *)((SCHEME_OBJECT *)(*((SCHEME_OBJECT *)(result & 288230376151711743UL) + 0) & 288230376151711743UL) + 2));
    } else {
#line 51
      tmp___0 = "**** filename not known ****";
    }
#line 51
    tmp___1 = tmp___0;
  }
#line 51
  return (tmp___1);
}
}
#line 59 "/home/khheo/project/mit-scheme-9.2/src/microcode/debug.c"
static SCHEME_OBJECT compiled_entry_debug_filename(SCHEME_OBJECT entry ) 
{ 
  SCHEME_OBJECT tmp___0 ;
  SCHEME_OBJECT tmp___1 ;
  _Bool tmp___2 ;
  SCHEME_OBJECT tmp___3 ;
  SCHEME_OBJECT tmp___4 ;

  {
  {
#line 62
  tmp___2 = cc_entry_closure_p(entry);
  }
#line 62
  if (tmp___2) {
    {
#line 62
    tmp___0 = cc_closure_to_entry(entry);
#line 62
    tmp___1 = tmp___0;
    }
  } else {
#line 62
    tmp___1 = entry;
  }
  {
#line 62
  tmp___3 = cc_entry_to_block(tmp___1);
#line 62
  tmp___4 = compiled_block_debug_filename(tmp___3);
  }
#line 62
  return (tmp___4);
}
}
#line 69 "/home/khheo/project/mit-scheme-9.2/src/microcode/debug.c"
static SCHEME_OBJECT compiled_block_debug_filename(SCHEME_OBJECT block ) 
{ 
  SCHEME_OBJECT info ;
  SCHEME_OBJECT tmp ;

  {
  {
#line 74
  info = cc_block_debugging_info(block);
  }
#line 75
  if (info >> 58U == 30UL) {
#line 75
    tmp = info;
  } else
#line 75
  if (info >> 58U == 1UL) {
#line 75
    if (*((SCHEME_OBJECT *)(info & 288230376151711743UL) + 0) >> 58U == 30UL) {
#line 75
      if (*((SCHEME_OBJECT *)(info & 288230376151711743UL) + 1) >> 58U == 26UL) {
#line 75
        tmp = info;
      } else {
#line 75
        tmp = 0UL;
      }
    } else {
#line 75
      tmp = 0UL;
    }
  } else {
#line 75
    tmp = 0UL;
  }
#line 75
  return (tmp);
}
}
#line 86 "/home/khheo/project/mit-scheme-9.2/src/microcode/debug.c"
void Show_Env(SCHEME_OBJECT The_Env ) 
{ 
  SCHEME_OBJECT *name_ptr ;
  SCHEME_OBJECT procedure ;
  SCHEME_OBJECT *value_ptr ;
  SCHEME_OBJECT extension ;
  long count ;
  long i ;
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT *tmp___0 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 92
  procedure = *((SCHEME_OBJECT *)(The_Env & 288230376151711743UL) + 1);
#line 93
  value_ptr = (SCHEME_OBJECT *)(The_Env & 288230376151711743UL) + 2;
#line 95
  if (procedure >> 58U == 10UL) {
#line 97
    extension = procedure;
#line 98
    procedure = *((SCHEME_OBJECT *)(extension & 288230376151711743UL) + 2);
  } else {
#line 101
    extension = 0UL;
  }
#line 103
  if (procedure >> 58U != 15UL) {
#line 103
    if (procedure >> 58U != 9UL) {
      {
#line 106
      outf_error("Not created by a procedure");
      }
#line 107
      return;
    }
  }
#line 109
  name_ptr = (SCHEME_OBJECT *)(procedure & 288230376151711743UL) + 0;
#line 110
  name_ptr = (SCHEME_OBJECT *)(*name_ptr & 288230376151711743UL) + 1;
#line 111
  count = (long )((*((SCHEME_OBJECT *)(*name_ptr & 288230376151711743UL) + 0) & 288230376151711743UL) - 1UL);
#line 113
  name_ptr = (SCHEME_OBJECT *)(*name_ptr & 288230376151711743UL) + 2;
#line 114
  i = 0L;
  {
#line 114
  while (1) {
    while_continue: /* CIL Label */ ;
#line 114
    if (! (i < count)) {
#line 114
      goto while_break;
    }
    {
#line 116
    tmp = name_ptr;
#line 116
    name_ptr ++;
#line 116
    Print_Expression(*tmp, "Name ");
#line 117
    tmp___0 = value_ptr;
#line 117
    value_ptr ++;
#line 117
    Print_Expression(*tmp___0, " Value ");
#line 118
    outf_error("\n");
#line 114
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 120
  if (extension != 0UL) {
    {
#line 122
    outf_error("Auxiliary Variables\n");
#line 123
    count = (long )(*((SCHEME_OBJECT *)(extension & 288230376151711743UL) + 3) & 288230376151711743UL);
#line 124
    i = 0L;
#line 124
    name_ptr = (SCHEME_OBJECT *)(extension & 288230376151711743UL) + 4;
    }
    {
#line 124
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 124
      if (! (i < count)) {
#line 124
        goto while_break___0;
      }
      {
#line 128
      Print_Expression(*((SCHEME_OBJECT *)(*name_ptr & 288230376151711743UL) + 0),
                       "Name ");
#line 129
      Print_Expression(*((SCHEME_OBJECT *)(*name_ptr & 288230376151711743UL) + 1),
                       " Value ");
#line 130
      outf_error("\n");
#line 124
      i ++;
#line 124
      name_ptr ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 133
  return;
}
}
#line 135 "/home/khheo/project/mit-scheme-9.2/src/microcode/debug.c"
static void print_list(outf_channel stream , SCHEME_OBJECT pair ) 
{ 
  int count ;
  char const   *tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 140
  outf(stream, "(");
#line 141
  count = 0;
  }
  {
#line 142
  while (1) {
    while_continue: /* CIL Label */ ;
#line 142
    if (pair >> 58U == 1UL) {
#line 142
      goto _L;
    } else
#line 142
    if (pair >> 58U == 55UL) {
      _L: /* CIL Label */ 
#line 142
      if (! (count < 10)) {
#line 142
        goto while_break;
      }
    } else {
#line 142
      goto while_break;
    }
#line 144
    if (count > 0) {
      {
#line 145
      outf(stream, " ");
      }
    }
#line 146
    if (pair >> 58U == 55UL) {
#line 146
      tmp = "{weak}";
    } else {
#line 146
      tmp = "";
    }
    {
#line 146
    print_expression(stream, *((SCHEME_OBJECT *)(pair & 288230376151711743UL) + 0),
                     tmp);
#line 149
    pair = *((SCHEME_OBJECT *)(pair & 288230376151711743UL) + 1);
#line 150
    count ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 152
  if (! (pair == ((8UL << 58U) | 9UL))) {
#line 154
    if (count == 10) {
      {
#line 155
      outf(stream, " ...");
      }
    } else {
      {
#line 158
      outf(stream, " . ");
#line 159
      print_expression(stream, pair, "");
      }
    }
  }
  {
#line 162
  outf(stream, ")");
  }
#line 163
  return;
}
}
#line 165 "/home/khheo/project/mit-scheme-9.2/src/microcode/debug.c"
static void print_return_name(outf_channel stream , SCHEME_OBJECT Ptr ) 
{ 
  unsigned long index___0 ;
  char const   *name ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 168
  index___0 = Ptr & 288230376151711743UL;
#line 169
  if (index___0 <= MAX_RETURN) {
#line 171
    name = Return_Names[index___0];
#line 172
    if ((unsigned long )name != (unsigned long )((char const   *)0)) {
#line 172
      if ((int const   )*(name + 0) != 0) {
        {
#line 174
        outf(stream, "%s", name);
        }
#line 175
        return;
      }
    }
  }
  {
#line 178
  outf(stream, "[0x%lx]", index___0);
  }
#line 179
  return;
}
}
#line 181 "/home/khheo/project/mit-scheme-9.2/src/microcode/debug.c"
void Print_Return(char const   *String ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
  {
#line 184
  outf_error("%s: ", String);
#line 185
  print_return_name((outf_channel )1, Registers[6]);
#line 186
  outf_error("\n");
  }
#line 187
  return;
}
}
#line 189 "/home/khheo/project/mit-scheme-9.2/src/microcode/debug.c"
static void print_string(outf_channel stream , SCHEME_OBJECT string ) 
{ 
  long length ;
  long i ;
  char *next ;
  char this ;
  char *tmp ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
#line 197
  outf(stream, "\"");
#line 198
  length = (long )(*((SCHEME_OBJECT *)(string & 288230376151711743UL) + 1) & 288230376151711743UL);
#line 199
  next = (char *)((SCHEME_OBJECT *)(string & 288230376151711743UL) + 2);
#line 200
  i = 0L;
  }
  {
#line 200
  while (1) {
    while_continue: /* CIL Label */ ;
#line 200
    if (! (i < length)) {
#line 200
      goto while_break;
    }
#line 202
    tmp = next;
#line 202
    next ++;
#line 202
    this = *tmp;
    {
#line 205
    if ((int )this == 92) {
#line 205
      goto case_92;
    }
#line 208
    if ((int )this == 34) {
#line 208
      goto case_34;
    }
#line 211
    if ((int )this == 9) {
#line 211
      goto case_9;
    }
#line 214
    if ((int )this == 10) {
#line 214
      goto case_10;
    }
#line 217
    if ((int )this == 12) {
#line 217
      goto case_12;
    }
#line 220
    goto switch_default;
    case_92: /* CIL Label */ 
    {
#line 206
    outf(stream, "\\\\");
    }
#line 207
    goto switch_break;
    case_34: /* CIL Label */ 
    {
#line 209
    outf(stream, "\\\"");
    }
#line 210
    goto switch_break;
    case_9: /* CIL Label */ 
    {
#line 212
    outf(stream, "\\t");
    }
#line 213
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 215
    outf(stream, "\\n");
    }
#line 216
    goto switch_break;
    case_12: /* CIL Label */ 
    {
#line 218
    outf(stream, "\\f");
    }
#line 219
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 221
    if ((int )this >= 32) {
#line 221
      if ((int )this <= 126) {
        {
#line 222
        outf(stream, "%c", (int )this);
        }
      } else {
        {
#line 224
        outf(stream, "\\%03o", (int )this);
        }
      }
    } else {
      {
#line 224
      outf(stream, "\\%03o", (int )this);
      }
    }
#line 225
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 200
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 228
  outf(stream, "\"");
  }
#line 229
  return;
}
}
#line 231 "/home/khheo/project/mit-scheme-9.2/src/microcode/debug.c"
static void print_symbol(outf_channel stream , SCHEME_OBJECT symbol ) 
{ 
  SCHEME_OBJECT string ;
  unsigned long length ;
  unsigned long limit ;
  unsigned long i ;
  char *next ;
  int c ;
  char *tmp ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 240
  string = *((SCHEME_OBJECT *)(symbol & 288230376151711743UL) + 0);
#line 241
  length = *((SCHEME_OBJECT *)(string & 288230376151711743UL) + 1) & 288230376151711743UL;
#line 242
  if (length > 64UL) {
#line 242
    limit = 64UL;
  } else {
#line 242
    limit = length;
  }
#line 243
  next = (char *)((SCHEME_OBJECT *)(string & 288230376151711743UL) + 2);
#line 244
  i = 0UL;
  {
#line 244
  while (1) {
    while_continue: /* CIL Label */ ;
#line 244
    if (! (i < limit)) {
#line 244
      goto while_break;
    }
#line 246
    tmp = next;
#line 246
    next ++;
#line 246
    c = (int )*tmp;
#line 247
    if (c < 128) {
      {
#line 248
      outf(stream, "%c", c);
      }
    } else {
      {
#line 250
      outf(stream, "\\x%02x", c);
      }
    }
#line 244
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 252
  if (limit < length) {
    {
#line 253
    outf(stream, "...");
    }
  }
#line 254
  return;
}
}
#line 257 "/home/khheo/project/mit-scheme-9.2/src/microcode/debug.c"
static void print_filename(outf_channel stream , SCHEME_OBJECT filename ) 
{ 
  long length ;
  char *scan ;
  char *end ;
  char *slash ;
  char *tmp ;
  char *__cil_tmp8 ;

  {
#line 265
  length = (long )(*((SCHEME_OBJECT *)(filename & 288230376151711743UL) + 1) & 288230376151711743UL);
#line 266
  scan = (char *)((SCHEME_OBJECT *)(filename & 288230376151711743UL) + 2);
#line 267
  end = scan + length;
#line 268
  slash = scan;
  {
#line 269
  while (1) {
    while_continue: /* CIL Label */ ;
#line 269
    if (! ((unsigned long )scan < (unsigned long )end)) {
#line 269
      goto while_break;
    }
#line 270
    tmp = scan;
#line 270
    scan ++;
#line 270
    if ((int )*tmp == 47) {
#line 271
      slash = scan;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 272
  outf(stream, "\"%s\"", slash);
  }
#line 273
  return;
}
}
#line 276 "/home/khheo/project/mit-scheme-9.2/src/microcode/debug.c"
static void print_object(SCHEME_OBJECT object ) 
{ 
  char *__cil_tmp2 ;

  {
  {
#line 279
  do_printing((outf_channel )1, object, (_Bool)1);
#line 280
  outf_error("\n");
#line 281
  outf_flush_error();
  }
#line 282
  return;
}
}
#line 284 "/home/khheo/project/mit-scheme-9.2/src/microcode/debug.c"
SCHEME_OBJECT Prim_debugging_printer(void) 
{ 


  {
  {
#line 287
  while (1) {
    while_continue: /* CIL Label */ ;
#line 287
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 289
  print_object(*(stack_pointer + 0));
  }
#line 290
  return (0UL);
}
}
#line 293 "/home/khheo/project/mit-scheme-9.2/src/microcode/debug.c"
static void print_objects(SCHEME_OBJECT *objects , int n ) 
{ 
  SCHEME_OBJECT *scan ;
  SCHEME_OBJECT *end ;
  SCHEME_OBJECT *tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 299
  scan = objects;
#line 300
  end = objects + n;
  {
#line 301
  while (1) {
    while_continue: /* CIL Label */ ;
#line 301
    if (! ((unsigned long )scan < (unsigned long )end)) {
#line 301
      goto while_break;
    }
    {
#line 303
    outf_error("%4lx: ", (unsigned long )((char *)scan - (char *)objects));
#line 305
    tmp = scan;
#line 305
    scan ++;
#line 305
    do_printing((outf_channel )1, *tmp, (_Bool)1);
#line 306
    outf_error("\n");
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 308
  outf_flush_error();
  }
#line 309
  return;
}
}
#line 316 "/home/khheo/project/mit-scheme-9.2/src/microcode/debug.c"
void Print_Vector(SCHEME_OBJECT vector ) 
{ 


  {
  {
#line 319
  print_objects((SCHEME_OBJECT *)(vector & 288230376151711743UL) + 1, (int )((*((SCHEME_OBJECT *)(vector & 288230376151711743UL) + 0) & 288230376151711743UL) & 288230376151711743UL));
  }
#line 321
  return;
}
}
#line 323 "/home/khheo/project/mit-scheme-9.2/src/microcode/debug.c"
static void print_expression(outf_channel stream , SCHEME_OBJECT expression , char const   *string ) 
{ 
  char *__cil_tmp4 ;

  {
#line 326
  if ((int const   )*(string + 0) != 0) {
    {
#line 327
    outf(stream, "%s: ", string);
    }
  }
  {
#line 328
  do_printing(stream, expression, (_Bool)1);
  }
#line 329
  return;
}
}
#line 331 "/home/khheo/project/mit-scheme-9.2/src/microcode/debug.c"
void Print_Expression(SCHEME_OBJECT expression , char const   *string ) 
{ 


  {
  {
#line 334
  print_expression((outf_channel )1, expression, string);
  }
#line 335
  return;
}
}
#line 337 "/home/khheo/project/mit-scheme-9.2/src/microcode/debug.c"
static void do_printing(outf_channel stream , SCHEME_OBJECT Expr , _Bool Detailed ) 
{ 
  long Temp_Address ;
  _Bool handled_p ;
  SCHEME_OBJECT procedure ;
  SCHEME_OBJECT entry ;
  _Bool closure_p ;
  cc_entry_type_t cet ;
  char const   *type_string ;
  SCHEME_OBJECT filename ;
  _Bool tmp ;
  _Bool tmp___0 ;
  unsigned long tmp___1 ;
  unsigned int type ;
  char const   *name ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;

  {
#line 340
  Temp_Address = (long )(Expr & 288230376151711743UL);
#line 341
  handled_p = (_Bool)0;
#line 343
  if (Expr == ((8UL << 58U) | 9UL)) {
    {
#line 343
    outf(stream, "()");
    }
#line 343
    return;
  } else
#line 344
  if (Expr == 0UL) {
    {
#line 344
    outf(stream, "#F");
    }
#line 344
    return;
  } else
#line 345
  if (Expr == 8UL << 58U) {
    {
#line 345
    outf(stream, "#T");
    }
#line 345
    return;
  } else
#line 346
  if (Expr == ((8UL << 58U) | 1UL)) {
    {
#line 346
    outf(stream, "[UNSPECIFIC]");
    }
#line 346
    return;
  } else
#line 348
  if (Expr == return_to_interpreter) {
    {
#line 350
    outf(stream, "[RETURN_TO_INTERPRETER]");
    }
#line 351
    return;
  } else
#line 354
  if (Expr == reflect_to_interface) {
    {
#line 356
    outf(stream, "[REFLECT_TO_INTERFACE]");
    }
#line 357
    return;
  }
  {
#line 363
  if (Expr >> 58U == 31UL) {
#line 363
    goto case_31;
  }
#line 374
  if (Expr >> 58U == 35UL) {
#line 374
    goto case_35;
  }
#line 379
  if (Expr >> 58U == 30UL) {
#line 379
    goto case_30;
  }
#line 383
  if (Expr >> 58U == 33UL) {
#line 383
    goto case_33;
  }
#line 388
  if (Expr >> 58U == 26UL) {
#line 388
    goto case_26;
  }
#line 392
  if (Expr >> 58U == 6UL) {
#line 392
    goto case_6;
  }
#line 397
  if (Expr >> 58U == 1UL) {
#line 397
    goto case_1;
  }
#line 397
  if (Expr >> 58U == 55UL) {
#line 397
    goto case_1;
  }
#line 401
  if (Expr >> 58U == 0UL) {
#line 401
    goto case_0;
  }
#line 404
  if (Expr >> 58U == 5UL) {
#line 404
    goto case_5;
  }
#line 408
  if (Expr >> 58U == 29UL) {
#line 408
    goto case_29;
  }
#line 412
  if (Expr >> 58U == 44UL) {
#line 412
    goto case_44;
  }
#line 422
  if (Expr >> 58U == 38UL) {
#line 422
    goto case_38;
  }
#line 434
  if (Expr >> 58U == 18UL) {
#line 434
    goto case_18;
  }
#line 448
  if (Expr >> 58U == 20UL) {
#line 448
    goto case_20;
  }
#line 458
  if (Expr >> 58U == 9UL) {
#line 458
    goto case_9;
  }
#line 466
  if (Expr >> 58U == 23UL) {
#line 466
    goto case_23;
  }
#line 476
  if (Expr >> 58U == 24UL) {
#line 476
    goto case_24;
  }
#line 482
  if (Expr >> 58U == 15UL) {
#line 482
    goto case_15;
  }
#line 490
  if (Expr >> 58U == 50UL) {
#line 490
    goto case_50;
  }
#line 501
  if (Expr >> 58U == 11UL) {
#line 501
    goto case_11;
  }
#line 507
  if (Expr >> 58U == 8UL) {
#line 507
    goto case_8;
  }
#line 511
  if (Expr >> 58U == 40UL) {
#line 511
    goto case_40;
  }
#line 587
  goto switch_default___0;
  case_31: /* CIL Label */ 
  {
#line 365
  outf(stream, "[ACCESS (");
#line 366
  Expr = *((SCHEME_OBJECT *)(Expr & 288230376151711743UL) + 1);
  }
  SPrint: 
  {
#line 368
  print_symbol(stream, Expr);
#line 369
  handled_p = (_Bool)1;
#line 370
  outf(stream, ")");
  }
#line 371
  goto switch_break;
  case_35: /* CIL Label */ 
  {
#line 375
  outf(stream, "[SET! (");
#line 376
  Expr = *((SCHEME_OBJECT *)(*((SCHEME_OBJECT *)(Expr & 288230376151711743UL) + 0) & 288230376151711743UL) + 0);
  }
#line 377
  goto SPrint;
  case_30: /* CIL Label */ 
  {
#line 380
  print_string(stream, Expr);
  }
#line 381
  return;
  case_33: /* CIL Label */ 
  {
#line 384
  outf(stream, "[DEFINE (");
#line 385
  Expr = *((SCHEME_OBJECT *)(Expr & 288230376151711743UL) + 0);
  }
#line 386
  goto SPrint;
  case_26: /* CIL Label */ 
  {
#line 389
  outf(stream, "%ld", (long )((Expr ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL)));
  }
#line 390
  return;
  case_6: /* CIL Label */ 
  {
#line 393
  outf(stream, "%lf", *((double *)((SCHEME_OBJECT *)(Expr & 288230376151711743UL) + 1)));
  }
#line 394
  return;
  case_1: /* CIL Label */ 
  case_55: /* CIL Label */ 
  {
#line 398
  print_list(stream, Expr);
  }
#line 399
  return;
  case_0: /* CIL Label */ 
#line 402
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 405
  outf(stream, "[UNINTERNED_SYMBOL (");
  }
#line 406
  goto SPrint;
  case_29: /* CIL Label */ 
  {
#line 409
  print_symbol(stream, Expr);
  }
#line 410
  return;
  case_44: /* CIL Label */ 
#line 413
  Expr = *((SCHEME_OBJECT *)(Expr & 288230376151711743UL) + 0);
#line 414
  if (Detailed) {
    {
#line 416
    outf(stream, "[VARIABLE (");
    }
#line 417
    goto SPrint;
  }
  {
#line 419
  print_symbol(stream, Expr);
  }
#line 420
  return;
  case_38: /* CIL Label */ 
  {
#line 423
  outf(stream, "[COMBINATION (%ld args) 0x%lx]", (long )((*((SCHEME_OBJECT *)(Expr & 288230376151711743UL) + 0) & 288230376151711743UL) - 1UL),
       Temp_Address);
  }
#line 426
  if (Detailed) {
    {
#line 428
    outf(stream, " (");
#line 429
    do_printing(stream, *((SCHEME_OBJECT *)(Expr & 288230376151711743UL) + 1), (_Bool)0);
#line 430
    outf(stream, " ...)");
    }
  }
#line 432
  return;
  case_18: /* CIL Label */ 
  {
#line 438
  outf(stream, "[ENVIRONMENT 0x%lx]", Temp_Address);
#line 439
  outf(stream, " (from ");
#line 440
  procedure = *((SCHEME_OBJECT *)(Expr & 288230376151711743UL) + 1);
  }
#line 441
  if (procedure >> 58U == 56UL) {
#line 442
    procedure = *((SCHEME_OBJECT *)(procedure & 288230376151711743UL) + 2);
  }
  {
#line 443
  do_printing(stream, procedure, (_Bool)0);
#line 444
  outf(stream, ")");
  }
#line 445
  return;
  case_20: /* CIL Label */ 
#line 449
  if (Detailed) {
    {
#line 450
    outf(stream, "[EXTENDED_LAMBDA (");
    }
  }
  {
#line 451
  do_printing(stream, *((SCHEME_OBJECT *)(*((SCHEME_OBJECT *)(Expr & 288230376151711743UL) + 1) & 288230376151711743UL) + 1),
              (_Bool)0);
  }
#line 454
  if (Detailed) {
    {
#line 455
    outf(stream, ") 0x%lx", Temp_Address);
    }
  }
#line 456
  return;
  case_9: /* CIL Label */ 
#line 459
  if (Detailed) {
    {
#line 460
    outf(stream, "[EXTENDED_PROCEDURE (");
    }
  }
  {
#line 461
  do_printing(stream, *((SCHEME_OBJECT *)(Expr & 288230376151711743UL) + 0), (_Bool)0);
  }
#line 462
  if (Detailed) {
    {
#line 463
    outf(stream, ") 0x%lx]", Temp_Address);
    }
  }
#line 464
  goto switch_break;
  case_23: /* CIL Label */ 
#line 467
  if (Detailed) {
    {
#line 468
    outf(stream, "[LAMBDA (");
    }
  }
  {
#line 469
  do_printing(stream, *((SCHEME_OBJECT *)(*((SCHEME_OBJECT *)(Expr & 288230376151711743UL) + 1) & 288230376151711743UL) + 1),
              (_Bool)0);
  }
#line 472
  if (Detailed) {
    {
#line 473
    outf(stream, ") 0x%lx]", Temp_Address);
    }
  }
#line 474
  return;
  case_24: /* CIL Label */ 
  {
#line 477
  outf(stream, "[PRIMITIVE ");
#line 478
  print_primitive_name(stream, Expr);
#line 479
  outf(stream, "]");
  }
#line 480
  return;
  case_15: /* CIL Label */ 
#line 483
  if (Detailed) {
    {
#line 484
    outf(stream, "[PROCEDURE (");
    }
  }
  {
#line 485
  do_printing(stream, *((SCHEME_OBJECT *)(Expr & 288230376151711743UL) + 0), (_Bool)0);
  }
#line 486
  if (Detailed) {
    {
#line 487
    outf(stream, ") 0x%lx]", Temp_Address);
    }
  }
#line 488
  return;
  case_50: /* CIL Label */ 
#line 492
  if ((Expr & 288230376151711743UL) <= 9UL) {
#line 493
    goto switch_break;
  }
  {
#line 494
  outf(stream, "[REFERENCE-TRAP");
#line 495
  print_expression(stream, *((SCHEME_OBJECT *)(Expr & 288230376151711743UL) + 0),
                   " tag");
#line 496
  print_expression(stream, *((SCHEME_OBJECT *)(Expr & 288230376151711743UL) + 1),
                   " extra");
#line 497
  outf(stream, "]");
  }
#line 498
  return;
  case_11: /* CIL Label */ 
  {
#line 502
  outf(stream, "[RETURN_CODE ");
#line 503
  print_return_name(stream, Expr);
#line 504
  outf(stream, "]");
  }
#line 505
  return;
  case_8: /* CIL Label */ 
#line 508
  goto switch_break;
  case_40: /* CIL Label */ 
  {
#line 513
  entry = Expr;
#line 514
  closure_p = (_Bool)0;
#line 519
  tmp___0 = read_cc_entry_type(& cet, (insn_t *)((SCHEME_OBJECT *)(entry & 288230376151711743UL)));
  }
#line 519
  if (tmp___0) {
#line 520
    type_string = "UNKNOWN";
  } else {
    {
#line 525
    if ((unsigned int )cet.marker == 7U) {
#line 525
      goto case_7;
    }
#line 525
    if ((unsigned int )cet.marker == 0U) {
#line 525
      goto case_7;
    }
#line 536
    if ((unsigned int )cet.marker == 1U) {
#line 536
      goto case_1___0;
    }
#line 540
    if ((unsigned int )cet.marker == 2U) {
#line 540
      goto case_2;
    }
#line 544
    if ((unsigned int )cet.marker == 4U) {
#line 544
      goto case_4;
    }
#line 549
    if ((unsigned int )cet.marker == 5U) {
#line 549
      goto case_5___0;
    }
#line 549
    if ((unsigned int )cet.marker == 3U) {
#line 549
      goto case_5___0;
    }
#line 553
    if ((unsigned int )cet.marker == 6U) {
#line 553
      goto case_6___0;
    }
#line 557
    goto switch_default;
    case_7: /* CIL Label */ 
    case_0___0: /* CIL Label */ 
    {
#line 526
    tmp = cc_entry_closure_p(entry);
    }
#line 526
    if (tmp) {
      {
#line 528
      type_string = "COMPILED_CLOSURE";
#line 529
      entry = cc_closure_to_entry(entry);
#line 530
      closure_p = (_Bool)1;
      }
    } else {
#line 533
      type_string = "COMPILED_PROCEDURE";
    }
#line 534
    goto switch_break___0;
    case_1___0: /* CIL Label */ 
#line 537
    type_string = "COMPILED_RETURN_ADDRESS";
#line 538
    goto switch_break___0;
    case_2: /* CIL Label */ 
#line 541
    type_string = "COMPILED_EXPRESSION";
#line 542
    goto switch_break___0;
    case_4: /* CIL Label */ 
#line 545
    type_string = "COMPILED_RETURN_ADDRESS";
#line 546
    goto switch_break___0;
    case_5___0: /* CIL Label */ 
    case_3: /* CIL Label */ 
#line 550
    type_string = "COMPILED_ENTRY";
#line 551
    goto switch_break___0;
    case_6___0: /* CIL Label */ 
#line 554
    type_string = "COMPILED_RETURN_ADDRESS";
#line 555
    goto switch_break___0;
    switch_default: /* CIL Label */ 
#line 558
    type_string = "COMPILED_ENTRY";
#line 559
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
  {
#line 562
  tmp___1 = cc_entry_to_block_offset(entry);
#line 562
  outf(stream, "[%s offset: %#lx entry: %#lx", type_string, tmp___1, entry & 288230376151711743UL);
  }
#line 566
  if (closure_p) {
    {
#line 567
    outf(stream, " address: 0x%lx", Temp_Address);
    }
  }
  {
#line 569
  filename = compiled_entry_debug_filename(entry);
  }
#line 570
  if (filename >> 58U == 30UL) {
    {
#line 572
    outf(stream, " file: ");
#line 573
    print_filename(stream, filename);
    }
  } else
#line 575
  if (filename >> 58U == 1UL) {
    {
#line 577
    outf(stream, " file: ");
#line 578
    print_filename(stream, *((SCHEME_OBJECT *)(filename & 288230376151711743UL) + 0));
#line 579
    outf(stream, " block: %ld", (long )((*((SCHEME_OBJECT *)(filename & 288230376151711743UL) + 1) ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL)));
    }
  }
  {
#line 582
  outf(stream, "]");
  }
#line 583
  return;
  switch_default___0: /* CIL Label */ 
#line 588
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 590
  if (! handled_p) {
#line 592
    type = (unsigned int )(Expr >> 58U);
#line 593
    name = (char const   *)0;
#line 594
    if (Expr >> 58U < (SCHEME_OBJECT )(1 << 6)) {
#line 595
      name = type_names[type];
    }
#line 596
    if ((unsigned long )name != (unsigned long )((char const   *)0)) {
      {
#line 597
      outf(stream, "[%s", name);
      }
    } else {
      {
#line 599
      outf(stream, "[%#02x", type);
      }
    }
  }
  {
#line 601
  outf(stream, " %#lx]", (unsigned long )Temp_Address);
  }
#line 602
  return;
}
}
#line 604 "/home/khheo/project/mit-scheme-9.2/src/microcode/debug.c"
extern void Debug_Print(SCHEME_OBJECT Expr , _Bool Detailed ) 
{ 
  char *__cil_tmp3 ;

  {
  {
#line 607
  do_printing((outf_channel )1, Expr, Detailed);
#line 608
  outf_error("\n");
#line 609
  outf_flush_error();
  }
#line 610
  return;
}
}
#line 612 "/home/khheo/project/mit-scheme-9.2/src/microcode/debug.c"
static _Bool print_one_continuation_frame(outf_channel stream , SCHEME_OBJECT Temp ) 
{ 
  SCHEME_OBJECT Expr ;
  SCHEME_OBJECT *tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 617
  outf(stream, "\n    ");
#line 618
  print_expression(stream, Temp, "Return code");
#line 619
  outf(stream, "\n    ");
#line 620
  tmp = stack_pointer;
#line 620
  stack_pointer ++;
#line 620
  Expr = *tmp;
#line 621
  print_expression(stream, Expr, "Expression");
#line 622
  outf(stream, "\n");
  }
#line 623
  if ((Temp & 288230376151711743UL) == 0UL) {
#line 625
    return ((_Bool)1);
  } else
#line 623
  if ((Temp & 288230376151711743UL) == 70UL) {
#line 625
    return ((_Bool)1);
  }
#line 626
  if ((Temp & 288230376151711743UL) == 1UL) {
    {
#line 627
    stack_pointer = control_point_start(Expr);
    }
  }
#line 628
  return ((_Bool)0);
}
}
#line 631
_Bool Print_One_Continuation_Frame(SCHEME_OBJECT Temp ) ;
#line 633 "/home/khheo/project/mit-scheme-9.2/src/microcode/debug.c"
_Bool Print_One_Continuation_Frame(SCHEME_OBJECT Temp ) 
{ 
  _Bool tmp ;

  {
  {
#line 636
  tmp = print_one_continuation_frame((outf_channel )1, Temp);
  }
#line 636
  return (tmp);
}
}
#line 642 "/home/khheo/project/mit-scheme-9.2/src/microcode/debug.c"
void Back_Trace(outf_channel stream ) 
{ 
  SCHEME_OBJECT Temp ;
  SCHEME_OBJECT *Old_Stack ;
  SCHEME_OBJECT *tmp ;
  _Bool tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 647
  Old_Stack = stack_pointer;
  {
#line 648
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 662
    outf(stream, "{%#lx}", (unsigned long )stack_pointer);
#line 663
    tmp = stack_pointer;
#line 663
    stack_pointer ++;
#line 663
    Temp = *tmp;
    }
#line 664
    if (Temp >> 58U == 11UL) {
      {
#line 666
      tmp___0 = print_one_continuation_frame(stream, Temp);
      }
#line 666
      if (tmp___0) {
#line 667
        goto while_break;
      }
    } else {
      {
#line 671
      print_expression(stream, Temp, "  ...");
      }
#line 672
      if (Temp >> 58U == 39UL) {
        {
#line 674
        outf(stream, " (skipping)");
#line 675
        stack_pointer += Temp & 288230376151711743UL;
        }
      }
      {
#line 677
      outf(stream, "\n");
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 680
  stack_pointer = Old_Stack;
#line 681
  outf_flush(stream);
  }
#line 682
  return;
}
}
#line 684 "/home/khheo/project/mit-scheme-9.2/src/microcode/debug.c"
void print_stack(SCHEME_OBJECT *sp ) 
{ 
  SCHEME_OBJECT *saved_sp ;

  {
  {
#line 687
  saved_sp = stack_pointer;
#line 688
  stack_pointer = sp;
#line 689
  Back_Trace((outf_channel )1);
#line 690
  stack_pointer = saved_sp;
  }
#line 691
  return;
}
}
#line 693 "/home/khheo/project/mit-scheme-9.2/src/microcode/debug.c"
extern void Debug_Stack_Trace(void) 
{ 


  {
  {
#line 696
  print_stack(stack_pointer + 0);
  }
#line 697
  return;
}
}
#line 699 "/home/khheo/project/mit-scheme-9.2/src/microcode/debug.c"
static _Bool print_primitive_name(outf_channel stream , SCHEME_OBJECT primitive ) 
{ 
  char const   *name ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 702
  name = *(Primitive_Name_Table + (primitive & 288230376151711743UL));
#line 703
  if ((unsigned long )name == (unsigned long )((char const   *)0)) {
    {
#line 705
    outf(stream, "Unknown primitive %#08lx", primitive & 288230376151711743UL);
    }
#line 706
    return ((_Bool)0);
  } else {
    {
#line 710
    outf(stream, "%s", name);
    }
#line 711
    return ((_Bool)1);
  }
}
}
#line 715 "/home/khheo/project/mit-scheme-9.2/src/microcode/debug.c"
void Print_Primitive(SCHEME_OBJECT primitive ) 
{ 
  char buffer___2[40] ;
  int NArgs ;
  int i ;
  _Bool tmp ;
  void *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 721
  outf_error("Primitive: ");
#line 722
  tmp = print_primitive_name((outf_channel )1, primitive);
  }
#line 722
  if (tmp) {
#line 723
    NArgs = *(Primitive_Arity_Table + (primitive & 288230376151711743UL));
  } else {
#line 725
    NArgs = 3;
  }
  {
#line 727
  outf_error("\n");
#line 729
  i = 0;
  }
  {
#line 729
  while (1) {
    while_continue: /* CIL Label */ ;
#line 729
    if (! (i < NArgs)) {
#line 729
      goto while_break;
    }
    {
#line 731
    sprintf((char */* __restrict  */)(buffer___2), (char const   */* __restrict  */)"...Arg %ld",
            (long )(i + 1));
#line 732
    print_expression((outf_channel )1, *(stack_pointer + i), (char const   *)(buffer___2));
#line 733
    outf_error("\n");
#line 729
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 735
  return;
}
}
#line 960 "/home/khheo/project/mit-scheme-9.2/src/microcode/debug.c"
_Bool verify_heap(void) 
{ 


  {
#line 963
  return ((_Bool)1);
}
}
#line 968 "/home/khheo/project/mit-scheme-9.2/src/microcode/debug.c"
SCHEME_OBJECT Prim_verify_heap(void) 
{ 
  unsigned long tmp___0 ;
  _Bool tmp___1 ;

  {
  {
#line 973
  while (1) {
    while_continue: /* CIL Label */ ;
#line 973
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 974
  tmp___1 = verify_heap();
  }
#line 974
  if (tmp___1) {
#line 974
    tmp___0 = 8UL << 58U;
  } else {
#line 974
    tmp___0 = 0UL;
  }
#line 974
  return (tmp___0);
}
}
#line 1144 "/home/khheo/project/mit-scheme-9.2/src/microcode/debug.c"
void debug_edit_flags(void) 
{ 
  char *__cil_tmp1 ;

  {
  {
#line 1147
  outf_error("Not a debugging version.  No flags to handle.\n");
#line 1148
  outf_flush_error();
  }
#line 1149
  return;
}
}
#line 1151 "/home/khheo/project/mit-scheme-9.2/src/microcode/debug.c"
static int set_flag(int flag_number , int value ) 
{ 


  {
  {
#line 1154
  signal_error_from_primitive(51L);
  }
#line 1156
  return (0);
}
}
#line 1161 "/home/khheo/project/mit-scheme-9.2/src/microcode/debug.c"
SCHEME_OBJECT Prim_set_debug_flags(void) 
{ 
  long tmp ;

  {
  {
#line 1164
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1164
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1165
  tmp = arg_integer(1);
#line 1165
  set_flag((int )tmp, *(stack_pointer + 1) != 0UL);
  }
#line 1166
  return ((8UL << 58U) | 1UL);
}
}
#line 49 "/home/khheo/project/mit-scheme-9.2/src/microcode/daemon.c"
SCHEME_OBJECT Prim_close_lost_open_files(void) 
{ 
  SCHEME_OBJECT file_list ;
  SCHEME_OBJECT *smash ;
  SCHEME_OBJECT cell ;
  SCHEME_OBJECT weak_cell ;

  {
  {
#line 51
  while (1) {
    while_continue: /* CIL Label */ ;
#line 51
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 53
  file_list = *(stack_pointer + 0);
#line 54
  smash = (SCHEME_OBJECT *)(file_list & 288230376151711743UL) + 1;
#line 55
  cell = *smash;
  {
#line 56
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 56
    if (! (! (cell == ((8UL << 58U) | 9UL)))) {
#line 56
      goto while_break___0;
    }
#line 58
    weak_cell = *((SCHEME_OBJECT *)(cell & 288230376151711743UL) + 0);
#line 59
    if (*((SCHEME_OBJECT *)(weak_cell & 288230376151711743UL) + 0) == 0UL) {
      {
#line 61
      OS_channel_close_noerror((Tchannel )((long )(*((SCHEME_OBJECT *)(weak_cell & 288230376151711743UL) + 1) & 288230376151711743UL)));
#line 63
      cell = *((SCHEME_OBJECT *)(cell & 288230376151711743UL) + 1);
#line 64
      *smash = cell;
      }
    } else {
#line 68
      smash = (SCHEME_OBJECT *)(cell & 288230376151711743UL) + 1;
#line 69
      cell = *smash;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 73
  return ((8UL << 58U) | 1UL);
}
}
#line 84 "/home/khheo/project/mit-scheme-9.2/src/microcode/daemon.c"
static void rehash_pair(SCHEME_OBJECT pair , SCHEME_OBJECT hash_table , long table_size ) 
{ 
  long object_datum ;
  long hash_address ;
  SCHEME_OBJECT *new_pair ;
  SCHEME_OBJECT *tmp ;
  SCHEME_OBJECT *tmp___0 ;

  {
#line 91
  object_datum = (long )(*((SCHEME_OBJECT *)(pair & 288230376151711743UL) + 0) & 288230376151711743UL);
#line 92
  hash_address = 2L + object_datum % table_size;
#line 93
  new_pair = Free;
#line 94
  tmp = Free;
#line 94
  Free ++;
#line 94
  *tmp = (1UL << 58U) | (pair & 288230376151711743UL);
#line 95
  tmp___0 = Free;
#line 95
  Free ++;
#line 95
  *tmp___0 = *((SCHEME_OBJECT *)(hash_table & 288230376151711743UL) + hash_address);
#line 96
  *((SCHEME_OBJECT *)(hash_table & 288230376151711743UL) + hash_address) = (1UL << 58U) | (SCHEME_OBJECT )new_pair;
#line 99
  return;
}
}
#line 101 "/home/khheo/project/mit-scheme-9.2/src/microcode/daemon.c"
static void rehash_bucket(SCHEME_OBJECT *bucket , SCHEME_OBJECT hash_table , long table_size ) 
{ 
  SCHEME_OBJECT weak_pair ;

  {
  {
#line 107
  while (1) {
    while_continue: /* CIL Label */ ;
#line 107
    if (! (! (*bucket == ((8UL << 58U) | 9UL)))) {
#line 107
      goto while_break;
    }
#line 109
    weak_pair = *((SCHEME_OBJECT *)(*bucket & 288230376151711743UL) + 0);
#line 110
    if (*((SCHEME_OBJECT *)(weak_pair & 288230376151711743UL) + 0) != 0UL) {
      {
#line 112
      rehash_pair(weak_pair, hash_table, table_size);
      }
    }
#line 114
    bucket = (SCHEME_OBJECT *)(*bucket & 288230376151711743UL) + 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 116
  return;
}
}
#line 118 "/home/khheo/project/mit-scheme-9.2/src/microcode/daemon.c"
static void splice_and_rehash_bucket(SCHEME_OBJECT *bucket , SCHEME_OBJECT hash_table ,
                                     long table_size ) 
{ 
  SCHEME_OBJECT weak_pair ;

  {
  {
#line 124
  while (1) {
    while_continue: /* CIL Label */ ;
#line 124
    if (! (! (*bucket == ((8UL << 58U) | 9UL)))) {
#line 124
      goto while_break;
    }
#line 126
    weak_pair = *((SCHEME_OBJECT *)(*bucket & 288230376151711743UL) + 0);
#line 127
    if (*((SCHEME_OBJECT *)(weak_pair & 288230376151711743UL) + 0) != 0UL) {
      {
#line 129
      rehash_pair(weak_pair, hash_table, table_size);
#line 130
      bucket = (SCHEME_OBJECT *)(*bucket & 288230376151711743UL) + 1;
      }
    } else {
#line 133
      *bucket = *((SCHEME_OBJECT *)(*bucket & 288230376151711743UL) + 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 135
  return;
}
}
#line 142 "/home/khheo/project/mit-scheme-9.2/src/microcode/daemon.c"
SCHEME_OBJECT Prim_rehash(void) 
{ 
  long table_size ;
  long counter ;
  SCHEME_OBJECT *bucket ;
  SCHEME_OBJECT *tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
  {
#line 146
  while (1) {
    while_continue: /* CIL Label */ ;
#line 146
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 147
  table_size = (long )(*((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 0) & 288230376151711743UL);
#line 150
  counter = table_size;
#line 151
  bucket = (SCHEME_OBJECT *)(*(stack_pointer + 1) & 288230376151711743UL) + 2;
  {
#line 152
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 152
    tmp___0 = counter;
#line 152
    counter --;
#line 152
    if (! (tmp___0 > 0L)) {
#line 152
      goto while_break___0;
    }
#line 153
    tmp = bucket;
#line 153
    bucket ++;
#line 153
    *tmp = (8UL << 58U) | 9UL;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 157
  counter = table_size;
#line 158
  bucket = (SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 1;
  {
#line 159
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 159
    tmp___1 = counter;
#line 159
    counter --;
#line 159
    if (! (tmp___1 > 0L)) {
#line 159
      goto while_break___1;
    }
#line 161
    if (*((SCHEME_OBJECT *)(*bucket & 288230376151711743UL) + 0) == 8UL << 58U) {
      {
#line 162
      splice_and_rehash_bucket((SCHEME_OBJECT *)(*bucket & 288230376151711743UL) + 1,
                               *(stack_pointer + 1), table_size);
      }
    } else {
      {
#line 165
      rehash_bucket((SCHEME_OBJECT *)(*bucket & 288230376151711743UL) + 1, *(stack_pointer + 1),
                    table_size);
      }
    }
#line 166
    bucket ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 168
  return ((8UL << 58U) | 1UL);
}
}
#line 33 "/home/khheo/project/mit-scheme-9.2/src/microcode/char.c"
long arg_ascii_char(int n ) 
{ 
  SCHEME_OBJECT object ;

  {
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
#line 36
    if (! (*(stack_pointer + (n - 1)) >> 58U == 2UL)) {
      {
#line 36
      error_wrong_type_arg(n);
      }
    }
#line 36
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 38
  object = *(stack_pointer + (n - 1));
#line 39
  if (! ((object & 288230376151711743UL) < 1UL << 8)) {
    {
#line 40
    error_bad_range_arg(n);
    }
  }
#line 41
  return ((long )(object & ((1UL << 8) - 1UL)));
}
}
#line 45 "/home/khheo/project/mit-scheme-9.2/src/microcode/char.c"
long arg_ascii_integer(int n ) 
{ 
  long tmp ;

  {
  {
#line 48
  tmp = arg_index_integer(n, (long )(1UL << 8));
  }
#line 48
  return (tmp);
}
}
#line 51 "/home/khheo/project/mit-scheme-9.2/src/microcode/char.c"
SCHEME_OBJECT Prim_char_p(void) 
{ 
  unsigned long tmp ;

  {
  {
#line 53
  while (1) {
    while_continue: /* CIL Label */ ;
#line 53
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 54
  if (*(stack_pointer + 0) >> 58U == 2UL) {
#line 54
    tmp = 8UL << 58U;
  } else {
#line 54
    tmp = 0UL;
  }
#line 54
  return (tmp);
}
}
#line 57 "/home/khheo/project/mit-scheme-9.2/src/microcode/char.c"
SCHEME_OBJECT Prim_make_char(void) 
{ 
  long tmp ;
  long tmp___0 ;

  {
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;
#line 59
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 60
  tmp = arg_index_integer(2, (long )(1UL << 4));
#line 60
  tmp___0 = arg_index_integer(1, (long )(1UL << 21));
  }
#line 60
  return ((2UL << 58U) | (((unsigned long )tmp << 21) | (unsigned long )tmp___0));
}
}
#line 65 "/home/khheo/project/mit-scheme-9.2/src/microcode/char.c"
SCHEME_OBJECT Prim_char_bits(void) 
{ 


  {
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
#line 67
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 68
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 68
    if (! (*(stack_pointer + 0) >> 58U == 2UL)) {
      {
#line 68
      error_wrong_type_arg(1);
      }
    }
#line 68
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 69
  return ((26UL << 58U) | (((*(stack_pointer + 0) & 288230376151711743UL) >> 21) & ((1UL << 4) - 1UL)));
}
}
#line 72 "/home/khheo/project/mit-scheme-9.2/src/microcode/char.c"
SCHEME_OBJECT Prim_char_code(void) 
{ 


  {
  {
#line 74
  while (1) {
    while_continue: /* CIL Label */ ;
#line 74
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 75
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 75
    if (! (*(stack_pointer + 0) >> 58U == 2UL)) {
      {
#line 75
      error_wrong_type_arg(1);
      }
    }
#line 75
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 76
  return ((26UL << 58U) | ((*(stack_pointer + 0) & 288230376151711743UL) & ((1UL << 21) - 1UL)));
}
}
#line 79 "/home/khheo/project/mit-scheme-9.2/src/microcode/char.c"
SCHEME_OBJECT Prim_char_to_integer(void) 
{ 


  {
  {
#line 81
  while (1) {
    while_continue: /* CIL Label */ ;
#line 81
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 82
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 82
    if (! (*(stack_pointer + 0) >> 58U == 2UL)) {
      {
#line 82
      error_wrong_type_arg(1);
      }
    }
#line 82
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 83
  return ((26UL << 58U) | (*(stack_pointer + 0) & ((1UL << 25) - 1UL)));
}
}
#line 87 "/home/khheo/project/mit-scheme-9.2/src/microcode/char.c"
SCHEME_OBJECT Prim_integer_to_char(void) 
{ 
  long tmp ;

  {
  {
#line 89
  while (1) {
    while_continue: /* CIL Label */ ;
#line 89
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 90
  tmp = arg_index_integer(1, (long )(1UL << 25));
  }
#line 90
  return ((2UL << 58U) | (unsigned long )tmp);
}
}
#line 94 "/home/khheo/project/mit-scheme-9.2/src/microcode/char.c"
long char_downcase(long c ) 
{ 
  long tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
  {
#line 97
  tmp___1 = __ctype_b_loc();
  }
#line 97
  if ((int const   )*(*tmp___1 + (int )c) & 256) {
#line 97
    tmp___0 = (c - 65L) + 97L;
  } else {
#line 97
    tmp___0 = c;
  }
#line 97
  return (tmp___0);
}
}
#line 100 "/home/khheo/project/mit-scheme-9.2/src/microcode/char.c"
long char_upcase(long c ) 
{ 
  long tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
  {
#line 103
  tmp___1 = __ctype_b_loc();
  }
#line 103
  if ((int const   )*(*tmp___1 + (int )c) & 512) {
#line 103
    tmp___0 = (c - 97L) + 65L;
  } else {
#line 103
    tmp___0 = c;
  }
#line 103
  return (tmp___0);
}
}
#line 106 "/home/khheo/project/mit-scheme-9.2/src/microcode/char.c"
SCHEME_OBJECT Prim_char_downcase(void) 
{ 
  long tmp ;

  {
  {
#line 108
  while (1) {
    while_continue: /* CIL Label */ ;
#line 108
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 109
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 109
    if (! (*(stack_pointer + 0) >> 58U == 2UL)) {
      {
#line 109
      error_wrong_type_arg(1);
      }
    }
#line 109
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 110
  tmp = char_downcase((long )((*(stack_pointer + 0) & 288230376151711743UL) & ((1UL << 21) - 1UL)));
  }
#line 110
  return ((2UL << 58U) | (((((*(stack_pointer + 0) & 288230376151711743UL) >> 21) & ((1UL << 4) - 1UL)) << 21) | (unsigned long )tmp));
}
}
#line 115 "/home/khheo/project/mit-scheme-9.2/src/microcode/char.c"
SCHEME_OBJECT Prim_char_upcase(void) 
{ 
  long tmp ;

  {
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
#line 117
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 118
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 118
    if (! (*(stack_pointer + 0) >> 58U == 2UL)) {
      {
#line 118
      error_wrong_type_arg(1);
      }
    }
#line 118
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 119
  tmp = char_upcase((long )((*(stack_pointer + 0) & 288230376151711743UL) & ((1UL << 21) - 1UL)));
  }
#line 119
  return ((2UL << 58U) | (((((*(stack_pointer + 0) & 288230376151711743UL) >> 21) & ((1UL << 4) - 1UL)) << 21) | (unsigned long )tmp));
}
}
#line 124 "/home/khheo/project/mit-scheme-9.2/src/microcode/char.c"
SCHEME_OBJECT Prim_ascii_to_char(void) 
{ 
  long tmp ;

  {
  {
#line 126
  while (1) {
    while_continue: /* CIL Label */ ;
#line 126
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 127
  tmp = arg_index_integer(1, (long )(1UL << 8));
  }
#line 127
  return ((2UL << 58U) | (unsigned long )tmp);
}
}
#line 130 "/home/khheo/project/mit-scheme-9.2/src/microcode/char.c"
SCHEME_OBJECT Prim_char_to_ascii(void) 
{ 
  long tmp ;

  {
  {
#line 132
  while (1) {
    while_continue: /* CIL Label */ ;
#line 132
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 133
  tmp = arg_ascii_char(1);
  }
#line 133
  return ((26UL << 58U) | (unsigned long )tmp);
}
}
#line 136 "/home/khheo/project/mit-scheme-9.2/src/microcode/char.c"
SCHEME_OBJECT Prim_char_ascii_p(void) 
{ 
  SCHEME_OBJECT character ;
  unsigned long tmp ;

  {
  {
#line 138
  while (1) {
    while_continue: /* CIL Label */ ;
#line 138
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 139
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 139
    if (! (*(stack_pointer + 0) >> 58U == 2UL)) {
      {
#line 139
      error_wrong_type_arg(1);
      }
    }
#line 139
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 141
  character = *(stack_pointer + 0);
#line 142
  if ((character & 288230376151711743UL) >= 1UL << 8) {
#line 142
    tmp = 0UL;
  } else {
#line 142
    tmp = (26UL << 58U) | (character & ((1UL << 8) - 1UL));
  }
#line 142
  return (tmp);
}
}
#line 35 "/home/khheo/project/mit-scheme-9.2/src/microcode/critsec.h"
_Bool critical_section_hook_p  ;
#line 36 "/home/khheo/project/mit-scheme-9.2/src/microcode/critsec.h"
void (*critical_section_hook)(char const   * )  ;
#line 181 "/home/khheo/project/mit-scheme-9.2/src/microcode/extern.h"
char const   *scheme_program_name  ;
#line 182 "/home/khheo/project/mit-scheme-9.2/src/microcode/extern.h"
char const   *OS_Name  ;
#line 183 "/home/khheo/project/mit-scheme-9.2/src/microcode/extern.h"
char const   *OS_Variant  ;
#line 184 "/home/khheo/project/mit-scheme-9.2/src/microcode/extern.h"
struct obstack scratch_obstack  ;
#line 185 "/home/khheo/project/mit-scheme-9.2/src/microcode/extern.h"
struct obstack ffi_obstack  ;
#line 37 "/home/khheo/project/mit-scheme-9.2/src/microcode/boot.c"
SCHEME_OBJECT Re_Enter_Interpreter(void) ;
#line 57
static void start_scheme(void) ;
#line 58
static void Enter_Interpreter(void) ;
#line 65 "/home/khheo/project/mit-scheme-9.2/src/microcode/boot.c"
void *initial_C_stack_pointer  ;
#line 66 "/home/khheo/project/mit-scheme-9.2/src/microcode/boot.c"
static char *reload_saved_string  ;
#line 67 "/home/khheo/project/mit-scheme-9.2/src/microcode/boot.c"
static unsigned int reload_saved_string_length  ;
#line 69 "/home/khheo/project/mit-scheme-9.2/src/microcode/boot.c"
void *obstack_chunk_alloc(size_t size ) 
{ 
  void *result ;
  void *tmp ;
  char *__cil_tmp4 ;

  {
  {
#line 72
  tmp = malloc(size);
#line 72
  result = tmp;
  }
#line 73
  if ((unsigned long )result == (unsigned long )((void *)0)) {
    {
#line 75
    outf_fatal("\n%s: unable to allocate obstack chunk of %d bytes\n", scheme_program_name,
               (int )size);
#line 77
    Microcode_Termination(12);
    }
  }
#line 79
  return (result);
}
}
#line 85 "/home/khheo/project/mit-scheme-9.2/src/microcode/boot.c"
char const   *critical_section_name  =    (char const   *)0;
#line 95 "/home/khheo/project/mit-scheme-9.2/src/microcode/boot.c"
int main(int argc , char const   **argv ) 
{ 


  {
  {
#line 98
  init_exit_scheme();
#line 99
  scheme_program_name = *(argv + 0);
#line 100
  initial_C_stack_pointer = (void *)(& argc);
#line 111
  _obstack_begin(& scratch_obstack, 0, 0L, & obstack_chunk_alloc, (void (*)(void * ))(& free));
#line 112
  _obstack_begin(& ffi_obstack, 0, 0L, & obstack_chunk_alloc, (void (*)(void * ))(& free));
#line 113
  dstack_initialize();
#line 114
  transaction_initialize();
#line 115
  reload_saved_string = (char *)0;
#line 116
  reload_saved_string_length = 0U;
#line 117
  read_command_line_options(argc, argv);
#line 119
  setup_memory(option_heap_size * 1024UL, option_stack_size * 1024UL, option_constant_size * 1024UL);
#line 123
  initialize_primitives();
#line 124
  compiler_initialize((_Bool )((unsigned long )option_fasl_file != (unsigned long )((char const   *)0)));
#line 125
  OS_initialize();
#line 126
  start_scheme();
#line 127
  termination_init_error();
  }
#line 128
  return (0);
}
}
#line 137 "/home/khheo/project/mit-scheme-9.2/src/microcode/boot.c"
static void start_scheme(void) 
{ 
  SCHEME_OBJECT expr ;
  SCHEME_OBJECT prim1 ;
  SCHEME_OBJECT tmp ;
  SCHEME_OBJECT fn_object ;
  SCHEME_OBJECT tmp___0 ;
  SCHEME_OBJECT prim2 ;
  SCHEME_OBJECT tmp___1 ;
  SCHEME_OBJECT *inner_arg ;
  SCHEME_OBJECT *tmp___2 ;
  SCHEME_OBJECT *tmp___3 ;
  SCHEME_OBJECT *tmp___4 ;
  SCHEME_OBJECT *tmp___5 ;
  SCHEME_OBJECT *tmp___6 ;
  SCHEME_OBJECT *tmp___7 ;
  SCHEME_OBJECT *tmp___8 ;
  SCHEME_OBJECT prim ;
  SCHEME_OBJECT tmp___9 ;
  SCHEME_OBJECT fn_object___0 ;
  SCHEME_OBJECT tmp___10 ;
  SCHEME_OBJECT *tmp___11 ;
  SCHEME_OBJECT *tmp___12 ;
  SCHEME_OBJECT *tmp___13 ;
  SCHEME_OBJECT *tmp___14 ;
  SCHEME_OBJECT *tmp___15 ;
  SCHEME_OBJECT *tmp___16 ;
  SCHEME_OBJECT *tmp___17 ;
  SCHEME_OBJECT *tmp___18 ;
  SCHEME_OBJECT *tmp___19 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;

  {
#line 142
  if (! option_batch_mode) {
#line 142
    if (! option_show_version) {
#line 142
      if (! option_show_help) {
        {
#line 144
        outf_console("MIT/GNU Scheme running under %s\n", OS_Variant);
#line 145
        OS_announcement();
#line 146
        outf_console("\n");
#line 147
        outf_flush_console();
        }
      }
    }
  }
  {
#line 149
  initialize_fixed_objects_vector();
  }
#line 151
  if ((unsigned long )option_fasl_file != (unsigned long )((char const   *)0)) {
    {
#line 158
    tmp = make_primitive("BINARY-FASLOAD", 1);
#line 158
    prim1 = tmp;
#line 160
    tmp___0 = char_pointer_to_string(option_fasl_file);
#line 160
    fn_object = tmp___0;
#line 161
    tmp___1 = make_primitive("SCODE-EVAL", 2);
#line 161
    prim2 = tmp___1;
#line 162
    inner_arg = Free;
#line 163
    tmp___2 = Free;
#line 163
    Free ++;
#line 163
    *tmp___2 = 2UL;
#line 164
    tmp___3 = Free;
#line 164
    Free ++;
#line 164
    *tmp___3 = prim1;
#line 165
    tmp___4 = Free;
#line 165
    Free ++;
#line 165
    *tmp___4 = fn_object;
#line 166
    expr = (38UL << 58U) | (SCHEME_OBJECT )Free;
#line 167
    tmp___5 = Free;
#line 167
    Free ++;
#line 167
    *tmp___5 = 3UL;
#line 168
    tmp___6 = Free;
#line 168
    Free ++;
#line 168
    *tmp___6 = prim2;
#line 169
    tmp___7 = Free;
#line 169
    Free ++;
#line 169
    *tmp___7 = (38UL << 58U) | (SCHEME_OBJECT )inner_arg;
#line 170
    tmp___8 = Free;
#line 170
    Free ++;
#line 170
    *tmp___8 = 0UL;
    }
  } else {
    {
#line 175
    tmp___9 = make_primitive("LOAD-BAND", 1);
#line 175
    prim = tmp___9;
#line 176
    tmp___10 = char_pointer_to_string(option_band_file);
#line 176
    fn_object___0 = tmp___10;
#line 177
    expr = (38UL << 58U) | (SCHEME_OBJECT )Free;
#line 178
    tmp___11 = Free;
#line 178
    Free ++;
#line 178
    *tmp___11 = 2UL;
#line 179
    tmp___12 = Free;
#line 179
    Free ++;
#line 179
    *tmp___12 = prim;
#line 180
    tmp___13 = Free;
#line 180
    Free ++;
#line 180
    *tmp___13 = fn_object___0;
    }
  }
  {
#line 184
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 184
    set_ulong_register(1U, 0UL);
#line 184
    set_ulong_register(12U, 0UL);
    }
    {
#line 184
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 184
      if ((Registers[1] & Registers[12]) != 0UL) {
#line 184
        tmp___15 = memory_block_start;
      } else {
#line 184
        if ((Registers[1] & 4UL) != 0UL) {
#line 184
          tmp___14 = heap_alloc_limit;
        } else {
#line 184
          tmp___14 = heap_end;
        }
#line 184
        tmp___15 = tmp___14;
      }
      {
#line 184
      set_ptr_register(0U, tmp___15);
      }
#line 184
      if ((Registers[1] & 1UL) != 0UL) {
#line 184
        tmp___16 = stack_guard;
      } else {
#line 184
        tmp___16 = stack_start;
      }
      {
#line 184
      set_ptr_register(11U, tmp___16);
      }
#line 184
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 184
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 185
  Registers[3] = 0UL;
#line 186
  trapping = (_Bool)0;
  {
#line 189
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 189
    if (! ((unsigned long )(stack_pointer + -2) >= (unsigned long )stack_guard)) {
      {
#line 189
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 189
        if (*stack_start != ((34UL << 58U) | (SCHEME_OBJECT )stack_start)) {
          {
#line 189
          stack_death("STACK_CHECK");
          }
        }
#line 189
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 189
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 189
        set_ulong_register(12U, Registers[12] | 1UL);
        }
        {
#line 189
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 189
          if ((Registers[1] & Registers[12]) != 0UL) {
#line 189
            tmp___18 = memory_block_start;
          } else {
#line 189
            if ((Registers[1] & 4UL) != 0UL) {
#line 189
              tmp___17 = heap_alloc_limit;
            } else {
#line 189
              tmp___17 = heap_end;
            }
#line 189
            tmp___18 = tmp___17;
          }
          {
#line 189
          set_ptr_register(0U, tmp___18);
          }
#line 189
          if ((Registers[1] & 1UL) != 0UL) {
#line 189
            tmp___19 = stack_guard;
          } else {
#line 189
            tmp___19 = stack_start;
          }
          {
#line 189
          set_ptr_register(11U, tmp___19);
          }
#line 189
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 189
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 189
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 190
  Registers[6] = 11UL << 58U;
#line 191
  Registers[5] = 0UL;
  {
#line 192
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 192
    stack_pointer --;
#line 192
    *stack_pointer = Registers[5];
#line 192
    stack_pointer --;
#line 192
    *stack_pointer = Registers[6];
#line 192
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 195
  Registers[5] = expr;
#line 198
  if ((unsigned long )stack_pointer >= (unsigned long )stack_guard) {
#line 198
    if (! ((unsigned long )Free <= (unsigned long )heap_alloc_limit)) {
      {
#line 200
      outf_fatal("Configuration won\'t hold initial data.\n");
#line 201
      termination_init_error();
      }
    }
  } else {
    {
#line 200
    outf_fatal("Configuration won\'t hold initial data.\n");
#line 201
    termination_init_error();
    }
  }
  {
#line 203
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 203
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 204
  Enter_Interpreter();
  }
#line 205
  return;
}
}
#line 207 "/home/khheo/project/mit-scheme-9.2/src/microcode/boot.c"
static void Do_Enter_Interpreter(void) 
{ 
  char *__cil_tmp1 ;

  {
  {
#line 210
  Interpret(0);
#line 211
  outf_fatal("\nThe interpreter returned to top level!\n");
#line 212
  Microcode_Termination(12);
  }
}
}
#line 215 "/home/khheo/project/mit-scheme-9.2/src/microcode/boot.c"
static void Enter_Interpreter(void) 
{ 


  {
  {
#line 218
  Do_Enter_Interpreter();
  }
#line 219
  return;
}
}
#line 223 "/home/khheo/project/mit-scheme-9.2/src/microcode/boot.c"
SCHEME_OBJECT Re_Enter_Interpreter(void) 
{ 


  {
  {
#line 226
  Interpret(0);
  }
#line 227
  return (Registers[2]);
}
}
#line 232 "/home/khheo/project/mit-scheme-9.2/src/microcode/boot.c"
SCHEME_OBJECT Prim_microcode_identify(void) 
{ 
  SCHEME_OBJECT tmp ;

  {
  {
#line 234
  while (1) {
    while_continue: /* CIL Label */ ;
#line 234
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 235
  tmp = make_microcode_identification_vector();
  }
#line 235
  return (tmp);
}
}
#line 238 "/home/khheo/project/mit-scheme-9.2/src/microcode/boot.c"
SCHEME_OBJECT Prim_microcode_library_path(void) 
{ 
  char const   **scan ;
  char const   **end ;
  SCHEME_OBJECT result ;
  SCHEME_OBJECT tmp ;
  SCHEME_OBJECT *scan_result ;
  SCHEME_OBJECT *tmp___0 ;
  char const   **tmp___1 ;

  {
  {
#line 240
  while (1) {
    while_continue: /* CIL Label */ ;
#line 240
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 242
  scan = option_library_path;
#line 243
  end = option_library_path;
  {
#line 244
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 246
    if ((unsigned long )*end == (unsigned long )((char const   *)0)) {
#line 247
      goto while_break___0;
    }
#line 248
    end ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 251
  tmp = allocate_marked_vector(10U, (unsigned long )(end - scan), (_Bool)1);
#line 251
  result = tmp;
#line 253
  scan_result = (SCHEME_OBJECT *)(result & 288230376151711743UL) + 1;
  }
  {
#line 254
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 254
    if (! ((unsigned long )scan < (unsigned long )end)) {
#line 254
      goto while_break___1;
    }
    {
#line 255
    tmp___0 = scan_result;
#line 255
    scan_result ++;
#line 255
    tmp___1 = scan;
#line 255
    scan ++;
#line 255
    *tmp___0 = char_pointer_to_string(*tmp___1);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 256
  return (result);
}
}
#line 261 "/home/khheo/project/mit-scheme-9.2/src/microcode/boot.c"
static SCHEME_OBJECT argv_to_object(int argc , char const   **argv ) 
{ 
  SCHEME_OBJECT result ;
  SCHEME_OBJECT tmp ;
  char const   **scan ;
  char const   **end ;
  SCHEME_OBJECT *scan_result ;
  SCHEME_OBJECT *tmp___0 ;
  char const   **tmp___1 ;

  {
  {
#line 264
  tmp = allocate_marked_vector(10U, (unsigned long )argc, (_Bool)1);
#line 264
  result = tmp;
#line 265
  scan = argv;
#line 266
  end = scan + argc;
#line 267
  scan_result = (SCHEME_OBJECT *)(result & 288230376151711743UL) + 1;
  }
  {
#line 268
  while (1) {
    while_continue: /* CIL Label */ ;
#line 268
    if (! ((unsigned long )scan < (unsigned long )end)) {
#line 268
      goto while_break;
    }
    {
#line 269
    tmp___0 = scan_result;
#line 269
    scan_result ++;
#line 269
    tmp___1 = scan;
#line 269
    scan ++;
#line 269
    *tmp___0 = char_pointer_to_string(*tmp___1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 270
  return (result);
}
}
#line 273 "/home/khheo/project/mit-scheme-9.2/src/microcode/boot.c"
SCHEME_OBJECT Prim_get_command_line(void) 
{ 
  SCHEME_OBJECT tmp ;

  {
  {
#line 275
  while (1) {
    while_continue: /* CIL Label */ ;
#line 275
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 276
  tmp = argv_to_object(option_saved_argc, option_saved_argv);
  }
#line 276
  return (tmp);
}
}
#line 279 "/home/khheo/project/mit-scheme-9.2/src/microcode/boot.c"
SCHEME_OBJECT Prim_get_unused_command_line(void) 
{ 
  SCHEME_OBJECT result ;
  SCHEME_OBJECT tmp ;

  {
  {
#line 281
  while (1) {
    while_continue: /* CIL Label */ ;
#line 281
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 282
  if ((unsigned long )option_unused_argv == (unsigned long )((char const   **)0)) {
#line 283
    return (0UL);
  }
  {
#line 285
  tmp = argv_to_object(option_unused_argc, option_unused_argv);
#line 285
  result = tmp;
#line 287
  option_unused_argv = (char const   **)0;
  }
#line 288
  return (result);
}
}
#line 292 "/home/khheo/project/mit-scheme-9.2/src/microcode/boot.c"
SCHEME_OBJECT Prim_reload_save_string(void) 
{ 
  unsigned int length ;
  void *tmp ;
  char *scan ;
  char *end ;
  char *scan_result ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 294
  while (1) {
    while_continue: /* CIL Label */ ;
#line 294
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 295
  if ((unsigned long )reload_saved_string != (unsigned long )((char *)0)) {
    {
#line 297
    free((void *)reload_saved_string);
#line 298
    reload_saved_string = (char *)0;
    }
  }
#line 300
  if (*(stack_pointer + 0) != 0UL) {
    {
#line 302
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 302
      if (! (*(stack_pointer + 0) >> 58U == 30UL)) {
        {
#line 302
        error_wrong_type_arg(1);
        }
      }
#line 302
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 304
    length = (unsigned int )(*((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 1) & 288230376151711743UL);
#line 305
    if (length > 0U) {
      {
#line 307
      tmp = OS_malloc((size_t )length);
#line 307
      reload_saved_string = (char *)tmp;
#line 308
      reload_saved_string_length = length;
#line 310
      scan = (char *)((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 2);
#line 311
      end = scan + length;
#line 312
      scan_result = reload_saved_string;
      }
      {
#line 313
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 313
        if (! ((unsigned long )scan < (unsigned long )end)) {
#line 313
          goto while_break___1;
        }
#line 314
        tmp___0 = scan_result;
#line 314
        scan_result ++;
#line 314
        tmp___1 = scan;
#line 314
        scan ++;
#line 314
        *tmp___0 = *tmp___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  }
#line 319
  return ((8UL << 58U) | 1UL);
}
}
#line 322 "/home/khheo/project/mit-scheme-9.2/src/microcode/boot.c"
SCHEME_OBJECT Prim_reload_retrieve_string(void) 
{ 
  SCHEME_OBJECT result ;
  SCHEME_OBJECT tmp ;

  {
  {
#line 324
  while (1) {
    while_continue: /* CIL Label */ ;
#line 324
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 325
  if ((unsigned long )reload_saved_string == (unsigned long )((char *)0)) {
#line 326
    return (0UL);
  }
  {
#line 328
  tmp = memory_to_string((unsigned long )reload_saved_string_length, (void const   *)((unsigned char *)reload_saved_string));
#line 328
  result = tmp;
#line 331
  free((void *)reload_saved_string);
#line 332
  reload_saved_string = (char *)0;
  }
#line 333
  return (result);
}
}
#line 337 "/home/khheo/project/mit-scheme-9.2/src/microcode/boot.c"
SCHEME_OBJECT Prim_batch_mode_p(void) 
{ 
  unsigned long tmp ;

  {
  {
#line 339
  while (1) {
    while_continue: /* CIL Label */ ;
#line 339
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 340
  if (option_batch_mode) {
#line 340
    tmp = 8UL << 58U;
  } else {
#line 340
    tmp = 0UL;
  }
#line 340
  return (tmp);
}
}
#line 297 "/home/khheo/project/mit-scheme-9.2/src/microcode/extern.h"
SCHEME_OBJECT allocate_bit_string(unsigned long length ) ;
#line 315
void clear_bit_string(SCHEME_OBJECT bit_string ) ;
#line 316
void bit_string_set(SCHEME_OBJECT bitstr , long index___0 , int value ) ;
#line 116 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.h"
void bignum_to_digit_stream(bignum_type bignum , unsigned int radix , void (*consumer)(bignum_procedure_context  ,
                                                                                       long  ) ,
                            bignum_procedure_context context ) ;
#line 37 "/home/khheo/project/mit-scheme-9.2/src/microcode/bitstr.c"
static void copy_bits(SCHEME_OBJECT *source , long source_offset , SCHEME_OBJECT *destination ,
                      long destination_offset , long nbits ) ;
#line 40 "/home/khheo/project/mit-scheme-9.2/src/microcode/bitstr.c"
SCHEME_OBJECT allocate_bit_string(unsigned long length ) 
{ 
  long total_pointers ;
  SCHEME_OBJECT result ;

  {
  {
#line 46
  total_pointers = (long )(1UL + (length + 63UL) / 64UL);
#line 47
  result = allocate_non_marked_vector(47U, (unsigned long )total_pointers, (_Bool)1);
#line 48
  *((SCHEME_OBJECT *)(result & 288230376151711743UL) + 1) = length;
  }
#line 49
  return (result);
}
}
#line 55 "/home/khheo/project/mit-scheme-9.2/src/microcode/bitstr.c"
SCHEME_OBJECT Prim_bit_string_allocate(void) 
{ 
  unsigned long tmp ;
  SCHEME_OBJECT tmp___0 ;

  {
  {
#line 57
  while (1) {
    while_continue: /* CIL Label */ ;
#line 57
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 58
  tmp = arg_ulong_integer(1);
#line 58
  tmp___0 = allocate_bit_string(tmp);
  }
#line 58
  return (tmp___0);
}
}
#line 64 "/home/khheo/project/mit-scheme-9.2/src/microcode/bitstr.c"
SCHEME_OBJECT Prim_bit_string_p(void) 
{ 
  unsigned long tmp ;

  {
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 66
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 67
  if (*(stack_pointer + 0) >> 58U == 47UL) {
#line 67
    tmp = 8UL << 58U;
  } else {
#line 67
    tmp = 0UL;
  }
#line 67
  return (tmp);
}
}
#line 70 "/home/khheo/project/mit-scheme-9.2/src/microcode/bitstr.c"
void fill_bit_string(SCHEME_OBJECT bit_string , int sense ) 
{ 
  SCHEME_OBJECT *scanner ;
  SCHEME_OBJECT filler ;
  long i ;
  int tmp ;

  {
#line 78
  if (sense) {
#line 78
    tmp = ~ 0;
  } else {
#line 78
    tmp = 0;
  }
#line 78
  filler = (SCHEME_OBJECT )tmp;
#line 79
  scanner = (SCHEME_OBJECT *)(bit_string & 288230376151711743UL) + ((*((SCHEME_OBJECT *)(bit_string & 288230376151711743UL) + 0) & 288230376151711743UL) + 1UL);
#line 80
  i = ((long )*((SCHEME_OBJECT *)(bit_string & 288230376151711743UL) + 1) + 63L) / 64L;
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
#line 80
    if (! (i > 0L)) {
#line 80
      goto while_break;
    }
#line 82
    scanner --;
#line 82
    *scanner = filler;
#line 80
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 83
  return;
}
}
#line 85 "/home/khheo/project/mit-scheme-9.2/src/microcode/bitstr.c"
void clear_bit_string(SCHEME_OBJECT bit_string ) 
{ 
  SCHEME_OBJECT *scanner ;
  long i ;

  {
#line 91
  scanner = (SCHEME_OBJECT *)(bit_string & 288230376151711743UL) + ((*((SCHEME_OBJECT *)(bit_string & 288230376151711743UL) + 0) & 288230376151711743UL) + 1UL);
#line 92
  i = ((long )*((SCHEME_OBJECT *)(bit_string & 288230376151711743UL) + 1) + 63L) / 64L;
  {
#line 92
  while (1) {
    while_continue: /* CIL Label */ ;
#line 92
    if (! (i > 0L)) {
#line 92
      goto while_break;
    }
#line 94
    scanner --;
#line 94
    *scanner = (SCHEME_OBJECT )0;
#line 92
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 95
  return;
}
}
#line 97 "/home/khheo/project/mit-scheme-9.2/src/microcode/bitstr.c"
SCHEME_OBJECT Prim_make_bit_string(void) 
{ 
  SCHEME_OBJECT result ;
  unsigned long tmp ;

  {
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
#line 103
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 104
  tmp = arg_ulong_integer(1);
#line 104
  result = allocate_bit_string(tmp);
#line 105
  fill_bit_string(result, *(stack_pointer + 1) != 0UL);
  }
#line 106
  return (result);
}
}
#line 109 "/home/khheo/project/mit-scheme-9.2/src/microcode/bitstr.c"
SCHEME_OBJECT Prim_bit_string_fill_x(void) 
{ 


  {
  {
#line 114
  while (1) {
    while_continue: /* CIL Label */ ;
#line 114
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 115
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 115
    if (! (*(stack_pointer + 0) >> 58U == 47UL)) {
      {
#line 115
      error_wrong_type_arg(1);
      }
    }
#line 115
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 116
  fill_bit_string(*(stack_pointer + 0), *(stack_pointer + 1) != 0UL);
  }
#line 117
  return ((8UL << 58U) | 1UL);
}
}
#line 122 "/home/khheo/project/mit-scheme-9.2/src/microcode/bitstr.c"
SCHEME_OBJECT Prim_bit_string_length(void) 
{ 


  {
  {
#line 126
  while (1) {
    while_continue: /* CIL Label */ ;
#line 126
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 127
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 127
    if (! (*(stack_pointer + 0) >> 58U == 47UL)) {
      {
#line 127
      error_wrong_type_arg(1);
      }
    }
#line 127
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 128
  return ((26UL << 58U) | (unsigned long )((long )*((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 1)));
}
}
#line 149 "/home/khheo/project/mit-scheme-9.2/src/microcode/bitstr.c"
SCHEME_OBJECT Prim_bit_string_ref(void) 
{ 
  SCHEME_OBJECT bit_string ;
  long index___0 ;
  SCHEME_OBJECT *ptr ;
  long mask ;
  unsigned long tmp ;

  {
  {
#line 153
  while (1) {
    while_continue: /* CIL Label */ ;
#line 153
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 153
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 153
    if (! (*(stack_pointer + 0) >> 58U == 47UL)) {
      {
#line 153
      error_wrong_type_arg(1);
      }
    }
#line 153
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 153
  bit_string = *(stack_pointer + 0);
#line 153
  index___0 = arg_nonnegative_integer(2);
  }
#line 153
  if (index___0 >= (long )*((SCHEME_OBJECT *)(bit_string & 288230376151711743UL) + 1)) {
    {
#line 153
    error_bad_range_arg(2);
    }
  }
#line 153
  ptr = (SCHEME_OBJECT *)(bit_string & 288230376151711743UL) + (3L + index___0 / 64L);
#line 153
  mask = 1L << index___0 % 64L;
#line 154
  if ((*(ptr - 1) & (unsigned long )mask) != 0UL) {
#line 154
    tmp = 8UL << 58U;
  } else {
#line 154
    tmp = 0UL;
  }
#line 154
  return (tmp);
}
}
#line 159 "/home/khheo/project/mit-scheme-9.2/src/microcode/bitstr.c"
SCHEME_OBJECT Prim_bit_string_clear_x(void) 
{ 
  SCHEME_OBJECT bit_string ;
  long index___0 ;
  SCHEME_OBJECT *ptr ;
  long mask ;

  {
  {
#line 163
  while (1) {
    while_continue: /* CIL Label */ ;
#line 163
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 163
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 163
    if (! (*(stack_pointer + 0) >> 58U == 47UL)) {
      {
#line 163
      error_wrong_type_arg(1);
      }
    }
#line 163
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 163
  bit_string = *(stack_pointer + 0);
#line 163
  index___0 = arg_nonnegative_integer(2);
  }
#line 163
  if (index___0 >= (long )*((SCHEME_OBJECT *)(bit_string & 288230376151711743UL) + 1)) {
    {
#line 163
    error_bad_range_arg(2);
    }
  }
#line 163
  ptr = (SCHEME_OBJECT *)(bit_string & 288230376151711743UL) + (3L + index___0 / 64L);
#line 163
  mask = 1L << index___0 % 64L;
#line 164
  if ((*(ptr - 1) & (unsigned long )mask) == 0UL) {
#line 165
    return (0UL);
  }
#line 166
  *(ptr - 1) &= (unsigned long )(~ mask);
#line 167
  return (8UL << 58U);
}
}
#line 170 "/home/khheo/project/mit-scheme-9.2/src/microcode/bitstr.c"
SCHEME_OBJECT Prim_bit_string_set_x(void) 
{ 
  SCHEME_OBJECT bit_string ;
  long index___0 ;
  SCHEME_OBJECT *ptr ;
  long mask ;

  {
  {
#line 174
  while (1) {
    while_continue: /* CIL Label */ ;
#line 174
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 174
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 174
    if (! (*(stack_pointer + 0) >> 58U == 47UL)) {
      {
#line 174
      error_wrong_type_arg(1);
      }
    }
#line 174
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 174
  bit_string = *(stack_pointer + 0);
#line 174
  index___0 = arg_nonnegative_integer(2);
  }
#line 174
  if (index___0 >= (long )*((SCHEME_OBJECT *)(bit_string & 288230376151711743UL) + 1)) {
    {
#line 174
    error_bad_range_arg(2);
    }
  }
#line 174
  ptr = (SCHEME_OBJECT *)(bit_string & 288230376151711743UL) + (3L + index___0 / 64L);
#line 174
  mask = 1L << index___0 % 64L;
#line 175
  if ((*(ptr - 1) & (unsigned long )mask) != 0UL) {
#line 176
    return (8UL << 58U);
  }
#line 177
  *(ptr - 1) |= (unsigned long )mask;
#line 178
  return (0UL);
}
}
#line 189 "/home/khheo/project/mit-scheme-9.2/src/microcode/bitstr.c"
SCHEME_OBJECT Prim_bit_string_zero_p(void) 
{ 
  SCHEME_OBJECT bit_string ;
  SCHEME_OBJECT *scan ;
  long i ;
  long length ;
  long odd_bits ;

  {
  {
#line 197
  while (1) {
    while_continue: /* CIL Label */ ;
#line 197
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 198
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 198
    if (! (*(stack_pointer + 0) >> 58U == 47UL)) {
      {
#line 198
      error_wrong_type_arg(1);
      }
    }
#line 198
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 199
  bit_string = *(stack_pointer + 0);
#line 200
  length = (long )*((SCHEME_OBJECT *)(bit_string & 288230376151711743UL) + 1);
#line 201
  odd_bits = length % 64L;
#line 202
  scan = (SCHEME_OBJECT *)(bit_string & 288230376151711743UL) + ((*((SCHEME_OBJECT *)(bit_string & 288230376151711743UL) + 0) & 288230376151711743UL) + 1UL);
#line 203
  if (odd_bits == 0L) {
#line 205
    i = length / 64L;
    {
#line 205
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 205
      if (! (i > 0L)) {
#line 205
        goto while_break___1;
      }
#line 205
      scan --;
#line 205
      if (*scan != 0UL) {
#line 205
        return (0UL);
      }
#line 205
      i --;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 205
    return (8UL << 58U);
  } else
#line 207
  if ((*(scan - 1) & (unsigned long )((1L << odd_bits) - 1L)) != 0UL) {
#line 208
    return (0UL);
  } else {
#line 211
    scan --;
#line 212
    i = length / 64L;
    {
#line 212
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 212
      if (! (i > 0L)) {
#line 212
        goto while_break___2;
      }
#line 212
      scan --;
#line 212
      if (*scan != 0UL) {
#line 212
        return (0UL);
      }
#line 212
      i --;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 212
    return (8UL << 58U);
  }
}
}
#line 225 "/home/khheo/project/mit-scheme-9.2/src/microcode/bitstr.c"
SCHEME_OBJECT Prim_bit_string_equal_p(void) 
{ 
  SCHEME_OBJECT bit_string_1 ;
  SCHEME_OBJECT bit_string_2 ;
  long length ;
  SCHEME_OBJECT *scan1 ;
  SCHEME_OBJECT *scan2 ;
  long i ;
  long odd_bits ;
  long mask ;

  {
  {
#line 234
  while (1) {
    while_continue: /* CIL Label */ ;
#line 234
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 235
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 235
    if (! (*(stack_pointer + 0) >> 58U == 47UL)) {
      {
#line 235
      error_wrong_type_arg(1);
      }
    }
#line 235
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 236
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 236
    if (! (*(stack_pointer + 1) >> 58U == 47UL)) {
      {
#line 236
      error_wrong_type_arg(2);
      }
    }
#line 236
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 237
  bit_string_1 = *(stack_pointer + 0);
#line 238
  bit_string_2 = *(stack_pointer + 1);
#line 239
  length = (long )*((SCHEME_OBJECT *)(bit_string_1 & 288230376151711743UL) + 1);
#line 240
  if (length != (long )*((SCHEME_OBJECT *)(bit_string_2 & 288230376151711743UL) + 1)) {
#line 241
    return (0UL);
  }
#line 242
  scan1 = (SCHEME_OBJECT *)(bit_string_1 & 288230376151711743UL) + ((*((SCHEME_OBJECT *)(bit_string_1 & 288230376151711743UL) + 0) & 288230376151711743UL) + 1UL);
#line 243
  scan2 = (SCHEME_OBJECT *)(bit_string_2 & 288230376151711743UL) + ((*((SCHEME_OBJECT *)(bit_string_2 & 288230376151711743UL) + 0) & 288230376151711743UL) + 1UL);
#line 244
  odd_bits = length % 64L;
#line 245
  if (odd_bits == 0L) {
#line 247
    i = length / 64L;
    {
#line 247
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 247
      if (! (i > 0L)) {
#line 247
        goto while_break___2;
      }
#line 247
      scan1 --;
#line 247
      scan2 --;
#line 247
      if (*scan1 != *scan2) {
#line 247
        return (0UL);
      }
#line 247
      i --;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 247
    return (8UL << 58U);
  } else {
#line 253
    mask = (1L << odd_bits) - 1L;
#line 254
    if ((*(((SCHEME_OBJECT *)(bit_string_1 & 288230376151711743UL) + ((*((SCHEME_OBJECT *)(bit_string_1 & 288230376151711743UL) + 0) & 288230376151711743UL) + 1UL)) - 1) & (unsigned long )mask) != (*(((SCHEME_OBJECT *)(bit_string_2 & 288230376151711743UL) + ((*((SCHEME_OBJECT *)(bit_string_2 & 288230376151711743UL) + 0) & 288230376151711743UL) + 1UL)) - 1) & (unsigned long )mask)) {
#line 256
      return (0UL);
    } else {
#line 259
      scan1 --;
#line 260
      scan2 --;
#line 261
      i = length / 64L;
      {
#line 261
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 261
        if (! (i > 0L)) {
#line 261
          goto while_break___3;
        }
#line 261
        scan1 --;
#line 261
        scan2 --;
#line 261
        if (*scan1 != *scan2) {
#line 261
          return (0UL);
        }
#line 261
        i --;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 261
      return (8UL << 58U);
    }
  }
}
}
#line 289 "/home/khheo/project/mit-scheme-9.2/src/microcode/bitstr.c"
SCHEME_OBJECT Prim_bit_string_move_x(void) 
{ 
  SCHEME_OBJECT bit_string_1 ;
  SCHEME_OBJECT bit_string_2 ;
  long i ;
  SCHEME_OBJECT *scan1 ;
  SCHEME_OBJECT *scan2 ;

  {
  {
#line 290
  while (1) {
    while_continue: /* CIL Label */ ;
#line 290
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 290
  bit_string_1 = *(stack_pointer + 0);
#line 290
  bit_string_2 = *(stack_pointer + 1);
#line 290
  if ((long )*((SCHEME_OBJECT *)(bit_string_1 & 288230376151711743UL) + 1) != (long )*((SCHEME_OBJECT *)(bit_string_2 & 288230376151711743UL) + 1)) {
    {
#line 290
    error_bad_range_arg(1);
    }
  }
#line 290
  scan1 = (SCHEME_OBJECT *)(bit_string_1 & 288230376151711743UL) + ((*((SCHEME_OBJECT *)(bit_string_1 & 288230376151711743UL) + 0) & 288230376151711743UL) + 1UL);
#line 290
  scan2 = (SCHEME_OBJECT *)(bit_string_2 & 288230376151711743UL) + ((*((SCHEME_OBJECT *)(bit_string_2 & 288230376151711743UL) + 0) & 288230376151711743UL) + 1UL);
#line 290
  i = (long )((*((SCHEME_OBJECT *)(bit_string_1 & 288230376151711743UL) + 0) & 288230376151711743UL) - 1UL);
  {
#line 290
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 290
    if (! (i > 0L)) {
#line 290
      goto while_break___0;
    }
#line 290
    scan1 --;
#line 290
    scan2 --;
#line 290
    *scan1 = *scan2;
#line 290
    i --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 290
  return ((8UL << 58U) | 1UL);
}
}
#line 292 "/home/khheo/project/mit-scheme-9.2/src/microcode/bitstr.c"
SCHEME_OBJECT Prim_bit_string_movec_x(void) 
{ 
  SCHEME_OBJECT bit_string_1 ;
  SCHEME_OBJECT bit_string_2 ;
  long i ;
  SCHEME_OBJECT *scan1 ;
  SCHEME_OBJECT *scan2 ;

  {
  {
#line 293
  while (1) {
    while_continue: /* CIL Label */ ;
#line 293
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 293
  bit_string_1 = *(stack_pointer + 0);
#line 293
  bit_string_2 = *(stack_pointer + 1);
#line 293
  if ((long )*((SCHEME_OBJECT *)(bit_string_1 & 288230376151711743UL) + 1) != (long )*((SCHEME_OBJECT *)(bit_string_2 & 288230376151711743UL) + 1)) {
    {
#line 293
    error_bad_range_arg(1);
    }
  }
#line 293
  scan1 = (SCHEME_OBJECT *)(bit_string_1 & 288230376151711743UL) + ((*((SCHEME_OBJECT *)(bit_string_1 & 288230376151711743UL) + 0) & 288230376151711743UL) + 1UL);
#line 293
  scan2 = (SCHEME_OBJECT *)(bit_string_2 & 288230376151711743UL) + ((*((SCHEME_OBJECT *)(bit_string_2 & 288230376151711743UL) + 0) & 288230376151711743UL) + 1UL);
#line 293
  i = (long )((*((SCHEME_OBJECT *)(bit_string_1 & 288230376151711743UL) + 0) & 288230376151711743UL) - 1UL);
  {
#line 293
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 293
    if (! (i > 0L)) {
#line 293
      goto while_break___0;
    }
#line 293
    scan1 --;
#line 293
    scan2 --;
#line 293
    *scan1 = ~ *scan2;
#line 293
    i --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 293
  return ((8UL << 58U) | 1UL);
}
}
#line 295 "/home/khheo/project/mit-scheme-9.2/src/microcode/bitstr.c"
SCHEME_OBJECT Prim_bit_string_or_x(void) 
{ 
  SCHEME_OBJECT bit_string_1 ;
  SCHEME_OBJECT bit_string_2 ;
  long i ;
  SCHEME_OBJECT *scan1 ;
  SCHEME_OBJECT *scan2 ;

  {
  {
#line 296
  while (1) {
    while_continue: /* CIL Label */ ;
#line 296
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 296
  bit_string_1 = *(stack_pointer + 0);
#line 296
  bit_string_2 = *(stack_pointer + 1);
#line 296
  if ((long )*((SCHEME_OBJECT *)(bit_string_1 & 288230376151711743UL) + 1) != (long )*((SCHEME_OBJECT *)(bit_string_2 & 288230376151711743UL) + 1)) {
    {
#line 296
    error_bad_range_arg(1);
    }
  }
#line 296
  scan1 = (SCHEME_OBJECT *)(bit_string_1 & 288230376151711743UL) + ((*((SCHEME_OBJECT *)(bit_string_1 & 288230376151711743UL) + 0) & 288230376151711743UL) + 1UL);
#line 296
  scan2 = (SCHEME_OBJECT *)(bit_string_2 & 288230376151711743UL) + ((*((SCHEME_OBJECT *)(bit_string_2 & 288230376151711743UL) + 0) & 288230376151711743UL) + 1UL);
#line 296
  i = (long )((*((SCHEME_OBJECT *)(bit_string_1 & 288230376151711743UL) + 0) & 288230376151711743UL) - 1UL);
  {
#line 296
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 296
    if (! (i > 0L)) {
#line 296
      goto while_break___0;
    }
#line 296
    scan1 --;
#line 296
    scan2 --;
#line 296
    *scan1 |= *scan2;
#line 296
    i --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 296
  return ((8UL << 58U) | 1UL);
}
}
#line 298 "/home/khheo/project/mit-scheme-9.2/src/microcode/bitstr.c"
SCHEME_OBJECT Prim_bit_string_and_x(void) 
{ 
  SCHEME_OBJECT bit_string_1 ;
  SCHEME_OBJECT bit_string_2 ;
  long i ;
  SCHEME_OBJECT *scan1 ;
  SCHEME_OBJECT *scan2 ;

  {
  {
#line 299
  while (1) {
    while_continue: /* CIL Label */ ;
#line 299
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 299
  bit_string_1 = *(stack_pointer + 0);
#line 299
  bit_string_2 = *(stack_pointer + 1);
#line 299
  if ((long )*((SCHEME_OBJECT *)(bit_string_1 & 288230376151711743UL) + 1) != (long )*((SCHEME_OBJECT *)(bit_string_2 & 288230376151711743UL) + 1)) {
    {
#line 299
    error_bad_range_arg(1);
    }
  }
#line 299
  scan1 = (SCHEME_OBJECT *)(bit_string_1 & 288230376151711743UL) + ((*((SCHEME_OBJECT *)(bit_string_1 & 288230376151711743UL) + 0) & 288230376151711743UL) + 1UL);
#line 299
  scan2 = (SCHEME_OBJECT *)(bit_string_2 & 288230376151711743UL) + ((*((SCHEME_OBJECT *)(bit_string_2 & 288230376151711743UL) + 0) & 288230376151711743UL) + 1UL);
#line 299
  i = (long )((*((SCHEME_OBJECT *)(bit_string_1 & 288230376151711743UL) + 0) & 288230376151711743UL) - 1UL);
  {
#line 299
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 299
    if (! (i > 0L)) {
#line 299
      goto while_break___0;
    }
#line 299
    scan1 --;
#line 299
    scan2 --;
#line 299
    *scan1 &= *scan2;
#line 299
    i --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 299
  return ((8UL << 58U) | 1UL);
}
}
#line 301 "/home/khheo/project/mit-scheme-9.2/src/microcode/bitstr.c"
SCHEME_OBJECT Prim_bit_string_andc_x(void) 
{ 
  SCHEME_OBJECT bit_string_1 ;
  SCHEME_OBJECT bit_string_2 ;
  long i ;
  SCHEME_OBJECT *scan1 ;
  SCHEME_OBJECT *scan2 ;

  {
  {
#line 302
  while (1) {
    while_continue: /* CIL Label */ ;
#line 302
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 302
  bit_string_1 = *(stack_pointer + 0);
#line 302
  bit_string_2 = *(stack_pointer + 1);
#line 302
  if ((long )*((SCHEME_OBJECT *)(bit_string_1 & 288230376151711743UL) + 1) != (long )*((SCHEME_OBJECT *)(bit_string_2 & 288230376151711743UL) + 1)) {
    {
#line 302
    error_bad_range_arg(1);
    }
  }
#line 302
  scan1 = (SCHEME_OBJECT *)(bit_string_1 & 288230376151711743UL) + ((*((SCHEME_OBJECT *)(bit_string_1 & 288230376151711743UL) + 0) & 288230376151711743UL) + 1UL);
#line 302
  scan2 = (SCHEME_OBJECT *)(bit_string_2 & 288230376151711743UL) + ((*((SCHEME_OBJECT *)(bit_string_2 & 288230376151711743UL) + 0) & 288230376151711743UL) + 1UL);
#line 302
  i = (long )((*((SCHEME_OBJECT *)(bit_string_1 & 288230376151711743UL) + 0) & 288230376151711743UL) - 1UL);
  {
#line 302
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 302
    if (! (i > 0L)) {
#line 302
      goto while_break___0;
    }
#line 302
    scan1 --;
#line 302
    scan2 --;
#line 302
    *scan1 &= ~ *scan2;
#line 302
    i --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 302
  return ((8UL << 58U) | 1UL);
}
}
#line 304 "/home/khheo/project/mit-scheme-9.2/src/microcode/bitstr.c"
SCHEME_OBJECT Prim_bit_string_xor_x(void) 
{ 
  SCHEME_OBJECT bit_string_1 ;
  SCHEME_OBJECT bit_string_2 ;
  long i ;
  SCHEME_OBJECT *scan1 ;
  SCHEME_OBJECT *scan2 ;

  {
  {
#line 305
  while (1) {
    while_continue: /* CIL Label */ ;
#line 305
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 305
  bit_string_1 = *(stack_pointer + 0);
#line 305
  bit_string_2 = *(stack_pointer + 1);
#line 305
  if ((long )*((SCHEME_OBJECT *)(bit_string_1 & 288230376151711743UL) + 1) != (long )*((SCHEME_OBJECT *)(bit_string_2 & 288230376151711743UL) + 1)) {
    {
#line 305
    error_bad_range_arg(1);
    }
  }
#line 305
  scan1 = (SCHEME_OBJECT *)(bit_string_1 & 288230376151711743UL) + ((*((SCHEME_OBJECT *)(bit_string_1 & 288230376151711743UL) + 0) & 288230376151711743UL) + 1UL);
#line 305
  scan2 = (SCHEME_OBJECT *)(bit_string_2 & 288230376151711743UL) + ((*((SCHEME_OBJECT *)(bit_string_2 & 288230376151711743UL) + 0) & 288230376151711743UL) + 1UL);
#line 305
  i = (long )((*((SCHEME_OBJECT *)(bit_string_1 & 288230376151711743UL) + 0) & 288230376151711743UL) - 1UL);
  {
#line 305
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 305
    if (! (i > 0L)) {
#line 305
      goto while_break___0;
    }
#line 305
    scan1 --;
#line 305
    scan2 --;
#line 305
    *scan1 ^= *scan2;
#line 305
    i --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 305
  return ((8UL << 58U) | 1UL);
}
}
#line 307 "/home/khheo/project/mit-scheme-9.2/src/microcode/bitstr.c"
SCHEME_OBJECT Prim_bit_substring_move_right_x(void) 
{ 
  SCHEME_OBJECT bit_string_1 ;
  SCHEME_OBJECT bit_string_2 ;
  long start1 ;
  long end1 ;
  long start2 ;
  long end2 ;
  long nbits ;
  long end1_mod ;
  long end2_mod ;
  long tmp ;
  long tmp___0 ;

  {
  {
#line 317
  while (1) {
    while_continue: /* CIL Label */ ;
#line 317
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 318
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 318
    if (! (*(stack_pointer + 0) >> 58U == 47UL)) {
      {
#line 318
      error_wrong_type_arg(1);
      }
    }
#line 318
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 319
  bit_string_1 = *(stack_pointer + 0);
#line 320
  start1 = arg_nonnegative_integer(2);
#line 321
  end1 = arg_nonnegative_integer(3);
  }
  {
#line 322
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 322
    if (! (*(stack_pointer + 3) >> 58U == 47UL)) {
      {
#line 322
      error_wrong_type_arg(4);
      }
    }
#line 322
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 323
  bit_string_2 = *(stack_pointer + 3);
#line 324
  start2 = arg_nonnegative_integer(5);
#line 325
  nbits = end1 - start1;
#line 326
  end2 = start2 + nbits;
  }
#line 327
  if (start1 < 0L) {
    {
#line 328
    error_bad_range_arg(2);
    }
  } else
#line 327
  if (start1 > end1) {
    {
#line 328
    error_bad_range_arg(2);
    }
  }
#line 329
  if (end1 > (long )*((SCHEME_OBJECT *)(bit_string_1 & 288230376151711743UL) + 1)) {
    {
#line 330
    error_bad_range_arg(3);
    }
  }
#line 331
  if (start2 < 0L) {
    {
#line 332
    error_bad_range_arg(5);
    }
  } else
#line 331
  if (end2 > (long )*((SCHEME_OBJECT *)(bit_string_2 & 288230376151711743UL) + 1)) {
    {
#line 332
    error_bad_range_arg(5);
    }
  }
#line 333
  end1_mod = end1 % 64L;
#line 334
  end2_mod = end2 % 64L;
#line 340
  if (end2_mod == 0L) {
#line 340
    tmp = 0L;
  } else {
#line 340
    tmp = 64L - end2_mod;
  }
#line 340
  if (end1_mod == 0L) {
#line 340
    tmp___0 = 0L;
  } else {
#line 340
    tmp___0 = 64L - end1_mod;
  }
  {
#line 340
  copy_bits((SCHEME_OBJECT *)(bit_string_1 & 288230376151711743UL) + (3L + (end1 - 1L) / 64L),
            tmp___0, (SCHEME_OBJECT *)(bit_string_2 & 288230376151711743UL) + (3L + (end2 - 1L) / 64L),
            tmp, nbits);
  }
#line 349
  return ((8UL << 58U) | 1UL);
}
}
#line 365 "/home/khheo/project/mit-scheme-9.2/src/microcode/bitstr.c"
static void copy_bits(SCHEME_OBJECT *source , long source_offset , SCHEME_OBJECT *destination ,
                      long destination_offset , long nbits ) 
{ 
  long head ;
  long mask ;
  long mask___0 ;
  SCHEME_OBJECT temp ;
  long mask___1 ;
  long offset1 ;
  long offset2 ;
  long head___0 ;
  long mask___2 ;
  long mask1 ;
  long mask2 ;
  long mask___3 ;
  SCHEME_OBJECT temp___0 ;
  long i ;
  long dest_tail ;
  long i___0 ;
  long j ;
  long offset1___0 ;
  long offset2___0 ;
  long head___1 ;
  long mask___4 ;
  long mask1___0 ;
  long dest_buffer ;
  unsigned long tmp ;
  long mask___5 ;

  {
#line 373
  if (nbits == 0L) {
#line 374
    return;
  }
#line 381
  if (source_offset == destination_offset) {
#line 383
    if (source_offset != 0L) {
#line 385
      head = 64L - source_offset;
#line 386
      if (nbits <= head) {
        {
#line 388
        while (1) {
          while_continue: /* CIL Label */ ;
#line 388
          mask = ((1L << nbits) - 1L) << (head - nbits);
#line 388
          *(destination - 1) = (*(source - 1) & (unsigned long )mask) | (*(destination - 1) & (unsigned long )(~ mask));
#line 388
          goto while_break;
        }
        while_break: /* CIL Label */ ;
        }
#line 389
        nbits = 0L;
      } else {
#line 393
        mask___0 = (1L << head) - 1L;
#line 394
        temp = *(destination - 1);
#line 395
        destination --;
#line 395
        source --;
#line 395
        *destination = (*source & (unsigned long )mask___0) | (temp & (unsigned long )(~ mask___0));
#line 398
        nbits -= head;
      }
    }
    {
#line 401
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 401
      if (! (nbits >= 64L)) {
#line 401
        goto while_break___0;
      }
#line 403
      destination --;
#line 403
      source --;
#line 403
      *destination = *source;
#line 405
      nbits -= 64L;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 407
    if (nbits > 0L) {
      {
#line 408
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 408
        mask___1 = ((1L << nbits) - 1L) << (64L - nbits);
#line 408
        *(destination - 1) = (*(source - 1) & (unsigned long )mask___1) | (*(destination - 1) & (unsigned long )(~ mask___1));
#line 408
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  } else
#line 411
  if (source_offset < destination_offset) {
#line 413
    offset1 = destination_offset - source_offset;
#line 414
    offset2 = 64L - offset1;
#line 415
    head___0 = 64L - destination_offset;
#line 416
    if (nbits <= head___0) {
#line 418
      mask___2 = ((1L << nbits) - 1L) << (head___0 - nbits);
#line 419
      *(destination - 1) = ((*(source - 1) >> offset1) & (unsigned long )mask___2) | (*(destination - 1) & (unsigned long )(~ mask___2));
    } else {
#line 425
      mask1 = (1L << offset1) - 1L;
#line 426
      mask2 = (1L << offset2) - 1L;
#line 428
      mask___3 = (1L << head___0) - 1L;
#line 429
      temp___0 = *(destination - 1);
#line 430
      destination --;
#line 430
      *destination = ((*(source - 1) >> offset1) & (unsigned long )mask___3) | (temp___0 & (unsigned long )(~ mask___3));
#line 434
      nbits -= head___0;
      {
#line 435
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 435
        if (! (nbits >= 64L)) {
#line 435
          goto while_break___2;
        }
#line 437
        source --;
#line 437
        i = (long )((*source & (unsigned long )mask1) << offset2);
#line 439
        destination --;
#line 439
        *destination = ((*(source - 1) >> offset1) & (unsigned long )mask2) | (unsigned long )i;
#line 441
        nbits -= 64L;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 443
      if (nbits > 0L) {
#line 445
        dest_tail = (long )(*(destination - 1) & (unsigned long )((1L << (64L - nbits)) - 1L));
#line 448
        if (nbits <= offset1) {
#line 449
          *(destination - 1) = ((*(source - 1) & (unsigned long )(((1L << nbits) - 1L) << (offset1 - nbits))) << offset2) | (unsigned long )dest_tail;
        } else {
#line 456
          source --;
#line 456
          i___0 = (long )((*source & (unsigned long )mask1) << offset2);
#line 458
          j = nbits - offset1;
#line 459
          *(destination - 1) = (((*(source - 1) & (unsigned long )(((1L << j) - 1L) << (64L - j))) >> offset1) | (unsigned long )i___0) | (unsigned long )dest_tail;
        }
      }
    }
  } else {
#line 473
    offset1___0 = source_offset - destination_offset;
#line 474
    offset2___0 = 64L - offset1___0;
#line 475
    head___1 = 64L - source_offset;
#line 476
    if (nbits <= head___1) {
#line 478
      mask___4 = ((1L << nbits) - 1L) << (offset1___0 + (head___1 - nbits));
#line 479
      *(destination - 1) = ((*(source - 1) << offset1___0) & (unsigned long )mask___4) | (*(destination - 1) & (unsigned long )(~ mask___4));
    } else {
#line 485
      mask1___0 = (1L << offset1___0) - 1L;
#line 486
      if (head___1 + offset1___0 < 64L) {
#line 486
        tmp = *(destination - 1) & (unsigned long )(~ ((1L << (head___1 + offset1___0)) - 1L));
      } else {
#line 486
        tmp = 0UL;
      }
#line 486
      dest_buffer = (long )tmp;
#line 491
      source --;
#line 491
      dest_buffer = (long )((unsigned long )dest_buffer | ((*source & (unsigned long )((1L << head___1) - 1L)) << offset1___0));
#line 494
      nbits -= head___1;
      {
#line 495
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 495
        if (! (nbits >= 64L)) {
#line 495
          goto while_break___3;
        }
#line 497
        destination --;
#line 497
        *destination = (unsigned long )dest_buffer | ((*(source - 1) >> offset2___0) & (unsigned long )mask1___0);
#line 500
        source --;
#line 500
        dest_buffer = (long )(*source << offset1___0);
#line 501
        nbits -= 64L;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 503
      if (nbits <= offset1___0) {
#line 504
        *(destination - 1) = ((unsigned long )dest_buffer | (*(destination - 1) & (unsigned long )((1L << (offset1___0 - nbits)) - 1L))) | ((*(source - 1) >> offset2___0) & (unsigned long )(((1L << nbits) - 1L) << (offset1___0 - nbits)));
      } else {
#line 512
        destination --;
#line 512
        *destination = (unsigned long )dest_buffer | ((*(source - 1) >> offset2___0) & (unsigned long )mask1___0);
#line 515
        nbits -= offset1___0;
#line 517
        mask___5 = (1L << (64L - nbits)) - 1L;
#line 518
        *(destination - 1) = (*(destination - 1) & (unsigned long )mask___5) | ((*(source - 1) << offset1___0) & (unsigned long )(~ mask___5));
      }
    }
  }
#line 525
  return;
}
}
#line 529 "/home/khheo/project/mit-scheme-9.2/src/microcode/bitstr.c"
static unsigned long ulong_significant_bits(unsigned long number ) 
{ 
  unsigned long limit ;
  unsigned int nbits ;

  {
#line 532
  limit = 1UL;
#line 533
  nbits = 1U;
  {
#line 534
  while (1) {
    while_continue: /* CIL Label */ ;
#line 536
    if (number <= limit) {
#line 537
      return ((unsigned long )nbits);
    }
#line 538
    limit = limit * 2UL + 1UL;
#line 539
    nbits ++;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 543 "/home/khheo/project/mit-scheme-9.2/src/microcode/bitstr.c"
static SCHEME_OBJECT zero_to_bit_string(unsigned long length ) 
{ 
  SCHEME_OBJECT result ;
  SCHEME_OBJECT tmp ;

  {
  {
#line 546
  tmp = allocate_bit_string(length);
#line 546
  result = tmp;
#line 547
  clear_bit_string(result);
  }
#line 548
  return (result);
}
}
#line 551 "/home/khheo/project/mit-scheme-9.2/src/microcode/bitstr.c"
static SCHEME_OBJECT ulong_to_bit_string(unsigned long length , unsigned long number ) 
{ 
  SCHEME_OBJECT tmp ;
  unsigned long tmp___0 ;
  SCHEME_OBJECT result ;
  SCHEME_OBJECT tmp___1 ;

  {
#line 554
  if (number == 0UL) {
    {
#line 555
    tmp = zero_to_bit_string(length);
    }
#line 555
    return (tmp);
  }
  {
#line 556
  tmp___0 = ulong_significant_bits(number);
  }
#line 556
  if (length < tmp___0) {
    {
#line 557
    error_bad_range_arg(2);
    }
  }
  {
#line 559
  tmp___1 = zero_to_bit_string(length);
#line 559
  result = tmp___1;
#line 560
  *(((SCHEME_OBJECT *)(result & 288230376151711743UL) + 3U) - 1) = number;
  }
#line 561
  return (result);
}
}
#line 565 "/home/khheo/project/mit-scheme-9.2/src/microcode/bitstr.c"
static void btbs_consumer(void *result_ptr , long digit ) 
{ 
  unsigned char *tmp ;

  {
#line 569
  tmp = *((unsigned char **)result_ptr);
#line 569
  (*((unsigned char **)result_ptr)) ++;
#line 569
  *tmp = (unsigned char )digit;
#line 571
  return;
}
}
#line 573 "/home/khheo/project/mit-scheme-9.2/src/microcode/bitstr.c"
static SCHEME_OBJECT bignum_to_bit_string(unsigned long length , SCHEME_OBJECT bignum ) 
{ 
  enum bignum_comparison tmp ;
  SCHEME_OBJECT tmp___0 ;
  int tmp___1 ;
  SCHEME_OBJECT result ;
  SCHEME_OBJECT tmp___2 ;
  unsigned char *result_ptr ;

  {
  {
#line 576
  tmp = bignum_test(bignum);
  }
  {
#line 578
  if ((unsigned int )tmp == 0U) {
#line 578
    goto case_0;
  }
#line 580
  if ((unsigned int )tmp == 1U) {
#line 580
    goto case_1;
  }
#line 582
  if ((unsigned int )tmp == 2U) {
#line 582
    goto case_2;
  }
#line 593
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 579
  tmp___0 = zero_to_bit_string(length);
  }
#line 579
  return (tmp___0);
  case_1: /* CIL Label */ 
  {
#line 581
  error_bad_range_arg(2);
  }
  case_2: /* CIL Label */ 
  {
#line 583
  tmp___1 = bignum_fits_in_word_p(bignum, (long )length, 0);
  }
#line 583
  if (! tmp___1) {
    {
#line 584
    error_bad_range_arg(2);
    }
  }
  {
#line 586
  tmp___2 = zero_to_bit_string(length);
#line 586
  result = tmp___2;
#line 587
  result_ptr = (unsigned char *)((SCHEME_OBJECT *)(result & 288230376151711743UL) + 2);
#line 589
  bignum_to_digit_stream(bignum, (unsigned int )(1L << 8), & btbs_consumer, (bignum_procedure_context )(& result_ptr));
  }
#line 591
  return (result);
  switch_default: /* CIL Label */ 
#line 595
  return ((SCHEME_OBJECT )0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 605 "/home/khheo/project/mit-scheme-9.2/src/microcode/bitstr.c"
static unsigned int bstb_producer(void *context ) 
{ 
  struct bitstr_to_bignm_context *c ;
  unsigned int result ;

  {
#line 608
  c = (struct bitstr_to_bignm_context *)context;
#line 609
  result = c->mask & (unsigned int )*(c->source_ptr - 1);
#line 610
  c->mask = (unsigned int )((1L << 8) - 1L);
#line 611
  (c->source_ptr) --;
#line 612
  return (result);
}
}
#line 615 "/home/khheo/project/mit-scheme-9.2/src/microcode/bitstr.c"
static SCHEME_OBJECT bit_string_to_bignum(unsigned long nbits , SCHEME_OBJECT bitstr ) 
{ 
  unsigned long ndigits ;
  struct bitstr_to_bignm_context context ;
  unsigned long skip ;
  bignum_type tmp ;

  {
#line 618
  ndigits = (nbits + 7UL) / 8UL;
#line 621
  context.mask = (unsigned int )((1L << ((nbits - 1UL) % 8UL + 1UL)) - 1L);
#line 622
  context.source_ptr = (unsigned char *)((SCHEME_OBJECT *)(bitstr & 288230376151711743UL) + (3UL + (nbits - 1UL) / 64UL));
#line 626
  if (ndigits != 0UL) {
#line 628
    skip = sizeof(SCHEME_OBJECT ) - ((ndigits - 1UL) % sizeof(SCHEME_OBJECT ) + 1UL);
    {
#line 633
    while (1) {
      while_continue: /* CIL Label */ ;
#line 633
      if (! (skip > 0UL)) {
#line 633
        goto while_break;
      }
#line 635
      (context.source_ptr) --;
#line 636
      skip --;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 640
  tmp = digit_stream_to_bignum((unsigned int )ndigits, & bstb_producer, (bignum_procedure_context )(& context),
                               (unsigned int )(1L << 8), 0);
  }
#line 640
  return (tmp);
}
}
#line 646 "/home/khheo/project/mit-scheme-9.2/src/microcode/bitstr.c"
SCHEME_OBJECT Prim_unsigned_to_bit_string(void) 
{ 
  unsigned long length ;
  SCHEME_OBJECT object ;
  SCHEME_OBJECT tmp ;
  SCHEME_OBJECT tmp___0 ;

  {
  {
#line 654
  while (1) {
    while_continue: /* CIL Label */ ;
#line 654
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 656
  length = arg_ulong_integer(1);
#line 657
  object = *(stack_pointer + 1);
  }
#line 658
  if (object >> 58U == 26UL) {
#line 660
    if (! (((object & 288230376151711743UL) & 0xfe00000000000000UL) == 0UL)) {
      {
#line 661
      error_bad_range_arg(2);
      }
    }
    {
#line 662
    tmp = ulong_to_bit_string(length, object & 288230376151711743UL);
    }
#line 662
    return (tmp);
  }
#line 665
  if (object >> 58U == 14UL) {
    {
#line 666
    tmp___0 = bignum_to_bit_string(length, object);
    }
#line 666
    return (tmp___0);
  }
  {
#line 667
  error_wrong_type_arg(2);
  }
#line 669
  return ((SCHEME_OBJECT )0);
}
}
#line 674 "/home/khheo/project/mit-scheme-9.2/src/microcode/bitstr.c"
SCHEME_OBJECT Prim_bit_string_to_unsigned(void) 
{ 
  SCHEME_OBJECT bit_string ;
  SCHEME_OBJECT *scan ;
  unsigned long nwords ;
  unsigned long nbits ;
  unsigned long word ;
  unsigned long tmp ;
  SCHEME_OBJECT tmp___0 ;
  unsigned long tmp___1 ;

  {
  {
#line 684
  while (1) {
    while_continue: /* CIL Label */ ;
#line 684
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 686
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 686
    if (! (*(stack_pointer + 0) >> 58U == 47UL)) {
      {
#line 686
      error_wrong_type_arg(1);
      }
    }
#line 686
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 687
  bit_string = *(stack_pointer + 0);
#line 689
  scan = (SCHEME_OBJECT *)(bit_string & 288230376151711743UL) + ((*((SCHEME_OBJECT *)(bit_string & 288230376151711743UL) + 0) & 288230376151711743UL) + 1UL);
#line 690
  nbits = (unsigned long )((long )*((SCHEME_OBJECT *)(bit_string & 288230376151711743UL) + 1) % 64L);
#line 691
  if (nbits > 0UL) {
#line 691
    scan --;
#line 691
    word = *scan & (unsigned long )((1L << nbits) - 1L);
  } else {
#line 691
    scan --;
#line 691
    word = *scan;
  }
#line 695
  nwords = (*((SCHEME_OBJECT *)(bit_string & 288230376151711743UL) + 0) & 288230376151711743UL) - 1UL;
  {
#line 695
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 695
    if (! (nwords > 0UL)) {
#line 695
      goto while_break___1;
    }
#line 697
    if (word != 0UL) {
#line 698
      goto while_break___1;
    }
#line 699
    scan --;
#line 699
    word = *scan;
#line 695
    nwords --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 701
  if (nwords == 0UL) {
#line 702
    return (26UL << 58U);
  }
  {
#line 703
  tmp = ulong_significant_bits(word);
#line 703
  nbits = (nwords - 1UL) * 64UL + tmp;
  }
#line 704
  if (nbits <= 57UL) {
#line 704
    tmp___1 = (26UL << 58U) | word;
  } else {
    {
#line 704
    tmp___0 = bit_string_to_bignum(nbits, bit_string);
#line 704
    tmp___1 = tmp___0;
    }
  }
#line 704
  return (tmp___1);
}
}
#line 724 "/home/khheo/project/mit-scheme-9.2/src/microcode/bitstr.c"
SCHEME_OBJECT Prim_read_bits_x(void) 
{ 
  SCHEME_OBJECT bit_string ;
  long end ;
  long end_mod ;
  long offset ;
  SCHEME_OBJECT *start ;
  long tmp ;

  {
  {
#line 728
  while (1) {
    while_continue: /* CIL Label */ ;
#line 728
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 728
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 728
    if (! (*(stack_pointer + 2) >> 58U == 47UL)) {
      {
#line 728
      error_wrong_type_arg(3);
      }
    }
#line 728
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 728
  bit_string = *(stack_pointer + 2);
#line 728
  end = (long )*((SCHEME_OBJECT *)(bit_string & 288230376151711743UL) + 1);
#line 728
  end_mod = end % 64L;
#line 728
  offset = arg_nonnegative_integer(2);
#line 728
  start = (SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + (((offset + end) - 1L) + 63L) / 64L;
#line 728
  offset = (offset + end) % 64L;
  }
#line 728
  if (offset != 0L) {
#line 728
    offset = 64L - offset;
  }
#line 729
  if (end_mod == 0L) {
#line 729
    tmp = 0L;
  } else {
#line 729
    tmp = 64L - end_mod;
  }
  {
#line 729
  copy_bits(start, offset, (SCHEME_OBJECT *)(bit_string & 288230376151711743UL) + (3L + (end - 1L) / 64L),
            tmp, end);
  }
#line 736
  return ((8UL << 58U) | 1UL);
}
}
#line 739 "/home/khheo/project/mit-scheme-9.2/src/microcode/bitstr.c"
SCHEME_OBJECT Prim_write_bits_x(void) 
{ 
  SCHEME_OBJECT bit_string ;
  long end ;
  long end_mod ;
  long offset ;
  SCHEME_OBJECT *start ;
  long tmp ;

  {
  {
#line 743
  while (1) {
    while_continue: /* CIL Label */ ;
#line 743
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 743
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 743
    if (! (*(stack_pointer + 2) >> 58U == 47UL)) {
      {
#line 743
      error_wrong_type_arg(3);
      }
    }
#line 743
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 743
  bit_string = *(stack_pointer + 2);
#line 743
  end = (long )*((SCHEME_OBJECT *)(bit_string & 288230376151711743UL) + 1);
#line 743
  end_mod = end % 64L;
#line 743
  offset = arg_nonnegative_integer(2);
#line 743
  start = (SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + (((offset + end) - 1L) + 63L) / 64L;
#line 743
  offset = (offset + end) % 64L;
  }
#line 743
  if (offset != 0L) {
#line 743
    offset = 64L - offset;
  }
#line 744
  if (end_mod == 0L) {
#line 744
    tmp = 0L;
  } else {
#line 744
    tmp = 64L - end_mod;
  }
  {
#line 744
  copy_bits((SCHEME_OBJECT *)(bit_string & 288230376151711743UL) + (3L + (end - 1L) / 64L),
            tmp, start, offset, end);
  }
#line 751
  return ((8UL << 58U) | 1UL);
}
}
#line 794 "/home/khheo/project/mit-scheme-9.2/src/microcode/bitstr.c"
SCHEME_OBJECT Prim_bitstr_find_next_set_bit(void) 
{ 
  SCHEME_OBJECT bit_string ;
  long start ;
  long end ;
  long word ;
  long bit ;
  long end_word ;
  long end_bit ;
  long mask ;
  SCHEME_OBJECT *scan ;
  long tmp ;
  SCHEME_OBJECT *tmp___0 ;
  SCHEME_OBJECT *tmp___1 ;
  long tmp___2 ;

  {
  {
#line 797
  while (1) {
    while_continue: /* CIL Label */ ;
#line 797
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 797
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 797
    if (! (*(stack_pointer + 0) >> 58U == 47UL)) {
      {
#line 797
      error_wrong_type_arg(1);
      }
    }
#line 797
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 797
  bit_string = *(stack_pointer + 0);
#line 797
  start = arg_nonnegative_integer(2);
#line 797
  end = arg_nonnegative_integer(3);
  }
#line 797
  if (end > (long )*((SCHEME_OBJECT *)(bit_string & 288230376151711743UL) + 1)) {
    {
#line 797
    error_bad_range_arg(3);
    }
  }
#line 797
  if (start > end) {
    {
#line 797
    error_bad_range_arg(2);
    }
  }
#line 797
  if (start == end) {
#line 797
    return (0UL);
  }
#line 797
  word = 3L + start / 64L;
#line 797
  bit = start % 64L;
#line 797
  end_word = 3L + (end - 1L) / 64L;
#line 797
  end_bit = (end - 1L) % 64L + 1L;
#line 797
  scan = (SCHEME_OBJECT *)(bit_string & 288230376151711743UL) + word;
#line 798
  if (word == end_word) {
#line 800
    if (end_bit - bit == 64L) {
#line 800
      if (*(scan - 1) != 0UL) {
#line 800
        goto _L;
      } else {
#line 800
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 800
    if ((*(scan - 1) & (unsigned long )(((1L << (end_bit - bit)) - 1L) << bit)) != 0UL) {
      _L: /* CIL Label */ 
#line 805
      bit = bit;
#line 805
      mask = 1L << bit;
      {
#line 805
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 805
        if ((*(scan - 1) & (unsigned long )mask) != 0UL) {
#line 805
          goto win;
        }
#line 805
        bit ++;
#line 805
        mask <<= 1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 807
    return (0UL);
  } else {
#line 809
    if (bit == 0L) {
#line 809
      tmp = (long )(~ 0);
    } else {
#line 809
      tmp = ((1L << (64L - bit)) - 1L) << bit;
    }
#line 809
    if ((*(scan - 1) & (unsigned long )tmp) != 0UL) {
#line 813
      bit = bit;
#line 813
      mask = 1L << bit;
      {
#line 813
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 813
        if ((*(scan - 1) & (unsigned long )mask) != 0UL) {
#line 813
          goto win;
        }
#line 813
        bit ++;
#line 813
        mask <<= 1;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
  }
#line 815
  word ++;
  {
#line 816
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 816
    if (! (word != end_word)) {
#line 816
      goto while_break___3;
    }
#line 818
    tmp___0 = scan;
#line 818
    scan ++;
#line 818
    if (*tmp___0 != 0UL) {
#line 820
      bit = 0L;
#line 820
      mask = 1L;
      {
#line 820
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 820
        if ((*(scan - 1) & (unsigned long )mask) != 0UL) {
#line 820
          goto win;
        }
#line 820
        bit ++;
#line 820
        mask <<= 1;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
#line 822
    word ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 824
  tmp___1 = scan;
#line 824
  scan ++;
#line 824
  if (end_bit == 64L) {
#line 824
    tmp___2 = (long )(~ 0);
  } else {
#line 824
    tmp___2 = (1L << end_bit) - 1L;
  }
#line 824
  if ((*tmp___1 & (unsigned long )tmp___2) != 0UL) {
#line 828
    bit = 0L;
#line 828
    mask = 1L;
    {
#line 828
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 828
      if ((*(scan - 1) & (unsigned long )mask) != 0UL) {
#line 828
        goto win;
      }
#line 828
      bit ++;
#line 828
      mask <<= 1;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
#line 830
  return (0UL);
  win: 
#line 832
  return ((26UL << 58U) | (unsigned long )((word - 3L) * 64L + bit));
}
}
#line 837 "/home/khheo/project/mit-scheme-9.2/src/microcode/bitstr.c"
void bit_string_set(SCHEME_OBJECT bitstr , long index___0 , int value ) 
{ 
  unsigned long mask ;
  SCHEME_OBJECT *ptr ;

  {
#line 843
  ptr = (SCHEME_OBJECT *)(bitstr & 288230376151711743UL) + (3L + index___0 / 64L);
#line 844
  mask = (unsigned long )(1L << index___0 % 64L);
#line 845
  if (value == 0) {
#line 846
    *(ptr - 1) &= ~ mask;
  } else {
#line 848
    *(ptr - 1) |= mask;
  }
#line 849
  return;
}
}
#line 224 "/home/khheo/project/mit-scheme-9.2/src/microcode/extern.h"
SCHEME_OBJECT bignum_to_fixnum(SCHEME_OBJECT bignum ) ;
#line 226
SCHEME_OBJECT bignum_to_flonum(SCHEME_OBJECT bignum ) ;
#line 52 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.h"
int bignum_equal_p(bignum_type x , bignum_type y ) ;
#line 54
enum bignum_comparison bignum_compare(bignum_type x , bignum_type y ) ;
#line 56
bignum_type bignum_add(bignum_type x , bignum_type y ) ;
#line 57
bignum_type bignum_subtract(bignum_type x , bignum_type y ) ;
#line 59
bignum_type bignum_multiply(bignum_type x , bignum_type y ) ;
#line 60
int bignum_divide(bignum_type numerator , bignum_type denominator , bignum_type *quotient ,
                  bignum_type *remainder___0 ) ;
#line 65
bignum_type bignum_quotient(bignum_type numerator , bignum_type denominator ) ;
#line 66
bignum_type bignum_remainder(bignum_type numerator , bignum_type denominator ) ;
#line 75
bignum_type double_to_bignum(double x ) ;
#line 78
unsigned long bignum_length_in_bits(bignum_type bignum ) ;
#line 39 "/home/khheo/project/mit-scheme-9.2/src/microcode/bigprm.c"
SCHEME_OBJECT Prim_bignum_zero_p(void) 
{ 
  unsigned long tmp___0 ;
  enum bignum_comparison tmp___1 ;

  {
  {
#line 40
  while (1) {
    while_continue: /* CIL Label */ ;
#line 40
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 40
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 40
    if (! (*(stack_pointer + 0) >> 58U == 14UL)) {
      {
#line 40
      error_wrong_type_arg(1);
      }
    }
#line 40
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 40
  tmp___1 = bignum_test(*(stack_pointer + 0));
  }
#line 40
  if ((unsigned int )tmp___1 == 0U) {
#line 40
    tmp___0 = 8UL << 58U;
  } else {
#line 40
    tmp___0 = 0UL;
  }
#line 40
  return (tmp___0);
}
}
#line 41 "/home/khheo/project/mit-scheme-9.2/src/microcode/bigprm.c"
SCHEME_OBJECT Prim_bignum_negative_p(void) 
{ 
  unsigned long tmp___0 ;
  enum bignum_comparison tmp___1 ;

  {
  {
#line 42
  while (1) {
    while_continue: /* CIL Label */ ;
#line 42
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 42
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 42
    if (! (*(stack_pointer + 0) >> 58U == 14UL)) {
      {
#line 42
      error_wrong_type_arg(1);
      }
    }
#line 42
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 42
  tmp___1 = bignum_test(*(stack_pointer + 0));
  }
#line 42
  if ((unsigned int )tmp___1 == 1U) {
#line 42
    tmp___0 = 8UL << 58U;
  } else {
#line 42
    tmp___0 = 0UL;
  }
#line 42
  return (tmp___0);
}
}
#line 43 "/home/khheo/project/mit-scheme-9.2/src/microcode/bigprm.c"
SCHEME_OBJECT Prim_bignum_positive_p(void) 
{ 
  unsigned long tmp___0 ;
  enum bignum_comparison tmp___1 ;

  {
  {
#line 44
  while (1) {
    while_continue: /* CIL Label */ ;
#line 44
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 44
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 44
    if (! (*(stack_pointer + 0) >> 58U == 14UL)) {
      {
#line 44
      error_wrong_type_arg(1);
      }
    }
#line 44
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 44
  tmp___1 = bignum_test(*(stack_pointer + 0));
  }
#line 44
  if ((unsigned int )tmp___1 == 2U) {
#line 44
    tmp___0 = 8UL << 58U;
  } else {
#line 44
    tmp___0 = 0UL;
  }
#line 44
  return (tmp___0);
}
}
#line 55 "/home/khheo/project/mit-scheme-9.2/src/microcode/bigprm.c"
SCHEME_OBJECT Prim_bignum_equal_p(void) 
{ 
  unsigned long tmp___0 ;
  int tmp___1 ;

  {
  {
#line 56
  while (1) {
    while_continue: /* CIL Label */ ;
#line 56
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 56
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 56
    if (! (*(stack_pointer + 0) >> 58U == 14UL)) {
      {
#line 56
      error_wrong_type_arg(1);
      }
    }
#line 56
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 56
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 56
    if (! (*(stack_pointer + 1) >> 58U == 14UL)) {
      {
#line 56
      error_wrong_type_arg(2);
      }
    }
#line 56
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 56
  tmp___1 = bignum_equal_p(*(stack_pointer + 0), *(stack_pointer + 1));
  }
#line 56
  if (tmp___1) {
#line 56
    tmp___0 = 8UL << 58U;
  } else {
#line 56
    tmp___0 = 0UL;
  }
#line 56
  return (tmp___0);
}
}
#line 57 "/home/khheo/project/mit-scheme-9.2/src/microcode/bigprm.c"
SCHEME_OBJECT Prim_bignum_less_p(void) 
{ 
  unsigned long tmp___0 ;
  enum bignum_comparison tmp___1 ;

  {
  {
#line 58
  while (1) {
    while_continue: /* CIL Label */ ;
#line 58
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 58
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 58
    if (! (*(stack_pointer + 0) >> 58U == 14UL)) {
      {
#line 58
      error_wrong_type_arg(1);
      }
    }
#line 58
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 58
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 58
    if (! (*(stack_pointer + 1) >> 58U == 14UL)) {
      {
#line 58
      error_wrong_type_arg(2);
      }
    }
#line 58
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 58
  tmp___1 = bignum_compare(*(stack_pointer + 0), *(stack_pointer + 1));
  }
#line 58
  if ((unsigned int )tmp___1 == 1U) {
#line 58
    tmp___0 = 8UL << 58U;
  } else {
#line 58
    tmp___0 = 0UL;
  }
#line 58
  return (tmp___0);
}
}
#line 68 "/home/khheo/project/mit-scheme-9.2/src/microcode/bigprm.c"
SCHEME_OBJECT Prim_bignum_add(void) 
{ 
  bignum_type tmp ;

  {
  {
#line 69
  while (1) {
    while_continue: /* CIL Label */ ;
#line 69
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 69
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 69
    if (! (*(stack_pointer + 0) >> 58U == 14UL)) {
      {
#line 69
      error_wrong_type_arg(1);
      }
    }
#line 69
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 69
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 69
    if (! (*(stack_pointer + 1) >> 58U == 14UL)) {
      {
#line 69
      error_wrong_type_arg(2);
      }
    }
#line 69
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 69
  tmp = bignum_add(*(stack_pointer + 0), *(stack_pointer + 1));
  }
#line 69
  return (tmp);
}
}
#line 70 "/home/khheo/project/mit-scheme-9.2/src/microcode/bigprm.c"
SCHEME_OBJECT Prim_bignum_subtract(void) 
{ 
  bignum_type tmp ;

  {
  {
#line 71
  while (1) {
    while_continue: /* CIL Label */ ;
#line 71
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 71
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 71
    if (! (*(stack_pointer + 0) >> 58U == 14UL)) {
      {
#line 71
      error_wrong_type_arg(1);
      }
    }
#line 71
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 71
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 71
    if (! (*(stack_pointer + 1) >> 58U == 14UL)) {
      {
#line 71
      error_wrong_type_arg(2);
      }
    }
#line 71
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 71
  tmp = bignum_subtract(*(stack_pointer + 0), *(stack_pointer + 1));
  }
#line 71
  return (tmp);
}
}
#line 72 "/home/khheo/project/mit-scheme-9.2/src/microcode/bigprm.c"
SCHEME_OBJECT Prim_bignum_multiply(void) 
{ 
  bignum_type tmp ;

  {
  {
#line 73
  while (1) {
    while_continue: /* CIL Label */ ;
#line 73
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 73
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 73
    if (! (*(stack_pointer + 0) >> 58U == 14UL)) {
      {
#line 73
      error_wrong_type_arg(1);
      }
    }
#line 73
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 73
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 73
    if (! (*(stack_pointer + 1) >> 58U == 14UL)) {
      {
#line 73
      error_wrong_type_arg(2);
      }
    }
#line 73
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 73
  tmp = bignum_multiply(*(stack_pointer + 0), *(stack_pointer + 1));
  }
#line 73
  return (tmp);
}
}
#line 75 "/home/khheo/project/mit-scheme-9.2/src/microcode/bigprm.c"
SCHEME_OBJECT Prim_bignum_divide(void) 
{ 
  SCHEME_OBJECT quotient ;
  SCHEME_OBJECT remainder___0 ;
  int tmp ;
  SCHEME_OBJECT tmp___0 ;

  {
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
#line 79
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 80
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 80
    if (! (*(stack_pointer + 0) >> 58U == 14UL)) {
      {
#line 80
      error_wrong_type_arg(1);
      }
    }
#line 80
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 81
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 81
    if (! (*(stack_pointer + 1) >> 58U == 14UL)) {
      {
#line 81
      error_wrong_type_arg(2);
      }
    }
#line 81
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 82
  tmp = bignum_divide(*(stack_pointer + 0), *(stack_pointer + 1), & quotient, & remainder___0);
  }
#line 82
  if (tmp) {
    {
#line 83
    error_bad_range_arg(2);
    }
  }
  {
#line 84
  tmp___0 = cons(quotient, remainder___0);
  }
#line 84
  return (tmp___0);
}
}
#line 99 "/home/khheo/project/mit-scheme-9.2/src/microcode/bigprm.c"
SCHEME_OBJECT Prim_bignum_quotient(void) 
{ 
  SCHEME_OBJECT result ;

  {
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 100
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 100
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 100
    if (! (*(stack_pointer + 0) >> 58U == 14UL)) {
      {
#line 100
      error_wrong_type_arg(1);
      }
    }
#line 100
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 100
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 100
    if (! (*(stack_pointer + 1) >> 58U == 14UL)) {
      {
#line 100
      error_wrong_type_arg(2);
      }
    }
#line 100
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 100
  result = bignum_quotient(*(stack_pointer + 0), *(stack_pointer + 1));
  }
#line 100
  if (result == 0UL) {
    {
#line 100
    error_bad_range_arg(2);
    }
  }
#line 100
  return (result);
}
}
#line 101 "/home/khheo/project/mit-scheme-9.2/src/microcode/bigprm.c"
SCHEME_OBJECT Prim_bignum_remainder(void) 
{ 
  SCHEME_OBJECT result ;

  {
  {
#line 102
  while (1) {
    while_continue: /* CIL Label */ ;
#line 102
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 102
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 102
    if (! (*(stack_pointer + 0) >> 58U == 14UL)) {
      {
#line 102
      error_wrong_type_arg(1);
      }
    }
#line 102
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 102
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 102
    if (! (*(stack_pointer + 1) >> 58U == 14UL)) {
      {
#line 102
      error_wrong_type_arg(2);
      }
    }
#line 102
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 102
  result = bignum_remainder(*(stack_pointer + 0), *(stack_pointer + 1));
  }
#line 102
  if (result == 0UL) {
    {
#line 102
    error_bad_range_arg(2);
    }
  }
#line 102
  return (result);
}
}
#line 104 "/home/khheo/project/mit-scheme-9.2/src/microcode/bigprm.c"
static void listify_bignum_consumer(void *previous_cdr , long digit ) 
{ 


  {
  {
#line 108
  *((SCHEME_OBJECT *)previous_cdr) = cons((26UL << 58U) | (unsigned long )digit, *((SCHEME_OBJECT *)previous_cdr));
  }
#line 111
  return;
}
}
#line 113 "/home/khheo/project/mit-scheme-9.2/src/microcode/bigprm.c"
SCHEME_OBJECT Prim_listify_bignum(void) 
{ 
  SCHEME_OBJECT bignum ;
  long radix ;
  long tmp ;
  long tmp___0 ;
  SCHEME_OBJECT tmp___1 ;
  enum bignum_comparison tmp___2 ;
  SCHEME_OBJECT previous_cdr ;

  {
  {
#line 116
  while (1) {
    while_continue: /* CIL Label */ ;
#line 116
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 117
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 117
    if (! (*(stack_pointer + 0) >> 58U == 14UL)) {
      {
#line 117
      error_wrong_type_arg(1);
      }
    }
#line 117
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 119
  bignum = *(stack_pointer + 0);
#line 120
  tmp = bignum_max_digit_stream_radix();
#line 120
  tmp___0 = arg_integer_in_range(2, 2L, tmp);
#line 120
  radix = tmp___0;
#line 122
  tmp___2 = bignum_test(bignum);
  }
#line 122
  if ((unsigned int )tmp___2 == 0U) {
    {
#line 123
    tmp___1 = cons(26UL << 58U, (8UL << 58U) | 9UL);
    }
#line 123
    return (tmp___1);
  }
  {
#line 125
  previous_cdr = (8UL << 58U) | 9UL;
#line 126
  bignum_to_digit_stream(bignum, (unsigned int )radix, & listify_bignum_consumer,
                         (bignum_procedure_context )(& previous_cdr));
  }
#line 128
  return (previous_cdr);
}
}
#line 133 "/home/khheo/project/mit-scheme-9.2/src/microcode/bigprm.c"
SCHEME_OBJECT Prim_fixnum_to_bignum(void) 
{ 
  bignum_type tmp ;

  {
  {
#line 135
  while (1) {
    while_continue: /* CIL Label */ ;
#line 135
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 136
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 136
    if (! (*(stack_pointer + 0) >> 58U == 26UL)) {
      {
#line 136
      error_wrong_type_arg(1);
      }
    }
#line 136
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 137
  tmp = long_to_bignum((long )((*(stack_pointer + 0) ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL)));
  }
#line 137
  return (tmp);
}
}
#line 140 "/home/khheo/project/mit-scheme-9.2/src/microcode/bigprm.c"
SCHEME_OBJECT Prim_bignum_to_fixnum(void) 
{ 
  SCHEME_OBJECT tmp ;

  {
  {
#line 142
  while (1) {
    while_continue: /* CIL Label */ ;
#line 142
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 143
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 143
    if (! (*(stack_pointer + 0) >> 58U == 14UL)) {
      {
#line 143
      error_wrong_type_arg(1);
      }
    }
#line 143
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 144
  tmp = bignum_to_fixnum(*(stack_pointer + 0));
  }
#line 144
  return (tmp);
}
}
#line 147 "/home/khheo/project/mit-scheme-9.2/src/microcode/bigprm.c"
SCHEME_OBJECT Prim_flonum_to_bignum(void) 
{ 
  _Bool tmp ;
  bignum_type tmp___0 ;

  {
  {
#line 149
  while (1) {
    while_continue: /* CIL Label */ ;
#line 149
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 150
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 150
    tmp = finite_flonum_p(*(stack_pointer + 0));
    }
#line 150
    if (! tmp) {
      {
#line 150
      error_wrong_type_arg(1);
      }
    }
#line 150
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 151
  tmp___0 = double_to_bignum(*((double *)((SCHEME_OBJECT *)(*(stack_pointer + 0) & 288230376151711743UL) + 1)));
  }
#line 151
  return (tmp___0);
}
}
#line 154 "/home/khheo/project/mit-scheme-9.2/src/microcode/bigprm.c"
SCHEME_OBJECT Prim_bignum_to_flonum(void) 
{ 
  SCHEME_OBJECT tmp ;

  {
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
#line 156
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 157
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 157
    if (! (*(stack_pointer + 0) >> 58U == 14UL)) {
      {
#line 157
      error_wrong_type_arg(1);
      }
    }
#line 157
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 158
  tmp = bignum_to_flonum(*(stack_pointer + 0));
  }
#line 158
  return (tmp);
}
}
#line 161 "/home/khheo/project/mit-scheme-9.2/src/microcode/bigprm.c"
SCHEME_OBJECT Prim_bignum_length_in_bits(void) 
{ 
  unsigned long tmp ;

  {
  {
#line 163
  while (1) {
    while_continue: /* CIL Label */ ;
#line 163
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 164
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 164
    if (! (*(stack_pointer + 0) >> 58U == 14UL)) {
      {
#line 164
      error_wrong_type_arg(1);
      }
    }
#line 164
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 165
  tmp = bignum_length_in_bits(*(stack_pointer + 0));
  }
#line 165
  return (tmp);
}
}
#line 103 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) frexp)(double __x ,
                                                                               int *__exponent ) ;
#line 106
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) ldexp)(double __x ,
                                                                               int __exponent ) ;
#line 50 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.h"
bignum_type bignum_make_zero(void) ;
#line 51
bignum_type bignum_make_one(int negative_p ) ;
#line 58
bignum_type bignum_negate(bignum_type x ) ;
#line 68
bignum_type ulong_to_bignum(unsigned long n ) ;
#line 69
long bignum_to_long(bignum_type bignum ) ;
#line 70
unsigned long bignum_to_ulong(bignum_type bignum ) ;
#line 71
bignum_type intmax_to_bignum(intmax_t n ) ;
#line 72
bignum_type uintmax_to_bignum(uintmax_t n ) ;
#line 73
intmax_t bignum_to_intmax(bignum_type bignum ) ;
#line 74
uintmax_t bignum_to_uintmax(bignum_type bignum ) ;
#line 79
unsigned long bignum_integer_length(bignum_type bignum ) ;
#line 80
long bignum_first_set_bit(bignum_type bignum ) ;
#line 81
unsigned long bignum_bit_count(bignum_type x ) ;
#line 82
long bignum_hamming_distance(bignum_type x , bignum_type y ) ;
#line 83
bignum_type bignum_bitwise_not(bignum_type bignum ) ;
#line 84
bignum_type bignum_bitwise_and(bignum_type x , bignum_type y ) ;
#line 85
bignum_type bignum_bitwise_andc2(bignum_type x , bignum_type y ) ;
#line 86
bignum_type bignum_bitwise_andc1(bignum_type x , bignum_type y ) ;
#line 87
bignum_type bignum_bitwise_xor(bignum_type x , bignum_type y ) ;
#line 88
bignum_type bignum_bitwise_ior(bignum_type x , bignum_type y ) ;
#line 89
bignum_type bignum_bitwise_nor(bignum_type x , bignum_type y ) ;
#line 90
bignum_type bignum_bitwise_eqv(bignum_type x , bignum_type y ) ;
#line 91
bignum_type bignum_bitwise_orc2(bignum_type x , bignum_type y ) ;
#line 92
bignum_type bignum_bitwise_orc1(bignum_type x , bignum_type y ) ;
#line 93
bignum_type bignum_bitwise_nand(bignum_type x , bignum_type y ) ;
#line 104
bignum_type bignum_nonnegative_one_bits(unsigned long size , unsigned long position___1 ) ;
#line 105
bignum_type bignum_negative_zero_bits(unsigned long n , unsigned long m ) ;
#line 106
bignum_type bignum_shift_right(bignum_type n , unsigned long m ) ;
#line 107
bignum_type bignum_shift_left(bignum_type n , unsigned long m ) ;
#line 108
bignum_type unsigned_long_to_shifted_bignum(unsigned long n , unsigned long m , int sign ) ;
#line 77 "/home/khheo/project/mit-scheme-9.2/src/microcode/bits.h"
__inline static unsigned int ulong_bit_count(unsigned long x ) 
{ 
  unsigned long two_bit_mask ;
  unsigned long four_bit_mask ;
  unsigned long eight_bit_mask ;
  unsigned long final_mask ;
  int i ;

  {
#line 77
  two_bit_mask = 0xffffffffffffffffUL / (unsigned long )(1 + (1 << 1));
#line 77
  four_bit_mask = 0xffffffffffffffffUL / (unsigned long )(1 + (1 << 2));
#line 77
  eight_bit_mask = 0xffffffffffffffffUL / (unsigned long )(1 + (1 << 4));
#line 77
  final_mask = (8UL * sizeof(unsigned long ) << 1) - 1UL;
#line 77
  x -= (x >> 1) & two_bit_mask;
#line 77
  x = ((x >> 2) & four_bit_mask) + (x & four_bit_mask);
#line 77
  x = ((x >> 4) + x) & eight_bit_mask;
#line 77
  i = 8;
  {
#line 77
  while (1) {
    while_continue: /* CIL Label */ ;
#line 77
    if (! ((unsigned long )i < 8UL * sizeof(unsigned long ))) {
#line 77
      goto while_break;
    }
#line 77
    x += x >> i;
#line 77
    i <<= 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 77
  return ((unsigned int )(x & final_mask));
}
}
#line 101 "/home/khheo/project/mit-scheme-9.2/src/microcode/bits.h"
__inline static unsigned int ulong_length_in_bits(unsigned long x ) 
{ 
  int i ;
  int limit ;
  unsigned int tmp ;

  {
#line 101
  limit = (int )(8UL * sizeof(unsigned long ));
#line 101
  if (1 < limit) {
#line 101
    x |= x >> 1;
  }
#line 101
  if (2 < limit) {
#line 101
    x |= x >> 2;
  }
#line 101
  if (4 < limit) {
#line 101
    x |= x >> 4;
  }
#line 101
  if (8 < limit) {
#line 101
    x |= x >> 8;
  }
#line 101
  if (16 < limit) {
#line 101
    x |= x >> 16;
  }
#line 101
  if (32 < limit) {
#line 101
    x |= x >> 32;
  }
#line 101
  i = 64;
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;
#line 101
    if (! (i < limit)) {
#line 101
      goto while_break;
    }
#line 101
    x |= x >> i;
#line 101
    i <<= 1;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 101
  tmp = ulong_bit_count(x);
  }
#line 101
  return (tmp);
}
}
#line 63 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
static int bignum_equal_p_unsigned(bignum_type x , bignum_type y ) ;
#line 64
static enum bignum_comparison bignum_compare_unsigned(bignum_type x , bignum_type y ) ;
#line 66
static bignum_type bignum_add_unsigned(bignum_type x , bignum_type y , int negative_p ) ;
#line 67
static bignum_type bignum_subtract_unsigned(bignum_type x , bignum_type y ) ;
#line 68
static bignum_type bignum_multiply_unsigned(bignum_type x , bignum_type y , int negative_p ) ;
#line 69
static bignum_type bignum_multiply_unsigned_small_factor(bignum_type x , bignum_digit_type y ,
                                                         int negative_p ) ;
#line 71
static void bignum_destructive_scale_up(bignum_type bignum , bignum_digit_type factor ) ;
#line 72
static void bignum_destructive_add(bignum_type bignum , bignum_digit_type n ) ;
#line 73
static void bignum_divide_unsigned_large_denominator(bignum_type numerator , bignum_type denominator ,
                                                     bignum_type *quotient , bignum_type *remainder___0 ,
                                                     int q_negative_p , int r_negative_p ) ;
#line 75
static void bignum_destructive_normalization(bignum_type source , bignum_type target ,
                                             int shift_left ) ;
#line 76
static void bignum_destructive_unnormalization(bignum_type bignum , int shift_right ) ;
#line 77
static void bignum_divide_unsigned_normalized(bignum_type u , bignum_type v , bignum_type q ) ;
#line 79
static bignum_digit_type bignum_divide_subtract(bignum_digit_type *v_start , bignum_digit_type *v_end ,
                                                bignum_digit_type guess , bignum_digit_type *u_start ) ;
#line 82
static void bignum_divide_unsigned_medium_denominator(bignum_type numerator , bignum_digit_type denominator ,
                                                      bignum_type *quotient , bignum_type *remainder___0 ,
                                                      int q_negative_p , int r_negative_p ) ;
#line 84
static bignum_digit_type bignum_digit_divide(bignum_digit_type uh , bignum_digit_type ul ,
                                             bignum_digit_type v , bignum_digit_type *q ) ;
#line 87
static bignum_digit_type bignum_digit_divide_subtract(bignum_digit_type v1 , bignum_digit_type v2 ,
                                                      bignum_digit_type guess , bignum_digit_type *u ) ;
#line 90
static void bignum_divide_unsigned_small_denominator(bignum_type numerator , bignum_digit_type denominator ,
                                                     bignum_type *quotient , bignum_type *remainder___0 ,
                                                     int q_negative_p , int r_negative_p ) ;
#line 92
static bignum_digit_type bignum_destructive_scale_down(bignum_type bignum , bignum_digit_type denominator ) ;
#line 94
static bignum_type bignum_remainder_unsigned_small_denominator(bignum_type n , bignum_digit_type d ,
                                                               int negative_p ) ;
#line 96
static bignum_type bignum_digit_to_bignum(bignum_digit_type digit , int negative_p ) ;
#line 97
static bignum_type bignum_allocate(bignum_length_type length , int negative_p ) ;
#line 98
static bignum_type bignum_allocate_zeroed(bignum_length_type length , int negative_p ) ;
#line 99
static bignum_type bignum_shorten_length(bignum_type bignum , bignum_length_type length ) ;
#line 100
static bignum_type bignum_trim(bignum_type bignum ) ;
#line 101
static bignum_type bignum_copy(bignum_type source ) ;
#line 102
static bignum_type bignum_new_sign(bignum_type bignum , int negative_p ) ;
#line 103
static bignum_type bignum_maybe_new_sign(bignum_type bignum , int negative_p ) ;
#line 104
static void bignum_destructive_copy(bignum_type source , bignum_type target ) ;
#line 108 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
bignum_type bignum_make_zero(void) 
{ 
  bignum_type result ;
  SCHEME_OBJECT tmp ;

  {
  {
#line 111
  tmp = allocate_non_marked_vector(14U, (sizeof(bignum_digit_type ) + (sizeof(SCHEME_OBJECT ) - 1UL)) / sizeof(SCHEME_OBJECT ),
                                   (_Bool)1);
#line 111
  result = tmp;
#line 112
  *((bignum_digit_type *)((SCHEME_OBJECT *)(result & 288230376151711743UL) + 1)) = (bignum_digit_type )0UL;
  }
#line 113
  return (result);
}
}
#line 116 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
bignum_type bignum_make_one(int negative_p ) 
{ 
  bignum_type result ;
  SCHEME_OBJECT tmp ;
  unsigned long tmp___0 ;

  {
  {
#line 119
  tmp = allocate_non_marked_vector(14U, (2UL * sizeof(bignum_digit_type ) + (sizeof(SCHEME_OBJECT ) - 1UL)) / sizeof(SCHEME_OBJECT ),
                                   (_Bool)1);
#line 119
  result = tmp;
  }
#line 120
  if (negative_p) {
#line 120
    tmp___0 = 1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL);
  } else {
#line 120
    tmp___0 = 0UL;
  }
#line 120
  *((bignum_digit_type *)((SCHEME_OBJECT *)(result & 288230376151711743UL) + 1)) = (bignum_digit_type )(1UL | tmp___0);
#line 121
  *(((bignum_digit_type *)((SCHEME_OBJECT *)(result & 288230376151711743UL) + 1) + 1) + 0) = (bignum_digit_type )1;
#line 122
  return (result);
}
}
#line 125 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
int bignum_equal_p(bignum_type x , bignum_type y ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 128
  if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(x & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL)) == 0UL) {
#line 128
    tmp___2 = ((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(y & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL)) == 0UL;
  } else {
#line 128
    if (! (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(y & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL)) == 0UL)) {
#line 128
      if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(x & 288230376151711743UL) + 1)) & (1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL))) != 0UL) {
#line 128
        tmp = ((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(y & 288230376151711743UL) + 1)) & (1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL))) != 0UL;
      } else {
#line 128
        tmp = ! (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(y & 288230376151711743UL) + 1)) & (1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL))) != 0UL);
      }
#line 128
      if (tmp) {
        {
#line 128
        tmp___0 = bignum_equal_p_unsigned(x, y);
        }
#line 128
        if (tmp___0) {
#line 128
          tmp___1 = 1;
        } else {
#line 128
          tmp___1 = 0;
        }
      } else {
#line 128
        tmp___1 = 0;
      }
    } else {
#line 128
      tmp___1 = 0;
    }
#line 128
    tmp___2 = tmp___1;
  }
#line 128
  return (tmp___2);
}
}
#line 138 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
enum bignum_comparison bignum_test(bignum_type bignum ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 141
  if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(bignum & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL)) == 0UL) {
#line 141
    tmp___0 = 0;
  } else {
#line 141
    if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(bignum & 288230376151711743UL) + 1)) & (1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL))) != 0UL) {
#line 141
      tmp = 1;
    } else {
#line 141
      tmp = 2;
    }
#line 141
    tmp___0 = tmp;
  }
#line 141
  return ((enum bignum_comparison )tmp___0);
}
}
#line 149 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
enum bignum_comparison bignum_compare(bignum_type x , bignum_type y ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  enum bignum_comparison tmp___2 ;
  unsigned int tmp___3 ;
  enum bignum_comparison tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  unsigned int tmp___8 ;

  {
#line 152
  if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(x & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL)) == 0UL) {
#line 152
    if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(y & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL)) == 0UL) {
#line 152
      tmp___0 = 0;
    } else {
#line 152
      if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(y & 288230376151711743UL) + 1)) & (1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL))) != 0UL) {
#line 152
        tmp = 2;
      } else {
#line 152
        tmp = 1;
      }
#line 152
      tmp___0 = tmp;
    }
#line 152
    tmp___8 = (unsigned int )tmp___0;
  } else {
#line 152
    if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(y & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL)) == 0UL) {
#line 152
      if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(x & 288230376151711743UL) + 1)) & (1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL))) != 0UL) {
#line 152
        tmp___1 = 1;
      } else {
#line 152
        tmp___1 = 2;
      }
#line 152
      tmp___7 = (unsigned int )tmp___1;
    } else {
#line 152
      if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(x & 288230376151711743UL) + 1)) & (1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL))) != 0UL) {
#line 152
        if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(y & 288230376151711743UL) + 1)) & (1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL))) != 0UL) {
          {
#line 152
          tmp___2 = bignum_compare_unsigned(y, x);
#line 152
          tmp___3 = (unsigned int )tmp___2;
          }
        } else {
#line 152
          tmp___3 = 1U;
        }
#line 152
        tmp___6 = tmp___3;
      } else {
#line 152
        if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(y & 288230376151711743UL) + 1)) & (1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL))) != 0UL) {
#line 152
          tmp___5 = 2U;
        } else {
          {
#line 152
          tmp___4 = bignum_compare_unsigned(x, y);
#line 152
          tmp___5 = (unsigned int )tmp___4;
          }
        }
#line 152
        tmp___6 = tmp___5;
      }
#line 152
      tmp___7 = tmp___6;
    }
#line 152
    tmp___8 = tmp___7;
  }
#line 152
  return ((enum bignum_comparison )tmp___8);
}
}
#line 172 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
bignum_type bignum_add(bignum_type x , bignum_type y ) 
{ 
  bignum_type tmp ;
  bignum_type tmp___0 ;
  bignum_type tmp___1 ;
  bignum_type tmp___2 ;
  bignum_type tmp___3 ;
  bignum_type tmp___4 ;
  bignum_type tmp___5 ;
  bignum_type tmp___6 ;
  bignum_type tmp___7 ;

  {
#line 175
  if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(x & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL)) == 0UL) {
#line 175
    tmp___7 = y;
  } else {
#line 175
    if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(y & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL)) == 0UL) {
#line 175
      tmp___6 = x;
    } else {
#line 175
      if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(x & 288230376151711743UL) + 1)) & (1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL))) != 0UL) {
#line 175
        if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(y & 288230376151711743UL) + 1)) & (1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL))) != 0UL) {
          {
#line 175
          tmp = bignum_add_unsigned(x, y, 1);
#line 175
          tmp___1 = tmp;
          }
        } else {
          {
#line 175
          tmp___0 = bignum_subtract_unsigned(y, x);
#line 175
          tmp___1 = tmp___0;
          }
        }
#line 175
        tmp___5 = tmp___1;
      } else {
#line 175
        if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(y & 288230376151711743UL) + 1)) & (1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL))) != 0UL) {
          {
#line 175
          tmp___2 = bignum_subtract_unsigned(x, y);
#line 175
          tmp___4 = tmp___2;
          }
        } else {
          {
#line 175
          tmp___3 = bignum_add_unsigned(x, y, 0);
#line 175
          tmp___4 = tmp___3;
          }
        }
#line 175
        tmp___5 = tmp___4;
      }
#line 175
      tmp___6 = tmp___5;
    }
#line 175
    tmp___7 = tmp___6;
  }
#line 175
  return (tmp___7);
}
}
#line 189 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
bignum_type bignum_subtract(bignum_type x , bignum_type y ) 
{ 
  bignum_type tmp ;
  bignum_type tmp___0 ;
  bignum_type tmp___1 ;
  bignum_type tmp___2 ;
  bignum_type tmp___3 ;
  bignum_type tmp___4 ;
  bignum_type tmp___5 ;
  bignum_type tmp___6 ;
  bignum_type tmp___7 ;
  bignum_type tmp___8 ;
  bignum_type tmp___9 ;

  {
#line 192
  if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(x & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL)) == 0UL) {
#line 192
    if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(y & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL)) == 0UL) {
#line 192
      tmp___0 = y;
    } else {
      {
#line 192
      tmp = bignum_new_sign(y, ! (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(y & 288230376151711743UL) + 1)) & (1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL))) != 0UL));
#line 192
      tmp___0 = tmp;
      }
    }
#line 192
    tmp___9 = tmp___0;
  } else {
#line 192
    if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(y & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL)) == 0UL) {
#line 192
      tmp___8 = x;
    } else {
#line 192
      if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(x & 288230376151711743UL) + 1)) & (1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL))) != 0UL) {
#line 192
        if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(y & 288230376151711743UL) + 1)) & (1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL))) != 0UL) {
          {
#line 192
          tmp___1 = bignum_subtract_unsigned(y, x);
#line 192
          tmp___3 = tmp___1;
          }
        } else {
          {
#line 192
          tmp___2 = bignum_add_unsigned(x, y, 1);
#line 192
          tmp___3 = tmp___2;
          }
        }
#line 192
        tmp___7 = tmp___3;
      } else {
#line 192
        if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(y & 288230376151711743UL) + 1)) & (1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL))) != 0UL) {
          {
#line 192
          tmp___4 = bignum_add_unsigned(x, y, 0);
#line 192
          tmp___6 = tmp___4;
          }
        } else {
          {
#line 192
          tmp___5 = bignum_subtract_unsigned(x, y);
#line 192
          tmp___6 = tmp___5;
          }
        }
#line 192
        tmp___7 = tmp___6;
      }
#line 192
      tmp___8 = tmp___7;
    }
#line 192
    tmp___9 = tmp___8;
  }
#line 192
  return (tmp___9);
}
}
#line 208 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
bignum_type bignum_negate(bignum_type x ) 
{ 
  bignum_type tmp ;
  bignum_type tmp___0 ;

  {
#line 211
  if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(x & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL)) == 0UL) {
#line 211
    tmp___0 = x;
  } else {
    {
#line 211
    tmp = bignum_new_sign(x, ! (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(x & 288230376151711743UL) + 1)) & (1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL))) != 0UL));
#line 211
    tmp___0 = tmp;
    }
  }
#line 211
  return (tmp___0);
}
}
#line 217 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
bignum_type bignum_multiply(bignum_type x , bignum_type y ) 
{ 
  bignum_length_type x_length ;
  bignum_length_type y_length ;
  int negative_p ;
  int tmp ;
  bignum_digit_type digit ;
  bignum_type tmp___0 ;
  bignum_type tmp___1 ;
  bignum_digit_type digit___0 ;
  bignum_type tmp___2 ;
  bignum_type tmp___3 ;
  bignum_type tmp___4 ;

  {
#line 220
  x_length = (bignum_length_type )((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(x & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL));
#line 221
  y_length = (bignum_length_type )((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(y & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL));
#line 222
  if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(x & 288230376151711743UL) + 1)) & (1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL))) != 0UL) {
#line 222
    tmp = ! (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(y & 288230376151711743UL) + 1)) & (1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL))) != 0UL);
  } else {
#line 222
    tmp = ((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(y & 288230376151711743UL) + 1)) & (1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL))) != 0UL;
  }
#line 222
  negative_p = tmp;
#line 226
  if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(x & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL)) == 0UL) {
#line 227
    return (x);
  }
#line 228
  if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(y & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL)) == 0UL) {
#line 229
    return (y);
  }
#line 230
  if (x_length == 1L) {
#line 232
    digit = *(((bignum_digit_type *)((SCHEME_OBJECT *)(x & 288230376151711743UL) + 1) + 1) + 0);
#line 233
    if (digit == 1L) {
      {
#line 234
      tmp___0 = bignum_maybe_new_sign(y, negative_p);
      }
#line 234
      return (tmp___0);
    }
#line 235
    if ((unsigned long )digit < 1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL) {
      {
#line 236
      tmp___1 = bignum_multiply_unsigned_small_factor(y, digit, negative_p);
      }
#line 236
      return (tmp___1);
    }
  }
#line 238
  if (y_length == 1L) {
#line 240
    digit___0 = *(((bignum_digit_type *)((SCHEME_OBJECT *)(y & 288230376151711743UL) + 1) + 1) + 0);
#line 241
    if (digit___0 == 1L) {
      {
#line 242
      tmp___2 = bignum_maybe_new_sign(x, negative_p);
      }
#line 242
      return (tmp___2);
    }
#line 243
    if ((unsigned long )digit___0 < 1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL) {
      {
#line 244
      tmp___3 = bignum_multiply_unsigned_small_factor(x, digit___0, negative_p);
      }
#line 244
      return (tmp___3);
    }
  }
  {
#line 246
  tmp___4 = bignum_multiply_unsigned(x, y, negative_p);
  }
#line 246
  return (tmp___4);
}
}
#line 249 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
int bignum_divide(bignum_type numerator , bignum_type denominator , bignum_type *quotient ,
                  bignum_type *remainder___0 ) 
{ 
  int r_negative_p ;
  int q_negative_p ;
  int tmp ;
  enum bignum_comparison tmp___0 ;
  bignum_digit_type digit ;

  {
#line 253
  if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(denominator & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL)) == 0UL) {
#line 254
    return (1);
  }
#line 255
  if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(numerator & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL)) == 0UL) {
#line 257
    *quotient = numerator;
#line 258
    *remainder___0 = numerator;
  } else {
#line 262
    r_negative_p = ((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(numerator & 288230376151711743UL) + 1)) & (1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL))) != 0UL;
#line 263
    if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(denominator & 288230376151711743UL) + 1)) & (1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL))) != 0UL) {
#line 263
      tmp = ! r_negative_p;
    } else {
#line 263
      tmp = r_negative_p;
    }
    {
#line 263
    q_negative_p = tmp;
#line 265
    tmp___0 = bignum_compare_unsigned(numerator, denominator);
    }
    {
#line 267
    if ((unsigned int )tmp___0 == 0U) {
#line 267
      goto case_0;
    }
#line 273
    if ((unsigned int )tmp___0 == 1U) {
#line 273
      goto case_1;
    }
#line 279
    if ((unsigned int )tmp___0 == 2U) {
#line 279
      goto case_2;
    }
#line 265
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 269
    *quotient = bignum_make_one(q_negative_p);
#line 270
    *remainder___0 = bignum_make_zero();
    }
#line 271
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 275
    *quotient = bignum_make_zero();
#line 276
    *remainder___0 = numerator;
    }
#line 277
    goto switch_break;
    case_2: /* CIL Label */ 
#line 281
    if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(denominator & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL)) == 1UL) {
#line 283
      digit = *(((bignum_digit_type *)((SCHEME_OBJECT *)(denominator & 288230376151711743UL) + 1) + 1) + 0);
#line 284
      if (digit == 1L) {
        {
#line 286
        *quotient = bignum_maybe_new_sign(numerator, q_negative_p);
#line 288
        *remainder___0 = bignum_make_zero();
        }
#line 289
        goto switch_break;
      } else
#line 291
      if ((unsigned long )digit < 1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL) {
        {
#line 293
        bignum_divide_unsigned_small_denominator(numerator, digit, quotient, remainder___0,
                                                 q_negative_p, r_negative_p);
        }
#line 297
        goto switch_break;
      } else {
        {
#line 301
        bignum_divide_unsigned_medium_denominator(numerator, digit, quotient, remainder___0,
                                                  q_negative_p, r_negative_p);
        }
#line 305
        goto switch_break;
      }
    }
    {
#line 308
    bignum_divide_unsigned_large_denominator(numerator, denominator, quotient, remainder___0,
                                             q_negative_p, r_negative_p);
    }
#line 312
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 316
  return (0);
}
}
#line 319 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
bignum_type bignum_quotient(bignum_type numerator , bignum_type denominator ) 
{ 
  int q_negative_p ;
  int tmp ;
  enum bignum_comparison tmp___0 ;
  bignum_type tmp___1 ;
  bignum_type tmp___2 ;
  bignum_type quotient ;
  bignum_digit_type digit ;
  bignum_type tmp___3 ;

  {
#line 322
  if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(denominator & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL)) == 0UL) {
#line 323
    return (0UL);
  }
#line 324
  if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(numerator & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL)) == 0UL) {
#line 325
    return (numerator);
  }
#line 327
  if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(denominator & 288230376151711743UL) + 1)) & (1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL))) != 0UL) {
#line 327
    tmp = ! (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(numerator & 288230376151711743UL) + 1)) & (1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL))) != 0UL);
  } else {
#line 327
    tmp = ((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(numerator & 288230376151711743UL) + 1)) & (1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL))) != 0UL;
  }
  {
#line 327
  q_negative_p = tmp;
#line 331
  tmp___0 = bignum_compare_unsigned(numerator, denominator);
  }
  {
#line 333
  if ((unsigned int )tmp___0 == 0U) {
#line 333
    goto case_0;
  }
#line 335
  if ((unsigned int )tmp___0 == 1U) {
#line 335
    goto case_1;
  }
#line 337
  if ((unsigned int )tmp___0 == 2U) {
#line 337
    goto case_2;
  }
#line 363
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 334
  tmp___1 = bignum_make_one(q_negative_p);
  }
#line 334
  return (tmp___1);
  case_1: /* CIL Label */ 
  {
#line 336
  tmp___2 = bignum_make_zero();
  }
#line 336
  return (tmp___2);
  case_2: /* CIL Label */ 
#line 340
  if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(denominator & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL)) == 1UL) {
#line 342
    digit = *(((bignum_digit_type *)((SCHEME_OBJECT *)(denominator & 288230376151711743UL) + 1) + 1) + 0);
#line 343
    if (digit == 1L) {
      {
#line 344
      tmp___3 = bignum_maybe_new_sign(numerator, q_negative_p);
      }
#line 344
      return (tmp___3);
    }
#line 345
    if ((unsigned long )digit < 1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL) {
      {
#line 346
      bignum_divide_unsigned_small_denominator(numerator, digit, & quotient, (bignum_type *)0,
                                               q_negative_p, 0);
      }
    } else {
      {
#line 351
      bignum_divide_unsigned_medium_denominator(numerator, digit, & quotient, (bignum_type *)0,
                                                q_negative_p, 0);
      }
    }
  } else {
    {
#line 357
    bignum_divide_unsigned_large_denominator(numerator, denominator, & quotient, (bignum_type *)0,
                                             q_negative_p, 0);
    }
  }
#line 361
  return (quotient);
  switch_default: /* CIL Label */ 
#line 365
  return ((bignum_type )0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 370 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
bignum_type bignum_remainder(bignum_type numerator , bignum_type denominator ) 
{ 
  enum bignum_comparison tmp ;
  bignum_type tmp___0 ;
  bignum_type remainder___0 ;
  bignum_digit_type digit ;
  bignum_digit_type unsigned_remainder ;
  bignum_type tmp___1 ;
  bignum_type tmp___2 ;
  bignum_type tmp___3 ;
  bignum_type tmp___4 ;

  {
#line 373
  if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(denominator & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL)) == 0UL) {
#line 374
    return (0UL);
  }
#line 375
  if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(numerator & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL)) == 0UL) {
#line 376
    return (numerator);
  }
  {
#line 377
  tmp = bignum_compare_unsigned(numerator, denominator);
  }
  {
#line 379
  if ((unsigned int )tmp == 0U) {
#line 379
    goto case_0;
  }
#line 381
  if ((unsigned int )tmp == 1U) {
#line 381
    goto case_1;
  }
#line 383
  if ((unsigned int )tmp == 2U) {
#line 383
    goto case_2;
  }
#line 416
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 380
  tmp___0 = bignum_make_zero();
  }
#line 380
  return (tmp___0);
  case_1: /* CIL Label */ 
#line 382
  return (numerator);
  case_2: /* CIL Label */ 
#line 386
  if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(denominator & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL)) == 1UL) {
#line 388
    digit = *(((bignum_digit_type *)((SCHEME_OBJECT *)(denominator & 288230376151711743UL) + 1) + 1) + 0);
#line 389
    if ((digit & (digit - 1L)) == 0L) {
#line 392
      if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(numerator & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL)) == 0UL) {
        {
#line 393
        tmp___1 = bignum_make_zero();
        }
#line 393
        return (tmp___1);
      }
#line 394
      unsigned_remainder = (digit - 1L) & *(((bignum_digit_type *)((SCHEME_OBJECT *)(numerator & 288230376151711743UL) + 1) + 1) + 0);
#line 395
      if (unsigned_remainder == 0L) {
        {
#line 396
        tmp___2 = bignum_make_zero();
        }
#line 396
        return (tmp___2);
      }
      {
#line 397
      tmp___3 = bignum_digit_to_bignum(unsigned_remainder, ((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(numerator & 288230376151711743UL) + 1)) & (1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL))) != 0UL);
      }
#line 397
      return (tmp___3);
    }
#line 400
    if ((unsigned long )digit < 1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL) {
      {
#line 401
      tmp___4 = bignum_remainder_unsigned_small_denominator(numerator, digit, ((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(numerator & 288230376151711743UL) + 1)) & (1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL))) != 0UL);
      }
#line 401
      return (tmp___4);
    }
    {
#line 404
    bignum_divide_unsigned_medium_denominator(numerator, digit, (bignum_type *)0,
                                              & remainder___0, 0, ((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(numerator & 288230376151711743UL) + 1)) & (1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL))) != 0UL);
    }
  } else {
    {
#line 410
    bignum_divide_unsigned_large_denominator(numerator, denominator, (bignum_type *)0,
                                             & remainder___0, 0, ((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(numerator & 288230376151711743UL) + 1)) & (1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL))) != 0UL);
    }
  }
#line 414
  return (remainder___0);
  switch_default: /* CIL Label */ 
#line 418
  return ((bignum_type )0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 422 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
static bignum_type bignum_from_digits(bignum_digit_type *start_digits , bignum_digit_type *end_digits ,
                                      _Bool negative_p ) 
{ 
  bignum_type result ;
  bignum_type tmp ;
  bignum_digit_type *scan_digits ;
  bignum_digit_type *scan_result ;
  bignum_digit_type *tmp___0 ;
  bignum_digit_type *tmp___1 ;

  {
  {
#line 427
  tmp = bignum_allocate(end_digits - start_digits, (int )negative_p);
#line 427
  result = tmp;
#line 429
  scan_digits = start_digits;
#line 430
  scan_result = (bignum_digit_type *)((SCHEME_OBJECT *)(result & 288230376151711743UL) + 1) + 1;
  }
  {
#line 431
  while (1) {
    while_continue: /* CIL Label */ ;
#line 431
    if (! ((unsigned long )scan_digits < (unsigned long )end_digits)) {
#line 431
      goto while_break;
    }
#line 432
    tmp___0 = scan_result;
#line 432
    scan_result ++;
#line 432
    tmp___1 = scan_digits;
#line 432
    scan_digits ++;
#line 432
    *tmp___0 = *tmp___1;
  }
  while_break: /* CIL Label */ ;
  }
#line 433
  return (result);
}
}
#line 458 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
bignum_type long_to_bignum(long n ) 
{ 
  bignum_type tmp ;
  bignum_type tmp___0 ;
  bignum_type tmp___1 ;
  int negative_p ;
  bignum_digit_type result_digits[(sizeof(long ) * 8UL + ((sizeof(bignum_digit_type ) * 8UL - 2UL) - 1UL)) / (sizeof(bignum_digit_type ) * 8UL - 2UL)] ;
  bignum_digit_type *end_digits ;
  unsigned long accumulator ;
  long tmp___2 ;
  bignum_digit_type *tmp___3 ;
  bignum_type tmp___4 ;
  void *__cil_tmp12 ;

  {
#line 458
  if (n == 0L) {
    {
#line 458
    tmp = bignum_make_zero();
    }
#line 458
    return (tmp);
  }
#line 458
  if (n == 1L) {
    {
#line 458
    tmp___0 = bignum_make_one(0);
    }
#line 458
    return (tmp___0);
  }
#line 458
  if (n == -1L) {
    {
#line 458
    tmp___1 = bignum_make_one(1);
    }
#line 458
    return (tmp___1);
  }
#line 458
  end_digits = result_digits;
#line 458
  negative_p = n < 0L;
#line 458
  if (negative_p) {
#line 458
    tmp___2 = - n;
  } else {
#line 458
    tmp___2 = n;
  }
#line 458
  accumulator = (unsigned long )tmp___2;
  {
#line 458
  while (1) {
    while_continue: /* CIL Label */ ;
#line 458
    tmp___3 = end_digits;
#line 458
    end_digits ++;
#line 458
    *tmp___3 = (bignum_digit_type )(accumulator & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL));
#line 458
    accumulator >>= sizeof(bignum_digit_type ) * 8UL - 2UL;
#line 458
    if (! (accumulator != 0UL)) {
#line 458
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 458
  tmp___4 = bignum_from_digits(result_digits, end_digits, (_Bool )negative_p);
  }
#line 458
  return (tmp___4);
}
}
#line 459 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
bignum_type intmax_to_bignum(intmax_t n ) 
{ 
  bignum_type tmp ;
  bignum_type tmp___0 ;
  bignum_type tmp___1 ;
  int negative_p ;
  bignum_digit_type result_digits[(sizeof(intmax_t ) * 8UL + ((sizeof(bignum_digit_type ) * 8UL - 2UL) - 1UL)) / (sizeof(bignum_digit_type ) * 8UL - 2UL)] ;
  bignum_digit_type *end_digits ;
  uintmax_t accumulator ;
  intmax_t tmp___2 ;
  bignum_digit_type *tmp___3 ;
  bignum_type tmp___4 ;
  void *__cil_tmp12 ;

  {
#line 459
  if (n == 0L) {
    {
#line 459
    tmp = bignum_make_zero();
    }
#line 459
    return (tmp);
  }
#line 459
  if (n == 1L) {
    {
#line 459
    tmp___0 = bignum_make_one(0);
    }
#line 459
    return (tmp___0);
  }
#line 459
  if (n == -1L) {
    {
#line 459
    tmp___1 = bignum_make_one(1);
    }
#line 459
    return (tmp___1);
  }
#line 459
  end_digits = result_digits;
#line 459
  negative_p = n < 0L;
#line 459
  if (negative_p) {
#line 459
    tmp___2 = - n;
  } else {
#line 459
    tmp___2 = n;
  }
#line 459
  accumulator = (uintmax_t )tmp___2;
  {
#line 459
  while (1) {
    while_continue: /* CIL Label */ ;
#line 459
    tmp___3 = end_digits;
#line 459
    end_digits ++;
#line 459
    *tmp___3 = (bignum_digit_type )(accumulator & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL));
#line 459
    accumulator >>= sizeof(bignum_digit_type ) * 8UL - 2UL;
#line 459
    if (! (accumulator != 0UL)) {
#line 459
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 459
  tmp___4 = bignum_from_digits(result_digits, end_digits, (_Bool )negative_p);
  }
#line 459
  return (tmp___4);
}
}
#line 480 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
long bignum_to_long(bignum_type bignum ) 
{ 
  unsigned long accumulator ;
  bignum_digit_type *start ;
  bignum_digit_type *scan ;
  long tmp ;

  {
#line 480
  if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(bignum & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL)) == 0UL) {
#line 480
    return (0L);
  }
#line 480
  accumulator = 0UL;
#line 480
  start = (bignum_digit_type *)((SCHEME_OBJECT *)(bignum & 288230376151711743UL) + 1) + 1;
#line 480
  scan = start + ((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(bignum & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL));
  {
#line 480
  while (1) {
    while_continue: /* CIL Label */ ;
#line 480
    if (! ((unsigned long )start < (unsigned long )scan)) {
#line 480
      goto while_break;
    }
#line 480
    scan --;
#line 480
    accumulator = (accumulator << (sizeof(bignum_digit_type ) * 8UL - 2UL)) + (unsigned long )*scan;
  }
  while_break: /* CIL Label */ ;
  }
#line 480
  if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(bignum & 288230376151711743UL) + 1)) & (1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL))) != 0UL) {
#line 480
    tmp = - ((long )accumulator);
  } else {
#line 480
    tmp = (long )accumulator;
  }
#line 480
  return (tmp);
}
}
#line 481 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
intmax_t bignum_to_intmax(bignum_type bignum ) 
{ 
  uintmax_t accumulator ;
  bignum_digit_type *start ;
  bignum_digit_type *scan ;
  intmax_t tmp ;

  {
#line 481
  if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(bignum & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL)) == 0UL) {
#line 481
    return ((intmax_t )0);
  }
#line 481
  accumulator = (uintmax_t )0;
#line 481
  start = (bignum_digit_type *)((SCHEME_OBJECT *)(bignum & 288230376151711743UL) + 1) + 1;
#line 481
  scan = start + ((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(bignum & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL));
  {
#line 481
  while (1) {
    while_continue: /* CIL Label */ ;
#line 481
    if (! ((unsigned long )start < (unsigned long )scan)) {
#line 481
      goto while_break;
    }
#line 481
    scan --;
#line 481
    accumulator = (accumulator << (sizeof(bignum_digit_type ) * 8UL - 2UL)) + (uintmax_t )*scan;
  }
  while_break: /* CIL Label */ ;
  }
#line 481
  if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(bignum & 288230376151711743UL) + 1)) & (1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL))) != 0UL) {
#line 481
    tmp = - ((intmax_t )accumulator);
  } else {
#line 481
    tmp = (intmax_t )accumulator;
  }
#line 481
  return (tmp);
}
}
#line 502 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
bignum_type ulong_to_bignum(unsigned long n ) 
{ 
  bignum_type tmp ;
  bignum_type tmp___0 ;
  bignum_digit_type result_digits[(sizeof(unsigned long ) * 8UL + ((sizeof(bignum_digit_type ) * 8UL - 2UL) - 1UL)) / (sizeof(bignum_digit_type ) * 8UL - 2UL)] ;
  bignum_digit_type *end_digits ;
  unsigned long accumulator ;
  bignum_digit_type *tmp___1 ;
  bignum_type tmp___2 ;
  void *__cil_tmp9 ;

  {
#line 502
  if (n == 0UL) {
    {
#line 502
    tmp = bignum_make_zero();
    }
#line 502
    return (tmp);
  }
#line 502
  if (n == 1UL) {
    {
#line 502
    tmp___0 = bignum_make_one(0);
    }
#line 502
    return (tmp___0);
  }
#line 502
  end_digits = result_digits;
#line 502
  accumulator = n;
  {
#line 502
  while (1) {
    while_continue: /* CIL Label */ ;
#line 502
    tmp___1 = end_digits;
#line 502
    end_digits ++;
#line 502
    *tmp___1 = (bignum_digit_type )(accumulator & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL));
#line 502
    accumulator >>= sizeof(bignum_digit_type ) * 8UL - 2UL;
#line 502
    if (! (accumulator != 0UL)) {
#line 502
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 502
  tmp___2 = bignum_from_digits(result_digits, end_digits, (_Bool)0);
  }
#line 502
  return (tmp___2);
}
}
#line 503 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
bignum_type uintmax_to_bignum(uintmax_t n ) 
{ 
  bignum_type tmp ;
  bignum_type tmp___0 ;
  bignum_digit_type result_digits[(sizeof(uintmax_t ) * 8UL + ((sizeof(bignum_digit_type ) * 8UL - 2UL) - 1UL)) / (sizeof(bignum_digit_type ) * 8UL - 2UL)] ;
  bignum_digit_type *end_digits ;
  uintmax_t accumulator ;
  bignum_digit_type *tmp___1 ;
  bignum_type tmp___2 ;
  void *__cil_tmp9 ;

  {
#line 503
  if (n == 0UL) {
    {
#line 503
    tmp = bignum_make_zero();
    }
#line 503
    return (tmp);
  }
#line 503
  if (n == 1UL) {
    {
#line 503
    tmp___0 = bignum_make_one(0);
    }
#line 503
    return (tmp___0);
  }
#line 503
  end_digits = result_digits;
#line 503
  accumulator = n;
  {
#line 503
  while (1) {
    while_continue: /* CIL Label */ ;
#line 503
    tmp___1 = end_digits;
#line 503
    end_digits ++;
#line 503
    *tmp___1 = (bignum_digit_type )(accumulator & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL));
#line 503
    accumulator >>= sizeof(bignum_digit_type ) * 8UL - 2UL;
#line 503
    if (! (accumulator != 0UL)) {
#line 503
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 503
  tmp___2 = bignum_from_digits(result_digits, end_digits, (_Bool)0);
  }
#line 503
  return (tmp___2);
}
}
#line 522 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
unsigned long bignum_to_ulong(bignum_type bignum ) 
{ 
  enum bignum_comparison tmp ;
  unsigned long accumulator ;
  bignum_digit_type *start ;
  bignum_digit_type *scan ;

  {
#line 522
  if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(bignum & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL)) == 0UL) {
#line 522
    return (0UL);
  }
  {
#line 522
  tmp = bignum_test(bignum);
  }
#line 522
  if (! ((unsigned int )tmp == 2U)) {
    {
#line 522
    error_external_return();
    }
  }
#line 522
  accumulator = 0UL;
#line 522
  start = (bignum_digit_type *)((SCHEME_OBJECT *)(bignum & 288230376151711743UL) + 1) + 1;
#line 522
  scan = start + ((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(bignum & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL));
  {
#line 522
  while (1) {
    while_continue: /* CIL Label */ ;
#line 522
    if (! ((unsigned long )start < (unsigned long )scan)) {
#line 522
      goto while_break;
    }
#line 522
    scan --;
#line 522
    accumulator = (accumulator << (sizeof(bignum_digit_type ) * 8UL - 2UL)) + (unsigned long )*scan;
  }
  while_break: /* CIL Label */ ;
  }
#line 522
  return (accumulator);
}
}
#line 523 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
uintmax_t bignum_to_uintmax(bignum_type bignum ) 
{ 
  enum bignum_comparison tmp ;
  uintmax_t accumulator ;
  bignum_digit_type *start ;
  bignum_digit_type *scan ;

  {
#line 523
  if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(bignum & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL)) == 0UL) {
#line 523
    return ((uintmax_t )0);
  }
  {
#line 523
  tmp = bignum_test(bignum);
  }
#line 523
  if (! ((unsigned int )tmp == 2U)) {
    {
#line 523
    error_external_return();
    }
  }
#line 523
  accumulator = (uintmax_t )0;
#line 523
  start = (bignum_digit_type *)((SCHEME_OBJECT *)(bignum & 288230376151711743UL) + 1) + 1;
#line 523
  scan = start + ((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(bignum & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL));
  {
#line 523
  while (1) {
    while_continue: /* CIL Label */ ;
#line 523
    if (! ((unsigned long )start < (unsigned long )scan)) {
#line 523
      goto while_break;
    }
#line 523
    scan --;
#line 523
    accumulator = (accumulator << (sizeof(bignum_digit_type ) * 8UL - 2UL)) + (uintmax_t )*scan;
  }
  while_break: /* CIL Label */ ;
  }
#line 523
  return (accumulator);
}
}
#line 534 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
bignum_type double_to_bignum(double x ) 
{ 
  int exponent ;
  double significand___0 ;
  double tmp ;
  bignum_type tmp___0 ;
  bignum_type tmp___1 ;
  bignum_length_type length ;
  bignum_type result ;
  bignum_type tmp___2 ;
  bignum_digit_type *start ;
  bignum_digit_type *scan ;
  unsigned int n_valid_bits ;
  bignum_digit_type digit ;
  int odd_bits ;

  {
  {
#line 538
  tmp = frexp(x, & exponent);
#line 538
  significand___0 = tmp;
  }
#line 539
  if (exponent <= 0) {
    {
#line 539
    tmp___0 = bignum_make_zero();
    }
#line 539
    return (tmp___0);
  }
#line 540
  if (exponent == 1) {
    {
#line 540
    tmp___1 = bignum_make_one(x < (double )0);
    }
#line 540
    return (tmp___1);
  }
#line 541
  if (significand___0 < (double )0) {
#line 541
    significand___0 = - significand___0;
  }
  {
#line 543
  length = (bignum_length_type )(((unsigned long )exponent + ((sizeof(bignum_digit_type ) * 8UL - 2UL) - 1UL)) / (sizeof(bignum_digit_type ) * 8UL - 2UL));
#line 544
  tmp___2 = bignum_allocate(length, x < (double )0);
#line 544
  result = tmp___2;
#line 545
  start = (bignum_digit_type *)((SCHEME_OBJECT *)(result & 288230376151711743UL) + 1) + 1;
#line 546
  scan = start + length;
#line 547
  n_valid_bits = 53U;
#line 550
  odd_bits = (int )((unsigned long )exponent % (sizeof(bignum_digit_type ) * 8UL - 2UL));
  }
#line 551
  if (odd_bits > 0) {
    {
#line 552
    while (1) {
      while_continue: /* CIL Label */ ;
#line 552
      significand___0 *= (double )(1UL << odd_bits);
#line 552
      digit = (bignum_digit_type )significand___0;
#line 552
      scan --;
#line 552
      *scan = digit;
#line 552
      significand___0 -= (double )digit;
#line 552
      n_valid_bits -= (unsigned int )odd_bits;
#line 552
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 554
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 554
    if (! ((unsigned long )start < (unsigned long )scan)) {
#line 554
      goto while_break___0;
    }
#line 556
    if (significand___0 == (double )0) {
#line 556
      goto _L;
    } else
#line 556
    if (n_valid_bits == 0U) {
      _L: /* CIL Label */ 
      {
#line 558
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 558
        if (! ((unsigned long )start < (unsigned long )scan)) {
#line 558
          goto while_break___1;
        }
#line 559
        scan --;
#line 559
        *scan = (bignum_digit_type )0;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 560
      goto while_break___0;
    }
#line 562
    if ((unsigned long )n_valid_bits >= sizeof(bignum_digit_type ) * 8UL - 2UL) {
      {
#line 563
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 563
        significand___0 *= (double )(1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL));
#line 563
        digit = (bignum_digit_type )significand___0;
#line 563
        scan --;
#line 563
        *scan = digit;
#line 563
        significand___0 -= (double )digit;
#line 563
        n_valid_bits = (unsigned int )((unsigned long )n_valid_bits - (sizeof(bignum_digit_type ) * 8UL - 2UL));
#line 563
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else {
#line 566
      significand___0 *= (double )(1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL));
#line 567
      digit = (bignum_digit_type )significand___0;
#line 568
      scan --;
#line 568
      *scan = (bignum_digit_type )((unsigned long )digit & (((1UL << n_valid_bits) - 1UL) << ((sizeof(bignum_digit_type ) * 8UL - 2UL) - (unsigned long )n_valid_bits)));
#line 572
      significand___0 = 0.0;
#line 573
      n_valid_bits = 0U;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 576
  return (result);
}
}
#line 602 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
double bignum_to_double(bignum_type bignum ) 
{ 
  bignum_length_type length ;
  bignum_length_type index___0 ;
  bignum_length_type scale_words ;
  bignum_digit_type msd ;
  int bits_to_get ;
  double value ;
  bignum_digit_type guard_bit_mask ;
  bignum_digit_type rounding_correction ;
  int current_digit_bit_count ;
  unsigned int tmp ;
  bignum_digit_type mask ;
  bignum_length_type index2 ;
  double tmp___0 ;

  {
#line 605
  if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(bignum & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL)) == 0UL) {
#line 606
    return (0.0);
  }
  {
#line 609
  length = (bignum_length_type )((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(bignum & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL));
#line 610
  index___0 = length - 1L;
#line 612
  msd = *(((bignum_digit_type *)((SCHEME_OBJECT *)(bignum & 288230376151711743UL) + 1) + 1) + index___0);
#line 614
  bits_to_get = 53;
#line 618
  value = (double )0;
#line 619
  guard_bit_mask = (bignum_digit_type )((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) >> 1);
#line 620
  rounding_correction = (bignum_digit_type )0;
#line 621
  tmp = ulong_length_in_bits((unsigned long )msd);
#line 621
  current_digit_bit_count = (int )tmp;
#line 622
  mask = ~ (-1L << current_digit_bit_count);
  }
  {
#line 624
  while (1) {
    while_continue: /* CIL Label */ ;
#line 625
    if (current_digit_bit_count > bits_to_get) {
#line 626
      guard_bit_mask = (bignum_digit_type )(1UL << ((current_digit_bit_count - bits_to_get) - 1));
#line 627
      mask = (bignum_digit_type )((unsigned long )mask & ~ ((unsigned long )(guard_bit_mask << 1) - 1UL));
#line 628
      current_digit_bit_count = bits_to_get;
#line 629
      bits_to_get = 0;
    } else {
#line 631
      bits_to_get -= current_digit_bit_count;
    }
#line 634
    value = value * (double )(1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) + (double )(*(((bignum_digit_type *)((SCHEME_OBJECT *)(bignum & 288230376151711743UL) + 1) + 1) + index___0) & mask);
#line 636
    if (bits_to_get == 0) {
#line 637
      scale_words = index___0;
#line 638
      if ((unsigned long )current_digit_bit_count == sizeof(bignum_digit_type ) * 8UL - 2UL) {
#line 639
        if (index___0 == 0L) {
#line 640
          goto finished;
        }
#line 641
        guard_bit_mask = (bignum_digit_type )(1UL << ((sizeof(bignum_digit_type ) * 8UL - 2UL) - 1UL));
#line 642
        rounding_correction = (bignum_digit_type )1;
#line 643
        index___0 --;
      } else {
#line 645
        rounding_correction = guard_bit_mask << 1;
      }
#line 647
      goto while_break;
    }
#line 649
    if (index___0 == 0L) {
#line 650
      goto finished;
    }
#line 652
    index___0 --;
#line 653
    current_digit_bit_count = (int )(sizeof(bignum_digit_type ) * 8UL - 2UL);
#line 654
    mask = (bignum_digit_type )((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL);
  }
  while_break: /* CIL Label */ ;
  }
#line 659
  if ((*(((bignum_digit_type *)((SCHEME_OBJECT *)(bignum & 288230376151711743UL) + 1) + 1) + index___0) & guard_bit_mask) == 0L) {
#line 660
    goto round_down;
  }
#line 662
  if ((*(((bignum_digit_type *)((SCHEME_OBJECT *)(bignum & 288230376151711743UL) + 1) + 1) + index___0) & (guard_bit_mask - 1L)) != 0L) {
#line 663
    goto round_up;
  }
#line 666
  if ((unsigned long )(guard_bit_mask << 1) == 1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) {
#line 667
    if (((unsigned long )*(((bignum_digit_type *)((SCHEME_OBJECT *)(bignum & 288230376151711743UL) + 1) + 1) + (index___0 + 1L)) & 1UL) != 0UL) {
#line 668
      goto round_up;
    }
  } else
#line 670
  if ((*(((bignum_digit_type *)((SCHEME_OBJECT *)(bignum & 288230376151711743UL) + 1) + 1) + index___0) & (guard_bit_mask << 1)) != 0L) {
#line 671
    goto round_up;
  }
#line 674
  if (index___0 == 0L) {
#line 675
    goto finished;
  }
#line 678
  index2 = index___0 - 1L;
  {
#line 679
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 679
    if (! (index2 >= 0L)) {
#line 679
      goto while_break___0;
    }
#line 680
    if (*(((bignum_digit_type *)((SCHEME_OBJECT *)(bignum & 288230376151711743UL) + 1) + 1) + index2) != 0L) {
#line 681
      goto round_up;
    }
#line 682
    index2 --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 684
  goto round_down;
  round_up: 
#line 688
  value += (double )rounding_correction;
  round_down: 
#line 693
  if (scale_words > 0L) {
    {
#line 694
    value = ldexp(value, (int )((unsigned long )scale_words * (sizeof(bignum_digit_type ) * 8UL - 2UL)));
    }
  }
  finished: 
#line 697
  if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(bignum & 288230376151711743UL) + 1)) & (1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL))) != 0UL) {
#line 697
    tmp___0 = - value;
  } else {
#line 697
    tmp___0 = value;
  }
#line 697
  return (tmp___0);
}
}
#line 740 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
int bignum_fits_in_word_p(bignum_type bignum , long word_length , int twos_complement_p ) 
{ 
  unsigned int n_bits ;
  bignum_length_type length ;
  unsigned int max_digits ;
  bignum_digit_type msd ;
  bignum_digit_type max ;
  int tmp ;

  {
#line 746
  if (twos_complement_p) {
#line 747
    n_bits = (unsigned int )(word_length - 1L);
  } else {
#line 750
    if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(bignum & 288230376151711743UL) + 1)) & (1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL))) != 0UL) {
#line 751
      return (0);
    }
#line 752
    n_bits = (unsigned int )word_length;
  }
#line 755
  if (! (n_bits > 0U)) {
    {
#line 755
    error_external_return();
    }
  }
#line 757
  length = (bignum_length_type )((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(bignum & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL));
#line 758
  max_digits = (unsigned int )(((unsigned long )n_bits + ((sizeof(bignum_digit_type ) * 8UL - 2UL) - 1UL)) / (sizeof(bignum_digit_type ) * 8UL - 2UL));
#line 759
  if ((unsigned int )length < max_digits) {
#line 760
    return (1);
  }
#line 761
  if ((unsigned int )length > max_digits) {
#line 762
    return (0);
  }
#line 764
  msd = *(((bignum_digit_type *)((SCHEME_OBJECT *)(bignum & 288230376151711743UL) + 1) + 1) + (length - 1L));
#line 765
  max = (bignum_digit_type )(1UL << ((unsigned long )n_bits - (unsigned long )(length - 1L) * (sizeof(bignum_digit_type ) * 8UL - 2UL)));
#line 767
  if (msd < max) {
#line 767
    tmp = 1;
  } else
#line 767
  if (twos_complement_p) {
#line 767
    if (msd == max) {
#line 767
      if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(bignum & 288230376151711743UL) + 1)) & (1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL))) != 0UL) {
#line 767
        tmp = 1;
      } else {
#line 767
        tmp = 0;
      }
    } else {
#line 767
      tmp = 0;
    }
  } else {
#line 767
    tmp = 0;
  }
#line 767
  return (tmp);
}
}
#line 780 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
bignum_type bignum_bitwise_not(bignum_type bignum ) 
{ 
  bignum_type tmp ;
  bignum_type tmp___0 ;

  {
  {
#line 783
  tmp = bignum_make_one(1);
#line 783
  tmp___0 = bignum_subtract(tmp, bignum);
  }
#line 783
  return (tmp___0);
}
}
#line 825
static bignum_type bignum_bitwise_andc1_unsigned(bignum_type x , bignum_type y ) ;
#line 826
static bignum_type bignum_bitwise_orc1_unsigned(bignum_type x , bignum_type y ) ;
#line 831 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
static bignum_type bignum_bitwise_and_unsigned(bignum_type x , bignum_type y ) 
{ 
  bignum_type t ;
  bignum_length_type x_length ;
  bignum_length_type y_length ;
  bignum_length_type r_length ;
  bignum_type r ;
  bignum_type tmp ;
  bignum_digit_type *x_scan ;
  bignum_digit_type *x_end ;
  bignum_digit_type *y_scan ;
  bignum_digit_type *y_end ;
  bignum_digit_type *r_scan ;
  bignum_digit_type *tmp___0 ;
  bignum_digit_type *tmp___1 ;
  bignum_digit_type *tmp___2 ;
  bignum_digit_type *tmp___3 ;
  bignum_digit_type *tmp___4 ;
  bignum_type tmp___5 ;

  {
#line 831
  if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(x & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL)) < ((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(y & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL))) {
    {
#line 831
    while (1) {
      while_continue: /* CIL Label */ ;
#line 831
      t = y;
#line 831
      y = x;
#line 831
      x = t;
#line 831
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 831
  x_length = (bignum_length_type )((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(x & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL));
#line 831
  y_length = (bignum_length_type )((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(y & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL));
#line 831
  r_length = x_length;
#line 831
  tmp = bignum_allocate(r_length, 0);
#line 831
  r = tmp;
#line 831
  x_scan = (bignum_digit_type *)((SCHEME_OBJECT *)(x & 288230376151711743UL) + 1) + 1;
#line 831
  x_end = x_scan + x_length;
#line 831
  y_scan = (bignum_digit_type *)((SCHEME_OBJECT *)(y & 288230376151711743UL) + 1) + 1;
#line 831
  y_end = y_scan + y_length;
#line 831
  r_scan = (bignum_digit_type *)((SCHEME_OBJECT *)(r & 288230376151711743UL) + 1) + 1;
  }
#line 831
  if (! (x_length >= y_length)) {
    {
#line 831
    error_external_return();
    }
  }
  {
#line 831
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 831
    if (! ((unsigned long )y_scan < (unsigned long )y_end)) {
#line 831
      goto while_break___0;
    }
#line 831
    tmp___0 = r_scan;
#line 831
    r_scan ++;
#line 831
    tmp___1 = x_scan;
#line 831
    x_scan ++;
#line 831
    tmp___2 = y_scan;
#line 831
    y_scan ++;
#line 831
    *tmp___0 = *tmp___1 & *tmp___2;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 831
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 831
    if (! ((unsigned long )x_scan < (unsigned long )x_end)) {
#line 831
      goto while_break___1;
    }
#line 831
    tmp___3 = r_scan;
#line 831
    r_scan ++;
#line 831
    tmp___4 = x_scan;
#line 831
    x_scan ++;
#line 831
    *tmp___3 = 0L;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 831
  tmp___5 = bignum_trim(r);
  }
#line 831
  return (tmp___5);
}
}
#line 832 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
static bignum_type bignum_bitwise_andc2_unsigned(bignum_type x , bignum_type y ) 
{ 
  bignum_type tmp ;
  bignum_length_type x_length ;
  bignum_length_type y_length ;
  bignum_length_type r_length ;
  bignum_type r ;
  bignum_type tmp___0 ;
  bignum_digit_type *x_scan ;
  bignum_digit_type *x_end ;
  bignum_digit_type *y_scan ;
  bignum_digit_type *y_end ;
  bignum_digit_type *r_scan ;
  bignum_digit_type *tmp___1 ;
  bignum_digit_type *tmp___2 ;
  bignum_digit_type *tmp___3 ;
  bignum_digit_type *tmp___4 ;
  bignum_digit_type *tmp___5 ;
  bignum_type tmp___6 ;

  {
#line 832
  if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(x & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL)) < ((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(y & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL))) {
    {
#line 832
    tmp = bignum_bitwise_andc1_unsigned(y, x);
    }
#line 832
    return (tmp);
  }
  {
#line 832
  x_length = (bignum_length_type )((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(x & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL));
#line 832
  y_length = (bignum_length_type )((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(y & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL));
#line 832
  r_length = x_length;
#line 832
  tmp___0 = bignum_allocate(r_length, 0);
#line 832
  r = tmp___0;
#line 832
  x_scan = (bignum_digit_type *)((SCHEME_OBJECT *)(x & 288230376151711743UL) + 1) + 1;
#line 832
  x_end = x_scan + x_length;
#line 832
  y_scan = (bignum_digit_type *)((SCHEME_OBJECT *)(y & 288230376151711743UL) + 1) + 1;
#line 832
  y_end = y_scan + y_length;
#line 832
  r_scan = (bignum_digit_type *)((SCHEME_OBJECT *)(r & 288230376151711743UL) + 1) + 1;
  }
#line 832
  if (! (x_length >= y_length)) {
    {
#line 832
    error_external_return();
    }
  }
  {
#line 832
  while (1) {
    while_continue: /* CIL Label */ ;
#line 832
    if (! ((unsigned long )y_scan < (unsigned long )y_end)) {
#line 832
      goto while_break;
    }
#line 832
    tmp___1 = r_scan;
#line 832
    r_scan ++;
#line 832
    tmp___2 = x_scan;
#line 832
    x_scan ++;
#line 832
    tmp___3 = y_scan;
#line 832
    y_scan ++;
#line 832
    *tmp___1 = *tmp___2 & ~ *tmp___3;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 832
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 832
    if (! ((unsigned long )x_scan < (unsigned long )x_end)) {
#line 832
      goto while_break___0;
    }
#line 832
    tmp___4 = r_scan;
#line 832
    r_scan ++;
#line 832
    tmp___5 = x_scan;
#line 832
    x_scan ++;
#line 832
    *tmp___4 = *tmp___5 & -1L;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 832
  tmp___6 = bignum_trim(r);
  }
#line 832
  return (tmp___6);
}
}
#line 834 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
static bignum_type bignum_bitwise_andc1_unsigned(bignum_type x , bignum_type y ) 
{ 
  bignum_type tmp ;
  bignum_length_type x_length ;
  bignum_length_type y_length ;
  bignum_length_type r_length ;
  bignum_type r ;
  bignum_type tmp___0 ;
  bignum_digit_type *x_scan ;
  bignum_digit_type *x_end ;
  bignum_digit_type *y_scan ;
  bignum_digit_type *y_end ;
  bignum_digit_type *r_scan ;
  bignum_digit_type *tmp___1 ;
  bignum_digit_type *tmp___2 ;
  bignum_digit_type *tmp___3 ;
  bignum_digit_type *tmp___4 ;
  bignum_digit_type *tmp___5 ;
  bignum_type tmp___6 ;

  {
#line 834
  if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(x & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL)) < ((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(y & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL))) {
    {
#line 834
    tmp = bignum_bitwise_andc2_unsigned(y, x);
    }
#line 834
    return (tmp);
  }
  {
#line 834
  x_length = (bignum_length_type )((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(x & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL));
#line 834
  y_length = (bignum_length_type )((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(y & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL));
#line 834
  r_length = x_length;
#line 834
  tmp___0 = bignum_allocate(r_length, 0);
#line 834
  r = tmp___0;
#line 834
  x_scan = (bignum_digit_type *)((SCHEME_OBJECT *)(x & 288230376151711743UL) + 1) + 1;
#line 834
  x_end = x_scan + x_length;
#line 834
  y_scan = (bignum_digit_type *)((SCHEME_OBJECT *)(y & 288230376151711743UL) + 1) + 1;
#line 834
  y_end = y_scan + y_length;
#line 834
  r_scan = (bignum_digit_type *)((SCHEME_OBJECT *)(r & 288230376151711743UL) + 1) + 1;
  }
#line 834
  if (! (x_length >= y_length)) {
    {
#line 834
    error_external_return();
    }
  }
  {
#line 834
  while (1) {
    while_continue: /* CIL Label */ ;
#line 834
    if (! ((unsigned long )y_scan < (unsigned long )y_end)) {
#line 834
      goto while_break;
    }
#line 834
    tmp___1 = r_scan;
#line 834
    r_scan ++;
#line 834
    tmp___2 = y_scan;
#line 834
    y_scan ++;
#line 834
    tmp___3 = x_scan;
#line 834
    x_scan ++;
#line 834
    *tmp___1 = *tmp___2 & ~ *tmp___3;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 834
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 834
    if (! ((unsigned long )x_scan < (unsigned long )x_end)) {
#line 834
      goto while_break___0;
    }
#line 834
    tmp___4 = r_scan;
#line 834
    r_scan ++;
#line 834
    tmp___5 = x_scan;
#line 834
    x_scan ++;
#line 834
    *tmp___4 = 0L;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 834
  tmp___6 = bignum_trim(r);
  }
#line 834
  return (tmp___6);
}
}
#line 836 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
static bignum_type bignum_bitwise_xor_unsigned(bignum_type x , bignum_type y ) 
{ 
  bignum_type t ;
  bignum_length_type x_length ;
  bignum_length_type y_length ;
  bignum_length_type r_length ;
  bignum_type r ;
  bignum_type tmp ;
  bignum_digit_type *x_scan ;
  bignum_digit_type *x_end ;
  bignum_digit_type *y_scan ;
  bignum_digit_type *y_end ;
  bignum_digit_type *r_scan ;
  bignum_digit_type *tmp___0 ;
  bignum_digit_type *tmp___1 ;
  bignum_digit_type *tmp___2 ;
  bignum_digit_type *tmp___3 ;
  bignum_digit_type *tmp___4 ;
  bignum_type tmp___5 ;

  {
#line 836
  if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(x & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL)) < ((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(y & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL))) {
    {
#line 836
    while (1) {
      while_continue: /* CIL Label */ ;
#line 836
      t = y;
#line 836
      y = x;
#line 836
      x = t;
#line 836
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 836
  x_length = (bignum_length_type )((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(x & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL));
#line 836
  y_length = (bignum_length_type )((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(y & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL));
#line 836
  r_length = x_length;
#line 836
  tmp = bignum_allocate(r_length, 0);
#line 836
  r = tmp;
#line 836
  x_scan = (bignum_digit_type *)((SCHEME_OBJECT *)(x & 288230376151711743UL) + 1) + 1;
#line 836
  x_end = x_scan + x_length;
#line 836
  y_scan = (bignum_digit_type *)((SCHEME_OBJECT *)(y & 288230376151711743UL) + 1) + 1;
#line 836
  y_end = y_scan + y_length;
#line 836
  r_scan = (bignum_digit_type *)((SCHEME_OBJECT *)(r & 288230376151711743UL) + 1) + 1;
  }
#line 836
  if (! (x_length >= y_length)) {
    {
#line 836
    error_external_return();
    }
  }
  {
#line 836
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 836
    if (! ((unsigned long )y_scan < (unsigned long )y_end)) {
#line 836
      goto while_break___0;
    }
#line 836
    tmp___0 = r_scan;
#line 836
    r_scan ++;
#line 836
    tmp___1 = x_scan;
#line 836
    x_scan ++;
#line 836
    tmp___2 = y_scan;
#line 836
    y_scan ++;
#line 836
    *tmp___0 = *tmp___1 ^ *tmp___2;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 836
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 836
    if (! ((unsigned long )x_scan < (unsigned long )x_end)) {
#line 836
      goto while_break___1;
    }
#line 836
    tmp___3 = r_scan;
#line 836
    r_scan ++;
#line 836
    tmp___4 = x_scan;
#line 836
    x_scan ++;
#line 836
    *tmp___3 = *tmp___4;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 836
  tmp___5 = bignum_trim(r);
  }
#line 836
  return (tmp___5);
}
}
#line 837 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
static bignum_type bignum_bitwise_ior_unsigned(bignum_type x , bignum_type y ) 
{ 
  bignum_type t ;
  bignum_length_type x_length ;
  bignum_length_type y_length ;
  bignum_length_type r_length ;
  bignum_type r ;
  bignum_type tmp ;
  bignum_digit_type *x_scan ;
  bignum_digit_type *x_end ;
  bignum_digit_type *y_scan ;
  bignum_digit_type *y_end ;
  bignum_digit_type *r_scan ;
  bignum_digit_type *tmp___0 ;
  bignum_digit_type *tmp___1 ;
  bignum_digit_type *tmp___2 ;
  bignum_digit_type *tmp___3 ;
  bignum_digit_type *tmp___4 ;
  bignum_type tmp___5 ;

  {
#line 837
  if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(x & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL)) < ((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(y & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL))) {
    {
#line 837
    while (1) {
      while_continue: /* CIL Label */ ;
#line 837
      t = y;
#line 837
      y = x;
#line 837
      x = t;
#line 837
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 837
  x_length = (bignum_length_type )((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(x & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL));
#line 837
  y_length = (bignum_length_type )((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(y & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL));
#line 837
  r_length = x_length;
#line 837
  tmp = bignum_allocate(r_length, 0);
#line 837
  r = tmp;
#line 837
  x_scan = (bignum_digit_type *)((SCHEME_OBJECT *)(x & 288230376151711743UL) + 1) + 1;
#line 837
  x_end = x_scan + x_length;
#line 837
  y_scan = (bignum_digit_type *)((SCHEME_OBJECT *)(y & 288230376151711743UL) + 1) + 1;
#line 837
  y_end = y_scan + y_length;
#line 837
  r_scan = (bignum_digit_type *)((SCHEME_OBJECT *)(r & 288230376151711743UL) + 1) + 1;
  }
#line 837
  if (! (x_length >= y_length)) {
    {
#line 837
    error_external_return();
    }
  }
  {
#line 837
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 837
    if (! ((unsigned long )y_scan < (unsigned long )y_end)) {
#line 837
      goto while_break___0;
    }
#line 837
    tmp___0 = r_scan;
#line 837
    r_scan ++;
#line 837
    tmp___1 = x_scan;
#line 837
    x_scan ++;
#line 837
    tmp___2 = y_scan;
#line 837
    y_scan ++;
#line 837
    *tmp___0 = *tmp___1 | *tmp___2;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 837
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 837
    if (! ((unsigned long )x_scan < (unsigned long )x_end)) {
#line 837
      goto while_break___1;
    }
#line 837
    tmp___3 = r_scan;
#line 837
    r_scan ++;
#line 837
    tmp___4 = x_scan;
#line 837
    x_scan ++;
#line 837
    *tmp___3 = *tmp___4;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 837
  tmp___5 = bignum_trim(r);
  }
#line 837
  return (tmp___5);
}
}
#line 838 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
static bignum_type bignum_bitwise_nor_unsigned(bignum_type x , bignum_type y ) 
{ 
  bignum_type t ;
  bignum_length_type x_length ;
  bignum_length_type y_length ;
  bignum_length_type r_length ;
  bignum_type r ;
  bignum_type tmp ;
  bignum_digit_type *x_scan ;
  bignum_digit_type *x_end ;
  bignum_digit_type *y_scan ;
  bignum_digit_type *y_end ;
  bignum_digit_type *r_scan ;
  bignum_digit_type *tmp___0 ;
  bignum_digit_type *tmp___1 ;
  bignum_digit_type *tmp___2 ;
  bignum_digit_type *tmp___3 ;
  bignum_digit_type *tmp___4 ;
  bignum_type tmp___5 ;
  bignum_type tmp___6 ;

  {
#line 838
  if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(x & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL)) < ((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(y & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL))) {
    {
#line 838
    while (1) {
      while_continue: /* CIL Label */ ;
#line 838
      t = y;
#line 838
      y = x;
#line 838
      x = t;
#line 838
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 838
  x_length = (bignum_length_type )((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(x & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL));
#line 838
  y_length = (bignum_length_type )((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(y & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL));
#line 838
  r_length = x_length;
#line 838
  tmp = bignum_allocate(r_length, 0);
#line 838
  r = tmp;
#line 838
  x_scan = (bignum_digit_type *)((SCHEME_OBJECT *)(x & 288230376151711743UL) + 1) + 1;
#line 838
  x_end = x_scan + x_length;
#line 838
  y_scan = (bignum_digit_type *)((SCHEME_OBJECT *)(y & 288230376151711743UL) + 1) + 1;
#line 838
  y_end = y_scan + y_length;
#line 838
  r_scan = (bignum_digit_type *)((SCHEME_OBJECT *)(r & 288230376151711743UL) + 1) + 1;
  }
#line 838
  if (! (x_length >= y_length)) {
    {
#line 838
    error_external_return();
    }
  }
  {
#line 838
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 838
    if (! ((unsigned long )y_scan < (unsigned long )y_end)) {
#line 838
      goto while_break___0;
    }
#line 838
    tmp___0 = r_scan;
#line 838
    r_scan ++;
#line 838
    tmp___1 = x_scan;
#line 838
    x_scan ++;
#line 838
    tmp___2 = y_scan;
#line 838
    y_scan ++;
#line 838
    *tmp___0 = *tmp___1 | *tmp___2;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 838
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 838
    if (! ((unsigned long )x_scan < (unsigned long )x_end)) {
#line 838
      goto while_break___1;
    }
#line 838
    tmp___3 = r_scan;
#line 838
    r_scan ++;
#line 838
    tmp___4 = x_scan;
#line 838
    x_scan ++;
#line 838
    *tmp___3 = *tmp___4;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 838
  tmp___5 = bignum_trim(r);
#line 838
  tmp___6 = bignum_bitwise_not(tmp___5);
  }
#line 838
  return (tmp___6);
}
}
#line 839 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
static bignum_type bignum_bitwise_eqv_unsigned(bignum_type x , bignum_type y ) 
{ 
  bignum_type t ;
  bignum_length_type x_length ;
  bignum_length_type y_length ;
  bignum_length_type r_length ;
  bignum_type r ;
  bignum_type tmp ;
  bignum_digit_type *x_scan ;
  bignum_digit_type *x_end ;
  bignum_digit_type *y_scan ;
  bignum_digit_type *y_end ;
  bignum_digit_type *r_scan ;
  bignum_digit_type *tmp___0 ;
  bignum_digit_type *tmp___1 ;
  bignum_digit_type *tmp___2 ;
  bignum_digit_type *tmp___3 ;
  bignum_digit_type *tmp___4 ;
  bignum_type tmp___5 ;
  bignum_type tmp___6 ;

  {
#line 839
  if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(x & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL)) < ((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(y & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL))) {
    {
#line 839
    while (1) {
      while_continue: /* CIL Label */ ;
#line 839
      t = y;
#line 839
      y = x;
#line 839
      x = t;
#line 839
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 839
  x_length = (bignum_length_type )((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(x & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL));
#line 839
  y_length = (bignum_length_type )((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(y & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL));
#line 839
  r_length = x_length;
#line 839
  tmp = bignum_allocate(r_length, 0);
#line 839
  r = tmp;
#line 839
  x_scan = (bignum_digit_type *)((SCHEME_OBJECT *)(x & 288230376151711743UL) + 1) + 1;
#line 839
  x_end = x_scan + x_length;
#line 839
  y_scan = (bignum_digit_type *)((SCHEME_OBJECT *)(y & 288230376151711743UL) + 1) + 1;
#line 839
  y_end = y_scan + y_length;
#line 839
  r_scan = (bignum_digit_type *)((SCHEME_OBJECT *)(r & 288230376151711743UL) + 1) + 1;
  }
#line 839
  if (! (x_length >= y_length)) {
    {
#line 839
    error_external_return();
    }
  }
  {
#line 839
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 839
    if (! ((unsigned long )y_scan < (unsigned long )y_end)) {
#line 839
      goto while_break___0;
    }
#line 839
    tmp___0 = r_scan;
#line 839
    r_scan ++;
#line 839
    tmp___1 = x_scan;
#line 839
    x_scan ++;
#line 839
    tmp___2 = y_scan;
#line 839
    y_scan ++;
#line 839
    *tmp___0 = *tmp___1 ^ *tmp___2;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 839
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 839
    if (! ((unsigned long )x_scan < (unsigned long )x_end)) {
#line 839
      goto while_break___1;
    }
#line 839
    tmp___3 = r_scan;
#line 839
    r_scan ++;
#line 839
    tmp___4 = x_scan;
#line 839
    x_scan ++;
#line 839
    *tmp___3 = *tmp___4;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 839
  tmp___5 = bignum_trim(r);
#line 839
  tmp___6 = bignum_bitwise_not(tmp___5);
  }
#line 839
  return (tmp___6);
}
}
#line 844 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
static bignum_type bignum_bitwise_nand_unsigned(bignum_type x , bignum_type y ) 
{ 
  bignum_type t ;
  bignum_length_type x_length ;
  bignum_length_type y_length ;
  bignum_length_type r_length ;
  bignum_type r ;
  bignum_type tmp ;
  bignum_digit_type *x_scan ;
  bignum_digit_type *x_end ;
  bignum_digit_type *y_scan ;
  bignum_digit_type *y_end ;
  bignum_digit_type *r_scan ;
  bignum_digit_type *tmp___0 ;
  bignum_digit_type *tmp___1 ;
  bignum_digit_type *tmp___2 ;
  bignum_digit_type *tmp___3 ;
  bignum_digit_type *tmp___4 ;
  bignum_type tmp___5 ;
  bignum_type tmp___6 ;

  {
#line 844
  if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(x & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL)) < ((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(y & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL))) {
    {
#line 844
    while (1) {
      while_continue: /* CIL Label */ ;
#line 844
      t = y;
#line 844
      y = x;
#line 844
      x = t;
#line 844
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 844
  x_length = (bignum_length_type )((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(x & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL));
#line 844
  y_length = (bignum_length_type )((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(y & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL));
#line 844
  r_length = x_length;
#line 844
  tmp = bignum_allocate(r_length, 0);
#line 844
  r = tmp;
#line 844
  x_scan = (bignum_digit_type *)((SCHEME_OBJECT *)(x & 288230376151711743UL) + 1) + 1;
#line 844
  x_end = x_scan + x_length;
#line 844
  y_scan = (bignum_digit_type *)((SCHEME_OBJECT *)(y & 288230376151711743UL) + 1) + 1;
#line 844
  y_end = y_scan + y_length;
#line 844
  r_scan = (bignum_digit_type *)((SCHEME_OBJECT *)(r & 288230376151711743UL) + 1) + 1;
  }
#line 844
  if (! (x_length >= y_length)) {
    {
#line 844
    error_external_return();
    }
  }
  {
#line 844
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 844
    if (! ((unsigned long )y_scan < (unsigned long )y_end)) {
#line 844
      goto while_break___0;
    }
#line 844
    tmp___0 = r_scan;
#line 844
    r_scan ++;
#line 844
    tmp___1 = x_scan;
#line 844
    x_scan ++;
#line 844
    tmp___2 = y_scan;
#line 844
    y_scan ++;
#line 844
    *tmp___0 = *tmp___1 & *tmp___2;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 844
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 844
    if (! ((unsigned long )x_scan < (unsigned long )x_end)) {
#line 844
      goto while_break___1;
    }
#line 844
    tmp___3 = r_scan;
#line 844
    r_scan ++;
#line 844
    tmp___4 = x_scan;
#line 844
    x_scan ++;
#line 844
    *tmp___3 = 0L;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 844
  tmp___5 = bignum_trim(r);
#line 844
  tmp___6 = bignum_bitwise_not(tmp___5);
  }
#line 844
  return (tmp___6);
}
}
#line 847 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
static bignum_type bignum_bitwise_orc2_unsigned(bignum_type x , bignum_type y ) 
{ 
  bignum_type tmp ;
  bignum_type tmp___0 ;

  {
  {
#line 850
  tmp = bignum_bitwise_andc1(x, y);
#line 850
  tmp___0 = bignum_bitwise_not(tmp);
  }
#line 850
  return (tmp___0);
}
}
#line 853 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
static bignum_type bignum_bitwise_orc1_unsigned(bignum_type x , bignum_type y ) 
{ 
  bignum_type tmp ;
  bignum_type tmp___0 ;

  {
  {
#line 856
  tmp = bignum_bitwise_andc2(x, y);
#line 856
  tmp___0 = bignum_bitwise_not(tmp);
  }
#line 856
  return (tmp___0);
}
}
#line 880 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
bignum_type bignum_bitwise_and(bignum_type x , bignum_type y ) 
{ 
  bignum_type tmp ;
  bignum_type tmp___0 ;
  bignum_type tmp___3 ;
  bignum_type tmp___4 ;
  bignum_type tmp___5 ;
  bignum_type tmp___6 ;
  enum bignum_comparison tmp___7 ;
  bignum_type tmp___9 ;
  bignum_type tmp___10 ;
  bignum_type tmp___11 ;
  bignum_type tmp___12 ;
  bignum_type tmp___13 ;
  bignum_type tmp___14 ;
  enum bignum_comparison tmp___15 ;
  bignum_type tmp___16 ;
  enum bignum_comparison tmp___17 ;

  {
#line 880
  if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(x & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL)) == 0UL) {
    {
#line 880
    tmp = bignum_make_zero();
    }
#line 880
    return (tmp);
  }
#line 880
  if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(y & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL)) == 0UL) {
    {
#line 880
    tmp___0 = bignum_make_zero();
    }
#line 880
    return (tmp___0);
  }
  {
#line 880
  tmp___17 = bignum_test(x);
  }
#line 880
  if ((unsigned int )tmp___17 == 2U) {
    {
#line 880
    tmp___7 = bignum_test(y);
    }
#line 880
    if ((unsigned int )tmp___7 == 2U) {
      {
#line 880
      tmp___3 = bignum_bitwise_and_unsigned(x, y);
#line 880
      tmp___6 = tmp___3;
      }
    } else {
      {
#line 880
      tmp___4 = bignum_bitwise_not(y);
#line 880
      tmp___5 = bignum_bitwise_andc2_unsigned(x, tmp___4);
#line 880
      tmp___6 = tmp___5;
      }
    }
#line 880
    tmp___16 = tmp___6;
  } else {
    {
#line 880
    tmp___15 = bignum_test(y);
    }
#line 880
    if ((unsigned int )tmp___15 == 2U) {
      {
#line 880
      tmp___9 = bignum_bitwise_not(x);
#line 880
      tmp___10 = bignum_bitwise_andc1_unsigned(tmp___9, y);
#line 880
      tmp___14 = tmp___10;
      }
    } else {
      {
#line 880
      tmp___11 = bignum_bitwise_not(y);
#line 880
      tmp___12 = bignum_bitwise_not(x);
#line 880
      tmp___13 = bignum_bitwise_nor_unsigned(tmp___12, tmp___11);
#line 880
      tmp___14 = tmp___13;
      }
    }
#line 880
    tmp___16 = tmp___14;
  }
#line 880
  return (tmp___16);
}
}
#line 883 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
bignum_type bignum_bitwise_andc2(bignum_type x , bignum_type y ) 
{ 
  bignum_type tmp ;
  bignum_type tmp___2 ;
  bignum_type tmp___3 ;
  bignum_type tmp___4 ;
  bignum_type tmp___5 ;
  enum bignum_comparison tmp___6 ;
  bignum_type tmp___8 ;
  bignum_type tmp___9 ;
  bignum_type tmp___10 ;
  bignum_type tmp___11 ;
  bignum_type tmp___12 ;
  bignum_type tmp___13 ;
  enum bignum_comparison tmp___14 ;
  bignum_type tmp___15 ;
  enum bignum_comparison tmp___16 ;

  {
#line 883
  if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(x & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL)) == 0UL) {
    {
#line 883
    tmp = bignum_make_zero();
    }
#line 883
    return (tmp);
  }
#line 883
  if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(y & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL)) == 0UL) {
#line 883
    return (x);
  }
  {
#line 883
  tmp___16 = bignum_test(x);
  }
#line 883
  if ((unsigned int )tmp___16 == 2U) {
    {
#line 883
    tmp___6 = bignum_test(y);
    }
#line 883
    if ((unsigned int )tmp___6 == 2U) {
      {
#line 883
      tmp___2 = bignum_bitwise_andc2_unsigned(x, y);
#line 883
      tmp___5 = tmp___2;
      }
    } else {
      {
#line 883
      tmp___3 = bignum_bitwise_not(y);
#line 883
      tmp___4 = bignum_bitwise_and_unsigned(x, tmp___3);
#line 883
      tmp___5 = tmp___4;
      }
    }
#line 883
    tmp___15 = tmp___5;
  } else {
    {
#line 883
    tmp___14 = bignum_test(y);
    }
#line 883
    if ((unsigned int )tmp___14 == 2U) {
      {
#line 883
      tmp___8 = bignum_bitwise_not(x);
#line 883
      tmp___9 = bignum_bitwise_nor_unsigned(tmp___8, y);
#line 883
      tmp___13 = tmp___9;
      }
    } else {
      {
#line 883
      tmp___10 = bignum_bitwise_not(y);
#line 883
      tmp___11 = bignum_bitwise_not(x);
#line 883
      tmp___12 = bignum_bitwise_andc1_unsigned(tmp___11, tmp___10);
#line 883
      tmp___13 = tmp___12;
      }
    }
#line 883
    tmp___15 = tmp___13;
  }
#line 883
  return (tmp___15);
}
}
#line 886 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
bignum_type bignum_bitwise_andc1(bignum_type x , bignum_type y ) 
{ 
  bignum_type tmp ;
  bignum_type tmp___2 ;
  bignum_type tmp___3 ;
  bignum_type tmp___4 ;
  bignum_type tmp___5 ;
  enum bignum_comparison tmp___6 ;
  bignum_type tmp___8 ;
  bignum_type tmp___9 ;
  bignum_type tmp___10 ;
  bignum_type tmp___11 ;
  bignum_type tmp___12 ;
  bignum_type tmp___13 ;
  enum bignum_comparison tmp___14 ;
  bignum_type tmp___15 ;
  enum bignum_comparison tmp___16 ;

  {
#line 886
  if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(x & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL)) == 0UL) {
#line 886
    return (y);
  }
#line 886
  if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(y & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL)) == 0UL) {
    {
#line 886
    tmp = bignum_make_zero();
    }
#line 886
    return (tmp);
  }
  {
#line 886
  tmp___16 = bignum_test(x);
  }
#line 886
  if ((unsigned int )tmp___16 == 2U) {
    {
#line 886
    tmp___6 = bignum_test(y);
    }
#line 886
    if ((unsigned int )tmp___6 == 2U) {
      {
#line 886
      tmp___2 = bignum_bitwise_andc1_unsigned(x, y);
#line 886
      tmp___5 = tmp___2;
      }
    } else {
      {
#line 886
      tmp___3 = bignum_bitwise_not(y);
#line 886
      tmp___4 = bignum_bitwise_nor_unsigned(x, tmp___3);
#line 886
      tmp___5 = tmp___4;
      }
    }
#line 886
    tmp___15 = tmp___5;
  } else {
    {
#line 886
    tmp___14 = bignum_test(y);
    }
#line 886
    if ((unsigned int )tmp___14 == 2U) {
      {
#line 886
      tmp___8 = bignum_bitwise_not(x);
#line 886
      tmp___9 = bignum_bitwise_and_unsigned(tmp___8, y);
#line 886
      tmp___13 = tmp___9;
      }
    } else {
      {
#line 886
      tmp___10 = bignum_bitwise_not(y);
#line 886
      tmp___11 = bignum_bitwise_not(x);
#line 886
      tmp___12 = bignum_bitwise_andc2_unsigned(tmp___11, tmp___10);
#line 886
      tmp___13 = tmp___12;
      }
    }
#line 886
    tmp___15 = tmp___13;
  }
#line 886
  return (tmp___15);
}
}
#line 889 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
bignum_type bignum_bitwise_xor(bignum_type x , bignum_type y ) 
{ 
  bignum_type tmp___1 ;
  bignum_type tmp___2 ;
  bignum_type tmp___3 ;
  bignum_type tmp___4 ;
  enum bignum_comparison tmp___5 ;
  bignum_type tmp___7 ;
  bignum_type tmp___8 ;
  bignum_type tmp___9 ;
  bignum_type tmp___10 ;
  bignum_type tmp___11 ;
  bignum_type tmp___12 ;
  enum bignum_comparison tmp___13 ;
  bignum_type tmp___14 ;
  enum bignum_comparison tmp___15 ;

  {
#line 889
  if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(x & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL)) == 0UL) {
#line 889
    return (y);
  }
#line 889
  if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(y & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL)) == 0UL) {
#line 889
    return (x);
  }
  {
#line 889
  tmp___15 = bignum_test(x);
  }
#line 889
  if ((unsigned int )tmp___15 == 2U) {
    {
#line 889
    tmp___5 = bignum_test(y);
    }
#line 889
    if ((unsigned int )tmp___5 == 2U) {
      {
#line 889
      tmp___1 = bignum_bitwise_xor_unsigned(x, y);
#line 889
      tmp___4 = tmp___1;
      }
    } else {
      {
#line 889
      tmp___2 = bignum_bitwise_not(y);
#line 889
      tmp___3 = bignum_bitwise_eqv_unsigned(x, tmp___2);
#line 889
      tmp___4 = tmp___3;
      }
    }
#line 889
    tmp___14 = tmp___4;
  } else {
    {
#line 889
    tmp___13 = bignum_test(y);
    }
#line 889
    if ((unsigned int )tmp___13 == 2U) {
      {
#line 889
      tmp___7 = bignum_bitwise_not(x);
#line 889
      tmp___8 = bignum_bitwise_eqv_unsigned(tmp___7, y);
#line 889
      tmp___12 = tmp___8;
      }
    } else {
      {
#line 889
      tmp___9 = bignum_bitwise_not(y);
#line 889
      tmp___10 = bignum_bitwise_not(x);
#line 889
      tmp___11 = bignum_bitwise_xor_unsigned(tmp___10, tmp___9);
#line 889
      tmp___12 = tmp___11;
      }
    }
#line 889
    tmp___14 = tmp___12;
  }
#line 889
  return (tmp___14);
}
}
#line 891 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
bignum_type bignum_bitwise_ior(bignum_type x , bignum_type y ) 
{ 
  bignum_type tmp___1 ;
  bignum_type tmp___2 ;
  bignum_type tmp___3 ;
  bignum_type tmp___4 ;
  enum bignum_comparison tmp___5 ;
  bignum_type tmp___7 ;
  bignum_type tmp___8 ;
  bignum_type tmp___9 ;
  bignum_type tmp___10 ;
  bignum_type tmp___11 ;
  bignum_type tmp___12 ;
  enum bignum_comparison tmp___13 ;
  bignum_type tmp___14 ;
  enum bignum_comparison tmp___15 ;

  {
#line 891
  if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(x & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL)) == 0UL) {
#line 891
    return (y);
  }
#line 891
  if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(y & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL)) == 0UL) {
#line 891
    return (x);
  }
  {
#line 891
  tmp___15 = bignum_test(x);
  }
#line 891
  if ((unsigned int )tmp___15 == 2U) {
    {
#line 891
    tmp___5 = bignum_test(y);
    }
#line 891
    if ((unsigned int )tmp___5 == 2U) {
      {
#line 891
      tmp___1 = bignum_bitwise_ior_unsigned(x, y);
#line 891
      tmp___4 = tmp___1;
      }
    } else {
      {
#line 891
      tmp___2 = bignum_bitwise_not(y);
#line 891
      tmp___3 = bignum_bitwise_orc2_unsigned(x, tmp___2);
#line 891
      tmp___4 = tmp___3;
      }
    }
#line 891
    tmp___14 = tmp___4;
  } else {
    {
#line 891
    tmp___13 = bignum_test(y);
    }
#line 891
    if ((unsigned int )tmp___13 == 2U) {
      {
#line 891
      tmp___7 = bignum_bitwise_not(x);
#line 891
      tmp___8 = bignum_bitwise_orc1_unsigned(tmp___7, y);
#line 891
      tmp___12 = tmp___8;
      }
    } else {
      {
#line 891
      tmp___9 = bignum_bitwise_not(y);
#line 891
      tmp___10 = bignum_bitwise_not(x);
#line 891
      tmp___11 = bignum_bitwise_nand_unsigned(tmp___10, tmp___9);
#line 891
      tmp___12 = tmp___11;
      }
    }
#line 891
    tmp___14 = tmp___12;
  }
#line 891
  return (tmp___14);
}
}
#line 893 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
bignum_type bignum_bitwise_nor(bignum_type x , bignum_type y ) 
{ 
  bignum_type tmp ;
  bignum_type tmp___0 ;
  bignum_type tmp___3 ;
  bignum_type tmp___4 ;
  bignum_type tmp___5 ;
  bignum_type tmp___6 ;
  enum bignum_comparison tmp___7 ;
  bignum_type tmp___9 ;
  bignum_type tmp___10 ;
  bignum_type tmp___11 ;
  bignum_type tmp___12 ;
  bignum_type tmp___13 ;
  bignum_type tmp___14 ;
  enum bignum_comparison tmp___15 ;
  bignum_type tmp___16 ;
  enum bignum_comparison tmp___17 ;

  {
#line 893
  if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(x & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL)) == 0UL) {
    {
#line 893
    tmp = bignum_bitwise_not(y);
    }
#line 893
    return (tmp);
  }
#line 893
  if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(y & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL)) == 0UL) {
    {
#line 893
    tmp___0 = bignum_bitwise_not(x);
    }
#line 893
    return (tmp___0);
  }
  {
#line 893
  tmp___17 = bignum_test(x);
  }
#line 893
  if ((unsigned int )tmp___17 == 2U) {
    {
#line 893
    tmp___7 = bignum_test(y);
    }
#line 893
    if ((unsigned int )tmp___7 == 2U) {
      {
#line 893
      tmp___3 = bignum_bitwise_nor_unsigned(x, y);
#line 893
      tmp___6 = tmp___3;
      }
    } else {
      {
#line 893
      tmp___4 = bignum_bitwise_not(y);
#line 893
      tmp___5 = bignum_bitwise_andc1_unsigned(x, tmp___4);
#line 893
      tmp___6 = tmp___5;
      }
    }
#line 893
    tmp___16 = tmp___6;
  } else {
    {
#line 893
    tmp___15 = bignum_test(y);
    }
#line 893
    if ((unsigned int )tmp___15 == 2U) {
      {
#line 893
      tmp___9 = bignum_bitwise_not(x);
#line 893
      tmp___10 = bignum_bitwise_andc2_unsigned(tmp___9, y);
#line 893
      tmp___14 = tmp___10;
      }
    } else {
      {
#line 893
      tmp___11 = bignum_bitwise_not(y);
#line 893
      tmp___12 = bignum_bitwise_not(x);
#line 893
      tmp___13 = bignum_bitwise_and_unsigned(tmp___12, tmp___11);
#line 893
      tmp___14 = tmp___13;
      }
    }
#line 893
    tmp___16 = tmp___14;
  }
#line 893
  return (tmp___16);
}
}
#line 898 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
bignum_type bignum_bitwise_eqv(bignum_type x , bignum_type y ) 
{ 
  bignum_type tmp ;
  bignum_type tmp___0 ;
  bignum_type tmp___3 ;
  bignum_type tmp___4 ;
  bignum_type tmp___5 ;
  bignum_type tmp___6 ;
  enum bignum_comparison tmp___7 ;
  bignum_type tmp___9 ;
  bignum_type tmp___10 ;
  bignum_type tmp___11 ;
  bignum_type tmp___12 ;
  bignum_type tmp___13 ;
  bignum_type tmp___14 ;
  enum bignum_comparison tmp___15 ;
  bignum_type tmp___16 ;
  enum bignum_comparison tmp___17 ;

  {
#line 898
  if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(x & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL)) == 0UL) {
    {
#line 898
    tmp = bignum_bitwise_not(y);
    }
#line 898
    return (tmp);
  }
#line 898
  if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(y & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL)) == 0UL) {
    {
#line 898
    tmp___0 = bignum_bitwise_not(x);
    }
#line 898
    return (tmp___0);
  }
  {
#line 898
  tmp___17 = bignum_test(x);
  }
#line 898
  if ((unsigned int )tmp___17 == 2U) {
    {
#line 898
    tmp___7 = bignum_test(y);
    }
#line 898
    if ((unsigned int )tmp___7 == 2U) {
      {
#line 898
      tmp___3 = bignum_bitwise_eqv_unsigned(x, y);
#line 898
      tmp___6 = tmp___3;
      }
    } else {
      {
#line 898
      tmp___4 = bignum_bitwise_not(y);
#line 898
      tmp___5 = bignum_bitwise_xor_unsigned(x, tmp___4);
#line 898
      tmp___6 = tmp___5;
      }
    }
#line 898
    tmp___16 = tmp___6;
  } else {
    {
#line 898
    tmp___15 = bignum_test(y);
    }
#line 898
    if ((unsigned int )tmp___15 == 2U) {
      {
#line 898
      tmp___9 = bignum_bitwise_not(x);
#line 898
      tmp___10 = bignum_bitwise_xor_unsigned(tmp___9, y);
#line 898
      tmp___14 = tmp___10;
      }
    } else {
      {
#line 898
      tmp___11 = bignum_bitwise_not(y);
#line 898
      tmp___12 = bignum_bitwise_not(x);
#line 898
      tmp___13 = bignum_bitwise_eqv_unsigned(tmp___12, tmp___11);
#line 898
      tmp___14 = tmp___13;
      }
    }
#line 898
    tmp___16 = tmp___14;
  }
#line 898
  return (tmp___16);
}
}
#line 903 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
bignum_type bignum_bitwise_orc2(bignum_type x , bignum_type y ) 
{ 
  bignum_type tmp ;
  bignum_type tmp___0 ;
  bignum_type tmp___3 ;
  bignum_type tmp___4 ;
  bignum_type tmp___5 ;
  bignum_type tmp___6 ;
  enum bignum_comparison tmp___7 ;
  bignum_type tmp___9 ;
  bignum_type tmp___10 ;
  bignum_type tmp___11 ;
  bignum_type tmp___12 ;
  bignum_type tmp___13 ;
  bignum_type tmp___14 ;
  enum bignum_comparison tmp___15 ;
  bignum_type tmp___16 ;
  enum bignum_comparison tmp___17 ;

  {
#line 903
  if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(x & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL)) == 0UL) {
    {
#line 903
    tmp = bignum_bitwise_not(y);
    }
#line 903
    return (tmp);
  }
#line 903
  if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(y & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL)) == 0UL) {
    {
#line 903
    tmp___0 = bignum_make_one(1);
    }
#line 903
    return (tmp___0);
  }
  {
#line 903
  tmp___17 = bignum_test(x);
  }
#line 903
  if ((unsigned int )tmp___17 == 2U) {
    {
#line 903
    tmp___7 = bignum_test(y);
    }
#line 903
    if ((unsigned int )tmp___7 == 2U) {
      {
#line 903
      tmp___3 = bignum_bitwise_orc2_unsigned(x, y);
#line 903
      tmp___6 = tmp___3;
      }
    } else {
      {
#line 903
      tmp___4 = bignum_bitwise_not(y);
#line 903
      tmp___5 = bignum_bitwise_ior_unsigned(x, tmp___4);
#line 903
      tmp___6 = tmp___5;
      }
    }
#line 903
    tmp___16 = tmp___6;
  } else {
    {
#line 903
    tmp___15 = bignum_test(y);
    }
#line 903
    if ((unsigned int )tmp___15 == 2U) {
      {
#line 903
      tmp___9 = bignum_bitwise_not(x);
#line 903
      tmp___10 = bignum_bitwise_nand_unsigned(tmp___9, y);
#line 903
      tmp___14 = tmp___10;
      }
    } else {
      {
#line 903
      tmp___11 = bignum_bitwise_not(y);
#line 903
      tmp___12 = bignum_bitwise_not(x);
#line 903
      tmp___13 = bignum_bitwise_orc1_unsigned(tmp___12, tmp___11);
#line 903
      tmp___14 = tmp___13;
      }
    }
#line 903
    tmp___16 = tmp___14;
  }
#line 903
  return (tmp___16);
}
}
#line 907 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
bignum_type bignum_bitwise_orc1(bignum_type x , bignum_type y ) 
{ 
  bignum_type tmp ;
  bignum_type tmp___0 ;
  bignum_type tmp___3 ;
  bignum_type tmp___4 ;
  bignum_type tmp___5 ;
  bignum_type tmp___6 ;
  enum bignum_comparison tmp___7 ;
  bignum_type tmp___9 ;
  bignum_type tmp___10 ;
  bignum_type tmp___11 ;
  bignum_type tmp___12 ;
  bignum_type tmp___13 ;
  bignum_type tmp___14 ;
  enum bignum_comparison tmp___15 ;
  bignum_type tmp___16 ;
  enum bignum_comparison tmp___17 ;

  {
#line 907
  if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(x & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL)) == 0UL) {
    {
#line 907
    tmp = bignum_make_one(1);
    }
#line 907
    return (tmp);
  }
#line 907
  if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(y & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL)) == 0UL) {
    {
#line 907
    tmp___0 = bignum_bitwise_not(x);
    }
#line 907
    return (tmp___0);
  }
  {
#line 907
  tmp___17 = bignum_test(x);
  }
#line 907
  if ((unsigned int )tmp___17 == 2U) {
    {
#line 907
    tmp___7 = bignum_test(y);
    }
#line 907
    if ((unsigned int )tmp___7 == 2U) {
      {
#line 907
      tmp___3 = bignum_bitwise_orc1_unsigned(x, y);
#line 907
      tmp___6 = tmp___3;
      }
    } else {
      {
#line 907
      tmp___4 = bignum_bitwise_not(y);
#line 907
      tmp___5 = bignum_bitwise_nand_unsigned(x, tmp___4);
#line 907
      tmp___6 = tmp___5;
      }
    }
#line 907
    tmp___16 = tmp___6;
  } else {
    {
#line 907
    tmp___15 = bignum_test(y);
    }
#line 907
    if ((unsigned int )tmp___15 == 2U) {
      {
#line 907
      tmp___9 = bignum_bitwise_not(x);
#line 907
      tmp___10 = bignum_bitwise_ior_unsigned(tmp___9, y);
#line 907
      tmp___14 = tmp___10;
      }
    } else {
      {
#line 907
      tmp___11 = bignum_bitwise_not(y);
#line 907
      tmp___12 = bignum_bitwise_not(x);
#line 907
      tmp___13 = bignum_bitwise_orc2_unsigned(tmp___12, tmp___11);
#line 907
      tmp___14 = tmp___13;
      }
    }
#line 907
    tmp___16 = tmp___14;
  }
#line 907
  return (tmp___16);
}
}
#line 911 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
bignum_type bignum_bitwise_nand(bignum_type x , bignum_type y ) 
{ 
  bignum_type tmp ;
  bignum_type tmp___0 ;
  bignum_type tmp___3 ;
  bignum_type tmp___4 ;
  bignum_type tmp___5 ;
  bignum_type tmp___6 ;
  enum bignum_comparison tmp___7 ;
  bignum_type tmp___9 ;
  bignum_type tmp___10 ;
  bignum_type tmp___11 ;
  bignum_type tmp___12 ;
  bignum_type tmp___13 ;
  bignum_type tmp___14 ;
  enum bignum_comparison tmp___15 ;
  bignum_type tmp___16 ;
  enum bignum_comparison tmp___17 ;

  {
#line 911
  if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(x & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL)) == 0UL) {
    {
#line 911
    tmp = bignum_make_one(1);
    }
#line 911
    return (tmp);
  }
#line 911
  if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(y & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL)) == 0UL) {
    {
#line 911
    tmp___0 = bignum_make_one(1);
    }
#line 911
    return (tmp___0);
  }
  {
#line 911
  tmp___17 = bignum_test(x);
  }
#line 911
  if ((unsigned int )tmp___17 == 2U) {
    {
#line 911
    tmp___7 = bignum_test(y);
    }
#line 911
    if ((unsigned int )tmp___7 == 2U) {
      {
#line 911
      tmp___3 = bignum_bitwise_nand_unsigned(x, y);
#line 911
      tmp___6 = tmp___3;
      }
    } else {
      {
#line 911
      tmp___4 = bignum_bitwise_not(y);
#line 911
      tmp___5 = bignum_bitwise_orc1_unsigned(x, tmp___4);
#line 911
      tmp___6 = tmp___5;
      }
    }
#line 911
    tmp___16 = tmp___6;
  } else {
    {
#line 911
    tmp___15 = bignum_test(y);
    }
#line 911
    if ((unsigned int )tmp___15 == 2U) {
      {
#line 911
      tmp___9 = bignum_bitwise_not(x);
#line 911
      tmp___10 = bignum_bitwise_orc2_unsigned(tmp___9, y);
#line 911
      tmp___14 = tmp___10;
      }
    } else {
      {
#line 911
      tmp___11 = bignum_bitwise_not(y);
#line 911
      tmp___12 = bignum_bitwise_not(x);
#line 911
      tmp___13 = bignum_bitwise_ior_unsigned(tmp___12, tmp___11);
#line 911
      tmp___14 = tmp___13;
      }
    }
#line 911
    tmp___16 = tmp___14;
  }
#line 911
  return (tmp___16);
}
}
#line 1021 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
unsigned long bignum_length_in_bits(bignum_type bignum ) 
{ 
  bignum_length_type index___0 ;
  unsigned int tmp ;

  {
#line 1024
  if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(bignum & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL)) == 0UL) {
#line 1025
    return (0UL);
  }
  {
#line 1027
  index___0 = (bignum_length_type )(((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(bignum & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL)) - 1UL);
#line 1028
  tmp = ulong_length_in_bits((unsigned long )*(((bignum_digit_type *)((SCHEME_OBJECT *)(bignum & 288230376151711743UL) + 1) + 1) + index___0));
  }
#line 1028
  return ((unsigned long )tmp + (sizeof(bignum_digit_type ) * 8UL - 2UL) * (unsigned long )index___0);
}
}
#line 1036 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
unsigned long bignum_integer_length(bignum_type bignum ) 
{ 
  unsigned long length_in_bits ;
  unsigned long tmp ;
  enum bignum_comparison tmp___0 ;
  bignum_digit_type *scan ;
  bignum_digit_type *end ;
  bignum_digit_type *tmp___1 ;

  {
  {
#line 1039
  tmp = bignum_length_in_bits(bignum);
#line 1039
  length_in_bits = tmp;
  }
#line 1040
  if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(bignum & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL)) == 0UL) {
#line 1041
    return (length_in_bits);
  } else {
    {
#line 1040
    tmp___0 = bignum_test(bignum);
    }
#line 1040
    if ((unsigned int )tmp___0 == 2U) {
#line 1041
      return (length_in_bits);
    }
  }
#line 1051
  scan = (bignum_digit_type *)((SCHEME_OBJECT *)(bignum & 288230376151711743UL) + 1) + 1;
#line 1052
  end = (scan + ((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(bignum & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL))) - 1;
  {
#line 1053
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1053
    if (! ((unsigned long )scan < (unsigned long )end)) {
#line 1053
      goto while_break;
    }
#line 1054
    tmp___1 = scan;
#line 1054
    scan ++;
#line 1054
    if (0L != *tmp___1) {
#line 1055
      return (length_in_bits);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1056
  return (length_in_bits - (unsigned long )(0L == (*end & (*end - 1L))));
}
}
#line 1060 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
long bignum_first_set_bit(bignum_type bignum ) 
{ 
  bignum_digit_type *start ;
  bignum_digit_type *scan ;
  bignum_digit_type *end ;
  unsigned int tmp ;

  {
#line 1063
  if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(bignum & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL)) == 0UL) {
#line 1064
    return (-1L);
  }
#line 1066
  start = (bignum_digit_type *)((SCHEME_OBJECT *)(bignum & 288230376151711743UL) + 1) + 1;
#line 1067
  scan = start;
#line 1068
  end = scan + ((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(bignum & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL));
  {
#line 1069
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1069
    if (! ((unsigned long )scan < (unsigned long )end)) {
#line 1069
      goto while_break;
    }
#line 1071
    if (*scan != 0L) {
#line 1071
      goto while_break;
    }
#line 1072
    scan ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1074
  if (! ((unsigned long )scan < (unsigned long )end)) {
    {
#line 1074
    error_external_return();
    }
  }
  {
#line 1075
  tmp = ulong_bit_count((unsigned long )((*scan ^ (*scan - 1L)) >> 1));
  }
#line 1075
  return ((long )((unsigned long )tmp + (unsigned long )(scan - start) * (sizeof(bignum_digit_type ) * 8UL - 2UL)));
}
}
#line 1081 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
__inline static unsigned long digits_bit_count(bignum_digit_type **scan_loc , unsigned long count ) 
{ 
  unsigned long bit_count ;
  bignum_digit_type *end ;
  bignum_digit_type *tmp ;
  unsigned int tmp___0 ;

  {
#line 1084
  bit_count = 0UL;
#line 1085
  end = *scan_loc + count;
  {
#line 1086
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1086
    if (! ((unsigned long )*scan_loc < (unsigned long )end)) {
#line 1086
      goto while_break;
    }
    {
#line 1087
    tmp = *scan_loc;
#line 1087
    (*scan_loc) ++;
#line 1087
    tmp___0 = ulong_bit_count((unsigned long )*tmp);
#line 1087
    bit_count += (unsigned long )tmp___0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1088
  return (bit_count);
}
}
#line 1091 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
__inline static unsigned long digits_hamming_distance(bignum_digit_type **x_scan_loc ,
                                                      bignum_digit_type **y_scan_loc ,
                                                      unsigned long count ) 
{ 
  unsigned long hamming_distance ;
  bignum_digit_type *end ;
  bignum_digit_type *tmp ;
  bignum_digit_type *tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 1096
  hamming_distance = 0UL;
#line 1097
  end = *x_scan_loc + count;
  {
#line 1098
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1098
    if (! ((unsigned long )*x_scan_loc < (unsigned long )end)) {
#line 1098
      goto while_break;
    }
    {
#line 1099
    tmp = *x_scan_loc;
#line 1099
    (*x_scan_loc) ++;
#line 1099
    tmp___0 = *y_scan_loc;
#line 1099
    (*y_scan_loc) ++;
#line 1099
    tmp___1 = ulong_bit_count((unsigned long )(*tmp ^ *tmp___0));
#line 1099
    hamming_distance += (unsigned long )tmp___1;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1101
  return (hamming_distance);
}
}
#line 1106 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
static unsigned long bignum_positive_hamming_distance(bignum_type x , bignum_type y ) 
{ 
  enum bignum_comparison tmp ;
  enum bignum_comparison tmp___0 ;
  bignum_type t ;
  bignum_digit_type *x_scan ;
  bignum_digit_type *y_scan ;
  unsigned long hamming_distance ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;

  {
#line 1109
  if (! (! (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(x & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL)) == 0UL))) {
    {
#line 1109
    error_external_return();
    }
  }
#line 1110
  if (! (! (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(y & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL)) == 0UL))) {
    {
#line 1110
    error_external_return();
    }
  }
  {
#line 1111
  tmp = bignum_test(x);
  }
#line 1111
  if (! ((unsigned int )tmp == 2U)) {
    {
#line 1111
    error_external_return();
    }
  }
  {
#line 1112
  tmp___0 = bignum_test(y);
  }
#line 1112
  if (! ((unsigned int )tmp___0 == 2U)) {
    {
#line 1112
    error_external_return();
    }
  }
#line 1113
  if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(x & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL)) < ((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(y & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL))) {
#line 1115
    t = x;
#line 1115
    x = y;
#line 1115
    y = t;
  }
  {
#line 1118
  x_scan = (bignum_digit_type *)((SCHEME_OBJECT *)(x & 288230376151711743UL) + 1) + 1;
#line 1119
  y_scan = (bignum_digit_type *)((SCHEME_OBJECT *)(y & 288230376151711743UL) + 1) + 1;
#line 1120
  tmp___1 = digits_hamming_distance(& x_scan, & y_scan, (unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(y & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL));
#line 1120
  hamming_distance = tmp___1;
#line 1123
  tmp___2 = digits_bit_count(& x_scan, ((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(x & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL)) - ((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(y & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL)));
#line 1123
  hamming_distance += tmp___2;
  }
#line 1126
  return (hamming_distance);
}
}
#line 1213 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
static unsigned long bignum_bit_count_unsigned(bignum_type x ) 
{ 
  bignum_digit_type *scan ;
  unsigned long tmp ;

  {
  {
#line 1216
  scan = (bignum_digit_type *)((SCHEME_OBJECT *)(x & 288230376151711743UL) + 1) + 1;
#line 1217
  tmp = digits_bit_count(& scan, (unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(x & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL));
  }
#line 1217
  return (tmp);
}
}
#line 1220 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
static unsigned long bignum_negative_hamming_distance(bignum_type x , bignum_type y ) 
{ 
  unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;

  {
  {
#line 1223
  x = bignum_bitwise_not(x);
#line 1224
  y = bignum_bitwise_not(y);
  }
#line 1225
  if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(x & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL)) == 0UL) {
    {
#line 1225
    tmp = bignum_bit_count_unsigned(y);
    }
#line 1225
    return (tmp);
  }
#line 1226
  if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(y & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL)) == 0UL) {
    {
#line 1226
    tmp___0 = bignum_bit_count_unsigned(x);
    }
#line 1226
    return (tmp___0);
  }
  {
#line 1227
  tmp___1 = bignum_positive_hamming_distance(x, y);
  }
#line 1227
  return (tmp___1);
}
}
#line 1230 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
unsigned long bignum_bit_count(bignum_type x ) 
{ 
  bignum_type tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;

  {
#line 1233
  if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(x & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL)) == 0UL) {
#line 1234
    return (0UL);
  }
#line 1235
  if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(x & 288230376151711743UL) + 1)) & (1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL))) != 0UL) {
    {
#line 1237
    tmp = bignum_bitwise_not(x);
#line 1237
    tmp___0 = bignum_bit_count_unsigned(tmp);
    }
#line 1237
    return (tmp___0);
  } else {
    {
#line 1239
    tmp___1 = bignum_bit_count_unsigned(x);
    }
#line 1239
    return (tmp___1);
  }
}
}
#line 1242 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
long bignum_hamming_distance(bignum_type x , bignum_type y ) 
{ 
  unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___5 ;
  unsigned long tmp___6 ;
  enum bignum_comparison tmp___7 ;
  unsigned long tmp___9 ;
  unsigned long tmp___10 ;
  enum bignum_comparison tmp___11 ;
  unsigned long tmp___12 ;
  enum bignum_comparison tmp___13 ;

  {
#line 1245
  if (x == y) {
#line 1246
    return (0L);
  }
#line 1247
  if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(x & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL)) == 0UL) {
#line 1248
    if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(y & 288230376151711743UL) + 1)) & (1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL))) != 0UL) {
#line 1248
      tmp___0 = 0xffffffffffffffffUL;
    } else {
      {
#line 1248
      tmp = bignum_bit_count_unsigned(y);
#line 1248
      tmp___0 = tmp;
      }
    }
#line 1248
    return ((long )tmp___0);
  }
#line 1249
  if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(y & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL)) == 0UL) {
#line 1250
    if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(x & 288230376151711743UL) + 1)) & (1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL))) != 0UL) {
#line 1250
      tmp___2 = 0xffffffffffffffffUL;
    } else {
      {
#line 1250
      tmp___1 = bignum_bit_count_unsigned(x);
#line 1250
      tmp___2 = tmp___1;
      }
    }
#line 1250
    return ((long )tmp___2);
  }
  {
#line 1251
  tmp___13 = bignum_test(x);
  }
#line 1251
  if ((unsigned int )tmp___13 == 2U) {
    {
#line 1251
    tmp___7 = bignum_test(y);
    }
#line 1251
    if ((unsigned int )tmp___7 == 2U) {
      {
#line 1251
      tmp___5 = bignum_positive_hamming_distance(x, y);
#line 1251
      tmp___6 = tmp___5;
      }
    } else {
#line 1251
      tmp___6 = 0xffffffffffffffffUL;
    }
#line 1251
    tmp___12 = tmp___6;
  } else {
    {
#line 1251
    tmp___11 = bignum_test(y);
    }
#line 1251
    if ((unsigned int )tmp___11 == 2U) {
#line 1251
      tmp___10 = 0xffffffffffffffffUL;
    } else {
      {
#line 1251
      tmp___9 = bignum_negative_hamming_distance(x, y);
#line 1251
      tmp___10 = tmp___9;
      }
    }
#line 1251
    tmp___12 = tmp___10;
  }
#line 1251
  return ((long )tmp___12);
}
}
#line 1303 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
bignum_type bignum_nonnegative_one_bits(unsigned long size , unsigned long position___1 ) 
{ 
  bignum_type tmp ;
  bignum_type tmp___0 ;
  bignum_type tmp___1 ;
  bignum_type tmp___2 ;

  {
  {
#line 1306
  tmp = bignum_make_one(1);
#line 1306
  tmp___0 = bignum_shift_left(tmp, size);
#line 1306
  tmp___1 = bignum_bitwise_not(tmp___0);
#line 1306
  tmp___2 = bignum_shift_left(tmp___1, position___1);
  }
#line 1306
  return (tmp___2);
}
}
#line 1312 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
bignum_type bignum_negative_zero_bits(unsigned long n , unsigned long m ) 
{ 
  bignum_type tmp ;
  bignum_type tmp___0 ;

  {
  {
#line 1315
  tmp = bignum_nonnegative_one_bits(n, m);
#line 1315
  tmp___0 = bignum_bitwise_not(tmp);
  }
#line 1315
  return (tmp___0);
}
}
#line 1318 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
static bignum_type bignum_shift_right_unsigned(bignum_type n , unsigned long digits ,
                                               unsigned long bits ) 
{ 
  bignum_length_type n_length ;
  bignum_digit_type *n_start ;
  bignum_digit_type *n_scan ;
  bignum_digit_type *n_end ;
  bignum_length_type r_length ;
  int tmp ;
  bignum_type r ;
  bignum_type tmp___0 ;
  bignum_digit_type *r_scan ;
  bignum_digit_type *tmp___1 ;
  bignum_digit_type *tmp___2 ;
  bignum_digit_type mask ;
  bignum_digit_type shift ;
  bignum_digit_type extra ;
  bignum_digit_type *tmp___3 ;
  bignum_digit_type digit ;
  bignum_digit_type *tmp___4 ;
  bignum_digit_type *tmp___5 ;
  bignum_digit_type *tmp___6 ;

  {
#line 1323
  n_length = (bignum_length_type )((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(n & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL));
#line 1324
  n_start = (bignum_digit_type *)((SCHEME_OBJECT *)(n & 288230376151711743UL) + 1) + 1;
#line 1325
  n_scan = n_start + digits;
#line 1326
  n_end = n_start + n_length;
#line 1327
  if ((unsigned long )n_start < (unsigned long )n_end) {
#line 1327
    if (0L == *(n_end + -1) >> bits) {
#line 1327
      tmp = 1;
    } else {
#line 1327
      tmp = 0;
    }
  } else {
#line 1327
    tmp = 0;
  }
  {
#line 1327
  r_length = (bignum_length_type )(((unsigned long )n_length - digits) - (unsigned long )tmp);
#line 1330
  tmp___0 = bignum_allocate(r_length, 0);
#line 1330
  r = tmp___0;
#line 1331
  r_scan = (bignum_digit_type *)((SCHEME_OBJECT *)(r & 288230376151711743UL) + 1) + 1;
  }
#line 1332
  if (bits == 0UL) {
    {
#line 1333
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1333
      if (! ((unsigned long )n_scan < (unsigned long )n_end)) {
#line 1333
        goto while_break;
      }
#line 1334
      tmp___1 = r_scan;
#line 1334
      r_scan ++;
#line 1334
      tmp___2 = n_scan;
#line 1334
      n_scan ++;
#line 1334
      *tmp___1 = *tmp___2;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 1337
    mask = ~ (-1L << bits);
#line 1338
    shift = (bignum_digit_type )((sizeof(bignum_digit_type ) * 8UL - 2UL) - bits);
#line 1339
    tmp___3 = n_scan;
#line 1339
    n_scan ++;
#line 1339
    extra = *tmp___3 >> bits;
    {
#line 1340
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1340
      if (! ((unsigned long )n_scan < (unsigned long )n_end)) {
#line 1340
        goto while_break___0;
      }
#line 1342
      tmp___4 = n_scan;
#line 1342
      n_scan ++;
#line 1342
      digit = *tmp___4;
#line 1343
      tmp___5 = r_scan;
#line 1343
      r_scan ++;
#line 1343
      *tmp___5 = ((digit & mask) << shift) | extra;
#line 1344
      extra = digit >> bits;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1346
    if (extra != 0L) {
#line 1347
      tmp___6 = r_scan;
#line 1347
      r_scan ++;
#line 1347
      *tmp___6 = extra;
    }
#line 1348
    if (! ((unsigned long )r_scan == (unsigned long )(((bignum_digit_type *)((SCHEME_OBJECT *)(r & 288230376151711743UL) + 1) + 1) + r_length))) {
      {
#line 1348
      error_external_return();
      }
    }
  }
#line 1350
  return (r);
}
}
#line 1353 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
bignum_type bignum_shift_right(bignum_type n , unsigned long m ) 
{ 
  unsigned long digits ;
  unsigned long bits ;
  bignum_type tmp ;
  bignum_type tmp___0 ;
  bignum_type tmp___1 ;
  bignum_type tmp___2 ;
  bignum_type tmp___3 ;
  bignum_type tmp___4 ;
  bignum_type tmp___5 ;

  {
#line 1356
  digits = m / (sizeof(bignum_digit_type ) * 8UL - 2UL);
#line 1357
  bits = m % (sizeof(bignum_digit_type ) * 8UL - 2UL);
#line 1359
  if (digits >= ((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(n & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL))) {
#line 1360
    if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(n & 288230376151711743UL) + 1)) & (1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL))) != 0UL) {
      {
#line 1360
      tmp = bignum_make_one(1);
#line 1360
      tmp___1 = tmp;
      }
    } else {
      {
#line 1360
      tmp___0 = bignum_make_zero();
#line 1360
      tmp___1 = tmp___0;
      }
    }
#line 1360
    return (tmp___1);
  }
#line 1362
  if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(n & 288230376151711743UL) + 1)) & (1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL))) != 0UL) {
    {
#line 1363
    tmp___2 = bignum_bitwise_not(n);
#line 1363
    tmp___3 = bignum_shift_right_unsigned(tmp___2, digits, bits);
#line 1363
    tmp___4 = bignum_bitwise_not(tmp___3);
    }
#line 1363
    return (tmp___4);
  } else {
    {
#line 1367
    tmp___5 = bignum_shift_right_unsigned(n, digits, bits);
    }
#line 1367
    return (tmp___5);
  }
}
}
#line 1370 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
bignum_type bignum_shift_left(bignum_type n , unsigned long m ) 
{ 
  unsigned long ln ;
  unsigned long delta ;
  unsigned int tmp ;
  unsigned long zeroes ;
  unsigned long shift ;
  unsigned long ln2 ;
  bignum_type result ;
  bignum_type tmp___0 ;
  bignum_digit_type *scan_n ;
  bignum_digit_type *end_n ;
  bignum_digit_type *scan_result ;
  bignum_digit_type *tmp___1 ;
  unsigned long tmp___2 ;
  bignum_digit_type *tmp___3 ;
  bignum_digit_type *tmp___4 ;
  unsigned long temp ;
  bignum_digit_type digit ;
  bignum_digit_type *tmp___5 ;
  bignum_digit_type *tmp___6 ;

  {
#line 1373
  ln = (unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(n & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL);
#line 1374
  delta = 0UL;
#line 1375
  if (m == 0UL) {
#line 1376
    return (n);
  } else
#line 1375
  if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(n & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL)) == 0UL) {
#line 1376
    return (n);
  }
  {
#line 1378
  tmp = ulong_length_in_bits((unsigned long )*(((bignum_digit_type *)((SCHEME_OBJECT *)(n & 288230376151711743UL) + 1) + 1) + (ln - 1UL)));
#line 1378
  delta = (unsigned long )tmp;
#line 1381
  zeroes = m / (sizeof(bignum_digit_type ) * 8UL - 2UL);
#line 1382
  shift = m % (sizeof(bignum_digit_type ) * 8UL - 2UL);
#line 1383
  ln2 = ((ln - 1UL) + (delta + m) / (sizeof(bignum_digit_type ) * 8UL - 2UL)) + (unsigned long )((delta + m) % (sizeof(bignum_digit_type ) * 8UL - 2UL) != 0UL);
#line 1386
  tmp___0 = bignum_allocate((bignum_length_type )ln2, ((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(n & 288230376151711743UL) + 1)) & (1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL))) != 0UL);
#line 1386
  result = tmp___0;
#line 1387
  scan_n = (bignum_digit_type *)((SCHEME_OBJECT *)(n & 288230376151711743UL) + 1) + 1;
#line 1388
  end_n = scan_n + ln;
#line 1389
  scan_result = (bignum_digit_type *)((SCHEME_OBJECT *)(result & 288230376151711743UL) + 1) + 1;
  }
  {
#line 1390
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1390
    tmp___2 = zeroes;
#line 1390
    zeroes --;
#line 1390
    if (! (tmp___2 > 0UL)) {
#line 1390
      goto while_break;
    }
#line 1391
    tmp___1 = scan_result;
#line 1391
    scan_result ++;
#line 1391
    *tmp___1 = (bignum_digit_type )0;
  }
  while_break: /* CIL Label */ ;
  }
#line 1392
  if (shift == 0UL) {
    {
#line 1393
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1393
      if (! ((unsigned long )scan_n < (unsigned long )end_n)) {
#line 1393
        goto while_break___0;
      }
#line 1394
      tmp___3 = scan_result;
#line 1394
      scan_result ++;
#line 1394
      tmp___4 = scan_n;
#line 1394
      scan_n ++;
#line 1394
      *tmp___3 = *tmp___4;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 1397
    temp = 0UL;
    {
#line 1398
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1398
      if (! ((unsigned long )scan_n < (unsigned long )end_n)) {
#line 1398
        goto while_break___1;
      }
#line 1400
      tmp___5 = scan_n;
#line 1400
      scan_n ++;
#line 1400
      digit = *tmp___5;
#line 1401
      tmp___6 = scan_result;
#line 1401
      scan_result ++;
#line 1401
      *tmp___6 = (bignum_digit_type )(((unsigned long )(digit << shift) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL)) | temp);
#line 1402
      temp = (unsigned long )(digit >> ((sizeof(bignum_digit_type ) * 8UL - 2UL) - shift));
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1404
    if (temp != 0UL) {
#line 1405
      *scan_result = (bignum_digit_type )temp;
    }
  }
#line 1407
  return (result);
}
}
#line 1411 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
bignum_type unsigned_long_to_shifted_bignum(unsigned long n , unsigned long m , int sign ) 
{ 
  unsigned long delta ;
  bignum_type tmp ;
  unsigned int tmp___0 ;
  unsigned long zeroes ;
  unsigned long shift ;
  unsigned long ln ;
  bignum_type result ;
  bignum_type tmp___1 ;
  bignum_digit_type *scan_result ;
  bignum_digit_type *tmp___2 ;
  unsigned long tmp___3 ;
  bignum_digit_type *tmp___4 ;
  bignum_digit_type *tmp___5 ;

  {
#line 1414
  delta = 0UL;
#line 1415
  if (n == 0UL) {
    {
#line 1416
    tmp = bignum_make_zero();
    }
#line 1416
    return (tmp);
  }
  {
#line 1418
  tmp___0 = ulong_length_in_bits(n);
#line 1418
  delta = (unsigned long )tmp___0;
#line 1421
  zeroes = m / (sizeof(bignum_digit_type ) * 8UL - 2UL);
#line 1422
  shift = m % (sizeof(bignum_digit_type ) * 8UL - 2UL);
#line 1423
  ln = (delta + m) / (sizeof(bignum_digit_type ) * 8UL - 2UL) + (unsigned long )((delta + m) % (sizeof(bignum_digit_type ) * 8UL - 2UL) != 0UL);
#line 1426
  tmp___1 = bignum_allocate((bignum_length_type )ln, sign);
#line 1426
  result = tmp___1;
#line 1427
  scan_result = (bignum_digit_type *)((SCHEME_OBJECT *)(result & 288230376151711743UL) + 1) + 1;
  }
  {
#line 1428
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1428
    tmp___3 = zeroes;
#line 1428
    zeroes --;
#line 1428
    if (! (tmp___3 > 0UL)) {
#line 1428
      goto while_break;
    }
#line 1429
    tmp___2 = scan_result;
#line 1429
    scan_result ++;
#line 1429
    *tmp___2 = (bignum_digit_type )0;
  }
  while_break: /* CIL Label */ ;
  }
#line 1430
  tmp___4 = scan_result;
#line 1430
  scan_result ++;
#line 1430
  *tmp___4 = (bignum_digit_type )((n << shift) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL));
#line 1431
  n >>= (sizeof(bignum_digit_type ) * 8UL - 2UL) - shift;
  {
#line 1432
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1432
    if (! (n > 0UL)) {
#line 1432
      goto while_break___0;
    }
#line 1434
    tmp___5 = scan_result;
#line 1434
    scan_result ++;
#line 1434
    *tmp___5 = (bignum_digit_type )(n & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL));
#line 1435
    n >>= sizeof(bignum_digit_type ) * 8UL - 2UL;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1437
  return (result);
}
}
#line 1441 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
bignum_type digit_stream_to_bignum(unsigned int n_digits , unsigned int (*producer)(bignum_procedure_context  ) ,
                                   bignum_procedure_context context , unsigned int radix ,
                                   int negative_p ) 
{ 
  bignum_type tmp ;
  long digit ;
  unsigned int tmp___0 ;
  long tmp___1 ;
  bignum_type tmp___2 ;
  bignum_length_type length ;
  unsigned int tmp___3 ;
  bignum_type result ;
  bignum_type tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  bignum_type tmp___7 ;

  {
#line 1448
  if (radix > 1U) {
#line 1448
    if (! ((unsigned long )radix <= 1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL)) {
      {
#line 1448
      error_external_return();
      }
    }
  } else {
    {
#line 1448
    error_external_return();
    }
  }
#line 1449
  if (n_digits == 0U) {
    {
#line 1450
    tmp = bignum_make_zero();
    }
#line 1450
    return (tmp);
  }
#line 1451
  if (n_digits == 1U) {
    {
#line 1453
    tmp___0 = (*producer)(context);
#line 1453
    digit = (long )tmp___0;
    }
#line 1454
    if (negative_p) {
#line 1454
      tmp___1 = - digit;
    } else {
#line 1454
      tmp___1 = digit;
    }
    {
#line 1454
    tmp___2 = long_to_bignum(tmp___1);
    }
#line 1454
    return (tmp___2);
  }
  {
#line 1458
  tmp___3 = ulong_length_in_bits((unsigned long )radix);
#line 1458
  length = (bignum_length_type )(((unsigned long )(n_digits * tmp___3) + ((sizeof(bignum_digit_type ) * 8UL - 2UL) - 1UL)) / (sizeof(bignum_digit_type ) * 8UL - 2UL));
#line 1462
  tmp___4 = bignum_allocate_zeroed(length, negative_p);
#line 1462
  result = tmp___4;
  }
  {
#line 1463
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1463
    tmp___6 = n_digits;
#line 1463
    n_digits --;
#line 1463
    if (! (tmp___6 > 0U)) {
#line 1463
      goto while_break;
    }
    {
#line 1465
    bignum_destructive_scale_up(result, (bignum_digit_type )radix);
#line 1466
    tmp___5 = (*producer)(context);
#line 1466
    bignum_destructive_add(result, (bignum_digit_type )tmp___5);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1469
  tmp___7 = bignum_trim(result);
  }
#line 1469
  return (tmp___7);
}
}
#line 1474 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
void bignum_to_digit_stream(bignum_type bignum , unsigned int radix , void (*consumer)(bignum_procedure_context  ,
                                                                                       long  ) ,
                            bignum_procedure_context context ) 
{ 
  bignum_type working_copy ;
  bignum_type tmp ;
  bignum_digit_type *start ;
  bignum_digit_type *scan ;
  bignum_digit_type tmp___0 ;

  {
#line 1480
  if (radix > 1U) {
#line 1480
    if (! ((unsigned long )radix <= 1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL)) {
      {
#line 1480
      error_external_return();
      }
    }
  } else {
    {
#line 1480
    error_external_return();
    }
  }
#line 1481
  if (! (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(bignum & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL)) == 0UL)) {
    {
#line 1483
    tmp = bignum_copy(bignum);
#line 1483
    working_copy = tmp;
#line 1484
    start = (bignum_digit_type *)((SCHEME_OBJECT *)(working_copy & 288230376151711743UL) + 1) + 1;
#line 1485
    scan = start + ((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(working_copy & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL));
    }
    {
#line 1486
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1486
      if (! ((unsigned long )start < (unsigned long )scan)) {
#line 1486
        goto while_break;
      }
#line 1488
      if (*(scan + -1) == 0L) {
#line 1489
        scan --;
      } else {
        {
#line 1491
        tmp___0 = bignum_destructive_scale_down(working_copy, (bignum_digit_type )radix);
#line 1491
        (*consumer)(context, tmp___0);
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1494
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1494
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1496
  return;
}
}
#line 1499 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
long bignum_max_digit_stream_radix(void) 
{ 


  {
#line 1502
  return ((long )(1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL));
}
}
#line 1507 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
static int bignum_equal_p_unsigned(bignum_type x , bignum_type y ) 
{ 
  bignum_length_type length ;
  bignum_digit_type *scan_x ;
  bignum_digit_type *scan_y ;
  bignum_digit_type *end_x ;
  bignum_digit_type *tmp ;
  bignum_digit_type *tmp___0 ;

  {
#line 1510
  length = (bignum_length_type )((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(x & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL));
#line 1511
  if (length != (bignum_length_type )((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(y & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL))) {
#line 1512
    return (0);
  } else {
#line 1515
    scan_x = (bignum_digit_type *)((SCHEME_OBJECT *)(x & 288230376151711743UL) + 1) + 1;
#line 1516
    scan_y = (bignum_digit_type *)((SCHEME_OBJECT *)(y & 288230376151711743UL) + 1) + 1;
#line 1517
    end_x = scan_x + length;
    {
#line 1518
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1518
      if (! ((unsigned long )scan_x < (unsigned long )end_x)) {
#line 1518
        goto while_break;
      }
#line 1519
      tmp = scan_x;
#line 1519
      scan_x ++;
#line 1519
      tmp___0 = scan_y;
#line 1519
      scan_y ++;
#line 1519
      if (*tmp != *tmp___0) {
#line 1520
        return (0);
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 1521
    return (1);
  }
}
}
#line 1525 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
static enum bignum_comparison bignum_compare_unsigned(bignum_type x , bignum_type y ) 
{ 
  bignum_length_type x_length ;
  bignum_length_type y_length ;
  bignum_digit_type *start_x ;
  bignum_digit_type *scan_x ;
  bignum_digit_type *scan_y ;
  bignum_digit_type digit_x ;
  bignum_digit_type digit_y ;

  {
#line 1528
  x_length = (bignum_length_type )((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(x & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL));
#line 1529
  y_length = (bignum_length_type )((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(y & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL));
#line 1530
  if (x_length < y_length) {
#line 1531
    return ((enum bignum_comparison )1);
  }
#line 1532
  if (x_length > y_length) {
#line 1533
    return ((enum bignum_comparison )2);
  }
#line 1535
  start_x = (bignum_digit_type *)((SCHEME_OBJECT *)(x & 288230376151711743UL) + 1) + 1;
#line 1536
  scan_x = start_x + x_length;
#line 1537
  scan_y = ((bignum_digit_type *)((SCHEME_OBJECT *)(y & 288230376151711743UL) + 1) + 1) + y_length;
  {
#line 1538
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1538
    if (! ((unsigned long )start_x < (unsigned long )scan_x)) {
#line 1538
      goto while_break;
    }
#line 1540
    scan_x --;
#line 1540
    digit_x = *scan_x;
#line 1541
    scan_y --;
#line 1541
    digit_y = *scan_y;
#line 1542
    if (digit_x < digit_y) {
#line 1543
      return ((enum bignum_comparison )1);
    }
#line 1544
    if (digit_x > digit_y) {
#line 1545
      return ((enum bignum_comparison )2);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1548
  return ((enum bignum_comparison )0);
}
}
#line 1553 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
static bignum_type bignum_add_unsigned(bignum_type x , bignum_type y , int negative_p ) 
{ 
  bignum_type z ;
  bignum_length_type x_length ;
  bignum_type r ;
  bignum_type tmp ;
  bignum_digit_type sum ;
  bignum_digit_type carry ;
  bignum_digit_type *scan_x ;
  bignum_digit_type *scan_r ;
  bignum_digit_type *scan_y ;
  bignum_digit_type *end_y ;
  bignum_digit_type *tmp___0 ;
  bignum_digit_type *tmp___1 ;
  bignum_digit_type *tmp___2 ;
  bignum_digit_type *tmp___3 ;
  bignum_digit_type *end_x ;
  bignum_digit_type *tmp___4 ;
  bignum_digit_type *tmp___5 ;
  bignum_digit_type *tmp___6 ;
  bignum_digit_type *tmp___7 ;
  bignum_digit_type *tmp___8 ;
  bignum_type tmp___9 ;

  {
#line 1556
  if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(y & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL)) > ((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(x & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL))) {
#line 1558
    z = x;
#line 1559
    x = y;
#line 1560
    y = z;
  }
  {
#line 1563
  x_length = (bignum_length_type )((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(x & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL));
#line 1564
  tmp = bignum_allocate(x_length + 1L, negative_p);
#line 1564
  r = tmp;
#line 1566
  carry = (bignum_digit_type )0;
#line 1567
  scan_x = (bignum_digit_type *)((SCHEME_OBJECT *)(x & 288230376151711743UL) + 1) + 1;
#line 1568
  scan_r = (bignum_digit_type *)((SCHEME_OBJECT *)(r & 288230376151711743UL) + 1) + 1;
#line 1570
  scan_y = (bignum_digit_type *)((SCHEME_OBJECT *)(y & 288230376151711743UL) + 1) + 1;
#line 1571
  end_y = scan_y + ((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(y & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL));
  }
  {
#line 1572
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1572
    if (! ((unsigned long )scan_y < (unsigned long )end_y)) {
#line 1572
      goto while_break;
    }
#line 1574
    tmp___0 = scan_x;
#line 1574
    scan_x ++;
#line 1574
    tmp___1 = scan_y;
#line 1574
    scan_y ++;
#line 1574
    sum = (*tmp___0 + *tmp___1) + carry;
#line 1575
    if ((unsigned long )sum < 1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) {
#line 1577
      tmp___2 = scan_r;
#line 1577
      scan_r ++;
#line 1577
      *tmp___2 = sum;
#line 1578
      carry = (bignum_digit_type )0;
    } else {
#line 1582
      tmp___3 = scan_r;
#line 1582
      scan_r ++;
#line 1582
      *tmp___3 = (bignum_digit_type )((unsigned long )sum - (1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)));
#line 1583
      carry = (bignum_digit_type )1;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1588
  end_x = ((bignum_digit_type *)((SCHEME_OBJECT *)(x & 288230376151711743UL) + 1) + 1) + x_length;
#line 1589
  if (carry != 0L) {
    {
#line 1590
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1590
      if (! ((unsigned long )scan_x < (unsigned long )end_x)) {
#line 1590
        goto while_break___0;
      }
#line 1592
      tmp___4 = scan_x;
#line 1592
      scan_x ++;
#line 1592
      sum = *tmp___4 + 1L;
#line 1593
      if ((unsigned long )sum < 1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) {
#line 1595
        tmp___5 = scan_r;
#line 1595
        scan_r ++;
#line 1595
        *tmp___5 = sum;
#line 1596
        carry = (bignum_digit_type )0;
#line 1597
        goto while_break___0;
      } else {
#line 1600
        tmp___6 = scan_r;
#line 1600
        scan_r ++;
#line 1600
        *tmp___6 = (bignum_digit_type )((unsigned long )sum - (1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)));
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 1602
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1602
    if (! ((unsigned long )scan_x < (unsigned long )end_x)) {
#line 1602
      goto while_break___1;
    }
#line 1603
    tmp___7 = scan_r;
#line 1603
    scan_r ++;
#line 1603
    tmp___8 = scan_x;
#line 1603
    scan_x ++;
#line 1603
    *tmp___7 = *tmp___8;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1605
  if (carry != 0L) {
#line 1607
    *scan_r = (bignum_digit_type )1;
#line 1608
    return (r);
  }
  {
#line 1610
  tmp___9 = bignum_shorten_length(r, x_length);
  }
#line 1610
  return (tmp___9);
}
}
#line 1616 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
static bignum_type bignum_subtract_unsigned(bignum_type x , bignum_type y ) 
{ 
  int negative_p ;
  enum bignum_comparison tmp ;
  bignum_type tmp___0 ;
  bignum_type z ;
  bignum_length_type x_length ;
  bignum_type r ;
  bignum_type tmp___1 ;
  bignum_digit_type difference ;
  bignum_digit_type borrow ;
  bignum_digit_type *scan_x ;
  bignum_digit_type *scan_r ;
  bignum_digit_type *scan_y ;
  bignum_digit_type *end_y ;
  bignum_digit_type *tmp___2 ;
  bignum_digit_type *tmp___3 ;
  bignum_digit_type *tmp___4 ;
  bignum_digit_type *tmp___5 ;
  bignum_digit_type *end_x ;
  bignum_digit_type *tmp___6 ;
  bignum_digit_type *tmp___7 ;
  bignum_digit_type *tmp___8 ;
  bignum_digit_type *tmp___9 ;
  bignum_digit_type *tmp___10 ;
  bignum_type tmp___11 ;

  {
  {
#line 1619
  negative_p = 0;
#line 1620
  tmp = bignum_compare_unsigned(x, y);
  }
  {
#line 1622
  if ((unsigned int )tmp == 0U) {
#line 1622
    goto case_0;
  }
#line 1624
  if ((unsigned int )tmp == 1U) {
#line 1624
    goto case_1;
  }
#line 1632
  if ((unsigned int )tmp == 2U) {
#line 1632
    goto case_2;
  }
#line 1620
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 1623
  tmp___0 = bignum_make_zero();
  }
#line 1623
  return (tmp___0);
  case_1: /* CIL Label */ 
#line 1626
  z = x;
#line 1627
  x = y;
#line 1628
  y = z;
#line 1630
  negative_p = 1;
#line 1631
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1633
  negative_p = 0;
#line 1634
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1637
  x_length = (bignum_length_type )((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(x & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL));
#line 1638
  tmp___1 = bignum_allocate(x_length, negative_p);
#line 1638
  r = tmp___1;
#line 1640
  borrow = (bignum_digit_type )0;
#line 1641
  scan_x = (bignum_digit_type *)((SCHEME_OBJECT *)(x & 288230376151711743UL) + 1) + 1;
#line 1642
  scan_r = (bignum_digit_type *)((SCHEME_OBJECT *)(r & 288230376151711743UL) + 1) + 1;
#line 1644
  scan_y = (bignum_digit_type *)((SCHEME_OBJECT *)(y & 288230376151711743UL) + 1) + 1;
#line 1645
  end_y = scan_y + ((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(y & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL));
  }
  {
#line 1646
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1646
    if (! ((unsigned long )scan_y < (unsigned long )end_y)) {
#line 1646
      goto while_break;
    }
#line 1648
    tmp___2 = scan_x;
#line 1648
    scan_x ++;
#line 1648
    tmp___3 = scan_y;
#line 1648
    scan_y ++;
#line 1648
    difference = (*tmp___2 - *tmp___3) - borrow;
#line 1649
    if (difference < 0L) {
#line 1651
      tmp___4 = scan_r;
#line 1651
      scan_r ++;
#line 1651
      *tmp___4 = (bignum_digit_type )((unsigned long )difference + (1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)));
#line 1652
      borrow = (bignum_digit_type )1;
    } else {
#line 1656
      tmp___5 = scan_r;
#line 1656
      scan_r ++;
#line 1656
      *tmp___5 = difference;
#line 1657
      borrow = (bignum_digit_type )0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1662
  end_x = ((bignum_digit_type *)((SCHEME_OBJECT *)(x & 288230376151711743UL) + 1) + 1) + x_length;
#line 1663
  if (borrow != 0L) {
    {
#line 1664
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1664
      if (! ((unsigned long )scan_x < (unsigned long )end_x)) {
#line 1664
        goto while_break___0;
      }
#line 1666
      tmp___6 = scan_x;
#line 1666
      scan_x ++;
#line 1666
      difference = *tmp___6 - borrow;
#line 1667
      if (difference < 0L) {
#line 1668
        tmp___7 = scan_r;
#line 1668
        scan_r ++;
#line 1668
        *tmp___7 = (bignum_digit_type )((unsigned long )difference + (1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)));
      } else {
#line 1671
        tmp___8 = scan_r;
#line 1671
        scan_r ++;
#line 1671
        *tmp___8 = difference;
#line 1672
        borrow = (bignum_digit_type )0;
#line 1673
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1676
  if (! (borrow == 0L)) {
    {
#line 1676
    error_external_return();
    }
  }
  {
#line 1677
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1677
    if (! ((unsigned long )scan_x < (unsigned long )end_x)) {
#line 1677
      goto while_break___1;
    }
#line 1678
    tmp___9 = scan_r;
#line 1678
    scan_r ++;
#line 1678
    tmp___10 = scan_x;
#line 1678
    scan_x ++;
#line 1678
    *tmp___9 = *tmp___10;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1680
  tmp___11 = bignum_trim(r);
  }
#line 1680
  return (tmp___11);
}
}
#line 1690 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
static bignum_type bignum_multiply_unsigned(bignum_type x , bignum_type y , int negative_p ) 
{ 
  bignum_type z ;
  bignum_digit_type carry ;
  bignum_digit_type y_digit_low ;
  bignum_digit_type y_digit_high ;
  bignum_digit_type x_digit_low ;
  bignum_digit_type x_digit_high ;
  bignum_digit_type product_low ;
  bignum_digit_type *scan_r ;
  bignum_digit_type *scan_y ;
  bignum_length_type x_length ;
  bignum_length_type y_length ;
  bignum_type r ;
  bignum_type tmp ;
  bignum_digit_type *scan_x ;
  bignum_digit_type *end_x ;
  bignum_digit_type *start_y ;
  bignum_digit_type *end_y ;
  bignum_digit_type *start_r ;
  bignum_digit_type *tmp___0 ;
  bignum_digit_type *tmp___1 ;
  bignum_digit_type *tmp___2 ;
  bignum_digit_type *tmp___3 ;
  bignum_type tmp___4 ;

  {
#line 1693
  if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(y & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL)) > ((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(x & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL))) {
#line 1695
    z = x;
#line 1696
    x = y;
#line 1697
    y = z;
  }
  {
#line 1708
  x_length = (bignum_length_type )((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(x & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL));
#line 1709
  y_length = (bignum_length_type )((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(y & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL));
#line 1710
  tmp = bignum_allocate_zeroed(x_length + y_length, negative_p);
#line 1710
  r = tmp;
#line 1712
  scan_x = (bignum_digit_type *)((SCHEME_OBJECT *)(x & 288230376151711743UL) + 1) + 1;
#line 1713
  end_x = scan_x + x_length;
#line 1714
  start_y = (bignum_digit_type *)((SCHEME_OBJECT *)(y & 288230376151711743UL) + 1) + 1;
#line 1715
  end_y = start_y + y_length;
#line 1716
  start_r = (bignum_digit_type *)((SCHEME_OBJECT *)(r & 288230376151711743UL) + 1) + 1;
  }
  {
#line 1720
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1720
    if (! ((unsigned long )scan_x < (unsigned long )end_x)) {
#line 1720
      goto while_break;
    }
#line 1722
    tmp___0 = scan_x;
#line 1722
    scan_x ++;
#line 1722
    x_digit_high = *tmp___0;
#line 1723
    x_digit_low = (bignum_digit_type )((unsigned long )x_digit_high & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL) - 1UL));
#line 1724
    x_digit_high >>= (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL;
#line 1725
    carry = (bignum_digit_type )0;
#line 1726
    scan_y = start_y;
#line 1727
    tmp___1 = start_r;
#line 1727
    start_r ++;
#line 1727
    scan_r = tmp___1;
    {
#line 1728
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1728
      if (! ((unsigned long )scan_y < (unsigned long )end_y)) {
#line 1728
        goto while_break___0;
      }
#line 1730
      tmp___2 = scan_y;
#line 1730
      scan_y ++;
#line 1730
      y_digit_high = *tmp___2;
#line 1731
      y_digit_low = (bignum_digit_type )((unsigned long )y_digit_high & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL) - 1UL));
#line 1732
      y_digit_high >>= (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL;
#line 1733
      product_low = (bignum_digit_type )((unsigned long )(*scan_r + x_digit_low * y_digit_low) + ((unsigned long )carry & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL) - 1UL)));
#line 1737
      carry = ((x_digit_high * y_digit_low + x_digit_low * y_digit_high) + (product_low >> (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL)) + (carry >> (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL);
#line 1742
      tmp___3 = scan_r;
#line 1742
      scan_r ++;
#line 1742
      *tmp___3 = (bignum_digit_type )((((unsigned long )carry & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL) - 1UL)) << (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL) | ((unsigned long )product_low & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL) - 1UL)));
#line 1744
      carry = x_digit_high * y_digit_high + (carry >> (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1748
    *scan_r += carry;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1750
  tmp___4 = bignum_trim(r);
  }
#line 1750
  return (tmp___4);
}
}
#line 1757 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
static bignum_type bignum_multiply_unsigned_small_factor(bignum_type x , bignum_digit_type y ,
                                                         int negative_p ) 
{ 
  bignum_length_type length_x ;
  bignum_type p ;
  bignum_type tmp ;
  bignum_type tmp___0 ;

  {
  {
#line 1761
  length_x = (bignum_length_type )((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(x & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL));
#line 1762
  tmp = bignum_allocate(length_x + 1L, negative_p);
#line 1762
  p = tmp;
#line 1763
  bignum_destructive_copy(x, p);
#line 1764
  *(((bignum_digit_type *)((SCHEME_OBJECT *)(p & 288230376151711743UL) + 1) + 1) + length_x) = (bignum_digit_type )0;
#line 1765
  bignum_destructive_scale_up(p, y);
#line 1766
  tmp___0 = bignum_trim(p);
  }
#line 1766
  return (tmp___0);
}
}
#line 1769 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
static void bignum_destructive_scale_up(bignum_type bignum , bignum_digit_type factor ) 
{ 
  bignum_digit_type carry ;
  bignum_digit_type *scan ;
  bignum_digit_type two_digits ;
  bignum_digit_type product_low ;
  bignum_digit_type *end ;
  bignum_digit_type *tmp ;

  {
#line 1772
  carry = (bignum_digit_type )0;
#line 1773
  scan = (bignum_digit_type *)((SCHEME_OBJECT *)(bignum & 288230376151711743UL) + 1) + 1;
#line 1777
  end = scan + ((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(bignum & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL));
#line 1778
  if (factor > 1L) {
#line 1778
    if (! ((unsigned long )factor < 1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL)) {
      {
#line 1778
      error_external_return();
      }
    }
  } else {
    {
#line 1778
    error_external_return();
    }
  }
  {
#line 1779
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1779
    if (! ((unsigned long )scan < (unsigned long )end)) {
#line 1779
      goto while_break;
    }
#line 1781
    two_digits = *scan;
#line 1782
    product_low = (bignum_digit_type )((unsigned long )factor * ((unsigned long )two_digits & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL) - 1UL)) + ((unsigned long )carry & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL) - 1UL)));
#line 1783
    carry = (factor * (two_digits >> (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL) + (product_low >> (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL)) + (carry >> (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL);
#line 1787
    tmp = scan;
#line 1787
    scan ++;
#line 1787
    *tmp = (bignum_digit_type )((((unsigned long )carry & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL) - 1UL)) << (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL) | ((unsigned long )product_low & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL) - 1UL)));
#line 1788
    carry >>= (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL;
  }
  while_break: /* CIL Label */ ;
  }
#line 1794
  if (! (carry == 0L)) {
    {
#line 1794
    error_external_return();
    }
  }
#line 1795
  return;
}
}
#line 1799 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
static void bignum_destructive_add(bignum_type bignum , bignum_digit_type n ) 
{ 
  bignum_digit_type *scan ;
  bignum_digit_type digit ;
  bignum_digit_type *tmp ;
  bignum_digit_type *tmp___0 ;

  {
#line 1802
  scan = (bignum_digit_type *)((SCHEME_OBJECT *)(bignum & 288230376151711743UL) + 1) + 1;
#line 1804
  digit = *scan + n;
#line 1805
  if ((unsigned long )digit < 1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) {
#line 1807
    *scan = digit;
#line 1808
    return;
  }
#line 1810
  tmp = scan;
#line 1810
  scan ++;
#line 1810
  *tmp = (bignum_digit_type )((unsigned long )digit - (1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)));
  {
#line 1811
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1813
    digit = *scan + 1L;
#line 1814
    if ((unsigned long )digit < 1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) {
#line 1816
      *scan = digit;
#line 1817
      return;
    }
#line 1819
    tmp___0 = scan;
#line 1819
    scan ++;
#line 1819
    *tmp___0 = (bignum_digit_type )((unsigned long )digit - (1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)));
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1830 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
static void bignum_divide_unsigned_large_denominator(bignum_type numerator , bignum_type denominator ,
                                                     bignum_type *quotient , bignum_type *remainder___0 ,
                                                     int q_negative_p , int r_negative_p ) 
{ 
  bignum_length_type length_n ;
  bignum_length_type length_d ;
  bignum_type q ;
  bignum_type tmp ;
  bignum_type tmp___0 ;
  bignum_type u ;
  bignum_type tmp___1 ;
  int shift ;
  bignum_digit_type v1 ;
  bignum_type v ;
  bignum_type tmp___2 ;

  {
#line 1838
  length_n = (bignum_length_type )(((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(numerator & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL)) + 1UL);
#line 1839
  length_d = (bignum_length_type )((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(denominator & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL));
#line 1840
  if ((unsigned long )quotient != (unsigned long )((bignum_type *)0)) {
    {
#line 1840
    tmp = bignum_allocate(length_n - length_d, q_negative_p);
#line 1840
    tmp___0 = tmp;
    }
  } else {
#line 1840
    tmp___0 = 0UL;
  }
  {
#line 1840
  q = tmp___0;
#line 1844
  tmp___1 = bignum_allocate(length_n, r_negative_p);
#line 1844
  u = tmp___1;
#line 1845
  shift = 0;
  }
#line 1846
  if (! (length_d > 1L)) {
    {
#line 1846
    error_external_return();
    }
  }
#line 1848
  v1 = *(((bignum_digit_type *)((SCHEME_OBJECT *)(denominator & 288230376151711743UL) + 1) + 1) + (length_d - 1L));
  {
#line 1849
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1849
    if (! ((unsigned long )v1 < (1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) / 2UL)) {
#line 1849
      goto while_break;
    }
#line 1851
    v1 <<= 1;
#line 1852
    shift ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1855
  if (shift == 0) {
    {
#line 1857
    bignum_destructive_copy(numerator, u);
#line 1858
    *(((bignum_digit_type *)((SCHEME_OBJECT *)(u & 288230376151711743UL) + 1) + 1) + (length_n - 1L)) = (bignum_digit_type )0;
#line 1859
    bignum_divide_unsigned_normalized(u, denominator, q);
    }
  } else {
    {
#line 1863
    tmp___2 = bignum_allocate(length_d, 0);
#line 1863
    v = tmp___2;
#line 1864
    bignum_destructive_normalization(numerator, u, shift);
#line 1865
    bignum_destructive_normalization(denominator, v, shift);
#line 1866
    bignum_divide_unsigned_normalized(u, v, q);
    }
    {
#line 1867
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1867
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1868
    if ((unsigned long )remainder___0 != (unsigned long )((bignum_type *)0)) {
      {
#line 1869
      bignum_destructive_unnormalization(u, shift);
      }
    }
  }
#line 1871
  if ((unsigned long )quotient != (unsigned long )((bignum_type *)0)) {
    {
#line 1872
    *quotient = bignum_trim(q);
    }
  }
#line 1873
  if ((unsigned long )remainder___0 != (unsigned long )((bignum_type *)0)) {
    {
#line 1874
    *remainder___0 = bignum_trim(u);
    }
  } else {
    {
#line 1876
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1876
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1877
  return;
}
}
#line 1880 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
static void bignum_divide_unsigned_normalized(bignum_type u , bignum_type v , bignum_type q ) 
{ 
  bignum_length_type u_length ;
  bignum_length_type v_length ;
  bignum_digit_type *u_start ;
  bignum_digit_type *u_scan ;
  bignum_digit_type *u_scan_limit ;
  bignum_digit_type *u_scan_start ;
  bignum_digit_type *v_start ;
  bignum_digit_type *v_end ;
  bignum_digit_type *q_scan ;
  bignum_digit_type v1 ;
  bignum_digit_type v2 ;
  bignum_digit_type ph ;
  bignum_digit_type pl ;
  bignum_digit_type guess ;
  bignum_digit_type gh ;
  bignum_digit_type ch ;
  bignum_digit_type v2l ;
  bignum_digit_type v2h ;
  bignum_digit_type cl ;
  bignum_digit_type gm ;

  {
#line 1883
  u_length = (bignum_length_type )((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(u & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL));
#line 1884
  v_length = (bignum_length_type )((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(v & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL));
#line 1885
  u_start = (bignum_digit_type *)((SCHEME_OBJECT *)(u & 288230376151711743UL) + 1) + 1;
#line 1886
  u_scan = u_start + u_length;
#line 1887
  u_scan_limit = u_start + v_length;
#line 1888
  u_scan_start = u_scan - v_length;
#line 1889
  v_start = (bignum_digit_type *)((SCHEME_OBJECT *)(v & 288230376151711743UL) + 1) + 1;
#line 1890
  v_end = v_start + v_length;
#line 1891
  q_scan = (bignum_digit_type *)0;
#line 1892
  v1 = *(v_end + -1);
#line 1893
  v2 = *(v_end + -2);
#line 1899
  v2l = (bignum_digit_type )((unsigned long )v2 & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL) - 1UL));
#line 1900
  v2h = v2 >> (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL;
#line 1906
  if (q != 0UL) {
#line 1907
    q_scan = ((bignum_digit_type *)((SCHEME_OBJECT *)(q & 288230376151711743UL) + 1) + 1) + ((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(q & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL));
  }
  {
#line 1908
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1908
    if (! ((unsigned long )u_scan_limit < (unsigned long )u_scan)) {
#line 1908
      goto while_break;
    }
#line 1910
    u_scan --;
#line 1910
    pl = *u_scan;
#line 1911
    if (pl != v1) {
      {
#line 1916
      cl = *(u_scan + -2);
#line 1917
      ch = bignum_digit_divide(pl, *(u_scan + -1), v1, & gm);
#line 1918
      guess = gm;
      }
    } else {
#line 1922
      cl = *(u_scan + -2);
#line 1923
      ch = *(u_scan + -1) + v1;
#line 1924
      guess = (bignum_digit_type )((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL);
    }
    {
#line 1926
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1929
      ph = (bignum_digit_type )((unsigned long )guess & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL) - 1UL));
#line 1930
      gh = guess >> (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL;
#line 1931
      pl = v2l * ph;
#line 1932
      ph = (v2l * gh + v2h * ph) + (pl >> (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL);
#line 1933
      pl = (bignum_digit_type )((((unsigned long )ph & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL) - 1UL)) << (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL) | ((unsigned long )pl & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL) - 1UL)));
#line 1934
      ph = v2h * gh + (ph >> (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL);
#line 1936
      if (ch > ph) {
#line 1937
        goto while_break___0;
      } else
#line 1936
      if (ch == ph) {
#line 1936
        if (cl >= pl) {
#line 1937
          goto while_break___0;
        }
      }
#line 1938
      guess --;
#line 1940
      ch += v1;
#line 1942
      if ((unsigned long )ch >= 1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) {
#line 1943
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1945
    u_scan_start --;
#line 1945
    ph = bignum_divide_subtract(v_start, v_end, guess, u_scan_start);
    }
#line 1946
    if (q != 0UL) {
#line 1947
      q_scan --;
#line 1947
      *q_scan = ph;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1949
  return;
}
}
#line 1955 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
static bignum_digit_type bignum_divide_subtract(bignum_digit_type *v_start , bignum_digit_type *v_end ,
                                                bignum_digit_type guess , bignum_digit_type *u_start ) 
{ 
  bignum_digit_type *v_scan ;
  bignum_digit_type *u_scan ;
  bignum_digit_type carry ;
  bignum_digit_type gl ;
  bignum_digit_type gh ;
  bignum_digit_type v ;
  bignum_digit_type pl ;
  bignum_digit_type vl ;
  bignum_digit_type *tmp ;
  bignum_digit_type *tmp___0 ;
  bignum_digit_type *tmp___1 ;
  bignum_digit_type sum ;
  bignum_digit_type *tmp___2 ;
  bignum_digit_type *tmp___3 ;
  bignum_digit_type *tmp___4 ;
  bignum_digit_type sum___0 ;

  {
#line 1961
  v_scan = v_start;
#line 1962
  u_scan = u_start;
#line 1963
  carry = (bignum_digit_type )0;
#line 1964
  if (guess == 0L) {
#line 1964
    return ((bignum_digit_type )0);
  }
#line 1966
  gl = (bignum_digit_type )((unsigned long )guess & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL) - 1UL));
#line 1967
  gh = guess >> (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL;
  {
#line 1974
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1974
    if (! ((unsigned long )v_scan < (unsigned long )v_end)) {
#line 1974
      goto while_break;
    }
#line 1976
    tmp = v_scan;
#line 1976
    v_scan ++;
#line 1976
    v = *tmp;
#line 1977
    vl = (bignum_digit_type )((unsigned long )v & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL) - 1UL));
#line 1978
    v >>= (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL;
#line 1979
    pl = (bignum_digit_type )((unsigned long )(vl * gl) + ((unsigned long )carry & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL) - 1UL)));
#line 1980
    carry = ((vl * gh + v * gl) + (pl >> (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL)) + (carry >> (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL);
#line 1981
    pl = (bignum_digit_type )((unsigned long )*u_scan - ((((unsigned long )carry & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL) - 1UL)) << (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL) | ((unsigned long )pl & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL) - 1UL))));
#line 1982
    if (pl < 0L) {
#line 1984
      tmp___0 = u_scan;
#line 1984
      u_scan ++;
#line 1984
      *tmp___0 = (bignum_digit_type )((unsigned long )pl + (1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)));
#line 1985
      carry = (v * gh + (carry >> (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL)) + 1L;
    } else {
#line 1989
      tmp___1 = u_scan;
#line 1989
      u_scan ++;
#line 1989
      *tmp___1 = pl;
#line 1990
      carry = v * gh + (carry >> (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1993
  if (carry == 0L) {
#line 1994
    return (guess);
  }
#line 1995
  pl = *u_scan - carry;
#line 1996
  if (pl < 0L) {
#line 1997
    *u_scan = (bignum_digit_type )((unsigned long )pl + (1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)));
  } else {
#line 2000
    *u_scan = pl;
#line 2001
    return (guess);
  }
#line 2009
  v_scan = v_start;
#line 2010
  u_scan = u_start;
#line 2011
  carry = (bignum_digit_type )0;
  {
#line 2012
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2012
    if (! ((unsigned long )v_scan < (unsigned long )v_end)) {
#line 2012
      goto while_break___0;
    }
#line 2014
    tmp___2 = v_scan;
#line 2014
    v_scan ++;
#line 2014
    sum = (*tmp___2 + *u_scan) + carry;
#line 2015
    if ((unsigned long )sum < 1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) {
#line 2017
      tmp___3 = u_scan;
#line 2017
      u_scan ++;
#line 2017
      *tmp___3 = sum;
#line 2018
      carry = (bignum_digit_type )0;
    } else {
#line 2022
      tmp___4 = u_scan;
#line 2022
      u_scan ++;
#line 2022
      *tmp___4 = (bignum_digit_type )((unsigned long )sum - (1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)));
#line 2023
      carry = (bignum_digit_type )1;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2026
  if (carry == 1L) {
#line 2028
    sum___0 = *u_scan + carry;
#line 2029
    if ((unsigned long )sum___0 < 1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) {
#line 2029
      *u_scan = sum___0;
    } else {
#line 2029
      *u_scan = (bignum_digit_type )((unsigned long )sum___0 - (1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)));
    }
  }
#line 2031
  return (guess - 1L);
}
}
#line 2034 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
static void bignum_divide_unsigned_medium_denominator(bignum_type numerator , bignum_digit_type denominator ,
                                                      bignum_type *quotient , bignum_type *remainder___0 ,
                                                      int q_negative_p , int r_negative_p ) 
{ 
  bignum_length_type length_n ;
  bignum_length_type length_q ;
  bignum_type q ;
  int shift ;
  bignum_digit_type r ;
  bignum_digit_type *start ;
  bignum_digit_type *scan ;
  bignum_digit_type qj ;

  {
#line 2042
  length_n = (bignum_length_type )((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(numerator & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL));
#line 2045
  shift = 0;
  {
#line 2047
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2047
    if (! ((unsigned long )denominator < (1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) / 2UL)) {
#line 2047
      goto while_break;
    }
#line 2049
    denominator <<= 1;
#line 2050
    shift ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2052
  if (shift == 0) {
    {
#line 2054
    length_q = length_n;
#line 2055
    q = bignum_allocate(length_q, q_negative_p);
#line 2056
    bignum_destructive_copy(numerator, q);
    }
  } else {
    {
#line 2060
    length_q = length_n + 1L;
#line 2061
    q = bignum_allocate(length_q, q_negative_p);
#line 2062
    bignum_destructive_normalization(numerator, q, shift);
    }
  }
#line 2065
  r = (bignum_digit_type )0;
#line 2066
  start = (bignum_digit_type *)((SCHEME_OBJECT *)(q & 288230376151711743UL) + 1) + 1;
#line 2067
  scan = start + length_q;
#line 2069
  if ((unsigned long )quotient != (unsigned long )((bignum_type *)0)) {
    {
#line 2071
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2071
      if (! ((unsigned long )start < (unsigned long )scan)) {
#line 2071
        goto while_break___0;
      }
      {
#line 2073
      scan --;
#line 2073
      r = bignum_digit_divide(r, *scan, denominator, & qj);
#line 2074
      *scan = qj;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 2076
    *quotient = bignum_trim(q);
    }
  } else {
    {
#line 2080
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2080
      if (! ((unsigned long )start < (unsigned long )scan)) {
#line 2080
        goto while_break___1;
      }
      {
#line 2081
      scan --;
#line 2081
      r = bignum_digit_divide(r, *scan, denominator, & qj);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 2082
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2082
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 2084
  if ((unsigned long )remainder___0 != (unsigned long )((bignum_type *)0)) {
#line 2086
    if (shift != 0) {
#line 2087
      r >>= shift;
    }
    {
#line 2088
    *remainder___0 = bignum_digit_to_bignum(r, r_negative_p);
    }
  }
#line 2091
  return;
}
}
#line 2094 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
static void bignum_destructive_normalization(bignum_type source , bignum_type target ,
                                             int shift_left ) 
{ 
  bignum_digit_type digit ;
  bignum_digit_type *scan_source ;
  bignum_digit_type carry ;
  bignum_digit_type *scan_target ;
  bignum_digit_type *end_source ;
  bignum_digit_type *end_target ;
  int shift_right ;
  bignum_digit_type mask ;
  bignum_digit_type *tmp ;
  bignum_digit_type *tmp___0 ;

  {
#line 2099
  scan_source = (bignum_digit_type *)((SCHEME_OBJECT *)(source & 288230376151711743UL) + 1) + 1;
#line 2100
  carry = (bignum_digit_type )0;
#line 2101
  scan_target = (bignum_digit_type *)((SCHEME_OBJECT *)(target & 288230376151711743UL) + 1) + 1;
#line 2102
  end_source = scan_source + ((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(source & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL));
#line 2103
  end_target = scan_target + ((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(target & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL));
#line 2104
  shift_right = (int )((sizeof(bignum_digit_type ) * 8UL - 2UL) - (unsigned long )shift_left);
#line 2105
  mask = (bignum_digit_type )((1UL << shift_right) - 1UL);
  {
#line 2106
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2106
    if (! ((unsigned long )scan_source < (unsigned long )end_source)) {
#line 2106
      goto while_break;
    }
#line 2108
    tmp = scan_source;
#line 2108
    scan_source ++;
#line 2108
    digit = *tmp;
#line 2109
    tmp___0 = scan_target;
#line 2109
    scan_target ++;
#line 2109
    *tmp___0 = ((digit & mask) << shift_left) | carry;
#line 2110
    carry = digit >> shift_right;
  }
  while_break: /* CIL Label */ ;
  }
#line 2112
  if ((unsigned long )scan_target < (unsigned long )end_target) {
#line 2113
    *scan_target = carry;
  } else
#line 2115
  if (! (carry == 0L)) {
    {
#line 2115
    error_external_return();
    }
  }
#line 2116
  return;
}
}
#line 2119 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
static void bignum_destructive_unnormalization(bignum_type bignum , int shift_right ) 
{ 
  bignum_digit_type *start ;
  bignum_digit_type *scan ;
  bignum_digit_type digit ;
  bignum_digit_type carry ;
  int shift_left ;
  bignum_digit_type mask ;

  {
#line 2122
  start = (bignum_digit_type *)((SCHEME_OBJECT *)(bignum & 288230376151711743UL) + 1) + 1;
#line 2123
  scan = start + ((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(bignum & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL));
#line 2125
  carry = (bignum_digit_type )0;
#line 2126
  shift_left = (int )((sizeof(bignum_digit_type ) * 8UL - 2UL) - (unsigned long )shift_right);
#line 2127
  mask = (bignum_digit_type )((1UL << shift_right) - 1UL);
  {
#line 2128
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2128
    if (! ((unsigned long )start < (unsigned long )scan)) {
#line 2128
      goto while_break;
    }
#line 2130
    scan --;
#line 2130
    digit = *scan;
#line 2131
    *scan = (digit >> shift_right) | carry;
#line 2132
    carry = (digit & mask) << shift_left;
  }
  while_break: /* CIL Label */ ;
  }
#line 2134
  if (! (carry == 0L)) {
    {
#line 2134
    error_external_return();
    }
  }
#line 2135
  return;
}
}
#line 2165 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
static bignum_digit_type bignum_digit_divide(bignum_digit_type uh , bignum_digit_type ul ,
                                             bignum_digit_type v , bignum_digit_type *q ) 
{ 
  bignum_digit_type guess ;
  bignum_digit_type comparand ;
  bignum_digit_type v1 ;
  bignum_digit_type v2 ;
  bignum_digit_type uj ;
  bignum_digit_type uj_uj1 ;
  bignum_digit_type q1 ;
  bignum_digit_type q2 ;
  bignum_digit_type u[4] ;
  void *__cil_tmp14 ;

  {
#line 2178
  if (uh == 0L) {
#line 2180
    if (ul < v) {
#line 2182
      *q = (bignum_digit_type )0;
#line 2183
      return (ul);
    } else
#line 2185
    if (ul == v) {
#line 2187
      *q = (bignum_digit_type )1;
#line 2188
      return ((bignum_digit_type )0);
    }
  }
#line 2191
  u[0] = uh >> (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL;
#line 2192
  u[1] = (bignum_digit_type )((unsigned long )uh & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL) - 1UL));
#line 2193
  u[2] = ul >> (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL;
#line 2194
  u[3] = (bignum_digit_type )((unsigned long )ul & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL) - 1UL));
#line 2195
  v1 = v >> (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL;
#line 2196
  v2 = (bignum_digit_type )((unsigned long )v & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL) - 1UL));
#line 2197
  uj = u[0];
#line 2197
  if (uj != v1) {
#line 2197
    uj_uj1 = (uj << (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL) | u[1];
#line 2197
    guess = uj_uj1 / v1;
#line 2197
    comparand = (uj_uj1 % v1 << (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL) | u[2];
  } else {
#line 2197
    guess = (bignum_digit_type )((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL) - 1UL);
#line 2197
    comparand = ((u[1] + v1) << (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL) | u[2];
  }
  {
#line 2197
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2197
    if (! (guess * v2 > comparand)) {
#line 2197
      goto while_break;
    }
#line 2197
    guess --;
#line 2197
    comparand += v1 << (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL;
#line 2197
    if ((unsigned long )comparand >= 1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) {
#line 2197
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2197
  q1 = bignum_digit_divide_subtract(v1, v2, guess, & u[0]);
#line 2198
  uj = u[1];
  }
#line 2198
  if (uj != v1) {
#line 2198
    uj_uj1 = (uj << (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL) | u[2];
#line 2198
    guess = uj_uj1 / v1;
#line 2198
    comparand = (uj_uj1 % v1 << (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL) | u[3];
  } else {
#line 2198
    guess = (bignum_digit_type )((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL) - 1UL);
#line 2198
    comparand = ((u[2] + v1) << (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL) | u[3];
  }
  {
#line 2198
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2198
    if (! (guess * v2 > comparand)) {
#line 2198
      goto while_break___0;
    }
#line 2198
    guess --;
#line 2198
    comparand += v1 << (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL;
#line 2198
    if ((unsigned long )comparand >= 1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) {
#line 2198
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2198
  q2 = bignum_digit_divide_subtract(v1, v2, guess, & u[1]);
#line 2199
  *q = (q1 << (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL) | q2;
  }
#line 2200
  return ((u[2] << (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL) | u[3]);
}
}
#line 2236 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
static bignum_digit_type bignum_digit_divide_subtract(bignum_digit_type v1 , bignum_digit_type v2 ,
                                                      bignum_digit_type guess , bignum_digit_type *u ) 
{ 
  bignum_digit_type product ;
  bignum_digit_type diff ;
  bignum_digit_type carry ;
  bignum_digit_type sum ;
  bignum_digit_type carry___0 ;

  {
#line 2244
  product = v2 * guess;
#line 2244
  diff = (bignum_digit_type )((unsigned long )*(u + 2) - ((unsigned long )product & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL) - 1UL)));
#line 2244
  if (diff < 0L) {
#line 2244
    *(u + 2) = (bignum_digit_type )((unsigned long )diff + (1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL));
#line 2244
    carry = (product >> (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL) + 1L;
  } else {
#line 2244
    *(u + 2) = diff;
#line 2244
    carry = product >> (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL;
  }
#line 2245
  product = v1 * guess + carry;
#line 2245
  diff = (bignum_digit_type )((unsigned long )*(u + 1) - ((unsigned long )product & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL) - 1UL)));
#line 2245
  if (diff < 0L) {
#line 2245
    *(u + 1) = (bignum_digit_type )((unsigned long )diff + (1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL));
#line 2245
    carry = (product >> (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL) + 1L;
  } else {
#line 2245
    *(u + 1) = diff;
#line 2245
    carry = product >> (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL;
  }
#line 2246
  if (carry == 0L) {
#line 2247
    return (guess);
  }
#line 2248
  diff = *(u + 0) - carry;
#line 2249
  if (diff < 0L) {
#line 2250
    *(u + 0) = (bignum_digit_type )((unsigned long )diff + (1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)));
  } else {
#line 2253
    *(u + 0) = diff;
#line 2254
    return (guess);
  }
#line 2260
  sum = v2 + *(u + 2);
#line 2260
  if ((unsigned long )sum < 1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL) {
#line 2260
    *(u + 2) = sum;
#line 2260
    carry___0 = (bignum_digit_type )0;
  } else {
#line 2260
    *(u + 2) = (bignum_digit_type )((unsigned long )sum - (1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL));
#line 2260
    carry___0 = (bignum_digit_type )1;
  }
#line 2261
  sum = (v1 + *(u + 1)) + carry___0;
#line 2261
  if ((unsigned long )sum < 1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL) {
#line 2261
    *(u + 1) = sum;
#line 2261
    carry___0 = (bignum_digit_type )0;
  } else {
#line 2261
    *(u + 1) = (bignum_digit_type )((unsigned long )sum - (1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL));
#line 2261
    carry___0 = (bignum_digit_type )1;
  }
#line 2262
  if (carry___0 == 1L) {
#line 2263
    (*(u + 0)) ++;
  }
#line 2265
  return (guess - 1L);
}
}
#line 2271 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
static void bignum_divide_unsigned_small_denominator(bignum_type numerator , bignum_digit_type denominator ,
                                                     bignum_type *quotient , bignum_type *remainder___0 ,
                                                     int q_negative_p , int r_negative_p ) 
{ 
  bignum_type q ;
  bignum_type tmp ;
  bignum_digit_type r ;
  bignum_digit_type tmp___0 ;

  {
  {
#line 2279
  tmp = bignum_new_sign(numerator, q_negative_p);
#line 2279
  q = tmp;
#line 2280
  tmp___0 = bignum_destructive_scale_down(q, denominator);
#line 2280
  r = tmp___0;
#line 2281
  *quotient = bignum_trim(q);
  }
#line 2282
  if ((unsigned long )remainder___0 != (unsigned long )((bignum_type *)0)) {
    {
#line 2283
    *remainder___0 = bignum_digit_to_bignum(r, r_negative_p);
    }
  }
#line 2284
  return;
}
}
#line 2291 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
static bignum_digit_type bignum_destructive_scale_down(bignum_type bignum , bignum_digit_type denominator ) 
{ 
  bignum_digit_type numerator ;
  bignum_digit_type remainder___0 ;
  bignum_digit_type two_digits ;
  bignum_digit_type *start ;
  bignum_digit_type *scan ;

  {
#line 2296
  remainder___0 = (bignum_digit_type )0;
#line 2299
  start = (bignum_digit_type *)((SCHEME_OBJECT *)(bignum & 288230376151711743UL) + 1) + 1;
#line 2300
  scan = start + ((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(bignum & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL));
#line 2301
  if (denominator > 1L) {
#line 2301
    if (! ((unsigned long )denominator < 1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL)) {
      {
#line 2301
      error_external_return();
      }
    }
  } else {
    {
#line 2301
    error_external_return();
    }
  }
  {
#line 2302
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2302
    if (! ((unsigned long )start < (unsigned long )scan)) {
#line 2302
      goto while_break;
    }
#line 2304
    scan --;
#line 2304
    two_digits = *scan;
#line 2305
    numerator = (remainder___0 << (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL) | (two_digits >> (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL);
#line 2306
    remainder___0 = numerator / denominator;
#line 2307
    numerator = (bignum_digit_type )((unsigned long )(numerator % denominator << (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL) | ((unsigned long )two_digits & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL) - 1UL)));
#line 2308
    *scan = (remainder___0 << (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL) | numerator / denominator;
#line 2309
    remainder___0 = numerator % denominator;
  }
  while_break: /* CIL Label */ ;
  }
#line 2311
  return (remainder___0);
}
}
#line 2315 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
static bignum_type bignum_remainder_unsigned_small_denominator(bignum_type n , bignum_digit_type d ,
                                                               int negative_p ) 
{ 
  bignum_digit_type two_digits ;
  bignum_digit_type *start ;
  bignum_digit_type *scan ;
  bignum_digit_type r ;
  bignum_type tmp ;

  {
#line 2321
  start = (bignum_digit_type *)((SCHEME_OBJECT *)(n & 288230376151711743UL) + 1) + 1;
#line 2322
  scan = start + ((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(n & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL));
#line 2323
  r = (bignum_digit_type )0;
#line 2324
  if (d > 1L) {
#line 2324
    if (! ((unsigned long )d < 1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL)) {
      {
#line 2324
      error_external_return();
      }
    }
  } else {
    {
#line 2324
    error_external_return();
    }
  }
  {
#line 2325
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2325
    if (! ((unsigned long )start < (unsigned long )scan)) {
#line 2325
      goto while_break;
    }
#line 2327
    scan --;
#line 2327
    two_digits = *scan;
#line 2328
    r = (bignum_digit_type )(((unsigned long )(((r << (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL) | (two_digits >> (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL)) % d << (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL) | ((unsigned long )two_digits & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL) / 2UL) - 1UL))) % (unsigned long )d);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2333
  tmp = bignum_digit_to_bignum(r, negative_p);
  }
#line 2333
  return (tmp);
}
}
#line 2336 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
static bignum_type bignum_digit_to_bignum(bignum_digit_type digit , int negative_p ) 
{ 
  bignum_type tmp ;
  bignum_type result ;
  bignum_type tmp___0 ;

  {
#line 2339
  if (digit == 0L) {
    {
#line 2340
    tmp = bignum_make_zero();
    }
#line 2340
    return (tmp);
  } else {
    {
#line 2343
    tmp___0 = bignum_allocate((bignum_length_type )1, negative_p);
#line 2343
    result = tmp___0;
#line 2344
    *(((bignum_digit_type *)((SCHEME_OBJECT *)(result & 288230376151711743UL) + 1) + 1) + 0) = digit;
    }
#line 2345
    return (result);
  }
}
}
#line 2351 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
static bignum_type bignum_allocate(bignum_length_type length , int negative_p ) 
{ 
  bignum_type result ;
  SCHEME_OBJECT tmp ;
  unsigned long tmp___0 ;

  {
#line 2354
  if (0L <= length) {
#line 2354
    if (! ((unsigned long )length <= (1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) / (sizeof(bignum_digit_type ) * 8UL - 2UL) - (sizeof(bignum_digit_type ) * 8UL - 2UL))) {
      {
#line 2354
      error_external_return();
      }
    }
  } else {
    {
#line 2354
    error_external_return();
    }
  }
  {
#line 2356
  tmp = allocate_non_marked_vector(14U, ((unsigned long )(length + 1L) * sizeof(bignum_digit_type ) + (sizeof(SCHEME_OBJECT ) - 1UL)) / sizeof(SCHEME_OBJECT ),
                                   (_Bool)1);
#line 2356
  result = tmp;
  }
#line 2357
  if (negative_p) {
#line 2357
    tmp___0 = 1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL);
  } else {
#line 2357
    tmp___0 = 0UL;
  }
#line 2357
  *((bignum_digit_type *)((SCHEME_OBJECT *)(result & 288230376151711743UL) + 1)) = (bignum_digit_type )((unsigned long )length | tmp___0);
#line 2358
  return (result);
}
}
#line 2362 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
static bignum_type bignum_allocate_zeroed(bignum_length_type length , int negative_p ) 
{ 
  bignum_type result ;
  SCHEME_OBJECT tmp ;
  bignum_digit_type *scan ;
  bignum_digit_type *end ;
  unsigned long tmp___0 ;
  bignum_digit_type *tmp___1 ;

  {
#line 2365
  if (0L <= length) {
#line 2365
    if (! ((unsigned long )length <= (1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) / (sizeof(bignum_digit_type ) * 8UL - 2UL) - (sizeof(bignum_digit_type ) * 8UL - 2UL))) {
      {
#line 2365
      error_external_return();
      }
    }
  } else {
    {
#line 2365
    error_external_return();
    }
  }
  {
#line 2367
  tmp = allocate_non_marked_vector(14U, ((unsigned long )(length + 1L) * sizeof(bignum_digit_type ) + (sizeof(SCHEME_OBJECT ) - 1UL)) / sizeof(SCHEME_OBJECT ),
                                   (_Bool)1);
#line 2367
  result = tmp;
#line 2368
  scan = (bignum_digit_type *)((SCHEME_OBJECT *)(result & 288230376151711743UL) + 1) + 1;
#line 2369
  end = scan + length;
  }
#line 2370
  if (negative_p) {
#line 2370
    tmp___0 = 1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL);
  } else {
#line 2370
    tmp___0 = 0UL;
  }
#line 2370
  *((bignum_digit_type *)((SCHEME_OBJECT *)(result & 288230376151711743UL) + 1)) = (bignum_digit_type )((unsigned long )length | tmp___0);
  {
#line 2371
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2371
    if (! ((unsigned long )scan < (unsigned long )end)) {
#line 2371
      goto while_break;
    }
#line 2372
    tmp___1 = scan;
#line 2372
    scan ++;
#line 2372
    *tmp___1 = (bignum_digit_type )0;
  }
  while_break: /* CIL Label */ ;
  }
#line 2373
  return (result);
}
}
#line 2377 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
static bignum_type bignum_shorten_length(bignum_type bignum , bignum_length_type length ) 
{ 
  bignum_length_type current_length ;
  unsigned long tmp ;
  unsigned long new_gc_length ;
  unsigned long old_gc_length ;
  unsigned long delta ;

  {
#line 2380
  current_length = (bignum_length_type )((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(bignum & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL));
#line 2381
  if (0L <= length) {
#line 2381
    if (! (length <= current_length)) {
      {
#line 2381
      error_external_return();
      }
    }
  } else {
    {
#line 2381
    error_external_return();
    }
  }
#line 2382
  if (length < current_length) {
#line 2384
    if (length != 0L) {
#line 2384
      if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(bignum & 288230376151711743UL) + 1)) & (1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL))) != 0UL) {
#line 2384
        tmp = 1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL);
      } else {
#line 2384
        tmp = 0UL;
      }
    } else {
#line 2384
      tmp = 0UL;
    }
#line 2384
    *((bignum_digit_type *)((SCHEME_OBJECT *)(bignum & 288230376151711743UL) + 1)) = (bignum_digit_type )((unsigned long )length | tmp);
#line 2386
    new_gc_length = ((unsigned long )(length + 1L) * sizeof(bignum_digit_type ) + (sizeof(SCHEME_OBJECT ) - 1UL)) / sizeof(SCHEME_OBJECT );
#line 2386
    old_gc_length = *((SCHEME_OBJECT *)(bignum & 288230376151711743UL) + 0) & 288230376151711743UL;
#line 2386
    delta = old_gc_length - new_gc_length;
#line 2386
    if (delta == 1UL) {
#line 2386
      *((SCHEME_OBJECT *)(bignum & 288230376151711743UL) + (new_gc_length + 1UL)) = 0UL;
    } else
#line 2386
    if (delta > 1UL) {
#line 2386
      *((SCHEME_OBJECT *)(bignum & 288230376151711743UL) + (new_gc_length + 1UL)) = (39UL << 58U) | (delta - 1UL);
    }
#line 2386
    if (delta != 0UL) {
#line 2386
      *((SCHEME_OBJECT *)(bignum & 288230376151711743UL) + 0) = ((*((SCHEME_OBJECT *)(bignum & 288230376151711743UL) + 0) >> 58U) << 58U) | new_gc_length;
    }
#line 2386
    bignum = bignum;
  }
#line 2388
  return (bignum);
}
}
#line 2391 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
static bignum_type bignum_trim(bignum_type bignum ) 
{ 
  bignum_digit_type *start ;
  bignum_digit_type *end ;
  bignum_digit_type *scan ;
  bignum_length_type length ;
  unsigned long tmp ;
  unsigned long new_gc_length ;
  unsigned long old_gc_length ;
  unsigned long delta ;

  {
#line 2394
  start = (bignum_digit_type *)((SCHEME_OBJECT *)(bignum & 288230376151711743UL) + 1) + 1;
#line 2395
  end = start + ((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(bignum & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL));
#line 2396
  scan = end;
  {
#line 2397
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2397
    if ((unsigned long )start <= (unsigned long )scan) {
#line 2397
      scan --;
#line 2397
      if (! (*scan == 0L)) {
#line 2397
        goto while_break;
      }
    } else {
#line 2397
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2399
  scan ++;
#line 2400
  if ((unsigned long )scan < (unsigned long )end) {
#line 2402
    length = scan - start;
#line 2403
    if (length != 0L) {
#line 2403
      if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(bignum & 288230376151711743UL) + 1)) & (1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL))) != 0UL) {
#line 2403
        tmp = 1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL);
      } else {
#line 2403
        tmp = 0UL;
      }
    } else {
#line 2403
      tmp = 0UL;
    }
#line 2403
    *((bignum_digit_type *)((SCHEME_OBJECT *)(bignum & 288230376151711743UL) + 1)) = (bignum_digit_type )((unsigned long )length | tmp);
#line 2405
    new_gc_length = ((unsigned long )(length + 1L) * sizeof(bignum_digit_type ) + (sizeof(SCHEME_OBJECT ) - 1UL)) / sizeof(SCHEME_OBJECT );
#line 2405
    old_gc_length = *((SCHEME_OBJECT *)(bignum & 288230376151711743UL) + 0) & 288230376151711743UL;
#line 2405
    delta = old_gc_length - new_gc_length;
#line 2405
    if (delta == 1UL) {
#line 2405
      *((SCHEME_OBJECT *)(bignum & 288230376151711743UL) + (new_gc_length + 1UL)) = 0UL;
    } else
#line 2405
    if (delta > 1UL) {
#line 2405
      *((SCHEME_OBJECT *)(bignum & 288230376151711743UL) + (new_gc_length + 1UL)) = (39UL << 58U) | (delta - 1UL);
    }
#line 2405
    if (delta != 0UL) {
#line 2405
      *((SCHEME_OBJECT *)(bignum & 288230376151711743UL) + 0) = ((*((SCHEME_OBJECT *)(bignum & 288230376151711743UL) + 0) >> 58U) << 58U) | new_gc_length;
    }
#line 2405
    bignum = bignum;
  }
#line 2407
  return (bignum);
}
}
#line 2412 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
static bignum_type bignum_copy(bignum_type source ) 
{ 
  bignum_type target ;
  bignum_type tmp ;

  {
  {
#line 2415
  tmp = bignum_allocate((bignum_length_type )((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(source & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL)),
                        ((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(source & 288230376151711743UL) + 1)) & (1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL))) != 0UL);
#line 2415
  target = tmp;
#line 2417
  bignum_destructive_copy(source, target);
  }
#line 2418
  return (target);
}
}
#line 2421 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
static bignum_type bignum_new_sign(bignum_type bignum , int negative_p ) 
{ 
  bignum_type result ;
  bignum_type tmp ;

  {
  {
#line 2424
  tmp = bignum_allocate((bignum_length_type )((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(bignum & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL)),
                        negative_p);
#line 2424
  result = tmp;
#line 2426
  bignum_destructive_copy(bignum, result);
  }
#line 2427
  return (result);
}
}
#line 2430 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
static bignum_type bignum_maybe_new_sign(bignum_type bignum , int negative_p ) 
{ 
  bignum_type result ;
  bignum_type tmp ;
  int tmp___0 ;

  {
#line 2434
  if (((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(bignum & 288230376151711743UL) + 1)) & (1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL))) != 0UL) {
#line 2434
    tmp___0 = negative_p;
  } else {
#line 2434
    tmp___0 = ! negative_p;
  }
#line 2434
  if (tmp___0) {
#line 2435
    return (bignum);
  } else {
    {
#line 2439
    tmp = bignum_allocate((bignum_length_type )((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(bignum & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL)),
                          negative_p);
#line 2439
    result = tmp;
#line 2441
    bignum_destructive_copy(bignum, result);
    }
#line 2442
    return (result);
  }
}
}
#line 2446 "/home/khheo/project/mit-scheme-9.2/src/microcode/bignum.c"
static void bignum_destructive_copy(bignum_type source , bignum_type target ) 
{ 
  bignum_digit_type *scan_source ;
  bignum_digit_type *end_source ;
  bignum_digit_type *scan_target ;
  bignum_digit_type *tmp ;
  bignum_digit_type *tmp___0 ;

  {
#line 2449
  scan_source = (bignum_digit_type *)((SCHEME_OBJECT *)(source & 288230376151711743UL) + 1) + 1;
#line 2450
  end_source = scan_source + ((unsigned long )*((bignum_digit_type *)((SCHEME_OBJECT *)(source & 288230376151711743UL) + 1)) & ((1UL << (sizeof(bignum_digit_type ) * 8UL - 2UL)) - 1UL));
#line 2452
  scan_target = (bignum_digit_type *)((SCHEME_OBJECT *)(target & 288230376151711743UL) + 1) + 1;
  {
#line 2453
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2453
    if (! ((unsigned long )scan_source < (unsigned long )end_source)) {
#line 2453
      goto while_break;
    }
#line 2454
    tmp = scan_target;
#line 2454
    scan_target ++;
#line 2454
    tmp___0 = scan_source;
#line 2454
    scan_source ++;
#line 2454
    *tmp = *tmp___0;
  }
  while_break: /* CIL Label */ ;
  }
#line 2455
  return;
}
}
#line 54 "/home/khheo/project/mit-scheme-9.2/src/microcode/avltree.h"
void tree_free(tree_node tree ) ;
#line 35 "/home/khheo/project/mit-scheme-9.2/src/microcode/avltree.c"
char const   *tree_error_message  =    (char const   *)0;
#line 36 "/home/khheo/project/mit-scheme-9.2/src/microcode/avltree.c"
char const   *tree_error_noise  =    (char const   *)0;
#line 38 "/home/khheo/project/mit-scheme-9.2/src/microcode/avltree.c"
static void tree_error(char const   *message , char const   *noise ) 
{ 


  {
#line 41
  tree_error_message = message;
#line 42
  tree_error_noise = noise;
#line 43
  return;
}
}
#line 62 "/home/khheo/project/mit-scheme-9.2/src/microcode/avltree.c"
static void update_height(tree_node tree ) 
{ 
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 65
  if ((unsigned long )tree->left == (unsigned long )((tree_node )0)) {
#line 65
    tmp___4 = 0;
  } else {
#line 65
    tmp___4 = (tree->left)->height;
  }
#line 65
  if ((unsigned long )tree->rite == (unsigned long )((tree_node )0)) {
#line 65
    tmp___5 = 0;
  } else {
#line 65
    tmp___5 = (tree->rite)->height;
  }
#line 65
  if (tmp___4 >= tmp___5) {
#line 65
    if ((unsigned long )tree->left == (unsigned long )((tree_node )0)) {
#line 65
      tmp___1 = 0;
    } else {
#line 65
      tmp___1 = (tree->left)->height;
    }
#line 65
    tmp___3 = tmp___1;
  } else {
#line 65
    if ((unsigned long )tree->rite == (unsigned long )((tree_node )0)) {
#line 65
      tmp___2 = 0;
    } else {
#line 65
      tmp___2 = (tree->rite)->height;
    }
#line 65
    tmp___3 = tmp___2;
  }
#line 65
  tree->height = 1 + tmp___3;
#line 67
  return;
}
}
#line 69 "/home/khheo/project/mit-scheme-9.2/src/microcode/avltree.c"
static tree_node leaf_make(char const   *name , unsigned long value ) 
{ 
  tree_node leaf ;
  void *tmp ;
  char *__cil_tmp5 ;

  {
  {
#line 72
  tmp = malloc(sizeof(struct tree_node_s ));
#line 72
  leaf = (tree_node )tmp;
  }
#line 73
  if ((unsigned long )leaf == (unsigned long )((tree_node )0)) {
    {
#line 75
    tree_error("leaf_make: malloc failed.\n", (char const   *)0);
    }
#line 76
    return (leaf);
  }
#line 78
  leaf->name = name;
#line 79
  leaf->value = value;
#line 80
  leaf->height = 1;
#line 81
  leaf->left = (tree_node )0;
#line 82
  leaf->rite = (tree_node )0;
#line 83
  return (leaf);
}
}
#line 86 "/home/khheo/project/mit-scheme-9.2/src/microcode/avltree.c"
static tree_node rotate_left(tree_node tree ) 
{ 
  tree_node rite ;
  tree_node beta ;

  {
  {
#line 89
  rite = tree->rite;
#line 90
  beta = rite->left;
#line 91
  tree->rite = beta;
#line 92
  rite->left = tree;
#line 93
  update_height(tree);
#line 94
  update_height(rite);
  }
#line 95
  return (rite);
}
}
#line 98 "/home/khheo/project/mit-scheme-9.2/src/microcode/avltree.c"
static tree_node rotate_rite(tree_node tree ) 
{ 
  tree_node left ;
  tree_node beta ;

  {
  {
#line 101
  left = tree->left;
#line 102
  beta = left->rite;
#line 103
  tree->left = beta;
#line 104
  left->rite = tree;
#line 105
  update_height(tree);
#line 106
  update_height(left);
  }
#line 107
  return (left);
}
}
#line 110 "/home/khheo/project/mit-scheme-9.2/src/microcode/avltree.c"
static tree_node rebalance_left(tree_node tree ) 
{ 
  tree_node q ;
  int tmp ;
  int tmp___0 ;
  tree_node tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 113
  if ((unsigned long )tree->rite == (unsigned long )((tree_node )0)) {
#line 113
    tmp___2 = 0;
  } else {
#line 113
    tmp___2 = (tree->rite)->height;
  }
#line 113
  if ((unsigned long )tree->left == (unsigned long )((tree_node )0)) {
#line 113
    tmp___3 = 0;
  } else {
#line 113
    tmp___3 = (tree->left)->height;
  }
#line 113
  if (1 + tmp___2 >= tmp___3) {
    {
#line 115
    update_height(tree);
    }
#line 116
    return (tree);
  } else {
#line 120
    q = tree->left;
#line 121
    if ((unsigned long )q->rite == (unsigned long )((tree_node )0)) {
#line 121
      tmp = 0;
    } else {
#line 121
      tmp = (q->rite)->height;
    }
#line 121
    if ((unsigned long )q->left == (unsigned long )((tree_node )0)) {
#line 121
      tmp___0 = 0;
    } else {
#line 121
      tmp___0 = (q->left)->height;
    }
#line 121
    if (tmp > tmp___0) {
      {
#line 122
      tree->left = rotate_left(q);
      }
    }
    {
#line 123
    tmp___1 = rotate_rite(tree);
    }
#line 123
    return (tmp___1);
  }
}
}
#line 127 "/home/khheo/project/mit-scheme-9.2/src/microcode/avltree.c"
static tree_node rebalance_rite(tree_node tree ) 
{ 
  tree_node q ;
  int tmp ;
  int tmp___0 ;
  tree_node tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 130
  if ((unsigned long )tree->left == (unsigned long )((tree_node )0)) {
#line 130
    tmp___2 = 0;
  } else {
#line 130
    tmp___2 = (tree->left)->height;
  }
#line 130
  if ((unsigned long )tree->rite == (unsigned long )((tree_node )0)) {
#line 130
    tmp___3 = 0;
  } else {
#line 130
    tmp___3 = (tree->rite)->height;
  }
#line 130
  if (1 + tmp___2 >= tmp___3) {
    {
#line 132
    update_height(tree);
    }
#line 133
    return (tree);
  } else {
#line 137
    q = tree->rite;
#line 138
    if ((unsigned long )q->left == (unsigned long )((tree_node )0)) {
#line 138
      tmp = 0;
    } else {
#line 138
      tmp = (q->left)->height;
    }
#line 138
    if ((unsigned long )q->rite == (unsigned long )((tree_node )0)) {
#line 138
      tmp___0 = 0;
    } else {
#line 138
      tmp___0 = (q->rite)->height;
    }
#line 138
    if (tmp > tmp___0) {
      {
#line 139
      tree->rite = rotate_rite(q);
      }
    }
    {
#line 140
    tmp___1 = rotate_left(tree);
    }
#line 140
    return (tmp___1);
  }
}
}
#line 144 "/home/khheo/project/mit-scheme-9.2/src/microcode/avltree.c"
tree_node tree_insert(tree_node tree , char const   *name , unsigned long value ) 
{ 
  tree_node tmp ;
  int tmp___0 ;
  tree_node tmp___1 ;
  tree_node tmp___2 ;
  char *__cil_tmp8 ;

  {
#line 147
  if ((unsigned long )tree == (unsigned long )((tree_node )0)) {
    {
#line 148
    tmp = leaf_make(name, value);
    }
#line 148
    return (tmp);
  }
  {
#line 149
  tmp___0 = strcmp_ci(name, tree->name);
  }
  {
#line 151
  if (tmp___0 == 0) {
#line 151
    goto case_0;
  }
#line 155
  if (tmp___0 == -1) {
#line 155
    goto case_neg_1;
  }
#line 161
  if (tmp___0 == 1) {
#line 161
    goto case_1;
  }
#line 149
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 152
  tree_error("tree_insert: Duplicate entry %s.\n", name);
  }
#line 153
  return (tree);
  case_neg_1: /* CIL Label */ 
  {
#line 157
  tree->left = tree_insert(tree->left, name, value);
#line 158
  tmp___1 = rebalance_left(tree);
  }
#line 158
  return (tmp___1);
  case_1: /* CIL Label */ 
  {
#line 163
  tree->rite = tree_insert(tree->rite, name, value);
#line 164
  tmp___2 = rebalance_rite(tree);
  }
#line 164
  return (tmp___2);
  switch_break: /* CIL Label */ ;
  }
#line 168
  return ((tree_node )0);
}
}
#line 171 "/home/khheo/project/mit-scheme-9.2/src/microcode/avltree.c"
tree_node tree_lookup(tree_node tree , char const   *name ) 
{ 
  int tmp ;

  {
  {
#line 174
  while (1) {
    while_continue: /* CIL Label */ ;
#line 174
    if (! ((unsigned long )tree != (unsigned long )((tree_node )0))) {
#line 174
      goto while_break;
    }
    {
#line 175
    tmp = strcmp_ci(name, tree->name);
    }
    {
#line 177
    if (tmp == 0) {
#line 177
      goto case_0;
    }
#line 180
    if (tmp == -1) {
#line 180
      goto case_neg_1;
    }
#line 184
    if (tmp == 1) {
#line 184
      goto case_1;
    }
#line 175
    goto switch_break;
    case_0: /* CIL Label */ 
#line 178
    return (tree);
    case_neg_1: /* CIL Label */ 
#line 181
    tree = tree->left;
#line 182
    goto switch_break;
    case_1: /* CIL Label */ 
#line 185
    tree = tree->rite;
#line 186
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 188
  return (tree);
}
}
#line 194 "/home/khheo/project/mit-scheme-9.2/src/microcode/avltree.c"
static long bias  =    0L;
#line 191 "/home/khheo/project/mit-scheme-9.2/src/microcode/avltree.c"
tree_node tree_build(unsigned long high , char const   **names , unsigned long value ) 
{ 
  tree_node tree ;
  long middle ;
  long next ;
  tree_node tmp ;
  tree_node tmp___0 ;

  {
#line 195
  if (high > 1UL) {
#line 198
    middle = (long )(high / 2UL);
#line 201
    if ((high & 1UL) == 0UL) {
#line 203
      middle -= bias;
#line 204
      bias = 1L - bias;
    }
    {
#line 206
    next = middle + 1L;
#line 207
    tree = leaf_make(*(names + middle), value + (unsigned long )middle);
#line 208
    tree->left = tree_build((unsigned long )middle, names, value);
#line 209
    tree->rite = tree_build(high - (unsigned long )next, names + next, value + (unsigned long )next);
#line 211
    update_height(tree);
    }
#line 212
    return (tree);
  }
#line 214
  if (high == 1UL) {
    {
#line 214
    tmp = leaf_make(*names, value);
#line 214
    tmp___0 = tmp;
    }
  } else {
#line 214
    tmp___0 = (tree_node )0;
  }
#line 214
  return (tmp___0);
}
}
#line 217 "/home/khheo/project/mit-scheme-9.2/src/microcode/avltree.c"
void tree_free(tree_node tree ) 
{ 


  {
#line 220
  if ((unsigned long )tree != (unsigned long )((tree_node )0)) {
    {
#line 222
    tree_free(tree->left);
#line 223
    tree_free(tree->rite);
#line 224
    free((void *)tree);
    }
  }
#line 226
  return;
}
}
#line 115 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) modf)(double __x ,
                                                                              double *__iptr ) ;
#line 178
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) ceil)(double __x )  __attribute__((__const__)) ;
#line 181
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) fabs)(double __x )  __attribute__((__const__)) ;
#line 184
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) floor)(double __x )  __attribute__((__const__)) ;
#line 205 "/home/khheo/project/mit-scheme-9.2/src/microcode/extern.h"
long fixnum_to_long(SCHEME_OBJECT fixnum ) ;
#line 206
SCHEME_OBJECT double_to_fixnum(double value ) ;
#line 215
_Bool integer_to_uintmax_p(SCHEME_OBJECT n ) ;
#line 219
_Bool integer_to_double_p(SCHEME_OBJECT n ) ;
#line 220
double integer_to_double(SCHEME_OBJECT n ) ;
#line 223
double double_round(double x ) ;
#line 271
_Bool double_is_finite_p(double x ) ;
#line 112 "/home/khheo/project/mit-scheme-9.2/src/microcode/bits.h"
__inline static int ulong_first_set_bit(unsigned long x ) 
{ 
  unsigned int tmp ;

  {
#line 112
  if (x == 0UL) {
#line 112
    return (-1);
  }
  {
#line 112
  tmp = ulong_length_in_bits((x ^ (x - 1UL)) >> 1);
  }
#line 112
  return ((int )tmp);
}
}
#line 34 "/home/khheo/project/mit-scheme-9.2/src/microcode/artutl.c"
long fixnum_to_long(SCHEME_OBJECT fixnum ) 
{ 


  {
#line 37
  return ((long )((fixnum ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL)));
}
}
#line 40 "/home/khheo/project/mit-scheme-9.2/src/microcode/artutl.c"
SCHEME_OBJECT double_to_fixnum(double value ) 
{ 


  {
#line 47
  return ((26UL << 58U) | ((unsigned long )((long )value) & 288230376151711743UL));
}
}
#line 51 "/home/khheo/project/mit-scheme-9.2/src/microcode/artutl.c"
_Bool integer_to_long_p(SCHEME_OBJECT n ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 54
  if (n >> 58U == 26UL) {
#line 54
    tmp___0 = 1;
  } else {
    {
#line 54
    tmp = bignum_fits_in_word_p(n, (long )(sizeof(long ) * 8UL), 1);
    }
#line 54
    if (tmp) {
#line 54
      tmp___0 = 1;
    } else {
#line 54
      tmp___0 = 0;
    }
  }
#line 54
  return ((_Bool )tmp___0);
}
}
#line 57 "/home/khheo/project/mit-scheme-9.2/src/microcode/artutl.c"
long integer_to_long(SCHEME_OBJECT n ) 
{ 
  long tmp ;
  long tmp___0 ;

  {
#line 60
  if (n >> 58U == 26UL) {
#line 60
    tmp___0 = (long )((n ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL));
  } else {
    {
#line 60
    tmp = bignum_to_long(n);
#line 60
    tmp___0 = tmp;
    }
  }
#line 60
  return (tmp___0);
}
}
#line 63 "/home/khheo/project/mit-scheme-9.2/src/microcode/artutl.c"
_Bool integer_to_intmax_p(SCHEME_OBJECT n ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 66
  if (n >> 58U == 26UL) {
#line 66
    tmp___0 = 1;
  } else {
    {
#line 66
    tmp = bignum_fits_in_word_p(n, (long )(sizeof(intmax_t ) * 8UL), 1);
    }
#line 66
    if (tmp) {
#line 66
      tmp___0 = 1;
    } else {
#line 66
      tmp___0 = 0;
    }
  }
#line 66
  return ((_Bool )tmp___0);
}
}
#line 69 "/home/khheo/project/mit-scheme-9.2/src/microcode/artutl.c"
intmax_t integer_to_intmax(SCHEME_OBJECT n ) 
{ 
  intmax_t tmp ;
  long tmp___0 ;

  {
#line 72
  if (n >> 58U == 26UL) {
#line 72
    tmp___0 = (long )((n ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL));
  } else {
    {
#line 72
    tmp = bignum_to_intmax(n);
#line 72
    tmp___0 = tmp;
    }
  }
#line 72
  return (tmp___0);
}
}
#line 75 "/home/khheo/project/mit-scheme-9.2/src/microcode/artutl.c"
SCHEME_OBJECT long_to_integer(long number ) 
{ 
  bignum_type tmp ;
  unsigned long tmp___0 ;

  {
#line 78
  if (((unsigned long )number & 0xfe00000000000000UL) == 0UL) {
#line 78
    tmp___0 = (26UL << 58U) | ((unsigned long )number & 288230376151711743UL);
  } else
#line 78
  if (((unsigned long )number & 0xfe00000000000000UL) == 0xfe00000000000000UL) {
#line 78
    tmp___0 = (26UL << 58U) | ((unsigned long )number & 288230376151711743UL);
  } else {
    {
#line 78
    tmp = long_to_bignum(number);
#line 78
    tmp___0 = tmp;
    }
  }
#line 78
  return (tmp___0);
}
}
#line 84 "/home/khheo/project/mit-scheme-9.2/src/microcode/artutl.c"
SCHEME_OBJECT intmax_to_integer(intmax_t number ) 
{ 
  SCHEME_OBJECT tmp ;
  bignum_type tmp___0 ;
  SCHEME_OBJECT tmp___1 ;

  {
#line 87
  if ((-0x7FFFFFFFFFFFFFFF-1) <= number) {
#line 87
    if (number <= 9223372036854775807L) {
      {
#line 87
      tmp = long_to_integer(number);
#line 87
      tmp___1 = tmp;
      }
    } else {
      {
#line 87
      tmp___0 = intmax_to_bignum(number);
#line 87
      tmp___1 = tmp___0;
      }
    }
  } else {
    {
#line 87
    tmp___0 = intmax_to_bignum(number);
#line 87
    tmp___1 = tmp___0;
    }
  }
#line 87
  return (tmp___1);
}
}
#line 93 "/home/khheo/project/mit-scheme-9.2/src/microcode/artutl.c"
_Bool integer_to_ulong_p(SCHEME_OBJECT n ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 96
  if (n >> 58U == 26UL) {
#line 96
    tmp___0 = ! ((n & 144115188075855872UL) != 0UL);
  } else {
    {
#line 96
    tmp = bignum_fits_in_word_p(n, (long )(sizeof(unsigned long ) * 8UL), 0);
#line 96
    tmp___0 = tmp;
    }
  }
#line 96
  return ((_Bool )tmp___0);
}
}
#line 99 "/home/khheo/project/mit-scheme-9.2/src/microcode/artutl.c"
unsigned long integer_to_ulong(SCHEME_OBJECT n ) 
{ 
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
#line 102
  if (n >> 58U == 26UL) {
#line 102
    tmp___0 = (unsigned long )((long )((n ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL)));
  } else {
    {
#line 102
    tmp = bignum_to_ulong(n);
#line 102
    tmp___0 = tmp;
    }
  }
#line 102
  return (tmp___0);
}
}
#line 107 "/home/khheo/project/mit-scheme-9.2/src/microcode/artutl.c"
_Bool integer_to_uintmax_p(SCHEME_OBJECT n ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 110
  if (n >> 58U == 26UL) {
#line 110
    tmp___0 = ! ((n & 144115188075855872UL) != 0UL);
  } else {
    {
#line 110
    tmp = bignum_fits_in_word_p(n, (long )(sizeof(uintmax_t ) * 8UL), 0);
#line 110
    tmp___0 = tmp;
    }
  }
#line 110
  return ((_Bool )tmp___0);
}
}
#line 114 "/home/khheo/project/mit-scheme-9.2/src/microcode/artutl.c"
uintmax_t integer_to_uintmax(SCHEME_OBJECT n ) 
{ 
  uintmax_t tmp ;
  uintmax_t tmp___0 ;

  {
#line 117
  if (n >> 58U == 26UL) {
#line 117
    tmp___0 = (uintmax_t )((long )((n ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL)));
  } else {
    {
#line 117
    tmp = bignum_to_uintmax(n);
#line 117
    tmp___0 = tmp;
    }
  }
#line 117
  return (tmp___0);
}
}
#line 122 "/home/khheo/project/mit-scheme-9.2/src/microcode/artutl.c"
SCHEME_OBJECT ulong_to_integer(unsigned long number ) 
{ 
  long s_number ;
  bignum_type tmp ;
  unsigned long tmp___0 ;
  bignum_type tmp___1 ;

  {
#line 125
  s_number = (long )number;
#line 126
  if (s_number >= 0L) {
#line 127
    if (((unsigned long )s_number & 0xfe00000000000000UL) == 0UL) {
#line 127
      tmp___0 = (26UL << 58U) | ((unsigned long )s_number & 288230376151711743UL);
    } else
#line 127
    if (((unsigned long )s_number & 0xfe00000000000000UL) == 0xfe00000000000000UL) {
#line 127
      tmp___0 = (26UL << 58U) | ((unsigned long )s_number & 288230376151711743UL);
    } else {
      {
#line 127
      tmp = long_to_bignum(s_number);
#line 127
      tmp___0 = tmp;
      }
    }
#line 127
    return (tmp___0);
  } else {
    {
#line 132
    tmp___1 = ulong_to_bignum(number);
    }
#line 132
    return (tmp___1);
  }
}
}
#line 135 "/home/khheo/project/mit-scheme-9.2/src/microcode/artutl.c"
SCHEME_OBJECT uintmax_to_integer(uintmax_t number ) 
{ 
  SCHEME_OBJECT tmp ;
  bignum_type tmp___0 ;
  SCHEME_OBJECT tmp___1 ;

  {
#line 138
  if (number <= 0xffffffffffffffffUL) {
    {
#line 138
    tmp = ulong_to_integer(number);
#line 138
    tmp___1 = tmp;
    }
  } else {
    {
#line 138
    tmp___0 = uintmax_to_bignum(number);
#line 138
    tmp___1 = tmp___0;
    }
  }
#line 138
  return (tmp___1);
}
}
#line 143 "/home/khheo/project/mit-scheme-9.2/src/microcode/artutl.c"
_Bool integer_to_double_p(SCHEME_OBJECT n ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 146
  if (n >> 58U == 26UL) {
#line 146
    tmp___0 = 1;
  } else {
    {
#line 146
    tmp = bignum_fits_in_word_p(n, 1025L, 1);
    }
#line 146
    if (tmp) {
#line 146
      tmp___0 = 1;
    } else {
#line 146
      tmp___0 = 0;
    }
  }
#line 146
  return ((_Bool )tmp___0);
}
}
#line 149 "/home/khheo/project/mit-scheme-9.2/src/microcode/artutl.c"
double integer_to_double(SCHEME_OBJECT n ) 
{ 
  double tmp ;
  double tmp___0 ;

  {
#line 152
  if (n >> 58U == 26UL) {
#line 152
    tmp___0 = (double )((long )((n ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL)));
  } else {
    {
#line 152
    tmp = bignum_to_double(n);
#line 152
    tmp___0 = tmp;
    }
  }
#line 152
  return (tmp___0);
}
}
#line 155 "/home/khheo/project/mit-scheme-9.2/src/microcode/artutl.c"
SCHEME_OBJECT double_to_integer(double x ) 
{ 
  bignum_type tmp ;
  unsigned long tmp___0 ;

  {
#line 158
  if (x > (double )-144115188075855873L) {
#line 158
    if (x < (double )144115188075855872L) {
#line 158
      tmp___0 = (26UL << 58U) | ((unsigned long )((long )x) & 288230376151711743UL);
    } else {
      {
#line 158
      tmp = double_to_bignum(x);
#line 158
      tmp___0 = tmp;
      }
    }
  } else {
    {
#line 158
    tmp = double_to_bignum(x);
#line 158
    tmp___0 = tmp;
    }
  }
#line 158
  return (tmp___0);
}
}
#line 164 "/home/khheo/project/mit-scheme-9.2/src/microcode/artutl.c"
double double_truncate(double x ) 
{ 
  double iptr ;

  {
  {
#line 168
  modf(x, & iptr);
  }
#line 169
  return (iptr);
}
}
#line 172 "/home/khheo/project/mit-scheme-9.2/src/microcode/artutl.c"
double double_round(double x ) 
{ 
  double integral ;
  double fractional ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  int tmp___2 ;

  {
  {
#line 176
  tmp = modf(x, & integral);
#line 176
  tmp___0 = fabs(tmp);
#line 176
  fractional = tmp___0;
  }
#line 178
  if (fractional == 0.5) {
    {
#line 178
    tmp___1 = fmod(integral, 2.0);
#line 178
    tmp___2 = tmp___1 == 0.0;
    }
  } else {
#line 178
    tmp___2 = ! (0.5 < fractional);
  }
#line 178
  if (tmp___2) {
#line 181
    return (integral);
  } else
#line 182
  if (x < 0.0) {
#line 183
    return (integral - 1.0);
  } else {
#line 185
    return (integral + 1.0);
  }
}
}
#line 190 "/home/khheo/project/mit-scheme-9.2/src/microcode/artutl.c"
SCHEME_OBJECT bignum_to_fixnum(SCHEME_OBJECT bignum ) 
{ 
  long tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;

  {
  {
#line 193
  tmp___2 = bignum_fits_in_word_p(bignum, 58L, 1);
  }
#line 193
  if (tmp___2) {
    {
#line 193
    tmp___0 = bignum_to_long(bignum);
#line 193
    tmp___1 = (26UL << 58U) | ((unsigned long )tmp___0 & 288230376151711743UL);
    }
  } else {
#line 193
    tmp___1 = 0UL;
  }
#line 193
  return (tmp___1);
}
}
#line 199 "/home/khheo/project/mit-scheme-9.2/src/microcode/artutl.c"
SCHEME_OBJECT bignum_to_integer(SCHEME_OBJECT bignum ) 
{ 
  long tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;

  {
  {
#line 202
  tmp___2 = bignum_fits_in_word_p(bignum, 58L, 1);
  }
#line 202
  if (tmp___2) {
    {
#line 202
    tmp___0 = bignum_to_long(bignum);
#line 202
    tmp___1 = (26UL << 58U) | ((unsigned long )tmp___0 & 288230376151711743UL);
    }
  } else {
#line 202
    tmp___1 = bignum;
  }
#line 202
  return (tmp___1);
}
}
#line 208 "/home/khheo/project/mit-scheme-9.2/src/microcode/artutl.c"
SCHEME_OBJECT bignum_to_flonum(SCHEME_OBJECT bignum ) 
{ 
  double tmp___0 ;
  SCHEME_OBJECT tmp___1 ;
  SCHEME_OBJECT tmp___2 ;
  int tmp___3 ;

  {
  {
#line 211
  tmp___3 = bignum_fits_in_word_p(bignum, 1025L, 1);
  }
#line 211
  if (tmp___3) {
    {
#line 211
    tmp___0 = bignum_to_double(bignum);
#line 211
    tmp___1 = double_to_flonum(tmp___0);
#line 211
    tmp___2 = tmp___1;
    }
  } else {
#line 211
    tmp___2 = 0UL;
  }
#line 211
  return (tmp___2);
}
}
#line 217 "/home/khheo/project/mit-scheme-9.2/src/microcode/artutl.c"
_Bool finite_flonum_p(SCHEME_OBJECT x ) 
{ 
  _Bool tmp ;
  int tmp___0 ;

  {
#line 220
  if (x >> 58U == 6UL) {
    {
#line 220
    tmp = flonum_is_finite_p(x);
    }
#line 220
    if (tmp) {
#line 220
      tmp___0 = 1;
    } else {
#line 220
      tmp___0 = 0;
    }
  } else {
#line 220
    tmp___0 = 0;
  }
#line 220
  return ((_Bool )tmp___0);
}
}
#line 223 "/home/khheo/project/mit-scheme-9.2/src/microcode/artutl.c"
_Bool flonum_is_finite_p(SCHEME_OBJECT x ) 
{ 
  _Bool tmp ;

  {
  {
#line 226
  tmp = double_is_finite_p(*((double *)((SCHEME_OBJECT *)(x & 288230376151711743UL) + 1)));
  }
#line 226
  return (tmp);
}
}
#line 229 "/home/khheo/project/mit-scheme-9.2/src/microcode/artutl.c"
_Bool double_is_finite_p(double x ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 232
  if (x > 1.0) {
#line 232
    tmp___0 = x != x / 2.0;
  } else
#line 232
  if (x < - 1.0) {
#line 232
    tmp___0 = x != x / 2.0;
  } else {
#line 232
    if (x <= 1.0) {
#line 232
      if (x >= - 1.0) {
#line 232
        tmp = 1;
      } else {
#line 232
        tmp = 0;
      }
    } else {
#line 232
      tmp = 0;
    }
#line 232
    tmp___0 = tmp;
  }
#line 232
  return ((_Bool )tmp___0);
}
}
#line 238 "/home/khheo/project/mit-scheme-9.2/src/microcode/artutl.c"
_Bool flonum_integer_p(SCHEME_OBJECT x ) 
{ 
  double iptr ;
  double tmp ;

  {
  {
#line 242
  tmp = modf(*((double *)((SCHEME_OBJECT *)(x & 288230376151711743UL) + 1)), & iptr);
  }
#line 242
  return ((_Bool )(tmp == (double )0));
}
}
#line 245 "/home/khheo/project/mit-scheme-9.2/src/microcode/artutl.c"
SCHEME_OBJECT flonum_floor(SCHEME_OBJECT x ) 
{ 
  double tmp ;
  SCHEME_OBJECT tmp___0 ;

  {
  {
#line 248
  tmp = floor(*((double *)((SCHEME_OBJECT *)(x & 288230376151711743UL) + 1)));
#line 248
  tmp___0 = double_to_flonum(tmp);
  }
#line 248
  return (tmp___0);
}
}
#line 251 "/home/khheo/project/mit-scheme-9.2/src/microcode/artutl.c"
SCHEME_OBJECT flonum_ceiling(SCHEME_OBJECT x ) 
{ 
  double tmp ;
  SCHEME_OBJECT tmp___0 ;

  {
  {
#line 254
  tmp = ceil(*((double *)((SCHEME_OBJECT *)(x & 288230376151711743UL) + 1)));
#line 254
  tmp___0 = double_to_flonum(tmp);
  }
#line 254
  return (tmp___0);
}
}
#line 257 "/home/khheo/project/mit-scheme-9.2/src/microcode/artutl.c"
SCHEME_OBJECT flonum_round(SCHEME_OBJECT x ) 
{ 
  double tmp ;
  SCHEME_OBJECT tmp___0 ;

  {
  {
#line 260
  tmp = double_round(*((double *)((SCHEME_OBJECT *)(x & 288230376151711743UL) + 1)));
#line 260
  tmp___0 = double_to_flonum(tmp);
  }
#line 260
  return (tmp___0);
}
}
#line 263 "/home/khheo/project/mit-scheme-9.2/src/microcode/artutl.c"
SCHEME_OBJECT flonum_normalize(SCHEME_OBJECT x ) 
{ 
  int exponent ;
  double significand___0 ;
  double tmp ;
  SCHEME_OBJECT tmp___0 ;
  SCHEME_OBJECT tmp___1 ;
  SCHEME_OBJECT tmp___2 ;

  {
  {
#line 267
  tmp = frexp(*((double *)((SCHEME_OBJECT *)(x & 288230376151711743UL) + 1)), & exponent);
#line 267
  significand___0 = tmp;
#line 268
  tmp___0 = long_to_integer((long )exponent);
#line 268
  tmp___1 = double_to_flonum(significand___0);
#line 268
  tmp___2 = cons(tmp___1, tmp___0);
  }
#line 268
  return (tmp___2);
}
}
#line 272 "/home/khheo/project/mit-scheme-9.2/src/microcode/artutl.c"
SCHEME_OBJECT flonum_denormalize(SCHEME_OBJECT x , SCHEME_OBJECT e ) 
{ 
  long tmp ;
  double tmp___0 ;
  SCHEME_OBJECT tmp___1 ;

  {
  {
#line 275
  tmp = integer_to_long(e);
#line 275
  tmp___0 = ldexp(*((double *)((SCHEME_OBJECT *)(x & 288230376151711743UL) + 1)),
                  (int )tmp);
#line 275
  tmp___1 = double_to_flonum(tmp___0);
  }
#line 275
  return (tmp___1);
}
}
#line 281 "/home/khheo/project/mit-scheme-9.2/src/microcode/artutl.c"
_Bool integer_zero_p(SCHEME_OBJECT n ) 
{ 
  enum bignum_comparison tmp ;
  int tmp___0 ;

  {
#line 284
  if (n >> 58U == 26UL) {
#line 284
    tmp___0 = (n & 288230376151711743UL) == 0UL;
  } else {
    {
#line 284
    tmp = bignum_test(n);
#line 284
    tmp___0 = (unsigned int )tmp == 0U;
    }
  }
#line 284
  return ((_Bool )tmp___0);
}
}
#line 287 "/home/khheo/project/mit-scheme-9.2/src/microcode/artutl.c"
_Bool integer_negative_p(SCHEME_OBJECT n ) 
{ 
  enum bignum_comparison tmp ;
  int tmp___0 ;

  {
#line 290
  if (n >> 58U == 26UL) {
#line 290
    tmp___0 = (n & 144115188075855872UL) != 0UL;
  } else {
    {
#line 290
    tmp = bignum_test(n);
#line 290
    tmp___0 = (unsigned int )tmp == 1U;
    }
  }
#line 290
  return ((_Bool )tmp___0);
}
}
#line 293 "/home/khheo/project/mit-scheme-9.2/src/microcode/artutl.c"
_Bool integer_positive_p(SCHEME_OBJECT n ) 
{ 
  int tmp ;
  enum bignum_comparison tmp___0 ;
  int tmp___1 ;

  {
#line 296
  if (n >> 58U == 26UL) {
#line 296
    if ((n & 288230376151711743UL) == 0UL) {
#line 296
      tmp = 0;
    } else
#line 296
    if ((n & 144115188075855872UL) != 0UL) {
#line 296
      tmp = 0;
    } else {
#line 296
      tmp = 1;
    }
#line 296
    tmp___1 = tmp;
  } else {
    {
#line 296
    tmp___0 = bignum_test(n);
#line 296
    tmp___1 = (unsigned int )tmp___0 == 2U;
    }
  }
#line 296
  return ((_Bool )tmp___1);
}
}
#line 299 "/home/khheo/project/mit-scheme-9.2/src/microcode/artutl.c"
_Bool integer_equal_p(SCHEME_OBJECT n , SCHEME_OBJECT m ) 
{ 
  bignum_type tmp ;
  int tmp___0 ;
  int tmp___1 ;
  bignum_type tmp___2 ;
  bignum_type tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 302
  if (n >> 58U == 26UL) {
#line 302
    if (m >> 58U == 26UL) {
#line 302
      tmp___1 = (n & 288230376151711743UL) == (m & 288230376151711743UL);
    } else {
      {
#line 302
      tmp = long_to_bignum((long )((n ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL)));
#line 302
      tmp___0 = bignum_equal_p(tmp, m);
#line 302
      tmp___1 = tmp___0;
      }
    }
#line 302
    tmp___5 = tmp___1;
  } else {
#line 302
    if (m >> 58U == 26UL) {
      {
#line 302
      tmp___2 = long_to_bignum((long )((m ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL)));
#line 302
      tmp___3 = tmp___2;
      }
    } else {
#line 302
      tmp___3 = m;
    }
    {
#line 302
    tmp___4 = bignum_equal_p(n, tmp___3);
#line 302
    tmp___5 = tmp___4;
    }
  }
#line 302
  return ((_Bool )tmp___5);
}
}
#line 310 "/home/khheo/project/mit-scheme-9.2/src/microcode/artutl.c"
_Bool integer_less_p(SCHEME_OBJECT n , SCHEME_OBJECT m ) 
{ 
  bignum_type tmp ;
  enum bignum_comparison tmp___0 ;
  int tmp___1 ;
  bignum_type tmp___2 ;
  bignum_type tmp___3 ;
  enum bignum_comparison tmp___4 ;
  int tmp___5 ;

  {
#line 313
  if (n >> 58U == 26UL) {
#line 313
    if (m >> 58U == 26UL) {
#line 313
      tmp___1 = (long )((n ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL)) < (long )((m ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL));
    } else {
      {
#line 313
      tmp = long_to_bignum((long )((n ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL)));
#line 313
      tmp___0 = bignum_compare(tmp, m);
#line 313
      tmp___1 = (unsigned int )tmp___0 == 1U;
      }
    }
#line 313
    tmp___5 = tmp___1;
  } else {
#line 313
    if (m >> 58U == 26UL) {
      {
#line 313
      tmp___2 = long_to_bignum((long )((m ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL)));
#line 313
      tmp___3 = tmp___2;
      }
    } else {
#line 313
      tmp___3 = m;
    }
    {
#line 313
    tmp___4 = bignum_compare(n, tmp___3);
#line 313
    tmp___5 = (unsigned int )tmp___4 == 1U;
    }
  }
#line 313
  return ((_Bool )tmp___5);
}
}
#line 321 "/home/khheo/project/mit-scheme-9.2/src/microcode/artutl.c"
SCHEME_OBJECT integer_negate(SCHEME_OBJECT n ) 
{ 
  SCHEME_OBJECT tmp ;
  bignum_type tmp___0 ;
  SCHEME_OBJECT tmp___1 ;
  SCHEME_OBJECT tmp___2 ;

  {
#line 324
  if (n >> 58U == 26UL) {
    {
#line 324
    tmp = long_to_integer(- ((long )((n ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL))));
#line 324
    tmp___2 = tmp;
    }
  } else {
    {
#line 324
    tmp___0 = bignum_negate(n);
#line 324
    tmp___1 = bignum_to_integer(tmp___0);
#line 324
    tmp___2 = tmp___1;
    }
  }
#line 324
  return (tmp___2);
}
}
#line 330 "/home/khheo/project/mit-scheme-9.2/src/microcode/artutl.c"
SCHEME_OBJECT integer_add(SCHEME_OBJECT n , SCHEME_OBJECT m ) 
{ 
  SCHEME_OBJECT tmp ;
  bignum_type tmp___0 ;
  bignum_type tmp___1 ;
  SCHEME_OBJECT tmp___2 ;
  SCHEME_OBJECT tmp___3 ;
  bignum_type tmp___4 ;
  bignum_type tmp___5 ;
  bignum_type tmp___6 ;
  SCHEME_OBJECT tmp___7 ;
  SCHEME_OBJECT tmp___8 ;

  {
#line 333
  if (n >> 58U == 26UL) {
#line 333
    if (m >> 58U == 26UL) {
      {
#line 333
      tmp = long_to_integer((long )((n ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL)) + (long )((m ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL)));
#line 333
      tmp___3 = tmp;
      }
    } else {
      {
#line 333
      tmp___0 = long_to_bignum((long )((n ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL)));
#line 333
      tmp___1 = bignum_add(tmp___0, m);
#line 333
      tmp___2 = bignum_to_integer(tmp___1);
#line 333
      tmp___3 = tmp___2;
      }
    }
#line 333
    tmp___8 = tmp___3;
  } else {
#line 333
    if (m >> 58U == 26UL) {
      {
#line 333
      tmp___4 = long_to_bignum((long )((m ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL)));
#line 333
      tmp___5 = tmp___4;
      }
    } else {
#line 333
      tmp___5 = m;
    }
    {
#line 333
    tmp___6 = bignum_add(n, tmp___5);
#line 333
    tmp___7 = bignum_to_integer(tmp___6);
#line 333
    tmp___8 = tmp___7;
    }
  }
#line 333
  return (tmp___8);
}
}
#line 342 "/home/khheo/project/mit-scheme-9.2/src/microcode/artutl.c"
SCHEME_OBJECT integer_add_1(SCHEME_OBJECT n ) 
{ 
  SCHEME_OBJECT tmp ;
  bignum_type tmp___0 ;
  bignum_type tmp___1 ;
  SCHEME_OBJECT tmp___2 ;
  SCHEME_OBJECT tmp___3 ;

  {
#line 345
  if (n >> 58U == 26UL) {
    {
#line 345
    tmp = long_to_integer((long )((n ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL)) + 1L);
#line 345
    tmp___3 = tmp;
    }
  } else {
    {
#line 345
    tmp___0 = long_to_bignum(1L);
#line 345
    tmp___1 = bignum_add(n, tmp___0);
#line 345
    tmp___2 = bignum_to_integer(tmp___1);
#line 345
    tmp___3 = tmp___2;
    }
  }
#line 345
  return (tmp___3);
}
}
#line 351 "/home/khheo/project/mit-scheme-9.2/src/microcode/artutl.c"
SCHEME_OBJECT integer_subtract(SCHEME_OBJECT n , SCHEME_OBJECT m ) 
{ 
  SCHEME_OBJECT tmp ;
  bignum_type tmp___0 ;
  bignum_type tmp___1 ;
  SCHEME_OBJECT tmp___2 ;
  SCHEME_OBJECT tmp___3 ;
  bignum_type tmp___4 ;
  bignum_type tmp___5 ;
  bignum_type tmp___6 ;
  SCHEME_OBJECT tmp___7 ;
  SCHEME_OBJECT tmp___8 ;

  {
#line 354
  if (n >> 58U == 26UL) {
#line 354
    if (m >> 58U == 26UL) {
      {
#line 354
      tmp = long_to_integer((long )((n ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL)) - (long )((m ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL)));
#line 354
      tmp___3 = tmp;
      }
    } else {
      {
#line 354
      tmp___0 = long_to_bignum((long )((n ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL)));
#line 354
      tmp___1 = bignum_subtract(tmp___0, m);
#line 354
      tmp___2 = bignum_to_integer(tmp___1);
#line 354
      tmp___3 = tmp___2;
      }
    }
#line 354
    tmp___8 = tmp___3;
  } else {
#line 354
    if (m >> 58U == 26UL) {
      {
#line 354
      tmp___4 = long_to_bignum((long )((m ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL)));
#line 354
      tmp___5 = tmp___4;
      }
    } else {
#line 354
      tmp___5 = m;
    }
    {
#line 354
    tmp___6 = bignum_subtract(n, tmp___5);
#line 354
    tmp___7 = bignum_to_integer(tmp___6);
#line 354
    tmp___8 = tmp___7;
    }
  }
#line 354
  return (tmp___8);
}
}
#line 363 "/home/khheo/project/mit-scheme-9.2/src/microcode/artutl.c"
SCHEME_OBJECT integer_subtract_1(SCHEME_OBJECT n ) 
{ 
  SCHEME_OBJECT tmp ;
  bignum_type tmp___0 ;
  bignum_type tmp___1 ;
  SCHEME_OBJECT tmp___2 ;
  SCHEME_OBJECT tmp___3 ;

  {
#line 366
  if (n >> 58U == 26UL) {
    {
#line 366
    tmp = long_to_integer((long )((n ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL)) - 1L);
#line 366
    tmp___3 = tmp;
    }
  } else {
    {
#line 366
    tmp___0 = long_to_bignum(1L);
#line 366
    tmp___1 = bignum_subtract(n, tmp___0);
#line 366
    tmp___2 = bignum_to_integer(tmp___1);
#line 366
    tmp___3 = tmp___2;
    }
  }
#line 366
  return (tmp___3);
}
}
#line 372 "/home/khheo/project/mit-scheme-9.2/src/microcode/artutl.c"
SCHEME_OBJECT integer_multiply(SCHEME_OBJECT n , SCHEME_OBJECT m ) 
{ 
  SCHEME_OBJECT result ;
  bignum_type tmp ;
  bignum_type tmp___0 ;
  bignum_type tmp___1 ;
  SCHEME_OBJECT tmp___2 ;
  SCHEME_OBJECT tmp___3 ;
  bignum_type tmp___4 ;
  bignum_type tmp___5 ;
  SCHEME_OBJECT tmp___6 ;
  SCHEME_OBJECT tmp___7 ;
  bignum_type tmp___8 ;
  bignum_type tmp___9 ;
  bignum_type tmp___10 ;
  SCHEME_OBJECT tmp___11 ;
  SCHEME_OBJECT tmp___12 ;

  {
#line 376
  if (n >> 58U == 26UL) {
#line 376
    if (m >> 58U == 26UL) {
      {
#line 376
      result = Mul(n, m);
      }
#line 376
      if (result != 0UL) {
#line 376
        tmp___3 = result;
      } else {
        {
#line 376
        tmp = long_to_bignum((long )((m ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL)));
#line 376
        tmp___0 = long_to_bignum((long )((n ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL)));
#line 376
        tmp___1 = bignum_multiply(tmp___0, tmp);
#line 376
        tmp___2 = bignum_to_integer(tmp___1);
#line 376
        tmp___3 = tmp___2;
        }
      }
#line 376
      tmp___7 = tmp___3;
    } else {
      {
#line 376
      tmp___4 = long_to_bignum((long )((n ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL)));
#line 376
      tmp___5 = bignum_multiply(tmp___4, m);
#line 376
      tmp___6 = bignum_to_integer(tmp___5);
#line 376
      tmp___7 = tmp___6;
      }
    }
#line 376
    tmp___12 = tmp___7;
  } else {
#line 376
    if (m >> 58U == 26UL) {
      {
#line 376
      tmp___8 = long_to_bignum((long )((m ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL)));
#line 376
      tmp___9 = tmp___8;
      }
    } else {
#line 376
      tmp___9 = m;
    }
    {
#line 376
    tmp___10 = bignum_multiply(n, tmp___9);
#line 376
    tmp___11 = bignum_to_integer(tmp___10);
#line 376
    tmp___12 = tmp___11;
    }
  }
#line 376
  return (tmp___12);
}
}
#line 390 "/home/khheo/project/mit-scheme-9.2/src/microcode/artutl.c"
_Bool integer_divide(SCHEME_OBJECT n , SCHEME_OBJECT d , SCHEME_OBJECT *q , SCHEME_OBJECT *r ) 
{ 
  long lx ;
  long ly ;
  long quotient ;
  long remainder___0 ;
  SCHEME_OBJECT quotient___0 ;
  SCHEME_OBJECT remainder___1 ;
  int tmp ;

  {
#line 394
  if (n >> 58U == 26UL) {
#line 396
    if (d >> 58U == 26UL) {
#line 401
      lx = (long )((n ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL));
#line 402
      ly = (long )((d ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL));
#line 405
      if (ly == 0L) {
#line 406
        return ((_Bool)1);
      }
#line 407
      if (lx < 0L) {
#line 409
        lx = - lx;
#line 410
        if (ly < 0L) {
#line 412
          ly = - ly;
#line 413
          quotient = lx / ly;
        } else {
#line 416
          quotient = - (lx / ly);
        }
#line 417
        remainder___0 = - (lx % ly);
      } else {
#line 421
        if (ly < 0L) {
#line 423
          ly = - ly;
#line 424
          quotient = - (lx / ly);
        } else {
#line 427
          quotient = lx / ly;
        }
#line 428
        remainder___0 = lx % ly;
      }
      {
#line 430
      *q = long_to_integer(quotient);
#line 431
      *r = (26UL << 58U) | ((unsigned long )remainder___0 & 288230376151711743UL);
      }
#line 432
      return ((_Bool)0);
    }
    {
#line 434
    n = long_to_bignum((long )((n ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL)));
    }
  } else
#line 438
  if (d >> 58U == 26UL) {
    {
#line 439
    d = long_to_bignum((long )((d ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL)));
    }
  }
  {
#line 444
  tmp = bignum_divide(n, d, & quotient___0, & remainder___1);
  }
#line 444
  if (tmp) {
#line 445
    return ((_Bool)1);
  }
  {
#line 446
  *q = bignum_to_integer(quotient___0);
#line 447
  *r = bignum_to_integer(remainder___1);
  }
#line 448
  return ((_Bool)0);
}
}
#line 452 "/home/khheo/project/mit-scheme-9.2/src/microcode/artutl.c"
SCHEME_OBJECT integer_quotient(SCHEME_OBJECT n , SCHEME_OBJECT d ) 
{ 
  long lx ;
  long ly ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  SCHEME_OBJECT tmp___2 ;
  unsigned long tmp___3 ;
  SCHEME_OBJECT result ;
  bignum_type tmp___4 ;
  SCHEME_OBJECT tmp___5 ;
  unsigned long tmp___6 ;

  {
#line 455
  if (n >> 58U == 26UL) {
#line 457
    if (d >> 58U == 26UL) {
#line 459
      lx = (long )((n ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL));
#line 460
      ly = (long )((d ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL));
#line 461
      if (ly == 0L) {
#line 461
        tmp___3 = 0UL;
      } else {
#line 461
        if (lx < 0L) {
#line 461
          if (ly < 0L) {
#line 461
            tmp = - lx / - ly;
          } else {
#line 461
            tmp = - (- lx / ly);
          }
#line 461
          tmp___1 = tmp;
        } else {
#line 461
          if (ly < 0L) {
#line 461
            tmp___0 = - (lx / - ly);
          } else {
#line 461
            tmp___0 = lx / ly;
          }
#line 461
          tmp___1 = tmp___0;
        }
        {
#line 461
        tmp___2 = long_to_integer(tmp___1);
#line 461
        tmp___3 = tmp___2;
        }
      }
#line 461
      return (tmp___3);
    }
    {
#line 473
    n = long_to_bignum((long )((n ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL)));
    }
  } else
#line 477
  if (d >> 58U == 26UL) {
    {
#line 478
    d = long_to_bignum((long )((d ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL)));
    }
  }
  {
#line 481
  tmp___4 = bignum_quotient(n, d);
#line 481
  result = tmp___4;
  }
#line 482
  if (result == 0UL) {
#line 482
    tmp___6 = 0UL;
  } else {
    {
#line 482
    tmp___5 = bignum_to_integer(result);
#line 482
    tmp___6 = tmp___5;
    }
  }
#line 482
  return (tmp___6);
}
}
#line 486 "/home/khheo/project/mit-scheme-9.2/src/microcode/artutl.c"
SCHEME_OBJECT integer_remainder(SCHEME_OBJECT n , SCHEME_OBJECT d ) 
{ 
  long lx ;
  long ly ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  SCHEME_OBJECT tmp___2 ;
  unsigned long tmp___3 ;
  SCHEME_OBJECT result ;
  bignum_type tmp___4 ;
  SCHEME_OBJECT tmp___5 ;
  unsigned long tmp___6 ;

  {
#line 489
  if (n >> 58U == 26UL) {
#line 491
    if (d >> 58U == 26UL) {
#line 493
      lx = (long )((n ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL));
#line 494
      ly = (long )((d ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL));
#line 495
      if (ly == 0L) {
#line 495
        tmp___3 = 0UL;
      } else {
#line 495
        if (lx < 0L) {
#line 495
          if (ly < 0L) {
#line 495
            tmp = - ly;
          } else {
#line 495
            tmp = ly;
          }
#line 495
          tmp___1 = - (- lx % tmp);
        } else {
#line 495
          if (ly < 0L) {
#line 495
            tmp___0 = - ly;
          } else {
#line 495
            tmp___0 = ly;
          }
#line 495
          tmp___1 = lx % tmp___0;
        }
        {
#line 495
        tmp___2 = long_to_integer(tmp___1);
#line 495
        tmp___3 = tmp___2;
        }
      }
#line 495
      return (tmp___3);
    }
    {
#line 503
    n = long_to_bignum((long )((n ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL)));
    }
  } else
#line 507
  if (d >> 58U == 26UL) {
    {
#line 508
    d = long_to_bignum((long )((d ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL)));
    }
  }
  {
#line 511
  tmp___4 = bignum_remainder(n, d);
#line 511
  result = tmp___4;
  }
#line 512
  if (result == 0UL) {
#line 512
    tmp___6 = 0UL;
  } else {
    {
#line 512
    tmp___5 = bignum_to_integer(result);
#line 512
    tmp___6 = tmp___5;
    }
  }
#line 512
  return (tmp___6);
}
}
#line 523 "/home/khheo/project/mit-scheme-9.2/src/microcode/artutl.c"
SCHEME_OBJECT integer_length_in_bits(SCHEME_OBJECT n ) 
{ 
  long n1 ;
  long tmp ;
  unsigned int tmp___0 ;
  unsigned long tmp___1 ;
  SCHEME_OBJECT tmp___2 ;

  {
#line 526
  if (n >> 58U == 26UL) {
#line 528
    n1 = (long )((n ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL));
#line 529
    if (n1 < 0L) {
#line 529
      tmp = - n1;
    } else {
#line 529
      tmp = n1;
    }
    {
#line 529
    tmp___0 = ulong_length_in_bits((unsigned long )tmp);
    }
#line 529
    return ((26UL << 58U) | (unsigned long )tmp___0);
  } else {
    {
#line 532
    tmp___1 = bignum_length_in_bits(n);
#line 532
    tmp___2 = ulong_to_integer(tmp___1);
    }
#line 532
    return (tmp___2);
  }
}
}
#line 537 "/home/khheo/project/mit-scheme-9.2/src/microcode/artutl.c"
SCHEME_OBJECT integer_length(SCHEME_OBJECT n ) 
{ 
  long n1 ;
  long tmp ;
  unsigned int tmp___0 ;
  unsigned long tmp___1 ;
  SCHEME_OBJECT tmp___2 ;

  {
#line 540
  if (n >> 58U == 26UL) {
#line 542
    n1 = (long )((n ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL));
#line 543
    if (n1 < 0L) {
#line 543
      tmp = ~ n1;
    } else {
#line 543
      tmp = n1;
    }
    {
#line 543
    tmp___0 = ulong_length_in_bits((unsigned long )tmp);
    }
#line 543
    return ((26UL << 58U) | (unsigned long )tmp___0);
  } else {
    {
#line 546
    tmp___1 = bignum_integer_length(n);
#line 546
    tmp___2 = ulong_to_integer(tmp___1);
    }
#line 546
    return (tmp___2);
  }
}
}
#line 549 "/home/khheo/project/mit-scheme-9.2/src/microcode/artutl.c"
SCHEME_OBJECT integer_first_set_bit(SCHEME_OBJECT n ) 
{ 
  long n1 ;
  unsigned long tmp ;
  int tmp___0 ;
  long tmp___1 ;
  SCHEME_OBJECT tmp___2 ;

  {
#line 552
  if (n >> 58U == 26UL) {
#line 554
    n1 = (long )((n ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL));
#line 555
    if (n1 < 0L) {
#line 555
      tmp = ~ ((unsigned long )(~ n1));
    } else {
#line 555
      tmp = (unsigned long )n1;
    }
    {
#line 555
    tmp___0 = ulong_first_set_bit(tmp);
    }
#line 555
    return ((26UL << 58U) | ((unsigned long )tmp___0 & 288230376151711743UL));
  } else {
    {
#line 560
    tmp___1 = bignum_first_set_bit(n);
#line 560
    tmp___2 = long_to_integer(tmp___1);
    }
#line 560
    return (tmp___2);
  }
}
}
#line 563 "/home/khheo/project/mit-scheme-9.2/src/microcode/artutl.c"
SCHEME_OBJECT integer_bit_count(SCHEME_OBJECT n ) 
{ 
  long n1 ;
  long tmp ;
  unsigned int tmp___0 ;
  unsigned long tmp___1 ;
  SCHEME_OBJECT tmp___2 ;

  {
#line 566
  if (n >> 58U == 26UL) {
#line 568
    n1 = (long )((n ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL));
#line 569
    if (n1 < 0L) {
#line 569
      tmp = ~ n1;
    } else {
#line 569
      tmp = n1;
    }
    {
#line 569
    tmp___0 = ulong_bit_count((unsigned long )tmp);
    }
#line 569
    return ((26UL << 58U) | (unsigned long )tmp___0);
  } else {
    {
#line 572
    tmp___1 = bignum_bit_count(n);
#line 572
    tmp___2 = ulong_to_integer(tmp___1);
    }
#line 572
    return (tmp___2);
  }
}
}
#line 575 "/home/khheo/project/mit-scheme-9.2/src/microcode/artutl.c"
SCHEME_OBJECT integer_hamming_distance(SCHEME_OBJECT n , SCHEME_OBJECT m ) 
{ 
  long x ;
  unsigned int tmp ;
  unsigned long tmp___0 ;
  bignum_type tmp___1 ;
  bignum_type tmp___2 ;
  bignum_type tmp___3 ;
  bignum_type tmp___4 ;
  long tmp___5 ;
  SCHEME_OBJECT tmp___6 ;

  {
#line 578
  if (n >> 58U == 26UL) {
#line 578
    if (m >> 58U == 26UL) {
#line 580
      x = (long )((n ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL)) ^ (long )((m ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL));
#line 581
      if (x < 0L) {
#line 581
        tmp___0 = (26UL << 58U) | 288230376151711743UL;
      } else {
        {
#line 581
        tmp = ulong_bit_count((unsigned long )x);
#line 581
        tmp___0 = (26UL << 58U) | (unsigned long )tmp;
        }
      }
#line 581
      return (tmp___0);
    } else {
#line 578
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 587
    if (m >> 58U == 26UL) {
      {
#line 587
      tmp___1 = long_to_bignum((long )((m ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL)));
#line 587
      tmp___2 = tmp___1;
      }
    } else {
#line 587
      tmp___2 = m;
    }
#line 587
    if (n >> 58U == 26UL) {
      {
#line 587
      tmp___3 = long_to_bignum((long )((n ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL)));
#line 587
      tmp___4 = tmp___3;
      }
    } else {
#line 587
      tmp___4 = n;
    }
    {
#line 587
    tmp___5 = bignum_hamming_distance(tmp___4, tmp___2);
#line 587
    tmp___6 = long_to_integer(tmp___5);
    }
#line 587
    return (tmp___6);
  }
}
}
#line 596 "/home/khheo/project/mit-scheme-9.2/src/microcode/artutl.c"
SCHEME_OBJECT integer_bitwise_not(SCHEME_OBJECT n ) 
{ 
  bignum_type tmp ;

  {
#line 599
  if (n >> 58U == 26UL) {
#line 600
    return ((26UL << 58U) | ((unsigned long )(~ ((long )((n ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL)))) & 288230376151711743UL));
  } else {
    {
#line 602
    tmp = bignum_bitwise_not(n);
    }
#line 602
    return (tmp);
  }
}
}
#line 632 "/home/khheo/project/mit-scheme-9.2/src/microcode/artutl.c"
SCHEME_OBJECT integer_bitwise_and(SCHEME_OBJECT n , SCHEME_OBJECT m ) 
{ 
  bignum_type tmp ;
  bignum_type tmp___0 ;
  bignum_type tmp___1 ;
  bignum_type tmp___2 ;
  bignum_type tmp___3 ;
  SCHEME_OBJECT tmp___4 ;

  {
#line 632
  if (n >> 58U == 26UL) {
#line 632
    if (m >> 58U == 26UL) {
#line 632
      return ((26UL << 58U) | ((unsigned long )((long )((n ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL)) & (long )((m ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL))) & 288230376151711743UL));
    } else {
#line 632
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 632
    if (m >> 58U == 26UL) {
      {
#line 632
      tmp = long_to_bignum((long )((m ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL)));
#line 632
      tmp___0 = tmp;
      }
    } else {
#line 632
      tmp___0 = m;
    }
#line 632
    if (n >> 58U == 26UL) {
      {
#line 632
      tmp___1 = long_to_bignum((long )((n ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL)));
#line 632
      tmp___2 = tmp___1;
      }
    } else {
#line 632
      tmp___2 = n;
    }
    {
#line 632
    tmp___3 = bignum_bitwise_and(tmp___2, tmp___0);
#line 632
    tmp___4 = bignum_to_integer(tmp___3);
    }
#line 632
    return (tmp___4);
  }
}
}
#line 633 "/home/khheo/project/mit-scheme-9.2/src/microcode/artutl.c"
SCHEME_OBJECT integer_bitwise_andc2(SCHEME_OBJECT n , SCHEME_OBJECT m ) 
{ 
  bignum_type tmp ;
  bignum_type tmp___0 ;
  bignum_type tmp___1 ;
  bignum_type tmp___2 ;
  bignum_type tmp___3 ;
  SCHEME_OBJECT tmp___4 ;

  {
#line 633
  if (n >> 58U == 26UL) {
#line 633
    if (m >> 58U == 26UL) {
#line 633
      return ((26UL << 58U) | ((unsigned long )((long )((n ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL)) & ~ ((long )((m ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL)))) & 288230376151711743UL));
    } else {
#line 633
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 633
    if (m >> 58U == 26UL) {
      {
#line 633
      tmp = long_to_bignum((long )((m ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL)));
#line 633
      tmp___0 = tmp;
      }
    } else {
#line 633
      tmp___0 = m;
    }
#line 633
    if (n >> 58U == 26UL) {
      {
#line 633
      tmp___1 = long_to_bignum((long )((n ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL)));
#line 633
      tmp___2 = tmp___1;
      }
    } else {
#line 633
      tmp___2 = n;
    }
    {
#line 633
    tmp___3 = bignum_bitwise_andc2(tmp___2, tmp___0);
#line 633
    tmp___4 = bignum_to_integer(tmp___3);
    }
#line 633
    return (tmp___4);
  }
}
}
#line 634 "/home/khheo/project/mit-scheme-9.2/src/microcode/artutl.c"
SCHEME_OBJECT integer_bitwise_andc1(SCHEME_OBJECT n , SCHEME_OBJECT m ) 
{ 
  bignum_type tmp ;
  bignum_type tmp___0 ;
  bignum_type tmp___1 ;
  bignum_type tmp___2 ;
  bignum_type tmp___3 ;
  SCHEME_OBJECT tmp___4 ;

  {
#line 634
  if (n >> 58U == 26UL) {
#line 634
    if (m >> 58U == 26UL) {
#line 634
      return ((26UL << 58U) | ((unsigned long )((long )((m ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL)) & ~ ((long )((n ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL)))) & 288230376151711743UL));
    } else {
#line 634
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 634
    if (m >> 58U == 26UL) {
      {
#line 634
      tmp = long_to_bignum((long )((m ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL)));
#line 634
      tmp___0 = tmp;
      }
    } else {
#line 634
      tmp___0 = m;
    }
#line 634
    if (n >> 58U == 26UL) {
      {
#line 634
      tmp___1 = long_to_bignum((long )((n ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL)));
#line 634
      tmp___2 = tmp___1;
      }
    } else {
#line 634
      tmp___2 = n;
    }
    {
#line 634
    tmp___3 = bignum_bitwise_andc1(tmp___2, tmp___0);
#line 634
    tmp___4 = bignum_to_integer(tmp___3);
    }
#line 634
    return (tmp___4);
  }
}
}
#line 635 "/home/khheo/project/mit-scheme-9.2/src/microcode/artutl.c"
SCHEME_OBJECT integer_bitwise_xor(SCHEME_OBJECT n , SCHEME_OBJECT m ) 
{ 
  bignum_type tmp ;
  bignum_type tmp___0 ;
  bignum_type tmp___1 ;
  bignum_type tmp___2 ;
  bignum_type tmp___3 ;
  SCHEME_OBJECT tmp___4 ;

  {
#line 635
  if (n >> 58U == 26UL) {
#line 635
    if (m >> 58U == 26UL) {
#line 635
      return ((26UL << 58U) | ((unsigned long )((long )((n ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL)) ^ (long )((m ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL))) & 288230376151711743UL));
    } else {
#line 635
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 635
    if (m >> 58U == 26UL) {
      {
#line 635
      tmp = long_to_bignum((long )((m ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL)));
#line 635
      tmp___0 = tmp;
      }
    } else {
#line 635
      tmp___0 = m;
    }
#line 635
    if (n >> 58U == 26UL) {
      {
#line 635
      tmp___1 = long_to_bignum((long )((n ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL)));
#line 635
      tmp___2 = tmp___1;
      }
    } else {
#line 635
      tmp___2 = n;
    }
    {
#line 635
    tmp___3 = bignum_bitwise_xor(tmp___2, tmp___0);
#line 635
    tmp___4 = bignum_to_integer(tmp___3);
    }
#line 635
    return (tmp___4);
  }
}
}
#line 636 "/home/khheo/project/mit-scheme-9.2/src/microcode/artutl.c"
SCHEME_OBJECT integer_bitwise_ior(SCHEME_OBJECT n , SCHEME_OBJECT m ) 
{ 
  bignum_type tmp ;
  bignum_type tmp___0 ;
  bignum_type tmp___1 ;
  bignum_type tmp___2 ;
  bignum_type tmp___3 ;
  SCHEME_OBJECT tmp___4 ;

  {
#line 636
  if (n >> 58U == 26UL) {
#line 636
    if (m >> 58U == 26UL) {
#line 636
      return ((26UL << 58U) | ((unsigned long )((long )((n ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL)) | (long )((m ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL))) & 288230376151711743UL));
    } else {
#line 636
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 636
    if (m >> 58U == 26UL) {
      {
#line 636
      tmp = long_to_bignum((long )((m ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL)));
#line 636
      tmp___0 = tmp;
      }
    } else {
#line 636
      tmp___0 = m;
    }
#line 636
    if (n >> 58U == 26UL) {
      {
#line 636
      tmp___1 = long_to_bignum((long )((n ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL)));
#line 636
      tmp___2 = tmp___1;
      }
    } else {
#line 636
      tmp___2 = n;
    }
    {
#line 636
    tmp___3 = bignum_bitwise_ior(tmp___2, tmp___0);
#line 636
    tmp___4 = bignum_to_integer(tmp___3);
    }
#line 636
    return (tmp___4);
  }
}
}
#line 637 "/home/khheo/project/mit-scheme-9.2/src/microcode/artutl.c"
SCHEME_OBJECT integer_bitwise_nor(SCHEME_OBJECT n , SCHEME_OBJECT m ) 
{ 
  bignum_type tmp ;
  bignum_type tmp___0 ;
  bignum_type tmp___1 ;
  bignum_type tmp___2 ;
  bignum_type tmp___3 ;
  SCHEME_OBJECT tmp___4 ;

  {
#line 637
  if (n >> 58U == 26UL) {
#line 637
    if (m >> 58U == 26UL) {
#line 637
      return ((26UL << 58U) | ((unsigned long )(~ ((long )((n ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL)) | (long )((m ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL)))) & 288230376151711743UL));
    } else {
#line 637
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 637
    if (m >> 58U == 26UL) {
      {
#line 637
      tmp = long_to_bignum((long )((m ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL)));
#line 637
      tmp___0 = tmp;
      }
    } else {
#line 637
      tmp___0 = m;
    }
#line 637
    if (n >> 58U == 26UL) {
      {
#line 637
      tmp___1 = long_to_bignum((long )((n ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL)));
#line 637
      tmp___2 = tmp___1;
      }
    } else {
#line 637
      tmp___2 = n;
    }
    {
#line 637
    tmp___3 = bignum_bitwise_nor(tmp___2, tmp___0);
#line 637
    tmp___4 = bignum_to_integer(tmp___3);
    }
#line 637
    return (tmp___4);
  }
}
}
#line 638 "/home/khheo/project/mit-scheme-9.2/src/microcode/artutl.c"
SCHEME_OBJECT integer_bitwise_eqv(SCHEME_OBJECT n , SCHEME_OBJECT m ) 
{ 
  bignum_type tmp ;
  bignum_type tmp___0 ;
  bignum_type tmp___1 ;
  bignum_type tmp___2 ;
  bignum_type tmp___3 ;
  SCHEME_OBJECT tmp___4 ;

  {
#line 638
  if (n >> 58U == 26UL) {
#line 638
    if (m >> 58U == 26UL) {
#line 638
      return ((26UL << 58U) | ((unsigned long )(~ ((long )((n ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL)) ^ (long )((m ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL)))) & 288230376151711743UL));
    } else {
#line 638
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 638
    if (m >> 58U == 26UL) {
      {
#line 638
      tmp = long_to_bignum((long )((m ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL)));
#line 638
      tmp___0 = tmp;
      }
    } else {
#line 638
      tmp___0 = m;
    }
#line 638
    if (n >> 58U == 26UL) {
      {
#line 638
      tmp___1 = long_to_bignum((long )((n ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL)));
#line 638
      tmp___2 = tmp___1;
      }
    } else {
#line 638
      tmp___2 = n;
    }
    {
#line 638
    tmp___3 = bignum_bitwise_eqv(tmp___2, tmp___0);
#line 638
    tmp___4 = bignum_to_integer(tmp___3);
    }
#line 638
    return (tmp___4);
  }
}
}
#line 639 "/home/khheo/project/mit-scheme-9.2/src/microcode/artutl.c"
SCHEME_OBJECT integer_bitwise_orc2(SCHEME_OBJECT n , SCHEME_OBJECT m ) 
{ 
  bignum_type tmp ;
  bignum_type tmp___0 ;
  bignum_type tmp___1 ;
  bignum_type tmp___2 ;
  bignum_type tmp___3 ;
  SCHEME_OBJECT tmp___4 ;

  {
#line 639
  if (n >> 58U == 26UL) {
#line 639
    if (m >> 58U == 26UL) {
#line 639
      return ((26UL << 58U) | ((unsigned long )((long )((n ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL)) | ~ ((long )((m ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL)))) & 288230376151711743UL));
    } else {
#line 639
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 639
    if (m >> 58U == 26UL) {
      {
#line 639
      tmp = long_to_bignum((long )((m ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL)));
#line 639
      tmp___0 = tmp;
      }
    } else {
#line 639
      tmp___0 = m;
    }
#line 639
    if (n >> 58U == 26UL) {
      {
#line 639
      tmp___1 = long_to_bignum((long )((n ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL)));
#line 639
      tmp___2 = tmp___1;
      }
    } else {
#line 639
      tmp___2 = n;
    }
    {
#line 639
    tmp___3 = bignum_bitwise_orc2(tmp___2, tmp___0);
#line 639
    tmp___4 = bignum_to_integer(tmp___3);
    }
#line 639
    return (tmp___4);
  }
}
}
#line 640 "/home/khheo/project/mit-scheme-9.2/src/microcode/artutl.c"
SCHEME_OBJECT integer_bitwise_orc1(SCHEME_OBJECT n , SCHEME_OBJECT m ) 
{ 
  bignum_type tmp ;
  bignum_type tmp___0 ;
  bignum_type tmp___1 ;
  bignum_type tmp___2 ;
  bignum_type tmp___3 ;
  SCHEME_OBJECT tmp___4 ;

  {
#line 640
  if (n >> 58U == 26UL) {
#line 640
    if (m >> 58U == 26UL) {
#line 640
      return ((26UL << 58U) | ((unsigned long )((long )((m ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL)) | ~ ((long )((n ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL)))) & 288230376151711743UL));
    } else {
#line 640
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 640
    if (m >> 58U == 26UL) {
      {
#line 640
      tmp = long_to_bignum((long )((m ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL)));
#line 640
      tmp___0 = tmp;
      }
    } else {
#line 640
      tmp___0 = m;
    }
#line 640
    if (n >> 58U == 26UL) {
      {
#line 640
      tmp___1 = long_to_bignum((long )((n ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL)));
#line 640
      tmp___2 = tmp___1;
      }
    } else {
#line 640
      tmp___2 = n;
    }
    {
#line 640
    tmp___3 = bignum_bitwise_orc1(tmp___2, tmp___0);
#line 640
    tmp___4 = bignum_to_integer(tmp___3);
    }
#line 640
    return (tmp___4);
  }
}
}
#line 641 "/home/khheo/project/mit-scheme-9.2/src/microcode/artutl.c"
SCHEME_OBJECT integer_bitwise_nand(SCHEME_OBJECT n , SCHEME_OBJECT m ) 
{ 
  bignum_type tmp ;
  bignum_type tmp___0 ;
  bignum_type tmp___1 ;
  bignum_type tmp___2 ;
  bignum_type tmp___3 ;
  SCHEME_OBJECT tmp___4 ;

  {
#line 641
  if (n >> 58U == 26UL) {
#line 641
    if (m >> 58U == 26UL) {
#line 641
      return ((26UL << 58U) | ((unsigned long )(~ ((long )((n ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL)) & (long )((m ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL)))) & 288230376151711743UL));
    } else {
#line 641
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 641
    if (m >> 58U == 26UL) {
      {
#line 641
      tmp = long_to_bignum((long )((m ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL)));
#line 641
      tmp___0 = tmp;
      }
    } else {
#line 641
      tmp___0 = m;
    }
#line 641
    if (n >> 58U == 26UL) {
      {
#line 641
      tmp___1 = long_to_bignum((long )((n ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL)));
#line 641
      tmp___2 = tmp___1;
      }
    } else {
#line 641
      tmp___2 = n;
    }
    {
#line 641
    tmp___3 = bignum_bitwise_nand(tmp___2, tmp___0);
#line 641
    tmp___4 = bignum_to_integer(tmp___3);
    }
#line 641
    return (tmp___4);
  }
}
}
#line 643 "/home/khheo/project/mit-scheme-9.2/src/microcode/artutl.c"
SCHEME_OBJECT integer_nonnegative_one_bits(unsigned long n , unsigned long m ) 
{ 
  bignum_type tmp ;

  {
#line 646
  if (n == 0UL) {
#line 647
    return (26UL << 58U);
  } else
#line 648
  if (n + m <= 57UL) {
#line 649
    return ((26UL << 58U) | (~ (0xffffffffffffffffUL << n) << m));
  } else {
    {
#line 651
    tmp = bignum_nonnegative_one_bits(n, m);
    }
#line 651
    return (tmp);
  }
}
}
#line 654 "/home/khheo/project/mit-scheme-9.2/src/microcode/artutl.c"
SCHEME_OBJECT integer_negative_zero_bits(unsigned long n , unsigned long m ) 
{ 
  bignum_type tmp ;

  {
#line 657
  if (n == 0UL) {
#line 658
    return ((26UL << 58U) | 288230376151711743UL);
  } else
#line 659
  if (n + m <= 57UL) {
#line 660
    return ((26UL << 58U) | ((unsigned long )(~ ((long )(~ (0xffffffffffffffffUL << n) << m))) & 288230376151711743UL));
  } else {
    {
#line 663
    tmp = bignum_negative_zero_bits(n, m);
    }
#line 663
    return (tmp);
  }
}
}
#line 668 "/home/khheo/project/mit-scheme-9.2/src/microcode/artutl.c"
SCHEME_OBJECT integer_shift_left(SCHEME_OBJECT n , unsigned long m ) 
{ 
  long n1 ;
  bignum_type tmp ;
  bignum_type tmp___0 ;
  unsigned int tmp___1 ;
  bignum_type tmp___2 ;
  unsigned int tmp___3 ;
  bignum_type tmp___4 ;

  {
#line 671
  if (m == 0UL) {
#line 672
    return (n);
  }
#line 673
  if (n >> 58U == 26UL) {
#line 675
    n1 = (long )((n ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL));
#line 676
    if (n1 < 0L) {
      {
#line 678
      tmp___1 = ulong_length_in_bits((unsigned long )(~ n1));
      }
#line 678
      if (m + (unsigned long )tmp___1 <= 57UL) {
#line 681
        return ((26UL << 58U) | ((unsigned long )(- (- n1 << m)) & 288230376151711743UL));
      } else {
        {
#line 683
        tmp = unsigned_long_to_shifted_bignum((unsigned long )(- n1), m, 0);
#line 683
        tmp___0 = bignum_negate(tmp);
        }
#line 683
        return (tmp___0);
      }
    } else
#line 686
    if (0L < n1) {
      {
#line 688
      tmp___3 = ulong_length_in_bits((unsigned long )n1);
      }
#line 688
      if (m + (unsigned long )tmp___3 <= 57UL) {
#line 689
        return ((26UL << 58U) | ((unsigned long )(n1 << m) & 288230376151711743UL));
      } else {
        {
#line 691
        tmp___2 = unsigned_long_to_shifted_bignum((unsigned long )n1, m, 0);
        }
#line 691
        return (tmp___2);
      }
    } else {
#line 694
      return (26UL << 58U);
    }
  } else {
    {
#line 697
    tmp___4 = bignum_shift_left(n, m);
    }
#line 697
    return (tmp___4);
  }
}
}
#line 700 "/home/khheo/project/mit-scheme-9.2/src/microcode/artutl.c"
SCHEME_OBJECT integer_shift_right(SCHEME_OBJECT n , unsigned long m ) 
{ 
  long n1 ;
  long tmp ;
  bignum_type tmp___0 ;
  SCHEME_OBJECT tmp___1 ;

  {
#line 703
  if (m == 0UL) {
#line 704
    return (n);
  }
#line 705
  if (n >> 58U == 26UL) {
#line 707
    n1 = (long )((n ^ 144115188075855872UL) - ((26UL << 58U) | 144115188075855872UL));
#line 708
    if (n1 < 0L) {
#line 708
      tmp = ~ (~ n1 >> m);
    } else {
#line 708
      tmp = n1 >> m;
    }
#line 708
    return ((26UL << 58U) | ((unsigned long )tmp & 288230376151711743UL));
  } else {
    {
#line 711
    tmp___0 = bignum_shift_right(n, m);
#line 711
    tmp___1 = bignum_to_integer(tmp___0);
    }
#line 711
    return (tmp___1);
  }
}
}
