/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 35 "../include/aal/types.h"
typedef long long int64_t;
#line 42 "../include/aal/types.h"
typedef unsigned int uint32_t;
#line 44 "../include/aal/types.h"
typedef unsigned long long uint64_t;
#line 97 "../include/aal/types.h"
typedef int bool_t;
#line 100 "../include/aal/types.h"
typedef int64_t errno_t;
#line 169 "../include/aal/types.h"
typedef uint64_t blk_t;
#line 170 "../include/aal/types.h"
typedef uint64_t count_t;
#line 173
struct aal_device_ops;
#line 179 "../include/aal/types.h"
struct aal_device {
   int flags ;
   void *data ;
   void *entity ;
   void *person ;
   char name[256] ;
   char error[256] ;
   uint32_t blksize ;
   struct aal_device_ops *ops ;
};
#line 192 "../include/aal/types.h"
typedef struct aal_device aal_device_t;
#line 196 "../include/aal/types.h"
struct aal_device_ops {
   errno_t (*open)(aal_device_t * , void * , uint32_t  , int  ) ;
   errno_t (*read)(aal_device_t * , void * , blk_t  , count_t  ) ;
   errno_t (*write)(aal_device_t * , void * , blk_t  , count_t  ) ;
   errno_t (*sync)(aal_device_t * ) ;
   errno_t (*equals)(aal_device_t * , aal_device_t * ) ;
   count_t (*len)(aal_device_t * ) ;
   void (*close)(aal_device_t * ) ;
};
#line 230
enum aal_exception_type {
    EXCEPTION_TYPE_INFO = 1,
    EXCEPTION_TYPE_MESSAGE = 2,
    EXCEPTION_TYPE_WARNING = 3,
    EXCEPTION_TYPE_ERROR = 4,
    EXCEPTION_TYPE_FATAL = 5,
    EXCEPTION_TYPE_BUG = 6,
    EXCEPTION_TYPE_LAST = 7
} ;
#line 240 "../include/aal/types.h"
typedef enum aal_exception_type aal_exception_type_t;
#line 242
enum aal_exception_option {
    EXCEPTION_OPT_UNHANDLED = 1,
    EXCEPTION_OPT_YES = 2,
    EXCEPTION_OPT_NO = 4,
    EXCEPTION_OPT_OK = 8,
    EXCEPTION_OPT_RETRY = 16,
    EXCEPTION_OPT_IGNORE = 32,
    EXCEPTION_OPT_CANCEL = 64,
    EXCEPTION_OPT_LAST = 128
} ;
#line 253 "../include/aal/types.h"
typedef enum aal_exception_option aal_exception_option_t;
#line 114
struct aal_hash_node;
#line 114 "../include/aal/types.h"
typedef struct aal_hash_node aal_hash_node_t;
#line 116 "../include/aal/types.h"
struct aal_hash_node {
   void *key ;
   void *value ;
   aal_hash_node_t *next ;
};
#line 134 "../include/aal/types.h"
struct aal_hash_table {
   uint32_t size ;
   uint32_t real ;
   uint64_t (*hash_func)(void * ) ;
   int (*comp_func)(void * , void * , void * ) ;
   void (*keyrem_func)(void * ) ;
   void (*valrem_func)(void * ) ;
   aal_hash_node_t **nodes ;
};
#line 146 "../include/aal/types.h"
typedef struct aal_hash_table aal_hash_table_t;
#line 219 "../include/aal/types.h"
struct aal_block {
   blk_t nr ;
   int dirty ;
   void *data ;
   uint32_t size ;
   aal_device_t *device ;
};
#line 227 "../include/aal/types.h"
typedef struct aal_block aal_block_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 98 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 14 "../include/aal/ui.h"
typedef int64_t (*aal_numeric_func_t)(char const   * , int64_t  , int (*)(int64_t  ,
                                                                          void * ) ,
                                      void * );
#line 19 "../include/aal/ui.h"
typedef void (*aal_alpha_func_t)(char const   * , char * , int (*)(char * , void * ) ,
                                 void * );
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 272 "../include/aal/types.h"
struct aal_exception {
   char *message ;
   aal_exception_type_t type ;
   aal_exception_option_t options ;
};
#line 278 "../include/aal/types.h"
typedef struct aal_exception aal_exception_t;
#line 280 "../include/aal/types.h"
typedef aal_exception_option_t (*aal_exception_handler_t)(aal_exception_t *ex );
#line 283
struct aal_gauge;
#line 283 "../include/aal/types.h"
typedef struct aal_gauge aal_gauge_t;
#line 285
enum aal_gauge_state {
    GS_START = 0,
    GS_ACTIVE = 1,
    GS_PAUSE = 2,
    GS_RESUME = 3,
    GS_DONE = 4,
    GS_LAST = 5
} ;
#line 294 "../include/aal/types.h"
typedef enum aal_gauge_state aal_gauge_state_t;
#line 298 "../include/aal/types.h"
struct aal_gauge_time {
   uint64_t sec ;
   uint64_t misec ;
   uint64_t gap ;
};
#line 305 "../include/aal/types.h"
typedef struct aal_gauge_time aal_gauge_time_t;
#line 307 "../include/aal/types.h"
struct aal_gauge {
   void (*handler)(aal_gauge_t * ) ;
   aal_gauge_state_t state ;
   char label[80] ;
   void (*value_func)(aal_gauge_t * ) ;
   aal_gauge_time_t time ;
   int64_t value ;
   void *data ;
};
#line 33 "../include/aal/types.h"
typedef int int32_t;
#line 102
struct aal_list;
#line 102 "../include/aal/types.h"
typedef struct aal_list aal_list_t;
#line 107 "../include/aal/types.h"
struct aal_list {
   void *data ;
   aal_list_t *next ;
   aal_list_t *prev ;
};
#line 10 "../include/aal/bitops.h"
typedef unsigned long long bit_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 49 "/usr/include/fcntl.h"
typedef __off64_t off_t;
#line 220 "/usr/include/unistd.h"
typedef __ssize_t ssize_t;
#line 19 "../include/aal/malloc.h"
typedef void (*aal_free_handler_t)(void * );
#line 20 "../include/aal/malloc.h"
typedef void *(*aal_malloc_handler_t)(uint32_t  );
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 320 "../include/aal/types.h"
struct aal_stream;
#line 320 "../include/aal/types.h"
typedef struct aal_stream aal_stream_t;
#line 325 "../include/aal/types.h"
struct aal_proto {
   int (*eof)(aal_stream_t * ) ;
   void (*fini)(aal_stream_t * ) ;
   int32_t (*read)(aal_stream_t * , void * , uint32_t  ) ;
   int32_t (*write)(aal_stream_t * , void * , uint32_t  ) ;
};
#line 332 "../include/aal/types.h"
typedef struct aal_proto aal_proto_t;
#line 335 "../include/aal/types.h"
struct aal_stream {
   void *entity ;
   uint32_t size ;
   uint32_t offset ;
   aal_proto_t *proto ;
};
#line 54 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/malloc.c"
struct chunk;
#line 54 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/malloc.c"
typedef struct chunk chunk_t;
#line 55
enum chunk_state;
#line 55 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/malloc.c"
typedef enum chunk_state chunk_state_t;
#line 57
enum chunk_state {
    ST_FREE = 1,
    ST_USED = 2
} ;
#line 62 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/malloc.c"
struct chunk {
   uint32_t len ;
   chunk_t *next ;
   chunk_t *prev ;
   chunk_state_t state ;
} __attribute__((__packed__)) ;
#line 11 "../include/aal/device.h"
aal_device_t *aal_device_open(struct aal_device_ops *ops , void *person , uint32_t blksize ,
                              int flags ) ;
#line 17
errno_t aal_device_sync(aal_device_t *device ) ;
#line 19
bool_t aal_device_readonly(aal_device_t *device ) ;
#line 21
errno_t aal_device_reopen(aal_device_t *device , uint32_t blksize , int flags ) ;
#line 25
errno_t aal_device_write(aal_device_t *device , void *buff , blk_t block , count_t count ) ;
#line 29
bool_t aal_device_equals(aal_device_t *device1 , aal_device_t *device2 ) ;
#line 33
errno_t aal_device_read(aal_device_t *device , void *buff , blk_t block , count_t count ) ;
#line 37
void aal_device_close(aal_device_t *device ) ;
#line 39
errno_t aal_device_set_bs(aal_device_t *device , uint32_t blksize ) ;
#line 42
count_t aal_device_len(aal_device_t *device ) ;
#line 43
uint32_t aal_device_get_bs(aal_device_t *device ) ;
#line 25 "../include/aal/exception.h"
aal_exception_option_t ( /* format attribute */  aal_exception_throw)(aal_exception_type_t type ,
                                                                      aal_exception_option_t opts ,
                                                                      char const   *message 
                                                                      , ...) ;
#line 30 "../include/aal/malloc.h"
void aal_free(void *ptr ) ;
#line 32
void *aal_calloc(uint32_t size , char c ) ;
#line 12 "../include/aal/math.h"
int aal_pow2(uint32_t n ) ;
#line 39 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/device.c"
aal_device_t *aal_device_open(struct aal_device_ops *ops , void *person , uint32_t blksize ,
                              int flags ) 
{ 
  aal_device_t *device ;
  int tmp ;
  void *tmp___0 ;
  errno_t tmp___1 ;

  {
  {
#line 51
  tmp = aal_pow2(blksize);
  }
#line 51
  if (! tmp) {
    {
#line 52
    aal_exception_throw((aal_exception_type_t )4, (aal_exception_option_t )8, "Block size %u isn\'t power of two.",
                        blksize);
    }
#line 53
    return ((aal_device_t *)((void *)0));
  }
#line 56
  if (blksize < 512U) {
    {
#line 57
    aal_exception_throw((aal_exception_type_t )4, (aal_exception_option_t )8, "Block size can\'t be less than 512 bytes.");
    }
#line 58
    return ((aal_device_t *)((void *)0));
  }
  {
#line 63
  tmp___0 = aal_calloc((uint32_t )sizeof(*device), (char)0);
#line 63
  device = (aal_device_t *)tmp___0;
  }
#line 63
  if (! device) {
#line 64
    return ((aal_device_t *)((void *)0));
  }
#line 66
  device->ops = ops;
#line 67
  device->flags = flags;
#line 68
  device->person = person;
#line 69
  device->blksize = blksize;
#line 71
  if (ops->open) {
    {
#line 72
    tmp___1 = (*(ops->open))(device, person, blksize, flags);
    }
#line 72
    if (tmp___1) {
#line 73
      goto error_free_device;
    }
  }
#line 76
  return (device);
  error_free_device: 
  {
#line 79
  aal_free((void *)device);
  }
#line 80
  return ((aal_device_t *)((void *)0));
}
}
#line 84 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/device.c"
errno_t aal_device_reopen(aal_device_t *device , uint32_t blksize , int flags ) 
{ 
  errno_t tmp ;

  {
  {
#line 89
  device->flags = flags;
#line 90
  device->blksize = blksize;
#line 92
  tmp = (*((device->ops)->open))(device, device->person, blksize, flags);
  }
#line 92
  return (tmp);
}
}
#line 96 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/device.c"
bool_t aal_device_readonly(aal_device_t *device ) 
{ 


  {
#line 98
  return ((device->flags & 7) == 0);
}
}
#line 104 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/device.c"
errno_t aal_device_write(aal_device_t *device , void *buff , blk_t block , count_t count ) 
{ 
  errno_t tmp ;

  {
  {
#line 113
  while (1) {
    while_continue: /* CIL Label */ ;
#line 113
    if (! (device->ops)->write) {
      {
#line 113
      aal_exception_throw((aal_exception_type_t )5, (aal_exception_option_t )8, "Device operation \"write\" isn\'t implemented.");
      }
#line 113
      return ((errno_t )-22);
    }
#line 113
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 114
  tmp = (*((device->ops)->write))(device, buff, block, count);
  }
#line 114
  return (tmp);
}
}
#line 120 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/device.c"
errno_t aal_device_sync(aal_device_t *device ) 
{ 
  errno_t tmp ;

  {
  {
#line 125
  while (1) {
    while_continue: /* CIL Label */ ;
#line 125
    if (! (device->ops)->sync) {
      {
#line 125
      aal_exception_throw((aal_exception_type_t )5, (aal_exception_option_t )8, "Device operation \"sync\" isn\'t implemented.");
      }
#line 125
      return ((errno_t )-22);
    }
#line 125
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 126
  tmp = (*((device->ops)->sync))(device);
  }
#line 126
  return (tmp);
}
}
#line 132 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/device.c"
bool_t aal_device_equals(aal_device_t *device1 , aal_device_t *device2 ) 
{ 
  errno_t tmp ;

  {
  {
#line 139
  while (1) {
    while_continue: /* CIL Label */ ;
#line 139
    if (! (device1->ops)->equals) {
      {
#line 139
      aal_exception_throw((aal_exception_type_t )5, (aal_exception_option_t )8, "Device operation \"equals\" isn\'t implemented.");
      }
#line 139
      return (0);
    }
#line 139
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 140
  tmp = (*((device1->ops)->equals))(device1, device2);
  }
#line 140
  return ((bool_t )tmp);
}
}
#line 146 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/device.c"
errno_t aal_device_set_bs(aal_device_t *device , uint32_t blksize ) 
{ 
  int tmp ;

  {
  {
#line 153
  tmp = aal_pow2(blksize);
  }
#line 153
  if (! tmp) {
    {
#line 154
    aal_exception_throw((aal_exception_type_t )4, (aal_exception_option_t )8, "Block size %u isn\'t power of two.",
                        blksize);
    }
#line 155
    return ((errno_t )-22);
  }
#line 158
  if (blksize < 512U) {
    {
#line 159
    aal_exception_throw((aal_exception_type_t )4, (aal_exception_option_t )8, "Block size can\'t be less than 512 bytes.");
    }
#line 160
    return ((errno_t )-22);
  }
#line 164
  device->blksize = blksize;
#line 165
  return ((errno_t )0);
}
}
#line 169 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/device.c"
void aal_device_close(aal_device_t *device ) 
{ 


  {
#line 174
  if ((device->ops)->close) {
    {
#line 175
    (*((device->ops)->close))(device);
    }
  }
  {
#line 177
  aal_free((void *)device);
  }
#line 178
  return;
}
}
#line 181 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/device.c"
uint32_t aal_device_get_bs(aal_device_t *device ) 
{ 


  {
#line 185
  return (device->blksize);
}
}
#line 191 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/device.c"
errno_t aal_device_read(aal_device_t *device , void *buff , blk_t block , count_t count ) 
{ 
  errno_t tmp ;

  {
  {
#line 199
  while (1) {
    while_continue: /* CIL Label */ ;
#line 199
    if (! (device->ops)->read) {
      {
#line 199
      aal_exception_throw((aal_exception_type_t )5, (aal_exception_option_t )8, "Device operation \"read\" isn\'t implemented.");
      }
#line 199
      return ((errno_t )-22);
    }
#line 199
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 200
  tmp = (*((device->ops)->read))(device, buff, block, count);
  }
#line 200
  return (tmp);
}
}
#line 204 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/device.c"
count_t aal_device_len(aal_device_t *device ) 
{ 
  count_t tmp ;

  {
  {
#line 209
  while (1) {
    while_continue: /* CIL Label */ ;
#line 209
    if (! (device->ops)->len) {
      {
#line 209
      aal_exception_throw((aal_exception_type_t )5, (aal_exception_option_t )8, "Device operation \"len\" isn\'t implemented.");
      }
#line 209
      return ((uint64_t )(~ 0));
    }
#line 209
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 212
  tmp = (*((device->ops)->len))(device);
  }
#line 212
  return (tmp);
}
}
#line 11 "../include/aal/hash.h"
void aal_hash_table_free(aal_hash_table_t *table ) ;
#line 13
void *aal_hash_table_lookup(aal_hash_table_t *table , void *key ) ;
#line 16
errno_t aal_hash_table_remove(aal_hash_table_t *table , void *key ) ;
#line 19
errno_t aal_hash_table_insert(aal_hash_table_t *table , void *key , void *value ) ;
#line 22
errno_t aal_hash_table_foreach(aal_hash_table_t *table , errno_t (*foreach_func)(void * ,
                                                                                 void * ) ,
                               void *data ) ;
#line 26
aal_hash_table_t *aal_hash_table_create(uint32_t size , uint64_t (*hash_func)(void * ) ,
                                        int (*comp_func)(void * , void * , void * ) ,
                                        void (*keyrem_func)(void * ) , void (*valrem_func)(void * ) ) ;
#line 32
aal_hash_node_t **aal_hash_table_lookup_node(aal_hash_table_t *table , void *key ) ;
#line 9 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/hash.c"
static aal_hash_node_t *aal_hash_node_alloc(void *key , void *value ) 
{ 
  aal_hash_node_t *node ;
  void *tmp ;

  {
  {
#line 12
  tmp = aal_calloc((uint32_t )sizeof(*node), (char)0);
#line 12
  node = (aal_hash_node_t *)tmp;
  }
#line 12
  if (! node) {
#line 13
    return ((aal_hash_node_t *)((void *)0));
  }
#line 15
  node->key = key;
#line 16
  node->value = value;
#line 18
  return (node);
}
}
#line 22 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/hash.c"
static void aal_hash_node_free(aal_hash_table_t *table , aal_hash_node_t *node ) 
{ 


  {
#line 25
  if (table->keyrem_func) {
    {
#line 26
    (*(table->keyrem_func))(node->key);
    }
  }
#line 28
  if (table->valrem_func) {
    {
#line 29
    (*(table->valrem_func))(node->value);
    }
  }
  {
#line 31
  aal_free((void *)node);
  }
#line 32
  return;
}
}
#line 36 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/hash.c"
aal_hash_table_t *aal_hash_table_create(uint32_t size , uint64_t (*hash_func)(void * ) ,
                                        int (*comp_func)(void * , void * , void * ) ,
                                        void (*keyrem_func)(void * ) , void (*valrem_func)(void * ) ) 
{ 
  aal_hash_table_t *table ;
  void *tmp ;
  aal_hash_node_t **tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 47
  tmp = aal_calloc((uint32_t )sizeof(*table), (char)0);
#line 47
  table = (aal_hash_table_t *)tmp;
  }
#line 47
  if (! table) {
#line 48
    return ((aal_hash_table_t *)((void *)0));
  }
  {
#line 50
  table->real = (uint32_t )0;
#line 51
  table->size = size;
#line 53
  table->hash_func = hash_func;
#line 54
  table->comp_func = comp_func;
#line 56
  table->keyrem_func = keyrem_func;
#line 57
  table->valrem_func = valrem_func;
#line 59
  size = (uint32_t )((unsigned long )table->size * sizeof(void *));
#line 61
  tmp___1 = aal_calloc(size, (char)0);
#line 61
  tmp___0 = (aal_hash_node_t **)tmp___1;
#line 61
  table->nodes = tmp___0;
  }
#line 61
  if (! tmp___0) {
#line 62
    goto error_free_table;
  }
#line 64
  return (table);
  error_free_table: 
  {
#line 67
  aal_free((void *)table);
  }
#line 68
  return ((aal_hash_table_t *)((void *)0));
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/hash.c"
void aal_hash_table_free(aal_hash_table_t *table ) 
{ 
  uint32_t i ;
  aal_hash_node_t *node ;
  aal_hash_node_t *next ;

  {
#line 79
  i = (uint32_t )0;
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
#line 79
    if (! (i < table->size)) {
#line 79
      goto while_break;
    }
#line 80
    node = *(table->nodes + i);
    {
#line 80
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 80
      if (! ((unsigned long )node != (unsigned long )((void *)0))) {
#line 80
        goto while_break___0;
      }
      {
#line 83
      next = node->next;
#line 84
      aal_hash_node_free(table, node);
#line 80
      node = next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 79
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 88
  aal_free((void *)table->nodes);
#line 89
  aal_free((void *)table);
  }
#line 90
  return;
}
}
#line 93 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/hash.c"
aal_hash_node_t **aal_hash_table_lookup_node(aal_hash_table_t *table , void *key ) 
{ 
  uint64_t hash ;
  aal_hash_node_t **node ;
  int tmp ;

  {
  {
#line 103
  hash = (*(table->hash_func))(key);
#line 104
  node = table->nodes + (hash & (unsigned long long )(table->size - 1U));
  }
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
#line 106
    if (*node) {
      {
#line 106
      tmp = (*(table->comp_func))((*node)->key, key, (void *)0);
      }
#line 106
      if (! tmp) {
#line 106
        goto while_break;
      }
    } else {
#line 106
      goto while_break;
    }
#line 107
    node = & (*node)->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 109
  return (node);
}
}
#line 113 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/hash.c"
void *aal_hash_table_lookup(aal_hash_table_t *table , void *key ) 
{ 
  aal_hash_node_t *node ;
  aal_hash_node_t **tmp ;
  void *tmp___0 ;

  {
  {
#line 118
  tmp = aal_hash_table_lookup_node(table, key);
#line 118
  node = *tmp;
  }
#line 119
  if (node) {
#line 119
    tmp___0 = node->value;
  } else {
#line 119
    tmp___0 = (void *)0;
  }
#line 119
  return (tmp___0);
}
}
#line 123 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/hash.c"
errno_t aal_hash_table_insert(aal_hash_table_t *table , void *key , void *value ) 
{ 
  aal_hash_node_t **node ;
  aal_hash_node_t *tmp ;

  {
  {
#line 128
  node = aal_hash_table_lookup_node(table, key);
  }
#line 130
  if (*node) {
#line 131
    (*node)->value = value;
  } else {
    {
#line 133
    tmp = aal_hash_node_alloc(key, value);
#line 133
    *node = tmp;
    }
#line 133
    if (! tmp) {
#line 134
      return ((errno_t )-12);
    }
#line 136
    (table->real) ++;
  }
#line 139
  return ((errno_t )0);
}
}
#line 143 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/hash.c"
errno_t aal_hash_table_remove(aal_hash_table_t *table , void *key ) 
{ 
  aal_hash_node_t *dest ;
  aal_hash_node_t **node ;

  {
  {
#line 149
  node = aal_hash_table_lookup_node(table, key);
  }
#line 151
  if (*node) {
    {
#line 152
    dest = *node;
#line 153
    *node = dest->next;
#line 154
    aal_hash_node_free(table, dest);
#line 155
    (table->real) --;
    }
#line 157
    return ((errno_t )0);
  }
#line 160
  return ((errno_t )-22);
}
}
#line 166 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/hash.c"
errno_t aal_hash_table_foreach(aal_hash_table_t *table , errno_t (*foreach_func)(void * ,
                                                                                 void * ) ,
                               void *data ) 
{ 
  uint32_t i ;
  errno_t res ;
  aal_hash_node_t *node ;
  aal_hash_node_t *next ;

  {
#line 173
  i = (uint32_t )0;
  {
#line 173
  while (1) {
    while_continue: /* CIL Label */ ;
#line 173
    if (! (i < table->size)) {
#line 173
      goto while_break;
    }
#line 177
    node = *(table->nodes + i);
    {
#line 177
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 177
      if (! ((unsigned long )node != (unsigned long )((void *)0))) {
#line 177
        goto while_break___0;
      }
      {
#line 180
      next = node->next;
#line 182
      res = (*foreach_func)((void *)node, data);
      }
#line 182
      if (res) {
#line 183
        return (res);
      }
#line 177
      node = next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 173
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 187
  return ((errno_t )0);
}
}
#line 31 "../include/aal/malloc.h"
void *aal_malloc(uint32_t size ) ;
#line 14 "../include/aal/string.h"
void *aal_memset(void *dest , int c , uint32_t n ) ;
#line 12 "../include/aal/block.h"
void aal_block_move(aal_block_t *block , aal_device_t *device , blk_t nr ) ;
#line 16
errno_t aal_block_write(aal_block_t *block ) ;
#line 19
void aal_block_free(aal_block_t *block ) ;
#line 20
void aal_block_fini(aal_block_t *block ) ;
#line 21
errno_t aal_block_read(aal_block_t *block ) ;
#line 23
errno_t aal_block_fill(aal_block_t *block , unsigned char c ) ;
#line 26
errno_t aal_block_init(aal_block_t *block , aal_device_t *device , uint32_t size ,
                       blk_t nr ) ;
#line 30
aal_block_t *aal_block_alloc(aal_device_t *device , uint32_t size , blk_t nr ) ;
#line 33
aal_block_t *aal_block_load(aal_device_t *device , uint32_t size , blk_t nr ) ;
#line 8 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/block.c"
errno_t aal_block_init(aal_block_t *block , aal_device_t *device , uint32_t size ,
                       blk_t nr ) 
{ 
  void *tmp ;

  {
  {
#line 15
  block->nr = nr;
#line 16
  block->dirty = 0;
#line 17
  block->size = size;
#line 18
  block->device = device;
#line 20
  tmp = aal_malloc(size);
#line 20
  block->data = tmp;
  }
#line 20
  if (! tmp) {
#line 21
    return ((errno_t )-12);
  }
#line 23
  return ((errno_t )0);
}
}
#line 26 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/block.c"
void aal_block_fini(aal_block_t *block ) 
{ 


  {
  {
#line 27
  aal_free(block->data);
#line 28
  block->data = (void *)0;
  }
#line 29
  return;
}
}
#line 35 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/block.c"
aal_block_t *aal_block_alloc(aal_device_t *device , uint32_t size , blk_t nr ) 
{ 
  aal_block_t *block ;
  void *tmp ;
  errno_t tmp___0 ;

  {
  {
#line 44
  tmp = aal_calloc((uint32_t )sizeof(*block), (char)0);
#line 44
  block = (aal_block_t *)tmp;
  }
#line 44
  if (! block) {
#line 45
    return ((aal_block_t *)((void *)0));
  }
  {
#line 47
  tmp___0 = aal_block_init(block, device, size, nr);
  }
#line 47
  if (tmp___0) {
#line 48
    goto error_free_block;
  }
#line 50
  return (block);
  error_free_block: 
  {
#line 53
  aal_free((void *)block);
  }
#line 54
  return ((aal_block_t *)((void *)0));
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/block.c"
void aal_block_free(aal_block_t *block ) 
{ 


  {
  {
#line 63
  aal_block_fini(block);
#line 64
  aal_free((void *)block);
  }
#line 65
  return;
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/block.c"
errno_t aal_block_fill(aal_block_t *block , unsigned char c ) 
{ 
  void *tmp ;

  {
  {
#line 70
  tmp = aal_memset(block->data, (int )c, block->size);
  }
#line 70
  if (! tmp) {
#line 71
    return ((errno_t )-22);
  }
#line 73
  block->dirty = 1;
#line 74
  return ((errno_t )0);
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/block.c"
errno_t aal_block_read(aal_block_t *block ) 
{ 
  uint32_t count ;
  errno_t tmp ;

  {
  {
#line 82
  block->dirty = 0;
#line 83
  count = block->size / (block->device)->blksize;
#line 85
  tmp = aal_device_read(block->device, block->data, block->nr * (blk_t )count, (count_t )count);
  }
#line 85
  return (tmp);
}
}
#line 92 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/block.c"
aal_block_t *aal_block_load(aal_device_t *device , uint32_t size , blk_t nr ) 
{ 
  aal_block_t *block ;
  errno_t tmp ;

  {
  {
#line 102
  block = aal_block_alloc(device, size, nr);
  }
#line 102
  if (! block) {
#line 103
    return ((aal_block_t *)((void *)0));
  }
  {
#line 105
  tmp = aal_block_read(block);
  }
#line 105
  if (tmp) {
#line 106
    goto error_free_block;
  }
#line 108
  return (block);
  error_free_block: 
  {
#line 111
  aal_block_free(block);
  }
#line 112
  return ((aal_block_t *)((void *)0));
}
}
#line 117 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/block.c"
void aal_block_move(aal_block_t *block , aal_device_t *device , blk_t nr ) 
{ 


  {
#line 124
  block->nr = nr;
#line 125
  block->dirty = 1;
#line 126
  block->device = device;
#line 127
  return;
}
}
#line 132 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/block.c"
errno_t aal_block_write(aal_block_t *block ) 
{ 
  uint32_t count ;
  errno_t tmp ;

  {
  {
#line 139
  block->dirty = 0;
#line 140
  count = block->size / (block->device)->blksize;
#line 142
  tmp = aal_device_write(block->device, block->data, block->nr * (blk_t )count, (count_t )count);
  }
#line 142
  return (tmp);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 12 "../include/aal/print.h"
int aal_vsnprintf(char *buff , uint32_t n , char const   *format , va_list arg_list ) ;
#line 22 "../include/aal/ui.h"
void aal_ui_set_numeric_handler(int64_t (*func)(char const   * , int64_t  , int (*)(int64_t  ,
                                                                                    void * ) ,
                                                void * ) ) ;
#line 23
aal_numeric_func_t aal_ui_get_numeric_handler(void) ;
#line 25
int64_t aal_ui_get_numeric(int64_t defvalue , int (*check_func)(int64_t  , void * ) ,
                           void *data , char const   *format  , ...) ;
#line 29
void aal_ui_set_alpha_handler(void (*func)(char const   * , char * , int (*)(char * ,
                                                                             void * ) ,
                                           void * ) ) ;
#line 30
aal_alpha_func_t aal_ui_get_alpha_handler(void) ;
#line 32
void aal_ui_get_alpha(char *defvalue , int (*check_func)(char * , void * ) , void *data ,
                      char const   *format  , ...) ;
#line 10 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/ui.c"
static int64_t (*numeric_handler)(char const   * , int64_t  , int (*)(int64_t  , void * ) ,
                                  void * )  =    (int64_t (*)(char const   * , int64_t  , int (*)(int64_t  , void * ) , void * ))((void *)0);
#line 12 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/ui.c"
void aal_ui_set_numeric_handler(int64_t (*func)(char const   * , int64_t  , int (*)(int64_t  ,
                                                                                    void * ) ,
                                                void * ) ) 
{ 


  {
#line 13
  numeric_handler = func;
#line 14
  return;
}
}
#line 16 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/ui.c"
aal_numeric_func_t aal_ui_get_numeric_handler(void) 
{ 


  {
#line 17
  return (numeric_handler);
}
}
#line 20 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/ui.c"
int64_t aal_ui_get_numeric(int64_t defvalue , int (*check_func)(int64_t  , void * ) ,
                           void *data , char const   *format  , ...) 
{ 
  char buff[256] ;
  va_list arg_list ;
  int64_t tmp ;

  {
#line 27
  if (! numeric_handler) {
#line 28
    return (~ 0LL);
  }
  {
#line 30
  aal_memset((void *)(buff), 0, (uint32_t )sizeof(buff));
#line 32
  __builtin_va_start(arg_list, format);
#line 33
  aal_vsnprintf(buff, (uint32_t )sizeof(buff), format, arg_list);
#line 34
  __builtin_va_end(arg_list);
#line 36
  tmp = (*numeric_handler)((char const   *)(buff), defvalue, check_func, data);
  }
#line 36
  return (tmp);
}
}
#line 39 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/ui.c"
static void (*alpha_handler)(char const   * , char * , int (*)(char * , void * ) ,
                             void * )  =    (void (*)(char const   * , char * , int (*)(char * , void * ) , void * ))((void *)0);
#line 41 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/ui.c"
void aal_ui_set_alpha_handler(void (*func)(char const   * , char * , int (*)(char * ,
                                                                             void * ) ,
                                           void * ) ) 
{ 


  {
#line 42
  alpha_handler = func;
#line 43
  return;
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/ui.c"
aal_alpha_func_t aal_ui_get_alpha_handler(void) 
{ 


  {
#line 46
  return (alpha_handler);
}
}
#line 49 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/ui.c"
void aal_ui_get_alpha(char *defvalue , int (*check_func)(char * , void * ) , void *data ,
                      char const   *format  , ...) 
{ 
  char buff[256] ;
  va_list arg_list ;

  {
#line 56
  if (! alpha_handler) {
#line 57
    return;
  }
  {
#line 59
  aal_memset((void *)(buff), 0, (uint32_t )sizeof(buff));
#line 61
  __builtin_va_start(arg_list, format);
#line 62
  aal_vsnprintf(buff, (uint32_t )sizeof(buff), format, arg_list);
#line 63
  __builtin_va_end(arg_list);
#line 65
  (*alpha_handler)((char const   *)(buff), defvalue, check_func, data);
  }
#line 66
  return;
}
}
#line 15 "../include/aal/string.h"
void *aal_memcpy(void *dest , void const   *src , uint32_t n ) ;
#line 16
void *aal_memmove(void *dest , void const   *src , uint32_t n ) ;
#line 17
int aal_memcmp(void const   *s1 , void const   *s2 , uint32_t n ) ;
#line 19
char *aal_strncpy(char *dest , char const   *src , uint32_t n ) ;
#line 20
char *aal_strncat(char *dest , char const   *src , uint32_t n ) ;
#line 21
int aal_strncmp(char const   *s1 , char const   *s2 , uint32_t n ) ;
#line 22
int aal_strcmp(char const   *s1 , char const   *s2 ) ;
#line 23
uint32_t aal_strlen(char const   *s ) ;
#line 25
char *aal_strpbrk(char const   *s , char const   *accept ) ;
#line 26
char *aal_strchr(char const   *s , int c ) ;
#line 27
char *aal_strrchr(char const   *s , int c ) ;
#line 28
char *aal_strsep(char **stringp , char const   *delim ) ;
#line 30
char *aal_strndup(char const   *s , uint32_t n ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 50
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 140
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 315
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strpbrk)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 557
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strsep)(char ** __restrict  __stringp ,
                                                                                                 char const   * __restrict  __delim ) ;
#line 189 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/string.c"
void *aal_memset(void *dest , int c , uint32_t n ) 
{ 
  void *tmp ;

  {
  {
#line 190
  tmp = memset(dest, c, (size_t )n);
  }
#line 190
  return (tmp);
}
}
#line 193 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/string.c"
void *aal_memcpy(void *dest , void const   *src , uint32_t n ) 
{ 
  void *tmp ;

  {
  {
#line 194
  tmp = memcpy((void */* __restrict  */)dest, (void const   */* __restrict  */)src,
               (size_t )n);
  }
#line 194
  return (tmp);
}
}
#line 197 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/string.c"
void *aal_memmove(void *dest , void const   *src , uint32_t n ) 
{ 
  void *tmp ;

  {
  {
#line 198
  tmp = memmove(dest, src, (size_t )n);
  }
#line 198
  return (tmp);
}
}
#line 201 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/string.c"
int aal_memcmp(void const   *s1 , void const   *s2 , uint32_t n ) 
{ 
  int tmp ;

  {
  {
#line 202
  tmp = memcmp(s1, s2, (size_t )n);
  }
#line 202
  return (tmp);
}
}
#line 205 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/string.c"
uint32_t aal_strlen(char const   *s ) 
{ 
  size_t tmp ;

  {
  {
#line 206
  tmp = strlen(s);
  }
#line 206
  return ((uint32_t )tmp);
}
}
#line 209 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/string.c"
int aal_strncmp(char const   *s1 , char const   *s2 , uint32_t n ) 
{ 
  int tmp ;

  {
  {
#line 210
  tmp = strncmp(s1, s2, (size_t )n);
  }
#line 210
  return (tmp);
}
}
#line 213 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/string.c"
int aal_strcmp(char const   *s1 , char const   *s2 ) 
{ 
  int tmp ;

  {
  {
#line 214
  tmp = strcmp(s1, s2);
  }
#line 214
  return (tmp);
}
}
#line 217 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/string.c"
char *aal_strncpy(char *dest , char const   *src , uint32_t n ) 
{ 
  char *tmp ;

  {
  {
#line 218
  tmp = strncpy((char */* __restrict  */)dest, (char const   */* __restrict  */)src,
                (size_t )n);
  }
#line 218
  return (tmp);
}
}
#line 221 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/string.c"
char *aal_strncat(char *dest , char const   *src , uint32_t n ) 
{ 
  char *tmp ;

  {
  {
#line 222
  tmp = strncat((char */* __restrict  */)dest, (char const   */* __restrict  */)src,
                (size_t )n);
  }
#line 222
  return (tmp);
}
}
#line 225 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/string.c"
char *aal_strpbrk(char const   *s , char const   *accept ) 
{ 
  char *tmp ;

  {
  {
#line 226
  tmp = strpbrk(s, accept);
  }
#line 226
  return (tmp);
}
}
#line 229 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/string.c"
char *aal_strchr(char const   *s , int c ) 
{ 
  char *tmp ;

  {
  {
#line 230
  tmp = strchr(s, c);
  }
#line 230
  return (tmp);
}
}
#line 233 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/string.c"
char *aal_strrchr(char const   *s , int c ) 
{ 
  char *tmp ;

  {
  {
#line 234
  tmp = strrchr(s, c);
  }
#line 234
  return (tmp);
}
}
#line 237 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/string.c"
char *aal_strsep(char **stringp , char const   *delim ) 
{ 
  char *tmp ;

  {
  {
#line 238
  tmp = strsep((char **/* __restrict  */)stringp, (char const   */* __restrict  */)delim);
  }
#line 238
  return (tmp);
}
}
#line 243 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/string.c"
char *aal_strndup(char const   *s , uint32_t n ) 
{ 
  char *str ;
  void *tmp ;

  {
  {
#line 244
  tmp = aal_calloc(n + 1U, (char)0);
#line 244
  str = (char *)tmp;
#line 245
  aal_strncpy(str, s, n);
  }
#line 247
  return (str);
}
}
#line 12 "../include/aal/exception.h"
void aal_exception_on(void) ;
#line 13
void aal_exception_off(void) ;
#line 16
char *aal_exception_option_name(aal_exception_option_t opt ) ;
#line 18
char *aal_exception_message(aal_exception_t *exception ) ;
#line 19
aal_exception_type_t aal_exception_type(aal_exception_t *exception ) ;
#line 20
aal_exception_option_t aal_exception_option(aal_exception_t *exception ) ;
#line 22
aal_exception_handler_t aal_exception_get_handler(void) ;
#line 23
void aal_exception_set_handler(aal_exception_option_t (*handler)(aal_exception_t *ex ) ) ;
#line 11 "../include/aal/math.h"
int aal_log2(uint32_t n ) ;
#line 10 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/exception.c"
static aal_exception_option_t (*exception_handler)(aal_exception_t *ex )  =    (aal_exception_option_t (*)(aal_exception_t *ex ))((void *)0);
#line 13 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/exception.c"
static char *option_names[6]  = {      (char *)"Yes",      (char *)"No",      (char *)"OK",      (char *)"Retry", 
        (char *)"Ignore",      (char *)"Cancel"};
#line 22 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/exception.c"
static int disable_count  =    0;
#line 25 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/exception.c"
aal_exception_type_t aal_exception_type(aal_exception_t *exception ) 
{ 


  {
#line 28
  return (exception->type);
}
}
#line 32 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/exception.c"
char *aal_exception_option_name(aal_exception_option_t opt ) 
{ 
  int tmp ;

  {
  {
#line 35
  tmp = aal_log2((uint32_t )opt);
  }
#line 35
  return (option_names[tmp - 1]);
}
}
#line 39 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/exception.c"
aal_exception_option_t aal_exception_option(aal_exception_t *exception ) 
{ 


  {
#line 42
  return (exception->options);
}
}
#line 46 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/exception.c"
char *aal_exception_message(aal_exception_t *exception ) 
{ 


  {
#line 49
  return (exception->message);
}
}
#line 54 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/exception.c"
void aal_exception_set_handler(aal_exception_option_t (*handler)(aal_exception_t *ex ) ) 
{ 


  {
#line 57
  exception_handler = handler;
#line 58
  return;
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/exception.c"
aal_exception_handler_t aal_exception_get_handler(void) 
{ 


  {
#line 61
  return (exception_handler);
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/exception.c"
void aal_exception_catch(aal_exception_t *exception ) 
{ 


  {
#line 68
  if (! exception) {
#line 68
    return;
  }
  {
#line 70
  aal_free((void *)exception->message);
#line 71
  aal_free((void *)exception);
  }
#line 72
  return;
}
}
#line 76 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/exception.c"
static aal_exception_option_t aal_exception_actual_throw(aal_exception_t *exception ) 
{ 
  aal_exception_option_t opt ;

  {
#line 81
  if (! exception_handler) {
#line 82
    return ((aal_exception_option_t )1);
  } else
#line 81
  if (disable_count) {
#line 82
    return ((aal_exception_option_t )1);
  }
  {
#line 84
  opt = (*exception_handler)(exception);
#line 85
  aal_exception_catch(exception);
  }
#line 87
  return (opt);
}
}
#line 99 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/exception.c"
aal_exception_option_t ( /* format attribute */  aal_exception_throw)(aal_exception_type_t type ,
                                                                      aal_exception_option_t opts ,
                                                                      char const   *message 
                                                                      , ...) 
{ 
  va_list arg_list ;
  aal_exception_t *exception ;
  void *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  aal_exception_option_t tmp___2 ;

  {
  {
#line 109
  tmp = aal_malloc((uint32_t )sizeof(aal_exception_t ));
#line 109
  exception = (aal_exception_t *)tmp;
  }
#line 109
  if (! exception) {
#line 110
    goto error_no_memory;
  }
  {
#line 113
  tmp___1 = aal_calloc((uint32_t )4096, (char)0);
#line 113
  tmp___0 = (char *)tmp___1;
#line 113
  exception->message = tmp___0;
  }
#line 113
  if (! tmp___0) {
#line 114
    goto error_no_memory;
  }
  {
#line 117
  exception->type = type;
#line 118
  exception->options = opts;
#line 121
  __builtin_va_start(arg_list, message);
#line 122
  aal_vsnprintf(exception->message, (uint32_t )4096, message, arg_list);
#line 123
  __builtin_va_end(arg_list);
#line 125
  tmp___2 = aal_exception_actual_throw(exception);
  }
#line 125
  return (tmp___2);
  error_no_memory: 
#line 128
  return ((aal_exception_option_t )1);
}
}
#line 135 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/exception.c"
void aal_exception_off(void) 
{ 


  {
#line 136
  disable_count ++;
#line 137
  return;
}
}
#line 139 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/exception.c"
void aal_exception_on(void) 
{ 


  {
#line 140
  if (disable_count > 0) {
#line 141
    disable_count --;
  }
#line 142
  return;
}
}
#line 16 "../include/aal/print.h"
int aal_snprintf(char *buff , uint32_t n , char const   *format  , ...) ;
#line 390 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 10 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/print.c"
int aal_vsnprintf(char *buff , uint32_t n , char const   *format , va_list arg_list ) 
{ 
  int tmp ;

  {
  {
#line 16
  tmp = vsnprintf((char */* __restrict  */)buff, (size_t )n, (char const   */* __restrict  */)format,
                  arg_list);
  }
#line 16
  return (tmp);
}
}
#line 20 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/print.c"
int aal_snprintf(char *buff , uint32_t n , char const   *format  , ...) 
{ 
  int len ;
  va_list arg_list ;

  {
  {
#line 29
  __builtin_va_start(arg_list, format);
#line 30
  len = aal_vsnprintf(buff, n, format, arg_list);
#line 31
  __builtin_va_end(arg_list);
  }
#line 33
  return (len);
}
}
#line 12 "../include/aal/gauge.h"
aal_gauge_t *aal_gauge_create(void (*handler)(aal_gauge_t * ) , void (*value_func)(aal_gauge_t * ) ,
                              void *data , uint64_t gap , char *label  , ...) ;
#line 17
void aal_gauge_rename(aal_gauge_t *gauge , char *label  , ...) ;
#line 19
void aal_gauge_touch(aal_gauge_t *gauge ) ;
#line 20
void aal_gauge_done(aal_gauge_t *gauge ) ;
#line 21
void aal_gauge_pause(aal_gauge_t *gauge ) ;
#line 22
void aal_gauge_free(aal_gauge_t *gauge ) ;
#line 24
void aal_gauge_set_value(aal_gauge_t *gauge , int64_t value ) ;
#line 25
int64_t aal_gauge_get_value(aal_gauge_t *gauge ) ;
#line 26
void aal_gauge_set_data(aal_gauge_t *gauge , void *data ) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/gauge.c"
aal_gauge_t *aal_gauge_create(void (*handler)(aal_gauge_t * ) , void (*value_func)(aal_gauge_t * ) ,
                              void *data , uint64_t gap , char *label  , ...) 
{ 
  aal_gauge_t *gauge ;
  va_list arg_list ;
  void *tmp ;

  {
#line 36
  if (! handler) {
#line 37
    return ((aal_gauge_t *)((void *)0));
  }
  {
#line 39
  tmp = aal_calloc((uint32_t )sizeof(*gauge), (char)0);
#line 39
  gauge = (aal_gauge_t *)tmp;
  }
#line 39
  if (! gauge) {
#line 40
    return ((aal_gauge_t *)((void *)0));
  }
  {
#line 42
  gauge->handler = handler;
#line 43
  gauge->value_func = value_func;
#line 44
  gauge->data = data;
#line 45
  gauge->value = (int64_t )-1;
#line 46
  gauge->time.gap = gap;
#line 48
  __builtin_va_start(arg_list, label);
#line 49
  aal_gauge_rename(gauge, label, arg_list);
#line 50
  __builtin_va_end(arg_list);
  }
#line 52
  return (gauge);
}
}
#line 56 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/gauge.c"
void aal_gauge_rename(aal_gauge_t *gauge , char *label  , ...) 
{ 
  va_list arg_list ;
  int len ;

  {
#line 60
  if (! gauge) {
#line 60
    return;
  } else
#line 60
  if (! label) {
#line 60
    return;
  }
  {
#line 62
  gauge->state = (aal_gauge_state_t )4;
#line 64
  __builtin_va_start(arg_list, label);
#line 65
  len = aal_vsnprintf(gauge->label, (uint32_t )sizeof(gauge->label), (char const   *)label,
                      arg_list);
#line 67
  __builtin_va_end(arg_list);
#line 69
  gauge->label[len] = (char )'\000';
  }
#line 70
  return;
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/gauge.c"
void aal_gauge_touch(aal_gauge_t *gauge ) 
{ 


  {
#line 74
  if (! gauge) {
#line 74
    return;
  }
#line 76
  if ((unsigned int )gauge->state == 4U) {
#line 77
    gauge->state = (aal_gauge_state_t )0;
  } else
#line 78
  if ((unsigned int )gauge->state == 2U) {
#line 79
    gauge->state = (aal_gauge_state_t )3;
  }
  {
#line 82
  (*(gauge->handler))(gauge);
#line 83
  gauge->state = (aal_gauge_state_t )1;
  }
#line 84
  return;
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/gauge.c"
void aal_gauge_done(aal_gauge_t *gauge ) 
{ 


  {
#line 88
  if (! gauge) {
#line 89
    return;
  } else
#line 88
  if ((unsigned int )gauge->state == 4U) {
#line 89
    return;
  }
#line 91
  if ((unsigned int )gauge->state == 2U) {
    {
#line 92
    aal_gauge_touch(gauge);
    }
  }
  {
#line 94
  gauge->state = (aal_gauge_state_t )4;
#line 95
  (*(gauge->handler))(gauge);
  }
#line 96
  return;
}
}
#line 99 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/gauge.c"
void aal_gauge_pause(aal_gauge_t *gauge ) 
{ 


  {
#line 100
  if (! gauge) {
#line 100
    return;
  }
#line 102
  if ((unsigned int )gauge->state != 1U) {
#line 102
    if ((unsigned int )gauge->state != 0U) {
#line 105
      return;
    }
  }
  {
#line 108
  gauge->state = (aal_gauge_state_t )2;
#line 109
  (*(gauge->handler))(gauge);
  }
#line 110
  return;
}
}
#line 113 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/gauge.c"
void aal_gauge_free(aal_gauge_t *gauge ) 
{ 


  {
#line 114
  if (! gauge) {
#line 114
    return;
  }
  {
#line 115
  aal_free((void *)gauge);
  }
#line 116
  return;
}
}
#line 118 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/gauge.c"
void aal_gauge_set_value(aal_gauge_t *gauge , int64_t value ) 
{ 


  {
#line 119
  if (! gauge) {
#line 119
    return;
  }
#line 120
  gauge->value = value;
#line 121
  return;
}
}
#line 123 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/gauge.c"
int64_t aal_gauge_get_value(aal_gauge_t *gauge ) 
{ 


  {
#line 124
  if (! gauge) {
#line 125
    return ((int64_t )-22);
  }
#line 127
  return (gauge->value);
}
}
#line 130 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/gauge.c"
void aal_gauge_set_data(aal_gauge_t *gauge , void *data ) 
{ 


  {
#line 131
  if (! gauge) {
#line 131
    return;
  }
#line 132
  gauge->data = data;
#line 133
  return;
}
}
#line 12 "../include/aal/list.h"
aal_list_t *aal_list_alloc(void *data ) ;
#line 13
aal_list_t *aal_list_last(aal_list_t *list ) ;
#line 14
aal_list_t *aal_list_first(aal_list_t *list ) ;
#line 16
uint32_t aal_list_len(aal_list_t *list ) ;
#line 18
errno_t aal_list_foreach(aal_list_t *list , errno_t (*func)(void * , void * ) , void *data ) ;
#line 22
aal_list_t *aal_list_prepend(aal_list_t *list , void *data ) ;
#line 25
int32_t aal_list_pos(aal_list_t *list , void *data ) ;
#line 26
aal_list_t *aal_list_at(aal_list_t *list , uint32_t n ) ;
#line 28
aal_list_t *aal_list_insert(aal_list_t *list , void *data , uint32_t n ) ;
#line 31
aal_list_t *aal_list_insert_sorted(aal_list_t *list , void *data , int (*comp_func)(void * ,
                                                                                    void * ,
                                                                                    void * ) ,
                                   void *user ) ;
#line 36
aal_list_t *aal_list_append(aal_list_t *list , void *data ) ;
#line 37
aal_list_t *aal_list_remove(aal_list_t *list , void *data ) ;
#line 38
aal_list_t *aal_list_find(aal_list_t *list , void *data ) ;
#line 40
aal_list_t *aal_list_find_custom(aal_list_t *list , void *needle , int (*comp_func)(void * ,
                                                                                    void * ,
                                                                                    void * ) ,
                                 void *user ) ;
#line 43
void aal_list_free(aal_list_t *list , errno_t (*func)(void * , void * ) , void *data ) ;
#line 10 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/list.c"
aal_list_t *aal_list_alloc(void *data ) 
{ 
  aal_list_t *list ;
  void *tmp ;

  {
  {
#line 13
  tmp = aal_calloc((uint32_t )sizeof(*list), (char)0);
#line 13
  list = (aal_list_t *)tmp;
  }
#line 13
  if (! list) {
#line 14
    return ((aal_list_t *)((void *)0));
  }
#line 16
  list->data = data;
#line 17
  list->next = (aal_list_t *)((void *)0);
#line 18
  list->prev = (aal_list_t *)((void *)0);
#line 20
  return (list);
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/list.c"
aal_list_t *aal_list_last(aal_list_t *list ) 
{ 


  {
#line 25
  if (! list) {
#line 25
    return ((aal_list_t *)((void *)0));
  }
  {
#line 27
  while (1) {
    while_continue: /* CIL Label */ ;
#line 27
    if (! list->next) {
#line 27
      goto while_break;
    }
#line 28
    list = list->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 30
  return (list);
}
}
#line 34 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/list.c"
aal_list_t *aal_list_first(aal_list_t *list ) 
{ 


  {
#line 35
  if (! list) {
#line 35
    return ((aal_list_t *)((void *)0));
  }
  {
#line 37
  while (1) {
    while_continue: /* CIL Label */ ;
#line 37
    if (! list->prev) {
#line 37
      goto while_break;
    }
#line 38
    list = list->prev;
  }
  while_break: /* CIL Label */ ;
  }
#line 40
  return (list);
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/list.c"
uint32_t aal_list_len(aal_list_t *list ) 
{ 
  uint32_t len ;

  {
#line 45
  len = (uint32_t )0;
  {
#line 47
  while (1) {
    while_continue: /* CIL Label */ ;
#line 47
    if (! list) {
#line 47
      goto while_break;
    }
#line 48
    len ++;
#line 49
    list = list->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 52
  return (len);
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/list.c"
errno_t aal_list_foreach(aal_list_t *list , errno_t (*func)(void * , void * ) , void *data ) 
{ 
  errno_t res ;
  aal_list_t *walk ;
  aal_list_t *next ;

  {
#line 65
  walk = list;
  {
#line 65
  while (1) {
    while_continue: /* CIL Label */ ;
#line 65
    if (! walk) {
#line 65
      goto while_break;
    }
    {
#line 66
    next = walk->next;
#line 68
    res = (*func)(walk->data, data);
    }
#line 68
    if (res) {
#line 69
      return (res);
    }
#line 71
    walk = next;
  }
  while_break: /* CIL Label */ ;
  }
#line 74
  return ((errno_t )0);
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/list.c"
int32_t aal_list_pos(aal_list_t *list , void *data ) 
{ 
  int32_t pos ;

  {
#line 79
  pos = 0;
  {
#line 81
  while (1) {
    while_continue: /* CIL Label */ ;
#line 81
    if (! list) {
#line 81
      goto while_break;
    }
#line 82
    if ((unsigned long )list->data == (unsigned long )data) {
#line 83
      return (pos);
    }
#line 85
    pos ++;
#line 86
    list = list->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 88
  return (pos);
}
}
#line 92 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/list.c"
aal_list_t *aal_list_at(aal_list_t *list , uint32_t n ) 
{ 
  uint32_t tmp ;

  {
#line 94
  if (! list) {
#line 95
    return ((aal_list_t *)((void *)0));
  }
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;
#line 97
    tmp = n;
#line 97
    n --;
#line 97
    if (tmp > 0U) {
#line 97
      if (! list->next) {
#line 97
        goto while_break;
      }
    } else {
#line 97
      goto while_break;
    }
#line 98
    list = list->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 100
  return (list);
}
}
#line 104 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/list.c"
aal_list_t *aal_list_insert(aal_list_t *list , void *data , uint32_t n ) 
{ 
  aal_list_t *at ;
  aal_list_t *tmp ;
  aal_list_t *tmp___0 ;

  {
#line 109
  if (n == 0U) {
    {
#line 110
    tmp = aal_list_prepend(list, data);
    }
#line 110
    return (tmp);
  }
  {
#line 112
  at = aal_list_at(list, n - 1U);
#line 113
  at = aal_list_append(at, data);
  }
#line 115
  if ((unsigned long )list == (unsigned long )((void *)0)) {
#line 115
    tmp___0 = at;
  } else {
#line 115
    tmp___0 = list;
  }
#line 115
  return (tmp___0);
}
}
#line 119 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/list.c"
aal_list_t *aal_list_insert_sorted(aal_list_t *list , void *data , int (*comp_func)(void * ,
                                                                                    void * ,
                                                                                    void * ) ,
                                   void *user ) 
{ 
  aal_list_t *at ;
  int cmp ;
  aal_list_t *tmp ;
  aal_list_t *tmp___0 ;
  aal_list_t *tmp___1 ;

  {
#line 122
  at = list;
#line 125
  if (! comp_func) {
#line 126
    return ((aal_list_t *)((void *)0));
  }
#line 128
  if (! list) {
    {
#line 129
    at = aal_list_alloc(data);
    }
#line 130
    return (at);
  }
  {
#line 133
  cmp = (*comp_func)(at->data, data, user);
  }
  {
#line 135
  while (1) {
    while_continue: /* CIL Label */ ;
#line 135
    if (at->next) {
#line 135
      if (! (cmp < 0)) {
#line 135
        goto while_break;
      }
    } else {
#line 135
      goto while_break;
    }
    {
#line 136
    at = at->next;
#line 137
    cmp = (*comp_func)(at->data, data, user);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 140
  if (cmp > 0) {
    {
#line 140
    tmp = aal_list_prepend(at, data);
#line 140
    at = tmp;
    }
  } else {
    {
#line 140
    tmp___0 = aal_list_append(at, data);
#line 140
    at = tmp___0;
    }
  }
#line 144
  if ((unsigned long )list == (unsigned long )at->next) {
#line 144
    tmp___1 = at;
  } else {
#line 144
    tmp___1 = list;
  }
#line 144
  return (tmp___1);
}
}
#line 148 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/list.c"
aal_list_t *aal_list_prepend(aal_list_t *list , void *data ) 
{ 
  aal_list_t *new ;

  {
  {
#line 151
  new = aal_list_alloc(data);
  }
#line 151
  if (! new) {
#line 152
    return ((aal_list_t *)0);
  }
#line 154
  if (list) {
#line 155
    if (list->prev) {
#line 156
      (list->prev)->next = new;
#line 157
      new->prev = list->prev;
    }
#line 159
    list->prev = new;
#line 160
    new->next = list;
  }
#line 163
  return (new);
}
}
#line 167 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/list.c"
aal_list_t *aal_list_append(aal_list_t *list , void *data ) 
{ 
  aal_list_t *new ;

  {
  {
#line 170
  new = aal_list_alloc(data);
  }
#line 170
  if (! new) {
#line 171
    return ((aal_list_t *)0);
  }
#line 173
  if (list) {
#line 174
    if (list->next) {
#line 175
      (list->next)->prev = new;
    }
#line 177
    new->next = list->next;
#line 178
    new->prev = list;
#line 180
    list->next = new;
#line 182
    return (list);
  } else {
#line 184
    return (new);
  }
}
}
#line 189 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/list.c"
aal_list_t *aal_list_remove(aal_list_t *list , void *data ) 
{ 
  aal_list_t *temp ;
  aal_list_t *result ;

  {
#line 191
  result = list;
#line 193
  if (list) {
    {
#line 193
    temp = aal_list_find(list, data);
    }
#line 193
    if (temp) {
#line 194
      if (temp->prev) {
#line 195
        (temp->prev)->next = temp->next;
      }
#line 197
      if (temp->next) {
#line 198
        (temp->next)->prev = temp->prev;
      }
#line 200
      if ((unsigned long )temp == (unsigned long )list) {
#line 201
        if (temp->next) {
#line 202
          result = temp->next;
        } else
#line 203
        if (temp->prev) {
#line 204
          result = temp->prev;
        } else {
#line 206
          result = (aal_list_t *)((void *)0);
        }
      }
      {
#line 209
      aal_free((void *)temp);
      }
    }
  }
#line 212
  return (result);
}
}
#line 216 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/list.c"
aal_list_t *aal_list_find(aal_list_t *list , void *data ) 
{ 


  {
  {
#line 217
  while (1) {
    while_continue: /* CIL Label */ ;
#line 217
    if (! list) {
#line 217
      goto while_break;
    }
#line 218
    if ((unsigned long )list->data == (unsigned long )data) {
#line 219
      return (list);
    }
#line 221
    list = list->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 223
  return ((aal_list_t *)((void *)0));
}
}
#line 226 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/list.c"
aal_list_t *aal_list_find_custom(aal_list_t *list , void *needle , int (*comp_func)(void * ,
                                                                                    void * ,
                                                                                    void * ) ,
                                 void *user ) 
{ 
  int tmp ;

  {
#line 230
  if (! comp_func) {
#line 231
    return ((aal_list_t *)((void *)0));
  }
  {
#line 233
  while (1) {
    while_continue: /* CIL Label */ ;
#line 233
    if (! list) {
#line 233
      goto while_break;
    }
    {
#line 234
    tmp = (*comp_func)(list->data, needle, user);
    }
#line 234
    if (tmp == 0) {
#line 235
      return (list);
    }
#line 237
    list = list->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 240
  return ((aal_list_t *)((void *)0));
}
}
#line 244 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/list.c"
void aal_list_free(aal_list_t *list , errno_t (*func)(void * , void * ) , void *data ) 
{ 
  aal_list_t *last ;
  aal_list_t *temp ;

  {
#line 245
  last = list;
#line 247
  if (! list) {
#line 247
    return;
  }
  {
#line 249
  while (1) {
    while_continue: /* CIL Label */ ;
#line 249
    if (! last->next) {
#line 249
      goto while_break;
    }
#line 250
    temp = last->next;
#line 252
    if (func) {
      {
#line 252
      (*func)(last->data, data);
      }
    }
    {
#line 254
    aal_free((void *)last);
#line 255
    last = temp;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 257
  return;
}
}
#line 9 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/math.c"
int aal_log2(uint32_t n ) 
{ 
  uint32_t x ;

  {
#line 12
  x = (uint32_t )0;
  {
#line 12
  while (1) {
    while_continue: /* CIL Label */ ;
#line 12
    if (! ((uint32_t )(1 << x) <= n)) {
#line 12
      goto while_break;
    }
#line 12
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 13
  return ((int )(x - 1U));
}
}
#line 18 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/math.c"
int aal_pow2(uint32_t n ) 
{ 


  {
#line 19
  return ((n & - n) == n);
}
}
#line 23 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/math.c"
uint32_t aal_abs(int32_t n ) 
{ 
  int32_t tmp ;

  {
#line 24
  if (n > 0) {
#line 24
    tmp = n;
  } else {
#line 24
    tmp = - n;
  }
#line 24
  return ((uint32_t )tmp);
}
}
#line 27 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/math.c"
int aal_min(int32_t v1 , int32_t v2 ) 
{ 
  int32_t tmp ;

  {
#line 28
  if (v1 < v2) {
#line 28
    tmp = v1;
  } else {
#line 28
    tmp = v2;
  }
#line 28
  return (tmp);
}
}
#line 31 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/math.c"
__inline static void aal_divl(uint32_t high , uint32_t low , uint32_t div , uint32_t *q ,
                              uint32_t *r ) 
{ 
  uint64_t n ;
  uint64_t d ;
  uint32_t q1 ;
  int c ;

  {
#line 35
  n = ((uint64_t )high << 32) | (unsigned long long )low;
#line 36
  d = (uint64_t )div << 31;
#line 37
  q1 = (uint32_t )0;
#line 38
  c = 32;
  {
#line 40
  while (1) {
    while_continue: /* CIL Label */ ;
#line 40
    if (! (n > 4294967295ULL)) {
#line 40
      goto while_break;
    }
#line 41
    q1 <<= 1;
#line 42
    if (n >= d) {
#line 43
      n -= d;
#line 44
      q1 |= 1U;
    }
#line 46
    d >>= 1;
#line 47
    c --;
  }
  while_break: /* CIL Label */ ;
  }
#line 49
  q1 <<= c;
#line 50
  if (n) {
#line 51
    low = (uint32_t )n;
#line 52
    *q = q1 | low / div;
#line 53
    if (r) {
#line 54
      *r = low % div;
    }
  } else {
#line 56
    if (r) {
#line 57
      *r = (uint32_t )0;
    }
#line 58
    *q = q1;
  }
#line 60
  return;
}
}
#line 63 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/math.c"
uint64_t aal_div64(uint64_t n , uint32_t div , uint32_t *rem ) 
{ 
  uint32_t low ;
  uint32_t high ;
  uint32_t high1 ;
  uint32_t low1 ;

  {
#line 66
  low = (uint32_t )(n & 4294967295ULL);
#line 67
  high = (uint32_t )(n >> 32);
#line 69
  if (high) {
    {
#line 70
    high1 = high % div;
#line 71
    low1 = low;
#line 72
    high /= div;
#line 73
    aal_divl(high1, low1, div, & low, rem);
    }
#line 74
    return (((uint64_t )high << 32) | (unsigned long long )low);
  } else {
#line 76
    if (rem) {
#line 77
      *rem = low % div;
    }
#line 78
    return ((uint64_t )(low / div));
  }
}
}
#line 82 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/math.c"
uint32_t aal_mod64(uint64_t n , uint32_t div ) 
{ 
  uint32_t rem ;

  {
  {
#line 85
  aal_div64(n, div, & rem);
  }
#line 86
  return (rem);
}
}
#line 13 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/libaal.c"
int libaal_max_interface_version(void) 
{ 


  {
#line 14
  return (0);
}
}
#line 18 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/libaal.c"
int libaal_min_interface_version(void) 
{ 


  {
#line 19
  return (0);
}
}
#line 23 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/libaal.c"
char const   *libaal_version(void) 
{ 


  {
#line 24
  return ("1.0.5");
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/debug.c"
void __actual_bug(char *hint , char *file , int line , char *func , char *text  , ...) 
{ 


  {
#line 65
  return;
}
}
#line 69 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/debug.c"
void __actual_assert(char *hint , int cond , char *text , char *file , int line ,
                     char *func ) 
{ 


  {
#line 82
  return;
}
}
#line 12 "../include/aal/bitops.h"
__inline int aal_set_bit(void *map , bit_t nr ) ;
#line 13
__inline int aal_clear_bit(void *map , bit_t nr ) ;
#line 14
__inline int aal_test_bit(void *map , bit_t nr ) ;
#line 16
__inline bit_t aal_find_first_zero_bit(void *map , bit_t size ) ;
#line 18
__inline bit_t aal_find_next_zero_bit(void *map , bit_t size , bit_t offset ) ;
#line 21
__inline bit_t aal_find_next_set_bit(void *map , bit_t size , bit_t offset ) ;
#line 24
__inline bit_t aal_find_zero_bits(void *map , bit_t size , bit_t *start , bit_t count ) ;
#line 27
__inline bit_t aal_find_set_bits(void *map , bit_t size , bit_t *start , bit_t count ) ;
#line 30
__inline void aal_clear_bits(void *map , bit_t start , bit_t count ) ;
#line 33
__inline void aal_set_bits(void *map , bit_t start , bit_t count ) ;
#line 12 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/bitops.c"
__inline int aal_set_bit(void *map , bit_t nr ) 
{ 
  int retval ;
  unsigned char *p ;
  unsigned char mask ;

  {
#line 16
  p = (unsigned char *)map;
#line 17
  p += nr >> 3;
#line 18
  mask = (unsigned char )(1 << (nr & 7ULL));
#line 20
  retval = ((int )mask & (int )*p) != 0;
#line 21
  *p = (unsigned char )((int )*p | (int )mask);
#line 23
  return (retval);
}
}
#line 27 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/bitops.c"
__inline int aal_clear_bit(void *map , bit_t nr ) 
{ 
  int retval ;
  unsigned char *p ;
  unsigned char mask ;

  {
#line 31
  p = (unsigned char *)map;
#line 32
  p += nr >> 3;
#line 33
  mask = (unsigned char )(1 << (nr & 7ULL));
#line 35
  retval = ((int )mask & (int )*p) != 0;
#line 36
  *p = (unsigned char )((int )*p & ~ ((int )mask));
#line 38
  return (retval);
}
}
#line 42 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/bitops.c"
__inline int aal_test_bit(void *map , bit_t nr ) 
{ 
  unsigned char *p ;
  unsigned char mask ;

  {
#line 45
  p = (unsigned char *)map;
#line 46
  p += nr >> 3;
#line 47
  mask = (unsigned char )(1 << (nr & 7ULL));
#line 48
  return (((int )mask & (int )*p) != 0);
}
}
#line 52 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/bitops.c"
__inline bit_t aal_find_first_zero_bit(void *map , bit_t size ) 
{ 
  int res ;
  unsigned char *p ;
  unsigned char *addr ;
  unsigned char *tmp ;
  int tmp___0 ;

  {
#line 56
  p = (unsigned char *)map;
#line 57
  addr = (unsigned char *)map;
#line 59
  if (! size) {
#line 60
    return ((bit_t )0);
  }
#line 62
  size = (size >> 3) + (bit_t )((size & 7ULL) > 0ULL);
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
#line 64
    tmp = p;
#line 64
    p ++;
#line 64
    if (! ((int )*tmp == 255)) {
#line 64
      goto while_break;
    }
#line 65
    size --;
#line 65
    if (size == 0ULL) {
#line 66
      return ((bit_t )((p - addr) << 3));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 69
  p --;
#line 70
  res = 0;
  {
#line 70
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 70
    if (! (res < 8)) {
#line 70
      goto while_break___0;
    }
    {
#line 71
    tmp___0 = aal_test_bit((void *)p, (bit_t )res);
    }
#line 71
    if (! tmp___0) {
#line 72
      goto while_break___0;
    }
#line 70
    res ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 75
  return ((bit_t )((p - addr) * 8L + (long )res));
}
}
#line 79 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/bitops.c"
__inline bit_t aal_find_next_zero_bit(void *map , bit_t size , bit_t offset ) 
{ 
  bit_t bit ;
  bit_t res ;
  unsigned char *addr ;
  unsigned char *p ;
  int tmp ;

  {
#line 83
  bit = offset & 7ULL;
#line 84
  addr = (unsigned char *)map;
#line 85
  p = addr + (offset >> 3);
#line 87
  if (offset >= size) {
#line 88
    return (size);
  }
#line 90
  if (bit) {
#line 91
    res = bit;
    {
#line 91
    while (1) {
      while_continue: /* CIL Label */ ;
#line 91
      if (! (res < 8ULL)) {
#line 91
        goto while_break;
      }
      {
#line 92
      tmp = aal_test_bit((void *)p, res);
      }
#line 92
      if (! tmp) {
#line 93
        return ((bit_t )((p - addr) * 8L) + res);
      }
#line 91
      res ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 94
    p ++;
  }
  {
#line 97
  res = aal_find_first_zero_bit((void *)p, size - (bit_t )(8L * (p - addr)));
  }
#line 98
  return ((bit_t )((p - addr) * 8L) + res);
}
}
#line 102 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/bitops.c"
__inline static int aal_find_nzb(unsigned char byte , bit_t offset ) 
{ 
  bit_t i ;
  unsigned char mask ;

  {
#line 103
  i = offset;
#line 104
  mask = (unsigned char )(1 << offset);
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
#line 106
    if (! (((int )byte & (int )mask) != 0)) {
#line 106
      goto while_break;
    }
#line 107
    mask = (unsigned char )((int )mask << 1);
#line 109
    i ++;
#line 109
    if (i >= 8ULL) {
#line 110
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 113
  return ((int )i);
}
}
#line 117 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/bitops.c"
__inline bit_t aal_find_next_set_bit(void *map , bit_t size , bit_t offset ) 
{ 
  unsigned char *addr ;
  bit_t byte_nr ;
  bit_t bit_nr ;
  bit_t max_byte_nr ;
  unsigned int b ;
  unsigned int nzb ;
  int tmp ;
  unsigned int b___0 ;
  unsigned int nzb___0 ;
  int tmp___0 ;

  {
#line 121
  addr = (unsigned char *)map;
#line 122
  byte_nr = offset >> 3;
#line 123
  bit_nr = offset & 7ULL;
#line 124
  max_byte_nr = (size - 1ULL) >> 3;
#line 126
  if (bit_nr != 0ULL) {
    {
#line 127
    b = ~ ((unsigned int )*(addr + byte_nr));
#line 128
    tmp = aal_find_nzb((unsigned char )b, bit_nr);
#line 128
    nzb = (unsigned int )tmp;
    }
#line 130
    if (nzb < 8U) {
#line 131
      return ((byte_nr << 3) + (bit_t )nzb);
    }
#line 133
    byte_nr ++;
  }
  {
#line 136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 136
    if (! (byte_nr <= max_byte_nr)) {
#line 136
      goto while_break;
    }
#line 137
    if ((int )*(addr + byte_nr) != 0) {
      {
#line 138
      b___0 = ~ ((unsigned int )*(addr + byte_nr));
#line 139
      tmp___0 = aal_find_nzb((unsigned char )b___0, (bit_t )0);
#line 139
      nzb___0 = (unsigned int )tmp___0;
      }
#line 141
      return ((byte_nr << 3) + (bit_t )nzb___0);
    }
#line 144
    byte_nr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 147
  return (size);
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/bitops.c"
__inline void aal_clear_bits(void *map , bit_t start , bit_t count ) 
{ 
  bit_t end_byte ;
  bit_t start_byte ;
  char *addr ;
  bit_t left ;
  bit_t right ;

  {
#line 157
  addr = (char *)map;
#line 160
  start_byte = start >> 3;
#line 161
  end_byte = ((start + count) - 1ULL) >> 3;
#line 163
  if (end_byte > start_byte + 1ULL) {
    {
#line 164
    aal_memset((void *)((addr + start_byte) + 1), 0, (uint32_t )((end_byte - start_byte) - 1ULL));
    }
  }
#line 169
  left = start - start_byte * 8ULL;
#line 170
  if (start_byte == end_byte) {
#line 170
    right = left + count;
  } else {
#line 170
    right = (bit_t )8;
  }
#line 172
  *(addr + start_byte) = (char )((int )*(addr + start_byte) & ~ ((255 << left) & (255 >> (8ULL - right))));
#line 176
  if (start_byte != end_byte) {
#line 177
    right = (start + count) - end_byte * 8ULL;
#line 179
    *(addr + end_byte) = (char )((int )*(addr + end_byte) & ~ (255 >> (8ULL - right)));
  }
#line 181
  return;
}
}
#line 184 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/bitops.c"
__inline void aal_set_bits(void *map , bit_t start , bit_t count ) 
{ 
  bit_t end_byte ;
  bit_t start_byte ;
  char *addr ;
  bit_t left ;
  bit_t right ;

  {
#line 190
  addr = (char *)map;
#line 193
  start_byte = start >> 3;
#line 194
  end_byte = ((start + count) - 1ULL) >> 3;
#line 196
  if (end_byte > start_byte + 1ULL) {
    {
#line 197
    aal_memset((void *)((addr + start_byte) + 1), 255, (uint32_t )((end_byte - start_byte) - 1ULL));
    }
  }
#line 202
  left = start - start_byte * 8ULL;
#line 203
  if (start_byte == end_byte) {
#line 203
    right = left + count;
  } else {
#line 203
    right = (bit_t )8;
  }
#line 205
  *(addr + start_byte) = (char )((int )*(addr + start_byte) | ((255 << left) & (255 >> (8ULL - right))));
#line 209
  if (start_byte != end_byte) {
#line 210
    right = (start + count) - end_byte * 8ULL;
#line 212
    *(addr + end_byte) = (char )((int )*(addr + end_byte) | (255 >> (8ULL - right)));
  }
#line 214
  return;
}
}
#line 217 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/bitops.c"
__inline bit_t aal_find_zero_bits(void *map , bit_t size , bit_t *start , bit_t count ) 
{ 
  bit_t beg ;
  bit_t end ;
  bit_t search_end ;

  {
  {
#line 224
  beg = aal_find_next_zero_bit(map, size, *start);
  }
#line 225
  if (beg >= size) {
#line 226
    return ((bit_t )0);
  }
#line 228
  if (beg + count > size) {
#line 228
    search_end = size;
  } else {
#line 228
    search_end = beg + count;
  }
  {
#line 230
  end = aal_find_next_set_bit(map, search_end, beg + 1ULL);
  }
#line 231
  if (end > search_end) {
#line 232
    end = search_end;
  }
#line 234
  *start = beg;
#line 235
  return (end - beg);
}
}
#line 239 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/bitops.c"
__inline bit_t aal_find_set_bits(void *map , bit_t size , bit_t *start , bit_t count ) 
{ 
  bit_t beg ;
  bit_t end ;
  bit_t search_end ;

  {
  {
#line 246
  beg = aal_find_next_set_bit(map, size, *start);
  }
#line 247
  if (beg >= size) {
#line 248
    return ((bit_t )0);
  }
#line 250
  if (beg + count > size) {
#line 250
    search_end = size;
  } else {
#line 250
    search_end = beg + count;
  }
  {
#line 252
  end = aal_find_next_zero_bit(map, search_end, beg + 1ULL);
  }
#line 253
  if (end >= search_end) {
#line 254
    end = search_end;
  }
#line 256
  *start = beg;
#line 257
  return (end - beg);
}
}
#line 149 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...)  __asm__("open64")  ;
#line 337 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off64_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                  __off64_t __offset ,
                                                                                  int __whence )  __asm__("lseek64")  ;
#line 353
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 956
extern int fsync(int __fd ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 413 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 12 "../include/aal/file.h"
struct aal_device_ops file_ops ;
#line 27 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/file.c"
static void file_error(aal_device_t *device ) 
{ 
  char *error ;
  uint32_t tmp ;
  int *tmp___0 ;

  {
#line 32
  if (! device) {
#line 33
    return;
  }
  {
#line 35
  tmp___0 = __errno_location();
#line 35
  error = strerror(*tmp___0);
  }
#line 35
  if (error) {
    {
#line 36
    tmp = aal_strlen((char const   *)error);
#line 36
    aal_strncpy(device->error, (char const   *)error, tmp);
    }
  }
#line 37
  return;
}
}
#line 41 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/file.c"
errno_t file_open(aal_device_t *device , void *person , uint32_t blksize , int flags ) 
{ 
  int fd ;
  char *filename ;
  uint32_t tmp ;
  void *tmp___0 ;

  {
#line 50
  if (! device) {
#line 51
    return ((errno_t )-22);
  }
#line 53
  if (! person) {
#line 54
    return ((errno_t )-22);
  } else {
    {
#line 53
    tmp = aal_strlen((char const   *)((char *)person));
    }
#line 53
    if (tmp == 0U) {
#line 54
      return ((errno_t )-22);
    }
  }
  {
#line 58
  tmp___0 = aal_calloc((uint32_t )sizeof(int ), (char)0);
#line 58
  device->entity = tmp___0;
  }
#line 58
  if (! tmp___0) {
#line 59
    return ((errno_t )-12);
  }
  {
#line 62
  filename = (char *)person;
#line 68
  fd = open((char const   *)filename, flags);
  }
#line 68
  if (fd == -1) {
#line 69
    goto error_free_entity;
  }
  {
#line 71
  *((int *)device->entity) = fd;
#line 73
  aal_strncpy(device->name, (char const   *)filename, (uint32_t )sizeof(device->name));
  }
#line 76
  return ((errno_t )0);
  error_free_entity: 
  {
#line 79
  aal_free(device->entity);
  }
#line 80
  return ((errno_t )-22);
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/file.c"
void file_close(aal_device_t *device ) 
{ 


  {
#line 89
  if (! device) {
#line 90
    return;
  }
  {
#line 93
  close(*((int *)device->entity));
#line 94
  aal_free(device->entity);
  }
#line 95
  return;
}
}
#line 99 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/file.c"
static errno_t file_read(aal_device_t *device , void *buff , blk_t block , count_t count ) 
{ 
  off_t off ;
  off_t len ;
  int *tmp ;
  __off64_t tmp___0 ;
  int *tmp___1 ;
  ssize_t tmp___2 ;

  {
#line 107
  if (! device) {
#line 108
    return ((errno_t )-22);
  } else
#line 107
  if (! buff) {
#line 108
    return ((errno_t )-22);
  }
  {
#line 113
  off = (off_t )block * (off_t )device->blksize;
#line 115
  tmp___0 = lseek(*((int *)device->entity), off, 0);
  }
#line 115
  if (tmp___0 == -1L) {
    {
#line 116
    file_error(device);
#line 117
    tmp = __errno_location();
    }
#line 117
    return ((errno_t )*tmp);
  }
  {
#line 121
  len = (off_t )count * (off_t )device->blksize;
#line 123
  tmp___2 = read(*((int *)device->entity), buff, (size_t )len);
  }
#line 123
  if (tmp___2 <= 0L) {
    {
#line 124
    file_error(device);
#line 125
    tmp___1 = __errno_location();
    }
#line 125
    return ((errno_t )*tmp___1);
  }
#line 128
  return ((errno_t )0);
}
}
#line 133 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/file.c"
static errno_t file_write(aal_device_t *device , void *buff , blk_t block , count_t count ) 
{ 
  off_t off ;
  off_t len ;
  int *tmp ;
  __off64_t tmp___0 ;
  int *tmp___1 ;
  ssize_t tmp___2 ;

  {
#line 141
  if (! device) {
#line 142
    return ((errno_t )-22);
  } else
#line 141
  if (! buff) {
#line 142
    return ((errno_t )-22);
  }
  {
#line 145
  off = (off_t )block * (off_t )device->blksize;
#line 147
  tmp___0 = lseek(*((int *)device->entity), off, 0);
  }
#line 147
  if (tmp___0 == -1L) {
    {
#line 148
    file_error(device);
#line 149
    tmp = __errno_location();
    }
#line 149
    return ((errno_t )*tmp);
  }
  {
#line 153
  len = (off_t )count * (off_t )device->blksize;
#line 155
  tmp___2 = write(*((int *)device->entity), (void const   *)buff, (size_t )len);
  }
#line 155
  if (tmp___2 <= 0L) {
    {
#line 156
    file_error(device);
#line 157
    tmp___1 = __errno_location();
    }
#line 157
    return ((errno_t )*tmp___1);
  }
#line 160
  return ((errno_t )0);
}
}
#line 165 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/file.c"
static errno_t file_sync(aal_device_t *device ) 
{ 
  int *tmp ;
  int tmp___0 ;

  {
#line 168
  if (! device) {
#line 169
    return ((errno_t )-22);
  }
  {
#line 173
  tmp___0 = fsync(*((int *)device->entity));
  }
#line 173
  if (tmp___0) {
    {
#line 174
    file_error(device);
#line 175
    tmp = __errno_location();
    }
#line 175
    return ((errno_t )*tmp);
  }
#line 178
  return ((errno_t )0);
}
}
#line 183 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/file.c"
static errno_t file_equals(aal_device_t *device1 , aal_device_t *device2 ) 
{ 
  char *file1 ;
  char *file2 ;
  uint32_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 189
  if (! device1) {
#line 190
    return ((errno_t )0);
  } else
#line 189
  if (! device2) {
#line 190
    return ((errno_t )0);
  }
  {
#line 192
  file1 = (char *)device1->data;
#line 193
  file2 = (char *)device2->data;
#line 196
  tmp = aal_strlen((char const   *)file1);
#line 196
  tmp___0 = aal_strncmp((char const   *)file1, (char const   *)file2, tmp);
  }
#line 196
  if (tmp___0) {
#line 196
    tmp___1 = 0;
  } else {
#line 196
    tmp___1 = 1;
  }
#line 196
  return ((errno_t )tmp___1);
}
}
#line 201 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/file.c"
static count_t file_len(aal_device_t *device ) 
{ 
  uint64_t size ;
  off_t max_off ;
  int tmp ;
  unsigned long l_size ;
  int tmp___0 ;

  {
#line 205
  max_off = (off_t )0;
#line 207
  if (! device) {
#line 208
    return ((uint64_t )(~ 0));
  }
  {
#line 211
  tmp = ioctl(*((int *)device->entity), (unsigned long )(((2U << 30) | (unsigned int )(18 << 8)) | 114U) | (sizeof(size_t ) << 16),
              & size);
  }
#line 211
  if (tmp >= 0) {
#line 212
    return (size / (uint64_t )device->blksize);
  }
  {
#line 221
  tmp___0 = ioctl(*((int *)device->entity), (unsigned long )((unsigned int )(18 << 8) | 96U),
                  & l_size);
  }
#line 221
  if (tmp___0 >= 0) {
#line 222
    size = (uint64_t )l_size;
#line 223
    return ((size * 512ULL) / (uint64_t )device->blksize);
  }
  {
#line 229
  max_off = lseek(*((int *)device->entity), (__off64_t )0, 2);
  }
#line 229
  if (max_off == -1L) {
    {
#line 232
    file_error(device);
    }
#line 233
    return ((uint64_t )(~ 0));
  }
#line 236
  return ((count_t )(max_off / (off_t )device->blksize));
}
}
#line 243 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/file.c"
struct aal_device_ops file_ops  =    {& file_open, & file_read, & file_write, & file_sync, & file_equals, & file_len,
    & file_close};
#line 15 "../include/aal/malloc.h"
void aal_mem_fini(void) ;
#line 16
unsigned int aal_mem_free(void) ;
#line 17
void aal_mem_init(void *start , uint32_t len ) ;
#line 23
void aal_malloc_set_handler(void *(*handler)(uint32_t  ) ) ;
#line 24
aal_malloc_handler_t aal_malloc_get_handler(void) ;
#line 26
aal_free_handler_t aal_free_get_handler(void) ;
#line 27
void aal_free_set_handler(void (*handler)(void * ) ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 16 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/malloc.c"
static void (*free_handler)(void * )  =    (void (*)(void * ))(& free);
#line 17 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/malloc.c"
static void *(*malloc_handler)(uint32_t  )  =    (void *(*)(uint32_t  ))(& malloc);
#line 27 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/malloc.c"
void aal_malloc_set_handler(void *(*handler)(uint32_t  ) ) 
{ 


  {
#line 30
  malloc_handler = handler;
#line 31
  return;
}
}
#line 34 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/malloc.c"
aal_malloc_handler_t aal_malloc_get_handler(void) 
{ 


  {
#line 35
  return (malloc_handler);
}
}
#line 39 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/malloc.c"
void aal_free_set_handler(void (*handler)(void * ) ) 
{ 


  {
#line 42
  free_handler = handler;
#line 43
  return;
}
}
#line 46 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/malloc.c"
aal_free_handler_t aal_free_get_handler(void) 
{ 


  {
#line 47
  return (free_handler);
}
}
#line 201 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/malloc.c"
void aal_mem_init(void *start , uint32_t len ) 
{ 


  {
#line 202
  return;
}
}
#line 204 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/malloc.c"
void aal_mem_fini(void) 
{ 


  {
#line 205
  return;
}
}
#line 207 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/malloc.c"
unsigned int aal_mem_free(void) 
{ 


  {
#line 208
  return (0U);
}
}
#line 214 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/malloc.c"
void aal_free(void *ptr ) 
{ 


  {
#line 217
  if (! free_handler) {
#line 218
    return;
  }
  {
#line 220
  (*free_handler)(ptr);
  }
#line 221
  return;
}
}
#line 225 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/malloc.c"
void *aal_malloc(uint32_t size ) 
{ 
  void *mem ;

  {
#line 233
  if (! malloc_handler) {
#line 234
    return ((void *)0);
  }
  {
#line 236
  mem = (*malloc_handler)(size);
  }
#line 236
  if (! mem) {
#line 237
    return ((void *)0);
  }
#line 239
  return (mem);
}
}
#line 243 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/malloc.c"
void *aal_calloc(uint32_t size , char c ) 
{ 
  void *mem ;

  {
  {
#line 249
  mem = aal_malloc(size);
  }
#line 249
  if (! mem) {
#line 250
    return ((void *)0);
  }
  {
#line 252
  aal_memset(mem, (int )c, size);
  }
#line 253
  return (mem);
}
}
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 343 "../include/aal/types.h"
aal_proto_t file_stream ;
#line 344
aal_proto_t memory_stream ;
#line 12 "../include/aal/stream.h"
int aal_stream_eof(aal_stream_t *stream ) ;
#line 13
void aal_stream_fini(aal_stream_t *stream ) ;
#line 14
void aal_stream_close(aal_stream_t *stream ) ;
#line 15
void aal_stream_reset(aal_stream_t *stream ) ;
#line 17
aal_stream_t *aal_stream_create(void *entity , aal_proto_t *proto ) ;
#line 20
int32_t aal_stream_read(aal_stream_t *stream , void *buff , uint32_t n ) ;
#line 23
int32_t aal_stream_write(aal_stream_t *stream , void *buff , uint32_t n ) ;
#line 26
int32_t aal_stream_format(aal_stream_t *stream , char const   *format  , ...) ;
#line 28
void aal_stream_init(aal_stream_t *stream , void *entity , aal_proto_t *proto ) ;
#line 11 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/stream.c"
aal_stream_t *aal_stream_create(void *entity , aal_proto_t *proto ) 
{ 
  aal_stream_t *stream ;
  void *tmp ;

  {
  {
#line 18
  tmp = aal_calloc((uint32_t )sizeof(*stream), (char)0);
#line 18
  stream = (aal_stream_t *)tmp;
  }
#line 18
  if (! stream) {
#line 19
    return ((aal_stream_t *)((void *)0));
  }
  {
#line 21
  aal_stream_init(stream, entity, proto);
  }
#line 22
  return (stream);
}
}
#line 25 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/stream.c"
void aal_stream_init(aal_stream_t *stream , void *entity , aal_proto_t *proto ) 
{ 


  {
#line 29
  stream->size = (uint32_t )0;
#line 30
  stream->offset = (uint32_t )0;
#line 31
  stream->proto = proto;
#line 32
  stream->entity = entity;
#line 33
  return;
}
}
#line 35 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/stream.c"
void aal_stream_fini(aal_stream_t *stream ) 
{ 


  {
#line 38
  if ((stream->proto)->fini) {
    {
#line 39
    (*((stream->proto)->fini))(stream);
    }
  }
#line 40
  return;
}
}
#line 42 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/stream.c"
void aal_stream_close(aal_stream_t *stream ) 
{ 


  {
  {
#line 45
  aal_stream_fini(stream);
#line 46
  aal_free((void *)stream);
  }
#line 47
  return;
}
}
#line 49 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/stream.c"
void aal_stream_reset(aal_stream_t *stream ) 
{ 


  {
#line 51
  stream->offset = (uint32_t )0;
#line 52
  return;
}
}
#line 54 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/stream.c"
int32_t aal_stream_write(aal_stream_t *stream , void *buff , uint32_t n ) 
{ 
  int32_t tmp ;

  {
#line 60
  if (! (stream->proto)->write) {
#line 61
    return (-22);
  }
  {
#line 63
  tmp = (*((stream->proto)->write))(stream, buff, n);
  }
#line 63
  return (tmp);
}
}
#line 66 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/stream.c"
int32_t aal_stream_read(aal_stream_t *stream , void *buff , uint32_t n ) 
{ 
  int32_t tmp ;

  {
#line 72
  if (! (stream->proto)->read) {
#line 73
    return (-22);
  }
  {
#line 75
  tmp = (*((stream->proto)->read))(stream, buff, n);
  }
#line 75
  return (tmp);
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/stream.c"
int aal_stream_eof(aal_stream_t *stream ) 
{ 
  int tmp ;

  {
  {
#line 80
  tmp = (*((stream->proto)->eof))(stream);
  }
#line 80
  return (tmp);
}
}
#line 83 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/stream.c"
int32_t aal_stream_format(aal_stream_t *stream , char const   *format  , ...) 
{ 
  uint32_t n ;
  char buff[256] ;
  va_list arg_list ;
  int tmp ;
  int32_t tmp___0 ;

  {
  {
#line 93
  __builtin_va_start(arg_list, format);
#line 95
  tmp = aal_vsnprintf(buff, (uint32_t )sizeof(buff), format, arg_list);
#line 95
  n = (uint32_t )tmp;
#line 98
  __builtin_va_end(arg_list);
#line 100
  tmp___0 = aal_stream_write(stream, (void *)(buff), n);
  }
#line 100
  return (tmp___0);
}
}
#line 104 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/stream.c"
static int32_t read_memory(aal_stream_t *stream , void *buff , uint32_t n ) 
{ 


  {
#line 107
  if (n > stream->size - stream->offset) {
#line 108
    n = stream->size - stream->offset;
  }
  {
#line 110
  aal_memcpy(buff, (void const   *)(stream->entity + stream->offset), n);
#line 113
  stream->offset += n;
  }
#line 114
  return ((int32_t )n);
}
}
#line 118 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/stream.c"
static int32_t write_memory(aal_stream_t *stream , void *buff , uint32_t n ) 
{ 
  void *tmp ;

  {
#line 122
  if ((stream->offset + n) + 1U > stream->size) {
    {
#line 123
    stream->size = (stream->size + n) + 1U;
#line 125
    tmp = realloc(stream->entity, (size_t )stream->size);
#line 125
    stream->entity = tmp;
    }
#line 125
    if (! tmp) {
#line 128
      return (-12);
    }
  }
  {
#line 133
  aal_memcpy(stream->entity + stream->offset, (void const   *)buff, n);
#line 134
  stream->offset += n;
#line 135
  *((char *)(stream->entity + stream->offset)) = (char)0;
  }
#line 137
  return ((int32_t )n);
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/stream.c"
static int eof_memory(aal_stream_t *stream ) 
{ 


  {
#line 141
  return (stream->offset >= stream->size);
}
}
#line 144 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/stream.c"
static void fini_memory(aal_stream_t *stream ) 
{ 


  {
#line 145
  if (stream->entity) {
    {
#line 146
    aal_free(stream->entity);
#line 147
    stream->entity = (void *)0;
    }
  }
#line 149
  return;
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/stream.c"
static int32_t read_file(aal_stream_t *stream , void *buff , uint32_t n ) 
{ 
  FILE *file ;
  uint32_t res ;
  uint32_t read___0 ;
  size_t tmp ;

  {
#line 158
  if (stream->entity) {
#line 158
    file = (FILE *)stream->entity;
  } else {
#line 158
    file = stdin;
  }
#line 160
  read___0 = (uint32_t )0;
  {
#line 160
  while (1) {
    while_continue: /* CIL Label */ ;
#line 160
    if (! (read___0 < n)) {
#line 160
      goto while_break;
    }
    {
#line 161
    tmp = fread((void */* __restrict  */)(buff + read___0), (size_t )1, (size_t )(n - read___0),
                (FILE */* __restrict  */)file);
#line 161
    res = (uint32_t )tmp;
    }
#line 164
    if (res < n - read___0) {
#line 165
      read___0 += res;
#line 166
      goto error_update_offset;
    }
#line 160
    read___0 += res;
  }
  while_break: /* CIL Label */ ;
  }
  error_update_offset: 
#line 171
  stream->offset += read___0;
#line 172
  return ((int32_t )read___0);
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/stream.c"
static int32_t write_file(aal_stream_t *stream , void *buff , uint32_t n ) 
{ 
  FILE *file ;
  uint32_t res ;
  uint32_t write___0 ;
  size_t tmp ;

  {
#line 182
  if (stream->entity) {
#line 182
    file = (FILE *)stream->entity;
  } else {
#line 182
    file = stdout;
  }
#line 184
  write___0 = (uint32_t )0;
  {
#line 184
  while (1) {
    while_continue: /* CIL Label */ ;
#line 184
    if (! (write___0 < n)) {
#line 184
      goto while_break;
    }
    {
#line 185
    tmp = fwrite((void const   */* __restrict  */)(buff + write___0), (size_t )1,
                 (size_t )(n - write___0), (FILE */* __restrict  */)file);
#line 185
    res = (uint32_t )tmp;
    }
#line 188
    if (res < n - write___0) {
#line 189
      write___0 += res;
#line 190
      goto error_update_offset;
    }
#line 184
    write___0 += res;
  }
  while_break: /* CIL Label */ ;
  }
  error_update_offset: 
#line 195
  stream->offset += write___0;
#line 196
  return ((int32_t )write___0);
}
}
#line 199 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/stream.c"
static int eof_file(aal_stream_t *stream ) 
{ 
  FILE *file ;
  FILE *tmp ;
  int tmp___0 ;

  {
#line 200
  if (stream->entity) {
#line 200
    tmp = (FILE *)stream->entity;
  } else {
#line 200
    tmp = stdin;
  }
  {
#line 200
  file = tmp;
#line 201
  tmp___0 = feof(file);
  }
#line 201
  return (tmp___0);
}
}
#line 204 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/stream.c"
aal_proto_t memory_stream  =    {& eof_memory, & fini_memory, & read_memory, & write_memory};
#line 211 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/stream.c"
aal_proto_t file_stream  =    {& eof_file, (void (*)(aal_stream_t * ))((void *)0), & read_file, & write_file};
#line 12 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/malloc.c"
static void (*free_handler___0)(void * )  =    (void (*)(void * ))((void *)0);
#line 13 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/malloc.c"
static void *(*malloc_handler___0)(uint32_t  )  =    (void *(*)(uint32_t  ))((void *)0);
#line 70 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/malloc.c"
static uint32_t area_len  =    (uint32_t )0;
#line 71 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/malloc.c"
static uint32_t area_free  =    (uint32_t )0;
#line 72 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/malloc.c"
static void *area_start  =    (void *)0;
#line 74 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/malloc.c"
static void __chunk_init(void *ptr , uint32_t len , chunk_state_t state , void *prev ,
                         void *next ) 
{ 


  {
#line 78
  ((chunk_t *)ptr)->len = len;
#line 79
  ((chunk_t *)ptr)->next = (chunk_t *)next;
#line 80
  ((chunk_t *)ptr)->prev = (chunk_t *)prev;
#line 81
  ((chunk_t *)ptr)->state = state;
#line 82
  return;
}
}
#line 85 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/malloc.c"
static int __chunk_fuse(chunk_t *chunk , chunk_t *right ) 
{ 


  {
#line 87
  if ((unsigned long )right == (unsigned long )area_start) {
#line 88
    return (0);
  } else
#line 87
  if ((unsigned int )right->state != 1U) {
#line 88
    return (0);
  }
#line 90
  if ((unsigned long )chunk == (unsigned long )area_start) {
#line 91
    return (0);
  } else
#line 90
  if ((unsigned int )chunk->state != 1U) {
#line 91
    return (0);
  }
#line 93
  chunk->next = right->next;
#line 94
  (right->next)->prev = chunk;
#line 96
  area_free = (uint32_t )((unsigned long )area_free + sizeof(chunk_t ));
#line 97
  chunk->len = (uint32_t )((unsigned long )chunk->len + ((unsigned long )right->len + sizeof(chunk_t )));
#line 99
  return (1);
}
}
#line 102 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/malloc.c"
static void *__chunk_split(chunk_t *chunk , uint32_t size , int forw ) 
{ 
  uint32_t s ;
  void *new ;
  int tmp ;
  uint32_t tmp___0 ;
  int tmp___1 ;
  uint32_t tmp___2 ;
  char *tmp___3 ;

  {
#line 106
  s = (uint32_t )((unsigned long )(chunk->len - size) - sizeof(chunk_t ));
#line 107
  if (forw) {
#line 107
    new = (void *)(((char *)chunk + sizeof(chunk_t )) + size);
  } else {
#line 107
    new = (void *)(((char *)chunk + sizeof(chunk_t )) + s);
  }
#line 113
  if (forw) {
#line 113
    tmp = 1;
  } else {
#line 113
    tmp = 2;
  }
#line 113
  if (forw) {
#line 113
    tmp___0 = s;
  } else {
#line 113
    tmp___0 = size;
  }
  {
#line 113
  __chunk_init(new, tmp___0, (chunk_state_t )tmp, (void *)chunk, (void *)chunk->next);
#line 117
  (chunk->next)->prev = (chunk_t *)new;
  }
#line 119
  if (forw) {
#line 119
    tmp___1 = 2;
  } else {
#line 119
    tmp___1 = 1;
  }
#line 119
  if (forw) {
#line 119
    tmp___2 = size;
  } else {
#line 119
    tmp___2 = s;
  }
  {
#line 119
  __chunk_init((void *)chunk, tmp___2, (chunk_state_t )tmp___1, (void *)chunk->prev,
               new);
#line 122
  area_free = (uint32_t )((unsigned long )area_free - ((unsigned long )size + sizeof(chunk_t )));
  }
#line 123
  if (forw) {
#line 123
    tmp___3 = (char *)chunk + sizeof(chunk_t );
  } else {
#line 123
    tmp___3 = (char *)new + sizeof(chunk_t );
  }
#line 123
  return ((void *)tmp___3);
}
}
#line 130 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/malloc.c"
static void *__chunk_alloc(uint32_t size ) 
{ 
  chunk_t *walk ;
  int forw ;
  void *tmp ;

  {
#line 131
  walk = (chunk_t *)area_start;
#line 132
  forw = 1;
#line 134
  if (size >= 4096U) {
#line 135
    forw = 0;
#line 136
    walk = walk->prev;
  }
  {
#line 140
  while (1) {
    while_continue: /* CIL Label */ ;
#line 141
    if ((unsigned int )walk->state == 1U) {
#line 142
      if ((unsigned long )walk->len >= ((unsigned long )size + sizeof(chunk_t )) + 1UL) {
        {
#line 143
        tmp = __chunk_split(walk, size, forw);
        }
#line 143
        return (tmp);
      } else
#line 144
      if (walk->len == size) {
#line 145
        walk->state = (chunk_state_t )2;
#line 146
        area_free -= walk->len;
#line 147
        return ((void *)walk + sizeof(chunk_t ));
      }
    }
#line 152
    if (forw) {
#line 152
      walk = walk->next;
    } else {
#line 152
      walk = walk->prev;
    }
#line 152
    if ((unsigned long )walk == (unsigned long )area_start) {
#line 153
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 156
  return ((void *)0);
}
}
#line 163 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/malloc.c"
static void __chunk_free(void *ptr ) 
{ 
  chunk_t *chunk ;

  {
  {
#line 164
  chunk = (chunk_t *)((unsigned long )((int )ptr) - sizeof(chunk_t ));
#line 166
  chunk->state = (chunk_state_t )1;
#line 167
  area_free += chunk->len;
#line 171
  __chunk_fuse(chunk, chunk->next);
#line 172
  __chunk_fuse(chunk->prev, chunk);
  }
#line 173
  return;
}
}
#line 9 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/hash.c"
static aal_hash_node_t *aal_hash_node_alloc___0(void *key , void *value ) 
{ 
  aal_hash_node_t *node ;
  void *tmp ;

  {
  {
#line 12
  tmp = aal_calloc((uint32_t )sizeof(*node), (char)0);
#line 12
  node = (aal_hash_node_t *)tmp;
  }
#line 12
  if (! node) {
#line 13
    return ((aal_hash_node_t *)((void *)0));
  }
#line 15
  node->key = key;
#line 16
  node->value = value;
#line 18
  return (node);
}
}
#line 22 "/home/june/repo/benchmarks/collector/temp/libaal-1.0.5/src/hash.c"
static void aal_hash_node_free___0(aal_hash_table_t *table , aal_hash_node_t *node ) 
{ 


  {
#line 25
  if (table->keyrem_func) {
    {
#line 26
    (*(table->keyrem_func))(node->key);
    }
  }
#line 28
  if (table->valrem_func) {
    {
#line 29
    (*(table->valrem_func))(node->value);
    }
  }
  {
#line 31
  aal_free((void *)node);
  }
#line 32
  return;
}
}
