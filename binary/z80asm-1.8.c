/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 58 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.h"
enum reftype {
    TYPE_BSR = 0,
    TYPE_DS = 1,
    TYPE_RST = 2,
    TYPE_ABSW = 3,
    TYPE_ABSB = 4,
    TYPE_RELB = 5,
    TYPE_LABEL = 6
} ;
#line 76
struct reference;
#line 76 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.h"
struct label {
   struct label *next ;
   struct label *prev ;
   int value ;
   int valid ;
   int busy ;
   struct reference *ref ;
   char name[1] ;
};
#line 101 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.h"
struct includedir {
   struct includedir *next ;
   char name[1] ;
};
#line 108 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.h"
struct macro_arg {
   struct macro_arg *next ;
   unsigned int pos ;
   unsigned int which ;
};
#line 115 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.h"
struct macro_line {
   struct macro_line *next ;
   char *line ;
   struct macro_arg *args ;
};
#line 122 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.h"
struct macro {
   struct macro *next ;
   char *name ;
   unsigned int numargs ;
   char **args ;
   struct macro_line *lines ;
};
#line 132 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.h"
struct stack {
   char const   *name ;
   struct includedir *dir ;
   FILE *file ;
   int line ;
   int shouldclose ;
   struct label *labels ;
   struct macro *macro ;
   struct macro_line *macro_line ;
   char **macro_args ;
};
#line 147 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.h"
struct reference {
   struct reference *next ;
   struct reference *prev ;
   enum reftype type ;
   long oseekpos ;
   long lseekpos ;
   char delimiter ;
   int addr ;
   int line ;
   int baseaddr ;
   int comma ;
   int count ;
   int infile ;
   int done ;
   int computed_value ;
   int level ;
   struct includedir *dir ;
   char *file ;
   char input[1] ;
};
#line 82 "/usr/include/wchar.h"
union __anonunion___value_3 {
   unsigned int __wch ;
   char __wchb[4] ;
};
#line 82 "/usr/include/wchar.h"
struct __anonstruct___mbstate_t_2 {
   int __count ;
   union __anonunion___value_3 __value ;
};
#line 82 "/usr/include/wchar.h"
typedef struct __anonstruct___mbstate_t_2 __mbstate_t;
#line 21 "/usr/include/_G_config.h"
struct __anonstruct__G_fpos_t_4 {
   __off_t __pos ;
   __mbstate_t __state ;
};
#line 21 "/usr/include/_G_config.h"
typedef struct __anonstruct__G_fpos_t_4 _G_fpos_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 110 "/usr/include/stdio.h"
typedef _G_fpos_t fpos_t;
#line 98 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 96 "gnulib/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 70 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.h"
enum filetype {
    FILETYPE_ASM = 0
} ;
#line 87 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.h"
struct infile {
   char const   *name ;
   enum filetype type ;
};
#line 94 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.h"
struct name {
   struct name *next ;
   struct name *prev ;
   char name[1] ;
};
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 147 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 124
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 173 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.h"
struct label *firstlabel ;
#line 194
int addr ;
#line 209
int verbose ;
#line 215
int baseaddr ;
#line 227
int sp ;
#line 228
struct stack stack[200] ;
#line 234
void printerr(int error , char const   *fmt  , ...) ;
#line 237
char const   *delspc(char const   *ptr ) ;
#line 239
int rd_expr(char const   **p , char delimiter , int *valid , int level , int print_errors ) ;
#line 241
int rd_label(char const   **p , int *exists , struct label **previous , int level ,
             int print_errors ) ;
#line 243
int rd_character(char const   **p , int *valid , int print_errors ) ;
#line 245
int compute_ref(struct reference *ref , int allow_invalid ) ;
#line 38 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/expressions.c"
static int do_rd_expr(char const   **p , char delimiter , int *valid , int level ,
                      int *check , int print_errors ) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/expressions.c"
static int rd_number(char const   **p , char const   **endp , int base ) 
{ 
  int result ;
  int i ;
  char *c ;
  char num[37] ;
  int tmp ;

  {
#line 44
  result = 0;
#line 45
  num[0] = (char )'0';
#line 45
  num[1] = (char )'1';
#line 45
  num[2] = (char )'2';
#line 45
  num[3] = (char )'3';
#line 45
  num[4] = (char )'4';
#line 45
  num[5] = (char )'5';
#line 45
  num[6] = (char )'6';
#line 45
  num[7] = (char )'7';
#line 45
  num[8] = (char )'8';
#line 45
  num[9] = (char )'9';
#line 45
  num[10] = (char )'a';
#line 45
  num[11] = (char )'b';
#line 45
  num[12] = (char )'c';
#line 45
  num[13] = (char )'d';
#line 45
  num[14] = (char )'e';
#line 45
  num[15] = (char )'f';
#line 45
  num[16] = (char )'g';
#line 45
  num[17] = (char )'h';
#line 45
  num[18] = (char )'i';
#line 45
  num[19] = (char )'j';
#line 45
  num[20] = (char )'k';
#line 45
  num[21] = (char )'l';
#line 45
  num[22] = (char )'m';
#line 45
  num[23] = (char )'n';
#line 45
  num[24] = (char )'o';
#line 45
  num[25] = (char )'p';
#line 45
  num[26] = (char )'q';
#line 45
  num[27] = (char )'r';
#line 45
  num[28] = (char )'s';
#line 45
  num[29] = (char )'t';
#line 45
  num[30] = (char )'u';
#line 45
  num[31] = (char )'v';
#line 45
  num[32] = (char )'w';
#line 45
  num[33] = (char )'x';
#line 45
  num[34] = (char )'y';
#line 45
  num[35] = (char )'z';
#line 45
  num[36] = (char )'\000';
#line 46
  if (verbose >= 6) {
    {
#line 47
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%5d (0x%04x): Starting to read number of base %d(string=%s).\n",
            stack[sp].line, addr, base, *p);
    }
  }
  {
#line 49
  num[base] = (char )'\000';
#line 50
  *p = delspc(*p);
  }
  {
#line 51
  while (1) {
    while_continue: /* CIL Label */ ;
#line 51
    if (*(*p)) {
      {
#line 51
      tmp = tolower((int )*(*p));
#line 51
      c = strchr((char const   *)(num), tmp);
      }
#line 51
      if (! c) {
#line 51
        goto while_break;
      }
    } else {
#line 51
      goto while_break;
    }
#line 53
    i = (int )(c - num);
#line 54
    if (verbose >= 7) {
      {
#line 55
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%5d (0x%04x): Digit found:%1x.\n",
              stack[sp].line, addr, i);
      }
    }
#line 57
    result = result * base + i;
#line 58
    (*p) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 60
  if (endp) {
#line 61
    *endp = *p;
  }
  {
#line 62
  *p = delspc(*p);
  }
#line 63
  if (verbose >= 7) {
    {
#line 64
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%5d (0x%04x): rd_number returned %d (%04x).\n",
            stack[sp].line, addr, result, result);
    }
  }
#line 66
  return (result);
}
}
#line 69 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/expressions.c"
static int rd_otherbasenumber(char const   **p , int *valid , int print_errors ) 
{ 
  char c ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;

  {
#line 73
  if (verbose >= 6) {
    {
#line 74
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%5d (0x%04x): Starting to read basenumber (string=%s).\n",
            stack[sp].line, addr, *p);
    }
  }
#line 77
  (*p) ++;
#line 78
  if (! *(*p)) {
#line 80
    if (valid) {
#line 81
      *valid = 0;
    } else
#line 82
    if (print_errors) {
      {
#line 83
      printerr(1, "unexpected end of line after `@\'\n");
      }
    }
#line 84
    return (0);
  }
#line 86
  if ((int const   )*(*p) == 48) {
#line 86
    goto _L;
  } else {
    {
#line 86
    tmp = __ctype_b_loc();
    }
#line 86
    if (! ((int const   )*(*tmp + (int )*(*p)) & 8)) {
      _L: /* CIL Label */ 
#line 88
      if (valid) {
#line 89
        *valid = 0;
      } else
#line 90
      if (print_errors) {
        {
#line 91
        printerr(1, "base must be between 1 and z\n");
        }
      }
#line 92
      return (0);
    }
  }
  {
#line 94
  c = (char )*(*p);
#line 95
  (*p) ++;
#line 96
  tmp___2 = __ctype_b_loc();
  }
#line 96
  if ((int const   )*(*tmp___2 + (int )*(*p)) & 1024) {
    {
#line 97
    tmp___0 = tolower((int )c);
#line 97
    tmp___1 = rd_number(p, (char const   **)((void *)0), (tmp___0 - 97) + 1);
    }
#line 97
    return (tmp___1);
  }
  {
#line 98
  tmp___3 = rd_number(p, (char const   **)((void *)0), ((int )c - 48) + 1);
  }
#line 98
  return (tmp___3);
}
}
#line 101 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/expressions.c"
int rd_character(char const   **p , int *valid , int print_errors ) 
{ 
  int i ;
  int b ;
  int num_digits ;
  int bit ;

  {
#line 105
  if (verbose >= 6) {
    {
#line 106
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%5d (0x%04x): Starting to read character (string=%s).\n",
            stack[sp].line, addr, *p);
    }
  }
#line 109
  i = (int )*(*p);
#line 110
  if (! i) {
#line 112
    if (valid) {
#line 113
      *valid = 0;
    } else
#line 114
    if (print_errors) {
      {
#line 115
      printerr(1, "unexpected end of line in string constant\n");
      }
    }
#line 116
    return (0);
  }
#line 118
  if (i == 92) {
#line 120
    (*p) ++;
#line 121
    if ((int const   )*(*p) >= 48) {
#line 121
      if ((int const   )*(*p) <= 55) {
#line 124
        i = 0;
#line 125
        if ((int const   )*(*p + 1) >= 48) {
#line 125
          if ((int const   )*(*p + 1) <= 55) {
#line 127
            if ((int const   )*(*p) <= 51) {
#line 127
              if ((int const   )*(*p + 2) >= 48) {
#line 127
                if ((int const   )*(*p + 2) <= 55) {
#line 128
                  num_digits = 3;
                } else {
#line 130
                  num_digits = 2;
                }
              } else {
#line 130
                num_digits = 2;
              }
            } else {
#line 130
              num_digits = 2;
            }
          } else {
#line 133
            num_digits = 1;
          }
        } else {
#line 133
          num_digits = 1;
        }
#line 134
        b = 0;
        {
#line 134
        while (1) {
          while_continue: /* CIL Label */ ;
#line 134
          if (! (b < num_digits)) {
#line 134
            goto while_break;
          }
#line 136
          bit = (int )((int const   )*(*p + ((num_digits - 1) - b)) - 48);
#line 137
          i += (1 << b * 3) * bit;
#line 134
          b ++;
        }
        while_break: /* CIL Label */ ;
        }
#line 139
        *p += num_digits;
      } else {
#line 121
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 145
      if ((int const   )*(*p) == 110) {
#line 145
        goto case_110;
      }
#line 148
      if ((int const   )*(*p) == 114) {
#line 148
        goto case_114;
      }
#line 151
      if ((int const   )*(*p) == 116) {
#line 151
        goto case_116;
      }
#line 154
      if ((int const   )*(*p) == 97) {
#line 154
        goto case_97;
      }
#line 157
      if ((int const   )*(*p) == 39) {
#line 157
        goto case_39;
      }
#line 163
      if ((int const   )*(*p) == 0) {
#line 163
        goto case_0;
      }
#line 170
      goto switch_default;
      case_110: /* CIL Label */ 
#line 146
      i = 10;
#line 147
      goto switch_break;
      case_114: /* CIL Label */ 
#line 149
      i = 13;
#line 150
      goto switch_break;
      case_116: /* CIL Label */ 
#line 152
      i = 9;
#line 153
      goto switch_break;
      case_97: /* CIL Label */ 
#line 155
      i = 7;
#line 156
      goto switch_break;
      case_39: /* CIL Label */ 
#line 158
      if (valid) {
#line 159
        *valid = 0;
      } else
#line 160
      if (print_errors) {
        {
#line 161
        printerr(1, "empty literal character\n");
        }
      }
#line 162
      return (0);
      case_0: /* CIL Label */ 
#line 164
      if (valid) {
#line 165
        *valid = 0;
      } else
#line 166
      if (print_errors) {
        {
#line 167
        printerr(1, "unexpected end of line after backslash in string constant\n");
        }
      }
#line 169
      return (0);
      switch_default: /* CIL Label */ 
#line 171
      i = (int )*(*p);
      switch_break: /* CIL Label */ ;
      }
#line 173
      (*p) ++;
    }
  } else {
#line 177
    (*p) ++;
  }
#line 178
  if (verbose >= 7) {
    {
#line 179
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%5d (0x%04x): rd_character returned %d (%c).\n",
            stack[sp].line, addr, i, i);
    }
  }
#line 181
  return (i);
}
}
#line 184 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/expressions.c"
static int check_label(struct label *labels , char const   **p , struct label **ret ,
                       struct label **previous , int force_skip ) 
{ 
  struct label *l ;
  char const   *c ;
  unsigned int s2 ;
  unsigned short const   **tmp ;
  unsigned int s1 ;
  unsigned int s ;
  int cmp ;
  size_t tmp___0 ;

  {
  {
#line 191
  *p = delspc(*p);
#line 192
  c = *p;
  }
  {
#line 192
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 192
    tmp = __ctype_b_loc();
    }
#line 192
    if (! ((int const   )*(*tmp + (int )*c) & 8)) {
#line 192
      if (! ((int const   )*c == 95)) {
#line 192
        if (! ((int const   )*c == 46)) {
#line 192
          goto while_break;
        }
      }
    }
#line 192
    c ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 195
  s2 = (unsigned int )(c - *p);
#line 196
  l = labels;
  {
#line 196
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 196
    if (! l) {
#line 196
      goto while_break___0;
    }
    {
#line 200
    tmp___0 = strlen((char const   *)(l->name));
#line 200
    s1 = (unsigned int )tmp___0;
    }
#line 201
    if (s1 < s2) {
#line 201
      s = s1;
    } else {
#line 201
      s = s2;
    }
    {
#line 202
    cmp = strncmp((char const   *)(l->name), *p, (size_t )s);
    }
#line 203
    if (cmp > 0) {
#line 203
      goto _L;
    } else
#line 203
    if (cmp == 0) {
#line 203
      if (s1 > s) {
        _L: /* CIL Label */ 
#line 205
        if (force_skip) {
#line 206
          *p = c;
        }
#line 207
        return (0);
      }
    }
#line 209
    if (cmp < 0) {
#line 209
      goto _L___0;
    } else
#line 209
    if (s2 > s) {
      _L___0: /* CIL Label */ 
#line 211
      if (previous) {
#line 212
        *previous = l;
      }
#line 213
      goto __Cont;
    }
#line 215
    *p = c;
#line 217
    if (l->ref) {
      {
#line 219
      compute_ref(l->ref, 1);
      }
#line 220
      if (! (l->ref)->done) {
#line 225
        if (verbose >= 6) {
          {
#line 226
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%5d (0x%04x): returning invalid label %s.\n",
                  stack[sp].line, addr, l->name);
          }
        }
#line 229
        *ret = l;
#line 230
        return (0);
      }
    }
#line 233
    *ret = l;
#line 234
    return (1);
    __Cont: /* CIL Label */ 
#line 196
    l = l->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 236
  if (force_skip) {
#line 237
    *p = c;
  }
#line 238
  return (0);
}
}
#line 241 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/expressions.c"
int rd_label(char const   **p , int *exists , struct label **previous , int level ,
             int print_errors ) 
{ 
  struct label *l ;
  int s ;
  struct label **tmp ;
  int tmp___0 ;
  char const   *old_p ;
  struct label **tmp___1 ;
  int tmp___2 ;

  {
#line 245
  l = (struct label *)((void *)0);
#line 247
  if (exists) {
#line 248
    *exists = 0;
  }
#line 249
  if (previous) {
#line 250
    *previous = (struct label *)((void *)0);
  }
#line 251
  if (verbose >= 6) {
    {
#line 252
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%5d (0x%04x): Starting to read label (string=%s).\n",
            stack[sp].line, addr, *p);
    }
  }
#line 254
  s = level;
  {
#line 254
  while (1) {
    while_continue: /* CIL Label */ ;
#line 254
    if (! (s >= 0)) {
#line 254
      goto while_break;
    }
#line 256
    if ((int const   )*(*p) == 46) {
#line 256
      if (s == sp) {
#line 256
        tmp = previous;
      } else {
#line 256
        tmp = (struct label **)((void *)0);
      }
    } else {
#line 256
      tmp = (struct label **)((void *)0);
    }
    {
#line 256
    tmp___0 = check_label(stack[s].labels, p, & l, tmp, 0);
    }
#line 256
    if (tmp___0) {
#line 258
      goto while_break;
    }
#line 254
    s --;
  }
  while_break: /* CIL Label */ ;
  }
#line 260
  if (s < 0) {
#line 263
    old_p = *p;
#line 264
    if ((int const   )*(*p) != 46) {
#line 264
      tmp___1 = previous;
    } else {
#line 264
      tmp___1 = (struct label **)((void *)0);
    }
    {
#line 264
    tmp___2 = check_label(firstlabel, p, & l, tmp___1, 1);
    }
#line 264
    if (! tmp___2) {
#line 268
      if (! exists) {
#line 268
        if (print_errors) {
          {
#line 269
          printerr(1, "using undefined label %.*s\n", *p - old_p, old_p);
          }
        }
      }
#line 271
      if (verbose >= 7) {
        {
#line 272
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"rd_label returns invalid value\n");
        }
      }
#line 273
      return ((unsigned long )l != (unsigned long )((void *)0));
    }
  }
#line 276
  if (exists) {
#line 277
    *exists = 1;
  }
#line 278
  if (verbose >= 7) {
    {
#line 279
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"rd_label returns valid value 0x%x\n",
            l->value);
    }
  }
#line 280
  return (l->value);
}
}
#line 283 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/expressions.c"
static int rd_value(char const   **p , int *valid , int level , int *check , int print_errors ) 
{ 
  int sign ;
  int not ;
  int base ;
  int v ;
  char const   *p0 ;
  char const   *p1 ;
  char const   *p2 ;
  char *tmp ;
  int exist ;
  int retval ;
  char quote ;
  int dummy_check ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int value ;
  int *tmp___6 ;

  {
#line 286
  sign = 1;
#line 286
  not = 0;
#line 288
  if (verbose >= 6) {
    {
#line 289
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%5d (0x%04x): Starting to read value (string=%s).\n",
            stack[sp].line, addr, *p);
    }
  }
  {
#line 291
  *p = delspc(*p);
  }
  {
#line 292
  while (1) {
    while_continue: /* CIL Label */ ;
#line 292
    if (*(*p)) {
      {
#line 292
      tmp = strchr("+-~", (int )*(*p));
      }
#line 292
      if (! tmp) {
#line 292
        goto while_break;
      }
    } else {
#line 292
      goto while_break;
    }
#line 294
    if ((int const   )*(*p) == 45) {
#line 295
      sign = - sign;
    } else
#line 296
    if ((int const   )*(*p) == 126) {
#line 297
      not = ~ not;
    }
    {
#line 298
    (*p) ++;
#line 299
    *p = delspc(*p);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 301
  base = 10;
#line 304
  if ((int const   )*(*p) != 40) {
#line 305
    *check = 0;
  }
  {
#line 312
  if ((int const   )*(*p) == 40) {
#line 312
    goto case_40;
  }
#line 319
  if ((int const   )*(*p) == 48) {
#line 319
    goto case_48;
  }
#line 335
  if ((int const   )*(*p) == 57) {
#line 335
    goto case_57;
  }
#line 335
  if ((int const   )*(*p) == 56) {
#line 335
    goto case_57;
  }
#line 335
  if ((int const   )*(*p) == 55) {
#line 335
    goto case_57;
  }
#line 335
  if ((int const   )*(*p) == 54) {
#line 335
    goto case_57;
  }
#line 335
  if ((int const   )*(*p) == 53) {
#line 335
    goto case_57;
  }
#line 335
  if ((int const   )*(*p) == 52) {
#line 335
    goto case_57;
  }
#line 335
  if ((int const   )*(*p) == 51) {
#line 335
    goto case_57;
  }
#line 335
  if ((int const   )*(*p) == 50) {
#line 335
    goto case_57;
  }
#line 335
  if ((int const   )*(*p) == 49) {
#line 335
    goto case_57;
  }
#line 372
  if ((int const   )*(*p) == 36) {
#line 372
    goto case_36;
  }
#line 384
  if ((int const   )*(*p) == 37) {
#line 384
    goto case_37;
  }
#line 388
  if ((int const   )*(*p) == 34) {
#line 388
    goto case_34;
  }
#line 388
  if ((int const   )*(*p) == 39) {
#line 388
    goto case_34;
  }
#line 402
  if ((int const   )*(*p) == 64) {
#line 402
    goto case_64;
  }
#line 404
  if ((int const   )*(*p) == 63) {
#line 404
    goto case_63;
  }
#line 407
  if ((int const   )*(*p) == 38) {
#line 407
    goto case_38;
  }
#line 434
  goto switch_default___1;
  case_40: /* CIL Label */ 
  {
#line 313
  (*p) ++;
#line 314
  dummy_check = 0;
#line 315
  tmp___0 = do_rd_expr(p, (char )')', valid, level, & dummy_check, print_errors);
#line 315
  retval = not ^ sign * tmp___0;
#line 317
  (*p) ++;
  }
#line 318
  return (retval);
  case_48: /* CIL Label */ 
#line 320
  if ((int const   )*(*p + 1) == 120) {
    {
#line 322
    *p += 2;
#line 323
    tmp___1 = rd_number(p, (char const   **)((void *)0), 16);
    }
#line 323
    return (not ^ sign * tmp___1);
  }
#line 325
  base = 8;
  case_57: /* CIL Label */ 
  case_56: /* CIL Label */ 
  case_55: /* CIL Label */ 
  case_54: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_52: /* CIL Label */ 
  case_51: /* CIL Label */ 
  case_50: /* CIL Label */ 
  case_49: /* CIL Label */ 
  {
#line 336
  p0 = *p;
#line 337
  rd_number(p, & p1, 36);
#line 338
  p1 --;
  }
  {
#line 342
  if ((int const   )*p1 == 72) {
#line 342
    goto case_72;
  }
#line 342
  if ((int const   )*p1 == 104) {
#line 342
    goto case_72;
  }
#line 346
  if ((int const   )*p1 == 66) {
#line 346
    goto case_66;
  }
#line 346
  if ((int const   )*p1 == 98) {
#line 346
    goto case_66;
  }
#line 352
  if ((int const   )*p1 == 81) {
#line 352
    goto case_81;
  }
#line 352
  if ((int const   )*p1 == 113) {
#line 352
    goto case_81;
  }
#line 352
  if ((int const   )*p1 == 79) {
#line 352
    goto case_81;
  }
#line 352
  if ((int const   )*p1 == 111) {
#line 352
    goto case_81;
  }
#line 356
  if ((int const   )*p1 == 68) {
#line 356
    goto case_68;
  }
#line 356
  if ((int const   )*p1 == 100) {
#line 356
    goto case_68;
  }
#line 359
  goto switch_default;
  case_72: /* CIL Label */ 
  case_104: /* CIL Label */ 
#line 343
  base = 16;
#line 344
  goto switch_break___0;
  case_66: /* CIL Label */ 
  case_98: /* CIL Label */ 
#line 347
  base = 2;
#line 348
  goto switch_break___0;
  case_81: /* CIL Label */ 
  case_113: /* CIL Label */ 
  case_79: /* CIL Label */ 
  case_111: /* CIL Label */ 
#line 353
  base = 8;
#line 354
  goto switch_break___0;
  case_68: /* CIL Label */ 
  case_100: /* CIL Label */ 
#line 357
  base = 10;
#line 358
  goto switch_break___0;
  switch_default: /* CIL Label */ 
#line 360
  p1 ++;
#line 361
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 363
  v = rd_number(& p0, & p2, base);
  }
#line 364
  if ((unsigned long )p1 != (unsigned long )p2) {
#line 366
    if (valid) {
#line 367
      *valid = 0;
    } else
#line 368
    if (print_errors) {
      {
#line 369
      printerr(1, "invalid character in number: \'%c\'\n", (int const   )*p2);
      }
    }
  }
#line 371
  return (not ^ sign * v);
  case_36: /* CIL Label */ 
  {
#line 373
  (*p) ++;
#line 374
  *p = delspc(*p);
#line 375
  p0 = *p;
#line 376
  v = rd_number(& p0, & p2, 16);
  }
#line 377
  if ((unsigned long )p2 == (unsigned long )*p) {
#line 379
    v = baseaddr;
  } else {
#line 382
    *p = p2;
  }
#line 383
  return (not ^ sign * v);
  case_37: /* CIL Label */ 
  {
#line 385
  (*p) ++;
#line 386
  tmp___2 = rd_number(p, (char const   **)((void *)0), 2);
  }
#line 386
  return (not ^ sign * tmp___2);
  case_34: /* CIL Label */ 
  case_39: /* CIL Label */ 
  {
#line 389
  quote = (char )*(*p);
#line 390
  (*p) ++;
#line 391
  tmp___3 = rd_character(p, valid, print_errors);
#line 391
  retval = not ^ sign * tmp___3;
  }
#line 392
  if ((int const   )*(*p) != (int const   )quote) {
#line 394
    if (valid) {
#line 395
      *valid = 0;
    } else
#line 396
    if (print_errors) {
      {
#line 397
      printerr(1, "missing closing quote (%c)\n", (int )quote);
      }
    }
#line 398
    return (0);
  }
#line 400
  (*p) ++;
#line 401
  return (retval);
  case_64: /* CIL Label */ 
  {
#line 403
  tmp___4 = rd_otherbasenumber(p, valid, print_errors);
  }
#line 403
  return (not ^ sign * tmp___4);
  case_63: /* CIL Label */ 
  {
#line 405
  rd_label(p, & exist, (struct label **)((void *)0), level, 0);
  }
#line 406
  return (not ^ sign * exist);
  case_38: /* CIL Label */ 
#line 409
  (*p) ++;
  {
#line 413
  if ((int const   )*(*p) == 72) {
#line 413
    goto case_72___0;
  }
#line 413
  if ((int const   )*(*p) == 104) {
#line 413
    goto case_72___0;
  }
#line 417
  if ((int const   )*(*p) == 79) {
#line 417
    goto case_79___0;
  }
#line 417
  if ((int const   )*(*p) == 111) {
#line 417
    goto case_79___0;
  }
#line 421
  if ((int const   )*(*p) == 66) {
#line 421
    goto case_66___0;
  }
#line 421
  if ((int const   )*(*p) == 98) {
#line 421
    goto case_66___0;
  }
#line 424
  goto switch_default___0;
  case_72___0: /* CIL Label */ 
  case_104___0: /* CIL Label */ 
#line 414
  base = 16;
#line 415
  goto switch_break___1;
  case_79___0: /* CIL Label */ 
  case_111___0: /* CIL Label */ 
#line 418
  base = 8;
#line 419
  goto switch_break___1;
  case_66___0: /* CIL Label */ 
  case_98___0: /* CIL Label */ 
#line 422
  base = 2;
#line 423
  goto switch_break___1;
  switch_default___0: /* CIL Label */ 
#line 425
  if (valid) {
#line 426
    *valid = 0;
  } else
#line 427
  if (print_errors) {
    {
#line 428
    printerr(1, "invalid literal starting with &%c\n", (int const   )*(*p));
    }
  }
#line 429
  return (0);
  switch_break___1: /* CIL Label */ ;
  }
  {
#line 431
  (*p) ++;
#line 432
  tmp___5 = rd_number(p, (char const   **)((void *)0), base);
  }
#line 432
  return (not ^ sign * tmp___5);
  switch_default___1: /* CIL Label */ 
#line 437
  exist = 1;
#line 438
  if (valid) {
#line 438
    tmp___6 = & exist;
  } else {
#line 438
    tmp___6 = (int *)((void *)0);
  }
  {
#line 438
  value = rd_label(p, tmp___6, (struct label **)((void *)0), level, print_errors);
  }
#line 439
  if (! exist) {
#line 440
    *valid = 0;
  }
#line 441
  return (not ^ sign * value);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 446 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/expressions.c"
static int rd_factor(char const   **p , int *valid , int level , int *check , int print_errors ) 
{ 
  int result ;
  int tmp ;
  int tmp___0 ;

  {
#line 451
  if (verbose >= 6) {
    {
#line 452
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%5d (0x%04x): Starting to read factor (string=%s).\n",
            stack[sp].line, addr, *p);
    }
  }
  {
#line 454
  result = rd_value(p, valid, level, check, print_errors);
#line 455
  *p = delspc(*p);
  }
  {
#line 456
  while (1) {
    while_continue: /* CIL Label */ ;
#line 456
    if (! ((int const   )*(*p) == 42)) {
#line 456
      if (! ((int const   )*(*p) == 47)) {
#line 456
        goto while_break;
      }
    }
#line 458
    *check = 0;
#line 459
    if ((int const   )*(*p) == 42) {
      {
#line 461
      (*p) ++;
#line 462
      tmp = rd_value(p, valid, level, check, print_errors);
#line 462
      result *= tmp;
      }
    } else
#line 464
    if ((int const   )*(*p) == 47) {
      {
#line 466
      (*p) ++;
#line 467
      tmp___0 = rd_value(p, valid, level, check, print_errors);
#line 467
      result /= tmp___0;
      }
    }
    {
#line 469
    *p = delspc(*p);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 471
  if (verbose >= 7) {
    {
#line 472
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%5d (0x%04x): rd_factor returned %d (%04x).\n",
            stack[sp].line, addr, result, result);
    }
  }
#line 474
  return (result);
}
}
#line 477 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/expressions.c"
static int rd_term(char const   **p , int *valid , int level , int *check , int print_errors ) 
{ 
  int result ;
  int tmp ;
  int tmp___0 ;

  {
#line 482
  if (verbose >= 6) {
    {
#line 483
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%5d (0x%04x): Starting to read term (string=%s).\n",
            stack[sp].line, addr, *p);
    }
  }
  {
#line 485
  result = rd_factor(p, valid, level, check, print_errors);
#line 486
  *p = delspc(*p);
  }
  {
#line 487
  while (1) {
    while_continue: /* CIL Label */ ;
#line 487
    if (! ((int const   )*(*p) == 43)) {
#line 487
      if (! ((int const   )*(*p) == 45)) {
#line 487
        goto while_break;
      }
    }
#line 489
    *check = 0;
#line 490
    if ((int const   )*(*p) == 43) {
      {
#line 492
      (*p) ++;
#line 493
      tmp = rd_factor(p, valid, level, check, print_errors);
#line 493
      result += tmp;
      }
    } else
#line 495
    if ((int const   )*(*p) == 45) {
      {
#line 497
      (*p) ++;
#line 498
      tmp___0 = rd_factor(p, valid, level, check, print_errors);
#line 498
      result -= tmp___0;
      }
    }
    {
#line 500
    *p = delspc(*p);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 502
  if (verbose >= 7) {
    {
#line 503
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%5d (0x%04x): rd_term returned %d (%04x).\n",
            stack[sp].line, addr, result, result);
    }
  }
#line 505
  return (result);
}
}
#line 508 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/expressions.c"
static int rd_expr_shift(char const   **p , int *valid , int level , int *check ,
                         int print_errors ) 
{ 
  int result ;
  int tmp ;
  int tmp___0 ;

  {
#line 513
  if (verbose >= 6) {
    {
#line 514
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%5d (0x%04x): Starting to read shift expression (string=%s).\n",
            stack[sp].line, addr, *p);
    }
  }
  {
#line 516
  result = rd_term(p, valid, level, check, print_errors);
#line 517
  *p = delspc(*p);
  }
  {
#line 518
  while (1) {
    while_continue: /* CIL Label */ ;
#line 518
    if ((int const   )*(*p) == 60) {
#line 518
      goto _L;
    } else
#line 518
    if ((int const   )*(*p) == 62) {
      _L: /* CIL Label */ 
#line 518
      if (! ((int const   )*(*p + 1) == (int const   )*(*p))) {
#line 518
        goto while_break;
      }
    } else {
#line 518
      goto while_break;
    }
#line 520
    *check = 0;
#line 521
    if ((int const   )*(*p) == 60) {
      {
#line 523
      *p += 2;
#line 524
      tmp = rd_term(p, valid, level, check, print_errors);
#line 524
      result <<= tmp;
      }
    } else
#line 526
    if ((int const   )*(*p) == 62) {
      {
#line 528
      *p += 2;
#line 529
      tmp___0 = rd_term(p, valid, level, check, print_errors);
#line 529
      result >>= tmp___0;
      }
    }
    {
#line 531
    *p = delspc(*p);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 533
  if (verbose >= 7) {
    {
#line 534
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%5d (0x%04x): rd_shift returned %d (%04x).\n",
            stack[sp].line, addr, result, result);
    }
  }
#line 536
  return (result);
}
}
#line 539 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/expressions.c"
static int rd_expr_unequal(char const   **p , int *valid , int level , int *check ,
                           int print_errors ) 
{ 
  int result ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 544
  if (verbose >= 6) {
    {
#line 545
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%5d (0x%04x): Starting to read unequality expression (string=%s).\n",
            stack[sp].line, addr, *p);
    }
  }
  {
#line 548
  result = rd_expr_shift(p, valid, level, check, print_errors);
#line 549
  *p = delspc(*p);
  }
#line 550
  if ((int const   )*(*p) == 60) {
#line 550
    if ((int const   )*(*p + 1) == 61) {
      {
#line 552
      *check = 0;
#line 553
      *p += 2;
#line 554
      tmp = rd_expr_unequal(p, valid, level, check, print_errors);
      }
#line 554
      return (result <= tmp);
    } else {
#line 550
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 556
  if ((int const   )*(*p) == 62) {
#line 556
    if ((int const   )*(*p + 1) == 61) {
      {
#line 558
      *check = 0;
#line 559
      *p += 2;
#line 560
      tmp___0 = rd_expr_unequal(p, valid, level, check, print_errors);
      }
#line 560
      return (result >= tmp___0);
    }
  }
#line 562
  if ((int const   )*(*p) == 60) {
#line 562
    if ((int const   )*(*p + 1) != 60) {
      {
#line 564
      *check = 0;
#line 565
      (*p) ++;
#line 566
      tmp___1 = rd_expr_unequal(p, valid, level, check, print_errors);
      }
#line 566
      return (result < tmp___1);
    } else {
#line 562
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 568
  if ((int const   )*(*p) == 62) {
#line 568
    if ((int const   )*(*p + 1) != 62) {
      {
#line 570
      *check = 0;
#line 571
      (*p) ++;
#line 572
      tmp___2 = rd_expr_unequal(p, valid, level, check, print_errors);
      }
#line 572
      return (result > tmp___2);
    }
  }
#line 574
  if (verbose >= 7) {
    {
#line 575
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%5d (0x%04x): rd_shift returned %d (%04x).\n",
            stack[sp].line, addr, result, result);
    }
  }
#line 577
  return (result);
}
}
#line 580 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/expressions.c"
static int rd_expr_equal(char const   **p , int *valid , int level , int *check ,
                         int print_errors ) 
{ 
  int result ;
  int tmp ;
  int tmp___0 ;

  {
#line 585
  if (verbose >= 6) {
    {
#line 586
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%5d (0x%04x): Starting to read equality epression (string=%s).\n",
            stack[sp].line, addr, *p);
    }
  }
  {
#line 588
  result = rd_expr_unequal(p, valid, level, check, print_errors);
#line 589
  *p = delspc(*p);
  }
#line 590
  if ((int const   )*(*p) == 61) {
#line 592
    *check = 0;
#line 593
    (*p) ++;
#line 594
    if ((int const   )*(*p) == 61) {
#line 595
      (*p) ++;
    }
    {
#line 596
    tmp = rd_expr_equal(p, valid, level, check, print_errors);
    }
#line 596
    return (result == tmp);
  } else
#line 598
  if ((int const   )*(*p) == 33) {
#line 598
    if ((int const   )*(*p + 1) == 61) {
      {
#line 600
      *check = 0;
#line 601
      *p += 2;
#line 602
      tmp___0 = rd_expr_equal(p, valid, level, check, print_errors);
      }
#line 602
      return (result != tmp___0);
    }
  }
#line 604
  if (verbose >= 7) {
    {
#line 605
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%5d (0x%04x): rd_equal returned %d (%04x).\n",
            stack[sp].line, addr, result, result);
    }
  }
#line 607
  return (result);
}
}
#line 610 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/expressions.c"
static int rd_expr_and(char const   **p , int *valid , int level , int *check , int print_errors ) 
{ 
  int result ;
  int tmp ;

  {
#line 615
  if (verbose >= 6) {
    {
#line 616
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%5d (0x%04x): Starting to read and expression (string=%s).\n",
            stack[sp].line, addr, *p);
    }
  }
  {
#line 618
  result = rd_expr_equal(p, valid, level, check, print_errors);
#line 619
  *p = delspc(*p);
  }
#line 620
  if ((int const   )*(*p) == 38) {
    {
#line 622
    *check = 0;
#line 623
    (*p) ++;
#line 624
    tmp = rd_expr_and(p, valid, level, check, print_errors);
#line 624
    result &= tmp;
    }
  }
#line 626
  if (verbose >= 7) {
    {
#line 627
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%5d (0x%04x): rd_expr_and returned %d (%04x).\n",
            stack[sp].line, addr, result, result);
    }
  }
#line 629
  return (result);
}
}
#line 632 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/expressions.c"
static int rd_expr_xor(char const   **p , int *valid , int level , int *check , int print_errors ) 
{ 
  int result ;
  int tmp ;

  {
#line 637
  if (verbose >= 6) {
    {
#line 638
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%5d (0x%04x): Starting to read xor expression (string=%s).\n",
            stack[sp].line, addr, *p);
    }
  }
  {
#line 640
  result = rd_expr_and(p, valid, level, check, print_errors);
  }
#line 641
  if (verbose >= 7) {
    {
#line 642
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%5d (0x%04x): rd_expr_xor: rd_expr_and returned %d (%04x).\n",
            stack[sp].line, addr, result, result);
    }
  }
  {
#line 644
  *p = delspc(*p);
  }
#line 645
  if ((int const   )*(*p) == 94) {
    {
#line 647
    *check = 0;
#line 648
    (*p) ++;
#line 649
    tmp = rd_expr_xor(p, valid, level, check, print_errors);
#line 649
    result ^= tmp;
    }
  }
#line 651
  if (verbose >= 7) {
    {
#line 652
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%5d (0x%04x): rd_expr_xor returned %d (%04x).\n",
            stack[sp].line, addr, result, result);
    }
  }
#line 654
  return (result);
}
}
#line 657 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/expressions.c"
static int rd_expr_or(char const   **p , int *valid , int level , int *check , int print_errors ) 
{ 
  int result ;
  int tmp ;

  {
#line 662
  if (verbose >= 6) {
    {
#line 663
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%5d (0x%04x): Starting to read or expression (string=%s).\n",
            stack[sp].line, addr, *p);
    }
  }
  {
#line 665
  result = rd_expr_xor(p, valid, level, check, print_errors);
  }
#line 666
  if (verbose >= 7) {
    {
#line 667
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%5d (0x%04x): rd_expr_or: rd_expr_xor returned %d (%04x).\n",
            stack[sp].line, addr, result, result);
    }
  }
  {
#line 669
  *p = delspc(*p);
  }
#line 670
  if ((int const   )*(*p) == 124) {
    {
#line 672
    *check = 0;
#line 673
    (*p) ++;
#line 674
    tmp = rd_expr_or(p, valid, level, check, print_errors);
#line 674
    result |= tmp;
    }
  }
#line 676
  if (verbose >= 7) {
    {
#line 677
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%5d (0x%04x): rd_expr_or returned %d (%04x).\n",
            stack[sp].line, addr, result, result);
    }
  }
#line 679
  return (result);
}
}
#line 682 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/expressions.c"
static int do_rd_expr(char const   **p , char delimiter , int *valid , int level ,
                      int *check , int print_errors ) 
{ 
  int result ;
  int tmp ;

  {
#line 687
  result = 0;
#line 688
  if (verbose >= 6) {
#line 689
    if (delimiter) {
#line 689
      tmp = (int )delimiter;
    } else {
#line 689
      tmp = ' ';
    }
    {
#line 689
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%5d (0x%04x): Starting to read expression (string=%s, delimiter=%c).\n",
            stack[sp].line, addr, *p, tmp);
    }
  }
  {
#line 693
  *p = delspc(*p);
  }
#line 694
  if (! *(*p)) {
#line 694
    goto _L;
  } else
#line 694
  if ((int const   )*(*p) == (int const   )delimiter) {
    _L: /* CIL Label */ 
#line 696
    if (valid) {
#line 697
      *valid = 0;
    } else
#line 698
    if (print_errors) {
      {
#line 699
      printerr(1, "expression expected (not %s)\n", *p);
      }
    }
#line 700
    return (0);
  }
  {
#line 702
  result = rd_expr_or(p, valid, level, check, print_errors);
#line 703
  *p = delspc(*p);
  }
#line 704
  if ((int const   )*(*p) == 63) {
#line 706
    *check = 0;
#line 707
    (*p) ++;
#line 708
    if (result) {
      {
#line 710
      result = do_rd_expr(p, (char )':', valid, level, check, print_errors);
      }
#line 711
      if (*(*p)) {
#line 712
        (*p) ++;
      }
      {
#line 713
      do_rd_expr(p, delimiter, valid, level, check, print_errors);
      }
    } else {
      {
#line 717
      do_rd_expr(p, (char )':', valid, level, check, print_errors);
      }
#line 718
      if (*(*p)) {
#line 719
        (*p) ++;
      }
      {
#line 720
      result = do_rd_expr(p, delimiter, valid, level, check, print_errors);
      }
    }
  }
  {
#line 724
  *p = delspc(*p);
  }
#line 725
  if (*(*p)) {
#line 725
    if ((int const   )*(*p) != (int const   )delimiter) {
#line 727
      if (valid) {
#line 728
        *valid = 0;
      } else
#line 729
      if (print_errors) {
        {
#line 730
        printerr(1, "junk at end of expression: %s\n", *p);
        }
      }
    }
  }
#line 732
  if (verbose >= 7) {
    {
#line 734
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%5d (0x%04x): rd_expr returned %d (%04x).\n",
            stack[sp].line, addr, result, result);
    }
#line 736
    if (valid) {
#line 736
      if (! *valid) {
        {
#line 737
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%5d (0x%04x): Returning invalid result.\n",
                stack[sp].line, addr);
        }
      }
    }
  }
#line 740
  return (result);
}
}
#line 743 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/expressions.c"
int rd_expr(char const   **p , char delimiter , int *valid , int level , int print_errors ) 
{ 
  int check ;
  int result ;

  {
#line 747
  check = 1;
#line 749
  if (valid) {
#line 750
    *valid = 1;
  }
  {
#line 751
  result = do_rd_expr(p, delimiter, valid, level, & check, print_errors);
  }
#line 752
  if (print_errors) {
#line 752
    if (! valid) {
#line 752
      goto _L;
    } else
#line 752
    if (*valid) {
      _L: /* CIL Label */ 
#line 752
      if (check) {
        {
#line 753
        printerr(0, "expression fully enclosed in parenthesis\n");
        }
      }
    }
  }
#line 754
  return (result);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 435 "/usr/include/libio.h"
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 195
extern FILE *tmpfile(void) ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 573
extern int fputc(int __c , FILE *__stream ) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 749
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 754
extern long ftell(FILE *__stream ) ;
#line 759
extern void rewind(FILE *__stream ) ;
#line 798
extern int fgetpos(FILE * __restrict  __stream , fpos_t * __restrict  __pos ) ;
#line 826
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) clearerr)(FILE *__stream ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 49 "gnulib/getopt.h"
extern char *optarg ;
#line 63
extern int optind ;
#line 148
extern int getopt_long(int ___argc , char * const  *___argv , char const   *__shortopts ,
                       struct option  const  *__longopts , int *__longind ) ;
#line 826 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 169 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.h"
char const   *mnemonics[89] ;
#line 172
struct reference *firstreference ;
#line 173
struct label *lastlabel ;
#line 174
struct name *firstname ;
#line 175
struct includedir *firstincludedir ;
#line 176
struct macro *firstmacro ;
#line 179 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.h"
FILE *realoutputfile  ;
#line 179 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.h"
FILE *outfile  ;
#line 179 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.h"
FILE *reallistfile  ;
#line 179 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.h"
FILE *listfile  ;
#line 179 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.h"
FILE *labelfile  ;
#line 180 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.h"
char const   *realoutputfilename  ;
#line 181 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.h"
char const   *labelfilename  ;
#line 182 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.h"
struct infile *infile  ;
#line 184
char const   *labelprefix ;
#line 186
int havelist ;
#line 186
int label ;
#line 188 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.h"
int infilecount  ;
#line 191
int errors ;
#line 194 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.h"
int file  ;
#line 196 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.h"
int listdepth  ;
#line 199 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.h"
int writebyte  ;
#line 200 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.h"
char const   *readbyte  ;
#line 203 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.h"
char const   *readword  ;
#line 203 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.h"
char const   *indexjmp  ;
#line 203 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.h"
char const   *bitsetres  ;
#line 206 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.h"
int indexed  ;
#line 212 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.h"
int comma  ;
#line 215 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.h"
int baseaddr  ;
#line 218 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.h"
char mem_delimiter  ;
#line 221
char *buffer ;
#line 224
int define_macro ;
#line 227 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.h"
int sp  ;
#line 228 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.h"
struct stack stack[200]  ;
#line 231
int use_force ;
#line 26 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
char const   *mnemonics[89]  = 
#line 26 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
  {      "call",      "cpdr",      "cpir",      "djnz", 
        "halt",      "indr",      "inir",      "lddr", 
        "ldir",      "otdr",      "otir",      "outd", 
        "outi",      "push",      "reti",      "retn", 
        "rlca",      "rrca",      "defb",      "defw", 
        "defs",      "defm",      "adc",      "add", 
        "and",      "bit",      "ccf",      "cpd", 
        "cpi",      "cpl",      "daa",      "dec", 
        "equ",      "exx",      "inc",      "ind", 
        "ini",      "ldd",      "ldi",      "neg", 
        "nop",      "out",      "pop",      "res", 
        "ret",      "rla",      "rlc",      "rld", 
        "rra",      "rrc",      "rrd",      "rst", 
        "sbc",      "scf",      "set",      "sla", 
        "sll",      "sli",      "sra",      "srl", 
        "sub",      "xor",      "org",      "cp", 
        "di",      "ei",      "ex",      "im", 
        "in",      "jp",      "jr",      "ld", 
        "or",      "rl",      "rr",      "db", 
        "dw",      "ds",      "dm",      "include", 
        "incbin",      "if",      "else",      "endif", 
        "end",      "macro",      "endm",      "seek", 
        (char const   *)((void *)0)};
#line 41 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
struct reference *firstreference  =    (struct reference *)((void *)0);
#line 42 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
struct label *firstlabel  =    (struct label *)((void *)0);
#line 42 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
struct label *lastlabel  =    (struct label *)((void *)0);
#line 43 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
struct name *firstname  =    (struct name *)((void *)0);
#line 44 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
struct includedir *firstincludedir  =    (struct includedir *)((void *)0);
#line 45 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
struct macro *firstmacro  =    (struct macro *)((void *)0);
#line 53 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
char const   *labelprefix  =    "";
#line 55 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
int havelist  =    0;
#line 55 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
int label  =    0;
#line 60 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
int errors  =    0;
#line 63 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
int addr  =    0;
#line 78 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
int verbose  =    0;
#line 90 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
char *buffer  =    (char *)((void *)0);
#line 93 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
int define_macro  =    0;
#line 100 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
int use_force  =    0;
#line 103 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
void printerr(int error , char const   *fmt  , ...) 
{ 
  va_list l ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 107
  __builtin_va_start(l, fmt);
  }
#line 108
  if (sp < 0) {
    {
#line 110
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"internal assembler error, sp == %i\n",
            sp);
#line 111
    vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
             l);
#line 112
    exit(2);
    }
  } else
#line 108
  if ((unsigned long )stack[sp].name == (unsigned long )((char const   *)0)) {
    {
#line 110
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"internal assembler error, sp == %i\n",
            sp);
#line 111
    vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
             l);
#line 112
    exit(2);
    }
  }
#line 114
  if (error) {
#line 114
    tmp = "error";
  } else {
#line 114
    tmp = "warning";
  }
#line 114
  if (stack[sp].dir) {
#line 114
    tmp___0 = (char const   *)((stack[sp].dir)->name);
  } else {
#line 114
    tmp___0 = "";
  }
  {
#line 114
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s%s:%d: %s: ",
          tmp___0, stack[sp].name, stack[sp].line, tmp);
#line 116
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
           l);
#line 117
  __builtin_va_end(l);
  }
#line 118
  if (error) {
#line 119
    errors ++;
  }
#line 120
  return;
}
}
#line 123 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
char const   *delspc(char const   *ptr ) 
{ 
  unsigned short const   **tmp ;

  {
  {
#line 126
  while (1) {
    while_continue: /* CIL Label */ ;
#line 126
    if (*ptr) {
      {
#line 126
      tmp = __ctype_b_loc();
      }
#line 126
      if (! ((int const   )*(*tmp + (int )*ptr) & 8192)) {
#line 126
        goto while_break;
      }
    } else {
#line 126
      goto while_break;
    }
#line 127
    ptr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 128
  if ((int const   )*ptr == 59) {
#line 129
    ptr = "";
  }
#line 130
  return (ptr);
}
}
#line 134 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static void rd_comma(char const   **p ) 
{ 


  {
  {
#line 137
  *p = delspc(*p);
  }
#line 138
  if ((int const   )*(*p) != 44) {
    {
#line 140
    printerr(1, "`,\' expected. Remainder of line: %s\n", *p);
    }
#line 141
    return;
  }
  {
#line 143
  *p = delspc(*p + 1);
  }
#line 144
  return;
}
}
#line 147 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static int has_argument(char const   **p ) 
{ 
  char const   *q ;
  char const   *tmp ;

  {
  {
#line 150
  tmp = delspc(*p);
#line 150
  q = tmp;
  }
#line 151
  return ((int const   )*q == 44);
}
}
#line 157 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static void skipword(char const   **pos , char delimiter ) 
{ 
  int valid ;

  {
  {
#line 164
  rd_expr(pos, delimiter, & valid, sp, 0);
  }
#line 165
  return;
}
}
#line 168 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static FILE *openfile(int *done , char const   *type , FILE *def , char const   *name ,
                      char const   *flags ) 
{ 
  FILE *retval ;
  int *tmp ;
  char *tmp___0 ;

  {
#line 176
  if (*done) {
    {
#line 178
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: more than one %s specified\n",
            type);
#line 179
    exit(1);
    }
  }
#line 181
  *done = 1;
#line 182
  if (def) {
#line 182
    if (! name) {
#line 184
      return (def);
    } else
#line 182
    if ((int const   )*(name + 0) == 45) {
#line 182
      if ((int const   )*(name + 1) == 0) {
#line 184
        return (def);
      }
    }
  }
#line 186
  if (! name) {
    {
#line 188
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: no %s specified\n",
            type);
#line 189
    exit(1);
    }
  } else
#line 186
  if (! *(name + 0)) {
    {
#line 188
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: no %s specified\n",
            type);
#line 189
    exit(1);
    }
  }
  {
#line 191
  retval = fopen((char const   */* __restrict  */)name, (char const   */* __restrict  */)flags);
  }
#line 191
  if (! retval) {
    {
#line 193
    tmp = __errno_location();
#line 193
    tmp___0 = strerror(*tmp);
#line 193
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unable to open %s %s: %s\n",
            type, name, tmp___0);
#line 195
    exit(1);
    }
  }
#line 197
  return (retval);
}
}
#line 201 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static FILE *open_include_file(char const   *name , struct includedir **dir , char const   *flags ) 
{ 
  FILE *result ;
  struct includedir *i ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 208
  result = fopen((char const   */* __restrict  */)name, (char const   */* __restrict  */)flags);
  }
#line 209
  if (result) {
#line 211
    if (dir) {
#line 212
      *dir = (struct includedir *)((void *)0);
    }
#line 213
    return (result);
  }
#line 215
  i = firstincludedir;
  {
#line 215
  while (1) {
    while_continue: /* CIL Label */ ;
#line 215
    if (! ((unsigned long )i != (unsigned long )((void *)0))) {
#line 215
      goto while_break;
    }
    {
#line 217
    tmp___0 = strlen((char const   *)(i->name));
#line 217
    tmp___1 = strlen(name);
#line 217
    tmp___2 = malloc((tmp___0 + tmp___1) + 1UL);
#line 217
    tmp = (char *)tmp___2;
    }
#line 218
    if (! tmp) {
      {
#line 220
      printerr(1, "not enough memory trying to open include file\n");
      }
#line 221
      return ((FILE *)((void *)0));
    }
    {
#line 223
    strcpy((char */* __restrict  */)tmp, (char const   */* __restrict  */)(i->name));
#line 224
    strcat((char */* __restrict  */)tmp, (char const   */* __restrict  */)name);
#line 225
    result = fopen((char const   */* __restrict  */)tmp, (char const   */* __restrict  */)flags);
#line 226
    free((void *)tmp);
    }
#line 227
    if (result) {
#line 229
      if (dir) {
#line 230
        *dir = i;
      }
#line 231
      return (result);
    }
#line 215
    i = i->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 234
  return ((FILE *)((void *)0));
}
}
#line 238 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static void open_infile(char const   *name ) 
{ 
  void *tmp ;

  {
  {
#line 241
  tmp = realloc((void *)infile, sizeof(struct infile ) * (unsigned long )(infilecount + 1));
#line 241
  infile = (struct infile *)tmp;
  }
#line 242
  if (! infile) {
    {
#line 244
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: insufficient memory\n");
#line 245
    exit(1);
    }
  }
#line 248
  (infile + infilecount)->type = (enum filetype )0;
#line 249
  (infile + infilecount)->name = name;
#line 250
  if (verbose >= 5) {
    {
#line 251
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"queued inputfile %s\n",
            (infile + infilecount)->name);
    }
  }
#line 252
  infilecount ++;
#line 253
  return;
}
}
#line 256 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static void add_include(char const   *name ) 
{ 
  struct includedir *i ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 260
  tmp = strlen(name);
#line 260
  tmp___0 = malloc((sizeof(struct includedir ) + tmp) + 1UL);
#line 260
  i = (struct includedir *)tmp___0;
  }
#line 261
  if (! i) {
    {
#line 263
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: insufficient memory\n");
#line 264
    exit(1);
    }
  }
  {
#line 266
  strcpy((char */* __restrict  */)(i->name), (char const   */* __restrict  */)name);
#line 267
  tmp___1 = strlen(name);
  }
#line 267
  if ((int const   )*(name + (tmp___1 - 1UL)) != 47) {
    {
#line 268
    strcat((char */* __restrict  */)(i->name), (char const   */* __restrict  */)"/");
    }
  }
#line 269
  i->next = firstincludedir;
#line 270
  firstincludedir = i;
#line 271
  return;
}
}
#line 273 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static void try_use_real_file(FILE *real , FILE **backup ) 
{ 
  fpos_t pos ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  FILE *tmp___2 ;

  {
  {
#line 277
  tmp = fgetpos((FILE */* __restrict  */)real, (fpos_t */* __restrict  */)(& pos));
  }
#line 277
  if (tmp == 0) {
#line 279
    *backup = real;
#line 280
    return;
  }
  {
#line 282
  tmp___2 = tmpfile();
#line 282
  *backup = tmp___2;
  }
#line 282
  if (! tmp___2) {
    {
#line 284
    tmp___0 = __errno_location();
#line 284
    tmp___1 = strerror(*tmp___0);
#line 284
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Unable to open temporary file: %s\n",
            tmp___1);
#line 286
    exit(1);
    }
  }
#line 288
  return;
}
}
#line 290 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static void flush_to_real_file(FILE *real , FILE *tmp ) 
{ 
  int l ;
  int size ;
  int len ;
  char buf[300] ;
  int *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;

  {
#line 293
  len = 0;
#line 295
  if ((unsigned long )tmp == (unsigned long )real) {
#line 297
    return;
  }
  {
#line 299
  rewind(tmp);
  }
  {
#line 300
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 302
    clearerr(tmp);
#line 303
    tmp___0 = __errno_location();
#line 303
    *tmp___0 = 0;
#line 304
    tmp___1 = fread((void */* __restrict  */)(buf), (size_t )1, (size_t )300, (FILE */* __restrict  */)tmp);
#line 304
    len = (int )tmp___1;
    }
#line 305
    if (len == 0) {
      {
#line 305
      tmp___2 = feof(tmp);
      }
#line 305
      if (tmp___2) {
#line 306
        goto while_break;
      }
    }
#line 307
    if (len <= 0) {
      {
#line 309
      tmp___3 = __errno_location();
#line 309
      tmp___4 = strerror(*tmp___3);
#line 309
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error reading temp file: %s\n",
              tmp___4);
#line 310
      exit(1);
      }
    }
#line 312
    l = 0;
    {
#line 313
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 313
      if (! (l < len)) {
#line 313
        goto while_break___0;
      }
      {
#line 315
      clearerr(real);
#line 316
      tmp___5 = fwrite((void const   */* __restrict  */)(& buf[l]), (size_t )1, (size_t )(len - l),
                       (FILE */* __restrict  */)real);
#line 316
      size = (int )tmp___5;
      }
#line 317
      if (size <= 0) {
        {
#line 319
        tmp___6 = __errno_location();
#line 319
        tmp___7 = strerror(*tmp___6);
#line 319
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error writing final file: %s\n",
                tmp___7);
#line 321
        exit(1);
        }
      }
#line 323
      l += size;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 326
  return;
}
}
#line 329 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static void parse_commandline(int argc , char **argv ) 
{ 
  struct option opts[11] ;
  char const   *short_opts ;
  int done ;
  int i ;
  int out ;
  int tmp ;

  {
#line 332
  opts[0].name = "help";
#line 332
  opts[0].has_arg = 0;
#line 332
  opts[0].flag = (int *)((void *)0);
#line 332
  opts[0].val = 'h';
#line 332
  opts[1].name = "version";
#line 332
  opts[1].has_arg = 0;
#line 332
  opts[1].flag = (int *)((void *)0);
#line 332
  opts[1].val = 'V';
#line 332
  opts[2].name = "verbose";
#line 332
  opts[2].has_arg = 0;
#line 332
  opts[2].flag = (int *)((void *)0);
#line 332
  opts[2].val = 'v';
#line 332
  opts[3].name = "list";
#line 332
  opts[3].has_arg = 2;
#line 332
  opts[3].flag = (int *)((void *)0);
#line 332
  opts[3].val = 'l';
#line 332
  opts[4].name = "label";
#line 332
  opts[4].has_arg = 2;
#line 332
  opts[4].flag = (int *)((void *)0);
#line 332
  opts[4].val = 'L';
#line 332
  opts[5].name = "input";
#line 332
  opts[5].has_arg = 1;
#line 332
  opts[5].flag = (int *)((void *)0);
#line 332
  opts[5].val = 'i';
#line 332
  opts[6].name = "output";
#line 332
  opts[6].has_arg = 1;
#line 332
  opts[6].flag = (int *)((void *)0);
#line 332
  opts[6].val = 'o';
#line 332
  opts[7].name = "label-prefix";
#line 332
  opts[7].has_arg = 1;
#line 332
  opts[7].flag = (int *)((void *)0);
#line 332
  opts[7].val = 'p';
#line 332
  opts[8].name = "includepath";
#line 332
  opts[8].has_arg = 1;
#line 332
  opts[8].flag = (int *)((void *)0);
#line 332
  opts[8].val = 'I';
#line 332
  opts[9].name = "force";
#line 332
  opts[9].has_arg = 0;
#line 332
  opts[9].flag = (int *)((void *)0);
#line 332
  opts[9].val = 'f';
#line 332
  opts[10].name = (char const   *)((void *)0);
#line 332
  opts[10].has_arg = 0;
#line 332
  opts[10].flag = (int *)((void *)0);
#line 332
  opts[10].val = 0;
#line 345
  short_opts = "hVvl::L::i:o:p:I:f";
#line 346
  done = 0;
#line 346
  out = 0;
#line 347
  infile = (struct infile *)((void *)0);
  {
#line 348
  while (1) {
    while_continue: /* CIL Label */ ;
#line 348
    if (! (! done)) {
#line 348
      goto while_break;
    }
    {
#line 350
    tmp = getopt_long(argc, (char * const  *)argv, short_opts, (struct option  const  *)(opts),
                      (int *)((void *)0));
    }
    {
#line 352
    if (tmp == 104) {
#line 352
      goto case_104;
    }
#line 370
    if (tmp == 86) {
#line 370
      goto case_86;
    }
#line 384
    if (tmp == 118) {
#line 384
      goto case_118;
    }
#line 389
    if (tmp == 111) {
#line 389
      goto case_111;
    }
#line 396
    if (tmp == 105) {
#line 396
      goto case_105;
    }
#line 399
    if (tmp == 108) {
#line 399
      goto case_108;
    }
#line 405
    if (tmp == 76) {
#line 405
      goto case_76;
    }
#line 411
    if (tmp == 112) {
#line 411
      goto case_112;
    }
#line 414
    if (tmp == 73) {
#line 414
      goto case_73;
    }
#line 417
    if (tmp == 102) {
#line 417
      goto case_102;
    }
#line 420
    if (tmp == -1) {
#line 420
      goto case_neg_1;
    }
#line 423
    goto switch_default;
    case_104: /* CIL Label */ 
    {
#line 354
    printf((char const   */* __restrict  */)"Usage: %s [options] [input files]\n\nPossible options are:\n-h\t--help\t\tDisplay this help text and exit.\n-V\t--version\tDisplay version information and exit.\n-v\t--verbose\tBe verbose.  Specify again to be more verbose.\n-l\t--list\t\tWrite a list file.\n-L\t--label\t\tWrite a label file.\n",
           *(argv + 0));
#line 363
    printf((char const   */* __restrict  */)"-p\t--label-prefix\tprefix all labels with this prefix.\n-i\t--input\t\tSpecify an input file (-i may be omitted).\n-o\t--output\tSpecify the output file.\n-I\t--includepath\tAdd a directory to the include path.\nPlease send bug reports and feature requests to <shevek@fmf.nl>\n");
#line 369
    exit(0);
    }
    case_86: /* CIL Label */ 
    {
#line 371
    printf((char const   */* __restrict  */)"Z80 assembler version 1.8\nCopyright (C) 2002-2007 Bas Wijnen <shevek@fmf.nl>.\nCopyright (C) 2005 Jan Wilmans <jw@dds.nl>.\nThis program comes with ABSOLUTELY NO WARRANTY.\nYou may distribute copies of the program under the terms\nof the GNU General Public License as published by\nthe Free Software Foundation; either version 2 of the\nLicense, or (at your option) any later version.\n\nThe complete text of the GPL can be found in\n/usr/share/common-licenses/GPL.\n");
#line 383
    exit(0);
    }
    case_118: /* CIL Label */ 
#line 385
    verbose ++;
#line 386
    if (verbose >= 5) {
      {
#line 387
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Verbosity increased to level %d\n",
              verbose);
      }
    }
#line 388
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 390
    realoutputfile = openfile(& out, "output file", stdout, (char const   *)optarg,
                              "wb");
#line 392
    realoutputfilename = (char const   *)optarg;
    }
#line 393
    if (verbose >= 5) {
      {
#line 394
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Opened outputfile\n");
      }
    }
#line 395
    goto switch_break;
    case_105: /* CIL Label */ 
    {
#line 397
    open_infile((char const   *)optarg);
    }
#line 398
    goto switch_break;
    case_108: /* CIL Label */ 
    {
#line 400
    reallistfile = openfile(& havelist, "list file", stderr, (char const   *)optarg,
                            "w");
    }
#line 402
    if (verbose >= 5) {
      {
#line 403
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Opened list file\n");
      }
    }
#line 404
    goto switch_break;
    case_76: /* CIL Label */ 
    {
#line 406
    labelfile = openfile(& label, "label file", stderr, (char const   *)optarg, "w");
#line 407
    labelfilename = (char const   *)optarg;
    }
#line 408
    if (verbose >= 5) {
      {
#line 409
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Opened label file\n");
      }
    }
#line 410
    goto switch_break;
    case_112: /* CIL Label */ 
#line 412
    labelprefix = (char const   *)optarg;
#line 413
    goto switch_break;
    case_73: /* CIL Label */ 
    {
#line 415
    add_include((char const   *)optarg);
    }
#line 416
    goto switch_break;
    case_102: /* CIL Label */ 
#line 418
    use_force = 1;
#line 419
    goto switch_break;
    case_neg_1: /* CIL Label */ 
#line 421
    done = 1;
#line 422
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 425
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 428
  i = optind;
  {
#line 428
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 428
    if (! (i < argc)) {
#line 428
      goto while_break___0;
    }
    {
#line 429
    open_infile((char const   *)*(argv + i));
#line 428
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 430
  if (! infilecount) {
    {
#line 431
    open_infile("-");
    }
  }
#line 432
  if (! out) {
    {
#line 433
    realoutputfile = openfile(& out, "output file", stdout, "a.bin", "wb");
    }
  }
  {
#line 434
  try_use_real_file(realoutputfile, & outfile);
  }
#line 435
  if (havelist) {
    {
#line 436
    try_use_real_file(reallistfile, & listfile);
    }
  }
#line 437
  return;
}
}
#line 440 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static int indx(char const   **ptr , char const   **list , int error , char const   **expr ) 
{ 
  int i ;
  int l ;
  char const   *input ;
  char const   *check ;
  int had_expr ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
  {
#line 444
  *ptr = delspc(*ptr);
  }
#line 445
  if (! *(*ptr)) {
#line 447
    if (error) {
      {
#line 449
      printerr(1, "unexpected end of line\n");
      }
#line 450
      return (0);
    } else {
#line 453
      return (0);
    }
  }
#line 455
  if (comma > 1) {
    {
#line 456
    rd_comma(ptr);
    }
  }
#line 457
  i = 0;
  {
#line 457
  while (1) {
    while_continue: /* CIL Label */ ;
#line 457
    if (! *(list + i)) {
#line 457
      goto while_break;
    }
#line 459
    input = *ptr;
#line 460
    check = *(list + i);
#line 461
    had_expr = 0;
#line 462
    if (! *(*(list + i) + 0)) {
#line 463
      goto __Cont;
    }
    {
#line 464
    tmp = strlen(*(list + i));
#line 464
    l = (int )tmp;
    }
    {
#line 465
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 465
      if (! *check) {
#line 465
        goto while_break___0;
      }
#line 467
      if ((int const   )*check == 32) {
        {
#line 469
        input = delspc(input);
        }
      } else
#line 471
      if ((int const   )*check == 42) {
        {
#line 473
        *expr = input;
#line 474
        mem_delimiter = (char )*(check + 1);
#line 475
        rd_expr(& input, mem_delimiter, (int *)((void *)0), sp, 0);
#line 476
        had_expr = 1;
        }
      } else
#line 478
      if ((int const   )*check == 43) {
#line 480
        if ((int const   )*input == 43) {
          {
#line 482
          *expr = input;
#line 483
          mem_delimiter = (char )*(check + 1);
#line 484
          rd_expr(& input, mem_delimiter, (int *)((void *)0), sp, 0);
          }
        } else
#line 480
        if ((int const   )*input == 45) {
          {
#line 482
          *expr = input;
#line 483
          mem_delimiter = (char )*(check + 1);
#line 484
          rd_expr(& input, mem_delimiter, (int *)((void *)0), sp, 0);
          }
        }
      } else
#line 487
      if ((int const   )*check == (int const   )*input) {
#line 489
        input ++;
      } else
#line 487
      if ((int const   )*check >= 97) {
#line 487
        if ((int const   )*check <= 122) {
#line 487
          if (((int const   )*check - 97) + 65 == (int const   )*input) {
#line 489
            input ++;
          } else {
#line 491
            goto while_break___0;
          }
        } else {
#line 491
          goto while_break___0;
        }
      } else {
#line 491
        goto while_break___0;
      }
#line 493
      check ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 495
    if (*check) {
#line 496
      goto __Cont;
    } else {
      {
#line 495
      tmp___0 = __ctype_b_loc();
      }
#line 495
      if ((int const   )*(*tmp___0 + (int )*(check + -1)) & 8) {
        {
#line 495
        tmp___1 = __ctype_b_loc();
        }
#line 495
        if ((int const   )*(*tmp___1 + (int )*(input + 0)) & 8) {
#line 496
          goto __Cont;
        }
      }
    }
#line 497
    if (had_expr) {
      {
#line 499
      input = delspc(input);
      }
#line 500
      if (*input) {
#line 500
        if ((int const   )*input != 44) {
#line 501
          goto __Cont;
        }
      }
    }
#line 503
    *ptr = input;
#line 504
    if (verbose >= 4) {
      {
#line 505
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%5d (0x%04x): Piece of code found:%s\n",
              stack[sp].line, addr, *(list + i));
      }
    }
#line 507
    if (verbose >= 6) {
      {
#line 508
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%5d (0x%04x): Remainder of line=%s.\n",
              stack[sp].line, addr, *ptr);
      }
    }
#line 510
    comma ++;
#line 511
    return (i + 1);
    __Cont: /* CIL Label */ 
#line 457
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 513
  if (error) {
    {
#line 515
    printerr(1, "parse error. Remainder of line=%s\n", *ptr);
    }
#line 516
    if (verbose >= 3) {
      {
#line 518
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"When looking for any of:\n");
#line 519
      i = 0;
      }
      {
#line 519
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 519
        if (! *(list + i)) {
#line 519
          goto while_break___1;
        }
        {
#line 520
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\t",
                *(list + i));
#line 519
        i ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 521
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    }
  }
#line 524
  return (0);
}
}
#line 528 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static int readcommand(char const   **p ) 
{ 
  int tmp ;

  {
  {
#line 531
  tmp = indx(p, mnemonics, 0, (char const   **)((void *)0));
  }
#line 531
  return (tmp);
}
}
#line 535 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static void readlabel(char const   **p , int store ) 
{ 
  char const   *c ;
  char const   *d ;
  char const   *pos ;
  char const   *dummy ;
  int i ;
  int j ;
  struct label *buf ;
  struct label *previous ;
  struct label **thefirstlabel ;
  char *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;

  {
#line 541
  d = *p;
  {
#line 541
  while (1) {
    while_continue: /* CIL Label */ ;
#line 541
    if (*d) {
#line 541
      if (! ((int const   )*d != 59)) {
#line 541
        goto while_break;
      }
    } else {
#line 541
      goto while_break;
    }
#line 541
    d ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 544
  c = *p;
  {
#line 544
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 544
    tmp = strchr(" \r\n\t", (int )*c);
    }
#line 544
    if (tmp) {
#line 544
      goto while_break___0;
    } else
#line 544
    if (! ((unsigned long )c < (unsigned long )d)) {
#line 544
      goto while_break___0;
    }
#line 544
    c ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 547
  tmp___0 = strchr(*p, ':');
#line 547
  pos = (char const   *)tmp___0;
  }
#line 548
  if (! pos) {
#line 549
    return;
  } else
#line 548
  if ((unsigned long )pos >= (unsigned long )c) {
#line 549
    return;
  }
#line 550
  if ((unsigned long )pos == (unsigned long )*p) {
    {
#line 552
    printerr(1, "`:\' found without a label");
    }
#line 553
    return;
  }
#line 555
  if (! store) {
#line 557
    *p = pos + 1;
#line 558
    return;
  }
  {
#line 560
  c = pos + 1;
#line 561
  dummy = *p;
#line 562
  j = rd_label(& dummy, & i, & previous, sp, 0);
  }
#line 563
  if (i) {
    {
#line 565
    printerr(1, "duplicate definition of label %s\n", *p);
#line 566
    *p = c;
    }
#line 567
    return;
  } else
#line 563
  if (j) {
    {
#line 565
    printerr(1, "duplicate definition of label %s\n", *p);
#line 566
    *p = c;
    }
#line 567
    return;
  }
  {
#line 569
  tmp___1 = malloc((size_t )((c + sizeof(struct label )) - *p));
#line 569
  buf = (struct label *)tmp___1;
  }
#line 569
  if ((unsigned long )((void *)0) == (unsigned long )buf) {
    {
#line 571
    printerr(1, "not enough memory to store label %s\n", *p);
#line 572
    *p = c;
    }
#line 573
    return;
  }
  {
#line 575
  strncpy((char */* __restrict  */)(buf->name), (char const   */* __restrict  */)*p,
          (size_t )((c - *p) - 1L));
#line 576
  buf->name[(c - *p) - 1L] = (char)0;
  }
#line 577
  if (verbose >= 3) {
    {
#line 578
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%5d (0x%04x): Label found: %s\n",
            stack[sp].line, addr, buf->name);
    }
  }
#line 580
  *p = c;
#line 581
  buf->value = addr;
#line 582
  lastlabel = buf;
#line 583
  if ((int )buf->name[0] == 46) {
#line 584
    thefirstlabel = & stack[sp].labels;
  } else {
#line 586
    thefirstlabel = & firstlabel;
  }
#line 587
  if (previous) {
#line 588
    buf->next = previous->next;
  } else {
#line 590
    buf->next = *thefirstlabel;
  }
#line 591
  buf->prev = previous;
#line 592
  buf->valid = 1;
#line 593
  buf->busy = 0;
#line 594
  buf->ref = (struct reference *)((void *)0);
#line 595
  if (buf->prev) {
#line 596
    (buf->prev)->next = buf;
  } else {
#line 598
    *thefirstlabel = buf;
  }
#line 599
  if (buf->next) {
#line 600
    (buf->next)->prev = buf;
  }
#line 601
  return;
}
}
#line 603
static void new_reference(char const   *p , int type , char delimiter , int ds_count ) ;
#line 607 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static void write_one_byte(int b , int list ) 
{ 


  {
#line 610
  if (verbose >= 4) {
    {
#line 611
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%5d (0x%04x): write_one_byte called with argument 0x%02x\n",
            stack[sp].line, addr, b);
    }
  }
  {
#line 614
  b &= 255;
#line 615
  _IO_putc(b, outfile);
  }
#line 616
  if (list) {
#line 616
    if (havelist) {
      {
#line 618
      fprintf((FILE */* __restrict  */)listfile, (char const   */* __restrict  */)" %02x",
              b);
#line 619
      listdepth += 3;
      }
    }
  }
#line 621
  addr ++;
#line 622
  addr &= 65535;
#line 623
  return;
}
}
#line 626 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static void wrtb(int b ) 
{ 


  {
#line 629
  if (verbose >= 4) {
    {
#line 630
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%5d (0x%04x): wrtb called with argument 0x%02x\n",
            stack[sp].line, addr, b);
    }
  }
#line 632
  if (indexed) {
#line 634
    if (verbose >= 5) {
      {
#line 635
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%5d (0x%04x): writing indexed byte 0x%02x\n",
              stack[sp].line, addr, indexed);
      }
    }
    {
#line 637
    write_one_byte(indexed, 1);
#line 638
    indexed = 0;
    }
  }
#line 640
  if (writebyte) {
#line 642
    if (verbose >= 5) {
      {
#line 643
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%5d (0x%04x): using a xor on byte because there is a writebyte.\n",
              stack[sp].line, addr);
      }
    }
#line 645
    b ^= 64;
  }
#line 647
  if (verbose >= 5) {
    {
#line 648
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%5d (0x%04x): writing byte 0x%02x\n",
            stack[sp].line, addr, b);
    }
  }
#line 650
  if (bitsetres) {
#line 650
    if (b != 203) {
      {
#line 652
      new_reference(bitsetres, 0, (char )',', b);
#line 653
      bitsetres = (char const   *)((void *)0);
      }
    } else {
      {
#line 657
      write_one_byte(b, 1);
      }
    }
  } else {
    {
#line 657
    write_one_byte(b, 1);
    }
  }
#line 659
  if (indexjmp) {
#line 661
    if (verbose >= 5) {
      {
#line 662
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%5d (0x%04x): Making reference for index/jump %s\n",
              stack[sp].line, addr, indexjmp);
      }
    }
    {
#line 664
    new_reference(indexjmp, 4, (char )')', 1);
#line 665
    indexjmp = (char const   *)((void *)0);
    }
  }
#line 667
  if (writebyte) {
#line 669
    if (verbose >= 5) {
      {
#line 670
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%5d (0x%04x): writing argument byte for padding\n",
              stack[sp].line, addr);
      }
    }
    {
#line 672
    writebyte = 0;
#line 673
    new_reference(readbyte, 4, mem_delimiter, 1);
    }
  }
#line 675
  return;
}
}
#line 677 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
int compute_ref(struct reference *ref , int allow_invalid ) 
{ 
  char const   *ptr ;
  int valid ;
  int backup_addr ;
  int backup_baseaddr ;
  int backup_comma ;
  int backup_file ;
  int backup_sp ;
  int *tmp ;

  {
#line 681
  valid = 0;
#line 682
  backup_addr = addr;
#line 683
  backup_baseaddr = baseaddr;
#line 684
  backup_comma = comma;
#line 685
  backup_file = file;
#line 686
  backup_sp = sp;
#line 687
  sp = ref->level;
#line 688
  addr = ref->addr;
#line 689
  baseaddr = ref->baseaddr;
#line 690
  comma = ref->comma;
#line 691
  file = ref->infile;
#line 692
  if (verbose >= 3) {
    {
#line 693
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%5d (0x%04x): Making reference to %s (done=%d, computed=%d)\n",
            stack[sp].line, addr, ref->input, ref->done, ref->computed_value);
    }
  }
#line 697
  ptr = (char const   *)(ref->input);
#line 698
  if (! ref->done) {
#line 700
    if (allow_invalid) {
#line 700
      tmp = & valid;
    } else {
#line 700
      tmp = (int *)((void *)0);
    }
    {
#line 700
    ref->computed_value = rd_expr(& ptr, ref->delimiter, tmp, ref->level, 1);
    }
#line 703
    if (valid) {
#line 704
      ref->done = 1;
    }
  }
#line 706
  if (verbose >= 4) {
    {
#line 707
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%5d (0x%04x): Reference is %d (0x%04x).\n",
            stack[sp].line, addr, ref->computed_value, ref->computed_value);
    }
  }
#line 709
  sp = backup_sp;
#line 710
  addr = backup_addr;
#line 711
  baseaddr = backup_baseaddr;
#line 712
  comma = backup_comma;
#line 713
  file = backup_file;
#line 714
  return (ref->computed_value);
}
}
#line 717
static void wrt_ref(int val , int type , int count ) ;
#line 721 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static void new_reference(char const   *p , int type , char delimiter , int ds_count ) 
{ 
  struct reference *tmp ;
  long opos ;
  long lpos ;
  int valid ;
  int value ;
  char const   *c ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  long tmp___6 ;

  {
  {
#line 724
  tmp = (struct reference *)((void *)0);
#line 728
  c = p;
#line 729
  value = rd_expr(& c, delimiter, & valid, sp, 1);
  }
#line 730
  if (valid) {
#line 732
    if (verbose >= 5) {
      {
#line 734
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%5d (0x%04x): Using calculated value %d (%x) immediately.\n",
              stack[sp].line, addr, value, value);
      }
    }
  } else {
    {
#line 741
    tmp___0 = strlen(p);
#line 741
    tmp___1 = malloc(sizeof(struct reference ) + tmp___0);
#line 741
    tmp = (struct reference *)tmp___1;
    }
#line 742
    if (! tmp) {
      {
#line 744
      printerr(1, "unable to allocate memory for reference %s\n", p);
      }
#line 745
      return;
    }
    {
#line 747
    tmp___2 = strlen(stack[sp].name);
#line 747
    tmp___3 = malloc(tmp___2 + 1UL);
#line 747
    tmp->file = (char *)tmp___3;
    }
#line 748
    if (! tmp->file) {
      {
#line 750
      printerr(1, "unable to allocate memory for reference filename\n");
#line 751
      free((void *)tmp);
      }
#line 752
      return;
    }
    {
#line 754
    strcpy((char */* __restrict  */)tmp->file, (char const   */* __restrict  */)stack[sp].name);
    }
#line 755
    if (stack[sp].dir) {
      {
#line 757
      tmp___4 = strlen((char const   *)((stack[sp].dir)->name));
#line 757
      tmp___5 = malloc(tmp___4 + sizeof(struct includedir ));
#line 757
      tmp->dir = (struct includedir *)tmp___5;
      }
#line 759
      if (! tmp->dir) {
        {
#line 761
        printerr(1, "unable to allocate memory for reference dir\n");
#line 762
        free((void *)tmp->file);
#line 763
        free((void *)tmp);
        }
#line 764
        return;
      }
      {
#line 766
      strcpy((char */* __restrict  */)((tmp->dir)->name), (char const   */* __restrict  */)((stack[sp].dir)->name));
      }
    } else {
#line 769
      tmp->dir = (struct includedir *)((void *)0);
    }
    {
#line 770
    opos = ftell(outfile);
    }
#line 771
    if (havelist) {
      {
#line 771
      tmp___6 = ftell(listfile);
#line 771
      lpos = tmp___6;
      }
    } else {
#line 771
      lpos = 0L;
    }
#line 772
    if (verbose >= 3) {
      {
#line 773
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%5d (0x%04x): reference set to %s (delimiter=%c, sp=%d)\n",
              stack[sp].line, addr, p, (int )delimiter, sp);
      }
    }
    {
#line 775
    strcpy((char */* __restrict  */)(tmp->input), (char const   */* __restrict  */)p);
#line 776
    tmp->line = stack[sp].line;
#line 777
    tmp->addr = addr;
#line 778
    tmp->baseaddr = baseaddr;
#line 779
    tmp->count = ds_count;
#line 780
    tmp->infile = file;
#line 781
    tmp->comma = comma;
#line 782
    tmp->oseekpos = opos;
#line 783
    tmp->lseekpos = lpos;
#line 784
    tmp->delimiter = delimiter;
#line 785
    tmp->type = (enum reftype )type;
#line 786
    tmp->next = firstreference;
#line 787
    tmp->done = 0;
#line 788
    tmp->level = sp;
    }
#line 789
    if (type != 6) {
#line 791
      if (firstreference) {
#line 792
        firstreference->prev = tmp;
      }
#line 793
      tmp->prev = (struct reference *)((void *)0);
#line 794
      firstreference = tmp;
    }
#line 797
    if (type == 5) {
#line 797
      value = ds_count;
    } else {
#line 797
      value = 0;
    }
  }
#line 799
  if (type != 6) {
    {
#line 801
    wrt_ref(value, type, ds_count);
    }
  } else {
#line 805
    lastlabel->ref = tmp;
#line 806
    lastlabel->valid = valid;
#line 807
    lastlabel->value = value;
  }
#line 809
  return;
}
}
#line 812 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static void write_word(void) 
{ 


  {
  {
#line 815
  new_reference(readword, 3, mem_delimiter, 1);
  }
#line 816
  return;
}
}
#line 819 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static void write_rel(void) 
{ 


  {
  {
#line 822
  new_reference(readbyte, 5, mem_delimiter, (addr + 1) & 65535);
#line 823
  writebyte = 0;
  }
#line 824
  return;
}
}
#line 827 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static int rd_word(char const   **p , char delimiter ) 
{ 


  {
  {
#line 830
  *p = delspc(*p);
  }
#line 831
  if ((int const   )*(*p) == 0) {
#line 832
    return (0);
  }
  {
#line 833
  readword = *p;
#line 834
  mem_delimiter = delimiter;
#line 835
  skipword(p, delimiter);
  }
#line 836
  return (1);
}
}
#line 840 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static int rd_byte(char const   **p , char delimiter ) 
{ 


  {
  {
#line 843
  *p = delspc(*p);
  }
#line 844
  if ((int const   )*(*p) == 0) {
#line 845
    return (0);
  }
  {
#line 846
  readbyte = *p;
#line 847
  writebyte = 1;
#line 848
  mem_delimiter = delimiter;
#line 849
  skipword(p, delimiter);
  }
#line 850
  return (1);
}
}
#line 855 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static void rd_wrt_addr(char const   **p , char delimiter ) 
{ 
  int tmp ;

  {
  {
#line 858
  tmp = rd_word(p, delimiter);
  }
#line 858
  if (! tmp) {
#line 859
    return;
  }
  {
#line 860
  write_word();
  }
#line 861
  return;
}
}
#line 864 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static void rd_wrt_jr(char const   **p , char delimiter ) 
{ 
  int tmp ;

  {
  {
#line 867
  tmp = rd_byte(p, delimiter);
  }
#line 867
  if (! tmp) {
#line 868
    return;
  }
  {
#line 869
  write_rel();
  }
#line 870
  return;
}
}
#line 873 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static int rd_ex1(char const   **p ) 
{ 
  char const   *list[4] ;
  int tmp ;

  {
  {
#line 878
  list[0] = "( sp )";
#line 878
  list[1] = "de";
#line 878
  list[2] = "af";
#line 878
  list[3] = (char const   *)((void *)0);
#line 879
  tmp = indx(p, list, 1, (char const   **)((void *)0));
  }
#line 879
  return (tmp);
}
}
#line 883 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static int rd_in(char const   **p ) 
{ 
  char const   *list[9] ;
  int tmp ;

  {
  {
#line 887
  list[0] = "b";
#line 887
  list[1] = "c";
#line 887
  list[2] = "d";
#line 887
  list[3] = "e";
#line 887
  list[4] = "h";
#line 887
  list[5] = "l";
#line 887
  list[6] = "f";
#line 887
  list[7] = "a";
#line 887
  list[8] = (char const   *)((void *)0);
#line 888
  tmp = indx(p, list, 1, (char const   **)((void *)0));
  }
#line 888
  return (tmp);
}
}
#line 892 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static int rd_out(char const   **p ) 
{ 
  char const   *list[9] ;
  int tmp ;

  {
  {
#line 895
  list[0] = "b";
#line 895
  list[1] = "c";
#line 895
  list[2] = "d";
#line 895
  list[3] = "e";
#line 895
  list[4] = "h";
#line 895
  list[5] = "l";
#line 895
  list[6] = "0";
#line 895
  list[7] = "a";
#line 895
  list[8] = (char const   *)((void *)0);
#line 896
  tmp = indx(p, list, 1, (char const   **)((void *)0));
  }
#line 896
  return (tmp);
}
}
#line 900 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static int rd_nnc(char const   **p ) 
{ 
  int i ;
  char const   *list[4] ;

  {
  {
#line 905
  list[0] = "( c )";
#line 905
  list[1] = "(*)";
#line 905
  list[2] = "a , (*)";
#line 905
  list[3] = (char const   *)((void *)0);
#line 906
  i = indx(p, list, 1, & readbyte);
  }
#line 907
  if (i < 2) {
#line 908
    return (i);
  }
#line 909
  return (2);
}
}
#line 913 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static int rd_c(char const   **p ) 
{ 
  char const   *list[3] ;
  int tmp ;

  {
  {
#line 916
  list[0] = "( c )";
#line 916
  list[1] = "( bc )";
#line 916
  list[2] = (char const   *)((void *)0);
#line 917
  tmp = indx(p, list, 1, (char const   **)((void *)0));
  }
#line 917
  return (tmp);
}
}
#line 921 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static int rd_a_hl(char const   **p ) 
{ 
  char const   *list[3] ;
  int tmp ;

  {
  {
#line 925
  list[0] = "a";
#line 925
  list[1] = "hl";
#line 925
  list[2] = (char const   *)((void *)0);
#line 926
  tmp = indx(p, list, 1, (char const   **)((void *)0));
  }
#line 926
  return (tmp);
}
}
#line 930 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static int rd_ld(char const   **p ) 
{ 
  int i ;
  char const   *list[26] ;
  char const   *nn ;

  {
  {
#line 955
  list[0] = "ixh";
#line 955
  list[1] = "ixl";
#line 955
  list[2] = "iyh";
#line 955
  list[3] = "iyl";
#line 955
  list[4] = "bc";
#line 955
  list[5] = "de";
#line 955
  list[6] = "hl";
#line 955
  list[7] = "sp";
#line 955
  list[8] = "ix";
#line 955
  list[9] = "iy";
#line 955
  list[10] = "b";
#line 955
  list[11] = "c";
#line 955
  list[12] = "d";
#line 955
  list[13] = "e";
#line 955
  list[14] = "h";
#line 955
  list[15] = "l";
#line 955
  list[16] = "( hl )";
#line 955
  list[17] = "a";
#line 955
  list[18] = "i";
#line 955
  list[19] = "r";
#line 955
  list[20] = "( bc )";
#line 955
  list[21] = "( de )";
#line 955
  list[22] = "( ix +)";
#line 955
  list[23] = "(iy +)";
#line 955
  list[24] = "(*)";
#line 955
  list[25] = (char const   *)((void *)0);
#line 961
  i = indx(p, list, 1, & nn);
  }
#line 962
  if (! i) {
#line 963
    return (0);
  }
#line 964
  if (i <= 2) {
#line 966
    indexed = 221;
#line 967
    return (11 + (i == 2));
  }
#line 969
  if (i <= 4) {
#line 971
    indexed = 253;
#line 972
    return (11 + (i == 4));
  }
#line 974
  i -= 4;
#line 975
  if (i == 5) {
#line 975
    goto _L;
  } else
#line 975
  if (i == 6) {
    _L: /* CIL Label */ 
#line 977
    if (i == 5) {
#line 977
      indexed = 221;
    } else {
#line 977
      indexed = 253;
    }
#line 978
    return (3);
  }
#line 980
  if (i == 19) {
#line 980
    goto _L___0;
  } else
#line 980
  if (i == 20) {
    _L___0: /* CIL Label */ 
#line 982
    indexjmp = nn;
#line 983
    if (i == 19) {
#line 983
      indexed = 221;
    } else {
#line 983
      indexed = 253;
    }
#line 984
    return (13);
  }
#line 986
  if (i == 21) {
#line 987
    readword = nn;
  }
#line 988
  return (i);
}
}
#line 992 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static int rd_jp(char const   **p ) 
{ 
  int i ;
  char const   *list[12] ;

  {
  {
#line 996
  list[0] = "nz";
#line 996
  list[1] = "z";
#line 996
  list[2] = "nc";
#line 996
  list[3] = "c";
#line 996
  list[4] = "po";
#line 996
  list[5] = "pe";
#line 996
  list[6] = "p";
#line 996
  list[7] = "m";
#line 996
  list[8] = "( ix )";
#line 996
  list[9] = "( iy )";
#line 996
  list[10] = "(hl)";
#line 996
  list[11] = (char const   *)((void *)0);
#line 1000
  i = indx(p, list, 0, (char const   **)((void *)0));
  }
#line 1001
  if (i < 9) {
#line 1002
    return (i);
  }
#line 1003
  if (i == 11) {
#line 1004
    return (-1);
  }
#line 1005
  indexed = 221 + 32 * (i - 9);
#line 1006
  return (-1);
}
}
#line 1010 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static int rd_jr(char const   **p ) 
{ 
  char const   *list[5] ;
  int tmp ;

  {
  {
#line 1013
  list[0] = "nz";
#line 1013
  list[1] = "z";
#line 1013
  list[2] = "nc";
#line 1013
  list[3] = "c";
#line 1013
  list[4] = (char const   *)((void *)0);
#line 1014
  tmp = indx(p, list, 0, (char const   **)((void *)0));
  }
#line 1014
  return (tmp);
}
}
#line 1018 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static int rd_a(char const   **p ) 
{ 
  char const   *list[2] ;
  int tmp ;

  {
  {
#line 1021
  list[0] = "a";
#line 1021
  list[1] = (char const   *)((void *)0);
#line 1022
  tmp = indx(p, list, 1, (char const   **)((void *)0));
  }
#line 1022
  return (tmp);
}
}
#line 1026 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static int rd_stack(char const   **p ) 
{ 
  int i ;
  char const   *list[7] ;

  {
  {
#line 1030
  list[0] = "bc";
#line 1030
  list[1] = "de";
#line 1030
  list[2] = "hl";
#line 1030
  list[3] = "af";
#line 1030
  list[4] = "ix";
#line 1030
  list[5] = "iy";
#line 1030
  list[6] = (char const   *)((void *)0);
#line 1031
  i = indx(p, list, 1, (char const   **)((void *)0));
  }
#line 1032
  if (i < 5) {
#line 1033
    return (i);
  }
#line 1034
  indexed = 221 + 32 * (i - 5);
#line 1035
  return (3);
}
}
#line 1058 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static int rd_r_add(char const   **p ) 
{ 
  int i ;
  char const   *list[19] ;
  char const   *nn ;

  {
  {
#line 1063
  list[0] = "ixl";
#line 1063
  list[1] = "ixh";
#line 1063
  list[2] = "iyl";
#line 1063
  list[3] = "iyh";
#line 1063
  list[4] = "b";
#line 1063
  list[5] = "c";
#line 1063
  list[6] = "d";
#line 1063
  list[7] = "e";
#line 1063
  list[8] = "h";
#line 1063
  list[9] = "l";
#line 1063
  list[10] = "( hl )";
#line 1063
  list[11] = "a";
#line 1063
  list[12] = "( ix +)";
#line 1063
  list[13] = "( iy +)";
#line 1063
  list[14] = "hl";
#line 1063
  list[15] = "ix";
#line 1063
  list[16] = "iy";
#line 1063
  list[17] = "*";
#line 1063
  list[18] = (char const   *)((void *)0);
#line 1068
  i = indx(p, list, 0, & nn);
  }
#line 1069
  if (i == 18) {
#line 1071
    readbyte = nn;
#line 1072
    writebyte = 1;
#line 1073
    return (7);
  }
#line 1075
  if (i > 14) {
#line 1077
    if (i > 15) {
#line 1078
      indexed = 221 + 32 * (i - 16);
    }
#line 1079
    return (15);
  }
#line 1081
  if (i <= 4) {
#line 1083
    indexed = 221 + 32 * (i > 2);
#line 1084
    return (6 - (i & 1));
  }
#line 1086
  i -= 4;
#line 1087
  if (i < 9) {
#line 1088
    return (i);
  }
#line 1089
  indexed = 221 + 32 * (i - 9);
#line 1090
  indexjmp = nn;
#line 1091
  return (7);
}
}
#line 1095 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static int rd_rr_(char const   **p ) 
{ 
  char const   *list[5] ;
  int tmp ;

  {
  {
#line 1098
  list[0] = "bc";
#line 1098
  list[1] = "de";
#line 1098
  list[2] = "hl";
#line 1098
  list[3] = "sp";
#line 1098
  list[4] = (char const   *)((void *)0);
#line 1099
  tmp = indx(p, list, 1, (char const   **)((void *)0));
  }
#line 1099
  return (tmp);
}
}
#line 1103 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static int rd_rrxx(char const   **p ) 
{ 
  char const   *listx[5] ;
  char const   *listy[5] ;
  char const   *list[5] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1106
  listx[0] = "bc";
#line 1106
  listx[1] = "de";
#line 1106
  listx[2] = "ix";
#line 1106
  listx[3] = "sp";
#line 1106
  listx[4] = (char const   *)((void *)0);
#line 1107
  listy[0] = "bc";
#line 1107
  listy[1] = "de";
#line 1107
  listy[2] = "iy";
#line 1107
  listy[3] = "sp";
#line 1107
  listy[4] = (char const   *)((void *)0);
#line 1108
  list[0] = "bc";
#line 1108
  list[1] = "de";
#line 1108
  list[2] = "hl";
#line 1108
  list[3] = "sp";
#line 1108
  list[4] = (char const   *)((void *)0);
  {
#line 1111
  if (indexed == 221) {
#line 1111
    goto case_221;
  }
#line 1113
  if (indexed == 253) {
#line 1113
    goto case_253;
  }
#line 1115
  goto switch_default;
  case_221: /* CIL Label */ 
  {
#line 1112
  tmp = indx(p, listx, 1, (char const   **)((void *)0));
  }
#line 1112
  return (tmp);
  case_253: /* CIL Label */ 
  {
#line 1114
  tmp___0 = indx(p, listy, 1, (char const   **)((void *)0));
  }
#line 1114
  return (tmp___0);
  switch_default: /* CIL Label */ 
  {
#line 1116
  tmp___1 = indx(p, list, 1, (char const   **)((void *)0));
  }
#line 1116
  return (tmp___1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1122 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static int rd_r(char const   **p ) 
{ 
  int i ;
  char const   *list[16] ;
  char const   *nn ;

  {
  {
#line 1126
  list[0] = "ixl";
#line 1126
  list[1] = "ixh";
#line 1126
  list[2] = "iyl";
#line 1126
  list[3] = "iyh";
#line 1126
  list[4] = "b";
#line 1126
  list[5] = "c";
#line 1126
  list[6] = "d";
#line 1126
  list[7] = "e";
#line 1126
  list[8] = "h";
#line 1126
  list[9] = "l";
#line 1126
  list[10] = "( hl )";
#line 1126
  list[11] = "a";
#line 1126
  list[12] = "( ix +)";
#line 1126
  list[13] = "( iy +)";
#line 1126
  list[14] = "*";
#line 1126
  list[15] = (char const   *)((void *)0);
#line 1131
  i = indx(p, list, 0, & nn);
  }
#line 1132
  if (i == 15) {
#line 1134
    readbyte = nn;
#line 1135
    writebyte = 1;
#line 1136
    return (7);
  }
#line 1138
  if (i <= 4) {
#line 1140
    indexed = 221 + 32 * (i > 2);
#line 1141
    return (6 - (i & 1));
  }
#line 1143
  i -= 4;
#line 1144
  if (i < 9) {
#line 1145
    return (i);
  }
#line 1146
  indexed = 221 + 32 * (i - 9);
#line 1147
  indexjmp = nn;
#line 1148
  return (7);
}
}
#line 1152 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static int rd_r_(char const   **p ) 
{ 
  int i ;
  char const   *list[11] ;

  {
  {
#line 1156
  list[0] = "b";
#line 1156
  list[1] = "c";
#line 1156
  list[2] = "d";
#line 1156
  list[3] = "e";
#line 1156
  list[4] = "h";
#line 1156
  list[5] = "l";
#line 1156
  list[6] = "( hl )";
#line 1156
  list[7] = "a";
#line 1156
  list[8] = "( ix +)";
#line 1156
  list[9] = "( iy +)";
#line 1156
  list[10] = (char const   *)((void *)0);
#line 1159
  i = indx(p, list, 1, & indexjmp);
  }
#line 1160
  if (i < 9) {
#line 1161
    return (i);
  }
#line 1162
  indexed = 221 + 32 * (i - 9);
#line 1163
  return (7);
}
}
#line 1167 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static int rd_0_7(char const   **p ) 
{ 


  {
  {
#line 1170
  *p = delspc(*p);
  }
#line 1171
  if ((int const   )*(*p) == 0) {
#line 1172
    return (0);
  }
  {
#line 1173
  bitsetres = *p;
#line 1174
  skipword(p, (char )',');
  }
#line 1175
  return (1);
}
}
#line 1179 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static int rd_cc(char const   **p ) 
{ 
  char const   *list[9] ;
  int tmp ;

  {
  {
#line 1182
  list[0] = "nz";
#line 1182
  list[1] = "z";
#line 1182
  list[2] = "nc";
#line 1182
  list[3] = "c";
#line 1182
  list[4] = "po";
#line 1182
  list[5] = "pe";
#line 1182
  list[6] = "p";
#line 1182
  list[7] = "m";
#line 1182
  list[8] = (char const   *)((void *)0);
#line 1183
  tmp = indx(p, list, 0, (char const   **)((void *)0));
  }
#line 1183
  return (tmp);
}
}
#line 1187 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static int rd_r_rr(char const   **p ) 
{ 
  int i ;
  char const   *list[18] ;

  {
  {
#line 1191
  list[0] = "iy";
#line 1191
  list[1] = "ix";
#line 1191
  list[2] = "sp";
#line 1191
  list[3] = "hl";
#line 1191
  list[4] = "de";
#line 1191
  list[5] = "bc";
#line 1191
  list[6] = "";
#line 1191
  list[7] = "b";
#line 1191
  list[8] = "c";
#line 1191
  list[9] = "d";
#line 1191
  list[10] = "e";
#line 1191
  list[11] = "h";
#line 1191
  list[12] = "l";
#line 1191
  list[13] = "( hl )";
#line 1191
  list[14] = "a";
#line 1191
  list[15] = "( ix +)";
#line 1191
  list[16] = "( iy +)";
#line 1191
  list[17] = (char const   *)((void *)0);
#line 1195
  i = indx(p, list, 1, & indexjmp);
  }
#line 1196
  if (! i) {
#line 1197
    return (0);
  }
#line 1198
  if (i < 16) {
#line 1198
    if (i > 2) {
#line 1199
      return (7 - i);
    }
  }
#line 1200
  if (i > 15) {
#line 1202
    indexed = 221 + (i - 16) * 32;
#line 1203
    return (-7);
  }
#line 1205
  indexed = 221 + (2 - i) * 32;
#line 1206
  return (3);
}
}
#line 1210 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static int rd_hl(char const   **p ) 
{ 
  char const   *list[2] ;
  int tmp ;

  {
  {
#line 1213
  list[0] = "hl";
#line 1213
  list[1] = (char const   *)((void *)0);
#line 1214
  tmp = indx(p, list, 1, (char const   **)((void *)0));
  }
#line 1214
  return (tmp);
}
}
#line 1218 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static int rd_hlx(char const   **p ) 
{ 
  int i ;
  char const   *list[4] ;

  {
  {
#line 1222
  list[0] = "hl";
#line 1222
  list[1] = "ix";
#line 1222
  list[2] = "iy";
#line 1222
  list[3] = (char const   *)((void *)0);
#line 1223
  i = indx(p, list, 1, (char const   **)((void *)0));
  }
#line 1224
  if (i < 2) {
#line 1225
    return (i);
  }
#line 1226
  indexed = 221 + 32 * (i - 2);
#line 1227
  return (1);
}
}
#line 1231 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static int rd_af_(char const   **p ) 
{ 
  char const   *list[2] ;
  int tmp ;

  {
  {
#line 1234
  list[0] = "af\'";
#line 1234
  list[1] = (char const   *)((void *)0);
#line 1235
  tmp = indx(p, list, 1, (char const   **)((void *)0));
  }
#line 1235
  return (tmp);
}
}
#line 1239 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static int rd_0_2(char const   **p ) 
{ 
  char const   *list[5] ;
  int tmp ;

  {
  {
#line 1242
  list[0] = "0";
#line 1242
  list[1] = "";
#line 1242
  list[2] = "1";
#line 1242
  list[3] = "2";
#line 1242
  list[4] = (char const   *)((void *)0);
#line 1243
  tmp = indx(p, list, 1, (char const   **)((void *)0));
  }
#line 1243
  return (tmp);
}
}
#line 1247 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static int rd_ld_hl(char const   **p ) 
{ 
  int i ;
  char const   *list[10] ;

  {
  {
#line 1251
  list[0] = "b";
#line 1251
  list[1] = "c";
#line 1251
  list[2] = "d";
#line 1251
  list[3] = "e";
#line 1251
  list[4] = "h";
#line 1251
  list[5] = "l";
#line 1251
  list[6] = "";
#line 1251
  list[7] = "a";
#line 1251
  list[8] = "*";
#line 1251
  list[9] = (char const   *)((void *)0);
#line 1252
  i = indx(p, list, 0, & readbyte);
  }
#line 1253
  if (i < 9) {
#line 1254
    return (i);
  }
#line 1255
  writebyte = 1;
#line 1256
  return (7);
}
}
#line 1260 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static int rd_ld_nn(char const   **p ) 
{ 
  int i ;
  char const   *list[9] ;

  {
  {
#line 1266
  list[0] = "bc";
#line 1266
  list[1] = "de";
#line 1266
  list[2] = "";
#line 1266
  list[3] = "sp";
#line 1266
  list[4] = "hl";
#line 1266
  list[5] = "a";
#line 1266
  list[6] = "ix";
#line 1266
  list[7] = "iy";
#line 1266
  list[8] = (char const   *)((void *)0);
#line 1267
  i = indx(p, list, 1, (char const   **)((void *)0));
  }
#line 1268
  if (i < 7) {
#line 1269
    return (i);
  }
#line 1270
  indexed = 221 + 32 * (i == 8);
#line 1271
  return (5);
}
}
#line 1275 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static int rd_lda(char const   **p ) 
{ 
  int i ;
  char const   *list[18] ;
  char const   *nn ;

  {
  {
#line 1282
  list[0] = "( sp )";
#line 1282
  list[1] = "( iy +)";
#line 1282
  list[2] = "( de )";
#line 1282
  list[3] = "( bc )";
#line 1282
  list[4] = "( ix +)";
#line 1282
  list[5] = "b";
#line 1282
  list[6] = "c";
#line 1282
  list[7] = "d";
#line 1282
  list[8] = "e";
#line 1282
  list[9] = "h";
#line 1282
  list[10] = "l";
#line 1282
  list[11] = "( hl )";
#line 1282
  list[12] = "a";
#line 1282
  list[13] = "i";
#line 1282
  list[14] = "r";
#line 1282
  list[15] = "(*)";
#line 1282
  list[16] = "*";
#line 1282
  list[17] = (char const   *)((void *)0);
#line 1287
  i = indx(p, list, 0, & nn);
  }
#line 1288
  if (i == 2) {
#line 1288
    goto _L;
  } else
#line 1288
  if (i == 5) {
    _L: /* CIL Label */ 
#line 1290
    if (i == 2) {
#line 1290
      indexed = 253;
    } else {
#line 1290
      indexed = 221;
    }
#line 1291
    indexjmp = nn;
#line 1292
    return (7);
  }
#line 1294
  if (i == 17) {
#line 1296
    readbyte = nn;
#line 1297
    writebyte = 1;
#line 1298
    return (7);
  }
#line 1300
  if (i == 16) {
#line 1302
    readword = nn;
  }
#line 1304
  return (i - 5);
}
}
#line 1308 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static int rd_ldbcdehla(char const   **p ) 
{ 
  int i ;
  char const   *list[16] ;
  char const   *nn ;
  int x ;

  {
  {
#line 1312
  list[0] = "b";
#line 1312
  list[1] = "c";
#line 1312
  list[2] = "d";
#line 1312
  list[3] = "e";
#line 1312
  list[4] = "h";
#line 1312
  list[5] = "l";
#line 1312
  list[6] = "( hl )";
#line 1312
  list[7] = "a";
#line 1312
  list[8] = "( ix +)";
#line 1312
  list[9] = "( iy +)";
#line 1312
  list[10] = "ixh";
#line 1312
  list[11] = "ixl";
#line 1312
  list[12] = "iyh";
#line 1312
  list[13] = "iyl";
#line 1312
  list[14] = "*";
#line 1312
  list[15] = (char const   *)((void *)0);
#line 1317
  i = indx(p, list, 0, & nn);
  }
#line 1318
  if (i == 15) {
#line 1320
    readbyte = nn;
#line 1321
    writebyte = 1;
#line 1322
    return (7);
  }
#line 1324
  if (i > 10) {
#line 1327
    x = 221 + 32 * (i > 12);
#line 1328
    if (indexed) {
#line 1328
      if (indexed != x) {
        {
#line 1330
        printerr(1, "illegal use of index registers\n");
        }
#line 1331
        return (0);
      }
    }
#line 1333
    indexed = x;
#line 1334
    return (6 - (i & 1));
  }
#line 1336
  if (i > 8) {
#line 1338
    if (indexed) {
      {
#line 1340
      printerr(1, "illegal use of index registers\n");
      }
#line 1341
      return (0);
    }
#line 1343
    indexed = 221 + 32 * (i == 10);
#line 1344
    indexjmp = nn;
#line 1345
    return (7);
  }
#line 1347
  return (i);
}
}
#line 1351 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static int rd_nn_nn(char const   **p ) 
{ 
  char const   *list[3] ;
  int tmp ;

  {
  {
#line 1355
  list[0] = "(*)";
#line 1355
  list[1] = "*";
#line 1355
  list[2] = (char const   *)((void *)0);
#line 1356
  tmp = indx(p, list, 0, & readword);
  }
#line 1356
  return (2 - tmp);
}
}
#line 1360 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static int rd_sp(char const   **p ) 
{ 
  int i ;
  char const   *list[6] ;
  char const   *nn ;
  int tmp ;

  {
  {
#line 1366
  list[0] = "hl";
#line 1366
  list[1] = "ix";
#line 1366
  list[2] = "iy";
#line 1366
  list[3] = "(*)";
#line 1366
  list[4] = "*";
#line 1366
  list[5] = (char const   *)((void *)0);
#line 1368
  i = indx(p, list, 0, & nn);
  }
#line 1369
  if (i > 3) {
#line 1371
    readword = nn;
#line 1372
    if (i == 4) {
#line 1372
      tmp = 2;
    } else {
#line 1372
      tmp = 0;
    }
#line 1372
    return (tmp);
  }
#line 1374
  if (i != 1) {
#line 1375
    indexed = 221 + 32 * (i - 2);
  }
#line 1376
  return (1);
}
}
#line 1380 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static void wrt_ref(int val , int type , int count ) 
{ 
  int tmp ;

  {
  {
#line 1385
  if (type == 2) {
#line 1385
    goto case_2;
  }
#line 1393
  if (type == 3) {
#line 1393
    goto case_3;
  }
#line 1399
  if (type == 4) {
#line 1399
    goto case_4;
  }
#line 1404
  if (type == 1) {
#line 1404
    goto case_1;
  }
#line 1417
  if (type == 0) {
#line 1417
    goto case_0;
  }
#line 1425
  if (type == 5) {
#line 1425
    goto case_5;
  }
#line 1433
  if (type == 6) {
#line 1433
    goto case_6;
  }
#line 1383
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1386
  if ((val & 56) != val) {
    {
#line 1388
    printerr(1, "incorrect RST value %d (0x%02x)\n", val, val);
    }
#line 1389
    return;
  }
  {
#line 1391
  write_one_byte(val + 199, 1);
  }
#line 1392
  return;
  case_3: /* CIL Label */ 
#line 1394
  if (val < -32768) {
    {
#line 1395
    printerr(0, "word value %d (0x%x) truncated\n", val, val);
    }
  } else
#line 1394
  if (val >= 65536) {
    {
#line 1395
    printerr(0, "word value %d (0x%x) truncated\n", val, val);
    }
  }
  {
#line 1396
  write_one_byte(val & 255, 1);
#line 1397
  write_one_byte((val >> 8) & 255, 1);
  }
#line 1398
  return;
  case_4: /* CIL Label */ 
#line 1400
  if (val < -128) {
    {
#line 1401
    printerr(0, "byte value %d (0x%x) truncated\n", val, val);
    }
  } else
#line 1400
  if (val >= 256) {
    {
#line 1401
    printerr(0, "byte value %d (0x%x) truncated\n", val, val);
    }
  }
  {
#line 1402
  write_one_byte(val & 255, 1);
  }
#line 1403
  return;
  case_1: /* CIL Label */ 
#line 1405
  if (val < -128) {
    {
#line 1406
    printerr(0, "byte value %d (0x%x) truncated\n", val, val);
    }
  } else
#line 1405
  if (val >= 256) {
    {
#line 1406
    printerr(0, "byte value %d (0x%x) truncated\n", val, val);
    }
  }
#line 1407
  if (havelist) {
    {
#line 1409
    fprintf((FILE */* __restrict  */)listfile, (char const   */* __restrict  */)" 0x%02x...",
            val & 255);
#line 1410
    listdepth += 6;
    }
  }
  {
#line 1412
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1412
    tmp = count;
#line 1412
    count --;
#line 1412
    if (! tmp) {
#line 1412
      goto while_break;
    }
    {
#line 1414
    write_one_byte(val & 255, 0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1416
  return;
  case_0: /* CIL Label */ 
#line 1418
  if (val & -8) {
    {
#line 1420
    printerr(1, "incorrect BIT/SET/RES value %d\n", val);
    }
#line 1421
    return;
  }
  {
#line 1423
  write_one_byte(8 * val + count, 1);
  }
#line 1424
  return;
  case_5: /* CIL Label */ 
#line 1426
  val -= count;
#line 1427
  if (val & 65408) {
#line 1427
    if (~ val & 65408) {
      {
#line 1429
      printerr(1, "relative jump out of range (%d)\n", val);
      }
    }
  }
  {
#line 1431
  write_one_byte(val & 255, 1);
  }
#line 1432
  return;
  case_6: /* CIL Label */ 
  {
#line 1434
  printerr(1, "bug in the assembler: trying to write label reference.  Please report.\n");
  }
#line 1436
  return;
  switch_break: /* CIL Label */ ;
  }
#line 1438
  return;
}
}
#line 1440 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static char *get_include_name(char const   **ptr ) 
{ 
  int pos ;
  char quote ;
  char *name ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;

  {
  {
#line 1443
  pos = 0;
#line 1446
  *ptr = delspc(*ptr);
#line 1447
  tmp = strlen(*ptr);
#line 1447
  tmp___0 = malloc(tmp);
#line 1447
  name = (char *)tmp___0;
  }
#line 1448
  if (! name) {
    {
#line 1450
    tmp___1 = strlen(*ptr);
#line 1450
    printerr(1, "unable to allocate memory for filename %.*s\n", tmp___1 - 1UL, *ptr);
    }
#line 1452
    return ((char *)((void *)0));
  }
#line 1454
  if (! *(*ptr)) {
    {
#line 1456
    printerr(1, "include without filename\n");
#line 1457
    free((void *)name);
    }
#line 1458
    return ((char *)((void *)0));
  }
#line 1460
  tmp___2 = *ptr;
#line 1460
  (*ptr) ++;
#line 1460
  quote = (char )*tmp___2;
  {
#line 1461
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1461
    if (! ((int const   )*(*ptr) != (int const   )quote)) {
#line 1461
      goto while_break;
    }
#line 1463
    if (! *(*ptr)) {
      {
#line 1465
      printerr(1, "filename without closing quote (%c)\n", (int )quote);
#line 1466
      free((void *)name);
      }
#line 1467
      return ((char *)((void *)0));
    }
#line 1469
    tmp___3 = pos;
#line 1469
    pos ++;
#line 1469
    tmp___4 = *ptr;
#line 1469
    (*ptr) ++;
#line 1469
    *(name + tmp___3) = (char )*tmp___4;
  }
  while_break: /* CIL Label */ ;
  }
#line 1471
  *(name + pos) = (char)0;
#line 1472
  (*ptr) ++;
#line 1473
  return (name);
}
}
#line 1484 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static char short_buffer[301]  ;
#line 1476 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static int read_line(void) 
{ 
  unsigned int pos ;
  unsigned int newpos ;
  unsigned int size ;
  struct macro_arg *arg ;
  FILE *f ;
  char *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char *b ;
  char *tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  unsigned int i ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;
  size_t tmp___8 ;

  {
#line 1481
  if (stack[sp].file) {
#line 1483
    f = stack[sp].file;
#line 1485
    if (buffer) {
#line 1485
      if ((unsigned long )buffer != (unsigned long )(short_buffer)) {
        {
#line 1486
        free((void *)buffer);
        }
      }
    }
    {
#line 1487
    buffer = (char *)((void *)0);
#line 1488
    tmp = fgets((char */* __restrict  */)(short_buffer), 301, (FILE */* __restrict  */)f);
    }
#line 1488
    if (! tmp) {
#line 1489
      return (0);
    }
    {
#line 1490
    tmp___0 = strlen((char const   *)(short_buffer));
    }
#line 1490
    if (tmp___0 < 300UL) {
#line 1492
      buffer = short_buffer;
#line 1493
      return (1);
    }
    {
#line 1495
    size = 600U;
#line 1496
    tmp___1 = malloc((size_t )(size + 1U));
#line 1496
    buffer = (char *)tmp___1;
    }
#line 1497
    if (! buffer) {
      {
#line 1499
      printerr(1, "out of memory reading line\n");
      }
#line 1500
      return (0);
    }
    {
#line 1502
    memcpy((void */* __restrict  */)buffer, (void const   */* __restrict  */)(short_buffer),
           (size_t )301);
    }
    {
#line 1503
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1506
      tmp___2 = fgets((char */* __restrict  */)(buffer + (size - 300U)), 301, (FILE */* __restrict  */)f);
      }
#line 1506
      if (tmp___2) {
        {
#line 1506
        tmp___3 = strlen((char const   *)buffer);
        }
#line 1506
        if ((int )*(buffer + (tmp___3 - 1UL)) == 10) {
#line 1509
          return (1);
        }
      } else {
#line 1509
        return (1);
      }
      {
#line 1511
      size += 300U;
#line 1512
      tmp___4 = realloc((void *)buffer, (size_t )(size + 1U));
#line 1512
      b = (char *)tmp___4;
      }
#line 1513
      if (! b) {
        {
#line 1515
        printerr(1, "out of memory reading line\n");
        }
#line 1516
        return (0);
      }
#line 1518
      buffer = b;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1522
  if (! stack[sp].macro_line) {
#line 1525
    i = 0U;
    {
#line 1525
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1525
      if (! (i < (stack[sp].macro)->numargs)) {
#line 1525
        goto while_break___0;
      }
      {
#line 1526
      free((void *)*(stack[sp].macro_args + i));
#line 1525
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1527
    free((void *)stack[sp].macro_args);
    }
#line 1528
    return (0);
  }
  {
#line 1530
  tmp___5 = strlen((char const   *)(stack[sp].macro_line)->line);
#line 1530
  size = (unsigned int )(tmp___5 + 1UL);
#line 1531
  arg = (stack[sp].macro_line)->args;
  }
  {
#line 1531
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1531
    if (! arg) {
#line 1531
      goto while_break___1;
    }
    {
#line 1532
    tmp___6 = strlen((char const   *)*(stack[sp].macro_args + arg->which));
#line 1532
    size = (unsigned int )((size_t )size + tmp___6);
#line 1531
    arg = arg->next;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1533
  tmp___7 = malloc((size_t )size);
#line 1533
  buffer = (char *)tmp___7;
  }
#line 1534
  if (! buffer) {
    {
#line 1536
    printerr(1, "out of memory\n");
    }
#line 1537
    return (0);
  }
#line 1539
  pos = 0U;
#line 1540
  newpos = 0U;
#line 1541
  arg = (stack[sp].macro_line)->args;
  {
#line 1541
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1541
    if (! arg) {
#line 1541
      goto while_break___2;
    }
    {
#line 1543
    memcpy((void */* __restrict  */)(buffer + newpos), (void const   */* __restrict  */)((stack[sp].macro_line)->line + pos),
           (size_t )(arg->pos - pos));
#line 1545
    newpos += arg->pos - pos;
#line 1546
    strcpy((char */* __restrict  */)(buffer + newpos), (char const   */* __restrict  */)*(stack[sp].macro_args + arg->which));
#line 1547
    tmp___8 = strlen((char const   *)*(stack[sp].macro_args + arg->which));
#line 1547
    newpos = (unsigned int )((size_t )newpos + tmp___8);
#line 1548
    pos = arg->pos + 1U;
#line 1541
    arg = arg->next;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 1550
  strcpy((char */* __restrict  */)(buffer + newpos), (char const   */* __restrict  */)((stack[sp].macro_line)->line + pos));
#line 1551
  stack[sp].macro_line = (stack[sp].macro_line)->next;
  }
#line 1552
  return (1);
}
}
#line 1555 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static unsigned int get_macro_args(char const   **ptr , char ***ret_args , int allow_empty ) 
{ 
  unsigned int numargs ;
  char **args ;
  char const   *c ;
  char *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1558
  numargs = 0U;
#line 1559
  *ret_args = (char **)((void *)0);
  {
#line 1560
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1564
    *ptr = delspc(*ptr);
    }
#line 1565
    if (! *(*ptr)) {
#line 1566
      goto while_break;
    }
#line 1567
    c = *ptr;
    {
#line 1568
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1568
      if (*(*ptr)) {
        {
#line 1568
        tmp = strchr(" \r\n\t,;", (int )*(*ptr));
        }
#line 1568
        if (tmp) {
#line 1568
          goto while_break___0;
        }
      } else {
#line 1568
        goto while_break___0;
      }
#line 1568
      (*ptr) ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1571
    if ((unsigned long )*ptr == (unsigned long )c) {
#line 1571
      if (! allow_empty) {
        {
#line 1573
        printerr(1, "empty macro argument\n");
        }
#line 1574
        goto while_break;
      }
    }
    {
#line 1576
    numargs ++;
#line 1577
    tmp___0 = realloc((void *)*ret_args, sizeof(char *) * (unsigned long )numargs);
#line 1577
    args = (char **)tmp___0;
    }
#line 1578
    if (! args) {
      {
#line 1580
      printerr(1, "out of memory\n");
#line 1581
      numargs --;
      }
#line 1582
      goto while_break;
    }
    {
#line 1584
    *ret_args = args;
#line 1585
    tmp___1 = malloc((size_t )((*ptr - c) + 1L));
#line 1585
    *(args + (numargs - 1U)) = (char *)tmp___1;
    }
#line 1586
    if (! *(args + (numargs - 1U))) {
      {
#line 1588
      printerr(1, "out of memory\n");
#line 1589
      numargs --;
      }
#line 1590
      goto while_break;
    }
    {
#line 1592
    memcpy((void */* __restrict  */)*(args + (numargs - 1U)), (void const   */* __restrict  */)c,
           (size_t )(*ptr - c));
#line 1593
    *(*(args + (numargs - 1U)) + (*ptr - c)) = (char)0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1595
  return (numargs);
}
}
#line 1599 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static void assemble(void) 
{ 
  int ifcount ;
  int noifcount ;
  char const   *ptr ;
  struct label *l ;
  char *bufptr ;
  int r ;
  int s ;
  int file_ended ;
  int cmd ;
  int cont ;
  int i ;
  int tabs ;
  int tmp ;
  struct reference *ref ;
  struct reference *nextref ;
  struct label *next ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *newptr ;
  struct macro_line **current_line ;
  void *tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;
  unsigned int p ;
  struct macro_arg **last_arg ;
  struct macro_arg *newarg ;
  void *tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  char const   *tmp___12 ;
  int i___0 ;
  int have_quote ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  char const   *tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  char const   *tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int quote ;
  int tmp___28 ;
  int tmp___29 ;
  int x ;
  struct name *name ;
  char *nm ;
  char *tmp___30 ;
  size_t tmp___31 ;
  void *tmp___32 ;
  FILE *incfile ;
  char *name___0 ;
  char *tmp___33 ;
  char filebuffer[4096] ;
  size_t num ;
  size_t tmp___34 ;
  int *tmp___35 ;
  char *tmp___36 ;
  size_t tmp___37 ;
  int tmp___38 ;
  struct macro *m ;
  int tmp___39 ;
  void *tmp___40 ;
  size_t tmp___41 ;
  void *tmp___42 ;
  unsigned int seekaddr ;
  int tmp___43 ;
  char const   *tmp___44 ;
  struct macro *m___0 ;
  unsigned int numargs ;
  int x___0 ;
  size_t tmp___45 ;
  unsigned int a ;
  size_t tmp___46 ;
  int tmp___47 ;
  struct reference *next___0 ;
  struct reference *tmp___48 ;
  int ref___0 ;

  {
#line 1602
  ifcount = 0;
#line 1602
  noifcount = 0;
#line 1608
  file = 0;
  {
#line 1608
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1608
    if (! (file < infilecount)) {
#line 1608
      goto while_break;
    }
#line 1610
    file_ended = 0;
#line 1611
    sp = 0;
#line 1612
    stack[sp].line = 0;
#line 1613
    stack[sp].shouldclose = 0;
#line 1614
    stack[sp].name = (infile + file)->name;
#line 1615
    stack[sp].dir = (struct includedir *)((void *)0);
#line 1616
    if ((int const   )*((infile + file)->name + 0) == 45) {
#line 1616
      if ((int const   )*((infile + file)->name + 1) == 0) {
#line 1618
        stack[sp].file = stdin;
      } else {
#line 1616
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 1622
      stack[sp].file = fopen((char const   */* __restrict  */)(infile + file)->name,
                             (char const   */* __restrict  */)"r");
      }
#line 1623
      if (! stack[sp].file) {
        {
#line 1625
        printerr(1, "unable to open %s. skipping\n", (infile + file)->name);
        }
#line 1626
        goto __Cont;
      }
#line 1628
      stack[sp].shouldclose = 1;
    }
#line 1630
    if (havelist) {
      {
#line 1631
      fprintf((FILE */* __restrict  */)listfile, (char const   */* __restrict  */)"# File %s\n",
              stack[sp].name);
      }
    }
#line 1632
    if (buffer) {
#line 1633
      *(buffer + 0) = (char)0;
    }
    {
#line 1635
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1637
      cont = 1;
#line 1638
      if (havelist) {
#line 1640
        if (buffer) {
#line 1640
          if ((int )*(buffer + 0) != 0) {
            {
#line 1643
            ptr = delspc(ptr);
            }
#line 1644
            if ((int const   )*ptr != 0) {
              {
#line 1646
              printerr(1, "junk at end of line: %s\n", ptr);
              }
            }
#line 1648
            if (listdepth < 8) {
#line 1649
              tabs = 3;
            } else
#line 1650
            if (listdepth < 16) {
#line 1651
              tabs = 2;
            } else {
#line 1653
              tabs = 1;
            }
#line 1654
            i = 0;
            {
#line 1654
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 1654
              if (! (i < tabs)) {
#line 1654
                goto while_break___1;
              }
              {
#line 1655
              fputc('\t', listfile);
#line 1654
              i ++;
              }
            }
            while_break___1: /* CIL Label */ ;
            }
            {
#line 1656
            fprintf((FILE */* __restrict  */)listfile, (char const   */* __restrict  */)"%s\n",
                    buffer);
            }
          }
        }
#line 1658
        listdepth = 4;
      }
#line 1661
      if (file_ended) {
        {
#line 1663
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
#line 1663
          tmp = read_line();
          }
#line 1663
          if (! tmp) {
#line 1663
            goto while_break___2;
          }
#line 1665
          if (havelist) {
            {
#line 1666
            fprintf((FILE */* __restrict  */)listfile, (char const   */* __restrict  */)"\t\t\t%s\n",
                    buffer);
            }
          }
        }
        while_break___2: /* CIL Label */ ;
        }
#line 1668
        file_ended = 0;
      }
      {
#line 1670
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 1670
        tmp___2 = read_line();
        }
#line 1670
        if (tmp___2) {
#line 1670
          goto while_break___3;
        }
#line 1674
        if (verbose >= 6) {
          {
#line 1675
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"finished reading file %s\n",
                  stack[sp].name);
          }
        }
#line 1677
        if (havelist) {
#line 1679
          if (stack[sp].file) {
            {
#line 1680
            fprintf((FILE */* __restrict  */)listfile, (char const   */* __restrict  */)"# End of file %s\n",
                    stack[sp].name);
            }
          } else {
            {
#line 1682
            fprintf((FILE */* __restrict  */)listfile, (char const   */* __restrict  */)"# End of macro %s\n",
                    stack[sp].name);
            }
          }
        }
#line 1684
        if (stack[sp].shouldclose) {
          {
#line 1685
          fclose(stack[sp].file);
          }
        }
#line 1689
        ref = firstreference;
        {
#line 1689
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 1689
          if (! ref) {
#line 1689
            goto while_break___4;
          }
          {
#line 1691
          nextref = ref->next;
#line 1692
          compute_ref(ref, 1);
          }
#line 1693
          if (ref->done) {
#line 1694
            goto __Cont___0;
          }
#line 1695
          if (ref->level == sp) {
#line 1696
            tmp___0 = ref->level;
#line 1696
            (ref->level) --;
#line 1696
            if (! tmp___0) {
              {
#line 1698
              printerr(1, "unable to resolve reference: %s\n", ref->input);
              }
#line 1700
              if (ref->prev) {
#line 1701
                (ref->prev)->next = ref->next;
              } else {
#line 1703
                firstreference = ref->next;
              }
#line 1704
              if (ref->next) {
#line 1705
                (ref->next)->prev = ref->prev;
              }
              {
#line 1706
              free((void *)ref);
              }
            }
          }
          __Cont___0: /* CIL Label */ 
#line 1689
          ref = nextref;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 1710
        l = stack[sp].labels;
        {
#line 1710
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 1710
          if (! l) {
#line 1710
            goto while_break___5;
          }
#line 1712
          next = l->next;
#line 1713
          if (l->ref) {
            {
#line 1714
            free((void *)l->ref);
            }
          }
          {
#line 1715
          free((void *)l);
#line 1710
          l = next;
          }
        }
        while_break___5: /* CIL Label */ ;
        }
#line 1717
        stack[sp].labels = (struct label *)((void *)0);
#line 1718
        tmp___1 = sp;
#line 1718
        sp --;
#line 1718
        if (! tmp___1) {
#line 1720
          cont = 0;
#line 1721
          goto while_break___3;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 1724
      if (! cont) {
#line 1725
        goto while_break___0;
      }
#line 1726
      if (havelist) {
        {
#line 1727
        fprintf((FILE */* __restrict  */)listfile, (char const   */* __restrict  */)"%04x",
                addr);
        }
      }
#line 1728
      bufptr = buffer;
      {
#line 1728
      while (1) {
        while_continue___6: /* CIL Label */ ;
        {
#line 1728
        bufptr = strchr((char const   *)bufptr, '\n');
        }
#line 1728
        if (! bufptr) {
#line 1728
          goto while_break___6;
        }
#line 1729
        *bufptr = (char )' ';
      }
      while_break___6: /* CIL Label */ ;
      }
#line 1730
      bufptr = buffer;
      {
#line 1730
      while (1) {
        while_continue___7: /* CIL Label */ ;
        {
#line 1730
        bufptr = strchr((char const   *)bufptr, '\r');
        }
#line 1730
        if (! bufptr) {
#line 1730
          goto while_break___7;
        }
#line 1731
        *bufptr = (char )' ';
      }
      while_break___7: /* CIL Label */ ;
      }
      {
#line 1732
      ptr = (char const   *)buffer;
#line 1733
      lastlabel = (struct label *)((void *)0);
#line 1734
      baseaddr = addr;
#line 1735
      (stack[sp].line) ++;
#line 1736
      ptr = delspc(ptr);
      }
#line 1737
      if (! *ptr) {
#line 1738
        goto while_continue___0;
      }
#line 1739
      if (! noifcount) {
#line 1739
        if (! define_macro) {
          {
#line 1740
          readlabel(& ptr, 1);
          }
        } else {
          {
#line 1742
          readlabel(& ptr, 0);
          }
        }
      } else {
        {
#line 1742
        readlabel(& ptr, 0);
        }
      }
      {
#line 1743
      ptr = delspc(ptr);
      }
#line 1744
      if (! *ptr) {
#line 1745
        goto while_continue___0;
      }
      {
#line 1746
      comma = 0;
#line 1747
      indexed = 0;
#line 1748
      indexjmp = (char const   *)0;
#line 1749
      writebyte = 0;
#line 1750
      readbyte = (char const   *)0;
#line 1751
      readword = (char const   *)0;
#line 1752
      tmp___3 = readcommand(& ptr);
#line 1752
      cmd = tmp___3 - 1;
      }
#line 1753
      if (noifcount) {
        {
#line 1757
        if (cmd == 81) {
#line 1757
          goto case_81;
        }
#line 1760
        if (cmd == 82) {
#line 1760
          goto case_82;
        }
#line 1767
        if (cmd == 83) {
#line 1767
          goto case_83;
        }
#line 1755
        goto switch_break;
        case_81: /* CIL Label */ 
#line 1758
        noifcount ++;
#line 1759
        goto switch_break;
        case_82: /* CIL Label */ 
#line 1761
        if (noifcount == 1) {
#line 1763
          noifcount = 0;
#line 1764
          ifcount ++;
        }
#line 1766
        goto switch_break;
        case_83: /* CIL Label */ 
#line 1768
        noifcount --;
        switch_break: /* CIL Label */ ;
        }
#line 1770
        ptr = "";
#line 1771
        goto while_continue___0;
      }
#line 1773
      if (define_macro) {
#line 1777
        current_line = & firstmacro->lines;
        {
#line 1777
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 1777
          if (! *current_line) {
#line 1777
            goto while_break___8;
          }
#line 1777
          current_line = & (*current_line)->next;
        }
        while_break___8: /* CIL Label */ ;
        }
        {
#line 1781
        tmp___4 = malloc(sizeof(struct macro_line ));
#line 1781
        *current_line = (struct macro_line *)tmp___4;
        }
#line 1782
        if (! *current_line) {
          {
#line 1784
          printerr(1, "out of memory\n");
          }
#line 1785
          goto while_continue___0;
        }
        {
#line 1787
        (*current_line)->next = (struct macro_line *)((void *)0);
#line 1788
        (*current_line)->args = (struct macro_arg *)((void *)0);
#line 1789
        tmp___5 = strlen((char const   *)buffer);
#line 1789
        tmp___6 = malloc(tmp___5 + 1UL);
#line 1789
        (*current_line)->line = (char *)tmp___6;
        }
#line 1790
        if (! (*current_line)->line) {
          {
#line 1792
          printerr(1, "out of memory\n");
#line 1793
          free((void *)*current_line);
#line 1794
          *current_line = (struct macro_line *)((void *)0);
          }
#line 1795
          goto while_continue___0;
        }
#line 1797
        ptr = (char const   *)buffer;
#line 1798
        newptr = (*current_line)->line;
        {
#line 1799
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 1799
          if (! *ptr) {
#line 1799
            goto while_break___9;
          }
#line 1802
          last_arg = & (*current_line)->args;
#line 1803
          p = 0U;
          {
#line 1803
          while (1) {
            while_continue___10: /* CIL Label */ ;
#line 1803
            if (! (p < firstmacro->numargs)) {
#line 1803
              goto while_break___10;
            }
            {
#line 1805
            tmp___9 = strlen((char const   *)*(firstmacro->args + p));
#line 1805
            tmp___10 = strncmp(ptr, (char const   *)*(firstmacro->args + p), tmp___9);
            }
#line 1805
            if (tmp___10 == 0) {
              {
#line 1809
              tmp___7 = malloc(sizeof(struct macro_arg ));
#line 1809
              newarg = (struct macro_arg *)tmp___7;
              }
#line 1810
              if (! newarg) {
                {
#line 1812
                printerr(1, "out of memory\n");
                }
#line 1813
                goto while_break___10;
              }
              {
#line 1815
              newarg->next = (struct macro_arg *)((void *)0);
#line 1816
              *last_arg = newarg;
#line 1817
              last_arg = & newarg->next;
#line 1818
              newarg->pos = (unsigned int )(newptr - (*current_line)->line);
#line 1819
              newarg->which = p;
#line 1822
              tmp___8 = strlen((char const   *)*(firstmacro->args + p));
#line 1822
              ptr += tmp___8 - 1UL;
              }
#line 1823
              goto while_break___10;
            }
#line 1803
            p ++;
          }
          while_break___10: /* CIL Label */ ;
          }
#line 1826
          tmp___11 = newptr;
#line 1826
          newptr ++;
#line 1826
          tmp___12 = ptr;
#line 1826
          ptr ++;
#line 1826
          *tmp___11 = (char )*tmp___12;
        }
        while_break___9: /* CIL Label */ ;
        }
#line 1828
        *newptr = (char)0;
#line 1829
        if (verbose >= 7) {
          {
#line 1830
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"added line to macro (cmd = %d): %s\n",
                  cmd, (*current_line)->line);
          }
        }
#line 1832
        if (cmd == 86) {
#line 1833
          define_macro = 0;
        }
#line 1834
        goto while_continue___0;
      }
      {
#line 1839
      if (cmd == 22) {
#line 1839
        goto case_22;
      }
#line 1854
      if (cmd == 23) {
#line 1854
        goto case_23;
      }
#line 1878
      if (cmd == 24) {
#line 1878
        goto case_24;
      }
#line 1883
      if (cmd == 25) {
#line 1883
        goto case_25;
      }
#line 1892
      if (cmd == 0) {
#line 1892
        goto case_0;
      }
#line 1904
      if (cmd == 26) {
#line 1904
        goto case_26;
      }
#line 1907
      if (cmd == 63) {
#line 1907
        goto case_63;
      }
#line 1912
      if (cmd == 27) {
#line 1912
        goto case_27;
      }
#line 1916
      if (cmd == 1) {
#line 1916
        goto case_1;
      }
#line 1920
      if (cmd == 28) {
#line 1920
        goto case_28;
      }
#line 1924
      if (cmd == 2) {
#line 1924
        goto case_2;
      }
#line 1928
      if (cmd == 29) {
#line 1928
        goto case_29;
      }
#line 1931
      if (cmd == 30) {
#line 1931
        goto case_30;
      }
#line 1934
      if (cmd == 31) {
#line 1934
        goto case_31;
      }
#line 1944
      if (cmd == 64) {
#line 1944
        goto case_64;
      }
#line 1947
      if (cmd == 3) {
#line 1947
        goto case_3;
      }
#line 1951
      if (cmd == 65) {
#line 1951
        goto case_65;
      }
#line 1954
      if (cmd == 32) {
#line 1954
        goto case_32;
      }
#line 1973
      if (cmd == 66) {
#line 1973
        goto case_66;
      }
#line 1994
      if (cmd == 33) {
#line 1994
        goto case_33;
      }
#line 1997
      if (cmd == 4) {
#line 1997
        goto case_4;
      }
#line 2000
      if (cmd == 67) {
#line 2000
        goto case_67;
      }
#line 2006
      if (cmd == 68) {
#line 2006
        goto case_68;
      }
#line 2030
      if (cmd == 34) {
#line 2030
        goto case_34;
      }
#line 2040
      if (cmd == 35) {
#line 2040
        goto case_35;
      }
#line 2044
      if (cmd == 5) {
#line 2044
        goto case_5;
      }
#line 2048
      if (cmd == 36) {
#line 2048
        goto case_36;
      }
#line 2052
      if (cmd == 6) {
#line 2052
        goto case_6;
      }
#line 2056
      if (cmd == 69) {
#line 2056
        goto case_69;
      }
#line 2074
      if (cmd == 70) {
#line 2074
        goto case_70;
      }
#line 2081
      if (cmd == 71) {
#line 2081
        goto case_71;
      }
#line 2185
      if (cmd == 37) {
#line 2185
        goto case_37;
      }
#line 2189
      if (cmd == 7) {
#line 2189
        goto case_7___0;
      }
#line 2193
      if (cmd == 38) {
#line 2193
        goto case_38;
      }
#line 2197
      if (cmd == 8) {
#line 2197
        goto case_8___0;
      }
#line 2201
      if (cmd == 39) {
#line 2201
        goto case_39;
      }
#line 2205
      if (cmd == 40) {
#line 2205
        goto case_40;
      }
#line 2208
      if (cmd == 72) {
#line 2208
        goto case_72;
      }
#line 2213
      if (cmd == 9) {
#line 2213
        goto case_9___0;
      }
#line 2217
      if (cmd == 10) {
#line 2217
        goto case_10___0;
      }
#line 2221
      if (cmd == 41) {
#line 2221
        goto case_41;
      }
#line 2240
      if (cmd == 11) {
#line 2240
        goto case_11___0;
      }
#line 2244
      if (cmd == 12) {
#line 2244
        goto case_12___0;
      }
#line 2248
      if (cmd == 42) {
#line 2248
        goto case_42;
      }
#line 2253
      if (cmd == 13) {
#line 2253
        goto case_13___0;
      }
#line 2258
      if (cmd == 43) {
#line 2258
        goto case_43;
      }
#line 2267
      if (cmd == 44) {
#line 2267
        goto case_44;
      }
#line 2275
      if (cmd == 14) {
#line 2275
        goto case_14___0;
      }
#line 2279
      if (cmd == 15) {
#line 2279
        goto case_15___0;
      }
#line 2283
      if (cmd == 73) {
#line 2283
        goto case_73;
      }
#line 2289
      if (cmd == 45) {
#line 2289
        goto case_45;
      }
#line 2292
      if (cmd == 46) {
#line 2292
        goto case_46;
      }
#line 2298
      if (cmd == 16) {
#line 2298
        goto case_16___0;
      }
#line 2301
      if (cmd == 47) {
#line 2301
        goto case_47;
      }
#line 2305
      if (cmd == 74) {
#line 2305
        goto case_74;
      }
#line 2311
      if (cmd == 48) {
#line 2311
        goto case_48;
      }
#line 2314
      if (cmd == 49) {
#line 2314
        goto case_49;
      }
#line 2320
      if (cmd == 17) {
#line 2320
        goto case_17___0;
      }
#line 2323
      if (cmd == 50) {
#line 2323
        goto case_50;
      }
#line 2327
      if (cmd == 51) {
#line 2327
        goto case_51;
      }
#line 2331
      if (cmd == 52) {
#line 2331
        goto case_52;
      }
#line 2346
      if (cmd == 53) {
#line 2346
        goto case_53;
      }
#line 2349
      if (cmd == 54) {
#line 2349
        goto case_54;
      }
#line 2358
      if (cmd == 55) {
#line 2358
        goto case_55;
      }
#line 2364
      if (cmd == 57) {
#line 2364
        goto case_57;
      }
#line 2370
      if (cmd == 58) {
#line 2370
        goto case_58;
      }
#line 2376
      if (cmd == 59) {
#line 2376
        goto case_59;
      }
#line 2382
      if (cmd == 60) {
#line 2382
        goto case_60;
      }
#line 2397
      if (cmd == 61) {
#line 2397
        goto case_61;
      }
#line 2405
      if (cmd == 78) {
#line 2405
        goto case_78;
      }
#line 2405
      if (cmd == 21) {
#line 2405
        goto case_78;
      }
#line 2405
      if (cmd == 75) {
#line 2405
        goto case_78;
      }
#line 2405
      if (cmd == 18) {
#line 2405
        goto case_78;
      }
#line 2449
      if (cmd == 76) {
#line 2449
        goto case_76;
      }
#line 2449
      if (cmd == 19) {
#line 2449
        goto case_76;
      }
#line 2467
      if (cmd == 77) {
#line 2467
        goto case_77;
      }
#line 2467
      if (cmd == 20) {
#line 2467
        goto case_77;
      }
#line 2495
      if (cmd == 84) {
#line 2495
        goto case_84;
      }
#line 2498
      if (cmd == 62) {
#line 2498
        goto case_62;
      }
#line 2501
      if (cmd == 79) {
#line 2501
        goto case_79;
      }
#line 2551
      if (cmd == 80) {
#line 2551
        goto case_80;
      }
#line 2583
      if (cmd == 81) {
#line 2583
        goto case_81___0;
      }
#line 2589
      if (cmd == 82) {
#line 2589
        goto case_82___0;
      }
#line 2598
      if (cmd == 83) {
#line 2598
        goto case_83___0;
      }
#line 2609
      if (cmd == 85) {
#line 2609
        goto case_85;
      }
#line 2658
      if (cmd == 86) {
#line 2658
        goto case_86;
      }
#line 2662
      if (cmd == 87) {
#line 2662
        goto case_87;
      }
#line 2676
      goto switch_default___0;
      case_22: /* CIL Label */ 
      {
#line 1840
      r = rd_a_hl(& ptr);
      }
#line 1840
      if (! r) {
#line 1841
        goto switch_break___0;
      }
#line 1842
      if (r == 2) {
        {
#line 1844
        r = rd_rr_(& ptr);
        }
#line 1844
        if (! r) {
#line 1845
          goto switch_break___0;
        }
        {
#line 1846
        wrtb(237);
#line 1847
        r --;
#line 1847
        wrtb(74 + 16 * r);
        }
#line 1848
        goto switch_break___0;
      }
      {
#line 1850
      r = rd_r(& ptr);
      }
#line 1850
      if (! r) {
#line 1851
        goto switch_break___0;
      }
      {
#line 1852
      r --;
#line 1852
      wrtb(136 + r);
      }
#line 1853
      goto switch_break___0;
      case_23: /* CIL Label */ 
      {
#line 1855
      r = rd_r_add(& ptr);
      }
#line 1855
      if (! r) {
#line 1856
        goto switch_break___0;
      }
#line 1857
      if (r == 15) {
        {
#line 1859
        r = rd_rrxx(& ptr);
        }
#line 1859
        if (! r) {
#line 1860
          goto switch_break___0;
        }
        {
#line 1861
        r --;
#line 1861
        wrtb(9 + 16 * r);
        }
#line 1862
        goto switch_break___0;
      }
      {
#line 1864
      tmp___13 = has_argument(& ptr);
      }
#line 1864
      if (tmp___13) {
#line 1866
        if (r != 8) {
          {
#line 1868
          printerr(1, "parse error before: %s\n", ptr);
          }
#line 1869
          goto switch_break___0;
        }
        {
#line 1871
        r = rd_r(& ptr);
        }
#line 1871
        if (! r) {
#line 1872
          goto switch_break___0;
        }
        {
#line 1873
        r --;
#line 1873
        wrtb(128 + r);
        }
#line 1874
        goto switch_break___0;
      }
      {
#line 1876
      r --;
#line 1876
      wrtb(128 + r);
      }
#line 1877
      goto switch_break___0;
      case_24: /* CIL Label */ 
      {
#line 1879
      r = rd_r(& ptr);
      }
#line 1879
      if (! r) {
#line 1880
        goto switch_break___0;
      }
      {
#line 1881
      r --;
#line 1881
      wrtb(160 + r);
      }
#line 1882
      goto switch_break___0;
      case_25: /* CIL Label */ 
      {
#line 1884
      tmp___14 = rd_0_7(& ptr);
      }
#line 1884
      if (! tmp___14) {
#line 1885
        goto switch_break___0;
      }
      {
#line 1886
      rd_comma(& ptr);
#line 1887
      r = rd_r_(& ptr);
      }
#line 1887
      if (! r) {
#line 1888
        goto switch_break___0;
      }
      {
#line 1889
      wrtb(203);
#line 1890
      wrtb(64 + (r - 1));
      }
#line 1891
      goto switch_break___0;
      case_0: /* CIL Label */ 
      {
#line 1893
      r = rd_cc(& ptr);
      }
#line 1893
      if (r) {
        {
#line 1899
        r --;
#line 1899
        wrtb(196 + 8 * r);
#line 1900
        rd_comma(& ptr);
        }
      } else {
        {
#line 1895
        wrtb(205);
        }
      }
      {
#line 1902
      rd_wrt_addr(& ptr, (char )'\000');
      }
#line 1903
      goto switch_break___0;
      case_26: /* CIL Label */ 
      {
#line 1905
      wrtb(63);
      }
#line 1906
      goto switch_break___0;
      case_63: /* CIL Label */ 
      {
#line 1908
      r = rd_r(& ptr);
      }
#line 1908
      if (! r) {
#line 1909
        goto switch_break___0;
      }
      {
#line 1910
      r --;
#line 1910
      wrtb(184 + r);
      }
#line 1911
      goto switch_break___0;
      case_27: /* CIL Label */ 
      {
#line 1913
      wrtb(237);
#line 1914
      wrtb(169);
      }
#line 1915
      goto switch_break___0;
      case_1: /* CIL Label */ 
      {
#line 1917
      wrtb(237);
#line 1918
      wrtb(185);
      }
#line 1919
      goto switch_break___0;
      case_28: /* CIL Label */ 
      {
#line 1921
      wrtb(237);
#line 1922
      wrtb(161);
      }
#line 1923
      goto switch_break___0;
      case_2: /* CIL Label */ 
      {
#line 1925
      wrtb(237);
#line 1926
      wrtb(177);
      }
#line 1927
      goto switch_break___0;
      case_29: /* CIL Label */ 
      {
#line 1929
      wrtb(47);
      }
#line 1930
      goto switch_break___0;
      case_30: /* CIL Label */ 
      {
#line 1932
      wrtb(39);
      }
#line 1933
      goto switch_break___0;
      case_31: /* CIL Label */ 
      {
#line 1935
      r = rd_r_rr(& ptr);
      }
#line 1935
      if (! r) {
#line 1936
        goto switch_break___0;
      }
#line 1937
      if (r < 0) {
        {
#line 1939
        r ++;
#line 1939
        wrtb(5 - 8 * r);
        }
#line 1940
        goto switch_break___0;
      }
      {
#line 1942
      r --;
#line 1942
      wrtb(11 + 16 * r);
      }
#line 1943
      goto switch_break___0;
      case_64: /* CIL Label */ 
      {
#line 1945
      wrtb(243);
      }
#line 1946
      goto switch_break___0;
      case_3: /* CIL Label */ 
      {
#line 1948
      wrtb(16);
#line 1949
      rd_wrt_jr(& ptr, (char )'\000');
      }
#line 1950
      goto switch_break___0;
      case_65: /* CIL Label */ 
      {
#line 1952
      wrtb(251);
      }
#line 1953
      goto switch_break___0;
      case_32: /* CIL Label */ 
#line 1955
      if (! lastlabel) {
        {
#line 1957
        printerr(1, "EQU without label\n");
        }
#line 1958
        goto switch_break___0;
      }
      {
#line 1960
      new_reference(ptr, 6, (char)0, 0);
      }
#line 1961
      if (verbose >= 4) {
#line 1963
        if (lastlabel->valid) {
          {
#line 1964
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Assigned value %d to label %s.\n",
                  lastlabel->value, lastlabel->name);
          }
        } else {
          {
#line 1967
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Scheduled label %s for later computation.\n",
                  lastlabel->name);
          }
        }
      }
#line 1971
      ptr = "";
#line 1972
      goto switch_break___0;
      case_66: /* CIL Label */ 
      {
#line 1974
      r = rd_ex1(& ptr);
      }
#line 1974
      if (! r) {
#line 1975
        goto switch_break___0;
      }
      {
#line 1978
      if (r == 2) {
#line 1978
        goto case_2___0;
      }
#line 1983
      if (r == 3) {
#line 1983
        goto case_3___0;
      }
#line 1988
      goto switch_default;
      case_2___0: /* CIL Label */ 
      {
#line 1979
      tmp___15 = rd_hl(& ptr);
      }
#line 1979
      if (! tmp___15) {
#line 1980
        goto switch_break___1;
      }
      {
#line 1981
      wrtb(235);
      }
#line 1982
      goto switch_break___1;
      case_3___0: /* CIL Label */ 
      {
#line 1984
      tmp___16 = rd_af_(& ptr);
      }
#line 1984
      if (! tmp___16) {
#line 1985
        goto switch_break___1;
      }
      {
#line 1986
      wrtb(8);
      }
#line 1987
      goto switch_break___1;
      switch_default: /* CIL Label */ 
      {
#line 1989
      tmp___17 = rd_hlx(& ptr);
      }
#line 1989
      if (! tmp___17) {
#line 1990
        goto switch_break___1;
      }
      {
#line 1991
      wrtb(227);
      }
      switch_break___1: /* CIL Label */ ;
      }
#line 1993
      goto switch_break___0;
      case_33: /* CIL Label */ 
      {
#line 1995
      wrtb(217);
      }
#line 1996
      goto switch_break___0;
      case_4: /* CIL Label */ 
      {
#line 1998
      wrtb(118);
      }
#line 1999
      goto switch_break___0;
      case_67: /* CIL Label */ 
      {
#line 2001
      r = rd_0_2(& ptr);
      }
#line 2001
      if (! r) {
#line 2002
        goto switch_break___0;
      }
      {
#line 2003
      wrtb(237);
#line 2004
      r --;
#line 2004
      wrtb(70 + 8 * r);
      }
#line 2005
      goto switch_break___0;
      case_68: /* CIL Label */ 
      {
#line 2007
      r = rd_in(& ptr);
      }
#line 2007
      if (! r) {
#line 2008
        goto switch_break___0;
      }
#line 2009
      if (r == 8) {
        {
#line 2012
        r = rd_nnc(& ptr);
        }
#line 2012
        if (! r) {
#line 2013
          goto switch_break___0;
        }
#line 2014
        if (r == 1) {
          {
#line 2016
          wrtb(237);
#line 2017
          wrtb(120);
          }
#line 2018
          goto switch_break___0;
        }
        {
#line 2020
        tmp___18 = readbyte;
#line 2021
        wrtb(219);
#line 2022
        new_reference(tmp___18, 4, (char )')', 1);
        }
#line 2023
        goto switch_break___0;
      }
      {
#line 2025
      tmp___19 = rd_c(& ptr);
      }
#line 2025
      if (! tmp___19) {
#line 2026
        goto switch_break___0;
      }
      {
#line 2027
      wrtb(237);
#line 2028
      r --;
#line 2028
      wrtb(64 + 8 * r);
      }
#line 2029
      goto switch_break___0;
      case_34: /* CIL Label */ 
      {
#line 2031
      r = rd_r_rr(& ptr);
      }
#line 2031
      if (! r) {
#line 2032
        goto switch_break___0;
      }
#line 2033
      if (r < 0) {
        {
#line 2035
        r ++;
#line 2035
        wrtb(4 - 8 * r);
        }
#line 2036
        goto switch_break___0;
      }
      {
#line 2038
      r --;
#line 2038
      wrtb(3 + 16 * r);
      }
#line 2039
      goto switch_break___0;
      case_35: /* CIL Label */ 
      {
#line 2041
      wrtb(237);
#line 2042
      wrtb(170);
      }
#line 2043
      goto switch_break___0;
      case_5: /* CIL Label */ 
      {
#line 2045
      wrtb(237);
#line 2046
      wrtb(186);
      }
#line 2047
      goto switch_break___0;
      case_36: /* CIL Label */ 
      {
#line 2049
      wrtb(237);
#line 2050
      wrtb(162);
      }
#line 2051
      goto switch_break___0;
      case_6: /* CIL Label */ 
      {
#line 2053
      wrtb(237);
#line 2054
      wrtb(178);
      }
#line 2055
      goto switch_break___0;
      case_69: /* CIL Label */ 
      {
#line 2057
      r = rd_jp(& ptr);
      }
#line 2058
      if (r < 0) {
        {
#line 2060
        wrtb(233);
        }
#line 2061
        goto switch_break___0;
      }
#line 2063
      if (r == 0) {
        {
#line 2065
        wrtb(195);
        }
      } else {
        {
#line 2069
        r --;
#line 2069
        wrtb(194 + 8 * r);
#line 2070
        rd_comma(& ptr);
        }
      }
      {
#line 2072
      rd_wrt_addr(& ptr, (char )'\000');
      }
#line 2073
      goto switch_break___0;
      case_70: /* CIL Label */ 
      {
#line 2075
      r = rd_jr(& ptr);
      }
#line 2076
      if (r) {
        {
#line 2077
        rd_comma(& ptr);
        }
      }
      {
#line 2078
      wrtb(24 + 8 * r);
#line 2079
      rd_wrt_jr(& ptr, (char )'\000');
      }
#line 2080
      goto switch_break___0;
      case_71: /* CIL Label */ 
      {
#line 2082
      r = rd_ld(& ptr);
      }
#line 2082
      if (! r) {
#line 2083
        goto switch_break___0;
      }
      {
#line 2087
      if (r == 18) {
#line 2087
        goto case_18;
      }
#line 2087
      if (r == 17) {
#line 2087
        goto case_18;
      }
#line 2092
      if (r == 13) {
#line 2092
        goto case_13;
      }
#line 2096
      if (r == 21) {
#line 2096
        goto case_21;
      }
#line 2109
      if (r == 14) {
#line 2109
        goto case_14;
      }
#line 2136
      if (r == 12) {
#line 2136
        goto case_12;
      }
#line 2136
      if (r == 11) {
#line 2136
        goto case_12;
      }
#line 2136
      if (r == 10) {
#line 2136
        goto case_12;
      }
#line 2136
      if (r == 9) {
#line 2136
        goto case_12;
      }
#line 2136
      if (r == 8) {
#line 2136
        goto case_12;
      }
#line 2136
      if (r == 7) {
#line 2136
        goto case_12;
      }
#line 2142
      if (r == 2) {
#line 2142
        goto case_2___1;
      }
#line 2142
      if (r == 1) {
#line 2142
        goto case_2___1;
      }
#line 2154
      if (r == 3) {
#line 2154
        goto case_3___1;
      }
#line 2160
      if (r == 16) {
#line 2160
        goto case_16;
      }
#line 2160
      if (r == 15) {
#line 2160
        goto case_16;
      }
#line 2166
      if (r == 4) {
#line 2166
        goto case_4___0;
      }
#line 2084
      goto switch_break___2;
      case_18: /* CIL Label */ 
      case_17: /* CIL Label */ 
      {
#line 2088
      tmp___20 = rd_a(& ptr);
      }
#line 2088
      if (! tmp___20) {
#line 2089
        goto switch_break___2;
      }
      {
#line 2090
      wrtb(2 + 16 * (r == 18));
      }
#line 2091
      goto switch_break___2;
      case_13: /* CIL Label */ 
      {
#line 2093
      r = rd_ld_hl(& ptr);
#line 2094
      r --;
#line 2094
      wrtb(112 + r);
      }
#line 2095
      goto switch_break___2;
      case_21: /* CIL Label */ 
      {
#line 2097
      r = rd_ld_nn(& ptr);
      }
#line 2097
      if (! r) {
#line 2098
        goto switch_break___2;
      }
#line 2099
      if (r == 6) {
        {
#line 2101
        wrtb(34 + 16 * (r == 6));
#line 2102
        write_word();
        }
#line 2103
        goto switch_break___2;
      } else
#line 2099
      if (r == 5) {
        {
#line 2101
        wrtb(34 + 16 * (r == 6));
#line 2102
        write_word();
        }
#line 2103
        goto switch_break___2;
      }
      {
#line 2105
      wrtb(237);
#line 2106
      r --;
#line 2106
      wrtb(67 + 16 * r);
#line 2107
      write_word();
      }
#line 2108
      goto switch_break___2;
      case_14: /* CIL Label */ 
      {
#line 2110
      r = rd_lda(& ptr);
      }
#line 2110
      if (! r) {
#line 2111
        goto switch_break___2;
      }
#line 2112
      if (r == 11) {
        {
#line 2114
        wrtb(58);
#line 2115
        write_word();
        }
#line 2116
        goto switch_break___2;
      }
#line 2118
      if (r == 9) {
        {
#line 2120
        wrtb(237);
#line 2121
        wrtb(87 + 8 * (r == 10));
        }
#line 2122
        goto switch_break___2;
      } else
#line 2118
      if (r == 10) {
        {
#line 2120
        wrtb(237);
#line 2121
        wrtb(87 + 8 * (r == 10));
        }
#line 2122
        goto switch_break___2;
      }
#line 2124
      if (r < 0) {
        {
#line 2126
        r ++;
#line 2126
        wrtb(10 - 16 * r);
        }
#line 2127
        goto switch_break___2;
      }
      {
#line 2129
      r --;
#line 2129
      wrtb(120 + r);
      }
#line 2130
      goto switch_break___2;
      case_12: /* CIL Label */ 
      case_11: /* CIL Label */ 
      case_10: /* CIL Label */ 
      case_9: /* CIL Label */ 
      case_8: /* CIL Label */ 
      case_7: /* CIL Label */ 
      {
#line 2137
      s = rd_ldbcdehla(& ptr);
      }
#line 2137
      if (! s) {
#line 2138
        goto switch_break___2;
      }
      {
#line 2139
      wrtb((64 + 8 * (r - 7)) + (s - 1));
      }
#line 2140
      goto switch_break___2;
      case_2___1: /* CIL Label */ 
      case_1___0: /* CIL Label */ 
      {
#line 2143
      s = rd_nn_nn(& ptr);
      }
#line 2144
      if (s == 1) {
        {
#line 2146
        wrtb(237);
#line 2147
        wrtb(75 + 16 * (r == 2));
#line 2148
        write_word();
        }
#line 2149
        goto switch_break___2;
      }
      {
#line 2151
      wrtb(1 + (r == 2) * 16);
#line 2152
      write_word();
      }
#line 2153
      goto switch_break___2;
      case_3___1: /* CIL Label */ 
      {
#line 2155
      r = rd_nn_nn(& ptr);
#line 2156
      wrtb(33 + (r == 1) * 9);
#line 2157
      write_word();
      }
#line 2158
      goto switch_break___2;
      case_16: /* CIL Label */ 
      case_15: /* CIL Label */ 
      {
#line 2161
      tmp___21 = rd_a(& ptr);
      }
#line 2161
      if (! tmp___21) {
#line 2162
        goto switch_break___2;
      }
      {
#line 2163
      wrtb(237);
#line 2164
      wrtb(71 + 8 * (r == 16));
      }
#line 2165
      goto switch_break___2;
      case_4___0: /* CIL Label */ 
      {
#line 2167
      r = rd_sp(& ptr);
      }
#line 2168
      if (r == 1) {
        {
#line 2170
        wrtb(249);
        }
#line 2171
        goto switch_break___2;
      }
#line 2173
      if (r == 0) {
        {
#line 2175
        wrtb(49);
#line 2176
        write_word();
        }
#line 2177
        goto switch_break___2;
      }
      {
#line 2179
      wrtb(237);
#line 2180
      wrtb(123);
#line 2181
      write_word();
      }
#line 2182
      goto switch_break___2;
      switch_break___2: /* CIL Label */ ;
      }
#line 2184
      goto switch_break___0;
      case_37: /* CIL Label */ 
      {
#line 2186
      wrtb(237);
#line 2187
      wrtb(168);
      }
#line 2188
      goto switch_break___0;
      case_7___0: /* CIL Label */ 
      {
#line 2190
      wrtb(237);
#line 2191
      wrtb(184);
      }
#line 2192
      goto switch_break___0;
      case_38: /* CIL Label */ 
      {
#line 2194
      wrtb(237);
#line 2195
      wrtb(160);
      }
#line 2196
      goto switch_break___0;
      case_8___0: /* CIL Label */ 
      {
#line 2198
      wrtb(237);
#line 2199
      wrtb(176);
      }
#line 2200
      goto switch_break___0;
      case_39: /* CIL Label */ 
      {
#line 2202
      wrtb(237);
#line 2203
      wrtb(68);
      }
#line 2204
      goto switch_break___0;
      case_40: /* CIL Label */ 
      {
#line 2206
      wrtb(0);
      }
#line 2207
      goto switch_break___0;
      case_72: /* CIL Label */ 
      {
#line 2209
      r = rd_r(& ptr);
      }
#line 2209
      if (! r) {
#line 2210
        goto switch_break___0;
      }
      {
#line 2211
      r --;
#line 2211
      wrtb(176 + r);
      }
#line 2212
      goto switch_break___0;
      case_9___0: /* CIL Label */ 
      {
#line 2214
      wrtb(237);
#line 2215
      wrtb(187);
      }
#line 2216
      goto switch_break___0;
      case_10___0: /* CIL Label */ 
      {
#line 2218
      wrtb(237);
#line 2219
      wrtb(179);
      }
#line 2220
      goto switch_break___0;
      case_41: /* CIL Label */ 
      {
#line 2222
      r = rd_nnc(& ptr);
      }
#line 2222
      if (! r) {
#line 2223
        goto switch_break___0;
      }
#line 2224
      if (r == 1) {
        {
#line 2226
        r = rd_out(& ptr);
        }
#line 2226
        if (! r) {
#line 2227
          goto switch_break___0;
        }
        {
#line 2228
        wrtb(237);
#line 2229
        r --;
#line 2229
        wrtb(65 + 8 * r);
        }
#line 2230
        goto switch_break___0;
      }
      {
#line 2232
      tmp___22 = rd_a(& ptr);
      }
#line 2232
      if (! tmp___22) {
#line 2233
        goto switch_break___0;
      }
      {
#line 2235
      tmp___23 = readbyte;
#line 2236
      wrtb(211);
#line 2237
      new_reference(tmp___23, 4, (char )')', 1);
      }
#line 2239
      goto switch_break___0;
      case_11___0: /* CIL Label */ 
      {
#line 2241
      wrtb(237);
#line 2242
      wrtb(171);
      }
#line 2243
      goto switch_break___0;
      case_12___0: /* CIL Label */ 
      {
#line 2245
      wrtb(237);
#line 2246
      wrtb(163);
      }
#line 2247
      goto switch_break___0;
      case_42: /* CIL Label */ 
      {
#line 2249
      r = rd_stack(& ptr);
      }
#line 2249
      if (! r) {
#line 2250
        goto switch_break___0;
      }
      {
#line 2251
      r --;
#line 2251
      wrtb(193 + 16 * r);
      }
#line 2252
      goto switch_break___0;
      case_13___0: /* CIL Label */ 
      {
#line 2254
      r = rd_stack(& ptr);
      }
#line 2254
      if (! r) {
#line 2255
        goto switch_break___0;
      }
      {
#line 2256
      r --;
#line 2256
      wrtb(197 + 16 * r);
      }
#line 2257
      goto switch_break___0;
      case_43: /* CIL Label */ 
      {
#line 2259
      tmp___24 = rd_0_7(& ptr);
      }
#line 2259
      if (! tmp___24) {
#line 2260
        goto switch_break___0;
      }
      {
#line 2261
      rd_comma(& ptr);
#line 2262
      r = rd_r_(& ptr);
      }
#line 2262
      if (! r) {
#line 2263
        goto switch_break___0;
      }
      {
#line 2264
      wrtb(203);
#line 2265
      r --;
#line 2265
      wrtb(128 + r);
      }
#line 2266
      goto switch_break___0;
      case_44: /* CIL Label */ 
      {
#line 2268
      r = rd_cc(& ptr);
      }
#line 2268
      if (! r) {
        {
#line 2270
        wrtb(201);
        }
#line 2271
        goto switch_break___0;
      }
      {
#line 2273
      r --;
#line 2273
      wrtb(192 + 8 * r);
      }
#line 2274
      goto switch_break___0;
      case_14___0: /* CIL Label */ 
      {
#line 2276
      wrtb(237);
#line 2277
      wrtb(77);
      }
#line 2278
      goto switch_break___0;
      case_15___0: /* CIL Label */ 
      {
#line 2280
      wrtb(237);
#line 2281
      wrtb(69);
      }
#line 2282
      goto switch_break___0;
      case_73: /* CIL Label */ 
      {
#line 2284
      r = rd_r_(& ptr);
      }
#line 2284
      if (! r) {
#line 2285
        goto switch_break___0;
      }
      {
#line 2286
      wrtb(203);
#line 2287
      r --;
#line 2287
      wrtb(16 + r);
      }
#line 2288
      goto switch_break___0;
      case_45: /* CIL Label */ 
      {
#line 2290
      wrtb(23);
      }
#line 2291
      goto switch_break___0;
      case_46: /* CIL Label */ 
      {
#line 2293
      r = rd_r_(& ptr);
      }
#line 2293
      if (! r) {
#line 2294
        goto switch_break___0;
      }
      {
#line 2295
      wrtb(203);
#line 2296
      r --;
#line 2296
      wrtb(r);
      }
#line 2297
      goto switch_break___0;
      case_16___0: /* CIL Label */ 
      {
#line 2299
      wrtb(7);
      }
#line 2300
      goto switch_break___0;
      case_47: /* CIL Label */ 
      {
#line 2302
      wrtb(237);
#line 2303
      wrtb(111);
      }
#line 2304
      goto switch_break___0;
      case_74: /* CIL Label */ 
      {
#line 2306
      r = rd_r_(& ptr);
      }
#line 2306
      if (! r) {
#line 2307
        goto switch_break___0;
      }
      {
#line 2308
      wrtb(203);
#line 2309
      r --;
#line 2309
      wrtb(24 + r);
      }
#line 2310
      goto switch_break___0;
      case_48: /* CIL Label */ 
      {
#line 2312
      wrtb(31);
      }
#line 2313
      goto switch_break___0;
      case_49: /* CIL Label */ 
      {
#line 2315
      r = rd_r_(& ptr);
      }
#line 2315
      if (! r) {
#line 2316
        goto switch_break___0;
      }
      {
#line 2317
      wrtb(203);
#line 2318
      r --;
#line 2318
      wrtb(8 + r);
      }
#line 2319
      goto switch_break___0;
      case_17___0: /* CIL Label */ 
      {
#line 2321
      wrtb(15);
      }
#line 2322
      goto switch_break___0;
      case_50: /* CIL Label */ 
      {
#line 2324
      wrtb(237);
#line 2325
      wrtb(103);
      }
#line 2326
      goto switch_break___0;
      case_51: /* CIL Label */ 
      {
#line 2328
      new_reference(ptr, 2, (char )'\000', 1);
#line 2329
      ptr = "";
      }
#line 2330
      goto switch_break___0;
      case_52: /* CIL Label */ 
      {
#line 2332
      r = rd_a_hl(& ptr);
      }
#line 2332
      if (! r) {
#line 2333
        goto switch_break___0;
      }
#line 2334
      if (r == 2) {
        {
#line 2336
        r = rd_rr_(& ptr);
        }
#line 2336
        if (! r) {
#line 2337
          goto switch_break___0;
        }
        {
#line 2338
        wrtb(237);
#line 2339
        r --;
#line 2339
        wrtb(66 + 16 * r);
        }
#line 2340
        goto switch_break___0;
      }
      {
#line 2342
      r = rd_r(& ptr);
      }
#line 2342
      if (! r) {
#line 2343
        goto switch_break___0;
      }
      {
#line 2344
      r --;
#line 2344
      wrtb(152 + r);
      }
#line 2345
      goto switch_break___0;
      case_53: /* CIL Label */ 
      {
#line 2347
      wrtb(55);
      }
#line 2348
      goto switch_break___0;
      case_54: /* CIL Label */ 
      {
#line 2350
      tmp___25 = rd_0_7(& ptr);
      }
#line 2350
      if (! tmp___25) {
#line 2351
        goto switch_break___0;
      }
      {
#line 2352
      rd_comma(& ptr);
#line 2353
      r = rd_r_(& ptr);
      }
#line 2353
      if (! r) {
#line 2354
        goto switch_break___0;
      }
      {
#line 2355
      wrtb(203);
#line 2356
      r --;
#line 2356
      wrtb(192 + r);
      }
#line 2357
      goto switch_break___0;
      case_55: /* CIL Label */ 
      {
#line 2359
      r = rd_r_(& ptr);
      }
#line 2359
      if (! r) {
#line 2360
        goto switch_break___0;
      }
      {
#line 2361
      wrtb(203);
#line 2362
      r --;
#line 2362
      wrtb(32 + r);
      }
#line 2363
      goto switch_break___0;
      case_57: /* CIL Label */ 
      {
#line 2365
      r = rd_r_(& ptr);
      }
#line 2365
      if (! r) {
#line 2366
        goto switch_break___0;
      }
      {
#line 2367
      wrtb(203);
#line 2368
      r --;
#line 2368
      wrtb(48 + r);
      }
#line 2369
      goto switch_break___0;
      case_58: /* CIL Label */ 
      {
#line 2371
      r = rd_r_(& ptr);
      }
#line 2371
      if (! r) {
#line 2372
        goto switch_break___0;
      }
      {
#line 2373
      wrtb(203);
#line 2374
      r --;
#line 2374
      wrtb(40 + r);
      }
#line 2375
      goto switch_break___0;
      case_59: /* CIL Label */ 
      {
#line 2377
      r = rd_r_(& ptr);
      }
#line 2377
      if (! r) {
#line 2378
        goto switch_break___0;
      }
      {
#line 2379
      wrtb(203);
#line 2380
      r --;
#line 2380
      wrtb(56 + r);
      }
#line 2381
      goto switch_break___0;
      case_60: /* CIL Label */ 
      {
#line 2383
      r = rd_r(& ptr);
      }
#line 2383
      if (! r) {
#line 2384
        goto switch_break___0;
      }
      {
#line 2385
      tmp___26 = has_argument(& ptr);
      }
#line 2385
      if (tmp___26) {
#line 2387
        if (r != 8) {
          {
#line 2389
          printerr(1, "parse error before: %s\n", ptr);
          }
#line 2390
          goto switch_break___0;
        }
        {
#line 2392
        r = rd_r(& ptr);
        }
#line 2392
        if (! r) {
#line 2393
          goto switch_break___0;
        }
      }
      {
#line 2395
      r --;
#line 2395
      wrtb(144 + r);
      }
#line 2396
      goto switch_break___0;
      case_61: /* CIL Label */ 
      {
#line 2398
      r = rd_r(& ptr);
      }
#line 2398
      if (! r) {
#line 2399
        goto switch_break___0;
      }
      {
#line 2400
      r --;
#line 2400
      wrtb(168 + r);
      }
#line 2401
      goto switch_break___0;
      case_78: /* CIL Label */ 
      case_21___0: /* CIL Label */ 
      case_75: /* CIL Label */ 
      case_18___0: /* CIL Label */ 
      {
#line 2406
      ptr = delspc(ptr);
      }
      {
#line 2407
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 2409
        if ((int const   )*ptr == 34) {
#line 2409
          tmp___27 = 1;
        } else
#line 2409
        if ((int const   )*ptr == 39) {
#line 2409
          tmp___27 = 1;
        } else {
#line 2409
          tmp___27 = 0;
        }
#line 2409
        have_quote = tmp___27;
#line 2410
        if (have_quote) {
#line 2413
          quote = (int )*ptr;
#line 2414
          if (listfile) {
            {
#line 2416
            fprintf((FILE */* __restrict  */)listfile, (char const   */* __restrict  */)" ..");
#line 2417
            listdepth += 3;
            }
          }
#line 2419
          ptr ++;
          {
#line 2420
          while (1) {
            while_continue___12: /* CIL Label */ ;
#line 2420
            if (! ((int const   )*ptr != (int const   )quote)) {
#line 2420
              goto while_break___12;
            }
            {
#line 2422
            tmp___28 = rd_character(& ptr, (int *)((void *)0), 1);
#line 2422
            write_one_byte(tmp___28, 0);
            }
#line 2423
            if ((int const   )*ptr == 0) {
              {
#line 2425
              printerr(1, "end of line in quoted string\n");
              }
#line 2426
              goto while_break___12;
            }
          }
          while_break___12: /* CIL Label */ ;
          }
#line 2429
          ptr ++;
        } else {
          {
#line 2434
          new_reference(ptr, 4, (char )',', 1);
#line 2435
          skipword(& ptr, (char )',');
          }
        }
        {
#line 2437
        ptr = delspc(ptr);
        }
#line 2438
        if ((int const   )*ptr == 44) {
#line 2440
          ptr ++;
#line 2441
          goto while_continue___11;
        }
#line 2443
        if ((int const   )*ptr != 0) {
          {
#line 2444
          printerr(1, "junk in byte definition: %s\n", ptr);
          }
        }
#line 2445
        goto while_break___11;
      }
      while_break___11: /* CIL Label */ ;
      }
#line 2447
      goto switch_break___0;
      case_76: /* CIL Label */ 
      case_19: /* CIL Label */ 
      {
#line 2450
      r = rd_word(& ptr, (char )',');
      }
#line 2450
      if (! r) {
        {
#line 2452
        printerr(1, "No data for word definition\n");
        }
#line 2453
        goto switch_break___0;
      }
      {
#line 2455
      while (1) {
        while_continue___13: /* CIL Label */ ;
        {
#line 2457
        new_reference(readword, 3, (char )',', 1);
#line 2458
        ptr = delspc(ptr);
        }
#line 2459
        if ((int const   )*ptr != 44) {
#line 2460
          goto while_break___13;
        }
        {
#line 2461
        ptr ++;
#line 2462
        r = rd_word(& ptr, (char )',');
        }
#line 2462
        if (! r) {
          {
#line 2463
          printerr(1, "Missing expression in defw\n");
          }
        }
      }
      while_break___13: /* CIL Label */ ;
      }
#line 2465
      goto switch_break___0;
      case_77: /* CIL Label */ 
      case_20: /* CIL Label */ 
      {
#line 2468
      r = rd_expr(& ptr, (char )',', (int *)((void *)0), sp, 1);
      }
#line 2469
      if (r < 0) {
        {
#line 2471
        printerr(1, "ds should have its first argument >=0 (not -0x%x)\n", - r);
        }
#line 2473
        goto switch_break___0;
      }
      {
#line 2475
      ptr = delspc(ptr);
      }
#line 2476
      if (*ptr) {
        {
#line 2478
        rd_comma(& ptr);
#line 2479
        readbyte = (char const   *)0;
#line 2480
        rd_byte(& ptr, (char )'\000');
#line 2481
        writebyte = 0;
#line 2482
        new_reference(readbyte, 1, (char )'\000', r);
        }
#line 2483
        goto switch_break___0;
      }
#line 2485
      if (havelist) {
        {
#line 2487
        fprintf((FILE */* __restrict  */)listfile, (char const   */* __restrict  */)" 00...");
#line 2488
        listdepth += 6;
        }
      }
#line 2490
      i___0 = 0;
      {
#line 2490
      while (1) {
        while_continue___14: /* CIL Label */ ;
#line 2490
        if (! (i___0 < r)) {
#line 2490
          goto while_break___14;
        }
        {
#line 2492
        write_one_byte(0, 0);
#line 2490
        i___0 ++;
        }
      }
      while_break___14: /* CIL Label */ ;
      }
#line 2494
      goto switch_break___0;
      case_84: /* CIL Label */ 
#line 2496
      file_ended = 1;
#line 2497
      goto switch_break___0;
      case_62: /* CIL Label */ 
      {
#line 2499
      tmp___29 = rd_expr(& ptr, (char )'\000', (int *)((void *)0), sp, 1);
#line 2499
      addr = tmp___29 & 65535;
      }
#line 2500
      goto switch_break___0;
      case_79: /* CIL Label */ 
#line 2502
      if (sp + 1 >= 200) {
        {
#line 2504
        printerr(1, "stack overflow (circular include?)");
        }
#line 2505
        if (verbose >= 5) {
          {
#line 2508
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Stack dump:\nframe  line file\n");
#line 2509
          x = 0;
          }
          {
#line 2509
          while (1) {
            while_continue___15: /* CIL Label */ ;
#line 2509
            if (! (x < 200)) {
#line 2509
              goto while_break___15;
            }
            {
#line 2510
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%5d %5d %s\n",
                    x, stack[x].line, stack[x].name);
#line 2509
            x ++;
            }
          }
          while_break___15: /* CIL Label */ ;
          }
        }
#line 2513
        goto switch_break___0;
      }
      {
#line 2517
      tmp___30 = get_include_name(& ptr);
#line 2517
      nm = tmp___30;
      }
#line 2518
      if (! nm) {
#line 2519
        goto switch_break___0;
      }
      {
#line 2520
      tmp___31 = strlen((char const   *)nm);
#line 2520
      tmp___32 = malloc(sizeof(struct name ) + tmp___31);
#line 2520
      name = (struct name *)tmp___32;
      }
#line 2521
      if (! name) {
        {
#line 2523
        printerr(1, "out of memory while allocating name\n");
#line 2524
        free((void *)nm);
        }
#line 2525
        goto switch_break___0;
      }
      {
#line 2527
      strcpy((char */* __restrict  */)(name->name), (char const   */* __restrict  */)nm);
#line 2528
      free((void *)nm);
#line 2529
      sp ++;
#line 2530
      stack[sp].name = (char const   *)(name->name);
#line 2531
      stack[sp].shouldclose = 1;
#line 2532
      stack[sp].line = 0;
#line 2533
      stack[sp].file = open_include_file((char const   *)(name->name), & stack[sp].dir,
                                         "r");
      }
#line 2535
      if (! stack[sp].file) {
        {
#line 2537
        printerr(1, "unable to open file %s\n", name->name);
#line 2538
        free((void *)name);
#line 2539
        sp --;
        }
#line 2540
        goto switch_break___0;
      }
#line 2542
      name->next = firstname;
#line 2543
      name->prev = (struct name *)((void *)0);
#line 2544
      if (name->next) {
#line 2545
        (name->next)->prev = name;
      }
#line 2546
      firstname = name;
#line 2547
      if (verbose >= 4) {
        {
#line 2548
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Reading file %s\n",
                name->name);
        }
      }
#line 2550
      goto switch_break___0;
      case_80: /* CIL Label */ 
      {
#line 2554
      tmp___33 = get_include_name(& ptr);
#line 2554
      name___0 = tmp___33;
      }
#line 2555
      if (! name___0) {
#line 2556
        goto switch_break___0;
      }
      {
#line 2557
      incfile = open_include_file((char const   *)name___0, (struct includedir **)((void *)0),
                                  "rb");
      }
#line 2558
      if (! incfile) {
        {
#line 2560
        printerr(1, "unable to open binary file %s\n", name___0);
#line 2561
        free((void *)name___0);
        }
#line 2562
        goto switch_break___0;
      }
      {
#line 2564
      while (1) {
        while_continue___16: /* CIL Label */ ;
        {
#line 2567
        tmp___34 = fread((void */* __restrict  */)(filebuffer), (size_t )1, (size_t )4096,
                         (FILE */* __restrict  */)incfile);
#line 2567
        num = tmp___34;
        }
#line 2568
        if (num == 0UL) {
#line 2569
          goto while_break___16;
        }
        {
#line 2570
        tmp___37 = fwrite((void const   */* __restrict  */)(filebuffer), (size_t )1,
                          num, (FILE */* __restrict  */)outfile);
        }
#line 2570
        if (num != tmp___37) {
          {
#line 2572
          tmp___35 = __errno_location();
#line 2572
          tmp___36 = strerror(*tmp___35);
#line 2572
          printerr(1, "error including binary file %s: %s\n", name___0, tmp___36);
          }
#line 2574
          goto while_break___16;
        }
#line 2576
        addr = (int )((size_t )addr + num);
#line 2577
        addr &= 65535;
      }
      while_break___16: /* CIL Label */ ;
      }
      {
#line 2579
      fclose(incfile);
#line 2580
      free((void *)name___0);
      }
#line 2581
      goto switch_break___0;
      case_81___0: /* CIL Label */ 
      {
#line 2584
      tmp___38 = rd_expr(& ptr, (char )'\000', (int *)((void *)0), sp, 1);
      }
#line 2584
      if (tmp___38) {
#line 2585
        ifcount ++;
      } else {
#line 2587
        noifcount ++;
      }
#line 2588
      goto switch_break___0;
      case_82___0: /* CIL Label */ 
#line 2590
      if (ifcount == 0) {
        {
#line 2592
        printerr(1, "else without if\n");
        }
#line 2593
        goto switch_break___0;
      }
#line 2595
      noifcount = 1;
#line 2596
      ifcount --;
#line 2597
      goto switch_break___0;
      case_83___0: /* CIL Label */ 
#line 2599
      if (noifcount == 0) {
#line 2599
        if (ifcount == 0) {
          {
#line 2601
          printerr(1, "endif without if\n");
          }
#line 2602
          goto switch_break___0;
        }
      }
#line 2604
      if (noifcount) {
#line 2605
        noifcount --;
      } else {
#line 2607
        ifcount --;
      }
#line 2608
      goto switch_break___0;
      case_85: /* CIL Label */ 
#line 2610
      if (! lastlabel) {
        {
#line 2612
        printerr(1, "macro without label\n");
        }
#line 2613
        goto switch_break___0;
      }
#line 2615
      if (define_macro) {
        {
#line 2617
        printerr(1, "nested macro definition\n");
        }
#line 2618
        goto switch_break___0;
      }
#line 2622
      m = firstmacro;
      {
#line 2622
      while (1) {
        while_continue___17: /* CIL Label */ ;
#line 2622
        if (! m) {
#line 2622
          goto while_break___17;
        }
        {
#line 2624
        tmp___39 = strcmp((char const   *)m->name, (char const   *)(lastlabel->name));
        }
#line 2624
        if (tmp___39 == 0) {
          {
#line 2626
          printerr(1, "duplicate macro definition\n");
          }
#line 2627
          goto while_break___17;
        }
#line 2622
        m = m->next;
      }
      while_break___17: /* CIL Label */ ;
      }
      {
#line 2630
      tmp___40 = malloc(sizeof(struct macro ));
#line 2630
      m = (struct macro *)tmp___40;
      }
#line 2631
      if (! m) {
        {
#line 2633
        printerr(1, "out of memory\n");
        }
#line 2634
        goto switch_break___0;
      }
      {
#line 2636
      tmp___41 = strlen((char const   *)(lastlabel->name));
#line 2636
      tmp___42 = malloc(tmp___41 + 1UL);
#line 2636
      m->name = (char *)tmp___42;
      }
#line 2637
      if (! m->name) {
        {
#line 2639
        printerr(1, "out of memory\n");
#line 2640
        free((void *)m);
        }
#line 2641
        goto switch_break___0;
      }
      {
#line 2643
      strcpy((char */* __restrict  */)m->name, (char const   */* __restrict  */)(lastlabel->name));
      }
#line 2644
      if (lastlabel->prev) {
#line 2645
        (lastlabel->prev)->next = lastlabel->next;
      } else {
#line 2647
        firstlabel = lastlabel->next;
      }
#line 2648
      if (lastlabel->next) {
#line 2649
        (lastlabel->next)->prev = lastlabel->prev;
      }
      {
#line 2650
      free((void *)lastlabel);
#line 2651
      m->next = firstmacro;
#line 2652
      firstmacro = m;
#line 2653
      m->lines = (struct macro_line *)((void *)0);
#line 2654
      m->numargs = get_macro_args(& ptr, & m->args, 0);
#line 2655
      define_macro = 1;
      }
#line 2657
      goto switch_break___0;
      case_86: /* CIL Label */ 
#line 2659
      if (stack[sp].file) {
        {
#line 2660
        printerr(1, "endm outside macro definition\n");
        }
      }
#line 2661
      goto switch_break___0;
      case_87: /* CIL Label */ 
      {
#line 2664
      tmp___43 = rd_expr(& ptr, (char )'\000', (int *)((void *)0), sp, 1);
#line 2664
      seekaddr = (unsigned int )tmp___43;
      }
#line 2665
      if (verbose >= 2) {
#line 2667
        if (stack[sp].dir) {
#line 2667
          tmp___44 = (char const   *)((stack[sp].dir)->name);
        } else {
#line 2667
          tmp___44 = "";
        }
        {
#line 2667
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s%s:%d: ",
                tmp___44, stack[sp].name, stack[sp].line);
#line 2670
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[Message] seeking to 0x%0X \n",
                seekaddr);
        }
      }
      {
#line 2673
      fseek(outfile, (long )seekaddr, 0);
      }
#line 2674
      goto switch_break___0;
      switch_default___0: /* CIL Label */ 
#line 2679
      m___0 = firstmacro;
      {
#line 2679
      while (1) {
        while_continue___18: /* CIL Label */ ;
#line 2679
        if (! m___0) {
#line 2679
          goto while_break___18;
        }
        {
#line 2681
        tmp___46 = strlen((char const   *)m___0->name);
#line 2681
        tmp___47 = strncmp((char const   *)m___0->name, ptr, tmp___46);
        }
#line 2681
        if (tmp___47 == 0) {
#line 2684
          if (sp + 1 >= 200) {
            {
#line 2686
            printerr(1, "stack overflow (circular include?)\n");
            }
#line 2687
            if (verbose >= 5) {
              {
#line 2690
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Stack dump:\nframe  line file\n");
#line 2692
              x___0 = 0;
              }
              {
#line 2692
              while (1) {
                while_continue___19: /* CIL Label */ ;
#line 2692
                if (! (x___0 < 200)) {
#line 2692
                  goto while_break___19;
                }
                {
#line 2693
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%5d %5d %s\n",
                        x___0, stack[x___0].line, stack[x___0].name);
#line 2692
                x___0 ++;
                }
              }
              while_break___19: /* CIL Label */ ;
              }
            }
#line 2696
            goto while_break___18;
          }
          {
#line 2698
          sp ++;
#line 2699
          tmp___45 = strlen((char const   *)m___0->name);
#line 2699
          ptr += tmp___45;
#line 2700
          numargs = get_macro_args(& ptr, & stack[sp].macro_args, 1);
          }
#line 2702
          if (numargs != m___0->numargs) {
            {
#line 2705
            printerr(1, "invalid number of arguments for macro (is %d, must be %d)\n",
                     numargs, m___0->numargs);
#line 2708
            a = 0U;
            }
            {
#line 2708
            while (1) {
              while_continue___20: /* CIL Label */ ;
#line 2708
              if (! (a < numargs)) {
#line 2708
                goto while_break___20;
              }
              {
#line 2709
              free((void *)*(stack[sp].macro_args + a));
#line 2708
              a ++;
              }
            }
            while_break___20: /* CIL Label */ ;
            }
            {
#line 2710
            free((void *)stack[sp].macro_args);
            }
#line 2711
            goto while_break___18;
          }
#line 2713
          stack[sp].name = (char const   *)m___0->name;
#line 2714
          stack[sp].file = (FILE *)((void *)0);
#line 2715
          stack[sp].line = 0;
#line 2716
          stack[sp].macro = m___0;
#line 2717
          stack[sp].macro_line = m___0->lines;
#line 2718
          stack[sp].shouldclose = 0;
#line 2719
          stack[sp].dir = (struct includedir *)((void *)0);
#line 2720
          goto while_break___18;
        }
#line 2679
        m___0 = m___0->next;
      }
      while_break___18: /* CIL Label */ ;
      }
#line 2723
      if (m___0) {
#line 2724
        goto switch_break___0;
      }
      {
#line 2726
      printerr(1, "command or comment expected (was %s)\n", ptr);
      }
      switch_break___0: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 1608
    file ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2730
  if (ifcount) {
    {
#line 2732
    printerr(1, "reached EOF at IF level %d\n", ifcount + noifcount);
    }
  } else
#line 2730
  if (noifcount) {
    {
#line 2732
    printerr(1, "reached EOF at IF level %d\n", ifcount + noifcount);
    }
  }
#line 2734
  if (havelist) {
    {
#line 2736
    fprintf((FILE */* __restrict  */)listfile, (char const   */* __restrict  */)"%04x\n",
            addr);
    }
  }
#line 2742
  sp ++;
#line 2743
  tmp___48 = firstreference;
  {
#line 2743
  while (1) {
    while_continue___21: /* CIL Label */ ;
#line 2743
    if (! tmp___48) {
#line 2743
      goto while_break___21;
    }
    {
#line 2746
    next___0 = tmp___48->next;
#line 2747
    fseek(outfile, tmp___48->oseekpos, 0);
    }
#line 2748
    if (havelist) {
      {
#line 2749
      fseek(listfile, tmp___48->lseekpos, 0);
      }
    }
    {
#line 2750
    stack[sp].name = (char const   *)tmp___48->file;
#line 2751
    stack[sp].dir = tmp___48->dir;
#line 2752
    stack[sp].line = tmp___48->line;
#line 2753
    ref___0 = compute_ref(tmp___48, 0);
#line 2754
    wrt_ref(ref___0, (int )tmp___48->type, tmp___48->count);
    }
#line 2755
    if (tmp___48->dir) {
      {
#line 2756
      free((void *)tmp___48->dir);
      }
    }
    {
#line 2757
    free((void *)tmp___48->file);
#line 2758
    free((void *)tmp___48);
#line 2743
    tmp___48 = next___0;
    }
  }
  while_break___21: /* CIL Label */ ;
  }
#line 2761
  if (! errors) {
#line 2761
    goto _L___0;
  } else
#line 2761
  if (use_force) {
    _L___0: /* CIL Label */ 
    {
#line 2763
    flush_to_real_file(realoutputfile, outfile);
    }
#line 2764
    if (havelist) {
      {
#line 2765
      flush_to_real_file(reallistfile, listfile);
      }
    }
  }
#line 2768
  if (label) {
    {
#line 2769
    fseek(labelfile, 0L, 2);
    }
  }
#line 2770
  l = firstlabel;
  {
#line 2770
  while (1) {
    while_continue___22: /* CIL Label */ ;
#line 2770
    if (! l) {
#line 2770
      goto while_break___22;
    }
#line 2772
    if (l->ref) {
      {
#line 2774
      compute_ref(l->ref, 0);
      }
    }
#line 2776
    if (label) {
      {
#line 2778
      fprintf((FILE */* __restrict  */)labelfile, (char const   */* __restrict  */)"%s%s:\tequ $%04x\n",
              labelprefix, l->name, l->value);
      }
    }
#line 2770
    l = l->next;
  }
  while_break___22: /* CIL Label */ ;
  }
#line 2782
  if (label) {
    {
#line 2783
    fclose(labelfile);
    }
  }
  {
#line 2784
  while (1) {
    while_continue___23: /* CIL Label */ ;
#line 2784
    if (! firstlabel) {
#line 2784
      goto while_break___23;
    }
    {
#line 2786
    l = firstlabel->next;
#line 2787
    free((void *)firstlabel);
#line 2788
    firstlabel = l;
    }
  }
  while_break___23: /* CIL Label */ ;
  }
  {
#line 2790
  fclose(outfile);
  }
#line 2791
  if ((unsigned long )outfile != (unsigned long )realoutputfile) {
    {
#line 2792
    fclose(realoutputfile);
    }
  }
#line 2793
  if (havelist) {
    {
#line 2795
    fclose(listfile);
    }
#line 2796
    if ((unsigned long )listfile != (unsigned long )reallistfile) {
#line 2796
      if ((unsigned long )reallistfile != (unsigned long )stderr) {
        {
#line 2797
        fclose(reallistfile);
        }
      }
    }
  }
  {
#line 2799
  free((void *)infile);
  }
#line 2800
  return;
}
}
#line 2802 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
int main(int argc , char **argv ) 
{ 


  {
  {
#line 2806
  add_include("/usr/share/z80asm/headers/");
#line 2807
  parse_commandline(argc, argv);
  }
#line 2808
  if (verbose >= 1) {
    {
#line 2809
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Assembling....\n");
    }
  }
  {
#line 2810
  assemble();
  }
#line 2811
  if (errors) {
#line 2813
    if (errors == 1) {
      {
#line 2814
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*** 1 error found ***\n");
      }
    } else {
      {
#line 2816
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*** %d errors found ***\n",
              errors);
      }
    }
#line 2817
    if ((unsigned long )realoutputfile == (unsigned long )outfile) {
#line 2817
      if (! use_force) {
        {
#line 2819
        unlink(realoutputfilename);
#line 2820
        unlink(labelfilename);
        }
      }
    }
#line 2822
    return (1);
  } else {
#line 2826
    if (verbose >= 1) {
      {
#line 2827
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Assembly succesful.\n");
      }
    }
#line 2828
    return (0);
  }
}
}
#line 134 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static void rd_comma___0(char const   **p ) 
{ 


  {
  {
#line 137
  *p = delspc(*p);
  }
#line 138
  if ((int const   )*(*p) != 44) {
    {
#line 140
    printerr(1, "`,\' expected. Remainder of line: %s\n", *p);
    }
#line 141
    return;
  }
  {
#line 143
  *p = delspc(*p + 1);
  }
#line 144
  return;
}
}
#line 147 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static int has_argument___0(char const   **p ) 
{ 
  char const   *q ;
  char const   *tmp ;

  {
  {
#line 150
  tmp = delspc(*p);
#line 150
  q = tmp;
  }
#line 151
  return ((int const   )*q == 44);
}
}
#line 157 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static void skipword___0(char const   **pos , char delimiter ) 
{ 
  int valid ;

  {
  {
#line 164
  rd_expr(pos, delimiter, & valid, sp, 0);
  }
#line 165
  return;
}
}
#line 168 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static FILE *openfile___0(int *done , char const   *type , FILE *def , char const   *name ,
                          char const   *flags ) 
{ 
  FILE *retval ;
  int *tmp ;
  char *tmp___0 ;

  {
#line 176
  if (*done) {
    {
#line 178
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: more than one %s specified\n",
            type);
#line 179
    exit(1);
    }
  }
#line 181
  *done = 1;
#line 182
  if (def) {
#line 182
    if (! name) {
#line 184
      return (def);
    } else
#line 182
    if ((int const   )*(name + 0) == 45) {
#line 182
      if ((int const   )*(name + 1) == 0) {
#line 184
        return (def);
      }
    }
  }
#line 186
  if (! name) {
    {
#line 188
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: no %s specified\n",
            type);
#line 189
    exit(1);
    }
  } else
#line 186
  if (! *(name + 0)) {
    {
#line 188
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: no %s specified\n",
            type);
#line 189
    exit(1);
    }
  }
  {
#line 191
  retval = fopen((char const   */* __restrict  */)name, (char const   */* __restrict  */)flags);
  }
#line 191
  if (! retval) {
    {
#line 193
    tmp = __errno_location();
#line 193
    tmp___0 = strerror(*tmp);
#line 193
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unable to open %s %s: %s\n",
            type, name, tmp___0);
#line 195
    exit(1);
    }
  }
#line 197
  return (retval);
}
}
#line 201 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static FILE *open_include_file___0(char const   *name , struct includedir **dir ,
                                   char const   *flags ) 
{ 
  FILE *result ;
  struct includedir *i ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 208
  result = fopen((char const   */* __restrict  */)name, (char const   */* __restrict  */)flags);
  }
#line 209
  if (result) {
#line 211
    if (dir) {
#line 212
      *dir = (struct includedir *)((void *)0);
    }
#line 213
    return (result);
  }
#line 215
  i = firstincludedir;
  {
#line 215
  while (1) {
    while_continue: /* CIL Label */ ;
#line 215
    if (! ((unsigned long )i != (unsigned long )((void *)0))) {
#line 215
      goto while_break;
    }
    {
#line 217
    tmp___0 = strlen((char const   *)(i->name));
#line 217
    tmp___1 = strlen(name);
#line 217
    tmp___2 = malloc((tmp___0 + tmp___1) + 1UL);
#line 217
    tmp = (char *)tmp___2;
    }
#line 218
    if (! tmp) {
      {
#line 220
      printerr(1, "not enough memory trying to open include file\n");
      }
#line 221
      return ((FILE *)((void *)0));
    }
    {
#line 223
    strcpy((char */* __restrict  */)tmp, (char const   */* __restrict  */)(i->name));
#line 224
    strcat((char */* __restrict  */)tmp, (char const   */* __restrict  */)name);
#line 225
    result = fopen((char const   */* __restrict  */)tmp, (char const   */* __restrict  */)flags);
#line 226
    free((void *)tmp);
    }
#line 227
    if (result) {
#line 229
      if (dir) {
#line 230
        *dir = i;
      }
#line 231
      return (result);
    }
#line 215
    i = i->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 234
  return ((FILE *)((void *)0));
}
}
#line 238 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static void open_infile___0(char const   *name ) 
{ 
  void *tmp ;

  {
  {
#line 241
  tmp = realloc((void *)infile, sizeof(struct infile ) * (unsigned long )(infilecount + 1));
#line 241
  infile = (struct infile *)tmp;
  }
#line 242
  if (! infile) {
    {
#line 244
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: insufficient memory\n");
#line 245
    exit(1);
    }
  }
#line 248
  (infile + infilecount)->type = (enum filetype )0;
#line 249
  (infile + infilecount)->name = name;
#line 250
  if (verbose >= 5) {
    {
#line 251
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"queued inputfile %s\n",
            (infile + infilecount)->name);
    }
  }
#line 252
  infilecount ++;
#line 253
  return;
}
}
#line 256 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static void add_include___0(char const   *name ) 
{ 
  struct includedir *i ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 260
  tmp = strlen(name);
#line 260
  tmp___0 = malloc((sizeof(struct includedir ) + tmp) + 1UL);
#line 260
  i = (struct includedir *)tmp___0;
  }
#line 261
  if (! i) {
    {
#line 263
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: insufficient memory\n");
#line 264
    exit(1);
    }
  }
  {
#line 266
  strcpy((char */* __restrict  */)(i->name), (char const   */* __restrict  */)name);
#line 267
  tmp___1 = strlen(name);
  }
#line 267
  if ((int const   )*(name + (tmp___1 - 1UL)) != 47) {
    {
#line 268
    strcat((char */* __restrict  */)(i->name), (char const   */* __restrict  */)"/");
    }
  }
#line 269
  i->next = firstincludedir;
#line 270
  firstincludedir = i;
#line 271
  return;
}
}
#line 273 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static void try_use_real_file___0(FILE *real , FILE **backup ) 
{ 
  fpos_t pos ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  FILE *tmp___2 ;

  {
  {
#line 277
  tmp = fgetpos((FILE */* __restrict  */)real, (fpos_t */* __restrict  */)(& pos));
  }
#line 277
  if (tmp == 0) {
#line 279
    *backup = real;
#line 280
    return;
  }
  {
#line 282
  tmp___2 = tmpfile();
#line 282
  *backup = tmp___2;
  }
#line 282
  if (! tmp___2) {
    {
#line 284
    tmp___0 = __errno_location();
#line 284
    tmp___1 = strerror(*tmp___0);
#line 284
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Unable to open temporary file: %s\n",
            tmp___1);
#line 286
    exit(1);
    }
  }
#line 288
  return;
}
}
#line 290 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static void flush_to_real_file___0(FILE *real , FILE *tmp ) 
{ 
  int l ;
  int size ;
  int len ;
  char buf[300] ;
  int *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;

  {
#line 293
  len = 0;
#line 295
  if ((unsigned long )tmp == (unsigned long )real) {
#line 297
    return;
  }
  {
#line 299
  rewind(tmp);
  }
  {
#line 300
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 302
    clearerr(tmp);
#line 303
    tmp___0 = __errno_location();
#line 303
    *tmp___0 = 0;
#line 304
    tmp___1 = fread((void */* __restrict  */)(buf), (size_t )1, (size_t )300, (FILE */* __restrict  */)tmp);
#line 304
    len = (int )tmp___1;
    }
#line 305
    if (len == 0) {
      {
#line 305
      tmp___2 = feof(tmp);
      }
#line 305
      if (tmp___2) {
#line 306
        goto while_break;
      }
    }
#line 307
    if (len <= 0) {
      {
#line 309
      tmp___3 = __errno_location();
#line 309
      tmp___4 = strerror(*tmp___3);
#line 309
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error reading temp file: %s\n",
              tmp___4);
#line 310
      exit(1);
      }
    }
#line 312
    l = 0;
    {
#line 313
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 313
      if (! (l < len)) {
#line 313
        goto while_break___0;
      }
      {
#line 315
      clearerr(real);
#line 316
      tmp___5 = fwrite((void const   */* __restrict  */)(& buf[l]), (size_t )1, (size_t )(len - l),
                       (FILE */* __restrict  */)real);
#line 316
      size = (int )tmp___5;
      }
#line 317
      if (size <= 0) {
        {
#line 319
        tmp___6 = __errno_location();
#line 319
        tmp___7 = strerror(*tmp___6);
#line 319
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error writing final file: %s\n",
                tmp___7);
#line 321
        exit(1);
        }
      }
#line 323
      l += size;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 326
  return;
}
}
#line 329 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static void parse_commandline___0(int argc , char **argv ) 
{ 
  struct option opts[11] ;
  char const   *short_opts ;
  int done ;
  int i ;
  int out ;
  int tmp ;

  {
#line 332
  opts[0].name = "help";
#line 332
  opts[0].has_arg = 0;
#line 332
  opts[0].flag = (int *)((void *)0);
#line 332
  opts[0].val = 'h';
#line 332
  opts[1].name = "version";
#line 332
  opts[1].has_arg = 0;
#line 332
  opts[1].flag = (int *)((void *)0);
#line 332
  opts[1].val = 'V';
#line 332
  opts[2].name = "verbose";
#line 332
  opts[2].has_arg = 0;
#line 332
  opts[2].flag = (int *)((void *)0);
#line 332
  opts[2].val = 'v';
#line 332
  opts[3].name = "list";
#line 332
  opts[3].has_arg = 2;
#line 332
  opts[3].flag = (int *)((void *)0);
#line 332
  opts[3].val = 'l';
#line 332
  opts[4].name = "label";
#line 332
  opts[4].has_arg = 2;
#line 332
  opts[4].flag = (int *)((void *)0);
#line 332
  opts[4].val = 'L';
#line 332
  opts[5].name = "input";
#line 332
  opts[5].has_arg = 1;
#line 332
  opts[5].flag = (int *)((void *)0);
#line 332
  opts[5].val = 'i';
#line 332
  opts[6].name = "output";
#line 332
  opts[6].has_arg = 1;
#line 332
  opts[6].flag = (int *)((void *)0);
#line 332
  opts[6].val = 'o';
#line 332
  opts[7].name = "label-prefix";
#line 332
  opts[7].has_arg = 1;
#line 332
  opts[7].flag = (int *)((void *)0);
#line 332
  opts[7].val = 'p';
#line 332
  opts[8].name = "includepath";
#line 332
  opts[8].has_arg = 1;
#line 332
  opts[8].flag = (int *)((void *)0);
#line 332
  opts[8].val = 'I';
#line 332
  opts[9].name = "force";
#line 332
  opts[9].has_arg = 0;
#line 332
  opts[9].flag = (int *)((void *)0);
#line 332
  opts[9].val = 'f';
#line 332
  opts[10].name = (char const   *)((void *)0);
#line 332
  opts[10].has_arg = 0;
#line 332
  opts[10].flag = (int *)((void *)0);
#line 332
  opts[10].val = 0;
#line 345
  short_opts = "hVvl::L::i:o:p:I:f";
#line 346
  done = 0;
#line 346
  out = 0;
#line 347
  infile = (struct infile *)((void *)0);
  {
#line 348
  while (1) {
    while_continue: /* CIL Label */ ;
#line 348
    if (! (! done)) {
#line 348
      goto while_break;
    }
    {
#line 350
    tmp = getopt_long(argc, (char * const  *)argv, short_opts, (struct option  const  *)(opts),
                      (int *)((void *)0));
    }
    {
#line 352
    if (tmp == 104) {
#line 352
      goto case_104;
    }
#line 370
    if (tmp == 86) {
#line 370
      goto case_86;
    }
#line 384
    if (tmp == 118) {
#line 384
      goto case_118;
    }
#line 389
    if (tmp == 111) {
#line 389
      goto case_111;
    }
#line 396
    if (tmp == 105) {
#line 396
      goto case_105;
    }
#line 399
    if (tmp == 108) {
#line 399
      goto case_108;
    }
#line 405
    if (tmp == 76) {
#line 405
      goto case_76;
    }
#line 411
    if (tmp == 112) {
#line 411
      goto case_112;
    }
#line 414
    if (tmp == 73) {
#line 414
      goto case_73;
    }
#line 417
    if (tmp == 102) {
#line 417
      goto case_102;
    }
#line 420
    if (tmp == -1) {
#line 420
      goto case_neg_1;
    }
#line 423
    goto switch_default;
    case_104: /* CIL Label */ 
    {
#line 354
    printf((char const   */* __restrict  */)"Usage: %s [options] [input files]\n\nPossible options are:\n-h\t--help\t\tDisplay this help text and exit.\n-V\t--version\tDisplay version information and exit.\n-v\t--verbose\tBe verbose.  Specify again to be more verbose.\n-l\t--list\t\tWrite a list file.\n-L\t--label\t\tWrite a label file.\n",
           *(argv + 0));
#line 363
    printf((char const   */* __restrict  */)"-p\t--label-prefix\tprefix all labels with this prefix.\n-i\t--input\t\tSpecify an input file (-i may be omitted).\n-o\t--output\tSpecify the output file.\n-I\t--includepath\tAdd a directory to the include path.\nPlease send bug reports and feature requests to <shevek@fmf.nl>\n");
#line 369
    exit(0);
    }
    case_86: /* CIL Label */ 
    {
#line 371
    printf((char const   */* __restrict  */)"Z80 assembler version 1.8\nCopyright (C) 2002-2007 Bas Wijnen <shevek@fmf.nl>.\nCopyright (C) 2005 Jan Wilmans <jw@dds.nl>.\nThis program comes with ABSOLUTELY NO WARRANTY.\nYou may distribute copies of the program under the terms\nof the GNU General Public License as published by\nthe Free Software Foundation; either version 2 of the\nLicense, or (at your option) any later version.\n\nThe complete text of the GPL can be found in\n/usr/share/common-licenses/GPL.\n");
#line 383
    exit(0);
    }
    case_118: /* CIL Label */ 
#line 385
    verbose ++;
#line 386
    if (verbose >= 5) {
      {
#line 387
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Verbosity increased to level %d\n",
              verbose);
      }
    }
#line 388
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 390
    realoutputfile = openfile___0(& out, "output file", stdout, (char const   *)optarg,
                                  "wb");
#line 392
    realoutputfilename = (char const   *)optarg;
    }
#line 393
    if (verbose >= 5) {
      {
#line 394
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Opened outputfile\n");
      }
    }
#line 395
    goto switch_break;
    case_105: /* CIL Label */ 
    {
#line 397
    open_infile___0((char const   *)optarg);
    }
#line 398
    goto switch_break;
    case_108: /* CIL Label */ 
    {
#line 400
    reallistfile = openfile___0(& havelist, "list file", stderr, (char const   *)optarg,
                                "w");
    }
#line 402
    if (verbose >= 5) {
      {
#line 403
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Opened list file\n");
      }
    }
#line 404
    goto switch_break;
    case_76: /* CIL Label */ 
    {
#line 406
    labelfile = openfile___0(& label, "label file", stderr, (char const   *)optarg,
                             "w");
#line 407
    labelfilename = (char const   *)optarg;
    }
#line 408
    if (verbose >= 5) {
      {
#line 409
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Opened label file\n");
      }
    }
#line 410
    goto switch_break;
    case_112: /* CIL Label */ 
#line 412
    labelprefix = (char const   *)optarg;
#line 413
    goto switch_break;
    case_73: /* CIL Label */ 
    {
#line 415
    add_include___0((char const   *)optarg);
    }
#line 416
    goto switch_break;
    case_102: /* CIL Label */ 
#line 418
    use_force = 1;
#line 419
    goto switch_break;
    case_neg_1: /* CIL Label */ 
#line 421
    done = 1;
#line 422
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 425
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 428
  i = optind;
  {
#line 428
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 428
    if (! (i < argc)) {
#line 428
      goto while_break___0;
    }
    {
#line 429
    open_infile___0((char const   *)*(argv + i));
#line 428
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 430
  if (! infilecount) {
    {
#line 431
    open_infile___0("-");
    }
  }
#line 432
  if (! out) {
    {
#line 433
    realoutputfile = openfile___0(& out, "output file", stdout, "a.bin", "wb");
    }
  }
  {
#line 434
  try_use_real_file___0(realoutputfile, & outfile);
  }
#line 435
  if (havelist) {
    {
#line 436
    try_use_real_file___0(reallistfile, & listfile);
    }
  }
#line 437
  return;
}
}
#line 440 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static int indx___0(char const   **ptr , char const   **list , int error , char const   **expr ) 
{ 
  int i ;
  int l ;
  char const   *input ;
  char const   *check ;
  int had_expr ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
  {
#line 444
  *ptr = delspc(*ptr);
  }
#line 445
  if (! *(*ptr)) {
#line 447
    if (error) {
      {
#line 449
      printerr(1, "unexpected end of line\n");
      }
#line 450
      return (0);
    } else {
#line 453
      return (0);
    }
  }
#line 455
  if (comma > 1) {
    {
#line 456
    rd_comma___0(ptr);
    }
  }
#line 457
  i = 0;
  {
#line 457
  while (1) {
    while_continue: /* CIL Label */ ;
#line 457
    if (! *(list + i)) {
#line 457
      goto while_break;
    }
#line 459
    input = *ptr;
#line 460
    check = *(list + i);
#line 461
    had_expr = 0;
#line 462
    if (! *(*(list + i) + 0)) {
#line 463
      goto __Cont;
    }
    {
#line 464
    tmp = strlen(*(list + i));
#line 464
    l = (int )tmp;
    }
    {
#line 465
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 465
      if (! *check) {
#line 465
        goto while_break___0;
      }
#line 467
      if ((int const   )*check == 32) {
        {
#line 469
        input = delspc(input);
        }
      } else
#line 471
      if ((int const   )*check == 42) {
        {
#line 473
        *expr = input;
#line 474
        mem_delimiter = (char )*(check + 1);
#line 475
        rd_expr(& input, mem_delimiter, (int *)((void *)0), sp, 0);
#line 476
        had_expr = 1;
        }
      } else
#line 478
      if ((int const   )*check == 43) {
#line 480
        if ((int const   )*input == 43) {
          {
#line 482
          *expr = input;
#line 483
          mem_delimiter = (char )*(check + 1);
#line 484
          rd_expr(& input, mem_delimiter, (int *)((void *)0), sp, 0);
          }
        } else
#line 480
        if ((int const   )*input == 45) {
          {
#line 482
          *expr = input;
#line 483
          mem_delimiter = (char )*(check + 1);
#line 484
          rd_expr(& input, mem_delimiter, (int *)((void *)0), sp, 0);
          }
        }
      } else
#line 487
      if ((int const   )*check == (int const   )*input) {
#line 489
        input ++;
      } else
#line 487
      if ((int const   )*check >= 97) {
#line 487
        if ((int const   )*check <= 122) {
#line 487
          if (((int const   )*check - 97) + 65 == (int const   )*input) {
#line 489
            input ++;
          } else {
#line 491
            goto while_break___0;
          }
        } else {
#line 491
          goto while_break___0;
        }
      } else {
#line 491
        goto while_break___0;
      }
#line 493
      check ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 495
    if (*check) {
#line 496
      goto __Cont;
    } else {
      {
#line 495
      tmp___0 = __ctype_b_loc();
      }
#line 495
      if ((int const   )*(*tmp___0 + (int )*(check + -1)) & 8) {
        {
#line 495
        tmp___1 = __ctype_b_loc();
        }
#line 495
        if ((int const   )*(*tmp___1 + (int )*(input + 0)) & 8) {
#line 496
          goto __Cont;
        }
      }
    }
#line 497
    if (had_expr) {
      {
#line 499
      input = delspc(input);
      }
#line 500
      if (*input) {
#line 500
        if ((int const   )*input != 44) {
#line 501
          goto __Cont;
        }
      }
    }
#line 503
    *ptr = input;
#line 504
    if (verbose >= 4) {
      {
#line 505
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%5d (0x%04x): Piece of code found:%s\n",
              stack[sp].line, addr, *(list + i));
      }
    }
#line 507
    if (verbose >= 6) {
      {
#line 508
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%5d (0x%04x): Remainder of line=%s.\n",
              stack[sp].line, addr, *ptr);
      }
    }
#line 510
    comma ++;
#line 511
    return (i + 1);
    __Cont: /* CIL Label */ 
#line 457
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 513
  if (error) {
    {
#line 515
    printerr(1, "parse error. Remainder of line=%s\n", *ptr);
    }
#line 516
    if (verbose >= 3) {
      {
#line 518
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"When looking for any of:\n");
#line 519
      i = 0;
      }
      {
#line 519
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 519
        if (! *(list + i)) {
#line 519
          goto while_break___1;
        }
        {
#line 520
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\t",
                *(list + i));
#line 519
        i ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 521
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    }
  }
#line 524
  return (0);
}
}
#line 528 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static int readcommand___0(char const   **p ) 
{ 
  int tmp ;

  {
  {
#line 531
  tmp = indx___0(p, mnemonics, 0, (char const   **)((void *)0));
  }
#line 531
  return (tmp);
}
}
#line 535 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static void readlabel___0(char const   **p , int store ) 
{ 
  char const   *c ;
  char const   *d ;
  char const   *pos ;
  char const   *dummy ;
  int i ;
  int j ;
  struct label *buf ;
  struct label *previous ;
  struct label **thefirstlabel ;
  char *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;

  {
#line 541
  d = *p;
  {
#line 541
  while (1) {
    while_continue: /* CIL Label */ ;
#line 541
    if (*d) {
#line 541
      if (! ((int const   )*d != 59)) {
#line 541
        goto while_break;
      }
    } else {
#line 541
      goto while_break;
    }
#line 541
    d ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 544
  c = *p;
  {
#line 544
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 544
    tmp = strchr(" \r\n\t", (int )*c);
    }
#line 544
    if (tmp) {
#line 544
      goto while_break___0;
    } else
#line 544
    if (! ((unsigned long )c < (unsigned long )d)) {
#line 544
      goto while_break___0;
    }
#line 544
    c ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 547
  tmp___0 = strchr(*p, ':');
#line 547
  pos = (char const   *)tmp___0;
  }
#line 548
  if (! pos) {
#line 549
    return;
  } else
#line 548
  if ((unsigned long )pos >= (unsigned long )c) {
#line 549
    return;
  }
#line 550
  if ((unsigned long )pos == (unsigned long )*p) {
    {
#line 552
    printerr(1, "`:\' found without a label");
    }
#line 553
    return;
  }
#line 555
  if (! store) {
#line 557
    *p = pos + 1;
#line 558
    return;
  }
  {
#line 560
  c = pos + 1;
#line 561
  dummy = *p;
#line 562
  j = rd_label(& dummy, & i, & previous, sp, 0);
  }
#line 563
  if (i) {
    {
#line 565
    printerr(1, "duplicate definition of label %s\n", *p);
#line 566
    *p = c;
    }
#line 567
    return;
  } else
#line 563
  if (j) {
    {
#line 565
    printerr(1, "duplicate definition of label %s\n", *p);
#line 566
    *p = c;
    }
#line 567
    return;
  }
  {
#line 569
  tmp___1 = malloc((size_t )((c + sizeof(struct label )) - *p));
#line 569
  buf = (struct label *)tmp___1;
  }
#line 569
  if ((unsigned long )((void *)0) == (unsigned long )buf) {
    {
#line 571
    printerr(1, "not enough memory to store label %s\n", *p);
#line 572
    *p = c;
    }
#line 573
    return;
  }
  {
#line 575
  strncpy((char */* __restrict  */)(buf->name), (char const   */* __restrict  */)*p,
          (size_t )((c - *p) - 1L));
#line 576
  buf->name[(c - *p) - 1L] = (char)0;
  }
#line 577
  if (verbose >= 3) {
    {
#line 578
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%5d (0x%04x): Label found: %s\n",
            stack[sp].line, addr, buf->name);
    }
  }
#line 580
  *p = c;
#line 581
  buf->value = addr;
#line 582
  lastlabel = buf;
#line 583
  if ((int )buf->name[0] == 46) {
#line 584
    thefirstlabel = & stack[sp].labels;
  } else {
#line 586
    thefirstlabel = & firstlabel;
  }
#line 587
  if (previous) {
#line 588
    buf->next = previous->next;
  } else {
#line 590
    buf->next = *thefirstlabel;
  }
#line 591
  buf->prev = previous;
#line 592
  buf->valid = 1;
#line 593
  buf->busy = 0;
#line 594
  buf->ref = (struct reference *)((void *)0);
#line 595
  if (buf->prev) {
#line 596
    (buf->prev)->next = buf;
  } else {
#line 598
    *thefirstlabel = buf;
  }
#line 599
  if (buf->next) {
#line 600
    (buf->next)->prev = buf;
  }
#line 601
  return;
}
}
#line 603
static void new_reference___0(char const   *p , int type , char delimiter , int ds_count ) ;
#line 607 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static void write_one_byte___0(int b , int list ) 
{ 


  {
#line 610
  if (verbose >= 4) {
    {
#line 611
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%5d (0x%04x): write_one_byte called with argument 0x%02x\n",
            stack[sp].line, addr, b);
    }
  }
  {
#line 614
  b &= 255;
#line 615
  _IO_putc(b, outfile);
  }
#line 616
  if (list) {
#line 616
    if (havelist) {
      {
#line 618
      fprintf((FILE */* __restrict  */)listfile, (char const   */* __restrict  */)" %02x",
              b);
#line 619
      listdepth += 3;
      }
    }
  }
#line 621
  addr ++;
#line 622
  addr &= 65535;
#line 623
  return;
}
}
#line 626 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static void wrtb___0(int b ) 
{ 


  {
#line 629
  if (verbose >= 4) {
    {
#line 630
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%5d (0x%04x): wrtb called with argument 0x%02x\n",
            stack[sp].line, addr, b);
    }
  }
#line 632
  if (indexed) {
#line 634
    if (verbose >= 5) {
      {
#line 635
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%5d (0x%04x): writing indexed byte 0x%02x\n",
              stack[sp].line, addr, indexed);
      }
    }
    {
#line 637
    write_one_byte___0(indexed, 1);
#line 638
    indexed = 0;
    }
  }
#line 640
  if (writebyte) {
#line 642
    if (verbose >= 5) {
      {
#line 643
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%5d (0x%04x): using a xor on byte because there is a writebyte.\n",
              stack[sp].line, addr);
      }
    }
#line 645
    b ^= 64;
  }
#line 647
  if (verbose >= 5) {
    {
#line 648
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%5d (0x%04x): writing byte 0x%02x\n",
            stack[sp].line, addr, b);
    }
  }
#line 650
  if (bitsetres) {
#line 650
    if (b != 203) {
      {
#line 652
      new_reference___0(bitsetres, 0, (char )',', b);
#line 653
      bitsetres = (char const   *)((void *)0);
      }
    } else {
      {
#line 657
      write_one_byte___0(b, 1);
      }
    }
  } else {
    {
#line 657
    write_one_byte___0(b, 1);
    }
  }
#line 659
  if (indexjmp) {
#line 661
    if (verbose >= 5) {
      {
#line 662
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%5d (0x%04x): Making reference for index/jump %s\n",
              stack[sp].line, addr, indexjmp);
      }
    }
    {
#line 664
    new_reference___0(indexjmp, 4, (char )')', 1);
#line 665
    indexjmp = (char const   *)((void *)0);
    }
  }
#line 667
  if (writebyte) {
#line 669
    if (verbose >= 5) {
      {
#line 670
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%5d (0x%04x): writing argument byte for padding\n",
              stack[sp].line, addr);
      }
    }
    {
#line 672
    writebyte = 0;
#line 673
    new_reference___0(readbyte, 4, mem_delimiter, 1);
    }
  }
#line 675
  return;
}
}
#line 717
static void wrt_ref___0(int val , int type , int count ) ;
#line 721 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static void new_reference___0(char const   *p , int type , char delimiter , int ds_count ) 
{ 
  struct reference *tmp ;
  long opos ;
  long lpos ;
  int valid ;
  int value ;
  char const   *c ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  long tmp___6 ;

  {
  {
#line 724
  tmp = (struct reference *)((void *)0);
#line 728
  c = p;
#line 729
  value = rd_expr(& c, delimiter, & valid, sp, 1);
  }
#line 730
  if (valid) {
#line 732
    if (verbose >= 5) {
      {
#line 734
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%5d (0x%04x): Using calculated value %d (%x) immediately.\n",
              stack[sp].line, addr, value, value);
      }
    }
  } else {
    {
#line 741
    tmp___0 = strlen(p);
#line 741
    tmp___1 = malloc(sizeof(struct reference ) + tmp___0);
#line 741
    tmp = (struct reference *)tmp___1;
    }
#line 742
    if (! tmp) {
      {
#line 744
      printerr(1, "unable to allocate memory for reference %s\n", p);
      }
#line 745
      return;
    }
    {
#line 747
    tmp___2 = strlen(stack[sp].name);
#line 747
    tmp___3 = malloc(tmp___2 + 1UL);
#line 747
    tmp->file = (char *)tmp___3;
    }
#line 748
    if (! tmp->file) {
      {
#line 750
      printerr(1, "unable to allocate memory for reference filename\n");
#line 751
      free((void *)tmp);
      }
#line 752
      return;
    }
    {
#line 754
    strcpy((char */* __restrict  */)tmp->file, (char const   */* __restrict  */)stack[sp].name);
    }
#line 755
    if (stack[sp].dir) {
      {
#line 757
      tmp___4 = strlen((char const   *)((stack[sp].dir)->name));
#line 757
      tmp___5 = malloc(tmp___4 + sizeof(struct includedir ));
#line 757
      tmp->dir = (struct includedir *)tmp___5;
      }
#line 759
      if (! tmp->dir) {
        {
#line 761
        printerr(1, "unable to allocate memory for reference dir\n");
#line 762
        free((void *)tmp->file);
#line 763
        free((void *)tmp);
        }
#line 764
        return;
      }
      {
#line 766
      strcpy((char */* __restrict  */)((tmp->dir)->name), (char const   */* __restrict  */)((stack[sp].dir)->name));
      }
    } else {
#line 769
      tmp->dir = (struct includedir *)((void *)0);
    }
    {
#line 770
    opos = ftell(outfile);
    }
#line 771
    if (havelist) {
      {
#line 771
      tmp___6 = ftell(listfile);
#line 771
      lpos = tmp___6;
      }
    } else {
#line 771
      lpos = 0L;
    }
#line 772
    if (verbose >= 3) {
      {
#line 773
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%5d (0x%04x): reference set to %s (delimiter=%c, sp=%d)\n",
              stack[sp].line, addr, p, (int )delimiter, sp);
      }
    }
    {
#line 775
    strcpy((char */* __restrict  */)(tmp->input), (char const   */* __restrict  */)p);
#line 776
    tmp->line = stack[sp].line;
#line 777
    tmp->addr = addr;
#line 778
    tmp->baseaddr = baseaddr;
#line 779
    tmp->count = ds_count;
#line 780
    tmp->infile = file;
#line 781
    tmp->comma = comma;
#line 782
    tmp->oseekpos = opos;
#line 783
    tmp->lseekpos = lpos;
#line 784
    tmp->delimiter = delimiter;
#line 785
    tmp->type = (enum reftype )type;
#line 786
    tmp->next = firstreference;
#line 787
    tmp->done = 0;
#line 788
    tmp->level = sp;
    }
#line 789
    if (type != 6) {
#line 791
      if (firstreference) {
#line 792
        firstreference->prev = tmp;
      }
#line 793
      tmp->prev = (struct reference *)((void *)0);
#line 794
      firstreference = tmp;
    }
#line 797
    if (type == 5) {
#line 797
      value = ds_count;
    } else {
#line 797
      value = 0;
    }
  }
#line 799
  if (type != 6) {
    {
#line 801
    wrt_ref___0(value, type, ds_count);
    }
  } else {
#line 805
    lastlabel->ref = tmp;
#line 806
    lastlabel->valid = valid;
#line 807
    lastlabel->value = value;
  }
#line 809
  return;
}
}
#line 812 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static void write_word___0(void) 
{ 


  {
  {
#line 815
  new_reference___0(readword, 3, mem_delimiter, 1);
  }
#line 816
  return;
}
}
#line 819 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static void write_rel___0(void) 
{ 


  {
  {
#line 822
  new_reference___0(readbyte, 5, mem_delimiter, (addr + 1) & 65535);
#line 823
  writebyte = 0;
  }
#line 824
  return;
}
}
#line 827 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static int rd_word___0(char const   **p , char delimiter ) 
{ 


  {
  {
#line 830
  *p = delspc(*p);
  }
#line 831
  if ((int const   )*(*p) == 0) {
#line 832
    return (0);
  }
  {
#line 833
  readword = *p;
#line 834
  mem_delimiter = delimiter;
#line 835
  skipword___0(p, delimiter);
  }
#line 836
  return (1);
}
}
#line 840 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static int rd_byte___0(char const   **p , char delimiter ) 
{ 


  {
  {
#line 843
  *p = delspc(*p);
  }
#line 844
  if ((int const   )*(*p) == 0) {
#line 845
    return (0);
  }
  {
#line 846
  readbyte = *p;
#line 847
  writebyte = 1;
#line 848
  mem_delimiter = delimiter;
#line 849
  skipword___0(p, delimiter);
  }
#line 850
  return (1);
}
}
#line 855 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static void rd_wrt_addr___0(char const   **p , char delimiter ) 
{ 
  int tmp ;

  {
  {
#line 858
  tmp = rd_word___0(p, delimiter);
  }
#line 858
  if (! tmp) {
#line 859
    return;
  }
  {
#line 860
  write_word___0();
  }
#line 861
  return;
}
}
#line 864 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static void rd_wrt_jr___0(char const   **p , char delimiter ) 
{ 
  int tmp ;

  {
  {
#line 867
  tmp = rd_byte___0(p, delimiter);
  }
#line 867
  if (! tmp) {
#line 868
    return;
  }
  {
#line 869
  write_rel___0();
  }
#line 870
  return;
}
}
#line 873 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static int rd_ex1___0(char const   **p ) 
{ 
  char const   *list[4] ;
  int tmp ;

  {
  {
#line 878
  list[0] = "( sp )";
#line 878
  list[1] = "de";
#line 878
  list[2] = "af";
#line 878
  list[3] = (char const   *)((void *)0);
#line 879
  tmp = indx___0(p, list, 1, (char const   **)((void *)0));
  }
#line 879
  return (tmp);
}
}
#line 883 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static int rd_in___0(char const   **p ) 
{ 
  char const   *list[9] ;
  int tmp ;

  {
  {
#line 887
  list[0] = "b";
#line 887
  list[1] = "c";
#line 887
  list[2] = "d";
#line 887
  list[3] = "e";
#line 887
  list[4] = "h";
#line 887
  list[5] = "l";
#line 887
  list[6] = "f";
#line 887
  list[7] = "a";
#line 887
  list[8] = (char const   *)((void *)0);
#line 888
  tmp = indx___0(p, list, 1, (char const   **)((void *)0));
  }
#line 888
  return (tmp);
}
}
#line 892 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static int rd_out___0(char const   **p ) 
{ 
  char const   *list[9] ;
  int tmp ;

  {
  {
#line 895
  list[0] = "b";
#line 895
  list[1] = "c";
#line 895
  list[2] = "d";
#line 895
  list[3] = "e";
#line 895
  list[4] = "h";
#line 895
  list[5] = "l";
#line 895
  list[6] = "0";
#line 895
  list[7] = "a";
#line 895
  list[8] = (char const   *)((void *)0);
#line 896
  tmp = indx___0(p, list, 1, (char const   **)((void *)0));
  }
#line 896
  return (tmp);
}
}
#line 900 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static int rd_nnc___0(char const   **p ) 
{ 
  int i ;
  char const   *list[4] ;

  {
  {
#line 905
  list[0] = "( c )";
#line 905
  list[1] = "(*)";
#line 905
  list[2] = "a , (*)";
#line 905
  list[3] = (char const   *)((void *)0);
#line 906
  i = indx___0(p, list, 1, & readbyte);
  }
#line 907
  if (i < 2) {
#line 908
    return (i);
  }
#line 909
  return (2);
}
}
#line 913 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static int rd_c___0(char const   **p ) 
{ 
  char const   *list[3] ;
  int tmp ;

  {
  {
#line 916
  list[0] = "( c )";
#line 916
  list[1] = "( bc )";
#line 916
  list[2] = (char const   *)((void *)0);
#line 917
  tmp = indx___0(p, list, 1, (char const   **)((void *)0));
  }
#line 917
  return (tmp);
}
}
#line 921 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static int rd_a_hl___0(char const   **p ) 
{ 
  char const   *list[3] ;
  int tmp ;

  {
  {
#line 925
  list[0] = "a";
#line 925
  list[1] = "hl";
#line 925
  list[2] = (char const   *)((void *)0);
#line 926
  tmp = indx___0(p, list, 1, (char const   **)((void *)0));
  }
#line 926
  return (tmp);
}
}
#line 930 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static int rd_ld___0(char const   **p ) 
{ 
  int i ;
  char const   *list[26] ;
  char const   *nn ;

  {
  {
#line 955
  list[0] = "ixh";
#line 955
  list[1] = "ixl";
#line 955
  list[2] = "iyh";
#line 955
  list[3] = "iyl";
#line 955
  list[4] = "bc";
#line 955
  list[5] = "de";
#line 955
  list[6] = "hl";
#line 955
  list[7] = "sp";
#line 955
  list[8] = "ix";
#line 955
  list[9] = "iy";
#line 955
  list[10] = "b";
#line 955
  list[11] = "c";
#line 955
  list[12] = "d";
#line 955
  list[13] = "e";
#line 955
  list[14] = "h";
#line 955
  list[15] = "l";
#line 955
  list[16] = "( hl )";
#line 955
  list[17] = "a";
#line 955
  list[18] = "i";
#line 955
  list[19] = "r";
#line 955
  list[20] = "( bc )";
#line 955
  list[21] = "( de )";
#line 955
  list[22] = "( ix +)";
#line 955
  list[23] = "(iy +)";
#line 955
  list[24] = "(*)";
#line 955
  list[25] = (char const   *)((void *)0);
#line 961
  i = indx___0(p, list, 1, & nn);
  }
#line 962
  if (! i) {
#line 963
    return (0);
  }
#line 964
  if (i <= 2) {
#line 966
    indexed = 221;
#line 967
    return (11 + (i == 2));
  }
#line 969
  if (i <= 4) {
#line 971
    indexed = 253;
#line 972
    return (11 + (i == 4));
  }
#line 974
  i -= 4;
#line 975
  if (i == 5) {
#line 975
    goto _L;
  } else
#line 975
  if (i == 6) {
    _L: /* CIL Label */ 
#line 977
    if (i == 5) {
#line 977
      indexed = 221;
    } else {
#line 977
      indexed = 253;
    }
#line 978
    return (3);
  }
#line 980
  if (i == 19) {
#line 980
    goto _L___0;
  } else
#line 980
  if (i == 20) {
    _L___0: /* CIL Label */ 
#line 982
    indexjmp = nn;
#line 983
    if (i == 19) {
#line 983
      indexed = 221;
    } else {
#line 983
      indexed = 253;
    }
#line 984
    return (13);
  }
#line 986
  if (i == 21) {
#line 987
    readword = nn;
  }
#line 988
  return (i);
}
}
#line 992 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static int rd_jp___0(char const   **p ) 
{ 
  int i ;
  char const   *list[12] ;

  {
  {
#line 996
  list[0] = "nz";
#line 996
  list[1] = "z";
#line 996
  list[2] = "nc";
#line 996
  list[3] = "c";
#line 996
  list[4] = "po";
#line 996
  list[5] = "pe";
#line 996
  list[6] = "p";
#line 996
  list[7] = "m";
#line 996
  list[8] = "( ix )";
#line 996
  list[9] = "( iy )";
#line 996
  list[10] = "(hl)";
#line 996
  list[11] = (char const   *)((void *)0);
#line 1000
  i = indx___0(p, list, 0, (char const   **)((void *)0));
  }
#line 1001
  if (i < 9) {
#line 1002
    return (i);
  }
#line 1003
  if (i == 11) {
#line 1004
    return (-1);
  }
#line 1005
  indexed = 221 + 32 * (i - 9);
#line 1006
  return (-1);
}
}
#line 1010 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static int rd_jr___0(char const   **p ) 
{ 
  char const   *list[5] ;
  int tmp ;

  {
  {
#line 1013
  list[0] = "nz";
#line 1013
  list[1] = "z";
#line 1013
  list[2] = "nc";
#line 1013
  list[3] = "c";
#line 1013
  list[4] = (char const   *)((void *)0);
#line 1014
  tmp = indx___0(p, list, 0, (char const   **)((void *)0));
  }
#line 1014
  return (tmp);
}
}
#line 1018 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static int rd_a___0(char const   **p ) 
{ 
  char const   *list[2] ;
  int tmp ;

  {
  {
#line 1021
  list[0] = "a";
#line 1021
  list[1] = (char const   *)((void *)0);
#line 1022
  tmp = indx___0(p, list, 1, (char const   **)((void *)0));
  }
#line 1022
  return (tmp);
}
}
#line 1026 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static int rd_stack___0(char const   **p ) 
{ 
  int i ;
  char const   *list[7] ;

  {
  {
#line 1030
  list[0] = "bc";
#line 1030
  list[1] = "de";
#line 1030
  list[2] = "hl";
#line 1030
  list[3] = "af";
#line 1030
  list[4] = "ix";
#line 1030
  list[5] = "iy";
#line 1030
  list[6] = (char const   *)((void *)0);
#line 1031
  i = indx___0(p, list, 1, (char const   **)((void *)0));
  }
#line 1032
  if (i < 5) {
#line 1033
    return (i);
  }
#line 1034
  indexed = 221 + 32 * (i - 5);
#line 1035
  return (3);
}
}
#line 1058 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static int rd_r_add___0(char const   **p ) 
{ 
  int i ;
  char const   *list[19] ;
  char const   *nn ;

  {
  {
#line 1063
  list[0] = "ixl";
#line 1063
  list[1] = "ixh";
#line 1063
  list[2] = "iyl";
#line 1063
  list[3] = "iyh";
#line 1063
  list[4] = "b";
#line 1063
  list[5] = "c";
#line 1063
  list[6] = "d";
#line 1063
  list[7] = "e";
#line 1063
  list[8] = "h";
#line 1063
  list[9] = "l";
#line 1063
  list[10] = "( hl )";
#line 1063
  list[11] = "a";
#line 1063
  list[12] = "( ix +)";
#line 1063
  list[13] = "( iy +)";
#line 1063
  list[14] = "hl";
#line 1063
  list[15] = "ix";
#line 1063
  list[16] = "iy";
#line 1063
  list[17] = "*";
#line 1063
  list[18] = (char const   *)((void *)0);
#line 1068
  i = indx___0(p, list, 0, & nn);
  }
#line 1069
  if (i == 18) {
#line 1071
    readbyte = nn;
#line 1072
    writebyte = 1;
#line 1073
    return (7);
  }
#line 1075
  if (i > 14) {
#line 1077
    if (i > 15) {
#line 1078
      indexed = 221 + 32 * (i - 16);
    }
#line 1079
    return (15);
  }
#line 1081
  if (i <= 4) {
#line 1083
    indexed = 221 + 32 * (i > 2);
#line 1084
    return (6 - (i & 1));
  }
#line 1086
  i -= 4;
#line 1087
  if (i < 9) {
#line 1088
    return (i);
  }
#line 1089
  indexed = 221 + 32 * (i - 9);
#line 1090
  indexjmp = nn;
#line 1091
  return (7);
}
}
#line 1095 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static int rd_rr____0(char const   **p ) 
{ 
  char const   *list[5] ;
  int tmp ;

  {
  {
#line 1098
  list[0] = "bc";
#line 1098
  list[1] = "de";
#line 1098
  list[2] = "hl";
#line 1098
  list[3] = "sp";
#line 1098
  list[4] = (char const   *)((void *)0);
#line 1099
  tmp = indx___0(p, list, 1, (char const   **)((void *)0));
  }
#line 1099
  return (tmp);
}
}
#line 1103 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static int rd_rrxx___0(char const   **p ) 
{ 
  char const   *listx[5] ;
  char const   *listy[5] ;
  char const   *list[5] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1106
  listx[0] = "bc";
#line 1106
  listx[1] = "de";
#line 1106
  listx[2] = "ix";
#line 1106
  listx[3] = "sp";
#line 1106
  listx[4] = (char const   *)((void *)0);
#line 1107
  listy[0] = "bc";
#line 1107
  listy[1] = "de";
#line 1107
  listy[2] = "iy";
#line 1107
  listy[3] = "sp";
#line 1107
  listy[4] = (char const   *)((void *)0);
#line 1108
  list[0] = "bc";
#line 1108
  list[1] = "de";
#line 1108
  list[2] = "hl";
#line 1108
  list[3] = "sp";
#line 1108
  list[4] = (char const   *)((void *)0);
  {
#line 1111
  if (indexed == 221) {
#line 1111
    goto case_221;
  }
#line 1113
  if (indexed == 253) {
#line 1113
    goto case_253;
  }
#line 1115
  goto switch_default;
  case_221: /* CIL Label */ 
  {
#line 1112
  tmp = indx___0(p, listx, 1, (char const   **)((void *)0));
  }
#line 1112
  return (tmp);
  case_253: /* CIL Label */ 
  {
#line 1114
  tmp___0 = indx___0(p, listy, 1, (char const   **)((void *)0));
  }
#line 1114
  return (tmp___0);
  switch_default: /* CIL Label */ 
  {
#line 1116
  tmp___1 = indx___0(p, list, 1, (char const   **)((void *)0));
  }
#line 1116
  return (tmp___1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1122 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static int rd_r___0(char const   **p ) 
{ 
  int i ;
  char const   *list[16] ;
  char const   *nn ;

  {
  {
#line 1126
  list[0] = "ixl";
#line 1126
  list[1] = "ixh";
#line 1126
  list[2] = "iyl";
#line 1126
  list[3] = "iyh";
#line 1126
  list[4] = "b";
#line 1126
  list[5] = "c";
#line 1126
  list[6] = "d";
#line 1126
  list[7] = "e";
#line 1126
  list[8] = "h";
#line 1126
  list[9] = "l";
#line 1126
  list[10] = "( hl )";
#line 1126
  list[11] = "a";
#line 1126
  list[12] = "( ix +)";
#line 1126
  list[13] = "( iy +)";
#line 1126
  list[14] = "*";
#line 1126
  list[15] = (char const   *)((void *)0);
#line 1131
  i = indx___0(p, list, 0, & nn);
  }
#line 1132
  if (i == 15) {
#line 1134
    readbyte = nn;
#line 1135
    writebyte = 1;
#line 1136
    return (7);
  }
#line 1138
  if (i <= 4) {
#line 1140
    indexed = 221 + 32 * (i > 2);
#line 1141
    return (6 - (i & 1));
  }
#line 1143
  i -= 4;
#line 1144
  if (i < 9) {
#line 1145
    return (i);
  }
#line 1146
  indexed = 221 + 32 * (i - 9);
#line 1147
  indexjmp = nn;
#line 1148
  return (7);
}
}
#line 1152 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static int rd_r____0(char const   **p ) 
{ 
  int i ;
  char const   *list[11] ;

  {
  {
#line 1156
  list[0] = "b";
#line 1156
  list[1] = "c";
#line 1156
  list[2] = "d";
#line 1156
  list[3] = "e";
#line 1156
  list[4] = "h";
#line 1156
  list[5] = "l";
#line 1156
  list[6] = "( hl )";
#line 1156
  list[7] = "a";
#line 1156
  list[8] = "( ix +)";
#line 1156
  list[9] = "( iy +)";
#line 1156
  list[10] = (char const   *)((void *)0);
#line 1159
  i = indx___0(p, list, 1, & indexjmp);
  }
#line 1160
  if (i < 9) {
#line 1161
    return (i);
  }
#line 1162
  indexed = 221 + 32 * (i - 9);
#line 1163
  return (7);
}
}
#line 1167 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static int rd_0_7___0(char const   **p ) 
{ 


  {
  {
#line 1170
  *p = delspc(*p);
  }
#line 1171
  if ((int const   )*(*p) == 0) {
#line 1172
    return (0);
  }
  {
#line 1173
  bitsetres = *p;
#line 1174
  skipword___0(p, (char )',');
  }
#line 1175
  return (1);
}
}
#line 1179 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static int rd_cc___0(char const   **p ) 
{ 
  char const   *list[9] ;
  int tmp ;

  {
  {
#line 1182
  list[0] = "nz";
#line 1182
  list[1] = "z";
#line 1182
  list[2] = "nc";
#line 1182
  list[3] = "c";
#line 1182
  list[4] = "po";
#line 1182
  list[5] = "pe";
#line 1182
  list[6] = "p";
#line 1182
  list[7] = "m";
#line 1182
  list[8] = (char const   *)((void *)0);
#line 1183
  tmp = indx___0(p, list, 0, (char const   **)((void *)0));
  }
#line 1183
  return (tmp);
}
}
#line 1187 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static int rd_r_rr___0(char const   **p ) 
{ 
  int i ;
  char const   *list[18] ;

  {
  {
#line 1191
  list[0] = "iy";
#line 1191
  list[1] = "ix";
#line 1191
  list[2] = "sp";
#line 1191
  list[3] = "hl";
#line 1191
  list[4] = "de";
#line 1191
  list[5] = "bc";
#line 1191
  list[6] = "";
#line 1191
  list[7] = "b";
#line 1191
  list[8] = "c";
#line 1191
  list[9] = "d";
#line 1191
  list[10] = "e";
#line 1191
  list[11] = "h";
#line 1191
  list[12] = "l";
#line 1191
  list[13] = "( hl )";
#line 1191
  list[14] = "a";
#line 1191
  list[15] = "( ix +)";
#line 1191
  list[16] = "( iy +)";
#line 1191
  list[17] = (char const   *)((void *)0);
#line 1195
  i = indx___0(p, list, 1, & indexjmp);
  }
#line 1196
  if (! i) {
#line 1197
    return (0);
  }
#line 1198
  if (i < 16) {
#line 1198
    if (i > 2) {
#line 1199
      return (7 - i);
    }
  }
#line 1200
  if (i > 15) {
#line 1202
    indexed = 221 + (i - 16) * 32;
#line 1203
    return (-7);
  }
#line 1205
  indexed = 221 + (2 - i) * 32;
#line 1206
  return (3);
}
}
#line 1210 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static int rd_hl___0(char const   **p ) 
{ 
  char const   *list[2] ;
  int tmp ;

  {
  {
#line 1213
  list[0] = "hl";
#line 1213
  list[1] = (char const   *)((void *)0);
#line 1214
  tmp = indx___0(p, list, 1, (char const   **)((void *)0));
  }
#line 1214
  return (tmp);
}
}
#line 1218 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static int rd_hlx___0(char const   **p ) 
{ 
  int i ;
  char const   *list[4] ;

  {
  {
#line 1222
  list[0] = "hl";
#line 1222
  list[1] = "ix";
#line 1222
  list[2] = "iy";
#line 1222
  list[3] = (char const   *)((void *)0);
#line 1223
  i = indx___0(p, list, 1, (char const   **)((void *)0));
  }
#line 1224
  if (i < 2) {
#line 1225
    return (i);
  }
#line 1226
  indexed = 221 + 32 * (i - 2);
#line 1227
  return (1);
}
}
#line 1231 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static int rd_af____0(char const   **p ) 
{ 
  char const   *list[2] ;
  int tmp ;

  {
  {
#line 1234
  list[0] = "af\'";
#line 1234
  list[1] = (char const   *)((void *)0);
#line 1235
  tmp = indx___0(p, list, 1, (char const   **)((void *)0));
  }
#line 1235
  return (tmp);
}
}
#line 1239 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static int rd_0_2___0(char const   **p ) 
{ 
  char const   *list[5] ;
  int tmp ;

  {
  {
#line 1242
  list[0] = "0";
#line 1242
  list[1] = "";
#line 1242
  list[2] = "1";
#line 1242
  list[3] = "2";
#line 1242
  list[4] = (char const   *)((void *)0);
#line 1243
  tmp = indx___0(p, list, 1, (char const   **)((void *)0));
  }
#line 1243
  return (tmp);
}
}
#line 1247 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static int rd_ld_hl___0(char const   **p ) 
{ 
  int i ;
  char const   *list[10] ;

  {
  {
#line 1251
  list[0] = "b";
#line 1251
  list[1] = "c";
#line 1251
  list[2] = "d";
#line 1251
  list[3] = "e";
#line 1251
  list[4] = "h";
#line 1251
  list[5] = "l";
#line 1251
  list[6] = "";
#line 1251
  list[7] = "a";
#line 1251
  list[8] = "*";
#line 1251
  list[9] = (char const   *)((void *)0);
#line 1252
  i = indx___0(p, list, 0, & readbyte);
  }
#line 1253
  if (i < 9) {
#line 1254
    return (i);
  }
#line 1255
  writebyte = 1;
#line 1256
  return (7);
}
}
#line 1260 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static int rd_ld_nn___0(char const   **p ) 
{ 
  int i ;
  char const   *list[9] ;

  {
  {
#line 1266
  list[0] = "bc";
#line 1266
  list[1] = "de";
#line 1266
  list[2] = "";
#line 1266
  list[3] = "sp";
#line 1266
  list[4] = "hl";
#line 1266
  list[5] = "a";
#line 1266
  list[6] = "ix";
#line 1266
  list[7] = "iy";
#line 1266
  list[8] = (char const   *)((void *)0);
#line 1267
  i = indx___0(p, list, 1, (char const   **)((void *)0));
  }
#line 1268
  if (i < 7) {
#line 1269
    return (i);
  }
#line 1270
  indexed = 221 + 32 * (i == 8);
#line 1271
  return (5);
}
}
#line 1275 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static int rd_lda___0(char const   **p ) 
{ 
  int i ;
  char const   *list[18] ;
  char const   *nn ;

  {
  {
#line 1282
  list[0] = "( sp )";
#line 1282
  list[1] = "( iy +)";
#line 1282
  list[2] = "( de )";
#line 1282
  list[3] = "( bc )";
#line 1282
  list[4] = "( ix +)";
#line 1282
  list[5] = "b";
#line 1282
  list[6] = "c";
#line 1282
  list[7] = "d";
#line 1282
  list[8] = "e";
#line 1282
  list[9] = "h";
#line 1282
  list[10] = "l";
#line 1282
  list[11] = "( hl )";
#line 1282
  list[12] = "a";
#line 1282
  list[13] = "i";
#line 1282
  list[14] = "r";
#line 1282
  list[15] = "(*)";
#line 1282
  list[16] = "*";
#line 1282
  list[17] = (char const   *)((void *)0);
#line 1287
  i = indx___0(p, list, 0, & nn);
  }
#line 1288
  if (i == 2) {
#line 1288
    goto _L;
  } else
#line 1288
  if (i == 5) {
    _L: /* CIL Label */ 
#line 1290
    if (i == 2) {
#line 1290
      indexed = 253;
    } else {
#line 1290
      indexed = 221;
    }
#line 1291
    indexjmp = nn;
#line 1292
    return (7);
  }
#line 1294
  if (i == 17) {
#line 1296
    readbyte = nn;
#line 1297
    writebyte = 1;
#line 1298
    return (7);
  }
#line 1300
  if (i == 16) {
#line 1302
    readword = nn;
  }
#line 1304
  return (i - 5);
}
}
#line 1308 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static int rd_ldbcdehla___0(char const   **p ) 
{ 
  int i ;
  char const   *list[16] ;
  char const   *nn ;
  int x ;

  {
  {
#line 1312
  list[0] = "b";
#line 1312
  list[1] = "c";
#line 1312
  list[2] = "d";
#line 1312
  list[3] = "e";
#line 1312
  list[4] = "h";
#line 1312
  list[5] = "l";
#line 1312
  list[6] = "( hl )";
#line 1312
  list[7] = "a";
#line 1312
  list[8] = "( ix +)";
#line 1312
  list[9] = "( iy +)";
#line 1312
  list[10] = "ixh";
#line 1312
  list[11] = "ixl";
#line 1312
  list[12] = "iyh";
#line 1312
  list[13] = "iyl";
#line 1312
  list[14] = "*";
#line 1312
  list[15] = (char const   *)((void *)0);
#line 1317
  i = indx___0(p, list, 0, & nn);
  }
#line 1318
  if (i == 15) {
#line 1320
    readbyte = nn;
#line 1321
    writebyte = 1;
#line 1322
    return (7);
  }
#line 1324
  if (i > 10) {
#line 1327
    x = 221 + 32 * (i > 12);
#line 1328
    if (indexed) {
#line 1328
      if (indexed != x) {
        {
#line 1330
        printerr(1, "illegal use of index registers\n");
        }
#line 1331
        return (0);
      }
    }
#line 1333
    indexed = x;
#line 1334
    return (6 - (i & 1));
  }
#line 1336
  if (i > 8) {
#line 1338
    if (indexed) {
      {
#line 1340
      printerr(1, "illegal use of index registers\n");
      }
#line 1341
      return (0);
    }
#line 1343
    indexed = 221 + 32 * (i == 10);
#line 1344
    indexjmp = nn;
#line 1345
    return (7);
  }
#line 1347
  return (i);
}
}
#line 1351 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static int rd_nn_nn___0(char const   **p ) 
{ 
  char const   *list[3] ;
  int tmp ;

  {
  {
#line 1355
  list[0] = "(*)";
#line 1355
  list[1] = "*";
#line 1355
  list[2] = (char const   *)((void *)0);
#line 1356
  tmp = indx___0(p, list, 0, & readword);
  }
#line 1356
  return (2 - tmp);
}
}
#line 1360 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static int rd_sp___0(char const   **p ) 
{ 
  int i ;
  char const   *list[6] ;
  char const   *nn ;
  int tmp ;

  {
  {
#line 1366
  list[0] = "hl";
#line 1366
  list[1] = "ix";
#line 1366
  list[2] = "iy";
#line 1366
  list[3] = "(*)";
#line 1366
  list[4] = "*";
#line 1366
  list[5] = (char const   *)((void *)0);
#line 1368
  i = indx___0(p, list, 0, & nn);
  }
#line 1369
  if (i > 3) {
#line 1371
    readword = nn;
#line 1372
    if (i == 4) {
#line 1372
      tmp = 2;
    } else {
#line 1372
      tmp = 0;
    }
#line 1372
    return (tmp);
  }
#line 1374
  if (i != 1) {
#line 1375
    indexed = 221 + 32 * (i - 2);
  }
#line 1376
  return (1);
}
}
#line 1380 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static void wrt_ref___0(int val , int type , int count ) 
{ 
  int tmp ;

  {
  {
#line 1385
  if (type == 2) {
#line 1385
    goto case_2;
  }
#line 1393
  if (type == 3) {
#line 1393
    goto case_3;
  }
#line 1399
  if (type == 4) {
#line 1399
    goto case_4;
  }
#line 1404
  if (type == 1) {
#line 1404
    goto case_1;
  }
#line 1417
  if (type == 0) {
#line 1417
    goto case_0;
  }
#line 1425
  if (type == 5) {
#line 1425
    goto case_5;
  }
#line 1433
  if (type == 6) {
#line 1433
    goto case_6;
  }
#line 1383
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1386
  if ((val & 56) != val) {
    {
#line 1388
    printerr(1, "incorrect RST value %d (0x%02x)\n", val, val);
    }
#line 1389
    return;
  }
  {
#line 1391
  write_one_byte___0(val + 199, 1);
  }
#line 1392
  return;
  case_3: /* CIL Label */ 
#line 1394
  if (val < -32768) {
    {
#line 1395
    printerr(0, "word value %d (0x%x) truncated\n", val, val);
    }
  } else
#line 1394
  if (val >= 65536) {
    {
#line 1395
    printerr(0, "word value %d (0x%x) truncated\n", val, val);
    }
  }
  {
#line 1396
  write_one_byte___0(val & 255, 1);
#line 1397
  write_one_byte___0((val >> 8) & 255, 1);
  }
#line 1398
  return;
  case_4: /* CIL Label */ 
#line 1400
  if (val < -128) {
    {
#line 1401
    printerr(0, "byte value %d (0x%x) truncated\n", val, val);
    }
  } else
#line 1400
  if (val >= 256) {
    {
#line 1401
    printerr(0, "byte value %d (0x%x) truncated\n", val, val);
    }
  }
  {
#line 1402
  write_one_byte___0(val & 255, 1);
  }
#line 1403
  return;
  case_1: /* CIL Label */ 
#line 1405
  if (val < -128) {
    {
#line 1406
    printerr(0, "byte value %d (0x%x) truncated\n", val, val);
    }
  } else
#line 1405
  if (val >= 256) {
    {
#line 1406
    printerr(0, "byte value %d (0x%x) truncated\n", val, val);
    }
  }
#line 1407
  if (havelist) {
    {
#line 1409
    fprintf((FILE */* __restrict  */)listfile, (char const   */* __restrict  */)" 0x%02x...",
            val & 255);
#line 1410
    listdepth += 6;
    }
  }
  {
#line 1412
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1412
    tmp = count;
#line 1412
    count --;
#line 1412
    if (! tmp) {
#line 1412
      goto while_break;
    }
    {
#line 1414
    write_one_byte___0(val & 255, 0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1416
  return;
  case_0: /* CIL Label */ 
#line 1418
  if (val & -8) {
    {
#line 1420
    printerr(1, "incorrect BIT/SET/RES value %d\n", val);
    }
#line 1421
    return;
  }
  {
#line 1423
  write_one_byte___0(8 * val + count, 1);
  }
#line 1424
  return;
  case_5: /* CIL Label */ 
#line 1426
  val -= count;
#line 1427
  if (val & 65408) {
#line 1427
    if (~ val & 65408) {
      {
#line 1429
      printerr(1, "relative jump out of range (%d)\n", val);
      }
    }
  }
  {
#line 1431
  write_one_byte___0(val & 255, 1);
  }
#line 1432
  return;
  case_6: /* CIL Label */ 
  {
#line 1434
  printerr(1, "bug in the assembler: trying to write label reference.  Please report.\n");
  }
#line 1436
  return;
  switch_break: /* CIL Label */ ;
  }
#line 1438
  return;
}
}
#line 1440 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static char *get_include_name___0(char const   **ptr ) 
{ 
  int pos ;
  char quote ;
  char *name ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;

  {
  {
#line 1443
  pos = 0;
#line 1446
  *ptr = delspc(*ptr);
#line 1447
  tmp = strlen(*ptr);
#line 1447
  tmp___0 = malloc(tmp);
#line 1447
  name = (char *)tmp___0;
  }
#line 1448
  if (! name) {
    {
#line 1450
    tmp___1 = strlen(*ptr);
#line 1450
    printerr(1, "unable to allocate memory for filename %.*s\n", tmp___1 - 1UL, *ptr);
    }
#line 1452
    return ((char *)((void *)0));
  }
#line 1454
  if (! *(*ptr)) {
    {
#line 1456
    printerr(1, "include without filename\n");
#line 1457
    free((void *)name);
    }
#line 1458
    return ((char *)((void *)0));
  }
#line 1460
  tmp___2 = *ptr;
#line 1460
  (*ptr) ++;
#line 1460
  quote = (char )*tmp___2;
  {
#line 1461
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1461
    if (! ((int const   )*(*ptr) != (int const   )quote)) {
#line 1461
      goto while_break;
    }
#line 1463
    if (! *(*ptr)) {
      {
#line 1465
      printerr(1, "filename without closing quote (%c)\n", (int )quote);
#line 1466
      free((void *)name);
      }
#line 1467
      return ((char *)((void *)0));
    }
#line 1469
    tmp___3 = pos;
#line 1469
    pos ++;
#line 1469
    tmp___4 = *ptr;
#line 1469
    (*ptr) ++;
#line 1469
    *(name + tmp___3) = (char )*tmp___4;
  }
  while_break: /* CIL Label */ ;
  }
#line 1471
  *(name + pos) = (char)0;
#line 1472
  (*ptr) ++;
#line 1473
  return (name);
}
}
#line 1484 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static char short_buffer___0[301]  ;
#line 1476 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static int read_line___0(void) 
{ 
  unsigned int pos ;
  unsigned int newpos ;
  unsigned int size ;
  struct macro_arg *arg ;
  FILE *f ;
  char *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char *b ;
  char *tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  unsigned int i ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;
  size_t tmp___8 ;

  {
#line 1481
  if (stack[sp].file) {
#line 1483
    f = stack[sp].file;
#line 1485
    if (buffer) {
#line 1485
      if ((unsigned long )buffer != (unsigned long )(short_buffer___0)) {
        {
#line 1486
        free((void *)buffer);
        }
      }
    }
    {
#line 1487
    buffer = (char *)((void *)0);
#line 1488
    tmp = fgets((char */* __restrict  */)(short_buffer___0), 301, (FILE */* __restrict  */)f);
    }
#line 1488
    if (! tmp) {
#line 1489
      return (0);
    }
    {
#line 1490
    tmp___0 = strlen((char const   *)(short_buffer___0));
    }
#line 1490
    if (tmp___0 < 300UL) {
#line 1492
      buffer = short_buffer___0;
#line 1493
      return (1);
    }
    {
#line 1495
    size = 600U;
#line 1496
    tmp___1 = malloc((size_t )(size + 1U));
#line 1496
    buffer = (char *)tmp___1;
    }
#line 1497
    if (! buffer) {
      {
#line 1499
      printerr(1, "out of memory reading line\n");
      }
#line 1500
      return (0);
    }
    {
#line 1502
    memcpy((void */* __restrict  */)buffer, (void const   */* __restrict  */)(short_buffer___0),
           (size_t )301);
    }
    {
#line 1503
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1506
      tmp___2 = fgets((char */* __restrict  */)(buffer + (size - 300U)), 301, (FILE */* __restrict  */)f);
      }
#line 1506
      if (tmp___2) {
        {
#line 1506
        tmp___3 = strlen((char const   *)buffer);
        }
#line 1506
        if ((int )*(buffer + (tmp___3 - 1UL)) == 10) {
#line 1509
          return (1);
        }
      } else {
#line 1509
        return (1);
      }
      {
#line 1511
      size += 300U;
#line 1512
      tmp___4 = realloc((void *)buffer, (size_t )(size + 1U));
#line 1512
      b = (char *)tmp___4;
      }
#line 1513
      if (! b) {
        {
#line 1515
        printerr(1, "out of memory reading line\n");
        }
#line 1516
        return (0);
      }
#line 1518
      buffer = b;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1522
  if (! stack[sp].macro_line) {
#line 1525
    i = 0U;
    {
#line 1525
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1525
      if (! (i < (stack[sp].macro)->numargs)) {
#line 1525
        goto while_break___0;
      }
      {
#line 1526
      free((void *)*(stack[sp].macro_args + i));
#line 1525
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1527
    free((void *)stack[sp].macro_args);
    }
#line 1528
    return (0);
  }
  {
#line 1530
  tmp___5 = strlen((char const   *)(stack[sp].macro_line)->line);
#line 1530
  size = (unsigned int )(tmp___5 + 1UL);
#line 1531
  arg = (stack[sp].macro_line)->args;
  }
  {
#line 1531
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1531
    if (! arg) {
#line 1531
      goto while_break___1;
    }
    {
#line 1532
    tmp___6 = strlen((char const   *)*(stack[sp].macro_args + arg->which));
#line 1532
    size = (unsigned int )((size_t )size + tmp___6);
#line 1531
    arg = arg->next;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1533
  tmp___7 = malloc((size_t )size);
#line 1533
  buffer = (char *)tmp___7;
  }
#line 1534
  if (! buffer) {
    {
#line 1536
    printerr(1, "out of memory\n");
    }
#line 1537
    return (0);
  }
#line 1539
  pos = 0U;
#line 1540
  newpos = 0U;
#line 1541
  arg = (stack[sp].macro_line)->args;
  {
#line 1541
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1541
    if (! arg) {
#line 1541
      goto while_break___2;
    }
    {
#line 1543
    memcpy((void */* __restrict  */)(buffer + newpos), (void const   */* __restrict  */)((stack[sp].macro_line)->line + pos),
           (size_t )(arg->pos - pos));
#line 1545
    newpos += arg->pos - pos;
#line 1546
    strcpy((char */* __restrict  */)(buffer + newpos), (char const   */* __restrict  */)*(stack[sp].macro_args + arg->which));
#line 1547
    tmp___8 = strlen((char const   *)*(stack[sp].macro_args + arg->which));
#line 1547
    newpos = (unsigned int )((size_t )newpos + tmp___8);
#line 1548
    pos = arg->pos + 1U;
#line 1541
    arg = arg->next;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 1550
  strcpy((char */* __restrict  */)(buffer + newpos), (char const   */* __restrict  */)((stack[sp].macro_line)->line + pos));
#line 1551
  stack[sp].macro_line = (stack[sp].macro_line)->next;
  }
#line 1552
  return (1);
}
}
#line 1555 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static unsigned int get_macro_args___0(char const   **ptr , char ***ret_args , int allow_empty ) 
{ 
  unsigned int numargs ;
  char **args ;
  char const   *c ;
  char *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1558
  numargs = 0U;
#line 1559
  *ret_args = (char **)((void *)0);
  {
#line 1560
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1564
    *ptr = delspc(*ptr);
    }
#line 1565
    if (! *(*ptr)) {
#line 1566
      goto while_break;
    }
#line 1567
    c = *ptr;
    {
#line 1568
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1568
      if (*(*ptr)) {
        {
#line 1568
        tmp = strchr(" \r\n\t,;", (int )*(*ptr));
        }
#line 1568
        if (tmp) {
#line 1568
          goto while_break___0;
        }
      } else {
#line 1568
        goto while_break___0;
      }
#line 1568
      (*ptr) ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1571
    if ((unsigned long )*ptr == (unsigned long )c) {
#line 1571
      if (! allow_empty) {
        {
#line 1573
        printerr(1, "empty macro argument\n");
        }
#line 1574
        goto while_break;
      }
    }
    {
#line 1576
    numargs ++;
#line 1577
    tmp___0 = realloc((void *)*ret_args, sizeof(char *) * (unsigned long )numargs);
#line 1577
    args = (char **)tmp___0;
    }
#line 1578
    if (! args) {
      {
#line 1580
      printerr(1, "out of memory\n");
#line 1581
      numargs --;
      }
#line 1582
      goto while_break;
    }
    {
#line 1584
    *ret_args = args;
#line 1585
    tmp___1 = malloc((size_t )((*ptr - c) + 1L));
#line 1585
    *(args + (numargs - 1U)) = (char *)tmp___1;
    }
#line 1586
    if (! *(args + (numargs - 1U))) {
      {
#line 1588
      printerr(1, "out of memory\n");
#line 1589
      numargs --;
      }
#line 1590
      goto while_break;
    }
    {
#line 1592
    memcpy((void */* __restrict  */)*(args + (numargs - 1U)), (void const   */* __restrict  */)c,
           (size_t )(*ptr - c));
#line 1593
    *(*(args + (numargs - 1U)) + (*ptr - c)) = (char)0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1595
  return (numargs);
}
}
#line 1599 "/home/june/repo/benchmarks/collector/temp/z80asm-1.8/z80asm.c"
static void assemble___0(void) 
{ 
  int ifcount ;
  int noifcount ;
  char const   *ptr ;
  struct label *l ;
  char *bufptr ;
  int r ;
  int s ;
  int file_ended ;
  int cmd ;
  int cont ;
  int i ;
  int tabs ;
  int tmp ;
  struct reference *ref ;
  struct reference *nextref ;
  struct label *next ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *newptr ;
  struct macro_line **current_line ;
  void *tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;
  unsigned int p ;
  struct macro_arg **last_arg ;
  struct macro_arg *newarg ;
  void *tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  char const   *tmp___12 ;
  int i___0 ;
  int have_quote ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  char const   *tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  char const   *tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int quote ;
  int tmp___28 ;
  int tmp___29 ;
  int x ;
  struct name *name ;
  char *nm ;
  char *tmp___30 ;
  size_t tmp___31 ;
  void *tmp___32 ;
  FILE *incfile ;
  char *name___0 ;
  char *tmp___33 ;
  char filebuffer[4096] ;
  size_t num ;
  size_t tmp___34 ;
  int *tmp___35 ;
  char *tmp___36 ;
  size_t tmp___37 ;
  int tmp___38 ;
  struct macro *m ;
  int tmp___39 ;
  void *tmp___40 ;
  size_t tmp___41 ;
  void *tmp___42 ;
  unsigned int seekaddr ;
  int tmp___43 ;
  char const   *tmp___44 ;
  struct macro *m___0 ;
  unsigned int numargs ;
  int x___0 ;
  size_t tmp___45 ;
  unsigned int a ;
  size_t tmp___46 ;
  int tmp___47 ;
  struct reference *next___0 ;
  struct reference *tmp___48 ;
  int ref___0 ;

  {
#line 1602
  ifcount = 0;
#line 1602
  noifcount = 0;
#line 1608
  file = 0;
  {
#line 1608
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1608
    if (! (file < infilecount)) {
#line 1608
      goto while_break;
    }
#line 1610
    file_ended = 0;
#line 1611
    sp = 0;
#line 1612
    stack[sp].line = 0;
#line 1613
    stack[sp].shouldclose = 0;
#line 1614
    stack[sp].name = (infile + file)->name;
#line 1615
    stack[sp].dir = (struct includedir *)((void *)0);
#line 1616
    if ((int const   )*((infile + file)->name + 0) == 45) {
#line 1616
      if ((int const   )*((infile + file)->name + 1) == 0) {
#line 1618
        stack[sp].file = stdin;
      } else {
#line 1616
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 1622
      stack[sp].file = fopen((char const   */* __restrict  */)(infile + file)->name,
                             (char const   */* __restrict  */)"r");
      }
#line 1623
      if (! stack[sp].file) {
        {
#line 1625
        printerr(1, "unable to open %s. skipping\n", (infile + file)->name);
        }
#line 1626
        goto __Cont;
      }
#line 1628
      stack[sp].shouldclose = 1;
    }
#line 1630
    if (havelist) {
      {
#line 1631
      fprintf((FILE */* __restrict  */)listfile, (char const   */* __restrict  */)"# File %s\n",
              stack[sp].name);
      }
    }
#line 1632
    if (buffer) {
#line 1633
      *(buffer + 0) = (char)0;
    }
    {
#line 1635
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1637
      cont = 1;
#line 1638
      if (havelist) {
#line 1640
        if (buffer) {
#line 1640
          if ((int )*(buffer + 0) != 0) {
            {
#line 1643
            ptr = delspc(ptr);
            }
#line 1644
            if ((int const   )*ptr != 0) {
              {
#line 1646
              printerr(1, "junk at end of line: %s\n", ptr);
              }
            }
#line 1648
            if (listdepth < 8) {
#line 1649
              tabs = 3;
            } else
#line 1650
            if (listdepth < 16) {
#line 1651
              tabs = 2;
            } else {
#line 1653
              tabs = 1;
            }
#line 1654
            i = 0;
            {
#line 1654
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 1654
              if (! (i < tabs)) {
#line 1654
                goto while_break___1;
              }
              {
#line 1655
              fputc('\t', listfile);
#line 1654
              i ++;
              }
            }
            while_break___1: /* CIL Label */ ;
            }
            {
#line 1656
            fprintf((FILE */* __restrict  */)listfile, (char const   */* __restrict  */)"%s\n",
                    buffer);
            }
          }
        }
#line 1658
        listdepth = 4;
      }
#line 1661
      if (file_ended) {
        {
#line 1663
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
#line 1663
          tmp = read_line___0();
          }
#line 1663
          if (! tmp) {
#line 1663
            goto while_break___2;
          }
#line 1665
          if (havelist) {
            {
#line 1666
            fprintf((FILE */* __restrict  */)listfile, (char const   */* __restrict  */)"\t\t\t%s\n",
                    buffer);
            }
          }
        }
        while_break___2: /* CIL Label */ ;
        }
#line 1668
        file_ended = 0;
      }
      {
#line 1670
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 1670
        tmp___2 = read_line___0();
        }
#line 1670
        if (tmp___2) {
#line 1670
          goto while_break___3;
        }
#line 1674
        if (verbose >= 6) {
          {
#line 1675
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"finished reading file %s\n",
                  stack[sp].name);
          }
        }
#line 1677
        if (havelist) {
#line 1679
          if (stack[sp].file) {
            {
#line 1680
            fprintf((FILE */* __restrict  */)listfile, (char const   */* __restrict  */)"# End of file %s\n",
                    stack[sp].name);
            }
          } else {
            {
#line 1682
            fprintf((FILE */* __restrict  */)listfile, (char const   */* __restrict  */)"# End of macro %s\n",
                    stack[sp].name);
            }
          }
        }
#line 1684
        if (stack[sp].shouldclose) {
          {
#line 1685
          fclose(stack[sp].file);
          }
        }
#line 1689
        ref = firstreference;
        {
#line 1689
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 1689
          if (! ref) {
#line 1689
            goto while_break___4;
          }
          {
#line 1691
          nextref = ref->next;
#line 1692
          compute_ref(ref, 1);
          }
#line 1693
          if (ref->done) {
#line 1694
            goto __Cont___0;
          }
#line 1695
          if (ref->level == sp) {
#line 1696
            tmp___0 = ref->level;
#line 1696
            (ref->level) --;
#line 1696
            if (! tmp___0) {
              {
#line 1698
              printerr(1, "unable to resolve reference: %s\n", ref->input);
              }
#line 1700
              if (ref->prev) {
#line 1701
                (ref->prev)->next = ref->next;
              } else {
#line 1703
                firstreference = ref->next;
              }
#line 1704
              if (ref->next) {
#line 1705
                (ref->next)->prev = ref->prev;
              }
              {
#line 1706
              free((void *)ref);
              }
            }
          }
          __Cont___0: /* CIL Label */ 
#line 1689
          ref = nextref;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 1710
        l = stack[sp].labels;
        {
#line 1710
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 1710
          if (! l) {
#line 1710
            goto while_break___5;
          }
#line 1712
          next = l->next;
#line 1713
          if (l->ref) {
            {
#line 1714
            free((void *)l->ref);
            }
          }
          {
#line 1715
          free((void *)l);
#line 1710
          l = next;
          }
        }
        while_break___5: /* CIL Label */ ;
        }
#line 1717
        stack[sp].labels = (struct label *)((void *)0);
#line 1718
        tmp___1 = sp;
#line 1718
        sp --;
#line 1718
        if (! tmp___1) {
#line 1720
          cont = 0;
#line 1721
          goto while_break___3;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 1724
      if (! cont) {
#line 1725
        goto while_break___0;
      }
#line 1726
      if (havelist) {
        {
#line 1727
        fprintf((FILE */* __restrict  */)listfile, (char const   */* __restrict  */)"%04x",
                addr);
        }
      }
#line 1728
      bufptr = buffer;
      {
#line 1728
      while (1) {
        while_continue___6: /* CIL Label */ ;
        {
#line 1728
        bufptr = strchr((char const   *)bufptr, '\n');
        }
#line 1728
        if (! bufptr) {
#line 1728
          goto while_break___6;
        }
#line 1729
        *bufptr = (char )' ';
      }
      while_break___6: /* CIL Label */ ;
      }
#line 1730
      bufptr = buffer;
      {
#line 1730
      while (1) {
        while_continue___7: /* CIL Label */ ;
        {
#line 1730
        bufptr = strchr((char const   *)bufptr, '\r');
        }
#line 1730
        if (! bufptr) {
#line 1730
          goto while_break___7;
        }
#line 1731
        *bufptr = (char )' ';
      }
      while_break___7: /* CIL Label */ ;
      }
      {
#line 1732
      ptr = (char const   *)buffer;
#line 1733
      lastlabel = (struct label *)((void *)0);
#line 1734
      baseaddr = addr;
#line 1735
      (stack[sp].line) ++;
#line 1736
      ptr = delspc(ptr);
      }
#line 1737
      if (! *ptr) {
#line 1738
        goto while_continue___0;
      }
#line 1739
      if (! noifcount) {
#line 1739
        if (! define_macro) {
          {
#line 1740
          readlabel___0(& ptr, 1);
          }
        } else {
          {
#line 1742
          readlabel___0(& ptr, 0);
          }
        }
      } else {
        {
#line 1742
        readlabel___0(& ptr, 0);
        }
      }
      {
#line 1743
      ptr = delspc(ptr);
      }
#line 1744
      if (! *ptr) {
#line 1745
        goto while_continue___0;
      }
      {
#line 1746
      comma = 0;
#line 1747
      indexed = 0;
#line 1748
      indexjmp = (char const   *)0;
#line 1749
      writebyte = 0;
#line 1750
      readbyte = (char const   *)0;
#line 1751
      readword = (char const   *)0;
#line 1752
      tmp___3 = readcommand___0(& ptr);
#line 1752
      cmd = tmp___3 - 1;
      }
#line 1753
      if (noifcount) {
        {
#line 1757
        if (cmd == 81) {
#line 1757
          goto case_81;
        }
#line 1760
        if (cmd == 82) {
#line 1760
          goto case_82;
        }
#line 1767
        if (cmd == 83) {
#line 1767
          goto case_83;
        }
#line 1755
        goto switch_break;
        case_81: /* CIL Label */ 
#line 1758
        noifcount ++;
#line 1759
        goto switch_break;
        case_82: /* CIL Label */ 
#line 1761
        if (noifcount == 1) {
#line 1763
          noifcount = 0;
#line 1764
          ifcount ++;
        }
#line 1766
        goto switch_break;
        case_83: /* CIL Label */ 
#line 1768
        noifcount --;
        switch_break: /* CIL Label */ ;
        }
#line 1770
        ptr = "";
#line 1771
        goto while_continue___0;
      }
#line 1773
      if (define_macro) {
#line 1777
        current_line = & firstmacro->lines;
        {
#line 1777
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 1777
          if (! *current_line) {
#line 1777
            goto while_break___8;
          }
#line 1777
          current_line = & (*current_line)->next;
        }
        while_break___8: /* CIL Label */ ;
        }
        {
#line 1781
        tmp___4 = malloc(sizeof(struct macro_line ));
#line 1781
        *current_line = (struct macro_line *)tmp___4;
        }
#line 1782
        if (! *current_line) {
          {
#line 1784
          printerr(1, "out of memory\n");
          }
#line 1785
          goto while_continue___0;
        }
        {
#line 1787
        (*current_line)->next = (struct macro_line *)((void *)0);
#line 1788
        (*current_line)->args = (struct macro_arg *)((void *)0);
#line 1789
        tmp___5 = strlen((char const   *)buffer);
#line 1789
        tmp___6 = malloc(tmp___5 + 1UL);
#line 1789
        (*current_line)->line = (char *)tmp___6;
        }
#line 1790
        if (! (*current_line)->line) {
          {
#line 1792
          printerr(1, "out of memory\n");
#line 1793
          free((void *)*current_line);
#line 1794
          *current_line = (struct macro_line *)((void *)0);
          }
#line 1795
          goto while_continue___0;
        }
#line 1797
        ptr = (char const   *)buffer;
#line 1798
        newptr = (*current_line)->line;
        {
#line 1799
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 1799
          if (! *ptr) {
#line 1799
            goto while_break___9;
          }
#line 1802
          last_arg = & (*current_line)->args;
#line 1803
          p = 0U;
          {
#line 1803
          while (1) {
            while_continue___10: /* CIL Label */ ;
#line 1803
            if (! (p < firstmacro->numargs)) {
#line 1803
              goto while_break___10;
            }
            {
#line 1805
            tmp___9 = strlen((char const   *)*(firstmacro->args + p));
#line 1805
            tmp___10 = strncmp(ptr, (char const   *)*(firstmacro->args + p), tmp___9);
            }
#line 1805
            if (tmp___10 == 0) {
              {
#line 1809
              tmp___7 = malloc(sizeof(struct macro_arg ));
#line 1809
              newarg = (struct macro_arg *)tmp___7;
              }
#line 1810
              if (! newarg) {
                {
#line 1812
                printerr(1, "out of memory\n");
                }
#line 1813
                goto while_break___10;
              }
              {
#line 1815
              newarg->next = (struct macro_arg *)((void *)0);
#line 1816
              *last_arg = newarg;
#line 1817
              last_arg = & newarg->next;
#line 1818
              newarg->pos = (unsigned int )(newptr - (*current_line)->line);
#line 1819
              newarg->which = p;
#line 1822
              tmp___8 = strlen((char const   *)*(firstmacro->args + p));
#line 1822
              ptr += tmp___8 - 1UL;
              }
#line 1823
              goto while_break___10;
            }
#line 1803
            p ++;
          }
          while_break___10: /* CIL Label */ ;
          }
#line 1826
          tmp___11 = newptr;
#line 1826
          newptr ++;
#line 1826
          tmp___12 = ptr;
#line 1826
          ptr ++;
#line 1826
          *tmp___11 = (char )*tmp___12;
        }
        while_break___9: /* CIL Label */ ;
        }
#line 1828
        *newptr = (char)0;
#line 1829
        if (verbose >= 7) {
          {
#line 1830
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"added line to macro (cmd = %d): %s\n",
                  cmd, (*current_line)->line);
          }
        }
#line 1832
        if (cmd == 86) {
#line 1833
          define_macro = 0;
        }
#line 1834
        goto while_continue___0;
      }
      {
#line 1839
      if (cmd == 22) {
#line 1839
        goto case_22;
      }
#line 1854
      if (cmd == 23) {
#line 1854
        goto case_23;
      }
#line 1878
      if (cmd == 24) {
#line 1878
        goto case_24;
      }
#line 1883
      if (cmd == 25) {
#line 1883
        goto case_25;
      }
#line 1892
      if (cmd == 0) {
#line 1892
        goto case_0;
      }
#line 1904
      if (cmd == 26) {
#line 1904
        goto case_26;
      }
#line 1907
      if (cmd == 63) {
#line 1907
        goto case_63;
      }
#line 1912
      if (cmd == 27) {
#line 1912
        goto case_27;
      }
#line 1916
      if (cmd == 1) {
#line 1916
        goto case_1;
      }
#line 1920
      if (cmd == 28) {
#line 1920
        goto case_28;
      }
#line 1924
      if (cmd == 2) {
#line 1924
        goto case_2;
      }
#line 1928
      if (cmd == 29) {
#line 1928
        goto case_29;
      }
#line 1931
      if (cmd == 30) {
#line 1931
        goto case_30;
      }
#line 1934
      if (cmd == 31) {
#line 1934
        goto case_31;
      }
#line 1944
      if (cmd == 64) {
#line 1944
        goto case_64;
      }
#line 1947
      if (cmd == 3) {
#line 1947
        goto case_3;
      }
#line 1951
      if (cmd == 65) {
#line 1951
        goto case_65;
      }
#line 1954
      if (cmd == 32) {
#line 1954
        goto case_32;
      }
#line 1973
      if (cmd == 66) {
#line 1973
        goto case_66;
      }
#line 1994
      if (cmd == 33) {
#line 1994
        goto case_33;
      }
#line 1997
      if (cmd == 4) {
#line 1997
        goto case_4;
      }
#line 2000
      if (cmd == 67) {
#line 2000
        goto case_67;
      }
#line 2006
      if (cmd == 68) {
#line 2006
        goto case_68;
      }
#line 2030
      if (cmd == 34) {
#line 2030
        goto case_34;
      }
#line 2040
      if (cmd == 35) {
#line 2040
        goto case_35;
      }
#line 2044
      if (cmd == 5) {
#line 2044
        goto case_5;
      }
#line 2048
      if (cmd == 36) {
#line 2048
        goto case_36;
      }
#line 2052
      if (cmd == 6) {
#line 2052
        goto case_6;
      }
#line 2056
      if (cmd == 69) {
#line 2056
        goto case_69;
      }
#line 2074
      if (cmd == 70) {
#line 2074
        goto case_70;
      }
#line 2081
      if (cmd == 71) {
#line 2081
        goto case_71;
      }
#line 2185
      if (cmd == 37) {
#line 2185
        goto case_37;
      }
#line 2189
      if (cmd == 7) {
#line 2189
        goto case_7___0;
      }
#line 2193
      if (cmd == 38) {
#line 2193
        goto case_38;
      }
#line 2197
      if (cmd == 8) {
#line 2197
        goto case_8___0;
      }
#line 2201
      if (cmd == 39) {
#line 2201
        goto case_39;
      }
#line 2205
      if (cmd == 40) {
#line 2205
        goto case_40;
      }
#line 2208
      if (cmd == 72) {
#line 2208
        goto case_72;
      }
#line 2213
      if (cmd == 9) {
#line 2213
        goto case_9___0;
      }
#line 2217
      if (cmd == 10) {
#line 2217
        goto case_10___0;
      }
#line 2221
      if (cmd == 41) {
#line 2221
        goto case_41;
      }
#line 2240
      if (cmd == 11) {
#line 2240
        goto case_11___0;
      }
#line 2244
      if (cmd == 12) {
#line 2244
        goto case_12___0;
      }
#line 2248
      if (cmd == 42) {
#line 2248
        goto case_42;
      }
#line 2253
      if (cmd == 13) {
#line 2253
        goto case_13___0;
      }
#line 2258
      if (cmd == 43) {
#line 2258
        goto case_43;
      }
#line 2267
      if (cmd == 44) {
#line 2267
        goto case_44;
      }
#line 2275
      if (cmd == 14) {
#line 2275
        goto case_14___0;
      }
#line 2279
      if (cmd == 15) {
#line 2279
        goto case_15___0;
      }
#line 2283
      if (cmd == 73) {
#line 2283
        goto case_73;
      }
#line 2289
      if (cmd == 45) {
#line 2289
        goto case_45;
      }
#line 2292
      if (cmd == 46) {
#line 2292
        goto case_46;
      }
#line 2298
      if (cmd == 16) {
#line 2298
        goto case_16___0;
      }
#line 2301
      if (cmd == 47) {
#line 2301
        goto case_47;
      }
#line 2305
      if (cmd == 74) {
#line 2305
        goto case_74;
      }
#line 2311
      if (cmd == 48) {
#line 2311
        goto case_48;
      }
#line 2314
      if (cmd == 49) {
#line 2314
        goto case_49;
      }
#line 2320
      if (cmd == 17) {
#line 2320
        goto case_17___0;
      }
#line 2323
      if (cmd == 50) {
#line 2323
        goto case_50;
      }
#line 2327
      if (cmd == 51) {
#line 2327
        goto case_51;
      }
#line 2331
      if (cmd == 52) {
#line 2331
        goto case_52;
      }
#line 2346
      if (cmd == 53) {
#line 2346
        goto case_53;
      }
#line 2349
      if (cmd == 54) {
#line 2349
        goto case_54;
      }
#line 2358
      if (cmd == 55) {
#line 2358
        goto case_55;
      }
#line 2364
      if (cmd == 57) {
#line 2364
        goto case_57;
      }
#line 2370
      if (cmd == 58) {
#line 2370
        goto case_58;
      }
#line 2376
      if (cmd == 59) {
#line 2376
        goto case_59;
      }
#line 2382
      if (cmd == 60) {
#line 2382
        goto case_60;
      }
#line 2397
      if (cmd == 61) {
#line 2397
        goto case_61;
      }
#line 2405
      if (cmd == 78) {
#line 2405
        goto case_78;
      }
#line 2405
      if (cmd == 21) {
#line 2405
        goto case_78;
      }
#line 2405
      if (cmd == 75) {
#line 2405
        goto case_78;
      }
#line 2405
      if (cmd == 18) {
#line 2405
        goto case_78;
      }
#line 2449
      if (cmd == 76) {
#line 2449
        goto case_76;
      }
#line 2449
      if (cmd == 19) {
#line 2449
        goto case_76;
      }
#line 2467
      if (cmd == 77) {
#line 2467
        goto case_77;
      }
#line 2467
      if (cmd == 20) {
#line 2467
        goto case_77;
      }
#line 2495
      if (cmd == 84) {
#line 2495
        goto case_84;
      }
#line 2498
      if (cmd == 62) {
#line 2498
        goto case_62;
      }
#line 2501
      if (cmd == 79) {
#line 2501
        goto case_79;
      }
#line 2551
      if (cmd == 80) {
#line 2551
        goto case_80;
      }
#line 2583
      if (cmd == 81) {
#line 2583
        goto case_81___0;
      }
#line 2589
      if (cmd == 82) {
#line 2589
        goto case_82___0;
      }
#line 2598
      if (cmd == 83) {
#line 2598
        goto case_83___0;
      }
#line 2609
      if (cmd == 85) {
#line 2609
        goto case_85;
      }
#line 2658
      if (cmd == 86) {
#line 2658
        goto case_86;
      }
#line 2662
      if (cmd == 87) {
#line 2662
        goto case_87;
      }
#line 2676
      goto switch_default___0;
      case_22: /* CIL Label */ 
      {
#line 1840
      r = rd_a_hl___0(& ptr);
      }
#line 1840
      if (! r) {
#line 1841
        goto switch_break___0;
      }
#line 1842
      if (r == 2) {
        {
#line 1844
        r = rd_rr____0(& ptr);
        }
#line 1844
        if (! r) {
#line 1845
          goto switch_break___0;
        }
        {
#line 1846
        wrtb___0(237);
#line 1847
        r --;
#line 1847
        wrtb___0(74 + 16 * r);
        }
#line 1848
        goto switch_break___0;
      }
      {
#line 1850
      r = rd_r___0(& ptr);
      }
#line 1850
      if (! r) {
#line 1851
        goto switch_break___0;
      }
      {
#line 1852
      r --;
#line 1852
      wrtb___0(136 + r);
      }
#line 1853
      goto switch_break___0;
      case_23: /* CIL Label */ 
      {
#line 1855
      r = rd_r_add___0(& ptr);
      }
#line 1855
      if (! r) {
#line 1856
        goto switch_break___0;
      }
#line 1857
      if (r == 15) {
        {
#line 1859
        r = rd_rrxx___0(& ptr);
        }
#line 1859
        if (! r) {
#line 1860
          goto switch_break___0;
        }
        {
#line 1861
        r --;
#line 1861
        wrtb___0(9 + 16 * r);
        }
#line 1862
        goto switch_break___0;
      }
      {
#line 1864
      tmp___13 = has_argument___0(& ptr);
      }
#line 1864
      if (tmp___13) {
#line 1866
        if (r != 8) {
          {
#line 1868
          printerr(1, "parse error before: %s\n", ptr);
          }
#line 1869
          goto switch_break___0;
        }
        {
#line 1871
        r = rd_r___0(& ptr);
        }
#line 1871
        if (! r) {
#line 1872
          goto switch_break___0;
        }
        {
#line 1873
        r --;
#line 1873
        wrtb___0(128 + r);
        }
#line 1874
        goto switch_break___0;
      }
      {
#line 1876
      r --;
#line 1876
      wrtb___0(128 + r);
      }
#line 1877
      goto switch_break___0;
      case_24: /* CIL Label */ 
      {
#line 1879
      r = rd_r___0(& ptr);
      }
#line 1879
      if (! r) {
#line 1880
        goto switch_break___0;
      }
      {
#line 1881
      r --;
#line 1881
      wrtb___0(160 + r);
      }
#line 1882
      goto switch_break___0;
      case_25: /* CIL Label */ 
      {
#line 1884
      tmp___14 = rd_0_7___0(& ptr);
      }
#line 1884
      if (! tmp___14) {
#line 1885
        goto switch_break___0;
      }
      {
#line 1886
      rd_comma___0(& ptr);
#line 1887
      r = rd_r____0(& ptr);
      }
#line 1887
      if (! r) {
#line 1888
        goto switch_break___0;
      }
      {
#line 1889
      wrtb___0(203);
#line 1890
      wrtb___0(64 + (r - 1));
      }
#line 1891
      goto switch_break___0;
      case_0: /* CIL Label */ 
      {
#line 1893
      r = rd_cc___0(& ptr);
      }
#line 1893
      if (r) {
        {
#line 1899
        r --;
#line 1899
        wrtb___0(196 + 8 * r);
#line 1900
        rd_comma___0(& ptr);
        }
      } else {
        {
#line 1895
        wrtb___0(205);
        }
      }
      {
#line 1902
      rd_wrt_addr___0(& ptr, (char )'\000');
      }
#line 1903
      goto switch_break___0;
      case_26: /* CIL Label */ 
      {
#line 1905
      wrtb___0(63);
      }
#line 1906
      goto switch_break___0;
      case_63: /* CIL Label */ 
      {
#line 1908
      r = rd_r___0(& ptr);
      }
#line 1908
      if (! r) {
#line 1909
        goto switch_break___0;
      }
      {
#line 1910
      r --;
#line 1910
      wrtb___0(184 + r);
      }
#line 1911
      goto switch_break___0;
      case_27: /* CIL Label */ 
      {
#line 1913
      wrtb___0(237);
#line 1914
      wrtb___0(169);
      }
#line 1915
      goto switch_break___0;
      case_1: /* CIL Label */ 
      {
#line 1917
      wrtb___0(237);
#line 1918
      wrtb___0(185);
      }
#line 1919
      goto switch_break___0;
      case_28: /* CIL Label */ 
      {
#line 1921
      wrtb___0(237);
#line 1922
      wrtb___0(161);
      }
#line 1923
      goto switch_break___0;
      case_2: /* CIL Label */ 
      {
#line 1925
      wrtb___0(237);
#line 1926
      wrtb___0(177);
      }
#line 1927
      goto switch_break___0;
      case_29: /* CIL Label */ 
      {
#line 1929
      wrtb___0(47);
      }
#line 1930
      goto switch_break___0;
      case_30: /* CIL Label */ 
      {
#line 1932
      wrtb___0(39);
      }
#line 1933
      goto switch_break___0;
      case_31: /* CIL Label */ 
      {
#line 1935
      r = rd_r_rr___0(& ptr);
      }
#line 1935
      if (! r) {
#line 1936
        goto switch_break___0;
      }
#line 1937
      if (r < 0) {
        {
#line 1939
        r ++;
#line 1939
        wrtb___0(5 - 8 * r);
        }
#line 1940
        goto switch_break___0;
      }
      {
#line 1942
      r --;
#line 1942
      wrtb___0(11 + 16 * r);
      }
#line 1943
      goto switch_break___0;
      case_64: /* CIL Label */ 
      {
#line 1945
      wrtb___0(243);
      }
#line 1946
      goto switch_break___0;
      case_3: /* CIL Label */ 
      {
#line 1948
      wrtb___0(16);
#line 1949
      rd_wrt_jr___0(& ptr, (char )'\000');
      }
#line 1950
      goto switch_break___0;
      case_65: /* CIL Label */ 
      {
#line 1952
      wrtb___0(251);
      }
#line 1953
      goto switch_break___0;
      case_32: /* CIL Label */ 
#line 1955
      if (! lastlabel) {
        {
#line 1957
        printerr(1, "EQU without label\n");
        }
#line 1958
        goto switch_break___0;
      }
      {
#line 1960
      new_reference___0(ptr, 6, (char)0, 0);
      }
#line 1961
      if (verbose >= 4) {
#line 1963
        if (lastlabel->valid) {
          {
#line 1964
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Assigned value %d to label %s.\n",
                  lastlabel->value, lastlabel->name);
          }
        } else {
          {
#line 1967
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Scheduled label %s for later computation.\n",
                  lastlabel->name);
          }
        }
      }
#line 1971
      ptr = "";
#line 1972
      goto switch_break___0;
      case_66: /* CIL Label */ 
      {
#line 1974
      r = rd_ex1___0(& ptr);
      }
#line 1974
      if (! r) {
#line 1975
        goto switch_break___0;
      }
      {
#line 1978
      if (r == 2) {
#line 1978
        goto case_2___0;
      }
#line 1983
      if (r == 3) {
#line 1983
        goto case_3___0;
      }
#line 1988
      goto switch_default;
      case_2___0: /* CIL Label */ 
      {
#line 1979
      tmp___15 = rd_hl___0(& ptr);
      }
#line 1979
      if (! tmp___15) {
#line 1980
        goto switch_break___1;
      }
      {
#line 1981
      wrtb___0(235);
      }
#line 1982
      goto switch_break___1;
      case_3___0: /* CIL Label */ 
      {
#line 1984
      tmp___16 = rd_af____0(& ptr);
      }
#line 1984
      if (! tmp___16) {
#line 1985
        goto switch_break___1;
      }
      {
#line 1986
      wrtb___0(8);
      }
#line 1987
      goto switch_break___1;
      switch_default: /* CIL Label */ 
      {
#line 1989
      tmp___17 = rd_hlx___0(& ptr);
      }
#line 1989
      if (! tmp___17) {
#line 1990
        goto switch_break___1;
      }
      {
#line 1991
      wrtb___0(227);
      }
      switch_break___1: /* CIL Label */ ;
      }
#line 1993
      goto switch_break___0;
      case_33: /* CIL Label */ 
      {
#line 1995
      wrtb___0(217);
      }
#line 1996
      goto switch_break___0;
      case_4: /* CIL Label */ 
      {
#line 1998
      wrtb___0(118);
      }
#line 1999
      goto switch_break___0;
      case_67: /* CIL Label */ 
      {
#line 2001
      r = rd_0_2___0(& ptr);
      }
#line 2001
      if (! r) {
#line 2002
        goto switch_break___0;
      }
      {
#line 2003
      wrtb___0(237);
#line 2004
      r --;
#line 2004
      wrtb___0(70 + 8 * r);
      }
#line 2005
      goto switch_break___0;
      case_68: /* CIL Label */ 
      {
#line 2007
      r = rd_in___0(& ptr);
      }
#line 2007
      if (! r) {
#line 2008
        goto switch_break___0;
      }
#line 2009
      if (r == 8) {
        {
#line 2012
        r = rd_nnc___0(& ptr);
        }
#line 2012
        if (! r) {
#line 2013
          goto switch_break___0;
        }
#line 2014
        if (r == 1) {
          {
#line 2016
          wrtb___0(237);
#line 2017
          wrtb___0(120);
          }
#line 2018
          goto switch_break___0;
        }
        {
#line 2020
        tmp___18 = readbyte;
#line 2021
        wrtb___0(219);
#line 2022
        new_reference___0(tmp___18, 4, (char )')', 1);
        }
#line 2023
        goto switch_break___0;
      }
      {
#line 2025
      tmp___19 = rd_c___0(& ptr);
      }
#line 2025
      if (! tmp___19) {
#line 2026
        goto switch_break___0;
      }
      {
#line 2027
      wrtb___0(237);
#line 2028
      r --;
#line 2028
      wrtb___0(64 + 8 * r);
      }
#line 2029
      goto switch_break___0;
      case_34: /* CIL Label */ 
      {
#line 2031
      r = rd_r_rr___0(& ptr);
      }
#line 2031
      if (! r) {
#line 2032
        goto switch_break___0;
      }
#line 2033
      if (r < 0) {
        {
#line 2035
        r ++;
#line 2035
        wrtb___0(4 - 8 * r);
        }
#line 2036
        goto switch_break___0;
      }
      {
#line 2038
      r --;
#line 2038
      wrtb___0(3 + 16 * r);
      }
#line 2039
      goto switch_break___0;
      case_35: /* CIL Label */ 
      {
#line 2041
      wrtb___0(237);
#line 2042
      wrtb___0(170);
      }
#line 2043
      goto switch_break___0;
      case_5: /* CIL Label */ 
      {
#line 2045
      wrtb___0(237);
#line 2046
      wrtb___0(186);
      }
#line 2047
      goto switch_break___0;
      case_36: /* CIL Label */ 
      {
#line 2049
      wrtb___0(237);
#line 2050
      wrtb___0(162);
      }
#line 2051
      goto switch_break___0;
      case_6: /* CIL Label */ 
      {
#line 2053
      wrtb___0(237);
#line 2054
      wrtb___0(178);
      }
#line 2055
      goto switch_break___0;
      case_69: /* CIL Label */ 
      {
#line 2057
      r = rd_jp___0(& ptr);
      }
#line 2058
      if (r < 0) {
        {
#line 2060
        wrtb___0(233);
        }
#line 2061
        goto switch_break___0;
      }
#line 2063
      if (r == 0) {
        {
#line 2065
        wrtb___0(195);
        }
      } else {
        {
#line 2069
        r --;
#line 2069
        wrtb___0(194 + 8 * r);
#line 2070
        rd_comma___0(& ptr);
        }
      }
      {
#line 2072
      rd_wrt_addr___0(& ptr, (char )'\000');
      }
#line 2073
      goto switch_break___0;
      case_70: /* CIL Label */ 
      {
#line 2075
      r = rd_jr___0(& ptr);
      }
#line 2076
      if (r) {
        {
#line 2077
        rd_comma___0(& ptr);
        }
      }
      {
#line 2078
      wrtb___0(24 + 8 * r);
#line 2079
      rd_wrt_jr___0(& ptr, (char )'\000');
      }
#line 2080
      goto switch_break___0;
      case_71: /* CIL Label */ 
      {
#line 2082
      r = rd_ld___0(& ptr);
      }
#line 2082
      if (! r) {
#line 2083
        goto switch_break___0;
      }
      {
#line 2087
      if (r == 18) {
#line 2087
        goto case_18;
      }
#line 2087
      if (r == 17) {
#line 2087
        goto case_18;
      }
#line 2092
      if (r == 13) {
#line 2092
        goto case_13;
      }
#line 2096
      if (r == 21) {
#line 2096
        goto case_21;
      }
#line 2109
      if (r == 14) {
#line 2109
        goto case_14;
      }
#line 2136
      if (r == 12) {
#line 2136
        goto case_12;
      }
#line 2136
      if (r == 11) {
#line 2136
        goto case_12;
      }
#line 2136
      if (r == 10) {
#line 2136
        goto case_12;
      }
#line 2136
      if (r == 9) {
#line 2136
        goto case_12;
      }
#line 2136
      if (r == 8) {
#line 2136
        goto case_12;
      }
#line 2136
      if (r == 7) {
#line 2136
        goto case_12;
      }
#line 2142
      if (r == 2) {
#line 2142
        goto case_2___1;
      }
#line 2142
      if (r == 1) {
#line 2142
        goto case_2___1;
      }
#line 2154
      if (r == 3) {
#line 2154
        goto case_3___1;
      }
#line 2160
      if (r == 16) {
#line 2160
        goto case_16;
      }
#line 2160
      if (r == 15) {
#line 2160
        goto case_16;
      }
#line 2166
      if (r == 4) {
#line 2166
        goto case_4___0;
      }
#line 2084
      goto switch_break___2;
      case_18: /* CIL Label */ 
      case_17: /* CIL Label */ 
      {
#line 2088
      tmp___20 = rd_a___0(& ptr);
      }
#line 2088
      if (! tmp___20) {
#line 2089
        goto switch_break___2;
      }
      {
#line 2090
      wrtb___0(2 + 16 * (r == 18));
      }
#line 2091
      goto switch_break___2;
      case_13: /* CIL Label */ 
      {
#line 2093
      r = rd_ld_hl___0(& ptr);
#line 2094
      r --;
#line 2094
      wrtb___0(112 + r);
      }
#line 2095
      goto switch_break___2;
      case_21: /* CIL Label */ 
      {
#line 2097
      r = rd_ld_nn___0(& ptr);
      }
#line 2097
      if (! r) {
#line 2098
        goto switch_break___2;
      }
#line 2099
      if (r == 6) {
        {
#line 2101
        wrtb___0(34 + 16 * (r == 6));
#line 2102
        write_word___0();
        }
#line 2103
        goto switch_break___2;
      } else
#line 2099
      if (r == 5) {
        {
#line 2101
        wrtb___0(34 + 16 * (r == 6));
#line 2102
        write_word___0();
        }
#line 2103
        goto switch_break___2;
      }
      {
#line 2105
      wrtb___0(237);
#line 2106
      r --;
#line 2106
      wrtb___0(67 + 16 * r);
#line 2107
      write_word___0();
      }
#line 2108
      goto switch_break___2;
      case_14: /* CIL Label */ 
      {
#line 2110
      r = rd_lda___0(& ptr);
      }
#line 2110
      if (! r) {
#line 2111
        goto switch_break___2;
      }
#line 2112
      if (r == 11) {
        {
#line 2114
        wrtb___0(58);
#line 2115
        write_word___0();
        }
#line 2116
        goto switch_break___2;
      }
#line 2118
      if (r == 9) {
        {
#line 2120
        wrtb___0(237);
#line 2121
        wrtb___0(87 + 8 * (r == 10));
        }
#line 2122
        goto switch_break___2;
      } else
#line 2118
      if (r == 10) {
        {
#line 2120
        wrtb___0(237);
#line 2121
        wrtb___0(87 + 8 * (r == 10));
        }
#line 2122
        goto switch_break___2;
      }
#line 2124
      if (r < 0) {
        {
#line 2126
        r ++;
#line 2126
        wrtb___0(10 - 16 * r);
        }
#line 2127
        goto switch_break___2;
      }
      {
#line 2129
      r --;
#line 2129
      wrtb___0(120 + r);
      }
#line 2130
      goto switch_break___2;
      case_12: /* CIL Label */ 
      case_11: /* CIL Label */ 
      case_10: /* CIL Label */ 
      case_9: /* CIL Label */ 
      case_8: /* CIL Label */ 
      case_7: /* CIL Label */ 
      {
#line 2137
      s = rd_ldbcdehla___0(& ptr);
      }
#line 2137
      if (! s) {
#line 2138
        goto switch_break___2;
      }
      {
#line 2139
      wrtb___0((64 + 8 * (r - 7)) + (s - 1));
      }
#line 2140
      goto switch_break___2;
      case_2___1: /* CIL Label */ 
      case_1___0: /* CIL Label */ 
      {
#line 2143
      s = rd_nn_nn___0(& ptr);
      }
#line 2144
      if (s == 1) {
        {
#line 2146
        wrtb___0(237);
#line 2147
        wrtb___0(75 + 16 * (r == 2));
#line 2148
        write_word___0();
        }
#line 2149
        goto switch_break___2;
      }
      {
#line 2151
      wrtb___0(1 + (r == 2) * 16);
#line 2152
      write_word___0();
      }
#line 2153
      goto switch_break___2;
      case_3___1: /* CIL Label */ 
      {
#line 2155
      r = rd_nn_nn___0(& ptr);
#line 2156
      wrtb___0(33 + (r == 1) * 9);
#line 2157
      write_word___0();
      }
#line 2158
      goto switch_break___2;
      case_16: /* CIL Label */ 
      case_15: /* CIL Label */ 
      {
#line 2161
      tmp___21 = rd_a___0(& ptr);
      }
#line 2161
      if (! tmp___21) {
#line 2162
        goto switch_break___2;
      }
      {
#line 2163
      wrtb___0(237);
#line 2164
      wrtb___0(71 + 8 * (r == 16));
      }
#line 2165
      goto switch_break___2;
      case_4___0: /* CIL Label */ 
      {
#line 2167
      r = rd_sp___0(& ptr);
      }
#line 2168
      if (r == 1) {
        {
#line 2170
        wrtb___0(249);
        }
#line 2171
        goto switch_break___2;
      }
#line 2173
      if (r == 0) {
        {
#line 2175
        wrtb___0(49);
#line 2176
        write_word___0();
        }
#line 2177
        goto switch_break___2;
      }
      {
#line 2179
      wrtb___0(237);
#line 2180
      wrtb___0(123);
#line 2181
      write_word___0();
      }
#line 2182
      goto switch_break___2;
      switch_break___2: /* CIL Label */ ;
      }
#line 2184
      goto switch_break___0;
      case_37: /* CIL Label */ 
      {
#line 2186
      wrtb___0(237);
#line 2187
      wrtb___0(168);
      }
#line 2188
      goto switch_break___0;
      case_7___0: /* CIL Label */ 
      {
#line 2190
      wrtb___0(237);
#line 2191
      wrtb___0(184);
      }
#line 2192
      goto switch_break___0;
      case_38: /* CIL Label */ 
      {
#line 2194
      wrtb___0(237);
#line 2195
      wrtb___0(160);
      }
#line 2196
      goto switch_break___0;
      case_8___0: /* CIL Label */ 
      {
#line 2198
      wrtb___0(237);
#line 2199
      wrtb___0(176);
      }
#line 2200
      goto switch_break___0;
      case_39: /* CIL Label */ 
      {
#line 2202
      wrtb___0(237);
#line 2203
      wrtb___0(68);
      }
#line 2204
      goto switch_break___0;
      case_40: /* CIL Label */ 
      {
#line 2206
      wrtb___0(0);
      }
#line 2207
      goto switch_break___0;
      case_72: /* CIL Label */ 
      {
#line 2209
      r = rd_r___0(& ptr);
      }
#line 2209
      if (! r) {
#line 2210
        goto switch_break___0;
      }
      {
#line 2211
      r --;
#line 2211
      wrtb___0(176 + r);
      }
#line 2212
      goto switch_break___0;
      case_9___0: /* CIL Label */ 
      {
#line 2214
      wrtb___0(237);
#line 2215
      wrtb___0(187);
      }
#line 2216
      goto switch_break___0;
      case_10___0: /* CIL Label */ 
      {
#line 2218
      wrtb___0(237);
#line 2219
      wrtb___0(179);
      }
#line 2220
      goto switch_break___0;
      case_41: /* CIL Label */ 
      {
#line 2222
      r = rd_nnc___0(& ptr);
      }
#line 2222
      if (! r) {
#line 2223
        goto switch_break___0;
      }
#line 2224
      if (r == 1) {
        {
#line 2226
        r = rd_out___0(& ptr);
        }
#line 2226
        if (! r) {
#line 2227
          goto switch_break___0;
        }
        {
#line 2228
        wrtb___0(237);
#line 2229
        r --;
#line 2229
        wrtb___0(65 + 8 * r);
        }
#line 2230
        goto switch_break___0;
      }
      {
#line 2232
      tmp___22 = rd_a___0(& ptr);
      }
#line 2232
      if (! tmp___22) {
#line 2233
        goto switch_break___0;
      }
      {
#line 2235
      tmp___23 = readbyte;
#line 2236
      wrtb___0(211);
#line 2237
      new_reference___0(tmp___23, 4, (char )')', 1);
      }
#line 2239
      goto switch_break___0;
      case_11___0: /* CIL Label */ 
      {
#line 2241
      wrtb___0(237);
#line 2242
      wrtb___0(171);
      }
#line 2243
      goto switch_break___0;
      case_12___0: /* CIL Label */ 
      {
#line 2245
      wrtb___0(237);
#line 2246
      wrtb___0(163);
      }
#line 2247
      goto switch_break___0;
      case_42: /* CIL Label */ 
      {
#line 2249
      r = rd_stack___0(& ptr);
      }
#line 2249
      if (! r) {
#line 2250
        goto switch_break___0;
      }
      {
#line 2251
      r --;
#line 2251
      wrtb___0(193 + 16 * r);
      }
#line 2252
      goto switch_break___0;
      case_13___0: /* CIL Label */ 
      {
#line 2254
      r = rd_stack___0(& ptr);
      }
#line 2254
      if (! r) {
#line 2255
        goto switch_break___0;
      }
      {
#line 2256
      r --;
#line 2256
      wrtb___0(197 + 16 * r);
      }
#line 2257
      goto switch_break___0;
      case_43: /* CIL Label */ 
      {
#line 2259
      tmp___24 = rd_0_7___0(& ptr);
      }
#line 2259
      if (! tmp___24) {
#line 2260
        goto switch_break___0;
      }
      {
#line 2261
      rd_comma___0(& ptr);
#line 2262
      r = rd_r____0(& ptr);
      }
#line 2262
      if (! r) {
#line 2263
        goto switch_break___0;
      }
      {
#line 2264
      wrtb___0(203);
#line 2265
      r --;
#line 2265
      wrtb___0(128 + r);
      }
#line 2266
      goto switch_break___0;
      case_44: /* CIL Label */ 
      {
#line 2268
      r = rd_cc___0(& ptr);
      }
#line 2268
      if (! r) {
        {
#line 2270
        wrtb___0(201);
        }
#line 2271
        goto switch_break___0;
      }
      {
#line 2273
      r --;
#line 2273
      wrtb___0(192 + 8 * r);
      }
#line 2274
      goto switch_break___0;
      case_14___0: /* CIL Label */ 
      {
#line 2276
      wrtb___0(237);
#line 2277
      wrtb___0(77);
      }
#line 2278
      goto switch_break___0;
      case_15___0: /* CIL Label */ 
      {
#line 2280
      wrtb___0(237);
#line 2281
      wrtb___0(69);
      }
#line 2282
      goto switch_break___0;
      case_73: /* CIL Label */ 
      {
#line 2284
      r = rd_r____0(& ptr);
      }
#line 2284
      if (! r) {
#line 2285
        goto switch_break___0;
      }
      {
#line 2286
      wrtb___0(203);
#line 2287
      r --;
#line 2287
      wrtb___0(16 + r);
      }
#line 2288
      goto switch_break___0;
      case_45: /* CIL Label */ 
      {
#line 2290
      wrtb___0(23);
      }
#line 2291
      goto switch_break___0;
      case_46: /* CIL Label */ 
      {
#line 2293
      r = rd_r____0(& ptr);
      }
#line 2293
      if (! r) {
#line 2294
        goto switch_break___0;
      }
      {
#line 2295
      wrtb___0(203);
#line 2296
      r --;
#line 2296
      wrtb___0(r);
      }
#line 2297
      goto switch_break___0;
      case_16___0: /* CIL Label */ 
      {
#line 2299
      wrtb___0(7);
      }
#line 2300
      goto switch_break___0;
      case_47: /* CIL Label */ 
      {
#line 2302
      wrtb___0(237);
#line 2303
      wrtb___0(111);
      }
#line 2304
      goto switch_break___0;
      case_74: /* CIL Label */ 
      {
#line 2306
      r = rd_r____0(& ptr);
      }
#line 2306
      if (! r) {
#line 2307
        goto switch_break___0;
      }
      {
#line 2308
      wrtb___0(203);
#line 2309
      r --;
#line 2309
      wrtb___0(24 + r);
      }
#line 2310
      goto switch_break___0;
      case_48: /* CIL Label */ 
      {
#line 2312
      wrtb___0(31);
      }
#line 2313
      goto switch_break___0;
      case_49: /* CIL Label */ 
      {
#line 2315
      r = rd_r____0(& ptr);
      }
#line 2315
      if (! r) {
#line 2316
        goto switch_break___0;
      }
      {
#line 2317
      wrtb___0(203);
#line 2318
      r --;
#line 2318
      wrtb___0(8 + r);
      }
#line 2319
      goto switch_break___0;
      case_17___0: /* CIL Label */ 
      {
#line 2321
      wrtb___0(15);
      }
#line 2322
      goto switch_break___0;
      case_50: /* CIL Label */ 
      {
#line 2324
      wrtb___0(237);
#line 2325
      wrtb___0(103);
      }
#line 2326
      goto switch_break___0;
      case_51: /* CIL Label */ 
      {
#line 2328
      new_reference___0(ptr, 2, (char )'\000', 1);
#line 2329
      ptr = "";
      }
#line 2330
      goto switch_break___0;
      case_52: /* CIL Label */ 
      {
#line 2332
      r = rd_a_hl___0(& ptr);
      }
#line 2332
      if (! r) {
#line 2333
        goto switch_break___0;
      }
#line 2334
      if (r == 2) {
        {
#line 2336
        r = rd_rr____0(& ptr);
        }
#line 2336
        if (! r) {
#line 2337
          goto switch_break___0;
        }
        {
#line 2338
        wrtb___0(237);
#line 2339
        r --;
#line 2339
        wrtb___0(66 + 16 * r);
        }
#line 2340
        goto switch_break___0;
      }
      {
#line 2342
      r = rd_r___0(& ptr);
      }
#line 2342
      if (! r) {
#line 2343
        goto switch_break___0;
      }
      {
#line 2344
      r --;
#line 2344
      wrtb___0(152 + r);
      }
#line 2345
      goto switch_break___0;
      case_53: /* CIL Label */ 
      {
#line 2347
      wrtb___0(55);
      }
#line 2348
      goto switch_break___0;
      case_54: /* CIL Label */ 
      {
#line 2350
      tmp___25 = rd_0_7___0(& ptr);
      }
#line 2350
      if (! tmp___25) {
#line 2351
        goto switch_break___0;
      }
      {
#line 2352
      rd_comma___0(& ptr);
#line 2353
      r = rd_r____0(& ptr);
      }
#line 2353
      if (! r) {
#line 2354
        goto switch_break___0;
      }
      {
#line 2355
      wrtb___0(203);
#line 2356
      r --;
#line 2356
      wrtb___0(192 + r);
      }
#line 2357
      goto switch_break___0;
      case_55: /* CIL Label */ 
      {
#line 2359
      r = rd_r____0(& ptr);
      }
#line 2359
      if (! r) {
#line 2360
        goto switch_break___0;
      }
      {
#line 2361
      wrtb___0(203);
#line 2362
      r --;
#line 2362
      wrtb___0(32 + r);
      }
#line 2363
      goto switch_break___0;
      case_57: /* CIL Label */ 
      {
#line 2365
      r = rd_r____0(& ptr);
      }
#line 2365
      if (! r) {
#line 2366
        goto switch_break___0;
      }
      {
#line 2367
      wrtb___0(203);
#line 2368
      r --;
#line 2368
      wrtb___0(48 + r);
      }
#line 2369
      goto switch_break___0;
      case_58: /* CIL Label */ 
      {
#line 2371
      r = rd_r____0(& ptr);
      }
#line 2371
      if (! r) {
#line 2372
        goto switch_break___0;
      }
      {
#line 2373
      wrtb___0(203);
#line 2374
      r --;
#line 2374
      wrtb___0(40 + r);
      }
#line 2375
      goto switch_break___0;
      case_59: /* CIL Label */ 
      {
#line 2377
      r = rd_r____0(& ptr);
      }
#line 2377
      if (! r) {
#line 2378
        goto switch_break___0;
      }
      {
#line 2379
      wrtb___0(203);
#line 2380
      r --;
#line 2380
      wrtb___0(56 + r);
      }
#line 2381
      goto switch_break___0;
      case_60: /* CIL Label */ 
      {
#line 2383
      r = rd_r___0(& ptr);
      }
#line 2383
      if (! r) {
#line 2384
        goto switch_break___0;
      }
      {
#line 2385
      tmp___26 = has_argument___0(& ptr);
      }
#line 2385
      if (tmp___26) {
#line 2387
        if (r != 8) {
          {
#line 2389
          printerr(1, "parse error before: %s\n", ptr);
          }
#line 2390
          goto switch_break___0;
        }
        {
#line 2392
        r = rd_r___0(& ptr);
        }
#line 2392
        if (! r) {
#line 2393
          goto switch_break___0;
        }
      }
      {
#line 2395
      r --;
#line 2395
      wrtb___0(144 + r);
      }
#line 2396
      goto switch_break___0;
      case_61: /* CIL Label */ 
      {
#line 2398
      r = rd_r___0(& ptr);
      }
#line 2398
      if (! r) {
#line 2399
        goto switch_break___0;
      }
      {
#line 2400
      r --;
#line 2400
      wrtb___0(168 + r);
      }
#line 2401
      goto switch_break___0;
      case_78: /* CIL Label */ 
      case_21___0: /* CIL Label */ 
      case_75: /* CIL Label */ 
      case_18___0: /* CIL Label */ 
      {
#line 2406
      ptr = delspc(ptr);
      }
      {
#line 2407
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 2409
        if ((int const   )*ptr == 34) {
#line 2409
          tmp___27 = 1;
        } else
#line 2409
        if ((int const   )*ptr == 39) {
#line 2409
          tmp___27 = 1;
        } else {
#line 2409
          tmp___27 = 0;
        }
#line 2409
        have_quote = tmp___27;
#line 2410
        if (have_quote) {
#line 2413
          quote = (int )*ptr;
#line 2414
          if (listfile) {
            {
#line 2416
            fprintf((FILE */* __restrict  */)listfile, (char const   */* __restrict  */)" ..");
#line 2417
            listdepth += 3;
            }
          }
#line 2419
          ptr ++;
          {
#line 2420
          while (1) {
            while_continue___12: /* CIL Label */ ;
#line 2420
            if (! ((int const   )*ptr != (int const   )quote)) {
#line 2420
              goto while_break___12;
            }
            {
#line 2422
            tmp___28 = rd_character(& ptr, (int *)((void *)0), 1);
#line 2422
            write_one_byte___0(tmp___28, 0);
            }
#line 2423
            if ((int const   )*ptr == 0) {
              {
#line 2425
              printerr(1, "end of line in quoted string\n");
              }
#line 2426
              goto while_break___12;
            }
          }
          while_break___12: /* CIL Label */ ;
          }
#line 2429
          ptr ++;
        } else {
          {
#line 2434
          new_reference___0(ptr, 4, (char )',', 1);
#line 2435
          skipword___0(& ptr, (char )',');
          }
        }
        {
#line 2437
        ptr = delspc(ptr);
        }
#line 2438
        if ((int const   )*ptr == 44) {
#line 2440
          ptr ++;
#line 2441
          goto while_continue___11;
        }
#line 2443
        if ((int const   )*ptr != 0) {
          {
#line 2444
          printerr(1, "junk in byte definition: %s\n", ptr);
          }
        }
#line 2445
        goto while_break___11;
      }
      while_break___11: /* CIL Label */ ;
      }
#line 2447
      goto switch_break___0;
      case_76: /* CIL Label */ 
      case_19: /* CIL Label */ 
      {
#line 2450
      r = rd_word___0(& ptr, (char )',');
      }
#line 2450
      if (! r) {
        {
#line 2452
        printerr(1, "No data for word definition\n");
        }
#line 2453
        goto switch_break___0;
      }
      {
#line 2455
      while (1) {
        while_continue___13: /* CIL Label */ ;
        {
#line 2457
        new_reference___0(readword, 3, (char )',', 1);
#line 2458
        ptr = delspc(ptr);
        }
#line 2459
        if ((int const   )*ptr != 44) {
#line 2460
          goto while_break___13;
        }
        {
#line 2461
        ptr ++;
#line 2462
        r = rd_word___0(& ptr, (char )',');
        }
#line 2462
        if (! r) {
          {
#line 2463
          printerr(1, "Missing expression in defw\n");
          }
        }
      }
      while_break___13: /* CIL Label */ ;
      }
#line 2465
      goto switch_break___0;
      case_77: /* CIL Label */ 
      case_20: /* CIL Label */ 
      {
#line 2468
      r = rd_expr(& ptr, (char )',', (int *)((void *)0), sp, 1);
      }
#line 2469
      if (r < 0) {
        {
#line 2471
        printerr(1, "ds should have its first argument >=0 (not -0x%x)\n", - r);
        }
#line 2473
        goto switch_break___0;
      }
      {
#line 2475
      ptr = delspc(ptr);
      }
#line 2476
      if (*ptr) {
        {
#line 2478
        rd_comma___0(& ptr);
#line 2479
        readbyte = (char const   *)0;
#line 2480
        rd_byte___0(& ptr, (char )'\000');
#line 2481
        writebyte = 0;
#line 2482
        new_reference___0(readbyte, 1, (char )'\000', r);
        }
#line 2483
        goto switch_break___0;
      }
#line 2485
      if (havelist) {
        {
#line 2487
        fprintf((FILE */* __restrict  */)listfile, (char const   */* __restrict  */)" 00...");
#line 2488
        listdepth += 6;
        }
      }
#line 2490
      i___0 = 0;
      {
#line 2490
      while (1) {
        while_continue___14: /* CIL Label */ ;
#line 2490
        if (! (i___0 < r)) {
#line 2490
          goto while_break___14;
        }
        {
#line 2492
        write_one_byte___0(0, 0);
#line 2490
        i___0 ++;
        }
      }
      while_break___14: /* CIL Label */ ;
      }
#line 2494
      goto switch_break___0;
      case_84: /* CIL Label */ 
#line 2496
      file_ended = 1;
#line 2497
      goto switch_break___0;
      case_62: /* CIL Label */ 
      {
#line 2499
      tmp___29 = rd_expr(& ptr, (char )'\000', (int *)((void *)0), sp, 1);
#line 2499
      addr = tmp___29 & 65535;
      }
#line 2500
      goto switch_break___0;
      case_79: /* CIL Label */ 
#line 2502
      if (sp + 1 >= 200) {
        {
#line 2504
        printerr(1, "stack overflow (circular include?)");
        }
#line 2505
        if (verbose >= 5) {
          {
#line 2508
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Stack dump:\nframe  line file\n");
#line 2509
          x = 0;
          }
          {
#line 2509
          while (1) {
            while_continue___15: /* CIL Label */ ;
#line 2509
            if (! (x < 200)) {
#line 2509
              goto while_break___15;
            }
            {
#line 2510
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%5d %5d %s\n",
                    x, stack[x].line, stack[x].name);
#line 2509
            x ++;
            }
          }
          while_break___15: /* CIL Label */ ;
          }
        }
#line 2513
        goto switch_break___0;
      }
      {
#line 2517
      tmp___30 = get_include_name___0(& ptr);
#line 2517
      nm = tmp___30;
      }
#line 2518
      if (! nm) {
#line 2519
        goto switch_break___0;
      }
      {
#line 2520
      tmp___31 = strlen((char const   *)nm);
#line 2520
      tmp___32 = malloc(sizeof(struct name ) + tmp___31);
#line 2520
      name = (struct name *)tmp___32;
      }
#line 2521
      if (! name) {
        {
#line 2523
        printerr(1, "out of memory while allocating name\n");
#line 2524
        free((void *)nm);
        }
#line 2525
        goto switch_break___0;
      }
      {
#line 2527
      strcpy((char */* __restrict  */)(name->name), (char const   */* __restrict  */)nm);
#line 2528
      free((void *)nm);
#line 2529
      sp ++;
#line 2530
      stack[sp].name = (char const   *)(name->name);
#line 2531
      stack[sp].shouldclose = 1;
#line 2532
      stack[sp].line = 0;
#line 2533
      stack[sp].file = open_include_file___0((char const   *)(name->name), & stack[sp].dir,
                                             "r");
      }
#line 2535
      if (! stack[sp].file) {
        {
#line 2537
        printerr(1, "unable to open file %s\n", name->name);
#line 2538
        free((void *)name);
#line 2539
        sp --;
        }
#line 2540
        goto switch_break___0;
      }
#line 2542
      name->next = firstname;
#line 2543
      name->prev = (struct name *)((void *)0);
#line 2544
      if (name->next) {
#line 2545
        (name->next)->prev = name;
      }
#line 2546
      firstname = name;
#line 2547
      if (verbose >= 4) {
        {
#line 2548
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Reading file %s\n",
                name->name);
        }
      }
#line 2550
      goto switch_break___0;
      case_80: /* CIL Label */ 
      {
#line 2554
      tmp___33 = get_include_name___0(& ptr);
#line 2554
      name___0 = tmp___33;
      }
#line 2555
      if (! name___0) {
#line 2556
        goto switch_break___0;
      }
      {
#line 2557
      incfile = open_include_file___0((char const   *)name___0, (struct includedir **)((void *)0),
                                      "rb");
      }
#line 2558
      if (! incfile) {
        {
#line 2560
        printerr(1, "unable to open binary file %s\n", name___0);
#line 2561
        free((void *)name___0);
        }
#line 2562
        goto switch_break___0;
      }
      {
#line 2564
      while (1) {
        while_continue___16: /* CIL Label */ ;
        {
#line 2567
        tmp___34 = fread((void */* __restrict  */)(filebuffer), (size_t )1, (size_t )4096,
                         (FILE */* __restrict  */)incfile);
#line 2567
        num = tmp___34;
        }
#line 2568
        if (num == 0UL) {
#line 2569
          goto while_break___16;
        }
        {
#line 2570
        tmp___37 = fwrite((void const   */* __restrict  */)(filebuffer), (size_t )1,
                          num, (FILE */* __restrict  */)outfile);
        }
#line 2570
        if (num != tmp___37) {
          {
#line 2572
          tmp___35 = __errno_location();
#line 2572
          tmp___36 = strerror(*tmp___35);
#line 2572
          printerr(1, "error including binary file %s: %s\n", name___0, tmp___36);
          }
#line 2574
          goto while_break___16;
        }
#line 2576
        addr = (int )((size_t )addr + num);
#line 2577
        addr &= 65535;
      }
      while_break___16: /* CIL Label */ ;
      }
      {
#line 2579
      fclose(incfile);
#line 2580
      free((void *)name___0);
      }
#line 2581
      goto switch_break___0;
      case_81___0: /* CIL Label */ 
      {
#line 2584
      tmp___38 = rd_expr(& ptr, (char )'\000', (int *)((void *)0), sp, 1);
      }
#line 2584
      if (tmp___38) {
#line 2585
        ifcount ++;
      } else {
#line 2587
        noifcount ++;
      }
#line 2588
      goto switch_break___0;
      case_82___0: /* CIL Label */ 
#line 2590
      if (ifcount == 0) {
        {
#line 2592
        printerr(1, "else without if\n");
        }
#line 2593
        goto switch_break___0;
      }
#line 2595
      noifcount = 1;
#line 2596
      ifcount --;
#line 2597
      goto switch_break___0;
      case_83___0: /* CIL Label */ 
#line 2599
      if (noifcount == 0) {
#line 2599
        if (ifcount == 0) {
          {
#line 2601
          printerr(1, "endif without if\n");
          }
#line 2602
          goto switch_break___0;
        }
      }
#line 2604
      if (noifcount) {
#line 2605
        noifcount --;
      } else {
#line 2607
        ifcount --;
      }
#line 2608
      goto switch_break___0;
      case_85: /* CIL Label */ 
#line 2610
      if (! lastlabel) {
        {
#line 2612
        printerr(1, "macro without label\n");
        }
#line 2613
        goto switch_break___0;
      }
#line 2615
      if (define_macro) {
        {
#line 2617
        printerr(1, "nested macro definition\n");
        }
#line 2618
        goto switch_break___0;
      }
#line 2622
      m = firstmacro;
      {
#line 2622
      while (1) {
        while_continue___17: /* CIL Label */ ;
#line 2622
        if (! m) {
#line 2622
          goto while_break___17;
        }
        {
#line 2624
        tmp___39 = strcmp((char const   *)m->name, (char const   *)(lastlabel->name));
        }
#line 2624
        if (tmp___39 == 0) {
          {
#line 2626
          printerr(1, "duplicate macro definition\n");
          }
#line 2627
          goto while_break___17;
        }
#line 2622
        m = m->next;
      }
      while_break___17: /* CIL Label */ ;
      }
      {
#line 2630
      tmp___40 = malloc(sizeof(struct macro ));
#line 2630
      m = (struct macro *)tmp___40;
      }
#line 2631
      if (! m) {
        {
#line 2633
        printerr(1, "out of memory\n");
        }
#line 2634
        goto switch_break___0;
      }
      {
#line 2636
      tmp___41 = strlen((char const   *)(lastlabel->name));
#line 2636
      tmp___42 = malloc(tmp___41 + 1UL);
#line 2636
      m->name = (char *)tmp___42;
      }
#line 2637
      if (! m->name) {
        {
#line 2639
        printerr(1, "out of memory\n");
#line 2640
        free((void *)m);
        }
#line 2641
        goto switch_break___0;
      }
      {
#line 2643
      strcpy((char */* __restrict  */)m->name, (char const   */* __restrict  */)(lastlabel->name));
      }
#line 2644
      if (lastlabel->prev) {
#line 2645
        (lastlabel->prev)->next = lastlabel->next;
      } else {
#line 2647
        firstlabel = lastlabel->next;
      }
#line 2648
      if (lastlabel->next) {
#line 2649
        (lastlabel->next)->prev = lastlabel->prev;
      }
      {
#line 2650
      free((void *)lastlabel);
#line 2651
      m->next = firstmacro;
#line 2652
      firstmacro = m;
#line 2653
      m->lines = (struct macro_line *)((void *)0);
#line 2654
      m->numargs = get_macro_args___0(& ptr, & m->args, 0);
#line 2655
      define_macro = 1;
      }
#line 2657
      goto switch_break___0;
      case_86: /* CIL Label */ 
#line 2659
      if (stack[sp].file) {
        {
#line 2660
        printerr(1, "endm outside macro definition\n");
        }
      }
#line 2661
      goto switch_break___0;
      case_87: /* CIL Label */ 
      {
#line 2664
      tmp___43 = rd_expr(& ptr, (char )'\000', (int *)((void *)0), sp, 1);
#line 2664
      seekaddr = (unsigned int )tmp___43;
      }
#line 2665
      if (verbose >= 2) {
#line 2667
        if (stack[sp].dir) {
#line 2667
          tmp___44 = (char const   *)((stack[sp].dir)->name);
        } else {
#line 2667
          tmp___44 = "";
        }
        {
#line 2667
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s%s:%d: ",
                tmp___44, stack[sp].name, stack[sp].line);
#line 2670
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[Message] seeking to 0x%0X \n",
                seekaddr);
        }
      }
      {
#line 2673
      fseek(outfile, (long )seekaddr, 0);
      }
#line 2674
      goto switch_break___0;
      switch_default___0: /* CIL Label */ 
#line 2679
      m___0 = firstmacro;
      {
#line 2679
      while (1) {
        while_continue___18: /* CIL Label */ ;
#line 2679
        if (! m___0) {
#line 2679
          goto while_break___18;
        }
        {
#line 2681
        tmp___46 = strlen((char const   *)m___0->name);
#line 2681
        tmp___47 = strncmp((char const   *)m___0->name, ptr, tmp___46);
        }
#line 2681
        if (tmp___47 == 0) {
#line 2684
          if (sp + 1 >= 200) {
            {
#line 2686
            printerr(1, "stack overflow (circular include?)\n");
            }
#line 2687
            if (verbose >= 5) {
              {
#line 2690
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Stack dump:\nframe  line file\n");
#line 2692
              x___0 = 0;
              }
              {
#line 2692
              while (1) {
                while_continue___19: /* CIL Label */ ;
#line 2692
                if (! (x___0 < 200)) {
#line 2692
                  goto while_break___19;
                }
                {
#line 2693
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%5d %5d %s\n",
                        x___0, stack[x___0].line, stack[x___0].name);
#line 2692
                x___0 ++;
                }
              }
              while_break___19: /* CIL Label */ ;
              }
            }
#line 2696
            goto while_break___18;
          }
          {
#line 2698
          sp ++;
#line 2699
          tmp___45 = strlen((char const   *)m___0->name);
#line 2699
          ptr += tmp___45;
#line 2700
          numargs = get_macro_args___0(& ptr, & stack[sp].macro_args, 1);
          }
#line 2702
          if (numargs != m___0->numargs) {
            {
#line 2705
            printerr(1, "invalid number of arguments for macro (is %d, must be %d)\n",
                     numargs, m___0->numargs);
#line 2708
            a = 0U;
            }
            {
#line 2708
            while (1) {
              while_continue___20: /* CIL Label */ ;
#line 2708
              if (! (a < numargs)) {
#line 2708
                goto while_break___20;
              }
              {
#line 2709
              free((void *)*(stack[sp].macro_args + a));
#line 2708
              a ++;
              }
            }
            while_break___20: /* CIL Label */ ;
            }
            {
#line 2710
            free((void *)stack[sp].macro_args);
            }
#line 2711
            goto while_break___18;
          }
#line 2713
          stack[sp].name = (char const   *)m___0->name;
#line 2714
          stack[sp].file = (FILE *)((void *)0);
#line 2715
          stack[sp].line = 0;
#line 2716
          stack[sp].macro = m___0;
#line 2717
          stack[sp].macro_line = m___0->lines;
#line 2718
          stack[sp].shouldclose = 0;
#line 2719
          stack[sp].dir = (struct includedir *)((void *)0);
#line 2720
          goto while_break___18;
        }
#line 2679
        m___0 = m___0->next;
      }
      while_break___18: /* CIL Label */ ;
      }
#line 2723
      if (m___0) {
#line 2724
        goto switch_break___0;
      }
      {
#line 2726
      printerr(1, "command or comment expected (was %s)\n", ptr);
      }
      switch_break___0: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 1608
    file ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2730
  if (ifcount) {
    {
#line 2732
    printerr(1, "reached EOF at IF level %d\n", ifcount + noifcount);
    }
  } else
#line 2730
  if (noifcount) {
    {
#line 2732
    printerr(1, "reached EOF at IF level %d\n", ifcount + noifcount);
    }
  }
#line 2734
  if (havelist) {
    {
#line 2736
    fprintf((FILE */* __restrict  */)listfile, (char const   */* __restrict  */)"%04x\n",
            addr);
    }
  }
#line 2742
  sp ++;
#line 2743
  tmp___48 = firstreference;
  {
#line 2743
  while (1) {
    while_continue___21: /* CIL Label */ ;
#line 2743
    if (! tmp___48) {
#line 2743
      goto while_break___21;
    }
    {
#line 2746
    next___0 = tmp___48->next;
#line 2747
    fseek(outfile, tmp___48->oseekpos, 0);
    }
#line 2748
    if (havelist) {
      {
#line 2749
      fseek(listfile, tmp___48->lseekpos, 0);
      }
    }
    {
#line 2750
    stack[sp].name = (char const   *)tmp___48->file;
#line 2751
    stack[sp].dir = tmp___48->dir;
#line 2752
    stack[sp].line = tmp___48->line;
#line 2753
    ref___0 = compute_ref(tmp___48, 0);
#line 2754
    wrt_ref___0(ref___0, (int )tmp___48->type, tmp___48->count);
    }
#line 2755
    if (tmp___48->dir) {
      {
#line 2756
      free((void *)tmp___48->dir);
      }
    }
    {
#line 2757
    free((void *)tmp___48->file);
#line 2758
    free((void *)tmp___48);
#line 2743
    tmp___48 = next___0;
    }
  }
  while_break___21: /* CIL Label */ ;
  }
#line 2761
  if (! errors) {
#line 2761
    goto _L___0;
  } else
#line 2761
  if (use_force) {
    _L___0: /* CIL Label */ 
    {
#line 2763
    flush_to_real_file___0(realoutputfile, outfile);
    }
#line 2764
    if (havelist) {
      {
#line 2765
      flush_to_real_file___0(reallistfile, listfile);
      }
    }
  }
#line 2768
  if (label) {
    {
#line 2769
    fseek(labelfile, 0L, 2);
    }
  }
#line 2770
  l = firstlabel;
  {
#line 2770
  while (1) {
    while_continue___22: /* CIL Label */ ;
#line 2770
    if (! l) {
#line 2770
      goto while_break___22;
    }
#line 2772
    if (l->ref) {
      {
#line 2774
      compute_ref(l->ref, 0);
      }
    }
#line 2776
    if (label) {
      {
#line 2778
      fprintf((FILE */* __restrict  */)labelfile, (char const   */* __restrict  */)"%s%s:\tequ $%04x\n",
              labelprefix, l->name, l->value);
      }
    }
#line 2770
    l = l->next;
  }
  while_break___22: /* CIL Label */ ;
  }
#line 2782
  if (label) {
    {
#line 2783
    fclose(labelfile);
    }
  }
  {
#line 2784
  while (1) {
    while_continue___23: /* CIL Label */ ;
#line 2784
    if (! firstlabel) {
#line 2784
      goto while_break___23;
    }
    {
#line 2786
    l = firstlabel->next;
#line 2787
    free((void *)firstlabel);
#line 2788
    firstlabel = l;
    }
  }
  while_break___23: /* CIL Label */ ;
  }
  {
#line 2790
  fclose(outfile);
  }
#line 2791
  if ((unsigned long )outfile != (unsigned long )realoutputfile) {
    {
#line 2792
    fclose(realoutputfile);
    }
  }
#line 2793
  if (havelist) {
    {
#line 2795
    fclose(listfile);
    }
#line 2796
    if ((unsigned long )listfile != (unsigned long )reallistfile) {
#line 2796
      if ((unsigned long )reallistfile != (unsigned long )stderr) {
        {
#line 2797
        fclose(reallistfile);
        }
      }
    }
  }
  {
#line 2799
  free((void *)infile);
  }
#line 2800
  return;
}
}
