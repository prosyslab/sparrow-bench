/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 48 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_info.h"
enum gom_info_types {
    GOM_INFO_ERROR = -1,
    GOM_INFO_QUIET = 0,
    GOM_INFO_NORMAL = 1,
    GOM_INFO_VERBOSE = 2,
    GOM_INFO_DEBUG = 3
} ;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __useconds_t;
#line 37 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_mixer.h"
struct __anonstruct_Gom_mixer_settings_54 {
   int volume[25][2] ;
   int record[25] ;
};
#line 37 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_mixer.h"
typedef struct __anonstruct_Gom_mixer_settings_54 Gom_mixer_settings;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 107 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct itimerval {
   struct timeval it_interval ;
   struct timeval it_value ;
};
#line 120 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef int __itimer_which_t;
#line 104 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 38 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_gomii.h"
enum gom_gomii_refresh_stage {
    GOM_GOMII_REFRESH_NO = 0,
    GOM_GOMII_REFRESH_INIT = 1,
    GOM_GOMII_REFRESH_PAGE = 2,
    GOM_GOMII_REFRESH_CHANNELS = 3,
    GOM_GOMII_REFRESH_CURRENT_CHANNEL = 4
} ;
#line 150 "/usr/include/curses.h"
typedef unsigned long chtype;
#line 358
struct _win_st;
#line 358 "/usr/include/curses.h"
typedef struct _win_st WINDOW;
#line 360 "/usr/include/curses.h"
typedef chtype attr_t;
#line 405
struct ldat;
#line 407 "/usr/include/curses.h"
struct pdat {
   short _pad_y ;
   short _pad_x ;
   short _pad_top ;
   short _pad_left ;
   short _pad_bottom ;
   short _pad_right ;
};
#line 407 "/usr/include/curses.h"
struct _win_st {
   short _cury ;
   short _curx ;
   short _maxy ;
   short _maxx ;
   short _begy ;
   short _begx ;
   short _flags ;
   attr_t _attrs ;
   chtype _bkgd ;
   _Bool _notimeout ;
   _Bool _clear ;
   _Bool _leaveok ;
   _Bool _scroll ;
   _Bool _idlok ;
   _Bool _idcok ;
   _Bool _immed ;
   _Bool _sync ;
   _Bool _use_keypad ;
   int _delay ;
   struct ldat *_line ;
   short _regtop ;
   short _regbottom ;
   int _parx ;
   int _pary ;
   WINDOW *_parent ;
   struct pdat _pad ;
   short _yoffset ;
};
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 54 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_driver_oss.c"
struct __anonstruct_c_56 {
   int opened ;
   char fn[80] ;
   int fd ;
   unsigned int channelmask ;
   unsigned int stereomask ;
   unsigned int recmask ;
};
#line 54 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_driver_oss.c"
struct __anonstruct_v_57 {
   unsigned int lockmask ;
};
#line 54 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_driver_oss.c"
struct __anonstruct_s_58 {
   int dummy ;
};
#line 54 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_driver_oss.c"
struct __anonstruct_z_59 {
   unsigned int recsrcmask ;
   unsigned int volume[25] ;
};
#line 54 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_driver_oss.c"
struct __anonstruct_gom_driver_oss_55 {
   struct __anonstruct_c_56 c ;
   struct __anonstruct_v_57 v ;
   struct __anonstruct_s_58 s ;
   struct __anonstruct_z_59 z ;
};
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 140
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 51 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_info.h"
int gom_info_errors ;
#line 60
int gom_info_verbosity(void) ;
#line 61
void gom_info_verbosity_set(enum gom_info_types std_verb , int verbosity ) ;
#line 66
int gom_info_scroll(void) ;
#line 67
int gom_info_scroll_set(int scroll ) ;
#line 72
void gom_info_custom_default(enum gom_info_types kind , char *fmt , va_list vargs ) ;
#line 73
void gom_info_custom_set(void (*proc)(enum gom_info_types  , char * , va_list  ) ) ;
#line 78
void gom_info(enum gom_info_types kind , char *fmt  , ...) ;
#line 79
void gom_info_block(enum gom_info_types std_verb , int indent , char *text ) ;
#line 80
void gom_info_text(enum gom_info_types kind , char **text ) ;
#line 39 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_info.c"
int gom_info_verbosity_var  =    1;
#line 42 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_info.c"
int gom_info_scroll_var  =    0;
#line 45 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_info.c"
int gom_info_errors  =    0;
#line 48 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_info.c"
void (*gom_info_custom_var)(enum gom_info_types  , char * , va_list  )  =    & gom_info_custom_default;
#line 60 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_info.c"
int gom_info_verbosity(void) 
{ 


  {
#line 62
  return (gom_info_verbosity_var);
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_info.c"
void gom_info_verbosity_set(enum gom_info_types std_verb , int verbosity ) 
{ 
  int old_verbosity ;

  {
  {
#line 68
  old_verbosity = gom_info_verbosity_var;
#line 69
  gom_info_verbosity_var = verbosity;
#line 71
  gom_info(std_verb, (char *)"Verbosity set to %i (was %i) [<=%i:ERROR, %i:QUIET, %i:NORMAL, %i:VERBOSE, >=%i:DEBUG].",
           gom_info_verbosity_var, old_verbosity, -1, 0, 1, 2, 3);
  }
#line 75
  return;
}
}
#line 81 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_info.c"
int gom_info_scroll(void) 
{ 


  {
#line 83
  return (gom_info_scroll_var);
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_info.c"
int gom_info_scroll_set(int scroll ) 
{ 
  int old_scroll ;

  {
#line 88
  old_scroll = gom_info_scroll_var;
#line 89
  gom_info_scroll_var = scroll;
#line 90
  return (old_scroll);
}
}
#line 97 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_info.c"
void gom_info_custom_default(enum gom_info_types kind , char *fmt , va_list vargs ) 
{ 
  FILE *output_stream ;

  {
#line 100
  output_stream = stdout;
#line 101
  if ((int )kind == -1) {
#line 102
    output_stream = stderr;
  }
  {
#line 104
  vfprintf((FILE */* __restrict  */)output_stream, (char const   */* __restrict  */)fmt,
           vargs);
#line 105
  fprintf((FILE */* __restrict  */)output_stream, (char const   */* __restrict  */)"\n");
#line 106
  fflush(output_stream);
  }
#line 107
  return;
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_info.c"
void gom_info_custom_set(void (*proc)(enum gom_info_types  , char * , va_list  ) ) 
{ 


  {
#line 111
  if ((unsigned long )proc == (unsigned long )((void *)0)) {
#line 112
    gom_info_custom_var = & gom_info_custom_default;
  } else {
#line 114
    gom_info_custom_var = proc;
  }
#line 115
  return;
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_info.c"
void gom_info(enum gom_info_types kind , char *fmt  , ...) 
{ 
  va_list vargs ;
  char new_fmt[255] ;
  char const   *tmp ;
  int tmp___0 ;

  {
#line 127
  if ((int )kind == -1) {
#line 127
    if (gom_info_errors < 2147483647) {
#line 128
      gom_info_errors ++;
    }
  }
  {
#line 130
  tmp___0 = gom_info_verbosity();
  }
#line 130
  if ((int )kind <= tmp___0) {
#line 132
    if ((int )kind == -1) {
#line 132
      tmp = "gom ERROR: ";
    } else {
#line 132
      tmp = "gom: ";
    }
    {
#line 132
    strncpy((char */* __restrict  */)(new_fmt), (char const   */* __restrict  */)tmp,
            (size_t )255);
#line 133
    strncat((char */* __restrict  */)(new_fmt), (char const   */* __restrict  */)fmt,
            (size_t )255);
#line 134
    __builtin_va_start(vargs, fmt);
#line 135
    (*gom_info_custom_var)(kind, new_fmt, vargs);
#line 136
    __builtin_va_end(vargs);
    }
  }
#line 138
  return;
}
}
#line 146 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_info.c"
void gom_info_block(enum gom_info_types std_verb , int indent , char *text ) 
{ 
  char line[70] ;
  int i ;
  char *string ;
  int block_width ;
  size_t tmp ;

  {
#line 151
  string = text;
#line 152
  block_width = 69 - indent;
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 157
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 157
      if (! ((int )*string == 32)) {
#line 157
        goto while_break___0;
      }
#line 157
      string ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 159
    strcpy((char */* __restrict  */)(line), (char const   */* __restrict  */)"");
#line 160
    i = 0;
    }
    {
#line 160
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 160
      if (! (i < indent)) {
#line 160
        goto while_break___1;
      }
      {
#line 161
      strncat((char */* __restrict  */)(line), (char const   */* __restrict  */)" ",
              (size_t )69);
#line 160
      i ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 164
    strncat((char */* __restrict  */)(line), (char const   */* __restrict  */)string,
            (size_t )block_width);
#line 166
    gom_info(std_verb, line);
#line 168
    tmp = strlen((char const   *)string);
    }
#line 168
    if (tmp > (size_t )block_width) {
#line 169
      string += block_width;
    } else {
#line 171
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 174
  return;
}
}
#line 176 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_info.c"
void gom_info_text(enum gom_info_types kind , char **text ) 
{ 
  int i ;

  {
#line 179
  i = 0;
  {
#line 179
  while (1) {
    while_continue: /* CIL Label */ ;
#line 179
    if (! ((unsigned long )*(text + i) != (unsigned long )((void *)0))) {
#line 179
      goto while_break;
    }
    {
#line 180
    gom_info(kind, *(text + i));
#line 179
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 181
  return;
}
}
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 460 "/usr/include/unistd.h"
extern int usleep(__useconds_t __useconds ) ;
#line 64 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_driver.h"
int gom_driver_C(int c ) ;
#line 65
int gom_driver_C_first(void) ;
#line 67
int gom_driver_C_next(int c , int jump ) ;
#line 69
char *gom_driver_C_name(unsigned int c , int label ) ;
#line 75
int gom_driver_c(int c ) ;
#line 76
int gom_driver_c_first(void) ;
#line 78
int gom_driver_c_next(int c , int jump ) ;
#line 80
char *gom_driver_c_name(int c , int label ) ;
#line 87
int gom_driver_C_C_first(int c ) ;
#line 89
int gom_driver_C_C_next(int c , int cc , int jump ) ;
#line 96
int gom_driver_c_c(int c , int cc ) ;
#line 97
int gom_driver_c_c_first(int c ) ;
#line 99
int gom_driver_c_c_next(int c , int cc , int jump ) ;
#line 100
int gom_driver_c_c_len(int c ) ;
#line 106
int gom_driver_c_c_v_range(int v ) ;
#line 107
int gom_driver_c_c_v(int c , int cc ) ;
#line 108
void gom_driver_c_c_v_set(enum gom_info_types std_verb , int c , int cc , int v ) ;
#line 113
int gom_driver_c_r(int c ) ;
#line 114
void gom_driver_c_r_set(enum gom_info_types std_verb , int c , int r ) ;
#line 45 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_mixer.h"
void gom_mixer_d_defaults_set(enum gom_info_types std_verb ) ;
#line 48
int gom_mixer_C_find(char *name___0 ) ;
#line 51
int gom_mixer_c_current(void) ;
#line 52
int gom_mixer_c_c_current(void) ;
#line 53
void gom_mixer_c_current_set(enum gom_info_types std_verb , int c ) ;
#line 54
void gom_mixer_c_c_current_set(enum gom_info_types std_verb , int cc ) ;
#line 57
void gom_mixer_c_mute(enum gom_info_types std_verb , int c ) ;
#line 58
void gom_mixer_mute(enum gom_info_types std_verb ) ;
#line 61
int gom_mixer_fadival(void) ;
#line 62
int gom_mixer_fadival_set(enum gom_info_types std_verb , int duration ) ;
#line 63
void gom_mixer_c_c_v_fade(enum gom_info_types std_verb , int c , int cc , int v ) ;
#line 66
void gom_mixer_snapshot(enum gom_info_types std_verb ) ;
#line 67
void gom_mixer_unsnapshot(enum gom_info_types std_verb ) ;
#line 70
int gom_mixer_c_l(int c ) ;
#line 71
void gom_mixer_c_l_set(enum gom_info_types std_verb , int c , int lock ) ;
#line 74
void gom_mixer_l_set(enum gom_info_types std_verb , int lock ) ;
#line 77
void gom_mixer_c_v_set(enum gom_info_types std_verb , int c , int volume ) ;
#line 80
void gom_mixer_c_c_v_set_l(enum gom_info_types std_verb , int c , int cc , int volume ) ;
#line 83
void gom_mixer_c_c_v_fade_l(enum gom_info_types std_verb , int c , int cc , int v ) ;
#line 86
void gom_mixer_c_r_set_single(enum gom_info_types std_verb , int c ) ;
#line 38 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_mixer.c"
int gom_mixer_c_current_var  ;
#line 39 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_mixer.c"
int gom_mixer_c_c_current_var  ;
#line 40 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_mixer.c"
int gom_mixer_fadival_var  ;
#line 42 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_mixer.c"
Gom_mixer_settings gom_mixer_snapshot_var  ;
#line 44 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_mixer.c"
int gom_mixer_unlockmask[25]  = {      0};
#line 55 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_mixer.c"
void gom_mixer_d_defaults_set(enum gom_info_types std_verb ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 58
  gom_mixer_l_set(std_verb, 1);
#line 61
  tmp = gom_driver_c_first();
#line 61
  gom_mixer_c_current_set(std_verb, tmp);
#line 62
  tmp___0 = gom_mixer_c_current();
#line 62
  tmp___1 = gom_driver_c_c_first(tmp___0);
#line 62
  gom_mixer_c_c_current_set(std_verb, tmp___1);
#line 65
  gom_mixer_snapshot(std_verb);
  }
#line 66
  return;
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_mixer.c"
int gom_mixer_C_find(char *name___0 ) 
{ 
  int c ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 74
  c = gom_driver_C_first();
  }
  {
#line 74
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 74
    tmp = gom_driver_C(c);
    }
#line 74
    if (tmp > -1) {
      {
#line 74
      tmp___0 = gom_driver_C_name((unsigned int )c, 0);
#line 74
      tmp___1 = strcmp((char const   *)name___0, (char const   *)tmp___0);
      }
#line 74
      if (! (tmp___1 != 0)) {
#line 74
        goto while_break;
      }
    } else {
#line 74
      goto while_break;
    }
    {
#line 74
    c = gom_driver_C_next(c, 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 77
  return (c);
}
}
#line 84 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_mixer.c"
int gom_mixer_c_current(void) 
{ 


  {
#line 86
  return (gom_mixer_c_current_var);
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_mixer.c"
int gom_mixer_c_c_current(void) 
{ 


  {
#line 91
  return (gom_mixer_c_c_current_var);
}
}
#line 94 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_mixer.c"
void gom_mixer_c_current_set(enum gom_info_types std_verb , int c ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 96
  tmp___1 = gom_driver_c(c);
  }
#line 96
  if (tmp___1 > -1) {
    {
#line 98
    gom_mixer_c_current_var = c;
#line 99
    tmp = gom_driver_c_name(c, 0);
#line 99
    gom_info(std_verb, (char *)"Setting current channel to %d(%s).", c, tmp);
    }
  } else {
    {
#line 105
    tmp___0 = gom_driver_C_name((unsigned int )c, 0);
#line 105
    gom_info((enum gom_info_types )-1, (char *)"Can\'t make channel %d=(%s) current: unavailable.",
             c, tmp___0);
    }
  }
#line 110
  return;
}
}
#line 112 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_mixer.c"
void gom_mixer_c_c_current_set(enum gom_info_types std_verb , int cc ) 
{ 
  int c ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 114
  tmp = gom_mixer_c_current();
#line 114
  c = tmp;
#line 116
  tmp___2 = gom_driver_c_c(c, cc);
  }
#line 116
  if (tmp___2 > -1) {
    {
#line 118
    gom_mixer_c_c_current_var = cc;
#line 119
    tmp___0 = gom_driver_c_name(c, 0);
#line 119
    gom_info(std_verb, (char *)"Setting current volume to %d on channel %d(%s).",
             cc, c, tmp___0);
    }
  } else {
    {
#line 126
    tmp___1 = gom_driver_C_name((unsigned int )c, 0);
#line 126
    gom_info((enum gom_info_types )-1, (char *)"Can\'t set volume to %d on channel %d(%s): volume unavailable.",
             cc, c, tmp___1);
    }
  }
#line 131
  return;
}
}
#line 136 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_mixer.c"
void gom_mixer_c_mute(enum gom_info_types std_verb , int c ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 138
  tmp___1 = gom_driver_c(c);
  }
#line 138
  if (tmp___1 > -1) {
    {
#line 140
    gom_mixer_c_v_set((enum gom_info_types )((int )std_verb + 1), c, 0);
#line 141
    tmp = gom_driver_c_name(c, 0);
#line 141
    gom_info(std_verb, (char *)"Channel %d(%s) muted.", c, tmp);
    }
  } else {
    {
#line 147
    tmp___0 = gom_driver_C_name((unsigned int )c, 0);
#line 147
    gom_info((enum gom_info_types )-1, (char *)"Can\'t mute channel %d(%s): unavailable.",
             c, tmp___0);
    }
  }
#line 151
  return;
}
}
#line 153 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_mixer.c"
void gom_mixer_mute(enum gom_info_types std_verb ) 
{ 
  int c ;

  {
  {
#line 157
  c = gom_driver_c_first();
  }
  {
#line 157
  while (1) {
    while_continue: /* CIL Label */ ;
#line 157
    if (! (c > -1)) {
#line 157
      goto while_break;
    }
    {
#line 158
    gom_mixer_c_mute((enum gom_info_types )((int )std_verb + 1), c);
#line 157
    c = gom_driver_c_next(c, 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 160
  gom_info(std_verb, (char *)"All channels muted.");
  }
#line 161
  return;
}
}
#line 167 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_mixer.c"
int gom_mixer_fadival(void) 
{ 


  {
#line 169
  return (gom_mixer_fadival_var);
}
}
#line 172 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_mixer.c"
int gom_mixer_fadival_set(enum gom_info_types std_verb , int duration ) 
{ 
  int oldduration ;
  int tmp ;

  {
  {
#line 174
  tmp = gom_mixer_fadival();
#line 174
  oldduration = tmp;
  }
#line 175
  if (duration >= 1) {
#line 175
    if (duration <= 1800) {
      {
#line 178
      gom_mixer_fadival_var = duration;
#line 179
      gom_info(std_verb, (char *)"Fade duration set to %d seconds (was %d).", duration,
               oldduration);
      }
    } else {
      {
#line 183
      gom_info((enum gom_info_types )-1, (char *)"Requested fade duration (%d seconds) out of range (allowed range: %d < duration <= %d).",
               duration, 1, 1800);
      }
    }
  } else {
    {
#line 183
    gom_info((enum gom_info_types )-1, (char *)"Requested fade duration (%d seconds) out of range (allowed range: %d < duration <= %d).",
             duration, 1, 1800);
    }
  }
#line 187
  return (oldduration);
}
}
#line 190 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_mixer.c"
void gom_mixer_c_c_v_fade_meta(enum gom_info_types std_verb , int c , int cc , int v ,
                               int locksensible ) 
{ 
  int volume ;
  int diff ;
  unsigned long micro_seconds_to_sleep ;
  int fade_up ;
  int old_v ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;

  {
  {
#line 193
  micro_seconds_to_sleep = 5000UL;
#line 196
  tmp = gom_driver_c_c_v(c, cc);
#line 196
  old_v = tmp;
#line 197
  v = gom_driver_c_c_v_range(v);
  }
#line 199
  if (old_v < 0) {
    {
#line 201
    tmp___0 = gom_driver_C_name((unsigned int )c, 0);
#line 201
    gom_info((enum gom_info_types )-1, (char *)"Can\'t fade volume %d on channel %d(%s): not available.",
             cc, c, tmp___0);
    }
  } else
#line 205
  if (! (v < 0)) {
#line 212
    if (locksensible) {
      {
#line 212
      tmp___7 = gom_mixer_c_l(c);
      }
#line 212
      if (tmp___7) {
        {
#line 213
        tmp___1 = gom_mixer_fadival();
#line 213
        tmp___2 = gom_driver_c_c_v(c, cc);
#line 213
        tmp___3 = gom_driver_c_name(c, 0);
#line 213
        gom_info(std_verb, (char *)"Fading all volumes of channel %d(%s) from %i to %i in about %i seconds.",
                 c, tmp___3, tmp___2, v, tmp___1);
        }
      } else {
        {
#line 218
        tmp___4 = gom_mixer_fadival();
#line 218
        tmp___5 = gom_driver_c_c_v(c, cc);
#line 218
        tmp___6 = gom_driver_c_name(c, 0);
#line 218
        gom_info(std_verb, (char *)"Fading volume %d of channel %d(%s) from %i to %i in about %i seconds.",
                 cc, c, tmp___6, tmp___5, v, tmp___4);
        }
      }
    } else {
      {
#line 218
      tmp___4 = gom_mixer_fadival();
#line 218
      tmp___5 = gom_driver_c_c_v(c, cc);
#line 218
      tmp___6 = gom_driver_c_name(c, 0);
#line 218
      gom_info(std_verb, (char *)"Fading volume %d of channel %d(%s) from %i to %i in about %i seconds.",
               cc, c, tmp___6, tmp___5, v, tmp___4);
      }
    }
    {
#line 224
    tmp___8 = gom_driver_c_c_v(c, cc);
#line 224
    fade_up = tmp___8 <= v;
    }
#line 225
    if (fade_up) {
      {
#line 225
      tmp___9 = gom_driver_c_c_v(c, cc);
#line 225
      diff = v - tmp___9;
      }
    } else {
      {
#line 225
      tmp___10 = gom_driver_c_c_v(c, cc);
#line 225
      diff = tmp___10 - v;
      }
    }
    {
#line 226
    tmp___11 = gom_mixer_fadival();
#line 226
    micro_seconds_to_sleep = (unsigned long )(1000000 * tmp___11);
    }
#line 228
    if (diff != 0) {
#line 228
      tmp___12 = diff;
    } else {
#line 228
      tmp___12 = 1;
    }
#line 228
    micro_seconds_to_sleep /= (unsigned long )tmp___12;
#line 230
    if (fade_up) {
      {
#line 230
      tmp___14 = gom_driver_c_c_v(c, cc);
#line 230
      volume = tmp___14 + 1;
      }
    } else {
      {
#line 230
      tmp___13 = gom_driver_c_c_v(c, cc);
#line 230
      volume = tmp___13 - 1;
      }
    }
    {
#line 230
    while (1) {
      while_continue: /* CIL Label */ ;
#line 230
      if (fade_up) {
#line 230
        tmp___15 = volume < v;
      } else {
#line 230
        tmp___15 = volume > v;
      }
#line 230
      if (! tmp___15) {
#line 230
        goto while_break;
      }
#line 234
      if (locksensible) {
        {
#line 235
        gom_mixer_c_c_v_set_l((enum gom_info_types )((int )std_verb + 1), c, cc, volume);
        }
      } else {
        {
#line 237
        gom_driver_c_c_v_set((enum gom_info_types )((int )std_verb + 1), c, cc, volume);
        }
      }
      {
#line 238
      usleep((__useconds_t )micro_seconds_to_sleep);
      }
#line 230
      if (fade_up) {
#line 230
        volume ++;
      } else {
#line 230
        volume --;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 240
    if (locksensible) {
      {
#line 241
      gom_mixer_c_c_v_set_l((enum gom_info_types )((int )std_verb + 1), c, cc, v);
      }
    } else {
      {
#line 243
      gom_driver_c_c_v_set((enum gom_info_types )((int )std_verb + 1), c, cc, v);
      }
    }
  }
#line 245
  return;
}
}
#line 247 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_mixer.c"
void gom_mixer_c_c_v_fade(enum gom_info_types std_verb , int c , int cc , int v ) 
{ 


  {
  {
#line 249
  gom_mixer_c_c_v_fade_meta(std_verb, c, cc, v, 0);
  }
#line 250
  return;
}
}
#line 253 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_mixer.c"
void gom_mixer_c_c_v_fade_l(enum gom_info_types std_verb , int c , int cc , int v ) 
{ 


  {
  {
#line 255
  gom_mixer_c_c_v_fade_meta(std_verb, c, cc, v, 1);
  }
#line 256
  return;
}
}
#line 259 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_mixer.c"
void gom_mixer_snapshot(enum gom_info_types std_verb ) 
{ 
  int c ;
  int cc ;

  {
  {
#line 264
  c = gom_driver_C_first();
  }
  {
#line 264
  while (1) {
    while_continue: /* CIL Label */ ;
#line 264
    if (! (c > -1)) {
#line 264
      goto while_break;
    }
    {
#line 266
    gom_mixer_snapshot_var.record[c] = gom_driver_c_r(c);
#line 267
    cc = gom_driver_C_C_first(c);
    }
    {
#line 267
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 267
      if (! (cc > -1)) {
#line 267
        goto while_break___0;
      }
      {
#line 268
      gom_mixer_snapshot_var.volume[c][cc] = gom_driver_c_c_v(c, cc);
#line 267
      cc = gom_driver_C_C_next(c, cc, 1);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 264
    c = gom_driver_C_next(c, 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 270
  gom_info(std_verb, (char *)"Snapshot of current settings made.");
  }
#line 271
  return;
}
}
#line 274 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_mixer.c"
void gom_mixer_unsnapshot_c(enum gom_info_types std_verb , int c ) 
{ 
  int cc ;

  {
#line 278
  if (gom_mixer_snapshot_var.record[c] > -1) {
    {
#line 279
    gom_driver_c_r_set((enum gom_info_types )((int )std_verb + 1), c, gom_mixer_snapshot_var.record[c]);
    }
  }
  {
#line 280
  cc = gom_driver_c_c_first(c);
  }
  {
#line 280
  while (1) {
    while_continue: /* CIL Label */ ;
#line 280
    if (! (cc > -1)) {
#line 280
      goto while_break;
    }
    {
#line 281
    gom_driver_c_c_v_set((enum gom_info_types )((int )std_verb + 1), c, cc, gom_mixer_snapshot_var.volume[c][cc]);
#line 280
    cc = gom_driver_c_c_next(c, cc, 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 283
  gom_info(std_verb, (char *)"Snapshot settings for channel %i restored.", c);
  }
#line 284
  return;
}
}
#line 286 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_mixer.c"
void gom_mixer_unsnapshot(enum gom_info_types std_verb ) 
{ 
  int c ;

  {
  {
#line 293
  c = gom_driver_c_first();
  }
  {
#line 293
  while (1) {
    while_continue: /* CIL Label */ ;
#line 293
    if (! (c > -1)) {
#line 293
      goto while_break;
    }
#line 295
    if (gom_mixer_snapshot_var.record[c] > 0) {
      {
#line 296
      gom_mixer_unsnapshot_c((enum gom_info_types )((int )std_verb + 1), c);
      }
    }
    {
#line 293
    c = gom_driver_c_next(c, 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 300
  c = gom_driver_c_first();
  }
  {
#line 300
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 300
    if (! (c > -1)) {
#line 300
      goto while_break___0;
    }
#line 302
    if (gom_mixer_snapshot_var.record[c] <= 0) {
      {
#line 303
      gom_mixer_unsnapshot_c((enum gom_info_types )((int )std_verb + 1), c);
      }
    }
    {
#line 300
    c = gom_driver_c_next(c, 1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 306
  gom_info(std_verb, (char *)"Snapshot settings restored.");
  }
#line 307
  return;
}
}
#line 314 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_mixer.c"
int gom_mixer_c_l(int c ) 
{ 
  int tmp ;

  {
  {
#line 316
  tmp = gom_driver_C(c);
  }
#line 316
  if (tmp > -1) {
#line 317
    return (! gom_mixer_unlockmask[c]);
  } else {
#line 319
    return (-1);
  }
}
}
#line 322 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_mixer.c"
void gom_mixer_c_l_set(enum gom_info_types std_verb , int c , int lock ) 
{ 
  int old_lock ;
  char const   *tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;

  {
  {
#line 325
  tmp___11 = gom_driver_C(c);
  }
#line 325
  if (tmp___11 > -1) {
    {
#line 327
    old_lock = gom_mixer_c_l(c);
#line 328
    gom_mixer_unlockmask[c] = ! lock;
#line 330
    tmp___4 = gom_driver_c(c);
    }
#line 330
    if (tmp___4 < 0) {
#line 330
      tmp___3 = " [though currently unavailable]";
    } else {
      {
#line 330
      tmp___2 = gom_driver_c_c_len(c);
      }
#line 330
      if (tmp___2 == 1) {
#line 330
        tmp___1 = " [though currently mono]";
      } else {
#line 330
        tmp___1 = "";
      }
#line 330
      tmp___3 = tmp___1;
    }
#line 330
    if (old_lock) {
#line 330
      tmp___5 = "l";
    } else {
#line 330
      tmp___5 = "unl";
    }
    {
#line 330
    tmp___8 = gom_mixer_c_l(c);
    }
#line 330
    if (tmp___8) {
#line 330
      tmp___7 = "l";
    } else {
#line 330
      tmp___7 = "unl";
    }
    {
#line 330
    tmp___9 = gom_driver_C_name((unsigned int )c, 0);
#line 330
    gom_info(std_verb, (char *)"Channel %d(%s) %socked (was %socked)%s.", c, tmp___9,
             tmp___7, tmp___5, tmp___3);
    }
  } else {
    {
#line 340
    tmp___10 = gom_driver_C_name((unsigned int )c, 0);
#line 340
    gom_info((enum gom_info_types )-1, (char *)"Can\'t (un)lock channel %d(%s): Unexistent channel.",
             c, tmp___10);
    }
  }
#line 344
  return;
}
}
#line 347 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_mixer.c"
void gom_mixer_l_set(enum gom_info_types std_verb , int lock ) 
{ 
  int c ;
  char const   *tmp ;

  {
  {
#line 350
  c = gom_driver_C_first();
  }
  {
#line 350
  while (1) {
    while_continue: /* CIL Label */ ;
#line 350
    if (! (c > -1)) {
#line 350
      goto while_break;
    }
    {
#line 351
    gom_mixer_c_l_set((enum gom_info_types )((int )std_verb + 1), c, lock);
#line 350
    c = gom_driver_C_next(c, 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 353
  if (lock) {
#line 353
    tmp = "l";
  } else {
#line 353
    tmp = "unl";
  }
  {
#line 353
  gom_info(std_verb, (char *)"All channels %socked.", tmp);
  }
#line 356
  return;
}
}
#line 359 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_mixer.c"
void gom_mixer_c_v_set(enum gom_info_types std_verb , int c , int volume ) 
{ 
  int cc ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 363
  tmp___3 = gom_driver_c(c);
  }
#line 363
  if (tmp___3 > -1) {
    {
#line 365
    cc = gom_driver_c_c_first(c);
    }
    {
#line 365
    while (1) {
      while_continue: /* CIL Label */ ;
#line 365
      if (! (cc > -1)) {
#line 365
        goto while_break;
      }
      {
#line 366
      gom_driver_c_c_v_set((enum gom_info_types )((int )std_verb + 1), c, cc, volume);
#line 365
      cc = gom_driver_c_c_next(c, cc, 1);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 368
    tmp___0 = gom_driver_c_c_first(c);
#line 368
    tmp___1 = gom_driver_c_c_v(c, tmp___0);
    }
#line 368
    if (volume == tmp___1) {
      {
#line 369
      tmp = gom_driver_c_name(c, 0);
#line 369
      gom_info(std_verb, (char *)"All volumes for channel %d(%s) set to %d.", c, tmp,
               volume);
      }
    }
  } else {
    {
#line 376
    tmp___2 = gom_driver_C_name((unsigned int )c, 0);
#line 376
    gom_info((enum gom_info_types )-1, (char *)"Can\'t set volumes on channel %d(%s): not available.",
             c, tmp___2);
    }
  }
#line 380
  return;
}
}
#line 383 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_mixer.c"
void gom_mixer_c_c_v_set_l(enum gom_info_types std_verb , int c , int cc , int volume ) 
{ 
  int tmp ;

  {
  {
#line 385
  tmp = gom_mixer_c_l(c);
  }
#line 385
  if (tmp) {
    {
#line 386
    gom_mixer_c_v_set(std_verb, c, volume);
    }
  } else {
    {
#line 388
    gom_driver_c_c_v_set(std_verb, c, cc, volume);
    }
  }
#line 389
  return;
}
}
#line 391 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_mixer.c"
void gom_mixer_c_r_set_single(enum gom_info_types std_verb , int c ) 
{ 
  int c2 ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 396
  gom_driver_c_r_set(std_verb, c, 1);
#line 398
  tmp___0 = gom_driver_c_r(c);
  }
#line 398
  if (tmp___0 == 1) {
    {
#line 401
    c2 = gom_driver_c_first();
    }
    {
#line 401
    while (1) {
      while_continue: /* CIL Label */ ;
#line 401
      if (! (c2 > -1)) {
#line 401
        goto while_break;
      }
#line 403
      if (c != c2) {
        {
#line 403
        tmp = gom_driver_c_r(c2);
        }
#line 403
        if (tmp > -1) {
          {
#line 404
          gom_driver_c_r_set((enum gom_info_types )((int )std_verb + 2), c2, 0);
          }
        }
      }
      {
#line 401
      c2 = gom_driver_c_next(c2, 1);
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 407
  return;
}
}
#line 716 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_iface_x.c"
int gom_iface_c_global_dummy  =    0;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 205
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) strftime)(char * __restrict  __s ,
                                                                                  size_t __maxsize ,
                                                                                  char const   * __restrict  __format ,
                                                                                  struct tm  const  * __restrict  __tp ) ;
#line 243
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 131 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setitimer)(__itimer_which_t __which ,
                                                                                struct itimerval  const  * __restrict  __new ,
                                                                                struct itimerval * __restrict  __old ) ;
#line 53 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_gomii.h"
void gom_gomii_refproc_keep(void) ;
#line 54
int gom_gomii_refival(void) ;
#line 56
int gom_gomii_refival_set(enum gom_info_types std_verb , int interval , void (*refproc)() ) ;
#line 57
char *gom_gomii_last_refresh_str(void) ;
#line 39 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_gomii.c"
int gom_gomii_refival_var  ;
#line 42 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_gomii.c"
void (*gom_gomii_refproc)()  =    (void (*)())0;
#line 58 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_gomii.c"
void gom_gomii_refresh_handler(int sig ) 
{ 


  {
#line 60
  if ((unsigned long )gom_gomii_refproc != (unsigned long )((void *)0)) {
    {
#line 62
    (*gom_gomii_refproc)();
    }
  } else {
    {
#line 65
    gom_info((enum gom_info_types )-1, (char *)"Bug: Gomii refresh handler called, but gom_gomii_refproc is NULL.");
    }
  }
  {
#line 70
  signal(14, & gom_gomii_refresh_handler);
  }
#line 71
  return;
}
}
#line 74 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_gomii.c"
void gom_gomii_refproc_keep(void) 
{ 


  {
#line 75
  return;
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_gomii.c"
int gom_gomii_refival(void) 
{ 


  {
#line 80
  return (gom_gomii_refival_var);
}
}
#line 83 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_gomii.c"
int gom_gomii_refival_set(enum gom_info_types std_verb , int interval , void (*refproc)() ) 
{ 
  struct itimerval real_timer ;
  int err ;
  int oldinterval ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;

  {
  {
#line 87
  tmp = gom_gomii_refival();
#line 87
  oldinterval = tmp;
  }
#line 89
  if (interval >= 0) {
#line 89
    if (interval <= 3600) {
#line 93
      gom_gomii_refival_var = interval;
#line 96
      if ((unsigned long )gom_gomii_refproc != (unsigned long )((void *)0)) {
        {
#line 99
        real_timer.it_interval.tv_sec = (__time_t )0;
#line 100
        real_timer.it_interval.tv_usec = (__suseconds_t )0;
#line 101
        real_timer.it_value.tv_sec = (__time_t )0;
#line 102
        real_timer.it_value.tv_usec = (__suseconds_t )0;
#line 103
        err = setitimer(0, (struct itimerval  const  */* __restrict  */)(& real_timer),
                        (struct itimerval */* __restrict  */)((void *)0));
        }
#line 104
        if (err != 0) {
          {
#line 105
          gom_info((enum gom_info_types )-1, (char *)"(ignored) Can\'t uninstall gomii auto refresh (\"setitimer\" failed with error code %d).",
                   err);
          }
        }
        {
#line 108
        signal(14, (void (*)(int  ))0);
        }
      }
#line 112
      if ((unsigned long )refproc != (unsigned long )(& gom_gomii_refproc_keep)) {
#line 113
        gom_gomii_refproc = refproc;
      }
#line 116
      if ((unsigned long )gom_gomii_refproc != (unsigned long )((void *)0)) {
        {
#line 119
        tmp___0 = gom_gomii_refival();
#line 119
        real_timer.it_interval.tv_sec = (__time_t )tmp___0;
#line 120
        real_timer.it_interval.tv_usec = (__suseconds_t )0;
#line 121
        tmp___1 = gom_gomii_refival();
#line 121
        real_timer.it_value.tv_sec = (__time_t )tmp___1;
#line 122
        real_timer.it_value.tv_usec = (__suseconds_t )0;
#line 123
        err = setitimer(0, (struct itimerval  const  */* __restrict  */)(& real_timer),
                        (struct itimerval */* __restrict  */)((void *)0));
        }
#line 124
        if (err != 0) {
          {
#line 125
          gom_info((enum gom_info_types )-1, (char *)"Can\'t install gomii auto refresh: \"setitimer\" failed with error code %d.",
                   err);
          }
        } else {
          {
#line 129
          signal(14, & gom_gomii_refresh_handler);
          }
        }
      }
#line 131
      if (oldinterval == 0) {
#line 131
        tmp___3 = "(disabled)";
      } else {
#line 131
        if (oldinterval == 1) {
#line 131
          tmp___2 = "second";
        } else {
#line 131
          tmp___2 = "seconds";
        }
#line 131
        tmp___3 = tmp___2;
      }
#line 131
      if (interval == 0) {
#line 131
        tmp___5 = "(disabled)";
      } else {
#line 131
        if (interval == 1) {
#line 131
          tmp___4 = "second";
        } else {
#line 131
          tmp___4 = "seconds";
        }
#line 131
        tmp___5 = tmp___4;
      }
      {
#line 131
      gom_info(std_verb, (char *)"Gomii refresh interval set to %d %s (was %d %s).",
               interval, tmp___5, oldinterval, tmp___3);
      }
    } else {
      {
#line 137
      gom_info((enum gom_info_types )-1, (char *)"Requested gomii refresh interval (%d seconds) out of range (allowed range: %d <= interval <= %d).",
               interval, 0, 3600);
      }
    }
  } else {
    {
#line 137
    gom_info((enum gom_info_types )-1, (char *)"Requested gomii refresh interval (%d seconds) out of range (allowed range: %d <= interval <= %d).",
             interval, 0, 3600);
    }
  }
#line 141
  return (oldinterval);
}
}
#line 150 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_gomii.c"
static char last_refresh_string[30]  ;
#line 148 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_gomii.c"
char *gom_gomii_last_refresh_str(void) 
{ 
  time_t current_time ;
  struct tm *tmp ;

  {
  {
#line 153
  current_time = time((time_t *)((void *)0));
#line 154
  tmp = localtime((time_t const   *)(& current_time));
#line 154
  strftime((char */* __restrict  */)(last_refresh_string), (size_t )29, (char const   */* __restrict  */)"Last refresh: %X",
           (struct tm  const  */* __restrict  */)tmp);
  }
#line 155
  return ((char *)(& last_refresh_string));
}
}
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 717
extern int system(char const   *__command ) ;
#line 173 "/usr/include/getopt.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long)(int ___argc ,
                                                                                  char * const  *___argv ,
                                                                                  char const   *__shortopts ,
                                                                                  struct option  const  *__longopts ,
                                                                                  int *__longind ) ;
#line 48 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_driver.h"
char *gom_driver(void) ;
#line 55
char *gom_driver_d(void) ;
#line 57
int gom_driver_d_set(enum gom_info_types std_verb , char *device_file ) ;
#line 68
int gom_driver_C_len(void) ;
#line 79
int gom_driver_c_len(void) ;
#line 51 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_file.h"
void gom_file_options_read(enum gom_info_types std_verb , FILE *f , char *allowed_actions ) ;
#line 54
void gom_file_load(enum gom_info_types verb , char *fname , int is_settings_file ,
                   char *allowed_actions ) ;
#line 70
void gom_file_settings_write(FILE *f , int verbose ) ;
#line 73
void gom_file_settings_save(enum gom_info_types std_verb , char *fname ) ;
#line 59 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_action.h"
char *gom_action_shortopts(void) ;
#line 62
int gom_action_getopt(int argc , char * const  *argv ) ;
#line 65
void gom_action_help_special_set(char **help_text___0 ) ;
#line 68
enum gom_gomii_refresh_stage gom_action(enum gom_info_types std_verb , char action ,
                                        int cmd_line , char *(*get_option_arg)(char * ) ,
                                        void (*pre_scroll)() , void (*post_scroll)() ) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_iface.h"
void gom_iface_t(void) ;
#line 44 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_action.c"
void *gom_action_help_special_var  =    (void *)0;
#line 57 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_action.c"
struct option gom_options[60]  = 
#line 57
  {      {"device", 1, (int *)0, 'd'}, 
        {"mixer", 1, (int *)0, 'd'}, 
        {"channel", 1, (int *)0, 'c'}, 
        {"volume-channel", 1, (int *)0, 'C'}, 
        {"lock", 1, (int *)0, 'k'}, 
        {"lock-all", 1, (int *)0, 'K'}, 
        {"fade-interval", 1, (int *)0, 'F'}, 
        {"refresh-interval", 1, (int *)0, 'U'}, 
        {"write-config", 0, (int *)0, 'W'}, 
        {"save-config", 0, (int *)0, 'W'}, 
        {"loudness", 1, (int *)0, 'l'}, 
        {"volume", 1, (int *)0, 'l'}, 
        {"record", 1, (int *)0, 'r'}, 
        {"record-single", 0, (int *)0, 'R'}, 
        {"fade-to-loudness", 1, (int *)0, 'L'}, 
        {"fade-to-volume", 1, (int *)0, 'L'}, 
        {"mute", 0, (int *)0, 'm'}, 
        {"mute-all", 0, (int *)0, 'M'}, 
        {"get-options", 2, (int *)0, 'G'}, 
        {"load-options", 2, (int *)0, 'G'}, 
        {"get-settings", 2, (int *)0, 'G'}, 
        {"load-settings", 2, (int *)0, 'G'}, 
        {"save-settings", 2, (int *)0, 'S'}, 
        {"snapshot-settings", 0, (int *)0, 'z'}, 
        {"unsnapshot-settings", 0, (int *)0, 'Z'}, 
        {"restore-settings", 0, (int *)0, 'Z'}, 
        {"originate", 0, (int *)0, 'O'}, 
        {"initialize", 0, (int *)0, 'O'}, 
        {"info", 0, (int *)0, 't'}, 
        {"info-all", 0, (int *)0, 'T'}, 
        {"version", 0, (int *)0, 'V'}, 
        {"copyright", 0, (int *)0, 'w'}, 
        {"copyleft", 0, (int *)0, 'w'}, 
        {"license", 0, (int *)0, 'w'}, 
        {"warranty", 0, (int *)0, 'w'}, 
        {"help", 0, (int *)0, 'h'}, 
        {"help-verbose", 0, (int *)0, 'H'}, 
        {"execute", 1, (int *)0, 'e'}, 
        {"ignore-config", 0, (int *)0, 'Y'}, 
        {"interface", 1, (int *)0, 'i'}, 
        {"gomii", 1, (int *)0, 'i'}, 
        {"verbose", 2, (int *)0, 'v'}, 
        {"quiet", 0, (int *)0, 'q'}, 
        {"silent", 0, (int *)0, 'q'}, 
        {"extract-settings", 0, (int *)0, 'x'}, 
        {"read-stdin", 0, (int *)0, 'I'}, 
        {"print-driver", 0, (int *)0, '1'}, 
        {"print-driver-channels", 0, (int *)0, '2'}, 
        {"print-device", 0, (int *)0, '3'}, 
        {"print-mixer", 0, (int *)0, '3'}, 
        {"print-channels", 0, (int *)0, '4'}, 
        {"print-channel-name", 0, (int *)0, '5'}, 
        {"print-channel-label", 0, (int *)0, '6'}, 
        {"print-channel-volumes", 0, (int *)0, '7'}, 
        {"print-channel-volume", 0, (int *)0, '8'}, 
        {"print-channel-recsrc", 0, (int *)0, '9'}, 
        {"print-channel-lock", 0, (int *)0, '0'}, 
        {"print-fade-interval", 0, (int *)0, 'a'}, 
        {"print-refresh-interval", 0, (int *)0, 'A'}, 
        {(char const   *)((void *)0), 0, (int *)0, 0}};
#line 140 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_action.c"
char *gom_options_help[59]  = 
#line 140
  {      (char *)((void *)0),      (char *)"[no_mixer_opened] Set mixer special device file to <argument>. If the new mixer is valid, the current mixer --if any-- will be closed and the new mixer opened. Current channel, current channel volume, the channel lock setting and the snapshot will be resetted to defaults.",      (char *)"[first available channel] Set current mixer channel to <argument>. The channel may be given as number or as name.",      (char *)"[first available volume channel on current channel] Set volume channel on current mixer channel to <argument> (e.g., for stereo, 0 means left, 1 means right volume).", 
        (char *)((void *)0),      (char *)"[1] Lock or unlock current or all channel(s). Locking means syncing of the stereo volumes (balance) for all volume settings gom might do -- this doesn\'t change any volume settings by itself (i.e., it doesn\'t auto-balance). Thus, a locked channel might have unbalanced volumes.",      (char *)"[5] Set fade interval to <argument> seconds. See --fade-to-loudness.",      (char *)"[30] Set gomii refresh (update) interval to <argument> seconds (zero disables).", 
        (char *)((void *)0),      (char *)"This option is obsolete since version 0.29.10.",      (char *)((void *)0),      (char *)"Set current volume channel on current channel to <argument>. If the argument is being given with a leading \"+\" or \"-\", the given value will be added or substracted, respectively, from the current value. The allowed range is from zero up to a soundcard driver dependent maximum.", 
        (char *)"Set recording for current channel on or off.",      (char *)"Set recording for current channel on and disable all other recording sources.",      (char *)((void *)0),      (char *)"Like --loudness, but fade to the new volume within a time given with --fade-interval.", 
        (char *)((void *)0),      (char *)"Mute current or all channels. Muting means setting all channel volumes to 0.",      (char *)((void *)0),      (char *)((void *)0), 
        (char *)((void *)0),      (char *)"Get options from/to file <argument>. If no argument is given, the default file (named \"default\") is used. Non-absolut given filenames will be expanded to \"<mixer-device>.<argument>\", and then first searched for in the user and -- if this fails -- in the system configuration directory. Any free-form files with gom one-character command line options in any lines starting with a dash (in column zero) will make sense to this option.",      (char *)"Save mixer settings to a free-form option file; for the file name, the same rules as for loading option files apply, except that only the user configuration dir will be used. Files with thusly expanded filenames will be silently overwritten; other files never. When saving, care is being taken that the \"last recording source error\" can\'t occur when loading these options (and maybe there are other reasonable side effects apart from the pure mixer settings (e.g. channel locking, current channel)).",      (char *)((void *)0), 
        (char *)((void *)0),      (char *)"[mixer settings after opening a new mixer] Snap- or unsnapshot to/from current mixer settings.",      (char *)((void *)0),      (char *)"Load the options file initialize; all options are allowed in this file. This is meant to initialize mixers. For example: \"-d/dev/mixer0 -G -d/dev/mixer1 -G\". This would load the default settings file for both the mixer0 and the mixer1 device.", 
        (char *)"Display current channel information.",      (char *)"Display overall information.",      (char *)"Display version information.",      (char *)((void *)0), 
        (char *)((void *)0),      (char *)((void *)0),      (char *)"Display copyright/license/warranty information.",      (char *)((void *)0), 
        (char *)"Display this help normally or verbose; both helps are still dependent on the current verbosity level (i.e., higher verbosity levels might still show more; \"gom -v0 -H\" and \"gom -h\" produce the same output). For the normal verbosity level, these are reasonable macros.",      (char *)"Execute the shell command <argument>.",      (char *)"Skip all automatically loaded configurations files; this must be given before any other option (except q (quiet) or v (verbose)).",      (char *)((void *)0), 
        (char *)"Explicitly start up a build-in gomii (<argument>=t: terminal gomii, <argument>=x: X gomii).",      (char *)"[NORMAL] Set output verbosity level to <argument> (number, the higher, the more verbose). If no argument is given, the level will be increased by 1.",      (char *)((void *)0),      (char *)"Set output verbosity to QUIET (only error / error help messages).", 
        (char *)"Extract all mixer settings as a gom option line to stdout (e.g. for \"setting=`gom --quiet --extract-settings`\" and \"gom --quiet $settings\" later in a shell script).",      (char *)"Read options from stdin (until EOF).",      (char *)"Print the used sound driver.",      (char *)"List of all channels known by the used driver.", 
        (char *)((void *)0),      (char *)"Prints current mixer\'s device file name.",      (char *)"Prints a list of all currently available channels.",      (char *)"Prints current channel\'s name.", 
        (char *)"Prints current channel\'s label.",      (char *)"Prints a list of all available volumes of current channel.",      (char *)"Print the current subchannel\'s volume value.",      (char *)"Prints current channel\'s record state (-1=unavailable, 0=off, 1=on).", 
        (char *)"Prints current channel\'s lock state (0=unlocked, 1=locked).",      (char *)"Prints current fade interval.",      (char *)"Prints current refresh interval."};
#line 316 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_action.c"
static char shortopts[120]  = {      (char )'\000'};
#line 314 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_action.c"
char *gom_action_shortopts(void) 
{ 
  char shortopts_copy[120] ;
  unsigned int tmp ;
  int i ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 317
  shortopts_copy[0] = (char )'\000';
#line 317
  tmp = 1U;
  {
#line 317
  while (1) {
    while_continue: /* CIL Label */ ;
#line 317
    if (tmp >= 120U) {
#line 317
      goto while_break;
    }
#line 317
    shortopts_copy[tmp] = (char)0;
#line 317
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 320
  strcpy((char */* __restrict  */)(shortopts), (char const   */* __restrict  */)"");
#line 321
  i = 0;
  }
  {
#line 321
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 321
    if (! ((unsigned long )gom_options[i].name != (unsigned long )((void *)0))) {
#line 321
      goto while_break___0;
    }
    {
#line 323
    strcpy((char */* __restrict  */)(shortopts_copy), (char const   */* __restrict  */)(shortopts));
    }
#line 324
    if (gom_options[i].has_arg == 2) {
#line 324
      tmp___1 = "::";
    } else {
#line 324
      if (gom_options[i].has_arg == 1) {
#line 324
        tmp___0 = ":";
      } else {
#line 324
        tmp___0 = "";
      }
#line 324
      tmp___1 = tmp___0;
    }
    {
#line 324
    snprintf((char */* __restrict  */)(shortopts), (size_t )120, (char const   */* __restrict  */)"%s%c%s",
             shortopts_copy, gom_options[i].val, tmp___1);
#line 321
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 328
  return (shortopts);
}
}
#line 332 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_action.c"
char gom_action_shortopt(char *longopt ) 
{ 
  int i ;
  int tmp ;

  {
#line 336
  i = 0;
  {
#line 336
  while (1) {
    while_continue: /* CIL Label */ ;
#line 336
    if (! ((unsigned long )gom_options[i].name != (unsigned long )((void *)0))) {
#line 336
      goto while_break;
    }
    {
#line 338
    tmp = strcmp(gom_options[i].name, (char const   *)longopt);
    }
#line 338
    if (tmp == 0) {
#line 339
      return ((char )gom_options[i].val);
    }
#line 336
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 341
  return ((char)-1);
}
}
#line 344 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_action.c"
int gom_action_getopt(int argc , char * const  *argv ) 
{ 
  int action ;
  int option_index ;
  char *tmp ;

  {
  {
#line 346
  action = -1;
#line 350
  tmp = gom_action_shortopts();
#line 350
  action = getopt_long(argc, argv, (char const   *)tmp, (struct option  const  *)(gom_options),
                       & option_index);
  }
#line 355
  return (action);
}
}
#line 364 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_action.c"
void gom_action_version(enum gom_info_types std_verb ) 
{ 


  {
  {
#line 366
  gom_info(std_verb, (char *)"gom 0.30.2 (31 May 2004)");
  }
#line 367
  return;
}
}
#line 369 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_action.c"
void gom_action_license(enum gom_info_types std_verb ) 
{ 
  char *license_text[23] ;

  {
  {
#line 371
  license_text[0] = (char *)"";
#line 371
  license_text[1] = (char *)"Copyright/Licence";
#line 371
  license_text[2] = (char *)"-----------------";
#line 371
  license_text[3] = (char *)"";
#line 371
  license_text[4] = (char *)"  GOM, Gom is nOt yet another Mixer";
#line 371
  license_text[5] = (char *)"  gom 0.30.2 (31 May 2004)";
#line 371
  license_text[6] = (char *)"  Copyright (c) 1996-2004 Stephan Alexander S\374rken <absurd@olurdix.de> GPL.";
#line 371
  license_text[7] = (char *)"  Compile time: Mar  3 2016 22:50:55";
#line 371
  license_text[8] = (char *)"";
#line 371
  license_text[9] = (char *)"  This program is free software; you can redistribute it and/or modify";
#line 371
  license_text[10] = (char *)"  it under the terms of the GNU General Public License as published by";
#line 371
  license_text[11] = (char *)"  the Free Software Foundation; either version 2 of the License, or";
#line 371
  license_text[12] = (char *)"  (at your option) any later version.";
#line 371
  license_text[13] = (char *)"  ";
#line 371
  license_text[14] = (char *)"  This program is distributed in the hope that it will be useful,";
#line 371
  license_text[15] = (char *)"  but WITHOUT ANY WARRANTY; without even the implied warranty of";
#line 371
  license_text[16] = (char *)"  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the";
#line 371
  license_text[17] = (char *)"  GNU General Public License for more details.";
#line 371
  license_text[18] = (char *)"  ";
#line 371
  license_text[19] = (char *)"  You should have received a copy of the GNU General Public License";
#line 371
  license_text[20] = (char *)"  along with this program; if not, write to the Free Software";
#line 371
  license_text[21] = (char *)"  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.";
#line 371
  license_text[22] = (char *)((void *)0);
#line 397
  gom_info_text(std_verb, license_text);
  }
#line 398
  return;
}
}
#line 402 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_action.c"
void gom_help_option(enum gom_info_types std_verb , int *option ) 
{ 
  char line[70] ;
  char line_copy[70] ;
  int i ;

  {
  {
#line 409
  snprintf((char */* __restrict  */)(line), (size_t )70, (char const   */* __restrict  */)"    -%c",
           gom_options[*option].val);
#line 411
  i = *option;
  }
  {
#line 411
  while (1) {
    while_continue: /* CIL Label */ ;
#line 411
    if (! (gom_options[i].val == gom_options[*option].val)) {
#line 411
      goto while_break;
    }
    {
#line 413
    strcpy((char */* __restrict  */)(line_copy), (char const   */* __restrict  */)(line));
#line 414
    snprintf((char */* __restrict  */)(line), (size_t )70, (char const   */* __restrict  */)"%s, --%s",
             line_copy, gom_options[i].name);
#line 411
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 416
  i --;
#line 416
  *option = i;
  {
#line 421
  if (gom_options[i].has_arg == 0) {
#line 421
    goto case_0;
  }
#line 423
  if (gom_options[i].has_arg == 1) {
#line 423
    goto case_1;
  }
#line 427
  if (gom_options[i].has_arg == 2) {
#line 427
    goto case_2;
  }
#line 431
  goto switch_default;
  case_0: /* CIL Label */ 
#line 422
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 424
  strcpy((char */* __restrict  */)(line_copy), (char const   */* __restrict  */)(line));
#line 425
  snprintf((char */* __restrict  */)(line), (size_t )70, (char const   */* __restrict  */)"%s <argument>",
           line_copy);
  }
#line 426
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 428
  strcpy((char */* __restrict  */)(line_copy), (char const   */* __restrict  */)(line));
#line 429
  snprintf((char */* __restrict  */)(line), (size_t )70, (char const   */* __restrict  */)"%s [<argument>]",
           line_copy);
  }
#line 430
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 432
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 435
  gom_info(std_verb, line);
  }
#line 437
  if (gom_options_help[i]) {
    {
#line 438
    gom_info_block((enum gom_info_types )((int )std_verb + 1), 8, gom_options_help[i]);
    }
  }
#line 439
  return;
}
}
#line 442 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_action.c"
void gom_action_help(enum gom_info_types std_verb ) 
{ 
  int i ;
  char *help_text___0[6] ;

  {
#line 445
  help_text___0[0] = (char *)"";
#line 445
  help_text___0[1] = (char *)"Help on command line options";
#line 445
  help_text___0[2] = (char *)"----------------------------";
#line 445
  help_text___0[3] = (char *)"";
#line 445
  help_text___0[4] = (char *)"  Usage: gom {OPTION}";
#line 445
  help_text___0[5] = (char *)((void *)0);
#line 455
  if ((unsigned long )gom_action_help_special_var != (unsigned long )((void *)0)) {
    {
#line 457
    gom_info_text(std_verb, (char **)gom_action_help_special_var);
    }
  }
  {
#line 459
  gom_info_text(std_verb, help_text___0);
#line 466
  gom_info((enum gom_info_types )((int )std_verb + 1), (char *)"");
#line 467
  gom_info_block((enum gom_info_types )((int )std_verb + 1), 4, (char *)"Options can be given in arbitrary order or amount; they are computed in sequence from left to right. Default values (if any), are given in []. For boolean arguments, \"1\" means on, \"0\" means off.");
#line 473
  gom_info((enum gom_info_types )((int )std_verb + 1), (char *)"");
#line 474
  gom_info_block((enum gom_info_types )((int )std_verb + 1), 4, (char *)"Note that for options with _optional_ arguments, these must be given like \"gom -G<file>\" (or \"gom --get-settings=<file>\" resp.) rather than \"gom -G <file>\" (or \"gom --get-settings <file>\" resp.). Otherwise, they will be ignored (or, at least with my implementation of getopt;).");
#line 480
  i = 0;
  }
  {
#line 480
  while (1) {
    while_continue: /* CIL Label */ ;
#line 480
    if (! ((unsigned long )gom_options[i].name != (unsigned long )((void *)0))) {
#line 480
      goto while_break;
    }
    {
#line 490
    if (gom_options[i].val == 89) {
#line 490
      goto case_89;
    }
#line 490
    if (gom_options[i].val == 101) {
#line 490
      goto case_89;
    }
#line 490
    if (gom_options[i].val == 116) {
#line 490
      goto case_89;
    }
#line 490
    if (gom_options[i].val == 71) {
#line 490
      goto case_89;
    }
#line 490
    if (gom_options[i].val == 108) {
#line 490
      goto case_89;
    }
#line 490
    if (gom_options[i].val == 100) {
#line 490
      goto case_89;
    }
#line 493
    goto switch_default;
    case_89: /* CIL Label */ 
    case_101: /* CIL Label */ 
    case_116: /* CIL Label */ 
    case_71: /* CIL Label */ 
    case_108: /* CIL Label */ 
    case_100: /* CIL Label */ 
    {
#line 491
    gom_info(std_verb, (char *)"");
    }
#line 492
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 494
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 499
    if (gom_options[i].val == 100) {
#line 499
      goto case_100___0;
    }
#line 502
    if (gom_options[i].val == 108) {
#line 502
      goto case_108___0;
    }
#line 505
    if (gom_options[i].val == 71) {
#line 505
      goto case_71___0;
    }
#line 508
    if (gom_options[i].val == 116) {
#line 508
      goto case_116___0;
    }
#line 511
    if (gom_options[i].val == 101) {
#line 511
      goto case_101___0;
    }
#line 514
    if (gom_options[i].val == 89) {
#line 514
      goto case_89___0;
    }
#line 517
    goto switch_default___0;
    case_100___0: /* CIL Label */ 
    {
#line 500
    gom_info(std_verb, (char *)"  Configuring options:");
    }
#line 501
    goto switch_break___0;
    case_108___0: /* CIL Label */ 
    {
#line 503
    gom_info(std_verb, (char *)"  Setting mixer options:");
    }
#line 504
    goto switch_break___0;
    case_71___0: /* CIL Label */ 
    {
#line 506
    gom_info(std_verb, (char *)"  Mixer settings options:");
    }
#line 507
    goto switch_break___0;
    case_116___0: /* CIL Label */ 
    {
#line 509
    gom_info(std_verb, (char *)"  Informational options:");
    }
#line 510
    goto switch_break___0;
    case_101___0: /* CIL Label */ 
    {
#line 512
    gom_info(std_verb, (char *)"  Special options:");
    }
#line 513
    goto switch_break___0;
    case_89___0: /* CIL Label */ 
    {
#line 515
    gom_info(std_verb, (char *)"  Command line only options:");
    }
#line 516
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 518
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
    {
#line 520
    gom_help_option(std_verb, & i);
#line 480
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 522
  if ((int )std_verb > 0) {
    {
#line 524
    gom_info(std_verb, (char *)"");
#line 525
    gom_info(std_verb, (char *)"`gom --help-verbose\' might give more information.");
    }
  }
#line 527
  return;
}
}
#line 529 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_action.c"
void gom_action_help_special_set(char **help_text___0 ) 
{ 


  {
#line 531
  gom_action_help_special_var = (void *)help_text___0;
#line 532
  return;
}
}
#line 539 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_action.c"
void gom_info_info_help(enum gom_info_types std_verb , int c , int put_info ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;

  {
#line 542
  if (put_info) {
    {
#line 544
    gom_info(std_verb, (char *)"");
#line 545
    gom_info(std_verb, (char *)"Current channel information");
#line 546
    gom_info(std_verb, (char *)"---------------------------");
#line 547
    gom_info(std_verb, (char *)"");
#line 548
    gom_info(std_verb, (char *)"    No Name       Rec  Volumes  Vol-0  Vol-1  Locked");
    }
  }
  {
#line 551
  tmp = gom_mixer_c_l(c);
#line 551
  tmp___0 = gom_driver_c_c_v(c, 1);
#line 551
  tmp___1 = gom_driver_c_c_v(c, 0);
#line 551
  tmp___2 = gom_driver_c_c_len(c);
#line 551
  tmp___3 = gom_driver_c_r(c);
#line 551
  tmp___4 = gom_driver_C_name((unsigned int )c, 0);
#line 551
  gom_info(std_verb, (char *)"    %2d.%-10s %2d     %2d      %3d    %3d    %2d", c,
           tmp___4, tmp___3, tmp___2, tmp___1, tmp___0, tmp);
  }
#line 559
  return;
}
}
#line 561 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_action.c"
void gom_action_current_channel_info(enum gom_info_types std_verb ) 
{ 
  int tmp ;

  {
  {
#line 563
  tmp = gom_mixer_c_current();
#line 563
  gom_info_info_help(std_verb, tmp, 1);
  }
#line 564
  return;
}
}
#line 566 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_action.c"
void gom_action_overall_info(enum gom_info_types std_verb ) 
{ 
  int c ;
  char *runtime_text[5] ;
  char *tmp ;
  int tmp___0 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 569
  runtime_text[0] = (char *)"";
#line 569
  runtime_text[1] = (char *)"Overall information";
#line 569
  runtime_text[2] = (char *)"-------------------";
#line 569
  runtime_text[3] = (char *)"";
#line 569
  runtime_text[4] = (char *)((void *)0);
#line 577
  gom_info_text(std_verb, runtime_text);
#line 579
  gom_info(std_verb, (char *)"  Configuration:");
#line 580
  tmp = gom_driver_d();
#line 580
  gom_info(std_verb, (char *)"    Mixer special file: %s.", tmp);
#line 583
  tmp___0 = gom_mixer_fadival();
#line 583
  gom_info(std_verb, (char *)"    Fade duration     : %d seconds.", tmp___0);
#line 586
  tmp___3 = gom_gomii_refival();
  }
#line 586
  if (tmp___3 == 0) {
#line 586
    tmp___2 = " (disabled)";
  } else {
#line 586
    tmp___2 = "";
  }
  {
#line 586
  tmp___4 = gom_gomii_refival();
#line 586
  gom_info(std_verb, (char *)"    Gomii refresh     : all %d seconds%s.", tmp___4,
           tmp___2);
#line 590
  tmp___5 = gom_info_verbosity();
#line 590
  gom_info(std_verb, (char *)"    Verbosity         : %i [<=%i:ERROR, %i:QUIET, %i:NORMAL, %i:VERBOSE, >=%i:DEBUG].",
           tmp___5, -1, 0, 1, 2, 3);
#line 594
  gom_info(std_verb, (char *)"    Lock mask         : (see table below).");
#line 596
  gom_info(std_verb, (char *)"    Errors detected   : %i.", gom_info_errors);
#line 600
  gom_info(std_verb, (char *)"");
#line 601
  gom_info(std_verb, (char *)"  Current mixer information:");
#line 602
  tmp___6 = gom_driver();
#line 602
  gom_info(std_verb, (char *)"    Driver used       : %s", tmp___6);
#line 605
  tmp___7 = gom_driver_C_len();
#line 605
  tmp___8 = gom_driver_c_len();
#line 605
  gom_info(std_verb, (char *)"    Available channels: %d / %d", tmp___8, tmp___7);
#line 609
  gom_info(std_verb, (char *)"    ------------------------------------------------");
#line 610
  gom_info(std_verb, (char *)"    No Name       Rec  Volumes  Vol-0  Vol-1  Locked");
#line 611
  gom_info(std_verb, (char *)"    ------------------------------------------------");
#line 613
  c = gom_driver_c_first();
  }
  {
#line 613
  while (1) {
    while_continue: /* CIL Label */ ;
#line 613
    if (! (c > -1)) {
#line 613
      goto while_break;
    }
    {
#line 615
    gom_info_info_help(std_verb, c, 0);
#line 613
    c = gom_driver_c_next(c, 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 617
  gom_info(std_verb, (char *)"    ------------------------------------------------");
#line 618
  c = gom_driver_C_first();
  }
  {
#line 618
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 618
    if (! (c > -1)) {
#line 618
      goto while_break___0;
    }
    {
#line 620
    tmp___9 = gom_driver_c(c);
    }
#line 620
    if (! (tmp___9 > -1)) {
      {
#line 620
      gom_info_info_help(std_verb, c, 0);
      }
    }
    {
#line 618
    c = gom_driver_C_next(c, 1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 622
  gom_info(std_verb, (char *)"    ------------------------------------------------");
#line 623
  gom_info(std_verb, (char *)"    -1 = unavailable, 1 = yes (or value), 0 = no (or value), ");
  }
#line 624
  return;
}
}
#line 631 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_action.c"
int gom_action_arg2i(char *str , int *i ) 
{ 
  char const   *tmp ;
  int tmp___0 ;

  {
#line 633
  if (str) {
    {
#line 633
    tmp___0 = sscanf((char const   */* __restrict  */)str, (char const   */* __restrict  */)"%d",
                     i);
    }
#line 633
    if (1 == tmp___0) {
#line 634
      return (1);
    } else {
#line 633
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 637
    if (str) {
#line 637
      tmp = (char const   *)str;
    } else {
#line 637
      tmp = "<NULL>";
    }
    {
#line 637
    gom_info((enum gom_info_types )-1, (char *)"Option argument \"%s\" ignored: can\'t convert properly into integer.",
             tmp);
    }
#line 640
    return (0);
  }
}
}
#line 645 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_action.c"
int gom_action_arg2v(char *str , int old_v , int *v ) 
{ 
  int tmp ;

  {
  {
#line 647
  tmp = gom_action_arg2i(str, v);
  }
#line 647
  if (tmp) {
#line 649
    if ((int )*str == 43) {
#line 650
      *v += old_v;
    } else
#line 649
    if ((int )*str == 45) {
#line 650
      *v += old_v;
    }
#line 651
    return (1);
  } else {
#line 654
    return (0);
  }
}
}
#line 661 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_action.c"
enum gom_gomii_refresh_stage gom_action(enum gom_info_types std_verb , char action ,
                                        int cmd_line , char *(*get_option_arg)(char * ) ,
                                        void (*pre_scroll)() , void (*post_scroll)() ) 
{ 
  int new_int ;
  int c ;
  int cc ;
  char *local_optarg ;
  int execute_err ;
  enum gom_gomii_refresh_stage stage ;
  int tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  char *tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  char *tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  char *tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  char *tmp___33 ;
  char *tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  char *tmp___39 ;
  char *tmp___40 ;
  int tmp___41 ;
  char *tmp___42 ;
  int tmp___43 ;
  char *tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;

  {
#line 670
  stage = (enum gom_gomii_refresh_stage )4;
  {
#line 674
  if ((int )action == 100) {
#line 674
    goto case_100;
  }
#line 686
  if ((int )action == 99) {
#line 686
    goto case_99;
  }
#line 704
  if ((int )action == 67) {
#line 704
    goto case_67;
  }
#line 710
  if ((int )action == 107) {
#line 710
    goto case_107;
  }
#line 716
  if ((int )action == 75) {
#line 716
    goto case_75;
  }
#line 725
  if ((int )action == 70) {
#line 725
    goto case_70;
  }
#line 732
  if ((int )action == 85) {
#line 732
    goto case_85;
  }
#line 741
  if ((int )action == 87) {
#line 741
    goto case_87;
  }
#line 747
  if ((int )action == 108) {
#line 747
    goto case_108;
  }
#line 757
  if ((int )action == 114) {
#line 757
    goto case_114;
  }
#line 764
  if ((int )action == 82) {
#line 764
    goto case_82;
  }
#line 770
  if ((int )action == 76) {
#line 770
    goto case_76;
  }
#line 780
  if ((int )action == 109) {
#line 780
    goto case_109;
  }
#line 785
  if ((int )action == 77) {
#line 785
    goto case_77;
  }
#line 790
  if ((int )action == 71) {
#line 790
    goto case_71;
  }
#line 797
  if ((int )action == 83) {
#line 797
    goto case_83;
  }
#line 803
  if ((int )action == 122) {
#line 803
    goto case_122;
  }
#line 808
  if ((int )action == 90) {
#line 808
    goto case_90;
  }
#line 814
  if ((int )action == 79) {
#line 814
    goto case_79;
  }
#line 825
  if ((int )action == 72) {
#line 825
    goto case_72;
  }
#line 825
  if ((int )action == 104) {
#line 825
    goto case_72;
  }
#line 825
  if ((int )action == 119) {
#line 825
    goto case_72;
  }
#line 825
  if ((int )action == 86) {
#line 825
    goto case_72;
  }
#line 825
  if ((int )action == 84) {
#line 825
    goto case_72;
  }
#line 825
  if ((int )action == 116) {
#line 825
    goto case_72;
  }
#line 857
  if ((int )action == 101) {
#line 857
    goto case_101;
  }
#line 877
  if ((int )action == 12) {
#line 877
    goto case_12;
  }
#line 882
  goto switch_default___0;
  case_100: /* CIL Label */ 
  {
#line 676
  local_optarg = (*get_option_arg)((char *)"New mixer device? ");
#line 677
  tmp = gom_driver_d_set(std_verb, local_optarg);
  }
#line 677
  if (tmp) {
    {
#line 679
    gom_mixer_d_defaults_set((enum gom_info_types )((int )std_verb + 1));
#line 680
    stage = (enum gom_gomii_refresh_stage )1;
    }
  } else {
#line 683
    stage = (enum gom_gomii_refresh_stage )0;
  }
#line 684
  goto switch_break;
  case_99: /* CIL Label */ 
  {
#line 688
  local_optarg = (*get_option_arg)((char *)"New current channel? ");
#line 690
  tmp___1 = __ctype_b_loc();
  }
#line 690
  if ((int const   )*(*tmp___1 + (int )*local_optarg) & 2048) {
    {
#line 690
    tmp___2 = gom_action_arg2i(local_optarg, & new_int);
    }
#line 690
    if (tmp___2) {
      {
#line 693
      gom_mixer_c_current_set(std_verb, new_int);
      }
    } else {
      {
#line 698
      tmp___0 = gom_mixer_C_find(local_optarg);
#line 698
      gom_mixer_c_current_set(std_verb, tmp___0);
      }
    }
  } else {
    {
#line 698
    tmp___0 = gom_mixer_C_find(local_optarg);
#line 698
    gom_mixer_c_current_set(std_verb, tmp___0);
    }
  }
#line 701
  stage = (enum gom_gomii_refresh_stage )3;
#line 702
  goto switch_break;
  case_67: /* CIL Label */ 
  {
#line 706
  tmp___3 = (*get_option_arg)((char *)"New current volume channel? ");
#line 706
  tmp___4 = gom_action_arg2i(tmp___3, & new_int);
  }
#line 706
  if (tmp___4) {
    {
#line 707
    gom_mixer_c_c_current_set(std_verb, new_int);
    }
  }
#line 708
  goto switch_break;
  case_107: /* CIL Label */ 
  {
#line 712
  tmp___6 = (*get_option_arg)((char *)"Lock current channel (0|1)? ");
#line 712
  tmp___7 = gom_action_arg2i(tmp___6, & new_int);
  }
#line 712
  if (tmp___7) {
    {
#line 713
    tmp___5 = gom_mixer_c_current();
#line 713
    gom_mixer_c_l_set(std_verb, tmp___5, new_int);
    }
  }
#line 714
  goto switch_break;
  case_75: /* CIL Label */ 
  {
#line 718
  tmp___8 = (*get_option_arg)((char *)"Lock all channels (0|1)? ");
#line 718
  tmp___9 = gom_action_arg2i(tmp___8, & new_int);
  }
#line 718
  if (tmp___9) {
    {
#line 720
    gom_mixer_l_set(std_verb, new_int);
#line 721
    stage = (enum gom_gomii_refresh_stage )3;
    }
  }
#line 723
  goto switch_break;
  case_70: /* CIL Label */ 
  {
#line 727
  tmp___10 = (*get_option_arg)((char *)"New fade interval? ");
#line 727
  tmp___11 = gom_action_arg2i(tmp___10, & new_int);
  }
#line 727
  if (tmp___11) {
    {
#line 728
    gom_mixer_fadival_set(std_verb, new_int);
    }
  }
#line 729
  stage = (enum gom_gomii_refresh_stage )0;
#line 730
  goto switch_break;
  case_85: /* CIL Label */ 
  {
#line 734
  tmp___12 = (*get_option_arg)((char *)"New gomii refresh interval? ");
#line 734
  tmp___13 = gom_action_arg2i(tmp___12, & new_int);
  }
#line 734
  if (tmp___13) {
    {
#line 735
    gom_gomii_refival_set(std_verb, new_int, & gom_gomii_refproc_keep);
    }
  }
#line 738
  stage = (enum gom_gomii_refresh_stage )0;
#line 739
  goto switch_break;
  case_87: /* CIL Label */ 
  {
#line 743
  gom_info((enum gom_info_types )-1, (char *)"Since version 0.29.10, automatic saving of configuration is no longer possible (edit it by hand!).");
#line 744
  stage = (enum gom_gomii_refresh_stage )0;
  }
#line 745
  goto switch_break;
  case_108: /* CIL Label */ 
  {
#line 749
  tmp___16 = gom_mixer_c_c_current();
#line 749
  tmp___17 = gom_mixer_c_current();
#line 749
  tmp___18 = gom_driver_c_c_v(tmp___17, tmp___16);
#line 749
  tmp___19 = (*get_option_arg)((char *)"New volume? ");
#line 749
  tmp___20 = gom_action_arg2v(tmp___19, tmp___18, & new_int);
  }
#line 749
  if (tmp___20) {
    {
#line 752
    tmp___14 = gom_mixer_c_c_current();
#line 752
    tmp___15 = gom_mixer_c_current();
#line 752
    gom_mixer_c_c_v_set_l(std_verb, tmp___15, tmp___14, new_int);
    }
  }
#line 755
  goto switch_break;
  case_114: /* CIL Label */ 
  {
#line 759
  tmp___22 = (*get_option_arg)((char *)"Make channel recording source (0,1)? ");
#line 759
  tmp___23 = gom_action_arg2i(tmp___22, & new_int);
  }
#line 759
  if (tmp___23) {
    {
#line 760
    tmp___21 = gom_mixer_c_current();
#line 760
    gom_driver_c_r_set(std_verb, tmp___21, new_int);
    }
  }
#line 762
  goto switch_break;
  case_82: /* CIL Label */ 
  {
#line 766
  tmp___24 = gom_mixer_c_current();
#line 766
  gom_mixer_c_r_set_single(std_verb, tmp___24);
#line 767
  stage = (enum gom_gomii_refresh_stage )3;
  }
#line 768
  goto switch_break;
  case_76: /* CIL Label */ 
  {
#line 772
  tmp___27 = gom_mixer_c_c_current();
#line 772
  tmp___28 = gom_mixer_c_current();
#line 772
  tmp___29 = gom_driver_c_c_v(tmp___28, tmp___27);
#line 772
  tmp___30 = (*get_option_arg)((char *)"New volume to fade to? ");
#line 772
  tmp___31 = gom_action_arg2v(tmp___30, tmp___29, & new_int);
  }
#line 772
  if (tmp___31) {
    {
#line 775
    tmp___25 = gom_mixer_c_c_current();
#line 775
    tmp___26 = gom_mixer_c_current();
#line 775
    gom_mixer_c_c_v_fade_l(std_verb, tmp___26, tmp___25, new_int);
    }
  }
#line 778
  goto switch_break;
  case_109: /* CIL Label */ 
  {
#line 782
  tmp___32 = gom_mixer_c_current();
#line 782
  gom_mixer_c_mute(std_verb, tmp___32);
  }
#line 784
  goto switch_break;
  case_77: /* CIL Label */ 
  {
#line 786
  gom_mixer_mute(std_verb);
#line 787
  stage = (enum gom_gomii_refresh_stage )3;
  }
#line 788
  goto switch_break;
  case_71: /* CIL Label */ 
  {
#line 792
  tmp___33 = (*get_option_arg)((char *)"Option file to load from [default]? ");
#line 792
  gom_file_load(std_verb, tmp___33, 1, (char *)((void *)0));
#line 795
  stage = (enum gom_gomii_refresh_stage )3;
  }
#line 796
  goto switch_break;
  case_83: /* CIL Label */ 
  {
#line 799
  tmp___34 = (*get_option_arg)((char *)"Save settings as options file to [default]? ");
#line 799
  gom_file_settings_save(std_verb, tmp___34);
#line 800
  stage = (enum gom_gomii_refresh_stage )0;
  }
#line 801
  goto switch_break;
  case_122: /* CIL Label */ 
  {
#line 805
  gom_mixer_snapshot(std_verb);
#line 806
  stage = (enum gom_gomii_refresh_stage )0;
  }
#line 807
  goto switch_break;
  case_90: /* CIL Label */ 
  {
#line 810
  gom_mixer_unsnapshot(std_verb);
#line 811
  stage = (enum gom_gomii_refresh_stage )3;
  }
#line 812
  goto switch_break;
  case_79: /* CIL Label */ 
  {
#line 816
  gom_file_load(std_verb, (char *)"initialize", 0, (char *)((void *)0));
#line 817
  stage = (enum gom_gomii_refresh_stage )1;
  }
#line 818
  goto switch_break;
  case_72: /* CIL Label */ 
  case_104: /* CIL Label */ 
  case_119: /* CIL Label */ 
  case_86: /* CIL Label */ 
  case_84: /* CIL Label */ 
  case_116: /* CIL Label */ 
#line 826
  if ((unsigned long )pre_scroll != (unsigned long )((void *)0)) {
    {
#line 826
    (*pre_scroll)();
    }
  }
  {
#line 829
  if ((int )action == 116) {
#line 829
    goto case_116___0;
  }
#line 832
  if ((int )action == 84) {
#line 832
    goto case_84___0;
  }
#line 835
  if ((int )action == 86) {
#line 835
    goto case_86___0;
  }
#line 838
  if ((int )action == 119) {
#line 838
    goto case_119___0;
  }
#line 841
  if ((int )action == 104) {
#line 841
    goto case_104___0;
  }
#line 844
  if ((int )action == 72) {
#line 844
    goto case_72___0;
  }
#line 848
  goto switch_default;
  case_116___0: /* CIL Label */ 
  {
#line 830
  gom_action_current_channel_info(std_verb);
  }
#line 831
  goto switch_break___0;
  case_84___0: /* CIL Label */ 
  {
#line 833
  gom_action_overall_info(std_verb);
  }
#line 834
  goto switch_break___0;
  case_86___0: /* CIL Label */ 
  {
#line 836
  gom_action_version(std_verb);
  }
#line 837
  goto switch_break___0;
  case_119___0: /* CIL Label */ 
  {
#line 839
  gom_action_license(std_verb);
  }
#line 840
  goto switch_break___0;
  case_104___0: /* CIL Label */ 
  {
#line 842
  gom_action_help(std_verb);
  }
#line 843
  goto switch_break___0;
  case_72___0: /* CIL Label */ 
  {
#line 846
  gom_action_help((enum gom_info_types )0);
  }
#line 847
  goto switch_break___0;
  switch_default: /* CIL Label */ 
#line 849
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 851
  if ((unsigned long )post_scroll != (unsigned long )((void *)0)) {
    {
#line 851
    (*post_scroll)();
    }
  }
#line 852
  stage = (enum gom_gomii_refresh_stage )2;
#line 853
  goto switch_break;
  case_101: /* CIL Label */ 
  {
#line 859
  local_optarg = (*get_option_arg)((char *)"System command to execute? ");
#line 860
  gom_info(std_verb, (char *)"Executing shell command \"%s\".", local_optarg);
#line 862
  execute_err = system((char const   *)local_optarg);
  }
#line 863
  if (execute_err != 0) {
    {
#line 864
    gom_info((enum gom_info_types )-1, (char *)"Shell command \"%s\" returned with error code %i.",
             local_optarg, execute_err);
    }
  } else {
    {
#line 868
    gom_info(std_verb, (char *)"Shell command \"%s\" successfully finished.", local_optarg);
    }
  }
#line 872
  stage = (enum gom_gomii_refresh_stage )0;
#line 873
  goto switch_break;
  case_12: /* CIL Label */ 
#line 879
  stage = (enum gom_gomii_refresh_stage )1;
#line 880
  goto switch_break;
  switch_default___0: /* CIL Label */ 
#line 883
  if (cmd_line) {
    {
#line 888
    if ((int )action == 89) {
#line 888
      goto case_89;
    }
#line 892
    if ((int )action == 105) {
#line 892
      goto case_105;
    }
#line 912
    if ((int )action == 113) {
#line 912
      goto case_113;
    }
#line 917
    if ((int )action == 118) {
#line 917
      goto case_118;
    }
#line 927
    if ((int )action == 120) {
#line 927
      goto case_120;
    }
#line 932
    if ((int )action == 73) {
#line 932
      goto case_73;
    }
#line 940
    if ((int )action == 49) {
#line 940
      goto case_49;
    }
#line 945
    if ((int )action == 50) {
#line 945
      goto case_50;
    }
#line 951
    if ((int )action == 51) {
#line 951
      goto case_51;
    }
#line 956
    if ((int )action == 52) {
#line 956
      goto case_52;
    }
#line 962
    if ((int )action == 53) {
#line 962
      goto case_53;
    }
#line 967
    if ((int )action == 54) {
#line 967
      goto case_54;
    }
#line 972
    if ((int )action == 55) {
#line 972
      goto case_55;
    }
#line 979
    if ((int )action == 56) {
#line 979
      goto case_56;
    }
#line 984
    if ((int )action == 57) {
#line 984
      goto case_57;
    }
#line 989
    if ((int )action == 48) {
#line 989
      goto case_48;
    }
#line 994
    if ((int )action == 97) {
#line 994
      goto case_97;
    }
#line 999
    if ((int )action == 65) {
#line 999
      goto case_65;
    }
#line 1007
    if ((int )action == 63) {
#line 1007
      goto case_63;
    }
#line 1013
    goto switch_default___1;
    case_89: /* CIL Label */ 
    {
#line 890
    gom_info((enum gom_info_types )-1, (char *)"Y is ignored here; it must be given before any other option (except q or v).");
    }
#line 891
    goto switch_break___1;
    case_105: /* CIL Label */ 
    {
#line 894
    local_optarg = (*get_option_arg)((char *)"Gomii to start (t|i)? ");
#line 896
    tmp___36 = strcmp((char const   *)local_optarg, "t");
    }
#line 896
    if (tmp___36 == 0) {
      {
#line 898
      gom_iface_t();
      }
    } else {
      {
#line 900
      tmp___35 = strcmp((char const   *)local_optarg, "x");
      }
#line 900
      if (tmp___35 == 0) {
        {
#line 905
        gom_info((enum gom_info_types )-1, (char *)"This binary of gom hasn\'t the X gomii compiled in.");
        }
      } else {
        {
#line 909
        gom_info((enum gom_info_types )-1, (char *)"Unknown gomii shorthand: %s.",
                 local_optarg);
        }
      }
    }
#line 910
    goto switch_break___1;
    case_113: /* CIL Label */ 
    {
#line 914
    gom_info_verbosity_set((enum gom_info_types )1, 0);
    }
#line 915
    goto switch_break___1;
    case_118: /* CIL Label */ 
    {
#line 919
    local_optarg = (*get_option_arg)((char *)"New verbosity level? ");
    }
#line 921
    if (local_optarg) {
      {
#line 922
      tmp___37 = atoi((char const   *)local_optarg);
#line 922
      gom_info_verbosity_set((enum gom_info_types )1, tmp___37);
      }
    } else {
      {
#line 924
      tmp___38 = gom_info_verbosity();
#line 924
      gom_info_verbosity_set((enum gom_info_types )1, tmp___38 + 1);
      }
    }
#line 925
    goto switch_break___1;
    case_120: /* CIL Label */ 
    {
#line 929
    gom_file_settings_write(stdout, 0);
    }
#line 930
    goto switch_break___1;
    case_73: /* CIL Label */ 
    {
#line 934
    gom_file_options_read((enum gom_info_types )1, stdin, (char *)((void *)0));
    }
#line 935
    goto switch_break___1;
    case_49: /* CIL Label */ 
    {
#line 942
    tmp___39 = gom_driver();
#line 942
    printf((char const   */* __restrict  */)"%s", tmp___39);
    }
#line 943
    goto switch_break___1;
    case_50: /* CIL Label */ 
    {
#line 947
    c = gom_driver_C_first();
    }
    {
#line 947
    while (1) {
      while_continue: /* CIL Label */ ;
#line 947
      if (! (c > -1)) {
#line 947
        goto while_break;
      }
      {
#line 948
      printf((char const   */* __restrict  */)"%d ", c);
#line 947
      c = gom_driver_C_next(c, 1);
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 949
    goto switch_break___1;
    case_51: /* CIL Label */ 
    {
#line 953
    tmp___40 = gom_driver_d();
#line 953
    printf((char const   */* __restrict  */)"%s", tmp___40);
    }
#line 954
    goto switch_break___1;
    case_52: /* CIL Label */ 
    {
#line 958
    c = gom_driver_c_first();
    }
    {
#line 958
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 958
      if (! (c > -1)) {
#line 958
        goto while_break___0;
      }
      {
#line 959
      printf((char const   */* __restrict  */)"%d ", c);
#line 958
      c = gom_driver_c_next(c, 1);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 960
    goto switch_break___1;
    case_53: /* CIL Label */ 
    {
#line 964
    tmp___41 = gom_mixer_c_current();
#line 964
    tmp___42 = gom_driver_c_name(tmp___41, 0);
#line 964
    printf((char const   */* __restrict  */)"%s", tmp___42);
    }
#line 965
    goto switch_break___1;
    case_54: /* CIL Label */ 
    {
#line 969
    tmp___43 = gom_mixer_c_current();
#line 969
    tmp___44 = gom_driver_c_name(tmp___43, 1);
#line 969
    printf((char const   */* __restrict  */)"%s", tmp___44);
    }
#line 970
    goto switch_break___1;
    case_55: /* CIL Label */ 
    {
#line 974
    tmp___45 = gom_mixer_c_current();
#line 974
    cc = gom_driver_c_c_first(tmp___45);
    }
    {
#line 974
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 974
      if (! (cc > -1)) {
#line 974
        goto while_break___1;
      }
      {
#line 976
      printf((char const   */* __restrict  */)"%d ", cc);
#line 974
      tmp___46 = gom_mixer_c_current();
#line 974
      cc = gom_driver_c_c_next(tmp___46, cc, 1);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 977
    goto switch_break___1;
    case_56: /* CIL Label */ 
    {
#line 981
    tmp___47 = gom_mixer_c_c_current();
#line 981
    tmp___48 = gom_mixer_c_current();
#line 981
    tmp___49 = gom_driver_c_c_v(tmp___48, tmp___47);
#line 981
    printf((char const   */* __restrict  */)"%d", tmp___49);
    }
#line 982
    goto switch_break___1;
    case_57: /* CIL Label */ 
    {
#line 986
    tmp___50 = gom_mixer_c_current();
#line 986
    tmp___51 = gom_driver_c_r(tmp___50);
#line 986
    printf((char const   */* __restrict  */)"%d", tmp___51);
    }
#line 987
    goto switch_break___1;
    case_48: /* CIL Label */ 
    {
#line 991
    tmp___52 = gom_mixer_c_current();
#line 991
    tmp___53 = gom_mixer_c_l(tmp___52);
#line 991
    printf((char const   */* __restrict  */)"%d", tmp___53);
    }
#line 992
    goto switch_break___1;
    case_97: /* CIL Label */ 
    {
#line 996
    tmp___54 = gom_mixer_fadival();
#line 996
    printf((char const   */* __restrict  */)"%d", tmp___54);
    }
#line 997
    goto switch_break___1;
    case_65: /* CIL Label */ 
    {
#line 1001
    tmp___55 = gom_gomii_refival();
#line 1001
    printf((char const   */* __restrict  */)"%d", tmp___55);
    }
#line 1002
    goto switch_break___1;
    case_63: /* CIL Label */ 
    {
#line 1009
    gom_info((enum gom_info_types )-1, (char *)"Bad command line option syntax.");
#line 1010
    gom_info((enum gom_info_types )0, (char *)"Try `gom -h, --help, -H, --help-verbose\' or `man gom\' for help.");
    }
#line 1011
    goto switch_break___1;
    switch_default___1: /* CIL Label */ 
#line 1015
    if ((int )action == 0) {
#line 1015
      tmp___56 = ' ';
    } else {
#line 1015
      tmp___56 = (int )action;
    }
    {
#line 1015
    gom_info((enum gom_info_types )-1, (char *)"\"%c\"=%d: Unknown action.", tmp___56,
             (int )action);
#line 1017
    gom_info((enum gom_info_types )0, (char *)"Try `gom -h, --help, -H, --help-verbose\' or `man gom\' for help.");
    }
#line 1018
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
  } else {
#line 1024
    if ((int )action == 0) {
#line 1024
      tmp___57 = ' ';
    } else {
#line 1024
      tmp___57 = (int )action;
    }
    {
#line 1024
    gom_info((enum gom_info_types )-1, (char *)"\"%c\"=%d: Unknown action.", tmp___57,
             (int )action);
#line 1026
    stage = (enum gom_gomii_refresh_stage )0;
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 1029
  return (stage);
}
}
#line 538 "/usr/include/stdio.h"
extern int getchar(void) ;
#line 77 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_driver.h"
int gom_driver_c_last(void) ;
#line 98
int gom_driver_c_c_last(int c ) ;
#line 105
int gom_driver_c_c_v_max(void) ;
#line 587 "/usr/include/curses.h"
extern int cbreak(void) ;
#line 608
extern int echo(void) ;
#line 611
extern int endwin(void) ;
#line 632
extern WINDOW *initscr(void) ;
#line 647
extern int keypad(WINDOW * , _Bool  ) ;
#line 649
extern int leaveok(WINDOW * , _Bool  ) ;
#line 674
extern int mvprintw(int  , int  , char const   *  , ...) ;
#line 711
extern int noecho(void) ;
#line 723
extern int printw(char const   *  , ...) ;
#line 781
extern int vwprintw(WINDOW * , char const   * , va_list  ) ;
#line 801
extern int wclear(WINDOW * ) ;
#line 810
extern int wgetch(WINDOW * ) ;
#line 811
extern int wgetnstr(WINDOW * , char * , int  ) ;
#line 824
extern int wmove(WINDOW * , int  , int  ) ;
#line 829
extern int wrefresh(WINDOW * ) ;
#line 838
extern void wtimeout(WINDOW * , int  ) ;
#line 1386
extern WINDOW *stdscr ;
#line 1390
extern int COLS ;
#line 1392
extern int LINES ;
#line 100 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_iface_t.c"
int gom_iface_t_action_action  ;
#line 101 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_iface_t.c"
int gom_iface_t_is_initialized  =    0;
#line 102 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_iface_t.c"
int gom_iface_t_current_page  =    0;
#line 103 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_iface_t.c"
int gom_iface_t_pages  ;
#line 104 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_iface_t.c"
int gom_iface_t_info_line  ;
#line 109
void gom_iface_t_refresh(void) ;
#line 116 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_iface_t.c"
void gom_iface_t_cntrprintw(int line , char *str ) 
{ 
  size_t tmp ;

  {
  {
#line 118
  tmp = strlen((char const   *)str);
#line 118
  mvprintw(line, (int )(((size_t )COLS - tmp) / 2UL), (char const   *)str);
  }
#line 119
  return;
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_iface_t.c"
void gom_iface_t_filline(int line , char ch ) 
{ 
  int i ;

  {
#line 124
  i = 0;
  {
#line 124
  while (1) {
    while_continue: /* CIL Label */ ;
#line 124
    if (! (i < COLS)) {
#line 124
      goto while_break;
    }
    {
#line 124
    mvprintw(line, i, "%c", (int )ch);
#line 124
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 125
  return;
}
}
#line 127 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_iface_t.c"
void gom_iface_t_seperator_line(int line , char *text ) 
{ 


  {
#line 129
  if (stdscr) {
#line 129
    stdscr->_attrs = 1UL << 21;
  }
  {
#line 130
  gom_iface_t_filline(line, (char )'-');
#line 131
  gom_iface_t_cntrprintw(line, text);
  }
#line 131
  if (stdscr) {
#line 131
    stdscr->_attrs = 0UL;
  }
#line 132
  return;
}
}
#line 134 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_iface_t.c"
void gom_iface_t_clear_cboxes_space(void) 
{ 
  unsigned int c ;

  {
#line 137
  c = 2U;
  {
#line 137
  while (1) {
    while_continue: /* CIL Label */ ;
#line 137
    if (! (c <= (unsigned int )(LINES - 3))) {
#line 137
      goto while_break;
    }
    {
#line 138
    gom_iface_t_filline((int )c, (char )' ');
#line 137
    c ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 139
  return;
}
}
#line 145 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_iface_t.c"
void gom_iface_t_info(enum gom_info_types kind , char *fmt , va_list vargs ) 
{ 
  int tmp ;

  {
  {
#line 147
  tmp = gom_info_scroll();
  }
#line 147
  if (tmp) {
#line 149
    if (gom_iface_t_info_line > LINES - 5) {
      {
#line 151
      gom_iface_t_seperator_line(LINES - 2, (char *)"Press any key for more");
#line 152
      wgetch(stdscr);
#line 153
      gom_iface_t_clear_cboxes_space();
#line 154
      gom_iface_t_info_line = 3;
      }
    } else {
#line 158
      gom_iface_t_info_line ++;
    }
    {
#line 160
    mvprintw(gom_iface_t_info_line, 0, "");
    }
  } else {
    {
#line 165
    gom_iface_t_filline(LINES - 1, (char )' ');
#line 166
    mvprintw(LINES - 1, 0, "");
    }
  }
  {
#line 168
  vwprintw(stdscr, (char const   *)fmt, vargs);
#line 169
  wrefresh(stdscr);
  }
#line 170
  return;
}
}
#line 177
char *gom_iface_t_get_option_arg(char *prompt ) ;
#line 177 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_iface_t.c"
static char option_arg[100]  = {      (char )'\000'};
#line 175 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_iface_t.c"
char *gom_iface_t_get_option_arg(char *prompt ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 181
  if (gom_iface_t_action_action == 114) {
#line 181
    goto case_114;
  }
#line 185
  if (gom_iface_t_action_action == 107) {
#line 185
    goto case_107;
  }
#line 189
  goto switch_default;
  case_114: /* CIL Label */ 
  {
#line 182
  tmp = gom_mixer_c_current();
#line 182
  tmp___0 = gom_driver_c_r(tmp);
  }
#line 182
  if (tmp___0) {
#line 182
    tmp___1 = 0;
  } else {
#line 182
    tmp___1 = 1;
  }
  {
#line 182
  snprintf((char */* __restrict  */)(option_arg), (size_t )100, (char const   */* __restrict  */)"%d",
           tmp___1);
  }
#line 183
  goto switch_break;
  case_107: /* CIL Label */ 
  {
#line 186
  tmp___2 = gom_mixer_c_current();
#line 186
  tmp___3 = gom_mixer_c_l(tmp___2);
  }
#line 186
  if (tmp___3) {
#line 186
    tmp___4 = 0;
  } else {
#line 186
    tmp___4 = 1;
  }
  {
#line 186
  snprintf((char */* __restrict  */)(option_arg), (size_t )100, (char const   */* __restrict  */)"%d",
           tmp___4);
  }
#line 187
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 190
  gom_iface_t_filline(LINES - 1, (char )' ');
#line 191
  mvprintw(LINES - 1, 0, (char const   *)prompt);
#line 194
  tmp___5 = gom_gomii_refival();
#line 194
  gom_gomii_refival_set((enum gom_info_types )3, tmp___5, (void (*)())((void *)0));
#line 196
  leaveok(stdscr, (_Bool)0);
#line 197
  echo();
#line 198
  wgetnstr(stdscr, option_arg, 100);
#line 199
  noecho();
#line 200
  leaveok(stdscr, (_Bool)1);
#line 203
  tmp___6 = gom_gomii_refival();
#line 203
  gom_gomii_refival_set((enum gom_info_types )3, tmp___6, & gom_iface_t_refresh);
#line 205
  gom_iface_t_filline(LINES - 1, (char )' ');
  }
#line 206
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 208
  return (option_arg);
}
}
#line 215 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_iface_t.c"
void gom_iface_t_draw_mask(void) 
{ 


  {
#line 218
  if (stdscr) {
#line 218
    stdscr->_attrs = 1UL << 21;
  }
  {
#line 219
  gom_iface_t_cntrprintw(0, (char *)"GOM, Gom is nOt yet another Mixer");
#line 222
  gom_iface_t_seperator_line(LINES - 2, (char *)"Help: hH----Info: VwtT----Quit: q");
  }
#line 223
  return;
}
}
#line 225 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_iface_t.c"
void gom_iface_t_pre_scroll(void) 
{ 
  int tmp ;

  {
  {
#line 227
  gom_info((enum gom_info_types )1, (char *)"Terminal gomii text scroller");
#line 228
  gom_info_scroll_set(1);
#line 231
  tmp = gom_gomii_refival();
#line 231
  gom_gomii_refival_set((enum gom_info_types )3, tmp, (void (*)())((void *)0));
#line 233
  gom_iface_t_clear_cboxes_space();
#line 234
  gom_iface_t_seperator_line(1, (char *)"Terminal gomii text scroller");
#line 235
  gom_iface_t_info_line = 2;
  }
#line 236
  return;
}
}
#line 238 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_iface_t.c"
void gom_iface_t_post_scroll(void) 
{ 
  int tmp ;

  {
  {
#line 240
  gom_iface_t_seperator_line(LINES - 2, (char *)"Press any key to continue");
#line 240
  wgetch(stdscr);
#line 243
  tmp = gom_gomii_refival();
#line 243
  gom_gomii_refival_set((enum gom_info_types )3, tmp, & gom_iface_t_refresh);
#line 244
  gom_info_scroll_set(0);
#line 245
  gom_info((enum gom_info_types )1, (char *)"Back from scrolling...");
  }
#line 246
  return;
}
}
#line 248 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_iface_t.c"
void gom_iface_t_draw_bline(int line , int col ) 
{ 


  {
  {
#line 250
  mvprintw(line, col, "o---------------------------------o");
  }
#line 251
  return;
}
}
#line 254 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_iface_t.c"
void gom_iface_t_draw_sline(int c , int cc , int volume ) 
{ 
  int i ;
  int per_slider ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  char const   *tmp___28 ;
  int tmp___29 ;
  char const   *tmp___30 ;
  int tmp___31 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;

  {
#line 256
  per_slider = (20 * volume) / 100;
#line 258
  if (stdscr) {
#line 258
    stdscr->_attrs = 0UL;
  }
  {
#line 259
  printw("|");
  }
#line 261
  if (cc == 0) {
#line 261
    goto _L___1;
  } else {
    {
#line 261
    tmp___25 = gom_driver_c_c_len(c);
    }
#line 261
    if (tmp___25 == 2) {
      _L___1: /* CIL Label */ 
      {
#line 263
      tmp = gom_mixer_c_current();
      }
#line 263
      if (tmp == c) {
        {
#line 263
        tmp___0 = gom_mixer_c_c_current();
        }
#line 263
        if (tmp___0 == cc) {
#line 263
          goto _L;
        } else {
          {
#line 263
          tmp___1 = gom_mixer_c_l(c);
          }
#line 263
          if (tmp___1) {
#line 263
            goto _L;
          } else {
            {
#line 263
            tmp___2 = gom_driver_c_c_len(c);
            }
#line 263
            if (tmp___2) {
#line 263
              tmp___3 = 0;
            } else {
#line 263
              tmp___3 = 1;
            }
#line 263
            if (tmp___3 == 2) {
              _L: /* CIL Label */ 
#line 264
              if (stdscr) {
#line 264
                stdscr->_attrs = 1UL << 16;
              }
            }
          }
        }
      }
#line 265
      if (cc == 0) {
#line 265
        tmp___4 = 'L';
      } else {
#line 265
        tmp___4 = 'R';
      }
      {
#line 265
      printw(" %c ", tmp___4);
      }
#line 266
      if (stdscr) {
#line 266
        stdscr->_attrs = 0UL;
      }
      {
#line 268
      tmp___9 = gom_mixer_c_l(c);
      }
#line 268
      if (tmp___9) {
        {
#line 268
        tmp___10 = gom_driver_c_c_len(c);
        }
#line 268
        if (tmp___10 == 2) {
#line 268
          if (cc == 0) {
#line 268
            tmp___7 = '/';
          } else {
#line 268
            tmp___7 = '\\';
          }
#line 268
          tmp___8 = tmp___7;
        } else {
#line 268
          tmp___8 = '[';
        }
      } else {
#line 268
        tmp___8 = '[';
      }
#line 268
      if (volume < 100) {
#line 268
        if (volume < 10) {
#line 268
          tmp___11 = "  ";
        } else {
#line 268
          tmp___11 = " ";
        }
#line 268
        tmp___12 = tmp___11;
      } else {
#line 268
        tmp___12 = "";
      }
      {
#line 268
      printw("%s%d %c", tmp___12, volume, tmp___8);
#line 272
      i = 0;
      }
      {
#line 272
      while (1) {
        while_continue: /* CIL Label */ ;
#line 272
        if (! (i < 20)) {
#line 272
          goto while_break;
        }
#line 273
        if (cc == 1) {
          {
#line 273
          tmp___17 = gom_driver_c_c_len(c);
          }
#line 273
          if (tmp___17) {
#line 273
            tmp___18 = 0;
          } else {
#line 273
            tmp___18 = 1;
          }
#line 273
          if (tmp___18 == 2) {
#line 273
            tmp___16 = 'x';
          } else {
#line 273
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
#line 273
          if (i < per_slider) {
#line 273
            tmp___15 = '*';
          } else {
#line 273
            tmp___15 = '-';
          }
#line 273
          tmp___16 = tmp___15;
        }
        {
#line 273
        printw("%c", tmp___16);
#line 272
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 274
      if (stdscr) {
#line 274
        stdscr->_attrs = 0UL;
      }
      {
#line 275
      tmp___23 = gom_mixer_c_l(c);
      }
#line 275
      if (tmp___23) {
        {
#line 275
        tmp___24 = gom_driver_c_c_len(c);
        }
#line 275
        if (tmp___24 == 2) {
#line 275
          if (cc == 0) {
#line 275
            tmp___21 = '\\';
          } else {
#line 275
            tmp___21 = '/';
          }
#line 275
          tmp___22 = tmp___21;
        } else {
#line 275
          tmp___22 = ']';
        }
      } else {
#line 275
        tmp___22 = ']';
      }
      {
#line 275
      printw("%c ", tmp___22);
      }
    } else {
      {
#line 279
      printw("                              ");
      }
    }
  }
#line 281
  if (stdscr) {
#line 281
    stdscr->_attrs = 0UL;
  }
#line 282
  if (cc == 0) {
    {
#line 283
    tmp___31 = gom_driver_c_r(c);
    }
#line 283
    if (tmp___31 > -1) {
      {
#line 283
      tmp___29 = gom_driver_c_r(c);
      }
#line 283
      if (tmp___29) {
#line 283
        tmp___28 = "R+";
      } else {
#line 283
        tmp___28 = "R-";
      }
#line 283
      tmp___30 = tmp___28;
    } else {
#line 283
      tmp___30 = "  ";
    }
    {
#line 283
    printw("%s |", tmp___30);
    }
  } else {
    {
#line 285
    tmp___37 = gom_driver_c_c_len(c);
    }
#line 285
    if (tmp___37 >= 2) {
      {
#line 285
      tmp___35 = gom_mixer_c_l(c);
      }
#line 285
      if (tmp___35) {
#line 285
        tmp___34 = '+';
      } else {
#line 285
        tmp___34 = '-';
      }
#line 285
      tmp___36 = tmp___34;
    } else {
#line 285
      tmp___36 = 'x';
    }
    {
#line 285
    printw("   |", tmp___36);
    }
  }
#line 286
  return;
}
}
#line 288 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_iface_t.c"
int gom_iface_t_c_number(int c ) 
{ 
  int c2 ;
  int no ;

  {
  {
#line 291
  no = 0;
#line 292
  c2 = gom_driver_c_first();
  }
  {
#line 292
  while (1) {
    while_continue: /* CIL Label */ ;
#line 292
    if (c2 > -1) {
#line 292
      if (! (c2 != c)) {
#line 292
        goto while_break;
      }
    } else {
#line 292
      goto while_break;
    }
    {
#line 295
    no ++;
#line 292
    c2 = gom_driver_c_next(c2, 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 296
  return (no);
}
}
#line 299 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_iface_t.c"
int gom_iface_t_cbox(int c ) 
{ 
  int no ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 302
  tmp___0 = gom_driver_c(c);
  }
#line 302
  if (tmp___0 > -1) {
    {
#line 304
    tmp = gom_iface_t_c_number(c);
#line 304
    no = tmp - gom_iface_t_current_page * ((COLS / 35) * ((LINES - 5) / 3));
    }
#line 305
    if (no < (COLS / 35) * ((LINES - 5) / 3)) {
#line 306
      return (no);
    }
  }
#line 308
  return (-1);
}
}
#line 311 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_iface_t.c"
int gom_iface_t_last_cdisplay(void) 
{ 
  int c ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 314
  tmp = gom_driver_C_len();
#line 314
  c = tmp - 1;
  }
  {
#line 314
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 314
    tmp___0 = gom_iface_t_cbox(c);
    }
#line 314
    if (! (tmp___0 < 0)) {
#line 314
      goto while_break;
    }
#line 314
    c --;
  }
  while_break: /* CIL Label */ ;
  }
#line 315
  return (c);
}
}
#line 318 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_iface_t.c"
int gom_iface_t_cdisplays(void) 
{ 
  int max ;
  int tmp ;

  {
  {
#line 321
  max = gom_driver_c_len();
  }
#line 322
  if (gom_iface_t_current_page < 1) {
    {
#line 323
    max = gom_driver_c_len();
    }
  } else {
    {
#line 325
    tmp = gom_driver_c_len();
#line 325
    max = tmp - (gom_iface_t_current_page - 1) * ((COLS / 35) * ((LINES - 5) / 3));
    }
  }
#line 327
  if (max > (COLS / 35) * ((LINES - 5) / 3)) {
#line 328
    max = (COLS / 35) * ((LINES - 5) / 3);
  }
#line 329
  return (max);
}
}
#line 332 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_iface_t.c"
void gom_iface_t_draw_channel(int c ) 
{ 
  int cbox ;
  int cdisplay_line ;
  int cdisplay_col ;
  int line ;
  int col ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 336
  cbox = gom_iface_t_cbox(c);
  }
#line 337
  if (cbox < 0) {
#line 338
    return;
  }
  {
#line 341
  cdisplay_col = cbox / ((LINES - 5) / 3);
#line 342
  cdisplay_line = cbox % ((LINES - 5) / 3);
#line 345
  line = 2 + cdisplay_line * 3;
#line 346
  col = (COLS - (COLS / 35) * 35) / 2 + cdisplay_col * 34;
#line 350
  gom_iface_t_draw_bline(line, col);
  }
#line 351
  if (stdscr) {
#line 351
    stdscr->_attrs = 1UL << 21;
  }
  {
#line 352
  tmp = gom_driver_C_name((unsigned int )c, 1);
#line 352
  mvprintw(line, col + 7, " %i. %s ", c, tmp);
  }
#line 355
  if (stdscr) {
#line 355
    stdscr->_attrs = 0UL;
  }
  {
#line 358
  line ++;
#line 358
  wmove(stdscr, line, col);
#line 359
  tmp___0 = gom_driver_c_c_v(c, 0);
#line 359
  gom_iface_t_draw_sline(c, 0, tmp___0);
#line 362
  line ++;
#line 362
  wmove(stdscr, line, col);
#line 363
  tmp___1 = gom_driver_c_c_v(c, 1);
#line 363
  gom_iface_t_draw_sline(c, 1, tmp___1);
#line 366
  tmp___2 = gom_iface_t_c_number(c);
  }
#line 366
  if ((tmp___2 + 1) % ((LINES - 5) / 3) == 0) {
    {
#line 368
    line ++;
#line 368
    gom_iface_t_draw_bline(line, col);
    }
  } else {
    {
#line 366
    tmp___3 = gom_iface_t_c_number(c);
#line 366
    tmp___4 = gom_driver_c_len();
    }
#line 366
    if (tmp___3 + 1 == tmp___4) {
      {
#line 368
      line ++;
#line 368
      gom_iface_t_draw_bline(line, col);
      }
    }
  }
  {
#line 370
  wrefresh(stdscr);
  }
#line 371
  return;
}
}
#line 380
void gom_iface_t_init(void) ;
#line 380 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_iface_t.c"
static char *help_text[20]  = 
#line 380
  {      (char *)"",      (char *)"Help on terminal gomii",      (char *)"----------------------",      (char *)"", 
        (char *)"  You can use all command line options (except the few command",      (char *)"  line _only_ options) by typing the character that builds up",      (char *)"  the standard POSIX-like one-character option.",      (char *)"", 
        (char *)"  Terminal gomii specials:",      (char *)"",      (char *)"    <Left/Right>-+   De/increase volume by 1.",      (char *)"    j                Jump: increase volume by 1/4 of total", 
        (char *)"                     (flipping back to zero).",      (char *)"    <Up/Down><Tab>   Select channels (or left/right volumes inside",      (char *)"                     unlocked channels).",      (char *)"    <Space>          Goto next page.", 
        (char *)"    <C-l>            Do a (ncurses) display reinitialisation (useful, for",      (char *)"                     example, after resizing a xterm I am running in).",      (char *)"    <Esc>qQ          Quit the terminal gomii.",      (char *)((void *)0)};
#line 378 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_iface_t.c"
void gom_iface_t_init(void) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 404
  initscr();
  }
#line 407
  if (COLS < 35) {
    {
#line 409
    gom_info((enum gom_info_types )-1, (char *)"Your terminal is too small. I need at least %i columns (now %i) and %i lines (now %i).",
             35, COLS, 8, LINES);
#line 412
    gom_info((enum gom_info_types )-1, (char *)"-- [RETURN] to continue anyway --");
#line 414
    getchar();
    }
  } else
#line 407
  if (LINES < 8) {
    {
#line 409
    gom_info((enum gom_info_types )-1, (char *)"Your terminal is too small. I need at least %i columns (now %i) and %i lines (now %i).",
             35, COLS, 8, LINES);
#line 412
    gom_info((enum gom_info_types )-1, (char *)"-- [RETURN] to continue anyway --");
#line 414
    getchar();
    }
  }
#line 416
  if (COLS < 75) {
    {
#line 418
    gom_info((enum gom_info_types )-1, (char *)"Warning: Your terminal is quite narrow; there might be display inconveniences.");
#line 420
    gom_info((enum gom_info_types )-1, (char *)"Note: It would be perfect if you had at least %i columns (now %i).",
             75, COLS);
#line 423
    gom_info((enum gom_info_types )-1, (char *)"-- [RETURN] to continue anyway --");
#line 425
    getchar();
    }
  }
  {
#line 429
  keypad(stdscr, (_Bool)1);
#line 430
  cbreak();
#line 431
  noecho();
#line 432
  leaveok(stdscr, (_Bool)1);
#line 433
  wtimeout(stdscr, -1);
#line 436
  tmp = gom_gomii_refival();
#line 436
  gom_gomii_refival_set((enum gom_info_types )3, tmp, & gom_iface_t_refresh);
#line 438
  gom_info_custom_set(& gom_iface_t_info);
#line 439
  gom_action_help_special_set(help_text);
#line 442
  tmp___0 = gom_driver_c_len();
#line 442
  gom_iface_t_pages = tmp___0 / ((COLS / 35) * ((LINES - 5) / 3));
#line 443
  tmp___1 = gom_driver_c_len();
  }
#line 443
  if (tmp___1 % ((COLS / 35) * ((LINES - 5) / 3)) != 0) {
#line 444
    gom_iface_t_pages ++;
  }
#line 449
  gom_iface_t_is_initialized = 1;
#line 450
  return;
}
}
#line 452 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_iface_t.c"
void gom_iface_t_closeup(void) 
{ 
  int tmp ;

  {
#line 454
  if (gom_iface_t_is_initialized) {
    {
#line 457
    tmp = gom_gomii_refival();
#line 457
    gom_gomii_refival_set((enum gom_info_types )3, tmp, (void (*)())((void *)0));
#line 459
    gom_info_custom_set((void (*)(enum gom_info_types  , char * , va_list  ))((void *)0));
#line 460
    gom_action_help_special_set((char **)((void *)0));
#line 462
    wclear(stdscr);
#line 463
    wrefresh(stdscr);
#line 464
    endwin();
#line 466
    gom_iface_t_is_initialized = 0;
    }
  }
#line 468
  return;
}
}
#line 470 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_iface_t.c"
void gom_iface_t_update(enum gom_gomii_refresh_stage stage ) 
{ 
  int c ;
  int old_page ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;

  {
#line 474
  if (gom_iface_t_is_initialized) {
    {
#line 477
    old_page = gom_iface_t_current_page;
#line 478
    tmp = gom_mixer_c_current();
#line 478
    tmp___0 = gom_iface_t_c_number(tmp);
#line 478
    gom_iface_t_current_page = tmp___0 / ((COLS / 35) * ((LINES - 5) / 3));
    }
  } else {
#line 483
    gom_iface_t_current_page = 0;
#line 483
    old_page = gom_iface_t_current_page;
  }
  {
#line 488
  if ((unsigned int )stage == 1U) {
#line 488
    goto case_1;
  }
#line 495
  if ((unsigned int )stage == 2U) {
#line 495
    goto case_2;
  }
#line 504
  if ((unsigned int )stage == 3U) {
#line 504
    goto case_3;
  }
#line 521
  if ((unsigned int )stage == 4U) {
#line 521
    goto case_4;
  }
#line 537
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 490
  gom_iface_t_closeup();
#line 491
  gom_iface_t_init();
#line 492
  gom_info((enum gom_info_types )1, (char *)"Welcome to the all-ascii-no-color(tm) terminal gomii!");
  }
  case_2: /* CIL Label */ 
  {
#line 497
  gom_iface_t_draw_mask();
#line 498
  tmp___1 = gom_driver_d();
#line 498
  gom_iface_t_seperator_line(1, tmp___1);
#line 499
  gom_iface_t_clear_cboxes_space();
#line 502
  mvprintw(1, 1, " Page %i/%i ", 1 + gom_iface_t_current_page, gom_iface_t_pages);
  }
  case_3: /* CIL Label */ 
  {
#line 506
  tmp___2 = gom_gomii_last_refresh_str();
#line 506
  tmp___3 = gom_gomii_last_refresh_str();
#line 506
  tmp___4 = strlen((char const   *)tmp___3);
#line 506
  mvprintw(1, (int )(((size_t )COLS - tmp___4) - 3UL), " %s ", tmp___2);
  }
#line 510
  if ((unsigned int )stage == 3U) {
#line 510
    if (old_page != gom_iface_t_current_page) {
      {
#line 512
      gom_iface_t_update((enum gom_gomii_refresh_stage )2);
      }
#line 512
      goto switch_break;
    } else {
#line 510
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 517
    c = gom_driver_c_first();
    }
    {
#line 517
    while (1) {
      while_continue: /* CIL Label */ ;
#line 517
      if (! (c > -1)) {
#line 517
        goto while_break;
      }
      {
#line 518
      gom_iface_t_draw_channel(c);
#line 517
      c = gom_driver_c_next(c, 1);
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  case_4: /* CIL Label */ 
#line 522
  if ((unsigned int )stage == 4U) {
#line 522
    if (old_page != gom_iface_t_current_page) {
      {
#line 524
      gom_iface_t_update((enum gom_gomii_refresh_stage )2);
      }
#line 524
      goto switch_break;
    } else {
#line 522
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 526
  if ((unsigned int )stage == 4U) {
    {
#line 529
    gom_iface_t_update((enum gom_gomii_refresh_stage )3);
    }
#line 529
    goto switch_break;
  }
#line 535
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 538
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 540
  return;
}
}
#line 542 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_iface_t.c"
void gom_iface_t_refresh(void) 
{ 


  {
  {
#line 544
  gom_iface_t_update((enum gom_gomii_refresh_stage )3);
  }
#line 545
  return;
}
}
#line 547 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_iface_t.c"
void gom_iface_t_add_volume(int add ) 
{ 
  int max ;
  int tmp ;
  int tmp___0 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
#line 549
  if (add > 0) {
    {
#line 549
    tmp = gom_driver_c_c_v_max();
#line 549
    tmp___0 = tmp;
    }
  } else {
#line 549
    tmp___0 = 0;
  }
  {
#line 549
  max = tmp___0;
#line 551
  tmp___8 = gom_mixer_c_c_current();
#line 551
  tmp___9 = gom_mixer_c_current();
#line 551
  tmp___10 = gom_driver_c_c_v(tmp___9, tmp___8);
  }
#line 551
  if (tmp___10 == max) {
#line 551
    tmp___7 = max;
  } else {
    {
#line 551
    tmp___4 = gom_mixer_c_c_current();
#line 551
    tmp___5 = gom_mixer_c_current();
#line 551
    tmp___6 = gom_driver_c_c_v(tmp___5, tmp___4);
#line 551
    tmp___7 = tmp___6 + add;
    }
  }
  {
#line 551
  tmp___11 = gom_mixer_c_c_current();
#line 551
  tmp___12 = gom_mixer_c_current();
#line 551
  gom_mixer_c_c_v_set_l((enum gom_info_types )1, tmp___12, tmp___11, tmp___7);
  }
#line 556
  return;
}
}
#line 560 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_iface_t.c"
void gom_iface_t_upordown(int add ) 
{ 
  int new_c ;
  int new_cc ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 565
  new_c = gom_mixer_c_current();
#line 566
  tmp = gom_mixer_c_c_current();
#line 566
  new_cc = gom_driver_c_c_next(new_c, tmp, add);
  }
#line 568
  if (new_cc < 0) {
#line 568
    goto _L;
  } else {
    {
#line 568
    tmp___1 = gom_mixer_c_l(new_c);
    }
#line 568
    if (tmp___1) {
      _L: /* CIL Label */ 
      {
#line 570
      tmp___0 = gom_mixer_c_current();
#line 570
      new_c = gom_driver_c_next(tmp___0, add);
      }
#line 571
      if (new_c > -1) {
#line 573
        if (add < 0) {
          {
#line 574
          new_cc = gom_driver_c_c_last(new_c);
          }
        } else {
          {
#line 576
          new_cc = gom_driver_c_c_first(new_c);
          }
        }
      } else
#line 580
      if (add < 0) {
        {
#line 582
        new_c = gom_driver_c_last();
#line 583
        new_cc = gom_driver_c_c_last(new_c);
        }
      } else {
        {
#line 587
        new_c = gom_driver_c_first();
#line 588
        new_cc = gom_driver_c_c_first(new_c);
        }
      }
    }
  }
  {
#line 594
  gom_mixer_c_current_set((enum gom_info_types )2, new_c);
#line 595
  gom_mixer_c_c_current_set((enum gom_info_types )2, new_cc);
  }
#line 596
  return;
}
}
#line 598 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_iface_t.c"
void gom_iface_t(void) 
{ 
  int jump_volume ;
  enum gom_gomii_refresh_stage stage ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
#line 600
  jump_volume = 0;
#line 601
  stage = (enum gom_gomii_refresh_stage )1;
  {
#line 603
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 606
    gom_iface_t_update(stage);
#line 607
    stage = (enum gom_gomii_refresh_stage )4;
#line 610
    gom_iface_t_action_action = wgetch(stdscr);
    }
    {
#line 614
    if (gom_iface_t_action_action == 81) {
#line 614
      goto case_81;
    }
#line 614
    if (gom_iface_t_action_action == 113) {
#line 614
      goto case_81;
    }
#line 614
    if (gom_iface_t_action_action == 27) {
#line 614
      goto case_81;
    }
#line 618
    if (gom_iface_t_action_action == 32) {
#line 618
      goto case_32;
    }
#line 637
    if (gom_iface_t_action_action == 259) {
#line 637
      goto case_259;
    }
#line 643
    if (gom_iface_t_action_action == 258) {
#line 643
      goto case_258;
    }
#line 643
    if (gom_iface_t_action_action == 9) {
#line 643
      goto case_258;
    }
#line 650
    if (gom_iface_t_action_action == 261) {
#line 650
      goto case_261;
    }
#line 650
    if (gom_iface_t_action_action == 43) {
#line 650
      goto case_261;
    }
#line 655
    if (gom_iface_t_action_action == 260) {
#line 655
      goto case_260;
    }
#line 655
    if (gom_iface_t_action_action == 45) {
#line 655
      goto case_260;
    }
#line 660
    if (gom_iface_t_action_action == 106) {
#line 660
      goto case_106;
    }
#line 668
    goto switch_default;
    case_81: /* CIL Label */ 
    case_113: /* CIL Label */ 
    case_27: /* CIL Label */ 
    {
#line 615
    gom_iface_t_closeup();
    }
#line 616
    return;
    case_32: /* CIL Label */ 
#line 620
    if (gom_iface_t_pages == 1) {
      {
#line 621
      gom_info((enum gom_info_types )1, (char *)"There is only one page.");
      }
    } else {
      {
#line 625
      tmp___2 = gom_iface_t_last_cdisplay();
#line 625
      tmp___3 = gom_driver_c_next(tmp___2, 1);
      }
#line 625
      if (tmp___3 < 0) {
        {
#line 626
        tmp = gom_driver_c_first();
#line 626
        gom_mixer_c_current_set((enum gom_info_types )2, tmp);
        }
      } else {
        {
#line 628
        tmp___0 = gom_iface_t_last_cdisplay();
#line 628
        tmp___1 = gom_driver_c_next(tmp___0, 1);
#line 628
        gom_mixer_c_current_set((enum gom_info_types )2, tmp___1);
        }
      }
      {
#line 630
      tmp___4 = gom_mixer_c_current();
#line 630
      tmp___5 = gom_driver_c_c_first(tmp___4);
#line 630
      gom_mixer_c_c_current_set((enum gom_info_types )2, tmp___5);
#line 633
      stage = (enum gom_gomii_refresh_stage )2;
      }
    }
#line 635
    goto switch_break;
    case_259: /* CIL Label */ 
    {
#line 639
    gom_iface_t_upordown(-1);
    }
#line 640
    goto switch_break;
    case_258: /* CIL Label */ 
    case_9: /* CIL Label */ 
    {
#line 645
    gom_iface_t_upordown(1);
    }
#line 646
    goto switch_break;
    case_261: /* CIL Label */ 
    case_43: /* CIL Label */ 
    {
#line 651
    gom_iface_t_add_volume(1);
    }
#line 652
    goto switch_break;
    case_260: /* CIL Label */ 
    case_45: /* CIL Label */ 
    {
#line 656
    gom_iface_t_add_volume(-1);
    }
#line 657
    goto switch_break;
    case_106: /* CIL Label */ 
    {
#line 661
    tmp___6 = gom_mixer_c_c_current();
#line 661
    tmp___7 = gom_mixer_c_current();
#line 661
    tmp___8 = gom_driver_c_c_v(tmp___7, tmp___6);
#line 661
    tmp___9 = gom_driver_c_c_v_max();
#line 661
    jump_volume = tmp___8 + tmp___9 / 4;
#line 663
    tmp___11 = gom_driver_c_c_v_max();
    }
#line 663
    if (jump_volume > tmp___11) {
#line 663
      jump_volume = 0;
    } else {
#line 663
      jump_volume = jump_volume;
    }
    {
#line 664
    tmp___12 = gom_mixer_c_c_current();
#line 664
    tmp___13 = gom_mixer_c_current();
#line 664
    gom_mixer_c_c_v_set_l((enum gom_info_types )1, tmp___13, tmp___12, jump_volume);
    }
#line 666
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 669
    stage = gom_action((enum gom_info_types )1, (char )gom_iface_t_action_action,
                       0, & gom_iface_t_get_option_arg, & gom_iface_t_pre_scroll,
                       & gom_iface_t_post_scroll);
    }
#line 672
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 677
  gom_info((enum gom_info_types )-1, (char *)"Bug: gom_iface_t()");
  }
#line 678
  return;
}
}
#line 40 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_iface.h"
void gom_iface_c(int argc , char **argv ) ;
#line 38 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom.c"
int main(int argc , char **argv ) 
{ 
  char const   *tmp ;

  {
  {
#line 41
  gom_gomii_refival_set((enum gom_info_types )3, 30, & gom_gomii_refproc_keep);
#line 42
  gom_mixer_fadival_set((enum gom_info_types )3, 5);
#line 45
  gom_iface_c(argc, argv);
#line 48
  gom_driver_d_set((enum gom_info_types )1, (char *)((void *)0));
  }
#line 51
  if (gom_info_errors > 0) {
#line 53
    if (gom_info_errors == 2147483647) {
#line 53
      tmp = "At least ";
    } else {
#line 53
      tmp = "";
    }
    {
#line 53
    gom_info((enum gom_info_types )2, (char *)"%s%d error(s) detected while running.",
             tmp, gom_info_errors);
    }
#line 58
    return (2);
  } else {
#line 63
    return (0);
  }
}
}
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 425
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...)  __asm__("__isoc99_fscanf")  ;
#line 749
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 564 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 147 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 489
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) index)(char const   *__s ,
                                                                                              int __c )  __attribute__((__pure__)) ;
#line 517
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) rindex)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 675 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 678
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) geteuid)(void) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_file.c"
char gom_file_option[100]  ;
#line 54 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_file.c"
int gom_file_systemconf(void) 
{ 
  __uid_t tmp ;
  __uid_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 56
  tmp = geteuid();
  }
#line 56
  if (tmp == 0U) {
#line 56
    tmp___1 = 1;
  } else {
    {
#line 56
    tmp___0 = getuid();
    }
#line 56
    if (tmp___0 == 0U) {
#line 56
      tmp___1 = 1;
    } else {
#line 56
      tmp___1 = 0;
    }
  }
#line 56
  return (tmp___1);
}
}
#line 59 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_file.c"
char *gom_file_fncat(char *fn , char const   *ct ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 61
  tmp = strlen(ct);
#line 61
  tmp___0 = strlen((char const   *)fn);
  }
#line 61
  if (tmp > (4096UL - tmp___0) - 1UL) {
    {
#line 62
    gom_info((enum gom_info_types )-1, (char *)"Bug: File name too big (>%i characters).",
             4095);
    }
  }
  {
#line 63
  tmp___1 = strlen((char const   *)fn);
#line 63
  tmp___2 = strncat((char */* __restrict  */)fn, (char const   */* __restrict  */)ct,
                    (4096UL - tmp___1) - 1UL);
  }
#line 63
  return (tmp___2);
}
}
#line 66 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_file.c"
int gom_file_fn_make(enum gom_info_types verb , char *fn , char const   *fname , int const   is_settings_file ,
                     int const   force_systemconf ) 
{ 
  char *mixer_name ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char const   *tmp___6 ;
  size_t tmp___7 ;

  {
#line 74
  *(fn + 0) = (char )'\000';
#line 75
  if ((unsigned long )fname != (unsigned long )((void *)0)) {
#line 75
    if ((int const   )*(fname + 0) == 47) {
#line 75
      goto _L___0;
    } else
#line 75
    if ((int const   )*(fname + 0) == 126) {
#line 75
      goto _L___0;
    } else
#line 75
    if ((int const   )*(fname + 0) == 46) {
#line 75
      if ((int const   )*(fname + 1) == 47) {
        _L___0: /* CIL Label */ 
#line 80
        if ((int const   )*(fname + 0) == 126) {
          {
#line 80
          tmp___0 = getenv("HOME");
          }
#line 80
          if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
            {
#line 82
            tmp = getenv("HOME");
#line 82
            gom_file_fncat(fn, (char const   *)tmp);
#line 83
            gom_file_fncat(fn, fname + 1);
            }
          } else {
            {
#line 87
            gom_file_fncat(fn, fname);
            }
          }
        } else {
          {
#line 87
          gom_file_fncat(fn, fname);
          }
        }
#line 89
        return (0);
      } else {
#line 75
        goto _L;
      }
    } else {
#line 75
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 96
    if (force_systemconf) {
      {
#line 99
      gom_file_fncat(fn, "/etc/gom/");
      }
    } else {
      {
#line 96
      tmp___3 = gom_file_systemconf();
      }
#line 96
      if (tmp___3) {
        {
#line 99
        gom_file_fncat(fn, "/etc/gom/");
        }
      } else {
        {
#line 102
        tmp___2 = getenv("HOME");
        }
#line 102
        if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
          {
#line 105
          tmp___1 = getenv("HOME");
#line 105
          gom_file_fncat(fn, (char const   *)tmp___1);
#line 106
          gom_file_fncat(fn, "/.gom/");
          }
        } else {
          {
#line 111
          gom_info((enum gom_info_types )0, (char *)"Warning: No environment variable \'HOME\' found (using working directory).");
#line 112
          gom_file_fncat(fn, "./.gom/");
          }
        }
      }
    }
#line 115
    if (is_settings_file) {
      {
#line 119
      tmp___4 = gom_driver_d();
#line 119
      mixer_name = rindex((char const   *)tmp___4, '/');
      }
#line 120
      if ((unsigned long )mixer_name == (unsigned long )((void *)0)) {
        {
#line 123
        mixer_name = gom_driver_d();
        }
      } else {
#line 127
        mixer_name ++;
      }
      {
#line 129
      gom_file_fncat(fn, (char const   *)mixer_name);
#line 130
      gom_file_fncat(fn, ".");
      }
    } else {
      {
#line 135
      gom_file_fncat(fn, "conf");
#line 136
      gom_file_fncat(fn, ".");
      }
    }
#line 139
    if ((unsigned long )fname == (unsigned long )((void *)0)) {
#line 139
      tmp___6 = "default";
    } else {
      {
#line 139
      tmp___7 = strlen(fname);
      }
#line 139
      if (tmp___7 == 0UL) {
#line 139
        tmp___6 = "default";
      } else {
#line 139
        tmp___6 = fname;
      }
    }
    {
#line 139
    gom_file_fncat(fn, tmp___6);
    }
#line 140
    return (1);
  }
}
}
#line 153
char *gom_file_optarg_get(void) ;
#line 153 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_file.c"
static char nullstr[1]  = {      (char )'\000'};
#line 151 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_file.c"
char *gom_file_optarg_get(void) 
{ 
  size_t tmp ;

  {
  {
#line 155
  tmp = strlen((char const   *)(gom_file_option));
  }
#line 155
  if (tmp < 2UL) {
#line 157
    return (nullstr);
  } else {
#line 160
    return (& gom_file_option[1]);
  }
}
}
#line 164 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_file.c"
char gom_file_fprereadc(FILE *f ) 
{ 
  char c ;
  int tmp ;

  {
  {
#line 167
  tmp = fscanf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%c",
               & c);
  }
#line 167
  if (1 == tmp) {
    {
#line 168
    fseek(f, -1L, 1);
    }
  } else {
#line 170
    c = (char)-1;
  }
#line 171
  return (c);
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_file.c"
int gom_file_option_allowed(char *allowed_actions , char action ) 
{ 
  char *tmp ;

  {
#line 177
  if ((unsigned long )allowed_actions == (unsigned long )((void *)0)) {
#line 178
    return (1);
  } else {
    {
#line 180
    tmp = index((char const   *)allowed_actions, (int )action);
    }
#line 180
    return ((unsigned long )tmp != (unsigned long )((void *)0));
  }
}
}
#line 184 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_file.c"
void gom_file_options_read(enum gom_info_types std_verb , FILE *f , char *allowed_actions ) 
{ 
  char ind ;
  char action ;
  int count ;
  int line ;
  int line_valid ;
  int tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 188
  line = 1;
  {
#line 190
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 193
    ind = gom_file_fprereadc(f);
#line 193
    line_valid = (int )ind == 45;
    }
#line 195
    if (line_valid) {
      {
#line 197
      gom_info((enum gom_info_types )((int )std_verb + 2), (char *)"Line %d: significant, processing...",
               line);
      }
      {
#line 199
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 199
        count = fscanf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"-%100s",
                       (char *)(& gom_file_option));
        }
#line 199
        if (! (1 == count)) {
#line 199
          goto while_break___0;
        }
        {
#line 205
        action = gom_file_option[0];
#line 207
        gom_info((enum gom_info_types )((int )std_verb + 2), (char *)"Line %d: Option found: %s",
                 line, gom_file_option);
#line 209
        tmp = gom_file_option_allowed(allowed_actions, action);
        }
#line 209
        if (tmp) {
          {
#line 210
          gom_action(std_verb, action, 1, (char *(*)(char * ))(& gom_file_optarg_get),
                     (void (*)())((void *)0), (void (*)())((void *)0));
          }
        } else {
          {
#line 212
          gom_info((enum gom_info_types )-1, (char *)"Option \"-%s\" is not allowed here (allowed are: \"%s\").",
                   & gom_file_option, allowed_actions);
          }
        }
        {
#line 217
        tmp___0 = __ctype_b_loc();
#line 217
        ind = gom_file_fprereadc(f);
        }
#line 217
        if ((int const   )*(*tmp___0 + (int )ind) & 8192) {
#line 217
          if ((int )ind != 10) {
            {
#line 219
            fseek(f, 1L, 1);
            }
          } else {
#line 222
            goto while_break___0;
          }
        } else {
#line 222
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    } else
#line 228
    if ((int )ind == 35) {
      {
#line 229
      gom_info((enum gom_info_types )((int )std_verb + 2), (char *)"Line %d: comment, skipping...",
               line);
      }
    } else
#line 230
    if ((int )ind == 10) {
      {
#line 231
      gom_info((enum gom_info_types )((int )std_verb + 2), (char *)"Line %d: empty, skipping...",
               line);
      }
    } else {
      {
#line 233
      gom_info((enum gom_info_types )((int )std_verb + 2), (char *)"Line %d: ambigious, skipping...",
               line);
      }
    }
    {
#line 237
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 237
      tmp___1 = fscanf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%c",
                       & ind);
      }
#line 237
      if (1 == tmp___1) {
#line 237
        if ((int )ind != -1) {
#line 237
          if (! ((int )ind != 10)) {
#line 237
            goto while_break___1;
          }
        } else {
#line 237
          goto while_break___1;
        }
      } else {
#line 237
        goto while_break___1;
      }
#line 239
      if (line_valid) {
        {
#line 240
        gom_info((enum gom_info_types )((int )std_verb + 2), (char *)"Line %d: Skipping suspicious trailing garbage (%c).",
                 line, (int )ind);
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 243
    line ++;
#line 190
    tmp___2 = feof(f);
    }
#line 190
    if (! (tmp___2 == 0)) {
#line 190
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 246
  return;
}
}
#line 252 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_file.c"
void gom_file_load(enum gom_info_types verb , char *fname , int is_settings_file ,
                   char *allowed_actions ) 
{ 
  FILE *f ;
  char fn_user[4096] ;
  char fn_sys[4096] ;
  char *fn ;
  enum gom_info_types open_err_verb ;
  int tmp ;

  {
#line 258
  fn = (char *)((void *)0);
#line 259
  if (is_settings_file) {
#line 259
    tmp = -1;
  } else {
#line 259
    tmp = (int )verb;
  }
  {
#line 259
  open_err_verb = (enum gom_info_types )tmp;
#line 262
  gom_file_fn_make(verb, (char *)(fn_user), (char const   *)fname, (int const   )is_settings_file,
                   (int const   )0);
#line 263
  f = fopen((char const   */* __restrict  */)(fn_user), (char const   */* __restrict  */)"r");
  }
#line 263
  if ((unsigned long )f == (unsigned long )((void *)0)) {
    {
#line 266
    gom_file_fn_make(verb, (char *)(fn_sys), (char const   *)fname, (int const   )is_settings_file,
                     (int const   )1);
#line 267
    f = fopen((char const   */* __restrict  */)(fn_sys), (char const   */* __restrict  */)"r");
    }
#line 267
    if ((unsigned long )f == (unsigned long )((void *)0)) {
      {
#line 269
      gom_info(open_err_verb, (char *)"No such file from stem \"%s\" (tried \"%s\" and \"%s\").",
               fname, fn_user, fn_sys);
      }
#line 272
      return;
    } else {
#line 276
      fn = fn_sys;
    }
  } else {
#line 281
    fn = fn_user;
  }
  {
#line 285
  gom_info(verb, (char *)"Loading option file from \"%s\"...", fn);
#line 286
  gom_file_options_read((enum gom_info_types )((int )verb + 1), f, allowed_actions);
#line 287
  gom_info(verb, (char *)"Option file load from \"%s\" completed.", fn);
#line 290
  fclose(f);
  }
#line 291
  return;
}
}
#line 298 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_file.c"
int gom_file_stropt_write(FILE *f , char option , char *arg ) 
{ 
  int tmp ;

  {
  {
#line 300
  tmp = fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"-%c%s ",
                (int )option, arg);
  }
#line 300
  return (tmp);
}
}
#line 303 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_file.c"
int gom_file_intopt_write(FILE *f , char option , int arg ) 
{ 
  int tmp ;

  {
  {
#line 305
  tmp = fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"-%c%i ",
                (int )option, arg);
  }
#line 305
  return (tmp);
}
}
#line 309 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_file.c"
void gom_file_options_c_write(FILE *f , int c ) 
{ 
  int cc ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 314
  gom_file_intopt_write(f, (char )'c', c);
#line 315
  tmp___0 = gom_driver_c_r(c);
  }
#line 315
  if (tmp___0 > -1) {
    {
#line 316
    tmp = gom_driver_c_r(c);
#line 316
    gom_file_intopt_write(f, (char )'r', tmp);
    }
  }
  {
#line 319
  gom_file_intopt_write(f, (char )'k', 0);
#line 322
  cc = gom_driver_c_c_first(c);
  }
  {
#line 322
  while (1) {
    while_continue: /* CIL Label */ ;
#line 322
    if (! (cc > -1)) {
#line 322
      goto while_break;
    }
    {
#line 324
    gom_file_intopt_write(f, (char )'C', cc);
#line 325
    tmp___1 = gom_driver_c_c_v(c, cc);
#line 325
    gom_file_intopt_write(f, (char )'l', tmp___1);
#line 322
    cc = gom_driver_c_c_next(c, cc, 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 328
  gom_file_intopt_write(f, (char )'k', 1);
  }
#line 329
  return;
}
}
#line 332 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_file.c"
void gom_file_settings_write(FILE *f , int verbose ) 
{ 
  int c ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 336
  if (verbose) {
    {
#line 338
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"# This is a mixer settings file, automatically produced by gom 0.30.2 (31 May 2004).\n# Lines starting with \"-\" are read (must be one-letter style gom options).\n# Other lines are comments.\n#\n# Channels with recording source == 1 first (avoids \"last rec. source error\" when loading):\n");
    }
  }
  {
#line 346
  c = gom_driver_c_first();
  }
  {
#line 346
  while (1) {
    while_continue: /* CIL Label */ ;
#line 346
    if (! (c > -1)) {
#line 346
      goto while_break;
    }
    {
#line 348
    tmp = gom_driver_c_r(c);
    }
#line 348
    if (tmp > 0) {
      {
#line 350
      gom_file_options_c_write(f, c);
      }
#line 351
      if (verbose) {
        {
#line 352
        fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\n");
        }
      }
    }
    {
#line 346
    c = gom_driver_c_next(c, 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 356
  if (verbose) {
    {
#line 357
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"# Other channels:\n");
    }
  }
  {
#line 359
  c = gom_driver_c_first();
  }
  {
#line 359
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 359
    if (! (c > -1)) {
#line 359
      goto while_break___0;
    }
    {
#line 361
    tmp___0 = gom_driver_c_r(c);
    }
#line 361
    if (tmp___0 <= 0) {
      {
#line 363
      gom_file_options_c_write(f, c);
      }
#line 364
      if (verbose) {
        {
#line 365
        fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\n");
        }
      }
    }
    {
#line 359
    c = gom_driver_c_next(c, 1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 368
  if (verbose) {
    {
#line 369
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"# Resetting current channel to first.\n");
    }
  }
  {
#line 370
  tmp___1 = gom_driver_c_first();
#line 370
  gom_file_intopt_write(f, (char )'c', tmp___1);
  }
#line 371
  return;
}
}
#line 374 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_file.c"
void gom_file_settings_save(enum gom_info_types std_verb , char *fname ) 
{ 
  char fn[4096] ;
  FILE *f ;
  int overwrite ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;

  {
  {
#line 377
  f = (FILE *)((void *)0);
#line 381
  overwrite = gom_file_fn_make(std_verb, (char *)(fn), (char const   *)fname, (int const   )1,
                               (int const   )0);
  }
#line 384
  if ((unsigned long )fname != (unsigned long )((void *)0)) {
    {
#line 384
    tmp___5 = strlen("gom");
#line 384
    tmp___6 = strncmp((char const   *)fname, "gom", tmp___5);
    }
#line 384
    if (tmp___6 == 0) {
      {
#line 386
      gom_info((enum gom_info_types )-1, (char *)"I won\'t save files starting with \"gom\" (like \"%s\") to the configuration dir.",
               fn);
      }
    } else {
#line 384
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 391
  if (! overwrite) {
    {
#line 391
    f = fopen((char const   */* __restrict  */)(fn), (char const   */* __restrict  */)"r");
    }
#line 391
    if ((unsigned long )f != (unsigned long )((void *)0)) {
      {
#line 393
      fclose(f);
#line 393
      f = (FILE *)((void *)0);
#line 394
      gom_info((enum gom_info_types )-1, (char *)"File \"%s\" exists (I refuse to overwrite files elsewhere than in $HOME/.gom).",
               fn);
      }
    } else {
#line 391
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 398
    f = fopen((char const   */* __restrict  */)(fn), (char const   */* __restrict  */)"w");
    }
#line 398
    if ((unsigned long )f == (unsigned long )((void *)0)) {
      {
#line 400
      tmp = __errno_location();
#line 400
      tmp___0 = strerror(*tmp);
#line 400
      gom_info((enum gom_info_types )-1, (char *)"Can\'t open file \"%s\" for save: %s.",
               fn, tmp___0);
      }
    } else {
      {
#line 407
      tmp___1 = gom_file_systemconf();
      }
#line 407
      if (tmp___1) {
        {
#line 408
        gom_info((enum gom_info_types )0, (char *)"Warning: Running as root, writing to \"/etc/gom/\".");
        }
      }
      {
#line 411
      gom_file_settings_write(f, 1);
#line 413
      tmp___4 = fclose(f);
      }
#line 413
      if (tmp___4 == 0) {
        {
#line 414
        gom_info(std_verb, (char *)"Settings saved to \"%s\".", fn);
        }
      } else {
        {
#line 416
        tmp___2 = __errno_location();
#line 416
        tmp___3 = strerror(*tmp___2);
#line 416
        gom_info((enum gom_info_types )-1, (char *)"Problems closing file \"%s\": %s.",
                 fn, tmp___3);
        }
      }
    }
  }
#line 419
  return;
}
}
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 56 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_driver.h"
int gom_driver_d_opened(void) ;
#line 66
int gom_driver_C_last(void) ;
#line 86
int gom_driver_C_C(int c , int cc ) ;
#line 88
int gom_driver_C_C_last(int c ) ;
#line 90
int gom_driver_C_C_len(int c ) ;
#line 54 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_driver_oss.c"
struct __anonstruct_gom_driver_oss_55 gom_driver_oss  =    {{0, {(char )'n', (char )'o', (char )'_', (char )'m', (char )'i', (char )'x', (char )'e',
         (char )'r', (char )'_', (char )'o', (char )'p', (char )'e', (char )'n', (char )'e',
         (char )'d', (char )'\000'}, -1, 0U, 0U, 0U}, {(unsigned int )(~ 0)}, {0},
    {0U, {0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,
          0U, 0U, 0U, 0U, 0U, 0U, 0U}}};
#line 95 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_driver_oss.c"
unsigned int gom_driver_private_getbits(unsigned int x , int p , int n ) 
{ 


  {
#line 97
  return ((x >> ((p + 1) - n)) & (unsigned int )(~ (-1 << n)));
}
}
#line 100 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_driver_oss.c"
unsigned int gom_driver_private_pow(unsigned int base , int exp ) 
{ 
  int i ;
  unsigned int x ;

  {
#line 103
  x = 1U;
#line 104
  i = 0;
  {
#line 104
  while (1) {
    while_continue: /* CIL Label */ ;
#line 104
    if (! (i < exp)) {
#line 104
      goto while_break;
    }
#line 105
    x *= base;
#line 104
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 106
  return (x);
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_driver_oss.c"
unsigned int gom_driver_private_setbit(unsigned int x , int p , int on ) 
{ 
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 111
  if (on) {
    {
#line 112
    tmp = gom_driver_private_pow(2U, p);
    }
#line 112
    return (x | tmp);
  } else {
    {
#line 114
    tmp___0 = gom_driver_private_pow(2U, p);
    }
#line 114
    return (x & ~ tmp___0);
  }
}
}
#line 122 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_driver_oss.c"
static char name[28]  = 
#line 122
  {      (char )'O',      (char )'S',      (char )'S',      (char )' ', 
        (char )'(',      (char )'O',      (char )'p',      (char )'e', 
        (char )'n',      (char )' ',      (char )'S',      (char )'o', 
        (char )'u',      (char )'n',      (char )'d',      (char )' ', 
        (char )'S',      (char )'y',      (char )'s',      (char )'t', 
        (char )'e',      (char )'m',      (char )')',      (char )' ', 
        (char )'A',      (char )'P',      (char )'I',      (char )'\000'};
#line 120 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_driver_oss.c"
char *gom_driver(void) 
{ 


  {
#line 123
  return ((char *)(& name));
}
}
#line 130 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_driver_oss.c"
char *gom_driver_d(void) 
{ 


  {
#line 132
  return ((char *)(& gom_driver_oss.c.fn));
}
}
#line 135 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_driver_oss.c"
int gom_driver_d_opened(void) 
{ 


  {
#line 137
  return (gom_driver_oss.c.opened);
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_driver_oss.c"
int gom_driver_d_set(enum gom_info_types std_verb , char *device_file ) 
{ 
  int new_mixer ;
  unsigned int channelmask ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 150
  if ((unsigned long )device_file == (unsigned long )((void *)0)) {
#line 153
    if (gom_driver_oss.c.opened) {
      {
#line 155
      close(gom_driver_oss.c.fd);
#line 156
      strncpy((char */* __restrict  */)(gom_driver_oss.c.fn), (char const   */* __restrict  */)"no_mixer_opened",
              (size_t )80);
#line 157
      gom_driver_oss.c.opened = 0;
      }
    }
#line 159
    return (1);
  } else
#line 161
  if (gom_driver_oss.c.opened) {
    {
#line 161
    tmp___2 = strcmp((char const   *)device_file, (char const   *)(gom_driver_oss.c.fn));
    }
#line 161
    if (tmp___2 == 0) {
      {
#line 164
      gom_info(std_verb, (char *)"Mixer corresponding to special file %s is already open.",
               device_file);
      }
#line 167
      return (1);
    } else {
#line 161
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 170
    new_mixer = open((char const   *)device_file, 2);
    }
#line 170
    if (new_mixer == -1) {
      {
#line 173
      tmp = __errno_location();
#line 173
      tmp___0 = strerror(*tmp);
#line 173
      gom_info((enum gom_info_types )-1, (char *)"Can\'t open mixer device special file \"%s\": %s.",
               device_file, tmp___0);
#line 176
      gom_info_block((enum gom_info_types )0, 6, (char *)"Error help: if loading a mixer special file leads to \"No such device\", then you most likely do have the kernel sound driver not or incorrectly installed. \"Permission denied\" means you need permissions by the local admin in the first place.");
      }
#line 182
      return (0);
    } else {
      {
#line 184
      tmp___1 = ioctl(new_mixer, (unsigned long )(((2U << 30) | (unsigned int )(77 << 8)) | 254U) | (sizeof(int ) << 16),
                      & channelmask);
      }
#line 184
      if (tmp___1 == -1) {
        {
#line 187
        close(new_mixer);
#line 189
        gom_info((enum gom_info_types )-1, (char *)"I can\'t read the opened mixer special file %s.",
                 device_file);
#line 190
        gom_info_block((enum gom_info_types )0, 6, (char *)"Error help: This is an abnormal situation, as the mixer special device was opened correctly, but I can\'t read it. Maybe this indicates a misconfigured OSS sounddriver, some strange hardware bug, or some strange gom bug; but basically, I don\'t really have a clue.");
        }
#line 194
        return (0);
      } else
#line 196
      if (channelmask == 0U) {
        {
#line 198
        close(new_mixer);
#line 199
        gom_info((enum gom_info_types )-1, (char *)"Bug: Mixer opened ok, but no channels available (!?) (opened special file is %s).",
                 device_file);
#line 202
        gom_info_block((enum gom_info_types )0, 6, (char *)"Error help: This is an abnormal situation, as your mixer presents himself to me as being available with _zero_ channels. Maybe this indicates a misconfigured OSS sounddriver, some strange hardware bug, or some strange gom bug; but basically, I don\'t really have a clue.");
        }
#line 206
        return (0);
      } else {
        {
#line 211
        gom_driver_d_set(std_verb, (char *)((void *)0));
#line 214
        strncpy((char */* __restrict  */)(gom_driver_oss.c.fn), (char const   */* __restrict  */)device_file,
                (size_t )80);
#line 215
        gom_driver_oss.c.fd = new_mixer;
#line 216
        gom_driver_oss.c.opened = 1;
#line 217
        gom_info(std_verb, (char *)"Mixer corresponding to special file %s opened.",
                 device_file);
#line 222
        ioctl(gom_driver_oss.c.fd, (unsigned long )(((2U << 30) | (unsigned int )(77 << 8)) | 254U) | (sizeof(int ) << 16),
              & gom_driver_oss.c.channelmask);
#line 223
        ioctl(gom_driver_oss.c.fd, (unsigned long )(((2U << 30) | (unsigned int )(77 << 8)) | 253U) | (sizeof(int ) << 16),
              & gom_driver_oss.c.recmask);
#line 224
        ioctl(gom_driver_oss.c.fd, (unsigned long )(((2U << 30) | (unsigned int )(77 << 8)) | 251U) | (sizeof(int ) << 16),
              & gom_driver_oss.c.stereomask);
#line 227
        gom_driver_oss.v.lockmask = (unsigned int )(~ 0);
        }
#line 230
        return (1);
      }
    }
  }
}
}
#line 238 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_driver_oss.c"
int gom_driver_C(int c ) 
{ 


  {
#line 240
  if (c >= 0) {
#line 240
    if (c < 25) {
#line 241
      return (c);
    } else {
#line 243
      return (-1);
    }
  } else {
#line 243
    return (-1);
  }
}
}
#line 246 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_driver_oss.c"
int gom_driver_C_first(void) 
{ 


  {
#line 248
  return (0);
}
}
#line 251 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_driver_oss.c"
int gom_driver_C_last(void) 
{ 


  {
#line 253
  return (24);
}
}
#line 256 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_driver_oss.c"
int gom_driver_C_next(int c , int jump ) 
{ 
  int tmp ;

  {
  {
#line 258
  tmp = gom_driver_C(c + jump);
  }
#line 258
  return (tmp);
}
}
#line 261 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_driver_oss.c"
int gom_driver_C_len(void) 
{ 


  {
#line 263
  return (25);
}
}
#line 270 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_driver_oss.c"
static char unexistent[15]  = 
#line 270
  {      (char )'n',      (char )'o',      (char )'_',      (char )'O', 
        (char )'S',      (char )'S',      (char )'_',      (char )'c', 
        (char )'h',      (char )'a',      (char )'n',      (char )'n', 
        (char )'e',      (char )'l',      (char )'\000'};
#line 266 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_driver_oss.c"
char *gom_driver_C_name(unsigned int c , int label ) 
{ 
  char *channel_name[25] ;
  char *channel_label[25] ;
  int tmp ;

  {
  {
#line 268
  channel_name[0] = (char *)"vol";
#line 268
  channel_name[1] = (char *)"bass";
#line 268
  channel_name[2] = (char *)"treble";
#line 268
  channel_name[3] = (char *)"synth";
#line 268
  channel_name[4] = (char *)"pcm";
#line 268
  channel_name[5] = (char *)"speaker";
#line 268
  channel_name[6] = (char *)"line";
#line 268
  channel_name[7] = (char *)"mic";
#line 268
  channel_name[8] = (char *)"cd";
#line 268
  channel_name[9] = (char *)"mix";
#line 268
  channel_name[10] = (char *)"pcm2";
#line 268
  channel_name[11] = (char *)"rec";
#line 268
  channel_name[12] = (char *)"igain";
#line 268
  channel_name[13] = (char *)"ogain";
#line 268
  channel_name[14] = (char *)"line1";
#line 268
  channel_name[15] = (char *)"line2";
#line 268
  channel_name[16] = (char *)"line3";
#line 268
  channel_name[17] = (char *)"dig1";
#line 268
  channel_name[18] = (char *)"dig2";
#line 268
  channel_name[19] = (char *)"dig3";
#line 268
  channel_name[20] = (char *)"phin";
#line 268
  channel_name[21] = (char *)"phout";
#line 268
  channel_name[22] = (char *)"video";
#line 268
  channel_name[23] = (char *)"radio";
#line 268
  channel_name[24] = (char *)"monitor";
#line 269
  channel_label[0] = (char *)"Vol  ";
#line 269
  channel_label[1] = (char *)"Bass ";
#line 269
  channel_label[2] = (char *)"Trebl";
#line 269
  channel_label[3] = (char *)"Synth";
#line 269
  channel_label[4] = (char *)"Pcm  ";
#line 269
  channel_label[5] = (char *)"Spkr ";
#line 269
  channel_label[6] = (char *)"Line ";
#line 269
  channel_label[7] = (char *)"Mic  ";
#line 269
  channel_label[8] = (char *)"CD   ";
#line 269
  channel_label[9] = (char *)"Mix  ";
#line 269
  channel_label[10] = (char *)"Pcm2 ";
#line 269
  channel_label[11] = (char *)"Rec  ";
#line 269
  channel_label[12] = (char *)"IGain";
#line 269
  channel_label[13] = (char *)"OGain";
#line 269
  channel_label[14] = (char *)"Line1";
#line 269
  channel_label[15] = (char *)"Line2";
#line 269
  channel_label[16] = (char *)"Line3";
#line 269
  channel_label[17] = (char *)"Digital1";
#line 269
  channel_label[18] = (char *)"Digital2";
#line 269
  channel_label[19] = (char *)"Digital3";
#line 269
  channel_label[20] = (char *)"PhoneIn";
#line 269
  channel_label[21] = (char *)"PhoneOut";
#line 269
  channel_label[22] = (char *)"Video";
#line 269
  channel_label[23] = (char *)"Radio";
#line 269
  channel_label[24] = (char *)"Monitor";
#line 272
  tmp = gom_driver_C((int )c);
  }
#line 272
  if (tmp > -1) {
#line 274
    if (label) {
#line 275
      return (channel_label[c]);
    } else {
#line 277
      return (channel_name[c]);
    }
  } else {
#line 280
    return (unexistent);
  }
}
}
#line 287 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_driver_oss.c"
int gom_driver_c(int c ) 
{ 
  int tmp ;
  unsigned int tmp___0 ;

  {
#line 289
  if (gom_driver_oss.c.opened) {
    {
#line 289
    tmp___0 = gom_driver_private_getbits(gom_driver_oss.c.channelmask, c, 1);
    }
#line 289
    if (tmp___0) {
      {
#line 290
      tmp = gom_driver_C(c);
      }
#line 290
      return (tmp);
    } else {
#line 292
      return (-1);
    }
  } else {
#line 292
    return (-1);
  }
}
}
#line 295 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_driver_oss.c"
int gom_driver_c_first(void) 
{ 
  int c ;
  int tmp ;

  {
  {
#line 298
  c = gom_driver_C_first();
  }
  {
#line 298
  while (1) {
    while_continue: /* CIL Label */ ;
#line 298
    if (c > -1) {
      {
#line 298
      tmp = gom_driver_c(c);
      }
#line 298
      if (! (tmp < 0)) {
#line 298
        goto while_break;
      }
    } else {
#line 298
      goto while_break;
    }
    {
#line 298
    c = gom_driver_C_next(c, 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 301
  return (c);
}
}
#line 304 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_driver_oss.c"
int gom_driver_c_last(void) 
{ 
  int c ;
  int tmp ;

  {
  {
#line 307
  c = gom_driver_C_last();
  }
  {
#line 307
  while (1) {
    while_continue: /* CIL Label */ ;
#line 307
    if (c > -1) {
      {
#line 307
      tmp = gom_driver_c(c);
      }
#line 307
      if (! (tmp < 0)) {
#line 307
        goto while_break;
      }
    } else {
#line 307
      goto while_break;
    }
    {
#line 307
    c = gom_driver_C_next(c, -1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 310
  return (c);
}
}
#line 313 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_driver_oss.c"
int gom_driver_c_next(int c , int jump ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 315
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 316
    c = gom_driver_C_next(c, jump);
#line 315
    tmp = gom_driver_C(c);
    }
#line 315
    if (tmp > -1) {
      {
#line 315
      tmp___0 = gom_driver_c(c);
      }
#line 315
      if (! (tmp___0 < 0)) {
#line 315
        goto while_break;
      }
    } else {
#line 315
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 318
  return (c);
}
}
#line 321 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_driver_oss.c"
int gom_driver_c_len(void) 
{ 
  int i ;
  int avail_channels ;

  {
  {
#line 323
  avail_channels = 0;
#line 325
  i = gom_driver_c_first();
  }
  {
#line 325
  while (1) {
    while_continue: /* CIL Label */ ;
#line 325
    if (! (i != -1)) {
#line 325
      goto while_break;
    }
    {
#line 328
    avail_channels ++;
#line 325
    i = gom_driver_c_next(i, 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 329
  return (avail_channels);
}
}
#line 334 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_driver_oss.c"
static char unavailable[12]  = 
#line 334
  {      (char )'u',      (char )'n',      (char )'a',      (char )'v', 
        (char )'a',      (char )'i',      (char )'l',      (char )'a', 
        (char )'b',      (char )'l',      (char )'e',      (char )'\000'};
#line 332 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_driver_oss.c"
char *gom_driver_c_name(int c , int label ) 
{ 
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 336
  tmp___0 = gom_driver_c(c);
  }
#line 336
  if (tmp___0 < 0) {
#line 337
    return (unavailable);
  } else {
    {
#line 339
    tmp = gom_driver_C_name((unsigned int )c, label);
    }
#line 339
    return (tmp);
  }
}
}
#line 346 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_driver_oss.c"
int gom_driver_C_C(int c , int cc ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 348
  tmp = gom_driver_C(c);
  }
#line 348
  if (tmp > -1) {
    {
#line 348
    tmp___0 = gom_driver_C_C_first(c);
    }
#line 348
    if (cc >= tmp___0) {
      {
#line 348
      tmp___1 = gom_driver_C_C_last(c);
      }
#line 348
      if (cc <= tmp___1) {
#line 350
        return (cc);
      } else {
#line 352
        return (-1);
      }
    } else {
#line 352
      return (-1);
    }
  } else {
#line 352
    return (-1);
  }
}
}
#line 355 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_driver_oss.c"
int gom_driver_C_C_first(int c ) 
{ 


  {
#line 357
  return (0);
}
}
#line 360 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_driver_oss.c"
int gom_driver_C_C_last(int c ) 
{ 
  int tmp ;

  {
  {
#line 362
  tmp = gom_driver_C_C_len(c);
  }
#line 362
  return (tmp - 1);
}
}
#line 365 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_driver_oss.c"
int gom_driver_C_C_next(int c , int cc , int jump ) 
{ 
  int tmp ;

  {
  {
#line 367
  tmp = gom_driver_C_C(c, cc + jump);
  }
#line 367
  return (tmp);
}
}
#line 370 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_driver_oss.c"
int gom_driver_C_C_len(int c ) 
{ 
  int tmp ;

  {
  {
#line 372
  tmp = gom_driver_C(c);
  }
#line 372
  if (tmp > -1) {
#line 374
    return (2);
  } else {
#line 376
    return (-1);
  }
}
}
#line 383 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_driver_oss.c"
int gom_driver_c_c(int c , int cc ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 385
  tmp = gom_driver_c(c);
  }
#line 385
  if (tmp > -1) {
    {
#line 385
    tmp___0 = gom_driver_c_c_first(c);
    }
#line 385
    if (cc >= tmp___0) {
      {
#line 385
      tmp___1 = gom_driver_c_c_last(c);
      }
#line 385
      if (cc <= tmp___1) {
#line 387
        return (cc);
      } else {
#line 389
        return (-1);
      }
    } else {
#line 389
      return (-1);
    }
  } else {
#line 389
    return (-1);
  }
}
}
#line 392 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_driver_oss.c"
int gom_driver_c_c_first(int c ) 
{ 


  {
#line 394
  return (0);
}
}
#line 397 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_driver_oss.c"
int gom_driver_c_c_last(int c ) 
{ 
  int tmp ;

  {
  {
#line 399
  tmp = gom_driver_c_c_len(c);
  }
#line 399
  return (tmp - 1);
}
}
#line 402 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_driver_oss.c"
int gom_driver_c_c_next(int c , int cc , int jump ) 
{ 
  int tmp ;

  {
  {
#line 404
  tmp = gom_driver_c_c(c, cc + jump);
  }
#line 404
  return (tmp);
}
}
#line 407 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_driver_oss.c"
int gom_driver_c_c_len(int c ) 
{ 
  unsigned int tmp ;
  int tmp___0 ;

  {
  {
#line 409
  tmp___0 = gom_driver_c(c);
  }
#line 409
  if (tmp___0 > -1) {
    {
#line 411
    tmp = gom_driver_private_getbits(gom_driver_oss.c.stereomask, c, 1);
    }
#line 411
    return ((int )(1U + tmp));
  } else {
#line 413
    return (-1);
  }
}
}
#line 419 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_driver_oss.c"
int gom_driver_c_c_v_max(void) 
{ 


  {
#line 421
  return (100);
}
}
#line 424 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_driver_oss.c"
int gom_driver_c_c_v_range(int v ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 426
  if (v > -1) {
    {
#line 426
    tmp___0 = gom_driver_c_c_v_max();
    }
#line 426
    if (v <= tmp___0) {
#line 427
      return (v);
    } else {
      {
#line 430
      tmp = gom_driver_c_c_v_max();
#line 430
      gom_info((enum gom_info_types )-1, (char *)"Requested volume (%d) out of range (allowed range: 0 =< volume <= %d).",
               v, tmp);
      }
#line 433
      return (-1);
    }
  } else {
    {
#line 430
    tmp = gom_driver_c_c_v_max();
#line 430
    gom_info((enum gom_info_types )-1, (char *)"Requested volume (%d) out of range (allowed range: 0 =< volume <= %d).",
             v, tmp);
    }
#line 433
    return (-1);
  }
}
}
#line 437 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_driver_oss.c"
int gom_driver_c_c_v(int c , int cc ) 
{ 
  int volume ;
  unsigned int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 439
  volume = 0;
#line 441
  tmp___2 = gom_driver_c_c(c, cc);
  }
#line 441
  if (tmp___2 > -1) {
    {
#line 443
    tmp___1 = ioctl(gom_driver_oss.c.fd, (unsigned long )(((2U << 30) | (unsigned int )(77 << 8)) | (unsigned int )c) | (sizeof(int ) << 16),
                    & volume);
    }
#line 443
    if (tmp___1 != -1) {
      {
#line 445
      tmp = gom_driver_private_getbits((unsigned int )volume, 8 * (cc + 1) - 1, 8);
      }
#line 445
      return ((int )tmp);
    } else {
      {
#line 449
      tmp___0 = gom_driver_C_name((unsigned int )c, 0);
#line 449
      gom_info((enum gom_info_types )-1, (char *)"Bug (gom_driver_c_c_v): Can\'t read volume on %d(%s).",
               c, tmp___0);
      }
    }
  }
#line 454
  return (-1);
}
}
#line 459 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_driver_oss.c"
void gom_driver_c_c_v_set(enum gom_info_types std_verb , int c , int cc , int v ) 
{ 
  int coded_volume ;
  int old_v ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;

  {
  {
#line 463
  tmp = gom_driver_c_c_v(c, cc);
#line 463
  old_v = tmp;
#line 464
  v = gom_driver_c_c_v_range(v);
  }
#line 466
  if (old_v < 0) {
    {
#line 468
    tmp___0 = gom_driver_C_name((unsigned int )c, 0);
#line 468
    gom_info((enum gom_info_types )-1, (char *)"Can\'t set volume %d on channel %d(%s): not available.",
             cc, c, tmp___0);
    }
  } else
#line 473
  if (! (v < 0)) {
    {
#line 479
    old_v = gom_driver_c_c_v(c, cc);
    }
#line 483
    if (cc == 0) {
      {
#line 485
      tmp___1 = gom_driver_c_c_v(c, 1);
#line 485
      coded_volume = v | (tmp___1 << 8);
      }
    } else
#line 486
    if (cc == 1) {
      {
#line 488
      tmp___2 = gom_driver_c_c_v(c, 0);
#line 488
      coded_volume = tmp___2 | (v << 8);
      }
    } else {
      {
#line 490
      gom_info((enum gom_info_types )-1, (char *)"Bug (gom_driver_c_c_v_set): cc too big.");
      }
    }
    {
#line 493
    tmp___6 = ioctl(gom_driver_oss.c.fd, (unsigned long )(((3U << 30) | (unsigned int )(77 << 8)) | (unsigned int )c) | (sizeof(int ) << 16),
                    & coded_volume);
    }
#line 493
    if (tmp___6 != -1) {
      {
#line 495
      tmp___3 = gom_driver_c_c_v(c, cc);
#line 495
      tmp___4 = gom_driver_C_name((unsigned int )c, 0);
#line 495
      gom_info(std_verb, (char *)"Volume %d on channel %d(%s) set to %i (from %i).",
               cc, c, tmp___4, tmp___3, old_v);
      }
    } else {
      {
#line 503
      tmp___5 = gom_driver_C_name((unsigned int )c, 0);
#line 503
      gom_info((enum gom_info_types )-1, (char *)"Bug (gom_driver_c_c_v_set): Can\'t write volume to mixer device though available (channel %d(%s)).",
               c, tmp___5);
      }
    }
  }
#line 508
  return;
}
}
#line 514 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_driver_oss.c"
int gom_driver_c_r(int c ) 
{ 
  unsigned int recsrc ;
  int tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;

  {
  {
#line 517
  tmp___1 = gom_driver_c(c);
  }
#line 517
  if (tmp___1 > -1) {
    {
#line 517
    tmp___2 = gom_driver_private_getbits(gom_driver_oss.c.recmask, c, 1);
    }
#line 517
    if (tmp___2) {
      {
#line 519
      tmp = ioctl(gom_driver_oss.c.fd, (unsigned long )(((2U << 30) | (unsigned int )(77 << 8)) | 255U) | (sizeof(int ) << 16),
                  & recsrc);
      }
#line 519
      if (tmp == -1) {
        {
#line 520
        gom_info((enum gom_info_types )-1, (char *)"Bug (gom_driver_c_r): Can\'t read recording source mask from mixer.");
        }
      }
      {
#line 521
      tmp___0 = gom_driver_private_getbits(recsrc, c, 1);
      }
#line 521
      return ((int )tmp___0);
    } else {
#line 524
      return (-1);
    }
  } else {
#line 524
    return (-1);
  }
}
}
#line 527 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_driver_oss.c"
void gom_driver_c_r_set(enum gom_info_types std_verb , int c , int r ) 
{ 
  unsigned int recsrc ;
  int old_r ;
  int tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char const   *tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;

  {
  {
#line 531
  tmp = gom_driver_c_r(c);
#line 531
  old_r = tmp;
  }
#line 533
  if (old_r > -1) {
    {
#line 535
    ioctl(gom_driver_oss.c.fd, (unsigned long )(((2U << 30) | (unsigned int )(77 << 8)) | 255U) | (sizeof(int ) << 16),
          & recsrc);
#line 536
    recsrc = gom_driver_private_setbit(recsrc, c, r);
    }
#line 538
    if (recsrc != 0U) {
      {
#line 539
      ioctl(gom_driver_oss.c.fd, (unsigned long )(((3U << 30) | (unsigned int )(77 << 8)) | 255U) | (sizeof(int ) << 16),
            & recsrc);
      }
    }
    {
#line 541
    tmp___4 = gom_driver_c_r(c);
    }
#line 541
    if (tmp___4 == r) {
      {
#line 543
      tmp___0 = gom_driver_C_name((unsigned int )c, 0);
      }
#line 543
      if (r) {
#line 543
        tmp___1 = "on";
      } else {
#line 543
        tmp___1 = "off";
      }
      {
#line 543
      gom_info(std_verb, (char *)"Recording %s for channel %d(%s).", tmp___1, c, tmp___0);
      }
    } else {
#line 550
      if (r) {
#line 550
        tmp___2 = "on";
      } else {
#line 550
        tmp___2 = "off";
      }
      {
#line 550
      tmp___3 = gom_driver_C_name((unsigned int )c, 0);
#line 550
      gom_info((enum gom_info_types )-1, (char *)"Can\'t set recording for channel %d(%s) to %s: %s.",
               c, tmp___3, tmp___2, "maybe last recording source");
      }
    }
  } else {
    {
#line 559
    tmp___10 = gom_driver_c(c);
    }
#line 559
    if (tmp___10 < 0) {
#line 559
      tmp___9 = "unavailable";
    } else {
      {
#line 559
      tmp___8 = gom_driver_c_r(c);
      }
#line 559
      if (tmp___8 < 0) {
#line 559
        tmp___7 = "unrecordable";
      } else {
#line 559
        tmp___7 = "*bug*";
      }
#line 559
      tmp___9 = tmp___7;
    }
    {
#line 559
    tmp___11 = gom_driver_C_name((unsigned int )c, 0);
#line 559
    gom_info((enum gom_info_types )-1, (char *)"Can\'t set recording for channel %d(%s): %s.",
             c, tmp___11, tmp___9);
    }
  }
#line 564
  return;
}
}
#line 431 "/usr/include/stdio.h"
extern int scanf(char const   * __restrict  __format  , ...)  __asm__("__isoc99_scanf")  ;
#line 127 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 48 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_iface_c.c"
char *gom_iface_c_get_option_args(char *prompt ) 
{ 


  {
#line 51
  return (optarg);
}
}
#line 54 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_iface_c.c"
int gom_iface_c_question(char *question ) 
{ 
  char answer ;
  int tmp ;

  {
  {
#line 58
  gom_info((enum gom_info_types )0, (char *)"%s %s ", "[y|Y = yes, else no]", question);
#line 59
  scanf((char const   */* __restrict  */)"%c", & answer);
#line 60
  tmp = toupper((int )answer);
  }
#line 60
  return (tmp == 89);
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/gom-0.30.2/src/gom_iface_c.c"
void gom_iface_c(int argc , char **argv ) 
{ 
  int action ;
  int ignore_config ;

  {
  {
#line 68
  action = 0;
#line 69
  ignore_config = 0;
#line 72
  gom_info_custom_set((void (*)(enum gom_info_types  , char * , va_list  ))((void *)0));
  }
#line 74
  if (argc == 1) {
    {
#line 77
    gom_info((enum gom_info_types )0, (char *)"You must specify an option.");
#line 78
    gom_info((enum gom_info_types )0, (char *)"Try `gom -h, --help, -H, --help-verbose\' or `man gom\' for help.");
    }
  } else {
    {
#line 83
    action = gom_action_getopt(argc, (char * const  *)argv);
    }
    {
#line 88
    while (1) {
      while_continue: /* CIL Label */ ;
#line 88
      if (! (action == 118)) {
#line 88
        if (! (action == 113)) {
#line 88
          if (! (action == 89)) {
#line 88
            if (! (action == 86)) {
#line 88
              if (! (action == 119)) {
#line 88
                if (! (action == 104)) {
#line 88
                  if (! (action == 72)) {
#line 88
                    goto while_break;
                  }
                }
              }
            }
          }
        }
      }
#line 91
      if (action == 89) {
#line 92
        ignore_config = 1;
      } else {
        {
#line 94
        gom_action((enum gom_info_types )1, (char )action, 1, & gom_iface_c_get_option_args,
                   (void (*)())((void *)0), (void (*)())((void *)0));
        }
      }
      {
#line 95
      action = gom_action_getopt(argc, (char * const  *)argv);
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 100
    if (ignore_config) {
      {
#line 101
      gom_info((enum gom_info_types )1, (char *)"Explicitely ignoring automatic configuration \'gom\' and \'default_mixer\'.");
      }
    } else
#line 103
    if (action != -1) {
      {
#line 105
      gom_file_load((enum gom_info_types )2, (char *)"gom", 0, (char *)"vqFU");
#line 107
      gom_file_load((enum gom_info_types )2, (char *)"default_mixer", 0, (char *)"d");
      }
    }
    {
#line 112
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 112
      if (! (action != -1)) {
#line 112
        goto while_break___0;
      }
      {
#line 114
      gom_action((enum gom_info_types )1, (char )action, 1, & gom_iface_c_get_option_args,
                 (void (*)())((void *)0), (void (*)())((void *)0));
#line 115
      action = gom_action_getopt(argc, (char * const  *)argv);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 118
  return;
}
}
