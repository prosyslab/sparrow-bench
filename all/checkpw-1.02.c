/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 4 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/buffer.h"
struct buffer {
   char *x ;
   unsigned int p ;
   unsigned int n ;
   int fd ;
   int (*op)() ;
};
#line 4 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/buffer.h"
typedef struct buffer buffer;
#line 6 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/stralloc.h"
struct stralloc {
   char *s ;
   unsigned int len ;
   unsigned int a ;
};
#line 6 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/stralloc.h"
typedef struct stralloc stralloc;
#line 9 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/alloc.c"
union __anonunion_aligned_1 {
   char irrelevant[16] ;
   double d ;
};
#line 9 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/alloc.c"
typedef union __anonunion_aligned_1 aligned;
#line 4 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/strerr.h"
struct strerr {
   struct strerr *who ;
   char *x ;
   char *y ;
   char *z ;
};
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 4 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/substdio.h"
struct substdio {
   char *x ;
   int p ;
   int n ;
   int fd ;
   int (*op)() ;
};
#line 4 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/substdio.h"
typedef struct substdio substdio;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 15 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/global.h"
typedef unsigned char *POINTER;
#line 21 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/global.h"
typedef uint32_t UINT4;
#line 27 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/md5.h"
struct __anonstruct_MD5_CTX_2 {
   UINT4 state[4] ;
   UINT4 count[2] ;
   unsigned char buffer[64] ;
};
#line 27 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/md5.h"
typedef struct __anonstruct_MD5_CTX_2 MD5_CTX;
#line 4 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/alloc.h"
char *alloc(unsigned int n ) ;
#line 5
void alloc_free(char *x ) ;
#line 6
int alloc_re(char **x , unsigned int m , unsigned int n ) ;
#line 6 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/byte.h"
void byte_copy(char *to , unsigned int n , char *from ) ;
#line 4 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/alloc_re.c"
int alloc_re(char **x , unsigned int m , unsigned int n ) 
{ 
  char *y ;

  {
  {
#line 11
  y = alloc(n);
  }
#line 12
  if (! y) {
#line 12
    return (0);
  }
  {
#line 13
  byte_copy(y, m, *x);
#line 14
  alloc_free(*x);
#line 15
  *x = y;
  }
#line 16
  return (1);
}
}
#line 19 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/buffer.h"
int buffer_put(buffer *s , char *buf , unsigned int len ) ;
#line 34
int buffer_feed(buffer *s ) ;
#line 48
int buffer_copy(buffer *bout , buffer *bin ) ;
#line 3 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/buffer_copy.c"
int buffer_copy(buffer *bout , buffer *bin ) 
{ 
  int n ;
  char *x ;
  int tmp___3 ;

  {
  {
#line 8
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 9
    n = buffer_feed(bin);
    }
#line 10
    if (n < 0) {
#line 10
      return (-2);
    }
#line 11
    if (! n) {
#line 11
      return (0);
    }
    {
#line 12
    x = bin->x + bin->n;
#line 13
    tmp___3 = buffer_put(bout, x, (unsigned int )n);
    }
#line 13
    if (tmp___3 == -1) {
#line 13
      return (-3);
    }
#line 14
    bin->p -= (unsigned int )n;
#line 14
    bin->n += (unsigned int )n;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 6 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/error.h"
int error_intr ;
#line 7
int error_nomem ;
#line 8
int error_noent ;
#line 9
int error_txtbsy ;
#line 10
int error_io ;
#line 11
int error_exist ;
#line 12
int error_timeout ;
#line 13
int error_inprogress ;
#line 14
int error_wouldblock ;
#line 15
int error_again ;
#line 16
int error_pipe ;
#line 17
int error_perm ;
#line 18
int error_acces ;
#line 19
int error_nodevice ;
#line 20
int error_proto ;
#line 21
int error_isdir ;
#line 22
int error_connrefused ;
#line 24
char *error_str(int i ) ;
#line 6 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/error_str.c"
char *error_str(int i ) 
{ 


  {
#line 8
  if (i == 0) {
#line 8
    return ((char *)"no error");
  }
#line 9
  if (i == error_intr) {
#line 9
    return ((char *)"interrupted system call");
  }
#line 10
  if (i == error_nomem) {
#line 10
    return ((char *)"out of memory");
  }
#line 11
  if (i == error_noent) {
#line 11
    return ((char *)"file does not exist");
  }
#line 12
  if (i == error_txtbsy) {
#line 12
    return ((char *)"text busy");
  }
#line 13
  if (i == error_io) {
#line 13
    return ((char *)"input/output error");
  }
#line 14
  if (i == error_exist) {
#line 14
    return ((char *)"file already exists");
  }
#line 15
  if (i == error_timeout) {
#line 15
    return ((char *)"timed out");
  }
#line 16
  if (i == error_inprogress) {
#line 16
    return ((char *)"operation in progress");
  }
#line 17
  if (i == error_again) {
#line 17
    return ((char *)"temporary failure");
  }
#line 18
  if (i == error_wouldblock) {
#line 18
    return ((char *)"input/output would block");
  }
#line 19
  if (i == error_pipe) {
#line 19
    return ((char *)"broken pipe");
  }
#line 20
  if (i == error_perm) {
#line 20
    return ((char *)"permission denied");
  }
#line 21
  if (i == error_acces) {
#line 21
    return ((char *)"access denied");
  }
#line 22
  if (i == error_nodevice) {
#line 22
    return ((char *)"device not configured");
  }
#line 23
  if (i == error_proto) {
#line 23
    return ((char *)"protocol error");
  }
#line 24
  if (i == error_isdir) {
#line 24
    return ((char *)"is a directory");
  }
#line 25
  if (i == error_connrefused) {
#line 25
    return ((char *)"connection refused");
  }
#line 27
  if (i == 3) {
#line 27
    return ((char *)"no such process");
  }
#line 30
  if (i == 7) {
#line 30
    return ((char *)"argument list too long");
  }
#line 33
  if (i == 8) {
#line 33
    return ((char *)"exec format error");
  }
#line 36
  if (i == 9) {
#line 36
    return ((char *)"file descriptor not open");
  }
#line 39
  if (i == 10) {
#line 39
    return ((char *)"no child processes");
  }
#line 42
  if (i == 35) {
#line 42
    return ((char *)"operation would cause deadlock");
  }
#line 45
  if (i == 14) {
#line 45
    return ((char *)"bad address");
  }
#line 48
  if (i == 15) {
#line 48
    return ((char *)"not a block device");
  }
#line 51
  if (i == 16) {
#line 51
    return ((char *)"device busy");
  }
#line 54
  if (i == 18) {
#line 54
    return ((char *)"cross-device link");
  }
#line 57
  if (i == 19) {
#line 57
    return ((char *)"device does not support operation");
  }
#line 60
  if (i == 20) {
#line 60
    return ((char *)"not a directory");
  }
#line 63
  if (i == 22) {
#line 63
    return ((char *)"invalid argument");
  }
#line 66
  if (i == 23) {
#line 66
    return ((char *)"system cannot open more files");
  }
#line 69
  if (i == 24) {
#line 69
    return ((char *)"process cannot open more files");
  }
#line 72
  if (i == 25) {
#line 72
    return ((char *)"not a tty");
  }
#line 75
  if (i == 27) {
#line 75
    return ((char *)"file too big");
  }
#line 78
  if (i == 28) {
#line 78
    return ((char *)"out of disk space");
  }
#line 81
  if (i == 29) {
#line 81
    return ((char *)"unseekable descriptor");
  }
#line 84
  if (i == 30) {
#line 84
    return ((char *)"read-only file system");
  }
#line 87
  if (i == 31) {
#line 87
    return ((char *)"too many links");
  }
#line 90
  if (i == 33) {
#line 90
    return ((char *)"input out of range");
  }
#line 93
  if (i == 34) {
#line 93
    return ((char *)"output out of range");
  }
#line 96
  if (i == 114) {
#line 96
    return ((char *)"operation already in progress");
  }
#line 99
  if (i == 88) {
#line 99
    return ((char *)"not a socket");
  }
#line 102
  if (i == 89) {
#line 102
    return ((char *)"destination address required");
  }
#line 105
  if (i == 90) {
#line 105
    return ((char *)"message too long");
  }
#line 108
  if (i == 91) {
#line 108
    return ((char *)"incorrect protocol type");
  }
#line 111
  if (i == 92) {
#line 111
    return ((char *)"protocol not available");
  }
#line 114
  if (i == 93) {
#line 114
    return ((char *)"protocol not supported");
  }
#line 117
  if (i == 94) {
#line 117
    return ((char *)"socket type not supported");
  }
#line 120
  if (i == 95) {
#line 120
    return ((char *)"operation not supported");
  }
#line 123
  if (i == 96) {
#line 123
    return ((char *)"protocol family not supported");
  }
#line 126
  if (i == 97) {
#line 126
    return ((char *)"address family not supported");
  }
#line 129
  if (i == 98) {
#line 129
    return ((char *)"address already used");
  }
#line 132
  if (i == 99) {
#line 132
    return ((char *)"address not available");
  }
#line 135
  if (i == 100) {
#line 135
    return ((char *)"network down");
  }
#line 138
  if (i == 101) {
#line 138
    return ((char *)"network unreachable");
  }
#line 141
  if (i == 102) {
#line 141
    return ((char *)"network reset");
  }
#line 144
  if (i == 103) {
#line 144
    return ((char *)"connection aborted");
  }
#line 147
  if (i == 104) {
#line 147
    return ((char *)"connection reset");
  }
#line 150
  if (i == 105) {
#line 150
    return ((char *)"out of buffer space");
  }
#line 153
  if (i == 106) {
#line 153
    return ((char *)"already connected");
  }
#line 156
  if (i == 107) {
#line 156
    return ((char *)"not connected");
  }
#line 159
  if (i == 108) {
#line 159
    return ((char *)"socket shut down");
  }
#line 162
  if (i == 109) {
#line 162
    return ((char *)"too many references");
  }
#line 165
  if (i == 40) {
#line 165
    return ((char *)"symbolic link loop");
  }
#line 168
  if (i == 36) {
#line 168
    return ((char *)"file name too long");
  }
#line 171
  if (i == 112) {
#line 171
    return ((char *)"host down");
  }
#line 174
  if (i == 113) {
#line 174
    return ((char *)"host unreachable");
  }
#line 177
  if (i == 39) {
#line 177
    return ((char *)"directory not empty");
  }
#line 183
  if (i == 87) {
#line 183
    return ((char *)"too many users");
  }
#line 186
  if (i == 122) {
#line 186
    return ((char *)"disk quota exceeded");
  }
#line 189
  if (i == 116) {
#line 189
    return ((char *)"stale NFS file handle");
  }
#line 192
  if (i == 66) {
#line 192
    return ((char *)"too many levels of remote in path");
  }
#line 210
  if (i == 37) {
#line 210
    return ((char *)"no locks available");
  }
#line 213
  if (i == 38) {
#line 213
    return ((char *)"system call not available");
  }
#line 225
  if (i == 60) {
#line 225
    return ((char *)"not a stream device");
  }
#line 228
  if (i == 62) {
#line 228
    return ((char *)"timer expired");
  }
#line 231
  if (i == 63) {
#line 231
    return ((char *)"out of stream resources");
  }
#line 234
  if (i == 42) {
#line 234
    return ((char *)"no message of desired type");
  }
#line 237
  if (i == 74) {
#line 237
    return ((char *)"bad message type");
  }
#line 240
  if (i == 43) {
#line 240
    return ((char *)"identifier removed");
  }
#line 243
  if (i == 64) {
#line 243
    return ((char *)"machine not on network");
  }
#line 249
  if (i == 67) {
#line 249
    return ((char *)"link severed");
  }
#line 252
  if (i == 68) {
#line 252
    return ((char *)"advertise error");
  }
#line 255
  if (i == 69) {
#line 255
    return ((char *)"srmount error");
  }
#line 258
  if (i == 70) {
#line 258
    return ((char *)"communication error");
  }
#line 261
  if (i == 72) {
#line 261
    return ((char *)"multihop attempted");
  }
#line 264
  if (i == 78) {
#line 264
    return ((char *)"remote address changed");
  }
#line 266
  return ((char *)"unknown error");
}
}
#line 6 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/error.c"
int error_intr  =    4;
#line 13 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/error.c"
int error_nomem  =    12;
#line 20 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/error.c"
int error_noent  =    2;
#line 27 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/error.c"
int error_txtbsy  =    26;
#line 34 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/error.c"
int error_io  =    5;
#line 41 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/error.c"
int error_exist  =    17;
#line 48 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/error.c"
int error_timeout  =    110;
#line 55 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/error.c"
int error_inprogress  =    115;
#line 62 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/error.c"
int error_wouldblock  =    11;
#line 69 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/error.c"
int error_again  =    11;
#line 76 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/error.c"
int error_pipe  =    32;
#line 83 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/error.c"
int error_perm  =    1;
#line 90 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/error.c"
int error_acces  =    13;
#line 97 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/error.c"
int error_nodevice  =    6;
#line 104 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/error.c"
int error_proto  =    71;
#line 111 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/error.c"
int error_isdir  =    21;
#line 118 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/error.c"
int error_connrefused  =    111;
#line 5 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/readwrite.h"
extern int write() ;
#line 54 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/buffer.h"
buffer *buffer_2 ;
#line 4 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/buffer_2.c"
char buffer_2_space[256]  ;
#line 5 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/buffer_2.c"
static buffer it  =    {buffer_2_space, 0U, (unsigned int )sizeof(buffer_2_space), 2, & write};
#line 6 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/buffer_2.c"
buffer *buffer_2  =    & it;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 4 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/open.h"
int open_read(char *fn ) ;
#line 7 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/readclose.h"
extern int readclose(int  , stralloc * , unsigned int  ) ;
#line 6 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/openreadclose.h"
int openreadclose(char const   *fn , stralloc *sa , unsigned int bufsize ) ;
#line 6 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/openreadclose.c"
int openreadclose(char const   *fn , stralloc *sa , unsigned int bufsize ) 
{ 
  int fd ;
  int *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 9
  fd = open_read((char *)fn);
  }
#line 10
  if (fd == -1) {
    {
#line 11
    tmp___3 = __errno_location();
    }
#line 11
    if (*tmp___3 == error_noent) {
#line 11
      return (0);
    }
#line 12
    return (-1);
  }
  {
#line 14
  tmp___4 = readclose(fd, sa, bufsize);
  }
#line 14
  if (tmp___4 == -1) {
#line 14
    return (-1);
  }
#line 15
  return (1);
}
}
#line 11 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/stralloc.h"
extern int stralloc_cat(stralloc * , stralloc * ) ;
#line 12
extern int stralloc_copys(stralloc * , char * ) ;
#line 13
extern int stralloc_cats(stralloc * , char * ) ;
#line 16
extern int stralloc_append(stralloc * , char * ) ;
#line 8 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/str.h"
extern unsigned int str_chr(char * , int  ) ;
#line 8 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/byte.h"
int byte_diff(char *s , unsigned int n , char *t ) ;
#line 4 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/env.h"
extern char **environ ;
#line 4 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/pathexec.h"
void pathexec_run(char *file , char **argv , char **envp ) ;
#line 5
int pathexec_env(char *s , char *t ) ;
#line 6
void pathexec(char **argv ) ;
#line 8 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/pathexec_env.c"
static stralloc plus  ;
#line 9 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/pathexec_env.c"
static stralloc tmp  ;
#line 11 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/pathexec_env.c"
int pathexec_env(char *s , char *t ) 
{ 
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 13
  if (! s) {
#line 13
    return (1);
  }
  {
#line 14
  tmp___3 = stralloc_copys(& tmp, s);
  }
#line 14
  if (! tmp___3) {
#line 14
    return (0);
  }
#line 15
  if (t) {
    {
#line 16
    tmp___4 = stralloc_cats(& tmp, (char *)"=");
    }
#line 16
    if (! tmp___4) {
#line 16
      return (0);
    }
    {
#line 17
    tmp___5 = stralloc_cats(& tmp, t);
    }
#line 17
    if (! tmp___5) {
#line 17
      return (0);
    }
  }
  {
#line 19
  tmp___6 = stralloc_append(& tmp, (char *)"");
  }
#line 19
  if (! tmp___6) {
#line 19
    return (0);
  }
  {
#line 20
  tmp___7 = stralloc_cat(& plus, & tmp);
  }
#line 20
  return (tmp___7);
}
}
#line 23 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/pathexec_env.c"
void pathexec(char **argv ) 
{ 
  char **e ;
  unsigned int elen ;
  unsigned int i ;
  unsigned int j ;
  unsigned int split ;
  unsigned int t ;
  int tmp___3 ;
  char *tmp___4 ;
  unsigned int tmp___5 ;
  int tmp___6 ;
  unsigned int tmp___7 ;

  {
  {
#line 33
  tmp___3 = stralloc_cats(& plus, (char *)"");
  }
#line 33
  if (! tmp___3) {
#line 33
    return;
  }
#line 35
  elen = 0U;
#line 36
  i = 0U;
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
#line 36
    if (! *(environ + i)) {
#line 36
      goto while_break;
    }
#line 37
    elen ++;
#line 36
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 38
  i = 0U;
  {
#line 38
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 38
    if (! (i < plus.len)) {
#line 38
      goto while_break___0;
    }
#line 39
    if (! *(plus.s + i)) {
#line 40
      elen ++;
    }
#line 38
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 42
  tmp___4 = alloc((unsigned long )(elen + 1U) * sizeof(char *));
#line 42
  e = (char **)tmp___4;
  }
#line 43
  if (! e) {
#line 43
    return;
  }
#line 45
  elen = 0U;
#line 46
  i = 0U;
  {
#line 46
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 46
    if (! *(environ + i)) {
#line 46
      goto while_break___1;
    }
#line 47
    tmp___5 = elen;
#line 47
    elen ++;
#line 47
    *(e + tmp___5) = *(environ + i);
#line 46
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 49
  j = 0U;
#line 50
  i = 0U;
  {
#line 50
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 50
    if (! (i < plus.len)) {
#line 50
      goto while_break___2;
    }
#line 51
    if (! *(plus.s + i)) {
      {
#line 52
      split = str_chr(plus.s + j, '=');
#line 53
      t = 0U;
      }
      {
#line 53
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 53
        if (! (t < elen)) {
#line 53
          goto while_break___3;
        }
        {
#line 54
        tmp___6 = byte_diff(plus.s + j, split, *(e + t));
        }
#line 54
        if (! tmp___6) {
#line 55
          if ((int )*(*(e + t) + split) == 61) {
#line 56
            elen --;
#line 57
            *(e + t) = *(e + elen);
#line 58
            goto while_break___3;
          }
        }
#line 53
        t ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 60
      if (*(plus.s + (j + split))) {
#line 61
        tmp___7 = elen;
#line 61
        elen ++;
#line 61
        *(e + tmp___7) = plus.s + j;
      }
#line 62
      j = i + 1U;
    }
#line 50
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 64
  *(e + elen) = (char *)0;
#line 66
  pathexec_run(*argv, argv, e);
#line 67
  alloc_free(e);
  }
#line 68
  return;
}
}
#line 18 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/buffer.h"
int buffer_flush(buffer *s ) ;
#line 20
int buffer_putalign(buffer *s , char *buf , unsigned int len ) ;
#line 21
int buffer_putflush(buffer *s , char *buf , unsigned int len ) ;
#line 22
int buffer_puts(buffer *s , char *buf ) ;
#line 23
int buffer_putsalign(buffer *s , char *buf ) ;
#line 24
int buffer_putsflush(buffer *s , char *buf ) ;
#line 7 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/str.h"
extern unsigned int str_len(char * ) ;
#line 6 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/buffer_put.c"
static int allwrite(int (*op)() , int fd , char *buf , unsigned int len ) 
{ 
  int w ;
  int *tmp___3 ;

  {
  {
#line 10
  while (1) {
    while_continue: /* CIL Label */ ;
#line 10
    if (! len) {
#line 10
      goto while_break;
    }
    {
#line 11
    w = (*op)(fd, buf, len);
    }
#line 12
    if (w == -1) {
      {
#line 13
      tmp___3 = __errno_location();
      }
#line 13
      if (*tmp___3 == error_intr) {
#line 13
        goto while_continue;
      }
#line 14
      return (-1);
    }
#line 17
    buf += w;
#line 18
    len -= (unsigned int )w;
  }
  while_break: /* CIL Label */ ;
  }
#line 20
  return (0);
}
}
#line 23 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/buffer_put.c"
int buffer_flush(buffer *s ) 
{ 
  int p___0 ;
  int tmp___3 ;

  {
#line 27
  p___0 = (int )s->p;
#line 28
  if (! p___0) {
#line 28
    return (0);
  }
  {
#line 29
  s->p = 0U;
#line 30
  tmp___3 = allwrite(s->op, s->fd, s->x, (unsigned int )p___0);
  }
#line 30
  return (tmp___3);
}
}
#line 33 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/buffer_put.c"
int buffer_putalign(buffer *s , char *buf , unsigned int len ) 
{ 
  unsigned int n ;
  int tmp___3 ;

  {
  {
#line 37
  while (1) {
    while_continue: /* CIL Label */ ;
#line 37
    n = s->n - s->p;
#line 37
    if (! (len > n)) {
#line 37
      goto while_break;
    }
    {
#line 38
    byte_copy(s->x + s->p, n, buf);
#line 38
    s->p += n;
#line 38
    buf += n;
#line 38
    len -= n;
#line 39
    tmp___3 = buffer_flush(s);
    }
#line 39
    if (tmp___3 == -1) {
#line 39
      return (-1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 42
  byte_copy(s->x + s->p, len, buf);
#line 43
  s->p += len;
  }
#line 44
  return (0);
}
}
#line 47 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/buffer_put.c"
int buffer_put(buffer *s , char *buf , unsigned int len ) 
{ 
  unsigned int n ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 51
  n = s->n;
#line 52
  if (len > n - s->p) {
    {
#line 53
    tmp___3 = buffer_flush(s);
    }
#line 53
    if (tmp___3 == -1) {
#line 53
      return (-1);
    }
#line 55
    if (n < 8192U) {
#line 55
      n = 8192U;
    }
    {
#line 56
    while (1) {
      while_continue: /* CIL Label */ ;
#line 56
      if (! (len > s->n)) {
#line 56
        goto while_break;
      }
#line 57
      if (n > len) {
#line 57
        n = len;
      }
      {
#line 58
      tmp___4 = allwrite(s->op, s->fd, buf, n);
      }
#line 58
      if (tmp___4 == -1) {
#line 58
        return (-1);
      }
#line 59
      buf += n;
#line 60
      len -= n;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 64
  byte_copy(s->x + s->p, len, buf);
#line 65
  s->p += len;
  }
#line 66
  return (0);
}
}
#line 69 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/buffer_put.c"
int buffer_putflush(buffer *s , char *buf , unsigned int len ) 
{ 
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 71
  tmp___3 = buffer_flush(s);
  }
#line 71
  if (tmp___3 == -1) {
#line 71
    return (-1);
  }
  {
#line 72
  tmp___4 = allwrite(s->op, s->fd, buf, len);
  }
#line 72
  return (tmp___4);
}
}
#line 75 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/buffer_put.c"
int buffer_putsalign(buffer *s , char *buf ) 
{ 
  unsigned int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 77
  tmp___3 = str_len(buf);
#line 77
  tmp___4 = buffer_putalign(s, buf, tmp___3);
  }
#line 77
  return (tmp___4);
}
}
#line 80 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/buffer_put.c"
int buffer_puts(buffer *s , char *buf ) 
{ 
  unsigned int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 82
  tmp___3 = str_len(buf);
#line 82
  tmp___4 = buffer_put(s, buf, tmp___3);
  }
#line 82
  return (tmp___4);
}
}
#line 85 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/buffer_put.c"
int buffer_putsflush(buffer *s , char *buf ) 
{ 
  unsigned int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 87
  tmp___3 = str_len(buf);
#line 87
  tmp___4 = buffer_putflush(s, buf, tmp___3);
  }
#line 87
  return (tmp___4);
}
}
#line 14 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/stralloc.h"
extern int stralloc_copyb(stralloc * , char * , unsigned int  ) ;
#line 6 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/env.h"
extern char *env_get(char *s ) ;
#line 7 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/pathexec_run.c"
static stralloc tmp___0  ;
#line 16
extern int ( /* missing proto */  execve)() ;
#line 9 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/pathexec_run.c"
void pathexec_run(char *file , char **argv , char **envp ) 
{ 
  char *path ;
  unsigned int split ;
  int savederrno ;
  unsigned int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  int *tmp___10 ;
  int *tmp___11 ;
  int *tmp___12 ;
  int *tmp___13 ;
  int *tmp___14 ;

  {
  {
#line 15
  tmp___3 = str_chr(file, '/');
  }
#line 15
  if (*(file + tmp___3)) {
    {
#line 16
    execve(file, argv, envp);
    }
#line 17
    return;
  }
  {
#line 20
  path = env_get((char *)"PATH");
  }
#line 21
  if (! path) {
#line 21
    path = (char *)"/bin:/usr/bin";
  }
#line 23
  savederrno = 0;
  {
#line 24
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 25
    split = str_chr(path, ':');
#line 26
    tmp___4 = stralloc_copyb(& tmp___0, path, split);
    }
#line 26
    if (! tmp___4) {
#line 26
      return;
    }
#line 27
    if (! split) {
      {
#line 28
      tmp___5 = stralloc_cats(& tmp___0, (char *)".");
      }
#line 28
      if (! tmp___5) {
#line 28
        return;
      }
    }
    {
#line 29
    tmp___6 = stralloc_cats(& tmp___0, (char *)"/");
    }
#line 29
    if (! tmp___6) {
#line 29
      return;
    }
    {
#line 30
    tmp___7 = stralloc_cats(& tmp___0, file);
    }
#line 30
    if (! tmp___7) {
#line 30
      return;
    }
    {
#line 31
    tmp___8 = stralloc_append(& tmp___0, (char *)"");
    }
#line 31
    if (! tmp___8) {
#line 31
      return;
    }
    {
#line 33
    execve(tmp___0.s, argv, envp);
#line 34
    tmp___13 = __errno_location();
    }
#line 34
    if (*tmp___13 != error_noent) {
      {
#line 35
      tmp___9 = __errno_location();
#line 35
      savederrno = *tmp___9;
#line 36
      tmp___10 = __errno_location();
      }
#line 36
      if (*tmp___10 != error_acces) {
        {
#line 36
        tmp___11 = __errno_location();
        }
#line 36
        if (*tmp___11 != error_perm) {
          {
#line 36
          tmp___12 = __errno_location();
          }
#line 36
          if (*tmp___12 != error_isdir) {
#line 36
            return;
          }
        }
      }
    }
#line 39
    if (! *(path + split)) {
#line 40
      if (savederrno) {
        {
#line 40
        tmp___14 = __errno_location();
#line 40
        *tmp___14 = savederrno;
        }
      }
#line 41
      return;
    }
#line 43
    path += split;
#line 44
    path ++;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 4 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/exit.h"
extern void _exit() ;
#line 5 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/auto-str.c"
char bspace[256]  ;
#line 6 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/auto-str.c"
buffer b  =    {bspace, 0U, (unsigned int )sizeof(bspace), 1, & write};
#line 8 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/auto-str.c"
void puts(char *s ) 
{ 
  int tmp___3 ;

  {
  {
#line 10
  tmp___3 = buffer_puts(& b, s);
  }
#line 10
  if (tmp___3 == -1) {
    {
#line 10
    _exit(111);
    }
  }
#line 11
  return;
}
}
#line 13 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/auto-str.c"
int main(int argc , char **argv ) 
{ 
  char *name ;
  char *value ;
  unsigned char ch ;
  char octal[4] ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 20
  name = *(argv + 1);
#line 21
  if (! name) {
    {
#line 21
    _exit(100);
    }
  }
#line 22
  value = *(argv + 2);
#line 23
  if (! value) {
    {
#line 23
    _exit(100);
    }
  }
  {
#line 25
  puts((char *)"const char ");
#line 26
  puts(name);
#line 27
  puts((char *)"[] = \"\\\n");
  }
  {
#line 29
  while (1) {
    while_continue: /* CIL Label */ ;
#line 29
    tmp___3 = value;
#line 29
    value ++;
#line 29
    ch = (unsigned char )*tmp___3;
#line 29
    if (! ch) {
#line 29
      goto while_break;
    }
    {
#line 30
    puts((char *)"\\");
#line 31
    octal[3] = (char)0;
#line 32
    octal[2] = (char )(48 + ((int )ch & 7));
#line 32
    ch = (unsigned char )((int )ch >> 3);
#line 33
    octal[1] = (char )(48 + ((int )ch & 7));
#line 33
    ch = (unsigned char )((int )ch >> 3);
#line 34
    octal[0] = (char )(48 + ((int )ch & 7));
#line 35
    puts(octal);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 38
  puts((char *)"\\\n\";\n");
#line 39
  tmp___4 = buffer_flush(& b);
  }
#line 39
  if (tmp___4 == -1) {
    {
#line 39
    _exit(111);
    }
  }
  {
#line 40
  _exit(0);
  }
#line 41
  return (0);
}
}
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 5 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/open_read.c"
int open_read(char *fn ) 
{ 
  int tmp___3 ;

  {
  {
#line 6
  tmp___3 = open((char const   *)fn, 2048);
  }
#line 6
  return (tmp___3);
}
}
#line 3 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/byte_diff.c"
int byte_diff(char *s , unsigned int n , char *t ) 
{ 


  {
  {
#line 8
  while (1) {
    while_continue: /* CIL Label */ ;
#line 9
    if (! n) {
#line 9
      return (0);
    }
#line 9
    if ((int )*s != (int )*t) {
#line 9
      goto while_break;
    }
#line 9
    s ++;
#line 9
    t ++;
#line 9
    n --;
#line 10
    if (! n) {
#line 10
      return (0);
    }
#line 10
    if ((int )*s != (int )*t) {
#line 10
      goto while_break;
    }
#line 10
    s ++;
#line 10
    t ++;
#line 10
    n --;
#line 11
    if (! n) {
#line 11
      return (0);
    }
#line 11
    if ((int )*s != (int )*t) {
#line 11
      goto while_break;
    }
#line 11
    s ++;
#line 11
    t ++;
#line 11
    n --;
#line 12
    if (! n) {
#line 12
      return (0);
    }
#line 12
    if ((int )*s != (int )*t) {
#line 12
      goto while_break;
    }
#line 12
    s ++;
#line 12
    t ++;
#line 12
    n --;
  }
  while_break: /* CIL Label */ ;
  }
#line 14
  return ((int )((unsigned int )((unsigned char )*s)) - (int )((unsigned int )((unsigned char )*t)));
}
}
#line 7 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/open.h"
int open_trunc(char *fn ) ;
#line 5 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/open_trunc.c"
int open_trunc(char *fn ) 
{ 
  int tmp___3 ;

  {
  {
#line 6
  tmp___3 = open((char const   *)fn, 2625, 420);
  }
#line 6
  return (tmp___3);
}
}
#line 32 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/buffer.h"
int buffer_get(buffer *s , char *buf , unsigned int len ) ;
#line 33
int buffer_bget(buffer *s , char *buf , unsigned int len ) ;
#line 36
char *buffer_peek(buffer *s ) ;
#line 37
void buffer_seek(buffer *s , unsigned int len ) ;
#line 7 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/byte.h"
extern void byte_copyr() ;
#line 5 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/buffer_get.c"
static int oneread(int (*op)() , int fd , char *buf , unsigned int len ) 
{ 
  int r ;
  int *tmp___3 ;

  {
  {
#line 9
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 10
    r = (*op)(fd, buf, len);
    }
#line 11
    if (r == -1) {
      {
#line 11
      tmp___3 = __errno_location();
      }
#line 11
      if (*tmp___3 == error_intr) {
#line 11
        goto __Cont;
      }
    }
#line 12
    return (r);
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 16 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/buffer_get.c"
static int getthis(buffer *s , char *buf , unsigned int len ) 
{ 


  {
#line 18
  if (len > s->p) {
#line 18
    len = s->p;
  }
  {
#line 19
  s->p -= len;
#line 20
  byte_copy(buf, len, s->x + s->n);
#line 21
  s->n += len;
  }
#line 22
  return ((int )len);
}
}
#line 25 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/buffer_get.c"
int buffer_feed(buffer *s ) 
{ 
  int r ;

  {
#line 29
  if (s->p) {
#line 29
    return ((int )s->p);
  }
  {
#line 30
  r = oneread(s->op, s->fd, s->x, s->n);
  }
#line 31
  if (r <= 0) {
#line 31
    return (r);
  }
#line 32
  s->p = (unsigned int )r;
#line 33
  s->n -= (unsigned int )r;
#line 34
  if (s->n > 0U) {
    {
#line 34
    byte_copyr(s->x + s->n, r, s->x);
    }
  }
#line 35
  return (r);
}
}
#line 38 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/buffer_get.c"
int buffer_bget(buffer *s , char *buf , unsigned int len ) 
{ 
  int r ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 42
  if (s->p > 0U) {
    {
#line 42
    tmp___3 = getthis(s, buf, len);
    }
#line 42
    return (tmp___3);
  }
#line 43
  if (s->n <= len) {
    {
#line 43
    tmp___4 = oneread(s->op, s->fd, buf, s->n);
    }
#line 43
    return (tmp___4);
  }
  {
#line 44
  r = buffer_feed(s);
  }
#line 44
  if (r <= 0) {
#line 44
    return (r);
  }
  {
#line 45
  tmp___5 = getthis(s, buf, len);
  }
#line 45
  return (tmp___5);
}
}
#line 48 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/buffer_get.c"
int buffer_get(buffer *s , char *buf , unsigned int len ) 
{ 
  int r ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 52
  if (s->p > 0U) {
    {
#line 52
    tmp___3 = getthis(s, buf, len);
    }
#line 52
    return (tmp___3);
  }
#line 53
  if (s->n <= len) {
    {
#line 53
    tmp___4 = oneread(s->op, s->fd, buf, len);
    }
#line 53
    return (tmp___4);
  }
  {
#line 54
  r = buffer_feed(s);
  }
#line 54
  if (r <= 0) {
#line 54
    return (r);
  }
  {
#line 55
  tmp___5 = getthis(s, buf, len);
  }
#line 55
  return (tmp___5);
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/buffer_get.c"
char *buffer_peek(buffer *s ) 
{ 


  {
#line 60
  return (s->x + s->n);
}
}
#line 63 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/buffer_get.c"
void buffer_seek(buffer *s , unsigned int len ) 
{ 


  {
#line 65
  s->n += len;
#line 66
  s->p -= len;
#line 67
  return;
}
}
#line 16 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/buffer.h"
void buffer_init(buffer *s , int (*op)() , int fd , char *buf , unsigned int len ) ;
#line 3 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/buffer.c"
void buffer_init(buffer *s , int (*op)() , int fd , char *buf , unsigned int len ) 
{ 


  {
#line 5
  s->x = buf;
#line 6
  s->fd = fd;
#line 7
  s->op = op;
#line 8
  s->p = 0U;
#line 9
  s->n = len;
#line 10
  return;
}
}
#line 10 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/str.h"
extern int str_start(char * , char * ) ;
#line 4 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/env.c"
extern char *env_get(char *s ) 
{ 
  int i ;
  unsigned int len ;
  int tmp___3 ;

  {
#line 9
  if (! s) {
#line 9
    return ((char *)0);
  }
  {
#line 10
  len = str_len(s);
#line 11
  i = 0;
  }
  {
#line 11
  while (1) {
    while_continue: /* CIL Label */ ;
#line 11
    if (! *(environ + i)) {
#line 11
      goto while_break;
    }
    {
#line 12
    tmp___3 = str_start(*(environ + i), s);
    }
#line 12
    if (tmp___3) {
#line 12
      if ((int )*(*(environ + i) + len) == 61) {
#line 13
        return ((*(environ + i) + len) + 1);
      }
    }
#line 11
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 14
  return ((char *)0);
}
}
#line 14 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/fmt.h"
unsigned int fmt_ulong(char *s , unsigned long u ) ;
#line 3 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/fmt_ulong.c"
unsigned int fmt_ulong(char *s , unsigned long u ) 
{ 
  register unsigned int len ;
  register unsigned long q ;

  {
#line 6
  len = 1U;
#line 6
  q = u;
  {
#line 7
  while (1) {
    while_continue: /* CIL Label */ ;
#line 7
    if (! (q > 9UL)) {
#line 7
      goto while_break;
    }
#line 7
    len ++;
#line 7
    q /= 10UL;
  }
  while_break: /* CIL Label */ ;
  }
#line 8
  if (s) {
#line 9
    s += len;
    {
#line 10
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 10
      s --;
#line 10
      *s = (char )(48UL + u % 10UL);
#line 10
      u /= 10UL;
#line 10
      if (! u) {
#line 10
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 12
  return (len);
}
}
#line 3 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/alloc.c"
extern char *malloc() ;
#line 4
extern void free() ;
#line 10 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/alloc.c"
static aligned realspace[128]  ;
#line 12 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/alloc.c"
static unsigned int avail  =    2048U;
#line 14 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/alloc.c"
char *alloc(unsigned int n ) 
{ 
  char *x ;
  int *tmp___3 ;

  {
#line 18
  n = (16U + n) - (n & 15U);
#line 19
  if (n <= avail) {
#line 19
    avail -= n;
#line 19
    return ((char *)(realspace) + avail);
  }
  {
#line 20
  x = malloc(n);
  }
#line 21
  if (! x) {
    {
#line 21
    tmp___3 = __errno_location();
#line 21
    *tmp___3 = error_nomem;
    }
  }
#line 22
  return (x);
}
}
#line 25 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/alloc.c"
void alloc_free(char *x ) 
{ 


  {
#line 28
  if ((unsigned long )x >= (unsigned long )((char *)(realspace))) {
#line 29
    if ((unsigned long )x < (unsigned long )((char *)(realspace) + 2048)) {
#line 30
      return;
    }
  }
  {
#line 31
  free(x);
  }
#line 32
  return;
}
}
#line 11 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/strerr.h"
struct strerr strerr_sys ;
#line 16
extern void strerr_die(int  , char * , char * , char * , char * , char * , char * ,
                       struct strerr * ) ;
#line 4 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/readwrite.h"
extern int read() ;
#line 8 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/install.c"
void hier(void) ;
#line 12 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/install.c"
int fdsourcedir  =    -1;
#line 20
extern int ( /* missing proto */  mkdir)() ;
#line 23
extern int ( /* missing proto */  chown)() ;
#line 25
extern int ( /* missing proto */  chmod)() ;
#line 14 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/install.c"
void h(char *home , int uid , int gid , int mode ) 
{ 
  int *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 20
  tmp___4 = mkdir(home, 448);
  }
#line 20
  if (tmp___4 == -1) {
    {
#line 21
    tmp___3 = __errno_location();
    }
#line 21
    if (*tmp___3 != error_exist) {
      {
#line 22
      strerr_die(111, (char *)"install: fatal: ", (char *)"unable to mkdir ", home,
                 (char *)": ", (char *)0, (char *)0, & strerr_sys);
      }
    }
  }
  {
#line 23
  tmp___5 = chown(home, uid, gid);
  }
#line 23
  if (tmp___5 == -1) {
    {
#line 24
    strerr_die(111, (char *)"install: fatal: ", (char *)"unable to chown ", home,
               (char *)": ", (char *)0, (char *)0, & strerr_sys);
    }
  }
  {
#line 25
  tmp___6 = chmod(home, mode);
  }
#line 25
  if (tmp___6 == -1) {
    {
#line 26
    strerr_die(111, (char *)"install: fatal: ", (char *)"unable to chmod ", home,
               (char *)": ", (char *)0, (char *)0, & strerr_sys);
    }
  }
#line 27
  return;
}
}
#line 36
extern int ( /* missing proto */  chdir)() ;
#line 29 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/install.c"
void d(char *home , char *subdir , int uid , int gid , int mode ) 
{ 
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
#line 36
  tmp___3 = chdir(home);
  }
#line 36
  if (tmp___3 == -1) {
    {
#line 37
    strerr_die(111, (char *)"install: fatal: ", (char *)"unable to switch to ", home,
               (char *)": ", (char *)0, (char *)0, & strerr_sys);
    }
  }
  {
#line 38
  tmp___5 = mkdir(subdir, 448);
  }
#line 38
  if (tmp___5 == -1) {
    {
#line 39
    tmp___4 = __errno_location();
    }
#line 39
    if (*tmp___4 != error_exist) {
      {
#line 40
      strerr_die(111, (char *)"install: fatal: ", (char *)"unable to mkdir ", home,
                 (char *)"/", subdir, (char *)": ", & strerr_sys);
      }
    }
  }
  {
#line 41
  tmp___6 = chown(subdir, uid, gid);
  }
#line 41
  if (tmp___6 == -1) {
    {
#line 42
    strerr_die(111, (char *)"install: fatal: ", (char *)"unable to chown ", home,
               (char *)"/", subdir, (char *)": ", & strerr_sys);
    }
  }
  {
#line 43
  tmp___7 = chmod(subdir, mode);
  }
#line 43
  if (tmp___7 == -1) {
    {
#line 44
    strerr_die(111, (char *)"install: fatal: ", (char *)"unable to chmod ", home,
               (char *)"/", subdir, (char *)": ", & strerr_sys);
    }
  }
#line 45
  return;
}
}
#line 47 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/install.c"
char inbuf[8192]  ;
#line 48 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/install.c"
char outbuf[8192]  ;
#line 49 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/install.c"
buffer ssin  ;
#line 50 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/install.c"
buffer ssout  ;
#line 63
extern int ( /* missing proto */  fchdir)() ;
#line 88
extern int ( /* missing proto */  close)() ;
#line 91
extern int ( /* missing proto */  fsync)() ;
#line 52 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/install.c"
void c(char *home , char *subdir , char *file , int uid , int gid , int mode ) 
{ 
  int fdin ;
  int fdout ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
  {
#line 63
  tmp___3 = fchdir(fdsourcedir);
  }
#line 63
  if (tmp___3 == -1) {
    {
#line 64
    strerr_die(111, (char *)"install: fatal: ", (char *)"unable to switch back to source directory: ",
               (char *)0, (char *)0, (char *)0, (char *)0, & strerr_sys);
    }
  }
  {
#line 66
  fdin = open_read(file);
  }
#line 67
  if (fdin == -1) {
    {
#line 68
    strerr_die(111, (char *)"install: fatal: ", (char *)"unable to read ", file, (char *)": ",
               (char *)0, (char *)0, & strerr_sys);
    }
  }
  {
#line 69
  buffer_init(& ssin, & read, fdin, inbuf, (unsigned int )sizeof(inbuf));
#line 71
  tmp___4 = chdir(home);
  }
#line 71
  if (tmp___4 == -1) {
    {
#line 72
    strerr_die(111, (char *)"install: fatal: ", (char *)"unable to switch to ", home,
               (char *)": ", (char *)0, (char *)0, & strerr_sys);
    }
  }
  {
#line 73
  tmp___5 = chdir(subdir);
  }
#line 73
  if (tmp___5 == -1) {
    {
#line 74
    strerr_die(111, (char *)"install: fatal: ", (char *)"unable to switch to ", home,
               (char *)"/", subdir, (char *)": ", & strerr_sys);
    }
  }
  {
#line 76
  fdout = open_trunc(file);
  }
#line 77
  if (fdout == -1) {
    {
#line 78
    strerr_die(111, (char *)"install: fatal: ", (char *)"unable to write .../", subdir,
               (char *)"/", file, (char *)": ", & strerr_sys);
    }
  }
  {
#line 79
  buffer_init(& ssout, & write, fdout, outbuf, (unsigned int )sizeof(outbuf));
#line 81
  tmp___6 = buffer_copy(& ssout, & ssin);
  }
  {
#line 82
  if (tmp___6 == -2) {
#line 82
    goto case_neg_2;
  }
#line 84
  if (tmp___6 == -3) {
#line 84
    goto case_neg_3;
  }
#line 81
  goto switch_break;
  case_neg_2: /* CIL Label */ 
  {
#line 83
  strerr_die(111, (char *)"install: fatal: ", (char *)"unable to read ", file, (char *)": ",
             (char *)0, (char *)0, & strerr_sys);
  }
  case_neg_3: /* CIL Label */ 
  {
#line 85
  strerr_die(111, (char *)"install: fatal: ", (char *)"unable to write .../", subdir,
             (char *)"/", file, (char *)": ", & strerr_sys);
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 88
  close(fdin);
#line 89
  tmp___7 = buffer_flush(& ssout);
  }
#line 89
  if (tmp___7 == -1) {
    {
#line 90
    strerr_die(111, (char *)"install: fatal: ", (char *)"unable to write .../", subdir,
               (char *)"/", file, (char *)": ", & strerr_sys);
    }
  }
  {
#line 91
  tmp___8 = fsync(fdout);
  }
#line 91
  if (tmp___8 == -1) {
    {
#line 92
    strerr_die(111, (char *)"install: fatal: ", (char *)"unable to write .../", subdir,
               (char *)"/", file, (char *)": ", & strerr_sys);
    }
  }
  {
#line 93
  tmp___9 = close(fdout);
  }
#line 93
  if (tmp___9 == -1) {
    {
#line 94
    strerr_die(111, (char *)"install: fatal: ", (char *)"unable to write .../", subdir,
               (char *)"/", file, (char *)": ", & strerr_sys);
    }
  }
  {
#line 96
  tmp___10 = chown(file, uid, gid);
  }
#line 96
  if (tmp___10 == -1) {
    {
#line 97
    strerr_die(111, (char *)"install: fatal: ", (char *)"unable to chown .../", subdir,
               (char *)"/", file, (char *)": ", & strerr_sys);
    }
  }
  {
#line 98
  tmp___11 = chmod(file, mode);
  }
#line 98
  if (tmp___11 == -1) {
    {
#line 99
    strerr_die(111, (char *)"install: fatal: ", (char *)"unable to chmod .../", subdir,
               (char *)"/", file, (char *)": ", & strerr_sys);
    }
  }
#line 100
  return;
}
}
#line 102 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/install.c"
void z(char *home , char *subdir , char *file , int len , int uid , int gid , int mode ) 
{ 
  int fdout ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
  {
#line 113
  tmp___3 = chdir(home);
  }
#line 113
  if (tmp___3 == -1) {
    {
#line 114
    strerr_die(111, (char *)"install: fatal: ", (char *)"unable to switch to ", home,
               (char *)": ", (char *)0, (char *)0, & strerr_sys);
    }
  }
  {
#line 115
  tmp___4 = chdir(subdir);
  }
#line 115
  if (tmp___4 == -1) {
    {
#line 116
    strerr_die(111, (char *)"install: fatal: ", (char *)"unable to switch to ", home,
               (char *)"/", subdir, (char *)": ", & strerr_sys);
    }
  }
  {
#line 118
  fdout = open_trunc(file);
  }
#line 119
  if (fdout == -1) {
    {
#line 120
    strerr_die(111, (char *)"install: fatal: ", (char *)"unable to write .../", subdir,
               (char *)"/", file, (char *)": ", & strerr_sys);
    }
  }
  {
#line 121
  buffer_init(& ssout, & write, fdout, outbuf, (unsigned int )sizeof(outbuf));
  }
  {
#line 123
  while (1) {
    while_continue: /* CIL Label */ ;
#line 123
    tmp___6 = len;
#line 123
    len --;
#line 123
    if (! (tmp___6 > 0)) {
#line 123
      goto while_break;
    }
    {
#line 124
    tmp___5 = buffer_put(& ssout, (char *)"", 1U);
    }
#line 124
    if (tmp___5 == -1) {
      {
#line 125
      strerr_die(111, (char *)"install: fatal: ", (char *)"unable to write .../",
                 subdir, (char *)"/", file, (char *)": ", & strerr_sys);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 127
  tmp___7 = buffer_flush(& ssout);
  }
#line 127
  if (tmp___7 == -1) {
    {
#line 128
    strerr_die(111, (char *)"install: fatal: ", (char *)"unable to write .../", subdir,
               (char *)"/", file, (char *)": ", & strerr_sys);
    }
  }
  {
#line 129
  tmp___8 = fsync(fdout);
  }
#line 129
  if (tmp___8 == -1) {
    {
#line 130
    strerr_die(111, (char *)"install: fatal: ", (char *)"unable to write .../", subdir,
               (char *)"/", file, (char *)": ", & strerr_sys);
    }
  }
  {
#line 131
  tmp___9 = close(fdout);
  }
#line 131
  if (tmp___9 == -1) {
    {
#line 132
    strerr_die(111, (char *)"install: fatal: ", (char *)"unable to write .../", subdir,
               (char *)"/", file, (char *)": ", & strerr_sys);
    }
  }
  {
#line 134
  tmp___10 = chown(file, uid, gid);
  }
#line 134
  if (tmp___10 == -1) {
    {
#line 135
    strerr_die(111, (char *)"install: fatal: ", (char *)"unable to chown .../", subdir,
               (char *)"/", file, (char *)": ", & strerr_sys);
    }
  }
  {
#line 136
  tmp___11 = chmod(file, mode);
  }
#line 136
  if (tmp___11 == -1) {
    {
#line 137
    strerr_die(111, (char *)"install: fatal: ", (char *)"unable to chmod .../", subdir,
               (char *)"/", file, (char *)": ", & strerr_sys);
    }
  }
#line 138
  return;
}
}
#line 146
extern int ( /* missing proto */  umask)() ;
#line 4 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/auto_home.h"
char const   auto_home[2] ;
#line 3 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/hier.c"
void hier(void) 
{ 


  {
  {
#line 5
  c(auto_home, "bin", "checkpw", -1, -1, 448);
#line 6
  c(auto_home, "bin", "checkapoppw", -1, -1, 448);
#line 7
  c(auto_home, "bin", "selectcheckpw", -1, -1, 448);
#line 8
  c(auto_home, "bin", "loginlog", -1, -1, 493);
  }
#line 9
  return;
}
}
#line 3 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/byte_copy.c"
void byte_copy(char *to , unsigned int n , char *from ) 
{ 
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;

  {
  {
#line 8
  while (1) {
    while_continue: /* CIL Label */ ;
#line 9
    if (! n) {
#line 9
      return;
    }
#line 9
    tmp___3 = to;
#line 9
    to ++;
#line 9
    tmp___4 = from;
#line 9
    from ++;
#line 9
    *tmp___3 = *tmp___4;
#line 9
    n --;
#line 10
    if (! n) {
#line 10
      return;
    }
#line 10
    tmp___5 = to;
#line 10
    to ++;
#line 10
    tmp___6 = from;
#line 10
    from ++;
#line 10
    *tmp___5 = *tmp___6;
#line 10
    n --;
#line 11
    if (! n) {
#line 11
      return;
    }
#line 11
    tmp___7 = to;
#line 11
    to ++;
#line 11
    tmp___8 = from;
#line 11
    from ++;
#line 11
    *tmp___7 = *tmp___8;
#line 11
    n --;
#line 12
    if (! n) {
#line 12
      return;
    }
#line 12
    tmp___9 = to;
#line 12
    to ++;
#line 12
    tmp___10 = from;
#line 12
    from ++;
#line 12
    *tmp___9 = *tmp___10;
#line 12
    n --;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 6 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/buffer_put.c"
static int allwrite___0(int (*op)() , int fd , char *buf , unsigned int len ) 
{ 
  int w ;
  int *tmp___3 ;

  {
  {
#line 10
  while (1) {
    while_continue: /* CIL Label */ ;
#line 10
    if (! len) {
#line 10
      goto while_break;
    }
    {
#line 11
    w = (*op)(fd, buf, len);
    }
#line 12
    if (w == -1) {
      {
#line 13
      tmp___3 = __errno_location();
      }
#line 13
      if (*tmp___3 == error_intr) {
#line 13
        goto while_continue;
      }
#line 14
      return (-1);
    }
#line 17
    buf += w;
#line 18
    len -= (unsigned int )w;
  }
  while_break: /* CIL Label */ ;
  }
#line 20
  return (0);
}
}
#line 5 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/buffer_get.c"
static int oneread___0(int (*op)() , int fd , char *buf , unsigned int len ) 
{ 
  int r ;
  int *tmp___3 ;

  {
  {
#line 9
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 10
    r = (*op)(fd, buf, len);
    }
#line 11
    if (r == -1) {
      {
#line 11
      tmp___3 = __errno_location();
      }
#line 11
      if (*tmp___3 == error_intr) {
#line 11
        goto __Cont;
      }
    }
#line 12
    return (r);
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 16 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/buffer_get.c"
static int getthis___0(buffer *s , char *buf , unsigned int len ) 
{ 


  {
#line 18
  if (len > s->p) {
#line 18
    len = s->p;
  }
  {
#line 19
  s->p -= len;
#line 20
  byte_copy(buf, len, s->x + s->n);
#line 21
  s->n += len;
  }
#line 22
  return ((int )len);
}
}
#line 1 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/auto_home.c"
char const   auto_home[2]  = {      (char const   )'/',      (char const   )'\000'};
#line 5 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/buffer_2.c"
static buffer it___0  =    {buffer_2_space, 0U, (unsigned int )sizeof(buffer_2_space), 2, & write};
#line 10 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/alloc.c"
static aligned realspace___0[128]  ;
#line 12 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/alloc.c"
static unsigned int avail___0  =    2048U;
#line 1 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/auto_password.c"
char const   auto_password[10]  = 
#line 1 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/auto_password.c"
  {      (char const   )'.',      (char const   )'p',      (char const   )'a',      (char const   )'s', 
        (char const   )'s',      (char const   )'w',      (char const   )'o',      (char const   )'r', 
        (char const   )'d',      (char const   )'\000'};
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 4 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/prot.h"
extern int prot_gid(int  ) ;
#line 5
extern int prot_uid(int  ) ;
#line 4 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/auto_maildir.h"
char const   auto_maildir[8] ;
#line 4 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/auto_patrn.h"
int auto_patrn ;
#line 116 "/usr/include/pwd.h"
extern struct passwd *getpwnam(char const   *__name ) ;
#line 14 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/checkpw.c"
static struct passwd *pw  ;
#line 16 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/checkpw.c"
static char up[513]  ;
#line 17 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/checkpw.c"
static int uplen  ;
#line 19 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/checkpw.c"
static stralloc stored  =    {(char *)0, 0U, 0U};
#line 20 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/checkpw.c"
static stralloc pwfile  =    {(char *)0, 0U, 0U};
#line 22 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/checkpw.c"
void cleanup(void) 
{ 
  int i ;

  {
#line 25
  i = 0;
  {
#line 25
  while (1) {
    while_continue: /* CIL Label */ ;
#line 25
    if (! ((unsigned long )i < sizeof(up))) {
#line 25
      goto while_break;
    }
#line 25
    up[i] = (char)0;
#line 25
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 26
  i = 0;
  {
#line 26
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 26
    if (! ((unsigned int )i < stored.len)) {
#line 26
      goto while_break___0;
    }
#line 26
    *(stored.s + i) = (char)0;
#line 26
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 27
  return;
}
}
#line 29 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/checkpw.c"
void die(int x ) 
{ 


  {
  {
#line 31
  cleanup();
#line 32
  _exit(x);
  }
#line 33
  return;
}
}
#line 98
extern int ( /* missing proto */  strcmp)() ;
#line 16 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/substdio.h"
int substdio_flush(substdio *s ) ;
#line 17
int substdio_put(substdio *s , char *buf , int len ) ;
#line 18
int substdio_bput(substdio *s , char *buf , int len ) ;
#line 19
int substdio_putflush(substdio *s , char *buf , int len ) ;
#line 20
int substdio_puts(substdio *s , char *buf ) ;
#line 21
int substdio_bputs(substdio *s , char *buf ) ;
#line 22
int substdio_putsflush(substdio *s , char *buf ) ;
#line 6 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/substdo.c"
static int allwrite___1(int (*op)() , int fd , char *buf , int len ) 
{ 
  register int w ;
  int *tmp___3 ;

  {
  {
#line 14
  while (1) {
    while_continue: /* CIL Label */ ;
#line 14
    if (! len) {
#line 14
      goto while_break;
    }
    {
#line 15
    w = (*op)(fd, buf, len);
    }
#line 16
    if (w == -1) {
      {
#line 17
      tmp___3 = __errno_location();
      }
#line 17
      if (*tmp___3 == error_intr) {
#line 17
        goto while_continue;
      }
#line 18
      return (-1);
    }
#line 21
    buf += w;
#line 22
    len -= w;
  }
  while_break: /* CIL Label */ ;
  }
#line 24
  return (0);
}
}
#line 27 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/substdo.c"
int substdio_flush(substdio *s ) 
{ 
  register int p___0 ;
  int tmp___3 ;

  {
#line 32
  p___0 = s->p;
#line 33
  if (! p___0) {
#line 33
    return (0);
  }
  {
#line 34
  s->p = 0;
#line 35
  tmp___3 = allwrite___1(s->op, s->fd, s->x, p___0);
  }
#line 35
  return (tmp___3);
}
}
#line 38 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/substdo.c"
int substdio_bput(substdio *s , char *buf , int len ) 
{ 
  register int n ;
  int tmp___3 ;

  {
  {
#line 45
  while (1) {
    while_continue: /* CIL Label */ ;
#line 45
    n = s->n - s->p;
#line 45
    if (! (len > n)) {
#line 45
      goto while_break;
    }
    {
#line 46
    byte_copy(s->x + s->p, n, buf);
#line 46
    s->p += n;
#line 46
    buf += n;
#line 46
    len -= n;
#line 47
    tmp___3 = substdio_flush(s);
    }
#line 47
    if (tmp___3 == -1) {
#line 47
      return (-1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 50
  byte_copy(s->x + s->p, len, buf);
#line 51
  s->p += len;
  }
#line 52
  return (0);
}
}
#line 55 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/substdo.c"
int substdio_put(substdio *s , char *buf , int len ) 
{ 
  register int n ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 62
  n = s->n;
#line 63
  if (len > n - s->p) {
    {
#line 64
    tmp___3 = substdio_flush(s);
    }
#line 64
    if (tmp___3 == -1) {
#line 64
      return (-1);
    }
#line 66
    if (n < 8192) {
#line 66
      n = 8192;
    }
    {
#line 67
    while (1) {
      while_continue: /* CIL Label */ ;
#line 67
      if (! (len > s->n)) {
#line 67
        goto while_break;
      }
#line 68
      if (n > len) {
#line 68
        n = len;
      }
      {
#line 69
      tmp___4 = allwrite___1(s->op, s->fd, buf, n);
      }
#line 69
      if (tmp___4 == -1) {
#line 69
        return (-1);
      }
#line 70
      buf += n;
#line 71
      len -= n;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 75
  byte_copy(s->x + s->p, len, buf);
#line 76
  s->p += len;
  }
#line 77
  return (0);
}
}
#line 80 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/substdo.c"
int substdio_putflush(substdio *s , char *buf , int len ) 
{ 
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 85
  tmp___3 = substdio_flush(s);
  }
#line 85
  if (tmp___3 == -1) {
#line 85
    return (-1);
  }
  {
#line 86
  tmp___4 = allwrite___1(s->op, s->fd, buf, len);
  }
#line 86
  return (tmp___4);
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/substdo.c"
int substdio_bputs(substdio *s , char *buf ) 
{ 
  unsigned int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 93
  tmp___3 = str_len(buf);
#line 93
  tmp___4 = substdio_bput(s, buf, (int )tmp___3);
  }
#line 93
  return (tmp___4);
}
}
#line 96 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/substdo.c"
int substdio_puts(substdio *s , char *buf ) 
{ 
  unsigned int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 100
  tmp___3 = str_len(buf);
#line 100
  tmp___4 = substdio_put(s, buf, (int )tmp___3);
  }
#line 100
  return (tmp___4);
}
}
#line 103 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/substdo.c"
int substdio_putsflush(substdio *s , char *buf ) 
{ 
  unsigned int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 107
  tmp___3 = str_len(buf);
#line 107
  tmp___4 = substdio_putflush(s, buf, (int )tmp___3);
  }
#line 107
  return (tmp___4);
}
}
#line 1 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/auto_patrn.c"
int auto_patrn  =    63;
#line 5 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/buffer_get.c"
static int oneread___1(int (*op)() , int fd , char *buf , unsigned int len ) 
{ 
  int r ;
  int *tmp___3 ;

  {
  {
#line 9
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 10
    r = (*op)(fd, buf, len);
    }
#line 11
    if (r == -1) {
      {
#line 11
      tmp___3 = __errno_location();
      }
#line 11
      if (*tmp___3 == error_intr) {
#line 11
        goto __Cont;
      }
    }
#line 12
    return (r);
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 16 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/buffer_get.c"
static int getthis___1(buffer *s , char *buf , unsigned int len ) 
{ 


  {
#line 18
  if (len > s->p) {
#line 18
    len = s->p;
  }
  {
#line 19
  s->p -= len;
#line 20
  byte_copy(buf, len, s->x + s->n);
#line 21
  s->n += len;
  }
#line 22
  return ((int )len);
}
}
#line 6 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/buffer_put.c"
static int allwrite___2(int (*op)() , int fd , char *buf , unsigned int len ) 
{ 
  int w ;
  int *tmp___3 ;

  {
  {
#line 10
  while (1) {
    while_continue: /* CIL Label */ ;
#line 10
    if (! len) {
#line 10
      goto while_break;
    }
    {
#line 11
    w = (*op)(fd, buf, len);
    }
#line 12
    if (w == -1) {
      {
#line 13
      tmp___3 = __errno_location();
      }
#line 13
      if (*tmp___3 == error_intr) {
#line 13
        goto while_continue;
      }
#line 14
      return (-1);
    }
#line 17
    buf += w;
#line 18
    len -= (unsigned int )w;
  }
  while_break: /* CIL Label */ ;
  }
#line 20
  return (0);
}
}
#line 10 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/alloc.c"
static aligned realspace___1[128]  ;
#line 12 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/alloc.c"
static unsigned int avail___1  =    2048U;
#line 5 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/buffer_2.c"
static buffer it___1  =    {buffer_2_space, 0U, (unsigned int )sizeof(buffer_2_space), 2, & write};
#line 1 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/auto_maildir.c"
char const   auto_maildir[8]  = 
#line 1 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/auto_maildir.c"
  {      (char const   )'M',      (char const   )'a',      (char const   )'i',      (char const   )'l', 
        (char const   )'d',      (char const   )'i',      (char const   )'r',      (char const   )'\000'};
#line 5 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/buffer_2.c"
static buffer it___2  =    {buffer_2_space, 0U, (unsigned int )sizeof(buffer_2_space), 2, & write};
#line 8 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/pathexec_env.c"
static stralloc plus___0  ;
#line 9 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/pathexec_env.c"
static stralloc tmp___1  ;
#line 6 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/buffer_put.c"
static int allwrite___3(int (*op)() , int fd , char *buf , unsigned int len ) 
{ 
  int w ;
  int *tmp___3 ;

  {
  {
#line 10
  while (1) {
    while_continue: /* CIL Label */ ;
#line 10
    if (! len) {
#line 10
      goto while_break;
    }
    {
#line 11
    w = (*op)(fd, buf, len);
    }
#line 12
    if (w == -1) {
      {
#line 13
      tmp___3 = __errno_location();
      }
#line 13
      if (*tmp___3 == error_intr) {
#line 13
        goto while_continue;
      }
#line 14
      return (-1);
    }
#line 17
    buf += w;
#line 18
    len -= (unsigned int )w;
  }
  while_break: /* CIL Label */ ;
  }
#line 20
  return (0);
}
}
#line 7 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/pathexec_run.c"
static stralloc tmp___2  ;
#line 5 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/buffer_get.c"
static int oneread___2(int (*op)() , int fd , char *buf , unsigned int len ) 
{ 
  int r ;
  int *tmp___3 ;

  {
  {
#line 9
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 10
    r = (*op)(fd, buf, len);
    }
#line 11
    if (r == -1) {
      {
#line 11
      tmp___3 = __errno_location();
      }
#line 11
      if (*tmp___3 == error_intr) {
#line 11
        goto __Cont;
      }
    }
#line 12
    return (r);
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 16 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/buffer_get.c"
static int getthis___2(buffer *s , char *buf , unsigned int len ) 
{ 


  {
#line 18
  if (len > s->p) {
#line 18
    len = s->p;
  }
  {
#line 19
  s->p -= len;
#line 20
  byte_copy(buf, len, s->x + s->n);
#line 21
  s->n += len;
  }
#line 22
  return ((int )len);
}
}
#line 26 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/scan.h"
extern unsigned int scan_8long(char const   * , unsigned long * ) ;
#line 7 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/auto-int8.c"
char buf1[256]  ;
#line 8 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/auto-int8.c"
substdio ss1  =    {buf1, 0, (int )sizeof(buf1), 1, & write};
#line 10 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/alloc.c"
static aligned realspace___2[128]  ;
#line 12 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/alloc.c"
static unsigned int avail___2  =    2048U;
#line 6 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/buffer_put.c"
static int allwrite___4(int (*op)() , int fd , char *buf , unsigned int len ) 
{ 
  int w ;
  int *tmp___3 ;

  {
  {
#line 10
  while (1) {
    while_continue: /* CIL Label */ ;
#line 10
    if (! len) {
#line 10
      goto while_break;
    }
    {
#line 11
    w = (*op)(fd, buf, len);
    }
#line 12
    if (w == -1) {
      {
#line 13
      tmp___3 = __errno_location();
      }
#line 13
      if (*tmp___3 == error_intr) {
#line 13
        goto while_continue;
      }
#line 14
      return (-1);
    }
#line 17
    buf += w;
#line 18
    len -= (unsigned int )w;
  }
  while_break: /* CIL Label */ ;
  }
#line 20
  return (0);
}
}
#line 5 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/buffer_get.c"
static int oneread___3(int (*op)() , int fd , char *buf , unsigned int len ) 
{ 
  int r ;
  int *tmp___3 ;

  {
  {
#line 9
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 10
    r = (*op)(fd, buf, len);
    }
#line 11
    if (r == -1) {
      {
#line 11
      tmp___3 = __errno_location();
      }
#line 11
      if (*tmp___3 == error_intr) {
#line 11
        goto __Cont;
      }
    }
#line 12
    return (r);
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 16 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/buffer_get.c"
static int getthis___3(buffer *s , char *buf , unsigned int len ) 
{ 


  {
#line 18
  if (len > s->p) {
#line 18
    len = s->p;
  }
  {
#line 19
  s->p -= len;
#line 20
  byte_copy(buf, len, s->x + s->n);
#line 21
  s->n += len;
  }
#line 22
  return ((int )len);
}
}
#line 15 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/strerr.h"
extern void strerr_warn(char * , char * , char * , char * , char * , char * , struct strerr * ) ;
#line 13 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/instcheck.c"
void perm(char *prefix1 , char *prefix2 , char *prefix3 , char *file , int type ,
          int uid , int gid , int mode ) 
{ 
  struct stat st ;
  int *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 25
  tmp___4 = stat((char const   */* __restrict  */)file, (struct stat */* __restrict  */)(& st));
  }
#line 25
  if (tmp___4 == -1) {
    {
#line 26
    tmp___3 = __errno_location();
    }
#line 26
    if (*tmp___3 == error_noent) {
      {
#line 27
      strerr_warn((char *)"instcheck: warning: ", prefix1, prefix2, prefix3, file,
                  (char *)" does not exist", (struct strerr *)0);
      }
    } else {
      {
#line 29
      strerr_warn((char *)"instcheck: warning: ", (char *)"unable to stat .../", file,
                  (char *)": ", (char *)0, (char *)0, & strerr_sys);
      }
    }
#line 30
    return;
  }
#line 33
  if (uid != -1) {
#line 33
    if (st.st_uid != (__uid_t )uid) {
      {
#line 34
      strerr_warn((char *)"instcheck: warning: ", prefix1, prefix2, prefix3, file,
                  (char *)" has wrong owner", (struct strerr *)0);
      }
    }
  }
#line 35
  if (gid != -1) {
#line 35
    if (st.st_gid != (__gid_t )gid) {
      {
#line 36
      strerr_warn((char *)"instcheck: warning: ", prefix1, prefix2, prefix3, file,
                  (char *)" has wrong group", (struct strerr *)0);
      }
    }
  }
#line 37
  if ((st.st_mode & 4095U) != (unsigned int )mode) {
    {
#line 38
    strerr_warn((char *)"instcheck: warning: ", prefix1, prefix2, prefix3, file, (char *)" has wrong permissions",
                (struct strerr *)0);
    }
  }
#line 39
  if ((st.st_mode & 61440U) != (unsigned int )type) {
    {
#line 40
    strerr_warn((char *)"instcheck: warning: ", prefix1, prefix2, prefix3, file, (char *)" has wrong type",
                (struct strerr *)0);
    }
  }
#line 41
  return;
}
}
#line 64 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/instcheck.c"
void p(char *home , char *fifo , int uid , int gid , int mode ) 
{ 
  int tmp___3 ;

  {
  {
#line 71
  tmp___3 = chdir(home);
  }
#line 71
  if (tmp___3 == -1) {
    {
#line 72
    strerr_die(111, (char *)"instcheck: fatal: ", (char *)"unable to switch to ",
               home, (char *)": ", (char *)0, (char *)0, & strerr_sys);
    }
  }
  {
#line 73
  perm((char *)"", home, (char *)"/", fifo, 4096, uid, gid, mode);
  }
#line 74
  return;
}
}
#line 5 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/buffer_2.c"
static buffer it___3  =    {buffer_2_space, 0U, (unsigned int )sizeof(buffer_2_space), 2, & write};
#line 10 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/alloc.c"
static aligned realspace___3[128]  ;
#line 12 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/alloc.c"
static unsigned int avail___3  =    2048U;
#line 5 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/buffer_2.c"
static buffer it___4  =    {buffer_2_space, 0U, (unsigned int )sizeof(buffer_2_space), 2, & write};
#line 11 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/strerr.h"
struct strerr strerr_sys  ;
#line 12
void strerr_sysinit(void) ;
#line 6 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/strerr_sys.c"
void strerr_sysinit(void) 
{ 
  int *tmp___3 ;

  {
  {
#line 8
  strerr_sys.who = (struct strerr *)0;
#line 9
  tmp___3 = __errno_location();
#line 9
  strerr_sys.x = error_str(*tmp___3);
#line 10
  strerr_sys.y = (char *)"";
#line 11
  strerr_sys.z = (char *)"";
  }
#line 12
  return;
}
}
#line 10 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/alloc.c"
static aligned realspace___4[128]  ;
#line 12 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/alloc.c"
static unsigned int avail___4  =    2048U;
#line 5 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/buffer_get.c"
static int oneread___4(int (*op)() , int fd , char *buf , unsigned int len ) 
{ 
  int r ;
  int *tmp___3 ;

  {
  {
#line 9
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 10
    r = (*op)(fd, buf, len);
    }
#line 11
    if (r == -1) {
      {
#line 11
      tmp___3 = __errno_location();
      }
#line 11
      if (*tmp___3 == error_intr) {
#line 11
        goto __Cont;
      }
    }
#line 12
    return (r);
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 16 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/buffer_get.c"
static int getthis___4(buffer *s , char *buf , unsigned int len ) 
{ 


  {
#line 18
  if (len > s->p) {
#line 18
    len = s->p;
  }
  {
#line 19
  s->p -= len;
#line 20
  byte_copy(buf, len, s->x + s->n);
#line 21
  s->n += len;
  }
#line 22
  return ((int )len);
}
}
#line 33 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/md5.h"
void MD5Init(MD5_CTX *context ) ;
#line 34
void MD5Update(MD5_CTX *context , unsigned char *input , unsigned int inputLen ) ;
#line 36
void MD5Final(unsigned char *digest , MD5_CTX *context ) ;
#line 48 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/md5c.c"
static void MD5Transform(UINT4 *state , unsigned char *block ) ;
#line 49
static void Encode(unsigned char *output , UINT4 *input , unsigned int len ) ;
#line 51
static void Decode(UINT4 *output , unsigned char *input , unsigned int len ) ;
#line 53
static void MD5_memcpy(POINTER output , POINTER input , unsigned int len ) ;
#line 54
static void MD5_memset(POINTER output , int value , unsigned int len ) ;
#line 56 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/md5c.c"
static unsigned char PADDING[64]  = 
#line 56
  {      (unsigned char)128,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0};
#line 99 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/md5c.c"
void MD5Init(MD5_CTX *context ) 
{ 
  UINT4 tmp___3 ;

  {
#line 102
  tmp___3 = (UINT4 )0;
#line 102
  context->count[1] = tmp___3;
#line 102
  context->count[0] = tmp___3;
#line 105
  context->state[0] = (UINT4 )1732584193;
#line 106
  context->state[1] = 4023233417U;
#line 107
  context->state[2] = 2562383102U;
#line 108
  context->state[3] = (UINT4 )271733878;
#line 109
  return;
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/md5c.c"
void MD5Update(MD5_CTX *context , unsigned char *input , unsigned int inputLen ) 
{ 
  unsigned int i ;
  unsigned int index ;
  unsigned int partLen ;
  UINT4 tmp___3 ;

  {
#line 123
  index = (context->count[0] >> 3) & 63U;
#line 126
  tmp___3 = context->count[0] + (inputLen << 3);
#line 126
  context->count[0] = tmp___3;
#line 126
  if (tmp___3 < inputLen << 3) {
#line 128
    (context->count[1]) ++;
  }
#line 129
  context->count[1] += inputLen >> 29;
#line 131
  partLen = 64U - index;
#line 135
  if (inputLen >= partLen) {
    {
#line 136
    MD5_memcpy(& context->buffer[index], input, partLen);
#line 138
    MD5Transform(context->state, context->buffer);
#line 140
    i = partLen;
    }
    {
#line 140
    while (1) {
      while_continue: /* CIL Label */ ;
#line 140
      if (! (i + 63U < inputLen)) {
#line 140
        goto while_break;
      }
      {
#line 141
      MD5Transform(context->state, input + i);
#line 140
      i += 64U;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 143
    index = 0U;
  } else {
#line 146
    i = 0U;
  }
  {
#line 149
  MD5_memcpy(& context->buffer[index], input + i, inputLen - i);
  }
#line 152
  return;
}
}
#line 157 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/md5c.c"
void MD5Final(unsigned char *digest , MD5_CTX *context ) 
{ 
  unsigned char bits[8] ;
  unsigned int index ;
  unsigned int padLen ;

  {
  {
#line 165
  Encode(bits, context->count, 8);
#line 169
  index = (context->count[0] >> 3) & 63U;
  }
#line 170
  if (index < 56U) {
#line 170
    padLen = 56U - index;
  } else {
#line 170
    padLen = 120U - index;
  }
  {
#line 171
  MD5Update(context, PADDING, padLen);
#line 174
  MD5Update(context, bits, 8U);
#line 176
  Encode(digest, context->state, 16);
#line 180
  MD5_memset((POINTER )context, 0, sizeof(*context));
  }
#line 181
  return;
}
}
#line 185 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/md5c.c"
static void MD5Transform(UINT4 *state , unsigned char *block ) 
{ 
  UINT4 a ;
  UINT4 b___0 ;
  UINT4 c___0 ;
  UINT4 d___0 ;
  UINT4 x[16] ;

  {
  {
#line 189
  a = *(state + 0);
#line 189
  b___0 = *(state + 1);
#line 189
  c___0 = *(state + 2);
#line 189
  d___0 = *(state + 3);
#line 191
  Decode(x, block, 64);
#line 194
  a += (((b___0 & c___0) | (~ b___0 & d___0)) + x[0]) + 3614090360U;
#line 194
  a = (a << 7) | (a >> 25);
#line 194
  a += b___0;
#line 195
  d___0 += (((a & b___0) | (~ a & c___0)) + x[1]) + 3905402710U;
#line 195
  d___0 = (d___0 << 12) | (d___0 >> 20);
#line 195
  d___0 += a;
#line 196
  c___0 += (((d___0 & a) | (~ d___0 & b___0)) + x[2]) + 606105819U;
#line 196
  c___0 = (c___0 << 17) | (c___0 >> 15);
#line 196
  c___0 += d___0;
#line 197
  b___0 += (((c___0 & d___0) | (~ c___0 & a)) + x[3]) + 3250441966U;
#line 197
  b___0 = (b___0 << 22) | (b___0 >> 10);
#line 197
  b___0 += c___0;
#line 198
  a += (((b___0 & c___0) | (~ b___0 & d___0)) + x[4]) + 4118548399U;
#line 198
  a = (a << 7) | (a >> 25);
#line 198
  a += b___0;
#line 199
  d___0 += (((a & b___0) | (~ a & c___0)) + x[5]) + 1200080426U;
#line 199
  d___0 = (d___0 << 12) | (d___0 >> 20);
#line 199
  d___0 += a;
#line 200
  c___0 += (((d___0 & a) | (~ d___0 & b___0)) + x[6]) + 2821735955U;
#line 200
  c___0 = (c___0 << 17) | (c___0 >> 15);
#line 200
  c___0 += d___0;
#line 201
  b___0 += (((c___0 & d___0) | (~ c___0 & a)) + x[7]) + 4249261313U;
#line 201
  b___0 = (b___0 << 22) | (b___0 >> 10);
#line 201
  b___0 += c___0;
#line 202
  a += (((b___0 & c___0) | (~ b___0 & d___0)) + x[8]) + 1770035416U;
#line 202
  a = (a << 7) | (a >> 25);
#line 202
  a += b___0;
#line 203
  d___0 += (((a & b___0) | (~ a & c___0)) + x[9]) + 2336552879U;
#line 203
  d___0 = (d___0 << 12) | (d___0 >> 20);
#line 203
  d___0 += a;
#line 204
  c___0 += (((d___0 & a) | (~ d___0 & b___0)) + x[10]) + 4294925233U;
#line 204
  c___0 = (c___0 << 17) | (c___0 >> 15);
#line 204
  c___0 += d___0;
#line 205
  b___0 += (((c___0 & d___0) | (~ c___0 & a)) + x[11]) + 2304563134U;
#line 205
  b___0 = (b___0 << 22) | (b___0 >> 10);
#line 205
  b___0 += c___0;
#line 206
  a += (((b___0 & c___0) | (~ b___0 & d___0)) + x[12]) + 1804603682U;
#line 206
  a = (a << 7) | (a >> 25);
#line 206
  a += b___0;
#line 207
  d___0 += (((a & b___0) | (~ a & c___0)) + x[13]) + 4254626195U;
#line 207
  d___0 = (d___0 << 12) | (d___0 >> 20);
#line 207
  d___0 += a;
#line 208
  c___0 += (((d___0 & a) | (~ d___0 & b___0)) + x[14]) + 2792965006U;
#line 208
  c___0 = (c___0 << 17) | (c___0 >> 15);
#line 208
  c___0 += d___0;
#line 209
  b___0 += (((c___0 & d___0) | (~ c___0 & a)) + x[15]) + 1236535329U;
#line 209
  b___0 = (b___0 << 22) | (b___0 >> 10);
#line 209
  b___0 += c___0;
#line 212
  a += (((b___0 & d___0) | (c___0 & ~ d___0)) + x[1]) + 4129170786U;
#line 212
  a = (a << 5) | (a >> 27);
#line 212
  a += b___0;
#line 213
  d___0 += (((a & c___0) | (b___0 & ~ c___0)) + x[6]) + 3225465664U;
#line 213
  d___0 = (d___0 << 9) | (d___0 >> 23);
#line 213
  d___0 += a;
#line 214
  c___0 += (((d___0 & b___0) | (a & ~ b___0)) + x[11]) + 643717713U;
#line 214
  c___0 = (c___0 << 14) | (c___0 >> 18);
#line 214
  c___0 += d___0;
#line 215
  b___0 += (((c___0 & a) | (d___0 & ~ a)) + x[0]) + 3921069994U;
#line 215
  b___0 = (b___0 << 20) | (b___0 >> 12);
#line 215
  b___0 += c___0;
#line 216
  a += (((b___0 & d___0) | (c___0 & ~ d___0)) + x[5]) + 3593408605U;
#line 216
  a = (a << 5) | (a >> 27);
#line 216
  a += b___0;
#line 217
  d___0 += (((a & c___0) | (b___0 & ~ c___0)) + x[10]) + 38016083U;
#line 217
  d___0 = (d___0 << 9) | (d___0 >> 23);
#line 217
  d___0 += a;
#line 218
  c___0 += (((d___0 & b___0) | (a & ~ b___0)) + x[15]) + 3634488961U;
#line 218
  c___0 = (c___0 << 14) | (c___0 >> 18);
#line 218
  c___0 += d___0;
#line 219
  b___0 += (((c___0 & a) | (d___0 & ~ a)) + x[4]) + 3889429448U;
#line 219
  b___0 = (b___0 << 20) | (b___0 >> 12);
#line 219
  b___0 += c___0;
#line 220
  a += (((b___0 & d___0) | (c___0 & ~ d___0)) + x[9]) + 568446438U;
#line 220
  a = (a << 5) | (a >> 27);
#line 220
  a += b___0;
#line 221
  d___0 += (((a & c___0) | (b___0 & ~ c___0)) + x[14]) + 3275163606U;
#line 221
  d___0 = (d___0 << 9) | (d___0 >> 23);
#line 221
  d___0 += a;
#line 222
  c___0 += (((d___0 & b___0) | (a & ~ b___0)) + x[3]) + 4107603335U;
#line 222
  c___0 = (c___0 << 14) | (c___0 >> 18);
#line 222
  c___0 += d___0;
#line 223
  b___0 += (((c___0 & a) | (d___0 & ~ a)) + x[8]) + 1163531501U;
#line 223
  b___0 = (b___0 << 20) | (b___0 >> 12);
#line 223
  b___0 += c___0;
#line 224
  a += (((b___0 & d___0) | (c___0 & ~ d___0)) + x[13]) + 2850285829U;
#line 224
  a = (a << 5) | (a >> 27);
#line 224
  a += b___0;
#line 225
  d___0 += (((a & c___0) | (b___0 & ~ c___0)) + x[2]) + 4243563512U;
#line 225
  d___0 = (d___0 << 9) | (d___0 >> 23);
#line 225
  d___0 += a;
#line 226
  c___0 += (((d___0 & b___0) | (a & ~ b___0)) + x[7]) + 1735328473U;
#line 226
  c___0 = (c___0 << 14) | (c___0 >> 18);
#line 226
  c___0 += d___0;
#line 227
  b___0 += (((c___0 & a) | (d___0 & ~ a)) + x[12]) + 2368359562U;
#line 227
  b___0 = (b___0 << 20) | (b___0 >> 12);
#line 227
  b___0 += c___0;
#line 230
  a += (((b___0 ^ c___0) ^ d___0) + x[5]) + 4294588738U;
#line 230
  a = (a << 4) | (a >> 28);
#line 230
  a += b___0;
#line 231
  d___0 += (((a ^ b___0) ^ c___0) + x[8]) + 2272392833U;
#line 231
  d___0 = (d___0 << 11) | (d___0 >> 21);
#line 231
  d___0 += a;
#line 232
  c___0 += (((d___0 ^ a) ^ b___0) + x[11]) + 1839030562U;
#line 232
  c___0 = (c___0 << 16) | (c___0 >> 16);
#line 232
  c___0 += d___0;
#line 233
  b___0 += (((c___0 ^ d___0) ^ a) + x[14]) + 4259657740U;
#line 233
  b___0 = (b___0 << 23) | (b___0 >> 9);
#line 233
  b___0 += c___0;
#line 234
  a += (((b___0 ^ c___0) ^ d___0) + x[1]) + 2763975236U;
#line 234
  a = (a << 4) | (a >> 28);
#line 234
  a += b___0;
#line 235
  d___0 += (((a ^ b___0) ^ c___0) + x[4]) + 1272893353U;
#line 235
  d___0 = (d___0 << 11) | (d___0 >> 21);
#line 235
  d___0 += a;
#line 236
  c___0 += (((d___0 ^ a) ^ b___0) + x[7]) + 4139469664U;
#line 236
  c___0 = (c___0 << 16) | (c___0 >> 16);
#line 236
  c___0 += d___0;
#line 237
  b___0 += (((c___0 ^ d___0) ^ a) + x[10]) + 3200236656U;
#line 237
  b___0 = (b___0 << 23) | (b___0 >> 9);
#line 237
  b___0 += c___0;
#line 238
  a += (((b___0 ^ c___0) ^ d___0) + x[13]) + 681279174U;
#line 238
  a = (a << 4) | (a >> 28);
#line 238
  a += b___0;
#line 239
  d___0 += (((a ^ b___0) ^ c___0) + x[0]) + 3936430074U;
#line 239
  d___0 = (d___0 << 11) | (d___0 >> 21);
#line 239
  d___0 += a;
#line 240
  c___0 += (((d___0 ^ a) ^ b___0) + x[3]) + 3572445317U;
#line 240
  c___0 = (c___0 << 16) | (c___0 >> 16);
#line 240
  c___0 += d___0;
#line 241
  b___0 += (((c___0 ^ d___0) ^ a) + x[6]) + 76029189U;
#line 241
  b___0 = (b___0 << 23) | (b___0 >> 9);
#line 241
  b___0 += c___0;
#line 242
  a += (((b___0 ^ c___0) ^ d___0) + x[9]) + 3654602809U;
#line 242
  a = (a << 4) | (a >> 28);
#line 242
  a += b___0;
#line 243
  d___0 += (((a ^ b___0) ^ c___0) + x[12]) + 3873151461U;
#line 243
  d___0 = (d___0 << 11) | (d___0 >> 21);
#line 243
  d___0 += a;
#line 244
  c___0 += (((d___0 ^ a) ^ b___0) + x[15]) + 530742520U;
#line 244
  c___0 = (c___0 << 16) | (c___0 >> 16);
#line 244
  c___0 += d___0;
#line 245
  b___0 += (((c___0 ^ d___0) ^ a) + x[2]) + 3299628645U;
#line 245
  b___0 = (b___0 << 23) | (b___0 >> 9);
#line 245
  b___0 += c___0;
#line 248
  a += ((c___0 ^ (b___0 | ~ d___0)) + x[0]) + 4096336452U;
#line 248
  a = (a << 6) | (a >> 26);
#line 248
  a += b___0;
#line 249
  d___0 += ((b___0 ^ (a | ~ c___0)) + x[7]) + 1126891415U;
#line 249
  d___0 = (d___0 << 10) | (d___0 >> 22);
#line 249
  d___0 += a;
#line 250
  c___0 += ((a ^ (d___0 | ~ b___0)) + x[14]) + 2878612391U;
#line 250
  c___0 = (c___0 << 15) | (c___0 >> 17);
#line 250
  c___0 += d___0;
#line 251
  b___0 += ((d___0 ^ (c___0 | ~ a)) + x[5]) + 4237533241U;
#line 251
  b___0 = (b___0 << 21) | (b___0 >> 11);
#line 251
  b___0 += c___0;
#line 252
  a += ((c___0 ^ (b___0 | ~ d___0)) + x[12]) + 1700485571U;
#line 252
  a = (a << 6) | (a >> 26);
#line 252
  a += b___0;
#line 253
  d___0 += ((b___0 ^ (a | ~ c___0)) + x[3]) + 2399980690U;
#line 253
  d___0 = (d___0 << 10) | (d___0 >> 22);
#line 253
  d___0 += a;
#line 254
  c___0 += ((a ^ (d___0 | ~ b___0)) + x[10]) + 4293915773U;
#line 254
  c___0 = (c___0 << 15) | (c___0 >> 17);
#line 254
  c___0 += d___0;
#line 255
  b___0 += ((d___0 ^ (c___0 | ~ a)) + x[1]) + 2240044497U;
#line 255
  b___0 = (b___0 << 21) | (b___0 >> 11);
#line 255
  b___0 += c___0;
#line 256
  a += ((c___0 ^ (b___0 | ~ d___0)) + x[8]) + 1873313359U;
#line 256
  a = (a << 6) | (a >> 26);
#line 256
  a += b___0;
#line 257
  d___0 += ((b___0 ^ (a | ~ c___0)) + x[15]) + 4264355552U;
#line 257
  d___0 = (d___0 << 10) | (d___0 >> 22);
#line 257
  d___0 += a;
#line 258
  c___0 += ((a ^ (d___0 | ~ b___0)) + x[6]) + 2734768916U;
#line 258
  c___0 = (c___0 << 15) | (c___0 >> 17);
#line 258
  c___0 += d___0;
#line 259
  b___0 += ((d___0 ^ (c___0 | ~ a)) + x[13]) + 1309151649U;
#line 259
  b___0 = (b___0 << 21) | (b___0 >> 11);
#line 259
  b___0 += c___0;
#line 260
  a += ((c___0 ^ (b___0 | ~ d___0)) + x[4]) + 4149444226U;
#line 260
  a = (a << 6) | (a >> 26);
#line 260
  a += b___0;
#line 261
  d___0 += ((b___0 ^ (a | ~ c___0)) + x[11]) + 3174756917U;
#line 261
  d___0 = (d___0 << 10) | (d___0 >> 22);
#line 261
  d___0 += a;
#line 262
  c___0 += ((a ^ (d___0 | ~ b___0)) + x[2]) + 718787259U;
#line 262
  c___0 = (c___0 << 15) | (c___0 >> 17);
#line 262
  c___0 += d___0;
#line 263
  b___0 += ((d___0 ^ (c___0 | ~ a)) + x[9]) + 3951481745U;
#line 263
  b___0 = (b___0 << 21) | (b___0 >> 11);
#line 263
  b___0 += c___0;
#line 265
  *(state + 0) += a;
#line 266
  *(state + 1) += b___0;
#line 267
  *(state + 2) += c___0;
#line 268
  *(state + 3) += d___0;
#line 272
  MD5_memset((POINTER )(x), 0, sizeof(x));
  }
#line 273
  return;
}
}
#line 278 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/md5c.c"
static void Encode(unsigned char *output , UINT4 *input , unsigned int len ) 
{ 
  unsigned int i ;
  unsigned int j ;

  {
#line 285
  i = 0U;
#line 285
  j = 0U;
  {
#line 285
  while (1) {
    while_continue: /* CIL Label */ ;
#line 285
    if (! (j < len)) {
#line 285
      goto while_break;
    }
#line 286
    *(output + j) = (unsigned char )(*(input + i) & 255U);
#line 287
    *(output + (j + 1U)) = (unsigned char )((*(input + i) >> 8) & 255U);
#line 288
    *(output + (j + 2U)) = (unsigned char )((*(input + i) >> 16) & 255U);
#line 289
    *(output + (j + 3U)) = (unsigned char )((*(input + i) >> 24) & 255U);
#line 285
    i ++;
#line 285
    j += 4U;
  }
  while_break: /* CIL Label */ ;
  }
#line 291
  return;
}
}
#line 296 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/md5c.c"
static void Decode(UINT4 *output , unsigned char *input , unsigned int len ) 
{ 
  unsigned int i ;
  unsigned int j ;

  {
#line 303
  i = 0U;
#line 303
  j = 0U;
  {
#line 303
  while (1) {
    while_continue: /* CIL Label */ ;
#line 303
    if (! (j < len)) {
#line 303
      goto while_break;
    }
#line 304
    *(output + i) = (((UINT4 )*(input + j) | ((UINT4 )*(input + (j + 1U)) << 8)) | ((UINT4 )*(input + (j + 2U)) << 16)) | ((UINT4 )*(input + (j + 3U)) << 24);
#line 303
    i ++;
#line 303
    j += 4U;
  }
  while_break: /* CIL Label */ ;
  }
#line 306
  return;
}
}
#line 311 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/md5c.c"
static void MD5_memcpy(POINTER output , POINTER input , unsigned int len ) 
{ 
  unsigned int i ;

  {
#line 318
  i = 0U;
  {
#line 318
  while (1) {
    while_continue: /* CIL Label */ ;
#line 318
    if (! (i < len)) {
#line 318
      goto while_break;
    }
#line 319
    *(output + i) = *(input + i);
#line 318
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 320
  return;
}
}
#line 324 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/md5c.c"
static void MD5_memset(POINTER output , int value , unsigned int len ) 
{ 
  unsigned int i ;

  {
#line 331
  i = 0U;
  {
#line 331
  while (1) {
    while_continue: /* CIL Label */ ;
#line 331
    if (! (i < len)) {
#line 331
      goto while_break;
    }
#line 332
    *((char *)output + i) = (char )value;
#line 331
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 333
  return;
}
}
#line 6 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/buffer_put.c"
static int allwrite___5(int (*op)() , int fd , char *buf , unsigned int len ) 
{ 
  int w ;
  int *tmp___3 ;

  {
  {
#line 10
  while (1) {
    while_continue: /* CIL Label */ ;
#line 10
    if (! len) {
#line 10
      goto while_break;
    }
    {
#line 11
    w = (*op)(fd, buf, len);
    }
#line 12
    if (w == -1) {
      {
#line 13
      tmp___3 = __errno_location();
      }
#line 13
      if (*tmp___3 == error_intr) {
#line 13
        goto while_continue;
      }
#line 14
      return (-1);
    }
#line 17
    buf += w;
#line 18
    len -= (unsigned int )w;
  }
  while_break: /* CIL Label */ ;
  }
#line 20
  return (0);
}
}
#line 17 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/checkapoppw.c"
static struct passwd *pw___0  ;
#line 19 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/checkapoppw.c"
static char up___0[513]  ;
#line 20 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/checkapoppw.c"
static int uplen___0  ;
#line 22 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/checkapoppw.c"
static stralloc stored___0  =    {(char *)0, 0U, 0U};
#line 23 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/checkapoppw.c"
static stralloc pwfile___0  =    {(char *)0, 0U, 0U};
#line 25 "/home/june/repo/benchmarks/collector/temp/checkpw-1.02/checkapoppw.c"
static char *hextable  =    (char *)"0123456789abcdef";
