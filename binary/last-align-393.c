/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 28 "/home/wheatley/newnew/temp/last-align-393/src/CA_code/lambda_calculator.c"
struct Lambda {
   double min ;
   double max ;
   int flag ;
};
#line 28 "/home/wheatley/newnew/temp/last-align-393/src/CA_code/lambda_calculator.c"
typedef struct Lambda Lambda;
#line 33 "/home/wheatley/newnew/temp/last-align-393/src/CA_code/lambda_calculator.c"
struct Sum {
   double value ;
   int flag ;
};
#line 33 "/home/wheatley/newnew/temp/last-align-393/src/CA_code/lambda_calculator.c"
typedef struct Sum Sum;
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 100 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) exp)(double __x ) ;
#line 109
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) log)(double __x ) ;
#line 181
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) fabs)(double __x )  __attribute__((__const__)) ;
#line 3 "/home/wheatley/newnew/temp/last-align-393/src/CA_code/nrutil.h"
float *vector(int nl , int nh ) ;
#line 4
float **matrix(int nrl , int nrh , int ncl , int nch ) ;
#line 5
float **convert_matrix(float *a , int nrl , int nrh , int ncl , int nch ) ;
#line 6
double *dvector(int nl , int nh ) ;
#line 7
double **dmatrix(int nrl , int nrh , int ncl , int nch ) ;
#line 8
int *ivector(int nl , int nh ) ;
#line 9
int **imatrix(int nrl , int nrh , int ncl , int nch ) ;
#line 10
float **submatrix(float **a , int oldrl , int oldrh , int oldcl , int oldch , int newrl ,
                  int newcl ) ;
#line 11
void free_vector(float *v , int nl , int nh ) ;
#line 12
void free_dvector(double *v , int nl , int nh ) ;
#line 13
void free_ivector(int *v , int nl , int nh ) ;
#line 14
void free_matrix(float **m , int nrl , int nrh , int ncl , int nch ) ;
#line 15
void free_dmatrix(double **m , int nrl , int nrh , int ncl , int nch ) ;
#line 16
void free_imatrix(int **m , int nrl , int nrh , int ncl , int nch ) ;
#line 17
void free_submatrix(float **b , int nrl , int nrh , int ncl , int nch ) ;
#line 18
void free_convert_matrix(float **b , int nrl , int nrh , int ncl , int nch ) ;
#line 19
void nrerror(char *error_text ) ;
#line 11 "/home/wheatley/newnew/temp/last-align-393/src/CA_code/lambda_calculator.c"
int Alphsize  ;
#line 7 "/home/wheatley/newnew/temp/last-align-393/src/CA_code/nrutil.c"
void nrerror(char *error_text ) 
{ 


  {
  {
#line 12
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Numerical Recipes run-time error...\n");
#line 13
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          error_text);
#line 14
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"...now exiting to system...\n");
#line 15
  exit(1);
  }
}
}
#line 18 "/home/wheatley/newnew/temp/last-align-393/src/CA_code/nrutil.c"
float *vector(int nl , int nh ) 
{ 
  float *v ;
  void *tmp ;

  {
  {
#line 23
  tmp = malloc((unsigned long )((unsigned int )((nh - nl) + 1)) * sizeof(float ));
#line 23
  v = (float *)tmp;
  }
#line 24
  if (! v) {
    {
#line 24
    nrerror((char *)"allocation failure in vector()");
    }
  }
#line 25
  return (v - nl);
}
}
#line 28 "/home/wheatley/newnew/temp/last-align-393/src/CA_code/nrutil.c"
int *ivector(int nl , int nh ) 
{ 
  int *v ;
  void *tmp ;

  {
  {
#line 33
  tmp = malloc((unsigned long )((unsigned int )((nh - nl) + 1)) * sizeof(int ));
#line 33
  v = (int *)tmp;
  }
#line 34
  if (! v) {
    {
#line 34
    nrerror((char *)"allocation failure in ivector()");
    }
  }
#line 35
  return (v - nl);
}
}
#line 38 "/home/wheatley/newnew/temp/last-align-393/src/CA_code/nrutil.c"
double *dvector(int nl , int nh ) 
{ 
  double *v ;
  void *tmp ;

  {
  {
#line 43
  tmp = malloc((unsigned long )((unsigned int )((nh - nl) + 1)) * sizeof(double ));
#line 43
  v = (double *)tmp;
  }
#line 44
  if (! v) {
    {
#line 44
    nrerror((char *)"allocation failure in dvector()");
    }
  }
#line 45
  return (v - nl);
}
}
#line 48 "/home/wheatley/newnew/temp/last-align-393/src/CA_code/nrutil.c"
float **matrix(int nrl , int nrh , int ncl , int nch ) 
{ 
  int i ;
  float **m ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 54
  tmp = malloc((unsigned long )((unsigned int )((nrh - nrl) + 1)) * sizeof(float *));
#line 54
  m = (float **)tmp;
  }
#line 55
  if (! m) {
    {
#line 55
    nrerror((char *)"allocation failure 1 in matrix()");
    }
  }
#line 56
  m -= nrl;
#line 58
  i = nrl;
  {
#line 58
  while (1) {
    while_continue: /* CIL Label */ ;
#line 58
    if (! (i <= nrh)) {
#line 58
      goto while_break;
    }
    {
#line 59
    tmp___0 = malloc((unsigned long )((unsigned int )((nch - ncl) + 1)) * sizeof(float ));
#line 59
    *(m + i) = (float *)tmp___0;
    }
#line 60
    if (! *(m + i)) {
      {
#line 60
      nrerror((char *)"allocation failure 2 in matrix()");
      }
    }
#line 61
    *(m + i) -= ncl;
#line 58
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 63
  return (m);
}
}
#line 66 "/home/wheatley/newnew/temp/last-align-393/src/CA_code/nrutil.c"
double **dmatrix(int nrl , int nrh , int ncl , int nch ) 
{ 
  int i ;
  double **m ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 72
  tmp = malloc((unsigned long )((unsigned int )((nrh - nrl) + 1)) * sizeof(double *));
#line 72
  m = (double **)tmp;
  }
#line 73
  if (! m) {
    {
#line 73
    nrerror((char *)"allocation failure 1 in dmatrix()");
    }
  }
#line 74
  m -= nrl;
#line 76
  i = nrl;
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
#line 76
    if (! (i <= nrh)) {
#line 76
      goto while_break;
    }
    {
#line 77
    tmp___0 = malloc((unsigned long )((unsigned int )((nch - ncl) + 1)) * sizeof(double ));
#line 77
    *(m + i) = (double *)tmp___0;
    }
#line 78
    if (! *(m + i)) {
      {
#line 78
      nrerror((char *)"allocation failure 2 in dmatrix()");
      }
    }
#line 79
    *(m + i) -= ncl;
#line 76
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 81
  return (m);
}
}
#line 84 "/home/wheatley/newnew/temp/last-align-393/src/CA_code/nrutil.c"
double ***darray3(int n1l , int n1h , int n2l , int n2h , int n3l , int n3h ) 
{ 
  int i ;
  double ***m ;
  void *tmp ;

  {
  {
#line 90
  tmp = malloc((unsigned long )((unsigned int )((n1h - n1l) + 1)) * sizeof(double **));
#line 90
  m = (double ***)tmp;
  }
#line 91
  if (! m) {
    {
#line 91
    nrerror((char *)"allocation failure 1 in darray3()");
    }
  }
#line 92
  m -= n1l;
#line 94
  i = n1l;
  {
#line 94
  while (1) {
    while_continue: /* CIL Label */ ;
#line 94
    if (! (i <= n1h)) {
#line 94
      goto while_break;
    }
    {
#line 96
    *(m + i) = dmatrix(n2l, n2h, n3l, n3h);
#line 94
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  return (m);
}
}
#line 101 "/home/wheatley/newnew/temp/last-align-393/src/CA_code/nrutil.c"
double ****darray4(int n1l , int n1h , int n2l , int n2h , int n3l , int n3h , int n4l ,
                   int n4h ) 
{ 
  int i ;
  double ****m ;
  void *tmp ;

  {
  {
#line 107
  tmp = malloc((unsigned long )((unsigned int )((n1h - n1l) + 1)) * sizeof(double ***));
#line 107
  m = (double ****)tmp;
  }
#line 108
  if (! m) {
    {
#line 108
    nrerror((char *)"allocation failure 1 in darray4()");
    }
  }
#line 109
  m -= n1l;
#line 111
  i = n1l;
  {
#line 111
  while (1) {
    while_continue: /* CIL Label */ ;
#line 111
    if (! (i <= n1h)) {
#line 111
      goto while_break;
    }
    {
#line 113
    *(m + i) = darray3(n2l, n2h, n3l, n3h, n4l, n4h);
#line 111
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 115
  return (m);
}
}
#line 118 "/home/wheatley/newnew/temp/last-align-393/src/CA_code/nrutil.c"
int **imatrix(int nrl , int nrh , int ncl , int nch ) 
{ 
  int i ;
  int **m ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 123
  tmp = malloc((unsigned long )((unsigned int )((nrh - nrl) + 1)) * sizeof(int *));
#line 123
  m = (int **)tmp;
  }
#line 124
  if (! m) {
    {
#line 124
    nrerror((char *)"allocation failure 1 in imatrix()");
    }
  }
#line 125
  m -= nrl;
#line 127
  i = nrl;
  {
#line 127
  while (1) {
    while_continue: /* CIL Label */ ;
#line 127
    if (! (i <= nrh)) {
#line 127
      goto while_break;
    }
    {
#line 128
    tmp___0 = malloc((unsigned long )((unsigned int )((nch - ncl) + 1)) * sizeof(int ));
#line 128
    *(m + i) = (int *)tmp___0;
    }
#line 129
    if (! *(m + i)) {
      {
#line 129
      nrerror((char *)"allocation failure 2 in imatrix()");
      }
    }
#line 130
    *(m + i) -= ncl;
#line 127
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 132
  return (m);
}
}
#line 135 "/home/wheatley/newnew/temp/last-align-393/src/CA_code/nrutil.c"
float **submatrix(float **a , int oldrl , int oldrh , int oldcl , int oldch , int newrl ,
                  int newcl ) 
{ 
  int i ;
  int j ;
  float **m ;
  void *tmp ;

  {
  {
#line 142
  tmp = malloc((unsigned long )((unsigned int )((oldrh - oldrl) + 1)) * sizeof(float *));
#line 142
  m = (float **)tmp;
  }
#line 143
  if (! m) {
    {
#line 143
    nrerror((char *)"allocation failure in submatrix()");
    }
  }
#line 144
  m -= newrl;
#line 146
  i = oldrl;
#line 146
  j = newrl;
  {
#line 146
  while (1) {
    while_continue: /* CIL Label */ ;
#line 146
    if (! (i <= oldrh)) {
#line 146
      goto while_break;
    }
#line 146
    *(m + j) = (*(a + i) + oldcl) - newcl;
#line 146
    i ++;
#line 146
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 148
  return (m);
}
}
#line 151 "/home/wheatley/newnew/temp/last-align-393/src/CA_code/nrutil.c"
void free_vector(float *v , int nl , int nh ) 
{ 


  {
  {
#line 155
  free((void *)((char *)(v + nl)));
  }
#line 156
  return;
}
}
#line 158 "/home/wheatley/newnew/temp/last-align-393/src/CA_code/nrutil.c"
void free_ivector(int *v , int nl , int nh ) 
{ 


  {
  {
#line 161
  free((void *)((char *)(v + nl)));
  }
#line 162
  return;
}
}
#line 164 "/home/wheatley/newnew/temp/last-align-393/src/CA_code/nrutil.c"
void free_dvector(double *v , int nl , int nh ) 
{ 


  {
  {
#line 168
  free((void *)((char *)(v + nl)));
  }
#line 169
  return;
}
}
#line 171 "/home/wheatley/newnew/temp/last-align-393/src/CA_code/nrutil.c"
void free_matrix(float **m , int nrl , int nrh , int ncl , int nch ) 
{ 
  int i ;

  {
#line 177
  i = nrh;
  {
#line 177
  while (1) {
    while_continue: /* CIL Label */ ;
#line 177
    if (! (i >= nrl)) {
#line 177
      goto while_break;
    }
    {
#line 177
    free((void *)((char *)(*(m + i) + ncl)));
#line 177
    i --;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 178
  free((void *)((char *)(m + nrl)));
  }
#line 179
  return;
}
}
#line 181 "/home/wheatley/newnew/temp/last-align-393/src/CA_code/nrutil.c"
void free_dmatrix(double **m , int nrl , int nrh , int ncl , int nch ) 
{ 
  int i ;

  {
#line 187
  i = nrh;
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 187
    if (! (i >= nrl)) {
#line 187
      goto while_break;
    }
    {
#line 187
    free((void *)((char *)(*(m + i) + ncl)));
#line 187
    i --;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 188
  free((void *)((char *)(m + nrl)));
  }
#line 189
  return;
}
}
#line 191 "/home/wheatley/newnew/temp/last-align-393/src/CA_code/nrutil.c"
void free_imatrix(int **m , int nrl , int nrh , int ncl , int nch ) 
{ 
  int i ;

  {
#line 197
  i = nrh;
  {
#line 197
  while (1) {
    while_continue: /* CIL Label */ ;
#line 197
    if (! (i >= nrl)) {
#line 197
      goto while_break;
    }
    {
#line 197
    free((void *)((char *)(*(m + i) + ncl)));
#line 197
    i --;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 198
  free((void *)((char *)(m + nrl)));
  }
#line 199
  return;
}
}
#line 201 "/home/wheatley/newnew/temp/last-align-393/src/CA_code/nrutil.c"
void free_darray3(double ***m , int n1l , int n1h , int n2l , int n2h , int n3l ,
                  int n3h ) 
{ 
  int i ;

  {
#line 207
  i = n1h;
  {
#line 207
  while (1) {
    while_continue: /* CIL Label */ ;
#line 207
    if (! (i >= n1l)) {
#line 207
      goto while_break;
    }
    {
#line 207
    free_dmatrix(*(m + i), n2l, n2h, n3l, n3h);
#line 207
    i --;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 208
  free((void *)((char *)(m + n1l)));
  }
#line 209
  return;
}
}
#line 211 "/home/wheatley/newnew/temp/last-align-393/src/CA_code/nrutil.c"
void free_submatrix(float **b , int nrl , int nrh , int ncl , int nch ) 
{ 


  {
  {
#line 215
  free((void *)((char *)(b + nrl)));
  }
#line 216
  return;
}
}
#line 218 "/home/wheatley/newnew/temp/last-align-393/src/CA_code/nrutil.c"
float **convert_matrix(float *a , int nrl , int nrh , int ncl , int nch ) 
{ 
  int i ;
  int j ;
  int nrow ;
  int ncol ;
  float **m ;
  void *tmp ;

  {
  {
#line 225
  nrow = (nrh - nrl) + 1;
#line 226
  ncol = (nch - ncl) + 1;
#line 227
  tmp = malloc((unsigned long )((unsigned int )nrow) * sizeof(float *));
#line 227
  m = (float **)tmp;
  }
#line 228
  if (! m) {
    {
#line 228
    nrerror((char *)"allocation failure in convert_matrix()");
    }
  }
#line 229
  m -= nrl;
#line 230
  i = 0;
#line 230
  j = nrl;
  {
#line 230
  while (1) {
    while_continue: /* CIL Label */ ;
#line 230
    if (! (i <= nrow - 1)) {
#line 230
      goto while_break;
    }
#line 230
    *(m + j) = (a + ncol * i) - ncl;
#line 230
    i ++;
#line 230
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 231
  return (m);
}
}
#line 234 "/home/wheatley/newnew/temp/last-align-393/src/CA_code/nrutil.c"
void free_convert_matrix(float **b , int nrl , int nrh , int ncl , int nch ) 
{ 


  {
  {
#line 238
  free((void *)((char *)(b + nrl)));
  }
#line 239
  return;
}
}
#line 7 "/home/wheatley/newnew/temp/last-align-393/src/CA_code/ludcmp.c"
void ludcmp(double **a , int n , int *indx , double *d ) 
{ 
  int i ;
  int imax ;
  int j ;
  int k ;
  double big ;
  double dum ;
  double sum ;
  double temp ;
  double *vv ;
  double tmp ;

  {
  {
#line 16
  vv = dvector(1, n);
#line 17
  *d = 1.0;
#line 18
  i = 1;
  }
  {
#line 18
  while (1) {
    while_continue: /* CIL Label */ ;
#line 18
    if (! (i <= n)) {
#line 18
      goto while_break;
    }
#line 19
    big = 0.0;
#line 20
    j = 1;
    {
#line 20
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 20
      if (! (j <= n)) {
#line 20
        goto while_break___0;
      }
      {
#line 21
      temp = fabs(*(*(a + i) + j));
      }
#line 21
      if (temp > big) {
#line 21
        big = temp;
      }
#line 20
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 22
    if (big == 0.0) {
      {
#line 22
      nrerror((char *)"Singular matrix in routine LUDCMP");
      }
    }
#line 23
    *(vv + i) = 1.0 / big;
#line 18
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 25
  j = 1;
  {
#line 25
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 25
    if (! (j <= n)) {
#line 25
      goto while_break___1;
    }
#line 26
    i = 1;
    {
#line 26
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 26
      if (! (i < j)) {
#line 26
        goto while_break___2;
      }
#line 27
      sum = *(*(a + i) + j);
#line 28
      k = 1;
      {
#line 28
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 28
        if (! (k < i)) {
#line 28
          goto while_break___3;
        }
#line 28
        sum -= *(*(a + i) + k) * *(*(a + k) + j);
#line 28
        k ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 29
      *(*(a + i) + j) = sum;
#line 26
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 31
    big = 0.0;
#line 32
    i = j;
    {
#line 32
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 32
      if (! (i <= n)) {
#line 32
        goto while_break___4;
      }
#line 33
      sum = *(*(a + i) + j);
#line 34
      k = 1;
      {
#line 34
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 34
        if (! (k < j)) {
#line 34
          goto while_break___5;
        }
#line 35
        sum -= *(*(a + i) + k) * *(*(a + k) + j);
#line 34
        k ++;
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 36
      *(*(a + i) + j) = sum;
#line 37
      tmp = fabs(sum);
#line 37
      dum = *(vv + i) * tmp;
      }
#line 37
      if (dum >= big) {
#line 38
        big = dum;
#line 39
        imax = i;
      }
#line 32
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 42
    if (j != imax) {
#line 43
      k = 1;
      {
#line 43
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 43
        if (! (k <= n)) {
#line 43
          goto while_break___6;
        }
#line 44
        dum = *(*(a + imax) + k);
#line 45
        *(*(a + imax) + k) = *(*(a + j) + k);
#line 46
        *(*(a + j) + k) = dum;
#line 43
        k ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 48
      *d = - *d;
#line 49
      *(vv + imax) = *(vv + j);
    }
#line 51
    *(indx + j) = imax;
#line 52
    if (*(*(a + j) + j) == 0.0) {
#line 52
      *(*(a + j) + j) = 1.0e-20;
    }
#line 53
    if (j != n) {
#line 54
      dum = 1.0 / *(*(a + j) + j);
#line 55
      i = j + 1;
      {
#line 55
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 55
        if (! (i <= n)) {
#line 55
          goto while_break___7;
        }
#line 55
        *(*(a + i) + j) *= dum;
#line 55
        i ++;
      }
      while_break___7: /* CIL Label */ ;
      }
    }
#line 25
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 58
  free_dvector(vv, 1, n);
  }
#line 59
  return;
}
}
#line 3 "/home/wheatley/newnew/temp/last-align-393/src/CA_code/lubksb.c"
void lubksb(double **a , int n , int *indx , double *b ) 
{ 
  int i ;
  int ii ;
  int ip ;
  int j ;
  double sum ;

  {
#line 7
  ii = 0;
#line 10
  i = 1;
  {
#line 10
  while (1) {
    while_continue: /* CIL Label */ ;
#line 10
    if (! (i <= n)) {
#line 10
      goto while_break;
    }
#line 11
    ip = *(indx + i);
#line 12
    sum = *(b + ip);
#line 13
    *(b + ip) = *(b + i);
#line 14
    if (ii) {
#line 15
      j = ii;
      {
#line 15
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 15
        if (! (j <= i - 1)) {
#line 15
          goto while_break___0;
        }
#line 15
        sum -= *(*(a + i) + j) * *(b + j);
#line 15
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else
#line 16
    if (sum) {
#line 16
      ii = i;
    }
#line 17
    *(b + i) = sum;
#line 10
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 19
  i = n;
  {
#line 19
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 19
    if (! (i >= 1)) {
#line 19
      goto while_break___1;
    }
#line 20
    sum = *(b + i);
#line 21
    j = i + 1;
    {
#line 21
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 21
      if (! (j <= n)) {
#line 21
        goto while_break___2;
      }
#line 21
      sum -= *(*(a + i) + j) * *(b + j);
#line 21
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 22
    *(b + i) = sum / *(*(a + i) + i);
#line 19
    i --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 24
  return;
}
}
#line 7 "/home/wheatley/newnew/temp/last-align-393/src/CA_code/lambda_calculator.h"
double calculate_lambda(double const   **mat_b , int alpha_size , double *p , double *q ) ;
#line 24 "/home/wheatley/newnew/temp/last-align-393/src/CA_code/lambda_calculator.c"
double Lambda_UB  ;
#line 25 "/home/wheatley/newnew/temp/last-align-393/src/CA_code/lambda_calculator.c"
double r_max_m  ;
#line 25 "/home/wheatley/newnew/temp/last-align-393/src/CA_code/lambda_calculator.c"
double c_max_m  ;
#line 27
void makematrix(double const   **mat_b , double **a , double lambda ) ;
#line 37
Lambda Find_JP(double const   **mat_b , double la_min , double la_max , double **JP ,
               double *p_in , double *q_in ) ;
#line 38
Sum Check_root(double const   **mat_b , double **a , double lambda , double *p , double *q ) ;
#line 39
double Check_det(double const   **mat_b , double **a , double lambda ) ;
#line 40
Sum Nail_lambda(double const   **mat_b , int flag_sign , double lambda_min , double lambda_max ,
                double *p , double *q , double *lam_add ) ;
#line 41
double Nail_det(double const   **mat_b , int flag_sign , double lambda_min , double lambda_max ) ;
#line 42
int Check_range(double const   **mat_b ) ;
#line 44
double *Locate_det_zero(double const   **mat_b , int *N_root_add ) ;
#line 47 "/home/wheatley/newnew/temp/last-align-393/src/CA_code/lambda_calculator.c"
double calculate_lambda(double const   **mat_b , int alpha_size , double *p , double *q ) 
{ 
  double **JP ;
  int k ;
  double *root_location ;
  int N_root ;
  Lambda Lambda_local ;
  int tmp ;

  {
  {
#line 56
  Alphsize = alpha_size;
#line 58
  tmp = Check_range(mat_b);
  }
#line 58
  if (! tmp) {
#line 58
    return (- 1.0);
  }
  {
#line 60
  root_location = Locate_det_zero(mat_b, & N_root);
  }
#line 61
  if ((unsigned long )root_location == (unsigned long )((void *)0)) {
#line 61
    if (N_root > 0) {
#line 61
      return (- 1.0);
    }
  }
  {
#line 65
  JP = dmatrix(1, Alphsize, 1, Alphsize);
  }
#line 67
  if (N_root == 0) {
    {
#line 68
    Lambda_local = Find_JP(mat_b, (double )0, Lambda_UB, JP, p, q);
    }
#line 69
    if (1 == Lambda_local.flag) {
      {
#line 73
      free((void *)root_location);
#line 74
      free_dmatrix(JP, 1, Alphsize, 1, Alphsize);
      }
#line 75
      return ((Lambda_local.min + Lambda_local.max) / 2.0);
    }
  } else
#line 81
  if (N_root > 0) {
#line 84
    k = 0;
    {
#line 84
    while (1) {
      while_continue: /* CIL Label */ ;
#line 84
      if (! (k <= N_root)) {
#line 84
        goto while_break;
      }
#line 85
      if (k == 0) {
#line 85
        Lambda_local.min = (double )0;
#line 85
        Lambda_local.max = *(root_location + 0);
      } else
#line 86
      if (k == N_root) {
#line 86
        Lambda_local.min = *(root_location + (N_root - 1));
#line 86
        Lambda_local.max = Lambda_UB + 1.0e-36;
      } else {
#line 87
        Lambda_local.min = *(root_location + (k - 1));
#line 87
        Lambda_local.max = *(root_location + k);
      }
      {
#line 88
      Lambda_local = Find_JP(mat_b, Lambda_local.min, Lambda_local.max, JP, p, q);
      }
#line 89
      if (1 == Lambda_local.flag) {
        {
#line 92
        free((void *)root_location);
#line 93
        free_dmatrix(JP, 1, Alphsize, 1, Alphsize);
        }
#line 94
        return ((Lambda_local.min + Lambda_local.max) / 2.0);
      }
#line 84
      k ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 104
  free((void *)root_location);
#line 105
  free_dmatrix(JP, 1, Alphsize, 1, Alphsize);
  }
#line 106
  return (- 1.0);
}
}
#line 109 "/home/wheatley/newnew/temp/last-align-393/src/CA_code/lambda_calculator.c"
int Check_range(double const   **mat_b ) 
{ 
  int i ;
  int j ;
  int pos_flag_r ;
  int neg_flag_r ;
  int pos_flag_c ;
  int neg_flag_c ;
  double r_max ;
  double c_max ;
  int L_r ;
  int L_c ;
  double tmp ;
  double tmp___0 ;

  {
#line 116
  L_r = 0;
#line 116
  L_c = 0;
#line 119
  c_max_m = 100000000000.0;
#line 119
  r_max_m = c_max_m;
#line 120
  i = 1;
  {
#line 120
  while (1) {
    while_continue: /* CIL Label */ ;
#line 120
    if (! (i <= Alphsize)) {
#line 120
      goto while_break;
    }
#line 121
    r_max = (double )0;
#line 121
    c_max = (double )0;
#line 122
    pos_flag_r = -1;
#line 122
    neg_flag_r = -1;
#line 122
    pos_flag_c = -1;
#line 122
    neg_flag_c = -1;
#line 123
    j = 1;
    {
#line 123
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 123
      if (! (j <= Alphsize)) {
#line 123
        goto while_break___0;
      }
#line 124
      if (*(*(mat_b + i) + j) > (double const   )0) {
#line 125
        if (*(*(mat_b + i) + j) > (double const   )r_max) {
#line 125
          r_max = (double )*(*(mat_b + i) + j);
        }
#line 126
        pos_flag_r = 1;
      } else
#line 128
      if (*(*(mat_b + i) + j) < (double const   )0) {
#line 128
        neg_flag_r = 1;
      }
#line 129
      if (*(*(mat_b + j) + i) > (double const   )0) {
#line 130
        if (*(*(mat_b + j) + i) > (double const   )c_max) {
#line 130
          c_max = (double )*(*(mat_b + j) + i);
        }
#line 131
        pos_flag_c = 1;
      } else
#line 133
      if (*(*(mat_b + j) + i) < (double const   )0) {
#line 133
        neg_flag_c = 1;
      }
#line 123
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 135
    if (pos_flag_r == -1) {
#line 135
      goto _L___0;
    } else
#line 135
    if (neg_flag_r == -1) {
#line 135
      goto _L___0;
    } else
#line 135
    if (pos_flag_c == -1) {
#line 135
      goto _L___0;
    } else
#line 135
    if (neg_flag_c == -1) {
      _L___0: /* CIL Label */ 
#line 136
      if (pos_flag_r == -1) {
#line 136
        if (neg_flag_r == -1) {
          {
#line 137
          printf((char const   */* __restrict  */)"only zero score at row  %d\n",
                 i);
#line 138
          L_r ++;
          }
        } else {
#line 136
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 140
      if (pos_flag_c == -1) {
#line 140
        if (neg_flag_c == -1) {
          {
#line 141
          printf((char const   */* __restrict  */)"only zero score at column %d\n",
                 i);
#line 142
          L_c ++;
          }
        } else {
#line 147
          return (0);
        }
      } else {
#line 147
        return (0);
      }
    }
#line 151
    if (r_max < r_max_m) {
#line 151
      if (r_max > (double )0) {
#line 151
        r_max_m = r_max;
      }
    }
#line 152
    if (c_max < c_max_m) {
#line 152
      if (c_max > (double )0) {
#line 152
        c_max_m = c_max;
      }
    }
#line 120
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 157
  if (r_max_m > c_max_m) {
    {
#line 158
    tmp = log(1.0 * (double )Alphsize - (double )L_r);
#line 158
    Lambda_UB = (1.1 * tmp) / r_max_m;
    }
  } else {
    {
#line 161
    tmp___0 = log(1.0 * (double )Alphsize - (double )L_c);
#line 161
    Lambda_UB = (1.1 * tmp___0) / c_max_m;
    }
  }
#line 164
  return (1);
}
}
#line 169 "/home/wheatley/newnew/temp/last-align-393/src/CA_code/lambda_calculator.c"
double Check_det(double const   **mat_b , double **a , double lambda ) 
{ 
  double d ;
  int i ;
  int *indx ;

  {
  {
#line 174
  indx = ivector(1, Alphsize);
#line 175
  makematrix(mat_b, a, lambda);
#line 176
  ludcmp(a, Alphsize, indx, & d);
#line 177
  i = 1;
  }
  {
#line 177
  while (1) {
    while_continue: /* CIL Label */ ;
#line 177
    if (! (i <= Alphsize)) {
#line 177
      goto while_break;
    }
#line 177
    d *= *(*(a + i) + i);
#line 177
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 178
  free_ivector(indx, 1, Alphsize);
  }
#line 179
  return (d);
}
}
#line 183 "/home/wheatley/newnew/temp/last-align-393/src/CA_code/lambda_calculator.c"
Sum Check_root(double const   **mat_b , double **a , double lambda , double *p , double *q ) 
{ 
  double **y ;
  double d ;
  int i ;
  int j ;
  Sum Sum_here ;
  int *indx ;
  unsigned long __lengthofindx ;
  void *tmp ;
  double *col ;
  unsigned long __lengthofcol ;
  void *tmp___0 ;

  {
  {
#line 190
  y = dmatrix(1, Alphsize, 1, Alphsize);
#line 192
  __lengthofindx = (unsigned long )(Alphsize + 1);
#line 192
  tmp = __builtin_alloca(sizeof(*indx) * __lengthofindx);
#line 192
  indx = (int *)tmp;
#line 194
  __lengthofcol = (unsigned long )(Alphsize + 1);
#line 194
  tmp___0 = __builtin_alloca(sizeof(*col) * __lengthofcol);
#line 194
  col = (double *)tmp___0;
#line 196
  makematrix(mat_b, a, lambda);
#line 197
  ludcmp(a, Alphsize, indx, & d);
#line 198
  Sum_here.value = 0.0;
#line 199
  i = 1;
  }
  {
#line 199
  while (1) {
    while_continue: /* CIL Label */ ;
#line 199
    if (! (i <= Alphsize)) {
#line 199
      goto while_break;
    }
#line 199
    *(q + i) = 0.0;
#line 199
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 200
  j = 1;
  {
#line 200
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 200
    if (! (j <= Alphsize)) {
#line 200
      goto while_break___0;
    }
#line 201
    i = 1;
    {
#line 201
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 201
      if (! (i <= Alphsize)) {
#line 201
        goto while_break___1;
      }
#line 201
      *(col + i) = 0.0;
#line 201
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 202
    *(col + j) = 1.0;
#line 203
    lubksb(a, Alphsize, indx, col);
#line 204
    *(p + j) = 0.0;
#line 205
    i = 1;
    }
    {
#line 205
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 205
      if (! (i <= Alphsize)) {
#line 205
        goto while_break___2;
      }
#line 206
      *(*(y + i) + j) = *(col + i);
#line 206
      Sum_here.value += *(*(y + i) + j);
#line 207
      *(p + j) += *(*(y + i) + j);
#line 207
      *(q + i) += *(*(y + i) + j);
#line 205
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 200
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 211
  Sum_here.flag = 1;
#line 212
  i = 1;
  {
#line 212
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 212
    if (! (i < Alphsize)) {
#line 212
      goto while_break___3;
    }
#line 213
    if (*(p + i) < (double )0) {
#line 214
      Sum_here.flag = -1;
    } else
#line 213
    if (*(q + i) < (double )0) {
#line 214
      Sum_here.flag = -1;
    }
#line 212
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 218
  free_dmatrix(y, 1, Alphsize, 1, Alphsize);
  }
#line 219
  return (Sum_here);
}
}
#line 224 "/home/wheatley/newnew/temp/last-align-393/src/CA_code/lambda_calculator.c"
double *Locate_det_zero(double const   **mat_b , int *N_root_add ) 
{ 
  double **a ;
  int i ;
  int N ;
  int flag_sign ;
  double lambda ;
  double lambda_root ;
  double dlambda ;
  double root[5000] ;
  double *root_temp ;
  int zero_monitor ;
  double tmp ;
  double *l_here ;
  unsigned long __lengthofl_here ;
  void *tmp___0 ;
  double *s_here ;
  unsigned long __lengthofs_here ;
  void *tmp___1 ;
  int tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;
  double tmp___9 ;
  void *tmp___10 ;

  {
  {
#line 236
  zero_monitor = 0;
#line 239
  a = dmatrix(1, Alphsize, 1, Alphsize);
  }
#line 243
  if ((double )400 > (double )((int )(Lambda_UB - (double )0)) / 0.005) {
#line 243
    tmp = (double )400;
  } else {
#line 243
    tmp = (double )((int )(Lambda_UB - (double )0)) / 0.005;
  }
  {
#line 243
  N = (int )((double )2 + tmp);
#line 245
  dlambda = Lambda_UB / ((double )N * 1.0);
#line 248
  __lengthofl_here = (unsigned long )(N + 1);
#line 248
  tmp___0 = __builtin_alloca(sizeof(*l_here) * __lengthofl_here);
#line 248
  l_here = (double *)tmp___0;
#line 249
  __lengthofs_here = (unsigned long )(N + 1);
#line 249
  tmp___1 = __builtin_alloca(sizeof(*s_here) * __lengthofs_here);
#line 249
  s_here = (double *)tmp___1;
#line 251
  i = 0;
  }
  {
#line 251
  while (1) {
    while_continue: /* CIL Label */ ;
#line 251
    if (! (i < N)) {
#line 251
      goto while_break;
    }
    {
#line 252
    lambda = (double )(i + 1) * dlambda;
#line 253
    *(s_here + i) = Check_det(mat_b, a, lambda);
#line 254
    *(l_here + i) = lambda;
#line 251
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 257
  if (*(s_here + 0) < 0.0) {
#line 257
    flag_sign = -1;
  }
#line 258
  if (*(s_here + 0) > 0.0) {
#line 258
    flag_sign = 1;
  }
  {
#line 259
  tmp___3 = fabs(*(s_here + 0));
#line 259
  tmp___4 = exp((*(l_here + 0) * (r_max_m + c_max_m)) / 2.0);
  }
#line 259
  if (tmp___3 / tmp___4 <= 1.0e-36) {
#line 260
    tmp___2 = zero_monitor;
#line 260
    zero_monitor ++;
#line 260
    root[tmp___2] = *(l_here + 0);
#line 261
    flag_sign = 0;
  }
#line 264
  i = 1;
  {
#line 264
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 264
    if (! (i < N)) {
#line 264
      goto while_break___0;
    }
#line 265
    if (flag_sign != 0) {
      {
#line 265
      tmp___9 = fabs(*(s_here + i));
      }
#line 265
      if (tmp___9 > 1.0e-36) {
#line 266
        if (*(s_here + (i - 1)) * *(s_here + i) < (double )0) {
          {
#line 268
          lambda_root = Nail_det(mat_b, flag_sign, *(l_here + (i - 1)), *(l_here + i));
#line 269
          tmp___5 = zero_monitor;
#line 269
          zero_monitor ++;
#line 269
          root[tmp___5] = lambda_root;
#line 270
          flag_sign = - flag_sign;
          }
        }
      } else {
#line 265
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 275
      if (*(s_here + i) < 0.0) {
#line 275
        flag_sign = -1;
      }
#line 276
      if (*(s_here + i) > 0.0) {
#line 276
        flag_sign = 1;
      }
      {
#line 277
      tmp___7 = fabs(*(s_here + i));
#line 277
      tmp___8 = exp((*(l_here + i) * (r_max_m + c_max_m)) / 2.0);
      }
#line 277
      if (tmp___7 / tmp___8 <= 1.0e-36) {
#line 278
        tmp___6 = zero_monitor;
#line 278
        zero_monitor ++;
#line 278
        root[tmp___6] = *(l_here + i);
      }
    }
#line 264
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 283
  tmp___10 = malloc((unsigned long )zero_monitor * sizeof(double ));
#line 283
  root_temp = (double *)tmp___10;
#line 284
  *N_root_add = zero_monitor;
  }
#line 285
  if (zero_monitor > 0) {
#line 286
    if (zero_monitor >= N / 4) {
      {
#line 289
      free((void *)root_temp);
      }
#line 290
      return ((double *)((void *)0));
    }
#line 293
    i = 0;
    {
#line 293
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 293
      if (! (i < zero_monitor)) {
#line 293
        goto while_break___1;
      }
#line 294
      *(root_temp + i) = root[i];
#line 293
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 298
  free_dmatrix(a, 1, Alphsize, 1, Alphsize);
  }
#line 299
  return (root_temp);
}
}
#line 304 "/home/wheatley/newnew/temp/last-align-393/src/CA_code/lambda_calculator.c"
Lambda Find_JP(double const   **mat_b , double la_min , double la_max , double **JP ,
               double *p_in , double *q_in ) 
{ 
  double **a ;
  double *q ;
  double *p ;
  int i ;
  int j ;
  int N ;
  double lambda ;
  double lambda_max ;
  double lambda_min ;
  double lambda_final ;
  double dlambda ;
  int flag_sign ;
  int flag_done ;
  int i_monitor ;
  int j_monitor ;
  Lambda Lambda_local ;
  Sum Sum_local ;
  double tmp ;
  double *l_here ;
  unsigned long __lengthofl_here ;
  void *tmp___0 ;
  double *s_here ;
  unsigned long __lengthofs_here ;
  void *tmp___1 ;

  {
  {
#line 315
  flag_done = -1;
#line 316
  i_monitor = 0;
#line 323
  lambda_min = la_min;
#line 324
  lambda_max = la_max;
#line 325
  q = q_in;
#line 326
  p = p_in;
#line 327
  a = dmatrix(1, Alphsize, 1, Alphsize);
  }
#line 331
  if ((double )400 > (double )((int )(lambda_max - lambda_min)) / 0.005) {
#line 331
    tmp = (double )400;
  } else {
#line 331
    tmp = (double )((int )(lambda_max - lambda_min)) / 0.005;
  }
  {
#line 331
  N = (int )((double )2 + tmp);
#line 333
  dlambda = (lambda_max - lambda_min) / ((double )N * 1.0);
#line 336
  __lengthofl_here = (unsigned long )(N + 1);
#line 336
  tmp___0 = __builtin_alloca(sizeof(*l_here) * __lengthofl_here);
#line 336
  l_here = (double *)tmp___0;
#line 337
  __lengthofs_here = (unsigned long )(N + 1);
#line 337
  tmp___1 = __builtin_alloca(sizeof(*s_here) * __lengthofs_here);
#line 337
  s_here = (double *)tmp___1;
#line 339
  i = 0;
  }
  {
#line 339
  while (1) {
    while_continue: /* CIL Label */ ;
#line 339
    if (! (i < N - 1)) {
#line 339
      goto while_break;
    }
    {
#line 340
    lambda = lambda_min + (double )(i + 1) * dlambda;
#line 341
    makematrix(mat_b, a, lambda);
#line 342
    Sum_local = Check_root(mat_b, a, lambda, p, q);
#line 343
    *(l_here + i) = lambda;
#line 344
    *(s_here + i) = Sum_local.value - 1.0;
#line 339
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 348
  if (*(s_here + 0) < 0.0) {
#line 348
    flag_sign = -1;
  } else
#line 349
  if (*(s_here + 0) > 0.0) {
#line 349
    flag_sign = 1;
  } else
#line 350
  if (*(s_here + 0) == 0.0) {
    {
#line 351
    printf((char const   */* __restrict  */)"enter the exact hit, rarely occurs other than when lambda = 0 \n");
#line 352
    j_monitor = 1;
#line 353
    flag_sign = 0;
    }
    {
#line 354
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 354
      if (flag_sign == 0) {
#line 354
        if (! (j_monitor < N)) {
#line 354
          goto while_break___0;
        }
      } else {
#line 354
        goto while_break___0;
      }
      {
#line 355
      Sum_local = Check_root(mat_b, a, *(l_here + 0) + ((double )j_monitor * dlambda) / (double )N,
                             p, q);
      }
#line 356
      if (Sum_local.value > 1.0) {
#line 357
        flag_sign = 1;
      } else
#line 359
      if (Sum_local.value < 1.0) {
#line 360
        flag_sign = -1;
      }
#line 362
      j_monitor ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 366
  i = 1;
  {
#line 366
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 366
    if (! (i < N)) {
#line 366
      goto while_break___1;
    }
#line 367
    if (flag_sign == 0) {
      {
#line 367
      printf((char const   */* __restrict  */)"flag_sign = 0 \n");
#line 367
      exit(1);
      }
    }
#line 368
    if (*(s_here + (i - 1)) * *(s_here + i) < (double )0) {
      {
#line 369
      lambda_min = *(l_here + (i - 1));
#line 370
      lambda_max = *(l_here + i);
#line 371
      Sum_local = Nail_lambda(mat_b, flag_sign, lambda_min, lambda_max, p, q, & lambda_final);
      }
#line 372
      if (Sum_local.flag == 1) {
#line 373
        i = N;
#line 373
        flag_done = 1;
#line 373
        Lambda_local.flag = 1;
#line 374
        Lambda_local.min = lambda_final;
#line 374
        Lambda_local.max = lambda_final;
      }
#line 376
      flag_sign = - flag_sign;
#line 377
      i_monitor ++;
    }
#line 366
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 381
  if (flag_done == 1) {
    {
#line 383
    makematrix(mat_b, a, lambda_final);
#line 384
    i = 1;
    }
    {
#line 384
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 384
      if (! (i <= Alphsize)) {
#line 384
        goto while_break___2;
      }
#line 385
      j = 1;
      {
#line 385
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 385
        if (! (j <= Alphsize)) {
#line 385
          goto while_break___3;
        }
#line 386
        *(*(JP + i) + j) = (*(*(a + i) + j) * *(p + i)) * *(q + j);
#line 385
        j ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 384
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 389
    free_dmatrix(a, 1, Alphsize, 1, Alphsize);
    }
#line 390
    return (Lambda_local);
  } else
#line 392
  if (flag_done == -1) {
#line 394
    Lambda_local.flag = -1;
#line 394
    Lambda_local.min = (double )0;
#line 394
    Lambda_local.max = 1000000.0;
#line 395
    return (Lambda_local);
  }
#line 398
  return (Lambda_local);
}
}
#line 402 "/home/wheatley/newnew/temp/last-align-393/src/CA_code/lambda_calculator.c"
Sum Nail_lambda(double const   **mat_b , int flag_sign , double lambda_min , double lambda_max ,
                double *p , double *q , double *lam_add ) 
{ 
  double **a ;
  double lambda ;
  Sum Sum_local ;
  double tmp ;

  {
  {
#line 409
  a = dmatrix(1, Alphsize, 1, Alphsize);
#line 412
  lambda = (lambda_min + lambda_max) / 2.0;
#line 413
  Sum_local = Check_root(mat_b, a, lambda, p, q);
  }
  {
#line 414
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 414
    tmp = fabs(Sum_local.value - 1.0);
    }
#line 414
    if (! (tmp > 1.0e-12)) {
#line 414
      goto while_break;
    }
#line 415
    if ((double )flag_sign * (Sum_local.value - 1.0) < (double )0) {
#line 415
      lambda_max = lambda;
    } else
#line 416
    if ((double )flag_sign * (Sum_local.value - 1.0) > (double )0) {
#line 416
      lambda_min = lambda;
    }
#line 419
    if (lambda == (lambda_min + lambda_max) / 2.0) {
#line 420
      Sum_local.flag = -1;
#line 421
      goto while_break;
    }
    {
#line 424
    lambda = (lambda_min + lambda_max) / 2.0;
#line 425
    Sum_local = Check_root(mat_b, a, lambda, p, q);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 427
  free_dmatrix(a, 1, Alphsize, 1, Alphsize);
#line 428
  *lam_add = lambda;
  }
#line 429
  return (Sum_local);
}
}
#line 433 "/home/wheatley/newnew/temp/last-align-393/src/CA_code/lambda_calculator.c"
double Nail_det(double const   **mat_b , int flag_sign , double lambda_min , double lambda_max ) 
{ 
  double **a ;
  double lambda ;
  double value ;
  double tmp ;

  {
  {
#line 439
  a = dmatrix(1, Alphsize, 1, Alphsize);
#line 441
  lambda = (lambda_min + lambda_max) / 2.0;
#line 442
  value = Check_det(mat_b, a, lambda);
  }
  {
#line 443
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 443
    tmp = fabs(value);
    }
#line 443
    if (tmp > 1.0e-12) {
#line 443
      if (! (lambda > (double )0)) {
#line 443
        goto while_break;
      }
    } else {
#line 443
      goto while_break;
    }
#line 444
    if ((double )flag_sign * value < (double )0) {
#line 444
      lambda_max = lambda;
    } else
#line 445
    if ((double )flag_sign * value > (double )0) {
#line 445
      lambda_min = lambda;
    }
    {
#line 446
    lambda = (lambda_min + lambda_max) / 2.0;
#line 447
    value = Check_det(mat_b, a, lambda);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 449
  free_dmatrix(a, 1, Alphsize, 1, Alphsize);
  }
#line 450
  return (lambda);
}
}
#line 453 "/home/wheatley/newnew/temp/last-align-393/src/CA_code/lambda_calculator.c"
void makematrix(double const   **mat_b , double **a , double lambda ) 
{ 
  int i ;
  int j ;

  {
#line 458
  i = 1;
  {
#line 458
  while (1) {
    while_continue: /* CIL Label */ ;
#line 458
    if (! (i <= Alphsize)) {
#line 458
      goto while_break;
    }
#line 459
    j = 1;
    {
#line 459
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 459
      if (! (j <= Alphsize)) {
#line 459
        goto while_break___0;
      }
      {
#line 460
      *(*(a + i) + j) = exp(lambda * (double )*(*(mat_b + i) + j));
#line 459
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 458
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 462
  return;
}
}
