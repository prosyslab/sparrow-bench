/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 29 "/home/june/repo/benchmarks/collector/temp/glosstex-0.4.dfsg.1/error.h"
enum e_loglevel {
    ERROR = 0,
    WARNING = 1,
    PROGRESS = 2,
    INFORMATION = 3,
    VERBOSE = 4,
    DEBUG = 5
} ;
#line 29 "/home/june/repo/benchmarks/collector/temp/glosstex-0.4.dfsg.1/list.h"
struct s_node_s {
   void *ptr ;
   struct s_node_s *next ;
};
#line 29 "/home/june/repo/benchmarks/collector/temp/glosstex-0.4.dfsg.1/list.h"
typedef struct s_node_s s_node;
#line 34 "/home/june/repo/benchmarks/collector/temp/glosstex-0.4.dfsg.1/list.h"
struct s_list_s {
   s_node *root ;
   s_node *top ;
};
#line 34 "/home/june/repo/benchmarks/collector/temp/glosstex-0.4.dfsg.1/list.h"
typedef struct s_list_s s_list;
#line 39 "/home/june/repo/benchmarks/collector/temp/glosstex-0.4.dfsg.1/list.h"
struct s_list_iterator_s {
   s_node *root ;
   s_node *current ;
};
#line 39 "/home/june/repo/benchmarks/collector/temp/glosstex-0.4.dfsg.1/list.h"
typedef struct s_list_iterator_s s_list_iterator;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 33 "/home/june/repo/benchmarks/collector/temp/glosstex-0.4.dfsg.1/labels.h"
enum e_label_flag {
    UNRESOLVED = 0,
    RESOLVED = 1
} ;
#line 36
enum e_find_mode {
    FIND_FIRST = 0,
    FIND_NEXT = 1
} ;
#line 40 "/home/june/repo/benchmarks/collector/temp/glosstex-0.4.dfsg.1/labels.h"
struct s_label_s {
   char *label ;
   char *pageref_mode ;
   char *list ;
   char *list_mode ;
   char *page ;
   enum e_label_flag flag ;
};
#line 40 "/home/june/repo/benchmarks/collector/temp/glosstex-0.4.dfsg.1/labels.h"
typedef struct s_label_s s_label;
#line 37 "/home/june/repo/benchmarks/collector/temp/glosstex-0.4.dfsg.1/database.c"
enum e_pass {
    PASS_1 = 0,
    PASS_2 = 1
} ;
#line 78
enum e_state {
    HEADER = 0,
    BODY = 1
} ;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 98 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 36 "/home/june/repo/benchmarks/collector/temp/glosstex-0.4.dfsg.1/error.h"
void error(char const   *fmt  , ...) ;
#line 37
void printlog(enum e_loglevel level , int output_to , char const   *fmt  , ...) ;
#line 272 "/usr/include/stdio.h"
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 44 "/home/june/repo/benchmarks/collector/temp/glosstex-0.4.dfsg.1/glosstex.h"
s_list labels ;
#line 45
s_list databases ;
#line 52
FILE *outfile ;
#line 61
unsigned int count_gdf_parsing ;
#line 62
unsigned int count_gdf_defined ;
#line 63
unsigned int count_gdf_success ;
#line 31 "/home/june/repo/benchmarks/collector/temp/glosstex-0.4.dfsg.1/database.h"
void read_databases(void) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/glosstex-0.4.dfsg.1/labels.h"
s_label *find_label(s_list_iterator *iterator , enum e_find_mode find_mode , char *label ,
                    char *list ) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/glosstex-0.4.dfsg.1/database.c"
static unsigned int lineno  =    0U;
#line 43
static void process_file(enum e_pass pass , FILE *dbfile , char *inname___0 ) ;
#line 44
static void process_line(enum e_pass pass , char *inname___0 , char *line ) ;
#line 45
static void write_line(FILE *outfile___0 , char *inname___0 , char *list , char *label ,
                       char *item , char *longform , char *line , char *list_mode ,
                       char *pageref_mode , char *page ) ;
#line 50
static int glo_parse_item(char *line , char *label , char *item , char *longform ,
                          int *ptr ) ;
#line 53 "/home/june/repo/benchmarks/collector/temp/glosstex-0.4.dfsg.1/database.c"
void read_databases(void) 
{ 
  FILE *dbfile ;
  enum e_pass pass ;
  s_node *filename ;

  {
#line 57
  pass = (enum e_pass )0;
#line 58
  filename = databases.root;
#line 60
  pass = (enum e_pass )0;
  {
#line 60
  while (1) {
    while_continue: /* CIL Label */ ;
#line 60
    if (! ((unsigned int )pass <= 1U)) {
#line 60
      goto while_break;
    }
    {
#line 61
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 61
      if (! ((unsigned long )filename != (unsigned long )((s_node *)0))) {
#line 61
        goto while_break___0;
      }
      {
#line 62
      dbfile = fopen((char const   */* __restrict  */)filename->ptr, (char const   */* __restrict  */)"r");
      }
#line 62
      if ((unsigned long )dbfile == (unsigned long )((void *)0)) {
        {
#line 63
        error("database %s", (char *)filename->ptr);
        }
      } else {
        {
#line 65
        printlog((enum e_loglevel )2, 1, "(%s ", (char *)filename->ptr);
#line 66
        process_file(pass, dbfile, (char *)filename->ptr);
#line 67
        printlog((enum e_loglevel )2, 1, ")");
        }
      }
#line 69
      filename = filename->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 71
    filename = databases.root;
#line 60
    pass = (enum e_pass )((unsigned int )pass + 1U);
  }
  while_break: /* CIL Label */ ;
  }
#line 73
  return;
}
}
#line 75 "/home/june/repo/benchmarks/collector/temp/glosstex-0.4.dfsg.1/database.c"
static void process_file(enum e_pass pass , FILE *dbfile , char *inname___0 ) 
{ 
  int status ;
  char buf[1024] ;
  enum e_state state ;
  char *line ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t len ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;

  {
#line 84
  state = (enum e_state )0;
#line 85
  line = (char *)0;
  {
#line 87
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 87
    tmp___10 = fgets((char */* __restrict  */)(buf), 1024, (FILE */* __restrict  */)dbfile);
    }
#line 87
    if (! ((unsigned long )tmp___10 != (unsigned long )((char *)0))) {
#line 87
      goto while_break;
    }
    {
#line 88
    tmp = strlen((char const   *)(buf));
    }
#line 88
    if ((int )buf[tmp - 1UL] == 10) {
#line 89
      lineno ++;
    }
    {
#line 91
    status = strncmp((char const   *)(buf), "@entry{", (size_t )7);
    }
#line 92
    if ((unsigned int )state == 0U) {
#line 92
      if (! (status != 0)) {
#line 92
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 95
      state = (enum e_state )1;
#line 96
      if (status == 0) {
#line 99
        if ((unsigned long )line != (unsigned long )((char *)0)) {
          {
#line 100
          process_line(pass, inname___0, line);
#line 101
          free((void *)line);
          }
        }
        {
#line 103
        tmp___0 = strlen((char const   *)(buf));
#line 103
        tmp___1 = malloc(tmp___0 + 1UL);
#line 103
        line = (char *)tmp___1;
        }
#line 104
        if (! ((unsigned long )line != (unsigned long )((char *)0))) {
          {
#line 104
          __assert_fail("line != 0", "/home/june/repo/benchmarks/collector/temp/glosstex-0.4.dfsg.1/database.c",
                        104U, "process_file");
          }
        }
        {
#line 105
        strcpy((char */* __restrict  */)line, (char const   */* __restrict  */)(buf));
#line 107
        tmp___3 = strlen((char const   *)line);
        }
#line 107
        if ((int )*(line + (tmp___3 - 1UL)) == 10) {
          {
#line 108
          tmp___2 = strlen((char const   *)line);
#line 108
          *(line + (tmp___2 - 1UL)) = (char )' ';
          }
        }
      } else {
        {
#line 110
        tmp___9 = strncmp((char const   *)(buf), "%", (size_t )1);
        }
#line 110
        if (! (tmp___9 == 0)) {
          {
#line 113
          tmp___4 = strlen((char const   *)line);
#line 113
          len = tmp___4;
#line 114
          tmp___5 = strlen((char const   *)(buf));
#line 114
          tmp___6 = realloc((void *)line, (len + tmp___5) + 1UL);
#line 114
          line = (char *)tmp___6;
          }
#line 115
          if (! ((unsigned long )line != (unsigned long )((char *)0))) {
            {
#line 115
            __assert_fail("line != 0", "/home/june/repo/benchmarks/collector/temp/glosstex-0.4.dfsg.1/database.c",
                          115U, "process_file");
            }
          }
          {
#line 116
          strcpy((char */* __restrict  */)(line + len), (char const   */* __restrict  */)(buf));
#line 117
          tmp___8 = strlen((char const   *)line);
          }
#line 117
          if ((int )*(line + (tmp___8 - 1UL)) == 10) {
            {
#line 118
            tmp___7 = strlen((char const   *)line);
#line 118
            *(line + (tmp___7 - 1UL)) = (char )' ';
            }
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 124
  if ((unsigned long )line != (unsigned long )((char *)0)) {
    {
#line 125
    process_line(pass, inname___0, line);
#line 126
    free((void *)line);
    }
  }
#line 128
  return;
}
}
#line 130 "/home/june/repo/benchmarks/collector/temp/glosstex-0.4.dfsg.1/database.c"
static void process_line(enum e_pass pass , char *inname___0 , char *line ) 
{ 
  char label[1024] ;
  char item[1024] ;
  char longform[1024] ;
  size_t index ;
  int ptr ;
  s_list_iterator iter ;
  s_list_iterator iter2 ;
  s_label *node ;
  s_label *node2 ;
  int tmp ;

  {
  {
#line 137
  ptr = 0;
#line 143
  iter.root = labels.root;
#line 144
  iter.current = labels.root;
#line 145
  iter2.root = labels.root;
#line 146
  iter2.current = labels.root;
#line 148
  tmp = glo_parse_item(line, label, item, longform, & ptr);
  }
#line 148
  if (tmp != 0) {
    {
#line 149
    printlog((enum e_loglevel )2, 1, "x");
#line 150
    printlog((enum e_loglevel )1, 2, "\n%s:%u parse error: %s", inname___0, lineno,
             line);
#line 152
    count_gdf_parsing ++;
    }
#line 153
    return;
  }
  {
#line 156
  index = strlen((char const   *)(line + ptr));
#line 157
  index --;
  }
  {
#line 159
  while (1) {
    while_continue: /* CIL Label */ ;
#line 159
    if (! ((int )*(line + ((size_t )ptr + index)) == 32)) {
#line 159
      goto while_break;
    }
#line 160
    *(line + ((size_t )ptr + index)) = (char )'\000';
#line 161
    index --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 165
  if ((unsigned int )pass == 0U) {
#line 165
    goto case_0;
  }
#line 193
  if ((unsigned int )pass == 1U) {
#line 193
    goto case_1___0;
  }
#line 164
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 167
  node = find_label(& iter, (enum e_find_mode )0, label, (char *)0);
  }
#line 169
  if ((unsigned long )node != (unsigned long )((s_label *)0)) {
    {
#line 172
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 172
      if (! ((unsigned long )node != (unsigned long )((s_label *)0))) {
#line 172
        goto while_break___0;
      }
      {
#line 174
      if ((unsigned int )node->flag == 0U) {
#line 174
        goto case_0___0;
      }
#line 181
      if ((unsigned int )node->flag == 1U) {
#line 181
        goto case_1;
      }
#line 173
      goto switch_break___0;
      case_0___0: /* CIL Label */ 
      {
#line 175
      write_line(outfile, inname___0, node->list, label, item, longform, line + ptr,
                 node->list_mode, node->pageref_mode, node->page);
#line 178
      node->flag = (enum e_label_flag )1;
      }
#line 179
      goto switch_break___0;
      case_1: /* CIL Label */ 
      {
#line 182
      printlog((enum e_loglevel )2, 1, "i");
#line 183
      printlog((enum e_loglevel )3, 2, "\n%s:%u %s already resolved", inname___0,
               lineno, label);
#line 186
      count_gdf_defined ++;
      }
#line 187
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
      {
#line 189
      node = find_label(& iter, (enum e_find_mode )1, label, (char *)0);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 192
  goto switch_break;
  case_1___0: /* CIL Label */ 
  {
#line 195
  node = find_label(& iter, (enum e_find_mode )0, (char *)"*", (char *)0);
  }
#line 197
  if ((unsigned long )node == (unsigned long )((s_label *)0)) {
    {
#line 198
    printlog((enum e_loglevel )2, 1, ".");
#line 199
    printlog((enum e_loglevel )5, 2, "\n%s:%u %s@%s(%s) not needed", inname___0, lineno,
             label, item, longform);
    }
  } else {
    {
#line 203
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 203
      if (! ((unsigned long )node != (unsigned long )((s_label *)0))) {
#line 203
        goto while_break___1;
      }
      {
#line 205
      node2 = find_label(& iter2, (enum e_find_mode )0, label, node->list);
      }
#line 205
      if ((unsigned long )node2 == (unsigned long )((s_label *)0)) {
        {
#line 207
        write_line(outfile, inname___0, node->list, label, item, longform, line + ptr,
                   node->list_mode, node->pageref_mode, node->page);
#line 210
        node->flag = (enum e_label_flag )1;
        }
      }
      {
#line 212
      node = find_label(& iter, (enum e_find_mode )1, (char *)"*", (char *)0);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 215
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 217
  return;
}
}
#line 219 "/home/june/repo/benchmarks/collector/temp/glosstex-0.4.dfsg.1/database.c"
static void write_line(FILE *outfile___0 , char *inname___0 , char *list , char *label ,
                       char *item , char *longform , char *line , char *list_mode ,
                       char *pageref_mode , char *page ) 
{ 


  {
  {
#line 225
  fprintf((FILE */* __restrict  */)outfile___0, (char const   */* __restrict  */)"\\GlossTeXEntry{%s%s@{%s}{%s}{%s}{%s}{%s}{%s}{\\GlossTeXPage{%s}{%s}}|GlossTeXNull}{0}\n",
          list, label, label, item, longform, line, list, list_mode, pageref_mode,
          page);
#line 230
  printlog((enum e_loglevel )2, 1, "o");
#line 231
  printlog((enum e_loglevel )4, 2, "\n%s:%u %s@%s(%s) used *", inname___0, lineno,
           label, item, longform);
#line 233
  count_gdf_success ++;
  }
#line 234
  return;
}
}
#line 254 "/home/june/repo/benchmarks/collector/temp/glosstex-0.4.dfsg.1/database.c"
static int glo_parse_item(char *line , char *label , char *item , char *longform ,
                          int *ptr ) 
{ 
  int i ;
  int brace ;
  char x ;
  int tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  unsigned short const   **tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 261
  i = 0;
#line 262
  brace = 1;
#line 263
  *ptr = 7;
  {
#line 264
  while (1) {
    while_continue: /* CIL Label */ ;
#line 265
    tmp = *ptr;
#line 265
    (*ptr) ++;
#line 265
    x = *(line + tmp);
#line 266
    if ((int )x == 0) {
#line 267
      return (1);
    }
#line 268
    if ((int )x == 123) {
#line 269
      if ((int )*(line + (*ptr - 2)) != 92) {
#line 270
        brace ++;
      }
    }
#line 271
    if ((int )x == 125) {
#line 272
      if ((int )*(line + (*ptr - 2)) != 92) {
#line 273
        brace --;
      }
#line 274
      if (brace <= 0) {
#line 275
        goto while_break;
      }
    }
#line 277
    if ((int )x == 44) {
#line 278
      goto while_break;
    }
#line 279
    tmp___0 = i;
#line 279
    i ++;
#line 279
    *(label + tmp___0) = x;
  }
  while_break: /* CIL Label */ ;
  }
#line 281
  *(label + i) = (char )'\000';
  {
#line 284
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 284
    tmp___1 = __ctype_b_loc();
    }
#line 284
    if (! (((int const   )*(*tmp___1 + (int )*(line + *ptr)) & 8192) != 0)) {
#line 284
      goto while_break___0;
    }
#line 285
    (*ptr) ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 288
  i = 0;
  {
#line 289
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 289
    if (! (brace > 0)) {
#line 289
      goto while_break___1;
    }
#line 290
    tmp___2 = *ptr;
#line 290
    (*ptr) ++;
#line 290
    x = *(line + tmp___2);
#line 291
    if ((int )x == 0) {
#line 292
      return (1);
    }
#line 293
    if ((int )x == 123) {
#line 294
      if ((int )*(line + (*ptr - 2)) != 92) {
#line 295
        brace ++;
      }
    }
#line 296
    if ((int )x == 125) {
#line 297
      if ((int )*(line + (*ptr - 2)) != 92) {
#line 298
        brace --;
      }
#line 299
      if (brace <= 0) {
#line 300
        goto while_break___1;
      }
    }
#line 302
    if ((int )x == 44) {
#line 303
      goto while_break___1;
    }
#line 304
    tmp___3 = i;
#line 304
    i ++;
#line 304
    *(item + tmp___3) = x;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 306
  *(item + i) = (char )'\000';
#line 309
  if (i == 0) {
    {
#line 310
    strcpy((char */* __restrict  */)item, (char const   */* __restrict  */)label);
    }
  }
  {
#line 312
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 312
    tmp___4 = __ctype_b_loc();
    }
#line 312
    if (! (((int const   )*(*tmp___4 + (int )*(line + *ptr)) & 8192) != 0)) {
#line 312
      goto while_break___2;
    }
#line 313
    (*ptr) ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 316
  i = 0;
  {
#line 317
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 317
    if (! (brace > 0)) {
#line 317
      goto while_break___3;
    }
#line 318
    tmp___5 = *ptr;
#line 318
    (*ptr) ++;
#line 318
    x = *(line + tmp___5);
#line 319
    if ((int )x == 0) {
#line 320
      return (1);
    }
#line 321
    if ((int )x == 123) {
#line 322
      if ((int )*(line + (*ptr - 2)) != 92) {
#line 323
        brace ++;
      }
    }
#line 324
    if ((int )x == 125) {
#line 325
      if ((int )*(line + (*ptr - 2)) != 92) {
#line 326
        brace --;
      }
#line 327
      if (brace <= 0) {
#line 328
        goto while_break___3;
      }
    }
#line 330
    tmp___6 = i;
#line 330
    i ++;
#line 330
    *(longform + tmp___6) = x;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 332
  *(longform + i) = (char )'\000';
#line 334
  return (0);
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/glosstex-0.4.dfsg.1/list.h"
void *list_add(s_list *list , void *ptr ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/glosstex-0.4.dfsg.1/glosstex.h"
enum e_loglevel loglevel ;
#line 44 "/home/june/repo/benchmarks/collector/temp/glosstex-0.4.dfsg.1/glosstex.h"
s_list labels  ;
#line 45 "/home/june/repo/benchmarks/collector/temp/glosstex-0.4.dfsg.1/glosstex.h"
s_list databases  ;
#line 47
char *inname ;
#line 48
char *outname ;
#line 49
char *logname ;
#line 52 "/home/june/repo/benchmarks/collector/temp/glosstex-0.4.dfsg.1/glosstex.h"
FILE *outfile  ;
#line 53 "/home/june/repo/benchmarks/collector/temp/glosstex-0.4.dfsg.1/glosstex.h"
FILE *logfile  ;
#line 55
char *progname ;
#line 57
unsigned int count_label_parsing ;
#line 58
unsigned int count_label_defined ;
#line 59
unsigned int count_label_override ;
#line 60
unsigned int count_label_success ;
#line 61 "/home/june/repo/benchmarks/collector/temp/glosstex-0.4.dfsg.1/glosstex.h"
unsigned int count_gdf_parsing  ;
#line 62 "/home/june/repo/benchmarks/collector/temp/glosstex-0.4.dfsg.1/glosstex.h"
unsigned int count_gdf_defined  ;
#line 63 "/home/june/repo/benchmarks/collector/temp/glosstex-0.4.dfsg.1/glosstex.h"
unsigned int count_gdf_success  ;
#line 49 "/home/june/repo/benchmarks/collector/temp/glosstex-0.4.dfsg.1/labels.h"
int read_labels(char *inname___0 ) ;
#line 52
unsigned int show_unresolved_labels(s_list list , FILE *file ) ;
#line 29 "/home/june/repo/benchmarks/collector/temp/glosstex-0.4.dfsg.1/version.h"
char version[108] ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 285
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strcspn)(char const   *__s ,
                                                                                                   char const   *__reject )  __attribute__((__pure__)) ;
#line 826 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 38 "/home/june/repo/benchmarks/collector/temp/glosstex-0.4.dfsg.1/main.c"
enum e_loglevel loglevel  =    (enum e_loglevel )2;
#line 43 "/home/june/repo/benchmarks/collector/temp/glosstex-0.4.dfsg.1/main.c"
char *progname  =    (char *)0;
#line 45 "/home/june/repo/benchmarks/collector/temp/glosstex-0.4.dfsg.1/main.c"
char *inname  =    (char *)0;
#line 46 "/home/june/repo/benchmarks/collector/temp/glosstex-0.4.dfsg.1/main.c"
char *outname  =    (char *)0;
#line 47 "/home/june/repo/benchmarks/collector/temp/glosstex-0.4.dfsg.1/main.c"
char *logname  =    (char *)0;
#line 52 "/home/june/repo/benchmarks/collector/temp/glosstex-0.4.dfsg.1/main.c"
unsigned int count_label_parsing  =    0U;
#line 53 "/home/june/repo/benchmarks/collector/temp/glosstex-0.4.dfsg.1/main.c"
unsigned int count_label_defined  =    0U;
#line 54 "/home/june/repo/benchmarks/collector/temp/glosstex-0.4.dfsg.1/main.c"
unsigned int count_label_override  =    0U;
#line 55 "/home/june/repo/benchmarks/collector/temp/glosstex-0.4.dfsg.1/main.c"
unsigned int count_label_success  =    0U;
#line 56 "/home/june/repo/benchmarks/collector/temp/glosstex-0.4.dfsg.1/main.c"
unsigned int count_label_unresolved  =    0U;
#line 62 "/home/june/repo/benchmarks/collector/temp/glosstex-0.4.dfsg.1/main.c"
char usage[41]  = 
#line 62
  {      (char )'U',      (char )'s',      (char )'a',      (char )'g', 
        (char )'e',      (char )':',      (char )' ',      (char )'%', 
        (char )'s',      (char )' ',      (char )'a',      (char )'u', 
        (char )'x',      (char )' ',      (char )'g',      (char )'d', 
        (char )'f',      (char )'0',      (char )' ',      (char )'[', 
        (char )'g',      (char )'d',      (char )'f',      (char )'1', 
        (char )' ',      (char )'.',      (char )'.',      (char )'.', 
        (char )']',      (char )' ',      (char )'[',      (char )'-', 
        (char )'v',      (char )'[',      (char )'0',      (char )'-', 
        (char )'5',      (char )']',      (char )']',      (char )'\n', 
        (char )'\000'};
#line 64
static void parse_commandline(int argc , char **argv ) ;
#line 65
static void open_files(void) ;
#line 66
static char *check_extension(char const   *string , char const   *ext ) ;
#line 67
static char *build_filename(char const   *string , char const   *ext ) ;
#line 69 "/home/june/repo/benchmarks/collector/temp/glosstex-0.4.dfsg.1/main.c"
int main(int argc , char **argv ) 
{ 
  size_t tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 72
  labels.top = (s_node *)0;
#line 72
  labels.root = labels.top;
#line 73
  databases.top = (s_node *)0;
#line 73
  databases.root = databases.top;
#line 75
  if (! ((unsigned long )*(argv + 0) != (unsigned long )((char *)0))) {
    {
#line 75
    __assert_fail("argv[0] != 0", "/home/june/repo/benchmarks/collector/temp/glosstex-0.4.dfsg.1/main.c",
                  75U, "main");
    }
  }
  {
#line 76
  tmp = strlen((char const   *)*(argv + 0));
#line 76
  tmp___0 = malloc(tmp + 1UL);
#line 76
  progname = (char *)tmp___0;
  }
#line 78
  if (! ((unsigned long )progname != (unsigned long )((char *)0))) {
    {
#line 78
    __assert_fail("progname != 0", "/home/june/repo/benchmarks/collector/temp/glosstex-0.4.dfsg.1/main.c",
                  78U, "main");
    }
  }
  {
#line 79
  strcpy((char */* __restrict  */)progname, (char const   */* __restrict  */)*(argv + 0));
#line 81
  printf((char const   */* __restrict  */)"%s\n", version);
#line 83
  parse_commandline(argc, argv);
#line 85
  open_files();
#line 87
  tmp___3 = read_labels(inname);
  }
#line 87
  if (tmp___3 != 0) {
    {
#line 88
    tmp___1 = unlink((char const   *)outname);
    }
#line 88
    if (tmp___1 != 0) {
      {
#line 89
      error("output-file %s", outname);
#line 90
      exit(1);
      }
    }
    {
#line 92
    tmp___2 = unlink((char const   *)logname);
    }
#line 92
    if (tmp___2 != 0) {
      {
#line 93
      error("logfile %s", outname);
#line 94
      exit(1);
      }
    }
    {
#line 96
    exit(1);
    }
  }
  {
#line 99
  printlog((enum e_loglevel )2, 1, "\n(parse errors:%d, overrides: %d, success:%d)\n\n",
           count_label_parsing, count_label_override, count_label_success);
#line 103
  read_databases();
#line 104
  printlog((enum e_loglevel )2, 1, "\n(parse errors:%d, terms already defined: %d, success:%d)\n",
           count_gdf_parsing, count_gdf_defined, count_gdf_success);
#line 108
  count_label_unresolved = show_unresolved_labels(labels, logfile);
  }
#line 108
  if (count_label_unresolved != 0U) {
    {
#line 109
    printlog((enum e_loglevel )2, 1, "\n(unresolved labels: %d)", count_label_unresolved,
             logname);
    }
  }
  {
#line 112
  printlog((enum e_loglevel )2, 1, "\nWrote output-file %s, log-file %s\n", outname,
           logname);
  }
#line 115
  return (0);
}
}
#line 118 "/home/june/repo/benchmarks/collector/temp/glosstex-0.4.dfsg.1/main.c"
static void parse_commandline(int argc , char **argv ) 
{ 
  int index ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 123
  if (argc < 3) {
    {
#line 124
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)(usage),
            progname);
#line 125
    exit(1);
    }
  }
  {
#line 127
  inname = check_extension((char const   *)*(argv + 1), ".aux");
#line 129
  index = 2;
  }
  {
#line 129
  while (1) {
    while_continue: /* CIL Label */ ;
#line 129
    if (! (index < argc)) {
#line 129
      goto while_break;
    }
    {
#line 130
    tmp___6 = strncmp((char const   *)*(argv + index), "-v0", (size_t )3);
    }
#line 130
    if (tmp___6 == 0) {
#line 131
      loglevel = (enum e_loglevel )0;
    } else {
      {
#line 132
      tmp___5 = strncmp((char const   *)*(argv + index), "-v1", (size_t )3);
      }
#line 132
      if (tmp___5 == 0) {
#line 133
        loglevel = (enum e_loglevel )1;
      } else {
        {
#line 134
        tmp___4 = strncmp((char const   *)*(argv + index), "-v2", (size_t )3);
        }
#line 134
        if (tmp___4 == 0) {
#line 135
          loglevel = (enum e_loglevel )2;
        } else {
          {
#line 136
          tmp___3 = strncmp((char const   *)*(argv + index), "-v3", (size_t )3);
          }
#line 136
          if (tmp___3 == 0) {
#line 137
            loglevel = (enum e_loglevel )3;
          } else {
            {
#line 138
            tmp___2 = strncmp((char const   *)*(argv + index), "-v4", (size_t )3);
            }
#line 138
            if (tmp___2 == 0) {
#line 139
              loglevel = (enum e_loglevel )4;
            } else {
              {
#line 140
              tmp___1 = strncmp((char const   *)*(argv + index), "-v5", (size_t )3);
              }
#line 140
              if (tmp___1 == 0) {
#line 141
                loglevel = (enum e_loglevel )5;
              } else {
                {
#line 142
                tmp___0 = strncmp((char const   *)*(argv + index), "-v", (size_t )2);
                }
#line 142
                if (tmp___0 == 0) {
#line 143
                  loglevel = (enum e_loglevel )4;
                } else {
                  {
#line 145
                  tmp = check_extension((char const   *)*(argv + index), ".gdf");
#line 145
                  list_add(& databases, (void *)tmp);
                  }
                }
              }
            }
          }
        }
      }
    }
#line 129
    index ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 148
  return;
}
}
#line 150 "/home/june/repo/benchmarks/collector/temp/glosstex-0.4.dfsg.1/main.c"
static void open_files(void) 
{ 


  {
#line 153
  if ((unsigned long )outname == (unsigned long )((char *)0)) {
    {
#line 154
    outname = build_filename((char const   *)inname, ".gxs");
    }
  }
  {
#line 156
  outfile = fopen((char const   */* __restrict  */)outname, (char const   */* __restrict  */)"w");
  }
#line 156
  if ((unsigned long )outfile == (unsigned long )((void *)0)) {
    {
#line 157
    error("output-file %s", outname);
#line 158
    exit(1);
    }
  }
#line 161
  if ((unsigned long )logname == (unsigned long )((char *)0)) {
    {
#line 162
    logname = build_filename((char const   *)inname, ".gxg");
    }
  }
  {
#line 164
  logfile = fopen((char const   */* __restrict  */)logname, (char const   */* __restrict  */)"w");
  }
#line 164
  if ((unsigned long )logfile == (unsigned long )((void *)0)) {
    {
#line 165
    error("log-file %s", logname);
#line 166
    exit(1);
    }
  }
#line 168
  return;
}
}
#line 170 "/home/june/repo/benchmarks/collector/temp/glosstex-0.4.dfsg.1/main.c"
static char *check_extension(char const   *string , char const   *ext ) 
{ 
  char *new ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 173
  new = (char *)0;
#line 175
  tmp___4 = strchr(string, '.');
  }
#line 175
  if ((unsigned long )tmp___4 == (unsigned long )((char *)0)) {
    {
#line 176
    tmp = strlen(string);
#line 176
    tmp___0 = strlen(ext);
#line 176
    tmp___1 = malloc((tmp + tmp___0) + 1UL);
#line 176
    new = (char *)tmp___1;
    }
#line 177
    if (! ((unsigned long )new != (unsigned long )((char *)0))) {
      {
#line 177
      __assert_fail("new != 0", "/home/june/repo/benchmarks/collector/temp/glosstex-0.4.dfsg.1/main.c",
                    177U, "check_extension");
      }
    }
    {
#line 178
    strcpy((char */* __restrict  */)new, (char const   */* __restrict  */)string);
#line 179
    strcat((char */* __restrict  */)new, (char const   */* __restrict  */)ext);
    }
  } else {
    {
#line 181
    tmp___2 = strlen(string);
#line 181
    tmp___3 = malloc(tmp___2 + 1UL);
#line 181
    new = (char *)tmp___3;
    }
#line 182
    if (! ((unsigned long )new != (unsigned long )((char *)0))) {
      {
#line 182
      __assert_fail("new != 0", "/home/june/repo/benchmarks/collector/temp/glosstex-0.4.dfsg.1/main.c",
                    182U, "check_extension");
      }
    }
    {
#line 183
    strcpy((char */* __restrict  */)new, (char const   */* __restrict  */)string);
    }
  }
#line 185
  return (new);
}
}
#line 188 "/home/june/repo/benchmarks/collector/temp/glosstex-0.4.dfsg.1/main.c"
static char *build_filename(char const   *string , char const   *ext ) 
{ 
  char *filename ;
  size_t len ;
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 191
  filename = (char *)0;
#line 194
  len = strcspn(string, ".");
  }
#line 195
  if (! (len != 0UL)) {
    {
#line 195
    __assert_fail("len != 0", "/home/june/repo/benchmarks/collector/temp/glosstex-0.4.dfsg.1/main.c",
                  195U, "build_filename");
    }
  }
  {
#line 197
  tmp = strlen(ext);
#line 197
  tmp___0 = malloc((len + tmp) + 1UL);
#line 197
  filename = (char *)tmp___0;
  }
#line 198
  if (! ((unsigned long )filename != (unsigned long )((char *)0))) {
    {
#line 198
    __assert_fail("filename != 0", "/home/june/repo/benchmarks/collector/temp/glosstex-0.4.dfsg.1/main.c",
                  198U, "build_filename");
    }
  }
  {
#line 200
  strncpy((char */* __restrict  */)filename, (char const   */* __restrict  */)string,
          len);
#line 201
  *(filename + len) = (char )'\000';
#line 202
  strcat((char */* __restrict  */)filename, (char const   */* __restrict  */)ext);
  }
#line 204
  return (filename);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 379
extern  __attribute__((__nothrow__)) int vsprintf(char * __restrict  __s , char const   * __restrict  __format ,
                                                  __gnuc_va_list __arg ) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 413 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 37 "/home/june/repo/benchmarks/collector/temp/glosstex-0.4.dfsg.1/error.c"
void error(char const   *fmt  , ...) 
{ 
  char buf[4096] ;
  int errno_save ;
  int *tmp ;
  va_list ap ;
  size_t tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 41
  tmp = __errno_location();
#line 41
  errno_save = *tmp;
#line 44
  __builtin_va_start(ap, fmt);
#line 46
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"\n%s: ",
          progname);
#line 47
  tmp___0 = strlen((char const   *)(buf));
#line 47
  vsprintf((char */* __restrict  */)(buf + tmp___0), (char const   */* __restrict  */)fmt,
           ap);
#line 50
  tmp___1 = strerror(errno_save);
#line 50
  tmp___2 = strlen((char const   *)(buf));
#line 50
  sprintf((char */* __restrict  */)(buf + tmp___2), (char const   */* __restrict  */)": %s\n",
          tmp___1);
#line 55
  fflush(stdout);
#line 56
  fputs((char const   */* __restrict  */)(buf), (FILE */* __restrict  */)stderr);
#line 59
  fflush((FILE *)0);
#line 65
  __builtin_va_end(ap);
  }
#line 66
  return;
}
}
#line 68 "/home/june/repo/benchmarks/collector/temp/glosstex-0.4.dfsg.1/error.c"
void printlog(enum e_loglevel level , int output_to , char const   *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 72
  __builtin_va_start(ap, fmt);
  }
#line 74
  if ((unsigned int )level <= (unsigned int )loglevel) {
#line 74
    if (output_to & 1) {
      {
#line 75
      vfprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)fmt,
               ap);
      }
    }
  }
#line 77
  if ((unsigned int )level <= (unsigned int )loglevel + 1U) {
#line 77
    if (output_to & 2) {
      {
#line 78
      vfprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)fmt,
               ap);
      }
    }
  }
#line 79
  return;
}
}
#line 30 "/home/june/repo/benchmarks/collector/temp/glosstex-0.4.dfsg.1/list.c"
void *list_add(s_list *list , void *ptr ) 
{ 
  s_node *new ;
  void *tmp ;

  {
  {
#line 33
  new = (s_node *)0;
#line 35
  tmp = malloc(sizeof(s_node ));
#line 35
  new = (s_node *)tmp;
  }
#line 36
  if (! ((unsigned long )new != (unsigned long )((s_node *)0))) {
    {
#line 36
    __assert_fail("new != 0", "/home/june/repo/benchmarks/collector/temp/glosstex-0.4.dfsg.1/list.c",
                  36U, "list_add");
    }
  }
#line 38
  if ((unsigned long )list->root == (unsigned long )((s_node *)0)) {
#line 39
    list->root = new;
#line 40
    list->top = new;
#line 41
    (list->top)->ptr = ptr;
#line 42
    (list->top)->next = (struct s_node_s *)0;
  } else {
#line 44
    (list->top)->next = new;
#line 45
    list->top = new;
#line 46
    (list->top)->ptr = ptr;
#line 47
    (list->top)->next = (struct s_node_s *)0;
  }
#line 50
  return ((void *)new);
}
}
#line 27 "/home/june/repo/benchmarks/collector/temp/glosstex-0.4.dfsg.1/version.c"
char version[108]  = 
#line 27 "/home/june/repo/benchmarks/collector/temp/glosstex-0.4.dfsg.1/version.c"
  {      (char )'T',      (char )'h',      (char )'i',      (char )'s', 
        (char )' ',      (char )'i',      (char )'s',      (char )' ', 
        (char )'G',      (char )'l',      (char )'o',      (char )'s', 
        (char )'s',      (char )'T',      (char )'e',      (char )'X', 
        (char )',',      (char )' ',      (char )'v',      (char )'e', 
        (char )'r',      (char )'s',      (char )'i',      (char )'o', 
        (char )'n',      (char )' ',      (char )'0',      (char )'.', 
        (char )'4',      (char )'\n',      (char )'G',      (char )'l', 
        (char )'o',      (char )'s',      (char )'s',      (char )'T', 
        (char )'e',      (char )'X',      (char )' ',      (char )'c', 
        (char )'o',      (char )'m',      (char )'e',      (char )'s', 
        (char )' ',      (char )'w',      (char )'i',      (char )'t', 
        (char )'h',      (char )' ',      (char )'A',      (char )'B', 
        (char )'S',      (char )'O',      (char )'L',      (char )'U', 
        (char )'T',      (char )'E',      (char )'L',      (char )'Y', 
        (char )' ',      (char )'N',      (char )'O',      (char )' ', 
        (char )'W',      (char )'A',      (char )'R',      (char )'R', 
        (char )'A',      (char )'N',      (char )'T',      (char )'Y', 
        (char )'.',      (char )' ',      (char )'(',      (char )'C', 
        (char )')',      (char )'o',      (char )'p',      (char )'y', 
        (char )'r',      (char )'i',      (char )'g',      (char )'h', 
        (char )'t',      (char )' ',      (char )'1',      (char )'9', 
        (char )'9',      (char )'6',      (char )',',      (char )' ', 
        (char )'9',      (char )'7',      (char )' ',      (char )'V', 
        (char )'o',      (char )'l',      (char )'k',      (char )'a', 
        (char )'n',      (char )' ',      (char )'Y',      (char )'a', 
        (char )'v',      (char )'u',      (char )'z',      (char )'\000'};
#line 433 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 39 "/home/june/repo/benchmarks/collector/temp/glosstex-0.4.dfsg.1/labels.c"
static int get_label(char *buf , char *label , char *pageref_mode , char *list , char *list_mode ,
                     char *page ) ;
#line 43 "/home/june/repo/benchmarks/collector/temp/glosstex-0.4.dfsg.1/labels.c"
int read_labels(char *inname___0 ) 
{ 
  FILE *infile___0 ;
  char buf[1024] ;
  unsigned int lineno___0 ;
  s_list_iterator iter ;
  size_t tmp ;
  s_label *label ;
  void *tmp___0 ;
  s_label *found_label ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char *new_file_name ;
  void *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  char *tmp___15 ;

  {
  {
#line 48
  lineno___0 = 0U;
#line 52
  iter.root = labels.root;
#line 53
  iter.current = labels.root;
#line 55
  infile___0 = fopen((char const   */* __restrict  */)inname___0, (char const   */* __restrict  */)"r");
  }
#line 55
  if ((unsigned long )infile___0 == (unsigned long )((void *)0)) {
    {
#line 56
    error("input-file %s", inname___0);
    }
#line 57
    return (1);
  }
  {
#line 59
  printlog((enum e_loglevel )2, 1, "(%s ", inname___0);
  }
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 61
    tmp___15 = fgets((char */* __restrict  */)(buf), 1024, (FILE */* __restrict  */)infile___0);
    }
#line 61
    if (! ((unsigned long )tmp___15 != (unsigned long )((char *)0))) {
#line 61
      goto while_break;
    }
    {
#line 62
    tmp = strlen((char const   *)(buf));
    }
#line 62
    if ((int )buf[tmp - 1UL] == 10) {
#line 63
      lineno___0 ++;
    }
    {
#line 65
    tmp___14 = strncmp((char const   *)(buf), "\\GLX@entry", (size_t )10);
    }
#line 65
    if (tmp___14 == 0) {
      {
#line 67
      tmp___0 = malloc(sizeof(s_label ));
#line 67
      label = (s_label *)tmp___0;
#line 68
      found_label = (s_label *)0;
      }
#line 69
      if (! ((unsigned long )label != (unsigned long )((s_label *)0))) {
        {
#line 69
        __assert_fail("label != 0", "/home/june/repo/benchmarks/collector/temp/glosstex-0.4.dfsg.1/labels.c",
                      69U, "read_labels");
        }
      }
      {
#line 71
      tmp___1 = malloc((size_t )129);
#line 71
      label->label = (char *)tmp___1;
      }
#line 72
      if (! ((unsigned long )label->label != (unsigned long )((char *)0))) {
        {
#line 72
        __assert_fail("label->label != 0", "/home/june/repo/benchmarks/collector/temp/glosstex-0.4.dfsg.1/labels.c",
                      72U, "read_labels");
        }
      }
      {
#line 74
      tmp___2 = malloc((size_t )129);
#line 74
      label->pageref_mode = (char *)tmp___2;
      }
#line 75
      if (! ((unsigned long )label->pageref_mode != (unsigned long )((char *)0))) {
        {
#line 75
        __assert_fail("label->pageref_mode != 0", "/home/june/repo/benchmarks/collector/temp/glosstex-0.4.dfsg.1/labels.c",
                      75U, "read_labels");
        }
      }
      {
#line 77
      tmp___3 = malloc((size_t )129);
#line 77
      label->list = (char *)tmp___3;
      }
#line 78
      if (! ((unsigned long )label->list != (unsigned long )((char *)0))) {
        {
#line 78
        __assert_fail("label->list != 0", "/home/june/repo/benchmarks/collector/temp/glosstex-0.4.dfsg.1/labels.c",
                      78U, "read_labels");
        }
      }
      {
#line 80
      tmp___4 = malloc((size_t )129);
#line 80
      label->list_mode = (char *)tmp___4;
      }
#line 81
      if (! ((unsigned long )label->list_mode != (unsigned long )((char *)0))) {
        {
#line 81
        __assert_fail("label->list_mode != 0", "/home/june/repo/benchmarks/collector/temp/glosstex-0.4.dfsg.1/labels.c",
                      81U, "read_labels");
        }
      }
      {
#line 83
      tmp___5 = malloc((size_t )129);
#line 83
      label->page = (char *)tmp___5;
      }
#line 84
      if (! ((unsigned long )label->page != (unsigned long )((char *)0))) {
        {
#line 84
        __assert_fail("label->page != 0", "/home/june/repo/benchmarks/collector/temp/glosstex-0.4.dfsg.1/labels.c",
                      84U, "read_labels");
        }
      }
      {
#line 86
      label->flag = (enum e_label_flag )0;
#line 88
      tmp___6 = get_label(& buf[10], label->label, label->pageref_mode, label->list,
                          label->list_mode, label->page);
      }
#line 88
      if (tmp___6 != 0) {
        {
#line 92
        printlog((enum e_loglevel )2, 1, "x");
#line 93
        printlog((enum e_loglevel )1, 2, "\n%s:%u parse error: %s", inname___0, lineno___0,
                 buf);
#line 95
        count_label_parsing ++;
        }
#line 96
        goto while_continue;
      }
      {
#line 98
      found_label = find_label(& iter, (enum e_find_mode )0, label->label, label->list);
      }
#line 98
      if ((unsigned long )found_label == (unsigned long )((s_label *)0)) {
        {
#line 100
        list_add(& labels, (void *)label);
#line 101
        iter.root = labels.root;
#line 102
        printlog((enum e_loglevel )3, 2, "\n%s:%u %s[%s](%s)%s@%s", inname___0, lineno___0,
                 label->label, label->pageref_mode, label->list, label->list_mode,
                 label->page);
#line 106
        count_label_success ++;
#line 107
        printlog((enum e_loglevel )2, 1, "i");
        }
      } else {
        {
#line 109
        tmp___7 = strcmp((char const   *)found_label->pageref_mode, "n");
        }
#line 109
        if (tmp___7 == 0) {
          {
#line 109
          tmp___8 = strcmp((char const   *)label->pageref_mode, "n");
          }
#line 109
          if (tmp___8 != 0) {
#line 109
            goto _L;
          } else {
#line 109
            goto _L___1;
          }
        } else {
          _L___1: /* CIL Label */ 
          {
#line 109
          tmp___9 = strcmp((char const   *)found_label->list_mode, "n");
          }
#line 109
          if (tmp___9 == 0) {
            {
#line 109
            tmp___10 = strcmp((char const   *)label->list_mode, "n");
            }
#line 109
            if (tmp___10 != 0) {
              _L: /* CIL Label */ 
              {
#line 113
              printlog((enum e_loglevel )3, 2, "\n%s:%u %s[%s](%s)%s@%s overrides %s[%s](%s)%s@%s",
                       inname___0, lineno___0, label->label, label->pageref_mode,
                       label->list, label->list_mode, label->page, found_label->label,
                       found_label->pageref_mode, found_label->list, found_label->list_mode,
                       found_label->page);
#line 120
              printlog((enum e_loglevel )2, 1, "o");
#line 121
              free((void *)found_label->label);
#line 122
              free((void *)found_label->pageref_mode);
#line 123
              free((void *)found_label->list);
#line 124
              free((void *)found_label->list_mode);
#line 125
              free((void *)found_label->page);
#line 126
              found_label->label = label->label;
#line 127
              found_label->pageref_mode = label->pageref_mode;
#line 128
              found_label->list = label->list;
#line 129
              found_label->list_mode = label->list_mode;
#line 130
              found_label->page = label->page;
#line 131
              count_label_override ++;
#line 132
              free((void *)label);
              }
            } else {
#line 109
              goto _L___0;
            }
          } else {
            _L___0: /* CIL Label */ 
            {
#line 134
            printlog((enum e_loglevel )4, 2, "\n%s:%u %s[%s](%s)%s@%s ignored", inname___0,
                     lineno___0, label->label, label->pageref_mode, label->list, label->list_mode,
                     label->page);
#line 138
            printlog((enum e_loglevel )2, 1, ".");
#line 139
            count_label_defined ++;
#line 141
            free((void *)label->label);
#line 142
            free((void *)label->pageref_mode);
#line 143
            free((void *)label->list);
#line 144
            free((void *)label->list_mode);
#line 145
            free((void *)label->page);
#line 146
            free((void *)label);
            }
          }
        }
      }
    } else {
      {
#line 150
      tmp___13 = strncmp((char const   *)(buf), "\\@input", (size_t )7);
      }
#line 150
      if (tmp___13 == 0) {
        {
#line 151
        tmp___11 = malloc((size_t )129);
#line 151
        new_file_name = (char *)tmp___11;
        }
#line 152
        if (! ((unsigned long )new_file_name != (unsigned long )((char *)0))) {
          {
#line 152
          __assert_fail("new_file_name != 0", "/home/june/repo/benchmarks/collector/temp/glosstex-0.4.dfsg.1/labels.c",
                        152U, "read_labels");
          }
        }
        {
#line 154
        tmp___12 = sscanf((char const   */* __restrict  */)(& buf[7]), (char const   */* __restrict  */)"{%128[^}]}\n",
                          new_file_name);
        }
#line 154
        if (tmp___12 == 1) {
          {
#line 156
          read_labels(new_file_name);
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 159
  printlog((enum e_loglevel )2, 1, ")");
  }
#line 161
  return (0);
}
}
#line 164 "/home/june/repo/benchmarks/collector/temp/glosstex-0.4.dfsg.1/labels.c"
s_label *find_label(s_list_iterator *iterator , enum e_find_mode find_mode , char *label ,
                    char *list ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 168
  if ((unsigned int )find_mode == 0U) {
#line 169
    iterator->current = iterator->root;
  } else
#line 171
  if ((unsigned long )iterator->current != (unsigned long )((s_node *)0)) {
#line 171
    iterator->current = (iterator->current)->next;
  }
  {
#line 173
  while (1) {
    while_continue: /* CIL Label */ ;
#line 173
    if (! ((unsigned long )iterator->current != (unsigned long )((s_node *)0))) {
#line 173
      goto while_break;
    }
    {
#line 174
    tmp = strcmp((char const   *)((s_label *)(iterator->current)->ptr)->label, (char const   *)label);
    }
#line 174
    if (tmp == 0) {
#line 174
      if ((unsigned long )list == (unsigned long )((char *)0)) {
#line 174
        tmp___1 = 1;
      } else {
        {
#line 174
        tmp___0 = strcmp((char const   *)((s_label *)(iterator->current)->ptr)->list,
                         (char const   *)list);
#line 174
        tmp___1 = tmp___0 == 0;
        }
      }
#line 174
      if (tmp___1) {
#line 177
        return ((s_label *)(iterator->current)->ptr);
      }
    }
#line 178
    iterator->current = (iterator->current)->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 180
  return ((s_label *)0);
}
}
#line 183 "/home/june/repo/benchmarks/collector/temp/glosstex-0.4.dfsg.1/labels.c"
unsigned int show_unresolved_labels(s_list list , FILE *file ) 
{ 
  unsigned int i ;
  s_node *p ;

  {
#line 186
  i = 0U;
#line 187
  p = list.root;
  {
#line 188
  while (1) {
    while_continue: /* CIL Label */ ;
#line 188
    if (! ((unsigned long )p != (unsigned long )((s_node *)0))) {
#line 188
      goto while_break;
    }
#line 189
    if ((unsigned int )((s_label *)p->ptr)->flag == 0U) {
      {
#line 190
      printlog((enum e_loglevel )1, 3, "\n%s[%s](%s)%s@%s unresolved", ((s_label *)p->ptr)->label,
               ((s_label *)p->ptr)->pageref_mode, ((s_label *)p->ptr)->list, ((s_label *)p->ptr)->list_mode,
               ((s_label *)p->ptr)->page);
#line 196
      i ++;
      }
    }
#line 198
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 200
  return (i);
}
}
#line 203 "/home/june/repo/benchmarks/collector/temp/glosstex-0.4.dfsg.1/labels.c"
static int get_label(char *buf , char *label , char *pageref_mode , char *list , char *list_mode ,
                     char *page ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 208
  tmp = sscanf((char const   */* __restrict  */)buf, (char const   */* __restrict  */)"{%128[^}]}{%128[^}]}{%128[^}]}{%128[^}]}{%128[^}]}\n",
               label, pageref_mode, list, list_mode, page);
#line 208
  i = tmp;
  }
#line 212
  if (i != 5) {
#line 212
    tmp___0 = 1;
  } else {
#line 212
    tmp___0 = 0;
  }
#line 212
  return (tmp___0);
}
}
