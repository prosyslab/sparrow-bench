/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 41 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_os_posix.h"
typedef int bool_t;
#line 26 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_types.h"
struct hdhomerun_device_t;
#line 33 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_sock.h"
typedef int hdhomerun_sock_t;
#line 33 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_debug.h"
struct hdhomerun_debug_t;
#line 30 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device_selector.h"
struct hdhomerun_device_selector_t;
#line 23 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device_selector.c"
struct hdhomerun_device_selector_t {
   struct hdhomerun_device_t **hd_list ;
   size_t hd_count ;
   struct hdhomerun_debug_t *dbg ;
};
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __useconds_t;
#line 147 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __clockid_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 91 "/usr/include/time.h"
typedef __clockid_t clockid_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef struct __pthread_internal_list __pthread_list_t;
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_mutex_t_11 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutex_t_11 pthread_mutex_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 55 "/usr/include/stdint.h"
typedef unsigned long uint64_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 183 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef char *__caddr_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 264 "/usr/include/netinet/in.h"
struct ip_mreq {
   struct in_addr imr_multiaddr ;
   struct in_addr imr_interface ;
};
#line 36 "/usr/include/x86_64-linux-gnu/sys/poll.h"
typedef unsigned long nfds_t;
#line 39 "/usr/include/x86_64-linux-gnu/sys/poll.h"
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
#line 567 "/usr/include/netdb.h"
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
#line 24 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_sock.h"
struct hdhomerun_local_ip_info_t {
   uint32_t ip_addr ;
   uint32_t subnet_mask ;
};
#line 111 "/usr/include/net/if.h"
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};
#line 126 "/usr/include/net/if.h"
union __anonunion_ifr_ifrn_74 {
   char ifrn_name[16] ;
};
#line 126 "/usr/include/net/if.h"
union __anonunion_ifr_ifru_75 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16] ;
   char ifru_newname[16] ;
   __caddr_t ifru_data ;
};
#line 126 "/usr/include/net/if.h"
struct ifreq {
   union __anonunion_ifr_ifrn_74 ifr_ifrn ;
   union __anonunion_ifr_ifru_75 ifr_ifru ;
};
#line 176 "/usr/include/net/if.h"
union __anonunion_ifc_ifcu_76 {
   __caddr_t ifcu_buf ;
   struct ifreq *ifcu_req ;
};
#line 176 "/usr/include/net/if.h"
struct ifconf {
   int ifc_len ;
   union __anonunion_ifc_ifcu_76 ifc_ifcu ;
};
#line 29 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_types.h"
struct hdhomerun_tuner_status_t {
   char channel[32] ;
   char lock_str[32] ;
   bool_t signal_present ;
   bool_t lock_supported ;
   bool_t lock_unsupported ;
   unsigned int signal_strength ;
   unsigned int signal_to_noise_quality ;
   unsigned int symbol_error_quality ;
   uint32_t raw_bits_per_second ;
   uint32_t packets_per_second ;
};
#line 53 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_types.h"
struct hdhomerun_channelscan_program_t {
   char program_str[64] ;
   uint16_t program_number ;
   uint16_t virtual_major ;
   uint16_t virtual_minor ;
   uint16_t type ;
   char name[32] ;
};
#line 64 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_types.h"
struct hdhomerun_channelscan_result_t {
   char channel_str[64] ;
   uint32_t channelmap ;
   uint32_t frequency ;
   struct hdhomerun_tuner_status_t status ;
   int program_count ;
   struct hdhomerun_channelscan_program_t programs[64] ;
   bool_t transport_stream_id_detected ;
   uint16_t transport_stream_id ;
};
#line 25 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_channels.h"
struct hdhomerun_channel_entry_t;
#line 26
struct hdhomerun_channel_list_t;
#line 30 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_channelscan.h"
struct hdhomerun_channelscan_t;
#line 23 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_channelscan.c"
struct hdhomerun_channelscan_t {
   struct hdhomerun_device_t *hd ;
   uint32_t scanned_channels ;
   struct hdhomerun_channel_list_t *channel_list ;
   struct hdhomerun_channel_entry_t *next_channel ;
};
#line 137 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_pkt.h"
struct hdhomerun_pkt_t {
   uint8_t *pos ;
   uint8_t *start ;
   uint8_t *end ;
   uint8_t *limit ;
   uint8_t buffer[3074] ;
};
#line 24 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_discover.h"
struct hdhomerun_discover_device_t {
   uint32_t ip_addr ;
   uint32_t device_type ;
   uint32_t device_id ;
   uint8_t tuner_count ;
};
#line 24 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_control.h"
struct hdhomerun_control_sock_t;
#line 28 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_control.c"
struct hdhomerun_control_sock_t {
   uint32_t desired_device_id ;
   uint32_t desired_device_ip ;
   uint32_t actual_device_id ;
   uint32_t actual_device_ip ;
   hdhomerun_sock_t sock ;
   struct hdhomerun_debug_t *dbg ;
   struct hdhomerun_pkt_t tx_pkt ;
   struct hdhomerun_pkt_t rx_pkt ;
};
#line 195 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef short int16_t;
#line 42 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_types.h"
struct hdhomerun_tuner_vstatus_t {
   char vchannel[32] ;
   char name[32] ;
   char auth[32] ;
   char cci[32] ;
   char cgms[32] ;
   bool_t not_subscribed ;
   bool_t not_available ;
   bool_t copy_protected ;
};
#line 75 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_types.h"
struct hdhomerun_plotsample_t {
   int16_t real ;
   int16_t imag ;
};
#line 24 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_video.h"
struct hdhomerun_video_sock_t;
#line 26 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_video.h"
struct hdhomerun_video_stats_t {
   uint32_t packet_count ;
   uint32_t network_error_count ;
   uint32_t transport_error_count ;
   uint32_t sequence_error_count ;
   uint32_t overflow_error_count ;
};
#line 23 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
struct hdhomerun_device_t {
   struct hdhomerun_control_sock_t *cs ;
   struct hdhomerun_video_sock_t *vs ;
   struct hdhomerun_debug_t *dbg ;
   struct hdhomerun_channelscan_t *scan ;
   uint32_t multicast_ip ;
   uint16_t multicast_port ;
   uint32_t device_id ;
   unsigned int tuner ;
   uint32_t lockkey ;
   char name[32] ;
   char model[32] ;
};
#line 23 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_channels.c"
struct hdhomerun_channel_entry_t {
   struct hdhomerun_channel_entry_t *next ;
   struct hdhomerun_channel_entry_t *prev ;
   uint32_t frequency ;
   uint16_t channel_number ;
   char name[16] ;
};
#line 31 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_channels.c"
struct hdhomerun_channel_list_t {
   struct hdhomerun_channel_entry_t *head ;
   struct hdhomerun_channel_entry_t *tail ;
};
#line 36 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_channels.c"
struct hdhomerun_channelmap_range_t {
   uint16_t channel_range_start ;
   uint16_t channel_range_end ;
   uint32_t frequency ;
   uint32_t spacing ;
};
#line 43 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_channels.c"
struct hdhomerun_channelmap_record_t {
   char const   *channelmap ;
   struct hdhomerun_channelmap_range_t  const  *range_list ;
   char const   *channelmap_scan_group ;
   char const   *countrycodes ;
};
#line 60 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned long pthread_t;
#line 63 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
#line 69 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union pthread_attr_t pthread_attr_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_mutexattr_t_12 {
   char __size[4] ;
   int __align ;
};
#line 129 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutexattr_t_12 pthread_mutexattr_t;
#line 23 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_video.c"
struct hdhomerun_video_sock_t {
   pthread_mutex_t lock ;
   struct hdhomerun_debug_t *dbg ;
   hdhomerun_sock_t sock ;
   size_t volatile   head ;
   size_t volatile   tail ;
   uint8_t *buffer ;
   size_t buffer_size ;
   size_t advance ;
   pthread_t thread ;
   bool_t volatile   terminate ;
   uint32_t volatile   packet_count ;
   uint32_t volatile   transport_error_count ;
   uint32_t volatile   network_error_count ;
   uint32_t volatile   sequence_error_count ;
   uint32_t volatile   overflow_error_count ;
   uint32_t volatile   rtp_sequence ;
   uint8_t volatile   sequence[8192] ;
};
#line 50 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_discover.h"
struct hdhomerun_discover_t;
#line 25 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_discover.c"
struct hdhomerun_discover_sock_t {
   hdhomerun_sock_t sock ;
   bool_t detected ;
   uint32_t local_ip ;
   uint32_t subnet_mask ;
};
#line 32 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_discover.c"
struct hdhomerun_discover_t {
   struct hdhomerun_discover_sock_t socks[16] ;
   unsigned int sock_count ;
   struct hdhomerun_pkt_t tx_pkt ;
   struct hdhomerun_pkt_t rx_pkt ;
   struct hdhomerun_debug_t *dbg ;
};
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 42 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_debug.c"
struct hdhomerun_debug_message_t {
   struct hdhomerun_debug_message_t *next ;
   struct hdhomerun_debug_message_t *prev ;
   char buffer[2048] ;
};
#line 49 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_debug.c"
struct hdhomerun_debug_t {
   pthread_t thread ;
   bool_t volatile   enabled ;
   bool_t volatile   terminate ;
   char *prefix ;
   pthread_mutex_t print_lock ;
   pthread_mutex_t queue_lock ;
   pthread_mutex_t send_lock ;
   struct hdhomerun_debug_message_t *queue_head ;
   struct hdhomerun_debug_message_t *queue_tail ;
   uint32_t queue_depth ;
   uint64_t connect_delay ;
   char *file_name ;
   FILE *file_fp ;
   hdhomerun_sock_t sock ;
};
#line 196 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef int int32_t;
#line 22 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef int __sig_atomic_t;
#line 40 "/usr/include/signal.h"
typedef __sig_atomic_t sig_atomic_t;
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 468 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 283
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes )  __asm__("fopen64")  ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 236 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_sock.h"
hdhomerun_sock_t hdhomerun_sock_create_udp(void) ;
#line 37
void hdhomerun_sock_destroy(hdhomerun_sock_t sock ) ;
#line 48
bool_t hdhomerun_sock_bind(hdhomerun_sock_t sock , uint32_t local_addr , uint16_t local_port ,
                           bool_t allow_reuse ) ;
#line 47 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_debug.h"
void hdhomerun_debug_printf(struct hdhomerun_debug_t *dbg , char const   *fmt  , ...) ;
#line 67 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.h"
struct hdhomerun_device_t *hdhomerun_device_create_from_str(char const   *device_str ,
                                                            struct hdhomerun_debug_t *dbg ) ;
#line 68
void hdhomerun_device_destroy(struct hdhomerun_device_t *hd___0 ) ;
#line 73
char const   *hdhomerun_device_get_name(struct hdhomerun_device_t *hd___0 ) ;
#line 74
uint32_t hdhomerun_device_get_device_id(struct hdhomerun_device_t *hd___0 ) ;
#line 78
unsigned int hdhomerun_device_get_tuner(struct hdhomerun_device_t *hd___0 ) ;
#line 91
uint32_t hdhomerun_device_get_local_machine_addr(struct hdhomerun_device_t *hd___0 ) ;
#line 112
int hdhomerun_device_get_tuner_target(struct hdhomerun_device_t *hd___0 , char **ptarget ) ;
#line 181
int hdhomerun_device_tuner_lockkey_request(struct hdhomerun_device_t *hd___0 , char **perror___0 ) ;
#line 183
int hdhomerun_device_tuner_lockkey_force(struct hdhomerun_device_t *hd___0 ) ;
#line 30 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device_selector.h"
struct hdhomerun_device_selector_t *hdhomerun_device_selector_create(struct hdhomerun_debug_t *dbg ) ;
#line 31
void hdhomerun_device_selector_destroy(struct hdhomerun_device_selector_t *hds , bool_t destroy_devices ) ;
#line 36
int hdhomerun_device_selector_get_device_count(struct hdhomerun_device_selector_t *hds ) ;
#line 42
int hdhomerun_device_selector_load_from_file(struct hdhomerun_device_selector_t *hds ,
                                             char *filename ) ;
#line 50
void hdhomerun_device_selector_add_device(struct hdhomerun_device_selector_t *hds ,
                                          struct hdhomerun_device_t *hd___0 ) ;
#line 51
void hdhomerun_device_selector_remove_device(struct hdhomerun_device_selector_t *hds ,
                                             struct hdhomerun_device_t *hd___0 ) ;
#line 56
struct hdhomerun_device_t *hdhomerun_device_selector_find_device(struct hdhomerun_device_selector_t *hds ,
                                                                 uint32_t device_id ,
                                                                 unsigned int tuner_index ) ;
#line 81
struct hdhomerun_device_t *hdhomerun_device_selector_choose_and_lock(struct hdhomerun_device_selector_t *hds ,
                                                                     struct hdhomerun_device_t *prefered ) ;
#line 29 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device_selector.c"
struct hdhomerun_device_selector_t *hdhomerun_device_selector_create(struct hdhomerun_debug_t *dbg ) 
{ 
  struct hdhomerun_device_selector_t *hds ;
  void *tmp ;

  {
  {
#line 31
  tmp = calloc((size_t )1, sizeof(struct hdhomerun_device_selector_t ));
#line 31
  hds = (struct hdhomerun_device_selector_t *)tmp;
  }
#line 32
  if (! hds) {
    {
#line 33
    hdhomerun_debug_printf(dbg, "hdhomerun_device_selector_create: failed to allocate selector object\n");
    }
#line 34
    return ((struct hdhomerun_device_selector_t *)((void *)0));
  }
#line 37
  hds->dbg = dbg;
#line 39
  return (hds);
}
}
#line 42 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device_selector.c"
void hdhomerun_device_selector_destroy(struct hdhomerun_device_selector_t *hds , bool_t destroy_devices ) 
{ 
  size_t index___0 ;
  struct hdhomerun_device_t *entry ;

  {
#line 44
  if (destroy_devices) {
#line 46
    index___0 = (size_t )0;
    {
#line 46
    while (1) {
      while_continue: /* CIL Label */ ;
#line 46
      if (! (index___0 < hds->hd_count)) {
#line 46
        goto while_break;
      }
      {
#line 47
      entry = *(hds->hd_list + index___0);
#line 48
      hdhomerun_device_destroy(entry);
#line 46
      index___0 ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 52
  if (hds->hd_list) {
    {
#line 53
    free((void *)hds->hd_list);
    }
  }
  {
#line 56
  free((void *)hds);
  }
#line 57
  return;
}
}
#line 59 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device_selector.c"
int hdhomerun_device_selector_get_device_count(struct hdhomerun_device_selector_t *hds ) 
{ 


  {
#line 61
  return ((int )hds->hd_count);
}
}
#line 64 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device_selector.c"
void hdhomerun_device_selector_add_device(struct hdhomerun_device_selector_t *hds ,
                                          struct hdhomerun_device_t *hd___0 ) 
{ 
  size_t index___0 ;
  struct hdhomerun_device_t *entry ;
  void *tmp ;
  size_t tmp___0 ;

  {
#line 67
  index___0 = (size_t )0;
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
#line 67
    if (! (index___0 < hds->hd_count)) {
#line 67
      goto while_break;
    }
#line 68
    entry = *(hds->hd_list + index___0);
#line 69
    if ((unsigned long )entry == (unsigned long )hd___0) {
#line 70
      return;
    }
#line 67
    index___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 74
  tmp = realloc((void *)hds->hd_list, (hds->hd_count + 1UL) * sizeof(struct hdhomerun_device_selector_t *));
#line 74
  hds->hd_list = (struct hdhomerun_device_t **)tmp;
  }
#line 75
  if (! hds->hd_list) {
    {
#line 76
    hdhomerun_debug_printf(hds->dbg, "hdhomerun_device_selector_add_device: failed to allocate device list\n");
    }
#line 77
    return;
  }
#line 80
  tmp___0 = hds->hd_count;
#line 80
  (hds->hd_count) ++;
#line 80
  *(hds->hd_list + tmp___0) = hd___0;
#line 81
  return;
}
}
#line 83 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device_selector.c"
void hdhomerun_device_selector_remove_device(struct hdhomerun_device_selector_t *hds ,
                                             struct hdhomerun_device_t *hd___0 ) 
{ 
  size_t index___0 ;
  struct hdhomerun_device_t *entry ;

  {
#line 85
  index___0 = (size_t )0;
  {
#line 86
  while (1) {
    while_continue: /* CIL Label */ ;
#line 87
    if (index___0 >= hds->hd_count) {
#line 88
      return;
    }
#line 91
    entry = *(hds->hd_list + index___0);
#line 92
    if ((unsigned long )entry == (unsigned long )hd___0) {
#line 93
      goto while_break;
    }
#line 96
    index___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 99
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 99
    if (! (index___0 + 1UL < hds->hd_count)) {
#line 99
      goto while_break___0;
    }
#line 100
    *(hds->hd_list + index___0) = *(hds->hd_list + (index___0 + 1UL));
#line 101
    index___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 104
  *(hds->hd_list + index___0) = (struct hdhomerun_device_t *)((void *)0);
#line 105
  (hds->hd_count) --;
#line 106
  return;
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device_selector.c"
struct hdhomerun_device_t *hdhomerun_device_selector_find_device(struct hdhomerun_device_selector_t *hds ,
                                                                 uint32_t device_id ,
                                                                 unsigned int tuner_index ) 
{ 
  size_t index___0 ;
  struct hdhomerun_device_t *entry ;
  uint32_t tmp ;
  unsigned int tmp___0 ;

  {
#line 111
  index___0 = (size_t )0;
  {
#line 111
  while (1) {
    while_continue: /* CIL Label */ ;
#line 111
    if (! (index___0 < hds->hd_count)) {
#line 111
      goto while_break;
    }
    {
#line 112
    entry = *(hds->hd_list + index___0);
#line 113
    tmp = hdhomerun_device_get_device_id(entry);
    }
#line 113
    if (tmp != device_id) {
#line 114
      goto __Cont;
    }
    {
#line 116
    tmp___0 = hdhomerun_device_get_tuner(entry);
    }
#line 116
    if (tmp___0 != tuner_index) {
#line 117
      goto __Cont;
    }
#line 119
    return (entry);
    __Cont: /* CIL Label */ 
#line 111
    index___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 122
  return ((struct hdhomerun_device_t *)((void *)0));
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device_selector.c"
int hdhomerun_device_selector_load_from_file(struct hdhomerun_device_selector_t *hds ,
                                             char *filename ) 
{ 
  FILE *fp ;
  FILE *tmp ;
  char device_name[32] ;
  char *tmp___0 ;
  struct hdhomerun_device_t *hd___0 ;
  struct hdhomerun_device_t *tmp___1 ;

  {
  {
#line 127
  tmp = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
#line 127
  fp = tmp;
  }
#line 128
  if (! fp) {
#line 129
    return (0);
  }
  {
#line 132
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 134
    tmp___0 = fgets((char */* __restrict  */)(device_name), (int )sizeof(device_name),
                    (FILE */* __restrict  */)fp);
    }
#line 134
    if (! tmp___0) {
#line 135
      goto while_break;
    }
    {
#line 138
    tmp___1 = hdhomerun_device_create_from_str((char const   *)(device_name), hds->dbg);
#line 138
    hd___0 = tmp___1;
    }
#line 139
    if (! hd___0) {
#line 140
      goto while_continue;
    }
    {
#line 143
    hdhomerun_device_selector_add_device(hds, hd___0);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 146
  fclose(fp);
  }
#line 147
  return ((int )hds->hd_count);
}
}
#line 208 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device_selector.c"
static bool_t hdhomerun_device_selector_choose_test(struct hdhomerun_device_selector_t *hds ,
                                                    struct hdhomerun_device_t *test_hd ) 
{ 
  char const   *name ;
  char const   *tmp ;
  char *error ;
  int ret ;
  int tmp___0 ;
  char *target ;
  char *ptr ;
  char *tmp___1 ;
  unsigned int a[4] ;
  unsigned int target_port ;
  int tmp___2 ;
  uint32_t target_ip ;
  uint32_t local_ip ;
  uint32_t tmp___3 ;
  hdhomerun_sock_t test_sock ;
  hdhomerun_sock_t tmp___4 ;
  bool_t inuse ;
  bool_t tmp___5 ;

  {
  {
#line 210
  tmp = hdhomerun_device_get_name(test_hd);
#line 210
  name = tmp;
#line 216
  tmp___0 = hdhomerun_device_tuner_lockkey_request(test_hd, & error);
#line 216
  ret = tmp___0;
  }
#line 217
  if (ret > 0) {
    {
#line 218
    hdhomerun_debug_printf(hds->dbg, "hdhomerun_device_selector_choose_test: device %s chosen\n",
                           name);
    }
#line 219
    return (1);
  }
#line 221
  if (ret < 0) {
    {
#line 222
    hdhomerun_debug_printf(hds->dbg, "hdhomerun_device_selector_choose_test: device %s communication error\n",
                           name);
    }
#line 223
    return (0);
  }
  {
#line 230
  ret = hdhomerun_device_get_tuner_target(test_hd, & target);
  }
#line 231
  if (ret < 0) {
    {
#line 232
    hdhomerun_debug_printf(hds->dbg, "hdhomerun_device_selector_choose_test: device %s communication error\n",
                           name);
    }
#line 233
    return (0);
  }
#line 235
  if (ret == 0) {
    {
#line 236
    hdhomerun_debug_printf(hds->dbg, "hdhomerun_device_selector_choose_test: device %s in use, failed to read target\n",
                           name);
    }
#line 237
    return (0);
  }
  {
#line 240
  tmp___1 = strstr((char const   *)target, "//");
#line 240
  ptr = tmp___1;
  }
#line 241
  if (ptr) {
#line 242
    target = ptr + 2;
  }
  {
#line 244
  ptr = strchr((char const   *)target, ' ');
  }
#line 245
  if (ptr) {
#line 246
    *ptr = (char)0;
  }
  {
#line 251
  tmp___2 = sscanf((char const   */* __restrict  */)target, (char const   */* __restrict  */)"%u.%u.%u.%u:%u",
                   & a[0], & a[1], & a[2], & a[3], & target_port);
  }
#line 251
  if (tmp___2 != 5) {
    {
#line 252
    hdhomerun_debug_printf(hds->dbg, "hdhomerun_device_selector_choose_test: device %s in use, no target set (%s)\n",
                           name, target);
    }
#line 253
    return (0);
  }
  {
#line 256
  target_ip = (((a[0] << 24) | (a[1] << 16)) | (a[2] << 8)) | a[3];
#line 257
  tmp___3 = hdhomerun_device_get_local_machine_addr(test_hd);
#line 257
  local_ip = tmp___3;
  }
#line 258
  if (target_ip != local_ip) {
    {
#line 259
    hdhomerun_debug_printf(hds->dbg, "hdhomerun_device_selector_choose_test: device %s in use by %s\n",
                           name, target);
    }
#line 260
    return (0);
  }
  {
#line 266
  tmp___4 = hdhomerun_sock_create_udp();
#line 266
  test_sock = tmp___4;
  }
#line 267
  if (test_sock == -1) {
    {
#line 268
    hdhomerun_debug_printf(hds->dbg, "hdhomerun_device_selector_choose_test: device %s in use, failed to create test sock\n",
                           name);
    }
#line 269
    return (0);
  }
  {
#line 272
  tmp___5 = hdhomerun_sock_bind(test_sock, (in_addr_t )0, (uint16_t )target_port,
                                0);
#line 272
  inuse = tmp___5 == 0;
#line 273
  hdhomerun_sock_destroy(test_sock);
  }
#line 275
  if (inuse) {
    {
#line 276
    hdhomerun_debug_printf(hds->dbg, "hdhomerun_device_selector_choose_test: device %s in use by local machine\n",
                           name);
    }
#line 277
    return (0);
  }
  {
#line 283
  ret = hdhomerun_device_tuner_lockkey_force(test_hd);
  }
#line 284
  if (ret < 0) {
    {
#line 285
    hdhomerun_debug_printf(hds->dbg, "hdhomerun_device_selector_choose_test: device %s communication error\n",
                           name);
    }
#line 286
    return (0);
  }
#line 288
  if (ret == 0) {
    {
#line 289
    hdhomerun_debug_printf(hds->dbg, "hdhomerun_device_selector_choose_test: device %s in use by local machine, dead target, failed to force release lockkey\n",
                           name);
    }
#line 290
    return (0);
  }
  {
#line 293
  hdhomerun_debug_printf(hds->dbg, "hdhomerun_device_selector_choose_test: device %s in use by local machine, dead target, lockkey force successful\n",
                         name);
#line 298
  ret = hdhomerun_device_tuner_lockkey_request(test_hd, & error);
  }
#line 299
  if (ret > 0) {
    {
#line 300
    hdhomerun_debug_printf(hds->dbg, "hdhomerun_device_selector_choose_test: device %s chosen\n",
                           name);
    }
#line 301
    return (1);
  }
#line 303
  if (ret < 0) {
    {
#line 304
    hdhomerun_debug_printf(hds->dbg, "hdhomerun_device_selector_choose_test: device %s communication error\n",
                           name);
    }
#line 305
    return (0);
  }
  {
#line 308
  hdhomerun_debug_printf(hds->dbg, "hdhomerun_device_selector_choose_test: device %s still in use after lockkey force (%s)\n",
                         name, error);
  }
#line 309
  return (0);
}
}
#line 312 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device_selector.c"
struct hdhomerun_device_t *hdhomerun_device_selector_choose_and_lock(struct hdhomerun_device_selector_t *hds ,
                                                                     struct hdhomerun_device_t *prefered ) 
{ 
  bool_t tmp ;
  size_t index___0 ;
  struct hdhomerun_device_t *entry ;
  bool_t tmp___0 ;

  {
#line 315
  if (prefered) {
    {
#line 316
    tmp = hdhomerun_device_selector_choose_test(hds, prefered);
    }
#line 316
    if (tmp) {
#line 317
      return (prefered);
    }
  }
#line 323
  index___0 = (size_t )0;
  {
#line 323
  while (1) {
    while_continue: /* CIL Label */ ;
#line 323
    if (! (index___0 < hds->hd_count)) {
#line 323
      goto while_break;
    }
#line 324
    entry = *(hds->hd_list + index___0);
#line 325
    if ((unsigned long )entry == (unsigned long )prefered) {
#line 326
      goto __Cont;
    }
    {
#line 329
    tmp___0 = hdhomerun_device_selector_choose_test(hds, entry);
    }
#line 329
    if (tmp___0) {
#line 330
      return (entry);
    }
    __Cont: /* CIL Label */ 
#line 323
    index___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 334
  hdhomerun_debug_printf(hds->dbg, "hdhomerun_device_selector_choose_and_lock: no devices available\n");
  }
#line 335
  return ((struct hdhomerun_device_t *)((void *)0));
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 390 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 444 "/usr/include/unistd.h"
extern unsigned int sleep(unsigned int __seconds ) ;
#line 460
extern int usleep(__useconds_t __useconds ) ;
#line 342 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) clock_gettime)(clockid_t __clock_id ,
                                                                                    struct timespec *__tp ) ;
#line 773 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex ) ;
#line 784
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex ) ;
#line 53 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_os_posix.h"
uint32_t random_get32(void) ;
#line 54
uint64_t getcurrenttime(void) ;
#line 55
void msleep_approx(uint64_t ms ) ;
#line 56
void msleep_minimum(uint64_t ms ) ;
#line 58
bool_t hdhomerun_vsprintf(char *buffer , char *end , char const   *fmt , va_list ap ) ;
#line 59
bool_t hdhomerun_sprintf(char *buffer , char *end , char const   *fmt  , ...) ;
#line 23 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_os_posix.c"
uint32_t random_get32(void) 
{ 
  FILE *fp ;
  FILE *tmp ;
  uint64_t tmp___0 ;
  uint32_t Result ;
  uint64_t tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 25
  tmp = fopen((char const   */* __restrict  */)"/dev/urandom", (char const   */* __restrict  */)"rb");
#line 25
  fp = tmp;
  }
#line 26
  if (! fp) {
    {
#line 27
    tmp___0 = getcurrenttime();
    }
#line 27
    return ((uint32_t )tmp___0);
  }
  {
#line 31
  tmp___2 = fread((void */* __restrict  */)(& Result), (size_t )4, (size_t )1, (FILE */* __restrict  */)fp);
  }
#line 31
  if (tmp___2 != 1UL) {
    {
#line 32
    tmp___1 = getcurrenttime();
#line 32
    Result = (uint32_t )tmp___1;
    }
  }
  {
#line 35
  fclose(fp);
  }
#line 36
  return (Result);
}
}
#line 41 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_os_posix.c"
static pthread_mutex_t lock  =    {{0, 0U, 0, 0U, 0, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}};
#line 42 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_os_posix.c"
static uint64_t result  =    (uint64_t )0;
#line 43 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_os_posix.c"
static uint64_t previous_time  =    (uint64_t )0;
#line 39 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_os_posix.c"
uint64_t getcurrenttime(void) 
{ 
  struct timespec tp ;
  uint64_t current_time ;

  {
  {
#line 45
  pthread_mutex_lock(& lock);
#line 49
  clock_gettime(1, & tp);
#line 50
  current_time = (uint64_t )tp.tv_sec * 1000UL + (uint64_t )(tp.tv_nsec / 1000000L);
  }
#line 57
  if (current_time > previous_time) {
#line 58
    result += current_time - previous_time;
  }
  {
#line 61
  previous_time = current_time;
#line 63
  pthread_mutex_unlock(& lock);
  }
#line 64
  return (result);
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_os_posix.c"
void msleep_approx(uint64_t ms ) 
{ 
  unsigned int delay_s ;
  unsigned int delay_us ;

  {
#line 69
  delay_s = (unsigned int )(ms / 1000UL);
#line 70
  if (delay_s > 0U) {
    {
#line 71
    sleep(delay_s);
#line 72
    ms -= (uint64_t )(delay_s * 1000U);
    }
  }
#line 75
  delay_us = (unsigned int )(ms * 1000UL);
#line 76
  if (delay_us > 0U) {
    {
#line 77
    usleep(delay_us);
    }
  }
#line 79
  return;
}
}
#line 81 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_os_posix.c"
void msleep_minimum(uint64_t ms ) 
{ 
  uint64_t stop_time ;
  uint64_t tmp ;
  uint64_t current_time ;
  uint64_t tmp___0 ;

  {
  {
#line 83
  tmp = getcurrenttime();
#line 83
  stop_time = tmp + ms;
  }
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 86
    tmp___0 = getcurrenttime();
#line 86
    current_time = tmp___0;
    }
#line 87
    if (current_time >= stop_time) {
#line 88
      return;
    }
    {
#line 91
    msleep_approx(stop_time - current_time);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_os_posix.c"
bool_t hdhomerun_vsprintf(char *buffer , char *end , char const   *fmt , va_list ap ) 
{ 
  int length ;
  int tmp ;

  {
#line 97
  if ((unsigned long )buffer >= (unsigned long )end) {
#line 98
    return (0);
  }
  {
#line 101
  tmp = vsnprintf((char */* __restrict  */)buffer, (size_t )((end - buffer) - 1L),
                  (char const   */* __restrict  */)fmt, ap);
#line 101
  length = tmp;
  }
#line 102
  if (length < 0) {
#line 103
    *buffer = (char)0;
#line 104
    return (0);
  }
#line 107
  if ((unsigned long )((buffer + length) + 1) > (unsigned long )end) {
#line 108
    *(end - 1) = (char)0;
#line 109
    return (0);
  }
#line 113
  return (1);
}
}
#line 116 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_os_posix.c"
bool_t hdhomerun_sprintf(char *buffer , char *end , char const   *fmt  , ...) 
{ 
  va_list ap ;
  bool_t result___1 ;
  bool_t tmp ;

  {
  {
#line 119
  __builtin_va_start(ap, fmt);
#line 120
  tmp = hdhomerun_vsprintf(buffer, end, fmt, ap);
#line 120
  result___1 = tmp;
#line 121
  __builtin_va_end(ap);
  }
#line 122
  return (result___1);
}
}
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 123
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  *__addr ,
                                                                           socklen_t __len ) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getsockname)(int __fd ,
                                                                                  struct sockaddr * __restrict  __addr ,
                                                                                  socklen_t * __restrict  __len ) ;
#line 137
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 141
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getpeername)(int __fd ,
                                                                                  struct sockaddr * __restrict  __addr ,
                                                                                  socklen_t * __restrict  __len ) ;
#line 149
extern ssize_t send(int __fd , void const   *__buf , size_t __n , int __flags ) ;
#line 156
extern ssize_t recv(int __fd , void *__buf , size_t __n , int __flags ) ;
#line 163
extern ssize_t sendto(int __fd , void const   *__buf , size_t __n , int __flags ,
                      struct sockaddr  const  *__addr , socklen_t __addr_len ) ;
#line 174
extern ssize_t recvfrom(int __fd , void * __restrict  __buf , size_t __n , int __flags ,
                        struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 226
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void const   *__optval ,
                                                                                 socklen_t __optlen ) ;
#line 374 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) ntohl)(uint32_t __netlong )  __attribute__((__const__)) ;
#line 375
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) ntohs)(uint16_t __netshort )  __attribute__((__const__)) ;
#line 377
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) htonl)(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 379
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 57 "/usr/include/x86_64-linux-gnu/sys/poll.h"
extern int poll(struct pollfd *__fds , nfds_t __nfds , int __timeout ) ;
#line 662 "/usr/include/netdb.h"
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
#line 668
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) freeaddrinfo)(struct addrinfo *__ai ) ;
#line 29 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_sock.h"
int hdhomerun_local_ip_info(struct hdhomerun_local_ip_info_t *ip_info_list , int max_count ) ;
#line 36
hdhomerun_sock_t hdhomerun_sock_create_tcp(void) ;
#line 39
int hdhomerun_sock_getlasterror(void) ;
#line 40
uint32_t hdhomerun_sock_getsockname_addr(hdhomerun_sock_t sock ) ;
#line 41
uint16_t hdhomerun_sock_getsockname_port(hdhomerun_sock_t sock ) ;
#line 42
uint32_t hdhomerun_sock_getpeername_addr(hdhomerun_sock_t sock ) ;
#line 43
uint32_t hdhomerun_sock_getaddrinfo_addr(hdhomerun_sock_t sock , char const   *name ) ;
#line 45
bool_t hdhomerun_sock_join_multicast_group(hdhomerun_sock_t sock , uint32_t multicast_ip ,
                                           uint32_t local_ip ) ;
#line 46
bool_t hdhomerun_sock_leave_multicast_group(hdhomerun_sock_t sock , uint32_t multicast_ip ,
                                            uint32_t local_ip ) ;
#line 49
bool_t hdhomerun_sock_connect(hdhomerun_sock_t sock , uint32_t remote_addr , uint16_t remote_port ,
                              uint64_t timeout ) ;
#line 51
bool_t hdhomerun_sock_send(hdhomerun_sock_t sock , void const   *data , size_t length ,
                           uint64_t timeout ) ;
#line 52
bool_t hdhomerun_sock_sendto(hdhomerun_sock_t sock , uint32_t remote_addr , uint16_t remote_port ,
                             void const   *data , size_t length , uint64_t timeout ) ;
#line 54
bool_t hdhomerun_sock_recv(hdhomerun_sock_t sock , void *data , size_t *length , uint64_t timeout ) ;
#line 55
bool_t hdhomerun_sock_recvfrom(hdhomerun_sock_t sock , uint32_t *remote_addr , uint16_t *remote_port ,
                               void *data , size_t *length , uint64_t timeout ) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 54 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_sock_posix.c"
int hdhomerun_local_ip_info(struct hdhomerun_local_ip_info_t *ip_info_list , int max_count ) 
{ 
  int sock ;
  int tmp ;
  struct ifconf ifc ;
  size_t ifreq_buffer_size ;
  void *tmp___0 ;
  int tmp___1 ;
  char *ptr ;
  char *end ;
  int count ;
  struct ifreq *ifr ;
  int tmp___2 ;
  int tmp___3 ;
  struct sockaddr_in *ip_addr_in ;
  uint32_t ip_addr ;
  uint32_t tmp___4 ;
  int tmp___5 ;
  struct sockaddr_in *subnet_mask_in ;
  uint32_t subnet_mask ;
  uint32_t tmp___6 ;
  struct hdhomerun_local_ip_info_t *ip_info ;

  {
  {
#line 56
  tmp = socket(2, 2, 0);
#line 56
  sock = tmp;
  }
#line 57
  if (sock == -1) {
#line 58
    return (-1);
  }
#line 62
  ifreq_buffer_size = (size_t )1024;
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 65
    ifc.ifc_len = (int )ifreq_buffer_size;
#line 66
    tmp___0 = malloc(ifreq_buffer_size);
#line 66
    ifc.ifc_ifcu.ifcu_buf = (char *)tmp___0;
    }
#line 67
    if (! ifc.ifc_ifcu.ifcu_buf) {
      {
#line 68
      close(sock);
      }
#line 69
      return (-1);
    }
    {
#line 72
    memset((void *)ifc.ifc_ifcu.ifcu_buf, 0, ifreq_buffer_size);
#line 74
    tmp___1 = ioctl(sock, 35090UL, & ifc);
    }
#line 74
    if (tmp___1 != 0) {
      {
#line 75
      free((void *)ifc.ifc_ifcu.ifcu_buf);
#line 76
      close(sock);
      }
#line 77
      return (-1);
    }
#line 80
    if ((size_t )ifc.ifc_len < ifreq_buffer_size) {
#line 81
      goto while_break;
    }
    {
#line 84
    free((void *)ifc.ifc_ifcu.ifcu_buf);
#line 85
    ifreq_buffer_size += 1024UL;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 88
  ptr = ifc.ifc_ifcu.ifcu_buf;
#line 89
  end = ifc.ifc_ifcu.ifcu_buf + ifc.ifc_len;
#line 91
  count = 0;
  {
#line 92
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 92
    if (! ((unsigned long )ptr < (unsigned long )end)) {
#line 92
      goto while_break___0;
    }
    {
#line 93
    ifr = (struct ifreq *)ptr;
#line 94
    ptr += sizeof(*ifr);
#line 97
    tmp___2 = ioctl(sock, 35091UL, ifr);
    }
#line 97
    if (tmp___2 != 0) {
#line 98
      goto while_continue___0;
    }
#line 101
    if (((int )ifr->ifr_ifru.ifru_flags & 1) == 0) {
#line 102
      goto while_continue___0;
    }
#line 104
    if (((int )ifr->ifr_ifru.ifru_flags & 64) == 0) {
#line 105
      goto while_continue___0;
    }
    {
#line 109
    tmp___3 = ioctl(sock, 35093UL, ifr);
    }
#line 109
    if (tmp___3 != 0) {
#line 110
      goto while_continue___0;
    }
    {
#line 113
    ip_addr_in = (struct sockaddr_in *)(& ifr->ifr_ifru.ifru_addr);
#line 114
    tmp___4 = ntohl(ip_addr_in->sin_addr.s_addr);
#line 114
    ip_addr = tmp___4;
    }
#line 115
    if (ip_addr == 0U) {
#line 116
      goto while_continue___0;
    }
    {
#line 120
    tmp___5 = ioctl(sock, 35099UL, ifr);
    }
#line 120
    if (tmp___5 != 0) {
#line 121
      goto while_continue___0;
    }
    {
#line 124
    subnet_mask_in = (struct sockaddr_in *)(& ifr->ifr_ifru.ifru_addr);
#line 125
    tmp___6 = ntohl(subnet_mask_in->sin_addr.s_addr);
#line 125
    subnet_mask = tmp___6;
    }
#line 128
    if (count < max_count) {
#line 129
      ip_info = ip_info_list + count;
#line 130
      ip_info->ip_addr = ip_addr;
#line 131
      ip_info->subnet_mask = subnet_mask;
    }
#line 134
    count ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 137
  free((void *)ifc.ifc_ifcu.ifcu_buf);
#line 138
  close(sock);
  }
#line 139
  return (count);
}
}
#line 142 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_sock_posix.c"
hdhomerun_sock_t hdhomerun_sock_create_udp(void) 
{ 
  hdhomerun_sock_t sock ;
  int tmp ;
  int tmp___0 ;
  int sock_opt ;

  {
  {
#line 145
  tmp = socket(2, 2, 0);
#line 145
  sock = tmp;
  }
#line 146
  if (sock == -1) {
#line 147
    return (-1);
  }
  {
#line 151
  tmp___0 = fcntl(sock, 4, 2048);
  }
#line 151
  if (tmp___0 != 0) {
    {
#line 152
    close(sock);
    }
#line 153
    return (-1);
  }
  {
#line 157
  sock_opt = 1;
#line 158
  setsockopt(sock, 1, 6, (void const   *)((char *)(& sock_opt)), (socklen_t )sizeof(sock_opt));
  }
#line 161
  return (sock);
}
}
#line 164 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_sock_posix.c"
hdhomerun_sock_t hdhomerun_sock_create_tcp(void) 
{ 
  hdhomerun_sock_t sock ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 167
  tmp = socket(2, 1, 0);
#line 167
  sock = tmp;
  }
#line 168
  if (sock == -1) {
#line 169
    return (-1);
  }
  {
#line 173
  tmp___0 = fcntl(sock, 4, 2048);
  }
#line 173
  if (tmp___0 != 0) {
    {
#line 174
    close(sock);
    }
#line 175
    return (-1);
  }
#line 179
  return (sock);
}
}
#line 182 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_sock_posix.c"
void hdhomerun_sock_destroy(hdhomerun_sock_t sock ) 
{ 


  {
  {
#line 184
  close(sock);
  }
#line 185
  return;
}
}
#line 187 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_sock_posix.c"
int hdhomerun_sock_getlasterror(void) 
{ 
  int *tmp ;

  {
  {
#line 189
  tmp = __errno_location();
  }
#line 189
  return (*tmp);
}
}
#line 192 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_sock_posix.c"
uint32_t hdhomerun_sock_getsockname_addr(hdhomerun_sock_t sock ) 
{ 
  struct sockaddr_in sock_addr ;
  socklen_t sockaddr_size ;
  int tmp ;
  uint32_t tmp___0 ;

  {
  {
#line 195
  sockaddr_size = (socklen_t )sizeof(sock_addr);
#line 197
  tmp = getsockname(sock, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& sock_addr)),
                    (socklen_t */* __restrict  */)(& sockaddr_size));
  }
#line 197
  if (tmp != 0) {
#line 198
    return ((uint32_t )0);
  }
  {
#line 201
  tmp___0 = ntohl(sock_addr.sin_addr.s_addr);
  }
#line 201
  return (tmp___0);
}
}
#line 204 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_sock_posix.c"
uint16_t hdhomerun_sock_getsockname_port(hdhomerun_sock_t sock ) 
{ 
  struct sockaddr_in sock_addr ;
  socklen_t sockaddr_size ;
  int tmp ;
  uint16_t tmp___0 ;

  {
  {
#line 207
  sockaddr_size = (socklen_t )sizeof(sock_addr);
#line 209
  tmp = getsockname(sock, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& sock_addr)),
                    (socklen_t */* __restrict  */)(& sockaddr_size));
  }
#line 209
  if (tmp != 0) {
#line 210
    return ((uint16_t )0);
  }
  {
#line 213
  tmp___0 = ntohs(sock_addr.sin_port);
  }
#line 213
  return (tmp___0);
}
}
#line 216 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_sock_posix.c"
uint32_t hdhomerun_sock_getpeername_addr(hdhomerun_sock_t sock ) 
{ 
  struct sockaddr_in sock_addr ;
  socklen_t sockaddr_size ;
  int tmp ;
  uint32_t tmp___0 ;

  {
  {
#line 219
  sockaddr_size = (socklen_t )sizeof(sock_addr);
#line 221
  tmp = getpeername(sock, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& sock_addr)),
                    (socklen_t */* __restrict  */)(& sockaddr_size));
  }
#line 221
  if (tmp != 0) {
#line 222
    return ((uint32_t )0);
  }
  {
#line 225
  tmp___0 = ntohl(sock_addr.sin_addr.s_addr);
  }
#line 225
  return (tmp___0);
}
}
#line 228 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_sock_posix.c"
uint32_t hdhomerun_sock_getaddrinfo_addr(hdhomerun_sock_t sock , char const   *name ) 
{ 
  struct addrinfo hints ;
  struct addrinfo *sock_info ;
  int tmp ;
  struct sockaddr_in *sock_addr ;
  uint32_t addr ;
  uint32_t tmp___0 ;

  {
  {
#line 231
  memset((void *)(& hints), 0, sizeof(hints));
#line 232
  hints.ai_family = 2;
#line 233
  hints.ai_socktype = 1;
#line 234
  hints.ai_protocol = 6;
#line 237
  tmp = getaddrinfo((char const   */* __restrict  */)name, (char const   */* __restrict  */)"",
                    (struct addrinfo  const  */* __restrict  */)(& hints), (struct addrinfo **/* __restrict  */)(& sock_info));
  }
#line 237
  if (tmp != 0) {
#line 238
    return ((uint32_t )0);
  }
  {
#line 241
  sock_addr = (struct sockaddr_in *)sock_info->ai_addr;
#line 242
  tmp___0 = ntohl(sock_addr->sin_addr.s_addr);
#line 242
  addr = tmp___0;
#line 244
  freeaddrinfo(sock_info);
  }
#line 245
  return (addr);
}
}
#line 248 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_sock_posix.c"
bool_t hdhomerun_sock_join_multicast_group(hdhomerun_sock_t sock , uint32_t multicast_ip ,
                                           uint32_t local_ip ) 
{ 
  struct ip_mreq imr ;
  int tmp ;

  {
  {
#line 251
  memset((void *)(& imr), 0, sizeof(imr));
#line 252
  imr.imr_multiaddr.s_addr = htonl(multicast_ip);
#line 253
  imr.imr_interface.s_addr = htonl(local_ip);
#line 255
  tmp = setsockopt(sock, 0, 35, (void const   *)((char const   *)(& imr)), (socklen_t )sizeof(imr));
  }
#line 255
  if (tmp != 0) {
#line 256
    return (0);
  }
#line 259
  return (1);
}
}
#line 262 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_sock_posix.c"
bool_t hdhomerun_sock_leave_multicast_group(hdhomerun_sock_t sock , uint32_t multicast_ip ,
                                            uint32_t local_ip ) 
{ 
  struct ip_mreq imr ;
  int tmp ;

  {
  {
#line 265
  memset((void *)(& imr), 0, sizeof(imr));
#line 266
  imr.imr_multiaddr.s_addr = htonl(multicast_ip);
#line 267
  imr.imr_interface.s_addr = htonl(local_ip);
#line 269
  tmp = setsockopt(sock, 0, 36, (void const   *)((char const   *)(& imr)), (socklen_t )sizeof(imr));
  }
#line 269
  if (tmp != 0) {
#line 270
    return (0);
  }
#line 273
  return (1);
}
}
#line 276 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_sock_posix.c"
bool_t hdhomerun_sock_bind(hdhomerun_sock_t sock , uint32_t local_addr , uint16_t local_port ,
                           bool_t allow_reuse ) 
{ 
  int sock_opt ;
  struct sockaddr_in sock_addr ;
  int tmp ;

  {
  {
#line 278
  sock_opt = allow_reuse;
#line 279
  setsockopt(sock, 1, 2, (void const   *)((char *)(& sock_opt)), (socklen_t )sizeof(sock_opt));
#line 282
  memset((void *)(& sock_addr), 0, sizeof(sock_addr));
#line 283
  sock_addr.sin_family = (sa_family_t )2;
#line 284
  sock_addr.sin_addr.s_addr = htonl(local_addr);
#line 285
  sock_addr.sin_port = htons(local_port);
#line 287
  tmp = bind(sock, (struct sockaddr  const  *)((struct sockaddr *)(& sock_addr)),
             (socklen_t )sizeof(sock_addr));
  }
#line 287
  if (tmp != 0) {
#line 288
    return (0);
  }
#line 291
  return (1);
}
}
#line 294 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_sock_posix.c"
static bool_t hdhomerun_sock_wait_for_event(hdhomerun_sock_t sock , short event_type ,
                                            uint64_t stop_time ) 
{ 
  uint64_t current_time ;
  uint64_t tmp ;
  struct pollfd poll_event ;
  uint64_t timeout ;
  int tmp___0 ;

  {
  {
#line 296
  tmp = getcurrenttime();
#line 296
  current_time = tmp;
  }
#line 297
  if (current_time >= stop_time) {
#line 298
    return (0);
  }
  {
#line 302
  poll_event.fd = sock;
#line 303
  poll_event.events = event_type;
#line 304
  poll_event.revents = (short)0;
#line 306
  timeout = stop_time - current_time;
#line 308
  tmp___0 = poll(& poll_event, (nfds_t )1, (int )timeout);
  }
#line 308
  if (tmp___0 <= 0) {
#line 309
    return (0);
  }
#line 312
  if (((int )poll_event.revents & (int )event_type) == 0) {
#line 313
    return (0);
  }
#line 316
  return (1);
}
}
#line 319 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_sock_posix.c"
bool_t hdhomerun_sock_connect(hdhomerun_sock_t sock , uint32_t remote_addr , uint16_t remote_port ,
                              uint64_t timeout ) 
{ 
  struct sockaddr_in sock_addr ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  uint64_t stop_time ;
  uint64_t tmp___3 ;
  bool_t tmp___4 ;

  {
  {
#line 322
  memset((void *)(& sock_addr), 0, sizeof(sock_addr));
#line 323
  sock_addr.sin_family = (sa_family_t )2;
#line 324
  sock_addr.sin_addr.s_addr = htonl(remote_addr);
#line 325
  sock_addr.sin_port = htons(remote_port);
#line 327
  tmp___2 = connect(sock, (struct sockaddr  const  *)((struct sockaddr *)(& sock_addr)),
                    (socklen_t )sizeof(sock_addr));
  }
#line 327
  if (tmp___2 != 0) {
    {
#line 328
    tmp = __errno_location();
    }
#line 328
    if (*tmp != 11) {
      {
#line 328
      tmp___0 = __errno_location();
      }
#line 328
      if (*tmp___0 != 11) {
        {
#line 328
        tmp___1 = __errno_location();
        }
#line 328
        if (*tmp___1 != 115) {
#line 329
          return (0);
        }
      }
    }
  }
  {
#line 333
  tmp___3 = getcurrenttime();
#line 333
  stop_time = tmp___3 + timeout;
#line 334
  tmp___4 = hdhomerun_sock_wait_for_event(sock, (short)4, stop_time);
  }
#line 334
  return (tmp___4);
}
}
#line 337 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_sock_posix.c"
bool_t hdhomerun_sock_send(hdhomerun_sock_t sock , void const   *data , size_t length ,
                           uint64_t timeout ) 
{ 
  uint64_t stop_time ;
  uint64_t tmp ;
  uint8_t const   *ptr ;
  int ret ;
  ssize_t tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  bool_t tmp___4 ;

  {
  {
#line 339
  tmp = getcurrenttime();
#line 339
  stop_time = tmp + timeout;
#line 340
  ptr = (uint8_t const   *)data;
  }
  {
#line 342
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 343
    tmp___0 = send(sock, (void const   *)ptr, length, 16384);
#line 343
    ret = (int )tmp___0;
    }
#line 344
    if (ret <= 0) {
      {
#line 345
      tmp___1 = __errno_location();
      }
#line 345
      if (*tmp___1 != 11) {
        {
#line 345
        tmp___2 = __errno_location();
        }
#line 345
        if (*tmp___2 != 11) {
          {
#line 345
          tmp___3 = __errno_location();
          }
#line 345
          if (*tmp___3 != 115) {
#line 346
            return (0);
          }
        }
      }
      {
#line 348
      tmp___4 = hdhomerun_sock_wait_for_event(sock, (short)4, stop_time);
      }
#line 348
      if (! tmp___4) {
#line 349
        return (0);
      }
#line 351
      goto while_continue;
    }
#line 354
    if (ret < (int )length) {
#line 355
      ptr += ret;
#line 356
      length -= (size_t )ret;
#line 357
      goto while_continue;
    }
#line 360
    return (1);
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 364 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_sock_posix.c"
bool_t hdhomerun_sock_sendto(hdhomerun_sock_t sock , uint32_t remote_addr , uint16_t remote_port ,
                             void const   *data , size_t length , uint64_t timeout ) 
{ 
  uint64_t stop_time ;
  uint64_t tmp ;
  uint8_t const   *ptr ;
  struct sockaddr_in sock_addr ;
  int ret ;
  ssize_t tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  bool_t tmp___4 ;

  {
  {
#line 366
  tmp = getcurrenttime();
#line 366
  stop_time = tmp + timeout;
#line 367
  ptr = (uint8_t const   *)data;
  }
  {
#line 369
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 371
    memset((void *)(& sock_addr), 0, sizeof(sock_addr));
#line 372
    sock_addr.sin_family = (sa_family_t )2;
#line 373
    sock_addr.sin_addr.s_addr = htonl(remote_addr);
#line 374
    sock_addr.sin_port = htons(remote_port);
#line 376
    tmp___0 = sendto(sock, (void const   *)ptr, length, 0, (struct sockaddr  const  *)((struct sockaddr *)(& sock_addr)),
                     (socklen_t )sizeof(sock_addr));
#line 376
    ret = (int )tmp___0;
    }
#line 377
    if (ret <= 0) {
      {
#line 378
      tmp___1 = __errno_location();
      }
#line 378
      if (*tmp___1 != 11) {
        {
#line 378
        tmp___2 = __errno_location();
        }
#line 378
        if (*tmp___2 != 11) {
          {
#line 378
          tmp___3 = __errno_location();
          }
#line 378
          if (*tmp___3 != 115) {
#line 379
            return (0);
          }
        }
      }
      {
#line 381
      tmp___4 = hdhomerun_sock_wait_for_event(sock, (short)4, stop_time);
      }
#line 381
      if (! tmp___4) {
#line 382
        return (0);
      }
#line 384
      goto while_continue;
    }
#line 387
    if (ret < (int )length) {
#line 388
      ptr += ret;
#line 389
      length -= (size_t )ret;
#line 390
      goto while_continue;
    }
#line 393
    return (1);
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 397 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_sock_posix.c"
bool_t hdhomerun_sock_recv(hdhomerun_sock_t sock , void *data , size_t *length , uint64_t timeout ) 
{ 
  uint64_t stop_time ;
  uint64_t tmp ;
  int ret ;
  ssize_t tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  bool_t tmp___4 ;

  {
  {
#line 399
  tmp = getcurrenttime();
#line 399
  stop_time = tmp + timeout;
  }
  {
#line 401
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 402
    tmp___0 = recv(sock, data, *length, 0);
#line 402
    ret = (int )tmp___0;
    }
#line 403
    if (ret < 0) {
      {
#line 404
      tmp___1 = __errno_location();
      }
#line 404
      if (*tmp___1 != 11) {
        {
#line 404
        tmp___2 = __errno_location();
        }
#line 404
        if (*tmp___2 != 11) {
          {
#line 404
          tmp___3 = __errno_location();
          }
#line 404
          if (*tmp___3 != 115) {
#line 405
            return (0);
          }
        }
      }
      {
#line 407
      tmp___4 = hdhomerun_sock_wait_for_event(sock, (short)1, stop_time);
      }
#line 407
      if (! tmp___4) {
#line 408
        return (0);
      }
#line 410
      goto while_continue;
    }
#line 413
    if (ret == 0) {
#line 414
      return (0);
    }
#line 417
    *length = (size_t )ret;
#line 418
    return (1);
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 422 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_sock_posix.c"
bool_t hdhomerun_sock_recvfrom(hdhomerun_sock_t sock , uint32_t *remote_addr , uint16_t *remote_port ,
                               void *data , size_t *length , uint64_t timeout ) 
{ 
  uint64_t stop_time ;
  uint64_t tmp ;
  struct sockaddr_in sock_addr ;
  socklen_t sockaddr_size ;
  int ret ;
  ssize_t tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  bool_t tmp___4 ;

  {
  {
#line 424
  tmp = getcurrenttime();
#line 424
  stop_time = tmp + timeout;
  }
  {
#line 426
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 428
    memset((void *)(& sock_addr), 0, sizeof(sock_addr));
#line 429
    sockaddr_size = (socklen_t )sizeof(sock_addr);
#line 431
    tmp___0 = recvfrom(sock, (void */* __restrict  */)data, *length, 0, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& sock_addr)),
                       (socklen_t */* __restrict  */)(& sockaddr_size));
#line 431
    ret = (int )tmp___0;
    }
#line 432
    if (ret < 0) {
      {
#line 433
      tmp___1 = __errno_location();
      }
#line 433
      if (*tmp___1 != 11) {
        {
#line 433
        tmp___2 = __errno_location();
        }
#line 433
        if (*tmp___2 != 11) {
          {
#line 433
          tmp___3 = __errno_location();
          }
#line 433
          if (*tmp___3 != 115) {
#line 434
            return (0);
          }
        }
      }
      {
#line 436
      tmp___4 = hdhomerun_sock_wait_for_event(sock, (short)1, stop_time);
      }
#line 436
      if (! tmp___4) {
#line 437
        return (0);
      }
#line 439
      goto while_continue;
    }
#line 442
    if (ret == 0) {
#line 443
      return (0);
    }
    {
#line 446
    *remote_addr = ntohl(sock_addr.sin_addr.s_addr);
#line 447
    *remote_port = ntohs(sock_addr.sin_port);
#line 448
    *length = (size_t )ret;
    }
#line 449
    return (1);
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 32 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_channels.h"
uint32_t hdhomerun_channel_entry_frequency(struct hdhomerun_channel_entry_t *entry ) ;
#line 33
char const   *hdhomerun_channel_entry_name(struct hdhomerun_channel_entry_t *entry ) ;
#line 35
struct hdhomerun_channel_list_t *hdhomerun_channel_list_create(char const   *channelmap ) ;
#line 36
void hdhomerun_channel_list_destroy(struct hdhomerun_channel_list_t *channel_list ) ;
#line 39
struct hdhomerun_channel_entry_t *hdhomerun_channel_list_last(struct hdhomerun_channel_list_t *channel_list ) ;
#line 41
struct hdhomerun_channel_entry_t *hdhomerun_channel_list_prev(struct hdhomerun_channel_list_t *channel_list ,
                                                              struct hdhomerun_channel_entry_t *entry ) ;
#line 32 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_channelscan.h"
struct hdhomerun_channelscan_t *channelscan_create(struct hdhomerun_device_t *hd___0 ,
                                                   char const   *channelmap ) ;
#line 33
void channelscan_destroy(struct hdhomerun_channelscan_t *scan ) ;
#line 35
int channelscan_advance(struct hdhomerun_channelscan_t *scan , struct hdhomerun_channelscan_result_t *result___1 ) ;
#line 36
int channelscan_detect(struct hdhomerun_channelscan_t *scan , struct hdhomerun_channelscan_result_t *result___1 ) ;
#line 37
uint8_t channelscan_get_progress(struct hdhomerun_channelscan_t *scan ) ;
#line 104 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.h"
int hdhomerun_device_get_tuner_status(struct hdhomerun_device_t *hd___0 , char **pstatus_str ,
                                      struct hdhomerun_tuner_status_t *status ) ;
#line 106
int hdhomerun_device_get_tuner_streaminfo(struct hdhomerun_device_t *hd___0 , char **pstreaminfo ) ;
#line 126
char const   *hdhomerun_device_get_model_str(struct hdhomerun_device_t *hd___0 ) ;
#line 137
int hdhomerun_device_set_tuner_channel(struct hdhomerun_device_t *hd___0 , char const   *channel ) ;
#line 200
int hdhomerun_device_wait_for_lock(struct hdhomerun_device_t *hd___0 , struct hdhomerun_tuner_status_t *status ) ;
#line 30 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_channelscan.c"
struct hdhomerun_channelscan_t *channelscan_create(struct hdhomerun_device_t *hd___0 ,
                                                   char const   *channelmap ) 
{ 
  struct hdhomerun_channelscan_t *scan ;
  void *tmp ;

  {
  {
#line 32
  tmp = calloc((size_t )1, sizeof(struct hdhomerun_channelscan_t ));
#line 32
  scan = (struct hdhomerun_channelscan_t *)tmp;
  }
#line 33
  if (! scan) {
#line 34
    return ((struct hdhomerun_channelscan_t *)((void *)0));
  }
  {
#line 37
  scan->hd = hd___0;
#line 39
  scan->channel_list = hdhomerun_channel_list_create(channelmap);
  }
#line 40
  if (! scan->channel_list) {
    {
#line 41
    free((void *)scan);
    }
#line 42
    return ((struct hdhomerun_channelscan_t *)((void *)0));
  }
  {
#line 45
  scan->next_channel = hdhomerun_channel_list_last(scan->channel_list);
  }
#line 46
  return (scan);
}
}
#line 49 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_channelscan.c"
void channelscan_destroy(struct hdhomerun_channelscan_t *scan ) 
{ 


  {
  {
#line 51
  hdhomerun_channel_list_destroy(scan->channel_list);
#line 52
  free((void *)scan);
  }
#line 53
  return;
}
}
#line 55 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_channelscan.c"
static int channelscan_find_lock(struct hdhomerun_channelscan_t *scan , uint32_t frequency ,
                                 struct hdhomerun_channelscan_result_t *result___1 ) 
{ 
  char channel_str[64] ;
  int ret ;
  int tmp ;
  uint64_t timeout ;
  uint64_t tmp___0 ;
  uint64_t tmp___1 ;

  {
  {
#line 59
  hdhomerun_sprintf(channel_str, channel_str + sizeof(channel_str), "auto:%u", frequency);
#line 61
  tmp = hdhomerun_device_set_tuner_channel(scan->hd, (char const   *)(channel_str));
#line 61
  ret = tmp;
  }
#line 62
  if (ret <= 0) {
#line 63
    return (ret);
  }
  {
#line 67
  ret = hdhomerun_device_wait_for_lock(scan->hd, & result___1->status);
  }
#line 68
  if (ret <= 0) {
#line 69
    return (ret);
  }
#line 71
  if (! result___1->status.lock_supported) {
#line 72
    return (1);
  }
  {
#line 76
  tmp___0 = getcurrenttime();
#line 76
  timeout = tmp___0 + 5000UL;
  }
  {
#line 77
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 78
    ret = hdhomerun_device_get_tuner_status(scan->hd, (char **)((void *)0), & result___1->status);
    }
#line 79
    if (ret <= 0) {
#line 80
      return (ret);
    }
#line 83
    if (result___1->status.symbol_error_quality == 100U) {
#line 84
      return (1);
    }
    {
#line 87
    tmp___1 = getcurrenttime();
    }
#line 87
    if (tmp___1 >= timeout) {
#line 88
      return (1);
    }
    {
#line 91
    msleep_approx((uint64_t )250);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_channelscan.c"
static void channelscan_extract_name(struct hdhomerun_channelscan_program_t *program ,
                                     char const   *line ) 
{ 
  char const   *start ;
  char *tmp ;
  char *tmp___0 ;
  char const   *end ;
  char *tmp___1 ;
  char *tmp___2 ;
  size_t length ;

  {
  {
#line 98
  tmp = strchr(line, ' ');
#line 98
  start = (char const   *)tmp;
  }
#line 99
  if (! start) {
#line 100
    return;
  }
  {
#line 102
  start ++;
#line 104
  tmp___0 = strchr(start, ' ');
#line 104
  start = (char const   *)tmp___0;
  }
#line 105
  if (! start) {
#line 106
    return;
  }
  {
#line 108
  start ++;
#line 111
  tmp___1 = strstr(start, " (");
#line 111
  end = (char const   *)tmp___1;
  }
#line 112
  if (! end) {
    {
#line 113
    tmp___2 = strchr(line, 0);
#line 113
    end = (char const   *)tmp___2;
    }
  }
#line 116
  if ((unsigned long )end <= (unsigned long )start) {
#line 117
    return;
  }
#line 121
  length = (size_t )(end - start);
#line 122
  if (length > sizeof(program->name) - 1UL) {
#line 123
    length = sizeof(program->name) - 1UL;
  }
  {
#line 126
  strncpy((char */* __restrict  */)(program->name), (char const   */* __restrict  */)start,
          length);
#line 127
  program->name[length] = (char)0;
  }
#line 128
  return;
}
}
#line 130 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_channelscan.c"
static int channelscan_detect_programs(struct hdhomerun_channelscan_t *scan , struct hdhomerun_channelscan_result_t *result___1 ,
                                       bool_t *pchanged , bool_t *pincomplete ) 
{ 
  char *streaminfo ;
  int ret ;
  int tmp ;
  char *next_line ;
  int program_count ;
  char *line ;
  char *tmp___0 ;
  unsigned int transport_stream_id ;
  int tmp___1 ;
  struct hdhomerun_channelscan_program_t program ;
  unsigned int program_number ;
  unsigned int virtual_major ;
  unsigned int virtual_minor ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;

  {
  {
#line 132
  *pchanged = 0;
#line 133
  *pincomplete = 0;
#line 136
  tmp = hdhomerun_device_get_tuner_streaminfo(scan->hd, & streaminfo);
#line 136
  ret = tmp;
  }
#line 137
  if (ret <= 0) {
#line 138
    return (ret);
  }
#line 141
  next_line = streaminfo;
#line 142
  program_count = 0;
  {
#line 144
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 145
    line = next_line;
#line 147
    next_line = strchr((char const   *)line, '\n');
    }
#line 148
    if (! next_line) {
#line 149
      goto while_break;
    }
    {
#line 151
    tmp___0 = next_line;
#line 151
    next_line ++;
#line 151
    *tmp___0 = (char)0;
#line 154
    tmp___1 = sscanf((char const   */* __restrict  */)line, (char const   */* __restrict  */)"tsid=0x%x",
                     & transport_stream_id);
    }
#line 154
    if (tmp___1 == 1) {
#line 155
      result___1->transport_stream_id = (uint16_t )transport_stream_id;
#line 156
      result___1->transport_stream_id_detected = 1;
#line 157
      goto while_continue;
    }
#line 160
    if (program_count >= 64) {
#line 161
      goto while_continue;
    }
    {
#line 165
    memset((void *)(& program), 0, sizeof(program));
#line 167
    hdhomerun_sprintf(program.program_str, program.program_str + sizeof(program.program_str),
                      "%s", line);
#line 171
    tmp___3 = sscanf((char const   */* __restrict  */)line, (char const   */* __restrict  */)"%u: %u.%u",
                     & program_number, & virtual_major, & virtual_minor);
    }
#line 171
    if (tmp___3 != 3) {
      {
#line 172
      tmp___2 = sscanf((char const   */* __restrict  */)line, (char const   */* __restrict  */)"%u: %u",
                       & program_number, & virtual_major);
      }
#line 172
      if (tmp___2 != 2) {
#line 173
        goto while_continue;
      }
#line 175
      virtual_minor = 0U;
    }
    {
#line 178
    program.program_number = (uint16_t )program_number;
#line 179
    program.virtual_major = (uint16_t )virtual_major;
#line 180
    program.virtual_minor = (uint16_t )virtual_minor;
#line 182
    channelscan_extract_name(& program, (char const   *)line);
#line 184
    tmp___6 = strstr((char const   *)line, "(control)");
    }
#line 184
    if (tmp___6) {
#line 185
      program.type = (uint16_t )2;
    } else {
      {
#line 186
      tmp___5 = strstr((char const   *)line, "(encrypted)");
      }
#line 186
      if (tmp___5) {
#line 187
        program.type = (uint16_t )3;
      } else {
        {
#line 188
        tmp___4 = strstr((char const   *)line, "(no data)");
        }
#line 188
        if (tmp___4) {
#line 189
          program.type = (uint16_t )1;
#line 190
          *pincomplete = 1;
        } else {
#line 192
          program.type = (uint16_t )0;
#line 193
          if ((int )program.virtual_major == 0) {
#line 194
            *pincomplete = 1;
          } else
#line 193
          if ((int )program.name[0] == 0) {
#line 194
            *pincomplete = 1;
          }
        }
      }
    }
    {
#line 198
    tmp___7 = memcmp((void const   *)(& result___1->programs[program_count]), (void const   *)(& program),
                     sizeof(program));
    }
#line 198
    if (tmp___7 != 0) {
      {
#line 199
      memcpy((void */* __restrict  */)(& result___1->programs[program_count]), (void const   */* __restrict  */)(& program),
             sizeof(program));
#line 200
      *pchanged = 1;
      }
    }
#line 203
    program_count ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 206
  if (program_count == 0) {
#line 207
    *pincomplete = 1;
  }
#line 209
  if (result___1->program_count != program_count) {
#line 210
    result___1->program_count = program_count;
#line 211
    *pchanged = 1;
  }
#line 214
  return (1);
}
}
#line 217 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_channelscan.c"
int channelscan_advance(struct hdhomerun_channelscan_t *scan , struct hdhomerun_channelscan_result_t *result___1 ) 
{ 
  struct hdhomerun_channel_entry_t *entry ;
  char *ptr ;
  char *end ;
  char const   *tmp ;
  uint32_t tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 219
  memset((void *)result___1, 0, sizeof(struct hdhomerun_channelscan_result_t ));
#line 221
  entry = scan->next_channel;
  }
#line 222
  if (! entry) {
#line 223
    return (0);
  }
  {
#line 227
  result___1->frequency = hdhomerun_channel_entry_frequency(entry);
#line 229
  ptr = result___1->channel_str;
#line 230
  end = result___1->channel_str + sizeof(result___1->channel_str);
#line 231
  tmp = hdhomerun_channel_entry_name(entry);
#line 231
  hdhomerun_sprintf(ptr, end, tmp);
  }
  {
#line 233
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 234
    entry = hdhomerun_channel_list_prev(scan->channel_list, entry);
    }
#line 235
    if (! entry) {
#line 236
      scan->next_channel = (struct hdhomerun_channel_entry_t *)((void *)0);
#line 237
      goto while_break;
    }
    {
#line 240
    tmp___0 = hdhomerun_channel_entry_frequency(entry);
    }
#line 240
    if (tmp___0 != result___1->frequency) {
#line 241
      scan->next_channel = entry;
#line 242
      goto while_break;
    }
    {
#line 245
    ptr = strchr((char const   *)ptr, 0);
#line 246
    tmp___1 = hdhomerun_channel_entry_name(entry);
#line 246
    hdhomerun_sprintf(ptr, end, ", %s", tmp___1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 249
  return (1);
}
}
#line 252 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_channelscan.c"
int channelscan_detect(struct hdhomerun_channelscan_t *scan , struct hdhomerun_channelscan_result_t *result___1 ) 
{ 
  int ret ;
  int tmp ;
  uint64_t timeout ;
  uint64_t tmp___0 ;
  uint64_t tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  uint64_t complete_time ;
  uint64_t tmp___4 ;
  bool_t changed ;
  bool_t incomplete ;
  uint64_t tmp___5 ;
  uint64_t tmp___6 ;
  uint64_t tmp___7 ;
  uint32_t max_next_frequency ;
  uint32_t tmp___8 ;

  {
  {
#line 254
  (scan->scanned_channels) ++;
#line 257
  tmp = channelscan_find_lock(scan, result___1->frequency, result___1);
#line 257
  ret = tmp;
  }
#line 258
  if (ret <= 0) {
#line 259
    return (ret);
  }
#line 261
  if (! result___1->status.lock_supported) {
#line 262
    return (1);
  }
  {
#line 266
  result___1->program_count = 0;
#line 269
  tmp___2 = hdhomerun_device_get_model_str(scan->hd);
#line 269
  tmp___3 = strstr(tmp___2, "atsc");
  }
#line 269
  if (tmp___3) {
    {
#line 270
    tmp___0 = getcurrenttime();
#line 270
    timeout = tmp___0 + 4000UL;
    }
  } else {
    {
#line 272
    tmp___1 = getcurrenttime();
#line 272
    timeout = tmp___1 + 10000UL;
    }
  }
  {
#line 275
  tmp___4 = getcurrenttime();
#line 275
  complete_time = tmp___4 + 1000UL;
  }
  {
#line 277
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 279
    ret = channelscan_detect_programs(scan, result___1, & changed, & incomplete);
    }
#line 280
    if (ret <= 0) {
#line 281
      return (ret);
    }
#line 284
    if (changed) {
      {
#line 285
      tmp___5 = getcurrenttime();
#line 285
      complete_time = tmp___5 + 1000UL;
      }
    }
#line 288
    if (! incomplete) {
      {
#line 288
      tmp___6 = getcurrenttime();
      }
#line 288
      if (tmp___6 >= complete_time) {
#line 289
        goto while_break;
      }
    }
    {
#line 292
    tmp___7 = getcurrenttime();
    }
#line 292
    if (tmp___7 >= timeout) {
#line 293
      goto while_break;
    }
    {
#line 296
    msleep_approx((uint64_t )250);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 300
  max_next_frequency = result___1->frequency - 5500000U;
  {
#line 301
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 302
    if (! scan->next_channel) {
#line 303
      goto while_break___0;
    }
    {
#line 306
    tmp___8 = hdhomerun_channel_entry_frequency(scan->next_channel);
    }
#line 306
    if (tmp___8 <= max_next_frequency) {
#line 307
      goto while_break___0;
    }
    {
#line 310
    scan->next_channel = hdhomerun_channel_list_prev(scan->channel_list, scan->next_channel);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 314
  return (1);
}
}
#line 317 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_channelscan.c"
uint8_t channelscan_get_progress(struct hdhomerun_channelscan_t *scan ) 
{ 
  struct hdhomerun_channel_entry_t *entry ;
  uint32_t channels_remaining ;
  uint32_t frequency ;
  uint32_t tmp ;
  uint32_t tmp___0 ;

  {
#line 319
  entry = scan->next_channel;
#line 320
  if (! entry) {
#line 321
    return ((uint8_t )100);
  }
  {
#line 324
  channels_remaining = (uint32_t )1;
#line 325
  tmp = hdhomerun_channel_entry_frequency(entry);
#line 325
  frequency = tmp;
  }
  {
#line 327
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 328
    entry = hdhomerun_channel_list_prev(scan->channel_list, entry);
    }
#line 329
    if (! entry) {
#line 330
      goto while_break;
    }
    {
#line 333
    tmp___0 = hdhomerun_channel_entry_frequency(entry);
    }
#line 333
    if (tmp___0 != frequency) {
      {
#line 334
      channels_remaining ++;
#line 335
      frequency = hdhomerun_channel_entry_frequency(entry);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 339
  return ((uint8_t )((scan->scanned_channels * 100U) / (scan->scanned_channels + channels_remaining)));
}
}
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 147 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_pkt.h"
void hdhomerun_pkt_reset(struct hdhomerun_pkt_t *pkt ) ;
#line 153
uint8_t *hdhomerun_pkt_read_tlv(struct hdhomerun_pkt_t *pkt , uint8_t *ptag , size_t *plength ) ;
#line 155
void hdhomerun_pkt_write_u8(struct hdhomerun_pkt_t *pkt , uint8_t v ) ;
#line 157
void hdhomerun_pkt_write_u32(struct hdhomerun_pkt_t *pkt , uint32_t v ) ;
#line 158
void hdhomerun_pkt_write_var_length(struct hdhomerun_pkt_t *pkt , size_t v ) ;
#line 159
void hdhomerun_pkt_write_mem(struct hdhomerun_pkt_t *pkt , void const   *mem , size_t length ) ;
#line 161
int hdhomerun_pkt_open_frame(struct hdhomerun_pkt_t *pkt , uint16_t *ptype ) ;
#line 162
void hdhomerun_pkt_seal_frame(struct hdhomerun_pkt_t *pkt , uint16_t frame_type ) ;
#line 45 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_discover.h"
int hdhomerun_discover_find_devices_custom(uint32_t target_ip , uint32_t device_type ,
                                           uint32_t device_id , struct hdhomerun_discover_device_t *result_list ,
                                           int max_count ) ;
#line 71
bool_t hdhomerun_discover_is_ip_multicast(uint32_t ip_addr ) ;
#line 40 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_control.h"
struct hdhomerun_control_sock_t *hdhomerun_control_create(uint32_t device_id , uint32_t device_ip ,
                                                          struct hdhomerun_debug_t *dbg ) ;
#line 41
void hdhomerun_control_destroy(struct hdhomerun_control_sock_t *cs ) ;
#line 48
uint32_t hdhomerun_control_get_device_id(struct hdhomerun_control_sock_t *cs ) ;
#line 49
uint32_t hdhomerun_control_get_device_ip(struct hdhomerun_control_sock_t *cs ) ;
#line 50
uint32_t hdhomerun_control_get_device_id_requested(struct hdhomerun_control_sock_t *cs ) ;
#line 51
uint32_t hdhomerun_control_get_device_ip_requested(struct hdhomerun_control_sock_t *cs ) ;
#line 53
void hdhomerun_control_set_device(struct hdhomerun_control_sock_t *cs , uint32_t device_id ,
                                  uint32_t device_ip ) ;
#line 62
uint32_t hdhomerun_control_get_local_addr(struct hdhomerun_control_sock_t *cs ) ;
#line 67
int hdhomerun_control_send_recv(struct hdhomerun_control_sock_t *cs , struct hdhomerun_pkt_t *tx_pkt ,
                                struct hdhomerun_pkt_t *rx_pkt , uint16_t type ) ;
#line 86
int hdhomerun_control_get(struct hdhomerun_control_sock_t *cs , char const   *name ,
                          char **pvalue , char **perror___0 ) ;
#line 87
int hdhomerun_control_set(struct hdhomerun_control_sock_t *cs , char const   *name ,
                          char const   *value , char **pvalue , char **perror___0 ) ;
#line 88
int hdhomerun_control_set_with_lockkey(struct hdhomerun_control_sock_t *cs , char const   *name ,
                                       char const   *value , uint32_t lockkey , char **pvalue ,
                                       char **perror___0 ) ;
#line 99
int hdhomerun_control_upgrade(struct hdhomerun_control_sock_t *cs , FILE *upgrade_file ) ;
#line 39 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_control.c"
static void hdhomerun_control_close_sock(struct hdhomerun_control_sock_t *cs ) 
{ 


  {
#line 41
  if (cs->sock == -1) {
#line 42
    return;
  }
  {
#line 45
  hdhomerun_sock_destroy(cs->sock);
#line 46
  cs->sock = -1;
  }
#line 47
  return;
}
}
#line 49 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_control.c"
void hdhomerun_control_set_device(struct hdhomerun_control_sock_t *cs , uint32_t device_id ,
                                  uint32_t device_ip ) 
{ 


  {
  {
#line 51
  hdhomerun_control_close_sock(cs);
#line 53
  cs->desired_device_id = device_id;
#line 54
  cs->desired_device_ip = device_ip;
#line 55
  cs->actual_device_id = (uint32_t )0;
#line 56
  cs->actual_device_ip = (uint32_t )0;
  }
#line 57
  return;
}
}
#line 59 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_control.c"
struct hdhomerun_control_sock_t *hdhomerun_control_create(uint32_t device_id , uint32_t device_ip ,
                                                          struct hdhomerun_debug_t *dbg ) 
{ 
  struct hdhomerun_control_sock_t *cs ;
  void *tmp ;

  {
  {
#line 61
  tmp = calloc((size_t )1, sizeof(struct hdhomerun_control_sock_t ));
#line 61
  cs = (struct hdhomerun_control_sock_t *)tmp;
  }
#line 62
  if (! cs) {
    {
#line 63
    hdhomerun_debug_printf(dbg, "hdhomerun_control_create: failed to allocate control object\n");
    }
#line 64
    return ((struct hdhomerun_control_sock_t *)((void *)0));
  }
  {
#line 67
  cs->dbg = dbg;
#line 68
  cs->sock = -1;
#line 69
  hdhomerun_control_set_device(cs, device_id, device_ip);
  }
#line 71
  return (cs);
}
}
#line 74 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_control.c"
void hdhomerun_control_destroy(struct hdhomerun_control_sock_t *cs ) 
{ 


  {
  {
#line 76
  hdhomerun_control_close_sock(cs);
#line 77
  free((void *)cs);
  }
#line 78
  return;
}
}
#line 80 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_control.c"
static bool_t hdhomerun_control_connect_sock(struct hdhomerun_control_sock_t *cs ) 
{ 
  bool_t tmp ;
  struct hdhomerun_discover_device_t result___1 ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  bool_t tmp___3 ;

  {
#line 82
  if (cs->sock != -1) {
#line 83
    return (1);
  }
#line 86
  if (cs->desired_device_id == 0U) {
#line 86
    if (cs->desired_device_ip == 0U) {
      {
#line 87
      hdhomerun_debug_printf(cs->dbg, "hdhomerun_control_connect_sock: no device specified\n");
      }
#line 88
      return (0);
    }
  }
  {
#line 90
  tmp = hdhomerun_discover_is_ip_multicast(cs->desired_device_ip);
  }
#line 90
  if (tmp) {
    {
#line 91
    hdhomerun_debug_printf(cs->dbg, "hdhomerun_control_connect_sock: cannot use multicast ip address for device operations\n");
    }
#line 92
    return (0);
  }
  {
#line 97
  tmp___0 = hdhomerun_discover_find_devices_custom(cs->desired_device_ip, 4294967295U,
                                                   cs->desired_device_id, & result___1,
                                                   1);
  }
#line 97
  if (tmp___0 <= 0) {
    {
#line 98
    hdhomerun_debug_printf(cs->dbg, "hdhomerun_control_connect_sock: device not found\n");
    }
#line 99
    return (0);
  }
  {
#line 101
  cs->actual_device_ip = result___1.ip_addr;
#line 102
  cs->actual_device_id = result___1.device_id;
#line 105
  cs->sock = hdhomerun_sock_create_tcp();
  }
#line 106
  if (cs->sock == -1) {
    {
#line 107
    tmp___1 = hdhomerun_sock_getlasterror();
#line 107
    hdhomerun_debug_printf(cs->dbg, "hdhomerun_control_connect_sock: failed to create socket (%d)\n",
                           tmp___1);
    }
#line 108
    return (0);
  }
  {
#line 112
  tmp___3 = hdhomerun_sock_connect(cs->sock, cs->actual_device_ip, (uint16_t )65001,
                                   (uint64_t )2500);
  }
#line 112
  if (! tmp___3) {
    {
#line 113
    tmp___2 = hdhomerun_sock_getlasterror();
#line 113
    hdhomerun_debug_printf(cs->dbg, "hdhomerun_control_connect_sock: failed to connect (%d)\n",
                           tmp___2);
#line 114
    hdhomerun_control_close_sock(cs);
    }
#line 115
    return (0);
  }
#line 119
  return (1);
}
}
#line 122 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_control.c"
uint32_t hdhomerun_control_get_device_id(struct hdhomerun_control_sock_t *cs ) 
{ 
  bool_t tmp ;

  {
  {
#line 124
  tmp = hdhomerun_control_connect_sock(cs);
  }
#line 124
  if (! tmp) {
    {
#line 125
    hdhomerun_debug_printf(cs->dbg, "hdhomerun_control_get_device_id: connect failed\n");
    }
#line 126
    return ((uint32_t )0);
  }
#line 129
  return (cs->actual_device_id);
}
}
#line 132 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_control.c"
uint32_t hdhomerun_control_get_device_ip(struct hdhomerun_control_sock_t *cs ) 
{ 
  bool_t tmp ;

  {
  {
#line 134
  tmp = hdhomerun_control_connect_sock(cs);
  }
#line 134
  if (! tmp) {
    {
#line 135
    hdhomerun_debug_printf(cs->dbg, "hdhomerun_control_get_device_ip: connect failed\n");
    }
#line 136
    return ((uint32_t )0);
  }
#line 139
  return (cs->actual_device_ip);
}
}
#line 142 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_control.c"
uint32_t hdhomerun_control_get_device_id_requested(struct hdhomerun_control_sock_t *cs ) 
{ 


  {
#line 144
  return (cs->desired_device_id);
}
}
#line 147 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_control.c"
uint32_t hdhomerun_control_get_device_ip_requested(struct hdhomerun_control_sock_t *cs ) 
{ 


  {
#line 149
  return (cs->desired_device_ip);
}
}
#line 152 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_control.c"
uint32_t hdhomerun_control_get_local_addr(struct hdhomerun_control_sock_t *cs ) 
{ 
  bool_t tmp ;
  uint32_t addr ;
  uint32_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 154
  tmp = hdhomerun_control_connect_sock(cs);
  }
#line 154
  if (! tmp) {
    {
#line 155
    hdhomerun_debug_printf(cs->dbg, "hdhomerun_control_get_local_addr: connect failed\n");
    }
#line 156
    return ((uint32_t )0);
  }
  {
#line 159
  tmp___0 = hdhomerun_sock_getsockname_addr(cs->sock);
#line 159
  addr = tmp___0;
  }
#line 160
  if (addr == 0U) {
    {
#line 161
    tmp___1 = hdhomerun_sock_getlasterror();
#line 161
    hdhomerun_debug_printf(cs->dbg, "hdhomerun_control_get_local_addr: getsockname failed (%d)\n",
                           tmp___1);
    }
#line 162
    return ((uint32_t )0);
  }
#line 165
  return (addr);
}
}
#line 168 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_control.c"
static bool_t hdhomerun_control_send_sock(struct hdhomerun_control_sock_t *cs , struct hdhomerun_pkt_t *tx_pkt ) 
{ 
  int tmp ;
  bool_t tmp___0 ;

  {
  {
#line 170
  tmp___0 = hdhomerun_sock_send(cs->sock, (void const   *)tx_pkt->start, (size_t )(tx_pkt->end - tx_pkt->start),
                                (uint64_t )2500);
  }
#line 170
  if (! tmp___0) {
    {
#line 171
    tmp = hdhomerun_sock_getlasterror();
#line 171
    hdhomerun_debug_printf(cs->dbg, "hdhomerun_control_send_sock: send failed (%d)\n",
                           tmp);
#line 172
    hdhomerun_control_close_sock(cs);
    }
#line 173
    return (0);
  }
#line 176
  return (1);
}
}
#line 179 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_control.c"
static bool_t hdhomerun_control_recv_sock(struct hdhomerun_control_sock_t *cs , struct hdhomerun_pkt_t *rx_pkt ,
                                          uint16_t *ptype , uint64_t recv_timeout ) 
{ 
  uint64_t stop_time ;
  uint64_t tmp ;
  uint64_t current_time ;
  uint64_t tmp___0 ;
  size_t length ;
  int tmp___1 ;
  bool_t tmp___2 ;
  int ret ;
  bool_t tmp___3 ;

  {
  {
#line 181
  tmp = getcurrenttime();
#line 181
  stop_time = tmp + recv_timeout;
#line 182
  hdhomerun_pkt_reset(rx_pkt);
  }
  {
#line 184
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 185
    tmp___0 = getcurrenttime();
#line 185
    current_time = tmp___0;
    }
#line 186
    if (current_time >= stop_time) {
      {
#line 187
      hdhomerun_debug_printf(cs->dbg, "hdhomerun_control_recv_sock: timeout\n");
#line 188
      hdhomerun_control_close_sock(cs);
      }
#line 189
      return (0);
    }
    {
#line 192
    length = (size_t )(rx_pkt->limit - rx_pkt->end);
#line 193
    tmp___2 = hdhomerun_sock_recv(cs->sock, (void *)rx_pkt->end, & length, stop_time - current_time);
    }
#line 193
    if (! tmp___2) {
      {
#line 194
      tmp___1 = hdhomerun_sock_getlasterror();
#line 194
      hdhomerun_debug_printf(cs->dbg, "hdhomerun_control_recv_sock: recv failed (%d)\n",
                             tmp___1);
#line 195
      hdhomerun_control_close_sock(cs);
      }
#line 196
      return (0);
    }
    {
#line 199
    rx_pkt->end += length;
#line 201
    tmp___3 = hdhomerun_pkt_open_frame(rx_pkt, ptype);
#line 201
    ret = tmp___3;
    }
#line 202
    if (ret < 0) {
      {
#line 203
      hdhomerun_debug_printf(cs->dbg, "hdhomerun_control_recv_sock: frame error\n");
#line 204
      hdhomerun_control_close_sock(cs);
      }
#line 205
      return (0);
    }
#line 207
    if (ret > 0) {
#line 208
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 213 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_control.c"
static int hdhomerun_control_send_recv_internal(struct hdhomerun_control_sock_t *cs ,
                                                struct hdhomerun_pkt_t *tx_pkt , struct hdhomerun_pkt_t *rx_pkt ,
                                                uint16_t type , uint64_t recv_timeout ) 
{ 
  int i ;
  bool_t tmp ;
  bool_t tmp___0 ;
  uint16_t rsp_type ;
  bool_t tmp___1 ;

  {
  {
#line 215
  hdhomerun_pkt_seal_frame(tx_pkt, type);
#line 218
  i = 0;
  }
  {
#line 218
  while (1) {
    while_continue: /* CIL Label */ ;
#line 218
    if (! (i < 2)) {
#line 218
      goto while_break;
    }
#line 219
    if (cs->sock == -1) {
      {
#line 220
      tmp = hdhomerun_control_connect_sock(cs);
      }
#line 220
      if (! tmp) {
        {
#line 221
        hdhomerun_debug_printf(cs->dbg, "hdhomerun_control_send_recv: connect failed\n");
        }
#line 222
        return (-1);
      }
    }
    {
#line 226
    tmp___0 = hdhomerun_control_send_sock(cs, tx_pkt);
    }
#line 226
    if (! tmp___0) {
#line 227
      goto __Cont;
    }
#line 229
    if (! rx_pkt) {
#line 230
      return (1);
    }
    {
#line 234
    tmp___1 = hdhomerun_control_recv_sock(cs, rx_pkt, & rsp_type, recv_timeout);
    }
#line 234
    if (! tmp___1) {
#line 235
      goto __Cont;
    }
#line 237
    if ((int )rsp_type != (int )type + 1) {
      {
#line 238
      hdhomerun_debug_printf(cs->dbg, "hdhomerun_control_send_recv: unexpected frame type\n");
#line 239
      hdhomerun_control_close_sock(cs);
      }
#line 240
      goto __Cont;
    }
#line 243
    return (1);
    __Cont: /* CIL Label */ 
#line 218
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 246
  hdhomerun_debug_printf(cs->dbg, "hdhomerun_control_send_recv: failed\n");
  }
#line 247
  return (-1);
}
}
#line 250 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_control.c"
int hdhomerun_control_send_recv(struct hdhomerun_control_sock_t *cs , struct hdhomerun_pkt_t *tx_pkt ,
                                struct hdhomerun_pkt_t *rx_pkt , uint16_t type ) 
{ 
  int tmp ;

  {
  {
#line 252
  tmp = hdhomerun_control_send_recv_internal(cs, tx_pkt, rx_pkt, type, (uint64_t )2500);
  }
#line 252
  return (tmp);
}
}
#line 255 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_control.c"
static int hdhomerun_control_get_set(struct hdhomerun_control_sock_t *cs , char const   *name ,
                                     char const   *value , uint32_t lockkey , char **pvalue ,
                                     char **perror___0 ) 
{ 
  struct hdhomerun_pkt_t *tx_pkt ;
  struct hdhomerun_pkt_t *rx_pkt ;
  int name_len ;
  size_t tmp ;
  int value_len ;
  size_t tmp___0 ;
  int tmp___1 ;
  uint8_t tag ;
  size_t len ;
  uint8_t *next ;
  uint8_t *tmp___2 ;

  {
  {
#line 257
  tx_pkt = & cs->tx_pkt;
#line 258
  rx_pkt = & cs->rx_pkt;
#line 261
  hdhomerun_pkt_reset(tx_pkt);
#line 263
  tmp = strlen(name);
#line 263
  name_len = (int )tmp + 1;
  }
#line 264
  if ((unsigned long )((tx_pkt->end + 3) + name_len) > (unsigned long )tx_pkt->limit) {
    {
#line 265
    hdhomerun_debug_printf(cs->dbg, "hdhomerun_control_get_set: request too long\n");
    }
#line 266
    return (-1);
  }
  {
#line 268
  hdhomerun_pkt_write_u8(tx_pkt, (uint8_t )3);
#line 269
  hdhomerun_pkt_write_var_length(tx_pkt, (size_t )name_len);
#line 270
  hdhomerun_pkt_write_mem(tx_pkt, (void const   *)name, (size_t )name_len);
  }
#line 272
  if (value) {
    {
#line 273
    tmp___0 = strlen(value);
#line 273
    value_len = (int )tmp___0 + 1;
    }
#line 274
    if ((unsigned long )((tx_pkt->end + 3) + value_len) > (unsigned long )tx_pkt->limit) {
      {
#line 275
      hdhomerun_debug_printf(cs->dbg, "hdhomerun_control_get_set: request too long\n");
      }
#line 276
      return (-1);
    }
    {
#line 278
    hdhomerun_pkt_write_u8(tx_pkt, (uint8_t )4);
#line 279
    hdhomerun_pkt_write_var_length(tx_pkt, (size_t )value_len);
#line 280
    hdhomerun_pkt_write_mem(tx_pkt, (void const   *)value, (size_t )value_len);
    }
  }
#line 283
  if (lockkey != 0U) {
#line 284
    if ((unsigned long )(tx_pkt->end + 6) > (unsigned long )tx_pkt->limit) {
      {
#line 285
      hdhomerun_debug_printf(cs->dbg, "hdhomerun_control_get_set: request too long\n");
      }
#line 286
      return (-1);
    }
    {
#line 288
    hdhomerun_pkt_write_u8(tx_pkt, (uint8_t )21);
#line 289
    hdhomerun_pkt_write_var_length(tx_pkt, (size_t )4);
#line 290
    hdhomerun_pkt_write_u32(tx_pkt, lockkey);
    }
  }
  {
#line 294
  tmp___1 = hdhomerun_control_send_recv_internal(cs, tx_pkt, rx_pkt, (uint16_t )4,
                                                 (uint64_t )2500);
  }
#line 294
  if (tmp___1 < 0) {
    {
#line 295
    hdhomerun_debug_printf(cs->dbg, "hdhomerun_control_get_set: send/recv error\n");
    }
#line 296
    return (-1);
  }
  {
#line 300
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 303
    tmp___2 = hdhomerun_pkt_read_tlv(rx_pkt, & tag, & len);
#line 303
    next = tmp___2;
    }
#line 304
    if (! next) {
#line 305
      goto while_break;
    }
    {
#line 309
    if ((int )tag == 4) {
#line 309
      goto case_4;
    }
#line 319
    if ((int )tag == 5) {
#line 319
      goto case_5;
    }
#line 308
    goto switch_break;
    case_4: /* CIL Label */ 
#line 310
    if (pvalue) {
#line 311
      *pvalue = (char *)rx_pkt->pos;
#line 312
      *(rx_pkt->pos + len) = (uint8_t )0;
    }
#line 314
    if (perror___0) {
#line 315
      *perror___0 = (char *)((void *)0);
    }
#line 317
    return (1);
    case_5: /* CIL Label */ 
    {
#line 320
    *(rx_pkt->pos + len) = (uint8_t )0;
#line 321
    hdhomerun_debug_printf(cs->dbg, "hdhomerun_control_get_set: %s\n", rx_pkt->pos);
    }
#line 323
    if (pvalue) {
#line 324
      *pvalue = (char *)((void *)0);
    }
#line 326
    if (perror___0) {
#line 327
      *perror___0 = (char *)rx_pkt->pos;
    }
#line 330
    return (0);
    switch_break: /* CIL Label */ ;
    }
#line 333
    rx_pkt->pos = next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 336
  hdhomerun_debug_printf(cs->dbg, "hdhomerun_control_get_set: missing response tags\n");
  }
#line 337
  return (-1);
}
}
#line 340 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_control.c"
int hdhomerun_control_get(struct hdhomerun_control_sock_t *cs , char const   *name ,
                          char **pvalue , char **perror___0 ) 
{ 
  int tmp ;

  {
  {
#line 342
  tmp = hdhomerun_control_get_set(cs, name, (char const   *)((void *)0), (uint32_t )0,
                                  pvalue, perror___0);
  }
#line 342
  return (tmp);
}
}
#line 345 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_control.c"
int hdhomerun_control_set(struct hdhomerun_control_sock_t *cs , char const   *name ,
                          char const   *value , char **pvalue , char **perror___0 ) 
{ 
  int tmp ;

  {
  {
#line 347
  tmp = hdhomerun_control_get_set(cs, name, value, (uint32_t )0, pvalue, perror___0);
  }
#line 347
  return (tmp);
}
}
#line 350 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_control.c"
int hdhomerun_control_set_with_lockkey(struct hdhomerun_control_sock_t *cs , char const   *name ,
                                       char const   *value , uint32_t lockkey , char **pvalue ,
                                       char **perror___0 ) 
{ 
  int tmp ;

  {
  {
#line 352
  tmp = hdhomerun_control_get_set(cs, name, value, lockkey, pvalue, perror___0);
  }
#line 352
  return (tmp);
}
}
#line 355 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_control.c"
int hdhomerun_control_upgrade(struct hdhomerun_control_sock_t *cs , FILE *upgrade_file ) 
{ 
  struct hdhomerun_pkt_t *tx_pkt ;
  struct hdhomerun_pkt_t *rx_pkt ;
  bool_t upload_delay ;
  uint32_t sequence ;
  char *version_str ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  uint8_t data[1024] ;
  size_t length ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  uint8_t tag ;
  size_t len ;
  uint8_t *next ;
  uint8_t *tmp___4 ;

  {
  {
#line 357
  tx_pkt = & cs->tx_pkt;
#line 358
  rx_pkt = & cs->rx_pkt;
#line 359
  upload_delay = 0;
#line 360
  sequence = (uint32_t )0;
#line 364
  tmp = hdhomerun_control_get(cs, "/sys/version", & version_str, (char **)((void *)0));
#line 364
  ret = tmp;
  }
#line 365
  if (ret > 0) {
    {
#line 366
    tmp___0 = strcmp((char const   *)version_str, "20120704beta1");
#line 366
    upload_delay = tmp___0 == 0;
    }
  }
  {
#line 370
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 372
    tmp___1 = fread((void */* __restrict  */)(data), (size_t )1, (size_t )1024, (FILE */* __restrict  */)upgrade_file);
#line 372
    length = tmp___1;
    }
#line 373
    if (length == 0UL) {
#line 374
      goto while_break;
    }
    {
#line 377
    hdhomerun_pkt_reset(tx_pkt);
#line 378
    hdhomerun_pkt_write_u32(tx_pkt, sequence);
#line 379
    hdhomerun_pkt_write_mem(tx_pkt, (void const   *)(data), length);
#line 381
    tmp___2 = hdhomerun_control_send_recv_internal(cs, tx_pkt, (struct hdhomerun_pkt_t *)((void *)0),
                                                   (uint16_t )6, (uint64_t )0);
    }
#line 381
    if (tmp___2 < 0) {
      {
#line 382
      hdhomerun_debug_printf(cs->dbg, "hdhomerun_control_upgrade: send/recv failed\n");
      }
#line 383
      return (-1);
    }
#line 386
    sequence += (uint32_t )length;
#line 388
    if (upload_delay) {
      {
#line 389
      msleep_approx((uint64_t )25);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 393
  if (sequence == 0U) {
    {
#line 395
    hdhomerun_debug_printf(cs->dbg, "hdhomerun_control_upgrade: zero length file\n");
    }
#line 396
    return (0);
  }
  {
#line 400
  hdhomerun_pkt_reset(tx_pkt);
#line 401
  hdhomerun_pkt_write_u32(tx_pkt, 4294967295U);
#line 403
  tmp___3 = hdhomerun_control_send_recv_internal(cs, tx_pkt, rx_pkt, (uint16_t )6,
                                                 (uint64_t )20000);
  }
#line 403
  if (tmp___3 < 0) {
    {
#line 404
    hdhomerun_debug_printf(cs->dbg, "hdhomerun_control_upgrade: send/recv failed\n");
    }
#line 405
    return (-1);
  }
  {
#line 409
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 412
    tmp___4 = hdhomerun_pkt_read_tlv(rx_pkt, & tag, & len);
#line 412
    next = tmp___4;
    }
#line 413
    if (! next) {
#line 414
      goto while_break___0;
    }
    {
#line 418
    if ((int )tag == 5) {
#line 418
      goto case_5;
    }
#line 423
    goto switch_default;
    case_5: /* CIL Label */ 
    {
#line 419
    *(rx_pkt->pos + len) = (uint8_t )0;
#line 420
    hdhomerun_debug_printf(cs->dbg, "hdhomerun_control_upgrade: %s\n", (char *)rx_pkt->pos);
    }
#line 421
    return (0);
    switch_default: /* CIL Label */ 
#line 424
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 427
    rx_pkt->pos = next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 430
  return (1);
}
}
#line 147 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_debug.h"
bool_t hdhomerun_debug_enabled(struct hdhomerun_debug_t *dbg ) ;
#line 51 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_video.h"
struct hdhomerun_video_sock_t *hdhomerun_video_create(uint16_t listen_port , bool_t allow_port_reuse ,
                                                      size_t buffer_size , struct hdhomerun_debug_t *dbg ) ;
#line 52
void hdhomerun_video_destroy(struct hdhomerun_video_sock_t *vs ) ;
#line 59
uint16_t hdhomerun_video_get_local_port(struct hdhomerun_video_sock_t *vs ) ;
#line 64
int hdhomerun_video_join_multicast_group(struct hdhomerun_video_sock_t *vs , uint32_t multicast_ip ,
                                         uint32_t local_ip ) ;
#line 65
void hdhomerun_video_leave_multicast_group(struct hdhomerun_video_sock_t *vs , uint32_t multicast_ip ,
                                           uint32_t local_ip ) ;
#line 84
uint8_t *hdhomerun_video_recv(struct hdhomerun_video_sock_t *vs , size_t max_size ,
                              size_t *pactual_size ) ;
#line 89
void hdhomerun_video_flush(struct hdhomerun_video_sock_t *vs ) ;
#line 94
void hdhomerun_video_debug_print_stats(struct hdhomerun_video_sock_t *vs ) ;
#line 95
void hdhomerun_video_get_stats(struct hdhomerun_video_sock_t *vs , struct hdhomerun_video_stats_t *stats ) ;
#line 66 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.h"
struct hdhomerun_device_t *hdhomerun_device_create(uint32_t device_id , uint32_t device_ip ,
                                                   unsigned int tuner , struct hdhomerun_debug_t *dbg ) ;
#line 75
uint32_t hdhomerun_device_get_device_ip(struct hdhomerun_device_t *hd___0 ) ;
#line 76
uint32_t hdhomerun_device_get_device_id_requested(struct hdhomerun_device_t *hd___0 ) ;
#line 77
uint32_t hdhomerun_device_get_device_ip_requested(struct hdhomerun_device_t *hd___0 ) ;
#line 80
int hdhomerun_device_set_device(struct hdhomerun_device_t *hd___0 , uint32_t device_id ,
                                uint32_t device_ip ) ;
#line 81
int hdhomerun_device_set_tuner(struct hdhomerun_device_t *hd___0 , unsigned int tuner ) ;
#line 82
int hdhomerun_device_set_tuner_from_str(struct hdhomerun_device_t *hd___0 , char const   *tuner_str ) ;
#line 105
int hdhomerun_device_get_tuner_vstatus(struct hdhomerun_device_t *hd___0 , char **pvstatus_str ,
                                       struct hdhomerun_tuner_vstatus_t *vstatus ) ;
#line 107
int hdhomerun_device_get_tuner_channel(struct hdhomerun_device_t *hd___0 , char **pchannel ) ;
#line 108
int hdhomerun_device_get_tuner_vchannel(struct hdhomerun_device_t *hd___0 , char **pvchannel ) ;
#line 109
int hdhomerun_device_get_tuner_channelmap(struct hdhomerun_device_t *hd___0 , char **pchannelmap ) ;
#line 110
int hdhomerun_device_get_tuner_filter(struct hdhomerun_device_t *hd___0 , char **pfilter ) ;
#line 111
int hdhomerun_device_get_tuner_program(struct hdhomerun_device_t *hd___0 , char **pprogram ) ;
#line 113
int hdhomerun_device_get_tuner_plotsample(struct hdhomerun_device_t *hd___0 , struct hdhomerun_plotsample_t **psamples ,
                                          size_t *pcount ) ;
#line 114
int hdhomerun_device_get_tuner_lockkey_owner(struct hdhomerun_device_t *hd___0 , char **powner ) ;
#line 115
int hdhomerun_device_get_oob_status(struct hdhomerun_device_t *hd___0 , char **pstatus_str ,
                                    struct hdhomerun_tuner_status_t *status ) ;
#line 116
int hdhomerun_device_get_oob_plotsample(struct hdhomerun_device_t *hd___0 , struct hdhomerun_plotsample_t **psamples ,
                                        size_t *pcount ) ;
#line 117
int hdhomerun_device_get_ir_target(struct hdhomerun_device_t *hd___0 , char **ptarget ) ;
#line 118
int hdhomerun_device_get_lineup_location(struct hdhomerun_device_t *hd___0 , char **plocation ) ;
#line 119
int hdhomerun_device_get_version(struct hdhomerun_device_t *hd___0 , char **pversion_str ,
                                 uint32_t *pversion_num ) ;
#line 120
int hdhomerun_device_get_supported(struct hdhomerun_device_t *hd___0 , char *prefix ,
                                   char **pstr ) ;
#line 122
uint32_t hdhomerun_device_get_tuner_status_ss_color(struct hdhomerun_tuner_status_t *status ) ;
#line 123
uint32_t hdhomerun_device_get_tuner_status_snq_color(struct hdhomerun_tuner_status_t *status ) ;
#line 124
uint32_t hdhomerun_device_get_tuner_status_seq_color(struct hdhomerun_tuner_status_t *status ) ;
#line 138
int hdhomerun_device_set_tuner_vchannel(struct hdhomerun_device_t *hd___0 , char const   *vchannel ) ;
#line 139
int hdhomerun_device_set_tuner_channelmap(struct hdhomerun_device_t *hd___0 , char const   *channelmap ) ;
#line 140
int hdhomerun_device_set_tuner_filter(struct hdhomerun_device_t *hd___0 , char const   *filter ) ;
#line 141
int hdhomerun_device_set_tuner_filter_by_array(struct hdhomerun_device_t *hd___0 ,
                                               unsigned char *filter_array ) ;
#line 142
int hdhomerun_device_set_tuner_program(struct hdhomerun_device_t *hd___0 , char const   *program ) ;
#line 143
int hdhomerun_device_set_tuner_target(struct hdhomerun_device_t *hd___0 , char const   *target ) ;
#line 144
int hdhomerun_device_set_ir_target(struct hdhomerun_device_t *hd___0 , char const   *target ) ;
#line 145
int hdhomerun_device_set_lineup_location(struct hdhomerun_device_t *hd___0 , char const   *location ) ;
#line 146
int hdhomerun_device_set_sys_dvbc_modulation(struct hdhomerun_device_t *hd___0 , char const   *modulation_list ) ;
#line 165
int hdhomerun_device_get_var(struct hdhomerun_device_t *hd___0 , char const   *name ,
                             char **pvalue , char **perror___0 ) ;
#line 166
int hdhomerun_device_set_var(struct hdhomerun_device_t *hd___0 , char const   *name ,
                             char const   *value , char **pvalue , char **perror___0 ) ;
#line 182
int hdhomerun_device_tuner_lockkey_release(struct hdhomerun_device_t *hd___0 ) ;
#line 188
void hdhomerun_device_tuner_lockkey_use_value(struct hdhomerun_device_t *hd___0 ,
                                              uint32_t lockkey ) ;
#line 218
int hdhomerun_device_stream_start(struct hdhomerun_device_t *hd___0 ) ;
#line 219
uint8_t *hdhomerun_device_stream_recv(struct hdhomerun_device_t *hd___0 , size_t max_size ,
                                      size_t *pactual_size ) ;
#line 220
void hdhomerun_device_stream_flush(struct hdhomerun_device_t *hd___0 ) ;
#line 221
void hdhomerun_device_stream_stop(struct hdhomerun_device_t *hd___0 ) ;
#line 226
int hdhomerun_device_channelscan_init(struct hdhomerun_device_t *hd___0 , char const   *channelmap ) ;
#line 227
int hdhomerun_device_channelscan_advance(struct hdhomerun_device_t *hd___0 , struct hdhomerun_channelscan_result_t *result___1 ) ;
#line 228
int hdhomerun_device_channelscan_detect(struct hdhomerun_device_t *hd___0 , struct hdhomerun_channelscan_result_t *result___1 ) ;
#line 229
uint8_t hdhomerun_device_channelscan_get_progress(struct hdhomerun_device_t *hd___0 ) ;
#line 240
int hdhomerun_device_upgrade(struct hdhomerun_device_t *hd___0 , FILE *upgrade_file ) ;
#line 245
struct hdhomerun_control_sock_t *hdhomerun_device_get_control_sock(struct hdhomerun_device_t *hd___0 ) ;
#line 246
struct hdhomerun_video_sock_t *hdhomerun_device_get_video_sock(struct hdhomerun_device_t *hd___0 ) ;
#line 251
void hdhomerun_device_debug_print_video_stats(struct hdhomerun_device_t *hd___0 ) ;
#line 252
void hdhomerun_device_get_video_stats(struct hdhomerun_device_t *hd___0 , struct hdhomerun_video_stats_t *stats ) ;
#line 37 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
static int hdhomerun_device_set_device_normal(struct hdhomerun_device_t *hd___0 ,
                                              uint32_t device_id , uint32_t device_ip ) 
{ 


  {
#line 39
  if (! hd___0->cs) {
    {
#line 40
    hd___0->cs = hdhomerun_control_create((uint32_t )0, (uint32_t )0, hd___0->dbg);
    }
#line 41
    if (! hd___0->cs) {
      {
#line 42
      hdhomerun_debug_printf(hd___0->dbg, "hdhomerun_device_set_device: failed to create control object\n");
      }
#line 43
      return (-1);
    }
  }
  {
#line 47
  hdhomerun_control_set_device(hd___0->cs, device_id, device_ip);
  }
#line 49
  if (device_id == 0U) {
    {
#line 50
    device_id = hdhomerun_control_get_device_id(hd___0->cs);
    }
  } else
#line 49
  if (device_id == 4294967295U) {
    {
#line 50
    device_id = hdhomerun_control_get_device_id(hd___0->cs);
    }
  }
  {
#line 53
  hd___0->multicast_ip = (uint32_t )0;
#line 54
  hd___0->multicast_port = (uint16_t )0;
#line 55
  hd___0->device_id = device_id;
#line 56
  hd___0->tuner = 0U;
#line 57
  hd___0->lockkey = (uint32_t )0;
#line 59
  hdhomerun_sprintf(hd___0->name, hd___0->name + sizeof(hd___0->name), "%08X-%u",
                    hd___0->device_id, hd___0->tuner);
#line 60
  hdhomerun_sprintf(hd___0->model, hd___0->model + sizeof(hd___0->model), "");
  }
#line 62
  return (1);
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
static int hdhomerun_device_set_device_multicast(struct hdhomerun_device_t *hd___0 ,
                                                 uint32_t multicast_ip ) 
{ 
  unsigned int ip ;

  {
#line 67
  if (hd___0->cs) {
    {
#line 68
    hdhomerun_control_destroy(hd___0->cs);
#line 69
    hd___0->cs = (struct hdhomerun_control_sock_t *)((void *)0);
    }
  }
  {
#line 72
  hd___0->multicast_ip = multicast_ip;
#line 73
  hd___0->multicast_port = (uint16_t )0;
#line 74
  hd___0->device_id = (uint32_t )0;
#line 75
  hd___0->tuner = 0U;
#line 76
  hd___0->lockkey = (uint32_t )0;
#line 78
  ip = multicast_ip;
#line 79
  hdhomerun_sprintf(hd___0->name, hd___0->name + sizeof(hd___0->name), "%u.%u.%u.%u",
                    (ip >> 24) & 255U, (ip >> 16) & 255U, (ip >> 8) & 255U, ip & 255U);
#line 80
  hdhomerun_sprintf(hd___0->model, hd___0->model + sizeof(hd___0->model), "multicast");
  }
#line 82
  return (1);
}
}
#line 85 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
int hdhomerun_device_set_device(struct hdhomerun_device_t *hd___0 , uint32_t device_id ,
                                uint32_t device_ip ) 
{ 
  int tmp ;
  bool_t tmp___0 ;
  int tmp___1 ;

  {
#line 87
  if (device_id == 0U) {
#line 87
    if (device_ip == 0U) {
      {
#line 88
      hdhomerun_debug_printf(hd___0->dbg, "hdhomerun_device_set_device: device not specified\n");
      }
#line 89
      return (-1);
    }
  }
  {
#line 92
  tmp___0 = hdhomerun_discover_is_ip_multicast(device_ip);
  }
#line 92
  if (tmp___0) {
    {
#line 93
    tmp = hdhomerun_device_set_device_multicast(hd___0, device_ip);
    }
#line 93
    return (tmp);
  }
  {
#line 96
  tmp___1 = hdhomerun_device_set_device_normal(hd___0, device_id, device_ip);
  }
#line 96
  return (tmp___1);
}
}
#line 99 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
int hdhomerun_device_set_tuner(struct hdhomerun_device_t *hd___0 , unsigned int tuner ) 
{ 


  {
#line 101
  if (hd___0->multicast_ip != 0U) {
#line 102
    if (tuner != 0U) {
      {
#line 103
      hdhomerun_debug_printf(hd___0->dbg, "hdhomerun_device_set_tuner: tuner cannot be specified in multicast mode\n");
      }
#line 104
      return (-1);
    }
#line 107
    return (1);
  }
  {
#line 110
  hd___0->tuner = tuner;
#line 111
  hdhomerun_sprintf(hd___0->name, hd___0->name + sizeof(hd___0->name), "%08X-%u",
                    hd___0->device_id, hd___0->tuner);
  }
#line 113
  return (1);
}
}
#line 116 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
struct hdhomerun_device_t *hdhomerun_device_create(uint32_t device_id , uint32_t device_ip ,
                                                   unsigned int tuner , struct hdhomerun_debug_t *dbg ) 
{ 
  struct hdhomerun_device_t *hd___0 ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 118
  tmp = calloc((size_t )1, sizeof(struct hdhomerun_device_t ));
#line 118
  hd___0 = (struct hdhomerun_device_t *)tmp;
  }
#line 119
  if (! hd___0) {
    {
#line 120
    hdhomerun_debug_printf(dbg, "hdhomerun_device_create: failed to allocate device object\n");
    }
#line 121
    return ((struct hdhomerun_device_t *)((void *)0));
  }
#line 124
  hd___0->dbg = dbg;
#line 126
  if (device_id == 0U) {
#line 126
    if (device_ip == 0U) {
#line 126
      if (tuner == 0U) {
#line 127
        return (hd___0);
      }
    }
  }
  {
#line 130
  tmp___0 = hdhomerun_device_set_device(hd___0, device_id, device_ip);
  }
#line 130
  if (tmp___0 <= 0) {
    {
#line 131
    free((void *)hd___0);
    }
#line 132
    return ((struct hdhomerun_device_t *)((void *)0));
  }
  {
#line 134
  tmp___1 = hdhomerun_device_set_tuner(hd___0, tuner);
  }
#line 134
  if (tmp___1 <= 0) {
    {
#line 135
    free((void *)hd___0);
    }
#line 136
    return ((struct hdhomerun_device_t *)((void *)0));
  }
#line 139
  return (hd___0);
}
}
#line 142 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
void hdhomerun_device_destroy(struct hdhomerun_device_t *hd___0 ) 
{ 


  {
#line 144
  if (hd___0->scan) {
    {
#line 145
    channelscan_destroy(hd___0->scan);
    }
  }
#line 148
  if (hd___0->vs) {
    {
#line 149
    hdhomerun_video_destroy(hd___0->vs);
    }
  }
#line 152
  if (hd___0->cs) {
    {
#line 153
    hdhomerun_control_destroy(hd___0->cs);
    }
  }
  {
#line 156
  free((void *)hd___0);
  }
#line 157
  return;
}
}
#line 159 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
static bool_t is_hex_char(char c ) 
{ 


  {
#line 161
  if ((int )c >= 48) {
#line 161
    if ((int )c <= 57) {
#line 162
      return (1);
    }
  }
#line 164
  if ((int )c >= 65) {
#line 164
    if ((int )c <= 70) {
#line 165
      return (1);
    }
  }
#line 167
  if ((int )c >= 97) {
#line 167
    if ((int )c <= 102) {
#line 168
      return (1);
    }
  }
#line 170
  return (0);
}
}
#line 173 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
static struct hdhomerun_device_t *hdhomerun_device_create_from_str_device_id(char const   *device_str ,
                                                                             struct hdhomerun_debug_t *dbg ) 
{ 
  int i ;
  char const   *ptr ;
  char const   *tmp ;
  bool_t tmp___0 ;
  unsigned int device_id ;
  int tmp___1 ;
  struct hdhomerun_device_t *tmp___2 ;
  unsigned int device_id___0 ;
  unsigned int tuner ;
  int tmp___3 ;
  struct hdhomerun_device_t *tmp___4 ;

  {
#line 176
  ptr = device_str;
#line 177
  i = 0;
  {
#line 177
  while (1) {
    while_continue: /* CIL Label */ ;
#line 177
    if (! (i < 8)) {
#line 177
      goto while_break;
    }
    {
#line 178
    tmp = ptr;
#line 178
    ptr ++;
#line 178
    tmp___0 = is_hex_char((char )*tmp);
    }
#line 178
    if (! tmp___0) {
#line 179
      return ((struct hdhomerun_device_t *)((void *)0));
    }
#line 177
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 183
  if ((int const   )*ptr == 0) {
    {
#line 185
    tmp___1 = sscanf((char const   */* __restrict  */)device_str, (char const   */* __restrict  */)"%x",
                     & device_id);
    }
#line 185
    if (tmp___1 != 1) {
#line 186
      return ((struct hdhomerun_device_t *)((void *)0));
    }
    {
#line 188
    tmp___2 = hdhomerun_device_create(device_id, (uint32_t )0, 0U, dbg);
    }
#line 188
    return (tmp___2);
  }
#line 191
  if ((int const   )*ptr == 45) {
    {
#line 194
    tmp___3 = sscanf((char const   */* __restrict  */)device_str, (char const   */* __restrict  */)"%x-%u",
                     & device_id___0, & tuner);
    }
#line 194
    if (tmp___3 != 2) {
#line 195
      return ((struct hdhomerun_device_t *)((void *)0));
    }
    {
#line 197
    tmp___4 = hdhomerun_device_create(device_id___0, (uint32_t )0, tuner, dbg);
    }
#line 197
    return (tmp___4);
  }
#line 200
  return ((struct hdhomerun_device_t *)((void *)0));
}
}
#line 203 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
static struct hdhomerun_device_t *hdhomerun_device_create_from_str_ip_result(unsigned int *a ,
                                                                             unsigned int port ,
                                                                             unsigned int tuner ,
                                                                             struct hdhomerun_debug_t *dbg ) 
{ 
  uint32_t device_ip ;
  struct hdhomerun_device_t *hd___0 ;
  struct hdhomerun_device_t *tmp ;

  {
  {
#line 205
  device_ip = (((*(a + 0) << 24) | (*(a + 1) << 16)) | (*(a + 2) << 8)) | *(a + 3);
#line 206
  tmp = hdhomerun_device_create(4294967295U, device_ip, tuner, dbg);
#line 206
  hd___0 = tmp;
  }
#line 207
  if (! hd___0) {
#line 208
    return ((struct hdhomerun_device_t *)((void *)0));
  }
#line 211
  if (hd___0->multicast_ip != 0U) {
#line 212
    hd___0->multicast_port = (uint16_t )port;
  }
#line 215
  return (hd___0);
}
}
#line 218 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
static struct hdhomerun_device_t *hdhomerun_device_create_from_str_ip(char const   *device_str ,
                                                                      struct hdhomerun_debug_t *dbg ) 
{ 
  unsigned int a[4] ;
  unsigned int port ;
  unsigned int tuner ;
  struct hdhomerun_device_t *tmp ;
  int tmp___0 ;
  struct hdhomerun_device_t *tmp___1 ;
  int tmp___2 ;
  struct hdhomerun_device_t *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 221
  port = 0U;
#line 222
  tuner = 0U;
#line 224
  tmp___0 = sscanf((char const   */* __restrict  */)device_str, (char const   */* __restrict  */)"%u.%u.%u.%u:%u",
                   & a[0], & a[1], & a[2], & a[3], & port);
  }
#line 224
  if (tmp___0 == 5) {
    {
#line 225
    tmp = hdhomerun_device_create_from_str_ip_result((unsigned int *)(a), port, tuner,
                                                     dbg);
    }
#line 225
    return (tmp);
  }
  {
#line 227
  tmp___2 = sscanf((char const   */* __restrict  */)device_str, (char const   */* __restrict  */)"%u.%u.%u.%u-%u",
                   & a[0], & a[1], & a[2], & a[3], & tuner);
  }
#line 227
  if (tmp___2 == 5) {
    {
#line 228
    tmp___1 = hdhomerun_device_create_from_str_ip_result((unsigned int *)(a), port,
                                                         tuner, dbg);
    }
#line 228
    return (tmp___1);
  }
  {
#line 230
  tmp___4 = sscanf((char const   */* __restrict  */)device_str, (char const   */* __restrict  */)"%u.%u.%u.%u",
                   & a[0], & a[1], & a[2], & a[3]);
  }
#line 230
  if (tmp___4 == 4) {
    {
#line 231
    tmp___3 = hdhomerun_device_create_from_str_ip_result((unsigned int *)(a), port,
                                                         tuner, dbg);
    }
#line 231
    return (tmp___3);
  }
#line 234
  return ((struct hdhomerun_device_t *)((void *)0));
}
}
#line 237 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
static struct hdhomerun_device_t *hdhomerun_device_create_from_str_dns(char const   *device_str ,
                                                                       struct hdhomerun_debug_t *dbg ) 
{ 
  struct addrinfo hints ;
  struct addrinfo *sock_info ;
  int tmp ;
  struct sockaddr_in *sock_addr ;
  uint32_t device_ip ;
  uint32_t tmp___0 ;
  struct hdhomerun_device_t *tmp___1 ;

  {
  {
#line 243
  memset((void *)(& hints), 0, sizeof(hints));
#line 244
  hints.ai_family = 2;
#line 245
  hints.ai_socktype = 1;
#line 246
  hints.ai_protocol = 6;
#line 249
  tmp = getaddrinfo((char const   */* __restrict  */)device_str, (char const   */* __restrict  */)"65001",
                    (struct addrinfo  const  */* __restrict  */)(& hints), (struct addrinfo **/* __restrict  */)(& sock_info));
  }
#line 249
  if (tmp != 0) {
#line 250
    return ((struct hdhomerun_device_t *)((void *)0));
  }
  {
#line 253
  sock_addr = (struct sockaddr_in *)sock_info->ai_addr;
#line 254
  tmp___0 = ntohl(sock_addr->sin_addr.s_addr);
#line 254
  device_ip = tmp___0;
#line 255
  freeaddrinfo(sock_info);
  }
#line 257
  if (device_ip == 0U) {
#line 258
    return ((struct hdhomerun_device_t *)((void *)0));
  }
  {
#line 261
  tmp___1 = hdhomerun_device_create(4294967295U, device_ip, 0U, dbg);
  }
#line 261
  return (tmp___1);
}
}
#line 265 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
struct hdhomerun_device_t *hdhomerun_device_create_from_str(char const   *device_str ,
                                                            struct hdhomerun_debug_t *dbg ) 
{ 
  struct hdhomerun_device_t *device ;
  struct hdhomerun_device_t *tmp ;

  {
  {
#line 267
  tmp = hdhomerun_device_create_from_str_device_id(device_str, dbg);
#line 267
  device = tmp;
  }
#line 268
  if (device) {
#line 269
    return (device);
  }
  {
#line 272
  device = hdhomerun_device_create_from_str_ip(device_str, dbg);
  }
#line 273
  if (device) {
#line 274
    return (device);
  }
  {
#line 277
  device = hdhomerun_device_create_from_str_dns(device_str, dbg);
  }
#line 278
  if (device) {
#line 279
    return (device);
  }
#line 282
  return ((struct hdhomerun_device_t *)((void *)0));
}
}
#line 285 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
int hdhomerun_device_set_tuner_from_str(struct hdhomerun_device_t *hd___0 , char const   *tuner_str ) 
{ 
  unsigned int tuner ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 288
  tmp = sscanf((char const   */* __restrict  */)tuner_str, (char const   */* __restrict  */)"%u",
               & tuner);
  }
#line 288
  if (tmp == 1) {
    {
#line 289
    hdhomerun_device_set_tuner(hd___0, tuner);
    }
#line 290
    return (1);
  }
  {
#line 292
  tmp___0 = sscanf((char const   */* __restrict  */)tuner_str, (char const   */* __restrict  */)"/tuner%u",
                   & tuner);
  }
#line 292
  if (tmp___0 == 1) {
    {
#line 293
    hdhomerun_device_set_tuner(hd___0, tuner);
    }
#line 294
    return (1);
  }
#line 297
  return (-1);
}
}
#line 300 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
char const   *hdhomerun_device_get_name(struct hdhomerun_device_t *hd___0 ) 
{ 


  {
#line 302
  return ((char const   *)(hd___0->name));
}
}
#line 305 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
uint32_t hdhomerun_device_get_device_id(struct hdhomerun_device_t *hd___0 ) 
{ 


  {
#line 307
  return (hd___0->device_id);
}
}
#line 310 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
uint32_t hdhomerun_device_get_device_ip(struct hdhomerun_device_t *hd___0 ) 
{ 
  uint32_t tmp ;

  {
#line 312
  if (hd___0->multicast_ip != 0U) {
#line 313
    return (hd___0->multicast_ip);
  }
#line 315
  if (hd___0->cs) {
    {
#line 316
    tmp = hdhomerun_control_get_device_ip(hd___0->cs);
    }
#line 316
    return (tmp);
  }
#line 319
  return ((uint32_t )0);
}
}
#line 322 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
uint32_t hdhomerun_device_get_device_id_requested(struct hdhomerun_device_t *hd___0 ) 
{ 
  uint32_t tmp ;

  {
#line 324
  if (hd___0->multicast_ip != 0U) {
#line 325
    return ((uint32_t )0);
  }
#line 327
  if (hd___0->cs) {
    {
#line 328
    tmp = hdhomerun_control_get_device_id_requested(hd___0->cs);
    }
#line 328
    return (tmp);
  }
#line 331
  return ((uint32_t )0);
}
}
#line 334 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
uint32_t hdhomerun_device_get_device_ip_requested(struct hdhomerun_device_t *hd___0 ) 
{ 
  uint32_t tmp ;

  {
#line 336
  if (hd___0->multicast_ip != 0U) {
#line 337
    return (hd___0->multicast_ip);
  }
#line 339
  if (hd___0->cs) {
    {
#line 340
    tmp = hdhomerun_control_get_device_ip_requested(hd___0->cs);
    }
#line 340
    return (tmp);
  }
#line 343
  return ((uint32_t )0);
}
}
#line 346 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
unsigned int hdhomerun_device_get_tuner(struct hdhomerun_device_t *hd___0 ) 
{ 


  {
#line 348
  return (hd___0->tuner);
}
}
#line 351 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
struct hdhomerun_control_sock_t *hdhomerun_device_get_control_sock(struct hdhomerun_device_t *hd___0 ) 
{ 


  {
#line 353
  return (hd___0->cs);
}
}
#line 356 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
struct hdhomerun_video_sock_t *hdhomerun_device_get_video_sock(struct hdhomerun_device_t *hd___0 ) 
{ 
  bool_t allow_port_reuse ;

  {
#line 358
  if (hd___0->vs) {
#line 359
    return (hd___0->vs);
  }
  {
#line 362
  allow_port_reuse = (int )hd___0->multicast_port != 0;
#line 364
  hd___0->vs = hdhomerun_video_create(hd___0->multicast_port, allow_port_reuse, (size_t )5000000,
                                      hd___0->dbg);
  }
#line 365
  if (! hd___0->vs) {
    {
#line 366
    hdhomerun_debug_printf(hd___0->dbg, "hdhomerun_device_get_video_sock: failed to create video object\n");
    }
#line 367
    return ((struct hdhomerun_video_sock_t *)((void *)0));
  }
#line 370
  return (hd___0->vs);
}
}
#line 373 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
uint32_t hdhomerun_device_get_local_machine_addr(struct hdhomerun_device_t *hd___0 ) 
{ 
  uint32_t tmp ;

  {
#line 375
  if (hd___0->cs) {
    {
#line 376
    tmp = hdhomerun_control_get_local_addr(hd___0->cs);
    }
#line 376
    return (tmp);
  }
#line 379
  return ((uint32_t )0);
}
}
#line 382 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
static uint32_t hdhomerun_device_get_status_parse(char const   *status_str , char const   *tag ) 
{ 
  char const   *ptr ;
  char *tmp ;
  unsigned int value ;
  size_t tmp___0 ;

  {
  {
#line 384
  tmp = strstr(status_str, tag);
#line 384
  ptr = (char const   *)tmp;
  }
#line 385
  if (! ptr) {
#line 386
    return ((uint32_t )0);
  }
  {
#line 389
  value = 0U;
#line 390
  tmp___0 = strlen(tag);
#line 390
  sscanf((char const   */* __restrict  */)(ptr + tmp___0), (char const   */* __restrict  */)"%u",
         & value);
  }
#line 392
  return (value);
}
}
#line 395 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
static bool_t hdhomerun_device_get_tuner_status_lock_is_bcast(struct hdhomerun_tuner_status_t *status ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 397
  tmp = strcmp((char const   *)(status->lock_str), "8vsb");
  }
#line 397
  if (tmp == 0) {
#line 398
    return (1);
  }
  {
#line 400
  tmp___0 = strncmp((char const   *)(status->lock_str), "t8", (size_t )2);
  }
#line 400
  if (tmp___0 == 0) {
#line 401
    return (1);
  }
  {
#line 403
  tmp___1 = strncmp((char const   *)(status->lock_str), "t7", (size_t )2);
  }
#line 403
  if (tmp___1 == 0) {
#line 404
    return (1);
  }
  {
#line 406
  tmp___2 = strncmp((char const   *)(status->lock_str), "t6", (size_t )2);
  }
#line 406
  if (tmp___2 == 0) {
#line 407
    return (1);
  }
#line 410
  return (0);
}
}
#line 413 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
uint32_t hdhomerun_device_get_tuner_status_ss_color(struct hdhomerun_tuner_status_t *status ) 
{ 
  unsigned int ss_yellow_min ;
  unsigned int ss_green_min ;
  bool_t tmp ;

  {
#line 418
  if (! status->lock_supported) {
#line 419
    return (4294967295U);
  }
  {
#line 422
  tmp = hdhomerun_device_get_tuner_status_lock_is_bcast(status);
  }
#line 422
  if (tmp) {
#line 423
    ss_yellow_min = 50U;
#line 424
    ss_green_min = 75U;
  } else {
#line 426
    ss_yellow_min = 80U;
#line 427
    ss_green_min = 90U;
  }
#line 430
  if (status->signal_strength >= ss_green_min) {
#line 431
    return (4278239232U);
  }
#line 433
  if (status->signal_strength >= ss_yellow_min) {
#line 434
    return (4294967040U);
  }
#line 437
  return (4294901760U);
}
}
#line 440 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
uint32_t hdhomerun_device_get_tuner_status_snq_color(struct hdhomerun_tuner_status_t *status ) 
{ 


  {
#line 442
  if (status->signal_to_noise_quality >= 70U) {
#line 443
    return (4278239232U);
  }
#line 445
  if (status->signal_to_noise_quality >= 50U) {
#line 446
    return (4294967040U);
  }
#line 449
  return (4294901760U);
}
}
#line 452 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
uint32_t hdhomerun_device_get_tuner_status_seq_color(struct hdhomerun_tuner_status_t *status ) 
{ 


  {
#line 454
  if (status->symbol_error_quality >= 100U) {
#line 455
    return (4278239232U);
  }
#line 458
  return (4294901760U);
}
}
#line 461 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
int hdhomerun_device_get_tuner_status(struct hdhomerun_device_t *hd___0 , char **pstatus_str ,
                                      struct hdhomerun_tuner_status_t *status ) 
{ 
  char name[32] ;
  char *status_str ;
  int ret ;
  int tmp ;
  char *channel ;
  char *tmp___0 ;
  char *lock___1 ;
  char *tmp___1 ;
  uint32_t tmp___2 ;
  uint32_t tmp___3 ;
  uint32_t tmp___4 ;
  int tmp___5 ;

  {
#line 463
  if (! hd___0->cs) {
    {
#line 464
    hdhomerun_debug_printf(hd___0->dbg, "hdhomerun_device_get_tuner_status: device not set\n");
    }
#line 465
    return (-1);
  }
  {
#line 468
  memset((void *)status, 0, sizeof(struct hdhomerun_tuner_status_t ));
#line 471
  hdhomerun_sprintf(name, name + sizeof(name), "/tuner%u/status", hd___0->tuner);
#line 474
  tmp = hdhomerun_control_get(hd___0->cs, (char const   *)(name), & status_str, (char **)((void *)0));
#line 474
  ret = tmp;
  }
#line 475
  if (ret <= 0) {
#line 476
    return (ret);
  }
#line 479
  if (pstatus_str) {
#line 480
    *pstatus_str = status_str;
  }
#line 483
  if (status) {
    {
#line 484
    tmp___0 = strstr((char const   *)status_str, "ch=");
#line 484
    channel = tmp___0;
    }
#line 485
    if (channel) {
      {
#line 486
      sscanf((char const   */* __restrict  */)(channel + 3), (char const   */* __restrict  */)"%31s",
             status->channel);
      }
    }
    {
#line 489
    tmp___1 = strstr((char const   *)status_str, "lock=");
#line 489
    lock___1 = tmp___1;
    }
#line 490
    if (lock___1) {
      {
#line 491
      sscanf((char const   */* __restrict  */)(lock___1 + 5), (char const   */* __restrict  */)"%31s",
             status->lock_str);
      }
    }
    {
#line 494
    tmp___2 = hdhomerun_device_get_status_parse((char const   *)status_str, "ss=");
#line 494
    status->signal_strength = tmp___2;
#line 495
    tmp___3 = hdhomerun_device_get_status_parse((char const   *)status_str, "snq=");
#line 495
    status->signal_to_noise_quality = tmp___3;
#line 496
    tmp___4 = hdhomerun_device_get_status_parse((char const   *)status_str, "seq=");
#line 496
    status->symbol_error_quality = tmp___4;
#line 497
    status->raw_bits_per_second = hdhomerun_device_get_status_parse((char const   *)status_str,
                                                                    "bps=");
#line 498
    status->packets_per_second = hdhomerun_device_get_status_parse((char const   *)status_str,
                                                                   "pps=");
#line 500
    status->signal_present = status->signal_strength >= 45U;
#line 502
    tmp___5 = strcmp((char const   *)(status->lock_str), "none");
    }
#line 502
    if (tmp___5 != 0) {
#line 503
      if ((int )status->lock_str[0] == 40) {
#line 504
        status->lock_unsupported = 1;
      } else {
#line 506
        status->lock_supported = 1;
      }
    }
  }
#line 511
  return (1);
}
}
#line 514 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
int hdhomerun_device_get_oob_status(struct hdhomerun_device_t *hd___0 , char **pstatus_str ,
                                    struct hdhomerun_tuner_status_t *status ) 
{ 
  char *status_str ;
  int ret ;
  int tmp ;
  char *channel ;
  char *tmp___0 ;
  char *lock___1 ;
  char *tmp___1 ;
  uint32_t tmp___2 ;
  uint32_t tmp___3 ;
  int tmp___4 ;

  {
#line 516
  if (! hd___0->cs) {
    {
#line 517
    hdhomerun_debug_printf(hd___0->dbg, "hdhomerun_device_get_oob_status: device not set\n");
    }
#line 518
    return (-1);
  }
  {
#line 521
  memset((void *)status, 0, sizeof(struct hdhomerun_tuner_status_t ));
#line 524
  tmp = hdhomerun_control_get(hd___0->cs, "/oob/status", & status_str, (char **)((void *)0));
#line 524
  ret = tmp;
  }
#line 525
  if (ret <= 0) {
#line 526
    return (ret);
  }
#line 529
  if (pstatus_str) {
#line 530
    *pstatus_str = status_str;
  }
#line 533
  if (status) {
    {
#line 534
    tmp___0 = strstr((char const   *)status_str, "ch=");
#line 534
    channel = tmp___0;
    }
#line 535
    if (channel) {
      {
#line 536
      sscanf((char const   */* __restrict  */)(channel + 3), (char const   */* __restrict  */)"%31s",
             status->channel);
      }
    }
    {
#line 539
    tmp___1 = strstr((char const   *)status_str, "lock=");
#line 539
    lock___1 = tmp___1;
    }
#line 540
    if (lock___1) {
      {
#line 541
      sscanf((char const   */* __restrict  */)(lock___1 + 5), (char const   */* __restrict  */)"%31s",
             status->lock_str);
      }
    }
    {
#line 544
    tmp___2 = hdhomerun_device_get_status_parse((char const   *)status_str, "ss=");
#line 544
    status->signal_strength = tmp___2;
#line 545
    tmp___3 = hdhomerun_device_get_status_parse((char const   *)status_str, "snq=");
#line 545
    status->signal_to_noise_quality = tmp___3;
#line 546
    status->signal_present = status->signal_strength >= 45U;
#line 547
    tmp___4 = strcmp((char const   *)(status->lock_str), "none");
#line 547
    status->lock_supported = tmp___4 != 0;
    }
  }
#line 550
  return (1);
}
}
#line 553 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
int hdhomerun_device_get_tuner_vstatus(struct hdhomerun_device_t *hd___0 , char **pvstatus_str ,
                                       struct hdhomerun_tuner_vstatus_t *vstatus ) 
{ 
  char var_name[32] ;
  char *vstatus_str ;
  int ret ;
  int tmp ;
  char *vch ;
  char *tmp___0 ;
  char *name ;
  char *tmp___1 ;
  char *auth ;
  char *tmp___2 ;
  char *cci ;
  char *tmp___3 ;
  char *cgms ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 555
  if (! hd___0->cs) {
    {
#line 556
    hdhomerun_debug_printf(hd___0->dbg, "hdhomerun_device_get_tuner_vstatus: device not set\n");
    }
#line 557
    return (-1);
  }
  {
#line 560
  memset((void *)vstatus, 0, sizeof(struct hdhomerun_tuner_vstatus_t ));
#line 563
  hdhomerun_sprintf(var_name, var_name + sizeof(var_name), "/tuner%u/vstatus", hd___0->tuner);
#line 566
  tmp = hdhomerun_control_get(hd___0->cs, (char const   *)(var_name), & vstatus_str,
                              (char **)((void *)0));
#line 566
  ret = tmp;
  }
#line 567
  if (ret <= 0) {
#line 568
    return (ret);
  }
#line 571
  if (pvstatus_str) {
#line 572
    *pvstatus_str = vstatus_str;
  }
#line 575
  if (vstatus) {
    {
#line 576
    tmp___0 = strstr((char const   *)vstatus_str, "vch=");
#line 576
    vch = tmp___0;
    }
#line 577
    if (vch) {
      {
#line 578
      sscanf((char const   */* __restrict  */)(vch + 4), (char const   */* __restrict  */)"%31s",
             vstatus->vchannel);
      }
    }
    {
#line 581
    tmp___1 = strstr((char const   *)vstatus_str, "name=");
#line 581
    name = tmp___1;
    }
#line 582
    if (name) {
      {
#line 583
      sscanf((char const   */* __restrict  */)(name + 5), (char const   */* __restrict  */)"%31s",
             vstatus->name);
      }
    }
    {
#line 586
    tmp___2 = strstr((char const   *)vstatus_str, "auth=");
#line 586
    auth = tmp___2;
    }
#line 587
    if (auth) {
      {
#line 588
      sscanf((char const   */* __restrict  */)(auth + 5), (char const   */* __restrict  */)"%31s",
             vstatus->auth);
      }
    }
    {
#line 591
    tmp___3 = strstr((char const   *)vstatus_str, "cci=");
#line 591
    cci = tmp___3;
    }
#line 592
    if (cci) {
      {
#line 593
      sscanf((char const   */* __restrict  */)(cci + 4), (char const   */* __restrict  */)"%31s",
             vstatus->cci);
      }
    }
    {
#line 596
    tmp___4 = strstr((char const   *)vstatus_str, "cgms=");
#line 596
    cgms = tmp___4;
    }
#line 597
    if (cgms) {
      {
#line 598
      sscanf((char const   */* __restrict  */)(cgms + 5), (char const   */* __restrict  */)"%31s",
             vstatus->cgms);
      }
    }
    {
#line 601
    tmp___5 = strncmp((char const   *)(vstatus->auth), "not-subscribed", (size_t )14);
    }
#line 601
    if (tmp___5 == 0) {
#line 602
      vstatus->not_subscribed = 1;
    }
    {
#line 605
    tmp___6 = strncmp((char const   *)(vstatus->auth), "error", (size_t )5);
    }
#line 605
    if (tmp___6 == 0) {
#line 606
      vstatus->not_available = 1;
    }
    {
#line 608
    tmp___7 = strncmp((char const   *)(vstatus->auth), "dialog", (size_t )6);
    }
#line 608
    if (tmp___7 == 0) {
#line 609
      vstatus->not_available = 1;
    }
    {
#line 612
    tmp___8 = strncmp((char const   *)(vstatus->cci), "protected", (size_t )9);
    }
#line 612
    if (tmp___8 == 0) {
#line 613
      vstatus->copy_protected = 1;
    }
    {
#line 615
    tmp___9 = strncmp((char const   *)(vstatus->cgms), "protected", (size_t )9);
    }
#line 615
    if (tmp___9 == 0) {
#line 616
      vstatus->copy_protected = 1;
    }
  }
#line 620
  return (1);
}
}
#line 623 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
int hdhomerun_device_get_tuner_streaminfo(struct hdhomerun_device_t *hd___0 , char **pstreaminfo ) 
{ 
  char name[32] ;
  int tmp ;

  {
#line 625
  if (! hd___0->cs) {
    {
#line 626
    hdhomerun_debug_printf(hd___0->dbg, "hdhomerun_device_get_tuner_streaminfo: device not set\n");
    }
#line 627
    return (-1);
  }
  {
#line 631
  hdhomerun_sprintf(name, name + sizeof(name), "/tuner%u/streaminfo", hd___0->tuner);
#line 632
  tmp = hdhomerun_control_get(hd___0->cs, (char const   *)(name), pstreaminfo, (char **)((void *)0));
  }
#line 632
  return (tmp);
}
}
#line 635 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
int hdhomerun_device_get_tuner_channel(struct hdhomerun_device_t *hd___0 , char **pchannel ) 
{ 
  char name[32] ;
  int tmp ;

  {
#line 637
  if (! hd___0->cs) {
    {
#line 638
    hdhomerun_debug_printf(hd___0->dbg, "hdhomerun_device_get_tuner_channel: device not set\n");
    }
#line 639
    return (-1);
  }
  {
#line 643
  hdhomerun_sprintf(name, name + sizeof(name), "/tuner%u/channel", hd___0->tuner);
#line 644
  tmp = hdhomerun_control_get(hd___0->cs, (char const   *)(name), pchannel, (char **)((void *)0));
  }
#line 644
  return (tmp);
}
}
#line 647 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
int hdhomerun_device_get_tuner_vchannel(struct hdhomerun_device_t *hd___0 , char **pvchannel ) 
{ 
  char name[32] ;
  int tmp ;

  {
#line 649
  if (! hd___0->cs) {
    {
#line 650
    hdhomerun_debug_printf(hd___0->dbg, "hdhomerun_device_get_tuner_vchannel: device not set\n");
    }
#line 651
    return (-1);
  }
  {
#line 655
  hdhomerun_sprintf(name, name + sizeof(name), "/tuner%u/vchannel", hd___0->tuner);
#line 656
  tmp = hdhomerun_control_get(hd___0->cs, (char const   *)(name), pvchannel, (char **)((void *)0));
  }
#line 656
  return (tmp);
}
}
#line 659 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
int hdhomerun_device_get_tuner_channelmap(struct hdhomerun_device_t *hd___0 , char **pchannelmap ) 
{ 
  char name[32] ;
  int tmp ;

  {
#line 661
  if (! hd___0->cs) {
    {
#line 662
    hdhomerun_debug_printf(hd___0->dbg, "hdhomerun_device_get_tuner_channelmap: device not set\n");
    }
#line 663
    return (-1);
  }
  {
#line 667
  hdhomerun_sprintf(name, name + sizeof(name), "/tuner%u/channelmap", hd___0->tuner);
#line 668
  tmp = hdhomerun_control_get(hd___0->cs, (char const   *)(name), pchannelmap, (char **)((void *)0));
  }
#line 668
  return (tmp);
}
}
#line 671 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
int hdhomerun_device_get_tuner_filter(struct hdhomerun_device_t *hd___0 , char **pfilter ) 
{ 
  char name[32] ;
  int tmp ;

  {
#line 673
  if (! hd___0->cs) {
    {
#line 674
    hdhomerun_debug_printf(hd___0->dbg, "hdhomerun_device_get_tuner_filter: device not set\n");
    }
#line 675
    return (-1);
  }
  {
#line 679
  hdhomerun_sprintf(name, name + sizeof(name), "/tuner%u/filter", hd___0->tuner);
#line 680
  tmp = hdhomerun_control_get(hd___0->cs, (char const   *)(name), pfilter, (char **)((void *)0));
  }
#line 680
  return (tmp);
}
}
#line 683 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
int hdhomerun_device_get_tuner_program(struct hdhomerun_device_t *hd___0 , char **pprogram ) 
{ 
  char name[32] ;
  int tmp ;

  {
#line 685
  if (! hd___0->cs) {
    {
#line 686
    hdhomerun_debug_printf(hd___0->dbg, "hdhomerun_device_get_tuner_program: device not set\n");
    }
#line 687
    return (-1);
  }
  {
#line 691
  hdhomerun_sprintf(name, name + sizeof(name), "/tuner%u/program", hd___0->tuner);
#line 692
  tmp = hdhomerun_control_get(hd___0->cs, (char const   *)(name), pprogram, (char **)((void *)0));
  }
#line 692
  return (tmp);
}
}
#line 695 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
int hdhomerun_device_get_tuner_target(struct hdhomerun_device_t *hd___0 , char **ptarget ) 
{ 
  char name[32] ;
  int tmp ;

  {
#line 697
  if (! hd___0->cs) {
    {
#line 698
    hdhomerun_debug_printf(hd___0->dbg, "hdhomerun_device_get_tuner_target: device not set\n");
    }
#line 699
    return (-1);
  }
  {
#line 703
  hdhomerun_sprintf(name, name + sizeof(name), "/tuner%u/target", hd___0->tuner);
#line 704
  tmp = hdhomerun_control_get(hd___0->cs, (char const   *)(name), ptarget, (char **)((void *)0));
  }
#line 704
  return (tmp);
}
}
#line 707 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
static int hdhomerun_device_get_tuner_plotsample_internal(struct hdhomerun_device_t *hd___0 ,
                                                          char const   *name , struct hdhomerun_plotsample_t **psamples ,
                                                          size_t *pcount ) 
{ 
  char *result___1 ;
  int ret ;
  int tmp ;
  struct hdhomerun_plotsample_t *samples ;
  size_t count ;
  char *ptr ;
  char *tmp___0 ;
  char *tmp___1 ;
  unsigned int raw ;
  int tmp___2 ;
  uint16_t real ;
  uint16_t imag ;

  {
  {
#line 710
  tmp = hdhomerun_control_get(hd___0->cs, name, & result___1, (char **)((void *)0));
#line 710
  ret = tmp;
  }
#line 711
  if (ret <= 0) {
#line 712
    return (ret);
  }
#line 715
  samples = (struct hdhomerun_plotsample_t *)result___1;
#line 716
  *psamples = samples;
#line 717
  count = (size_t )0;
  {
#line 719
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 720
    tmp___0 = strchr((char const   *)result___1, ' ');
#line 720
    ptr = tmp___0;
    }
#line 721
    if (! ptr) {
#line 722
      goto while_break;
    }
    {
#line 724
    tmp___1 = ptr;
#line 724
    ptr ++;
#line 724
    *tmp___1 = (char)0;
#line 727
    tmp___2 = sscanf((char const   */* __restrict  */)result___1, (char const   */* __restrict  */)"%x",
                     & raw);
    }
#line 727
    if (tmp___2 != 1) {
#line 728
      goto while_break;
    }
#line 731
    real = (uint16_t )((raw >> 12) & 4095U);
#line 732
    if ((int )real & 2048) {
#line 733
      real = (uint16_t )((int )real | 61440);
    }
#line 736
    imag = (uint16_t )(raw & 4095U);
#line 737
    if ((int )imag & 2048) {
#line 738
      imag = (uint16_t )((int )imag | 61440);
    }
#line 741
    samples->real = (int16_t )real;
#line 742
    samples->imag = (int16_t )imag;
#line 743
    samples ++;
#line 744
    count ++;
#line 746
    result___1 = ptr;
  }
  while_break: /* CIL Label */ ;
  }
#line 749
  *pcount = count;
#line 750
  return (1);
}
}
#line 753 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
int hdhomerun_device_get_tuner_plotsample(struct hdhomerun_device_t *hd___0 , struct hdhomerun_plotsample_t **psamples ,
                                          size_t *pcount ) 
{ 
  char name[32] ;
  int tmp ;

  {
#line 755
  if (! hd___0->cs) {
    {
#line 756
    hdhomerun_debug_printf(hd___0->dbg, "hdhomerun_device_get_tuner_plotsample: device not set\n");
    }
#line 757
    return (-1);
  }
  {
#line 761
  hdhomerun_sprintf(name, name + sizeof(name), "/tuner%u/plotsample", hd___0->tuner);
#line 762
  tmp = hdhomerun_device_get_tuner_plotsample_internal(hd___0, (char const   *)(name),
                                                       psamples, pcount);
  }
#line 762
  return (tmp);
}
}
#line 765 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
int hdhomerun_device_get_oob_plotsample(struct hdhomerun_device_t *hd___0 , struct hdhomerun_plotsample_t **psamples ,
                                        size_t *pcount ) 
{ 
  int tmp ;

  {
#line 767
  if (! hd___0->cs) {
    {
#line 768
    hdhomerun_debug_printf(hd___0->dbg, "hdhomerun_device_get_oob_plotsample: device not set\n");
    }
#line 769
    return (-1);
  }
  {
#line 772
  tmp = hdhomerun_device_get_tuner_plotsample_internal(hd___0, "/oob/plotsample",
                                                       psamples, pcount);
  }
#line 772
  return (tmp);
}
}
#line 775 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
int hdhomerun_device_get_tuner_lockkey_owner(struct hdhomerun_device_t *hd___0 , char **powner ) 
{ 
  char name[32] ;
  int tmp ;

  {
#line 777
  if (! hd___0->cs) {
    {
#line 778
    hdhomerun_debug_printf(hd___0->dbg, "hdhomerun_device_get_tuner_lockkey_owner: device not set\n");
    }
#line 779
    return (-1);
  }
  {
#line 783
  hdhomerun_sprintf(name, name + sizeof(name), "/tuner%u/lockkey", hd___0->tuner);
#line 784
  tmp = hdhomerun_control_get(hd___0->cs, (char const   *)(name), powner, (char **)((void *)0));
  }
#line 784
  return (tmp);
}
}
#line 787 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
int hdhomerun_device_get_ir_target(struct hdhomerun_device_t *hd___0 , char **ptarget ) 
{ 
  int tmp ;

  {
#line 789
  if (! hd___0->cs) {
    {
#line 790
    hdhomerun_debug_printf(hd___0->dbg, "hdhomerun_device_get_ir_target: device not set\n");
    }
#line 791
    return (-1);
  }
  {
#line 794
  tmp = hdhomerun_control_get(hd___0->cs, "/ir/target", ptarget, (char **)((void *)0));
  }
#line 794
  return (tmp);
}
}
#line 797 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
int hdhomerun_device_get_lineup_location(struct hdhomerun_device_t *hd___0 , char **plocation ) 
{ 
  int tmp ;

  {
#line 799
  if (! hd___0->cs) {
    {
#line 800
    hdhomerun_debug_printf(hd___0->dbg, "hdhomerun_device_get_lineup_location: device not set\n");
    }
#line 801
    return (-1);
  }
  {
#line 804
  tmp = hdhomerun_control_get(hd___0->cs, "/lineup/location", plocation, (char **)((void *)0));
  }
#line 804
  return (tmp);
}
}
#line 807 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
int hdhomerun_device_get_version(struct hdhomerun_device_t *hd___0 , char **pversion_str ,
                                 uint32_t *pversion_num ) 
{ 
  char *version_str ;
  int ret ;
  int tmp ;
  unsigned int version_num ;
  int tmp___0 ;

  {
#line 809
  if (! hd___0->cs) {
    {
#line 810
    hdhomerun_debug_printf(hd___0->dbg, "hdhomerun_device_get_version: device not set\n");
    }
#line 811
    return (-1);
  }
  {
#line 815
  tmp = hdhomerun_control_get(hd___0->cs, "/sys/version", & version_str, (char **)((void *)0));
#line 815
  ret = tmp;
  }
#line 816
  if (ret <= 0) {
#line 817
    return (ret);
  }
#line 820
  if (pversion_str) {
#line 821
    *pversion_str = version_str;
  }
#line 824
  if (pversion_num) {
    {
#line 826
    tmp___0 = sscanf((char const   */* __restrict  */)version_str, (char const   */* __restrict  */)"%u",
                     & version_num);
    }
#line 826
    if (tmp___0 != 1) {
#line 827
      *pversion_num = (uint32_t )0;
    } else {
#line 829
      *pversion_num = version_num;
    }
  }
#line 833
  return (1);
}
}
#line 836 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
int hdhomerun_device_get_supported(struct hdhomerun_device_t *hd___0 , char *prefix ,
                                   char **pstr ) 
{ 
  char *features ;
  int ret ;
  int tmp ;
  char *ptr ;
  char *tmp___0 ;
  size_t tmp___1 ;

  {
#line 838
  if (! hd___0->cs) {
    {
#line 839
    hdhomerun_debug_printf(hd___0->dbg, "hdhomerun_device_set_tuner_channel: device not set\n");
    }
#line 840
    return (-1);
  }
  {
#line 844
  tmp = hdhomerun_control_get(hd___0->cs, "/sys/features", & features, (char **)((void *)0));
#line 844
  ret = tmp;
  }
#line 845
  if (ret <= 0) {
#line 846
    return (ret);
  }
#line 849
  if (! prefix) {
#line 850
    *pstr = features;
#line 851
    return (1);
  }
  {
#line 854
  tmp___0 = strstr((char const   *)features, (char const   *)prefix);
#line 854
  ptr = tmp___0;
  }
#line 855
  if (! ptr) {
#line 856
    return (0);
  }
  {
#line 859
  tmp___1 = strlen((char const   *)prefix);
#line 859
  ptr += tmp___1;
#line 860
  *pstr = ptr;
#line 862
  ptr = strchr((char const   *)ptr, '\n');
  }
#line 863
  if (ptr) {
#line 864
    *ptr = (char)0;
  }
#line 867
  return (1);
}
}
#line 870 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
int hdhomerun_device_set_tuner_channel(struct hdhomerun_device_t *hd___0 , char const   *channel ) 
{ 
  char name[32] ;
  int tmp ;

  {
#line 872
  if (! hd___0->cs) {
    {
#line 873
    hdhomerun_debug_printf(hd___0->dbg, "hdhomerun_device_set_tuner_channel: device not set\n");
    }
#line 874
    return (-1);
  }
  {
#line 878
  hdhomerun_sprintf(name, name + sizeof(name), "/tuner%u/channel", hd___0->tuner);
#line 879
  tmp = hdhomerun_control_set_with_lockkey(hd___0->cs, (char const   *)(name), channel,
                                           hd___0->lockkey, (char **)((void *)0),
                                           (char **)((void *)0));
  }
#line 879
  return (tmp);
}
}
#line 882 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
int hdhomerun_device_set_tuner_vchannel(struct hdhomerun_device_t *hd___0 , char const   *vchannel ) 
{ 
  char name[32] ;
  int tmp ;

  {
#line 884
  if (! hd___0->cs) {
    {
#line 885
    hdhomerun_debug_printf(hd___0->dbg, "hdhomerun_device_set_tuner_vchannel: device not set\n");
    }
#line 886
    return (-1);
  }
  {
#line 890
  hdhomerun_sprintf(name, name + sizeof(name), "/tuner%u/vchannel", hd___0->tuner);
#line 891
  tmp = hdhomerun_control_set_with_lockkey(hd___0->cs, (char const   *)(name), vchannel,
                                           hd___0->lockkey, (char **)((void *)0),
                                           (char **)((void *)0));
  }
#line 891
  return (tmp);
}
}
#line 894 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
int hdhomerun_device_set_tuner_channelmap(struct hdhomerun_device_t *hd___0 , char const   *channelmap ) 
{ 
  char name[32] ;
  int tmp ;

  {
#line 896
  if (! hd___0->cs) {
    {
#line 897
    hdhomerun_debug_printf(hd___0->dbg, "hdhomerun_device_set_tuner_channelmap: device not set\n");
    }
#line 898
    return (-1);
  }
  {
#line 902
  hdhomerun_sprintf(name, name + sizeof(name), "/tuner%u/channelmap", hd___0->tuner);
#line 903
  tmp = hdhomerun_control_set_with_lockkey(hd___0->cs, (char const   *)(name), channelmap,
                                           hd___0->lockkey, (char **)((void *)0),
                                           (char **)((void *)0));
  }
#line 903
  return (tmp);
}
}
#line 906 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
int hdhomerun_device_set_tuner_filter(struct hdhomerun_device_t *hd___0 , char const   *filter ) 
{ 
  char name[32] ;
  int tmp ;

  {
#line 908
  if (! hd___0->cs) {
    {
#line 909
    hdhomerun_debug_printf(hd___0->dbg, "hdhomerun_device_set_tuner_filter: device not set\n");
    }
#line 910
    return (-1);
  }
  {
#line 914
  hdhomerun_sprintf(name, name + sizeof(name), "/tuner%u/filter", hd___0->tuner);
#line 915
  tmp = hdhomerun_control_set_with_lockkey(hd___0->cs, (char const   *)(name), filter,
                                           hd___0->lockkey, (char **)((void *)0),
                                           (char **)((void *)0));
  }
#line 915
  return (tmp);
}
}
#line 918 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
static bool_t hdhomerun_device_set_tuner_filter_by_array_append(char *ptr , char *end ,
                                                                uint16_t range_begin ,
                                                                uint16_t range_end ) 
{ 
  bool_t tmp ;
  bool_t tmp___0 ;

  {
#line 920
  if ((int )range_begin == (int )range_end) {
    {
#line 921
    tmp = hdhomerun_sprintf(ptr, end, "0x%04x ", (unsigned int )range_begin);
    }
#line 921
    return (tmp);
  } else {
    {
#line 923
    tmp___0 = hdhomerun_sprintf(ptr, end, "0x%04x-0x%04x ", (unsigned int )range_begin,
                                (unsigned int )range_end);
    }
#line 923
    return (tmp___0);
  }
}
}
#line 927 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
int hdhomerun_device_set_tuner_filter_by_array(struct hdhomerun_device_t *hd___0 ,
                                               unsigned char *filter_array ) 
{ 
  char filter[1024] ;
  char *ptr ;
  char *end ;
  uint16_t range_begin ;
  uint16_t range_end ;
  uint16_t i ;
  bool_t tmp ;
  bool_t tmp___0 ;
  int tmp___1 ;

  {
#line 930
  ptr = filter;
#line 931
  end = filter + sizeof(filter);
#line 933
  range_begin = (uint16_t )65535;
#line 934
  range_end = (uint16_t )65535;
#line 937
  i = (uint16_t )0;
  {
#line 937
  while (1) {
    while_continue: /* CIL Label */ ;
#line 937
    if (! ((int )i <= 8191)) {
#line 937
      goto while_break;
    }
#line 938
    if (! *(filter_array + i)) {
#line 939
      if ((int )range_begin == 65535) {
#line 940
        goto __Cont;
      }
      {
#line 942
      tmp = hdhomerun_device_set_tuner_filter_by_array_append(ptr, end, range_begin,
                                                              range_end);
      }
#line 942
      if (! tmp) {
#line 943
        return (0);
      }
      {
#line 945
      ptr = strchr((char const   *)ptr, 0);
#line 946
      range_begin = (uint16_t )65535;
#line 947
      range_end = (uint16_t )65535;
      }
#line 948
      goto __Cont;
    }
#line 951
    if ((int )range_begin == 65535) {
#line 952
      range_begin = i;
#line 953
      range_end = i;
#line 954
      goto __Cont;
    }
#line 957
    range_end = i;
    __Cont: /* CIL Label */ 
#line 937
    i = (uint16_t )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 960
  if ((int )range_begin != 65535) {
    {
#line 961
    tmp___0 = hdhomerun_device_set_tuner_filter_by_array_append(ptr, end, range_begin,
                                                                range_end);
    }
#line 961
    if (! tmp___0) {
#line 962
      return (0);
    }
    {
#line 964
    ptr = strchr((char const   *)ptr, 0);
    }
  }
#line 968
  if ((unsigned long )ptr > (unsigned long )(filter)) {
#line 969
    ptr --;
#line 970
    *ptr = (char)0;
  }
  {
#line 973
  tmp___1 = hdhomerun_device_set_tuner_filter(hd___0, (char const   *)(filter));
  }
#line 973
  return (tmp___1);
}
}
#line 976 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
int hdhomerun_device_set_tuner_program(struct hdhomerun_device_t *hd___0 , char const   *program ) 
{ 
  char name[32] ;
  int tmp ;

  {
#line 978
  if (! hd___0->cs) {
    {
#line 979
    hdhomerun_debug_printf(hd___0->dbg, "hdhomerun_device_set_tuner_program: device not set\n");
    }
#line 980
    return (-1);
  }
  {
#line 984
  hdhomerun_sprintf(name, name + sizeof(name), "/tuner%u/program", hd___0->tuner);
#line 985
  tmp = hdhomerun_control_set_with_lockkey(hd___0->cs, (char const   *)(name), program,
                                           hd___0->lockkey, (char **)((void *)0),
                                           (char **)((void *)0));
  }
#line 985
  return (tmp);
}
}
#line 988 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
int hdhomerun_device_set_tuner_target(struct hdhomerun_device_t *hd___0 , char const   *target ) 
{ 
  char name[32] ;
  int tmp ;

  {
#line 990
  if (! hd___0->cs) {
    {
#line 991
    hdhomerun_debug_printf(hd___0->dbg, "hdhomerun_device_set_tuner_target: device not set\n");
    }
#line 992
    return (-1);
  }
  {
#line 996
  hdhomerun_sprintf(name, name + sizeof(name), "/tuner%u/target", hd___0->tuner);
#line 997
  tmp = hdhomerun_control_set_with_lockkey(hd___0->cs, (char const   *)(name), target,
                                           hd___0->lockkey, (char **)((void *)0),
                                           (char **)((void *)0));
  }
#line 997
  return (tmp);
}
}
#line 1000 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
static int hdhomerun_device_set_tuner_target_to_local(struct hdhomerun_device_t *hd___0 ,
                                                      char const   *protocol ) 
{ 
  char target[64] ;
  uint32_t local_ip ;
  uint32_t tmp ;
  uint16_t local_port ;
  uint16_t tmp___0 ;
  int tmp___1 ;

  {
#line 1002
  if (! hd___0->cs) {
    {
#line 1003
    hdhomerun_debug_printf(hd___0->dbg, "hdhomerun_device_set_tuner_target_to_local: device not set\n");
    }
#line 1004
    return (-1);
  }
#line 1006
  if (! hd___0->vs) {
    {
#line 1007
    hdhomerun_debug_printf(hd___0->dbg, "hdhomerun_device_set_tuner_target_to_local: video not initialized\n");
    }
#line 1008
    return (-1);
  }
  {
#line 1013
  tmp = hdhomerun_control_get_local_addr(hd___0->cs);
#line 1013
  local_ip = tmp;
#line 1014
  tmp___0 = hdhomerun_video_get_local_port(hd___0->vs);
#line 1014
  local_port = tmp___0;
#line 1015
  hdhomerun_sprintf(target, target + sizeof(target), "%s://%u.%u.%u.%u:%u", protocol,
                    (local_ip >> 24) & 255U, (local_ip >> 16) & 255U, (local_ip >> 8) & 255U,
                    local_ip & 255U, (unsigned int )local_port);
#line 1022
  tmp___1 = hdhomerun_device_set_tuner_target(hd___0, (char const   *)(target));
  }
#line 1022
  return (tmp___1);
}
}
#line 1025 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
int hdhomerun_device_set_ir_target(struct hdhomerun_device_t *hd___0 , char const   *target ) 
{ 
  int tmp ;

  {
#line 1027
  if (! hd___0->cs) {
    {
#line 1028
    hdhomerun_debug_printf(hd___0->dbg, "hdhomerun_device_set_ir_target: device not set\n");
    }
#line 1029
    return (-1);
  }
  {
#line 1032
  tmp = hdhomerun_control_set(hd___0->cs, "/ir/target", target, (char **)((void *)0),
                              (char **)((void *)0));
  }
#line 1032
  return (tmp);
}
}
#line 1035 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
int hdhomerun_device_set_lineup_location(struct hdhomerun_device_t *hd___0 , char const   *location ) 
{ 
  int tmp ;

  {
#line 1037
  if (! hd___0->cs) {
    {
#line 1038
    hdhomerun_debug_printf(hd___0->dbg, "hdhomerun_device_set_lineup_location: device not set\n");
    }
#line 1039
    return (-1);
  }
  {
#line 1042
  tmp = hdhomerun_control_set(hd___0->cs, "/lineup/location", location, (char **)((void *)0),
                              (char **)((void *)0));
  }
#line 1042
  return (tmp);
}
}
#line 1045 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
int hdhomerun_device_set_sys_dvbc_modulation(struct hdhomerun_device_t *hd___0 , char const   *modulation_list ) 
{ 
  int tmp ;

  {
#line 1047
  if (! hd___0->cs) {
    {
#line 1048
    hdhomerun_debug_printf(hd___0->dbg, "hdhomerun_device_set_sys_dvbc_modulation: device not set\n");
    }
#line 1049
    return (-1);
  }
  {
#line 1052
  tmp = hdhomerun_control_set(hd___0->cs, "/sys/dvbc_modulation", modulation_list,
                              (char **)((void *)0), (char **)((void *)0));
  }
#line 1052
  return (tmp);
}
}
#line 1055 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
int hdhomerun_device_get_var(struct hdhomerun_device_t *hd___0 , char const   *name ,
                             char **pvalue , char **perror___0 ) 
{ 
  int tmp ;

  {
#line 1057
  if (! hd___0->cs) {
    {
#line 1058
    hdhomerun_debug_printf(hd___0->dbg, "hdhomerun_device_get_var: device not set\n");
    }
#line 1059
    return (-1);
  }
  {
#line 1062
  tmp = hdhomerun_control_get(hd___0->cs, name, pvalue, perror___0);
  }
#line 1062
  return (tmp);
}
}
#line 1065 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
int hdhomerun_device_set_var(struct hdhomerun_device_t *hd___0 , char const   *name ,
                             char const   *value , char **pvalue , char **perror___0 ) 
{ 
  int tmp ;

  {
#line 1067
  if (! hd___0->cs) {
    {
#line 1068
    hdhomerun_debug_printf(hd___0->dbg, "hdhomerun_device_set_var: device not set\n");
    }
#line 1069
    return (-1);
  }
  {
#line 1072
  tmp = hdhomerun_control_set_with_lockkey(hd___0->cs, name, value, hd___0->lockkey,
                                           pvalue, perror___0);
  }
#line 1072
  return (tmp);
}
}
#line 1075 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
int hdhomerun_device_tuner_lockkey_request(struct hdhomerun_device_t *hd___0 , char **perror___0 ) 
{ 
  uint32_t new_lockkey ;
  uint32_t tmp ;
  char name[32] ;
  char new_lockkey_str[64] ;
  int ret ;
  int tmp___0 ;

  {
#line 1077
  if (hd___0->multicast_ip != 0U) {
#line 1078
    return (1);
  }
#line 1080
  if (! hd___0->cs) {
    {
#line 1081
    hdhomerun_debug_printf(hd___0->dbg, "hdhomerun_device_tuner_lockkey_request: device not set\n");
    }
#line 1082
    return (-1);
  }
  {
#line 1085
  tmp = random_get32();
#line 1085
  new_lockkey = tmp;
#line 1088
  hdhomerun_sprintf(name, name + sizeof(name), "/tuner%u/lockkey", hd___0->tuner);
#line 1091
  hdhomerun_sprintf(new_lockkey_str, new_lockkey_str + sizeof(new_lockkey_str), "%u",
                    new_lockkey);
#line 1093
  tmp___0 = hdhomerun_control_set_with_lockkey(hd___0->cs, (char const   *)(name),
                                               (char const   *)(new_lockkey_str),
                                               hd___0->lockkey, (char **)((void *)0),
                                               perror___0);
#line 1093
  ret = tmp___0;
  }
#line 1094
  if (ret <= 0) {
#line 1095
    hd___0->lockkey = (uint32_t )0;
#line 1096
    return (ret);
  }
#line 1099
  hd___0->lockkey = new_lockkey;
#line 1100
  return (ret);
}
}
#line 1103 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
int hdhomerun_device_tuner_lockkey_release(struct hdhomerun_device_t *hd___0 ) 
{ 
  char name[32] ;
  int ret ;
  int tmp ;

  {
#line 1105
  if (hd___0->multicast_ip != 0U) {
#line 1106
    return (1);
  }
#line 1108
  if (! hd___0->cs) {
    {
#line 1109
    hdhomerun_debug_printf(hd___0->dbg, "hdhomerun_device_tuner_lockkey_release: device not set\n");
    }
#line 1110
    return (-1);
  }
#line 1113
  if (hd___0->lockkey == 0U) {
#line 1114
    return (1);
  }
  {
#line 1118
  hdhomerun_sprintf(name, name + sizeof(name), "/tuner%u/lockkey", hd___0->tuner);
#line 1119
  tmp = hdhomerun_control_set_with_lockkey(hd___0->cs, (char const   *)(name), "none",
                                           hd___0->lockkey, (char **)((void *)0),
                                           (char **)((void *)0));
#line 1119
  ret = tmp;
#line 1121
  hd___0->lockkey = (uint32_t )0;
  }
#line 1122
  return (ret);
}
}
#line 1125 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
int hdhomerun_device_tuner_lockkey_force(struct hdhomerun_device_t *hd___0 ) 
{ 
  char name[32] ;
  int ret ;
  int tmp ;

  {
#line 1127
  if (hd___0->multicast_ip != 0U) {
#line 1128
    return (1);
  }
#line 1130
  if (! hd___0->cs) {
    {
#line 1131
    hdhomerun_debug_printf(hd___0->dbg, "hdhomerun_device_tuner_lockkey_force: device not set\n");
    }
#line 1132
    return (-1);
  }
  {
#line 1136
  hdhomerun_sprintf(name, name + sizeof(name), "/tuner%u/lockkey", hd___0->tuner);
#line 1137
  tmp = hdhomerun_control_set(hd___0->cs, (char const   *)(name), "force", (char **)((void *)0),
                              (char **)((void *)0));
#line 1137
  ret = tmp;
#line 1139
  hd___0->lockkey = (uint32_t )0;
  }
#line 1140
  return (ret);
}
}
#line 1143 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
void hdhomerun_device_tuner_lockkey_use_value(struct hdhomerun_device_t *hd___0 ,
                                              uint32_t lockkey ) 
{ 


  {
#line 1145
  if (hd___0->multicast_ip != 0U) {
#line 1146
    return;
  }
#line 1149
  hd___0->lockkey = lockkey;
#line 1150
  return;
}
}
#line 1152 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
int hdhomerun_device_wait_for_lock(struct hdhomerun_device_t *hd___0 , struct hdhomerun_tuner_status_t *status ) 
{ 
  uint64_t timeout ;
  uint64_t tmp ;
  int ret ;
  int tmp___0 ;
  uint64_t tmp___1 ;

  {
  {
#line 1155
  msleep_minimum((uint64_t )250);
#line 1158
  tmp = getcurrenttime();
#line 1158
  timeout = tmp + 2500UL;
  }
  {
#line 1159
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1161
    tmp___0 = hdhomerun_device_get_tuner_status(hd___0, (char **)((void *)0), status);
#line 1161
    ret = tmp___0;
    }
#line 1162
    if (ret <= 0) {
#line 1163
      return (ret);
    }
#line 1166
    if (! status->signal_present) {
#line 1167
      return (1);
    }
#line 1169
    if (status->lock_supported) {
#line 1170
      return (1);
    } else
#line 1169
    if (status->lock_unsupported) {
#line 1170
      return (1);
    }
    {
#line 1173
    tmp___1 = getcurrenttime();
    }
#line 1173
    if (tmp___1 >= timeout) {
#line 1174
      return (1);
    }
    {
#line 1177
    msleep_approx((uint64_t )250);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1181 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
int hdhomerun_device_stream_start(struct hdhomerun_device_t *hd___0 ) 
{ 
  int ret ;
  int tmp ;
  int ret___0 ;
  int tmp___0 ;

  {
  {
#line 1183
  hdhomerun_device_get_video_sock(hd___0);
  }
#line 1184
  if (! hd___0->vs) {
#line 1185
    return (-1);
  }
#line 1189
  if (hd___0->multicast_ip != 0U) {
    {
#line 1190
    tmp = hdhomerun_video_join_multicast_group(hd___0->vs, hd___0->multicast_ip, (uint32_t )0);
#line 1190
    ret = tmp;
    }
#line 1191
    if (ret <= 0) {
#line 1192
      return (ret);
    }
  } else {
    {
#line 1195
    tmp___0 = hdhomerun_device_set_tuner_target_to_local(hd___0, "rtp");
#line 1195
    ret___0 = tmp___0;
    }
#line 1196
    if (ret___0 == 0) {
      {
#line 1197
      ret___0 = hdhomerun_device_set_tuner_target_to_local(hd___0, "udp");
      }
    }
#line 1199
    if (ret___0 <= 0) {
#line 1200
      return (ret___0);
    }
  }
  {
#line 1205
  msleep_minimum((uint64_t )64);
#line 1206
  hdhomerun_video_flush(hd___0->vs);
  }
#line 1209
  return (1);
}
}
#line 1212 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
uint8_t *hdhomerun_device_stream_recv(struct hdhomerun_device_t *hd___0 , size_t max_size ,
                                      size_t *pactual_size ) 
{ 
  uint8_t *tmp ;

  {
#line 1214
  if (! hd___0->vs) {
    {
#line 1215
    hdhomerun_debug_printf(hd___0->dbg, "hdhomerun_device_stream_recv: video not initialized\n");
    }
#line 1216
    return ((uint8_t *)((void *)0));
  }
  {
#line 1219
  tmp = hdhomerun_video_recv(hd___0->vs, max_size, pactual_size);
  }
#line 1219
  return (tmp);
}
}
#line 1222 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
void hdhomerun_device_stream_flush(struct hdhomerun_device_t *hd___0 ) 
{ 


  {
#line 1224
  if (! hd___0->vs) {
    {
#line 1225
    hdhomerun_debug_printf(hd___0->dbg, "hdhomerun_device_stream_flush: video not initialized\n");
    }
#line 1226
    return;
  }
  {
#line 1229
  hdhomerun_video_flush(hd___0->vs);
  }
#line 1230
  return;
}
}
#line 1232 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
void hdhomerun_device_stream_stop(struct hdhomerun_device_t *hd___0 ) 
{ 


  {
#line 1234
  if (! hd___0->vs) {
    {
#line 1235
    hdhomerun_debug_printf(hd___0->dbg, "hdhomerun_device_stream_stop: video not initialized\n");
    }
#line 1236
    return;
  }
#line 1239
  if (hd___0->multicast_ip != 0U) {
    {
#line 1240
    hdhomerun_video_leave_multicast_group(hd___0->vs, hd___0->multicast_ip, (uint32_t )0);
    }
  } else {
    {
#line 1242
    hdhomerun_device_set_tuner_target(hd___0, "none");
    }
  }
#line 1244
  return;
}
}
#line 1246 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
int hdhomerun_device_channelscan_init(struct hdhomerun_device_t *hd___0 , char const   *channelmap ) 
{ 


  {
#line 1248
  if (hd___0->scan) {
    {
#line 1249
    channelscan_destroy(hd___0->scan);
    }
  }
  {
#line 1252
  hd___0->scan = channelscan_create(hd___0, channelmap);
  }
#line 1253
  if (! hd___0->scan) {
    {
#line 1254
    hdhomerun_debug_printf(hd___0->dbg, "hdhomerun_device_channelscan_init: failed to create scan object\n");
    }
#line 1255
    return (-1);
  }
#line 1258
  return (1);
}
}
#line 1261 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
int hdhomerun_device_channelscan_advance(struct hdhomerun_device_t *hd___0 , struct hdhomerun_channelscan_result_t *result___1 ) 
{ 
  int ret ;
  int tmp ;

  {
#line 1263
  if (! hd___0->scan) {
    {
#line 1264
    hdhomerun_debug_printf(hd___0->dbg, "hdhomerun_device_channelscan_advance: scan not initialized\n");
    }
#line 1265
    return (0);
  }
  {
#line 1268
  tmp = channelscan_advance(hd___0->scan, result___1);
#line 1268
  ret = tmp;
  }
#line 1269
  if (ret <= 0) {
    {
#line 1270
    channelscan_destroy(hd___0->scan);
#line 1271
    hd___0->scan = (struct hdhomerun_channelscan_t *)((void *)0);
    }
  }
#line 1274
  return (ret);
}
}
#line 1277 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
int hdhomerun_device_channelscan_detect(struct hdhomerun_device_t *hd___0 , struct hdhomerun_channelscan_result_t *result___1 ) 
{ 
  int ret ;
  int tmp ;

  {
#line 1279
  if (! hd___0->scan) {
    {
#line 1280
    hdhomerun_debug_printf(hd___0->dbg, "hdhomerun_device_channelscan_detect: scan not initialized\n");
    }
#line 1281
    return (0);
  }
  {
#line 1284
  tmp = channelscan_detect(hd___0->scan, result___1);
#line 1284
  ret = tmp;
  }
#line 1285
  if (ret < 0) {
    {
#line 1286
    channelscan_destroy(hd___0->scan);
#line 1287
    hd___0->scan = (struct hdhomerun_channelscan_t *)((void *)0);
    }
  }
#line 1290
  return (ret);
}
}
#line 1293 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
uint8_t hdhomerun_device_channelscan_get_progress(struct hdhomerun_device_t *hd___0 ) 
{ 
  uint8_t tmp ;

  {
#line 1295
  if (! hd___0->scan) {
    {
#line 1296
    hdhomerun_debug_printf(hd___0->dbg, "hdhomerun_device_channelscan_get_progress: scan not initialized\n");
    }
#line 1297
    return ((uint8_t )0);
  }
  {
#line 1300
  tmp = channelscan_get_progress(hd___0->scan);
  }
#line 1300
  return (tmp);
}
}
#line 1303 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
char const   *hdhomerun_device_get_model_str(struct hdhomerun_device_t *hd___0 ) 
{ 
  char *model_str ;
  int ret ;
  int tmp ;

  {
#line 1305
  if (hd___0->model[0]) {
#line 1306
    return ((char const   *)(hd___0->model));
  }
#line 1309
  if (! hd___0->cs) {
    {
#line 1310
    hdhomerun_debug_printf(hd___0->dbg, "hdhomerun_device_get_model_str: device not set\n");
    }
#line 1311
    return ((char const   *)((void *)0));
  }
  {
#line 1315
  tmp = hdhomerun_control_get(hd___0->cs, "/sys/model", & model_str, (char **)((void *)0));
#line 1315
  ret = tmp;
  }
#line 1316
  if (ret < 0) {
#line 1317
    return ((char const   *)((void *)0));
  }
#line 1319
  if (ret == 0) {
    {
#line 1320
    hdhomerun_sprintf(hd___0->model, hd___0->model + sizeof(hd___0->model), "hdhomerun_atsc");
    }
#line 1321
    return ((char const   *)(hd___0->model));
  }
  {
#line 1324
  hdhomerun_sprintf(hd___0->model, hd___0->model + sizeof(hd___0->model), "%s", model_str);
  }
#line 1325
  return ((char const   *)(hd___0->model));
}
}
#line 1328 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
int hdhomerun_device_upgrade(struct hdhomerun_device_t *hd___0 , FILE *upgrade_file ) 
{ 
  int tmp ;

  {
#line 1330
  if (! hd___0->cs) {
    {
#line 1331
    hdhomerun_debug_printf(hd___0->dbg, "hdhomerun_device_upgrade: device not set\n");
    }
#line 1332
    return (-1);
  }
  {
#line 1335
  hdhomerun_control_set(hd___0->cs, "/tuner0/lockkey", "force", (char **)((void *)0),
                        (char **)((void *)0));
#line 1336
  hdhomerun_control_set(hd___0->cs, "/tuner0/channel", "none", (char **)((void *)0),
                        (char **)((void *)0));
#line 1338
  hdhomerun_control_set(hd___0->cs, "/tuner1/lockkey", "force", (char **)((void *)0),
                        (char **)((void *)0));
#line 1339
  hdhomerun_control_set(hd___0->cs, "/tuner1/channel", "none", (char **)((void *)0),
                        (char **)((void *)0));
#line 1341
  tmp = hdhomerun_control_upgrade(hd___0->cs, upgrade_file);
  }
#line 1341
  return (tmp);
}
}
#line 1344 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
void hdhomerun_device_debug_print_video_stats(struct hdhomerun_device_t *hd___0 ) 
{ 
  bool_t tmp ;
  char name[32] ;
  char *debug_str ;
  char *error_str ;
  int ret ;
  int tmp___0 ;

  {
  {
#line 1346
  tmp = hdhomerun_debug_enabled(hd___0->dbg);
  }
#line 1346
  if (! tmp) {
#line 1347
    return;
  }
#line 1350
  if (hd___0->cs) {
    {
#line 1352
    hdhomerun_sprintf(name, name + sizeof(name), "/tuner%u/debug", hd___0->tuner);
#line 1356
    tmp___0 = hdhomerun_control_get(hd___0->cs, (char const   *)(name), & debug_str,
                                    & error_str);
#line 1356
    ret = tmp___0;
    }
#line 1357
    if (ret < 0) {
      {
#line 1358
      hdhomerun_debug_printf(hd___0->dbg, "video dev: communication error getting debug stats\n");
      }
#line 1359
      return;
    }
#line 1362
    if (error_str) {
      {
#line 1363
      hdhomerun_debug_printf(hd___0->dbg, "video dev: %s\n", error_str);
      }
    } else {
      {
#line 1365
      hdhomerun_debug_printf(hd___0->dbg, "video dev: %s\n", debug_str);
      }
    }
  }
#line 1369
  if (hd___0->vs) {
    {
#line 1370
    hdhomerun_video_debug_print_stats(hd___0->vs);
    }
  }
#line 1372
  return;
}
}
#line 1374 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
void hdhomerun_device_get_video_stats(struct hdhomerun_device_t *hd___0 , struct hdhomerun_video_stats_t *stats ) 
{ 


  {
#line 1376
  if (! hd___0->vs) {
    {
#line 1377
    hdhomerun_debug_printf(hd___0->dbg, "hdhomerun_device_stream_flush: video not initialized\n");
#line 1378
    memset((void *)stats, 0, sizeof(struct hdhomerun_video_stats_t ));
    }
#line 1379
    return;
  }
  {
#line 1382
  hdhomerun_video_get_stats(hd___0->vs, stats);
  }
#line 1383
  return;
}
}
#line 28 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_channels.h"
char const   *hdhomerun_channelmap_get_channelmap_from_country_source(char const   *countrycode ,
                                                                      char const   *source ,
                                                                      char const   *supported ) ;
#line 29
char const   *hdhomerun_channelmap_get_channelmap_scan_group(char const   *channelmap ) ;
#line 31
uint16_t hdhomerun_channel_entry_channel_number(struct hdhomerun_channel_entry_t *entry ) ;
#line 38
struct hdhomerun_channel_entry_t *hdhomerun_channel_list_first(struct hdhomerun_channel_list_t *channel_list ) ;
#line 40
struct hdhomerun_channel_entry_t *hdhomerun_channel_list_next(struct hdhomerun_channel_list_t *channel_list ,
                                                              struct hdhomerun_channel_entry_t *entry ) ;
#line 42
uint32_t hdhomerun_channel_list_total_count(struct hdhomerun_channel_list_t *channel_list ) ;
#line 43
uint32_t hdhomerun_channel_list_frequency_count(struct hdhomerun_channel_list_t *channel_list ) ;
#line 45
uint32_t hdhomerun_channel_frequency_round(uint32_t frequency , uint32_t resolution ) ;
#line 46
uint32_t hdhomerun_channel_frequency_round_normal(uint32_t frequency ) ;
#line 47
uint32_t hdhomerun_channel_number_to_frequency(struct hdhomerun_channel_list_t *channel_list ,
                                               uint16_t channel_number ) ;
#line 48
uint16_t hdhomerun_channel_frequency_to_number(struct hdhomerun_channel_list_t *channel_list ,
                                               uint32_t frequency ) ;
#line 51 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_channels.c"
static struct hdhomerun_channelmap_range_t  const  hdhomerun_channelmap_range_au_bcast[3]  = {      {(uint16_t )5,
      (uint16_t )12, (uint32_t )177500000, (uint32_t )7000000}, 
        {(uint16_t )21, (uint16_t )69, (uint32_t )480500000, (uint32_t )7000000}, 
        {(uint16_t )0, (uint16_t )0, (uint32_t )0, (uint32_t )0}};
#line 58 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_channels.c"
static struct hdhomerun_channelmap_range_t  const  hdhomerun_channelmap_range_eu_bcast[3]  = {      {(uint16_t )5,
      (uint16_t )12, (uint32_t )177500000, (uint32_t )7000000}, 
        {(uint16_t )21, (uint16_t )69, (uint32_t )474000000, (uint32_t )8000000}, 
        {(uint16_t )0, (uint16_t )0, (uint32_t )0, (uint32_t )0}};
#line 65 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_channels.c"
static struct hdhomerun_channelmap_range_t  const  hdhomerun_channelmap_range_eu_cable[2]  = {      {(uint16_t )108,
      (uint16_t )862, (uint32_t )108000000, (uint32_t )1000000}, 
        {(uint16_t )0, (uint16_t )0, (uint32_t )0, (uint32_t )0}};
#line 71 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_channels.c"
static struct hdhomerun_channelmap_range_t  const  hdhomerun_channelmap_range_kr_cable[6]  = {      {(uint16_t )2,
      (uint16_t )4, (uint32_t )57000000, (uint32_t )6000000}, 
        {(uint16_t )5, (uint16_t )6, (uint32_t )79000000, (uint32_t )6000000}, 
        {(uint16_t )7, (uint16_t )13, (uint32_t )177000000, (uint32_t )6000000}, 
        {(uint16_t )14, (uint16_t )22, (uint32_t )123000000, (uint32_t )6000000}, 
        {(uint16_t )23, (uint16_t )153, (uint32_t )219000000, (uint32_t )6000000}, 
        {(uint16_t )0, (uint16_t )0, (uint32_t )0, (uint32_t )0}};
#line 81 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_channels.c"
static struct hdhomerun_channelmap_range_t  const  hdhomerun_channelmap_range_us_bcast[5]  = {      {(uint16_t )2,
      (uint16_t )4, (uint32_t )57000000, (uint32_t )6000000}, 
        {(uint16_t )5, (uint16_t )6, (uint32_t )79000000, (uint32_t )6000000}, 
        {(uint16_t )7, (uint16_t )13, (uint32_t )177000000, (uint32_t )6000000}, 
        {(uint16_t )14, (uint16_t )69, (uint32_t )473000000, (uint32_t )6000000}, 
        {(uint16_t )0, (uint16_t )0, (uint32_t )0, (uint32_t )0}};
#line 90 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_channels.c"
static struct hdhomerun_channelmap_range_t  const  hdhomerun_channelmap_range_us_cable[8]  = 
#line 90
  {      {(uint16_t )2, (uint16_t )4, (uint32_t )57000000, (uint32_t )6000000}, 
        {(uint16_t )5, (uint16_t )6, (uint32_t )79000000, (uint32_t )6000000}, 
        {(uint16_t )7, (uint16_t )13, (uint32_t )177000000, (uint32_t )6000000}, 
        {(uint16_t )14, (uint16_t )22, (uint32_t )123000000, (uint32_t )6000000}, 
        {(uint16_t )23, (uint16_t )94, (uint32_t )219000000, (uint32_t )6000000}, 
        {(uint16_t )95, (uint16_t )99, (uint32_t )93000000, (uint32_t )6000000}, 
        {(uint16_t )100, (uint16_t )158, (uint32_t )651000000, (uint32_t )6000000}, 
        {(uint16_t )0, (uint16_t )0, (uint32_t )0, (uint32_t )0}};
#line 102 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_channels.c"
static struct hdhomerun_channelmap_range_t  const  hdhomerun_channelmap_range_us_hrc[8]  = 
#line 102
  {      {(uint16_t )2, (uint16_t )4, (uint32_t )55752700, (uint32_t )6000300}, 
        {(uint16_t )5, (uint16_t )6, (uint32_t )79753900, (uint32_t )6000300}, 
        {(uint16_t )7, (uint16_t )13, (uint32_t )175758700, (uint32_t )6000300}, 
        {(uint16_t )14, (uint16_t )22, (uint32_t )121756000, (uint32_t )6000300}, 
        {(uint16_t )23, (uint16_t )94, (uint32_t )217760800, (uint32_t )6000300}, 
        {(uint16_t )95, (uint16_t )99, (uint32_t )91754500, (uint32_t )6000300}, 
        {(uint16_t )100, (uint16_t )158, (uint32_t )649782400, (uint32_t )6000300}, 
        {(uint16_t )0, (uint16_t )0, (uint32_t )0, (uint32_t )0}};
#line 114 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_channels.c"
static struct hdhomerun_channelmap_range_t  const  hdhomerun_channelmap_range_us_irc[11]  = 
#line 114
  {      {(uint16_t )2, (uint16_t )4, (uint32_t )57012500, (uint32_t )6000000}, 
        {(uint16_t )5, (uint16_t )6, (uint32_t )81012500, (uint32_t )6000000}, 
        {(uint16_t )7, (uint16_t )13, (uint32_t )177012500, (uint32_t )6000000}, 
        {(uint16_t )14, (uint16_t )22, (uint32_t )123012500, (uint32_t )6000000}, 
        {(uint16_t )23, (uint16_t )41, (uint32_t )219012500, (uint32_t )6000000}, 
        {(uint16_t )42, (uint16_t )42, (uint32_t )333025000, (uint32_t )6000000}, 
        {(uint16_t )43, (uint16_t )94, (uint32_t )339012500, (uint32_t )6000000}, 
        {(uint16_t )95, (uint16_t )97, (uint32_t )93012500, (uint32_t )6000000}, 
        {(uint16_t )98, (uint16_t )99, (uint32_t )111025000, (uint32_t )6000000}, 
        {(uint16_t )100, (uint16_t )158, (uint32_t )651012500, (uint32_t )6000000}, 
        {(uint16_t )0, (uint16_t )0, (uint32_t )0, (uint32_t )0}};
#line 128 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_channels.c"
static struct hdhomerun_channelmap_record_t  const  hdhomerun_channelmap_table[13]  = 
#line 128
  {      {"au-bcast", hdhomerun_channelmap_range_au_bcast, "au-bcast", "AU"}, 
        {"au-cable", hdhomerun_channelmap_range_eu_cable, "au-cable", "AU"}, 
        {"eu-bcast", hdhomerun_channelmap_range_eu_bcast, "eu-bcast", (char const   *)((void *)0)}, 
        {"eu-cable",
      hdhomerun_channelmap_range_eu_cable, "eu-cable", (char const   *)((void *)0)}, 
        {"tw-bcast",
      hdhomerun_channelmap_range_us_bcast, "tw-bcast", "TW"}, 
        {"tw-cable", hdhomerun_channelmap_range_us_cable, "tw-cable", "TW"}, 
        {"kr-bcast", hdhomerun_channelmap_range_us_bcast, "kr-bcast", "KR"}, 
        {"kr-cable", hdhomerun_channelmap_range_kr_cable, "kr-cable", "KR"}, 
        {"us-bcast", hdhomerun_channelmap_range_us_bcast, "us-bcast", (char const   *)((void *)0)}, 
        {"us-cable",
      hdhomerun_channelmap_range_us_cable, "us-cable us-hrc us-irc", (char const   *)((void *)0)}, 
        {"us-hrc",
      hdhomerun_channelmap_range_us_hrc, "us-cable us-hrc us-irc", (char const   *)((void *)0)}, 
        {"us-irc",
      hdhomerun_channelmap_range_us_irc, "us-cable us-hrc us-irc", (char const   *)((void *)0)}, 
        {(char const   *)((void *)0),
      (struct hdhomerun_channelmap_range_t  const  *)((void *)0), (char const   *)((void *)0),
      (char const   *)((void *)0)}};
#line 146 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_channels.c"
char const   *hdhomerun_channelmap_get_channelmap_from_country_source(char const   *countrycode ,
                                                                      char const   *source ,
                                                                      char const   *supported ) 
{ 
  char const   *default_result ;
  struct hdhomerun_channelmap_record_t  const  *record ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 148
  default_result = (char const   *)((void *)0);
#line 150
  record = hdhomerun_channelmap_table;
  {
#line 151
  while (1) {
    while_continue: /* CIL Label */ ;
#line 151
    if (! record->channelmap) {
#line 151
      goto while_break;
    }
    {
#line 153
    tmp = strstr((char const   *)record->channelmap, source);
    }
#line 153
    if (! tmp) {
#line 154
      record ++;
#line 155
      goto while_continue;
    }
    {
#line 159
    tmp___0 = strstr(supported, (char const   *)record->channelmap);
    }
#line 159
    if (! tmp___0) {
#line 160
      record ++;
#line 161
      goto while_continue;
    }
#line 165
    if (! record->countrycodes) {
#line 166
      default_result = (char const   *)record->channelmap;
#line 167
      record ++;
#line 168
      goto while_continue;
    }
    {
#line 172
    tmp___1 = strstr((char const   *)record->countrycodes, countrycode);
    }
#line 172
    if (! tmp___1) {
#line 173
      record ++;
#line 174
      goto while_continue;
    }
#line 178
    return ((char const   *)record->channelmap);
  }
  while_break: /* CIL Label */ ;
  }
#line 181
  return (default_result);
}
}
#line 184 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_channels.c"
char const   *hdhomerun_channelmap_get_channelmap_scan_group(char const   *channelmap ) 
{ 
  struct hdhomerun_channelmap_record_t  const  *record ;
  char *tmp ;

  {
#line 186
  record = hdhomerun_channelmap_table;
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 187
    if (! record->channelmap) {
#line 187
      goto while_break;
    }
    {
#line 188
    tmp = strstr(channelmap, (char const   *)record->channelmap);
    }
#line 188
    if (tmp) {
#line 189
      return ((char const   *)record->channelmap_scan_group);
    }
#line 191
    record ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 194
  return ((char const   *)((void *)0));
}
}
#line 197 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_channels.c"
uint16_t hdhomerun_channel_entry_channel_number(struct hdhomerun_channel_entry_t *entry ) 
{ 


  {
#line 199
  return (entry->channel_number);
}
}
#line 202 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_channels.c"
uint32_t hdhomerun_channel_entry_frequency(struct hdhomerun_channel_entry_t *entry ) 
{ 


  {
#line 204
  return (entry->frequency);
}
}
#line 207 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_channels.c"
char const   *hdhomerun_channel_entry_name(struct hdhomerun_channel_entry_t *entry ) 
{ 


  {
#line 209
  return ((char const   *)(entry->name));
}
}
#line 212 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_channels.c"
struct hdhomerun_channel_entry_t *hdhomerun_channel_list_first(struct hdhomerun_channel_list_t *channel_list ) 
{ 


  {
#line 214
  return (channel_list->head);
}
}
#line 217 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_channels.c"
struct hdhomerun_channel_entry_t *hdhomerun_channel_list_last(struct hdhomerun_channel_list_t *channel_list ) 
{ 


  {
#line 219
  return (channel_list->tail);
}
}
#line 222 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_channels.c"
struct hdhomerun_channel_entry_t *hdhomerun_channel_list_next(struct hdhomerun_channel_list_t *channel_list ,
                                                              struct hdhomerun_channel_entry_t *entry ) 
{ 


  {
#line 224
  return (entry->next);
}
}
#line 227 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_channels.c"
struct hdhomerun_channel_entry_t *hdhomerun_channel_list_prev(struct hdhomerun_channel_list_t *channel_list ,
                                                              struct hdhomerun_channel_entry_t *entry ) 
{ 


  {
#line 229
  return (entry->prev);
}
}
#line 232 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_channels.c"
uint32_t hdhomerun_channel_list_total_count(struct hdhomerun_channel_list_t *channel_list ) 
{ 
  uint32_t count ;
  struct hdhomerun_channel_entry_t *entry ;
  struct hdhomerun_channel_entry_t *tmp ;

  {
  {
#line 234
  count = (uint32_t )0;
#line 236
  tmp = hdhomerun_channel_list_first(channel_list);
#line 236
  entry = tmp;
  }
  {
#line 237
  while (1) {
    while_continue: /* CIL Label */ ;
#line 237
    if (! entry) {
#line 237
      goto while_break;
    }
    {
#line 238
    count ++;
#line 239
    entry = hdhomerun_channel_list_next(channel_list, entry);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 242
  return (count);
}
}
#line 245 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_channels.c"
uint32_t hdhomerun_channel_list_frequency_count(struct hdhomerun_channel_list_t *channel_list ) 
{ 
  uint32_t count ;
  uint32_t last_frequency ;
  struct hdhomerun_channel_entry_t *entry ;
  struct hdhomerun_channel_entry_t *tmp ;

  {
  {
#line 247
  count = (uint32_t )0;
#line 248
  last_frequency = (uint32_t )0;
#line 250
  tmp = hdhomerun_channel_list_first(channel_list);
#line 250
  entry = tmp;
  }
  {
#line 251
  while (1) {
    while_continue: /* CIL Label */ ;
#line 251
    if (! entry) {
#line 251
      goto while_break;
    }
#line 252
    if (entry->frequency != last_frequency) {
#line 253
      last_frequency = entry->frequency;
#line 254
      count ++;
    }
    {
#line 257
    entry = hdhomerun_channel_list_next(channel_list, entry);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 260
  return (count);
}
}
#line 263 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_channels.c"
uint32_t hdhomerun_channel_frequency_round(uint32_t frequency , uint32_t resolution ) 
{ 


  {
#line 265
  frequency += resolution / 2U;
#line 266
  return ((frequency / resolution) * resolution);
}
}
#line 269 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_channels.c"
uint32_t hdhomerun_channel_frequency_round_normal(uint32_t frequency ) 
{ 
  uint32_t tmp ;

  {
  {
#line 271
  tmp = hdhomerun_channel_frequency_round(frequency, (uint32_t )125000);
  }
#line 271
  return (tmp);
}
}
#line 274 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_channels.c"
uint32_t hdhomerun_channel_number_to_frequency(struct hdhomerun_channel_list_t *channel_list ,
                                               uint16_t channel_number ) 
{ 
  struct hdhomerun_channel_entry_t *entry ;
  struct hdhomerun_channel_entry_t *tmp ;

  {
  {
#line 276
  tmp = hdhomerun_channel_list_first(channel_list);
#line 276
  entry = tmp;
  }
  {
#line 277
  while (1) {
    while_continue: /* CIL Label */ ;
#line 277
    if (! entry) {
#line 277
      goto while_break;
    }
#line 278
    if ((int )entry->channel_number == (int )channel_number) {
#line 279
      return (entry->frequency);
    }
    {
#line 282
    entry = hdhomerun_channel_list_next(channel_list, entry);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 285
  return ((uint32_t )0);
}
}
#line 288 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_channels.c"
uint16_t hdhomerun_channel_frequency_to_number(struct hdhomerun_channel_list_t *channel_list ,
                                               uint32_t frequency ) 
{ 
  struct hdhomerun_channel_entry_t *entry ;
  struct hdhomerun_channel_entry_t *tmp ;

  {
  {
#line 290
  frequency = hdhomerun_channel_frequency_round_normal(frequency);
#line 292
  tmp = hdhomerun_channel_list_first(channel_list);
#line 292
  entry = tmp;
  }
  {
#line 293
  while (1) {
    while_continue: /* CIL Label */ ;
#line 293
    if (! entry) {
#line 293
      goto while_break;
    }
#line 294
    if (entry->frequency == frequency) {
#line 295
      return (entry->channel_number);
    }
#line 297
    if (entry->frequency > frequency) {
#line 298
      return ((uint16_t )0);
    }
    {
#line 301
    entry = hdhomerun_channel_list_next(channel_list, entry);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 304
  return ((uint16_t )0);
}
}
#line 307 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_channels.c"
static void hdhomerun_channel_list_build_insert(struct hdhomerun_channel_list_t *channel_list ,
                                                struct hdhomerun_channel_entry_t *entry ) 
{ 
  struct hdhomerun_channel_entry_t *prev ;
  struct hdhomerun_channel_entry_t *next ;

  {
#line 309
  prev = (struct hdhomerun_channel_entry_t *)((void *)0);
#line 310
  next = channel_list->head;
  {
#line 312
  while (1) {
    while_continue: /* CIL Label */ ;
#line 312
    if (! next) {
#line 312
      goto while_break;
    }
#line 313
    if (next->frequency > entry->frequency) {
#line 314
      goto while_break;
    }
#line 317
    prev = next;
#line 318
    next = next->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 321
  entry->prev = prev;
#line 322
  entry->next = next;
#line 324
  if (prev) {
#line 325
    prev->next = entry;
  } else {
#line 327
    channel_list->head = entry;
  }
#line 330
  if (next) {
#line 331
    next->prev = entry;
  } else {
#line 333
    channel_list->tail = entry;
  }
#line 335
  return;
}
}
#line 337 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_channels.c"
static void hdhomerun_channel_list_build_range(struct hdhomerun_channel_list_t *channel_list ,
                                               char const   *channelmap , struct hdhomerun_channelmap_range_t  const  *range ) 
{ 
  uint16_t channel_number ;
  struct hdhomerun_channel_entry_t *entry ;
  void *tmp ;

  {
#line 340
  channel_number = (uint16_t )range->channel_range_start;
  {
#line 340
  while (1) {
    while_continue: /* CIL Label */ ;
#line 340
    if (! ((int )channel_number <= (int )range->channel_range_end)) {
#line 340
      goto while_break;
    }
    {
#line 341
    tmp = calloc((size_t )1, sizeof(struct hdhomerun_channel_entry_t ));
#line 341
    entry = (struct hdhomerun_channel_entry_t *)tmp;
    }
#line 342
    if (! entry) {
#line 343
      return;
    }
    {
#line 346
    entry->channel_number = channel_number;
#line 347
    entry->frequency = (uint32_t )(range->frequency + (uint32_t const   )((uint32_t )((int )channel_number - (int )range->channel_range_start) * (uint32_t )range->spacing));
#line 348
    entry->frequency = hdhomerun_channel_frequency_round_normal(entry->frequency);
#line 349
    hdhomerun_sprintf(entry->name, entry->name + sizeof(entry->name), "%s:%u", channelmap,
                      (int )entry->channel_number);
#line 351
    hdhomerun_channel_list_build_insert(channel_list, entry);
#line 340
    channel_number = (uint16_t )((int )channel_number + 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 353
  return;
}
}
#line 355 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_channels.c"
static void hdhomerun_channel_list_build_ranges(struct hdhomerun_channel_list_t *channel_list ,
                                                struct hdhomerun_channelmap_record_t  const  *record ) 
{ 
  struct hdhomerun_channelmap_range_t  const  *range ;

  {
#line 357
  range = (struct hdhomerun_channelmap_range_t  const  *)record->range_list;
  {
#line 358
  while (1) {
    while_continue: /* CIL Label */ ;
#line 358
    if (! range->frequency) {
#line 358
      goto while_break;
    }
    {
#line 359
    hdhomerun_channel_list_build_range(channel_list, (char const   *)record->channelmap,
                                       range);
#line 360
    range ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 362
  return;
}
}
#line 364 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_channels.c"
void hdhomerun_channel_list_destroy(struct hdhomerun_channel_list_t *channel_list ) 
{ 
  struct hdhomerun_channel_entry_t *entry ;

  {
  {
#line 366
  while (1) {
    while_continue: /* CIL Label */ ;
#line 366
    if (! channel_list->head) {
#line 366
      goto while_break;
    }
    {
#line 367
    entry = channel_list->head;
#line 368
    channel_list->head = entry->next;
#line 369
    free((void *)entry);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 372
  free((void *)channel_list);
  }
#line 373
  return;
}
}
#line 375 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_channels.c"
struct hdhomerun_channel_list_t *hdhomerun_channel_list_create(char const   *channelmap ) 
{ 
  struct hdhomerun_channel_list_t *channel_list ;
  void *tmp ;
  struct hdhomerun_channelmap_record_t  const  *record ;
  char *tmp___0 ;

  {
  {
#line 377
  tmp = calloc((size_t )1, sizeof(struct hdhomerun_channel_list_t ));
#line 377
  channel_list = (struct hdhomerun_channel_list_t *)tmp;
  }
#line 378
  if (! channel_list) {
#line 379
    return ((struct hdhomerun_channel_list_t *)((void *)0));
  }
#line 382
  record = hdhomerun_channelmap_table;
  {
#line 383
  while (1) {
    while_continue: /* CIL Label */ ;
#line 383
    if (! record->channelmap) {
#line 383
      goto while_break;
    }
    {
#line 384
    tmp___0 = strstr(channelmap, (char const   *)record->channelmap);
    }
#line 384
    if (! tmp___0) {
#line 385
      record ++;
#line 386
      goto while_continue;
    }
    {
#line 389
    hdhomerun_channel_list_build_ranges(channel_list, record);
#line 390
    record ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 393
  if (! channel_list->head) {
    {
#line 394
    free((void *)channel_list);
    }
#line 395
    return ((struct hdhomerun_channel_list_t *)((void *)0));
  }
#line 398
  return (channel_list);
}
}
#line 145 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_pkt.h"
struct hdhomerun_pkt_t *hdhomerun_pkt_create(void) ;
#line 146
void hdhomerun_pkt_destroy(struct hdhomerun_pkt_t *pkt ) ;
#line 149
uint8_t hdhomerun_pkt_read_u8(struct hdhomerun_pkt_t *pkt ) ;
#line 150
uint16_t hdhomerun_pkt_read_u16(struct hdhomerun_pkt_t *pkt ) ;
#line 151
uint32_t hdhomerun_pkt_read_u32(struct hdhomerun_pkt_t *pkt ) ;
#line 152
size_t hdhomerun_pkt_read_var_length(struct hdhomerun_pkt_t *pkt ) ;
#line 156
void hdhomerun_pkt_write_u16(struct hdhomerun_pkt_t *pkt , uint16_t v ) ;
#line 23 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_pkt.c"
struct hdhomerun_pkt_t *hdhomerun_pkt_create(void) 
{ 
  struct hdhomerun_pkt_t *pkt ;
  void *tmp ;

  {
  {
#line 25
  tmp = calloc((size_t )1, sizeof(struct hdhomerun_pkt_t ));
#line 25
  pkt = (struct hdhomerun_pkt_t *)tmp;
  }
#line 26
  if (! pkt) {
#line 27
    return ((struct hdhomerun_pkt_t *)((void *)0));
  }
  {
#line 30
  hdhomerun_pkt_reset(pkt);
  }
#line 32
  return (pkt);
}
}
#line 35 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_pkt.c"
void hdhomerun_pkt_destroy(struct hdhomerun_pkt_t *pkt ) 
{ 


  {
  {
#line 37
  free((void *)pkt);
  }
#line 38
  return;
}
}
#line 40 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_pkt.c"
void hdhomerun_pkt_reset(struct hdhomerun_pkt_t *pkt ) 
{ 


  {
#line 42
  pkt->limit = (pkt->buffer + sizeof(pkt->buffer)) - 4;
#line 43
  pkt->start = pkt->buffer + 1024;
#line 44
  pkt->end = pkt->start;
#line 45
  pkt->pos = pkt->start;
#line 46
  return;
}
}
#line 48 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_pkt.c"
static uint32_t hdhomerun_pkt_calc_crc(uint8_t *start , uint8_t *end ) 
{ 
  uint8_t *pos ;
  uint32_t crc ;
  uint8_t x ;
  uint8_t *tmp ;

  {
#line 50
  pos = start;
#line 51
  crc = 4294967295U;
  {
#line 52
  while (1) {
    while_continue: /* CIL Label */ ;
#line 52
    if (! ((unsigned long )pos < (unsigned long )end)) {
#line 52
      goto while_break;
    }
#line 53
    tmp = pos;
#line 53
    pos ++;
#line 53
    x = (uint8_t )((int )((uint8_t )crc) ^ (int )*tmp);
#line 54
    crc >>= 8;
#line 55
    if ((int )x & 1) {
#line 55
      crc ^= 1996959894U;
    }
#line 56
    if ((int )x & 2) {
#line 56
      crc ^= 3993919788U;
    }
#line 57
    if ((int )x & 4) {
#line 57
      crc ^= 124634137U;
    }
#line 58
    if ((int )x & 8) {
#line 58
      crc ^= 249268274U;
    }
#line 59
    if ((int )x & 16) {
#line 59
      crc ^= 498536548U;
    }
#line 60
    if ((int )x & 32) {
#line 60
      crc ^= 997073096U;
    }
#line 61
    if ((int )x & 64) {
#line 61
      crc ^= 1994146192U;
    }
#line 62
    if ((int )x & 128) {
#line 62
      crc ^= 3988292384U;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 64
  return (crc ^ 4294967295U);
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_pkt.c"
uint8_t hdhomerun_pkt_read_u8(struct hdhomerun_pkt_t *pkt ) 
{ 
  uint8_t v ;
  uint8_t *tmp ;

  {
#line 69
  tmp = pkt->pos;
#line 69
  (pkt->pos) ++;
#line 69
  v = *tmp;
#line 70
  return (v);
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_pkt.c"
uint16_t hdhomerun_pkt_read_u16(struct hdhomerun_pkt_t *pkt ) 
{ 
  uint16_t v ;
  uint8_t *tmp ;
  uint8_t *tmp___0 ;

  {
#line 76
  tmp = pkt->pos;
#line 76
  (pkt->pos) ++;
#line 76
  v = (uint16_t )((int )((uint16_t )*tmp) << 8);
#line 77
  tmp___0 = pkt->pos;
#line 77
  (pkt->pos) ++;
#line 77
  v = (uint16_t )((int )v | (int )((uint16_t )*tmp___0));
#line 78
  return (v);
}
}
#line 81 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_pkt.c"
uint32_t hdhomerun_pkt_read_u32(struct hdhomerun_pkt_t *pkt ) 
{ 
  uint32_t v ;
  uint8_t *tmp ;
  uint8_t *tmp___0 ;
  uint8_t *tmp___1 ;
  uint8_t *tmp___2 ;

  {
#line 84
  tmp = pkt->pos;
#line 84
  (pkt->pos) ++;
#line 84
  v = (uint32_t )*tmp << 24;
#line 85
  tmp___0 = pkt->pos;
#line 85
  (pkt->pos) ++;
#line 85
  v |= (uint32_t )*tmp___0 << 16;
#line 86
  tmp___1 = pkt->pos;
#line 86
  (pkt->pos) ++;
#line 86
  v |= (uint32_t )*tmp___1 << 8;
#line 87
  tmp___2 = pkt->pos;
#line 87
  (pkt->pos) ++;
#line 87
  v |= (uint32_t )*tmp___2;
#line 88
  return (v);
}
}
#line 91 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_pkt.c"
size_t hdhomerun_pkt_read_var_length(struct hdhomerun_pkt_t *pkt ) 
{ 
  size_t length ;
  uint8_t *tmp ;
  uint8_t *tmp___0 ;

  {
#line 95
  if ((unsigned long )(pkt->pos + 1) > (unsigned long )pkt->end) {
#line 96
    return ((size_t )-1);
  }
#line 99
  tmp = pkt->pos;
#line 99
  (pkt->pos) ++;
#line 99
  length = (size_t )*tmp;
#line 100
  if (length & 128UL) {
#line 101
    if ((unsigned long )(pkt->pos + 1) > (unsigned long )pkt->end) {
#line 102
      return ((size_t )-1);
    }
#line 105
    length &= 127UL;
#line 106
    tmp___0 = pkt->pos;
#line 106
    (pkt->pos) ++;
#line 106
    length |= (size_t )*tmp___0 << 7;
  }
#line 109
  return (length);
}
}
#line 112 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_pkt.c"
uint8_t *hdhomerun_pkt_read_tlv(struct hdhomerun_pkt_t *pkt , uint8_t *ptag , size_t *plength ) 
{ 


  {
#line 114
  if ((unsigned long )(pkt->pos + 2) > (unsigned long )pkt->end) {
#line 115
    return ((uint8_t *)((void *)0));
  }
  {
#line 118
  *ptag = hdhomerun_pkt_read_u8(pkt);
#line 119
  *plength = hdhomerun_pkt_read_var_length(pkt);
  }
#line 121
  if ((unsigned long )(pkt->pos + *plength) > (unsigned long )pkt->end) {
#line 122
    return ((uint8_t *)((void *)0));
  }
#line 125
  return (pkt->pos + *plength);
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_pkt.c"
void hdhomerun_pkt_write_u8(struct hdhomerun_pkt_t *pkt , uint8_t v ) 
{ 
  uint8_t *tmp ;

  {
#line 130
  tmp = pkt->pos;
#line 130
  (pkt->pos) ++;
#line 130
  *tmp = v;
#line 132
  if ((unsigned long )pkt->pos > (unsigned long )pkt->end) {
#line 133
    pkt->end = pkt->pos;
  }
#line 135
  return;
}
}
#line 137 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_pkt.c"
void hdhomerun_pkt_write_u16(struct hdhomerun_pkt_t *pkt , uint16_t v ) 
{ 
  uint8_t *tmp ;
  uint8_t *tmp___0 ;

  {
#line 139
  tmp = pkt->pos;
#line 139
  (pkt->pos) ++;
#line 139
  *tmp = (uint8_t )((int )v >> 8);
#line 140
  tmp___0 = pkt->pos;
#line 140
  (pkt->pos) ++;
#line 140
  *tmp___0 = (uint8_t )((int )v);
#line 142
  if ((unsigned long )pkt->pos > (unsigned long )pkt->end) {
#line 143
    pkt->end = pkt->pos;
  }
#line 145
  return;
}
}
#line 147 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_pkt.c"
void hdhomerun_pkt_write_u32(struct hdhomerun_pkt_t *pkt , uint32_t v ) 
{ 
  uint8_t *tmp ;
  uint8_t *tmp___0 ;
  uint8_t *tmp___1 ;
  uint8_t *tmp___2 ;

  {
#line 149
  tmp = pkt->pos;
#line 149
  (pkt->pos) ++;
#line 149
  *tmp = (uint8_t )(v >> 24);
#line 150
  tmp___0 = pkt->pos;
#line 150
  (pkt->pos) ++;
#line 150
  *tmp___0 = (uint8_t )(v >> 16);
#line 151
  tmp___1 = pkt->pos;
#line 151
  (pkt->pos) ++;
#line 151
  *tmp___1 = (uint8_t )(v >> 8);
#line 152
  tmp___2 = pkt->pos;
#line 152
  (pkt->pos) ++;
#line 152
  *tmp___2 = (uint8_t )v;
#line 154
  if ((unsigned long )pkt->pos > (unsigned long )pkt->end) {
#line 155
    pkt->end = pkt->pos;
  }
#line 157
  return;
}
}
#line 159 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_pkt.c"
void hdhomerun_pkt_write_var_length(struct hdhomerun_pkt_t *pkt , size_t v ) 
{ 
  uint8_t *tmp ;
  uint8_t *tmp___0 ;
  uint8_t *tmp___1 ;

  {
#line 161
  if (v <= 127UL) {
#line 162
    tmp = pkt->pos;
#line 162
    (pkt->pos) ++;
#line 162
    *tmp = (uint8_t )v;
  } else {
#line 164
    tmp___0 = pkt->pos;
#line 164
    (pkt->pos) ++;
#line 164
    *tmp___0 = (uint8_t )(v | 128UL);
#line 165
    tmp___1 = pkt->pos;
#line 165
    (pkt->pos) ++;
#line 165
    *tmp___1 = (uint8_t )(v >> 7);
  }
#line 168
  if ((unsigned long )pkt->pos > (unsigned long )pkt->end) {
#line 169
    pkt->end = pkt->pos;
  }
#line 171
  return;
}
}
#line 173 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_pkt.c"
void hdhomerun_pkt_write_mem(struct hdhomerun_pkt_t *pkt , void const   *mem , size_t length ) 
{ 


  {
  {
#line 175
  memcpy((void */* __restrict  */)pkt->pos, (void const   */* __restrict  */)mem,
         length);
#line 176
  pkt->pos += length;
  }
#line 178
  if ((unsigned long )pkt->pos > (unsigned long )pkt->end) {
#line 179
    pkt->end = pkt->pos;
  }
#line 181
  return;
}
}
#line 183 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_pkt.c"
int hdhomerun_pkt_open_frame(struct hdhomerun_pkt_t *pkt , uint16_t *ptype ) 
{ 
  size_t length ;
  uint16_t tmp ;
  uint32_t calc_crc ;
  uint32_t tmp___0 ;
  uint32_t packet_crc ;
  uint8_t *tmp___1 ;
  uint8_t *tmp___2 ;
  uint8_t *tmp___3 ;
  uint8_t *tmp___4 ;

  {
#line 185
  pkt->pos = pkt->start;
#line 187
  if ((unsigned long )(pkt->pos + 4) > (unsigned long )pkt->end) {
#line 188
    return (0);
  }
  {
#line 191
  *ptype = hdhomerun_pkt_read_u16(pkt);
#line 192
  tmp = hdhomerun_pkt_read_u16(pkt);
#line 192
  length = (size_t )tmp;
#line 193
  pkt->pos += length;
  }
#line 195
  if ((unsigned long )(pkt->pos + 4) > (unsigned long )pkt->end) {
#line 196
    pkt->pos = pkt->start;
#line 197
    return (0);
  }
  {
#line 200
  tmp___0 = hdhomerun_pkt_calc_crc(pkt->start, pkt->pos);
#line 200
  calc_crc = tmp___0;
#line 203
  tmp___1 = pkt->pos;
#line 203
  (pkt->pos) ++;
#line 203
  packet_crc = (uint32_t )*tmp___1;
#line 204
  tmp___2 = pkt->pos;
#line 204
  (pkt->pos) ++;
#line 204
  packet_crc |= (uint32_t )*tmp___2 << 8;
#line 205
  tmp___3 = pkt->pos;
#line 205
  (pkt->pos) ++;
#line 205
  packet_crc |= (uint32_t )*tmp___3 << 16;
#line 206
  tmp___4 = pkt->pos;
#line 206
  (pkt->pos) ++;
#line 206
  packet_crc |= (uint32_t )*tmp___4 << 24;
  }
#line 207
  if (calc_crc != packet_crc) {
#line 208
    return (-1);
  }
#line 211
  pkt->start += 4;
#line 212
  pkt->end = pkt->start + length;
#line 213
  pkt->pos = pkt->start;
#line 214
  return (1);
}
}
#line 217 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_pkt.c"
void hdhomerun_pkt_seal_frame(struct hdhomerun_pkt_t *pkt , uint16_t frame_type ) 
{ 
  size_t length ;
  uint32_t crc ;
  uint32_t tmp ;
  uint8_t *tmp___0 ;
  uint8_t *tmp___1 ;
  uint8_t *tmp___2 ;
  uint8_t *tmp___3 ;

  {
  {
#line 219
  length = (size_t )(pkt->end - pkt->start);
#line 221
  pkt->start -= 4;
#line 222
  pkt->pos = pkt->start;
#line 223
  hdhomerun_pkt_write_u16(pkt, frame_type);
#line 224
  hdhomerun_pkt_write_u16(pkt, (uint16_t )length);
#line 226
  tmp = hdhomerun_pkt_calc_crc(pkt->start, pkt->end);
#line 226
  crc = tmp;
#line 227
  tmp___0 = pkt->end;
#line 227
  (pkt->end) ++;
#line 227
  *tmp___0 = (uint8_t )crc;
#line 228
  tmp___1 = pkt->end;
#line 228
  (pkt->end) ++;
#line 228
  *tmp___1 = (uint8_t )(crc >> 8);
#line 229
  tmp___2 = pkt->end;
#line 229
  (pkt->end) ++;
#line 229
  *tmp___2 = (uint8_t )(crc >> 16);
#line 230
  tmp___3 = pkt->end;
#line 230
  (pkt->end) ++;
#line 230
  *tmp___3 = (uint8_t )(crc >> 24);
#line 232
  pkt->pos = pkt->start;
  }
#line 233
  return;
}
}
#line 244 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t * __restrict  __newthread ,
                                                                                             pthread_attr_t const   * __restrict  __attr ,
                                                                                             void *(*__start_routine)(void * ) ,
                                                                                             void * __restrict  __arg ) ;
#line 261
extern int pthread_join(pthread_t __th , void **__thread_return ) ;
#line 760
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutex_init)(pthread_mutex_t *__mutex ,
                                                                                                         pthread_mutexattr_t const   *__mutexattr ) ;
#line 100 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_video.h"
hdhomerun_sock_t hdhomerun_video_get_sock(struct hdhomerun_video_sock_t *vs ) ;
#line 47 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_video.c"
static void *hdhomerun_video_thread_execute(void *arg ) ;
#line 49 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_video.c"
struct hdhomerun_video_sock_t *hdhomerun_video_create(uint16_t listen_port , bool_t allow_port_reuse ,
                                                      size_t buffer_size , struct hdhomerun_debug_t *dbg ) 
{ 
  struct hdhomerun_video_sock_t *vs ;
  void *tmp ;
  void *tmp___0 ;
  int rx_size ;
  bool_t tmp___1 ;
  int tmp___2 ;

  {
  {
#line 52
  tmp = calloc((size_t )1, sizeof(struct hdhomerun_video_sock_t ));
#line 52
  vs = (struct hdhomerun_video_sock_t *)tmp;
  }
#line 53
  if (! vs) {
    {
#line 54
    hdhomerun_debug_printf(dbg, "hdhomerun_video_create: failed to allocate video object\n");
    }
#line 55
    return ((struct hdhomerun_video_sock_t *)((void *)0));
  }
  {
#line 58
  vs->dbg = dbg;
#line 59
  vs->sock = -1;
#line 60
  pthread_mutex_init(& vs->lock, (pthread_mutexattr_t const   *)((void *)0));
#line 63
  hdhomerun_video_flush(vs);
#line 66
  vs->buffer_size = (buffer_size / 1316UL) * 1316UL;
  }
#line 67
  if (vs->buffer_size == 0UL) {
    {
#line 68
    hdhomerun_debug_printf(dbg, "hdhomerun_video_create: invalid buffer size (%lu bytes)\n",
                           buffer_size);
    }
#line 69
    goto error;
  }
  {
#line 71
  vs->buffer_size += 1316UL;
#line 74
  tmp___0 = malloc(vs->buffer_size);
#line 74
  vs->buffer = (uint8_t *)tmp___0;
  }
#line 75
  if (! vs->buffer) {
    {
#line 76
    hdhomerun_debug_printf(dbg, "hdhomerun_video_create: failed to allocate buffer (%lu bytes)\n",
                           vs->buffer_size);
    }
#line 77
    goto error;
  }
  {
#line 81
  vs->sock = hdhomerun_sock_create_udp();
  }
#line 82
  if (vs->sock == -1) {
    {
#line 83
    hdhomerun_debug_printf(dbg, "hdhomerun_video_create: failed to allocate socket\n");
    }
#line 84
    goto error;
  }
  {
#line 88
  rx_size = 1048576;
#line 89
  setsockopt(vs->sock, 1, 8, (void const   *)((char *)(& rx_size)), (socklen_t )sizeof(rx_size));
#line 92
  tmp___1 = hdhomerun_sock_bind(vs->sock, (in_addr_t )0, listen_port, allow_port_reuse);
  }
#line 92
  if (! tmp___1) {
    {
#line 93
    hdhomerun_debug_printf(dbg, "hdhomerun_video_create: failed to bind socket (port %u)\n",
                           (int )listen_port);
    }
#line 94
    goto error;
  }
  {
#line 98
  tmp___2 = pthread_create((pthread_t */* __restrict  */)(& vs->thread), (pthread_attr_t const   */* __restrict  */)((void *)0),
                           & hdhomerun_video_thread_execute, (void */* __restrict  */)vs);
  }
#line 98
  if (tmp___2 != 0) {
    {
#line 99
    hdhomerun_debug_printf(dbg, "hdhomerun_video_create: failed to start thread\n");
    }
#line 100
    goto error;
  }
#line 104
  return (vs);
  error: 
#line 107
  if (vs->sock != -1) {
    {
#line 108
    hdhomerun_sock_destroy(vs->sock);
    }
  }
#line 110
  if (vs->buffer) {
    {
#line 111
    free((void *)vs->buffer);
    }
  }
  {
#line 113
  free((void *)vs);
  }
#line 114
  return ((struct hdhomerun_video_sock_t *)((void *)0));
}
}
#line 117 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_video.c"
void hdhomerun_video_destroy(struct hdhomerun_video_sock_t *vs ) 
{ 


  {
  {
#line 119
  vs->terminate = (bool_t volatile   )1;
#line 120
  pthread_join(vs->thread, (void **)((void *)0));
#line 122
  hdhomerun_sock_destroy(vs->sock);
#line 123
  free((void *)vs->buffer);
#line 125
  free((void *)vs);
  }
#line 126
  return;
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_video.c"
hdhomerun_sock_t hdhomerun_video_get_sock(struct hdhomerun_video_sock_t *vs ) 
{ 


  {
#line 130
  return (vs->sock);
}
}
#line 133 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_video.c"
uint16_t hdhomerun_video_get_local_port(struct hdhomerun_video_sock_t *vs ) 
{ 
  uint16_t port ;
  uint16_t tmp ;
  int tmp___0 ;

  {
  {
#line 135
  tmp = hdhomerun_sock_getsockname_port(vs->sock);
#line 135
  port = tmp;
  }
#line 136
  if ((int )port == 0) {
    {
#line 137
    tmp___0 = hdhomerun_sock_getlasterror();
#line 137
    hdhomerun_debug_printf(vs->dbg, "hdhomerun_video_get_local_port: getsockname failed (%d)\n",
                           tmp___0);
    }
#line 138
    return ((uint16_t )0);
  }
#line 141
  return (port);
}
}
#line 144 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_video.c"
int hdhomerun_video_join_multicast_group(struct hdhomerun_video_sock_t *vs , uint32_t multicast_ip ,
                                         uint32_t local_ip ) 
{ 
  int tmp ;
  bool_t tmp___0 ;

  {
  {
#line 146
  tmp___0 = hdhomerun_sock_join_multicast_group(vs->sock, multicast_ip, local_ip);
  }
#line 146
  if (! tmp___0) {
    {
#line 147
    tmp = hdhomerun_sock_getlasterror();
#line 147
    hdhomerun_debug_printf(vs->dbg, "hdhomerun_video_join_multicast_group: setsockopt failed (%d)\n",
                           tmp);
    }
#line 148
    return (-1);
  }
#line 151
  return (1);
}
}
#line 154 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_video.c"
void hdhomerun_video_leave_multicast_group(struct hdhomerun_video_sock_t *vs , uint32_t multicast_ip ,
                                           uint32_t local_ip ) 
{ 
  int tmp ;
  bool_t tmp___0 ;

  {
  {
#line 156
  tmp___0 = hdhomerun_sock_leave_multicast_group(vs->sock, multicast_ip, local_ip);
  }
#line 156
  if (! tmp___0) {
    {
#line 157
    tmp = hdhomerun_sock_getlasterror();
#line 157
    hdhomerun_debug_printf(vs->dbg, "hdhomerun_video_leave_multicast_group: setsockopt failed (%d)\n",
                           tmp);
    }
  }
#line 159
  return;
}
}
#line 161 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_video.c"
static void hdhomerun_video_stats_ts_pkt(struct hdhomerun_video_sock_t *vs , uint8_t *ptr ) 
{ 
  uint16_t packet_identifier ;
  bool_t transport_error ;
  uint8_t sequence ;
  uint8_t previous_sequence ;

  {
#line 163
  packet_identifier = (uint16_t )(((int )((uint16_t )((int )*(ptr + 1) & 31)) << 8) | (int )((uint16_t )*(ptr + 2)));
#line 164
  if ((int )packet_identifier == 8191) {
#line 165
    return;
  }
#line 168
  transport_error = (int )*(ptr + 1) >> 7;
#line 169
  if (transport_error) {
#line 170
    vs->transport_error_count += (uint32_t volatile   )1;
#line 171
    vs->sequence[packet_identifier] = (uint8_t volatile   )255;
#line 172
    return;
  }
#line 175
  sequence = (uint8_t )((int )*(ptr + 3) & 15);
#line 177
  previous_sequence = (uint8_t )vs->sequence[packet_identifier];
#line 178
  vs->sequence[packet_identifier] = (uint8_t volatile   )sequence;
#line 180
  if ((int )previous_sequence == 255) {
#line 181
    return;
  }
#line 183
  if ((int )sequence == (((int )previous_sequence + 1) & 15)) {
#line 184
    return;
  }
#line 186
  if ((int )sequence == (int )previous_sequence) {
#line 187
    return;
  }
#line 190
  vs->sequence_error_count += (uint32_t volatile   )1;
#line 191
  return;
}
}
#line 193 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_video.c"
static void hdhomerun_video_parse_rtp(struct hdhomerun_video_sock_t *vs , struct hdhomerun_pkt_t *pkt ) 
{ 
  uint32_t rtp_sequence ;
  uint16_t tmp ;
  uint32_t previous_rtp_sequence ;
  int i ;

  {
  {
#line 195
  pkt->pos += 2;
#line 196
  tmp = hdhomerun_pkt_read_u16(pkt);
#line 196
  rtp_sequence = (uint32_t )tmp;
#line 197
  pkt->pos += 8;
#line 199
  previous_rtp_sequence = (uint32_t )vs->rtp_sequence;
#line 200
  vs->rtp_sequence = (uint32_t volatile   )rtp_sequence;
  }
#line 203
  if (previous_rtp_sequence == 4294967295U) {
#line 204
    return;
  }
#line 208
  if (rtp_sequence == ((previous_rtp_sequence + 1U) & 65535U)) {
#line 209
    return;
  }
#line 213
  vs->network_error_count += (uint32_t volatile   )1;
#line 217
  i = 0;
  {
#line 217
  while (1) {
    while_continue: /* CIL Label */ ;
#line 217
    if (! (i < 8192)) {
#line 217
      goto while_break;
    }
#line 218
    vs->sequence[i] = (uint8_t volatile   )255;
#line 217
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 220
  return;
}
}
#line 222 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_video.c"
static void *hdhomerun_video_thread_execute(void *arg ) 
{ 
  struct hdhomerun_video_sock_t *vs ;
  struct hdhomerun_pkt_t pkt_inst ;
  struct hdhomerun_pkt_t *pkt ;
  size_t length ;
  bool_t tmp ;
  size_t head ;
  uint8_t *ptr ;

  {
#line 224
  vs = (struct hdhomerun_video_sock_t *)arg;
  {
#line 227
  while (1) {
    while_continue: /* CIL Label */ ;
#line 227
    if (! (! vs->terminate)) {
#line 227
      goto while_break;
    }
    {
#line 228
    pkt = & pkt_inst;
#line 229
    hdhomerun_pkt_reset(pkt);
#line 232
    length = (size_t )1328;
#line 233
    tmp = hdhomerun_sock_recv(vs->sock, (void *)pkt->end, & length, (uint64_t )25);
    }
#line 233
    if (! tmp) {
#line 234
      goto while_continue;
    }
#line 237
    pkt->end += length;
#line 239
    if (length == 1328UL) {
      {
#line 240
      hdhomerun_video_parse_rtp(vs, pkt);
#line 241
      length = (size_t )((int )(pkt->end - pkt->pos));
      }
    }
#line 244
    if (length != 1316UL) {
#line 246
      goto while_continue;
    }
    {
#line 249
    pthread_mutex_lock(& vs->lock);
#line 252
    head = (size_t )vs->head;
#line 253
    ptr = vs->buffer + head;
#line 254
    memcpy((void */* __restrict  */)ptr, (void const   */* __restrict  */)pkt->pos,
           length);
#line 257
    vs->packet_count += (uint32_t volatile   )1;
#line 258
    hdhomerun_video_stats_ts_pkt(vs, ptr + 0);
#line 259
    hdhomerun_video_stats_ts_pkt(vs, ptr + 188);
#line 260
    hdhomerun_video_stats_ts_pkt(vs, ptr + 376);
#line 261
    hdhomerun_video_stats_ts_pkt(vs, ptr + 564);
#line 262
    hdhomerun_video_stats_ts_pkt(vs, ptr + 752);
#line 263
    hdhomerun_video_stats_ts_pkt(vs, ptr + 940);
#line 264
    hdhomerun_video_stats_ts_pkt(vs, ptr + 1128);
#line 267
    head += length;
    }
#line 268
    if (head >= vs->buffer_size) {
#line 269
      head -= vs->buffer_size;
    }
#line 273
    if (head == (size_t )vs->tail) {
      {
#line 274
      vs->overflow_error_count += (uint32_t volatile   )1;
#line 275
      pthread_mutex_unlock(& vs->lock);
      }
#line 276
      goto while_continue;
    }
    {
#line 279
    vs->head = (size_t volatile   )head;
#line 281
    pthread_mutex_unlock(& vs->lock);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 284
  return ((void *)0);
}
}
#line 287 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_video.c"
uint8_t *hdhomerun_video_recv(struct hdhomerun_video_sock_t *vs , size_t max_size ,
                              size_t *pactual_size ) 
{ 
  size_t head ;
  size_t tail ;
  size_t size ;
  size_t avail ;
  uint8_t *result___1 ;

  {
  {
#line 289
  pthread_mutex_lock(& vs->lock);
#line 291
  head = (size_t )vs->head;
#line 292
  tail = (size_t )vs->tail;
  }
#line 294
  if (vs->advance > 0UL) {
#line 295
    tail += vs->advance;
#line 296
    if (tail >= vs->buffer_size) {
#line 297
      tail -= vs->buffer_size;
    }
#line 300
    vs->tail = (size_t volatile   )tail;
  }
#line 303
  if (head == tail) {
    {
#line 304
    vs->advance = (size_t )0;
#line 305
    *pactual_size = (size_t )0;
#line 306
    pthread_mutex_unlock(& vs->lock);
    }
#line 307
    return ((uint8_t *)((void *)0));
  }
#line 310
  size = (max_size / 1316UL) * 1316UL;
#line 311
  if (size == 0UL) {
    {
#line 312
    vs->advance = (size_t )0;
#line 313
    *pactual_size = (size_t )0;
#line 314
    pthread_mutex_unlock(& vs->lock);
    }
#line 315
    return ((uint8_t *)((void *)0));
  }
#line 319
  if (head > tail) {
#line 320
    avail = head - tail;
  } else {
#line 322
    avail = vs->buffer_size - tail;
  }
#line 324
  if (size > avail) {
#line 325
    size = avail;
  }
  {
#line 327
  vs->advance = size;
#line 328
  *pactual_size = size;
#line 329
  result___1 = vs->buffer + tail;
#line 331
  pthread_mutex_unlock(& vs->lock);
  }
#line 332
  return (result___1);
}
}
#line 335 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_video.c"
void hdhomerun_video_flush(struct hdhomerun_video_sock_t *vs ) 
{ 
  int i ;

  {
  {
#line 337
  pthread_mutex_lock(& vs->lock);
#line 339
  vs->tail = vs->head;
#line 340
  vs->advance = (size_t )0;
#line 342
  vs->rtp_sequence = (uint32_t volatile   )4294967295U;
#line 345
  i = 0;
  }
  {
#line 345
  while (1) {
    while_continue: /* CIL Label */ ;
#line 345
    if (! (i < 8192)) {
#line 345
      goto while_break;
    }
#line 346
    vs->sequence[i] = (uint8_t volatile   )255;
#line 345
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 349
  vs->packet_count = (uint32_t volatile   )0;
#line 350
  vs->transport_error_count = (uint32_t volatile   )0;
#line 351
  vs->network_error_count = (uint32_t volatile   )0;
#line 352
  vs->sequence_error_count = (uint32_t volatile   )0;
#line 353
  vs->overflow_error_count = (uint32_t volatile   )0;
#line 355
  pthread_mutex_unlock(& vs->lock);
  }
#line 356
  return;
}
}
#line 358 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_video.c"
void hdhomerun_video_debug_print_stats(struct hdhomerun_video_sock_t *vs ) 
{ 
  struct hdhomerun_video_stats_t stats ;

  {
  {
#line 361
  hdhomerun_video_get_stats(vs, & stats);
#line 363
  hdhomerun_debug_printf(vs->dbg, "video sock: pkt=%u net=%u te=%u miss=%u drop=%u\n",
                         stats.packet_count, stats.network_error_count, stats.transport_error_count,
                         stats.sequence_error_count, stats.overflow_error_count);
  }
#line 368
  return;
}
}
#line 370 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_video.c"
void hdhomerun_video_get_stats(struct hdhomerun_video_sock_t *vs , struct hdhomerun_video_stats_t *stats ) 
{ 


  {
  {
#line 372
  memset((void *)stats, 0, sizeof(struct hdhomerun_video_stats_t ));
#line 374
  pthread_mutex_lock(& vs->lock);
#line 376
  stats->packet_count = (uint32_t )vs->packet_count;
#line 377
  stats->network_error_count = (uint32_t )vs->network_error_count;
#line 378
  stats->transport_error_count = (uint32_t )vs->transport_error_count;
#line 379
  stats->sequence_error_count = (uint32_t )vs->sequence_error_count;
#line 380
  stats->overflow_error_count = (uint32_t )vs->overflow_error_count;
#line 382
  pthread_mutex_unlock(& vs->lock);
  }
#line 383
  return;
}
}
#line 50 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_discover.h"
struct hdhomerun_discover_t *hdhomerun_discover_create(struct hdhomerun_debug_t *dbg ) ;
#line 51
void hdhomerun_discover_destroy(struct hdhomerun_discover_t *ds ) ;
#line 52
int hdhomerun_discover_find_devices(struct hdhomerun_discover_t *ds , uint32_t target_ip ,
                                    uint32_t device_type , uint32_t device_id , struct hdhomerun_discover_device_t *result_list ,
                                    int max_count ) ;
#line 63
bool_t hdhomerun_discover_validate_device_id(uint32_t device_id ) ;
#line 40 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_discover.c"
static bool_t hdhomerun_discover_sock_add(struct hdhomerun_discover_t *ds , uint32_t local_ip ,
                                          uint32_t subnet_mask ) 
{ 
  unsigned int i ;
  struct hdhomerun_discover_sock_t *dss ;
  hdhomerun_sock_t sock ;
  hdhomerun_sock_t tmp ;
  bool_t tmp___0 ;
  struct hdhomerun_discover_sock_t *dss___0 ;
  unsigned int tmp___1 ;

  {
#line 43
  i = 1U;
  {
#line 43
  while (1) {
    while_continue: /* CIL Label */ ;
#line 43
    if (! (i < ds->sock_count)) {
#line 43
      goto while_break;
    }
#line 44
    dss = & ds->socks[i];
#line 46
    if (dss->local_ip == local_ip) {
#line 46
      if (dss->subnet_mask == subnet_mask) {
#line 47
        dss->detected = 1;
#line 48
        return (1);
      }
    }
#line 43
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 52
  if (ds->sock_count >= 16U) {
#line 53
    return (0);
  }
  {
#line 57
  tmp = hdhomerun_sock_create_udp();
#line 57
  sock = tmp;
  }
#line 58
  if (sock == -1) {
#line 59
    return (0);
  }
  {
#line 63
  tmp___0 = hdhomerun_sock_bind(sock, local_ip, (uint16_t )0, 0);
  }
#line 63
  if (! tmp___0) {
    {
#line 64
    hdhomerun_debug_printf(ds->dbg, "discover: failed to bind to %u.%u.%u.%u:0\n",
                           (local_ip >> 24) & 255U, (local_ip >> 16) & 255U, (local_ip >> 8) & 255U,
                           local_ip & 255U);
#line 65
    hdhomerun_sock_destroy(sock);
    }
#line 66
    return (0);
  }
#line 70
  tmp___1 = ds->sock_count;
#line 70
  (ds->sock_count) ++;
#line 70
  dss___0 = & ds->socks[tmp___1];
#line 71
  dss___0->sock = sock;
#line 72
  dss___0->detected = 1;
#line 73
  dss___0->local_ip = local_ip;
#line 74
  dss___0->subnet_mask = subnet_mask;
#line 76
  return (1);
}
}
#line 79 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_discover.c"
struct hdhomerun_discover_t *hdhomerun_discover_create(struct hdhomerun_debug_t *dbg ) 
{ 
  struct hdhomerun_discover_t *ds ;
  void *tmp ;
  bool_t tmp___0 ;

  {
  {
#line 81
  tmp = calloc((size_t )1, sizeof(struct hdhomerun_discover_t ));
#line 81
  ds = (struct hdhomerun_discover_t *)tmp;
  }
#line 82
  if (! ds) {
#line 83
    return ((struct hdhomerun_discover_t *)((void *)0));
  }
  {
#line 86
  ds->dbg = dbg;
#line 89
  tmp___0 = hdhomerun_discover_sock_add(ds, (uint32_t )0, (uint32_t )0);
  }
#line 89
  if (! tmp___0) {
    {
#line 90
    free((void *)ds);
    }
#line 91
    return ((struct hdhomerun_discover_t *)((void *)0));
  }
#line 95
  return (ds);
}
}
#line 98 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_discover.c"
void hdhomerun_discover_destroy(struct hdhomerun_discover_t *ds ) 
{ 
  unsigned int i ;
  struct hdhomerun_discover_sock_t *dss ;

  {
#line 101
  i = 0U;
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;
#line 101
    if (! (i < ds->sock_count)) {
#line 101
      goto while_break;
    }
    {
#line 102
    dss = & ds->socks[i];
#line 103
    hdhomerun_sock_destroy(dss->sock);
#line 101
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 106
  free((void *)ds);
  }
#line 107
  return;
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_discover.c"
static void hdhomerun_discover_sock_detect(struct hdhomerun_discover_t *ds ) 
{ 
  unsigned int i ;
  struct hdhomerun_discover_sock_t *dss ;
  struct hdhomerun_local_ip_info_t ip_info_list[16] ;
  int count ;
  int tmp ;
  int index___0 ;
  struct hdhomerun_local_ip_info_t *ip_info ;
  struct hdhomerun_discover_sock_t *src ;
  struct hdhomerun_discover_sock_t *dst ;

  {
#line 112
  i = 1U;
  {
#line 112
  while (1) {
    while_continue: /* CIL Label */ ;
#line 112
    if (! (i < ds->sock_count)) {
#line 112
      goto while_break;
    }
#line 113
    dss = & ds->socks[i];
#line 114
    dss->detected = 0;
#line 112
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 118
  tmp = hdhomerun_local_ip_info(ip_info_list, 16);
#line 118
  count = tmp;
  }
#line 119
  if (count < 0) {
    {
#line 120
    hdhomerun_debug_printf(ds->dbg, "discover: hdhomerun_local_ip_info returned error\n");
#line 121
    count = 0;
    }
  }
#line 123
  if (count > 16) {
    {
#line 124
    hdhomerun_debug_printf(ds->dbg, "discover: too many local IP addresses\n");
#line 125
    count = 16;
    }
  }
#line 129
  index___0 = 0;
  {
#line 129
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 129
    if (! (index___0 < count)) {
#line 129
      goto while_break___0;
    }
    {
#line 130
    ip_info = & ip_info_list[index___0];
#line 131
    hdhomerun_discover_sock_add(ds, ip_info->ip_addr, ip_info->subnet_mask);
#line 129
    index___0 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 134
  src = & ds->socks[1];
#line 135
  dst = & ds->socks[1];
#line 136
  count = 1;
#line 137
  i = 1U;
  {
#line 137
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 137
    if (! (i < ds->sock_count)) {
#line 137
      goto while_break___1;
    }
#line 138
    if (! src->detected) {
      {
#line 139
      hdhomerun_sock_destroy(src->sock);
#line 140
      src ++;
      }
#line 141
      goto __Cont;
    }
#line 143
    if ((unsigned long )dst != (unsigned long )src) {
#line 144
      *dst = *src;
    }
#line 146
    src ++;
#line 147
    dst ++;
#line 148
    count ++;
    __Cont: /* CIL Label */ 
#line 137
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 151
  ds->sock_count = (unsigned int )count;
#line 152
  return;
}
}
#line 154 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_discover.c"
static bool_t hdhomerun_discover_send_internal(struct hdhomerun_discover_t *ds , struct hdhomerun_discover_sock_t *dss ,
                                               uint32_t target_ip , uint32_t device_type ,
                                               uint32_t device_id ) 
{ 
  struct hdhomerun_pkt_t *tx_pkt ;
  bool_t tmp ;

  {
  {
#line 156
  tx_pkt = & ds->tx_pkt;
#line 157
  hdhomerun_pkt_reset(tx_pkt);
#line 159
  hdhomerun_pkt_write_u8(tx_pkt, (uint8_t )1);
#line 160
  hdhomerun_pkt_write_var_length(tx_pkt, (size_t )4);
#line 161
  hdhomerun_pkt_write_u32(tx_pkt, device_type);
#line 162
  hdhomerun_pkt_write_u8(tx_pkt, (uint8_t )2);
#line 163
  hdhomerun_pkt_write_var_length(tx_pkt, (size_t )4);
#line 164
  hdhomerun_pkt_write_u32(tx_pkt, device_id);
#line 165
  hdhomerun_pkt_seal_frame(tx_pkt, (uint16_t )2);
#line 167
  tmp = hdhomerun_sock_sendto(dss->sock, target_ip, (uint16_t )65001, (void const   *)tx_pkt->start,
                              (size_t )(tx_pkt->end - tx_pkt->start), (uint64_t )0);
  }
#line 167
  return (tmp);
}
}
#line 170 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_discover.c"
static bool_t hdhomerun_discover_send_wildcard_ip(struct hdhomerun_discover_t *ds ,
                                                  uint32_t device_type , uint32_t device_id ) 
{ 
  bool_t result___1 ;
  unsigned int i ;
  struct hdhomerun_discover_sock_t *dss ;
  uint32_t target_ip ;
  bool_t tmp ;
  struct hdhomerun_discover_sock_t *dss___0 ;

  {
#line 172
  result___1 = 0;
#line 179
  i = 1U;
  {
#line 179
  while (1) {
    while_continue: /* CIL Label */ ;
#line 179
    if (! (i < ds->sock_count)) {
#line 179
      goto while_break;
    }
    {
#line 180
    dss = & ds->socks[i];
#line 181
    target_ip = dss->local_ip | ~ dss->subnet_mask;
#line 182
    tmp = hdhomerun_discover_send_internal(ds, dss, target_ip, device_type, device_id);
#line 182
    result___1 |= tmp;
#line 179
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 188
  if (! result___1) {
    {
#line 189
    dss___0 = & ds->socks[0];
#line 190
    result___1 = hdhomerun_discover_send_internal(ds, dss___0, 4294967295U, device_type,
                                                  device_id);
    }
  }
#line 193
  return (result___1);
}
}
#line 196 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_discover.c"
static bool_t hdhomerun_discover_send_target_ip(struct hdhomerun_discover_t *ds ,
                                                uint32_t target_ip , uint32_t device_type ,
                                                uint32_t device_id ) 
{ 
  bool_t result___1 ;
  unsigned int i ;
  struct hdhomerun_discover_sock_t *dss ;
  bool_t tmp ;
  struct hdhomerun_discover_sock_t *dss___0 ;

  {
#line 198
  result___1 = 0;
#line 205
  i = 1U;
  {
#line 205
  while (1) {
    while_continue: /* CIL Label */ ;
#line 205
    if (! (i < ds->sock_count)) {
#line 205
      goto while_break;
    }
#line 206
    dss = & ds->socks[i];
#line 207
    if ((target_ip & dss->subnet_mask) != (dss->local_ip & dss->subnet_mask)) {
#line 208
      goto __Cont;
    }
    {
#line 211
    tmp = hdhomerun_discover_send_internal(ds, dss, target_ip, device_type, device_id);
#line 211
    result___1 |= tmp;
    }
    __Cont: /* CIL Label */ 
#line 205
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 217
  if (! result___1) {
    {
#line 218
    dss___0 = & ds->socks[0];
#line 219
    result___1 = hdhomerun_discover_send_internal(ds, dss___0, target_ip, device_type,
                                                  device_id);
    }
  }
#line 222
  return (result___1);
}
}
#line 225 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_discover.c"
static bool_t hdhomerun_discover_send(struct hdhomerun_discover_t *ds , uint32_t target_ip ,
                                      uint32_t device_type , uint32_t device_id ) 
{ 
  bool_t tmp ;
  bool_t tmp___0 ;

  {
#line 227
  if (target_ip == 0U) {
    {
#line 228
    tmp = hdhomerun_discover_send_wildcard_ip(ds, device_type, device_id);
    }
#line 228
    return (tmp);
  } else {
    {
#line 230
    tmp___0 = hdhomerun_discover_send_target_ip(ds, target_ip, device_type, device_id);
    }
#line 230
    return (tmp___0);
  }
}
}
#line 234 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_discover.c"
static bool_t hdhomerun_discover_recv_internal(struct hdhomerun_discover_t *ds , struct hdhomerun_discover_sock_t *dss ,
                                               struct hdhomerun_discover_device_t *result___1 ) 
{ 
  struct hdhomerun_pkt_t *rx_pkt ;
  uint32_t remote_addr ;
  uint16_t remote_port ;
  size_t length ;
  bool_t tmp ;
  uint16_t type ;
  bool_t tmp___0 ;
  uint8_t tag ;
  size_t len ;
  uint8_t *next ;
  uint8_t *tmp___1 ;

  {
  {
#line 236
  rx_pkt = & ds->rx_pkt;
#line 237
  hdhomerun_pkt_reset(rx_pkt);
#line 241
  length = (size_t )(rx_pkt->limit - rx_pkt->end);
#line 242
  tmp = hdhomerun_sock_recvfrom(dss->sock, & remote_addr, & remote_port, (void *)rx_pkt->end,
                                & length, (uint64_t )0);
  }
#line 242
  if (! tmp) {
#line 243
    return (0);
  }
  {
#line 246
  rx_pkt->end += length;
#line 249
  tmp___0 = hdhomerun_pkt_open_frame(rx_pkt, & type);
  }
#line 249
  if (tmp___0 <= 0) {
#line 250
    return (0);
  }
#line 252
  if ((int )type != 3) {
#line 253
    return (0);
  }
#line 256
  result___1->ip_addr = remote_addr;
#line 257
  result___1->device_type = (uint32_t )0;
#line 258
  result___1->device_id = (uint32_t )0;
#line 259
  result___1->tuner_count = (uint8_t )0;
  {
#line 261
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 264
    tmp___1 = hdhomerun_pkt_read_tlv(rx_pkt, & tag, & len);
#line 264
    next = tmp___1;
    }
#line 265
    if (! next) {
#line 266
      goto while_break;
    }
    {
#line 270
    if ((int )tag == 1) {
#line 270
      goto case_1;
    }
#line 277
    if ((int )tag == 2) {
#line 277
      goto case_2;
    }
#line 284
    if ((int )tag == 16) {
#line 284
      goto case_16;
    }
#line 291
    goto switch_default;
    case_1: /* CIL Label */ 
#line 271
    if (len != 4UL) {
#line 272
      goto switch_break;
    }
    {
#line 274
    result___1->device_type = hdhomerun_pkt_read_u32(rx_pkt);
    }
#line 275
    goto switch_break;
    case_2: /* CIL Label */ 
#line 278
    if (len != 4UL) {
#line 279
      goto switch_break;
    }
    {
#line 281
    result___1->device_id = hdhomerun_pkt_read_u32(rx_pkt);
    }
#line 282
    goto switch_break;
    case_16: /* CIL Label */ 
#line 285
    if (len != 1UL) {
#line 286
      goto switch_break;
    }
    {
#line 288
    result___1->tuner_count = hdhomerun_pkt_read_u8(rx_pkt);
    }
#line 289
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 292
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 295
    rx_pkt->pos = next;
  }
  while_break: /* CIL Label */ ;
  }
#line 299
  if ((int )result___1->tuner_count == 0) {
    {
#line 301
    if (result___1->device_id >> 20 == 258U) {
#line 301
      goto case_258;
    }
#line 307
    if (result___1->device_id >> 20 == 289U) {
#line 307
      goto case_289;
    }
#line 307
    if (result___1->device_id >> 20 == 257U) {
#line 307
      goto case_289;
    }
#line 307
    if (result___1->device_id >> 20 == 256U) {
#line 307
      goto case_289;
    }
#line 311
    goto switch_default___0;
    case_258: /* CIL Label */ 
#line 302
    result___1->tuner_count = (uint8_t )1;
#line 303
    goto switch_break___0;
    case_289: /* CIL Label */ 
    case_257: /* CIL Label */ 
    case_256: /* CIL Label */ 
#line 308
    result___1->tuner_count = (uint8_t )2;
#line 309
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 312
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
#line 316
  return (1);
}
}
#line 319 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_discover.c"
static bool_t hdhomerun_discover_recv(struct hdhomerun_discover_t *ds , struct hdhomerun_discover_device_t *result___1 ) 
{ 
  unsigned int i ;
  struct hdhomerun_discover_sock_t *dss ;
  bool_t tmp ;

  {
#line 322
  i = 0U;
  {
#line 322
  while (1) {
    while_continue: /* CIL Label */ ;
#line 322
    if (! (i < ds->sock_count)) {
#line 322
      goto while_break;
    }
    {
#line 323
    dss = & ds->socks[i];
#line 325
    tmp = hdhomerun_discover_recv_internal(ds, dss, result___1);
    }
#line 325
    if (tmp) {
#line 326
      return (1);
    }
#line 322
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 330
  return (0);
}
}
#line 333 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_discover.c"
static struct hdhomerun_discover_device_t *hdhomerun_discover_find_in_list(struct hdhomerun_discover_device_t *result_list ,
                                                                           int count ,
                                                                           struct hdhomerun_discover_device_t *lookup ) 
{ 
  int index___0 ;
  struct hdhomerun_discover_device_t *entry ;
  int tmp ;

  {
#line 336
  index___0 = 0;
  {
#line 336
  while (1) {
    while_continue: /* CIL Label */ ;
#line 336
    if (! (index___0 < count)) {
#line 336
      goto while_break;
    }
    {
#line 337
    entry = result_list + index___0;
#line 338
    tmp = memcmp((void const   *)lookup, (void const   *)entry, sizeof(struct hdhomerun_discover_device_t ));
    }
#line 338
    if (tmp == 0) {
#line 339
      return (entry);
    }
#line 336
    index___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 343
  return ((struct hdhomerun_discover_device_t *)((void *)0));
}
}
#line 346 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_discover.c"
int hdhomerun_discover_find_devices(struct hdhomerun_discover_t *ds , uint32_t target_ip ,
                                    uint32_t device_type , uint32_t device_id , struct hdhomerun_discover_device_t *result_list ,
                                    int max_count ) 
{ 
  int count ;
  int attempt ;
  bool_t tmp ;
  uint64_t timeout ;
  uint64_t tmp___0 ;
  struct hdhomerun_discover_device_t *result___1 ;
  uint64_t tmp___1 ;
  bool_t tmp___2 ;
  struct hdhomerun_discover_device_t *tmp___3 ;

  {
  {
#line 348
  hdhomerun_discover_sock_detect(ds);
#line 350
  count = 0;
#line 352
  attempt = 0;
  }
  {
#line 352
  while (1) {
    while_continue: /* CIL Label */ ;
#line 352
    if (! (attempt < 2)) {
#line 352
      goto while_break;
    }
    {
#line 353
    tmp = hdhomerun_discover_send(ds, target_ip, device_type, device_id);
    }
#line 353
    if (! tmp) {
#line 354
      return (-1);
    }
    {
#line 357
    tmp___0 = getcurrenttime();
#line 357
    timeout = tmp___0 + 200UL;
    }
    {
#line 358
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 359
      result___1 = result_list + count;
#line 360
      memset((void *)result___1, 0, sizeof(struct hdhomerun_discover_device_t ));
#line 362
      tmp___2 = hdhomerun_discover_recv(ds, result___1);
      }
#line 362
      if (! tmp___2) {
        {
#line 363
        tmp___1 = getcurrenttime();
        }
#line 363
        if (tmp___1 >= timeout) {
#line 364
          goto while_break___0;
        }
        {
#line 366
        msleep_approx((uint64_t )10);
        }
#line 367
        goto while_continue___0;
      }
#line 371
      if (device_type != 4294967295U) {
#line 372
        if (device_type != result___1->device_type) {
#line 373
          goto while_continue___0;
        }
      }
#line 376
      if (device_id != 4294967295U) {
#line 377
        if (device_id != result___1->device_id) {
#line 378
          goto while_continue___0;
        }
      }
      {
#line 383
      tmp___3 = hdhomerun_discover_find_in_list(result_list, count, result___1);
      }
#line 383
      if (tmp___3) {
#line 384
        goto while_continue___0;
      }
#line 388
      count ++;
#line 389
      if (count >= max_count) {
#line 390
        return (count);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 352
    attempt ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 395
  return (count);
}
}
#line 398 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_discover.c"
int hdhomerun_discover_find_devices_custom(uint32_t target_ip , uint32_t device_type ,
                                           uint32_t device_id , struct hdhomerun_discover_device_t *result_list ,
                                           int max_count ) 
{ 
  bool_t tmp ;
  struct hdhomerun_discover_t *ds ;
  struct hdhomerun_discover_t *tmp___0 ;
  int ret ;
  int tmp___1 ;

  {
  {
#line 400
  tmp = hdhomerun_discover_is_ip_multicast(target_ip);
  }
#line 400
  if (tmp) {
#line 401
    return (0);
  }
  {
#line 404
  tmp___0 = hdhomerun_discover_create((struct hdhomerun_debug_t *)((void *)0));
#line 404
  ds = tmp___0;
  }
#line 405
  if (! ds) {
#line 406
    return (-1);
  }
  {
#line 409
  tmp___1 = hdhomerun_discover_find_devices(ds, target_ip, device_type, device_id,
                                            result_list, max_count);
#line 409
  ret = tmp___1;
#line 411
  hdhomerun_discover_destroy(ds);
  }
#line 412
  return (ret);
}
}
#line 417 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_discover.c"
static uint32_t lookup_table[16]  = 
#line 417
  {      (uint32_t )10,      (uint32_t )5,      (uint32_t )15,      (uint32_t )6, 
        (uint32_t )7,      (uint32_t )12,      (uint32_t )1,      (uint32_t )11, 
        (uint32_t )9,      (uint32_t )2,      (uint32_t )8,      (uint32_t )13, 
        (uint32_t )4,      (uint32_t )3,      (uint32_t )14,      (uint32_t )0};
#line 415 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_discover.c"
bool_t hdhomerun_discover_validate_device_id(uint32_t device_id ) 
{ 
  uint32_t checksum ;

  {
#line 419
  checksum = (uint32_t )0;
#line 421
  checksum ^= lookup_table[(device_id >> 28) & 15U];
#line 422
  checksum ^= (device_id >> 24) & 15U;
#line 423
  checksum ^= lookup_table[(device_id >> 20) & 15U];
#line 424
  checksum ^= (device_id >> 16) & 15U;
#line 425
  checksum ^= lookup_table[(device_id >> 12) & 15U];
#line 426
  checksum ^= (device_id >> 8) & 15U;
#line 427
  checksum ^= lookup_table[(device_id >> 4) & 15U];
#line 428
  checksum ^= device_id & 15U;
#line 430
  return (checksum == 0U);
}
}
#line 433 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_discover.c"
bool_t hdhomerun_discover_is_ip_multicast(uint32_t ip_addr ) 
{ 
  int tmp ;

  {
#line 435
  if (ip_addr >= 3758096384U) {
#line 435
    if (ip_addr < 4026531840U) {
#line 435
      tmp = 1;
    } else {
#line 435
      tmp = 0;
    }
  } else {
#line 435
    tmp = 0;
  }
#line 435
  return (tmp);
}
}
#line 242 "/usr/include/stdio.h"
extern int fflush(FILE *__stream ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 176 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 205
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) strftime)(char * __restrict  __s ,
                                                                                  size_t __maxsize ,
                                                                                  char const   * __restrict  __format ,
                                                                                  struct tm  const  * __restrict  __tp ) ;
#line 243
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_debug.h"
struct hdhomerun_debug_t *hdhomerun_debug_create(void) ;
#line 36
void hdhomerun_debug_destroy(struct hdhomerun_debug_t *dbg ) ;
#line 38
void hdhomerun_debug_set_prefix(struct hdhomerun_debug_t *dbg , char const   *prefix ) ;
#line 39
void hdhomerun_debug_set_filename(struct hdhomerun_debug_t *dbg , char const   *filename ) ;
#line 40
void hdhomerun_debug_enable(struct hdhomerun_debug_t *dbg ) ;
#line 41
void hdhomerun_debug_disable(struct hdhomerun_debug_t *dbg ) ;
#line 44
void hdhomerun_debug_flush(struct hdhomerun_debug_t *dbg , uint64_t timeout ) ;
#line 45
void hdhomerun_debug_close(struct hdhomerun_debug_t *dbg , uint64_t timeout ) ;
#line 48
void hdhomerun_debug_vprintf(struct hdhomerun_debug_t *dbg , char const   *fmt , va_list args ) ;
#line 71 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_debug.c"
static void *hdhomerun_debug_thread_execute(void *arg ) ;
#line 73 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_debug.c"
struct hdhomerun_debug_t *hdhomerun_debug_create(void) 
{ 
  struct hdhomerun_debug_t *dbg ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 75
  tmp = calloc((size_t )1, sizeof(struct hdhomerun_debug_t ));
#line 75
  dbg = (struct hdhomerun_debug_t *)tmp;
  }
#line 76
  if (! dbg) {
#line 77
    return ((struct hdhomerun_debug_t *)((void *)0));
  }
  {
#line 80
  dbg->sock = -1;
#line 82
  pthread_mutex_init(& dbg->print_lock, (pthread_mutexattr_t const   *)((void *)0));
#line 83
  pthread_mutex_init(& dbg->queue_lock, (pthread_mutexattr_t const   *)((void *)0));
#line 84
  pthread_mutex_init(& dbg->send_lock, (pthread_mutexattr_t const   *)((void *)0));
#line 86
  tmp___0 = pthread_create((pthread_t */* __restrict  */)(& dbg->thread), (pthread_attr_t const   */* __restrict  */)((void *)0),
                           & hdhomerun_debug_thread_execute, (void */* __restrict  */)dbg);
  }
#line 86
  if (tmp___0 != 0) {
    {
#line 87
    free((void *)dbg);
    }
#line 88
    return ((struct hdhomerun_debug_t *)((void *)0));
  }
#line 91
  return (dbg);
}
}
#line 94 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_debug.c"
void hdhomerun_debug_destroy(struct hdhomerun_debug_t *dbg ) 
{ 


  {
#line 96
  if (! dbg) {
#line 97
    return;
  }
  {
#line 100
  dbg->terminate = (bool_t volatile   )1;
#line 101
  pthread_join(dbg->thread, (void **)((void *)0));
  }
#line 103
  if (dbg->prefix) {
    {
#line 104
    free((void *)dbg->prefix);
    }
  }
#line 106
  if (dbg->file_name) {
    {
#line 107
    free((void *)dbg->file_name);
    }
  }
#line 109
  if (dbg->file_fp) {
    {
#line 110
    fclose(dbg->file_fp);
    }
  }
#line 112
  if (dbg->sock != -1) {
    {
#line 113
    hdhomerun_sock_destroy(dbg->sock);
    }
  }
  {
#line 116
  free((void *)dbg);
  }
#line 117
  return;
}
}
#line 120 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_debug.c"
static void hdhomerun_debug_close_internal(struct hdhomerun_debug_t *dbg ) 
{ 


  {
#line 122
  if (dbg->file_fp) {
    {
#line 123
    fclose(dbg->file_fp);
#line 124
    dbg->file_fp = (FILE *)((void *)0);
    }
  }
#line 127
  if (dbg->sock != -1) {
    {
#line 128
    hdhomerun_sock_destroy(dbg->sock);
#line 129
    dbg->sock = -1;
    }
  }
#line 131
  return;
}
}
#line 133 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_debug.c"
void hdhomerun_debug_close(struct hdhomerun_debug_t *dbg , uint64_t timeout ) 
{ 


  {
#line 135
  if (! dbg) {
#line 136
    return;
  }
#line 139
  if (timeout > 0UL) {
    {
#line 140
    hdhomerun_debug_flush(dbg, timeout);
    }
  }
  {
#line 143
  pthread_mutex_lock(& dbg->send_lock);
#line 144
  hdhomerun_debug_close_internal(dbg);
#line 145
  dbg->connect_delay = (uint64_t )0;
#line 146
  pthread_mutex_unlock(& dbg->send_lock);
  }
#line 147
  return;
}
}
#line 149 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_debug.c"
void hdhomerun_debug_set_filename(struct hdhomerun_debug_t *dbg , char const   *filename ) 
{ 
  int tmp ;

  {
#line 151
  if (! dbg) {
#line 152
    return;
  }
  {
#line 155
  pthread_mutex_lock(& dbg->send_lock);
  }
#line 157
  if (! filename) {
#line 157
    if (! dbg->file_name) {
      {
#line 158
      pthread_mutex_unlock(& dbg->send_lock);
      }
#line 159
      return;
    }
  }
#line 161
  if (filename) {
#line 161
    if (dbg->file_name) {
      {
#line 162
      tmp = strcmp(filename, (char const   *)dbg->file_name);
      }
#line 162
      if (tmp == 0) {
        {
#line 163
        pthread_mutex_unlock(& dbg->send_lock);
        }
#line 164
        return;
      }
    }
  }
  {
#line 168
  hdhomerun_debug_close_internal(dbg);
#line 169
  dbg->connect_delay = (uint64_t )0;
  }
#line 171
  if (dbg->file_name) {
    {
#line 172
    free((void *)dbg->file_name);
#line 173
    dbg->file_name = (char *)((void *)0);
    }
  }
#line 175
  if (filename) {
    {
#line 176
    dbg->file_name = strdup(filename);
    }
  }
  {
#line 179
  pthread_mutex_unlock(& dbg->send_lock);
  }
#line 180
  return;
}
}
#line 182 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_debug.c"
void hdhomerun_debug_set_prefix(struct hdhomerun_debug_t *dbg , char const   *prefix ) 
{ 


  {
#line 184
  if (! dbg) {
#line 185
    return;
  }
  {
#line 188
  pthread_mutex_lock(& dbg->print_lock);
  }
#line 190
  if (dbg->prefix) {
    {
#line 191
    free((void *)dbg->prefix);
#line 192
    dbg->prefix = (char *)((void *)0);
    }
  }
#line 195
  if (prefix) {
    {
#line 196
    dbg->prefix = strdup(prefix);
    }
  }
  {
#line 199
  pthread_mutex_unlock(& dbg->print_lock);
  }
#line 200
  return;
}
}
#line 202 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_debug.c"
void hdhomerun_debug_enable(struct hdhomerun_debug_t *dbg ) 
{ 


  {
#line 204
  if (! dbg) {
#line 205
    return;
  }
#line 208
  dbg->enabled = (bool_t volatile   )1;
#line 209
  return;
}
}
#line 211 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_debug.c"
void hdhomerun_debug_disable(struct hdhomerun_debug_t *dbg ) 
{ 


  {
#line 213
  if (! dbg) {
#line 214
    return;
  }
#line 217
  dbg->enabled = (bool_t volatile   )0;
#line 218
  return;
}
}
#line 220 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_debug.c"
bool_t hdhomerun_debug_enabled(struct hdhomerun_debug_t *dbg ) 
{ 


  {
#line 222
  if (! dbg) {
#line 223
    return (0);
  }
#line 226
  return ((bool_t )dbg->enabled);
}
}
#line 229 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_debug.c"
void hdhomerun_debug_flush(struct hdhomerun_debug_t *dbg , uint64_t timeout ) 
{ 
  uint64_t tmp ;
  struct hdhomerun_debug_message_t *message ;
  uint64_t tmp___0 ;

  {
#line 231
  if (! dbg) {
#line 232
    return;
  }
  {
#line 235
  tmp = getcurrenttime();
#line 235
  timeout = tmp + timeout;
  }
  {
#line 237
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 237
    tmp___0 = getcurrenttime();
    }
#line 237
    if (! (tmp___0 < timeout)) {
#line 237
      goto while_break;
    }
    {
#line 238
    pthread_mutex_lock(& dbg->queue_lock);
#line 239
    message = dbg->queue_tail;
#line 240
    pthread_mutex_unlock(& dbg->queue_lock);
    }
#line 242
    if (! message) {
#line 243
      return;
    }
    {
#line 246
    msleep_approx((uint64_t )10);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 248
  return;
}
}
#line 250 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_debug.c"
void hdhomerun_debug_printf(struct hdhomerun_debug_t *dbg , char const   *fmt  , ...) 
{ 
  va_list args ;

  {
  {
#line 253
  __builtin_va_start(args, fmt);
#line 254
  hdhomerun_debug_vprintf(dbg, fmt, args);
#line 255
  __builtin_va_end(args);
  }
#line 256
  return;
}
}
#line 258 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_debug.c"
void hdhomerun_debug_vprintf(struct hdhomerun_debug_t *dbg , char const   *fmt , va_list args ) 
{ 
  struct hdhomerun_debug_message_t *message ;
  void *tmp ;
  char *ptr ;
  char *end ;
  time_t current_time ;
  time_t tmp___0 ;
  struct tm *tmp___1 ;
  size_t tmp___2 ;

  {
#line 260
  if (! dbg) {
#line 261
    return;
  }
#line 263
  if (! dbg->enabled) {
#line 264
    return;
  }
  {
#line 267
  tmp = malloc(sizeof(struct hdhomerun_debug_message_t ));
#line 267
  message = (struct hdhomerun_debug_message_t *)tmp;
  }
#line 268
  if (! message) {
#line 269
    return;
  }
  {
#line 272
  ptr = message->buffer;
#line 273
  end = (message->buffer + sizeof(message->buffer)) - 2;
#line 274
  *end = (char)0;
#line 279
  tmp___0 = time((time_t *)((void *)0));
#line 279
  current_time = tmp___0;
#line 280
  tmp___1 = localtime((time_t const   *)(& current_time));
#line 280
  tmp___2 = strftime((char */* __restrict  */)ptr, (size_t )(end - ptr), (char const   */* __restrict  */)"%Y%m%d-%H:%M:%S ",
                     (struct tm  const  */* __restrict  */)tmp___1);
#line 280
  ptr += tmp___2;
  }
#line 281
  if ((unsigned long )ptr > (unsigned long )end) {
#line 282
    ptr = end;
  }
  {
#line 288
  pthread_mutex_lock(& dbg->print_lock);
  }
#line 290
  if (dbg->prefix) {
    {
#line 291
    hdhomerun_sprintf(ptr, end, "%s ", dbg->prefix);
#line 292
    ptr = strchr((char const   *)ptr, 0);
    }
  }
  {
#line 295
  pthread_mutex_unlock(& dbg->print_lock);
#line 300
  hdhomerun_vsprintf(ptr, end, fmt, args);
#line 301
  ptr = strchr((char const   *)ptr, 0);
  }
#line 306
  if ((int )*(ptr + -1) != 10) {
    {
#line 307
    hdhomerun_sprintf(ptr, end, "\n");
    }
  }
  {
#line 313
  pthread_mutex_lock(& dbg->queue_lock);
#line 315
  message->prev = (struct hdhomerun_debug_message_t *)((void *)0);
#line 316
  message->next = dbg->queue_head;
#line 317
  dbg->queue_head = message;
  }
#line 318
  if (message->next) {
#line 319
    (message->next)->prev = message;
  } else {
#line 321
    dbg->queue_tail = message;
  }
  {
#line 323
  (dbg->queue_depth) ++;
#line 325
  pthread_mutex_unlock(& dbg->queue_lock);
  }
#line 326
  return;
}
}
#line 329 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_debug.c"
static bool_t hdhomerun_debug_output_message_file(struct hdhomerun_debug_t *dbg ,
                                                  struct hdhomerun_debug_message_t *message ) 
{ 
  uint64_t current_time ;
  uint64_t tmp ;

  {
#line 331
  if (! dbg->file_fp) {
    {
#line 332
    tmp = getcurrenttime();
#line 332
    current_time = tmp;
    }
#line 333
    if (current_time < dbg->connect_delay) {
#line 334
      return (0);
    }
    {
#line 336
    dbg->connect_delay = current_time + 30000UL;
#line 338
    dbg->file_fp = fopen((char const   */* __restrict  */)dbg->file_name, (char const   */* __restrict  */)"a");
    }
#line 339
    if (! dbg->file_fp) {
#line 340
      return (0);
    }
  }
  {
#line 344
  fprintf((FILE */* __restrict  */)dbg->file_fp, (char const   */* __restrict  */)"%s",
          message->buffer);
#line 345
  fflush(dbg->file_fp);
  }
#line 347
  return (1);
}
}
#line 351 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_debug.c"
static bool_t hdhomerun_debug_output_message_sock(struct hdhomerun_debug_t *dbg ,
                                                  struct hdhomerun_debug_message_t *message ) 
{ 
  uint64_t current_time ;
  uint64_t tmp ;
  uint32_t remote_addr ;
  uint32_t tmp___0 ;
  bool_t tmp___1 ;
  size_t length ;
  size_t tmp___2 ;
  bool_t tmp___3 ;

  {
#line 353
  if (dbg->sock == -1) {
    {
#line 354
    tmp = getcurrenttime();
#line 354
    current_time = tmp;
    }
#line 355
    if (current_time < dbg->connect_delay) {
#line 356
      return (0);
    }
    {
#line 358
    dbg->connect_delay = current_time + 30000UL;
#line 360
    dbg->sock = hdhomerun_sock_create_tcp();
    }
#line 361
    if (dbg->sock == -1) {
#line 362
      return (0);
    }
    {
#line 365
    tmp___0 = hdhomerun_sock_getaddrinfo_addr(dbg->sock, "debug.silicondust.com");
#line 365
    remote_addr = tmp___0;
    }
#line 366
    if (remote_addr == 0U) {
      {
#line 367
      hdhomerun_debug_close_internal(dbg);
      }
#line 368
      return (0);
    }
    {
#line 371
    tmp___1 = hdhomerun_sock_connect(dbg->sock, remote_addr, (uint16_t )8002, (uint64_t )10000);
    }
#line 371
    if (! tmp___1) {
      {
#line 372
      hdhomerun_debug_close_internal(dbg);
      }
#line 373
      return (0);
    }
  }
  {
#line 377
  tmp___2 = strlen((char const   *)(message->buffer));
#line 377
  length = tmp___2;
#line 378
  tmp___3 = hdhomerun_sock_send(dbg->sock, (void const   *)(message->buffer), length,
                                (uint64_t )10000);
  }
#line 378
  if (! tmp___3) {
    {
#line 379
    hdhomerun_debug_close_internal(dbg);
    }
#line 380
    return (0);
  }
#line 383
  return (1);
}
}
#line 386 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_debug.c"
static bool_t hdhomerun_debug_output_message(struct hdhomerun_debug_t *dbg , struct hdhomerun_debug_message_t *message ) 
{ 
  bool_t ret ;

  {
  {
#line 388
  pthread_mutex_lock(& dbg->send_lock);
  }
#line 391
  if (dbg->file_name) {
    {
#line 392
    ret = hdhomerun_debug_output_message_file(dbg, message);
    }
  } else {
    {
#line 394
    ret = hdhomerun_debug_output_message_sock(dbg, message);
    }
  }
  {
#line 397
  pthread_mutex_unlock(& dbg->send_lock);
  }
#line 398
  return (ret);
}
}
#line 401 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_debug.c"
static void hdhomerun_debug_pop_and_free_message(struct hdhomerun_debug_t *dbg ) 
{ 
  struct hdhomerun_debug_message_t *message ;

  {
  {
#line 403
  pthread_mutex_lock(& dbg->queue_lock);
#line 405
  message = dbg->queue_tail;
#line 406
  dbg->queue_tail = message->prev;
  }
#line 407
  if (message->prev) {
#line 408
    (message->prev)->next = (struct hdhomerun_debug_message_t *)((void *)0);
  } else {
#line 410
    dbg->queue_head = (struct hdhomerun_debug_message_t *)((void *)0);
  }
  {
#line 412
  (dbg->queue_depth) --;
#line 414
  pthread_mutex_unlock(& dbg->queue_lock);
#line 416
  free((void *)message);
  }
#line 417
  return;
}
}
#line 419 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_debug.c"
static void *hdhomerun_debug_thread_execute(void *arg ) 
{ 
  struct hdhomerun_debug_t *dbg ;
  struct hdhomerun_debug_message_t *message ;
  uint32_t queue_depth ;
  bool_t tmp ;

  {
#line 421
  dbg = (struct hdhomerun_debug_t *)arg;
  {
#line 423
  while (1) {
    while_continue: /* CIL Label */ ;
#line 423
    if (! (! dbg->terminate)) {
#line 423
      goto while_break;
    }
    {
#line 425
    pthread_mutex_lock(& dbg->queue_lock);
#line 426
    message = dbg->queue_tail;
#line 427
    queue_depth = dbg->queue_depth;
#line 428
    pthread_mutex_unlock(& dbg->queue_lock);
    }
#line 430
    if (! message) {
      {
#line 431
      msleep_approx((uint64_t )250);
      }
#line 432
      goto while_continue;
    }
#line 435
    if (queue_depth > 1024U) {
      {
#line 436
      hdhomerun_debug_pop_and_free_message(dbg);
      }
#line 437
      goto while_continue;
    }
    {
#line 440
    tmp = hdhomerun_debug_output_message(dbg, message);
    }
#line 440
    if (! tmp) {
      {
#line 441
      msleep_approx((uint64_t )250);
      }
#line 442
      goto while_continue;
    }
    {
#line 445
    hdhomerun_debug_pop_and_free_message(dbg);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 448
  return ((void *)0);
}
}
/* compiler builtin: 
   void __builtin_va_copy(__builtin_va_list  , __builtin_va_list  ) ;  */
#line 187 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 377
extern int vprintf(char const   * __restrict  __format , __gnuc_va_list __arg ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 263 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 33 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_config.c"
static char const   *appname  ;
#line 35 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_config.c"
struct hdhomerun_device_t *hd  ;
#line 37 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_config.c"
static int help(void) 
{ 


  {
  {
#line 39
  printf((char const   */* __restrict  */)"Usage:\n");
#line 40
  printf((char const   */* __restrict  */)"\t%s discover\n", appname);
#line 41
  printf((char const   */* __restrict  */)"\t%s <id> get help\n", appname);
#line 42
  printf((char const   */* __restrict  */)"\t%s <id> get <item>\n", appname);
#line 43
  printf((char const   */* __restrict  */)"\t%s <id> set <item> <value>\n", appname);
#line 44
  printf((char const   */* __restrict  */)"\t%s <id> scan <tuner> [<filename>]\n",
         appname);
#line 45
  printf((char const   */* __restrict  */)"\t%s <id> save <tuner> <filename>\n", appname);
#line 46
  printf((char const   */* __restrict  */)"\t%s <id> upgrade <filename>\n", appname);
  }
#line 47
  return (-1);
}
}
#line 50 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_config.c"
static void extract_appname(char const   *argv0 ) 
{ 
  char const   *ptr ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 52
  tmp = strrchr(argv0, '/');
#line 52
  ptr = (char const   *)tmp;
  }
#line 53
  if (ptr) {
#line 54
    argv0 = ptr + 1;
  }
  {
#line 56
  tmp___0 = strrchr(argv0, '\\');
#line 56
  ptr = (char const   *)tmp___0;
  }
#line 57
  if (ptr) {
#line 58
    argv0 = ptr + 1;
  }
#line 60
  appname = argv0;
#line 61
  return;
}
}
#line 63 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_config.c"
static bool_t contains(char const   *arg , char const   *cmpstr ) 
{ 
  int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 65
  tmp = strcmp(arg, cmpstr);
  }
#line 65
  if (tmp == 0) {
#line 66
    return (1);
  }
#line 69
  tmp___0 = arg;
#line 69
  arg ++;
#line 69
  if ((int const   )*tmp___0 != 45) {
#line 70
    return (0);
  }
#line 72
  tmp___1 = arg;
#line 72
  arg ++;
#line 72
  if ((int const   )*tmp___1 != 45) {
#line 73
    return (0);
  }
  {
#line 75
  tmp___2 = strcmp(arg, cmpstr);
  }
#line 75
  if (tmp___2 == 0) {
#line 76
    return (1);
  }
#line 79
  return (0);
}
}
#line 82 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_config.c"
static uint32_t parse_ip_addr(char const   *str ) 
{ 
  unsigned int a[4] ;
  int tmp ;

  {
  {
#line 85
  tmp = sscanf((char const   */* __restrict  */)str, (char const   */* __restrict  */)"%u.%u.%u.%u",
               & a[0], & a[1], & a[2], & a[3]);
  }
#line 85
  if (tmp != 4) {
#line 86
    return ((uint32_t )0);
  }
#line 89
  return ((((a[0] << 24) | (a[1] << 16)) | (a[2] << 8)) | a[3]);
}
}
#line 92 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_config.c"
static int discover_print(char *target_ip_str ) 
{ 
  uint32_t target_ip ;
  struct hdhomerun_discover_device_t result_list[64] ;
  int count ;
  int tmp ;
  int index___0 ;
  struct hdhomerun_discover_device_t *result___1 ;

  {
#line 94
  target_ip = (uint32_t )0;
#line 95
  if (target_ip_str) {
    {
#line 96
    target_ip = parse_ip_addr((char const   *)target_ip_str);
    }
#line 97
    if (target_ip == 0U) {
      {
#line 98
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"invalid ip address: %s\n",
              target_ip_str);
      }
#line 99
      return (-1);
    }
  }
  {
#line 104
  tmp = hdhomerun_discover_find_devices_custom(target_ip, (uint32_t )1, 4294967295U,
                                               result_list, 64);
#line 104
  count = tmp;
  }
#line 105
  if (count < 0) {
    {
#line 106
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error sending discover request\n");
    }
#line 107
    return (-1);
  }
#line 109
  if (count == 0) {
    {
#line 110
    printf((char const   */* __restrict  */)"no devices found\n");
    }
#line 111
    return (0);
  }
#line 115
  index___0 = 0;
  {
#line 115
  while (1) {
    while_continue: /* CIL Label */ ;
#line 115
    if (! (index___0 < count)) {
#line 115
      goto while_break;
    }
    {
#line 116
    result___1 = & result_list[index___0];
#line 117
    printf((char const   */* __restrict  */)"hdhomerun device %08X found at %u.%u.%u.%u\n",
           result___1->device_id, (result___1->ip_addr >> 24) & 255U, (result___1->ip_addr >> 16) & 255U,
           (result___1->ip_addr >> 8) & 255U, result___1->ip_addr & 255U);
#line 115
    index___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 124
  return (count);
}
}
#line 127 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_config.c"
static int cmd_get(char const   *item ) 
{ 
  char *ret_value ;
  char *ret_error ;
  int tmp ;

  {
  {
#line 131
  tmp = hdhomerun_device_get_var(hd, item, & ret_value, & ret_error);
  }
#line 131
  if (tmp < 0) {
    {
#line 132
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"communication error sending request to hdhomerun device\n");
    }
#line 133
    return (-1);
  }
#line 136
  if (ret_error) {
    {
#line 137
    printf((char const   */* __restrict  */)"%s\n", ret_error);
    }
#line 138
    return (0);
  }
  {
#line 141
  printf((char const   */* __restrict  */)"%s\n", ret_value);
  }
#line 142
  return (1);
}
}
#line 145 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_config.c"
static int cmd_set_internal(char const   *item , char const   *value ) 
{ 
  char *ret_error ;
  int tmp ;

  {
  {
#line 148
  tmp = hdhomerun_device_set_var(hd, item, value, (char **)((void *)0), & ret_error);
  }
#line 148
  if (tmp < 0) {
    {
#line 149
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"communication error sending request to hdhomerun device\n");
    }
#line 150
    return (-1);
  }
#line 153
  if (ret_error) {
    {
#line 154
    printf((char const   */* __restrict  */)"%s\n", ret_error);
    }
#line 155
    return (0);
  }
#line 158
  return (1);
}
}
#line 161 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_config.c"
static int cmd_set(char const   *item , char const   *value ) 
{ 
  char *buffer ;
  size_t pos ;
  void *tmp ;
  size_t size ;
  size_t tmp___0 ;
  int ret ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 163
  tmp___2 = strcmp(value, "-");
  }
#line 163
  if (tmp___2 == 0) {
#line 164
    buffer = (char *)((void *)0);
#line 165
    pos = (size_t )0;
    {
#line 167
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 168
      tmp = realloc((void *)buffer, pos + 1024UL);
#line 168
      buffer = (char *)tmp;
      }
#line 169
      if (! buffer) {
        {
#line 170
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"out of memory\n");
        }
#line 171
        return (-1);
      }
      {
#line 174
      tmp___0 = fread((void */* __restrict  */)(buffer + pos), (size_t )1, (size_t )1024,
                      (FILE */* __restrict  */)stdin);
#line 174
      size = tmp___0;
#line 175
      pos += size;
      }
#line 177
      if (size < 1024UL) {
#line 178
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 182
    *(buffer + pos) = (char)0;
#line 184
    tmp___1 = cmd_set_internal(item, (char const   *)buffer);
#line 184
    ret = tmp___1;
#line 186
    free((void *)buffer);
    }
#line 187
    return (ret);
  }
  {
#line 190
  tmp___3 = cmd_set_internal(item, value);
  }
#line 190
  return (tmp___3);
}
}
#line 193 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_config.c"
static int volatile   sigabort_flag  =    (sig_atomic_t volatile   )0;
#line 194 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_config.c"
static int volatile   siginfo_flag  =    (sig_atomic_t volatile   )0;
#line 196 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_config.c"
static void sigabort_handler(int arg ) 
{ 


  {
#line 198
  sigabort_flag = (int volatile   )1;
#line 199
  return;
}
}
#line 201 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_config.c"
static void siginfo_handler(int arg ) 
{ 


  {
#line 203
  siginfo_flag = (int volatile   )1;
#line 204
  return;
}
}
#line 206 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_config.c"
static void register_signal_handlers(void (*sigpipe_handler)(int  ) , void (*sigint_handler)(int  ) ,
                                     void (*siginfo_handler___0)(int  ) ) 
{ 


  {
  {
#line 209
  signal(13, sigpipe_handler);
#line 212
  signal(2, sigint_handler);
  }
#line 217
  return;
}
}
#line 219 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_config.c"
static void cmd_scan_printf(FILE *fp , char const   *fmt  , ...) 
{ 
  va_list ap ;
  va_list apc ;

  {
  {
#line 222
  __builtin_va_start(ap, fmt);
  }
#line 224
  if (fp) {
    {
#line 226
    __builtin_va_copy(apc, ap);
#line 228
    vfprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)fmt, apc);
#line 229
    fflush(fp);
#line 231
    __builtin_va_end(apc);
    }
  }
  {
#line 234
  vprintf((char const   */* __restrict  */)fmt, ap);
#line 235
  fflush(stdout);
#line 237
  __builtin_va_end(ap);
  }
#line 238
  return;
}
}
#line 240 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_config.c"
static int cmd_scan(char const   *tuner_str , char const   *filename ) 
{ 
  int tmp ;
  char *ret_error ;
  int tmp___0 ;
  char *channelmap ;
  int tmp___1 ;
  char const   *channelmap_scan_group ;
  char const   *tmp___2 ;
  int tmp___3 ;
  FILE *fp ;
  int ret ;
  struct hdhomerun_channelscan_result_t result___1 ;
  int i ;
  struct hdhomerun_channelscan_program_t *program ;

  {
  {
#line 242
  tmp = hdhomerun_device_set_tuner_from_str(hd, tuner_str);
  }
#line 242
  if (tmp <= 0) {
    {
#line 243
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"invalid tuner number\n");
    }
#line 244
    return (-1);
  }
  {
#line 248
  tmp___0 = hdhomerun_device_tuner_lockkey_request(hd, & ret_error);
  }
#line 248
  if (tmp___0 <= 0) {
    {
#line 249
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"failed to lock tuner\n");
    }
#line 250
    if (ret_error) {
      {
#line 251
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
              ret_error);
      }
    }
#line 253
    return (-1);
  }
  {
#line 256
  hdhomerun_device_set_tuner_target(hd, "none");
#line 259
  tmp___1 = hdhomerun_device_get_tuner_channelmap(hd, & channelmap);
  }
#line 259
  if (tmp___1 <= 0) {
    {
#line 260
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"failed to query channelmap from device\n");
    }
#line 261
    return (-1);
  }
  {
#line 264
  tmp___2 = hdhomerun_channelmap_get_channelmap_scan_group((char const   *)channelmap);
#line 264
  channelmap_scan_group = tmp___2;
  }
#line 265
  if (! channelmap_scan_group) {
    {
#line 266
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unknown channelmap \'%s\'\n",
            channelmap);
    }
#line 267
    return (-1);
  }
  {
#line 270
  tmp___3 = hdhomerun_device_channelscan_init(hd, channelmap_scan_group);
  }
#line 270
  if (tmp___3 <= 0) {
    {
#line 271
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"failed to initialize channel scan\n");
    }
#line 272
    return (-1);
  }
#line 275
  fp = (FILE *)((void *)0);
#line 276
  if (filename) {
    {
#line 277
    fp = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"w");
    }
#line 278
    if (! fp) {
      {
#line 279
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unable to create file: %s\n",
              filename);
      }
#line 280
      return (-1);
    }
  }
  {
#line 284
  register_signal_handlers(& sigabort_handler, & sigabort_handler, & siginfo_handler);
#line 286
  ret = 0;
  }
  {
#line 287
  while (1) {
    while_continue: /* CIL Label */ ;
#line 287
    if (! (! sigabort_flag)) {
#line 287
      goto while_break;
    }
    {
#line 289
    ret = hdhomerun_device_channelscan_advance(hd, & result___1);
    }
#line 290
    if (ret <= 0) {
#line 291
      goto while_break;
    }
    {
#line 294
    cmd_scan_printf(fp, "SCANNING: %u (%s)\n", result___1.frequency, result___1.channel_str);
#line 298
    ret = hdhomerun_device_channelscan_detect(hd, & result___1);
    }
#line 299
    if (ret < 0) {
#line 300
      goto while_break;
    }
#line 302
    if (ret == 0) {
#line 303
      goto while_continue;
    }
    {
#line 306
    cmd_scan_printf(fp, "LOCK: %s (ss=%u snq=%u seq=%u)\n", result___1.status.lock_str,
                    result___1.status.signal_strength, result___1.status.signal_to_noise_quality,
                    result___1.status.symbol_error_quality);
    }
#line 311
    if (result___1.transport_stream_id_detected) {
      {
#line 312
      cmd_scan_printf(fp, "TSID: 0x%04X\n", (int )result___1.transport_stream_id);
      }
    }
#line 316
    i = 0;
    {
#line 316
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 316
      if (! (i < result___1.program_count)) {
#line 316
        goto while_break___0;
      }
      {
#line 317
      program = & result___1.programs[i];
#line 318
      cmd_scan_printf(fp, "PROGRAM %s\n", program->program_str);
#line 316
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 322
  hdhomerun_device_tuner_lockkey_release(hd);
  }
#line 324
  if (fp) {
    {
#line 325
    fclose(fp);
    }
  }
#line 327
  if (ret < 0) {
    {
#line 328
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"communication error sending request to hdhomerun device\n");
    }
  }
#line 330
  return (ret);
}
}
#line 333 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_config.c"
static void cmd_save_print_stats(void) 
{ 
  struct hdhomerun_video_stats_t stats ;

  {
  {
#line 336
  hdhomerun_device_get_video_stats(hd, & stats);
#line 338
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%u packets received, %u overflow errors, %u network errors, %u transport errors, %u sequence errors\n",
          stats.packet_count, stats.overflow_error_count, stats.network_error_count,
          stats.transport_error_count, stats.sequence_error_count);
  }
#line 345
  return;
}
}
#line 347 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_config.c"
static int cmd_save(char const   *tuner_str , char const   *filename ) 
{ 
  int tmp ;
  FILE *fp ;
  int tmp___0 ;
  int tmp___1 ;
  int ret ;
  int tmp___2 ;
  struct hdhomerun_video_stats_t stats_old ;
  struct hdhomerun_video_stats_t stats_cur ;
  uint64_t next_progress ;
  uint64_t tmp___3 ;
  uint64_t loop_start_time ;
  uint64_t tmp___4 ;
  size_t actual_size ;
  uint8_t *ptr ;
  uint8_t *tmp___5 ;
  size_t tmp___6 ;
  int32_t delay ;
  uint64_t tmp___7 ;

  {
  {
#line 349
  tmp = hdhomerun_device_set_tuner_from_str(hd, tuner_str);
  }
#line 349
  if (tmp <= 0) {
    {
#line 350
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"invalid tuner number\n");
    }
#line 351
    return (-1);
  }
  {
#line 355
  tmp___1 = strcmp(filename, "null");
  }
#line 355
  if (tmp___1 == 0) {
#line 356
    fp = (FILE *)((void *)0);
  } else {
    {
#line 357
    tmp___0 = strcmp(filename, "-");
    }
#line 357
    if (tmp___0 == 0) {
#line 358
      fp = stdout;
    } else {
      {
#line 360
      fp = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"wb");
      }
#line 361
      if (! fp) {
        {
#line 362
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unable to create file %s\n",
                filename);
        }
#line 363
        return (-1);
      }
    }
  }
  {
#line 367
  tmp___2 = hdhomerun_device_stream_start(hd);
#line 367
  ret = tmp___2;
  }
#line 368
  if (ret <= 0) {
    {
#line 369
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unable to start stream\n");
    }
#line 370
    if (fp) {
#line 370
      if ((unsigned long )fp != (unsigned long )stdout) {
        {
#line 371
        fclose(fp);
        }
      }
    }
#line 373
    return (ret);
  }
  {
#line 376
  register_signal_handlers(& sigabort_handler, & sigabort_handler, & siginfo_handler);
#line 379
  hdhomerun_device_get_video_stats(hd, & stats_old);
#line 381
  tmp___3 = getcurrenttime();
#line 381
  next_progress = tmp___3 + 1000UL;
  }
  {
#line 383
  while (1) {
    while_continue: /* CIL Label */ ;
#line 383
    if (! (! sigabort_flag)) {
#line 383
      goto while_break;
    }
    {
#line 384
    tmp___4 = getcurrenttime();
#line 384
    loop_start_time = tmp___4;
    }
#line 386
    if (siginfo_flag) {
      {
#line 387
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 388
      cmd_save_print_stats();
#line 389
      siginfo_flag = (int volatile   )0;
      }
    }
    {
#line 393
    tmp___5 = hdhomerun_device_stream_recv(hd, (size_t )2500000, & actual_size);
#line 393
    ptr = tmp___5;
    }
#line 394
    if (! ptr) {
      {
#line 395
      msleep_approx((uint64_t )64);
      }
#line 396
      goto while_continue;
    }
#line 399
    if (fp) {
      {
#line 400
      tmp___6 = fwrite((void const   */* __restrict  */)ptr, (size_t )1, actual_size,
                       (FILE */* __restrict  */)fp);
      }
#line 400
      if (tmp___6 != actual_size) {
        {
#line 401
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error writing output\n");
        }
#line 402
        return (-1);
      }
    }
#line 406
    if (loop_start_time >= next_progress) {
#line 407
      next_progress += 1000UL;
#line 408
      if (loop_start_time >= next_progress) {
#line 409
        next_progress = loop_start_time + 1000UL;
      }
      {
#line 418
      hdhomerun_device_get_video_stats(hd, & stats_cur);
      }
#line 420
      if (stats_cur.overflow_error_count > stats_old.overflow_error_count) {
        {
#line 421
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"o");
        }
      } else
#line 422
      if (stats_cur.network_error_count > stats_old.network_error_count) {
        {
#line 423
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"n");
        }
      } else
#line 424
      if (stats_cur.transport_error_count > stats_old.transport_error_count) {
        {
#line 425
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"t");
        }
      } else
#line 426
      if (stats_cur.sequence_error_count > stats_old.sequence_error_count) {
        {
#line 427
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"s");
        }
      } else {
        {
#line 429
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)".");
        }
      }
      {
#line 432
      stats_old = stats_cur;
#line 433
      fflush(stderr);
      }
    }
    {
#line 436
    tmp___7 = getcurrenttime();
#line 436
    delay = 64 - (int32_t )(tmp___7 - loop_start_time);
    }
#line 437
    if (delay <= 0) {
#line 438
      goto while_continue;
    }
    {
#line 441
    msleep_approx((uint64_t )delay);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 444
  if (fp) {
    {
#line 445
    fclose(fp);
    }
  }
  {
#line 448
  hdhomerun_device_stream_stop(hd);
#line 450
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 451
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-- Video statistics --\n");
#line 452
  cmd_save_print_stats();
  }
#line 454
  return (0);
}
}
#line 457 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_config.c"
static int cmd_upgrade(char const   *filename ) 
{ 
  FILE *fp ;
  FILE *tmp ;
  int tmp___0 ;
  int count ;
  char *version_str ;
  int tmp___1 ;

  {
  {
#line 459
  tmp = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"rb");
#line 459
  fp = tmp;
  }
#line 460
  if (! fp) {
    {
#line 461
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unable to open file %s\n",
            filename);
    }
#line 462
    return (-1);
  }
  {
#line 465
  printf((char const   */* __restrict  */)"uploading firmware...\n");
#line 466
  tmp___0 = hdhomerun_device_upgrade(hd, fp);
  }
#line 466
  if (tmp___0 <= 0) {
    {
#line 467
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error sending upgrade file to hdhomerun device\n");
#line 468
    fclose(fp);
    }
#line 469
    return (-1);
  }
  {
#line 472
  fclose(fp);
#line 473
  msleep_minimum((uint64_t )2000);
#line 475
  printf((char const   */* __restrict  */)"upgrading firmware...\n");
#line 476
  msleep_minimum((uint64_t )8000);
#line 478
  printf((char const   */* __restrict  */)"rebooting...\n");
#line 479
  count = 0;
  }
  {
#line 481
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 482
    tmp___1 = hdhomerun_device_get_version(hd, & version_str, (uint32_t *)((void *)0));
    }
#line 482
    if (tmp___1 >= 0) {
#line 483
      goto while_break;
    }
#line 486
    count ++;
#line 487
    if (count > 30) {
      {
#line 488
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error finding device after firmware upgrade\n");
      }
#line 489
      return (-1);
    }
    {
#line 492
    msleep_minimum((uint64_t )1000);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 495
  printf((char const   */* __restrict  */)"upgrade complete - now running firmware %s\n",
         version_str);
  }
#line 496
  return (0);
}
}
#line 499 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_config.c"
static int cmd_execute(void) 
{ 
  char *ret_value ;
  char *ret_error ;
  int tmp ;
  char *end ;
  size_t tmp___0 ;
  char *pos ;
  char *eol_r ;
  char *tmp___1 ;
  char *eol_n ;
  char *tmp___2 ;
  char *eol ;
  char *sep ;
  char *tmp___3 ;
  char *item ;
  char *value ;

  {
  {
#line 503
  tmp = hdhomerun_device_get_var(hd, "/sys/boot", & ret_value, & ret_error);
  }
#line 503
  if (tmp < 0) {
    {
#line 504
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"communication error sending request to hdhomerun device\n");
    }
#line 505
    return (-1);
  }
#line 508
  if (ret_error) {
    {
#line 509
    printf((char const   */* __restrict  */)"%s\n", ret_error);
    }
#line 510
    return (0);
  }
  {
#line 513
  tmp___0 = strlen((char const   *)ret_value);
#line 513
  end = ret_value + tmp___0;
#line 514
  pos = ret_value;
  }
  {
#line 516
  while (1) {
    while_continue: /* CIL Label */ ;
#line 517
    if ((unsigned long )pos >= (unsigned long )end) {
#line 518
      goto while_break;
    }
    {
#line 521
    tmp___1 = strchr((char const   *)pos, '\r');
#line 521
    eol_r = tmp___1;
    }
#line 522
    if (! eol_r) {
#line 523
      eol_r = end;
    }
    {
#line 526
    tmp___2 = strchr((char const   *)pos, '\n');
#line 526
    eol_n = tmp___2;
    }
#line 527
    if (! eol_n) {
#line 528
      eol_n = end;
    }
#line 531
    eol = eol_r;
#line 532
    if ((unsigned long )eol_n < (unsigned long )eol) {
#line 533
      eol = eol_n;
    }
    {
#line 536
    tmp___3 = strchr((char const   *)pos, ' ');
#line 536
    sep = tmp___3;
    }
#line 537
    if (! sep) {
#line 538
      pos = eol + 1;
#line 539
      goto while_continue;
    } else
#line 537
    if ((unsigned long )sep > (unsigned long )eol) {
#line 538
      pos = eol + 1;
#line 539
      goto while_continue;
    }
    {
#line 542
    *sep = (char)0;
#line 543
    *eol = (char)0;
#line 545
    item = pos;
#line 546
    value = sep + 1;
#line 548
    printf((char const   */* __restrict  */)"set %s \"%s\"\n", item, value);
#line 550
    cmd_set_internal((char const   *)item, (char const   *)value);
#line 552
    pos = eol + 1;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 555
  return (1);
}
}
#line 558 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_config.c"
static int main_cmd(int argc , char **argv ) 
{ 
  int tmp ;
  char *cmd ;
  char **tmp___0 ;
  int tmp___1 ;
  uint32_t lockkey ;
  unsigned long tmp___2 ;
  bool_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  bool_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  bool_t tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  bool_t tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  bool_t tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  bool_t tmp___19 ;
  int tmp___20 ;
  bool_t tmp___21 ;
  int tmp___22 ;

  {
#line 560
  if (argc < 1) {
    {
#line 561
    tmp = help();
    }
#line 561
    return (tmp);
  }
  {
#line 564
  tmp___0 = argv;
#line 564
  argv ++;
#line 564
  cmd = *tmp___0;
#line 564
  argc --;
#line 566
  tmp___3 = contains((char const   *)cmd, "key");
  }
#line 566
  if (tmp___3) {
#line 567
    if (argc < 2) {
      {
#line 568
      tmp___1 = help();
      }
#line 568
      return (tmp___1);
    }
    {
#line 570
    tmp___2 = strtoul((char const   */* __restrict  */)*(argv + 0), (char **/* __restrict  */)((void *)0),
                      0);
#line 570
    lockkey = (uint32_t )tmp___2;
#line 571
    hdhomerun_device_tuner_lockkey_use_value(hd, lockkey);
#line 573
    cmd = *(argv + 1);
#line 574
    argv += 2;
#line 574
    argc -= 2;
    }
  }
  {
#line 577
  tmp___6 = contains((char const   *)cmd, "get");
  }
#line 577
  if (tmp___6) {
#line 578
    if (argc < 1) {
      {
#line 579
      tmp___4 = help();
      }
#line 579
      return (tmp___4);
    }
    {
#line 581
    tmp___5 = cmd_get((char const   *)*(argv + 0));
    }
#line 581
    return (tmp___5);
  }
  {
#line 584
  tmp___9 = contains((char const   *)cmd, "set");
  }
#line 584
  if (tmp___9) {
#line 585
    if (argc < 2) {
      {
#line 586
      tmp___7 = help();
      }
#line 586
      return (tmp___7);
    }
    {
#line 588
    tmp___8 = cmd_set((char const   *)*(argv + 0), (char const   *)*(argv + 1));
    }
#line 588
    return (tmp___8);
  }
  {
#line 591
  tmp___13 = contains((char const   *)cmd, "scan");
  }
#line 591
  if (tmp___13) {
#line 592
    if (argc < 1) {
      {
#line 593
      tmp___10 = help();
      }
#line 593
      return (tmp___10);
    }
#line 595
    if (argc < 2) {
      {
#line 596
      tmp___11 = cmd_scan((char const   *)*(argv + 0), (char const   *)((void *)0));
      }
#line 596
      return (tmp___11);
    } else {
      {
#line 598
      tmp___12 = cmd_scan((char const   *)*(argv + 0), (char const   *)*(argv + 1));
      }
#line 598
      return (tmp___12);
    }
  }
  {
#line 602
  tmp___16 = contains((char const   *)cmd, "save");
  }
#line 602
  if (tmp___16) {
#line 603
    if (argc < 2) {
      {
#line 604
      tmp___14 = help();
      }
#line 604
      return (tmp___14);
    }
    {
#line 606
    tmp___15 = cmd_save((char const   *)*(argv + 0), (char const   *)*(argv + 1));
    }
#line 606
    return (tmp___15);
  }
  {
#line 609
  tmp___19 = contains((char const   *)cmd, "upgrade");
  }
#line 609
  if (tmp___19) {
#line 610
    if (argc < 1) {
      {
#line 611
      tmp___17 = help();
      }
#line 611
      return (tmp___17);
    }
    {
#line 613
    tmp___18 = cmd_upgrade((char const   *)*(argv + 0));
    }
#line 613
    return (tmp___18);
  }
  {
#line 616
  tmp___21 = contains((char const   *)cmd, "execute");
  }
#line 616
  if (tmp___21) {
    {
#line 617
    tmp___20 = cmd_execute();
    }
#line 617
    return (tmp___20);
  }
  {
#line 620
  tmp___22 = help();
  }
#line 620
  return (tmp___22);
}
}
#line 623 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_config.c"
static int main_internal(int argc , char **argv ) 
{ 
  int tmp ;
  char *id_str ;
  char **tmp___0 ;
  int tmp___1 ;
  bool_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  bool_t tmp___5 ;
  uint32_t device_id_requested ;
  uint32_t tmp___6 ;
  bool_t tmp___7 ;
  char const   *model ;
  char const   *tmp___8 ;
  int ret ;
  int tmp___9 ;

  {
  {
#line 632
  extract_appname((char const   *)*(argv + 0));
#line 633
  argv ++;
#line 634
  argc --;
  }
#line 636
  if (argc == 0) {
    {
#line 637
    tmp = help();
    }
#line 637
    return (tmp);
  }
  {
#line 640
  tmp___0 = argv;
#line 640
  argv ++;
#line 640
  id_str = *tmp___0;
#line 640
  argc --;
#line 641
  tmp___2 = contains((char const   *)id_str, "help");
  }
#line 641
  if (tmp___2) {
    {
#line 642
    tmp___1 = help();
    }
#line 642
    return (tmp___1);
  }
  {
#line 644
  tmp___5 = contains((char const   *)id_str, "discover");
  }
#line 644
  if (tmp___5) {
#line 645
    if (argc < 1) {
      {
#line 646
      tmp___3 = discover_print((char *)((void *)0));
      }
#line 646
      return (tmp___3);
    } else {
      {
#line 648
      tmp___4 = discover_print(*(argv + 0));
      }
#line 648
      return (tmp___4);
    }
  }
  {
#line 653
  hd = hdhomerun_device_create_from_str((char const   *)id_str, (struct hdhomerun_debug_t *)((void *)0));
  }
#line 654
  if (! hd) {
    {
#line 655
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"invalid device id: %s\n",
            id_str);
    }
#line 656
    return (-1);
  }
  {
#line 660
  tmp___6 = hdhomerun_device_get_device_id_requested(hd);
#line 660
  device_id_requested = tmp___6;
#line 661
  tmp___7 = hdhomerun_discover_validate_device_id(device_id_requested);
  }
#line 661
  if (! tmp___7) {
    {
#line 662
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"invalid device id: %08X\n",
            device_id_requested);
    }
  }
  {
#line 666
  tmp___8 = hdhomerun_device_get_model_str(hd);
#line 666
  model = tmp___8;
  }
#line 667
  if (! model) {
    {
#line 668
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unable to connect to device\n");
#line 669
    hdhomerun_device_destroy(hd);
    }
#line 670
    return (-1);
  }
  {
#line 674
  tmp___9 = main_cmd(argc, argv);
#line 674
  ret = tmp___9;
#line 677
  hdhomerun_device_destroy(hd);
  }
#line 680
  return (ret);
}
}
#line 683 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_config.c"
int main(int argc , char **argv ) 
{ 
  int ret ;
  int tmp ;

  {
  {
#line 685
  tmp = main_internal(argc, argv);
#line 685
  ret = tmp;
  }
#line 686
  if (ret <= 0) {
#line 687
    return (1);
  }
#line 689
  return (0);
}
}
#line 48 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_pkt.c"
static uint32_t hdhomerun_pkt_calc_crc___0(uint8_t *start , uint8_t *end ) 
{ 
  uint8_t *pos ;
  uint32_t crc ;
  uint8_t x ;
  uint8_t *tmp ;

  {
#line 50
  pos = start;
#line 51
  crc = 4294967295U;
  {
#line 52
  while (1) {
    while_continue: /* CIL Label */ ;
#line 52
    if (! ((unsigned long )pos < (unsigned long )end)) {
#line 52
      goto while_break;
    }
#line 53
    tmp = pos;
#line 53
    pos ++;
#line 53
    x = (uint8_t )((int )((uint8_t )crc) ^ (int )*tmp);
#line 54
    crc >>= 8;
#line 55
    if ((int )x & 1) {
#line 55
      crc ^= 1996959894U;
    }
#line 56
    if ((int )x & 2) {
#line 56
      crc ^= 3993919788U;
    }
#line 57
    if ((int )x & 4) {
#line 57
      crc ^= 124634137U;
    }
#line 58
    if ((int )x & 8) {
#line 58
      crc ^= 249268274U;
    }
#line 59
    if ((int )x & 16) {
#line 59
      crc ^= 498536548U;
    }
#line 60
    if ((int )x & 32) {
#line 60
      crc ^= 997073096U;
    }
#line 61
    if ((int )x & 64) {
#line 61
      crc ^= 1994146192U;
    }
#line 62
    if ((int )x & 128) {
#line 62
      crc ^= 3988292384U;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 64
  return (crc ^ 4294967295U);
}
}
#line 40 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_discover.c"
static bool_t hdhomerun_discover_sock_add___0(struct hdhomerun_discover_t *ds , uint32_t local_ip ,
                                              uint32_t subnet_mask ) 
{ 
  unsigned int i ;
  struct hdhomerun_discover_sock_t *dss ;
  hdhomerun_sock_t sock ;
  hdhomerun_sock_t tmp ;
  bool_t tmp___0 ;
  struct hdhomerun_discover_sock_t *dss___0 ;
  unsigned int tmp___1 ;

  {
#line 43
  i = 1U;
  {
#line 43
  while (1) {
    while_continue: /* CIL Label */ ;
#line 43
    if (! (i < ds->sock_count)) {
#line 43
      goto while_break;
    }
#line 44
    dss = & ds->socks[i];
#line 46
    if (dss->local_ip == local_ip) {
#line 46
      if (dss->subnet_mask == subnet_mask) {
#line 47
        dss->detected = 1;
#line 48
        return (1);
      }
    }
#line 43
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 52
  if (ds->sock_count >= 16U) {
#line 53
    return (0);
  }
  {
#line 57
  tmp = hdhomerun_sock_create_udp();
#line 57
  sock = tmp;
  }
#line 58
  if (sock == -1) {
#line 59
    return (0);
  }
  {
#line 63
  tmp___0 = hdhomerun_sock_bind(sock, local_ip, (uint16_t )0, 0);
  }
#line 63
  if (! tmp___0) {
    {
#line 64
    hdhomerun_debug_printf(ds->dbg, "discover: failed to bind to %u.%u.%u.%u:0\n",
                           (local_ip >> 24) & 255U, (local_ip >> 16) & 255U, (local_ip >> 8) & 255U,
                           local_ip & 255U);
#line 65
    hdhomerun_sock_destroy(sock);
    }
#line 66
    return (0);
  }
#line 70
  tmp___1 = ds->sock_count;
#line 70
  (ds->sock_count) ++;
#line 70
  dss___0 = & ds->socks[tmp___1];
#line 71
  dss___0->sock = sock;
#line 72
  dss___0->detected = 1;
#line 73
  dss___0->local_ip = local_ip;
#line 74
  dss___0->subnet_mask = subnet_mask;
#line 76
  return (1);
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_discover.c"
static void hdhomerun_discover_sock_detect___0(struct hdhomerun_discover_t *ds ) 
{ 
  unsigned int i ;
  struct hdhomerun_discover_sock_t *dss ;
  struct hdhomerun_local_ip_info_t ip_info_list[16] ;
  int count ;
  int tmp ;
  int index___0 ;
  struct hdhomerun_local_ip_info_t *ip_info ;
  struct hdhomerun_discover_sock_t *src ;
  struct hdhomerun_discover_sock_t *dst ;

  {
#line 112
  i = 1U;
  {
#line 112
  while (1) {
    while_continue: /* CIL Label */ ;
#line 112
    if (! (i < ds->sock_count)) {
#line 112
      goto while_break;
    }
#line 113
    dss = & ds->socks[i];
#line 114
    dss->detected = 0;
#line 112
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 118
  tmp = hdhomerun_local_ip_info(ip_info_list, 16);
#line 118
  count = tmp;
  }
#line 119
  if (count < 0) {
    {
#line 120
    hdhomerun_debug_printf(ds->dbg, "discover: hdhomerun_local_ip_info returned error\n");
#line 121
    count = 0;
    }
  }
#line 123
  if (count > 16) {
    {
#line 124
    hdhomerun_debug_printf(ds->dbg, "discover: too many local IP addresses\n");
#line 125
    count = 16;
    }
  }
#line 129
  index___0 = 0;
  {
#line 129
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 129
    if (! (index___0 < count)) {
#line 129
      goto while_break___0;
    }
    {
#line 130
    ip_info = & ip_info_list[index___0];
#line 131
    hdhomerun_discover_sock_add___0(ds, ip_info->ip_addr, ip_info->subnet_mask);
#line 129
    index___0 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 134
  src = & ds->socks[1];
#line 135
  dst = & ds->socks[1];
#line 136
  count = 1;
#line 137
  i = 1U;
  {
#line 137
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 137
    if (! (i < ds->sock_count)) {
#line 137
      goto while_break___1;
    }
#line 138
    if (! src->detected) {
      {
#line 139
      hdhomerun_sock_destroy(src->sock);
#line 140
      src ++;
      }
#line 141
      goto __Cont;
    }
#line 143
    if ((unsigned long )dst != (unsigned long )src) {
#line 144
      *dst = *src;
    }
#line 146
    src ++;
#line 147
    dst ++;
#line 148
    count ++;
    __Cont: /* CIL Label */ 
#line 137
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 151
  ds->sock_count = (unsigned int )count;
#line 152
  return;
}
}
#line 154 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_discover.c"
static bool_t hdhomerun_discover_send_internal___0(struct hdhomerun_discover_t *ds ,
                                                   struct hdhomerun_discover_sock_t *dss ,
                                                   uint32_t target_ip , uint32_t device_type ,
                                                   uint32_t device_id ) 
{ 
  struct hdhomerun_pkt_t *tx_pkt ;
  bool_t tmp ;

  {
  {
#line 156
  tx_pkt = & ds->tx_pkt;
#line 157
  hdhomerun_pkt_reset(tx_pkt);
#line 159
  hdhomerun_pkt_write_u8(tx_pkt, (uint8_t )1);
#line 160
  hdhomerun_pkt_write_var_length(tx_pkt, (size_t )4);
#line 161
  hdhomerun_pkt_write_u32(tx_pkt, device_type);
#line 162
  hdhomerun_pkt_write_u8(tx_pkt, (uint8_t )2);
#line 163
  hdhomerun_pkt_write_var_length(tx_pkt, (size_t )4);
#line 164
  hdhomerun_pkt_write_u32(tx_pkt, device_id);
#line 165
  hdhomerun_pkt_seal_frame(tx_pkt, (uint16_t )2);
#line 167
  tmp = hdhomerun_sock_sendto(dss->sock, target_ip, (uint16_t )65001, (void const   *)tx_pkt->start,
                              (size_t )(tx_pkt->end - tx_pkt->start), (uint64_t )0);
  }
#line 167
  return (tmp);
}
}
#line 170 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_discover.c"
static bool_t hdhomerun_discover_send_wildcard_ip___0(struct hdhomerun_discover_t *ds ,
                                                      uint32_t device_type , uint32_t device_id ) 
{ 
  bool_t result___1 ;
  unsigned int i ;
  struct hdhomerun_discover_sock_t *dss ;
  uint32_t target_ip ;
  bool_t tmp ;
  struct hdhomerun_discover_sock_t *dss___0 ;

  {
#line 172
  result___1 = 0;
#line 179
  i = 1U;
  {
#line 179
  while (1) {
    while_continue: /* CIL Label */ ;
#line 179
    if (! (i < ds->sock_count)) {
#line 179
      goto while_break;
    }
    {
#line 180
    dss = & ds->socks[i];
#line 181
    target_ip = dss->local_ip | ~ dss->subnet_mask;
#line 182
    tmp = hdhomerun_discover_send_internal___0(ds, dss, target_ip, device_type, device_id);
#line 182
    result___1 |= tmp;
#line 179
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 188
  if (! result___1) {
    {
#line 189
    dss___0 = & ds->socks[0];
#line 190
    result___1 = hdhomerun_discover_send_internal___0(ds, dss___0, 4294967295U, device_type,
                                                      device_id);
    }
  }
#line 193
  return (result___1);
}
}
#line 196 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_discover.c"
static bool_t hdhomerun_discover_send_target_ip___0(struct hdhomerun_discover_t *ds ,
                                                    uint32_t target_ip , uint32_t device_type ,
                                                    uint32_t device_id ) 
{ 
  bool_t result___1 ;
  unsigned int i ;
  struct hdhomerun_discover_sock_t *dss ;
  bool_t tmp ;
  struct hdhomerun_discover_sock_t *dss___0 ;

  {
#line 198
  result___1 = 0;
#line 205
  i = 1U;
  {
#line 205
  while (1) {
    while_continue: /* CIL Label */ ;
#line 205
    if (! (i < ds->sock_count)) {
#line 205
      goto while_break;
    }
#line 206
    dss = & ds->socks[i];
#line 207
    if ((target_ip & dss->subnet_mask) != (dss->local_ip & dss->subnet_mask)) {
#line 208
      goto __Cont;
    }
    {
#line 211
    tmp = hdhomerun_discover_send_internal___0(ds, dss, target_ip, device_type, device_id);
#line 211
    result___1 |= tmp;
    }
    __Cont: /* CIL Label */ 
#line 205
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 217
  if (! result___1) {
    {
#line 218
    dss___0 = & ds->socks[0];
#line 219
    result___1 = hdhomerun_discover_send_internal___0(ds, dss___0, target_ip, device_type,
                                                      device_id);
    }
  }
#line 222
  return (result___1);
}
}
#line 225 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_discover.c"
static bool_t hdhomerun_discover_send___0(struct hdhomerun_discover_t *ds , uint32_t target_ip ,
                                          uint32_t device_type , uint32_t device_id ) 
{ 
  bool_t tmp ;
  bool_t tmp___0 ;

  {
#line 227
  if (target_ip == 0U) {
    {
#line 228
    tmp = hdhomerun_discover_send_wildcard_ip___0(ds, device_type, device_id);
    }
#line 228
    return (tmp);
  } else {
    {
#line 230
    tmp___0 = hdhomerun_discover_send_target_ip___0(ds, target_ip, device_type, device_id);
    }
#line 230
    return (tmp___0);
  }
}
}
#line 234 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_discover.c"
static bool_t hdhomerun_discover_recv_internal___0(struct hdhomerun_discover_t *ds ,
                                                   struct hdhomerun_discover_sock_t *dss ,
                                                   struct hdhomerun_discover_device_t *result___1 ) 
{ 
  struct hdhomerun_pkt_t *rx_pkt ;
  uint32_t remote_addr ;
  uint16_t remote_port ;
  size_t length ;
  bool_t tmp ;
  uint16_t type ;
  bool_t tmp___0 ;
  uint8_t tag ;
  size_t len ;
  uint8_t *next ;
  uint8_t *tmp___1 ;

  {
  {
#line 236
  rx_pkt = & ds->rx_pkt;
#line 237
  hdhomerun_pkt_reset(rx_pkt);
#line 241
  length = (size_t )(rx_pkt->limit - rx_pkt->end);
#line 242
  tmp = hdhomerun_sock_recvfrom(dss->sock, & remote_addr, & remote_port, (void *)rx_pkt->end,
                                & length, (uint64_t )0);
  }
#line 242
  if (! tmp) {
#line 243
    return (0);
  }
  {
#line 246
  rx_pkt->end += length;
#line 249
  tmp___0 = hdhomerun_pkt_open_frame(rx_pkt, & type);
  }
#line 249
  if (tmp___0 <= 0) {
#line 250
    return (0);
  }
#line 252
  if ((int )type != 3) {
#line 253
    return (0);
  }
#line 256
  result___1->ip_addr = remote_addr;
#line 257
  result___1->device_type = (uint32_t )0;
#line 258
  result___1->device_id = (uint32_t )0;
#line 259
  result___1->tuner_count = (uint8_t )0;
  {
#line 261
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 264
    tmp___1 = hdhomerun_pkt_read_tlv(rx_pkt, & tag, & len);
#line 264
    next = tmp___1;
    }
#line 265
    if (! next) {
#line 266
      goto while_break;
    }
    {
#line 270
    if ((int )tag == 1) {
#line 270
      goto case_1;
    }
#line 277
    if ((int )tag == 2) {
#line 277
      goto case_2;
    }
#line 284
    if ((int )tag == 16) {
#line 284
      goto case_16;
    }
#line 291
    goto switch_default;
    case_1: /* CIL Label */ 
#line 271
    if (len != 4UL) {
#line 272
      goto switch_break;
    }
    {
#line 274
    result___1->device_type = hdhomerun_pkt_read_u32(rx_pkt);
    }
#line 275
    goto switch_break;
    case_2: /* CIL Label */ 
#line 278
    if (len != 4UL) {
#line 279
      goto switch_break;
    }
    {
#line 281
    result___1->device_id = hdhomerun_pkt_read_u32(rx_pkt);
    }
#line 282
    goto switch_break;
    case_16: /* CIL Label */ 
#line 285
    if (len != 1UL) {
#line 286
      goto switch_break;
    }
    {
#line 288
    result___1->tuner_count = hdhomerun_pkt_read_u8(rx_pkt);
    }
#line 289
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 292
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 295
    rx_pkt->pos = next;
  }
  while_break: /* CIL Label */ ;
  }
#line 299
  if ((int )result___1->tuner_count == 0) {
    {
#line 301
    if (result___1->device_id >> 20 == 258U) {
#line 301
      goto case_258;
    }
#line 307
    if (result___1->device_id >> 20 == 289U) {
#line 307
      goto case_289;
    }
#line 307
    if (result___1->device_id >> 20 == 257U) {
#line 307
      goto case_289;
    }
#line 307
    if (result___1->device_id >> 20 == 256U) {
#line 307
      goto case_289;
    }
#line 311
    goto switch_default___0;
    case_258: /* CIL Label */ 
#line 302
    result___1->tuner_count = (uint8_t )1;
#line 303
    goto switch_break___0;
    case_289: /* CIL Label */ 
    case_257: /* CIL Label */ 
    case_256: /* CIL Label */ 
#line 308
    result___1->tuner_count = (uint8_t )2;
#line 309
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 312
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
#line 316
  return (1);
}
}
#line 319 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_discover.c"
static bool_t hdhomerun_discover_recv___0(struct hdhomerun_discover_t *ds , struct hdhomerun_discover_device_t *result___1 ) 
{ 
  unsigned int i ;
  struct hdhomerun_discover_sock_t *dss ;
  bool_t tmp ;

  {
#line 322
  i = 0U;
  {
#line 322
  while (1) {
    while_continue: /* CIL Label */ ;
#line 322
    if (! (i < ds->sock_count)) {
#line 322
      goto while_break;
    }
    {
#line 323
    dss = & ds->socks[i];
#line 325
    tmp = hdhomerun_discover_recv_internal___0(ds, dss, result___1);
    }
#line 325
    if (tmp) {
#line 326
      return (1);
    }
#line 322
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 330
  return (0);
}
}
#line 333 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_discover.c"
static struct hdhomerun_discover_device_t *hdhomerun_discover_find_in_list___0(struct hdhomerun_discover_device_t *result_list ,
                                                                               int count ,
                                                                               struct hdhomerun_discover_device_t *lookup ) 
{ 
  int index___0 ;
  struct hdhomerun_discover_device_t *entry ;
  int tmp ;

  {
#line 336
  index___0 = 0;
  {
#line 336
  while (1) {
    while_continue: /* CIL Label */ ;
#line 336
    if (! (index___0 < count)) {
#line 336
      goto while_break;
    }
    {
#line 337
    entry = result_list + index___0;
#line 338
    tmp = memcmp((void const   *)lookup, (void const   *)entry, sizeof(struct hdhomerun_discover_device_t ));
    }
#line 338
    if (tmp == 0) {
#line 339
      return (entry);
    }
#line 336
    index___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 343
  return ((struct hdhomerun_discover_device_t *)((void *)0));
}
}
#line 417 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_discover.c"
static uint32_t lookup_table___0[16]  = 
#line 417
  {      (uint32_t )10,      (uint32_t )5,      (uint32_t )15,      (uint32_t )6, 
        (uint32_t )7,      (uint32_t )12,      (uint32_t )1,      (uint32_t )11, 
        (uint32_t )9,      (uint32_t )2,      (uint32_t )8,      (uint32_t )13, 
        (uint32_t )4,      (uint32_t )3,      (uint32_t )14,      (uint32_t )0};
#line 208 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device_selector.c"
static bool_t hdhomerun_device_selector_choose_test___0(struct hdhomerun_device_selector_t *hds ,
                                                        struct hdhomerun_device_t *test_hd ) 
{ 
  char const   *name ;
  char const   *tmp ;
  char *error ;
  int ret ;
  int tmp___0 ;
  char *target ;
  char *ptr ;
  char *tmp___1 ;
  unsigned int a[4] ;
  unsigned int target_port ;
  int tmp___2 ;
  uint32_t target_ip ;
  uint32_t local_ip ;
  uint32_t tmp___3 ;
  hdhomerun_sock_t test_sock ;
  hdhomerun_sock_t tmp___4 ;
  bool_t inuse ;
  bool_t tmp___5 ;

  {
  {
#line 210
  tmp = hdhomerun_device_get_name(test_hd);
#line 210
  name = tmp;
#line 216
  tmp___0 = hdhomerun_device_tuner_lockkey_request(test_hd, & error);
#line 216
  ret = tmp___0;
  }
#line 217
  if (ret > 0) {
    {
#line 218
    hdhomerun_debug_printf(hds->dbg, "hdhomerun_device_selector_choose_test: device %s chosen\n",
                           name);
    }
#line 219
    return (1);
  }
#line 221
  if (ret < 0) {
    {
#line 222
    hdhomerun_debug_printf(hds->dbg, "hdhomerun_device_selector_choose_test: device %s communication error\n",
                           name);
    }
#line 223
    return (0);
  }
  {
#line 230
  ret = hdhomerun_device_get_tuner_target(test_hd, & target);
  }
#line 231
  if (ret < 0) {
    {
#line 232
    hdhomerun_debug_printf(hds->dbg, "hdhomerun_device_selector_choose_test: device %s communication error\n",
                           name);
    }
#line 233
    return (0);
  }
#line 235
  if (ret == 0) {
    {
#line 236
    hdhomerun_debug_printf(hds->dbg, "hdhomerun_device_selector_choose_test: device %s in use, failed to read target\n",
                           name);
    }
#line 237
    return (0);
  }
  {
#line 240
  tmp___1 = strstr((char const   *)target, "//");
#line 240
  ptr = tmp___1;
  }
#line 241
  if (ptr) {
#line 242
    target = ptr + 2;
  }
  {
#line 244
  ptr = strchr((char const   *)target, ' ');
  }
#line 245
  if (ptr) {
#line 246
    *ptr = (char)0;
  }
  {
#line 251
  tmp___2 = sscanf((char const   */* __restrict  */)target, (char const   */* __restrict  */)"%u.%u.%u.%u:%u",
                   & a[0], & a[1], & a[2], & a[3], & target_port);
  }
#line 251
  if (tmp___2 != 5) {
    {
#line 252
    hdhomerun_debug_printf(hds->dbg, "hdhomerun_device_selector_choose_test: device %s in use, no target set (%s)\n",
                           name, target);
    }
#line 253
    return (0);
  }
  {
#line 256
  target_ip = (((a[0] << 24) | (a[1] << 16)) | (a[2] << 8)) | a[3];
#line 257
  tmp___3 = hdhomerun_device_get_local_machine_addr(test_hd);
#line 257
  local_ip = tmp___3;
  }
#line 258
  if (target_ip != local_ip) {
    {
#line 259
    hdhomerun_debug_printf(hds->dbg, "hdhomerun_device_selector_choose_test: device %s in use by %s\n",
                           name, target);
    }
#line 260
    return (0);
  }
  {
#line 266
  tmp___4 = hdhomerun_sock_create_udp();
#line 266
  test_sock = tmp___4;
  }
#line 267
  if (test_sock == -1) {
    {
#line 268
    hdhomerun_debug_printf(hds->dbg, "hdhomerun_device_selector_choose_test: device %s in use, failed to create test sock\n",
                           name);
    }
#line 269
    return (0);
  }
  {
#line 272
  tmp___5 = hdhomerun_sock_bind(test_sock, (in_addr_t )0, (uint16_t )target_port,
                                0);
#line 272
  inuse = tmp___5 == 0;
#line 273
  hdhomerun_sock_destroy(test_sock);
  }
#line 275
  if (inuse) {
    {
#line 276
    hdhomerun_debug_printf(hds->dbg, "hdhomerun_device_selector_choose_test: device %s in use by local machine\n",
                           name);
    }
#line 277
    return (0);
  }
  {
#line 283
  ret = hdhomerun_device_tuner_lockkey_force(test_hd);
  }
#line 284
  if (ret < 0) {
    {
#line 285
    hdhomerun_debug_printf(hds->dbg, "hdhomerun_device_selector_choose_test: device %s communication error\n",
                           name);
    }
#line 286
    return (0);
  }
#line 288
  if (ret == 0) {
    {
#line 289
    hdhomerun_debug_printf(hds->dbg, "hdhomerun_device_selector_choose_test: device %s in use by local machine, dead target, failed to force release lockkey\n",
                           name);
    }
#line 290
    return (0);
  }
  {
#line 293
  hdhomerun_debug_printf(hds->dbg, "hdhomerun_device_selector_choose_test: device %s in use by local machine, dead target, lockkey force successful\n",
                         name);
#line 298
  ret = hdhomerun_device_tuner_lockkey_request(test_hd, & error);
  }
#line 299
  if (ret > 0) {
    {
#line 300
    hdhomerun_debug_printf(hds->dbg, "hdhomerun_device_selector_choose_test: device %s chosen\n",
                           name);
    }
#line 301
    return (1);
  }
#line 303
  if (ret < 0) {
    {
#line 304
    hdhomerun_debug_printf(hds->dbg, "hdhomerun_device_selector_choose_test: device %s communication error\n",
                           name);
    }
#line 305
    return (0);
  }
  {
#line 308
  hdhomerun_debug_printf(hds->dbg, "hdhomerun_device_selector_choose_test: device %s still in use after lockkey force (%s)\n",
                         name, error);
  }
#line 309
  return (0);
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
static int hdhomerun_device_set_device_normal___0(struct hdhomerun_device_t *hd___0 ,
                                                  uint32_t device_id , uint32_t device_ip ) 
{ 


  {
#line 39
  if (! hd___0->cs) {
    {
#line 40
    hd___0->cs = hdhomerun_control_create((uint32_t )0, (uint32_t )0, hd___0->dbg);
    }
#line 41
    if (! hd___0->cs) {
      {
#line 42
      hdhomerun_debug_printf(hd___0->dbg, "hdhomerun_device_set_device: failed to create control object\n");
      }
#line 43
      return (-1);
    }
  }
  {
#line 47
  hdhomerun_control_set_device(hd___0->cs, device_id, device_ip);
  }
#line 49
  if (device_id == 0U) {
    {
#line 50
    device_id = hdhomerun_control_get_device_id(hd___0->cs);
    }
  } else
#line 49
  if (device_id == 4294967295U) {
    {
#line 50
    device_id = hdhomerun_control_get_device_id(hd___0->cs);
    }
  }
  {
#line 53
  hd___0->multicast_ip = (uint32_t )0;
#line 54
  hd___0->multicast_port = (uint16_t )0;
#line 55
  hd___0->device_id = device_id;
#line 56
  hd___0->tuner = 0U;
#line 57
  hd___0->lockkey = (uint32_t )0;
#line 59
  hdhomerun_sprintf(hd___0->name, hd___0->name + sizeof(hd___0->name), "%08X-%u",
                    hd___0->device_id, hd___0->tuner);
#line 60
  hdhomerun_sprintf(hd___0->model, hd___0->model + sizeof(hd___0->model), "");
  }
#line 62
  return (1);
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
static int hdhomerun_device_set_device_multicast___0(struct hdhomerun_device_t *hd___0 ,
                                                     uint32_t multicast_ip ) 
{ 
  unsigned int ip ;

  {
#line 67
  if (hd___0->cs) {
    {
#line 68
    hdhomerun_control_destroy(hd___0->cs);
#line 69
    hd___0->cs = (struct hdhomerun_control_sock_t *)((void *)0);
    }
  }
  {
#line 72
  hd___0->multicast_ip = multicast_ip;
#line 73
  hd___0->multicast_port = (uint16_t )0;
#line 74
  hd___0->device_id = (uint32_t )0;
#line 75
  hd___0->tuner = 0U;
#line 76
  hd___0->lockkey = (uint32_t )0;
#line 78
  ip = multicast_ip;
#line 79
  hdhomerun_sprintf(hd___0->name, hd___0->name + sizeof(hd___0->name), "%u.%u.%u.%u",
                    (ip >> 24) & 255U, (ip >> 16) & 255U, (ip >> 8) & 255U, ip & 255U);
#line 80
  hdhomerun_sprintf(hd___0->model, hd___0->model + sizeof(hd___0->model), "multicast");
  }
#line 82
  return (1);
}
}
#line 159 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
static bool_t is_hex_char___0(char c ) 
{ 


  {
#line 161
  if ((int )c >= 48) {
#line 161
    if ((int )c <= 57) {
#line 162
      return (1);
    }
  }
#line 164
  if ((int )c >= 65) {
#line 164
    if ((int )c <= 70) {
#line 165
      return (1);
    }
  }
#line 167
  if ((int )c >= 97) {
#line 167
    if ((int )c <= 102) {
#line 168
      return (1);
    }
  }
#line 170
  return (0);
}
}
#line 173 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
static struct hdhomerun_device_t *hdhomerun_device_create_from_str_device_id___0(char const   *device_str ,
                                                                                 struct hdhomerun_debug_t *dbg ) 
{ 
  int i ;
  char const   *ptr ;
  char const   *tmp ;
  bool_t tmp___0 ;
  unsigned int device_id ;
  int tmp___1 ;
  struct hdhomerun_device_t *tmp___2 ;
  unsigned int device_id___0 ;
  unsigned int tuner ;
  int tmp___3 ;
  struct hdhomerun_device_t *tmp___4 ;

  {
#line 176
  ptr = device_str;
#line 177
  i = 0;
  {
#line 177
  while (1) {
    while_continue: /* CIL Label */ ;
#line 177
    if (! (i < 8)) {
#line 177
      goto while_break;
    }
    {
#line 178
    tmp = ptr;
#line 178
    ptr ++;
#line 178
    tmp___0 = is_hex_char___0((char )*tmp);
    }
#line 178
    if (! tmp___0) {
#line 179
      return ((struct hdhomerun_device_t *)((void *)0));
    }
#line 177
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 183
  if ((int const   )*ptr == 0) {
    {
#line 185
    tmp___1 = sscanf((char const   */* __restrict  */)device_str, (char const   */* __restrict  */)"%x",
                     & device_id);
    }
#line 185
    if (tmp___1 != 1) {
#line 186
      return ((struct hdhomerun_device_t *)((void *)0));
    }
    {
#line 188
    tmp___2 = hdhomerun_device_create(device_id, (uint32_t )0, 0U, dbg);
    }
#line 188
    return (tmp___2);
  }
#line 191
  if ((int const   )*ptr == 45) {
    {
#line 194
    tmp___3 = sscanf((char const   */* __restrict  */)device_str, (char const   */* __restrict  */)"%x-%u",
                     & device_id___0, & tuner);
    }
#line 194
    if (tmp___3 != 2) {
#line 195
      return ((struct hdhomerun_device_t *)((void *)0));
    }
    {
#line 197
    tmp___4 = hdhomerun_device_create(device_id___0, (uint32_t )0, tuner, dbg);
    }
#line 197
    return (tmp___4);
  }
#line 200
  return ((struct hdhomerun_device_t *)((void *)0));
}
}
#line 203 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
static struct hdhomerun_device_t *hdhomerun_device_create_from_str_ip_result___0(unsigned int *a ,
                                                                                 unsigned int port ,
                                                                                 unsigned int tuner ,
                                                                                 struct hdhomerun_debug_t *dbg ) 
{ 
  uint32_t device_ip ;
  struct hdhomerun_device_t *hd___0 ;
  struct hdhomerun_device_t *tmp ;

  {
  {
#line 205
  device_ip = (((*(a + 0) << 24) | (*(a + 1) << 16)) | (*(a + 2) << 8)) | *(a + 3);
#line 206
  tmp = hdhomerun_device_create(4294967295U, device_ip, tuner, dbg);
#line 206
  hd___0 = tmp;
  }
#line 207
  if (! hd___0) {
#line 208
    return ((struct hdhomerun_device_t *)((void *)0));
  }
#line 211
  if (hd___0->multicast_ip != 0U) {
#line 212
    hd___0->multicast_port = (uint16_t )port;
  }
#line 215
  return (hd___0);
}
}
#line 218 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
static struct hdhomerun_device_t *hdhomerun_device_create_from_str_ip___0(char const   *device_str ,
                                                                          struct hdhomerun_debug_t *dbg ) 
{ 
  unsigned int a[4] ;
  unsigned int port ;
  unsigned int tuner ;
  struct hdhomerun_device_t *tmp ;
  int tmp___0 ;
  struct hdhomerun_device_t *tmp___1 ;
  int tmp___2 ;
  struct hdhomerun_device_t *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 221
  port = 0U;
#line 222
  tuner = 0U;
#line 224
  tmp___0 = sscanf((char const   */* __restrict  */)device_str, (char const   */* __restrict  */)"%u.%u.%u.%u:%u",
                   & a[0], & a[1], & a[2], & a[3], & port);
  }
#line 224
  if (tmp___0 == 5) {
    {
#line 225
    tmp = hdhomerun_device_create_from_str_ip_result___0((unsigned int *)(a), port,
                                                         tuner, dbg);
    }
#line 225
    return (tmp);
  }
  {
#line 227
  tmp___2 = sscanf((char const   */* __restrict  */)device_str, (char const   */* __restrict  */)"%u.%u.%u.%u-%u",
                   & a[0], & a[1], & a[2], & a[3], & tuner);
  }
#line 227
  if (tmp___2 == 5) {
    {
#line 228
    tmp___1 = hdhomerun_device_create_from_str_ip_result___0((unsigned int *)(a),
                                                             port, tuner, dbg);
    }
#line 228
    return (tmp___1);
  }
  {
#line 230
  tmp___4 = sscanf((char const   */* __restrict  */)device_str, (char const   */* __restrict  */)"%u.%u.%u.%u",
                   & a[0], & a[1], & a[2], & a[3]);
  }
#line 230
  if (tmp___4 == 4) {
    {
#line 231
    tmp___3 = hdhomerun_device_create_from_str_ip_result___0((unsigned int *)(a),
                                                             port, tuner, dbg);
    }
#line 231
    return (tmp___3);
  }
#line 234
  return ((struct hdhomerun_device_t *)((void *)0));
}
}
#line 237 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
static struct hdhomerun_device_t *hdhomerun_device_create_from_str_dns___0(char const   *device_str ,
                                                                           struct hdhomerun_debug_t *dbg ) 
{ 
  struct addrinfo hints ;
  struct addrinfo *sock_info ;
  int tmp ;
  struct sockaddr_in *sock_addr ;
  uint32_t device_ip ;
  uint32_t tmp___0 ;
  struct hdhomerun_device_t *tmp___1 ;

  {
  {
#line 243
  memset((void *)(& hints), 0, sizeof(hints));
#line 244
  hints.ai_family = 2;
#line 245
  hints.ai_socktype = 1;
#line 246
  hints.ai_protocol = 6;
#line 249
  tmp = getaddrinfo((char const   */* __restrict  */)device_str, (char const   */* __restrict  */)"65001",
                    (struct addrinfo  const  */* __restrict  */)(& hints), (struct addrinfo **/* __restrict  */)(& sock_info));
  }
#line 249
  if (tmp != 0) {
#line 250
    return ((struct hdhomerun_device_t *)((void *)0));
  }
  {
#line 253
  sock_addr = (struct sockaddr_in *)sock_info->ai_addr;
#line 254
  tmp___0 = ntohl(sock_addr->sin_addr.s_addr);
#line 254
  device_ip = tmp___0;
#line 255
  freeaddrinfo(sock_info);
  }
#line 257
  if (device_ip == 0U) {
#line 258
    return ((struct hdhomerun_device_t *)((void *)0));
  }
  {
#line 261
  tmp___1 = hdhomerun_device_create(4294967295U, device_ip, 0U, dbg);
  }
#line 261
  return (tmp___1);
}
}
#line 382 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
static uint32_t hdhomerun_device_get_status_parse___0(char const   *status_str , char const   *tag ) 
{ 
  char const   *ptr ;
  char *tmp ;
  unsigned int value ;
  size_t tmp___0 ;

  {
  {
#line 384
  tmp = strstr(status_str, tag);
#line 384
  ptr = (char const   *)tmp;
  }
#line 385
  if (! ptr) {
#line 386
    return ((uint32_t )0);
  }
  {
#line 389
  value = 0U;
#line 390
  tmp___0 = strlen(tag);
#line 390
  sscanf((char const   */* __restrict  */)(ptr + tmp___0), (char const   */* __restrict  */)"%u",
         & value);
  }
#line 392
  return (value);
}
}
#line 395 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
static bool_t hdhomerun_device_get_tuner_status_lock_is_bcast___0(struct hdhomerun_tuner_status_t *status ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 397
  tmp = strcmp((char const   *)(status->lock_str), "8vsb");
  }
#line 397
  if (tmp == 0) {
#line 398
    return (1);
  }
  {
#line 400
  tmp___0 = strncmp((char const   *)(status->lock_str), "t8", (size_t )2);
  }
#line 400
  if (tmp___0 == 0) {
#line 401
    return (1);
  }
  {
#line 403
  tmp___1 = strncmp((char const   *)(status->lock_str), "t7", (size_t )2);
  }
#line 403
  if (tmp___1 == 0) {
#line 404
    return (1);
  }
  {
#line 406
  tmp___2 = strncmp((char const   *)(status->lock_str), "t6", (size_t )2);
  }
#line 406
  if (tmp___2 == 0) {
#line 407
    return (1);
  }
#line 410
  return (0);
}
}
#line 707 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
static int hdhomerun_device_get_tuner_plotsample_internal___0(struct hdhomerun_device_t *hd___0 ,
                                                              char const   *name ,
                                                              struct hdhomerun_plotsample_t **psamples ,
                                                              size_t *pcount ) 
{ 
  char *result___1 ;
  int ret ;
  int tmp ;
  struct hdhomerun_plotsample_t *samples ;
  size_t count ;
  char *ptr ;
  char *tmp___0 ;
  char *tmp___1 ;
  unsigned int raw ;
  int tmp___2 ;
  uint16_t real ;
  uint16_t imag ;

  {
  {
#line 710
  tmp = hdhomerun_control_get(hd___0->cs, name, & result___1, (char **)((void *)0));
#line 710
  ret = tmp;
  }
#line 711
  if (ret <= 0) {
#line 712
    return (ret);
  }
#line 715
  samples = (struct hdhomerun_plotsample_t *)result___1;
#line 716
  *psamples = samples;
#line 717
  count = (size_t )0;
  {
#line 719
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 720
    tmp___0 = strchr((char const   *)result___1, ' ');
#line 720
    ptr = tmp___0;
    }
#line 721
    if (! ptr) {
#line 722
      goto while_break;
    }
    {
#line 724
    tmp___1 = ptr;
#line 724
    ptr ++;
#line 724
    *tmp___1 = (char)0;
#line 727
    tmp___2 = sscanf((char const   */* __restrict  */)result___1, (char const   */* __restrict  */)"%x",
                     & raw);
    }
#line 727
    if (tmp___2 != 1) {
#line 728
      goto while_break;
    }
#line 731
    real = (uint16_t )((raw >> 12) & 4095U);
#line 732
    if ((int )real & 2048) {
#line 733
      real = (uint16_t )((int )real | 61440);
    }
#line 736
    imag = (uint16_t )(raw & 4095U);
#line 737
    if ((int )imag & 2048) {
#line 738
      imag = (uint16_t )((int )imag | 61440);
    }
#line 741
    samples->real = (int16_t )real;
#line 742
    samples->imag = (int16_t )imag;
#line 743
    samples ++;
#line 744
    count ++;
#line 746
    result___1 = ptr;
  }
  while_break: /* CIL Label */ ;
  }
#line 749
  *pcount = count;
#line 750
  return (1);
}
}
#line 918 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
static bool_t hdhomerun_device_set_tuner_filter_by_array_append___0(char *ptr , char *end ,
                                                                    uint16_t range_begin ,
                                                                    uint16_t range_end ) 
{ 
  bool_t tmp ;
  bool_t tmp___0 ;

  {
#line 920
  if ((int )range_begin == (int )range_end) {
    {
#line 921
    tmp = hdhomerun_sprintf(ptr, end, "0x%04x ", (unsigned int )range_begin);
    }
#line 921
    return (tmp);
  } else {
    {
#line 923
    tmp___0 = hdhomerun_sprintf(ptr, end, "0x%04x-0x%04x ", (unsigned int )range_begin,
                                (unsigned int )range_end);
    }
#line 923
    return (tmp___0);
  }
}
}
#line 1000 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_device.c"
static int hdhomerun_device_set_tuner_target_to_local___0(struct hdhomerun_device_t *hd___0 ,
                                                          char const   *protocol ) 
{ 
  char target[64] ;
  uint32_t local_ip ;
  uint32_t tmp ;
  uint16_t local_port ;
  uint16_t tmp___0 ;
  int tmp___1 ;

  {
#line 1002
  if (! hd___0->cs) {
    {
#line 1003
    hdhomerun_debug_printf(hd___0->dbg, "hdhomerun_device_set_tuner_target_to_local: device not set\n");
    }
#line 1004
    return (-1);
  }
#line 1006
  if (! hd___0->vs) {
    {
#line 1007
    hdhomerun_debug_printf(hd___0->dbg, "hdhomerun_device_set_tuner_target_to_local: video not initialized\n");
    }
#line 1008
    return (-1);
  }
  {
#line 1013
  tmp = hdhomerun_control_get_local_addr(hd___0->cs);
#line 1013
  local_ip = tmp;
#line 1014
  tmp___0 = hdhomerun_video_get_local_port(hd___0->vs);
#line 1014
  local_port = tmp___0;
#line 1015
  hdhomerun_sprintf(target, target + sizeof(target), "%s://%u.%u.%u.%u:%u", protocol,
                    (local_ip >> 24) & 255U, (local_ip >> 16) & 255U, (local_ip >> 8) & 255U,
                    local_ip & 255U, (unsigned int )local_port);
#line 1022
  tmp___1 = hdhomerun_device_set_tuner_target(hd___0, (char const   *)(target));
  }
#line 1022
  return (tmp___1);
}
}
#line 294 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_sock_posix.c"
static bool_t hdhomerun_sock_wait_for_event___0(hdhomerun_sock_t sock , short event_type ,
                                                uint64_t stop_time ) 
{ 
  uint64_t current_time ;
  uint64_t tmp ;
  struct pollfd poll_event ;
  uint64_t timeout ;
  int tmp___0 ;

  {
  {
#line 296
  tmp = getcurrenttime();
#line 296
  current_time = tmp;
  }
#line 297
  if (current_time >= stop_time) {
#line 298
    return (0);
  }
  {
#line 302
  poll_event.fd = sock;
#line 303
  poll_event.events = event_type;
#line 304
  poll_event.revents = (short)0;
#line 306
  timeout = stop_time - current_time;
#line 308
  tmp___0 = poll(& poll_event, (nfds_t )1, (int )timeout);
  }
#line 308
  if (tmp___0 <= 0) {
#line 309
    return (0);
  }
#line 312
  if (((int )poll_event.revents & (int )event_type) == 0) {
#line 313
    return (0);
  }
#line 316
  return (1);
}
}
#line 39 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_control.c"
static void hdhomerun_control_close_sock___0(struct hdhomerun_control_sock_t *cs ) 
{ 


  {
#line 41
  if (cs->sock == -1) {
#line 42
    return;
  }
  {
#line 45
  hdhomerun_sock_destroy(cs->sock);
#line 46
  cs->sock = -1;
  }
#line 47
  return;
}
}
#line 80 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_control.c"
static bool_t hdhomerun_control_connect_sock___0(struct hdhomerun_control_sock_t *cs ) 
{ 
  bool_t tmp ;
  struct hdhomerun_discover_device_t result___1 ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  bool_t tmp___3 ;

  {
#line 82
  if (cs->sock != -1) {
#line 83
    return (1);
  }
#line 86
  if (cs->desired_device_id == 0U) {
#line 86
    if (cs->desired_device_ip == 0U) {
      {
#line 87
      hdhomerun_debug_printf(cs->dbg, "hdhomerun_control_connect_sock: no device specified\n");
      }
#line 88
      return (0);
    }
  }
  {
#line 90
  tmp = hdhomerun_discover_is_ip_multicast(cs->desired_device_ip);
  }
#line 90
  if (tmp) {
    {
#line 91
    hdhomerun_debug_printf(cs->dbg, "hdhomerun_control_connect_sock: cannot use multicast ip address for device operations\n");
    }
#line 92
    return (0);
  }
  {
#line 97
  tmp___0 = hdhomerun_discover_find_devices_custom(cs->desired_device_ip, 4294967295U,
                                                   cs->desired_device_id, & result___1,
                                                   1);
  }
#line 97
  if (tmp___0 <= 0) {
    {
#line 98
    hdhomerun_debug_printf(cs->dbg, "hdhomerun_control_connect_sock: device not found\n");
    }
#line 99
    return (0);
  }
  {
#line 101
  cs->actual_device_ip = result___1.ip_addr;
#line 102
  cs->actual_device_id = result___1.device_id;
#line 105
  cs->sock = hdhomerun_sock_create_tcp();
  }
#line 106
  if (cs->sock == -1) {
    {
#line 107
    tmp___1 = hdhomerun_sock_getlasterror();
#line 107
    hdhomerun_debug_printf(cs->dbg, "hdhomerun_control_connect_sock: failed to create socket (%d)\n",
                           tmp___1);
    }
#line 108
    return (0);
  }
  {
#line 112
  tmp___3 = hdhomerun_sock_connect(cs->sock, cs->actual_device_ip, (uint16_t )65001,
                                   (uint64_t )2500);
  }
#line 112
  if (! tmp___3) {
    {
#line 113
    tmp___2 = hdhomerun_sock_getlasterror();
#line 113
    hdhomerun_debug_printf(cs->dbg, "hdhomerun_control_connect_sock: failed to connect (%d)\n",
                           tmp___2);
#line 114
    hdhomerun_control_close_sock___0(cs);
    }
#line 115
    return (0);
  }
#line 119
  return (1);
}
}
#line 168 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_control.c"
static bool_t hdhomerun_control_send_sock___0(struct hdhomerun_control_sock_t *cs ,
                                              struct hdhomerun_pkt_t *tx_pkt ) 
{ 
  int tmp ;
  bool_t tmp___0 ;

  {
  {
#line 170
  tmp___0 = hdhomerun_sock_send(cs->sock, (void const   *)tx_pkt->start, (size_t )(tx_pkt->end - tx_pkt->start),
                                (uint64_t )2500);
  }
#line 170
  if (! tmp___0) {
    {
#line 171
    tmp = hdhomerun_sock_getlasterror();
#line 171
    hdhomerun_debug_printf(cs->dbg, "hdhomerun_control_send_sock: send failed (%d)\n",
                           tmp);
#line 172
    hdhomerun_control_close_sock___0(cs);
    }
#line 173
    return (0);
  }
#line 176
  return (1);
}
}
#line 179 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_control.c"
static bool_t hdhomerun_control_recv_sock___0(struct hdhomerun_control_sock_t *cs ,
                                              struct hdhomerun_pkt_t *rx_pkt , uint16_t *ptype ,
                                              uint64_t recv_timeout ) 
{ 
  uint64_t stop_time ;
  uint64_t tmp ;
  uint64_t current_time ;
  uint64_t tmp___0 ;
  size_t length ;
  int tmp___1 ;
  bool_t tmp___2 ;
  int ret ;
  bool_t tmp___3 ;

  {
  {
#line 181
  tmp = getcurrenttime();
#line 181
  stop_time = tmp + recv_timeout;
#line 182
  hdhomerun_pkt_reset(rx_pkt);
  }
  {
#line 184
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 185
    tmp___0 = getcurrenttime();
#line 185
    current_time = tmp___0;
    }
#line 186
    if (current_time >= stop_time) {
      {
#line 187
      hdhomerun_debug_printf(cs->dbg, "hdhomerun_control_recv_sock: timeout\n");
#line 188
      hdhomerun_control_close_sock___0(cs);
      }
#line 189
      return (0);
    }
    {
#line 192
    length = (size_t )(rx_pkt->limit - rx_pkt->end);
#line 193
    tmp___2 = hdhomerun_sock_recv(cs->sock, (void *)rx_pkt->end, & length, stop_time - current_time);
    }
#line 193
    if (! tmp___2) {
      {
#line 194
      tmp___1 = hdhomerun_sock_getlasterror();
#line 194
      hdhomerun_debug_printf(cs->dbg, "hdhomerun_control_recv_sock: recv failed (%d)\n",
                             tmp___1);
#line 195
      hdhomerun_control_close_sock___0(cs);
      }
#line 196
      return (0);
    }
    {
#line 199
    rx_pkt->end += length;
#line 201
    tmp___3 = hdhomerun_pkt_open_frame(rx_pkt, ptype);
#line 201
    ret = tmp___3;
    }
#line 202
    if (ret < 0) {
      {
#line 203
      hdhomerun_debug_printf(cs->dbg, "hdhomerun_control_recv_sock: frame error\n");
#line 204
      hdhomerun_control_close_sock___0(cs);
      }
#line 205
      return (0);
    }
#line 207
    if (ret > 0) {
#line 208
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 213 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_control.c"
static int hdhomerun_control_send_recv_internal___0(struct hdhomerun_control_sock_t *cs ,
                                                    struct hdhomerun_pkt_t *tx_pkt ,
                                                    struct hdhomerun_pkt_t *rx_pkt ,
                                                    uint16_t type , uint64_t recv_timeout ) 
{ 
  int i ;
  bool_t tmp ;
  bool_t tmp___0 ;
  uint16_t rsp_type ;
  bool_t tmp___1 ;

  {
  {
#line 215
  hdhomerun_pkt_seal_frame(tx_pkt, type);
#line 218
  i = 0;
  }
  {
#line 218
  while (1) {
    while_continue: /* CIL Label */ ;
#line 218
    if (! (i < 2)) {
#line 218
      goto while_break;
    }
#line 219
    if (cs->sock == -1) {
      {
#line 220
      tmp = hdhomerun_control_connect_sock___0(cs);
      }
#line 220
      if (! tmp) {
        {
#line 221
        hdhomerun_debug_printf(cs->dbg, "hdhomerun_control_send_recv: connect failed\n");
        }
#line 222
        return (-1);
      }
    }
    {
#line 226
    tmp___0 = hdhomerun_control_send_sock___0(cs, tx_pkt);
    }
#line 226
    if (! tmp___0) {
#line 227
      goto __Cont;
    }
#line 229
    if (! rx_pkt) {
#line 230
      return (1);
    }
    {
#line 234
    tmp___1 = hdhomerun_control_recv_sock___0(cs, rx_pkt, & rsp_type, recv_timeout);
    }
#line 234
    if (! tmp___1) {
#line 235
      goto __Cont;
    }
#line 237
    if ((int )rsp_type != (int )type + 1) {
      {
#line 238
      hdhomerun_debug_printf(cs->dbg, "hdhomerun_control_send_recv: unexpected frame type\n");
#line 239
      hdhomerun_control_close_sock___0(cs);
      }
#line 240
      goto __Cont;
    }
#line 243
    return (1);
    __Cont: /* CIL Label */ 
#line 218
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 246
  hdhomerun_debug_printf(cs->dbg, "hdhomerun_control_send_recv: failed\n");
  }
#line 247
  return (-1);
}
}
#line 255 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_control.c"
static int hdhomerun_control_get_set___0(struct hdhomerun_control_sock_t *cs , char const   *name ,
                                         char const   *value , uint32_t lockkey ,
                                         char **pvalue , char **perror___0 ) 
{ 
  struct hdhomerun_pkt_t *tx_pkt ;
  struct hdhomerun_pkt_t *rx_pkt ;
  int name_len ;
  size_t tmp ;
  int value_len ;
  size_t tmp___0 ;
  int tmp___1 ;
  uint8_t tag ;
  size_t len ;
  uint8_t *next ;
  uint8_t *tmp___2 ;

  {
  {
#line 257
  tx_pkt = & cs->tx_pkt;
#line 258
  rx_pkt = & cs->rx_pkt;
#line 261
  hdhomerun_pkt_reset(tx_pkt);
#line 263
  tmp = strlen(name);
#line 263
  name_len = (int )tmp + 1;
  }
#line 264
  if ((unsigned long )((tx_pkt->end + 3) + name_len) > (unsigned long )tx_pkt->limit) {
    {
#line 265
    hdhomerun_debug_printf(cs->dbg, "hdhomerun_control_get_set: request too long\n");
    }
#line 266
    return (-1);
  }
  {
#line 268
  hdhomerun_pkt_write_u8(tx_pkt, (uint8_t )3);
#line 269
  hdhomerun_pkt_write_var_length(tx_pkt, (size_t )name_len);
#line 270
  hdhomerun_pkt_write_mem(tx_pkt, (void const   *)name, (size_t )name_len);
  }
#line 272
  if (value) {
    {
#line 273
    tmp___0 = strlen(value);
#line 273
    value_len = (int )tmp___0 + 1;
    }
#line 274
    if ((unsigned long )((tx_pkt->end + 3) + value_len) > (unsigned long )tx_pkt->limit) {
      {
#line 275
      hdhomerun_debug_printf(cs->dbg, "hdhomerun_control_get_set: request too long\n");
      }
#line 276
      return (-1);
    }
    {
#line 278
    hdhomerun_pkt_write_u8(tx_pkt, (uint8_t )4);
#line 279
    hdhomerun_pkt_write_var_length(tx_pkt, (size_t )value_len);
#line 280
    hdhomerun_pkt_write_mem(tx_pkt, (void const   *)value, (size_t )value_len);
    }
  }
#line 283
  if (lockkey != 0U) {
#line 284
    if ((unsigned long )(tx_pkt->end + 6) > (unsigned long )tx_pkt->limit) {
      {
#line 285
      hdhomerun_debug_printf(cs->dbg, "hdhomerun_control_get_set: request too long\n");
      }
#line 286
      return (-1);
    }
    {
#line 288
    hdhomerun_pkt_write_u8(tx_pkt, (uint8_t )21);
#line 289
    hdhomerun_pkt_write_var_length(tx_pkt, (size_t )4);
#line 290
    hdhomerun_pkt_write_u32(tx_pkt, lockkey);
    }
  }
  {
#line 294
  tmp___1 = hdhomerun_control_send_recv_internal___0(cs, tx_pkt, rx_pkt, (uint16_t )4,
                                                     (uint64_t )2500);
  }
#line 294
  if (tmp___1 < 0) {
    {
#line 295
    hdhomerun_debug_printf(cs->dbg, "hdhomerun_control_get_set: send/recv error\n");
    }
#line 296
    return (-1);
  }
  {
#line 300
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 303
    tmp___2 = hdhomerun_pkt_read_tlv(rx_pkt, & tag, & len);
#line 303
    next = tmp___2;
    }
#line 304
    if (! next) {
#line 305
      goto while_break;
    }
    {
#line 309
    if ((int )tag == 4) {
#line 309
      goto case_4;
    }
#line 319
    if ((int )tag == 5) {
#line 319
      goto case_5;
    }
#line 308
    goto switch_break;
    case_4: /* CIL Label */ 
#line 310
    if (pvalue) {
#line 311
      *pvalue = (char *)rx_pkt->pos;
#line 312
      *(rx_pkt->pos + len) = (uint8_t )0;
    }
#line 314
    if (perror___0) {
#line 315
      *perror___0 = (char *)((void *)0);
    }
#line 317
    return (1);
    case_5: /* CIL Label */ 
    {
#line 320
    *(rx_pkt->pos + len) = (uint8_t )0;
#line 321
    hdhomerun_debug_printf(cs->dbg, "hdhomerun_control_get_set: %s\n", rx_pkt->pos);
    }
#line 323
    if (pvalue) {
#line 324
      *pvalue = (char *)((void *)0);
    }
#line 326
    if (perror___0) {
#line 327
      *perror___0 = (char *)rx_pkt->pos;
    }
#line 330
    return (0);
    switch_break: /* CIL Label */ ;
    }
#line 333
    rx_pkt->pos = next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 336
  hdhomerun_debug_printf(cs->dbg, "hdhomerun_control_get_set: missing response tags\n");
  }
#line 337
  return (-1);
}
}
#line 55 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_channelscan.c"
static int channelscan_find_lock___0(struct hdhomerun_channelscan_t *scan , uint32_t frequency ,
                                     struct hdhomerun_channelscan_result_t *result___1 ) 
{ 
  char channel_str[64] ;
  int ret ;
  int tmp ;
  uint64_t timeout ;
  uint64_t tmp___0 ;
  uint64_t tmp___1 ;

  {
  {
#line 59
  hdhomerun_sprintf(channel_str, channel_str + sizeof(channel_str), "auto:%u", frequency);
#line 61
  tmp = hdhomerun_device_set_tuner_channel(scan->hd, (char const   *)(channel_str));
#line 61
  ret = tmp;
  }
#line 62
  if (ret <= 0) {
#line 63
    return (ret);
  }
  {
#line 67
  ret = hdhomerun_device_wait_for_lock(scan->hd, & result___1->status);
  }
#line 68
  if (ret <= 0) {
#line 69
    return (ret);
  }
#line 71
  if (! result___1->status.lock_supported) {
#line 72
    return (1);
  }
  {
#line 76
  tmp___0 = getcurrenttime();
#line 76
  timeout = tmp___0 + 5000UL;
  }
  {
#line 77
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 78
    ret = hdhomerun_device_get_tuner_status(scan->hd, (char **)((void *)0), & result___1->status);
    }
#line 79
    if (ret <= 0) {
#line 80
      return (ret);
    }
#line 83
    if (result___1->status.symbol_error_quality == 100U) {
#line 84
      return (1);
    }
    {
#line 87
    tmp___1 = getcurrenttime();
    }
#line 87
    if (tmp___1 >= timeout) {
#line 88
      return (1);
    }
    {
#line 91
    msleep_approx((uint64_t )250);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_channelscan.c"
static void channelscan_extract_name___0(struct hdhomerun_channelscan_program_t *program ,
                                         char const   *line ) 
{ 
  char const   *start ;
  char *tmp ;
  char *tmp___0 ;
  char const   *end ;
  char *tmp___1 ;
  char *tmp___2 ;
  size_t length ;

  {
  {
#line 98
  tmp = strchr(line, ' ');
#line 98
  start = (char const   *)tmp;
  }
#line 99
  if (! start) {
#line 100
    return;
  }
  {
#line 102
  start ++;
#line 104
  tmp___0 = strchr(start, ' ');
#line 104
  start = (char const   *)tmp___0;
  }
#line 105
  if (! start) {
#line 106
    return;
  }
  {
#line 108
  start ++;
#line 111
  tmp___1 = strstr(start, " (");
#line 111
  end = (char const   *)tmp___1;
  }
#line 112
  if (! end) {
    {
#line 113
    tmp___2 = strchr(line, 0);
#line 113
    end = (char const   *)tmp___2;
    }
  }
#line 116
  if ((unsigned long )end <= (unsigned long )start) {
#line 117
    return;
  }
#line 121
  length = (size_t )(end - start);
#line 122
  if (length > sizeof(program->name) - 1UL) {
#line 123
    length = sizeof(program->name) - 1UL;
  }
  {
#line 126
  strncpy((char */* __restrict  */)(program->name), (char const   */* __restrict  */)start,
          length);
#line 127
  program->name[length] = (char)0;
  }
#line 128
  return;
}
}
#line 130 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_channelscan.c"
static int channelscan_detect_programs___0(struct hdhomerun_channelscan_t *scan ,
                                           struct hdhomerun_channelscan_result_t *result___1 ,
                                           bool_t *pchanged , bool_t *pincomplete ) 
{ 
  char *streaminfo ;
  int ret ;
  int tmp ;
  char *next_line ;
  int program_count ;
  char *line ;
  char *tmp___0 ;
  unsigned int transport_stream_id ;
  int tmp___1 ;
  struct hdhomerun_channelscan_program_t program ;
  unsigned int program_number ;
  unsigned int virtual_major ;
  unsigned int virtual_minor ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;

  {
  {
#line 132
  *pchanged = 0;
#line 133
  *pincomplete = 0;
#line 136
  tmp = hdhomerun_device_get_tuner_streaminfo(scan->hd, & streaminfo);
#line 136
  ret = tmp;
  }
#line 137
  if (ret <= 0) {
#line 138
    return (ret);
  }
#line 141
  next_line = streaminfo;
#line 142
  program_count = 0;
  {
#line 144
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 145
    line = next_line;
#line 147
    next_line = strchr((char const   *)line, '\n');
    }
#line 148
    if (! next_line) {
#line 149
      goto while_break;
    }
    {
#line 151
    tmp___0 = next_line;
#line 151
    next_line ++;
#line 151
    *tmp___0 = (char)0;
#line 154
    tmp___1 = sscanf((char const   */* __restrict  */)line, (char const   */* __restrict  */)"tsid=0x%x",
                     & transport_stream_id);
    }
#line 154
    if (tmp___1 == 1) {
#line 155
      result___1->transport_stream_id = (uint16_t )transport_stream_id;
#line 156
      result___1->transport_stream_id_detected = 1;
#line 157
      goto while_continue;
    }
#line 160
    if (program_count >= 64) {
#line 161
      goto while_continue;
    }
    {
#line 165
    memset((void *)(& program), 0, sizeof(program));
#line 167
    hdhomerun_sprintf(program.program_str, program.program_str + sizeof(program.program_str),
                      "%s", line);
#line 171
    tmp___3 = sscanf((char const   */* __restrict  */)line, (char const   */* __restrict  */)"%u: %u.%u",
                     & program_number, & virtual_major, & virtual_minor);
    }
#line 171
    if (tmp___3 != 3) {
      {
#line 172
      tmp___2 = sscanf((char const   */* __restrict  */)line, (char const   */* __restrict  */)"%u: %u",
                       & program_number, & virtual_major);
      }
#line 172
      if (tmp___2 != 2) {
#line 173
        goto while_continue;
      }
#line 175
      virtual_minor = 0U;
    }
    {
#line 178
    program.program_number = (uint16_t )program_number;
#line 179
    program.virtual_major = (uint16_t )virtual_major;
#line 180
    program.virtual_minor = (uint16_t )virtual_minor;
#line 182
    channelscan_extract_name___0(& program, (char const   *)line);
#line 184
    tmp___6 = strstr((char const   *)line, "(control)");
    }
#line 184
    if (tmp___6) {
#line 185
      program.type = (uint16_t )2;
    } else {
      {
#line 186
      tmp___5 = strstr((char const   *)line, "(encrypted)");
      }
#line 186
      if (tmp___5) {
#line 187
        program.type = (uint16_t )3;
      } else {
        {
#line 188
        tmp___4 = strstr((char const   *)line, "(no data)");
        }
#line 188
        if (tmp___4) {
#line 189
          program.type = (uint16_t )1;
#line 190
          *pincomplete = 1;
        } else {
#line 192
          program.type = (uint16_t )0;
#line 193
          if ((int )program.virtual_major == 0) {
#line 194
            *pincomplete = 1;
          } else
#line 193
          if ((int )program.name[0] == 0) {
#line 194
            *pincomplete = 1;
          }
        }
      }
    }
    {
#line 198
    tmp___7 = memcmp((void const   *)(& result___1->programs[program_count]), (void const   *)(& program),
                     sizeof(program));
    }
#line 198
    if (tmp___7 != 0) {
      {
#line 199
      memcpy((void */* __restrict  */)(& result___1->programs[program_count]), (void const   */* __restrict  */)(& program),
             sizeof(program));
#line 200
      *pchanged = 1;
      }
    }
#line 203
    program_count ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 206
  if (program_count == 0) {
#line 207
    *pincomplete = 1;
  }
#line 209
  if (result___1->program_count != program_count) {
#line 210
    result___1->program_count = program_count;
#line 211
    *pchanged = 1;
  }
#line 214
  return (1);
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_channels.c"
static struct hdhomerun_channelmap_range_t  const  hdhomerun_channelmap_range_au_bcast___0[3]  = {      {(uint16_t )5,
      (uint16_t )12, (uint32_t )177500000, (uint32_t )7000000}, 
        {(uint16_t )21, (uint16_t )69, (uint32_t )480500000, (uint32_t )7000000}, 
        {(uint16_t )0, (uint16_t )0, (uint32_t )0, (uint32_t )0}};
#line 58 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_channels.c"
static struct hdhomerun_channelmap_range_t  const  hdhomerun_channelmap_range_eu_bcast___0[3]  = {      {(uint16_t )5,
      (uint16_t )12, (uint32_t )177500000, (uint32_t )7000000}, 
        {(uint16_t )21, (uint16_t )69, (uint32_t )474000000, (uint32_t )8000000}, 
        {(uint16_t )0, (uint16_t )0, (uint32_t )0, (uint32_t )0}};
#line 65 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_channels.c"
static struct hdhomerun_channelmap_range_t  const  hdhomerun_channelmap_range_eu_cable___0[2]  = {      {(uint16_t )108,
      (uint16_t )862, (uint32_t )108000000, (uint32_t )1000000}, 
        {(uint16_t )0, (uint16_t )0, (uint32_t )0, (uint32_t )0}};
#line 71 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_channels.c"
static struct hdhomerun_channelmap_range_t  const  hdhomerun_channelmap_range_kr_cable___0[6]  = {      {(uint16_t )2,
      (uint16_t )4, (uint32_t )57000000, (uint32_t )6000000}, 
        {(uint16_t )5, (uint16_t )6, (uint32_t )79000000, (uint32_t )6000000}, 
        {(uint16_t )7, (uint16_t )13, (uint32_t )177000000, (uint32_t )6000000}, 
        {(uint16_t )14, (uint16_t )22, (uint32_t )123000000, (uint32_t )6000000}, 
        {(uint16_t )23, (uint16_t )153, (uint32_t )219000000, (uint32_t )6000000}, 
        {(uint16_t )0, (uint16_t )0, (uint32_t )0, (uint32_t )0}};
#line 81 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_channels.c"
static struct hdhomerun_channelmap_range_t  const  hdhomerun_channelmap_range_us_bcast___0[5]  = {      {(uint16_t )2,
      (uint16_t )4, (uint32_t )57000000, (uint32_t )6000000}, 
        {(uint16_t )5, (uint16_t )6, (uint32_t )79000000, (uint32_t )6000000}, 
        {(uint16_t )7, (uint16_t )13, (uint32_t )177000000, (uint32_t )6000000}, 
        {(uint16_t )14, (uint16_t )69, (uint32_t )473000000, (uint32_t )6000000}, 
        {(uint16_t )0, (uint16_t )0, (uint32_t )0, (uint32_t )0}};
#line 90 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_channels.c"
static struct hdhomerun_channelmap_range_t  const  hdhomerun_channelmap_range_us_cable___0[8]  = 
#line 90
  {      {(uint16_t )2, (uint16_t )4, (uint32_t )57000000, (uint32_t )6000000}, 
        {(uint16_t )5, (uint16_t )6, (uint32_t )79000000, (uint32_t )6000000}, 
        {(uint16_t )7, (uint16_t )13, (uint32_t )177000000, (uint32_t )6000000}, 
        {(uint16_t )14, (uint16_t )22, (uint32_t )123000000, (uint32_t )6000000}, 
        {(uint16_t )23, (uint16_t )94, (uint32_t )219000000, (uint32_t )6000000}, 
        {(uint16_t )95, (uint16_t )99, (uint32_t )93000000, (uint32_t )6000000}, 
        {(uint16_t )100, (uint16_t )158, (uint32_t )651000000, (uint32_t )6000000}, 
        {(uint16_t )0, (uint16_t )0, (uint32_t )0, (uint32_t )0}};
#line 102 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_channels.c"
static struct hdhomerun_channelmap_range_t  const  hdhomerun_channelmap_range_us_hrc___0[8]  = 
#line 102
  {      {(uint16_t )2, (uint16_t )4, (uint32_t )55752700, (uint32_t )6000300}, 
        {(uint16_t )5, (uint16_t )6, (uint32_t )79753900, (uint32_t )6000300}, 
        {(uint16_t )7, (uint16_t )13, (uint32_t )175758700, (uint32_t )6000300}, 
        {(uint16_t )14, (uint16_t )22, (uint32_t )121756000, (uint32_t )6000300}, 
        {(uint16_t )23, (uint16_t )94, (uint32_t )217760800, (uint32_t )6000300}, 
        {(uint16_t )95, (uint16_t )99, (uint32_t )91754500, (uint32_t )6000300}, 
        {(uint16_t )100, (uint16_t )158, (uint32_t )649782400, (uint32_t )6000300}, 
        {(uint16_t )0, (uint16_t )0, (uint32_t )0, (uint32_t )0}};
#line 114 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_channels.c"
static struct hdhomerun_channelmap_range_t  const  hdhomerun_channelmap_range_us_irc___0[11]  = 
#line 114
  {      {(uint16_t )2, (uint16_t )4, (uint32_t )57012500, (uint32_t )6000000}, 
        {(uint16_t )5, (uint16_t )6, (uint32_t )81012500, (uint32_t )6000000}, 
        {(uint16_t )7, (uint16_t )13, (uint32_t )177012500, (uint32_t )6000000}, 
        {(uint16_t )14, (uint16_t )22, (uint32_t )123012500, (uint32_t )6000000}, 
        {(uint16_t )23, (uint16_t )41, (uint32_t )219012500, (uint32_t )6000000}, 
        {(uint16_t )42, (uint16_t )42, (uint32_t )333025000, (uint32_t )6000000}, 
        {(uint16_t )43, (uint16_t )94, (uint32_t )339012500, (uint32_t )6000000}, 
        {(uint16_t )95, (uint16_t )97, (uint32_t )93012500, (uint32_t )6000000}, 
        {(uint16_t )98, (uint16_t )99, (uint32_t )111025000, (uint32_t )6000000}, 
        {(uint16_t )100, (uint16_t )158, (uint32_t )651012500, (uint32_t )6000000}, 
        {(uint16_t )0, (uint16_t )0, (uint32_t )0, (uint32_t )0}};
#line 128 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_channels.c"
static struct hdhomerun_channelmap_record_t  const  hdhomerun_channelmap_table___0[13]  = 
#line 128
  {      {"au-bcast", hdhomerun_channelmap_range_au_bcast___0, "au-bcast", "AU"}, 
        {"au-cable", hdhomerun_channelmap_range_eu_cable___0, "au-cable", "AU"}, 
        {"eu-bcast", hdhomerun_channelmap_range_eu_bcast___0, "eu-bcast", (char const   *)((void *)0)}, 
        {"eu-cable",
      hdhomerun_channelmap_range_eu_cable___0, "eu-cable", (char const   *)((void *)0)}, 
        {"tw-bcast",
      hdhomerun_channelmap_range_us_bcast___0, "tw-bcast", "TW"}, 
        {"tw-cable", hdhomerun_channelmap_range_us_cable___0, "tw-cable", "TW"}, 
        {"kr-bcast", hdhomerun_channelmap_range_us_bcast___0, "kr-bcast", "KR"}, 
        {"kr-cable", hdhomerun_channelmap_range_kr_cable___0, "kr-cable", "KR"}, 
        {"us-bcast", hdhomerun_channelmap_range_us_bcast___0, "us-bcast", (char const   *)((void *)0)}, 
        {"us-cable",
      hdhomerun_channelmap_range_us_cable___0, "us-cable us-hrc us-irc", (char const   *)((void *)0)}, 
        {"us-hrc",
      hdhomerun_channelmap_range_us_hrc___0, "us-cable us-hrc us-irc", (char const   *)((void *)0)}, 
        {"us-irc",
      hdhomerun_channelmap_range_us_irc___0, "us-cable us-hrc us-irc", (char const   *)((void *)0)}, 
        {(char const   *)((void *)0),
      (struct hdhomerun_channelmap_range_t  const  *)((void *)0), (char const   *)((void *)0),
      (char const   *)((void *)0)}};
#line 307 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_channels.c"
static void hdhomerun_channel_list_build_insert___0(struct hdhomerun_channel_list_t *channel_list ,
                                                    struct hdhomerun_channel_entry_t *entry ) 
{ 
  struct hdhomerun_channel_entry_t *prev ;
  struct hdhomerun_channel_entry_t *next ;

  {
#line 309
  prev = (struct hdhomerun_channel_entry_t *)((void *)0);
#line 310
  next = channel_list->head;
  {
#line 312
  while (1) {
    while_continue: /* CIL Label */ ;
#line 312
    if (! next) {
#line 312
      goto while_break;
    }
#line 313
    if (next->frequency > entry->frequency) {
#line 314
      goto while_break;
    }
#line 317
    prev = next;
#line 318
    next = next->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 321
  entry->prev = prev;
#line 322
  entry->next = next;
#line 324
  if (prev) {
#line 325
    prev->next = entry;
  } else {
#line 327
    channel_list->head = entry;
  }
#line 330
  if (next) {
#line 331
    next->prev = entry;
  } else {
#line 333
    channel_list->tail = entry;
  }
#line 335
  return;
}
}
#line 337 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_channels.c"
static void hdhomerun_channel_list_build_range___0(struct hdhomerun_channel_list_t *channel_list ,
                                                   char const   *channelmap , struct hdhomerun_channelmap_range_t  const  *range ) 
{ 
  uint16_t channel_number ;
  struct hdhomerun_channel_entry_t *entry ;
  void *tmp ;

  {
#line 340
  channel_number = (uint16_t )range->channel_range_start;
  {
#line 340
  while (1) {
    while_continue: /* CIL Label */ ;
#line 340
    if (! ((int )channel_number <= (int )range->channel_range_end)) {
#line 340
      goto while_break;
    }
    {
#line 341
    tmp = calloc((size_t )1, sizeof(struct hdhomerun_channel_entry_t ));
#line 341
    entry = (struct hdhomerun_channel_entry_t *)tmp;
    }
#line 342
    if (! entry) {
#line 343
      return;
    }
    {
#line 346
    entry->channel_number = channel_number;
#line 347
    entry->frequency = (uint32_t )(range->frequency + (uint32_t const   )((uint32_t )((int )channel_number - (int )range->channel_range_start) * (uint32_t )range->spacing));
#line 348
    entry->frequency = hdhomerun_channel_frequency_round_normal(entry->frequency);
#line 349
    hdhomerun_sprintf(entry->name, entry->name + sizeof(entry->name), "%s:%u", channelmap,
                      (int )entry->channel_number);
#line 351
    hdhomerun_channel_list_build_insert___0(channel_list, entry);
#line 340
    channel_number = (uint16_t )((int )channel_number + 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 353
  return;
}
}
#line 355 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_channels.c"
static void hdhomerun_channel_list_build_ranges___0(struct hdhomerun_channel_list_t *channel_list ,
                                                    struct hdhomerun_channelmap_record_t  const  *record ) 
{ 
  struct hdhomerun_channelmap_range_t  const  *range ;

  {
#line 357
  range = (struct hdhomerun_channelmap_range_t  const  *)record->range_list;
  {
#line 358
  while (1) {
    while_continue: /* CIL Label */ ;
#line 358
    if (! range->frequency) {
#line 358
      goto while_break;
    }
    {
#line 359
    hdhomerun_channel_list_build_range___0(channel_list, (char const   *)record->channelmap,
                                           range);
#line 360
    range ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 362
  return;
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_debug.c"
static void *hdhomerun_debug_thread_execute___0(void *arg ) ;
#line 120 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_debug.c"
static void hdhomerun_debug_close_internal___0(struct hdhomerun_debug_t *dbg ) 
{ 


  {
#line 122
  if (dbg->file_fp) {
    {
#line 123
    fclose(dbg->file_fp);
#line 124
    dbg->file_fp = (FILE *)((void *)0);
    }
  }
#line 127
  if (dbg->sock != -1) {
    {
#line 128
    hdhomerun_sock_destroy(dbg->sock);
#line 129
    dbg->sock = -1;
    }
  }
#line 131
  return;
}
}
#line 329 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_debug.c"
static bool_t hdhomerun_debug_output_message_file___0(struct hdhomerun_debug_t *dbg ,
                                                      struct hdhomerun_debug_message_t *message ) 
{ 
  uint64_t current_time ;
  uint64_t tmp ;

  {
#line 331
  if (! dbg->file_fp) {
    {
#line 332
    tmp = getcurrenttime();
#line 332
    current_time = tmp;
    }
#line 333
    if (current_time < dbg->connect_delay) {
#line 334
      return (0);
    }
    {
#line 336
    dbg->connect_delay = current_time + 30000UL;
#line 338
    dbg->file_fp = fopen((char const   */* __restrict  */)dbg->file_name, (char const   */* __restrict  */)"a");
    }
#line 339
    if (! dbg->file_fp) {
#line 340
      return (0);
    }
  }
  {
#line 344
  fprintf((FILE */* __restrict  */)dbg->file_fp, (char const   */* __restrict  */)"%s",
          message->buffer);
#line 345
  fflush(dbg->file_fp);
  }
#line 347
  return (1);
}
}
#line 351 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_debug.c"
static bool_t hdhomerun_debug_output_message_sock___0(struct hdhomerun_debug_t *dbg ,
                                                      struct hdhomerun_debug_message_t *message ) 
{ 
  uint64_t current_time ;
  uint64_t tmp ;
  uint32_t remote_addr ;
  uint32_t tmp___0 ;
  bool_t tmp___1 ;
  size_t length ;
  size_t tmp___2 ;
  bool_t tmp___3 ;

  {
#line 353
  if (dbg->sock == -1) {
    {
#line 354
    tmp = getcurrenttime();
#line 354
    current_time = tmp;
    }
#line 355
    if (current_time < dbg->connect_delay) {
#line 356
      return (0);
    }
    {
#line 358
    dbg->connect_delay = current_time + 30000UL;
#line 360
    dbg->sock = hdhomerun_sock_create_tcp();
    }
#line 361
    if (dbg->sock == -1) {
#line 362
      return (0);
    }
    {
#line 365
    tmp___0 = hdhomerun_sock_getaddrinfo_addr(dbg->sock, "debug.silicondust.com");
#line 365
    remote_addr = tmp___0;
    }
#line 366
    if (remote_addr == 0U) {
      {
#line 367
      hdhomerun_debug_close_internal___0(dbg);
      }
#line 368
      return (0);
    }
    {
#line 371
    tmp___1 = hdhomerun_sock_connect(dbg->sock, remote_addr, (uint16_t )8002, (uint64_t )10000);
    }
#line 371
    if (! tmp___1) {
      {
#line 372
      hdhomerun_debug_close_internal___0(dbg);
      }
#line 373
      return (0);
    }
  }
  {
#line 377
  tmp___2 = strlen((char const   *)(message->buffer));
#line 377
  length = tmp___2;
#line 378
  tmp___3 = hdhomerun_sock_send(dbg->sock, (void const   *)(message->buffer), length,
                                (uint64_t )10000);
  }
#line 378
  if (! tmp___3) {
    {
#line 379
    hdhomerun_debug_close_internal___0(dbg);
    }
#line 380
    return (0);
  }
#line 383
  return (1);
}
}
#line 386 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_debug.c"
static bool_t hdhomerun_debug_output_message___0(struct hdhomerun_debug_t *dbg , struct hdhomerun_debug_message_t *message ) 
{ 
  bool_t ret ;

  {
  {
#line 388
  pthread_mutex_lock(& dbg->send_lock);
  }
#line 391
  if (dbg->file_name) {
    {
#line 392
    ret = hdhomerun_debug_output_message_file___0(dbg, message);
    }
  } else {
    {
#line 394
    ret = hdhomerun_debug_output_message_sock___0(dbg, message);
    }
  }
  {
#line 397
  pthread_mutex_unlock(& dbg->send_lock);
  }
#line 398
  return (ret);
}
}
#line 401 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_debug.c"
static void hdhomerun_debug_pop_and_free_message___0(struct hdhomerun_debug_t *dbg ) 
{ 
  struct hdhomerun_debug_message_t *message ;

  {
  {
#line 403
  pthread_mutex_lock(& dbg->queue_lock);
#line 405
  message = dbg->queue_tail;
#line 406
  dbg->queue_tail = message->prev;
  }
#line 407
  if (message->prev) {
#line 408
    (message->prev)->next = (struct hdhomerun_debug_message_t *)((void *)0);
  } else {
#line 410
    dbg->queue_head = (struct hdhomerun_debug_message_t *)((void *)0);
  }
  {
#line 412
  (dbg->queue_depth) --;
#line 414
  pthread_mutex_unlock(& dbg->queue_lock);
#line 416
  free((void *)message);
  }
#line 417
  return;
}
}
#line 419 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_debug.c"
static void *hdhomerun_debug_thread_execute___0(void *arg ) 
{ 
  struct hdhomerun_debug_t *dbg ;
  struct hdhomerun_debug_message_t *message ;
  uint32_t queue_depth ;
  bool_t tmp ;

  {
#line 421
  dbg = (struct hdhomerun_debug_t *)arg;
  {
#line 423
  while (1) {
    while_continue: /* CIL Label */ ;
#line 423
    if (! (! dbg->terminate)) {
#line 423
      goto while_break;
    }
    {
#line 425
    pthread_mutex_lock(& dbg->queue_lock);
#line 426
    message = dbg->queue_tail;
#line 427
    queue_depth = dbg->queue_depth;
#line 428
    pthread_mutex_unlock(& dbg->queue_lock);
    }
#line 430
    if (! message) {
      {
#line 431
      msleep_approx((uint64_t )250);
      }
#line 432
      goto while_continue;
    }
#line 435
    if (queue_depth > 1024U) {
      {
#line 436
      hdhomerun_debug_pop_and_free_message___0(dbg);
      }
#line 437
      goto while_continue;
    }
    {
#line 440
    tmp = hdhomerun_debug_output_message___0(dbg, message);
    }
#line 440
    if (! tmp) {
      {
#line 441
      msleep_approx((uint64_t )250);
      }
#line 442
      goto while_continue;
    }
    {
#line 445
    hdhomerun_debug_pop_and_free_message___0(dbg);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 448
  return ((void *)0);
}
}
#line 47 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_video.c"
static void *hdhomerun_video_thread_execute___0(void *arg ) ;
#line 161 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_video.c"
static void hdhomerun_video_stats_ts_pkt___0(struct hdhomerun_video_sock_t *vs , uint8_t *ptr ) 
{ 
  uint16_t packet_identifier ;
  bool_t transport_error ;
  uint8_t sequence ;
  uint8_t previous_sequence ;

  {
#line 163
  packet_identifier = (uint16_t )(((int )((uint16_t )((int )*(ptr + 1) & 31)) << 8) | (int )((uint16_t )*(ptr + 2)));
#line 164
  if ((int )packet_identifier == 8191) {
#line 165
    return;
  }
#line 168
  transport_error = (int )*(ptr + 1) >> 7;
#line 169
  if (transport_error) {
#line 170
    vs->transport_error_count += (uint32_t volatile   )1;
#line 171
    vs->sequence[packet_identifier] = (uint8_t volatile   )255;
#line 172
    return;
  }
#line 175
  sequence = (uint8_t )((int )*(ptr + 3) & 15);
#line 177
  previous_sequence = (uint8_t )vs->sequence[packet_identifier];
#line 178
  vs->sequence[packet_identifier] = (uint8_t volatile   )sequence;
#line 180
  if ((int )previous_sequence == 255) {
#line 181
    return;
  }
#line 183
  if ((int )sequence == (((int )previous_sequence + 1) & 15)) {
#line 184
    return;
  }
#line 186
  if ((int )sequence == (int )previous_sequence) {
#line 187
    return;
  }
#line 190
  vs->sequence_error_count += (uint32_t volatile   )1;
#line 191
  return;
}
}
#line 193 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_video.c"
static void hdhomerun_video_parse_rtp___0(struct hdhomerun_video_sock_t *vs , struct hdhomerun_pkt_t *pkt ) 
{ 
  uint32_t rtp_sequence ;
  uint16_t tmp ;
  uint32_t previous_rtp_sequence ;
  int i ;

  {
  {
#line 195
  pkt->pos += 2;
#line 196
  tmp = hdhomerun_pkt_read_u16(pkt);
#line 196
  rtp_sequence = (uint32_t )tmp;
#line 197
  pkt->pos += 8;
#line 199
  previous_rtp_sequence = (uint32_t )vs->rtp_sequence;
#line 200
  vs->rtp_sequence = (uint32_t volatile   )rtp_sequence;
  }
#line 203
  if (previous_rtp_sequence == 4294967295U) {
#line 204
    return;
  }
#line 208
  if (rtp_sequence == ((previous_rtp_sequence + 1U) & 65535U)) {
#line 209
    return;
  }
#line 213
  vs->network_error_count += (uint32_t volatile   )1;
#line 217
  i = 0;
  {
#line 217
  while (1) {
    while_continue: /* CIL Label */ ;
#line 217
    if (! (i < 8192)) {
#line 217
      goto while_break;
    }
#line 218
    vs->sequence[i] = (uint8_t volatile   )255;
#line 217
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 220
  return;
}
}
#line 222 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_video.c"
static void *hdhomerun_video_thread_execute___0(void *arg ) 
{ 
  struct hdhomerun_video_sock_t *vs ;
  struct hdhomerun_pkt_t pkt_inst ;
  struct hdhomerun_pkt_t *pkt ;
  size_t length ;
  bool_t tmp ;
  size_t head ;
  uint8_t *ptr ;

  {
#line 224
  vs = (struct hdhomerun_video_sock_t *)arg;
  {
#line 227
  while (1) {
    while_continue: /* CIL Label */ ;
#line 227
    if (! (! vs->terminate)) {
#line 227
      goto while_break;
    }
    {
#line 228
    pkt = & pkt_inst;
#line 229
    hdhomerun_pkt_reset(pkt);
#line 232
    length = (size_t )1328;
#line 233
    tmp = hdhomerun_sock_recv(vs->sock, (void *)pkt->end, & length, (uint64_t )25);
    }
#line 233
    if (! tmp) {
#line 234
      goto while_continue;
    }
#line 237
    pkt->end += length;
#line 239
    if (length == 1328UL) {
      {
#line 240
      hdhomerun_video_parse_rtp___0(vs, pkt);
#line 241
      length = (size_t )((int )(pkt->end - pkt->pos));
      }
    }
#line 244
    if (length != 1316UL) {
#line 246
      goto while_continue;
    }
    {
#line 249
    pthread_mutex_lock(& vs->lock);
#line 252
    head = (size_t )vs->head;
#line 253
    ptr = vs->buffer + head;
#line 254
    memcpy((void */* __restrict  */)ptr, (void const   */* __restrict  */)pkt->pos,
           length);
#line 257
    vs->packet_count += (uint32_t volatile   )1;
#line 258
    hdhomerun_video_stats_ts_pkt___0(vs, ptr + 0);
#line 259
    hdhomerun_video_stats_ts_pkt___0(vs, ptr + 188);
#line 260
    hdhomerun_video_stats_ts_pkt___0(vs, ptr + 376);
#line 261
    hdhomerun_video_stats_ts_pkt___0(vs, ptr + 564);
#line 262
    hdhomerun_video_stats_ts_pkt___0(vs, ptr + 752);
#line 263
    hdhomerun_video_stats_ts_pkt___0(vs, ptr + 940);
#line 264
    hdhomerun_video_stats_ts_pkt___0(vs, ptr + 1128);
#line 267
    head += length;
    }
#line 268
    if (head >= vs->buffer_size) {
#line 269
      head -= vs->buffer_size;
    }
#line 273
    if (head == (size_t )vs->tail) {
      {
#line 274
      vs->overflow_error_count += (uint32_t volatile   )1;
#line 275
      pthread_mutex_unlock(& vs->lock);
      }
#line 276
      goto while_continue;
    }
    {
#line 279
    vs->head = (size_t volatile   )head;
#line 281
    pthread_mutex_unlock(& vs->lock);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 284
  return ((void *)0);
}
}
#line 41 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_os_posix.c"
static pthread_mutex_t lock___0  =    {{0, 0U, 0, 0U, 0, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}};
#line 42 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_os_posix.c"
static uint64_t result___0  =    (uint64_t )0;
#line 43 "/home/june/repo/benchmarks/collector/temp/libhdhomerun-20140121/hdhomerun_os_posix.c"
static uint64_t previous_time___0  =    (uint64_t )0;
