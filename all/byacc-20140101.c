/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 153 "/home/june/collector/temp/byacc-20140101/defs.h"
typedef char Assoc_t;
#line 156 "/home/june/collector/temp/byacc-20140101/defs.h"
typedef short Value_t;
#line 189
struct shifts;
#line 189 "/home/june/collector/temp/byacc-20140101/defs.h"
typedef struct shifts shifts;
#line 190 "/home/june/collector/temp/byacc-20140101/defs.h"
struct shifts {
   struct shifts *next ;
   Value_t number ;
   Value_t nshifts ;
   Value_t shift[1] ;
};
#line 211
struct action;
#line 211 "/home/june/collector/temp/byacc-20140101/defs.h"
typedef struct action action;
#line 212 "/home/june/collector/temp/byacc-20140101/defs.h"
struct action {
   struct action *next ;
   Value_t symbol ;
   Value_t number ;
   Value_t prec ;
   char action_code ;
   Assoc_t assoc ;
   char suppressed ;
};
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 154 "/home/june/collector/temp/byacc-20140101/defs.h"
typedef char Class_t;
#line 155 "/home/june/collector/temp/byacc-20140101/defs.h"
typedef short Index_t;
#line 160
struct bucket;
#line 160 "/home/june/collector/temp/byacc-20140101/defs.h"
typedef struct bucket bucket;
#line 161 "/home/june/collector/temp/byacc-20140101/defs.h"
struct bucket {
   struct bucket *link ;
   struct bucket *next ;
   char *name ;
   char *tag ;
   Value_t value ;
   Index_t index ;
   Value_t prec ;
   Class_t class ;
   Assoc_t assoc ;
};
#line 224
struct param;
#line 224 "/home/june/collector/temp/byacc-20140101/defs.h"
typedef struct param param;
#line 225 "/home/june/collector/temp/byacc-20140101/defs.h"
struct param {
   struct param *next ;
   char *name ;
   char *type ;
   char *type2 ;
};
#line 176
struct core;
#line 176 "/home/june/collector/temp/byacc-20140101/defs.h"
typedef struct core core;
#line 177 "/home/june/collector/temp/byacc-20140101/defs.h"
struct core {
   struct core *next ;
   struct core *link ;
   Value_t number ;
   Value_t accessing_symbol ;
   Value_t nitems ;
   Value_t items[1] ;
};
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 21 "/home/june/collector/temp/byacc-20140101/main.c"
struct _my_tmpfiles {
   struct _my_tmpfiles *next ;
   char *name ;
};
#line 21 "/home/june/collector/temp/byacc-20140101/main.c"
typedef struct _my_tmpfiles MY_TMPFILES;
#line 200 "/home/june/collector/temp/byacc-20140101/defs.h"
struct reductions;
#line 200 "/home/june/collector/temp/byacc-20140101/defs.h"
typedef struct reductions reductions;
#line 201 "/home/june/collector/temp/byacc-20140101/defs.h"
struct reductions {
   struct reductions *next ;
   Value_t number ;
   Value_t nreds ;
   Value_t rules[1] ;
};
#line 5 "/home/june/collector/temp/byacc-20140101/lalr.c"
struct shorts {
   struct shorts *next ;
   Value_t value ;
};
#line 5 "/home/june/collector/temp/byacc-20140101/lalr.c"
typedef struct shorts shorts;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 245 "/home/june/collector/temp/byacc-20140101/defs.h"
char const   *myname ;
#line 250
int exit_code ;
#line 285
int nrules ;
#line 287
int ntokens ;
#line 294
Value_t start_symbol ;
#line 298
short *symbol_prec ;
#line 299
char *symbol_assoc ;
#line 301
Value_t *ritem ;
#line 304
Value_t *rprec ;
#line 305
Assoc_t *rassoc ;
#line 313
int nstates ;
#line 317
Value_t *accessing_symbol ;
#line 319
shifts **shift_table ;
#line 321
unsigned int *LA ;
#line 322
Value_t *LAruleno ;
#line 323
Value_t *lookaheads ;
#line 328 "/home/june/collector/temp/byacc-20140101/defs.h"
action **parser  ;
#line 329 "/home/june/collector/temp/byacc-20140101/defs.h"
int SRexpect  ;
#line 330 "/home/june/collector/temp/byacc-20140101/defs.h"
int RRexpect  ;
#line 331 "/home/june/collector/temp/byacc-20140101/defs.h"
int SRtotal  ;
#line 332 "/home/june/collector/temp/byacc-20140101/defs.h"
int RRtotal  ;
#line 333 "/home/june/collector/temp/byacc-20140101/defs.h"
Value_t *SRconflicts  ;
#line 334 "/home/june/collector/temp/byacc-20140101/defs.h"
Value_t *RRconflicts  ;
#line 335 "/home/june/collector/temp/byacc-20140101/defs.h"
Value_t *defred  ;
#line 336 "/home/june/collector/temp/byacc-20140101/defs.h"
Value_t *rules_used  ;
#line 337 "/home/june/collector/temp/byacc-20140101/defs.h"
Value_t nunused  ;
#line 338 "/home/june/collector/temp/byacc-20140101/defs.h"
Value_t final_state  ;
#line 384
void no_space(void) ;
#line 428
void *allocate(size_t n ) ;
#line 432
void free_parser(void) ;
#line 433
void make_parser(void) ;
#line 5 "/home/june/collector/temp/byacc-20140101/mkpar.c"
static action *add_reduce(action *actions , int ruleno , int symbol ) ;
#line 6
static action *add_reductions(int stateno , action *actions ) ;
#line 7
static action *get_shifts(int stateno ) ;
#line 8
static action *parse_actions(int stateno ) ;
#line 9
static int sole_reduction(int stateno ) ;
#line 10
static void defreds(void) ;
#line 11
static void find_final_state(void) ;
#line 12
static void free_action_row(action *p ) ;
#line 13
static void remove_conflicts(void) ;
#line 14
static void total_conflicts(void) ;
#line 15
static void unused_rules(void) ;
#line 32 "/home/june/collector/temp/byacc-20140101/mkpar.c"
static Value_t SRcount  ;
#line 33 "/home/june/collector/temp/byacc-20140101/mkpar.c"
static Value_t RRcount  ;
#line 35 "/home/june/collector/temp/byacc-20140101/mkpar.c"
void make_parser(void) 
{ 
  int i ;
  void *tmp ;

  {
  {
#line 40
  tmp = allocate((size_t )nstates * sizeof(action *));
#line 40
  parser = (action **)tmp;
#line 41
  i = 0;
  }
  {
#line 41
  while (1) {
    while_continue: /* CIL Label */ ;
#line 41
    if (! (i < nstates)) {
#line 41
      goto while_break;
    }
    {
#line 42
    *(parser + i) = parse_actions(i);
#line 41
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 44
  find_final_state();
#line 45
  remove_conflicts();
#line 46
  unused_rules();
  }
#line 47
  if (SRtotal + RRtotal > 0) {
    {
#line 48
    total_conflicts();
    }
  }
  {
#line 49
  defreds();
  }
#line 50
  return;
}
}
#line 52 "/home/june/collector/temp/byacc-20140101/mkpar.c"
static action *parse_actions(int stateno ) 
{ 
  action *actions ;

  {
  {
#line 57
  actions = get_shifts(stateno);
#line 58
  actions = add_reductions(stateno, actions);
  }
#line 59
  return (actions);
}
}
#line 62 "/home/june/collector/temp/byacc-20140101/mkpar.c"
static action *get_shifts(int stateno ) 
{ 
  action *actions ;
  action *temp ;
  shifts *sp ;
  Value_t *to_state2 ;
  Value_t i ;
  Value_t k ;
  Value_t symbol ;
  void *tmp ;

  {
#line 71
  actions = (action *)0;
#line 72
  sp = *(shift_table + stateno);
#line 73
  if (sp) {
#line 75
    to_state2 = sp->shift;
#line 76
    i = (Value_t )((int )sp->nshifts - 1);
    {
#line 76
    while (1) {
      while_continue: /* CIL Label */ ;
#line 76
      if (! ((int )i >= 0)) {
#line 76
        goto while_break;
      }
#line 78
      k = *(to_state2 + i);
#line 79
      symbol = *(accessing_symbol + k);
#line 80
      if ((int )symbol < (int )start_symbol) {
        {
#line 82
        tmp = allocate(sizeof(action ));
#line 82
        temp = (action *)tmp;
#line 83
        temp->next = actions;
#line 84
        temp->symbol = symbol;
#line 85
        temp->number = k;
#line 86
        temp->prec = *(symbol_prec + symbol);
#line 87
        temp->action_code = (char)1;
#line 88
        temp->assoc = *(symbol_assoc + symbol);
#line 89
        actions = temp;
        }
      }
#line 76
      i = (Value_t )((int )i - 1);
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 93
  return (actions);
}
}
#line 96 "/home/june/collector/temp/byacc-20140101/mkpar.c"
static action *add_reductions(int stateno , action *actions ) 
{ 
  int i ;
  int j ;
  int m ;
  int n ;
  int ruleno ;
  int tokensetsize___0 ;
  unsigned int *rowp ;

  {
#line 103
  tokensetsize___0 = (ntokens + 31) / 32;
#line 104
  m = (int )*(lookaheads + stateno);
#line 105
  n = (int )*(lookaheads + (stateno + 1));
#line 106
  i = m;
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
#line 106
    if (! (i < n)) {
#line 106
      goto while_break;
    }
#line 108
    ruleno = (int )*(LAruleno + i);
#line 109
    rowp = LA + i * tokensetsize___0;
#line 110
    j = ntokens - 1;
    {
#line 110
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 110
      if (! (j >= 0)) {
#line 110
        goto while_break___0;
      }
#line 112
      if ((*(rowp + (j >> 5)) >> (j & 31)) & 1U) {
        {
#line 113
        actions = add_reduce(actions, ruleno, j);
        }
      }
#line 110
      j --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 106
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 116
  return (actions);
}
}
#line 119 "/home/june/collector/temp/byacc-20140101/mkpar.c"
static action *add_reduce(action *actions , int ruleno , int symbol ) 
{ 
  action *temp ;
  action *prev ;
  action *next ;
  void *tmp ;

  {
#line 126
  prev = (action *)0;
#line 127
  next = actions;
  {
#line 127
  while (1) {
    while_continue: /* CIL Label */ ;
#line 127
    if (next) {
#line 127
      if (! ((int )next->symbol < symbol)) {
#line 127
        goto while_break;
      }
    } else {
#line 127
      goto while_break;
    }
#line 128
    prev = next;
#line 127
    next = next->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 130
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 130
    if (next) {
#line 130
      if ((int )next->symbol == symbol) {
#line 130
        if (! ((int )next->action_code == 1)) {
#line 130
          goto while_break___0;
        }
      } else {
#line 130
        goto while_break___0;
      }
    } else {
#line 130
      goto while_break___0;
    }
#line 132
    prev = next;
#line 133
    next = next->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 136
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 136
    if (next) {
#line 136
      if ((int )next->symbol == symbol) {
#line 136
        if ((int )next->action_code == 2) {
#line 136
          if (! ((int )next->number < ruleno)) {
#line 136
            goto while_break___1;
          }
        } else {
#line 136
          goto while_break___1;
        }
      } else {
#line 136
        goto while_break___1;
      }
    } else {
#line 136
      goto while_break___1;
    }
#line 139
    prev = next;
#line 140
    next = next->next;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 143
  tmp = allocate(sizeof(action ));
#line 143
  temp = (action *)tmp;
#line 144
  temp->next = next;
#line 145
  temp->symbol = (Value_t )symbol;
#line 146
  temp->number = (Value_t )ruleno;
#line 147
  temp->prec = *(rprec + ruleno);
#line 148
  temp->action_code = (char)2;
#line 149
  temp->assoc = *(rassoc + ruleno);
  }
#line 151
  if (prev) {
#line 152
    prev->next = temp;
  } else {
#line 154
    actions = temp;
  }
#line 156
  return (actions);
}
}
#line 159 "/home/june/collector/temp/byacc-20140101/mkpar.c"
static void find_final_state(void) 
{ 
  int goal___0 ;
  int i ;
  Value_t *to_state2 ;
  shifts *p ;

  {
#line 166
  p = *(shift_table + 0);
#line 167
  to_state2 = p->shift;
#line 168
  goal___0 = (int )*(ritem + 1);
#line 169
  i = (int )p->nshifts - 1;
  {
#line 169
  while (1) {
    while_continue: /* CIL Label */ ;
#line 169
    if (! (i >= 0)) {
#line 169
      goto while_break;
    }
#line 171
    final_state = *(to_state2 + i);
#line 172
    if ((int )*(accessing_symbol + final_state) == goal___0) {
#line 173
      goto while_break;
    }
#line 169
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 175
  return;
}
}
#line 177 "/home/june/collector/temp/byacc-20140101/mkpar.c"
static void unused_rules(void) 
{ 
  int i ;
  action *p ;
  void *tmp ;

  {
  {
#line 183
  tmp = malloc((size_t )nrules * sizeof(Value_t ));
#line 183
  rules_used = (Value_t *)tmp;
  }
#line 184
  if ((unsigned long )rules_used == (unsigned long )((Value_t *)0)) {
    {
#line 184
    no_space();
    }
  }
#line 184
  if (! ((unsigned long )rules_used != (unsigned long )((Value_t *)0))) {
    {
#line 184
    __assert_fail("rules_used != 0", "/home/june/collector/temp/byacc-20140101/mkpar.c",
                  184U, "unused_rules");
    }
  }
#line 186
  i = 0;
  {
#line 186
  while (1) {
    while_continue: /* CIL Label */ ;
#line 186
    if (! (i < nrules)) {
#line 186
      goto while_break;
    }
#line 187
    *(rules_used + i) = (Value_t )0;
#line 186
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 189
  i = 0;
  {
#line 189
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 189
    if (! (i < nstates)) {
#line 189
      goto while_break___0;
    }
#line 191
    p = *(parser + i);
    {
#line 191
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 191
      if (! p) {
#line 191
        goto while_break___1;
      }
#line 193
      if ((int )p->action_code == 2) {
#line 193
        if ((int )p->suppressed == 0) {
#line 194
          *(rules_used + p->number) = (Value_t )1;
        }
      }
#line 191
      p = p->next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 189
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 198
  nunused = (Value_t )0;
#line 199
  i = 3;
  {
#line 199
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 199
    if (! (i < nrules)) {
#line 199
      goto while_break___2;
    }
#line 200
    if (! *(rules_used + i)) {
#line 201
      nunused = (Value_t )((int )nunused + 1);
    }
#line 199
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 203
  if (nunused) {
#line 205
    if ((int )nunused == 1) {
      {
#line 206
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: 1 rule never reduced\n",
              myname);
      }
    } else {
      {
#line 208
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %d rules never reduced\n",
              myname, (int )nunused);
      }
    }
  }
#line 210
  return;
}
}
#line 212 "/home/june/collector/temp/byacc-20140101/mkpar.c"
static void remove_conflicts(void) 
{ 
  int i ;
  int symbol ;
  action *p ;
  action *pref ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 217
  pref = (action *)0;
#line 219
  SRtotal = 0;
#line 220
  RRtotal = 0;
#line 221
  tmp = allocate((size_t )nstates * sizeof(Value_t ));
#line 221
  SRconflicts = (Value_t *)tmp;
#line 222
  tmp___0 = allocate((size_t )nstates * sizeof(Value_t ));
#line 222
  RRconflicts = (Value_t *)tmp___0;
#line 223
  i = 0;
  }
  {
#line 223
  while (1) {
    while_continue: /* CIL Label */ ;
#line 223
    if (! (i < nstates)) {
#line 223
      goto while_break;
    }
#line 225
    SRcount = (Value_t )0;
#line 226
    RRcount = (Value_t )0;
#line 227
    symbol = -1;
#line 228
    p = *(parser + i);
    {
#line 228
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 228
      if (! p) {
#line 228
        goto while_break___0;
      }
#line 230
      if ((int )p->symbol != symbol) {
#line 232
        pref = p;
#line 233
        symbol = (int )p->symbol;
      } else
#line 235
      if (i == (int )final_state) {
#line 235
        if (symbol == 0) {
#line 237
          SRcount = (Value_t )((int )SRcount + 1);
#line 238
          p->suppressed = (char)1;
        } else {
#line 235
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 240
      if ((unsigned long )pref != (unsigned long )((action *)0)) {
#line 240
        if ((int )pref->action_code == 1) {
#line 242
          if ((int )pref->prec > 0) {
#line 242
            if ((int )p->prec > 0) {
#line 244
              if ((int )pref->prec < (int )p->prec) {
#line 246
                pref->suppressed = (char)2;
#line 247
                pref = p;
              } else
#line 249
              if ((int )pref->prec > (int )p->prec) {
#line 251
                p->suppressed = (char)2;
              } else
#line 253
              if ((int )pref->assoc == 1) {
#line 255
                pref->suppressed = (char)2;
#line 256
                pref = p;
              } else
#line 258
              if ((int )pref->assoc == 2) {
#line 260
                p->suppressed = (char)2;
              } else {
#line 264
                pref->suppressed = (char)2;
#line 265
                p->suppressed = (char)2;
              }
            } else {
#line 270
              SRcount = (Value_t )((int )SRcount + 1);
#line 271
              p->suppressed = (char)1;
            }
          } else {
#line 270
            SRcount = (Value_t )((int )SRcount + 1);
#line 271
            p->suppressed = (char)1;
          }
        } else {
#line 276
          RRcount = (Value_t )((int )RRcount + 1);
#line 277
          p->suppressed = (char)1;
        }
      } else {
#line 276
        RRcount = (Value_t )((int )RRcount + 1);
#line 277
        p->suppressed = (char)1;
      }
#line 228
      p = p->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 280
    SRtotal += (int )SRcount;
#line 281
    RRtotal += (int )RRcount;
#line 282
    *(SRconflicts + i) = SRcount;
#line 283
    *(RRconflicts + i) = RRcount;
#line 223
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 285
  return;
}
}
#line 287 "/home/june/collector/temp/byacc-20140101/mkpar.c"
static void total_conflicts(void) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 290
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
          myname);
  }
#line 291
  if (SRtotal == 1) {
    {
#line 292
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"1 shift/reduce conflict");
    }
  } else
#line 293
  if (SRtotal > 1) {
    {
#line 294
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%d shift/reduce conflicts",
            SRtotal);
    }
  }
#line 296
  if (SRtotal) {
#line 296
    if (RRtotal) {
      {
#line 297
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)", ");
      }
    }
  }
#line 299
  if (RRtotal == 1) {
    {
#line 300
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"1 reduce/reduce conflict");
    }
  } else
#line 301
  if (RRtotal > 1) {
    {
#line 302
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%d reduce/reduce conflicts",
            RRtotal);
    }
  }
  {
#line 304
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)".\n");
  }
#line 306
  if (SRexpect >= 0) {
#line 306
    if (SRtotal != SRexpect) {
      {
#line 308
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
              myname);
      }
#line 309
      if (SRexpect > 1) {
#line 309
        tmp = "s";
      } else {
#line 309
        tmp = "";
      }
      {
#line 309
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"expected %d shift/reduce conflict%s.\n",
              SRexpect, tmp);
#line 311
      exit_code = 1;
      }
    }
  }
#line 313
  if (RRexpect >= 0) {
#line 313
    if (RRtotal != RRexpect) {
      {
#line 315
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
              myname);
      }
#line 316
      if (RRexpect > 1) {
#line 316
        tmp___0 = "s";
      } else {
#line 316
        tmp___0 = "";
      }
      {
#line 316
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"expected %d reduce/reduce conflict%s.\n",
              RRexpect, tmp___0);
#line 318
      exit_code = 1;
      }
    }
  }
#line 320
  return;
}
}
#line 322 "/home/june/collector/temp/byacc-20140101/mkpar.c"
static int sole_reduction(int stateno ) 
{ 
  int count ;
  int ruleno ;
  action *p ;

  {
#line 328
  count = 0;
#line 329
  ruleno = 0;
#line 330
  p = *(parser + stateno);
  {
#line 330
  while (1) {
    while_continue: /* CIL Label */ ;
#line 330
    if (! p) {
#line 330
      goto while_break;
    }
#line 332
    if ((int )p->action_code == 1) {
#line 332
      if ((int )p->suppressed == 0) {
#line 333
        return (0);
      } else {
#line 332
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 334
    if ((int )p->action_code == 2) {
#line 334
      if ((int )p->suppressed == 0) {
#line 336
        if (ruleno > 0) {
#line 336
          if ((int )p->number != ruleno) {
#line 337
            return (0);
          }
        }
#line 338
        if ((int )p->symbol != 1) {
#line 339
          count ++;
        }
#line 340
        ruleno = (int )p->number;
      }
    }
#line 330
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 344
  if (count == 0) {
#line 345
    return (0);
  }
#line 346
  return (ruleno);
}
}
#line 349 "/home/june/collector/temp/byacc-20140101/mkpar.c"
static void defreds(void) 
{ 
  int i ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 354
  tmp = allocate((size_t )nstates * sizeof(Value_t ));
#line 354
  defred = (Value_t *)tmp;
#line 355
  i = 0;
  }
  {
#line 355
  while (1) {
    while_continue: /* CIL Label */ ;
#line 355
    if (! (i < nstates)) {
#line 355
      goto while_break;
    }
    {
#line 356
    tmp___0 = sole_reduction(i);
#line 356
    *(defred + i) = (Value_t )tmp___0;
#line 355
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 357
  return;
}
}
#line 359 "/home/june/collector/temp/byacc-20140101/mkpar.c"
static void free_action_row(action *p ) 
{ 
  action *q ;

  {
  {
#line 364
  while (1) {
    while_continue: /* CIL Label */ ;
#line 364
    if (! p) {
#line 364
      goto while_break;
    }
    {
#line 366
    q = p->next;
#line 367
    free((void *)((char *)p));
#line 368
    p = q;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 370
  return;
}
}
#line 372 "/home/june/collector/temp/byacc-20140101/mkpar.c"
void free_parser(void) 
{ 
  int i ;

  {
#line 377
  i = 0;
  {
#line 377
  while (1) {
    while_continue: /* CIL Label */ ;
#line 377
    if (! (i < nstates)) {
#line 377
      goto while_break;
    }
    {
#line 378
    free_action_row(*(parser + i));
#line 377
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 380
  free((void *)((char *)parser));
  }
#line 381
  return;
}
}
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 124
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 434 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 435
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 235 "/home/june/collector/temp/byacc-20140101/defs.h"
char dflag ;
#line 236
char gflag ;
#line 238
char lflag ;
#line 242
char vflag ;
#line 246 "/home/june/collector/temp/byacc-20140101/defs.h"
char *cptr  ;
#line 247 "/home/june/collector/temp/byacc-20140101/defs.h"
char *line  ;
#line 248
int lineno ;
#line 249
int outline ;
#line 251
int pure_parser ;
#line 252
int token_table ;
#line 254
char const   * const  banner[15] ;
#line 269
char *input_file_name ;
#line 273
FILE *action_file ;
#line 274
FILE *code_file ;
#line 277
FILE *input_file ;
#line 278
FILE *output_file ;
#line 279
FILE *text_file ;
#line 280
FILE *union_file ;
#line 281
FILE *verbose_file ;
#line 284
int nitems ;
#line 286
int nsyms ;
#line 288
int nvars ;
#line 289 "/home/june/collector/temp/byacc-20140101/defs.h"
int ntags  ;
#line 291 "/home/june/collector/temp/byacc-20140101/defs.h"
char unionized  ;
#line 292
char line_format[15] ;
#line 295
char **symbol_name ;
#line 296
char **symbol_pname ;
#line 297
Value_t *symbol_value ;
#line 302
Value_t *rlhs ;
#line 303
Value_t *rrhs ;
#line 310
bucket *first_symbol ;
#line 311
bucket *last_symbol ;
#line 344 "/home/june/collector/temp/byacc-20140101/defs.h"
param *lex_param  ;
#line 345 "/home/june/collector/temp/byacc-20140101/defs.h"
param *parse_param  ;
#line 349
bucket *lookup(char const   *name ) ;
#line 350
bucket *make_bucket(char const   *name ) ;
#line 376
void default_action_warning(void) ;
#line 377
void dollar_error(int a_lineno , char *a_line , char *a_cptr ) ;
#line 378
void dollar_warning(int a_lineno , int i ) ;
#line 380
void illegal_character(char *c_cptr ) ;
#line 381
void illegal_tag(int t_lineno , char *t_line , char *t_cptr ) ;
#line 382
void missing_brace(void) ;
#line 383
void no_grammar(void) ;
#line 386
void over_unionized(char *u_cptr ) ;
#line 387
void prec_redeclared(void) ;
#line 388
void reprec_warning(char *s ) ;
#line 389
void restarted_warning(void) ;
#line 390
void retyped_warning(char *s ) ;
#line 391
void revalued_warning(char *s ) ;
#line 392
void syntax_error(int st_lineno , char *st_line , char *st_cptr ) ;
#line 393
void terminal_lhs(int s_lineno ) ;
#line 394
void terminal_start(char *s ) ;
#line 395
void tokenized_start(char *s ) ;
#line 396
void undefined_goal(char *s ) ;
#line 397
void undefined_symbol_warning(char *s ) ;
#line 398
void unexpected_EOF(void) ;
#line 399
void unknown_rhs(int i ) ;
#line 400
void unterminated_action(int a_lineno , char *a_line , char *a_cptr ) ;
#line 401
void unterminated_comment(int c_lineno , char *c_line , char *c_cptr ) ;
#line 402
void unterminated_string(int s_lineno , char *s_line , char *s_cptr ) ;
#line 403
void unterminated_text(int t_lineno , char *t_line , char *t_cptr ) ;
#line 404
void unterminated_union(int u_lineno , char *u_line , char *u_cptr ) ;
#line 405
void untyped_lhs(void) ;
#line 406
void untyped_rhs(int i , char *s ) ;
#line 407
void used_reserved(char *s ) ;
#line 413
void create_symbol_table(void) ;
#line 414
void free_symbol_table(void) ;
#line 415
void free_symbols(void) ;
#line 439
void reader(void) ;
#line 442
void write_section(FILE *fp , char const   * const  *section ) ;
#line 15 "/home/june/collector/temp/byacc-20140101/reader.c"
static void start_rule(bucket *bp , int s_lineno ) ;
#line 17 "/home/june/collector/temp/byacc-20140101/reader.c"
static char *cache  ;
#line 18 "/home/june/collector/temp/byacc-20140101/reader.c"
static int cinc  ;
#line 18 "/home/june/collector/temp/byacc-20140101/reader.c"
static int cache_size  ;
#line 21 "/home/june/collector/temp/byacc-20140101/reader.c"
static int tagmax  ;
#line 22 "/home/june/collector/temp/byacc-20140101/reader.c"
static char **tag_table  ;
#line 24 "/home/june/collector/temp/byacc-20140101/reader.c"
static char saw_eof  ;
#line 27 "/home/june/collector/temp/byacc-20140101/reader.c"
static int linesize  ;
#line 29 "/home/june/collector/temp/byacc-20140101/reader.c"
static bucket *goal  ;
#line 30 "/home/june/collector/temp/byacc-20140101/reader.c"
static Value_t prec  ;
#line 31 "/home/june/collector/temp/byacc-20140101/reader.c"
static int gensym  ;
#line 32 "/home/june/collector/temp/byacc-20140101/reader.c"
static char last_was_action  ;
#line 34 "/home/june/collector/temp/byacc-20140101/reader.c"
static int maxitems  ;
#line 35 "/home/june/collector/temp/byacc-20140101/reader.c"
static bucket **pitem  ;
#line 37 "/home/june/collector/temp/byacc-20140101/reader.c"
static int maxrules  ;
#line 38 "/home/june/collector/temp/byacc-20140101/reader.c"
static bucket **plhs  ;
#line 40 "/home/june/collector/temp/byacc-20140101/reader.c"
static size_t name_pool_size  ;
#line 41 "/home/june/collector/temp/byacc-20140101/reader.c"
static char *name_pool  ;
#line 43 "/home/june/collector/temp/byacc-20140101/reader.c"
char line_format[15]  = 
#line 43
  {      (char )'#',      (char )'l',      (char )'i',      (char )'n', 
        (char )'e',      (char )' ',      (char )'%',      (char )'d', 
        (char )' ',      (char )'\"',      (char )'%',      (char )'s', 
        (char )'\"',      (char )'\n',      (char )'\000'};
#line 48 "/home/june/collector/temp/byacc-20140101/reader.c"
static void cachec(int c ) 
{ 
  void *tmp ;

  {
#line 51
  if (! (cinc >= 0)) {
    {
#line 51
    __assert_fail("cinc >= 0", "/home/june/collector/temp/byacc-20140101/reader.c",
                  51U, "cachec");
    }
  }
#line 52
  if (cinc >= cache_size) {
    {
#line 54
    cache_size += 256;
#line 55
    tmp = realloc((void *)cache, (size_t )cache_size * sizeof(char ));
#line 55
    cache = (char *)tmp;
    }
#line 56
    if ((unsigned long )cache == (unsigned long )((char *)0)) {
      {
#line 56
      no_space();
      }
    }
#line 56
    if (! ((unsigned long )cache != (unsigned long )((char *)0))) {
      {
#line 56
      __assert_fail("cache != 0", "/home/june/collector/temp/byacc-20140101/reader.c",
                    56U, "cachec");
      }
    }
  }
#line 58
  *(cache + cinc) = (char )c;
#line 59
  cinc ++;
#line 60
  return;
}
}
#line 62 "/home/june/collector/temp/byacc-20140101/reader.c"
static void get_line(void) 
{ 
  FILE *f ;
  int c ;
  int i ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 65
  f = input_file;
#line 69
  if (saw_eof) {
#line 69
    goto _L;
  } else {
    {
#line 69
    c = _IO_getc(f);
    }
#line 69
    if (c == -1) {
      _L: /* CIL Label */ 
#line 71
      if (line) {
        {
#line 73
        free((void *)line);
#line 74
        line = (char *)0;
        }
      }
#line 76
      cptr = (char *)0;
#line 77
      saw_eof = (char)1;
#line 78
      return;
    }
  }
#line 81
  if ((unsigned long )line == (unsigned long )((char *)0)) {
#line 81
    goto _L___0;
  } else
#line 81
  if (linesize != 101) {
    _L___0: /* CIL Label */ 
#line 83
    if (line) {
      {
#line 84
      free((void *)line);
      }
    }
    {
#line 85
    linesize = 101;
#line 86
    tmp = malloc((size_t )linesize * sizeof(char ));
#line 86
    line = (char *)tmp;
    }
#line 87
    if ((unsigned long )line == (unsigned long )((char *)0)) {
      {
#line 87
      no_space();
      }
    }
#line 87
    if (! ((unsigned long )line != (unsigned long )((char *)0))) {
      {
#line 87
      __assert_fail("line != 0", "/home/june/collector/temp/byacc-20140101/reader.c",
                    87U, "get_line");
      }
    }
  }
#line 90
  i = 0;
#line 91
  lineno ++;
  {
#line 92
  while (1) {
    while_continue: /* CIL Label */ ;
#line 94
    *(line + i) = (char )c;
#line 95
    if (c == 10) {
#line 97
      cptr = line;
#line 98
      return;
    }
#line 100
    i ++;
#line 100
    if (i >= linesize) {
      {
#line 102
      linesize += 100;
#line 103
      tmp___0 = realloc((void *)line, (size_t )linesize * sizeof(char ));
#line 103
      line = (char *)tmp___0;
      }
#line 104
      if ((unsigned long )line == (unsigned long )((char *)0)) {
        {
#line 104
        no_space();
        }
      }
#line 104
      if (! ((unsigned long )line != (unsigned long )((char *)0))) {
        {
#line 104
        __assert_fail("line != 0", "/home/june/collector/temp/byacc-20140101/reader.c",
                      104U, "get_line");
        }
      }
    }
    {
#line 106
    c = _IO_getc(f);
    }
#line 107
    if (c == -1) {
#line 109
      *(line + i) = (char )'\n';
#line 110
      saw_eof = (char)1;
#line 111
      cptr = line;
#line 112
      return;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 117 "/home/june/collector/temp/byacc-20140101/reader.c"
static char *dup_line(void) 
{ 
  char *p ;
  char *s ;
  char *t ;
  void *tmp ;
  char *tmp___0 ;
  char tmp___1 ;
  char *tmp___2 ;

  {
#line 122
  if ((unsigned long )line == (unsigned long )((char *)0)) {
#line 123
    return ((char *)0);
  }
#line 124
  s = line;
  {
#line 125
  while (1) {
    while_continue: /* CIL Label */ ;
#line 125
    if (! ((int )*s != 10)) {
#line 125
      goto while_break;
    }
#line 126
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 127
  tmp = malloc((size_t )((s - line) + 1L) * sizeof(char ));
#line 127
  p = (char *)tmp;
  }
#line 128
  if ((unsigned long )p == (unsigned long )((char *)0)) {
    {
#line 128
    no_space();
    }
  }
#line 128
  if (! ((unsigned long )p != (unsigned long )((char *)0))) {
    {
#line 128
    __assert_fail("p != 0", "/home/june/collector/temp/byacc-20140101/reader.c", 128U,
                  "dup_line");
    }
  }
#line 130
  s = line;
#line 131
  t = p;
  {
#line 132
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 132
    tmp___0 = t;
#line 132
    t ++;
#line 132
    tmp___2 = s;
#line 132
    s ++;
#line 132
    tmp___1 = *tmp___2;
#line 132
    *tmp___0 = tmp___1;
#line 132
    if (! ((int )tmp___1 != 10)) {
#line 132
      goto while_break___0;
    }
#line 133
    goto while_continue___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 134
  return (p);
}
}
#line 137 "/home/june/collector/temp/byacc-20140101/reader.c"
static void skip_comment(void) 
{ 
  char *s ;
  int st_lineno ;
  char *st_line ;
  char *tmp ;
  char *st_cptr ;

  {
  {
#line 142
  st_lineno = lineno;
#line 143
  tmp = dup_line();
#line 143
  st_line = tmp;
#line 144
  st_cptr = st_line + (cptr - line);
#line 146
  s = cptr + 2;
  }
  {
#line 147
  while (1) {
    while_continue: /* CIL Label */ ;
#line 149
    if ((int )*s == 42) {
#line 149
      if ((int )*(s + 1) == 47) {
        {
#line 151
        cptr = s + 2;
#line 152
        free((void *)st_line);
        }
#line 153
        return;
      }
    }
#line 155
    if ((int )*s == 10) {
      {
#line 157
      get_line();
      }
#line 158
      if ((unsigned long )line == (unsigned long )((char *)0)) {
        {
#line 159
        unterminated_comment(st_lineno, st_line, st_cptr);
        }
      }
#line 160
      s = cptr;
    } else {
#line 163
      s ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 167 "/home/june/collector/temp/byacc-20140101/reader.c"
static int nextc(void) 
{ 
  char *s ;

  {
#line 172
  if ((unsigned long )line == (unsigned long )((char *)0)) {
    {
#line 174
    get_line();
    }
#line 175
    if ((unsigned long )line == (unsigned long )((char *)0)) {
#line 176
      return (-1);
    }
  }
#line 179
  s = cptr;
  {
#line 180
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 184
    if ((int )*s == 10) {
#line 184
      goto case_10;
    }
#line 197
    if ((int )*s == 59) {
#line 197
      goto case_59;
    }
#line 197
    if ((int )*s == 44) {
#line 197
      goto case_59;
    }
#line 197
    if ((int )*s == 11) {
#line 197
      goto case_59;
    }
#line 197
    if ((int )*s == 13) {
#line 197
      goto case_59;
    }
#line 197
    if ((int )*s == 12) {
#line 197
      goto case_59;
    }
#line 197
    if ((int )*s == 9) {
#line 197
      goto case_59;
    }
#line 197
    if ((int )*s == 32) {
#line 197
      goto case_59;
    }
#line 201
    if ((int )*s == 92) {
#line 201
      goto case_92;
    }
#line 205
    if ((int )*s == 47) {
#line 205
      goto case_47;
    }
#line 223
    goto switch_default;
    case_10: /* CIL Label */ 
    {
#line 185
    get_line();
    }
#line 186
    if ((unsigned long )line == (unsigned long )((char *)0)) {
#line 187
      return (-1);
    }
#line 188
    s = cptr;
#line 189
    goto switch_break;
    case_59: /* CIL Label */ 
    case_44: /* CIL Label */ 
    case_11: /* CIL Label */ 
    case_13: /* CIL Label */ 
    case_12: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_32: /* CIL Label */ 
#line 198
    s ++;
#line 199
    goto switch_break;
    case_92: /* CIL Label */ 
#line 202
    cptr = s;
#line 203
    return ('%');
    case_47: /* CIL Label */ 
#line 206
    if ((int )*(s + 1) == 42) {
      {
#line 208
      cptr = s;
#line 209
      skip_comment();
#line 210
      s = cptr;
      }
#line 211
      goto switch_break;
    } else
#line 213
    if ((int )*(s + 1) == 47) {
      {
#line 215
      get_line();
      }
#line 216
      if ((unsigned long )line == (unsigned long )((char *)0)) {
#line 217
        return (-1);
      }
#line 218
      s = cptr;
#line 219
      goto switch_break;
    }
    switch_default: /* CIL Label */ 
#line 224
    cptr = s;
#line 225
    return ((int )*s);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 234 "/home/june/collector/temp/byacc-20140101/reader.c"
static int matchec(char const   *name ) 
{ 
  char const   *p ;
  char const   *q ;
  int code ;
  char a ;
  char const   *tmp ;
  char b ;
  char const   *tmp___0 ;

  {
#line 237
  p = (char const   *)cache;
#line 238
  q = name;
#line 239
  code = 0;
  {
#line 241
  while (1) {
    while_continue: /* CIL Label */ ;
#line 241
    if ((int const   )*p != 0) {
#line 241
      if (! ((int const   )*q != 0)) {
#line 241
        goto while_break;
      }
    } else {
#line 241
      goto while_break;
    }
#line 243
    tmp = p;
#line 243
    p ++;
#line 243
    a = (char )*tmp;
#line 244
    tmp___0 = q;
#line 244
    q ++;
#line 244
    b = (char )*tmp___0;
#line 245
    if ((int )a == 95) {
#line 246
      a = (char )'-';
    }
#line 247
    if ((int )b == 95) {
#line 248
      b = (char )'-';
    }
#line 249
    if ((int )a != (int )b) {
#line 250
      goto while_break;
    }
#line 251
    if ((int const   )*p == 0) {
#line 251
      if ((int const   )*q == 0) {
#line 253
        code = 1;
#line 254
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 257
  return (code);
}
}
#line 260 "/home/june/collector/temp/byacc-20140101/reader.c"
static int keyword(void) 
{ 
  int c ;
  char *t_cptr ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  unsigned short const   **tmp___19 ;

  {
  {
#line 264
  t_cptr = cptr;
#line 266
  cptr ++;
#line 266
  c = (int )*cptr;
#line 267
  tmp___19 = __ctype_b_loc();
  }
#line 267
  if ((int const   )*(*tmp___19 + c) & 1024) {
#line 269
    cinc = 0;
    {
#line 270
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 272
      tmp___1 = __ctype_b_loc();
      }
#line 272
      if ((int const   )*(*tmp___1 + c) & 1024) {
        {
#line 274
        tmp = __ctype_b_loc();
        }
#line 274
        if ((int const   )*(*tmp + c) & 256) {
          {
#line 275
          c = tolower(c);
          }
        }
        {
#line 276
        cachec(c);
        }
      } else {
        {
#line 278
        tmp___0 = __ctype_b_loc();
        }
#line 278
        if ((int const   )*(*tmp___0 + c) & 2048) {
          {
#line 284
          cachec(c);
          }
        } else
#line 278
        if (c == 45) {
          {
#line 284
          cachec(c);
          }
        } else
#line 278
        if (c == 95) {
          {
#line 284
          cachec(c);
          }
        } else
#line 278
        if (c == 46) {
          {
#line 284
          cachec(c);
          }
        } else
#line 278
        if (c == 36) {
          {
#line 284
          cachec(c);
          }
        } else {
#line 288
          goto while_break;
        }
      }
#line 290
      cptr ++;
#line 290
      c = (int )*cptr;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 292
    cachec('\000');
#line 294
    tmp___2 = matchec("token");
    }
#line 294
    if (tmp___2) {
#line 295
      return (0);
    } else {
      {
#line 294
      tmp___3 = matchec("term");
      }
#line 294
      if (tmp___3) {
#line 295
        return (0);
      }
    }
    {
#line 296
    tmp___4 = matchec("type");
    }
#line 296
    if (tmp___4) {
#line 297
      return (6);
    }
    {
#line 298
    tmp___5 = matchec("left");
    }
#line 298
    if (tmp___5) {
#line 299
      return (1);
    }
    {
#line 300
    tmp___6 = matchec("right");
    }
#line 300
    if (tmp___6) {
#line 301
      return (2);
    }
    {
#line 302
    tmp___7 = matchec("nonassoc");
    }
#line 302
    if (tmp___7) {
#line 303
      return (3);
    } else {
      {
#line 302
      tmp___8 = matchec("binary");
      }
#line 302
      if (tmp___8) {
#line 303
        return (3);
      }
    }
    {
#line 304
    tmp___9 = matchec("start");
    }
#line 304
    if (tmp___9) {
#line 305
      return (7);
    }
    {
#line 306
    tmp___10 = matchec("union");
    }
#line 306
    if (tmp___10) {
#line 307
      return (8);
    }
    {
#line 308
    tmp___11 = matchec("ident");
    }
#line 308
    if (tmp___11) {
#line 309
      return (9);
    }
    {
#line 310
    tmp___12 = matchec("expect");
    }
#line 310
    if (tmp___12) {
#line 311
      return (10);
    }
    {
#line 312
    tmp___13 = matchec("expect-rr");
    }
#line 312
    if (tmp___13) {
#line 313
      return (11);
    }
    {
#line 314
    tmp___14 = matchec("pure-parser");
    }
#line 314
    if (tmp___14) {
#line 315
      return (12);
    }
    {
#line 316
    tmp___15 = matchec("parse-param");
    }
#line 316
    if (tmp___15) {
#line 317
      return (13);
    }
    {
#line 318
    tmp___16 = matchec("lex-param");
    }
#line 318
    if (tmp___16) {
#line 319
      return (14);
    }
    {
#line 320
    tmp___17 = matchec("token-table");
    }
#line 320
    if (tmp___17) {
#line 321
      return (16);
    }
    {
#line 322
    tmp___18 = matchec("yacc");
    }
#line 322
    if (tmp___18) {
#line 323
      return (15);
    }
  } else {
#line 327
    cptr ++;
#line 328
    if (c == 123) {
#line 329
      return (5);
    }
#line 330
    if (c == 37) {
#line 331
      return (4);
    } else
#line 330
    if (c == 92) {
#line 331
      return (4);
    }
#line 332
    if (c == 60) {
#line 333
      return (1);
    }
#line 334
    if (c == 62) {
#line 335
      return (2);
    }
#line 336
    if (c == 48) {
#line 337
      return (0);
    }
#line 338
    if (c == 50) {
#line 339
      return (3);
    }
  }
  {
#line 341
  syntax_error(lineno, line, t_cptr);
  }
#line 343
  return (0);
}
}
#line 345 "/home/june/collector/temp/byacc-20140101/reader.c"
static void copy_ident(void) 
{ 
  int c ;
  FILE *f ;

  {
  {
#line 349
  f = output_file;
#line 351
  c = nextc();
  }
#line 352
  if (c == -1) {
    {
#line 353
    unexpected_EOF();
    }
  }
#line 354
  if (c != 34) {
    {
#line 355
    syntax_error(lineno, line, cptr);
    }
  }
  {
#line 356
  outline ++;
#line 357
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"#ident \"");
  }
  {
#line 358
  while (1) {
    while_continue: /* CIL Label */ ;
#line 360
    cptr ++;
#line 360
    c = (int )*cptr;
#line 361
    if (c == 10) {
      {
#line 363
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\"\n");
      }
#line 364
      return;
    }
    {
#line 366
    _IO_putc(c, f);
    }
#line 367
    if (c == 34) {
      {
#line 369
      _IO_putc('\n', f);
#line 370
      cptr ++;
      }
#line 371
      return;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 376 "/home/june/collector/temp/byacc-20140101/reader.c"
static void copy_text(void) 
{ 
  int c ;
  int quote ;
  FILE *f ;
  int need_newline ;
  int t_lineno ;
  char *t_line ;
  char *tmp ;
  char *t_cptr ;
  char *tmp___0 ;
  int s_lineno ;
  char *s_line ;
  char *tmp___1 ;
  char *s_cptr ;
  char *tmp___2 ;
  char *tmp___3 ;
  int c_lineno ;
  char *c_line ;
  char *tmp___4 ;
  char *c_cptr ;
  char *tmp___5 ;

  {
  {
#line 381
  f = text_file;
#line 382
  need_newline = 0;
#line 383
  t_lineno = lineno;
#line 384
  tmp = dup_line();
#line 384
  t_line = tmp;
#line 385
  t_cptr = t_line + ((cptr - line) - 2L);
  }
#line 387
  if ((int )*cptr == 10) {
    {
#line 389
    get_line();
    }
#line 390
    if ((unsigned long )line == (unsigned long )((char *)0)) {
      {
#line 391
      unterminated_text(t_lineno, t_line, t_cptr);
      }
    }
  }
#line 393
  if (! lflag) {
    {
#line 394
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)(line_format),
            lineno, input_file_name);
    }
  }
  loop: 
#line 397
  tmp___0 = cptr;
#line 397
  cptr ++;
#line 397
  c = (int )*tmp___0;
  {
#line 400
  if (c == 10) {
#line 400
    goto next_line;
  }
#line 410
  if (c == 34) {
#line 410
    goto case_34;
  }
#line 410
  if (c == 39) {
#line 410
    goto case_34;
  }
#line 444
  if (c == 47) {
#line 444
    goto case_47;
  }
#line 492
  if (c == 92) {
#line 492
    goto case_92;
  }
#line 492
  if (c == 37) {
#line 492
    goto case_92;
  }
#line 503
  goto switch_default;
  next_line: 
  case_10: /* CIL Label */ 
  {
#line 402
  _IO_putc('\n', f);
#line 403
  need_newline = 0;
#line 404
  get_line();
  }
#line 405
  if (line) {
#line 406
    goto loop;
  }
  {
#line 407
  unterminated_text(t_lineno, t_line, t_cptr);
  }
  case_34: /* CIL Label */ 
  case_39: /* CIL Label */ 
  {
#line 412
  s_lineno = lineno;
#line 413
  tmp___1 = dup_line();
#line 413
  s_line = tmp___1;
#line 414
  s_cptr = s_line + ((cptr - line) - 1L);
#line 416
  quote = c;
#line 417
  _IO_putc(c, f);
  }
  {
#line 418
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 420
    tmp___2 = cptr;
#line 420
    cptr ++;
#line 420
    c = (int )*tmp___2;
#line 421
    _IO_putc(c, f);
    }
#line 422
    if (c == quote) {
      {
#line 424
      need_newline = 1;
#line 425
      free((void *)s_line);
      }
#line 426
      goto loop;
    }
#line 428
    if (c == 10) {
      {
#line 429
      unterminated_string(s_lineno, s_line, s_cptr);
      }
    }
#line 430
    if (c == 92) {
      {
#line 432
      tmp___3 = cptr;
#line 432
      cptr ++;
#line 432
      c = (int )*tmp___3;
#line 433
      _IO_putc(c, f);
      }
#line 434
      if (c == 10) {
        {
#line 436
        get_line();
        }
#line 437
        if ((unsigned long )line == (unsigned long )((char *)0)) {
          {
#line 438
          unterminated_string(s_lineno, s_line, s_cptr);
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  case_47: /* CIL Label */ 
  {
#line 445
  _IO_putc(c, f);
#line 446
  need_newline = 1;
#line 447
  c = (int )*cptr;
  }
#line 448
  if (c == 47) {
    {
#line 450
    _IO_putc('*', f);
    }
    {
#line 451
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 451
      cptr ++;
#line 451
      c = (int )*cptr;
#line 451
      if (! (c != 10)) {
#line 451
        goto while_break___0;
      }
#line 453
      if (c == 42) {
#line 453
        if ((int )*(cptr + 1) == 47) {
          {
#line 454
          fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"* ");
          }
        } else {
          {
#line 456
          _IO_putc(c, f);
          }
        }
      } else {
        {
#line 456
        _IO_putc(c, f);
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 458
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"*/");
    }
#line 459
    goto next_line;
  }
#line 461
  if (c == 42) {
    {
#line 463
    c_lineno = lineno;
#line 464
    tmp___4 = dup_line();
#line 464
    c_line = tmp___4;
#line 465
    c_cptr = c_line + ((cptr - line) - 1L);
#line 467
    _IO_putc('*', f);
#line 468
    cptr ++;
    }
    {
#line 469
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 471
      tmp___5 = cptr;
#line 471
      cptr ++;
#line 471
      c = (int )*tmp___5;
#line 472
      _IO_putc(c, f);
      }
#line 473
      if (c == 42) {
#line 473
        if ((int )*cptr == 47) {
          {
#line 475
          _IO_putc('/', f);
#line 476
          cptr ++;
#line 477
          free((void *)c_line);
          }
#line 478
          goto loop;
        }
      }
#line 480
      if (c == 10) {
        {
#line 482
        get_line();
        }
#line 483
        if ((unsigned long )line == (unsigned long )((char *)0)) {
          {
#line 484
          unterminated_comment(c_lineno, c_line, c_cptr);
          }
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 488
  need_newline = 1;
#line 489
  goto loop;
  case_92: /* CIL Label */ 
  case_37: /* CIL Label */ 
#line 493
  if ((int )*cptr == 125) {
#line 495
    if (need_newline) {
      {
#line 496
      _IO_putc('\n', f);
      }
    }
    {
#line 497
    cptr ++;
#line 498
    free((void *)t_line);
    }
#line 499
    return;
  }
  switch_default: /* CIL Label */ 
  {
#line 504
  _IO_putc(c, f);
#line 505
  need_newline = 1;
  }
#line 506
  goto loop;
  switch_break: /* CIL Label */ ;
  }
}
}
#line 510 "/home/june/collector/temp/byacc-20140101/reader.c"
static void puts_both(char const   *s ) 
{ 


  {
  {
#line 513
  fputs((char const   */* __restrict  */)s, (FILE */* __restrict  */)text_file);
  }
#line 514
  if (dflag) {
    {
#line 515
    fputs((char const   */* __restrict  */)s, (FILE */* __restrict  */)union_file);
    }
  }
#line 516
  return;
}
}
#line 518 "/home/june/collector/temp/byacc-20140101/reader.c"
static void putc_both(int c ) 
{ 


  {
  {
#line 521
  _IO_putc(c, text_file);
  }
#line 522
  if (dflag) {
    {
#line 523
    _IO_putc(c, union_file);
    }
  }
#line 524
  return;
}
}
#line 526 "/home/june/collector/temp/byacc-20140101/reader.c"
static void copy_union(void) 
{ 
  int c ;
  int quote ;
  int depth ;
  int u_lineno ;
  char *u_line ;
  char *tmp ;
  char *u_cptr ;
  char *tmp___0 ;
  int s_lineno ;
  char *s_line ;
  char *tmp___1 ;
  char *s_cptr ;
  char *tmp___2 ;
  char *tmp___3 ;
  int c_lineno ;
  char *c_line ;
  char *tmp___4 ;
  char *c_cptr ;
  char *tmp___5 ;

  {
  {
#line 532
  u_lineno = lineno;
#line 533
  tmp = dup_line();
#line 533
  u_line = tmp;
#line 534
  u_cptr = u_line + ((cptr - line) - 6L);
  }
#line 536
  if (unionized) {
    {
#line 537
    over_unionized(cptr - 6);
    }
  }
#line 538
  unionized = (char)1;
#line 540
  if (! lflag) {
    {
#line 541
    fprintf((FILE */* __restrict  */)text_file, (char const   */* __restrict  */)(line_format),
            lineno, input_file_name);
    }
  }
  {
#line 543
  puts_both("#ifdef YYSTYPE\n");
#line 544
  puts_both("#undef  YYSTYPE_IS_DECLARED\n");
#line 545
  puts_both("#define YYSTYPE_IS_DECLARED 1\n");
#line 546
  puts_both("#endif\n");
#line 547
  puts_both("#ifndef YYSTYPE_IS_DECLARED\n");
#line 548
  puts_both("#define YYSTYPE_IS_DECLARED 1\n");
#line 549
  puts_both("typedef union");
#line 551
  depth = 0;
  }
  loop: 
  {
#line 553
  tmp___0 = cptr;
#line 553
  cptr ++;
#line 553
  c = (int )*tmp___0;
#line 554
  putc_both(c);
  }
  {
#line 557
  if (c == 10) {
#line 557
    goto next_line;
  }
#line 564
  if (c == 123) {
#line 564
    goto case_123;
  }
#line 568
  if (c == 125) {
#line 568
    goto case_125;
  }
#line 579
  if (c == 34) {
#line 579
    goto case_34;
  }
#line 579
  if (c == 39) {
#line 579
    goto case_34;
  }
#line 611
  if (c == 47) {
#line 611
    goto case_47;
  }
#line 659
  goto switch_default;
  next_line: 
  case_10: /* CIL Label */ 
  {
#line 559
  get_line();
  }
#line 560
  if ((unsigned long )line == (unsigned long )((char *)0)) {
    {
#line 561
    unterminated_union(u_lineno, u_line, u_cptr);
    }
  }
#line 562
  goto loop;
  case_123: /* CIL Label */ 
#line 565
  depth ++;
#line 566
  goto loop;
  case_125: /* CIL Label */ 
#line 569
  depth --;
#line 569
  if (depth == 0) {
    {
#line 571
    puts_both(" YYSTYPE;\n");
#line 572
    puts_both("#endif /* !YYSTYPE_IS_DECLARED */\n");
#line 573
    free((void *)u_line);
    }
#line 574
    return;
  }
#line 576
  goto loop;
  case_34: /* CIL Label */ 
  case_39: /* CIL Label */ 
  {
#line 581
  s_lineno = lineno;
#line 582
  tmp___1 = dup_line();
#line 582
  s_line = tmp___1;
#line 583
  s_cptr = s_line + ((cptr - line) - 1L);
#line 585
  quote = c;
  }
  {
#line 586
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 588
    tmp___2 = cptr;
#line 588
    cptr ++;
#line 588
    c = (int )*tmp___2;
#line 589
    putc_both(c);
    }
#line 590
    if (c == quote) {
      {
#line 592
      free((void *)s_line);
      }
#line 593
      goto loop;
    }
#line 595
    if (c == 10) {
      {
#line 596
      unterminated_string(s_lineno, s_line, s_cptr);
      }
    }
#line 597
    if (c == 92) {
      {
#line 599
      tmp___3 = cptr;
#line 599
      cptr ++;
#line 599
      c = (int )*tmp___3;
#line 600
      putc_both(c);
      }
#line 601
      if (c == 10) {
        {
#line 603
        get_line();
        }
#line 604
        if ((unsigned long )line == (unsigned long )((char *)0)) {
          {
#line 605
          unterminated_string(s_lineno, s_line, s_cptr);
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  case_47: /* CIL Label */ 
#line 612
  c = (int )*cptr;
#line 613
  if (c == 47) {
    {
#line 615
    putc_both('*');
    }
    {
#line 616
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 616
      cptr ++;
#line 616
      c = (int )*cptr;
#line 616
      if (! (c != 10)) {
#line 616
        goto while_break___0;
      }
#line 618
      if (c == 42) {
#line 618
        if ((int )*(cptr + 1) == 47) {
          {
#line 620
          puts_both("* ");
          }
        } else {
          {
#line 624
          putc_both(c);
          }
        }
      } else {
        {
#line 624
        putc_both(c);
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 627
    puts_both("*/\n");
    }
#line 628
    goto next_line;
  }
#line 630
  if (c == 42) {
    {
#line 632
    c_lineno = lineno;
#line 633
    tmp___4 = dup_line();
#line 633
    c_line = tmp___4;
#line 634
    c_cptr = c_line + ((cptr - line) - 1L);
#line 636
    putc_both('*');
#line 637
    cptr ++;
    }
    {
#line 638
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 640
      tmp___5 = cptr;
#line 640
      cptr ++;
#line 640
      c = (int )*tmp___5;
#line 641
      putc_both(c);
      }
#line 642
      if (c == 42) {
#line 642
        if ((int )*cptr == 47) {
          {
#line 644
          putc_both('/');
#line 645
          cptr ++;
#line 646
          free((void *)c_line);
          }
#line 647
          goto loop;
        }
      }
#line 649
      if (c == 10) {
        {
#line 651
        get_line();
        }
#line 652
        if ((unsigned long )line == (unsigned long )((char *)0)) {
          {
#line 653
          unterminated_comment(c_lineno, c_line, c_cptr);
          }
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 657
  goto loop;
  switch_default: /* CIL Label */ 
#line 660
  goto loop;
  switch_break: /* CIL Label */ ;
  }
}
}
#line 667 "/home/june/collector/temp/byacc-20140101/reader.c"
static void copy_param(int k ) 
{ 
  char *buf ;
  int c ;
  param *head ;
  param *p ;
  int i ;
  int name ;
  int type2 ;
  void *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned short const   **tmp___3 ;
  int level ;
  int tmp___4 ;
  unsigned short const   **tmp___5 ;
  unsigned short const   **tmp___6 ;
  void *tmp___7 ;

  {
  {
#line 676
  c = nextc();
  }
#line 677
  if (c == -1) {
    {
#line 678
    unexpected_EOF();
    }
  }
#line 679
  if (c != 123) {
#line 680
    goto out;
  }
  {
#line 681
  cptr ++;
#line 683
  c = nextc();
  }
#line 684
  if (c == -1) {
    {
#line 685
    unexpected_EOF();
    }
  }
#line 686
  if (c == 125) {
#line 687
    goto out;
  }
  {
#line 689
  tmp = malloc((size_t )linesize * sizeof(char ));
#line 689
  buf = (char *)tmp;
  }
#line 690
  if ((unsigned long )buf == (unsigned long )((char *)0)) {
    {
#line 690
    no_space();
    }
  }
#line 690
  if (! ((unsigned long )buf != (unsigned long )((char *)0))) {
    {
#line 690
    __assert_fail("buf != 0", "/home/june/collector/temp/byacc-20140101/reader.c",
                  690U, "copy_param");
    }
  }
#line 692
  i = 0;
  {
#line 692
  while (1) {
    while_continue: /* CIL Label */ ;
#line 692
    tmp___0 = cptr;
#line 692
    cptr ++;
#line 692
    c = (int )*tmp___0;
#line 692
    if (! (c != 125)) {
#line 692
      goto while_break;
    }
#line 694
    if (c == 0) {
      {
#line 695
      missing_brace();
      }
    }
#line 696
    if (c == -1) {
      {
#line 697
      unexpected_EOF();
      }
    }
#line 698
    *(buf + i) = (char )c;
#line 692
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 701
  if (i == 0) {
#line 702
    goto out;
  }
#line 704
  tmp___1 = i;
#line 704
  i --;
#line 704
  *(buf + tmp___1) = (char )'\000';
  {
#line 705
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 705
    if (i > 0) {
      {
#line 705
      tmp___3 = __ctype_b_loc();
      }
#line 705
      if (! ((int const   )*(*tmp___3 + (int )((unsigned char )*(buf + i))) & 8192)) {
#line 705
        goto while_break___0;
      }
    } else {
#line 705
      goto while_break___0;
    }
#line 706
    tmp___2 = i;
#line 706
    i --;
#line 706
    *(buf + tmp___2) = (char )'\000';
  }
  while_break___0: /* CIL Label */ ;
  }
#line 708
  if ((int )*(buf + i) == 93) {
#line 710
    level = 1;
    {
#line 711
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 711
      if (i >= 0) {
#line 711
        if (level > 0) {
#line 711
          if (! ((int )*(buf + i) != 91)) {
#line 711
            goto while_break___1;
          }
        } else {
#line 711
          goto while_break___1;
        }
      } else {
#line 711
        goto while_break___1;
      }
#line 713
      if ((int )*(buf + i) == 93) {
#line 714
        level ++;
      } else
#line 715
      if ((int )*(buf + i) == 91) {
#line 716
        level --;
      }
#line 717
      i --;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 719
    if (i <= 0) {
      {
#line 720
      unexpected_EOF();
      }
    }
#line 721
    tmp___4 = i;
#line 721
    i --;
#line 721
    type2 = tmp___4;
  } else {
#line 725
    type2 = i + 1;
  }
  {
#line 728
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 728
    if (i > 0) {
      {
#line 728
      tmp___5 = __ctype_b_loc();
      }
#line 728
      if (! ((int const   )*(*tmp___5 + (int )((unsigned char )*(buf + i))) & 8)) {
#line 728
        if (! ((int )((unsigned char )*(buf + i)) == 95)) {
#line 728
          goto while_break___2;
        }
      }
    } else {
#line 728
      goto while_break___2;
    }
#line 730
    i --;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 732
  tmp___6 = __ctype_b_loc();
  }
#line 732
  if (! ((int const   )*(*tmp___6 + (int )((unsigned char )*(buf + i))) & 8192)) {
#line 732
    if ((int )*(buf + i) != 42) {
#line 733
      goto out;
    }
  }
  {
#line 735
  name = i + 1;
#line 737
  tmp___7 = malloc(sizeof(param ));
#line 737
  p = (param *)tmp___7;
  }
#line 738
  if ((unsigned long )p == (unsigned long )((param *)0)) {
    {
#line 738
    no_space();
    }
  }
#line 738
  if (! ((unsigned long )p != (unsigned long )((param *)0))) {
    {
#line 738
    __assert_fail("p != 0", "/home/june/collector/temp/byacc-20140101/reader.c", 738U,
                  "copy_param");
    }
  }
  {
#line 740
  p->type2 = strdup((char const   *)(buf + type2));
  }
#line 741
  if ((unsigned long )p->type2 == (unsigned long )((char *)0)) {
    {
#line 741
    no_space();
    }
  }
#line 741
  if (! ((unsigned long )p->type2 != (unsigned long )((char *)0))) {
    {
#line 741
    __assert_fail("p->type2 != 0", "/home/june/collector/temp/byacc-20140101/reader.c",
                  741U, "copy_param");
    }
  }
  {
#line 743
  *(buf + type2) = (char )'\000';
#line 745
  p->name = strdup((char const   *)(buf + name));
  }
#line 746
  if ((unsigned long )p->name == (unsigned long )((char *)0)) {
    {
#line 746
    no_space();
    }
  }
#line 746
  if (! ((unsigned long )p->name != (unsigned long )((char *)0))) {
    {
#line 746
    __assert_fail("p->name != 0", "/home/june/collector/temp/byacc-20140101/reader.c",
                  746U, "copy_param");
    }
  }
#line 748
  *(buf + name) = (char )'\000';
#line 749
  p->type = buf;
#line 751
  if (k == 14) {
#line 752
    head = lex_param;
  } else {
#line 754
    head = parse_param;
  }
#line 756
  if ((unsigned long )head != (unsigned long )((void *)0)) {
    {
#line 758
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 758
      if (! head->next) {
#line 758
        goto while_break___3;
      }
#line 759
      head = head->next;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 760
    head->next = p;
  } else
#line 764
  if (k == 14) {
#line 765
    lex_param = p;
  } else {
#line 767
    parse_param = p;
  }
#line 769
  p->next = (struct param *)((void *)0);
#line 770
  return;
  out: 
  {
#line 773
  syntax_error(lineno, line, cptr);
  }
#line 774
  return;
}
}
#line 776 "/home/june/collector/temp/byacc-20140101/reader.c"
static int hexval(int c ) 
{ 


  {
#line 779
  if (c >= 48) {
#line 779
    if (c <= 57) {
#line 780
      return (c - 48);
    }
  }
#line 781
  if (c >= 65) {
#line 781
    if (c <= 70) {
#line 782
      return ((c - 65) + 10);
    }
  }
#line 783
  if (c >= 97) {
#line 783
    if (c <= 102) {
#line 784
      return ((c - 97) + 10);
    }
  }
#line 785
  return (-1);
}
}
#line 788 "/home/june/collector/temp/byacc-20140101/reader.c"
static bucket *get_literal(void) 
{ 
  int c ;
  int quote ;
  int i ;
  int n ;
  char *s ;
  bucket *bp ;
  int s_lineno ;
  char *s_line ;
  char *tmp ;
  char *s_cptr ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *c_cptr ;
  char *tmp___2 ;
  char *tmp___3 ;
  void *tmp___4 ;
  unsigned short const   **tmp___5 ;

  {
  {
#line 796
  s_lineno = lineno;
#line 797
  tmp = dup_line();
#line 797
  s_line = tmp;
#line 798
  s_cptr = s_line + (cptr - line);
#line 800
  tmp___0 = cptr;
#line 800
  cptr ++;
#line 800
  quote = (int )*tmp___0;
#line 801
  cinc = 0;
  }
  {
#line 802
  while (1) {
    while_continue: /* CIL Label */ ;
#line 804
    tmp___1 = cptr;
#line 804
    cptr ++;
#line 804
    c = (int )*tmp___1;
#line 805
    if (c == quote) {
#line 806
      goto while_break;
    }
#line 807
    if (c == 10) {
      {
#line 808
      unterminated_string(s_lineno, s_line, s_cptr);
      }
    }
#line 809
    if (c == 92) {
#line 811
      c_cptr = cptr - 1;
#line 813
      tmp___2 = cptr;
#line 813
      cptr ++;
#line 813
      c = (int )*tmp___2;
      {
#line 816
      if (c == 10) {
#line 816
        goto case_10;
      }
#line 829
      if (c == 55) {
#line 829
        goto case_55;
      }
#line 829
      if (c == 54) {
#line 829
        goto case_55;
      }
#line 829
      if (c == 53) {
#line 829
        goto case_55;
      }
#line 829
      if (c == 52) {
#line 829
        goto case_55;
      }
#line 829
      if (c == 51) {
#line 829
        goto case_55;
      }
#line 829
      if (c == 50) {
#line 829
        goto case_55;
      }
#line 829
      if (c == 49) {
#line 829
        goto case_55;
      }
#line 829
      if (c == 48) {
#line 829
        goto case_55;
      }
#line 847
      if (c == 120) {
#line 847
        goto case_120;
      }
#line 866
      if (c == 97) {
#line 866
        goto case_97;
      }
#line 869
      if (c == 98) {
#line 869
        goto case_98;
      }
#line 872
      if (c == 102) {
#line 872
        goto case_102;
      }
#line 875
      if (c == 110) {
#line 875
        goto case_110;
      }
#line 878
      if (c == 114) {
#line 878
        goto case_114;
      }
#line 881
      if (c == 116) {
#line 881
        goto case_116;
      }
#line 884
      if (c == 118) {
#line 884
        goto case_118;
      }
#line 814
      goto switch_break;
      case_10: /* CIL Label */ 
      {
#line 817
      get_line();
      }
#line 818
      if ((unsigned long )line == (unsigned long )((char *)0)) {
        {
#line 819
        unterminated_string(s_lineno, s_line, s_cptr);
        }
      }
#line 820
      goto __Cont;
      case_55: /* CIL Label */ 
      case_54: /* CIL Label */ 
      case_53: /* CIL Label */ 
      case_52: /* CIL Label */ 
      case_51: /* CIL Label */ 
      case_50: /* CIL Label */ 
      case_49: /* CIL Label */ 
      case_48: /* CIL Label */ 
#line 830
      n = c - 48;
#line 831
      c = (int )*cptr;
#line 832
      if (c >= 48) {
#line 832
        if (c <= 55) {
#line 834
          n = (n << 3) + (c - 48);
#line 835
          cptr ++;
#line 835
          c = (int )*cptr;
#line 836
          if (c >= 48) {
#line 836
            if (c <= 55) {
#line 838
              n = (n << 3) + (c - 48);
#line 839
              cptr ++;
            }
          }
        }
      }
#line 842
      if (n > 255) {
        {
#line 843
        illegal_character(c_cptr);
        }
      }
#line 844
      c = n;
#line 845
      goto switch_break;
      case_120: /* CIL Label */ 
      {
#line 848
      tmp___3 = cptr;
#line 848
      cptr ++;
#line 848
      c = (int )*tmp___3;
#line 849
      n = hexval(c);
      }
#line 850
      if (n < 0) {
        {
#line 851
        illegal_character(c_cptr);
        }
      } else
#line 850
      if (n >= 16) {
        {
#line 851
        illegal_character(c_cptr);
        }
      }
      {
#line 852
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 854
        c = (int )*cptr;
#line 855
        i = hexval(c);
        }
#line 856
        if (i < 0) {
#line 857
          goto while_break___0;
        } else
#line 856
        if (i >= 16) {
#line 857
          goto while_break___0;
        }
#line 858
        cptr ++;
#line 859
        n = (n << 4) + i;
#line 860
        if (n > 255) {
          {
#line 861
          illegal_character(c_cptr);
          }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 863
      c = n;
#line 864
      goto switch_break;
      case_97: /* CIL Label */ 
#line 867
      c = 7;
#line 868
      goto switch_break;
      case_98: /* CIL Label */ 
#line 870
      c = '\b';
#line 871
      goto switch_break;
      case_102: /* CIL Label */ 
#line 873
      c = '\f';
#line 874
      goto switch_break;
      case_110: /* CIL Label */ 
#line 876
      c = '\n';
#line 877
      goto switch_break;
      case_114: /* CIL Label */ 
#line 879
      c = '\r';
#line 880
      goto switch_break;
      case_116: /* CIL Label */ 
#line 882
      c = '\t';
#line 883
      goto switch_break;
      case_118: /* CIL Label */ 
#line 885
      c = '\v';
#line 886
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
    {
#line 889
    cachec(c);
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 891
  free((void *)s_line);
#line 893
  n = cinc;
#line 894
  tmp___4 = malloc((size_t )n * sizeof(char ));
#line 894
  s = (char *)tmp___4;
  }
#line 895
  if ((unsigned long )s == (unsigned long )((char *)0)) {
    {
#line 895
    no_space();
    }
  }
#line 895
  if (! ((unsigned long )s != (unsigned long )((char *)0))) {
    {
#line 895
    __assert_fail("s != 0", "/home/june/collector/temp/byacc-20140101/reader.c", 895U,
                  "get_literal");
    }
  }
#line 897
  i = 0;
  {
#line 897
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 897
    if (! (i < n)) {
#line 897
      goto while_break___1;
    }
#line 898
    *(s + i) = *(cache + i);
#line 897
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 900
  cinc = 0;
#line 901
  if (n == 1) {
    {
#line 902
    cachec('\'');
    }
  } else {
    {
#line 904
    cachec('\"');
    }
  }
#line 906
  i = 0;
  {
#line 906
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 906
    if (! (i < n)) {
#line 906
      goto while_break___2;
    }
#line 908
    c = (int )((unsigned char )*(s + i));
#line 909
    if (c == 92) {
      {
#line 911
      cachec('\\');
#line 912
      cachec(c);
      }
    } else
#line 909
    if (c == (int )*(cache + 0)) {
      {
#line 911
      cachec('\\');
#line 912
      cachec(c);
      }
    } else {
      {
#line 914
      tmp___5 = __ctype_b_loc();
      }
#line 914
      if ((int const   )*(*tmp___5 + c) & 16384) {
        {
#line 915
        cachec(c);
        }
      } else {
        {
#line 918
        cachec('\\');
        }
        {
#line 921
        if (c == 7) {
#line 921
          goto case_7;
        }
#line 924
        if (c == 8) {
#line 924
          goto case_8;
        }
#line 927
        if (c == 12) {
#line 927
          goto case_12;
        }
#line 930
        if (c == 10) {
#line 930
          goto case_10___0;
        }
#line 933
        if (c == 13) {
#line 933
          goto case_13;
        }
#line 936
        if (c == 9) {
#line 936
          goto case_9;
        }
#line 939
        if (c == 11) {
#line 939
          goto case_11;
        }
#line 942
        goto switch_default;
        case_7: /* CIL Label */ 
        {
#line 922
        cachec('a');
        }
#line 923
        goto switch_break___0;
        case_8: /* CIL Label */ 
        {
#line 925
        cachec('b');
        }
#line 926
        goto switch_break___0;
        case_12: /* CIL Label */ 
        {
#line 928
        cachec('f');
        }
#line 929
        goto switch_break___0;
        case_10___0: /* CIL Label */ 
        {
#line 931
        cachec('n');
        }
#line 932
        goto switch_break___0;
        case_13: /* CIL Label */ 
        {
#line 934
        cachec('r');
        }
#line 935
        goto switch_break___0;
        case_9: /* CIL Label */ 
        {
#line 937
        cachec('t');
        }
#line 938
        goto switch_break___0;
        case_11: /* CIL Label */ 
        {
#line 940
        cachec('v');
        }
#line 941
        goto switch_break___0;
        switch_default: /* CIL Label */ 
        {
#line 943
        cachec(((c >> 6) & 7) + 48);
#line 944
        cachec(((c >> 3) & 7) + 48);
#line 945
        cachec((c & 7) + 48);
        }
#line 946
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
      }
    }
#line 906
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 951
  if (n == 1) {
    {
#line 952
    cachec('\'');
    }
  } else {
    {
#line 954
    cachec('\"');
    }
  }
  {
#line 956
  cachec('\000');
#line 957
  bp = lookup((char const   *)cache);
#line 958
  bp->class = (Class_t )1;
  }
#line 959
  if (n == 1) {
#line 959
    if ((int )bp->value == -1) {
#line 960
      bp->value = (Value_t )((unsigned char )*s);
    }
  }
  {
#line 961
  free((void *)s);
  }
#line 963
  return (bp);
}
}
#line 966 "/home/june/collector/temp/byacc-20140101/reader.c"
static int is_reserved(char *name ) 
{ 
  char *s ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;

  {
  {
#line 971
  tmp = strcmp((char const   *)name, ".");
  }
#line 971
  if (tmp == 0) {
#line 974
    return (1);
  } else {
    {
#line 971
    tmp___0 = strcmp((char const   *)name, "$accept");
    }
#line 971
    if (tmp___0 == 0) {
#line 974
      return (1);
    } else {
      {
#line 971
      tmp___1 = strcmp((char const   *)name, "$end");
      }
#line 971
      if (tmp___1 == 0) {
#line 974
        return (1);
      }
    }
  }
#line 976
  if ((int )*(name + 0) == 36) {
#line 976
    if ((int )*(name + 1) == 36) {
      {
#line 976
      tmp___3 = __ctype_b_loc();
      }
#line 976
      if ((int const   )*(*tmp___3 + (int )((unsigned char )*(name + 2))) & 2048) {
#line 978
        s = name + 3;
        {
#line 979
        while (1) {
          while_continue: /* CIL Label */ ;
          {
#line 979
          tmp___2 = __ctype_b_loc();
          }
#line 979
          if (! ((int const   )*(*tmp___2 + (int )((unsigned char )*s)) & 2048)) {
#line 979
            goto while_break;
          }
#line 980
          s ++;
        }
        while_break: /* CIL Label */ ;
        }
#line 981
        if ((int )*s == 0) {
#line 982
          return (1);
        }
      }
    }
  }
#line 985
  return (0);
}
}
#line 988 "/home/june/collector/temp/byacc-20140101/reader.c"
static bucket *get_name(void) 
{ 
  int c ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  bucket *tmp___1 ;

  {
#line 993
  cinc = 0;
#line 994
  c = (int )*cptr;
  {
#line 994
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 994
    tmp = __ctype_b_loc();
    }
#line 994
    if (! ((int const   )*(*tmp + c) & 8)) {
#line 994
      if (! (c == 95)) {
#line 994
        if (! (c == 46)) {
#line 994
          if (! (c == 36)) {
#line 994
            goto while_break;
          }
        }
      }
    }
    {
#line 995
    cachec(c);
#line 994
    cptr ++;
#line 994
    c = (int )*cptr;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 996
  cachec('\000');
#line 998
  tmp___0 = is_reserved(cache);
  }
#line 998
  if (tmp___0) {
    {
#line 999
    used_reserved(cache);
    }
  }
  {
#line 1001
  tmp___1 = lookup((char const   *)cache);
  }
#line 1001
  return (tmp___1);
}
}
#line 1004 "/home/june/collector/temp/byacc-20140101/reader.c"
static Value_t get_number(void) 
{ 
  int c ;
  Value_t n ;
  unsigned short const   **tmp ;

  {
#line 1010
  n = (Value_t )0;
#line 1011
  c = (int )*cptr;
  {
#line 1011
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1011
    tmp = __ctype_b_loc();
    }
#line 1011
    if (! ((int const   )*(*tmp + c) & 2048)) {
#line 1011
      goto while_break;
    }
#line 1012
    n = (Value_t )(10 * (int )n + (c - 48));
#line 1011
    cptr ++;
#line 1011
    c = (int )*cptr;
  }
  while_break: /* CIL Label */ ;
  }
#line 1014
  return (n);
}
}
#line 1017 "/home/june/collector/temp/byacc-20140101/reader.c"
static char *get_tag(void) 
{ 
  int c ;
  int i ;
  char *s ;
  int t_lineno ;
  char *t_line ;
  char *tmp ;
  char *t_cptr ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;

  {
  {
#line 1023
  t_lineno = lineno;
#line 1024
  tmp = dup_line();
#line 1024
  t_line = tmp;
#line 1025
  t_cptr = t_line + (cptr - line);
#line 1027
  cptr ++;
#line 1028
  c = nextc();
  }
#line 1029
  if (c == -1) {
    {
#line 1030
    unexpected_EOF();
    }
  }
  {
#line 1031
  tmp___0 = __ctype_b_loc();
  }
#line 1031
  if (! ((int const   )*(*tmp___0 + c) & 1024)) {
#line 1031
    if (c != 95) {
#line 1031
      if (c != 36) {
        {
#line 1032
        illegal_tag(t_lineno, t_line, t_cptr);
        }
      }
    }
  }
#line 1034
  cinc = 0;
  {
#line 1035
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1037
    cachec(c);
#line 1038
    cptr ++;
#line 1038
    c = (int )*cptr;
#line 1035
    tmp___1 = __ctype_b_loc();
    }
#line 1035
    if (! ((int const   )*(*tmp___1 + c) & 8)) {
#line 1035
      if (! (c == 95)) {
#line 1035
        if (! (c == 46)) {
#line 1035
          if (! (c == 36)) {
#line 1035
            goto while_break;
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1041
  cachec('\000');
#line 1043
  c = nextc();
  }
#line 1044
  if (c == -1) {
    {
#line 1045
    unexpected_EOF();
    }
  }
#line 1046
  if (c != 62) {
    {
#line 1047
    illegal_tag(t_lineno, t_line, t_cptr);
    }
  }
#line 1048
  cptr ++;
#line 1050
  i = 0;
  {
#line 1050
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1050
    if (! (i < ntags)) {
#line 1050
      goto while_break___0;
    }
    {
#line 1052
    tmp___2 = strcmp((char const   *)cache, (char const   *)*(tag_table + i));
    }
#line 1052
    if (tmp___2 == 0) {
      {
#line 1054
      free((void *)t_line);
      }
#line 1055
      return (*(tag_table + i));
    }
#line 1050
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1059
  if (ntags >= tagmax) {
#line 1061
    tagmax += 16;
#line 1062
    if (tag_table) {
      {
#line 1062
      tmp___3 = realloc((void *)((char *)tag_table), (size_t )tagmax * sizeof(char *));
#line 1062
      tag_table = (char **)tmp___3;
      }
    } else {
      {
#line 1062
      tmp___4 = malloc((size_t )tagmax * sizeof(char *));
#line 1062
      tag_table = (char **)tmp___4;
      }
    }
#line 1066
    if ((unsigned long )tag_table == (unsigned long )((char **)0)) {
      {
#line 1066
      no_space();
      }
    }
#line 1066
    if (! ((unsigned long )tag_table != (unsigned long )((char **)0))) {
      {
#line 1066
      __assert_fail("tag_table != 0", "/home/june/collector/temp/byacc-20140101/reader.c",
                    1066U, "get_tag");
      }
    }
  }
  {
#line 1069
  tmp___5 = malloc((size_t )cinc * sizeof(char ));
#line 1069
  s = (char *)tmp___5;
  }
#line 1070
  if ((unsigned long )s == (unsigned long )((char *)0)) {
    {
#line 1070
    no_space();
    }
  }
#line 1070
  if (! ((unsigned long )s != (unsigned long )((char *)0))) {
    {
#line 1070
    __assert_fail("s != 0", "/home/june/collector/temp/byacc-20140101/reader.c", 1070U,
                  "get_tag");
    }
  }
  {
#line 1072
  strcpy((char */* __restrict  */)s, (char const   */* __restrict  */)cache);
#line 1073
  *(tag_table + ntags) = s;
#line 1074
  ntags ++;
#line 1075
  free((void *)t_line);
  }
#line 1076
  return (s);
}
}
#line 1079 "/home/june/collector/temp/byacc-20140101/reader.c"
static void declare_tokens(int assoc ) 
{ 
  int c ;
  bucket *bp ;
  Value_t value ;
  char *tag ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;

  {
#line 1085
  tag = (char *)0;
#line 1087
  if (assoc != 0) {
#line 1088
    prec = (Value_t )((int )prec + 1);
  }
  {
#line 1090
  c = nextc();
  }
#line 1091
  if (c == -1) {
    {
#line 1092
    unexpected_EOF();
    }
  }
#line 1093
  if (c == 60) {
    {
#line 1095
    tag = get_tag();
#line 1096
    c = nextc();
    }
#line 1097
    if (c == -1) {
      {
#line 1098
      unexpected_EOF();
      }
    }
  }
  {
#line 1101
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1103
    tmp = __ctype_b_loc();
    }
#line 1103
    if ((int const   )*(*tmp + c) & 1024) {
      {
#line 1104
      bp = get_name();
      }
    } else
#line 1103
    if (c == 95) {
      {
#line 1104
      bp = get_name();
      }
    } else
#line 1103
    if (c == 46) {
      {
#line 1104
      bp = get_name();
      }
    } else
#line 1103
    if (c == 36) {
      {
#line 1104
      bp = get_name();
      }
    } else
#line 1105
    if (c == 39) {
      {
#line 1106
      bp = get_literal();
      }
    } else
#line 1105
    if (c == 34) {
      {
#line 1106
      bp = get_literal();
      }
    } else {
#line 1108
      return;
    }
#line 1110
    if ((unsigned long )bp == (unsigned long )goal) {
      {
#line 1111
      tokenized_start(bp->name);
      }
    }
#line 1112
    bp->class = (Class_t )1;
#line 1114
    if (tag) {
#line 1116
      if (bp->tag) {
#line 1116
        if ((unsigned long )tag != (unsigned long )bp->tag) {
          {
#line 1117
          retyped_warning(bp->name);
          }
        }
      }
#line 1118
      bp->tag = tag;
    }
#line 1121
    if (assoc != 0) {
#line 1123
      if (bp->prec) {
#line 1123
        if ((int )prec != (int )bp->prec) {
          {
#line 1124
          reprec_warning(bp->name);
          }
        }
      }
#line 1125
      bp->assoc = (Assoc_t )assoc;
#line 1126
      bp->prec = prec;
    }
    {
#line 1129
    c = nextc();
    }
#line 1130
    if (c == -1) {
      {
#line 1131
      unexpected_EOF();
      }
    }
    {
#line 1133
    tmp___0 = __ctype_b_loc();
    }
#line 1133
    if ((int const   )*(*tmp___0 + c) & 2048) {
      {
#line 1135
      value = get_number();
      }
#line 1136
      if ((int )bp->value != -1) {
#line 1136
        if ((int )value != (int )bp->value) {
          {
#line 1137
          revalued_warning(bp->name);
          }
        }
      }
      {
#line 1138
      bp->value = value;
#line 1139
      c = nextc();
      }
#line 1140
      if (c == -1) {
        {
#line 1141
        unexpected_EOF();
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1151 "/home/june/collector/temp/byacc-20140101/reader.c"
static void declare_expect(int assoc ) 
{ 
  int c ;
  Value_t tmp ;
  Value_t tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;

  {
#line 1156
  if (assoc != 10) {
#line 1156
    if (assoc != 11) {
#line 1157
      prec = (Value_t )((int )prec + 1);
    }
  }
#line 1163
  cptr ++;
#line 1163
  c = (int )*cptr;
#line 1164
  if (c == -1) {
    {
#line 1165
    unexpected_EOF();
    }
  }
  {
#line 1167
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1169
    tmp___3 = __ctype_b_loc();
    }
#line 1169
    if ((int const   )*(*tmp___3 + c) & 2048) {
#line 1171
      if (assoc == 10) {
        {
#line 1172
        tmp = get_number();
#line 1172
        SRexpect = (int )tmp;
        }
      } else {
        {
#line 1174
        tmp___0 = get_number();
#line 1174
        RRexpect = (int )tmp___0;
        }
      }
#line 1175
      goto while_break;
    } else
#line 1182
    if (c == 10) {
      {
#line 1184
      syntax_error(lineno, line, cptr);
      }
    } else {
      {
#line 1182
      tmp___1 = __ctype_b_loc();
      }
#line 1182
      if ((int const   )*(*tmp___1 + c) & 1024) {
        {
#line 1184
        syntax_error(lineno, line, cptr);
        }
      } else {
        {
#line 1182
        tmp___2 = __ctype_b_loc();
        }
#line 1182
        if ((int const   )*(*tmp___2 + c) & 8192) {
#line 1188
          cptr ++;
#line 1188
          c = (int )*cptr;
#line 1189
          if (c == -1) {
            {
#line 1190
            unexpected_EOF();
            }
          }
        } else {
          {
#line 1184
          syntax_error(lineno, line, cptr);
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1193
  return;
}
}
#line 1195 "/home/june/collector/temp/byacc-20140101/reader.c"
static void declare_types(void) 
{ 
  int c ;
  bucket *bp ;
  char *tag ;
  unsigned short const   **tmp ;

  {
  {
#line 1202
  c = nextc();
  }
#line 1203
  if (c == -1) {
    {
#line 1204
    unexpected_EOF();
    }
  }
#line 1205
  if (c != 60) {
    {
#line 1206
    syntax_error(lineno, line, cptr);
    }
  }
  {
#line 1207
  tag = get_tag();
  }
  {
#line 1209
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1211
    c = nextc();
#line 1212
    tmp = __ctype_b_loc();
    }
#line 1212
    if ((int const   )*(*tmp + c) & 1024) {
      {
#line 1213
      bp = get_name();
      }
    } else
#line 1212
    if (c == 95) {
      {
#line 1213
      bp = get_name();
      }
    } else
#line 1212
    if (c == 46) {
      {
#line 1213
      bp = get_name();
      }
    } else
#line 1212
    if (c == 36) {
      {
#line 1213
      bp = get_name();
      }
    } else
#line 1214
    if (c == 39) {
      {
#line 1215
      bp = get_literal();
      }
    } else
#line 1214
    if (c == 34) {
      {
#line 1215
      bp = get_literal();
      }
    } else {
#line 1217
      return;
    }
#line 1219
    if (bp->tag) {
#line 1219
      if ((unsigned long )tag != (unsigned long )bp->tag) {
        {
#line 1220
        retyped_warning(bp->name);
        }
      }
    }
#line 1221
    bp->tag = tag;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1225 "/home/june/collector/temp/byacc-20140101/reader.c"
static void declare_start(void) 
{ 
  int c ;
  bucket *bp ;
  unsigned short const   **tmp ;

  {
  {
#line 1231
  c = nextc();
  }
#line 1232
  if (c == -1) {
    {
#line 1233
    unexpected_EOF();
    }
  }
  {
#line 1234
  tmp = __ctype_b_loc();
  }
#line 1234
  if (! ((int const   )*(*tmp + c) & 1024)) {
#line 1234
    if (c != 95) {
#line 1234
      if (c != 46) {
#line 1234
        if (c != 36) {
          {
#line 1235
          syntax_error(lineno, line, cptr);
          }
        }
      }
    }
  }
  {
#line 1236
  bp = get_name();
  }
#line 1237
  if ((int )bp->class == 1) {
    {
#line 1238
    terminal_start(bp->name);
    }
  }
#line 1239
  if (goal) {
#line 1239
    if ((unsigned long )goal != (unsigned long )bp) {
      {
#line 1240
      restarted_warning();
      }
    }
  }
#line 1241
  goal = bp;
#line 1242
  return;
}
}
#line 1244 "/home/june/collector/temp/byacc-20140101/reader.c"
static void read_declarations(void) 
{ 
  int c ;
  int k ;
  void *tmp ;

  {
  {
#line 1249
  cache_size = 256;
#line 1250
  tmp = malloc((size_t )cache_size * sizeof(char ));
#line 1250
  cache = (char *)tmp;
  }
#line 1251
  if ((unsigned long )cache == (unsigned long )((char *)0)) {
    {
#line 1251
    no_space();
    }
  }
#line 1251
  if (! ((unsigned long )cache != (unsigned long )((char *)0))) {
    {
#line 1251
    __assert_fail("cache != 0", "/home/june/collector/temp/byacc-20140101/reader.c",
                  1251U, "read_declarations");
    }
  }
  {
#line 1253
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1255
    c = nextc();
    }
#line 1256
    if (c == -1) {
      {
#line 1257
      unexpected_EOF();
      }
    }
#line 1258
    if (c != 37) {
      {
#line 1259
      syntax_error(lineno, line, cptr);
      }
    }
    {
#line 1260
    k = keyword();
    }
    {
#line 1262
    if (k == 4) {
#line 1262
      goto case_4;
    }
#line 1265
    if (k == 9) {
#line 1265
      goto case_9;
    }
#line 1269
    if (k == 5) {
#line 1269
      goto case_5;
    }
#line 1273
    if (k == 8) {
#line 1273
      goto case_8;
    }
#line 1280
    if (k == 3) {
#line 1280
      goto case_3;
    }
#line 1280
    if (k == 2) {
#line 1280
      goto case_3;
    }
#line 1280
    if (k == 1) {
#line 1280
      goto case_3;
    }
#line 1280
    if (k == 0) {
#line 1280
      goto case_3;
    }
#line 1285
    if (k == 11) {
#line 1285
      goto case_11;
    }
#line 1285
    if (k == 10) {
#line 1285
      goto case_11;
    }
#line 1289
    if (k == 6) {
#line 1289
      goto case_6;
    }
#line 1293
    if (k == 7) {
#line 1293
      goto case_7;
    }
#line 1297
    if (k == 12) {
#line 1297
      goto case_12;
    }
#line 1302
    if (k == 14) {
#line 1302
      goto case_14;
    }
#line 1302
    if (k == 13) {
#line 1302
      goto case_14;
    }
#line 1306
    if (k == 16) {
#line 1306
      goto case_16;
    }
#line 1310
    if (k == 15) {
#line 1310
      goto case_15;
    }
#line 1260
    goto switch_break;
    case_4: /* CIL Label */ 
#line 1263
    return;
    case_9: /* CIL Label */ 
    {
#line 1266
    copy_ident();
    }
#line 1267
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 1270
    copy_text();
    }
#line 1271
    goto switch_break;
    case_8: /* CIL Label */ 
    {
#line 1274
    copy_union();
    }
#line 1275
    goto switch_break;
    case_3: /* CIL Label */ 
    case_2: /* CIL Label */ 
    case_1: /* CIL Label */ 
    case_0: /* CIL Label */ 
    {
#line 1281
    declare_tokens(k);
    }
#line 1282
    goto switch_break;
    case_11: /* CIL Label */ 
    case_10: /* CIL Label */ 
    {
#line 1286
    declare_expect(k);
    }
#line 1287
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 1290
    declare_types();
    }
#line 1291
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 1294
    declare_start();
    }
#line 1295
    goto switch_break;
    case_12: /* CIL Label */ 
#line 1298
    pure_parser = 1;
#line 1299
    goto switch_break;
    case_14: /* CIL Label */ 
    case_13: /* CIL Label */ 
    {
#line 1303
    copy_param(k);
    }
#line 1304
    goto switch_break;
    case_16: /* CIL Label */ 
#line 1307
    token_table = 1;
#line 1308
    goto switch_break;
    case_15: /* CIL Label */ 
#line 1313
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1318 "/home/june/collector/temp/byacc-20140101/reader.c"
static void initialize_grammar(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 1321
  nitems = 4;
#line 1322
  maxitems = 300;
#line 1324
  tmp = malloc((size_t )maxitems * sizeof(bucket *));
#line 1324
  pitem = (bucket **)tmp;
  }
#line 1325
  if ((unsigned long )pitem == (unsigned long )((bucket **)0)) {
    {
#line 1325
    no_space();
    }
  }
#line 1325
  if (! ((unsigned long )pitem != (unsigned long )((bucket **)0))) {
    {
#line 1325
    __assert_fail("pitem != 0", "/home/june/collector/temp/byacc-20140101/reader.c",
                  1325U, "initialize_grammar");
    }
  }
  {
#line 1327
  *(pitem + 0) = (bucket *)0;
#line 1328
  *(pitem + 1) = (bucket *)0;
#line 1329
  *(pitem + 2) = (bucket *)0;
#line 1330
  *(pitem + 3) = (bucket *)0;
#line 1332
  nrules = 3;
#line 1333
  maxrules = 100;
#line 1335
  tmp___0 = malloc((size_t )maxrules * sizeof(bucket *));
#line 1335
  plhs = (bucket **)tmp___0;
  }
#line 1336
  if ((unsigned long )plhs == (unsigned long )((bucket **)0)) {
    {
#line 1336
    no_space();
    }
  }
#line 1336
  if (! ((unsigned long )plhs != (unsigned long )((bucket **)0))) {
    {
#line 1336
    __assert_fail("plhs != 0", "/home/june/collector/temp/byacc-20140101/reader.c",
                  1336U, "initialize_grammar");
    }
  }
  {
#line 1338
  *(plhs + 0) = (bucket *)0;
#line 1339
  *(plhs + 1) = (bucket *)0;
#line 1340
  *(plhs + 2) = (bucket *)0;
#line 1342
  tmp___1 = malloc((size_t )maxrules * sizeof(Value_t ));
#line 1342
  rprec = (Value_t *)tmp___1;
  }
#line 1343
  if ((unsigned long )rprec == (unsigned long )((Value_t *)0)) {
    {
#line 1343
    no_space();
    }
  }
#line 1343
  if (! ((unsigned long )rprec != (unsigned long )((Value_t *)0))) {
    {
#line 1343
    __assert_fail("rprec != 0", "/home/june/collector/temp/byacc-20140101/reader.c",
                  1343U, "initialize_grammar");
    }
  }
  {
#line 1345
  *(rprec + 0) = (Value_t )0;
#line 1346
  *(rprec + 1) = (Value_t )0;
#line 1347
  *(rprec + 2) = (Value_t )0;
#line 1349
  tmp___2 = malloc((size_t )maxrules * sizeof(Assoc_t ));
#line 1349
  rassoc = (Assoc_t *)tmp___2;
  }
#line 1350
  if ((unsigned long )rassoc == (unsigned long )((Assoc_t *)0)) {
    {
#line 1350
    no_space();
    }
  }
#line 1350
  if (! ((unsigned long )rassoc != (unsigned long )((Assoc_t *)0))) {
    {
#line 1350
    __assert_fail("rassoc != 0", "/home/june/collector/temp/byacc-20140101/reader.c",
                  1350U, "initialize_grammar");
    }
  }
#line 1352
  *(rassoc + 0) = (Assoc_t )0;
#line 1353
  *(rassoc + 1) = (Assoc_t )0;
#line 1354
  *(rassoc + 2) = (Assoc_t )0;
#line 1355
  return;
}
}
#line 1357 "/home/june/collector/temp/byacc-20140101/reader.c"
static void expand_items(void) 
{ 
  void *tmp ;

  {
  {
#line 1360
  maxitems += 300;
#line 1361
  tmp = realloc((void *)((char *)pitem), (size_t )maxitems * sizeof(bucket *));
#line 1361
  pitem = (bucket **)tmp;
  }
#line 1362
  if ((unsigned long )pitem == (unsigned long )((bucket **)0)) {
    {
#line 1362
    no_space();
    }
  }
#line 1362
  if (! ((unsigned long )pitem != (unsigned long )((bucket **)0))) {
    {
#line 1362
    __assert_fail("pitem != 0", "/home/june/collector/temp/byacc-20140101/reader.c",
                  1362U, "expand_items");
    }
  }
#line 1363
  return;
}
}
#line 1365 "/home/june/collector/temp/byacc-20140101/reader.c"
static void expand_rules(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 1368
  maxrules += 100;
#line 1370
  tmp = realloc((void *)((char *)plhs), (size_t )maxrules * sizeof(bucket *));
#line 1370
  plhs = (bucket **)tmp;
  }
#line 1371
  if ((unsigned long )plhs == (unsigned long )((bucket **)0)) {
    {
#line 1371
    no_space();
    }
  }
#line 1371
  if (! ((unsigned long )plhs != (unsigned long )((bucket **)0))) {
    {
#line 1371
    __assert_fail("plhs != 0", "/home/june/collector/temp/byacc-20140101/reader.c",
                  1371U, "expand_rules");
    }
  }
  {
#line 1373
  tmp___0 = realloc((void *)((char *)rprec), (size_t )maxrules * sizeof(Value_t ));
#line 1373
  rprec = (Value_t *)tmp___0;
  }
#line 1374
  if ((unsigned long )rprec == (unsigned long )((Value_t *)0)) {
    {
#line 1374
    no_space();
    }
  }
#line 1374
  if (! ((unsigned long )rprec != (unsigned long )((Value_t *)0))) {
    {
#line 1374
    __assert_fail("rprec != 0", "/home/june/collector/temp/byacc-20140101/reader.c",
                  1374U, "expand_rules");
    }
  }
  {
#line 1376
  tmp___1 = realloc((void *)rassoc, (size_t )maxrules * sizeof(Assoc_t ));
#line 1376
  rassoc = (Assoc_t *)tmp___1;
  }
#line 1377
  if ((unsigned long )rassoc == (unsigned long )((Assoc_t *)0)) {
    {
#line 1377
    no_space();
    }
  }
#line 1377
  if (! ((unsigned long )rassoc != (unsigned long )((Assoc_t *)0))) {
    {
#line 1377
    __assert_fail("rassoc != 0", "/home/june/collector/temp/byacc-20140101/reader.c",
                  1377U, "expand_rules");
    }
  }
#line 1378
  return;
}
}
#line 1380 "/home/june/collector/temp/byacc-20140101/reader.c"
static void advance_to_start(void) 
{ 
  int c ;
  bucket *bp ;
  char *s_cptr ;
  int s_lineno ;
  int tmp ;
  unsigned short const   **tmp___0 ;

  {
  {
#line 1388
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1390
    c = nextc();
    }
#line 1391
    if (c != 37) {
#line 1392
      goto while_break;
    }
    {
#line 1393
    s_cptr = cptr;
#line 1394
    tmp = keyword();
    }
    {
#line 1396
    if (tmp == 4) {
#line 1396
      goto case_4;
    }
#line 1399
    if (tmp == 5) {
#line 1399
      goto case_5;
    }
#line 1403
    if (tmp == 7) {
#line 1403
      goto case_7;
    }
#line 1407
    goto switch_default;
    case_4: /* CIL Label */ 
    {
#line 1397
    no_grammar();
    }
    case_5: /* CIL Label */ 
    {
#line 1400
    copy_text();
    }
#line 1401
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 1404
    declare_start();
    }
#line 1405
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1408
    syntax_error(lineno, line, s_cptr);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1412
  c = nextc();
#line 1413
  tmp___0 = __ctype_b_loc();
  }
#line 1413
  if (! ((int const   )*(*tmp___0 + c) & 1024)) {
#line 1413
    if (c != 95) {
#line 1413
      if (c != 46) {
#line 1413
        if (c != 95) {
          {
#line 1414
          syntax_error(lineno, line, cptr);
          }
        }
      }
    }
  }
  {
#line 1415
  bp = get_name();
  }
#line 1416
  if ((unsigned long )goal == (unsigned long )((bucket *)0)) {
#line 1418
    if ((int )bp->class == 1) {
      {
#line 1419
      terminal_start(bp->name);
      }
    }
#line 1420
    goal = bp;
  }
  {
#line 1423
  s_lineno = lineno;
#line 1424
  c = nextc();
  }
#line 1425
  if (c == -1) {
    {
#line 1426
    unexpected_EOF();
    }
  }
#line 1427
  if (c != 58) {
    {
#line 1428
    syntax_error(lineno, line, cptr);
    }
  }
  {
#line 1429
  start_rule(bp, s_lineno);
#line 1430
  cptr ++;
  }
#line 1431
  return;
}
}
#line 1433 "/home/june/collector/temp/byacc-20140101/reader.c"
static void start_rule(bucket *bp , int s_lineno ) 
{ 


  {
#line 1436
  if ((int )bp->class == 1) {
    {
#line 1437
    terminal_lhs(s_lineno);
    }
  }
#line 1438
  bp->class = (Class_t )2;
#line 1439
  if (nrules >= maxrules) {
    {
#line 1440
    expand_rules();
    }
  }
#line 1441
  *(plhs + nrules) = bp;
#line 1442
  *(rprec + nrules) = (Value_t )-1;
#line 1443
  *(rassoc + nrules) = (Assoc_t )0;
#line 1444
  return;
}
}
#line 1446 "/home/june/collector/temp/byacc-20140101/reader.c"
static void end_rule(void) 
{ 
  int i ;

  {
#line 1451
  if (! last_was_action) {
#line 1451
    if ((*(plhs + nrules))->tag) {
#line 1453
      if (*(pitem + (nitems - 1))) {
#line 1455
        i = nitems - 1;
        {
#line 1455
        while (1) {
          while_continue: /* CIL Label */ ;
#line 1455
          if (i > 0) {
#line 1455
            if (! *(pitem + i)) {
#line 1455
              goto while_break;
            }
          } else {
#line 1455
            goto while_break;
          }
#line 1456
          goto __Cont;
          __Cont: /* CIL Label */ 
#line 1455
          i --;
        }
        while_break: /* CIL Label */ ;
        }
#line 1457
        if ((unsigned long )*(pitem + (i + 1)) == (unsigned long )((bucket *)0)) {
          {
#line 1458
          default_action_warning();
          }
        } else
#line 1457
        if ((unsigned long )(*(pitem + (i + 1)))->tag != (unsigned long )(*(plhs + nrules))->tag) {
          {
#line 1458
          default_action_warning();
          }
        }
      } else {
        {
#line 1462
        default_action_warning();
        }
      }
    }
  }
#line 1466
  last_was_action = (char)0;
#line 1467
  if (nitems >= maxitems) {
    {
#line 1468
    expand_items();
    }
  }
#line 1469
  *(pitem + nitems) = (bucket *)0;
#line 1470
  nitems ++;
#line 1471
  nrules ++;
#line 1472
  return;
}
}
#line 1474 "/home/june/collector/temp/byacc-20140101/reader.c"
static void insert_empty_rule(void) 
{ 
  bucket *bp ;
  bucket **bpp ;
  bucket **tmp ;
  bucket *tmp___0 ;

  {
#line 1479
  if (! cache) {
    {
#line 1479
    __assert_fail("cache", "/home/june/collector/temp/byacc-20140101/reader.c", 1479U,
                  "insert_empty_rule");
    }
  }
  {
#line 1480
  gensym ++;
#line 1480
  sprintf((char */* __restrict  */)cache, (char const   */* __restrict  */)"$$%d",
          gensym);
#line 1481
  bp = make_bucket((char const   *)cache);
#line 1482
  last_symbol->next = bp;
#line 1483
  last_symbol = bp;
#line 1484
  bp->tag = (*(plhs + nrules))->tag;
#line 1485
  bp->class = (Class_t )2;
#line 1487
  nitems += 2;
  }
#line 1487
  if (nitems > maxitems) {
    {
#line 1488
    expand_items();
    }
  }
#line 1489
  bpp = (pitem + nitems) - 1;
#line 1490
  tmp = bpp;
#line 1490
  bpp --;
#line 1490
  *tmp = bp;
  {
#line 1491
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1491
    tmp___0 = *(bpp + -1);
#line 1491
    *(bpp + 0) = tmp___0;
#line 1491
    if (! ((unsigned long )tmp___0 != (unsigned long )((bucket *)0))) {
#line 1491
      goto while_break;
    }
#line 1492
    bpp --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1494
  nrules ++;
#line 1494
  if (nrules >= maxrules) {
    {
#line 1495
    expand_rules();
    }
  }
#line 1496
  *(plhs + nrules) = *(plhs + (nrules - 1));
#line 1497
  *(plhs + (nrules - 1)) = bp;
#line 1498
  *(rprec + nrules) = *(rprec + (nrules - 1));
#line 1499
  *(rprec + (nrules - 1)) = (Value_t )0;
#line 1500
  *(rassoc + nrules) = *(rassoc + (nrules - 1));
#line 1501
  *(rassoc + (nrules - 1)) = (Assoc_t )0;
#line 1502
  return;
}
}
#line 1504 "/home/june/collector/temp/byacc-20140101/reader.c"
static void add_symbol(void) 
{ 
  int c ;
  bucket *bp ;
  int s_lineno ;

  {
#line 1509
  s_lineno = lineno;
#line 1511
  c = (int )*cptr;
#line 1512
  if (c == 39) {
    {
#line 1513
    bp = get_literal();
    }
  } else
#line 1512
  if (c == 34) {
    {
#line 1513
    bp = get_literal();
    }
  } else {
    {
#line 1515
    bp = get_name();
    }
  }
  {
#line 1517
  c = nextc();
  }
#line 1518
  if (c == 58) {
    {
#line 1520
    end_rule();
#line 1521
    start_rule(bp, s_lineno);
#line 1522
    cptr ++;
    }
#line 1523
    return;
  }
#line 1526
  if (last_was_action) {
    {
#line 1527
    insert_empty_rule();
    }
  }
#line 1528
  last_was_action = (char)0;
#line 1530
  nitems ++;
#line 1530
  if (nitems > maxitems) {
    {
#line 1531
    expand_items();
    }
  }
#line 1532
  *(pitem + (nitems - 1)) = bp;
#line 1533
  return;
}
}
#line 1535 "/home/june/collector/temp/byacc-20140101/reader.c"
static char *after_blanks(char *s ) 
{ 
  unsigned short const   **tmp ;

  {
  {
#line 1538
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1538
    if ((int )*s != 0) {
      {
#line 1538
      tmp = __ctype_b_loc();
      }
#line 1538
      if (! ((int const   )*(*tmp + (int )((unsigned char )*s)) & 8192)) {
#line 1538
        goto while_break;
      }
    } else {
#line 1538
      goto while_break;
    }
#line 1539
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1540
  return (s);
}
}
#line 1543 "/home/june/collector/temp/byacc-20140101/reader.c"
static void copy_action(void) 
{ 
  int c ;
  int i ;
  int n ;
  int depth ;
  int quote ;
  char *tag ;
  FILE *f ;
  int a_lineno ;
  char *a_line ;
  char *tmp ;
  char *a_cptr ;
  char *tmp___0 ;
  int d_lineno ;
  char *d_line ;
  char *tmp___1 ;
  char *d_cptr ;
  Value_t tmp___2 ;
  Value_t tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  Value_t tmp___6 ;
  Value_t tmp___7 ;
  unsigned short const   **tmp___8 ;
  unsigned short const   **tmp___9 ;
  unsigned short const   **tmp___10 ;
  int s_lineno ;
  char *s_line ;
  char *tmp___11 ;
  char *s_cptr ;
  char *tmp___12 ;
  char *tmp___13 ;
  int c_lineno ;
  char *c_line ;
  char *tmp___14 ;
  char *c_cptr ;
  char *tmp___15 ;

  {
  {
#line 1551
  f = action_file;
#line 1552
  a_lineno = lineno;
#line 1553
  tmp = dup_line();
#line 1553
  a_line = tmp;
#line 1554
  a_cptr = a_line + (cptr - line);
  }
#line 1556
  if (last_was_action) {
    {
#line 1557
    insert_empty_rule();
    }
  }
  {
#line 1558
  last_was_action = (char)1;
#line 1560
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"case %d:\n",
          nrules - 2);
  }
#line 1561
  if (! lflag) {
    {
#line 1562
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)(line_format),
            lineno, input_file_name);
    }
  }
#line 1563
  if ((int )*cptr == 61) {
#line 1564
    cptr ++;
  }
  {
#line 1567
  tmp___0 = after_blanks(cptr);
  }
#line 1567
  if ((int )*tmp___0 == 123) {
    {
#line 1569
    _IO_putc('\t', f);
#line 1570
    cptr = after_blanks(cptr);
    }
  }
#line 1573
  n = 0;
#line 1574
  i = nitems - 1;
  {
#line 1574
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1574
    if (! *(pitem + i)) {
#line 1574
      goto while_break;
    }
#line 1575
    n ++;
#line 1574
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1577
  depth = 0;
  loop: 
#line 1579
  c = (int )*cptr;
#line 1580
  if (c == 36) {
#line 1582
    if ((int )*(cptr + 1) == 60) {
      {
#line 1584
      d_lineno = lineno;
#line 1585
      tmp___1 = dup_line();
#line 1585
      d_line = tmp___1;
#line 1586
      d_cptr = d_line + (cptr - line);
#line 1588
      cptr ++;
#line 1589
      tag = get_tag();
#line 1590
      c = (int )*cptr;
      }
#line 1591
      if (c == 36) {
        {
#line 1593
        fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"yyval.%s",
                tag);
#line 1594
        cptr ++;
#line 1595
        free((void *)d_line);
        }
#line 1596
        goto loop;
      } else {
        {
#line 1598
        tmp___5 = __ctype_b_loc();
        }
#line 1598
        if ((int const   )*(*tmp___5 + c) & 2048) {
          {
#line 1600
          tmp___2 = get_number();
#line 1600
          i = (int )tmp___2;
          }
#line 1601
          if (i > n) {
            {
#line 1602
            dollar_warning(d_lineno, i);
            }
          }
          {
#line 1603
          fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"yystack.l_mark[%d].%s",
                  i - n, tag);
#line 1604
          free((void *)d_line);
          }
#line 1605
          goto loop;
        } else
#line 1607
        if (c == 45) {
          {
#line 1607
          tmp___4 = __ctype_b_loc();
          }
#line 1607
          if ((int const   )*(*tmp___4 + (int )((unsigned char )*(cptr + 1))) & 2048) {
            {
#line 1609
            cptr ++;
#line 1610
            tmp___3 = get_number();
#line 1610
            i = - ((int )tmp___3) - n;
#line 1611
            fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"yystack.l_mark[%d].%s",
                    i, tag);
#line 1612
            free((void *)d_line);
            }
#line 1613
            goto loop;
          } else {
            {
#line 1616
            dollar_error(d_lineno, d_line, d_cptr);
            }
          }
        } else {
          {
#line 1616
          dollar_error(d_lineno, d_line, d_cptr);
          }
        }
      }
    } else
#line 1618
    if ((int )*(cptr + 1) == 36) {
#line 1620
      if (ntags) {
#line 1622
        tag = (*(plhs + nrules))->tag;
#line 1623
        if ((unsigned long )tag == (unsigned long )((char *)0)) {
          {
#line 1624
          untyped_lhs();
          }
        }
        {
#line 1625
        fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"yyval.%s",
                tag);
        }
      } else {
        {
#line 1628
        fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"yyval");
        }
      }
#line 1629
      cptr += 2;
#line 1630
      goto loop;
    } else {
      {
#line 1632
      tmp___8 = __ctype_b_loc();
      }
#line 1632
      if ((int const   )*(*tmp___8 + (int )((unsigned char )*(cptr + 1))) & 2048) {
        {
#line 1634
        cptr ++;
#line 1635
        tmp___6 = get_number();
#line 1635
        i = (int )tmp___6;
        }
#line 1636
        if (ntags) {
#line 1638
          if (i <= 0) {
            {
#line 1639
            unknown_rhs(i);
            }
          } else
#line 1638
          if (i > n) {
            {
#line 1639
            unknown_rhs(i);
            }
          }
#line 1640
          tag = (*(pitem + (((nitems + i) - n) - 1)))->tag;
#line 1641
          if ((unsigned long )tag == (unsigned long )((char *)0)) {
            {
#line 1642
            untyped_rhs(i, (*(pitem + (((nitems + i) - n) - 1)))->name);
            }
          }
          {
#line 1643
          fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"yystack.l_mark[%d].%s",
                  i - n, tag);
          }
        } else {
#line 1647
          if (i > n) {
            {
#line 1648
            dollar_warning(lineno, i);
            }
          }
          {
#line 1649
          fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"yystack.l_mark[%d]",
                  i - n);
          }
        }
#line 1651
        goto loop;
      } else
#line 1653
      if ((int )*(cptr + 1) == 45) {
        {
#line 1655
        cptr += 2;
#line 1656
        tmp___7 = get_number();
#line 1656
        i = (int )tmp___7;
        }
#line 1657
        if (ntags) {
          {
#line 1658
          unknown_rhs(- i);
          }
        }
        {
#line 1659
        fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"yystack.l_mark[%d]",
                - i - n);
        }
#line 1660
        goto loop;
      }
    }
  }
  {
#line 1663
  tmp___10 = __ctype_b_loc();
  }
#line 1663
  if ((int const   )*(*tmp___10 + c) & 1024) {
#line 1663
    goto _L;
  } else
#line 1663
  if (c == 95) {
#line 1663
    goto _L;
  } else
#line 1663
  if (c == 36) {
    _L: /* CIL Label */ 
    {
#line 1665
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1667
      _IO_putc(c, f);
#line 1668
      cptr ++;
#line 1668
      c = (int )*cptr;
#line 1665
      tmp___9 = __ctype_b_loc();
      }
#line 1665
      if (! ((int const   )*(*tmp___9 + c) & 8)) {
#line 1665
        if (! (c == 95)) {
#line 1665
          if (! (c == 36)) {
#line 1665
            goto while_break___0;
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1671
    goto loop;
  }
  {
#line 1673
  _IO_putc(c, f);
#line 1674
  cptr ++;
  }
  {
#line 1677
  if (c == 10) {
#line 1677
    goto next_line;
  }
#line 1684
  if (c == 59) {
#line 1684
    goto case_59;
  }
#line 1691
  if (c == 123) {
#line 1691
    goto case_123;
  }
#line 1695
  if (c == 125) {
#line 1695
    goto case_125;
  }
#line 1703
  if (c == 34) {
#line 1703
    goto case_34;
  }
#line 1703
  if (c == 39) {
#line 1703
    goto case_34;
  }
#line 1735
  if (c == 47) {
#line 1735
    goto case_47;
  }
#line 1779
  goto switch_default;
  next_line: 
  case_10: /* CIL Label */ 
  {
#line 1679
  get_line();
  }
#line 1680
  if (line) {
#line 1681
    goto loop;
  }
  {
#line 1682
  unterminated_action(a_lineno, a_line, a_cptr);
  }
  case_59: /* CIL Label */ 
#line 1685
  if (depth > 0) {
#line 1686
    goto loop;
  }
  {
#line 1687
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\nbreak;\n");
#line 1688
  free((void *)a_line);
  }
#line 1689
  return;
  case_123: /* CIL Label */ 
#line 1692
  depth ++;
#line 1693
  goto loop;
  case_125: /* CIL Label */ 
#line 1696
  depth --;
#line 1696
  if (depth > 0) {
#line 1697
    goto loop;
  }
  {
#line 1698
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\nbreak;\n");
#line 1699
  free((void *)a_line);
  }
#line 1700
  return;
  case_34: /* CIL Label */ 
  case_39: /* CIL Label */ 
  {
#line 1705
  s_lineno = lineno;
#line 1706
  tmp___11 = dup_line();
#line 1706
  s_line = tmp___11;
#line 1707
  s_cptr = s_line + ((cptr - line) - 1L);
#line 1709
  quote = c;
  }
  {
#line 1710
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 1712
    tmp___12 = cptr;
#line 1712
    cptr ++;
#line 1712
    c = (int )*tmp___12;
#line 1713
    _IO_putc(c, f);
    }
#line 1714
    if (c == quote) {
      {
#line 1716
      free((void *)s_line);
      }
#line 1717
      goto loop;
    }
#line 1719
    if (c == 10) {
      {
#line 1720
      unterminated_string(s_lineno, s_line, s_cptr);
      }
    }
#line 1721
    if (c == 92) {
      {
#line 1723
      tmp___13 = cptr;
#line 1723
      cptr ++;
#line 1723
      c = (int )*tmp___13;
#line 1724
      _IO_putc(c, f);
      }
#line 1725
      if (c == 10) {
        {
#line 1727
        get_line();
        }
#line 1728
        if ((unsigned long )line == (unsigned long )((char *)0)) {
          {
#line 1729
          unterminated_string(s_lineno, s_line, s_cptr);
          }
        }
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  case_47: /* CIL Label */ 
#line 1736
  c = (int )*cptr;
#line 1737
  if (c == 47) {
    {
#line 1739
    _IO_putc('*', f);
    }
    {
#line 1740
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1740
      cptr ++;
#line 1740
      c = (int )*cptr;
#line 1740
      if (! (c != 10)) {
#line 1740
        goto while_break___2;
      }
#line 1742
      if (c == 42) {
#line 1742
        if ((int )*(cptr + 1) == 47) {
          {
#line 1743
          fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"* ");
          }
        } else {
          {
#line 1745
          _IO_putc(c, f);
          }
        }
      } else {
        {
#line 1745
        _IO_putc(c, f);
        }
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 1747
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"*/\n");
    }
#line 1748
    goto next_line;
  }
#line 1750
  if (c == 42) {
    {
#line 1752
    c_lineno = lineno;
#line 1753
    tmp___14 = dup_line();
#line 1753
    c_line = tmp___14;
#line 1754
    c_cptr = c_line + ((cptr - line) - 1L);
#line 1756
    _IO_putc('*', f);
#line 1757
    cptr ++;
    }
    {
#line 1758
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 1760
      tmp___15 = cptr;
#line 1760
      cptr ++;
#line 1760
      c = (int )*tmp___15;
#line 1761
      _IO_putc(c, f);
      }
#line 1762
      if (c == 42) {
#line 1762
        if ((int )*cptr == 47) {
          {
#line 1764
          _IO_putc('/', f);
#line 1765
          cptr ++;
#line 1766
          free((void *)c_line);
          }
#line 1767
          goto loop;
        }
      }
#line 1769
      if (c == 10) {
        {
#line 1771
        get_line();
        }
#line 1772
        if ((unsigned long )line == (unsigned long )((char *)0)) {
          {
#line 1773
          unterminated_comment(c_lineno, c_line, c_cptr);
          }
        }
      }
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 1777
  goto loop;
  switch_default: /* CIL Label */ 
#line 1780
  goto loop;
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1784 "/home/june/collector/temp/byacc-20140101/reader.c"
static int mark_symbol(void) 
{ 
  int c ;
  bucket *bp ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
#line 1788
  bp = (bucket *)((void *)0);
#line 1790
  c = (int )*(cptr + 1);
#line 1791
  if (c == 37) {
#line 1793
    cptr += 2;
#line 1794
    return (1);
  } else
#line 1791
  if (c == 92) {
#line 1793
    cptr += 2;
#line 1794
    return (1);
  }
#line 1797
  if (c == 61) {
#line 1798
    cptr += 2;
  } else
#line 1799
  if (c == 112) {
#line 1799
    goto _L___2;
  } else
#line 1799
  if (c == 80) {
    _L___2: /* CIL Label */ 
#line 1799
    c = (int )*(cptr + 2);
#line 1799
    if (c == 114) {
#line 1799
      goto _L___1;
    } else
#line 1799
    if (c == 82) {
      _L___1: /* CIL Label */ 
#line 1799
      c = (int )*(cptr + 3);
#line 1799
      if (c == 101) {
#line 1799
        goto _L___0;
      } else
#line 1799
      if (c == 69) {
        _L___0: /* CIL Label */ 
#line 1799
        c = (int )*(cptr + 4);
#line 1799
        if (c == 99) {
#line 1799
          goto _L;
        } else
#line 1799
        if (c == 67) {
          _L: /* CIL Label */ 
          {
#line 1799
          c = (int )*(cptr + 5);
#line 1799
          tmp = __ctype_b_loc();
          }
#line 1799
          if ((int const   )*(*tmp + c) & 8) {
#line 1799
            tmp___0 = 0;
          } else
#line 1799
          if (c == 95) {
#line 1799
            tmp___0 = 0;
          } else
#line 1799
          if (c == 46) {
#line 1799
            tmp___0 = 0;
          } else
#line 1799
          if (c == 36) {
#line 1799
            tmp___0 = 0;
          } else {
#line 1799
            tmp___0 = 1;
          }
#line 1799
          if (tmp___0) {
#line 1804
            cptr += 5;
          } else {
            {
#line 1806
            syntax_error(lineno, line, cptr);
            }
          }
        } else {
          {
#line 1806
          syntax_error(lineno, line, cptr);
          }
        }
      } else {
        {
#line 1806
        syntax_error(lineno, line, cptr);
        }
      }
    } else {
      {
#line 1806
      syntax_error(lineno, line, cptr);
      }
    }
  } else {
    {
#line 1806
    syntax_error(lineno, line, cptr);
    }
  }
  {
#line 1808
  c = nextc();
#line 1809
  tmp___1 = __ctype_b_loc();
  }
#line 1809
  if ((int const   )*(*tmp___1 + c) & 1024) {
    {
#line 1810
    bp = get_name();
    }
  } else
#line 1809
  if (c == 95) {
    {
#line 1810
    bp = get_name();
    }
  } else
#line 1809
  if (c == 46) {
    {
#line 1810
    bp = get_name();
    }
  } else
#line 1809
  if (c == 36) {
    {
#line 1810
    bp = get_name();
    }
  } else
#line 1811
  if (c == 39) {
    {
#line 1812
    bp = get_literal();
    }
  } else
#line 1811
  if (c == 34) {
    {
#line 1812
    bp = get_literal();
    }
  } else {
    {
#line 1815
    syntax_error(lineno, line, cptr);
    }
  }
#line 1819
  if ((int )*(rprec + nrules) != -1) {
#line 1819
    if ((int )bp->prec != (int )*(rprec + nrules)) {
      {
#line 1820
      prec_redeclared();
      }
    }
  }
#line 1822
  *(rprec + nrules) = bp->prec;
#line 1823
  *(rassoc + nrules) = bp->assoc;
#line 1824
  return (0);
}
}
#line 1827 "/home/june/collector/temp/byacc-20140101/reader.c"
static void read_grammar(void) 
{ 
  int c ;
  int tmp ;
  unsigned short const   **tmp___0 ;

  {
  {
#line 1832
  initialize_grammar();
#line 1833
  advance_to_start();
  }
  {
#line 1835
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1837
    c = nextc();
    }
#line 1838
    if (c == -1) {
#line 1839
      goto while_break;
    }
    {
#line 1840
    tmp___0 = __ctype_b_loc();
    }
#line 1840
    if ((int const   )*(*tmp___0 + c) & 1024) {
      {
#line 1846
      add_symbol();
      }
    } else
#line 1840
    if (c == 95) {
      {
#line 1846
      add_symbol();
      }
    } else
#line 1840
    if (c == 46) {
      {
#line 1846
      add_symbol();
      }
    } else
#line 1840
    if (c == 36) {
      {
#line 1846
      add_symbol();
      }
    } else
#line 1840
    if (c == 39) {
      {
#line 1846
      add_symbol();
      }
    } else
#line 1840
    if (c == 34) {
      {
#line 1846
      add_symbol();
      }
    } else
#line 1847
    if (c == 123) {
      {
#line 1848
      copy_action();
      }
    } else
#line 1847
    if (c == 61) {
      {
#line 1848
      copy_action();
      }
    } else
#line 1849
    if (c == 124) {
      {
#line 1851
      end_rule();
#line 1852
      start_rule(*(plhs + (nrules - 1)), 0);
#line 1853
      cptr ++;
      }
    } else
#line 1855
    if (c == 37) {
      {
#line 1857
      tmp = mark_symbol();
      }
#line 1857
      if (tmp) {
#line 1858
        goto while_break;
      }
    } else {
      {
#line 1861
      syntax_error(lineno, line, cptr);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1863
  end_rule();
  }
#line 1864
  return;
}
}
#line 1866 "/home/june/collector/temp/byacc-20140101/reader.c"
static void free_tags(void) 
{ 
  int i ;

  {
#line 1871
  if ((unsigned long )tag_table == (unsigned long )((char **)0)) {
#line 1872
    return;
  }
#line 1874
  i = 0;
  {
#line 1874
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1874
    if (! (i < ntags)) {
#line 1874
      goto while_break;
    }
#line 1876
    if (! *(tag_table + i)) {
      {
#line 1876
      __assert_fail("tag_table[i]", "/home/june/collector/temp/byacc-20140101/reader.c",
                    1876U, "free_tags");
      }
    }
    {
#line 1877
    free((void *)*(tag_table + i));
#line 1874
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1879
  free((void *)((char *)tag_table));
  }
#line 1880
  return;
}
}
#line 1882 "/home/june/collector/temp/byacc-20140101/reader.c"
static void pack_names(void) 
{ 
  bucket *bp ;
  char *p ;
  char *s ;
  char *t ;
  size_t tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  char *tmp___3 ;

  {
#line 1888
  name_pool_size = (size_t )13;
#line 1889
  bp = first_symbol;
  {
#line 1889
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1889
    if (! bp) {
#line 1889
      goto while_break;
    }
    {
#line 1890
    tmp = strlen((char const   *)bp->name);
#line 1890
    name_pool_size += tmp + 1UL;
#line 1889
    bp = bp->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1892
  tmp___0 = malloc(name_pool_size * sizeof(char ));
#line 1892
  name_pool = (char *)tmp___0;
  }
#line 1893
  if ((unsigned long )name_pool == (unsigned long )((char *)0)) {
    {
#line 1893
    no_space();
    }
  }
#line 1893
  if (! ((unsigned long )name_pool != (unsigned long )((char *)0))) {
    {
#line 1893
    __assert_fail("name_pool != 0", "/home/june/collector/temp/byacc-20140101/reader.c",
                  1893U, "pack_names");
    }
  }
  {
#line 1895
  strcpy((char */* __restrict  */)name_pool, (char const   */* __restrict  */)"$accept");
#line 1896
  strcpy((char */* __restrict  */)(name_pool + 8), (char const   */* __restrict  */)"$end");
#line 1897
  t = name_pool + 13;
#line 1898
  bp = first_symbol;
  }
  {
#line 1898
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1898
    if (! bp) {
#line 1898
      goto while_break___0;
    }
#line 1900
    p = t;
#line 1901
    s = bp->name;
    {
#line 1902
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1902
      tmp___1 = t;
#line 1902
      t ++;
#line 1902
      tmp___3 = s;
#line 1902
      s ++;
#line 1902
      tmp___2 = *tmp___3;
#line 1902
      *tmp___1 = tmp___2;
#line 1902
      if (! ((int )tmp___2 != 0)) {
#line 1902
        goto while_break___1;
      }
#line 1903
      goto while_continue___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1904
    free((void *)bp->name);
#line 1905
    bp->name = p;
#line 1898
    bp = bp->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1907
  return;
}
}
#line 1909 "/home/june/collector/temp/byacc-20140101/reader.c"
static void check_symbols(void) 
{ 
  bucket *bp ;

  {
#line 1914
  if ((int )goal->class == 0) {
    {
#line 1915
    undefined_goal(goal->name);
    }
  }
#line 1917
  bp = first_symbol;
  {
#line 1917
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1917
    if (! bp) {
#line 1917
      goto while_break;
    }
#line 1919
    if ((int )bp->class == 0) {
      {
#line 1921
      undefined_symbol_warning(bp->name);
#line 1922
      bp->class = (Class_t )1;
      }
    }
#line 1917
    bp = bp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1925
  return;
}
}
#line 1927 "/home/june/collector/temp/byacc-20140101/reader.c"
static void protect_string(char *src , char **des ) 
{ 
  unsigned int len ;
  char *s ;
  char *d ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 1934
  *des = src;
#line 1935
  if (src) {
#line 1937
    len = 1U;
#line 1938
    s = src;
    {
#line 1939
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1939
      if (! *s) {
#line 1939
        goto while_break;
      }
#line 1941
      if (92 == (int )*s) {
#line 1942
        len ++;
      } else
#line 1941
      if (34 == (int )*s) {
#line 1942
        len ++;
      }
#line 1943
      s ++;
#line 1944
      len ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1947
    tmp = malloc((size_t )len * sizeof(char ));
#line 1947
    d = (char *)tmp;
#line 1947
    *des = d;
    }
#line 1948
    if ((unsigned long )d == (unsigned long )((char *)0)) {
      {
#line 1948
      no_space();
      }
    }
#line 1948
    if (! ((unsigned long )d != (unsigned long )((char *)0))) {
      {
#line 1948
      __assert_fail("d != 0", "/home/june/collector/temp/byacc-20140101/reader.c",
                    1948U, "protect_string");
      }
    }
#line 1950
    s = src;
    {
#line 1951
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1951
      if (! *s) {
#line 1951
        goto while_break___0;
      }
#line 1953
      if (92 == (int )*s) {
#line 1954
        tmp___0 = d;
#line 1954
        d ++;
#line 1954
        *tmp___0 = (char )'\\';
      } else
#line 1953
      if (34 == (int )*s) {
#line 1954
        tmp___0 = d;
#line 1954
        d ++;
#line 1954
        *tmp___0 = (char )'\\';
      }
#line 1955
      tmp___1 = d;
#line 1955
      d ++;
#line 1955
      tmp___2 = s;
#line 1955
      s ++;
#line 1955
      *tmp___1 = *tmp___2;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1957
    *d = (char )'\000';
  }
#line 1959
  return;
}
}
#line 1961 "/home/june/collector/temp/byacc-20140101/reader.c"
static void pack_symbols(void) 
{ 
  bucket *bp ;
  bucket **v ;
  Value_t i ;
  Value_t j ;
  Value_t k ;
  Value_t n ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  Value_t tmp___4 ;
  Value_t tmp___5 ;
  Value_t tmp___6 ;
  void *tmp___7 ;

  {
#line 1968
  nsyms = 2;
#line 1969
  ntokens = 1;
#line 1970
  bp = first_symbol;
  {
#line 1970
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1970
    if (! bp) {
#line 1970
      goto while_break;
    }
#line 1972
    nsyms ++;
#line 1973
    if ((int )bp->class == 1) {
#line 1974
      ntokens ++;
    }
#line 1970
    bp = bp->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1976
  start_symbol = (Value_t )ntokens;
#line 1977
  nvars = nsyms - ntokens;
#line 1979
  tmp = malloc((size_t )nsyms * sizeof(char *));
#line 1979
  symbol_name = (char **)tmp;
  }
#line 1980
  if ((unsigned long )symbol_name == (unsigned long )((char **)0)) {
    {
#line 1980
    no_space();
    }
  }
#line 1980
  if (! ((unsigned long )symbol_name != (unsigned long )((char **)0))) {
    {
#line 1980
    __assert_fail("symbol_name != 0", "/home/june/collector/temp/byacc-20140101/reader.c",
                  1980U, "pack_symbols");
    }
  }
  {
#line 1982
  tmp___0 = malloc((size_t )nsyms * sizeof(Value_t ));
#line 1982
  symbol_value = (Value_t *)tmp___0;
  }
#line 1983
  if ((unsigned long )symbol_value == (unsigned long )((Value_t *)0)) {
    {
#line 1983
    no_space();
    }
  }
#line 1983
  if (! ((unsigned long )symbol_value != (unsigned long )((Value_t *)0))) {
    {
#line 1983
    __assert_fail("symbol_value != 0", "/home/june/collector/temp/byacc-20140101/reader.c",
                  1983U, "pack_symbols");
    }
  }
  {
#line 1985
  tmp___1 = malloc((size_t )nsyms * sizeof(short ));
#line 1985
  symbol_prec = (short *)tmp___1;
  }
#line 1986
  if ((unsigned long )symbol_prec == (unsigned long )((Value_t *)0)) {
    {
#line 1986
    no_space();
    }
  }
#line 1986
  if (! ((unsigned long )symbol_prec != (unsigned long )((Value_t *)0))) {
    {
#line 1986
    __assert_fail("symbol_prec != 0", "/home/june/collector/temp/byacc-20140101/reader.c",
                  1986U, "pack_symbols");
    }
  }
  {
#line 1988
  tmp___2 = malloc((size_t )nsyms * sizeof(char ));
#line 1988
  symbol_assoc = (char *)tmp___2;
  }
#line 1989
  if ((unsigned long )symbol_assoc == (unsigned long )((char *)0)) {
    {
#line 1989
    no_space();
    }
  }
#line 1989
  if (! ((unsigned long )symbol_assoc != (unsigned long )((char *)0))) {
    {
#line 1989
    __assert_fail("symbol_assoc != 0", "/home/june/collector/temp/byacc-20140101/reader.c",
                  1989U, "pack_symbols");
    }
  }
  {
#line 1991
  tmp___3 = malloc((size_t )nsyms * sizeof(bucket *));
#line 1991
  v = (bucket **)tmp___3;
  }
#line 1992
  if ((unsigned long )v == (unsigned long )((bucket **)0)) {
    {
#line 1992
    no_space();
    }
  }
#line 1992
  if (! ((unsigned long )v != (unsigned long )((bucket **)0))) {
    {
#line 1992
    __assert_fail("v != 0", "/home/june/collector/temp/byacc-20140101/reader.c", 1992U,
                  "pack_symbols");
    }
  }
#line 1994
  *(v + 0) = (bucket *)0;
#line 1995
  *(v + start_symbol) = (bucket *)0;
#line 1997
  i = (Value_t )1;
#line 1998
  j = (Value_t )((int )start_symbol + 1);
#line 1999
  bp = first_symbol;
  {
#line 1999
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1999
    if (! bp) {
#line 1999
      goto while_break___0;
    }
#line 2001
    if ((int )bp->class == 1) {
#line 2002
      tmp___4 = i;
#line 2002
      i = (Value_t )((int )i + 1);
#line 2002
      *(v + tmp___4) = bp;
    } else {
#line 2004
      tmp___5 = j;
#line 2004
      j = (Value_t )((int )j + 1);
#line 2004
      *(v + tmp___5) = bp;
    }
#line 1999
    bp = bp->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2006
  if ((int )i == ntokens) {
#line 2006
    if (! ((int )j == nsyms)) {
      {
#line 2006
      __assert_fail("i == ntokens && j == nsyms", "/home/june/collector/temp/byacc-20140101/reader.c",
                    2006U, "pack_symbols");
      }
    }
  } else {
    {
#line 2006
    __assert_fail("i == ntokens && j == nsyms", "/home/june/collector/temp/byacc-20140101/reader.c",
                  2006U, "pack_symbols");
    }
  }
#line 2008
  i = (Value_t )1;
  {
#line 2008
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2008
    if (! ((int )i < ntokens)) {
#line 2008
      goto while_break___1;
    }
#line 2009
    (*(v + i))->index = i;
#line 2008
    i = (Value_t )((int )i + 1);
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2011
  goal->index = (Index_t )((int )start_symbol + 1);
#line 2012
  k = (Value_t )((int )start_symbol + 2);
  {
#line 2013
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2013
    i = (Value_t )((int )i + 1);
#line 2013
    if (! ((int )i < nsyms)) {
#line 2013
      goto while_break___2;
    }
#line 2014
    if ((unsigned long )*(v + i) != (unsigned long )goal) {
#line 2016
      (*(v + i))->index = k;
#line 2017
      k = (Value_t )((int )k + 1);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 2020
  goal->value = (Value_t )0;
#line 2021
  k = (Value_t )1;
#line 2022
  i = (Value_t )((int )start_symbol + 1);
  {
#line 2022
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 2022
    if (! ((int )i < nsyms)) {
#line 2022
      goto while_break___3;
    }
#line 2024
    if ((unsigned long )*(v + i) != (unsigned long )goal) {
#line 2026
      (*(v + i))->value = k;
#line 2027
      k = (Value_t )((int )k + 1);
    }
#line 2022
    i = (Value_t )((int )i + 1);
  }
  while_break___3: /* CIL Label */ ;
  }
#line 2031
  k = (Value_t )0;
#line 2032
  i = (Value_t )1;
  {
#line 2032
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 2032
    if (! ((int )i < ntokens)) {
#line 2032
      goto while_break___4;
    }
#line 2034
    n = (*(v + i))->value;
#line 2035
    if ((int )n > 256) {
#line 2037
      tmp___6 = k;
#line 2037
      k = (Value_t )((int )k + 1);
#line 2037
      j = tmp___6;
      {
#line 2037
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 2037
        if ((int )j > 0) {
#line 2037
          if (! ((int )*(symbol_value + ((int )j - 1)) > (int )n)) {
#line 2037
            goto while_break___5;
          }
        } else {
#line 2037
          goto while_break___5;
        }
#line 2038
        *(symbol_value + j) = *(symbol_value + ((int )j - 1));
#line 2037
        j = (Value_t )((int )j - 1);
      }
      while_break___5: /* CIL Label */ ;
      }
#line 2039
      *(symbol_value + j) = n;
    }
#line 2032
    i = (Value_t )((int )i + 1);
  }
  while_break___4: /* CIL Label */ ;
  }
#line 2043
  if (! ((unsigned long )*(v + 1) != (unsigned long )((bucket *)0))) {
    {
#line 2043
    __assert_fail("v[1] != 0", "/home/june/collector/temp/byacc-20140101/reader.c",
                  2043U, "pack_symbols");
    }
  }
#line 2045
  if ((int )(*(v + 1))->value == -1) {
#line 2046
    (*(v + 1))->value = (Value_t )256;
  }
#line 2048
  j = (Value_t )0;
#line 2049
  n = (Value_t )257;
#line 2050
  i = (Value_t )2;
  {
#line 2050
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 2050
    if (! ((int )i < ntokens)) {
#line 2050
      goto while_break___6;
    }
#line 2052
    if ((int )(*(v + i))->value == -1) {
      {
#line 2054
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 2054
        if ((int )j < (int )k) {
#line 2054
          if (! ((int )n == (int )*(symbol_value + j))) {
#line 2054
            goto while_break___7;
          }
        } else {
#line 2054
          goto while_break___7;
        }
        {
#line 2056
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 2056
          j = (Value_t )((int )j + 1);
#line 2056
          if ((int )j < (int )k) {
#line 2056
            if (! ((int )n == (int )*(symbol_value + j))) {
#line 2056
              goto while_break___8;
            }
          } else {
#line 2056
            goto while_break___8;
          }
#line 2057
          goto while_continue___8;
        }
        while_break___8: /* CIL Label */ ;
        }
#line 2058
        n = (Value_t )((int )n + 1);
      }
      while_break___7: /* CIL Label */ ;
      }
#line 2060
      (*(v + i))->value = n;
#line 2061
      n = (Value_t )((int )n + 1);
    }
#line 2050
    i = (Value_t )((int )i + 1);
  }
  while_break___6: /* CIL Label */ ;
  }
#line 2065
  *(symbol_name + 0) = name_pool + 8;
#line 2066
  *(symbol_value + 0) = (Value_t )0;
#line 2067
  *(symbol_prec + 0) = (Value_t )0;
#line 2068
  *(symbol_assoc + 0) = (char)0;
#line 2069
  i = (Value_t )1;
  {
#line 2069
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 2069
    if (! ((int )i < ntokens)) {
#line 2069
      goto while_break___9;
    }
#line 2071
    *(symbol_name + i) = (*(v + i))->name;
#line 2072
    *(symbol_value + i) = (*(v + i))->value;
#line 2073
    *(symbol_prec + i) = (*(v + i))->prec;
#line 2074
    *(symbol_assoc + i) = (*(v + i))->assoc;
#line 2069
    i = (Value_t )((int )i + 1);
  }
  while_break___9: /* CIL Label */ ;
  }
#line 2076
  *(symbol_name + start_symbol) = name_pool;
#line 2077
  *(symbol_value + start_symbol) = (Value_t )-1;
#line 2078
  *(symbol_prec + start_symbol) = (Value_t )0;
#line 2079
  *(symbol_assoc + start_symbol) = (char)0;
#line 2080
  i = (Value_t )((int )i + 1);
  {
#line 2080
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 2080
    if (! ((int )i < nsyms)) {
#line 2080
      goto while_break___10;
    }
#line 2082
    k = (*(v + i))->index;
#line 2083
    *(symbol_name + k) = (*(v + i))->name;
#line 2084
    *(symbol_value + k) = (*(v + i))->value;
#line 2085
    *(symbol_prec + k) = (*(v + i))->prec;
#line 2086
    *(symbol_assoc + k) = (*(v + i))->assoc;
#line 2080
    i = (Value_t )((int )i + 1);
  }
  while_break___10: /* CIL Label */ ;
  }
#line 2089
  if (gflag) {
    {
#line 2091
    tmp___7 = malloc((size_t )nsyms * sizeof(char *));
#line 2091
    symbol_pname = (char **)tmp___7;
    }
#line 2092
    if ((unsigned long )symbol_pname == (unsigned long )((char **)0)) {
      {
#line 2092
      no_space();
      }
    }
#line 2092
    if (! ((unsigned long )symbol_pname != (unsigned long )((char **)0))) {
      {
#line 2092
      __assert_fail("symbol_pname != 0", "/home/june/collector/temp/byacc-20140101/reader.c",
                    2092U, "pack_symbols");
      }
    }
#line 2094
    i = (Value_t )0;
    {
#line 2094
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 2094
      if (! ((int )i < nsyms)) {
#line 2094
        goto while_break___11;
      }
      {
#line 2095
      protect_string(*(symbol_name + i), symbol_pname + i);
#line 2094
      i = (Value_t )((int )i + 1);
      }
    }
    while_break___11: /* CIL Label */ ;
    }
  }
  {
#line 2098
  free((void *)((char *)v));
  }
#line 2099
  return;
}
}
#line 2101 "/home/june/collector/temp/byacc-20140101/reader.c"
static void pack_grammar(void) 
{ 
  int i ;
  Value_t j ;
  Assoc_t assoc ;
  Value_t prec2 ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 2109
  tmp = malloc((size_t )nitems * sizeof(Value_t ));
#line 2109
  ritem = (Value_t *)tmp;
  }
#line 2110
  if ((unsigned long )ritem == (unsigned long )((Value_t *)0)) {
    {
#line 2110
    no_space();
    }
  }
#line 2110
  if (! ((unsigned long )ritem != (unsigned long )((Value_t *)0))) {
    {
#line 2110
    __assert_fail("ritem != 0", "/home/june/collector/temp/byacc-20140101/reader.c",
                  2110U, "pack_grammar");
    }
  }
  {
#line 2112
  tmp___0 = malloc((size_t )nrules * sizeof(Value_t ));
#line 2112
  rlhs = (Value_t *)tmp___0;
  }
#line 2113
  if ((unsigned long )rlhs == (unsigned long )((Value_t *)0)) {
    {
#line 2113
    no_space();
    }
  }
#line 2113
  if (! ((unsigned long )rlhs != (unsigned long )((Value_t *)0))) {
    {
#line 2113
    __assert_fail("rlhs != 0", "/home/june/collector/temp/byacc-20140101/reader.c",
                  2113U, "pack_grammar");
    }
  }
  {
#line 2115
  tmp___1 = malloc((size_t )(nrules + 1) * sizeof(Value_t ));
#line 2115
  rrhs = (Value_t *)tmp___1;
  }
#line 2116
  if ((unsigned long )rrhs == (unsigned long )((Value_t *)0)) {
    {
#line 2116
    no_space();
    }
  }
#line 2116
  if (! ((unsigned long )rrhs != (unsigned long )((Value_t *)0))) {
    {
#line 2116
    __assert_fail("rrhs != 0", "/home/june/collector/temp/byacc-20140101/reader.c",
                  2116U, "pack_grammar");
    }
  }
  {
#line 2118
  tmp___2 = realloc((void *)((char *)rprec), (size_t )nrules * sizeof(Value_t ));
#line 2118
  rprec = (Value_t *)tmp___2;
  }
#line 2119
  if ((unsigned long )rprec == (unsigned long )((Value_t *)0)) {
    {
#line 2119
    no_space();
    }
  }
#line 2119
  if (! ((unsigned long )rprec != (unsigned long )((Value_t *)0))) {
    {
#line 2119
    __assert_fail("rprec != 0", "/home/june/collector/temp/byacc-20140101/reader.c",
                  2119U, "pack_grammar");
    }
  }
  {
#line 2121
  tmp___3 = realloc((void *)rassoc, (size_t )nrules * sizeof(Assoc_t ));
#line 2121
  rassoc = (Assoc_t *)tmp___3;
  }
#line 2122
  if ((unsigned long )rassoc == (unsigned long )((Assoc_t *)0)) {
    {
#line 2122
    no_space();
    }
  }
#line 2122
  if (! ((unsigned long )rassoc != (unsigned long )((Assoc_t *)0))) {
    {
#line 2122
    __assert_fail("rassoc != 0", "/home/june/collector/temp/byacc-20140101/reader.c",
                  2122U, "pack_grammar");
    }
  }
#line 2124
  *(ritem + 0) = (Value_t )-1;
#line 2125
  *(ritem + 1) = goal->index;
#line 2126
  *(ritem + 2) = (Value_t )0;
#line 2127
  *(ritem + 3) = (Value_t )-2;
#line 2128
  *(rlhs + 0) = (Value_t )0;
#line 2129
  *(rlhs + 1) = (Value_t )0;
#line 2130
  *(rlhs + 2) = start_symbol;
#line 2131
  *(rrhs + 0) = (Value_t )0;
#line 2132
  *(rrhs + 1) = (Value_t )0;
#line 2133
  *(rrhs + 2) = (Value_t )1;
#line 2135
  j = (Value_t )4;
#line 2136
  i = 3;
  {
#line 2136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2136
    if (! (i < nrules)) {
#line 2136
      goto while_break;
    }
#line 2138
    *(rlhs + i) = (*(plhs + i))->index;
#line 2139
    *(rrhs + i) = j;
#line 2140
    assoc = (Assoc_t )0;
#line 2141
    prec2 = (Value_t )0;
    {
#line 2142
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2142
      if (! *(pitem + j)) {
#line 2142
        goto while_break___0;
      }
#line 2144
      *(ritem + j) = (*(pitem + j))->index;
#line 2145
      if ((int )(*(pitem + j))->class == 1) {
#line 2147
        prec2 = (*(pitem + j))->prec;
#line 2148
        assoc = (*(pitem + j))->assoc;
      }
#line 2150
      j = (Value_t )((int )j + 1);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2152
    *(ritem + j) = (Value_t )(- i);
#line 2153
    j = (Value_t )((int )j + 1);
#line 2154
    if ((int )*(rprec + i) == -1) {
#line 2156
      *(rprec + i) = prec2;
#line 2157
      *(rassoc + i) = assoc;
    }
#line 2136
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2160
  *(rrhs + i) = j;
#line 2162
  free((void *)((char *)plhs));
#line 2163
  free((void *)((char *)pitem));
  }
#line 2164
  return;
}
}
#line 2166 "/home/june/collector/temp/byacc-20140101/reader.c"
static void print_grammar(void) 
{ 
  int i ;
  int k ;
  size_t j ;
  size_t spacing ;
  FILE *f ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 2170
  spacing = (size_t )0;
#line 2171
  f = verbose_file;
#line 2173
  if (! vflag) {
#line 2174
    return;
  }
#line 2176
  k = 1;
#line 2177
  i = 2;
  {
#line 2177
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2177
    if (! (i < nrules)) {
#line 2177
      goto while_break;
    }
#line 2179
    if ((int )*(rlhs + i) != (int )*(rlhs + (i - 1))) {
#line 2181
      if (i != 2) {
        {
#line 2182
        fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\n");
        }
      }
      {
#line 2183
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%4d  %s :",
              i - 2, *(symbol_name + *(rlhs + i)));
#line 2184
      tmp = strlen((char const   *)*(symbol_name + *(rlhs + i)));
#line 2184
      spacing = tmp + 1UL;
      }
    } else {
      {
#line 2188
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%4d  ",
              i - 2);
#line 2189
      j = spacing;
      }
      {
#line 2190
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2190
        tmp___0 = j;
#line 2190
        j --;
#line 2190
        if (! (tmp___0 != 0UL)) {
#line 2190
          goto while_break___0;
        }
        {
#line 2191
        _IO_putc(' ', f);
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 2192
      _IO_putc('|', f);
      }
    }
    {
#line 2195
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2195
      if (! ((int )*(ritem + k) >= 0)) {
#line 2195
        goto while_break___1;
      }
      {
#line 2197
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)" %s",
              *(symbol_name + *(ritem + k)));
#line 2198
      k ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 2200
    k ++;
#line 2201
    _IO_putc('\n', f);
#line 2177
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2203
  return;
}
}
#line 2205 "/home/june/collector/temp/byacc-20140101/reader.c"
void reader(void) 
{ 


  {
  {
#line 2208
  write_section(code_file, banner);
#line 2209
  create_symbol_table();
#line 2210
  read_declarations();
#line 2211
  read_grammar();
#line 2212
  free_symbol_table();
#line 2213
  free_tags();
#line 2214
  pack_names();
#line 2215
  check_symbols();
#line 2216
  pack_symbols();
#line 2217
  pack_grammar();
#line 2218
  free_symbols();
#line 2219
  print_grammar();
  }
#line 2220
  return;
}
}
#line 379 "/home/june/collector/temp/byacc-20140101/defs.h"
void fatal(char const   *msg___0 ) ;
#line 385
void open_error(char const   *filename ) ;
#line 429
void done(int k ) ;
#line 7 "/home/june/collector/temp/byacc-20140101/error.c"
void fatal(char const   *msg___0 ) 
{ 


  {
  {
#line 10
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: f - %s\n",
          myname, msg___0);
#line 11
  done(2);
  }
#line 12
  return;
}
}
#line 14 "/home/june/collector/temp/byacc-20140101/error.c"
void no_space(void) 
{ 


  {
  {
#line 17
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: f - out of space\n",
          myname);
#line 18
  done(2);
  }
#line 19
  return;
}
}
#line 21 "/home/june/collector/temp/byacc-20140101/error.c"
void open_error(char const   *filename ) 
{ 


  {
  {
#line 24
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: f - cannot open \"%s\"\n",
          myname, filename);
#line 25
  done(2);
  }
#line 26
  return;
}
}
#line 28 "/home/june/collector/temp/byacc-20140101/error.c"
void missing_brace(void) 
{ 


  {
  {
#line 31
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: e - line %d of \"%s\", missing \'}\'\n",
          myname, lineno, input_file_name);
#line 33
  done(1);
  }
#line 34
  return;
}
}
#line 36 "/home/june/collector/temp/byacc-20140101/error.c"
void unexpected_EOF(void) 
{ 


  {
  {
#line 39
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: e - line %d of \"%s\", unexpected end-of-file\n",
          myname, lineno, input_file_name);
#line 41
  done(1);
  }
#line 42
  return;
}
}
#line 44 "/home/june/collector/temp/byacc-20140101/error.c"
static void print_pos(char *st_line , char *st_cptr ) 
{ 
  char *s ;
  unsigned short const   **tmp ;

  {
#line 49
  if ((unsigned long )st_line == (unsigned long )((char *)0)) {
#line 50
    return;
  }
#line 51
  s = st_line;
  {
#line 51
  while (1) {
    while_continue: /* CIL Label */ ;
#line 51
    if (! ((int )*s != 10)) {
#line 51
      goto while_break;
    }
    {
#line 53
    tmp = __ctype_b_loc();
    }
#line 53
    if ((int const   )*(*tmp + (int )((unsigned char )*s)) & 16384) {
      {
#line 54
      _IO_putc((int )*s, stderr);
      }
    } else
#line 53
    if ((int )*s == 9) {
      {
#line 54
      _IO_putc((int )*s, stderr);
      }
    } else {
      {
#line 56
      _IO_putc('?', stderr);
      }
    }
#line 51
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 58
  _IO_putc('\n', stderr);
#line 59
  s = st_line;
  }
  {
#line 59
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 59
    if (! ((unsigned long )s < (unsigned long )st_cptr)) {
#line 59
      goto while_break___0;
    }
#line 61
    if ((int )*s == 9) {
      {
#line 62
      _IO_putc('\t', stderr);
      }
    } else {
      {
#line 64
      _IO_putc(' ', stderr);
      }
    }
#line 59
    s ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 66
  _IO_putc('^', stderr);
#line 67
  _IO_putc('\n', stderr);
  }
#line 68
  return;
}
}
#line 70 "/home/june/collector/temp/byacc-20140101/error.c"
void syntax_error(int st_lineno , char *st_line , char *st_cptr ) 
{ 


  {
  {
#line 73
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: e - line %d of \"%s\", syntax error\n",
          myname, st_lineno, input_file_name);
#line 75
  print_pos(st_line, st_cptr);
#line 76
  done(1);
  }
#line 77
  return;
}
}
#line 79 "/home/june/collector/temp/byacc-20140101/error.c"
void unterminated_comment(int c_lineno , char *c_line , char *c_cptr ) 
{ 


  {
  {
#line 82
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: e - line %d of \"%s\", unmatched /*\n",
          myname, c_lineno, input_file_name);
#line 84
  print_pos(c_line, c_cptr);
#line 85
  done(1);
  }
#line 86
  return;
}
}
#line 88 "/home/june/collector/temp/byacc-20140101/error.c"
void unterminated_string(int s_lineno , char *s_line , char *s_cptr ) 
{ 


  {
  {
#line 91
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: e - line %d of \"%s\", unterminated string\n",
          myname, s_lineno, input_file_name);
#line 93
  print_pos(s_line, s_cptr);
#line 94
  done(1);
  }
#line 95
  return;
}
}
#line 97 "/home/june/collector/temp/byacc-20140101/error.c"
void unterminated_text(int t_lineno , char *t_line , char *t_cptr ) 
{ 


  {
  {
#line 100
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: e - line %d of \"%s\", unmatched %%{\n",
          myname, t_lineno, input_file_name);
#line 102
  print_pos(t_line, t_cptr);
#line 103
  done(1);
  }
#line 104
  return;
}
}
#line 106 "/home/june/collector/temp/byacc-20140101/error.c"
void unterminated_union(int u_lineno , char *u_line , char *u_cptr ) 
{ 


  {
  {
#line 109
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: e - line %d of \"%s\", unterminated %%union declaration\n",
          myname, u_lineno, input_file_name);
#line 111
  print_pos(u_line, u_cptr);
#line 112
  done(1);
  }
#line 113
  return;
}
}
#line 115 "/home/june/collector/temp/byacc-20140101/error.c"
void over_unionized(char *u_cptr ) 
{ 


  {
  {
#line 118
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: e - line %d of \"%s\", too many %%union declarations\n",
          myname, lineno, input_file_name);
#line 120
  print_pos(line, u_cptr);
#line 121
  done(1);
  }
#line 122
  return;
}
}
#line 124 "/home/june/collector/temp/byacc-20140101/error.c"
void illegal_tag(int t_lineno , char *t_line , char *t_cptr ) 
{ 


  {
  {
#line 127
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: e - line %d of \"%s\", illegal tag\n",
          myname, t_lineno, input_file_name);
#line 129
  print_pos(t_line, t_cptr);
#line 130
  done(1);
  }
#line 131
  return;
}
}
#line 133 "/home/june/collector/temp/byacc-20140101/error.c"
void illegal_character(char *c_cptr ) 
{ 


  {
  {
#line 136
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: e - line %d of \"%s\", illegal character\n",
          myname, lineno, input_file_name);
#line 138
  print_pos(line, c_cptr);
#line 139
  done(1);
  }
#line 140
  return;
}
}
#line 142 "/home/june/collector/temp/byacc-20140101/error.c"
void used_reserved(char *s ) 
{ 


  {
  {
#line 145
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: e - line %d of \"%s\", illegal use of reserved symbol %s\n",
          myname, lineno, input_file_name, s);
#line 148
  done(1);
  }
#line 149
  return;
}
}
#line 151 "/home/june/collector/temp/byacc-20140101/error.c"
void tokenized_start(char *s ) 
{ 


  {
  {
#line 154
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: e - line %d of \"%s\", the start symbol %s cannot be declared to be a token\n",
          myname, lineno, input_file_name, s);
#line 157
  done(1);
  }
#line 158
  return;
}
}
#line 160 "/home/june/collector/temp/byacc-20140101/error.c"
void retyped_warning(char *s ) 
{ 


  {
  {
#line 163
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: w - line %d of \"%s\", the type of %s has been redeclared\n",
          myname, lineno, input_file_name, s);
  }
#line 165
  return;
}
}
#line 167 "/home/june/collector/temp/byacc-20140101/error.c"
void reprec_warning(char *s ) 
{ 


  {
  {
#line 170
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: w - line %d of \"%s\", the precedence of %s has been redeclared\n",
          myname, lineno, input_file_name, s);
  }
#line 173
  return;
}
}
#line 175 "/home/june/collector/temp/byacc-20140101/error.c"
void revalued_warning(char *s ) 
{ 


  {
  {
#line 178
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: w - line %d of \"%s\", the value of %s has been redeclared\n",
          myname, lineno, input_file_name, s);
  }
#line 180
  return;
}
}
#line 182 "/home/june/collector/temp/byacc-20140101/error.c"
void terminal_start(char *s ) 
{ 


  {
  {
#line 185
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: e - line %d of \"%s\", the start symbol %s is a token\n",
          myname, lineno, input_file_name, s);
#line 187
  done(1);
  }
#line 188
  return;
}
}
#line 190 "/home/june/collector/temp/byacc-20140101/error.c"
void restarted_warning(void) 
{ 


  {
  {
#line 193
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: w - line %d of \"%s\", the start symbol has been redeclared\n",
          myname, lineno, input_file_name);
  }
#line 195
  return;
}
}
#line 197 "/home/june/collector/temp/byacc-20140101/error.c"
void no_grammar(void) 
{ 


  {
  {
#line 200
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: e - line %d of \"%s\", no grammar has been specified\n",
          myname, lineno, input_file_name);
#line 202
  done(1);
  }
#line 203
  return;
}
}
#line 205 "/home/june/collector/temp/byacc-20140101/error.c"
void terminal_lhs(int s_lineno ) 
{ 


  {
  {
#line 208
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: e - line %d of \"%s\", a token appears on the lhs of a production\n",
          myname, s_lineno, input_file_name);
#line 210
  done(1);
  }
#line 211
  return;
}
}
#line 213 "/home/june/collector/temp/byacc-20140101/error.c"
void prec_redeclared(void) 
{ 


  {
  {
#line 216
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: w - line %d of  \"%s\", conflicting %%prec specifiers\n",
          myname, lineno, input_file_name);
  }
#line 218
  return;
}
}
#line 220 "/home/june/collector/temp/byacc-20140101/error.c"
void unterminated_action(int a_lineno , char *a_line , char *a_cptr ) 
{ 


  {
  {
#line 223
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: e - line %d of \"%s\", unterminated action\n",
          myname, a_lineno, input_file_name);
#line 225
  print_pos(a_line, a_cptr);
#line 226
  done(1);
  }
#line 227
  return;
}
}
#line 229 "/home/june/collector/temp/byacc-20140101/error.c"
void dollar_warning(int a_lineno , int i ) 
{ 


  {
  {
#line 232
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: w - line %d of \"%s\", $%d references beyond the end of the current rule\n",
          myname, a_lineno, input_file_name, i);
  }
#line 234
  return;
}
}
#line 236 "/home/june/collector/temp/byacc-20140101/error.c"
void dollar_error(int a_lineno , char *a_line , char *a_cptr ) 
{ 


  {
  {
#line 239
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: e - line %d of \"%s\", illegal $-name\n",
          myname, a_lineno, input_file_name);
#line 241
  print_pos(a_line, a_cptr);
#line 242
  done(1);
  }
#line 243
  return;
}
}
#line 245 "/home/june/collector/temp/byacc-20140101/error.c"
void untyped_lhs(void) 
{ 


  {
  {
#line 248
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: e - line %d of \"%s\", $$ is untyped\n",
          myname, lineno, input_file_name);
#line 250
  done(1);
  }
#line 251
  return;
}
}
#line 253 "/home/june/collector/temp/byacc-20140101/error.c"
void untyped_rhs(int i , char *s ) 
{ 


  {
  {
#line 256
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: e - line %d of \"%s\", $%d (%s) is untyped\n",
          myname, lineno, input_file_name, i, s);
#line 258
  done(1);
  }
#line 259
  return;
}
}
#line 261 "/home/june/collector/temp/byacc-20140101/error.c"
void unknown_rhs(int i ) 
{ 


  {
  {
#line 264
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: e - line %d of \"%s\", $%d is untyped\n",
          myname, lineno, input_file_name, i);
#line 266
  done(1);
  }
#line 267
  return;
}
}
#line 269 "/home/june/collector/temp/byacc-20140101/error.c"
void default_action_warning(void) 
{ 


  {
  {
#line 272
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: w - line %d of \"%s\", the default action assigns an undefined value to $$\n",
          myname, lineno, input_file_name);
  }
#line 275
  return;
}
}
#line 277 "/home/june/collector/temp/byacc-20140101/error.c"
void undefined_goal(char *s ) 
{ 


  {
  {
#line 280
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: e - the start symbol %s is undefined\n",
          myname, s);
#line 281
  done(1);
  }
#line 282
  return;
}
}
#line 284 "/home/june/collector/temp/byacc-20140101/error.c"
void undefined_symbol_warning(char *s ) 
{ 


  {
  {
#line 287
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: w - the symbol %s is undefined\n",
          myname, s);
  }
#line 288
  return;
}
}
#line 318 "/home/june/collector/temp/byacc-20140101/defs.h"
core **state_table ;
#line 445
void verbose(void) ;
#line 5 "/home/june/collector/temp/byacc-20140101/verbose.c"
static void log_conflicts(void) ;
#line 6
static void log_unused(void) ;
#line 7
static void print_actions(int stateno ) ;
#line 8
static void print_conflicts(int state ) ;
#line 9
static void print_core(int state ) ;
#line 10
static void print_gotos(int stateno ) ;
#line 11
static void print_nulls(int state ) ;
#line 12
static void print_shifts(action *p ) ;
#line 13
static void print_state(int state ) ;
#line 14
static void print_reductions(action *p , int defred2 ) ;
#line 16 "/home/june/collector/temp/byacc-20140101/verbose.c"
static short *null_rules  ;
#line 18 "/home/june/collector/temp/byacc-20140101/verbose.c"
void verbose(void) 
{ 
  int i ;
  void *tmp ;

  {
#line 23
  if (! vflag) {
#line 24
    return;
  }
  {
#line 26
  tmp = malloc((size_t )nrules * sizeof(short ));
#line 26
  null_rules = (short *)tmp;
  }
#line 27
  if ((unsigned long )null_rules == (unsigned long )((short *)0)) {
    {
#line 27
    no_space();
    }
  }
#line 27
  if (! ((unsigned long )null_rules != (unsigned long )((short *)0))) {
    {
#line 27
    __assert_fail("null_rules != 0", "/home/june/collector/temp/byacc-20140101/verbose.c",
                  27U, "verbose");
    }
  }
  {
#line 29
  fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)"\f\n");
#line 30
  i = 0;
  }
  {
#line 30
  while (1) {
    while_continue: /* CIL Label */ ;
#line 30
    if (! (i < nstates)) {
#line 30
      goto while_break;
    }
    {
#line 31
    print_state(i);
#line 30
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 32
  free((void *)((char *)null_rules));
  }
#line 34
  if (nunused) {
    {
#line 35
    log_unused();
    }
  }
#line 36
  if (SRtotal) {
    {
#line 37
    log_conflicts();
    }
  } else
#line 36
  if (RRtotal) {
    {
#line 37
    log_conflicts();
    }
  }
  {
#line 39
  fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)"\n\n%d terminals, %d nonterminals\n",
          ntokens, nvars);
#line 41
  fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)"%d grammar rules, %d states\n",
          nrules - 2, nstates);
  }
#line 42
  return;
}
}
#line 44 "/home/june/collector/temp/byacc-20140101/verbose.c"
static void log_unused(void) 
{ 
  int i ;
  short *p ;

  {
  {
#line 50
  fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)"\n\nRules never reduced:\n");
#line 51
  i = 3;
  }
  {
#line 51
  while (1) {
    while_continue: /* CIL Label */ ;
#line 51
    if (! (i < nrules)) {
#line 51
      goto while_break;
    }
#line 53
    if (! *(rules_used + i)) {
      {
#line 55
      fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)"\t%s :",
              *(symbol_name + *(rlhs + i)));
#line 56
      p = ritem + (int )*(rrhs + i);
      }
      {
#line 56
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 56
        if (! ((int )*p >= 0)) {
#line 56
          goto while_break___0;
        }
        {
#line 57
        fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)" %s",
                *(symbol_name + *p));
#line 56
        p ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 58
      fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)"  (%d)\n",
              i - 2);
      }
    }
#line 51
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 61
  return;
}
}
#line 63 "/home/june/collector/temp/byacc-20140101/verbose.c"
static void log_conflicts(void) 
{ 
  int i ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 68
  fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)"\n\n");
#line 69
  i = 0;
  }
  {
#line 69
  while (1) {
    while_continue: /* CIL Label */ ;
#line 69
    if (! (i < nstates)) {
#line 69
      goto while_break;
    }
#line 71
    if (*(SRconflicts + i)) {
#line 71
      goto _L;
    } else
#line 71
    if (*(RRconflicts + i)) {
      _L: /* CIL Label */ 
      {
#line 73
      fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)"State %d contains ",
              i);
      }
#line 74
      if ((int )*(SRconflicts + i) > 0) {
#line 75
        if ((int )*(SRconflicts + i) > 1) {
#line 75
          tmp = "s";
        } else {
#line 75
          tmp = "";
        }
        {
#line 75
        fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)"%d shift/reduce conflict%s",
                (int )*(SRconflicts + i), tmp);
        }
      }
#line 78
      if (*(SRconflicts + i)) {
#line 78
        if (*(RRconflicts + i)) {
          {
#line 79
          fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)", ");
          }
        }
      }
#line 80
      if ((int )*(RRconflicts + i) > 0) {
#line 81
        if ((int )*(RRconflicts + i) > 1) {
#line 81
          tmp___0 = "s";
        } else {
#line 81
          tmp___0 = "";
        }
        {
#line 81
        fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)"%d reduce/reduce conflict%s",
                (int )*(RRconflicts + i), tmp___0);
        }
      }
      {
#line 84
      fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)".\n");
      }
    }
#line 69
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 87
  return;
}
}
#line 89 "/home/june/collector/temp/byacc-20140101/verbose.c"
static void print_state(int state ) 
{ 


  {
#line 92
  if (state) {
    {
#line 93
    fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)"\n\n");
    }
  }
#line 94
  if (*(SRconflicts + state)) {
    {
#line 95
    print_conflicts(state);
    }
  } else
#line 94
  if (*(RRconflicts + state)) {
    {
#line 95
    print_conflicts(state);
    }
  }
  {
#line 96
  fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)"state %d\n",
          state);
#line 97
  print_core(state);
#line 98
  print_nulls(state);
#line 99
  print_actions(state);
  }
#line 100
  return;
}
}
#line 102 "/home/june/collector/temp/byacc-20140101/verbose.c"
static void print_conflicts(int state ) 
{ 
  int symbol ;
  int act ;
  int number ;
  action *p ;

  {
#line 108
  act = 0;
#line 109
  number = -1;
#line 110
  symbol = -1;
#line 111
  p = *(parser + state);
  {
#line 111
  while (1) {
    while_continue: /* CIL Label */ ;
#line 111
    if (! p) {
#line 111
      goto while_break;
    }
#line 113
    if ((int )p->suppressed == 2) {
#line 114
      goto __Cont;
    }
#line 116
    if ((int )p->symbol != symbol) {
#line 118
      symbol = (int )p->symbol;
#line 119
      number = (int )p->number;
#line 120
      if ((int )p->action_code == 1) {
#line 121
        act = 1;
      } else {
#line 123
        act = 2;
      }
    } else
#line 125
    if ((int )p->suppressed == 1) {
#line 127
      if (state == (int )final_state) {
#line 127
        if (symbol == 0) {
          {
#line 129
          fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)"%d: shift/reduce conflict (accept, reduce %d) on $end\n",
                  state, (int )p->number - 2);
          }
        } else {
#line 127
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 134
      if (act == 1) {
        {
#line 136
        fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)"%d: shift/reduce conflict (shift %d, reduce %d) on %s\n",
                state, number, (int )p->number - 2, *(symbol_name + symbol));
        }
      } else {
        {
#line 142
        fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)"%d: reduce/reduce conflict (reduce %d, reduce %d) on %s\n",
                state, number - 2, (int )p->number - 2, *(symbol_name + symbol));
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 111
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 149
  return;
}
}
#line 151 "/home/june/collector/temp/byacc-20140101/verbose.c"
static void print_core(int state ) 
{ 
  int i ;
  int k ;
  int rule ;
  core *statep ;
  short *sp ;
  short *sp1 ;

  {
#line 161
  statep = *(state_table + state);
#line 162
  k = (int )statep->nitems;
#line 164
  i = 0;
  {
#line 164
  while (1) {
    while_continue: /* CIL Label */ ;
#line 164
    if (! (i < k)) {
#line 164
      goto while_break;
    }
#line 166
    sp = ritem + (int )statep->items[i];
#line 166
    sp1 = sp;
    {
#line 168
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 168
      if (! ((int )*sp >= 0)) {
#line 168
        goto while_break___0;
      }
#line 169
      sp ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 170
    rule = - ((int )*sp);
#line 171
    fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)"\t%s : ",
            *(symbol_name + *(rlhs + rule)));
#line 173
    sp = ritem + (int )*(rrhs + rule);
    }
    {
#line 173
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 173
      if (! ((unsigned long )sp < (unsigned long )sp1)) {
#line 173
        goto while_break___1;
      }
      {
#line 174
      fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)"%s ",
              *(symbol_name + *sp));
#line 173
      sp ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 176
    _IO_putc('.', verbose_file);
    }
    {
#line 178
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 178
      if (! ((int )*sp >= 0)) {
#line 178
        goto while_break___2;
      }
      {
#line 180
      fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)" %s",
              *(symbol_name + *sp));
#line 181
      sp ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 183
    fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)"  (%d)\n",
            -2 - (int )*sp);
#line 164
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 185
  return;
}
}
#line 187 "/home/june/collector/temp/byacc-20140101/verbose.c"
static void print_nulls(int state ) 
{ 
  action *p ;
  Value_t i ;
  Value_t j ;
  Value_t k ;
  Value_t nnulls ;

  {
#line 193
  nnulls = (Value_t )0;
#line 194
  p = *(parser + state);
  {
#line 194
  while (1) {
    while_continue: /* CIL Label */ ;
#line 194
    if (! p) {
#line 194
      goto while_break;
    }
#line 196
    if ((int )p->action_code == 2) {
#line 196
      if ((int )p->suppressed == 0) {
#line 196
        goto _L;
      } else
#line 196
      if ((int )p->suppressed == 1) {
        _L: /* CIL Label */ 
#line 199
        i = p->number;
#line 200
        if ((int )*(rrhs + i) + 1 == (int )*(rrhs + ((int )i + 1))) {
#line 202
          j = (Value_t )0;
          {
#line 202
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 202
            if ((int )j < (int )nnulls) {
#line 202
              if (! ((int )i > (int )*(null_rules + j))) {
#line 202
                goto while_break___0;
              }
            } else {
#line 202
              goto while_break___0;
            }
#line 203
            goto __Cont;
            __Cont: /* CIL Label */ 
#line 202
            j = (Value_t )((int )j + 1);
          }
          while_break___0: /* CIL Label */ ;
          }
#line 205
          if ((int )j == (int )nnulls) {
#line 207
            nnulls = (Value_t )((int )nnulls + 1);
#line 208
            *(null_rules + j) = i;
          } else
#line 210
          if ((int )i != (int )*(null_rules + j)) {
#line 212
            nnulls = (Value_t )((int )nnulls + 1);
#line 213
            k = (Value_t )((int )nnulls - 1);
            {
#line 213
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 213
              if (! ((int )k > (int )j)) {
#line 213
                goto while_break___1;
              }
#line 214
              *(null_rules + k) = *(null_rules + ((int )k - 1));
#line 213
              k = (Value_t )((int )k - 1);
            }
            while_break___1: /* CIL Label */ ;
            }
#line 215
            *(null_rules + j) = i;
          }
        }
      }
    }
#line 194
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 221
  i = (Value_t )0;
  {
#line 221
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 221
    if (! ((int )i < (int )nnulls)) {
#line 221
      goto while_break___2;
    }
    {
#line 223
    j = *(null_rules + i);
#line 224
    fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)"\t%s : .  (%d)\n",
            *(symbol_name + *(rlhs + j)), (int )j - 2);
#line 221
    i = (Value_t )((int )i + 1);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 227
  fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)"\n");
  }
#line 228
  return;
}
}
#line 230 "/home/june/collector/temp/byacc-20140101/verbose.c"
static void print_actions(int stateno ) 
{ 
  action *p ;
  shifts *sp ;
  int as ;

  {
#line 237
  if (stateno == (int )final_state) {
    {
#line 238
    fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)"\t$end  accept\n");
    }
  }
#line 240
  p = *(parser + stateno);
#line 241
  if (p) {
    {
#line 243
    print_shifts(p);
#line 244
    print_reductions(p, (int )*(defred + stateno));
    }
  }
#line 247
  sp = *(shift_table + stateno);
#line 248
  if (sp) {
#line 248
    if ((int )sp->nshifts > 0) {
#line 250
      as = (int )*(accessing_symbol + sp->shift[(int )sp->nshifts - 1]);
#line 251
      if (as >= (int )start_symbol) {
        {
#line 252
        print_gotos(stateno);
        }
      }
    }
  }
#line 254
  return;
}
}
#line 256 "/home/june/collector/temp/byacc-20140101/verbose.c"
static void print_shifts(action *p ) 
{ 
  int count ;
  action *q ;

  {
#line 262
  count = 0;
#line 263
  q = p;
  {
#line 263
  while (1) {
    while_continue: /* CIL Label */ ;
#line 263
    if (! q) {
#line 263
      goto while_break;
    }
#line 265
    if ((int )q->suppressed < 2) {
#line 265
      if ((int )q->action_code == 1) {
#line 266
        count ++;
      }
    }
#line 263
    q = q->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 269
  if (count > 0) {
    {
#line 271
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 271
      if (! p) {
#line 271
        goto while_break___0;
      }
#line 273
      if ((int )p->action_code == 1) {
#line 273
        if ((int )p->suppressed == 0) {
          {
#line 274
          fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)"\t%s  shift %d\n",
                  *(symbol_name + p->symbol), (int )p->number);
          }
        }
      }
#line 271
      p = p->next;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 278
  return;
}
}
#line 280 "/home/june/collector/temp/byacc-20140101/verbose.c"
static void print_reductions(action *p , int defred2 ) 
{ 
  int k ;
  int anyreds ;
  action *q ;

  {
#line 286
  anyreds = 0;
#line 287
  q = p;
  {
#line 287
  while (1) {
    while_continue: /* CIL Label */ ;
#line 287
    if (! q) {
#line 287
      goto while_break;
    }
#line 289
    if ((int )q->action_code == 2) {
#line 289
      if ((int )q->suppressed < 2) {
#line 291
        anyreds = 1;
#line 292
        goto while_break;
      }
    }
#line 287
    q = q->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 296
  if (anyreds == 0) {
    {
#line 297
    fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)"\t.  error\n");
    }
  } else {
    {
#line 300
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 300
      if (! p) {
#line 300
        goto while_break___0;
      }
#line 302
      if ((int )p->action_code == 2) {
#line 302
        if ((int )p->number != defred2) {
#line 304
          k = (int )p->number - 2;
#line 305
          if ((int )p->suppressed == 0) {
            {
#line 306
            fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)"\t%s  reduce %d\n",
                    *(symbol_name + p->symbol), k);
            }
          }
        }
      }
#line 300
      p = p->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 311
    if (defred2 > 0) {
      {
#line 312
      fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)"\t.  reduce %d\n",
              defred2 - 2);
      }
    }
  }
#line 314
  return;
}
}
#line 316 "/home/june/collector/temp/byacc-20140101/verbose.c"
static void print_gotos(int stateno ) 
{ 
  int i ;
  int k ;
  int as ;
  short *to_state2 ;
  shifts *sp ;

  {
  {
#line 324
  _IO_putc('\n', verbose_file);
#line 325
  sp = *(shift_table + stateno);
#line 326
  to_state2 = sp->shift;
#line 327
  i = 0;
  }
  {
#line 327
  while (1) {
    while_continue: /* CIL Label */ ;
#line 327
    if (! (i < (int )sp->nshifts)) {
#line 327
      goto while_break;
    }
#line 329
    k = (int )*(to_state2 + i);
#line 330
    as = (int )*(accessing_symbol + k);
#line 331
    if (as >= (int )start_symbol) {
      {
#line 332
      fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)"\t%s  goto %d\n",
              *(symbol_name + as), k);
      }
    }
#line 327
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 334
  return;
}
}
#line 310 "/home/june/collector/temp/byacc-20140101/defs.h"
bucket *first_symbol  ;
#line 311 "/home/june/collector/temp/byacc-20140101/defs.h"
bucket *last_symbol  ;
#line 10 "/home/june/collector/temp/byacc-20140101/symtab.c"
static bucket **symbol_table  =    (bucket **)0;
#line 14 "/home/june/collector/temp/byacc-20140101/symtab.c"
static int hash(char const   *name ) 
{ 
  char const   *s ;
  int c ;
  int k ;

  {
#line 20
  if (name) {
#line 20
    if (! *name) {
      {
#line 20
      __assert_fail("name && *name", "/home/june/collector/temp/byacc-20140101/symtab.c",
                    20U, "hash");
      }
    }
  } else {
    {
#line 20
    __assert_fail("name && *name", "/home/june/collector/temp/byacc-20140101/symtab.c",
                  20U, "hash");
    }
  }
#line 21
  s = name;
#line 22
  k = (int )*s;
  {
#line 23
  while (1) {
    while_continue: /* CIL Label */ ;
#line 23
    s ++;
#line 23
    c = (int )*s;
#line 23
    if (! (c != 0)) {
#line 23
      goto while_break;
    }
#line 24
    k = (31 * k + c) & 1023;
  }
  while_break: /* CIL Label */ ;
  }
#line 26
  return (k);
}
}
#line 29 "/home/june/collector/temp/byacc-20140101/symtab.c"
bucket *make_bucket(char const   *name ) 
{ 
  bucket *bp ;
  void *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
#line 34
  if (! ((unsigned long )name != (unsigned long )((char const   *)0))) {
    {
#line 34
    __assert_fail("name != 0", "/home/june/collector/temp/byacc-20140101/symtab.c",
                  34U, "make_bucket");
    }
  }
  {
#line 36
  tmp = malloc(sizeof(bucket ));
#line 36
  bp = (bucket *)tmp;
  }
#line 37
  if ((unsigned long )bp == (unsigned long )((bucket *)0)) {
    {
#line 37
    no_space();
    }
  }
#line 37
  if (! ((unsigned long )bp != (unsigned long )((bucket *)0))) {
    {
#line 37
    __assert_fail("bp != 0", "/home/june/collector/temp/byacc-20140101/symtab.c",
                  37U, "make_bucket");
    }
  }
  {
#line 39
  bp->link = (struct bucket *)0;
#line 40
  bp->next = (struct bucket *)0;
#line 42
  tmp___0 = strlen(name);
#line 42
  tmp___1 = malloc((tmp___0 + 1UL) * sizeof(char ));
#line 42
  bp->name = (char *)tmp___1;
  }
#line 43
  if ((unsigned long )bp->name == (unsigned long )((char *)0)) {
    {
#line 43
    no_space();
    }
  }
#line 43
  if (! ((unsigned long )bp->name != (unsigned long )((char *)0))) {
    {
#line 43
    __assert_fail("bp->name != 0", "/home/june/collector/temp/byacc-20140101/symtab.c",
                  43U, "make_bucket");
    }
  }
  {
#line 45
  bp->tag = (char *)0;
#line 46
  bp->value = (Value_t )-1;
#line 47
  bp->index = (Index_t )0;
#line 48
  bp->prec = (Value_t )0;
#line 49
  bp->class = (Class_t )0;
#line 50
  bp->assoc = (Assoc_t )0;
#line 51
  strcpy((char */* __restrict  */)bp->name, (char const   */* __restrict  */)name);
  }
#line 53
  return (bp);
}
}
#line 56 "/home/june/collector/temp/byacc-20140101/symtab.c"
bucket *lookup(char const   *name ) 
{ 
  bucket *bp ;
  bucket **bpp ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 61
  tmp = hash(name);
#line 61
  bpp = symbol_table + tmp;
#line 62
  bp = *bpp;
  }
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
#line 64
    if (! bp) {
#line 64
      goto while_break;
    }
    {
#line 66
    tmp___0 = strcmp(name, (char const   *)bp->name);
    }
#line 66
    if (tmp___0 == 0) {
#line 67
      return (bp);
    }
#line 68
    bpp = & bp->link;
#line 69
    bp = *bpp;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 72
  bp = make_bucket(name);
#line 72
  *bpp = bp;
#line 73
  last_symbol->next = bp;
#line 74
  last_symbol = bp;
  }
#line 76
  return (bp);
}
}
#line 79 "/home/june/collector/temp/byacc-20140101/symtab.c"
void create_symbol_table(void) 
{ 
  int i ;
  bucket *bp ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 85
  tmp = malloc(1024UL * sizeof(bucket *));
#line 85
  symbol_table = (bucket **)tmp;
  }
#line 86
  if ((unsigned long )symbol_table == (unsigned long )((bucket **)0)) {
    {
#line 86
    no_space();
    }
  }
#line 86
  if (! ((unsigned long )symbol_table != (unsigned long )((bucket **)0))) {
    {
#line 86
    __assert_fail("symbol_table != 0", "/home/june/collector/temp/byacc-20140101/symtab.c",
                  86U, "create_symbol_table");
    }
  }
#line 88
  i = 0;
  {
#line 88
  while (1) {
    while_continue: /* CIL Label */ ;
#line 88
    if (! (i < 1024)) {
#line 88
      goto while_break;
    }
#line 89
    *(symbol_table + i) = (bucket *)0;
#line 88
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 91
  bp = make_bucket("error");
#line 92
  bp->index = (Index_t )1;
#line 93
  bp->class = (Class_t )1;
#line 95
  first_symbol = bp;
#line 96
  last_symbol = bp;
#line 97
  tmp___0 = hash("error");
#line 97
  *(symbol_table + tmp___0) = bp;
  }
#line 98
  return;
}
}
#line 100 "/home/june/collector/temp/byacc-20140101/symtab.c"
void free_symbol_table(void) 
{ 


  {
  {
#line 103
  free((void *)((char *)symbol_table));
#line 104
  symbol_table = (bucket **)0;
  }
#line 105
  return;
}
}
#line 107 "/home/june/collector/temp/byacc-20140101/symtab.c"
void free_symbols(void) 
{ 
  bucket *p ;
  bucket *q ;

  {
#line 112
  p = first_symbol;
  {
#line 112
  while (1) {
    while_continue: /* CIL Label */ ;
#line 112
    if (! p) {
#line 112
      goto while_break;
    }
    {
#line 114
    q = p->next;
#line 115
    free((void *)((char *)p));
#line 112
    p = q;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 117
  return;
}
}
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 287 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *__name ,
                                                                                             int __type ) ;
#line 603
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 468 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 519
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atexit)(void (*__func)(void) ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 620
extern int ( __attribute__((__nonnull__(1))) mkstemp)(char *__template ) ;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 306
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 235 "/home/june/collector/temp/byacc-20140101/defs.h"
char dflag  ;
#line 236 "/home/june/collector/temp/byacc-20140101/defs.h"
char gflag  ;
#line 237 "/home/june/collector/temp/byacc-20140101/defs.h"
char iflag  ;
#line 238 "/home/june/collector/temp/byacc-20140101/defs.h"
char lflag  ;
#line 239 "/home/june/collector/temp/byacc-20140101/defs.h"
char rflag  ;
#line 240 "/home/june/collector/temp/byacc-20140101/defs.h"
char sflag  ;
#line 241 "/home/june/collector/temp/byacc-20140101/defs.h"
char tflag  ;
#line 242 "/home/june/collector/temp/byacc-20140101/defs.h"
char vflag  ;
#line 243 "/home/june/collector/temp/byacc-20140101/defs.h"
char const   *symbol_prefix  ;
#line 248 "/home/june/collector/temp/byacc-20140101/defs.h"
int lineno  ;
#line 249 "/home/june/collector/temp/byacc-20140101/defs.h"
int outline  ;
#line 250 "/home/june/collector/temp/byacc-20140101/defs.h"
int exit_code  ;
#line 251 "/home/june/collector/temp/byacc-20140101/defs.h"
int pure_parser  ;
#line 252 "/home/june/collector/temp/byacc-20140101/defs.h"
int token_table  ;
#line 268 "/home/june/collector/temp/byacc-20140101/defs.h"
char *code_file_name  ;
#line 270 "/home/june/collector/temp/byacc-20140101/defs.h"
char *defines_file_name  ;
#line 271 "/home/june/collector/temp/byacc-20140101/defs.h"
char *externs_file_name  ;
#line 273 "/home/june/collector/temp/byacc-20140101/defs.h"
FILE *action_file  ;
#line 274 "/home/june/collector/temp/byacc-20140101/defs.h"
FILE *code_file  ;
#line 275 "/home/june/collector/temp/byacc-20140101/defs.h"
FILE *defines_file  ;
#line 276 "/home/june/collector/temp/byacc-20140101/defs.h"
FILE *externs_file  ;
#line 277 "/home/june/collector/temp/byacc-20140101/defs.h"
FILE *input_file  ;
#line 278 "/home/june/collector/temp/byacc-20140101/defs.h"
FILE *output_file  ;
#line 279 "/home/june/collector/temp/byacc-20140101/defs.h"
FILE *text_file  ;
#line 280 "/home/june/collector/temp/byacc-20140101/defs.h"
FILE *union_file  ;
#line 281 "/home/june/collector/temp/byacc-20140101/defs.h"
FILE *verbose_file  ;
#line 282 "/home/june/collector/temp/byacc-20140101/defs.h"
FILE *graph_file  ;
#line 284 "/home/june/collector/temp/byacc-20140101/defs.h"
int nitems  ;
#line 285 "/home/june/collector/temp/byacc-20140101/defs.h"
int nrules  ;
#line 286 "/home/june/collector/temp/byacc-20140101/defs.h"
int nsyms  ;
#line 287 "/home/june/collector/temp/byacc-20140101/defs.h"
int ntokens  ;
#line 288 "/home/june/collector/temp/byacc-20140101/defs.h"
int nvars  ;
#line 294 "/home/june/collector/temp/byacc-20140101/defs.h"
Value_t start_symbol  ;
#line 295 "/home/june/collector/temp/byacc-20140101/defs.h"
char **symbol_name  ;
#line 296 "/home/june/collector/temp/byacc-20140101/defs.h"
char **symbol_pname  ;
#line 297 "/home/june/collector/temp/byacc-20140101/defs.h"
Value_t *symbol_value  ;
#line 298 "/home/june/collector/temp/byacc-20140101/defs.h"
short *symbol_prec  ;
#line 299 "/home/june/collector/temp/byacc-20140101/defs.h"
char *symbol_assoc  ;
#line 301 "/home/june/collector/temp/byacc-20140101/defs.h"
Value_t *ritem  ;
#line 302 "/home/june/collector/temp/byacc-20140101/defs.h"
Value_t *rlhs  ;
#line 303 "/home/june/collector/temp/byacc-20140101/defs.h"
Value_t *rrhs  ;
#line 304 "/home/june/collector/temp/byacc-20140101/defs.h"
Value_t *rprec  ;
#line 305 "/home/june/collector/temp/byacc-20140101/defs.h"
Assoc_t *rassoc  ;
#line 307 "/home/june/collector/temp/byacc-20140101/defs.h"
Value_t **derives  ;
#line 308 "/home/june/collector/temp/byacc-20140101/defs.h"
char *nullable  ;
#line 372
void finalize_closure(void) ;
#line 410
void graph(void) ;
#line 418
void lalr(void) ;
#line 421
void lr0(void) ;
#line 436
void output(void) ;
#line 284 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chmod)(char const   *__file ,
                                                                                            __mode_t __mode ) ;
#line 28 "/home/june/collector/temp/byacc-20140101/main.c"
static MY_TMPFILES *my_tmpfiles  ;
#line 35 "/home/june/collector/temp/byacc-20140101/main.c"
static char oflag  ;
#line 42 "/home/june/collector/temp/byacc-20140101/main.c"
char const   *myname  =    "yacc";
#line 47 "/home/june/collector/temp/byacc-20140101/main.c"
static char empty_string[1]  = {      (char )'\000'};
#line 48 "/home/june/collector/temp/byacc-20140101/main.c"
static char default_file_prefix[2]  = {      (char )'y',      (char )'\000'};
#line 50 "/home/june/collector/temp/byacc-20140101/main.c"
static char *file_prefix  =    default_file_prefix;
#line 53 "/home/june/collector/temp/byacc-20140101/main.c"
char *input_file_name  =    empty_string;
#line 57 "/home/june/collector/temp/byacc-20140101/main.c"
static char *graph_file_name  ;
#line 58 "/home/june/collector/temp/byacc-20140101/main.c"
static char *output_file_name  ;
#line 59 "/home/june/collector/temp/byacc-20140101/main.c"
static char *verbose_file_name  ;
#line 112 "/home/june/collector/temp/byacc-20140101/main.c"
static int got_intr  =    0;
#line 114 "/home/june/collector/temp/byacc-20140101/main.c"
void done(int k ) 
{ 
  FILE *use ;
  FILE *use___0 ;
  FILE *use___1 ;
  FILE *use___2 ;
  FILE *use___3 ;
  FILE *use___4 ;
  FILE *use___5 ;
  FILE *use___6 ;
  FILE *use___7 ;

  {
#line 117
  if ((unsigned long )input_file != (unsigned long )((FILE *)0)) {
    {
#line 117
    use = input_file;
#line 117
    input_file = (FILE *)0;
#line 117
    fclose(use);
    }
  }
#line 118
  if ((unsigned long )output_file != (unsigned long )((FILE *)0)) {
    {
#line 118
    use___0 = output_file;
#line 118
    output_file = (FILE *)0;
#line 118
    fclose(use___0);
    }
  }
#line 120
  if ((unsigned long )action_file != (unsigned long )((FILE *)0)) {
    {
#line 120
    use___1 = action_file;
#line 120
    action_file = (FILE *)0;
#line 120
    fclose(use___1);
    }
  }
#line 121
  if ((unsigned long )defines_file != (unsigned long )((FILE *)0)) {
    {
#line 121
    use___2 = defines_file;
#line 121
    defines_file = (FILE *)0;
#line 121
    fclose(use___2);
    }
  }
#line 122
  if ((unsigned long )graph_file != (unsigned long )((FILE *)0)) {
    {
#line 122
    use___3 = graph_file;
#line 122
    graph_file = (FILE *)0;
#line 122
    fclose(use___3);
    }
  }
#line 123
  if ((unsigned long )text_file != (unsigned long )((FILE *)0)) {
    {
#line 123
    use___4 = text_file;
#line 123
    text_file = (FILE *)0;
#line 123
    fclose(use___4);
    }
  }
#line 124
  if ((unsigned long )union_file != (unsigned long )((FILE *)0)) {
    {
#line 124
    use___5 = union_file;
#line 124
    union_file = (FILE *)0;
#line 124
    fclose(use___5);
    }
  }
#line 125
  if ((unsigned long )verbose_file != (unsigned long )((FILE *)0)) {
    {
#line 125
    use___6 = verbose_file;
#line 125
    verbose_file = (FILE *)0;
#line 125
    fclose(use___6);
    }
  }
#line 127
  if (got_intr) {
    {
#line 128
    _exit(1);
    }
  }
#line 156
  if (rflag) {
#line 157
    if ((unsigned long )code_file != (unsigned long )((FILE *)0)) {
      {
#line 157
      use___7 = code_file;
#line 157
      code_file = (FILE *)0;
#line 157
      fclose(use___7);
      }
    }
  }
  {
#line 159
  exit(k);
  }
}
}
#line 162 "/home/june/collector/temp/byacc-20140101/main.c"
static void onintr(int sig ) 
{ 


  {
  {
#line 165
  got_intr = 1;
#line 166
  done(1);
  }
#line 167
  return;
}
}
#line 169 "/home/june/collector/temp/byacc-20140101/main.c"
static void set_signals(void) 
{ 
  __sighandler_t tmp ;
  __sighandler_t tmp___0 ;
  __sighandler_t tmp___1 ;

  {
  {
#line 173
  tmp = signal(2, (void (*)(int  ))1);
  }
#line 173
  if ((unsigned long )tmp != (unsigned long )((void (*)(int  ))1)) {
    {
#line 174
    signal(2, & onintr);
    }
  }
  {
#line 177
  tmp___0 = signal(15, (void (*)(int  ))1);
  }
#line 177
  if ((unsigned long )tmp___0 != (unsigned long )((void (*)(int  ))1)) {
    {
#line 178
    signal(15, & onintr);
    }
  }
  {
#line 181
  tmp___1 = signal(1, (void (*)(int  ))1);
  }
#line 181
  if ((unsigned long )tmp___1 != (unsigned long )((void (*)(int  ))1)) {
    {
#line 182
    signal(1, & onintr);
    }
  }
#line 184
  return;
}
}
#line 189
static void usage(void) ;
#line 189 "/home/june/collector/temp/byacc-20140101/main.c"
static char const   *msg[15]  = 
#line 189
  {      "",      "Options:",      "  -b file_prefix        set filename prefix (default \"y.\")",      "  -d                    write definitions (y.tab.h)", 
        "  -i                    write interface (y.tab.i)",      "  -g                    write a graphical description",      "  -l                    suppress #line directives",      "  -o output_file        (default \"y.tab.c\")", 
        "  -p symbol_prefix      set symbol prefix (default \"yy\")",      "  -P                    create a reentrant parser, e.g., \"%pure-parser\"",      "  -r                    produce separate code and table files (y.code.c)",      "  -s                    suppress #define\'s for quoted names in %token lines", 
        "  -t                    add debugging support",      "  -v                    write description (y.output)",      "  -V                    show version information and exit"};
#line 186 "/home/june/collector/temp/byacc-20140101/main.c"
static void usage(void) 
{ 
  unsigned int n ;

  {
  {
#line 209
  fflush(stdout);
#line 210
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: %s [options] filename\n",
          myname);
#line 211
  n = 0U;
  }
  {
#line 211
  while (1) {
    while_continue: /* CIL Label */ ;
#line 211
    if (! ((unsigned long )n < sizeof(msg) / sizeof(msg[0]))) {
#line 211
      goto while_break;
    }
    {
#line 212
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
            msg[n]);
#line 211
    n ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 214
  exit(1);
  }
}
}
#line 217 "/home/june/collector/temp/byacc-20140101/main.c"
static void setflag(int ch ) 
{ 


  {
  {
#line 222
  if (ch == 100) {
#line 222
    goto case_100;
  }
#line 226
  if (ch == 103) {
#line 226
    goto case_103;
  }
#line 230
  if (ch == 105) {
#line 230
    goto case_105;
  }
#line 234
  if (ch == 108) {
#line 234
    goto case_108;
  }
#line 238
  if (ch == 80) {
#line 238
    goto case_80;
  }
#line 242
  if (ch == 114) {
#line 242
    goto case_114;
  }
#line 246
  if (ch == 115) {
#line 246
    goto case_115;
  }
#line 250
  if (ch == 116) {
#line 250
    goto case_116;
  }
#line 254
  if (ch == 118) {
#line 254
    goto case_118;
  }
#line 258
  if (ch == 86) {
#line 258
    goto case_86;
  }
#line 262
  if (ch == 121) {
#line 262
    goto case_121;
  }
#line 267
  goto switch_default;
  case_100: /* CIL Label */ 
#line 223
  dflag = (char)1;
#line 224
  goto switch_break;
  case_103: /* CIL Label */ 
#line 227
  gflag = (char)1;
#line 228
  goto switch_break;
  case_105: /* CIL Label */ 
#line 231
  iflag = (char)1;
#line 232
  goto switch_break;
  case_108: /* CIL Label */ 
#line 235
  lflag = (char)1;
#line 236
  goto switch_break;
  case_80: /* CIL Label */ 
#line 239
  pure_parser = 1;
#line 240
  goto switch_break;
  case_114: /* CIL Label */ 
#line 243
  rflag = (char)1;
#line 244
  goto switch_break;
  case_115: /* CIL Label */ 
#line 247
  sflag = (char)1;
#line 248
  goto switch_break;
  case_116: /* CIL Label */ 
#line 251
  tflag = (char)1;
#line 252
  goto switch_break;
  case_118: /* CIL Label */ 
#line 255
  vflag = (char)1;
#line 256
  goto switch_break;
  case_86: /* CIL Label */ 
  {
#line 259
  printf((char const   */* __restrict  */)"%s - %s\n", myname, "1.9 20140101");
#line 260
  exit(0);
  }
  case_121: /* CIL Label */ 
#line 265
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 268
  usage();
  }
  switch_break: /* CIL Label */ ;
  }
#line 270
  return;
}
}
#line 272 "/home/june/collector/temp/byacc-20140101/main.c"
static void getargs(int argc , char **argv ) 
{ 
  int i ;
  char *s ;
  int ch ;

  {
#line 279
  if (argc > 0) {
#line 280
    myname = (char const   *)*(argv + 0);
  }
#line 282
  i = 1;
  {
#line 282
  while (1) {
    while_continue: /* CIL Label */ ;
#line 282
    if (! (i < argc)) {
#line 282
      goto while_break;
    }
#line 284
    s = *(argv + i);
#line 285
    if ((int )*s != 45) {
#line 286
      goto while_break;
    }
#line 287
    s ++;
#line 287
    ch = (int )*s;
    {
#line 289
    if (ch == 0) {
#line 289
      goto case_0;
    }
#line 295
    if (ch == 45) {
#line 295
      goto case_45;
    }
#line 299
    if (ch == 98) {
#line 299
      goto case_98;
    }
#line 308
    if (ch == 111) {
#line 308
      goto case_111;
    }
#line 317
    if (ch == 112) {
#line 317
      goto case_112;
    }
#line 326
    goto switch_default;
    case_0: /* CIL Label */ 
#line 290
    input_file = stdin;
#line 291
    if (i + 1 < argc) {
      {
#line 292
      usage();
      }
    }
#line 293
    return;
    case_45: /* CIL Label */ 
#line 296
    i ++;
#line 297
    goto no_more_options;
    case_98: /* CIL Label */ 
#line 300
    s ++;
#line 300
    if (*s) {
#line 301
      file_prefix = s;
    } else {
#line 302
      i ++;
#line 302
      if (i < argc) {
#line 303
        file_prefix = *(argv + i);
      } else {
        {
#line 305
        usage();
        }
      }
    }
#line 306
    goto __Cont;
    case_111: /* CIL Label */ 
#line 309
    s ++;
#line 309
    if (*s) {
#line 310
      output_file_name = s;
    } else {
#line 311
      i ++;
#line 311
      if (i < argc) {
#line 312
        output_file_name = *(argv + i);
      } else {
        {
#line 314
        usage();
        }
      }
    }
#line 315
    goto __Cont;
    case_112: /* CIL Label */ 
#line 318
    s ++;
#line 318
    if (*s) {
#line 319
      symbol_prefix = (char const   *)s;
    } else {
#line 320
      i ++;
#line 320
      if (i < argc) {
#line 321
        symbol_prefix = (char const   *)*(argv + i);
      } else {
        {
#line 323
        usage();
        }
      }
    }
#line 324
    goto __Cont;
    switch_default: /* CIL Label */ 
    {
#line 327
    setflag(ch);
    }
#line 328
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 331
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 333
      s ++;
#line 333
      ch = (int )*s;
      {
#line 335
      if (ch == 0) {
#line 335
        goto case_0___0;
      }
#line 338
      goto switch_default___0;
      case_0___0: /* CIL Label */ 
#line 336
      goto end_of_option;
      switch_default___0: /* CIL Label */ 
      {
#line 339
      setflag(ch);
      }
#line 340
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    end_of_option: ;
    __Cont: /* CIL Label */ 
#line 282
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  no_more_options: ;
#line 347
  if (i + 1 != argc) {
    {
#line 348
    usage();
    }
  }
#line 349
  input_file_name = *(argv + i);
#line 350
  return;
}
}
#line 352 "/home/june/collector/temp/byacc-20140101/main.c"
void *allocate(size_t n ) 
{ 
  void *p ;

  {
#line 357
  p = (void *)0;
#line 358
  if (n) {
    {
#line 360
    p = calloc((size_t )1, n);
    }
#line 361
    if ((unsigned long )p == (unsigned long )((void *)0)) {
      {
#line 361
      no_space();
      }
    }
#line 361
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
      {
#line 361
      __assert_fail("p != 0", "/home/june/collector/temp/byacc-20140101/main.c", 361U,
                    "allocate");
      }
    }
  }
#line 363
  return (p);
}
}
#line 372 "/home/june/collector/temp/byacc-20140101/main.c"
static void create_file_names(void) 
{ 
  size_t len ;
  char const   *defines_suffix ;
  char const   *externs_suffix ;
  char *prefix ;
  void *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;
  size_t tmp___7 ;
  void *tmp___8 ;
  size_t tmp___9 ;
  void *tmp___10 ;
  size_t tmp___11 ;
  void *tmp___12 ;

  {
#line 380
  prefix = (char *)((void *)0);
#line 381
  defines_suffix = ".tab.h";
#line 382
  externs_suffix = ".tab.i";
#line 385
  if ((unsigned long )output_file_name != (unsigned long )((char *)0)) {
    {
#line 387
    prefix = strstr((char const   *)output_file_name, ".tab.c");
    }
#line 387
    if (! prefix) {
      {
#line 387
      prefix = strstr((char const   *)output_file_name, ".c");
      }
#line 387
      if (prefix) {
#line 390
        defines_suffix = ".h";
#line 391
        externs_suffix = ".i";
      }
    }
  }
#line 395
  if ((unsigned long )prefix != (unsigned long )((void *)0)) {
    {
#line 397
    len = (size_t )(prefix - output_file_name);
#line 398
    tmp = malloc((len + 1UL) * sizeof(char ));
#line 398
    file_prefix = (char *)tmp;
    }
#line 399
    if ((unsigned long )file_prefix == (unsigned long )((char *)0)) {
      {
#line 399
      no_space();
      }
    }
#line 399
    if (! ((unsigned long )file_prefix != (unsigned long )((char *)0))) {
      {
#line 399
      __assert_fail("file_prefix != 0", "/home/june/collector/temp/byacc-20140101/main.c",
                    399U, "create_file_names");
      }
    }
    {
#line 400
    tmp___0 = strncpy((char */* __restrict  */)file_prefix, (char const   */* __restrict  */)output_file_name,
                      len);
#line 400
    *(tmp___0 + len) = (char)0;
    }
  } else {
    {
#line 403
    len = strlen((char const   *)file_prefix);
    }
  }
#line 406
  if ((unsigned long )output_file_name == (unsigned long )((char *)0)) {
    {
#line 408
    oflag = (char)1;
#line 409
    tmp___1 = strlen(".tab.c");
#line 409
    tmp___2 = malloc(((len + tmp___1) + 1UL) * sizeof(char ));
#line 409
    output_file_name = (char *)tmp___2;
    }
#line 409
    if ((unsigned long )output_file_name == (unsigned long )((char *)0)) {
      {
#line 409
      no_space();
      }
    }
#line 409
    if (! ((unsigned long )output_file_name != (unsigned long )((char *)0))) {
      {
#line 409
      __assert_fail("output_file_name != 0", "/home/june/collector/temp/byacc-20140101/main.c",
                    409U, "create_file_names");
      }
    }
    {
#line 409
    strcpy((char */* __restrict  */)output_file_name, (char const   */* __restrict  */)file_prefix);
#line 409
    strcpy((char */* __restrict  */)(output_file_name + len), (char const   */* __restrict  */)".tab.c");
    }
  }
#line 412
  if (rflag) {
    {
#line 414
    tmp___3 = strlen(".code.c");
#line 414
    tmp___4 = malloc(((len + tmp___3) + 1UL) * sizeof(char ));
#line 414
    code_file_name = (char *)tmp___4;
    }
#line 414
    if ((unsigned long )code_file_name == (unsigned long )((char *)0)) {
      {
#line 414
      no_space();
      }
    }
#line 414
    if (! ((unsigned long )code_file_name != (unsigned long )((char *)0))) {
      {
#line 414
      __assert_fail("code_file_name != 0", "/home/june/collector/temp/byacc-20140101/main.c",
                    414U, "create_file_names");
      }
    }
    {
#line 414
    strcpy((char */* __restrict  */)code_file_name, (char const   */* __restrict  */)file_prefix);
#line 414
    strcpy((char */* __restrict  */)(code_file_name + len), (char const   */* __restrict  */)".code.c");
    }
  } else {
#line 417
    code_file_name = output_file_name;
  }
#line 419
  if (dflag) {
    {
#line 421
    tmp___5 = strlen(defines_suffix);
#line 421
    tmp___6 = malloc(((len + tmp___5) + 1UL) * sizeof(char ));
#line 421
    defines_file_name = (char *)tmp___6;
    }
#line 421
    if ((unsigned long )defines_file_name == (unsigned long )((char *)0)) {
      {
#line 421
      no_space();
      }
    }
#line 421
    if (! ((unsigned long )defines_file_name != (unsigned long )((char *)0))) {
      {
#line 421
      __assert_fail("defines_file_name != 0", "/home/june/collector/temp/byacc-20140101/main.c",
                    421U, "create_file_names");
      }
    }
    {
#line 421
    strcpy((char */* __restrict  */)defines_file_name, (char const   */* __restrict  */)file_prefix);
#line 421
    strcpy((char */* __restrict  */)(defines_file_name + len), (char const   */* __restrict  */)defines_suffix);
    }
  }
#line 424
  if (iflag) {
    {
#line 426
    tmp___7 = strlen(externs_suffix);
#line 426
    tmp___8 = malloc(((len + tmp___7) + 1UL) * sizeof(char ));
#line 426
    externs_file_name = (char *)tmp___8;
    }
#line 426
    if ((unsigned long )externs_file_name == (unsigned long )((char *)0)) {
      {
#line 426
      no_space();
      }
    }
#line 426
    if (! ((unsigned long )externs_file_name != (unsigned long )((char *)0))) {
      {
#line 426
      __assert_fail("externs_file_name != 0", "/home/june/collector/temp/byacc-20140101/main.c",
                    426U, "create_file_names");
      }
    }
    {
#line 426
    strcpy((char */* __restrict  */)externs_file_name, (char const   */* __restrict  */)file_prefix);
#line 426
    strcpy((char */* __restrict  */)(externs_file_name + len), (char const   */* __restrict  */)externs_suffix);
    }
  }
#line 429
  if (vflag) {
    {
#line 431
    tmp___9 = strlen(".output");
#line 431
    tmp___10 = malloc(((len + tmp___9) + 1UL) * sizeof(char ));
#line 431
    verbose_file_name = (char *)tmp___10;
    }
#line 431
    if ((unsigned long )verbose_file_name == (unsigned long )((char *)0)) {
      {
#line 431
      no_space();
      }
    }
#line 431
    if (! ((unsigned long )verbose_file_name != (unsigned long )((char *)0))) {
      {
#line 431
      __assert_fail("verbose_file_name != 0", "/home/june/collector/temp/byacc-20140101/main.c",
                    431U, "create_file_names");
      }
    }
    {
#line 431
    strcpy((char */* __restrict  */)verbose_file_name, (char const   */* __restrict  */)file_prefix);
#line 431
    strcpy((char */* __restrict  */)(verbose_file_name + len), (char const   */* __restrict  */)".output");
    }
  }
#line 434
  if (gflag) {
    {
#line 436
    tmp___11 = strlen(".dot");
#line 436
    tmp___12 = malloc(((len + tmp___11) + 1UL) * sizeof(char ));
#line 436
    graph_file_name = (char *)tmp___12;
    }
#line 436
    if ((unsigned long )graph_file_name == (unsigned long )((char *)0)) {
      {
#line 436
      no_space();
      }
    }
#line 436
    if (! ((unsigned long )graph_file_name != (unsigned long )((char *)0))) {
      {
#line 436
      __assert_fail("graph_file_name != 0", "/home/june/collector/temp/byacc-20140101/main.c",
                    436U, "create_file_names");
      }
    }
    {
#line 436
    strcpy((char */* __restrict  */)graph_file_name, (char const   */* __restrict  */)file_prefix);
#line 436
    strcpy((char */* __restrict  */)(graph_file_name + len), (char const   */* __restrict  */)".dot");
    }
  }
#line 439
  if ((unsigned long )prefix != (unsigned long )((void *)0)) {
    {
#line 441
    free((void *)file_prefix);
    }
  }
#line 443
  return;
}
}
#line 446 "/home/june/collector/temp/byacc-20140101/main.c"
static void close_tmpfiles(void) 
{ 
  MY_TMPFILES *next ;

  {
  {
#line 449
  while (1) {
    while_continue: /* CIL Label */ ;
#line 449
    if (! ((unsigned long )my_tmpfiles != (unsigned long )((MY_TMPFILES *)0))) {
#line 449
      goto while_break;
    }
    {
#line 451
    next = my_tmpfiles->next;
#line 453
    chmod((char const   *)my_tmpfiles->name, (__mode_t )420);
#line 454
    unlink((char const   *)my_tmpfiles->name);
#line 456
    free((void *)my_tmpfiles->name);
#line 457
    free((void *)my_tmpfiles);
#line 459
    my_tmpfiles = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 461
  return;
}
}
#line 510 "/home/june/collector/temp/byacc-20140101/main.c"
static FILE *open_tmpfile(char const   *label ) 
{ 
  FILE *result ;
  int fd ;
  char const   *tmpdir ;
  char *name ;
  char const   *mark ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  size_t tmp___5 ;
  char *tmp___6 ;
  MY_TMPFILES *item ;
  void *tmp___7 ;

  {
  {
#line 520
  tmp___0 = getenv("TMPDIR");
#line 520
  tmpdir = (char const   *)tmp___0;
  }
#line 520
  if ((unsigned long )tmpdir == (unsigned long )((char const   *)0)) {
#line 520
    goto _L;
  } else {
    {
#line 520
    tmp___1 = access(tmpdir, 2);
    }
#line 520
    if (tmp___1 != 0) {
      _L: /* CIL Label */ 
      {
#line 523
      tmpdir = "/tmp";
#line 527
      tmp = access(tmpdir, 2);
      }
#line 527
      if (tmp != 0) {
#line 528
        tmpdir = ".";
      }
    }
  }
  {
#line 531
  tmp___2 = strlen(tmpdir);
#line 531
  tmp___3 = strlen(label);
#line 531
  tmp___4 = malloc((tmp___2 + 10UL) + tmp___3);
#line 531
  name = (char *)tmp___4;
#line 533
  result = (FILE *)0;
  }
#line 534
  if ((unsigned long )name != (unsigned long )((char *)0)) {
    {
#line 536
    tmp___6 = strrchr(label, '_');
#line 536
    mark = (char const   *)tmp___6;
    }
#line 536
    if ((unsigned long )mark == (unsigned long )((char const   *)0)) {
      {
#line 537
      tmp___5 = strlen(label);
#line 537
      mark = label + tmp___5;
      }
    }
    {
#line 539
    sprintf((char */* __restrict  */)name, (char const   */* __restrict  */)"%s/%.*sXXXXXX",
            tmpdir, (int )(mark - label), label);
#line 540
    fd = mkstemp(name);
    }
#line 541
    if (fd >= 0) {
      {
#line 543
      result = fdopen(fd, "w+");
      }
#line 544
      if ((unsigned long )result != (unsigned long )((FILE *)0)) {
#line 548
        if ((unsigned long )my_tmpfiles == (unsigned long )((MY_TMPFILES *)0)) {
          {
#line 550
          atexit(& close_tmpfiles);
          }
        }
        {
#line 553
        tmp___7 = allocate(sizeof(MY_TMPFILES ));
#line 553
        item = (MY_TMPFILES *)tmp___7;
        }
#line 554
        if ((unsigned long )item == (unsigned long )((MY_TMPFILES *)0)) {
          {
#line 554
          no_space();
          }
        }
#line 554
        if (! ((unsigned long )item != (unsigned long )((MY_TMPFILES *)0))) {
          {
#line 554
          __assert_fail("item != 0", "/home/june/collector/temp/byacc-20140101/main.c",
                        554U, "open_tmpfile");
          }
        }
#line 556
        item->name = name;
#line 557
        if ((unsigned long )item->name == (unsigned long )((char *)0)) {
          {
#line 557
          no_space();
          }
        }
#line 557
        if (! ((unsigned long )item->name != (unsigned long )((char *)0))) {
          {
#line 557
          __assert_fail("item->name != 0", "/home/june/collector/temp/byacc-20140101/main.c",
                        557U, "open_tmpfile");
          }
        }
#line 559
        item->next = my_tmpfiles;
#line 560
        my_tmpfiles = item;
      }
    }
  }
#line 568
  if ((unsigned long )result == (unsigned long )((FILE *)0)) {
    {
#line 569
    open_error(label);
    }
  }
#line 570
  return (result);
}
}
#line 573 "/home/june/collector/temp/byacc-20140101/main.c"
static void open_files(void) 
{ 


  {
  {
#line 576
  create_file_names();
  }
#line 578
  if ((unsigned long )input_file == (unsigned long )((FILE *)0)) {
    {
#line 580
    input_file = fopen((char const   */* __restrict  */)input_file_name, (char const   */* __restrict  */)"r");
    }
#line 581
    if ((unsigned long )input_file == (unsigned long )((FILE *)0)) {
      {
#line 582
      open_error((char const   *)input_file_name);
      }
    }
  }
  {
#line 585
  action_file = open_tmpfile("action_file");
#line 586
  text_file = open_tmpfile("text_file");
  }
#line 588
  if (vflag) {
    {
#line 590
    verbose_file = fopen((char const   */* __restrict  */)verbose_file_name, (char const   */* __restrict  */)"w");
    }
#line 591
    if ((unsigned long )verbose_file == (unsigned long )((FILE *)0)) {
      {
#line 592
      open_error((char const   *)verbose_file_name);
      }
    }
  }
#line 595
  if (gflag) {
    {
#line 597
    graph_file = fopen((char const   */* __restrict  */)graph_file_name, (char const   */* __restrict  */)"w");
    }
#line 598
    if ((unsigned long )graph_file == (unsigned long )((FILE *)0)) {
      {
#line 599
      open_error((char const   *)graph_file_name);
      }
    }
    {
#line 600
    fprintf((FILE */* __restrict  */)graph_file, (char const   */* __restrict  */)"digraph %s {\n",
            file_prefix);
#line 601
    fprintf((FILE */* __restrict  */)graph_file, (char const   */* __restrict  */)"\tedge [fontsize=10];\n");
#line 602
    fprintf((FILE */* __restrict  */)graph_file, (char const   */* __restrict  */)"\tnode [shape=box,fontsize=10];\n");
#line 603
    fprintf((FILE */* __restrict  */)graph_file, (char const   */* __restrict  */)"\torientation=landscape;\n");
#line 604
    fprintf((FILE */* __restrict  */)graph_file, (char const   */* __restrict  */)"\trankdir=LR;\n");
#line 605
    fprintf((FILE */* __restrict  */)graph_file, (char const   */* __restrict  */)"\t/*\n");
#line 606
    fprintf((FILE */* __restrict  */)graph_file, (char const   */* __restrict  */)"\tmargin=0.2;\n");
#line 607
    fprintf((FILE */* __restrict  */)graph_file, (char const   */* __restrict  */)"\tpage=\"8.27,11.69\"; // for A4 printing\n");
#line 608
    fprintf((FILE */* __restrict  */)graph_file, (char const   */* __restrict  */)"\tratio=auto;\n");
#line 609
    fprintf((FILE */* __restrict  */)graph_file, (char const   */* __restrict  */)"\t*/\n");
    }
  }
#line 612
  if (dflag) {
    {
#line 614
    defines_file = fopen((char const   */* __restrict  */)defines_file_name, (char const   */* __restrict  */)"w");
    }
#line 615
    if ((unsigned long )defines_file == (unsigned long )((FILE *)0)) {
      {
#line 616
      open_error((char const   *)defines_file_name);
      }
    }
    {
#line 617
    union_file = open_tmpfile("union_file");
    }
  }
#line 620
  if (iflag) {
    {
#line 622
    externs_file = fopen((char const   */* __restrict  */)externs_file_name, (char const   */* __restrict  */)"w");
    }
#line 623
    if ((unsigned long )externs_file == (unsigned long )((FILE *)0)) {
      {
#line 624
      open_error((char const   *)externs_file_name);
      }
    }
  }
  {
#line 627
  output_file = fopen((char const   */* __restrict  */)output_file_name, (char const   */* __restrict  */)"w");
  }
#line 628
  if ((unsigned long )output_file == (unsigned long )((FILE *)0)) {
    {
#line 629
    open_error((char const   *)output_file_name);
    }
  }
#line 631
  if (rflag) {
    {
#line 633
    code_file = fopen((char const   */* __restrict  */)code_file_name, (char const   */* __restrict  */)"w");
    }
#line 634
    if ((unsigned long )code_file == (unsigned long )((FILE *)0)) {
      {
#line 635
      open_error((char const   *)code_file_name);
      }
    }
  } else {
#line 638
    code_file = output_file;
  }
#line 639
  return;
}
}
#line 641 "/home/june/collector/temp/byacc-20140101/main.c"
int main(int argc , char **argv ) 
{ 


  {
  {
#line 644
  SRexpect = -1;
#line 645
  RRexpect = -1;
#line 646
  exit_code = 0;
#line 648
  set_signals();
#line 649
  getargs(argc, argv);
#line 650
  open_files();
#line 651
  reader();
#line 652
  lr0();
#line 653
  lalr();
#line 654
  make_parser();
#line 655
  graph();
#line 656
  finalize_closure();
#line 657
  verbose();
#line 658
  output();
#line 659
  done(exit_code);
  }
#line 661
  return (0);
}
}
#line 448 "/home/june/collector/temp/byacc-20140101/defs.h"
void reflexive_transitive_closure(unsigned int *R___0 , int n ) ;
#line 5 "/home/june/collector/temp/byacc-20140101/warshall.c"
static void transitive_closure(unsigned int *R___0 , int n ) 
{ 
  int rowsize ;
  unsigned int i ;
  unsigned int *rowj ;
  unsigned int *rp ;
  unsigned int *rend ;
  unsigned int *ccol ;
  unsigned int *relend ;
  unsigned int *cword ;
  unsigned int *rowi ;
  unsigned int *tmp ;
  unsigned int *tmp___0 ;

  {
#line 18
  rowsize = (n + 31) / 32;
#line 19
  relend = R___0 + n * rowsize;
#line 21
  cword = R___0;
#line 22
  i = 0U;
#line 23
  rowi = R___0;
  {
#line 24
  while (1) {
    while_continue: /* CIL Label */ ;
#line 24
    if (! ((unsigned long )rowi < (unsigned long )relend)) {
#line 24
      goto while_break;
    }
#line 26
    ccol = cword;
#line 27
    rowj = R___0;
    {
#line 29
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 29
      if (! ((unsigned long )rowj < (unsigned long )relend)) {
#line 29
        goto while_break___0;
      }
#line 31
      if (*ccol & (unsigned int )(1 << i)) {
#line 33
        rp = rowi;
#line 34
        rend = rowj + rowsize;
        {
#line 35
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 35
          if (! ((unsigned long )rowj < (unsigned long )rend)) {
#line 35
            goto while_break___1;
          }
#line 36
          tmp = rowj;
#line 36
          rowj ++;
#line 36
          tmp___0 = rp;
#line 36
          rp ++;
#line 36
          *tmp |= *tmp___0;
        }
        while_break___1: /* CIL Label */ ;
        }
      } else {
#line 40
        rowj += rowsize;
      }
#line 43
      ccol += rowsize;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 46
    i ++;
#line 46
    if (i >= 32U) {
#line 48
      i = 0U;
#line 49
      cword ++;
    }
#line 52
    rowi += rowsize;
  }
  while_break: /* CIL Label */ ;
  }
#line 54
  return;
}
}
#line 56 "/home/june/collector/temp/byacc-20140101/warshall.c"
void reflexive_transitive_closure(unsigned int *R___0 , int n ) 
{ 
  int rowsize ;
  unsigned int i ;
  unsigned int *rp ;
  unsigned int *relend ;

  {
  {
#line 64
  transitive_closure(R___0, n);
#line 66
  rowsize = (n + 31) / 32;
#line 67
  relend = R___0 + n * rowsize;
#line 69
  i = 0U;
#line 70
  rp = R___0;
  }
  {
#line 71
  while (1) {
    while_continue: /* CIL Label */ ;
#line 71
    if (! ((unsigned long )rp < (unsigned long )relend)) {
#line 71
      goto while_break;
    }
#line 73
    *rp |= (unsigned int )(1 << i);
#line 74
    i ++;
#line 74
    if (i >= 32U) {
#line 76
      i = 0U;
#line 77
      rp ++;
    }
#line 80
    rp += rowsize;
  }
  while_break: /* CIL Label */ ;
  }
#line 82
  return;
}
}
#line 255 "/home/june/collector/temp/byacc-20140101/defs.h"
char const   * const  xdecls[3] ;
#line 256
char const   * const  tables[15] ;
#line 257
char const   * const  global_vars[4] ;
#line 258
char const   * const  impure_vars[6] ;
#line 259
char const   * const  hdr_defs[25] ;
#line 260
char const   * const  hdr_vars[3] ;
#line 261
char const   * const  body_1[63] ;
#line 262
char const   * const  body_vars[8] ;
#line 263
char const   * const  body_2[69] ;
#line 264
char const   * const  body_3[71] ;
#line 265
char const   * const  trailer[50] ;
#line 266
char const   * const  trailer_2[10] ;
#line 17 "/home/june/collector/temp/byacc-20140101/skeleton.c"
char const   * const  banner[15]  = 
#line 17 "/home/june/collector/temp/byacc-20140101/skeleton.c"
  {      (char const   */* const  */)"#ifndef lint",      (char const   */* const  */)"static const char yysccsid[] = \"@(#)yaccpar\t1.9 (Berkeley) 02/21/93\";",      (char const   */* const  */)"#endif",      (char const   */* const  */)"", 
        (char const   */* const  */)"#define YYBYACC 1",      (char const   */* const  */)"#define YYMAJOR 1",      (char const   */* const  */)"#define YYMINOR 9",      (char const   */* const  */)"#define YYPATCH 20140101", 
        (char const   */* const  */)"",      (char const   */* const  */)"#define YYEMPTY        (-1)",      (char const   */* const  */)"#define yyclearin      (yychar = YYEMPTY)",      (char const   */* const  */)"#define yyerrok        (yyerrflag = 0)", 
        (char const   */* const  */)"#define YYRECOVERING() (yyerrflag != 0)",      (char const   */* const  */)"",      (char const   */* const  */)0};
#line 38 "/home/june/collector/temp/byacc-20140101/skeleton.c"
char const   * const  xdecls[3]  = {      (char const   */* const  */)"",      (char const   */* const  */)"extern int YYPARSE_DECL();",      (char const   */* const  */)0};
#line 45 "/home/june/collector/temp/byacc-20140101/skeleton.c"
char const   * const  tables[15]  = 
#line 45
  {      (char const   */* const  */)"extern short yylhs[];",      (char const   */* const  */)"extern short yylen[];",      (char const   */* const  */)"extern short yydefred[];",      (char const   */* const  */)"extern short yydgoto[];", 
        (char const   */* const  */)"extern short yysindex[];",      (char const   */* const  */)"extern short yyrindex[];",      (char const   */* const  */)"extern short yygindex[];",      (char const   */* const  */)"extern short yytable[];", 
        (char const   */* const  */)"extern short yycheck[];",      (char const   */* const  */)"",      (char const   */* const  */)"#if YYDEBUG",      (char const   */* const  */)"extern char *yyname[];", 
        (char const   */* const  */)"extern char *yyrule[];",      (char const   */* const  */)"#endif",      (char const   */* const  */)0};
#line 64 "/home/june/collector/temp/byacc-20140101/skeleton.c"
char const   * const  global_vars[4]  = {      (char const   */* const  */)"",      (char const   */* const  */)"int      yydebug;",      (char const   */* const  */)"int      yynerrs;",      (char const   */* const  */)0};
#line 72 "/home/june/collector/temp/byacc-20140101/skeleton.c"
char const   * const  impure_vars[6]  = {      (char const   */* const  */)"",      (char const   */* const  */)"int      yyerrflag;",      (char const   */* const  */)"int      yychar;",      (char const   */* const  */)"YYSTYPE  yyval;", 
        (char const   */* const  */)"YYSTYPE  yylval;",      (char const   */* const  */)0};
#line 82 "/home/june/collector/temp/byacc-20140101/skeleton.c"
char const   * const  hdr_defs[25]  = 
#line 82
  {      (char const   */* const  */)"",      (char const   */* const  */)"/* define the initial stack-sizes */",      (char const   */* const  */)"#ifdef YYSTACKSIZE",      (char const   */* const  */)"#undef YYMAXDEPTH", 
        (char const   */* const  */)"#define YYMAXDEPTH  YYSTACKSIZE",      (char const   */* const  */)"#else",      (char const   */* const  */)"#ifdef YYMAXDEPTH",      (char const   */* const  */)"#define YYSTACKSIZE YYMAXDEPTH", 
        (char const   */* const  */)"#else",      (char const   */* const  */)"#define YYSTACKSIZE 10000",      (char const   */* const  */)"#define YYMAXDEPTH  10000",      (char const   */* const  */)"#endif", 
        (char const   */* const  */)"#endif",      (char const   */* const  */)"",      (char const   */* const  */)"#define YYINITSTACKSIZE 200",      (char const   */* const  */)"", 
        (char const   */* const  */)"typedef struct {",      (char const   */* const  */)"    unsigned stacksize;",      (char const   */* const  */)"    short    *s_base;",      (char const   */* const  */)"    short    *s_mark;", 
        (char const   */* const  */)"    short    *s_last;",      (char const   */* const  */)"    YYSTYPE  *l_base;",      (char const   */* const  */)"    YYSTYPE  *l_mark;",      (char const   */* const  */)"} YYSTACKDATA;", 
        (char const   */* const  */)0};
#line 111 "/home/june/collector/temp/byacc-20140101/skeleton.c"
char const   * const  hdr_vars[3]  = {      (char const   */* const  */)"/* variables for the parser stack */",      (char const   */* const  */)"static YYSTACKDATA yystack;",      (char const   */* const  */)0};
#line 118 "/home/june/collector/temp/byacc-20140101/skeleton.c"
char const   * const  body_vars[8]  = 
#line 118
  {      (char const   */* const  */)"    int      yyerrflag;",      (char const   */* const  */)"    int      yychar;",      (char const   */* const  */)"    YYSTYPE  yyval;",      (char const   */* const  */)"    YYSTYPE  yylval;", 
        (char const   */* const  */)"",      (char const   */* const  */)"    /* variables for the parser stack */",      (char const   */* const  */)"    YYSTACKDATA yystack;",      (char const   */* const  */)0};
#line 130 "/home/june/collector/temp/byacc-20140101/skeleton.c"
char const   * const  body_1[63]  = 
#line 130
  {      (char const   */* const  */)"",      (char const   */* const  */)"#if YYDEBUG",      (char const   */* const  */)"#include <stdio.h>\t\t/* needed for printf */",      (char const   */* const  */)"#endif", 
        (char const   */* const  */)"",      (char const   */* const  */)"#include <stdlib.h>\t/* needed for malloc, etc */",      (char const   */* const  */)"#include <string.h>\t/* needed for memset */",      (char const   */* const  */)"", 
        (char const   */* const  */)"/* allocate initial stack or double stack size, up to YYMAXDEPTH */",      (char const   */* const  */)"static int yygrowstack(YYSTACKDATA *data)",      (char const   */* const  */)"{",      (char const   */* const  */)"    int i;", 
        (char const   */* const  */)"    unsigned newsize;",      (char const   */* const  */)"    short *newss;",      (char const   */* const  */)"    YYSTYPE *newvs;",      (char const   */* const  */)"", 
        (char const   */* const  */)"    if ((newsize = data->stacksize) == 0)",      (char const   */* const  */)"        newsize = YYINITSTACKSIZE;",      (char const   */* const  */)"    else if (newsize >= YYMAXDEPTH)",      (char const   */* const  */)"        return -1;", 
        (char const   */* const  */)"    else if ((newsize *= 2) > YYMAXDEPTH)",      (char const   */* const  */)"        newsize = YYMAXDEPTH;",      (char const   */* const  */)"",      (char const   */* const  */)"    i = (int) (data->s_mark - data->s_base);", 
        (char const   */* const  */)"    newss = (short *)realloc(data->s_base, newsize * sizeof(*newss));",      (char const   */* const  */)"    if (newss == 0)",      (char const   */* const  */)"        return -1;",      (char const   */* const  */)"", 
        (char const   */* const  */)"    data->s_base = newss;",      (char const   */* const  */)"    data->s_mark = newss + i;",      (char const   */* const  */)"",      (char const   */* const  */)"    newvs = (YYSTYPE *)realloc(data->l_base, newsize * sizeof(*newvs));", 
        (char const   */* const  */)"    if (newvs == 0)",      (char const   */* const  */)"        return -1;",      (char const   */* const  */)"",      (char const   */* const  */)"    data->l_base = newvs;", 
        (char const   */* const  */)"    data->l_mark = newvs + i;",      (char const   */* const  */)"",      (char const   */* const  */)"    data->stacksize = newsize;",      (char const   */* const  */)"    data->s_last = data->s_base + newsize - 1;", 
        (char const   */* const  */)"    return 0;",      (char const   */* const  */)"}",      (char const   */* const  */)"",      (char const   */* const  */)"#if YYPURE || defined(YY_NO_LEAKS)", 
        (char const   */* const  */)"static void yyfreestack(YYSTACKDATA *data)",      (char const   */* const  */)"{",      (char const   */* const  */)"    free(data->s_base);",      (char const   */* const  */)"    free(data->l_base);", 
        (char const   */* const  */)"    memset(data, 0, sizeof(*data));",      (char const   */* const  */)"}",      (char const   */* const  */)"#else",      (char const   */* const  */)"#define yyfreestack(data) /* nothing */", 
        (char const   */* const  */)"#endif",      (char const   */* const  */)"",      (char const   */* const  */)"#define YYABORT  goto yyabort",      (char const   */* const  */)"#define YYREJECT goto yyabort", 
        (char const   */* const  */)"#define YYACCEPT goto yyaccept",      (char const   */* const  */)"#define YYERROR  goto yyerrlab",      (char const   */* const  */)"",      (char const   */* const  */)"int", 
        (char const   */* const  */)"YYPARSE_DECL()",      (char const   */* const  */)"{",      (char const   */* const  */)0};
#line 197 "/home/june/collector/temp/byacc-20140101/skeleton.c"
char const   * const  body_2[69]  = 
#line 197
  {      (char const   */* const  */)"    int yym, yyn, yystate;",      (char const   */* const  */)"#if YYDEBUG",      (char const   */* const  */)"    const char *yys;",      (char const   */* const  */)"", 
        (char const   */* const  */)"    if ((yys = getenv(\"YYDEBUG\")) != 0)",      (char const   */* const  */)"    {",      (char const   */* const  */)"        yyn = *yys;",      (char const   */* const  */)"        if (yyn >= \'0\' && yyn <= \'9\')", 
        (char const   */* const  */)"            yydebug = yyn - \'0\';",      (char const   */* const  */)"    }",      (char const   */* const  */)"#endif",      (char const   */* const  */)"", 
        (char const   */* const  */)"    yynerrs = 0;",      (char const   */* const  */)"    yyerrflag = 0;",      (char const   */* const  */)"    yychar = YYEMPTY;",      (char const   */* const  */)"    yystate = 0;", 
        (char const   */* const  */)"",      (char const   */* const  */)"#if YYPURE",      (char const   */* const  */)"    memset(&yystack, 0, sizeof(yystack));",      (char const   */* const  */)"#endif", 
        (char const   */* const  */)"",      (char const   */* const  */)"    if (yystack.s_base == NULL && yygrowstack(&yystack)) goto yyoverflow;",      (char const   */* const  */)"    yystack.s_mark = yystack.s_base;",      (char const   */* const  */)"    yystack.l_mark = yystack.l_base;", 
        (char const   */* const  */)"    yystate = 0;",      (char const   */* const  */)"    *yystack.s_mark = 0;",      (char const   */* const  */)"",      (char const   */* const  */)"yyloop:", 
        (char const   */* const  */)"    if ((yyn = yydefred[yystate]) != 0) goto yyreduce;",      (char const   */* const  */)"    if (yychar < 0)",      (char const   */* const  */)"    {",      (char const   */* const  */)"        if ((yychar = YYLEX) < 0) yychar = 0;", 
        (char const   */* const  */)"#if YYDEBUG",      (char const   */* const  */)"        if (yydebug)",      (char const   */* const  */)"        {",      (char const   */* const  */)"            yys = yyname[YYTRANSLATE(yychar)];", 
        (char const   */* const  */)"            printf(\"%sdebug: state %d, reading %d (%s)\\n\",",      (char const   */* const  */)"                    YYPREFIX, yystate, yychar, yys);",      (char const   */* const  */)"        }",      (char const   */* const  */)"#endif", 
        (char const   */* const  */)"    }",      (char const   */* const  */)"    if ((yyn = yysindex[yystate]) && (yyn += yychar) >= 0 &&",      (char const   */* const  */)"            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)",      (char const   */* const  */)"    {", 
        (char const   */* const  */)"#if YYDEBUG",      (char const   */* const  */)"        if (yydebug)",      (char const   */* const  */)"            printf(\"%sdebug: state %d, shifting to state %d\\n\",",      (char const   */* const  */)"                    YYPREFIX, yystate, yytable[yyn]);", 
        (char const   */* const  */)"#endif",      (char const   */* const  */)"        if (yystack.s_mark >= yystack.s_last && yygrowstack(&yystack))",      (char const   */* const  */)"        {",      (char const   */* const  */)"            goto yyoverflow;", 
        (char const   */* const  */)"        }",      (char const   */* const  */)"        yystate = yytable[yyn];",      (char const   */* const  */)"        *++yystack.s_mark = yytable[yyn];",      (char const   */* const  */)"        *++yystack.l_mark = yylval;", 
        (char const   */* const  */)"        yychar = YYEMPTY;",      (char const   */* const  */)"        if (yyerrflag > 0)  --yyerrflag;",      (char const   */* const  */)"        goto yyloop;",      (char const   */* const  */)"    }", 
        (char const   */* const  */)"    if ((yyn = yyrindex[yystate]) && (yyn += yychar) >= 0 &&",      (char const   */* const  */)"            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)",      (char const   */* const  */)"    {",      (char const   */* const  */)"        yyn = yytable[yyn];", 
        (char const   */* const  */)"        goto yyreduce;",      (char const   */* const  */)"    }",      (char const   */* const  */)"    if (yyerrflag) goto yyinrecovery;",      (char const   */* const  */)"", 
        (char const   */* const  */)0};
#line 270 "/home/june/collector/temp/byacc-20140101/skeleton.c"
char const   * const  body_3[71]  = 
#line 270
  {      (char const   */* const  */)"",      (char const   */* const  */)"    goto yyerrlab;",      (char const   */* const  */)"",      (char const   */* const  */)"yyerrlab:", 
        (char const   */* const  */)"    ++yynerrs;",      (char const   */* const  */)"",      (char const   */* const  */)"yyinrecovery:",      (char const   */* const  */)"    if (yyerrflag < 3)", 
        (char const   */* const  */)"    {",      (char const   */* const  */)"        yyerrflag = 3;",      (char const   */* const  */)"        for (;;)",      (char const   */* const  */)"        {", 
        (char const   */* const  */)"            if ((yyn = yysindex[*yystack.s_mark]) && (yyn += YYERRCODE) >= 0 &&",      (char const   */* const  */)"                    yyn <= YYTABLESIZE && yycheck[yyn] == YYERRCODE)",      (char const   */* const  */)"            {",      (char const   */* const  */)"#if YYDEBUG", 
        (char const   */* const  */)"                if (yydebug)",      (char const   */* const  */)"                    printf(\"%sdebug: state %d, error recovery shifting\\",      (char const   */* const  */)" to state %d\\n\", YYPREFIX, *yystack.s_mark, yytable[yyn]);",      (char const   */* const  */)"#endif", 
        (char const   */* const  */)"                if (yystack.s_mark >= yystack.s_last && yygrowstack(&yystack))",      (char const   */* const  */)"                {",      (char const   */* const  */)"                    goto yyoverflow;",      (char const   */* const  */)"                }", 
        (char const   */* const  */)"                yystate = yytable[yyn];",      (char const   */* const  */)"                *++yystack.s_mark = yytable[yyn];",      (char const   */* const  */)"                *++yystack.l_mark = yylval;",      (char const   */* const  */)"                goto yyloop;", 
        (char const   */* const  */)"            }",      (char const   */* const  */)"            else",      (char const   */* const  */)"            {",      (char const   */* const  */)"#if YYDEBUG", 
        (char const   */* const  */)"                if (yydebug)",      (char const   */* const  */)"                    printf(\"%sdebug: error recovery discarding state %d\\n\",",      (char const   */* const  */)"                            YYPREFIX, *yystack.s_mark);",      (char const   */* const  */)"#endif", 
        (char const   */* const  */)"                if (yystack.s_mark <= yystack.s_base) goto yyabort;",      (char const   */* const  */)"                --yystack.s_mark;",      (char const   */* const  */)"                --yystack.l_mark;",      (char const   */* const  */)"            }", 
        (char const   */* const  */)"        }",      (char const   */* const  */)"    }",      (char const   */* const  */)"    else",      (char const   */* const  */)"    {", 
        (char const   */* const  */)"        if (yychar == 0) goto yyabort;",      (char const   */* const  */)"#if YYDEBUG",      (char const   */* const  */)"        if (yydebug)",      (char const   */* const  */)"        {", 
        (char const   */* const  */)"            yys = yyname[YYTRANSLATE(yychar)];",      (char const   */* const  */)"            printf(\"%sdebug: state %d, error recovery discards token %d (%s)\\n\",",      (char const   */* const  */)"                    YYPREFIX, yystate, yychar, yys);",      (char const   */* const  */)"        }", 
        (char const   */* const  */)"#endif",      (char const   */* const  */)"        yychar = YYEMPTY;",      (char const   */* const  */)"        goto yyloop;",      (char const   */* const  */)"    }", 
        (char const   */* const  */)"",      (char const   */* const  */)"yyreduce:",      (char const   */* const  */)"#if YYDEBUG",      (char const   */* const  */)"    if (yydebug)", 
        (char const   */* const  */)"        printf(\"%sdebug: state %d, reducing by rule %d (%s)\\n\",",      (char const   */* const  */)"                YYPREFIX, yystate, yyn, yyrule[yyn]);",      (char const   */* const  */)"#endif",      (char const   */* const  */)"    yym = yylen[yyn];", 
        (char const   */* const  */)"    if (yym)",      (char const   */* const  */)"        yyval = yystack.l_mark[1-yym];",      (char const   */* const  */)"    else",      (char const   */* const  */)"        memset(&yyval, 0, sizeof yyval);", 
        (char const   */* const  */)"    switch (yyn)",      (char const   */* const  */)"    {",      (char const   */* const  */)0};
#line 347 "/home/june/collector/temp/byacc-20140101/skeleton.c"
char const   * const  trailer[50]  = 
#line 347
  {      (char const   */* const  */)"    }",      (char const   */* const  */)"    yystack.s_mark -= yym;",      (char const   */* const  */)"    yystate = *yystack.s_mark;",      (char const   */* const  */)"    yystack.l_mark -= yym;", 
        (char const   */* const  */)"    yym = yylhs[yyn];",      (char const   */* const  */)"    if (yystate == 0 && yym == 0)",      (char const   */* const  */)"    {",      (char const   */* const  */)"#if YYDEBUG", 
        (char const   */* const  */)"        if (yydebug)",      (char const   */* const  */)"            printf(\"%sdebug: after reduction, shifting from state 0 to\\",      (char const   */* const  */)" state %d\\n\", YYPREFIX, YYFINAL);",      (char const   */* const  */)"#endif", 
        (char const   */* const  */)"        yystate = YYFINAL;",      (char const   */* const  */)"        *++yystack.s_mark = YYFINAL;",      (char const   */* const  */)"        *++yystack.l_mark = yyval;",      (char const   */* const  */)"        if (yychar < 0)", 
        (char const   */* const  */)"        {",      (char const   */* const  */)"            if ((yychar = YYLEX) < 0) yychar = 0;",      (char const   */* const  */)"#if YYDEBUG",      (char const   */* const  */)"            if (yydebug)", 
        (char const   */* const  */)"            {",      (char const   */* const  */)"                yys = yyname[YYTRANSLATE(yychar)];",      (char const   */* const  */)"                printf(\"%sdebug: state %d, reading %d (%s)\\n\",",      (char const   */* const  */)"                        YYPREFIX, YYFINAL, yychar, yys);", 
        (char const   */* const  */)"            }",      (char const   */* const  */)"#endif",      (char const   */* const  */)"        }",      (char const   */* const  */)"        if (yychar == 0) goto yyaccept;", 
        (char const   */* const  */)"        goto yyloop;",      (char const   */* const  */)"    }",      (char const   */* const  */)"    if ((yyn = yygindex[yym]) && (yyn += yystate) >= 0 &&",      (char const   */* const  */)"            yyn <= YYTABLESIZE && yycheck[yyn] == yystate)", 
        (char const   */* const  */)"        yystate = yytable[yyn];",      (char const   */* const  */)"    else",      (char const   */* const  */)"        yystate = yydgoto[yym];",      (char const   */* const  */)"#if YYDEBUG", 
        (char const   */* const  */)"    if (yydebug)",      (char const   */* const  */)"        printf(\"%sdebug: after reduction, shifting from state %d \\",      (char const   */* const  */)"to state %d\\n\", YYPREFIX, *yystack.s_mark, yystate);",      (char const   */* const  */)"#endif", 
        (char const   */* const  */)"    if (yystack.s_mark >= yystack.s_last && yygrowstack(&yystack))",      (char const   */* const  */)"    {",      (char const   */* const  */)"        goto yyoverflow;",      (char const   */* const  */)"    }", 
        (char const   */* const  */)"    *++yystack.s_mark = (short) yystate;",      (char const   */* const  */)"    *++yystack.l_mark = yyval;",      (char const   */* const  */)"    goto yyloop;",      (char const   */* const  */)"", 
        (char const   */* const  */)"yyoverflow:",      (char const   */* const  */)0};
#line 401 "/home/june/collector/temp/byacc-20140101/skeleton.c"
char const   * const  trailer_2[10]  = 
#line 401
  {      (char const   */* const  */)"",      (char const   */* const  */)"yyabort:",      (char const   */* const  */)"    yyfreestack(&yystack);",      (char const   */* const  */)"    return (1);", 
        (char const   */* const  */)"",      (char const   */* const  */)"yyaccept:",      (char const   */* const  */)"    yyfreestack(&yystack);",      (char const   */* const  */)"    return (0);", 
        (char const   */* const  */)"}",      (char const   */* const  */)0};
#line 415 "/home/june/collector/temp/byacc-20140101/skeleton.c"
void write_section(FILE *fp , char const   * const  *section ) 
{ 
  int c ;
  int i ;
  char const   *s ;

  {
#line 422
  i = 0;
  {
#line 422
  while (1) {
    while_continue: /* CIL Label */ ;
#line 422
    s = (char const   *)*(section + i);
#line 422
    if (! ((unsigned long )s != (unsigned long )((char const   *)0))) {
#line 422
      goto while_break;
    }
    {
#line 424
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 424
      c = (int )*s;
#line 424
      if (! (c != 0)) {
#line 424
        goto while_break___0;
      }
      {
#line 426
      _IO_putc(c, fp);
#line 427
      s ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 429
    if ((unsigned long )fp == (unsigned long )code_file) {
#line 430
      outline ++;
    }
    {
#line 431
    _IO_putc('\n', fp);
#line 422
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 433
  return;
}
}
#line 340 "/home/june/collector/temp/byacc-20140101/defs.h"
Value_t *itemset  ;
#line 341 "/home/june/collector/temp/byacc-20140101/defs.h"
Value_t *itemsetend  ;
#line 342 "/home/june/collector/temp/byacc-20140101/defs.h"
unsigned int *ruleset  ;
#line 371
void closure(short *nucleus , int n ) ;
#line 373
void set_first_derives(void) ;
#line 9 "/home/june/collector/temp/byacc-20140101/closure.c"
static unsigned int *first_derives  ;
#line 10 "/home/june/collector/temp/byacc-20140101/closure.c"
static unsigned int *EFF  ;
#line 12 "/home/june/collector/temp/byacc-20140101/closure.c"
static void set_EFF(void) 
{ 
  unsigned int *row ;
  int symbol ;
  short *sp ;
  int rowsize ;
  int i ;
  int rule ;
  void *tmp ;

  {
  {
#line 22
  rowsize = (nvars + 31) / 32;
#line 23
  tmp = allocate((size_t )(nvars * rowsize) * sizeof(unsigned int ));
#line 23
  EFF = (unsigned int *)tmp;
#line 25
  row = EFF;
#line 26
  i = (int )start_symbol;
  }
  {
#line 26
  while (1) {
    while_continue: /* CIL Label */ ;
#line 26
    if (! (i < nsyms)) {
#line 26
      goto while_break;
    }
#line 28
    sp = *(derives + i);
#line 29
    rule = (int )*sp;
    {
#line 29
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 29
      if (! (rule > 0)) {
#line 29
        goto while_break___0;
      }
#line 31
      symbol = (int )*(ritem + *(rrhs + rule));
#line 32
      if (symbol >= (int )start_symbol) {
#line 34
        symbol -= (int )start_symbol;
#line 35
        *(row + (symbol >> 5)) |= 1U << (symbol & 31);
      }
#line 29
      sp ++;
#line 29
      rule = (int )*sp;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 38
    row += rowsize;
#line 26
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 41
  reflexive_transitive_closure(EFF, nvars);
  }
#line 46
  return;
}
}
#line 48 "/home/june/collector/temp/byacc-20140101/closure.c"
void set_first_derives(void) 
{ 
  unsigned int *rrow ;
  unsigned int *vrow ;
  int j ;
  unsigned int k ;
  unsigned int cword ;
  short *rp ;
  int rule ;
  int i ;
  int rulesetsize ;
  int varsetsize ;
  void *tmp ;
  unsigned int *tmp___0 ;
  short *tmp___1 ;

  {
  {
#line 55
  cword = 0U;
#line 63
  rulesetsize = (nrules + 31) / 32;
#line 64
  varsetsize = (nvars + 31) / 32;
#line 65
  tmp = allocate((size_t )(nvars * rulesetsize) * sizeof(unsigned int ));
#line 65
  first_derives = (unsigned int *)tmp - ntokens * rulesetsize;
#line 67
  set_EFF();
#line 69
  rrow = first_derives + ntokens * rulesetsize;
#line 70
  i = (int )start_symbol;
  }
  {
#line 70
  while (1) {
    while_continue: /* CIL Label */ ;
#line 70
    if (! (i < nsyms)) {
#line 70
      goto while_break;
    }
#line 72
    vrow = EFF + (i - ntokens) * varsetsize;
#line 73
    k = 32U;
#line 74
    j = (int )start_symbol;
    {
#line 74
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 74
      if (! (j < nsyms)) {
#line 74
        goto while_break___0;
      }
#line 76
      if (k >= 32U) {
#line 78
        tmp___0 = vrow;
#line 78
        vrow ++;
#line 78
        cword = *tmp___0;
#line 79
        k = 0U;
      }
#line 82
      if (cword & (unsigned int )(1 << k)) {
#line 84
        rp = *(derives + j);
        {
#line 85
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 85
          tmp___1 = rp;
#line 85
          rp ++;
#line 85
          rule = (int )*tmp___1;
#line 85
          if (! (rule >= 0)) {
#line 85
            goto while_break___1;
          }
#line 87
          *(rrow + (rule >> 5)) |= 1U << (rule & 31);
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 74
      k ++;
#line 74
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 92
    rrow += rulesetsize;
#line 70
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 99
  free((void *)((char *)EFF));
  }
#line 100
  return;
}
}
#line 102 "/home/june/collector/temp/byacc-20140101/closure.c"
void closure(short *nucleus , int n ) 
{ 
  unsigned int ruleno ;
  unsigned int word ;
  unsigned int i ;
  Value_t *csp ;
  unsigned int *dsp ;
  unsigned int *rsp ;
  int rulesetsize ;
  Value_t *csend ;
  unsigned int *rsend ;
  int symbol ;
  Value_t itemno ;
  unsigned int *tmp ;
  unsigned int *tmp___0 ;
  Value_t *tmp___1 ;
  Value_t *tmp___2 ;
  Value_t *tmp___3 ;
  Value_t *tmp___4 ;
  Value_t *tmp___5 ;

  {
#line 118
  rulesetsize = (nrules + 31) / 32;
#line 119
  rsend = ruleset + rulesetsize;
#line 120
  rsp = ruleset;
  {
#line 120
  while (1) {
    while_continue: /* CIL Label */ ;
#line 120
    if (! ((unsigned long )rsp < (unsigned long )rsend)) {
#line 120
      goto while_break;
    }
#line 121
    *rsp = 0U;
#line 120
    rsp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 123
  csend = nucleus + n;
#line 124
  csp = nucleus;
  {
#line 124
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 124
    if (! ((unsigned long )csp < (unsigned long )csend)) {
#line 124
      goto while_break___0;
    }
#line 126
    symbol = (int )*(ritem + *csp);
#line 127
    if (symbol >= (int )start_symbol) {
#line 129
      dsp = first_derives + symbol * rulesetsize;
#line 130
      rsp = ruleset;
      {
#line 131
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 131
        if (! ((unsigned long )rsp < (unsigned long )rsend)) {
#line 131
          goto while_break___1;
        }
#line 132
        tmp = rsp;
#line 132
        rsp ++;
#line 132
        tmp___0 = dsp;
#line 132
        dsp ++;
#line 132
        *tmp |= *tmp___0;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 124
    csp ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 136
  ruleno = 0U;
#line 137
  itemsetend = itemset;
#line 138
  csp = nucleus;
#line 139
  rsp = ruleset;
  {
#line 139
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 139
    if (! ((unsigned long )rsp < (unsigned long )rsend)) {
#line 139
      goto while_break___2;
    }
#line 141
    word = *rsp;
#line 142
    if (word) {
#line 144
      i = 0U;
      {
#line 144
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 144
        if (! (i < 32U)) {
#line 144
          goto while_break___3;
        }
#line 146
        if (word & (unsigned int )(1 << i)) {
#line 148
          itemno = *(rrhs + (ruleno + i));
          {
#line 149
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 149
            if ((unsigned long )csp < (unsigned long )csend) {
#line 149
              if (! ((int )*csp < (int )itemno)) {
#line 149
                goto while_break___4;
              }
            } else {
#line 149
              goto while_break___4;
            }
#line 150
            tmp___1 = itemsetend;
#line 150
            itemsetend ++;
#line 150
            tmp___2 = csp;
#line 150
            csp ++;
#line 150
            *tmp___1 = *tmp___2;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 151
          tmp___3 = itemsetend;
#line 151
          itemsetend ++;
#line 151
          *tmp___3 = itemno;
          {
#line 152
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 152
            if ((unsigned long )csp < (unsigned long )csend) {
#line 152
              if (! ((int )*csp == (int )itemno)) {
#line 152
                goto while_break___5;
              }
            } else {
#line 152
              goto while_break___5;
            }
#line 153
            csp ++;
          }
          while_break___5: /* CIL Label */ ;
          }
        }
#line 144
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 157
    ruleno += 32U;
#line 139
    rsp ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 160
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 160
    if (! ((unsigned long )csp < (unsigned long )csend)) {
#line 160
      goto while_break___6;
    }
#line 161
    tmp___4 = itemsetend;
#line 161
    itemsetend ++;
#line 161
    tmp___5 = csp;
#line 161
    csp ++;
#line 161
    *tmp___4 = *tmp___5;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 166
  return;
}
}
#line 168 "/home/june/collector/temp/byacc-20140101/closure.c"
void finalize_closure(void) 
{ 


  {
  {
#line 171
  free((void *)((char *)itemset));
#line 172
  free((void *)((char *)ruleset));
#line 173
  free((void *)((char *)(first_derives + ntokens * ((nrules + 31) / 32))));
  }
#line 174
  return;
}
}
#line 313 "/home/june/collector/temp/byacc-20140101/defs.h"
int nstates  ;
#line 314 "/home/june/collector/temp/byacc-20140101/defs.h"
core *first_state  ;
#line 315 "/home/june/collector/temp/byacc-20140101/defs.h"
shifts *first_shift  ;
#line 316 "/home/june/collector/temp/byacc-20140101/defs.h"
reductions *first_reduction  ;
#line 422
void show_cores(void) ;
#line 423
void show_ritems(void) ;
#line 424
void show_rrhs(void) ;
#line 425
void show_shifts(void) ;
#line 5 "/home/june/collector/temp/byacc-20140101/lr0.c"
static core *new_state(int symbol ) ;
#line 6
static Value_t get_state(int symbol ) ;
#line 7
static void allocate_itemsets(void) ;
#line 8
static void allocate_storage(void) ;
#line 9
static void append_states(void) ;
#line 10
static void free_storage(void) ;
#line 11
static void generate_states(void) ;
#line 12
static void initialize_states(void) ;
#line 13
static void new_itemsets(void) ;
#line 14
static void save_reductions(void) ;
#line 15
static void save_shifts(void) ;
#line 16
static void set_derives(void) ;
#line 17
static void set_nullable(void) ;
#line 24 "/home/june/collector/temp/byacc-20140101/lr0.c"
static core **state_set  ;
#line 25 "/home/june/collector/temp/byacc-20140101/lr0.c"
static core *this_state  ;
#line 26 "/home/june/collector/temp/byacc-20140101/lr0.c"
static core *last_state  ;
#line 27 "/home/june/collector/temp/byacc-20140101/lr0.c"
static shifts *last_shift  ;
#line 28 "/home/june/collector/temp/byacc-20140101/lr0.c"
static reductions *last_reduction  ;
#line 30 "/home/june/collector/temp/byacc-20140101/lr0.c"
static int nshifts  ;
#line 31 "/home/june/collector/temp/byacc-20140101/lr0.c"
static short *shift_symbol  ;
#line 33 "/home/june/collector/temp/byacc-20140101/lr0.c"
static Value_t *redset  ;
#line 34 "/home/june/collector/temp/byacc-20140101/lr0.c"
static Value_t *shiftset  ;
#line 36 "/home/june/collector/temp/byacc-20140101/lr0.c"
static Value_t **kernel_base  ;
#line 37 "/home/june/collector/temp/byacc-20140101/lr0.c"
static Value_t **kernel_end  ;
#line 38 "/home/june/collector/temp/byacc-20140101/lr0.c"
static Value_t *kernel_items  ;
#line 40 "/home/june/collector/temp/byacc-20140101/lr0.c"
static void allocate_itemsets(void) 
{ 
  short *itemp ;
  short *item_end ;
  int symbol ;
  int i ;
  int count ;
  int max ;
  short *symbol_count ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 51
  count = 0;
#line 52
  tmp = allocate((size_t )nsyms * sizeof(short ));
#line 52
  symbol_count = (short *)tmp;
#line 54
  item_end = ritem + nitems;
#line 55
  itemp = ritem;
  }
  {
#line 55
  while (1) {
    while_continue: /* CIL Label */ ;
#line 55
    if (! ((unsigned long )itemp < (unsigned long )item_end)) {
#line 55
      goto while_break;
    }
#line 57
    symbol = (int )*itemp;
#line 58
    if (symbol >= 0) {
#line 60
      count ++;
#line 61
      *(symbol_count + symbol) = (short )((int )*(symbol_count + symbol) + 1);
    }
#line 55
    itemp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 65
  tmp___0 = allocate((size_t )nsyms * sizeof(short *));
#line 65
  kernel_base = (short **)tmp___0;
#line 66
  tmp___1 = allocate((size_t )count * sizeof(short ));
#line 66
  kernel_items = (short *)tmp___1;
#line 68
  count = 0;
#line 69
  max = 0;
#line 70
  i = 0;
  }
  {
#line 70
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 70
    if (! (i < nsyms)) {
#line 70
      goto while_break___0;
    }
#line 72
    *(kernel_base + i) = kernel_items + count;
#line 73
    count += (int )*(symbol_count + i);
#line 74
    if (max < (int )*(symbol_count + i)) {
#line 75
      max = (int )*(symbol_count + i);
    }
#line 70
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 78
  shift_symbol = symbol_count;
#line 79
  tmp___2 = allocate((size_t )nsyms * sizeof(short *));
#line 79
  kernel_end = (short **)tmp___2;
  }
#line 80
  return;
}
}
#line 82 "/home/june/collector/temp/byacc-20140101/lr0.c"
static void allocate_storage(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 85
  allocate_itemsets();
#line 86
  tmp = allocate((size_t )nsyms * sizeof(short ));
#line 86
  shiftset = (short *)tmp;
#line 87
  tmp___0 = allocate((size_t )(nrules + 1) * sizeof(short ));
#line 87
  redset = (short *)tmp___0;
#line 88
  tmp___1 = allocate((size_t )nitems * sizeof(core *));
#line 88
  state_set = (core **)tmp___1;
  }
#line 89
  return;
}
}
#line 91 "/home/june/collector/temp/byacc-20140101/lr0.c"
static void append_states(void) 
{ 
  int i ;
  int j ;
  Value_t symbol ;

  {
#line 101
  i = 1;
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;
#line 101
    if (! (i < nshifts)) {
#line 101
      goto while_break;
    }
#line 103
    symbol = *(shift_symbol + i);
#line 104
    j = i;
    {
#line 105
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 105
      if (j > 0) {
#line 105
        if (! ((int )*(shift_symbol + (j - 1)) > (int )symbol)) {
#line 105
          goto while_break___0;
        }
      } else {
#line 105
        goto while_break___0;
      }
#line 107
      *(shift_symbol + j) = *(shift_symbol + (j - 1));
#line 108
      j --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 110
    *(shift_symbol + j) = symbol;
#line 101
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 113
  i = 0;
  {
#line 113
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 113
    if (! (i < nshifts)) {
#line 113
      goto while_break___1;
    }
    {
#line 115
    symbol = *(shift_symbol + i);
#line 116
    *(shiftset + i) = get_state((int )symbol);
#line 113
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 118
  return;
}
}
#line 120 "/home/june/collector/temp/byacc-20140101/lr0.c"
static void free_storage(void) 
{ 


  {
  {
#line 123
  free((void *)((char *)shift_symbol));
#line 124
  free((void *)((char *)redset));
#line 125
  free((void *)((char *)shiftset));
#line 126
  free((void *)((char *)kernel_base));
#line 127
  free((void *)((char *)kernel_end));
#line 128
  free((void *)((char *)kernel_items));
#line 129
  free((void *)((char *)state_set));
  }
#line 130
  return;
}
}
#line 132 "/home/june/collector/temp/byacc-20140101/lr0.c"
static void generate_states(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 135
  allocate_storage();
#line 136
  tmp = allocate((size_t )nitems * sizeof(short ));
#line 136
  itemset = (short *)tmp;
#line 137
  tmp___0 = allocate((size_t )((nrules + 31) / 32) * sizeof(unsigned int ));
#line 137
  ruleset = (unsigned int *)tmp___0;
#line 138
  set_first_derives();
#line 139
  initialize_states();
  }
  {
#line 141
  while (1) {
    while_continue: /* CIL Label */ ;
#line 141
    if (! this_state) {
#line 141
      goto while_break;
    }
    {
#line 143
    closure(this_state->items, (int )this_state->nitems);
#line 144
    save_reductions();
#line 145
    new_itemsets();
#line 146
    append_states();
    }
#line 148
    if (nshifts > 0) {
      {
#line 149
      save_shifts();
      }
    }
#line 151
    this_state = this_state->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 154
  free_storage();
  }
#line 155
  return;
}
}
#line 157 "/home/june/collector/temp/byacc-20140101/lr0.c"
static Value_t get_state(int symbol ) 
{ 
  int key ;
  short *isp1 ;
  short *isp2 ;
  short *iend ;
  core *sp ;
  int found ;
  int n ;
  short *tmp ;
  short *tmp___0 ;
  struct core *tmp___1 ;

  {
#line 172
  isp1 = *(kernel_base + symbol);
#line 173
  iend = *(kernel_end + symbol);
#line 174
  n = (int )(iend - isp1);
#line 176
  key = (int )*isp1;
#line 177
  if (0 <= key) {
#line 177
    if (! (key < nitems)) {
      {
#line 177
      __assert_fail("0 <= key && key < nitems", "/home/june/collector/temp/byacc-20140101/lr0.c",
                    177U, "get_state");
      }
    }
  } else {
    {
#line 177
    __assert_fail("0 <= key && key < nitems", "/home/june/collector/temp/byacc-20140101/lr0.c",
                  177U, "get_state");
    }
  }
#line 178
  sp = *(state_set + key);
#line 179
  if (sp) {
#line 181
    found = 0;
    {
#line 182
    while (1) {
      while_continue: /* CIL Label */ ;
#line 182
      if (! (! found)) {
#line 182
        goto while_break;
      }
#line 184
      if ((int )sp->nitems == n) {
#line 186
        found = 1;
#line 187
        isp1 = *(kernel_base + symbol);
#line 188
        isp2 = sp->items;
        {
#line 190
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 190
          if (found) {
#line 190
            if (! ((unsigned long )isp1 < (unsigned long )iend)) {
#line 190
              goto while_break___0;
            }
          } else {
#line 190
            goto while_break___0;
          }
#line 192
          tmp = isp1;
#line 192
          isp1 ++;
#line 192
          tmp___0 = isp2;
#line 192
          isp2 ++;
#line 192
          if ((int )*tmp != (int )*tmp___0) {
#line 193
            found = 0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 197
      if (! found) {
#line 199
        if (sp->link) {
#line 201
          sp = sp->link;
        } else {
          {
#line 205
          tmp___1 = new_state(symbol);
#line 205
          sp->link = tmp___1;
#line 205
          sp = tmp___1;
#line 206
          found = 1;
          }
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 213
    sp = new_state(symbol);
#line 213
    *(state_set + key) = sp;
    }
  }
#line 216
  return (sp->number);
}
}
#line 219 "/home/june/collector/temp/byacc-20140101/lr0.c"
static void initialize_states(void) 
{ 
  unsigned int i ;
  short *start_derives ;
  core *p ;
  void *tmp ;

  {
#line 226
  start_derives = *(derives + start_symbol);
#line 227
  i = 0U;
  {
#line 227
  while (1) {
    while_continue: /* CIL Label */ ;
#line 227
    if (! ((int )*(start_derives + i) >= 0)) {
#line 227
      goto while_break;
    }
#line 228
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 227
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 230
  tmp = malloc(sizeof(core ) + (unsigned long )i * sizeof(short ));
#line 230
  p = (core *)tmp;
  }
#line 231
  if ((unsigned long )p == (unsigned long )((core *)0)) {
    {
#line 231
    no_space();
    }
  }
#line 231
  if (! ((unsigned long )p != (unsigned long )((core *)0))) {
    {
#line 231
    __assert_fail("p != 0", "/home/june/collector/temp/byacc-20140101/lr0.c", 231U,
                  "initialize_states");
    }
  }
#line 233
  p->next = (struct core *)0;
#line 234
  p->link = (struct core *)0;
#line 235
  p->number = (Value_t )0;
#line 236
  p->accessing_symbol = (Value_t )0;
#line 237
  p->nitems = (Value_t )i;
#line 239
  i = 0U;
  {
#line 239
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 239
    if (! ((int )*(start_derives + i) >= 0)) {
#line 239
      goto while_break___0;
    }
#line 240
    p->items[i] = *(rrhs + *(start_derives + i));
#line 239
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 242
  this_state = p;
#line 242
  last_state = this_state;
#line 242
  first_state = last_state;
#line 243
  nstates = 1;
#line 244
  return;
}
}
#line 246 "/home/june/collector/temp/byacc-20140101/lr0.c"
static void new_itemsets(void) 
{ 
  Value_t i ;
  int shiftcount ;
  short *isp ;
  short *ksp ;
  Value_t symbol ;
  short *tmp ;
  int tmp___0 ;
  short *tmp___1 ;

  {
#line 255
  i = (Value_t )0;
  {
#line 255
  while (1) {
    while_continue: /* CIL Label */ ;
#line 255
    if (! ((int )i < nsyms)) {
#line 255
      goto while_break;
    }
#line 256
    *(kernel_end + i) = (Value_t *)0;
#line 255
    i = (Value_t )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 258
  shiftcount = 0;
#line 259
  isp = itemset;
  {
#line 260
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 260
    if (! ((unsigned long )isp < (unsigned long )itemsetend)) {
#line 260
      goto while_break___0;
    }
#line 262
    tmp = isp;
#line 262
    isp ++;
#line 262
    i = *tmp;
#line 263
    symbol = *(ritem + i);
#line 264
    if ((int )symbol > 0) {
#line 266
      ksp = *(kernel_end + symbol);
#line 267
      if (! ksp) {
#line 269
        tmp___0 = shiftcount;
#line 269
        shiftcount ++;
#line 269
        *(shift_symbol + tmp___0) = symbol;
#line 270
        ksp = *(kernel_base + symbol);
      }
#line 273
      tmp___1 = ksp;
#line 273
      ksp ++;
#line 273
      *tmp___1 = (Value_t )((int )i + 1);
#line 274
      *(kernel_end + symbol) = ksp;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 278
  nshifts = shiftcount;
#line 279
  return;
}
}
#line 281 "/home/june/collector/temp/byacc-20140101/lr0.c"
static core *new_state(int symbol ) 
{ 
  unsigned int n ;
  core *p ;
  short *isp1 ;
  short *isp2 ;
  short *iend ;
  void *tmp ;
  short *tmp___0 ;
  short *tmp___1 ;

  {
#line 294
  if (nstates >= 32767) {
    {
#line 295
    fatal("too many states");
    }
  }
  {
#line 297
  isp1 = *(kernel_base + symbol);
#line 298
  iend = *(kernel_end + symbol);
#line 299
  n = (unsigned int )(iend - isp1);
#line 301
  tmp = allocate(sizeof(core ) + (unsigned long )(n - 1U) * sizeof(short ));
#line 301
  p = (core *)tmp;
#line 302
  p->accessing_symbol = (Value_t )symbol;
#line 303
  p->number = (Value_t )nstates;
#line 304
  p->nitems = (Value_t )n;
#line 306
  isp2 = p->items;
  }
  {
#line 307
  while (1) {
    while_continue: /* CIL Label */ ;
#line 307
    if (! ((unsigned long )isp1 < (unsigned long )iend)) {
#line 307
      goto while_break;
    }
#line 308
    tmp___0 = isp2;
#line 308
    isp2 ++;
#line 308
    tmp___1 = isp1;
#line 308
    isp1 ++;
#line 308
    *tmp___0 = *tmp___1;
  }
  while_break: /* CIL Label */ ;
  }
#line 310
  last_state->next = p;
#line 311
  last_state = p;
#line 313
  nstates ++;
#line 315
  return (p);
}
}
#line 320 "/home/june/collector/temp/byacc-20140101/lr0.c"
void show_cores(void) 
{ 
  core *p ;
  int i ;
  int j ;
  int k ;
  int n ;
  int itemno ;
  int tmp ;
  int tmp___0 ;

  {
#line 327
  k = 0;
#line 328
  p = first_state;
  {
#line 328
  while (1) {
    while_continue: /* CIL Label */ ;
#line 328
    if (! p) {
#line 328
      goto while_break;
    }
#line 330
    if (k) {
      {
#line 331
      printf((char const   */* __restrict  */)"\n");
      }
    }
    {
#line 332
    printf((char const   */* __restrict  */)"state %d, number = %d, accessing symbol = %s\n",
           k, (int )p->number, *(symbol_name + p->accessing_symbol));
#line 334
    n = (int )p->nitems;
#line 335
    i = 0;
    }
    {
#line 335
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 335
      if (! (i < n)) {
#line 335
        goto while_break___0;
      }
      {
#line 337
      itemno = (int )p->items[i];
#line 338
      printf((char const   */* __restrict  */)"%4d  ", itemno);
#line 339
      j = itemno;
      }
      {
#line 340
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 340
        if (! ((int )*(ritem + j) >= 0)) {
#line 340
          goto while_break___1;
        }
#line 341
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 342
      printf((char const   */* __restrict  */)"%s :", *(symbol_name + *(rlhs + - ((int )*(ritem + j)))));
#line 343
      j = (int )*(rrhs + - ((int )*(ritem + j)));
      }
      {
#line 344
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 344
        if (! (j < itemno)) {
#line 344
          goto while_break___2;
        }
        {
#line 345
        tmp = j;
#line 345
        j ++;
#line 345
        printf((char const   */* __restrict  */)" %s", *(symbol_name + *(ritem + tmp)));
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 346
      printf((char const   */* __restrict  */)" .");
      }
      {
#line 347
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 347
        if (! ((int )*(ritem + j) >= 0)) {
#line 347
          goto while_break___3;
        }
        {
#line 348
        tmp___0 = j;
#line 348
        j ++;
#line 348
        printf((char const   */* __restrict  */)" %s", *(symbol_name + *(ritem + tmp___0)));
        }
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 349
      printf((char const   */* __restrict  */)"\n");
#line 350
      fflush(stdout);
#line 335
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 328
    k ++;
#line 328
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 353
  return;
}
}
#line 357 "/home/june/collector/temp/byacc-20140101/lr0.c"
void show_ritems(void) 
{ 
  int i ;

  {
#line 362
  i = 0;
  {
#line 362
  while (1) {
    while_continue: /* CIL Label */ ;
#line 362
    if (! (i < nitems)) {
#line 362
      goto while_break;
    }
    {
#line 363
    printf((char const   */* __restrict  */)"ritem[%d] = %d\n", i, (int )*(ritem + i));
#line 362
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 364
  return;
}
}
#line 367 "/home/june/collector/temp/byacc-20140101/lr0.c"
void show_rrhs(void) 
{ 
  int i ;

  {
#line 372
  i = 0;
  {
#line 372
  while (1) {
    while_continue: /* CIL Label */ ;
#line 372
    if (! (i < nrules)) {
#line 372
      goto while_break;
    }
    {
#line 373
    printf((char const   */* __restrict  */)"rrhs[%d] = %d\n", i, (int )*(rrhs + i));
#line 372
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 374
  return;
}
}
#line 378 "/home/june/collector/temp/byacc-20140101/lr0.c"
void show_shifts(void) 
{ 
  shifts *p ;
  int i ;
  int j ;
  int k ;

  {
#line 384
  k = 0;
#line 385
  p = first_shift;
  {
#line 385
  while (1) {
    while_continue: /* CIL Label */ ;
#line 385
    if (! p) {
#line 385
      goto while_break;
    }
#line 387
    if (k) {
      {
#line 388
      printf((char const   */* __restrict  */)"\n");
      }
    }
    {
#line 389
    printf((char const   */* __restrict  */)"shift %d, number = %d, nshifts = %d\n",
           k, (int )p->number, (int )p->nshifts);
#line 391
    j = (int )p->nshifts;
#line 392
    i = 0;
    }
    {
#line 392
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 392
      if (! (i < j)) {
#line 392
        goto while_break___0;
      }
      {
#line 393
      printf((char const   */* __restrict  */)"\t%d\n", (int )p->shift[i]);
#line 392
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 385
    k ++;
#line 385
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 395
  return;
}
}
#line 397 "/home/june/collector/temp/byacc-20140101/lr0.c"
static void save_shifts(void) 
{ 
  shifts *p ;
  short *sp1 ;
  short *sp2 ;
  short *send ;
  void *tmp ;
  short *tmp___0 ;
  short *tmp___1 ;

  {
  {
#line 405
  tmp = allocate(sizeof(shifts ) + (unsigned long )((unsigned int )(nshifts - 1)) * sizeof(short ));
#line 405
  p = (shifts *)tmp;
#line 408
  p->number = this_state->number;
#line 409
  p->nshifts = (Value_t )nshifts;
#line 411
  sp1 = shiftset;
#line 412
  sp2 = p->shift;
#line 413
  send = shiftset + nshifts;
  }
  {
#line 415
  while (1) {
    while_continue: /* CIL Label */ ;
#line 415
    if (! ((unsigned long )sp1 < (unsigned long )send)) {
#line 415
      goto while_break;
    }
#line 416
    tmp___0 = sp2;
#line 416
    sp2 ++;
#line 416
    tmp___1 = sp1;
#line 416
    sp1 ++;
#line 416
    *tmp___0 = *tmp___1;
  }
  while_break: /* CIL Label */ ;
  }
#line 418
  if (last_shift) {
#line 420
    last_shift->next = p;
#line 421
    last_shift = p;
  } else {
#line 425
    first_shift = p;
#line 426
    last_shift = p;
  }
#line 428
  return;
}
}
#line 430 "/home/june/collector/temp/byacc-20140101/lr0.c"
static void save_reductions(void) 
{ 
  short *isp ;
  short *rp1 ;
  short *rp2 ;
  int item ;
  Value_t count ;
  reductions *p ;
  short *rend ;
  Value_t tmp ;
  void *tmp___0 ;
  short *tmp___1 ;
  short *tmp___2 ;

  {
#line 441
  count = (Value_t )0;
#line 442
  isp = itemset;
  {
#line 442
  while (1) {
    while_continue: /* CIL Label */ ;
#line 442
    if (! ((unsigned long )isp < (unsigned long )itemsetend)) {
#line 442
      goto while_break;
    }
#line 444
    item = (int )*(ritem + *isp);
#line 445
    if (item < 0) {
#line 447
      tmp = count;
#line 447
      count = (Value_t )((int )count + 1);
#line 447
      *(redset + tmp) = (Value_t )(- item);
    }
#line 442
    isp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 451
  if (count) {
    {
#line 453
    tmp___0 = allocate(sizeof(reductions ) + (unsigned long )((unsigned int )((int )count - 1)) * sizeof(short ));
#line 453
    p = (reductions *)tmp___0;
#line 457
    p->number = this_state->number;
#line 458
    p->nreds = count;
#line 460
    rp1 = redset;
#line 461
    rp2 = p->rules;
#line 462
    rend = rp1 + (int )count;
    }
    {
#line 464
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 464
      if (! ((unsigned long )rp1 < (unsigned long )rend)) {
#line 464
        goto while_break___0;
      }
#line 465
      tmp___1 = rp2;
#line 465
      rp2 ++;
#line 465
      tmp___2 = rp1;
#line 465
      rp1 ++;
#line 465
      *tmp___1 = *tmp___2;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 467
    if (last_reduction) {
#line 469
      last_reduction->next = p;
#line 470
      last_reduction = p;
    } else {
#line 474
      first_reduction = p;
#line 475
      last_reduction = p;
    }
  }
#line 478
  return;
}
}
#line 480 "/home/june/collector/temp/byacc-20140101/lr0.c"
static void set_derives(void) 
{ 
  Value_t i ;
  Value_t k ;
  int lhs ;
  short *rules ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 487
  tmp = allocate((size_t )nsyms * sizeof(short *));
#line 487
  derives = (short **)tmp;
#line 488
  tmp___0 = allocate((size_t )(nvars + nrules) * sizeof(short ));
#line 488
  rules = (short *)tmp___0;
#line 490
  k = (Value_t )0;
#line 491
  lhs = (int )start_symbol;
  }
  {
#line 491
  while (1) {
    while_continue: /* CIL Label */ ;
#line 491
    if (! (lhs < nsyms)) {
#line 491
      goto while_break;
    }
#line 493
    *(derives + lhs) = rules + (int )k;
#line 494
    i = (Value_t )0;
    {
#line 494
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 494
      if (! ((int )i < nrules)) {
#line 494
        goto while_break___0;
      }
#line 496
      if ((int )*(rlhs + i) == lhs) {
#line 498
        *(rules + k) = i;
#line 499
        k = (Value_t )((int )k + 1);
      }
#line 494
      i = (Value_t )((int )i + 1);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 502
    *(rules + k) = (short)-1;
#line 503
    k = (Value_t )((int )k + 1);
#line 491
    lhs ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 509
  return;
}
}
#line 534 "/home/june/collector/temp/byacc-20140101/lr0.c"
static void set_nullable(void) 
{ 
  int i ;
  int j ;
  int empty ;
  int done_flag ;
  void *tmp ;

  {
  {
#line 541
  tmp = malloc((size_t )nsyms * sizeof(char ));
#line 541
  nullable = (char *)tmp;
  }
#line 542
  if ((unsigned long )nullable == (unsigned long )((char *)0)) {
    {
#line 542
    no_space();
    }
  }
#line 542
  if (! ((unsigned long )nullable != (unsigned long )((char *)0))) {
    {
#line 542
    __assert_fail("nullable != 0", "/home/june/collector/temp/byacc-20140101/lr0.c",
                  542U, "set_nullable");
    }
  }
#line 544
  i = 0;
  {
#line 544
  while (1) {
    while_continue: /* CIL Label */ ;
#line 544
    if (! (i < nsyms)) {
#line 544
      goto while_break;
    }
#line 545
    *(nullable + i) = (char)0;
#line 544
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 547
  done_flag = 0;
  {
#line 548
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 548
    if (! (! done_flag)) {
#line 548
      goto while_break___0;
    }
#line 550
    done_flag = 1;
#line 551
    i = 1;
    {
#line 551
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 551
      if (! (i < nitems)) {
#line 551
        goto while_break___1;
      }
#line 553
      empty = 1;
      {
#line 554
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 554
        j = (int )*(ritem + i);
#line 554
        if (! (j >= 0)) {
#line 554
          goto while_break___2;
        }
#line 556
        if (! *(nullable + j)) {
#line 557
          empty = 0;
        }
#line 558
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 560
      if (empty) {
#line 562
        j = (int )*(rlhs + - j);
#line 563
        if (! *(nullable + j)) {
#line 565
          *(nullable + j) = (char)1;
#line 566
          done_flag = 0;
        }
      }
#line 551
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 581
  return;
}
}
#line 583 "/home/june/collector/temp/byacc-20140101/lr0.c"
void lr0(void) 
{ 


  {
  {
#line 586
  set_derives();
#line 587
  set_nullable();
#line 588
  generate_states();
  }
#line 589
  return;
}
}
#line 5 "/home/june/collector/temp/byacc-20140101/graph.c"
static void graph_state(int stateno ) ;
#line 6
static void graph_LA(int ruleno ) ;
#line 8 "/home/june/collector/temp/byacc-20140101/graph.c"
static unsigned int larno  ;
#line 10 "/home/june/collector/temp/byacc-20140101/graph.c"
void graph(void) 
{ 
  int i ;
  int j ;
  shifts *sp ;
  int sn ;
  int as ;

  {
#line 19
  if (! gflag) {
#line 20
    return;
  }
#line 22
  i = 0;
  {
#line 22
  while (1) {
    while_continue: /* CIL Label */ ;
#line 22
    if (! (i < nstates)) {
#line 22
      goto while_break;
    }
    {
#line 24
    closure((*(state_table + i))->items, (int )(*(state_table + i))->nitems);
#line 25
    graph_state(i);
#line 22
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 28
  fprintf((FILE */* __restrict  */)graph_file, (char const   */* __restrict  */)"\n\n");
#line 29
  i = 0;
  }
  {
#line 29
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 29
    if (! (i < nstates)) {
#line 29
      goto while_break___0;
    }
#line 32
    sp = *(shift_table + i);
#line 33
    if (sp) {
#line 34
      j = 0;
      {
#line 34
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 34
        if (! (j < (int )sp->nshifts)) {
#line 34
          goto while_break___1;
        }
        {
#line 36
        sn = (int )sp->shift[j];
#line 37
        as = (int )*(accessing_symbol + sn);
#line 38
        fprintf((FILE */* __restrict  */)graph_file, (char const   */* __restrict  */)"\tq%d -> q%d [label=\"%s\"];\n",
                i, sn, *(symbol_pname + as));
#line 34
        j ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 29
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 44
  fprintf((FILE */* __restrict  */)graph_file, (char const   */* __restrict  */)"}\n");
#line 46
  i = 0;
  }
  {
#line 46
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 46
    if (! (i < nsyms)) {
#line 46
      goto while_break___2;
    }
    {
#line 47
    free((void *)*(symbol_pname + i));
#line 46
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 48
  free((void *)((char *)symbol_pname));
  }
#line 49
  return;
}
}
#line 51 "/home/june/collector/temp/byacc-20140101/graph.c"
static void graph_state(int stateno ) 
{ 
  short *isp ;
  int rule ;
  short *sp ;
  short *sp1 ;

  {
  {
#line 59
  larno = (unsigned int )*(lookaheads + stateno);
#line 60
  fprintf((FILE */* __restrict  */)graph_file, (char const   */* __restrict  */)"\n\tq%d [label=\"%d:\\l",
          stateno, stateno);
#line 62
  isp = itemset;
  }
  {
#line 62
  while (1) {
    while_continue: /* CIL Label */ ;
#line 62
    if (! ((unsigned long )isp < (unsigned long )itemsetend)) {
#line 62
      goto while_break;
    }
#line 64
    sp = ritem + (int )*isp;
#line 64
    sp1 = sp;
    {
#line 66
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 66
      if (! ((int )*sp >= 0)) {
#line 66
        goto while_break___0;
      }
#line 67
      sp ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 68
    rule = - ((int )*sp);
#line 69
    fprintf((FILE */* __restrict  */)graph_file, (char const   */* __restrict  */)"  %s -> ",
            *(symbol_pname + *(rlhs + rule)));
#line 71
    sp = ritem + (int )*(rrhs + rule);
    }
    {
#line 71
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 71
      if (! ((unsigned long )sp < (unsigned long )sp1)) {
#line 71
        goto while_break___1;
      }
      {
#line 72
      fprintf((FILE */* __restrict  */)graph_file, (char const   */* __restrict  */)"%s ",
              *(symbol_pname + *sp));
#line 71
      sp ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 74
    _IO_putc('.', graph_file);
    }
    {
#line 76
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 76
      if (! ((int )*sp >= 0)) {
#line 76
        goto while_break___2;
      }
      {
#line 78
      fprintf((FILE */* __restrict  */)graph_file, (char const   */* __restrict  */)" %s",
              *(symbol_pname + *sp));
#line 79
      sp ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 82
    if ((int )*sp1 < 0) {
      {
#line 83
      graph_LA(- ((int )*sp1));
      }
    }
    {
#line 85
    fprintf((FILE */* __restrict  */)graph_file, (char const   */* __restrict  */)"\\l");
#line 62
    isp ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 87
  fprintf((FILE */* __restrict  */)graph_file, (char const   */* __restrict  */)"\"];");
  }
#line 88
  return;
}
}
#line 90 "/home/june/collector/temp/byacc-20140101/graph.c"
static void graph_LA(int ruleno ) 
{ 
  int i ;
  unsigned int tokensetsize___0 ;
  unsigned int *rowp ;

  {
#line 97
  tokensetsize___0 = (unsigned int )((ntokens + 31) / 32);
#line 99
  if (ruleno == (int )*(LAruleno + larno)) {
    {
#line 101
    rowp = LA + larno * tokensetsize___0;
#line 103
    fprintf((FILE */* __restrict  */)graph_file, (char const   */* __restrict  */)" { ");
#line 104
    i = ntokens - 1;
    }
    {
#line 104
    while (1) {
      while_continue: /* CIL Label */ ;
#line 104
      if (! (i >= 0)) {
#line 104
        goto while_break;
      }
#line 106
      if ((*(rowp + (i >> 5)) >> (i & 31)) & 1U) {
        {
#line 107
        fprintf((FILE */* __restrict  */)graph_file, (char const   */* __restrict  */)"%s ",
                *(symbol_pname + i));
        }
      }
#line 104
      i --;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 109
    fprintf((FILE */* __restrict  */)graph_file, (char const   */* __restrict  */)"}");
#line 110
    larno ++;
    }
  }
#line 112
  return;
}
}
#line 317 "/home/june/collector/temp/byacc-20140101/defs.h"
Value_t *accessing_symbol  ;
#line 318 "/home/june/collector/temp/byacc-20140101/defs.h"
core **state_table  ;
#line 319 "/home/june/collector/temp/byacc-20140101/defs.h"
shifts **shift_table  ;
#line 320 "/home/june/collector/temp/byacc-20140101/defs.h"
reductions **reduction_table  ;
#line 321 "/home/june/collector/temp/byacc-20140101/defs.h"
unsigned int *LA  ;
#line 322 "/home/june/collector/temp/byacc-20140101/defs.h"
Value_t *LAruleno  ;
#line 323 "/home/june/collector/temp/byacc-20140101/defs.h"
Value_t *lookaheads  ;
#line 324 "/home/june/collector/temp/byacc-20140101/defs.h"
Value_t *goto_map  ;
#line 325 "/home/june/collector/temp/byacc-20140101/defs.h"
Value_t *from_state  ;
#line 326 "/home/june/collector/temp/byacc-20140101/defs.h"
Value_t *to_state  ;
#line 12 "/home/june/collector/temp/byacc-20140101/lalr.c"
static Value_t map_goto(int state , int symbol ) ;
#line 13
static Value_t **transpose(Value_t **R2 , int n ) ;
#line 14
static void add_lookback_edge(int stateno , int ruleno , int gotono ) ;
#line 15
static void build_relations(void) ;
#line 16
static void compute_FOLLOWS(void) ;
#line 17
static void compute_lookaheads(void) ;
#line 18
static void digraph(Value_t **relation ) ;
#line 19
static void initialize_F(void) ;
#line 20
static void initialize_LA(void) ;
#line 21
static void set_accessing_symbol(void) ;
#line 22
static void set_goto_map(void) ;
#line 23
static void set_maxrhs(void) ;
#line 24
static void set_reduction_table(void) ;
#line 25
static void set_shift_table(void) ;
#line 26
static void set_state_table(void) ;
#line 27
static void traverse(int i ) ;
#line 29 "/home/june/collector/temp/byacc-20140101/lalr.c"
static int tokensetsize  ;
#line 41 "/home/june/collector/temp/byacc-20140101/lalr.c"
static Value_t infinity  ;
#line 42 "/home/june/collector/temp/byacc-20140101/lalr.c"
static int maxrhs  ;
#line 43 "/home/june/collector/temp/byacc-20140101/lalr.c"
static int ngotos  ;
#line 44 "/home/june/collector/temp/byacc-20140101/lalr.c"
static unsigned int *F  ;
#line 45 "/home/june/collector/temp/byacc-20140101/lalr.c"
static Value_t **includes  ;
#line 46 "/home/june/collector/temp/byacc-20140101/lalr.c"
static shorts **lookback  ;
#line 47 "/home/june/collector/temp/byacc-20140101/lalr.c"
static Value_t **R  ;
#line 48 "/home/june/collector/temp/byacc-20140101/lalr.c"
static Value_t *INDEX  ;
#line 49 "/home/june/collector/temp/byacc-20140101/lalr.c"
static Value_t *VERTICES  ;
#line 50 "/home/june/collector/temp/byacc-20140101/lalr.c"
static Value_t top  ;
#line 52 "/home/june/collector/temp/byacc-20140101/lalr.c"
void lalr(void) 
{ 


  {
  {
#line 55
  tokensetsize = (ntokens + 31) / 32;
#line 57
  set_state_table();
#line 58
  set_accessing_symbol();
#line 59
  set_shift_table();
#line 60
  set_reduction_table();
#line 61
  set_maxrhs();
#line 62
  initialize_LA();
#line 63
  set_goto_map();
#line 64
  initialize_F();
#line 65
  build_relations();
#line 66
  compute_FOLLOWS();
#line 67
  compute_lookaheads();
  }
#line 68
  return;
}
}
#line 70 "/home/june/collector/temp/byacc-20140101/lalr.c"
static void set_state_table(void) 
{ 
  core *sp ;
  void *tmp ;

  {
  {
#line 75
  tmp = allocate((size_t )nstates * sizeof(core *));
#line 75
  state_table = (core **)tmp;
#line 76
  sp = first_state;
  }
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
#line 76
    if (! sp) {
#line 76
      goto while_break;
    }
#line 77
    *(state_table + sp->number) = sp;
#line 76
    sp = sp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 78
  return;
}
}
#line 80 "/home/june/collector/temp/byacc-20140101/lalr.c"
static void set_accessing_symbol(void) 
{ 
  core *sp ;
  void *tmp ;

  {
  {
#line 85
  tmp = allocate((size_t )nstates * sizeof(Value_t ));
#line 85
  accessing_symbol = (Value_t *)tmp;
#line 86
  sp = first_state;
  }
  {
#line 86
  while (1) {
    while_continue: /* CIL Label */ ;
#line 86
    if (! sp) {
#line 86
      goto while_break;
    }
#line 87
    *(accessing_symbol + sp->number) = sp->accessing_symbol;
#line 86
    sp = sp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 88
  return;
}
}
#line 90 "/home/june/collector/temp/byacc-20140101/lalr.c"
static void set_shift_table(void) 
{ 
  shifts *sp ;
  void *tmp ;

  {
  {
#line 95
  tmp = allocate((size_t )nstates * sizeof(shifts *));
#line 95
  shift_table = (shifts **)tmp;
#line 96
  sp = first_shift;
  }
  {
#line 96
  while (1) {
    while_continue: /* CIL Label */ ;
#line 96
    if (! sp) {
#line 96
      goto while_break;
    }
#line 97
    *(shift_table + sp->number) = sp;
#line 96
    sp = sp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  return;
}
}
#line 100 "/home/june/collector/temp/byacc-20140101/lalr.c"
static void set_reduction_table(void) 
{ 
  reductions *rp ;
  void *tmp ;

  {
  {
#line 105
  tmp = allocate((size_t )nstates * sizeof(reductions *));
#line 105
  reduction_table = (reductions **)tmp;
#line 106
  rp = first_reduction;
  }
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
#line 106
    if (! rp) {
#line 106
      goto while_break;
    }
#line 107
    *(reduction_table + rp->number) = rp;
#line 106
    rp = rp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 108
  return;
}
}
#line 110 "/home/june/collector/temp/byacc-20140101/lalr.c"
static void set_maxrhs(void) 
{ 
  Value_t *itemp ;
  Value_t *item_end ;
  int length ;
  int max ;

  {
#line 118
  length = 0;
#line 119
  max = 0;
#line 120
  item_end = ritem + nitems;
#line 121
  itemp = ritem;
  {
#line 121
  while (1) {
    while_continue: /* CIL Label */ ;
#line 121
    if (! ((unsigned long )itemp < (unsigned long )item_end)) {
#line 121
      goto while_break;
    }
#line 123
    if ((int )*itemp >= 0) {
#line 125
      length ++;
    } else {
#line 129
      if (length > max) {
#line 130
        max = length;
      }
#line 131
      length = 0;
    }
#line 121
    itemp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 135
  maxrhs = max;
#line 136
  return;
}
}
#line 138 "/home/june/collector/temp/byacc-20140101/lalr.c"
static void initialize_LA(void) 
{ 
  int i ;
  int j ;
  int k ;
  reductions *rp ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 144
  tmp = allocate((size_t )(nstates + 1) * sizeof(Value_t ));
#line 144
  lookaheads = (Value_t *)tmp;
#line 146
  k = 0;
#line 147
  i = 0;
  }
  {
#line 147
  while (1) {
    while_continue: /* CIL Label */ ;
#line 147
    if (! (i < nstates)) {
#line 147
      goto while_break;
    }
#line 149
    *(lookaheads + i) = (Value_t )k;
#line 150
    rp = *(reduction_table + i);
#line 151
    if (rp) {
#line 152
      k += (int )rp->nreds;
    }
#line 147
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 154
  *(lookaheads + nstates) = (Value_t )k;
#line 156
  tmp___0 = allocate((size_t )(k * tokensetsize) * sizeof(unsigned int ));
#line 156
  LA = (unsigned int *)tmp___0;
#line 157
  tmp___1 = allocate((size_t )k * sizeof(Value_t ));
#line 157
  LAruleno = (Value_t *)tmp___1;
#line 158
  tmp___2 = allocate((size_t )k * sizeof(shorts *));
#line 158
  lookback = (shorts **)tmp___2;
#line 160
  k = 0;
#line 161
  i = 0;
  }
  {
#line 161
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 161
    if (! (i < nstates)) {
#line 161
      goto while_break___0;
    }
#line 163
    rp = *(reduction_table + i);
#line 164
    if (rp) {
#line 166
      j = 0;
      {
#line 166
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 166
        if (! (j < (int )rp->nreds)) {
#line 166
          goto while_break___1;
        }
#line 168
        *(LAruleno + k) = rp->rules[j];
#line 169
        k ++;
#line 166
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 161
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 173
  return;
}
}
#line 175 "/home/june/collector/temp/byacc-20140101/lalr.c"
static void set_goto_map(void) 
{ 
  shifts *sp ;
  int i ;
  int symbol ;
  int k ;
  Value_t *temp_map ;
  Value_t state2 ;
  Value_t state1 ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  Value_t tmp___3 ;

  {
  {
#line 186
  tmp = allocate((size_t )(nvars + 1) * sizeof(Value_t ));
#line 186
  goto_map = (Value_t *)tmp - ntokens;
#line 187
  tmp___0 = allocate((size_t )(nvars + 1) * sizeof(Value_t ));
#line 187
  temp_map = (Value_t *)tmp___0 - ntokens;
#line 189
  ngotos = 0;
#line 190
  sp = first_shift;
  }
  {
#line 190
  while (1) {
    while_continue: /* CIL Label */ ;
#line 190
    if (! sp) {
#line 190
      goto while_break;
    }
#line 192
    i = (int )sp->nshifts - 1;
    {
#line 192
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 192
      if (! (i >= 0)) {
#line 192
        goto while_break___0;
      }
#line 194
      symbol = (int )*(accessing_symbol + sp->shift[i]);
#line 196
      if (symbol < (int )start_symbol) {
#line 197
        goto while_break___0;
      }
#line 199
      if (ngotos == 32767) {
        {
#line 200
        fatal("too many gotos");
        }
      }
#line 202
      ngotos ++;
#line 203
      *(goto_map + symbol) = (Value_t )((int )*(goto_map + symbol) + 1);
#line 192
      i --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 190
    sp = sp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 207
  k = 0;
#line 208
  i = ntokens;
  {
#line 208
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 208
    if (! (i < nsyms)) {
#line 208
      goto while_break___1;
    }
#line 210
    *(temp_map + i) = (Value_t )k;
#line 211
    k += (int )*(goto_map + i);
#line 208
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 214
  i = ntokens;
  {
#line 214
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 214
    if (! (i < nsyms)) {
#line 214
      goto while_break___2;
    }
#line 215
    *(goto_map + i) = *(temp_map + i);
#line 214
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 217
  *(goto_map + nsyms) = (Value_t )ngotos;
#line 218
  *(temp_map + nsyms) = (Value_t )ngotos;
#line 220
  tmp___1 = allocate((size_t )ngotos * sizeof(Value_t ));
#line 220
  from_state = (Value_t *)tmp___1;
#line 221
  tmp___2 = allocate((size_t )ngotos * sizeof(Value_t ));
#line 221
  to_state = (Value_t *)tmp___2;
#line 223
  sp = first_shift;
  }
  {
#line 223
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 223
    if (! sp) {
#line 223
      goto while_break___3;
    }
#line 225
    state1 = sp->number;
#line 226
    i = (int )sp->nshifts - 1;
    {
#line 226
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 226
      if (! (i >= 0)) {
#line 226
        goto while_break___4;
      }
#line 228
      state2 = sp->shift[i];
#line 229
      symbol = (int )*(accessing_symbol + state2);
#line 231
      if (symbol < (int )start_symbol) {
#line 232
        goto while_break___4;
      }
#line 234
      tmp___3 = *(temp_map + symbol);
#line 234
      *(temp_map + symbol) = (Value_t )((int )*(temp_map + symbol) + 1);
#line 234
      k = (int )tmp___3;
#line 235
      *(from_state + k) = state1;
#line 236
      *(to_state + k) = state2;
#line 226
      i --;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 223
    sp = sp->next;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 240
  free((void *)((char *)(temp_map + ntokens)));
  }
#line 241
  return;
}
}
#line 245 "/home/june/collector/temp/byacc-20140101/lalr.c"
static Value_t map_goto(int state , int symbol ) 
{ 
  int high___0 ;
  int low ;
  int middle ;
  int s ;

  {
#line 253
  low = (int )*(goto_map + symbol);
#line 254
  high___0 = (int )*(goto_map + (symbol + 1));
  {
#line 256
  while (1) {
    while_continue: /* CIL Label */ ;
#line 258
    if (! (low <= high___0)) {
      {
#line 258
      __assert_fail("low <= high", "/home/june/collector/temp/byacc-20140101/lalr.c",
                    258U, "map_goto");
      }
    }
#line 259
    middle = (low + high___0) >> 1;
#line 260
    s = (int )*(from_state + middle);
#line 261
    if (s == state) {
#line 262
      return ((Value_t )middle);
    } else
#line 263
    if (s < state) {
#line 264
      low = middle + 1;
    } else {
#line 266
      high___0 = middle - 1;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 270 "/home/june/collector/temp/byacc-20140101/lalr.c"
static void initialize_F(void) 
{ 
  int i ;
  int j ;
  int k ;
  shifts *sp ;
  Value_t *edge ;
  unsigned int *rowp ;
  Value_t *rp ;
  Value_t **reads ;
  int nedges ;
  int stateno ;
  int symbol ;
  int nwords ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 286
  nwords = ngotos * tokensetsize;
#line 287
  tmp = allocate((size_t )nwords * sizeof(unsigned int ));
#line 287
  F = (unsigned int *)tmp;
#line 289
  tmp___0 = allocate((size_t )ngotos * sizeof(Value_t *));
#line 289
  reads = (Value_t **)tmp___0;
#line 290
  tmp___1 = allocate((size_t )(ngotos + 1) * sizeof(Value_t ));
#line 290
  edge = (Value_t *)tmp___1;
#line 291
  nedges = 0;
#line 293
  rowp = F;
#line 294
  i = 0;
  }
  {
#line 294
  while (1) {
    while_continue: /* CIL Label */ ;
#line 294
    if (! (i < ngotos)) {
#line 294
      goto while_break;
    }
#line 296
    stateno = (int )*(to_state + i);
#line 297
    sp = *(shift_table + stateno);
#line 299
    if (sp) {
#line 301
      k = (int )sp->nshifts;
#line 303
      j = 0;
      {
#line 303
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 303
        if (! (j < k)) {
#line 303
          goto while_break___0;
        }
#line 305
        symbol = (int )*(accessing_symbol + sp->shift[j]);
#line 306
        if (symbol >= (int )start_symbol) {
#line 307
          goto while_break___0;
        }
#line 308
        *(rowp + (symbol >> 5)) |= 1U << (symbol & 31);
#line 303
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 311
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 311
        if (! (j < k)) {
#line 311
          goto while_break___1;
        }
#line 313
        symbol = (int )*(accessing_symbol + sp->shift[j]);
#line 314
        if (*(nullable + symbol)) {
          {
#line 315
          tmp___2 = nedges;
#line 315
          nedges ++;
#line 315
          *(edge + tmp___2) = map_goto(stateno, symbol);
          }
        }
#line 311
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 318
      if (nedges) {
        {
#line 320
        tmp___3 = allocate((size_t )(nedges + 1) * sizeof(Value_t ));
#line 320
        rp = (Value_t *)tmp___3;
#line 320
        *(reads + i) = rp;
#line 322
        j = 0;
        }
        {
#line 322
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 322
          if (! (j < nedges)) {
#line 322
            goto while_break___2;
          }
#line 323
          *(rp + j) = *(edge + j);
#line 322
          j ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 325
        *(rp + nedges) = (Value_t )-1;
#line 326
        nedges = 0;
      }
    }
#line 330
    rowp += tokensetsize;
#line 294
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 333
  *(F + 0) |= 1U;
#line 334
  digraph(reads);
#line 336
  i = 0;
  }
  {
#line 336
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 336
    if (! (i < ngotos)) {
#line 336
      goto while_break___3;
    }
#line 338
    if (*(reads + i)) {
      {
#line 339
      free((void *)((char *)*(reads + i)));
      }
    }
#line 336
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 342
  free((void *)((char *)reads));
#line 343
  free((void *)((char *)edge));
  }
#line 344
  return;
}
}
#line 346 "/home/june/collector/temp/byacc-20140101/lalr.c"
static void build_relations(void) 
{ 
  int i ;
  int j ;
  int k ;
  Value_t *rulep ;
  Value_t *rp ;
  shifts *sp ;
  int length ;
  int nedges ;
  int done_flag ;
  Value_t state1 ;
  Value_t stateno ;
  int symbol1 ;
  int symbol2 ;
  Value_t *shortp ;
  Value_t *edge ;
  Value_t *states ;
  Value_t **new_includes ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;

  {
  {
#line 367
  tmp = allocate((size_t )ngotos * sizeof(Value_t *));
#line 367
  includes = (Value_t **)tmp;
#line 368
  tmp___0 = allocate((size_t )(ngotos + 1) * sizeof(Value_t ));
#line 368
  edge = (Value_t *)tmp___0;
#line 369
  tmp___1 = allocate((size_t )(maxrhs + 1) * sizeof(Value_t ));
#line 369
  states = (Value_t *)tmp___1;
#line 371
  i = 0;
  }
  {
#line 371
  while (1) {
    while_continue: /* CIL Label */ ;
#line 371
    if (! (i < ngotos)) {
#line 371
      goto while_break;
    }
#line 373
    nedges = 0;
#line 374
    state1 = *(from_state + i);
#line 375
    symbol1 = (int )*(accessing_symbol + *(to_state + i));
#line 377
    rulep = *(derives + symbol1);
    {
#line 377
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 377
      if (! ((int )*rulep >= 0)) {
#line 377
        goto while_break___0;
      }
#line 379
      length = 1;
#line 380
      *(states + 0) = state1;
#line 381
      stateno = state1;
#line 383
      rp = ritem + (int )*(rrhs + *rulep);
      {
#line 383
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 383
        if (! ((int )*rp >= 0)) {
#line 383
          goto while_break___1;
        }
#line 385
        symbol2 = (int )*rp;
#line 386
        sp = *(shift_table + stateno);
#line 387
        k = (int )sp->nshifts;
#line 389
        j = 0;
        {
#line 389
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 389
          if (! (j < k)) {
#line 389
            goto while_break___2;
          }
#line 391
          stateno = sp->shift[j];
#line 392
          if ((int )*(accessing_symbol + stateno) == symbol2) {
#line 393
            goto while_break___2;
          }
#line 389
          j ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 396
        tmp___2 = length;
#line 396
        length ++;
#line 396
        *(states + tmp___2) = stateno;
#line 383
        rp ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 399
      add_lookback_edge((int )stateno, (int )*rulep, i);
#line 401
      length --;
#line 402
      done_flag = 0;
      }
      {
#line 403
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 403
        if (! (! done_flag)) {
#line 403
          goto while_break___3;
        }
#line 405
        done_flag = 1;
#line 406
        rp --;
#line 407
        if ((int )*rp >= (int )start_symbol) {
          {
#line 409
          length --;
#line 409
          stateno = *(states + length);
#line 410
          tmp___3 = nedges;
#line 410
          nedges ++;
#line 410
          *(edge + tmp___3) = map_goto((int )stateno, (int )*rp);
          }
#line 411
          if (*(nullable + *rp)) {
#line 411
            if (length > 0) {
#line 412
              done_flag = 0;
            }
          }
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 377
      rulep ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 417
    if (nedges) {
      {
#line 419
      tmp___4 = allocate((size_t )(nedges + 1) * sizeof(Value_t ));
#line 419
      shortp = (Value_t *)tmp___4;
#line 419
      *(includes + i) = shortp;
#line 420
      j = 0;
      }
      {
#line 420
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 420
        if (! (j < nedges)) {
#line 420
          goto while_break___4;
        }
#line 421
        *(shortp + j) = *(edge + j);
#line 420
        j ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 422
      *(shortp + nedges) = (Value_t )-1;
    }
#line 371
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 426
  new_includes = transpose(includes, ngotos);
#line 428
  i = 0;
  }
  {
#line 428
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 428
    if (! (i < ngotos)) {
#line 428
      goto while_break___5;
    }
#line 429
    if (*(includes + i)) {
      {
#line 430
      free((void *)((char *)*(includes + i)));
      }
    }
#line 428
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 432
  free((void *)((char *)includes));
#line 434
  includes = new_includes;
#line 436
  free((void *)((char *)edge));
#line 437
  free((void *)((char *)states));
  }
#line 438
  return;
}
}
#line 440 "/home/june/collector/temp/byacc-20140101/lalr.c"
static void add_lookback_edge(int stateno , int ruleno , int gotono ) 
{ 
  int i ;
  int k ;
  int found ;
  shorts *sp ;
  void *tmp ;

  {
#line 447
  i = (int )*(lookaheads + stateno);
#line 448
  k = (int )*(lookaheads + (stateno + 1));
#line 449
  found = 0;
  {
#line 450
  while (1) {
    while_continue: /* CIL Label */ ;
#line 450
    if (! found) {
#line 450
      if (! (i < k)) {
#line 450
        goto while_break;
      }
    } else {
#line 450
      goto while_break;
    }
#line 452
    if ((int )*(LAruleno + i) == ruleno) {
#line 453
      found = 1;
    } else {
#line 455
      i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 457
  if (! found) {
    {
#line 457
    __assert_fail("found", "/home/june/collector/temp/byacc-20140101/lalr.c", 457U,
                  "add_lookback_edge");
    }
  }
  {
#line 459
  tmp = allocate(sizeof(shorts ));
#line 459
  sp = (shorts *)tmp;
#line 460
  sp->next = *(lookback + i);
#line 461
  sp->value = (Value_t )gotono;
#line 462
  *(lookback + i) = sp;
  }
#line 463
  return;
}
}
#line 465 "/home/june/collector/temp/byacc-20140101/lalr.c"
static Value_t **transpose(Value_t **R2 , int n ) 
{ 
  Value_t **new_R ;
  Value_t **temp_R ;
  Value_t *nedges ;
  Value_t *sp ;
  int i ;
  int k ;
  void *tmp ;
  Value_t *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  Value_t *tmp___4 ;
  Value_t *tmp___5 ;

  {
  {
#line 475
  tmp = allocate((size_t )n * sizeof(Value_t ));
#line 475
  nedges = (Value_t *)tmp;
#line 477
  i = 0;
  }
  {
#line 477
  while (1) {
    while_continue: /* CIL Label */ ;
#line 477
    if (! (i < n)) {
#line 477
      goto while_break;
    }
#line 479
    sp = *(R2 + i);
#line 480
    if (sp) {
      {
#line 482
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 482
        if (! ((int )*sp >= 0)) {
#line 482
          goto while_break___0;
        }
#line 483
        tmp___0 = sp;
#line 483
        sp ++;
#line 483
        *(nedges + *tmp___0) = (Value_t )((int )*(nedges + *tmp___0) + 1);
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 477
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 487
  tmp___1 = allocate((size_t )n * sizeof(Value_t *));
#line 487
  new_R = (Value_t **)tmp___1;
#line 488
  tmp___2 = allocate((size_t )n * sizeof(Value_t *));
#line 488
  temp_R = (Value_t **)tmp___2;
#line 490
  i = 0;
  }
  {
#line 490
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 490
    if (! (i < n)) {
#line 490
      goto while_break___1;
    }
#line 492
    k = (int )*(nedges + i);
#line 493
    if (k > 0) {
      {
#line 495
      tmp___3 = allocate((size_t )(k + 1) * sizeof(Value_t ));
#line 495
      sp = (Value_t *)tmp___3;
#line 496
      *(new_R + i) = sp;
#line 497
      *(temp_R + i) = sp;
#line 498
      *(sp + k) = (Value_t )-1;
      }
    }
#line 490
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 502
  free((void *)((char *)nedges));
#line 504
  i = 0;
  }
  {
#line 504
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 504
    if (! (i < n)) {
#line 504
      goto while_break___2;
    }
#line 506
    sp = *(R2 + i);
#line 507
    if (sp) {
      {
#line 509
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 509
        if (! ((int )*sp >= 0)) {
#line 509
          goto while_break___3;
        }
#line 510
        tmp___4 = sp;
#line 510
        sp ++;
#line 510
        tmp___5 = *(temp_R + *tmp___4);
#line 510
        (*(temp_R + *tmp___4)) ++;
#line 510
        *tmp___5 = (Value_t )i;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 504
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 514
  free((void *)((char *)temp_R));
  }
#line 516
  return (new_R);
}
}
#line 519 "/home/june/collector/temp/byacc-20140101/lalr.c"
static void compute_FOLLOWS(void) 
{ 


  {
  {
#line 522
  digraph(includes);
  }
#line 523
  return;
}
}
#line 525 "/home/june/collector/temp/byacc-20140101/lalr.c"
static void compute_lookaheads(void) 
{ 
  int i ;
  int n ;
  unsigned int *fp1 ;
  unsigned int *fp2 ;
  unsigned int *fp3 ;
  shorts *sp ;
  shorts *next ;
  unsigned int *rowp ;
  unsigned int *tmp ;
  unsigned int *tmp___0 ;

  {
#line 533
  rowp = LA;
#line 534
  n = (int )*(lookaheads + nstates);
#line 535
  i = 0;
  {
#line 535
  while (1) {
    while_continue: /* CIL Label */ ;
#line 535
    if (! (i < n)) {
#line 535
      goto while_break;
    }
#line 537
    fp3 = rowp + tokensetsize;
#line 538
    sp = *(lookback + i);
    {
#line 538
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 538
      if (! sp) {
#line 538
        goto while_break___0;
      }
#line 540
      fp1 = rowp;
#line 541
      fp2 = F + tokensetsize * (int )sp->value;
      {
#line 542
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 542
        if (! ((unsigned long )fp1 < (unsigned long )fp3)) {
#line 542
          goto while_break___1;
        }
#line 543
        tmp = fp1;
#line 543
        fp1 ++;
#line 543
        tmp___0 = fp2;
#line 543
        fp2 ++;
#line 543
        *tmp |= *tmp___0;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 538
      sp = sp->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 545
    rowp = fp3;
#line 535
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 548
  i = 0;
  {
#line 548
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 548
    if (! (i < n)) {
#line 548
      goto while_break___2;
    }
#line 549
    sp = *(lookback + i);
    {
#line 549
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 549
      if (! sp) {
#line 549
        goto while_break___3;
      }
      {
#line 551
      next = sp->next;
#line 552
      free((void *)((char *)sp));
#line 549
      sp = next;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 548
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 555
  free((void *)((char *)lookback));
#line 556
  free((void *)((char *)F));
  }
#line 557
  return;
}
}
#line 559 "/home/june/collector/temp/byacc-20140101/lalr.c"
static void digraph(Value_t **relation ) 
{ 
  int i ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 564
  infinity = (Value_t )(ngotos + 2);
#line 565
  tmp = allocate((size_t )(ngotos + 1) * sizeof(Value_t ));
#line 565
  INDEX = (Value_t *)tmp;
#line 566
  tmp___0 = allocate((size_t )(ngotos + 1) * sizeof(Value_t ));
#line 566
  VERTICES = (Value_t *)tmp___0;
#line 567
  top = (Value_t )0;
#line 569
  R = relation;
#line 571
  i = 0;
  }
  {
#line 571
  while (1) {
    while_continue: /* CIL Label */ ;
#line 571
    if (! (i < ngotos)) {
#line 571
      goto while_break;
    }
#line 572
    *(INDEX + i) = (Value_t )0;
#line 571
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 574
  i = 0;
  {
#line 574
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 574
    if (! (i < ngotos)) {
#line 574
      goto while_break___0;
    }
#line 576
    if ((int )*(INDEX + i) == 0) {
#line 576
      if (*(R + i)) {
        {
#line 577
        traverse(i);
        }
      }
    }
#line 574
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 580
  free((void *)((char *)INDEX));
#line 581
  free((void *)((char *)VERTICES));
  }
#line 582
  return;
}
}
#line 584 "/home/june/collector/temp/byacc-20140101/lalr.c"
static void traverse(int i ) 
{ 
  unsigned int *fp1 ;
  unsigned int *fp2 ;
  unsigned int *fp3 ;
  int j ;
  Value_t *rp ;
  Value_t height ;
  unsigned int *base___0 ;
  unsigned int *tmp ;
  unsigned int *tmp___0 ;
  Value_t *tmp___1 ;
  Value_t tmp___2 ;
  unsigned int *tmp___3 ;
  unsigned int *tmp___4 ;

  {
#line 596
  top = (Value_t )((int )top + 1);
#line 596
  *(VERTICES + top) = (Value_t )i;
#line 597
  height = top;
#line 597
  *(INDEX + i) = height;
#line 599
  base___0 = F + i * tokensetsize;
#line 600
  fp3 = base___0 + tokensetsize;
#line 602
  rp = *(R + i);
#line 603
  if (rp) {
    {
#line 605
    while (1) {
      while_continue: /* CIL Label */ ;
#line 605
      tmp___1 = rp;
#line 605
      rp ++;
#line 605
      j = (int )*tmp___1;
#line 605
      if (! (j >= 0)) {
#line 605
        goto while_break;
      }
#line 607
      if ((int )*(INDEX + j) == 0) {
        {
#line 608
        traverse(j);
        }
      }
#line 610
      if ((int )*(INDEX + i) > (int )*(INDEX + j)) {
#line 611
        *(INDEX + i) = *(INDEX + j);
      }
#line 613
      fp1 = base___0;
#line 614
      fp2 = F + j * tokensetsize;
      {
#line 616
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 616
        if (! ((unsigned long )fp1 < (unsigned long )fp3)) {
#line 616
          goto while_break___0;
        }
#line 617
        tmp = fp1;
#line 617
        fp1 ++;
#line 617
        tmp___0 = fp2;
#line 617
        fp2 ++;
#line 617
        *tmp |= *tmp___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 621
  if ((int )*(INDEX + i) == (int )height) {
    {
#line 623
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 625
      tmp___2 = top;
#line 625
      top = (Value_t )((int )top - 1);
#line 625
      j = (int )*(VERTICES + tmp___2);
#line 626
      *(INDEX + j) = infinity;
#line 628
      if (i == j) {
#line 629
        goto while_break___1;
      }
#line 631
      fp1 = base___0;
#line 632
      fp2 = F + j * tokensetsize;
      {
#line 634
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 634
        if (! ((unsigned long )fp1 < (unsigned long )fp3)) {
#line 634
          goto while_break___2;
        }
#line 635
        tmp___3 = fp2;
#line 635
        fp2 ++;
#line 635
        tmp___4 = fp1;
#line 635
        fp1 ++;
#line 635
        *tmp___3 = *tmp___4;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 638
  return;
}
}
#line 759 "/usr/include/stdio.h"
extern void rewind(FILE *__stream ) ;
#line 8 "/home/june/collector/temp/byacc-20140101/output.c"
static int nvectors  ;
#line 9 "/home/june/collector/temp/byacc-20140101/output.c"
static int nentries  ;
#line 10 "/home/june/collector/temp/byacc-20140101/output.c"
static Value_t **froms  ;
#line 11 "/home/june/collector/temp/byacc-20140101/output.c"
static Value_t **tos  ;
#line 12 "/home/june/collector/temp/byacc-20140101/output.c"
static Value_t *tally  ;
#line 13 "/home/june/collector/temp/byacc-20140101/output.c"
static Value_t *width  ;
#line 14 "/home/june/collector/temp/byacc-20140101/output.c"
static Value_t *state_count  ;
#line 15 "/home/june/collector/temp/byacc-20140101/output.c"
static Value_t *order  ;
#line 16 "/home/june/collector/temp/byacc-20140101/output.c"
static Value_t *base  ;
#line 17 "/home/june/collector/temp/byacc-20140101/output.c"
static Value_t *pos  ;
#line 18 "/home/june/collector/temp/byacc-20140101/output.c"
static int maxtable  ;
#line 19 "/home/june/collector/temp/byacc-20140101/output.c"
static Value_t *table  ;
#line 20 "/home/june/collector/temp/byacc-20140101/output.c"
static Value_t *check  ;
#line 21 "/home/june/collector/temp/byacc-20140101/output.c"
static int lowzero  ;
#line 22 "/home/june/collector/temp/byacc-20140101/output.c"
static int high  ;
#line 24 "/home/june/collector/temp/byacc-20140101/output.c"
static void putc_code(FILE *fp , int c ) 
{ 


  {
#line 27
  if (c == 10) {
#line 27
    if ((unsigned long )fp == (unsigned long )code_file) {
#line 28
      outline ++;
    }
  }
  {
#line 29
  _IO_putc(c, fp);
  }
#line 30
  return;
}
}
#line 32 "/home/june/collector/temp/byacc-20140101/output.c"
static void putl_code(FILE *fp , char const   *s ) 
{ 


  {
#line 35
  if ((unsigned long )fp == (unsigned long )code_file) {
#line 36
    outline ++;
  }
  {
#line 37
  fputs((char const   */* __restrict  */)s, (FILE */* __restrict  */)fp);
  }
#line 38
  return;
}
}
#line 40 "/home/june/collector/temp/byacc-20140101/output.c"
static void puts_code(FILE *fp , char const   *s ) 
{ 


  {
  {
#line 43
  fputs((char const   */* __restrict  */)s, (FILE */* __restrict  */)fp);
  }
#line 44
  return;
}
}
#line 46 "/home/june/collector/temp/byacc-20140101/output.c"
static void write_code_lineno(FILE *fp ) 
{ 


  {
#line 49
  if (! lflag) {
#line 49
    if ((unsigned long )fp == (unsigned long )code_file) {
      {
#line 51
      outline ++;
#line 52
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)(line_format),
              outline, code_file_name);
      }
    }
  }
#line 54
  return;
}
}
#line 56 "/home/june/collector/temp/byacc-20140101/output.c"
static void write_input_lineno(void) 
{ 


  {
#line 59
  if (! lflag) {
    {
#line 61
    outline ++;
#line 62
    fprintf((FILE */* __restrict  */)code_file, (char const   */* __restrict  */)(line_format),
            lineno, input_file_name);
    }
  }
#line 64
  return;
}
}
#line 66 "/home/june/collector/temp/byacc-20140101/output.c"
static void define_prefixed(FILE *fp , char const   *name ) 
{ 
  int bump_line ;
  int tmp ;

  {
#line 69
  if (! rflag) {
#line 69
    tmp = 1;
  } else
#line 69
  if ((unsigned long )fp == (unsigned long )code_file) {
#line 69
    tmp = 1;
  } else {
#line 69
    tmp = 0;
  }
#line 69
  bump_line = tmp;
#line 70
  if (bump_line) {
#line 71
    outline ++;
  }
  {
#line 72
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\n");
  }
#line 74
  if (bump_line) {
#line 75
    outline ++;
  }
  {
#line 76
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"#ifndef %s\n",
          name);
  }
#line 78
  if (bump_line) {
#line 79
    outline ++;
  }
  {
#line 80
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"#define %-10s %s%s\n",
          name, symbol_prefix, name + 2);
  }
#line 82
  if (bump_line) {
#line 83
    outline ++;
  }
  {
#line 84
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"#endif /* %s */\n",
          name);
  }
#line 85
  return;
}
}
#line 87 "/home/june/collector/temp/byacc-20140101/output.c"
static void output_prefix(FILE *fp ) 
{ 


  {
#line 90
  if ((unsigned long )symbol_prefix == (unsigned long )((void *)0)) {
#line 92
    symbol_prefix = "yy";
  } else {
    {
#line 96
    define_prefixed(fp, "yyparse");
#line 97
    define_prefixed(fp, "yylex");
#line 98
    define_prefixed(fp, "yyerror");
#line 99
    define_prefixed(fp, "yychar");
#line 100
    define_prefixed(fp, "yyval");
#line 101
    define_prefixed(fp, "yylval");
#line 102
    define_prefixed(fp, "yydebug");
#line 103
    define_prefixed(fp, "yynerrs");
#line 104
    define_prefixed(fp, "yyerrflag");
#line 105
    define_prefixed(fp, "yylhs");
#line 106
    define_prefixed(fp, "yylen");
#line 107
    define_prefixed(fp, "yydefred");
#line 108
    define_prefixed(fp, "yydgoto");
#line 109
    define_prefixed(fp, "yysindex");
#line 110
    define_prefixed(fp, "yyrindex");
#line 111
    define_prefixed(fp, "yygindex");
#line 112
    define_prefixed(fp, "yytable");
#line 113
    define_prefixed(fp, "yycheck");
#line 114
    define_prefixed(fp, "yyname");
#line 115
    define_prefixed(fp, "yyrule");
    }
  }
#line 117
  if (! rflag) {
#line 118
    outline ++;
  } else
#line 117
  if ((unsigned long )fp == (unsigned long )code_file) {
#line 118
    outline ++;
  }
  {
#line 119
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"#define YYPREFIX \"%s\"\n",
          symbol_prefix);
  }
#line 120
  return;
}
}
#line 122 "/home/june/collector/temp/byacc-20140101/output.c"
static void output_newline(void) 
{ 


  {
#line 125
  if (! rflag) {
#line 126
    outline ++;
  }
  {
#line 127
  _IO_putc('\n', output_file);
  }
#line 128
  return;
}
}
#line 130 "/home/june/collector/temp/byacc-20140101/output.c"
static void output_line(char const   *value ) 
{ 


  {
  {
#line 133
  fputs((char const   */* __restrict  */)value, (FILE */* __restrict  */)output_file);
#line 134
  output_newline();
  }
#line 135
  return;
}
}
#line 137 "/home/june/collector/temp/byacc-20140101/output.c"
static void output_int(int value ) 
{ 


  {
  {
#line 140
  fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"%5d,",
          value);
  }
#line 141
  return;
}
}
#line 143 "/home/june/collector/temp/byacc-20140101/output.c"
static void start_int_table(char const   *name , int value ) 
{ 
  int need ;
  size_t tmp ;
  size_t tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 146
  tmp = strlen(symbol_prefix);
#line 146
  tmp___0 = strlen(name);
#line 146
  need = 34 - (int )(tmp + tmp___0);
  }
#line 148
  if (need < 6) {
#line 149
    need = 6;
  }
#line 150
  if (rflag) {
#line 150
    tmp___1 = "";
  } else {
#line 150
    tmp___1 = "static ";
  }
  {
#line 150
  fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"%sconst short %s%s[] = {%*d,",
          tmp___1, symbol_prefix, name, need, value);
  }
#line 153
  return;
}
}
#line 155 "/home/june/collector/temp/byacc-20140101/output.c"
static void start_str_table(char const   *name ) 
{ 
  char const   *tmp ;

  {
#line 158
  if (rflag) {
#line 158
    tmp = "";
  } else {
#line 158
    tmp = "static ";
  }
  {
#line 158
  fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"%sconst char *%s%s[] = {",
          tmp, "yy", name);
#line 161
  output_newline();
  }
#line 162
  return;
}
}
#line 164 "/home/june/collector/temp/byacc-20140101/output.c"
static void end_table(void) 
{ 


  {
  {
#line 167
  output_newline();
#line 168
  output_line("};");
  }
#line 169
  return;
}
}
#line 171 "/home/june/collector/temp/byacc-20140101/output.c"
static void output_rule_data(void) 
{ 
  int i ;
  int j ;

  {
  {
#line 177
  start_int_table("lhs", (int )*(symbol_value + start_symbol));
#line 179
  j = 10;
#line 180
  i = 3;
  }
  {
#line 180
  while (1) {
    while_continue: /* CIL Label */ ;
#line 180
    if (! (i < nrules)) {
#line 180
      goto while_break;
    }
#line 182
    if (j >= 10) {
      {
#line 184
      output_newline();
#line 185
      j = 1;
      }
    } else {
#line 188
      j ++;
    }
    {
#line 190
    output_int((int )*(symbol_value + *(rlhs + i)));
#line 180
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 192
  end_table();
#line 194
  start_int_table("len", 2);
#line 196
  j = 10;
#line 197
  i = 3;
  }
  {
#line 197
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 197
    if (! (i < nrules)) {
#line 197
      goto while_break___0;
    }
#line 199
    if (j >= 10) {
      {
#line 201
      output_newline();
#line 202
      j = 1;
      }
    } else {
#line 205
      j ++;
    }
    {
#line 207
    output_int(((int )*(rrhs + (i + 1)) - (int )*(rrhs + i)) - 1);
#line 197
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 209
  end_table();
  }
#line 210
  return;
}
}
#line 212 "/home/june/collector/temp/byacc-20140101/output.c"
static void output_yydefred(void) 
{ 
  int i ;
  int j ;
  int tmp ;
  int tmp___0 ;

  {
#line 217
  if (*(defred + 0)) {
#line 217
    tmp = (int )*(defred + 0) - 2;
  } else {
#line 217
    tmp = 0;
  }
  {
#line 217
  start_int_table("defred", tmp);
#line 219
  j = 10;
#line 220
  i = 1;
  }
  {
#line 220
  while (1) {
    while_continue: /* CIL Label */ ;
#line 220
    if (! (i < nstates)) {
#line 220
      goto while_break;
    }
#line 222
    if (j < 10) {
#line 223
      j ++;
    } else {
      {
#line 226
      output_newline();
#line 227
      j = 1;
      }
    }
#line 230
    if (*(defred + i)) {
#line 230
      tmp___0 = (int )*(defred + i) - 2;
    } else {
#line 230
      tmp___0 = 0;
    }
    {
#line 230
    output_int(tmp___0);
#line 220
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 233
  end_table();
  }
#line 234
  return;
}
}
#line 236 "/home/june/collector/temp/byacc-20140101/output.c"
static void token_actions(void) 
{ 
  int i ;
  int j ;
  Value_t shiftcount ;
  Value_t reducecount ;
  int max ;
  int min ;
  Value_t *actionrow ;
  Value_t *r ;
  Value_t *s ;
  action *p ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  Value_t *tmp___2 ;
  Value_t *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  Value_t *tmp___6 ;
  Value_t *tmp___7 ;

  {
  {
#line 245
  tmp = allocate((size_t )(2 * ntokens) * sizeof(Value_t ));
#line 245
  actionrow = (Value_t *)tmp;
#line 246
  i = 0;
  }
  {
#line 246
  while (1) {
    while_continue: /* CIL Label */ ;
#line 246
    if (! (i < nstates)) {
#line 246
      goto while_break;
    }
#line 248
    if (*(parser + i)) {
#line 250
      j = 0;
      {
#line 250
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 250
        if (! (j < 2 * ntokens)) {
#line 250
          goto while_break___0;
        }
#line 251
        *(actionrow + j) = (Value_t )0;
#line 250
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 253
      shiftcount = (Value_t )0;
#line 254
      reducecount = (Value_t )0;
#line 255
      p = *(parser + i);
      {
#line 255
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 255
        if (! p) {
#line 255
          goto while_break___1;
        }
#line 257
        if ((int )p->suppressed == 0) {
#line 259
          if ((int )p->action_code == 1) {
#line 261
            shiftcount = (Value_t )((int )shiftcount + 1);
#line 262
            *(actionrow + p->symbol) = p->number;
          } else
#line 264
          if ((int )p->action_code == 2) {
#line 264
            if ((int )p->number != (int )*(defred + i)) {
#line 266
              reducecount = (Value_t )((int )reducecount + 1);
#line 267
              *(actionrow + ((int )p->symbol + ntokens)) = p->number;
            }
          }
        }
#line 255
        p = p->next;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 272
      *(tally + i) = shiftcount;
#line 273
      *(tally + (nstates + i)) = reducecount;
#line 274
      *(width + i) = (Value_t )0;
#line 275
      *(width + (nstates + i)) = (Value_t )0;
#line 276
      if ((int )shiftcount > 0) {
        {
#line 278
        tmp___0 = allocate((size_t )shiftcount * sizeof(Value_t ));
#line 278
        r = (Value_t *)tmp___0;
#line 278
        *(froms + i) = r;
#line 279
        tmp___1 = allocate((size_t )shiftcount * sizeof(Value_t ));
#line 279
        s = (Value_t *)tmp___1;
#line 279
        *(tos + i) = s;
#line 280
        min = 32767;
#line 281
        max = 0;
#line 282
        j = 0;
        }
        {
#line 282
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 282
          if (! (j < ntokens)) {
#line 282
            goto while_break___2;
          }
#line 284
          if (*(actionrow + j)) {
#line 286
            if (min > (int )*(symbol_value + j)) {
#line 287
              min = (int )*(symbol_value + j);
            }
#line 288
            if (max < (int )*(symbol_value + j)) {
#line 289
              max = (int )*(symbol_value + j);
            }
#line 290
            tmp___2 = r;
#line 290
            r ++;
#line 290
            *tmp___2 = *(symbol_value + j);
#line 291
            tmp___3 = s;
#line 291
            s ++;
#line 291
            *tmp___3 = *(actionrow + j);
          }
#line 282
          j ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 294
        *(width + i) = (Value_t )((max - min) + 1);
      }
#line 296
      if ((int )reducecount > 0) {
        {
#line 298
        tmp___4 = allocate((size_t )reducecount * sizeof(Value_t ));
#line 298
        r = (Value_t *)tmp___4;
#line 298
        *(froms + (nstates + i)) = r;
#line 299
        tmp___5 = allocate((size_t )reducecount * sizeof(Value_t ));
#line 299
        s = (Value_t *)tmp___5;
#line 299
        *(tos + (nstates + i)) = s;
#line 300
        min = 32767;
#line 301
        max = 0;
#line 302
        j = 0;
        }
        {
#line 302
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 302
          if (! (j < ntokens)) {
#line 302
            goto while_break___3;
          }
#line 304
          if (*(actionrow + (ntokens + j))) {
#line 306
            if (min > (int )*(symbol_value + j)) {
#line 307
              min = (int )*(symbol_value + j);
            }
#line 308
            if (max < (int )*(symbol_value + j)) {
#line 309
              max = (int )*(symbol_value + j);
            }
#line 310
            tmp___6 = r;
#line 310
            r ++;
#line 310
            *tmp___6 = *(symbol_value + j);
#line 311
            tmp___7 = s;
#line 311
            s ++;
#line 311
            *tmp___7 = (Value_t )((int )*(actionrow + (ntokens + j)) - 2);
          }
#line 302
          j ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 314
        *(width + (nstates + i)) = (Value_t )((max - min) + 1);
      }
    }
#line 246
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 318
  free((void *)((char *)actionrow));
  }
#line 319
  return;
}
}
#line 321 "/home/june/collector/temp/byacc-20140101/output.c"
static int default_goto(int symbol ) 
{ 
  int i ;
  int m ;
  int n ;
  int default_state ;
  int max ;

  {
#line 330
  m = (int )*(goto_map + symbol);
#line 331
  n = (int )*(goto_map + (symbol + 1));
#line 333
  if (m == n) {
#line 334
    return (0);
  }
#line 336
  i = 0;
  {
#line 336
  while (1) {
    while_continue: /* CIL Label */ ;
#line 336
    if (! (i < nstates)) {
#line 336
      goto while_break;
    }
#line 337
    *(state_count + i) = (Value_t )0;
#line 336
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 339
  i = m;
  {
#line 339
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 339
    if (! (i < n)) {
#line 339
      goto while_break___0;
    }
#line 340
    *(state_count + *(to_state + i)) = (Value_t )((int )*(state_count + *(to_state + i)) + 1);
#line 339
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 342
  max = 0;
#line 343
  default_state = 0;
#line 344
  i = 0;
  {
#line 344
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 344
    if (! (i < nstates)) {
#line 344
      goto while_break___1;
    }
#line 346
    if ((int )*(state_count + i) > max) {
#line 348
      max = (int )*(state_count + i);
#line 349
      default_state = i;
    }
#line 344
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 353
  return (default_state);
}
}
#line 356 "/home/june/collector/temp/byacc-20140101/output.c"
static void save_column(int symbol , int default_state ) 
{ 
  int i ;
  int m ;
  int n ;
  Value_t *sp ;
  Value_t *sp1 ;
  Value_t *sp2 ;
  Value_t count ;
  int symno ;
  void *tmp ;
  void *tmp___0 ;
  Value_t *tmp___1 ;
  Value_t *tmp___2 ;

  {
#line 368
  m = (int )*(goto_map + symbol);
#line 369
  n = (int )*(goto_map + (symbol + 1));
#line 371
  count = (Value_t )0;
#line 372
  i = m;
  {
#line 372
  while (1) {
    while_continue: /* CIL Label */ ;
#line 372
    if (! (i < n)) {
#line 372
      goto while_break;
    }
#line 374
    if ((int )*(to_state + i) != default_state) {
#line 375
      count = (Value_t )((int )count + 1);
    }
#line 372
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 377
  if ((int )count == 0) {
#line 378
    return;
  }
  {
#line 380
  symno = (int )*(symbol_value + symbol) + 2 * nstates;
#line 382
  tmp = allocate((size_t )count * sizeof(Value_t ));
#line 382
  sp = (Value_t *)tmp;
#line 382
  sp1 = sp;
#line 382
  *(froms + symno) = sp1;
#line 383
  tmp___0 = allocate((size_t )count * sizeof(Value_t ));
#line 383
  sp2 = (Value_t *)tmp___0;
#line 383
  *(tos + symno) = sp2;
#line 385
  i = m;
  }
  {
#line 385
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 385
    if (! (i < n)) {
#line 385
      goto while_break___0;
    }
#line 387
    if ((int )*(to_state + i) != default_state) {
#line 389
      tmp___1 = sp1;
#line 389
      sp1 ++;
#line 389
      *tmp___1 = *(from_state + i);
#line 390
      tmp___2 = sp2;
#line 390
      sp2 ++;
#line 390
      *tmp___2 = *(to_state + i);
    }
#line 385
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 394
  *(tally + symno) = count;
#line 395
  *(width + symno) = (Value_t )(((int )*(sp1 + -1) - (int )*(sp + 0)) + 1);
#line 396
  return;
}
}
#line 398 "/home/june/collector/temp/byacc-20140101/output.c"
static void goto_actions(void) 
{ 
  int i ;
  int j ;
  int k ;
  void *tmp ;

  {
  {
#line 403
  tmp = allocate((size_t )nstates * sizeof(Value_t ));
#line 403
  state_count = (Value_t *)tmp;
#line 405
  k = default_goto((int )start_symbol + 1);
#line 406
  start_int_table("dgoto", k);
#line 407
  save_column((int )start_symbol + 1, k);
#line 409
  j = 10;
#line 410
  i = (int )start_symbol + 2;
  }
  {
#line 410
  while (1) {
    while_continue: /* CIL Label */ ;
#line 410
    if (! (i < nsyms)) {
#line 410
      goto while_break;
    }
#line 412
    if (j >= 10) {
      {
#line 414
      output_newline();
#line 415
      j = 1;
      }
    } else {
#line 418
      j ++;
    }
    {
#line 420
    k = default_goto(i);
#line 421
    output_int(k);
#line 422
    save_column(i, k);
#line 410
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 425
  end_table();
#line 426
  free((void *)((char *)state_count));
  }
#line 427
  return;
}
}
#line 429 "/home/june/collector/temp/byacc-20140101/output.c"
static void sort_actions(void) 
{ 
  Value_t i ;
  int j ;
  int k ;
  int t ;
  int w ;
  void *tmp ;

  {
  {
#line 438
  tmp = allocate((size_t )nvectors * sizeof(Value_t ));
#line 438
  order = (Value_t *)tmp;
#line 439
  nentries = 0;
#line 441
  i = (Value_t )0;
  }
  {
#line 441
  while (1) {
    while_continue: /* CIL Label */ ;
#line 441
    if (! ((int )i < nvectors)) {
#line 441
      goto while_break;
    }
#line 443
    if ((int )*(tally + i) > 0) {
#line 445
      t = (int )*(tally + i);
#line 446
      w = (int )*(width + i);
#line 447
      j = nentries - 1;
      {
#line 449
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 449
        if (j >= 0) {
#line 449
          if (! ((int )*(width + *(order + j)) < w)) {
#line 449
            goto while_break___0;
          }
        } else {
#line 449
          goto while_break___0;
        }
#line 450
        j --;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 452
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 452
        if (j >= 0) {
#line 452
          if ((int )*(width + *(order + j)) == w) {
#line 452
            if (! ((int )*(tally + *(order + j)) < t)) {
#line 452
              goto while_break___1;
            }
          } else {
#line 452
            goto while_break___1;
          }
        } else {
#line 452
          goto while_break___1;
        }
#line 453
        j --;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 455
      k = nentries - 1;
      {
#line 455
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 455
        if (! (k > j)) {
#line 455
          goto while_break___2;
        }
#line 456
        *(order + (k + 1)) = *(order + k);
#line 455
        k --;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 458
      *(order + (j + 1)) = i;
#line 459
      nentries ++;
    }
#line 441
    i = (Value_t )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 462
  return;
}
}
#line 480 "/home/june/collector/temp/byacc-20140101/output.c"
static int matching_vector(int vector ) 
{ 
  int i ;
  int j ;
  int k ;
  int t ;
  int w ;
  int match ;
  int prev ;

  {
#line 491
  i = (int )*(order + vector);
#line 492
  if (i >= 2 * nstates) {
#line 493
    return (-1);
  }
#line 495
  t = (int )*(tally + i);
#line 496
  w = (int )*(width + i);
#line 498
  prev = vector - 1;
  {
#line 498
  while (1) {
    while_continue: /* CIL Label */ ;
#line 498
    if (! (prev >= 0)) {
#line 498
      goto while_break;
    }
#line 500
    j = (int )*(order + prev);
#line 501
    if ((int )*(width + j) != w) {
#line 502
      return (-1);
    } else
#line 501
    if ((int )*(tally + j) != t) {
#line 502
      return (-1);
    }
#line 504
    match = 1;
#line 505
    k = 0;
    {
#line 505
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 505
      if (match) {
#line 505
        if (! (k < t)) {
#line 505
          goto while_break___0;
        }
      } else {
#line 505
        goto while_break___0;
      }
#line 507
      if ((int )*(*(tos + j) + k) != (int )*(*(tos + i) + k)) {
#line 508
        match = 0;
      } else
#line 507
      if ((int )*(*(froms + j) + k) != (int )*(*(froms + i) + k)) {
#line 508
        match = 0;
      }
#line 505
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 511
    if (match) {
#line 512
      return (j);
    }
#line 498
    prev --;
  }
  while_break: /* CIL Label */ ;
  }
#line 515
  return (-1);
}
}
#line 518 "/home/june/collector/temp/byacc-20140101/output.c"
static int pack_vector(int vector ) 
{ 
  int i ;
  int j ;
  int k ;
  int l ;
  int t ;
  int loc ;
  int ok ;
  Value_t *from ;
  Value_t *to ;
  int newmax ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 529
  i = (int )*(order + vector);
#line 530
  t = (int )*(tally + i);
#line 531
  if (! t) {
    {
#line 531
    __assert_fail("t", "/home/june/collector/temp/byacc-20140101/output.c", 531U,
                  "pack_vector");
    }
  }
#line 533
  from = *(froms + i);
#line 534
  to = *(tos + i);
#line 536
  j = lowzero - (int )*(from + 0);
#line 537
  k = 1;
  {
#line 537
  while (1) {
    while_continue: /* CIL Label */ ;
#line 537
    if (! (k < t)) {
#line 537
      goto while_break;
    }
#line 538
    if (lowzero - (int )*(from + k) > j) {
#line 539
      j = lowzero - (int )*(from + k);
    }
#line 537
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 540
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 542
    if (j == 0) {
#line 543
      goto __Cont;
    }
#line 544
    ok = 1;
#line 545
    k = 0;
    {
#line 545
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 545
      if (ok) {
#line 545
        if (! (k < t)) {
#line 545
          goto while_break___1;
        }
      } else {
#line 545
        goto while_break___1;
      }
#line 547
      loc = j + (int )*(from + k);
#line 548
      if (loc >= maxtable - 1) {
#line 550
        if (loc >= 32499) {
          {
#line 551
          fatal("maximum table size exceeded");
          }
        }
#line 553
        newmax = maxtable;
        {
#line 554
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 556
          newmax += 200;
#line 554
          if (! (newmax <= loc)) {
#line 554
            goto while_break___2;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 560
        tmp = realloc((void *)((char *)table), (size_t )newmax * sizeof(Value_t ));
#line 560
        table = (Value_t *)tmp;
        }
#line 561
        if ((unsigned long )table == (unsigned long )((Value_t *)0)) {
          {
#line 561
          no_space();
          }
        }
#line 561
        if (! ((unsigned long )table != (unsigned long )((Value_t *)0))) {
          {
#line 561
          __assert_fail("table != 0", "/home/june/collector/temp/byacc-20140101/output.c",
                        561U, "pack_vector");
          }
        }
        {
#line 563
        tmp___0 = realloc((void *)((char *)check), (size_t )newmax * sizeof(Value_t ));
#line 563
        check = (Value_t *)tmp___0;
        }
#line 564
        if ((unsigned long )check == (unsigned long )((Value_t *)0)) {
          {
#line 564
          no_space();
          }
        }
#line 564
        if (! ((unsigned long )check != (unsigned long )((Value_t *)0))) {
          {
#line 564
          __assert_fail("check != 0", "/home/june/collector/temp/byacc-20140101/output.c",
                        564U, "pack_vector");
          }
        }
#line 566
        l = maxtable;
        {
#line 566
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 566
          if (! (l < newmax)) {
#line 566
            goto while_break___3;
          }
#line 568
          *(table + l) = (Value_t )0;
#line 569
          *(check + l) = (Value_t )-1;
#line 566
          l ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 571
        maxtable = newmax;
      }
#line 574
      if ((int )*(check + loc) != -1) {
#line 575
        ok = 0;
      }
#line 545
      k ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 577
    k = 0;
    {
#line 577
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 577
      if (ok) {
#line 577
        if (! (k < vector)) {
#line 577
          goto while_break___4;
        }
      } else {
#line 577
        goto while_break___4;
      }
#line 579
      if ((int )*(pos + k) == j) {
#line 580
        ok = 0;
      }
#line 577
      k ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 582
    if (ok) {
#line 584
      k = 0;
      {
#line 584
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 584
        if (! (k < t)) {
#line 584
          goto while_break___5;
        }
#line 586
        loc = j + (int )*(from + k);
#line 587
        *(table + loc) = *(to + k);
#line 588
        *(check + loc) = *(from + k);
#line 589
        if (loc > high) {
#line 590
          high = loc;
        }
#line 584
        k ++;
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 593
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 593
        if (! ((int )*(check + lowzero) != -1)) {
#line 593
          goto while_break___6;
        }
#line 594
        lowzero ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 596
      return (j);
    }
    __Cont: /* CIL Label */ 
#line 540
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
}
}
#line 601 "/home/june/collector/temp/byacc-20140101/output.c"
static void pack_table(void) 
{ 
  int i ;
  Value_t place ;
  int state ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 608
  tmp = allocate((size_t )nvectors * sizeof(Value_t ));
#line 608
  base = (Value_t *)tmp;
#line 609
  tmp___0 = allocate((size_t )nentries * sizeof(Value_t ));
#line 609
  pos = (Value_t *)tmp___0;
#line 611
  maxtable = 1000;
#line 612
  tmp___1 = allocate((size_t )maxtable * sizeof(Value_t ));
#line 612
  table = (Value_t *)tmp___1;
#line 613
  tmp___2 = allocate((size_t )maxtable * sizeof(Value_t ));
#line 613
  check = (Value_t *)tmp___2;
#line 615
  lowzero = 0;
#line 616
  high = 0;
#line 618
  i = 0;
  }
  {
#line 618
  while (1) {
    while_continue: /* CIL Label */ ;
#line 618
    if (! (i < maxtable)) {
#line 618
      goto while_break;
    }
#line 619
    *(check + i) = (Value_t )-1;
#line 618
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 621
  i = 0;
  {
#line 621
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 621
    if (! (i < nentries)) {
#line 621
      goto while_break___0;
    }
    {
#line 623
    state = matching_vector(i);
    }
#line 625
    if (state < 0) {
      {
#line 626
      tmp___3 = pack_vector(i);
#line 626
      place = (Value_t )tmp___3;
      }
    } else {
#line 628
      place = *(base + state);
    }
#line 630
    *(pos + i) = place;
#line 631
    *(base + *(order + i)) = place;
#line 621
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 634
  i = 0;
  {
#line 634
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 634
    if (! (i < nvectors)) {
#line 634
      goto while_break___1;
    }
#line 636
    if (*(froms + i)) {
      {
#line 637
      free((void *)((char *)*(froms + i)));
      }
    }
#line 638
    if (*(tos + i)) {
      {
#line 639
      free((void *)((char *)*(tos + i)));
      }
    }
#line 634
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 642
  free((void *)((char *)froms));
#line 643
  free((void *)((char *)tos));
#line 644
  free((void *)((char *)pos));
  }
#line 645
  return;
}
}
#line 647 "/home/june/collector/temp/byacc-20140101/output.c"
static void output_base(void) 
{ 
  int i ;
  int j ;

  {
  {
#line 652
  start_int_table("sindex", (int )*(base + 0));
#line 654
  j = 10;
#line 655
  i = 1;
  }
  {
#line 655
  while (1) {
    while_continue: /* CIL Label */ ;
#line 655
    if (! (i < nstates)) {
#line 655
      goto while_break;
    }
#line 657
    if (j >= 10) {
      {
#line 659
      output_newline();
#line 660
      j = 1;
      }
    } else {
#line 663
      j ++;
    }
    {
#line 665
    output_int((int )*(base + i));
#line 655
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 668
  end_table();
#line 670
  start_int_table("rindex", (int )*(base + nstates));
#line 672
  j = 10;
#line 673
  i = nstates + 1;
  }
  {
#line 673
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 673
    if (! (i < 2 * nstates)) {
#line 673
      goto while_break___0;
    }
#line 675
    if (j >= 10) {
      {
#line 677
      output_newline();
#line 678
      j = 1;
      }
    } else {
#line 681
      j ++;
    }
    {
#line 683
    output_int((int )*(base + i));
#line 673
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 686
  end_table();
#line 688
  start_int_table("gindex", (int )*(base + 2 * nstates));
#line 690
  j = 10;
#line 691
  i = 2 * nstates + 1;
  }
  {
#line 691
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 691
    if (! (i < nvectors - 1)) {
#line 691
      goto while_break___1;
    }
#line 693
    if (j >= 10) {
      {
#line 695
      output_newline();
#line 696
      j = 1;
      }
    } else {
#line 699
      j ++;
    }
    {
#line 701
    output_int((int )*(base + i));
#line 691
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 704
  end_table();
#line 705
  free((void *)((char *)base));
  }
#line 706
  return;
}
}
#line 708 "/home/june/collector/temp/byacc-20140101/output.c"
static void output_table(void) 
{ 
  int i ;
  int j ;

  {
  {
#line 714
  outline ++;
#line 715
  fprintf((FILE */* __restrict  */)code_file, (char const   */* __restrict  */)"#define YYTABLESIZE %d\n",
          high);
#line 716
  start_int_table("table", (int )*(table + 0));
#line 718
  j = 10;
#line 719
  i = 1;
  }
  {
#line 719
  while (1) {
    while_continue: /* CIL Label */ ;
#line 719
    if (! (i <= high)) {
#line 719
      goto while_break;
    }
#line 721
    if (j >= 10) {
      {
#line 723
      output_newline();
#line 724
      j = 1;
      }
    } else {
#line 727
      j ++;
    }
    {
#line 729
    output_int((int )*(table + i));
#line 719
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 732
  end_table();
#line 733
  free((void *)((char *)table));
  }
#line 734
  return;
}
}
#line 736 "/home/june/collector/temp/byacc-20140101/output.c"
static void output_check(void) 
{ 
  int i ;
  int j ;

  {
  {
#line 742
  start_int_table("check", (int )*(check + 0));
#line 744
  j = 10;
#line 745
  i = 1;
  }
  {
#line 745
  while (1) {
    while_continue: /* CIL Label */ ;
#line 745
    if (! (i <= high)) {
#line 745
      goto while_break;
    }
#line 747
    if (j >= 10) {
      {
#line 749
      output_newline();
#line 750
      j = 1;
      }
    } else {
#line 753
      j ++;
    }
    {
#line 755
    output_int((int )*(check + i));
#line 745
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 758
  end_table();
#line 759
  free((void *)((char *)check));
  }
#line 760
  return;
}
}
#line 762 "/home/june/collector/temp/byacc-20140101/output.c"
static void output_actions(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 765
  nvectors = 2 * nstates + nvars;
#line 767
  tmp = allocate((size_t )nvectors * sizeof(Value_t *));
#line 767
  froms = (Value_t **)tmp;
#line 768
  tmp___0 = allocate((size_t )nvectors * sizeof(Value_t *));
#line 768
  tos = (Value_t **)tmp___0;
#line 769
  tmp___1 = allocate((size_t )nvectors * sizeof(Value_t ));
#line 769
  tally = (Value_t *)tmp___1;
#line 770
  tmp___2 = allocate((size_t )nvectors * sizeof(Value_t ));
#line 770
  width = (Value_t *)tmp___2;
#line 772
  token_actions();
#line 773
  free((void *)((char *)lookaheads));
#line 774
  free((void *)((char *)LA));
#line 775
  free((void *)((char *)LAruleno));
#line 776
  free((void *)((char *)accessing_symbol));
#line 778
  goto_actions();
#line 779
  free((void *)((char *)(goto_map + ntokens)));
#line 780
  free((void *)((char *)from_state));
#line 781
  free((void *)((char *)to_state));
#line 783
  sort_actions();
#line 784
  pack_table();
#line 785
  output_base();
#line 786
  output_table();
#line 787
  output_check();
  }
#line 788
  return;
}
}
#line 790 "/home/june/collector/temp/byacc-20140101/output.c"
static int is_C_identifier(char *name ) 
{ 
  char *s ;
  int c ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
#line 796
  s = name;
#line 797
  c = (int )*s;
#line 798
  if (c == 34) {
    {
#line 800
    s ++;
#line 800
    c = (int )*s;
#line 801
    tmp = __ctype_b_loc();
    }
#line 801
    if (! ((int const   )*(*tmp + c) & 1024)) {
#line 801
      if (c != 95) {
#line 801
        if (c != 36) {
#line 802
          return (0);
        }
      }
    }
    {
#line 803
    while (1) {
      while_continue: /* CIL Label */ ;
#line 803
      s ++;
#line 803
      c = (int )*s;
#line 803
      if (! (c != 34)) {
#line 803
        goto while_break;
      }
      {
#line 805
      tmp___0 = __ctype_b_loc();
      }
#line 805
      if (! ((int const   )*(*tmp___0 + c) & 8)) {
#line 805
        if (c != 95) {
#line 805
          if (c != 36) {
#line 806
            return (0);
          }
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 808
    return (1);
  }
  {
#line 811
  tmp___1 = __ctype_b_loc();
  }
#line 811
  if (! ((int const   )*(*tmp___1 + c) & 1024)) {
#line 811
    if (c != 95) {
#line 811
      if (c != 36) {
#line 812
        return (0);
      }
    }
  }
  {
#line 813
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 813
    s ++;
#line 813
    c = (int )*s;
#line 813
    if (! (c != 0)) {
#line 813
      goto while_break___0;
    }
    {
#line 815
    tmp___2 = __ctype_b_loc();
    }
#line 815
    if (! ((int const   )*(*tmp___2 + c) & 8)) {
#line 815
      if (c != 95) {
#line 815
        if (c != 36) {
#line 816
          return (0);
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 818
  return (1);
}
}
#line 821 "/home/june/collector/temp/byacc-20140101/output.c"
static void output_defines(FILE *fp ) 
{ 
  int c ;
  int i ;
  char *s ;
  int tmp ;

  {
#line 827
  i = 2;
  {
#line 827
  while (1) {
    while_continue: /* CIL Label */ ;
#line 827
    if (! (i < ntokens)) {
#line 827
      goto while_break;
    }
    {
#line 829
    s = *(symbol_name + i);
#line 830
    tmp = is_C_identifier(s);
    }
#line 830
    if (tmp) {
#line 830
      if (! sflag) {
#line 830
        goto _L;
      } else
#line 830
      if ((int )*s != 34) {
        _L: /* CIL Label */ 
        {
#line 832
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"#define ");
#line 833
        c = (int )*s;
        }
#line 834
        if (c == 34) {
          {
#line 836
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 836
            s ++;
#line 836
            c = (int )*s;
#line 836
            if (! (c != 34)) {
#line 836
              goto while_break___0;
            }
            {
#line 838
            _IO_putc(c, fp);
            }
          }
          while_break___0: /* CIL Label */ ;
          }
        } else {
          {
#line 843
          while (1) {
            while_continue___1: /* CIL Label */ ;
            {
#line 845
            _IO_putc(c, fp);
#line 843
            s ++;
#line 843
            c = (int )*s;
            }
#line 843
            if (! (c != 0)) {
#line 843
              goto while_break___1;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
        }
#line 849
        if ((unsigned long )fp == (unsigned long )code_file) {
#line 850
          outline ++;
        }
        {
#line 851
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %d\n",
                (int )*(symbol_value + i));
        }
      }
    }
#line 827
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 855
  if ((unsigned long )fp == (unsigned long )code_file) {
#line 856
    outline ++;
  }
#line 857
  if ((unsigned long )fp != (unsigned long )defines_file) {
    {
#line 858
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"#define YYERRCODE %d\n",
            (int )*(symbol_value + 1));
    }
  } else
#line 857
  if (iflag) {
    {
#line 858
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"#define YYERRCODE %d\n",
            (int )*(symbol_value + 1));
    }
  }
#line 860
  if ((unsigned long )fp == (unsigned long )defines_file) {
#line 860
    goto _L___0;
  } else
#line 860
  if (iflag) {
#line 860
    if (! dflag) {
      _L___0: /* CIL Label */ 
#line 862
      if (unionized) {
#line 864
        if ((unsigned long )union_file != (unsigned long )((FILE *)0)) {
          {
#line 866
          rewind(union_file);
          }
          {
#line 867
          while (1) {
            while_continue___2: /* CIL Label */ ;
            {
#line 867
            c = _IO_getc(union_file);
            }
#line 867
            if (! (c != -1)) {
#line 867
              goto while_break___2;
            }
            {
#line 868
            _IO_putc(c, fp);
            }
          }
          while_break___2: /* CIL Label */ ;
          }
        }
        {
#line 870
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"extern YYSTYPE %slval;\n",
                symbol_prefix);
        }
      }
    }
  }
#line 873
  return;
}
}
#line 875 "/home/june/collector/temp/byacc-20140101/output.c"
static void output_stored_text(FILE *fp ) 
{ 
  int c ;
  FILE *in ;

  {
  {
#line 881
  rewind(text_file);
  }
#line 882
  if ((unsigned long )text_file == (unsigned long )((void *)0)) {
    {
#line 883
    open_error("text_file");
    }
  }
  {
#line 884
  in = text_file;
#line 885
  c = _IO_getc(in);
  }
#line 885
  if (c == -1) {
#line 886
    return;
  }
  {
#line 887
  putc_code(fp, c);
  }
  {
#line 888
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 888
    c = _IO_getc(in);
    }
#line 888
    if (! (c != -1)) {
#line 888
      goto while_break;
    }
    {
#line 890
    putc_code(fp, c);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 892
  write_code_lineno(fp);
  }
#line 893
  return;
}
}
#line 895 "/home/june/collector/temp/byacc-20140101/output.c"
static void output_debug(void) 
{ 
  int i ;
  int j ;
  int k ;
  int max ;
  char const   **symnam ;
  char const   *s ;
  void *tmp ;
  size_t tmp___0 ;

  {
  {
#line 902
  outline ++;
#line 903
  fprintf((FILE */* __restrict  */)code_file, (char const   */* __restrict  */)"#define YYFINAL %d\n",
          (int )final_state);
#line 905
  putl_code(code_file, "#ifndef YYDEBUG\n");
#line 906
  outline ++;
#line 907
  fprintf((FILE */* __restrict  */)code_file, (char const   */* __restrict  */)"#define YYDEBUG %d\n",
          (int )tflag);
#line 908
  putl_code(code_file, "#endif\n");
  }
#line 910
  if (rflag) {
    {
#line 912
    fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"#ifndef YYDEBUG\n");
#line 913
    fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"#define YYDEBUG %d\n",
            (int )tflag);
#line 914
    fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"#endif\n");
    }
  }
#line 917
  max = 0;
#line 918
  i = 2;
  {
#line 918
  while (1) {
    while_continue: /* CIL Label */ ;
#line 918
    if (! (i < ntokens)) {
#line 918
      goto while_break;
    }
#line 919
    if ((int )*(symbol_value + i) > max) {
#line 920
      max = (int )*(symbol_value + i);
    }
#line 918
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 922
  outline ++;
#line 923
  fprintf((FILE */* __restrict  */)code_file, (char const   */* __restrict  */)"#define YYMAXTOKEN %d\n",
          max);
#line 924
  fprintf((FILE */* __restrict  */)code_file, (char const   */* __restrict  */)"#define YYTRANSLATE(a) ((a) > YYMAXTOKEN ? (YYMAXTOKEN + 1) : (a))\n");
#line 927
  tmp = malloc((size_t )(max + 2) * sizeof(char const   *));
#line 927
  symnam = (char const   **)tmp;
  }
#line 928
  if ((unsigned long )symnam == (unsigned long )((char const   **)0)) {
    {
#line 928
    no_space();
    }
  }
#line 928
  if (! ((unsigned long )symnam != (unsigned long )((char const   **)0))) {
    {
#line 928
    __assert_fail("symnam != 0", "/home/june/collector/temp/byacc-20140101/output.c",
                  928U, "output_debug");
    }
  }
#line 932
  i = 0;
  {
#line 932
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 932
    if (! (i <= max)) {
#line 932
      goto while_break___0;
    }
#line 933
    *(symnam + i) = (char const   *)0;
#line 932
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 934
  i = ntokens - 1;
  {
#line 934
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 934
    if (! (i >= 2)) {
#line 934
      goto while_break___1;
    }
#line 935
    *(symnam + *(symbol_value + i)) = (char const   *)*(symbol_name + i);
#line 934
    i --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 936
  *(symnam + 0) = "end-of-file";
#line 937
  *(symnam + (max + 1)) = "illegal-symbol";
#line 947
  if (token_table) {
    {
#line 949
    output_line("#undef yytname");
#line 950
    output_line("#define yytname yyname");
    }
  } else {
    {
#line 954
    output_line("#if YYDEBUG");
    }
  }
  {
#line 957
  start_str_table("name");
#line 958
  j = 80;
#line 959
  i = 0;
  }
  {
#line 959
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 959
    if (! (i <= max + 1)) {
#line 959
      goto while_break___2;
    }
#line 961
    s = *(symnam + i);
#line 961
    if ((unsigned long )s != (unsigned long )((char const   *)0)) {
#line 963
      if ((int const   )*(s + 0) == 34) {
#line 965
        k = 7;
        {
#line 966
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 966
          s ++;
#line 966
          if (! ((int const   )*s != 34)) {
#line 966
            goto while_break___3;
          }
#line 968
          k ++;
#line 969
          if ((int const   )*s == 92) {
#line 971
            k += 2;
#line 972
            s ++;
#line 972
            if ((int const   )*s == 92) {
#line 973
              k ++;
            }
          }
        }
        while_break___3: /* CIL Label */ ;
        }
#line 976
        j += k;
#line 977
        if (j > 80) {
          {
#line 979
          output_newline();
#line 980
          j = k;
          }
        }
        {
#line 982
        fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"\"\\\"");
#line 983
        s = *(symnam + i);
        }
        {
#line 984
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 984
          s ++;
#line 984
          if (! ((int const   )*s != 34)) {
#line 984
            goto while_break___4;
          }
#line 986
          if ((int const   )*s == 92) {
            {
#line 988
            fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"\\\\");
#line 989
            s ++;
            }
#line 989
            if ((int const   )*s == 92) {
              {
#line 990
              fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"\\\\");
              }
            } else {
              {
#line 992
              _IO_putc((int )*s, output_file);
              }
            }
          } else {
            {
#line 995
            _IO_putc((int )*s, output_file);
            }
          }
        }
        while_break___4: /* CIL Label */ ;
        }
        {
#line 997
        fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"\\\"\",");
        }
      } else
#line 999
      if ((int const   )*(s + 0) == 39) {
#line 1001
        if ((int const   )*(s + 1) == 34) {
#line 1003
          j += 7;
#line 1004
          if (j > 80) {
            {
#line 1006
            output_newline();
#line 1007
            j = 7;
            }
          }
          {
#line 1009
          fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"\"\'\\\"\'\",");
          }
        } else {
#line 1013
          k = 5;
          {
#line 1014
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 1014
            s ++;
#line 1014
            if (! ((int const   )*s != 39)) {
#line 1014
              goto while_break___5;
            }
#line 1016
            k ++;
#line 1017
            if ((int const   )*s == 92) {
#line 1019
              k += 2;
#line 1020
              s ++;
#line 1020
              if ((int const   )*s == 92) {
#line 1021
                k ++;
              }
            }
          }
          while_break___5: /* CIL Label */ ;
          }
#line 1024
          j += k;
#line 1025
          if (j > 80) {
            {
#line 1027
            output_newline();
#line 1028
            j = k;
            }
          }
          {
#line 1030
          fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"\"\'");
#line 1031
          s = *(symnam + i);
          }
          {
#line 1032
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 1032
            s ++;
#line 1032
            if (! ((int const   )*s != 39)) {
#line 1032
              goto while_break___6;
            }
#line 1034
            if ((int const   )*s == 92) {
              {
#line 1036
              fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"\\\\");
#line 1037
              s ++;
              }
#line 1037
              if ((int const   )*s == 92) {
                {
#line 1038
                fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"\\\\");
                }
              } else {
                {
#line 1040
                _IO_putc((int )*s, output_file);
                }
              }
            } else {
              {
#line 1043
              _IO_putc((int )*s, output_file);
              }
            }
          }
          while_break___6: /* CIL Label */ ;
          }
          {
#line 1045
          fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"\'\",");
          }
        }
      } else {
        {
#line 1050
        tmp___0 = strlen(s);
#line 1050
        k = (int )tmp___0 + 3;
#line 1051
        j += k;
        }
#line 1052
        if (j > 80) {
          {
#line 1054
          output_newline();
#line 1055
          j = k;
          }
        }
        {
#line 1057
        _IO_putc('\"', output_file);
        }
        {
#line 1058
        while (1) {
          while_continue___7: /* CIL Label */ ;
          {
#line 1060
          _IO_putc((int )*s, output_file);
#line 1058
          s ++;
          }
#line 1058
          if (! *s) {
#line 1058
            goto while_break___7;
          }
        }
        while_break___7: /* CIL Label */ ;
        }
        {
#line 1063
        fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"\",");
        }
      }
    } else {
#line 1068
      j += 2;
#line 1069
      if (j > 80) {
        {
#line 1071
        output_newline();
#line 1072
        j = 2;
        }
      }
      {
#line 1074
      fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"0,");
      }
    }
#line 959
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 1077
  end_table();
#line 1078
  free((void *)((char *)symnam));
  }
#line 1080
  if (token_table) {
    {
#line 1081
    output_line("#if YYDEBUG");
    }
  }
  {
#line 1082
  start_str_table("rule");
#line 1083
  i = 2;
  }
  {
#line 1083
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 1083
    if (! (i < nrules)) {
#line 1083
      goto while_break___8;
    }
    {
#line 1085
    fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"\"%s :",
            *(symbol_name + *(rlhs + i)));
#line 1086
    j = (int )*(rrhs + i);
    }
    {
#line 1086
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 1086
      if (! ((int )*(ritem + j) > 0)) {
#line 1086
        goto while_break___9;
      }
#line 1088
      s = (char const   *)*(symbol_name + *(ritem + j));
#line 1089
      if ((int const   )*(s + 0) == 34) {
        {
#line 1091
        fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)" \\\"");
        }
        {
#line 1092
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 1092
          s ++;
#line 1092
          if (! ((int const   )*s != 34)) {
#line 1092
            goto while_break___10;
          }
#line 1094
          if ((int const   )*s == 92) {
#line 1096
            if ((int const   )*(s + 1) == 92) {
              {
#line 1097
              fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"\\\\\\\\");
              }
            } else {
              {
#line 1099
              fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"\\\\%c",
                      (int const   )*(s + 1));
              }
            }
#line 1100
            s ++;
          } else {
            {
#line 1103
            _IO_putc((int )*s, output_file);
            }
          }
        }
        while_break___10: /* CIL Label */ ;
        }
        {
#line 1105
        fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"\\\"");
        }
      } else
#line 1107
      if ((int const   )*(s + 0) == 39) {
#line 1109
        if ((int const   )*(s + 1) == 34) {
          {
#line 1110
          fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)" \'\\\"\'");
          }
        } else
#line 1111
        if ((int const   )*(s + 1) == 92) {
#line 1113
          if ((int const   )*(s + 2) == 92) {
            {
#line 1114
            fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)" \'\\\\\\\\");
            }
          } else {
            {
#line 1116
            fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)" \'\\\\%c",
                    (int const   )*(s + 2));
            }
          }
#line 1117
          s += 2;
          {
#line 1118
          while (1) {
            while_continue___11: /* CIL Label */ ;
#line 1118
            s ++;
#line 1118
            if (! ((int const   )*s != 39)) {
#line 1118
              goto while_break___11;
            }
            {
#line 1119
            _IO_putc((int )*s, output_file);
            }
          }
          while_break___11: /* CIL Label */ ;
          }
          {
#line 1120
          _IO_putc('\'', output_file);
          }
        } else {
          {
#line 1123
          fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)" \'%c\'",
                  (int const   )*(s + 1));
          }
        }
      } else {
        {
#line 1126
        fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)" %s",
                s);
        }
      }
#line 1086
      j ++;
    }
    while_break___9: /* CIL Label */ ;
    }
    {
#line 1128
    fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"\",");
#line 1129
    output_newline();
#line 1083
    i ++;
    }
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 1132
  end_table();
#line 1133
  output_line("#endif");
  }
#line 1134
  return;
}
}
#line 1136 "/home/june/collector/temp/byacc-20140101/output.c"
static void output_pure_parser(FILE *fp ) 
{ 


  {
  {
#line 1139
  putc_code(fp, '\n');
  }
#line 1141
  if ((unsigned long )fp == (unsigned long )code_file) {
#line 1142
    outline ++;
  }
  {
#line 1143
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"#define YYPURE %d\n",
          pure_parser);
#line 1144
  putc_code(fp, '\n');
  }
#line 1145
  return;
}
}
#line 1147 "/home/june/collector/temp/byacc-20140101/output.c"
static void output_stype(FILE *fp ) 
{ 


  {
#line 1150
  if (! unionized) {
#line 1150
    if (ntags == 0) {
      {
#line 1152
      putc_code(fp, '\n');
#line 1153
      putl_code(fp, "#ifndef YYSTYPE\n");
#line 1154
      putl_code(fp, "typedef int YYSTYPE;\n");
#line 1155
      putl_code(fp, "#endif\n");
      }
    }
  }
#line 1157
  return;
}
}
#line 1159 "/home/june/collector/temp/byacc-20140101/output.c"
static void output_trailing_text(void) 
{ 
  int c ;
  int last ;
  FILE *in ;

  {
#line 1165
  if ((unsigned long )line == (unsigned long )((char *)0)) {
#line 1166
    return;
  }
#line 1168
  in = input_file;
#line 1169
  c = (int )*cptr;
#line 1170
  if (c == 10) {
    {
#line 1172
    lineno ++;
#line 1173
    c = _IO_getc(in);
    }
#line 1173
    if (c == -1) {
#line 1174
      return;
    }
    {
#line 1175
    write_input_lineno();
#line 1176
    putc_code(code_file, c);
#line 1177
    last = c;
    }
  } else {
    {
#line 1181
    write_input_lineno();
    }
    {
#line 1182
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1184
      putc_code(code_file, c);
#line 1182
      cptr ++;
#line 1182
      c = (int )*cptr;
      }
#line 1182
      if (! (c != 10)) {
#line 1182
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1187
    putc_code(code_file, c);
#line 1188
    last = '\n';
    }
  }
  {
#line 1191
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1191
    c = _IO_getc(in);
    }
#line 1191
    if (! (c != -1)) {
#line 1191
      goto while_break___0;
    }
    {
#line 1193
    putc_code(code_file, c);
#line 1194
    last = c;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1197
  if (last != 10) {
    {
#line 1199
    putc_code(code_file, '\n');
    }
  }
  {
#line 1201
  write_code_lineno(code_file);
  }
#line 1202
  return;
}
}
#line 1204 "/home/june/collector/temp/byacc-20140101/output.c"
static void output_semantic_actions(void) 
{ 
  int c ;
  int last ;

  {
  {
#line 1209
  rewind(action_file);
#line 1210
  c = _IO_getc(action_file);
  }
#line 1210
  if (c == -1) {
#line 1211
    return;
  }
  {
#line 1213
  last = c;
#line 1214
  putc_code(code_file, c);
  }
  {
#line 1215
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1215
    c = _IO_getc(action_file);
    }
#line 1215
    if (! (c != -1)) {
#line 1215
      goto while_break;
    }
    {
#line 1217
    putc_code(code_file, c);
#line 1218
    last = c;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1221
  if (last != 10) {
    {
#line 1223
    putc_code(code_file, '\n');
    }
  }
  {
#line 1226
  write_code_lineno(code_file);
  }
#line 1227
  return;
}
}
#line 1229 "/home/june/collector/temp/byacc-20140101/output.c"
static void output_parse_decl(FILE *fp ) 
{ 
  param *p ;
  char const   *tmp ;

  {
  {
#line 1232
  putl_code(fp, "\n");
#line 1233
  putl_code(fp, "/* compatibility with bison */\n");
#line 1234
  putl_code(fp, "#ifdef YYPARSE_PARAM\n");
#line 1235
  putl_code(fp, "/* compatibility with FreeBSD */\n");
#line 1236
  putl_code(fp, "# ifdef YYPARSE_PARAM_TYPE\n");
#line 1237
  putl_code(fp, "#  define YYPARSE_DECL() yyparse(YYPARSE_PARAM_TYPE YYPARSE_PARAM)\n");
#line 1239
  putl_code(fp, "# else\n");
#line 1240
  putl_code(fp, "#  define YYPARSE_DECL() yyparse(void *YYPARSE_PARAM)\n");
#line 1241
  putl_code(fp, "# endif\n");
#line 1242
  putl_code(fp, "#else\n");
#line 1244
  puts_code(fp, "# define YYPARSE_DECL() yyparse(");
  }
#line 1245
  if (! parse_param) {
    {
#line 1246
    puts_code(fp, "void");
    }
  } else {
#line 1250
    p = parse_param;
    {
#line 1250
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1250
      if (! p) {
#line 1250
        goto while_break;
      }
#line 1251
      if (p->next) {
#line 1251
        tmp = ", ";
      } else {
#line 1251
        tmp = "";
      }
      {
#line 1251
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s %s%s%s",
              p->type, p->name, p->type2, tmp);
#line 1250
      p = p->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 1254
  putl_code(fp, ")\n");
#line 1256
  putl_code(fp, "#endif\n");
  }
#line 1257
  return;
}
}
#line 1259 "/home/june/collector/temp/byacc-20140101/output.c"
static void output_lex_decl(FILE *fp ) 
{ 
  param *p ;
  char const   *tmp ;
  char const   *tmp___0 ;
  param *p___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;

  {
  {
#line 1262
  putl_code(fp, "\n");
#line 1263
  putl_code(fp, "/* Parameters sent to lex. */\n");
#line 1264
  putl_code(fp, "#ifdef YYLEX_PARAM\n");
  }
#line 1265
  if (pure_parser) {
    {
#line 1267
    putl_code(fp, "# ifdef YYLEX_PARAM_TYPE\n");
#line 1268
    putl_code(fp, "#  define YYLEX_DECL() yylex(YYSTYPE *yylval, YYLEX_PARAM_TYPE YYLEX_PARAM)\n");
#line 1270
    putl_code(fp, "# else\n");
#line 1271
    putl_code(fp, "#  define YYLEX_DECL() yylex(YYSTYPE *yylval, void * YYLEX_PARAM)\n");
#line 1273
    putl_code(fp, "# endif\n");
#line 1274
    putl_code(fp, "# define YYLEX yylex(&yylval, YYLEX_PARAM)\n");
    }
  } else {
    {
#line 1278
    putl_code(fp, "# define YYLEX_DECL() yylex(void *YYLEX_PARAM)\n");
#line 1279
    putl_code(fp, "# define YYLEX yylex(YYLEX_PARAM)\n");
    }
  }
  {
#line 1281
  putl_code(fp, "#else\n");
  }
#line 1282
  if (pure_parser) {
#line 1282
    if (lex_param) {
      {
#line 1285
      puts_code(fp, "# define YYLEX_DECL() yylex(YYSTYPE *yylval, ");
#line 1286
      p = lex_param;
      }
      {
#line 1286
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1286
        if (! p) {
#line 1286
          goto while_break;
        }
#line 1287
        if (p->next) {
#line 1287
          tmp = ", ";
        } else {
#line 1287
          tmp = "";
        }
        {
#line 1287
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s %s%s%s",
                p->type, p->name, p->type2, tmp);
#line 1286
        p = p->next;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 1289
      putl_code(fp, ")\n");
#line 1291
      puts_code(fp, "# define YYLEX yylex(&yylval, ");
#line 1292
      p = lex_param;
      }
      {
#line 1292
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1292
        if (! p) {
#line 1292
          goto while_break___0;
        }
#line 1293
        if (p->next) {
#line 1293
          tmp___0 = ", ";
        } else {
#line 1293
          tmp___0 = "";
        }
        {
#line 1293
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s%s",
                p->name, tmp___0);
#line 1292
        p = p->next;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1294
      putl_code(fp, ")\n");
      }
    } else {
#line 1282
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1296
  if (pure_parser) {
    {
#line 1298
    putl_code(fp, "# define YYLEX_DECL() yylex(YYSTYPE *yylval)\n");
#line 1299
    putl_code(fp, "# define YYLEX yylex(&yylval)\n");
    }
  } else
#line 1301
  if (lex_param) {
    {
#line 1304
    puts_code(fp, "# define YYLEX_DECL() yylex(");
#line 1305
    p___0 = lex_param;
    }
    {
#line 1305
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1305
      if (! p___0) {
#line 1305
        goto while_break___1;
      }
#line 1306
      if (p___0->next) {
#line 1306
        tmp___1 = ", ";
      } else {
#line 1306
        tmp___1 = "";
      }
      {
#line 1306
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s %s%s%s",
              p___0->type, p___0->name, p___0->type2, tmp___1);
#line 1305
      p___0 = p___0->next;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1308
    putl_code(fp, ")\n");
#line 1310
    puts_code(fp, "# define YYLEX yylex(");
#line 1311
    p___0 = lex_param;
    }
    {
#line 1311
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1311
      if (! p___0) {
#line 1311
        goto while_break___2;
      }
#line 1312
      if (p___0->next) {
#line 1312
        tmp___2 = ", ";
      } else {
#line 1312
        tmp___2 = "";
      }
      {
#line 1312
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s%s",
              p___0->name, tmp___2);
#line 1311
      p___0 = p___0->next;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 1313
    putl_code(fp, ")\n");
    }
  } else {
    {
#line 1317
    putl_code(fp, "# define YYLEX_DECL() yylex(void)\n");
#line 1318
    putl_code(fp, "# define YYLEX yylex()\n");
    }
  }
  {
#line 1320
  putl_code(fp, "#endif\n");
  }
#line 1321
  return;
}
}
#line 1323 "/home/june/collector/temp/byacc-20140101/output.c"
static void output_error_decl(FILE *fp ) 
{ 
  param *p ;

  {
  {
#line 1326
  putl_code(fp, "\n");
#line 1327
  putl_code(fp, "/* Parameters sent to yyerror. */\n");
  }
#line 1328
  if (parse_param) {
    {
#line 1332
    putl_code(fp, "#ifndef YYERROR_DECL\n");
#line 1333
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"#define YYERROR_DECL() yyerror(");
#line 1334
    p = parse_param;
    }
    {
#line 1334
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1334
      if (! p) {
#line 1334
        goto while_break;
      }
      {
#line 1335
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s %s%s, ",
              p->type, p->name, p->type2);
#line 1334
      p = p->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1336
    putl_code(fp, "const char *s)\n");
#line 1337
    putl_code(fp, "#endif\n");
#line 1339
    putl_code(fp, "#ifndef YYERROR_CALL\n");
#line 1340
    puts_code(fp, "#define YYERROR_CALL(msg) yyerror(");
#line 1342
    p = parse_param;
    }
    {
#line 1342
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1342
      if (! p) {
#line 1342
        goto while_break___0;
      }
      {
#line 1343
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s, ",
              p->name);
#line 1342
      p = p->next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1345
    putl_code(fp, "msg)\n");
#line 1346
    putl_code(fp, "#endif\n");
    }
  } else {
    {
#line 1350
    putl_code(fp, "#ifndef YYERROR_DECL\n");
#line 1351
    putl_code(fp, "#define YYERROR_DECL() yyerror(const char *s)\n");
#line 1352
    putl_code(fp, "#endif\n");
#line 1353
    putl_code(fp, "#ifndef YYERROR_CALL\n");
#line 1354
    putl_code(fp, "#define YYERROR_CALL(msg) yyerror(msg)\n");
#line 1355
    putl_code(fp, "#endif\n");
    }
  }
#line 1357
  return;
}
}
#line 1359 "/home/june/collector/temp/byacc-20140101/output.c"
static void free_itemsets(void) 
{ 
  core *cp ;
  core *next ;

  {
  {
#line 1364
  free((void *)((char *)state_table));
#line 1365
  cp = first_state;
  }
  {
#line 1365
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1365
    if (! cp) {
#line 1365
      goto while_break;
    }
    {
#line 1367
    next = cp->next;
#line 1368
    free((void *)((char *)cp));
#line 1365
    cp = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1370
  return;
}
}
#line 1372 "/home/june/collector/temp/byacc-20140101/output.c"
static void free_shifts(void) 
{ 
  shifts *sp ;
  shifts *next ;

  {
  {
#line 1377
  free((void *)((char *)shift_table));
#line 1378
  sp = first_shift;
  }
  {
#line 1378
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1378
    if (! sp) {
#line 1378
      goto while_break;
    }
    {
#line 1380
    next = sp->next;
#line 1381
    free((void *)((char *)sp));
#line 1378
    sp = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1383
  return;
}
}
#line 1385 "/home/june/collector/temp/byacc-20140101/output.c"
static void free_reductions(void) 
{ 
  reductions *rp ;
  reductions *next ;

  {
  {
#line 1390
  free((void *)((char *)reduction_table));
#line 1391
  rp = first_reduction;
  }
  {
#line 1391
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1391
    if (! rp) {
#line 1391
      goto while_break;
    }
    {
#line 1393
    next = rp->next;
#line 1394
    free((void *)((char *)rp));
#line 1391
    rp = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1396
  return;
}
}
#line 1398 "/home/june/collector/temp/byacc-20140101/output.c"
static void output_yyerror_call(char const   *msg___0 ) 
{ 
  FILE *fp ;
  param *p ;

  {
  {
#line 1401
  fp = code_file;
#line 1403
  puts_code(fp, "    yyerror(");
  }
#line 1404
  if (parse_param) {
#line 1407
    p = parse_param;
    {
#line 1407
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1407
      if (! p) {
#line 1407
        goto while_break;
      }
      {
#line 1408
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s, ",
              p->name);
#line 1407
      p = p->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 1410
  puts_code(fp, "\"");
#line 1411
  puts_code(fp, msg___0);
#line 1412
  putl_code(fp, "\");\n");
  }
#line 1413
  return;
}
}
#line 1415 "/home/june/collector/temp/byacc-20140101/output.c"
static void output_externs(FILE *fp , char const   * const  *section ) 
{ 
  int c ;
  int i ;
  char const   *s ;

  {
#line 1422
  i = 0;
  {
#line 1422
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1422
    s = (char const   *)*(section + i);
#line 1422
    if (! ((unsigned long )s != (unsigned long )((char const   *)0))) {
#line 1422
      goto while_break;
    }
#line 1424
    if (*s) {
#line 1424
      if ((int const   )*s != 35) {
        {
#line 1425
        fputs((char const   */* __restrict  */)"extern\t", (FILE */* __restrict  */)fp);
        }
      }
    }
    {
#line 1426
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1426
      c = (int )*s;
#line 1426
      if (! (c != 0)) {
#line 1426
        goto while_break___0;
      }
      {
#line 1428
      _IO_putc(c, fp);
#line 1429
      s ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1431
    if ((unsigned long )fp == (unsigned long )code_file) {
#line 1432
      outline ++;
    }
    {
#line 1433
    _IO_putc('\n', fp);
#line 1422
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1435
  return;
}
}
#line 1437 "/home/june/collector/temp/byacc-20140101/output.c"
void output(void) 
{ 
  FILE *fp ;
  FILE *tmp ;

  {
  {
#line 1442
  free_itemsets();
#line 1443
  free_shifts();
#line 1444
  free_reductions();
  }
#line 1446
  if (iflag) {
    {
#line 1448
    outline ++;
#line 1449
    fprintf((FILE */* __restrict  */)code_file, (char const   */* __restrict  */)"#include \"%s\"\n",
            externs_file_name);
#line 1450
    fp = externs_file;
    }
  } else {
#line 1453
    fp = code_file;
  }
#line 1455
  if (iflag) {
#line 1455
    tmp = externs_file;
  } else {
#line 1455
    tmp = output_file;
  }
  {
#line 1455
  output_prefix(tmp);
#line 1456
  output_pure_parser(fp);
#line 1457
  output_stored_text(fp);
#line 1458
  output_stype(fp);
#line 1459
  output_parse_decl(fp);
#line 1460
  output_lex_decl(fp);
#line 1461
  output_error_decl(fp);
#line 1462
  write_section(fp, xdecls);
  }
#line 1464
  if (iflag) {
    {
#line 1466
    output_externs(externs_file, global_vars);
    }
#line 1467
    if (! pure_parser) {
      {
#line 1468
      output_externs(externs_file, impure_vars);
      }
    }
  }
#line 1471
  if (iflag) {
#line 1473
    if (dflag) {
      {
#line 1475
      outline ++;
#line 1476
      fprintf((FILE */* __restrict  */)code_file, (char const   */* __restrict  */)"#include \"%s\"\n",
              defines_file_name);
      }
    } else {
      {
#line 1479
      output_defines(externs_file);
      }
    }
  } else {
    {
#line 1483
    putc_code(code_file, '\n');
#line 1484
    output_defines(code_file);
    }
  }
#line 1487
  if (dflag) {
    {
#line 1488
    output_defines(defines_file);
    }
  }
  {
#line 1490
  output_rule_data();
#line 1491
  output_yydefred();
#line 1492
  output_actions();
#line 1493
  free_parser();
#line 1494
  output_debug();
  }
#line 1495
  if (rflag) {
    {
#line 1497
    output_prefix(code_file);
#line 1498
    write_section(code_file, xdecls);
#line 1499
    write_section(code_file, tables);
    }
  }
  {
#line 1501
  write_section(code_file, global_vars);
  }
#line 1502
  if (! pure_parser) {
    {
#line 1504
    write_section(code_file, impure_vars);
    }
  }
  {
#line 1506
  write_section(code_file, hdr_defs);
  }
#line 1507
  if (! pure_parser) {
    {
#line 1509
    write_section(code_file, hdr_vars);
    }
  }
  {
#line 1511
  output_trailing_text();
#line 1512
  write_section(code_file, body_1);
  }
#line 1513
  if (pure_parser) {
    {
#line 1515
    write_section(code_file, body_vars);
    }
  }
  {
#line 1517
  write_section(code_file, body_2);
#line 1518
  output_yyerror_call("syntax error");
#line 1519
  write_section(code_file, body_3);
#line 1520
  output_semantic_actions();
#line 1521
  write_section(code_file, trailer);
#line 1522
  output_yyerror_call("yacc stack overflow");
#line 1523
  write_section(code_file, trailer_2);
  }
#line 1524
  return;
}
}
#line 5 "/home/june/collector/temp/byacc-20140101/lr0.c"
static core *new_state___0(int symbol ) ;
#line 6
static Value_t get_state___0(int symbol ) ;
#line 7
static void allocate_itemsets___0(void) ;
#line 8
static void allocate_storage___0(void) ;
#line 9
static void append_states___0(void) ;
#line 10
static void free_storage___0(void) ;
#line 11
static void generate_states___0(void) ;
#line 12
static void initialize_states___0(void) ;
#line 13
static void new_itemsets___0(void) ;
#line 14
static void save_reductions___0(void) ;
#line 15
static void save_shifts___0(void) ;
#line 16
static void set_derives___0(void) ;
#line 17
static void set_nullable___0(void) ;
#line 24 "/home/june/collector/temp/byacc-20140101/lr0.c"
static core **state_set___0  ;
#line 25 "/home/june/collector/temp/byacc-20140101/lr0.c"
static core *this_state___0  ;
#line 26 "/home/june/collector/temp/byacc-20140101/lr0.c"
static core *last_state___0  ;
#line 27 "/home/june/collector/temp/byacc-20140101/lr0.c"
static shifts *last_shift___0  ;
#line 28 "/home/june/collector/temp/byacc-20140101/lr0.c"
static reductions *last_reduction___0  ;
#line 30 "/home/june/collector/temp/byacc-20140101/lr0.c"
static int nshifts___0  ;
#line 31 "/home/june/collector/temp/byacc-20140101/lr0.c"
static short *shift_symbol___0  ;
#line 33 "/home/june/collector/temp/byacc-20140101/lr0.c"
static Value_t *redset___0  ;
#line 34 "/home/june/collector/temp/byacc-20140101/lr0.c"
static Value_t *shiftset___0  ;
#line 36 "/home/june/collector/temp/byacc-20140101/lr0.c"
static Value_t **kernel_base___0  ;
#line 37 "/home/june/collector/temp/byacc-20140101/lr0.c"
static Value_t **kernel_end___0  ;
#line 38 "/home/june/collector/temp/byacc-20140101/lr0.c"
static Value_t *kernel_items___0  ;
#line 40 "/home/june/collector/temp/byacc-20140101/lr0.c"
static void allocate_itemsets___0(void) 
{ 
  short *itemp ;
  short *item_end ;
  int symbol ;
  int i ;
  int count ;
  int max ;
  short *symbol_count ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 51
  count = 0;
#line 52
  tmp = allocate((size_t )nsyms * sizeof(short ));
#line 52
  symbol_count = (short *)tmp;
#line 54
  item_end = ritem + nitems;
#line 55
  itemp = ritem;
  }
  {
#line 55
  while (1) {
    while_continue: /* CIL Label */ ;
#line 55
    if (! ((unsigned long )itemp < (unsigned long )item_end)) {
#line 55
      goto while_break;
    }
#line 57
    symbol = (int )*itemp;
#line 58
    if (symbol >= 0) {
#line 60
      count ++;
#line 61
      *(symbol_count + symbol) = (short )((int )*(symbol_count + symbol) + 1);
    }
#line 55
    itemp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 65
  tmp___0 = allocate((size_t )nsyms * sizeof(short *));
#line 65
  kernel_base___0 = (short **)tmp___0;
#line 66
  tmp___1 = allocate((size_t )count * sizeof(short ));
#line 66
  kernel_items___0 = (short *)tmp___1;
#line 68
  count = 0;
#line 69
  max = 0;
#line 70
  i = 0;
  }
  {
#line 70
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 70
    if (! (i < nsyms)) {
#line 70
      goto while_break___0;
    }
#line 72
    *(kernel_base___0 + i) = kernel_items___0 + count;
#line 73
    count += (int )*(symbol_count + i);
#line 74
    if (max < (int )*(symbol_count + i)) {
#line 75
      max = (int )*(symbol_count + i);
    }
#line 70
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 78
  shift_symbol___0 = symbol_count;
#line 79
  tmp___2 = allocate((size_t )nsyms * sizeof(short *));
#line 79
  kernel_end___0 = (short **)tmp___2;
  }
#line 80
  return;
}
}
#line 82 "/home/june/collector/temp/byacc-20140101/lr0.c"
static void allocate_storage___0(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 85
  allocate_itemsets___0();
#line 86
  tmp = allocate((size_t )nsyms * sizeof(short ));
#line 86
  shiftset___0 = (short *)tmp;
#line 87
  tmp___0 = allocate((size_t )(nrules + 1) * sizeof(short ));
#line 87
  redset___0 = (short *)tmp___0;
#line 88
  tmp___1 = allocate((size_t )nitems * sizeof(core *));
#line 88
  state_set___0 = (core **)tmp___1;
  }
#line 89
  return;
}
}
#line 91 "/home/june/collector/temp/byacc-20140101/lr0.c"
static void append_states___0(void) 
{ 
  int i ;
  int j ;
  Value_t symbol ;

  {
#line 101
  i = 1;
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;
#line 101
    if (! (i < nshifts___0)) {
#line 101
      goto while_break;
    }
#line 103
    symbol = *(shift_symbol___0 + i);
#line 104
    j = i;
    {
#line 105
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 105
      if (j > 0) {
#line 105
        if (! ((int )*(shift_symbol___0 + (j - 1)) > (int )symbol)) {
#line 105
          goto while_break___0;
        }
      } else {
#line 105
        goto while_break___0;
      }
#line 107
      *(shift_symbol___0 + j) = *(shift_symbol___0 + (j - 1));
#line 108
      j --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 110
    *(shift_symbol___0 + j) = symbol;
#line 101
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 113
  i = 0;
  {
#line 113
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 113
    if (! (i < nshifts___0)) {
#line 113
      goto while_break___1;
    }
    {
#line 115
    symbol = *(shift_symbol___0 + i);
#line 116
    *(shiftset___0 + i) = get_state___0((int )symbol);
#line 113
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 118
  return;
}
}
#line 120 "/home/june/collector/temp/byacc-20140101/lr0.c"
static void free_storage___0(void) 
{ 


  {
  {
#line 123
  free((void *)((char *)shift_symbol___0));
#line 124
  free((void *)((char *)redset___0));
#line 125
  free((void *)((char *)shiftset___0));
#line 126
  free((void *)((char *)kernel_base___0));
#line 127
  free((void *)((char *)kernel_end___0));
#line 128
  free((void *)((char *)kernel_items___0));
#line 129
  free((void *)((char *)state_set___0));
  }
#line 130
  return;
}
}
#line 132 "/home/june/collector/temp/byacc-20140101/lr0.c"
static void generate_states___0(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 135
  allocate_storage___0();
#line 136
  tmp = allocate((size_t )nitems * sizeof(short ));
#line 136
  itemset = (short *)tmp;
#line 137
  tmp___0 = allocate((size_t )((nrules + 31) / 32) * sizeof(unsigned int ));
#line 137
  ruleset = (unsigned int *)tmp___0;
#line 138
  set_first_derives();
#line 139
  initialize_states___0();
  }
  {
#line 141
  while (1) {
    while_continue: /* CIL Label */ ;
#line 141
    if (! this_state___0) {
#line 141
      goto while_break;
    }
    {
#line 143
    closure(this_state___0->items, (int )this_state___0->nitems);
#line 144
    save_reductions___0();
#line 145
    new_itemsets___0();
#line 146
    append_states___0();
    }
#line 148
    if (nshifts___0 > 0) {
      {
#line 149
      save_shifts___0();
      }
    }
#line 151
    this_state___0 = this_state___0->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 154
  free_storage___0();
  }
#line 155
  return;
}
}
#line 157 "/home/june/collector/temp/byacc-20140101/lr0.c"
static Value_t get_state___0(int symbol ) 
{ 
  int key ;
  short *isp1 ;
  short *isp2 ;
  short *iend ;
  core *sp ;
  int found ;
  int n ;
  short *tmp ;
  short *tmp___0 ;
  struct core *tmp___1 ;

  {
#line 172
  isp1 = *(kernel_base___0 + symbol);
#line 173
  iend = *(kernel_end___0 + symbol);
#line 174
  n = (int )(iend - isp1);
#line 176
  key = (int )*isp1;
#line 177
  if (0 <= key) {
#line 177
    if (! (key < nitems)) {
      {
#line 177
      __assert_fail("0 <= key && key < nitems", "/home/june/collector/temp/byacc-20140101/lr0.c",
                    177U, "get_state");
      }
    }
  } else {
    {
#line 177
    __assert_fail("0 <= key && key < nitems", "/home/june/collector/temp/byacc-20140101/lr0.c",
                  177U, "get_state");
    }
  }
#line 178
  sp = *(state_set___0 + key);
#line 179
  if (sp) {
#line 181
    found = 0;
    {
#line 182
    while (1) {
      while_continue: /* CIL Label */ ;
#line 182
      if (! (! found)) {
#line 182
        goto while_break;
      }
#line 184
      if ((int )sp->nitems == n) {
#line 186
        found = 1;
#line 187
        isp1 = *(kernel_base___0 + symbol);
#line 188
        isp2 = sp->items;
        {
#line 190
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 190
          if (found) {
#line 190
            if (! ((unsigned long )isp1 < (unsigned long )iend)) {
#line 190
              goto while_break___0;
            }
          } else {
#line 190
            goto while_break___0;
          }
#line 192
          tmp = isp1;
#line 192
          isp1 ++;
#line 192
          tmp___0 = isp2;
#line 192
          isp2 ++;
#line 192
          if ((int )*tmp != (int )*tmp___0) {
#line 193
            found = 0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 197
      if (! found) {
#line 199
        if (sp->link) {
#line 201
          sp = sp->link;
        } else {
          {
#line 205
          tmp___1 = new_state___0(symbol);
#line 205
          sp->link = tmp___1;
#line 205
          sp = tmp___1;
#line 206
          found = 1;
          }
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 213
    sp = new_state___0(symbol);
#line 213
    *(state_set___0 + key) = sp;
    }
  }
#line 216
  return (sp->number);
}
}
#line 219 "/home/june/collector/temp/byacc-20140101/lr0.c"
static void initialize_states___0(void) 
{ 
  unsigned int i ;
  short *start_derives ;
  core *p ;
  void *tmp ;

  {
#line 226
  start_derives = *(derives + start_symbol);
#line 227
  i = 0U;
  {
#line 227
  while (1) {
    while_continue: /* CIL Label */ ;
#line 227
    if (! ((int )*(start_derives + i) >= 0)) {
#line 227
      goto while_break;
    }
#line 228
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 227
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 230
  tmp = malloc(sizeof(core ) + (unsigned long )i * sizeof(short ));
#line 230
  p = (core *)tmp;
  }
#line 231
  if ((unsigned long )p == (unsigned long )((core *)0)) {
    {
#line 231
    no_space();
    }
  }
#line 231
  if (! ((unsigned long )p != (unsigned long )((core *)0))) {
    {
#line 231
    __assert_fail("p != 0", "/home/june/collector/temp/byacc-20140101/lr0.c", 231U,
                  "initialize_states");
    }
  }
#line 233
  p->next = (struct core *)0;
#line 234
  p->link = (struct core *)0;
#line 235
  p->number = (Value_t )0;
#line 236
  p->accessing_symbol = (Value_t )0;
#line 237
  p->nitems = (Value_t )i;
#line 239
  i = 0U;
  {
#line 239
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 239
    if (! ((int )*(start_derives + i) >= 0)) {
#line 239
      goto while_break___0;
    }
#line 240
    p->items[i] = *(rrhs + *(start_derives + i));
#line 239
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 242
  this_state___0 = p;
#line 242
  last_state___0 = this_state___0;
#line 242
  first_state = last_state___0;
#line 243
  nstates = 1;
#line 244
  return;
}
}
#line 246 "/home/june/collector/temp/byacc-20140101/lr0.c"
static void new_itemsets___0(void) 
{ 
  Value_t i ;
  int shiftcount ;
  short *isp ;
  short *ksp ;
  Value_t symbol ;
  short *tmp ;
  int tmp___0 ;
  short *tmp___1 ;

  {
#line 255
  i = (Value_t )0;
  {
#line 255
  while (1) {
    while_continue: /* CIL Label */ ;
#line 255
    if (! ((int )i < nsyms)) {
#line 255
      goto while_break;
    }
#line 256
    *(kernel_end___0 + i) = (Value_t *)0;
#line 255
    i = (Value_t )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 258
  shiftcount = 0;
#line 259
  isp = itemset;
  {
#line 260
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 260
    if (! ((unsigned long )isp < (unsigned long )itemsetend)) {
#line 260
      goto while_break___0;
    }
#line 262
    tmp = isp;
#line 262
    isp ++;
#line 262
    i = *tmp;
#line 263
    symbol = *(ritem + i);
#line 264
    if ((int )symbol > 0) {
#line 266
      ksp = *(kernel_end___0 + symbol);
#line 267
      if (! ksp) {
#line 269
        tmp___0 = shiftcount;
#line 269
        shiftcount ++;
#line 269
        *(shift_symbol___0 + tmp___0) = symbol;
#line 270
        ksp = *(kernel_base___0 + symbol);
      }
#line 273
      tmp___1 = ksp;
#line 273
      ksp ++;
#line 273
      *tmp___1 = (Value_t )((int )i + 1);
#line 274
      *(kernel_end___0 + symbol) = ksp;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 278
  nshifts___0 = shiftcount;
#line 279
  return;
}
}
#line 281 "/home/june/collector/temp/byacc-20140101/lr0.c"
static core *new_state___0(int symbol ) 
{ 
  unsigned int n ;
  core *p ;
  short *isp1 ;
  short *isp2 ;
  short *iend ;
  void *tmp ;
  short *tmp___0 ;
  short *tmp___1 ;

  {
#line 294
  if (nstates >= 32767) {
    {
#line 295
    fatal("too many states");
    }
  }
  {
#line 297
  isp1 = *(kernel_base___0 + symbol);
#line 298
  iend = *(kernel_end___0 + symbol);
#line 299
  n = (unsigned int )(iend - isp1);
#line 301
  tmp = allocate(sizeof(core ) + (unsigned long )(n - 1U) * sizeof(short ));
#line 301
  p = (core *)tmp;
#line 302
  p->accessing_symbol = (Value_t )symbol;
#line 303
  p->number = (Value_t )nstates;
#line 304
  p->nitems = (Value_t )n;
#line 306
  isp2 = p->items;
  }
  {
#line 307
  while (1) {
    while_continue: /* CIL Label */ ;
#line 307
    if (! ((unsigned long )isp1 < (unsigned long )iend)) {
#line 307
      goto while_break;
    }
#line 308
    tmp___0 = isp2;
#line 308
    isp2 ++;
#line 308
    tmp___1 = isp1;
#line 308
    isp1 ++;
#line 308
    *tmp___0 = *tmp___1;
  }
  while_break: /* CIL Label */ ;
  }
#line 310
  last_state___0->next = p;
#line 311
  last_state___0 = p;
#line 313
  nstates ++;
#line 315
  return (p);
}
}
#line 397 "/home/june/collector/temp/byacc-20140101/lr0.c"
static void save_shifts___0(void) 
{ 
  shifts *p ;
  short *sp1 ;
  short *sp2 ;
  short *send ;
  void *tmp ;
  short *tmp___0 ;
  short *tmp___1 ;

  {
  {
#line 405
  tmp = allocate(sizeof(shifts ) + (unsigned long )((unsigned int )(nshifts___0 - 1)) * sizeof(short ));
#line 405
  p = (shifts *)tmp;
#line 408
  p->number = this_state___0->number;
#line 409
  p->nshifts = (Value_t )nshifts___0;
#line 411
  sp1 = shiftset___0;
#line 412
  sp2 = p->shift;
#line 413
  send = shiftset___0 + nshifts___0;
  }
  {
#line 415
  while (1) {
    while_continue: /* CIL Label */ ;
#line 415
    if (! ((unsigned long )sp1 < (unsigned long )send)) {
#line 415
      goto while_break;
    }
#line 416
    tmp___0 = sp2;
#line 416
    sp2 ++;
#line 416
    tmp___1 = sp1;
#line 416
    sp1 ++;
#line 416
    *tmp___0 = *tmp___1;
  }
  while_break: /* CIL Label */ ;
  }
#line 418
  if (last_shift___0) {
#line 420
    last_shift___0->next = p;
#line 421
    last_shift___0 = p;
  } else {
#line 425
    first_shift = p;
#line 426
    last_shift___0 = p;
  }
#line 428
  return;
}
}
#line 430 "/home/june/collector/temp/byacc-20140101/lr0.c"
static void save_reductions___0(void) 
{ 
  short *isp ;
  short *rp1 ;
  short *rp2 ;
  int item ;
  Value_t count ;
  reductions *p ;
  short *rend ;
  Value_t tmp ;
  void *tmp___0 ;
  short *tmp___1 ;
  short *tmp___2 ;

  {
#line 441
  count = (Value_t )0;
#line 442
  isp = itemset;
  {
#line 442
  while (1) {
    while_continue: /* CIL Label */ ;
#line 442
    if (! ((unsigned long )isp < (unsigned long )itemsetend)) {
#line 442
      goto while_break;
    }
#line 444
    item = (int )*(ritem + *isp);
#line 445
    if (item < 0) {
#line 447
      tmp = count;
#line 447
      count = (Value_t )((int )count + 1);
#line 447
      *(redset___0 + tmp) = (Value_t )(- item);
    }
#line 442
    isp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 451
  if (count) {
    {
#line 453
    tmp___0 = allocate(sizeof(reductions ) + (unsigned long )((unsigned int )((int )count - 1)) * sizeof(short ));
#line 453
    p = (reductions *)tmp___0;
#line 457
    p->number = this_state___0->number;
#line 458
    p->nreds = count;
#line 460
    rp1 = redset___0;
#line 461
    rp2 = p->rules;
#line 462
    rend = rp1 + (int )count;
    }
    {
#line 464
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 464
      if (! ((unsigned long )rp1 < (unsigned long )rend)) {
#line 464
        goto while_break___0;
      }
#line 465
      tmp___1 = rp2;
#line 465
      rp2 ++;
#line 465
      tmp___2 = rp1;
#line 465
      rp1 ++;
#line 465
      *tmp___1 = *tmp___2;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 467
    if (last_reduction___0) {
#line 469
      last_reduction___0->next = p;
#line 470
      last_reduction___0 = p;
    } else {
#line 474
      first_reduction = p;
#line 475
      last_reduction___0 = p;
    }
  }
#line 478
  return;
}
}
#line 480 "/home/june/collector/temp/byacc-20140101/lr0.c"
static void set_derives___0(void) 
{ 
  Value_t i ;
  Value_t k ;
  int lhs ;
  short *rules ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 487
  tmp = allocate((size_t )nsyms * sizeof(short *));
#line 487
  derives = (short **)tmp;
#line 488
  tmp___0 = allocate((size_t )(nvars + nrules) * sizeof(short ));
#line 488
  rules = (short *)tmp___0;
#line 490
  k = (Value_t )0;
#line 491
  lhs = (int )start_symbol;
  }
  {
#line 491
  while (1) {
    while_continue: /* CIL Label */ ;
#line 491
    if (! (lhs < nsyms)) {
#line 491
      goto while_break;
    }
#line 493
    *(derives + lhs) = rules + (int )k;
#line 494
    i = (Value_t )0;
    {
#line 494
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 494
      if (! ((int )i < nrules)) {
#line 494
        goto while_break___0;
      }
#line 496
      if ((int )*(rlhs + i) == lhs) {
#line 498
        *(rules + k) = i;
#line 499
        k = (Value_t )((int )k + 1);
      }
#line 494
      i = (Value_t )((int )i + 1);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 502
    *(rules + k) = (short)-1;
#line 503
    k = (Value_t )((int )k + 1);
#line 491
    lhs ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 509
  return;
}
}
#line 534 "/home/june/collector/temp/byacc-20140101/lr0.c"
static void set_nullable___0(void) 
{ 
  int i ;
  int j ;
  int empty ;
  int done_flag ;
  void *tmp ;

  {
  {
#line 541
  tmp = malloc((size_t )nsyms * sizeof(char ));
#line 541
  nullable = (char *)tmp;
  }
#line 542
  if ((unsigned long )nullable == (unsigned long )((char *)0)) {
    {
#line 542
    no_space();
    }
  }
#line 542
  if (! ((unsigned long )nullable != (unsigned long )((char *)0))) {
    {
#line 542
    __assert_fail("nullable != 0", "/home/june/collector/temp/byacc-20140101/lr0.c",
                  542U, "set_nullable");
    }
  }
#line 544
  i = 0;
  {
#line 544
  while (1) {
    while_continue: /* CIL Label */ ;
#line 544
    if (! (i < nsyms)) {
#line 544
      goto while_break;
    }
#line 545
    *(nullable + i) = (char)0;
#line 544
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 547
  done_flag = 0;
  {
#line 548
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 548
    if (! (! done_flag)) {
#line 548
      goto while_break___0;
    }
#line 550
    done_flag = 1;
#line 551
    i = 1;
    {
#line 551
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 551
      if (! (i < nitems)) {
#line 551
        goto while_break___1;
      }
#line 553
      empty = 1;
      {
#line 554
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 554
        j = (int )*(ritem + i);
#line 554
        if (! (j >= 0)) {
#line 554
          goto while_break___2;
        }
#line 556
        if (! *(nullable + j)) {
#line 557
          empty = 0;
        }
#line 558
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 560
      if (empty) {
#line 562
        j = (int )*(rlhs + - j);
#line 563
        if (! *(nullable + j)) {
#line 565
          *(nullable + j) = (char)1;
#line 566
          done_flag = 0;
        }
      }
#line 551
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 581
  return;
}
}
