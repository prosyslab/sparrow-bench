/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 39 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/include/lru_cache.h"
struct lru_cache_element;
#line 40 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/include/lru_cache.h"
typedef struct lru_cache_element lru_cache_element;
#line 42 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/include/lru_cache.h"
struct lru_cache_element {
   void *index ;
   uint32_t index_len ;
   void *data ;
   lru_cache_element *next ;
   lru_cache_element *older ;
   lru_cache_element *newer ;
};
#line 54 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/include/lru_cache.h"
struct _lru_cache {
   uint32_t secret ;
   uint32_t num_keys ;
   uint32_t num_buckets ;
   uint32_t max_keys ;
   lru_cache_element *oldest ;
   lru_cache_element *newest ;
   lru_cache_element **table ;
   _Bool talloc_data ;
};
#line 54 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/include/lru_cache.h"
typedef struct _lru_cache lru_cache;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 196 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef int int32_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 29 "/usr/include/iconv.h"
typedef void *iconv_t;
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 55 "/usr/include/stdint.h"
typedef unsigned long uint64_t;
#line 77 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/include/winsec.h"
struct _winsec_uuid {
   uint32_t time_low ;
   uint16_t time_mid ;
   uint16_t time_hi_and_version ;
   uint8_t clock_seq[2] ;
   uint8_t node[6] ;
};
#line 77 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/include/winsec.h"
typedef struct _winsec_uuid WINSEC_UUID;
#line 97 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/include/winsec.h"
struct _winsec_sid {
   uint8_t sid_rev_num ;
   uint8_t num_auths ;
   uint8_t id_auth[6] ;
   uint32_t sub_auths[15] ;
};
#line 97 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/include/winsec.h"
typedef struct _winsec_sid WINSEC_DOM_SID;
#line 118 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/include/winsec.h"
struct _winsec_ace {
   uint8_t type ;
   uint8_t flags ;
   uint16_t size ;
   uint32_t access_mask ;
   uint32_t obj_flags ;
   WINSEC_UUID *obj_guid ;
   WINSEC_UUID *inh_guid ;
   WINSEC_DOM_SID *trustee ;
};
#line 118 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/include/winsec.h"
typedef struct _winsec_ace WINSEC_ACE;
#line 152 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/include/winsec.h"
struct _winsec_acl {
   uint16_t revision ;
   uint16_t size ;
   uint32_t num_aces ;
   WINSEC_ACE **aces ;
};
#line 152 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/include/winsec.h"
typedef struct _winsec_acl WINSEC_ACL;
#line 170 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/include/winsec.h"
struct _winsec_desc {
   uint8_t revision ;
   uint8_t sbz1 ;
   uint16_t control ;
   uint32_t off_owner_sid ;
   uint32_t off_grp_sid ;
   uint32_t off_sacl ;
   uint32_t off_dacl ;
   WINSEC_DOM_SID *owner_sid ;
   WINSEC_DOM_SID *grp_sid ;
   WINSEC_ACL *sacl ;
   WINSEC_ACL *dacl ;
};
#line 170 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/include/winsec.h"
typedef struct _winsec_desc WINSEC_DESC;
#line 37 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/include/void_stack.h"
struct _void_stack {
   void **elements ;
   unsigned short max_size ;
   unsigned short top ;
};
#line 37 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/include/void_stack.h"
typedef struct _void_stack void_stack;
#line 40 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/include/range_list.h"
struct _range_list_element {
   uint32_t offset ;
   uint32_t length ;
   void *data ;
};
#line 40 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/include/range_list.h"
typedef struct _range_list_element range_list_element;
#line 49 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/include/range_list.h"
struct _range_list {
   range_list_element **elements ;
   uint32_t elem_alloced ;
   uint32_t size ;
};
#line 49 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/include/range_list.h"
typedef struct _range_list range_list;
#line 86 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/include/regfi.h"
typedef uint8_t REGFI_ENCODING;
#line 242 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/include/regfi.h"
struct _regfi_nttime {
   uint32_t low ;
   uint32_t high ;
};
#line 242 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/include/regfi.h"
typedef struct _regfi_nttime REGFI_NTTIME;
#line 252 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/include/regfi.h"
struct _regfi_hbin {
   uint32_t file_off ;
   uint32_t ref_count ;
   uint32_t first_hbin_off ;
   uint32_t block_size ;
   uint32_t next_block ;
   uint8_t magic[4] ;
};
#line 252 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/include/regfi.h"
typedef struct _regfi_hbin REGFI_HBIN;
#line 278 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/include/regfi.h"
struct __anonstruct_REGFI_SUBKEY_LIST_ELEM_30 {
   uint32_t offset ;
   uint32_t hash ;
};
#line 278 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/include/regfi.h"
typedef struct __anonstruct_REGFI_SUBKEY_LIST_ELEM_30 REGFI_SUBKEY_LIST_ELEM;
#line 292 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/include/regfi.h"
struct _regfi_subkey_list {
   uint32_t offset ;
   uint32_t cell_size ;
   uint32_t num_children ;
   uint32_t num_keys ;
   REGFI_SUBKEY_LIST_ELEM *elements ;
   uint8_t magic[2] ;
   _Bool recursive_type ;
};
#line 292 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/include/regfi.h"
typedef struct _regfi_subkey_list REGFI_SUBKEY_LIST;
#line 313 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/include/regfi.h"
typedef uint32_t REGFI_VALUE_LIST_ELEM;
#line 317 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/include/regfi.h"
struct _regfi_value_list {
   uint32_t num_values ;
   REGFI_VALUE_LIST_ELEM *elements ;
};
#line 317 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/include/regfi.h"
typedef struct _regfi_value_list REGFI_VALUE_LIST;
#line 331 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/include/regfi.h"
struct _regfi_classname {
   char *interpreted ;
   uint8_t *raw ;
   uint16_t size ;
};
#line 331 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/include/regfi.h"
typedef struct _regfi_classname REGFI_CLASSNAME;
#line 353 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/include/regfi.h"
union _regfi_data_interpreted {
   uint8_t *none ;
   uint8_t *string ;
   uint8_t *expand_string ;
   uint8_t *binary ;
   uint32_t dword ;
   uint32_t dword_be ;
   uint8_t *link ;
   uint8_t **multiple_string ;
   uint64_t qword ;
   uint8_t *resource_list ;
   uint8_t *full_resource_descriptor ;
   uint8_t *resource_requirements_list ;
};
#line 353 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/include/regfi.h"
struct _regfi_data {
   uint32_t type ;
   uint32_t size ;
   uint8_t *raw ;
   uint32_t interpreted_size ;
   union _regfi_data_interpreted interpreted ;
};
#line 353 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/include/regfi.h"
typedef struct _regfi_data REGFI_DATA;
#line 457 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/include/regfi.h"
struct __anonstruct_REGFI_VK_REC_31 {
   uint32_t offset ;
   uint32_t cell_size ;
   REGFI_DATA *data ;
   char *valuename ;
   uint8_t *valuename_raw ;
   uint16_t name_length ;
   uint32_t hbin_off ;
   uint32_t data_size ;
   uint32_t data_off ;
   uint32_t type ;
   uint8_t magic[2] ;
   uint16_t flags ;
   uint16_t unknown1 ;
   _Bool data_in_offset ;
};
#line 457 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/include/regfi.h"
typedef struct __anonstruct_REGFI_VK_REC_31 REGFI_VK_REC;
#line 517
struct _regfi_sk_rec;
#line 522 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/include/regfi.h"
struct _regfi_sk_rec {
   uint32_t offset ;
   uint32_t cell_size ;
   WINSEC_DESC *sec_desc ;
   uint32_t hbin_off ;
   uint32_t prev_sk_off ;
   uint32_t next_sk_off ;
   uint32_t ref_count ;
   uint32_t desc_size ;
   uint16_t unknown_tag ;
   uint8_t magic[2] ;
};
#line 522 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/include/regfi.h"
typedef struct _regfi_sk_rec REGFI_SK_REC;
#line 559 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/include/regfi.h"
struct __anonstruct_REGFI_NK_REC_32 {
   uint32_t offset ;
   uint32_t cell_size ;
   REGFI_VALUE_LIST *values ;
   REGFI_SUBKEY_LIST *subkeys ;
   uint16_t flags ;
   uint8_t magic[2] ;
   REGFI_NTTIME mtime ;
   uint16_t name_length ;
   uint16_t classname_length ;
   char *keyname ;
   uint8_t *keyname_raw ;
   uint32_t parent_off ;
   uint32_t classname_off ;
   uint32_t max_bytes_subkeyname ;
   uint32_t max_bytes_subkeyclassname ;
   uint32_t max_bytes_valuename ;
   uint32_t max_bytes_value ;
   uint32_t unknown1 ;
   uint32_t unknown2 ;
   uint32_t unknown3 ;
   uint32_t unk_index ;
   uint32_t num_subkeys ;
   uint32_t subkeys_off ;
   uint32_t num_values ;
   uint32_t values_off ;
   uint32_t sk_off ;
};
#line 559 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/include/regfi.h"
typedef struct __anonstruct_REGFI_NK_REC_32 REGFI_NK_REC;
#line 667 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/include/regfi.h"
struct __anonstruct_REGFI_FILE_33 {
   int fd ;
   uint32_t file_length ;
   range_list *hbins ;
   lru_cache *sk_cache ;
   char *last_message ;
   uint16_t msg_mask ;
   uint8_t magic[4] ;
   uint32_t sequence1 ;
   uint32_t sequence2 ;
   REGFI_NTTIME mtime ;
   uint32_t major_version ;
   uint32_t minor_version ;
   uint32_t type ;
   uint32_t format ;
   uint32_t root_cell ;
   uint32_t last_block ;
   uint32_t cluster ;
   uint8_t file_name[64] ;
   WINSEC_UUID *rm_id ;
   WINSEC_UUID *log_id ;
   WINSEC_UUID *tm_id ;
   uint32_t flags ;
   uint32_t guid_signature ;
   uint32_t checksum ;
   uint32_t computed_checksum ;
   WINSEC_UUID *thaw_tm_id ;
   WINSEC_UUID *thaw_rm_id ;
   WINSEC_UUID *thaw_log_id ;
   uint32_t boot_type ;
   uint32_t boot_recover ;
   uint8_t reserved1[340] ;
   uint8_t reserved2[3528] ;
};
#line 667 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/include/regfi.h"
typedef struct __anonstruct_REGFI_FILE_33 REGFI_FILE;
#line 746 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/include/regfi.h"
struct _regfi_iterator {
   REGFI_FILE *f ;
   void_stack *key_positions ;
   REGFI_NK_REC *cur_key ;
   REGFI_ENCODING string_encoding ;
   uint32_t cur_subkey ;
   uint32_t cur_value ;
};
#line 746 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/include/regfi.h"
typedef struct _regfi_iterator REGFI_ITERATOR;
#line 770 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/include/regfi.h"
struct _regfi_iter_position {
   REGFI_NK_REC *nk ;
   uint32_t cur_subkey ;
};
#line 770 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/include/regfi.h"
typedef struct _regfi_iter_position REGFI_ITER_POSITION;
#line 783 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/include/regfi.h"
struct _regfi_buffer {
   uint8_t *buf ;
   uint32_t len ;
};
#line 783 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/include/regfi.h"
typedef struct _regfi_buffer REGFI_BUFFER;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 46 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/include/void_stack.h"
struct _void_stack_iterator {
   void_stack const   *stack ;
   unsigned short cur ;
};
#line 46 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/include/void_stack.h"
typedef struct _void_stack_iterator void_stack_iterator;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 78 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
struct talloc_reference_handle {
   struct talloc_reference_handle *next ;
   struct talloc_reference_handle *prev ;
   void *ptr ;
};
#line 85 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
struct talloc_chunk {
   struct talloc_chunk *next ;
   struct talloc_chunk *prev ;
   struct talloc_chunk *parent ;
   struct talloc_chunk *child ;
   struct talloc_reference_handle *refs ;
   int (*destructor)(void * ) ;
   char const   *name ;
   size_t size ;
   unsigned int flags ;
   void *pool ;
};
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 115 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/include/talloc.h"
void *talloc_named_const(void const   *context , size_t size , char const   *name ) ;
#line 121
int talloc_free(void *ptr ) ;
#line 123
void *_talloc_realloc(void const   *context , void *ptr , size_t size , char const   *name ) ;
#line 124
void *_talloc_steal(void const   *new_ctx , void const   *ptr ) ;
#line 143
void *_talloc_array(void const   *ctx , size_t el_size , unsigned int count , char const   *name ) ;
#line 70 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/include/lru_cache.h"
lru_cache *lru_cache_create(uint32_t max_keys , uint32_t secret ) ;
#line 76
lru_cache *lru_cache_create_ctx(void *talloc_ctx , uint32_t max_keys , uint32_t secret ,
                                _Bool talloc_data ) ;
#line 83
void lru_cache_destroy(lru_cache *ht ) ;
#line 89
_Bool lru_cache_update(lru_cache *ht , void const   *index___0 , uint32_t index_len ,
                       void *data ) ;
#line 98
void *lru_cache_find(lru_cache *ht , void const   *index___0 , uint32_t index_len ) ;
#line 109
_Bool lru_cache_remove(lru_cache *ht , void const   *index___0 , uint32_t index_len ) ;
#line 32 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/lru_cache.c"
static uint32_t lru_cache_compute_hash(uint32_t num_buckets , uint32_t secret , void const   *buf ,
                                       uint32_t buf_len ) 
{ 
  uint32_t i ;
  uint32_t ret_val ;
  unsigned char *s ;
  unsigned char const   *b ;

  {
#line 38
  ret_val = (uint32_t )608135816;
#line 39
  s = (unsigned char *)(& secret);
#line 40
  b = (unsigned char const   *)((unsigned char *)buf);
#line 42
  i = (uint32_t )0;
  {
#line 42
  while (1) {
    while_continue: /* CIL Label */ ;
#line 42
    if (! (i < buf_len)) {
#line 42
      goto while_break;
    }
#line 43
    ret_val = (ret_val + (i ^ (unsigned int )*(s + i % 4U)) * (unsigned int )*(b + i)) % num_buckets;
#line 42
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 45
  return (ret_val);
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/lru_cache.c"
static uint32_t lru_cache_floor_log2(uint32_t n ) 
{ 
  uint32_t ret_val ;

  {
#line 55
  ret_val = (uint32_t )31;
  {
#line 55
  while (1) {
    while_continue: /* CIL Label */ ;
#line 55
    if (! (ret_val > 1U)) {
#line 55
      goto while_break;
    }
#line 56
    if ((n & (unsigned int )(1 << ret_val)) != 0U) {
#line 57
      return (ret_val);
    }
#line 55
    ret_val --;
  }
  while_break: /* CIL Label */ ;
  }
#line 59
  return ((uint32_t )0);
}
}
#line 104 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/lru_cache.c"
lru_cache *lru_cache_create(uint32_t max_keys , uint32_t secret ) 
{ 
  lru_cache *tmp ;

  {
  {
#line 106
  tmp = lru_cache_create_ctx((void *)0, max_keys, secret, (_Bool)0);
  }
#line 106
  return (tmp);
}
}
#line 110 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/lru_cache.c"
lru_cache *lru_cache_create_ctx(void *talloc_ctx , uint32_t max_keys , uint32_t secret ,
                                _Bool talloc_data ) 
{ 
  lru_cache *ret_val ;
  void *tmp ;
  uint32_t tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 115
  tmp = talloc_named_const((void const   *)talloc_ctx, sizeof(lru_cache ), "lru_cache");
#line 115
  ret_val = (lru_cache *)tmp;
  }
#line 116
  if ((unsigned long )ret_val == (unsigned long )((void *)0)) {
#line 117
    return ((lru_cache *)((void *)0));
  }
#line 119
  if (max_keys == 0U) {
#line 120
    ret_val->num_buckets = (uint32_t )1024;
  } else {
    {
#line 123
    tmp___0 = lru_cache_floor_log2(max_keys);
#line 123
    ret_val->num_buckets = max_keys / tmp___0;
    }
#line 124
    if (ret_val->num_buckets < 1U) {
#line 125
      ret_val->num_buckets = (uint32_t )1;
    }
  }
  {
#line 128
  tmp___1 = _talloc_array((void const   *)ret_val, sizeof(lru_cache_element *), ret_val->num_buckets,
                          "lru_cache_element*");
#line 128
  ret_val->table = (lru_cache_element **)tmp___1;
  }
#line 130
  if ((unsigned long )ret_val->table == (unsigned long )((void *)0)) {
    {
#line 132
    talloc_free((void *)ret_val);
    }
#line 133
    return ((lru_cache *)((void *)0));
  }
  {
#line 136
  ret_val->oldest = (lru_cache_element *)((void *)0);
#line 137
  ret_val->newest = (lru_cache_element *)((void *)0);
#line 138
  ret_val->max_keys = max_keys;
#line 139
  ret_val->secret = secret;
#line 140
  ret_val->talloc_data = talloc_data;
#line 141
  ret_val->num_keys = (uint32_t )0;
#line 142
  memset((void *)ret_val->table, 0, (unsigned long )ret_val->num_buckets * sizeof(lru_cache_element *));
  }
#line 144
  return (ret_val);
}
}
#line 148 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/lru_cache.c"
void lru_cache_destroy(lru_cache *ht ) 
{ 


  {
  {
#line 150
  ht->secret = (uint32_t )0;
#line 151
  talloc_free((void *)ht);
  }
#line 152
  return;
}
}
#line 156 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/lru_cache.c"
_Bool lru_cache_update(lru_cache *ht , void const   *index___0 , uint32_t index_len ,
                       void *data ) 
{ 
  uint32_t hash ;
  uint32_t lru_hash ;
  lru_cache_element *cur ;
  lru_cache_element *last ;
  lru_cache_element *e ;
  void *tmp_index ;
  int tmp ;
  void *tmp___0 ;

  {
  {
#line 161
  last = (lru_cache_element *)((void *)0);
#line 162
  e = (lru_cache_element *)((void *)0);
#line 165
  hash = lru_cache_compute_hash(ht->num_buckets, ht->secret, index___0, index_len);
#line 166
  cur = *(ht->table + hash);
  }
  {
#line 166
  while (1) {
    while_continue: /* CIL Label */ ;
#line 166
    if ((unsigned long )cur != (unsigned long )((void *)0)) {
#line 166
      if (! ((unsigned long )e == (unsigned long )((void *)0))) {
#line 166
        goto while_break;
      }
    } else {
#line 166
      goto while_break;
    }
#line 168
    if (index_len == cur->index_len) {
      {
#line 168
      tmp = memcmp((void const   *)cur->index, index___0, (size_t )index_len);
      }
#line 168
      if (tmp == 0) {
#line 170
        e = cur;
      }
    }
#line 166
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 173
  if ((unsigned long )e != (unsigned long )((void *)0)) {
#line 178
    if (ht->talloc_data) {
      {
#line 179
      talloc_free(e->data);
      }
    }
#line 181
    if ((unsigned long )e->newer == (unsigned long )((void *)0)) {
#line 182
      ht->newest = e->older;
    } else {
#line 184
      (e->newer)->older = e->older;
    }
#line 186
    if ((unsigned long )e->older == (unsigned long )((void *)0)) {
#line 187
      ht->oldest = e->newer;
    } else {
#line 189
      (e->older)->newer = e->newer;
    }
  } else {
#line 194
    if (ht->max_keys != 0U) {
#line 194
      if (ht->num_keys >= ht->max_keys) {
#line 198
        e = ht->oldest;
#line 199
        if ((unsigned long )ht->newest == (unsigned long )ht->oldest) {
#line 201
          ht->newest = (lru_cache_element *)((void *)0);
#line 202
          ht->oldest = (lru_cache_element *)((void *)0);
        } else {
#line 206
          ht->oldest = e->newer;
#line 207
          (e->newer)->older = (lru_cache_element *)((void *)0);
        }
        {
#line 209
        e->newer = (lru_cache_element *)((void *)0);
#line 210
        e->older = (lru_cache_element *)((void *)0);
#line 212
        last = (lru_cache_element *)((void *)0);
#line 213
        lru_hash = lru_cache_compute_hash(ht->num_buckets, ht->secret, (void const   *)e->index,
                                          e->index_len);
#line 215
        cur = *(ht->table + lru_hash);
        }
        {
#line 215
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 215
          if ((unsigned long )cur != (unsigned long )e) {
#line 215
            if (! ((unsigned long )cur != (unsigned long )((void *)0))) {
#line 215
              goto while_break___0;
            }
          } else {
#line 215
            goto while_break___0;
          }
#line 217
          goto __Cont;
          __Cont: /* CIL Label */ 
#line 215
          last = cur;
#line 215
          cur = cur->next;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 219
        if ((unsigned long )last == (unsigned long )((void *)0)) {
#line 220
          *(ht->table + lru_hash) = e->next;
        } else {
#line 222
          last->next = e->next;
        }
#line 223
        e->next = (lru_cache_element *)((void *)0);
#line 225
        if (ht->talloc_data) {
          {
#line 226
          talloc_free(e->data);
          }
        }
        {
#line 228
        tmp_index = _talloc_realloc((void const   *)e, e->index, (size_t )index_len,
                                    "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/lru_cache.c:228");
        }
#line 229
        if ((unsigned long )tmp_index == (unsigned long )((void *)0)) {
          {
#line 231
          talloc_free((void *)e);
          }
#line 232
          return ((_Bool)0);
        } else {
#line 235
          e->index = tmp_index;
        }
      } else {
#line 194
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 240
      tmp___0 = talloc_named_const((void const   *)ht->table, sizeof(lru_cache_element ),
                                   "lru_cache_element");
#line 240
      e = (lru_cache_element *)tmp___0;
      }
#line 241
      if ((unsigned long )e == (unsigned long )((void *)0)) {
#line 242
        return ((_Bool)0);
      }
      {
#line 244
      e->index = talloc_named_const((void const   *)e, (size_t )index_len, "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/lru_cache.c:244");
      }
#line 245
      if ((unsigned long )e->index == (unsigned long )((void *)0)) {
        {
#line 247
        talloc_free((void *)e);
        }
#line 248
        return ((_Bool)0);
      }
#line 252
      (ht->num_keys) ++;
    }
    {
#line 254
    memcpy((void */* __restrict  */)e->index, (void const   */* __restrict  */)index___0,
           (size_t )index_len);
#line 255
    e->index_len = index_len;
#line 258
    e->next = *(ht->table + hash);
#line 259
    *(ht->table + hash) = e;
    }
  }
#line 261
  e->data = data;
#line 262
  if (ht->talloc_data) {
    {
#line 263
    _talloc_steal((void const   *)e, (void const   *)e->data);
    }
  }
#line 266
  if ((unsigned long )ht->newest != (unsigned long )((void *)0)) {
#line 267
    (ht->newest)->newer = e;
  }
#line 268
  e->newer = (lru_cache_element *)((void *)0);
#line 269
  e->older = ht->newest;
#line 270
  ht->newest = e;
#line 271
  if ((unsigned long )ht->oldest == (unsigned long )((void *)0)) {
#line 272
    ht->oldest = e;
  }
#line 274
  return ((_Bool)1);
}
}
#line 278 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/lru_cache.c"
void *lru_cache_find(lru_cache *ht , void const   *index___0 , uint32_t index_len ) 
{ 
  uint32_t hash ;
  lru_cache_element *cur ;
  int tmp ;

  {
  {
#line 284
  hash = lru_cache_compute_hash(ht->num_buckets, ht->secret, index___0, index_len);
#line 285
  cur = *(ht->table + hash);
  }
  {
#line 285
  while (1) {
    while_continue: /* CIL Label */ ;
#line 285
    if (! ((unsigned long )cur != (unsigned long )((void *)0))) {
#line 285
      goto while_break;
    }
#line 287
    if (index_len == cur->index_len) {
      {
#line 287
      tmp = memcmp((void const   *)cur->index, index___0, (size_t )index_len);
      }
#line 287
      if (tmp == 0) {
#line 289
        goto while_break;
      }
    }
#line 285
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 292
  if ((unsigned long )cur != (unsigned long )((void *)0)) {
#line 292
    if ((unsigned long )cur->newer != (unsigned long )((void *)0)) {
#line 295
      (cur->newer)->older = cur->older;
#line 297
      if ((unsigned long )cur->older == (unsigned long )((void *)0)) {
#line 298
        ht->oldest = cur->newer;
      } else {
#line 300
        (cur->older)->newer = cur->newer;
      }
#line 302
      cur->newer = (lru_cache_element *)((void *)0);
#line 303
      cur->older = ht->newest;
#line 304
      (ht->newest)->newer = cur;
#line 305
      ht->newest = cur;
    }
  }
#line 308
  if ((unsigned long )cur != (unsigned long )((void *)0)) {
#line 309
    return (cur->data);
  } else {
#line 311
    return ((void *)0);
  }
}
}
#line 316 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/lru_cache.c"
_Bool lru_cache_remove(lru_cache *ht , void const   *index___0 , uint32_t index_len ) 
{ 
  uint32_t hash ;
  lru_cache_element *cur ;
  lru_cache_element *last ;
  int tmp ;

  {
  {
#line 321
  last = (lru_cache_element *)((void *)0);
#line 323
  hash = lru_cache_compute_hash(ht->num_buckets, ht->secret, index___0, index_len);
#line 325
  cur = *(ht->table + hash);
  }
  {
#line 325
  while (1) {
    while_continue: /* CIL Label */ ;
#line 325
    if (! ((unsigned long )cur != (unsigned long )((void *)0))) {
#line 325
      goto while_break;
    }
#line 328
    if (index_len == cur->index_len) {
      {
#line 328
      tmp = memcmp((void const   *)cur->index, index___0, (size_t )index_len);
      }
#line 328
      if (tmp == 0) {
#line 330
        goto while_break;
      }
    }
#line 325
    last = cur;
#line 325
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 333
  if ((unsigned long )cur == (unsigned long )((void *)0)) {
#line 334
    return ((_Bool)0);
  }
#line 337
  if ((unsigned long )cur->newer == (unsigned long )((void *)0)) {
#line 338
    ht->newest = cur->older;
  } else {
#line 340
    (cur->newer)->older = cur->older;
  }
#line 342
  if ((unsigned long )cur->older == (unsigned long )((void *)0)) {
#line 343
    ht->oldest = cur->newer;
  } else {
#line 345
    (cur->older)->newer = cur->newer;
  }
#line 348
  if ((unsigned long )last == (unsigned long )((void *)0)) {
#line 349
    *(ht->table + hash) = cur->next;
  } else {
#line 351
    last->next = cur->next;
  }
  {
#line 353
  talloc_free((void *)cur);
#line 356
  (ht->num_keys) --;
  }
#line 358
  return ((_Bool)1);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 390
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 140
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 214 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 334 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                __off_t __offset ,
                                                                                int __whence ) ;
#line 353
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 37 "/usr/include/iconv.h"
extern iconv_t iconv_open(char const   *__tocode , char const   *__fromcode ) ;
#line 42
extern size_t iconv(iconv_t __cd , char ** __restrict  __inbuf , size_t * __restrict  __inbytesleft ,
                    char ** __restrict  __outbuf , size_t * __restrict  __outbytesleft ) ;
#line 51
extern int iconv_close(iconv_t __cd ) ;
#line 145 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/include/talloc.h"
void *_talloc_realloc_array(void const   *ctx , void *ptr , size_t el_size , unsigned int count ,
                            char const   *name ) ;
#line 232 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/include/winsec.h"
WINSEC_DESC *winsec_parse_desc(void *talloc_ctx , uint8_t const   *buf , uint32_t buf_len ) ;
#line 260
WINSEC_UUID *winsec_parse_uuid(void *talloc_ctx , uint8_t const   *buf , uint32_t buf_len ) ;
#line 61 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/include/void_stack.h"
void_stack *void_stack_new(unsigned short max_size ) ;
#line 119
void *void_stack_pop(void_stack *stack ) ;
#line 129
_Bool void_stack_push(void_stack *stack , void *e ) ;
#line 61 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/include/range_list.h"
range_list *range_list_new(void) ;
#line 71
void range_list_free(range_list *rl ) ;
#line 80
uint32_t range_list_size(range_list const   *rl ) ;
#line 99
_Bool range_list_add(range_list *rl , uint32_t offset , uint32_t length , void *data ) ;
#line 122
range_list_element const   *range_list_get(range_list const   *rl , uint32_t index___0 ) ;
#line 146
void *range_list_find_data(range_list const   *rl , uint32_t offset ) ;
#line 810 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/include/regfi.h"
REGFI_FILE *regfi_open(char const   *filename ) ;
#line 823
REGFI_FILE *regfi_alloc(int fd ) ;
#line 835
int regfi_close(REGFI_FILE *file ) ;
#line 844
void regfi_free(REGFI_FILE *file ) ;
#line 856
char *regfi_get_messages(REGFI_FILE *file ) ;
#line 881
void regfi_set_message_mask(REGFI_FILE *file , uint16_t mask ) ;
#line 892
void regfi_free_key(REGFI_NK_REC *nk ) ;
#line 901
void regfi_free_value(REGFI_VK_REC *vk ) ;
#line 932
REGFI_ITERATOR *regfi_iterator_new(REGFI_FILE *file , REGFI_ENCODING output_encoding ) ;
#line 944
void regfi_iterator_free(REGFI_ITERATOR *i ) ;
#line 960
_Bool regfi_iterator_down(REGFI_ITERATOR *i ) ;
#line 972
_Bool regfi_iterator_up(REGFI_ITERATOR *i ) ;
#line 983
_Bool regfi_iterator_to_root(REGFI_ITERATOR *i ) ;
#line 1004
_Bool regfi_iterator_walk_path(REGFI_ITERATOR *i , char const   **path ) ;
#line 1015
REGFI_NK_REC const   *regfi_iterator_cur_key(REGFI_ITERATOR *i ) ;
#line 1026
REGFI_SK_REC const   *regfi_iterator_cur_sk(REGFI_ITERATOR *i ) ;
#line 1041
REGFI_NK_REC *regfi_iterator_first_subkey(REGFI_ITERATOR *i ) ;
#line 1054
REGFI_NK_REC *regfi_iterator_cur_subkey(REGFI_ITERATOR *i ) ;
#line 1067
REGFI_NK_REC *regfi_iterator_next_subkey(REGFI_ITERATOR *i ) ;
#line 1081
_Bool regfi_iterator_find_subkey(REGFI_ITERATOR *i , char const   *subkey_name ) ;
#line 1096
REGFI_VK_REC *regfi_iterator_first_value(REGFI_ITERATOR *i ) ;
#line 1109
REGFI_VK_REC *regfi_iterator_cur_value(REGFI_ITERATOR *i ) ;
#line 1122
REGFI_VK_REC *regfi_iterator_next_value(REGFI_ITERATOR *i ) ;
#line 1136
_Bool regfi_iterator_find_value(REGFI_ITERATOR *i , char const   *value_name ) ;
#line 1149
REGFI_CLASSNAME *regfi_iterator_fetch_classname(REGFI_ITERATOR *i , REGFI_NK_REC const   *key ) ;
#line 1163
REGFI_DATA *regfi_iterator_fetch_data(REGFI_ITERATOR *i , REGFI_VK_REC const   *value ) ;
#line 1180
REGFI_NK_REC *regfi_load_key(REGFI_FILE *file , uint32_t offset , REGFI_ENCODING output_encoding ,
                             _Bool strict ) ;
#line 1191
REGFI_VK_REC *regfi_load_value(REGFI_FILE *file , uint32_t offset , REGFI_ENCODING output_encoding ,
                               _Bool strict ) ;
#line 1202
REGFI_SUBKEY_LIST *regfi_load_subkeylist(REGFI_FILE *file , uint32_t offset , uint32_t num_keys ,
                                         uint32_t max_size , _Bool strict ) ;
#line 1213
REGFI_VALUE_LIST *regfi_load_valuelist(REGFI_FILE *file , uint32_t offset , uint32_t num_values ,
                                       uint32_t max_size , _Bool strict ) ;
#line 1225
REGFI_BUFFER regfi_load_data(REGFI_FILE *file , uint32_t voffset , uint32_t length ,
                             _Bool data_in_offset , _Bool strict ) ;
#line 1236
REGFI_BUFFER regfi_load_big_data(REGFI_FILE *file , uint32_t offset , uint32_t data_length ,
                                 uint32_t cell_length , range_list *used_ranges ,
                                 _Bool strict ) ;
#line 1249
_Bool regfi_interpret_data(REGFI_FILE *file , REGFI_ENCODING string_encoding , uint32_t type ,
                           REGFI_DATA *data ) ;
#line 1260
void regfi_free_classname(REGFI_CLASSNAME *classname ) ;
#line 1269
void regfi_free_data(REGFI_DATA *data ) ;
#line 1280
REGFI_SK_REC const   *regfi_load_sk(REGFI_FILE *file , uint32_t offset , _Bool strict ) ;
#line 1290
REGFI_HBIN const   *regfi_lookup_hbin(REGFI_FILE *file , uint32_t offset ) ;
#line 1300
REGFI_FILE *regfi_parse_regf(int fd , _Bool strict ) ;
#line 1301
REGFI_HBIN *regfi_parse_hbin(REGFI_FILE *file , uint32_t offset , _Bool strict ) ;
#line 1317
REGFI_NK_REC *regfi_parse_nk(REGFI_FILE *file , uint32_t offset , uint32_t max_size ,
                             _Bool strict ) ;
#line 1327
REGFI_SUBKEY_LIST *regfi_parse_subkeylist(REGFI_FILE *file , uint32_t offset , uint32_t max_size ,
                                          _Bool strict ) ;
#line 1337
REGFI_VK_REC *regfi_parse_vk(REGFI_FILE *file , uint32_t offset , uint32_t max_size ,
                             _Bool strict ) ;
#line 1347
REGFI_SK_REC *regfi_parse_sk(REGFI_FILE *file , uint32_t offset , uint32_t max_size ,
                             _Bool strict ) ;
#line 1360
range_list *regfi_parse_unalloc_cells(REGFI_FILE *file ) ;
#line 1369
_Bool regfi_parse_cell(int fd , uint32_t offset , uint8_t *hdr , uint32_t hdr_len ,
                       uint32_t *cell_length , _Bool *unalloc ) ;
#line 1380
uint8_t *regfi_parse_classname(REGFI_FILE *file , uint32_t offset , uint16_t *name_length ,
                               uint32_t max_size , _Bool strict ) ;
#line 1391
REGFI_BUFFER regfi_parse_data(REGFI_FILE *file , uint32_t offset , uint32_t length ,
                              _Bool strict ) ;
#line 1402
REGFI_BUFFER regfi_parse_little_data(REGFI_FILE *file , uint32_t voffset , uint32_t length ,
                                     _Bool strict ) ;
#line 1409
REGFI_NK_REC *regfi_rootkey(REGFI_FILE *file , REGFI_ENCODING output_encoding ) ;
#line 1411
void regfi_subkeylist_free(REGFI_SUBKEY_LIST *list ) ;
#line 1412
uint32_t regfi_read(int fd , uint8_t *buf , uint32_t *length ) ;
#line 1414
char const   *regfi_type_val2str(unsigned int val ) ;
#line 1415
int regfi_type_str2val(char const   *str ) ;
#line 1417
char *regfi_get_sacl(WINSEC_DESC *sec_desc ) ;
#line 1418
char *regfi_get_dacl(WINSEC_DESC *sec_desc ) ;
#line 1419
char *regfi_get_owner(WINSEC_DESC *sec_desc ) ;
#line 1420
char *regfi_get_group(WINSEC_DESC *sec_desc ) ;
#line 1422
REGFI_SUBKEY_LIST *regfi_merge_subkeylists(uint16_t num_lists , REGFI_SUBKEY_LIST **lists ,
                                           _Bool strict ) ;
#line 1425
REGFI_SUBKEY_LIST *regfi_load_subkeylist_aux(REGFI_FILE *file , uint32_t offset ,
                                             uint32_t max_size , _Bool strict , uint8_t depth_left ) ;
#line 1428
void regfi_add_message(REGFI_FILE *file , uint16_t msg_type , char const   *fmt  , ...) ;
#line 1432
int32_t regfi_calc_maxsize(REGFI_FILE *file , uint32_t offset ) ;
#line 1433
int32_t regfi_conv_charset(char const   *input_charset , char const   *output_charset ,
                           uint8_t *input , char *output , uint32_t input_len , uint32_t output_max ) ;
#line 1437
REGFI_DATA *regfi_buffer_to_data(REGFI_BUFFER raw_data ) ;
#line 1440
void regfi_unix2nt_time(REGFI_NTTIME *nt , time_t t ) ;
#line 1441
time_t regfi_nt2unix_time(REGFI_NTTIME const   *nt ) ;
#line 1444
void regfi_interpret_keyname(REGFI_FILE *file , REGFI_NK_REC *nk , REGFI_ENCODING output_encoding ,
                             _Bool strict ) ;
#line 1446
void regfi_interpret_valuename(REGFI_FILE *file , REGFI_VK_REC *vk , REGFI_ENCODING output_encoding ,
                               _Bool strict ) ;
#line 38 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
unsigned int const   regfi_num_reg_types  =    (unsigned int const   )12;
#line 39 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
static char const   *regfi_type_names[12]  = 
#line 39
  {      "NONE",      "SZ",      "EXPAND_SZ",      "BINARY", 
        "DWORD",      "DWORD_BE",      "LINK",      "MULTI_SZ", 
        "RSRC_LIST",      "RSRC_DESC",      "RSRC_REQ_LIST",      "QWORD"};
#line 43 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
char const   *regfi_encoding_names[3]  = {      "US-ASCII//TRANSLIT",      "UTF-8//TRANSLIT",      "UTF-16LE//TRANSLIT"};
#line 49 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
void regfi_add_message(REGFI_FILE *file , uint16_t msg_type , char const   *fmt  , ...) 
{ 
  uint32_t buf_size ;
  uint32_t buf_used ;
  char *new_msg ;
  va_list args ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
#line 58
  if (((int )file->msg_mask & (int )msg_type) != 0) {
#line 60
    if ((unsigned long )file->last_message == (unsigned long )((void *)0)) {
#line 61
      buf_used = (uint32_t )0;
    } else {
      {
#line 63
      tmp = strlen((char const   *)file->last_message);
#line 63
      buf_used = (uint32_t )tmp;
      }
    }
    {
#line 65
    tmp___0 = strlen(fmt);
#line 65
    buf_size = (uint32_t )(((size_t )buf_used + tmp___0) + 160UL);
#line 66
    tmp___1 = realloc((void *)file->last_message, (size_t )buf_size);
#line 66
    new_msg = (char *)tmp___1;
    }
#line 67
    if ((unsigned long )new_msg == (unsigned long )((void *)0)) {
#line 69
      return;
    }
    {
#line 73
    if ((int )msg_type == 1) {
#line 73
      goto case_1;
    }
#line 77
    if ((int )msg_type == 4) {
#line 77
      goto case_4;
    }
#line 81
    if ((int )msg_type == 16) {
#line 81
      goto case_16;
    }
#line 71
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 74
    strcpy((char */* __restrict  */)(new_msg + buf_used), (char const   */* __restrict  */)"INFO: ");
#line 75
    buf_used += 6U;
    }
#line 76
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 78
    strcpy((char */* __restrict  */)(new_msg + buf_used), (char const   */* __restrict  */)"WARN: ");
#line 79
    buf_used += 6U;
    }
#line 80
    goto switch_break;
    case_16: /* CIL Label */ 
    {
#line 82
    strcpy((char */* __restrict  */)(new_msg + buf_used), (char const   */* __restrict  */)"ERROR: ");
#line 83
    buf_used += 7U;
    }
#line 84
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 87
    __builtin_va_start(args, fmt);
#line 88
    vsnprintf((char */* __restrict  */)(new_msg + buf_used), (size_t )(buf_size - buf_used),
              (char const   */* __restrict  */)fmt, args);
#line 89
    __builtin_va_end(args);
#line 90
    strncat((char */* __restrict  */)new_msg, (char const   */* __restrict  */)"\n",
            (size_t )(buf_size - 1U));
#line 92
    file->last_message = new_msg;
    }
  }
#line 94
  return;
}
}
#line 99 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
char *regfi_get_messages(REGFI_FILE *file ) 
{ 
  char *ret_val ;

  {
#line 101
  ret_val = file->last_message;
#line 102
  file->last_message = (char *)((void *)0);
#line 104
  return (ret_val);
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
void regfi_set_message_mask(REGFI_FILE *file , uint16_t mask ) 
{ 


  {
#line 110
  file->msg_mask = mask;
#line 111
  return;
}
}
#line 117 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
static char const   *regfi_encoding_int2str(REGFI_ENCODING e ) 
{ 


  {
#line 119
  if ((int )e < 3) {
#line 120
    return (regfi_encoding_names[e]);
  }
#line 122
  return ((char const   *)((void *)0));
}
}
#line 129 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
char const   *regfi_type_val2str(unsigned int val ) 
{ 


  {
#line 131
  if (val == 2147483647U) {
#line 132
    return ("KEY");
  }
#line 134
  if (val >= (unsigned int )regfi_num_reg_types) {
#line 135
    return ((char const   *)((void *)0));
  }
#line 137
  return (regfi_type_names[val]);
}
}
#line 144 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
int regfi_type_str2val(char const   *str ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 148
  tmp = strcmp("KEY", str);
  }
#line 148
  if (tmp == 0) {
#line 149
    return (2147483647);
  }
#line 151
  i = 0;
  {
#line 151
  while (1) {
    while_continue: /* CIL Label */ ;
#line 151
    if (! ((unsigned int const   )i < regfi_num_reg_types)) {
#line 151
      goto while_break;
    }
    {
#line 152
    tmp___0 = strcmp(regfi_type_names[i], str);
    }
#line 152
    if (tmp___0 == 0) {
#line 153
      return (i);
    }
#line 151
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 155
  tmp___1 = strcmp("DWORD_LE", str);
  }
#line 155
  if (tmp___1 == 0) {
#line 156
    return (4);
  }
#line 158
  return (-1);
}
}
#line 166
char const   *regfi_ace_type2str(uint8_t type ) ;
#line 166 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
static char const   *map[7]  = {      "ALLOW",      "DENY",      "AUDIT",      "ALARM", 
        "ALLOW CPD",      "OBJ ALLOW",      "OBJ DENY"};
#line 164 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
char const   *regfi_ace_type2str(uint8_t type ) 
{ 


  {
#line 169
  if ((int )type < 7) {
#line 170
    return (map[type]);
  } else {
#line 176
    return ("UNKNOWN");
  }
}
}
#line 186
char *regfi_ace_flags2str(uint8_t flags ) ;
#line 186 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
static char const   *flag_map[32]  = 
#line 186
  {      "OI",      "CI",      "NP",      "IO", 
        "IA",      (char const   *)((void *)0),      (char const   *)((void *)0),      (char const   *)((void *)0)};
#line 184 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
char *regfi_ace_flags2str(uint8_t flags ) 
{ 
  char *ret_val ;
  void *tmp ;
  char *fo ;
  uint32_t i ;
  uint8_t f___0 ;
  size_t tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 197
  tmp = malloc(35UL * sizeof(char ));
#line 197
  ret_val = (char *)tmp;
#line 198
  fo = ret_val;
  }
#line 202
  if ((unsigned long )ret_val == (unsigned long )((void *)0)) {
#line 203
    return ((char *)((void *)0));
  }
#line 205
  *(fo + 0) = (char )'\000';
#line 206
  if (! flags) {
#line 207
    return (ret_val);
  }
#line 209
  i = (uint32_t )0;
  {
#line 209
  while (1) {
    while_continue: /* CIL Label */ ;
#line 209
    if (! (i < 8U)) {
#line 209
      goto while_break;
    }
#line 211
    f___0 = (uint8_t )(1 << i);
#line 212
    if ((int )flags & (int )f___0) {
#line 212
      if ((unsigned long )flag_map[i] != (unsigned long )((void *)0)) {
        {
#line 214
        strcpy((char */* __restrict  */)fo, (char const   */* __restrict  */)flag_map[i]);
#line 215
        tmp___0 = strlen(flag_map[i]);
#line 215
        fo += tmp___0;
#line 216
        tmp___1 = fo;
#line 216
        fo ++;
#line 216
        *tmp___1 = (char )' ';
#line 217
        flags = (uint8_t )((int )flags ^ (int )f___0);
        }
      }
    }
#line 209
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 222
  if ((int )flags != 0) {
    {
#line 223
    sprintf((char */* __restrict  */)fo, (char const   */* __restrict  */)"0x%.2X ",
            (int )flags);
    }
  }
#line 226
  if ((unsigned long )fo != (unsigned long )ret_val) {
#line 227
    *(fo + -1) = (char )'\000';
  }
#line 229
  return (ret_val);
}
}
#line 245
char *regfi_ace_perms2str(uint32_t perms ) ;
#line 245 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
static char const   *perm_map[32]  = 
#line 245
  {      "QRY_VAL",      "SET_VAL",      "CREATE_KEY",      "ENUM_KEYS", 
        "NOTIFY",      "CREATE_LNK",      (char const   *)((void *)0),      (char const   *)((void *)0), 
        "WOW64_64",      "WOW64_32",      (char const   *)((void *)0),      (char const   *)((void *)0), 
        (char const   *)((void *)0),      (char const   *)((void *)0),      (char const   *)((void *)0),      (char const   *)((void *)0), 
        "DELETE",      "R_CONT",      "W_DAC",      "W_OWNER", 
        "SYNC",      (char const   *)((void *)0),      (char const   *)((void *)0),      (char const   *)((void *)0), 
        "SYS_SEC",      "MAX_ALLWD",      (char const   *)((void *)0),      (char const   *)((void *)0), 
        "GEN_A",      "GEN_X",      "GEN_W",      "GEN_R"};
#line 233 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
char *regfi_ace_perms2str(uint32_t perms ) 
{ 
  uint32_t i ;
  uint32_t p ;
  char *ret_val ;
  void *tmp ;
  char *r ;
  size_t tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 237
  tmp = malloc(350UL * sizeof(char ));
#line 237
  ret_val = (char *)tmp;
#line 238
  r = ret_val;
  }
#line 284
  if ((unsigned long )ret_val == (unsigned long )((void *)0)) {
#line 285
    return ((char *)((void *)0));
  }
#line 287
  *(r + 0) = (char )'\000';
#line 288
  i = (uint32_t )0;
  {
#line 288
  while (1) {
    while_continue: /* CIL Label */ ;
#line 288
    if (! (i < 32U)) {
#line 288
      goto while_break;
    }
#line 290
    p = (uint32_t )(1 << i);
#line 291
    if (perms & p) {
#line 291
      if ((unsigned long )perm_map[i] != (unsigned long )((void *)0)) {
        {
#line 293
        strcpy((char */* __restrict  */)r, (char const   */* __restrict  */)perm_map[i]);
#line 294
        tmp___0 = strlen(perm_map[i]);
#line 294
        r += tmp___0;
#line 295
        tmp___1 = r;
#line 295
        r ++;
#line 295
        *tmp___1 = (char )' ';
#line 296
        perms ^= p;
        }
      }
    }
#line 288
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 301
  if (perms != 0U) {
    {
#line 302
    sprintf((char */* __restrict  */)r, (char const   */* __restrict  */)"0x%.8X ",
            perms);
    }
  }
#line 305
  if ((unsigned long )r != (unsigned long )ret_val) {
#line 306
    *(r + -1) = (char )'\000';
  }
#line 308
  return (ret_val);
}
}
#line 312 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
char *regfi_sid2str(WINSEC_DOM_SID *sid ) 
{ 
  uint32_t i ;
  uint32_t size ;
  uint32_t left ;
  uint8_t comps ;
  char *ret_val ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 314
  size = (uint32_t )189;
#line 315
  left = size;
#line 316
  comps = sid->num_auths;
#line 317
  tmp = malloc((size_t )size);
#line 317
  ret_val = (char *)tmp;
  }
#line 319
  if ((unsigned long )ret_val == (unsigned long )((void *)0)) {
#line 320
    return ((char *)((void *)0));
  }
#line 322
  if ((int )comps > 15) {
#line 323
    comps = (uint8_t )15;
  }
  {
#line 325
  tmp___0 = sprintf((char */* __restrict  */)ret_val, (char const   */* __restrict  */)"S-%u-%u",
                    (int )sid->sid_rev_num, (int )sid->id_auth[5]);
#line 325
  left -= (uint32_t )tmp___0;
#line 327
  i = (uint32_t )0;
  }
  {
#line 327
  while (1) {
    while_continue: /* CIL Label */ ;
#line 327
    if (! (i < (uint32_t )comps)) {
#line 327
      goto while_break;
    }
    {
#line 328
    tmp___1 = snprintf((char */* __restrict  */)(ret_val + (size - left)), (size_t )left,
                       (char const   */* __restrict  */)"-%u", sid->sub_auths[i]);
#line 328
    left -= (uint32_t )tmp___1;
#line 327
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 330
  return (ret_val);
}
}
#line 334 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
char *regfi_get_acl(WINSEC_ACL *acl ) 
{ 
  uint32_t i ;
  uint32_t extra ;
  uint32_t size ;
  char const   *type_str ;
  char *flags_str ;
  char *perms_str ;
  char *sid_str ;
  char *ace_delim ;
  char *ret_val ;
  char *tmp_val ;
  _Bool failed ;
  char field_delim ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;

  {
#line 336
  size = (uint32_t )0;
#line 341
  ace_delim = (char *)"";
#line 342
  ret_val = (char *)((void *)0);
#line 343
  tmp_val = (char *)((void *)0);
#line 344
  failed = (_Bool)0;
#line 345
  field_delim = (char )':';
#line 347
  i = (uint32_t )0;
  {
#line 347
  while (1) {
    while_continue: /* CIL Label */ ;
#line 347
    if (i < acl->num_aces) {
#line 347
      if (! (! failed)) {
#line 347
        goto while_break;
      }
    } else {
#line 347
      goto while_break;
    }
    {
#line 349
    sid_str = regfi_sid2str((*(acl->aces + i))->trustee);
#line 350
    type_str = regfi_ace_type2str((*(acl->aces + i))->type);
#line 351
    perms_str = regfi_ace_perms2str((*(acl->aces + i))->access_mask);
#line 352
    flags_str = regfi_ace_flags2str((*(acl->aces + i))->flags);
    }
#line 354
    if ((unsigned long )flags_str != (unsigned long )((void *)0)) {
#line 354
      if ((unsigned long )perms_str != (unsigned long )((void *)0)) {
#line 354
        if ((unsigned long )type_str != (unsigned long )((void *)0)) {
#line 354
          if ((unsigned long )sid_str != (unsigned long )((void *)0)) {
            {
#line 358
            tmp = strlen((char const   *)sid_str);
#line 358
            tmp___0 = strlen(type_str);
#line 358
            tmp___1 = strlen((char const   *)perms_str);
#line 358
            tmp___2 = strlen((char const   *)flags_str);
#line 358
            extra = (uint32_t )((((tmp + tmp___0) + tmp___1) + tmp___2) + 5UL);
#line 360
            tmp___3 = realloc((void *)ret_val, (size_t )(size + extra));
#line 360
            tmp_val = (char *)tmp___3;
            }
#line 362
            if ((unsigned long )tmp_val == (unsigned long )((void *)0)) {
              {
#line 364
              free((void *)ret_val);
#line 365
              ret_val = (char *)((void *)0);
#line 366
              failed = (_Bool)1;
              }
            } else {
              {
#line 370
              ret_val = tmp_val;
#line 371
              tmp___4 = sprintf((char */* __restrict  */)(ret_val + size), (char const   */* __restrict  */)"%s%s%c%s%c%s%c%s",
                                ace_delim, sid_str, (int )field_delim, type_str, (int )field_delim,
                                perms_str, (int )field_delim, flags_str);
#line 371
              size += (uint32_t )tmp___4;
#line 376
              ace_delim = (char *)"|";
              }
            }
          } else {
#line 380
            failed = (_Bool)1;
          }
        } else {
#line 380
          failed = (_Bool)1;
        }
      } else {
#line 380
        failed = (_Bool)1;
      }
    } else {
#line 380
      failed = (_Bool)1;
    }
#line 382
    if ((unsigned long )sid_str != (unsigned long )((void *)0)) {
      {
#line 383
      free((void *)sid_str);
      }
    }
#line 384
    if ((unsigned long )sid_str != (unsigned long )((void *)0)) {
      {
#line 385
      free((void *)perms_str);
      }
    }
#line 386
    if ((unsigned long )sid_str != (unsigned long )((void *)0)) {
      {
#line 387
      free((void *)flags_str);
      }
    }
#line 347
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 390
  return (ret_val);
}
}
#line 394 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
char *regfi_get_sacl(WINSEC_DESC *sec_desc ) 
{ 
  char *tmp ;

  {
#line 396
  if (sec_desc->sacl) {
    {
#line 397
    tmp = regfi_get_acl(sec_desc->sacl);
    }
#line 397
    return (tmp);
  } else {
#line 399
    return ((char *)((void *)0));
  }
}
}
#line 403 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
char *regfi_get_dacl(WINSEC_DESC *sec_desc ) 
{ 
  char *tmp ;

  {
#line 405
  if (sec_desc->dacl) {
    {
#line 406
    tmp = regfi_get_acl(sec_desc->dacl);
    }
#line 406
    return (tmp);
  } else {
#line 408
    return ((char *)((void *)0));
  }
}
}
#line 412 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
char *regfi_get_owner(WINSEC_DESC *sec_desc ) 
{ 
  char *tmp ;

  {
  {
#line 414
  tmp = regfi_sid2str(sec_desc->owner_sid);
  }
#line 414
  return (tmp);
}
}
#line 418 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
char *regfi_get_group(WINSEC_DESC *sec_desc ) 
{ 
  char *tmp ;

  {
  {
#line 420
  tmp = regfi_sid2str(sec_desc->grp_sid);
  }
#line 420
  return (tmp);
}
}
#line 435 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
uint32_t regfi_read(int fd , uint8_t *buf , uint32_t *length ) 
{ 
  uint32_t rsize ;
  uint32_t rret ;
  ssize_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;

  {
#line 437
  rsize = (uint32_t )0;
#line 438
  rret = (uint32_t )0;
  {
#line 440
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 442
    tmp = read(fd, (void *)(buf + rsize), (size_t )(*length - rsize));
#line 442
    rret = (uint32_t )tmp;
    }
#line 443
    if (rret > 0U) {
#line 444
      rsize += rret;
    }
#line 440
    if (*length - rsize > 0U) {
#line 440
      if (! (rret > 0U)) {
#line 440
        if (rret == 4294967295U) {
          {
#line 440
          tmp___0 = __errno_location();
          }
#line 440
          if (! (*tmp___0 == 11)) {
            {
#line 440
            tmp___1 = __errno_location();
            }
#line 440
            if (! (*tmp___1 == 4)) {
#line 440
              goto while_break;
            }
          }
        } else {
#line 440
          goto while_break;
        }
      }
    } else {
#line 440
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 448
  *length = rsize;
#line 449
  if (rret == 4294967295U) {
    {
#line 449
    tmp___3 = __errno_location();
    }
#line 449
    if (*tmp___3 != 4) {
      {
#line 449
      tmp___4 = __errno_location();
      }
#line 449
      if (*tmp___4 != 11) {
        {
#line 450
        tmp___2 = __errno_location();
        }
#line 450
        return ((uint32_t )*tmp___2);
      }
    }
  }
#line 452
  return ((uint32_t )0);
}
}
#line 459 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
_Bool regfi_parse_cell(int fd , uint32_t offset , uint8_t *hdr , uint32_t hdr_len ,
                       uint32_t *cell_length , _Bool *unalloc ) 
{ 
  uint32_t length ;
  int32_t raw_length ;
  uint8_t tmp[4] ;
  __off_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;

  {
  {
#line 466
  tmp___0 = lseek(fd, (__off_t )offset, 0);
  }
#line 466
  if (tmp___0 == -1L) {
#line 467
    return ((_Bool)0);
  }
  {
#line 469
  length = (uint32_t )4;
#line 470
  tmp___1 = regfi_read(fd, tmp, & length);
  }
#line 470
  if (tmp___1 != 0U) {
#line 471
    return ((_Bool)0);
  } else
#line 470
  if (length != 4U) {
#line 471
    return ((_Bool)0);
  }
#line 472
  raw_length = (int32_t )(((unsigned int )*((unsigned char const   *)(tmp) + 0) | ((unsigned int )*((unsigned char const   *)(tmp) + 1) << 8)) | (((unsigned int )*((unsigned char const   *)(tmp) + 2) | ((unsigned int )*((unsigned char const   *)(tmp) + 3) << 8)) << 16));
#line 474
  if (raw_length < 0) {
#line 476
    *cell_length = (uint32_t )(raw_length * -1);
#line 477
    *unalloc = (_Bool)0;
  } else {
#line 481
    *cell_length = (uint32_t )raw_length;
#line 482
    *unalloc = (_Bool)1;
  }
#line 485
  if (*cell_length - 4U < hdr_len) {
#line 486
    return ((_Bool)0);
  }
#line 488
  if (hdr_len > 0U) {
    {
#line 490
    length = hdr_len;
#line 491
    tmp___2 = regfi_read(fd, hdr, & length);
    }
#line 491
    if (tmp___2 != 0U) {
#line 492
      return ((_Bool)0);
    } else
#line 491
    if (length != hdr_len) {
#line 492
      return ((_Bool)0);
    }
  }
#line 495
  return ((_Bool)1);
}
}
#line 521 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
REGFI_HBIN const   *regfi_lookup_hbin(REGFI_FILE *file , uint32_t offset ) 
{ 
  void *tmp ;

  {
  {
#line 523
  tmp = range_list_find_data((range_list const   *)file->hbins, offset);
  }
#line 523
  return ((REGFI_HBIN const   *)tmp);
}
}
#line 533 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
int32_t regfi_calc_maxsize(REGFI_FILE *file , uint32_t offset ) 
{ 
  REGFI_HBIN const   *hbin ;
  REGFI_HBIN const   *tmp ;

  {
  {
#line 535
  tmp = regfi_lookup_hbin(file, offset);
#line 535
  hbin = tmp;
  }
#line 536
  if ((unsigned long )hbin == (unsigned long )((void *)0)) {
#line 537
    return (-1);
  }
#line 539
  return ((int32_t )((hbin->block_size + hbin->file_off) - (uint32_t const   )offset));
}
}
#line 545 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
REGFI_SUBKEY_LIST *regfi_load_subkeylist(REGFI_FILE *file , uint32_t offset , uint32_t num_keys ,
                                         uint32_t max_size , _Bool strict ) 
{ 
  REGFI_SUBKEY_LIST *ret_val ;

  {
  {
#line 551
  ret_val = regfi_load_subkeylist_aux(file, offset, max_size, strict, (uint8_t )255);
  }
#line 553
  if ((unsigned long )ret_val == (unsigned long )((void *)0)) {
    {
#line 555
    regfi_add_message(file, (uint16_t )4, "Failed to load subkey list at offset 0x%.8X.",
                      offset);
    }
#line 557
    return ((REGFI_SUBKEY_LIST *)((void *)0));
  }
#line 560
  if (num_keys != ret_val->num_keys) {
    {
#line 566
    regfi_add_message(file, (uint16_t )4, "Number of subkeys listed in parent (%d) did not match number found in subkey list/tree (%d) while parsing subkey list/tree at offset 0x%.8X.",
                      num_keys, ret_val->num_keys, offset);
    }
  }
#line 572
  return (ret_val);
}
}
#line 578 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
REGFI_SUBKEY_LIST *regfi_load_subkeylist_aux(REGFI_FILE *file , uint32_t offset ,
                                             uint32_t max_size , _Bool strict , uint8_t depth_left ) 
{ 
  REGFI_SUBKEY_LIST *ret_val ;
  REGFI_SUBKEY_LIST **sublists ;
  uint32_t i ;
  uint32_t num_sublists ;
  uint32_t off ;
  int32_t sublist_maxsize ;
  void *tmp ;
  REGFI_SUBKEY_LIST *tmp___0 ;

  {
#line 587
  if ((int )depth_left == 0) {
    {
#line 589
    regfi_add_message(file, (uint16_t )4, "Maximum depth reached while parsing subkey list/tree at offset 0x%.8X.",
                      offset);
    }
#line 592
    return ((REGFI_SUBKEY_LIST *)((void *)0));
  }
  {
#line 595
  ret_val = regfi_parse_subkeylist(file, offset, max_size, strict);
  }
#line 596
  if ((unsigned long )ret_val == (unsigned long )((void *)0)) {
#line 597
    return ((REGFI_SUBKEY_LIST *)((void *)0));
  }
#line 599
  if (ret_val->recursive_type) {
    {
#line 601
    num_sublists = ret_val->num_children;
#line 602
    tmp = malloc((unsigned long )num_sublists * sizeof(REGFI_SUBKEY_LIST *));
#line 602
    sublists = (REGFI_SUBKEY_LIST **)tmp;
#line 604
    i = (uint32_t )0;
    }
    {
#line 604
    while (1) {
      while_continue: /* CIL Label */ ;
#line 604
      if (! (i < num_sublists)) {
#line 604
        goto while_break;
      }
      {
#line 606
      off = (ret_val->elements + i)->offset + 4096U;
#line 608
      sublist_maxsize = regfi_calc_maxsize(file, off);
      }
#line 609
      if (sublist_maxsize < 0) {
#line 610
        *(sublists + i) = (REGFI_SUBKEY_LIST *)((void *)0);
      } else {
        {
#line 612
        *(sublists + i) = regfi_load_subkeylist_aux(file, off, (uint32_t )sublist_maxsize,
                                                    strict, (uint8_t )((int )depth_left - 1));
        }
      }
#line 604
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 615
    talloc_free((void *)ret_val);
#line 617
    tmp___0 = regfi_merge_subkeylists((uint16_t )num_sublists, sublists, strict);
    }
#line 617
    return (tmp___0);
  }
#line 620
  return (ret_val);
}
}
#line 626 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
REGFI_SUBKEY_LIST *regfi_parse_subkeylist(REGFI_FILE *file , uint32_t offset , uint32_t max_size ,
                                          _Bool strict ) 
{ 
  REGFI_SUBKEY_LIST *ret_val ;
  uint32_t i ;
  uint32_t cell_length ;
  uint32_t length ;
  uint32_t elem_size ;
  uint32_t read_len ;
  uint8_t *elements ;
  uint8_t buf[4] ;
  _Bool unalloc ;
  _Bool recursive_type ;
  _Bool tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  uint32_t tmp___3 ;

  {
  {
#line 631
  elements = (uint8_t *)((void *)0);
#line 636
  tmp = regfi_parse_cell(file->fd, offset, buf, (uint32_t )4, & cell_length, & unalloc);
  }
#line 636
  if (! tmp) {
    {
#line 639
    regfi_add_message(file, (uint16_t )4, "Could not parse cell while parsing subkey-list at offset 0x%.8X.",
                      offset);
    }
#line 641
    return ((REGFI_SUBKEY_LIST *)((void *)0));
  }
#line 644
  if (cell_length > max_size) {
    {
#line 646
    regfi_add_message(file, (uint16_t )4, "Cell size longer than max_size while parsing subkey-list at offset 0x%.8X.",
                      offset);
    }
#line 648
    if (strict) {
#line 649
      return ((REGFI_SUBKEY_LIST *)((void *)0));
    }
#line 650
    cell_length = max_size & 4294967288U;
  }
#line 653
  recursive_type = (_Bool)0;
#line 654
  if ((int )buf[0] == 114) {
#line 654
    if ((int )buf[1] == 105) {
#line 656
      recursive_type = (_Bool)1;
#line 657
      elem_size = (uint32_t )sizeof(uint32_t );
    } else {
#line 654
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 659
  if ((int )buf[0] == 108) {
#line 659
    if ((int )buf[1] == 105) {
#line 660
      elem_size = (uint32_t )sizeof(uint32_t );
    } else {
#line 659
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 661
  if ((int )buf[0] == 108) {
#line 661
    if ((int )buf[1] == 102) {
#line 662
      elem_size = (uint32_t )sizeof(REGFI_SUBKEY_LIST_ELEM );
    } else
#line 661
    if ((int )buf[1] == 104) {
#line 662
      elem_size = (uint32_t )sizeof(REGFI_SUBKEY_LIST_ELEM );
    } else {
      {
#line 665
      regfi_add_message(file, (uint16_t )16, "Unknown magic number (0x%.2X, 0x%.2X) encountered while parsing subkey-list at offset 0x%.8X.",
                        (int )buf[0], (int )buf[1], offset);
      }
#line 668
      return ((REGFI_SUBKEY_LIST *)((void *)0));
    }
  } else {
    {
#line 665
    regfi_add_message(file, (uint16_t )16, "Unknown magic number (0x%.2X, 0x%.2X) encountered while parsing subkey-list at offset 0x%.8X.",
                      (int )buf[0], (int )buf[1], offset);
    }
#line 668
    return ((REGFI_SUBKEY_LIST *)((void *)0));
  }
  {
#line 671
  tmp___0 = talloc_named_const((void const   *)((void *)0), sizeof(REGFI_SUBKEY_LIST ),
                               "REGFI_SUBKEY_LIST");
#line 671
  ret_val = (REGFI_SUBKEY_LIST *)tmp___0;
  }
#line 672
  if ((unsigned long )ret_val == (unsigned long )((void *)0)) {
#line 673
    return ((REGFI_SUBKEY_LIST *)((void *)0));
  }
#line 675
  ret_val->offset = offset;
#line 676
  ret_val->cell_size = cell_length;
#line 677
  ret_val->magic[0] = buf[0];
#line 678
  ret_val->magic[1] = buf[1];
#line 679
  ret_val->recursive_type = recursive_type;
#line 680
  ret_val->num_children = (unsigned int )*((unsigned char const   *)(buf) + 2) | ((unsigned int )*((unsigned char const   *)(buf) + 3) << 8);
#line 682
  if (! recursive_type) {
#line 683
    ret_val->num_keys = ret_val->num_children;
  }
#line 685
  length = elem_size * ret_val->num_children;
#line 686
  if ((unsigned long )(cell_length - 4U) - sizeof(uint32_t ) < (unsigned long )length) {
    {
#line 688
    regfi_add_message(file, (uint16_t )4, "Number of elements too large for cell while parsing subkey-list at offset 0x%.8X.",
                      offset);
    }
#line 691
    if (strict) {
#line 692
      goto fail;
    }
#line 693
    length = (uint32_t )((unsigned long )(cell_length - 4U) - sizeof(uint32_t ));
  }
  {
#line 696
  tmp___1 = _talloc_array((void const   *)ret_val, sizeof(REGFI_SUBKEY_LIST_ELEM ),
                          ret_val->num_children, "REGFI_SUBKEY_LIST_ELEM");
#line 696
  ret_val->elements = (REGFI_SUBKEY_LIST_ELEM *)tmp___1;
  }
#line 698
  if ((unsigned long )ret_val->elements == (unsigned long )((void *)0)) {
#line 699
    goto fail;
  }
  {
#line 701
  tmp___2 = malloc((size_t )length);
#line 701
  elements = (uint8_t *)tmp___2;
  }
#line 702
  if ((unsigned long )elements == (unsigned long )((void *)0)) {
#line 703
    goto fail;
  }
  {
#line 705
  read_len = length;
#line 706
  tmp___3 = regfi_read(file->fd, elements, & read_len);
  }
#line 706
  if (tmp___3 != 0U) {
#line 707
    goto fail;
  } else
#line 706
  if (read_len != length) {
#line 707
    goto fail;
  }
#line 709
  if ((unsigned long )elem_size == sizeof(uint32_t )) {
#line 711
    i = (uint32_t )0;
    {
#line 711
    while (1) {
      while_continue: /* CIL Label */ ;
#line 711
      if (! (i < ret_val->num_children)) {
#line 711
        goto while_break;
      }
#line 713
      (ret_val->elements + i)->offset = ((unsigned int )*((unsigned char const   *)elements + i * elem_size) | ((unsigned int )*((unsigned char const   *)elements + (i * elem_size + 1U)) << 8)) | (((unsigned int )*((unsigned char const   *)elements + (i * elem_size + 2U)) | ((unsigned int )*((unsigned char const   *)elements + ((i * elem_size + 2U) + 1U)) << 8)) << 16);
#line 714
      (ret_val->elements + i)->hash = (uint32_t )0;
#line 711
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 719
    i = (uint32_t )0;
    {
#line 719
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 719
      if (! (i < ret_val->num_children)) {
#line 719
        goto while_break___0;
      }
#line 721
      (ret_val->elements + i)->offset = ((unsigned int )*((unsigned char const   *)elements + i * elem_size) | ((unsigned int )*((unsigned char const   *)elements + (i * elem_size + 1U)) << 8)) | (((unsigned int )*((unsigned char const   *)elements + (i * elem_size + 2U)) | ((unsigned int )*((unsigned char const   *)elements + ((i * elem_size + 2U) + 1U)) << 8)) << 16);
#line 722
      (ret_val->elements + i)->hash = ((unsigned int )*((unsigned char const   *)elements + (i * elem_size + 4U)) | ((unsigned int )*((unsigned char const   *)elements + ((i * elem_size + 4U) + 1U)) << 8)) | (((unsigned int )*((unsigned char const   *)elements + ((i * elem_size + 4U) + 2U)) | ((unsigned int )*((unsigned char const   *)elements + (((i * elem_size + 4U) + 2U) + 1U)) << 8)) << 16);
#line 719
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 725
  free((void *)elements);
  }
#line 727
  return (ret_val);
  fail: 
#line 730
  if ((unsigned long )elements != (unsigned long )((void *)0)) {
    {
#line 731
    free((void *)elements);
    }
  }
  {
#line 732
  talloc_free((void *)ret_val);
  }
#line 733
  return ((REGFI_SUBKEY_LIST *)((void *)0));
}
}
#line 739 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
REGFI_SUBKEY_LIST *regfi_merge_subkeylists(uint16_t num_lists , REGFI_SUBKEY_LIST **lists ,
                                           _Bool strict ) 
{ 
  uint32_t i ;
  uint32_t j ;
  uint32_t k ;
  REGFI_SUBKEY_LIST *ret_val ;
  void *tmp ;
  void *tmp___0 ;
  uint32_t tmp___1 ;

  {
#line 746
  if ((unsigned long )lists == (unsigned long )((void *)0)) {
#line 747
    return ((REGFI_SUBKEY_LIST *)((void *)0));
  }
  {
#line 748
  tmp = talloc_named_const((void const   *)((void *)0), sizeof(REGFI_SUBKEY_LIST ),
                           "REGFI_SUBKEY_LIST");
#line 748
  ret_val = (REGFI_SUBKEY_LIST *)tmp;
  }
#line 750
  if ((unsigned long )ret_val == (unsigned long )((void *)0)) {
#line 751
    return ((REGFI_SUBKEY_LIST *)((void *)0));
  }
#line 754
  ret_val->num_keys = (uint32_t )0;
#line 755
  i = (uint32_t )0;
  {
#line 755
  while (1) {
    while_continue: /* CIL Label */ ;
#line 755
    if (! (i < (uint32_t )num_lists)) {
#line 755
      goto while_break;
    }
#line 757
    if ((unsigned long )*(lists + i) != (unsigned long )((void *)0)) {
#line 758
      ret_val->num_keys += (*(lists + i))->num_children;
    }
#line 755
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 760
  ret_val->num_children = ret_val->num_keys;
#line 762
  if (ret_val->num_keys > 0U) {
    {
#line 764
    tmp___0 = _talloc_array((void const   *)ret_val, sizeof(REGFI_SUBKEY_LIST_ELEM ),
                            ret_val->num_keys, "REGFI_SUBKEY_LIST_ELEM");
#line 764
    ret_val->elements = (REGFI_SUBKEY_LIST_ELEM *)tmp___0;
#line 766
    k = (uint32_t )0;
    }
#line 768
    if ((unsigned long )ret_val->elements != (unsigned long )((void *)0)) {
#line 770
      i = (uint32_t )0;
      {
#line 770
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 770
        if (! (i < (uint32_t )num_lists)) {
#line 770
          goto while_break___0;
        }
#line 772
        if ((unsigned long )*(lists + i) != (unsigned long )((void *)0)) {
#line 774
          j = (uint32_t )0;
          {
#line 774
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 774
            if (! (j < (*(lists + i))->num_keys)) {
#line 774
              goto while_break___1;
            }
#line 776
            (ret_val->elements + k)->hash = ((*(lists + i))->elements + j)->hash;
#line 777
            tmp___1 = k;
#line 777
            k ++;
#line 777
            (ret_val->elements + tmp___1)->offset = ((*(lists + i))->elements + j)->offset;
#line 774
            j ++;
          }
          while_break___1: /* CIL Label */ ;
          }
        }
#line 770
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
#line 784
  i = (uint32_t )0;
  {
#line 784
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 784
    if (! (i < (uint32_t )num_lists)) {
#line 784
      goto while_break___2;
    }
    {
#line 785
    regfi_subkeylist_free(*(lists + i));
#line 784
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 786
  free((void *)lists);
  }
#line 788
  return (ret_val);
}
}
#line 795 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
REGFI_SK_REC *regfi_parse_sk(REGFI_FILE *file , uint32_t offset , uint32_t max_size ,
                             _Bool strict ) 
{ 
  REGFI_SK_REC *ret_val ;
  uint8_t *sec_desc_buf ;
  uint32_t cell_length ;
  uint32_t length ;
  uint8_t sk_header[20] ;
  _Bool unalloc ;
  _Bool tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  uint32_t tmp___2 ;
  WINSEC_DESC *tmp___3 ;

  {
  {
#line 799
  sec_desc_buf = (uint8_t *)((void *)0);
#line 802
  unalloc = (_Bool)0;
#line 804
  tmp = regfi_parse_cell(file->fd, offset, sk_header, (uint32_t )20, & cell_length,
                         & unalloc);
  }
#line 804
  if (! tmp) {
    {
#line 807
    regfi_add_message(file, (uint16_t )4, "Could not parse SK record cell at offset 0x%.8X.",
                      offset);
    }
#line 809
    return ((REGFI_SK_REC *)((void *)0));
  }
#line 812
  if ((int )sk_header[0] != 115) {
    {
#line 814
    regfi_add_message(file, (uint16_t )4, "Magic number mismatch in parsing SK record at offset 0x%.8X.",
                      offset);
    }
#line 816
    return ((REGFI_SK_REC *)((void *)0));
  } else
#line 812
  if ((int )sk_header[1] != 107) {
    {
#line 814
    regfi_add_message(file, (uint16_t )4, "Magic number mismatch in parsing SK record at offset 0x%.8X.",
                      offset);
    }
#line 816
    return ((REGFI_SK_REC *)((void *)0));
  }
  {
#line 819
  tmp___0 = talloc_named_const((void const   *)((void *)0), sizeof(REGFI_SK_REC ),
                               "REGFI_SK_REC");
#line 819
  ret_val = (REGFI_SK_REC *)tmp___0;
  }
#line 820
  if ((unsigned long )ret_val == (unsigned long )((void *)0)) {
#line 821
    return ((REGFI_SK_REC *)((void *)0));
  }
#line 823
  ret_val->offset = offset;
#line 827
  ret_val->cell_size = cell_length;
#line 829
  if (ret_val->cell_size > max_size) {
#line 830
    ret_val->cell_size = max_size & 4294967288U;
  }
#line 831
  if (ret_val->cell_size < 20U) {
    {
#line 834
    regfi_add_message(file, (uint16_t )4, "Invalid cell size found while parsing SK record at offset 0x%.8X.",
                      offset);
    }
#line 836
    goto fail;
  } else
#line 831
  if (strict) {
#line 831
    if ((ret_val->cell_size & 7U) != 0U) {
      {
#line 834
      regfi_add_message(file, (uint16_t )4, "Invalid cell size found while parsing SK record at offset 0x%.8X.",
                        offset);
      }
#line 836
      goto fail;
    }
  }
#line 839
  ret_val->magic[0] = sk_header[0];
#line 840
  ret_val->magic[1] = sk_header[1];
#line 842
  ret_val->unknown_tag = (uint16_t )((unsigned int )*((unsigned char const   *)(sk_header) + 2) | ((unsigned int )*((unsigned char const   *)(sk_header) + 3) << 8));
#line 843
  ret_val->prev_sk_off = ((unsigned int )*((unsigned char const   *)(sk_header) + 4) | ((unsigned int )*((unsigned char const   *)(sk_header) + 5) << 8)) | (((unsigned int )*((unsigned char const   *)(sk_header) + 6) | ((unsigned int )*((unsigned char const   *)(sk_header) + 7) << 8)) << 16);
#line 844
  ret_val->next_sk_off = ((unsigned int )*((unsigned char const   *)(sk_header) + 8) | ((unsigned int )*((unsigned char const   *)(sk_header) + 9) << 8)) | (((unsigned int )*((unsigned char const   *)(sk_header) + 10) | ((unsigned int )*((unsigned char const   *)(sk_header) + 11) << 8)) << 16);
#line 845
  ret_val->ref_count = ((unsigned int )*((unsigned char const   *)(sk_header) + 12) | ((unsigned int )*((unsigned char const   *)(sk_header) + 13) << 8)) | (((unsigned int )*((unsigned char const   *)(sk_header) + 14) | ((unsigned int )*((unsigned char const   *)(sk_header) + 15) << 8)) << 16);
#line 846
  ret_val->desc_size = ((unsigned int )*((unsigned char const   *)(sk_header) + 16) | ((unsigned int )*((unsigned char const   *)(sk_header) + 17) << 8)) | (((unsigned int )*((unsigned char const   *)(sk_header) + 18) | ((unsigned int )*((unsigned char const   *)(sk_header) + 19) << 8)) << 16);
#line 848
  if ((ret_val->prev_sk_off & 7U) != 0U) {
    {
#line 851
    regfi_add_message(file, (uint16_t )4, "SK record\'s next/previous offsets are not a multiple of 8 while parsing SK record at offset 0x%.8X.",
                      offset);
    }
#line 854
    goto fail;
  } else
#line 848
  if ((ret_val->next_sk_off & 7U) != 0U) {
    {
#line 851
    regfi_add_message(file, (uint16_t )4, "SK record\'s next/previous offsets are not a multiple of 8 while parsing SK record at offset 0x%.8X.",
                      offset);
    }
#line 854
    goto fail;
  }
#line 857
  if (ret_val->desc_size + 20U > ret_val->cell_size) {
    {
#line 859
    regfi_add_message(file, (uint16_t )4, "Security descriptor too large for cell while parsing SK record at offset 0x%.8X.",
                      offset);
    }
#line 862
    goto fail;
  }
  {
#line 865
  tmp___1 = malloc((size_t )ret_val->desc_size);
#line 865
  sec_desc_buf = (uint8_t *)tmp___1;
  }
#line 866
  if ((unsigned long )sec_desc_buf == (unsigned long )((void *)0)) {
#line 867
    goto fail;
  }
  {
#line 869
  length = ret_val->desc_size;
#line 870
  tmp___2 = regfi_read(file->fd, sec_desc_buf, & length);
  }
#line 870
  if (tmp___2 != 0U) {
    {
#line 873
    regfi_add_message(file, (uint16_t )16, "Failed to read security descriptor while parsing SK record at offset 0x%.8X.",
                      offset);
    }
#line 876
    goto fail;
  } else
#line 870
  if (length != ret_val->desc_size) {
    {
#line 873
    regfi_add_message(file, (uint16_t )16, "Failed to read security descriptor while parsing SK record at offset 0x%.8X.",
                      offset);
    }
#line 876
    goto fail;
  }
  {
#line 879
  tmp___3 = winsec_parse_desc((void *)ret_val, (uint8_t const   *)sec_desc_buf, ret_val->desc_size);
#line 879
  ret_val->sec_desc = tmp___3;
  }
#line 879
  if (! tmp___3) {
    {
#line 882
    regfi_add_message(file, (uint16_t )16, "Failed to parse security descriptor while parsing SK record at offset 0x%.8X.",
                      offset);
    }
#line 885
    goto fail;
  }
  {
#line 888
  free((void *)sec_desc_buf);
  }
#line 889
  return (ret_val);
  fail: 
#line 892
  if ((unsigned long )sec_desc_buf != (unsigned long )((void *)0)) {
    {
#line 893
    free((void *)sec_desc_buf);
    }
  }
  {
#line 894
  talloc_free((void *)ret_val);
  }
#line 895
  return ((REGFI_SK_REC *)((void *)0));
}
}
#line 899 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
REGFI_VALUE_LIST *regfi_parse_valuelist(REGFI_FILE *file , uint32_t offset , uint32_t num_values ,
                                        _Bool strict ) 
{ 
  REGFI_VALUE_LIST *ret_val ;
  uint32_t i ;
  uint32_t cell_length ;
  uint32_t length ;
  uint32_t read_len ;
  _Bool unalloc ;
  _Bool tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  uint32_t tmp___2 ;

  {
  {
#line 906
  tmp = regfi_parse_cell(file->fd, offset, (uint8_t *)((void *)0), (uint32_t )0, & cell_length,
                         & unalloc);
  }
#line 906
  if (! tmp) {
    {
#line 908
    regfi_add_message(file, (uint16_t )16, "Failed to read cell header while parsing value list at offset 0x%.8X.",
                      offset);
    }
#line 910
    return ((REGFI_VALUE_LIST *)((void *)0));
  }
#line 913
  if ((cell_length & 7U) != 0U) {
    {
#line 915
    regfi_add_message(file, (uint16_t )4, "Cell length not a multiple of 8 while parsing value list at offset 0x%.8X.",
                      offset);
    }
#line 917
    if (strict) {
#line 918
      return ((REGFI_VALUE_LIST *)((void *)0));
    }
#line 919
    cell_length &= 4294967288U;
  }
#line 922
  if ((unsigned long )num_values * sizeof(uint32_t ) > (unsigned long )cell_length - sizeof(uint32_t )) {
    {
#line 924
    regfi_add_message(file, (uint16_t )4, "Too many values found while parsing value list at offset 0x%.8X.",
                      offset);
    }
#line 926
    if (strict) {
#line 927
      return ((REGFI_VALUE_LIST *)((void *)0));
    }
#line 928
    num_values = (uint32_t )((unsigned long )cell_length / sizeof(uint32_t ) - sizeof(uint32_t ));
  }
  {
#line 931
  read_len = (uint32_t )((unsigned long )num_values * sizeof(uint32_t ));
#line 932
  tmp___0 = talloc_named_const((void const   *)((void *)0), sizeof(REGFI_VALUE_LIST ),
                               "REGFI_VALUE_LIST");
#line 932
  ret_val = (REGFI_VALUE_LIST *)tmp___0;
  }
#line 933
  if ((unsigned long )ret_val == (unsigned long )((void *)0)) {
#line 934
    return ((REGFI_VALUE_LIST *)((void *)0));
  }
  {
#line 936
  tmp___1 = talloc_named_const((void const   *)ret_val, (size_t )read_len, "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c:936");
#line 936
  ret_val->elements = (REGFI_VALUE_LIST_ELEM *)tmp___1;
  }
#line 937
  if ((unsigned long )ret_val->elements == (unsigned long )((void *)0)) {
    {
#line 939
    talloc_free((void *)ret_val);
    }
#line 940
    return ((REGFI_VALUE_LIST *)((void *)0));
  }
  {
#line 942
  ret_val->num_values = num_values;
#line 944
  length = read_len;
#line 945
  tmp___2 = regfi_read(file->fd, (uint8_t *)ret_val->elements, & length);
  }
#line 945
  if (tmp___2 != 0U) {
    {
#line 948
    regfi_add_message(file, (uint16_t )16, "Failed to read value pointers while parsing value list at offset 0x%.8X.",
                      offset);
#line 950
    talloc_free((void *)ret_val);
    }
#line 951
    return ((REGFI_VALUE_LIST *)((void *)0));
  } else
#line 945
  if (length != read_len) {
    {
#line 948
    regfi_add_message(file, (uint16_t )16, "Failed to read value pointers while parsing value list at offset 0x%.8X.",
                      offset);
#line 950
    talloc_free((void *)ret_val);
    }
#line 951
    return ((REGFI_VALUE_LIST *)((void *)0));
  }
#line 954
  i = (uint32_t )0;
  {
#line 954
  while (1) {
    while_continue: /* CIL Label */ ;
#line 954
    if (! (i < num_values)) {
#line 954
      goto while_break;
    }
#line 957
    *(ret_val->elements + i) = ((unsigned int )*((unsigned char const   *)(ret_val->elements + i) + 0) | ((unsigned int )*((unsigned char const   *)(ret_val->elements + i) + 1) << 8)) | (((unsigned int )*((unsigned char const   *)(ret_val->elements + i) + 2) | ((unsigned int )*((unsigned char const   *)(ret_val->elements + i) + 3) << 8)) << 16);
#line 960
    if (strict) {
#line 964
      if (*(ret_val->elements + i) + 4096U > file->file_length) {
        {
#line 967
        regfi_add_message(file, (uint16_t )4, "Invalid value pointer (0x%.8X) found while parsing value list at offset 0x%.8X.",
                          *(ret_val->elements + i), offset);
#line 970
        talloc_free((void *)ret_val);
        }
#line 971
        return ((REGFI_VALUE_LIST *)((void *)0));
      } else
#line 964
      if ((*(ret_val->elements + i) & 7U) != 0U) {
        {
#line 967
        regfi_add_message(file, (uint16_t )4, "Invalid value pointer (0x%.8X) found while parsing value list at offset 0x%.8X.",
                          *(ret_val->elements + i), offset);
#line 970
        talloc_free((void *)ret_val);
        }
#line 971
        return ((REGFI_VALUE_LIST *)((void *)0));
      }
    }
#line 954
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 976
  return (ret_val);
}
}
#line 980 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
void regfi_interpret_valuename(REGFI_FILE *file , REGFI_VK_REC *vk , REGFI_ENCODING output_encoding ,
                               _Bool strict ) 
{ 
  int32_t tmp_size ;
  REGFI_ENCODING from_encoding ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char *tmp___4 ;
  char const   *tmp___5 ;

  {
#line 992
  if ((int )vk->flags & 1) {
#line 992
    tmp = 0;
  } else {
#line 992
    tmp = 2;
  }
#line 992
  from_encoding = (REGFI_ENCODING )tmp;
#line 995
  if ((int )from_encoding == (int )output_encoding) {
    {
#line 997
    tmp___0 = _talloc_realloc_array((void const   *)vk, (void *)vk->valuename_raw,
                                    sizeof(uint8_t ), (unsigned int )((int )vk->name_length + 1),
                                    "uint8_t");
#line 997
    vk->valuename_raw = (uint8_t *)tmp___0;
#line 999
    *(vk->valuename_raw + vk->name_length) = (uint8_t )'\000';
#line 1000
    vk->valuename = (char *)vk->valuename_raw;
    }
  } else {
    {
#line 1004
    tmp___1 = _talloc_array((void const   *)vk, sizeof(char ), (unsigned int )((int )vk->name_length + 1),
                            "char");
#line 1004
    vk->valuename = (char *)tmp___1;
    }
#line 1005
    if ((unsigned long )vk->valuename == (unsigned long )((void *)0)) {
      {
#line 1007
      regfi_free_value(vk);
      }
#line 1008
      return;
    }
    {
#line 1011
    tmp___2 = regfi_encoding_int2str(output_encoding);
#line 1011
    tmp___3 = regfi_encoding_int2str(from_encoding);
#line 1011
    tmp_size = regfi_conv_charset(tmp___3, tmp___2, vk->valuename_raw, vk->valuename,
                                  (uint32_t )vk->name_length, (uint32_t )((int )vk->name_length + 1));
    }
#line 1015
    if (tmp_size < 0) {
      {
#line 1017
      tmp___4 = strerror(- tmp_size);
#line 1017
      tmp___5 = regfi_encoding_int2str(output_encoding);
#line 1017
      regfi_add_message(file, (uint16_t )4, "Error occurred while converting valuename to encoding %s.  Error message: %s",
                        tmp___5, tmp___4);
#line 1021
      talloc_free((void *)vk->valuename);
#line 1022
      vk->valuename = (char *)((void *)0);
      }
    }
  }
#line 1025
  return;
}
}
#line 1030 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
REGFI_VK_REC *regfi_load_value(REGFI_FILE *file , uint32_t offset , REGFI_ENCODING output_encoding ,
                               _Bool strict ) 
{ 
  REGFI_VK_REC *ret_val ;
  int32_t max_size ;

  {
  {
#line 1033
  ret_val = (REGFI_VK_REC *)((void *)0);
#line 1036
  max_size = regfi_calc_maxsize(file, offset);
  }
#line 1037
  if (max_size < 0) {
#line 1038
    return ((REGFI_VK_REC *)((void *)0));
  }
  {
#line 1040
  ret_val = regfi_parse_vk(file, offset, (uint32_t )max_size, strict);
  }
#line 1041
  if ((unsigned long )ret_val == (unsigned long )((void *)0)) {
#line 1042
    return ((REGFI_VK_REC *)((void *)0));
  }
  {
#line 1044
  regfi_interpret_valuename(file, ret_val, output_encoding, strict);
  }
#line 1046
  return (ret_val);
}
}
#line 1053 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
REGFI_VALUE_LIST *regfi_load_valuelist(REGFI_FILE *file , uint32_t offset , uint32_t num_values ,
                                       uint32_t max_size , _Bool strict ) 
{ 
  uint32_t usable_num_values ;
  REGFI_VALUE_LIST *tmp ;

  {
#line 1059
  if ((unsigned long )(num_values + 1U) * sizeof(uint32_t ) > (unsigned long )max_size) {
    {
#line 1061
    regfi_add_message(file, (uint16_t )4, "Number of values indicated by parent key (%d) would cause cell to straddle HBIN boundary while loading value list at offset 0x%.8X.",
                      num_values, offset);
    }
#line 1065
    if (strict) {
#line 1066
      return ((REGFI_VALUE_LIST *)((void *)0));
    }
#line 1067
    usable_num_values = (uint32_t )((unsigned long )max_size / sizeof(uint32_t ) - sizeof(uint32_t ));
  } else {
#line 1070
    usable_num_values = num_values;
  }
  {
#line 1072
  tmp = regfi_parse_valuelist(file, offset, usable_num_values, strict);
  }
#line 1072
  return (tmp);
}
}
#line 1076 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
void regfi_interpret_keyname(REGFI_FILE *file , REGFI_NK_REC *nk , REGFI_ENCODING output_encoding ,
                             _Bool strict ) 
{ 
  int32_t tmp_size ;
  REGFI_ENCODING from_encoding ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char *tmp___4 ;
  char const   *tmp___5 ;

  {
#line 1087
  if ((int )nk->flags & 32) {
#line 1087
    tmp = 0;
  } else {
#line 1087
    tmp = 2;
  }
#line 1087
  from_encoding = (REGFI_ENCODING )tmp;
#line 1090
  if ((int )from_encoding == (int )output_encoding) {
    {
#line 1092
    tmp___0 = _talloc_realloc_array((void const   *)nk, (void *)nk->keyname_raw, sizeof(uint8_t ),
                                    (unsigned int )((int )nk->name_length + 1), "uint8_t");
#line 1092
    nk->keyname_raw = (uint8_t *)tmp___0;
#line 1093
    *(nk->keyname_raw + nk->name_length) = (uint8_t )'\000';
#line 1094
    nk->keyname = (char *)nk->keyname_raw;
    }
  } else {
    {
#line 1098
    tmp___1 = _talloc_array((void const   *)nk, sizeof(char ), (unsigned int )((int )nk->name_length + 1),
                            "char");
#line 1098
    nk->keyname = (char *)tmp___1;
    }
#line 1099
    if ((unsigned long )nk->keyname == (unsigned long )((void *)0)) {
      {
#line 1101
      regfi_free_key(nk);
      }
#line 1102
      return;
    }
    {
#line 1105
    tmp___2 = regfi_encoding_int2str(output_encoding);
#line 1105
    tmp___3 = regfi_encoding_int2str(from_encoding);
#line 1105
    tmp_size = regfi_conv_charset(tmp___3, tmp___2, nk->keyname_raw, nk->keyname,
                                  (uint32_t )nk->name_length, (uint32_t )((int )nk->name_length + 1));
    }
#line 1109
    if (tmp_size < 0) {
      {
#line 1111
      tmp___4 = strerror(- tmp_size);
#line 1111
      tmp___5 = regfi_encoding_int2str(output_encoding);
#line 1111
      regfi_add_message(file, (uint16_t )4, "Error occurred while converting keyname to encoding %s.  Error message: %s",
                        tmp___5, tmp___4);
#line 1115
      talloc_free((void *)nk->keyname);
#line 1116
      nk->keyname = (char *)((void *)0);
      }
    }
  }
#line 1119
  return;
}
}
#line 1125 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
REGFI_NK_REC *regfi_load_key(REGFI_FILE *file , uint32_t offset , REGFI_ENCODING output_encoding ,
                             _Bool strict ) 
{ 
  REGFI_NK_REC *nk ;
  uint32_t off ;
  int32_t max_size ;

  {
  {
#line 1132
  max_size = regfi_calc_maxsize(file, offset);
  }
#line 1133
  if (max_size < 0) {
#line 1134
    return ((REGFI_NK_REC *)((void *)0));
  }
  {
#line 1137
  nk = regfi_parse_nk(file, offset, (uint32_t )max_size, (_Bool)1);
  }
#line 1137
  if ((unsigned long )nk == (unsigned long )((void *)0)) {
    {
#line 1139
    regfi_add_message(file, (uint16_t )16, "Could not load NK record at offset 0x%.8X.",
                      offset);
    }
#line 1141
    return ((REGFI_NK_REC *)((void *)0));
  }
  {
#line 1144
  regfi_interpret_keyname(file, nk, output_encoding, strict);
  }
#line 1147
  if (nk->num_values) {
#line 1147
    if (nk->values_off != 4294967295U) {
      {
#line 1149
      off = nk->values_off + 4096U;
#line 1150
      max_size = regfi_calc_maxsize(file, off);
      }
#line 1151
      if (max_size < 0) {
#line 1153
        if (strict) {
          {
#line 1155
          regfi_free_key(nk);
          }
#line 1156
          return ((REGFI_NK_REC *)((void *)0));
        } else {
#line 1159
          nk->values = (REGFI_VALUE_LIST *)((void *)0);
        }
      } else {
        {
#line 1164
        nk->values = regfi_load_valuelist(file, off, nk->num_values, (uint32_t )max_size,
                                          (_Bool)1);
        }
#line 1166
        if ((unsigned long )nk->values == (unsigned long )((void *)0)) {
          {
#line 1168
          regfi_add_message(file, (uint16_t )4, "Could not load value list for NK record at offset 0x%.8X.",
                            offset);
          }
#line 1170
          if (strict) {
            {
#line 1172
            regfi_free_key(nk);
            }
#line 1173
            return ((REGFI_NK_REC *)((void *)0));
          }
        }
        {
#line 1176
        _talloc_steal((void const   *)nk, (void const   *)nk->values);
        }
      }
    }
  }
#line 1181
  if (nk->num_subkeys) {
#line 1181
    if (nk->subkeys_off != 4294967295U) {
      {
#line 1183
      off = nk->subkeys_off + 4096U;
#line 1184
      max_size = regfi_calc_maxsize(file, off);
      }
#line 1185
      if (max_size < 0) {
#line 1187
        if (strict) {
          {
#line 1189
          regfi_free_key(nk);
          }
#line 1190
          return ((REGFI_NK_REC *)((void *)0));
        } else {
#line 1193
          nk->subkeys = (REGFI_SUBKEY_LIST *)((void *)0);
        }
      } else {
        {
#line 1197
        nk->subkeys = regfi_load_subkeylist(file, off, nk->num_subkeys, (uint32_t )max_size,
                                            (_Bool)1);
        }
#line 1200
        if ((unsigned long )nk->subkeys == (unsigned long )((void *)0)) {
          {
#line 1202
          regfi_add_message(file, (uint16_t )4, "Could not load subkey list while parsing NK record at offset 0x%.8X.",
                            offset);
#line 1204
          nk->num_subkeys = (uint32_t )0;
          }
        }
        {
#line 1206
        _talloc_steal((void const   *)nk, (void const   *)nk->subkeys);
        }
      }
    }
  }
#line 1210
  return (nk);
}
}
#line 1216 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
REGFI_SK_REC const   *regfi_load_sk(REGFI_FILE *file , uint32_t offset , _Bool strict ) 
{ 
  REGFI_SK_REC *ret_val ;
  int32_t max_size ;
  void *failure_ptr ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 1218
  ret_val = (REGFI_SK_REC *)((void *)0);
#line 1220
  failure_ptr = (void *)0;
#line 1223
  tmp = lru_cache_find(file->sk_cache, (void const   *)(& offset), (uint32_t )4);
#line 1223
  ret_val = (REGFI_SK_REC *)tmp;
  }
#line 1226
  if ((unsigned long )ret_val == (unsigned long )((void *)4294967295U)) {
#line 1227
    return ((REGFI_SK_REC const   *)((void *)0));
  }
#line 1229
  if ((unsigned long )ret_val == (unsigned long )((void *)0)) {
    {
#line 1231
    max_size = regfi_calc_maxsize(file, offset);
    }
#line 1232
    if (max_size < 0) {
#line 1233
      return ((REGFI_SK_REC const   *)((void *)0));
    }
    {
#line 1235
    ret_val = regfi_parse_sk(file, offset, (uint32_t )max_size, strict);
    }
#line 1236
    if ((unsigned long )ret_val == (unsigned long )((void *)0)) {
      {
#line 1238
      tmp___0 = talloc_named_const((void const   *)((void *)0), sizeof(uint32_t ),
                                   "uint32_t");
#line 1238
      failure_ptr = (void *)((uint32_t *)tmp___0);
      }
#line 1239
      if ((unsigned long )failure_ptr == (unsigned long )((void *)0)) {
#line 1240
        return ((REGFI_SK_REC const   *)((void *)0));
      }
      {
#line 1241
      *((uint32_t *)failure_ptr) = 4294967295U;
#line 1242
      lru_cache_update(file->sk_cache, (void const   *)(& offset), (uint32_t )4, failure_ptr);
      }
#line 1243
      return ((REGFI_SK_REC const   *)((void *)0));
    }
    {
#line 1246
    lru_cache_update(file->sk_cache, (void const   *)(& offset), (uint32_t )4, (void *)ret_val);
    }
  }
#line 1249
  return ((REGFI_SK_REC const   *)ret_val);
}
}
#line 1256 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
REGFI_NK_REC *regfi_find_root_nk(REGFI_FILE *file , REGFI_HBIN const   *hbin , REGFI_ENCODING output_encoding ) 
{ 
  REGFI_NK_REC *nk ;
  uint32_t cell_length ;
  uint32_t cur_offset ;
  uint32_t hbin_end ;
  _Bool unalloc ;
  _Bool tmp ;

  {
#line 1259
  nk = (REGFI_NK_REC *)((void *)0);
#line 1261
  cur_offset = (uint32_t )(hbin->file_off + 32U);
#line 1262
  hbin_end = (uint32_t )(hbin->file_off + hbin->block_size);
  {
#line 1265
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1265
    if (! (cur_offset < hbin_end)) {
#line 1265
      goto while_break;
    }
    {
#line 1267
    tmp = regfi_parse_cell(file->fd, cur_offset, (uint8_t *)((void *)0), (uint32_t )0,
                           & cell_length, & unalloc);
    }
#line 1267
    if (! tmp) {
      {
#line 1269
      regfi_add_message(file, (uint16_t )4, "Could not parse cell at offset 0x%.8X while searching for root key.",
                        cur_offset);
      }
#line 1271
      return ((REGFI_NK_REC *)((void *)0));
    }
#line 1274
    if (! unalloc) {
      {
#line 1276
      nk = regfi_load_key(file, cur_offset, output_encoding, (_Bool)1);
      }
#line 1277
      if ((unsigned long )nk != (unsigned long )((void *)0)) {
#line 1279
        if ((int )nk->flags & 4) {
#line 1280
          return (nk);
        }
      }
    }
#line 1284
    cur_offset += cell_length;
  }
  while_break: /* CIL Label */ ;
  }
#line 1287
  return ((REGFI_NK_REC *)((void *)0));
}
}
#line 1293 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
REGFI_FILE *regfi_open(char const   *filename ) 
{ 
  REGFI_FILE *ret_val ;
  int fd ;

  {
  {
#line 1299
  fd = open(filename, 0);
  }
#line 1299
  if (fd == -1) {
#line 1302
    return ((REGFI_FILE *)((void *)0));
  }
  {
#line 1305
  ret_val = regfi_alloc(fd);
  }
#line 1307
  if ((unsigned long )ret_val == (unsigned long )((void *)0)) {
    {
#line 1308
    close(fd);
    }
  }
#line 1310
  return (ret_val);
}
}
#line 1316 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
REGFI_FILE *regfi_alloc(int fd ) 
{ 
  struct stat sbuf ;
  REGFI_FILE *rb ;
  REGFI_HBIN *hbin ;
  uint32_t hbin_off ;
  uint32_t file_length ;
  uint32_t cache_secret ;
  _Bool rla ;
  int tmp ;
  time_t tmp___0 ;
  __pid_t tmp___1 ;

  {
  {
#line 1320
  hbin = (REGFI_HBIN *)((void *)0);
#line 1327
  tmp = fstat(fd, & sbuf);
  }
#line 1327
  if (tmp == -1) {
#line 1328
    return ((REGFI_FILE *)((void *)0));
  }
#line 1329
  file_length = (uint32_t )sbuf.st_size;
#line 1330
  if (file_length < 8192U) {
#line 1331
    return ((REGFI_FILE *)((void *)0));
  }
  {
#line 1334
  rb = regfi_parse_regf(fd, (_Bool)1);
  }
#line 1334
  if ((unsigned long )rb == (unsigned long )((void *)0)) {
#line 1337
    return ((REGFI_FILE *)((void *)0));
  }
  {
#line 1339
  rb->file_length = file_length;
#line 1341
  rb->hbins = range_list_new();
  }
#line 1342
  if ((unsigned long )rb->hbins == (unsigned long )((void *)0)) {
    {
#line 1345
    talloc_free((void *)rb);
    }
#line 1346
    return ((REGFI_FILE *)((void *)0));
  }
  {
#line 1348
  _talloc_steal((void const   *)rb, (void const   *)rb->hbins);
#line 1350
  rla = (_Bool)1;
#line 1351
  hbin_off = (uint32_t )4096;
#line 1352
  hbin = regfi_parse_hbin(rb, hbin_off, (_Bool)1);
  }
  {
#line 1353
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1353
    if (hbin) {
#line 1353
      if (! rla) {
#line 1353
        goto while_break;
      }
    } else {
#line 1353
      goto while_break;
    }
    {
#line 1355
    rla = range_list_add(rb->hbins, hbin->file_off, hbin->block_size, (void *)hbin);
    }
#line 1356
    if (rla) {
      {
#line 1357
      _talloc_steal((void const   *)rb->hbins, (void const   *)hbin);
      }
    }
    {
#line 1358
    hbin_off = hbin->file_off + hbin->block_size;
#line 1359
    hbin = regfi_parse_hbin(rb, hbin_off, (_Bool)1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1366
  tmp___0 = time((time_t *)((void *)0));
#line 1366
  tmp___1 = getpid();
#line 1366
  cache_secret = (uint32_t )((366914821L ^ tmp___0) ^ (long )(tmp___1 << 16));
#line 1369
  rb->sk_cache = lru_cache_create_ctx((void *)rb, (uint32_t )0, cache_secret, (_Bool)1);
#line 1372
  rb->msg_mask = (uint16_t )20;
  }
#line 1375
  return (rb);
}
}
#line 1381 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
int regfi_close(REGFI_FILE *file ) 
{ 
  int fd ;
  int tmp ;

  {
#line 1386
  if ((unsigned long )file == (unsigned long )((void *)0)) {
#line 1387
    return (0);
  } else
#line 1386
  if (file->fd == -1) {
#line 1387
    return (0);
  }
  {
#line 1389
  fd = file->fd;
#line 1390
  file->fd = -1;
#line 1392
  regfi_free(file);
#line 1394
  tmp = close(fd);
  }
#line 1394
  return (tmp);
}
}
#line 1400 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
void regfi_free(REGFI_FILE *file ) 
{ 


  {
#line 1402
  if ((unsigned long )file->last_message != (unsigned long )((void *)0)) {
    {
#line 1403
    free((void *)file->last_message);
    }
  }
  {
#line 1405
  talloc_free((void *)file);
  }
#line 1406
  return;
}
}
#line 1413 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
REGFI_NK_REC *regfi_rootkey(REGFI_FILE *file , REGFI_ENCODING output_encoding ) 
{ 
  REGFI_NK_REC *nk ;
  REGFI_HBIN *hbin ;
  uint32_t root_offset ;
  uint32_t i ;
  uint32_t num_hbins ;
  range_list_element const   *tmp ;

  {
#line 1415
  nk = (REGFI_NK_REC *)((void *)0);
#line 1419
  if (! file) {
#line 1420
    return ((REGFI_NK_REC *)((void *)0));
  }
  {
#line 1422
  root_offset = file->root_cell + 4096U;
#line 1423
  nk = regfi_load_key(file, root_offset, output_encoding, (_Bool)1);
  }
#line 1424
  if ((unsigned long )nk != (unsigned long )((void *)0)) {
#line 1426
    if ((int )nk->flags & 4) {
#line 1427
      return (nk);
    }
  }
  {
#line 1430
  regfi_add_message(file, (uint16_t )4, "File header indicated root key at location 0x%.8X, but no root key found. Searching rest of file...",
                    root_offset);
#line 1437
  num_hbins = range_list_size((range_list const   *)file->hbins);
#line 1438
  i = (uint32_t )0;
  }
  {
#line 1438
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1438
    if (i < num_hbins) {
#line 1438
      if (! ((unsigned long )nk == (unsigned long )((void *)0))) {
#line 1438
        goto while_break;
      }
    } else {
#line 1438
      goto while_break;
    }
    {
#line 1440
    tmp = range_list_get((range_list const   *)file->hbins, i);
#line 1440
    hbin = (REGFI_HBIN *)tmp->data;
#line 1441
    nk = regfi_find_root_nk(file, (REGFI_HBIN const   *)hbin, output_encoding);
#line 1438
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1444
  return (nk);
}
}
#line 1450 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
void regfi_free_key(REGFI_NK_REC *nk ) 
{ 


  {
  {
#line 1452
  regfi_subkeylist_free(nk->subkeys);
#line 1453
  talloc_free((void *)nk);
  }
#line 1454
  return;
}
}
#line 1459 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
void regfi_free_value(REGFI_VK_REC *vk ) 
{ 


  {
  {
#line 1461
  talloc_free((void *)vk);
  }
#line 1462
  return;
}
}
#line 1467 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
void regfi_subkeylist_free(REGFI_SUBKEY_LIST *list ) 
{ 


  {
#line 1469
  if ((unsigned long )list != (unsigned long )((void *)0)) {
    {
#line 1471
    talloc_free((void *)list);
    }
  }
#line 1473
  return;
}
}
#line 1478 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
REGFI_ITERATOR *regfi_iterator_new(REGFI_FILE *file , REGFI_ENCODING output_encoding ) 
{ 
  REGFI_NK_REC *root ;
  REGFI_ITERATOR *ret_val ;
  void *tmp ;

  {
#line 1484
  if ((int )output_encoding != 1) {
#line 1484
    if ((int )output_encoding != 0) {
      {
#line 1487
      regfi_add_message(file, (uint16_t )16, "Invalid output_encoding supplied in creation of regfi iterator.");
      }
#line 1489
      return ((REGFI_ITERATOR *)((void *)0));
    }
  }
  {
#line 1492
  tmp = talloc_named_const((void const   *)((void *)0), sizeof(REGFI_ITERATOR ), "REGFI_ITERATOR");
#line 1492
  ret_val = (REGFI_ITERATOR *)tmp;
  }
#line 1493
  if ((unsigned long )ret_val == (unsigned long )((void *)0)) {
#line 1494
    return ((REGFI_ITERATOR *)((void *)0));
  }
  {
#line 1496
  root = regfi_rootkey(file, output_encoding);
  }
#line 1497
  if ((unsigned long )root == (unsigned long )((void *)0)) {
    {
#line 1499
    talloc_free((void *)ret_val);
    }
#line 1500
    return ((REGFI_ITERATOR *)((void *)0));
  }
  {
#line 1503
  ret_val->key_positions = void_stack_new((unsigned short)512);
  }
#line 1504
  if ((unsigned long )ret_val->key_positions == (unsigned long )((void *)0)) {
    {
#line 1506
    talloc_free((void *)ret_val);
    }
#line 1507
    return ((REGFI_ITERATOR *)((void *)0));
  }
  {
#line 1509
  _talloc_steal((void const   *)ret_val, (void const   *)ret_val->key_positions);
#line 1511
  ret_val->f = file;
#line 1512
  ret_val->cur_key = root;
#line 1513
  ret_val->cur_subkey = (uint32_t )0;
#line 1514
  ret_val->cur_value = (uint32_t )0;
#line 1515
  ret_val->string_encoding = output_encoding;
  }
#line 1517
  return (ret_val);
}
}
#line 1523 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
void regfi_iterator_free(REGFI_ITERATOR *i ) 
{ 


  {
  {
#line 1525
  talloc_free((void *)i);
  }
#line 1526
  return;
}
}
#line 1533 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
_Bool regfi_iterator_down(REGFI_ITERATOR *i ) 
{ 
  REGFI_NK_REC *subkey ;
  REGFI_ITER_POSITION *pos ;
  void *tmp ;
  REGFI_NK_REC *tmp___0 ;
  _Bool tmp___1 ;

  {
  {
#line 1538
  tmp = talloc_named_const((void const   *)i->key_positions, sizeof(REGFI_ITER_POSITION ),
                           "REGFI_ITER_POSITION");
#line 1538
  pos = (REGFI_ITER_POSITION *)tmp;
  }
#line 1539
  if ((unsigned long )pos == (unsigned long )((void *)0)) {
#line 1540
    return ((_Bool)0);
  }
  {
#line 1542
  tmp___0 = regfi_iterator_cur_subkey(i);
#line 1542
  subkey = tmp___0;
  }
#line 1543
  if ((unsigned long )subkey == (unsigned long )((void *)0)) {
    {
#line 1545
    talloc_free((void *)pos);
    }
#line 1546
    return ((_Bool)0);
  }
  {
#line 1549
  pos->nk = i->cur_key;
#line 1550
  pos->cur_subkey = i->cur_subkey;
#line 1551
  tmp___1 = void_stack_push(i->key_positions, (void *)pos);
  }
#line 1551
  if (! tmp___1) {
    {
#line 1553
    talloc_free((void *)pos);
#line 1554
    regfi_free_key(subkey);
    }
#line 1555
    return ((_Bool)0);
  }
  {
#line 1557
  _talloc_steal((void const   *)i, (void const   *)subkey);
#line 1559
  i->cur_key = subkey;
#line 1560
  i->cur_subkey = (uint32_t )0;
#line 1561
  i->cur_value = (uint32_t )0;
  }
#line 1563
  return ((_Bool)1);
}
}
#line 1569 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
_Bool regfi_iterator_up(REGFI_ITERATOR *i ) 
{ 
  REGFI_ITER_POSITION *pos ;
  void *tmp ;

  {
  {
#line 1573
  tmp = void_stack_pop(i->key_positions);
#line 1573
  pos = (REGFI_ITER_POSITION *)tmp;
  }
#line 1574
  if ((unsigned long )pos == (unsigned long )((void *)0)) {
#line 1575
    return ((_Bool)0);
  }
  {
#line 1577
  regfi_free_key(i->cur_key);
#line 1578
  i->cur_key = pos->nk;
#line 1579
  i->cur_subkey = pos->cur_subkey;
#line 1580
  i->cur_value = (uint32_t )0;
#line 1581
  talloc_free((void *)pos);
  }
#line 1583
  return ((_Bool)1);
}
}
#line 1589 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
_Bool regfi_iterator_to_root(REGFI_ITERATOR *i ) 
{ 
  _Bool tmp ;

  {
  {
#line 1591
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1591
    tmp = regfi_iterator_up(i);
    }
#line 1591
    if (! tmp) {
#line 1591
      goto while_break;
    }
#line 1592
    goto while_continue;
  }
  while_break: /* CIL Label */ ;
  }
#line 1594
  return ((_Bool)1);
}
}
#line 1600 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
_Bool regfi_iterator_find_subkey(REGFI_ITERATOR *i , char const   *subkey_name ) 
{ 
  REGFI_NK_REC *subkey ;
  _Bool found ;
  uint32_t old_subkey ;
  REGFI_NK_REC *tmp ;
  REGFI_NK_REC *tmp___0 ;
  int tmp___1 ;

  {
#line 1603
  found = (_Bool)0;
#line 1604
  old_subkey = i->cur_subkey;
#line 1606
  if ((unsigned long )subkey_name == (unsigned long )((void *)0)) {
#line 1607
    return ((_Bool)0);
  }
  {
#line 1610
  tmp = regfi_iterator_first_subkey(i);
#line 1610
  subkey = tmp;
  }
  {
#line 1611
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1611
    if ((unsigned long )subkey != (unsigned long )((void *)0)) {
#line 1611
      if (! ((int )found == 0)) {
#line 1611
        goto while_break;
      }
    } else {
#line 1611
      goto while_break;
    }
#line 1613
    if ((unsigned long )subkey->keyname != (unsigned long )((void *)0)) {
      {
#line 1613
      tmp___1 = strcasecmp((char const   *)subkey->keyname, subkey_name);
      }
#line 1613
      if (tmp___1 == 0) {
#line 1615
        found = (_Bool)1;
      } else {
        {
#line 1618
        regfi_free_key(subkey);
#line 1619
        tmp___0 = regfi_iterator_next_subkey(i);
#line 1619
        subkey = tmp___0;
        }
      }
    } else {
      {
#line 1618
      regfi_free_key(subkey);
#line 1619
      tmp___0 = regfi_iterator_next_subkey(i);
#line 1619
      subkey = tmp___0;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1623
  if ((int )found == 0) {
#line 1625
    i->cur_subkey = old_subkey;
#line 1626
    return ((_Bool)0);
  }
  {
#line 1629
  regfi_free_key(subkey);
  }
#line 1630
  return ((_Bool)1);
}
}
#line 1636 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
_Bool regfi_iterator_walk_path(REGFI_ITERATOR *i , char const   **path ) 
{ 
  uint32_t x ;
  _Bool tmp ;
  _Bool tmp___0 ;

  {
#line 1639
  if ((unsigned long )path == (unsigned long )((void *)0)) {
#line 1640
    return ((_Bool)0);
  }
#line 1642
  x = (uint32_t )0;
  {
#line 1642
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1642
    if ((unsigned long )*(path + x) != (unsigned long )((void *)0)) {
      {
#line 1642
      tmp = regfi_iterator_find_subkey(i, *(path + x));
      }
#line 1642
      if (tmp) {
        {
#line 1642
        tmp___0 = regfi_iterator_down(i);
        }
#line 1642
        if (! tmp___0) {
#line 1642
          goto while_break;
        }
      } else {
#line 1642
        goto while_break;
      }
    } else {
#line 1642
      goto while_break;
    }
#line 1646
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 1642
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1648
  if ((unsigned long )*(path + x) == (unsigned long )((void *)0)) {
#line 1649
    return ((_Bool)1);
  }
  {
#line 1652
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1652
    if (! (x > 0U)) {
#line 1652
      goto while_break___0;
    }
    {
#line 1653
    regfi_iterator_up(i);
#line 1652
    x --;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1655
  return ((_Bool)0);
}
}
#line 1661 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
REGFI_NK_REC const   *regfi_iterator_cur_key(REGFI_ITERATOR *i ) 
{ 


  {
#line 1663
  return ((REGFI_NK_REC const   *)i->cur_key);
}
}
#line 1669 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
REGFI_SK_REC const   *regfi_iterator_cur_sk(REGFI_ITERATOR *i ) 
{ 
  REGFI_SK_REC const   *tmp ;

  {
#line 1671
  if ((unsigned long )i->cur_key == (unsigned long )((void *)0)) {
#line 1672
    return ((REGFI_SK_REC const   *)((void *)0));
  } else
#line 1671
  if ((i->cur_key)->sk_off == 4294967295U) {
#line 1672
    return ((REGFI_SK_REC const   *)((void *)0));
  }
  {
#line 1674
  tmp = regfi_load_sk(i->f, (i->cur_key)->sk_off + 4096U, (_Bool)1);
  }
#line 1674
  return (tmp);
}
}
#line 1680 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
REGFI_NK_REC *regfi_iterator_first_subkey(REGFI_ITERATOR *i ) 
{ 
  REGFI_NK_REC *tmp ;

  {
  {
#line 1682
  i->cur_subkey = (uint32_t )0;
#line 1683
  tmp = regfi_iterator_cur_subkey(i);
  }
#line 1683
  return (tmp);
}
}
#line 1689 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
REGFI_NK_REC *regfi_iterator_cur_subkey(REGFI_ITERATOR *i ) 
{ 
  uint32_t nk_offset ;
  REGFI_NK_REC *tmp ;

  {
#line 1694
  if (! i->cur_key) {
#line 1696
    return ((REGFI_NK_REC *)((void *)0));
  } else
#line 1694
  if ((i->cur_key)->subkeys_off == 4294967295U) {
#line 1696
    return ((REGFI_NK_REC *)((void *)0));
  } else
#line 1694
  if (i->cur_subkey >= (i->cur_key)->num_subkeys) {
#line 1696
    return ((REGFI_NK_REC *)((void *)0));
  }
  {
#line 1698
  nk_offset = (((i->cur_key)->subkeys)->elements + i->cur_subkey)->offset;
#line 1700
  tmp = regfi_load_key(i->f, nk_offset + 4096U, i->string_encoding, (_Bool)1);
  }
#line 1700
  return (tmp);
}
}
#line 1708 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
REGFI_NK_REC *regfi_iterator_next_subkey(REGFI_ITERATOR *i ) 
{ 
  REGFI_NK_REC *subkey ;

  {
  {
#line 1712
  (i->cur_subkey) ++;
#line 1713
  subkey = regfi_iterator_cur_subkey(i);
  }
#line 1715
  if ((unsigned long )subkey == (unsigned long )((void *)0)) {
#line 1716
    (i->cur_subkey) --;
  }
#line 1718
  return (subkey);
}
}
#line 1724 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
_Bool regfi_iterator_find_value(REGFI_ITERATOR *i , char const   *value_name ) 
{ 
  REGFI_VK_REC *cur ;
  _Bool found ;
  uint32_t old_value ;
  int tmp ;

  {
#line 1727
  found = (_Bool)0;
#line 1728
  old_value = i->cur_value;
#line 1733
  if ((unsigned long )value_name == (unsigned long )((void *)0)) {
#line 1734
    return ((_Bool)0);
  }
  {
#line 1736
  cur = regfi_iterator_first_value(i);
  }
  {
#line 1737
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1737
    if ((unsigned long )cur != (unsigned long )((void *)0)) {
#line 1737
      if (! ((int )found == 0)) {
#line 1737
        goto while_break;
      }
    } else {
#line 1737
      goto while_break;
    }
#line 1739
    if ((unsigned long )cur->valuename != (unsigned long )((void *)0)) {
      {
#line 1739
      tmp = strcasecmp((char const   *)cur->valuename, value_name);
      }
#line 1739
      if (tmp == 0) {
#line 1741
        found = (_Bool)1;
      } else {
        {
#line 1744
        regfi_free_value(cur);
#line 1745
        cur = regfi_iterator_next_value(i);
        }
      }
    } else {
      {
#line 1744
      regfi_free_value(cur);
#line 1745
      cur = regfi_iterator_next_value(i);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1749
  if ((int )found == 0) {
#line 1751
    i->cur_value = old_value;
#line 1752
    return ((_Bool)0);
  }
  {
#line 1755
  regfi_free_value(cur);
  }
#line 1756
  return ((_Bool)1);
}
}
#line 1762 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
REGFI_VK_REC *regfi_iterator_first_value(REGFI_ITERATOR *i ) 
{ 
  REGFI_VK_REC *tmp ;

  {
  {
#line 1764
  i->cur_value = (uint32_t )0;
#line 1765
  tmp = regfi_iterator_cur_value(i);
  }
#line 1765
  return (tmp);
}
}
#line 1771 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
REGFI_VK_REC *regfi_iterator_cur_value(REGFI_ITERATOR *i ) 
{ 
  REGFI_VK_REC *ret_val ;
  uint32_t voffset ;

  {
#line 1773
  ret_val = (REGFI_VK_REC *)((void *)0);
#line 1776
  if ((unsigned long )(i->cur_key)->values != (unsigned long )((void *)0)) {
#line 1776
    if ((unsigned long )((i->cur_key)->values)->elements != (unsigned long )((void *)0)) {
#line 1778
      if (i->cur_value < ((i->cur_key)->values)->num_values) {
        {
#line 1780
        voffset = *(((i->cur_key)->values)->elements + i->cur_value);
#line 1781
        ret_val = regfi_load_value(i->f, voffset + 4096U, i->string_encoding, (_Bool)1);
        }
      }
    }
  }
#line 1786
  return (ret_val);
}
}
#line 1792 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
REGFI_VK_REC *regfi_iterator_next_value(REGFI_ITERATOR *i ) 
{ 
  REGFI_VK_REC *ret_val ;

  {
  {
#line 1796
  (i->cur_value) ++;
#line 1797
  ret_val = regfi_iterator_cur_value(i);
  }
#line 1798
  if ((unsigned long )ret_val == (unsigned long )((void *)0)) {
#line 1799
    (i->cur_value) --;
  }
#line 1801
  return (ret_val);
}
}
#line 1807 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
REGFI_CLASSNAME *regfi_iterator_fetch_classname(REGFI_ITERATOR *i , REGFI_NK_REC const   *key ) 
{ 
  REGFI_CLASSNAME *ret_val ;
  uint8_t *raw ;
  char *interpreted ;
  uint32_t offset ;
  int32_t conv_size ;
  int32_t max_size ;
  uint16_t parse_length ;
  void *tmp ;
  void *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  void *tmp___4 ;

  {
#line 1817
  if (key->classname_off == 4294967295U) {
#line 1818
    return ((REGFI_CLASSNAME *)((void *)0));
  } else
#line 1817
  if ((int const   )key->classname_length == 0) {
#line 1818
    return ((REGFI_CLASSNAME *)((void *)0));
  }
  {
#line 1820
  offset = (uint32_t )(key->classname_off + 4096U);
#line 1821
  max_size = regfi_calc_maxsize(i->f, offset);
  }
#line 1822
  if (max_size <= 0) {
#line 1823
    return ((REGFI_CLASSNAME *)((void *)0));
  }
  {
#line 1825
  parse_length = (uint16_t )key->classname_length;
#line 1826
  raw = regfi_parse_classname(i->f, offset, & parse_length, (uint32_t )max_size, (_Bool)1);
  }
#line 1828
  if ((unsigned long )raw == (unsigned long )((void *)0)) {
    {
#line 1830
    regfi_add_message(i->f, (uint16_t )4, "Could not parse class name at offset 0x%.8X for key record at offset 0x%.8X.",
                      offset, key->offset);
    }
#line 1833
    return ((REGFI_CLASSNAME *)((void *)0));
  }
  {
#line 1836
  tmp = talloc_named_const((void const   *)((void *)0), sizeof(REGFI_CLASSNAME ),
                           "REGFI_CLASSNAME");
#line 1836
  ret_val = (REGFI_CLASSNAME *)tmp;
  }
#line 1837
  if ((unsigned long )ret_val == (unsigned long )((void *)0)) {
#line 1838
    return ((REGFI_CLASSNAME *)((void *)0));
  }
  {
#line 1840
  ret_val->raw = raw;
#line 1841
  ret_val->size = parse_length;
#line 1842
  _talloc_steal((void const   *)ret_val, (void const   *)raw);
#line 1844
  tmp___0 = _talloc_array((void const   *)((void *)0), sizeof(char ), (unsigned int )parse_length,
                          "char");
#line 1844
  interpreted = (char *)tmp___0;
#line 1846
  tmp___1 = regfi_encoding_int2str(i->string_encoding);
#line 1846
  tmp___2 = regfi_encoding_int2str((REGFI_ENCODING )2);
#line 1846
  conv_size = regfi_conv_charset(tmp___2, tmp___1, raw, interpreted, (uint32_t )parse_length,
                                 (uint32_t )parse_length);
  }
#line 1850
  if (conv_size < 0) {
    {
#line 1852
    tmp___3 = strerror(- conv_size);
#line 1852
    regfi_add_message(i->f, (uint16_t )4, "Error occurred while converting classname to charset %s.  Error message: %s",
                      (int )i->string_encoding, tmp___3);
#line 1855
    talloc_free((void *)interpreted);
#line 1856
    ret_val->interpreted = (char *)((void *)0);
    }
  } else {
    {
#line 1860
    tmp___4 = _talloc_realloc_array((void const   *)((void *)0), (void *)interpreted,
                                    sizeof(char ), (unsigned int )conv_size, "char");
#line 1860
    interpreted = (char *)tmp___4;
#line 1861
    ret_val->interpreted = interpreted;
#line 1862
    _talloc_steal((void const   *)ret_val, (void const   *)interpreted);
    }
  }
#line 1865
  return (ret_val);
}
}
#line 1871 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
REGFI_DATA *regfi_iterator_fetch_data(REGFI_ITERATOR *i , REGFI_VK_REC const   *value ) 
{ 
  REGFI_DATA *ret_val ;
  REGFI_BUFFER raw_data ;
  _Bool tmp ;

  {
#line 1874
  ret_val = (REGFI_DATA *)((void *)0);
#line 1877
  if (value->data_size != 0U) {
    {
#line 1879
    raw_data = regfi_load_data(i->f, (uint32_t )value->data_off, (uint32_t )value->data_size,
                               (_Bool )value->data_in_offset, (_Bool)1);
    }
#line 1881
    if ((unsigned long )raw_data.buf == (unsigned long )((void *)0)) {
      {
#line 1883
      regfi_add_message(i->f, (uint16_t )4, "Could not parse data record while parsing VK record at offset 0x%.8X.",
                        value->offset);
      }
    } else {
      {
#line 1889
      ret_val = regfi_buffer_to_data(raw_data);
      }
#line 1891
      if ((unsigned long )ret_val == (unsigned long )((void *)0)) {
        {
#line 1893
        regfi_add_message(i->f, (uint16_t )4, "Error occurred in converting data buffer to data structure while interpreting data for VK record at offset 0x%.8X.",
                          value->offset);
#line 1897
        talloc_free((void *)raw_data.buf);
        }
#line 1898
        return ((REGFI_DATA *)((void *)0));
      }
      {
#line 1901
      tmp = regfi_interpret_data(i->f, i->string_encoding, (uint32_t )value->type,
                                 ret_val);
      }
#line 1901
      if (! tmp) {
        {
#line 1903
        regfi_add_message(i->f, (uint16_t )1, "Error occurred while interpreting data for VK record at offset 0x%.8X.",
                          value->offset);
        }
      }
    }
  }
#line 1910
  return (ret_val);
}
}
#line 1916 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
void regfi_free_classname(REGFI_CLASSNAME *classname ) 
{ 


  {
  {
#line 1918
  talloc_free((void *)classname);
  }
#line 1919
  return;
}
}
#line 1923 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
void regfi_free_data(REGFI_DATA *data ) 
{ 


  {
  {
#line 1925
  talloc_free((void *)data);
  }
#line 1926
  return;
}
}
#line 1931 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
REGFI_DATA *regfi_buffer_to_data(REGFI_BUFFER raw_data ) 
{ 
  REGFI_DATA *ret_val ;
  void *tmp ;

  {
#line 1935
  if ((unsigned long )raw_data.buf == (unsigned long )((void *)0)) {
#line 1936
    return ((REGFI_DATA *)((void *)0));
  }
  {
#line 1938
  tmp = talloc_named_const((void const   *)((void *)0), sizeof(REGFI_DATA ), "REGFI_DATA");
#line 1938
  ret_val = (REGFI_DATA *)tmp;
  }
#line 1939
  if ((unsigned long )ret_val == (unsigned long )((void *)0)) {
#line 1940
    return ((REGFI_DATA *)((void *)0));
  }
  {
#line 1942
  _talloc_steal((void const   *)ret_val, (void const   *)raw_data.buf);
#line 1943
  ret_val->raw = raw_data.buf;
#line 1944
  ret_val->size = raw_data.len;
#line 1945
  ret_val->interpreted_size = (uint32_t )0;
#line 1946
  ret_val->interpreted.qword = (uint64_t )0;
  }
#line 1948
  return (ret_val);
}
}
#line 1954 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
_Bool regfi_interpret_data(REGFI_FILE *file , REGFI_ENCODING string_encoding , uint32_t type ,
                           REGFI_DATA *data ) 
{ 
  uint8_t **tmp_array ;
  uint8_t *tmp_str ;
  int32_t tmp_size ;
  uint32_t i ;
  uint32_t j ;
  uint32_t array_size ;
  void *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char *tmp___7 ;
  void *tmp___8 ;
  uint32_t tmp___9 ;
  void *tmp___10 ;

  {
#line 1962
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 1963
    return ((_Bool)0);
  }
  {
#line 1970
  if (type == 6U) {
#line 1970
    goto case_6;
  }
#line 1970
  if (type == 2U) {
#line 1970
    goto case_6;
  }
#line 1970
  if (type == 1U) {
#line 1970
    goto case_6;
  }
#line 2000
  if (type == 4U) {
#line 2000
    goto case_4;
  }
#line 2011
  if (type == 5U) {
#line 2011
    goto case_5;
  }
#line 2022
  if (type == 11U) {
#line 2022
    goto case_11;
  }
#line 2034
  if (type == 7U) {
#line 2034
    goto case_7;
  }
#line 2087
  if (type == 0U) {
#line 2087
    goto case_0;
  }
#line 2092
  if (type == 8U) {
#line 2092
    goto case_8;
  }
#line 2097
  if (type == 9U) {
#line 2097
    goto case_9;
  }
#line 2102
  if (type == 10U) {
#line 2102
    goto case_10;
  }
#line 2107
  if (type == 3U) {
#line 2107
    goto case_3;
  }
#line 2112
  goto switch_default;
  case_6: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 1971
  tmp = _talloc_array((void const   *)((void *)0), sizeof(uint8_t ), data->size, "uint8_t");
#line 1971
  tmp_str = (uint8_t *)tmp;
  }
#line 1972
  if ((unsigned long )tmp_str == (unsigned long )((void *)0)) {
#line 1974
    data->interpreted.string = (uint8_t *)((void *)0);
#line 1975
    data->interpreted_size = (uint32_t )0;
#line 1976
    return ((_Bool)0);
  }
  {
#line 1979
  tmp___0 = regfi_encoding_int2str(string_encoding);
#line 1979
  tmp___1 = regfi_encoding_int2str((REGFI_ENCODING )2);
#line 1979
  tmp_size = regfi_conv_charset(tmp___1, tmp___0, data->raw, (char *)tmp_str, data->size,
                                data->size);
  }
#line 1983
  if (tmp_size < 0) {
    {
#line 1985
    tmp___2 = strerror(- tmp_size);
#line 1985
    regfi_add_message(file, (uint16_t )1, "Error occurred while converting data of type %d to %s.  Error message: %s",
                      type, (int )string_encoding, tmp___2);
#line 1988
    talloc_free((void *)tmp_str);
#line 1989
    data->interpreted.string = (uint8_t *)((void *)0);
#line 1990
    data->interpreted_size = (uint32_t )0;
    }
#line 1991
    return ((_Bool)0);
  }
  {
#line 1994
  tmp___3 = _talloc_realloc_array((void const   *)((void *)0), (void *)tmp_str, sizeof(uint8_t ),
                                  (unsigned int )tmp_size, "uint8_t");
#line 1994
  tmp_str = (uint8_t *)tmp___3;
#line 1995
  data->interpreted.string = tmp_str;
#line 1996
  data->interpreted_size = (uint32_t )tmp_size;
#line 1997
  _talloc_steal((void const   *)data, (void const   *)tmp_str);
  }
#line 1998
  goto switch_break;
  case_4: /* CIL Label */ 
#line 2001
  if (data->size < 4U) {
#line 2003
    data->interpreted.dword = (uint32_t )0;
#line 2004
    data->interpreted_size = (uint32_t )0;
#line 2005
    return ((_Bool)0);
  }
#line 2007
  data->interpreted.dword = ((unsigned int )*((unsigned char const   *)data->raw + 0) | ((unsigned int )*((unsigned char const   *)data->raw + 1) << 8)) | (((unsigned int )*((unsigned char const   *)data->raw + 2) | ((unsigned int )*((unsigned char const   *)data->raw + 3) << 8)) << 16);
#line 2008
  data->interpreted_size = (uint32_t )4;
#line 2009
  goto switch_break;
  case_5: /* CIL Label */ 
#line 2012
  if (data->size < 4U) {
#line 2014
    data->interpreted.dword_be = (uint32_t )0;
#line 2015
    data->interpreted_size = (uint32_t )0;
#line 2016
    return ((_Bool)0);
  }
#line 2018
  data->interpreted.dword_be = (((((((unsigned int )*((unsigned char const   *)data->raw + 0) | ((unsigned int )*((unsigned char const   *)data->raw + 1) << 8)) | (((unsigned int )*((unsigned char const   *)data->raw + 2) | ((unsigned int )*((unsigned char const   *)data->raw + 3) << 8)) << 16)) & 255U) << 8) | (((((unsigned int )*((unsigned char const   *)data->raw + 0) | ((unsigned int )*((unsigned char const   *)data->raw + 1) << 8)) | (((unsigned int )*((unsigned char const   *)data->raw + 2) | ((unsigned int )*((unsigned char const   *)data->raw + 3) << 8)) << 16)) >> 8) & 255U)) << 16) | (((((((unsigned int )*((unsigned char const   *)data->raw + 0) | ((unsigned int )*((unsigned char const   *)data->raw + 1) << 8)) | (((unsigned int )*((unsigned char const   *)data->raw + 2) | ((unsigned int )*((unsigned char const   *)data->raw + 3) << 8)) << 16)) >> 16) & 255U) << 8) | ((((((unsigned int )*((unsigned char const   *)data->raw + 0) | ((unsigned int )*((unsigned char const   *)data->raw + 1) << 8)) | (((unsigned int )*((unsigned char const   *)data->raw + 2) | ((unsigned int )*((unsigned char const   *)data->raw + 3) << 8)) << 16)) >> 16) >> 8) & 255U));
#line 2019
  data->interpreted_size = (uint32_t )4;
#line 2020
  goto switch_break;
  case_11: /* CIL Label */ 
#line 2023
  if (data->size < 8U) {
#line 2025
    data->interpreted.qword = (uint64_t )0;
#line 2026
    data->interpreted_size = (uint32_t )0;
#line 2027
    return ((_Bool)0);
  }
#line 2029
  data->interpreted.qword = (uint64_t )(((unsigned int )*((unsigned char const   *)data->raw + 0) | ((unsigned int )*((unsigned char const   *)data->raw + 1) << 8)) | (((unsigned int )*((unsigned char const   *)data->raw + 2) | ((unsigned int )*((unsigned char const   *)data->raw + 3) << 8)) << 16)) + ((uint64_t )(((unsigned int )*((unsigned char const   *)data->raw + 4) | ((unsigned int )*((unsigned char const   *)data->raw + 5) << 8)) | (((unsigned int )*((unsigned char const   *)data->raw + 6) | ((unsigned int )*((unsigned char const   *)data->raw + 7) << 8)) << 16)) << 32);
#line 2031
  data->interpreted_size = (uint32_t )8;
#line 2032
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 2035
  tmp___4 = _talloc_array((void const   *)((void *)0), sizeof(uint8_t ), data->size,
                          "uint8_t");
#line 2035
  tmp_str = (uint8_t *)tmp___4;
  }
#line 2036
  if ((unsigned long )tmp_str == (unsigned long )((void *)0)) {
#line 2038
    data->interpreted.multiple_string = (uint8_t **)((void *)0);
#line 2039
    data->interpreted_size = (uint32_t )0;
#line 2040
    return ((_Bool)0);
  }
  {
#line 2046
  tmp___5 = regfi_encoding_int2str(string_encoding);
#line 2046
  tmp___6 = regfi_encoding_int2str((REGFI_ENCODING )2);
#line 2046
  tmp_size = regfi_conv_charset(tmp___6, tmp___5, data->raw, (char *)tmp_str, data->size,
                                data->size);
  }
#line 2050
  if (tmp_size < 0) {
    {
#line 2052
    tmp___7 = strerror(- tmp_size);
#line 2052
    regfi_add_message(file, (uint16_t )1, "Error occurred while converting data of type %d to %s.  Error message: %s",
                      type, (int )string_encoding, tmp___7);
#line 2055
    talloc_free((void *)tmp_str);
#line 2056
    data->interpreted.multiple_string = (uint8_t **)((void *)0);
#line 2057
    data->interpreted_size = (uint32_t )0;
    }
#line 2058
    return ((_Bool)0);
  }
  {
#line 2061
  array_size = (uint32_t )(tmp_size + 1);
#line 2062
  tmp___8 = _talloc_array((void const   *)((void *)0), sizeof(uint8_t *), array_size,
                          "uint8_t*");
#line 2062
  tmp_array = (uint8_t **)tmp___8;
  }
#line 2063
  if ((unsigned long )tmp_array == (unsigned long )((void *)0)) {
    {
#line 2065
    talloc_free((void *)tmp_str);
#line 2066
    data->interpreted.string = (uint8_t *)((void *)0);
#line 2067
    data->interpreted_size = (uint32_t )0;
    }
#line 2068
    return ((_Bool)0);
  }
#line 2071
  *(tmp_array + 0) = tmp_str;
#line 2072
  i = (uint32_t )0;
#line 2072
  j = (uint32_t )1;
  {
#line 2072
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2072
    if (i < (uint32_t )tmp_size) {
#line 2072
      if (! (j < array_size - 1U)) {
#line 2072
        goto while_break;
      }
    } else {
#line 2072
      goto while_break;
    }
#line 2074
    if ((int )*(tmp_str + i) == 0) {
#line 2074
      if (i + 1U < (uint32_t )tmp_size) {
#line 2075
        tmp___9 = j;
#line 2075
        j ++;
#line 2075
        *(tmp_array + tmp___9) = (tmp_str + i) + 1;
      }
    }
#line 2072
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2077
  *(tmp_array + j) = (uint8_t *)((void *)0);
#line 2078
  tmp___10 = _talloc_realloc_array((void const   *)((void *)0), (void *)tmp_array,
                                   sizeof(uint8_t *), j + 1U, "uint8_t*");
#line 2078
  tmp_array = (uint8_t **)tmp___10;
#line 2079
  data->interpreted.multiple_string = tmp_array;
#line 2081
  data->interpreted_size = (uint32_t )tmp_size;
#line 2082
  _talloc_steal((void const   *)tmp_array, (void const   *)tmp_str);
#line 2083
  _talloc_steal((void const   *)data, (void const   *)tmp_array);
  }
#line 2084
  goto switch_break;
  case_0: /* CIL Label */ 
#line 2088
  data->interpreted.none = data->raw;
#line 2089
  data->interpreted_size = data->size;
#line 2090
  goto switch_break;
  case_8: /* CIL Label */ 
#line 2093
  data->interpreted.resource_list = data->raw;
#line 2094
  data->interpreted_size = data->size;
#line 2095
  goto switch_break;
  case_9: /* CIL Label */ 
#line 2098
  data->interpreted.full_resource_descriptor = data->raw;
#line 2099
  data->interpreted_size = data->size;
#line 2100
  goto switch_break;
  case_10: /* CIL Label */ 
#line 2103
  data->interpreted.resource_requirements_list = data->raw;
#line 2104
  data->interpreted_size = data->size;
#line 2105
  goto switch_break;
  case_3: /* CIL Label */ 
#line 2108
  data->interpreted.binary = data->raw;
#line 2109
  data->interpreted_size = data->size;
#line 2110
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 2113
  data->interpreted.qword = (uint64_t )0;
#line 2114
  data->interpreted_size = (uint32_t )0;
#line 2115
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
#line 2118
  data->type = type;
#line 2119
  return ((_Bool)1);
}
}
#line 2127 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
int32_t regfi_conv_charset(char const   *input_charset , char const   *output_charset ,
                           uint8_t *input , char *output , uint32_t input_len , uint32_t output_max ) 
{ 
  iconv_t conv_desc___0 ;
  char *inbuf ;
  char *outbuf ;
  size_t in_len ;
  size_t out_len ;
  int ret ;
  size_t tmp ;
  int *tmp___0 ;

  {
  {
#line 2132
  inbuf = (char *)input;
#line 2133
  outbuf = output;
#line 2134
  in_len = (size_t )input_len;
#line 2135
  out_len = (size_t )(output_max - 1U);
#line 2144
  conv_desc___0 = iconv_open(output_charset, input_charset);
#line 2146
  tmp = iconv(conv_desc___0, (char **/* __restrict  */)(& inbuf), (size_t */* __restrict  */)(& in_len),
              (char **/* __restrict  */)(& outbuf), (size_t */* __restrict  */)(& out_len));
#line 2146
  ret = (int )tmp;
  }
#line 2147
  if (ret == -1) {
    {
#line 2149
    iconv_close(conv_desc___0);
#line 2150
    tmp___0 = __errno_location();
    }
#line 2150
    return (- *tmp___0);
  }
  {
#line 2152
  *outbuf = (char )'\000';
#line 2154
  iconv_close(conv_desc___0);
  }
#line 2155
  return ((int32_t )(((size_t )output_max - out_len) - 1UL));
}
}
#line 2164 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
static uint32_t regfi_compute_header_checksum(uint8_t *buffer ) 
{ 
  uint32_t checksum ;
  uint32_t x ;
  int i ;

  {
#line 2171
  x = (uint32_t )0;
#line 2171
  checksum = x;
#line 2173
  i = 0;
  {
#line 2173
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2173
    if (! (i < 507)) {
#line 2173
      goto while_break;
    }
#line 2174
    x = ((unsigned int )*((unsigned char const   *)buffer + i) | ((unsigned int )*((unsigned char const   *)buffer + (i + 1)) << 8)) | (((unsigned int )*((unsigned char const   *)buffer + (i + 2)) | ((unsigned int )*((unsigned char const   *)buffer + ((i + 2) + 1)) << 8)) << 16);
#line 2175
    checksum ^= x;
#line 2173
    i += 4;
  }
  while_break: /* CIL Label */ ;
  }
#line 2178
  return (checksum);
}
}
#line 2185 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
REGFI_FILE *regfi_parse_regf(int fd , _Bool strict ) 
{ 
  uint8_t file_header[4096] ;
  uint32_t length ;
  REGFI_FILE *ret_val ;
  void *tmp ;
  uint32_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 2191
  tmp = talloc_named_const((void const   *)((void *)0), sizeof(REGFI_FILE ), "REGFI_FILE");
#line 2191
  ret_val = (REGFI_FILE *)tmp;
  }
#line 2192
  if ((unsigned long )ret_val == (unsigned long )((void *)0)) {
#line 2193
    return ((REGFI_FILE *)((void *)0));
  }
  {
#line 2195
  ret_val->fd = fd;
#line 2196
  ret_val->sk_cache = (lru_cache *)((void *)0);
#line 2197
  ret_val->last_message = (char *)((void *)0);
#line 2198
  ret_val->hbins = (range_list *)((void *)0);
#line 2200
  length = (uint32_t )4096;
#line 2201
  tmp___0 = regfi_read(fd, file_header, & length);
  }
#line 2201
  if (tmp___0 != 0U) {
#line 2202
    goto fail;
  } else
#line 2201
  if (length != 4096U) {
#line 2202
    goto fail;
  }
  {
#line 2204
  ret_val->checksum = ((unsigned int )*((unsigned char const   *)(file_header) + 508) | ((unsigned int )*((unsigned char const   *)(file_header) + 509) << 8)) | (((unsigned int )*((unsigned char const   *)(file_header) + 510) | ((unsigned int )*((unsigned char const   *)(file_header) + 511) << 8)) << 16);
#line 2205
  ret_val->computed_checksum = regfi_compute_header_checksum(file_header);
  }
#line 2206
  if (strict) {
#line 2206
    if (ret_val->checksum != ret_val->computed_checksum) {
#line 2207
      goto fail;
    }
  }
  {
#line 2209
  memcpy((void */* __restrict  */)(ret_val->magic), (void const   */* __restrict  */)(file_header),
         (size_t )4);
#line 2210
  tmp___1 = memcmp((void const   *)(ret_val->magic), (void const   *)"regf", (size_t )4);
  }
#line 2210
  if (tmp___1 != 0) {
#line 2212
    if (strict) {
#line 2213
      goto fail;
    }
    {
#line 2214
    regfi_add_message(ret_val, (uint16_t )4, "Magic number mismatch (%.2X %.2X %.2X %.2X) while parsing hive header",
                      (int )ret_val->magic[0], (int )ret_val->magic[1], (int )ret_val->magic[2],
                      (int )ret_val->magic[3]);
    }
  }
  {
#line 2219
  ret_val->sequence1 = ((unsigned int )*((unsigned char const   *)(file_header) + 4) | ((unsigned int )*((unsigned char const   *)(file_header) + 5) << 8)) | (((unsigned int )*((unsigned char const   *)(file_header) + 6) | ((unsigned int )*((unsigned char const   *)(file_header) + 7) << 8)) << 16);
#line 2220
  ret_val->sequence2 = ((unsigned int )*((unsigned char const   *)(file_header) + 8) | ((unsigned int )*((unsigned char const   *)(file_header) + 9) << 8)) | (((unsigned int )*((unsigned char const   *)(file_header) + 10) | ((unsigned int )*((unsigned char const   *)(file_header) + 11) << 8)) << 16);
#line 2221
  ret_val->mtime.low = ((unsigned int )*((unsigned char const   *)(file_header) + 12) | ((unsigned int )*((unsigned char const   *)(file_header) + 13) << 8)) | (((unsigned int )*((unsigned char const   *)(file_header) + 14) | ((unsigned int )*((unsigned char const   *)(file_header) + 15) << 8)) << 16);
#line 2222
  ret_val->mtime.high = ((unsigned int )*((unsigned char const   *)(file_header) + 16) | ((unsigned int )*((unsigned char const   *)(file_header) + 17) << 8)) | (((unsigned int )*((unsigned char const   *)(file_header) + 18) | ((unsigned int )*((unsigned char const   *)(file_header) + 19) << 8)) << 16);
#line 2223
  ret_val->major_version = ((unsigned int )*((unsigned char const   *)(file_header) + 20) | ((unsigned int )*((unsigned char const   *)(file_header) + 21) << 8)) | (((unsigned int )*((unsigned char const   *)(file_header) + 22) | ((unsigned int )*((unsigned char const   *)(file_header) + 23) << 8)) << 16);
#line 2224
  ret_val->minor_version = ((unsigned int )*((unsigned char const   *)(file_header) + 24) | ((unsigned int )*((unsigned char const   *)(file_header) + 25) << 8)) | (((unsigned int )*((unsigned char const   *)(file_header) + 26) | ((unsigned int )*((unsigned char const   *)(file_header) + 27) << 8)) << 16);
#line 2225
  ret_val->type = ((unsigned int )*((unsigned char const   *)(file_header) + 28) | ((unsigned int )*((unsigned char const   *)(file_header) + 29) << 8)) | (((unsigned int )*((unsigned char const   *)(file_header) + 30) | ((unsigned int )*((unsigned char const   *)(file_header) + 31) << 8)) << 16);
#line 2226
  ret_val->format = ((unsigned int )*((unsigned char const   *)(file_header) + 32) | ((unsigned int )*((unsigned char const   *)(file_header) + 33) << 8)) | (((unsigned int )*((unsigned char const   *)(file_header) + 34) | ((unsigned int )*((unsigned char const   *)(file_header) + 35) << 8)) << 16);
#line 2227
  ret_val->root_cell = ((unsigned int )*((unsigned char const   *)(file_header) + 36) | ((unsigned int )*((unsigned char const   *)(file_header) + 37) << 8)) | (((unsigned int )*((unsigned char const   *)(file_header) + 38) | ((unsigned int )*((unsigned char const   *)(file_header) + 39) << 8)) << 16);
#line 2228
  ret_val->last_block = ((unsigned int )*((unsigned char const   *)(file_header) + 40) | ((unsigned int )*((unsigned char const   *)(file_header) + 41) << 8)) | (((unsigned int )*((unsigned char const   *)(file_header) + 42) | ((unsigned int )*((unsigned char const   *)(file_header) + 43) << 8)) << 16);
#line 2230
  ret_val->cluster = ((unsigned int )*((unsigned char const   *)(file_header) + 44) | ((unsigned int )*((unsigned char const   *)(file_header) + 45) << 8)) | (((unsigned int )*((unsigned char const   *)(file_header) + 46) | ((unsigned int )*((unsigned char const   *)(file_header) + 47) << 8)) << 16);
#line 2232
  memcpy((void */* __restrict  */)(ret_val->file_name), (void const   */* __restrict  */)(file_header + 48),
         (size_t )64);
#line 2235
  ret_val->rm_id = winsec_parse_uuid((void *)ret_val, (uint8_t const   *)(file_header + 112),
                                     (uint32_t )16);
#line 2236
  ret_val->log_id = winsec_parse_uuid((void *)ret_val, (uint8_t const   *)(file_header + 128),
                                      (uint32_t )16);
#line 2237
  ret_val->flags = ((unsigned int )*((unsigned char const   *)(file_header) + 144) | ((unsigned int )*((unsigned char const   *)(file_header) + 145) << 8)) | (((unsigned int )*((unsigned char const   *)(file_header) + 146) | ((unsigned int )*((unsigned char const   *)(file_header) + 147) << 8)) << 16);
#line 2238
  ret_val->tm_id = winsec_parse_uuid((void *)ret_val, (uint8_t const   *)(file_header + 148),
                                     (uint32_t )16);
#line 2239
  ret_val->guid_signature = ((unsigned int )*((unsigned char const   *)(file_header) + 164) | ((unsigned int )*((unsigned char const   *)(file_header) + 165) << 8)) | (((unsigned int )*((unsigned char const   *)(file_header) + 166) | ((unsigned int )*((unsigned char const   *)(file_header) + 167) << 8)) << 16);
#line 2241
  memcpy((void */* __restrict  */)(ret_val->reserved1), (void const   */* __restrict  */)(file_header + 168),
         (size_t )340);
#line 2242
  memcpy((void */* __restrict  */)(ret_val->reserved2), (void const   */* __restrict  */)(file_header + 512),
         (size_t )3528);
#line 2244
  ret_val->thaw_tm_id = winsec_parse_uuid((void *)ret_val, (uint8_t const   *)(file_header + 4040),
                                          (uint32_t )16);
#line 2245
  ret_val->thaw_rm_id = winsec_parse_uuid((void *)ret_val, (uint8_t const   *)(file_header + 4056),
                                          (uint32_t )16);
#line 2246
  ret_val->thaw_log_id = winsec_parse_uuid((void *)ret_val, (uint8_t const   *)(file_header + 4072),
                                           (uint32_t )16);
#line 2247
  ret_val->boot_type = ((unsigned int )*((unsigned char const   *)(file_header) + 4088) | ((unsigned int )*((unsigned char const   *)(file_header) + 4089) << 8)) | (((unsigned int )*((unsigned char const   *)(file_header) + 4090) | ((unsigned int )*((unsigned char const   *)(file_header) + 4091) << 8)) << 16);
#line 2248
  ret_val->boot_recover = ((unsigned int )*((unsigned char const   *)(file_header) + 4092) | ((unsigned int )*((unsigned char const   *)(file_header) + 4093) << 8)) | (((unsigned int )*((unsigned char const   *)(file_header) + 4094) | ((unsigned int )*((unsigned char const   *)(file_header) + 4095) << 8)) << 16);
  }
#line 2250
  return (ret_val);
  fail: 
  {
#line 2253
  talloc_free((void *)ret_val);
  }
#line 2254
  return ((REGFI_FILE *)((void *)0));
}
}
#line 2263 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
REGFI_HBIN *regfi_parse_hbin(REGFI_FILE *file , uint32_t offset , _Bool strict ) 
{ 
  REGFI_HBIN *hbin ;
  uint8_t hbin_header[32] ;
  uint32_t length ;
  __off_t tmp ;
  uint32_t tmp___0 ;
  __off_t tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
#line 2269
  if (offset >= file->file_length) {
#line 2270
    return ((REGFI_HBIN *)((void *)0));
  }
  {
#line 2272
  tmp = lseek(file->fd, (__off_t )offset, 0);
  }
#line 2272
  if (tmp == -1L) {
    {
#line 2274
    regfi_add_message(file, (uint16_t )16, "Seek failed while parsing hbin at offset 0x%.8X.",
                      offset);
    }
#line 2276
    return ((REGFI_HBIN *)((void *)0));
  }
  {
#line 2279
  length = (uint32_t )32;
#line 2280
  tmp___0 = regfi_read(file->fd, hbin_header, & length);
  }
#line 2280
  if (tmp___0 != 0U) {
#line 2282
    return ((REGFI_HBIN *)((void *)0));
  } else
#line 2280
  if (length != 32U) {
#line 2282
    return ((REGFI_HBIN *)((void *)0));
  }
  {
#line 2284
  tmp___1 = lseek(file->fd, (__off_t )offset, 0);
  }
#line 2284
  if (tmp___1 == -1L) {
    {
#line 2286
    regfi_add_message(file, (uint16_t )16, "Seek failed while parsing hbin at offset 0x%.8X.",
                      offset);
    }
#line 2288
    return ((REGFI_HBIN *)((void *)0));
  }
  {
#line 2291
  tmp___2 = talloc_named_const((void const   *)((void *)0), sizeof(REGFI_HBIN ), "REGFI_HBIN");
#line 2291
  hbin = (REGFI_HBIN *)tmp___2;
  }
#line 2292
  if ((unsigned long )hbin == (unsigned long )((void *)0)) {
#line 2293
    return ((REGFI_HBIN *)((void *)0));
  }
  {
#line 2294
  hbin->file_off = offset;
#line 2296
  memcpy((void */* __restrict  */)(hbin->magic), (void const   */* __restrict  */)(hbin_header),
         (size_t )4);
  }
#line 2297
  if (strict) {
    {
#line 2297
    tmp___3 = memcmp((void const   *)(hbin->magic), (void const   *)"hbin", (size_t )4);
    }
#line 2297
    if (tmp___3 != 0) {
      {
#line 2299
      regfi_add_message(file, (uint16_t )1, "Magic number mismatch (%.2X %.2X %.2X %.2X) while parsing hbin at offset 0x%.8X.",
                        (int )hbin->magic[0], (int )hbin->magic[1], (int )hbin->magic[2],
                        (int )hbin->magic[3], offset);
#line 2303
      talloc_free((void *)hbin);
      }
#line 2304
      return ((REGFI_HBIN *)((void *)0));
    }
  }
#line 2307
  hbin->first_hbin_off = ((unsigned int )*((unsigned char const   *)(hbin_header) + 4) | ((unsigned int )*((unsigned char const   *)(hbin_header) + 5) << 8)) | (((unsigned int )*((unsigned char const   *)(hbin_header) + 6) | ((unsigned int )*((unsigned char const   *)(hbin_header) + 7) << 8)) << 16);
#line 2308
  hbin->block_size = ((unsigned int )*((unsigned char const   *)(hbin_header) + 8) | ((unsigned int )*((unsigned char const   *)(hbin_header) + 9) << 8)) | (((unsigned int )*((unsigned char const   *)(hbin_header) + 10) | ((unsigned int )*((unsigned char const   *)(hbin_header) + 11) << 8)) << 16);
#line 2310
  hbin->next_block = ((unsigned int )*((unsigned char const   *)(hbin_header) + 28) | ((unsigned int )*((unsigned char const   *)(hbin_header) + 29) << 8)) | (((unsigned int )*((unsigned char const   *)(hbin_header) + 30) | ((unsigned int )*((unsigned char const   *)(hbin_header) + 31) << 8)) << 16);
#line 2319
  if (offset + hbin->block_size > file->file_length) {
    {
#line 2322
    regfi_add_message(file, (uint16_t )16, "The hbin offset is not aligned or runs off the end of the file while parsing hbin at offset 0x%.8X.",
                      offset);
#line 2325
    talloc_free((void *)hbin);
    }
#line 2326
    return ((REGFI_HBIN *)((void *)0));
  } else
#line 2319
  if ((hbin->block_size & 4294963200U) != hbin->block_size) {
    {
#line 2322
    regfi_add_message(file, (uint16_t )16, "The hbin offset is not aligned or runs off the end of the file while parsing hbin at offset 0x%.8X.",
                      offset);
#line 2325
    talloc_free((void *)hbin);
    }
#line 2326
    return ((REGFI_HBIN *)((void *)0));
  }
#line 2329
  return (hbin);
}
}
#line 2335 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
REGFI_NK_REC *regfi_parse_nk(REGFI_FILE *file , uint32_t offset , uint32_t max_size ,
                             _Bool strict ) 
{ 
  uint8_t nk_header[76] ;
  REGFI_NK_REC *ret_val ;
  uint32_t length ;
  uint32_t cell_length ;
  _Bool unalloc ;
  _Bool tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  uint32_t tmp___2 ;

  {
  {
#line 2341
  unalloc = (_Bool)0;
#line 2343
  tmp = regfi_parse_cell(file->fd, offset, nk_header, (uint32_t )76, & cell_length,
                         & unalloc);
  }
#line 2343
  if (! tmp) {
    {
#line 2346
    regfi_add_message(file, (uint16_t )4, "Could not parse cell header while parsing NK record at offset 0x%.8X.",
                      offset);
    }
#line 2348
    return ((REGFI_NK_REC *)((void *)0));
  }
#line 2352
  if ((int )nk_header[0] != 110) {
    {
#line 2354
    regfi_add_message(file, (uint16_t )4, "Magic number mismatch in parsing NK record at offset 0x%.8X.",
                      offset);
    }
#line 2356
    return ((REGFI_NK_REC *)((void *)0));
  } else
#line 2352
  if ((int )nk_header[1] != 107) {
    {
#line 2354
    regfi_add_message(file, (uint16_t )4, "Magic number mismatch in parsing NK record at offset 0x%.8X.",
                      offset);
    }
#line 2356
    return ((REGFI_NK_REC *)((void *)0));
  }
  {
#line 2359
  tmp___0 = talloc_named_const((void const   *)((void *)0), sizeof(REGFI_NK_REC ),
                               "REGFI_NK_REC");
#line 2359
  ret_val = (REGFI_NK_REC *)tmp___0;
  }
#line 2360
  if ((unsigned long )ret_val == (unsigned long )((void *)0)) {
    {
#line 2362
    regfi_add_message(file, (uint16_t )16, "Failed to allocate memory while parsing NK record at offset 0x%.8X.",
                      offset);
    }
#line 2364
    return ((REGFI_NK_REC *)((void *)0));
  }
#line 2367
  ret_val->values = (REGFI_VALUE_LIST *)((void *)0);
#line 2368
  ret_val->subkeys = (REGFI_SUBKEY_LIST *)((void *)0);
#line 2369
  ret_val->offset = offset;
#line 2370
  ret_val->cell_size = cell_length;
#line 2372
  if (ret_val->cell_size > max_size) {
#line 2373
    ret_val->cell_size = max_size & 4294967288U;
  }
#line 2374
  if (ret_val->cell_size < 76U) {
    {
#line 2377
    regfi_add_message(file, (uint16_t )4, "A length check failed while parsing NK record at offset 0x%.8X.",
                      offset);
#line 2379
    talloc_free((void *)ret_val);
    }
#line 2380
    return ((REGFI_NK_REC *)((void *)0));
  } else
#line 2374
  if (strict) {
#line 2374
    if ((ret_val->cell_size & 7U) != 0U) {
      {
#line 2377
      regfi_add_message(file, (uint16_t )4, "A length check failed while parsing NK record at offset 0x%.8X.",
                        offset);
#line 2379
      talloc_free((void *)ret_val);
      }
#line 2380
      return ((REGFI_NK_REC *)((void *)0));
    }
  }
#line 2383
  ret_val->magic[0] = nk_header[0];
#line 2384
  ret_val->magic[1] = nk_header[1];
#line 2385
  ret_val->flags = (uint16_t )((unsigned int )*((unsigned char const   *)(nk_header) + 2) | ((unsigned int )*((unsigned char const   *)(nk_header) + 3) << 8));
#line 2387
  if (((int )ret_val->flags & -20736) != 0) {
    {
#line 2389
    regfi_add_message(file, (uint16_t )4, "Unknown key flags (0x%.4X) while parsing NK record at offset 0x%.8X.",
                      (int )ret_val->flags & -20736, offset);
    }
  }
#line 2394
  ret_val->mtime.low = ((unsigned int )*((unsigned char const   *)(nk_header) + 4) | ((unsigned int )*((unsigned char const   *)(nk_header) + 5) << 8)) | (((unsigned int )*((unsigned char const   *)(nk_header) + 6) | ((unsigned int )*((unsigned char const   *)(nk_header) + 7) << 8)) << 16);
#line 2395
  ret_val->mtime.high = ((unsigned int )*((unsigned char const   *)(nk_header) + 8) | ((unsigned int )*((unsigned char const   *)(nk_header) + 9) << 8)) | (((unsigned int )*((unsigned char const   *)(nk_header) + 10) | ((unsigned int )*((unsigned char const   *)(nk_header) + 11) << 8)) << 16);
#line 2400
  if (unalloc) {
#line 2400
    if (ret_val->mtime.high < 28581485U) {
#line 2400
      if (ret_val->mtime.low < 653885440U) {
#line 2405
        return ((REGFI_NK_REC *)((void *)0));
      } else {
#line 2400
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 2400
    if (ret_val->mtime.high > 50623811U) {
#line 2400
      if (ret_val->mtime.low > 3356114944U) {
#line 2405
        return ((REGFI_NK_REC *)((void *)0));
      }
    }
  }
#line 2407
  ret_val->unknown1 = ((unsigned int )*((unsigned char const   *)(nk_header) + 12) | ((unsigned int )*((unsigned char const   *)(nk_header) + 13) << 8)) | (((unsigned int )*((unsigned char const   *)(nk_header) + 14) | ((unsigned int )*((unsigned char const   *)(nk_header) + 15) << 8)) << 16);
#line 2408
  ret_val->parent_off = ((unsigned int )*((unsigned char const   *)(nk_header) + 16) | ((unsigned int )*((unsigned char const   *)(nk_header) + 17) << 8)) | (((unsigned int )*((unsigned char const   *)(nk_header) + 18) | ((unsigned int )*((unsigned char const   *)(nk_header) + 19) << 8)) << 16);
#line 2409
  ret_val->num_subkeys = ((unsigned int )*((unsigned char const   *)(nk_header) + 20) | ((unsigned int )*((unsigned char const   *)(nk_header) + 21) << 8)) | (((unsigned int )*((unsigned char const   *)(nk_header) + 22) | ((unsigned int )*((unsigned char const   *)(nk_header) + 23) << 8)) << 16);
#line 2410
  ret_val->unknown2 = ((unsigned int )*((unsigned char const   *)(nk_header) + 24) | ((unsigned int )*((unsigned char const   *)(nk_header) + 25) << 8)) | (((unsigned int )*((unsigned char const   *)(nk_header) + 26) | ((unsigned int )*((unsigned char const   *)(nk_header) + 27) << 8)) << 16);
#line 2411
  ret_val->subkeys_off = ((unsigned int )*((unsigned char const   *)(nk_header) + 28) | ((unsigned int )*((unsigned char const   *)(nk_header) + 29) << 8)) | (((unsigned int )*((unsigned char const   *)(nk_header) + 30) | ((unsigned int )*((unsigned char const   *)(nk_header) + 31) << 8)) << 16);
#line 2412
  ret_val->unknown3 = ((unsigned int )*((unsigned char const   *)(nk_header) + 32) | ((unsigned int )*((unsigned char const   *)(nk_header) + 33) << 8)) | (((unsigned int )*((unsigned char const   *)(nk_header) + 34) | ((unsigned int )*((unsigned char const   *)(nk_header) + 35) << 8)) << 16);
#line 2413
  ret_val->num_values = ((unsigned int )*((unsigned char const   *)(nk_header) + 36) | ((unsigned int )*((unsigned char const   *)(nk_header) + 37) << 8)) | (((unsigned int )*((unsigned char const   *)(nk_header) + 38) | ((unsigned int )*((unsigned char const   *)(nk_header) + 39) << 8)) << 16);
#line 2414
  ret_val->values_off = ((unsigned int )*((unsigned char const   *)(nk_header) + 40) | ((unsigned int )*((unsigned char const   *)(nk_header) + 41) << 8)) | (((unsigned int )*((unsigned char const   *)(nk_header) + 42) | ((unsigned int )*((unsigned char const   *)(nk_header) + 43) << 8)) << 16);
#line 2415
  ret_val->sk_off = ((unsigned int )*((unsigned char const   *)(nk_header) + 44) | ((unsigned int )*((unsigned char const   *)(nk_header) + 45) << 8)) | (((unsigned int )*((unsigned char const   *)(nk_header) + 46) | ((unsigned int )*((unsigned char const   *)(nk_header) + 47) << 8)) << 16);
#line 2416
  ret_val->classname_off = ((unsigned int )*((unsigned char const   *)(nk_header) + 48) | ((unsigned int )*((unsigned char const   *)(nk_header) + 49) << 8)) | (((unsigned int )*((unsigned char const   *)(nk_header) + 50) | ((unsigned int )*((unsigned char const   *)(nk_header) + 51) << 8)) << 16);
#line 2418
  ret_val->max_bytes_subkeyname = ((unsigned int )*((unsigned char const   *)(nk_header) + 52) | ((unsigned int )*((unsigned char const   *)(nk_header) + 53) << 8)) | (((unsigned int )*((unsigned char const   *)(nk_header) + 54) | ((unsigned int )*((unsigned char const   *)(nk_header) + 55) << 8)) << 16);
#line 2419
  ret_val->max_bytes_subkeyclassname = ((unsigned int )*((unsigned char const   *)(nk_header) + 56) | ((unsigned int )*((unsigned char const   *)(nk_header) + 57) << 8)) | (((unsigned int )*((unsigned char const   *)(nk_header) + 58) | ((unsigned int )*((unsigned char const   *)(nk_header) + 59) << 8)) << 16);
#line 2420
  ret_val->max_bytes_valuename = ((unsigned int )*((unsigned char const   *)(nk_header) + 60) | ((unsigned int )*((unsigned char const   *)(nk_header) + 61) << 8)) | (((unsigned int )*((unsigned char const   *)(nk_header) + 62) | ((unsigned int )*((unsigned char const   *)(nk_header) + 63) << 8)) << 16);
#line 2421
  ret_val->max_bytes_value = ((unsigned int )*((unsigned char const   *)(nk_header) + 64) | ((unsigned int )*((unsigned char const   *)(nk_header) + 65) << 8)) | (((unsigned int )*((unsigned char const   *)(nk_header) + 66) | ((unsigned int )*((unsigned char const   *)(nk_header) + 67) << 8)) << 16);
#line 2422
  ret_val->unk_index = ((unsigned int )*((unsigned char const   *)(nk_header) + 68) | ((unsigned int )*((unsigned char const   *)(nk_header) + 69) << 8)) | (((unsigned int )*((unsigned char const   *)(nk_header) + 70) | ((unsigned int )*((unsigned char const   *)(nk_header) + 71) << 8)) << 16);
#line 2424
  ret_val->name_length = (uint16_t )((unsigned int )*((unsigned char const   *)(nk_header) + 72) | ((unsigned int )*((unsigned char const   *)(nk_header) + 73) << 8));
#line 2425
  ret_val->classname_length = (uint16_t )((unsigned int )*((unsigned char const   *)(nk_header) + 74) | ((unsigned int )*((unsigned char const   *)(nk_header) + 75) << 8));
#line 2426
  ret_val->keyname = (char *)((void *)0);
#line 2428
  if ((uint32_t )((int )ret_val->name_length + 76) > ret_val->cell_size) {
#line 2430
    if (strict) {
      {
#line 2432
      regfi_add_message(file, (uint16_t )16, "Contents too large for cell while parsing NK record at offset 0x%.8X.",
                        offset);
#line 2434
      talloc_free((void *)ret_val);
      }
#line 2435
      return ((REGFI_NK_REC *)((void *)0));
    } else {
#line 2438
      ret_val->name_length = (uint16_t )(ret_val->cell_size - 76U);
    }
  } else
#line 2440
  if (unalloc) {
#line 2443
    length = (unsigned int )((int )ret_val->name_length + 76) & 4294967288U;
#line 2444
    if (length < (uint32_t )((int )ret_val->name_length + 76)) {
#line 2445
      length += 8U;
    }
#line 2448
    if (length < ret_val->cell_size) {
#line 2449
      ret_val->cell_size = length;
    }
  }
  {
#line 2452
  tmp___1 = _talloc_array((void const   *)ret_val, sizeof(uint8_t ), (unsigned int )ret_val->name_length,
                          "uint8_t");
#line 2452
  ret_val->keyname_raw = (uint8_t *)tmp___1;
  }
#line 2453
  if ((unsigned long )ret_val->keyname_raw == (unsigned long )((void *)0)) {
    {
#line 2455
    talloc_free((void *)ret_val);
    }
#line 2456
    return ((REGFI_NK_REC *)((void *)0));
  }
  {
#line 2460
  length = (uint32_t )ret_val->name_length;
#line 2461
  tmp___2 = regfi_read(file->fd, ret_val->keyname_raw, & length);
  }
#line 2461
  if (tmp___2 != 0U) {
    {
#line 2464
    regfi_add_message(file, (uint16_t )16, "Failed to read key name while parsing NK record at offset 0x%.8X.",
                      offset);
#line 2466
    talloc_free((void *)ret_val);
    }
#line 2467
    return ((REGFI_NK_REC *)((void *)0));
  } else
#line 2461
  if (length != (uint32_t )ret_val->name_length) {
    {
#line 2464
    regfi_add_message(file, (uint16_t )16, "Failed to read key name while parsing NK record at offset 0x%.8X.",
                      offset);
#line 2466
    talloc_free((void *)ret_val);
    }
#line 2467
    return ((REGFI_NK_REC *)((void *)0));
  }
#line 2470
  return (ret_val);
}
}
#line 2474 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
uint8_t *regfi_parse_classname(REGFI_FILE *file , uint32_t offset , uint16_t *name_length ,
                               uint32_t max_size , _Bool strict ) 
{ 
  uint8_t *ret_val ;
  uint32_t length ;
  uint32_t cell_length ;
  _Bool unalloc ;
  _Bool tmp ;
  void *tmp___0 ;
  uint32_t tmp___1 ;

  {
#line 2477
  ret_val = (uint8_t *)((void *)0);
#line 2480
  unalloc = (_Bool)0;
#line 2482
  if ((int )*name_length > 0) {
#line 2482
    if (offset != 4294967295U) {
#line 2482
      if ((offset & 7U) == 0U) {
        {
#line 2485
        tmp = regfi_parse_cell(file->fd, offset, (uint8_t *)((void *)0), (uint32_t )0,
                               & cell_length, & unalloc);
        }
#line 2485
        if (! tmp) {
          {
#line 2487
          regfi_add_message(file, (uint16_t )4, "Could not parse cell header while parsing class name at offset 0x%.8X.",
                            offset);
          }
#line 2489
          return ((uint8_t *)((void *)0));
        }
#line 2492
        if ((cell_length & 7U) != 0U) {
          {
#line 2494
          regfi_add_message(file, (uint16_t )16, "Cell length not a multiple of 8 while parsing class name at offset 0x%.8X.",
                            offset);
          }
#line 2496
          return ((uint8_t *)((void *)0));
        }
#line 2499
        if (cell_length > max_size) {
          {
#line 2501
          regfi_add_message(file, (uint16_t )4, "Cell stretches past hbin boundary while parsing class name at offset 0x%.8X.",
                            offset);
          }
#line 2504
          if (strict) {
#line 2505
            return ((uint8_t *)((void *)0));
          }
#line 2506
          cell_length = max_size;
        }
#line 2509
        if (cell_length - 4U < (uint32_t )*name_length) {
          {
#line 2511
          regfi_add_message(file, (uint16_t )4, "Class name is larger than cell_length while parsing class name at offset 0x%.8X.",
                            offset);
          }
#line 2514
          if (strict) {
#line 2515
            return ((uint8_t *)((void *)0));
          }
#line 2516
          *name_length = (uint16_t )(cell_length - 4U);
        }
        {
#line 2519
        tmp___0 = _talloc_array((void const   *)((void *)0), sizeof(uint8_t ), (unsigned int )*name_length,
                                "uint8_t");
#line 2519
        ret_val = (uint8_t *)tmp___0;
        }
#line 2520
        if ((unsigned long )ret_val != (unsigned long )((void *)0)) {
          {
#line 2522
          length = (uint32_t )*name_length;
#line 2523
          tmp___1 = regfi_read(file->fd, ret_val, & length);
          }
#line 2523
          if (tmp___1 != 0U) {
            {
#line 2526
            regfi_add_message(file, (uint16_t )16, "Could not read class name while parsing class name at offset 0x%.8X.",
                              offset);
#line 2528
            talloc_free((void *)ret_val);
            }
#line 2529
            return ((uint8_t *)((void *)0));
          } else
#line 2523
          if (length != (uint32_t )*name_length) {
            {
#line 2526
            regfi_add_message(file, (uint16_t )16, "Could not read class name while parsing class name at offset 0x%.8X.",
                              offset);
#line 2528
            talloc_free((void *)ret_val);
            }
#line 2529
            return ((uint8_t *)((void *)0));
          }
        }
      }
    }
  }
#line 2534
  return (ret_val);
}
}
#line 2540 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
REGFI_VK_REC *regfi_parse_vk(REGFI_FILE *file , uint32_t offset , uint32_t max_size ,
                             _Bool strict ) 
{ 
  REGFI_VK_REC *ret_val ;
  uint8_t vk_header[20] ;
  uint32_t raw_data_size ;
  uint32_t length ;
  uint32_t cell_length ;
  _Bool unalloc ;
  _Bool tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  uint32_t tmp___2 ;

  {
  {
#line 2546
  unalloc = (_Bool)0;
#line 2548
  tmp = regfi_parse_cell(file->fd, offset, vk_header, (uint32_t )20, & cell_length,
                         & unalloc);
  }
#line 2548
  if (! tmp) {
    {
#line 2551
    regfi_add_message(file, (uint16_t )4, "Could not parse cell header while parsing VK record at offset 0x%.8X.",
                      offset);
    }
#line 2553
    return ((REGFI_VK_REC *)((void *)0));
  }
  {
#line 2556
  tmp___0 = talloc_named_const((void const   *)((void *)0), sizeof(REGFI_VK_REC ),
                               "REGFI_VK_REC");
#line 2556
  ret_val = (REGFI_VK_REC *)tmp___0;
  }
#line 2557
  if ((unsigned long )ret_val == (unsigned long )((void *)0)) {
#line 2558
    return ((REGFI_VK_REC *)((void *)0));
  }
#line 2560
  ret_val->offset = offset;
#line 2561
  ret_val->cell_size = cell_length;
#line 2562
  ret_val->valuename = (char *)((void *)0);
#line 2563
  ret_val->valuename_raw = (uint8_t *)((void *)0);
#line 2565
  if (ret_val->cell_size > max_size) {
#line 2566
    ret_val->cell_size = max_size & 4294967288U;
  }
#line 2567
  if (ret_val->cell_size < 20U) {
    {
#line 2570
    regfi_add_message(file, (uint16_t )4, "Invalid cell size encountered while parsing VK record at offset 0x%.8X.",
                      offset);
#line 2572
    talloc_free((void *)ret_val);
    }
#line 2573
    return ((REGFI_VK_REC *)((void *)0));
  } else
#line 2567
  if ((ret_val->cell_size & 7U) != 0U) {
    {
#line 2570
    regfi_add_message(file, (uint16_t )4, "Invalid cell size encountered while parsing VK record at offset 0x%.8X.",
                      offset);
#line 2572
    talloc_free((void *)ret_val);
    }
#line 2573
    return ((REGFI_VK_REC *)((void *)0));
  }
#line 2576
  ret_val->magic[0] = vk_header[0];
#line 2577
  ret_val->magic[1] = vk_header[1];
#line 2578
  if ((int )ret_val->magic[0] != 118) {
    {
#line 2584
    regfi_add_message(file, (uint16_t )4, "Magic number mismatch while parsing VK record at offset 0x%.8X.",
                      offset);
#line 2586
    talloc_free((void *)ret_val);
    }
#line 2587
    return ((REGFI_VK_REC *)((void *)0));
  } else
#line 2578
  if ((int )ret_val->magic[1] != 107) {
    {
#line 2584
    regfi_add_message(file, (uint16_t )4, "Magic number mismatch while parsing VK record at offset 0x%.8X.",
                      offset);
#line 2586
    talloc_free((void *)ret_val);
    }
#line 2587
    return ((REGFI_VK_REC *)((void *)0));
  }
#line 2590
  ret_val->name_length = (uint16_t )((unsigned int )*((unsigned char const   *)(vk_header) + 2) | ((unsigned int )*((unsigned char const   *)(vk_header) + 3) << 8));
#line 2591
  raw_data_size = ((unsigned int )*((unsigned char const   *)(vk_header) + 4) | ((unsigned int )*((unsigned char const   *)(vk_header) + 5) << 8)) | (((unsigned int )*((unsigned char const   *)(vk_header) + 6) | ((unsigned int )*((unsigned char const   *)(vk_header) + 7) << 8)) << 16);
#line 2592
  ret_val->data_size = raw_data_size & 2147483647U;
#line 2596
  ret_val->data_in_offset = (_Bool )(raw_data_size & 2147483648U);
#line 2597
  ret_val->data_off = ((unsigned int )*((unsigned char const   *)(vk_header) + 8) | ((unsigned int )*((unsigned char const   *)(vk_header) + 9) << 8)) | (((unsigned int )*((unsigned char const   *)(vk_header) + 10) | ((unsigned int )*((unsigned char const   *)(vk_header) + 11) << 8)) << 16);
#line 2598
  ret_val->type = ((unsigned int )*((unsigned char const   *)(vk_header) + 12) | ((unsigned int )*((unsigned char const   *)(vk_header) + 13) << 8)) | (((unsigned int )*((unsigned char const   *)(vk_header) + 14) | ((unsigned int )*((unsigned char const   *)(vk_header) + 15) << 8)) << 16);
#line 2599
  ret_val->flags = (uint16_t )((unsigned int )*((unsigned char const   *)(vk_header) + 16) | ((unsigned int )*((unsigned char const   *)(vk_header) + 17) << 8));
#line 2600
  ret_val->unknown1 = (uint16_t )((unsigned int )*((unsigned char const   *)(vk_header) + 18) | ((unsigned int )*((unsigned char const   *)(vk_header) + 19) << 8));
#line 2602
  if ((int )ret_val->name_length > 0) {
#line 2604
    if ((uint32_t )(((int )ret_val->name_length + 20) + 4) > ret_val->cell_size) {
      {
#line 2606
      regfi_add_message(file, (uint16_t )4, "Name too long for remaining cell space while parsing VK record at offset 0x%.8X.",
                        offset);
      }
#line 2609
      if (strict) {
        {
#line 2611
        talloc_free((void *)ret_val);
        }
#line 2612
        return ((REGFI_VK_REC *)((void *)0));
      } else {
#line 2615
        ret_val->name_length = (uint16_t )((ret_val->cell_size - 20U) - 4U);
      }
    }
#line 2619
    cell_length = (unsigned int )(((int )ret_val->name_length + 20) + 4) & 4294967288U;
#line 2620
    if (cell_length < (uint32_t )(((int )ret_val->name_length + 20) + 4)) {
#line 2621
      cell_length += 8U;
    }
    {
#line 2623
    tmp___1 = _talloc_array((void const   *)ret_val, sizeof(uint8_t ), (unsigned int )ret_val->name_length,
                            "uint8_t");
#line 2623
    ret_val->valuename_raw = (uint8_t *)tmp___1;
    }
#line 2624
    if ((unsigned long )ret_val->valuename_raw == (unsigned long )((void *)0)) {
      {
#line 2626
      talloc_free((void *)ret_val);
      }
#line 2627
      return ((REGFI_VK_REC *)((void *)0));
    }
    {
#line 2630
    length = (uint32_t )ret_val->name_length;
#line 2631
    tmp___2 = regfi_read(file->fd, ret_val->valuename_raw, & length);
    }
#line 2631
    if (tmp___2 != 0U) {
      {
#line 2634
      regfi_add_message(file, (uint16_t )16, "Could not read value name while parsing VK record at offset 0x%.8X.",
                        offset);
#line 2636
      talloc_free((void *)ret_val);
      }
#line 2637
      return ((REGFI_VK_REC *)((void *)0));
    } else
#line 2631
    if (length != (uint32_t )ret_val->name_length) {
      {
#line 2634
      regfi_add_message(file, (uint16_t )16, "Could not read value name while parsing VK record at offset 0x%.8X.",
                        offset);
#line 2636
      talloc_free((void *)ret_val);
      }
#line 2637
      return ((REGFI_VK_REC *)((void *)0));
    }
  } else {
#line 2641
    cell_length = (uint32_t )24;
  }
#line 2643
  if (unalloc) {
#line 2646
    if (cell_length < ret_val->cell_size) {
#line 2647
      ret_val->cell_size = cell_length;
    }
  }
#line 2650
  return (ret_val);
}
}
#line 2657 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
REGFI_BUFFER regfi_load_data(REGFI_FILE *file , uint32_t voffset , uint32_t length ,
                             _Bool data_in_offset , _Bool strict ) 
{ 
  REGFI_BUFFER ret_val ;
  uint32_t cell_length ;
  uint32_t offset ;
  int32_t max_size ;
  _Bool unalloc ;
  REGFI_BUFFER tmp ;
  _Bool tmp___0 ;
  REGFI_BUFFER tmp___1 ;

  {
#line 2679
  if (length > 1048576U) {
    {
#line 2681
    regfi_add_message(file, (uint16_t )4, "Value data size %d larger than %d, truncating...",
                      length, 1048576);
#line 2683
    length = (uint32_t )1048576;
    }
  }
#line 2686
  if (data_in_offset) {
    {
#line 2687
    tmp = regfi_parse_little_data(file, voffset, length, strict);
    }
#line 2687
    return (tmp);
  } else {
    {
#line 2690
    offset = voffset + 4096U;
#line 2691
    max_size = regfi_calc_maxsize(file, offset);
    }
#line 2692
    if (max_size < 0) {
      {
#line 2694
      regfi_add_message(file, (uint16_t )4, "Could not find HBIN for data at offset 0x%.8X.",
                        offset);
      }
#line 2696
      goto fail;
    }
    {
#line 2699
    tmp___0 = regfi_parse_cell(file->fd, offset, (uint8_t *)((void *)0), (uint32_t )0,
                               & cell_length, & unalloc);
    }
#line 2699
    if (! tmp___0) {
      {
#line 2702
      regfi_add_message(file, (uint16_t )4, "Could not parse cell while parsing data record at offset 0x%.8X.",
                        offset);
      }
#line 2704
      goto fail;
    }
#line 2707
    if ((cell_length & 7U) != 0U) {
      {
#line 2709
      regfi_add_message(file, (uint16_t )4, "Cell length not multiple of 8 while parsing data record at offset 0x%.8X.",
                        offset);
      }
#line 2712
      goto fail;
    }
#line 2715
    if (cell_length > (uint32_t )max_size) {
      {
#line 2717
      regfi_add_message(file, (uint16_t )4, "Cell extends past HBIN boundary while parsing data record at offset 0x%.8X.",
                        offset);
      }
#line 2720
      goto fail;
    }
#line 2723
    if (cell_length - 4U < length) {
#line 2729
      if (file->major_version >= 1U) {
#line 2729
        if (file->minor_version >= 5U) {
          {
#line 2732
          tmp___1 = regfi_load_big_data(file, offset, length, cell_length, (range_list *)((void *)0),
                                        strict);
          }
#line 2732
          return (tmp___1);
        } else {
#line 2729
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
#line 2737
        regfi_add_message(file, (uint16_t )4, "Data length (0x%.8X) larger than remaining cell length (0x%.8X) while parsing data record at offset 0x%.8X.",
                          length, cell_length - 4U, offset);
        }
#line 2741
        if (strict) {
#line 2742
          goto fail;
        } else {
#line 2744
          length = cell_length - 4U;
        }
      }
    }
    {
#line 2748
    ret_val = regfi_parse_data(file, offset, length, strict);
    }
  }
#line 2751
  return (ret_val);
  fail: 
#line 2754
  ret_val.buf = (uint8_t *)((void *)0);
#line 2755
  ret_val.len = (uint32_t )0;
#line 2756
  return (ret_val);
}
}
#line 2763 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
REGFI_BUFFER regfi_parse_data(REGFI_FILE *file , uint32_t offset , uint32_t length ,
                              _Bool strict ) 
{ 
  REGFI_BUFFER ret_val ;
  uint32_t read_length ;
  __off_t tmp ;
  void *tmp___0 ;
  uint32_t tmp___1 ;

  {
  {
#line 2769
  ret_val.buf = (uint8_t *)((void *)0);
#line 2770
  ret_val.len = (uint32_t )0;
#line 2772
  tmp = lseek(file->fd, (__off_t )(offset + 4U), 0);
  }
#line 2772
  if (tmp == -1L) {
    {
#line 2774
    regfi_add_message(file, (uint16_t )4, "Could not seek while reading data at offset 0x%.8X.",
                      offset);
    }
#line 2776
    return (ret_val);
  }
  {
#line 2779
  tmp___0 = _talloc_array((void const   *)((void *)0), sizeof(uint8_t ), length, "uint8_t");
#line 2779
  ret_val.buf = (uint8_t *)tmp___0;
  }
#line 2779
  if ((unsigned long )ret_val.buf == (unsigned long )((void *)0)) {
#line 2780
    return (ret_val);
  }
  {
#line 2781
  ret_val.len = length;
#line 2783
  read_length = length;
#line 2784
  tmp___1 = regfi_read(file->fd, ret_val.buf, & read_length);
  }
#line 2784
  if (tmp___1 != 0U) {
    {
#line 2787
    regfi_add_message(file, (uint16_t )16, "Could not read data block while parsing data record at offset 0x%.8X.",
                      offset);
#line 2789
    talloc_free((void *)ret_val.buf);
#line 2790
    ret_val.buf = (uint8_t *)((void *)0);
#line 2791
    ret_val.buf = (uint8_t *)0;
    }
  } else
#line 2784
  if (read_length != length) {
    {
#line 2787
    regfi_add_message(file, (uint16_t )16, "Could not read data block while parsing data record at offset 0x%.8X.",
                      offset);
#line 2789
    talloc_free((void *)ret_val.buf);
#line 2790
    ret_val.buf = (uint8_t *)((void *)0);
#line 2791
    ret_val.buf = (uint8_t *)0;
    }
  }
#line 2794
  return (ret_val);
}
}
#line 2802 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
REGFI_BUFFER regfi_parse_little_data(REGFI_FILE *file , uint32_t voffset , uint32_t length ,
                                     _Bool strict ) 
{ 
  uint8_t i ;
  REGFI_BUFFER ret_val ;
  void *tmp ;

  {
#line 2808
  ret_val.buf = (uint8_t *)((void *)0);
#line 2809
  ret_val.len = (uint32_t )0;
#line 2811
  if (length > 4U) {
    {
#line 2813
    regfi_add_message(file, (uint16_t )16, "Data in offset but length > 4 while parsing data record. (voffset=0x%.8X, length=%d)",
                      voffset, length);
    }
#line 2816
    return (ret_val);
  }
  {
#line 2819
  tmp = _talloc_array((void const   *)((void *)0), sizeof(uint8_t ), length, "uint8_t");
#line 2819
  ret_val.buf = (uint8_t *)tmp;
  }
#line 2819
  if ((unsigned long )ret_val.buf == (unsigned long )((void *)0)) {
#line 2820
    return (ret_val);
  }
#line 2821
  ret_val.len = length;
#line 2823
  i = (uint8_t )0;
  {
#line 2823
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2823
    if (! ((uint32_t )i < length)) {
#line 2823
      goto while_break;
    }
#line 2824
    *(ret_val.buf + i) = (uint8_t )((voffset >> (int )i * 8) & 255U);
#line 2823
    i = (uint8_t )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 2826
  return (ret_val);
}
}
#line 2831 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
REGFI_BUFFER regfi_parse_big_data_header(REGFI_FILE *file , uint32_t offset , uint32_t max_size ,
                                         _Bool strict ) 
{ 
  REGFI_BUFFER ret_val ;
  uint32_t cell_length ;
  _Bool unalloc ;
  void *tmp ;
  _Bool tmp___0 ;

  {
  {
#line 2839
  tmp = _talloc_array((void const   *)((void *)0), sizeof(uint8_t ), 12U, "uint8_t");
#line 2839
  ret_val.buf = (uint8_t *)tmp;
  }
#line 2840
  if ((unsigned long )ret_val.buf == (unsigned long )((void *)0)) {
#line 2841
    goto fail;
  }
#line 2843
  if (12U > max_size) {
    {
#line 2845
    regfi_add_message(file, (uint16_t )4, "Big data header exceeded max_size while parsing big data header at offset 0x%.8X.",
                      offset);
    }
#line 2847
    goto fail;
  }
  {
#line 2850
  tmp___0 = regfi_parse_cell(file->fd, offset, ret_val.buf, (uint32_t )12, & cell_length,
                             & unalloc);
  }
#line 2850
  if (! tmp___0) {
    {
#line 2853
    regfi_add_message(file, (uint16_t )4, "Could not parse cell while parsing big data header at offset 0x%.8X.",
                      offset);
    }
#line 2855
    goto fail;
  }
#line 2858
  if ((int )*(ret_val.buf + 0) != 100) {
    {
#line 2860
    regfi_add_message(file, (uint16_t )4, "Unknown magic number (0x%.2X, 0x%.2X) encountered while parsing big data header at offset 0x%.8X.",
                      (int )*(ret_val.buf + 0), (int )*(ret_val.buf + 1), offset);
    }
#line 2864
    goto fail;
  } else
#line 2858
  if ((int )*(ret_val.buf + 1) != 98) {
    {
#line 2860
    regfi_add_message(file, (uint16_t )4, "Unknown magic number (0x%.2X, 0x%.2X) encountered while parsing big data header at offset 0x%.8X.",
                      (int )*(ret_val.buf + 0), (int )*(ret_val.buf + 1), offset);
    }
#line 2864
    goto fail;
  }
#line 2867
  ret_val.len = (uint32_t )12;
#line 2868
  return (ret_val);
  fail: 
#line 2871
  if ((unsigned long )ret_val.buf != (unsigned long )((void *)0)) {
    {
#line 2873
    talloc_free((void *)ret_val.buf);
#line 2874
    ret_val.buf = (uint8_t *)((void *)0);
    }
  }
#line 2876
  ret_val.len = (uint32_t )0;
#line 2877
  return (ret_val);
}
}
#line 2885 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
uint32_t *regfi_parse_big_data_indirect(REGFI_FILE *file , uint32_t offset , uint16_t num_chunks ,
                                        _Bool strict ) 
{ 
  uint32_t *ret_val ;
  uint32_t indirect_length ;
  int32_t max_size ;
  uint16_t i ;
  _Bool unalloc ;
  void *tmp ;
  _Bool tmp___0 ;

  {
  {
#line 2896
  max_size = regfi_calc_maxsize(file, offset);
  }
#line 2897
  if (max_size < 0) {
#line 2898
    return ((uint32_t *)((void *)0));
  } else
#line 2897
  if ((unsigned long )num_chunks * sizeof(uint32_t ) + 4UL > (unsigned long )max_size) {
#line 2898
    return ((uint32_t *)((void *)0));
  }
  {
#line 2900
  tmp = _talloc_array((void const   *)((void *)0), sizeof(uint32_t ), (unsigned int )num_chunks,
                      "uint32_t");
#line 2900
  ret_val = (uint32_t *)tmp;
  }
#line 2901
  if ((unsigned long )ret_val == (unsigned long )((void *)0)) {
#line 2902
    goto fail;
  }
  {
#line 2904
  tmp___0 = regfi_parse_cell(file->fd, offset, (uint8_t *)ret_val, (uint32_t )((unsigned long )num_chunks * sizeof(uint32_t )),
                             & indirect_length, & unalloc);
  }
#line 2904
  if (! tmp___0) {
    {
#line 2908
    regfi_add_message(file, (uint16_t )4, "Could not parse cell while parsing big data indirect record at offset 0x%.8X.",
                      offset);
    }
#line 2911
    goto fail;
  }
#line 2915
  i = (uint16_t )0;
  {
#line 2915
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2915
    if (! ((int )i < (int )num_chunks)) {
#line 2915
      goto while_break;
    }
#line 2917
    *(ret_val + i) = ((unsigned int )*((unsigned char const   *)ret_val + (unsigned long )i * sizeof(uint32_t )) | ((unsigned int )*((unsigned char const   *)ret_val + ((unsigned long )i * sizeof(uint32_t ) + 1UL)) << 8)) | (((unsigned int )*((unsigned char const   *)ret_val + ((unsigned long )i * sizeof(uint32_t ) + 2UL)) | ((unsigned int )*((unsigned char const   *)ret_val + (((unsigned long )i * sizeof(uint32_t ) + 2UL) + 1UL)) << 8)) << 16);
#line 2918
    if ((*(ret_val + i) & 7U) != 0U) {
#line 2919
      goto fail;
    }
#line 2915
    i = (uint16_t )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 2922
  return (ret_val);
  fail: 
#line 2925
  if ((unsigned long )ret_val != (unsigned long )((void *)0)) {
    {
#line 2926
    talloc_free((void *)ret_val);
    }
  }
#line 2927
  return ((uint32_t *)((void *)0));
}
}
#line 2943 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
range_list *regfi_parse_big_data_cells(REGFI_FILE *file , uint32_t *offsets , uint16_t num_chunks ,
                                       _Bool strict ) 
{ 
  uint32_t cell_length ;
  uint32_t chunk_offset ;
  range_list *ret_val ;
  uint16_t i ;
  _Bool unalloc ;
  _Bool tmp ;
  _Bool tmp___0 ;

  {
  {
#line 2952
  ret_val = range_list_new();
  }
#line 2953
  if ((unsigned long )ret_val == (unsigned long )((void *)0)) {
#line 2954
    goto fail;
  }
#line 2956
  i = (uint16_t )0;
  {
#line 2956
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2956
    if (! ((int )i < (int )num_chunks)) {
#line 2956
      goto while_break;
    }
    {
#line 2958
    chunk_offset = *(offsets + i) + 4096U;
#line 2959
    tmp = regfi_parse_cell(file->fd, chunk_offset, (uint8_t *)((void *)0), (uint32_t )0,
                           & cell_length, & unalloc);
    }
#line 2959
    if (! tmp) {
      {
#line 2962
      regfi_add_message(file, (uint16_t )4, "Could not parse cell while parsing big data chunk at offset 0x%.8X.",
                        chunk_offset);
      }
#line 2965
      goto fail;
    }
    {
#line 2968
    tmp___0 = range_list_add(ret_val, chunk_offset, cell_length, (void *)0);
    }
#line 2968
    if (! tmp___0) {
#line 2969
      goto fail;
    }
#line 2956
    i = (uint16_t )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 2972
  return (ret_val);
  fail: 
#line 2975
  if ((unsigned long )ret_val != (unsigned long )((void *)0)) {
    {
#line 2976
    range_list_free(ret_val);
    }
  }
#line 2977
  return ((range_list *)((void *)0));
}
}
#line 2983 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
REGFI_BUFFER regfi_load_big_data(REGFI_FILE *file , uint32_t offset , uint32_t data_length ,
                                 uint32_t cell_length , range_list *used_ranges ,
                                 _Bool strict ) 
{ 
  REGFI_BUFFER ret_val ;
  uint16_t num_chunks ;
  uint16_t i ;
  uint32_t read_length ;
  uint32_t data_left ;
  uint32_t tmp_len ;
  uint32_t indirect_offset ;
  uint32_t *indirect_ptrs ;
  REGFI_BUFFER bd_header ;
  range_list *bd_cells ;
  range_list_element const   *cell_info ;
  _Bool tmp ;
  _Bool tmp___0 ;
  void *tmp___1 ;
  int32_t tmp___2 ;
  __off_t tmp___3 ;
  uint32_t tmp___4 ;
  _Bool tmp___5 ;

  {
  {
#line 2991
  indirect_ptrs = (uint32_t *)((void *)0);
#line 2993
  bd_cells = (range_list *)((void *)0);
#line 2996
  ret_val.buf = (uint8_t *)((void *)0);
#line 3000
  bd_header = regfi_parse_big_data_header(file, offset, cell_length, strict);
  }
#line 3001
  if ((unsigned long )bd_header.buf == (unsigned long )((void *)0)) {
#line 3002
    goto fail;
  }
#line 3005
  if ((unsigned long )used_ranges != (unsigned long )((void *)0)) {
    {
#line 3006
    tmp = range_list_add(used_ranges, offset, cell_length, (void *)0);
    }
#line 3006
    if (! tmp) {
#line 3007
      goto fail;
    }
  }
  {
#line 3009
  num_chunks = (uint16_t )((unsigned int )*((unsigned char const   *)bd_header.buf + 2) | ((unsigned int )*((unsigned char const   *)bd_header.buf + 3) << 8));
#line 3010
  indirect_offset = (((unsigned int )*((unsigned char const   *)bd_header.buf + 4) | ((unsigned int )*((unsigned char const   *)bd_header.buf + 5) << 8)) | (((unsigned int )*((unsigned char const   *)bd_header.buf + 6) | ((unsigned int )*((unsigned char const   *)bd_header.buf + 7) << 8)) << 16)) + 4096U;
#line 3011
  talloc_free((void *)bd_header.buf);
#line 3013
  indirect_ptrs = regfi_parse_big_data_indirect(file, indirect_offset, num_chunks,
                                                strict);
  }
#line 3015
  if ((unsigned long )indirect_ptrs == (unsigned long )((void *)0)) {
#line 3016
    goto fail;
  }
#line 3018
  if ((unsigned long )used_ranges != (unsigned long )((void *)0)) {
    {
#line 3019
    tmp___0 = range_list_add(used_ranges, indirect_offset, (uint32_t )((int )num_chunks * 4 + 4),
                             (void *)0);
    }
#line 3019
    if (! tmp___0) {
#line 3020
      goto fail;
    }
  }
  {
#line 3022
  tmp___1 = _talloc_array((void const   *)((void *)0), sizeof(uint8_t ), data_length,
                          "uint8_t");
#line 3022
  ret_val.buf = (uint8_t *)tmp___1;
  }
#line 3022
  if ((unsigned long )ret_val.buf == (unsigned long )((void *)0)) {
#line 3023
    goto fail;
  }
  {
#line 3024
  data_left = data_length;
#line 3026
  bd_cells = regfi_parse_big_data_cells(file, indirect_ptrs, num_chunks, strict);
  }
#line 3027
  if ((unsigned long )bd_cells == (unsigned long )((void *)0)) {
#line 3028
    goto fail;
  }
  {
#line 3030
  talloc_free((void *)indirect_ptrs);
#line 3031
  indirect_ptrs = (uint32_t *)((void *)0);
#line 3033
  i = (uint16_t )0;
  }
  {
#line 3033
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3033
    if ((int )i < (int )num_chunks) {
#line 3033
      if (! (data_left > 0U)) {
#line 3033
        goto while_break;
      }
    } else {
#line 3033
      goto while_break;
    }
    {
#line 3035
    cell_info = range_list_get((range_list const   *)bd_cells, (uint32_t )i);
    }
#line 3036
    if ((unsigned long )cell_info == (unsigned long )((void *)0)) {
#line 3037
      goto fail;
    }
#line 3045
    if (cell_info->length - 8U >= (uint32_t const   )data_left) {
#line 3047
      if ((int )i + 1 != (int )num_chunks) {
        {
#line 3049
        regfi_add_message(file, (uint16_t )4, "Left over chunks detected while constructing big data at offset 0x%.8X (chunk offset 0x%.8X).",
                          offset, cell_info->offset);
        }
      }
#line 3053
      read_length = data_left;
    } else {
#line 3056
      read_length = (uint32_t )(cell_info->length - 8U);
    }
    {
#line 3059
    tmp___2 = regfi_calc_maxsize(file, (uint32_t )cell_info->offset);
    }
#line 3059
    if (read_length > (uint32_t )tmp___2) {
      {
#line 3061
      regfi_add_message(file, (uint16_t )4, "A chunk exceeded the maxsize while constructing big data at offset 0x%.8X (chunk offset 0x%.8X).",
                        offset, cell_info->offset);
      }
#line 3064
      goto fail;
    }
    {
#line 3067
    tmp___3 = lseek(file->fd, (__off_t )((unsigned long )cell_info->offset + sizeof(uint32_t )),
                    0);
    }
#line 3067
    if (tmp___3 == -1L) {
      {
#line 3069
      regfi_add_message(file, (uint16_t )4, "Could not seek to chunk while constructing big data at offset 0x%.8X (chunk offset 0x%.8X).",
                        offset, cell_info->offset);
      }
#line 3072
      goto fail;
    }
    {
#line 3075
    tmp_len = read_length;
#line 3076
    tmp___4 = regfi_read(file->fd, ret_val.buf + (data_length - data_left), & read_length);
    }
#line 3076
    if (tmp___4 != 0U) {
      {
#line 3079
      regfi_add_message(file, (uint16_t )4, "Could not read data chunk while constructing big data at offset 0x%.8X (chunk offset 0x%.8X).",
                        offset, cell_info->offset);
      }
#line 3082
      goto fail;
    } else
#line 3076
    if (read_length != tmp_len) {
      {
#line 3079
      regfi_add_message(file, (uint16_t )4, "Could not read data chunk while constructing big data at offset 0x%.8X (chunk offset 0x%.8X).",
                        offset, cell_info->offset);
      }
#line 3082
      goto fail;
    }
#line 3085
    if ((unsigned long )used_ranges != (unsigned long )((void *)0)) {
      {
#line 3086
      tmp___5 = range_list_add(used_ranges, (uint32_t )cell_info->offset, (uint32_t )cell_info->length,
                               (void *)0);
      }
#line 3086
      if (! tmp___5) {
#line 3087
        goto fail;
      }
    }
#line 3089
    data_left -= read_length;
#line 3033
    i = (uint16_t )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3091
  range_list_free(bd_cells);
#line 3093
  ret_val.len = data_length - data_left;
  }
#line 3094
  return (ret_val);
  fail: 
#line 3097
  if ((unsigned long )ret_val.buf != (unsigned long )((void *)0)) {
    {
#line 3098
    talloc_free((void *)ret_val.buf);
    }
  }
#line 3099
  if ((unsigned long )indirect_ptrs != (unsigned long )((void *)0)) {
    {
#line 3100
    talloc_free((void *)indirect_ptrs);
    }
  }
#line 3101
  if ((unsigned long )bd_cells != (unsigned long )((void *)0)) {
    {
#line 3102
    range_list_free(bd_cells);
    }
  }
#line 3103
  ret_val.buf = (uint8_t *)((void *)0);
#line 3104
  ret_val.len = (uint32_t )0;
#line 3105
  return (ret_val);
}
}
#line 3109 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
range_list *regfi_parse_unalloc_cells(REGFI_FILE *file ) 
{ 
  range_list *ret_val ;
  REGFI_HBIN *hbin ;
  range_list_element const   *hbins_elem ;
  uint32_t i ;
  uint32_t num_hbins ;
  uint32_t curr_off ;
  uint32_t cell_len ;
  _Bool is_unalloc ;
  _Bool tmp ;

  {
  {
#line 3117
  ret_val = range_list_new();
  }
#line 3118
  if ((unsigned long )ret_val == (unsigned long )((void *)0)) {
#line 3119
    return ((range_list *)((void *)0));
  }
  {
#line 3121
  num_hbins = range_list_size((range_list const   *)file->hbins);
#line 3122
  i = (uint32_t )0;
  }
  {
#line 3122
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3122
    if (! (i < num_hbins)) {
#line 3122
      goto while_break;
    }
    {
#line 3124
    hbins_elem = range_list_get((range_list const   *)file->hbins, i);
    }
#line 3125
    if ((unsigned long )hbins_elem == (unsigned long )((void *)0)) {
#line 3126
      goto while_break;
    }
#line 3127
    hbin = (REGFI_HBIN *)hbins_elem->data;
#line 3129
    curr_off = (uint32_t )32;
    {
#line 3130
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3130
      if (! (curr_off < hbin->block_size)) {
#line 3130
        goto while_break___0;
      }
      {
#line 3132
      tmp = regfi_parse_cell(file->fd, hbin->file_off + curr_off, (uint8_t *)((void *)0),
                             (uint32_t )0, & cell_len, & is_unalloc);
      }
#line 3132
      if (! tmp) {
#line 3134
        goto while_break___0;
      }
#line 3136
      if (cell_len == 0U) {
        {
#line 3138
        regfi_add_message(file, (uint16_t )16, "Bad cell length encountered while parsing unallocated cells at offset 0x%.8X.",
                          hbin->file_off + curr_off);
        }
#line 3141
        goto while_break___0;
      } else
#line 3136
      if ((cell_len & 7U) != 0U) {
        {
#line 3138
        regfi_add_message(file, (uint16_t )16, "Bad cell length encountered while parsing unallocated cells at offset 0x%.8X.",
                          hbin->file_off + curr_off);
        }
#line 3141
        goto while_break___0;
      }
#line 3148
      if (curr_off + cell_len >= hbin->block_size) {
#line 3149
        cell_len = hbin->block_size - curr_off;
      }
#line 3151
      if (is_unalloc) {
        {
#line 3152
        range_list_add(ret_val, hbin->file_off + curr_off, cell_len, (void *)0);
        }
      }
#line 3155
      curr_off += cell_len;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3122
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3159
  return (ret_val);
}
}
#line 3169 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
void regfi_unix2nt_time(REGFI_NTTIME *nt , time_t t ) 
{ 
  double d ;

  {
#line 3173
  if (t == 0L) {
#line 3175
    nt->low = (uint32_t )0;
#line 3176
    nt->high = (uint32_t )0;
#line 3177
    return;
  }
#line 3180
  if (t == -1L - (-1L << (sizeof(time_t ) * 8UL - 1UL))) {
#line 3182
    nt->low = 4294967295U;
#line 3183
    nt->high = (uint32_t )2147483647;
#line 3184
    return;
  }
#line 3187
  if (t == -1L) {
#line 3189
    nt->low = 4294967295U;
#line 3190
    nt->high = 4294967295U;
#line 3191
    return;
  }
#line 3201
  d = (double )t;
#line 3202
  d += (((369.0 * 365.25) * (double )24) * (double )60) * (double )60 - (((3.0 * (double )24) * (double )60) * (double )60 + (6.0 * (double )60) * (double )60);
#line 3203
  d *= 1.0e7;
#line 3205
  nt->high = (uint32_t )(d * (1.0 / (4.0 * (double )(1 << 30))));
#line 3206
  nt->low = (uint32_t )(d - ((double )nt->high * 4.0) * (double )(1 << 30));
#line 3207
  return;
}
}
#line 3221 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
time_t regfi_nt2unix_time(REGFI_NTTIME const   *nt ) 
{ 
  double d ;
  time_t ret ;
  time_t l_time_min ;
  time_t l_time_max ;

  {
#line 3227
  l_time_min = -1L << (sizeof(time_t ) * 8UL - 1UL);
#line 3228
  l_time_max = -1L - (-1L << (sizeof(time_t ) * 8UL - 1UL));
#line 3230
  if (nt->high == 0U) {
#line 3231
    return ((time_t )0);
  } else
#line 3230
  if (nt->high == 4294967295U) {
#line 3230
    if (nt->low == 4294967295U) {
#line 3231
      return ((time_t )0);
    }
  }
#line 3233
  d = ((double )nt->high * 4.0) * (double )(1 << 30);
#line 3234
  d += (double )(nt->low & 4293918720U);
#line 3235
  d *= 1.0e-7;
#line 3238
  d -= (((369.0 * 365.25) * (double )24) * (double )60) * (double )60 - (((3.0 * (double )24) * (double )60) * (double )60 + (6.0 * (double )60) * (double )60);
#line 3240
  if (d <= (double )l_time_min) {
#line 3241
    return (l_time_min);
  }
#line 3243
  if (d >= (double )l_time_max) {
#line 3244
    return (l_time_max);
  }
#line 3246
  ret = (time_t )(d + 0.5);
#line 3258
  return (ret);
}
}
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 219 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/include/winsec.h"
WINSEC_DESC *winsec_parse_descriptor(uint8_t const   *buf , uint32_t buf_len ) ;
#line 226
void winsec_free_descriptor(WINSEC_DESC *desc ) ;
#line 239
WINSEC_ACL *winsec_parse_acl(void *talloc_ctx , uint8_t const   *buf , uint32_t buf_len ) ;
#line 246
WINSEC_ACE *winsec_parse_ace(void *talloc_ctx , uint8_t const   *buf , uint32_t buf_len ) ;
#line 253
WINSEC_DOM_SID *winsec_parse_dom_sid(void *talloc_ctx , uint8_t const   *buf , uint32_t buf_len ) ;
#line 268
size_t winsec_sid_size(WINSEC_DOM_SID const   *sid ) ;
#line 274
int winsec_sid_compare_auth(WINSEC_DOM_SID const   *sid1 , WINSEC_DOM_SID const   *sid2 ) ;
#line 280
int winsec_sid_compare(WINSEC_DOM_SID const   *sid1 , WINSEC_DOM_SID const   *sid2 ) ;
#line 286
_Bool winsec_sid_equal(WINSEC_DOM_SID const   *sid1 , WINSEC_DOM_SID const   *sid2 ) ;
#line 292
_Bool winsec_desc_equal(WINSEC_DESC *s1 , WINSEC_DESC *s2 ) ;
#line 298
_Bool winsec_acl_equal(WINSEC_ACL *s1 , WINSEC_ACL *s2 ) ;
#line 304
_Bool winsec_ace_equal(WINSEC_ACE *s1 , WINSEC_ACE *s2 ) ;
#line 310
_Bool winsec_ace_object(uint8_t type ) ;
#line 31 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/winsec.c"
WINSEC_DESC *winsec_parse_descriptor(uint8_t const   *buf , uint32_t buf_len ) 
{ 
  WINSEC_DESC *tmp ;

  {
  {
#line 33
  tmp = winsec_parse_desc((void *)0, buf, buf_len);
  }
#line 33
  return (tmp);
}
}
#line 40 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/winsec.c"
void winsec_free_descriptor(WINSEC_DESC *desc ) 
{ 


  {
  {
#line 42
  talloc_free((void *)desc);
  }
#line 43
  return;
}
}
#line 49 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/winsec.c"
WINSEC_DESC *winsec_parse_desc(void *talloc_ctx , uint8_t const   *buf , uint32_t buf_len ) 
{ 
  WINSEC_DESC *ret_val ;
  void *tmp ;

  {
#line 54
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 55
    return ((WINSEC_DESC *)((void *)0));
  } else
#line 54
  if ((unsigned long )buf_len < 5UL * sizeof(uint32_t )) {
#line 55
    return ((WINSEC_DESC *)((void *)0));
  }
  {
#line 57
  tmp = talloc_named_const((void const   *)talloc_ctx, sizeof(WINSEC_DESC ), "WINSEC_DESC");
#line 57
  ret_val = (WINSEC_DESC *)tmp;
  }
#line 57
  if ((unsigned long )ret_val == (unsigned long )((void *)0)) {
#line 58
    return ((WINSEC_DESC *)((void *)0));
  }
#line 60
  ret_val->revision = (uint8_t )*(buf + 0);
#line 61
  ret_val->sbz1 = (uint8_t )*(buf + 1);
#line 62
  ret_val->control = (uint16_t )((unsigned int )*(buf + 2) | ((unsigned int )*(buf + 3) << 8));
#line 64
  if (! ((int )ret_val->control & 32768)) {
    {
#line 65
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"DEBUG: NOT self-relative!\n");
    }
  }
#line 67
  ret_val->off_owner_sid = ((unsigned int )*(buf + 4) | ((unsigned int )*(buf + 5) << 8)) | (((unsigned int )*(buf + 6) | ((unsigned int )*(buf + 7) << 8)) << 16);
#line 68
  ret_val->off_grp_sid = ((unsigned int )*(buf + 8) | ((unsigned int )*(buf + 9) << 8)) | (((unsigned int )*(buf + 10) | ((unsigned int )*(buf + 11) << 8)) << 16);
#line 69
  ret_val->off_sacl = ((unsigned int )*(buf + 12) | ((unsigned int )*(buf + 13) << 8)) | (((unsigned int )*(buf + 14) | ((unsigned int )*(buf + 15) << 8)) << 16);
#line 70
  ret_val->off_dacl = ((unsigned int )*(buf + 16) | ((unsigned int )*(buf + 17) << 8)) | (((unsigned int )*(buf + 18) | ((unsigned int )*(buf + 19) << 8)) << 16);
#line 75
  if (ret_val->off_owner_sid >= buf_len) {
    {
#line 80
    talloc_free((void *)ret_val);
    }
#line 81
    return ((WINSEC_DESC *)((void *)0));
  } else
#line 75
  if (ret_val->off_grp_sid >= buf_len) {
    {
#line 80
    talloc_free((void *)ret_val);
    }
#line 81
    return ((WINSEC_DESC *)((void *)0));
  } else
#line 75
  if (ret_val->off_sacl >= buf_len) {
    {
#line 80
    talloc_free((void *)ret_val);
    }
#line 81
    return ((WINSEC_DESC *)((void *)0));
  } else
#line 75
  if (ret_val->off_dacl >= buf_len) {
    {
#line 80
    talloc_free((void *)ret_val);
    }
#line 81
    return ((WINSEC_DESC *)((void *)0));
  }
#line 84
  if (ret_val->off_owner_sid == 0U) {
#line 85
    ret_val->owner_sid = (WINSEC_DOM_SID *)((void *)0);
  } else {
    {
#line 88
    ret_val->owner_sid = winsec_parse_dom_sid((void *)ret_val, buf + ret_val->off_owner_sid,
                                              buf_len - ret_val->off_owner_sid);
    }
#line 91
    if ((unsigned long )ret_val->owner_sid == (unsigned long )((void *)0)) {
      {
#line 93
      talloc_free((void *)ret_val);
      }
#line 94
      return ((WINSEC_DESC *)((void *)0));
    }
  }
#line 98
  if (ret_val->off_grp_sid == 0U) {
#line 99
    ret_val->grp_sid = (WINSEC_DOM_SID *)((void *)0);
  } else {
    {
#line 102
    ret_val->grp_sid = winsec_parse_dom_sid((void *)ret_val, buf + ret_val->off_grp_sid,
                                            buf_len - ret_val->off_grp_sid);
    }
#line 104
    if ((unsigned long )ret_val->grp_sid == (unsigned long )((void *)0)) {
      {
#line 106
      talloc_free((void *)ret_val);
      }
#line 107
      return ((WINSEC_DESC *)((void *)0));
    }
  }
#line 111
  if ((int )ret_val->control & 16) {
#line 111
    if (ret_val->off_sacl) {
      {
#line 113
      ret_val->sacl = winsec_parse_acl((void *)ret_val, buf + ret_val->off_sacl, buf_len - ret_val->off_sacl);
      }
#line 115
      if ((unsigned long )ret_val->sacl == (unsigned long )((void *)0)) {
        {
#line 117
        talloc_free((void *)ret_val);
        }
#line 118
        return ((WINSEC_DESC *)((void *)0));
      }
    } else {
#line 122
      ret_val->sacl = (WINSEC_ACL *)((void *)0);
    }
  } else {
#line 122
    ret_val->sacl = (WINSEC_ACL *)((void *)0);
  }
#line 124
  if ((int )ret_val->control & 4) {
#line 124
    if (ret_val->off_dacl != 0U) {
      {
#line 126
      ret_val->dacl = winsec_parse_acl((void *)ret_val, buf + ret_val->off_dacl, buf_len - ret_val->off_dacl);
      }
#line 128
      if ((unsigned long )ret_val->dacl == (unsigned long )((void *)0)) {
        {
#line 130
        talloc_free((void *)ret_val);
        }
#line 131
        return ((WINSEC_DESC *)((void *)0));
      }
    } else {
#line 135
      ret_val->dacl = (WINSEC_ACL *)((void *)0);
    }
  } else {
#line 135
    ret_val->dacl = (WINSEC_ACL *)((void *)0);
  }
#line 137
  return (ret_val);
}
}
#line 144 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/winsec.c"
WINSEC_ACL *winsec_parse_acl(void *talloc_ctx , uint8_t const   *buf , uint32_t buf_len ) 
{ 
  uint32_t i ;
  uint32_t offset ;
  WINSEC_ACL *ret_val ;
  void *tmp ;
  WINSEC_ACE **tmp___0 ;
  void *tmp___1 ;

  {
#line 154
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 155
    return ((WINSEC_ACL *)((void *)0));
  } else
#line 154
  if (buf_len < 8U) {
#line 155
    return ((WINSEC_ACL *)((void *)0));
  }
  {
#line 157
  tmp = talloc_named_const((void const   *)talloc_ctx, sizeof(WINSEC_ACL ), "WINSEC_ACL");
#line 157
  ret_val = (WINSEC_ACL *)tmp;
  }
#line 157
  if ((unsigned long )ret_val == (unsigned long )((void *)0)) {
#line 158
    return ((WINSEC_ACL *)((void *)0));
  }
#line 160
  ret_val->revision = (uint16_t )((unsigned int )*(buf + 0) | ((unsigned int )*(buf + 1) << 8));
#line 161
  ret_val->size = (uint16_t )((unsigned int )*(buf + 2) | ((unsigned int )*(buf + 3) << 8));
#line 162
  ret_val->num_aces = ((unsigned int )*(buf + 4) | ((unsigned int )*(buf + 5) << 8)) | (((unsigned int )*(buf + 6) | ((unsigned int )*(buf + 7) << 8)) << 16);
#line 168
  if ((uint32_t )ret_val->size > buf_len) {
    {
#line 170
    talloc_free((void *)ret_val);
    }
#line 171
    return ((WINSEC_ACL *)((void *)0));
  } else
#line 168
  if (ret_val->num_aces > 4095U) {
    {
#line 170
    talloc_free((void *)ret_val);
    }
#line 171
    return ((WINSEC_ACL *)((void *)0));
  }
  {
#line 178
  tmp___1 = _talloc_array((void const   *)ret_val, sizeof(WINSEC_ACE *), ret_val->num_aces + 1U,
                          "WINSEC_ACE*");
#line 178
  tmp___0 = (WINSEC_ACE **)tmp___1;
#line 178
  ret_val->aces = tmp___0;
  }
#line 178
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
    {
#line 181
    talloc_free((void *)ret_val);
    }
#line 182
    return ((WINSEC_ACL *)((void *)0));
  }
#line 185
  offset = (uint32_t )8;
#line 186
  i = (uint32_t )0;
  {
#line 186
  while (1) {
    while_continue: /* CIL Label */ ;
#line 186
    if (! (i < ret_val->num_aces)) {
#line 186
      goto while_break;
    }
    {
#line 188
    *(ret_val->aces + i) = winsec_parse_ace((void *)ret_val->aces, buf + offset, buf_len - offset);
    }
#line 190
    if ((unsigned long )*(ret_val->aces + i) == (unsigned long )((void *)0)) {
      {
#line 192
      talloc_free((void *)ret_val);
      }
#line 193
      return ((WINSEC_ACL *)((void *)0));
    }
#line 196
    offset += (uint32_t )(*(ret_val->aces + i))->size;
#line 197
    if (offset > buf_len) {
      {
#line 199
      talloc_free((void *)ret_val);
      }
#line 200
      return ((WINSEC_ACL *)((void *)0));
    }
#line 186
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 203
  *(ret_val->aces + ret_val->num_aces) = (WINSEC_ACE *)((void *)0);
#line 205
  return (ret_val);
}
}
#line 212 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/winsec.c"
WINSEC_ACE *winsec_parse_ace(void *talloc_ctx , uint8_t const   *buf , uint32_t buf_len ) 
{ 
  uint32_t offset ;
  WINSEC_ACE *ret_val ;
  void *tmp ;
  _Bool tmp___0 ;

  {
#line 218
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 219
    return ((WINSEC_ACE *)((void *)0));
  } else
#line 218
  if (buf_len < 16U) {
#line 219
    return ((WINSEC_ACE *)((void *)0));
  }
  {
#line 221
  tmp = talloc_named_const((void const   *)talloc_ctx, sizeof(WINSEC_ACE ), "WINSEC_ACE");
#line 221
  ret_val = (WINSEC_ACE *)tmp;
  }
#line 221
  if ((unsigned long )ret_val == (unsigned long )((void *)0)) {
#line 222
    return ((WINSEC_ACE *)((void *)0));
  }
  {
#line 224
  ret_val->type = (uint8_t )*(buf + 0);
#line 225
  ret_val->flags = (uint8_t )*(buf + 1);
#line 226
  ret_val->size = (uint16_t )((unsigned int )*(buf + 2) | ((unsigned int )*(buf + 3) << 8));
#line 227
  ret_val->access_mask = ((unsigned int )*(buf + 4) | ((unsigned int )*(buf + 5) << 8)) | (((unsigned int )*(buf + 6) | ((unsigned int )*(buf + 7) << 8)) << 16);
#line 229
  offset = (uint32_t )8;
#line 232
  tmp___0 = winsec_ace_object(ret_val->type);
  }
#line 232
  if (tmp___0) {
#line 234
    ret_val->obj_flags = ((unsigned int )*(buf + offset) | ((unsigned int )*(buf + (offset + 1U)) << 8)) | (((unsigned int )*(buf + (offset + 2U)) | ((unsigned int )*(buf + ((offset + 2U) + 1U)) << 8)) << 16);
#line 235
    offset += 4U;
#line 237
    if (ret_val->obj_flags & 1U) {
      {
#line 239
      ret_val->obj_guid = winsec_parse_uuid((void *)ret_val, buf + offset, buf_len - offset);
      }
#line 241
      if ((unsigned long )ret_val->obj_guid == (unsigned long )((void *)0)) {
        {
#line 243
        talloc_free((void *)ret_val);
        }
#line 244
        return ((WINSEC_ACE *)((void *)0));
      }
#line 246
      offset = (uint32_t )((unsigned long )offset + sizeof(WINSEC_UUID ));
    } else {
#line 249
      ret_val->obj_guid = (WINSEC_UUID *)((void *)0);
    }
#line 251
    if (ret_val->obj_flags & 2U) {
      {
#line 253
      ret_val->inh_guid = winsec_parse_uuid((void *)ret_val, buf + offset, buf_len - offset);
      }
#line 255
      if ((unsigned long )ret_val->inh_guid == (unsigned long )((void *)0)) {
        {
#line 257
        talloc_free((void *)ret_val);
        }
#line 258
        return ((WINSEC_ACE *)((void *)0));
      }
#line 260
      offset = (uint32_t )((unsigned long )offset + sizeof(WINSEC_UUID ));
    } else {
#line 263
      ret_val->inh_guid = (WINSEC_UUID *)((void *)0);
    }
  }
  {
#line 266
  ret_val->trustee = winsec_parse_dom_sid((void *)ret_val, buf + offset, buf_len - offset);
  }
#line 267
  if ((unsigned long )ret_val->trustee == (unsigned long )((void *)0)) {
    {
#line 269
    talloc_free((void *)ret_val);
    }
#line 270
    return ((WINSEC_ACE *)((void *)0));
  }
#line 273
  return (ret_val);
}
}
#line 280 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/winsec.c"
WINSEC_DOM_SID *winsec_parse_dom_sid(void *talloc_ctx , uint8_t const   *buf , uint32_t buf_len ) 
{ 
  uint32_t i ;
  WINSEC_DOM_SID *ret_val ;
  void *tmp ;

  {
#line 286
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 287
    return ((WINSEC_DOM_SID *)((void *)0));
  } else
#line 286
  if (buf_len < 8U) {
#line 287
    return ((WINSEC_DOM_SID *)((void *)0));
  }
  {
#line 290
  tmp = talloc_named_const((void const   *)talloc_ctx, sizeof(WINSEC_DOM_SID ), "WINSEC_DOM_SID");
#line 290
  ret_val = (WINSEC_DOM_SID *)tmp;
  }
#line 290
  if ((unsigned long )ret_val == (unsigned long )((void *)0)) {
#line 291
    return ((WINSEC_DOM_SID *)((void *)0));
  }
  {
#line 293
  ret_val->sid_rev_num = (uint8_t )*(buf + 0);
#line 294
  ret_val->num_auths = (uint8_t )*(buf + 1);
#line 295
  memcpy((void */* __restrict  */)(ret_val->id_auth), (void const   */* __restrict  */)(buf + 2),
         (size_t )6);
  }
#line 298
  if ((int )ret_val->num_auths > 15) {
#line 299
    ret_val->num_auths = (uint8_t )15;
  }
#line 301
  if ((unsigned long )buf_len < (unsigned long )ret_val->num_auths * sizeof(uint32_t ) + 8UL) {
    {
#line 303
    talloc_free((void *)ret_val);
    }
#line 304
    return ((WINSEC_DOM_SID *)((void *)0));
  }
#line 307
  i = (uint32_t )0;
  {
#line 307
  while (1) {
    while_continue: /* CIL Label */ ;
#line 307
    if (! (i < (uint32_t )ret_val->num_auths)) {
#line 307
      goto while_break;
    }
#line 308
    ret_val->sub_auths[i] = ((unsigned int )*(buf + (8UL + (unsigned long )i * sizeof(uint32_t ))) | ((unsigned int )*(buf + ((8UL + (unsigned long )i * sizeof(uint32_t )) + 1UL)) << 8)) | (((unsigned int )*(buf + ((8UL + (unsigned long )i * sizeof(uint32_t )) + 2UL)) | ((unsigned int )*(buf + (((8UL + (unsigned long )i * sizeof(uint32_t )) + 2UL) + 1UL)) << 8)) << 16);
#line 307
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 310
  return (ret_val);
}
}
#line 317 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/winsec.c"
WINSEC_UUID *winsec_parse_uuid(void *talloc_ctx , uint8_t const   *buf , uint32_t buf_len ) 
{ 
  WINSEC_UUID *ret_val ;
  void *tmp ;

  {
#line 322
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 323
    return ((WINSEC_UUID *)0);
  } else
#line 322
  if ((unsigned long )buf_len < sizeof(WINSEC_UUID )) {
#line 323
    return ((WINSEC_UUID *)0);
  }
  {
#line 325
  tmp = talloc_named_const((void const   *)talloc_ctx, sizeof(WINSEC_UUID ), "WINSEC_UUID");
#line 325
  ret_val = (WINSEC_UUID *)tmp;
  }
#line 325
  if ((unsigned long )ret_val == (unsigned long )((void *)0)) {
#line 326
    return ((WINSEC_UUID *)((void *)0));
  }
  {
#line 328
  ret_val->time_low = ((unsigned int )*(buf + 0) | ((unsigned int )*(buf + 1) << 8)) | (((unsigned int )*(buf + 2) | ((unsigned int )*(buf + 3) << 8)) << 16);
#line 329
  ret_val->time_mid = (uint16_t )((unsigned int )*(buf + 4) | ((unsigned int )*(buf + 5) << 8));
#line 330
  ret_val->time_hi_and_version = (uint16_t )((unsigned int )*(buf + 6) | ((unsigned int )*(buf + 7) << 8));
#line 332
  memcpy((void */* __restrict  */)(ret_val->clock_seq), (void const   */* __restrict  */)(buf + 8),
         (size_t )2);
#line 333
  memcpy((void */* __restrict  */)(ret_val->node), (void const   */* __restrict  */)(buf + 11),
         (size_t )6);
  }
#line 335
  return (ret_val);
}
}
#line 342 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/winsec.c"
size_t winsec_sid_size(WINSEC_DOM_SID const   *sid ) 
{ 


  {
#line 344
  if ((unsigned long )sid == (unsigned long )((void *)0)) {
#line 345
    return ((size_t )0);
  }
#line 347
  return ((unsigned long )sid->num_auths * sizeof(uint32_t ) + 8UL);
}
}
#line 354 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/winsec.c"
int winsec_sid_compare_auth(WINSEC_DOM_SID const   *sid1 , WINSEC_DOM_SID const   *sid2 ) 
{ 
  int i ;

  {
#line 358
  if ((unsigned long )sid1 == (unsigned long )sid2) {
#line 359
    return (0);
  }
#line 360
  if (! sid1) {
#line 361
    return (-1);
  }
#line 362
  if (! sid2) {
#line 363
    return (1);
  }
#line 365
  if ((int const   )sid1->sid_rev_num != (int const   )sid2->sid_rev_num) {
#line 366
    return ((int )((int const   )sid1->sid_rev_num - (int const   )sid2->sid_rev_num));
  }
#line 368
  i = 0;
  {
#line 368
  while (1) {
    while_continue: /* CIL Label */ ;
#line 368
    if (! (i < 6)) {
#line 368
      goto while_break;
    }
#line 369
    if ((int )sid1->id_auth[i] != (int )sid2->id_auth[i]) {
#line 370
      return ((int )sid1->id_auth[i] - (int )sid2->id_auth[i]);
    }
#line 368
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 372
  return (0);
}
}
#line 379 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/winsec.c"
int winsec_sid_compare(WINSEC_DOM_SID const   *sid1 , WINSEC_DOM_SID const   *sid2 ) 
{ 
  int i ;
  int tmp ;

  {
#line 383
  if ((unsigned long )sid1 == (unsigned long )sid2) {
#line 384
    return (0);
  }
#line 385
  if (! sid1) {
#line 386
    return (-1);
  }
#line 387
  if (! sid2) {
#line 388
    return (1);
  }
#line 391
  if ((int const   )sid1->num_auths != (int const   )sid2->num_auths) {
#line 392
    return ((int )((int const   )sid1->num_auths - (int const   )sid2->num_auths));
  }
#line 394
  i = (int )((int const   )sid1->num_auths - 1);
  {
#line 394
  while (1) {
    while_continue: /* CIL Label */ ;
#line 394
    if (! (i >= 0)) {
#line 394
      goto while_break;
    }
#line 395
    if (sid1->sub_auths[i] != sid2->sub_auths[i]) {
#line 396
      return ((int )(sid1->sub_auths[i] - sid2->sub_auths[i]));
    }
#line 394
    i --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 398
  tmp = winsec_sid_compare_auth(sid1, sid2);
  }
#line 398
  return (tmp);
}
}
#line 405 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/winsec.c"
_Bool winsec_sid_equal(WINSEC_DOM_SID const   *sid1 , WINSEC_DOM_SID const   *sid2 ) 
{ 
  int tmp ;

  {
  {
#line 407
  tmp = winsec_sid_compare(sid1, sid2);
  }
#line 407
  return ((_Bool )(tmp == 0));
}
}
#line 414 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/winsec.c"
_Bool winsec_desc_equal(WINSEC_DESC *s1 , WINSEC_DESC *s2 ) 
{ 
  _Bool tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;

  {
#line 417
  if (! s1) {
#line 417
    if (! s2) {
#line 418
      return ((_Bool)1);
    }
  }
#line 419
  if (! s1) {
#line 420
    return ((_Bool)0);
  } else
#line 419
  if (! s2) {
#line 420
    return ((_Bool)0);
  }
#line 423
  if ((int )s1->revision != (int )s2->revision) {
#line 424
    return ((_Bool)0);
  }
#line 426
  if ((int )s1->control != (int )s2->control) {
#line 427
    return ((_Bool)0);
  }
  {
#line 430
  tmp = winsec_sid_equal((WINSEC_DOM_SID const   *)s1->owner_sid, (WINSEC_DOM_SID const   *)s2->owner_sid);
  }
#line 430
  if (! tmp) {
#line 431
    return ((_Bool)0);
  }
  {
#line 433
  tmp___0 = winsec_sid_equal((WINSEC_DOM_SID const   *)s1->grp_sid, (WINSEC_DOM_SID const   *)s2->grp_sid);
  }
#line 433
  if (! tmp___0) {
#line 434
    return ((_Bool)0);
  }
#line 437
  if (s1->dacl) {
#line 437
    if (! s2->dacl) {
#line 439
      return ((_Bool)0);
    } else {
#line 437
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 437
  if (! s1->dacl) {
#line 437
    if (s2->dacl) {
#line 439
      return ((_Bool)0);
    } else {
#line 437
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 437
  if (s1->sacl) {
#line 437
    if (! s2->sacl) {
#line 439
      return ((_Bool)0);
    } else {
#line 437
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 437
  if (! s1->sacl) {
#line 437
    if (s2->sacl) {
#line 439
      return ((_Bool)0);
    }
  }
  {
#line 443
  tmp___1 = winsec_acl_equal(s1->dacl, s2->dacl);
  }
#line 443
  if (tmp___1) {
    {
#line 443
    tmp___2 = winsec_acl_equal(s1->sacl, s2->sacl);
    }
#line 443
    if (! tmp___2) {
#line 444
      return ((_Bool)0);
    }
  } else {
#line 444
    return ((_Bool)0);
  }
#line 446
  return ((_Bool)1);
}
}
#line 454 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/winsec.c"
_Bool winsec_acl_equal(WINSEC_ACL *s1 , WINSEC_ACL *s2 ) 
{ 
  unsigned int i ;
  unsigned int j ;
  _Bool found ;
  _Bool tmp ;

  {
#line 459
  if (! s1) {
#line 459
    if (! s2) {
#line 460
      return ((_Bool)1);
    }
  }
#line 461
  if (! s1) {
#line 462
    return ((_Bool)0);
  } else
#line 461
  if (! s2) {
#line 462
    return ((_Bool)0);
  }
#line 465
  if ((int )s1->revision != (int )s2->revision) {
#line 466
    return ((_Bool)0);
  }
#line 468
  if (s1->num_aces != s2->num_aces) {
#line 469
    return ((_Bool)0);
  }
#line 474
  i = 0U;
  {
#line 474
  while (1) {
    while_continue: /* CIL Label */ ;
#line 474
    if (! (i < s1->num_aces)) {
#line 474
      goto while_break;
    }
#line 476
    found = (_Bool)0;
#line 478
    j = 0U;
    {
#line 478
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 478
      if (! (j < s2->num_aces)) {
#line 478
        goto while_break___0;
      }
      {
#line 480
      tmp = winsec_ace_equal(*(s1->aces + i), *(s2->aces + j));
      }
#line 480
      if (tmp) {
#line 482
        found = (_Bool)1;
#line 483
        goto while_break___0;
      }
#line 478
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 487
    if (! found) {
#line 488
      return ((_Bool)0);
    }
#line 474
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 491
  return ((_Bool)1);
}
}
#line 498 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/winsec.c"
_Bool winsec_ace_equal(WINSEC_ACE *s1 , WINSEC_ACE *s2 ) 
{ 
  _Bool tmp ;

  {
#line 501
  if (! s1) {
#line 501
    if (! s2) {
#line 502
      return ((_Bool)1);
    }
  }
#line 503
  if (! s1) {
#line 504
    return ((_Bool)0);
  } else
#line 503
  if (! s2) {
#line 504
    return ((_Bool)0);
  }
#line 507
  if ((int )s1->type != (int )s2->type) {
#line 509
    return ((_Bool)0);
  } else
#line 507
  if ((int )s1->flags != (int )s2->flags) {
#line 509
    return ((_Bool)0);
  } else
#line 507
  if (s1->access_mask != s2->access_mask) {
#line 509
    return ((_Bool)0);
  }
  {
#line 512
  tmp = winsec_sid_equal((WINSEC_DOM_SID const   *)s1->trustee, (WINSEC_DOM_SID const   *)s2->trustee);
  }
#line 512
  if (! tmp) {
#line 513
    return ((_Bool)0);
  }
#line 515
  return ((_Bool)1);
}
}
#line 522 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/winsec.c"
_Bool winsec_ace_object(uint8_t type ) 
{ 


  {
#line 524
  if ((int )type == 5) {
#line 528
    return ((_Bool)1);
  } else
#line 524
  if ((int )type == 6) {
#line 528
    return ((_Bool)1);
  } else
#line 524
  if ((int )type == 7) {
#line 528
    return ((_Bool)1);
  } else
#line 524
  if ((int )type == 8) {
#line 528
    return ((_Bool)1);
  }
#line 530
  return ((_Bool)0);
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/include/void_stack.h"
void_stack *void_stack_copy(void_stack const   *v ) ;
#line 80
void_stack *void_stack_copy_reverse(void_stack const   *v ) ;
#line 88
void void_stack_free(void_stack *stack ) ;
#line 100
void void_stack_free_deep(void_stack *stack ) ;
#line 109
unsigned short void_stack_size(void_stack const   *stack ) ;
#line 139
void const   *void_stack_cur(void_stack const   *stack ) ;
#line 148
void_stack_iterator *void_stack_iterator_new(void_stack const   *stack ) ;
#line 157
void void_stack_iterator_free(void_stack_iterator *iter ) ;
#line 168
void const   *void_stack_iterator_next(void_stack_iterator *iter ) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/void_stack.c"
void_stack *void_stack_new(unsigned short max_size ) 
{ 
  void_stack *ret_val ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 29
  tmp = talloc_named_const((void const   *)((void *)0), sizeof(void_stack ), "void_stack");
#line 29
  ret_val = (void_stack *)tmp;
  }
#line 31
  if ((unsigned long )ret_val != (unsigned long )((void *)0)) {
    {
#line 33
    memset((void *)ret_val, 0, sizeof(*ret_val));
#line 34
    tmp___0 = _talloc_array((void const   *)ret_val, sizeof(void *), (unsigned int )max_size,
                            "void*");
#line 34
    ret_val->elements = (void **)tmp___0;
    }
#line 35
    if ((unsigned long )ret_val->elements == (unsigned long )((void *)0)) {
      {
#line 37
      talloc_free((void *)ret_val);
#line 38
      ret_val = (void_stack *)((void *)0);
      }
    } else {
      {
#line 42
      memset((void *)ret_val->elements, 0, (unsigned long )max_size * sizeof(void *));
#line 44
      ret_val->max_size = max_size;
#line 45
      ret_val->top = (unsigned short)0;
      }
    }
  }
#line 49
  return (ret_val);
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/void_stack.c"
void_stack *void_stack_copy(void_stack const   *v ) 
{ 
  unsigned int i ;
  void_stack *ret_val ;

  {
#line 57
  if ((unsigned long )v == (unsigned long )((void *)0)) {
#line 58
    return ((void_stack *)((void *)0));
  }
  {
#line 60
  ret_val = void_stack_new((unsigned short )v->max_size);
  }
#line 61
  if ((unsigned long )ret_val == (unsigned long )((void *)0)) {
#line 62
    return ((void_stack *)((void *)0));
  }
#line 64
  i = 0U;
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
#line 64
    if (! (i < (unsigned int )v->top)) {
#line 64
      goto while_break;
    }
#line 65
    *(ret_val->elements + i) = *(v->elements + i);
#line 64
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 66
  ret_val->top = (unsigned short )v->top;
#line 68
  return (ret_val);
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/void_stack.c"
void_stack *void_stack_copy_reverse(void_stack const   *v ) 
{ 
  unsigned int i ;
  void_stack *ret_val ;

  {
#line 76
  if ((unsigned long )v == (unsigned long )((void *)0)) {
#line 77
    return ((void_stack *)((void *)0));
  }
  {
#line 79
  ret_val = void_stack_new((unsigned short )v->max_size);
  }
#line 80
  if ((unsigned long )ret_val == (unsigned long )((void *)0)) {
#line 81
    return ((void_stack *)((void *)0));
  }
#line 83
  i = 0U;
  {
#line 83
  while (1) {
    while_continue: /* CIL Label */ ;
#line 83
    if (! (i < (unsigned int )v->top)) {
#line 83
      goto while_break;
    }
#line 84
    *(ret_val->elements + i) = *(v->elements + (((unsigned int )v->top - i) - 1U));
#line 83
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 85
  ret_val->top = (unsigned short )v->top;
#line 87
  return (ret_val);
}
}
#line 91 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/void_stack.c"
void void_stack_free(void_stack *stack ) 
{ 


  {
  {
#line 93
  talloc_free((void *)stack);
  }
#line 94
  return;
}
}
#line 97 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/void_stack.c"
void void_stack_free_deep(void_stack *stack ) 
{ 
  unsigned short i ;

  {
#line 100
  i = (unsigned short)0;
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 100
    if (! ((int )i < (int )stack->top)) {
#line 100
      goto while_break;
    }
    {
#line 101
    free(*(stack->elements + i));
#line 100
    i = (unsigned short )((int )i + 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 102
  talloc_free((void *)stack);
  }
#line 103
  return;
}
}
#line 106 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/void_stack.c"
unsigned short void_stack_size(void_stack const   *stack ) 
{ 


  {
#line 108
  return ((unsigned short )stack->top);
}
}
#line 112 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/void_stack.c"
void *void_stack_pop(void_stack *stack ) 
{ 
  void *ret_val ;

  {
#line 114
  ret_val = (void *)0;
#line 116
  if ((int )stack->top > 0) {
#line 118
    stack->top = (unsigned short )((int )stack->top - 1);
#line 118
    ret_val = *(stack->elements + stack->top);
#line 119
    *(stack->elements + stack->top) = (void *)0;
  }
#line 122
  return (ret_val);
}
}
#line 126 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/void_stack.c"
_Bool void_stack_push(void_stack *stack , void *e ) 
{ 
  unsigned short tmp ;

  {
#line 128
  if ((int )stack->top < (int )stack->max_size) {
#line 130
    tmp = stack->top;
#line 130
    stack->top = (unsigned short )((int )stack->top + 1);
#line 130
    *(stack->elements + tmp) = e;
#line 131
    return ((_Bool)1);
  } else {
#line 134
    return ((_Bool)0);
  }
}
}
#line 138 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/void_stack.c"
void const   *void_stack_cur(void_stack const   *stack ) 
{ 
  void *ret_val ;

  {
#line 140
  ret_val = (void *)0;
#line 142
  if ((int const   )stack->top > 0) {
#line 143
    ret_val = *(stack->elements + ((int const   )stack->top - 1));
  }
#line 145
  return ((void const   *)ret_val);
}
}
#line 149 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/void_stack.c"
void_stack_iterator *void_stack_iterator_new(void_stack const   *stack ) 
{ 
  void_stack_iterator *ret_val ;
  void *tmp ;

  {
#line 151
  ret_val = (void_stack_iterator *)((void *)0);
#line 153
  if ((unsigned long )stack != (unsigned long )((void *)0)) {
    {
#line 155
    tmp = talloc_named_const((void const   *)stack, sizeof(void_stack_iterator ),
                             "void_stack_iterator");
#line 155
    ret_val = (void_stack_iterator *)tmp;
    }
#line 156
    if ((unsigned long )ret_val != (unsigned long )((void *)0)) {
#line 158
      ret_val->stack = stack;
#line 159
      ret_val->cur = (unsigned short)0;
    }
  }
#line 163
  return (ret_val);
}
}
#line 167 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/void_stack.c"
void void_stack_iterator_free(void_stack_iterator *iter ) 
{ 


  {
  {
#line 169
  talloc_free((void *)iter);
  }
#line 170
  return;
}
}
#line 173 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/void_stack.c"
void const   *void_stack_iterator_next(void_stack_iterator *iter ) 
{ 
  unsigned short tmp ;

  {
#line 175
  if ((int )iter->cur < (int )(iter->stack)->top) {
#line 176
    tmp = iter->cur;
#line 176
    iter->cur = (unsigned short )((int )iter->cur + 1);
#line 176
    return ((void const   *)*((iter->stack)->elements + tmp));
  } else {
#line 178
    return ((void const   *)((void *)0));
  }
}
}
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 205 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) strftime)(char * __restrict  __s ,
                                                                                  size_t __maxsize ,
                                                                                  char const   * __restrict  __format ,
                                                                                  struct tm  const  * __restrict  __tp ) ;
#line 239
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) gmtime)(time_t const   *__timer ) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/src/reglookup.c"
_Bool print_value_mtime  =    (_Bool)0;
#line 35 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/src/reglookup.c"
_Bool print_verbose  =    (_Bool)0;
#line 36 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/src/reglookup.c"
_Bool print_security  =    (_Bool)0;
#line 37 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/src/reglookup.c"
_Bool print_header  =    (_Bool)1;
#line 38 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/src/reglookup.c"
_Bool path_filter_enabled  =    (_Bool)0;
#line 39 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/src/reglookup.c"
_Bool type_filter_enabled  =    (_Bool)0;
#line 40 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/src/reglookup.c"
char *path_filter  =    (char *)((void *)0);
#line 41 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/src/reglookup.c"
int type_filter  ;
#line 42 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/src/reglookup.c"
char *registry_file  =    (char *)((void *)0);
#line 45 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/src/reglookup.c"
REGFI_FILE *f  ;
#line 25 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/src/common.c"
iconv_t conv_desc  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/src/common.c"
char const   *key_special_chars  =    ",\"\\/";
#line 28 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/src/common.c"
char const   *subfield_special_chars  =    ",\"\\|";
#line 29 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/src/common.c"
char const   *common_special_chars  =    ",\"\\";
#line 40 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/src/common.c"
void bailOut(int code , char *message ) 
{ 


  {
  {
#line 42
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)message);
#line 43
  exit(code);
  }
}
}
#line 46 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/src/common.c"
void printMsgs(REGFI_FILE *f___0 ) 
{ 
  char *msgs ;
  char *tmp ;

  {
  {
#line 48
  tmp = regfi_get_messages(f___0);
#line 48
  msgs = tmp;
  }
#line 49
  if ((unsigned long )msgs != (unsigned long )((void *)0)) {
    {
#line 51
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
            msgs);
#line 52
    free((void *)msgs);
    }
  }
#line 54
  return;
}
}
#line 56 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/src/common.c"
void clearMsgs(REGFI_FILE *f___0 ) 
{ 
  char *msgs ;
  char *tmp ;

  {
  {
#line 58
  tmp = regfi_get_messages(f___0);
#line 58
  msgs = tmp;
  }
#line 59
  if ((unsigned long )msgs != (unsigned long )((void *)0)) {
    {
#line 60
    free((void *)msgs);
    }
  }
#line 61
  return;
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/src/common.c"
static char *quote_buffer(unsigned char const   *str , unsigned int len , char const   *special ) 
{ 
  unsigned int i ;
  unsigned int added_len ;
  unsigned int num_written ;
  unsigned int buf_len ;
  char *ret_val ;
  char *tmp_buf ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;
  char *tmp___3 ;

  {
#line 74
  num_written = 0U;
#line 76
  buf_len = (unsigned int )(sizeof(char ) * (unsigned long )(len + 1U));
#line 77
  ret_val = (char *)((void *)0);
#line 80
  if (buf_len > 0U) {
    {
#line 81
    tmp = malloc((size_t )buf_len);
#line 81
    ret_val = (char *)tmp;
    }
  }
#line 82
  if ((unsigned long )ret_val == (unsigned long )((void *)0)) {
#line 83
    return ((char *)((void *)0));
  }
#line 85
  i = 0U;
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
#line 85
    if (! (i < len)) {
#line 85
      goto while_break;
    }
#line 87
    if (buf_len <= num_written + 5U) {
#line 95
      added_len = ((len - i) * num_written) / (i + 1U);
#line 96
      if (buf_len + added_len > len * 4U + 1U) {
#line 97
        buf_len = len * 4U + 1U;
      } else
#line 100
      if (added_len < 5U) {
#line 101
        buf_len += 5U;
      } else {
#line 103
        buf_len += added_len;
      }
      {
#line 106
      tmp___0 = realloc((void *)ret_val, (size_t )buf_len);
#line 106
      tmp_buf = (char *)tmp___0;
      }
#line 107
      if ((unsigned long )tmp_buf == (unsigned long )((void *)0)) {
        {
#line 109
        free((void *)ret_val);
        }
#line 110
        return ((char *)((void *)0));
      }
#line 112
      ret_val = tmp_buf;
    }
#line 115
    if ((int const   )*(str + i) < 32) {
      {
#line 117
      tmp___1 = snprintf((char */* __restrict  */)(ret_val + num_written), (size_t )(buf_len - num_written),
                         (char const   */* __restrict  */)"\\x%.2X", (int const   )*(str + i));
#line 117
      num_written += (unsigned int )tmp___1;
      }
    } else
#line 115
    if ((int const   )*(str + i) > 126) {
      {
#line 117
      tmp___1 = snprintf((char */* __restrict  */)(ret_val + num_written), (size_t )(buf_len - num_written),
                         (char const   */* __restrict  */)"\\x%.2X", (int const   )*(str + i));
#line 117
      num_written += (unsigned int )tmp___1;
      }
    } else {
      {
#line 115
      tmp___3 = strchr(special, (int )*(str + i));
      }
#line 115
      if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
        {
#line 117
        tmp___1 = snprintf((char */* __restrict  */)(ret_val + num_written), (size_t )(buf_len - num_written),
                           (char const   */* __restrict  */)"\\x%.2X", (int const   )*(str + i));
#line 117
        num_written += (unsigned int )tmp___1;
        }
      } else {
#line 121
        tmp___2 = num_written;
#line 121
        num_written ++;
#line 121
        *(ret_val + tmp___2) = (char )*(str + i);
      }
    }
#line 85
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 123
  *(ret_val + num_written) = (char )'\000';
#line 125
  return (ret_val);
}
}
#line 134 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/src/common.c"
static char *quote_string(char const   *str , char const   *special ) 
{ 
  unsigned int len ;
  size_t tmp ;
  char *tmp___0 ;

  {
#line 138
  if ((unsigned long )str == (unsigned long )((void *)0)) {
#line 139
    return ((char *)((void *)0));
  }
  {
#line 141
  tmp = strlen(str);
#line 141
  len = (unsigned int )tmp;
#line 142
  tmp___0 = quote_buffer((unsigned char const   *)str, len, special);
  }
#line 142
  return (tmp___0);
}
}
#line 156 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/src/common.c"
static char *data_to_ascii(REGFI_DATA *data , char **error_msg ) 
{ 
  char *ret_val ;
  char *cur_quoted ;
  char *tmp_ptr ;
  char *delim ;
  uint32_t ret_val_left ;
  uint32_t i ;
  uint32_t tmp_len ;
  void *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;
  char *tmp___4 ;
  void *tmp___5 ;
  char *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  void *tmp___18 ;
  char *tmp___19 ;

  {
#line 164
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 164
    goto _L;
  } else
#line 164
  if (data->size == 0U) {
    _L: /* CIL Label */ 
    {
#line 166
    tmp = malloc((size_t )37);
#line 166
    *error_msg = (char *)tmp;
    }
#line 167
    if ((unsigned long )*error_msg == (unsigned long )((void *)0)) {
#line 168
      return ((char *)((void *)0));
    }
    {
#line 169
    strcpy((char */* __restrict  */)*error_msg, (char const   */* __restrict  */)"Data pointer was NULL or size was 0.");
    }
#line 170
    return ((char *)((void *)0));
  }
#line 172
  *error_msg = (char *)((void *)0);
#line 175
  if (data->interpreted_size == 0U) {
    {
#line 177
    tmp___0 = malloc((size_t )51);
#line 177
    *error_msg = (char *)tmp___0;
    }
#line 178
    if ((unsigned long )*error_msg == (unsigned long )((void *)0)) {
#line 179
      return ((char *)((void *)0));
    }
    {
#line 180
    strcpy((char */* __restrict  */)*error_msg, (char const   */* __restrict  */)"Data could not be interpreted, quoting raw buffer.");
#line 181
    tmp___1 = quote_buffer((unsigned char const   *)data->raw, data->size, subfield_special_chars);
    }
#line 181
    return (tmp___1);
  }
  {
#line 186
  if (data->type == 1U) {
#line 186
    goto case_1;
  }
#line 195
  if (data->type == 2U) {
#line 195
    goto case_2;
  }
#line 204
  if (data->type == 6U) {
#line 204
    goto case_6;
  }
#line 212
  if (data->type == 4U) {
#line 212
    goto case_4;
  }
#line 221
  if (data->type == 5U) {
#line 221
    goto case_5;
  }
#line 230
  if (data->type == 11U) {
#line 230
    goto case_11;
  }
#line 240
  if (data->type == 7U) {
#line 240
    goto case_7;
  }
#line 267
  if (data->type == 0U) {
#line 267
    goto case_0;
  }
#line 273
  if (data->type == 8U) {
#line 273
    goto case_8;
  }
#line 279
  if (data->type == 9U) {
#line 279
    goto case_9;
  }
#line 285
  if (data->type == 10U) {
#line 285
    goto case_10;
  }
#line 291
  if (data->type == 3U) {
#line 291
    goto case_3;
  }
#line 297
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 187
  ret_val = quote_string((char const   *)((char *)data->interpreted.string), common_special_chars);
  }
#line 188
  if ((unsigned long )ret_val == (unsigned long )((void *)0)) {
    {
#line 188
    tmp___3 = malloc((size_t )49);
#line 188
    tmp___2 = (char *)tmp___3;
#line 188
    *error_msg = tmp___2;
    }
#line 188
    if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
      {
#line 189
      strcpy((char */* __restrict  */)*error_msg, (char const   */* __restrict  */)"Buffer could not be quoted due to unknown error.");
      }
    }
  }
#line 191
  return (ret_val);
#line 192
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 196
  ret_val = quote_string((char const   *)((char *)data->interpreted.expand_string),
                         common_special_chars);
  }
#line 198
  if ((unsigned long )ret_val == (unsigned long )((void *)0)) {
    {
#line 198
    tmp___5 = malloc((size_t )49);
#line 198
    tmp___4 = (char *)tmp___5;
#line 198
    *error_msg = tmp___4;
    }
#line 198
    if ((unsigned long )tmp___4 != (unsigned long )((void *)0)) {
      {
#line 199
      strcpy((char */* __restrict  */)*error_msg, (char const   */* __restrict  */)"Buffer could not be quoted due to unknown error.");
      }
    }
  }
#line 201
  return (ret_val);
#line 202
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 205
  ret_val = quote_string((char const   *)((char *)data->interpreted.link), common_special_chars);
  }
#line 206
  if ((unsigned long )ret_val == (unsigned long )((void *)0)) {
    {
#line 206
    tmp___7 = malloc((size_t )49);
#line 206
    tmp___6 = (char *)tmp___7;
#line 206
    *error_msg = tmp___6;
    }
#line 206
    if ((unsigned long )tmp___6 != (unsigned long )((void *)0)) {
      {
#line 207
      strcpy((char */* __restrict  */)*error_msg, (char const   */* __restrict  */)"Buffer could not be quoted due to unknown error.");
      }
    }
  }
#line 209
  return (ret_val);
#line 210
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 213
  tmp___8 = malloc(sizeof(char ) * 11UL);
#line 213
  ret_val = (char *)tmp___8;
  }
#line 214
  if ((unsigned long )ret_val == (unsigned long )((void *)0)) {
#line 215
    return ((char *)((void *)0));
  }
  {
#line 217
  sprintf((char */* __restrict  */)ret_val, (char const   */* __restrict  */)"0x%.8X",
          data->interpreted.dword);
  }
#line 218
  return (ret_val);
#line 219
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 222
  tmp___9 = malloc(sizeof(char ) * 11UL);
#line 222
  ret_val = (char *)tmp___9;
  }
#line 223
  if ((unsigned long )ret_val == (unsigned long )((void *)0)) {
#line 224
    return ((char *)((void *)0));
  }
  {
#line 226
  sprintf((char */* __restrict  */)ret_val, (char const   */* __restrict  */)"0x%.8X",
          data->interpreted.dword_be);
  }
#line 227
  return (ret_val);
#line 228
  goto switch_break;
  case_11: /* CIL Label */ 
  {
#line 231
  tmp___10 = malloc(sizeof(char ) * 19UL);
#line 231
  ret_val = (char *)tmp___10;
  }
#line 232
  if ((unsigned long )ret_val == (unsigned long )((void *)0)) {
#line 233
    return ((char *)((void *)0));
  }
  {
#line 235
  sprintf((char */* __restrict  */)ret_val, (char const   */* __restrict  */)"0x%.16llX",
          (unsigned long long )data->interpreted.qword);
  }
#line 237
  return (ret_val);
#line 238
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 241
  ret_val_left = data->interpreted_size * 4U + 1U;
#line 242
  tmp___11 = malloc((size_t )ret_val_left);
#line 242
  ret_val = (char *)tmp___11;
  }
#line 243
  if ((unsigned long )ret_val == (unsigned long )((void *)0)) {
#line 244
    return ((char *)((void *)0));
  }
#line 246
  tmp_ptr = ret_val;
#line 247
  *(tmp_ptr + 0) = (char )'\000';
#line 248
  delim = (char *)"";
#line 249
  i = (uint32_t )0;
  {
#line 249
  while (1) {
    while_continue: /* CIL Label */ ;
#line 249
    if (! ((unsigned long )*(data->interpreted.multiple_string + i) != (unsigned long )((void *)0))) {
#line 249
      goto while_break;
    }
    {
#line 251
    cur_quoted = quote_string((char const   *)((char *)*(data->interpreted.multiple_string + i)),
                              subfield_special_chars);
    }
#line 253
    if ((unsigned long )cur_quoted != (unsigned long )((void *)0)) {
#line 253
      if ((int )*(cur_quoted + 0) != 0) {
        {
#line 255
        tmp___12 = snprintf((char */* __restrict  */)tmp_ptr, (size_t )ret_val_left,
                            (char const   */* __restrict  */)"%s%s", delim, cur_quoted);
#line 255
        tmp_len = (uint32_t )tmp___12;
#line 256
        tmp_ptr += tmp_len;
#line 257
        ret_val_left -= tmp_len;
#line 258
        free((void *)cur_quoted);
        }
      }
    }
#line 260
    delim = (char *)"|";
#line 249
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 263
  return (ret_val);
#line 264
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 268
  tmp___13 = quote_buffer((unsigned char const   *)data->interpreted.none, data->interpreted_size,
                          common_special_chars);
  }
#line 268
  return (tmp___13);
#line 271
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 274
  tmp___14 = quote_buffer((unsigned char const   *)data->interpreted.resource_list,
                          data->interpreted_size, common_special_chars);
  }
#line 274
  return (tmp___14);
#line 277
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 280
  tmp___15 = quote_buffer((unsigned char const   *)data->interpreted.full_resource_descriptor,
                          data->interpreted_size, common_special_chars);
  }
#line 280
  return (tmp___15);
#line 283
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 286
  tmp___16 = quote_buffer((unsigned char const   *)data->interpreted.resource_requirements_list,
                          data->interpreted_size, common_special_chars);
  }
#line 286
  return (tmp___16);
#line 289
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 292
  tmp___17 = quote_buffer((unsigned char const   *)data->interpreted.binary, data->interpreted_size,
                          common_special_chars);
  }
#line 292
  return (tmp___17);
#line 295
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 301
  tmp___18 = malloc((size_t )65);
#line 301
  *error_msg = (char *)tmp___18;
  }
#line 302
  if ((unsigned long )*error_msg == (unsigned long )((void *)0)) {
#line 303
    return ((char *)((void *)0));
  }
  {
#line 304
  sprintf((char */* __restrict  */)*error_msg, (char const   */* __restrict  */)"Unrecognized registry data type (0x%.8X); quoting as binary.",
          data->type);
#line 307
  tmp___19 = quote_buffer((unsigned char const   *)data->raw, data->size, common_special_chars);
  }
#line 307
  return (tmp___19);
  switch_break: /* CIL Label */ ;
  }
#line 310
  return ((char *)((void *)0));
}
}
#line 314 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/src/common.c"
static char *get_quoted_keyname(REGFI_NK_REC const   *nk ) 
{ 
  char *ret_val ;

  {
#line 318
  if ((unsigned long )nk->keyname == (unsigned long )((void *)0)) {
    {
#line 319
    ret_val = quote_buffer((unsigned char const   *)nk->keyname_raw, (unsigned int )nk->name_length,
                           key_special_chars);
    }
  } else {
    {
#line 321
    ret_val = quote_string((char const   *)nk->keyname, key_special_chars);
    }
  }
#line 323
  return (ret_val);
}
}
#line 327 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/src/common.c"
static char *get_quoted_valuename(REGFI_VK_REC const   *vk ) 
{ 
  char *ret_val ;

  {
#line 331
  if ((unsigned long )vk->valuename == (unsigned long )((void *)0)) {
    {
#line 332
    ret_val = quote_buffer((unsigned char const   *)vk->valuename_raw, (unsigned int )vk->name_length,
                           key_special_chars);
    }
  } else {
    {
#line 335
    ret_val = quote_string((char const   *)vk->valuename, key_special_chars);
    }
  }
#line 337
  return (ret_val);
}
}
#line 54 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/src/reglookup.c"
void printValue(REGFI_ITERATOR *iter , REGFI_VK_REC const   *vk , char *prefix ) 
{ 
  REGFI_DATA *data ;
  char *quoted_value ;
  char *quoted_name ;
  char *conv_error ;
  char const   *str_type ;
  char mtime[20] ;
  time_t tmp_time[1] ;
  struct tm *tmp_time_s ;
  void *tmp ;

  {
  {
#line 57
  quoted_value = (char *)((void *)0);
#line 58
  quoted_name = (char *)((void *)0);
#line 59
  conv_error = (char *)((void *)0);
#line 60
  str_type = (char const   *)((void *)0);
#line 63
  tmp_time_s = (struct tm *)((void *)0);
#line 65
  quoted_name = get_quoted_valuename(vk);
  }
#line 66
  if ((unsigned long )quoted_name == (unsigned long )((void *)0)) {
    {
#line 73
    tmp = malloc(sizeof(char ));
#line 73
    quoted_name = (char *)tmp;
    }
#line 74
    if ((unsigned long )quoted_name == (unsigned long )((void *)0)) {
      {
#line 75
      bailOut(71, (char *)"ERROR: Could not allocate sufficient memory.\n");
      }
    }
#line 76
    *(quoted_name + 0) = (char )'\000';
  }
  {
#line 79
  data = regfi_iterator_fetch_data(iter, vk);
#line 81
  printMsgs(iter->f);
  }
#line 82
  if ((unsigned long )data != (unsigned long )((void *)0)) {
    {
#line 84
    quoted_value = data_to_ascii(data, & conv_error);
    }
#line 85
    if ((unsigned long )quoted_value == (unsigned long )((void *)0)) {
#line 87
      if ((unsigned long )conv_error == (unsigned long )((void *)0)) {
        {
#line 88
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"WARN: Could not quote value for \'%s/%s\'.  Memory allocation failure likely.\n",
                prefix, quoted_name);
        }
      } else {
        {
#line 91
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"WARN: Could not quote value for \'%s/%s\'.  Returned error: %s\n",
                prefix, quoted_name, conv_error);
        }
      }
    } else
#line 94
    if ((unsigned long )conv_error != (unsigned long )((void *)0)) {
      {
#line 95
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"WARN: While quoting value for \'%s/%s\', warning returned: %s\n",
              prefix, quoted_name, conv_error);
      }
    }
    {
#line 97
    regfi_free_data(data);
    }
  }
#line 100
  if (print_value_mtime) {
    {
#line 102
    tmp_time[0] = regfi_nt2unix_time((REGFI_NTTIME const   *)(& (iter->cur_key)->mtime));
#line 103
    tmp_time_s = gmtime((time_t const   *)(tmp_time));
#line 104
    strftime((char */* __restrict  */)(mtime), sizeof(mtime), (char const   */* __restrict  */)"%Y-%m-%d %H:%M:%S",
             (struct tm  const  */* __restrict  */)tmp_time_s);
    }
  } else {
#line 107
    mtime[0] = (char )'\000';
  }
  {
#line 109
  str_type = regfi_type_val2str((unsigned int )vk->type);
  }
#line 110
  if (print_security) {
#line 112
    if ((unsigned long )str_type == (unsigned long )((void *)0)) {
      {
#line 113
      printf((char const   */* __restrict  */)"%s/%s,0x%.8X,%s,%s,,,,\n", prefix,
             quoted_name, vk->type, quoted_value, mtime);
      }
    } else {
      {
#line 116
      printf((char const   */* __restrict  */)"%s/%s,%s,%s,%s,,,,\n", prefix, quoted_name,
             str_type, quoted_value, mtime);
      }
    }
  } else
#line 121
  if ((unsigned long )str_type == (unsigned long )((void *)0)) {
    {
#line 122
    printf((char const   */* __restrict  */)"%s/%s,0x%.8X,%s,%s\n", prefix, quoted_name,
           vk->type, quoted_value, mtime);
    }
  } else {
    {
#line 125
    printf((char const   */* __restrict  */)"%s/%s,%s,%s,%s\n", prefix, quoted_name,
           str_type, quoted_value, mtime);
    }
  }
#line 129
  if ((unsigned long )quoted_value != (unsigned long )((void *)0)) {
    {
#line 130
    free((void *)quoted_value);
    }
  }
#line 131
  if ((unsigned long )quoted_name != (unsigned long )((void *)0)) {
    {
#line 132
    free((void *)quoted_name);
    }
  }
#line 133
  if ((unsigned long )conv_error != (unsigned long )((void *)0)) {
    {
#line 134
    free((void *)conv_error);
    }
  }
#line 135
  return;
}
}
#line 138 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/src/reglookup.c"
char **splitPath(char const   *s ) 
{ 
  char **ret_val ;
  char const   *cur ;
  char *next ;
  char *copy ;
  uint32_t ret_cur ;
  void *tmp ;
  void *tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  size_t tmp___3 ;

  {
  {
#line 141
  cur = s;
#line 142
  next = (char *)((void *)0);
#line 144
  ret_cur = (uint32_t )0;
#line 146
  tmp = malloc(514UL * sizeof(char **));
#line 146
  ret_val = (char **)tmp;
  }
#line 147
  if ((unsigned long )ret_val == (unsigned long )((void *)0)) {
#line 148
    return ((char **)((void *)0));
  }
#line 149
  *(ret_val + 0) = (char *)((void *)0);
#line 152
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 153
    return (ret_val);
  }
  {
#line 155
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 155
    next = strchr(cur, '/');
    }
#line 155
    if (! ((unsigned long )next != (unsigned long )((void *)0))) {
#line 155
      goto while_break;
    }
#line 157
    if (next - (char *)cur > 0L) {
      {
#line 159
      tmp___0 = malloc((unsigned long )((next - (char *)cur) + 1L) * sizeof(char ));
#line 159
      copy = (char *)tmp___0;
      }
#line 160
      if ((unsigned long )copy == (unsigned long )((void *)0)) {
        {
#line 161
        bailOut(71, (char *)"ERROR: Memory allocation problem.\n");
        }
      }
      {
#line 163
      memcpy((void */* __restrict  */)copy, (void const   */* __restrict  */)cur,
             (size_t )(next - (char *)cur));
#line 164
      *(copy + (next - (char *)cur)) = (char )'\000';
#line 165
      tmp___1 = ret_cur;
#line 165
      ret_cur ++;
#line 165
      *(ret_val + tmp___1) = copy;
      }
#line 166
      if (ret_cur < 514U) {
#line 167
        *(ret_val + ret_cur) = (char *)((void *)0);
      } else {
        {
#line 169
        bailOut(65, (char *)"ERROR: Registry maximum depth exceeded.\n");
        }
      }
    }
#line 171
    cur = (char const   *)(next + 1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 175
  tmp___3 = strlen(cur);
  }
#line 175
  if (tmp___3 > 0UL) {
    {
#line 177
    copy = strdup(cur);
#line 178
    tmp___2 = ret_cur;
#line 178
    ret_cur ++;
#line 178
    *(ret_val + tmp___2) = copy;
    }
#line 179
    if (ret_cur < 514U) {
#line 180
      *(ret_val + ret_cur) = (char *)((void *)0);
    } else {
      {
#line 182
      bailOut(65, (char *)"ERROR: Registry maximum depth exceeded.\n");
      }
    }
  }
#line 185
  return (ret_val);
}
}
#line 189 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/src/reglookup.c"
void freePath(char **path ) 
{ 
  uint32_t i ;

  {
#line 193
  if ((unsigned long )path == (unsigned long )((void *)0)) {
#line 194
    return;
  }
#line 196
  i = (uint32_t )0;
  {
#line 196
  while (1) {
    while_continue: /* CIL Label */ ;
#line 196
    if (! ((unsigned long )*(path + i) != (unsigned long )((void *)0))) {
#line 196
      goto while_break;
    }
    {
#line 197
    free((void *)*(path + i));
#line 196
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 199
  free((void *)path);
  }
#line 200
  return;
}
}
#line 204 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/src/reglookup.c"
char *iter2Path(REGFI_ITERATOR *i ) 
{ 
  REGFI_ITER_POSITION const   *cur ;
  REGFI_NK_REC const   *tmp_key ;
  uint32_t buf_left ;
  uint32_t buf_len ;
  uint32_t name_len ;
  uint32_t grow_amt ;
  char *buf ;
  char *new_buf ;
  char *name ;
  void_stack_iterator *iter ;
  void *tmp ;
  unsigned short tmp___0 ;
  void const   *tmp___1 ;
  void const   *tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;

  {
  {
#line 208
  buf_left = (uint32_t )127;
#line 209
  buf_len = buf_left + 1U;
#line 210
  name_len = (uint32_t )0;
#line 217
  tmp = malloc((unsigned long )buf_len * sizeof(char ));
#line 217
  buf = (char *)tmp;
  }
#line 218
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 219
    return ((char *)((void *)0));
  }
  {
#line 220
  *(buf + 0) = (char )'\000';
#line 222
  iter = void_stack_iterator_new((void_stack const   *)i->key_positions);
  }
#line 223
  if ((unsigned long )iter == (unsigned long )((void *)0)) {
    {
#line 225
    free((void *)buf);
    }
#line 226
    return ((char *)((void *)0));
  }
  {
#line 230
  tmp___0 = void_stack_size((void_stack const   *)i->key_positions);
  }
#line 230
  if ((int )tmp___0 < 1) {
#line 232
    *(buf + 0) = (char )'/';
#line 233
    *(buf + 1) = (char )'\000';
#line 234
    return (buf);
  }
  {
#line 236
  tmp___1 = void_stack_iterator_next(iter);
#line 236
  cur = (REGFI_ITER_POSITION const   *)tmp___1;
  }
  {
#line 238
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 240
    tmp___2 = void_stack_iterator_next(iter);
#line 240
    cur = (REGFI_ITER_POSITION const   *)tmp___2;
    }
#line 241
    if ((unsigned long )cur == (unsigned long )((void *)0)) {
#line 242
      tmp_key = (REGFI_NK_REC const   *)i->cur_key;
    } else {
#line 244
      tmp_key = (REGFI_NK_REC const   *)cur->nk;
    }
    {
#line 246
    name = get_quoted_keyname(tmp_key);
#line 248
    *(buf + ((buf_len - buf_left) - 1U)) = (char )'/';
#line 249
    buf_left --;
#line 250
    tmp___3 = strlen((char const   *)name);
#line 250
    name_len = (uint32_t )tmp___3;
    }
#line 251
    if (name_len + 1U > buf_left) {
      {
#line 253
      grow_amt = buf_len / 2U;
#line 254
      buf_len += ((name_len + 1U) + grow_amt) - buf_left;
#line 255
      tmp___4 = realloc((void *)buf, (size_t )buf_len);
#line 255
      new_buf = (char *)tmp___4;
      }
#line 255
      if ((unsigned long )new_buf == (unsigned long )((void *)0)) {
        {
#line 257
        free((void *)name);
#line 258
        free((void *)buf);
#line 259
        free((void *)iter);
        }
#line 260
        return ((char *)((void *)0));
      }
#line 262
      buf = new_buf;
#line 263
      buf_left = (grow_amt + name_len) + 1U;
    }
    {
#line 265
    strncpy((char */* __restrict  */)(buf + ((buf_len - buf_left) - 1U)), (char const   */* __restrict  */)name,
            (size_t )name_len);
#line 266
    buf_left -= name_len;
#line 267
    *(buf + ((buf_len - buf_left) - 1U)) = (char )'\000';
#line 268
    free((void *)name);
    }
#line 238
    if (! ((unsigned long )cur != (unsigned long )((void *)0))) {
#line 238
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 271
  return (buf);
}
}
#line 275 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/src/reglookup.c"
void printValueList(REGFI_ITERATOR *iter , char *prefix ) 
{ 
  REGFI_VK_REC *value ;

  {
  {
#line 279
  value = regfi_iterator_first_value(iter);
  }
  {
#line 280
  while (1) {
    while_continue: /* CIL Label */ ;
#line 280
    if (! ((unsigned long )value != (unsigned long )((void *)0))) {
#line 280
      goto while_break;
    }
#line 282
    if (! type_filter_enabled) {
      {
#line 283
      printValue(iter, (REGFI_VK_REC const   *)value, prefix);
      }
    } else
#line 282
    if (value->type == (uint32_t )type_filter) {
      {
#line 283
      printValue(iter, (REGFI_VK_REC const   *)value, prefix);
      }
    }
    {
#line 284
    regfi_free_value(value);
#line 285
    value = regfi_iterator_next_value(iter);
#line 286
    printMsgs(iter->f);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 288
  return;
}
}
#line 293
void printKey(REGFI_ITERATOR *iter , char *full_path ) ;
#line 293 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/src/reglookup.c"
static char empty_str[1]  = {      (char )'\000'};
#line 291 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/src/reglookup.c"
void printKey(REGFI_ITERATOR *iter , char *full_path ) 
{ 
  char *owner ;
  char *group ;
  char *sacl ;
  char *dacl ;
  char *quoted_classname ;
  char mtime[20] ;
  time_t tmp_time[1] ;
  struct tm *tmp_time_s ;
  REGFI_SK_REC const   *sk ;
  REGFI_NK_REC const   *k ;
  REGFI_NK_REC const   *tmp ;
  REGFI_CLASSNAME *classname ;

  {
  {
#line 294
  owner = (char *)((void *)0);
#line 295
  group = (char *)((void *)0);
#line 296
  sacl = (char *)((void *)0);
#line 297
  dacl = (char *)((void *)0);
#line 301
  tmp_time_s = (struct tm *)((void *)0);
#line 303
  tmp = regfi_iterator_cur_key(iter);
#line 303
  k = tmp;
#line 306
  tmp_time[0] = regfi_nt2unix_time(& k->mtime);
#line 307
  tmp_time_s = gmtime((time_t const   *)(tmp_time));
#line 308
  strftime((char */* __restrict  */)(mtime), sizeof(mtime), (char const   */* __restrict  */)"%Y-%m-%d %H:%M:%S",
           (struct tm  const  */* __restrict  */)tmp_time_s);
  }
#line 310
  if (print_security) {
    {
#line 310
    sk = regfi_iterator_cur_sk(iter);
    }
#line 310
    if (sk) {
      {
#line 312
      owner = regfi_get_owner((WINSEC_DESC *)sk->sec_desc);
#line 313
      group = regfi_get_group((WINSEC_DESC *)sk->sec_desc);
#line 314
      sacl = regfi_get_sacl((WINSEC_DESC *)sk->sec_desc);
#line 315
      dacl = regfi_get_dacl((WINSEC_DESC *)sk->sec_desc);
      }
#line 316
      if ((unsigned long )owner == (unsigned long )((void *)0)) {
#line 317
        owner = empty_str;
      }
#line 318
      if ((unsigned long )group == (unsigned long )((void *)0)) {
#line 319
        group = empty_str;
      }
#line 320
      if ((unsigned long )sacl == (unsigned long )((void *)0)) {
#line 321
        sacl = empty_str;
      }
#line 322
      if ((unsigned long )dacl == (unsigned long )((void *)0)) {
#line 323
        dacl = empty_str;
      }
      {
#line 325
      classname = regfi_iterator_fetch_classname(iter, k);
#line 326
      printMsgs(iter->f);
      }
#line 327
      if ((unsigned long )classname != (unsigned long )((void *)0)) {
#line 329
        if ((unsigned long )classname->interpreted == (unsigned long )((void *)0)) {
          {
#line 331
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"WARN: Could not convert class name charset for key \'%s\'.  Quoting raw...\n",
                  full_path);
#line 333
          quoted_classname = quote_buffer((unsigned char const   *)classname->raw,
                                          (unsigned int )classname->size, key_special_chars);
          }
        } else {
          {
#line 337
          quoted_classname = quote_string((char const   *)classname->interpreted,
                                          key_special_chars);
          }
        }
#line 340
        if ((unsigned long )quoted_classname == (unsigned long )((void *)0)) {
          {
#line 342
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR: Could not quote classname for key \'%s\' due to unknown error.\n",
                  full_path);
#line 344
          quoted_classname = empty_str;
          }
        }
      } else {
#line 348
        quoted_classname = empty_str;
      }
      {
#line 349
      regfi_free_classname(classname);
#line 351
      printMsgs(iter->f);
#line 352
      printf((char const   */* __restrict  */)"%s,KEY,,%s,%s,%s,%s,%s,%s\n", full_path,
             mtime, owner, group, sacl, dacl, quoted_classname);
      }
#line 355
      if ((unsigned long )owner != (unsigned long )(empty_str)) {
        {
#line 356
        free((void *)owner);
        }
      }
#line 357
      if ((unsigned long )group != (unsigned long )(empty_str)) {
        {
#line 358
        free((void *)group);
        }
      }
#line 359
      if ((unsigned long )sacl != (unsigned long )(empty_str)) {
        {
#line 360
        free((void *)sacl);
        }
      }
#line 361
      if ((unsigned long )dacl != (unsigned long )(empty_str)) {
        {
#line 362
        free((void *)dacl);
        }
      }
#line 363
      if ((unsigned long )quoted_classname != (unsigned long )(empty_str)) {
        {
#line 364
        free((void *)quoted_classname);
        }
      }
    } else {
      {
#line 367
      printf((char const   */* __restrict  */)"%s,KEY,,%s\n", full_path, mtime);
      }
    }
  } else {
    {
#line 367
    printf((char const   */* __restrict  */)"%s,KEY,,%s\n", full_path, mtime);
    }
  }
#line 368
  return;
}
}
#line 371 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/src/reglookup.c"
void printKeyTree(REGFI_ITERATOR *iter ) 
{ 
  REGFI_NK_REC const   *root ;
  REGFI_NK_REC const   *cur ;
  REGFI_NK_REC *sub ;
  char *path ;
  int key_type ;
  int tmp ;
  _Bool print_this ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;

  {
  {
#line 373
  root = (REGFI_NK_REC const   *)((void *)0);
#line 374
  cur = (REGFI_NK_REC const   *)((void *)0);
#line 375
  sub = (REGFI_NK_REC *)((void *)0);
#line 376
  path = (char *)((void *)0);
#line 377
  tmp = regfi_type_str2val("KEY");
#line 377
  key_type = tmp;
#line 378
  print_this = (_Bool)1;
#line 380
  cur = regfi_iterator_cur_key(iter);
#line 380
  root = cur;
#line 381
  sub = regfi_iterator_first_subkey(iter);
#line 382
  printMsgs(iter->f);
  }
#line 384
  if ((unsigned long )root == (unsigned long )((void *)0)) {
    {
#line 385
    bailOut(65, (char *)"ERROR: root cannot be NULL.\n");
    }
  }
  {
#line 387
  while (1) {
    while_continue: /* CIL Label */ ;
#line 389
    if (print_this) {
      {
#line 391
      path = iter2Path(iter);
      }
#line 392
      if ((unsigned long )path == (unsigned long )((void *)0)) {
        {
#line 393
        bailOut(71, (char *)"ERROR: Could not construct iterator\'s path.\n");
        }
      }
#line 395
      if (! type_filter_enabled) {
        {
#line 396
        printKey(iter, path);
        }
      } else
#line 395
      if (key_type == type_filter) {
        {
#line 396
        printKey(iter, path);
        }
      }
#line 397
      if (! type_filter_enabled) {
        {
#line 398
        printValueList(iter, path);
        }
      } else
#line 397
      if (key_type != type_filter) {
        {
#line 398
        printValueList(iter, path);
        }
      }
      {
#line 400
      free((void *)path);
      }
    }
#line 403
    if ((unsigned long )sub == (unsigned long )((void *)0)) {
#line 405
      if ((unsigned long )cur != (unsigned long )root) {
        {
#line 408
        tmp___0 = regfi_iterator_up(iter);
        }
#line 408
        if (! tmp___0) {
          {
#line 410
          printMsgs(iter->f);
#line 411
          bailOut(65, (char *)"ERROR: could not traverse iterator upward.\n");
          }
        }
        {
#line 414
        cur = regfi_iterator_cur_key(iter);
        }
#line 415
        if ((unsigned long )cur == (unsigned long )((void *)0)) {
          {
#line 417
          printMsgs(iter->f);
#line 418
          bailOut(65, (char *)"ERROR: unexpected NULL for key.\n");
          }
        }
        {
#line 421
        sub = regfi_iterator_next_subkey(iter);
        }
      }
#line 423
      print_this = (_Bool)0;
    } else {
      {
#line 429
      tmp___1 = regfi_iterator_down(iter);
      }
#line 429
      if (! tmp___1) {
        {
#line 431
        printMsgs(iter->f);
#line 432
        bailOut(65, (char *)"ERROR: could not traverse iterator downward.\n");
        }
      }
      {
#line 435
      cur = regfi_iterator_cur_key(iter);
#line 436
      regfi_free_key(sub);
#line 437
      sub = regfi_iterator_first_subkey(iter);
#line 438
      print_this = (_Bool)1;
      }
    }
    {
#line 440
    printMsgs(iter->f);
    }
#line 387
    if ((unsigned long )cur == (unsigned long )root) {
#line 387
      if ((unsigned long )sub == (unsigned long )((void *)0)) {
#line 387
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 443
  if (print_verbose) {
    {
#line 444
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"INFO: Finished printing key tree.\n");
    }
  }
#line 445
  return;
}
}
#line 457 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/src/reglookup.c"
int retrievePath(REGFI_ITERATOR *iter , char **path ) 
{ 
  REGFI_VK_REC *value ;
  char *tmp_path_joined ;
  char const   **tmp_path ;
  uint32_t i ;
  void *tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;

  {
#line 464
  if ((unsigned long )path == (unsigned long )((void *)0)) {
#line 465
    return (-1);
  }
  {
#line 468
  tmp = malloc(sizeof(char const   **) * 514UL);
#line 468
  tmp_path = (char const   **)tmp;
  }
#line 469
  if ((unsigned long )tmp_path == (unsigned long )((void *)0)) {
#line 470
    return (-2);
  }
#line 473
  i = (uint32_t )0;
  {
#line 473
  while (1) {
    while_continue: /* CIL Label */ ;
#line 473
    if ((unsigned long )*(path + i) != (unsigned long )((void *)0)) {
#line 473
      if ((unsigned long )*(path + (i + 1U)) != (unsigned long )((void *)0)) {
#line 473
        if (! (i < 513U)) {
#line 473
          goto while_break;
        }
      } else {
#line 473
        goto while_break;
      }
    } else {
#line 473
      goto while_break;
    }
#line 476
    *(tmp_path + i) = (char const   *)*(path + i);
#line 473
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 477
  *(tmp_path + i) = (char const   *)((void *)0);
#line 479
  if (print_verbose) {
    {
#line 480
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"INFO: Attempting to retrieve specified path: %s\n",
            path_filter);
    }
  }
#line 484
  if ((unsigned long )*(path + 0) == (unsigned long )((void *)0)) {
#line 486
    if (print_verbose) {
      {
#line 487
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"INFO: Found final path element as root key.\n");
      }
    }
    {
#line 488
    free((void *)tmp_path);
    }
#line 489
    return (2);
  }
  {
#line 492
  tmp___0 = regfi_iterator_walk_path(iter, tmp_path);
  }
#line 492
  if (! tmp___0) {
    {
#line 494
    printMsgs(iter->f);
#line 495
    free((void *)tmp_path);
    }
#line 496
    return (0);
  }
  {
#line 499
  tmp___3 = regfi_iterator_find_value(iter, (char const   *)*(path + i));
  }
#line 499
  if (tmp___3) {
#line 501
    if (print_verbose) {
      {
#line 502
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"INFO: Found final path element as value.\n");
      }
    }
    {
#line 504
    value = regfi_iterator_cur_value(iter);
#line 505
    printMsgs(iter->f);
#line 506
    tmp_path_joined = iter2Path(iter);
    }
#line 508
    if ((unsigned long )value == (unsigned long )((void *)0)) {
      {
#line 509
      bailOut(71, (char *)"ERROR: Unexpected error before printValue.\n");
      }
    } else
#line 508
    if ((unsigned long )tmp_path_joined == (unsigned long )((void *)0)) {
      {
#line 509
      bailOut(71, (char *)"ERROR: Unexpected error before printValue.\n");
      }
    }
#line 511
    if (! type_filter_enabled) {
      {
#line 512
      printValue(iter, (REGFI_VK_REC const   *)value, tmp_path_joined);
      }
    } else
#line 511
    if (value->type == (uint32_t )type_filter) {
      {
#line 512
      printValue(iter, (REGFI_VK_REC const   *)value, tmp_path_joined);
      }
    }
    {
#line 514
    regfi_free_value(value);
#line 515
    free((void *)tmp_path);
#line 516
    free((void *)tmp_path_joined);
    }
#line 517
    return (1);
  } else {
    {
#line 519
    tmp___2 = regfi_iterator_find_subkey(iter, (char const   *)*(path + i));
    }
#line 519
    if (tmp___2) {
      {
#line 521
      printMsgs(iter->f);
      }
#line 522
      if (print_verbose) {
        {
#line 523
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"INFO: Found final path element as key.\n");
        }
      }
      {
#line 525
      tmp___1 = regfi_iterator_down(iter);
      }
#line 525
      if (! tmp___1) {
        {
#line 527
        printMsgs(iter->f);
#line 528
        bailOut(65, (char *)"ERROR: Unexpected error on traversing path filter key.\n");
        }
      }
#line 531
      return (2);
    }
  }
  {
#line 533
  printMsgs(iter->f);
  }
#line 535
  if (print_verbose) {
    {
#line 536
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"INFO: Could not find last element of path.\n");
    }
  }
#line 538
  return (0);
}
}
#line 542 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/src/reglookup.c"
static void usage(void) 
{ 


  {
  {
#line 544
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: reglookup [-v] [-s] [-p <PATH_FILTER>] [-t <TYPE_FILTER>] <REGISTRY_FILE>\n");
#line 547
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Version: %s\n",
          "0.12.0");
#line 548
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Options:\n");
#line 549
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t-v\t sets verbose mode.\n");
#line 550
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t-h\t enables header row. (default)\n");
#line 551
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t-H\t disables header row.\n");
#line 552
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t-s\t enables security descriptor output.\n");
#line 553
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t-S\t disables security descriptor output. (default)\n");
#line 554
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t-p\t restrict output to elements below this path.\n");
#line 555
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t-t\t restrict results to this specific data type.\n");
#line 556
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t-i\t includes parent key modification times with child values.\n");
#line 557
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
  }
#line 558
  return;
}
}
#line 561 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/src/reglookup.c"
int main(int argc , char **argv ) 
{ 
  char **path ;
  REGFI_ITERATOR *iter ;
  int retr_path_ret ;
  uint32_t argi ;
  uint32_t arge ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 563
  path = (char **)((void *)0);
#line 569
  if (argc < 2) {
    {
#line 571
    usage();
#line 572
    bailOut(64, (char *)"ERROR: Requires at least one argument.\n");
    }
  }
#line 575
  arge = (uint32_t )(argc - 1);
#line 576
  argi = (uint32_t )1;
  {
#line 576
  while (1) {
    while_continue: /* CIL Label */ ;
#line 576
    if (! (argi < arge)) {
#line 576
      goto while_break;
    }
    {
#line 578
    tmp___6 = strcmp("-p", (char const   *)*(argv + argi));
    }
#line 578
    if (tmp___6 == 0) {
#line 580
      argi ++;
#line 580
      if (argi >= arge) {
        {
#line 582
        usage();
#line 583
        bailOut(64, (char *)"ERROR: \'-p\' option requires parameter.\n");
        }
      }
      {
#line 585
      path_filter = strdup((char const   *)*(argv + argi));
      }
#line 585
      if ((unsigned long )path_filter == (unsigned long )((void *)0)) {
        {
#line 586
        bailOut(71, (char *)"ERROR: Memory allocation problem.\n");
        }
      }
#line 588
      path_filter_enabled = (_Bool)1;
    } else {
      {
#line 590
      tmp___5 = strcmp("-t", (char const   *)*(argv + argi));
      }
#line 590
      if (tmp___5 == 0) {
#line 592
        argi ++;
#line 592
        if (argi >= arge) {
          {
#line 594
          usage();
#line 595
          bailOut(64, (char *)"ERROR: \'-t\' option requires parameter.\n");
          }
        }
        {
#line 597
        type_filter = regfi_type_str2val((char const   *)*(argv + argi));
        }
#line 597
        if (type_filter < 0) {
          {
#line 599
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR: Invalid type specified: %s.\n",
                  *(argv + argi));
#line 600
          bailOut(64, (char *)"");
          }
        }
#line 602
        type_filter_enabled = (_Bool)1;
      } else {
        {
#line 604
        tmp___4 = strcmp("-h", (char const   *)*(argv + argi));
        }
#line 604
        if (tmp___4 == 0) {
#line 605
          print_header = (_Bool)1;
        } else {
          {
#line 606
          tmp___3 = strcmp("-H", (char const   *)*(argv + argi));
          }
#line 606
          if (tmp___3 == 0) {
#line 607
            print_header = (_Bool)0;
          } else {
            {
#line 608
            tmp___2 = strcmp("-s", (char const   *)*(argv + argi));
            }
#line 608
            if (tmp___2 == 0) {
#line 609
              print_security = (_Bool)1;
            } else {
              {
#line 610
              tmp___1 = strcmp("-S", (char const   *)*(argv + argi));
              }
#line 610
              if (tmp___1 == 0) {
#line 611
                print_security = (_Bool)0;
              } else {
                {
#line 612
                tmp___0 = strcmp("-v", (char const   *)*(argv + argi));
                }
#line 612
                if (tmp___0 == 0) {
#line 613
                  print_verbose = (_Bool)1;
                } else {
                  {
#line 614
                  tmp = strcmp("-i", (char const   *)*(argv + argi));
                  }
#line 614
                  if (tmp == 0) {
#line 615
                    print_value_mtime = (_Bool)1;
                  } else {
                    {
#line 618
                    usage();
#line 619
                    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR: Unrecognized option: %s\n",
                            *(argv + argi));
#line 620
                    bailOut(64, (char *)"");
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
#line 576
    argi ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 623
  registry_file = strdup((char const   *)*(argv + argi));
  }
#line 623
  if ((unsigned long )registry_file == (unsigned long )((void *)0)) {
    {
#line 624
    bailOut(71, (char *)"ERROR: Memory allocation problem.\n");
    }
  }
  {
#line 626
  f = regfi_open((char const   *)registry_file);
  }
#line 627
  if ((unsigned long )f == (unsigned long )((void *)0)) {
    {
#line 629
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR: Couldn\'t open registry file: %s\n",
            registry_file);
#line 630
    bailOut(66, (char *)"");
    }
  }
#line 633
  if (print_verbose) {
    {
#line 634
    regfi_set_message_mask(f, (uint16_t )21);
    }
  }
  {
#line 637
  iter = regfi_iterator_new(f, (REGFI_ENCODING )0);
  }
#line 638
  if ((unsigned long )iter == (unsigned long )((void *)0)) {
    {
#line 640
    printMsgs(f);
#line 641
    bailOut(71, (char *)"ERROR: Couldn\'t create registry iterator.\n");
    }
  }
#line 644
  if (print_header) {
#line 646
    if (print_security) {
      {
#line 647
      printf((char const   */* __restrict  */)"PATH,TYPE,VALUE,MTIME,OWNER,GROUP,SACL,DACL,CLASS\n");
      }
    } else {
      {
#line 649
      printf((char const   */* __restrict  */)"PATH,TYPE,VALUE,MTIME\n");
      }
    }
  }
#line 652
  if (path_filter_enabled) {
#line 652
    if ((unsigned long )path_filter != (unsigned long )((void *)0)) {
      {
#line 653
      path = splitPath((char const   *)path_filter);
      }
    }
  }
#line 655
  if ((unsigned long )path != (unsigned long )((void *)0)) {
    {
#line 657
    retr_path_ret = retrievePath(iter, path);
#line 658
    printMsgs(iter->f);
#line 659
    freePath(path);
    }
#line 661
    if (retr_path_ret == 0) {
      {
#line 662
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"WARN: Specified path \'%s\' not found.\n",
              path_filter);
      }
    } else
#line 663
    if (retr_path_ret == 2) {
      {
#line 664
      printKeyTree(iter);
      }
    } else
#line 665
    if (retr_path_ret < 0) {
      {
#line 667
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR: retrievePath() returned %d.\n",
              retr_path_ret);
#line 669
      bailOut(65, (char *)"ERROR: Unknown error occurred in retrieving path.\n");
      }
    }
  } else {
    {
#line 674
    printKeyTree(iter);
    }
  }
  {
#line 676
  regfi_iterator_free(iter);
#line 677
  regfi_close(f);
  }
#line 679
  return (0);
}
}
#line 178 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) ceil)(double __x )  __attribute__((__const__)) ;
#line 111 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/include/range_list.h"
_Bool range_list_remove(range_list *rl , uint32_t index___0 ) ;
#line 132
int32_t range_list_find(range_list const   *rl , uint32_t offset ) ;
#line 167
_Bool range_list_split_element(range_list *rl , uint32_t index___0 , uint32_t offset ) ;
#line 179
_Bool range_list_has_range(range_list *rl , uint32_t start , uint32_t length ) ;
#line 51 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/range_list.c"
static _Bool range_list_insert(range_list *rl , range_list_element *elem , uint32_t index___0 ) 
{ 
  uint32_t i ;
  range_list_element **tmp ;
  void *tmp___0 ;

  {
#line 56
  if (rl->size == rl->elem_alloced) {
    {
#line 58
    tmp___0 = _talloc_realloc_array((void const   *)rl, (void *)rl->elements, sizeof(range_list_element *),
                                    rl->elem_alloced + 256U, "range_list_element*");
#line 58
    tmp = (range_list_element **)tmp___0;
    }
#line 60
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 61
      return ((_Bool)0);
    }
#line 62
    rl->elements = tmp;
#line 63
    rl->elem_alloced += 256U;
  }
#line 67
  i = rl->size;
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
#line 67
    if (! (i > index___0)) {
#line 67
      goto while_break;
    }
#line 68
    *(rl->elements + i) = *(rl->elements + (i - 1U));
#line 67
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 69
  *(rl->elements + index___0) = elem;
#line 71
  (rl->size) ++;
#line 72
  return ((_Bool)1);
}
}
#line 81 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/range_list.c"
static int32_t range_list_find_previous(range_list const   *rl , uint32_t offset ) 
{ 
  uint32_t h_idx ;
  uint32_t l_idx ;
  uint32_t cur_idx ;
  uint32_t h_val ;
  uint32_t l_val ;
  range_list_element *cur_elem ;
  double tmp ;

  {
#line 87
  if (rl->size == 0U) {
#line 88
    return (-1);
  } else
#line 87
  if (offset < (*(rl->elements + 0))->offset) {
#line 88
    return (-1);
  }
#line 90
  if (offset >= (*(rl->elements + (rl->size - 1U)))->offset) {
#line 91
    return ((int32_t )(rl->size - 1U));
  }
#line 93
  h_idx = (uint32_t )(rl->size - 1U);
#line 94
  l_idx = (uint32_t )0;
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;
#line 95
    if (! (h_idx != l_idx)) {
#line 95
      goto while_break;
    }
    {
#line 97
    h_val = (*(rl->elements + h_idx))->offset + (*(rl->elements + h_idx))->length;
#line 98
    l_val = (*(rl->elements + l_idx))->offset;
#line 102
    tmp = ceil((((double )offset - (double )l_val) / (double )(h_val - l_val)) * (double )(h_idx - l_idx));
#line 102
    cur_idx = (uint32_t )tmp;
    }
#line 103
    if (cur_idx > h_idx) {
#line 104
      cur_idx = h_idx;
    }
#line 105
    if (cur_idx < l_idx) {
#line 106
      cur_idx = l_idx;
    }
#line 107
    cur_elem = *(rl->elements + cur_idx);
#line 109
    if (offset >= cur_elem->offset) {
#line 109
      if (offset < (*(rl->elements + (cur_idx + 1U)))->offset) {
#line 110
        return ((int32_t )cur_idx);
      }
    }
#line 112
    if (offset < cur_elem->offset) {
#line 113
      h_idx = cur_idx - 1U;
    } else {
#line 115
      l_idx = cur_idx + 1U;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 118
  return ((int32_t )h_idx);
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/range_list.c"
range_list *range_list_new(void) 
{ 
  range_list *rl ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 129
  tmp = talloc_named_const((void const   *)((void *)0), sizeof(range_list ), "range_list");
#line 129
  rl = (range_list *)tmp;
  }
#line 130
  if ((unsigned long )rl == (unsigned long )((void *)0)) {
#line 131
    return ((range_list *)((void *)0));
  }
  {
#line 133
  tmp___0 = _talloc_array((void const   *)rl, sizeof(range_list_element *), 256U,
                          "range_list_element*");
#line 133
  rl->elements = (range_list_element **)tmp___0;
  }
#line 134
  if ((unsigned long )rl->elements == (unsigned long )((void *)0)) {
    {
#line 136
    talloc_free((void *)rl);
    }
#line 137
    return ((range_list *)((void *)0));
  }
#line 140
  rl->elem_alloced = (uint32_t )256;
#line 141
  rl->size = (uint32_t )0;
#line 143
  return (rl);
}
}
#line 147 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/range_list.c"
void range_list_free(range_list *rl ) 
{ 


  {
#line 149
  if ((unsigned long )rl != (unsigned long )((void *)0)) {
    {
#line 150
    talloc_free((void *)rl);
    }
  }
#line 151
  return;
}
}
#line 154 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/range_list.c"
uint32_t range_list_size(range_list const   *rl ) 
{ 


  {
#line 156
  return ((uint32_t )rl->size);
}
}
#line 161 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/range_list.c"
_Bool range_list_add(range_list *rl , uint32_t offset , uint32_t length , void *data ) 
{ 
  uint32_t insert_index ;
  range_list_element *elem ;
  range_list_element *prev_elem ;
  int32_t tmp ;
  void *tmp___0 ;
  _Bool tmp___1 ;

  {
#line 168
  if (rl->size >= 2147483647U) {
#line 169
    return ((_Bool)0);
  }
#line 172
  if (length == 0U) {
#line 173
    return ((_Bool)0);
  }
#line 176
  if (offset + length < offset) {
#line 177
    return ((_Bool)0);
  } else
#line 176
  if (offset + length < length) {
#line 177
    return ((_Bool)0);
  }
  {
#line 180
  tmp = range_list_find_previous((range_list const   *)rl, offset);
#line 180
  insert_index = (uint32_t )(tmp + 1);
  }
#line 183
  if (insert_index > 0U) {
#line 185
    prev_elem = *(rl->elements + (insert_index - 1U));
#line 186
    if (offset < prev_elem->length + prev_elem->offset) {
#line 187
      return ((_Bool)0);
    }
  }
#line 191
  if (insert_index + 1U < rl->size) {
#line 191
    if (offset + length > (*(rl->elements + (insert_index + 1U)))->offset) {
#line 193
      return ((_Bool)0);
    }
  }
  {
#line 195
  tmp___0 = talloc_named_const((void const   *)rl->elements, sizeof(range_list_element ),
                               "range_list_element");
#line 195
  elem = (range_list_element *)tmp___0;
  }
#line 196
  if ((unsigned long )elem == (unsigned long )((void *)0)) {
#line 197
    return ((_Bool)0);
  }
  {
#line 198
  elem->offset = offset;
#line 199
  elem->length = length;
#line 200
  elem->data = data;
#line 202
  tmp___1 = range_list_insert(rl, elem, insert_index);
  }
#line 202
  if (! tmp___1) {
    {
#line 204
    talloc_free((void *)elem);
    }
#line 205
    return ((_Bool)0);
  }
#line 208
  return ((_Bool)1);
}
}
#line 212 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/range_list.c"
_Bool range_list_remove(range_list *rl , uint32_t index___0 ) 
{ 
  uint32_t i ;
  range_list_element **tmp ;
  void *tmp___0 ;

  {
#line 217
  if (index___0 >= rl->size) {
#line 218
    return ((_Bool)0);
  }
  {
#line 220
  talloc_free((void *)*(rl->elements + index___0));
#line 223
  i = index___0;
  }
  {
#line 223
  while (1) {
    while_continue: /* CIL Label */ ;
#line 223
    if (! (i < rl->size - 1U)) {
#line 223
      goto while_break;
    }
#line 224
    *(rl->elements + i) = *(rl->elements + (i + 1U));
#line 223
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 225
  *(rl->elements + (rl->size - 1U)) = (range_list_element *)((void *)0);
#line 226
  (rl->size) --;
#line 229
  if (rl->size + 512U < rl->elem_alloced) {
    {
#line 231
    tmp___0 = _talloc_realloc_array((void const   *)rl, (void *)rl->elements, sizeof(range_list_element *),
                                    rl->elem_alloced - 512U, "range_list_element*");
#line 231
    tmp = (range_list_element **)tmp___0;
    }
#line 233
    if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 235
      rl->elements = tmp;
#line 236
      rl->elem_alloced -= 512U;
    }
  }
#line 240
  return ((_Bool)1);
}
}
#line 244 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/range_list.c"
range_list_element const   *range_list_get(range_list const   *rl , uint32_t index___0 ) 
{ 


  {
#line 246
  if (index___0 >= (uint32_t )rl->size) {
#line 247
    return ((range_list_element const   *)((void *)0));
  }
#line 249
  return ((range_list_element const   *)*(rl->elements + index___0));
}
}
#line 253 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/range_list.c"
int32_t range_list_find(range_list const   *rl , uint32_t offset ) 
{ 
  uint32_t prev_idx ;
  range_list_element *elem ;
  int32_t tmp ;

  {
#line 258
  if (rl->size == 0U) {
#line 259
    return (-1);
  }
#line 261
  if (offset < (*(rl->elements + 0))->offset) {
#line 264
    return (-2);
  } else
#line 261
  if (offset > (*(rl->elements + (rl->size - 1U)))->offset + (*(rl->elements + (rl->size - 1U)))->length) {
#line 264
    return (-2);
  }
  {
#line 266
  tmp = range_list_find_previous(rl, offset);
#line 266
  prev_idx = (uint32_t )tmp;
#line 267
  elem = *(rl->elements + prev_idx);
  }
#line 268
  if (offset < elem->offset + elem->length) {
#line 269
    return ((int32_t )prev_idx);
  }
#line 271
  return (-3);
}
}
#line 275 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/range_list.c"
void *range_list_find_data(range_list const   *rl , uint32_t offset ) 
{ 
  int32_t index___0 ;
  int32_t tmp ;

  {
  {
#line 277
  tmp = range_list_find(rl, offset);
#line 277
  index___0 = tmp;
  }
#line 278
  if (index___0 < 0) {
#line 279
    return ((void *)0);
  }
#line 281
  return ((*(rl->elements + index___0))->data);
}
}
#line 285 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/range_list.c"
_Bool range_list_split_element(range_list *rl , uint32_t index___0 , uint32_t offset ) 
{ 
  range_list_element *cur_elem ;
  range_list_element *new_elem ;
  void *tmp ;
  _Bool tmp___0 ;

  {
#line 290
  if (index___0 >= rl->size) {
#line 291
    return ((_Bool)0);
  }
#line 293
  cur_elem = *(rl->elements + index___0);
#line 294
  if (offset <= cur_elem->offset) {
#line 296
    return ((_Bool)0);
  } else
#line 294
  if (offset >= cur_elem->offset + cur_elem->length) {
#line 296
    return ((_Bool)0);
  }
  {
#line 298
  tmp = talloc_named_const((void const   *)rl->elements, sizeof(range_list_element ),
                           "range_list_element");
#line 298
  new_elem = (range_list_element *)tmp;
  }
#line 299
  if ((unsigned long )new_elem == (unsigned long )((void *)0)) {
#line 300
    return ((_Bool)0);
  }
  {
#line 302
  new_elem->offset = offset;
#line 303
  new_elem->length = (cur_elem->offset + cur_elem->length) - offset;
#line 304
  new_elem->data = cur_elem->data;
#line 306
  tmp___0 = range_list_insert(rl, new_elem, index___0 + 1U);
  }
#line 306
  if (! tmp___0) {
    {
#line 308
    talloc_free((void *)new_elem);
    }
#line 309
    return ((_Bool)0);
  }
#line 312
  cur_elem->length = new_elem->offset - cur_elem->offset;
#line 314
  return ((_Bool)1);
}
}
#line 318 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/range_list.c"
_Bool range_list_has_range(range_list *rl , uint32_t start , uint32_t length ) 
{ 
  int32_t idx1 ;
  int32_t idx2 ;

  {
  {
#line 322
  idx1 = range_list_find((range_list const   *)rl, start);
  }
#line 323
  if (idx1 < 0) {
#line 324
    return ((_Bool)0);
  }
  {
#line 326
  idx2 = range_list_find((range_list const   *)rl, start + length);
  }
#line 327
  if (idx2 < 0) {
#line 328
    return ((_Bool)0);
  }
#line 330
  if (idx1 == idx2) {
#line 331
    return ((_Bool)1);
  }
  {
#line 333
  while (1) {
    while_continue: /* CIL Label */ ;
#line 333
    if (! (idx1 != idx2)) {
#line 333
      goto while_break;
    }
#line 335
    if ((*(rl->elements + idx1))->offset + (*(rl->elements + idx1))->length != (*(rl->elements + (idx1 + 1)))->offset) {
#line 337
      return ((_Bool)0);
    }
#line 338
    idx1 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 341
  return ((_Bool)1);
}
}
/* compiler builtin: 
   void __builtin_va_copy(__builtin_va_list  , __builtin_va_list  ) ;  */
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
#line 515 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 519
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atexit)(void (*__func)(void) ) ;
#line 242 "/usr/include/stdio.h"
extern int fflush(FILE *__stream ) ;
#line 104 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/include/talloc.h"
void *_talloc(void const   *context , size_t size ) ;
#line 105
void *talloc_pool(void const   *context , size_t size ) ;
#line 106
void _talloc_set_destructor(void const   *ptr , int (*destructor)(void * ) ) ;
#line 107
int talloc_increase_ref_count(void const   *ptr ) ;
#line 108
size_t talloc_reference_count(void const   *ptr ) ;
#line 109
void *_talloc_reference(void const   *context , void const   *ptr ) ;
#line 110
int talloc_unlink(void const   *context , void *ptr ) ;
#line 111
char const   *( /* format attribute */  talloc_set_name)(void const   *ptr , char const   *fmt 
                                                         , ...) ;
#line 112
void talloc_set_name_const(void const   *ptr , char const   *name ) ;
#line 113
void *( /* format attribute */  talloc_named)(void const   *context , size_t size ,
                                              char const   *fmt  , ...) ;
#line 116
char const   *talloc_get_name(void const   *ptr ) ;
#line 117
void *talloc_check_name(void const   *ptr , char const   *name ) ;
#line 118
void *talloc_parent(void const   *ptr ) ;
#line 119
char const   *talloc_parent_name(void const   *ptr ) ;
#line 120
void *( /* format attribute */  talloc_init)(char const   *fmt  , ...) ;
#line 122
void talloc_free_children(void *ptr ) ;
#line 125
void *_talloc_move(void const   *new_ctx , void const   *_pptr ) ;
#line 126
size_t talloc_total_size(void const   *ptr ) ;
#line 127
size_t talloc_total_blocks(void const   *ptr ) ;
#line 128
void talloc_report_depth_cb(void const   *ptr , int depth , int max_depth , void (*callback)(void const   *ptr ,
                                                                                             int depth ,
                                                                                             int max_depth ,
                                                                                             int is_ref ,
                                                                                             void *private_data ) ,
                            void *private_data ) ;
#line 134
void talloc_report_depth_file(void const   *ptr , int depth , int max_depth , FILE *f___0 ) ;
#line 135
void talloc_report_full(void const   *ptr , FILE *f___0 ) ;
#line 136
void talloc_report(void const   *ptr , FILE *f___0 ) ;
#line 137
void talloc_enable_null_tracking(void) ;
#line 138
void talloc_disable_null_tracking(void) ;
#line 139
void talloc_enable_leak_report(void) ;
#line 140
void talloc_enable_leak_report_full(void) ;
#line 141
void *_talloc_zero(void const   *ctx , size_t size , char const   *name ) ;
#line 142
void *_talloc_memdup(void const   *t , void const   *p , size_t size , char const   *name ) ;
#line 144
void *_talloc_zero_array(void const   *ctx , size_t el_size , unsigned int count ,
                         char const   *name ) ;
#line 146
void *talloc_realloc_fn(void const   *context , void *ptr , size_t size ) ;
#line 147
void *talloc_autofree_context(void) ;
#line 148
size_t talloc_get_size(void const   *context ) ;
#line 149
void *talloc_find_parent_byname(void const   *context , char const   *name ) ;
#line 150
void talloc_show_parents(void const   *context , FILE *file ) ;
#line 151
int talloc_is_parent(void const   *context , void const   *ptr ) ;
#line 153
char *talloc_strdup(void const   *t , char const   *p ) ;
#line 154
char *talloc_strdup_append(char *s , char const   *a ) ;
#line 155
char *talloc_strdup_append_buffer(char *s , char const   *a ) ;
#line 157
char *talloc_strndup(void const   *t , char const   *p , size_t n ) ;
#line 158
char *talloc_strndup_append(char *s , char const   *a , size_t n ) ;
#line 159
char *talloc_strndup_append_buffer(char *s , char const   *a , size_t n ) ;
#line 161
char *( /* format attribute */  talloc_vasprintf)(void const   *t , char const   *fmt ,
                                                  va_list ap ) ;
#line 162
char *( /* format attribute */  talloc_vasprintf_append)(char *s , char const   *fmt ,
                                                         va_list ap ) ;
#line 163
char *( /* format attribute */  talloc_vasprintf_append_buffer)(char *s , char const   *fmt ,
                                                                va_list ap ) ;
#line 165
char *( /* format attribute */  talloc_asprintf)(void const   *t , char const   *fmt 
                                                 , ...) ;
#line 166
char *( /* format attribute */  talloc_asprintf_append)(char *s , char const   *fmt 
                                                        , ...) ;
#line 167
char *( /* format attribute */  talloc_asprintf_append_buffer)(char *s , char const   *fmt 
                                                               , ...) ;
#line 75 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
static void *null_context  ;
#line 76 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
static void *autofree_context  ;
#line 112 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
static void talloc_abort_double_free(void) 
{ 


  {
  {
#line 114
  abort();
  }
}
}
#line 117 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
static void talloc_abort_unknown_value(void) 
{ 


  {
  {
#line 119
  abort();
  }
}
}
#line 123 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
__inline static struct talloc_chunk *talloc_chunk_from_ptr(void const   *ptr ) 
{ 
  char const   *pp ;
  struct talloc_chunk *tc ;
  long tmp ;

  {
  {
#line 125
  pp = (char const   *)ptr;
#line 126
  tc = (struct talloc_chunk *)(pp - ((sizeof(struct talloc_chunk ) + 15UL) & 0xfffffffffffffff0UL));
#line 127
  tmp = __builtin_expect((long )(! (! ((tc->flags & 4294967281U) != 3893685360U))),
                         0L);
  }
#line 127
  if (tmp) {
#line 128
    if (tc->flags & 1U) {
      {
#line 129
      talloc_abort_double_free();
      }
    } else {
      {
#line 131
      talloc_abort_unknown_value();
      }
    }
  }
#line 134
  return (tc);
}
}
#line 168 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
__inline static struct talloc_chunk *talloc_parent_chunk(void const   *ptr ) 
{ 
  struct talloc_chunk *tc ;
  long tmp ;

  {
  {
#line 172
  tmp = __builtin_expect((long )(! (! ((unsigned long )ptr == (unsigned long )((void *)0)))),
                         0L);
  }
#line 172
  if (tmp) {
#line 173
    return ((struct talloc_chunk *)((void *)0));
  }
  {
#line 176
  tc = talloc_chunk_from_ptr(ptr);
  }
  {
#line 177
  while (1) {
    while_continue: /* CIL Label */ ;
#line 177
    if (! tc->prev) {
#line 177
      goto while_break;
    }
#line 177
    tc = tc->prev;
  }
  while_break: /* CIL Label */ ;
  }
#line 179
  return (tc->parent);
}
}
#line 182 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
void *talloc_parent(void const   *ptr ) 
{ 
  struct talloc_chunk *tc ;
  struct talloc_chunk *tmp ;
  void *tmp___0 ;

  {
  {
#line 184
  tmp = talloc_parent_chunk(ptr);
#line 184
  tc = tmp;
  }
#line 185
  if (tc) {
#line 185
    tmp___0 = (void *)((char *)tc + ((sizeof(struct talloc_chunk ) + 15UL) & 0xfffffffffffffff0UL));
  } else {
#line 185
    tmp___0 = (void *)0;
  }
#line 185
  return (tmp___0);
}
}
#line 191 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
char const   *talloc_parent_name(void const   *ptr ) 
{ 
  struct talloc_chunk *tc ;
  struct talloc_chunk *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 193
  tmp = talloc_parent_chunk(ptr);
#line 193
  tc = tmp;
  }
#line 194
  if (tc) {
#line 194
    tmp___0 = tc->name;
  } else {
#line 194
    tmp___0 = (char const   *)((void *)0);
  }
#line 194
  return (tmp___0);
}
}
#line 212 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
static unsigned int *talloc_pool_objectcount(struct talloc_chunk *tc ) 
{ 


  {
#line 214
  return ((unsigned int *)((char *)tc + sizeof(struct talloc_chunk )));
}
}
#line 221 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
static struct talloc_chunk *talloc_alloc_pool(struct talloc_chunk *parent , size_t size ) 
{ 
  struct talloc_chunk *pool_ctx ;
  size_t space_left ;
  struct talloc_chunk *result ;
  size_t chunk_size ;
  unsigned int *tmp ;

  {
#line 224
  pool_ctx = (struct talloc_chunk *)((void *)0);
#line 229
  if ((unsigned long )parent == (unsigned long )((void *)0)) {
#line 230
    return ((struct talloc_chunk *)((void *)0));
  }
#line 233
  if (parent->flags & 4U) {
#line 234
    pool_ctx = parent;
  } else
#line 236
  if (parent->flags & 8U) {
#line 237
    pool_ctx = (struct talloc_chunk *)parent->pool;
  }
#line 240
  if ((unsigned long )pool_ctx == (unsigned long )((void *)0)) {
#line 241
    return ((struct talloc_chunk *)((void *)0));
  }
#line 244
  space_left = (size_t )((((char *)pool_ctx + ((sizeof(struct talloc_chunk ) + 15UL) & 0xfffffffffffffff0UL)) + pool_ctx->size) - (char *)pool_ctx->pool);
#line 250
  chunk_size = (size + 15UL) & 0xfffffffffffffff0UL;
#line 252
  if (space_left < chunk_size) {
#line 253
    return ((struct talloc_chunk *)((void *)0));
  }
  {
#line 256
  result = (struct talloc_chunk *)pool_ctx->pool;
#line 262
  pool_ctx->pool = (void *)((char *)result + chunk_size);
#line 264
  result->flags = 3893685368U;
#line 265
  result->pool = (void *)pool_ctx;
#line 267
  tmp = talloc_pool_objectcount(pool_ctx);
#line 267
  (*tmp) ++;
  }
#line 269
  return (result);
}
}
#line 275 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
__inline static void *__talloc(void const   *context , size_t size ) 
{ 
  struct talloc_chunk *tc ;
  long tmp ;
  long tmp___0 ;
  struct talloc_chunk *tmp___1 ;
  void *tmp___2 ;
  long tmp___3 ;
  struct talloc_chunk *parent ;
  struct talloc_chunk *tmp___4 ;
  struct talloc_chunk *tmp___5 ;
  struct talloc_chunk *tmp___6 ;
  long tmp___7 ;

  {
  {
#line 277
  tc = (struct talloc_chunk *)((void *)0);
#line 279
  tmp = __builtin_expect((long )(! (! ((unsigned long )context == (unsigned long )((void *)0)))),
                         0L);
  }
#line 279
  if (tmp) {
#line 280
    context = (void const   *)null_context;
  }
  {
#line 283
  tmp___0 = __builtin_expect((long )(! (! (size >= 268435456UL))), 0L);
  }
#line 283
  if (tmp___0) {
#line 284
    return ((void *)0);
  }
#line 287
  if ((unsigned long )context != (unsigned long )((void *)0)) {
    {
#line 288
    tmp___1 = talloc_chunk_from_ptr(context);
#line 288
    tc = talloc_alloc_pool(tmp___1, ((sizeof(struct talloc_chunk ) + 15UL) & 0xfffffffffffffff0UL) + size);
    }
  }
#line 292
  if ((unsigned long )tc == (unsigned long )((void *)0)) {
    {
#line 293
    tmp___2 = malloc(((sizeof(struct talloc_chunk ) + 15UL) & 0xfffffffffffffff0UL) + size);
#line 293
    tc = (struct talloc_chunk *)tmp___2;
#line 294
    tmp___3 = __builtin_expect((long )(! (! ((unsigned long )tc == (unsigned long )((void *)0)))),
                               0L);
    }
#line 294
    if (tmp___3) {
#line 294
      return ((void *)0);
    }
#line 295
    tc->flags = 3893685360U;
#line 296
    tc->pool = (void *)0;
  }
  {
#line 299
  tc->size = size;
#line 300
  tc->destructor = (int (*)(void * ))((void *)0);
#line 301
  tc->child = (struct talloc_chunk *)((void *)0);
#line 302
  tc->name = (char const   *)((void *)0);
#line 303
  tc->refs = (struct talloc_reference_handle *)((void *)0);
#line 305
  tmp___7 = __builtin_expect((long )(! (! context)), 1L);
  }
#line 305
  if (tmp___7) {
    {
#line 306
    tmp___4 = talloc_chunk_from_ptr(context);
#line 306
    parent = tmp___4;
    }
#line 308
    if (parent->child) {
#line 309
      (parent->child)->parent = (struct talloc_chunk *)((void *)0);
#line 310
      tc->next = parent->child;
#line 311
      (tc->next)->prev = tc;
    } else {
#line 313
      tc->next = (struct talloc_chunk *)((void *)0);
    }
#line 315
    tc->parent = parent;
#line 316
    tc->prev = (struct talloc_chunk *)((void *)0);
#line 317
    parent->child = tc;
  } else {
#line 319
    tmp___6 = (struct talloc_chunk *)((void *)0);
#line 319
    tc->parent = tmp___6;
#line 319
    tmp___5 = tmp___6;
#line 319
    tc->prev = tmp___5;
#line 319
    tc->next = tmp___5;
  }
#line 322
  return ((void *)((char *)tc + ((sizeof(struct talloc_chunk ) + 15UL) & 0xfffffffffffffff0UL)));
}
}
#line 329 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
void *talloc_pool(void const   *context , size_t size ) 
{ 
  void *result ;
  void *tmp ;
  struct talloc_chunk *tc ;
  long tmp___0 ;
  unsigned int *tmp___1 ;

  {
  {
#line 331
  tmp = __talloc(context, size + 16UL);
#line 331
  result = tmp;
#line 334
  tmp___0 = __builtin_expect((long )(! (! ((unsigned long )result == (unsigned long )((void *)0)))),
                             0L);
  }
#line 334
  if (tmp___0) {
#line 335
    return ((void *)0);
  }
  {
#line 338
  tc = talloc_chunk_from_ptr((void const   *)result);
#line 340
  tc->flags |= 4U;
#line 341
  tc->pool = (void *)((char *)result + 16);
#line 343
  tmp___1 = talloc_pool_objectcount(tc);
#line 343
  *tmp___1 = 1U;
  }
#line 349
  return (result);
}
}
#line 358 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
void _talloc_set_destructor(void const   *ptr , int (*destructor)(void * ) ) 
{ 
  struct talloc_chunk *tc ;
  struct talloc_chunk *tmp ;

  {
  {
#line 360
  tmp = talloc_chunk_from_ptr(ptr);
#line 360
  tc = tmp;
#line 361
  tc->destructor = destructor;
  }
#line 362
  return;
}
}
#line 367 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
int talloc_increase_ref_count(void const   *ptr ) 
{ 
  void *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  {
#line 369
  tmp = _talloc_reference((void const   *)null_context, ptr);
  }
#line 369
  if (tmp) {
#line 369
    tmp___0 = 0;
  } else {
#line 369
    tmp___0 = 1;
  }
  {
#line 369
  tmp___1 = __builtin_expect((long )tmp___0, 0L);
  }
#line 369
  if (tmp___1) {
#line 370
    return (-1);
  }
#line 372
  return (0);
}
}
#line 380 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
static int talloc_reference_destructor(struct talloc_reference_handle *handle ) 
{ 
  struct talloc_chunk *ptr_tc ;
  struct talloc_chunk *tmp ;
  struct talloc_reference_handle *tmp___0 ;

  {
  {
#line 382
  tmp = talloc_chunk_from_ptr((void const   *)handle->ptr);
#line 382
  ptr_tc = tmp;
  }
  {
#line 383
  while (1) {
    while_continue: /* CIL Label */ ;
#line 383
    if ((unsigned long )handle == (unsigned long )ptr_tc->refs) {
#line 383
      ptr_tc->refs = handle->next;
#line 383
      if (ptr_tc->refs) {
#line 383
        (ptr_tc->refs)->prev = (struct talloc_reference_handle *)((void *)0);
      }
    } else {
#line 383
      if (handle->prev) {
#line 383
        (handle->prev)->next = handle->next;
      }
#line 383
      if (handle->next) {
#line 383
        (handle->next)->prev = handle->prev;
      }
    }
#line 383
    if (handle) {
#line 383
      if ((unsigned long )handle != (unsigned long )ptr_tc->refs) {
#line 383
        tmp___0 = (struct talloc_reference_handle *)((void *)0);
#line 383
        handle->prev = tmp___0;
#line 383
        handle->next = tmp___0;
      }
    }
#line 383
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 384
  return (0);
}
}
#line 391 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
__inline static void _talloc_set_name_const(void const   *ptr , char const   *name ) 
{ 
  struct talloc_chunk *tc ;
  struct talloc_chunk *tmp ;

  {
  {
#line 393
  tmp = talloc_chunk_from_ptr(ptr);
#line 393
  tc = tmp;
#line 394
  tc->name = name;
  }
#line 395
  return;
}
}
#line 400 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
__inline static void *_talloc_named_const(void const   *context , size_t size , char const   *name ) 
{ 
  void *ptr ;
  long tmp ;

  {
  {
#line 404
  ptr = __talloc(context, size);
#line 405
  tmp = __builtin_expect((long )(! (! ((unsigned long )ptr == (unsigned long )((void *)0)))),
                         0L);
  }
#line 405
  if (tmp) {
#line 406
    return ((void *)0);
  }
  {
#line 409
  _talloc_set_name_const((void const   *)ptr, name);
  }
#line 411
  return (ptr);
}
}
#line 423 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
void *_talloc_reference(void const   *context , void const   *ptr ) 
{ 
  struct talloc_chunk *tc ;
  struct talloc_reference_handle *handle ;
  long tmp ;
  void *tmp___0 ;
  long tmp___1 ;
  struct talloc_reference_handle *tmp___2 ;

  {
  {
#line 427
  tmp = __builtin_expect((long )(! (! ((unsigned long )ptr == (unsigned long )((void *)0)))),
                         0L);
  }
#line 427
  if (tmp) {
#line 427
    return ((void *)0);
  }
  {
#line 429
  tc = talloc_chunk_from_ptr(ptr);
#line 430
  tmp___0 = _talloc_named_const(context, sizeof(struct talloc_reference_handle ),
                                (char const   *)1);
#line 430
  handle = (struct talloc_reference_handle *)tmp___0;
#line 433
  tmp___1 = __builtin_expect((long )(! (! ((unsigned long )handle == (unsigned long )((void *)0)))),
                             0L);
  }
#line 433
  if (tmp___1) {
#line 433
    return ((void *)0);
  }
  {
#line 438
  _talloc_set_destructor((void const   *)handle, (int (*)(void * ))(& talloc_reference_destructor));
#line 439
  handle->ptr = (void *)ptr;
  }
  {
#line 440
  while (1) {
    while_continue: /* CIL Label */ ;
#line 440
    if (! tc->refs) {
#line 440
      tc->refs = handle;
#line 440
      tmp___2 = (struct talloc_reference_handle *)((void *)0);
#line 440
      handle->prev = tmp___2;
#line 440
      handle->next = tmp___2;
    } else {
#line 440
      (tc->refs)->prev = handle;
#line 440
      handle->next = tc->refs;
#line 440
      handle->prev = (struct talloc_reference_handle *)((void *)0);
#line 440
      tc->refs = handle;
    }
#line 440
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 441
  return (handle->ptr);
}
}
#line 448 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
__inline static int _talloc_free(void *ptr ) 
{ 
  struct talloc_chunk *tc ;
  long tmp ;
  int is_child ;
  int tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  int (*d)(void * ) ;
  int tmp___3 ;
  long tmp___4 ;
  struct talloc_chunk *tmp___5 ;
  void *child ;
  void const   *new_parent ;
  struct talloc_chunk *p ;
  struct talloc_chunk *tmp___6 ;
  long tmp___7 ;
  struct talloc_chunk *p___0 ;
  struct talloc_chunk *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  long tmp___11 ;
  struct talloc_chunk *pool ;
  unsigned int *pool_object_count ;

  {
  {
#line 452
  tmp = __builtin_expect((long )(! (! ((unsigned long )ptr == (unsigned long )((void *)0)))),
                         0L);
  }
#line 452
  if (tmp) {
#line 453
    return (-1);
  }
  {
#line 456
  tc = talloc_chunk_from_ptr((void const   *)ptr);
#line 458
  tmp___1 = __builtin_expect((long )(! (! tc->refs)), 0L);
  }
#line 458
  if (tmp___1) {
    {
#line 467
    is_child = talloc_is_parent((void const   *)tc->refs, (void const   *)ptr);
#line 468
    _talloc_free((void *)tc->refs);
    }
#line 469
    if (is_child) {
      {
#line 470
      tmp___0 = _talloc_free(ptr);
      }
#line 470
      return (tmp___0);
    }
#line 472
    return (-1);
  }
  {
#line 475
  tmp___2 = __builtin_expect((long )(! (! (tc->flags & 2U))), 0L);
  }
#line 475
  if (tmp___2) {
#line 477
    return (0);
  }
  {
#line 480
  tmp___4 = __builtin_expect((long )(! (! tc->destructor)), 0L);
  }
#line 480
  if (tmp___4) {
#line 481
    d = tc->destructor;
#line 482
    if ((unsigned long )d == (unsigned long )((int (*)(void * ))-1)) {
#line 483
      return (-1);
    }
    {
#line 485
    tc->destructor = (int (*)(void * ))-1;
#line 486
    tmp___3 = (*d)(ptr);
    }
#line 486
    if (tmp___3 == -1) {
#line 487
      tc->destructor = d;
#line 488
      return (-1);
    }
#line 490
    tc->destructor = (int (*)(void * ))((void *)0);
  }
#line 493
  if (tc->parent) {
    {
#line 494
    while (1) {
      while_continue: /* CIL Label */ ;
#line 494
      if ((unsigned long )tc == (unsigned long )(tc->parent)->child) {
#line 494
        (tc->parent)->child = tc->next;
#line 494
        if ((tc->parent)->child) {
#line 494
          ((tc->parent)->child)->prev = (struct talloc_chunk *)((void *)0);
        }
      } else {
#line 494
        if (tc->prev) {
#line 494
          (tc->prev)->next = tc->next;
        }
#line 494
        if (tc->next) {
#line 494
          (tc->next)->prev = tc->prev;
        }
      }
#line 494
      if (tc) {
#line 494
        if ((unsigned long )tc != (unsigned long )(tc->parent)->child) {
#line 494
          tmp___5 = (struct talloc_chunk *)((void *)0);
#line 494
          tc->prev = tmp___5;
#line 494
          tc->next = tmp___5;
        }
      }
#line 494
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 495
    if ((tc->parent)->child) {
#line 496
      ((tc->parent)->child)->parent = tc->parent;
    }
  } else {
#line 499
    if (tc->prev) {
#line 499
      (tc->prev)->next = tc->next;
    }
#line 500
    if (tc->next) {
#line 500
      (tc->next)->prev = tc->prev;
    }
  }
#line 503
  tc->flags |= 2U;
  {
#line 505
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 505
    if (! tc->child) {
#line 505
      goto while_break___0;
    }
    {
#line 511
    child = (void *)((char *)tc->child + ((sizeof(struct talloc_chunk ) + 15UL) & 0xfffffffffffffff0UL));
#line 512
    new_parent = (void const   *)null_context;
#line 513
    tmp___7 = __builtin_expect((long )(! (! (tc->child)->refs)), 0L);
    }
#line 513
    if (tmp___7) {
      {
#line 514
      tmp___6 = talloc_parent_chunk((void const   *)(tc->child)->refs);
#line 514
      p = tmp___6;
      }
#line 515
      if (p) {
#line 515
        new_parent = (void const   *)((void *)((char *)p + ((sizeof(struct talloc_chunk ) + 15UL) & 0xfffffffffffffff0UL)));
      }
    }
    {
#line 517
    tmp___9 = _talloc_free(child);
    }
#line 517
    if (tmp___9 == -1) {
#line 517
      tmp___10 = 1;
    } else {
#line 517
      tmp___10 = 0;
    }
    {
#line 517
    tmp___11 = __builtin_expect((long )tmp___10, 0L);
    }
#line 517
    if (tmp___11) {
#line 518
      if ((unsigned long )new_parent == (unsigned long )null_context) {
        {
#line 519
        tmp___8 = talloc_parent_chunk((void const   *)ptr);
#line 519
        p___0 = tmp___8;
        }
#line 520
        if (p___0) {
#line 520
          new_parent = (void const   *)((void *)((char *)p___0 + ((sizeof(struct talloc_chunk ) + 15UL) & 0xfffffffffffffff0UL)));
        }
      }
      {
#line 522
      _talloc_steal(new_parent, (void const   *)child);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 526
  tc->flags |= 1U;
#line 528
  if (tc->flags & 12U) {
#line 532
    if (tc->flags & 4U) {
#line 532
      pool = tc;
    } else {
#line 532
      pool = (struct talloc_chunk *)tc->pool;
    }
    {
#line 535
    pool_object_count = talloc_pool_objectcount(pool);
    }
#line 537
    if (*pool_object_count == 0U) {
      {
#line 538
      abort();
      }
    }
#line 541
    (*pool_object_count) --;
#line 543
    if (*pool_object_count == 0U) {
      {
#line 544
      free((void *)pool);
      }
    }
  } else {
    {
#line 548
    free((void *)tc);
    }
  }
#line 550
  return (0);
}
}
#line 558 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
void *_talloc_steal(void const   *new_ctx , void const   *ptr ) 
{ 
  struct talloc_chunk *tc ;
  struct talloc_chunk *new_tc ;
  long tmp ;
  long tmp___0 ;
  struct talloc_chunk *tmp___1 ;
  struct talloc_chunk *tmp___2 ;
  struct talloc_chunk *tmp___3 ;
  long tmp___4 ;
  int tmp___5 ;
  long tmp___6 ;
  struct talloc_chunk *tmp___7 ;
  struct talloc_chunk *tmp___8 ;

  {
  {
#line 562
  tmp = __builtin_expect((long )(! (! (! ptr))), 0L);
  }
#line 562
  if (tmp) {
#line 563
    return ((void *)0);
  }
  {
#line 566
  tmp___0 = __builtin_expect((long )(! (! ((unsigned long )new_ctx == (unsigned long )((void *)0)))),
                             0L);
  }
#line 566
  if (tmp___0) {
#line 567
    new_ctx = (void const   *)null_context;
  }
  {
#line 570
  tc = talloc_chunk_from_ptr(ptr);
#line 572
  tmp___4 = __builtin_expect((long )(! (! ((unsigned long )new_ctx == (unsigned long )((void *)0)))),
                             0L);
  }
#line 572
  if (tmp___4) {
#line 573
    if (tc->parent) {
      {
#line 574
      while (1) {
        while_continue: /* CIL Label */ ;
#line 574
        if ((unsigned long )tc == (unsigned long )(tc->parent)->child) {
#line 574
          (tc->parent)->child = tc->next;
#line 574
          if ((tc->parent)->child) {
#line 574
            ((tc->parent)->child)->prev = (struct talloc_chunk *)((void *)0);
          }
        } else {
#line 574
          if (tc->prev) {
#line 574
            (tc->prev)->next = tc->next;
          }
#line 574
          if (tc->next) {
#line 574
            (tc->next)->prev = tc->prev;
          }
        }
#line 574
        if (tc) {
#line 574
          if ((unsigned long )tc != (unsigned long )(tc->parent)->child) {
#line 574
            tmp___1 = (struct talloc_chunk *)((void *)0);
#line 574
            tc->prev = tmp___1;
#line 574
            tc->next = tmp___1;
          }
        }
#line 574
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
#line 575
      if ((tc->parent)->child) {
#line 576
        ((tc->parent)->child)->parent = tc->parent;
      }
    } else {
#line 579
      if (tc->prev) {
#line 579
        (tc->prev)->next = tc->next;
      }
#line 580
      if (tc->next) {
#line 580
        (tc->next)->prev = tc->prev;
      }
    }
#line 583
    tmp___3 = (struct talloc_chunk *)((void *)0);
#line 583
    tc->prev = tmp___3;
#line 583
    tmp___2 = tmp___3;
#line 583
    tc->next = tmp___2;
#line 583
    tc->parent = tmp___2;
#line 584
    return ((void *)ptr);
  }
  {
#line 587
  new_tc = talloc_chunk_from_ptr(new_ctx);
  }
#line 589
  if ((unsigned long )tc == (unsigned long )new_tc) {
#line 589
    tmp___5 = 1;
  } else
#line 589
  if ((unsigned long )tc->parent == (unsigned long )new_tc) {
#line 589
    tmp___5 = 1;
  } else {
#line 589
    tmp___5 = 0;
  }
  {
#line 589
  tmp___6 = __builtin_expect((long )tmp___5, 0L);
  }
#line 589
  if (tmp___6) {
#line 590
    return ((void *)ptr);
  }
#line 593
  if (tc->parent) {
    {
#line 594
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 594
      if ((unsigned long )tc == (unsigned long )(tc->parent)->child) {
#line 594
        (tc->parent)->child = tc->next;
#line 594
        if ((tc->parent)->child) {
#line 594
          ((tc->parent)->child)->prev = (struct talloc_chunk *)((void *)0);
        }
      } else {
#line 594
        if (tc->prev) {
#line 594
          (tc->prev)->next = tc->next;
        }
#line 594
        if (tc->next) {
#line 594
          (tc->next)->prev = tc->prev;
        }
      }
#line 594
      if (tc) {
#line 594
        if ((unsigned long )tc != (unsigned long )(tc->parent)->child) {
#line 594
          tmp___7 = (struct talloc_chunk *)((void *)0);
#line 594
          tc->prev = tmp___7;
#line 594
          tc->next = tmp___7;
        }
      }
#line 594
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 595
    if ((tc->parent)->child) {
#line 596
      ((tc->parent)->child)->parent = tc->parent;
    }
  } else {
#line 599
    if (tc->prev) {
#line 599
      (tc->prev)->next = tc->next;
    }
#line 600
    if (tc->next) {
#line 600
      (tc->next)->prev = tc->prev;
    }
  }
#line 603
  tc->parent = new_tc;
#line 604
  if (new_tc->child) {
#line 604
    (new_tc->child)->parent = (struct talloc_chunk *)((void *)0);
  }
  {
#line 605
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 605
    if (! new_tc->child) {
#line 605
      new_tc->child = tc;
#line 605
      tmp___8 = (struct talloc_chunk *)((void *)0);
#line 605
      tc->prev = tmp___8;
#line 605
      tc->next = tmp___8;
    } else {
#line 605
      (new_tc->child)->prev = tc;
#line 605
      tc->next = new_tc->child;
#line 605
      tc->prev = (struct talloc_chunk *)((void *)0);
#line 605
      new_tc->child = tc;
    }
#line 605
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 607
  return ((void *)ptr);
}
}
#line 617 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
__inline static int talloc_unreference(void const   *context , void const   *ptr ) 
{ 
  struct talloc_chunk *tc ;
  struct talloc_chunk *tmp ;
  struct talloc_reference_handle *h ;
  long tmp___0 ;
  struct talloc_chunk *p ;
  struct talloc_chunk *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 619
  tmp = talloc_chunk_from_ptr(ptr);
#line 619
  tc = tmp;
#line 622
  tmp___0 = __builtin_expect((long )(! (! ((unsigned long )context == (unsigned long )((void *)0)))),
                             0L);
  }
#line 622
  if (tmp___0) {
#line 623
    context = (void const   *)null_context;
  }
#line 626
  h = tc->refs;
  {
#line 626
  while (1) {
    while_continue: /* CIL Label */ ;
#line 626
    if (! h) {
#line 626
      goto while_break;
    }
    {
#line 627
    tmp___1 = talloc_parent_chunk((void const   *)h);
#line 627
    p = tmp___1;
    }
#line 628
    if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 629
      if ((unsigned long )context == (unsigned long )((void *)0)) {
#line 629
        goto while_break;
      }
    } else
#line 630
    if ((unsigned long )((void *)((char *)p + ((sizeof(struct talloc_chunk ) + 15UL) & 0xfffffffffffffff0UL))) == (unsigned long )context) {
#line 631
      goto while_break;
    }
#line 626
    h = h->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 634
  if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 635
    return (-1);
  }
  {
#line 638
  tmp___2 = _talloc_free((void *)h);
  }
#line 638
  return (tmp___2);
}
}
#line 645 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
int talloc_unlink(void const   *context , void *ptr ) 
{ 
  struct talloc_chunk *tc_p ;
  struct talloc_chunk *new_p ;
  void *new_parent ;
  int tmp ;
  struct talloc_chunk *tmp___0 ;
  struct talloc_chunk *tmp___1 ;
  struct talloc_chunk *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 650
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
#line 651
    return (-1);
  }
#line 654
  if ((unsigned long )context == (unsigned long )((void *)0)) {
#line 655
    context = (void const   *)null_context;
  }
  {
#line 658
  tmp = talloc_unreference(context, (void const   *)ptr);
  }
#line 658
  if (tmp == 0) {
#line 659
    return (0);
  }
#line 662
  if ((unsigned long )context == (unsigned long )((void *)0)) {
    {
#line 663
    tmp___0 = talloc_parent_chunk((void const   *)ptr);
    }
#line 663
    if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 664
      return (-1);
    }
  } else {
    {
#line 667
    tmp___1 = talloc_chunk_from_ptr(context);
#line 667
    tmp___2 = talloc_parent_chunk((void const   *)ptr);
    }
#line 667
    if ((unsigned long )tmp___1 != (unsigned long )tmp___2) {
#line 668
      return (-1);
    }
  }
  {
#line 672
  tc_p = talloc_chunk_from_ptr((void const   *)ptr);
  }
#line 674
  if ((unsigned long )tc_p->refs == (unsigned long )((void *)0)) {
    {
#line 675
    tmp___3 = _talloc_free(ptr);
    }
#line 675
    return (tmp___3);
  }
  {
#line 678
  new_p = talloc_parent_chunk((void const   *)tc_p->refs);
  }
#line 679
  if (new_p) {
#line 680
    new_parent = (void *)((char *)new_p + ((sizeof(struct talloc_chunk ) + 15UL) & 0xfffffffffffffff0UL));
  } else {
#line 682
    new_parent = (void *)0;
  }
  {
#line 685
  tmp___4 = talloc_unreference((void const   *)new_parent, (void const   *)ptr);
  }
#line 685
  if (tmp___4 != 0) {
#line 686
    return (-1);
  }
  {
#line 689
  _talloc_steal((void const   *)new_parent, (void const   *)ptr);
  }
#line 691
  return (0);
}
}
#line 697
__inline static char const   *( /* format attribute */  talloc_set_name_v)(void const   *ptr ,
                                                                           char const   *fmt ,
                                                                           va_list ap ) ;
#line 699 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
__inline static char const   *( /* format attribute */  talloc_set_name_v)(void const   *ptr ,
                                                                           char const   *fmt ,
                                                                           va_list ap ) 
{ 
  struct talloc_chunk *tc ;
  struct talloc_chunk *tmp ;
  char *tmp___0 ;
  long tmp___1 ;

  {
  {
#line 701
  tmp = talloc_chunk_from_ptr(ptr);
#line 701
  tc = tmp;
#line 702
  tmp___0 = talloc_vasprintf(ptr, fmt, ap);
#line 702
  tc->name = (char const   *)tmp___0;
#line 703
  tmp___1 = __builtin_expect((long )(! (! tc->name)), 1L);
  }
#line 703
  if (tmp___1) {
    {
#line 704
    _talloc_set_name_const((void const   *)tc->name, ".name");
    }
  }
#line 706
  return (tc->name);
}
}
#line 712 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
char const   *( /* format attribute */  talloc_set_name)(void const   *ptr , char const   *fmt 
                                                         , ...) 
{ 
  char const   *name ;
  va_list ap ;

  {
  {
#line 716
  __builtin_va_start(ap, fmt);
#line 717
  name = talloc_set_name_v(ptr, fmt, ap);
#line 718
  __builtin_va_end(ap);
  }
#line 719
  return (name);
}
}
#line 728 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
void *( /* format attribute */  talloc_named)(void const   *context , size_t size ,
                                              char const   *fmt  , ...) 
{ 
  va_list ap ;
  void *ptr ;
  char const   *name ;
  long tmp ;
  long tmp___0 ;

  {
  {
#line 734
  ptr = __talloc(context, size);
#line 735
  tmp = __builtin_expect((long )(! (! ((unsigned long )ptr == (unsigned long )((void *)0)))),
                         0L);
  }
#line 735
  if (tmp) {
#line 735
    return ((void *)0);
  }
  {
#line 737
  __builtin_va_start(ap, fmt);
#line 738
  name = talloc_set_name_v((void const   *)ptr, fmt, ap);
#line 739
  __builtin_va_end(ap);
#line 741
  tmp___0 = __builtin_expect((long )(! (! ((unsigned long )name == (unsigned long )((void *)0)))),
                             0L);
  }
#line 741
  if (tmp___0) {
    {
#line 742
    _talloc_free(ptr);
    }
#line 743
    return ((void *)0);
  }
#line 746
  return (ptr);
}
}
#line 752 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
char const   *talloc_get_name(void const   *ptr ) 
{ 
  struct talloc_chunk *tc ;
  struct talloc_chunk *tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
  {
#line 754
  tmp = talloc_chunk_from_ptr(ptr);
#line 754
  tc = tmp;
#line 755
  tmp___0 = __builtin_expect((long )(! (! ((unsigned long )tc->name == (unsigned long )((char const   *)1)))),
                             0L);
  }
#line 755
  if (tmp___0) {
#line 756
    return (".reference");
  }
  {
#line 758
  tmp___1 = __builtin_expect((long )(! (! tc->name)), 1L);
  }
#line 758
  if (tmp___1) {
#line 759
    return (tc->name);
  }
#line 761
  return ("UNNAMED");
}
}
#line 769 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
void *talloc_check_name(void const   *ptr , char const   *name ) 
{ 
  char const   *pname ;
  long tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
#line 772
  tmp = __builtin_expect((long )(! (! ((unsigned long )ptr == (unsigned long )((void *)0)))),
                         0L);
  }
#line 772
  if (tmp) {
#line 772
    return ((void *)0);
  }
  {
#line 773
  pname = talloc_get_name(ptr);
  }
#line 774
  if ((unsigned long )pname == (unsigned long )name) {
#line 774
    tmp___1 = 1;
  } else {
    {
#line 774
    tmp___0 = strcmp(pname, name);
    }
#line 774
    if (tmp___0 == 0) {
#line 774
      tmp___1 = 1;
    } else {
#line 774
      tmp___1 = 0;
    }
  }
  {
#line 774
  tmp___2 = __builtin_expect((long )tmp___1, 1L);
  }
#line 774
  if (tmp___2) {
#line 775
    return ((void *)ptr);
  }
#line 777
  return ((void *)0);
}
}
#line 784 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
void *( /* format attribute */  talloc_init)(char const   *fmt  , ...) 
{ 
  va_list ap ;
  void *ptr ;
  char const   *name ;
  long tmp ;
  long tmp___0 ;

  {
  {
#line 795
  talloc_enable_null_tracking();
#line 797
  ptr = __talloc((void const   *)((void *)0), (size_t )0);
#line 798
  tmp = __builtin_expect((long )(! (! ((unsigned long )ptr == (unsigned long )((void *)0)))),
                         0L);
  }
#line 798
  if (tmp) {
#line 798
    return ((void *)0);
  }
  {
#line 800
  __builtin_va_start(ap, fmt);
#line 801
  name = talloc_set_name_v((void const   *)ptr, fmt, ap);
#line 802
  __builtin_va_end(ap);
#line 804
  tmp___0 = __builtin_expect((long )(! (! ((unsigned long )name == (unsigned long )((void *)0)))),
                             0L);
  }
#line 804
  if (tmp___0) {
    {
#line 805
    _talloc_free(ptr);
    }
#line 806
    return ((void *)0);
  }
#line 809
  return (ptr);
}
}
#line 817 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
void talloc_free_children(void *ptr ) 
{ 
  struct talloc_chunk *tc ;
  long tmp ;
  void *child ;
  void const   *new_parent ;
  struct talloc_chunk *p ;
  struct talloc_chunk *tmp___0 ;
  long tmp___1 ;
  struct talloc_chunk *p___0 ;
  struct talloc_chunk *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  long tmp___5 ;
  unsigned int *tmp___6 ;

  {
  {
#line 821
  tmp = __builtin_expect((long )(! (! ((unsigned long )ptr == (unsigned long )((void *)0)))),
                         0L);
  }
#line 821
  if (tmp) {
#line 822
    return;
  }
  {
#line 825
  tc = talloc_chunk_from_ptr((void const   *)ptr);
  }
  {
#line 827
  while (1) {
    while_continue: /* CIL Label */ ;
#line 827
    if (! tc->child) {
#line 827
      goto while_break;
    }
    {
#line 833
    child = (void *)((char *)tc->child + ((sizeof(struct talloc_chunk ) + 15UL) & 0xfffffffffffffff0UL));
#line 834
    new_parent = (void const   *)null_context;
#line 835
    tmp___1 = __builtin_expect((long )(! (! (tc->child)->refs)), 0L);
    }
#line 835
    if (tmp___1) {
      {
#line 836
      tmp___0 = talloc_parent_chunk((void const   *)(tc->child)->refs);
#line 836
      p = tmp___0;
      }
#line 837
      if (p) {
#line 837
        new_parent = (void const   *)((void *)((char *)p + ((sizeof(struct talloc_chunk ) + 15UL) & 0xfffffffffffffff0UL)));
      }
    }
    {
#line 839
    tmp___3 = _talloc_free(child);
    }
#line 839
    if (tmp___3 == -1) {
#line 839
      tmp___4 = 1;
    } else {
#line 839
      tmp___4 = 0;
    }
    {
#line 839
    tmp___5 = __builtin_expect((long )tmp___4, 0L);
    }
#line 839
    if (tmp___5) {
#line 840
      if ((unsigned long )new_parent == (unsigned long )null_context) {
        {
#line 841
        tmp___2 = talloc_parent_chunk((void const   *)ptr);
#line 841
        p___0 = tmp___2;
        }
#line 842
        if (p___0) {
#line 842
          new_parent = (void const   *)((void *)((char *)p___0 + ((sizeof(struct talloc_chunk ) + 15UL) & 0xfffffffffffffff0UL)));
        }
      }
      {
#line 844
      _talloc_steal(new_parent, (void const   *)child);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 848
  if (tc->flags & 4U) {
    {
#line 848
    tmp___6 = talloc_pool_objectcount(tc);
    }
#line 848
    if (*tmp___6 == 1U) {
#line 850
      tc->pool = (void *)(((char *)tc + ((sizeof(struct talloc_chunk ) + 15UL) & 0xfffffffffffffff0UL)) + 16);
    }
  }
#line 856
  return;
}
}
#line 861 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
void *_talloc(void const   *context , size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 863
  tmp = __talloc(context, size);
  }
#line 863
  return (tmp);
}
}
#line 869 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
void talloc_set_name_const(void const   *ptr , char const   *name ) 
{ 


  {
  {
#line 871
  _talloc_set_name_const(ptr, name);
  }
#line 872
  return;
}
}
#line 879 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
void *talloc_named_const(void const   *context , size_t size , char const   *name ) 
{ 
  void *tmp ;

  {
  {
#line 881
  tmp = _talloc_named_const(context, size, name);
  }
#line 881
  return (tmp);
}
}
#line 892 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
int talloc_free(void *ptr ) 
{ 
  int tmp ;

  {
  {
#line 894
  tmp = _talloc_free(ptr);
  }
#line 894
  return (tmp);
}
}
#line 903 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
void *_talloc_realloc(void const   *context , void *ptr , size_t size , char const   *name ) 
{ 
  struct talloc_chunk *tc ;
  void *new_ptr ;
  _Bool malloced ;
  long tmp ;
  long tmp___0 ;
  void *tmp___1 ;
  long tmp___2 ;
  struct talloc_chunk *tmp___3 ;
  unsigned int *tmp___4 ;
  size_t tmp___5 ;
  long tmp___6 ;

  {
  {
#line 907
  malloced = (_Bool)0;
#line 910
  tmp = __builtin_expect((long )(! (! (size == 0UL))), 0L);
  }
#line 910
  if (tmp) {
    {
#line 911
    _talloc_free(ptr);
    }
#line 912
    return ((void *)0);
  }
  {
#line 915
  tmp___0 = __builtin_expect((long )(! (! (size >= 268435456UL))), 0L);
  }
#line 915
  if (tmp___0) {
#line 916
    return ((void *)0);
  }
#line 920
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
    {
#line 921
    tmp___1 = _talloc_named_const(context, size, name);
    }
#line 921
    return (tmp___1);
  }
  {
#line 924
  tc = talloc_chunk_from_ptr((void const   *)ptr);
#line 927
  tmp___2 = __builtin_expect((long )(! (! tc->refs)), 0L);
  }
#line 927
  if (tmp___2) {
#line 928
    return ((void *)0);
  }
#line 932
  if (size < tc->size) {
#line 932
    if (tc->size - size < 1024UL) {
#line 933
      tc->size = size;
#line 934
      return (ptr);
    }
  }
#line 938
  tc->flags |= 1U;
#line 947
  if (tc->flags & 8U) {
    {
#line 949
    tmp___3 = talloc_alloc_pool(tc, size + ((sizeof(struct talloc_chunk ) + 15UL) & 0xfffffffffffffff0UL));
#line 949
    new_ptr = (void *)tmp___3;
#line 950
    tmp___4 = talloc_pool_objectcount((struct talloc_chunk *)tc->pool);
#line 950
    (*tmp___4) --;
    }
#line 953
    if ((unsigned long )new_ptr == (unsigned long )((void *)0)) {
      {
#line 954
      new_ptr = malloc(((sizeof(struct talloc_chunk ) + 15UL) & 0xfffffffffffffff0UL) + size);
#line 955
      malloced = (_Bool)1;
      }
    }
#line 958
    if (new_ptr) {
#line 959
      if (tc->size < size) {
#line 959
        tmp___5 = tc->size;
      } else {
#line 959
        tmp___5 = size;
      }
      {
#line 959
      memcpy((void */* __restrict  */)new_ptr, (void const   */* __restrict  */)tc,
             tmp___5 + ((sizeof(struct talloc_chunk ) + 15UL) & 0xfffffffffffffff0UL));
      }
    }
  } else {
    {
#line 963
    new_ptr = realloc((void *)tc, size + ((sizeof(struct talloc_chunk ) + 15UL) & 0xfffffffffffffff0UL));
    }
  }
  {
#line 966
  tmp___6 = __builtin_expect((long )(! (! (! new_ptr))), 0L);
  }
#line 966
  if (tmp___6) {
#line 967
    tc->flags &= 4294967294U;
#line 968
    return ((void *)0);
  }
#line 971
  tc = (struct talloc_chunk *)new_ptr;
#line 972
  tc->flags &= 4294967294U;
#line 973
  if (malloced) {
#line 974
    tc->flags &= 4294967287U;
  }
#line 976
  if (tc->parent) {
#line 977
    (tc->parent)->child = tc;
  }
#line 979
  if (tc->child) {
#line 980
    (tc->child)->parent = tc;
  }
#line 983
  if (tc->prev) {
#line 984
    (tc->prev)->next = tc;
  }
#line 986
  if (tc->next) {
#line 987
    (tc->next)->prev = tc;
  }
  {
#line 990
  tc->size = size;
#line 991
  _talloc_set_name_const((void const   *)((void *)((char *)tc + ((sizeof(struct talloc_chunk ) + 15UL) & 0xfffffffffffffff0UL))),
                         name);
  }
#line 993
  return ((void *)((char *)tc + ((sizeof(struct talloc_chunk ) + 15UL) & 0xfffffffffffffff0UL)));
}
}
#line 1000 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
void *_talloc_move(void const   *new_ctx , void const   *_pptr ) 
{ 
  void const   **pptr ;
  void *ret ;
  void *tmp ;

  {
  {
#line 1002
  pptr = (void const   **)_pptr;
#line 1003
  tmp = _talloc_steal(new_ctx, *pptr);
#line 1003
  ret = tmp;
#line 1004
  *pptr = (void const   *)((void *)0);
  }
#line 1005
  return (ret);
}
}
#line 1011 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
size_t talloc_total_size(void const   *ptr ) 
{ 
  size_t total ;
  struct talloc_chunk *c ;
  struct talloc_chunk *tc ;
  size_t tmp ;

  {
#line 1013
  total = (size_t )0;
#line 1016
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
#line 1017
    ptr = (void const   *)null_context;
  }
#line 1019
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
#line 1020
    return ((size_t )0);
  }
  {
#line 1023
  tc = talloc_chunk_from_ptr(ptr);
  }
#line 1025
  if (tc->flags & 2U) {
#line 1026
    return ((size_t )0);
  }
#line 1029
  tc->flags |= 2U;
#line 1031
  total = tc->size;
#line 1032
  c = tc->child;
  {
#line 1032
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1032
    if (! c) {
#line 1032
      goto while_break;
    }
    {
#line 1033
    tmp = talloc_total_size((void const   *)((void *)((char *)c + ((sizeof(struct talloc_chunk ) + 15UL) & 0xfffffffffffffff0UL))));
#line 1033
    total += tmp;
#line 1032
    c = c->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1036
  tc->flags &= 4294967293U;
#line 1038
  return (total);
}
}
#line 1044 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
size_t talloc_total_blocks(void const   *ptr ) 
{ 
  size_t total ;
  struct talloc_chunk *c ;
  struct talloc_chunk *tc ;
  struct talloc_chunk *tmp ;
  size_t tmp___0 ;

  {
  {
#line 1046
  total = (size_t )0;
#line 1047
  tmp = talloc_chunk_from_ptr(ptr);
#line 1047
  tc = tmp;
  }
#line 1049
  if (tc->flags & 2U) {
#line 1050
    return ((size_t )0);
  }
#line 1053
  tc->flags |= 2U;
#line 1055
  total ++;
#line 1056
  c = tc->child;
  {
#line 1056
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1056
    if (! c) {
#line 1056
      goto while_break;
    }
    {
#line 1057
    tmp___0 = talloc_total_blocks((void const   *)((void *)((char *)c + ((sizeof(struct talloc_chunk ) + 15UL) & 0xfffffffffffffff0UL))));
#line 1057
    total += tmp___0;
#line 1056
    c = c->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1060
  tc->flags &= 4294967293U;
#line 1062
  return (total);
}
}
#line 1068 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
size_t talloc_reference_count(void const   *ptr ) 
{ 
  struct talloc_chunk *tc ;
  struct talloc_chunk *tmp ;
  struct talloc_reference_handle *h ;
  size_t ret ;

  {
  {
#line 1070
  tmp = talloc_chunk_from_ptr(ptr);
#line 1070
  tc = tmp;
#line 1072
  ret = (size_t )0;
#line 1074
  h = tc->refs;
  }
  {
#line 1074
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1074
    if (! h) {
#line 1074
      goto while_break;
    }
#line 1075
    ret ++;
#line 1074
    h = h->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1077
  return (ret);
}
}
#line 1083 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
void talloc_report_depth_cb(void const   *ptr , int depth , int max_depth , void (*callback)(void const   *ptr ,
                                                                                             int depth ,
                                                                                             int max_depth ,
                                                                                             int is_ref ,
                                                                                             void *private_data ) ,
                            void *private_data ) 
{ 
  struct talloc_chunk *c ;
  struct talloc_chunk *tc ;
  struct talloc_reference_handle *h ;

  {
#line 1092
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
#line 1093
    ptr = (void const   *)null_context;
  }
#line 1095
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
#line 1095
    return;
  }
  {
#line 1097
  tc = talloc_chunk_from_ptr(ptr);
  }
#line 1099
  if (tc->flags & 2U) {
#line 1100
    return;
  }
  {
#line 1103
  (*callback)(ptr, depth, max_depth, 0, private_data);
  }
#line 1105
  if (max_depth >= 0) {
#line 1105
    if (depth >= max_depth) {
#line 1106
      return;
    }
  }
#line 1109
  tc->flags |= 2U;
#line 1110
  c = tc->child;
  {
#line 1110
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1110
    if (! c) {
#line 1110
      goto while_break;
    }
#line 1111
    if ((unsigned long )c->name == (unsigned long )((char const   *)1)) {
      {
#line 1112
      h = (struct talloc_reference_handle *)((void *)((char *)c + ((sizeof(struct talloc_chunk ) + 15UL) & 0xfffffffffffffff0UL)));
#line 1113
      (*callback)((void const   *)h->ptr, depth + 1, max_depth, 1, private_data);
      }
    } else {
      {
#line 1115
      talloc_report_depth_cb((void const   *)((void *)((char *)c + ((sizeof(struct talloc_chunk ) + 15UL) & 0xfffffffffffffff0UL))),
                             depth + 1, max_depth, callback, private_data);
      }
    }
#line 1110
    c = c->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1118
  tc->flags &= 4294967293U;
#line 1119
  return;
}
}
#line 1121 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
static void talloc_report_depth_FILE_helper(void const   *ptr , int depth , int max_depth ,
                                            int is_ref , void *_f ) 
{ 
  char const   *name ;
  char const   *tmp ;
  FILE *f___0 ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char const   *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;

  {
  {
#line 1123
  tmp = talloc_get_name(ptr);
#line 1123
  name = tmp;
#line 1124
  f___0 = (FILE *)_f;
  }
#line 1126
  if (is_ref) {
    {
#line 1127
    fprintf((FILE */* __restrict  */)f___0, (char const   */* __restrict  */)"%*sreference to: %s\n",
            depth * 4, "", name);
    }
#line 1128
    return;
  }
#line 1131
  if (depth == 0) {
    {
#line 1132
    tmp___0 = talloc_total_blocks(ptr);
#line 1132
    tmp___1 = talloc_total_size(ptr);
    }
#line 1132
    if (max_depth < 0) {
#line 1132
      tmp___2 = "full ";
    } else {
#line 1132
      tmp___2 = "";
    }
    {
#line 1132
    fprintf((FILE */* __restrict  */)f___0, (char const   */* __restrict  */)"%stalloc report on \'%s\' (total %6lu bytes in %3lu blocks)\n",
            tmp___2, name, tmp___1, tmp___0);
    }
#line 1136
    return;
  }
  {
#line 1139
  tmp___3 = talloc_reference_count(ptr);
#line 1139
  tmp___4 = talloc_total_blocks(ptr);
#line 1139
  tmp___5 = talloc_total_size(ptr);
#line 1139
  fprintf((FILE */* __restrict  */)f___0, (char const   */* __restrict  */)"%*s%-30s contains %6lu bytes in %3lu blocks (ref %d) %p\n",
          depth * 4, "", name, tmp___5, tmp___4, (int )tmp___3, ptr);
  }
#line 1162
  return;
}
}
#line 1167 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
void talloc_report_depth_file(void const   *ptr , int depth , int max_depth , FILE *f___0 ) 
{ 


  {
  {
#line 1169
  talloc_report_depth_cb(ptr, depth, max_depth, & talloc_report_depth_FILE_helper,
                         (void *)f___0);
#line 1170
  fflush(f___0);
  }
#line 1171
  return;
}
}
#line 1176 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
void talloc_report_full(void const   *ptr , FILE *f___0 ) 
{ 


  {
  {
#line 1178
  talloc_report_depth_file(ptr, 0, -1, f___0);
  }
#line 1179
  return;
}
}
#line 1184 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
void talloc_report(void const   *ptr , FILE *f___0 ) 
{ 


  {
  {
#line 1186
  talloc_report_depth_file(ptr, 0, 1, f___0);
  }
#line 1187
  return;
}
}
#line 1192 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
static void talloc_report_null(void) 
{ 
  size_t tmp ;

  {
  {
#line 1194
  tmp = talloc_total_size((void const   *)null_context);
  }
#line 1194
  if (tmp != 0UL) {
    {
#line 1195
    talloc_report((void const   *)null_context, stderr);
    }
  }
#line 1197
  return;
}
}
#line 1202 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
static void talloc_report_null_full(void) 
{ 
  size_t tmp ;

  {
  {
#line 1204
  tmp = talloc_total_size((void const   *)null_context);
  }
#line 1204
  if (tmp != 0UL) {
    {
#line 1205
    talloc_report_full((void const   *)null_context, stderr);
    }
  }
#line 1207
  return;
}
}
#line 1212 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
void talloc_enable_null_tracking(void) 
{ 


  {
#line 1214
  if ((unsigned long )null_context == (unsigned long )((void *)0)) {
    {
#line 1215
    null_context = _talloc_named_const((void const   *)((void *)0), (size_t )0, "null_context");
    }
  }
#line 1217
  return;
}
}
#line 1222 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
void talloc_disable_null_tracking(void) 
{ 


  {
  {
#line 1224
  _talloc_free(null_context);
#line 1225
  null_context = (void *)0;
  }
#line 1226
  return;
}
}
#line 1231 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
void talloc_enable_leak_report(void) 
{ 


  {
  {
#line 1233
  talloc_enable_null_tracking();
#line 1234
  atexit(& talloc_report_null);
  }
#line 1235
  return;
}
}
#line 1240 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
void talloc_enable_leak_report_full(void) 
{ 


  {
  {
#line 1242
  talloc_enable_null_tracking();
#line 1243
  atexit(& talloc_report_null_full);
  }
#line 1244
  return;
}
}
#line 1249 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
void *_talloc_zero(void const   *ctx , size_t size , char const   *name ) 
{ 
  void *p ;
  void *tmp ;

  {
  {
#line 1251
  tmp = _talloc_named_const(ctx, size, name);
#line 1251
  p = tmp;
  }
#line 1253
  if (p) {
    {
#line 1254
    memset(p, '\000', size);
    }
  }
#line 1257
  return (p);
}
}
#line 1263 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
void *_talloc_memdup(void const   *t , void const   *p , size_t size , char const   *name ) 
{ 
  void *newp ;
  void *tmp ;
  long tmp___0 ;

  {
  {
#line 1265
  tmp = _talloc_named_const(t, size, name);
#line 1265
  newp = tmp;
#line 1267
  tmp___0 = __builtin_expect((long )(! (! newp)), 1L);
  }
#line 1267
  if (tmp___0) {
    {
#line 1268
    memcpy((void */* __restrict  */)newp, (void const   */* __restrict  */)p, size);
    }
  }
#line 1271
  return (newp);
}
}
#line 1274 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
__inline static char *__talloc_strlendup(void const   *t , char const   *p , size_t len ) 
{ 
  char *ret ;
  void *tmp ;
  long tmp___0 ;

  {
  {
#line 1278
  tmp = __talloc(t, len + 1UL);
#line 1278
  ret = (char *)tmp;
#line 1279
  tmp___0 = __builtin_expect((long )(! (! (! ret))), 0L);
  }
#line 1279
  if (tmp___0) {
#line 1279
    return ((char *)((void *)0));
  }
  {
#line 1281
  memcpy((void */* __restrict  */)ret, (void const   */* __restrict  */)p, len);
#line 1282
  *(ret + len) = (char)0;
#line 1284
  _talloc_set_name_const((void const   *)ret, (char const   *)ret);
  }
#line 1285
  return (ret);
}
}
#line 1291 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
char *talloc_strdup(void const   *t , char const   *p ) 
{ 
  long tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 1293
  tmp = __builtin_expect((long )(! (! (! p))), 0L);
  }
#line 1293
  if (tmp) {
#line 1293
    return ((char *)((void *)0));
  }
  {
#line 1294
  tmp___0 = strlen(p);
#line 1294
  tmp___1 = __talloc_strlendup(t, p, tmp___0);
  }
#line 1294
  return (tmp___1);
}
}
#line 1300 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
char *talloc_strndup(void const   *t , char const   *p , size_t n ) 
{ 
  long tmp ;
  char *tmp___0 ;

  {
  {
#line 1302
  tmp = __builtin_expect((long )(! (! (! p))), 0L);
  }
#line 1302
  if (tmp) {
#line 1302
    return ((char *)((void *)0));
  }
  {
#line 1303
  tmp___0 = __talloc_strlendup(t, p, n);
  }
#line 1303
  return (tmp___0);
}
}
#line 1306 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
__inline static char *__talloc_strlendup_append(char *s , size_t slen , char const   *a ,
                                                size_t alen ) 
{ 
  char *ret ;
  void *tmp ;
  long tmp___0 ;

  {
  {
#line 1311
  tmp = _talloc_realloc_array((void const   *)((void *)0), (void *)s, sizeof(char ),
                              (unsigned int )((slen + alen) + 1UL), "char");
#line 1311
  ret = (char *)tmp;
#line 1312
  tmp___0 = __builtin_expect((long )(! (! (! ret))), 0L);
  }
#line 1312
  if (tmp___0) {
#line 1312
    return ((char *)((void *)0));
  }
  {
#line 1315
  memcpy((void */* __restrict  */)(ret + slen), (void const   */* __restrict  */)a,
         alen);
#line 1316
  *(ret + (slen + alen)) = (char)0;
#line 1318
  _talloc_set_name_const((void const   *)ret, (char const   *)ret);
  }
#line 1319
  return (ret);
}
}
#line 1325 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
char *talloc_strdup_append(char *s , char const   *a ) 
{ 
  char *tmp ;
  long tmp___0 ;
  long tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 1327
  tmp___0 = __builtin_expect((long )(! (! (! s))), 0L);
  }
#line 1327
  if (tmp___0) {
    {
#line 1328
    tmp = talloc_strdup((void const   *)((void *)0), a);
    }
#line 1328
    return (tmp);
  }
  {
#line 1331
  tmp___1 = __builtin_expect((long )(! (! (! a))), 0L);
  }
#line 1331
  if (tmp___1) {
#line 1332
    return (s);
  }
  {
#line 1335
  tmp___2 = strlen(a);
#line 1335
  tmp___3 = strlen((char const   *)s);
#line 1335
  tmp___4 = __talloc_strlendup_append(s, tmp___3, a, tmp___2);
  }
#line 1335
  return (tmp___4);
}
}
#line 1342 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
char *talloc_strdup_append_buffer(char *s , char const   *a ) 
{ 
  size_t slen ;
  char *tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 1346
  tmp___0 = __builtin_expect((long )(! (! (! s))), 0L);
  }
#line 1346
  if (tmp___0) {
    {
#line 1347
    tmp = talloc_strdup((void const   *)((void *)0), a);
    }
#line 1347
    return (tmp);
  }
  {
#line 1350
  tmp___1 = __builtin_expect((long )(! (! (! a))), 0L);
  }
#line 1350
  if (tmp___1) {
#line 1351
    return (s);
  }
  {
#line 1354
  slen = talloc_get_size((void const   *)s);
#line 1355
  tmp___2 = __builtin_expect((long )(! (! (slen > 0UL))), 1L);
  }
#line 1355
  if (tmp___2) {
#line 1356
    slen --;
  }
  {
#line 1359
  tmp___3 = strlen(a);
#line 1359
  tmp___4 = __talloc_strlendup_append(s, slen, a, tmp___3);
  }
#line 1359
  return (tmp___4);
}
}
#line 1365 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
char *talloc_strndup_append(char *s , char const   *a , size_t n ) 
{ 
  char *tmp ;
  long tmp___0 ;
  long tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 1367
  tmp___0 = __builtin_expect((long )(! (! (! s))), 0L);
  }
#line 1367
  if (tmp___0) {
    {
#line 1368
    tmp = talloc_strdup((void const   *)((void *)0), a);
    }
#line 1368
    return (tmp);
  }
  {
#line 1371
  tmp___1 = __builtin_expect((long )(! (! (! a))), 0L);
  }
#line 1371
  if (tmp___1) {
#line 1372
    return (s);
  }
  {
#line 1375
  tmp___2 = strlen((char const   *)s);
#line 1375
  tmp___3 = __talloc_strlendup_append(s, tmp___2, a, n);
  }
#line 1375
  return (tmp___3);
}
}
#line 1382 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
char *talloc_strndup_append_buffer(char *s , char const   *a , size_t n ) 
{ 
  size_t slen ;
  char *tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 1386
  tmp___0 = __builtin_expect((long )(! (! (! s))), 0L);
  }
#line 1386
  if (tmp___0) {
    {
#line 1387
    tmp = talloc_strdup((void const   *)((void *)0), a);
    }
#line 1387
    return (tmp);
  }
  {
#line 1390
  tmp___1 = __builtin_expect((long )(! (! (! a))), 0L);
  }
#line 1390
  if (tmp___1) {
#line 1391
    return (s);
  }
  {
#line 1394
  slen = talloc_get_size((void const   *)s);
#line 1395
  tmp___2 = __builtin_expect((long )(! (! (slen > 0UL))), 1L);
  }
#line 1395
  if (tmp___2) {
#line 1396
    slen --;
  }
  {
#line 1399
  tmp___3 = __talloc_strlendup_append(s, slen, a, n);
  }
#line 1399
  return (tmp___3);
}
}
#line 1403 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
char *( /* format attribute */  talloc_vasprintf)(void const   *t , char const   *fmt ,
                                                  va_list ap ) 
{ 
  int len ;
  char *ret ;
  va_list ap2 ;
  char c ;
  long tmp ;
  void *tmp___0 ;
  long tmp___1 ;

  {
  {
#line 1411
  __builtin_va_copy(ap2, ap);
#line 1412
  len = vsnprintf((char */* __restrict  */)(& c), (size_t )1, (char const   */* __restrict  */)fmt,
                  ap2);
#line 1413
  __builtin_va_end(ap2);
#line 1414
  tmp = __builtin_expect((long )(! (! (len < 0))), 0L);
  }
#line 1414
  if (tmp) {
#line 1415
    return ((char *)((void *)0));
  }
  {
#line 1418
  tmp___0 = __talloc(t, (size_t )(len + 1));
#line 1418
  ret = (char *)tmp___0;
#line 1419
  tmp___1 = __builtin_expect((long )(! (! (! ret))), 0L);
  }
#line 1419
  if (tmp___1) {
#line 1419
    return ((char *)((void *)0));
  }
  {
#line 1421
  __builtin_va_copy(ap2, ap);
#line 1422
  vsnprintf((char */* __restrict  */)ret, (size_t )(len + 1), (char const   */* __restrict  */)fmt,
            ap2);
#line 1423
  __builtin_va_end(ap2);
#line 1425
  _talloc_set_name_const((void const   *)ret, (char const   *)ret);
  }
#line 1426
  return (ret);
}
}
#line 1434 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
char *( /* format attribute */  talloc_asprintf)(void const   *t , char const   *fmt 
                                                 , ...) 
{ 
  va_list ap ;
  char *ret ;

  {
  {
#line 1439
  __builtin_va_start(ap, fmt);
#line 1440
  ret = talloc_vasprintf(t, fmt, ap);
#line 1441
  __builtin_va_end(ap);
  }
#line 1442
  return (ret);
}
}
#line 1445
__inline static char *( /* format attribute */  __talloc_vaslenprintf_append)(char *s ,
                                                                              size_t slen ,
                                                                              char const   *fmt ,
                                                                              va_list ap ) ;
#line 1449 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
__inline static char *( /* format attribute */  __talloc_vaslenprintf_append)(char *s ,
                                                                              size_t slen ,
                                                                              char const   *fmt ,
                                                                              va_list ap ) 
{ 
  ssize_t alen ;
  va_list ap2 ;
  char c ;
  int tmp ;
  void *tmp___0 ;

  {
  {
#line 1456
  __builtin_va_copy(ap2, ap);
#line 1457
  tmp = vsnprintf((char */* __restrict  */)(& c), (size_t )1, (char const   */* __restrict  */)fmt,
                  ap2);
#line 1457
  alen = (ssize_t )tmp;
#line 1458
  __builtin_va_end(ap2);
  }
#line 1460
  if (alen <= 0L) {
#line 1467
    return (s);
  }
  {
#line 1470
  tmp___0 = _talloc_realloc_array((void const   *)((void *)0), (void *)s, sizeof(char ),
                                  (unsigned int )((slen + (size_t )alen) + 1UL), "char");
#line 1470
  s = (char *)tmp___0;
  }
#line 1471
  if (! s) {
#line 1471
    return ((char *)((void *)0));
  }
  {
#line 1473
  __builtin_va_copy(ap2, ap);
#line 1474
  vsnprintf((char */* __restrict  */)(s + slen), (size_t )(alen + 1L), (char const   */* __restrict  */)fmt,
            ap2);
#line 1475
  __builtin_va_end(ap2);
#line 1477
  _talloc_set_name_const((void const   *)s, (char const   *)s);
  }
#line 1478
  return (s);
}
}
#line 1487 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
char *( /* format attribute */  talloc_vasprintf_append)(char *s , char const   *fmt ,
                                                         va_list ap ) 
{ 
  char *tmp ;
  long tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 1489
  tmp___0 = __builtin_expect((long )(! (! (! s))), 0L);
  }
#line 1489
  if (tmp___0) {
    {
#line 1490
    tmp = talloc_vasprintf((void const   *)((void *)0), fmt, ap);
    }
#line 1490
    return (tmp);
  }
  {
#line 1493
  tmp___1 = strlen((char const   *)s);
#line 1493
  tmp___2 = __talloc_vaslenprintf_append(s, tmp___1, fmt, ap);
  }
#line 1493
  return (tmp___2);
}
}
#line 1501 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
char *( /* format attribute */  talloc_vasprintf_append_buffer)(char *s , char const   *fmt ,
                                                                va_list ap ) 
{ 
  size_t slen ;
  char *tmp ;
  long tmp___0 ;
  long tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 1505
  tmp___0 = __builtin_expect((long )(! (! (! s))), 0L);
  }
#line 1505
  if (tmp___0) {
    {
#line 1506
    tmp = talloc_vasprintf((void const   *)((void *)0), fmt, ap);
    }
#line 1506
    return (tmp);
  }
  {
#line 1509
  slen = talloc_get_size((void const   *)s);
#line 1510
  tmp___1 = __builtin_expect((long )(! (! (slen > 0UL))), 1L);
  }
#line 1510
  if (tmp___1) {
#line 1511
    slen --;
  }
  {
#line 1514
  tmp___2 = __talloc_vaslenprintf_append(s, slen, fmt, ap);
  }
#line 1514
  return (tmp___2);
}
}
#line 1522 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
char *( /* format attribute */  talloc_asprintf_append)(char *s , char const   *fmt 
                                                        , ...) 
{ 
  va_list ap ;

  {
  {
#line 1526
  __builtin_va_start(ap, fmt);
#line 1527
  s = talloc_vasprintf_append(s, fmt, ap);
#line 1528
  __builtin_va_end(ap);
  }
#line 1529
  return (s);
}
}
#line 1537 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
char *( /* format attribute */  talloc_asprintf_append_buffer)(char *s , char const   *fmt 
                                                               , ...) 
{ 
  va_list ap ;

  {
  {
#line 1541
  __builtin_va_start(ap, fmt);
#line 1542
  s = talloc_vasprintf_append_buffer(s, fmt, ap);
#line 1543
  __builtin_va_end(ap);
  }
#line 1544
  return (s);
}
}
#line 1550 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
void *_talloc_array(void const   *ctx , size_t el_size , unsigned int count , char const   *name ) 
{ 
  void *tmp ;

  {
#line 1552
  if ((size_t )count >= 268435456UL / el_size) {
#line 1553
    return ((void *)0);
  }
  {
#line 1555
  tmp = _talloc_named_const(ctx, el_size * (size_t )count, name);
  }
#line 1555
  return (tmp);
}
}
#line 1561 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
void *_talloc_zero_array(void const   *ctx , size_t el_size , unsigned int count ,
                         char const   *name ) 
{ 
  void *tmp ;

  {
#line 1563
  if ((size_t )count >= 268435456UL / el_size) {
#line 1564
    return ((void *)0);
  }
  {
#line 1566
  tmp = _talloc_zero(ctx, el_size * (size_t )count, name);
  }
#line 1566
  return (tmp);
}
}
#line 1572 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
void *_talloc_realloc_array(void const   *ctx , void *ptr , size_t el_size , unsigned int count ,
                            char const   *name ) 
{ 
  void *tmp ;

  {
#line 1574
  if ((size_t )count >= 268435456UL / el_size) {
#line 1575
    return ((void *)0);
  }
  {
#line 1577
  tmp = _talloc_realloc(ctx, ptr, el_size * (size_t )count, name);
  }
#line 1577
  return (tmp);
}
}
#line 1585 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
void *talloc_realloc_fn(void const   *context , void *ptr , size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 1587
  tmp = _talloc_realloc(context, ptr, size, (char const   *)((void *)0));
  }
#line 1587
  return (tmp);
}
}
#line 1591 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
static int talloc_autofree_destructor(void *ptr ) 
{ 


  {
#line 1593
  autofree_context = (void *)0;
#line 1594
  return (0);
}
}
#line 1597 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
static void talloc_autofree(void) 
{ 


  {
  {
#line 1599
  _talloc_free(autofree_context);
  }
#line 1600
  return;
}
}
#line 1606 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
void *talloc_autofree_context(void) 
{ 


  {
#line 1608
  if ((unsigned long )autofree_context == (unsigned long )((void *)0)) {
    {
#line 1609
    autofree_context = _talloc_named_const((void const   *)((void *)0), (size_t )0,
                                           "autofree_context");
#line 1610
    _talloc_set_destructor((void const   *)autofree_context, & talloc_autofree_destructor);
#line 1611
    atexit(& talloc_autofree);
    }
  }
#line 1613
  return (autofree_context);
}
}
#line 1616 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
size_t talloc_get_size(void const   *context ) 
{ 
  struct talloc_chunk *tc ;

  {
#line 1620
  if ((unsigned long )context == (unsigned long )((void *)0)) {
#line 1621
    return ((size_t )0);
  }
  {
#line 1623
  tc = talloc_chunk_from_ptr(context);
  }
#line 1625
  return (tc->size);
}
}
#line 1631 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
void *talloc_find_parent_byname(void const   *context , char const   *name ) 
{ 
  struct talloc_chunk *tc ;
  int tmp ;

  {
#line 1635
  if ((unsigned long )context == (unsigned long )((void *)0)) {
#line 1636
    return ((void *)0);
  }
  {
#line 1639
  tc = talloc_chunk_from_ptr(context);
  }
  {
#line 1640
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1640
    if (! tc) {
#line 1640
      goto while_break;
    }
#line 1641
    if (tc->name) {
      {
#line 1641
      tmp = strcmp(tc->name, name);
      }
#line 1641
      if (tmp == 0) {
#line 1642
        return ((void *)((char *)tc + ((sizeof(struct talloc_chunk ) + 15UL) & 0xfffffffffffffff0UL)));
      }
    }
    {
#line 1644
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1644
      if (tc) {
#line 1644
        if (! tc->prev) {
#line 1644
          goto while_break___0;
        }
      } else {
#line 1644
        goto while_break___0;
      }
#line 1644
      tc = tc->prev;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1645
    if (tc) {
#line 1646
      tc = tc->parent;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1649
  return ((void *)0);
}
}
#line 1655 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
void talloc_show_parents(void const   *context , FILE *file ) 
{ 
  struct talloc_chunk *tc ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 1659
  if ((unsigned long )context == (unsigned long )((void *)0)) {
    {
#line 1660
    fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"talloc no parents for NULL\n");
    }
#line 1661
    return;
  }
  {
#line 1664
  tc = talloc_chunk_from_ptr(context);
#line 1665
  tmp = talloc_get_name(context);
#line 1665
  fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"talloc parents of \'%s\'\n",
          tmp);
  }
  {
#line 1666
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1666
    if (! tc) {
#line 1666
      goto while_break;
    }
    {
#line 1667
    tmp___0 = talloc_get_name((void const   *)((void *)((char *)tc + ((sizeof(struct talloc_chunk ) + 15UL) & 0xfffffffffffffff0UL))));
#line 1667
    fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"\t\'%s\'\n",
            tmp___0);
    }
    {
#line 1668
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1668
      if (tc) {
#line 1668
        if (! tc->prev) {
#line 1668
          goto while_break___0;
        }
      } else {
#line 1668
        goto while_break___0;
      }
#line 1668
      tc = tc->prev;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1669
    if (tc) {
#line 1670
      tc = tc->parent;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1673
  fflush(file);
  }
#line 1674
  return;
}
}
#line 1679 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
int talloc_is_parent(void const   *context , void const   *ptr ) 
{ 
  struct talloc_chunk *tc ;

  {
#line 1683
  if ((unsigned long )context == (unsigned long )((void *)0)) {
#line 1684
    return (0);
  }
  {
#line 1687
  tc = talloc_chunk_from_ptr(context);
  }
  {
#line 1688
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1688
    if (! tc) {
#line 1688
      goto while_break;
    }
#line 1689
    if ((unsigned long )((void *)((char *)tc + ((sizeof(struct talloc_chunk ) + 15UL) & 0xfffffffffffffff0UL))) == (unsigned long )ptr) {
#line 1689
      return (1);
    }
    {
#line 1690
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1690
      if (tc) {
#line 1690
        if (! tc->prev) {
#line 1690
          goto while_break___0;
        }
      } else {
#line 1690
        goto while_break___0;
      }
#line 1690
      tc = tc->prev;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1691
    if (tc) {
#line 1692
      tc = tc->parent;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1695
  return (0);
}
}
#line 32 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/lru_cache.c"
static uint32_t lru_cache_compute_hash___0(uint32_t num_buckets , uint32_t secret ,
                                           void const   *buf , uint32_t buf_len ) 
{ 
  uint32_t i ;
  uint32_t ret_val ;
  unsigned char *s ;
  unsigned char const   *b ;

  {
#line 38
  ret_val = (uint32_t )608135816;
#line 39
  s = (unsigned char *)(& secret);
#line 40
  b = (unsigned char const   *)((unsigned char *)buf);
#line 42
  i = (uint32_t )0;
  {
#line 42
  while (1) {
    while_continue: /* CIL Label */ ;
#line 42
    if (! (i < buf_len)) {
#line 42
      goto while_break;
    }
#line 43
    ret_val = (ret_val + (i ^ (unsigned int )*(s + i % 4U)) * (unsigned int )*(b + i)) % num_buckets;
#line 42
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 45
  return (ret_val);
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/lru_cache.c"
static uint32_t lru_cache_floor_log2___0(uint32_t n ) 
{ 
  uint32_t ret_val ;

  {
#line 55
  ret_val = (uint32_t )31;
  {
#line 55
  while (1) {
    while_continue: /* CIL Label */ ;
#line 55
    if (! (ret_val > 1U)) {
#line 55
      goto while_break;
    }
#line 56
    if ((n & (unsigned int )(1 << ret_val)) != 0U) {
#line 57
      return (ret_val);
    }
#line 55
    ret_val --;
  }
  while_break: /* CIL Label */ ;
  }
#line 59
  return ((uint32_t )0);
}
}
#line 39 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
static char const   *regfi_type_names___0[12]  = 
#line 39 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
  {      "NONE",      "SZ",      "EXPAND_SZ",      "BINARY", 
        "DWORD",      "DWORD_BE",      "LINK",      "MULTI_SZ", 
        "RSRC_LIST",      "RSRC_DESC",      "RSRC_REQ_LIST",      "QWORD"};
#line 117 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
static char const   *regfi_encoding_int2str___0(REGFI_ENCODING e ) 
{ 


  {
#line 119
  if ((int )e < 3) {
#line 120
    return (regfi_encoding_names[e]);
  }
#line 122
  return ((char const   *)((void *)0));
}
}
#line 166 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
static char const   *map___0[7]  = {      "ALLOW",      "DENY",      "AUDIT",      "ALARM", 
        "ALLOW CPD",      "OBJ ALLOW",      "OBJ DENY"};
#line 186 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
static char const   *flag_map___0[32]  = 
#line 186
  {      "OI",      "CI",      "NP",      "IO", 
        "IA",      (char const   *)((void *)0),      (char const   *)((void *)0),      (char const   *)((void *)0)};
#line 245 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
static char const   *perm_map___0[32]  = 
#line 245
  {      "QRY_VAL",      "SET_VAL",      "CREATE_KEY",      "ENUM_KEYS", 
        "NOTIFY",      "CREATE_LNK",      (char const   *)((void *)0),      (char const   *)((void *)0), 
        "WOW64_64",      "WOW64_32",      (char const   *)((void *)0),      (char const   *)((void *)0), 
        (char const   *)((void *)0),      (char const   *)((void *)0),      (char const   *)((void *)0),      (char const   *)((void *)0), 
        "DELETE",      "R_CONT",      "W_DAC",      "W_OWNER", 
        "SYNC",      (char const   *)((void *)0),      (char const   *)((void *)0),      (char const   *)((void *)0), 
        "SYS_SEC",      "MAX_ALLWD",      (char const   *)((void *)0),      (char const   *)((void *)0), 
        "GEN_A",      "GEN_X",      "GEN_W",      "GEN_R"};
#line 2164 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/regfi.c"
static uint32_t regfi_compute_header_checksum___0(uint8_t *buffer ) 
{ 
  uint32_t checksum ;
  uint32_t x ;
  int i ;

  {
#line 2171
  x = (uint32_t )0;
#line 2171
  checksum = x;
#line 2173
  i = 0;
  {
#line 2173
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2173
    if (! (i < 507)) {
#line 2173
      goto while_break;
    }
#line 2174
    x = ((unsigned int )*((unsigned char const   *)buffer + i) | ((unsigned int )*((unsigned char const   *)buffer + (i + 1)) << 8)) | (((unsigned int )*((unsigned char const   *)buffer + (i + 2)) | ((unsigned int )*((unsigned char const   *)buffer + ((i + 2) + 1)) << 8)) << 16);
#line 2175
    checksum ^= x;
#line 2173
    i += 4;
  }
  while_break: /* CIL Label */ ;
  }
#line 2178
  return (checksum);
}
}
#line 35 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/src/reglookup-recover.c"
_Bool print_leftover  =    (_Bool)0;
#line 36 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/src/reglookup-recover.c"
_Bool print_parsedraw  =    (_Bool)0;
#line 70 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/src/common.c"
static char *quote_buffer___0(unsigned char const   *str , unsigned int len , char const   *special ) 
{ 
  unsigned int i ;
  unsigned int added_len ;
  unsigned int num_written ;
  unsigned int buf_len ;
  char *ret_val ;
  char *tmp_buf ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;
  char *tmp___3 ;

  {
#line 74
  num_written = 0U;
#line 76
  buf_len = (unsigned int )(sizeof(char ) * (unsigned long )(len + 1U));
#line 77
  ret_val = (char *)((void *)0);
#line 80
  if (buf_len > 0U) {
    {
#line 81
    tmp = malloc((size_t )buf_len);
#line 81
    ret_val = (char *)tmp;
    }
  }
#line 82
  if ((unsigned long )ret_val == (unsigned long )((void *)0)) {
#line 83
    return ((char *)((void *)0));
  }
#line 85
  i = 0U;
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
#line 85
    if (! (i < len)) {
#line 85
      goto while_break;
    }
#line 87
    if (buf_len <= num_written + 5U) {
#line 95
      added_len = ((len - i) * num_written) / (i + 1U);
#line 96
      if (buf_len + added_len > len * 4U + 1U) {
#line 97
        buf_len = len * 4U + 1U;
      } else
#line 100
      if (added_len < 5U) {
#line 101
        buf_len += 5U;
      } else {
#line 103
        buf_len += added_len;
      }
      {
#line 106
      tmp___0 = realloc((void *)ret_val, (size_t )buf_len);
#line 106
      tmp_buf = (char *)tmp___0;
      }
#line 107
      if ((unsigned long )tmp_buf == (unsigned long )((void *)0)) {
        {
#line 109
        free((void *)ret_val);
        }
#line 110
        return ((char *)((void *)0));
      }
#line 112
      ret_val = tmp_buf;
    }
#line 115
    if ((int const   )*(str + i) < 32) {
      {
#line 117
      tmp___1 = snprintf((char */* __restrict  */)(ret_val + num_written), (size_t )(buf_len - num_written),
                         (char const   */* __restrict  */)"\\x%.2X", (int const   )*(str + i));
#line 117
      num_written += (unsigned int )tmp___1;
      }
    } else
#line 115
    if ((int const   )*(str + i) > 126) {
      {
#line 117
      tmp___1 = snprintf((char */* __restrict  */)(ret_val + num_written), (size_t )(buf_len - num_written),
                         (char const   */* __restrict  */)"\\x%.2X", (int const   )*(str + i));
#line 117
      num_written += (unsigned int )tmp___1;
      }
    } else {
      {
#line 115
      tmp___3 = strchr(special, (int )*(str + i));
      }
#line 115
      if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
        {
#line 117
        tmp___1 = snprintf((char */* __restrict  */)(ret_val + num_written), (size_t )(buf_len - num_written),
                           (char const   */* __restrict  */)"\\x%.2X", (int const   )*(str + i));
#line 117
        num_written += (unsigned int )tmp___1;
        }
      } else {
#line 121
        tmp___2 = num_written;
#line 121
        num_written ++;
#line 121
        *(ret_val + tmp___2) = (char )*(str + i);
      }
    }
#line 85
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 123
  *(ret_val + num_written) = (char )'\000';
#line 125
  return (ret_val);
}
}
#line 134 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/src/common.c"
static char *quote_string___0(char const   *str , char const   *special ) 
{ 
  unsigned int len ;
  size_t tmp ;
  char *tmp___0 ;

  {
#line 138
  if ((unsigned long )str == (unsigned long )((void *)0)) {
#line 139
    return ((char *)((void *)0));
  }
  {
#line 141
  tmp = strlen(str);
#line 141
  len = (unsigned int )tmp;
#line 142
  tmp___0 = quote_buffer___0((unsigned char const   *)str, len, special);
  }
#line 142
  return (tmp___0);
}
}
#line 156 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/src/common.c"
static char *data_to_ascii___0(REGFI_DATA *data , char **error_msg ) 
{ 
  char *ret_val ;
  char *cur_quoted ;
  char *tmp_ptr ;
  char *delim ;
  uint32_t ret_val_left ;
  uint32_t i ;
  uint32_t tmp_len ;
  void *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;
  char *tmp___4 ;
  void *tmp___5 ;
  char *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  void *tmp___18 ;
  char *tmp___19 ;

  {
#line 164
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 164
    goto _L;
  } else
#line 164
  if (data->size == 0U) {
    _L: /* CIL Label */ 
    {
#line 166
    tmp = malloc((size_t )37);
#line 166
    *error_msg = (char *)tmp;
    }
#line 167
    if ((unsigned long )*error_msg == (unsigned long )((void *)0)) {
#line 168
      return ((char *)((void *)0));
    }
    {
#line 169
    strcpy((char */* __restrict  */)*error_msg, (char const   */* __restrict  */)"Data pointer was NULL or size was 0.");
    }
#line 170
    return ((char *)((void *)0));
  }
#line 172
  *error_msg = (char *)((void *)0);
#line 175
  if (data->interpreted_size == 0U) {
    {
#line 177
    tmp___0 = malloc((size_t )51);
#line 177
    *error_msg = (char *)tmp___0;
    }
#line 178
    if ((unsigned long )*error_msg == (unsigned long )((void *)0)) {
#line 179
      return ((char *)((void *)0));
    }
    {
#line 180
    strcpy((char */* __restrict  */)*error_msg, (char const   */* __restrict  */)"Data could not be interpreted, quoting raw buffer.");
#line 181
    tmp___1 = quote_buffer___0((unsigned char const   *)data->raw, data->size, subfield_special_chars);
    }
#line 181
    return (tmp___1);
  }
  {
#line 186
  if (data->type == 1U) {
#line 186
    goto case_1;
  }
#line 195
  if (data->type == 2U) {
#line 195
    goto case_2;
  }
#line 204
  if (data->type == 6U) {
#line 204
    goto case_6;
  }
#line 212
  if (data->type == 4U) {
#line 212
    goto case_4;
  }
#line 221
  if (data->type == 5U) {
#line 221
    goto case_5;
  }
#line 230
  if (data->type == 11U) {
#line 230
    goto case_11;
  }
#line 240
  if (data->type == 7U) {
#line 240
    goto case_7;
  }
#line 267
  if (data->type == 0U) {
#line 267
    goto case_0;
  }
#line 273
  if (data->type == 8U) {
#line 273
    goto case_8;
  }
#line 279
  if (data->type == 9U) {
#line 279
    goto case_9;
  }
#line 285
  if (data->type == 10U) {
#line 285
    goto case_10;
  }
#line 291
  if (data->type == 3U) {
#line 291
    goto case_3;
  }
#line 297
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 187
  ret_val = quote_string___0((char const   *)((char *)data->interpreted.string), common_special_chars);
  }
#line 188
  if ((unsigned long )ret_val == (unsigned long )((void *)0)) {
    {
#line 188
    tmp___3 = malloc((size_t )49);
#line 188
    tmp___2 = (char *)tmp___3;
#line 188
    *error_msg = tmp___2;
    }
#line 188
    if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
      {
#line 189
      strcpy((char */* __restrict  */)*error_msg, (char const   */* __restrict  */)"Buffer could not be quoted due to unknown error.");
      }
    }
  }
#line 191
  return (ret_val);
#line 192
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 196
  ret_val = quote_string___0((char const   *)((char *)data->interpreted.expand_string),
                             common_special_chars);
  }
#line 198
  if ((unsigned long )ret_val == (unsigned long )((void *)0)) {
    {
#line 198
    tmp___5 = malloc((size_t )49);
#line 198
    tmp___4 = (char *)tmp___5;
#line 198
    *error_msg = tmp___4;
    }
#line 198
    if ((unsigned long )tmp___4 != (unsigned long )((void *)0)) {
      {
#line 199
      strcpy((char */* __restrict  */)*error_msg, (char const   */* __restrict  */)"Buffer could not be quoted due to unknown error.");
      }
    }
  }
#line 201
  return (ret_val);
#line 202
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 205
  ret_val = quote_string___0((char const   *)((char *)data->interpreted.link), common_special_chars);
  }
#line 206
  if ((unsigned long )ret_val == (unsigned long )((void *)0)) {
    {
#line 206
    tmp___7 = malloc((size_t )49);
#line 206
    tmp___6 = (char *)tmp___7;
#line 206
    *error_msg = tmp___6;
    }
#line 206
    if ((unsigned long )tmp___6 != (unsigned long )((void *)0)) {
      {
#line 207
      strcpy((char */* __restrict  */)*error_msg, (char const   */* __restrict  */)"Buffer could not be quoted due to unknown error.");
      }
    }
  }
#line 209
  return (ret_val);
#line 210
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 213
  tmp___8 = malloc(sizeof(char ) * 11UL);
#line 213
  ret_val = (char *)tmp___8;
  }
#line 214
  if ((unsigned long )ret_val == (unsigned long )((void *)0)) {
#line 215
    return ((char *)((void *)0));
  }
  {
#line 217
  sprintf((char */* __restrict  */)ret_val, (char const   */* __restrict  */)"0x%.8X",
          data->interpreted.dword);
  }
#line 218
  return (ret_val);
#line 219
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 222
  tmp___9 = malloc(sizeof(char ) * 11UL);
#line 222
  ret_val = (char *)tmp___9;
  }
#line 223
  if ((unsigned long )ret_val == (unsigned long )((void *)0)) {
#line 224
    return ((char *)((void *)0));
  }
  {
#line 226
  sprintf((char */* __restrict  */)ret_val, (char const   */* __restrict  */)"0x%.8X",
          data->interpreted.dword_be);
  }
#line 227
  return (ret_val);
#line 228
  goto switch_break;
  case_11: /* CIL Label */ 
  {
#line 231
  tmp___10 = malloc(sizeof(char ) * 19UL);
#line 231
  ret_val = (char *)tmp___10;
  }
#line 232
  if ((unsigned long )ret_val == (unsigned long )((void *)0)) {
#line 233
    return ((char *)((void *)0));
  }
  {
#line 235
  sprintf((char */* __restrict  */)ret_val, (char const   */* __restrict  */)"0x%.16llX",
          (unsigned long long )data->interpreted.qword);
  }
#line 237
  return (ret_val);
#line 238
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 241
  ret_val_left = data->interpreted_size * 4U + 1U;
#line 242
  tmp___11 = malloc((size_t )ret_val_left);
#line 242
  ret_val = (char *)tmp___11;
  }
#line 243
  if ((unsigned long )ret_val == (unsigned long )((void *)0)) {
#line 244
    return ((char *)((void *)0));
  }
#line 246
  tmp_ptr = ret_val;
#line 247
  *(tmp_ptr + 0) = (char )'\000';
#line 248
  delim = (char *)"";
#line 249
  i = (uint32_t )0;
  {
#line 249
  while (1) {
    while_continue: /* CIL Label */ ;
#line 249
    if (! ((unsigned long )*(data->interpreted.multiple_string + i) != (unsigned long )((void *)0))) {
#line 249
      goto while_break;
    }
    {
#line 251
    cur_quoted = quote_string___0((char const   *)((char *)*(data->interpreted.multiple_string + i)),
                                  subfield_special_chars);
    }
#line 253
    if ((unsigned long )cur_quoted != (unsigned long )((void *)0)) {
#line 253
      if ((int )*(cur_quoted + 0) != 0) {
        {
#line 255
        tmp___12 = snprintf((char */* __restrict  */)tmp_ptr, (size_t )ret_val_left,
                            (char const   */* __restrict  */)"%s%s", delim, cur_quoted);
#line 255
        tmp_len = (uint32_t )tmp___12;
#line 256
        tmp_ptr += tmp_len;
#line 257
        ret_val_left -= tmp_len;
#line 258
        free((void *)cur_quoted);
        }
      }
    }
#line 260
    delim = (char *)"|";
#line 249
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 263
  return (ret_val);
#line 264
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 268
  tmp___13 = quote_buffer___0((unsigned char const   *)data->interpreted.none, data->interpreted_size,
                              common_special_chars);
  }
#line 268
  return (tmp___13);
#line 271
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 274
  tmp___14 = quote_buffer___0((unsigned char const   *)data->interpreted.resource_list,
                              data->interpreted_size, common_special_chars);
  }
#line 274
  return (tmp___14);
#line 277
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 280
  tmp___15 = quote_buffer___0((unsigned char const   *)data->interpreted.full_resource_descriptor,
                              data->interpreted_size, common_special_chars);
  }
#line 280
  return (tmp___15);
#line 283
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 286
  tmp___16 = quote_buffer___0((unsigned char const   *)data->interpreted.resource_requirements_list,
                              data->interpreted_size, common_special_chars);
  }
#line 286
  return (tmp___16);
#line 289
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 292
  tmp___17 = quote_buffer___0((unsigned char const   *)data->interpreted.binary, data->interpreted_size,
                              common_special_chars);
  }
#line 292
  return (tmp___17);
#line 295
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 301
  tmp___18 = malloc((size_t )65);
#line 301
  *error_msg = (char *)tmp___18;
  }
#line 302
  if ((unsigned long )*error_msg == (unsigned long )((void *)0)) {
#line 303
    return ((char *)((void *)0));
  }
  {
#line 304
  sprintf((char */* __restrict  */)*error_msg, (char const   */* __restrict  */)"Unrecognized registry data type (0x%.8X); quoting as binary.",
          data->type);
#line 307
  tmp___19 = quote_buffer___0((unsigned char const   *)data->raw, data->size, common_special_chars);
  }
#line 307
  return (tmp___19);
  switch_break: /* CIL Label */ ;
  }
#line 310
  return ((char *)((void *)0));
}
}
#line 314 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/src/common.c"
static char *get_quoted_keyname___0(REGFI_NK_REC const   *nk ) 
{ 
  char *ret_val ;

  {
#line 318
  if ((unsigned long )nk->keyname == (unsigned long )((void *)0)) {
    {
#line 319
    ret_val = quote_buffer___0((unsigned char const   *)nk->keyname_raw, (unsigned int )nk->name_length,
                               key_special_chars);
    }
  } else {
    {
#line 321
    ret_val = quote_string___0((char const   *)nk->keyname, key_special_chars);
    }
  }
#line 323
  return (ret_val);
}
}
#line 327 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/src/common.c"
static char *get_quoted_valuename___0(REGFI_VK_REC const   *vk ) 
{ 
  char *ret_val ;

  {
#line 331
  if ((unsigned long )vk->valuename == (unsigned long )((void *)0)) {
    {
#line 332
    ret_val = quote_buffer___0((unsigned char const   *)vk->valuename_raw, (unsigned int )vk->name_length,
                               key_special_chars);
    }
  } else {
    {
#line 335
    ret_val = quote_string___0((char const   *)vk->valuename, key_special_chars);
    }
  }
#line 337
  return (ret_val);
}
}
#line 42 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/src/reglookup-recover.c"
char *getQuotedData(int fd , uint32_t offset , uint32_t length ) 
{ 
  uint8_t *buf ;
  char *quoted_buf ;
  uint32_t len ;
  __off_t tmp ;
  void *tmp___0 ;
  uint32_t tmp___1 ;

  {
  {
#line 48
  tmp = lseek(fd, (__off_t )offset, 0);
  }
#line 48
  if (tmp == -1L) {
#line 49
    return ((char *)((void *)0));
  }
  {
#line 51
  tmp___0 = malloc((size_t )length);
#line 51
  buf = (uint8_t *)tmp___0;
  }
#line 52
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 53
    return ((char *)((void *)0));
  }
  {
#line 55
  len = length;
#line 56
  tmp___1 = regfi_read(fd, buf, & length);
  }
#line 56
  if (tmp___1 != 0U) {
    {
#line 58
    free((void *)buf);
    }
#line 59
    return ((char *)((void *)0));
  } else
#line 56
  if (length != len) {
    {
#line 58
    free((void *)buf);
    }
#line 59
    return ((char *)((void *)0));
  }
  {
#line 62
  quoted_buf = quote_buffer___0((unsigned char const   *)buf, length, common_special_chars);
#line 63
  free((void *)buf);
  }
#line 65
  return (quoted_buf);
}
}
#line 187 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/src/reglookup-recover.c"
void printSK(REGFI_FILE *f___0 , REGFI_SK_REC *sk ) 
{ 
  char *quoted_raw ;
  char *empty_str___0 ;
  char *owner ;
  char *tmp ;
  char *group ;
  char *tmp___0 ;
  char *sacl ;
  char *tmp___1 ;
  char *dacl ;
  char *tmp___2 ;

  {
  {
#line 189
  quoted_raw = (char *)((void *)0);
#line 190
  empty_str___0 = (char *)"";
#line 191
  tmp = regfi_get_owner(sk->sec_desc);
#line 191
  owner = tmp;
#line 192
  tmp___0 = regfi_get_group(sk->sec_desc);
#line 192
  group = tmp___0;
#line 193
  tmp___1 = regfi_get_sacl(sk->sec_desc);
#line 193
  sacl = tmp___1;
#line 194
  tmp___2 = regfi_get_dacl(sk->sec_desc);
#line 194
  dacl = tmp___2;
  }
#line 196
  if (print_parsedraw) {
    {
#line 197
    quoted_raw = getQuotedData(f___0->fd, sk->offset, sk->cell_size);
    }
  }
#line 199
  if ((unsigned long )owner == (unsigned long )((void *)0)) {
#line 200
    owner = empty_str___0;
  }
#line 201
  if ((unsigned long )group == (unsigned long )((void *)0)) {
#line 202
    group = empty_str___0;
  }
#line 203
  if ((unsigned long )sacl == (unsigned long )((void *)0)) {
#line 204
    sacl = empty_str___0;
  }
#line 205
  if ((unsigned long )dacl == (unsigned long )((void *)0)) {
#line 206
    dacl = empty_str___0;
  }
  {
#line 208
  printf((char const   */* __restrict  */)"%.8X,%.8X,SK,,,,,,,,%s,%s,%s,%s,%s\n",
         sk->offset, sk->cell_size, owner, group, sacl, dacl, quoted_raw);
  }
#line 211
  if ((unsigned long )owner != (unsigned long )empty_str___0) {
    {
#line 212
    free((void *)owner);
    }
  }
#line 213
  if ((unsigned long )group != (unsigned long )empty_str___0) {
    {
#line 214
    free((void *)group);
    }
  }
#line 215
  if ((unsigned long )sacl != (unsigned long )empty_str___0) {
    {
#line 216
    free((void *)sacl);
    }
  }
#line 217
  if ((unsigned long )dacl != (unsigned long )empty_str___0) {
    {
#line 218
    free((void *)dacl);
    }
  }
#line 220
  if (print_parsedraw) {
    {
#line 221
    free((void *)quoted_raw);
    }
  }
#line 222
  return;
}
}
#line 225 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/src/reglookup-recover.c"
int printCell(REGFI_FILE *f___0 , uint32_t offset ) 
{ 
  char *quoted_buf ;
  uint32_t cell_length ;
  _Bool unalloc ;
  _Bool tmp ;

  {
  {
#line 231
  tmp = regfi_parse_cell(f___0->fd, offset, (uint8_t *)((void *)0), (uint32_t )0,
                         & cell_length, & unalloc);
  }
#line 231
  if (! tmp) {
#line 232
    return (1);
  }
  {
#line 234
  quoted_buf = getQuotedData(f___0->fd, offset, cell_length);
  }
#line 235
  if ((unsigned long )quoted_buf == (unsigned long )((void *)0)) {
#line 236
    return (2);
  }
  {
#line 238
  printf((char const   */* __restrict  */)"%.8X,%.8X,RAW,,,,,,,,,,,,%s\n", offset,
         cell_length, quoted_buf);
#line 240
  free((void *)quoted_buf);
  }
#line 241
  return (0);
}
}
#line 252 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/src/reglookup-recover.c"
char *getParentPath(REGFI_FILE *f___0 , REGFI_NK_REC *nk ) 
{ 
  void_stack *path_stack ;
  void_stack *tmp ;
  REGFI_NK_REC *cur_ancestor ;
  char *ret_val ;
  uint32_t virt_offset ;
  uint32_t i ;
  uint32_t stack_size ;
  uint32_t ret_val_size ;
  uint32_t ret_val_used ;
  uint32_t offset ;
  int32_t max_size ;
  REGFI_BUFFER *path_element ;
  void *tmp___0 ;
  char *tmp___1 ;
  _Bool tmp___2 ;
  size_t tmp___3 ;
  unsigned short tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;

  {
  {
#line 254
  tmp = void_stack_new((unsigned short)512);
#line 254
  path_stack = tmp;
#line 262
  virt_offset = nk->parent_off;
#line 263
  ret_val_size = (uint32_t )1;
  }
  {
#line 264
  while (1) {
    while_continue: /* CIL Label */ ;
#line 264
    if (! (virt_offset != 4294967295U)) {
#line 264
      goto while_break;
    }
    {
#line 266
    offset = virt_offset + 4096U;
#line 267
    max_size = regfi_calc_maxsize(f___0, offset);
    }
#line 268
    if (max_size < 0) {
#line 269
      virt_offset = 4294967295U;
    } else {
      {
#line 272
      cur_ancestor = regfi_parse_nk(f___0, offset, (uint32_t )max_size, (_Bool)1);
#line 273
      printMsgs(f___0);
      }
#line 275
      if ((unsigned long )cur_ancestor == (unsigned long )((void *)0)) {
#line 276
        virt_offset = 4294967295U;
      } else {
#line 279
        if ((int )cur_ancestor->flags & 4) {
#line 280
          virt_offset = 4294967295U;
        } else {
#line 282
          virt_offset = cur_ancestor->parent_off;
        }
        {
#line 284
        tmp___0 = talloc_named_const((void const   *)path_stack, sizeof(REGFI_BUFFER ),
                                     "REGFI_BUFFER");
#line 284
        path_element = (REGFI_BUFFER *)tmp___0;
        }
#line 285
        if ((unsigned long )path_element != (unsigned long )((void *)0)) {
          {
#line 288
          regfi_interpret_keyname(f___0, cur_ancestor, (REGFI_ENCODING )0, (_Bool)1);
#line 290
          tmp___1 = get_quoted_keyname___0((REGFI_NK_REC const   *)cur_ancestor);
#line 290
          path_element->buf = (uint8_t *)tmp___1;
          }
        }
#line 293
        if ((unsigned long )path_element == (unsigned long )((void *)0)) {
          {
#line 297
          regfi_free_key(cur_ancestor);
#line 298
          void_stack_free(path_stack);
          }
#line 299
          return ((char *)((void *)0));
        } else
#line 293
        if ((unsigned long )path_element->buf == (unsigned long )((void *)0)) {
          {
#line 297
          regfi_free_key(cur_ancestor);
#line 298
          void_stack_free(path_stack);
          }
#line 299
          return ((char *)((void *)0));
        } else {
          {
#line 293
          tmp___2 = void_stack_push(path_stack, (void *)path_element);
          }
#line 293
          if (! tmp___2) {
            {
#line 297
            regfi_free_key(cur_ancestor);
#line 298
            void_stack_free(path_stack);
            }
#line 299
            return ((char *)((void *)0));
          }
        }
        {
#line 306
        tmp___3 = strlen((char const   *)((char *)path_element->buf));
#line 306
        path_element->len = (uint32_t )tmp___3;
#line 307
        ret_val_size += path_element->len + 1U;
#line 309
        regfi_free_key(cur_ancestor);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 314
  tmp___4 = void_stack_size((void_stack const   *)path_stack);
#line 314
  stack_size = (uint32_t )tmp___4;
#line 315
  ret_val_used = (uint32_t )0;
#line 316
  tmp___5 = malloc((size_t )ret_val_size);
#line 316
  ret_val = (char *)tmp___5;
  }
#line 317
  if ((unsigned long )ret_val == (unsigned long )((void *)0)) {
    {
#line 319
    void_stack_free(path_stack);
    }
#line 320
    return ((char *)((void *)0));
  }
#line 322
  *(ret_val + 0) = (char )'\000';
#line 324
  i = (uint32_t )0;
  {
#line 324
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 324
    if (! (i < stack_size)) {
#line 324
      goto while_break___0;
    }
    {
#line 326
    tmp___6 = void_stack_pop(path_stack);
#line 326
    path_element = (REGFI_BUFFER *)tmp___6;
#line 327
    snprintf((char */* __restrict  */)(ret_val + ret_val_used), (size_t )(ret_val_size - ret_val_used),
             (char const   */* __restrict  */)"/%s", path_element->buf);
#line 329
    ret_val_used += path_element->len + 1U;
#line 330
    free((void *)path_element->buf);
#line 331
    talloc_free((void *)path_element);
#line 324
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 333
  void_stack_free(path_stack);
  }
#line 335
  return (ret_val);
}
}
#line 339 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/src/reglookup-recover.c"
static void usage___0(void) 
{ 


  {
  {
#line 341
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: reglookup-recover [options] <REGISTRY_FILE>\n");
#line 342
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Version: %s\n",
          "0.12.0");
#line 343
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Options:\n");
#line 344
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t-v\t sets verbose mode.\n");
#line 345
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t-h\t enables header row. (default)\n");
#line 346
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t-H\t disables header row.\n");
#line 347
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t-l\t enables leftover(raw) cell output.\n");
#line 348
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t-L\t disables leftover(raw) cell output. (default)\n");
#line 349
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t-r\t enables raw cell output for parsed cells.\n");
#line 350
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t-R\t disables raw cell output for parsed cells. (default)\n");
#line 351
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
  }
#line 352
  return;
}
}
#line 355 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/src/reglookup-recover.c"
_Bool removeRange(range_list *rl , uint32_t offset , uint32_t length ) 
{ 
  int32_t rm_idx ;
  range_list_element const   *cur_elem ;
  _Bool tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;

  {
  {
#line 360
  rm_idx = range_list_find((range_list const   *)rl, offset);
  }
#line 361
  if (rm_idx < 0) {
    {
#line 363
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"DEBUG: removeRange: rm_idx < 0; (%d)\n",
            rm_idx);
    }
#line 364
    return ((_Bool)0);
  }
  {
#line 367
  cur_elem = range_list_get((range_list const   *)rl, (uint32_t )rm_idx);
  }
#line 368
  if ((unsigned long )cur_elem == (unsigned long )((void *)0)) {
    {
#line 370
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"DEBUG: removeRange: cur_elem == NULL.  rm_idx=%d\n",
            rm_idx);
    }
#line 371
    return ((_Bool)0);
  }
#line 374
  if (offset > (uint32_t )cur_elem->offset) {
    {
#line 376
    tmp = range_list_split_element(rl, (uint32_t )rm_idx, offset);
    }
#line 376
    if (! tmp) {
      {
#line 378
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"DEBUG: removeRange: first split failed\n");
      }
#line 379
      return ((_Bool)0);
    }
    {
#line 381
    rm_idx ++;
#line 382
    cur_elem = range_list_get((range_list const   *)rl, (uint32_t )rm_idx);
    }
#line 383
    if ((unsigned long )cur_elem == (unsigned long )((void *)0)) {
      {
#line 385
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"DEBUG: removeRange: cur_elem == NULL after first split.  rm_idx=%d\n",
              rm_idx);
      }
#line 388
      return ((_Bool)0);
    }
  }
#line 392
  if (offset + length < (uint32_t )(cur_elem->offset + cur_elem->length)) {
    {
#line 394
    tmp___0 = range_list_split_element(rl, (uint32_t )rm_idx, offset + length);
    }
#line 394
    if (! tmp___0) {
      {
#line 396
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"DEBUG: removeRange: second split failed\n");
      }
#line 397
      return ((_Bool)0);
    }
  }
  {
#line 401
  tmp___1 = range_list_remove(rl, (uint32_t )rm_idx);
  }
#line 401
  if (! tmp___1) {
    {
#line 403
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"DEBUG: removeRange: remove failed\n");
    }
#line 404
    return ((_Bool)0);
  }
#line 407
  return ((_Bool)1);
}
}
#line 411 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/src/reglookup-recover.c"
int extractVKs(REGFI_FILE *f___0 , range_list *unalloc_cells , range_list *unalloc_values ) 
{ 
  range_list_element const   *cur_elem ;
  REGFI_VK_REC *vk ;
  uint32_t i ;
  uint32_t j ;
  _Bool tmp ;
  uint32_t tmp___0 ;
  _Bool tmp___1 ;
  uint32_t tmp___2 ;

  {
#line 419
  i = (uint32_t )0;
  {
#line 419
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 419
    tmp___0 = range_list_size((range_list const   *)unalloc_cells);
    }
#line 419
    if (! (i < tmp___0)) {
#line 419
      goto while_break;
    }
    {
#line 421
    printMsgs(f___0);
#line 422
    cur_elem = range_list_get((range_list const   *)unalloc_cells, i);
#line 423
    j = (uint32_t )0;
    }
    {
#line 423
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 423
      if (! (j <= (uint32_t )cur_elem->length)) {
#line 423
        goto while_break___0;
      }
      {
#line 425
      vk = regfi_parse_vk(f___0, (uint32_t )(cur_elem->offset + (uint32_t const   )j),
                          (uint32_t )(cur_elem->length - (uint32_t const   )j), (_Bool)0);
#line 427
      printMsgs(f___0);
      }
#line 429
      if ((unsigned long )vk != (unsigned long )((void *)0)) {
        {
#line 431
        tmp = range_list_add(unalloc_values, vk->offset, vk->cell_size, (void *)vk);
        }
#line 431
        if (! tmp) {
          {
#line 434
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR: Couldn\'t add value to unalloc_values.\n");
          }
#line 435
          return (20);
        }
#line 437
        j += vk->cell_size - 8U;
      }
#line 423
      j += 8U;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 419
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 443
  i = (uint32_t )0;
  {
#line 443
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 443
    tmp___2 = range_list_size((range_list const   *)unalloc_values);
    }
#line 443
    if (! (i < tmp___2)) {
#line 443
      goto while_break___1;
    }
    {
#line 445
    cur_elem = range_list_get((range_list const   *)unalloc_values, i);
#line 446
    tmp___1 = removeRange(unalloc_cells, (uint32_t )cur_elem->offset, (uint32_t )cur_elem->length);
    }
#line 446
    if (! tmp___1) {
#line 447
      return (30);
    }
#line 443
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 450
  return (0);
}
}
#line 454 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/src/reglookup-recover.c"
int extractDataCells(REGFI_FILE *file , range_list *unalloc_cells , range_list *unalloc_values ) 
{ 
  range_list_element const   *cur_elem ;
  REGFI_VK_REC *vk ;
  range_list *bd_cells ;
  REGFI_BUFFER data ;
  uint32_t i ;
  uint32_t j ;
  uint32_t offset ;
  uint32_t cell_length ;
  uint32_t length ;
  int32_t max_size ;
  _Bool unalloc ;
  _Bool tmp ;
  uint32_t tmp___0 ;
  _Bool tmp___1 ;
  uint32_t tmp___2 ;
  _Bool tmp___3 ;
  _Bool tmp___4 ;
  _Bool tmp___5 ;
  uint32_t tmp___6 ;

  {
  {
#line 466
  bd_cells = range_list_new();
  }
#line 467
  if ((unsigned long )bd_cells == (unsigned long )((void *)0)) {
#line 468
    return (10);
  }
#line 470
  data.buf = (uint8_t *)((void *)0);
#line 471
  data.len = (uint32_t )0;
#line 472
  i = (uint32_t )0;
  {
#line 472
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 472
    tmp___6 = range_list_size((range_list const   *)unalloc_values);
    }
#line 472
    if (! (i < tmp___6)) {
#line 472
      goto while_break;
    }
    {
#line 474
    cur_elem = range_list_get((range_list const   *)unalloc_values, i);
#line 475
    vk = (REGFI_VK_REC *)cur_elem->data;
    }
#line 476
    if ((unsigned long )vk == (unsigned long )((void *)0)) {
#line 477
      return (11);
    }
#line 479
    length = vk->data_size;
#line 480
    vk->data = (REGFI_DATA *)((void *)0);
#line 481
    if (vk->data_size != 0U) {
#line 483
      offset = vk->data_off + 4096U;
#line 485
      if (vk->data_in_offset) {
        {
#line 486
        data = regfi_parse_little_data(file, vk->data_off, length, (_Bool)0);
        }
      } else {
        {
#line 490
        max_size = regfi_calc_maxsize(file, offset);
        }
#line 491
        if (max_size >= 0) {
          {
#line 491
          tmp___5 = regfi_parse_cell(file->fd, offset, (uint8_t *)((void *)0), (uint32_t )0,
                                     & cell_length, & unalloc);
          }
#line 491
          if (tmp___5) {
#line 491
            if ((cell_length & 7U) == 0U) {
#line 491
              if (cell_length <= (uint32_t )max_size) {
#line 497
                if (cell_length - 4U < length) {
#line 505
                  if (file->major_version >= 1U) {
#line 505
                    if (file->minor_version >= 5U) {
                      {
#line 508
                      data = regfi_load_big_data(file, offset, length, cell_length,
                                                 bd_cells, (_Bool)0);
                      }
#line 512
                      if ((unsigned long )data.buf != (unsigned long )((void *)0)) {
#line 514
                        j = (uint32_t )0;
                        {
#line 514
                        while (1) {
                          while_continue___0: /* CIL Label */ ;
                          {
#line 514
                          tmp___0 = range_list_size((range_list const   *)bd_cells);
                          }
#line 514
                          if (! (j < tmp___0)) {
#line 514
                            goto while_break___0;
                          }
                          {
#line 516
                          cur_elem = range_list_get((range_list const   *)bd_cells,
                                                    j);
                          }
#line 517
                          if ((unsigned long )cur_elem == (unsigned long )((void *)0)) {
#line 518
                            return (20);
                          }
                          {
#line 519
                          tmp = range_list_has_range(unalloc_cells, (uint32_t )cur_elem->offset,
                                                     (uint32_t )cur_elem->length);
                          }
#line 519
                          if (! tmp) {
                            {
#line 523
                            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"WARN: Successfully parsed big data at offset 0x%.8X was rejected because some substructure (offset=0x%.8X) is allocated or used in other recovered structures.\n",
                                    offset, cur_elem->offset);
#line 529
                            talloc_free((void *)data.buf);
#line 530
                            data.buf = (uint8_t *)((void *)0);
#line 531
                            data.len = (uint32_t )0;
                            }
#line 532
                            goto while_break___0;
                          }
#line 514
                          j ++;
                        }
                        while_break___0: /* CIL Label */ ;
                        }
#line 536
                        if ((unsigned long )data.buf != (unsigned long )((void *)0)) {
#line 538
                          j = (uint32_t )0;
                          {
#line 538
                          while (1) {
                            while_continue___1: /* CIL Label */ ;
                            {
#line 538
                            tmp___2 = range_list_size((range_list const   *)bd_cells);
                            }
#line 538
                            if (! (j < tmp___2)) {
#line 538
                              goto while_break___1;
                            }
                            {
#line 540
                            cur_elem = range_list_get((range_list const   *)bd_cells,
                                                      j);
                            }
#line 541
                            if ((unsigned long )cur_elem == (unsigned long )((void *)0)) {
#line 542
                              return (21);
                            }
                            {
#line 544
                            tmp___1 = removeRange(unalloc_cells, (uint32_t )cur_elem->offset,
                                                  (uint32_t )cur_elem->length);
                            }
#line 544
                            if (! tmp___1) {
#line 547
                              return (22);
                            }
#line 538
                            j ++;
                          }
                          while_break___1: /* CIL Label */ ;
                          }
                        }
                      }
                    } else {
                      {
#line 555
                      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"WARN: Data length (0x%.8X) larger than remaining cell length (0x%.8X) while parsing data record at offset 0x%.8X. Truncating...\n",
                              length, cell_length - 4U, offset);
#line 561
                      length = cell_length - 4U;
                      }
                    }
                  } else {
                    {
#line 555
                    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"WARN: Data length (0x%.8X) larger than remaining cell length (0x%.8X) while parsing data record at offset 0x%.8X. Truncating...\n",
                            length, cell_length - 4U, offset);
#line 561
                    length = cell_length - 4U;
                    }
                  }
                }
                {
#line 566
                tmp___4 = range_list_has_range(unalloc_cells, offset, length);
                }
#line 566
                if (tmp___4) {
                  {
#line 568
                  data = regfi_parse_data(file, offset, length, (_Bool)0);
                  }
#line 569
                  if ((unsigned long )data.buf != (unsigned long )((void *)0)) {
                    {
#line 570
                    tmp___3 = removeRange(unalloc_cells, offset, length);
                    }
#line 570
                    if (! tmp___3) {
#line 571
                      return (30);
                    }
                  }
                }
              }
            }
          }
        }
      }
      {
#line 578
      vk->data = regfi_buffer_to_data(data);
#line 579
      _talloc_steal((void const   *)vk, (void const   *)vk->data);
      }
    }
#line 472
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 583
  range_list_free(bd_cells);
  }
#line 584
  return (0);
}
}
#line 589 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/src/reglookup-recover.c"
int extractKeys(REGFI_FILE *f___0 , range_list *unalloc_cells , range_list *unalloc_keys ) 
{ 
  range_list_element const   *cur_elem ;
  REGFI_NK_REC *key ;
  uint32_t i ;
  uint32_t j ;
  int error_code ;
  _Bool tmp ;
  uint32_t tmp___0 ;
  _Bool tmp___1 ;
  uint32_t tmp___2 ;

  {
#line 596
  error_code = 0;
#line 598
  i = (uint32_t )0;
  {
#line 598
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 598
    tmp___0 = range_list_size((range_list const   *)unalloc_cells);
    }
#line 598
    if (! (i < tmp___0)) {
#line 598
      goto while_break;
    }
    {
#line 600
    printMsgs(f___0);
#line 601
    cur_elem = range_list_get((range_list const   *)unalloc_cells, i);
#line 602
    j = (uint32_t )0;
    }
    {
#line 602
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 602
      if (cur_elem->length > 76U) {
#line 602
        if (! (j <= (uint32_t )(cur_elem->length - 76U))) {
#line 602
          goto while_break___0;
        }
      } else {
#line 602
        goto while_break___0;
      }
      {
#line 605
      key = regfi_parse_nk(f___0, (uint32_t )(cur_elem->offset + (uint32_t const   )j),
                           (uint32_t )(cur_elem->length - (uint32_t const   )j), (_Bool)0);
#line 607
      printMsgs(f___0);
      }
#line 609
      if ((unsigned long )key != (unsigned long )((void *)0)) {
        {
#line 611
        tmp = range_list_add(unalloc_keys, key->offset, key->cell_size, (void *)key);
        }
#line 611
        if (! tmp) {
          {
#line 614
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR: Couldn\'t add key to unalloc_keys.\n");
#line 615
          error_code = 20;
          }
#line 616
          goto fail;
        }
        {
#line 618
        _talloc_steal((void const   *)unalloc_keys, (void const   *)key);
#line 619
        j += key->cell_size - 8U;
        }
      }
#line 602
      j += 8U;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 598
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 624
  i = (uint32_t )0;
  {
#line 624
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 624
    tmp___2 = range_list_size((range_list const   *)unalloc_keys);
    }
#line 624
    if (! (i < tmp___2)) {
#line 624
      goto while_break___1;
    }
    {
#line 626
    cur_elem = range_list_get((range_list const   *)unalloc_keys, i);
#line 627
    tmp___1 = removeRange(unalloc_cells, (uint32_t )cur_elem->offset, (uint32_t )cur_elem->length);
    }
#line 627
    if (! tmp___1) {
#line 629
      error_code = 30;
#line 630
      goto fail;
    }
#line 624
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 634
  return (0);
  fail: 
  {
#line 637
  regfi_free_key(key);
  }
#line 638
  return (error_code);
}
}
#line 641 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/src/reglookup-recover.c"
int extractValueLists(REGFI_FILE *f___0 , range_list *unalloc_cells , range_list *unalloc_keys ,
                      range_list *unalloc_linked_values ) 
{ 
  REGFI_NK_REC *nk ;
  REGFI_VK_REC *vk ;
  range_list_element const   *cur_elem ;
  uint32_t i ;
  uint32_t j ;
  uint32_t num_keys ;
  uint32_t off ;
  uint32_t values_length ;
  int32_t max_size ;
  _Bool tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;

  {
  {
#line 652
  num_keys = range_list_size((range_list const   *)unalloc_keys);
#line 653
  i = (uint32_t )0;
  }
  {
#line 653
  while (1) {
    while_continue: /* CIL Label */ ;
#line 653
    if (! (i < num_keys)) {
#line 653
      goto while_break;
    }
    {
#line 655
    cur_elem = range_list_get((range_list const   *)unalloc_keys, i);
    }
#line 656
    if ((unsigned long )cur_elem == (unsigned long )((void *)0)) {
#line 657
      return (10);
    }
#line 658
    nk = (REGFI_NK_REC *)cur_elem->data;
#line 660
    if (nk->num_values) {
#line 660
      if (nk->values_off != 4294967295U) {
        {
#line 662
        off = nk->values_off + 4096U;
#line 663
        max_size = regfi_calc_maxsize(f___0, off);
        }
#line 664
        if (max_size >= 0) {
          {
#line 666
          nk->values = regfi_load_valuelist(f___0, off, nk->num_values, (uint32_t )max_size,
                                            (_Bool)0);
          }
#line 668
          if ((unsigned long )nk->values != (unsigned long )((void *)0)) {
#line 668
            if ((unsigned long )(nk->values)->elements != (unsigned long )((void *)0)) {
#line 675
              values_length = (uint32_t )((unsigned long )((nk->values)->num_values + 1U) * sizeof(uint32_t ));
#line 676
              if (values_length != (values_length & 4294967288U)) {
#line 677
                values_length = (values_length & 4294967288U) + 8U;
              }
              {
#line 679
              tmp___3 = range_list_has_range(unalloc_cells, off, values_length);
              }
#line 679
              if (tmp___3) {
                {
#line 690
                tmp = removeRange(unalloc_cells, off, values_length);
                }
#line 690
                if (! tmp) {
#line 691
                  return (20);
                }
#line 693
                j = (uint32_t )0;
                {
#line 693
                while (1) {
                  while_continue___0: /* CIL Label */ ;
#line 693
                  if (! (j < (nk->values)->num_values)) {
#line 693
                    goto while_break___0;
                  }
                  {
#line 698
                  vk = regfi_parse_vk(f___0, *((nk->values)->elements + j) + 4096U,
                                      (uint32_t )2147483647, (_Bool)0);
#line 700
                  printMsgs(f___0);
                  }
#line 702
                  if ((unsigned long )vk != (unsigned long )((void *)0)) {
                    {
#line 704
                    tmp___2 = range_list_has_range(unalloc_cells, vk->offset, vk->cell_size);
                    }
#line 704
                    if (tmp___2) {
                      {
#line 707
                      tmp___0 = range_list_add(unalloc_linked_values, vk->offset,
                                               vk->cell_size, (void *)vk);
                      }
#line 707
                      if (! tmp___0) {
                        {
#line 710
                        talloc_free((void *)vk);
                        }
#line 711
                        return (30);
                      }
                      {
#line 714
                      tmp___1 = removeRange(unalloc_cells, vk->offset, vk->cell_size);
                      }
#line 714
                      if (! tmp___1) {
#line 715
                        return (40);
                      }
                    } else {
                      {
#line 718
                      talloc_free((void *)vk);
                      }
                    }
                  }
#line 693
                  j ++;
                }
                while_break___0: /* CIL Label */ ;
                }
              } else {
                {
#line 683
                talloc_free((void *)nk->values);
#line 684
                nk->values = (REGFI_VALUE_LIST *)((void *)0);
                }
              }
            }
          }
        }
      }
    }
#line 653
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 727
  return (0);
}
}
#line 733 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/src/reglookup-recover.c"
int extractSKs(REGFI_FILE *f___0 , range_list *unalloc_cells , range_list *unalloc_sks ) 
{ 
  range_list_element const   *cur_elem ;
  REGFI_SK_REC *sk ;
  uint32_t i ;
  uint32_t j ;
  _Bool tmp ;
  uint32_t tmp___0 ;
  _Bool tmp___1 ;
  uint32_t tmp___2 ;

  {
#line 741
  i = (uint32_t )0;
  {
#line 741
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 741
    tmp___0 = range_list_size((range_list const   *)unalloc_cells);
    }
#line 741
    if (! (i < tmp___0)) {
#line 741
      goto while_break;
    }
    {
#line 743
    printMsgs(f___0);
#line 744
    cur_elem = range_list_get((range_list const   *)unalloc_cells, i);
#line 745
    j = (uint32_t )0;
    }
    {
#line 745
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 745
      if (! (j <= (uint32_t )cur_elem->length)) {
#line 745
        goto while_break___0;
      }
      {
#line 747
      sk = regfi_parse_sk(f___0, (uint32_t )(cur_elem->offset + (uint32_t const   )j),
                          (uint32_t )(cur_elem->length - (uint32_t const   )j), (_Bool)0);
#line 749
      printMsgs(f___0);
      }
#line 751
      if ((unsigned long )sk != (unsigned long )((void *)0)) {
        {
#line 753
        tmp = range_list_add(unalloc_sks, sk->offset, sk->cell_size, (void *)sk);
        }
#line 753
        if (! tmp) {
          {
#line 756
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR: Couldn\'t add sk to unalloc_sks.\n");
          }
#line 757
          return (20);
        }
        {
#line 759
        _talloc_steal((void const   *)unalloc_sks, (void const   *)sk);
#line 760
        j += sk->cell_size - 8U;
        }
      }
#line 745
      j += 8U;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 741
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 765
  i = (uint32_t )0;
  {
#line 765
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 765
    tmp___2 = range_list_size((range_list const   *)unalloc_sks);
    }
#line 765
    if (! (i < tmp___2)) {
#line 765
      goto while_break___1;
    }
    {
#line 767
    cur_elem = range_list_get((range_list const   *)unalloc_sks, i);
#line 768
    tmp___1 = removeRange(unalloc_cells, (uint32_t )cur_elem->offset, (uint32_t )cur_elem->length);
    }
#line 768
    if (! tmp___1) {
#line 769
      return (30);
    }
#line 765
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 772
  return (0);
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/range_list.c"
static _Bool range_list_insert___0(range_list *rl , range_list_element *elem , uint32_t index___0 ) 
{ 
  uint32_t i ;
  range_list_element **tmp ;
  void *tmp___0 ;

  {
#line 56
  if (rl->size == rl->elem_alloced) {
    {
#line 58
    tmp___0 = _talloc_realloc_array((void const   *)rl, (void *)rl->elements, sizeof(range_list_element *),
                                    rl->elem_alloced + 256U, "range_list_element*");
#line 58
    tmp = (range_list_element **)tmp___0;
    }
#line 60
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 61
      return ((_Bool)0);
    }
#line 62
    rl->elements = tmp;
#line 63
    rl->elem_alloced += 256U;
  }
#line 67
  i = rl->size;
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
#line 67
    if (! (i > index___0)) {
#line 67
      goto while_break;
    }
#line 68
    *(rl->elements + i) = *(rl->elements + (i - 1U));
#line 67
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 69
  *(rl->elements + index___0) = elem;
#line 71
  (rl->size) ++;
#line 72
  return ((_Bool)1);
}
}
#line 81 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/range_list.c"
static int32_t range_list_find_previous___0(range_list const   *rl , uint32_t offset ) 
{ 
  uint32_t h_idx ;
  uint32_t l_idx ;
  uint32_t cur_idx ;
  uint32_t h_val ;
  uint32_t l_val ;
  range_list_element *cur_elem ;
  double tmp ;

  {
#line 87
  if (rl->size == 0U) {
#line 88
    return (-1);
  } else
#line 87
  if (offset < (*(rl->elements + 0))->offset) {
#line 88
    return (-1);
  }
#line 90
  if (offset >= (*(rl->elements + (rl->size - 1U)))->offset) {
#line 91
    return ((int32_t )(rl->size - 1U));
  }
#line 93
  h_idx = (uint32_t )(rl->size - 1U);
#line 94
  l_idx = (uint32_t )0;
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;
#line 95
    if (! (h_idx != l_idx)) {
#line 95
      goto while_break;
    }
    {
#line 97
    h_val = (*(rl->elements + h_idx))->offset + (*(rl->elements + h_idx))->length;
#line 98
    l_val = (*(rl->elements + l_idx))->offset;
#line 102
    tmp = ceil((((double )offset - (double )l_val) / (double )(h_val - l_val)) * (double )(h_idx - l_idx));
#line 102
    cur_idx = (uint32_t )tmp;
    }
#line 103
    if (cur_idx > h_idx) {
#line 104
      cur_idx = h_idx;
    }
#line 105
    if (cur_idx < l_idx) {
#line 106
      cur_idx = l_idx;
    }
#line 107
    cur_elem = *(rl->elements + cur_idx);
#line 109
    if (offset >= cur_elem->offset) {
#line 109
      if (offset < (*(rl->elements + (cur_idx + 1U)))->offset) {
#line 110
        return ((int32_t )cur_idx);
      }
    }
#line 112
    if (offset < cur_elem->offset) {
#line 113
      h_idx = cur_idx - 1U;
    } else {
#line 115
      l_idx = cur_idx + 1U;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 118
  return ((int32_t )h_idx);
}
}
#line 75 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
static void *null_context___0  ;
#line 76 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
static void *autofree_context___0  ;
#line 112 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
static void talloc_abort_double_free___0(void) 
{ 


  {
  {
#line 114
  abort();
  }
}
}
#line 117 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
static void talloc_abort_unknown_value___0(void) 
{ 


  {
  {
#line 119
  abort();
  }
}
}
#line 123 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
__inline static struct talloc_chunk *talloc_chunk_from_ptr___0(void const   *ptr ) 
{ 
  char const   *pp ;
  struct talloc_chunk *tc ;
  long tmp ;

  {
  {
#line 125
  pp = (char const   *)ptr;
#line 126
  tc = (struct talloc_chunk *)(pp - ((sizeof(struct talloc_chunk ) + 15UL) & 0xfffffffffffffff0UL));
#line 127
  tmp = __builtin_expect((long )(! (! ((tc->flags & 4294967281U) != 3893685360U))),
                         0L);
  }
#line 127
  if (tmp) {
#line 128
    if (tc->flags & 1U) {
      {
#line 129
      talloc_abort_double_free___0();
      }
    } else {
      {
#line 131
      talloc_abort_unknown_value___0();
      }
    }
  }
#line 134
  return (tc);
}
}
#line 168 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
__inline static struct talloc_chunk *talloc_parent_chunk___0(void const   *ptr ) 
{ 
  struct talloc_chunk *tc ;
  long tmp ;

  {
  {
#line 172
  tmp = __builtin_expect((long )(! (! ((unsigned long )ptr == (unsigned long )((void *)0)))),
                         0L);
  }
#line 172
  if (tmp) {
#line 173
    return ((struct talloc_chunk *)((void *)0));
  }
  {
#line 176
  tc = talloc_chunk_from_ptr___0(ptr);
  }
  {
#line 177
  while (1) {
    while_continue: /* CIL Label */ ;
#line 177
    if (! tc->prev) {
#line 177
      goto while_break;
    }
#line 177
    tc = tc->prev;
  }
  while_break: /* CIL Label */ ;
  }
#line 179
  return (tc->parent);
}
}
#line 212 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
static unsigned int *talloc_pool_objectcount___0(struct talloc_chunk *tc ) 
{ 


  {
#line 214
  return ((unsigned int *)((char *)tc + sizeof(struct talloc_chunk )));
}
}
#line 221 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
static struct talloc_chunk *talloc_alloc_pool___0(struct talloc_chunk *parent , size_t size ) 
{ 
  struct talloc_chunk *pool_ctx ;
  size_t space_left ;
  struct talloc_chunk *result ;
  size_t chunk_size ;
  unsigned int *tmp ;

  {
#line 224
  pool_ctx = (struct talloc_chunk *)((void *)0);
#line 229
  if ((unsigned long )parent == (unsigned long )((void *)0)) {
#line 230
    return ((struct talloc_chunk *)((void *)0));
  }
#line 233
  if (parent->flags & 4U) {
#line 234
    pool_ctx = parent;
  } else
#line 236
  if (parent->flags & 8U) {
#line 237
    pool_ctx = (struct talloc_chunk *)parent->pool;
  }
#line 240
  if ((unsigned long )pool_ctx == (unsigned long )((void *)0)) {
#line 241
    return ((struct talloc_chunk *)((void *)0));
  }
#line 244
  space_left = (size_t )((((char *)pool_ctx + ((sizeof(struct talloc_chunk ) + 15UL) & 0xfffffffffffffff0UL)) + pool_ctx->size) - (char *)pool_ctx->pool);
#line 250
  chunk_size = (size + 15UL) & 0xfffffffffffffff0UL;
#line 252
  if (space_left < chunk_size) {
#line 253
    return ((struct talloc_chunk *)((void *)0));
  }
  {
#line 256
  result = (struct talloc_chunk *)pool_ctx->pool;
#line 262
  pool_ctx->pool = (void *)((char *)result + chunk_size);
#line 264
  result->flags = 3893685368U;
#line 265
  result->pool = (void *)pool_ctx;
#line 267
  tmp = talloc_pool_objectcount___0(pool_ctx);
#line 267
  (*tmp) ++;
  }
#line 269
  return (result);
}
}
#line 275 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
__inline static void *__talloc___0(void const   *context , size_t size ) 
{ 
  struct talloc_chunk *tc ;
  long tmp ;
  long tmp___0 ;
  struct talloc_chunk *tmp___1 ;
  void *tmp___2 ;
  long tmp___3 ;
  struct talloc_chunk *parent ;
  struct talloc_chunk *tmp___4 ;
  struct talloc_chunk *tmp___5 ;
  struct talloc_chunk *tmp___6 ;
  long tmp___7 ;

  {
  {
#line 277
  tc = (struct talloc_chunk *)((void *)0);
#line 279
  tmp = __builtin_expect((long )(! (! ((unsigned long )context == (unsigned long )((void *)0)))),
                         0L);
  }
#line 279
  if (tmp) {
#line 280
    context = (void const   *)null_context___0;
  }
  {
#line 283
  tmp___0 = __builtin_expect((long )(! (! (size >= 268435456UL))), 0L);
  }
#line 283
  if (tmp___0) {
#line 284
    return ((void *)0);
  }
#line 287
  if ((unsigned long )context != (unsigned long )((void *)0)) {
    {
#line 288
    tmp___1 = talloc_chunk_from_ptr___0(context);
#line 288
    tc = talloc_alloc_pool___0(tmp___1, ((sizeof(struct talloc_chunk ) + 15UL) & 0xfffffffffffffff0UL) + size);
    }
  }
#line 292
  if ((unsigned long )tc == (unsigned long )((void *)0)) {
    {
#line 293
    tmp___2 = malloc(((sizeof(struct talloc_chunk ) + 15UL) & 0xfffffffffffffff0UL) + size);
#line 293
    tc = (struct talloc_chunk *)tmp___2;
#line 294
    tmp___3 = __builtin_expect((long )(! (! ((unsigned long )tc == (unsigned long )((void *)0)))),
                               0L);
    }
#line 294
    if (tmp___3) {
#line 294
      return ((void *)0);
    }
#line 295
    tc->flags = 3893685360U;
#line 296
    tc->pool = (void *)0;
  }
  {
#line 299
  tc->size = size;
#line 300
  tc->destructor = (int (*)(void * ))((void *)0);
#line 301
  tc->child = (struct talloc_chunk *)((void *)0);
#line 302
  tc->name = (char const   *)((void *)0);
#line 303
  tc->refs = (struct talloc_reference_handle *)((void *)0);
#line 305
  tmp___7 = __builtin_expect((long )(! (! context)), 1L);
  }
#line 305
  if (tmp___7) {
    {
#line 306
    tmp___4 = talloc_chunk_from_ptr___0(context);
#line 306
    parent = tmp___4;
    }
#line 308
    if (parent->child) {
#line 309
      (parent->child)->parent = (struct talloc_chunk *)((void *)0);
#line 310
      tc->next = parent->child;
#line 311
      (tc->next)->prev = tc;
    } else {
#line 313
      tc->next = (struct talloc_chunk *)((void *)0);
    }
#line 315
    tc->parent = parent;
#line 316
    tc->prev = (struct talloc_chunk *)((void *)0);
#line 317
    parent->child = tc;
  } else {
#line 319
    tmp___6 = (struct talloc_chunk *)((void *)0);
#line 319
    tc->parent = tmp___6;
#line 319
    tmp___5 = tmp___6;
#line 319
    tc->prev = tmp___5;
#line 319
    tc->next = tmp___5;
  }
#line 322
  return ((void *)((char *)tc + ((sizeof(struct talloc_chunk ) + 15UL) & 0xfffffffffffffff0UL)));
}
}
#line 380 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
static int talloc_reference_destructor___0(struct talloc_reference_handle *handle ) 
{ 
  struct talloc_chunk *ptr_tc ;
  struct talloc_chunk *tmp ;
  struct talloc_reference_handle *tmp___0 ;

  {
  {
#line 382
  tmp = talloc_chunk_from_ptr___0((void const   *)handle->ptr);
#line 382
  ptr_tc = tmp;
  }
  {
#line 383
  while (1) {
    while_continue: /* CIL Label */ ;
#line 383
    if ((unsigned long )handle == (unsigned long )ptr_tc->refs) {
#line 383
      ptr_tc->refs = handle->next;
#line 383
      if (ptr_tc->refs) {
#line 383
        (ptr_tc->refs)->prev = (struct talloc_reference_handle *)((void *)0);
      }
    } else {
#line 383
      if (handle->prev) {
#line 383
        (handle->prev)->next = handle->next;
      }
#line 383
      if (handle->next) {
#line 383
        (handle->next)->prev = handle->prev;
      }
    }
#line 383
    if (handle) {
#line 383
      if ((unsigned long )handle != (unsigned long )ptr_tc->refs) {
#line 383
        tmp___0 = (struct talloc_reference_handle *)((void *)0);
#line 383
        handle->prev = tmp___0;
#line 383
        handle->next = tmp___0;
      }
    }
#line 383
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 384
  return (0);
}
}
#line 391 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
__inline static void _talloc_set_name_const___0(void const   *ptr , char const   *name ) 
{ 
  struct talloc_chunk *tc ;
  struct talloc_chunk *tmp ;

  {
  {
#line 393
  tmp = talloc_chunk_from_ptr___0(ptr);
#line 393
  tc = tmp;
#line 394
  tc->name = name;
  }
#line 395
  return;
}
}
#line 400 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
__inline static void *_talloc_named_const___0(void const   *context , size_t size ,
                                              char const   *name ) 
{ 
  void *ptr ;
  long tmp ;

  {
  {
#line 404
  ptr = __talloc___0(context, size);
#line 405
  tmp = __builtin_expect((long )(! (! ((unsigned long )ptr == (unsigned long )((void *)0)))),
                         0L);
  }
#line 405
  if (tmp) {
#line 406
    return ((void *)0);
  }
  {
#line 409
  _talloc_set_name_const___0((void const   *)ptr, name);
  }
#line 411
  return (ptr);
}
}
#line 448 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
__inline static int _talloc_free___0(void *ptr ) 
{ 
  struct talloc_chunk *tc ;
  long tmp ;
  int is_child ;
  int tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  int (*d)(void * ) ;
  int tmp___3 ;
  long tmp___4 ;
  struct talloc_chunk *tmp___5 ;
  void *child ;
  void const   *new_parent ;
  struct talloc_chunk *p ;
  struct talloc_chunk *tmp___6 ;
  long tmp___7 ;
  struct talloc_chunk *p___0 ;
  struct talloc_chunk *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  long tmp___11 ;
  struct talloc_chunk *pool ;
  unsigned int *pool_object_count ;

  {
  {
#line 452
  tmp = __builtin_expect((long )(! (! ((unsigned long )ptr == (unsigned long )((void *)0)))),
                         0L);
  }
#line 452
  if (tmp) {
#line 453
    return (-1);
  }
  {
#line 456
  tc = talloc_chunk_from_ptr___0((void const   *)ptr);
#line 458
  tmp___1 = __builtin_expect((long )(! (! tc->refs)), 0L);
  }
#line 458
  if (tmp___1) {
    {
#line 467
    is_child = talloc_is_parent((void const   *)tc->refs, (void const   *)ptr);
#line 468
    _talloc_free___0((void *)tc->refs);
    }
#line 469
    if (is_child) {
      {
#line 470
      tmp___0 = _talloc_free___0(ptr);
      }
#line 470
      return (tmp___0);
    }
#line 472
    return (-1);
  }
  {
#line 475
  tmp___2 = __builtin_expect((long )(! (! (tc->flags & 2U))), 0L);
  }
#line 475
  if (tmp___2) {
#line 477
    return (0);
  }
  {
#line 480
  tmp___4 = __builtin_expect((long )(! (! tc->destructor)), 0L);
  }
#line 480
  if (tmp___4) {
#line 481
    d = tc->destructor;
#line 482
    if ((unsigned long )d == (unsigned long )((int (*)(void * ))-1)) {
#line 483
      return (-1);
    }
    {
#line 485
    tc->destructor = (int (*)(void * ))-1;
#line 486
    tmp___3 = (*d)(ptr);
    }
#line 486
    if (tmp___3 == -1) {
#line 487
      tc->destructor = d;
#line 488
      return (-1);
    }
#line 490
    tc->destructor = (int (*)(void * ))((void *)0);
  }
#line 493
  if (tc->parent) {
    {
#line 494
    while (1) {
      while_continue: /* CIL Label */ ;
#line 494
      if ((unsigned long )tc == (unsigned long )(tc->parent)->child) {
#line 494
        (tc->parent)->child = tc->next;
#line 494
        if ((tc->parent)->child) {
#line 494
          ((tc->parent)->child)->prev = (struct talloc_chunk *)((void *)0);
        }
      } else {
#line 494
        if (tc->prev) {
#line 494
          (tc->prev)->next = tc->next;
        }
#line 494
        if (tc->next) {
#line 494
          (tc->next)->prev = tc->prev;
        }
      }
#line 494
      if (tc) {
#line 494
        if ((unsigned long )tc != (unsigned long )(tc->parent)->child) {
#line 494
          tmp___5 = (struct talloc_chunk *)((void *)0);
#line 494
          tc->prev = tmp___5;
#line 494
          tc->next = tmp___5;
        }
      }
#line 494
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 495
    if ((tc->parent)->child) {
#line 496
      ((tc->parent)->child)->parent = tc->parent;
    }
  } else {
#line 499
    if (tc->prev) {
#line 499
      (tc->prev)->next = tc->next;
    }
#line 500
    if (tc->next) {
#line 500
      (tc->next)->prev = tc->prev;
    }
  }
#line 503
  tc->flags |= 2U;
  {
#line 505
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 505
    if (! tc->child) {
#line 505
      goto while_break___0;
    }
    {
#line 511
    child = (void *)((char *)tc->child + ((sizeof(struct talloc_chunk ) + 15UL) & 0xfffffffffffffff0UL));
#line 512
    new_parent = (void const   *)null_context___0;
#line 513
    tmp___7 = __builtin_expect((long )(! (! (tc->child)->refs)), 0L);
    }
#line 513
    if (tmp___7) {
      {
#line 514
      tmp___6 = talloc_parent_chunk___0((void const   *)(tc->child)->refs);
#line 514
      p = tmp___6;
      }
#line 515
      if (p) {
#line 515
        new_parent = (void const   *)((void *)((char *)p + ((sizeof(struct talloc_chunk ) + 15UL) & 0xfffffffffffffff0UL)));
      }
    }
    {
#line 517
    tmp___9 = _talloc_free___0(child);
    }
#line 517
    if (tmp___9 == -1) {
#line 517
      tmp___10 = 1;
    } else {
#line 517
      tmp___10 = 0;
    }
    {
#line 517
    tmp___11 = __builtin_expect((long )tmp___10, 0L);
    }
#line 517
    if (tmp___11) {
#line 518
      if ((unsigned long )new_parent == (unsigned long )null_context___0) {
        {
#line 519
        tmp___8 = talloc_parent_chunk___0((void const   *)ptr);
#line 519
        p___0 = tmp___8;
        }
#line 520
        if (p___0) {
#line 520
          new_parent = (void const   *)((void *)((char *)p___0 + ((sizeof(struct talloc_chunk ) + 15UL) & 0xfffffffffffffff0UL)));
        }
      }
      {
#line 522
      _talloc_steal(new_parent, (void const   *)child);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 526
  tc->flags |= 1U;
#line 528
  if (tc->flags & 12U) {
#line 532
    if (tc->flags & 4U) {
#line 532
      pool = tc;
    } else {
#line 532
      pool = (struct talloc_chunk *)tc->pool;
    }
    {
#line 535
    pool_object_count = talloc_pool_objectcount___0(pool);
    }
#line 537
    if (*pool_object_count == 0U) {
      {
#line 538
      abort();
      }
    }
#line 541
    (*pool_object_count) --;
#line 543
    if (*pool_object_count == 0U) {
      {
#line 544
      free((void *)pool);
      }
    }
  } else {
    {
#line 548
    free((void *)tc);
    }
  }
#line 550
  return (0);
}
}
#line 617 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
__inline static int talloc_unreference___0(void const   *context , void const   *ptr ) 
{ 
  struct talloc_chunk *tc ;
  struct talloc_chunk *tmp ;
  struct talloc_reference_handle *h ;
  long tmp___0 ;
  struct talloc_chunk *p ;
  struct talloc_chunk *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 619
  tmp = talloc_chunk_from_ptr___0(ptr);
#line 619
  tc = tmp;
#line 622
  tmp___0 = __builtin_expect((long )(! (! ((unsigned long )context == (unsigned long )((void *)0)))),
                             0L);
  }
#line 622
  if (tmp___0) {
#line 623
    context = (void const   *)null_context___0;
  }
#line 626
  h = tc->refs;
  {
#line 626
  while (1) {
    while_continue: /* CIL Label */ ;
#line 626
    if (! h) {
#line 626
      goto while_break;
    }
    {
#line 627
    tmp___1 = talloc_parent_chunk___0((void const   *)h);
#line 627
    p = tmp___1;
    }
#line 628
    if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 629
      if ((unsigned long )context == (unsigned long )((void *)0)) {
#line 629
        goto while_break;
      }
    } else
#line 630
    if ((unsigned long )((void *)((char *)p + ((sizeof(struct talloc_chunk ) + 15UL) & 0xfffffffffffffff0UL))) == (unsigned long )context) {
#line 631
      goto while_break;
    }
#line 626
    h = h->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 634
  if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 635
    return (-1);
  }
  {
#line 638
  tmp___2 = _talloc_free___0((void *)h);
  }
#line 638
  return (tmp___2);
}
}
#line 697
__inline static char const   *( /* format attribute */  talloc_set_name_v___0)(void const   *ptr ,
                                                                               char const   *fmt ,
                                                                               va_list ap ) ;
#line 699 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
__inline static char const   *( /* format attribute */  talloc_set_name_v___0)(void const   *ptr ,
                                                                               char const   *fmt ,
                                                                               va_list ap ) 
{ 
  struct talloc_chunk *tc ;
  struct talloc_chunk *tmp ;
  char *tmp___0 ;
  long tmp___1 ;

  {
  {
#line 701
  tmp = talloc_chunk_from_ptr___0(ptr);
#line 701
  tc = tmp;
#line 702
  tmp___0 = talloc_vasprintf(ptr, fmt, ap);
#line 702
  tc->name = (char const   *)tmp___0;
#line 703
  tmp___1 = __builtin_expect((long )(! (! tc->name)), 1L);
  }
#line 703
  if (tmp___1) {
    {
#line 704
    _talloc_set_name_const___0((void const   *)tc->name, ".name");
    }
  }
#line 706
  return (tc->name);
}
}
#line 1121 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
static void talloc_report_depth_FILE_helper___0(void const   *ptr , int depth , int max_depth ,
                                                int is_ref , void *_f ) 
{ 
  char const   *name ;
  char const   *tmp ;
  FILE *f___0 ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char const   *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;

  {
  {
#line 1123
  tmp = talloc_get_name(ptr);
#line 1123
  name = tmp;
#line 1124
  f___0 = (FILE *)_f;
  }
#line 1126
  if (is_ref) {
    {
#line 1127
    fprintf((FILE */* __restrict  */)f___0, (char const   */* __restrict  */)"%*sreference to: %s\n",
            depth * 4, "", name);
    }
#line 1128
    return;
  }
#line 1131
  if (depth == 0) {
    {
#line 1132
    tmp___0 = talloc_total_blocks(ptr);
#line 1132
    tmp___1 = talloc_total_size(ptr);
    }
#line 1132
    if (max_depth < 0) {
#line 1132
      tmp___2 = "full ";
    } else {
#line 1132
      tmp___2 = "";
    }
    {
#line 1132
    fprintf((FILE */* __restrict  */)f___0, (char const   */* __restrict  */)"%stalloc report on \'%s\' (total %6lu bytes in %3lu blocks)\n",
            tmp___2, name, tmp___1, tmp___0);
    }
#line 1136
    return;
  }
  {
#line 1139
  tmp___3 = talloc_reference_count(ptr);
#line 1139
  tmp___4 = talloc_total_blocks(ptr);
#line 1139
  tmp___5 = talloc_total_size(ptr);
#line 1139
  fprintf((FILE */* __restrict  */)f___0, (char const   */* __restrict  */)"%*s%-30s contains %6lu bytes in %3lu blocks (ref %d) %p\n",
          depth * 4, "", name, tmp___5, tmp___4, (int )tmp___3, ptr);
  }
#line 1162
  return;
}
}
#line 1192 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
static void talloc_report_null___0(void) 
{ 
  size_t tmp ;

  {
  {
#line 1194
  tmp = talloc_total_size((void const   *)null_context___0);
  }
#line 1194
  if (tmp != 0UL) {
    {
#line 1195
    talloc_report((void const   *)null_context___0, stderr);
    }
  }
#line 1197
  return;
}
}
#line 1202 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
static void talloc_report_null_full___0(void) 
{ 
  size_t tmp ;

  {
  {
#line 1204
  tmp = talloc_total_size((void const   *)null_context___0);
  }
#line 1204
  if (tmp != 0UL) {
    {
#line 1205
    talloc_report_full((void const   *)null_context___0, stderr);
    }
  }
#line 1207
  return;
}
}
#line 1274 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
__inline static char *__talloc_strlendup___0(void const   *t , char const   *p , size_t len ) 
{ 
  char *ret ;
  void *tmp ;
  long tmp___0 ;

  {
  {
#line 1278
  tmp = __talloc___0(t, len + 1UL);
#line 1278
  ret = (char *)tmp;
#line 1279
  tmp___0 = __builtin_expect((long )(! (! (! ret))), 0L);
  }
#line 1279
  if (tmp___0) {
#line 1279
    return ((char *)((void *)0));
  }
  {
#line 1281
  memcpy((void */* __restrict  */)ret, (void const   */* __restrict  */)p, len);
#line 1282
  *(ret + len) = (char)0;
#line 1284
  _talloc_set_name_const___0((void const   *)ret, (char const   *)ret);
  }
#line 1285
  return (ret);
}
}
#line 1306 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
__inline static char *__talloc_strlendup_append___0(char *s , size_t slen , char const   *a ,
                                                    size_t alen ) 
{ 
  char *ret ;
  void *tmp ;
  long tmp___0 ;

  {
  {
#line 1311
  tmp = _talloc_realloc_array((void const   *)((void *)0), (void *)s, sizeof(char ),
                              (unsigned int )((slen + alen) + 1UL), "char");
#line 1311
  ret = (char *)tmp;
#line 1312
  tmp___0 = __builtin_expect((long )(! (! (! ret))), 0L);
  }
#line 1312
  if (tmp___0) {
#line 1312
    return ((char *)((void *)0));
  }
  {
#line 1315
  memcpy((void */* __restrict  */)(ret + slen), (void const   */* __restrict  */)a,
         alen);
#line 1316
  *(ret + (slen + alen)) = (char)0;
#line 1318
  _talloc_set_name_const___0((void const   *)ret, (char const   *)ret);
  }
#line 1319
  return (ret);
}
}
#line 1445
__inline static char *( /* format attribute */  __talloc_vaslenprintf_append___0)(char *s ,
                                                                                  size_t slen ,
                                                                                  char const   *fmt ,
                                                                                  va_list ap ) ;
#line 1449 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
__inline static char *( /* format attribute */  __talloc_vaslenprintf_append___0)(char *s ,
                                                                                  size_t slen ,
                                                                                  char const   *fmt ,
                                                                                  va_list ap ) 
{ 
  ssize_t alen ;
  va_list ap2 ;
  char c ;
  int tmp ;
  void *tmp___0 ;

  {
  {
#line 1456
  __builtin_va_copy(ap2, ap);
#line 1457
  tmp = vsnprintf((char */* __restrict  */)(& c), (size_t )1, (char const   */* __restrict  */)fmt,
                  ap2);
#line 1457
  alen = (ssize_t )tmp;
#line 1458
  __builtin_va_end(ap2);
  }
#line 1460
  if (alen <= 0L) {
#line 1467
    return (s);
  }
  {
#line 1470
  tmp___0 = _talloc_realloc_array((void const   *)((void *)0), (void *)s, sizeof(char ),
                                  (unsigned int )((slen + (size_t )alen) + 1UL), "char");
#line 1470
  s = (char *)tmp___0;
  }
#line 1471
  if (! s) {
#line 1471
    return ((char *)((void *)0));
  }
  {
#line 1473
  __builtin_va_copy(ap2, ap);
#line 1474
  vsnprintf((char */* __restrict  */)(s + slen), (size_t )(alen + 1L), (char const   */* __restrict  */)fmt,
            ap2);
#line 1475
  __builtin_va_end(ap2);
#line 1477
  _talloc_set_name_const___0((void const   *)s, (char const   *)s);
  }
#line 1478
  return (s);
}
}
#line 1591 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
static int talloc_autofree_destructor___0(void *ptr ) 
{ 


  {
#line 1593
  autofree_context___0 = (void *)0;
#line 1594
  return (0);
}
}
#line 1597 "/home/june/repo/benchmarks/collector/temp/reglookup-0.12.0/lib/talloc.c"
static void talloc_autofree___0(void) 
{ 


  {
  {
#line 1599
  _talloc_free___0(autofree_context___0);
  }
#line 1600
  return;
}
}
