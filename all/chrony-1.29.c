/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 41 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/logging.h"
enum __anonenum_LOG_Facility_2 {
    LOGF_Reference = 0,
    LOGF_NtpIO = 1,
    LOGF_NtpCore = 2,
    LOGF_NtpSources = 3,
    LOGF_Scheduler = 4,
    LOGF_SourceStats = 5,
    LOGF_Sources = 6,
    LOGF_Local = 7,
    LOGF_Util = 8,
    LOGF_Main = 9,
    LOGF_ClientLog = 10,
    LOGF_Configure = 11,
    LOGF_CmdMon = 12,
    LOGF_Acquire = 13,
    LOGF_Manual = 14,
    LOGF_Keys = 15,
    LOGF_Logging = 16,
    LOGF_Rtc = 17,
    LOGF_Regress = 18,
    LOGF_Sys = 19,
    LOGF_SysLinux = 20,
    LOGF_SysNetBSD = 21,
    LOGF_SysSolaris = 22,
    LOGF_SysSunOS = 23,
    LOGF_SysWinnt = 24,
    LOGF_RtcLinux = 25,
    LOGF_Refclock = 26
} ;
#line 41 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/logging.h"
typedef enum __anonenum_LOG_Facility_2 LOG_Facility;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 39 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/addressing.h"
union __anonunion_addr_72 {
   uint32_t in4 ;
   uint8_t in6[16] ;
};
#line 39 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/addressing.h"
struct __anonstruct_IPAddr_71 {
   union __anonunion_addr_72 addr ;
   uint16_t family ;
};
#line 39 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/addressing.h"
typedef struct __anonstruct_IPAddr_71 IPAddr;
#line 32 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/addrfilt.h"
struct ADF_AuthTableInst;
#line 32 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/addrfilt.h"
typedef struct ADF_AuthTableInst *ADF_AuthTable;
#line 34
enum __anonenum_ADF_Status_74 {
    ADF_SUCCESS = 0,
    ADF_BADSUBNET = 1
} ;
#line 34 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/addrfilt.h"
typedef enum __anonenum_ADF_Status_74 ADF_Status;
#line 45 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/addrfilt.c"
enum __anonenum_State_75 {
    DENY = 0,
    ALLOW = 1,
    AS_PARENT = 2
} ;
#line 45 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/addrfilt.c"
typedef enum __anonenum_State_75 State;
#line 47 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/addrfilt.c"
struct _TableNode {
   State state ;
   struct _TableNode *extended ;
};
#line 47 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/addrfilt.c"
typedef struct _TableNode TableNode;
#line 52 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/addrfilt.c"
struct ADF_AuthTableInst {
   TableNode base4 ;
   TableNode base6 ;
};
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 32 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/logging.h"
enum __anonenum_LOG_Severity_98 {
    LOGS_INFO = 0,
    LOGS_WARN = 1,
    LOGS_ERR = 2
} ;
#line 32 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/logging.h"
typedef enum __anonenum_LOG_Severity_98 LOG_Severity;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 9 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/chrony_timex.h"
struct timex {
   unsigned int modes ;
   long offset ;
   long freq ;
   long maxerror ;
   long esterror ;
   int status ;
   long constant ;
   long precision ;
   long tolerance ;
   struct timeval time ;
   long tick ;
   long ppsfreq ;
   long jitter ;
   int shift ;
   long stabil ;
   long jitcnt ;
   long calcnt ;
   long errcnt ;
   long stbcnt ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
};
#line 31 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/wrap_adjtimex.h"
struct tmx_params {
   long tick ;
   long offset ;
   long freq ;
   double dfreq ;
   long maxerror ;
   long esterror ;
   unsigned int sta_pll : 1 ;
   unsigned int sta_ppsfreq : 1 ;
   unsigned int sta_ppstime : 1 ;
   unsigned int sta_fll : 1 ;
   unsigned int sta_ins : 1 ;
   unsigned int sta_del : 1 ;
   unsigned int sta_unsync : 1 ;
   unsigned int sta_freqhold : 1 ;
   unsigned int sta_ppssignal : 1 ;
   unsigned int sta_ppsjitter : 1 ;
   unsigned int sta_ppswander : 1 ;
   unsigned int sta_ppserror : 1 ;
   unsigned int sta_clockerr : 1 ;
   int status ;
   long constant ;
   long precision ;
   long tolerance ;
   long ppsfreq ;
   long jitter ;
   int shift ;
   long stabil ;
   long jitcnt ;
   long calcnt ;
   long errcnt ;
   long stbcnt ;
};
#line 55 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sources.h"
enum __anonenum_SRC_SelectOption_91 {
    SRC_SelectNormal = 0,
    SRC_SelectNoselect = 1,
    SRC_SelectPrefer = 2
} ;
#line 55 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sources.h"
typedef enum __anonenum_SRC_SelectOption_91 SRC_SelectOption;
#line 32 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/srcparams.h"
struct __anonstruct_SourceParameters_93 {
   int minpoll ;
   int maxpoll ;
   int online ;
   int auto_offline ;
   int presend_minpoll ;
   int iburst ;
   int min_stratum ;
   int poll_target ;
   unsigned long authkey ;
   double max_delay ;
   double max_delay_ratio ;
   double max_delay_dev_ratio ;
   SRC_SelectOption sel_option ;
};
#line 32 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/srcparams.h"
typedef struct __anonstruct_SourceParameters_93 SourceParameters;
#line 33 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdparse.h"
enum __anonenum_CPS_Status_94 {
    CPS_Success = 0,
    CPS_BadOption = 1,
    CPS_BadHost = 2,
    CPS_BadPort = 3,
    CPS_BadMinpoll = 4,
    CPS_BadMaxpoll = 5,
    CPS_BadPresend = 6,
    CPS_BadMaxdelaydevratio = 7,
    CPS_BadMaxdelayratio = 8,
    CPS_BadMaxdelay = 9,
    CPS_BadKey = 10,
    CPS_BadMinstratum = 11,
    CPS_BadPolltarget = 12
} ;
#line 33 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdparse.h"
typedef enum __anonenum_CPS_Status_94 CPS_Status;
#line 49 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdparse.h"
struct __anonstruct_CPS_NTP_Source_95 {
   char *name ;
   unsigned short port ;
   SourceParameters params ;
};
#line 49 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdparse.h"
typedef struct __anonstruct_CPS_NTP_Source_95 CPS_NTP_Source;
#line 196 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef int int32_t;
#line 98 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
struct __anonstruct_Timeval_79 {
   uint32_t tv_sec_high ;
   uint32_t tv_sec_low ;
   uint32_t tv_nsec ;
};
#line 98 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
typedef struct __anonstruct_Timeval_79 Timeval;
#line 110 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
struct __anonstruct_Float_80 {
   int32_t f ;
};
#line 110 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
typedef struct __anonstruct_Float_80 Float;
#line 118 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
struct __anonstruct_REQ_Online_81 {
   IPAddr mask ;
   IPAddr address ;
   int32_t EOR ;
};
#line 118 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
typedef struct __anonstruct_REQ_Online_81 REQ_Online;
#line 124 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
struct __anonstruct_REQ_Offline_82 {
   IPAddr mask ;
   IPAddr address ;
   int32_t EOR ;
};
#line 124 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
typedef struct __anonstruct_REQ_Offline_82 REQ_Offline;
#line 130 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
struct __anonstruct_REQ_Burst_83 {
   IPAddr mask ;
   IPAddr address ;
   int32_t n_good_samples ;
   int32_t n_total_samples ;
   int32_t EOR ;
};
#line 130 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
typedef struct __anonstruct_REQ_Burst_83 REQ_Burst;
#line 138 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
struct __anonstruct_REQ_Modify_Minpoll_84 {
   IPAddr address ;
   int32_t new_minpoll ;
   int32_t EOR ;
};
#line 138 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
typedef struct __anonstruct_REQ_Modify_Minpoll_84 REQ_Modify_Minpoll;
#line 144 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
struct __anonstruct_REQ_Modify_Maxpoll_85 {
   IPAddr address ;
   int32_t new_maxpoll ;
   int32_t EOR ;
};
#line 144 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
typedef struct __anonstruct_REQ_Modify_Maxpoll_85 REQ_Modify_Maxpoll;
#line 150 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
struct __anonstruct_REQ_Dump_86 {
   int32_t pad ;
   int32_t EOR ;
};
#line 150 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
typedef struct __anonstruct_REQ_Dump_86 REQ_Dump;
#line 155 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
struct __anonstruct_REQ_Modify_Maxdelay_87 {
   IPAddr address ;
   Float new_max_delay ;
   int32_t EOR ;
};
#line 155 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
typedef struct __anonstruct_REQ_Modify_Maxdelay_87 REQ_Modify_Maxdelay;
#line 161 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
struct __anonstruct_REQ_Modify_Maxdelayratio_88 {
   IPAddr address ;
   Float new_max_delay_ratio ;
   int32_t EOR ;
};
#line 161 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
typedef struct __anonstruct_REQ_Modify_Maxdelayratio_88 REQ_Modify_Maxdelayratio;
#line 167 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
struct __anonstruct_REQ_Modify_Maxdelaydevratio_89 {
   IPAddr address ;
   Float new_max_delay_dev_ratio ;
   int32_t EOR ;
};
#line 167 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
typedef struct __anonstruct_REQ_Modify_Maxdelaydevratio_89 REQ_Modify_Maxdelaydevratio;
#line 173 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
struct __anonstruct_REQ_Modify_Minstratum_90 {
   IPAddr address ;
   int32_t new_min_stratum ;
   int32_t EOR ;
};
#line 173 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
typedef struct __anonstruct_REQ_Modify_Minstratum_90 REQ_Modify_Minstratum;
#line 179 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
struct __anonstruct_REQ_Modify_Polltarget_91 {
   IPAddr address ;
   int32_t new_poll_target ;
   int32_t EOR ;
};
#line 179 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
typedef struct __anonstruct_REQ_Modify_Polltarget_91 REQ_Modify_Polltarget;
#line 185 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
struct __anonstruct_REQ_Modify_Maxupdateskew_92 {
   Float new_max_update_skew ;
   int32_t EOR ;
};
#line 185 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
typedef struct __anonstruct_REQ_Modify_Maxupdateskew_92 REQ_Modify_Maxupdateskew;
#line 190 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
struct __anonstruct_REQ_Logon_93 {
   Timeval ts ;
   int32_t EOR ;
};
#line 190 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
typedef struct __anonstruct_REQ_Logon_93 REQ_Logon;
#line 195 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
struct __anonstruct_REQ_Settime_94 {
   Timeval ts ;
   int32_t EOR ;
};
#line 195 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
typedef struct __anonstruct_REQ_Settime_94 REQ_Settime;
#line 200 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
struct __anonstruct_REQ_Local_95 {
   int32_t on_off ;
   int32_t stratum ;
   int32_t EOR ;
};
#line 200 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
typedef struct __anonstruct_REQ_Local_95 REQ_Local;
#line 206 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
struct __anonstruct_REQ_Manual_96 {
   int32_t option ;
   int32_t EOR ;
};
#line 206 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
typedef struct __anonstruct_REQ_Manual_96 REQ_Manual;
#line 211 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
struct __anonstruct_REQ_N_Sources_97 {
   int32_t EOR ;
};
#line 211 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
typedef struct __anonstruct_REQ_N_Sources_97 REQ_N_Sources;
#line 215 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
struct __anonstruct_REQ_Source_Data_98 {
   int32_t index ;
   int32_t EOR ;
};
#line 215 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
typedef struct __anonstruct_REQ_Source_Data_98 REQ_Source_Data;
#line 220 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
struct __anonstruct_REQ_Rekey_99 {
   int32_t EOR ;
};
#line 220 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
typedef struct __anonstruct_REQ_Rekey_99 REQ_Rekey;
#line 224 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
struct __anonstruct_REQ_Allow_Deny_100 {
   IPAddr ip ;
   int32_t subnet_bits ;
   int32_t EOR ;
};
#line 224 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
typedef struct __anonstruct_REQ_Allow_Deny_100 REQ_Allow_Deny;
#line 230 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
struct __anonstruct_REQ_Ac_Check_101 {
   IPAddr ip ;
   int32_t EOR ;
};
#line 230 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
typedef struct __anonstruct_REQ_Ac_Check_101 REQ_Ac_Check;
#line 242 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
struct __anonstruct_REQ_NTP_Source_102 {
   IPAddr ip_addr ;
   uint32_t port ;
   int32_t minpoll ;
   int32_t maxpoll ;
   int32_t presend_minpoll ;
   uint32_t authkey ;
   Float max_delay ;
   Float max_delay_ratio ;
   uint32_t flags ;
   int32_t EOR ;
};
#line 242 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
typedef struct __anonstruct_REQ_NTP_Source_102 REQ_NTP_Source;
#line 255 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
struct __anonstruct_REQ_Del_Source_103 {
   IPAddr ip_addr ;
   int32_t EOR ;
};
#line 255 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
typedef struct __anonstruct_REQ_Del_Source_103 REQ_Del_Source;
#line 260 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
struct __anonstruct_REQ_WriteRtc_104 {
   int32_t EOR ;
};
#line 260 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
typedef struct __anonstruct_REQ_WriteRtc_104 REQ_WriteRtc;
#line 264 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
struct __anonstruct_REQ_Dfreq_105 {
   Float dfreq ;
   int32_t EOR ;
};
#line 264 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
typedef struct __anonstruct_REQ_Dfreq_105 REQ_Dfreq;
#line 269 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
struct __anonstruct_REQ_Doffset_106 {
   int32_t sec ;
   int32_t usec ;
   int32_t EOR ;
};
#line 269 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
typedef struct __anonstruct_REQ_Doffset_106 REQ_Doffset;
#line 275 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
struct __anonstruct_REQ_Tracking_107 {
   int32_t EOR ;
};
#line 275 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
typedef struct __anonstruct_REQ_Tracking_107 REQ_Tracking;
#line 279 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
struct __anonstruct_REQ_Sourcestats_108 {
   uint32_t index ;
   int32_t EOR ;
};
#line 279 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
typedef struct __anonstruct_REQ_Sourcestats_108 REQ_Sourcestats;
#line 284 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
struct __anonstruct_REQ_RTCReport_109 {
   int32_t EOR ;
};
#line 284 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
typedef struct __anonstruct_REQ_RTCReport_109 REQ_RTCReport;
#line 288 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
struct __anonstruct_REQ_TrimRTC_110 {
   int32_t EOR ;
};
#line 288 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
typedef struct __anonstruct_REQ_TrimRTC_110 REQ_TrimRTC;
#line 292 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
struct __anonstruct_REQ_CycleLogs_111 {
   int32_t EOR ;
};
#line 292 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
typedef struct __anonstruct_REQ_CycleLogs_111 REQ_CycleLogs;
#line 305 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
struct __anonstruct_REQ_ClientAccessesByIndex_113 {
   uint32_t first_index ;
   uint32_t n_indices ;
   int32_t EOR ;
};
#line 305 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
typedef struct __anonstruct_REQ_ClientAccessesByIndex_113 REQ_ClientAccessesByIndex;
#line 311 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
struct __anonstruct_REQ_ManualList_114 {
   int32_t EOR ;
};
#line 311 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
typedef struct __anonstruct_REQ_ManualList_114 REQ_ManualList;
#line 315 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
struct __anonstruct_REQ_ManualDelete_115 {
   int32_t index ;
   int32_t EOR ;
};
#line 315 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
typedef struct __anonstruct_REQ_ManualDelete_115 REQ_ManualDelete;
#line 320 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
struct __anonstruct_REQ_MakeStep_116 {
   int32_t EOR ;
};
#line 320 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
typedef struct __anonstruct_REQ_MakeStep_116 REQ_MakeStep;
#line 324 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
struct __anonstruct_REQ_Activity_117 {
   int32_t EOR ;
};
#line 324 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
typedef struct __anonstruct_REQ_Activity_117 REQ_Activity;
#line 328 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
struct __anonstruct_REQ_Reselect_118 {
   int32_t EOR ;
};
#line 328 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
typedef struct __anonstruct_REQ_Reselect_118 REQ_Reselect;
#line 332 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
struct __anonstruct_REQ_ReselectDistance_119 {
   Float distance ;
   int32_t EOR ;
};
#line 332 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
typedef struct __anonstruct_REQ_ReselectDistance_119 REQ_ReselectDistance;
#line 373 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
union __anonunion_data_121 {
   REQ_Online online ;
   REQ_Offline offline ;
   REQ_Burst burst ;
   REQ_Modify_Minpoll modify_minpoll ;
   REQ_Modify_Maxpoll modify_maxpoll ;
   REQ_Dump dump ;
   REQ_Modify_Maxdelay modify_maxdelay ;
   REQ_Modify_Maxdelayratio modify_maxdelayratio ;
   REQ_Modify_Maxdelaydevratio modify_maxdelaydevratio ;
   REQ_Modify_Minstratum modify_minstratum ;
   REQ_Modify_Polltarget modify_polltarget ;
   REQ_Modify_Maxupdateskew modify_maxupdateskew ;
   REQ_Logon logon ;
   REQ_Settime settime ;
   REQ_Local local ;
   REQ_Manual manual ;
   REQ_N_Sources n_sources ;
   REQ_Source_Data source_data ;
   REQ_Rekey rekey ;
   REQ_Allow_Deny allow_deny ;
   REQ_Ac_Check ac_check ;
   REQ_NTP_Source ntp_source ;
   REQ_Del_Source del_source ;
   REQ_WriteRtc writertc ;
   REQ_Dfreq dfreq ;
   REQ_Doffset doffset ;
   REQ_Tracking tracking ;
   REQ_Sourcestats sourcestats ;
   REQ_RTCReport rtcreport ;
   REQ_TrimRTC trimrtc ;
   REQ_CycleLogs cyclelogs ;
   REQ_ClientAccessesByIndex client_accesses_by_index ;
   REQ_ManualList manual_list ;
   REQ_ManualDelete manual_delete ;
   REQ_MakeStep make_step ;
   REQ_Activity activity ;
   REQ_Reselect reselect ;
   REQ_ReselectDistance reselect_distance ;
};
#line 373 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
struct __anonstruct_CMD_Request_120 {
   uint8_t version ;
   uint8_t pkt_type ;
   uint8_t res1 ;
   uint8_t res2 ;
   uint16_t command ;
   uint16_t attempt ;
   uint32_t sequence ;
   uint32_t utoken ;
   uint32_t token ;
   union __anonunion_data_121 data ;
   uint8_t auth[64] ;
};
#line 373 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
typedef struct __anonstruct_CMD_Request_120 CMD_Request;
#line 479 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
struct __anonstruct_RPY_Null_122 {
   int32_t EOR ;
};
#line 479 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
typedef struct __anonstruct_RPY_Null_122 RPY_Null;
#line 483 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
struct __anonstruct_RPY_N_Sources_123 {
   uint32_t n_sources ;
   int32_t EOR ;
};
#line 483 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
typedef struct __anonstruct_RPY_N_Sources_123 RPY_N_Sources;
#line 502 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
struct __anonstruct_RPY_Source_Data_124 {
   IPAddr ip_addr ;
   uint16_t poll ;
   uint16_t stratum ;
   uint16_t state ;
   uint16_t mode ;
   uint16_t flags ;
   uint16_t reachability ;
   uint32_t since_sample ;
   Float orig_latest_meas ;
   Float latest_meas ;
   Float latest_meas_err ;
   int32_t EOR ;
};
#line 502 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
typedef struct __anonstruct_RPY_Source_Data_124 RPY_Source_Data;
#line 517 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
struct __anonstruct_RPY_Tracking_125 {
   uint32_t ref_id ;
   IPAddr ip_addr ;
   uint16_t stratum ;
   uint16_t leap_status ;
   Timeval ref_time ;
   Float current_correction ;
   Float last_offset ;
   Float rms_offset ;
   Float freq_ppm ;
   Float resid_freq_ppm ;
   Float skew_ppm ;
   Float root_delay ;
   Float root_dispersion ;
   Float last_update_interval ;
   int32_t EOR ;
};
#line 517 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
typedef struct __anonstruct_RPY_Tracking_125 RPY_Tracking;
#line 535 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
struct __anonstruct_RPY_Sourcestats_126 {
   uint32_t ref_id ;
   IPAddr ip_addr ;
   uint32_t n_samples ;
   uint32_t n_runs ;
   uint32_t span_seconds ;
   Float sd ;
   Float resid_freq_ppm ;
   Float skew_ppm ;
   Float est_offset ;
   Float est_offset_err ;
   int32_t EOR ;
};
#line 535 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
typedef struct __anonstruct_RPY_Sourcestats_126 RPY_Sourcestats;
#line 549 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
struct __anonstruct_RPY_Rtc_127 {
   Timeval ref_time ;
   uint16_t n_samples ;
   uint16_t n_runs ;
   uint32_t span_seconds ;
   Float rtc_seconds_fast ;
   Float rtc_gain_rate_ppm ;
   int32_t EOR ;
};
#line 549 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
typedef struct __anonstruct_RPY_Rtc_127 RPY_Rtc;
#line 559 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
struct __anonstruct_RPY_ManualTimestamp_128 {
   uint32_t centiseconds ;
   Float dfreq_ppm ;
   Float new_afreq_ppm ;
   int32_t EOR ;
};
#line 559 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
typedef struct __anonstruct_RPY_ManualTimestamp_128 RPY_ManualTimestamp;
#line 572 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
struct __anonstruct_RPY_ClientAccesses_Client_130 {
   IPAddr ip ;
   uint32_t client_hits ;
   uint32_t peer_hits ;
   uint32_t cmd_hits_auth ;
   uint32_t cmd_hits_normal ;
   uint32_t cmd_hits_bad ;
   uint32_t last_ntp_hit_ago ;
   uint32_t last_cmd_hit_ago ;
};
#line 572 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
typedef struct __anonstruct_RPY_ClientAccesses_Client_130 RPY_ClientAccesses_Client;
#line 583 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
struct __anonstruct_RPY_ClientAccessesByIndex_131 {
   uint32_t n_indices ;
   uint32_t next_index ;
   uint32_t n_clients ;
   RPY_ClientAccesses_Client clients[8] ;
};
#line 583 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
typedef struct __anonstruct_RPY_ClientAccessesByIndex_131 RPY_ClientAccessesByIndex;
#line 592 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
struct __anonstruct_RPY_ManualListSample_132 {
   Timeval when ;
   Float slewed_offset ;
   Float orig_offset ;
   Float residual ;
};
#line 592 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
typedef struct __anonstruct_RPY_ManualListSample_132 RPY_ManualListSample;
#line 599 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
struct __anonstruct_RPY_ManualList_133 {
   uint32_t n_samples ;
   RPY_ManualListSample samples[32] ;
};
#line 599 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
typedef struct __anonstruct_RPY_ManualList_133 RPY_ManualList;
#line 604 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
struct __anonstruct_RPY_Activity_134 {
   int32_t online ;
   int32_t offline ;
   int32_t burst_online ;
   int32_t burst_offline ;
   int32_t unresolved ;
   int32_t EOR ;
};
#line 604 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
typedef struct __anonstruct_RPY_Activity_134 RPY_Activity;
#line 613 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
union __anonunion_data_136 {
   RPY_Null null ;
   RPY_N_Sources n_sources ;
   RPY_Source_Data source_data ;
   RPY_ManualTimestamp manual_timestamp ;
   RPY_Tracking tracking ;
   RPY_Sourcestats sourcestats ;
   RPY_Rtc rtc ;
   RPY_ClientAccessesByIndex client_accesses_by_index ;
   RPY_ManualList manual_list ;
   RPY_Activity activity ;
};
#line 613 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
struct __anonstruct_CMD_Reply_135 {
   uint8_t version ;
   uint8_t pkt_type ;
   uint8_t res1 ;
   uint8_t res2 ;
   uint16_t command ;
   uint16_t reply ;
   uint16_t status ;
   uint16_t number ;
   uint16_t total ;
   uint16_t pad1 ;
   uint32_t sequence ;
   uint32_t utoken ;
   uint32_t token ;
   union __anonunion_data_136 data ;
   uint8_t auth[64] ;
};
#line 613 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/candm.h"
typedef struct __anonstruct_CMD_Reply_135 CMD_Reply;
#line 194 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef signed char int8_t;
#line 34 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp.h"
struct __anonstruct_NTP_int64_71 {
   uint32_t hi ;
   uint32_t lo ;
};
#line 34 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp.h"
typedef struct __anonstruct_NTP_int64_71 NTP_int64;
#line 39 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp.h"
typedef uint32_t NTP_int32;
#line 60 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp.h"
struct __anonstruct_NTP_Packet_74 {
   uint8_t lvm ;
   uint8_t stratum ;
   int8_t poll ;
   int8_t precision ;
   NTP_int32 root_delay ;
   NTP_int32 root_dispersion ;
   NTP_int32 reference_id ;
   NTP_int64 reference_ts ;
   NTP_int64 originate_ts ;
   NTP_int64 receive_ts ;
   NTP_int64 transmit_ts ;
   NTP_int32 auth_keyid ;
   uint8_t auth_data[64] ;
};
#line 60 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp.h"
typedef struct __anonstruct_NTP_Packet_74 NTP_Packet;
#line 47 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/addressing.h"
struct __anonstruct_NTP_Remote_Address_78 {
   IPAddr ip_addr ;
   IPAddr local_ip_addr ;
   unsigned short port ;
};
#line 47 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/addressing.h"
typedef struct __anonstruct_NTP_Remote_Address_78 NTP_Remote_Address;
#line 35 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reports.h"
enum __anonenum_mode_80 {
    RPT_NTP_CLIENT = 0,
    RPT_NTP_PEER = 1,
    RPT_LOCAL_REFERENCE = 2
} ;
#line 35
enum __anonenum_state_81 {
    RPT_SYNC = 0,
    RPT_UNREACH = 1,
    RPT_FALSETICKER = 2,
    RPT_JITTERY = 3,
    RPT_CANDIDATE = 4,
    RPT_OUTLIER = 5
} ;
#line 35
enum __anonenum_sel_option_82 {
    RPT_NORMAL = 0,
    RPT_PREFER = 1,
    RPT_NOSELECT = 2
} ;
#line 35 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reports.h"
struct __anonstruct_RPT_SourceReport_79 {
   IPAddr ip_addr ;
   int stratum ;
   int poll ;
   enum __anonenum_mode_80 mode ;
   enum __anonenum_state_81 state ;
   enum __anonenum_sel_option_82 sel_option ;
   int reachability ;
   unsigned long latest_meas_ago ;
   double orig_latest_meas ;
   double latest_meas ;
   double latest_meas_err ;
};
#line 35 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reports.h"
typedef struct __anonstruct_RPT_SourceReport_79 RPT_SourceReport;
#line 117 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reports.h"
struct __anonstruct_RPT_ActivityReport_89 {
   int online ;
   int offline ;
   int burst_online ;
   int burst_offline ;
   int unresolved ;
};
#line 117 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reports.h"
typedef struct __anonstruct_RPT_ActivityReport_89 RPT_ActivityReport;
#line 37 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_core.h"
enum __anonenum_NTP_Source_Type_94 {
    NTP_SERVER = 0,
    NTP_PEER = 1
} ;
#line 37 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_core.h"
typedef enum __anonenum_NTP_Source_Type_94 NTP_Source_Type;
#line 43
struct NCR_Instance_Record;
#line 43 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_core.h"
typedef struct NCR_Instance_Record *NCR_Instance;
#line 41 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_sources.h"
enum __anonenum_NSR_Status_95 {
    NSR_Success = 0,
    NSR_NoSuchSource = 1,
    NSR_AlreadyInUse = 2,
    NSR_TooManySources = 3,
    NSR_InvalidAF = 4
} ;
#line 41 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_sources.h"
typedef enum __anonenum_NSR_Status_95 NSR_Status;
#line 33 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/nameserv.h"
enum __anonenum_DNS_Status_156 {
    DNS_Success = 0,
    DNS_TryAgain = 1,
    DNS_Failure = 2
} ;
#line 33 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/nameserv.h"
typedef enum __anonenum_DNS_Status_156 DNS_Status;
#line 32 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sched.h"
typedef unsigned long SCH_TimeoutID;
#line 41 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sched.h"
typedef void *SCH_ArbitraryArgument;
#line 47 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_sources.c"
struct __anonstruct_SourceRecord_158 {
   NTP_Remote_Address *remote_addr ;
   NCR_Instance data ;
};
#line 47 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_sources.c"
typedef struct __anonstruct_SourceRecord_158 SourceRecord;
#line 66 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_sources.c"
struct UnresolvedSource {
   char *name ;
   int port ;
   NTP_Source_Type type ;
   SourceParameters params ;
   struct UnresolvedSource *next ;
};
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 44 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp.h"
enum __anonenum_NTP_Leap_75 {
    LEAP_Normal = 0,
    LEAP_InsertSecond = 1,
    LEAP_DeleteSecond = 2,
    LEAP_Unsynchronised = 3
} ;
#line 44 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp.h"
typedef enum __anonenum_NTP_Leap_75 NTP_Leap;
#line 51
enum __anonenum_NTP_Mode_76 {
    MODE_UNDEFINED = 0,
    MODE_ACTIVE = 1,
    MODE_PASSIVE = 2,
    MODE_CLIENT = 3,
    MODE_SERVER = 4,
    MODE_BROADCAST = 5
} ;
#line 51 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp.h"
typedef enum __anonenum_NTP_Mode_76 NTP_Mode;
#line 41 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sources.h"
struct SRC_Instance_Record;
#line 41 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sources.h"
typedef struct SRC_Instance_Record *SRC_Instance;
#line 49
enum __anonenum_SRC_Type_90 {
    SRC_NTP = 0,
    SRC_REFCLOCK = 1
} ;
#line 49 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sources.h"
typedef enum __anonenum_SRC_Type_90 SRC_Type;
#line 34 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sched.h"
enum __anonenum_SCH_TimeoutClass_95 {
    SCH_ReservedTimeoutValue = 0,
    SCH_NtpSamplingClass = 1,
    SCH_NtpBroadcastClass = 2,
    SCH_NumberOfClasses = 3
} ;
#line 34 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sched.h"
typedef enum __anonenum_SCH_TimeoutClass_95 SCH_TimeoutClass;
#line 110 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/logging.h"
typedef int LOG_FileID;
#line 59 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_core.c"
typedef int OperatingMode;
#line 70 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_core.c"
struct NCR_Instance_Record {
   NTP_Remote_Address remote_addr ;
   NTP_Mode mode ;
   OperatingMode opmode ;
   int timer_running ;
   SCH_TimeoutID timeout_id ;
   int auto_offline ;
   int local_poll ;
   int remote_poll ;
   int remote_stratum ;
   int presend_minpoll ;
   int presend_done ;
   int minpoll ;
   int maxpoll ;
   int min_stratum ;
   int poll_target ;
   double poll_score ;
   double max_delay ;
   double max_delay_ratio ;
   double max_delay_dev_ratio ;
   int do_auth ;
   unsigned long auth_key_id ;
   int tx_count ;
   NTP_int64 remote_orig ;
   struct timeval local_rx ;
   NTP_int64 local_ntp_tx ;
   struct timeval local_tx ;
   SRC_Instance source ;
   int burst_good_samples_to_go ;
   int burst_total_samples_to_go ;
};
#line 110 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reports.h"
struct __anonstruct_RPT_ManualSamplesReport_83 {
   struct timeval when ;
   double slewed_offset ;
   double orig_offset ;
   double residual ;
};
#line 110 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reports.h"
typedef struct __anonstruct_RPT_ManualSamplesReport_83 RPT_ManualSamplesReport;
#line 49 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/manual.c"
struct __anonstruct_Sample_150 {
   struct timeval when ;
   double orig_offset ;
   double offset ;
   double residual ;
};
#line 49 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/manual.c"
typedef struct __anonstruct_Sample_150 Sample;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 20 "/usr/include/linux/rtc.h"
struct rtc_time {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
};
#line 80 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reports.h"
struct __anonstruct_RPT_RTC_Report_146 {
   struct timeval ref_time ;
   unsigned short n_samples ;
   unsigned short n_runs ;
   unsigned long span_seconds ;
   double rtc_seconds_fast ;
   double rtc_gain_rate_ppm ;
};
#line 80 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reports.h"
typedef struct __anonstruct_RPT_RTC_Report_146 RPT_RTC_Report;
#line 89 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reports.h"
struct __anonstruct_RPT_ClientAccess_Report_81 {
   unsigned long client_hits ;
   unsigned long peer_hits ;
   unsigned long cmd_hits_auth ;
   unsigned long cmd_hits_normal ;
   unsigned long cmd_hits_bad ;
   unsigned long last_ntp_hit_ago ;
   unsigned long last_cmd_hit_ago ;
};
#line 89 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reports.h"
typedef struct __anonstruct_RPT_ClientAccess_Report_81 RPT_ClientAccess_Report;
#line 99 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reports.h"
struct __anonstruct_RPT_ClientAccessByIndex_Report_82 {
   IPAddr ip_addr ;
   unsigned long client_hits ;
   unsigned long peer_hits ;
   unsigned long cmd_hits_auth ;
   unsigned long cmd_hits_normal ;
   unsigned long cmd_hits_bad ;
   unsigned long last_ntp_hit_ago ;
   unsigned long last_cmd_hit_ago ;
};
#line 99 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reports.h"
typedef struct __anonstruct_RPT_ClientAccessByIndex_Report_82 RPT_ClientAccessByIndex_Report;
#line 44 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/clientlog.h"
enum __anonenum_CLG_Command_Type_85 {
    CLG_CMD_AUTH = 0,
    CLG_CMD_NORMAL = 1,
    CLG_CMD_BAD_PKT = 2
} ;
#line 44 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/clientlog.h"
typedef enum __anonenum_CLG_Command_Type_85 CLG_Command_Type;
#line 55
enum __anonenum_CLG_Status_86 {
    CLG_SUCCESS = 0,
    CLG_EMPTYSUBNET = 1,
    CLG_BADSUBNET = 2,
    CLG_INACTIVE = 3,
    CLG_INDEXTOOLARGE = 4
} ;
#line 55 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/clientlog.h"
typedef enum __anonenum_CLG_Status_86 CLG_Status;
#line 54 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/clientlog.c"
struct _Node {
   IPAddr ip_addr ;
   unsigned long client_hits ;
   unsigned long peer_hits ;
   unsigned long cmd_hits_bad ;
   unsigned long cmd_hits_normal ;
   unsigned long cmd_hits_auth ;
   time_t last_ntp_hit ;
   time_t last_cmd_hit ;
};
#line 54 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/clientlog.c"
typedef struct _Node Node;
#line 65 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/clientlog.c"
struct _Subnet {
   void *entry[1UL << 8] ;
};
#line 65 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/clientlog.c"
typedef struct _Subnet Subnet;
#line 34 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/refclock.h"
struct __anonstruct_RefclockParameters_94 {
   char *driver_name ;
   char *driver_parameter ;
   int driver_poll ;
   int poll ;
   int filter_length ;
   int pps_rate ;
   uint32_t ref_id ;
   uint32_t lock_ref_id ;
   double offset ;
   double delay ;
   double precision ;
   SRC_SelectOption sel_option ;
};
#line 34 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/refclock.h"
typedef struct __anonstruct_RefclockParameters_94 RefclockParameters;
#line 49
struct RCL_Instance_Record;
#line 49 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/refclock.h"
typedef struct RCL_Instance_Record *RCL_Instance;
#line 51 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/refclock.h"
struct __anonstruct_RefclockDriver_95 {
   int (*init)(RCL_Instance instance ) ;
   void (*fini)(RCL_Instance instance ) ;
   int (*poll)(RCL_Instance instance ) ;
};
#line 51 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/refclock.h"
typedef struct __anonstruct_RefclockDriver_95 RefclockDriver;
#line 46 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/refclock.c"
struct FilterSample {
   double offset ;
   double dispersion ;
   struct timeval sample_time ;
};
#line 52 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/refclock.c"
struct MedianFilter {
   int length ;
   int index ;
   int used ;
   int last ;
   int avg_var_n ;
   double avg_var ;
   struct FilterSample *samples ;
   int *selected ;
   double *x_data ;
   double *y_data ;
   double *w_data ;
};
#line 66 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/refclock.c"
struct RCL_Instance_Record {
   RefclockDriver *driver ;
   void *data ;
   char *driver_parameter ;
   int driver_parameter_length ;
   int driver_poll ;
   int driver_polled ;
   int poll ;
   int leap_status ;
   int pps_rate ;
   struct MedianFilter filter ;
   uint32_t ref_id ;
   uint32_t lock_ref ;
   double offset ;
   double delay ;
   double precision ;
   SCH_TimeoutID timeout_id ;
   SRC_Instance source ;
};
#line 38 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/md5.h"
typedef uint32_t UINT4;
#line 41 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/md5.h"
struct __anonstruct_MD5_CTX_71 {
   UINT4 i[2] ;
   UINT4 buf[4] ;
   unsigned char in[64] ;
   unsigned char digest[16] ;
};
#line 41 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/md5.h"
typedef struct __anonstruct_MD5_CTX_71 MD5_CTX;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 33 "/usr/include/x86_64-linux-gnu/bits/socket.h"
typedef __socklen_t socklen_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 90 "/usr/include/x86_64-linux-gnu/sys/socket.h"
struct sockaddr_in;
#line 90
struct sockaddr_in6;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 209 "/usr/include/netinet/in.h"
union __anonunion___in6_u_30 {
   uint8_t __u6_addr8[16] ;
   uint16_t __u6_addr16[8] ;
   uint32_t __u6_addr32[4] ;
};
#line 209 "/usr/include/netinet/in.h"
struct in6_addr {
   union __anonunion___in6_u_30 __in6_u ;
};
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 252 "/usr/include/netinet/in.h"
struct sockaddr_in6 {
   sa_family_t sin6_family ;
   in_port_t sin6_port ;
   uint32_t sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   uint32_t sin6_scope_id ;
};
#line 50 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reports.h"
struct __anonstruct_RPT_TrackingReport_144 {
   uint32_t ref_id ;
   IPAddr ip_addr ;
   unsigned long stratum ;
   unsigned long leap_status ;
   struct timeval ref_time ;
   double current_correction ;
   double last_offset ;
   double rms_offset ;
   double freq_ppm ;
   double resid_freq_ppm ;
   double skew_ppm ;
   double root_delay ;
   double root_dispersion ;
   double last_update_interval ;
};
#line 50 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reports.h"
typedef struct __anonstruct_RPT_TrackingReport_144 RPT_TrackingReport;
#line 67 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reports.h"
struct __anonstruct_RPT_SourcestatsReport_145 {
   uint32_t ref_id ;
   IPAddr ip_addr ;
   unsigned long n_samples ;
   unsigned long n_runs ;
   unsigned long span_seconds ;
   double resid_freq_ppm ;
   double skew_ppm ;
   double sd ;
   double est_offset ;
   double est_offset_err ;
};
#line 67 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reports.h"
typedef struct __anonstruct_RPT_SourcestatsReport_145 RPT_SourcestatsReport;
#line 55 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
union sockaddr_in46 {
   struct sockaddr_in in4 ;
   struct sockaddr_in6 in6 ;
   struct sockaddr u ;
};
#line 88 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
struct _ResponseCell {
   struct _ResponseCell *next ;
   unsigned long tok ;
   unsigned long next_tok ;
   unsigned long msg_seq ;
   unsigned long attempt ;
   struct timeval ts ;
   CMD_Reply rpy ;
};
#line 88 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
typedef struct _ResponseCell ResponseCell;
#line 432 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
struct _TimestampCell {
   struct _TimestampCell *next ;
   struct timeval ts ;
};
#line 432 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
typedef struct _TimestampCell TimestampCell;
#line 41 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/broadcast.c"
struct __anonstruct_Destination_149 {
   NTP_Remote_Address addr ;
   int interval ;
};
#line 41 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/broadcast.c"
typedef struct __anonstruct_Destination_149 Destination;
#line 171 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sources.h"
enum __anonenum_SRC_Skew_Direction_92 {
    SRC_Skew_Decrease = 0,
    SRC_Skew_Nochange = 1,
    SRC_Skew_Increase = 2
} ;
#line 171 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sources.h"
typedef enum __anonenum_SRC_Skew_Direction_92 SRC_Skew_Direction;
#line 34 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sourcestats.h"
struct SST_Stats_Record;
#line 34 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sourcestats.h"
typedef struct SST_Stats_Record *SST_Stats;
#line 140
enum __anonenum_SST_Skew_Direction_93 {
    SST_Skew_Decrease = 0,
    SST_Skew_Nochange = 1,
    SST_Skew_Increase = 2
} ;
#line 140 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sourcestats.h"
typedef enum __anonenum_SST_Skew_Direction_93 SST_Skew_Direction;
#line 55 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sources.c"
struct SelectInfo {
   int stratum ;
   int select_ok ;
   double variance ;
   double root_distance ;
   double lo_limit ;
   double hi_limit ;
};
#line 67
enum __anonenum_SRC_Status_156 {
    SRC_OK = 0,
    SRC_UNREACHABLE = 1,
    SRC_BAD_STATS = 2,
    SRC_FALSETICKER = 3,
    SRC_JITTERY = 4,
    SRC_SELECTABLE = 5,
    SRC_SYNC = 6
} ;
#line 67 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sources.c"
typedef enum __anonenum_SRC_Status_156 SRC_Status;
#line 81 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sources.c"
struct SRC_Instance_Record {
   SST_Stats stats ;
   NTP_Leap leap_status ;
   int index ;
   uint32_t ref_id ;
   IPAddr *ip_addr ;
   int selectable ;
   int reachability ;
   int beginning ;
   int outlier ;
   SRC_Status status ;
   SRC_Type type ;
   SRC_SelectOption sel_option ;
   double sel_score ;
   struct SelectInfo sel_info ;
};
#line 119
enum __anonenum_tag_157 {
    LOW = -1,
    CENTRE = 0,
    HIGH = 1
} ;
#line 119 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sources.c"
struct Sort_Element {
   int index ;
   double offset ;
   enum __anonenum_tag_157 tag ;
};
#line 42 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc.c"
struct __anonstruct_driver_87 {
   int (*init)(void) ;
   void (*fini)(void) ;
   void (*time_pre_init)(void) ;
   void (*time_init)(void (*after_hook)(void * ) , void *anything ) ;
   void (*start_measurements)(void) ;
   int (*write_parameters)(void) ;
   int (*get_report)(RPT_RTC_Report *report ) ;
   int (*trim)(void) ;
};
#line 567 "/usr/include/netdb.h"
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
#line 42 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/keys.c"
struct __anonstruct_Key_156 {
   unsigned long id ;
   char *val ;
   int len ;
   int hash_id ;
   int auth_delay ;
};
#line 42 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/keys.c"
typedef struct __anonstruct_Key_156 Key;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 51 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/logging.c"
struct LogFile {
   char const   *name ;
   char const   *banner ;
   FILE *file ;
   unsigned long writes ;
};
#line 65 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/local.c"
struct _ChangeListEntry {
   struct _ChangeListEntry *next ;
   struct _ChangeListEntry *prev ;
   void (*handler)(struct timeval *raw , struct timeval *cooked , double dfreq , double doffset ,
                   int is_step_change , void *anything ) ;
   void *anything ;
};
#line 65 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/local.c"
typedef struct _ChangeListEntry ChangeListEntry;
#line 79 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/local.c"
struct _DispersionNotifyListEntry {
   struct _DispersionNotifyListEntry *next ;
   struct _DispersionNotifyListEntry *prev ;
   void (*handler)(double dispersion , void *anything ) ;
   void *anything ;
};
#line 79 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/local.c"
typedef struct _DispersionNotifyListEntry DispersionNotifyListEntry;
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_4 {
   __fd_mask fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_4 fd_set;
#line 66 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sched.c"
struct __anonstruct_FileHandlerEntry_140 {
   void (*handler)(SCH_ArbitraryArgument  ) ;
   SCH_ArbitraryArgument arg ;
};
#line 66 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sched.c"
typedef struct __anonstruct_FileHandlerEntry_140 FileHandlerEntry;
#line 81 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sched.c"
struct _TimerQueueEntry {
   struct _TimerQueueEntry *next ;
   struct _TimerQueueEntry *prev ;
   struct timeval tv ;
   SCH_TimeoutID id ;
   SCH_TimeoutClass class ;
   void (*handler)(SCH_ArbitraryArgument  ) ;
   SCH_ArbitraryArgument arg ;
};
#line 81 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sched.c"
typedef struct _TimerQueueEntry TimerQueueEntry;
#line 85 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp.h"
union __anonunion_ReceiveBuffer_81 {
   NTP_Packet ntp_pkt ;
   uint8_t arbitrary[500] ;
};
#line 85 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp.h"
typedef union __anonunion_ReceiveBuffer_81 ReceiveBuffer;
#line 70 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/acquire.c"
struct __anonstruct_SourceRecord_140 {
   IPAddr ip_addr ;
   int sanity ;
   int n_dead_probes ;
   int n_samples ;
   int n_total_samples ;
   double offsets[8] ;
   double root_distances[8] ;
   double inter_lo ;
   double inter_hi ;
   NTP_int64 last_tx ;
   int timer_running ;
   SCH_TimeoutID timeout_id ;
};
#line 70 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/acquire.c"
typedef struct __anonstruct_SourceRecord_140 SourceRecord___0;
#line 119
enum __anonenum_type_142 {
    LO = 0,
    HIGH___0 = 1
} ;
#line 119 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/acquire.c"
struct __anonstruct_Endpoint_141 {
   double offset ;
   enum __anonenum_type_142 type ;
   int index ;
};
#line 119 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/acquire.c"
typedef struct __anonstruct_Endpoint_141 Endpoint;
#line 125 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/acquire.c"
struct __anonstruct_Interval_143 {
   double lo ;
   double hi ;
};
#line 125 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/acquire.c"
typedef struct __anonstruct_Interval_143 Interval;
#line 226 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
struct __anonstruct_NTP_Source_161 {
   NTP_Source_Type type ;
   CPS_NTP_Source params ;
};
#line 226 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
typedef struct __anonstruct_NTP_Source_161 NTP_Source;
#line 241 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
struct _AllowDeny {
   struct _AllowDeny *next ;
   struct _AllowDeny *prev ;
   IPAddr ip ;
   int subnet_bits ;
   int all ;
   int allow ;
};
#line 241 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
typedef struct _AllowDeny AllowDeny;
#line 253 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
struct __anonstruct_NTP_Broadcast_Destination_162 {
   IPAddr addr ;
   unsigned short port ;
   int interval ;
};
#line 253 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
typedef struct __anonstruct_NTP_Broadcast_Destination_162 NTP_Broadcast_Destination;
#line 136 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __rlim_t;
#line 48 "/usr/include/x86_64-linux-gnu/sys/utsname.h"
struct utsname {
   char sysname[65] ;
   char nodename[65] ;
   char release[65] ;
   char version[65] ;
   char machine[65] ;
   char domainname[65] ;
};
#line 72 "/usr/include/x86_64-linux-gnu/bits/sched.h"
struct sched_param {
   int __sched_priority ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/resource.h"
enum __rlimit_resource {
    RLIMIT_CPU = 0,
    RLIMIT_FSIZE = 1,
    RLIMIT_DATA = 2,
    RLIMIT_STACK = 3,
    RLIMIT_CORE = 4,
    __RLIMIT_RSS = 5,
    RLIMIT_NOFILE = 7,
    __RLIMIT_OFILE = 7,
    RLIMIT_AS = 9,
    __RLIMIT_NPROC = 6,
    __RLIMIT_MEMLOCK = 8,
    __RLIMIT_LOCKS = 10,
    __RLIMIT_SIGPENDING = 11,
    __RLIMIT_MSGQUEUE = 12,
    __RLIMIT_NICE = 13,
    __RLIMIT_RTPRIO = 14,
    __RLIMIT_RTTIME = 15,
    __RLIMIT_NLIMITS = 16,
    __RLIM_NLIMITS = 16
} ;
#line 131 "/usr/include/x86_64-linux-gnu/bits/resource.h"
typedef __rlim_t rlim_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/resource.h"
struct rlimit {
   rlim_t rlim_cur ;
   rlim_t rlim_max ;
};
#line 38 "/usr/include/x86_64-linux-gnu/sys/resource.h"
typedef enum __rlimit_resource __rlimit_resource_t;
#line 65 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sourcestats.c"
struct SST_Stats_Record {
   uint32_t refid ;
   IPAddr *ip_addr ;
   int n_samples ;
   int runs_samples ;
   int last_sample ;
   int regression_ok ;
   int best_single_sample ;
   int min_delay_sample ;
   double estimated_offset ;
   double estimated_offset_sd ;
   struct timeval offset_time ;
   int nruns ;
   double estimated_frequency ;
   double skew ;
   SST_Skew_Direction skew_dirn ;
   double variance ;
   struct timeval sample_times[128] ;
   double offsets[128] ;
   double orig_offsets[64] ;
   double peer_delays[64] ;
   double peer_dispersions[64] ;
   double root_delays[64] ;
   double root_dispersions[64] ;
   int strata[64] ;
};
#line 144 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __key_t;
#line 122 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __key_t key_t;
#line 38 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/refclock_shm.c"
struct shmTime {
   int mode ;
   int volatile   count ;
   time_t clockTimeStampSec ;
   int clockTimeStampUSec ;
   time_t receiveTimeStampSec ;
   int receiveTimeStampUSec ;
   int leap ;
   int precision ;
   int nsamples ;
   int volatile   valid ;
   int clockTimeStampNSec ;
   int receiveTimeStampNSec ;
   int dummy[8] ;
};
#line 114 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c"
struct fb_drift {
   double freq ;
   double secs ;
};
#line 90 "/usr/include/x86_64-linux-gnu/sys/socket.h"
struct sockaddr_un;
#line 29 "/usr/include/x86_64-linux-gnu/sys/un.h"
struct sockaddr_un {
   sa_family_t sun_family ;
   char sun_path[108] ;
};
#line 39 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/refclock_sock.c"
struct sock_sample {
   struct timeval tv ;
   double offset ;
   int pulse ;
   int leap ;
   int _pad ;
   int magic ;
};
#line 43 "/usr/include/x86_64-linux-gnu/bits/uio.h"
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
#line 224 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct msghdr {
   void *msg_name ;
   socklen_t msg_namelen ;
   struct iovec *msg_iov ;
   size_t msg_iovlen ;
   void *msg_control ;
   size_t msg_controllen ;
   int msg_flags ;
};
#line 242 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct cmsghdr {
   size_t cmsg_len ;
   int cmsg_level ;
   int cmsg_type ;
   unsigned char __cmsg_data[] ;
};
#line 127 "/usr/include/x86_64-linux-gnu/bits/in.h"
struct in_pktinfo {
   int ipi_ifindex ;
   struct in_addr ipi_spec_dst ;
   struct in_addr ipi_addr ;
};
#line 534 "/usr/include/netinet/in.h"
struct in6_pktinfo {
   struct in6_addr ipi6_addr ;
   unsigned int ipi6_ifindex ;
};
#line 133 "getdate.y"
struct _TABLE {
   char const   *name ;
   int type ;
   int value ;
};
#line 133 "getdate.y"
typedef struct _TABLE TABLE;
#line 143
enum _MERIDIAN {
    MERam = 0,
    MERpm = 1,
    MER24 = 2
} ;
#line 143 "getdate.y"
typedef enum _MERIDIAN MERIDIAN;
#line 300 "getdate.c"
union YYSTYPE {
   int Number ;
   enum _MERIDIAN Meridian ;
};
#line 300 "getdate.c"
typedef union YYSTYPE YYSTYPE;
#line 333 "getdate.c"
typedef unsigned char yytype_uint8;
#line 340 "getdate.c"
typedef signed char yytype_int8;
#line 354 "getdate.c"
typedef short yytype_int16;
#line 485 "getdate.c"
union yyalloc {
   yytype_int16 yyss_alloc ;
   YYSTYPE yyvs_alloc ;
};
#line 33 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys.h"
void SYS_Initialise(void) ;
#line 36
void SYS_Finalise(void) ;
#line 39
void SYS_DropRoot(char *user___0 ) ;
#line 41
void SYS_SetScheduler(int SchedPriority___0 ) ;
#line 42
void SYS_LockMemory(void) ;
#line 81 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/logging.h"
void LOG_Fatal_Function(LOG_Facility facility , char const   *format  , ...) ;
#line 84
void LOG_Position(char const   *filename___0 , int line_number___0 , char const   *function_name ) ;
#line 30 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.h"
void SYS_Linux_Initialise(void) ;
#line 32
void SYS_Linux_Finalise(void) ;
#line 36
void SYS_Linux_MemLockAll(int LockAll___0 ) ;
#line 38
void SYS_Linux_SetScheduler(int SchedPriority___0 ) ;
#line 51 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys.c"
void SYS_Initialise(void) 
{ 


  {
  {
#line 56
  SYS_Linux_Initialise();
  }
#line 71
  return;
}
}
#line 75 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys.c"
void SYS_Finalise(void) 
{ 


  {
  {
#line 80
  SYS_Linux_Finalise();
  }
#line 94
  return;
}
}
#line 98 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys.c"
void SYS_DropRoot(char *user___0 ) 
{ 


  {
  {
#line 103
  LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys.c", 103,
               "SYS_DropRoot");
#line 103
  LOG_Fatal_Function((LOG_Facility )19, "dropping root privileges not supported");
  }
#line 105
  return;
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys.c"
void SYS_SetScheduler(int SchedPriority___0 ) 
{ 


  {
  {
#line 112
  SYS_Linux_SetScheduler(SchedPriority___0);
  }
#line 116
  return;
}
}
#line 120 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys.c"
void SYS_LockMemory(void) 
{ 


  {
  {
#line 123
  SYS_Linux_MemLockAll(1);
  }
#line 127
  return;
}
}
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 38 "/usr/include/malloc.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(unsigned long __size )  __attribute__((__malloc__)) ;
#line 53
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/addrfilt.h"
ADF_AuthTable ADF_CreateTable(void) ;
#line 45
ADF_Status ADF_Allow(ADF_AuthTable table , IPAddr *ip , int subnet_bits ) ;
#line 51
ADF_Status ADF_AllowAll(ADF_AuthTable table , IPAddr *ip , int subnet_bits ) ;
#line 57
ADF_Status ADF_Deny(ADF_AuthTable table , IPAddr *ip , int subnet_bits ) ;
#line 63
ADF_Status ADF_DenyAll(ADF_AuthTable table , IPAddr *ip , int subnet_bits ) ;
#line 68
void ADF_DestroyTable(ADF_AuthTable table ) ;
#line 72
int ADF_IsAllowed(ADF_AuthTable table , IPAddr *ip_addr ) ;
#line 59 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/addrfilt.c"
static void split_ip6(IPAddr *ip , uint32_t *dst ) 
{ 
  int i ;

  {
#line 64
  i = 0;
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
#line 64
    if (! (i < 4)) {
#line 64
      goto while_break;
    }
#line 65
    *(dst + i) = (uint32_t )(((((int )ip->addr.in6[i * 4] << 24) | ((int )ip->addr.in6[i * 4 + 1] << 16)) | ((int )ip->addr.in6[i * 4 + 2] << 8)) | (int )ip->addr.in6[i * 4 + 3]);
#line 64
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 69
  return;
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/addrfilt.c"
__inline static uint32_t get_subnet(uint32_t *addr , unsigned int where ) 
{ 
  int off ;

  {
#line 78
  off = (int )(where / 32U);
#line 79
  where %= 32U;
#line 81
  return ((uint32_t )((unsigned long )(*(addr + off) >> (28U - where)) & ((1UL << 4) - 1UL)));
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/addrfilt.c"
ADF_AuthTable ADF_CreateTable(void) 
{ 
  ADF_AuthTable result ;
  void *tmp ;

  {
  {
#line 90
  tmp = malloc(sizeof(struct ADF_AuthTableInst ));
#line 90
  result = (struct ADF_AuthTableInst *)tmp;
#line 93
  result->base4.state = (State )0;
#line 94
  result->base4.extended = (struct _TableNode *)((void *)0);
#line 95
  result->base6.state = (State )0;
#line 96
  result->base6.extended = (struct _TableNode *)((void *)0);
  }
#line 98
  return (result);
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/addrfilt.c"
static void close_node(TableNode *node ) 
{ 
  int i ;
  TableNode *child_node ;

  {
#line 111
  if ((unsigned long )node->extended != (unsigned long )((void *)0)) {
#line 112
    i = 0;
    {
#line 112
    while (1) {
      while_continue: /* CIL Label */ ;
#line 112
      if (! ((unsigned long )i < 1UL << 4)) {
#line 112
        goto while_break;
      }
      {
#line 113
      child_node = node->extended + i;
#line 114
      close_node(child_node);
#line 112
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 116
    free((void *)node->extended);
#line 117
    node->extended = (struct _TableNode *)((void *)0);
    }
  }
#line 119
  return;
}
}
#line 126 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/addrfilt.c"
static void open_node(TableNode *node ) 
{ 
  int i ;
  TableNode *child_node ;
  void *tmp ;

  {
#line 132
  if ((unsigned long )node->extended == (unsigned long )((void *)0)) {
    {
#line 134
    tmp = malloc((1UL << 4) * sizeof(struct _TableNode ));
#line 134
    node->extended = (struct _TableNode *)tmp;
#line 136
    i = 0;
    }
    {
#line 136
    while (1) {
      while_continue: /* CIL Label */ ;
#line 136
      if (! ((unsigned long )i < 1UL << 4)) {
#line 136
        goto while_break;
      }
#line 137
      child_node = node->extended + i;
#line 138
      child_node->state = (State )2;
#line 139
      child_node->extended = (struct _TableNode *)((void *)0);
#line 136
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 142
  return;
}
}
#line 146 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/addrfilt.c"
static ADF_Status set_subnet(TableNode *start_node , uint32_t *ip , int ip_len , int subnet_bits ,
                             State new_state , int delete_children ) 
{ 
  int bits_to_go ;
  int bits_consumed ;
  uint32_t subnet ;
  TableNode *node ;
  int N ;
  int i ;
  int j ;
  TableNode *this_node ;

  {
#line 158
  bits_consumed = 0;
#line 159
  bits_to_go = subnet_bits;
#line 160
  node = start_node;
#line 162
  if (subnet_bits < 0) {
#line 165
    return ((ADF_Status )1);
  } else
#line 162
  if (subnet_bits > 32 * ip_len) {
#line 165
    return ((ADF_Status )1);
  } else {
#line 169
    if ((bits_to_go & 3) == 0) {
      {
#line 171
      while (1) {
        while_continue: /* CIL Label */ ;
#line 171
        if (! (bits_to_go > 0)) {
#line 171
          goto while_break;
        }
        {
#line 172
        subnet = get_subnet(ip, (unsigned int )bits_consumed);
        }
#line 173
        if (! node->extended) {
          {
#line 174
          open_node(node);
          }
        }
#line 176
        node = node->extended + subnet;
#line 177
        bits_to_go -= 4;
#line 178
        bits_consumed += 4;
      }
      while_break: /* CIL Label */ ;
      }
#line 181
      if (delete_children) {
        {
#line 182
        close_node(node);
        }
      }
#line 184
      node->state = new_state;
    } else {
      {
#line 190
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 190
        if (! (bits_to_go >= 4)) {
#line 190
          goto while_break___0;
        }
        {
#line 191
        subnet = get_subnet(ip, (unsigned int )bits_consumed);
        }
#line 192
        if (! node->extended) {
          {
#line 193
          open_node(node);
          }
        }
#line 195
        node = node->extended + subnet;
#line 196
        bits_to_go -= 4;
#line 197
        bits_consumed += 4;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 201
      N = 1 << (4 - bits_to_go);
#line 202
      subnet = get_subnet(ip, (unsigned int )bits_consumed);
      }
#line 203
      if (! node->extended) {
        {
#line 204
        open_node(node);
        }
      }
#line 207
      i = (int )subnet;
#line 207
      j = 0;
      {
#line 207
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 207
        if (! (j < N)) {
#line 207
          goto while_break___1;
        }
#line 208
        this_node = node->extended + i;
#line 209
        if (delete_children) {
          {
#line 210
          close_node(this_node);
          }
        }
#line 212
        this_node->state = new_state;
#line 207
        i ++;
#line 207
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 216
    return ((ADF_Status )0);
  }
}
}
#line 223 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/addrfilt.c"
static ADF_Status set_subnet_(ADF_AuthTable table , IPAddr *ip_addr , int subnet_bits ,
                              State new_state , int delete_children ) 
{ 
  uint32_t ip6[4] ;
  ADF_Status tmp ;
  ADF_Status tmp___0 ;
  ADF_Status tmp___1 ;
  ADF_Status tmp___2 ;

  {
  {
#line 233
  if ((int )ip_addr->family == 1) {
#line 233
    goto case_1;
  }
#line 235
  if ((int )ip_addr->family == 2) {
#line 235
    goto case_2;
  }
#line 238
  if ((int )ip_addr->family == 0) {
#line 238
    goto case_0;
  }
#line 232
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 234
  tmp = set_subnet(& table->base4, & ip_addr->addr.in4, 1, subnet_bits, new_state,
                   delete_children);
  }
#line 234
  return (tmp);
  case_2: /* CIL Label */ 
  {
#line 236
  split_ip6(ip_addr, ip6);
#line 237
  tmp___0 = set_subnet(& table->base6, ip6, 4, subnet_bits, new_state, delete_children);
  }
#line 237
  return (tmp___0);
  case_0: /* CIL Label */ 
#line 240
  if (subnet_bits != 0) {
#line 241
    return ((ADF_Status )1);
  }
  {
#line 242
  memset((void *)(ip6), 0, sizeof(ip6));
#line 243
  tmp___1 = set_subnet(& table->base4, ip6, 1, 0, new_state, delete_children);
  }
#line 243
  if ((unsigned int )tmp___1 == 0U) {
    {
#line 243
    tmp___2 = set_subnet(& table->base6, ip6, 4, 0, new_state, delete_children);
    }
#line 243
    if ((unsigned int )tmp___2 == 0U) {
#line 245
      return ((ADF_Status )0);
    }
  }
#line 246
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 249
  return ((ADF_Status )1);
}
}
#line 252 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/addrfilt.c"
ADF_Status ADF_Allow(ADF_AuthTable table , IPAddr *ip , int subnet_bits ) 
{ 
  ADF_Status tmp ;

  {
  {
#line 257
  tmp = set_subnet_(table, ip, subnet_bits, (State )1, 0);
  }
#line 257
  return (tmp);
}
}
#line 263 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/addrfilt.c"
ADF_Status ADF_AllowAll(ADF_AuthTable table , IPAddr *ip , int subnet_bits ) 
{ 
  ADF_Status tmp ;

  {
  {
#line 268
  tmp = set_subnet_(table, ip, subnet_bits, (State )1, 1);
  }
#line 268
  return (tmp);
}
}
#line 273 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/addrfilt.c"
ADF_Status ADF_Deny(ADF_AuthTable table , IPAddr *ip , int subnet_bits ) 
{ 
  ADF_Status tmp ;

  {
  {
#line 278
  tmp = set_subnet_(table, ip, subnet_bits, (State )0, 0);
  }
#line 278
  return (tmp);
}
}
#line 283 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/addrfilt.c"
ADF_Status ADF_DenyAll(ADF_AuthTable table , IPAddr *ip , int subnet_bits ) 
{ 
  ADF_Status tmp ;

  {
  {
#line 288
  tmp = set_subnet_(table, ip, subnet_bits, (State )0, 1);
  }
#line 288
  return (tmp);
}
}
#line 293 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/addrfilt.c"
void ADF_DestroyTable(ADF_AuthTable table ) 
{ 


  {
  {
#line 296
  close_node(& table->base4);
#line 297
  close_node(& table->base6);
#line 298
  free((void *)table);
  }
#line 299
  return;
}
}
#line 303 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/addrfilt.c"
static int check_ip_in_node(TableNode *start_node , uint32_t *ip ) 
{ 
  uint32_t subnet ;
  int bits_consumed ;
  int result ;
  int finished ;
  TableNode *node ;
  State state ;

  {
#line 307
  bits_consumed = 0;
#line 308
  result = 0;
#line 309
  finished = 0;
#line 311
  state = (State )0;
#line 313
  node = start_node;
  {
#line 315
  while (1) {
    while_continue: /* CIL Label */ ;
#line 316
    if ((unsigned int )node->state != 2U) {
#line 317
      state = node->state;
    }
#line 319
    if (node->extended) {
      {
#line 320
      subnet = get_subnet(ip, (unsigned int )bits_consumed);
#line 321
      node = node->extended + subnet;
#line 322
      bits_consumed += 4;
      }
    } else {
#line 325
      finished = 1;
    }
#line 315
    if (! (! finished)) {
#line 315
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 330
  if ((unsigned int )state == 1U) {
#line 330
    goto case_1;
  }
#line 333
  if ((unsigned int )state == 0U) {
#line 333
    goto case_0;
  }
#line 336
  if ((unsigned int )state == 2U) {
#line 336
    goto case_2;
  }
#line 329
  goto switch_break;
  case_1: /* CIL Label */ 
#line 331
  result = 1;
#line 332
  goto switch_break;
  case_0: /* CIL Label */ 
#line 334
  result = 0;
#line 335
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 337
  __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/addrfilt.c",
                337U, "check_ip_in_node");
  }
#line 338
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 341
  return (result);
}
}
#line 347 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/addrfilt.c"
int ADF_IsAllowed(ADF_AuthTable table , IPAddr *ip_addr ) 
{ 
  uint32_t ip6[4] ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 354
  if ((int )ip_addr->family == 1) {
#line 354
    goto case_1;
  }
#line 356
  if ((int )ip_addr->family == 2) {
#line 356
    goto case_2;
  }
#line 353
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 355
  tmp = check_ip_in_node(& table->base4, & ip_addr->addr.in4);
  }
#line 355
  return (tmp);
  case_2: /* CIL Label */ 
  {
#line 357
  split_ip6(ip_addr, ip6);
#line 358
  tmp___0 = check_ip_in_node(& table->base6, ip6);
  }
#line 358
  return (tmp___0);
  switch_break: /* CIL Label */ ;
  }
#line 361
  return (0);
}
}
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 425
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 417
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pipe)(int *__pipedes ) ;
#line 497
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 667
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) setsid)(void) ;
#line 671
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getsid)(__pid_t __pid ) ;
#line 675
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 31 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/main.h"
void MAI_CleanupAndExit(void) ;
#line 48 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sched.h"
void SCH_Initialise(void) ;
#line 51
void SCH_Finalise(void) ;
#line 81
void SCH_MainLoop(void) ;
#line 83
void SCH_QuitProgram(void) ;
#line 177 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/local.h"
void LCL_Initialise(void) ;
#line 181
void LCL_Finalise(void) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_io.h"
void NIO_Initialise(int family ) ;
#line 38
void NIO_Finalise(void) ;
#line 44 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sources.h"
void SRC_Initialise(void) ;
#line 47
void SRC_Finalise(void) ;
#line 159
void SRC_DumpSources(void) ;
#line 161
void SRC_ReloadSources(void) ;
#line 46 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_core.h"
void NCR_Initialise(void) ;
#line 47
void NCR_Finalise(void) ;
#line 67 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_sources.h"
void NSR_Initialise(void) ;
#line 70
void NSR_Finalise(void) ;
#line 37 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sourcestats.h"
void SST_Initialise(void) ;
#line 38
void SST_Finalise(void) ;
#line 38 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.h"
void REF_Initialise(void) ;
#line 41
void REF_Finalise(void) ;
#line 72 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/logging.h"
void LOG_Initialise(void) ;
#line 75
void LOG_Finalise(void) ;
#line 78
void LOG_Line_Function(LOG_Severity severity , LOG_Facility facility , char const   *format 
                       , ...) ;
#line 87
void LOG_OpenSystemLog(void) ;
#line 90
void LOG_SetParentFd(int fd___0 ) ;
#line 93
void LOG_CloseParentFd(void) ;
#line 115
void LOG_CreateLogFileDir(void) ;
#line 32 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.h"
void CNF_SetRestarted(int r ) ;
#line 36
void CNF_ReadFile(char const   *filename___0 ) ;
#line 38
void CNF_AddSources(void) ;
#line 39
void CNF_AddBroadcasts(void) ;
#line 42
void CNF_ProcessInitStepSlew(void (*after_hook)(void * ) , void *anything ) ;
#line 60
int CNF_GetDumpOnExit(void) ;
#line 74
char *CNF_GetPidFile(void) ;
#line 90
void CNF_SetupAccessRestrictions(void) ;
#line 92
int CNF_GetSchedPriority(void) ;
#line 93
int CNF_GetLockMemory(void) ;
#line 97
char *CNF_GetUser(void) ;
#line 32 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.h"
void CAM_Initialise(int family ) ;
#line 34
void CAM_Finalise(void) ;
#line 30 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/keys.h"
void KEY_Initialise(void) ;
#line 31
void KEY_Finalise(void) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/acquire.h"
void ACQ_Initialise(void) ;
#line 36
void ACQ_Finalise(void) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/manual.h"
void MNL_Initialise(void) ;
#line 35
void MNL_Finalise(void) ;
#line 31 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc.h"
void RTC_Initialise(void) ;
#line 32
void RTC_Finalise(void) ;
#line 33
void RTC_TimePreInit(void) ;
#line 34
void RTC_TimeInit(void (*after_hook)(void * ) , void *anything ) ;
#line 35
void RTC_StartMeasurements(void) ;
#line 57 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/refclock.h"
void RCL_Initialise(void) ;
#line 58
void RCL_Finalise(void) ;
#line 60
void RCL_StartRefclocks(void) ;
#line 37 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/clientlog.h"
void CLG_Initialise(void) ;
#line 38
void CLG_Finalise(void) ;
#line 32 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/broadcast.h"
void BRD_Initialise(void) ;
#line 33
void BRD_Finalise(void) ;
#line 40 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/nameserv.h"
void DNS_SetAddressFamily(int family ) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/tempcomp.h"
void TMC_Initialise(void) ;
#line 29
void TMC_Finalise(void) ;
#line 61 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/main.c"
static int initialised  =    0;
#line 65 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/main.c"
static int reload  =    0;
#line 69 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/main.c"
static void delete_pidfile(void) 
{ 
  char const   *pidfile___0 ;
  char *tmp ;

  {
  {
#line 72
  tmp = CNF_GetPidFile();
#line 72
  pidfile___0 = (char const   *)tmp;
#line 74
  unlink(pidfile___0);
  }
#line 75
  return;
}
}
#line 79 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/main.c"
void MAI_CleanupAndExit(void) 
{ 
  int tmp ;

  {
#line 82
  if (! initialised) {
    {
#line 82
    exit(0);
    }
  }
  {
#line 84
  tmp = CNF_GetDumpOnExit();
  }
#line 84
  if (tmp) {
    {
#line 85
    SRC_DumpSources();
    }
  }
  {
#line 88
  TMC_Finalise();
#line 89
  MNL_Finalise();
#line 90
  ACQ_Finalise();
#line 91
  CLG_Finalise();
#line 92
  NSR_Finalise();
#line 93
  NCR_Finalise();
#line 94
  BRD_Finalise();
#line 95
  SST_Finalise();
#line 96
  REF_Finalise();
#line 97
  KEY_Finalise();
#line 98
  RCL_Finalise();
#line 99
  SRC_Finalise();
#line 100
  RTC_Finalise();
#line 101
  CAM_Finalise();
#line 102
  NIO_Finalise();
#line 103
  SYS_Finalise();
#line 104
  SCH_Finalise();
#line 105
  LCL_Finalise();
#line 107
  delete_pidfile();
#line 109
  LOG_Finalise();
#line 111
  exit(0);
  }
}
}
#line 116 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/main.c"
static void signal_cleanup(int x ) 
{ 


  {
#line 119
  if (! initialised) {
    {
#line 119
    exit(0);
    }
  }
  {
#line 120
  SCH_QuitProgram();
  }
#line 121
  return;
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/main.c"
static void post_acquire_hook(void *anything ) 
{ 


  {
  {
#line 129
  LOG_CloseParentFd();
#line 131
  CNF_AddSources();
#line 132
  CNF_AddBroadcasts();
  }
#line 133
  if (reload) {
    {
#line 138
    SRC_ReloadSources();
    }
  }
  {
#line 140
  CNF_SetupAccessRestrictions();
#line 142
  RTC_StartMeasurements();
#line 143
  RCL_StartRefclocks();
  }
#line 144
  return;
}
}
#line 148 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/main.c"
static void post_init_rtc_hook(void *anything ) 
{ 


  {
  {
#line 151
  CNF_ProcessInitStepSlew(& post_acquire_hook, (void *)0);
  }
#line 152
  return;
}
}
#line 157 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/main.c"
static int does_process_exist(int pid ) 
{ 
  int status___0 ;

  {
  {
#line 161
  status___0 = getsid(pid);
  }
#line 162
  if (status___0 >= 0) {
#line 163
    return (1);
  } else {
#line 165
    return (0);
  }
}
}
#line 171 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/main.c"
static int maybe_another_chronyd_running(int *other_pid ) 
{ 
  char const   *pidfile___0 ;
  char *tmp ;
  FILE *in ;
  int pid ;
  int count ;
  int tmp___0 ;

  {
  {
#line 174
  tmp = CNF_GetPidFile();
#line 174
  pidfile___0 = (char const   *)tmp;
#line 178
  *other_pid = 0;
#line 180
  in = fopen((char const   */* __restrict  */)pidfile___0, (char const   */* __restrict  */)"r");
  }
#line 181
  if (! in) {
#line 181
    return (0);
  }
  {
#line 183
  count = fscanf((FILE */* __restrict  */)in, (char const   */* __restrict  */)"%d",
                 & pid);
#line 184
  fclose(in);
  }
#line 186
  if (count != 1) {
#line 186
    return (0);
  }
  {
#line 188
  *other_pid = pid;
#line 189
  tmp___0 = does_process_exist(pid);
  }
#line 189
  return (tmp___0);
}
}
#line 195 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/main.c"
static void write_lockfile(void) 
{ 
  char const   *pidfile___0 ;
  char *tmp ;
  FILE *out ;
  __pid_t tmp___0 ;

  {
  {
#line 198
  tmp = CNF_GetPidFile();
#line 198
  pidfile___0 = (char const   *)tmp;
#line 201
  out = fopen((char const   */* __restrict  */)pidfile___0, (char const   */* __restrict  */)"w");
  }
#line 202
  if (! out) {
    {
#line 203
    LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/main.c", 203,
                 "write_lockfile");
#line 203
    LOG_Line_Function((LOG_Severity )2, (LOG_Facility )9, "could not open lockfile %s for writing",
                      pidfile___0);
    }
  } else {
    {
#line 205
    tmp___0 = getpid();
#line 205
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%d\n",
            tmp___0);
#line 206
    fclose(out);
    }
  }
#line 208
  return;
}
}
#line 212 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/main.c"
static void go_daemon(void) 
{ 
  int pid ;
  int fd___0 ;
  int pipefd[2] ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char message[1024] ;
  int r ;
  ssize_t tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;

  {
  {
#line 224
  tmp___1 = pipe((int *)(pipefd));
  }
#line 224
  if (tmp___1) {
    {
#line 225
    LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/main.c", 225,
                 "go_daemon");
#line 225
    tmp = __errno_location();
#line 225
    tmp___0 = strerror(*tmp);
#line 225
    LOG_Line_Function((LOG_Severity )2, (LOG_Facility )16, "Could not detach, pipe failed : %s",
                      tmp___0);
    }
  }
  {
#line 229
  pid = fork();
  }
#line 231
  if (pid < 0) {
    {
#line 232
    LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/main.c", 232,
                 "go_daemon");
#line 232
    tmp___2 = __errno_location();
#line 232
    tmp___3 = strerror(*tmp___2);
#line 232
    LOG_Line_Function((LOG_Severity )2, (LOG_Facility )16, "Could not detach, fork failed : %s",
                      tmp___3);
    }
  } else
#line 233
  if (pid > 0) {
    {
#line 238
    close(pipefd[1]);
#line 239
    tmp___4 = read(pipefd[0], (void *)(message), sizeof(message));
#line 239
    r = (int )tmp___4;
    }
#line 240
    if (r) {
#line 241
      if (r > 0) {
        {
#line 243
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%.1024s\n",
                message);
        }
      }
      {
#line 245
      exit(1);
      }
    } else {
      {
#line 247
      exit(0);
      }
    }
  } else {
    {
#line 249
    close(pipefd[0]);
#line 251
    setsid();
#line 254
    pid = fork();
    }
#line 256
    if (pid < 0) {
      {
#line 257
      LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/main.c",
                   257, "go_daemon");
#line 257
      tmp___5 = __errno_location();
#line 257
      tmp___6 = strerror(*tmp___5);
#line 257
      LOG_Line_Function((LOG_Severity )2, (LOG_Facility )16, "Could not detach, fork failed : %s",
                        tmp___6);
      }
    } else
#line 258
    if (pid > 0) {
      {
#line 259
      exit(0);
      }
    } else {
      {
#line 264
      tmp___9 = chdir("/");
      }
#line 264
      if (tmp___9 < 0) {
        {
#line 265
        LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/main.c",
                     265, "go_daemon");
#line 265
        tmp___7 = __errno_location();
#line 265
        tmp___8 = strerror(*tmp___7);
#line 265
        LOG_Line_Function((LOG_Severity )2, (LOG_Facility )16, "Could not chdir to / : %s",
                          tmp___8);
        }
      }
#line 270
      fd___0 = 0;
      {
#line 270
      while (1) {
        while_continue: /* CIL Label */ ;
#line 270
        if (! (fd___0 < 1024)) {
#line 270
          goto while_break;
        }
#line 271
        if (fd___0 != pipefd[1]) {
          {
#line 272
          close(fd___0);
          }
        }
#line 270
        fd___0 ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 275
      LOG_SetParentFd(pipefd[1]);
      }
    }
  }
#line 280
  return;
}
}
#line 284 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/main.c"
int main(int argc , char **argv ) 
{ 
  char const   *conf_file ;
  char *user___0 ;
  int debug ;
  int nofork ;
  int address_family___1 ;
  int do_init_rtc ;
  int restarted___0 ;
  int other_pid ;
  int lock_memory___0 ;
  int sched_priority___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  __uid_t tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;

  {
  {
#line 287
  conf_file = "/etc/chrony.conf";
#line 288
  user___0 = (char *)((void *)0);
#line 289
  debug = 0;
#line 289
  nofork = 0;
#line 289
  address_family___1 = 0;
#line 290
  do_init_rtc = 0;
#line 290
  restarted___0 = 0;
#line 292
  lock_memory___0 = 0;
#line 292
  sched_priority___0 = 0;
#line 294
  LOG_Initialise();
  }
  {
#line 297
  while (1) {
    while_continue: /* CIL Label */ ;
#line 297
    argv ++;
#line 297
    argc --;
#line 297
    if (! (argc > 0)) {
#line 297
      goto while_break;
    }
    {
#line 299
    tmp___12 = strcmp("-f", (char const   *)*argv);
    }
#line 299
    if (tmp___12) {
      {
#line 302
      tmp___11 = strcmp("-P", (char const   *)*argv);
      }
#line 302
      if (tmp___11) {
        {
#line 307
        tmp___10 = strcmp("-m", (char const   *)*argv);
        }
#line 307
        if (tmp___10) {
          {
#line 309
          tmp___9 = strcmp("-r", (char const   *)*argv);
          }
#line 309
          if (tmp___9) {
            {
#line 311
            tmp___8 = strcmp("-R", (char const   *)*argv);
            }
#line 311
            if (tmp___8) {
              {
#line 313
              tmp___7 = strcmp("-u", (char const   *)*argv);
              }
#line 313
              if (tmp___7) {
                {
#line 320
                tmp___6 = strcmp("-s", (char const   *)*argv);
                }
#line 320
                if (tmp___6) {
                  {
#line 322
                  tmp___4 = strcmp("-v", (char const   *)*argv);
                  }
#line 322
                  if (tmp___4) {
                    {
#line 322
                    tmp___5 = strcmp("--version", (char const   *)*argv);
                    }
#line 322
                    if (tmp___5) {
                      {
#line 326
                      tmp___3 = strcmp("-n", (char const   *)*argv);
                      }
#line 326
                      if (tmp___3) {
                        {
#line 328
                        tmp___2 = strcmp("-d", (char const   *)*argv);
                        }
#line 328
                        if (tmp___2) {
                          {
#line 331
                          tmp___1 = strcmp("-4", (char const   *)*argv);
                          }
#line 331
                          if (tmp___1) {
                            {
#line 333
                            tmp___0 = strcmp("-6", (char const   *)*argv);
                            }
#line 333
                            if (tmp___0) {
                              {
#line 336
                              LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/main.c",
                                           336, "main");
#line 336
                              LOG_Fatal_Function((LOG_Facility )9, "Unrecognized command line option [%s]",
                                                 *argv);
                              }
                            } else {
#line 334
                              address_family___1 = 2;
                            }
                          } else {
#line 332
                            address_family___1 = 1;
                          }
                        } else {
#line 329
                          debug = 1;
#line 330
                          nofork = 1;
                        }
                      } else {
#line 327
                        nofork = 1;
                      }
                    } else {
                      {
#line 324
                      printf((char const   */* __restrict  */)"chronyd (chrony) version %s\n",
                             "1.29");
#line 325
                      exit(0);
                      }
                    }
                  } else {
                    {
#line 324
                    printf((char const   */* __restrict  */)"chronyd (chrony) version %s\n",
                           "1.29");
#line 325
                    exit(0);
                    }
                  }
                } else {
#line 321
                  do_init_rtc = 1;
                }
              } else {
#line 314
                argv ++;
#line 314
                argc --;
#line 315
                if (argc == 0) {
                  {
#line 316
                  LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/main.c",
                               316, "main");
#line 316
                  LOG_Fatal_Function((LOG_Facility )9, "Missing user name");
                  }
                } else {
#line 318
                  user___0 = *argv;
                }
              }
            } else {
#line 312
              restarted___0 = 1;
            }
          } else {
#line 310
            reload = 1;
          }
        } else {
#line 308
          lock_memory___0 = 1;
        }
      } else {
#line 303
        argv ++;
#line 303
        argc --;
#line 304
        if (argc == 0) {
          {
#line 305
          LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/main.c",
                       305, "main");
#line 305
          LOG_Fatal_Function((LOG_Facility )9, "Bad scheduler priority");
          }
        } else {
          {
#line 304
          tmp = sscanf((char const   */* __restrict  */)*argv, (char const   */* __restrict  */)"%d",
                       & sched_priority___0);
          }
#line 304
          if (tmp != 1) {
            {
#line 305
            LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/main.c",
                         305, "main");
#line 305
            LOG_Fatal_Function((LOG_Facility )9, "Bad scheduler priority");
            }
          }
        }
      }
    } else {
#line 300
      argv ++;
#line 300
      argc --;
#line 301
      conf_file = (char const   *)*argv;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 340
  tmp___13 = getuid();
  }
#line 340
  if (tmp___13 != 0U) {
    {
#line 342
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Not superuser\n");
#line 343
    exit(1);
    }
  }
#line 347
  if (! nofork) {
    {
#line 348
    go_daemon();
    }
  }
#line 351
  if (! debug) {
    {
#line 352
    LOG_OpenSystemLog();
    }
  }
  {
#line 355
  LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/main.c", 355,
               "main");
#line 355
  LOG_Line_Function((LOG_Severity )0, (LOG_Facility )9, "chronyd version %s starting",
                    "1.29");
#line 357
  DNS_SetAddressFamily(address_family___1);
#line 359
  CNF_SetRestarted(restarted___0);
#line 360
  CNF_ReadFile(conf_file);
#line 365
  tmp___15 = maybe_another_chronyd_running(& other_pid);
  }
#line 365
  if (tmp___15) {
    {
#line 366
    LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/main.c", 366,
                 "main");
#line 366
    tmp___14 = CNF_GetPidFile();
#line 366
    LOG_Fatal_Function((LOG_Facility )9, "Another chronyd may already be running (pid=%d), check lockfile (%s)",
                       other_pid, tmp___14);
    }
  }
  {
#line 372
  write_lockfile();
  }
#line 374
  if (do_init_rtc) {
    {
#line 375
    RTC_TimePreInit();
    }
  }
  {
#line 378
  LCL_Initialise();
#line 379
  SCH_Initialise();
#line 380
  SYS_Initialise();
#line 381
  NIO_Initialise(address_family___1);
#line 382
  CAM_Initialise(address_family___1);
#line 383
  RTC_Initialise();
#line 384
  SRC_Initialise();
#line 385
  RCL_Initialise();
#line 386
  KEY_Initialise();
  }
#line 389
  if (! sched_priority___0) {
    {
#line 390
    sched_priority___0 = CNF_GetSchedPriority();
    }
  }
#line 392
  if (sched_priority___0) {
    {
#line 393
    SYS_SetScheduler(sched_priority___0);
    }
  }
#line 396
  if (lock_memory___0) {
    {
#line 397
    SYS_LockMemory();
    }
  } else {
    {
#line 396
    tmp___16 = CNF_GetLockMemory();
    }
#line 396
    if (tmp___16) {
      {
#line 397
      SYS_LockMemory();
      }
    }
  }
#line 400
  if (! user___0) {
    {
#line 401
    user___0 = CNF_GetUser();
    }
  }
#line 403
  if (user___0) {
    {
#line 404
    SYS_DropRoot(user___0);
    }
  }
  {
#line 407
  LOG_CreateLogFileDir();
#line 409
  REF_Initialise();
#line 410
  SST_Initialise();
#line 411
  BRD_Initialise();
#line 412
  NCR_Initialise();
#line 413
  NSR_Initialise();
#line 414
  CLG_Initialise();
#line 415
  ACQ_Initialise();
#line 416
  MNL_Initialise();
#line 417
  TMC_Initialise();
#line 420
  initialised = 1;
  }
#line 422
  if (do_init_rtc) {
    {
#line 423
    RTC_TimeInit(& post_init_rtc_hook, (void *)0);
    }
  } else {
    {
#line 425
    post_init_rtc_hook((void *)0);
    }
  }
  {
#line 428
  signal(2, & signal_cleanup);
#line 429
  signal(15, & signal_cleanup);
#line 431
  signal(3, & signal_cleanup);
#line 432
  signal(1, & signal_cleanup);
#line 437
  SCH_MainLoop();
#line 439
  LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/main.c", 439,
               "main");
#line 439
  LOG_Line_Function((LOG_Severity )0, (LOG_Facility )9, "chronyd exiting");
#line 441
  MAI_CleanupAndExit();
  }
#line 443
  return (0);
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/chrony_timex.h"
extern int adjtimex(struct timex * ) ;
#line 67 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/wrap_adjtimex.h"
int TMX_SetTick(long tick ) ;
#line 68
int TMX_ApplyOffset(long *offset ) ;
#line 69
int TMX_SetFrequency(double *freq , long tick ) ;
#line 70
int TMX_GetFrequency(double *freq , long *tick ) ;
#line 71
int TMX_GetOffsetLeft(long *offset ) ;
#line 72
int TMX_ReadCurrentParams(struct tmx_params *params ) ;
#line 73
int TMX_SetLeap(int leap ) ;
#line 74
int TMX_SetSync(int sync ) ;
#line 75
int TMX_EnableNanoPLL(void) ;
#line 76
int TMX_ApplyPLLOffset(long offset , long constant ) ;
#line 77
int TMX_GetPLLOffsetLeft(long *offset ) ;
#line 78
int TMX_TestStepOffset(void) ;
#line 79
int TMX_ApplyStepOffset(double offset ) ;
#line 37 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/wrap_adjtimex.c"
static int status  =    0;
#line 39 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/wrap_adjtimex.c"
int TMX_SetTick(long tick ) 
{ 
  struct timex txc ;
  int tmp ;

  {
  {
#line 43
  txc.modes = 16384U;
#line 44
  txc.tick = tick;
#line 46
  tmp = adjtimex(& txc);
  }
#line 46
  return (tmp);
}
}
#line 49 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/wrap_adjtimex.c"
int TMX_ApplyOffset(long *offset ) 
{ 
  struct timex txc ;
  int result ;

  {
  {
#line 55
  txc.modes = 32769U;
#line 56
  txc.offset = *offset;
#line 57
  result = adjtimex(& txc);
#line 58
  *offset = txc.offset;
  }
#line 59
  return (result);
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/wrap_adjtimex.c"
int TMX_SetFrequency(double *freq , long tick ) 
{ 
  struct timex txc ;
  int tmp ;

  {
#line 67
  txc.modes = 16402U;
#line 69
  txc.freq = (long )(*freq * (double )(1 << 16));
#line 70
  *freq = (double )txc.freq / (double )(1 << 16);
#line 71
  txc.tick = tick;
#line 72
  txc.status = status;
#line 74
  if (! (status & 64)) {
#line 77
    txc.modes |= 4U;
#line 78
    txc.maxerror = 0L;
  }
  {
#line 81
  tmp = adjtimex(& txc);
  }
#line 81
  return (tmp);
}
}
#line 84 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/wrap_adjtimex.c"
int TMX_GetFrequency(double *freq , long *tick ) 
{ 
  struct timex txc ;
  int result ;

  {
  {
#line 89
  txc.modes = 0U;
#line 90
  result = adjtimex(& txc);
#line 91
  *freq = (double )txc.freq / (double )(1 << 16);
#line 92
  *tick = txc.tick;
  }
#line 93
  return (result);
}
}
#line 96 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/wrap_adjtimex.c"
int TMX_GetOffsetLeft(long *offset ) 
{ 
  struct timex txc ;
  int result ;

  {
  {
#line 101
  txc.modes = 40961U;
#line 102
  result = adjtimex(& txc);
#line 103
  *offset = txc.offset;
  }
#line 104
  return (result);
}
}
#line 107 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/wrap_adjtimex.c"
int TMX_ReadCurrentParams(struct tmx_params *params ) 
{ 
  struct timex txc ;
  int result ;

  {
  {
#line 113
  txc.modes = 0U;
#line 114
  result = adjtimex(& txc);
#line 116
  params->tick = txc.tick;
#line 117
  params->offset = txc.offset;
#line 118
  params->freq = txc.freq;
#line 119
  params->dfreq = (double )txc.freq / (double )(1 << 16);
#line 120
  params->maxerror = txc.maxerror;
#line 121
  params->esterror = txc.esterror;
#line 123
  params->sta_pll = (unsigned int )(! (! (txc.status & 1)));
#line 124
  params->sta_ppsfreq = (unsigned int )(! (! (txc.status & 2)));
#line 125
  params->sta_ppstime = (unsigned int )(! (! (txc.status & 4)));
#line 126
  params->sta_fll = (unsigned int )(! (! (txc.status & 8)));
#line 127
  params->sta_ins = (unsigned int )(! (! (txc.status & 16)));
#line 128
  params->sta_del = (unsigned int )(! (! (txc.status & 32)));
#line 129
  params->sta_unsync = (unsigned int )(! (! (txc.status & 64)));
#line 130
  params->sta_freqhold = (unsigned int )(! (! (txc.status & 128)));
#line 131
  params->sta_ppssignal = (unsigned int )(! (! (txc.status & 256)));
#line 132
  params->sta_ppsjitter = (unsigned int )(! (! (txc.status & 512)));
#line 133
  params->sta_ppswander = (unsigned int )(! (! (txc.status & 1024)));
#line 134
  params->sta_ppserror = (unsigned int )(! (! (txc.status & 2048)));
#line 135
  params->sta_clockerr = (unsigned int )(! (! (txc.status & 4096)));
#line 137
  params->constant = txc.constant;
#line 138
  params->precision = txc.precision;
#line 139
  params->tolerance = txc.tolerance;
#line 140
  params->ppsfreq = txc.ppsfreq;
#line 141
  params->jitter = txc.jitter;
#line 142
  params->shift = txc.shift;
#line 143
  params->stabil = txc.stabil;
#line 144
  params->jitcnt = txc.jitcnt;
#line 145
  params->calcnt = txc.calcnt;
#line 146
  params->errcnt = txc.errcnt;
#line 147
  params->stbcnt = txc.stbcnt;
  }
#line 149
  return (result);
}
}
#line 152 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/wrap_adjtimex.c"
int TMX_SetLeap(int leap ) 
{ 
  struct timex txc ;
  int tmp ;

  {
#line 157
  status &= -49;
#line 159
  if (leap > 0) {
#line 160
    status |= 16;
  } else
#line 161
  if (leap < 0) {
#line 162
    status |= 32;
  }
  {
#line 165
  txc.modes = 16U;
#line 166
  txc.status = status;
#line 168
  tmp = adjtimex(& txc);
  }
#line 168
  return (tmp);
}
}
#line 171 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/wrap_adjtimex.c"
int TMX_SetSync(int sync ) 
{ 
  struct timex txc ;
  int tmp ;

  {
#line 175
  if (sync) {
#line 176
    status &= -65;
  } else {
#line 178
    status |= 64;
  }
  {
#line 181
  txc.modes = 16U;
#line 182
  txc.status = status;
#line 184
  tmp = adjtimex(& txc);
  }
#line 184
  return (tmp);
}
}
#line 187 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/wrap_adjtimex.c"
int TMX_EnableNanoPLL(void) 
{ 
  struct timex txc ;
  int result ;

  {
  {
#line 193
  txc.modes = 8241U;
#line 194
  txc.status = 129;
#line 195
  txc.offset = 0L;
#line 196
  txc.constant = 0L;
#line 197
  result = adjtimex(& txc);
  }
#line 198
  if (result < 0) {
#line 199
    return (-1);
  } else
#line 198
  if (! (txc.status & 8192)) {
#line 199
    return (-1);
  } else
#line 198
  if (txc.offset) {
#line 199
    return (-1);
  } else
#line 198
  if (txc.constant) {
#line 199
    return (-1);
  }
#line 201
  status |= 129;
#line 202
  return (result);
}
}
#line 205 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/wrap_adjtimex.c"
int TMX_ApplyPLLOffset(long offset , long constant ) 
{ 
  struct timex txc ;
  int tmp ;

  {
  {
#line 210
  txc.modes = 8225U;
#line 211
  txc.offset = offset;
#line 212
  txc.constant = constant;
#line 213
  tmp = adjtimex(& txc);
  }
#line 213
  return (tmp);
}
}
#line 216 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/wrap_adjtimex.c"
int TMX_GetPLLOffsetLeft(long *offset ) 
{ 
  struct timex txc ;
  int result ;

  {
  {
#line 222
  txc.modes = 0U;
#line 223
  result = adjtimex(& txc);
#line 224
  *offset = txc.offset;
  }
#line 225
  return (result);
}
}
#line 228 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/wrap_adjtimex.c"
int TMX_TestStepOffset(void) 
{ 
  struct timex txc ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 238
  txc.modes = 4U;
#line 239
  txc.maxerror = 0L;
#line 240
  tmp = adjtimex(& txc);
  }
#line 240
  if (tmp < 0) {
#line 241
    return (-1);
  } else
#line 240
  if (txc.maxerror != 0L) {
#line 241
    return (-1);
  }
  {
#line 243
  txc.modes = 256U;
#line 244
  txc.time.tv_sec = (__time_t )0;
#line 245
  txc.time.tv_usec = (__suseconds_t )0;
#line 246
  tmp___0 = adjtimex(& txc);
  }
#line 246
  if (tmp___0 < 0) {
#line 247
    return (-1);
  } else
#line 246
  if (txc.maxerror < 100000L) {
#line 247
    return (-1);
  }
#line 249
  return (0);
}
}
#line 252 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/wrap_adjtimex.c"
int TMX_ApplyStepOffset(double offset ) 
{ 
  struct timex txc ;
  int tmp ;

  {
#line 257
  txc.modes = 256U;
#line 258
  if (offset >= (double )0) {
#line 259
    txc.time.tv_sec = (__time_t )offset;
  } else {
#line 261
    txc.time.tv_sec = (__time_t )(offset - (double )1);
  }
#line 266
  if (status & 1) {
#line 267
    txc.modes |= 8192U;
#line 268
    txc.time.tv_usec = (__suseconds_t )(1e9 * (offset - (double )txc.time.tv_sec));
  } else {
#line 270
    txc.time.tv_usec = (__suseconds_t )(1e6 * (offset - (double )txc.time.tv_sec));
  }
  {
#line 273
  tmp = adjtimex(& txc);
  }
#line 273
  return (tmp);
}
}
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 176 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 56 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdparse.h"
CPS_Status CPS_ParseNTPSourceAdd(char *line___0 , CPS_NTP_Source *src ) ;
#line 59
void CPS_NormalizeLine(char *line___0 ) ;
#line 62
char *CPS_SplitWord(char *line___0 ) ;
#line 65
int CPS_ParseKey(char *line___0 , unsigned long *id , char const   **hash , char **key ) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdparse.c"
CPS_Status CPS_ParseNTPSourceAdd(char *line___0 , CPS_NTP_Source *src ) 
{ 
  char *hostname ;
  char *cmd ;
  int ok ;
  int n ;
  int done ;
  CPS_Status result ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;

  {
  {
#line 48
  src->port = (unsigned short)123;
#line 49
  src->params.minpoll = 6;
#line 50
  src->params.maxpoll = 10;
#line 51
  src->params.presend_minpoll = 0;
#line 52
  src->params.authkey = 0UL;
#line 53
  src->params.max_delay = 16.0;
#line 54
  src->params.max_delay_ratio = 0.0;
#line 55
  src->params.max_delay_dev_ratio = 10.0;
#line 56
  src->params.online = 1;
#line 57
  src->params.auto_offline = 0;
#line 58
  src->params.iburst = 0;
#line 59
  src->params.min_stratum = 0;
#line 60
  src->params.poll_target = 6;
#line 61
  src->params.sel_option = (SRC_SelectOption )0;
#line 63
  result = (CPS_Status )0;
#line 65
  hostname = line___0;
#line 66
  line___0 = CPS_SplitWord(line___0);
  }
#line 68
  if (! *hostname) {
#line 69
    result = (CPS_Status )2;
#line 70
    ok = 0;
  } else {
#line 73
    ok = 1;
#line 74
    done = 0;
    {
#line 75
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 76
      cmd = line___0;
#line 77
      line___0 = CPS_SplitWord(line___0);
      }
#line 79
      if (*cmd) {
        {
#line 80
        tmp___23 = strcasecmp((char const   *)cmd, "port");
        }
#line 80
        if (tmp___23) {
          {
#line 88
          tmp___22 = strcasecmp((char const   *)cmd, "minpoll");
          }
#line 88
          if (tmp___22) {
            {
#line 96
            tmp___21 = strcasecmp((char const   *)cmd, "maxpoll");
            }
#line 96
            if (tmp___21) {
              {
#line 104
              tmp___20 = strcasecmp((char const   *)cmd, "presend");
              }
#line 104
              if (tmp___20) {
                {
#line 112
                tmp___19 = strcasecmp((char const   *)cmd, "maxdelaydevratio");
                }
#line 112
                if (tmp___19) {
                  {
#line 120
                  tmp___18 = strcasecmp((char const   *)cmd, "maxdelayratio");
                  }
#line 120
                  if (tmp___18) {
                    {
#line 128
                    tmp___17 = strcasecmp((char const   *)cmd, "maxdelay");
                    }
#line 128
                    if (tmp___17) {
                      {
#line 136
                      tmp___16 = strcasecmp((char const   *)cmd, "key");
                      }
#line 136
                      if (tmp___16) {
                        {
#line 144
                        tmp___15 = strcasecmp((char const   *)cmd, "offline");
                        }
#line 144
                        if (tmp___15) {
                          {
#line 147
                          tmp___14 = strcasecmp((char const   *)cmd, "auto_offline");
                          }
#line 147
                          if (tmp___14) {
                            {
#line 150
                            tmp___13 = strcasecmp((char const   *)cmd, "iburst");
                            }
#line 150
                            if (tmp___13) {
                              {
#line 153
                              tmp___12 = strcasecmp((char const   *)cmd, "minstratum");
                              }
#line 153
                              if (tmp___12) {
                                {
#line 162
                                tmp___11 = strcasecmp((char const   *)cmd, "polltarget");
                                }
#line 162
                                if (tmp___11) {
                                  {
#line 171
                                  tmp___10 = strcasecmp((char const   *)cmd, "noselect");
                                  }
#line 171
                                  if (tmp___10) {
                                    {
#line 174
                                    tmp___9 = strcasecmp((char const   *)cmd, "prefer");
                                    }
#line 174
                                    if (tmp___9) {
#line 178
                                      result = (CPS_Status )1;
#line 179
                                      ok = 0;
#line 180
                                      done = 1;
                                    } else {
#line 175
                                      src->params.sel_option = (SRC_SelectOption )2;
                                    }
                                  } else {
#line 172
                                    src->params.sel_option = (SRC_SelectOption )1;
                                  }
                                } else {
                                  {
#line 163
                                  tmp___8 = sscanf((char const   */* __restrict  */)line___0,
                                                   (char const   */* __restrict  */)"%d%n",
                                                   & src->params.poll_target, & n);
                                  }
#line 163
                                  if (tmp___8 != 1) {
#line 164
                                    result = (CPS_Status )12;
#line 165
                                    ok = 0;
#line 166
                                    done = 1;
                                  } else {
#line 168
                                    line___0 += n;
                                  }
                                }
                              } else {
                                {
#line 154
                                tmp___7 = sscanf((char const   */* __restrict  */)line___0,
                                                 (char const   */* __restrict  */)"%d%n",
                                                 & src->params.min_stratum, & n);
                                }
#line 154
                                if (tmp___7 != 1) {
#line 155
                                  result = (CPS_Status )11;
#line 156
                                  ok = 0;
#line 157
                                  done = 1;
                                } else {
#line 159
                                  line___0 += n;
                                }
                              }
                            } else {
#line 151
                              src->params.iburst = 1;
                            }
                          } else {
#line 148
                            src->params.auto_offline = 1;
                          }
                        } else {
#line 145
                          src->params.online = 0;
                        }
                      } else {
                        {
#line 137
                        tmp___6 = sscanf((char const   */* __restrict  */)line___0,
                                         (char const   */* __restrict  */)"%lu%n",
                                         & src->params.authkey, & n);
                        }
#line 137
                        if (tmp___6 != 1) {
#line 138
                          result = (CPS_Status )10;
#line 139
                          ok = 0;
#line 140
                          done = 1;
                        } else {
#line 142
                          line___0 += n;
                        }
                      }
                    } else {
                      {
#line 129
                      tmp___5 = sscanf((char const   */* __restrict  */)line___0,
                                       (char const   */* __restrict  */)"%lf%n", & src->params.max_delay,
                                       & n);
                      }
#line 129
                      if (tmp___5 != 1) {
#line 130
                        result = (CPS_Status )9;
#line 131
                        ok = 0;
#line 132
                        done = 1;
                      } else {
#line 134
                        line___0 += n;
                      }
                    }
                  } else {
                    {
#line 121
                    tmp___4 = sscanf((char const   */* __restrict  */)line___0, (char const   */* __restrict  */)"%lf%n",
                                     & src->params.max_delay_ratio, & n);
                    }
#line 121
                    if (tmp___4 != 1) {
#line 122
                      result = (CPS_Status )8;
#line 123
                      ok = 0;
#line 124
                      done = 1;
                    } else {
#line 126
                      line___0 += n;
                    }
                  }
                } else {
                  {
#line 113
                  tmp___3 = sscanf((char const   */* __restrict  */)line___0, (char const   */* __restrict  */)"%lf%n",
                                   & src->params.max_delay_dev_ratio, & n);
                  }
#line 113
                  if (tmp___3 != 1) {
#line 114
                    result = (CPS_Status )7;
#line 115
                    ok = 0;
#line 116
                    done = 1;
                  } else {
#line 118
                    line___0 += n;
                  }
                }
              } else {
                {
#line 105
                tmp___2 = sscanf((char const   */* __restrict  */)line___0, (char const   */* __restrict  */)"%d%n",
                                 & src->params.presend_minpoll, & n);
                }
#line 105
                if (tmp___2 != 1) {
#line 106
                  result = (CPS_Status )6;
#line 107
                  ok = 0;
#line 108
                  done = 1;
                } else {
#line 110
                  line___0 += n;
                }
              }
            } else {
              {
#line 97
              tmp___1 = sscanf((char const   */* __restrict  */)line___0, (char const   */* __restrict  */)"%d%n",
                               & src->params.maxpoll, & n);
              }
#line 97
              if (tmp___1 != 1) {
#line 98
                result = (CPS_Status )5;
#line 99
                ok = 0;
#line 100
                done = 1;
              } else {
#line 102
                line___0 += n;
              }
            }
          } else {
            {
#line 89
            tmp___0 = sscanf((char const   */* __restrict  */)line___0, (char const   */* __restrict  */)"%d%n",
                             & src->params.minpoll, & n);
            }
#line 89
            if (tmp___0 != 1) {
#line 90
              result = (CPS_Status )4;
#line 91
              ok = 0;
#line 92
              done = 1;
            } else {
#line 94
              line___0 += n;
            }
          }
        } else {
          {
#line 81
          tmp = sscanf((char const   */* __restrict  */)line___0, (char const   */* __restrict  */)"%hu%n",
                       & src->port, & n);
          }
#line 81
          if (tmp != 1) {
#line 82
            result = (CPS_Status )3;
#line 83
            ok = 0;
#line 84
            done = 1;
          } else {
#line 86
            line___0 += n;
          }
        }
      } else {
#line 183
        done = 1;
      }
#line 75
      if (! (! done)) {
#line 75
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 188
  if (ok) {
    {
#line 189
    src->name = strdup((char const   *)hostname);
    }
  }
#line 192
  return (result);
}
}
#line 198 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdparse.c"
void CPS_NormalizeLine(char *line___0 ) 
{ 
  char *p ;
  char *q ;
  int space ;
  int first ;
  char *tmp ;
  unsigned short const   **tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 202
  space = 1;
#line 202
  first = 1;
#line 205
  q = line___0;
#line 205
  p = q;
  {
#line 205
  while (1) {
    while_continue: /* CIL Label */ ;
#line 205
    if (! *p) {
#line 205
      goto while_break;
    }
    {
#line 206
    tmp___0 = __ctype_b_loc();
    }
#line 206
    if ((int const   )*(*tmp___0 + (int )*p) & 8192) {
#line 207
      if (! space) {
#line 208
        tmp = q;
#line 208
        q ++;
#line 208
        *tmp = (char )' ';
      }
#line 209
      space = 1;
#line 210
      goto __Cont;
    }
#line 214
    if (first) {
      {
#line 214
      tmp___1 = strchr("!;#%", (int )*p);
      }
#line 214
      if (tmp___1) {
#line 215
        goto while_break;
      }
    }
#line 217
    tmp___2 = q;
#line 217
    q ++;
#line 217
    *tmp___2 = *p;
#line 218
    first = 0;
#line 218
    space = first;
    __Cont: /* CIL Label */ 
#line 205
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 222
  if ((unsigned long )q > (unsigned long )line___0) {
#line 222
    if ((int )*(q + -1) == 32) {
#line 223
      q --;
    }
  }
#line 225
  *q = (char )'\000';
#line 226
  return;
}
}
#line 230 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdparse.c"
char *CPS_SplitWord(char *line___0 ) 
{ 
  char *p ;
  char *q ;
  unsigned short const   **tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;

  {
#line 233
  p = line___0;
#line 233
  q = line___0;
  {
#line 236
  while (1) {
    while_continue: /* CIL Label */ ;
#line 236
    if (*q) {
      {
#line 236
      tmp = __ctype_b_loc();
      }
#line 236
      if (! ((int const   )*(*tmp + (int )*q) & 8192)) {
#line 236
        goto while_break;
      }
    } else {
#line 236
      goto while_break;
    }
#line 237
    q ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 240
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 240
    if (*q) {
      {
#line 240
      tmp___2 = __ctype_b_loc();
      }
#line 240
      if ((int const   )*(*tmp___2 + (int )*q) & 8192) {
#line 240
        goto while_break___0;
      }
    } else {
#line 240
      goto while_break___0;
    }
#line 241
    tmp___0 = p;
#line 241
    p ++;
#line 241
    tmp___1 = q;
#line 241
    q ++;
#line 241
    *tmp___0 = *tmp___1;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 244
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 244
    if (*q) {
      {
#line 244
      tmp___3 = __ctype_b_loc();
      }
#line 244
      if (! ((int const   )*(*tmp___3 + (int )*q) & 8192)) {
#line 244
        goto while_break___1;
      }
    } else {
#line 244
      goto while_break___1;
    }
#line 245
    q ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 247
  *p = (char )'\000';
#line 250
  return (q);
}
}
#line 255 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdparse.c"
int CPS_ParseKey(char *line___0 , unsigned long *id , char const   **hash , char **key ) 
{ 
  char *s1 ;
  char *s2 ;
  char *s3 ;
  char *s4 ;
  int tmp ;

  {
  {
#line 260
  s1 = line___0;
#line 261
  s2 = CPS_SplitWord(s1);
#line 262
  s3 = CPS_SplitWord(s2);
#line 263
  s4 = CPS_SplitWord(s3);
  }
#line 266
  if (! *s2) {
#line 267
    return (0);
  } else
#line 266
  if (*s4) {
#line 267
    return (0);
  }
  {
#line 269
  tmp = sscanf((char const   */* __restrict  */)s1, (char const   */* __restrict  */)"%lu",
               id);
  }
#line 269
  if (tmp != 1) {
#line 270
    return (0);
  }
#line 272
  if (*s3) {
#line 273
    *hash = (char const   *)s2;
#line 274
    *key = s3;
  } else {
#line 276
    *hash = "MD5";
#line 277
    *key = s2;
  }
#line 280
  return (1);
}
}
#line 374 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) ntohl)(uint32_t __netlong )  __attribute__((__const__)) ;
#line 375
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) ntohs)(uint16_t __netshort )  __attribute__((__const__)) ;
#line 379
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/pktlength.h"
int PKL_CommandLength(CMD_Request *r ) ;
#line 36
int PKL_ReplyLength(CMD_Reply *r ) ;
#line 38 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/pktlength.c"
int PKL_CommandLength(CMD_Request *r ) 
{ 
  int type ;
  uint16_t tmp ;

  {
  {
#line 42
  tmp = ntohs(r->command);
#line 42
  type = (int )tmp;
  }
#line 43
  if (type < 0) {
#line 44
    return (0);
  } else
#line 43
  if (type >= 50) {
#line 44
    return (0);
  } else {
    {
#line 48
    if (type == 0) {
#line 48
      goto case_0;
    }
#line 50
    if (type == 1) {
#line 50
      goto case_1;
    }
#line 52
    if (type == 2) {
#line 52
      goto case_2;
    }
#line 54
    if (type == 3) {
#line 54
      goto case_3;
    }
#line 56
    if (type == 4) {
#line 56
      goto case_4;
    }
#line 58
    if (type == 5) {
#line 58
      goto case_5;
    }
#line 60
    if (type == 6) {
#line 60
      goto case_6;
    }
#line 62
    if (type == 7) {
#line 62
      goto case_7;
    }
#line 64
    if (type == 8) {
#line 64
      goto case_8;
    }
#line 66
    if (type == 47) {
#line 66
      goto case_47;
    }
#line 68
    if (type == 9) {
#line 68
      goto case_9;
    }
#line 70
    if (type == 10) {
#line 70
      goto case_10;
    }
#line 72
    if (type == 11) {
#line 72
      goto case_11;
    }
#line 74
    if (type == 12) {
#line 74
      goto case_12;
    }
#line 76
    if (type == 13) {
#line 76
      goto case_13;
    }
#line 78
    if (type == 14) {
#line 78
      goto case_14;
    }
#line 80
    if (type == 15) {
#line 80
      goto case_15;
    }
#line 82
    if (type == 16) {
#line 82
      goto case_16;
    }
#line 84
    if (type == 17) {
#line 84
      goto case_17;
    }
#line 86
    if (type == 18) {
#line 86
      goto case_18;
    }
#line 88
    if (type == 19) {
#line 88
      goto case_19;
    }
#line 90
    if (type == 20) {
#line 90
      goto case_20;
    }
#line 92
    if (type == 21) {
#line 92
      goto case_21;
    }
#line 94
    if (type == 22) {
#line 94
      goto case_22;
    }
#line 96
    if (type == 23) {
#line 96
      goto case_23;
    }
#line 98
    if (type == 24) {
#line 98
      goto case_24;
    }
#line 100
    if (type == 25) {
#line 100
      goto case_25;
    }
#line 102
    if (type == 26) {
#line 102
      goto case_26;
    }
#line 104
    if (type == 27) {
#line 104
      goto case_27;
    }
#line 106
    if (type == 28) {
#line 106
      goto case_28;
    }
#line 108
    if (type == 29) {
#line 108
      goto case_29;
    }
#line 110
    if (type == 30) {
#line 110
      goto case_30;
    }
#line 112
    if (type == 31) {
#line 112
      goto case_31;
    }
#line 114
    if (type == 32) {
#line 114
      goto case_32;
    }
#line 116
    if (type == 33) {
#line 116
      goto case_33;
    }
#line 118
    if (type == 34) {
#line 118
      goto case_34;
    }
#line 120
    if (type == 35) {
#line 120
      goto case_35;
    }
#line 122
    if (type == 36) {
#line 122
      goto case_36;
    }
#line 124
    if (type == 37) {
#line 124
      goto case_37;
    }
#line 127
    if (type == 39) {
#line 127
      goto case_39;
    }
#line 127
    if (type == 38) {
#line 127
      goto case_39;
    }
#line 130
    if (type == 40) {
#line 130
      goto case_40;
    }
#line 132
    if (type == 41) {
#line 132
      goto case_41;
    }
#line 134
    if (type == 42) {
#line 134
      goto case_42;
    }
#line 136
    if (type == 43) {
#line 136
      goto case_43;
    }
#line 138
    if (type == 44) {
#line 138
      goto case_44;
    }
#line 140
    if (type == 48) {
#line 140
      goto case_48;
    }
#line 142
    if (type == 49) {
#line 142
      goto case_49;
    }
#line 144
    if (type == 45) {
#line 144
      goto case_45;
    }
#line 146
    if (type == 46) {
#line 146
      goto case_46;
    }
#line 148
    goto switch_default;
    case_0: /* CIL Label */ 
#line 49
    return ((int )((unsigned long )(& ((CMD_Request *)0)->data)));
    case_1: /* CIL Label */ 
#line 51
    return ((int )((unsigned long )(& ((CMD_Request *)0)->data.online.EOR)));
    case_2: /* CIL Label */ 
#line 53
    return ((int )((unsigned long )(& ((CMD_Request *)0)->data.offline.EOR)));
    case_3: /* CIL Label */ 
#line 55
    return ((int )((unsigned long )(& ((CMD_Request *)0)->data.burst.EOR)));
    case_4: /* CIL Label */ 
#line 57
    return ((int )((unsigned long )(& ((CMD_Request *)0)->data.modify_minpoll.EOR)));
    case_5: /* CIL Label */ 
#line 59
    return ((int )((unsigned long )(& ((CMD_Request *)0)->data.modify_maxpoll.EOR)));
    case_6: /* CIL Label */ 
#line 61
    return ((int )((unsigned long )(& ((CMD_Request *)0)->data.dump.EOR)));
    case_7: /* CIL Label */ 
#line 63
    return ((int )((unsigned long )(& ((CMD_Request *)0)->data.modify_maxdelay.EOR)));
    case_8: /* CIL Label */ 
#line 65
    return ((int )((unsigned long )(& ((CMD_Request *)0)->data.modify_maxdelayratio.EOR)));
    case_47: /* CIL Label */ 
#line 67
    return ((int )((unsigned long )(& ((CMD_Request *)0)->data.modify_maxdelaydevratio.EOR)));
    case_9: /* CIL Label */ 
#line 69
    return ((int )((unsigned long )(& ((CMD_Request *)0)->data.modify_maxupdateskew.EOR)));
    case_10: /* CIL Label */ 
#line 71
    return ((int )((unsigned long )(& ((CMD_Request *)0)->data.logon.EOR)));
    case_11: /* CIL Label */ 
#line 73
    return ((int )((unsigned long )(& ((CMD_Request *)0)->data.settime.EOR)));
    case_12: /* CIL Label */ 
#line 75
    return ((int )((unsigned long )(& ((CMD_Request *)0)->data.local.EOR)));
    case_13: /* CIL Label */ 
#line 77
    return ((int )((unsigned long )(& ((CMD_Request *)0)->data.manual.EOR)));
    case_14: /* CIL Label */ 
#line 79
    return ((int )((unsigned long )(& ((CMD_Request *)0)->data.n_sources.EOR)));
    case_15: /* CIL Label */ 
#line 81
    return ((int )((unsigned long )(& ((CMD_Request *)0)->data.source_data.EOR)));
    case_16: /* CIL Label */ 
#line 83
    return ((int )((unsigned long )(& ((CMD_Request *)0)->data.rekey.EOR)));
    case_17: /* CIL Label */ 
#line 85
    return ((int )((unsigned long )(& ((CMD_Request *)0)->data.allow_deny.EOR)));
    case_18: /* CIL Label */ 
#line 87
    return ((int )((unsigned long )(& ((CMD_Request *)0)->data.allow_deny.EOR)));
    case_19: /* CIL Label */ 
#line 89
    return ((int )((unsigned long )(& ((CMD_Request *)0)->data.allow_deny.EOR)));
    case_20: /* CIL Label */ 
#line 91
    return ((int )((unsigned long )(& ((CMD_Request *)0)->data.allow_deny.EOR)));
    case_21: /* CIL Label */ 
#line 93
    return ((int )((unsigned long )(& ((CMD_Request *)0)->data.allow_deny.EOR)));
    case_22: /* CIL Label */ 
#line 95
    return ((int )((unsigned long )(& ((CMD_Request *)0)->data.allow_deny.EOR)));
    case_23: /* CIL Label */ 
#line 97
    return ((int )((unsigned long )(& ((CMD_Request *)0)->data.allow_deny.EOR)));
    case_24: /* CIL Label */ 
#line 99
    return ((int )((unsigned long )(& ((CMD_Request *)0)->data.allow_deny.EOR)));
    case_25: /* CIL Label */ 
#line 101
    return ((int )((unsigned long )(& ((CMD_Request *)0)->data.ac_check.EOR)));
    case_26: /* CIL Label */ 
#line 103
    return ((int )((unsigned long )(& ((CMD_Request *)0)->data.ac_check.EOR)));
    case_27: /* CIL Label */ 
#line 105
    return ((int )((unsigned long )(& ((CMD_Request *)0)->data.ntp_source.EOR)));
    case_28: /* CIL Label */ 
#line 107
    return ((int )((unsigned long )(& ((CMD_Request *)0)->data.ntp_source.EOR)));
    case_29: /* CIL Label */ 
#line 109
    return ((int )((unsigned long )(& ((CMD_Request *)0)->data.del_source.EOR)));
    case_30: /* CIL Label */ 
#line 111
    return ((int )((unsigned long )(& ((CMD_Request *)0)->data.writertc.EOR)));
    case_31: /* CIL Label */ 
#line 113
    return ((int )((unsigned long )(& ((CMD_Request *)0)->data.dfreq.EOR)));
    case_32: /* CIL Label */ 
#line 115
    return ((int )((unsigned long )(& ((CMD_Request *)0)->data.doffset.EOR)));
    case_33: /* CIL Label */ 
#line 117
    return ((int )((unsigned long )(& ((CMD_Request *)0)->data.tracking.EOR)));
    case_34: /* CIL Label */ 
#line 119
    return ((int )((unsigned long )(& ((CMD_Request *)0)->data.sourcestats.EOR)));
    case_35: /* CIL Label */ 
#line 121
    return ((int )((unsigned long )(& ((CMD_Request *)0)->data.rtcreport.EOR)));
    case_36: /* CIL Label */ 
#line 123
    return ((int )((unsigned long )(& ((CMD_Request *)0)->data.trimrtc.EOR)));
    case_37: /* CIL Label */ 
#line 125
    return ((int )((unsigned long )(& ((CMD_Request *)0)->data.cyclelogs.EOR)));
    case_39: /* CIL Label */ 
    case_38: /* CIL Label */ 
#line 129
    return (0);
    case_40: /* CIL Label */ 
#line 131
    return ((int )((unsigned long )(& ((CMD_Request *)0)->data.client_accesses_by_index.EOR)));
    case_41: /* CIL Label */ 
#line 133
    return ((int )((unsigned long )(& ((CMD_Request *)0)->data.manual_list.EOR)));
    case_42: /* CIL Label */ 
#line 135
    return ((int )((unsigned long )(& ((CMD_Request *)0)->data.manual_delete.EOR)));
    case_43: /* CIL Label */ 
#line 137
    return ((int )((unsigned long )(& ((CMD_Request *)0)->data.make_step.EOR)));
    case_44: /* CIL Label */ 
#line 139
    return ((int )((unsigned long )(& ((CMD_Request *)0)->data.activity.EOR)));
    case_48: /* CIL Label */ 
#line 141
    return ((int )((unsigned long )(& ((CMD_Request *)0)->data.reselect.EOR)));
    case_49: /* CIL Label */ 
#line 143
    return ((int )((unsigned long )(& ((CMD_Request *)0)->data.reselect_distance.EOR)));
    case_45: /* CIL Label */ 
#line 145
    return ((int )((unsigned long )(& ((CMD_Request *)0)->data.modify_minstratum.EOR)));
    case_46: /* CIL Label */ 
#line 147
    return ((int )((unsigned long )(& ((CMD_Request *)0)->data.modify_polltarget.EOR)));
    switch_default: /* CIL Label */ 
    {
#line 150
    __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/pktlength.c",
                  150U, "PKL_CommandLength");
    }
    switch_break: /* CIL Label */ ;
    }
  }
#line 155
  return (0);
}
}
#line 162 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/pktlength.c"
int PKL_ReplyLength(CMD_Reply *r ) 
{ 
  int type ;
  uint16_t tmp ;
  unsigned long nc ;
  uint32_t tmp___0 ;
  uint16_t tmp___1 ;
  unsigned long ns ;
  uint32_t tmp___2 ;
  uint16_t tmp___3 ;

  {
  {
#line 166
  tmp = ntohs(r->reply);
#line 166
  type = (int )tmp;
  }
#line 168
  if (type < 1) {
#line 169
    return (0);
  } else
#line 168
  if (type >= 13) {
#line 169
    return (0);
  } else {
    {
#line 172
    if (type == 1) {
#line 172
      goto case_1;
    }
#line 174
    if (type == 2) {
#line 174
      goto case_2;
    }
#line 176
    if (type == 3) {
#line 176
      goto case_3;
    }
#line 178
    if (type == 4) {
#line 178
      goto case_4;
    }
#line 180
    if (type == 5) {
#line 180
      goto case_5;
    }
#line 182
    if (type == 6) {
#line 182
      goto case_6;
    }
#line 184
    if (type == 7) {
#line 184
      goto case_7;
    }
#line 187
    if (type == 9) {
#line 187
      goto case_9;
    }
#line 187
    if (type == 8) {
#line 187
      goto case_9;
    }
#line 190
    if (type == 10) {
#line 190
      goto case_10;
    }
#line 202
    if (type == 11) {
#line 202
      goto case_11;
    }
#line 214
    if (type == 12) {
#line 214
      goto case_12;
    }
#line 217
    goto switch_default;
    case_1: /* CIL Label */ 
#line 173
    return ((int )((unsigned long )(& ((CMD_Reply *)0)->data.null.EOR)));
    case_2: /* CIL Label */ 
#line 175
    return ((int )((unsigned long )(& ((CMD_Reply *)0)->data.n_sources.EOR)));
    case_3: /* CIL Label */ 
#line 177
    return ((int )((unsigned long )(& ((CMD_Reply *)0)->data.source_data.EOR)));
    case_4: /* CIL Label */ 
#line 179
    return ((int )((unsigned long )(& ((CMD_Reply *)0)->data.manual_timestamp.EOR)));
    case_5: /* CIL Label */ 
#line 181
    return ((int )((unsigned long )(& ((CMD_Reply *)0)->data.tracking.EOR)));
    case_6: /* CIL Label */ 
#line 183
    return ((int )((unsigned long )(& ((CMD_Reply *)0)->data.sourcestats.EOR)));
    case_7: /* CIL Label */ 
#line 185
    return ((int )((unsigned long )(& ((CMD_Reply *)0)->data.rtc.EOR)));
    case_9: /* CIL Label */ 
    case_8: /* CIL Label */ 
#line 189
    return (0);
    case_10: /* CIL Label */ 
    {
#line 192
    tmp___0 = ntohl(r->data.client_accesses_by_index.n_clients);
#line 192
    nc = (unsigned long )tmp___0;
#line 193
    tmp___1 = htons((uint16_t )0);
    }
#line 193
    if ((int )r->status == (int )tmp___1) {
#line 194
      if (nc > 8UL) {
#line 195
        return (0);
      }
#line 196
      return ((int )((unsigned long )(& ((CMD_Reply *)0)->data.client_accesses_by_index.clients) + nc * sizeof(RPY_ClientAccesses_Client )));
    } else {
#line 199
      return ((int )((unsigned long )(& ((CMD_Reply *)0)->data)));
    }
    case_11: /* CIL Label */ 
    {
#line 204
    tmp___2 = ntohl(r->data.manual_list.n_samples);
#line 204
    ns = (unsigned long )tmp___2;
    }
#line 205
    if (ns > 32UL) {
#line 206
      return (0);
    }
    {
#line 207
    tmp___3 = htons((uint16_t )0);
    }
#line 207
    if ((int )r->status == (int )tmp___3) {
#line 208
      return ((int )((unsigned long )(& ((CMD_Reply *)0)->data.manual_list.samples) + ns * sizeof(RPY_ManualListSample )));
    } else {
#line 211
      return ((int )((unsigned long )(& ((CMD_Reply *)0)->data)));
    }
    case_12: /* CIL Label */ 
#line 215
    return ((int )((unsigned long )(& ((CMD_Reply *)0)->data.activity.EOR)));
    switch_default: /* CIL Label */ 
    {
#line 218
    __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/pktlength.c",
                  218U, "PKL_ReplyLength");
    }
    switch_break: /* CIL Label */ ;
    }
  }
#line 222
  return (0);
}
}
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_core.h"
NCR_Instance NCR_GetInstance(NTP_Remote_Address *remote_addr , NTP_Source_Type type ,
                             SourceParameters *params ) ;
#line 53
void NCR_DestroyInstance(NCR_Instance instance ) ;
#line 57
void NCR_ProcessKnown(NTP_Packet *message , struct timeval *now , double now_err ,
                      NCR_Instance inst , int length ) ;
#line 61
void NCR_ProcessUnknown(NTP_Packet *message , struct timeval *now , double now_err ,
                        NTP_Remote_Address *remote_addr , int length ) ;
#line 64
void NCR_SlewTimes(NCR_Instance inst , struct timeval *when , double dfreq , double doffset ) ;
#line 67
void NCR_TakeSourceOnline(NCR_Instance inst ) ;
#line 71
void NCR_TakeSourceOffline(NCR_Instance inst ) ;
#line 73
void NCR_ModifyMinpoll(NCR_Instance inst , int new_minpoll ) ;
#line 75
void NCR_ModifyMaxpoll(NCR_Instance inst , int new_maxpoll ) ;
#line 77
void NCR_ModifyMaxdelay(NCR_Instance inst , double new_max_delay ) ;
#line 79
void NCR_ModifyMaxdelayratio(NCR_Instance inst , double new_max_delay_ratio ) ;
#line 81
void NCR_ModifyMaxdelaydevratio(NCR_Instance inst , double new_max_delay_dev_ratio ) ;
#line 83
void NCR_ModifyMinstratum(NCR_Instance inst , int new_min_stratum ) ;
#line 85
void NCR_ModifyPolltarget(NCR_Instance inst , int new_poll_target ) ;
#line 87
void NCR_InitiateSampleBurst(NCR_Instance inst , int n_good_samples , int n_total_samples ) ;
#line 89
void NCR_ReportSource(NCR_Instance inst , RPT_SourceReport *report , struct timeval *now ) ;
#line 94
void NCR_IncrementActivityCounters(NCR_Instance inst , int *online , int *offline ,
                                   int *burst_online , int *burst_offline ) ;
#line 97
NTP_Remote_Address *NCR_GetRemoteAddress(NCR_Instance inst ) ;
#line 99
int NCR_IsSyncPeer(NCR_Instance inst ) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_sources.h"
NSR_Status NSR_AddSource(NTP_Remote_Address *remote_addr , NTP_Source_Type type ,
                         SourceParameters *params ) ;
#line 55
void NSR_AddUnresolvedSource(char *name , int port , NTP_Source_Type type , SourceParameters *params ) ;
#line 58
void NSR_ResolveSources(void) ;
#line 61
NSR_Status NSR_RemoveSource(NTP_Remote_Address *remote_addr ) ;
#line 64
void NSR_ProcessReceive(NTP_Packet *message , struct timeval *now , double now_err ,
                        NTP_Remote_Address *remote_addr , int length ) ;
#line 75
int NSR_TakeSourcesOnline(IPAddr *mask , IPAddr *address ) ;
#line 80
int NSR_TakeSourcesOffline(IPAddr *mask , IPAddr *address ) ;
#line 82
int NSR_ModifyMinpoll(IPAddr *address , int new_minpoll ) ;
#line 84
int NSR_ModifyMaxpoll(IPAddr *address , int new_maxpoll ) ;
#line 86
int NSR_ModifyMaxdelay(IPAddr *address , double new_max_delay ) ;
#line 88
int NSR_ModifyMaxdelayratio(IPAddr *address , double new_max_delay_ratio ) ;
#line 90
int NSR_ModifyMaxdelaydevratio(IPAddr *address , double new_max_delay_dev_ratio ) ;
#line 92
int NSR_ModifyMinstratum(IPAddr *address , int new_min_stratum ) ;
#line 94
int NSR_ModifyPolltarget(IPAddr *address , int new_poll_target ) ;
#line 96
int NSR_InitiateSampleBurst(int n_good_samples , int n_total_samples , IPAddr *mask ,
                            IPAddr *address ) ;
#line 98
void NSR_ReportSource(RPT_SourceReport *report , struct timeval *now ) ;
#line 100
void NSR_GetActivityReport(RPT_ActivityReport *report ) ;
#line 87 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/util.h"
int UTI_CompareIPs(IPAddr *a , IPAddr *b , IPAddr *mask ) ;
#line 84 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/local.h"
void LCL_AddParameterChangeHandler(void (*handler)(struct timeval *raw , struct timeval *cooked ,
                                                   double dfreq , double doffset ,
                                                   int is_step_change , void *anything ) ,
                                   void *anything ) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/nameserv.h"
DNS_Status DNS_Name2IPAddress(char const   *name , IPAddr *addr ) ;
#line 46
void DNS_Reload(void) ;
#line 68 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sched.h"
SCH_TimeoutID SCH_AddTimeoutByDelay(double delay , void (*handler)(SCH_ArbitraryArgument  ) ,
                                    SCH_ArbitraryArgument arg ) ;
#line 79
void SCH_RemoveTimeout(SCH_TimeoutID id ) ;
#line 58 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_sources.c"
static SourceRecord records[256]  ;
#line 60 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_sources.c"
static int n_sources  ;
#line 74 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_sources.c"
static struct UnresolvedSource *unresolved_sources  =    (struct UnresolvedSource *)((void *)0);
#line 75 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_sources.c"
static int resolving_interval  =    0;
#line 76 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_sources.c"
static SCH_TimeoutID resolving_id  ;
#line 80
static void slew_sources(struct timeval *raw , struct timeval *cooked , double dfreq ,
                         double doffset , int is_step_change , void *anything ) ;
#line 91 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_sources.c"
static int initialised___0  =    0;
#line 95 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_sources.c"
void NSR_Initialise(void) 
{ 
  int i ;

  {
#line 99
  i = 0;
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    if (! (i < 256)) {
#line 99
      goto while_break;
    }
#line 100
    records[i].remote_addr = (NTP_Remote_Address *)((void *)0);
#line 99
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 102
  n_sources = 0;
#line 103
  initialised___0 = 1;
#line 105
  LCL_AddParameterChangeHandler(& slew_sources, (void *)0);
  }
#line 106
  return;
}
}
#line 110 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_sources.c"
void NSR_Finalise(void) 
{ 


  {
#line 113
  initialised___0 = 0;
#line 114
  return;
}
}
#line 130 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_sources.c"
static void find_slot(NTP_Remote_Address *remote_addr , int *slot , int *found ) 
{ 
  unsigned long hash ;
  unsigned long ip ;
  unsigned short port ;
  uint8_t *ip6 ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 141
  if ((int )remote_addr->ip_addr.family == 2) {
#line 141
    goto case_2;
  }
#line 148
  if ((int )remote_addr->ip_addr.family == 1) {
#line 148
    goto case_1;
  }
#line 151
  goto switch_default;
  case_2: /* CIL Label */ 
#line 142
  ip6 = remote_addr->ip_addr.addr.in6;
#line 143
  ip = (unsigned long )(((((((int )*(ip6 + 0) ^ (int )*(ip6 + 4)) ^ (int )*(ip6 + 8)) ^ (int )*(ip6 + 12)) | (((((int )*(ip6 + 1) ^ (int )*(ip6 + 5)) ^ (int )*(ip6 + 9)) ^ (int )*(ip6 + 13)) << 8)) | (((((int )*(ip6 + 2) ^ (int )*(ip6 + 6)) ^ (int )*(ip6 + 10)) ^ (int )*(ip6 + 14)) << 16)) | (((((int )*(ip6 + 3) ^ (int )*(ip6 + 7)) ^ (int )*(ip6 + 11)) ^ (int )*(ip6 + 15)) << 24));
#line 147
  goto switch_break;
  case_1: /* CIL Label */ 
#line 149
  ip = (unsigned long )remote_addr->ip_addr.addr.in4;
#line 150
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 152
  tmp = 0;
#line 152
  *slot = tmp;
#line 152
  *found = tmp;
#line 153
  return;
  switch_break: /* CIL Label */ ;
  }
#line 156
  port = remote_addr->port;
#line 158
  hash = ip ^ (ip >> 16);
#line 159
  hash = (hash ^ (hash >> 8)) & 255UL;
  {
#line 161
  while (1) {
    while_continue: /* CIL Label */ ;
#line 161
    if (records[hash].remote_addr) {
      {
#line 161
      tmp___0 = UTI_CompareIPs(& (records[hash].remote_addr)->ip_addr, & remote_addr->ip_addr,
                               (IPAddr *)((void *)0));
      }
#line 161
      if (! tmp___0) {
#line 161
        goto while_break;
      }
    } else {
#line 161
      goto while_break;
    }
#line 164
    hash ++;
#line 165
    if (hash == 256UL) {
#line 165
      hash = 0UL;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 168
  if (records[hash].remote_addr) {
#line 169
    if ((int )(records[hash].remote_addr)->port == (int )port) {
#line 170
      *found = 2;
    } else {
#line 172
      *found = 1;
    }
#line 174
    *slot = (int )hash;
  } else {
#line 176
    *found = 0;
#line 177
    *slot = (int )hash;
  }
#line 179
  return;
}
}
#line 184 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_sources.c"
NSR_Status NSR_AddSource(NTP_Remote_Address *remote_addr , NTP_Source_Type type ,
                         SourceParameters *params ) 
{ 
  int slot ;
  int found ;

  {
#line 189
  if (! initialised___0) {
    {
#line 189
    __assert_fail("initialised", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_sources.c",
                  189U, "NSR_AddSource");
    }
  }
  {
#line 196
  find_slot(remote_addr, & slot, & found);
  }
#line 197
  if (found) {
#line 198
    return ((NSR_Status )2);
  } else
#line 200
  if (n_sources == 64) {
#line 201
    return ((NSR_Status )3);
  } else
#line 202
  if ((int )remote_addr->ip_addr.family != 1) {
#line 202
    if ((int )remote_addr->ip_addr.family != 2) {
#line 204
      return ((NSR_Status )4);
    } else {
      {
#line 206
      n_sources ++;
#line 207
      records[slot].data = NCR_GetInstance(remote_addr, type, params);
#line 208
      records[slot].remote_addr = NCR_GetRemoteAddress(records[slot].data);
      }
#line 209
      return ((NSR_Status )0);
    }
  } else {
    {
#line 206
    n_sources ++;
#line 207
    records[slot].data = NCR_GetInstance(remote_addr, type, params);
#line 208
    records[slot].remote_addr = NCR_GetRemoteAddress(records[slot].data);
    }
#line 209
    return ((NSR_Status )0);
  }
}
}
#line 216 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_sources.c"
static void resolve_sources(void *arg ) 
{ 
  NTP_Remote_Address address ;
  struct UnresolvedSource *us ;
  struct UnresolvedSource **i ;
  DNS_Status s ;

  {
  {
#line 223
  memset((void *)(& address.local_ip_addr), 0, sizeof(address.local_ip_addr));
#line 225
  DNS_Reload();
#line 227
  i = & unresolved_sources;
  }
  {
#line 227
  while (1) {
    while_continue: /* CIL Label */ ;
#line 227
    if (! *i) {
#line 227
      goto while_break;
    }
    {
#line 228
    us = *i;
#line 229
    s = DNS_Name2IPAddress((char const   *)us->name, & address.ip_addr);
    }
#line 230
    if ((unsigned int )s == 1U) {
#line 231
      i = & (*i)->next;
#line 232
      goto __Cont;
    } else
#line 233
    if ((unsigned int )s == 0U) {
      {
#line 234
      address.port = (unsigned short )us->port;
#line 235
      NSR_AddSource(& address, us->type, & us->params);
      }
    } else {
      {
#line 237
      LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_sources.c",
                   237, "resolve_sources");
#line 237
      LOG_Line_Function((LOG_Severity )1, (LOG_Facility )3, "Invalid host %s", us->name);
      }
    }
    {
#line 240
    *i = us->next;
#line 242
    free((void *)us->name);
#line 243
    free((void *)us);
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 246
  if (unresolved_sources) {
#line 248
    if (resolving_interval < 9) {
#line 249
      resolving_interval ++;
    }
    {
#line 250
    resolving_id = SCH_AddTimeoutByDelay((double )(7 * (1 << resolving_interval)),
                                         & resolve_sources, (void *)0);
    }
  } else {
#line 252
    resolving_interval = 0;
  }
#line 254
  return;
}
}
#line 260 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_sources.c"
void NSR_AddUnresolvedSource(char *name , int port , NTP_Source_Type type , SourceParameters *params ) 
{ 
  struct UnresolvedSource *us ;
  struct UnresolvedSource **i ;
  void *tmp ;

  {
  {
#line 265
  tmp = malloc(sizeof(struct UnresolvedSource ));
#line 265
  us = (struct UnresolvedSource *)tmp;
#line 267
  us->name = name;
#line 268
  us->port = port;
#line 269
  us->type = type;
#line 270
  us->params = *params;
#line 271
  us->next = (struct UnresolvedSource *)((void *)0);
#line 273
  i = & unresolved_sources;
  }
  {
#line 273
  while (1) {
    while_continue: /* CIL Label */ ;
#line 273
    if (! *i) {
#line 273
      goto while_break;
    }
#line 273
    i = & (*i)->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 275
  *i = us;
#line 277
  if (! resolving_interval) {
    {
#line 278
    resolving_interval = 2;
#line 279
    resolving_id = SCH_AddTimeoutByDelay((double )(7 * (1 << resolving_interval)),
                                         & resolve_sources, (void *)0);
    }
  }
#line 281
  return;
}
}
#line 285 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_sources.c"
void NSR_ResolveSources(void) 
{ 


  {
#line 289
  if (resolving_interval) {
    {
#line 290
    SCH_RemoveTimeout(resolving_id);
#line 291
    resolving_interval --;
#line 292
    resolve_sources((void *)0);
    }
  }
#line 294
  return;
}
}
#line 302 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_sources.c"
NSR_Status NSR_RemoveSource(NTP_Remote_Address *remote_addr ) 
{ 
  int i ;
  int slot ;
  int found ;
  SourceRecord temp_records[256] ;

  {
#line 308
  if (! initialised___0) {
    {
#line 308
    __assert_fail("initialised", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_sources.c",
                  308U, "NSR_RemoveSource");
    }
  }
  {
#line 310
  find_slot(remote_addr, & slot, & found);
  }
#line 311
  if (! found) {
#line 312
    return ((NSR_Status )1);
  }
  {
#line 315
  n_sources --;
#line 316
  records[slot].remote_addr = (NTP_Remote_Address *)((void *)0);
#line 317
  NCR_DestroyInstance(records[slot].data);
#line 322
  memcpy((void */* __restrict  */)(temp_records), (void const   */* __restrict  */)(records),
         sizeof(records));
#line 324
  i = 0;
  }
  {
#line 324
  while (1) {
    while_continue: /* CIL Label */ ;
#line 324
    if (! (i < 256)) {
#line 324
      goto while_break;
    }
#line 325
    records[i].remote_addr = (NTP_Remote_Address *)((void *)0);
#line 324
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 328
  i = 0;
  {
#line 328
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 328
    if (! (i < 256)) {
#line 328
      goto while_break___0;
    }
#line 329
    if (! temp_records[i].remote_addr) {
#line 330
      goto __Cont;
    }
    {
#line 332
    find_slot(temp_records[i].remote_addr, & slot, & found);
    }
#line 333
    if (! (! found)) {
      {
#line 333
      __assert_fail("!found", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_sources.c",
                    333U, "NSR_RemoveSource");
      }
    }
#line 335
    records[slot].remote_addr = temp_records[i].remote_addr;
#line 336
    records[slot].data = temp_records[i].data;
    __Cont: /* CIL Label */ 
#line 328
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 339
  return ((NSR_Status )0);
}
}
#line 346 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_sources.c"
void NSR_ProcessReceive(NTP_Packet *message , struct timeval *now , double now_err ,
                        NTP_Remote_Address *remote_addr , int length ) 
{ 
  int slot ;
  int found ;

  {
#line 351
  if (! initialised___0) {
    {
#line 351
    __assert_fail("initialised", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_sources.c",
                  351U, "NSR_ProcessReceive");
    }
  }
  {
#line 359
  find_slot(remote_addr, & slot, & found);
  }
#line 360
  if (found == 2) {
    {
#line 361
    NCR_ProcessKnown(message, now, now_err, records[slot].data, length);
    }
  } else {
    {
#line 363
    NCR_ProcessUnknown(message, now, now_err, remote_addr, length);
    }
  }
#line 365
  return;
}
}
#line 369 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_sources.c"
static void slew_sources(struct timeval *raw , struct timeval *cooked , double dfreq ,
                         double doffset , int is_step_change , void *anything ) 
{ 
  int i ;

  {
#line 379
  i = 0;
  {
#line 379
  while (1) {
    while_continue: /* CIL Label */ ;
#line 379
    if (! (i < 256)) {
#line 379
      goto while_break;
    }
#line 380
    if (records[i].remote_addr) {
      {
#line 386
      NCR_SlewTimes(records[i].data, cooked, dfreq, doffset);
      }
    }
#line 379
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 390
  return;
}
}
#line 394 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_sources.c"
int NSR_TakeSourcesOnline(IPAddr *mask , IPAddr *address ) 
{ 
  int i ;
  int any ;
  int tmp ;
  struct UnresolvedSource *us ;

  {
  {
#line 400
  NSR_ResolveSources();
#line 402
  any = 0;
#line 403
  i = 0;
  }
  {
#line 403
  while (1) {
    while_continue: /* CIL Label */ ;
#line 403
    if (! (i < 256)) {
#line 403
      goto while_break;
    }
#line 404
    if (records[i].remote_addr) {
#line 405
      if ((int )address->family == 0) {
        {
#line 407
        any = 1;
#line 408
        NCR_TakeSourceOnline(records[i].data);
        }
      } else {
        {
#line 405
        tmp = UTI_CompareIPs(& (records[i].remote_addr)->ip_addr, address, mask);
        }
#line 405
        if (! tmp) {
          {
#line 407
          any = 1;
#line 408
          NCR_TakeSourceOnline(records[i].data);
          }
        }
      }
    }
#line 403
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 413
  if ((int )address->family == 0) {
#line 416
    us = unresolved_sources;
    {
#line 416
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 416
      if (! us) {
#line 416
        goto while_break___0;
      }
#line 417
      any = 1;
#line 418
      us->params.online = 1;
#line 416
      us = us->next;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 422
  return (any);
}
}
#line 427 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_sources.c"
int NSR_TakeSourcesOffline(IPAddr *mask , IPAddr *address ) 
{ 
  int i ;
  int any ;
  int syncpeer ;
  int tmp ;
  int tmp___0 ;
  struct UnresolvedSource *us ;

  {
#line 432
  any = 0;
#line 433
  syncpeer = -1;
#line 434
  i = 0;
  {
#line 434
  while (1) {
    while_continue: /* CIL Label */ ;
#line 434
    if (! (i < 256)) {
#line 434
      goto while_break;
    }
#line 435
    if (records[i].remote_addr) {
#line 436
      if ((int )address->family == 0) {
#line 436
        goto _L;
      } else {
        {
#line 436
        tmp___0 = UTI_CompareIPs(& (records[i].remote_addr)->ip_addr, address, mask);
        }
#line 436
        if (! tmp___0) {
          _L: /* CIL Label */ 
          {
#line 438
          any = 1;
#line 439
          tmp = NCR_IsSyncPeer(records[i].data);
          }
#line 439
          if (tmp) {
#line 440
            syncpeer = i;
#line 441
            goto __Cont;
          }
          {
#line 443
          NCR_TakeSourceOffline(records[i].data);
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 434
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 449
  if (syncpeer >= 0) {
    {
#line 450
    NCR_TakeSourceOffline(records[syncpeer].data);
    }
  }
#line 453
  if ((int )address->family == 0) {
#line 456
    us = unresolved_sources;
    {
#line 456
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 456
      if (! us) {
#line 456
        goto while_break___0;
      }
#line 457
      any = 1;
#line 458
      us->params.online = 0;
#line 456
      us = us->next;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 462
  return (any);
}
}
#line 467 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_sources.c"
int NSR_ModifyMinpoll(IPAddr *address , int new_minpoll ) 
{ 
  int slot ;
  int found ;
  NTP_Remote_Address addr ;

  {
  {
#line 472
  addr.ip_addr = *address;
#line 473
  addr.port = (unsigned short)0;
#line 475
  find_slot(& addr, & slot, & found);
  }
#line 476
  if (found == 0) {
#line 477
    return (0);
  } else {
    {
#line 479
    NCR_ModifyMinpoll(records[slot].data, new_minpoll);
    }
#line 480
    return (1);
  }
}
}
#line 486 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_sources.c"
int NSR_ModifyMaxpoll(IPAddr *address , int new_maxpoll ) 
{ 
  int slot ;
  int found ;
  NTP_Remote_Address addr ;

  {
  {
#line 491
  addr.ip_addr = *address;
#line 492
  addr.port = (unsigned short)0;
#line 494
  find_slot(& addr, & slot, & found);
  }
#line 495
  if (found == 0) {
#line 496
    return (0);
  } else {
    {
#line 498
    NCR_ModifyMaxpoll(records[slot].data, new_maxpoll);
    }
#line 499
    return (1);
  }
}
}
#line 505 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_sources.c"
int NSR_ModifyMaxdelay(IPAddr *address , double new_max_delay ) 
{ 
  int slot ;
  int found ;
  NTP_Remote_Address addr ;

  {
  {
#line 510
  addr.ip_addr = *address;
#line 511
  addr.port = (unsigned short)0;
#line 513
  find_slot(& addr, & slot, & found);
  }
#line 514
  if (found == 0) {
#line 515
    return (0);
  } else {
    {
#line 517
    NCR_ModifyMaxdelay(records[slot].data, new_max_delay);
    }
#line 518
    return (1);
  }
}
}
#line 524 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_sources.c"
int NSR_ModifyMaxdelayratio(IPAddr *address , double new_max_delay_ratio ) 
{ 
  int slot ;
  int found ;
  NTP_Remote_Address addr ;

  {
  {
#line 529
  addr.ip_addr = *address;
#line 530
  addr.port = (unsigned short)0;
#line 532
  find_slot(& addr, & slot, & found);
  }
#line 533
  if (found == 0) {
#line 534
    return (0);
  } else {
    {
#line 536
    NCR_ModifyMaxdelayratio(records[slot].data, new_max_delay_ratio);
    }
#line 537
    return (1);
  }
}
}
#line 543 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_sources.c"
int NSR_ModifyMaxdelaydevratio(IPAddr *address , double new_max_delay_dev_ratio ) 
{ 
  int slot ;
  int found ;
  NTP_Remote_Address addr ;

  {
  {
#line 548
  addr.ip_addr = *address;
#line 549
  addr.port = (unsigned short)0;
#line 551
  find_slot(& addr, & slot, & found);
  }
#line 552
  if (found == 0) {
#line 553
    return (0);
  } else {
    {
#line 555
    NCR_ModifyMaxdelaydevratio(records[slot].data, new_max_delay_dev_ratio);
    }
#line 556
    return (1);
  }
}
}
#line 562 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_sources.c"
int NSR_ModifyMinstratum(IPAddr *address , int new_min_stratum ) 
{ 
  int slot ;
  int found ;
  NTP_Remote_Address addr ;

  {
  {
#line 567
  addr.ip_addr = *address;
#line 568
  addr.port = (unsigned short)0;
#line 570
  find_slot(& addr, & slot, & found);
  }
#line 571
  if (found == 0) {
#line 572
    return (0);
  } else {
    {
#line 574
    NCR_ModifyMinstratum(records[slot].data, new_min_stratum);
    }
#line 575
    return (1);
  }
}
}
#line 581 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_sources.c"
int NSR_ModifyPolltarget(IPAddr *address , int new_poll_target ) 
{ 
  int slot ;
  int found ;
  NTP_Remote_Address addr ;

  {
  {
#line 586
  addr.ip_addr = *address;
#line 587
  addr.port = (unsigned short)0;
#line 589
  find_slot(& addr, & slot, & found);
  }
#line 590
  if (found == 0) {
#line 591
    return (0);
  } else {
    {
#line 593
    NCR_ModifyPolltarget(records[slot].data, new_poll_target);
    }
#line 594
    return (1);
  }
}
}
#line 600 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_sources.c"
int NSR_InitiateSampleBurst(int n_good_samples , int n_total_samples , IPAddr *mask ,
                            IPAddr *address ) 
{ 
  int i ;
  int any ;
  int tmp ;

  {
#line 607
  any = 0;
#line 608
  i = 0;
  {
#line 608
  while (1) {
    while_continue: /* CIL Label */ ;
#line 608
    if (! (i < 256)) {
#line 608
      goto while_break;
    }
#line 609
    if (records[i].remote_addr) {
#line 610
      if ((int )address->family == 0) {
        {
#line 612
        any = 1;
#line 613
        NCR_InitiateSampleBurst(records[i].data, n_good_samples, n_total_samples);
        }
      } else {
        {
#line 610
        tmp = UTI_CompareIPs(& (records[i].remote_addr)->ip_addr, address, mask);
        }
#line 610
        if (! tmp) {
          {
#line 612
          any = 1;
#line 613
          NCR_InitiateSampleBurst(records[i].data, n_good_samples, n_total_samples);
          }
        }
      }
    }
#line 608
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 618
  return (any);
}
}
#line 626 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_sources.c"
void NSR_ReportSource(RPT_SourceReport *report , struct timeval *now ) 
{ 
  NTP_Remote_Address rem_addr ;
  int slot ;
  int found ;

  {
  {
#line 632
  rem_addr.ip_addr = report->ip_addr;
#line 633
  rem_addr.port = (unsigned short)0;
#line 634
  find_slot(& rem_addr, & slot, & found);
  }
#line 635
  if (found) {
    {
#line 636
    NCR_ReportSource(records[slot].data, report, now);
    }
  } else {
#line 638
    report->poll = 0;
#line 639
    report->latest_meas_ago = 0UL;
  }
#line 641
  return;
}
}
#line 645 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_sources.c"
void NSR_GetActivityReport(RPT_ActivityReport *report ) 
{ 
  int i ;
  struct UnresolvedSource *us ;

  {
#line 651
  report->online = 0;
#line 652
  report->offline = 0;
#line 653
  report->burst_online = 0;
#line 654
  report->burst_offline = 0;
#line 656
  i = 0;
  {
#line 656
  while (1) {
    while_continue: /* CIL Label */ ;
#line 656
    if (! (i < 256)) {
#line 656
      goto while_break;
    }
#line 657
    if (records[i].remote_addr) {
      {
#line 658
      NCR_IncrementActivityCounters(records[i].data, & report->online, & report->offline,
                                    & report->burst_online, & report->burst_offline);
      }
    }
#line 656
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 663
  report->unresolved = 0;
#line 665
  us = unresolved_sources;
  {
#line 665
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 665
    if (! us) {
#line 665
      goto while_break___0;
    }
#line 666
    (report->unresolved) ++;
#line 665
    us = us->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 668
  return;
}
}
#line 181 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) fabs)(double __x )  __attribute__((__const__)) ;
#line 377 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) htonl)(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 69 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 64 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sources.h"
SRC_Instance SRC_CreateNewInstance(uint32_t ref_id , SRC_Type type , SRC_SelectOption sel_option ,
                                   IPAddr *addr ) ;
#line 71
void SRC_DestroyInstance(SRC_Instance instance ) ;
#line 85
void SRC_GetFrequencyRange(SRC_Instance instance , double *lo , double *hi ) ;
#line 115
void SRC_AccumulateSample(SRC_Instance inst , struct timeval *sample_time , double offset ,
                          double peer_delay , double peer_dispersion , double root_delay ,
                          double root_dispersion , int stratum , NTP_Leap leap_status ) ;
#line 119
void SRC_SetSelectable(SRC_Instance inst ) ;
#line 123
void SRC_UnsetSelectable(SRC_Instance inst ) ;
#line 126
void SRC_UpdateReachability(SRC_Instance inst , int reachable ) ;
#line 129
void SRC_ResetReachability(SRC_Instance inst ) ;
#line 149
double SRC_PredictOffset(SRC_Instance inst , struct timeval *when ) ;
#line 153
double SRC_MinRoundTripDelay(SRC_Instance inst ) ;
#line 157
int SRC_IsGoodSample(SRC_Instance inst , double offset , double delay , double max_delay_dev_ratio ,
                     double clock_error , struct timeval *when ) ;
#line 163
int SRC_IsSyncPeer(SRC_Instance inst ) ;
#line 179
int SRC_Samples(SRC_Instance inst ) ;
#line 91 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_core.h"
int NCR_AddAccessRestriction(IPAddr *ip_addr , int subnet_bits , int allow , int all ) ;
#line 92
int NCR_CheckAccessRestriction(IPAddr *ip_addr ) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_io.h"
void NIO_SendNormalPacket(NTP_Packet *packet , NTP_Remote_Address *remote_addr ) ;
#line 44
void NIO_SendAuthenticatedPacket(NTP_Packet *packet , NTP_Remote_Address *remote_addr ,
                                 int auth_len ) ;
#line 47
void NIO_SendEcho(NTP_Remote_Address *remote_addr ) ;
#line 62 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sched.h"
void SCH_GetLastEventTime(struct timeval *cooked , double *err , struct timeval *raw ) ;
#line 74
SCH_TimeoutID SCH_AddTimeoutInClass(double min_delay , double separation , double randomness ,
                                    SCH_TimeoutClass class , void (*handler)(SCH_ArbitraryArgument  ) ,
                                    SCH_ArbitraryArgument arg ) ;
#line 68 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.h"
void REF_GetReferenceParams(struct timeval *local_time , int *is_synchronised , NTP_Leap *leap_status ,
                            int *stratum , uint32_t *ref_id , struct timeval *ref_time ,
                            double *root_delay , double *root_dispersion ) ;
#line 134
int REF_GetOurStratum(void) ;
#line 47 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/local.h"
void LCL_ReadCookedTime(struct timeval *result , double *err ) ;
#line 165
int LCL_GetSysPrecisionAsLog(void) ;
#line 168
double LCL_GetSysPrecisionAsQuantum(void) ;
#line 172
double LCL_GetMaxClockError(void) ;
#line 46 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/util.h"
int UTI_CompareTimevals(struct timeval *a , struct timeval *b ) ;
#line 50
void UTI_NormaliseTimeval(struct timeval *x ) ;
#line 56
void UTI_DiffTimevalsToDouble(double *result , struct timeval *a , struct timeval *b ) ;
#line 64
void UTI_AverageDiffTimevals(struct timeval *earlier , struct timeval *later , struct timeval *average ,
                             double *diff ) ;
#line 81
char *UTI_IPToString(IPAddr *addr ) ;
#line 84
uint32_t UTI_IPToRefid(IPAddr *ip ) ;
#line 89
char *UTI_TimeToLogForm(time_t t ) ;
#line 92
void UTI_AdjustTimeval(struct timeval *old_tv , struct timeval *when , struct timeval *new_tv ,
                       double *delta_time , double dfreq , double doffset ) ;
#line 95
uint32_t UTI_GetNTPTsFuzz(int precision ) ;
#line 97
double UTI_Int32ToDouble(NTP_int32 x ) ;
#line 98
NTP_int32 UTI_DoubleToInt32(double x ) ;
#line 100
void UTI_TimevalToInt64(struct timeval *src , NTP_int64 *dest , uint32_t fuzz ) ;
#line 102
void UTI_Int64ToTimeval(NTP_int64 *src , struct timeval *dest ) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.h"
int CNF_GetLogMeasurements(void) ;
#line 96 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/logging.h"
int LOG_RateLimited(void) ;
#line 112
LOG_FileID LOG_FileOpen(char const   *name , char const   *banner ) ;
#line 113
void LOG_FileWrite(LOG_FileID id , char const   *format  , ...) ;
#line 38 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/keys.h"
int KEY_KeyKnown(unsigned long key_id ) ;
#line 39
int KEY_GetAuthDelay(unsigned long key_id ) ;
#line 41
int KEY_GenerateAuth(unsigned long key_id , unsigned char const   *data , int data_len ,
                     unsigned char *auth , int auth_len ) ;
#line 43
int KEY_CheckAuth(unsigned long key_id , unsigned char const   *data , int data_len ,
                  unsigned char const   *auth , int auth_len ) ;
#line 39 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/clientlog.h"
void CLG_LogNTPClientAccess(IPAddr *client , time_t now ) ;
#line 40
void CLG_LogNTPPeerAccess(IPAddr *client , time_t now ) ;
#line 48 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_core.c"
static LOG_FileID logfileid  ;
#line 217 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_core.c"
static ADF_AuthTable access_auth_table  ;
#line 222
static void transmit_timeout(void *arg ) ;
#line 226 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_core.c"
void NCR_Initialise(void) 
{ 
  LOG_FileID tmp___0 ;
  int tmp___1 ;

  {
  {
#line 229
  tmp___1 = CNF_GetLogMeasurements();
  }
#line 229
  if (tmp___1) {
    {
#line 229
    tmp___0 = LOG_FileOpen("measurements", "   Date (UTC) Time     IP Address   L St 1234 abc 5678 LP RP Score Offset     Peer del. Peer disp. Root del.  Root disp.");
#line 229
    logfileid = tmp___0;
    }
  } else {
#line 229
    logfileid = -1;
  }
  {
#line 233
  access_auth_table = ADF_CreateTable();
  }
#line 234
  return;
}
}
#line 238 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_core.c"
void NCR_Finalise(void) 
{ 


  {
  {
#line 241
  ADF_DestroyTable(access_auth_table);
  }
#line 243
  return;
}
}
#line 247 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_core.c"
static void start_initial_timeout(NCR_Instance inst ) 
{ 


  {
  {
#line 252
  inst->timeout_id = SCH_AddTimeoutInClass(0.2, 0.2, 0.02, (SCH_TimeoutClass )1, & transmit_timeout,
                                           (void *)inst);
#line 256
  inst->timer_running = 1;
  }
#line 257
  return;
}
}
#line 261 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_core.c"
static void take_offline(NCR_Instance inst ) 
{ 


  {
#line 264
  inst->opmode = (OperatingMode )0;
#line 265
  if (inst->timer_running) {
    {
#line 266
    SCH_RemoveTimeout(inst->timeout_id);
#line 267
    inst->timer_running = 0;
    }
  }
  {
#line 271
  SRC_ResetReachability(inst->source);
  }
#line 272
  return;
}
}
#line 276 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_core.c"
NCR_Instance NCR_GetInstance(NTP_Remote_Address *remote_addr , NTP_Source_Type type ,
                             SourceParameters *params ) 
{ 
  NCR_Instance result ;
  void *tmp ;
  uint32_t tmp___0 ;

  {
  {
#line 281
  tmp = malloc(sizeof(struct NCR_Instance_Record ));
#line 281
  result = (struct NCR_Instance_Record *)tmp;
#line 283
  result->remote_addr = *remote_addr;
  }
  {
#line 285
  if ((unsigned int )type == 0U) {
#line 285
    goto case_0;
  }
#line 288
  if ((unsigned int )type == 1U) {
#line 288
    goto case_1;
  }
#line 291
  goto switch_default;
  case_0: /* CIL Label */ 
#line 286
  result->mode = (NTP_Mode )3;
#line 287
  goto switch_break;
  case_1: /* CIL Label */ 
#line 289
  result->mode = (NTP_Mode )1;
#line 290
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 292
  __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_core.c",
                292U, "NCR_GetInstance");
  }
  switch_break: /* CIL Label */ ;
  }
#line 295
  result->minpoll = params->minpoll;
#line 296
  result->maxpoll = params->maxpoll;
#line 297
  result->min_stratum = params->min_stratum;
#line 299
  result->presend_minpoll = params->presend_minpoll;
#line 300
  result->presend_done = 0;
#line 302
  if (params->authkey == 0UL) {
#line 303
    result->do_auth = 0;
#line 304
    result->auth_key_id = 0UL;
  } else {
#line 306
    result->do_auth = 1;
#line 307
    result->auth_key_id = params->authkey;
  }
#line 310
  result->max_delay = params->max_delay;
#line 311
  result->max_delay_ratio = params->max_delay_ratio;
#line 312
  result->max_delay_dev_ratio = params->max_delay_dev_ratio;
#line 314
  result->tx_count = 0;
#line 316
  result->remote_orig.hi = (uint32_t )0;
#line 317
  result->remote_orig.lo = (uint32_t )0;
#line 319
  result->poll_target = params->poll_target;
#line 320
  result->poll_score = 0.0;
#line 322
  if (params->online) {
    {
#line 323
    start_initial_timeout(result);
#line 324
    result->opmode = (OperatingMode )1;
    }
  } else {
#line 326
    result->timer_running = 0;
#line 327
    result->timeout_id = (SCH_TimeoutID )0;
#line 328
    result->opmode = (OperatingMode )0;
  }
#line 331
  if (params->iburst) {
    {
#line 332
    NCR_InitiateSampleBurst(result, 4, 8);
    }
  }
  {
#line 335
  result->auto_offline = params->auto_offline;
#line 337
  result->local_poll = params->minpoll;
#line 338
  result->remote_poll = 0;
#line 339
  result->remote_stratum = 0;
#line 342
  tmp___0 = UTI_IPToRefid(& remote_addr->ip_addr);
#line 342
  result->source = SRC_CreateNewInstance(tmp___0, (SRC_Type )0, params->sel_option,
                                         & result->remote_addr.ip_addr);
#line 344
  result->local_rx.tv_sec = (__time_t )0;
#line 345
  result->local_rx.tv_usec = (__suseconds_t )0;
#line 346
  result->local_tx.tv_sec = (__time_t )0;
#line 347
  result->local_tx.tv_usec = (__suseconds_t )0;
#line 348
  result->local_ntp_tx.hi = (uint32_t )0;
#line 349
  result->local_ntp_tx.lo = (uint32_t )0;
  }
#line 351
  return (result);
}
}
#line 358 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_core.c"
void NCR_DestroyInstance(NCR_Instance instance ) 
{ 


  {
  {
#line 364
  SRC_DestroyInstance(instance->source);
  }
#line 367
  if (instance->timer_running) {
    {
#line 368
    SCH_RemoveTimeout(instance->timeout_id);
#line 369
    instance->timer_running = 0;
    }
  }
  {
#line 373
  free((void *)instance);
  }
#line 374
  return;
}
}
#line 378 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_core.c"
static int check_packet_auth(NTP_Packet *pkt , unsigned long keyid , int auth_len ) 
{ 
  int tmp ;

  {
  {
#line 381
  tmp = KEY_CheckAuth(keyid, (unsigned char const   *)((void *)pkt), (int )((unsigned long )(& ((NTP_Packet *)0)->auth_keyid)),
                      (unsigned char const   *)((void *)(& pkt->auth_data)), auth_len);
  }
#line 381
  return (tmp);
}
}
#line 387 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_core.c"
static void adjust_poll(NCR_Instance inst , double adj ) 
{ 


  {
#line 390
  inst->poll_score += adj;
#line 392
  if (inst->poll_score >= 1.0) {
#line 393
    inst->local_poll += (int )inst->poll_score;
#line 394
    inst->poll_score -= (double )((int )inst->poll_score);
  }
#line 397
  if (inst->poll_score < 0.0) {
#line 398
    inst->local_poll += (int )(inst->poll_score - 1.0);
#line 399
    inst->poll_score -= (double )((int )(inst->poll_score - 1.0));
  }
#line 403
  if (inst->local_poll < inst->minpoll) {
#line 404
    inst->local_poll = inst->minpoll;
#line 405
    inst->poll_score = (double )0;
  } else
#line 406
  if (inst->local_poll > inst->maxpoll) {
#line 407
    inst->local_poll = inst->maxpoll;
#line 408
    inst->poll_score = 1.0;
  }
#line 410
  return;
}
}
#line 414 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_core.c"
static double get_poll_adj(NCR_Instance inst , double error_in_estimate , double peer_distance ) 
{ 
  double poll_adj ;
  int shift ;
  unsigned long temp ;
  int samples___0 ;
  int tmp ;

  {
#line 419
  if (error_in_estimate > peer_distance) {
#line 420
    shift = 0;
#line 421
    temp = (unsigned long )((int )(error_in_estimate / peer_distance));
    {
#line 422
    while (1) {
      while_continue: /* CIL Label */ ;
#line 423
      shift ++;
#line 424
      temp >>= 1;
#line 422
      if (! temp) {
#line 422
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 427
    poll_adj = ((double )(- shift) - inst->poll_score) + 0.5;
  } else {
    {
#line 430
    tmp = SRC_Samples(inst->source);
#line 430
    samples___0 = tmp;
#line 434
    poll_adj = ((double )samples___0 / (double )inst->poll_target - 1.0) / (double )inst->poll_target;
    }
#line 437
    if (samples___0 < inst->poll_target) {
#line 438
      poll_adj *= 2.0;
    }
  }
#line 442
  return (poll_adj);
}
}
#line 447 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_core.c"
static double get_transmit_delay(NCR_Instance inst , int on_tx , double last_tx ) 
{ 
  int poll_to_use ;
  int stratum_diff ;
  double delay_time ;
  int tmp ;

  {
  {
#line 466
  if ((unsigned int )inst->opmode == 0U) {
#line 466
    goto case_0;
  }
#line 469
  if ((unsigned int )inst->opmode == 1U) {
#line 469
    goto case_1;
  }
#line 522
  if ((unsigned int )inst->opmode == 2U) {
#line 522
    goto case_2;
  }
#line 522
  if ((unsigned int )inst->opmode == 3U) {
#line 522
    goto case_2;
  }
#line 527
  goto switch_default___0;
  case_0: /* CIL Label */ 
  {
#line 467
  __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_core.c",
                467U, "get_transmit_delay");
  }
#line 468
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 474
  if ((unsigned int )inst->mode == 3U) {
#line 474
    goto case_3;
  }
#line 483
  if ((unsigned int )inst->mode == 1U) {
#line 483
    goto case_1___0;
  }
#line 515
  goto switch_default;
  case_3: /* CIL Label */ 
#line 477
  poll_to_use = inst->local_poll;
#line 479
  delay_time = (double )(1UL << poll_to_use);
#line 481
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
#line 489
  poll_to_use = inst->local_poll;
#line 490
  if (poll_to_use > inst->remote_poll) {
#line 491
    poll_to_use = inst->remote_poll;
  }
#line 492
  if (poll_to_use < inst->minpoll) {
#line 493
    poll_to_use = inst->minpoll;
  }
  {
#line 495
  delay_time = (double )(1UL << poll_to_use);
#line 502
  tmp = REF_GetOurStratum();
#line 502
  stratum_diff = inst->remote_stratum - tmp;
  }
#line 503
  if (stratum_diff > 0) {
#line 503
    if (last_tx * 1.1 < delay_time) {
#line 506
      delay_time *= 1.1;
    } else {
#line 503
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 503
  if (! on_tx) {
#line 503
    if (! stratum_diff) {
#line 503
      if (last_tx / delay_time > 1.1 - 0.5) {
#line 506
        delay_time *= 1.1;
      }
    }
  }
#line 509
  if (last_tx > 0.0) {
#line 510
    delay_time -= last_tx;
  }
#line 511
  if (delay_time < 0.0) {
#line 512
    delay_time = 0.0;
  }
#line 514
  goto switch_break___0;
  switch_default: /* CIL Label */ 
  {
#line 516
  __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_core.c",
                516U, "get_transmit_delay");
  }
#line 517
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 519
  goto switch_break;
  case_2: /* CIL Label */ 
  case_3___0: /* CIL Label */ 
#line 525
  if (on_tx) {
#line 525
    delay_time = 8.0;
  } else {
#line 525
    delay_time = 2.0;
  }
#line 526
  goto switch_break;
  switch_default___0: /* CIL Label */ 
  {
#line 528
  __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_core.c",
                528U, "get_transmit_delay");
  }
#line 529
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 532
  return (delay_time);
}
}
#line 537 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_core.c"
static void transmit_packet(NTP_Mode my_mode , int my_poll , int version , int do_auth ,
                            unsigned long key_id , NTP_int64 *orig_ts , struct timeval *local_rx ,
                            struct timeval *local_tx , NTP_int64 *local_ntp_tx , NTP_Remote_Address *where_to ) 
{ 
  NTP_Packet message ;
  int leap ;
  struct timeval local_transmit ;
  int are_we_synchronised___0 ;
  int our_stratum___0 ;
  NTP_Leap leap_status ;
  uint32_t our_ref_id___0 ;
  uint32_t ts_fuzz ;
  struct timeval our_ref_time___0 ;
  double our_root_delay___0 ;
  double our_root_dispersion___0 ;
  int tmp ;
  int auth_len ;
  int tmp___0 ;

  {
#line 569
  if (version > 3) {
#line 570
    version = 3;
  }
  {
#line 575
  SCH_GetLastEventTime(& local_transmit, (double *)((void *)0), (struct timeval *)((void *)0));
#line 577
  REF_GetReferenceParams(& local_transmit, & are_we_synchronised___0, & leap_status,
                         & our_stratum___0, & our_ref_id___0, & our_ref_time___0,
                         & our_root_delay___0, & our_root_dispersion___0);
  }
#line 583
  if (are_we_synchronised___0) {
#line 584
    leap = (int )leap_status;
  } else {
#line 586
    leap = 3;
  }
#line 590
  message.lvm = (uint8_t )((unsigned int )(((leap << 6) & 192) | ((version << 3) & 56)) | ((unsigned int )my_mode & 7U));
#line 591
  if (our_stratum___0 <= 15) {
#line 592
    message.stratum = (uint8_t )our_stratum___0;
  } else {
#line 595
    message.stratum = (uint8_t )0;
  }
  {
#line 598
  message.poll = (int8_t )my_poll;
#line 599
  tmp = LCL_GetSysPrecisionAsLog();
#line 599
  message.precision = (int8_t )tmp;
#line 603
  message.root_delay = UTI_DoubleToInt32(our_root_delay___0);
#line 604
  message.root_dispersion = UTI_DoubleToInt32(our_root_dispersion___0);
#line 606
  message.reference_id = htonl(our_ref_id___0);
#line 609
  UTI_TimevalToInt64(& our_ref_time___0, & message.reference_ts, (uint32_t )0);
#line 612
  message.originate_ts = *orig_ts;
#line 618
  UTI_TimevalToInt64(local_rx, & message.receive_ts, (uint32_t )0);
#line 621
  ts_fuzz = UTI_GetNTPTsFuzz((int )message.precision);
#line 626
  LCL_ReadCookedTime(& local_transmit, (double *)((void *)0));
  }
#line 629
  if (do_auth) {
    {
#line 633
    tmp___0 = KEY_GetAuthDelay(key_id);
#line 633
    local_transmit.tv_usec += (__suseconds_t )tmp___0;
#line 634
    UTI_NormaliseTimeval(& local_transmit);
#line 635
    UTI_TimevalToInt64(& local_transmit, & message.transmit_ts, ts_fuzz);
#line 637
    auth_len = KEY_GenerateAuth(key_id, (unsigned char const   *)((unsigned char *)(& message)),
                                (int )((unsigned long )(& ((NTP_Packet *)0)->auth_keyid)),
                                (unsigned char *)(& message.auth_data), (int )sizeof(message.auth_data));
    }
#line 640
    if (auth_len > 0) {
      {
#line 641
      message.auth_keyid = htonl((uint32_t )key_id);
#line 642
      NIO_SendAuthenticatedPacket(& message, where_to, (int )(sizeof(message.auth_keyid) + (unsigned long )auth_len));
      }
    }
  } else {
    {
#line 646
    UTI_TimevalToInt64(& local_transmit, & message.transmit_ts, ts_fuzz);
#line 647
    NIO_SendNormalPacket(& message, where_to);
    }
  }
#line 650
  if (local_tx) {
#line 651
    *local_tx = local_transmit;
  }
#line 654
  if (local_ntp_tx) {
#line 655
    *local_ntp_tx = message.transmit_ts;
  }
#line 658
  return;
}
}
#line 663 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_core.c"
static void transmit_timeout(void *arg ) 
{ 
  NCR_Instance inst ;
  double timeout_delay ;
  int do_auth ;
  double tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 666
  inst = (NCR_Instance )arg;
#line 670
  inst->timer_running = 0;
  {
#line 673
  if ((unsigned int )inst->opmode == 3U) {
#line 673
    goto case_3;
  }
#line 677
  if ((unsigned int )inst->opmode == 2U) {
#line 677
    goto case_2;
  }
#line 681
  goto switch_default;
  case_3: /* CIL Label */ 
#line 675
  if (inst->burst_total_samples_to_go <= 1) {
#line 676
    inst->opmode = (OperatingMode )1;
  }
  case_2: /* CIL Label */ 
#line 678
  if (inst->burst_total_samples_to_go <= 0) {
    {
#line 679
    take_offline(inst);
    }
  }
#line 680
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 682
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 685
  if ((unsigned int )inst->opmode == 0U) {
#line 686
    return;
  }
#line 699
  if (inst->presend_minpoll > 0) {
#line 699
    if (inst->presend_minpoll <= inst->local_poll) {
#line 699
      if (! inst->presend_done) {
        {
#line 704
        NIO_SendEcho(& inst->remote_addr);
#line 706
        inst->presend_done = 1;
#line 709
        inst->timer_running = 1;
#line 710
        inst->timeout_id = SCH_AddTimeoutInClass(4.0, 0.2, 0.02, (SCH_TimeoutClass )1,
                                                 & transmit_timeout, (void *)inst);
        }
#line 715
        return;
      }
    }
  }
#line 718
  inst->presend_done = 0;
#line 720
  (inst->tx_count) ++;
#line 726
  if (inst->tx_count >= 2) {
    {
#line 729
    tmp___1 = SRC_IsSyncPeer(inst->source);
    }
#line 729
    if (tmp___1) {
#line 729
      tmp___0 = 0.1;
    } else {
#line 729
      tmp___0 = 0.25;
    }
    {
#line 729
    adjust_poll(inst, tmp___0);
#line 731
    SRC_UpdateReachability(inst->source, 0);
    }
#line 733
    if (inst->auto_offline) {
#line 733
      if (inst->tx_count >= 3) {
        {
#line 734
        NCR_TakeSourceOffline(inst);
        }
      }
    }
  }
#line 738
  if (inst->do_auth) {
    {
#line 738
    tmp___2 = KEY_KeyKnown(inst->auth_key_id);
    }
#line 738
    if (tmp___2) {
#line 739
      do_auth = 1;
    } else {
#line 741
      do_auth = 0;
    }
  } else {
#line 741
    do_auth = 0;
  }
  {
#line 744
  transmit_packet(inst->mode, inst->local_poll, 3, do_auth, inst->auth_key_id, & inst->remote_orig,
                  & inst->local_rx, & inst->local_tx, & inst->local_ntp_tx, & inst->remote_addr);
  }
  {
#line 753
  if ((unsigned int )inst->opmode == 2U) {
#line 753
    goto case_2___0;
  }
#line 753
  if ((unsigned int )inst->opmode == 3U) {
#line 753
    goto case_2___0;
  }
#line 756
  goto switch_default___0;
  case_2___0: /* CIL Label */ 
  case_3___0: /* CIL Label */ 
#line 754
  (inst->burst_total_samples_to_go) --;
#line 755
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 757
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 761
  timeout_delay = get_transmit_delay(inst, 1, 0.0);
#line 762
  inst->timer_running = 1;
#line 763
  inst->timeout_id = SCH_AddTimeoutInClass(timeout_delay, 0.2, 0.02, (SCH_TimeoutClass )1,
                                           & transmit_timeout, (void *)inst);
  }
#line 767
  return;
}
}
#line 840
static void receive_packet(NTP_Packet *message , struct timeval *now , double now_err ,
                           NCR_Instance inst , int auth_len ) ;
#line 840 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_core.c"
static char sync_stats[4]  = {      (char )'N',      (char )'+',      (char )'-',      (char )'?'};
#line 772 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_core.c"
static void receive_packet(NTP_Packet *message , struct timeval *now , double now_err ,
                           NCR_Instance inst , int auth_len ) 
{ 
  int pkt_leap ;
  int source_is_synchronized ;
  double pkt_root_delay ;
  double pkt_root_dispersion ;
  unsigned long auth_key_id ;
  struct timeval sample_time ;
  double theta ;
  double delta ;
  double epsilon ;
  double peer_distance ;
  double root_delay ;
  double root_dispersion ;
  double skew ;
  double source_freq_lo ;
  double source_freq_hi ;
  struct timeval remote_receive_tv ;
  struct timeval remote_transmit_tv ;
  struct timeval remote_reference_tv ;
  struct timeval local_average ;
  struct timeval remote_average ;
  double local_interval ;
  double remote_interval ;
  int test1 ;
  int test2 ;
  int test3 ;
  int test4 ;
  int test5 ;
  int test6 ;
  int test7 ;
  int test7i ;
  int test7ii ;
  int test8 ;
  int test4a ;
  int test4b ;
  int test4c ;
  int valid_data ;
  int valid_header ;
  int good_data ;
  int good_header ;
  int kod_rate ;
  int valid_kod ;
  double estimated_offset ;
  double error_in_estimate ;
  double delay_time ;
  int requeue_transmit ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  int tmp___8 ;
  uint32_t tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  double tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  double tmp___23 ;
  double tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;

  {
#line 836
  kod_rate = 0;
#line 850
  delay_time = (double )0;
#line 851
  requeue_transmit = 0;
#line 856
  inst->local_rx = *now;
#line 858
  pkt_leap = ((int )message->lvm >> 6) & 3;
#line 859
  if (pkt_leap == 3) {
#line 860
    source_is_synchronized = 0;
  } else {
#line 862
    source_is_synchronized = 1;
  }
  {
#line 865
  pkt_root_delay = UTI_Int32ToDouble(message->root_delay);
#line 866
  pkt_root_dispersion = UTI_Int32ToDouble(message->root_dispersion);
  }
#line 873
  if (message->transmit_ts.hi == inst->remote_orig.hi) {
#line 873
    if (message->transmit_ts.lo == inst->remote_orig.lo) {
#line 875
      test1 = 0;
    } else {
#line 877
      test1 = 1;
    }
  } else {
#line 877
    test1 = 1;
  }
#line 882
  if (message->originate_ts.hi != inst->local_ntp_tx.hi) {
#line 884
    test2 = 0;
  } else
#line 882
  if (message->originate_ts.lo != inst->local_ntp_tx.lo) {
#line 884
    test2 = 0;
  } else {
#line 886
    test2 = 1;
  }
#line 895
  inst->remote_orig = message->transmit_ts;
#line 901
  if (message->originate_ts.hi == 0U) {
#line 901
    if (message->originate_ts.lo == 0U) {
#line 903
      test3 = 0;
    } else {
#line 901
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 901
  if (message->receive_ts.hi == 0U) {
#line 901
    if (message->receive_ts.lo == 0U) {
#line 903
      test3 = 0;
    } else {
#line 905
      test3 = 1;
    }
  } else {
#line 905
    test3 = 1;
  }
  {
#line 908
  SRC_GetFrequencyRange(inst->source, & source_freq_lo, & source_freq_hi);
#line 910
  UTI_Int64ToTimeval(& message->receive_ts, & remote_receive_tv);
#line 911
  UTI_Int64ToTimeval(& message->transmit_ts, & remote_transmit_tv);
  }
#line 913
  if (test3) {
    {
#line 915
    UTI_AverageDiffTimevals(& remote_receive_tv, & remote_transmit_tv, & remote_average,
                            & remote_interval);
#line 918
    UTI_AverageDiffTimevals(& inst->local_tx, now, & local_average, & local_interval);
#line 925
    delta = local_interval - remote_interval * (1.0 + source_freq_lo);
#line 930
    UTI_DiffTimevalsToDouble(& theta, & remote_average, & local_average);
#line 937
    sample_time = local_average;
#line 940
    skew = (source_freq_hi - source_freq_lo) / 2.0;
#line 943
    tmp = LCL_GetSysPrecisionAsQuantum();
#line 943
    tmp___0 = fabs(local_interval);
#line 943
    epsilon = (tmp + now_err) + skew * tmp___0;
    }
  } else {
#line 949
    epsilon = 0.0;
#line 949
    delta = epsilon;
#line 949
    theta = delta;
#line 950
    sample_time = *now;
  }
  {
#line 953
  tmp___1 = fabs(delta);
#line 953
  peer_distance = epsilon + 0.5 * tmp___1;
#line 958
  tmp___2 = fabs(delta);
  }
#line 958
  if (tmp___2 >= 16.0) {
#line 960
    test4 = 0;
  } else
#line 958
  if (epsilon >= 16.0) {
#line 960
    test4 = 0;
  } else {
#line 962
    test4 = 1;
  }
  {
#line 968
  tmp___3 = fabs(delta);
  }
#line 968
  if (tmp___3 > inst->max_delay) {
#line 969
    test4a = 0;
  } else {
#line 971
    test4a = 1;
  }
#line 978
  if (inst->max_delay_ratio > 1.0) {
    {
#line 978
    tmp___4 = SRC_MinRoundTripDelay(inst->source);
#line 978
    tmp___5 = fabs(delta / tmp___4);
    }
#line 978
    if (tmp___5 > inst->max_delay_ratio) {
#line 980
      test4b = 0;
    } else {
#line 982
      test4b = 1;
    }
  } else {
#line 982
    test4b = 1;
  }
  {
#line 990
  tmp___6 = LCL_GetMaxClockError();
#line 990
  tmp___7 = fabs(delta);
#line 990
  tmp___8 = SRC_IsGoodSample(inst->source, - theta, tmp___7, inst->max_delay_dev_ratio,
                             tmp___6, & sample_time);
  }
#line 990
  if (tmp___8) {
#line 994
    test4c = 1;
  } else {
#line 992
    test4c = 0;
  }
#line 998
  if (inst->do_auth) {
#line 999
    if (auth_len > 0) {
      {
#line 1000
      tmp___9 = ntohl(message->auth_keyid);
#line 1000
      auth_key_id = (unsigned long )tmp___9;
#line 1001
      tmp___10 = KEY_KeyKnown(auth_key_id);
      }
#line 1001
      if (tmp___10) {
        {
#line 1004
        test5 = check_packet_auth(message, auth_key_id, auth_len);
        }
      } else {
#line 1002
        test5 = 0;
      }
    } else {
#line 1009
      test5 = 0;
    }
  } else {
#line 1015
    test5 = 1;
  }
  {
#line 1022
  UTI_Int64ToTimeval(& message->reference_ts, & remote_reference_tv);
  }
#line 1023
  if (! source_is_synchronized) {
#line 1026
    test6 = 0;
  } else {
    {
#line 1023
    tmp___11 = UTI_CompareTimevals(& remote_reference_tv, & remote_transmit_tv);
    }
#line 1023
    if (tmp___11 == 1) {
#line 1026
      test6 = 0;
    } else
#line 1023
    if ((remote_reference_tv.tv_sec + 86400L) - remote_transmit_tv.tv_sec < 0L) {
#line 1026
      test6 = 0;
    } else {
#line 1028
      test6 = 1;
    }
  }
#line 1033
  if ((int )message->stratum <= 0) {
#line 1034
    message->stratum = (uint8_t )16;
  }
#line 1038
  if ((int )message->stratum < inst->min_stratum) {
#line 1039
    message->stratum = (uint8_t )inst->min_stratum;
  }
#line 1043
  if ((int )message->stratum > 15) {
#line 1044
    test7i = 0;
  } else {
#line 1046
    test7i = 1;
  }
  {
#line 1050
  tmp___12 = REF_GetOurStratum();
  }
#line 1050
  if ((int )message->stratum > tmp___12) {
#line 1051
    test7ii = 0;
  } else {
#line 1053
    test7ii = 1;
  }
#line 1056
  if (test7i) {
#line 1056
    if (test7ii) {
#line 1056
      tmp___13 = 1;
    } else {
#line 1056
      tmp___13 = 0;
    }
  } else {
#line 1056
    tmp___13 = 0;
  }
#line 1056
  test7 = tmp___13;
#line 1060
  if (pkt_root_delay >= 16.0) {
#line 1062
    test8 = 0;
  } else
#line 1060
  if (pkt_root_dispersion >= 16.0) {
#line 1062
    test8 = 0;
  } else {
#line 1064
    test8 = 1;
  }
#line 1068
  if (! test7i) {
#line 1068
    if (! source_is_synchronized) {
      {
#line 1069
      tmp___14 = memcmp((void const   *)(& message->reference_id), (void const   *)"RATE",
                        (size_t )4);
      }
#line 1069
      if (! tmp___14) {
#line 1070
        kod_rate = 1;
      }
    }
  }
#line 1073
  if (test1) {
#line 1073
    if (test2) {
#line 1073
      if (test5) {
#line 1073
        tmp___15 = 1;
      } else {
#line 1073
        tmp___15 = 0;
      }
    } else {
#line 1073
      tmp___15 = 0;
    }
  } else {
#line 1073
    tmp___15 = 0;
  }
#line 1073
  valid_kod = tmp___15;
#line 1075
  if (test1) {
#line 1075
    if (test2) {
#line 1075
      if (test3) {
#line 1075
        if (test4) {
#line 1075
          if (test4a) {
#line 1075
            if (test4b) {
#line 1075
              tmp___16 = 1;
            } else {
#line 1075
              tmp___16 = 0;
            }
          } else {
#line 1075
            tmp___16 = 0;
          }
        } else {
#line 1075
          tmp___16 = 0;
        }
      } else {
#line 1075
        tmp___16 = 0;
      }
    } else {
#line 1075
      tmp___16 = 0;
    }
  } else {
#line 1075
    tmp___16 = 0;
  }
#line 1075
  valid_data = tmp___16;
#line 1076
  if (valid_data) {
#line 1076
    if (test4c) {
#line 1076
      tmp___17 = 1;
    } else {
#line 1076
      tmp___17 = 0;
    }
  } else {
#line 1076
    tmp___17 = 0;
  }
#line 1076
  good_data = tmp___17;
#line 1077
  if (test5) {
#line 1077
    if (test6) {
#line 1077
      if (test7i) {
#line 1077
        if (test8) {
#line 1077
          tmp___18 = 1;
        } else {
#line 1077
          tmp___18 = 0;
        }
      } else {
#line 1077
        tmp___18 = 0;
      }
    } else {
#line 1077
      tmp___18 = 0;
    }
  } else {
#line 1077
    tmp___18 = 0;
  }
#line 1077
  valid_header = tmp___18;
#line 1078
  if (valid_header) {
#line 1078
    if (test7ii) {
#line 1078
      tmp___19 = 1;
    } else {
#line 1078
      tmp___19 = 0;
    }
  } else {
#line 1078
    tmp___19 = 0;
  }
  {
#line 1078
  good_header = tmp___19;
#line 1080
  tmp___20 = fabs(delta);
#line 1080
  root_delay = pkt_root_delay + tmp___20;
#line 1081
  root_dispersion = pkt_root_dispersion + epsilon;
  }
#line 1116
  if (kod_rate) {
#line 1116
    if (valid_kod) {
#line 1117
      if ((int )message->poll > inst->minpoll) {
#line 1118
        inst->minpoll = (int )message->poll;
#line 1119
        if (inst->minpoll > inst->maxpoll) {
#line 1120
          inst->maxpoll = inst->minpoll;
        }
#line 1121
        if (inst->minpoll > inst->local_poll) {
#line 1122
          inst->local_poll = inst->minpoll;
        }
        {
#line 1123
        LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_core.c",
                     1123, "receive_packet");
#line 1123
        tmp___21 = UTI_IPToString(& inst->remote_addr.ip_addr);
#line 1123
        LOG_Line_Function((LOG_Severity )1, (LOG_Facility )2, "Received KoD RATE from %s, minpoll set to %d",
                          tmp___21, inst->minpoll);
        }
      }
#line 1128
      if ((unsigned int )inst->opmode == 2U) {
        {
#line 1129
        inst->burst_good_samples_to_go = 0;
#line 1130
        LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_core.c",
                     1130, "receive_packet");
#line 1130
        tmp___22 = UTI_IPToString(& inst->remote_addr.ip_addr);
#line 1130
        LOG_Line_Function((LOG_Severity )1, (LOG_Facility )2, "Received KoD RATE from %s, burst sampling stopped",
                          tmp___22, inst->minpoll);
        }
      } else
#line 1128
      if ((unsigned int )inst->opmode == 3U) {
        {
#line 1129
        inst->burst_good_samples_to_go = 0;
#line 1130
        LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_core.c",
                     1130, "receive_packet");
#line 1130
        tmp___22 = UTI_IPToString(& inst->remote_addr.ip_addr);
#line 1130
        LOG_Line_Function((LOG_Severity )1, (LOG_Facility )2, "Received KoD RATE from %s, burst sampling stopped",
                          tmp___22, inst->minpoll);
        }
      }
#line 1134
      requeue_transmit = 1;
    }
  }
#line 1137
  if (valid_header) {
#line 1137
    if (valid_data) {
      {
#line 1138
      inst->remote_poll = (int )message->poll;
#line 1139
      inst->remote_stratum = (int )message->stratum;
#line 1140
      inst->tx_count = 0;
#line 1141
      SRC_UpdateReachability(inst->source, 1);
      }
#line 1146
      if (good_header) {
#line 1147
        if (good_data) {
          {
#line 1148
          SRC_SetSelectable(inst->source);
          }
        }
      } else {
        {
#line 1151
        SRC_UnsetSelectable(inst->source);
        }
      }
#line 1154
      if (good_data) {
        {
#line 1156
        estimated_offset = SRC_PredictOffset(inst->source, & sample_time);
#line 1158
        tmp___23 = fabs(delta);
#line 1158
        SRC_AccumulateSample(inst->source, & sample_time, theta, tmp___23, epsilon,
                             root_delay, root_dispersion, (int )message->stratum,
                             (NTP_Leap )pkt_leap);
#line 1168
        error_in_estimate = fabs(- theta - estimated_offset);
#line 1171
        tmp___24 = get_poll_adj(inst, error_in_estimate, peer_distance);
#line 1171
        adjust_poll(inst, tmp___24);
        }
        {
#line 1177
        if ((unsigned int )inst->opmode == 2U) {
#line 1177
          goto case_2;
        }
#line 1177
        if ((unsigned int )inst->opmode == 3U) {
#line 1177
          goto case_2;
        }
#line 1186
        goto switch_default;
        case_2: /* CIL Label */ 
        case_3: /* CIL Label */ 
#line 1178
        (inst->burst_good_samples_to_go) --;
#line 1179
        if (inst->burst_good_samples_to_go <= 0) {
#line 1180
          if ((unsigned int )inst->opmode == 3U) {
#line 1181
            inst->opmode = (OperatingMode )1;
          } else {
            {
#line 1183
            take_offline(inst);
            }
          }
        }
#line 1185
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 1187
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      } else {
        {
#line 1191
        adjust_poll(inst, 0.1);
        }
      }
#line 1194
      requeue_transmit = 1;
    }
  }
#line 1198
  if (requeue_transmit) {
#line 1198
    if ((unsigned int )inst->opmode != 0U) {
      {
#line 1199
      delay_time = get_transmit_delay(inst, 0, local_interval);
      }
#line 1201
      if (kod_rate) {
#line 1203
        delay_time += (double )(4UL * (1UL << inst->minpoll));
      }
#line 1207
      if (! inst->timer_running) {
        {
#line 1207
        __assert_fail("inst->timer_running", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_core.c",
                      1207U, "receive_packet");
        }
      }
      {
#line 1208
      SCH_RemoveTimeout(inst->timeout_id);
#line 1209
      inst->timeout_id = SCH_AddTimeoutInClass(delay_time, 0.2, 0.02, (SCH_TimeoutClass )1,
                                               & transmit_timeout, (void *)inst);
      }
    }
  }
#line 1216
  if (logfileid != -1) {
    {
#line 1217
    tmp___25 = UTI_IPToString(& inst->remote_addr.ip_addr);
#line 1217
    tmp___26 = UTI_TimeToLogForm(sample_time.tv_sec);
#line 1217
    LOG_FileWrite(logfileid, "%s %-15s %1c %2d %1d%1d%1d%1d %1d%1d%1d %1d%1d%1d%1d %2d %2d %4.2f %10.3e %10.3e %10.3e %10.3e %10.3e",
                  tmp___26, tmp___25, (int )sync_stats[pkt_leap], (int )message->stratum,
                  test1, test2, test3, test4, test4a, test4b, test4c, test5, test6,
                  test7, test8, inst->local_poll, inst->remote_poll, inst->poll_score,
                  theta, delta, epsilon, pkt_root_delay, pkt_root_dispersion);
    }
  }
#line 1230
  return;
}
}
#line 1256 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_core.c"
void NCR_ProcessKnown(NTP_Packet *message , struct timeval *now , double now_err ,
                      NCR_Instance inst , int length ) 
{ 
  int pkt_mode ;
  int version ;
  int valid_auth ;
  int valid_key ;
  int authenticate_reply ;
  int auth_len ;
  unsigned long auth_key_id ;
  unsigned long reply_auth_key_id ;
  uint32_t tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1273
  if ((unsigned int )inst->opmode == 0U) {
#line 1274
    return;
  }
#line 1278
  version = ((int )message->lvm >> 3) & 7;
#line 1279
  if (version < 1) {
#line 1281
    return;
  } else
#line 1279
  if (version > 4) {
#line 1281
    return;
  }
#line 1285
  pkt_mode = (int )message->lvm & 7;
#line 1288
  auth_len = (int )((unsigned long )length - ((unsigned long )(& ((NTP_Packet *)0)->auth_keyid) + sizeof(message->auth_keyid)));
#line 1289
  if (auth_len < 0) {
#line 1290
    auth_len = 0;
  }
  {
#line 1295
  if (pkt_mode == 3) {
#line 1295
    goto case_3;
  }
#line 1354
  if (pkt_mode == 1) {
#line 1354
    goto case_1;
  }
#line 1385
  if (pkt_mode == 4) {
#line 1385
    goto case_4___0;
  }
#line 1412
  if (pkt_mode == 2) {
#line 1412
    goto case_2___1;
  }
#line 1442
  if (pkt_mode == 5) {
#line 1442
    goto case_5___2;
  }
#line 1446
  goto switch_default___2;
  case_3: /* CIL Label */ 
  {
#line 1312
  tmp___2 = ADF_IsAllowed(access_auth_table, & inst->remote_addr.ip_addr);
  }
#line 1312
  if (tmp___2) {
    {
#line 1314
    CLG_LogNTPClientAccess(& inst->remote_addr.ip_addr, now->tv_sec);
    }
#line 1316
    if (auth_len > 0) {
      {
#line 1317
      tmp = ntohl(message->auth_keyid);
#line 1317
      auth_key_id = (unsigned long )tmp;
#line 1318
      valid_key = KEY_KeyKnown(auth_key_id);
      }
#line 1319
      if (valid_key) {
        {
#line 1320
        valid_auth = check_packet_auth(message, auth_key_id, auth_len);
        }
      } else {
#line 1322
        valid_auth = 0;
      }
#line 1325
      if (valid_key) {
#line 1325
        if (valid_auth) {
#line 1326
          authenticate_reply = 1;
#line 1327
          reply_auth_key_id = auth_key_id;
        } else {
#line 1329
          authenticate_reply = 0;
#line 1330
          reply_auth_key_id = 0UL;
        }
      } else {
#line 1329
        authenticate_reply = 0;
#line 1330
        reply_auth_key_id = 0UL;
      }
    } else {
#line 1333
      authenticate_reply = 0;
#line 1334
      reply_auth_key_id = 0UL;
    }
    {
#line 1337
    transmit_packet((NTP_Mode )4, inst->local_poll, version, authenticate_reply, reply_auth_key_id,
                    & message->transmit_ts, now, & inst->local_tx, & inst->local_ntp_tx,
                    & inst->remote_addr);
    }
  } else {
    {
#line 1346
    tmp___1 = LOG_RateLimited();
    }
#line 1346
    if (! tmp___1) {
      {
#line 1347
      LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_core.c",
                   1347, "NCR_ProcessKnown");
#line 1347
      tmp___0 = UTI_IPToString(& inst->remote_addr.ip_addr);
#line 1347
      LOG_Line_Function((LOG_Severity )1, (LOG_Facility )2, "NTP packet received from unauthorised host %s port %d",
                        tmp___0, (int )inst->remote_addr.port);
      }
    }
  }
#line 1352
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1357
  if ((unsigned int )inst->mode == 1U) {
#line 1357
    goto case_1___0;
  }
#line 1362
  if ((unsigned int )inst->mode == 2U) {
#line 1362
    goto case_2;
  }
#line 1366
  if ((unsigned int )inst->mode == 3U) {
#line 1366
    goto case_3___0;
  }
#line 1372
  if ((unsigned int )inst->mode == 4U) {
#line 1372
    goto case_4;
  }
#line 1375
  if ((unsigned int )inst->mode == 5U) {
#line 1375
    goto case_5;
  }
#line 1378
  goto switch_default;
  case_1___0: /* CIL Label */ 
  {
#line 1359
  CLG_LogNTPPeerAccess(& inst->remote_addr.ip_addr, now->tv_sec);
#line 1360
  receive_packet(message, now, now_err, inst, auth_len);
  }
#line 1361
  goto switch_break___0;
  case_2: /* CIL Label */ 
#line 1365
  goto switch_break___0;
  case_3___0: /* CIL Label */ 
  {
#line 1369
  CLG_LogNTPPeerAccess(& inst->remote_addr.ip_addr, now->tv_sec);
#line 1370
  receive_packet(message, now, now_err, inst, auth_len);
  }
#line 1371
  goto switch_break___0;
  case_4: /* CIL Label */ 
#line 1374
  goto switch_break___0;
  case_5: /* CIL Label */ 
#line 1377
  goto switch_break___0;
  switch_default: /* CIL Label */ 
#line 1380
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 1383
  goto switch_break;
  case_4___0: /* CIL Label */ 
  {
#line 1388
  if ((unsigned int )inst->mode == 1U) {
#line 1388
    goto case_1___1;
  }
#line 1393
  if ((unsigned int )inst->mode == 2U) {
#line 1393
    goto case_2___0;
  }
#line 1396
  if ((unsigned int )inst->mode == 3U) {
#line 1396
    goto case_3___1;
  }
#line 1400
  if ((unsigned int )inst->mode == 4U) {
#line 1400
    goto case_4___1;
  }
#line 1403
  if ((unsigned int )inst->mode == 5U) {
#line 1403
    goto case_5___0;
  }
#line 1406
  goto switch_default___0;
  case_1___1: /* CIL Label */ 
  {
#line 1390
  CLG_LogNTPPeerAccess(& inst->remote_addr.ip_addr, now->tv_sec);
#line 1391
  receive_packet(message, now, now_err, inst, auth_len);
  }
#line 1392
  goto switch_break___1;
  case_2___0: /* CIL Label */ 
#line 1395
  goto switch_break___1;
  case_3___1: /* CIL Label */ 
  {
#line 1398
  receive_packet(message, now, now_err, inst, auth_len);
  }
#line 1399
  goto switch_break___1;
  case_4___1: /* CIL Label */ 
#line 1402
  goto switch_break___1;
  case_5___0: /* CIL Label */ 
#line 1405
  goto switch_break___1;
  switch_default___0: /* CIL Label */ 
#line 1408
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 1410
  goto switch_break;
  case_2___1: /* CIL Label */ 
  {
#line 1415
  if ((unsigned int )inst->mode == 1U) {
#line 1415
    goto case_1___2;
  }
#line 1421
  if ((unsigned int )inst->mode == 2U) {
#line 1421
    goto case_2___2;
  }
#line 1426
  if ((unsigned int )inst->mode == 3U) {
#line 1426
    goto case_3___2;
  }
#line 1430
  if ((unsigned int )inst->mode == 4U) {
#line 1430
    goto case_4___2;
  }
#line 1433
  if ((unsigned int )inst->mode == 5U) {
#line 1433
    goto case_5___1;
  }
#line 1436
  goto switch_default___1;
  case_1___2: /* CIL Label */ 
  {
#line 1418
  CLG_LogNTPPeerAccess(& inst->remote_addr.ip_addr, now->tv_sec);
#line 1419
  receive_packet(message, now, now_err, inst, auth_len);
  }
#line 1420
  goto switch_break___2;
  case_2___2: /* CIL Label */ 
#line 1425
  goto switch_break___2;
  case_3___2: /* CIL Label */ 
  {
#line 1428
  receive_packet(message, now, now_err, inst, auth_len);
  }
#line 1429
  goto switch_break___2;
  case_4___2: /* CIL Label */ 
#line 1432
  goto switch_break___2;
  case_5___1: /* CIL Label */ 
#line 1435
  goto switch_break___2;
  switch_default___1: /* CIL Label */ 
#line 1438
  goto switch_break___2;
  switch_break___2: /* CIL Label */ ;
  }
#line 1440
  goto switch_break;
  case_5___2: /* CIL Label */ 
#line 1444
  goto switch_break;
  switch_default___2: /* CIL Label */ 
#line 1448
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1451
  return;
}
}
#line 1457 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_core.c"
void NCR_ProcessUnknown(NTP_Packet *message , struct timeval *now , double now_err ,
                        NTP_Remote_Address *remote_addr , int length ) 
{ 
  NTP_Mode his_mode ;
  NTP_Mode my_mode ;
  int my_poll ;
  int version ;
  int valid_key ;
  int valid_auth ;
  int auth_len ;
  unsigned long key_id ;
  int do_auth ;
  uint32_t tmp ;
  unsigned long tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1473
  version = ((int )message->lvm >> 3) & 7;
#line 1474
  if (version < 1) {
#line 1476
    return;
  } else
#line 1474
  if (version > 4) {
#line 1476
    return;
  }
  {
#line 1479
  tmp___3 = ADF_IsAllowed(access_auth_table, & remote_addr->ip_addr);
  }
#line 1479
  if (tmp___3) {
#line 1481
    his_mode = (NTP_Mode )((int )message->lvm & 7);
#line 1483
    if ((unsigned int )his_mode == 3U) {
      {
#line 1485
      my_mode = (NTP_Mode )4;
#line 1486
      CLG_LogNTPClientAccess(& remote_addr->ip_addr, now->tv_sec);
      }
    } else
#line 1488
    if ((unsigned int )his_mode == 1U) {
      {
#line 1490
      my_mode = (NTP_Mode )2;
#line 1491
      CLG_LogNTPPeerAccess(& remote_addr->ip_addr, now->tv_sec);
      }
    } else {
#line 1494
      my_mode = (NTP_Mode )0;
    }
#line 1500
    if ((unsigned int )my_mode != 0U) {
#line 1501
      do_auth = 0;
#line 1502
      auth_len = (int )((unsigned long )length - ((unsigned long )(& ((NTP_Packet *)0)->auth_keyid) + sizeof(message->auth_keyid)));
#line 1504
      if (auth_len > 0) {
        {
#line 1507
        tmp = ntohl(message->auth_keyid);
#line 1507
        key_id = (unsigned long )tmp;
#line 1508
        valid_key = KEY_KeyKnown(key_id);
#line 1509
        do_auth = 1;
        }
#line 1511
        if (valid_key) {
          {
#line 1512
          valid_auth = check_packet_auth(message, key_id, auth_len);
          }
        } else {
#line 1514
          valid_auth = 0;
        }
      }
#line 1518
      if (! do_auth) {
#line 1518
        goto _L;
      } else
#line 1518
      if (valid_key) {
#line 1518
        if (valid_auth) {
          _L: /* CIL Label */ 
#line 1519
          my_poll = (int )message->poll;
#line 1521
          if (do_auth) {
#line 1521
            tmp___0 = key_id;
          } else {
#line 1521
            tmp___0 = 0UL;
          }
          {
#line 1521
          transmit_packet(my_mode, my_poll, version, do_auth, tmp___0, & message->transmit_ts,
                          now, (struct timeval *)((void *)0), (NTP_int64 *)((void *)0),
                          remote_addr);
          }
        }
      }
    }
  } else {
    {
#line 1531
    tmp___2 = LOG_RateLimited();
    }
#line 1531
    if (! tmp___2) {
      {
#line 1532
      LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_core.c",
                   1532, "NCR_ProcessUnknown");
#line 1532
      tmp___1 = UTI_IPToString(& remote_addr->ip_addr);
#line 1532
      LOG_Line_Function((LOG_Severity )1, (LOG_Facility )2, "NTP packet received from unauthorised host %s port %d",
                        tmp___1, (int )remote_addr->port);
      }
    }
  }
#line 1536
  return;
}
}
#line 1540 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_core.c"
void NCR_SlewTimes(NCR_Instance inst , struct timeval *when , double dfreq , double doffset ) 
{ 
  struct timeval prev ;
  double delta ;

  {
#line 1545
  prev = inst->local_rx;
#line 1546
  if (inst->local_rx.tv_sec) {
    {
#line 1547
    UTI_AdjustTimeval(& inst->local_rx, when, & inst->local_rx, & delta, dfreq, doffset);
    }
  } else
#line 1546
  if (inst->local_rx.tv_usec) {
    {
#line 1547
    UTI_AdjustTimeval(& inst->local_rx, when, & inst->local_rx, & delta, dfreq, doffset);
    }
  }
#line 1552
  prev = inst->local_tx;
#line 1553
  if (inst->local_tx.tv_sec) {
    {
#line 1554
    UTI_AdjustTimeval(& inst->local_tx, when, & inst->local_tx, & delta, dfreq, doffset);
    }
  } else
#line 1553
  if (inst->local_tx.tv_usec) {
    {
#line 1554
    UTI_AdjustTimeval(& inst->local_tx, when, & inst->local_tx, & delta, dfreq, doffset);
    }
  }
#line 1561
  return;
}
}
#line 1565 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_core.c"
void NCR_TakeSourceOnline(NCR_Instance inst ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 1569
  if ((unsigned int )inst->opmode == 1U) {
#line 1569
    goto case_1;
  }
#line 1572
  if ((unsigned int )inst->opmode == 0U) {
#line 1572
    goto case_0;
  }
#line 1583
  if ((unsigned int )inst->opmode == 3U) {
#line 1583
    goto case_3;
  }
#line 1586
  if ((unsigned int )inst->opmode == 2U) {
#line 1586
    goto case_2;
  }
#line 1568
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1571
  goto switch_break;
  case_0: /* CIL Label */ 
#line 1573
  if (! inst->timer_running) {
    {
#line 1575
    LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_core.c",
                 1575, "NCR_TakeSourceOnline");
#line 1575
    tmp = UTI_IPToString(& inst->remote_addr.ip_addr);
#line 1575
    LOG_Line_Function((LOG_Severity )0, (LOG_Facility )2, "Source %s online", tmp);
#line 1576
    inst->tx_count = 0;
#line 1577
    inst->local_poll = inst->minpoll;
#line 1578
    inst->poll_score = 0.5;
#line 1579
    inst->opmode = (OperatingMode )1;
#line 1580
    start_initial_timeout(inst);
    }
  }
#line 1582
  goto switch_break;
  case_3: /* CIL Label */ 
#line 1585
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1587
  inst->opmode = (OperatingMode )3;
#line 1588
  LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_core.c",
               1588, "NCR_TakeSourceOnline");
#line 1588
  tmp___0 = UTI_IPToString(& inst->remote_addr.ip_addr);
#line 1588
  LOG_Line_Function((LOG_Severity )0, (LOG_Facility )2, "Source %s online", tmp___0);
  }
#line 1589
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1591
  return;
}
}
#line 1595 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_core.c"
void NCR_TakeSourceOffline(NCR_Instance inst ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 1599
  if ((unsigned int )inst->opmode == 1U) {
#line 1599
    goto case_1;
  }
#line 1605
  if ((unsigned int )inst->opmode == 0U) {
#line 1605
    goto case_0;
  }
#line 1607
  if ((unsigned int )inst->opmode == 3U) {
#line 1607
    goto case_3;
  }
#line 1611
  if ((unsigned int )inst->opmode == 2U) {
#line 1611
    goto case_2;
  }
#line 1598
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1600
  if (inst->timer_running) {
    {
#line 1601
    LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_core.c",
                 1601, "NCR_TakeSourceOffline");
#line 1601
    tmp = UTI_IPToString(& inst->remote_addr.ip_addr);
#line 1601
    LOG_Line_Function((LOG_Severity )0, (LOG_Facility )2, "Source %s offline", tmp);
#line 1602
    take_offline(inst);
    }
  }
#line 1604
  goto switch_break;
  case_0: /* CIL Label */ 
#line 1606
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 1608
  inst->opmode = (OperatingMode )2;
#line 1609
  LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_core.c",
               1609, "NCR_TakeSourceOffline");
#line 1609
  tmp___0 = UTI_IPToString(& inst->remote_addr.ip_addr);
#line 1609
  LOG_Line_Function((LOG_Severity )0, (LOG_Facility )2, "Source %s offline", tmp___0);
  }
#line 1610
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1612
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1615
  return;
}
}
#line 1619 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_core.c"
void NCR_ModifyMinpoll(NCR_Instance inst , int new_minpoll ) 
{ 
  char *tmp ;

  {
  {
#line 1622
  inst->minpoll = new_minpoll;
#line 1623
  LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_core.c",
               1623, "NCR_ModifyMinpoll");
#line 1623
  tmp = UTI_IPToString(& inst->remote_addr.ip_addr);
#line 1623
  LOG_Line_Function((LOG_Severity )0, (LOG_Facility )2, "Source %s new minpoll %d",
                    tmp, new_minpoll);
  }
#line 1624
  return;
}
}
#line 1628 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_core.c"
void NCR_ModifyMaxpoll(NCR_Instance inst , int new_maxpoll ) 
{ 
  char *tmp ;

  {
  {
#line 1631
  inst->maxpoll = new_maxpoll;
#line 1632
  LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_core.c",
               1632, "NCR_ModifyMaxpoll");
#line 1632
  tmp = UTI_IPToString(& inst->remote_addr.ip_addr);
#line 1632
  LOG_Line_Function((LOG_Severity )0, (LOG_Facility )2, "Source %s new maxpoll %d",
                    tmp, new_maxpoll);
  }
#line 1633
  return;
}
}
#line 1637 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_core.c"
void NCR_ModifyMaxdelay(NCR_Instance inst , double new_max_delay ) 
{ 
  char *tmp ;

  {
  {
#line 1640
  inst->max_delay = new_max_delay;
#line 1641
  LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_core.c",
               1641, "NCR_ModifyMaxdelay");
#line 1641
  tmp = UTI_IPToString(& inst->remote_addr.ip_addr);
#line 1641
  LOG_Line_Function((LOG_Severity )0, (LOG_Facility )2, "Source %s new max delay %f",
                    tmp, new_max_delay);
  }
#line 1643
  return;
}
}
#line 1647 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_core.c"
void NCR_ModifyMaxdelayratio(NCR_Instance inst , double new_max_delay_ratio ) 
{ 
  char *tmp ;

  {
  {
#line 1650
  inst->max_delay_ratio = new_max_delay_ratio;
#line 1651
  LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_core.c",
               1651, "NCR_ModifyMaxdelayratio");
#line 1651
  tmp = UTI_IPToString(& inst->remote_addr.ip_addr);
#line 1651
  LOG_Line_Function((LOG_Severity )0, (LOG_Facility )2, "Source %s new max delay ratio %f",
                    tmp, new_max_delay_ratio);
  }
#line 1653
  return;
}
}
#line 1657 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_core.c"
void NCR_ModifyMaxdelaydevratio(NCR_Instance inst , double new_max_delay_dev_ratio ) 
{ 
  char *tmp ;

  {
  {
#line 1660
  inst->max_delay_dev_ratio = new_max_delay_dev_ratio;
#line 1661
  LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_core.c",
               1661, "NCR_ModifyMaxdelaydevratio");
#line 1661
  tmp = UTI_IPToString(& inst->remote_addr.ip_addr);
#line 1661
  LOG_Line_Function((LOG_Severity )0, (LOG_Facility )2, "Source %s new max delay dev ratio %f",
                    tmp, new_max_delay_dev_ratio);
  }
#line 1663
  return;
}
}
#line 1667 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_core.c"
void NCR_ModifyMinstratum(NCR_Instance inst , int new_min_stratum ) 
{ 
  char *tmp ;

  {
  {
#line 1670
  inst->min_stratum = new_min_stratum;
#line 1671
  LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_core.c",
               1671, "NCR_ModifyMinstratum");
#line 1671
  tmp = UTI_IPToString(& inst->remote_addr.ip_addr);
#line 1671
  LOG_Line_Function((LOG_Severity )0, (LOG_Facility )2, "Source %s new minstratum %d",
                    tmp, new_min_stratum);
  }
#line 1673
  return;
}
}
#line 1677 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_core.c"
void NCR_ModifyPolltarget(NCR_Instance inst , int new_poll_target ) 
{ 
  char *tmp ;

  {
  {
#line 1680
  inst->poll_target = new_poll_target;
#line 1681
  LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_core.c",
               1681, "NCR_ModifyPolltarget");
#line 1681
  tmp = UTI_IPToString(& inst->remote_addr.ip_addr);
#line 1681
  LOG_Line_Function((LOG_Severity )0, (LOG_Facility )2, "Source %s new polltarget %d",
                    tmp, new_poll_target);
  }
#line 1683
  return;
}
}
#line 1687 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_core.c"
void NCR_InitiateSampleBurst(NCR_Instance inst , int n_good_samples , int n_total_samples ) 
{ 


  {
#line 1691
  if ((unsigned int )inst->mode == 3U) {
    {
#line 1701
    if ((unsigned int )inst->opmode == 3U) {
#line 1701
      goto case_3;
    }
#line 1701
    if ((unsigned int )inst->opmode == 2U) {
#line 1701
      goto case_3;
    }
#line 1706
    if ((unsigned int )inst->opmode == 0U) {
#line 1706
      goto case_0;
    }
#line 1706
    if ((unsigned int )inst->opmode == 1U) {
#line 1706
      goto case_0;
    }
#line 1722
    goto switch_default;
    case_3: /* CIL Label */ 
    case_2: /* CIL Label */ 
#line 1703
    goto switch_break;
    case_0: /* CIL Label */ 
    case_1: /* CIL Label */ 
#line 1707
    if ((unsigned int )inst->opmode == 1U) {
#line 1708
      inst->opmode = (OperatingMode )3;
    } else {
#line 1710
      inst->opmode = (OperatingMode )2;
    }
#line 1711
    inst->burst_good_samples_to_go = n_good_samples;
#line 1712
    inst->burst_total_samples_to_go = n_total_samples;
#line 1713
    if (inst->timer_running) {
      {
#line 1714
      SCH_RemoveTimeout(inst->timeout_id);
      }
    }
    {
#line 1716
    inst->timer_running = 1;
#line 1717
    inst->timeout_id = SCH_AddTimeoutInClass(0.2, 0.2, 0.02, (SCH_TimeoutClass )1,
                                             & transmit_timeout, (void *)inst);
    }
#line 1721
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1723
    __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_core.c",
                  1723U, "NCR_InitiateSampleBurst");
    }
#line 1724
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 1728
  return;
}
}
#line 1732 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_core.c"
void NCR_ReportSource(NCR_Instance inst , RPT_SourceReport *report , struct timeval *now ) 
{ 


  {
#line 1735
  report->poll = inst->local_poll;
  {
#line 1738
  if ((unsigned int )inst->mode == 3U) {
#line 1738
    goto case_3;
  }
#line 1741
  if ((unsigned int )inst->mode == 1U) {
#line 1741
    goto case_1;
  }
#line 1744
  goto switch_default;
  case_3: /* CIL Label */ 
#line 1739
  report->mode = (enum __anonenum_mode_80 )0;
#line 1740
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1742
  report->mode = (enum __anonenum_mode_80 )1;
#line 1743
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1745
  __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_core.c",
                1745U, "NCR_ReportSource");
  }
  switch_break: /* CIL Label */ ;
  }
#line 1747
  return;
}
}
#line 1751 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_core.c"
int NCR_AddAccessRestriction(IPAddr *ip_addr , int subnet_bits , int allow , int all ) 
{ 
  ADF_Status status___0 ;

  {
#line 1756
  if (allow) {
#line 1757
    if (all) {
      {
#line 1758
      status___0 = ADF_AllowAll(access_auth_table, ip_addr, subnet_bits);
      }
    } else {
      {
#line 1760
      status___0 = ADF_Allow(access_auth_table, ip_addr, subnet_bits);
      }
    }
  } else
#line 1763
  if (all) {
    {
#line 1764
    status___0 = ADF_DenyAll(access_auth_table, ip_addr, subnet_bits);
    }
  } else {
    {
#line 1766
    status___0 = ADF_Deny(access_auth_table, ip_addr, subnet_bits);
    }
  }
#line 1770
  if ((unsigned int )status___0 == 1U) {
#line 1771
    return (0);
  } else
#line 1772
  if ((unsigned int )status___0 == 0U) {
#line 1773
    return (1);
  } else {
#line 1775
    return (0);
  }
}
}
#line 1781 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_core.c"
int NCR_CheckAccessRestriction(IPAddr *ip_addr ) 
{ 
  int tmp ;

  {
  {
#line 1784
  tmp = ADF_IsAllowed(access_auth_table, ip_addr);
  }
#line 1784
  return (tmp);
}
}
#line 1789 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_core.c"
void NCR_IncrementActivityCounters(NCR_Instance inst , int *online , int *offline ,
                                   int *burst_online , int *burst_offline ) 
{ 


  {
  {
#line 1794
  if ((unsigned int )inst->opmode == 2U) {
#line 1794
    goto case_2;
  }
#line 1797
  if ((unsigned int )inst->opmode == 3U) {
#line 1797
    goto case_3;
  }
#line 1800
  if ((unsigned int )inst->opmode == 1U) {
#line 1800
    goto case_1;
  }
#line 1803
  if ((unsigned int )inst->opmode == 0U) {
#line 1803
    goto case_0;
  }
#line 1806
  goto switch_default;
  case_2: /* CIL Label */ 
#line 1795
  (*burst_offline) ++;
#line 1796
  goto switch_break;
  case_3: /* CIL Label */ 
#line 1798
  (*burst_online) ++;
#line 1799
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1801
  (*online) ++;
#line 1802
  goto switch_break;
  case_0: /* CIL Label */ 
#line 1804
  (*offline) ++;
#line 1805
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1807
  __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_core.c",
                1807U, "NCR_IncrementActivityCounters");
  }
#line 1808
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1810
  return;
}
}
#line 1814 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_core.c"
NTP_Remote_Address *NCR_GetRemoteAddress(NCR_Instance inst ) 
{ 


  {
#line 1817
  return (& inst->remote_addr);
}
}
#line 1822 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_core.c"
int NCR_IsSyncPeer(NCR_Instance inst ) 
{ 
  int tmp ;

  {
  {
#line 1824
  tmp = SRC_IsSyncPeer(inst->source);
  }
#line 1824
  return (tmp);
}
}
#line 36 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/manual.h"
int MNL_AcceptTimestamp(struct timeval *ts , long *offset_cs , double *dfreq_ppm ,
                        double *new_afreq_ppm ) ;
#line 38
void MNL_Enable(void) ;
#line 39
void MNL_Disable(void) ;
#line 40
void MNL_Reset(void) ;
#line 42
void MNL_ReportSamples(RPT_ManualSamplesReport *report , int max , int *n ) ;
#line 43
int MNL_DeleteSample(int index___0 ) ;
#line 121 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/local.h"
double LCL_ReadAbsoluteFrequency(void) ;
#line 61 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.h"
int CNF_GetManualEnabled(void) ;
#line 120 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.h"
void REF_SetManualReference(struct timeval *ref_time , double offset , double frequency ,
                            double skew ) ;
#line 108 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/regress.h"
int RGR_FindBestRobustRegression(double *x , double *y , int n , double tol , double *b0 ,
                                 double *b1 , int *n_runs___0 , int *best_start ) ;
#line 46 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/manual.c"
static int enabled  =    0;
#line 59 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/manual.c"
static Sample samples[16]  ;
#line 60 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/manual.c"
static int n_samples  ;
#line 62 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/manual.c"
static int replace_margin  ;
#line 63 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/manual.c"
static int error  ;
#line 71
static void slew_samples(struct timeval *raw , struct timeval *cooked , double dfreq ,
                         double doffset , int is_step_change , void *not_used ) ;
#line 81 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/manual.c"
void MNL_Initialise(void) 
{ 
  int tmp ;

  {
  {
#line 84
  tmp = CNF_GetManualEnabled();
  }
#line 84
  if (tmp) {
#line 85
    enabled = 1;
  } else {
#line 87
    enabled = 0;
  }
  {
#line 90
  n_samples = 0;
#line 92
  replace_margin = 300;
#line 93
  error = (int )0.2;
#line 95
  LCL_AddParameterChangeHandler(& slew_samples, (void *)0);
  }
#line 96
  return;
}
}
#line 100 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/manual.c"
void MNL_Finalise(void) 
{ 


  {
#line 103
  return;
}
}
#line 107 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/manual.c"
static void estimate_and_set_system(struct timeval *now , int offset_provided , double offset ,
                                    long *offset_cs , double *dfreq_ppm , double *new_afreq_ppm ) 
{ 
  double agos[16] ;
  double offsets[16] ;
  double b0 ;
  double b1 ;
  int n_runs___0 ;
  int best_start ;
  int i ;
  double freq ;
  double skew ;
  int found_freq ;
  double slew_by ;

  {
#line 114
  freq = 0.0;
#line 115
  skew = 0.099999999;
#line 119
  if (n_samples > 1) {
#line 120
    i = 0;
    {
#line 120
    while (1) {
      while_continue: /* CIL Label */ ;
#line 120
      if (! (i < n_samples)) {
#line 120
        goto while_break;
      }
      {
#line 121
      UTI_DiffTimevalsToDouble(& agos[i], & samples[n_samples - 1].when, & samples[i].when);
#line 122
      offsets[i] = samples[i].offset;
#line 120
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 125
    RGR_FindBestRobustRegression(agos, offsets, n_samples, 1.0e-8, & b0, & b1, & n_runs___0,
                                 & best_start);
#line 135
    freq = - b1;
#line 136
    found_freq = 1;
    }
  } else {
#line 138
    if (offset_provided) {
#line 139
      b0 = offset;
    } else {
#line 141
      b0 = 0.0;
    }
#line 143
    freq = 0.0;
#line 143
    b1 = freq;
#line 144
    found_freq = 0;
#line 145
    agos[0] = 0.0;
#line 146
    offsets[0] = b0;
  }
#line 149
  if (offset_provided) {
#line 150
    slew_by = offset;
  } else {
#line 152
    slew_by = b0;
  }
#line 155
  if (found_freq) {
    {
#line 156
    LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/manual.c",
                 156, "estimate_and_set_system");
#line 156
    LOG_Line_Function((LOG_Severity )0, (LOG_Facility )14, "Making a frequency change of %.3f ppm and a slew of %.6f",
                      1.0e6 * freq, slew_by);
#line 160
    REF_SetManualReference(now, slew_by, freq, skew);
    }
  } else {
    {
#line 164
    LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/manual.c",
                 164, "estimate_and_set_system");
#line 164
    LOG_Line_Function((LOG_Severity )0, (LOG_Facility )14, "Making a slew of %.6f",
                      slew_by);
#line 165
    REF_SetManualReference(now, slew_by, 0.0, skew);
    }
  }
#line 170
  if (offset_cs) {
#line 170
    *offset_cs = (long )(0.5 + 100.0 * b0);
  }
#line 171
  if (dfreq_ppm) {
#line 171
    *dfreq_ppm = 1.0e6 * freq;
  }
#line 172
  if (new_afreq_ppm) {
    {
#line 172
    *new_afreq_ppm = LCL_ReadAbsoluteFrequency();
    }
  }
#line 175
  i = 0;
  {
#line 175
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 175
    if (! (i < n_samples)) {
#line 175
      goto while_break___0;
    }
#line 176
    samples[i].residual = offsets[i] - (b0 + agos[i] * b1);
#line 175
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 179
  return;
}
}
#line 183 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/manual.c"
int MNL_AcceptTimestamp(struct timeval *ts , long *offset_cs , double *dfreq_ppm ,
                        double *new_afreq_ppm ) 
{ 
  struct timeval now ;
  double offset ;
  int i ;

  {
#line 190
  if (enabled) {
    {
#line 193
    LCL_ReadCookedTime(& now, (double *)((void *)0));
#line 195
    UTI_DiffTimevalsToDouble(& offset, & now, ts);
    }
#line 198
    if (n_samples == 16) {
#line 200
      i = 1;
      {
#line 200
      while (1) {
        while_continue: /* CIL Label */ ;
#line 200
        if (! (i < n_samples)) {
#line 200
          goto while_break;
        }
#line 201
        samples[i - 1] = samples[i];
#line 200
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 203
      n_samples --;
    }
    {
#line 206
    samples[n_samples].when = now;
#line 207
    samples[n_samples].offset = offset;
#line 208
    samples[n_samples].orig_offset = offset;
#line 209
    n_samples ++;
#line 211
    estimate_and_set_system(& now, 1, offset, offset_cs, dfreq_ppm, new_afreq_ppm);
    }
#line 213
    return (1);
  } else {
#line 217
    return (0);
  }
}
}
#line 224 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/manual.c"
static void slew_samples(struct timeval *raw , struct timeval *cooked , double dfreq ,
                         double doffset , int is_step_change , void *not_used ) 
{ 
  double delta_time ;
  int i ;

  {
#line 234
  i = 0;
  {
#line 234
  while (1) {
    while_continue: /* CIL Label */ ;
#line 234
    if (! (i < n_samples)) {
#line 234
      goto while_break;
    }
    {
#line 235
    UTI_AdjustTimeval(& samples[i].when, cooked, & samples[i].when, & delta_time,
                      dfreq, doffset);
#line 237
    samples[i].offset += delta_time;
#line 234
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 239
  return;
}
}
#line 243 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/manual.c"
void MNL_Enable(void) 
{ 


  {
#line 246
  enabled = 1;
#line 247
  return;
}
}
#line 252 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/manual.c"
void MNL_Disable(void) 
{ 


  {
#line 255
  enabled = 0;
#line 256
  return;
}
}
#line 260 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/manual.c"
void MNL_Reset(void) 
{ 


  {
#line 263
  n_samples = 0;
#line 264
  return;
}
}
#line 270 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/manual.c"
void MNL_ReportSamples(RPT_ManualSamplesReport *report , int max , int *n ) 
{ 
  int i ;

  {
#line 275
  if (n_samples > max) {
#line 276
    *n = max;
  } else {
#line 278
    *n = n_samples;
  }
#line 281
  i = 0;
  {
#line 281
  while (1) {
    while_continue: /* CIL Label */ ;
#line 281
    if (i < n_samples) {
#line 281
      if (! (i < max)) {
#line 281
        goto while_break;
      }
    } else {
#line 281
      goto while_break;
    }
#line 282
    (report + i)->when = samples[i].when;
#line 283
    (report + i)->slewed_offset = samples[i].offset;
#line 284
    (report + i)->orig_offset = samples[i].orig_offset;
#line 285
    (report + i)->residual = samples[i].residual;
#line 281
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 287
  return;
}
}
#line 293 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/manual.c"
int MNL_DeleteSample(int index___0 ) 
{ 
  int i ;
  struct timeval now ;

  {
#line 299
  if (index___0 < 0) {
#line 300
    return (0);
  } else
#line 299
  if (index___0 >= n_samples) {
#line 300
    return (0);
  }
#line 305
  i = index___0;
  {
#line 305
  while (1) {
    while_continue: /* CIL Label */ ;
#line 305
    if (! (i < n_samples - 1)) {
#line 305
      goto while_break;
    }
#line 306
    samples[i] = samples[i + 1];
#line 305
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 309
  n_samples --;
#line 313
  LCL_ReadCookedTime(& now, (double *)((void *)0));
#line 314
  estimate_and_set_system(& now, 0, 0.0, (long *)((void *)0), (double *)((void *)0),
                          (double *)((void *)0));
  }
#line 316
  return (1);
}
}
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 180 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rename)(char const   *__old ,
                                                                             char const   *__new ) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 50 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 284
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chmod)(char const   *__file ,
                                                                                            __mode_t __mode ) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 77
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) settimeofday)(struct timeval  const  *__tv ,
                                                                                   struct timezone  const  *__tz ) ;
#line 199 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) mktime)(struct tm *__tp ) ;
#line 239
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) gmtime)(time_t const   *__timer ) ;
#line 243
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 473 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chown)(char const   *__file ,
                                                                                            __uid_t __owner ,
                                                                                            __gid_t __group ) ;
#line 54 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sched.h"
void SCH_AddInputFileHandler(int fd___0 , void (*handler)(SCH_ArbitraryArgument  ) ,
                             SCH_ArbitraryArgument arg ) ;
#line 59
void SCH_RemoveInputFileHandler(int fd___0 ) ;
#line 144 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/local.h"
void LCL_AccumulateOffset(double offset , double corr_rate ) ;
#line 111 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/util.h"
void UTI_FdSetCloexec(int fd___0 ) ;
#line 31 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc_linux.h"
int RTC_Linux_Initialise(void) ;
#line 32
void RTC_Linux_Finalise(void) ;
#line 33
void RTC_Linux_TimePreInit(void) ;
#line 34
void RTC_Linux_TimeInit(void (*after_hook)(void * ) , void *anything ) ;
#line 35
void RTC_Linux_StartMeasurements(void) ;
#line 38
int RTC_Linux_WriteParameters(void) ;
#line 40
int RTC_Linux_GetReport(RPT_RTC_Report *report ) ;
#line 41
int RTC_Linux_Trim(void) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.h"
char *CNF_GetRtcDevice(void) ;
#line 53
int CNF_GetLogRtc(void) ;
#line 57
char *CNF_GetRtcFile(void) ;
#line 63
int CNF_GetRTCOnUTC(void) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc_linux.c"
static void measurement_timeout(void *any ) ;
#line 52
static void read_from_device(void *any ) ;
#line 62 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc_linux.c"
static OperatingMode operating_mode  =    (OperatingMode )0;
#line 66 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc_linux.c"
static int fd  =    -1;
#line 74 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc_linux.c"
static int measurement_period  =    15;
#line 76 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc_linux.c"
static int timeout_running  =    0;
#line 77 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc_linux.c"
static SCH_TimeoutID timeout_id  ;
#line 79 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc_linux.c"
static int skip_interrupts  ;
#line 90 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc_linux.c"
static time_t rtc_sec[64]  ;
#line 91 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc_linux.c"
static double rtc_trim[64]  ;
#line 94 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc_linux.c"
static time_t rtc_ref  ;
#line 99 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc_linux.c"
static struct timeval system_times[64]  ;
#line 102 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc_linux.c"
static int n_samples___0  ;
#line 105 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc_linux.c"
static int n_samples_since_regression  ;
#line 108 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc_linux.c"
static int n_runs  ;
#line 112 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc_linux.c"
static int coefs_valid  ;
#line 115 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc_linux.c"
static time_t coef_ref_time  ;
#line 117 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc_linux.c"
static double coef_seconds_fast  ;
#line 121 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc_linux.c"
static double coef_gain_rate  ;
#line 126 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc_linux.c"
static double saved_coef_gain_rate  ;
#line 130 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc_linux.c"
static char *coefs_file_name  ;
#line 136 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc_linux.c"
static int tried_to_load_coefs  =    0;
#line 139 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc_linux.c"
static int valid_coefs_from_file  =    0;
#line 142 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc_linux.c"
static time_t file_ref_time  ;
#line 143 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc_linux.c"
static double file_ref_offset  ;
#line 143 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc_linux.c"
static double file_rate_ppm  ;
#line 148 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc_linux.c"
static int rtc_on_utc  =    1;
#line 152 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc_linux.c"
static LOG_FileID logfileid___0  ;
#line 156 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc_linux.c"
static void (*after_init_hook)(void * )  =    (void (*)(void * ))((void *)0);
#line 157 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc_linux.c"
static void *after_init_hook_arg  =    (void *)0;
#line 161 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc_linux.c"
static void discard_samples(int new_first ) 
{ 
  int n_to_save ;

  {
#line 166
  if (new_first >= 0) {
#line 166
    if (! (new_first < n_samples___0)) {
      {
#line 166
      __assert_fail("new_first >= 0 && new_first < n_samples", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc_linux.c",
                    166U, "discard_samples");
      }
    }
  } else {
    {
#line 166
    __assert_fail("new_first >= 0 && new_first < n_samples", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc_linux.c",
                  166U, "discard_samples");
    }
  }
  {
#line 168
  n_to_save = n_samples___0 - new_first;
#line 170
  memmove((void *)(rtc_sec), (void const   *)(rtc_sec + new_first), (unsigned long )n_to_save * sizeof(time_t ));
#line 171
  memmove((void *)(rtc_trim), (void const   *)(rtc_trim + new_first), (unsigned long )n_to_save * sizeof(double ));
#line 172
  memmove((void *)(system_times), (void const   *)(system_times + new_first), (unsigned long )n_to_save * sizeof(struct timeval ));
#line 174
  n_samples___0 = n_to_save;
  }
#line 175
  return;
}
}
#line 181 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc_linux.c"
static void accumulate_sample(time_t rtc , struct timeval *sys ) 
{ 


  {
#line 185
  if (n_samples___0 == 64) {
    {
#line 187
    discard_samples(4);
    }
  }
#line 193
  if (n_samples___0 >= 0) {
#line 195
    rtc_ref = rtc;
#line 196
    rtc_sec[n_samples___0] = rtc;
#line 197
    rtc_trim[n_samples___0] = 0.0;
#line 198
    system_times[n_samples___0] = *sys;
#line 199
    n_samples_since_regression ++;
  }
#line 201
  n_samples___0 ++;
#line 202
  return;
}
}
#line 209 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc_linux.c"
static void run_regression(int new_sample , int *valid , time_t *ref , double *fast ,
                           double *slope ) 
{ 
  double rtc_rel[64] ;
  double offsets[64] ;
  int i ;
  double est_intercept ;
  double est_slope ;
  int best_new_start ;
  int tmp ;

  {
#line 222
  if (n_samples___0 > 0) {
#line 224
    i = 0;
    {
#line 224
    while (1) {
      while_continue: /* CIL Label */ ;
#line 224
      if (! (i < n_samples___0)) {
#line 224
        goto while_break;
      }
#line 225
      rtc_rel[i] = rtc_trim[i] + (double )(rtc_sec[i] - rtc_ref);
#line 226
      offsets[i] = ((double )(rtc_ref - system_times[i].tv_sec) - 1.0e-6 * (double )system_times[i].tv_usec) + rtc_rel[i];
#line 224
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 232
    tmp = RGR_FindBestRobustRegression(rtc_rel, offsets, n_samples___0, 1.0e-9, & est_intercept,
                                       & est_slope, & n_runs, & best_new_start);
    }
#line 232
    if (tmp) {
#line 241
      *valid = 1;
#line 242
      *ref = rtc_ref;
#line 243
      *fast = est_intercept;
#line 244
      *slope = est_slope;
#line 246
      if (best_new_start > 0) {
        {
#line 247
        discard_samples(best_new_start);
        }
      }
    }
  }
#line 258
  return;
}
}
#line 262 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc_linux.c"
static void slew_samples___0(struct timeval *raw , struct timeval *cooked , double dfreq ,
                             double doffset , int is_step_change , void *anything ) 
{ 
  int i ;
  double delta_time ;
  double old_seconds_fast ;
  double old_gain_rate ;

  {
#line 273
  i = 0;
  {
#line 273
  while (1) {
    while_continue: /* CIL Label */ ;
#line 273
    if (! (i < n_samples___0)) {
#line 273
      goto while_break;
    }
    {
#line 274
    UTI_AdjustTimeval(system_times + i, cooked, system_times + i, & delta_time, dfreq,
                      doffset);
#line 273
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 278
  old_seconds_fast = coef_seconds_fast;
#line 279
  old_gain_rate = coef_gain_rate;
#line 281
  if (coefs_valid) {
#line 282
    coef_seconds_fast += doffset;
#line 283
    coef_gain_rate = (1.0 + dfreq) * (1.0 + coef_gain_rate) - 1.0;
  }
#line 295
  return;
}
}
#line 303 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc_linux.c"
static struct tm *rtc_from_t(time_t const   *t ) 
{ 
  struct tm *tmp ;
  struct tm *tmp___0 ;

  {
#line 306
  if (rtc_on_utc) {
    {
#line 307
    tmp = gmtime(t);
    }
#line 307
    return (tmp);
  } else {
    {
#line 309
    tmp___0 = localtime(t);
    }
#line 309
    return (tmp___0);
  }
}
}
#line 347 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc_linux.c"
static time_t t_from_rtc(struct tm *stm ) 
{ 
  struct tm temp1 ;
  struct tm temp2 ;
  long diff ;
  time_t t1 ;
  time_t t2 ;
  struct tm *tmp ;
  struct tm *tmp___0 ;

  {
  {
#line 353
  temp1 = *stm;
#line 354
  temp1.tm_isdst = 0;
#line 356
  t1 = mktime(& temp1);
  }
#line 357
  if (rtc_on_utc) {
    {
#line 358
    tmp = gmtime((time_t const   *)(& t1));
#line 358
    temp2 = *tmp;
    }
  } else {
    {
#line 360
    tmp___0 = localtime((time_t const   *)(& t1));
#line 360
    temp2 = *tmp___0;
    }
  }
  {
#line 363
  temp2.tm_isdst = 0;
#line 364
  t2 = mktime(& temp2);
#line 365
  diff = t2 - t1;
  }
#line 367
  return (t1 - diff);
}
}
#line 372 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc_linux.c"
static void setup_config(void) 
{ 
  int tmp ;

  {
  {
#line 375
  tmp = CNF_GetRTCOnUTC();
  }
#line 375
  if (tmp) {
#line 376
    rtc_on_utc = 1;
  } else {
#line 378
    rtc_on_utc = 0;
  }
#line 380
  return;
}
}
#line 386 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc_linux.c"
static void read_coefs_from_file(void) 
{ 
  FILE *in ;
  char line___0[256] ;
  int tmp ;
  char *tmp___0 ;

  {
#line 392
  if (! tried_to_load_coefs) {
    {
#line 394
    valid_coefs_from_file = 0;
#line 396
    tried_to_load_coefs = 1;
#line 398
    in = fopen((char const   */* __restrict  */)coefs_file_name, (char const   */* __restrict  */)"r");
    }
#line 399
    if (in) {
      {
#line 400
      tmp___0 = fgets((char */* __restrict  */)(line___0), (int )sizeof(line___0),
                      (FILE */* __restrict  */)in);
      }
#line 400
      if (tmp___0) {
        {
#line 401
        tmp = sscanf((char const   */* __restrict  */)(line___0), (char const   */* __restrict  */)"%d%ld%lf%lf",
                     & valid_coefs_from_file, & file_ref_time, & file_ref_offset,
                     & file_rate_ppm);
        }
#line 401
        if (! (tmp == 4)) {
          {
#line 407
          LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc_linux.c",
                       407, "read_coefs_from_file");
#line 407
          LOG_Line_Function((LOG_Severity )1, (LOG_Facility )25, "Could not parse coefficients line from RTC file %s",
                            coefs_file_name);
          }
        }
      } else {
        {
#line 411
        LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc_linux.c",
                     411, "read_coefs_from_file");
#line 411
        LOG_Line_Function((LOG_Severity )1, (LOG_Facility )25, "Could not read first line from RTC file %s",
                          coefs_file_name);
        }
      }
      {
#line 414
      fclose(in);
      }
    } else {
      {
#line 416
      LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc_linux.c",
                   416, "read_coefs_from_file");
#line 416
      LOG_Line_Function((LOG_Severity )1, (LOG_Facility )25, "Could not open RTC file %s for reading",
                        coefs_file_name);
      }
    }
  }
#line 420
  return;
}
}
#line 426 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc_linux.c"
static int write_coefs_to_file(int valid , time_t ref_time , double offset , double rate ) 
{ 
  struct stat buf ;
  char *temp_coefs_file_name ;
  FILE *out ;
  size_t tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 435
  tmp = strlen((char const   *)coefs_file_name);
#line 435
  tmp___0 = malloc(tmp + 8UL);
#line 435
  temp_coefs_file_name = (char *)tmp___0;
  }
#line 437
  if (! temp_coefs_file_name) {
#line 438
    return (2);
  }
  {
#line 441
  strcpy((char */* __restrict  */)temp_coefs_file_name, (char const   */* __restrict  */)coefs_file_name);
#line 442
  strcat((char */* __restrict  */)temp_coefs_file_name, (char const   */* __restrict  */)".tmp");
#line 444
  out = fopen((char const   */* __restrict  */)temp_coefs_file_name, (char const   */* __restrict  */)"w");
  }
#line 445
  if (! out) {
    {
#line 446
    free((void *)temp_coefs_file_name);
#line 447
    LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc_linux.c",
                 447, "write_coefs_to_file");
#line 447
    LOG_Line_Function((LOG_Severity )1, (LOG_Facility )25, "Could not open temporary RTC file %s.tmp for writing",
                      coefs_file_name);
    }
#line 449
    return (2);
  }
  {
#line 453
  tmp___1 = fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%1d %ld %.6f %.3f\n",
                    valid, ref_time, offset, 1.0e6 * rate);
#line 453
  tmp___2 = fclose(out);
  }
#line 453
  if ((tmp___1 < 0) | tmp___2) {
    {
#line 456
    free((void *)temp_coefs_file_name);
#line 457
    LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc_linux.c",
                 457, "write_coefs_to_file");
#line 457
    LOG_Line_Function((LOG_Severity )1, (LOG_Facility )25, "Could not write to temporary RTC file %s.tmp",
                      coefs_file_name);
    }
#line 459
    return (2);
  }
  {
#line 464
  tmp___4 = stat((char const   */* __restrict  */)coefs_file_name, (struct stat */* __restrict  */)(& buf));
  }
#line 464
  if (! tmp___4) {
    {
#line 465
    tmp___3 = chown((char const   *)temp_coefs_file_name, buf.st_uid, buf.st_gid);
    }
#line 465
    if (tmp___3) {
      {
#line 466
      LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc_linux.c",
                   466, "write_coefs_to_file");
#line 466
      LOG_Line_Function((LOG_Severity )1, (LOG_Facility )25, "Could not change ownership of temporary RTC file %s.tmp",
                        coefs_file_name);
      }
    }
    {
#line 468
    chmod((char const   *)temp_coefs_file_name, buf.st_mode & 511U);
    }
  }
  {
#line 473
  tmp___5 = rename((char const   *)temp_coefs_file_name, (char const   *)coefs_file_name);
  }
#line 473
  if (tmp___5) {
    {
#line 474
    unlink((char const   *)temp_coefs_file_name);
#line 475
    free((void *)temp_coefs_file_name);
#line 476
    LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc_linux.c",
                 476, "write_coefs_to_file");
#line 476
    LOG_Line_Function((LOG_Severity )1, (LOG_Facility )25, "Could not replace old RTC file %s.tmp with new one %s",
                      coefs_file_name, coefs_file_name);
    }
#line 478
    return (2);
  }
  {
#line 481
  free((void *)temp_coefs_file_name);
  }
#line 483
  return (0);
}
}
#line 492 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc_linux.c"
int RTC_Linux_Initialise(void) 
{ 
  char *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  LOG_FileID tmp___4 ;
  int tmp___5 ;

  {
  {
#line 496
  setup_config();
#line 499
  coefs_file_name = CNF_GetRtcFile();
#line 503
  tmp = CNF_GetRtcDevice();
#line 503
  fd = open((char const   *)tmp, 2);
  }
#line 504
  if (fd < 0) {
    {
#line 505
    LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc_linux.c",
                 505, "RTC_Linux_Initialise");
#line 505
    tmp___0 = __errno_location();
#line 505
    tmp___1 = strerror(*tmp___0);
#line 505
    tmp___2 = CNF_GetRtcDevice();
#line 505
    LOG_Line_Function((LOG_Severity )2, (LOG_Facility )25, "Could not open %s, %s",
                      tmp___2, tmp___1);
    }
#line 506
    return (0);
  }
  {
#line 510
  UTI_FdSetCloexec(fd);
#line 512
  n_samples___0 = 0;
#line 513
  n_samples_since_regression = 0;
#line 514
  n_runs = 0;
#line 515
  coefs_valid = 0;
#line 517
  measurement_period = 15;
#line 519
  operating_mode = (OperatingMode )0;
#line 522
  SCH_AddInputFileHandler(fd, & read_from_device, (void *)0);
#line 525
  LCL_AddParameterChangeHandler(& slew_samples___0, (void *)0);
#line 527
  tmp___5 = CNF_GetLogRtc();
  }
#line 527
  if (tmp___5) {
    {
#line 527
    tmp___4 = LOG_FileOpen("rtc", "   Date (UTC) Time   RTC fast (s) Val   Est fast (s)   Slope (ppm)  Ns  Nr Meas");
#line 527
    logfileid___0 = tmp___4;
    }
  } else {
#line 527
    logfileid___0 = -1;
  }
#line 530
  return (1);
}
}
#line 535 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc_linux.c"
void RTC_Linux_Finalise(void) 
{ 


  {
#line 538
  if (timeout_running) {
    {
#line 539
    SCH_RemoveTimeout(timeout_id);
#line 540
    timeout_running = 0;
    }
  }
#line 544
  if (fd >= 0) {
    {
#line 545
    SCH_RemoveInputFileHandler(fd);
#line 546
    close(fd);
#line 549
    RTC_Linux_WriteParameters();
    }
  }
#line 552
  return;
}
}
#line 556 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc_linux.c"
static void switch_interrupts(int onoff ) 
{ 
  int status___0 ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;

  {
#line 561
  if (onoff) {
    {
#line 562
    status___0 = ioctl(fd, (unsigned long )((unsigned int )(112 << 8) | 3U), 0);
    }
#line 563
    if (status___0 < 0) {
      {
#line 564
      LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc_linux.c",
                   564, "switch_interrupts");
#line 564
      tmp = __errno_location();
#line 564
      tmp___0 = strerror(*tmp);
#line 564
      LOG_Line_Function((LOG_Severity )2, (LOG_Facility )25, "Could not start measurement : %s",
                        tmp___0);
      }
#line 565
      return;
    }
#line 567
    skip_interrupts = 1;
  } else {
    {
#line 569
    status___0 = ioctl(fd, (unsigned long )((unsigned int )(112 << 8) | 4U), 0);
    }
#line 570
    if (status___0 < 0) {
      {
#line 571
      LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc_linux.c",
                   571, "switch_interrupts");
#line 571
      tmp___1 = __errno_location();
#line 571
      tmp___2 = strerror(*tmp___1);
#line 571
      LOG_Line_Function((LOG_Severity )2, (LOG_Facility )25, "Could not stop measurement : %s",
                        tmp___2);
      }
#line 572
      return;
    }
  }
#line 575
  return;
}
}
#line 579 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc_linux.c"
static void measurement_timeout(void *any ) 
{ 


  {
  {
#line 582
  timeout_running = 0;
#line 583
  switch_interrupts(1);
  }
#line 584
  return;
}
}
#line 588 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc_linux.c"
static void set_rtc(time_t new_rtc_time ) 
{ 
  struct tm rtc_tm ;
  struct rtc_time rtc_raw ;
  int status___0 ;
  struct tm *tmp ;

  {
  {
#line 595
  tmp = rtc_from_t((time_t const   *)(& new_rtc_time));
#line 595
  rtc_tm = *tmp;
#line 597
  rtc_raw.tm_sec = rtc_tm.tm_sec;
#line 598
  rtc_raw.tm_min = rtc_tm.tm_min;
#line 599
  rtc_raw.tm_hour = rtc_tm.tm_hour;
#line 600
  rtc_raw.tm_mday = rtc_tm.tm_mday;
#line 601
  rtc_raw.tm_mon = rtc_tm.tm_mon;
#line 602
  rtc_raw.tm_year = rtc_tm.tm_year;
#line 603
  rtc_raw.tm_wday = rtc_tm.tm_wday;
#line 604
  rtc_raw.tm_yday = rtc_tm.tm_yday;
#line 605
  rtc_raw.tm_isdst = rtc_tm.tm_isdst;
#line 607
  status___0 = ioctl(fd, (unsigned long )(((1U << 30) | (unsigned int )(112 << 8)) | 10U) | (sizeof(struct rtc_time ) << 16),
                     & rtc_raw);
  }
#line 608
  if (status___0 < 0) {
    {
#line 609
    LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc_linux.c",
                 609, "set_rtc");
#line 609
    LOG_Line_Function((LOG_Severity )2, (LOG_Facility )25, "Could not set RTC time");
    }
  }
#line 612
  return;
}
}
#line 616 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc_linux.c"
static void handle_initial_trim(void) 
{ 
  double rate ;
  long delta_time ;
  double rtc_error_now ;
  double sys_error_now ;

  {
  {
#line 631
  run_regression(1, & coefs_valid, & coef_ref_time, & coef_seconds_fast, & coef_gain_rate);
#line 633
  n_samples_since_regression = 0;
#line 637
  n_samples___0 = -1;
#line 640
  read_coefs_from_file();
  }
#line 642
  if (valid_coefs_from_file) {
    {
#line 644
    delta_time = coef_ref_time - file_ref_time;
#line 645
    rate = 1.0e-6 * file_rate_ppm;
#line 646
    rtc_error_now = file_ref_offset + rate * (double )delta_time;
#line 649
    sys_error_now = rtc_error_now - coef_seconds_fast;
#line 651
    LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc_linux.c",
                 651, "handle_initial_trim");
#line 651
    LOG_Line_Function((LOG_Severity )0, (LOG_Facility )25, "System trim from RTC = %f",
                      sys_error_now);
#line 652
    LCL_AccumulateOffset(sys_error_now, 0.0);
    }
  } else {
    {
#line 654
    LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc_linux.c",
                 654, "handle_initial_trim");
#line 654
    LOG_Line_Function((LOG_Severity )1, (LOG_Facility )25, "No valid file coefficients, cannot trim system time");
    }
  }
  {
#line 657
  coefs_valid = 0;
#line 659
  (*after_init_hook)(after_init_hook_arg);
#line 661
  operating_mode = (OperatingMode )0;
  }
#line 662
  return;
}
}
#line 666 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc_linux.c"
static void handle_relock_after_trim(void) 
{ 
  int valid ;
  time_t ref ;
  double fast ;
  double slope ;

  {
  {
#line 673
  run_regression(1, & valid, & ref, & fast, & slope);
  }
#line 675
  if (valid) {
    {
#line 676
    write_coefs_to_file(1, ref, fast, saved_coef_gain_rate);
    }
  } else {
    {
#line 678
    LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc_linux.c",
                 678, "handle_relock_after_trim");
#line 678
    LOG_Line_Function((LOG_Severity )1, (LOG_Facility )25, "Could not do regression after trim");
    }
  }
#line 681
  coefs_valid = 0;
#line 682
  n_samples___0 = 0;
#line 683
  n_samples_since_regression = 0;
#line 684
  operating_mode = (OperatingMode )0;
#line 685
  measurement_period = 15;
#line 686
  return;
}
}
#line 693 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc_linux.c"
static void process_reading(time_t rtc_time , struct timeval *system_time ) 
{ 
  double rtc_fast ;
  char *tmp ;

  {
  {
#line 698
  accumulate_sample(rtc_time, system_time);
  }
  {
#line 701
  if ((unsigned int )operating_mode == 0U) {
#line 701
    goto case_0;
  }
#line 709
  if ((unsigned int )operating_mode == 1U) {
#line 709
    goto case_1;
  }
#line 714
  if ((unsigned int )operating_mode == 2U) {
#line 714
    goto case_2;
  }
#line 719
  goto switch_default;
  case_0: /* CIL Label */ 
#line 703
  if (n_samples_since_regression >= 1) {
    {
#line 704
    run_regression(1, & coefs_valid, & coef_ref_time, & coef_seconds_fast, & coef_gain_rate);
#line 705
    n_samples_since_regression = 0;
    }
  }
#line 708
  goto switch_break;
  case_1: /* CIL Label */ 
#line 710
  if (n_samples_since_regression >= 8) {
    {
#line 711
    handle_initial_trim();
    }
  }
#line 713
  goto switch_break;
  case_2: /* CIL Label */ 
#line 715
  if (n_samples_since_regression >= 8) {
    {
#line 716
    handle_relock_after_trim();
    }
  }
#line 718
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 720
  __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc_linux.c",
                720U, "process_reading");
  }
#line 721
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 725
  if (logfileid___0 != -1) {
    {
#line 726
    rtc_fast = (double )(rtc_time - system_time->tv_sec) - 1.0e-6 * (double )system_time->tv_usec;
#line 728
    tmp = UTI_TimeToLogForm(system_time->tv_sec);
#line 728
    LOG_FileWrite(logfileid___0, "%s %14.6f %1d  %14.6f  %12.3f  %2d  %2d %4d", tmp,
                  rtc_fast, coefs_valid, coef_seconds_fast, coef_gain_rate * 1.0e6,
                  n_samples___0, n_runs, measurement_period);
    }
  }
#line 735
  return;
}
}
#line 739 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc_linux.c"
static void read_from_device(void *any ) 
{ 
  int status___0 ;
  unsigned long data ;
  struct timeval sys_time ;
  struct rtc_time rtc_raw ;
  struct tm rtc_tm ;
  time_t rtc_t ;
  int error___0 ;
  ssize_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 748
  error___0 = 0;
#line 750
  tmp = read(fd, (void *)(& data), sizeof(data));
#line 750
  status___0 = (int )tmp;
  }
#line 752
  if (status___0 < 0) {
    {
#line 755
    LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc_linux.c",
                 755, "read_from_device");
#line 755
    tmp___0 = __errno_location();
#line 755
    tmp___1 = strerror(*tmp___0);
#line 755
    tmp___2 = CNF_GetRtcDevice();
#line 755
    LOG_Line_Function((LOG_Severity )2, (LOG_Facility )25, "Could not read flags %s : %s",
                      tmp___2, tmp___1);
#line 756
    error___0 = 1;
#line 757
    SCH_RemoveInputFileHandler(fd);
#line 758
    switch_interrupts(0);
#line 759
    close(fd);
#line 760
    fd = -1;
    }
#line 761
    return;
  }
#line 764
  if (skip_interrupts > 0) {
#line 766
    skip_interrupts --;
#line 767
    return;
  }
#line 770
  if ((data & 16UL) == 16UL) {
    {
#line 776
    SCH_GetLastEventTime(& sys_time, (double *)((void *)0), (struct timeval *)((void *)0));
#line 778
    status___0 = ioctl(fd, (unsigned long )(((2U << 30) | (unsigned int )(112 << 8)) | 9U) | (sizeof(struct rtc_time ) << 16),
                       & rtc_raw);
    }
#line 779
    if (status___0 < 0) {
      {
#line 780
      LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc_linux.c",
                   780, "read_from_device");
#line 780
      tmp___3 = __errno_location();
#line 780
      tmp___4 = strerror(*tmp___3);
#line 780
      tmp___5 = CNF_GetRtcDevice();
#line 780
      LOG_Line_Function((LOG_Severity )2, (LOG_Facility )25, "Could not read time from %s : %s",
                        tmp___5, tmp___4);
#line 781
      error___0 = 1;
      }
#line 782
      goto turn_off_interrupt;
    }
    {
#line 786
    rtc_tm.tm_sec = rtc_raw.tm_sec;
#line 787
    rtc_tm.tm_min = rtc_raw.tm_min;
#line 788
    rtc_tm.tm_hour = rtc_raw.tm_hour;
#line 789
    rtc_tm.tm_mday = rtc_raw.tm_mday;
#line 790
    rtc_tm.tm_mon = rtc_raw.tm_mon;
#line 791
    rtc_tm.tm_year = rtc_raw.tm_year;
#line 793
    rtc_t = t_from_rtc(& rtc_tm);
    }
#line 795
    if (rtc_t == -1L) {
      {
#line 796
      LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc_linux.c",
                   796, "read_from_device");
#line 796
      LOG_Line_Function((LOG_Severity )2, (LOG_Facility )25, "Could not convert RTC time to timeval");
#line 797
      error___0 = 1;
      }
#line 798
      goto turn_off_interrupt;
    }
    {
#line 801
    process_reading(rtc_t, & sys_time);
    }
#line 803
    if (n_samples___0 < 4) {
#line 804
      measurement_period = 15;
    } else
#line 805
    if (n_samples___0 < 6) {
#line 806
      measurement_period = 15 << 1;
    } else
#line 807
    if (n_samples___0 < 10) {
#line 808
      measurement_period = 15 << 2;
    } else
#line 809
    if (n_samples___0 < 14) {
#line 810
      measurement_period = 15 << 3;
    } else {
#line 812
      measurement_period = 15 << 4;
    }
  }
  turn_off_interrupt: 
  {
#line 820
  if ((unsigned int )operating_mode == 1U) {
#line 820
    goto case_1;
  }
#line 834
  if ((unsigned int )operating_mode == 2U) {
#line 834
    goto case_2;
  }
#line 847
  if ((unsigned int )operating_mode == 0U) {
#line 847
    goto case_0;
  }
#line 854
  goto switch_default;
  case_1: /* CIL Label */ 
#line 821
  if (error___0) {
    {
#line 822
    LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc_linux.c",
                 822, "read_from_device");
#line 822
    LOG_Line_Function((LOG_Severity )1, (LOG_Facility )25, "Could not complete initial step due to errors");
#line 823
    operating_mode = (OperatingMode )0;
#line 824
    (*after_init_hook)(after_init_hook_arg);
#line 826
    switch_interrupts(0);
#line 828
    timeout_running = 1;
#line 829
    timeout_id = SCH_AddTimeoutByDelay((double )measurement_period, & measurement_timeout,
                                       (void *)0);
    }
  }
#line 832
  goto switch_break;
  case_2: /* CIL Label */ 
#line 835
  if (error___0) {
    {
#line 836
    LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc_linux.c",
                 836, "read_from_device");
#line 836
    LOG_Line_Function((LOG_Severity )1, (LOG_Facility )25, "Could not complete after trim relock due to errors");
#line 837
    operating_mode = (OperatingMode )0;
#line 839
    switch_interrupts(0);
#line 841
    timeout_running = 1;
#line 842
    timeout_id = SCH_AddTimeoutByDelay((double )measurement_period, & measurement_timeout,
                                       (void *)0);
    }
  }
#line 845
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 848
  switch_interrupts(0);
#line 850
  timeout_running = 1;
#line 851
  timeout_id = SCH_AddTimeoutByDelay((double )measurement_period, & measurement_timeout,
                                     (void *)0);
  }
#line 853
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 855
  __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc_linux.c",
                855U, "read_from_device");
  }
#line 856
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 859
  return;
}
}
#line 863 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc_linux.c"
void RTC_Linux_TimeInit(void (*after_hook)(void * ) , void *anything ) 
{ 


  {
  {
#line 866
  after_init_hook = after_hook;
#line 867
  after_init_hook_arg = anything;
#line 869
  operating_mode = (OperatingMode )1;
#line 870
  timeout_running = 0;
#line 871
  switch_interrupts(1);
  }
#line 873
  return;
}
}
#line 877 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc_linux.c"
void RTC_Linux_StartMeasurements(void) 
{ 


  {
  {
#line 880
  timeout_running = 0;
#line 881
  measurement_timeout((void *)0);
  }
#line 882
  return;
}
}
#line 886 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc_linux.c"
int RTC_Linux_WriteParameters(void) 
{ 
  int retval ;

  {
#line 891
  if (fd < 0) {
#line 892
    return (1);
  }
#line 895
  if (coefs_valid) {
    {
#line 896
    retval = write_coefs_to_file(1, coef_ref_time, coef_seconds_fast, coef_gain_rate);
    }
  } else {
#line 900
    retval = 0;
  }
#line 903
  return (retval);
}
}
#line 912 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc_linux.c"
void RTC_Linux_TimePreInit(void) 
{ 
  int fd___0 ;
  int status___0 ;
  struct rtc_time rtc_raw ;
  struct tm rtc_tm ;
  time_t rtc_t ;
  time_t estimated_correct_rtc_t ;
  long interval ;
  double accumulated_error ;
  struct timeval new_sys_time ;
  struct timeval old_sys_time ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 920
  accumulated_error = 0.0;
#line 923
  coefs_file_name = CNF_GetRtcFile();
#line 925
  setup_config();
#line 926
  read_coefs_from_file();
#line 928
  tmp = CNF_GetRtcDevice();
#line 928
  fd___0 = open((char const   *)tmp, 0);
  }
#line 930
  if (fd___0 < 0) {
#line 931
    return;
  }
  {
#line 934
  status___0 = ioctl(fd___0, (unsigned long )(((2U << 30) | (unsigned int )(112 << 8)) | 9U) | (sizeof(struct rtc_time ) << 16),
                     & rtc_raw);
  }
#line 936
  if (status___0 >= 0) {
    {
#line 938
    rtc_tm.tm_sec = rtc_raw.tm_sec;
#line 939
    rtc_tm.tm_min = rtc_raw.tm_min;
#line 940
    rtc_tm.tm_hour = rtc_raw.tm_hour;
#line 941
    rtc_tm.tm_mday = rtc_raw.tm_mday;
#line 942
    rtc_tm.tm_mon = rtc_raw.tm_mon;
#line 943
    rtc_tm.tm_year = rtc_raw.tm_year;
#line 945
    rtc_t = t_from_rtc(& rtc_tm);
    }
#line 947
    if (rtc_t != -1L) {
#line 951
      if (valid_coefs_from_file) {
#line 952
        interval = rtc_t - file_ref_time;
#line 953
        accumulated_error = file_ref_offset + ((double )interval * 1.0e-6) * file_rate_ppm;
#line 956
        estimated_correct_rtc_t = rtc_t - (long )(0.5 + accumulated_error);
      } else {
#line 958
        estimated_correct_rtc_t = rtc_t - (long )(0.5 + accumulated_error);
      }
      {
#line 961
      new_sys_time.tv_sec = estimated_correct_rtc_t;
#line 962
      new_sys_time.tv_usec = (__suseconds_t )0;
#line 965
      tmp___1 = gettimeofday((struct timeval */* __restrict  */)(& old_sys_time),
                             (__timezone_ptr_t )((void *)0));
      }
#line 965
      if (! (tmp___1 < 0)) {
#line 965
        if (old_sys_time.tv_sec - new_sys_time.tv_sec > 1L) {
#line 965
          goto _L;
        } else
#line 965
        if (old_sys_time.tv_sec - new_sys_time.tv_sec < -1L) {
          _L: /* CIL Label */ 
          {
#line 969
          LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc_linux.c",
                       969, "RTC_Linux_TimePreInit");
#line 969
          LOG_Line_Function((LOG_Severity )0, (LOG_Facility )25, "Set system time, error in RTC = %f",
                            accumulated_error);
#line 973
          tmp___0 = settimeofday((struct timeval  const  *)(& new_sys_time), (struct timezone  const  *)((void *)0));
          }
#line 973
          if (tmp___0 < 0) {
            {
#line 974
            LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc_linux.c",
                         974, "RTC_Linux_TimePreInit");
#line 974
            LOG_Line_Function((LOG_Severity )1, (LOG_Facility )25, "Could not settimeofday");
            }
          }
        }
      }
    } else {
      {
#line 978
      LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc_linux.c",
                   978, "RTC_Linux_TimePreInit");
#line 978
      LOG_Line_Function((LOG_Severity )1, (LOG_Facility )25, "Could not convert RTC reading to seconds since 1/1/1970");
      }
    }
  }
  {
#line 982
  close(fd___0);
  }
#line 983
  return;
}
}
#line 987 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc_linux.c"
int RTC_Linux_GetReport(RPT_RTC_Report *report ) 
{ 


  {
#line 990
  report->ref_time.tv_sec = coef_ref_time;
#line 991
  report->ref_time.tv_usec = (__suseconds_t )0;
#line 992
  report->n_samples = (unsigned short )n_samples___0;
#line 993
  report->n_runs = (unsigned short )n_runs;
#line 994
  if (n_samples___0 > 1) {
#line 995
    report->span_seconds = (unsigned long )((rtc_sec[n_samples___0 - 1] - rtc_sec[0]) + (long )(rtc_trim[n_samples___0 - 1] - rtc_trim[0]));
  } else {
#line 998
    report->span_seconds = 0UL;
  }
#line 1000
  report->rtc_seconds_fast = coef_seconds_fast;
#line 1001
  report->rtc_gain_rate_ppm = 1.0e6 * coef_gain_rate;
#line 1002
  return (1);
}
}
#line 1007 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc_linux.c"
int RTC_Linux_Trim(void) 
{ 
  struct timeval now ;
  double tmp ;

  {
  {
#line 1015
  saved_coef_gain_rate = coef_gain_rate;
#line 1017
  tmp = fabs(coef_seconds_fast);
  }
#line 1017
  if (tmp > 1.0) {
    {
#line 1019
    LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc_linux.c",
                 1019, "RTC_Linux_Trim");
#line 1019
    LOG_Line_Function((LOG_Severity )0, (LOG_Facility )25, "Trimming RTC, error = %.3f seconds",
                      coef_seconds_fast);
#line 1029
    LCL_ReadCookedTime(& now, (double *)((void *)0));
#line 1031
    set_rtc(now.tv_sec);
#line 1035
    n_samples___0 = 0;
#line 1036
    operating_mode = (OperatingMode )2;
#line 1040
    coef_seconds_fast = (double )(- now.tv_usec) / 1e6 + 0.5;
#line 1041
    coef_ref_time = now.tv_sec;
    }
#line 1044
    if (timeout_running) {
      {
#line 1045
      SCH_RemoveTimeout(timeout_id);
#line 1046
      timeout_running = 0;
      }
    }
    {
#line 1048
    switch_interrupts(1);
    }
  }
#line 1051
  return (1);
}
}
#line 321 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) mkdir)(char const   *__path ,
                                                                                            __mode_t __mode ) ;
#line 29 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/mkdirpp.h"
int mkdir_and_parents(char const   *path ) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/mkdirpp.c"
static int do_dir(char *p ) 
{ 
  int status___0 ;
  struct stat buf ;
  int *tmp ;

  {
  {
#line 46
  status___0 = stat((char const   */* __restrict  */)p, (struct stat */* __restrict  */)(& buf));
  }
#line 48
  if (status___0 < 0) {
    {
#line 49
    tmp = __errno_location();
    }
#line 49
    if (*tmp == 2) {
      {
#line 51
      status___0 = mkdir((char const   *)p, (__mode_t )493);
      }
#line 52
      return (status___0);
    } else {
#line 54
      return (status___0);
    }
  }
#line 58
  if (! ((buf.st_mode & 61440U) == 16384U)) {
#line 59
    return (-1);
  }
#line 62
  return (0);
}
}
#line 69 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/mkdirpp.c"
int mkdir_and_parents(char const   *path ) 
{ 
  char *p ;
  int len ;
  int i ;
  int j ;
  int k ;
  int last ;
  size_t tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 75
  tmp = strlen(path);
#line 75
  len = (int )tmp;
#line 77
  tmp___0 = malloc((size_t )(1 + len));
#line 77
  p = (char *)tmp___0;
#line 79
  k = 0;
#line 79
  i = k;
  }
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
#line 81
    tmp___1 = i;
#line 81
    i ++;
#line 81
    tmp___2 = k;
#line 81
    k ++;
#line 81
    *(p + tmp___1) = (char )*(path + tmp___2);
#line 83
    if ((int const   )*(path + k) == 47) {
#line 83
      goto _L;
    } else
#line 83
    if (! *(path + k)) {
      _L: /* CIL Label */ 
      {
#line 84
      *(p + i) = (char)0;
#line 86
      tmp___3 = do_dir(p);
      }
#line 86
      if (tmp___3 < 0) {
        {
#line 87
        free((void *)p);
        }
#line 88
        return (0);
      }
#line 91
      if (! *(path + k)) {
#line 93
        goto while_break;
      }
#line 97
      last = 1;
#line 98
      j = k + 1;
      {
#line 99
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 99
        if (! *(path + j)) {
#line 99
          goto while_break___0;
        }
#line 100
        if ((int const   )*(path + j) != 47) {
#line 101
          k = j - 1;
#line 102
          last = 0;
#line 103
          goto while_break___0;
        }
#line 105
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 108
      if (last) {
#line 109
        goto while_break;
      }
    }
#line 113
    if (! *(path + k)) {
#line 113
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 117
  free((void *)p);
  }
#line 118
  return (1);
}
}
#line 49 "/usr/include/malloc.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/clientlog.h"
void CLG_LogCommandAccess(IPAddr *client , CLG_Command_Type type , time_t now ) ;
#line 67
CLG_Status CLG_GetSubnetBitmap(IPAddr *subnet , int bits , uint32_t *result ) ;
#line 69
CLG_Status CLG_GetClientAccessReportByIP(IPAddr *ip , RPT_ClientAccess_Report *report ,
                                         time_t now ) ;
#line 72
CLG_Status CLG_GetClientAccessReportByIndex(int index___0 , RPT_ClientAccessByIndex_Report *report ,
                                            time_t now , unsigned long *n_indices ) ;
#line 69 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.h"
int CNF_GetNoClientLog(void) ;
#line 70
unsigned long CNF_GetClientLogLimit(void) ;
#line 72 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/clientlog.c"
static Subnet top_subnet4  ;
#line 74 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/clientlog.c"
static Subnet top_subnet6  ;
#line 78 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/clientlog.c"
static Node **nodes  =    (Node **)((void *)0);
#line 81 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/clientlog.c"
static int n_nodes  =    0;
#line 84 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/clientlog.c"
static int max_nodes  =    0;
#line 87 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/clientlog.c"
static int active  =    0;
#line 91 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/clientlog.c"
static int alloc_limit_reached  ;
#line 93 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/clientlog.c"
static unsigned long alloc_limit  ;
#line 94 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/clientlog.c"
static unsigned long alloced  ;
#line 98 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/clientlog.c"
static void split_ip6___0(IPAddr *ip , uint32_t *dst ) 
{ 
  int i ;

  {
#line 103
  i = 0;
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
#line 103
    if (! (i < 4)) {
#line 103
      goto while_break;
    }
#line 104
    *(dst + i) = (uint32_t )(((((int )ip->addr.in6[i * 4] << 24) | ((int )ip->addr.in6[i * 4 + 1] << 16)) | ((int )ip->addr.in6[i * 4 + 2] << 8)) | (int )ip->addr.in6[i * 4 + 3]);
#line 103
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 108
  return;
}
}
#line 112 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/clientlog.c"
__inline static uint32_t get_subnet___0(uint32_t *addr , unsigned int where ) 
{ 
  int off ;

  {
#line 117
  off = (int )(where / 32U);
#line 118
  where %= 32U;
#line 120
  return ((uint32_t )((unsigned long )(*(addr + off) >> (24U - where)) & ((1UL << 8) - 1UL)));
}
}
#line 126 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/clientlog.c"
static void clear_subnet(Subnet *subnet ) 
{ 
  int i ;

  {
#line 131
  i = 0;
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;
#line 131
    if (! ((unsigned long )i < 1UL << 8)) {
#line 131
      goto while_break;
    }
#line 132
    subnet->entry[i] = (void *)0;
#line 131
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 134
  return;
}
}
#line 138 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/clientlog.c"
static void clear_node(Node *node ) 
{ 


  {
#line 141
  node->client_hits = 0UL;
#line 142
  node->peer_hits = 0UL;
#line 143
  node->cmd_hits_auth = 0UL;
#line 144
  node->cmd_hits_normal = 0UL;
#line 145
  node->cmd_hits_bad = 0UL;
#line 146
  node->last_ntp_hit = (time_t )0;
#line 147
  node->last_cmd_hit = (time_t )0;
#line 148
  return;
}
}
#line 152 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/clientlog.c"
void CLG_Initialise(void) 
{ 
  int tmp ;

  {
  {
#line 155
  clear_subnet(& top_subnet4);
#line 156
  clear_subnet(& top_subnet6);
#line 157
  tmp = CNF_GetNoClientLog();
  }
#line 157
  if (tmp) {
#line 158
    active = 0;
  } else {
#line 160
    active = 1;
  }
  {
#line 163
  nodes = (Node **)((void *)0);
#line 164
  max_nodes = 0;
#line 165
  n_nodes = 0;
#line 167
  alloced = 0UL;
#line 168
  alloc_limit = CNF_GetClientLogLimit();
#line 169
  alloc_limit_reached = 0;
  }
#line 170
  return;
}
}
#line 174 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/clientlog.c"
void CLG_Finalise(void) 
{ 


  {
#line 177
  return;
}
}
#line 181 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/clientlog.c"
static void check_alloc_limit(void) 
{ 


  {
#line 182
  if (alloc_limit_reached) {
#line 183
    return;
  }
#line 185
  if (alloced >= alloc_limit) {
    {
#line 186
    LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/clientlog.c",
                 186, "check_alloc_limit");
#line 186
    LOG_Line_Function((LOG_Severity )1, (LOG_Facility )10, "Client log memory limit reached");
#line 187
    alloc_limit_reached = 1;
    }
  }
#line 189
  return;
}
}
#line 193 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/clientlog.c"
static void create_subnet(Subnet *parent_subnet , int the_entry ) 
{ 
  void *tmp ;

  {
  {
#line 196
  tmp = malloc(sizeof(Subnet ));
#line 196
  parent_subnet->entry[the_entry] = (void *)((Subnet *)tmp);
#line 197
  clear_subnet((Subnet *)parent_subnet->entry[the_entry]);
#line 198
  alloced += sizeof(Subnet );
#line 199
  check_alloc_limit();
  }
#line 200
  return;
}
}
#line 204 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/clientlog.c"
static void create_node(Subnet *parent_subnet , int the_entry ) 
{ 
  Node *new_node ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 208
  tmp = malloc(sizeof(Node ));
#line 208
  new_node = (Node *)tmp;
#line 209
  parent_subnet->entry[the_entry] = (void *)new_node;
#line 210
  clear_node(new_node);
#line 212
  alloced += sizeof(Node );
  }
#line 214
  if (n_nodes == max_nodes) {
#line 215
    if (nodes) {
#line 216
      if (! (max_nodes > 0)) {
        {
#line 216
        __assert_fail("max_nodes > 0", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/clientlog.c",
                      216U, "create_node");
        }
      }
      {
#line 217
      max_nodes *= 2;
#line 218
      tmp___0 = realloc((void *)nodes, (unsigned long )max_nodes * sizeof(Node *));
#line 218
      nodes = (Node **)tmp___0;
      }
    } else {
#line 220
      if (! (max_nodes == 0)) {
        {
#line 220
        __assert_fail("max_nodes == 0", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/clientlog.c",
                      220U, "create_node");
        }
      }
      {
#line 221
      max_nodes = 16;
#line 222
      tmp___1 = malloc((unsigned long )max_nodes * sizeof(Node *));
#line 222
      nodes = (Node **)tmp___1;
      }
    }
#line 224
    alloced += sizeof(Node *) * (unsigned long )(max_nodes - n_nodes);
  }
  {
#line 226
  tmp___2 = n_nodes;
#line 226
  n_nodes ++;
#line 226
  *(nodes + tmp___2) = new_node;
#line 227
  check_alloc_limit();
  }
#line 228
  return;
}
}
#line 234 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/clientlog.c"
static void *find_subnet(Subnet *subnet , uint32_t *addr , int addr_len , int bits_consumed ) 
{ 
  uint32_t this_subnet ;
  void *tmp ;

  {
  {
#line 239
  this_subnet = get_subnet___0(addr, (unsigned int )bits_consumed);
#line 240
  bits_consumed += 8;
  }
#line 242
  if (bits_consumed < 32 * addr_len) {
#line 243
    if (! subnet->entry[this_subnet]) {
#line 244
      if (alloc_limit_reached) {
#line 245
        return ((void *)0);
      }
      {
#line 246
      create_subnet(subnet, (int )this_subnet);
      }
    }
    {
#line 248
    tmp = find_subnet((Subnet *)subnet->entry[this_subnet], addr, addr_len, bits_consumed);
    }
#line 248
    return (tmp);
  } else {
#line 250
    if (! subnet->entry[this_subnet]) {
#line 251
      if (alloc_limit_reached) {
#line 252
        return ((void *)0);
      }
      {
#line 253
      create_node(subnet, (int )this_subnet);
      }
    }
#line 255
    return (subnet->entry[this_subnet]);
  }
}
}
#line 264 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/clientlog.c"
static void *find_subnet_dont_open(Subnet *subnet , uint32_t *addr , int addr_len ,
                                   int bits_consumed ) 
{ 
  uint32_t this_subnet ;
  void *tmp ;

  {
#line 269
  if (bits_consumed >= 32 * addr_len) {
#line 270
    return ((void *)subnet);
  } else {
    {
#line 273
    this_subnet = get_subnet___0(addr, (unsigned int )bits_consumed);
#line 274
    bits_consumed += 8;
    }
#line 276
    if (! subnet->entry[this_subnet]) {
#line 277
      return ((void *)0);
    } else {
      {
#line 279
      tmp = find_subnet_dont_open((Subnet *)subnet->entry[this_subnet], addr, addr_len,
                                  bits_consumed);
      }
#line 279
      return (tmp);
    }
  }
}
}
#line 286 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/clientlog.c"
void CLG_LogNTPClientAccess(IPAddr *client , time_t now ) 
{ 
  uint32_t ip6[4] ;
  Node *node ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 292
  if (active) {
    {
#line 294
    if ((int )client->family == 1) {
#line 294
      goto case_1;
    }
#line 297
    if ((int )client->family == 2) {
#line 297
      goto case_2;
    }
#line 301
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 295
    tmp = find_subnet(& top_subnet4, & client->addr.in4, 1, 0);
#line 295
    node = (Node *)tmp;
    }
#line 296
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 298
    split_ip6___0(client, ip6);
#line 299
    tmp___0 = find_subnet(& top_subnet6, ip6, 4, 0);
#line 299
    node = (Node *)tmp___0;
    }
#line 300
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 302
    __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/clientlog.c",
                  302U, "CLG_LogNTPClientAccess");
    }
    switch_break: /* CIL Label */ ;
    }
#line 305
    if ((unsigned long )node == (unsigned long )((void *)0)) {
#line 306
      return;
    }
#line 308
    node->ip_addr = *client;
#line 309
    (node->client_hits) ++;
#line 310
    node->last_ntp_hit = now;
  }
#line 312
  return;
}
}
#line 316 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/clientlog.c"
void CLG_LogNTPPeerAccess(IPAddr *client , time_t now ) 
{ 
  uint32_t ip6[4] ;
  Node *node ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 322
  if (active) {
    {
#line 324
    if ((int )client->family == 1) {
#line 324
      goto case_1;
    }
#line 327
    if ((int )client->family == 2) {
#line 327
      goto case_2;
    }
#line 331
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 325
    tmp = find_subnet(& top_subnet4, & client->addr.in4, 1, 0);
#line 325
    node = (Node *)tmp;
    }
#line 326
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 328
    split_ip6___0(client, ip6);
#line 329
    tmp___0 = find_subnet(& top_subnet6, ip6, 4, 0);
#line 329
    node = (Node *)tmp___0;
    }
#line 330
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 332
    __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/clientlog.c",
                  332U, "CLG_LogNTPPeerAccess");
    }
    switch_break: /* CIL Label */ ;
    }
#line 335
    if ((unsigned long )node == (unsigned long )((void *)0)) {
#line 336
      return;
    }
#line 338
    node->ip_addr = *client;
#line 339
    (node->peer_hits) ++;
#line 340
    node->last_ntp_hit = now;
  }
#line 342
  return;
}
}
#line 346 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/clientlog.c"
void CLG_LogCommandAccess(IPAddr *client , CLG_Command_Type type , time_t now ) 
{ 
  uint32_t ip6[4] ;
  Node *node ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 352
  if (active) {
    {
#line 354
    if ((int )client->family == 1) {
#line 354
      goto case_1;
    }
#line 357
    if ((int )client->family == 2) {
#line 357
      goto case_2;
    }
#line 361
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 355
    tmp = find_subnet(& top_subnet4, & client->addr.in4, 1, 0);
#line 355
    node = (Node *)tmp;
    }
#line 356
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 358
    split_ip6___0(client, ip6);
#line 359
    tmp___0 = find_subnet(& top_subnet6, ip6, 4, 0);
#line 359
    node = (Node *)tmp___0;
    }
#line 360
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 362
    __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/clientlog.c",
                  362U, "CLG_LogCommandAccess");
    }
    switch_break: /* CIL Label */ ;
    }
#line 365
    if ((unsigned long )node == (unsigned long )((void *)0)) {
#line 366
      return;
    }
#line 368
    node->ip_addr = *client;
#line 369
    node->last_cmd_hit = now;
    {
#line 371
    if ((unsigned int )type == 0U) {
#line 371
      goto case_0;
    }
#line 374
    if ((unsigned int )type == 1U) {
#line 374
      goto case_1___0;
    }
#line 377
    if ((unsigned int )type == 2U) {
#line 377
      goto case_2___0;
    }
#line 380
    goto switch_default___0;
    case_0: /* CIL Label */ 
#line 372
    (node->cmd_hits_auth) ++;
#line 373
    goto switch_break___0;
    case_1___0: /* CIL Label */ 
#line 375
    (node->cmd_hits_normal) ++;
#line 376
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
#line 378
    (node->cmd_hits_bad) ++;
#line 379
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 381
    __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/clientlog.c",
                  381U, "CLG_LogCommandAccess");
    }
#line 382
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
#line 385
  return;
}
}
#line 389 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/clientlog.c"
CLG_Status CLG_GetSubnetBitmap(IPAddr *subnet , int bits , uint32_t *result ) 
{ 
  Subnet *s ;
  uint32_t ip6[4] ;
  unsigned long i ;
  unsigned long word ;
  unsigned long bit ;
  unsigned long mask ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 397
  if (bits >= 0) {
#line 397
    if (bits % 8 == 0) {
      {
#line 398
      memset((void *)result, 0, (1UL << 8) / 8UL);
      }
#line 399
      if (active) {
        {
#line 401
        if ((int )subnet->family == 1) {
#line 401
          goto case_1;
        }
#line 406
        if ((int )subnet->family == 2) {
#line 406
          goto case_2;
        }
#line 412
        goto switch_default;
        case_1: /* CIL Label */ 
#line 402
        if (bits >= 32) {
#line 403
          return ((CLG_Status )2);
        }
        {
#line 404
        tmp = find_subnet_dont_open(& top_subnet4, & subnet->addr.in4, 1, 32 - bits);
#line 404
        s = (Subnet *)tmp;
        }
#line 405
        goto switch_break;
        case_2: /* CIL Label */ 
#line 407
        if (bits >= 128) {
#line 408
          return ((CLG_Status )2);
        }
        {
#line 409
        split_ip6___0(subnet, ip6);
#line 410
        tmp___0 = find_subnet_dont_open(& top_subnet6, ip6, 4, 128 - bits);
#line 410
        s = (Subnet *)tmp___0;
        }
#line 411
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 413
        return ((CLG_Status )2);
        switch_break: /* CIL Label */ ;
        }
#line 416
        if (s) {
#line 417
          i = 0UL;
          {
#line 417
          while (1) {
            while_continue: /* CIL Label */ ;
#line 417
            if (! (i < 256UL)) {
#line 417
              goto while_break;
            }
#line 418
            if (s->entry[i]) {
#line 419
              word = i / 32UL;
#line 420
              bit = i % 32UL;
#line 421
              mask = 1UL << bit;
#line 422
              *(result + word) = (uint32_t )((unsigned long )*(result + word) | mask);
            }
#line 417
            i ++;
          }
          while_break: /* CIL Label */ ;
          }
#line 425
          return ((CLG_Status )0);
        } else {
#line 427
          return ((CLG_Status )1);
        }
      } else {
#line 430
        return ((CLG_Status )3);
      }
    } else {
#line 433
      return ((CLG_Status )2);
    }
  } else {
#line 433
    return ((CLG_Status )2);
  }
}
}
#line 439 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/clientlog.c"
CLG_Status CLG_GetClientAccessReportByIP(IPAddr *ip , RPT_ClientAccess_Report *report ,
                                         time_t now ) 
{ 
  uint32_t ip6[4] ;
  Node *node ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 445
  if (! active) {
#line 446
    return ((CLG_Status )3);
  } else {
    {
#line 449
    if ((int )ip->family == 1) {
#line 449
      goto case_1;
    }
#line 452
    if ((int )ip->family == 2) {
#line 452
      goto case_2;
    }
#line 456
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 450
    tmp = find_subnet_dont_open(& top_subnet4, & ip->addr.in4, 1, 0);
#line 450
    node = (Node *)tmp;
    }
#line 451
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 453
    split_ip6___0(ip, ip6);
#line 454
    tmp___0 = find_subnet_dont_open(& top_subnet6, ip6, 4, 0);
#line 454
    node = (Node *)tmp___0;
    }
#line 455
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 457
    return ((CLG_Status )1);
    switch_break: /* CIL Label */ ;
    }
#line 460
    if (! node) {
#line 461
      return ((CLG_Status )1);
    } else {
#line 463
      report->client_hits = node->client_hits;
#line 464
      report->peer_hits = node->peer_hits;
#line 465
      report->cmd_hits_auth = node->cmd_hits_auth;
#line 466
      report->cmd_hits_normal = node->cmd_hits_normal;
#line 467
      report->cmd_hits_bad = node->cmd_hits_bad;
#line 468
      report->last_ntp_hit_ago = (unsigned long )(now - node->last_ntp_hit);
#line 469
      report->last_cmd_hit_ago = (unsigned long )(now - node->last_cmd_hit);
#line 471
      return ((CLG_Status )0);
    }
  }
}
}
#line 478 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/clientlog.c"
CLG_Status CLG_GetClientAccessReportByIndex(int index___0 , RPT_ClientAccessByIndex_Report *report ,
                                            time_t now , unsigned long *n_indices ) 
{ 
  Node *node ;

  {
#line 484
  *n_indices = (unsigned long )n_nodes;
#line 486
  if (! active) {
#line 487
    return ((CLG_Status )3);
  } else {
#line 490
    if (index___0 < 0) {
#line 491
      return ((CLG_Status )4);
    } else
#line 490
    if (index___0 >= n_nodes) {
#line 491
      return ((CLG_Status )4);
    }
#line 494
    node = *(nodes + index___0);
#line 496
    report->ip_addr = node->ip_addr;
#line 497
    report->client_hits = node->client_hits;
#line 498
    report->peer_hits = node->peer_hits;
#line 499
    report->cmd_hits_auth = node->cmd_hits_auth;
#line 500
    report->cmd_hits_normal = node->cmd_hits_normal;
#line 501
    report->cmd_hits_bad = node->cmd_hits_bad;
#line 502
    report->last_ntp_hit_ago = (unsigned long )(now - node->last_ntp_hit);
#line 503
    report->last_cmd_hit_ago = (unsigned long )(now - node->last_cmd_hit);
#line 505
    return ((CLG_Status )0);
  }
}
}
#line 386 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 156 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) sqrt)(double __x ) ;
#line 765 "/usr/include/stdlib.h"
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 147 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 59 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/refclock.h"
int RCL_AddRefclock(RefclockParameters *params ) ;
#line 62
void RCL_ReportSource(RPT_SourceReport *report , struct timeval *now ) ;
#line 65
void RCL_SetDriverData(RCL_Instance instance , void *data ) ;
#line 66
void *RCL_GetDriverData(RCL_Instance instance ) ;
#line 67
char *RCL_GetDriverParameter(RCL_Instance instance ) ;
#line 68
char *RCL_GetDriverOption(RCL_Instance instance , char *name ) ;
#line 69
int RCL_AddSample(RCL_Instance instance , struct timeval *sample_time , double offset ,
                  int leap ) ;
#line 70
int RCL_AddPulse(RCL_Instance instance , struct timeval *pulse_time , double second ) ;
#line 141 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.h"
int REF_IsLocalActive(void) ;
#line 40 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.h"
void CNF_AddRefclocks(void) ;
#line 54
int CNF_GetLogRefclocks(void) ;
#line 36 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/local.h"
void LCL_ReadRawTime(struct timeval *result ) ;
#line 55
void LCL_GetOffsetCorrection(struct timeval *raw , double *correction , double *err ) ;
#line 87
void LCL_RemoveParameterChangeHandler(void (*handler)(struct timeval *raw , struct timeval *cooked ,
                                                      double dfreq , double doffset ,
                                                      int is_step_change , void *anything ) ,
                                      void *anything ) ;
#line 109
void LCL_AddDispersionNotifyHandler(void (*handler)(double dispersion , void *anything ) ,
                                    void *anything ) ;
#line 113
extern void LCL_RemoveDispersionNotifyHandler(void (*handler)(double dispersion ,
                                                              void *anything ) , void *anything ) ;
#line 61 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/util.h"
void UTI_AddDoubleToTimeval(struct timeval *start , double increment , struct timeval *end ) ;
#line 78
char *UTI_RefidToString(uint32_t ref_id ) ;
#line 31 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/regress.h"
void RGR_WeightedRegression(double *x , double *y , double *w , int n , double *b0 ,
                            double *b1 , double *s2 , double *sb0 , double *sb1 ) ;
#line 63
double RGR_GetChi2Coef(int dof ) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/refclock.c"
RefclockDriver RCL_SHM_driver ;
#line 43
RefclockDriver RCL_SOCK_driver ;
#line 44
RefclockDriver RCL_PPS_driver ;
#line 88 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/refclock.c"
static struct RCL_Instance_Record refclocks[8]  ;
#line 89 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/refclock.c"
static int n_sources___0  =    0;
#line 91 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/refclock.c"
static LOG_FileID logfileid___1  ;
#line 93
static int valid_sample_time(RCL_Instance instance , struct timeval *tv ) ;
#line 94
static int pps_stratum(RCL_Instance instance , struct timeval *tv ) ;
#line 95
static void poll_timeout(void *arg ) ;
#line 96
static void slew_samples___1(struct timeval *raw , struct timeval *cooked , double dfreq ,
                             double doffset , int is_step_change , void *anything ) ;
#line 98
static void add_dispersion(double dispersion , void *anything ) ;
#line 99
static void log_sample(RCL_Instance instance , struct timeval *sample_time , int filtered ,
                       int pulse , double raw_offset , double cooked_offset , double dispersion ) ;
#line 101
static void filter_init(struct MedianFilter *filter , int length ) ;
#line 102
static void filter_fini(struct MedianFilter *filter ) ;
#line 103
static void filter_reset(struct MedianFilter *filter ) ;
#line 104
static double filter_get_avg_sample_dispersion(struct MedianFilter *filter ) ;
#line 105
static void filter_add_sample(struct MedianFilter *filter , struct timeval *sample_time ,
                              double offset , double dispersion ) ;
#line 106
static int filter_get_last_sample(struct MedianFilter *filter , struct timeval *sample_time ,
                                  double *offset , double *dispersion ) ;
#line 107
static int filter_select_samples(struct MedianFilter *filter ) ;
#line 108
static int filter_get_sample(struct MedianFilter *filter , struct timeval *sample_time ,
                             double *offset , double *dispersion ) ;
#line 109
static void filter_slew_samples(struct MedianFilter *filter , struct timeval *when ,
                                double dfreq , double doffset ) ;
#line 110
static void filter_add_dispersion(struct MedianFilter *filter , double dispersion ) ;
#line 112 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/refclock.c"
void RCL_Initialise(void) 
{ 
  LOG_FileID tmp___0 ;
  int tmp___1 ;

  {
  {
#line 115
  CNF_AddRefclocks();
  }
#line 117
  if (n_sources___0 > 0) {
    {
#line 118
    LCL_AddParameterChangeHandler(& slew_samples___1, (void *)0);
#line 119
    LCL_AddDispersionNotifyHandler(& add_dispersion, (void *)0);
    }
  }
  {
#line 122
  tmp___1 = CNF_GetLogRefclocks();
  }
#line 122
  if (tmp___1) {
    {
#line 122
    tmp___0 = LOG_FileOpen("refclocks", "   Date (UTC) Time         Refid  DP L P  Raw offset   Cooked offset      Disp.");
#line 122
    logfileid___1 = tmp___0;
    }
  } else {
#line 122
    logfileid___1 = -1;
  }
#line 125
  return;
}
}
#line 127 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/refclock.c"
void RCL_Finalise(void) 
{ 
  int i ;
  RCL_Instance inst ;

  {
#line 132
  i = 0;
  {
#line 132
  while (1) {
    while_continue: /* CIL Label */ ;
#line 132
    if (! (i < n_sources___0)) {
#line 132
      goto while_break;
    }
#line 133
    inst = & refclocks[i];
#line 135
    if ((inst->driver)->fini) {
      {
#line 136
      (*((inst->driver)->fini))(inst);
      }
    }
    {
#line 138
    filter_fini(& inst->filter);
#line 139
    free((void *)inst->driver_parameter);
#line 132
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 142
  if (n_sources___0 > 0) {
    {
#line 143
    LCL_RemoveParameterChangeHandler(& slew_samples___1, (void *)0);
#line 144
    LCL_RemoveDispersionNotifyHandler(& add_dispersion, (void *)0);
    }
  }
#line 146
  return;
}
}
#line 148 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/refclock.c"
int RCL_AddRefclock(RefclockParameters *params ) 
{ 
  int pps_source ;
  RCL_Instance inst ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int i ;
  size_t tmp___2 ;
  unsigned char ref[5] ;
  int max_samples___1 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 151
  pps_source = 0;
#line 153
  inst = & refclocks[n_sources___0];
#line 155
  if (n_sources___0 == 8) {
#line 156
    return (0);
  }
  {
#line 158
  tmp___1 = strcmp((char const   *)params->driver_name, "SHM");
  }
#line 158
  if (tmp___1 == 0) {
#line 159
    inst->driver = & RCL_SHM_driver;
#line 160
    inst->precision = 1e-6;
  } else {
    {
#line 161
    tmp___0 = strcmp((char const   *)params->driver_name, "SOCK");
    }
#line 161
    if (tmp___0 == 0) {
#line 162
      inst->driver = & RCL_SOCK_driver;
#line 163
      inst->precision = 1e-9;
#line 164
      pps_source = 1;
    } else {
      {
#line 165
      tmp = strcmp((char const   *)params->driver_name, "PPS");
      }
#line 165
      if (tmp == 0) {
#line 166
        inst->driver = & RCL_PPS_driver;
#line 167
        inst->precision = 1e-9;
#line 168
        pps_source = 1;
      } else {
        {
#line 170
        LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/refclock.c",
                     170, "RCL_AddRefclock");
#line 170
        LOG_Fatal_Function((LOG_Facility )26, "unknown refclock driver %s", params->driver_name);
        }
#line 171
        return (0);
      }
    }
  }
#line 174
  if (! (inst->driver)->init) {
#line 174
    if (! (inst->driver)->poll) {
      {
#line 175
      LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/refclock.c",
                   175, "RCL_AddRefclock");
#line 175
      LOG_Fatal_Function((LOG_Facility )26, "refclock driver %s is not compiled in",
                         params->driver_name);
      }
#line 176
      return (0);
    }
  }
#line 179
  inst->data = (void *)0;
#line 180
  inst->driver_parameter = params->driver_parameter;
#line 181
  inst->driver_parameter_length = 0;
#line 182
  inst->driver_poll = params->driver_poll;
#line 183
  inst->poll = params->poll;
#line 184
  inst->driver_polled = 0;
#line 185
  inst->leap_status = 0;
#line 186
  inst->pps_rate = params->pps_rate;
#line 187
  inst->lock_ref = params->lock_ref_id;
#line 188
  inst->offset = params->offset;
#line 189
  inst->delay = params->delay;
#line 190
  if (params->precision > 0.0) {
#line 191
    inst->precision = params->precision;
  }
#line 192
  inst->timeout_id = (SCH_TimeoutID )-1;
#line 193
  inst->source = (SRC_Instance )((void *)0);
#line 195
  if (inst->driver_parameter) {
    {
#line 198
    tmp___2 = strlen((char const   *)inst->driver_parameter);
#line 198
    inst->driver_parameter_length = (int )tmp___2;
#line 199
    i = 0;
    }
    {
#line 199
    while (1) {
      while_continue: /* CIL Label */ ;
#line 199
      if (! (i < inst->driver_parameter_length)) {
#line 199
        goto while_break;
      }
#line 200
      if ((int )*(inst->driver_parameter + i) == 58) {
#line 201
        *(inst->driver_parameter + i) = (char )'\000';
      }
#line 199
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 204
  if (pps_source) {
#line 205
    if (inst->pps_rate < 1) {
#line 206
      inst->pps_rate = 1;
    }
  } else {
#line 208
    inst->pps_rate = 0;
  }
#line 211
  if (params->ref_id) {
#line 212
    inst->ref_id = params->ref_id;
  } else {
    {
#line 214
    ref[0] = (unsigned char)0;
#line 214
    ref[1] = (unsigned char)0;
#line 214
    ref[2] = (unsigned char)0;
#line 214
    ref[3] = (unsigned char)0;
#line 214
    ref[4] = (unsigned char)0;
#line 216
    snprintf((char */* __restrict  */)((char *)(ref)), (size_t )5, (char const   */* __restrict  */)"%3.3s%d",
             params->driver_name, n_sources___0 % 10);
#line 217
    inst->ref_id = (uint32_t )(((((int )ref[0] << 24) | ((int )ref[1] << 16)) | ((int )ref[2] << 8)) | (int )ref[3]);
    }
  }
#line 220
  if ((inst->driver)->poll) {
#line 223
    if (inst->driver_poll > inst->poll) {
#line 224
      inst->driver_poll = inst->poll;
    }
#line 226
    max_samples___1 = 1 << (inst->poll - inst->driver_poll);
#line 227
    if (max_samples___1 < params->filter_length) {
#line 228
      if (max_samples___1 < 4) {
        {
#line 229
        LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/refclock.c",
                     229, "RCL_AddRefclock");
#line 229
        tmp___3 = UTI_RefidToString(inst->ref_id);
#line 229
        LOG_Line_Function((LOG_Severity )1, (LOG_Facility )26, "Setting filter length for %s to %d",
                          tmp___3, max_samples___1);
        }
      }
#line 232
      params->filter_length = max_samples___1;
    }
  }
#line 236
  if ((inst->driver)->init) {
    {
#line 237
    tmp___4 = (*((inst->driver)->init))(inst);
    }
#line 237
    if (! tmp___4) {
      {
#line 238
      LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/refclock.c",
                   238, "RCL_AddRefclock");
#line 238
      LOG_Fatal_Function((LOG_Facility )26, "refclock %s initialisation failed", params->driver_name);
      }
#line 239
      return (0);
    }
  }
  {
#line 242
  filter_init(& inst->filter, params->filter_length);
#line 244
  inst->source = SRC_CreateNewInstance(inst->ref_id, (SRC_Type )1, params->sel_option,
                                       (IPAddr *)((void *)0));
#line 250
  n_sources___0 ++;
#line 252
  free((void *)params->driver_name);
  }
#line 254
  return (1);
}
}
#line 257 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/refclock.c"
void RCL_StartRefclocks(void) 
{ 
  int i ;
  int j ;
  RCL_Instance inst ;

  {
#line 262
  i = 0;
  {
#line 262
  while (1) {
    while_continue: /* CIL Label */ ;
#line 262
    if (! (i < n_sources___0)) {
#line 262
      goto while_break;
    }
    {
#line 263
    inst = & refclocks[i];
#line 265
    SRC_SetSelectable(inst->source);
#line 266
    inst->timeout_id = SCH_AddTimeoutByDelay(0.0, & poll_timeout, (void *)inst);
    }
#line 268
    if (inst->lock_ref) {
#line 270
      j = 0;
      {
#line 270
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 270
        if (j < n_sources___0) {
#line 270
          if (! (refclocks[j].ref_id != inst->lock_ref)) {
#line 270
            goto while_break___0;
          }
        } else {
#line 270
          goto while_break___0;
        }
#line 270
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 272
      if (j < n_sources___0) {
#line 272
        inst->lock_ref = (uint32_t )j;
      } else {
#line 272
        inst->lock_ref = (uint32_t )-1;
      }
    } else {
#line 274
      inst->lock_ref = (uint32_t )-1;
    }
#line 262
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 276
  return;
}
}
#line 278 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/refclock.c"
void RCL_ReportSource(RPT_SourceReport *report , struct timeval *now ) 
{ 
  int i ;
  uint32_t ref_id ;
  RCL_Instance inst ;

  {
#line 284
  if (! ((int )report->ip_addr.family == 1)) {
    {
#line 284
    __assert_fail("report->ip_addr.family == 1", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/refclock.c",
                  284U, "RCL_ReportSource");
    }
  }
#line 285
  ref_id = report->ip_addr.addr.in4;
#line 287
  i = 0;
  {
#line 287
  while (1) {
    while_continue: /* CIL Label */ ;
#line 287
    if (! (i < n_sources___0)) {
#line 287
      goto while_break;
    }
#line 288
    inst = & refclocks[i];
#line 289
    if (inst->ref_id == ref_id) {
#line 290
      report->poll = inst->poll;
#line 291
      report->mode = (enum __anonenum_mode_80 )2;
#line 292
      goto while_break;
    }
#line 287
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 295
  return;
}
}
#line 297 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/refclock.c"
void RCL_SetDriverData(RCL_Instance instance , void *data ) 
{ 


  {
#line 300
  instance->data = data;
#line 301
  return;
}
}
#line 303 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/refclock.c"
void *RCL_GetDriverData(RCL_Instance instance ) 
{ 


  {
#line 306
  return (instance->data);
}
}
#line 309 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/refclock.c"
char *RCL_GetDriverParameter(RCL_Instance instance ) 
{ 


  {
#line 312
  return (instance->driver_parameter);
}
}
#line 315 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/refclock.c"
char *RCL_GetDriverOption(RCL_Instance instance , char *name ) 
{ 
  char *s ;
  char *e ;
  int n ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 321
  s = instance->driver_parameter;
#line 322
  e = s + instance->driver_parameter_length;
#line 323
  tmp = strlen((char const   *)name);
#line 323
  n = (int )tmp;
  }
  {
#line 325
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 326
    tmp___0 = strlen((char const   *)s);
#line 326
    s += tmp___0 + 1UL;
    }
#line 327
    if ((unsigned long )s >= (unsigned long )e) {
#line 328
      goto while_break;
    }
    {
#line 329
    tmp___1 = strncmp((char const   *)name, (char const   *)s, (size_t )n);
    }
#line 329
    if (! tmp___1) {
#line 330
      if ((int )*(s + n) == 61) {
#line 331
        return ((s + n) + 1);
      }
#line 332
      if ((int )*(s + n) == 0) {
#line 333
        return (s + n);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 337
  return ((char *)((void *)0));
}
}
#line 340 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/refclock.c"
int RCL_AddSample(RCL_Instance instance , struct timeval *sample_time , double offset ,
                  int leap ) 
{ 
  double correction ;
  double dispersion ;
  struct timeval cooked_time ;
  double tmp ;
  int tmp___0 ;

  {
  {
#line 346
  LCL_GetOffsetCorrection(sample_time, & correction, & dispersion);
#line 347
  UTI_AddDoubleToTimeval(sample_time, correction, & cooked_time);
#line 348
  tmp = filter_get_avg_sample_dispersion(& instance->filter);
#line 348
  dispersion += instance->precision + tmp;
#line 350
  tmp___0 = valid_sample_time(instance, sample_time);
  }
#line 350
  if (! tmp___0) {
#line 351
    return (0);
  }
  {
#line 353
  filter_add_sample(& instance->filter, & cooked_time, (offset - correction) + instance->offset,
                    dispersion);
  }
  {
#line 358
  if (leap == 2) {
#line 358
    goto case_2;
  }
#line 358
  if (leap == 1) {
#line 358
    goto case_2;
  }
#line 358
  if (leap == 0) {
#line 358
    goto case_2;
  }
#line 361
  goto switch_default;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 359
  instance->leap_status = leap;
#line 360
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 362
  instance->leap_status = 3;
#line 363
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 366
  log_sample(instance, & cooked_time, 0, 0, offset, (offset - correction) + instance->offset,
             dispersion);
  }
#line 369
  if (! (instance->driver)->poll) {
#line 370
    (instance->driver_polled) ++;
  }
#line 372
  return (1);
}
}
#line 375 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/refclock.c"
int RCL_AddPulse(RCL_Instance instance , struct timeval *pulse_time , double second ) 
{ 
  double correction ;
  double dispersion ;
  double offset ;
  struct timeval cooked_time ;
  int rate ;
  double tmp ;
  int tmp___0 ;
  struct timeval ref_sample_time ;
  double sample_diff ;
  double ref_offset ;
  double ref_dispersion ;
  double shift ;
  int tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  struct timeval ref_time ;
  int is_synchronised ;
  int stratum ;
  double root_delay ;
  double root_dispersion ;
  double distance ;
  NTP_Leap leap ;
  uint32_t ref_id ;
  double tmp___4 ;

  {
  {
#line 382
  LCL_GetOffsetCorrection(pulse_time, & correction, & dispersion);
#line 383
  UTI_AddDoubleToTimeval(pulse_time, correction, & cooked_time);
#line 384
  tmp = filter_get_avg_sample_dispersion(& instance->filter);
#line 384
  dispersion += instance->precision + tmp;
#line 386
  tmp___0 = valid_sample_time(instance, pulse_time);
  }
#line 386
  if (! tmp___0) {
#line 387
    return (0);
  }
#line 389
  rate = instance->pps_rate;
#line 390
  if (! (rate > 0)) {
    {
#line 390
    __assert_fail("rate > 0", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/refclock.c",
                  390U, "RCL_AddPulse");
    }
  }
#line 392
  offset = (- second - correction) + instance->offset;
#line 395
  offset -= (double )((long )(offset * (double )rate)) / (double )rate;
#line 396
  if (offset < - 0.5 / (double )rate) {
#line 397
    offset += 1.0 / (double )rate;
  } else
#line 398
  if (offset >= 0.5 / (double )rate) {
#line 399
    offset -= 1.0 / (double )rate;
  }
#line 401
  if (instance->lock_ref != 4294967295U) {
    {
#line 405
    tmp___1 = filter_get_last_sample(& refclocks[instance->lock_ref].filter, & ref_sample_time,
                                     & ref_offset, & ref_dispersion);
    }
#line 405
    if (! tmp___1) {
#line 407
      return (0);
    }
    {
#line 409
    UTI_DiffTimevalsToDouble(& sample_diff, & cooked_time, & ref_sample_time);
#line 410
    tmp___2 = fabs(sample_diff);
    }
#line 410
    if (tmp___2 >= 2.0 / (double )rate) {
#line 411
      return (0);
    }
#line 414
    if (ref_offset - offset >= 0.0) {
#line 415
      shift = (double )((long )((ref_offset - offset) * (double )rate + 0.5)) / (double )rate;
    } else {
#line 417
      shift = (double )((long )((ref_offset - offset) * (double )rate - 0.5)) / (double )rate;
    }
    {
#line 419
    offset += shift;
#line 421
    tmp___3 = fabs(ref_offset - offset);
    }
#line 421
    if ((tmp___3 + ref_dispersion) + dispersion >= 0.2 / (double )rate) {
#line 422
      return (0);
    }
  } else {
    {
#line 437
    REF_GetReferenceParams(& cooked_time, & is_synchronised, & leap, & stratum, & ref_id,
                           & ref_time, & root_delay, & root_dispersion);
#line 439
    tmp___4 = fabs(root_delay);
#line 439
    distance = tmp___4 / (double )2 + root_dispersion;
    }
#line 441
    if (! is_synchronised) {
      {
#line 447
      filter_reset(& instance->filter);
      }
#line 448
      return (0);
    } else
#line 441
    if (distance >= 0.5 / (double )rate) {
      {
#line 447
      filter_reset(& instance->filter);
      }
#line 448
      return (0);
    }
  }
  {
#line 452
  filter_add_sample(& instance->filter, & cooked_time, offset, dispersion);
#line 453
  instance->leap_status = 0;
#line 455
  log_sample(instance, & cooked_time, 0, 1, (offset + correction) - instance->offset,
             offset, dispersion);
  }
#line 458
  if (! (instance->driver)->poll) {
#line 459
    (instance->driver_polled) ++;
  }
#line 461
  return (1);
}
}
#line 464 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/refclock.c"
static int valid_sample_time(RCL_Instance instance , struct timeval *tv ) 
{ 
  struct timeval raw_time ;
  double diff ;

  {
  {
#line 470
  LCL_ReadRawTime(& raw_time);
#line 471
  UTI_DiffTimevalsToDouble(& diff, & raw_time, tv);
  }
#line 472
  if (diff < 0.0) {
#line 473
    return (0);
  } else
#line 472
  if (diff > (double )(1 << (instance->poll + 1))) {
#line 473
    return (0);
  }
#line 474
  return (1);
}
}
#line 477 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/refclock.c"
static int pps_stratum(RCL_Instance instance , struct timeval *tv ) 
{ 
  struct timeval ref_time ;
  int is_synchronised ;
  int stratum ;
  int i ;
  double root_delay ;
  double root_dispersion ;
  NTP_Leap leap ;
  uint32_t ref_id ;
  int tmp ;

  {
  {
#line 486
  REF_GetReferenceParams(tv, & is_synchronised, & leap, & stratum, & ref_id, & ref_time,
                         & root_delay, & root_dispersion);
  }
#line 491
  if (ref_id == instance->ref_id) {
#line 492
    return (stratum - 1);
  } else {
    {
#line 491
    tmp = REF_IsLocalActive();
    }
#line 491
    if (tmp) {
#line 492
      return (stratum - 1);
    }
  }
#line 495
  i = 0;
  {
#line 495
  while (1) {
    while_continue: /* CIL Label */ ;
#line 495
    if (! (i < n_sources___0)) {
#line 495
      goto while_break;
    }
#line 496
    if (refclocks[i].ref_id == ref_id) {
#line 496
      if (refclocks[i].pps_rate) {
#line 496
        if (refclocks[i].lock_ref == 4294967295U) {
#line 498
          return (stratum - 1);
        }
      }
    }
#line 495
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 501
  return (0);
}
}
#line 504 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/refclock.c"
static void poll_timeout(void *arg ) 
{ 
  double next ;
  int poll ;
  RCL_Instance inst ;
  double offset ;
  double dispersion ;
  struct timeval sample_time ;
  int sample_ok ;
  int stratum ;

  {
#line 510
  inst = (RCL_Instance )arg;
#line 512
  poll = inst->poll;
#line 514
  if ((inst->driver)->poll) {
    {
#line 515
    poll = inst->driver_poll;
#line 516
    (*((inst->driver)->poll))(inst);
#line 517
    (inst->driver_polled) ++;
    }
  }
#line 520
  if ((inst->driver)->poll) {
#line 520
    if (! (inst->driver_polled < 1 << (inst->poll - inst->driver_poll))) {
#line 520
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 525
    sample_ok = filter_get_sample(& inst->filter, & sample_time, & offset, & dispersion);
#line 526
    inst->driver_polled = 0;
    }
#line 528
    if (sample_ok) {
#line 529
      if (inst->pps_rate) {
#line 529
        if (inst->lock_ref == 4294967295U) {
          {
#line 531
          stratum = pps_stratum(inst, & sample_time);
          }
        } else {
#line 533
          stratum = 0;
        }
      } else {
#line 533
        stratum = 0;
      }
      {
#line 535
      SRC_UpdateReachability(inst->source, 1);
#line 536
      SRC_AccumulateSample(inst->source, & sample_time, offset, inst->delay, dispersion,
                           inst->delay, dispersion, stratum, (NTP_Leap )inst->leap_status);
#line 539
      log_sample(inst, & sample_time, 1, 0, 0.0, offset, dispersion);
      }
    } else {
      {
#line 541
      SRC_UpdateReachability(inst->source, 0);
      }
    }
  }
#line 545
  if (poll >= 0) {
#line 546
    next = (double )(1 << poll);
  } else {
#line 548
    next = 1.0 / (double )(1 << - poll);
  }
  {
#line 550
  inst->timeout_id = SCH_AddTimeoutByDelay(next, & poll_timeout, arg);
  }
#line 551
  return;
}
}
#line 553 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/refclock.c"
static void slew_samples___1(struct timeval *raw , struct timeval *cooked , double dfreq ,
                             double doffset , int is_step_change , void *anything ) 
{ 
  int i ;

  {
#line 559
  i = 0;
  {
#line 559
  while (1) {
    while_continue: /* CIL Label */ ;
#line 559
    if (! (i < n_sources___0)) {
#line 559
      goto while_break;
    }
    {
#line 560
    filter_slew_samples(& refclocks[i].filter, cooked, dfreq, doffset);
#line 559
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 561
  return;
}
}
#line 563 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/refclock.c"
static void add_dispersion(double dispersion , void *anything ) 
{ 
  int i ;

  {
#line 568
  i = 0;
  {
#line 568
  while (1) {
    while_continue: /* CIL Label */ ;
#line 568
    if (! (i < n_sources___0)) {
#line 568
      goto while_break;
    }
    {
#line 569
    filter_add_dispersion(& refclocks[i].filter, dispersion);
#line 568
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 570
  return;
}
}
#line 572 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/refclock.c"
static void log_sample(RCL_Instance instance , struct timeval *sample_time , int filtered ,
                       int pulse , double raw_offset , double cooked_offset , double dispersion ) 
{ 
  char sync_stats___0[4] ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 575
  sync_stats___0[0] = (char )'N';
#line 575
  sync_stats___0[1] = (char )'+';
#line 575
  sync_stats___0[2] = (char )'-';
#line 575
  sync_stats___0[3] = (char )'?';
#line 577
  if (logfileid___1 == -1) {
#line 578
    return;
  }
#line 580
  if (! filtered) {
    {
#line 581
    tmp = UTI_RefidToString(instance->ref_id);
#line 581
    tmp___0 = UTI_TimeToLogForm(sample_time->tv_sec);
#line 581
    LOG_FileWrite(logfileid___1, "%s.%06d %-5s %3d %1c %1d %13.6e %13.6e %10.3e",
                  tmp___0, (int )sample_time->tv_usec, tmp, instance->driver_polled,
                  (int )sync_stats___0[instance->leap_status], pulse, raw_offset,
                  cooked_offset, dispersion);
    }
  } else {
    {
#line 592
    tmp___1 = UTI_RefidToString(instance->ref_id);
#line 592
    tmp___2 = UTI_TimeToLogForm(sample_time->tv_sec);
#line 592
    LOG_FileWrite(logfileid___1, "%s.%06d %-5s   - %1c -       -       %13.6e %10.3e",
                  tmp___2, (int )sample_time->tv_usec, tmp___1, (int )sync_stats___0[instance->leap_status],
                  cooked_offset, dispersion);
    }
  }
#line 600
  return;
}
}
#line 602 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/refclock.c"
static void filter_init(struct MedianFilter *filter , int length ) 
{ 
  double tmp ;
  double tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;

  {
#line 605
  if (length < 1) {
#line 606
    length = 1;
  }
  {
#line 608
  filter->length = length;
#line 609
  filter->index = -1;
#line 610
  filter->used = 0;
#line 611
  filter->last = -1;
#line 613
  filter->avg_var_n = 0;
#line 614
  tmp = LCL_GetSysPrecisionAsQuantum();
#line 614
  tmp___0 = LCL_GetSysPrecisionAsQuantum();
#line 614
  filter->avg_var = tmp * tmp___0;
#line 615
  tmp___1 = malloc((unsigned long )filter->length * sizeof(struct FilterSample ));
#line 615
  filter->samples = (struct FilterSample *)tmp___1;
#line 616
  tmp___2 = malloc((unsigned long )filter->length * sizeof(int ));
#line 616
  filter->selected = (int *)tmp___2;
#line 617
  tmp___3 = malloc((unsigned long )filter->length * sizeof(double ));
#line 617
  filter->x_data = (double *)tmp___3;
#line 618
  tmp___4 = malloc((unsigned long )filter->length * sizeof(double ));
#line 618
  filter->y_data = (double *)tmp___4;
#line 619
  tmp___5 = malloc((unsigned long )filter->length * sizeof(double ));
#line 619
  filter->w_data = (double *)tmp___5;
  }
#line 620
  return;
}
}
#line 622 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/refclock.c"
static void filter_fini(struct MedianFilter *filter ) 
{ 


  {
  {
#line 625
  free((void *)filter->samples);
#line 626
  free((void *)filter->selected);
#line 627
  free((void *)filter->x_data);
#line 628
  free((void *)filter->y_data);
#line 629
  free((void *)filter->w_data);
  }
#line 630
  return;
}
}
#line 632 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/refclock.c"
static void filter_reset(struct MedianFilter *filter ) 
{ 


  {
#line 635
  filter->index = -1;
#line 636
  filter->used = 0;
#line 637
  return;
}
}
#line 639 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/refclock.c"
static double filter_get_avg_sample_dispersion(struct MedianFilter *filter ) 
{ 
  double tmp ;

  {
  {
#line 642
  tmp = sqrt(filter->avg_var);
  }
#line 642
  return (tmp);
}
}
#line 645 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/refclock.c"
static void filter_add_sample(struct MedianFilter *filter , struct timeval *sample_time ,
                              double offset , double dispersion ) 
{ 


  {
#line 648
  (filter->index) ++;
#line 649
  filter->index %= filter->length;
#line 650
  filter->last = filter->index;
#line 651
  if (filter->used < filter->length) {
#line 652
    (filter->used) ++;
  }
#line 654
  (filter->samples + filter->index)->sample_time = *sample_time;
#line 655
  (filter->samples + filter->index)->offset = offset;
#line 656
  (filter->samples + filter->index)->dispersion = dispersion;
#line 657
  return;
}
}
#line 659 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/refclock.c"
static int filter_get_last_sample(struct MedianFilter *filter , struct timeval *sample_time ,
                                  double *offset , double *dispersion ) 
{ 


  {
#line 662
  if (filter->last < 0) {
#line 663
    return (0);
  }
#line 665
  *sample_time = (filter->samples + filter->last)->sample_time;
#line 666
  *offset = (filter->samples + filter->last)->offset;
#line 667
  *dispersion = (filter->samples + filter->last)->dispersion;
#line 668
  return (1);
}
}
#line 671 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/refclock.c"
static struct FilterSample  const  *tmp_sorted_array  ;
#line 673 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/refclock.c"
static int sample_compare(void const   *a , void const   *b ) 
{ 
  struct FilterSample  const  *s1 ;
  struct FilterSample  const  *s2 ;

  {
#line 678
  s1 = tmp_sorted_array + *((int *)a);
#line 679
  s2 = tmp_sorted_array + *((int *)b);
#line 681
  if (s1->offset < s2->offset) {
#line 682
    return (-1);
  } else
#line 683
  if (s1->offset > s2->offset) {
#line 684
    return (1);
  }
#line 685
  return (0);
}
}
#line 688 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/refclock.c"
static int filter_select_samples(struct MedianFilter *filter ) 
{ 
  int i ;
  int j ;
  int k ;
  int o ;
  int from ;
  int to ;
  int *selected ;
  double min_dispersion ;
  int tmp ;
  int tmp___0 ;

  {
#line 694
  if (filter->used < 1) {
#line 695
    return (0);
  }
#line 699
  if (filter->length < 4) {
#line 699
    if (filter->used != filter->length) {
#line 701
      return (0);
    } else {
#line 699
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 699
  if (filter->length >= 4) {
#line 699
    if (filter->used < 4) {
#line 701
      return (0);
    }
  }
#line 703
  selected = filter->selected;
#line 705
  if (filter->used > 4) {
#line 708
    i = 1;
#line 708
    min_dispersion = (filter->samples + 0)->dispersion;
    {
#line 708
    while (1) {
      while_continue: /* CIL Label */ ;
#line 708
      if (! (i < filter->used)) {
#line 708
        goto while_break;
      }
#line 709
      if (min_dispersion > (filter->samples + i)->dispersion) {
#line 710
        min_dispersion = (filter->samples + i)->dispersion;
      }
#line 708
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 713
    j = 0;
#line 713
    i = j;
    {
#line 713
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 713
      if (! (i < filter->used)) {
#line 713
        goto while_break___0;
      }
#line 714
      if ((filter->samples + i)->dispersion <= 1.5 * min_dispersion) {
#line 715
        tmp = j;
#line 715
        j ++;
#line 715
        *(selected + tmp) = i;
      }
#line 713
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 718
    j = 0;
  }
#line 721
  if (j < 4) {
#line 724
    j = 0;
    {
#line 724
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 724
      if (! (j < filter->used)) {
#line 724
        goto while_break___1;
      }
#line 725
      *(selected + j) = j;
#line 724
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 729
  tmp_sorted_array = (struct FilterSample  const  *)filter->samples;
#line 730
  qsort((void *)selected, (size_t )j, sizeof(int ), & sample_compare);
  }
#line 733
  if (j > 2) {
#line 734
    from = j / 5;
#line 735
    if (from < 1) {
#line 736
      from = 1;
    }
#line 737
    to = j - from;
  } else {
#line 739
    from = 0;
#line 740
    to = j;
  }
#line 745
  o = (filter->used - filter->index) - 1;
#line 747
  i = 0;
  {
#line 747
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 747
    if (! (i < from)) {
#line 747
      goto while_break___2;
    }
#line 748
    *(selected + i) = -1;
#line 747
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 749
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 749
    if (! (i < to)) {
#line 749
      goto while_break___3;
    }
#line 750
    *(selected + i) = (*(selected + i) + o) % filter->used;
#line 749
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 751
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 751
    if (! (i < filter->used)) {
#line 751
      goto while_break___4;
    }
#line 752
    *(selected + i) = -1;
#line 751
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 754
  i = from;
  {
#line 754
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 754
    if (! (i < to)) {
#line 754
      goto while_break___5;
    }
#line 755
    j = *(selected + i);
#line 756
    *(selected + i) = -1;
    {
#line 757
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 757
      if (j != -1) {
#line 757
        if (! (*(selected + j) != j)) {
#line 757
          goto while_break___6;
        }
      } else {
#line 757
        goto while_break___6;
      }
#line 758
      k = *(selected + j);
#line 759
      *(selected + j) = j;
#line 760
      j = k;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 754
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 764
  j = 0;
#line 764
  i = j;
#line 764
  k = -1;
  {
#line 764
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 764
    if (! (i < filter->used)) {
#line 764
      goto while_break___7;
    }
#line 765
    if (*(selected + i) != -1) {
#line 766
      tmp___0 = j;
#line 766
      j ++;
#line 766
      *(selected + tmp___0) = ((*(selected + i) + filter->used) - o) % filter->used;
    }
#line 764
    i ++;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 769
  return (j);
}
}
#line 772 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/refclock.c"
static int filter_get_sample(struct MedianFilter *filter , struct timeval *sample_time ,
                             double *offset , double *dispersion ) 
{ 
  struct FilterSample *s ;
  struct FilterSample *ls ;
  int i ;
  int n ;
  int dof ;
  double x ;
  double y ;
  double d ;
  double e ;
  double var ;
  double prev_avg_var ;
  double tmp ;
  double b0 ;
  double b1 ;
  double s2 ;
  double sb0 ;
  double sb1 ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;

  {
  {
#line 779
  n = filter_select_samples(filter);
  }
#line 781
  if (n < 1) {
#line 782
    return (0);
  }
#line 784
  ls = filter->samples + *(filter->selected + (n - 1));
#line 787
  i = 0;
  {
#line 787
  while (1) {
    while_continue: /* CIL Label */ ;
#line 787
    if (! (i < n)) {
#line 787
      goto while_break;
    }
    {
#line 788
    s = filter->samples + *(filter->selected + i);
#line 790
    UTI_DiffTimevalsToDouble(filter->x_data + i, & s->sample_time, & ls->sample_time);
#line 791
    *(filter->y_data + i) = s->offset;
#line 792
    *(filter->w_data + i) = s->dispersion;
#line 787
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 796
  i = 0;
#line 796
  e = 0.0;
#line 796
  y = e;
#line 796
  x = y;
  {
#line 796
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 796
    if (! (i < n)) {
#line 796
      goto while_break___0;
    }
#line 797
    x += *(filter->x_data + i);
#line 798
    y += *(filter->y_data + i);
#line 799
    e += *(filter->w_data + i);
#line 796
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 801
  x /= (double )n;
#line 802
  y /= (double )n;
#line 803
  e /= (double )n;
#line 805
  tmp = sqrt(filter->avg_var);
#line 805
  e -= tmp;
  }
#line 807
  if (n >= 4) {
#line 811
    i = 0;
    {
#line 811
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 811
      if (! (i < n)) {
#line 811
        goto while_break___1;
      }
#line 812
      *(filter->x_data + i) -= x;
#line 811
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 816
    RGR_WeightedRegression(filter->x_data, filter->y_data, filter->w_data, n, & b0,
                           & b1, & s2, & sb0, & sb1);
#line 818
    var = s2;
#line 819
    d = sb0;
#line 820
    dof = n - 2;
    }
  } else
#line 821
  if (n >= 2) {
#line 822
    i = 0;
#line 822
    d = 0.0;
    {
#line 822
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 822
      if (! (i < n)) {
#line 822
        goto while_break___2;
      }
#line 823
      d += (*(filter->y_data + i) - y) * (*(filter->y_data + i) - y);
#line 822
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 824
    var = d / (double )(n - 1);
#line 825
    d = sqrt(var);
#line 826
    dof = n - 1;
    }
  } else {
    {
#line 828
    var = filter->avg_var;
#line 829
    d = sqrt(var);
#line 830
    dof = 1;
    }
  }
#line 834
  if (var < 1e-20) {
    {
#line 835
    var = 1e-20;
#line 836
    d = sqrt(var);
    }
  }
#line 839
  prev_avg_var = filter->avg_var;
#line 842
  if (filter->avg_var_n > 50) {
#line 843
    filter->avg_var += ((double )dof / ((double )dof + 50.0)) * (var - filter->avg_var);
  } else {
#line 845
    filter->avg_var = (filter->avg_var * (double )filter->avg_var_n + var * (double )dof) / (double )(dof + filter->avg_var_n);
#line 847
    if (filter->avg_var_n == 0) {
#line 848
      prev_avg_var = filter->avg_var;
    }
#line 849
    filter->avg_var_n += dof;
  }
  {
#line 854
  tmp___2 = RGR_GetChi2Coef(dof);
  }
#line 854
  if ((var * (double )dof) / tmp___2 < prev_avg_var) {
    {
#line 855
    tmp___0 = sqrt(filter->avg_var);
#line 855
    tmp___1 = sqrt(var);
#line 855
    d = (tmp___0 * d) / tmp___1;
    }
  }
#line 857
  if (d < e) {
#line 858
    d = e;
  }
  {
#line 860
  UTI_AddDoubleToTimeval(& ls->sample_time, x, sample_time);
#line 861
  *offset = y;
#line 862
  *dispersion = d;
#line 864
  filter_reset(filter);
  }
#line 866
  return (1);
}
}
#line 869 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/refclock.c"
static void filter_slew_samples(struct MedianFilter *filter , struct timeval *when ,
                                double dfreq , double doffset ) 
{ 
  int i ;
  double delta_time ;
  double prev_offset ;
  struct timeval *sample ;

  {
#line 876
  i = 0;
  {
#line 876
  while (1) {
    while_continue: /* CIL Label */ ;
#line 876
    if (! (i < filter->used)) {
#line 876
      goto while_break;
    }
    {
#line 877
    sample = & (filter->samples + i)->sample_time;
#line 878
    UTI_AdjustTimeval(sample, when, sample, & delta_time, dfreq, doffset);
#line 879
    prev_offset = (filter->samples + i)->offset;
#line 880
    (filter->samples + i)->offset -= delta_time;
#line 876
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 888
  return;
}
}
#line 890 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/refclock.c"
static void filter_add_dispersion(struct MedianFilter *filter , double dispersion ) 
{ 
  int i ;

  {
#line 895
  i = 0;
  {
#line 895
  while (1) {
    while_continue: /* CIL Label */ ;
#line 895
    if (! (i < filter->used)) {
#line 895
      goto while_break;
    }
#line 896
    (filter->samples + i)->dispersion += dispersion;
#line 895
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 898
  return;
}
}
#line 34 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/hash.h"
int HSH_GetHashId(char const   *name ) ;
#line 36
unsigned int HSH_Hash(int id , unsigned char const   *in1 , unsigned int in1_len ,
                      unsigned char const   *in2 , unsigned int in2_len , unsigned char *out ,
                      unsigned int out_len ) ;
#line 48 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/md5.h"
void MD5Init(MD5_CTX *mdContext ) ;
#line 49
void MD5Update(MD5_CTX *mdContext , unsigned char const   *inBuf , unsigned int inLen ) ;
#line 50
void MD5Final(MD5_CTX *mdContext ) ;
#line 54 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/md5.c"
static void Transform(UINT4 *buf , UINT4 *in ) ;
#line 57 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/md5.c"
static unsigned char const   PADDING[64]  = 
#line 57
  {      (unsigned char const   )128,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0};
#line 120 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/md5.c"
void MD5Init(MD5_CTX *mdContext ) 
{ 
  UINT4 tmp ;

  {
#line 123
  tmp = (UINT4 )0;
#line 123
  mdContext->i[1] = tmp;
#line 123
  mdContext->i[0] = tmp;
#line 127
  mdContext->buf[0] = (UINT4 )1732584193;
#line 128
  mdContext->buf[1] = 4023233417U;
#line 129
  mdContext->buf[2] = 2562383102U;
#line 130
  mdContext->buf[3] = (UINT4 )271733878;
#line 131
  return;
}
}
#line 137 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/md5.c"
void MD5Update(MD5_CTX *mdContext , unsigned char const   *inBuf , unsigned int inLen ) 
{ 
  UINT4 in[16] ;
  int mdi ;
  unsigned int i ;
  unsigned int ii ;
  int tmp ;
  unsigned char const   *tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 147
  mdi = (int )((mdContext->i[0] >> 3) & 63U);
#line 150
  if (mdContext->i[0] + (inLen << 3) < mdContext->i[0]) {
#line 151
    (mdContext->i[1]) ++;
  }
#line 152
  mdContext->i[0] += inLen << 3;
#line 153
  mdContext->i[1] += inLen >> 29;
  {
#line 155
  while (1) {
    while_continue: /* CIL Label */ ;
#line 155
    tmp___1 = inLen;
#line 155
    inLen --;
#line 155
    if (! tmp___1) {
#line 155
      goto while_break;
    }
#line 157
    tmp = mdi;
#line 157
    mdi ++;
#line 157
    tmp___0 = inBuf;
#line 157
    inBuf ++;
#line 157
    mdContext->in[tmp] = (unsigned char )*tmp___0;
#line 160
    if (mdi == 64) {
#line 161
      i = 0U;
#line 161
      ii = 0U;
      {
#line 161
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 161
        if (! (i < 16U)) {
#line 161
          goto while_break___0;
        }
#line 162
        in[i] = ((((UINT4 )mdContext->in[ii + 3U] << 24) | ((UINT4 )mdContext->in[ii + 2U] << 16)) | ((UINT4 )mdContext->in[ii + 1U] << 8)) | (UINT4 )mdContext->in[ii];
#line 161
        i ++;
#line 161
        ii += 4U;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 166
      Transform(mdContext->buf, in);
#line 167
      mdi = 0;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 170
  return;
}
}
#line 176 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/md5.c"
void MD5Final(MD5_CTX *mdContext ) 
{ 
  UINT4 in[16] ;
  int mdi ;
  unsigned int i ;
  unsigned int ii ;
  unsigned int padLen ;

  {
#line 185
  in[14] = mdContext->i[0];
#line 186
  in[15] = mdContext->i[1];
#line 189
  mdi = (int )((mdContext->i[0] >> 3) & 63U);
#line 192
  if (mdi < 56) {
#line 192
    padLen = (unsigned int )(56 - mdi);
  } else {
#line 192
    padLen = (unsigned int )(120 - mdi);
  }
  {
#line 193
  MD5Update(mdContext, PADDING, padLen);
#line 196
  i = 0U;
#line 196
  ii = 0U;
  }
  {
#line 196
  while (1) {
    while_continue: /* CIL Label */ ;
#line 196
    if (! (i < 14U)) {
#line 196
      goto while_break;
    }
#line 197
    in[i] = ((((UINT4 )mdContext->in[ii + 3U] << 24) | ((UINT4 )mdContext->in[ii + 2U] << 16)) | ((UINT4 )mdContext->in[ii + 1U] << 8)) | (UINT4 )mdContext->in[ii];
#line 196
    i ++;
#line 196
    ii += 4U;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 201
  Transform(mdContext->buf, in);
#line 204
  i = 0U;
#line 204
  ii = 0U;
  }
  {
#line 204
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 204
    if (! (i < 4U)) {
#line 204
      goto while_break___0;
    }
#line 205
    mdContext->digest[ii] = (unsigned char )(mdContext->buf[i] & 255U);
#line 206
    mdContext->digest[ii + 1U] = (unsigned char )((mdContext->buf[i] >> 8) & 255U);
#line 208
    mdContext->digest[ii + 2U] = (unsigned char )((mdContext->buf[i] >> 16) & 255U);
#line 210
    mdContext->digest[ii + 3U] = (unsigned char )((mdContext->buf[i] >> 24) & 255U);
#line 204
    i ++;
#line 204
    ii += 4U;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 213
  return;
}
}
#line 217 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/md5.c"
static void Transform(UINT4 *buf , UINT4 *in ) 
{ 
  UINT4 a ;
  UINT4 b ;
  UINT4 c ;
  UINT4 d ;

  {
#line 221
  a = *(buf + 0);
#line 221
  b = *(buf + 1);
#line 221
  c = *(buf + 2);
#line 221
  d = *(buf + 3);
#line 229
  a += (((b & c) | (~ b & d)) + *(in + 0)) + 3614090360U;
#line 229
  a = (a << 7) | (a >> 25);
#line 229
  a += b;
#line 230
  d += (((a & b) | (~ a & c)) + *(in + 1)) + 3905402710U;
#line 230
  d = (d << 12) | (d >> 20);
#line 230
  d += a;
#line 231
  c += (((d & a) | (~ d & b)) + *(in + 2)) + 606105819U;
#line 231
  c = (c << 17) | (c >> 15);
#line 231
  c += d;
#line 232
  b += (((c & d) | (~ c & a)) + *(in + 3)) + 3250441966U;
#line 232
  b = (b << 22) | (b >> 10);
#line 232
  b += c;
#line 233
  a += (((b & c) | (~ b & d)) + *(in + 4)) + 4118548399U;
#line 233
  a = (a << 7) | (a >> 25);
#line 233
  a += b;
#line 234
  d += (((a & b) | (~ a & c)) + *(in + 5)) + 1200080426U;
#line 234
  d = (d << 12) | (d >> 20);
#line 234
  d += a;
#line 235
  c += (((d & a) | (~ d & b)) + *(in + 6)) + 2821735955U;
#line 235
  c = (c << 17) | (c >> 15);
#line 235
  c += d;
#line 236
  b += (((c & d) | (~ c & a)) + *(in + 7)) + 4249261313U;
#line 236
  b = (b << 22) | (b >> 10);
#line 236
  b += c;
#line 237
  a += (((b & c) | (~ b & d)) + *(in + 8)) + 1770035416U;
#line 237
  a = (a << 7) | (a >> 25);
#line 237
  a += b;
#line 238
  d += (((a & b) | (~ a & c)) + *(in + 9)) + 2336552879U;
#line 238
  d = (d << 12) | (d >> 20);
#line 238
  d += a;
#line 239
  c += (((d & a) | (~ d & b)) + *(in + 10)) + 4294925233U;
#line 239
  c = (c << 17) | (c >> 15);
#line 239
  c += d;
#line 240
  b += (((c & d) | (~ c & a)) + *(in + 11)) + 2304563134U;
#line 240
  b = (b << 22) | (b >> 10);
#line 240
  b += c;
#line 241
  a += (((b & c) | (~ b & d)) + *(in + 12)) + 1804603682U;
#line 241
  a = (a << 7) | (a >> 25);
#line 241
  a += b;
#line 242
  d += (((a & b) | (~ a & c)) + *(in + 13)) + 4254626195U;
#line 242
  d = (d << 12) | (d >> 20);
#line 242
  d += a;
#line 243
  c += (((d & a) | (~ d & b)) + *(in + 14)) + 2792965006U;
#line 243
  c = (c << 17) | (c >> 15);
#line 243
  c += d;
#line 244
  b += (((c & d) | (~ c & a)) + *(in + 15)) + 1236535329U;
#line 244
  b = (b << 22) | (b >> 10);
#line 244
  b += c;
#line 251
  a += (((b & d) | (c & ~ d)) + *(in + 1)) + 4129170786U;
#line 251
  a = (a << 5) | (a >> 27);
#line 251
  a += b;
#line 252
  d += (((a & c) | (b & ~ c)) + *(in + 6)) + 3225465664U;
#line 252
  d = (d << 9) | (d >> 23);
#line 252
  d += a;
#line 253
  c += (((d & b) | (a & ~ b)) + *(in + 11)) + 643717713U;
#line 253
  c = (c << 14) | (c >> 18);
#line 253
  c += d;
#line 254
  b += (((c & a) | (d & ~ a)) + *(in + 0)) + 3921069994U;
#line 254
  b = (b << 20) | (b >> 12);
#line 254
  b += c;
#line 255
  a += (((b & d) | (c & ~ d)) + *(in + 5)) + 3593408605U;
#line 255
  a = (a << 5) | (a >> 27);
#line 255
  a += b;
#line 256
  d += (((a & c) | (b & ~ c)) + *(in + 10)) + 38016083U;
#line 256
  d = (d << 9) | (d >> 23);
#line 256
  d += a;
#line 257
  c += (((d & b) | (a & ~ b)) + *(in + 15)) + 3634488961U;
#line 257
  c = (c << 14) | (c >> 18);
#line 257
  c += d;
#line 258
  b += (((c & a) | (d & ~ a)) + *(in + 4)) + 3889429448U;
#line 258
  b = (b << 20) | (b >> 12);
#line 258
  b += c;
#line 259
  a += (((b & d) | (c & ~ d)) + *(in + 9)) + 568446438U;
#line 259
  a = (a << 5) | (a >> 27);
#line 259
  a += b;
#line 260
  d += (((a & c) | (b & ~ c)) + *(in + 14)) + 3275163606U;
#line 260
  d = (d << 9) | (d >> 23);
#line 260
  d += a;
#line 261
  c += (((d & b) | (a & ~ b)) + *(in + 3)) + 4107603335U;
#line 261
  c = (c << 14) | (c >> 18);
#line 261
  c += d;
#line 262
  b += (((c & a) | (d & ~ a)) + *(in + 8)) + 1163531501U;
#line 262
  b = (b << 20) | (b >> 12);
#line 262
  b += c;
#line 263
  a += (((b & d) | (c & ~ d)) + *(in + 13)) + 2850285829U;
#line 263
  a = (a << 5) | (a >> 27);
#line 263
  a += b;
#line 264
  d += (((a & c) | (b & ~ c)) + *(in + 2)) + 4243563512U;
#line 264
  d = (d << 9) | (d >> 23);
#line 264
  d += a;
#line 265
  c += (((d & b) | (a & ~ b)) + *(in + 7)) + 1735328473U;
#line 265
  c = (c << 14) | (c >> 18);
#line 265
  c += d;
#line 266
  b += (((c & a) | (d & ~ a)) + *(in + 12)) + 2368359562U;
#line 266
  b = (b << 20) | (b >> 12);
#line 266
  b += c;
#line 273
  a += (((b ^ c) ^ d) + *(in + 5)) + 4294588738U;
#line 273
  a = (a << 4) | (a >> 28);
#line 273
  a += b;
#line 274
  d += (((a ^ b) ^ c) + *(in + 8)) + 2272392833U;
#line 274
  d = (d << 11) | (d >> 21);
#line 274
  d += a;
#line 275
  c += (((d ^ a) ^ b) + *(in + 11)) + 1839030562U;
#line 275
  c = (c << 16) | (c >> 16);
#line 275
  c += d;
#line 276
  b += (((c ^ d) ^ a) + *(in + 14)) + 4259657740U;
#line 276
  b = (b << 23) | (b >> 9);
#line 276
  b += c;
#line 277
  a += (((b ^ c) ^ d) + *(in + 1)) + 2763975236U;
#line 277
  a = (a << 4) | (a >> 28);
#line 277
  a += b;
#line 278
  d += (((a ^ b) ^ c) + *(in + 4)) + 1272893353U;
#line 278
  d = (d << 11) | (d >> 21);
#line 278
  d += a;
#line 279
  c += (((d ^ a) ^ b) + *(in + 7)) + 4139469664U;
#line 279
  c = (c << 16) | (c >> 16);
#line 279
  c += d;
#line 280
  b += (((c ^ d) ^ a) + *(in + 10)) + 3200236656U;
#line 280
  b = (b << 23) | (b >> 9);
#line 280
  b += c;
#line 281
  a += (((b ^ c) ^ d) + *(in + 13)) + 681279174U;
#line 281
  a = (a << 4) | (a >> 28);
#line 281
  a += b;
#line 282
  d += (((a ^ b) ^ c) + *(in + 0)) + 3936430074U;
#line 282
  d = (d << 11) | (d >> 21);
#line 282
  d += a;
#line 283
  c += (((d ^ a) ^ b) + *(in + 3)) + 3572445317U;
#line 283
  c = (c << 16) | (c >> 16);
#line 283
  c += d;
#line 284
  b += (((c ^ d) ^ a) + *(in + 6)) + 76029189U;
#line 284
  b = (b << 23) | (b >> 9);
#line 284
  b += c;
#line 285
  a += (((b ^ c) ^ d) + *(in + 9)) + 3654602809U;
#line 285
  a = (a << 4) | (a >> 28);
#line 285
  a += b;
#line 286
  d += (((a ^ b) ^ c) + *(in + 12)) + 3873151461U;
#line 286
  d = (d << 11) | (d >> 21);
#line 286
  d += a;
#line 287
  c += (((d ^ a) ^ b) + *(in + 15)) + 530742520U;
#line 287
  c = (c << 16) | (c >> 16);
#line 287
  c += d;
#line 288
  b += (((c ^ d) ^ a) + *(in + 2)) + 3299628645U;
#line 288
  b = (b << 23) | (b >> 9);
#line 288
  b += c;
#line 295
  a += ((c ^ (b | ~ d)) + *(in + 0)) + 4096336452U;
#line 295
  a = (a << 6) | (a >> 26);
#line 295
  a += b;
#line 296
  d += ((b ^ (a | ~ c)) + *(in + 7)) + 1126891415U;
#line 296
  d = (d << 10) | (d >> 22);
#line 296
  d += a;
#line 297
  c += ((a ^ (d | ~ b)) + *(in + 14)) + 2878612391U;
#line 297
  c = (c << 15) | (c >> 17);
#line 297
  c += d;
#line 298
  b += ((d ^ (c | ~ a)) + *(in + 5)) + 4237533241U;
#line 298
  b = (b << 21) | (b >> 11);
#line 298
  b += c;
#line 299
  a += ((c ^ (b | ~ d)) + *(in + 12)) + 1700485571U;
#line 299
  a = (a << 6) | (a >> 26);
#line 299
  a += b;
#line 300
  d += ((b ^ (a | ~ c)) + *(in + 3)) + 2399980690U;
#line 300
  d = (d << 10) | (d >> 22);
#line 300
  d += a;
#line 301
  c += ((a ^ (d | ~ b)) + *(in + 10)) + 4293915773U;
#line 301
  c = (c << 15) | (c >> 17);
#line 301
  c += d;
#line 302
  b += ((d ^ (c | ~ a)) + *(in + 1)) + 2240044497U;
#line 302
  b = (b << 21) | (b >> 11);
#line 302
  b += c;
#line 303
  a += ((c ^ (b | ~ d)) + *(in + 8)) + 1873313359U;
#line 303
  a = (a << 6) | (a >> 26);
#line 303
  a += b;
#line 304
  d += ((b ^ (a | ~ c)) + *(in + 15)) + 4264355552U;
#line 304
  d = (d << 10) | (d >> 22);
#line 304
  d += a;
#line 305
  c += ((a ^ (d | ~ b)) + *(in + 6)) + 2734768916U;
#line 305
  c = (c << 15) | (c >> 17);
#line 305
  c += d;
#line 306
  b += ((d ^ (c | ~ a)) + *(in + 13)) + 1309151649U;
#line 306
  b = (b << 21) | (b >> 11);
#line 306
  b += c;
#line 307
  a += ((c ^ (b | ~ d)) + *(in + 4)) + 4149444226U;
#line 307
  a = (a << 6) | (a >> 26);
#line 307
  a += b;
#line 308
  d += ((b ^ (a | ~ c)) + *(in + 11)) + 3174756917U;
#line 308
  d = (d << 10) | (d >> 22);
#line 308
  d += a;
#line 309
  c += ((a ^ (d | ~ b)) + *(in + 2)) + 718787259U;
#line 309
  c = (c << 15) | (c >> 17);
#line 309
  c += d;
#line 310
  b += ((d ^ (c | ~ a)) + *(in + 9)) + 3951481745U;
#line 310
  b = (b << 21) | (b >> 11);
#line 310
  b += c;
#line 312
  *(buf + 0) += a;
#line 313
  *(buf + 1) += b;
#line 314
  *(buf + 2) += c;
#line 315
  *(buf + 3) += d;
#line 316
  return;
}
}
#line 35 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/hash_intmd5.c"
static MD5_CTX ctx  ;
#line 37 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/hash_intmd5.c"
int HSH_GetHashId(char const   *name ) 
{ 
  int tmp ;

  {
  {
#line 41
  tmp = strcmp(name, "MD5");
  }
#line 41
  if (tmp) {
#line 42
    return (-1);
  }
#line 44
  return (0);
}
}
#line 47 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/hash_intmd5.c"
unsigned int HSH_Hash(int id , unsigned char const   *in1 , unsigned int in1_len ,
                      unsigned char const   *in2 , unsigned int in2_len , unsigned char *out ,
                      unsigned int out_len ) 
{ 


  {
#line 52
  if (out_len < 16U) {
#line 53
    return (0U);
  }
  {
#line 55
  MD5Init(& ctx);
#line 56
  MD5Update(& ctx, in1, in1_len);
  }
#line 57
  if (in2) {
    {
#line 58
    MD5Update(& ctx, in2, in2_len);
    }
  }
  {
#line 59
  MD5Final(& ctx);
#line 61
  memcpy((void */* __restrict  */)out, (void const   */* __restrict  */)(ctx.digest),
         (size_t )16);
  }
#line 63
  return (16U);
}
}
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 123
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  * __restrict  __addr ,
                                                                           socklen_t __len ) ;
#line 163
extern ssize_t sendto(int __fd , void const   *__buf , size_t __n , int __flags ,
                      struct sockaddr  const  * __restrict  __addr , socklen_t __addr_len ) ;
#line 174
extern ssize_t recvfrom(int __fd , void * __restrict  __buf , size_t __n , int __flags ,
                        struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 226
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void const   *__optval ,
                                                                                 socklen_t __optlen ) ;
#line 227 "/usr/include/netinet/in.h"
extern struct in6_addr  const  in6addr_any ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 36 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.h"
int CAM_AddAccessRestriction(IPAddr *ip_addr , int subnet_bits , int allow , int all ) ;
#line 37
int CAM_CheckAccessRestriction(IPAddr *ip_addr ) ;
#line 85 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/util.h"
void UTI_IPHostToNetwork(IPAddr *src , IPAddr *dest ) ;
#line 86
void UTI_IPNetworkToHost(IPAddr *src , IPAddr *dest ) ;
#line 104
void UTI_TimevalNetworkToHost(Timeval *src , struct timeval *dest ) ;
#line 105
void UTI_TimevalHostToNetwork(struct timeval *src , Timeval *dest ) ;
#line 107
double UTI_FloatNetworkToHost(Float f ) ;
#line 108
Float UTI_FloatHostToNetwork(double x ) ;
#line 116 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/logging.h"
void LOG_CycleLogFiles(void) ;
#line 33 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/keys.h"
void KEY_Reload(void) ;
#line 35
unsigned long KEY_GetCommandKey(void) ;
#line 141 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sources.h"
void SRC_ReselectSource(void) ;
#line 144
void SRC_SetReselectDistance(double distance ) ;
#line 164
int SRC_ReadNumberOfSources(void) ;
#line 165
int SRC_ReportSource(int index___0 , RPT_SourceReport *report , struct timeval *now ) ;
#line 167
int SRC_ReportSourcestats(int index___0 , RPT_SourcestatsReport *report , struct timeval *now ) ;
#line 169
SRC_Type SRC_GetType(int index___0 ) ;
#line 137 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.h"
void REF_ModifyMaxupdateskew(double new_max_update_skew ) ;
#line 139
void REF_EnableLocal(int stratum ) ;
#line 140
void REF_DisableLocal(void) ;
#line 143
void REF_GetTrackingReport(RPT_TrackingReport *rep ) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/local.h"
void LCL_CookTime(struct timeval *raw , struct timeval *cooked , double *err ) ;
#line 136
void LCL_AccumulateDeltaFrequency(double dfreq ) ;
#line 186
int LCL_MakeStep(double threshold ) ;
#line 62 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.h"
int CNF_GetCommandPort(void) ;
#line 73
void CNF_GetBindCommandAddress(int family , IPAddr *addr ) ;
#line 36 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc.h"
int RTC_GetReport(RPT_RTC_Report *report ) ;
#line 42
int RTC_WriteParameters(void) ;
#line 44
int RTC_Trim(void) ;
#line 64 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
static int sock_fd4  ;
#line 66 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
static int sock_fd6  ;
#line 70 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
static int initialised___1  =    0;
#line 73 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
static unsigned long utoken  ;
#line 76 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
static unsigned long issued_tokens  ;
#line 79 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
static unsigned long returned_tokens  ;
#line 82 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
static unsigned long token_base  ;
#line 85 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
static unsigned long issue_pointer  ;
#line 107 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
static ResponseCell kept_replies  ;
#line 108 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
static ResponseCell *free_replies  ;
#line 113 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
static int permissions[50]  = 
#line 113
  {      0,      2,      2,      2, 
        2,      2,      2,      2, 
        2,      2,      0,      2, 
        2,      2,      0,      0, 
        2,      2,      2,      2, 
        2,      2,      2,      2, 
        2,      2,      2,      2, 
        2,      2,      2,      2, 
        2,      0,      0,      0, 
        2,      2,      2,      2, 
        2,      0,      2,      2, 
        0,      2,      2,      2, 
        2,      2};
#line 170 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
static ADF_AuthTable access_auth_table___0  ;
#line 174
static int prepare_socket(int family ) ;
#line 175
static void read_from_cmd_socket(void *anything ) ;
#line 179 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
static int prepare_socket(int family ) 
{ 
  int port_number ;
  int sock_fd___0 ;
  socklen_t my_addr_len ;
  union sockaddr_in46 my_addr ;
  IPAddr bind_address ;
  int on_off ;
  int *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  char const   *tmp___6 ;
  int tmp___7 ;

  {
  {
#line 186
  on_off = 1;
#line 188
  port_number = CNF_GetCommandPort();
#line 190
  sock_fd___0 = socket(family, 2, 0);
  }
#line 191
  if (sock_fd___0 < 0) {
    {
#line 192
    LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c",
                 192, "prepare_socket");
#line 192
    tmp = __errno_location();
#line 192
    tmp___0 = strerror(*tmp);
    }
#line 192
    if (family == 2) {
#line 192
      tmp___1 = "IPv4";
    } else {
#line 192
      tmp___1 = "IPv6";
    }
    {
#line 192
    LOG_Line_Function((LOG_Severity )2, (LOG_Facility )12, "Could not open %s command socket : %s",
                      tmp___1, tmp___0);
    }
#line 194
    return (-1);
  }
  {
#line 198
  UTI_FdSetCloexec(sock_fd___0);
#line 201
  tmp___2 = setsockopt(sock_fd___0, 1, 2, (void const   *)((char *)(& on_off)), (socklen_t )sizeof(on_off));
  }
#line 201
  if (tmp___2 < 0) {
    {
#line 202
    LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c",
                 202, "prepare_socket");
#line 202
    LOG_Line_Function((LOG_Severity )2, (LOG_Facility )12, "Could not set reuseaddr socket options");
    }
  }
#line 206
  if (family == 10) {
    {
#line 209
    tmp___3 = setsockopt(sock_fd___0, 41, 26, (void const   *)((char *)(& on_off)),
                         (socklen_t )sizeof(on_off));
    }
#line 209
    if (tmp___3 < 0) {
      {
#line 210
      LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c",
                   210, "prepare_socket");
#line 210
      LOG_Line_Function((LOG_Severity )2, (LOG_Facility )12, "Could not request IPV6_V6ONLY socket option");
      }
    }
  }
  {
#line 216
  memset((void *)(& my_addr), 0, sizeof(my_addr));
  }
  {
#line 219
  if (family == 2) {
#line 219
    goto case_2;
  }
#line 232
  if (family == 10) {
#line 232
    goto case_10;
  }
#line 246
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 220
  my_addr_len = (socklen_t )sizeof(my_addr.in4);
#line 221
  my_addr.in4.sin_family = (sa_family_t )family;
#line 222
  my_addr.in4.sin_port = htons((unsigned short )port_number);
#line 224
  CNF_GetBindCommandAddress(1, & bind_address);
  }
#line 226
  if ((int )bind_address.family == 1) {
    {
#line 227
    my_addr.in4.sin_addr.s_addr = htonl(bind_address.addr.in4);
    }
  } else {
    {
#line 229
    my_addr.in4.sin_addr.s_addr = htonl((in_addr_t )0);
    }
  }
#line 230
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 233
  my_addr_len = (socklen_t )sizeof(my_addr.in6);
#line 234
  my_addr.in6.sin6_family = (sa_family_t )family;
#line 235
  my_addr.in6.sin6_port = htons((unsigned short )port_number);
#line 237
  CNF_GetBindCommandAddress(2, & bind_address);
  }
#line 239
  if ((int )bind_address.family == 2) {
    {
#line 240
    memcpy((void */* __restrict  */)(my_addr.in6.sin6_addr.__in6_u.__u6_addr8), (void const   */* __restrict  */)(bind_address.addr.in6),
           sizeof(my_addr.in6.sin6_addr.__in6_u.__u6_addr8));
    }
  } else {
#line 243
    my_addr.in6.sin6_addr = (struct in6_addr )in6addr_any;
  }
#line 244
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 247
  __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c",
                247U, "prepare_socket");
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 250
  tmp___7 = bind(sock_fd___0, (struct sockaddr  const  */* __restrict  */)(& my_addr.u),
                 my_addr_len);
  }
#line 250
  if (tmp___7 < 0) {
    {
#line 251
    LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c",
                 251, "prepare_socket");
#line 251
    tmp___4 = __errno_location();
#line 251
    tmp___5 = strerror(*tmp___4);
    }
#line 251
    if (family == 2) {
#line 251
      tmp___6 = "IPv4";
    } else {
#line 251
      tmp___6 = "IPv6";
    }
    {
#line 251
    LOG_Line_Function((LOG_Severity )2, (LOG_Facility )12, "Could not bind %s command socket : %s",
                      tmp___6, tmp___5);
#line 253
    close(sock_fd___0);
    }
#line 254
    return (-1);
  }
  {
#line 258
  SCH_AddInputFileHandler(sock_fd___0, & read_from_cmd_socket, (void *)((long )sock_fd___0));
  }
#line 260
  return (sock_fd___0);
}
}
#line 265 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
void CAM_Initialise(int family ) 
{ 
  time_t tmp ;

  {
#line 268
  if (! (! initialised___1)) {
    {
#line 268
    __assert_fail("!initialised", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c",
                  268U, "CAM_Initialise");
    }
  }
#line 269
  initialised___1 = 1;
#line 271
  if (! (sizeof(permissions) / sizeof(permissions[0]) == 50UL)) {
    {
#line 271
    __assert_fail("sizeof (permissions) / sizeof (permissions[0]) == 50", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c",
                  271U, "CAM_Initialise");
    }
  }
  {
#line 273
  tmp = time((time_t *)((void *)0));
#line 273
  utoken = (unsigned long )tmp;
#line 275
  issue_pointer = 0UL;
#line 275
  returned_tokens = issue_pointer;
#line 275
  issued_tokens = returned_tokens;
#line 276
  token_base = 1UL;
#line 279
  free_replies = (ResponseCell *)((void *)0);
#line 280
  kept_replies.next = (struct _ResponseCell *)((void *)0);
  }
#line 282
  if (family == 0) {
    {
#line 283
    sock_fd4 = prepare_socket(2);
    }
  } else
#line 282
  if (family == 1) {
    {
#line 283
    sock_fd4 = prepare_socket(2);
    }
  } else {
#line 285
    sock_fd4 = -1;
  }
#line 287
  if (family == 0) {
    {
#line 288
    sock_fd6 = prepare_socket(10);
    }
  } else
#line 287
  if (family == 2) {
    {
#line 288
    sock_fd6 = prepare_socket(10);
    }
  } else {
#line 290
    sock_fd6 = -1;
  }
#line 293
  if (sock_fd4 < 0) {
#line 293
    if (sock_fd6 < 0) {
      {
#line 298
      LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c",
                   298, "CAM_Initialise");
#line 298
      LOG_Fatal_Function((LOG_Facility )12, "Could not open any command socket");
      }
    }
  }
  {
#line 301
  access_auth_table___0 = ADF_CreateTable();
  }
#line 303
  return;
}
}
#line 307 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
void CAM_Finalise(void) 
{ 


  {
#line 310
  if (sock_fd4 >= 0) {
    {
#line 311
    SCH_RemoveInputFileHandler(sock_fd4);
#line 312
    close(sock_fd4);
    }
  }
#line 314
  sock_fd4 = -1;
#line 316
  if (sock_fd6 >= 0) {
    {
#line 317
    SCH_RemoveInputFileHandler(sock_fd6);
#line 318
    close(sock_fd6);
    }
  }
  {
#line 320
  sock_fd6 = -1;
#line 323
  ADF_DestroyTable(access_auth_table___0);
#line 325
  initialised___1 = 0;
  }
#line 326
  return;
}
}
#line 333 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
static int check_rx_packet_auth(CMD_Request *packet , int packet_len ) 
{ 
  int pkt_len ;
  int auth_len ;
  unsigned long tmp ;
  int tmp___0 ;

  {
  {
#line 338
  pkt_len = PKL_CommandLength(packet);
#line 339
  auth_len = packet_len - pkt_len;
#line 341
  tmp = KEY_GetCommandKey();
#line 341
  tmp___0 = KEY_CheckAuth(tmp, (unsigned char const   *)((unsigned char *)packet),
                          pkt_len, (unsigned char const   *)((unsigned char *)packet + pkt_len),
                          auth_len);
  }
#line 341
  return (tmp___0);
}
}
#line 347 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
static int generate_tx_packet_auth(CMD_Reply *packet ) 
{ 
  int pkt_len ;
  unsigned long tmp ;
  int tmp___0 ;

  {
  {
#line 352
  pkt_len = PKL_ReplyLength(packet);
#line 354
  tmp = KEY_GetCommandKey();
#line 354
  tmp___0 = KEY_GenerateAuth(tmp, (unsigned char const   *)((unsigned char *)packet),
                             pkt_len, (unsigned char *)packet + pkt_len, (int )sizeof(packet->auth));
  }
#line 354
  return (tmp___0);
}
}
#line 360 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
static void shift_tokens(void) 
{ 


  {
  {
#line 363
  while (1) {
    while_continue: /* CIL Label */ ;
#line 364
    issued_tokens >>= 1;
#line 365
    returned_tokens >>= 1;
#line 366
    token_base ++;
#line 367
    issue_pointer --;
#line 363
    if (issued_tokens & 1UL) {
#line 363
      if (! (returned_tokens & 1UL)) {
#line 363
        goto while_break;
      }
    } else {
#line 363
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 369
  return;
}
}
#line 373 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
static unsigned long get_token(void) 
{ 
  unsigned long result ;

  {
#line 378
  if (issue_pointer == 32UL) {
    {
#line 381
    shift_tokens();
    }
  }
#line 384
  result = token_base + issue_pointer;
#line 385
  issued_tokens |= 1UL << issue_pointer;
#line 386
  issue_pointer ++;
#line 388
  return (result);
}
}
#line 393 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
static int check_token(unsigned long token___0 ) 
{ 
  int result ;
  unsigned long pos ;

  {
#line 399
  if (token___0 < token_base) {
#line 401
    result = 0;
  } else {
#line 403
    pos = token___0 - token_base;
#line 404
    if (pos >= issue_pointer) {
#line 406
      result = 0;
    } else
#line 408
    if (returned_tokens & (1UL << pos)) {
#line 410
      result = 0;
    } else {
#line 413
      result = 1;
#line 414
      returned_tokens |= 1UL << pos;
#line 415
      if (pos == 0UL) {
        {
#line 416
        shift_tokens();
        }
      }
    }
  }
#line 422
  return (result);
}
}
#line 437 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
static struct _TimestampCell seen_ts_list  =    {(struct _TimestampCell *)((void *)0), {0L, 0L}};
#line 438 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
static struct _TimestampCell *free_ts_list  =    (struct _TimestampCell *)((void *)0);
#line 444 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
static TimestampCell *allocate_ts_cell(void) 
{ 
  TimestampCell *result ;
  int i ;
  void *tmp ;

  {
#line 449
  if ((unsigned long )free_ts_list == (unsigned long )((void *)0)) {
    {
#line 450
    tmp = malloc(32UL * sizeof(TimestampCell ));
#line 450
    free_ts_list = (TimestampCell *)tmp;
#line 451
    i = 0;
    }
    {
#line 451
    while (1) {
      while_continue: /* CIL Label */ ;
#line 451
      if (! (i < 31)) {
#line 451
        goto while_break;
      }
#line 452
      (free_ts_list + i)->next = (free_ts_list + i) + 1;
#line 451
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 454
    (free_ts_list + 31)->next = (struct _TimestampCell *)((void *)0);
  }
#line 457
  result = free_ts_list;
#line 458
  free_ts_list = free_ts_list->next;
#line 459
  return (result);
}
}
#line 464 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
static void release_ts_cell(TimestampCell *node ) 
{ 


  {
#line 467
  node->next = free_ts_list;
#line 468
  free_ts_list = node;
#line 469
  return;
}
}
#line 475 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
static int check_unique_ts(struct timeval *ts , struct timeval *now ) 
{ 
  TimestampCell *last_valid ;
  TimestampCell *cell ;
  TimestampCell *next ;
  int ok ;

  {
#line 481
  ok = 1;
#line 482
  last_valid = & seen_ts_list;
#line 483
  cell = last_valid->next;
  {
#line 485
  while (1) {
    while_continue: /* CIL Label */ ;
#line 485
    if (! cell) {
#line 485
      goto while_break;
    }
#line 486
    next = cell->next;
#line 488
    if (now->tv_sec - cell->ts.tv_sec > 20L) {
      {
#line 489
      release_ts_cell(cell);
#line 490
      last_valid->next = next;
      }
    } else {
#line 493
      last_valid->next = cell;
#line 494
      last_valid = cell;
#line 495
      if (cell->ts.tv_sec == ts->tv_sec) {
#line 495
        if (cell->ts.tv_usec == ts->tv_usec) {
#line 496
          ok = 0;
        }
      }
    }
#line 499
    cell = next;
  }
  while_break: /* CIL Label */ ;
  }
#line 502
  if (ok) {
    {
#line 504
    cell = allocate_ts_cell();
#line 505
    last_valid->next = cell;
#line 506
    cell->next = (struct _TimestampCell *)((void *)0);
#line 507
    cell->ts = *ts;
    }
  }
#line 510
  return (ok);
}
}
#line 515 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
static int ts_is_unique_and_not_stale(struct timeval *ts , struct timeval *now ) 
{ 
  int within_margin ;
  int is_unique ;
  long diff ;
  int tmp ;

  {
#line 518
  within_margin = 0;
#line 519
  is_unique = 0;
#line 522
  diff = now->tv_sec - ts->tv_sec;
#line 523
  if (diff < 20L) {
#line 523
    if (diff > -20L) {
#line 524
      within_margin = 1;
    } else {
#line 526
      within_margin = 0;
    }
  } else {
#line 526
    within_margin = 0;
  }
  {
#line 528
  is_unique = check_unique_ts(ts, now);
  }
#line 530
  if (within_margin) {
#line 530
    if (is_unique) {
#line 530
      tmp = 1;
    } else {
#line 530
      tmp = 0;
    }
  } else {
#line 530
    tmp = 0;
  }
#line 530
  return (tmp);
}
}
#line 537 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
static void get_more_replies(void) 
{ 
  ResponseCell *new_replies ;
  int i ;
  void *tmp ;

  {
#line 543
  if (! free_replies) {
    {
#line 544
    tmp = malloc(32UL * sizeof(ResponseCell ));
#line 544
    new_replies = (ResponseCell *)tmp;
#line 545
    i = 1;
    }
    {
#line 545
    while (1) {
      while_continue: /* CIL Label */ ;
#line 545
      if (! (i < 32)) {
#line 545
        goto while_break;
      }
#line 546
      (new_replies + (i - 1))->next = new_replies + i;
#line 545
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 548
    free_replies = new_replies;
  }
#line 550
  return;
}
}
#line 554 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
static ResponseCell *get_reply_slot(void) 
{ 
  ResponseCell *result ;

  {
#line 558
  if (! free_replies) {
    {
#line 559
    get_more_replies();
    }
  }
#line 561
  result = free_replies;
#line 562
  free_replies = result->next;
#line 563
  return (result);
}
}
#line 568 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
static void free_reply_slot(ResponseCell *cell ) 
{ 


  {
#line 571
  cell->next = free_replies;
#line 572
  free_replies = cell;
#line 573
  return;
}
}
#line 577 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
static void save_reply(CMD_Reply *msg , unsigned long tok_reply_to , unsigned long new_tok_issued ,
                       unsigned long client_msg_seq , unsigned short attempt , struct timeval *now ) 
{ 
  ResponseCell *cell ;

  {
  {
#line 587
  cell = get_reply_slot();
#line 589
  cell->ts = *now;
#line 590
  memcpy((void */* __restrict  */)(& cell->rpy), (void const   */* __restrict  */)msg,
         sizeof(CMD_Reply ));
#line 591
  cell->tok = tok_reply_to;
#line 592
  cell->next_tok = new_tok_issued;
#line 593
  cell->msg_seq = client_msg_seq;
#line 594
  cell->attempt = (unsigned long )attempt;
#line 596
  cell->next = kept_replies.next;
#line 597
  kept_replies.next = cell;
  }
#line 599
  return;
}
}
#line 603 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
static CMD_Reply *lookup_reply(unsigned long prev_msg_token , unsigned long client_msg_seq ,
                               unsigned short attempt ) 
{ 
  ResponseCell *ptr ;

  {
#line 608
  ptr = kept_replies.next;
  {
#line 609
  while (1) {
    while_continue: /* CIL Label */ ;
#line 609
    if (! ptr) {
#line 609
      goto while_break;
    }
#line 610
    if (ptr->tok == prev_msg_token) {
#line 610
      if (ptr->msg_seq == client_msg_seq) {
#line 610
        if ((unsigned long )attempt > ptr->attempt) {
#line 616
          ptr->attempt = (unsigned long )attempt;
#line 617
          return (& ptr->rpy);
        }
      }
    }
#line 619
    ptr = ptr->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 622
  return ((CMD_Reply *)((void *)0));
}
}
#line 630 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
static void token_acknowledged(unsigned long token___0 , struct timeval *now ) 
{ 
  ResponseCell *last_valid ;
  ResponseCell *cell ;
  ResponseCell *next ;

  {
#line 635
  last_valid = & kept_replies;
#line 636
  cell = kept_replies.next;
  {
#line 638
  while (1) {
    while_continue: /* CIL Label */ ;
#line 638
    if (! cell) {
#line 638
      goto while_break;
    }
#line 639
    next = cell->next;
#line 642
    if (cell->next_tok == token___0) {
      {
#line 644
      free_reply_slot(cell);
#line 645
      last_valid->next = next;
      }
    } else
#line 642
    if (now->tv_sec - cell->ts.tv_sec > 300L) {
      {
#line 644
      free_reply_slot(cell);
#line 645
      last_valid->next = next;
      }
    } else {
#line 647
      last_valid->next = cell;
#line 648
      last_valid = cell;
    }
#line 650
    cell = next;
  }
  while_break: /* CIL Label */ ;
  }
#line 652
  return;
}
}
#line 696 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
static void transmit_reply(CMD_Reply *msg , union sockaddr_in46 *where_to , int auth_len ) 
{ 
  int status___0 ;
  int tx_message_length ;
  int sock_fd___0 ;
  socklen_t addrlen ;
  int tmp ;
  ssize_t tmp___0 ;
  unsigned short port ;
  IPAddr ip ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 705
  if ((int )where_to->u.sa_family == 2) {
#line 705
    goto case_2;
  }
#line 710
  if ((int )where_to->u.sa_family == 10) {
#line 710
    goto case_10;
  }
#line 715
  goto switch_default;
  case_2: /* CIL Label */ 
#line 706
  sock_fd___0 = sock_fd4;
#line 707
  addrlen = (socklen_t )sizeof(where_to->in4);
#line 708
  goto switch_break;
  case_10: /* CIL Label */ 
#line 711
  sock_fd___0 = sock_fd6;
#line 712
  addrlen = (socklen_t )sizeof(where_to->in6);
#line 713
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 716
  __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c",
                716U, "transmit_reply");
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 719
  tmp = PKL_ReplyLength(msg);
#line 719
  tx_message_length = tmp + auth_len;
#line 720
  tmp___0 = sendto(sock_fd___0, (void const   *)((void *)msg), (size_t )tx_message_length,
                   0, (struct sockaddr  const  */* __restrict  */)(& where_to->u),
                   addrlen);
#line 720
  status___0 = (int )tmp___0;
  }
#line 723
  if (status___0 < 0) {
    {
#line 723
    tmp___2 = LOG_RateLimited();
    }
#line 723
    if (! tmp___2) {
      {
#line 728
      if ((int )where_to->u.sa_family == 2) {
#line 728
        goto case_2___0;
      }
#line 734
      if ((int )where_to->u.sa_family == 10) {
#line 734
        goto case_10___0;
      }
#line 740
      goto switch_default___0;
      case_2___0: /* CIL Label */ 
      {
#line 729
      ip.family = (uint16_t )1;
#line 730
      ip.addr.in4 = ntohl(where_to->in4.sin_addr.s_addr);
#line 731
      port = ntohs(where_to->in4.sin_port);
      }
#line 732
      goto switch_break___0;
      case_10___0: /* CIL Label */ 
      {
#line 735
      ip.family = (uint16_t )2;
#line 736
      memcpy((void */* __restrict  */)(ip.addr.in6), (void const   */* __restrict  */)(where_to->in6.sin6_addr.__in6_u.__u6_addr8),
             sizeof(ip.addr.in6));
#line 737
      port = ntohs(where_to->in6.sin6_port);
      }
#line 738
      goto switch_break___0;
      switch_default___0: /* CIL Label */ 
      {
#line 741
      __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c",
                    741U, "transmit_reply");
      }
      switch_break___0: /* CIL Label */ ;
      }
      {
#line 744
      LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c",
                   744, "transmit_reply");
#line 744
      tmp___1 = UTI_IPToString(& ip);
#line 744
      LOG_Line_Function((LOG_Severity )1, (LOG_Facility )12, "Could not send response to %s:%hu",
                        tmp___1, (int )port);
      }
    }
  }
#line 746
  return;
}
}
#line 751 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
static void handle_null(CMD_Request *rx_message , CMD_Reply *tx_message ) 
{ 


  {
  {
#line 754
  tx_message->status = htons((uint16_t )0);
  }
#line 755
  return;
}
}
#line 759 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
static void handle_online(CMD_Request *rx_message , CMD_Reply *tx_message ) 
{ 
  int status___0 ;
  IPAddr address ;
  IPAddr mask ;

  {
  {
#line 764
  UTI_IPNetworkToHost(& rx_message->data.online.mask, & mask);
#line 765
  UTI_IPNetworkToHost(& rx_message->data.online.address, & address);
#line 766
  status___0 = NSR_TakeSourcesOnline(& mask, & address);
  }
#line 767
  if (status___0) {
    {
#line 768
    tx_message->status = htons((uint16_t )0);
    }
  } else {
    {
#line 770
    tx_message->status = htons((uint16_t )4);
    }
  }
#line 772
  return;
}
}
#line 776 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
static void handle_offline(CMD_Request *rx_message , CMD_Reply *tx_message ) 
{ 
  int status___0 ;
  IPAddr address ;
  IPAddr mask ;

  {
  {
#line 781
  UTI_IPNetworkToHost(& rx_message->data.offline.mask, & mask);
#line 782
  UTI_IPNetworkToHost(& rx_message->data.offline.address, & address);
#line 783
  status___0 = NSR_TakeSourcesOffline(& mask, & address);
  }
#line 784
  if (status___0) {
    {
#line 785
    tx_message->status = htons((uint16_t )0);
    }
  } else {
    {
#line 787
    tx_message->status = htons((uint16_t )4);
    }
  }
#line 789
  return;
}
}
#line 793 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
static void handle_burst(CMD_Request *rx_message , CMD_Reply *tx_message ) 
{ 
  int status___0 ;
  IPAddr address ;
  IPAddr mask ;
  uint32_t tmp ;
  uint32_t tmp___0 ;

  {
  {
#line 798
  UTI_IPNetworkToHost(& rx_message->data.burst.mask, & mask);
#line 799
  UTI_IPNetworkToHost(& rx_message->data.burst.address, & address);
#line 800
  tmp = ntohl((uint32_t )rx_message->data.burst.n_total_samples);
#line 800
  tmp___0 = ntohl((uint32_t )rx_message->data.burst.n_good_samples);
#line 800
  status___0 = NSR_InitiateSampleBurst((int )tmp___0, (int )tmp, & mask, & address);
  }
#line 804
  if (status___0) {
    {
#line 805
    tx_message->status = htons((uint16_t )0);
    }
  } else {
    {
#line 807
    tx_message->status = htons((uint16_t )4);
    }
  }
#line 809
  return;
}
}
#line 813 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
static void handle_modify_minpoll(CMD_Request *rx_message , CMD_Reply *tx_message ) 
{ 
  int status___0 ;
  IPAddr address ;
  uint32_t tmp ;

  {
  {
#line 818
  UTI_IPNetworkToHost(& rx_message->data.modify_minpoll.address, & address);
#line 819
  tmp = ntohl((uint32_t )rx_message->data.modify_minpoll.new_minpoll);
#line 819
  status___0 = NSR_ModifyMinpoll(& address, (int )tmp);
  }
#line 822
  if (status___0) {
    {
#line 823
    tx_message->status = htons((uint16_t )0);
    }
  } else {
    {
#line 825
    tx_message->status = htons((uint16_t )4);
    }
  }
#line 827
  return;
}
}
#line 831 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
static void handle_modify_maxpoll(CMD_Request *rx_message , CMD_Reply *tx_message ) 
{ 
  int status___0 ;
  IPAddr address ;
  uint32_t tmp ;

  {
  {
#line 836
  UTI_IPNetworkToHost(& rx_message->data.modify_minpoll.address, & address);
#line 837
  tmp = ntohl((uint32_t )rx_message->data.modify_minpoll.new_minpoll);
#line 837
  status___0 = NSR_ModifyMaxpoll(& address, (int )tmp);
  }
#line 840
  if (status___0) {
    {
#line 841
    tx_message->status = htons((uint16_t )0);
    }
  } else {
    {
#line 843
    tx_message->status = htons((uint16_t )4);
    }
  }
#line 845
  return;
}
}
#line 849 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
static void handle_modify_maxdelay(CMD_Request *rx_message , CMD_Reply *tx_message ) 
{ 
  int status___0 ;
  IPAddr address ;
  double tmp ;

  {
  {
#line 854
  UTI_IPNetworkToHost(& rx_message->data.modify_maxdelay.address, & address);
#line 855
  tmp = UTI_FloatNetworkToHost(rx_message->data.modify_maxdelay.new_max_delay);
#line 855
  status___0 = NSR_ModifyMaxdelay(& address, tmp);
  }
#line 857
  if (status___0) {
    {
#line 858
    tx_message->status = htons((uint16_t )0);
    }
  } else {
    {
#line 860
    tx_message->status = htons((uint16_t )4);
    }
  }
#line 862
  return;
}
}
#line 866 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
static void handle_modify_maxdelayratio(CMD_Request *rx_message , CMD_Reply *tx_message ) 
{ 
  int status___0 ;
  IPAddr address ;
  double tmp ;

  {
  {
#line 871
  UTI_IPNetworkToHost(& rx_message->data.modify_maxdelayratio.address, & address);
#line 872
  tmp = UTI_FloatNetworkToHost(rx_message->data.modify_maxdelayratio.new_max_delay_ratio);
#line 872
  status___0 = NSR_ModifyMaxdelayratio(& address, tmp);
  }
#line 874
  if (status___0) {
    {
#line 875
    tx_message->status = htons((uint16_t )0);
    }
  } else {
    {
#line 877
    tx_message->status = htons((uint16_t )4);
    }
  }
#line 879
  return;
}
}
#line 883 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
static void handle_modify_maxdelaydevratio(CMD_Request *rx_message , CMD_Reply *tx_message ) 
{ 
  int status___0 ;
  IPAddr address ;
  double tmp ;

  {
  {
#line 888
  UTI_IPNetworkToHost(& rx_message->data.modify_maxdelaydevratio.address, & address);
#line 889
  tmp = UTI_FloatNetworkToHost(rx_message->data.modify_maxdelaydevratio.new_max_delay_dev_ratio);
#line 889
  status___0 = NSR_ModifyMaxdelaydevratio(& address, tmp);
  }
#line 891
  if (status___0) {
    {
#line 892
    tx_message->status = htons((uint16_t )0);
    }
  } else {
    {
#line 894
    tx_message->status = htons((uint16_t )4);
    }
  }
#line 896
  return;
}
}
#line 900 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
static void handle_modify_minstratum(CMD_Request *rx_message , CMD_Reply *tx_message ) 
{ 
  int status___0 ;
  IPAddr address ;
  uint32_t tmp ;

  {
  {
#line 905
  UTI_IPNetworkToHost(& rx_message->data.modify_minpoll.address, & address);
#line 906
  tmp = ntohl((uint32_t )rx_message->data.modify_minstratum.new_min_stratum);
#line 906
  status___0 = NSR_ModifyMinstratum(& address, (int )tmp);
  }
#line 909
  if (status___0) {
    {
#line 910
    tx_message->status = htons((uint16_t )0);
    }
  } else {
    {
#line 912
    tx_message->status = htons((uint16_t )4);
    }
  }
#line 914
  return;
}
}
#line 918 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
static void handle_modify_polltarget(CMD_Request *rx_message , CMD_Reply *tx_message ) 
{ 
  int status___0 ;
  IPAddr address ;
  uint32_t tmp ;

  {
  {
#line 923
  UTI_IPNetworkToHost(& rx_message->data.modify_polltarget.address, & address);
#line 924
  tmp = ntohl((uint32_t )rx_message->data.modify_polltarget.new_poll_target);
#line 924
  status___0 = NSR_ModifyPolltarget(& address, (int )tmp);
  }
#line 927
  if (status___0) {
    {
#line 928
    tx_message->status = htons((uint16_t )0);
    }
  } else {
    {
#line 930
    tx_message->status = htons((uint16_t )4);
    }
  }
#line 932
  return;
}
}
#line 936 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
static void handle_modify_maxupdateskew(CMD_Request *rx_message , CMD_Reply *tx_message ) 
{ 
  double tmp ;

  {
  {
#line 939
  tmp = UTI_FloatNetworkToHost(rx_message->data.modify_maxupdateskew.new_max_update_skew);
#line 939
  REF_ModifyMaxupdateskew(tmp);
#line 940
  tx_message->status = htons((uint16_t )0);
  }
#line 941
  return;
}
}
#line 945 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
static void handle_settime(CMD_Request *rx_message , CMD_Reply *tx_message ) 
{ 
  struct timeval ts ;
  long offset_cs ;
  double dfreq_ppm ;
  double new_afreq_ppm ;
  int tmp ;

  {
  {
#line 951
  UTI_TimevalNetworkToHost(& rx_message->data.settime.ts, & ts);
#line 952
  tmp = MNL_AcceptTimestamp(& ts, & offset_cs, & dfreq_ppm, & new_afreq_ppm);
  }
#line 952
  if (tmp) {
    {
#line 953
    tx_message->status = htons((uint16_t )0);
#line 954
    tx_message->reply = htons((uint16_t )4);
#line 955
    tx_message->data.manual_timestamp.centiseconds = htonl((uint32_t )((int32_t )offset_cs));
#line 956
    tx_message->data.manual_timestamp.dfreq_ppm = UTI_FloatHostToNetwork(dfreq_ppm);
#line 957
    tx_message->data.manual_timestamp.new_afreq_ppm = UTI_FloatHostToNetwork(new_afreq_ppm);
    }
  } else {
    {
#line 959
    tx_message->status = htons((uint16_t )6);
    }
  }
#line 961
  return;
}
}
#line 965 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
static void handle_local(CMD_Request *rx_message , CMD_Reply *tx_message ) 
{ 
  int on_off ;
  int stratum ;
  uint32_t tmp ;
  uint32_t tmp___0 ;

  {
  {
#line 969
  tmp = ntohl((uint32_t )rx_message->data.local.on_off);
#line 969
  on_off = (int )tmp;
  }
#line 970
  if (on_off) {
    {
#line 971
    tmp___0 = ntohl((uint32_t )rx_message->data.local.stratum);
#line 971
    stratum = (int )tmp___0;
#line 972
    REF_EnableLocal(stratum);
    }
  } else {
    {
#line 974
    REF_DisableLocal();
    }
  }
  {
#line 976
  tx_message->status = htons((uint16_t )0);
  }
#line 977
  return;
}
}
#line 981 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
static void handle_manual(CMD_Request *rx_message , CMD_Reply *tx_message ) 
{ 
  int option ;
  uint32_t tmp ;

  {
  {
#line 985
  tmp = ntohl((uint32_t )rx_message->data.manual.option);
#line 985
  option = (int )tmp;
  }
  {
#line 987
  if (option == 0) {
#line 987
    goto case_0;
  }
#line 990
  if (option == 1) {
#line 990
    goto case_1;
  }
#line 993
  if (option == 2) {
#line 993
    goto case_2;
  }
#line 986
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 988
  MNL_Disable();
  }
#line 989
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 991
  MNL_Enable();
  }
#line 992
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 994
  MNL_Reset();
  }
#line 995
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 997
  tx_message->status = htons((uint16_t )0);
  }
#line 998
  return;
}
}
#line 1002 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
static void handle_n_sources(CMD_Request *rx_message , CMD_Reply *tx_message ) 
{ 
  int n_sources___3 ;

  {
  {
#line 1006
  n_sources___3 = SRC_ReadNumberOfSources();
#line 1007
  tx_message->status = htons((uint16_t )0);
#line 1008
  tx_message->reply = htons((uint16_t )2);
#line 1009
  tx_message->data.n_sources.n_sources = htonl((uint32_t )n_sources___3);
  }
#line 1010
  return;
}
}
#line 1014 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
static void handle_source_data(CMD_Request *rx_message , CMD_Reply *tx_message ) 
{ 
  RPT_SourceReport report ;
  struct timeval now_corr ;
  uint32_t tmp ;
  SRC_Type tmp___0 ;
  uint32_t tmp___1 ;
  int tmp___2 ;

  {
  {
#line 1021
  LCL_ReadCookedTime(& now_corr, (double *)((void *)0));
#line 1022
  tmp___1 = ntohl((uint32_t )rx_message->data.source_data.index);
#line 1022
  tmp___2 = SRC_ReportSource((int )tmp___1, & report, & now_corr);
  }
#line 1022
  if (tmp___2) {
    {
#line 1023
    tmp = ntohl((uint32_t )rx_message->data.source_data.index);
#line 1023
    tmp___0 = SRC_GetType((int )tmp);
    }
    {
#line 1024
    if ((unsigned int )tmp___0 == 0U) {
#line 1024
      goto case_0;
    }
#line 1027
    if ((unsigned int )tmp___0 == 1U) {
#line 1027
      goto case_1;
    }
#line 1023
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 1025
    NSR_ReportSource(& report, & now_corr);
    }
#line 1026
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 1028
    RCL_ReportSource(& report, & now_corr);
    }
#line 1029
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 1032
    tx_message->status = htons((uint16_t )0);
#line 1033
    tx_message->reply = htons((uint16_t )3);
#line 1035
    UTI_IPHostToNetwork(& report.ip_addr, & tx_message->data.source_data.ip_addr);
#line 1036
    tx_message->data.source_data.stratum = htons((uint16_t )report.stratum);
#line 1037
    tx_message->data.source_data.poll = htons((uint16_t )report.poll);
    }
    {
#line 1039
    if ((unsigned int )report.state == 0U) {
#line 1039
      goto case_0___0;
    }
#line 1042
    if ((unsigned int )report.state == 1U) {
#line 1042
      goto case_1___0;
    }
#line 1045
    if ((unsigned int )report.state == 2U) {
#line 1045
      goto case_2;
    }
#line 1048
    if ((unsigned int )report.state == 3U) {
#line 1048
      goto case_3;
    }
#line 1051
    if ((unsigned int )report.state == 4U) {
#line 1051
      goto case_4;
    }
#line 1054
    if ((unsigned int )report.state == 5U) {
#line 1054
      goto case_5;
    }
#line 1038
    goto switch_break___0;
    case_0___0: /* CIL Label */ 
    {
#line 1040
    tx_message->data.source_data.state = htons((uint16_t )0);
    }
#line 1041
    goto switch_break___0;
    case_1___0: /* CIL Label */ 
    {
#line 1043
    tx_message->data.source_data.state = htons((uint16_t )1);
    }
#line 1044
    goto switch_break___0;
    case_2: /* CIL Label */ 
    {
#line 1046
    tx_message->data.source_data.state = htons((uint16_t )2);
    }
#line 1047
    goto switch_break___0;
    case_3: /* CIL Label */ 
    {
#line 1049
    tx_message->data.source_data.state = htons((uint16_t )3);
    }
#line 1050
    goto switch_break___0;
    case_4: /* CIL Label */ 
    {
#line 1052
    tx_message->data.source_data.state = htons((uint16_t )4);
    }
#line 1053
    goto switch_break___0;
    case_5: /* CIL Label */ 
    {
#line 1055
    tx_message->data.source_data.state = htons((uint16_t )5);
    }
#line 1056
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
    {
#line 1059
    if ((unsigned int )report.mode == 0U) {
#line 1059
      goto case_0___1;
    }
#line 1062
    if ((unsigned int )report.mode == 1U) {
#line 1062
      goto case_1___1;
    }
#line 1065
    if ((unsigned int )report.mode == 2U) {
#line 1065
      goto case_2___0;
    }
#line 1058
    goto switch_break___1;
    case_0___1: /* CIL Label */ 
    {
#line 1060
    tx_message->data.source_data.mode = htons((uint16_t )0);
    }
#line 1061
    goto switch_break___1;
    case_1___1: /* CIL Label */ 
    {
#line 1063
    tx_message->data.source_data.mode = htons((uint16_t )1);
    }
#line 1064
    goto switch_break___1;
    case_2___0: /* CIL Label */ 
    {
#line 1066
    tx_message->data.source_data.mode = htons((uint16_t )2);
    }
#line 1067
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
    {
#line 1070
    if ((unsigned int )report.sel_option == 0U) {
#line 1070
      goto case_0___2;
    }
#line 1073
    if ((unsigned int )report.sel_option == 1U) {
#line 1073
      goto case_1___2;
    }
#line 1076
    if ((unsigned int )report.sel_option == 2U) {
#line 1076
      goto case_2___1;
    }
#line 1069
    goto switch_break___2;
    case_0___2: /* CIL Label */ 
    {
#line 1071
    tx_message->data.source_data.flags = htons((uint16_t )0);
    }
#line 1072
    goto switch_break___2;
    case_1___2: /* CIL Label */ 
    {
#line 1074
    tx_message->data.source_data.flags = htons((uint16_t )2);
    }
#line 1075
    goto switch_break___2;
    case_2___1: /* CIL Label */ 
    {
#line 1077
    tx_message->data.source_data.flags = htons((uint16_t )2);
    }
#line 1078
    goto switch_break___2;
    switch_break___2: /* CIL Label */ ;
    }
    {
#line 1080
    tx_message->data.source_data.reachability = htons((uint16_t )report.reachability);
#line 1081
    tx_message->data.source_data.since_sample = htonl((uint32_t )report.latest_meas_ago);
#line 1082
    tx_message->data.source_data.orig_latest_meas = UTI_FloatHostToNetwork(report.orig_latest_meas);
#line 1083
    tx_message->data.source_data.latest_meas = UTI_FloatHostToNetwork(report.latest_meas);
#line 1084
    tx_message->data.source_data.latest_meas_err = UTI_FloatHostToNetwork(report.latest_meas_err);
    }
  } else {
    {
#line 1086
    tx_message->status = htons((uint16_t )4);
    }
  }
#line 1088
  return;
}
}
#line 1092 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
static void handle_rekey(CMD_Request *rx_message , CMD_Reply *tx_message ) 
{ 


  {
  {
#line 1095
  tx_message->status = htons((uint16_t )0);
#line 1096
  KEY_Reload();
  }
#line 1097
  return;
}
}
#line 1101 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
static void handle_allow(CMD_Request *rx_message , CMD_Reply *tx_message ) 
{ 
  IPAddr ip ;
  int subnet_bits ;
  uint32_t tmp ;
  int tmp___0 ;

  {
  {
#line 1106
  UTI_IPNetworkToHost(& rx_message->data.allow_deny.ip, & ip);
#line 1107
  tmp = ntohl((uint32_t )rx_message->data.allow_deny.subnet_bits);
#line 1107
  subnet_bits = (int )tmp;
#line 1108
  tmp___0 = NCR_AddAccessRestriction(& ip, subnet_bits, 1, 0);
  }
#line 1108
  if (tmp___0) {
    {
#line 1109
    tx_message->status = htons((uint16_t )0);
    }
  } else {
    {
#line 1111
    tx_message->status = htons((uint16_t )7);
    }
  }
#line 1113
  return;
}
}
#line 1117 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
static void handle_allowall(CMD_Request *rx_message , CMD_Reply *tx_message ) 
{ 
  IPAddr ip ;
  int subnet_bits ;
  uint32_t tmp ;
  int tmp___0 ;

  {
  {
#line 1122
  UTI_IPNetworkToHost(& rx_message->data.allow_deny.ip, & ip);
#line 1123
  tmp = ntohl((uint32_t )rx_message->data.allow_deny.subnet_bits);
#line 1123
  subnet_bits = (int )tmp;
#line 1124
  tmp___0 = NCR_AddAccessRestriction(& ip, subnet_bits, 1, 1);
  }
#line 1124
  if (tmp___0) {
    {
#line 1125
    tx_message->status = htons((uint16_t )0);
    }
  } else {
    {
#line 1127
    tx_message->status = htons((uint16_t )7);
    }
  }
#line 1129
  return;
}
}
#line 1133 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
static void handle_deny(CMD_Request *rx_message , CMD_Reply *tx_message ) 
{ 
  IPAddr ip ;
  int subnet_bits ;
  uint32_t tmp ;
  int tmp___0 ;

  {
  {
#line 1138
  UTI_IPNetworkToHost(& rx_message->data.allow_deny.ip, & ip);
#line 1139
  tmp = ntohl((uint32_t )rx_message->data.allow_deny.subnet_bits);
#line 1139
  subnet_bits = (int )tmp;
#line 1140
  tmp___0 = NCR_AddAccessRestriction(& ip, subnet_bits, 0, 0);
  }
#line 1140
  if (tmp___0) {
    {
#line 1141
    tx_message->status = htons((uint16_t )0);
    }
  } else {
    {
#line 1143
    tx_message->status = htons((uint16_t )7);
    }
  }
#line 1145
  return;
}
}
#line 1149 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
static void handle_denyall(CMD_Request *rx_message , CMD_Reply *tx_message ) 
{ 
  IPAddr ip ;
  int subnet_bits ;
  uint32_t tmp ;
  int tmp___0 ;

  {
  {
#line 1154
  UTI_IPNetworkToHost(& rx_message->data.allow_deny.ip, & ip);
#line 1155
  tmp = ntohl((uint32_t )rx_message->data.allow_deny.subnet_bits);
#line 1155
  subnet_bits = (int )tmp;
#line 1156
  tmp___0 = NCR_AddAccessRestriction(& ip, subnet_bits, 0, 1);
  }
#line 1156
  if (tmp___0) {
    {
#line 1157
    tx_message->status = htons((uint16_t )0);
    }
  } else {
    {
#line 1159
    tx_message->status = htons((uint16_t )7);
    }
  }
#line 1161
  return;
}
}
#line 1165 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
static void handle_cmdallow(CMD_Request *rx_message , CMD_Reply *tx_message ) 
{ 
  IPAddr ip ;
  int subnet_bits ;
  uint32_t tmp ;
  int tmp___0 ;

  {
  {
#line 1170
  UTI_IPNetworkToHost(& rx_message->data.allow_deny.ip, & ip);
#line 1171
  tmp = ntohl((uint32_t )rx_message->data.allow_deny.subnet_bits);
#line 1171
  subnet_bits = (int )tmp;
#line 1172
  tmp___0 = CAM_AddAccessRestriction(& ip, subnet_bits, 1, 0);
  }
#line 1172
  if (tmp___0) {
    {
#line 1173
    tx_message->status = htons((uint16_t )0);
    }
  } else {
    {
#line 1175
    tx_message->status = htons((uint16_t )7);
    }
  }
#line 1177
  return;
}
}
#line 1181 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
static void handle_cmdallowall(CMD_Request *rx_message , CMD_Reply *tx_message ) 
{ 
  IPAddr ip ;
  int subnet_bits ;
  uint32_t tmp ;
  int tmp___0 ;

  {
  {
#line 1186
  UTI_IPNetworkToHost(& rx_message->data.allow_deny.ip, & ip);
#line 1187
  tmp = ntohl((uint32_t )rx_message->data.allow_deny.subnet_bits);
#line 1187
  subnet_bits = (int )tmp;
#line 1188
  tmp___0 = CAM_AddAccessRestriction(& ip, subnet_bits, 1, 1);
  }
#line 1188
  if (tmp___0) {
    {
#line 1189
    tx_message->status = htons((uint16_t )0);
    }
  } else {
    {
#line 1191
    tx_message->status = htons((uint16_t )7);
    }
  }
#line 1193
  return;
}
}
#line 1197 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
static void handle_cmddeny(CMD_Request *rx_message , CMD_Reply *tx_message ) 
{ 
  IPAddr ip ;
  int subnet_bits ;
  uint32_t tmp ;
  int tmp___0 ;

  {
  {
#line 1202
  UTI_IPNetworkToHost(& rx_message->data.allow_deny.ip, & ip);
#line 1203
  tmp = ntohl((uint32_t )rx_message->data.allow_deny.subnet_bits);
#line 1203
  subnet_bits = (int )tmp;
#line 1204
  tmp___0 = CAM_AddAccessRestriction(& ip, subnet_bits, 0, 0);
  }
#line 1204
  if (tmp___0) {
    {
#line 1205
    tx_message->status = htons((uint16_t )0);
    }
  } else {
    {
#line 1207
    tx_message->status = htons((uint16_t )7);
    }
  }
#line 1209
  return;
}
}
#line 1213 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
static void handle_cmddenyall(CMD_Request *rx_message , CMD_Reply *tx_message ) 
{ 
  IPAddr ip ;
  int subnet_bits ;
  uint32_t tmp ;
  int tmp___0 ;

  {
  {
#line 1218
  UTI_IPNetworkToHost(& rx_message->data.allow_deny.ip, & ip);
#line 1219
  tmp = ntohl((uint32_t )rx_message->data.allow_deny.subnet_bits);
#line 1219
  subnet_bits = (int )tmp;
#line 1220
  tmp___0 = CAM_AddAccessRestriction(& ip, subnet_bits, 0, 1);
  }
#line 1220
  if (tmp___0) {
    {
#line 1221
    tx_message->status = htons((uint16_t )0);
    }
  } else {
    {
#line 1223
    tx_message->status = htons((uint16_t )7);
    }
  }
#line 1225
  return;
}
}
#line 1229 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
static void handle_accheck(CMD_Request *rx_message , CMD_Reply *tx_message ) 
{ 
  IPAddr ip ;
  int tmp ;

  {
  {
#line 1233
  UTI_IPNetworkToHost(& rx_message->data.ac_check.ip, & ip);
#line 1234
  tmp = NCR_CheckAccessRestriction(& ip);
  }
#line 1234
  if (tmp) {
    {
#line 1235
    tx_message->status = htons((uint16_t )8);
    }
  } else {
    {
#line 1237
    tx_message->status = htons((uint16_t )9);
    }
  }
#line 1239
  return;
}
}
#line 1243 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
static void handle_cmdaccheck(CMD_Request *rx_message , CMD_Reply *tx_message ) 
{ 
  IPAddr ip ;
  int tmp ;

  {
  {
#line 1247
  UTI_IPNetworkToHost(& rx_message->data.ac_check.ip, & ip);
#line 1248
  tmp = CAM_CheckAccessRestriction(& ip);
  }
#line 1248
  if (tmp) {
    {
#line 1249
    tx_message->status = htons((uint16_t )8);
    }
  } else {
    {
#line 1251
    tx_message->status = htons((uint16_t )9);
    }
  }
#line 1253
  return;
}
}
#line 1257 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
static void handle_add_source(NTP_Source_Type type , CMD_Request *rx_message , CMD_Reply *tx_message ) 
{ 
  NTP_Remote_Address rem_addr ;
  SourceParameters params ;
  NSR_Status status___0 ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  uint32_t tmp___3 ;
  uint32_t tmp___5 ;
  uint32_t tmp___7 ;
  uint32_t tmp___9 ;
  int tmp___12 ;
  uint32_t tmp___13 ;
  uint32_t tmp___14 ;

  {
  {
#line 1264
  UTI_IPNetworkToHost(& rx_message->data.ntp_source.ip_addr, & rem_addr.ip_addr);
#line 1265
  rem_addr.local_ip_addr.family = (uint16_t )0;
#line 1266
  tmp = ntohl(rx_message->data.ntp_source.port);
#line 1266
  rem_addr.port = (unsigned short )tmp;
#line 1267
  tmp___0 = ntohl((uint32_t )rx_message->data.ntp_source.minpoll);
#line 1267
  params.minpoll = (int )tmp___0;
#line 1268
  tmp___1 = ntohl((uint32_t )rx_message->data.ntp_source.maxpoll);
#line 1268
  params.maxpoll = (int )tmp___1;
#line 1269
  tmp___2 = ntohl((uint32_t )rx_message->data.ntp_source.presend_minpoll);
#line 1269
  params.presend_minpoll = (int )tmp___2;
#line 1270
  tmp___3 = ntohl(rx_message->data.ntp_source.authkey);
#line 1270
  params.authkey = (unsigned long )tmp___3;
#line 1271
  tmp___5 = ntohl(rx_message->data.ntp_source.flags);
  }
#line 1271
  if (tmp___5 & 1U) {
#line 1271
    params.online = 1;
  } else {
#line 1271
    params.online = 0;
  }
  {
#line 1272
  tmp___7 = ntohl(rx_message->data.ntp_source.flags);
  }
#line 1272
  if (tmp___7 & 2U) {
#line 1272
    params.auto_offline = 1;
  } else {
#line 1272
    params.auto_offline = 0;
  }
  {
#line 1273
  tmp___9 = ntohl(rx_message->data.ntp_source.flags);
  }
#line 1273
  if (tmp___9 & 4U) {
#line 1273
    params.iburst = 1;
  } else {
#line 1273
    params.iburst = 0;
  }
  {
#line 1274
  tmp___14 = ntohl(rx_message->data.ntp_source.flags);
  }
#line 1274
  if (tmp___14 & 8U) {
#line 1274
    params.sel_option = (SRC_SelectOption )2;
  } else {
    {
#line 1274
    tmp___13 = ntohl(rx_message->data.ntp_source.flags);
    }
#line 1274
    if (tmp___13 & 16U) {
#line 1274
      tmp___12 = 1;
    } else {
#line 1274
      tmp___12 = 0;
    }
#line 1274
    params.sel_option = (SRC_SelectOption )tmp___12;
  }
  {
#line 1276
  params.max_delay = UTI_FloatNetworkToHost(rx_message->data.ntp_source.max_delay);
#line 1277
  params.max_delay_ratio = UTI_FloatNetworkToHost(rx_message->data.ntp_source.max_delay_ratio);
#line 1280
  params.min_stratum = 0;
#line 1281
  params.poll_target = 6;
#line 1282
  params.max_delay_dev_ratio = 10.0;
#line 1284
  status___0 = NSR_AddSource(& rem_addr, type, & params);
  }
  {
#line 1286
  if ((unsigned int )status___0 == 0U) {
#line 1286
    goto case_0;
  }
#line 1289
  if ((unsigned int )status___0 == 2U) {
#line 1289
    goto case_2;
  }
#line 1292
  if ((unsigned int )status___0 == 3U) {
#line 1292
    goto case_3;
  }
#line 1295
  if ((unsigned int )status___0 == 4U) {
#line 1295
    goto case_4;
  }
#line 1298
  if ((unsigned int )status___0 == 1U) {
#line 1298
    goto case_1;
  }
#line 1285
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 1287
  tx_message->status = htons((uint16_t )0);
  }
#line 1288
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1290
  tx_message->status = htons((uint16_t )11);
  }
#line 1291
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 1293
  tx_message->status = htons((uint16_t )12);
  }
#line 1294
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 1296
  tx_message->status = htons((uint16_t )17);
  }
#line 1297
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1299
  __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c",
                1299U, "handle_add_source");
  }
#line 1300
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1302
  return;
}
}
#line 1306 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
static void handle_del_source(CMD_Request *rx_message , CMD_Reply *tx_message ) 
{ 
  NTP_Remote_Address rem_addr ;
  NSR_Status status___0 ;

  {
  {
#line 1312
  UTI_IPNetworkToHost(& rx_message->data.del_source.ip_addr, & rem_addr.ip_addr);
#line 1313
  rem_addr.local_ip_addr.family = (uint16_t )0;
#line 1314
  rem_addr.port = (unsigned short)0;
#line 1316
  status___0 = NSR_RemoveSource(& rem_addr);
  }
  {
#line 1318
  if ((unsigned int )status___0 == 0U) {
#line 1318
    goto case_0;
  }
#line 1321
  if ((unsigned int )status___0 == 1U) {
#line 1321
    goto case_1;
  }
#line 1326
  if ((unsigned int )status___0 == 4U) {
#line 1326
    goto case_4;
  }
#line 1326
  if ((unsigned int )status___0 == 2U) {
#line 1326
    goto case_4;
  }
#line 1326
  if ((unsigned int )status___0 == 3U) {
#line 1326
    goto case_4;
  }
#line 1317
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 1319
  tx_message->status = htons((uint16_t )0);
  }
#line 1320
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1322
  tx_message->status = htons((uint16_t )4);
  }
#line 1323
  goto switch_break;
  case_4: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 1327
  __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c",
                1327U, "handle_del_source");
  }
#line 1328
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1330
  return;
}
}
#line 1334 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
static void handle_writertc(CMD_Request *rx_message , CMD_Reply *tx_message ) 
{ 
  int tmp ;

  {
  {
#line 1337
  tmp = RTC_WriteParameters();
  }
  {
#line 1338
  if (tmp == 0) {
#line 1338
    goto case_0;
  }
#line 1341
  if (tmp == 1) {
#line 1341
    goto case_1;
  }
#line 1344
  if (tmp == 2) {
#line 1344
    goto case_2;
  }
#line 1337
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 1339
  tx_message->status = htons((uint16_t )0);
  }
#line 1340
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1342
  tx_message->status = htons((uint16_t )13);
  }
#line 1343
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1345
  tx_message->status = htons((uint16_t )14);
  }
#line 1346
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1348
  return;
}
}
#line 1352 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
static void handle_dfreq(CMD_Request *rx_message , CMD_Reply *tx_message ) 
{ 
  double dfreq ;

  {
  {
#line 1356
  dfreq = UTI_FloatNetworkToHost(rx_message->data.dfreq.dfreq);
#line 1357
  LCL_AccumulateDeltaFrequency(dfreq * 1.0e-6);
#line 1358
  LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c", 1358,
               "handle_dfreq");
#line 1358
  LOG_Line_Function((LOG_Severity )0, (LOG_Facility )12, "Accumulated delta freq of %.3fppm",
                    dfreq);
#line 1359
  tx_message->status = htons((uint16_t )0);
  }
#line 1360
  return;
}
}
#line 1364 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
static void handle_doffset(CMD_Request *rx_message , CMD_Reply *tx_message ) 
{ 
  long sec ;
  long usec ;
  double doffset ;
  uint32_t tmp ;
  uint32_t tmp___0 ;

  {
  {
#line 1369
  tmp = ntohl((uint32_t )rx_message->data.doffset.sec);
#line 1369
  sec = (long )tmp;
#line 1370
  tmp___0 = ntohl((uint32_t )rx_message->data.doffset.usec);
#line 1370
  usec = (long )tmp___0;
#line 1371
  doffset = (double )sec + 1.0e-6 * (double )usec;
#line 1372
  LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c", 1372,
               "handle_doffset");
#line 1372
  LOG_Line_Function((LOG_Severity )0, (LOG_Facility )12, "Accumulated delta offset of %.6f seconds",
                    doffset);
#line 1373
  LCL_AccumulateOffset(doffset, 0.0);
#line 1374
  tx_message->status = htons((uint16_t )0);
  }
#line 1375
  return;
}
}
#line 1379 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
static void handle_tracking(CMD_Request *rx_message , CMD_Reply *tx_message ) 
{ 
  RPT_TrackingReport rpt ;

  {
  {
#line 1384
  REF_GetTrackingReport(& rpt);
#line 1385
  tx_message->status = htons((uint16_t )0);
#line 1386
  tx_message->reply = htons((uint16_t )5);
#line 1387
  tx_message->data.tracking.ref_id = htonl(rpt.ref_id);
#line 1388
  UTI_IPHostToNetwork(& rpt.ip_addr, & tx_message->data.tracking.ip_addr);
#line 1389
  tx_message->data.tracking.stratum = htons((uint16_t )rpt.stratum);
#line 1390
  tx_message->data.tracking.leap_status = htons((uint16_t )rpt.leap_status);
#line 1391
  UTI_TimevalHostToNetwork(& rpt.ref_time, & tx_message->data.tracking.ref_time);
#line 1392
  tx_message->data.tracking.current_correction = UTI_FloatHostToNetwork(rpt.current_correction);
#line 1393
  tx_message->data.tracking.last_offset = UTI_FloatHostToNetwork(rpt.last_offset);
#line 1394
  tx_message->data.tracking.rms_offset = UTI_FloatHostToNetwork(rpt.rms_offset);
#line 1395
  tx_message->data.tracking.freq_ppm = UTI_FloatHostToNetwork(rpt.freq_ppm);
#line 1396
  tx_message->data.tracking.resid_freq_ppm = UTI_FloatHostToNetwork(rpt.resid_freq_ppm);
#line 1397
  tx_message->data.tracking.skew_ppm = UTI_FloatHostToNetwork(rpt.skew_ppm);
#line 1398
  tx_message->data.tracking.root_delay = UTI_FloatHostToNetwork(rpt.root_delay);
#line 1399
  tx_message->data.tracking.root_dispersion = UTI_FloatHostToNetwork(rpt.root_dispersion);
#line 1400
  tx_message->data.tracking.last_update_interval = UTI_FloatHostToNetwork(rpt.last_update_interval);
  }
#line 1401
  return;
}
}
#line 1405 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
static void handle_sourcestats(CMD_Request *rx_message , CMD_Reply *tx_message ) 
{ 
  int status___0 ;
  RPT_SourcestatsReport report ;
  struct timeval now_corr ;
  uint32_t tmp ;

  {
  {
#line 1412
  LCL_ReadCookedTime(& now_corr, (double *)((void *)0));
#line 1413
  tmp = ntohl(rx_message->data.sourcestats.index);
#line 1413
  status___0 = SRC_ReportSourcestats((int )tmp, & report, & now_corr);
  }
#line 1416
  if (status___0) {
    {
#line 1417
    tx_message->status = htons((uint16_t )0);
#line 1418
    tx_message->reply = htons((uint16_t )6);
#line 1419
    tx_message->data.sourcestats.ref_id = htonl(report.ref_id);
#line 1420
    UTI_IPHostToNetwork(& report.ip_addr, & tx_message->data.sourcestats.ip_addr);
#line 1421
    tx_message->data.sourcestats.n_samples = htonl((uint32_t )report.n_samples);
#line 1422
    tx_message->data.sourcestats.n_runs = htonl((uint32_t )report.n_runs);
#line 1423
    tx_message->data.sourcestats.span_seconds = htonl((uint32_t )report.span_seconds);
#line 1424
    tx_message->data.sourcestats.resid_freq_ppm = UTI_FloatHostToNetwork(report.resid_freq_ppm);
#line 1425
    tx_message->data.sourcestats.skew_ppm = UTI_FloatHostToNetwork(report.skew_ppm);
#line 1426
    tx_message->data.sourcestats.sd = UTI_FloatHostToNetwork(report.sd);
#line 1427
    tx_message->data.sourcestats.est_offset = UTI_FloatHostToNetwork(report.est_offset);
#line 1428
    tx_message->data.sourcestats.est_offset_err = UTI_FloatHostToNetwork(report.est_offset_err);
    }
  } else {
    {
#line 1430
    tx_message->status = htons((uint16_t )4);
    }
  }
#line 1432
  return;
}
}
#line 1436 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
static void handle_rtcreport(CMD_Request *rx_message , CMD_Reply *tx_message ) 
{ 
  int status___0 ;
  RPT_RTC_Report report ;

  {
  {
#line 1441
  status___0 = RTC_GetReport(& report);
  }
#line 1442
  if (status___0) {
    {
#line 1443
    tx_message->status = htons((uint16_t )0);
#line 1444
    tx_message->reply = htons((uint16_t )7);
#line 1445
    UTI_TimevalHostToNetwork(& report.ref_time, & tx_message->data.rtc.ref_time);
#line 1446
    tx_message->data.rtc.n_samples = htons(report.n_samples);
#line 1447
    tx_message->data.rtc.n_runs = htons(report.n_runs);
#line 1448
    tx_message->data.rtc.span_seconds = htonl((uint32_t )report.span_seconds);
#line 1449
    tx_message->data.rtc.rtc_seconds_fast = UTI_FloatHostToNetwork(report.rtc_seconds_fast);
#line 1450
    tx_message->data.rtc.rtc_gain_rate_ppm = UTI_FloatHostToNetwork(report.rtc_gain_rate_ppm);
    }
  } else {
    {
#line 1452
    tx_message->status = htons((uint16_t )13);
    }
  }
#line 1454
  return;
}
}
#line 1458 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
static void handle_trimrtc(CMD_Request *rx_message , CMD_Reply *tx_message ) 
{ 
  int status___0 ;

  {
  {
#line 1462
  status___0 = RTC_Trim();
  }
#line 1463
  if (status___0) {
    {
#line 1464
    tx_message->status = htons((uint16_t )0);
    }
  } else {
    {
#line 1466
    tx_message->status = htons((uint16_t )13);
    }
  }
#line 1468
  return;
}
}
#line 1472 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
static void handle_cyclelogs(CMD_Request *rx_message , CMD_Reply *tx_message ) 
{ 


  {
  {
#line 1475
  LOG_CycleLogFiles();
#line 1477
  tx_message->status = htons((uint16_t )0);
  }
#line 1478
  return;
}
}
#line 1482 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
static void handle_client_accesses_by_index(CMD_Request *rx_message , CMD_Reply *tx_message ) 
{ 
  CLG_Status result ;
  RPT_ClientAccessByIndex_Report report ;
  unsigned long first_index ;
  unsigned long n_indices ;
  unsigned long last_index ;
  unsigned long n_indices_in_table ;
  int i ;
  int j ;
  struct timeval now ;
  uint32_t tmp ;
  uint32_t tmp___0 ;

  {
  {
#line 1491
  LCL_ReadCookedTime(& now, (double *)((void *)0));
#line 1493
  tmp = ntohl(rx_message->data.client_accesses_by_index.first_index);
#line 1493
  first_index = (unsigned long )tmp;
#line 1494
  tmp___0 = ntohl(rx_message->data.client_accesses_by_index.n_indices);
#line 1494
  n_indices = (unsigned long )tmp___0;
#line 1495
  last_index = (first_index + n_indices) - 1UL;
#line 1497
  tx_message->status = htons((uint16_t )0);
#line 1498
  tx_message->reply = htons((uint16_t )10);
#line 1500
  i = (int )first_index;
#line 1500
  j = 0;
  }
  {
#line 1500
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1500
    if ((unsigned long )i <= last_index) {
#line 1500
      if (! (j < 8)) {
#line 1500
        goto while_break;
      }
    } else {
#line 1500
      goto while_break;
    }
    {
#line 1504
    result = CLG_GetClientAccessReportByIndex(i, & report, now.tv_sec, & n_indices_in_table);
#line 1505
    tx_message->data.client_accesses_by_index.n_indices = htonl((uint32_t )n_indices_in_table);
    }
    {
#line 1508
    if ((unsigned int )result == 0U) {
#line 1508
      goto case_0;
    }
#line 1519
    if ((unsigned int )result == 4U) {
#line 1519
      goto case_4;
    }
#line 1521
    if ((unsigned int )result == 3U) {
#line 1521
      goto case_3;
    }
#line 1524
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 1509
    UTI_IPHostToNetwork(& report.ip_addr, & tx_message->data.client_accesses_by_index.clients[j].ip);
#line 1510
    tx_message->data.client_accesses_by_index.clients[j].client_hits = htonl((uint32_t )report.client_hits);
#line 1511
    tx_message->data.client_accesses_by_index.clients[j].peer_hits = htonl((uint32_t )report.peer_hits);
#line 1512
    tx_message->data.client_accesses_by_index.clients[j].cmd_hits_auth = htonl((uint32_t )report.cmd_hits_auth);
#line 1513
    tx_message->data.client_accesses_by_index.clients[j].cmd_hits_normal = htonl((uint32_t )report.cmd_hits_normal);
#line 1514
    tx_message->data.client_accesses_by_index.clients[j].cmd_hits_bad = htonl((uint32_t )report.cmd_hits_bad);
#line 1515
    tx_message->data.client_accesses_by_index.clients[j].last_ntp_hit_ago = htonl((uint32_t )report.last_ntp_hit_ago);
#line 1516
    tx_message->data.client_accesses_by_index.clients[j].last_cmd_hit_ago = htonl((uint32_t )report.last_cmd_hit_ago);
#line 1517
    j ++;
    }
#line 1518
    goto switch_break;
    case_4: /* CIL Label */ 
#line 1520
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 1522
    tx_message->status = htons((uint16_t )15);
    }
#line 1523
    return;
    switch_default: /* CIL Label */ 
    {
#line 1525
    __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c",
                  1525U, "handle_client_accesses_by_index");
    }
#line 1526
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1500
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1530
  tx_message->data.client_accesses_by_index.next_index = htonl((uint32_t )i);
#line 1531
  tx_message->data.client_accesses_by_index.n_clients = htonl((uint32_t )j);
  }
#line 1532
  return;
}
}
#line 1536 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
static void handle_manual_list(CMD_Request *rx_message , CMD_Reply *tx_message ) 
{ 
  int n_samples___1 ;
  int i ;
  RPY_ManualListSample *sample ;
  RPT_ManualSamplesReport report[32] ;

  {
  {
#line 1544
  tx_message->status = htons((uint16_t )0);
#line 1545
  tx_message->reply = htons((uint16_t )11);
#line 1547
  MNL_ReportSamples(report, 32, & n_samples___1);
#line 1548
  tx_message->data.manual_list.n_samples = htonl((uint32_t )n_samples___1);
#line 1549
  i = 0;
  }
  {
#line 1549
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1549
    if (! (i < n_samples___1)) {
#line 1549
      goto while_break;
    }
    {
#line 1550
    sample = & tx_message->data.manual_list.samples[i];
#line 1551
    UTI_TimevalHostToNetwork(& report[i].when, & sample->when);
#line 1552
    sample->slewed_offset = UTI_FloatHostToNetwork(report[i].slewed_offset);
#line 1553
    sample->orig_offset = UTI_FloatHostToNetwork(report[i].orig_offset);
#line 1554
    sample->residual = UTI_FloatHostToNetwork(report[i].residual);
#line 1549
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1556
  return;
}
}
#line 1560 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
static void handle_manual_delete(CMD_Request *rx_message , CMD_Reply *tx_message ) 
{ 
  int status___0 ;
  int index___0 ;
  uint32_t tmp ;

  {
  {
#line 1566
  tmp = ntohl((uint32_t )rx_message->data.manual_delete.index);
#line 1566
  index___0 = (int )tmp;
#line 1567
  status___0 = MNL_DeleteSample(index___0);
  }
#line 1568
  if (! status___0) {
    {
#line 1569
    tx_message->status = htons((uint16_t )16);
    }
  } else {
    {
#line 1571
    tx_message->status = htons((uint16_t )0);
    }
  }
#line 1573
  return;
}
}
#line 1577 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
static void handle_make_step(CMD_Request *rx_message , CMD_Reply *tx_message ) 
{ 


  {
  {
#line 1580
  LCL_MakeStep(0.0);
#line 1581
  tx_message->status = htons((uint16_t )0);
  }
#line 1582
  return;
}
}
#line 1586 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
static void handle_activity(CMD_Request *rx_message , CMD_Reply *tx_message ) 
{ 
  RPT_ActivityReport report ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  uint32_t tmp___3 ;

  {
  {
#line 1590
  NSR_GetActivityReport(& report);
#line 1591
  tmp = htonl((uint32_t )report.online);
#line 1591
  tx_message->data.activity.online = (int32_t )tmp;
#line 1592
  tmp___0 = htonl((uint32_t )report.offline);
#line 1592
  tx_message->data.activity.offline = (int32_t )tmp___0;
#line 1593
  tmp___1 = htonl((uint32_t )report.burst_online);
#line 1593
  tx_message->data.activity.burst_online = (int32_t )tmp___1;
#line 1594
  tmp___2 = htonl((uint32_t )report.burst_offline);
#line 1594
  tx_message->data.activity.burst_offline = (int32_t )tmp___2;
#line 1595
  tmp___3 = htonl((uint32_t )report.unresolved);
#line 1595
  tx_message->data.activity.unresolved = (int32_t )tmp___3;
#line 1596
  tx_message->status = htons((uint16_t )0);
#line 1597
  tx_message->reply = htons((uint16_t )12);
  }
#line 1598
  return;
}
}
#line 1602 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
static void handle_reselect_distance(CMD_Request *rx_message , CMD_Reply *tx_message ) 
{ 
  double dist ;

  {
  {
#line 1606
  dist = UTI_FloatNetworkToHost(rx_message->data.reselect_distance.distance);
#line 1607
  SRC_SetReselectDistance(dist);
#line 1608
  tx_message->status = htons((uint16_t )0);
  }
#line 1609
  return;
}
}
#line 1613 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
static void handle_reselect(CMD_Request *rx_message , CMD_Reply *tx_message ) 
{ 


  {
  {
#line 1616
  SRC_ReselectSource();
#line 1617
  tx_message->status = htons((uint16_t )0);
  }
#line 1618
  return;
}
}
#line 2206 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
static int do_it  =    1;
#line 1637 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
static void read_from_cmd_socket(void *anything ) 
{ 
  int status___0 ;
  int read_length ;
  int expected_length ;
  unsigned long flags ;
  CMD_Request rx_message ;
  CMD_Reply tx_message ;
  CMD_Reply *prev_tx_message ;
  int rx_message_length ;
  int tx_message_length ;
  int sock_fd___0 ;
  union sockaddr_in46 where_from ;
  socklen_t from_length ;
  IPAddr remote_ip ;
  unsigned short remote_port ;
  int auth_length ;
  int auth_ok ;
  int utoken_ok ;
  int token_ok ;
  int issue_token ;
  int valid_ts ;
  int authenticated ;
  int localhost ;
  int allowed ;
  unsigned short rx_command ;
  unsigned long rx_message_token ;
  unsigned long tx_message_token ;
  unsigned long rx_message_seq ;
  unsigned long rx_attempt ;
  struct timeval now ;
  struct timeval cooked_now ;
  ssize_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  uint32_t tmp___14 ;
  uint32_t tmp___15 ;
  uint32_t tmp___16 ;
  uint16_t tmp___17 ;
  ssize_t tmp___18 ;
  char *tmp___19 ;
  int tmp___20 ;
  struct timeval ts ;
  uint32_t tmp___21 ;
  char *tmp___22 ;
  int tmp___23 ;

  {
  {
#line 1668
  flags = 0UL;
#line 1669
  rx_message_length = (int )sizeof(rx_message);
#line 1670
  from_length = (socklen_t )sizeof(where_from);
#line 1672
  sock_fd___0 = (int )((long )anything);
#line 1673
  tmp = recvfrom(sock_fd___0, (void */* __restrict  */)((char *)(& rx_message)), (size_t )rx_message_length,
                 (int )flags, (struct sockaddr */* __restrict  */)(& where_from.u),
                 (socklen_t */* __restrict  */)(& from_length));
#line 1673
  status___0 = (int )tmp;
  }
#line 1676
  if (status___0 < 0) {
    {
#line 1677
    LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c",
                 1677, "read_from_cmd_socket");
#line 1677
    tmp___0 = __errno_location();
#line 1677
    tmp___1 = strerror(*tmp___0);
#line 1677
    LOG_Line_Function((LOG_Severity )1, (LOG_Facility )12, "Error [%s] reading from control socket %d",
                      tmp___1, sock_fd___0);
    }
#line 1679
    return;
  }
  {
#line 1682
  read_length = status___0;
#line 1684
  LCL_ReadRawTime(& now);
#line 1685
  LCL_CookTime(& now, & cooked_now, (double *)((void *)0));
  }
  {
#line 1688
  if ((int )where_from.u.sa_family == 2) {
#line 1688
    goto case_2;
  }
#line 1695
  if ((int )where_from.u.sa_family == 10) {
#line 1695
    goto case_10;
  }
#line 1707
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 1689
  remote_ip.family = (uint16_t )1;
#line 1690
  remote_ip.addr.in4 = ntohl(where_from.in4.sin_addr.s_addr);
#line 1691
  remote_port = ntohs(where_from.in4.sin_port);
#line 1692
  localhost = (unsigned long )remote_ip.addr.in4 == 2130706433UL;
  }
#line 1693
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 1696
  remote_ip.family = (uint16_t )2;
#line 1697
  memcpy((void */* __restrict  */)(& remote_ip.addr.in6), (void const   */* __restrict  */)(where_from.in6.sin6_addr.__in6_u.__u6_addr8),
         sizeof(remote_ip.addr.in6));
#line 1699
  remote_port = ntohs(where_from.in6.sin6_port);
#line 1701
  localhost = 0;
  }
  {
#line 1701
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1701
    if (! (localhost < 16)) {
#line 1701
      goto while_break;
    }
#line 1702
    if ((int )remote_ip.addr.in6[localhost] != 0) {
#line 1703
      goto while_break;
    }
#line 1701
    localhost ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1704
  if (localhost == 15) {
#line 1704
    if ((int )remote_ip.addr.in6[localhost] == 1) {
#line 1704
      tmp___2 = 1;
    } else {
#line 1704
      tmp___2 = 0;
    }
  } else {
#line 1704
    tmp___2 = 0;
  }
#line 1704
  localhost = tmp___2;
#line 1705
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1708
  __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c",
                1708U, "read_from_cmd_socket");
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 1711
  tmp___3 = ADF_IsAllowed(access_auth_table___0, & remote_ip);
  }
#line 1711
  if (tmp___3) {
#line 1711
    tmp___4 = 1;
  } else
#line 1711
  if (localhost) {
#line 1711
    tmp___4 = 1;
  } else {
#line 1711
    tmp___4 = 0;
  }
#line 1711
  allowed = tmp___4;
#line 1714
  if ((unsigned long )read_length >= (unsigned long )(& ((CMD_Request *)0)->data)) {
    {
#line 1715
    expected_length = PKL_CommandLength(& rx_message);
    }
  } else {
#line 1717
    expected_length = 0;
  }
#line 1720
  if ((unsigned long )expected_length < (unsigned long )(& ((CMD_Request *)0)->data)) {
#line 1720
    goto _L;
  } else
#line 1720
  if ((int )rx_message.pkt_type != 1) {
#line 1720
    goto _L;
  } else
#line 1720
  if ((int )rx_message.res1 != 0) {
#line 1720
    goto _L;
  } else
#line 1720
  if ((int )rx_message.res2 != 0) {
    _L: /* CIL Label */ 
#line 1726
    if (allowed) {
      {
#line 1727
      CLG_LogCommandAccess(& remote_ip, (CLG_Command_Type )2, cooked_now.tv_sec);
      }
    }
#line 1729
    return;
  }
  {
#line 1732
  rx_command = ntohs(rx_message.command);
#line 1734
  tx_message.version = (uint8_t )5;
#line 1735
  tx_message.pkt_type = (uint8_t )2;
#line 1736
  tx_message.res1 = (uint8_t )0;
#line 1737
  tx_message.res2 = (uint8_t )0;
#line 1738
  tx_message.command = rx_message.command;
#line 1739
  tx_message.sequence = rx_message.sequence;
#line 1740
  tx_message.reply = htons((uint16_t )1);
#line 1741
  tx_message.number = htons((uint16_t )1);
#line 1742
  tx_message.total = htons((uint16_t )1);
#line 1743
  tx_message.pad1 = (uint16_t )0;
#line 1744
  tx_message.utoken = htonl((uint32_t )utoken);
#line 1748
  tx_message.token = htonl((uint32_t )4294967295UL);
#line 1749
  memset((void *)(& tx_message.auth), 0, sizeof(tx_message.auth));
  }
#line 1751
  if ((int )rx_message.version != 5) {
    {
#line 1752
    tx_message.status = htons((uint16_t )10);
#line 1753
    tmp___6 = LOG_RateLimited();
    }
#line 1753
    if (! tmp___6) {
      {
#line 1754
      LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c",
                   1754, "read_from_cmd_socket");
#line 1754
      tmp___5 = UTI_IPToString(& remote_ip);
#line 1754
      LOG_Line_Function((LOG_Severity )1, (LOG_Facility )12, "Read command packet with protocol version %d (expected %d) from %s:%hu",
                        (int )rx_message.version, 5, tmp___5, (int )remote_port);
      }
    }
#line 1756
    if (allowed) {
      {
#line 1757
      CLG_LogCommandAccess(& remote_ip, (CLG_Command_Type )2, cooked_now.tv_sec);
      }
    }
#line 1759
    if ((int )rx_message.version >= 4) {
      {
#line 1760
      tx_message.status = htons((uint16_t )18);
#line 1763
      tmp___7 = PKL_ReplyLength(& tx_message);
#line 1763
      memset((void *)((char *)(& tx_message) + tmp___7), 0, (size_t )16);
#line 1764
      transmit_reply(& tx_message, & where_from, 16);
      }
    }
#line 1766
    return;
  }
#line 1769
  if ((int )rx_command >= 50) {
    {
#line 1770
    tmp___9 = LOG_RateLimited();
    }
#line 1770
    if (! tmp___9) {
      {
#line 1771
      LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c",
                   1771, "read_from_cmd_socket");
#line 1771
      tmp___8 = UTI_IPToString(& remote_ip);
#line 1771
      LOG_Line_Function((LOG_Severity )1, (LOG_Facility )12, "Read command packet with invalid command %d from %s:%hu",
                        (int )rx_command, tmp___8, (int )remote_port);
      }
    }
#line 1773
    if (allowed) {
      {
#line 1774
      CLG_LogCommandAccess(& remote_ip, (CLG_Command_Type )2, cooked_now.tv_sec);
      }
    }
    {
#line 1776
    tx_message.status = htons((uint16_t )3);
#line 1777
    transmit_reply(& tx_message, & where_from, 0);
    }
#line 1778
    return;
  }
#line 1781
  if (read_length < expected_length) {
    {
#line 1782
    tmp___11 = LOG_RateLimited();
    }
#line 1782
    if (! tmp___11) {
      {
#line 1783
      LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c",
                   1783, "read_from_cmd_socket");
#line 1783
      tmp___10 = UTI_IPToString(& remote_ip);
#line 1783
      LOG_Line_Function((LOG_Severity )1, (LOG_Facility )12, "Read incorrectly sized command packet from %s:%hu",
                        tmp___10, (int )remote_port);
      }
    }
#line 1785
    if (allowed) {
      {
#line 1786
      CLG_LogCommandAccess(& remote_ip, (CLG_Command_Type )2, cooked_now.tv_sec);
      }
    }
    {
#line 1788
    tx_message.status = htons((uint16_t )19);
#line 1789
    transmit_reply(& tx_message, & where_from, 0);
    }
#line 1790
    return;
  }
#line 1793
  if (! allowed) {
    {
#line 1799
    tmp___13 = LOG_RateLimited();
    }
#line 1799
    if (! tmp___13) {
      {
#line 1800
      LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c",
                   1800, "read_from_cmd_socket");
#line 1800
      tmp___12 = UTI_IPToString(& remote_ip);
#line 1800
      LOG_Line_Function((LOG_Severity )1, (LOG_Facility )12, "Command packet received from unauthorised host %s port %d",
                        tmp___12, (int )remote_port);
      }
    }
    {
#line 1805
    tx_message.status = htons((uint16_t )10);
#line 1806
    transmit_reply(& tx_message, & where_from, 0);
    }
#line 1808
    return;
  }
#line 1816
  if (rx_message.utoken != 0U) {
    {
#line 1817
    auth_ok = check_rx_packet_auth(& rx_message, read_length);
    }
  } else {
#line 1819
    auth_ok = 0;
  }
  {
#line 1862
  tmp___14 = ntohl(rx_message.utoken);
#line 1862
  utoken_ok = (unsigned long )tmp___14 == utoken;
#line 1866
  tmp___15 = ntohl(rx_message.token);
#line 1866
  rx_message_token = (unsigned long )tmp___15;
#line 1867
  tmp___16 = ntohl(rx_message.sequence);
#line 1867
  rx_message_seq = (unsigned long )tmp___16;
#line 1868
  tmp___17 = ntohs(rx_message.attempt);
#line 1868
  rx_attempt = (unsigned long )tmp___17;
  }
#line 1870
  if (auth_ok) {
#line 1870
    if (utoken_ok) {
      {
#line 1871
      token_ok = check_token(rx_message_token);
      }
    } else {
#line 1873
      token_ok = 0;
    }
  } else {
#line 1873
    token_ok = 0;
  }
#line 1876
  if (auth_ok) {
#line 1876
    if (utoken_ok) {
#line 1876
      if (! token_ok) {
        {
#line 1879
        prev_tx_message = lookup_reply(rx_message_token, rx_message_seq, (unsigned short )rx_attempt);
        }
#line 1880
        if (prev_tx_message) {
          {
#line 1882
          tx_message_length = PKL_ReplyLength(prev_tx_message);
#line 1883
          tmp___18 = sendto(sock_fd___0, (void const   *)((void *)prev_tx_message),
                            (size_t )tx_message_length, 0, (struct sockaddr  const  */* __restrict  */)(& where_from.u),
                            from_length);
#line 1883
          status___0 = (int )tmp___18;
          }
#line 1885
          if (status___0 < 0) {
            {
#line 1885
            tmp___20 = LOG_RateLimited();
            }
#line 1885
            if (! tmp___20) {
              {
#line 1886
              LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c",
                           1886, "read_from_cmd_socket");
#line 1886
              tmp___19 = UTI_IPToString(& remote_ip);
#line 1886
              LOG_Line_Function((LOG_Severity )1, (LOG_Facility )12, "Could not send response to %s:%hu",
                                tmp___19, (int )remote_port);
              }
            }
          }
#line 1888
          return;
        }
      }
    }
  }
#line 1894
  if (auth_ok) {
#line 1894
    if (utoken_ok) {
#line 1894
      if (token_ok) {
        {
#line 1896
        token_acknowledged(rx_message_token, & now);
        }
      }
    }
  }
#line 1899
  valid_ts = 0;
#line 1901
  if (auth_ok) {
    {
#line 1904
    UTI_TimevalNetworkToHost(& rx_message.data.logon.ts, & ts);
    }
#line 1905
    if (utoken_ok) {
#line 1905
      if (token_ok) {
#line 1909
        issue_token = 1;
      } else {
#line 1905
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      {
#line 1905
      tmp___21 = ntohl(rx_message.utoken);
      }
#line 1905
      if (tmp___21 == 269488144U) {
#line 1905
        if ((int )rx_command == 10) {
          {
#line 1905
          valid_ts = ts_is_unique_and_not_stale(& ts, & now);
          }
#line 1905
          if (valid_ts) {
#line 1909
            issue_token = 1;
          } else {
#line 1911
            issue_token = 0;
          }
        } else {
#line 1911
          issue_token = 0;
        }
      } else {
#line 1911
        issue_token = 0;
      }
    }
  } else {
#line 1913
    issue_token = 0;
  }
#line 1916
  authenticated = (auth_ok & utoken_ok) & token_ok;
#line 1918
  if (authenticated) {
    {
#line 1919
    CLG_LogCommandAccess(& remote_ip, (CLG_Command_Type )0, cooked_now.tv_sec);
    }
  } else {
    {
#line 1921
    CLG_LogCommandAccess(& remote_ip, (CLG_Command_Type )1, cooked_now.tv_sec);
    }
  }
#line 1924
  if (issue_token) {
    {
#line 1928
    tx_message_token = get_token();
    }
  } else {
#line 1930
    tx_message_token = 4294967295UL;
  }
  {
#line 1933
  tx_message.token = htonl((uint32_t )tx_message_token);
  }
#line 1936
  if ((int )rx_command >= 50) {
    {
#line 1938
    __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c",
                  1938U, "read_from_cmd_socket");
    }
  } else {
#line 1940
    allowed = 0;
    {
#line 1944
    if (permissions[rx_command] == 2) {
#line 1944
      goto case_2___0;
    }
#line 1951
    if (permissions[rx_command] == 1) {
#line 1951
      goto case_1;
    }
#line 1958
    if (permissions[rx_command] == 0) {
#line 1958
      goto case_0;
    }
#line 1961
    goto switch_default___0;
    case_2___0: /* CIL Label */ 
#line 1945
    if (authenticated) {
#line 1946
      allowed = 1;
    } else {
#line 1948
      allowed = 0;
    }
#line 1950
    goto switch_break___0;
    case_1: /* CIL Label */ 
#line 1952
    if (authenticated) {
#line 1953
      allowed = 1;
    } else
#line 1952
    if (localhost) {
#line 1953
      allowed = 1;
    } else {
#line 1955
      allowed = 0;
    }
#line 1957
    goto switch_break___0;
    case_0: /* CIL Label */ 
#line 1959
    allowed = 1;
#line 1960
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 1962
    __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c",
                  1962U, "read_from_cmd_socket");
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 1965
    if (allowed) {
      {
#line 1967
      if ((int )rx_command == 0) {
#line 1967
        goto case_0___0;
      }
#line 1971
      if ((int )rx_command == 1) {
#line 1971
        goto case_1___0;
      }
#line 1975
      if ((int )rx_command == 2) {
#line 1975
        goto case_2___1;
      }
#line 1979
      if ((int )rx_command == 3) {
#line 1979
        goto case_3;
      }
#line 1983
      if ((int )rx_command == 4) {
#line 1983
        goto case_4;
      }
#line 1987
      if ((int )rx_command == 5) {
#line 1987
        goto case_5;
      }
#line 1991
      if ((int )rx_command == 6) {
#line 1991
        goto case_6;
      }
#line 1996
      if ((int )rx_command == 7) {
#line 1996
        goto case_7;
      }
#line 2000
      if ((int )rx_command == 8) {
#line 2000
        goto case_8;
      }
#line 2004
      if ((int )rx_command == 47) {
#line 2004
        goto case_47;
      }
#line 2008
      if ((int )rx_command == 9) {
#line 2008
        goto case_9;
      }
#line 2012
      if ((int )rx_command == 10) {
#line 2012
        goto case_10___0;
      }
#line 2034
      if ((int )rx_command == 11) {
#line 2034
        goto case_11;
      }
#line 2038
      if ((int )rx_command == 12) {
#line 2038
        goto case_12;
      }
#line 2042
      if ((int )rx_command == 13) {
#line 2042
        goto case_13;
      }
#line 2046
      if ((int )rx_command == 14) {
#line 2046
        goto case_14;
      }
#line 2050
      if ((int )rx_command == 15) {
#line 2050
        goto case_15;
      }
#line 2054
      if ((int )rx_command == 16) {
#line 2054
        goto case_16;
      }
#line 2058
      if ((int )rx_command == 17) {
#line 2058
        goto case_17;
      }
#line 2062
      if ((int )rx_command == 18) {
#line 2062
        goto case_18;
      }
#line 2066
      if ((int )rx_command == 19) {
#line 2066
        goto case_19;
      }
#line 2070
      if ((int )rx_command == 20) {
#line 2070
        goto case_20;
      }
#line 2074
      if ((int )rx_command == 21) {
#line 2074
        goto case_21;
      }
#line 2078
      if ((int )rx_command == 22) {
#line 2078
        goto case_22;
      }
#line 2082
      if ((int )rx_command == 23) {
#line 2082
        goto case_23;
      }
#line 2086
      if ((int )rx_command == 24) {
#line 2086
        goto case_24;
      }
#line 2090
      if ((int )rx_command == 25) {
#line 2090
        goto case_25;
      }
#line 2094
      if ((int )rx_command == 26) {
#line 2094
        goto case_26;
      }
#line 2098
      if ((int )rx_command == 27) {
#line 2098
        goto case_27;
      }
#line 2102
      if ((int )rx_command == 28) {
#line 2102
        goto case_28;
      }
#line 2106
      if ((int )rx_command == 29) {
#line 2106
        goto case_29;
      }
#line 2110
      if ((int )rx_command == 30) {
#line 2110
        goto case_30;
      }
#line 2114
      if ((int )rx_command == 31) {
#line 2114
        goto case_31;
      }
#line 2118
      if ((int )rx_command == 32) {
#line 2118
        goto case_32;
      }
#line 2122
      if ((int )rx_command == 33) {
#line 2122
        goto case_33;
      }
#line 2126
      if ((int )rx_command == 34) {
#line 2126
        goto case_34;
      }
#line 2130
      if ((int )rx_command == 35) {
#line 2130
        goto case_35;
      }
#line 2134
      if ((int )rx_command == 36) {
#line 2134
        goto case_36;
      }
#line 2138
      if ((int )rx_command == 37) {
#line 2138
        goto case_37;
      }
#line 2142
      if ((int )rx_command == 40) {
#line 2142
        goto case_40;
      }
#line 2146
      if ((int )rx_command == 41) {
#line 2146
        goto case_41;
      }
#line 2150
      if ((int )rx_command == 42) {
#line 2150
        goto case_42;
      }
#line 2154
      if ((int )rx_command == 43) {
#line 2154
        goto case_43;
      }
#line 2158
      if ((int )rx_command == 44) {
#line 2158
        goto case_44;
      }
#line 2162
      if ((int )rx_command == 49) {
#line 2162
        goto case_49;
      }
#line 2166
      if ((int )rx_command == 48) {
#line 2166
        goto case_48;
      }
#line 2170
      if ((int )rx_command == 45) {
#line 2170
        goto case_45;
      }
#line 2174
      if ((int )rx_command == 46) {
#line 2174
        goto case_46;
      }
#line 2178
      goto switch_default___1;
      case_0___0: /* CIL Label */ 
      {
#line 1968
      handle_null(& rx_message, & tx_message);
      }
#line 1969
      goto switch_break___1;
      case_1___0: /* CIL Label */ 
      {
#line 1972
      handle_online(& rx_message, & tx_message);
      }
#line 1973
      goto switch_break___1;
      case_2___1: /* CIL Label */ 
      {
#line 1976
      handle_offline(& rx_message, & tx_message);
      }
#line 1977
      goto switch_break___1;
      case_3: /* CIL Label */ 
      {
#line 1980
      handle_burst(& rx_message, & tx_message);
      }
#line 1981
      goto switch_break___1;
      case_4: /* CIL Label */ 
      {
#line 1984
      handle_modify_minpoll(& rx_message, & tx_message);
      }
#line 1985
      goto switch_break___1;
      case_5: /* CIL Label */ 
      {
#line 1988
      handle_modify_maxpoll(& rx_message, & tx_message);
      }
#line 1989
      goto switch_break___1;
      case_6: /* CIL Label */ 
      {
#line 1992
      SRC_DumpSources();
#line 1993
      tx_message.status = htons((uint16_t )0);
      }
#line 1994
      goto switch_break___1;
      case_7: /* CIL Label */ 
      {
#line 1997
      handle_modify_maxdelay(& rx_message, & tx_message);
      }
#line 1998
      goto switch_break___1;
      case_8: /* CIL Label */ 
      {
#line 2001
      handle_modify_maxdelayratio(& rx_message, & tx_message);
      }
#line 2002
      goto switch_break___1;
      case_47: /* CIL Label */ 
      {
#line 2005
      handle_modify_maxdelaydevratio(& rx_message, & tx_message);
      }
#line 2006
      goto switch_break___1;
      case_9: /* CIL Label */ 
      {
#line 2009
      handle_modify_maxupdateskew(& rx_message, & tx_message);
      }
#line 2010
      goto switch_break___1;
      case_10___0: /* CIL Label */ 
#line 2014
      if (! issue_token) {
        {
#line 2014
        tmp___23 = LOG_RateLimited();
        }
#line 2014
        if (! tmp___23) {
          {
#line 2015
          LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c",
                       2015, "read_from_cmd_socket");
#line 2015
          tmp___22 = UTI_IPToString(& remote_ip);
#line 2015
          LOG_Line_Function((LOG_Severity )1, (LOG_Facility )12, "Bad command logon from %s port %d (auth_ok=%d valid_ts=%d)",
                            tmp___22, (int )remote_port, auth_ok, valid_ts);
          }
        }
      }
#line 2022
      if (issue_token == 1) {
        {
#line 2023
        tx_message.status = htons((uint16_t )0);
        }
      } else
#line 2024
      if (! auth_ok) {
        {
#line 2025
        tx_message.status = htons((uint16_t )2);
        }
      } else
#line 2026
      if (! valid_ts) {
        {
#line 2027
        tx_message.status = htons((uint16_t )5);
        }
      } else {
        {
#line 2029
        tx_message.status = htons((uint16_t )1);
        }
      }
#line 2032
      goto switch_break___1;
      case_11: /* CIL Label */ 
      {
#line 2035
      handle_settime(& rx_message, & tx_message);
      }
#line 2036
      goto switch_break___1;
      case_12: /* CIL Label */ 
      {
#line 2039
      handle_local(& rx_message, & tx_message);
      }
#line 2040
      goto switch_break___1;
      case_13: /* CIL Label */ 
      {
#line 2043
      handle_manual(& rx_message, & tx_message);
      }
#line 2044
      goto switch_break___1;
      case_14: /* CIL Label */ 
      {
#line 2047
      handle_n_sources(& rx_message, & tx_message);
      }
#line 2048
      goto switch_break___1;
      case_15: /* CIL Label */ 
      {
#line 2051
      handle_source_data(& rx_message, & tx_message);
      }
#line 2052
      goto switch_break___1;
      case_16: /* CIL Label */ 
      {
#line 2055
      handle_rekey(& rx_message, & tx_message);
      }
#line 2056
      goto switch_break___1;
      case_17: /* CIL Label */ 
      {
#line 2059
      handle_allow(& rx_message, & tx_message);
      }
#line 2060
      goto switch_break___1;
      case_18: /* CIL Label */ 
      {
#line 2063
      handle_allowall(& rx_message, & tx_message);
      }
#line 2064
      goto switch_break___1;
      case_19: /* CIL Label */ 
      {
#line 2067
      handle_deny(& rx_message, & tx_message);
      }
#line 2068
      goto switch_break___1;
      case_20: /* CIL Label */ 
      {
#line 2071
      handle_denyall(& rx_message, & tx_message);
      }
#line 2072
      goto switch_break___1;
      case_21: /* CIL Label */ 
      {
#line 2075
      handle_cmdallow(& rx_message, & tx_message);
      }
#line 2076
      goto switch_break___1;
      case_22: /* CIL Label */ 
      {
#line 2079
      handle_cmdallowall(& rx_message, & tx_message);
      }
#line 2080
      goto switch_break___1;
      case_23: /* CIL Label */ 
      {
#line 2083
      handle_cmddeny(& rx_message, & tx_message);
      }
#line 2084
      goto switch_break___1;
      case_24: /* CIL Label */ 
      {
#line 2087
      handle_cmddenyall(& rx_message, & tx_message);
      }
#line 2088
      goto switch_break___1;
      case_25: /* CIL Label */ 
      {
#line 2091
      handle_accheck(& rx_message, & tx_message);
      }
#line 2092
      goto switch_break___1;
      case_26: /* CIL Label */ 
      {
#line 2095
      handle_cmdaccheck(& rx_message, & tx_message);
      }
#line 2096
      goto switch_break___1;
      case_27: /* CIL Label */ 
      {
#line 2099
      handle_add_source((NTP_Source_Type )0, & rx_message, & tx_message);
      }
#line 2100
      goto switch_break___1;
      case_28: /* CIL Label */ 
      {
#line 2103
      handle_add_source((NTP_Source_Type )1, & rx_message, & tx_message);
      }
#line 2104
      goto switch_break___1;
      case_29: /* CIL Label */ 
      {
#line 2107
      handle_del_source(& rx_message, & tx_message);
      }
#line 2108
      goto switch_break___1;
      case_30: /* CIL Label */ 
      {
#line 2111
      handle_writertc(& rx_message, & tx_message);
      }
#line 2112
      goto switch_break___1;
      case_31: /* CIL Label */ 
      {
#line 2115
      handle_dfreq(& rx_message, & tx_message);
      }
#line 2116
      goto switch_break___1;
      case_32: /* CIL Label */ 
      {
#line 2119
      handle_doffset(& rx_message, & tx_message);
      }
#line 2120
      goto switch_break___1;
      case_33: /* CIL Label */ 
      {
#line 2123
      handle_tracking(& rx_message, & tx_message);
      }
#line 2124
      goto switch_break___1;
      case_34: /* CIL Label */ 
      {
#line 2127
      handle_sourcestats(& rx_message, & tx_message);
      }
#line 2128
      goto switch_break___1;
      case_35: /* CIL Label */ 
      {
#line 2131
      handle_rtcreport(& rx_message, & tx_message);
      }
#line 2132
      goto switch_break___1;
      case_36: /* CIL Label */ 
      {
#line 2135
      handle_trimrtc(& rx_message, & tx_message);
      }
#line 2136
      goto switch_break___1;
      case_37: /* CIL Label */ 
      {
#line 2139
      handle_cyclelogs(& rx_message, & tx_message);
      }
#line 2140
      goto switch_break___1;
      case_40: /* CIL Label */ 
      {
#line 2143
      handle_client_accesses_by_index(& rx_message, & tx_message);
      }
#line 2144
      goto switch_break___1;
      case_41: /* CIL Label */ 
      {
#line 2147
      handle_manual_list(& rx_message, & tx_message);
      }
#line 2148
      goto switch_break___1;
      case_42: /* CIL Label */ 
      {
#line 2151
      handle_manual_delete(& rx_message, & tx_message);
      }
#line 2152
      goto switch_break___1;
      case_43: /* CIL Label */ 
      {
#line 2155
      handle_make_step(& rx_message, & tx_message);
      }
#line 2156
      goto switch_break___1;
      case_44: /* CIL Label */ 
      {
#line 2159
      handle_activity(& rx_message, & tx_message);
      }
#line 2160
      goto switch_break___1;
      case_49: /* CIL Label */ 
      {
#line 2163
      handle_reselect_distance(& rx_message, & tx_message);
      }
#line 2164
      goto switch_break___1;
      case_48: /* CIL Label */ 
      {
#line 2167
      handle_reselect(& rx_message, & tx_message);
      }
#line 2168
      goto switch_break___1;
      case_45: /* CIL Label */ 
      {
#line 2171
      handle_modify_minstratum(& rx_message, & tx_message);
      }
#line 2172
      goto switch_break___1;
      case_46: /* CIL Label */ 
      {
#line 2175
      handle_modify_polltarget(& rx_message, & tx_message);
      }
#line 2176
      goto switch_break___1;
      switch_default___1: /* CIL Label */ 
      {
#line 2179
      __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c",
                    2179U, "read_from_cmd_socket");
      }
#line 2180
      goto switch_break___1;
      switch_break___1: /* CIL Label */ ;
      }
    } else {
      {
#line 2183
      tx_message.status = htons((uint16_t )2);
      }
    }
  }
#line 2187
  if (auth_ok) {
    {
#line 2188
    auth_length = generate_tx_packet_auth(& tx_message);
    }
  } else {
#line 2190
    auth_length = 0;
  }
#line 2193
  if (token_ok) {
    {
#line 2194
    save_reply(& tx_message, rx_message_token, tx_message_token, rx_message_seq, (unsigned short )rx_attempt,
               & now);
    }
  }
#line 2208
  if (do_it) {
    {
#line 2209
    transmit_reply(& tx_message, & where_from, auth_length);
    }
  }
#line 2216
  return;
}
}
#line 2220 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
int CAM_AddAccessRestriction(IPAddr *ip_addr , int subnet_bits , int allow , int all ) 
{ 
  ADF_Status status___0 ;

  {
#line 2225
  if (allow) {
#line 2226
    if (all) {
      {
#line 2227
      status___0 = ADF_AllowAll(access_auth_table___0, ip_addr, subnet_bits);
      }
    } else {
      {
#line 2229
      status___0 = ADF_Allow(access_auth_table___0, ip_addr, subnet_bits);
      }
    }
  } else
#line 2232
  if (all) {
    {
#line 2233
    status___0 = ADF_DenyAll(access_auth_table___0, ip_addr, subnet_bits);
    }
  } else {
    {
#line 2235
    status___0 = ADF_Deny(access_auth_table___0, ip_addr, subnet_bits);
    }
  }
#line 2239
  if ((unsigned int )status___0 == 1U) {
#line 2240
    return (0);
  } else
#line 2241
  if ((unsigned int )status___0 == 0U) {
#line 2242
    return (1);
  } else {
#line 2244
    return (0);
  }
}
}
#line 2250 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/cmdmon.c"
int CAM_CheckAccessRestriction(IPAddr *ip_addr ) 
{ 
  int tmp ;

  {
  {
#line 2253
  tmp = ADF_IsAllowed(access_auth_table___0, ip_addr);
  }
#line 2253
  return (tmp);
}
}
#line 34 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/broadcast.h"
void BRD_AddDestination(IPAddr *addr , unsigned short port , int interval ) ;
#line 45 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/broadcast.c"
static Destination *destinations  =    (Destination *)0;
#line 46 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/broadcast.c"
static int n_destinations  =    0;
#line 47 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/broadcast.c"
static int max_destinations  =    0;
#line 49 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/broadcast.c"
void BRD_Initialise(void) 
{ 


  {
#line 52
  return;
}
}
#line 56 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/broadcast.c"
void BRD_Finalise(void) 
{ 


  {
#line 59
  return;
}
}
#line 64 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/broadcast.c"
static void timeout_handler(void *arbitrary ) 
{ 
  Destination *d ;
  NTP_Packet message ;
  int version ;
  int leap ;
  int are_we_synchronised___0 ;
  int our_stratum___0 ;
  NTP_Leap leap_status ;
  uint32_t our_ref_id___0 ;
  uint32_t ts_fuzz ;
  struct timeval our_ref_time___0 ;
  double our_root_delay___0 ;
  double our_root_dispersion___0 ;
  struct timeval local_transmit ;
  int tmp ;

  {
  {
#line 67
  d = (Destination *)arbitrary;
#line 79
  version = 3;
#line 81
  LCL_ReadCookedTime(& local_transmit, (double *)((void *)0));
#line 82
  REF_GetReferenceParams(& local_transmit, & are_we_synchronised___0, & leap_status,
                         & our_stratum___0, & our_ref_id___0, & our_ref_time___0,
                         & our_root_delay___0, & our_root_dispersion___0);
  }
#line 89
  if (are_we_synchronised___0) {
#line 90
    leap = (int )leap_status;
  } else {
#line 92
    leap = 3;
  }
  {
#line 95
  message.lvm = (uint8_t )((((leap << 6) & 192) | ((version << 3) & 56)) | 5);
#line 96
  message.stratum = (uint8_t )our_stratum___0;
#line 97
  message.poll = (int8_t )6;
#line 98
  tmp = LCL_GetSysPrecisionAsLog();
#line 98
  message.precision = (int8_t )tmp;
#line 102
  message.root_delay = UTI_DoubleToInt32(our_root_delay___0);
#line 103
  message.root_dispersion = UTI_DoubleToInt32(our_root_dispersion___0);
#line 105
  message.reference_id = htonl(our_ref_id___0);
#line 108
  UTI_TimevalToInt64(& our_ref_time___0, & message.reference_ts, (uint32_t )0);
#line 109
  message.originate_ts.hi = (uint32_t )0UL;
#line 110
  message.originate_ts.lo = (uint32_t )0UL;
#line 111
  message.receive_ts.hi = (uint32_t )0UL;
#line 112
  message.receive_ts.lo = (uint32_t )0UL;
#line 114
  ts_fuzz = UTI_GetNTPTsFuzz((int )message.precision);
#line 115
  LCL_ReadCookedTime(& local_transmit, (double *)((void *)0));
#line 116
  UTI_TimevalToInt64(& local_transmit, & message.transmit_ts, ts_fuzz);
#line 117
  NIO_SendNormalPacket(& message, & d->addr);
#line 121
  SCH_AddTimeoutInClass((double )d->interval, 1.0, 0.02, (SCH_TimeoutClass )2, & timeout_handler,
                        (void *)d);
  }
#line 126
  return;
}
}
#line 130 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/broadcast.c"
void BRD_AddDestination(IPAddr *addr , unsigned short port , int interval ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 133
  if (max_destinations == n_destinations) {
#line 135
    max_destinations += 8;
#line 136
    if (destinations) {
      {
#line 137
      tmp = realloc((void *)destinations, (unsigned long )max_destinations * sizeof(Destination ));
#line 137
      destinations = (Destination *)tmp;
      }
    } else {
      {
#line 139
      tmp___0 = malloc((unsigned long )max_destinations * sizeof(Destination ));
#line 139
      destinations = (Destination *)tmp___0;
      }
    }
  }
  {
#line 143
  (destinations + n_destinations)->addr.ip_addr = *addr;
#line 144
  (destinations + n_destinations)->addr.local_ip_addr.family = (uint16_t )0;
#line 145
  (destinations + n_destinations)->addr.port = port;
#line 146
  (destinations + n_destinations)->interval = interval;
#line 148
  SCH_AddTimeoutInClass((double )interval, 1.0, 0.0, (SCH_TimeoutClass )2, & timeout_handler,
                        (void *)(destinations + n_destinations));
#line 152
  n_destinations ++;
  }
#line 154
  return;
}
}
#line 138 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sources.h"
void SRC_SelectSource(uint32_t match_refid ) ;
#line 177
SRC_Skew_Direction SRC_LastSkewChange(SRC_Instance inst ) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sourcestats.h"
SST_Stats SST_CreateInstance(uint32_t refid , IPAddr *addr ) ;
#line 44
void SST_DeleteInstance(SST_Stats inst ) ;
#line 62
void SST_AccumulateSample(SST_Stats inst , struct timeval *sample_time , double offset ,
                          double peer_delay , double peer_dispersion , double root_delay ,
                          double root_dispersion , int stratum ) ;
#line 68
void SST_DoNewRegression(SST_Stats inst ) ;
#line 79
void SST_GetFrequencyRange(SST_Stats inst , double *lo , double *hi ) ;
#line 82
void SST_GetSelectionData(SST_Stats inst , struct timeval *now , int *stratum , double *offset_lo_limit ,
                          double *offset_hi_limit , double *root_distance , double *variance ,
                          int *select_ok ) ;
#line 91
void SST_GetTrackingData(SST_Stats inst , struct timeval *ref_time , double *average_offset ,
                         double *offset_sd , double *frequency , double *skew , double *root_delay ,
                         double *root_dispersion ) ;
#line 113
void SST_SlewSamples(SST_Stats inst , struct timeval *when , double dfreq , double doffset ) ;
#line 117
void SST_AddDispersion(SST_Stats inst , double dispersion ) ;
#line 122
double SST_PredictOffset(SST_Stats inst , struct timeval *when ) ;
#line 125
double SST_MinRoundTripDelay(SST_Stats inst ) ;
#line 129
int SST_IsGoodSample(SST_Stats inst , double offset , double delay , double max_delay_dev_ratio ,
                     double clock_error , struct timeval *when ) ;
#line 132
void SST_SaveToFile(SST_Stats inst , FILE *out ) ;
#line 134
int SST_LoadFromFile(SST_Stats inst , FILE *in ) ;
#line 136
void SST_DoSourceReport(SST_Stats inst , RPT_SourceReport *report , struct timeval *now ) ;
#line 138
void SST_DoSourcestatsReport(SST_Stats inst , RPT_SourcestatsReport *report , struct timeval *now ) ;
#line 146
SST_Skew_Direction SST_LastSkewChange(SST_Stats inst ) ;
#line 148
int SST_Samples(SST_Stats inst ) ;
#line 104 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.h"
void REF_SetReference(int stratum , NTP_Leap leap , int combined_sources , uint32_t ref_id ,
                      IPAddr *ref_ip , struct timeval *ref_time , double offset ,
                      double offset_sd , double frequency , double skew , double root_delay ,
                      double root_dispersion ) ;
#line 129
void REF_SetUnsynchronised(void) ;
#line 48 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.h"
char *CNF_GetDumpDir(void) ;
#line 84
double CNF_GetReselectDistance(void) ;
#line 85
double CNF_GetStratumWeight(void) ;
#line 86
double CNF_GetCombineLimit(void) ;
#line 51 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sources.c"
static int initialised___2  =    0;
#line 127 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sources.c"
static struct SRC_Instance_Record **sources  ;
#line 128 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sources.c"
static struct Sort_Element *sort_list  ;
#line 129 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sources.c"
static int *sel_sources  ;
#line 130 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sources.c"
static int n_sources___1  ;
#line 131 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sources.c"
static int max_n_sources  ;
#line 134 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sources.c"
static int selected_source_index  ;
#line 147 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sources.c"
static double reselect_distance  ;
#line 148 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sources.c"
static double stratum_weight  ;
#line 149 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sources.c"
static double combine_limit  ;
#line 154
static void slew_sources___0(struct timeval *raw , struct timeval *cooked , double dfreq ,
                             double doffset , int is_step_change , void *anything ) ;
#line 157
static void add_dispersion___0(double dispersion , void *anything ) ;
#line 159
static char *source_to_string(SRC_Instance inst ) ;
#line 164 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sources.c"
void SRC_Initialise(void) 
{ 


  {
  {
#line 165
  sources = (struct SRC_Instance_Record **)((void *)0);
#line 166
  sort_list = (struct Sort_Element *)((void *)0);
#line 167
  n_sources___1 = 0;
#line 168
  max_n_sources = 0;
#line 169
  selected_source_index = -1;
#line 170
  reselect_distance = CNF_GetReselectDistance();
#line 171
  stratum_weight = CNF_GetStratumWeight();
#line 172
  combine_limit = CNF_GetCombineLimit();
#line 173
  initialised___2 = 1;
#line 175
  LCL_AddParameterChangeHandler(& slew_sources___0, (void *)0);
#line 176
  LCL_AddDispersionNotifyHandler(& add_dispersion___0, (void *)0);
  }
#line 177
  return;
}
}
#line 181 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sources.c"
void SRC_Finalise(void) 
{ 


  {
  {
#line 183
  LCL_RemoveParameterChangeHandler(& slew_sources___0, (void *)0);
#line 184
  LCL_RemoveDispersionNotifyHandler(& add_dispersion___0, (void *)0);
#line 185
  initialised___2 = 0;
  }
#line 186
  return;
}
}
#line 192 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sources.c"
SRC_Instance SRC_CreateNewInstance(uint32_t ref_id , SRC_Type type , SRC_SelectOption sel_option ,
                                   IPAddr *addr ) 
{ 
  SRC_Instance result ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;

  {
#line 196
  if (! initialised___2) {
    {
#line 196
    __assert_fail("initialised", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sources.c",
                  196U, "SRC_CreateNewInstance");
    }
  }
  {
#line 198
  tmp = malloc(sizeof(struct SRC_Instance_Record ));
#line 198
  result = (struct SRC_Instance_Record *)tmp;
#line 199
  result->stats = SST_CreateInstance(ref_id, addr);
  }
#line 201
  if (n_sources___1 == max_n_sources) {
#line 203
    max_n_sources += 32;
#line 204
    if (sources) {
      {
#line 205
      tmp___0 = realloc((void *)sources, (unsigned long )max_n_sources * sizeof(struct SRC_Instance_Record *));
#line 205
      sources = (struct SRC_Instance_Record **)tmp___0;
#line 206
      tmp___1 = realloc((void *)sort_list, (unsigned long )(3 * max_n_sources) * sizeof(struct Sort_Element ));
#line 206
      sort_list = (struct Sort_Element *)tmp___1;
#line 207
      tmp___2 = realloc((void *)sel_sources, (unsigned long )max_n_sources * sizeof(int ));
#line 207
      sel_sources = (int *)tmp___2;
      }
    } else {
      {
#line 209
      tmp___3 = malloc((unsigned long )max_n_sources * sizeof(struct SRC_Instance_Record *));
#line 209
      sources = (struct SRC_Instance_Record **)tmp___3;
#line 210
      tmp___4 = malloc((unsigned long )(3 * max_n_sources) * sizeof(struct Sort_Element ));
#line 210
      sort_list = (struct Sort_Element *)tmp___4;
#line 211
      tmp___5 = malloc((unsigned long )max_n_sources * sizeof(int ));
#line 211
      sel_sources = (int *)tmp___5;
      }
    }
  }
#line 215
  *(sources + n_sources___1) = result;
#line 216
  result->index = n_sources___1;
#line 217
  result->leap_status = (NTP_Leap )0;
#line 218
  result->ref_id = ref_id;
#line 219
  result->ip_addr = addr;
#line 220
  result->selectable = 0;
#line 221
  result->reachability = 0;
#line 222
  result->beginning = 1;
#line 223
  result->outlier = 0;
#line 224
  result->status = (SRC_Status )2;
#line 225
  result->type = type;
#line 226
  result->sel_score = 1.0;
#line 227
  result->sel_option = sel_option;
#line 229
  n_sources___1 ++;
#line 231
  return (result);
}
}
#line 240 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sources.c"
void SRC_DestroyInstance(SRC_Instance instance ) 
{ 
  int dead_index ;
  int i ;

  {
#line 244
  if (! initialised___2) {
    {
#line 244
    __assert_fail("initialised", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sources.c",
                  244U, "SRC_DestroyInstance");
    }
  }
  {
#line 246
  SRC_UnsetSelectable(instance);
#line 248
  SST_DeleteInstance(instance->stats);
#line 249
  dead_index = instance->index;
#line 250
  i = dead_index;
  }
  {
#line 250
  while (1) {
    while_continue: /* CIL Label */ ;
#line 250
    if (! (i < n_sources___1 - 1)) {
#line 250
      goto while_break;
    }
#line 251
    *(sources + i) = *(sources + (i + 1));
#line 252
    (*(sources + i))->index = i;
#line 250
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 254
  n_sources___1 --;
#line 255
  free((void *)instance);
  }
#line 257
  if (selected_source_index > dead_index) {
#line 258
    selected_source_index --;
  }
#line 260
  return;
}
}
#line 274 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sources.c"
void SRC_GetFrequencyRange(SRC_Instance instance , double *lo , double *hi ) 
{ 


  {
#line 276
  if (! initialised___2) {
    {
#line 276
    __assert_fail("initialised", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sources.c",
                  276U, "SRC_GetFrequencyRange");
    }
  }
  {
#line 278
  SST_GetFrequencyRange(instance->stats, lo, hi);
  }
#line 279
  return;
}
}
#line 294 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sources.c"
void SRC_AccumulateSample(SRC_Instance inst , struct timeval *sample_time , double offset ,
                          double peer_delay , double peer_dispersion , double root_delay ,
                          double root_dispersion , int stratum , NTP_Leap leap_status ) 
{ 


  {
#line 306
  if (! initialised___2) {
    {
#line 306
    __assert_fail("initialised", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sources.c",
                  306U, "SRC_AccumulateSample");
    }
  }
  {
#line 308
  inst->leap_status = leap_status;
#line 317
  SST_AccumulateSample(inst->stats, sample_time, - offset, peer_delay, peer_dispersion,
                       root_delay, root_dispersion, stratum);
#line 318
  SST_DoNewRegression(inst->stats);
#line 320
  SRC_SelectSource(inst->ref_id);
  }
#line 321
  return;
}
}
#line 325 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sources.c"
void SRC_SetSelectable(SRC_Instance inst ) 
{ 


  {
#line 328
  inst->selectable = 1;
#line 336
  return;
}
}
#line 340 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sources.c"
void SRC_UnsetSelectable(SRC_Instance inst ) 
{ 


  {
#line 343
  inst->selectable = 0;
#line 352
  if (inst->index == selected_source_index) {
    {
#line 353
    SRC_SelectSource((uint32_t )0);
    }
  }
#line 356
  return;
}
}
#line 360 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sources.c"
void SRC_UpdateReachability(SRC_Instance inst , int reachable ) 
{ 


  {
#line 363
  inst->reachability <<= 1;
#line 364
  inst->reachability |= ! (! reachable);
#line 365
  inst->reachability &= ~ (-1 << 8);
#line 368
  if (inst->reachability & (1 << 7)) {
#line 369
    inst->beginning = 0;
  }
#line 371
  if (! reachable) {
#line 371
    if (inst->index == selected_source_index) {
      {
#line 373
      SRC_SelectSource((uint32_t )0);
      }
    }
  }
#line 375
  return;
}
}
#line 379 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sources.c"
void SRC_ResetReachability(SRC_Instance inst ) 
{ 


  {
#line 388
  return;
}
}
#line 392 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sources.c"
static int compare_sort_elements(void const   *a , void const   *b ) 
{ 
  struct Sort_Element  const  *u ;
  struct Sort_Element  const  *v ;

  {
#line 395
  u = (struct Sort_Element  const  *)a;
#line 396
  v = (struct Sort_Element  const  *)b;
#line 398
  if (u->offset < v->offset) {
#line 399
    return (-1);
  } else
#line 400
  if (u->offset > v->offset) {
#line 401
    return (1);
  } else
#line 402
  if ((int const   )u->tag < (int const   )v->tag) {
#line 403
    return (-1);
  } else
#line 404
  if ((int const   )u->tag > (int const   )v->tag) {
#line 405
    return (1);
  } else {
#line 407
    return (0);
  }
}
}
#line 413 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sources.c"
static char *source_to_string(SRC_Instance inst ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 417
  if ((unsigned int )inst->type == 0U) {
#line 417
    goto case_0;
  }
#line 419
  if ((unsigned int )inst->type == 1U) {
#line 419
    goto case_1;
  }
#line 421
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 418
  tmp = UTI_IPToString(inst->ip_addr);
  }
#line 418
  return (tmp);
  case_1: /* CIL Label */ 
  {
#line 420
  tmp___0 = UTI_RefidToString(inst->ref_id);
  }
#line 420
  return (tmp___0);
  switch_default: /* CIL Label */ 
  {
#line 422
  __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sources.c",
                422U, "source_to_string");
  }
  switch_break: /* CIL Label */ ;
  }
#line 424
  return ((char *)((void *)0));
}
}
#line 429 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sources.c"
static int combine_sources(int n_sel_sources , struct timeval *ref_time , double *offset ,
                           double *offset_sd , double *frequency , double *skew ) 
{ 
  struct timeval src_ref_time ;
  double src_offset ;
  double src_offset_sd ;
  double src_frequency ;
  double src_skew ;
  double src_root_delay ;
  double src_root_dispersion ;
  double elapsed ;
  double offset_weight ;
  double sum_offset_weight ;
  double sum_offset ;
  double sum2_offset_sd ;
  double frequency_weight ;
  double sum_frequency_weight ;
  double sum_frequency ;
  double inv_sum2_skew ;
  int i ;
  int index___0 ;
  int combined ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;

  {
#line 440
  if (n_sel_sources == 1) {
#line 441
    return (1);
  }
#line 443
  sum2_offset_sd = 0.0;
#line 443
  sum_offset = sum2_offset_sd;
#line 443
  sum_offset_weight = sum_offset;
#line 444
  inv_sum2_skew = 0.0;
#line 444
  sum_frequency = inv_sum2_skew;
#line 444
  sum_frequency_weight = sum_frequency;
#line 446
  combined = 0;
#line 446
  i = combined;
  {
#line 446
  while (1) {
    while_continue: /* CIL Label */ ;
#line 446
    if (! (i < n_sel_sources)) {
#line 446
      goto while_break;
    }
    {
#line 447
    index___0 = *(sel_sources + i);
#line 448
    SST_GetTrackingData((*(sources + index___0))->stats, & src_ref_time, & src_offset,
                        & src_offset_sd, & src_frequency, & src_skew, & src_root_delay,
                        & src_root_dispersion);
    }
#line 457
    if (index___0 != selected_source_index) {
#line 457
      if ((*(sources + index___0))->sel_info.root_distance > combine_limit * (reselect_distance + (*(sources + selected_source_index))->sel_info.root_distance)) {
#line 457
        goto _L___0;
      } else {
        {
#line 457
        tmp = fabs(*frequency - src_frequency);
#line 457
        tmp___0 = LCL_GetMaxClockError();
        }
#line 457
        if (tmp > combine_limit * ((*skew + src_skew) + tmp___0)) {
          _L___0: /* CIL Label */ 
#line 462
          if (! (*(sources + index___0))->beginning) {
#line 462
            (*(sources + index___0))->outlier = 32;
          } else {
#line 462
            (*(sources + index___0))->outlier = 1;
          }
        } else {
#line 457
          goto _L;
        }
      }
    } else
    _L: /* CIL Label */ 
#line 463
    if ((*(sources + index___0))->outlier) {
#line 464
      ((*(sources + index___0))->outlier) --;
    }
#line 467
    if ((*(sources + index___0))->outlier) {
#line 468
      goto __Cont;
    }
    {
#line 470
    UTI_DiffTimevalsToDouble(& elapsed, ref_time, & src_ref_time);
#line 471
    src_offset += elapsed * src_frequency;
#line 472
    offset_weight = 1.0 / (*(sources + index___0))->sel_info.root_distance;
#line 473
    frequency_weight = 1.0 / src_skew;
#line 480
    sum_offset_weight += offset_weight;
#line 481
    sum_offset += offset_weight * src_offset;
#line 482
    sum2_offset_sd += offset_weight * (src_offset_sd * src_offset_sd + (src_offset - *offset) * (src_offset - *offset));
#line 485
    sum_frequency_weight += frequency_weight;
#line 486
    sum_frequency += frequency_weight * src_frequency;
#line 487
    inv_sum2_skew += 1.0 / (src_skew * src_skew);
#line 489
    combined ++;
    }
    __Cont: /* CIL Label */ 
#line 446
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 492
  if (! combined) {
    {
#line 492
    __assert_fail("combined", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sources.c",
                  492U, "combine_sources");
    }
  }
  {
#line 493
  *offset = sum_offset / sum_offset_weight;
#line 494
  *offset_sd = sqrt(sum2_offset_sd / sum_offset_weight);
#line 495
  *frequency = sum_frequency / sum_frequency_weight;
#line 496
  tmp___1 = sqrt(inv_sum2_skew);
#line 496
  *skew = 1.0 / tmp___1;
  }
#line 503
  return (combined);
}
}
#line 513 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sources.c"
void SRC_SelectSource(uint32_t match_refid ) 
{ 
  int i ;
  int j ;
  int index___0 ;
  int old_selected_index ;
  struct timeval now ;
  struct timeval ref_time ;
  double src_offset ;
  double src_offset_sd ;
  double src_frequency ;
  double src_skew ;
  double src_root_delay ;
  double src_root_dispersion ;
  int n_endpoints ;
  int j1___0 ;
  int j2 ;
  double best_lo ;
  double best_hi ;
  int depth ;
  int best_depth ;
  int n_sel_sources ;
  int combined ;
  double distance ;
  double sel_src_distance ;
  int stratum ;
  int min_stratum ;
  struct SelectInfo *si ;
  int n_badstats_sources ;
  int max_sel_reach ;
  int max_badstat_reach ;
  int max_score_index ;
  double max_score ;
  NTP_Leap leap_status ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
#line 532
  leap_status = (NTP_Leap )0;
#line 533
  old_selected_index = selected_source_index;
#line 535
  if (n_sources___1 == 0) {
#line 537
    if (selected_source_index != -1) {
      {
#line 538
      LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/sources.c",
                   538, "SRC_SelectSource");
#line 538
      LOG_Line_Function((LOG_Severity )0, (LOG_Facility )6, "Can\'t synchronise: no sources");
#line 539
      selected_source_index = -1;
#line 540
      REF_SetUnsynchronised();
      }
    }
#line 542
    return;
  }
  {
#line 546
  SCH_GetLastEventTime(& now, (double *)((void *)0), (struct timeval *)((void *)0));
#line 549
  n_endpoints = 0;
#line 550
  n_sel_sources = 0;
#line 551
  n_badstats_sources = 0;
#line 552
  max_badstat_reach = 0;
#line 552
  max_sel_reach = max_badstat_reach;
#line 553
  i = 0;
  }
  {
#line 553
  while (1) {
    while_continue: /* CIL Label */ ;
#line 553
    if (! (i < n_sources___1)) {
#line 553
      goto while_break;
    }
#line 555
    if ((*(sources + i))->selectable) {
#line 555
      if ((*(sources + i))->reachability) {
#line 555
        if ((unsigned int )(*(sources + i))->sel_option != 1U) {
          {
#line 558
          si = & (*(sources + i))->sel_info;
#line 559
          SST_GetSelectionData((*(sources + i))->stats, & now, & si->stratum, & si->lo_limit,
                               & si->hi_limit, & si->root_distance, & si->variance,
                               & si->select_ok);
          }
#line 574
          if (si->select_ok) {
#line 575
            n_sel_sources ++;
#line 577
            (*(sources + i))->status = (SRC_Status )0;
#line 581
            j1___0 = n_endpoints;
#line 582
            j2 = j1___0 + 1;
#line 584
            (sort_list + j1___0)->index = i;
#line 585
            (sort_list + j1___0)->offset = si->lo_limit;
#line 586
            (sort_list + j1___0)->tag = (enum __anonenum_tag_157 )-1;
#line 588
            (sort_list + j2)->index = i;
#line 589
            (sort_list + j2)->offset = si->hi_limit;
#line 590
            (sort_list + j2)->tag = (enum __anonenum_tag_157 )1;
#line 592
            n_endpoints += 2;
#line 594
            if (max_sel_reach < (*(sources + i))->reachability) {
#line 595
              max_sel_reach = (*(sources + i))->reachability;
            }
          } else {
#line 598
            n_badstats_sources ++;
#line 599
            (*(sources + i))->status = (SRC_Status )2;
#line 601
            if (max_badstat_reach < (*(sources + i))->reachability) {
#line 602
              max_badstat_reach = (*(sources + i))->reachability;
            }
          }
        } else {
#line 608
          (*(sources + i))->status = (SRC_Status )1;
        }
      } else {
#line 608
        (*(sources + i))->status = (SRC_Status )1;
      }
    } else {
#line 608
      (*(sources + i))->status = (SRC_Status )1;
    }
#line 553
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 623
  if (n_badstats_sources) {
#line 623
    if (n_sel_sources) {
#line 623
      if (selected_source_index == -1) {
#line 623
        if (max_sel_reach >> 1 == max_badstat_reach) {
#line 626
          return;
        }
      }
    }
  }
#line 634
  if (n_endpoints > 0) {
    {
#line 637
    qsort((void *)sort_list, (size_t )n_endpoints, sizeof(struct Sort_Element ), & compare_sort_elements);
#line 662
    best_depth = 0;
#line 662
    depth = best_depth;
#line 663
    best_hi = 0.0;
#line 663
    best_lo = best_hi;
#line 665
    i = 0;
    }
    {
#line 665
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 665
      if (! (i < n_endpoints)) {
#line 665
        goto while_break___0;
      }
      {
#line 671
      if ((int )(sort_list + i)->tag == -1) {
#line 671
        goto case_neg_1;
      }
#line 679
      if ((int )(sort_list + i)->tag == 0) {
#line 679
        goto case_0;
      }
#line 683
      if ((int )(sort_list + i)->tag == 1) {
#line 683
        goto case_1;
      }
#line 670
      goto switch_break;
      case_neg_1: /* CIL Label */ 
#line 672
      depth ++;
#line 673
      if (depth > best_depth) {
#line 674
        best_depth = depth;
#line 675
        best_lo = (sort_list + i)->offset;
      }
#line 677
      goto switch_break;
      case_0: /* CIL Label */ 
      {
#line 680
      __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sources.c",
                    680U, "SRC_SelectSource");
      }
#line 681
      goto switch_break;
      case_1: /* CIL Label */ 
#line 684
      if (depth == best_depth) {
#line 685
        best_hi = (sort_list + i)->offset;
      }
#line 687
      depth --;
#line 688
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 665
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 698
    if (best_depth <= n_sel_sources / 2) {
#line 710
      if (selected_source_index != -1) {
        {
#line 711
        LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/sources.c",
                     711, "SRC_SelectSource");
#line 711
        LOG_Line_Function((LOG_Severity )0, (LOG_Facility )6, "Can\'t synchronise: no majority");
        }
      }
#line 713
      selected_source_index = -1;
#line 718
      i = 0;
      {
#line 718
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 718
        if (! (i < n_sources___1)) {
#line 718
          goto while_break___1;
        }
#line 719
        (*(sources + i))->status = (SRC_Status )3;
#line 718
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {
#line 727
      n_sel_sources = 0;
#line 728
      i = 0;
      {
#line 728
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 728
        if (! (i < n_sources___1)) {
#line 728
          goto while_break___2;
        }
#line 729
        if ((unsigned int )(*(sources + i))->status == 0U) {
#line 734
          if ((*(sources + i))->sel_info.lo_limit <= best_lo) {
#line 734
            if ((*(sources + i))->sel_info.hi_limit >= best_hi) {
#line 739
              tmp = n_sel_sources;
#line 739
              n_sel_sources ++;
#line 739
              *(sel_sources + tmp) = i;
            } else {
#line 734
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 734
          if ((*(sources + i))->sel_info.lo_limit >= best_lo) {
#line 734
            if ((*(sources + i))->sel_info.hi_limit <= best_hi) {
#line 739
              tmp = n_sel_sources;
#line 739
              n_sel_sources ++;
#line 739
              *(sel_sources + tmp) = i;
            } else {
#line 744
              (*(sources + i))->status = (SRC_Status )3;
            }
          } else {
#line 744
            (*(sources + i))->status = (SRC_Status )3;
          }
        }
#line 728
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 788
      j = 0;
#line 788
      i = j;
      {
#line 788
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 788
        if (! (i < n_sel_sources)) {
#line 788
          goto while_break___3;
        }
#line 789
        index___0 = *(sel_sources + i);
#line 790
        if (index___0 != -1) {
#line 791
          (*(sources + index___0))->status = (SRC_Status )5;
#line 792
          tmp___0 = j;
#line 792
          j ++;
#line 792
          *(sel_sources + tmp___0) = *(sel_sources + i);
#line 793
          index___0 ++;
        }
#line 788
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 796
      n_sel_sources = j;
#line 798
      if (n_sel_sources > 0) {
#line 801
        j2 = 0;
#line 801
        j1___0 = j2;
#line 801
        i = j1___0;
        {
#line 801
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 801
          if (! (i < n_sel_sources)) {
#line 801
            goto while_break___4;
          }
#line 802
          index___0 = *(sel_sources + i);
#line 803
          if ((unsigned int )(*(sources + index___0))->leap_status == 1U) {
#line 804
            j1___0 ++;
          } else
#line 805
          if ((unsigned int )(*(sources + index___0))->leap_status == 2U) {
#line 806
            j2 ++;
          }
#line 801
          i ++;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 810
        if (j1___0 > n_sel_sources / 2) {
#line 811
          leap_status = (NTP_Leap )1;
        } else
#line 812
        if (j2 > n_sel_sources / 2) {
#line 813
          leap_status = (NTP_Leap )2;
        }
#line 818
        j = 0;
#line 818
        i = j;
        {
#line 818
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 818
          if (! (i < n_sel_sources)) {
#line 818
            goto while_break___5;
          }
#line 819
          if ((unsigned int )(*(sources + *(sel_sources + i)))->sel_option == 2U) {
#line 820
            tmp___1 = j;
#line 820
            j ++;
#line 820
            *(sel_sources + tmp___1) = *(sel_sources + i);
          }
#line 818
          i ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 823
        if (j > 0) {
#line 824
          n_sel_sources = j;
        }
#line 831
        index___0 = *(sel_sources + 0);
#line 832
        min_stratum = (*(sources + index___0))->sel_info.stratum;
#line 833
        i = 1;
        {
#line 833
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 833
          if (! (i < n_sel_sources)) {
#line 833
            goto while_break___6;
          }
#line 834
          index___0 = *(sel_sources + i);
#line 835
          stratum = (*(sources + index___0))->sel_info.stratum;
#line 836
          if (stratum < min_stratum) {
#line 836
            min_stratum = stratum;
          }
#line 833
          i ++;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 845
        max_score_index = -1;
#line 846
        max_score = 0.0;
#line 847
        sel_src_distance = 0.0;
#line 849
        if (selected_source_index != -1) {
#line 850
          sel_src_distance = (*(sources + selected_source_index))->sel_info.root_distance + (double )((*(sources + selected_source_index))->sel_info.stratum - min_stratum) * stratum_weight;
        }
#line 854
        i = 0;
        {
#line 854
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 854
          if (! (i < n_sources___1)) {
#line 854
            goto while_break___7;
          }
#line 857
          if ((unsigned int )(*(sources + i))->status != 5U) {
#line 858
            (*(sources + i))->sel_score = 1.0;
#line 859
            (*(sources + i))->outlier = 32;
#line 860
            goto __Cont;
          }
#line 863
          distance = (*(sources + i))->sel_info.root_distance + (double )((*(sources + i))->sel_info.stratum - min_stratum) * stratum_weight;
#line 865
          if ((unsigned int )(*(sources + i))->type == 0U) {
#line 866
            distance += reselect_distance;
          }
#line 868
          if (selected_source_index != -1) {
#line 872
            if ((*(sources + i))->ref_id == match_refid) {
#line 872
              goto _L___0;
            } else
#line 872
            if ((*(sources + selected_source_index))->ref_id == match_refid) {
              _L___0: /* CIL Label */ 
#line 875
              (*(sources + i))->sel_score *= sel_src_distance / distance;
#line 877
              if ((*(sources + i))->sel_score < 1.0) {
#line 878
                (*(sources + i))->sel_score = 1.0;
              }
            }
          } else {
#line 887
            (*(sources + i))->sel_score = 1.0 / distance;
          }
#line 895
          if (max_score < (*(sources + i))->sel_score) {
#line 896
            max_score = (*(sources + i))->sel_score;
#line 897
            max_score_index = i;
          }
          __Cont: /* CIL Label */ 
#line 854
          i ++;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 901
        if (! (max_score_index != -1)) {
          {
#line 901
          __assert_fail("max_score_index != (-1)", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sources.c",
                        901U, "SRC_SelectSource");
          }
        }
#line 906
        if (selected_source_index == -1) {
#line 906
          goto _L___1;
        } else
#line 906
        if ((unsigned int )(*(sources + selected_source_index))->status != 5U) {
#line 906
          goto _L___1;
        } else
#line 906
        if (max_score_index != selected_source_index) {
#line 906
          if (max_score > 10.0) {
            _L___1: /* CIL Label */ 
            {
#line 912
            selected_source_index = max_score_index;
#line 913
            LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/sources.c",
                         913, "SRC_SelectSource");
#line 913
            tmp___2 = source_to_string(*(sources + selected_source_index));
#line 913
            LOG_Line_Function((LOG_Severity )0, (LOG_Facility )6, "Selected source %s",
                              tmp___2);
#line 921
            i = 0;
            }
            {
#line 921
            while (1) {
              while_continue___8: /* CIL Label */ ;
#line 921
              if (! (i < n_sources___1)) {
#line 921
                goto while_break___8;
              }
#line 922
              (*(sources + i))->sel_score = 1.0;
#line 923
              (*(sources + i))->outlier = 0;
#line 921
              i ++;
            }
            while_break___8: /* CIL Label */ ;
            }
          }
        }
#line 927
        (*(sources + selected_source_index))->status = (SRC_Status )6;
#line 931
        if (selected_source_index != old_selected_index) {
          {
#line 937
          SST_GetTrackingData((*(sources + selected_source_index))->stats, & ref_time,
                              & src_offset, & src_offset_sd, & src_frequency, & src_skew,
                              & src_root_delay, & src_root_dispersion);
#line 942
          combined = combine_sources(n_sel_sources, & ref_time, & src_offset, & src_offset_sd,
                                     & src_frequency, & src_skew);
#line 945
          REF_SetReference((*(sources + selected_source_index))->sel_info.stratum,
                           leap_status, combined, (*(sources + selected_source_index))->ref_id,
                           (*(sources + selected_source_index))->ip_addr, & ref_time,
                           src_offset, src_offset_sd, src_frequency, src_skew, src_root_delay,
                           src_root_dispersion);
          }
        } else
#line 931
        if (match_refid == (*(sources + selected_source_index))->ref_id) {
          {
#line 937
          SST_GetTrackingData((*(sources + selected_source_index))->stats, & ref_time,
                              & src_offset, & src_offset_sd, & src_frequency, & src_skew,
                              & src_root_delay, & src_root_dispersion);
#line 942
          combined = combine_sources(n_sel_sources, & ref_time, & src_offset, & src_offset_sd,
                                     & src_frequency, & src_skew);
#line 945
          REF_SetReference((*(sources + selected_source_index))->sel_info.stratum,
                           leap_status, combined, (*(sources + selected_source_index))->ref_id,
                           (*(sources + selected_source_index))->ip_addr, & ref_time,
                           src_offset, src_offset_sd, src_frequency, src_skew, src_root_delay,
                           src_root_dispersion);
          }
        }
      } else {
#line 960
        if (selected_source_index != -1) {
          {
#line 961
          LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/sources.c",
                       961, "SRC_SelectSource");
#line 961
          LOG_Line_Function((LOG_Severity )0, (LOG_Facility )6, "Can\'t synchronise: no selectable sources");
          }
        }
#line 963
        selected_source_index = -1;
      }
    }
  } else {
#line 969
    if (selected_source_index != -1) {
      {
#line 970
      LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/sources.c",
                   970, "SRC_SelectSource");
#line 970
      LOG_Line_Function((LOG_Severity )0, (LOG_Facility )6, "Can\'t synchronise: no reachable sources");
      }
    }
#line 972
    selected_source_index = -1;
  }
#line 975
  if (selected_source_index == -1) {
#line 975
    if (selected_source_index != old_selected_index) {
      {
#line 977
      REF_SetUnsynchronised();
      }
    }
  }
#line 979
  return;
}
}
#line 984 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sources.c"
void SRC_ReselectSource(void) 
{ 


  {
  {
#line 987
  selected_source_index = -1;
#line 988
  SRC_SelectSource((uint32_t )0);
  }
#line 989
  return;
}
}
#line 993 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sources.c"
void SRC_SetReselectDistance(double distance ) 
{ 


  {
#line 996
  if (reselect_distance != distance) {
    {
#line 997
    reselect_distance = distance;
#line 998
    LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/sources.c",
                 998, "SRC_SetReselectDistance");
#line 998
    LOG_Line_Function((LOG_Severity )0, (LOG_Facility )6, "New reselect distance %f",
                      distance);
    }
  }
#line 1000
  return;
}
}
#line 1004 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sources.c"
double SRC_PredictOffset(SRC_Instance inst , struct timeval *when ) 
{ 
  double tmp ;

  {
  {
#line 1007
  tmp = SST_PredictOffset(inst->stats, when);
  }
#line 1007
  return (tmp);
}
}
#line 1012 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sources.c"
double SRC_MinRoundTripDelay(SRC_Instance inst ) 
{ 
  double tmp ;

  {
  {
#line 1015
  tmp = SST_MinRoundTripDelay(inst->stats);
  }
#line 1015
  return (tmp);
}
}
#line 1020 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sources.c"
int SRC_IsGoodSample(SRC_Instance inst , double offset , double delay , double max_delay_dev_ratio ,
                     double clock_error , struct timeval *when ) 
{ 
  int tmp ;

  {
  {
#line 1024
  tmp = SST_IsGoodSample(inst->stats, offset, delay, max_delay_dev_ratio, clock_error,
                         when);
  }
#line 1024
  return (tmp);
}
}
#line 1035 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sources.c"
static void slew_sources___0(struct timeval *raw , struct timeval *cooked , double dfreq ,
                             double doffset , int is_step_change , void *anything ) 
{ 
  int i ;

  {
#line 1045
  i = 0;
  {
#line 1045
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1045
    if (! (i < n_sources___1)) {
#line 1045
      goto while_break;
    }
    {
#line 1046
    SST_SlewSamples((*(sources + i))->stats, cooked, dfreq, doffset);
#line 1045
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1049
  return;
}
}
#line 1055 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sources.c"
static void add_dispersion___0(double dispersion , void *anything ) 
{ 
  int i ;

  {
#line 1060
  i = 0;
  {
#line 1060
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1060
    if (! (i < n_sources___1)) {
#line 1060
      goto while_break;
    }
    {
#line 1061
    SST_AddDispersion((*(sources + i))->stats, dispersion);
#line 1060
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1063
  return;
}
}
#line 1068 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sources.c"
void SRC_DumpSources(void) 
{ 
  FILE *out ;
  int direc_len ;
  int file_len ;
  char *filename___0 ;
  unsigned int a ;
  unsigned int b ;
  unsigned int c ;
  unsigned int d ;
  int i ;
  char *direc ;
  size_t tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1078
  direc = CNF_GetDumpDir();
#line 1079
  tmp = strlen((char const   *)direc);
#line 1079
  direc_len = (int )tmp;
#line 1080
  file_len = direc_len + 24;
#line 1081
  tmp___0 = malloc((unsigned long )file_len * sizeof(char ));
#line 1081
  filename___0 = (char *)tmp___0;
#line 1082
  tmp___1 = mkdir_and_parents((char const   *)direc);
  }
#line 1082
  if (tmp___1) {
#line 1083
    i = 0;
    {
#line 1083
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1083
      if (! (i < n_sources___1)) {
#line 1083
        goto while_break;
      }
      {
#line 1084
      a = (*(sources + i))->ref_id >> 24;
#line 1085
      b = ((*(sources + i))->ref_id >> 16) & 255U;
#line 1086
      c = ((*(sources + i))->ref_id >> 8) & 255U;
#line 1087
      d = (*(sources + i))->ref_id & 255U;
#line 1089
      snprintf((char */* __restrict  */)filename___0, (size_t )(file_len - 1), (char const   */* __restrict  */)"%s/%d.%d.%d.%d.dat",
               direc, a, b, c, d);
#line 1090
      out = fopen((char const   */* __restrict  */)filename___0, (char const   */* __restrict  */)"w");
      }
#line 1091
      if (! out) {
        {
#line 1092
        LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/sources.c",
                     1092, "SRC_DumpSources");
#line 1092
        LOG_Line_Function((LOG_Severity )1, (LOG_Facility )6, "Could not open dump file %s",
                          filename___0);
        }
      } else {
        {
#line 1094
        SST_SaveToFile((*(sources + i))->stats, out);
#line 1095
        fclose(out);
        }
      }
#line 1083
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 1099
    LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/sources.c",
                 1099, "SRC_DumpSources");
#line 1099
    LOG_Line_Function((LOG_Severity )2, (LOG_Facility )6, "Could not create directory %s",
                      direc);
    }
  }
  {
#line 1101
  free((void *)filename___0);
  }
#line 1102
  return;
}
}
#line 1106 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sources.c"
void SRC_ReloadSources(void) 
{ 
  FILE *in ;
  char *filename___0 ;
  unsigned int a ;
  unsigned int b ;
  unsigned int c ;
  unsigned int d ;
  int i ;
  char *dumpdir___0 ;
  int dumpdirlen ;
  int filelen ;
  size_t tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 1116
  i = 0;
  {
#line 1116
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1116
    if (! (i < n_sources___1)) {
#line 1116
      goto while_break;
    }
    {
#line 1117
    a = (*(sources + i))->ref_id >> 24;
#line 1118
    b = ((*(sources + i))->ref_id >> 16) & 255U;
#line 1119
    c = ((*(sources + i))->ref_id >> 8) & 255U;
#line 1120
    d = (*(sources + i))->ref_id & 255U;
#line 1122
    dumpdir___0 = CNF_GetDumpDir();
#line 1123
    tmp = strlen((char const   *)dumpdir___0);
#line 1123
    dumpdirlen = (int )tmp;
#line 1124
    filelen = dumpdirlen + 24;
#line 1125
    tmp___0 = malloc((unsigned long )filelen * sizeof(char ));
#line 1125
    filename___0 = (char *)tmp___0;
#line 1126
    snprintf((char */* __restrict  */)filename___0, (size_t )(filelen - 1), (char const   */* __restrict  */)"%s/%d.%d.%d.%d.dat",
             dumpdir___0, a, b, c, d);
#line 1127
    in = fopen((char const   */* __restrict  */)filename___0, (char const   */* __restrict  */)"r");
    }
#line 1128
    if (! in) {
      {
#line 1129
      LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/sources.c",
                   1129, "SRC_ReloadSources");
#line 1129
      LOG_Line_Function((LOG_Severity )1, (LOG_Facility )6, "Could not open dump file %s",
                        filename___0);
      }
    } else {
      {
#line 1131
      tmp___1 = SST_LoadFromFile((*(sources + i))->stats, in);
      }
#line 1131
      if (tmp___1) {
        {
#line 1132
        SST_DoNewRegression((*(sources + i))->stats);
        }
      } else {
        {
#line 1134
        LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/sources.c",
                     1134, "SRC_ReloadSources");
#line 1134
        LOG_Line_Function((LOG_Severity )1, (LOG_Facility )6, "Problem loading from file %s",
                          filename___0);
        }
      }
      {
#line 1136
      fclose(in);
      }
    }
    {
#line 1138
    free((void *)filename___0);
#line 1116
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1140
  return;
}
}
#line 1144 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sources.c"
int SRC_IsSyncPeer(SRC_Instance inst ) 
{ 


  {
#line 1147
  if (inst->index == selected_source_index) {
#line 1148
    return (1);
  } else {
#line 1150
    return (0);
  }
}
}
#line 1157 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sources.c"
int SRC_ReadNumberOfSources(void) 
{ 


  {
#line 1160
  return (n_sources___1);
}
}
#line 1165 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sources.c"
int SRC_ReportSource(int index___0 , RPT_SourceReport *report , struct timeval *now ) 
{ 
  SRC_Instance src ;

  {
#line 1169
  if (index___0 >= n_sources___1) {
#line 1170
    return (0);
  } else
#line 1169
  if (index___0 < 0) {
#line 1170
    return (0);
  } else {
    {
#line 1172
    src = *(sources + index___0);
#line 1174
    memset((void *)(& report->ip_addr), 0, sizeof(report->ip_addr));
    }
#line 1175
    if (src->ip_addr) {
#line 1176
      report->ip_addr = *(src->ip_addr);
    } else {
#line 1179
      report->ip_addr.addr.in4 = src->ref_id;
#line 1180
      report->ip_addr.family = (uint16_t )1;
    }
    {
#line 1184
    if ((unsigned int )src->status == 6U) {
#line 1184
      goto case_6;
    }
#line 1187
    if ((unsigned int )src->status == 4U) {
#line 1187
      goto case_4;
    }
#line 1192
    if ((unsigned int )src->status == 1U) {
#line 1192
      goto case_1;
    }
#line 1192
    if ((unsigned int )src->status == 2U) {
#line 1192
      goto case_1;
    }
#line 1192
    if ((unsigned int )src->status == 0U) {
#line 1192
      goto case_1;
    }
#line 1195
    if ((unsigned int )src->status == 3U) {
#line 1195
      goto case_3;
    }
#line 1198
    if ((unsigned int )src->status == 5U) {
#line 1198
      goto case_5;
    }
#line 1201
    goto switch_default;
    case_6: /* CIL Label */ 
#line 1185
    report->state = (enum __anonenum_state_81 )0;
#line 1186
    goto switch_break;
    case_4: /* CIL Label */ 
#line 1188
    report->state = (enum __anonenum_state_81 )3;
#line 1189
    goto switch_break;
    case_1: /* CIL Label */ 
    case_2: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 1193
    report->state = (enum __anonenum_state_81 )1;
#line 1194
    goto switch_break;
    case_3: /* CIL Label */ 
#line 1196
    report->state = (enum __anonenum_state_81 )2;
#line 1197
    goto switch_break;
    case_5: /* CIL Label */ 
#line 1199
    if (src->outlier) {
#line 1199
      report->state = (enum __anonenum_state_81 )5;
    } else {
#line 1199
      report->state = (enum __anonenum_state_81 )4;
    }
#line 1200
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1202
    __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sources.c",
                  1202U, "SRC_ReportSource");
    }
#line 1203
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 1207
    if ((unsigned int )src->sel_option == 0U) {
#line 1207
      goto case_0___0;
    }
#line 1210
    if ((unsigned int )src->sel_option == 2U) {
#line 1210
      goto case_2___0;
    }
#line 1213
    if ((unsigned int )src->sel_option == 1U) {
#line 1213
      goto case_1___0;
    }
#line 1216
    goto switch_default___0;
    case_0___0: /* CIL Label */ 
#line 1208
    report->sel_option = (enum __anonenum_sel_option_82 )2;
#line 1209
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
#line 1211
    report->sel_option = (enum __anonenum_sel_option_82 )1;
#line 1212
    goto switch_break___0;
    case_1___0: /* CIL Label */ 
#line 1214
    report->sel_option = (enum __anonenum_sel_option_82 )2;
#line 1215
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 1217
    __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sources.c",
                  1217U, "SRC_ReportSource");
    }
    switch_break___0: /* CIL Label */ ;
    }
    {
#line 1220
    report->reachability = src->reachability;
#line 1223
    SST_DoSourceReport(src->stats, report, now);
    }
#line 1225
    return (1);
  }
}
}
#line 1232 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sources.c"
int SRC_ReportSourcestats(int index___0 , RPT_SourcestatsReport *report , struct timeval *now ) 
{ 
  SRC_Instance src ;

  {
#line 1237
  if (index___0 >= n_sources___1) {
#line 1238
    return (0);
  } else
#line 1237
  if (index___0 < 0) {
#line 1238
    return (0);
  } else {
#line 1240
    src = *(sources + index___0);
#line 1241
    report->ref_id = src->ref_id;
#line 1242
    if (src->ip_addr) {
#line 1243
      report->ip_addr = *(src->ip_addr);
    } else {
#line 1245
      report->ip_addr.family = (uint16_t )0;
    }
    {
#line 1246
    SST_DoSourcestatsReport(src->stats, report, now);
    }
#line 1247
    return (1);
  }
}
}
#line 1253 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sources.c"
SRC_Type SRC_GetType(int index___0 ) 
{ 


  {
#line 1256
  if (index___0 >= n_sources___1) {
#line 1257
    return ((SRC_Type )-1);
  } else
#line 1256
  if (index___0 < 0) {
#line 1257
    return ((SRC_Type )-1);
  }
#line 1258
  return ((*(sources + index___0))->type);
}
}
#line 1263 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sources.c"
SRC_Skew_Direction SRC_LastSkewChange(SRC_Instance inst ) 
{ 
  SRC_Skew_Direction result ;
  SST_Skew_Direction tmp ;

  {
  {
#line 1265
  result = (SRC_Skew_Direction )1;
#line 1267
  tmp = SST_LastSkewChange(inst->stats);
  }
  {
#line 1268
  if ((unsigned int )tmp == 0U) {
#line 1268
    goto case_0;
  }
#line 1271
  if ((unsigned int )tmp == 1U) {
#line 1271
    goto case_1;
  }
#line 1274
  if ((unsigned int )tmp == 2U) {
#line 1274
    goto case_2;
  }
#line 1267
  goto switch_break;
  case_0: /* CIL Label */ 
#line 1269
  result = (SRC_Skew_Direction )0;
#line 1270
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1272
  result = (SRC_Skew_Direction )1;
#line 1273
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1275
  result = (SRC_Skew_Direction )2;
#line 1276
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1279
  return (result);
}
}
#line 1284 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sources.c"
int SRC_Samples(SRC_Instance inst ) 
{ 
  int tmp ;

  {
  {
#line 1287
  tmp = SST_Samples(inst->stats);
  }
#line 1287
  return (tmp);
}
}
#line 64 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.h"
int CNF_GetRTCSync(void) ;
#line 40 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc.c"
static int driver_initialised  =    0;
#line 42 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc.c"
static struct __anonstruct_driver_87 driver  = 
#line 42
     {& RTC_Linux_Initialise, & RTC_Linux_Finalise, & RTC_Linux_TimePreInit, & RTC_Linux_TimeInit,
    & RTC_Linux_StartMeasurements, & RTC_Linux_WriteParameters, & RTC_Linux_GetReport,
    & RTC_Linux_Trim};
#line 76 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc.c"
void RTC_Initialise(void) 
{ 
  char *file_name ;
  int ok ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 84
  file_name = CNF_GetRtcFile();
  }
#line 86
  if (file_name) {
    {
#line 87
    tmp = CNF_GetRTCSync();
    }
#line 87
    if (tmp) {
      {
#line 88
      LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc.c",
                   88, "RTC_Initialise");
#line 88
      LOG_Fatal_Function((LOG_Facility )17, "rtcfile directive cannot be used with rtcsync");
      }
    }
#line 91
    if (driver.init) {
      {
#line 92
      tmp___0 = (*(driver.init))();
      }
#line 92
      if (tmp___0) {
#line 93
        ok = 1;
      } else {
#line 95
        ok = 0;
      }
    } else {
#line 98
      ok = 0;
    }
#line 101
    if (ok) {
#line 102
      driver_initialised = 1;
    } else {
      {
#line 104
      driver_initialised = 0;
#line 105
      LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc.c",
                   105, "RTC_Initialise");
#line 105
      LOG_Line_Function((LOG_Severity )2, (LOG_Facility )17, "Real time clock not supported on this operating system");
      }
    }
  } else {
#line 109
    driver_initialised = 0;
  }
#line 111
  return;
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc.c"
void RTC_Finalise(void) 
{ 


  {
#line 118
  if (driver.fini) {
    {
#line 119
    (*(driver.fini))();
    }
  }
#line 121
  return;
}
}
#line 134 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc.c"
void RTC_TimeInit(void (*after_hook)(void * ) , void *anything ) 
{ 


  {
#line 137
  if (driver_initialised) {
    {
#line 138
    (*(driver.time_init))(after_hook, anything);
    }
  } else {
    {
#line 140
    LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc.c", 140,
                 "RTC_TimeInit");
#line 140
    LOG_Line_Function((LOG_Severity )2, (LOG_Facility )17, "Can\'t initialise from real time clock, driver not loaded");
#line 141
    (*after_hook)(anything);
    }
  }
#line 143
  return;
}
}
#line 149 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc.c"
void RTC_TimePreInit(void) 
{ 


  {
#line 152
  if (driver.time_pre_init) {
    {
#line 153
    (*(driver.time_pre_init))();
    }
  }
#line 155
  return;
}
}
#line 160 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc.c"
void RTC_StartMeasurements(void) 
{ 


  {
#line 163
  if (driver_initialised) {
    {
#line 164
    (*(driver.start_measurements))();
    }
  }
#line 167
  return;
}
}
#line 173 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc.c"
int RTC_WriteParameters(void) 
{ 
  int tmp ;

  {
#line 176
  if (driver_initialised) {
    {
#line 177
    tmp = (*(driver.write_parameters))();
    }
#line 177
    return (tmp);
  } else {
#line 179
    return (1);
  }
}
}
#line 185 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc.c"
int RTC_GetReport(RPT_RTC_Report *report ) 
{ 
  int tmp ;

  {
#line 188
  if (driver_initialised) {
    {
#line 189
    tmp = (*(driver.get_report))(report);
    }
#line 189
    return (tmp);
  } else {
#line 191
    return (0);
  }
}
}
#line 197 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/rtc.c"
int RTC_Trim(void) 
{ 
  int tmp ;

  {
#line 200
  if (driver_initialised) {
    {
#line 201
    tmp = (*(driver.trim))();
    }
#line 201
    return (tmp);
  } else {
#line 203
    return (0);
  }
}
}
#line 662 "/usr/include/netdb.h"
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
#line 668
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) freeaddrinfo)(struct addrinfo *__ai ) ;
#line 677
extern int getnameinfo(struct sockaddr  const  * __restrict  __sa , socklen_t __salen ,
                       char * __restrict  __host , socklen_t __hostlen , char * __restrict  __serv ,
                       socklen_t __servlen , int __flags ) ;
#line 273 "/usr/include/resolv.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) __res_init)(void) ;
#line 44 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/nameserv.h"
int DNS_IPAddress2Name(IPAddr *ip_addr , char *name , int len ) ;
#line 38 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/nameserv.c"
static int address_family  =    0;
#line 40 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/nameserv.c"
void DNS_SetAddressFamily(int family ) 
{ 


  {
#line 43
  address_family = family;
#line 44
  return;
}
}
#line 46 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/nameserv.c"
DNS_Status DNS_Name2IPAddress(char const   *name , IPAddr *addr ) 
{ 
  struct addrinfo hints ;
  struct addrinfo *res ;
  struct addrinfo *ai ;
  int result ;
  int tmp ;

  {
  {
#line 53
  memset((void *)(& hints), 0, sizeof(hints));
#line 54
  hints.ai_family = 0;
#line 55
  hints.ai_socktype = 1;
#line 57
  result = getaddrinfo((char const   */* __restrict  */)name, (char const   */* __restrict  */)((void *)0),
                       (struct addrinfo  const  */* __restrict  */)(& hints), (struct addrinfo **/* __restrict  */)(& res));
  }
#line 59
  if (result) {
#line 61
    return ((DNS_Status )1);
  }
#line 67
  ai = res;
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
#line 67
    if (! result) {
#line 67
      if (! ((unsigned long )ai != (unsigned long )((void *)0))) {
#line 67
        goto while_break;
      }
    } else {
#line 67
      goto while_break;
    }
    {
#line 69
    if (ai->ai_family == 2) {
#line 69
      goto case_2;
    }
#line 75
    if (ai->ai_family == 10) {
#line 75
      goto case_10;
    }
#line 68
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 70
    addr->family = (uint16_t )1;
#line 71
    addr->addr.in4 = ntohl(((struct sockaddr_in *)ai->ai_addr)->sin_addr.s_addr);
#line 72
    result = 1;
    }
#line 73
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 76
    addr->family = (uint16_t )2;
#line 77
    memcpy((void */* __restrict  */)(& addr->addr.in6), (void const   */* __restrict  */)(& ((struct sockaddr_in6 *)ai->ai_addr)->sin6_addr.__in6_u.__u6_addr8),
           sizeof(addr->addr.in6));
#line 78
    result = 1;
    }
#line 79
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 82
    if (result) {
#line 82
      if (address_family != 0) {
#line 82
        if (address_family != (int )addr->family) {
#line 83
          result = 0;
        }
      }
    }
#line 67
    ai = ai->ai_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 86
  freeaddrinfo(res);
  }
#line 87
  if (result) {
#line 87
    tmp = 0;
  } else {
#line 87
    tmp = 2;
  }
#line 87
  return ((DNS_Status )tmp);
}
}
#line 113 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/nameserv.c"
int DNS_IPAddress2Name(IPAddr *ip_addr , char *name , int len ) 
{ 
  char *result ;
  struct sockaddr_in in4 ;
  struct sockaddr_in6 in6 ;
  char hbuf[1025] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 116
  result = (char *)((void *)0);
  {
#line 124
  if ((int )ip_addr->family == 1) {
#line 124
    goto case_1;
  }
#line 134
  if ((int )ip_addr->family == 2) {
#line 134
    goto case_2;
  }
#line 123
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 125
  memset((void *)(& in4), 0, sizeof(in4));
#line 129
  in4.sin_family = (sa_family_t )2;
#line 130
  in4.sin_addr.s_addr = htonl(ip_addr->addr.in4);
#line 131
  tmp = getnameinfo((struct sockaddr  const  */* __restrict  */)((struct sockaddr  const  *)(& in4)),
                    (socklen_t )sizeof(in4), (char */* __restrict  */)(hbuf), (socklen_t )sizeof(hbuf),
                    (char */* __restrict  */)((void *)0), (socklen_t )0, 0);
  }
#line 131
  if (! tmp) {
#line 132
    result = hbuf;
  }
#line 133
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 135
  memset((void *)(& in6), 0, sizeof(in6));
#line 139
  in6.sin6_family = (sa_family_t )10;
#line 140
  memcpy((void */* __restrict  */)(& in6.sin6_addr.__in6_u.__u6_addr8), (void const   */* __restrict  */)(ip_addr->addr.in6),
         sizeof(in6.sin6_addr.__in6_u.__u6_addr8));
#line 141
  tmp___0 = getnameinfo((struct sockaddr  const  */* __restrict  */)((struct sockaddr  const  *)(& in6)),
                        (socklen_t )sizeof(in6), (char */* __restrict  */)(hbuf),
                        (socklen_t )sizeof(hbuf), (char */* __restrict  */)((void *)0),
                        (socklen_t )0, 0);
  }
#line 141
  if (! tmp___0) {
#line 142
    result = hbuf;
  }
#line 143
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 166
  if ((unsigned long )result == (unsigned long )((void *)0)) {
    {
#line 167
    result = UTI_IPToString(ip_addr);
    }
  }
  {
#line 168
  tmp___1 = snprintf((char */* __restrict  */)name, (size_t )len, (char const   */* __restrict  */)"%s",
                     result);
  }
#line 168
  if (tmp___1 >= len) {
#line 169
    return (0);
  }
#line 171
  return (1);
}
}
#line 176 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/nameserv.c"
void DNS_Reload(void) 
{ 


  {
  {
#line 179
  __res_init();
  }
#line 180
  return;
}
}
#line 709 "/usr/include/stdio.h"
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 755 "/usr/include/stdlib.h"
extern void *( __attribute__((__nonnull__(1,2,5))) bsearch)(void const   *__key ,
                                                            void const   *__base ,
                                                            size_t __nmemb , size_t __size ,
                                                            int (*__compar)(void const   * ,
                                                                            void const   * ) ) ;
#line 56 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.h"
char *CNF_GetKeysFile(void) ;
#line 58
unsigned long CNF_GetCommandKey(void) ;
#line 59
int CNF_GetGenerateCommandKey(void) ;
#line 113 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/util.h"
int UTI_GenerateNTPAuth(int hash_id , unsigned char const   *key , int key_len , unsigned char const   *data ,
                        int data_len , unsigned char *auth , int auth_len ) ;
#line 115
int UTI_CheckNTPAuth(int hash_id , unsigned char const   *key , int key_len , unsigned char const   *data ,
                     int data_len , unsigned char const   *auth , int auth_len ) ;
#line 119
int UTI_DecodePasswordFromText(char *key ) ;
#line 52 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/keys.c"
static int n_keys  ;
#line 53 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/keys.c"
static Key keys[256]  ;
#line 55 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/keys.c"
static int command_key_valid  ;
#line 56 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/keys.c"
static int command_key_id  ;
#line 57 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/keys.c"
static int cache_valid  ;
#line 58 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/keys.c"
static unsigned long cache_key_id  ;
#line 59 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/keys.c"
static int cache_key_pos  ;
#line 63 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/keys.c"
static int generate_key(unsigned long key_id ) 
{ 
  unsigned char key[16] ;
  char const   *hashname ;
  char const   *key_file ;
  char const   *rand_dev ;
  FILE *f ;
  struct stat st ;
  int i ;
  char *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 71
  hashname = "MD5";
#line 73
  rand_dev = "/dev/urandom";
#line 78
  tmp = CNF_GetKeysFile();
#line 78
  key_file = (char const   *)tmp;
  }
#line 80
  if (! key_file) {
#line 81
    return (0);
  }
  {
#line 83
  f = fopen((char const   */* __restrict  */)rand_dev, (char const   */* __restrict  */)"r");
  }
#line 84
  if (! f) {
#line 84
    goto _L;
  } else {
    {
#line 84
    tmp___0 = fread((void */* __restrict  */)(key), sizeof(key), (size_t )1, (FILE */* __restrict  */)f);
    }
#line 84
    if (tmp___0 != 1UL) {
      _L: /* CIL Label */ 
#line 85
      if (f) {
        {
#line 86
        fclose(f);
        }
      }
      {
#line 87
      LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/keys.c",
                   87, "generate_key");
#line 87
      LOG_Fatal_Function((LOG_Facility )15, "Could not read %s", rand_dev);
      }
#line 88
      return (0);
    }
  }
  {
#line 90
  fclose(f);
#line 92
  f = fopen((char const   */* __restrict  */)key_file, (char const   */* __restrict  */)"a");
  }
#line 93
  if (! f) {
    {
#line 94
    LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/keys.c", 94,
                 "generate_key");
#line 94
    LOG_Fatal_Function((LOG_Facility )15, "Could not open keyfile %s for writing",
                       key_file);
    }
#line 95
    return (0);
  }
  {
#line 99
  tmp___1 = stat((char const   */* __restrict  */)key_file, (struct stat */* __restrict  */)(& st));
  }
#line 99
  if (tmp___1) {
    {
#line 100
    fclose(f);
#line 101
    LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/keys.c", 101,
                 "generate_key");
#line 101
    LOG_Fatal_Function((LOG_Facility )15, "Could not change permissions of keyfile %s",
                       key_file);
    }
#line 102
    return (0);
  } else {
    {
#line 99
    tmp___2 = chmod(key_file, st.st_mode & 504U);
    }
#line 99
    if (tmp___2) {
      {
#line 100
      fclose(f);
#line 101
      LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/keys.c",
                   101, "generate_key");
#line 101
      LOG_Fatal_Function((LOG_Facility )15, "Could not change permissions of keyfile %s",
                         key_file);
      }
#line 102
      return (0);
    }
  }
  {
#line 105
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\n%lu %s HEX:",
          key_id, hashname);
#line 106
  i = 0;
  }
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
#line 106
    if (! ((unsigned long )i < sizeof(key))) {
#line 106
      goto while_break;
    }
    {
#line 107
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%02hhX",
            (int )key[i]);
#line 106
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 108
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\n");
#line 109
  fclose(f);
#line 112
  memset((void *)(key), 0, sizeof(key));
#line 114
  LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/keys.c", 114,
               "generate_key");
#line 114
  LOG_Line_Function((LOG_Severity )0, (LOG_Facility )15, "Generated key %lu", key_id);
  }
#line 116
  return (1);
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/keys.c"
void KEY_Initialise(void) 
{ 
  unsigned long tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned long tmp___2 ;
  int tmp___3 ;

  {
  {
#line 124
  n_keys = 0;
#line 125
  command_key_valid = 0;
#line 126
  cache_valid = 0;
#line 127
  KEY_Reload();
#line 129
  tmp___1 = CNF_GetGenerateCommandKey();
  }
#line 129
  if (tmp___1) {
    {
#line 129
    tmp___2 = KEY_GetCommandKey();
#line 129
    tmp___3 = KEY_KeyKnown(tmp___2);
    }
#line 129
    if (! tmp___3) {
      {
#line 130
      tmp = KEY_GetCommandKey();
#line 130
      tmp___0 = generate_key(tmp);
      }
#line 130
      if (tmp___0) {
        {
#line 131
        KEY_Reload();
        }
      }
    }
  }
#line 133
  return;
}
}
#line 137 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/keys.c"
void KEY_Finalise(void) 
{ 


  {
#line 140
  return;
}
}
#line 144 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/keys.c"
static int determine_hash_delay(int key_id ) 
{ 
  NTP_Packet pkt ;
  struct timeval before ;
  struct timeval after ;
  unsigned long usecs ;
  unsigned long min_usecs ;
  int i ;

  {
#line 149
  min_usecs = 0UL;
#line 152
  i = 0;
  {
#line 152
  while (1) {
    while_continue: /* CIL Label */ ;
#line 152
    if (! (i < 10)) {
#line 152
      goto while_break;
    }
    {
#line 153
    LCL_ReadRawTime(& before);
#line 154
    KEY_GenerateAuth((unsigned long )key_id, (unsigned char const   *)((unsigned char *)(& pkt)),
                     (int )((unsigned long )(& ((NTP_Packet *)0)->auth_keyid)), (unsigned char *)(& pkt.auth_data),
                     (int )sizeof(pkt.auth_data));
#line 156
    LCL_ReadRawTime(& after);
#line 158
    usecs = (unsigned long )((after.tv_sec - before.tv_sec) * 1000000L + (after.tv_usec - before.tv_usec));
    }
#line 160
    if (i == 0) {
#line 161
      min_usecs = usecs;
    } else
#line 160
    if (usecs < min_usecs) {
#line 161
      min_usecs = usecs;
    }
#line 152
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 170
  return ((int )(min_usecs + (min_usecs >> 4)));
}
}
#line 177 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/keys.c"
static int compare_keys_by_id(void const   *a , void const   *b ) 
{ 
  Key const   *c ;
  Key const   *d ;

  {
#line 180
  c = (Key const   *)a;
#line 181
  d = (Key const   *)b;
#line 183
  if (c->id < d->id) {
#line 184
    return (-1);
  } else
#line 185
  if (c->id > d->id) {
#line 186
    return (1);
  } else {
#line 188
    return (0);
  }
}
}
#line 195 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/keys.c"
void KEY_Reload(void) 
{ 
  int i ;
  int line_number___0 ;
  FILE *in ;
  unsigned long key_id ;
  char line___0[2048] ;
  char *keyval ;
  char *key_file ;
  char const   *hashname ;
  int tmp ;
  void *tmp___0 ;
  char *tmp___1 ;

  {
#line 204
  i = 0;
  {
#line 204
  while (1) {
    while_continue: /* CIL Label */ ;
#line 204
    if (! (i < n_keys)) {
#line 204
      goto while_break;
    }
    {
#line 205
    free((void *)keys[i].val);
#line 204
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 207
  n_keys = 0;
#line 208
  command_key_valid = 0;
#line 209
  cache_valid = 0;
#line 211
  key_file = CNF_GetKeysFile();
#line 212
  line_number___0 = 0;
  }
#line 214
  if (! key_file) {
#line 215
    return;
  }
  {
#line 217
  in = fopen((char const   */* __restrict  */)key_file, (char const   */* __restrict  */)"r");
  }
#line 218
  if (! in) {
    {
#line 219
    LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/keys.c", 219,
                 "KEY_Reload");
#line 219
    LOG_Line_Function((LOG_Severity )1, (LOG_Facility )15, "Could not open keyfile %s",
                      key_file);
    }
#line 220
    return;
  }
  {
#line 223
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 223
    tmp___1 = fgets((char */* __restrict  */)(line___0), (int )sizeof(line___0), (FILE */* __restrict  */)in);
    }
#line 223
    if (! tmp___1) {
#line 223
      goto while_break___0;
    }
    {
#line 224
    line_number___0 ++;
#line 226
    CPS_NormalizeLine(line___0);
    }
#line 227
    if (! line___0[0]) {
#line 228
      goto while_continue___0;
    }
    {
#line 230
    tmp = CPS_ParseKey(line___0, & key_id, & hashname, & keyval);
    }
#line 230
    if (! tmp) {
      {
#line 231
      LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/keys.c",
                   231, "KEY_Reload");
#line 231
      LOG_Line_Function((LOG_Severity )1, (LOG_Facility )15, "Could not parse key at line %d in file %s",
                        line_number___0, key_file);
      }
#line 232
      goto while_continue___0;
    }
    {
#line 235
    keys[n_keys].hash_id = HSH_GetHashId(hashname);
    }
#line 236
    if (keys[n_keys].hash_id < 0) {
      {
#line 237
      LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/keys.c",
                   237, "KEY_Reload");
#line 237
      LOG_Line_Function((LOG_Severity )1, (LOG_Facility )15, "Unknown hash function in key %lu",
                        key_id);
      }
#line 238
      goto while_continue___0;
    }
    {
#line 241
    keys[n_keys].len = UTI_DecodePasswordFromText(keyval);
    }
#line 242
    if (! keys[n_keys].len) {
      {
#line 243
      LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/keys.c",
                   243, "KEY_Reload");
#line 243
      LOG_Line_Function((LOG_Severity )1, (LOG_Facility )15, "Could not decode password in key %lu",
                        key_id);
      }
#line 244
      goto while_continue___0;
    }
    {
#line 247
    keys[n_keys].id = key_id;
#line 248
    tmp___0 = malloc((unsigned long )keys[n_keys].len * sizeof(char ));
#line 248
    keys[n_keys].val = (char *)tmp___0;
#line 249
    memcpy((void */* __restrict  */)keys[n_keys].val, (void const   */* __restrict  */)keyval,
           (size_t )keys[n_keys].len);
#line 250
    n_keys ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 253
  fclose(in);
#line 258
  qsort((void *)(keys), (size_t )n_keys, sizeof(Key ), & compare_keys_by_id);
#line 261
  i = 1;
  }
  {
#line 261
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 261
    if (! (i < n_keys)) {
#line 261
      goto while_break___1;
    }
#line 262
    if (keys[i - 1].id == keys[i].id) {
      {
#line 263
      LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/keys.c",
                   263, "KEY_Reload");
#line 263
      LOG_Line_Function((LOG_Severity )1, (LOG_Facility )15, "Detected duplicate key %lu",
                        key_id);
      }
    }
#line 261
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 268
  memset((void *)(line___0), 0, sizeof(line___0));
#line 270
  i = 0;
  }
  {
#line 270
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 270
    if (! (i < n_keys)) {
#line 270
      goto while_break___2;
    }
    {
#line 271
    keys[i].auth_delay = determine_hash_delay((int )keys[i].id);
#line 270
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 273
  return;
}
}
#line 277 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/keys.c"
static int lookup_key(unsigned long id ) 
{ 
  Key specimen ;
  Key *where ;
  int pos ;
  void *tmp ;

  {
  {
#line 283
  specimen.id = id;
#line 284
  tmp = bsearch((void const   *)((void *)(& specimen)), (void const   *)((void *)(keys)),
                (size_t )n_keys, sizeof(Key ), & compare_keys_by_id);
#line 284
  where = (Key *)tmp;
  }
#line 285
  if (! where) {
#line 286
    return (-1);
  } else {
#line 288
    pos = (int )(where - keys);
#line 289
    return (pos);
  }
}
}
#line 295 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/keys.c"
static int get_key_pos(unsigned long key_id ) 
{ 


  {
#line 298
  if (! cache_valid) {
    {
#line 299
    cache_valid = 1;
#line 300
    cache_key_pos = lookup_key(key_id);
#line 301
    cache_key_id = key_id;
    }
  } else
#line 298
  if (key_id != cache_key_id) {
    {
#line 299
    cache_valid = 1;
#line 300
    cache_key_pos = lookup_key(key_id);
#line 301
    cache_key_id = key_id;
    }
  }
#line 304
  return (cache_key_pos);
}
}
#line 309 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/keys.c"
unsigned long KEY_GetCommandKey(void) 
{ 
  unsigned long tmp ;

  {
#line 312
  if (! command_key_valid) {
    {
#line 313
    tmp = CNF_GetCommandKey();
#line 313
    command_key_id = (int )tmp;
    }
  }
#line 316
  return ((unsigned long )command_key_id);
}
}
#line 321 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/keys.c"
int KEY_KeyKnown(unsigned long key_id ) 
{ 
  int position ;

  {
#line 326
  if (cache_valid) {
#line 326
    if (key_id == cache_key_id) {
#line 327
      return (1);
    } else {
#line 326
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 330
    position = lookup_key(key_id);
    }
#line 332
    if (position >= 0) {
#line 335
      cache_valid = 1;
#line 336
      cache_key_pos = position;
#line 337
      cache_key_id = key_id;
#line 338
      return (1);
    } else {
#line 340
      return (0);
    }
  }
}
}
#line 347 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/keys.c"
int KEY_GetAuthDelay(unsigned long key_id ) 
{ 
  int key_pos ;

  {
  {
#line 352
  key_pos = get_key_pos(key_id);
  }
#line 354
  if (key_pos < 0) {
#line 355
    return (0);
  }
#line 358
  return (keys[key_pos].auth_delay);
}
}
#line 363 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/keys.c"
int KEY_GenerateAuth(unsigned long key_id , unsigned char const   *data , int data_len ,
                     unsigned char *auth , int auth_len ) 
{ 
  int key_pos ;
  int tmp ;

  {
  {
#line 369
  key_pos = get_key_pos(key_id);
  }
#line 371
  if (key_pos < 0) {
#line 372
    return (0);
  }
  {
#line 375
  tmp = UTI_GenerateNTPAuth(keys[key_pos].hash_id, (unsigned char const   *)((unsigned char *)keys[key_pos].val),
                            keys[key_pos].len, data, data_len, auth, auth_len);
  }
#line 375
  return (tmp);
}
}
#line 382 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/keys.c"
int KEY_CheckAuth(unsigned long key_id , unsigned char const   *data , int data_len ,
                  unsigned char const   *auth , int auth_len ) 
{ 
  int key_pos ;
  int tmp ;

  {
  {
#line 388
  key_pos = get_key_pos(key_id);
  }
#line 390
  if (key_pos < 0) {
#line 391
    return (0);
  }
  {
#line 394
  tmp = UTI_CheckNTPAuth(keys[key_pos].hash_id, (unsigned char const   *)((unsigned char *)keys[key_pos].val),
                         keys[key_pos].len, data, data_len, auth, auth_len);
  }
#line 394
  return (tmp);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 242 "/usr/include/stdio.h"
extern int fflush(FILE *__stream ) ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 390
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 858
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 175 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void closelog(void) ;
#line 181
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 190
extern void ( /* format attribute */  syslog)(int __pri , char const   *__fmt  , ...) ;
#line 205 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) strftime)(char * __restrict  __s ,
                                                                                  size_t __maxsize ,
                                                                                  char const   * __restrict  __format ,
                                                                                  struct tm  const  * __restrict  __tp ) ;
#line 366 "/usr/include/unistd.h"
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 47 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.h"
char *CNF_GetLogDir(void) ;
#line 49
int CNF_GetLogBanner(void) ;
#line 39 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/logging.c"
static int initialised___3  =    0;
#line 41 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/logging.c"
static int system_log  =    0;
#line 43 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/logging.c"
static int parent_fd  =    0;
#line 45 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/logging.c"
static time_t last_limited  =    (time_t )0;
#line 58 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/logging.c"
static int n_filelogs  =    0;
#line 63 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/logging.c"
static struct LogFile logfiles[6]  ;
#line 68 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/logging.c"
void LOG_Initialise(void) 
{ 


  {
#line 71
  initialised___3 = 1;
#line 76
  return;
}
}
#line 81 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/logging.c"
void LOG_Finalise(void) 
{ 


  {
#line 89
  if (system_log) {
    {
#line 90
    closelog();
    }
  }
  {
#line 94
  LOG_CycleLogFiles();
#line 96
  initialised___3 = 0;
  }
#line 97
  return;
}
}
#line 101 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/logging.c"
void LOG_Line_Function(LOG_Severity severity , LOG_Facility facility , char const   *format 
                       , ...) 
{ 
  char buf[2048] ;
  va_list other_args ;

  {
  {
#line 106
  __builtin_va_start(other_args, format);
#line 107
  vsnprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)format,
            other_args);
#line 108
  __builtin_va_end(other_args);
  }
#line 114
  if (system_log) {
    {
#line 116
    if ((unsigned int )severity == 0U) {
#line 116
      goto case_0;
    }
#line 119
    if ((unsigned int )severity == 1U) {
#line 119
      goto case_1;
    }
#line 123
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 117
    syslog(6, "%s", buf);
    }
#line 118
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 120
    syslog(4, "%s", buf);
    }
#line 121
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 124
    syslog(3, "%s", buf);
    }
#line 125
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  } else {
    {
#line 128
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
            buf);
    }
  }
#line 131
  return;
}
}
#line 135 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/logging.c"
void LOG_Fatal_Function(LOG_Facility facility , char const   *format  , ...) 
{ 
  char buf[2048] ;
  va_list other_args ;
  size_t tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 140
  __builtin_va_start(other_args, format);
#line 141
  vsnprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)format,
            other_args);
#line 142
  __builtin_va_end(other_args);
  }
#line 149
  if (system_log) {
    {
#line 150
    syslog(2, "Fatal error : %s", buf);
    }
  } else {
    {
#line 152
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Fatal error : %s\n",
            buf);
    }
  }
#line 154
  if (parent_fd) {
    {
#line 155
    tmp = strlen((char const   *)(buf));
#line 155
    tmp___0 = write(parent_fd, (void const   *)(buf), tmp + 1UL);
    }
  }
  {
#line 160
  exit(1);
  }
}
}
#line 165 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/logging.c"
void LOG_Position(char const   *filename___0 , int line_number___0 , char const   *function_name ) 
{ 
  time_t t ;
  struct tm stm ;
  char buf[64] ;
  struct tm *tmp ;

  {
#line 173
  if (! system_log) {
    {
#line 175
    time(& t);
#line 176
    tmp = gmtime((time_t const   *)(& t));
#line 176
    stm = *tmp;
#line 177
    strftime((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%d-%H:%M:%S",
             (struct tm  const  */* __restrict  */)(& stm));
#line 178
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d:(%s)[%s] ",
            filename___0, line_number___0, function_name, buf);
    }
  }
#line 181
  return;
}
}
#line 185 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/logging.c"
void LOG_OpenSystemLog(void) 
{ 


  {
  {
#line 190
  system_log = 1;
#line 191
  openlog("chronyd", 1, 3 << 3);
  }
#line 193
  return;
}
}
#line 197 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/logging.c"
void LOG_SetParentFd(int fd___0 ) 
{ 


  {
#line 200
  parent_fd = fd___0;
#line 201
  return;
}
}
#line 205 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/logging.c"
void LOG_CloseParentFd(void) 
{ 


  {
#line 208
  if (parent_fd > 0) {
    {
#line 209
    close(parent_fd);
    }
  }
#line 210
  return;
}
}
#line 214 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/logging.c"
int LOG_RateLimited(void) 
{ 
  time_t now ;

  {
  {
#line 219
  now = time((time_t *)((void *)0));
  }
#line 221
  if (last_limited + 10L > now) {
#line 221
    if (last_limited <= now) {
#line 222
      return (1);
    }
  }
#line 224
  last_limited = now;
#line 225
  return (0);
}
}
#line 230 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/logging.c"
LOG_FileID LOG_FileOpen(char const   *name , char const   *banner ) 
{ 
  int tmp ;

  {
#line 233
  if (! (n_filelogs < 6)) {
    {
#line 233
    __assert_fail("n_filelogs < 6", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/logging.c",
                  233U, "LOG_FileOpen");
    }
  }
#line 235
  logfiles[n_filelogs].name = name;
#line 236
  logfiles[n_filelogs].banner = banner;
#line 237
  logfiles[n_filelogs].file = (FILE *)((void *)0);
#line 238
  logfiles[n_filelogs].writes = 0UL;
#line 240
  tmp = n_filelogs;
#line 240
  n_filelogs ++;
#line 240
  return (tmp);
}
}
#line 245 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/logging.c"
void LOG_FileWrite(LOG_FileID id , char const   *format  , ...) 
{ 
  va_list other_args ;
  int banner ;
  char filename___0[512] ;
  char *tmp ;
  int tmp___0 ;
  FILE *tmp___1 ;
  int tmp___2 ;
  char bannerline[256] ;
  int i ;
  int bannerlen ;
  size_t tmp___3 ;
  unsigned long tmp___4 ;

  {
#line 251
  if (id < 0) {
#line 252
    return;
  } else
#line 251
  if (id >= n_filelogs) {
#line 252
    return;
  } else
#line 251
  if (! logfiles[id].name) {
#line 252
    return;
  }
#line 254
  if (! logfiles[id].file) {
    {
#line 257
    tmp = CNF_GetLogDir();
#line 257
    tmp___0 = snprintf((char */* __restrict  */)(filename___0), sizeof(filename___0),
                       (char const   */* __restrict  */)"%s/%s.log", tmp, logfiles[id].name);
    }
#line 257
    if ((unsigned long )tmp___0 >= sizeof(filename___0)) {
      {
#line 260
      LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/logging.c",
                   260, "LOG_FileWrite");
#line 260
      LOG_Line_Function((LOG_Severity )1, (LOG_Facility )26, "Couldn\'t open logfile %s for update",
                        filename___0);
#line 261
      logfiles[id].name = (char const   *)((void *)0);
      }
#line 262
      return;
    } else {
      {
#line 257
      tmp___1 = fopen((char const   */* __restrict  */)(filename___0), (char const   */* __restrict  */)"a");
#line 257
      logfiles[id].file = tmp___1;
      }
#line 257
      if (! tmp___1) {
        {
#line 260
        LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/logging.c",
                     260, "LOG_FileWrite");
#line 260
        LOG_Line_Function((LOG_Severity )1, (LOG_Facility )26, "Couldn\'t open logfile %s for update",
                          filename___0);
#line 261
        logfiles[id].name = (char const   *)((void *)0);
        }
#line 262
        return;
      }
    }
    {
#line 266
    tmp___2 = fileno(logfiles[id].file);
#line 266
    UTI_FdSetCloexec(tmp___2);
    }
  }
  {
#line 269
  banner = CNF_GetLogBanner();
  }
#line 270
  if (banner) {
#line 270
    tmp___4 = logfiles[id].writes;
#line 270
    (logfiles[id].writes) ++;
#line 270
    if (tmp___4 % (unsigned long )banner == 0UL) {
      {
#line 274
      tmp___3 = strlen(logfiles[id].banner);
#line 274
      bannerlen = (int )tmp___3;
#line 276
      i = 0;
      }
      {
#line 276
      while (1) {
        while_continue: /* CIL Label */ ;
#line 276
        if (! (i < bannerlen)) {
#line 276
          goto while_break;
        }
#line 277
        bannerline[i] = (char )'=';
#line 276
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 278
      bannerline[i] = (char )'\000';
#line 280
      fprintf((FILE */* __restrict  */)logfiles[id].file, (char const   */* __restrict  */)"%s\n",
              bannerline);
#line 281
      fprintf((FILE */* __restrict  */)logfiles[id].file, (char const   */* __restrict  */)"%s\n",
              logfiles[id].banner);
#line 282
      fprintf((FILE */* __restrict  */)logfiles[id].file, (char const   */* __restrict  */)"%s\n",
              bannerline);
      }
    }
  }
  {
#line 285
  __builtin_va_start(other_args, format);
#line 286
  vfprintf((FILE */* __restrict  */)logfiles[id].file, (char const   */* __restrict  */)format,
           other_args);
#line 287
  __builtin_va_end(other_args);
#line 288
  fprintf((FILE */* __restrict  */)logfiles[id].file, (char const   */* __restrict  */)"\n");
#line 290
  fflush(logfiles[id].file);
  }
#line 291
  return;
}
}
#line 295 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/logging.c"
void LOG_CreateLogFileDir(void) 
{ 
  char const   *logdir___0 ;
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 300
  tmp = CNF_GetLogDir();
#line 300
  logdir___0 = (char const   *)tmp;
#line 302
  tmp___0 = mkdir_and_parents(logdir___0);
  }
#line 302
  if (! tmp___0) {
    {
#line 303
    LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/logging.c",
                 303, "LOG_CreateLogFileDir");
#line 303
    LOG_Line_Function((LOG_Severity )2, (LOG_Facility )16, "Could not create directory %s",
                      logdir___0);
    }
  }
#line 305
  return;
}
}
#line 309 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/logging.c"
void LOG_CycleLogFiles(void) 
{ 
  LOG_FileID i ;

  {
#line 314
  i = 0;
  {
#line 314
  while (1) {
    while_continue: /* CIL Label */ ;
#line 314
    if (! (i < n_filelogs)) {
#line 314
      goto while_break;
    }
#line 315
    if (logfiles[i].file) {
      {
#line 316
      fclose(logfiles[i].file);
      }
    }
#line 317
    logfiles[i].file = (FILE *)((void *)0);
#line 318
    logfiles[i].writes = 0UL;
#line 314
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 320
  return;
}
}
#line 81 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.h"
double CNF_GetMaxClockError(void) ;
#line 128 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/local.h"
void LCL_SetAbsoluteFrequency(double afreq_ppm ) ;
#line 153
void LCL_ApplyStepOffset(double offset ) ;
#line 157
void LCL_NotifyExternalTimeStep(struct timeval *raw , struct timeval *cooked , double offset ,
                                double dispersion ) ;
#line 162
void LCL_AccumulateFrequencyAndOffset(double dfreq , double doffset , double corr_rate ) ;
#line 191
void LCL_SetLeap(int leap ) ;
#line 198
double LCL_SetTempComp(double comp ) ;
#line 60 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/localp.h"
void lcl_InvokeDispersionNotifyHandlers(double dispersion ) ;
#line 62
void lcl_RegisterSystemDrivers(double (*read_freq)(void) , double (*set_freq)(double freq_ppm ) ,
                               void (*accrue_offset___0)(double offset , double corr_rate ) ,
                               void (*apply_step_offset___0)(double offset ) , void (*offset_convert)(struct timeval *raw ,
                                                                                                      double *corr ,
                                                                                                      double *err ) ,
                               void (*set_leap___0)(int leap ) ) ;
#line 45 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/local.c"
static double current_freq_ppm  ;
#line 48 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/local.c"
static double temp_comp_ppm  ;
#line 53 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/local.c"
static double (*drv_read_freq)(void)  ;
#line 54 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/local.c"
static double (*drv_set_freq)(double freq_ppm )  ;
#line 55 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/local.c"
static void (*drv_accrue_offset)(double offset , double corr_rate )  ;
#line 56 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/local.c"
static void (*drv_apply_step_offset)(double offset )  ;
#line 57 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/local.c"
static void (*drv_offset_convert)(struct timeval *raw , double *corr , double *err )  ;
#line 58 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/local.c"
static void (*drv_set_leap)(int leap )  ;
#line 72 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/local.c"
static ChangeListEntry change_list  ;
#line 86 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/local.c"
static DispersionNotifyListEntry dispersion_notify_list  ;
#line 90 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/local.c"
static int precision_log  ;
#line 91 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/local.c"
static double precision_quantum  ;
#line 93 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/local.c"
static double max_clock_error  ;
#line 104 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/local.c"
static void calculate_sys_precision(void) 
{ 
  struct timeval tv ;
  struct timeval old_tv ;
  int dusec ;
  int best_dusec ;
  int iters ;

  {
  {
#line 111
  gettimeofday((struct timeval */* __restrict  */)(& old_tv), (__timezone_ptr_t )((void *)0));
#line 112
  best_dusec = 1000000;
#line 113
  iters = 0;
  }
  {
#line 114
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 115
    gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )((void *)0));
#line 116
    dusec = (int )(1000000L * (tv.tv_sec - old_tv.tv_sec) + (tv.tv_usec - old_tv.tv_usec));
#line 117
    old_tv = tv;
    }
#line 118
    if (dusec > 0) {
#line 119
      if (dusec < best_dusec) {
#line 120
        best_dusec = dusec;
      }
#line 122
      iters ++;
    }
#line 114
    if (! (iters < 100)) {
#line 114
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 126
  if (! (best_dusec > 0)) {
    {
#line 126
    __assert_fail("best_dusec > 0", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/local.c",
                  126U, "calculate_sys_precision");
    }
  }
#line 128
  precision_quantum = (double )best_dusec * 1.0e-6;
#line 129
  precision_log = 0;
  {
#line 130
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 130
    if (! (best_dusec < 500000)) {
#line 130
      goto while_break___0;
    }
#line 131
    precision_log --;
#line 132
    best_dusec *= 2;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 134
  return;
}
}
#line 138 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/local.c"
void LCL_Initialise(void) 
{ 
  double tmp ;

  {
  {
#line 141
  change_list.prev = & change_list;
#line 141
  change_list.next = change_list.prev;
#line 143
  dispersion_notify_list.prev = & dispersion_notify_list;
#line 143
  dispersion_notify_list.next = dispersion_notify_list.prev;
#line 148
  drv_read_freq = (double (*)(void))((void *)0);
#line 149
  drv_set_freq = (double (*)(double freq_ppm ))((void *)0);
#line 150
  drv_accrue_offset = (void (*)(double offset , double corr_rate ))((void *)0);
#line 151
  drv_offset_convert = (void (*)(struct timeval *raw , double *corr , double *err ))((void *)0);
#line 154
  current_freq_ppm = 0.0;
#line 155
  temp_comp_ppm = 0.0;
#line 157
  calculate_sys_precision();
#line 159
  tmp = CNF_GetMaxClockError();
#line 159
  max_clock_error = tmp * 1e-6;
  }
#line 160
  return;
}
}
#line 164 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/local.c"
void LCL_Finalise(void) 
{ 


  {
#line 167
  return;
}
}
#line 172 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/local.c"
int LCL_GetSysPrecisionAsLog(void) 
{ 


  {
#line 175
  return (precision_log);
}
}
#line 181 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/local.c"
double LCL_GetSysPrecisionAsQuantum(void) 
{ 


  {
#line 184
  return (precision_quantum);
}
}
#line 189 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/local.c"
double LCL_GetMaxClockError(void) 
{ 


  {
#line 192
  return (max_clock_error);
}
}
#line 197 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/local.c"
void LCL_AddParameterChangeHandler(void (*handler)(struct timeval *raw , struct timeval *cooked ,
                                                   double dfreq , double doffset ,
                                                   int is_step_change , void *anything ) ,
                                   void *anything ) 
{ 
  ChangeListEntry *ptr ;
  ChangeListEntry *new_entry ;
  void *tmp ;

  {
#line 203
  ptr = change_list.next;
  {
#line 203
  while (1) {
    while_continue: /* CIL Label */ ;
#line 203
    if (! ((unsigned long )ptr != (unsigned long )(& change_list))) {
#line 203
      goto while_break;
    }
#line 204
    if (! ((unsigned long )ptr->handler != (unsigned long )handler)) {
#line 204
      if (! ((unsigned long )ptr->anything != (unsigned long )anything)) {
        {
#line 205
        __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/local.c",
                      205U, "LCL_AddParameterChangeHandler");
        }
      }
    }
#line 203
    ptr = ptr->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 209
  tmp = malloc(sizeof(ChangeListEntry ));
#line 209
  new_entry = (ChangeListEntry *)tmp;
#line 211
  new_entry->handler = handler;
#line 212
  new_entry->anything = anything;
#line 215
  new_entry->next = & change_list;
#line 216
  new_entry->prev = change_list.prev;
#line 217
  (change_list.prev)->next = new_entry;
#line 218
  change_list.prev = new_entry;
  }
#line 219
  return;
}
}
#line 224 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/local.c"
void LCL_RemoveParameterChangeHandler(void (*handler)(struct timeval *raw , struct timeval *cooked ,
                                                      double dfreq , double doffset ,
                                                      int is_step_change , void *anything ) ,
                                      void *anything ) 
{ 
  ChangeListEntry *ptr ;
  int ok ;

  {
#line 230
  ptr = (ChangeListEntry *)((void *)0);
#line 231
  ok = 0;
#line 233
  ptr = change_list.next;
  {
#line 233
  while (1) {
    while_continue: /* CIL Label */ ;
#line 233
    if (! ((unsigned long )ptr != (unsigned long )(& change_list))) {
#line 233
      goto while_break;
    }
#line 234
    if ((unsigned long )ptr->handler == (unsigned long )handler) {
#line 234
      if ((unsigned long )ptr->anything == (unsigned long )anything) {
#line 235
        ok = 1;
#line 236
        goto while_break;
      }
    }
#line 233
    ptr = ptr->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 240
  if (! ok) {
    {
#line 240
    __assert_fail("ok", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/local.c",
                  240U, "LCL_RemoveParameterChangeHandler");
    }
  }
  {
#line 243
  (ptr->next)->prev = ptr->prev;
#line 244
  (ptr->prev)->next = ptr->next;
#line 246
  free((void *)ptr);
  }
#line 247
  return;
}
}
#line 251 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/local.c"
void LCL_AddDispersionNotifyHandler(void (*handler)(double dispersion , void *anything ) ,
                                    void *anything ) 
{ 
  DispersionNotifyListEntry *ptr ;
  DispersionNotifyListEntry *new_entry ;
  void *tmp ;

  {
#line 257
  ptr = dispersion_notify_list.next;
  {
#line 257
  while (1) {
    while_continue: /* CIL Label */ ;
#line 257
    if (! ((unsigned long )ptr != (unsigned long )(& dispersion_notify_list))) {
#line 257
      goto while_break;
    }
#line 258
    if (! ((unsigned long )ptr->handler != (unsigned long )handler)) {
#line 258
      if (! ((unsigned long )ptr->anything != (unsigned long )anything)) {
        {
#line 259
        __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/local.c",
                      259U, "LCL_AddDispersionNotifyHandler");
        }
      }
    }
#line 257
    ptr = ptr->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 263
  tmp = malloc(sizeof(DispersionNotifyListEntry ));
#line 263
  new_entry = (DispersionNotifyListEntry *)tmp;
#line 265
  new_entry->handler = handler;
#line 266
  new_entry->anything = anything;
#line 269
  new_entry->next = & dispersion_notify_list;
#line 270
  new_entry->prev = dispersion_notify_list.prev;
#line 271
  (dispersion_notify_list.prev)->next = new_entry;
#line 272
  dispersion_notify_list.prev = new_entry;
  }
#line 273
  return;
}
}
#line 278 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/local.c"
extern void LCL_RemoveDispersionNotifyHandler(void (*handler)(double dispersion ,
                                                              void *anything ) , void *anything ) 
{ 
  DispersionNotifyListEntry *ptr ;
  int ok ;

  {
#line 285
  ptr = (DispersionNotifyListEntry *)((void *)0);
#line 286
  ok = 0;
#line 288
  ptr = dispersion_notify_list.next;
  {
#line 288
  while (1) {
    while_continue: /* CIL Label */ ;
#line 288
    if (! ((unsigned long )ptr != (unsigned long )(& dispersion_notify_list))) {
#line 288
      goto while_break;
    }
#line 289
    if ((unsigned long )ptr->handler == (unsigned long )handler) {
#line 289
      if ((unsigned long )ptr->anything == (unsigned long )anything) {
#line 290
        ok = 1;
#line 291
        goto while_break;
      }
    }
#line 288
    ptr = ptr->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 295
  if (! ok) {
    {
#line 295
    __assert_fail("ok", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/local.c",
                  295U, "LCL_RemoveDispersionNotifyHandler");
    }
  }
  {
#line 298
  (ptr->next)->prev = ptr->prev;
#line 299
  (ptr->prev)->next = ptr->next;
#line 301
  free((void *)ptr);
  }
#line 302
  return;
}
}
#line 308 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/local.c"
void LCL_ReadRawTime(struct timeval *result ) 
{ 
  int tmp ;

  {
  {
#line 311
  tmp = gettimeofday((struct timeval */* __restrict  */)result, (__timezone_ptr_t )((void *)0));
  }
#line 311
  if (tmp < 0) {
    {
#line 312
    LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/local.c",
                 312, "LCL_ReadRawTime");
#line 312
    LOG_Fatal_Function((LOG_Facility )7, "gettimeofday() failed");
    }
  }
#line 314
  return;
}
}
#line 318 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/local.c"
void LCL_ReadCookedTime(struct timeval *result , double *err ) 
{ 
  struct timeval raw ;

  {
  {
#line 323
  LCL_ReadRawTime(& raw);
#line 324
  LCL_CookTime(& raw, result, err);
  }
#line 325
  return;
}
}
#line 329 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/local.c"
void LCL_CookTime(struct timeval *raw , struct timeval *cooked , double *err ) 
{ 
  double correction ;

  {
  {
#line 334
  LCL_GetOffsetCorrection(raw, & correction, err);
#line 335
  UTI_AddDoubleToTimeval(raw, correction, cooked);
  }
#line 336
  return;
}
}
#line 340 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/local.c"
void LCL_GetOffsetCorrection(struct timeval *raw , double *correction , double *err ) 
{ 


  {
  {
#line 344
  (*drv_offset_convert)(raw, correction, err);
  }
#line 345
  return;
}
}
#line 350 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/local.c"
double LCL_ReadAbsoluteFrequency(void) 
{ 
  double freq ;

  {
#line 355
  freq = current_freq_ppm;
#line 358
  if (temp_comp_ppm != 0.0) {
#line 359
    freq = (freq + temp_comp_ppm) / (1.0 - 1.0e-6 * temp_comp_ppm);
  }
#line 362
  return (freq);
}
}
#line 369 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/local.c"
void LCL_SetAbsoluteFrequency(double afreq_ppm ) 
{ 
  ChangeListEntry *ptr ;
  struct timeval raw ;
  struct timeval cooked ;
  double dfreq ;

  {
#line 377
  if (temp_comp_ppm != 0.0) {
#line 378
    afreq_ppm = afreq_ppm * (1.0 - 1.0e-6 * temp_comp_ppm) - temp_comp_ppm;
  }
  {
#line 383
  afreq_ppm = (*drv_set_freq)(afreq_ppm);
#line 385
  dfreq = (afreq_ppm - current_freq_ppm) / (1.0e6 + current_freq_ppm);
#line 387
  LCL_ReadRawTime(& raw);
#line 388
  LCL_CookTime(& raw, & cooked, (double *)((void *)0));
#line 391
  ptr = change_list.next;
  }
  {
#line 391
  while (1) {
    while_continue: /* CIL Label */ ;
#line 391
    if (! ((unsigned long )ptr != (unsigned long )(& change_list))) {
#line 391
      goto while_break;
    }
    {
#line 392
    (*(ptr->handler))(& raw, & cooked, dfreq, 0.0, 0, ptr->anything);
#line 391
    ptr = ptr->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 395
  current_freq_ppm = afreq_ppm;
#line 397
  return;
}
}
#line 401 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/local.c"
void LCL_AccumulateDeltaFrequency(double dfreq ) 
{ 
  ChangeListEntry *ptr ;
  struct timeval raw ;
  struct timeval cooked ;
  double old_freq_ppm ;

  {
  {
#line 408
  old_freq_ppm = current_freq_ppm;
#line 414
  current_freq_ppm = (1.0 + dfreq) * current_freq_ppm + 1.0e6 * dfreq;
#line 417
  current_freq_ppm = (*drv_set_freq)(current_freq_ppm);
#line 418
  dfreq = (current_freq_ppm - old_freq_ppm) / (1.0e6 + old_freq_ppm);
#line 420
  LCL_ReadRawTime(& raw);
#line 421
  LCL_CookTime(& raw, & cooked, (double *)((void *)0));
#line 424
  ptr = change_list.next;
  }
  {
#line 424
  while (1) {
    while_continue: /* CIL Label */ ;
#line 424
    if (! ((unsigned long )ptr != (unsigned long )(& change_list))) {
#line 424
      goto while_break;
    }
    {
#line 425
    (*(ptr->handler))(& raw, & cooked, dfreq, 0.0, 0, ptr->anything);
#line 424
    ptr = ptr->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 428
  return;
}
}
#line 432 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/local.c"
void LCL_AccumulateOffset(double offset , double corr_rate ) 
{ 
  ChangeListEntry *ptr ;
  struct timeval raw ;
  struct timeval cooked ;

  {
  {
#line 441
  LCL_ReadRawTime(& raw);
#line 442
  LCL_CookTime(& raw, & cooked, (double *)((void *)0));
#line 444
  (*drv_accrue_offset)(offset, corr_rate);
#line 447
  ptr = change_list.next;
  }
  {
#line 447
  while (1) {
    while_continue: /* CIL Label */ ;
#line 447
    if (! ((unsigned long )ptr != (unsigned long )(& change_list))) {
#line 447
      goto while_break;
    }
    {
#line 448
    (*(ptr->handler))(& raw, & cooked, 0.0, offset, 0, ptr->anything);
#line 447
    ptr = ptr->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 451
  return;
}
}
#line 455 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/local.c"
void LCL_ApplyStepOffset(double offset ) 
{ 
  ChangeListEntry *ptr ;
  struct timeval raw ;
  struct timeval cooked ;

  {
  {
#line 464
  LCL_ReadRawTime(& raw);
#line 465
  LCL_CookTime(& raw, & cooked, (double *)((void *)0));
#line 467
  (*drv_apply_step_offset)(offset);
#line 470
  ptr = change_list.next;
  }
  {
#line 470
  while (1) {
    while_continue: /* CIL Label */ ;
#line 470
    if (! ((unsigned long )ptr != (unsigned long )(& change_list))) {
#line 470
      goto while_break;
    }
    {
#line 471
    (*(ptr->handler))(& raw, & cooked, 0.0, offset, 1, ptr->anything);
#line 470
    ptr = ptr->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 474
  return;
}
}
#line 478 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/local.c"
void LCL_NotifyExternalTimeStep(struct timeval *raw , struct timeval *cooked , double offset ,
                                double dispersion ) 
{ 
  ChangeListEntry *ptr ;

  {
#line 485
  ptr = change_list.next;
  {
#line 485
  while (1) {
    while_continue: /* CIL Label */ ;
#line 485
    if (! ((unsigned long )ptr != (unsigned long )(& change_list))) {
#line 485
      goto while_break;
    }
    {
#line 486
    (*(ptr->handler))(raw, cooked, 0.0, offset, 1, ptr->anything);
#line 485
    ptr = ptr->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 489
  lcl_InvokeDispersionNotifyHandlers(dispersion);
  }
#line 490
  return;
}
}
#line 494 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/local.c"
void LCL_AccumulateFrequencyAndOffset(double dfreq , double doffset , double corr_rate ) 
{ 
  ChangeListEntry *ptr ;
  struct timeval raw ;
  struct timeval cooked ;
  double old_freq_ppm ;

  {
  {
#line 501
  LCL_ReadRawTime(& raw);
#line 504
  LCL_CookTime(& raw, & cooked, (double *)((void *)0));
#line 506
  old_freq_ppm = current_freq_ppm;
#line 511
  current_freq_ppm = (1.0 + dfreq) * old_freq_ppm + 1.0e6 * dfreq;
#line 519
  current_freq_ppm = (*drv_set_freq)(current_freq_ppm);
#line 520
  dfreq = (current_freq_ppm - old_freq_ppm) / (1.0e6 + old_freq_ppm);
#line 522
  (*drv_accrue_offset)(doffset, corr_rate);
#line 525
  ptr = change_list.next;
  }
  {
#line 525
  while (1) {
    while_continue: /* CIL Label */ ;
#line 525
    if (! ((unsigned long )ptr != (unsigned long )(& change_list))) {
#line 525
      goto while_break;
    }
    {
#line 526
    (*(ptr->handler))(& raw, & cooked, dfreq, doffset, 0, ptr->anything);
#line 525
    ptr = ptr->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 530
  return;
}
}
#line 534 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/local.c"
void lcl_InvokeDispersionNotifyHandlers(double dispersion ) 
{ 
  DispersionNotifyListEntry *ptr ;

  {
#line 539
  ptr = dispersion_notify_list.next;
  {
#line 539
  while (1) {
    while_continue: /* CIL Label */ ;
#line 539
    if (! ((unsigned long )ptr != (unsigned long )(& dispersion_notify_list))) {
#line 539
      goto while_break;
    }
    {
#line 540
    (*(ptr->handler))(dispersion, ptr->anything);
#line 539
    ptr = ptr->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 543
  return;
}
}
#line 547 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/local.c"
void lcl_RegisterSystemDrivers(double (*read_freq)(void) , double (*set_freq)(double freq_ppm ) ,
                               void (*accrue_offset___0)(double offset , double corr_rate ) ,
                               void (*apply_step_offset___0)(double offset ) , void (*offset_convert)(struct timeval *raw ,
                                                                                                      double *corr ,
                                                                                                      double *err ) ,
                               void (*set_leap___0)(int leap ) ) 
{ 


  {
  {
#line 555
  drv_read_freq = read_freq;
#line 556
  drv_set_freq = set_freq;
#line 557
  drv_accrue_offset = accrue_offset___0;
#line 558
  drv_apply_step_offset = apply_step_offset___0;
#line 559
  drv_offset_convert = offset_convert;
#line 560
  drv_set_leap = set_leap___0;
#line 562
  current_freq_ppm = (*drv_read_freq)();
  }
#line 567
  return;
}
}
#line 573 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/local.c"
int LCL_MakeStep(double threshold ) 
{ 
  struct timeval raw ;
  double correction ;
  double tmp ;

  {
  {
#line 579
  LCL_ReadRawTime(& raw);
#line 580
  LCL_GetOffsetCorrection(& raw, & correction, (double *)((void *)0));
#line 582
  tmp = fabs(correction);
  }
#line 582
  if (tmp <= threshold) {
#line 583
    return (0);
  }
  {
#line 586
  LCL_AccumulateOffset(correction, 0.0);
#line 587
  LCL_ApplyStepOffset(- correction);
#line 589
  LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/local.c", 589,
               "LCL_MakeStep");
#line 589
  LOG_Line_Function((LOG_Severity )1, (LOG_Facility )7, "System clock was stepped by %.3f seconds",
                    correction);
  }
#line 591
  return (1);
}
}
#line 596 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/local.c"
void LCL_SetLeap(int leap ) 
{ 


  {
#line 599
  if (drv_set_leap) {
    {
#line 600
    (*drv_set_leap)(leap);
    }
  }
#line 602
  return;
}
}
#line 606 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/local.c"
double LCL_SetTempComp(double comp ) 
{ 
  double uncomp_freq_ppm ;

  {
#line 611
  if (temp_comp_ppm == comp) {
#line 612
    return (comp);
  }
  {
#line 615
  current_freq_ppm = (current_freq_ppm + temp_comp_ppm) / (1.0 - 1.0e-6 * temp_comp_ppm);
#line 618
  uncomp_freq_ppm = current_freq_ppm;
#line 621
  current_freq_ppm = current_freq_ppm * (1.0 - 1.0e-6 * comp) - comp;
#line 624
  current_freq_ppm = (*drv_set_freq)(current_freq_ppm);
#line 626
  temp_comp_ppm = (uncomp_freq_ppm - current_freq_ppm) / (1.0e-6 * uncomp_freq_ppm + 1.0);
  }
#line 629
  return (temp_comp_ppm);
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/regress.h"
double RGR_GetTCoef(int dof ) ;
#line 72
int RGR_FindBestRegression(double *x , double *y , double *w , int n , int m , int min_samples___1 ,
                           double *b0 , double *b1 , double *s2 , double *sb0 , double *sb1 ,
                           int *new_start , int *n_runs___0 , int *dof ) ;
#line 39 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/regress.c"
void RGR_WeightedRegression(double *x , double *y , double *w , int n , double *b0 ,
                            double *b1 , double *s2 , double *sb0 , double *sb1 ) 
{ 
  double P ;
  double Q ;
  double U ;
  double V ;
  double W ;
  double diff ;
  double u ;
  double ui ;
  double aa ;
  int i ;

  {
#line 67
  if (! (n >= 3)) {
    {
#line 67
    __assert_fail("n >= 3", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/regress.c",
                  67U, "RGR_WeightedRegression");
    }
  }
#line 69
  U = (double )0;
#line 69
  W = U;
#line 70
  i = 0;
  {
#line 70
  while (1) {
    while_continue: /* CIL Label */ ;
#line 70
    if (! (i < n)) {
#line 70
      goto while_break;
    }
#line 71
    U += *(x + i) / *(w + i);
#line 72
    W += 1.0 / *(w + i);
#line 70
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 75
  u = U / W;
#line 78
  V = 0.0;
#line 78
  Q = V;
#line 78
  P = Q;
#line 79
  i = 0;
  {
#line 79
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 79
    if (! (i < n)) {
#line 79
      goto while_break___0;
    }
#line 80
    ui = *(x + i) - u;
#line 81
    P += *(y + i) / *(w + i);
#line 82
    Q += (*(y + i) * ui) / *(w + i);
#line 83
    V += (ui * ui) / *(w + i);
#line 79
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 86
  *b1 = Q / V;
#line 87
  *b0 = P / W - *b1 * u;
#line 89
  *s2 = 0.0;
#line 90
  i = 0;
  {
#line 90
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 90
    if (! (i < n)) {
#line 90
      goto while_break___1;
    }
#line 91
    diff = (*(y + i) - *b0) - *b1 * *(x + i);
#line 92
    *s2 += (diff * diff) / *(w + i);
#line 90
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 95
  *s2 /= (double )(n - 2);
#line 97
  *sb1 = sqrt(*s2 / V);
#line 98
  aa = u * *sb1;
#line 99
  *sb0 = sqrt(*s2 / W + aa * aa);
#line 101
  *s2 *= (double )n / W;
  }
#line 102
  return;
}
}
#line 112 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/regress.c"
static double coefs[40]  = 
#line 112
  {      636.6,      31.6,      12.92,      8.61, 
        6.869,      5.959,      5.408,      5.041, 
        4.781,      4.587,      4.437,      4.318, 
        4.221,      4.140,      4.073,      4.015, 
        3.965,      3.922,      3.883,      3.850, 
        3.819,      3.792,      3.768,      3.745, 
        3.725,      3.707,      3.690,      3.674, 
        3.659,      3.646,      3.633,      3.622, 
        3.611,      3.601,      3.591,      3.582, 
        3.574,      3.566,      3.558,      3.551};
#line 108 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/regress.c"
double RGR_GetTCoef(int dof ) 
{ 


  {
#line 122
  if (dof <= 40) {
#line 123
    return (coefs[dof - 1]);
  } else {
#line 125
    return (3.5);
  }
}
}
#line 135 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/regress.c"
static double coefs___0[64]  = 
#line 135
  {      2.706,      4.605,      6.251,      7.779, 
        9.236,      10.645,      12.017,      13.362, 
        14.684,      15.987,      17.275,      18.549, 
        19.812,      21.064,      22.307,      23.542, 
        24.769,      25.989,      27.204,      28.412, 
        29.615,      30.813,      32.007,      33.196, 
        34.382,      35.563,      36.741,      37.916, 
        39.087,      40.256,      41.422,      42.585, 
        43.745,      44.903,      46.059,      47.212, 
        48.363,      49.513,      50.660,      51.805, 
        52.949,      54.090,      55.230,      56.369, 
        57.505,      58.641,      59.774,      60.907, 
        62.038,      63.167,      64.295,      65.422, 
        66.548,      67.673,      68.796,      69.919, 
        71.040,      72.160,      73.279,      74.397, 
        75.514,      76.630,      77.745,      78.860};
#line 132 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/regress.c"
double RGR_GetChi2Coef(int dof ) 
{ 


  {
#line 146
  if (dof <= 64) {
#line 147
    return (coefs___0[dof - 1]);
  } else {
#line 149
    return (1.2 * (double )dof);
  }
}
}
#line 171 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/regress.c"
static char critical_runs[130]  = 
#line 171
  {      (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)2,      (char)3,      (char)3,      (char)3, 
        (char)4,      (char)4,      (char)5,      (char)5, 
        (char)5,      (char)6,      (char)6,      (char)7, 
        (char)7,      (char)7,      (char)8,      (char)8, 
        (char)9,      (char)9,      (char)9,      (char)10, 
        (char)10,      (char)11,      (char)11,      (char)11, 
        (char)12,      (char)12,      (char)13,      (char)13, 
        (char)14,      (char)14,      (char)14,      (char)15, 
        (char)15,      (char)16,      (char)16,      (char)17, 
        (char)17,      (char)18,      (char)18,      (char)18, 
        (char)19,      (char)19,      (char)20,      (char)20, 
        (char)21,      (char)21,      (char)21,      (char)22, 
        (char)22,      (char)23,      (char)23,      (char)24, 
        (char)24,      (char)25,      (char)25,      (char)26, 
        (char)26,      (char)26,      (char)27,      (char)27, 
        (char)28,      (char)28,      (char)29,      (char)29, 
        (char)30,      (char)30,      (char)30,      (char)31, 
        (char)31,      (char)32,      (char)32,      (char)33, 
        (char)33,      (char)34,      (char)34,      (char)35, 
        (char)35,      (char)35,      (char)36,      (char)36, 
        (char)37,      (char)37,      (char)38,      (char)38, 
        (char)39,      (char)39,      (char)40,      (char)40, 
        (char)40,      (char)41,      (char)41,      (char)42, 
        (char)42,      (char)43,      (char)43,      (char)44, 
        (char)44,      (char)45,      (char)45,      (char)46, 
        (char)46,      (char)46,      (char)47,      (char)47, 
        (char)48,      (char)48,      (char)49,      (char)49, 
        (char)50,      (char)50,      (char)51,      (char)51, 
        (char)52,      (char)52,      (char)52,      (char)53, 
        (char)53,      (char)54,      (char)54,      (char)55, 
        (char)55,      (char)56};
#line 189 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/regress.c"
static int n_runs_from_residuals(double *resid , int n ) 
{ 
  int nruns ;
  int i ;

  {
#line 195
  nruns = 1;
#line 196
  i = 1;
  {
#line 196
  while (1) {
    while_continue: /* CIL Label */ ;
#line 196
    if (! (i < n)) {
#line 196
      goto while_break;
    }
#line 197
    if (*(resid + (i - 1)) < 0.0) {
#line 197
      if (! (*(resid + i) < 0.0)) {
#line 197
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 197
    if (*(resid + (i - 1)) > 0.0) {
#line 197
      if (! (*(resid + i) > 0.0)) {
#line 201
        nruns ++;
      }
    } else {
#line 201
      nruns ++;
    }
#line 196
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 205
  return (nruns);
}
}
#line 214 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/regress.c"
int RGR_FindBestRegression(double *x , double *y , double *w , int n , int m , int min_samples___1 ,
                           double *b0 , double *b1 , double *s2 , double *sb0 , double *sb1 ,
                           int *new_start , int *n_runs___0 , int *dof ) 
{ 
  double P ;
  double Q ;
  double U ;
  double V ;
  double W ;
  double resid[256] ;
  double ss ;
  double a ;
  double b ;
  double u ;
  double ui ;
  double aa ;
  int start ;
  int resid_start ;
  int nruns ;
  int npoints ;
  int i ;

  {
#line 258
  if (! (n <= 128)) {
    {
#line 258
    __assert_fail("n <= 128", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/regress.c",
                  258U, "RGR_FindBestRegression");
    }
  }
#line 259
  if (! ((unsigned long )(n * 2) < sizeof(critical_runs) / sizeof(critical_runs[0]))) {
    {
#line 259
    __assert_fail("n * 2 < sizeof (critical_runs) / sizeof (critical_runs[0])", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/regress.c",
                  259U, "RGR_FindBestRegression");
    }
  }
#line 261
  if (n < 3) {
#line 262
    return (0);
  }
#line 265
  start = 0;
  {
#line 266
  while (1) {
    while_continue: /* CIL Label */ ;
#line 268
    U = (double )0;
#line 268
    W = U;
#line 269
    i = start;
    {
#line 269
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 269
      if (! (i < n)) {
#line 269
        goto while_break___0;
      }
#line 270
      U += *(x + i) / *(w + i);
#line 271
      W += 1.0 / *(w + i);
#line 269
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 274
    u = U / W;
#line 276
    V = 0.0;
#line 276
    Q = V;
#line 276
    P = Q;
#line 277
    i = start;
    {
#line 277
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 277
      if (! (i < n)) {
#line 277
        goto while_break___1;
      }
#line 278
      ui = *(x + i) - u;
#line 279
      P += *(y + i) / *(w + i);
#line 280
      Q += (*(y + i) * ui) / *(w + i);
#line 281
      V += (ui * ui) / *(w + i);
#line 277
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 284
    b = Q / V;
#line 285
    a = P / W - b * u;
#line 288
    resid_start = n - (n - start) * 2;
#line 289
    if (resid_start < - m) {
#line 290
      resid_start = - m;
    }
#line 292
    i = resid_start;
    {
#line 292
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 292
      if (! (i < n)) {
#line 292
        goto while_break___2;
      }
#line 293
      resid[i - resid_start] = (*(y + i) - a) - b * *(x + i);
#line 292
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 297
    nruns = n_runs_from_residuals(resid, n - resid_start);
    }
#line 299
    if (nruns > (int )critical_runs[n - resid_start]) {
#line 299
      goto _L;
    } else
#line 299
    if (n - start <= 3) {
#line 299
      goto _L;
    } else
#line 299
    if (n - start <= min_samples___1) {
      _L: /* CIL Label */ 
#line 302
      if (start != resid_start) {
        {
#line 304
        nruns = n_runs_from_residuals((resid - resid_start) + start, n - start);
        }
      }
#line 306
      goto while_break;
    } else {
#line 309
      start ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 315
  *b1 = b;
#line 316
  *b0 = a;
#line 318
  ss = 0.0;
#line 319
  i = start;
  {
#line 319
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 319
    if (! (i < n)) {
#line 319
      goto while_break___3;
    }
#line 320
    ss += (resid[i - resid_start] * resid[i - resid_start]) / *(w + i);
#line 319
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 323
  npoints = n - start;
#line 324
  ss /= (double )(npoints - 2);
#line 325
  *sb1 = sqrt(ss / V);
#line 326
  aa = u * *sb1;
#line 327
  *sb0 = sqrt(ss / W + aa * aa);
#line 328
  *s2 = (ss * (double )npoints) / W;
#line 330
  *new_start = start;
#line 331
  *dof = npoints - 2;
#line 332
  *n_runs___0 = nruns;
  }
#line 334
  return (1);
}
}
#line 358 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/regress.c"
static double find_ordered_entry_with_flags(double *x , int n , int index___0 , int *flags ) 
{ 
  int u ;
  int v ;
  int l ;
  int r ;
  double temp ;
  double piv ;
  int pivind ;
  int tmp ;

  {
#line 366
  if (! (index___0 >= 0)) {
    {
#line 366
    __assert_fail("index >= 0", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/regress.c",
                  366U, "find_ordered_entry_with_flags");
    }
  }
#line 369
  if (*(flags + index___0)) {
#line 370
    return (*(x + index___0));
  }
#line 374
  v = index___0;
#line 374
  u = v;
  {
#line 375
  while (1) {
    while_continue: /* CIL Label */ ;
#line 375
    if (u > 0) {
#line 375
      if (! (! *(flags + u))) {
#line 375
        goto while_break;
      }
    } else {
#line 375
      goto while_break;
    }
#line 375
    u --;
  }
  while_break: /* CIL Label */ ;
  }
#line 376
  if (*(flags + u)) {
#line 376
    u ++;
  }
  {
#line 378
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 378
    if (v < n - 1) {
#line 378
      if (! (! *(flags + v))) {
#line 378
        goto while_break___0;
      }
    } else {
#line 378
      goto while_break___0;
    }
#line 378
    v ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 379
  if (*(flags + v)) {
#line 379
    v --;
  }
  {
#line 381
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 382
    if (v - u < 2) {
#line 383
      if (*(x + v) < *(x + u)) {
#line 384
        temp = *(x + v);
#line 384
        *(x + v) = *(x + u);
#line 384
        *(x + u) = temp;
      }
#line 386
      tmp = 1;
#line 386
      *(flags + u) = tmp;
#line 386
      *(flags + v) = tmp;
#line 387
      return (*(x + index___0));
    } else {
#line 389
      pivind = (u + v) >> 1;
#line 390
      temp = *(x + u);
#line 390
      *(x + u) = *(x + pivind);
#line 390
      *(x + pivind) = temp;
#line 391
      piv = *(x + u);
#line 392
      l = u + 1;
#line 393
      r = v;
      {
#line 394
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 395
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 395
          if (*(x + l) < piv) {
#line 395
            if (! (l < v)) {
#line 395
              goto while_break___3;
            }
          } else {
#line 395
            goto while_break___3;
          }
#line 395
          l ++;
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 396
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 396
          if (! (*(x + r) > piv)) {
#line 396
            goto while_break___4;
          }
#line 396
          r --;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 397
        if (r <= l) {
#line 397
          goto while_break___2;
        }
#line 398
        temp = *(x + l);
#line 398
        *(x + l) = *(x + r);
#line 398
        *(x + r) = temp;
#line 399
        l ++;
#line 400
        r --;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 402
      temp = *(x + u);
#line 402
      *(x + u) = *(x + r);
#line 402
      *(x + r) = temp;
#line 403
      *(flags + r) = 1;
#line 404
      if (index___0 == r) {
#line 405
        return (*(x + r));
      } else
#line 406
      if (index___0 < r) {
#line 407
        v = r - 1;
      } else
#line 408
      if (index___0 > r) {
#line 409
        u = l;
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
}
}
#line 432 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/regress.c"
static double find_median(double *x , int n ) 
{ 
  int k ;
  int flags[128] ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;

  {
  {
#line 438
  memset((void *)(flags), 0, (unsigned long )n * sizeof(int ));
#line 439
  k = n >> 1;
  }
#line 440
  if (n & 1) {
    {
#line 441
    tmp = find_ordered_entry_with_flags(x, n, k, flags);
    }
#line 441
    return (tmp);
  } else {
    {
#line 443
    tmp___0 = find_ordered_entry_with_flags(x, n, k, flags);
#line 443
    tmp___1 = find_ordered_entry_with_flags(x, n, k - 1, flags);
    }
#line 443
    return (0.5 * (tmp___0 + tmp___1));
  }
}
}
#line 456 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/regress.c"
static void eval_robust_residual(double *x , double *y , int n , double b , double *aa ,
                                 double *rr ) 
{ 
  int i ;
  double a ;
  double res ;
  double del ;
  double d[128] ;

  {
#line 471
  i = 0;
  {
#line 471
  while (1) {
    while_continue: /* CIL Label */ ;
#line 471
    if (! (i < n)) {
#line 471
      goto while_break;
    }
#line 472
    d[i] = *(y + i) - b * *(x + i);
#line 471
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 475
  a = find_median(d, n);
#line 477
  res = 0.0;
#line 478
  i = 0;
  }
  {
#line 478
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 478
    if (! (i < n)) {
#line 478
      goto while_break___0;
    }
#line 479
    del = (*(y + i) - a) - b * *(x + i);
#line 480
    if (del > 0.0) {
#line 481
      res += *(x + i);
    } else
#line 482
    if (del < 0.0) {
#line 483
      res -= *(x + i);
    }
#line 478
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 487
  *aa = a;
#line 488
  *rr = res;
#line 489
  return;
}
}
#line 503 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/regress.c"
int RGR_FindBestRobustRegression(double *x , double *y , int n , double tol , double *b0 ,
                                 double *b1 , int *n_runs___0 , int *best_start ) 
{ 
  int i ;
  int start ;
  int n_points ;
  double a ;
  double b ;
  double P ;
  double U ;
  double V ;
  double W ;
  double X ;
  double resid ;
  double resids[128] ;
  double blo ;
  double bhi ;
  double bmid ;
  double rlo ;
  double rhi ;
  double rmid ;
  double s2 ;
  double sb ;
  double incr ;
  double mx ;
  double dx ;
  double my ;
  double dy ;
  int nruns ;

  {
#line 526
  nruns = 0;
#line 528
  if (! (n < 128)) {
    {
#line 528
    __assert_fail("n < 128", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/regress.c",
                  528U, "RGR_FindBestRobustRegression");
    }
  }
#line 530
  if (n < 2) {
#line 531
    return (0);
  } else
#line 532
  if (n == 2) {
#line 534
    *b1 = (*(y + 1) - *(y + 0)) / (*(x + 1) - *(x + 0));
#line 535
    *b0 = *(y + 0) - *b1 * *(x + 0);
#line 536
    *n_runs___0 = 0;
#line 537
    *best_start = 0;
#line 538
    return (1);
  }
#line 543
  start = 0;
  {
#line 547
  while (1) {
    while_continue: /* CIL Label */ ;
#line 549
    n_points = n - start;
#line 553
    U = 0.0;
#line 553
    P = U;
#line 554
    i = start;
    {
#line 554
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 554
      if (! (i < n)) {
#line 554
        goto while_break___0;
      }
#line 555
      P += *(y + i);
#line 556
      U += *(x + i);
#line 554
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 559
    W = (double )n_points;
#line 561
    my = P / W;
#line 562
    mx = U / W;
#line 564
    V = 0.0;
#line 564
    X = V;
#line 565
    i = start;
    {
#line 565
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 565
      if (! (i < n)) {
#line 565
        goto while_break___1;
      }
#line 566
      dy = *(y + i) - my;
#line 567
      dx = *(x + i) - mx;
#line 568
      X += dy * dx;
#line 569
      V += dx * dx;
#line 565
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 572
    b = X / V;
#line 573
    a = my - b * mx;
#line 580
    s2 = 0.0;
#line 581
    i = start;
    {
#line 581
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 581
      if (! (i < n)) {
#line 581
        goto while_break___2;
      }
#line 582
      resid = (*(y + i) - a) - b * *(x + i);
#line 583
      s2 += resid * resid;
#line 581
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 589
    sb = sqrt((s2 * W) / V);
    }
#line 590
    if (sb > tol) {
#line 591
      incr = 3.0 * sb;
    } else {
#line 593
      incr = 3.0 * tol;
    }
#line 596
    blo = b;
#line 597
    bhi = b;
    {
#line 599
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 601
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 601
        if (! (bhi + incr == bhi)) {
#line 601
          if (! (blo - incr == blo)) {
#line 601
            goto while_break___4;
          }
        }
#line 602
        incr *= (double )2;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 605
      blo -= incr;
#line 606
      bhi += incr;
#line 609
      eval_robust_residual(x + start, y + start, n_points, blo, & a, & rlo);
#line 610
      eval_robust_residual(x + start, y + start, n_points, bhi, & a, & rhi);
      }
#line 599
      if (! (rlo * rhi >= 0.0)) {
#line 599
        goto while_break___3;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 616
    while (1) {
      while_continue___5: /* CIL Label */ ;
      {
#line 617
      bmid = 0.5 * (blo + bhi);
#line 618
      eval_robust_residual(x + start, y + start, n_points, bmid, & a, & rmid);
      }
#line 619
      if (rmid == 0.0) {
#line 620
        goto while_break___5;
      } else
#line 621
      if (rmid * rlo > 0.0) {
#line 622
        blo = bmid;
#line 623
        rlo = rmid;
      } else
#line 624
      if (rmid * rhi > 0.0) {
#line 625
        bhi = bmid;
#line 626
        rhi = rmid;
      } else {
        {
#line 628
        __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/regress.c",
                      628U, "RGR_FindBestRobustRegression");
        }
      }
#line 616
      if (bhi - blo > tol) {
#line 616
        if (! ((bmid - blo) * (bhi - bmid) > 0.0)) {
#line 616
          goto while_break___5;
        }
      } else {
#line 616
        goto while_break___5;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
#line 632
    *b0 = a;
#line 633
    *b1 = bmid;
#line 637
    if (n_points == 3) {
#line 638
      goto while_break;
    }
#line 641
    i = start;
    {
#line 641
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 641
      if (! (i < n)) {
#line 641
        goto while_break___6;
      }
#line 642
      resids[i] = (*(y + i) - a) - bmid * *(x + i);
#line 641
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    {
#line 645
    nruns = n_runs_from_residuals(resids + start, n_points);
    }
#line 647
    if (nruns > (int )critical_runs[n_points]) {
#line 648
      goto while_break;
    } else {
#line 650
      start ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 655
  *n_runs___0 = nruns;
#line 656
  *best_start = start;
#line 658
  return (1);
}
}
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 321 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) random)(void) ;
#line 324
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srandom)(unsigned int __seed ) ;
#line 65 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sched.h"
SCH_TimeoutID SCH_AddTimeout(struct timeval *tv , void (*handler)(SCH_ArbitraryArgument  ) ,
                             SCH_ArbitraryArgument arg ) ;
#line 53 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/util.h"
void UTI_DiffTimevals(struct timeval *result , struct timeval *a , struct timeval *b ) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sched.c"
static int initialised___4  =    0;
#line 52 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sched.c"
static fd_set read_fds  ;
#line 55 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sched.c"
static unsigned int n_read_fds  ;
#line 58 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sched.c"
static unsigned int one_highest_fd  ;
#line 71 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sched.c"
static FileHandlerEntry file_handlers[sizeof(fd_set ) * 8UL]  ;
#line 74 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sched.c"
static struct timeval last_select_ts  ;
#line 74 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sched.c"
static struct timeval last_select_ts_raw  ;
#line 75 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sched.c"
static double last_select_ts_err  ;
#line 105 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sched.c"
static TimerQueueEntry timer_queue  ;
#line 106 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sched.c"
static unsigned long n_timer_queue_entries  ;
#line 107 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sched.c"
static SCH_TimeoutID next_tqe_id  ;
#line 110 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sched.c"
static TimerQueueEntry *tqe_free_list  =    (TimerQueueEntry *)((void *)0);
#line 113 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sched.c"
static struct timeval last_class_dispatch[3]  ;
#line 117 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sched.c"
static int need_to_exit  ;
#line 121
static void handle_slew(struct timeval *raw , struct timeval *cooked , double dfreq ,
                        double doffset , int is_step_change , void *anything ) ;
#line 131 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sched.c"
void SCH_Initialise(void) 
{ 
  int __d0 ;
  int __d1 ;

  {
  {
#line 134
  while (1) {
    while_continue: /* CIL Label */ ;
#line 134
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& read_fds.fds_bits[0]): "memory");
#line 134
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 135
  n_read_fds = 0U;
#line 137
  n_timer_queue_entries = 0UL;
#line 138
  next_tqe_id = (SCH_TimeoutID )0;
#line 140
  timer_queue.next = & timer_queue;
#line 141
  timer_queue.prev = & timer_queue;
#line 143
  need_to_exit = 0;
#line 145
  LCL_AddParameterChangeHandler(& handle_slew, (void *)0);
#line 147
  LCL_ReadRawTime(& last_select_ts_raw);
#line 148
  last_select_ts = last_select_ts_raw;
#line 150
  srandom((unsigned int )((last_select_ts.tv_sec << 16) ^ last_select_ts.tv_usec));
#line 152
  initialised___4 = 1;
  }
#line 153
  return;
}
}
#line 158 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sched.c"
void SCH_Finalise(void) 
{ 


  {
#line 160
  initialised___4 = 0;
#line 161
  return;
}
}
#line 165 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sched.c"
void SCH_AddInputFileHandler(int fd___0 , void (*handler)(SCH_ArbitraryArgument  ) ,
                             SCH_ArbitraryArgument arg ) 
{ 


  {
#line 170
  if (! initialised___4) {
    {
#line 170
    __assert_fail("initialised", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sched.c",
                  170U, "SCH_AddInputFileHandler");
    }
  }
#line 175
  if (! (! ((read_fds.fds_bits[fd___0 / (8 * (int )sizeof(__fd_mask ))] & (1L << fd___0 % (8 * (int )sizeof(__fd_mask )))) != 0L))) {
    {
#line 175
    __assert_fail("!((((&read_fds)->fds_bits)[((fd) / (8 * (int) sizeof (__fd_mask)))] & ((__fd_mask) 1 << ((fd) % (8 * (int) sizeof (__fd_mask))))) != 0)",
                  "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sched.c",
                  175U, "SCH_AddInputFileHandler");
    }
  }
#line 177
  n_read_fds ++;
#line 179
  file_handlers[fd___0].handler = handler;
#line 180
  file_handlers[fd___0].arg = arg;
#line 182
  read_fds.fds_bits[fd___0 / (8 * (int )sizeof(__fd_mask ))] |= 1L << fd___0 % (8 * (int )sizeof(__fd_mask ));
#line 184
  if ((unsigned int )(fd___0 + 1) > one_highest_fd) {
#line 185
    one_highest_fd = (unsigned int )(fd___0 + 1);
  }
#line 187
  return;
}
}
#line 192 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sched.c"
void SCH_RemoveInputFileHandler(int fd___0 ) 
{ 
  int fds_left ;
  int fd_to_check ;

  {
#line 197
  if (! initialised___4) {
    {
#line 197
    __assert_fail("initialised", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sched.c",
                  197U, "SCH_RemoveInputFileHandler");
    }
  }
#line 200
  if (! ((read_fds.fds_bits[fd___0 / (8 * (int )sizeof(__fd_mask ))] & (1L << fd___0 % (8 * (int )sizeof(__fd_mask )))) != 0L)) {
    {
#line 200
    __assert_fail("((((&read_fds)->fds_bits)[((fd) / (8 * (int) sizeof (__fd_mask)))] & ((__fd_mask) 1 << ((fd) % (8 * (int) sizeof (__fd_mask))))) != 0)",
                  "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sched.c",
                  200U, "SCH_RemoveInputFileHandler");
    }
  }
#line 202
  n_read_fds --;
#line 204
  read_fds.fds_bits[fd___0 / (8 * (int )sizeof(__fd_mask ))] &= ~ (1L << fd___0 % (8 * (int )sizeof(__fd_mask )));
#line 207
  fds_left = (int )n_read_fds;
#line 208
  fd_to_check = 0;
  {
#line 209
  while (1) {
    while_continue: /* CIL Label */ ;
#line 209
    if (! (fds_left > 0)) {
#line 209
      goto while_break;
    }
#line 210
    if ((read_fds.fds_bits[fd_to_check / (8 * (int )sizeof(__fd_mask ))] & (1L << fd_to_check % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 211
      fds_left --;
    }
#line 213
    fd_to_check ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 216
  one_highest_fd = (unsigned int )fd_to_check;
#line 217
  return;
}
}
#line 221 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sched.c"
void SCH_GetLastEventTime(struct timeval *cooked , double *err , struct timeval *raw ) 
{ 


  {
#line 224
  if (cooked) {
#line 225
    *cooked = last_select_ts;
#line 226
    if (err) {
#line 227
      *err = last_select_ts_err;
    }
  }
#line 229
  if (raw) {
#line 230
    *raw = last_select_ts_raw;
  }
#line 231
  return;
}
}
#line 237 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sched.c"
static TimerQueueEntry *allocate_tqe(void) 
{ 
  TimerQueueEntry *new_block ;
  TimerQueueEntry *result ;
  int i ;
  void *tmp ;

  {
#line 243
  if ((unsigned long )tqe_free_list == (unsigned long )((void *)0)) {
    {
#line 244
    tmp = malloc(32UL * sizeof(TimerQueueEntry ));
#line 244
    new_block = (TimerQueueEntry *)tmp;
#line 245
    i = 1;
    }
    {
#line 245
    while (1) {
      while_continue: /* CIL Label */ ;
#line 245
      if (! (i < 32)) {
#line 245
        goto while_break;
      }
#line 246
      (new_block + i)->next = new_block + (i - 1);
#line 245
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 248
    (new_block + 0)->next = (struct _TimerQueueEntry *)((void *)0);
#line 249
    tqe_free_list = new_block + 31;
  }
#line 252
  result = tqe_free_list;
#line 253
  tqe_free_list = tqe_free_list->next;
#line 254
  return (result);
}
}
#line 259 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sched.c"
static void release_tqe(TimerQueueEntry *node ) 
{ 


  {
#line 262
  node->next = tqe_free_list;
#line 263
  tqe_free_list = node;
#line 264
  return;
}
}
#line 268 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sched.c"
SCH_TimeoutID SCH_AddTimeout(struct timeval *tv , void (*handler)(SCH_ArbitraryArgument  ) ,
                             SCH_ArbitraryArgument arg ) 
{ 
  TimerQueueEntry *new_tqe ;
  TimerQueueEntry *ptr ;
  SCH_TimeoutID tmp ;
  int tmp___0 ;

  {
#line 274
  if (! initialised___4) {
    {
#line 274
    __assert_fail("initialised", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sched.c",
                  274U, "SCH_AddTimeout");
    }
  }
  {
#line 276
  new_tqe = allocate_tqe();
#line 278
  tmp = next_tqe_id;
#line 278
  next_tqe_id ++;
#line 278
  new_tqe->id = tmp;
#line 279
  new_tqe->handler = handler;
#line 280
  new_tqe->arg = arg;
#line 281
  new_tqe->tv = *tv;
#line 282
  new_tqe->class = (SCH_TimeoutClass )0;
#line 285
  ptr = timer_queue.next;
  }
  {
#line 285
  while (1) {
    while_continue: /* CIL Label */ ;
#line 285
    if (! ((unsigned long )ptr != (unsigned long )(& timer_queue))) {
#line 285
      goto while_break;
    }
    {
#line 286
    tmp___0 = UTI_CompareTimevals(& new_tqe->tv, & ptr->tv);
    }
#line 286
    if (tmp___0 == -1) {
#line 289
      goto while_break;
    }
#line 285
    ptr = ptr->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 296
  new_tqe->next = ptr;
#line 297
  new_tqe->prev = ptr->prev;
#line 298
  (ptr->prev)->next = new_tqe;
#line 299
  ptr->prev = new_tqe;
#line 301
  n_timer_queue_entries ++;
#line 303
  return (new_tqe->id);
}
}
#line 310 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sched.c"
SCH_TimeoutID SCH_AddTimeoutByDelay(double delay , void (*handler)(SCH_ArbitraryArgument  ) ,
                                    SCH_ArbitraryArgument arg ) 
{ 
  struct timeval now ;
  struct timeval then ;
  SCH_TimeoutID tmp ;

  {
#line 315
  if (! initialised___4) {
    {
#line 315
    __assert_fail("initialised", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sched.c",
                  315U, "SCH_AddTimeoutByDelay");
    }
  }
#line 316
  if (! (delay >= 0.0)) {
    {
#line 316
    __assert_fail("delay >= 0.0", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sched.c",
                  316U, "SCH_AddTimeoutByDelay");
    }
  }
  {
#line 318
  LCL_ReadRawTime(& now);
#line 319
  UTI_AddDoubleToTimeval(& now, delay, & then);
#line 320
  tmp = SCH_AddTimeout(& then, handler, arg);
  }
#line 320
  return (tmp);
}
}
#line 326 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sched.c"
SCH_TimeoutID SCH_AddTimeoutInClass(double min_delay , double separation , double randomness ,
                                    SCH_TimeoutClass class , void (*handler)(SCH_ArbitraryArgument  ) ,
                                    SCH_ArbitraryArgument arg ) 
{ 
  TimerQueueEntry *new_tqe ;
  TimerQueueEntry *ptr ;
  struct timeval now ;
  double diff ;
  double r ;
  double new_min_delay ;
  long tmp ;
  SCH_TimeoutID tmp___0 ;

  {
#line 337
  if (! initialised___4) {
    {
#line 337
    __assert_fail("initialised", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sched.c",
                  337U, "SCH_AddTimeoutInClass");
    }
  }
#line 338
  if (! (min_delay >= 0.0)) {
    {
#line 338
    __assert_fail("min_delay >= 0.0", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sched.c",
                  338U, "SCH_AddTimeoutInClass");
    }
  }
#line 339
  if (! ((unsigned int )class < 3U)) {
    {
#line 339
    __assert_fail("class < SCH_NumberOfClasses", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sched.c",
                  339U, "SCH_AddTimeoutInClass");
    }
  }
#line 341
  if (randomness > 0.0) {
    {
#line 342
    tmp = random();
#line 342
    r = ((double )(tmp % 65535L) / ((double )65535 - 1.0)) * randomness + 1.0;
#line 343
    min_delay *= r;
#line 344
    separation *= r;
    }
  }
  {
#line 347
  LCL_ReadRawTime(& now);
#line 348
  new_min_delay = min_delay;
#line 351
  UTI_DiffTimevalsToDouble(& diff, & now, & last_class_dispatch[class]);
  }
#line 352
  if (diff < separation) {
#line 352
    if (diff >= 0.0) {
#line 352
      if (diff + new_min_delay < separation) {
#line 353
        new_min_delay = separation - diff;
      }
    }
  }
#line 358
  ptr = timer_queue.next;
  {
#line 358
  while (1) {
    while_continue: /* CIL Label */ ;
#line 358
    if (! ((unsigned long )ptr != (unsigned long )(& timer_queue))) {
#line 358
      goto while_break;
    }
#line 359
    if ((unsigned int )ptr->class == (unsigned int )class) {
      {
#line 360
      UTI_DiffTimevalsToDouble(& diff, & ptr->tv, & now);
      }
#line 361
      if (new_min_delay > diff) {
#line 362
        if (new_min_delay - diff < separation) {
#line 363
          new_min_delay = diff + separation;
        }
      } else
#line 366
      if (diff - new_min_delay < separation) {
#line 367
        new_min_delay = diff + separation;
      }
    }
#line 358
    ptr = ptr->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 373
  ptr = timer_queue.next;
  {
#line 373
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 373
    if (! ((unsigned long )ptr != (unsigned long )(& timer_queue))) {
#line 373
      goto while_break___0;
    }
    {
#line 374
    UTI_DiffTimevalsToDouble(& diff, & ptr->tv, & now);
    }
#line 375
    if (diff > new_min_delay) {
#line 376
      goto while_break___0;
    }
#line 373
    ptr = ptr->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 381
  new_tqe = allocate_tqe();
#line 383
  tmp___0 = next_tqe_id;
#line 383
  next_tqe_id ++;
#line 383
  new_tqe->id = tmp___0;
#line 384
  new_tqe->handler = handler;
#line 385
  new_tqe->arg = arg;
#line 386
  UTI_AddDoubleToTimeval(& now, new_min_delay, & new_tqe->tv);
#line 387
  new_tqe->class = class;
#line 389
  new_tqe->next = ptr;
#line 390
  new_tqe->prev = ptr->prev;
#line 391
  (ptr->prev)->next = new_tqe;
#line 392
  ptr->prev = new_tqe;
#line 393
  n_timer_queue_entries ++;
  }
#line 395
  return (new_tqe->id);
}
}
#line 400 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sched.c"
void SCH_RemoveTimeout(SCH_TimeoutID id ) 
{ 
  TimerQueueEntry *ptr ;

  {
#line 405
  if (! initialised___4) {
    {
#line 405
    __assert_fail("initialised", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sched.c",
                  405U, "SCH_RemoveTimeout");
    }
  }
#line 407
  ptr = timer_queue.next;
  {
#line 407
  while (1) {
    while_continue: /* CIL Label */ ;
#line 407
    if (! ((unsigned long )ptr != (unsigned long )(& timer_queue))) {
#line 407
      goto while_break;
    }
#line 409
    if (ptr->id == id) {
      {
#line 413
      (ptr->next)->prev = ptr->prev;
#line 414
      (ptr->prev)->next = ptr->next;
#line 417
      n_timer_queue_entries --;
#line 420
      release_tqe(ptr);
      }
#line 422
      goto while_break;
    }
#line 407
    ptr = ptr->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 425
  return;
}
}
#line 433 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sched.c"
static void dispatch_timeouts(struct timeval *now ) 
{ 
  TimerQueueEntry *ptr ;
  void (*handler)(SCH_ArbitraryArgument  ) ;
  SCH_ArbitraryArgument arg ;
  int n_done ;
  int n_entries_on_start ;
  int tmp ;

  {
#line 438
  n_done = 0;
#line 438
  n_entries_on_start = (int )n_timer_queue_entries;
  {
#line 440
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 441
    LCL_ReadRawTime(now);
    }
#line 443
    if (n_timer_queue_entries > 0UL) {
      {
#line 443
      tmp = UTI_CompareTimevals(now, & (timer_queue.next)->tv);
      }
#line 443
      if (! (tmp >= 0)) {
#line 445
        goto while_break;
      }
    } else {
#line 445
      goto while_break;
    }
    {
#line 448
    ptr = timer_queue.next;
#line 450
    last_class_dispatch[ptr->class] = *now;
#line 452
    handler = ptr->handler;
#line 453
    arg = ptr->arg;
#line 455
    SCH_RemoveTimeout(ptr->id);
#line 458
    (*handler)(arg);
#line 461
    n_done ++;
    }
#line 468
    if ((unsigned long )n_done > n_timer_queue_entries * 4UL) {
#line 468
      if (n_done > n_entries_on_start * 4) {
        {
#line 470
        LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/sched.c",
                     470, "dispatch_timeouts");
#line 470
        LOG_Fatal_Function((LOG_Facility )4, "Possible infinite loop in scheduling");
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 473
  return;
}
}
#line 479 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sched.c"
static void dispatch_filehandlers(int nfh , fd_set *fhs ) 
{ 
  int fh ;

  {
#line 482
  fh = 0;
  {
#line 484
  while (1) {
    while_continue: /* CIL Label */ ;
#line 484
    if (! (nfh > 0)) {
#line 484
      goto while_break;
    }
#line 485
    if ((fhs->fds_bits[fh / (8 * (int )sizeof(__fd_mask ))] & (1L << fh % (8 * (int )sizeof(__fd_mask )))) != 0L) {
      {
#line 488
      (*(file_handlers[fh].handler))(file_handlers[fh].arg);
#line 491
      nfh --;
      }
    }
#line 494
    fh ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 497
  return;
}
}
#line 501 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sched.c"
static void handle_slew(struct timeval *raw , struct timeval *cooked , double dfreq ,
                        double doffset , int is_step_change , void *anything ) 
{ 
  TimerQueueEntry *ptr ;
  double delta ;
  int i ;

  {
#line 513
  if (is_step_change) {
#line 516
    ptr = timer_queue.next;
    {
#line 516
    while (1) {
      while_continue: /* CIL Label */ ;
#line 516
      if (! ((unsigned long )ptr != (unsigned long )(& timer_queue))) {
#line 516
        goto while_break;
      }
      {
#line 517
      UTI_AddDoubleToTimeval(& ptr->tv, - doffset, & ptr->tv);
#line 516
      ptr = ptr->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 520
    i = 0;
    {
#line 520
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 520
      if (! (i < 3)) {
#line 520
        goto while_break___0;
      }
      {
#line 521
      UTI_AddDoubleToTimeval(& last_class_dispatch[i], - doffset, & last_class_dispatch[i]);
#line 520
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 524
    UTI_AddDoubleToTimeval(& last_select_ts_raw, - doffset, & last_select_ts_raw);
    }
  }
  {
#line 527
  UTI_AdjustTimeval(& last_select_ts, cooked, & last_select_ts, & delta, dfreq, doffset);
  }
#line 528
  return;
}
}
#line 534 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sched.c"
static void recover_backjump(struct timeval *raw , struct timeval *cooked , int timeout ) 
{ 
  double diff ;
  double err ;

  {
  {
#line 539
  UTI_DiffTimevalsToDouble(& diff, & last_select_ts_raw, raw);
  }
#line 541
  if (n_timer_queue_entries > 0UL) {
    {
#line 542
    UTI_DiffTimevalsToDouble(& err, & (timer_queue.next)->tv, & last_select_ts_raw);
    }
  } else {
#line 544
    err = 0.0;
  }
#line 547
  diff += err;
#line 549
  if (timeout) {
#line 550
    err = 1.0;
  }
  {
#line 553
  LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/sched.c", 553,
               "recover_backjump");
#line 553
  LOG_Line_Function((LOG_Severity )1, (LOG_Facility )4, "Backward time jump detected! (correction %.1f +- %.1f seconds)",
                    diff, err);
#line 555
  LCL_NotifyExternalTimeStep(raw, cooked, diff, err);
  }
#line 556
  return;
}
}
#line 560 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sched.c"
void SCH_MainLoop(void) 
{ 
  fd_set rd ;
  int status___0 ;
  int errsv ;
  struct timeval tv ;
  struct timeval *ptv ;
  struct timeval now ;
  struct timeval cooked ;
  double err ;
  int *tmp ;
  char *tmp___0 ;

  {
#line 569
  if (! initialised___4) {
    {
#line 569
    __assert_fail("initialised", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sched.c",
                  569U, "SCH_MainLoop");
    }
  }
  {
#line 571
  while (1) {
    while_continue: /* CIL Label */ ;
#line 571
    if (! (! need_to_exit)) {
#line 571
      goto while_break;
    }
    {
#line 574
    memcpy((void */* __restrict  */)((void *)(& rd)), (void const   */* __restrict  */)((void *)(& read_fds)),
           sizeof(fd_set ));
#line 577
    dispatch_timeouts(& now);
    }
#line 580
    if (n_timer_queue_entries > 0UL) {
      {
#line 582
      UTI_DiffTimevals(& tv, & (timer_queue.next)->tv, & now);
#line 583
      ptv = & tv;
      }
#line 584
      if (! (tv.tv_sec > 0L)) {
#line 584
        if (! (tv.tv_usec > 0L)) {
          {
#line 584
          __assert_fail("tv.tv_sec > 0 || tv.tv_usec > 0", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sched.c",
                        584U, "SCH_MainLoop");
          }
        }
      }
    } else {
#line 587
      ptv = (struct timeval *)((void *)0);
    }
#line 592
    if (! ptv) {
#line 592
      if (! n_read_fds) {
        {
#line 592
        __assert_fail("ptv || n_read_fds", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sched.c",
                      592U, "SCH_MainLoop");
        }
      }
    }
    {
#line 594
    status___0 = select((int )one_highest_fd, (fd_set */* __restrict  */)(& rd), (fd_set */* __restrict  */)((void *)0),
                        (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)ptv);
#line 595
    tmp = __errno_location();
#line 595
    errsv = *tmp;
#line 597
    LCL_ReadRawTime(& now);
#line 598
    LCL_CookTime(& now, & cooked, & err);
    }
#line 601
    if (last_select_ts_raw.tv_sec > now.tv_sec + 1L) {
      {
#line 602
      recover_backjump(& now, & cooked, status___0 == 0);
      }
    }
#line 605
    last_select_ts_raw = now;
#line 606
    last_select_ts = cooked;
#line 607
    last_select_ts_err = err;
#line 609
    if (status___0 < 0) {
#line 610
      if (! need_to_exit) {
#line 610
        if (errsv != 4) {
          {
#line 611
          LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/sched.c",
                       611, "SCH_MainLoop");
#line 611
          tmp___0 = strerror(errsv);
#line 611
          LOG_Fatal_Function((LOG_Facility )4, "select() failed : %s", tmp___0);
          }
        }
      }
    } else
#line 613
    if (status___0 > 0) {
      {
#line 616
      dispatch_filehandlers(status___0, & rd);
      }
    } else
#line 621
    if (! ptv) {
      {
#line 621
      __assert_fail("ptv", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sched.c",
                    621U, "SCH_MainLoop");
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 629
  return;
}
}
#line 633 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sched.c"
void SCH_QuitProgram(void) 
{ 


  {
#line 636
  if (! initialised___4) {
    {
#line 636
    __assert_fail("initialised", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sched.c",
                  636U, "SCH_QuitProgram");
    }
  }
#line 637
  need_to_exit = 1;
#line 638
  return;
}
}
#line 55 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.h"
int CNF_GetLogTempComp(void) ;
#line 95
void CNF_GetTempComp(char **file , double *interval , double *T0___0 , double *k0___0 ,
                     double *k1___0 , double *k2___0 ) ;
#line 38 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/tempcomp.c"
static SCH_TimeoutID timeout_id___0  ;
#line 40 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/tempcomp.c"
static LOG_FileID logfileid___2  ;
#line 42 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/tempcomp.c"
static char *filename  ;
#line 43 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/tempcomp.c"
static double update_interval  ;
#line 44 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/tempcomp.c"
static double T0  ;
#line 44 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/tempcomp.c"
static double k0  ;
#line 44 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/tempcomp.c"
static double k1  ;
#line 44 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/tempcomp.c"
static double k2  ;
#line 46 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/tempcomp.c"
static void read_timeout(void *arg ) 
{ 
  FILE *f ;
  double temp ;
  double comp ;
  struct timeval now ;
  char *tmp ;
  double tmp___0 ;
  int tmp___1 ;

  {
  {
#line 52
  f = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 54
  if (f) {
    {
#line 54
    tmp___1 = fscanf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%lf",
                     & temp);
    }
#line 54
    if (tmp___1 == 1) {
      {
#line 55
      comp = (k0 + (temp - T0) * k1) + ((temp - T0) * (temp - T0)) * k2;
#line 58
      tmp___0 = fabs(comp);
      }
#line 58
      if (tmp___0 < 10.0) {
        {
#line 59
        comp = LCL_SetTempComp(comp);
        }
#line 61
        if (logfileid___2 != -1) {
          {
#line 64
          LCL_ReadCookedTime(& now, (double *)((void *)0));
#line 65
          tmp = UTI_TimeToLogForm(now.tv_sec);
#line 65
          LOG_FileWrite(logfileid___2, "%s %11.4e %11.4e", tmp, temp, comp);
          }
        }
      }
    }
  }
#line 71
  if (f) {
    {
#line 72
    fclose(f);
    }
  }
  {
#line 74
  timeout_id___0 = SCH_AddTimeoutByDelay(update_interval, & read_timeout, (void *)0);
  }
#line 75
  return;
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/tempcomp.c"
void TMC_Initialise(void) 
{ 
  LOG_FileID tmp___0 ;
  int tmp___1 ;

  {
  {
#line 80
  CNF_GetTempComp(& filename, & update_interval, & T0, & k0, & k1, & k2);
  }
#line 82
  if ((unsigned long )filename == (unsigned long )((void *)0)) {
#line 83
    return;
  }
#line 85
  if (update_interval <= 0.0) {
#line 86
    update_interval = 1.0;
  }
  {
#line 88
  tmp___1 = CNF_GetLogTempComp();
  }
#line 88
  if (tmp___1) {
    {
#line 88
    tmp___0 = LOG_FileOpen("tempcomp", "   Date (UTC) Time        Temp.       Comp.");
#line 88
    logfileid___2 = tmp___0;
    }
  } else {
#line 88
    logfileid___2 = -1;
  }
  {
#line 92
  read_timeout((void *)0);
  }
#line 93
  return;
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/tempcomp.c"
void TMC_Finalise(void) 
{ 


  {
#line 98
  if ((unsigned long )filename == (unsigned long )((void *)0)) {
#line 99
    return;
  }
  {
#line 101
  SCH_RemoveTimeout(timeout_id___0);
#line 102
  free((void *)filename);
  }
#line 103
  return;
}
}
#line 38 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/acquire.h"
void ACQ_StartAcquisition(int n , IPAddr *ip_addrs , double threshold , void (*after_hook)(void * ) ,
                          void *anything ) ;
#line 44 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.h"
unsigned short CNF_GetAcquisitionPort(void) ;
#line 92 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/acquire.c"
static SourceRecord___0 *sources___0  ;
#line 93 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/acquire.c"
static int n_sources___2  ;
#line 94 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/acquire.c"
static int n_started_sources  ;
#line 95 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/acquire.c"
static int n_completed_sources  ;
#line 97 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/acquire.c"
static double init_slew_threshold  ;
#line 107 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/acquire.c"
static int sock_fd4___0  =    -1;
#line 109 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/acquire.c"
static int sock_fd6___0  =    -1;
#line 114 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/acquire.c"
static void (*saved_after_hook)(void * )  =    (void (*)(void * ))((void *)0);
#line 115 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/acquire.c"
static void *saved_after_hook_anything  =    (void *)0;
#line 132
static void read_from_socket(void *anything ) ;
#line 133
static void transmit_timeout___0(void *x ) ;
#line 134
static void wind_up_acquisition(void) ;
#line 135
static void start_source_timeout_handler(void *not_used ) ;
#line 139 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/acquire.c"
static SCH_TimeoutID source_start_timeout_id  ;
#line 143 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/acquire.c"
void ACQ_Initialise(void) 
{ 


  {
#line 146
  return;
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/acquire.c"
void ACQ_Finalise(void) 
{ 


  {
#line 154
  return;
}
}
#line 158 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/acquire.c"
static int prepare_socket___0(int family ) 
{ 
  unsigned short port_number ;
  unsigned short tmp ;
  int sock_fd___0 ;
  socklen_t addrlen ;
  int *tmp___0 ;
  char *tmp___1 ;
  union sockaddr_in46 my_addr ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 161
  tmp = CNF_GetAcquisitionPort();
#line 161
  port_number = tmp;
#line 165
  sock_fd___0 = socket(family, 2, 0);
  }
#line 167
  if (sock_fd___0 < 0) {
    {
#line 168
    LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/acquire.c",
                 168, "prepare_socket");
#line 168
    tmp___0 = __errno_location();
#line 168
    tmp___1 = strerror(*tmp___0);
#line 168
    LOG_Fatal_Function((LOG_Facility )13, "Could not open socket : %s", tmp___1);
    }
  }
  {
#line 172
  UTI_FdSetCloexec(sock_fd___0);
  }
#line 174
  if (! ((int )port_number == 0)) {
    {
#line 180
    memset((void *)(& my_addr), 0, sizeof(my_addr));
    }
    {
#line 183
    if (family == 2) {
#line 183
      goto case_2;
    }
#line 190
    if (family == 10) {
#line 190
      goto case_10;
    }
#line 197
    goto switch_default;
    case_2: /* CIL Label */ 
    {
#line 184
    my_addr.in4.sin_family = (sa_family_t )family;
#line 185
    my_addr.in4.sin_port = htons(port_number);
#line 186
    my_addr.in4.sin_addr.s_addr = htonl((in_addr_t )0);
#line 187
    addrlen = (socklen_t )sizeof(my_addr.in4);
    }
#line 188
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 191
    my_addr.in6.sin6_family = (sa_family_t )family;
#line 192
    my_addr.in6.sin6_port = htons(port_number);
#line 193
    my_addr.in6.sin6_addr = (struct in6_addr )in6addr_any;
#line 194
    addrlen = (socklen_t )sizeof(my_addr.in6);
    }
#line 195
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 198
    __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/acquire.c",
                  198U, "prepare_socket");
    }
    switch_break: /* CIL Label */ ;
    }
    {
#line 201
    tmp___4 = bind(sock_fd___0, (struct sockaddr  const  */* __restrict  */)(& my_addr.u),
                   addrlen);
    }
#line 201
    if (tmp___4 < 0) {
      {
#line 202
      LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/acquire.c",
                   202, "prepare_socket");
#line 202
      tmp___2 = __errno_location();
#line 202
      tmp___3 = strerror(*tmp___2);
#line 202
      LOG_Line_Function((LOG_Severity )2, (LOG_Facility )13, "Could not bind socket : %s",
                        tmp___3);
      }
    }
  }
  {
#line 207
  SCH_AddInputFileHandler(sock_fd___0, & read_from_socket, (void *)((long )sock_fd___0));
  }
#line 209
  return (sock_fd___0);
}
}
#line 213 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/acquire.c"
static void initialise_io(int family ) 
{ 


  {
#line 216
  if (family == 1) {
    {
#line 217
    sock_fd4___0 = prepare_socket___0(2);
    }
  } else
#line 216
  if (family == 0) {
    {
#line 217
    sock_fd4___0 = prepare_socket___0(2);
    }
  }
#line 219
  if (family == 2) {
    {
#line 220
    sock_fd6___0 = prepare_socket___0(10);
    }
  } else
#line 219
  if (family == 0) {
    {
#line 220
    sock_fd6___0 = prepare_socket___0(10);
    }
  }
#line 222
  return;
}
}
#line 226 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/acquire.c"
static void finalise_io(void) 
{ 


  {
#line 229
  if (sock_fd4___0 >= 0) {
    {
#line 230
    SCH_RemoveInputFileHandler(sock_fd4___0);
#line 231
    close(sock_fd4___0);
    }
  }
#line 233
  sock_fd4___0 = -1;
#line 235
  if (sock_fd6___0 >= 0) {
    {
#line 236
    SCH_RemoveInputFileHandler(sock_fd6___0);
#line 237
    close(sock_fd6___0);
    }
  }
#line 239
  sock_fd6___0 = -1;
#line 241
  return;
}
}
#line 245 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/acquire.c"
static void probe_source(SourceRecord___0 *src ) 
{ 
  NTP_Packet pkt ;
  int version ;
  NTP_Mode my_mode ;
  struct timeval cooked ;
  union sockaddr_in46 his_addr___0 ;
  int sock_fd___0 ;
  socklen_t addrlen ;
  uint32_t ts_fuzz ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  ssize_t tmp___3 ;

  {
  {
#line 249
  version = 3;
#line 250
  my_mode = (NTP_Mode )3;
#line 261
  pkt.lvm = (uint8_t )((unsigned int )(((3 << 6) & 192) | ((version << 3) & 56)) | ((unsigned int )my_mode & 7U));
#line 265
  pkt.stratum = (uint8_t )0;
#line 266
  pkt.poll = (int8_t )4;
#line 267
  pkt.precision = (int8_t )-6;
#line 268
  pkt.root_delay = UTI_DoubleToInt32(1.0);
#line 269
  pkt.root_dispersion = UTI_DoubleToInt32(1.0);
#line 270
  pkt.reference_id = (NTP_int32 )0;
#line 271
  pkt.reference_ts.hi = (uint32_t )0;
#line 272
  pkt.reference_ts.lo = (uint32_t )0;
#line 273
  pkt.originate_ts.hi = (uint32_t )0;
#line 274
  pkt.originate_ts.lo = (uint32_t )0;
#line 275
  pkt.receive_ts.hi = (uint32_t )0;
#line 276
  pkt.receive_ts.lo = (uint32_t )0;
#line 280
  memset((void *)(& his_addr___0), 0, sizeof(his_addr___0));
  }
  {
#line 282
  if ((int )src->ip_addr.family == 1) {
#line 282
    goto case_1;
  }
#line 290
  if ((int )src->ip_addr.family == 2) {
#line 290
    goto case_2;
  }
#line 299
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 283
  his_addr___0.in4.sin_addr.s_addr = htonl(src->ip_addr.addr.in4);
#line 284
  his_addr___0.in4.sin_port = htons((uint16_t )123);
#line 285
  his_addr___0.in4.sin_family = (sa_family_t )2;
#line 286
  addrlen = (socklen_t )sizeof(his_addr___0.in4);
#line 287
  sock_fd___0 = sock_fd4___0;
  }
#line 288
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 291
  memcpy((void */* __restrict  */)(& his_addr___0.in6.sin6_addr.__in6_u.__u6_addr8),
         (void const   */* __restrict  */)(& src->ip_addr.addr.in6), sizeof(his_addr___0.in6.sin6_addr.__in6_u.__u6_addr8));
#line 293
  his_addr___0.in6.sin6_port = htons((uint16_t )123);
#line 294
  his_addr___0.in6.sin6_family = (sa_family_t )10;
#line 295
  addrlen = (socklen_t )sizeof(his_addr___0.in6);
#line 296
  sock_fd___0 = sock_fd6___0;
  }
#line 297
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 300
  __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/acquire.c",
                300U, "probe_source");
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 304
  tmp = LCL_GetSysPrecisionAsLog();
#line 304
  ts_fuzz = UTI_GetNTPTsFuzz(tmp);
#line 305
  LCL_ReadCookedTime(& cooked, (double *)((void *)0));
#line 306
  UTI_TimevalToInt64(& cooked, & pkt.transmit_ts, ts_fuzz);
#line 308
  tmp___3 = sendto(sock_fd___0, (void const   *)((void *)(& pkt)), (unsigned long )(& ((NTP_Packet *)0)->auth_keyid),
                   0, (struct sockaddr  const  */* __restrict  */)(& his_addr___0.u),
                   addrlen);
  }
#line 308
  if (tmp___3 < 0L) {
    {
#line 311
    LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/acquire.c",
                 311, "probe_source");
#line 311
    tmp___0 = __errno_location();
#line 311
    tmp___1 = strerror(*tmp___0);
#line 311
    tmp___2 = UTI_IPToString(& src->ip_addr);
#line 311
    LOG_Line_Function((LOG_Severity )1, (LOG_Facility )13, "Could not send to %s : %s",
                      tmp___2, tmp___1);
    }
  }
  {
#line 316
  src->last_tx = pkt.transmit_ts;
#line 318
  (src->n_dead_probes) ++;
#line 319
  src->timer_running = 1;
#line 320
  src->timeout_id = SCH_AddTimeoutByDelay(1.0, & transmit_timeout___0, (void *)src);
  }
#line 321
  return;
}
}
#line 325 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/acquire.c"
static void transmit_timeout___0(void *x ) 
{ 
  SourceRecord___0 *src ;

  {
#line 328
  src = (SourceRecord___0 *)x;
#line 330
  src->timer_running = 0;
#line 336
  if (src->n_dead_probes < 4) {
    {
#line 337
    probe_source(src);
    }
  } else {
#line 340
    n_completed_sources ++;
#line 341
    if (n_completed_sources == n_sources___2) {
      {
#line 342
      wind_up_acquisition();
      }
    }
  }
#line 345
  return;
}
}
#line 351 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/acquire.c"
static void process_receive(NTP_Packet *msg , SourceRecord___0 *src , struct timeval *now ) 
{ 
  unsigned long lvm ;
  int leap ;
  int version ;
  int mode ;
  double root_delay ;
  double root_dispersion ;
  double total_root_delay ;
  double total_root_dispersion ;
  double total_root_distance ;
  struct timeval local_orig ;
  struct timeval local_average ;
  struct timeval remote_rx ;
  struct timeval remote_tx ;
  struct timeval remote_average ;
  double remote_interval ;
  double local_interval ;
  double delta ;
  double theta ;
  double epsilon ;
  int n ;
  double tmp ;
  double tmp___0 ;

  {
#line 369
  lvm = (unsigned long )msg->lvm;
#line 370
  leap = (int )((lvm >> 6) & 3UL);
#line 371
  version = (int )((lvm >> 3) & 7UL);
#line 372
  mode = (int )(lvm & 7UL);
#line 374
  if (leap == 3) {
#line 377
    return;
  } else
#line 374
  if (version < 2) {
#line 377
    return;
  } else
#line 374
  if (version > 4) {
#line 377
    return;
  } else
#line 374
  if (mode != 4) {
#line 374
    if (mode != 2) {
#line 377
      return;
    }
  }
#line 380
  if ((int )msg->stratum > 15) {
#line 381
    return;
  }
#line 385
  if (msg->originate_ts.hi != src->last_tx.hi) {
#line 387
    return;
  } else
#line 385
  if (msg->originate_ts.lo != src->last_tx.lo) {
#line 387
    return;
  }
#line 391
  if (msg->originate_ts.hi == 0U) {
#line 391
    if (msg->originate_ts.lo == 0U) {
#line 393
      return;
    } else {
#line 391
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 391
  if (msg->receive_ts.hi == 0U) {
#line 391
    if (msg->receive_ts.lo == 0U) {
#line 393
      return;
    }
  }
  {
#line 396
  root_delay = UTI_Int32ToDouble(msg->root_delay);
#line 397
  root_dispersion = UTI_Int32ToDouble(msg->root_dispersion);
#line 399
  UTI_Int64ToTimeval(& src->last_tx, & local_orig);
#line 400
  UTI_Int64ToTimeval(& msg->receive_ts, & remote_rx);
#line 401
  UTI_Int64ToTimeval(& msg->transmit_ts, & remote_tx);
#line 402
  UTI_AverageDiffTimevals(& remote_rx, & remote_tx, & remote_average, & remote_interval);
#line 403
  UTI_AverageDiffTimevals(& local_orig, now, & local_average, & local_interval);
#line 405
  delta = local_interval - remote_interval;
#line 410
  UTI_DiffTimevalsToDouble(& theta, & local_average, & remote_average);
#line 413
  epsilon = 0.0;
#line 415
  tmp = fabs(delta);
#line 415
  total_root_delay = tmp + root_delay;
#line 416
  total_root_dispersion = epsilon + root_dispersion;
#line 417
  tmp___0 = fabs(total_root_delay);
#line 417
  total_root_distance = 0.5 * tmp___0 + total_root_dispersion;
#line 419
  n = src->n_samples;
#line 424
  src->offsets[n] = theta;
#line 425
  src->root_distances[n] = total_root_distance;
#line 426
  (src->n_samples) ++;
  }
#line 428
  return;
}
}
#line 432 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/acquire.c"
static void read_from_socket(void *anything ) 
{ 
  int status___0 ;
  ReceiveBuffer msg ;
  union sockaddr_in46 his_addr___0 ;
  int sock_fd___0 ;
  socklen_t his_addr_len___0 ;
  int flags ;
  int message_length ;
  IPAddr remote_ip ;
  int i ;
  int ok ;
  struct timeval now ;
  SourceRecord___0 *src ;
  ssize_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 447
  flags = 0;
#line 448
  message_length = (int )sizeof(msg);
#line 449
  his_addr_len___0 = (socklen_t )sizeof(his_addr___0);
#line 452
  SCH_GetLastEventTime(& now, (double *)((void *)0), (struct timeval *)((void *)0));
#line 454
  sock_fd___0 = (int )((long )anything);
#line 455
  tmp = recvfrom(sock_fd___0, (void */* __restrict  */)((char *)(& msg)), (size_t )message_length,
                 flags, (struct sockaddr */* __restrict  */)(& his_addr___0.u), (socklen_t */* __restrict  */)(& his_addr_len___0));
#line 455
  status___0 = (int )tmp;
  }
#line 458
  if (status___0 < 0) {
    {
#line 459
    LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/acquire.c",
                 459, "read_from_socket");
#line 459
    tmp___0 = __errno_location();
#line 459
    tmp___1 = strerror(*tmp___0);
#line 459
    LOG_Line_Function((LOG_Severity )1, (LOG_Facility )13, "Error reading from socket, %s",
                      tmp___1);
    }
#line 460
    return;
  }
  {
#line 464
  if ((int )his_addr___0.u.sa_family == 2) {
#line 464
    goto case_2;
  }
#line 469
  if ((int )his_addr___0.u.sa_family == 10) {
#line 469
    goto case_10;
  }
#line 475
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 465
  remote_ip.family = (uint16_t )1;
#line 466
  remote_ip.addr.in4 = ntohl(his_addr___0.in4.sin_addr.s_addr);
  }
#line 467
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 470
  remote_ip.family = (uint16_t )2;
#line 471
  memcpy((void */* __restrict  */)(& remote_ip.addr.in6), (void const   */* __restrict  */)(his_addr___0.in6.sin6_addr.__in6_u.__u6_addr8),
         sizeof(remote_ip.addr.in6));
  }
#line 473
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 476
  __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/acquire.c",
                476U, "read_from_socket");
  }
  switch_break: /* CIL Label */ ;
  }
#line 484
  ok = 0;
#line 485
  i = 0;
  {
#line 485
  while (1) {
    while_continue: /* CIL Label */ ;
#line 485
    if (! (i < n_sources___2)) {
#line 485
      goto while_break;
    }
    {
#line 486
    tmp___2 = UTI_CompareIPs(& remote_ip, & (sources___0 + i)->ip_addr, (IPAddr *)((void *)0));
    }
#line 486
    if (tmp___2 == 0) {
#line 487
      ok = 1;
#line 488
      goto while_break;
    }
#line 485
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 492
  if (ok) {
#line 494
    src = sources___0 + i;
#line 495
    (src->n_total_samples) ++;
#line 497
    src->n_dead_probes = 0;
#line 501
    if (src->timer_running) {
      {
#line 502
      SCH_RemoveTimeout(src->timeout_id);
#line 503
      src->timer_running = 0;
      }
    }
    {
#line 506
    process_receive(& msg.ntp_pkt, src, & now);
    }
#line 509
    if (src->n_samples >= 4) {
#line 509
      goto _L;
    } else
#line 509
    if (src->n_total_samples >= 8) {
      _L: /* CIL Label */ 
#line 511
      n_completed_sources ++;
#line 515
      if (n_completed_sources == n_sources___2) {
        {
#line 516
        wind_up_acquisition();
        }
      }
    } else {
      {
#line 521
      probe_source(src);
      }
    }
  }
#line 526
  return;
}
}
#line 530 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/acquire.c"
static void start_next_source(void) 
{ 


  {
  {
#line 533
  probe_source(sources___0 + n_started_sources);
#line 537
  n_started_sources ++;
  }
#line 539
  if (n_started_sources < n_sources___2) {
    {
#line 540
    source_start_timeout_id = SCH_AddTimeoutByDelay(0.2, & start_source_timeout_handler,
                                                    (void *)0);
    }
  }
#line 542
  return;
}
}
#line 546 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/acquire.c"
static int endpoint_compare(void const   *a , void const   *b ) 
{ 
  Endpoint const   *aa ;
  Endpoint const   *bb ;

  {
#line 549
  aa = (Endpoint const   *)a;
#line 550
  bb = (Endpoint const   *)b;
#line 552
  if (aa->offset < bb->offset) {
#line 553
    return (-1);
  } else
#line 554
  if (aa->offset > bb->offset) {
#line 555
    return (1);
  } else {
#line 557
    return (0);
  }
}
}
#line 563 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/acquire.c"
static void process_measurements(void) 
{ 
  SourceRecord___0 *s ;
  Endpoint *eps ;
  int i ;
  int j ;
  int n_sane_sources ;
  double lo ;
  double hi ;
  double inter_lo ;
  double inter_hi ;
  int depth ;
  int best_depth ;
  int n_at_best_depth ;
  Interval *intervals ;
  double estimated_offset ;
  int index1 ;
  int index2 ;
  void *tmp ;
  void *tmp___0 ;
  char const   *tmp___1 ;
  double tmp___2 ;
  char const   *tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;

  {
#line 581
  n_sane_sources = 0;
#line 586
  i = 0;
  {
#line 586
  while (1) {
    while_continue: /* CIL Label */ ;
#line 586
    if (! (i < n_sources___2)) {
#line 586
      goto while_break;
    }
#line 587
    s = sources___0 + i;
#line 589
    if (s->n_samples == 0) {
#line 590
      s->sanity = 0;
    } else {
#line 592
      s->sanity = 1;
#line 593
      lo = s->offsets[0] - s->root_distances[0];
#line 594
      hi = s->offsets[0] + s->root_distances[0];
#line 595
      inter_lo = lo;
#line 596
      inter_hi = hi;
#line 597
      j = 1;
      {
#line 597
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 597
        if (! (j < s->n_samples)) {
#line 597
          goto while_break___0;
        }
#line 598
        lo = s->offsets[j] - s->root_distances[j];
#line 599
        hi = s->offsets[j] + s->root_distances[j];
#line 600
        if (inter_hi <= lo) {
#line 602
          s->sanity = 0;
#line 603
          goto while_break___0;
        } else
#line 600
        if (inter_lo >= hi) {
#line 602
          s->sanity = 0;
#line 603
          goto while_break___0;
        } else {
#line 605
          if (lo < inter_lo) {
#line 605
            inter_lo = inter_lo;
          } else {
#line 605
            inter_lo = lo;
          }
#line 606
          if (hi > inter_hi) {
#line 606
            inter_hi = inter_hi;
          } else {
#line 606
            inter_hi = hi;
          }
        }
#line 597
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 609
      if (s->sanity) {
#line 610
        s->inter_lo = inter_lo;
#line 611
        s->inter_hi = inter_hi;
      }
    }
#line 615
    if (s->sanity) {
#line 616
      n_sane_sources ++;
    }
#line 586
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 623
  tmp = malloc((unsigned long )(2 * n_sane_sources) * sizeof(Endpoint ));
#line 623
  eps = (Endpoint *)tmp;
#line 624
  tmp___0 = malloc((unsigned long )n_sane_sources * sizeof(Interval ));
#line 624
  intervals = (Interval *)tmp___0;
#line 626
  j = 0;
#line 627
  i = 0;
  }
  {
#line 627
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 627
    if (! (i < n_sources___2)) {
#line 627
      goto while_break___1;
    }
#line 628
    s = sources___0 + i;
#line 629
    if (s->sanity) {
#line 630
      (eps + j)->offset = s->inter_lo;
#line 631
      (eps + j)->type = (enum __anonenum_type_142 )0;
#line 632
      (eps + j)->index = i;
#line 633
      (eps + (j + 1))->offset = s->inter_hi;
#line 634
      (eps + (j + 1))->type = (enum __anonenum_type_142 )1;
#line 635
      (eps + (j + 1))->index = i;
#line 636
      j += 2;
    }
#line 627
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 640
  qsort((void *)eps, (size_t )(2 * n_sane_sources), sizeof(Endpoint ), & endpoint_compare);
#line 643
  depth = 0;
#line 643
  best_depth = depth;
#line 643
  n_at_best_depth = best_depth;
#line 644
  i = 0;
  }
  {
#line 644
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 644
    if (! (i < 2 * n_sane_sources)) {
#line 644
      goto while_break___2;
    }
    {
#line 655
    if ((unsigned int )(eps + i)->type == 0U) {
#line 655
      goto case_0;
    }
#line 669
    if ((unsigned int )(eps + i)->type == 1U) {
#line 669
      goto case_1;
    }
#line 654
    goto switch_break;
    case_0: /* CIL Label */ 
#line 656
    depth ++;
#line 657
    if (depth > best_depth) {
#line 658
      best_depth = depth;
#line 659
      n_at_best_depth = 0;
#line 660
      (intervals + 0)->lo = (eps + i)->offset;
    } else
#line 661
    if (depth == best_depth) {
#line 662
      (intervals + n_at_best_depth)->lo = (eps + i)->offset;
    }
#line 667
    goto switch_break;
    case_1: /* CIL Label */ 
#line 670
    if (depth == best_depth) {
#line 671
      (intervals + n_at_best_depth)->hi = (eps + i)->offset;
#line 672
      n_at_best_depth ++;
    }
#line 675
    depth --;
#line 677
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 644
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 682
  if (best_depth > 0) {
#line 683
    if (n_at_best_depth % 2 == 1) {
#line 684
      index1 = (n_at_best_depth - 1) / 2;
#line 685
      estimated_offset = 0.5 * ((intervals + index1)->lo + (intervals + index1)->hi);
    } else {
#line 687
      index2 = n_at_best_depth / 2;
#line 688
      index1 = index2 - 1;
#line 689
      estimated_offset = 0.5 * ((intervals + index1)->lo + (intervals + index2)->hi);
    }
    {
#line 698
    tmp___5 = fabs(estimated_offset);
    }
#line 698
    if (tmp___5 > init_slew_threshold) {
      {
#line 699
      LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/acquire.c",
                   699, "process_measurements");
      }
#line 699
      if (estimated_offset >= (double )0) {
#line 699
        tmp___1 = "fast";
      } else {
#line 699
        tmp___1 = "slow";
      }
      {
#line 699
      tmp___2 = fabs(estimated_offset);
#line 699
      LOG_Line_Function((LOG_Severity )0, (LOG_Facility )13, "System\'s initial offset : %.6f seconds %s of true (step)",
                        tmp___2, tmp___1);
#line 702
      LCL_ApplyStepOffset(estimated_offset);
      }
    } else {
      {
#line 704
      LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/acquire.c",
                   704, "process_measurements");
      }
#line 704
      if (estimated_offset >= (double )0) {
#line 704
        tmp___3 = "fast";
      } else {
#line 704
        tmp___3 = "slow";
      }
      {
#line 704
      tmp___4 = fabs(estimated_offset);
#line 704
      LOG_Line_Function((LOG_Severity )0, (LOG_Facility )13, "System\'s initial offset : %.6f seconds %s of true (slew)",
                        tmp___4, tmp___3);
#line 707
      LCL_AccumulateOffset(estimated_offset, 0.0);
      }
    }
  } else {
    {
#line 711
    LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/acquire.c",
                 711, "process_measurements");
#line 711
    LOG_Line_Function((LOG_Severity )1, (LOG_Facility )13, "No intersecting endpoints found");
    }
  }
  {
#line 714
  free((void *)intervals);
#line 715
  free((void *)eps);
  }
#line 717
  return;
}
}
#line 721 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/acquire.c"
static void wind_up_acquisition(void) 
{ 


  {
  {
#line 726
  process_measurements();
#line 728
  free((void *)sources___0);
#line 730
  finalise_io();
  }
#line 732
  if (saved_after_hook) {
    {
#line 733
    (*saved_after_hook)(saved_after_hook_anything);
    }
  }
#line 736
  return;
}
}
#line 740 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/acquire.c"
static void start_source_timeout_handler(void *not_used ) 
{ 


  {
  {
#line 744
  start_next_source();
  }
#line 745
  return;
}
}
#line 749 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/acquire.c"
void ACQ_StartAcquisition(int n , IPAddr *ip_addrs , double threshold , void (*after_hook)(void * ) ,
                          void *anything ) 
{ 
  int i ;
  int ip4 ;
  int ip6 ;
  int k ;
  int duplicate_ip ;
  void *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 756
  saved_after_hook = after_hook;
#line 757
  saved_after_hook_anything = anything;
#line 759
  init_slew_threshold = threshold;
#line 761
  n_started_sources = 0;
#line 762
  n_completed_sources = 0;
#line 763
  n_sources___2 = 0;
#line 764
  tmp = malloc((unsigned long )n * sizeof(SourceRecord___0 ));
#line 764
  sources___0 = (SourceRecord___0 *)tmp;
#line 766
  ip6 = 0;
#line 766
  ip4 = ip6;
#line 766
  i = ip4;
  }
  {
#line 766
  while (1) {
    while_continue: /* CIL Label */ ;
#line 766
    if (! (i < n)) {
#line 766
      goto while_break;
    }
#line 768
    duplicate_ip = 0;
#line 769
    k = 0;
    {
#line 769
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 769
      if (! (k < i)) {
#line 769
        goto while_break___0;
      }
      {
#line 770
      tmp___0 = UTI_CompareIPs(& (sources___0 + k)->ip_addr, ip_addrs + i, (IPAddr *)((void *)0));
#line 770
      duplicate_ip |= tmp___0 == 0;
#line 769
      k ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 774
    if (! duplicate_ip) {
#line 775
      (sources___0 + n_sources___2)->ip_addr = *(ip_addrs + i);
#line 776
      (sources___0 + n_sources___2)->n_samples = 0;
#line 777
      (sources___0 + n_sources___2)->n_total_samples = 0;
#line 778
      (sources___0 + n_sources___2)->n_dead_probes = 0;
#line 779
      if ((int )(ip_addrs + i)->family == 1) {
#line 780
        ip4 ++;
      } else
#line 781
      if ((int )(ip_addrs + i)->family == 2) {
#line 782
        ip6 ++;
      }
#line 783
      n_sources___2 ++;
    } else {
      {
#line 785
      LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/acquire.c",
                   785, "ACQ_StartAcquisition");
#line 785
      tmp___1 = UTI_IPToString(ip_addrs + i);
#line 785
      LOG_Line_Function((LOG_Severity )1, (LOG_Facility )13, "Ignoring duplicate source: %s",
                        tmp___1);
      }
    }
#line 766
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 790
  if (ip4) {
#line 790
    if (ip6) {
#line 790
      tmp___3 = 0;
    } else {
#line 790
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 790
    if (ip4) {
#line 790
      tmp___2 = 1;
    } else {
#line 790
      tmp___2 = 2;
    }
#line 790
    tmp___3 = tmp___2;
  }
  {
#line 790
  initialise_io(tmp___3);
#line 793
  start_next_source();
  }
#line 794
  return;
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.h"
unsigned short CNF_GetNTPPort(void) ;
#line 46
char *CNF_GetDriftFile(void) ;
#line 51
int CNF_GetLogStatistics(void) ;
#line 52
int CNF_GetLogTracking(void) ;
#line 65
void CNF_GetMakeStep(int *limit , double *threshold ) ;
#line 66
void CNF_GetMaxChange(int *delay , int *ignore , double *offset ) ;
#line 67
void CNF_GetLogChange(int *enabled___0 , double *threshold ) ;
#line 68
void CNF_GetMailOnChange(int *enabled___0 , double *threshold , char **user___0 ) ;
#line 71
void CNF_GetFallbackDrifts(int *min , int *max ) ;
#line 72
void CNF_GetBindAddress(int family , IPAddr *addr ) ;
#line 75
char *CNF_GetLeapSecTimezone(void) ;
#line 76
void CNF_GetLinuxHz(int *set , int *hz___0 ) ;
#line 77
void CNF_GetLinuxFreqScale(int *set , double *freq_scale___0 ) ;
#line 80
double CNF_GetMaxUpdateSkew(void) ;
#line 82
double CNF_GetCorrectionTimeRatio(void) ;
#line 88
int CNF_AllowLocalReference(int *stratum ) ;
#line 99
int CNF_GetMaxSamples(void) ;
#line 100
int CNF_GetMinSamples(void) ;
#line 83 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/util.h"
int UTI_StringToIP(char const   *addr , IPAddr *ip ) ;
#line 49 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static void parse_acquisitionport(char *line___0 ) ;
#line 50
static void parse_allow(char *line___0 ) ;
#line 51
static void parse_bindaddress(char *line___0 ) ;
#line 52
static void parse_bindcmdaddress(char *line___0 ) ;
#line 53
static void parse_broadcast(char *line___0 ) ;
#line 54
static void parse_clientloglimit(char *line___0 ) ;
#line 55
static void parse_cmdallow(char *line___0 ) ;
#line 56
static void parse_cmddeny(char *line___0 ) ;
#line 57
static void parse_cmdport(char *line___0 ) ;
#line 58
static void parse_combinelimit(char *line___0 ) ;
#line 59
static void parse_commandkey(char *line___0 ) ;
#line 60
static void parse_corrtimeratio(char *line___0 ) ;
#line 61
static void parse_deny(char *line___0 ) ;
#line 62
static void parse_driftfile(char *line___0 ) ;
#line 63
static void parse_dumpdir(char *line___0 ) ;
#line 64
static void parse_dumponexit(char *line___0 ) ;
#line 65
static void parse_fallbackdrift(char *line___0 ) ;
#line 66
static void parse_generatecommandkey(char *line___0 ) ;
#line 67
static void parse_include(char *line___0 ) ;
#line 68
static void parse_initstepslew(char *line___0 ) ;
#line 69
static void parse_keyfile(char *line___0 ) ;
#line 70
static void parse_leapsectz(char *line___0 ) ;
#line 71
static void parse_linux_freq_scale(char *line___0 ) ;
#line 72
static void parse_linux_hz(char *line___0 ) ;
#line 73
static void parse_local(char *line___0 ) ;
#line 74
static void parse_lockall(char *line___0 ) ;
#line 75
static void parse_log(char *line___0 ) ;
#line 76
static void parse_logbanner(char *line___0 ) ;
#line 77
static void parse_logchange(char *line___0 ) ;
#line 78
static void parse_logdir(char *line___0 ) ;
#line 79
static void parse_mailonchange(char *line___0 ) ;
#line 80
static void parse_makestep(char *line___0 ) ;
#line 81
static void parse_manual(char *line___0 ) ;
#line 82
static void parse_maxchange(char *line___0 ) ;
#line 83
static void parse_maxclockerror(char *line___0 ) ;
#line 84
static void parse_maxsamples(char *line___0 ) ;
#line 85
static void parse_maxupdateskew(char *line___0 ) ;
#line 86
static void parse_minsamples(char *line___0 ) ;
#line 87
static void parse_noclientlog(char *line___0 ) ;
#line 88
static void parse_peer(char *line___0 ) ;
#line 89
static void parse_pidfile(char *line___0 ) ;
#line 90
static void parse_port(char *line___0 ) ;
#line 91
static void parse_refclock(char *line___0 ) ;
#line 92
static void parse_reselectdist(char *line___0 ) ;
#line 93
static void parse_rtcdevice(char *line___0 ) ;
#line 94
static void parse_rtcfile(char *line___0 ) ;
#line 95
static void parse_rtconutc(char *line___0 ) ;
#line 96
static void parse_rtcsync(char *line___0 ) ;
#line 97
static void parse_sched_priority(char *line___0 ) ;
#line 98
static void parse_server(char *line___0 ) ;
#line 99
static void parse_stratumweight(char *line___0 ) ;
#line 100
static void parse_tempcomp(char *line___0 ) ;
#line 101
static void parse_user(char *line___0 ) ;
#line 106 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static int restarted  =    0;
#line 107 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static int generate_command_key  =    0;
#line 108 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static char *rtc_device  =    (char *)"/dev/rtc";
#line 109 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static int acquisition_port  =    0;
#line 110 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static int ntp_port  =    123;
#line 111 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static char *keys_file  =    (char *)((void *)0);
#line 112 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static char *drift_file  =    (char *)((void *)0);
#line 113 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static char *rtc_file  =    (char *)((void *)0);
#line 114 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static unsigned long command_key_id___0  ;
#line 115 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static double max_update_skew  =    1000.0;
#line 116 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static double correction_time_ratio  =    1.0;
#line 117 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static double max_clock_error___0  =    1.0;
#line 119 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static double reselect_distance___0  =    1e-4;
#line 120 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static double stratum_weight___0  =    1.0;
#line 121 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static double combine_limit___0  =    3.0;
#line 123 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static int cmd_port  =    323;
#line 125 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static int do_log_measurements  =    0;
#line 126 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static int do_log_statistics  =    0;
#line 127 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static int do_log_tracking  =    0;
#line 128 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static int do_log_rtc  =    0;
#line 129 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static int do_log_refclocks  =    0;
#line 130 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static int do_log_tempcomp  =    0;
#line 131 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static int do_dump_on_exit  =    0;
#line 132 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static int log_banner  =    32;
#line 133 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static char *logdir  =    (char *)".";
#line 134 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static char *dumpdir  =    (char *)".";
#line 136 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static int enable_local  =    0;
#line 137 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static int local_stratum  ;
#line 139 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static int do_init_stepslew  =    0;
#line 140 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static int n_init_srcs  ;
#line 144 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static double init_slew_threshold___0  ;
#line 146 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static IPAddr init_srcs_ip[8]  ;
#line 148 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static int enable_manual  =    0;
#line 152 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static int rtc_on_utc___0  =    0;
#line 155 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static int rtc_sync  =    0;
#line 158 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static int make_step_limit  =    0;
#line 159 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static double make_step_threshold  =    0.0;
#line 163 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static int max_offset_delay  =    -1;
#line 164 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static int max_offset_ignore  ;
#line 165 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static double max_offset  ;
#line 168 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static int max_samples___0  =    0;
#line 169 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static int min_samples___0  =    0;
#line 173 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static int do_log_change  =    0;
#line 174 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static double log_change_threshold  =    0.0;
#line 176 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static char *mail_user_on_change  =    (char *)((void *)0);
#line 177 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static double mail_change_threshold  =    0.0;
#line 181 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static int no_client_log  =    0;
#line 184 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static unsigned long client_log_limit  =    524288UL;
#line 187 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static int fb_drift_min  =    0;
#line 188 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static int fb_drift_max  =    0;
#line 192 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static IPAddr bind_address4  ;
#line 192 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static IPAddr bind_address6  ;
#line 196 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static IPAddr bind_cmd_address4  ;
#line 196 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static IPAddr bind_cmd_address6  ;
#line 200 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static char *pidfile  =    (char *)"/var/run/chronyd.pid";
#line 203 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static char *tempcomp_file  =    (char *)((void *)0);
#line 204 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static double tempcomp_interval  ;
#line 205 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static double tempcomp_T0  ;
#line 205 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static double tempcomp_k0  ;
#line 205 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static double tempcomp_k1  ;
#line 205 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static double tempcomp_k2  ;
#line 209 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static int set_linux_hz  =    0;
#line 210 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static int linux_hz  ;
#line 214 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static int set_linux_freq_scale  =    0;
#line 215 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static double linux_freq_scale  ;
#line 217 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static int sched_priority  =    0;
#line 218 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static int lock_memory  =    0;
#line 221 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static char *leapsec_tz  =    (char *)((void *)0);
#line 224 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static char *user  =    (char *)((void *)0);
#line 233 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static NTP_Source ntp_sources[64]  ;
#line 234 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static int n_ntp_sources  =    0;
#line 238 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static RefclockParameters refclock_sources[8]  ;
#line 239 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static int n_refclock_sources  =    0;
#line 250 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static AllowDeny ntp_auth_list  =    {& ntp_auth_list, & ntp_auth_list, {{.in6 = {(unsigned char)0, (unsigned char)0,
                                                (unsigned char)0, (unsigned char)0,
                                                (unsigned char)0, (unsigned char)0,
                                                (unsigned char)0, (unsigned char)0,
                                                (unsigned char)0, (unsigned char)0,
                                                (unsigned char)0, (unsigned char)0,
                                                (unsigned char)0, (unsigned char)0,
                                                (unsigned char)0, (unsigned char)0}},
                                       (unsigned short)0}, 0, 0, 0};
#line 251 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static AllowDeny cmd_auth_list  =    {& cmd_auth_list, & cmd_auth_list, {{.in6 = {(unsigned char)0, (unsigned char)0,
                                                (unsigned char)0, (unsigned char)0,
                                                (unsigned char)0, (unsigned char)0,
                                                (unsigned char)0, (unsigned char)0,
                                                (unsigned char)0, (unsigned char)0,
                                                (unsigned char)0, (unsigned char)0,
                                                (unsigned char)0, (unsigned char)0,
                                                (unsigned char)0, (unsigned char)0}},
                                       (unsigned short)0}, 0, 0, 0};
#line 260 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static NTP_Broadcast_Destination *broadcasts  =    (NTP_Broadcast_Destination *)((void *)0);
#line 261 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static int max_broadcasts  =    0;
#line 262 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static int n_broadcasts  =    0;
#line 267 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static int line_number  ;
#line 268 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static char const   *processed_file  ;
#line 269 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static char const   *processed_command  ;
#line 273 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static void command_parse_error(void) 
{ 


  {
  {
#line 276
  LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c", 276,
               "command_parse_error");
#line 276
  LOG_Fatal_Function((LOG_Facility )11, "Could not parse %s directive at line %d in file %s",
                     processed_command, line_number, processed_file);
  }
#line 278
  return;
}
}
#line 282 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static void other_parse_error(char const   *message ) 
{ 


  {
  {
#line 285
  LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c", 285,
               "other_parse_error");
#line 285
  LOG_Fatal_Function((LOG_Facility )11, "%s at line %d in file %s", message, line_number,
                     processed_file);
  }
#line 287
  return;
}
}
#line 291 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static void check_number_of_args(char *line___0 , int num ) 
{ 
  char const   *tmp ;

  {
#line 295
  if ((int )*line___0 == 32) {
#line 296
    line___0 ++;
  }
#line 297
  if (*line___0) {
#line 298
    num --;
  }
  {
#line 299
  while (1) {
    while_continue: /* CIL Label */ ;
#line 299
    if (! *line___0) {
#line 299
      goto while_break;
    }
#line 300
    if ((int )*line___0 == 32) {
#line 301
      num --;
    }
#line 299
    line___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 303
  if (num) {
    {
#line 304
    LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c", 304,
                 "check_number_of_args");
    }
#line 304
    if (num > 0) {
#line 304
      tmp = "Missing";
    } else {
#line 304
      tmp = "Too many";
    }
    {
#line 304
    LOG_Fatal_Function((LOG_Facility )11, "%s arguments for %s directive at line %d in file %s",
                       tmp, processed_command, line_number, processed_file);
    }
  }
#line 308
  return;
}
}
#line 312 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
void CNF_SetRestarted(int r ) 
{ 


  {
#line 315
  restarted = r;
#line 316
  return;
}
}
#line 321 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
void CNF_ReadFile(char const   *filename___0 ) 
{ 
  FILE *in ;
  char line___0[2048] ;
  char *p ;
  char *command ;
  char const   *prev_processed_file ;
  int prev_line_number ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  char *tmp___52 ;

  {
  {
#line 330
  in = fopen((char const   */* __restrict  */)filename___0, (char const   */* __restrict  */)"r");
  }
#line 331
  if (! in) {
    {
#line 332
    LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c", 332,
                 "CNF_ReadFile");
#line 332
    LOG_Fatal_Function((LOG_Facility )11, "Could not open configuration file %s",
                       filename___0);
    }
  } else {
#line 335
    prev_line_number = line_number;
#line 336
    prev_processed_file = processed_file;
#line 338
    line_number = 0;
#line 339
    processed_file = filename___0;
    {
#line 342
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 342
      tmp___52 = fgets((char */* __restrict  */)(line___0), (int )sizeof(line___0),
                       (FILE */* __restrict  */)in);
      }
#line 342
      if (! tmp___52) {
#line 342
        goto while_break;
      }
      {
#line 343
      line_number ++;
#line 346
      CPS_NormalizeLine(line___0);
      }
#line 349
      if (! line___0[0]) {
#line 350
        goto while_continue;
      }
      {
#line 353
      command = line___0;
#line 353
      processed_command = (char const   *)command;
#line 354
      p = CPS_SplitWord(line___0);
#line 356
      tmp___51 = strcasecmp((char const   *)command, "acquisitionport");
      }
#line 356
      if (tmp___51) {
        {
#line 358
        tmp___50 = strcasecmp((char const   *)command, "allow");
        }
#line 358
        if (tmp___50) {
          {
#line 360
          tmp___49 = strcasecmp((char const   *)command, "bindaddress");
          }
#line 360
          if (tmp___49) {
            {
#line 362
            tmp___48 = strcasecmp((char const   *)command, "bindcmdaddress");
            }
#line 362
            if (tmp___48) {
              {
#line 364
              tmp___47 = strcasecmp((char const   *)command, "broadcast");
              }
#line 364
              if (tmp___47) {
                {
#line 366
                tmp___46 = strcasecmp((char const   *)command, "clientloglimit");
                }
#line 366
                if (tmp___46) {
                  {
#line 368
                  tmp___45 = strcasecmp((char const   *)command, "cmdallow");
                  }
#line 368
                  if (tmp___45) {
                    {
#line 370
                    tmp___44 = strcasecmp((char const   *)command, "cmddeny");
                    }
#line 370
                    if (tmp___44) {
                      {
#line 372
                      tmp___43 = strcasecmp((char const   *)command, "cmdport");
                      }
#line 372
                      if (tmp___43) {
                        {
#line 374
                        tmp___42 = strcasecmp((char const   *)command, "combinelimit");
                        }
#line 374
                        if (tmp___42) {
                          {
#line 376
                          tmp___41 = strcasecmp((char const   *)command, "commandkey");
                          }
#line 376
                          if (tmp___41) {
                            {
#line 378
                            tmp___40 = strcasecmp((char const   *)command, "corrtimeratio");
                            }
#line 378
                            if (tmp___40) {
                              {
#line 380
                              tmp___39 = strcasecmp((char const   *)command, "deny");
                              }
#line 380
                              if (tmp___39) {
                                {
#line 382
                                tmp___38 = strcasecmp((char const   *)command, "driftfile");
                                }
#line 382
                                if (tmp___38) {
                                  {
#line 384
                                  tmp___37 = strcasecmp((char const   *)command, "dumpdir");
                                  }
#line 384
                                  if (tmp___37) {
                                    {
#line 386
                                    tmp___36 = strcasecmp((char const   *)command,
                                                          "dumponexit");
                                    }
#line 386
                                    if (tmp___36) {
                                      {
#line 388
                                      tmp___35 = strcasecmp((char const   *)command,
                                                            "fallbackdrift");
                                      }
#line 388
                                      if (tmp___35) {
                                        {
#line 390
                                        tmp___34 = strcasecmp((char const   *)command,
                                                              "generatecommandkey");
                                        }
#line 390
                                        if (tmp___34) {
                                          {
#line 392
                                          tmp___33 = strcasecmp((char const   *)command,
                                                                "include");
                                          }
#line 392
                                          if (tmp___33) {
                                            {
#line 394
                                            tmp___32 = strcasecmp((char const   *)command,
                                                                  "initstepslew");
                                            }
#line 394
                                            if (tmp___32) {
                                              {
#line 396
                                              tmp___31 = strcasecmp((char const   *)command,
                                                                    "keyfile");
                                              }
#line 396
                                              if (tmp___31) {
                                                {
#line 398
                                                tmp___30 = strcasecmp((char const   *)command,
                                                                      "leapsectz");
                                                }
#line 398
                                                if (tmp___30) {
                                                  {
#line 400
                                                  tmp___29 = strcasecmp((char const   *)command,
                                                                        "linux_freq_scale");
                                                  }
#line 400
                                                  if (tmp___29) {
                                                    {
#line 402
                                                    tmp___28 = strcasecmp((char const   *)command,
                                                                          "linux_hz");
                                                    }
#line 402
                                                    if (tmp___28) {
                                                      {
#line 404
                                                      tmp___27 = strcasecmp((char const   *)command,
                                                                            "local");
                                                      }
#line 404
                                                      if (tmp___27) {
                                                        {
#line 406
                                                        tmp___26 = strcasecmp((char const   *)command,
                                                                              "lock_all");
                                                        }
#line 406
                                                        if (tmp___26) {
                                                          {
#line 408
                                                          tmp___25 = strcasecmp((char const   *)command,
                                                                                "log");
                                                          }
#line 408
                                                          if (tmp___25) {
                                                            {
#line 410
                                                            tmp___24 = strcasecmp((char const   *)command,
                                                                                  "logbanner");
                                                            }
#line 410
                                                            if (tmp___24) {
                                                              {
#line 412
                                                              tmp___23 = strcasecmp((char const   *)command,
                                                                                    "logchange");
                                                              }
#line 412
                                                              if (tmp___23) {
                                                                {
#line 414
                                                                tmp___22 = strcasecmp((char const   *)command,
                                                                                      "logdir");
                                                                }
#line 414
                                                                if (tmp___22) {
                                                                  {
#line 416
                                                                  tmp___21 = strcasecmp((char const   *)command,
                                                                                        "mailonchange");
                                                                  }
#line 416
                                                                  if (tmp___21) {
                                                                    {
#line 418
                                                                    tmp___20 = strcasecmp((char const   *)command,
                                                                                          "makestep");
                                                                    }
#line 418
                                                                    if (tmp___20) {
                                                                      {
#line 420
                                                                      tmp___19 = strcasecmp((char const   *)command,
                                                                                            "manual");
                                                                      }
#line 420
                                                                      if (tmp___19) {
                                                                        {
#line 422
                                                                        tmp___18 = strcasecmp((char const   *)command,
                                                                                              "maxchange");
                                                                        }
#line 422
                                                                        if (tmp___18) {
                                                                          {
#line 424
                                                                          tmp___17 = strcasecmp((char const   *)command,
                                                                                                "maxclockerror");
                                                                          }
#line 424
                                                                          if (tmp___17) {
                                                                            {
#line 426
                                                                            tmp___16 = strcasecmp((char const   *)command,
                                                                                                  "maxsamples");
                                                                            }
#line 426
                                                                            if (tmp___16) {
                                                                              {
#line 428
                                                                              tmp___15 = strcasecmp((char const   *)command,
                                                                                                    "maxupdateskew");
                                                                              }
#line 428
                                                                              if (tmp___15) {
                                                                                {
#line 430
                                                                                tmp___14 = strcasecmp((char const   *)command,
                                                                                                      "minsamples");
                                                                                }
#line 430
                                                                                if (tmp___14) {
                                                                                  {
#line 432
                                                                                  tmp___13 = strcasecmp((char const   *)command,
                                                                                                        "noclientlog");
                                                                                  }
#line 432
                                                                                  if (tmp___13) {
                                                                                    {
#line 434
                                                                                    tmp___12 = strcasecmp((char const   *)command,
                                                                                                          "peer");
                                                                                    }
#line 434
                                                                                    if (tmp___12) {
                                                                                      {
#line 436
                                                                                      tmp___11 = strcasecmp((char const   *)command,
                                                                                                            "pidfile");
                                                                                      }
#line 436
                                                                                      if (tmp___11) {
                                                                                        {
#line 438
                                                                                        tmp___10 = strcasecmp((char const   *)command,
                                                                                                              "port");
                                                                                        }
#line 438
                                                                                        if (tmp___10) {
                                                                                          {
#line 440
                                                                                          tmp___9 = strcasecmp((char const   *)command,
                                                                                                               "refclock");
                                                                                          }
#line 440
                                                                                          if (tmp___9) {
                                                                                            {
#line 442
                                                                                            tmp___8 = strcasecmp((char const   *)command,
                                                                                                                 "reselectdist");
                                                                                            }
#line 442
                                                                                            if (tmp___8) {
                                                                                              {
#line 444
                                                                                              tmp___7 = strcasecmp((char const   *)command,
                                                                                                                   "rtcdevice");
                                                                                              }
#line 444
                                                                                              if (tmp___7) {
                                                                                                {
#line 446
                                                                                                tmp___6 = strcasecmp((char const   *)command,
                                                                                                                     "rtcfile");
                                                                                                }
#line 446
                                                                                                if (tmp___6) {
                                                                                                  {
#line 448
                                                                                                  tmp___5 = strcasecmp((char const   *)command,
                                                                                                                       "rtconutc");
                                                                                                  }
#line 448
                                                                                                  if (tmp___5) {
                                                                                                    {
#line 450
                                                                                                    tmp___4 = strcasecmp((char const   *)command,
                                                                                                                         "rtcsync");
                                                                                                    }
#line 450
                                                                                                    if (tmp___4) {
                                                                                                      {
#line 452
                                                                                                      tmp___3 = strcasecmp((char const   *)command,
                                                                                                                           "sched_priority");
                                                                                                      }
#line 452
                                                                                                      if (tmp___3) {
                                                                                                        {
#line 454
                                                                                                        tmp___2 = strcasecmp((char const   *)command,
                                                                                                                             "server");
                                                                                                        }
#line 454
                                                                                                        if (tmp___2) {
                                                                                                          {
#line 456
                                                                                                          tmp___1 = strcasecmp((char const   *)command,
                                                                                                                               "stratumweight");
                                                                                                          }
#line 456
                                                                                                          if (tmp___1) {
                                                                                                            {
#line 458
                                                                                                            tmp___0 = strcasecmp((char const   *)command,
                                                                                                                                 "tempcomp");
                                                                                                            }
#line 458
                                                                                                            if (tmp___0) {
                                                                                                              {
#line 460
                                                                                                              tmp = strcasecmp((char const   *)command,
                                                                                                                               "user");
                                                                                                              }
#line 460
                                                                                                              if (tmp) {
                                                                                                                {
#line 463
                                                                                                                other_parse_error("Invalid command");
                                                                                                                }
                                                                                                              } else {
                                                                                                                {
#line 461
                                                                                                                parse_user(p);
                                                                                                                }
                                                                                                              }
                                                                                                            } else {
                                                                                                              {
#line 459
                                                                                                              parse_tempcomp(p);
                                                                                                              }
                                                                                                            }
                                                                                                          } else {
                                                                                                            {
#line 457
                                                                                                            parse_stratumweight(p);
                                                                                                            }
                                                                                                          }
                                                                                                        } else {
                                                                                                          {
#line 455
                                                                                                          parse_server(p);
                                                                                                          }
                                                                                                        }
                                                                                                      } else {
                                                                                                        {
#line 453
                                                                                                        parse_sched_priority(p);
                                                                                                        }
                                                                                                      }
                                                                                                    } else {
                                                                                                      {
#line 451
                                                                                                      parse_rtcsync(p);
                                                                                                      }
                                                                                                    }
                                                                                                  } else {
                                                                                                    {
#line 449
                                                                                                    parse_rtconutc(p);
                                                                                                    }
                                                                                                  }
                                                                                                } else {
                                                                                                  {
#line 447
                                                                                                  parse_rtcfile(p);
                                                                                                  }
                                                                                                }
                                                                                              } else {
                                                                                                {
#line 445
                                                                                                parse_rtcdevice(p);
                                                                                                }
                                                                                              }
                                                                                            } else {
                                                                                              {
#line 443
                                                                                              parse_reselectdist(p);
                                                                                              }
                                                                                            }
                                                                                          } else {
                                                                                            {
#line 441
                                                                                            parse_refclock(p);
                                                                                            }
                                                                                          }
                                                                                        } else {
                                                                                          {
#line 439
                                                                                          parse_port(p);
                                                                                          }
                                                                                        }
                                                                                      } else {
                                                                                        {
#line 437
                                                                                        parse_pidfile(p);
                                                                                        }
                                                                                      }
                                                                                    } else {
                                                                                      {
#line 435
                                                                                      parse_peer(p);
                                                                                      }
                                                                                    }
                                                                                  } else {
                                                                                    {
#line 433
                                                                                    parse_noclientlog(p);
                                                                                    }
                                                                                  }
                                                                                } else {
                                                                                  {
#line 431
                                                                                  parse_minsamples(p);
                                                                                  }
                                                                                }
                                                                              } else {
                                                                                {
#line 429
                                                                                parse_maxupdateskew(p);
                                                                                }
                                                                              }
                                                                            } else {
                                                                              {
#line 427
                                                                              parse_maxsamples(p);
                                                                              }
                                                                            }
                                                                          } else {
                                                                            {
#line 425
                                                                            parse_maxclockerror(p);
                                                                            }
                                                                          }
                                                                        } else {
                                                                          {
#line 423
                                                                          parse_maxchange(p);
                                                                          }
                                                                        }
                                                                      } else {
                                                                        {
#line 421
                                                                        parse_manual(p);
                                                                        }
                                                                      }
                                                                    } else {
                                                                      {
#line 419
                                                                      parse_makestep(p);
                                                                      }
                                                                    }
                                                                  } else {
                                                                    {
#line 417
                                                                    parse_mailonchange(p);
                                                                    }
                                                                  }
                                                                } else {
                                                                  {
#line 415
                                                                  parse_logdir(p);
                                                                  }
                                                                }
                                                              } else {
                                                                {
#line 413
                                                                parse_logchange(p);
                                                                }
                                                              }
                                                            } else {
                                                              {
#line 411
                                                              parse_logbanner(p);
                                                              }
                                                            }
                                                          } else {
                                                            {
#line 409
                                                            parse_log(p);
                                                            }
                                                          }
                                                        } else {
                                                          {
#line 407
                                                          parse_lockall(p);
                                                          }
                                                        }
                                                      } else {
                                                        {
#line 405
                                                        parse_local(p);
                                                        }
                                                      }
                                                    } else {
                                                      {
#line 403
                                                      parse_linux_hz(p);
                                                      }
                                                    }
                                                  } else {
                                                    {
#line 401
                                                    parse_linux_freq_scale(p);
                                                    }
                                                  }
                                                } else {
                                                  {
#line 399
                                                  parse_leapsectz(p);
                                                  }
                                                }
                                              } else {
                                                {
#line 397
                                                parse_keyfile(p);
                                                }
                                              }
                                            } else {
                                              {
#line 395
                                              parse_initstepslew(p);
                                              }
                                            }
                                          } else {
                                            {
#line 393
                                            parse_include(p);
                                            }
                                          }
                                        } else {
                                          {
#line 391
                                          parse_generatecommandkey(p);
                                          }
                                        }
                                      } else {
                                        {
#line 389
                                        parse_fallbackdrift(p);
                                        }
                                      }
                                    } else {
                                      {
#line 387
                                      parse_dumponexit(p);
                                      }
                                    }
                                  } else {
                                    {
#line 385
                                    parse_dumpdir(p);
                                    }
                                  }
                                } else {
                                  {
#line 383
                                  parse_driftfile(p);
                                  }
                                }
                              } else {
                                {
#line 381
                                parse_deny(p);
                                }
                              }
                            } else {
                              {
#line 379
                              parse_corrtimeratio(p);
                              }
                            }
                          } else {
                            {
#line 377
                            parse_commandkey(p);
                            }
                          }
                        } else {
                          {
#line 375
                          parse_combinelimit(p);
                          }
                        }
                      } else {
                        {
#line 373
                        parse_cmdport(p);
                        }
                      }
                    } else {
                      {
#line 371
                      parse_cmddeny(p);
                      }
                    }
                  } else {
                    {
#line 369
                    parse_cmdallow(p);
                    }
                  }
                } else {
                  {
#line 367
                  parse_clientloglimit(p);
                  }
                }
              } else {
                {
#line 365
                parse_broadcast(p);
                }
              }
            } else {
              {
#line 363
              parse_bindcmdaddress(p);
              }
            }
          } else {
            {
#line 361
            parse_bindaddress(p);
            }
          }
        } else {
          {
#line 359
          parse_allow(p);
          }
        }
      } else {
        {
#line 357
        parse_acquisitionport(p);
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 467
    line_number = prev_line_number;
#line 468
    processed_file = prev_processed_file;
#line 469
    fclose(in);
    }
  }
#line 471
  return;
}
}
#line 475 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static void parse_source(char *line___0 , NTP_Source_Type type ) 
{ 
  CPS_Status status___0 ;

  {
#line 480
  if (n_ntp_sources >= 64) {
#line 481
    return;
  }
  {
#line 483
  ntp_sources[n_ntp_sources].type = type;
#line 484
  status___0 = CPS_ParseNTPSourceAdd(line___0, & ntp_sources[n_ntp_sources].params);
  }
  {
#line 487
  if ((unsigned int )status___0 == 0U) {
#line 487
    goto case_0;
  }
#line 490
  if ((unsigned int )status___0 == 1U) {
#line 490
    goto case_1;
  }
#line 493
  if ((unsigned int )status___0 == 2U) {
#line 493
    goto case_2;
  }
#line 496
  if ((unsigned int )status___0 == 3U) {
#line 496
    goto case_3;
  }
#line 499
  if ((unsigned int )status___0 == 4U) {
#line 499
    goto case_4;
  }
#line 502
  if ((unsigned int )status___0 == 5U) {
#line 502
    goto case_5;
  }
#line 505
  if ((unsigned int )status___0 == 6U) {
#line 505
    goto case_6;
  }
#line 508
  if ((unsigned int )status___0 == 7U) {
#line 508
    goto case_7;
  }
#line 511
  if ((unsigned int )status___0 == 8U) {
#line 511
    goto case_8;
  }
#line 514
  if ((unsigned int )status___0 == 9U) {
#line 514
    goto case_9;
  }
#line 517
  if ((unsigned int )status___0 == 10U) {
#line 517
    goto case_10;
  }
#line 520
  if ((unsigned int )status___0 == 11U) {
#line 520
    goto case_11;
  }
#line 523
  if ((unsigned int )status___0 == 12U) {
#line 523
    goto case_12;
  }
#line 486
  goto switch_break;
  case_0: /* CIL Label */ 
#line 488
  n_ntp_sources ++;
#line 489
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 491
  other_parse_error("Invalid server/peer parameter");
  }
#line 492
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 494
  other_parse_error("Invalid host/IP address");
  }
#line 495
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 497
  other_parse_error("Unreadable port");
  }
#line 498
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 500
  other_parse_error("Unreadable minpoll");
  }
#line 501
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 503
  other_parse_error("Unreadable maxpoll");
  }
#line 504
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 506
  other_parse_error("Unreadable presend");
  }
#line 507
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 509
  other_parse_error("Unreadable maxdelaydevratio");
  }
#line 510
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 512
  other_parse_error("Unreadable maxdelayratio");
  }
#line 513
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 515
  other_parse_error("Unreadable maxdelay");
  }
#line 516
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 518
  other_parse_error("Unreadable key");
  }
#line 519
  goto switch_break;
  case_11: /* CIL Label */ 
  {
#line 521
  other_parse_error("Unreadable minstratum");
  }
#line 522
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 524
  other_parse_error("Unreadable polltarget");
  }
#line 525
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 527
  return;
}
}
#line 531 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static void parse_sched_priority(char *line___0 ) 
{ 
  int tmp ;

  {
  {
#line 534
  check_number_of_args(line___0, 1);
#line 535
  tmp = sscanf((char const   */* __restrict  */)line___0, (char const   */* __restrict  */)"%d",
               & sched_priority);
  }
#line 535
  if (tmp != 1) {
    {
#line 536
    command_parse_error();
    }
  }
#line 538
  return;
}
}
#line 542 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static void parse_lockall(char *line___0 ) 
{ 


  {
  {
#line 545
  check_number_of_args(line___0, 0);
#line 546
  lock_memory = 1;
  }
#line 547
  return;
}
}
#line 551 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static void parse_server(char *line___0 ) 
{ 


  {
  {
#line 554
  parse_source(line___0, (NTP_Source_Type )0);
  }
#line 555
  return;
}
}
#line 559 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static void parse_peer(char *line___0 ) 
{ 


  {
  {
#line 562
  parse_source(line___0, (NTP_Source_Type )1);
  }
#line 563
  return;
}
}
#line 567 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static void parse_refclock(char *line___0 ) 
{ 
  int i ;
  int n ;
  int poll ;
  int dpoll ;
  int filter_length ;
  int pps_rate ;
  uint32_t ref_id ;
  uint32_t lock_ref_id ;
  double offset ;
  double delay ;
  double precision ;
  char *p ;
  char *cmd ;
  char *name ;
  char *param ;
  unsigned char ref[5] ;
  SRC_SelectOption sel_option ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;

  {
#line 577
  i = n_refclock_sources;
#line 578
  if (i >= 8) {
#line 579
    return;
  }
#line 581
  poll = 4;
#line 582
  dpoll = 0;
#line 583
  filter_length = 64;
#line 584
  pps_rate = 0;
#line 585
  offset = 0.0;
#line 586
  delay = 1e-9;
#line 587
  precision = 0.0;
#line 588
  ref_id = (uint32_t )0;
#line 589
  lock_ref_id = (uint32_t )0;
#line 590
  sel_option = (SRC_SelectOption )0;
#line 592
  if (! *line___0) {
    {
#line 593
    command_parse_error();
    }
#line 594
    return;
  }
  {
#line 597
  p = line___0;
#line 598
  line___0 = CPS_SplitWord(line___0);
  }
#line 600
  if (! *line___0) {
    {
#line 601
    command_parse_error();
    }
#line 602
    return;
  }
  {
#line 605
  name = strdup((char const   *)p);
#line 607
  p = line___0;
#line 608
  line___0 = CPS_SplitWord(line___0);
#line 609
  param = strdup((char const   *)p);
  }
  {
#line 611
  while (1) {
    while_continue: /* CIL Label */ ;
#line 611
    if (! *line___0) {
#line 611
      goto while_break;
    }
    {
#line 612
    cmd = line___0;
#line 613
    line___0 = CPS_SplitWord(line___0);
#line 614
    tmp___18 = strcasecmp((char const   *)cmd, "refid");
    }
#line 614
    if (tmp___18) {
      {
#line 618
      tmp___17 = strcasecmp((char const   *)cmd, "lock");
      }
#line 618
      if (tmp___17) {
        {
#line 622
        tmp___16 = strcasecmp((char const   *)cmd, "poll");
        }
#line 622
        if (tmp___16) {
          {
#line 626
          tmp___15 = strcasecmp((char const   *)cmd, "dpoll");
          }
#line 626
          if (tmp___15) {
            {
#line 630
            tmp___14 = strcasecmp((char const   *)cmd, "filter");
            }
#line 630
            if (tmp___14) {
              {
#line 634
              tmp___13 = strcasecmp((char const   *)cmd, "rate");
              }
#line 634
              if (tmp___13) {
                {
#line 637
                tmp___12 = strcasecmp((char const   *)cmd, "offset");
                }
#line 637
                if (tmp___12) {
                  {
#line 640
                  tmp___11 = strcasecmp((char const   *)cmd, "delay");
                  }
#line 640
                  if (tmp___11) {
                    {
#line 643
                    tmp___10 = strcasecmp((char const   *)cmd, "precision");
                    }
#line 643
                    if (tmp___10) {
                      {
#line 646
                      tmp___9 = strcasecmp((char const   *)cmd, "noselect");
                      }
#line 646
                      if (tmp___9) {
                        {
#line 649
                        tmp___8 = strcasecmp((char const   *)cmd, "prefer");
                        }
#line 649
                        if (tmp___8) {
#line 653
                          goto while_break;
                        } else {
#line 650
                          n = 0;
#line 651
                          sel_option = (SRC_SelectOption )2;
                        }
                      } else {
#line 647
                        n = 0;
#line 648
                        sel_option = (SRC_SelectOption )1;
                      }
                    } else {
                      {
#line 644
                      tmp___7 = sscanf((char const   */* __restrict  */)line___0,
                                       (char const   */* __restrict  */)"%lf%n", & precision,
                                       & n);
                      }
#line 644
                      if (tmp___7 != 1) {
#line 645
                        goto while_break;
                      }
                    }
                  } else {
                    {
#line 641
                    tmp___6 = sscanf((char const   */* __restrict  */)line___0, (char const   */* __restrict  */)"%lf%n",
                                     & delay, & n);
                    }
#line 641
                    if (tmp___6 != 1) {
#line 642
                      goto while_break;
                    }
                  }
                } else {
                  {
#line 638
                  tmp___5 = sscanf((char const   */* __restrict  */)line___0, (char const   */* __restrict  */)"%lf%n",
                                   & offset, & n);
                  }
#line 638
                  if (tmp___5 != 1) {
#line 639
                    goto while_break;
                  }
                }
              } else {
                {
#line 635
                tmp___4 = sscanf((char const   */* __restrict  */)line___0, (char const   */* __restrict  */)"%d%n",
                                 & pps_rate, & n);
                }
#line 635
                if (tmp___4 != 1) {
#line 636
                  goto while_break;
                }
              }
            } else {
              {
#line 631
              tmp___3 = sscanf((char const   */* __restrict  */)line___0, (char const   */* __restrict  */)"%d%n",
                               & filter_length, & n);
              }
#line 631
              if (tmp___3 != 1) {
#line 632
                goto while_break;
              }
            }
          } else {
            {
#line 627
            tmp___2 = sscanf((char const   */* __restrict  */)line___0, (char const   */* __restrict  */)"%d%n",
                             & dpoll, & n);
            }
#line 627
            if (tmp___2 != 1) {
#line 628
              goto while_break;
            }
          }
        } else {
          {
#line 623
          tmp___1 = sscanf((char const   */* __restrict  */)line___0, (char const   */* __restrict  */)"%d%n",
                           & poll, & n);
          }
#line 623
          if (tmp___1 != 1) {
#line 624
            goto while_break;
          }
        }
      } else {
        {
#line 619
        tmp___0 = sscanf((char const   */* __restrict  */)line___0, (char const   */* __restrict  */)"%4s%n",
                         (char *)(ref), & n);
        }
#line 619
        if (tmp___0 != 1) {
#line 620
          goto while_break;
        }
#line 621
        lock_ref_id = (uint32_t )(((((int )ref[0] << 24) | ((int )ref[1] << 16)) | ((int )ref[2] << 8)) | (int )ref[3]);
      }
    } else {
      {
#line 615
      tmp = sscanf((char const   */* __restrict  */)line___0, (char const   */* __restrict  */)"%4s%n",
                   (char *)(ref), & n);
      }
#line 615
      if (tmp != 1) {
#line 616
        goto while_break;
      }
#line 617
      ref_id = (uint32_t )(((((int )ref[0] << 24) | ((int )ref[1] << 16)) | ((int )ref[2] << 8)) | (int )ref[3]);
    }
#line 655
    line___0 += n;
  }
  while_break: /* CIL Label */ ;
  }
#line 658
  if (*line___0) {
    {
#line 659
    other_parse_error("Invalid/unreadable refclock parameter");
    }
#line 660
    return;
  }
#line 663
  refclock_sources[i].driver_name = name;
#line 664
  refclock_sources[i].driver_parameter = param;
#line 665
  refclock_sources[i].driver_poll = dpoll;
#line 666
  refclock_sources[i].poll = poll;
#line 667
  refclock_sources[i].filter_length = filter_length;
#line 668
  refclock_sources[i].pps_rate = pps_rate;
#line 669
  refclock_sources[i].offset = offset;
#line 670
  refclock_sources[i].delay = delay;
#line 671
  refclock_sources[i].precision = precision;
#line 672
  refclock_sources[i].sel_option = sel_option;
#line 673
  refclock_sources[i].ref_id = ref_id;
#line 674
  refclock_sources[i].lock_ref_id = lock_ref_id;
#line 676
  n_refclock_sources ++;
#line 677
  return;
}
}
#line 681 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static void parse_some_port(char *line___0 , int *portvar ) 
{ 
  int tmp ;

  {
  {
#line 684
  check_number_of_args(line___0, 1);
#line 685
  tmp = sscanf((char const   */* __restrict  */)line___0, (char const   */* __restrict  */)"%d",
               portvar);
  }
#line 685
  if (tmp != 1) {
    {
#line 686
    command_parse_error();
    }
  }
#line 688
  return;
}
}
#line 692 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static void parse_acquisitionport(char *line___0 ) 
{ 


  {
  {
#line 695
  parse_some_port(line___0, & acquisition_port);
  }
#line 696
  return;
}
}
#line 700 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static void parse_port(char *line___0 ) 
{ 


  {
  {
#line 703
  parse_some_port(line___0, & ntp_port);
  }
#line 704
  return;
}
}
#line 708 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static void parse_maxupdateskew(char *line___0 ) 
{ 
  int tmp ;

  {
  {
#line 711
  check_number_of_args(line___0, 1);
#line 712
  tmp = sscanf((char const   */* __restrict  */)line___0, (char const   */* __restrict  */)"%lf",
               & max_update_skew);
  }
#line 712
  if (tmp != 1) {
    {
#line 713
    command_parse_error();
    }
  }
#line 715
  return;
}
}
#line 719 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static void parse_maxclockerror(char *line___0 ) 
{ 
  int tmp ;

  {
  {
#line 722
  check_number_of_args(line___0, 1);
#line 723
  tmp = sscanf((char const   */* __restrict  */)line___0, (char const   */* __restrict  */)"%lf",
               & max_clock_error___0);
  }
#line 723
  if (tmp != 1) {
    {
#line 724
    command_parse_error();
    }
  }
#line 726
  return;
}
}
#line 730 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static void parse_corrtimeratio(char *line___0 ) 
{ 
  int tmp ;

  {
  {
#line 733
  check_number_of_args(line___0, 1);
#line 734
  tmp = sscanf((char const   */* __restrict  */)line___0, (char const   */* __restrict  */)"%lf",
               & correction_time_ratio);
  }
#line 734
  if (tmp != 1) {
    {
#line 735
    command_parse_error();
    }
  }
#line 737
  return;
}
}
#line 741 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static void parse_reselectdist(char *line___0 ) 
{ 
  int tmp ;

  {
  {
#line 744
  check_number_of_args(line___0, 1);
#line 745
  tmp = sscanf((char const   */* __restrict  */)line___0, (char const   */* __restrict  */)"%lf",
               & reselect_distance___0);
  }
#line 745
  if (tmp != 1) {
    {
#line 746
    command_parse_error();
    }
  }
#line 748
  return;
}
}
#line 752 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static void parse_stratumweight(char *line___0 ) 
{ 
  int tmp ;

  {
  {
#line 755
  check_number_of_args(line___0, 1);
#line 756
  tmp = sscanf((char const   */* __restrict  */)line___0, (char const   */* __restrict  */)"%lf",
               & stratum_weight___0);
  }
#line 756
  if (tmp != 1) {
    {
#line 757
    command_parse_error();
    }
  }
#line 759
  return;
}
}
#line 763 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static void parse_combinelimit(char *line___0 ) 
{ 
  int tmp ;

  {
  {
#line 766
  check_number_of_args(line___0, 1);
#line 767
  tmp = sscanf((char const   */* __restrict  */)line___0, (char const   */* __restrict  */)"%lf",
               & combine_limit___0);
  }
#line 767
  if (tmp != 1) {
    {
#line 768
    command_parse_error();
    }
  }
#line 770
  return;
}
}
#line 774 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static void parse_driftfile(char *line___0 ) 
{ 


  {
  {
#line 777
  check_number_of_args(line___0, 1);
#line 778
  drift_file = strdup((char const   *)line___0);
  }
#line 779
  return;
}
}
#line 783 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static void parse_keyfile(char *line___0 ) 
{ 


  {
  {
#line 786
  check_number_of_args(line___0, 1);
#line 787
  keys_file = strdup((char const   *)line___0);
  }
#line 788
  return;
}
}
#line 792 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static void parse_rtcfile(char *line___0 ) 
{ 


  {
  {
#line 795
  check_number_of_args(line___0, 1);
#line 796
  rtc_file = strdup((char const   *)line___0);
  }
#line 797
  return;
}
}
#line 801 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static void parse_rtcdevice(char *line___0 ) 
{ 


  {
  {
#line 804
  check_number_of_args(line___0, 1);
#line 805
  rtc_device = strdup((char const   *)line___0);
  }
#line 806
  return;
}
}
#line 810 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static void parse_logbanner(char *line___0 ) 
{ 
  int tmp ;

  {
  {
#line 813
  check_number_of_args(line___0, 1);
#line 814
  tmp = sscanf((char const   */* __restrict  */)line___0, (char const   */* __restrict  */)"%d",
               & log_banner);
  }
#line 814
  if (tmp != 1) {
    {
#line 815
    command_parse_error();
    }
  }
#line 817
  return;
}
}
#line 821 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static void parse_logdir(char *line___0 ) 
{ 


  {
  {
#line 824
  check_number_of_args(line___0, 1);
#line 825
  logdir = strdup((char const   *)line___0);
  }
#line 826
  return;
}
}
#line 830 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static void parse_maxsamples(char *line___0 ) 
{ 
  int tmp ;

  {
  {
#line 833
  check_number_of_args(line___0, 1);
#line 834
  tmp = sscanf((char const   */* __restrict  */)line___0, (char const   */* __restrict  */)"%d",
               & max_samples___0);
  }
#line 834
  if (tmp != 1) {
    {
#line 835
    command_parse_error();
    }
  }
#line 837
  return;
}
}
#line 841 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static void parse_minsamples(char *line___0 ) 
{ 
  int tmp ;

  {
  {
#line 844
  check_number_of_args(line___0, 1);
#line 845
  tmp = sscanf((char const   */* __restrict  */)line___0, (char const   */* __restrict  */)"%d",
               & min_samples___0);
  }
#line 845
  if (tmp != 1) {
    {
#line 846
    command_parse_error();
    }
  }
#line 848
  return;
}
}
#line 852 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static void parse_dumpdir(char *line___0 ) 
{ 


  {
  {
#line 855
  check_number_of_args(line___0, 1);
#line 856
  dumpdir = strdup((char const   *)line___0);
  }
#line 857
  return;
}
}
#line 861 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static void parse_dumponexit(char *line___0 ) 
{ 


  {
  {
#line 864
  check_number_of_args(line___0, 0);
#line 865
  do_dump_on_exit = 1;
  }
#line 866
  return;
}
}
#line 870 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static void parse_log(char *line___0 ) 
{ 
  char *log_name ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 874
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 875
    log_name = line___0;
#line 876
    line___0 = CPS_SplitWord(line___0);
    }
#line 877
    if (*log_name) {
      {
#line 878
      tmp___4 = strcmp((char const   *)log_name, "measurements");
      }
#line 878
      if (tmp___4) {
        {
#line 880
        tmp___3 = strcmp((char const   *)log_name, "statistics");
        }
#line 880
        if (tmp___3) {
          {
#line 882
          tmp___2 = strcmp((char const   *)log_name, "tracking");
          }
#line 882
          if (tmp___2) {
            {
#line 884
            tmp___1 = strcmp((char const   *)log_name, "rtc");
            }
#line 884
            if (tmp___1) {
              {
#line 886
              tmp___0 = strcmp((char const   *)log_name, "refclocks");
              }
#line 886
              if (tmp___0) {
                {
#line 888
                tmp = strcmp((char const   *)log_name, "tempcomp");
                }
#line 888
                if (tmp) {
                  {
#line 891
                  other_parse_error("Invalid log parameter");
                  }
#line 892
                  goto while_break;
                } else {
#line 889
                  do_log_tempcomp = 1;
                }
              } else {
#line 887
                do_log_refclocks = 1;
              }
            } else {
#line 885
              do_log_rtc = 1;
            }
          } else {
#line 883
            do_log_tracking = 1;
          }
        } else {
#line 881
          do_log_statistics = 1;
        }
      } else {
#line 879
        do_log_measurements = 1;
      }
    } else {
#line 895
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 898
  return;
}
}
#line 902 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static void parse_commandkey(char *line___0 ) 
{ 
  int tmp ;

  {
  {
#line 905
  check_number_of_args(line___0, 1);
#line 906
  tmp = sscanf((char const   */* __restrict  */)line___0, (char const   */* __restrict  */)"%lu",
               & command_key_id___0);
  }
#line 906
  if (tmp != 1) {
    {
#line 907
    command_parse_error();
    }
  }
#line 909
  return;
}
}
#line 913 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static void parse_local(char *line___0 ) 
{ 
  int stratum ;
  int tmp ;

  {
  {
#line 917
  tmp = sscanf((char const   */* __restrict  */)line___0, (char const   */* __restrict  */)"stratum%d",
               & stratum);
  }
#line 917
  if (tmp == 1) {
#line 918
    local_stratum = stratum;
#line 919
    enable_local = 1;
  } else {
    {
#line 921
    command_parse_error();
    }
  }
#line 923
  return;
}
}
#line 927 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static void parse_cmdport(char *line___0 ) 
{ 
  int tmp ;

  {
  {
#line 930
  check_number_of_args(line___0, 1);
#line 931
  tmp = sscanf((char const   */* __restrict  */)line___0, (char const   */* __restrict  */)"%d",
               & cmd_port);
  }
#line 931
  if (tmp != 1) {
    {
#line 932
    command_parse_error();
    }
  }
#line 934
  return;
}
}
#line 938 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static void parse_initstepslew(char *line___0 ) 
{ 
  char *p ;
  char *hostname ;
  IPAddr ip_addr ;
  int tmp ;
  DNS_Status tmp___0 ;

  {
#line 945
  if (restarted) {
#line 946
    return;
  }
  {
#line 949
  n_init_srcs = 0;
#line 950
  p = CPS_SplitWord(line___0);
#line 952
  tmp = sscanf((char const   */* __restrict  */)line___0, (char const   */* __restrict  */)"%lf",
               & init_slew_threshold___0);
  }
#line 952
  if (tmp != 1) {
    {
#line 953
    command_parse_error();
    }
#line 954
    return;
  }
  {
#line 957
  while (1) {
    while_continue: /* CIL Label */ ;
#line 957
    if (! *p) {
#line 957
      goto while_break;
    }
    {
#line 958
    hostname = p;
#line 959
    p = CPS_SplitWord(p);
    }
#line 960
    if (*hostname) {
      {
#line 961
      tmp___0 = DNS_Name2IPAddress((char const   *)hostname, & ip_addr);
      }
#line 961
      if ((unsigned int )tmp___0 == 0U) {
#line 962
        init_srcs_ip[n_init_srcs] = ip_addr;
#line 963
        n_init_srcs ++;
      } else {
        {
#line 965
        LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c",
                     965, "parse_initstepslew");
#line 965
        LOG_Line_Function((LOG_Severity )1, (LOG_Facility )11, "Could not resolve address of initstepslew server %s",
                          hostname);
        }
      }
#line 968
      if (n_init_srcs >= 8) {
        {
#line 969
        other_parse_error("Too many initstepslew servers");
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 973
  if (n_init_srcs > 0) {
#line 974
    do_init_stepslew = 1;
  }
#line 976
  return;
}
}
#line 980 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static void parse_manual(char *line___0 ) 
{ 


  {
  {
#line 983
  check_number_of_args(line___0, 0);
#line 984
  enable_manual = 1;
  }
#line 985
  return;
}
}
#line 989 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static void parse_rtconutc(char *line___0 ) 
{ 


  {
  {
#line 992
  check_number_of_args(line___0, 0);
#line 993
  rtc_on_utc___0 = 1;
  }
#line 994
  return;
}
}
#line 998 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static void parse_rtcsync(char *line___0 ) 
{ 


  {
  {
#line 1001
  check_number_of_args(line___0, 0);
#line 1002
  rtc_sync = 1;
  }
#line 1003
  return;
}
}
#line 1007 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static void parse_noclientlog(char *line___0 ) 
{ 


  {
  {
#line 1010
  check_number_of_args(line___0, 0);
#line 1011
  no_client_log = 1;
  }
#line 1012
  return;
}
}
#line 1016 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static void parse_clientloglimit(char *line___0 ) 
{ 
  int tmp ;

  {
  {
#line 1019
  check_number_of_args(line___0, 1);
#line 1020
  tmp = sscanf((char const   */* __restrict  */)line___0, (char const   */* __restrict  */)"%lu",
               & client_log_limit);
  }
#line 1020
  if (tmp != 1) {
    {
#line 1021
    command_parse_error();
    }
  }
#line 1024
  if (client_log_limit == 0UL) {
#line 1026
    client_log_limit = 0xffffffffffffffffUL;
  }
#line 1028
  return;
}
}
#line 1032 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static void parse_fallbackdrift(char *line___0 ) 
{ 
  int tmp ;

  {
  {
#line 1035
  check_number_of_args(line___0, 2);
#line 1036
  tmp = sscanf((char const   */* __restrict  */)line___0, (char const   */* __restrict  */)"%d %d",
               & fb_drift_min, & fb_drift_max);
  }
#line 1036
  if (tmp != 2) {
    {
#line 1037
    command_parse_error();
    }
  }
#line 1039
  return;
}
}
#line 1043 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static void parse_generatecommandkey(char *line___0 ) 
{ 


  {
  {
#line 1046
  check_number_of_args(line___0, 0);
#line 1047
  generate_command_key = 1;
  }
#line 1048
  return;
}
}
#line 1052 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static void parse_makestep(char *line___0 ) 
{ 
  int tmp ;

  {
  {
#line 1055
  check_number_of_args(line___0, 2);
#line 1056
  tmp = sscanf((char const   */* __restrict  */)line___0, (char const   */* __restrict  */)"%lf %d",
               & make_step_threshold, & make_step_limit);
  }
#line 1056
  if (tmp != 2) {
    {
#line 1057
    make_step_limit = 0;
#line 1058
    command_parse_error();
    }
  }
#line 1062
  if (restarted) {
#line 1062
    if (make_step_limit > 0) {
#line 1063
      make_step_limit = 0;
    }
  }
#line 1065
  return;
}
}
#line 1069 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static void parse_maxchange(char *line___0 ) 
{ 
  int tmp ;

  {
  {
#line 1072
  check_number_of_args(line___0, 3);
#line 1073
  tmp = sscanf((char const   */* __restrict  */)line___0, (char const   */* __restrict  */)"%lf %d %d",
               & max_offset, & max_offset_delay, & max_offset_ignore);
  }
#line 1073
  if (tmp != 3) {
    {
#line 1074
    max_offset_delay = -1;
#line 1075
    command_parse_error();
    }
  }
#line 1077
  return;
}
}
#line 1081 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static void parse_logchange(char *line___0 ) 
{ 
  int tmp ;

  {
  {
#line 1084
  check_number_of_args(line___0, 1);
#line 1085
  tmp = sscanf((char const   */* __restrict  */)line___0, (char const   */* __restrict  */)"%lf",
               & log_change_threshold);
  }
#line 1085
  if (tmp == 1) {
#line 1086
    do_log_change = 1;
  } else {
    {
#line 1088
    do_log_change = 0;
#line 1089
    command_parse_error();
    }
  }
#line 1091
  return;
}
}
#line 1096 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static void parse_mailonchange(char *line___0 ) 
{ 
  char *address ;
  int tmp ;

  {
  {
#line 1100
  check_number_of_args(line___0, 2);
#line 1101
  address = line___0;
#line 1102
  line___0 = CPS_SplitWord(line___0);
#line 1103
  tmp = sscanf((char const   */* __restrict  */)line___0, (char const   */* __restrict  */)"%lf",
               & mail_change_threshold);
  }
#line 1103
  if (tmp == 1) {
    {
#line 1104
    mail_user_on_change = strdup((char const   *)address);
    }
  } else {
    {
#line 1106
    mail_user_on_change = (char *)((void *)0);
#line 1107
    command_parse_error();
    }
  }
#line 1109
  return;
}
}
#line 1113 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static void parse_allow_deny(char *line___0 , AllowDeny *list , int allow ) 
{ 
  char *p ;
  unsigned long a ;
  unsigned long b ;
  unsigned long c ;
  unsigned long d ;
  unsigned long n ;
  int all ;
  AllowDeny *new_node ;
  IPAddr ip_addr ;
  int tmp ;
  void *tmp___0 ;
  char *slashpos ;
  void *tmp___1 ;
  int specified_subnet_bits ;
  int n___0 ;
  void *tmp___2 ;
  DNS_Status tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 1118
  all = 0;
#line 1119
  new_node = (AllowDeny *)((void *)0);
#line 1122
  p = line___0;
#line 1124
  tmp = strncmp((char const   *)p, "all", (size_t )3);
  }
#line 1124
  if (! tmp) {
    {
#line 1125
    all = 1;
#line 1126
    p = CPS_SplitWord(line___0);
    }
  }
#line 1129
  if (! *p) {
    {
#line 1131
    tmp___0 = malloc(sizeof(AllowDeny ));
#line 1131
    new_node = (AllowDeny *)tmp___0;
#line 1132
    new_node->allow = allow;
#line 1133
    new_node->all = all;
#line 1134
    new_node->ip.family = (uint16_t )0;
#line 1135
    new_node->subnet_bits = 0;
    }
  } else {
    {
#line 1138
    slashpos = strchr((char const   *)p, '/');
    }
#line 1139
    if (slashpos) {
#line 1139
      *slashpos = (char)0;
    }
    {
#line 1141
    check_number_of_args(p, 1);
#line 1142
    n = 0UL;
#line 1143
    tmp___4 = UTI_StringToIP((char const   *)p, & ip_addr);
    }
#line 1143
    if (tmp___4) {
#line 1143
      goto _L;
    } else {
      {
#line 1143
      tmp___5 = sscanf((char const   */* __restrict  */)p, (char const   */* __restrict  */)"%lu.%lu.%lu.%lu",
                       & a, & b, & c, & d);
#line 1143
      n = (unsigned long )tmp___5;
      }
#line 1143
      if (n >= 1UL) {
        _L: /* CIL Label */ 
        {
#line 1145
        tmp___1 = malloc(sizeof(AllowDeny ));
#line 1145
        new_node = (AllowDeny *)tmp___1;
#line 1146
        new_node->allow = allow;
#line 1147
        new_node->all = all;
        }
#line 1149
        if (n == 0UL) {
#line 1150
          new_node->ip = ip_addr;
#line 1151
          if ((int )ip_addr.family == 2) {
#line 1152
            new_node->subnet_bits = 128;
          } else {
#line 1154
            new_node->subnet_bits = 32;
          }
        } else {
#line 1156
          new_node->ip.family = (uint16_t )1;
#line 1158
          a &= 255UL;
#line 1159
          b &= 255UL;
#line 1160
          c &= 255UL;
#line 1161
          d &= 255UL;
          {
#line 1164
          if (n == 1UL) {
#line 1164
            goto case_1;
          }
#line 1168
          if (n == 2UL) {
#line 1168
            goto case_2;
          }
#line 1172
          if (n == 3UL) {
#line 1172
            goto case_3;
          }
#line 1176
          if (n == 4UL) {
#line 1176
            goto case_4;
          }
#line 1180
          goto switch_default;
          case_1: /* CIL Label */ 
#line 1165
          new_node->ip.addr.in4 = (uint32_t )(a << 24);
#line 1166
          new_node->subnet_bits = 8;
#line 1167
          goto switch_break;
          case_2: /* CIL Label */ 
#line 1169
          new_node->ip.addr.in4 = (uint32_t )((a << 24) | (b << 16));
#line 1170
          new_node->subnet_bits = 16;
#line 1171
          goto switch_break;
          case_3: /* CIL Label */ 
#line 1173
          new_node->ip.addr.in4 = (uint32_t )(((a << 24) | (b << 16)) | (c << 8));
#line 1174
          new_node->subnet_bits = 24;
#line 1175
          goto switch_break;
          case_4: /* CIL Label */ 
#line 1177
          new_node->ip.addr.in4 = (uint32_t )((((a << 24) | (b << 16)) | (c << 8)) | d);
#line 1178
          new_node->subnet_bits = 32;
#line 1179
          goto switch_break;
          switch_default: /* CIL Label */ 
          {
#line 1181
          __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c",
                        1181U, "parse_allow_deny");
          }
          switch_break: /* CIL Label */ ;
          }
        }
#line 1185
        if (slashpos) {
          {
#line 1187
          n___0 = sscanf((char const   */* __restrict  */)(slashpos + 1), (char const   */* __restrict  */)"%d",
                         & specified_subnet_bits);
          }
#line 1188
          if (n___0 == 1) {
#line 1189
            new_node->subnet_bits = specified_subnet_bits;
          } else {
            {
#line 1191
            command_parse_error();
            }
          }
        }
      } else {
        {
#line 1196
        tmp___3 = DNS_Name2IPAddress((char const   *)p, & ip_addr);
        }
#line 1196
        if ((unsigned int )tmp___3 == 0U) {
          {
#line 1197
          tmp___2 = malloc(sizeof(AllowDeny ));
#line 1197
          new_node = (AllowDeny *)tmp___2;
#line 1198
          new_node->allow = allow;
#line 1199
          new_node->all = all;
#line 1200
          new_node->ip = ip_addr;
          }
#line 1201
          if ((int )ip_addr.family == 2) {
#line 1202
            new_node->subnet_bits = 128;
          } else {
#line 1204
            new_node->subnet_bits = 32;
          }
        } else {
          {
#line 1206
          command_parse_error();
          }
        }
      }
    }
  }
#line 1211
  if (new_node) {
#line 1212
    new_node->prev = list->prev;
#line 1213
    new_node->next = list;
#line 1214
    (list->prev)->next = new_node;
#line 1215
    list->prev = new_node;
  }
#line 1218
  return;
}
}
#line 1223 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static void parse_allow(char *line___0 ) 
{ 


  {
  {
#line 1226
  parse_allow_deny(line___0, & ntp_auth_list, 1);
  }
#line 1227
  return;
}
}
#line 1232 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static void parse_deny(char *line___0 ) 
{ 


  {
  {
#line 1235
  parse_allow_deny(line___0, & ntp_auth_list, 0);
  }
#line 1236
  return;
}
}
#line 1240 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static void parse_cmdallow(char *line___0 ) 
{ 


  {
  {
#line 1243
  parse_allow_deny(line___0, & cmd_auth_list, 1);
  }
#line 1244
  return;
}
}
#line 1249 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static void parse_cmddeny(char *line___0 ) 
{ 


  {
  {
#line 1252
  parse_allow_deny(line___0, & cmd_auth_list, 0);
  }
#line 1253
  return;
}
}
#line 1257 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static void parse_bindaddress(char *line___0 ) 
{ 
  IPAddr ip ;
  int tmp ;

  {
  {
#line 1262
  check_number_of_args(line___0, 1);
#line 1263
  tmp = UTI_StringToIP((char const   *)line___0, & ip);
  }
#line 1263
  if (tmp) {
#line 1264
    if ((int )ip.family == 1) {
#line 1265
      bind_address4 = ip;
    } else
#line 1266
    if ((int )ip.family == 2) {
#line 1267
      bind_address6 = ip;
    }
  } else {
    {
#line 1269
    command_parse_error();
    }
  }
#line 1271
  return;
}
}
#line 1275 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static void parse_bindcmdaddress(char *line___0 ) 
{ 
  IPAddr ip ;
  int tmp ;

  {
  {
#line 1280
  check_number_of_args(line___0, 1);
#line 1281
  tmp = UTI_StringToIP((char const   *)line___0, & ip);
  }
#line 1281
  if (tmp) {
#line 1282
    if ((int )ip.family == 1) {
#line 1283
      bind_cmd_address4 = ip;
    } else
#line 1284
    if ((int )ip.family == 2) {
#line 1285
      bind_cmd_address6 = ip;
    }
  } else {
    {
#line 1287
    command_parse_error();
    }
  }
#line 1289
  return;
}
}
#line 1293 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static void parse_pidfile(char *line___0 ) 
{ 


  {
  {
#line 1296
  check_number_of_args(line___0, 1);
#line 1297
  pidfile = strdup((char const   *)line___0);
  }
#line 1298
  return;
}
}
#line 1302 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static void parse_broadcast(char *line___0 ) 
{ 
  int port ;
  int interval ;
  char *p ;
  IPAddr ip ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 1311
  p = line___0;
#line 1312
  line___0 = CPS_SplitWord(line___0);
#line 1314
  tmp = sscanf((char const   */* __restrict  */)p, (char const   */* __restrict  */)"%d",
               & interval);
  }
#line 1314
  if (tmp != 1) {
    {
#line 1315
    command_parse_error();
    }
#line 1316
    return;
  }
  {
#line 1319
  p = line___0;
#line 1320
  line___0 = CPS_SplitWord(line___0);
#line 1322
  tmp___0 = UTI_StringToIP((char const   *)p, & ip);
  }
#line 1322
  if (! tmp___0) {
    {
#line 1323
    command_parse_error();
    }
#line 1324
    return;
  }
  {
#line 1327
  p = line___0;
#line 1328
  line___0 = CPS_SplitWord(line___0);
  }
#line 1330
  if (*p) {
    {
#line 1331
    tmp___1 = sscanf((char const   */* __restrict  */)p, (char const   */* __restrict  */)"%d",
                     & port);
    }
#line 1331
    if (tmp___1 != 1) {
      {
#line 1332
      command_parse_error();
      }
#line 1333
      return;
    } else
#line 1331
    if (*line___0) {
      {
#line 1332
      command_parse_error();
      }
#line 1333
      return;
    }
  } else {
#line 1337
    port = 123;
  }
#line 1340
  if (max_broadcasts == n_broadcasts) {
#line 1342
    max_broadcasts += 8;
#line 1343
    if (broadcasts) {
      {
#line 1344
      tmp___2 = realloc((void *)broadcasts, (unsigned long )max_broadcasts * sizeof(NTP_Broadcast_Destination ));
#line 1344
      broadcasts = (NTP_Broadcast_Destination *)tmp___2;
      }
    } else {
      {
#line 1346
      tmp___3 = malloc((unsigned long )max_broadcasts * sizeof(NTP_Broadcast_Destination ));
#line 1346
      broadcasts = (NTP_Broadcast_Destination *)tmp___3;
      }
    }
  }
#line 1350
  (broadcasts + n_broadcasts)->addr = ip;
#line 1351
  (broadcasts + n_broadcasts)->port = (unsigned short )port;
#line 1352
  (broadcasts + n_broadcasts)->interval = interval;
#line 1353
  n_broadcasts ++;
#line 1354
  return;
}
}
#line 1358 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static void parse_tempcomp(char *line___0 ) 
{ 
  char *p ;
  int tmp ;

  {
  {
#line 1363
  check_number_of_args(line___0, 6);
#line 1364
  p = line___0;
#line 1365
  line___0 = CPS_SplitWord(line___0);
  }
#line 1367
  if (! *p) {
    {
#line 1368
    command_parse_error();
    }
#line 1369
    return;
  }
  {
#line 1372
  tmp = sscanf((char const   */* __restrict  */)line___0, (char const   */* __restrict  */)"%lf %lf %lf %lf %lf",
               & tempcomp_interval, & tempcomp_T0, & tempcomp_k0, & tempcomp_k1, & tempcomp_k2);
  }
#line 1372
  if (tmp != 5) {
    {
#line 1373
    command_parse_error();
    }
#line 1374
    return;
  }
  {
#line 1377
  tempcomp_file = strdup((char const   *)p);
  }
#line 1378
  return;
}
}
#line 1382 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static void parse_include(char *line___0 ) 
{ 


  {
  {
#line 1385
  check_number_of_args(line___0, 1);
#line 1386
  CNF_ReadFile((char const   *)line___0);
  }
#line 1387
  return;
}
}
#line 1391 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static void parse_leapsectz(char *line___0 ) 
{ 


  {
  {
#line 1394
  check_number_of_args(line___0, 1);
#line 1395
  leapsec_tz = strdup((char const   *)line___0);
  }
#line 1396
  return;
}
}
#line 1400 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static void parse_linux_hz(char *line___0 ) 
{ 
  int tmp ;

  {
  {
#line 1403
  check_number_of_args(line___0, 1);
#line 1404
  tmp = sscanf((char const   */* __restrict  */)line___0, (char const   */* __restrict  */)"%d",
               & linux_hz);
  }
#line 1404
  if (1 == tmp) {
#line 1405
    set_linux_hz = 1;
  } else {
    {
#line 1407
    command_parse_error();
    }
  }
#line 1409
  return;
}
}
#line 1413 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static void parse_linux_freq_scale(char *line___0 ) 
{ 
  int tmp ;

  {
  {
#line 1416
  check_number_of_args(line___0, 1);
#line 1417
  tmp = sscanf((char const   */* __restrict  */)line___0, (char const   */* __restrict  */)"%lf",
               & linux_freq_scale);
  }
#line 1417
  if (1 == tmp) {
#line 1418
    set_linux_freq_scale = 1;
  } else {
    {
#line 1420
    command_parse_error();
    }
  }
#line 1422
  return;
}
}
#line 1426 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
static void parse_user(char *line___0 ) 
{ 


  {
  {
#line 1429
  check_number_of_args(line___0, 1);
#line 1430
  user = strdup((char const   *)line___0);
  }
#line 1431
  return;
}
}
#line 1435 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
void CNF_ProcessInitStepSlew(void (*after_hook)(void * ) , void *anything ) 
{ 


  {
#line 1438
  if (do_init_stepslew) {
    {
#line 1439
    ACQ_StartAcquisition(n_init_srcs, init_srcs_ip, init_slew_threshold___0, after_hook,
                         anything);
    }
  } else {
    {
#line 1441
    (*after_hook)(anything);
    }
  }
#line 1443
  return;
}
}
#line 1447 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
void CNF_AddSources(void) 
{ 
  int i ;

  {
#line 1451
  i = 0;
  {
#line 1451
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1451
    if (! (i < n_ntp_sources)) {
#line 1451
      goto while_break;
    }
    {
#line 1452
    NSR_AddUnresolvedSource(ntp_sources[i].params.name, (int )ntp_sources[i].params.port,
                            ntp_sources[i].type, & ntp_sources[i].params.params);
#line 1451
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1456
  NSR_ResolveSources();
  }
#line 1457
  return;
}
}
#line 1461 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
void CNF_AddRefclocks(void) 
{ 
  int i ;

  {
#line 1465
  i = 0;
  {
#line 1465
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1465
    if (! (i < n_refclock_sources)) {
#line 1465
      goto while_break;
    }
    {
#line 1466
    RCL_AddRefclock(& refclock_sources[i]);
#line 1465
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1468
  return;
}
}
#line 1472 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
void CNF_AddBroadcasts(void) 
{ 
  int i ;

  {
#line 1476
  i = 0;
  {
#line 1476
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1476
    if (! (i < n_broadcasts)) {
#line 1476
      goto while_break;
    }
    {
#line 1477
    BRD_AddDestination(& (broadcasts + i)->addr, (broadcasts + i)->port, (broadcasts + i)->interval);
#line 1476
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1481
  return;
}
}
#line 1485 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
unsigned short CNF_GetNTPPort(void) 
{ 


  {
#line 1488
  return ((unsigned short )ntp_port);
}
}
#line 1493 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
unsigned short CNF_GetAcquisitionPort(void) 
{ 


  {
#line 1496
  return ((unsigned short )acquisition_port);
}
}
#line 1501 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
char *CNF_GetDriftFile(void) 
{ 


  {
#line 1504
  return (drift_file);
}
}
#line 1509 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
int CNF_GetLogBanner(void) 
{ 


  {
#line 1512
  return (log_banner);
}
}
#line 1517 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
char *CNF_GetLogDir(void) 
{ 


  {
#line 1520
  return (logdir);
}
}
#line 1525 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
char *CNF_GetDumpDir(void) 
{ 


  {
#line 1528
  return (dumpdir);
}
}
#line 1533 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
int CNF_GetLogMeasurements(void) 
{ 


  {
#line 1536
  return (do_log_measurements);
}
}
#line 1541 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
int CNF_GetLogStatistics(void) 
{ 


  {
#line 1544
  return (do_log_statistics);
}
}
#line 1549 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
int CNF_GetLogTracking(void) 
{ 


  {
#line 1552
  return (do_log_tracking);
}
}
#line 1557 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
int CNF_GetLogRtc(void) 
{ 


  {
#line 1560
  return (do_log_rtc);
}
}
#line 1565 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
int CNF_GetLogRefclocks(void) 
{ 


  {
#line 1568
  return (do_log_refclocks);
}
}
#line 1573 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
int CNF_GetLogTempComp(void) 
{ 


  {
#line 1576
  return (do_log_tempcomp);
}
}
#line 1581 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
char *CNF_GetKeysFile(void) 
{ 


  {
#line 1584
  return (keys_file);
}
}
#line 1589 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
char *CNF_GetRtcFile(void) 
{ 


  {
#line 1592
  return (rtc_file);
}
}
#line 1597 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
char *CNF_GetRtcDevice(void) 
{ 


  {
#line 1600
  return (rtc_device);
}
}
#line 1605 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
unsigned long CNF_GetCommandKey(void) 
{ 


  {
#line 1608
  return (command_key_id___0);
}
}
#line 1613 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
int CNF_GetGenerateCommandKey(void) 
{ 


  {
#line 1616
  return (generate_command_key);
}
}
#line 1621 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
int CNF_GetDumpOnExit(void) 
{ 


  {
#line 1624
  return (do_dump_on_exit);
}
}
#line 1629 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
double CNF_GetMaxUpdateSkew(void) 
{ 


  {
#line 1632
  return (max_update_skew);
}
}
#line 1637 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
double CNF_GetMaxClockError(void) 
{ 


  {
#line 1640
  return (max_clock_error___0);
}
}
#line 1645 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
double CNF_GetCorrectionTimeRatio(void) 
{ 


  {
#line 1648
  return (correction_time_ratio);
}
}
#line 1653 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
double CNF_GetReselectDistance(void) 
{ 


  {
#line 1656
  return (reselect_distance___0);
}
}
#line 1661 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
double CNF_GetStratumWeight(void) 
{ 


  {
#line 1664
  return (stratum_weight___0);
}
}
#line 1669 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
double CNF_GetCombineLimit(void) 
{ 


  {
#line 1672
  return (combine_limit___0);
}
}
#line 1677 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
int CNF_GetManualEnabled(void) 
{ 


  {
#line 1680
  return (enable_manual);
}
}
#line 1685 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
int CNF_GetCommandPort(void) 
{ 


  {
#line 1687
  return (cmd_port);
}
}
#line 1692 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
int CNF_AllowLocalReference(int *stratum ) 
{ 


  {
#line 1695
  if (enable_local) {
#line 1696
    *stratum = local_stratum;
#line 1697
    return (1);
  } else {
#line 1699
    return (0);
  }
}
}
#line 1705 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
int CNF_GetRTCOnUTC(void) 
{ 


  {
#line 1708
  return (rtc_on_utc___0);
}
}
#line 1713 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
int CNF_GetRTCSync(void) 
{ 


  {
#line 1716
  return (rtc_sync);
}
}
#line 1721 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
void CNF_GetMakeStep(int *limit , double *threshold ) 
{ 


  {
#line 1724
  *limit = make_step_limit;
#line 1725
  *threshold = make_step_threshold;
#line 1726
  return;
}
}
#line 1730 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
void CNF_GetMaxChange(int *delay , int *ignore , double *offset ) 
{ 


  {
#line 1733
  *delay = max_offset_delay;
#line 1734
  *ignore = max_offset_ignore;
#line 1735
  *offset = max_offset;
#line 1736
  return;
}
}
#line 1740 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
void CNF_GetLogChange(int *enabled___0 , double *threshold ) 
{ 


  {
#line 1743
  *enabled___0 = do_log_change;
#line 1744
  *threshold = log_change_threshold;
#line 1745
  return;
}
}
#line 1749 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
void CNF_GetMailOnChange(int *enabled___0 , double *threshold , char **user___0 ) 
{ 


  {
#line 1752
  if (mail_user_on_change) {
#line 1753
    *enabled___0 = 1;
#line 1754
    *threshold = mail_change_threshold;
#line 1755
    *user___0 = mail_user_on_change;
  } else {
#line 1757
    *enabled___0 = 0;
#line 1758
    *threshold = 0.0;
#line 1759
    *user___0 = (char *)((void *)0);
  }
#line 1761
  return;
}
}
#line 1765 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
void CNF_SetupAccessRestrictions(void) 
{ 
  AllowDeny *node ;
  int status___0 ;

  {
#line 1771
  node = ntp_auth_list.next;
  {
#line 1771
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1771
    if (! ((unsigned long )node != (unsigned long )(& ntp_auth_list))) {
#line 1771
      goto while_break;
    }
    {
#line 1772
    status___0 = NCR_AddAccessRestriction(& node->ip, node->subnet_bits, node->allow,
                                          node->all);
    }
#line 1773
    if (! status___0) {
      {
#line 1774
      LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c",
                   1774, "CNF_SetupAccessRestrictions");
#line 1774
      LOG_Fatal_Function((LOG_Facility )11, "Bad subnet for %08lx", node->ip);
      }
    }
#line 1771
    node = node->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1778
  node = cmd_auth_list.next;
  {
#line 1778
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1778
    if (! ((unsigned long )node != (unsigned long )(& cmd_auth_list))) {
#line 1778
      goto while_break___0;
    }
    {
#line 1779
    status___0 = CAM_AddAccessRestriction(& node->ip, node->subnet_bits, node->allow,
                                          node->all);
    }
#line 1780
    if (! status___0) {
      {
#line 1781
      LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c",
                   1781, "CNF_SetupAccessRestrictions");
#line 1781
      LOG_Fatal_Function((LOG_Facility )11, "Bad subnet for %08lx", node->ip);
      }
    }
#line 1778
    node = node->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1784
  return;
}
}
#line 1788 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
int CNF_GetNoClientLog(void) 
{ 


  {
#line 1791
  return (no_client_log);
}
}
#line 1796 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
unsigned long CNF_GetClientLogLimit(void) 
{ 


  {
#line 1799
  return (client_log_limit);
}
}
#line 1804 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
void CNF_GetFallbackDrifts(int *min , int *max ) 
{ 


  {
#line 1807
  *min = fb_drift_min;
#line 1808
  *max = fb_drift_max;
#line 1809
  return;
}
}
#line 1813 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
void CNF_GetBindAddress(int family , IPAddr *addr ) 
{ 


  {
#line 1816
  if (family == 1) {
#line 1817
    *addr = bind_address4;
  } else
#line 1818
  if (family == 2) {
#line 1819
    *addr = bind_address6;
  } else {
#line 1821
    addr->family = (uint16_t )0;
  }
#line 1822
  return;
}
}
#line 1826 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
void CNF_GetBindCommandAddress(int family , IPAddr *addr ) 
{ 


  {
#line 1829
  if (family == 1) {
#line 1830
    if ((int )bind_cmd_address4.family != 0) {
#line 1830
      *addr = bind_cmd_address4;
    } else {
#line 1830
      *addr = bind_address4;
    }
  } else
#line 1831
  if (family == 2) {
#line 1832
    if ((int )bind_cmd_address6.family != 0) {
#line 1832
      *addr = bind_cmd_address6;
    } else {
#line 1832
      *addr = bind_address6;
    }
  } else {
#line 1834
    addr->family = (uint16_t )0;
  }
#line 1835
  return;
}
}
#line 1839 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
char *CNF_GetPidFile(void) 
{ 


  {
#line 1842
  return (pidfile);
}
}
#line 1847 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
char *CNF_GetLeapSecTimezone(void) 
{ 


  {
#line 1850
  return (leapsec_tz);
}
}
#line 1855 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
void CNF_GetLinuxHz(int *set , int *hz___0 ) 
{ 


  {
#line 1858
  *set = set_linux_hz;
#line 1859
  *hz___0 = linux_hz;
#line 1860
  return;
}
}
#line 1864 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
void CNF_GetLinuxFreqScale(int *set , double *freq_scale___0 ) 
{ 


  {
#line 1867
  *set = set_linux_freq_scale;
#line 1868
  *freq_scale___0 = linux_freq_scale;
#line 1869
  return;
}
}
#line 1873 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
int CNF_GetSchedPriority(void) 
{ 


  {
#line 1876
  return (sched_priority);
}
}
#line 1881 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
int CNF_GetLockMemory(void) 
{ 


  {
#line 1884
  return (lock_memory);
}
}
#line 1889 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
void CNF_GetTempComp(char **file , double *interval , double *T0___0 , double *k0___0 ,
                     double *k1___0 , double *k2___0 ) 
{ 


  {
#line 1892
  *file = tempcomp_file;
#line 1893
  *interval = tempcomp_interval;
#line 1894
  *T0___0 = tempcomp_T0;
#line 1895
  *k0___0 = tempcomp_k0;
#line 1896
  *k1___0 = tempcomp_k1;
#line 1897
  *k2___0 = tempcomp_k2;
#line 1898
  return;
}
}
#line 1902 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
char *CNF_GetUser(void) 
{ 


  {
#line 1905
  return (user);
}
}
#line 1910 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
int CNF_GetMaxSamples(void) 
{ 


  {
#line 1913
  return (max_samples___0);
}
}
#line 1918 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/conf.c"
int CNF_GetMinSamples(void) 
{ 


  {
#line 1921
  return (min_samples___0);
}
}
#line 619 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) sysconf)(int __name ) ;
#line 81 "/usr/include/x86_64-linux-gnu/sys/utsname.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) uname)(struct utsname *__name ) ;
#line 56 "/usr/include/sched.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sched_setscheduler)(__pid_t __pid ,
                                                                                         int __policy ,
                                                                                         struct sched_param  const  *__param ) ;
#line 66
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sched_get_priority_max)(int __algorithm ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sched_get_priority_min)(int __algorithm ) ;
#line 38 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c"
int SchedPriority  =    0;
#line 111 "/usr/include/x86_64-linux-gnu/sys/mman.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) mlockall)(int __flags ) ;
#line 69 "/usr/include/x86_64-linux-gnu/sys/resource.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setrlimit)(__rlimit_resource_t __resource ,
                                                                                struct rlimit  const  *__rlimits ) ;
#line 44 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c"
int LockAll  =    0;
#line 63 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c"
static long current_tick  ;
#line 67 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c"
static double current_total_tick  ;
#line 70 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c"
static int nominal_tick  ;
#line 84 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c"
static double freq_scale  ;
#line 89 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c"
static int hz  ;
#line 90 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c"
static double dhz  ;
#line 96 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c"
static int version_major  ;
#line 97 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c"
static int version_minor  ;
#line 98 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c"
static int version_patchlevel  ;
#line 105 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c"
static int have_readonly_adjtime  ;
#line 110 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c"
static int have_nanopll  ;
#line 113 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c"
static int have_setoffset  ;
#line 117
static void handle_end_of_slew(void *anything ) ;
#line 121 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c"
__inline static long our_round(double x ) 
{ 
  long y ;

  {
#line 125
  if (x > 0.0) {
#line 126
    y = (long )(x + 0.5);
  } else {
#line 128
    y = (long )(x - 0.5);
  }
#line 129
  return (y);
}
}
#line 134 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c"
static double offset_register  ;
#line 137 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c"
static int slow_slewing  ;
#line 140 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c"
static int nano_slewing  ;
#line 144 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c"
static int fast_slewing  ;
#line 147 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c"
static double fast_slew_wanted  ;
#line 151 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c"
static long slewing_tick  ;
#line 160 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c"
static struct timeval slew_start_tv  ;
#line 165 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c"
static SCH_TimeoutID slew_timeout_id  ;
#line 169 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c"
static double delta_total_tick  ;
#line 185 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c"
static int slew_delta_tick  ;
#line 189 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c"
static int max_tick_bias  ;
#line 193 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c"
static struct timeval slow_slew_error_end  ;
#line 194 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c"
static int slow_slew_error  ;
#line 198 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c"
static struct timeval nano_slew_error_start  ;
#line 199 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c"
static int nano_slew_error  ;
#line 203 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c"
static struct timeval fast_slew_error_end  ;
#line 204 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c"
static double fast_slew_error  ;
#line 207 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c"
static int tick_update_hz  ;
#line 213 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c"
static long pll_time_constant  ;
#line 216 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c"
static double correction_rate  ;
#line 219 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c"
static int shift_pll  ;
#line 224 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c"
static void update_slow_slew_error(int offset ) 
{ 
  struct timeval now ;
  struct timeval newend ;
  int tmp ;
  double previous_left ;

  {
#line 229
  if (offset == 0) {
#line 229
    if (slow_slew_error == 0) {
#line 230
      return;
    }
  }
  {
#line 232
  tmp = gettimeofday((struct timeval */* __restrict  */)(& now), (__timezone_ptr_t )((void *)0));
  }
#line 232
  if (tmp < 0) {
    {
#line 233
    LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c",
                 233, "update_slow_slew_error");
#line 233
    LOG_Fatal_Function((LOG_Facility )20, "gettimeofday() failed");
    }
  }
#line 236
  if (offset < 0) {
#line 237
    offset = - offset;
  }
  {
#line 240
  UTI_AddDoubleToTimeval(& now, (double )((offset + 999) / 500) * 1.1, & newend);
  }
#line 242
  if (offset > 500) {
#line 243
    offset = 500;
  }
#line 245
  if (slow_slew_error > offset) {
    {
#line 248
    UTI_DiffTimevalsToDouble(& previous_left, & slow_slew_error_end, & now);
    }
#line 249
    if (previous_left > 0.0) {
#line 250
      if (offset == 0) {
#line 251
        newend = slow_slew_error_end;
      }
#line 252
      offset = slow_slew_error;
    }
  }
#line 256
  slow_slew_error = offset;
#line 257
  slow_slew_error_end = newend;
#line 258
  return;
}
}
#line 260 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c"
static double get_slow_slew_error(struct timeval *now ) 
{ 
  double left ;
  double tmp ;

  {
#line 265
  if (slow_slew_error == 0) {
#line 266
    return (0.0);
  }
  {
#line 268
  UTI_DiffTimevalsToDouble(& left, & slow_slew_error_end, now);
  }
#line 269
  if (left > 0.0) {
#line 269
    tmp = (double )slow_slew_error / 1e6;
  } else {
#line 269
    tmp = 0.0;
  }
#line 269
  return (tmp);
}
}
#line 272 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c"
static void update_nano_slew_error(long offset , int new ) 
{ 
  struct timeval now ;
  double ago ;
  int tmp ;
  int tmp___0 ;

  {
#line 278
  if (offset == 0L) {
#line 278
    if (nano_slew_error == 0) {
#line 279
      return;
    }
  }
#line 282
  if (new) {
#line 282
    tmp = 0;
  } else {
#line 282
    tmp = 1;
  }
#line 282
  offset /= (long )((1 << ((long )shift_pll + pll_time_constant)) - tmp);
#line 283
  if (offset < 0L) {
#line 284
    offset = - offset;
  }
#line 286
  if (new) {
#line 286
    goto _L;
  } else
#line 286
  if (nano_slew_error_start.tv_sec > 0L) {
    _L: /* CIL Label */ 
    {
#line 287
    tmp___0 = gettimeofday((struct timeval */* __restrict  */)(& now), (__timezone_ptr_t )((void *)0));
    }
#line 287
    if (tmp___0 < 0) {
      {
#line 288
      LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c",
                   288, "update_nano_slew_error");
#line 288
      LOG_Fatal_Function((LOG_Facility )20, "gettimeofday() failed");
      }
    }
  }
#line 295
  if (! new) {
#line 296
    if ((long )nano_slew_error > offset) {
#line 297
      if (nano_slew_error_start.tv_sec == 0L) {
#line 298
        nano_slew_error = (int )offset;
      } else {
        {
#line 300
        UTI_DiffTimevalsToDouble(& ago, & now, & nano_slew_error_start);
        }
#line 301
        if (ago > 1.1) {
#line 302
          nano_slew_error_start.tv_sec = (__time_t )0;
#line 303
          nano_slew_error = (int )offset;
        }
      }
    }
  } else {
#line 308
    if ((long )nano_slew_error < offset) {
#line 309
      nano_slew_error = (int )offset;
    }
#line 310
    nano_slew_error_start = now;
  }
#line 312
  return;
}
}
#line 314 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c"
static double get_nano_slew_error(void) 
{ 


  {
#line 317
  if (nano_slew_error == 0) {
#line 318
    return (0.0);
  }
#line 320
  return ((double )nano_slew_error / 1e9);
}
}
#line 323 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c"
static void update_fast_slew_error(struct timeval *now ) 
{ 
  double max_tick ;
  double tmp ;

  {
#line 328
  if (delta_total_tick > 0.0) {
#line 328
    tmp = delta_total_tick;
  } else {
#line 328
    tmp = 0.0;
  }
  {
#line 328
  max_tick = current_total_tick + tmp;
#line 331
  UTI_AddDoubleToTimeval(now, ((1e6 * max_tick) / (double )nominal_tick) / (double )tick_update_hz,
                         & fast_slew_error_end);
#line 333
  fast_slew_error = fabs(((1e6 * delta_total_tick) / (double )nominal_tick) / (double )tick_update_hz);
  }
#line 334
  return;
}
}
#line 336 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c"
static double get_fast_slew_error(struct timeval *now ) 
{ 
  double left ;
  double tmp ;

  {
#line 341
  if (fast_slew_error == 0.0) {
#line 342
    return (0.0);
  }
  {
#line 344
  UTI_DiffTimevalsToDouble(& left, & fast_slew_error_end, now);
  }
#line 345
  if (left < - 10.0) {
#line 346
    fast_slew_error = 0.0;
  }
#line 348
  if (left > 0.0) {
#line 348
    tmp = fast_slew_error;
  } else {
#line 348
    tmp = 0.0;
  }
#line 348
  return (tmp);
}
}
#line 354 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c"
static long get_pll_constant(double offset ) 
{ 
  long c ;
  double corr_time ;

  {
#line 360
  if (offset < 1e-9) {
#line 361
    return (0L);
  }
#line 363
  corr_time = correction_rate / offset;
#line 365
  c = 0L;
  {
#line 365
  while (1) {
    while_continue: /* CIL Label */ ;
#line 365
    if (! (c < 10L)) {
#line 365
      goto while_break;
    }
#line 366
    if (corr_time < (double )(1 << ((c + 1L) + (long )shift_pll))) {
#line 367
      goto while_break;
    }
#line 365
    c ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 369
  return (c);
}
}
#line 378 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c"
static void stop_fast_slew(void) 
{ 
  struct timeval T1 ;
  double fast_slew_done ;
  double slew_duration ;
  int tmp ;
  int tmp___0 ;

  {
#line 386
  if (! fast_slewing) {
    {
#line 386
    __assert_fail("fast_slewing", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c",
                  386U, "stop_fast_slew");
    }
  }
  {
#line 389
  tmp = gettimeofday((struct timeval */* __restrict  */)(& T1), (__timezone_ptr_t )((void *)0));
  }
#line 389
  if (tmp < 0) {
    {
#line 390
    LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c",
                 390, "stop_fast_slew");
#line 390
    LOG_Fatal_Function((LOG_Facility )20, "gettimeofday() failed");
    }
  }
  {
#line 393
  tmp___0 = TMX_SetTick(current_tick);
  }
#line 393
  if (tmp___0 < 0) {
    {
#line 394
    LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c",
                 394, "stop_fast_slew");
#line 394
    LOG_Fatal_Function((LOG_Facility )20, "adjtimex() failed");
    }
  }
  {
#line 397
  fast_slewing = 0;
#line 399
  UTI_DiffTimevalsToDouble(& slew_duration, & T1, & slew_start_tv);
#line 405
  update_fast_slew_error(& T1);
#line 406
  lcl_InvokeDispersionNotifyHandlers(fast_slew_error);
#line 408
  fast_slew_done = (delta_total_tick * slew_duration) / (current_total_tick + delta_total_tick);
#line 411
  offset_register += fast_slew_wanted + fast_slew_done;
  }
#line 413
  return;
}
}
#line 419 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c"
static void adjust_fast_slew(double old_tick , double old_delta_tick ) 
{ 
  struct timeval tv ;
  struct timeval end_of_slew ;
  double fast_slew_done ;
  double slew_duration ;
  double dseconds ;
  int tmp ;

  {
#line 425
  if (! fast_slewing) {
    {
#line 425
    __assert_fail("fast_slewing", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c",
                  425U, "adjust_fast_slew");
    }
  }
  {
#line 427
  tmp = gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )((void *)0));
  }
#line 427
  if (tmp < 0) {
    {
#line 428
    LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c",
                 428, "adjust_fast_slew");
#line 428
    LOG_Fatal_Function((LOG_Facility )20, "gettimeofday() failed");
    }
  }
  {
#line 431
  UTI_DiffTimevalsToDouble(& slew_duration, & tv, & slew_start_tv);
#line 433
  fast_slew_done = (old_delta_tick * slew_duration) / (old_tick + old_delta_tick);
#line 434
  offset_register += fast_slew_wanted + fast_slew_done;
#line 436
  dseconds = (- offset_register * (current_total_tick + delta_total_tick)) / delta_total_tick;
  }
#line 438
  if (dseconds > (double )604800) {
#line 439
    dseconds = (double )604800;
  }
  {
#line 440
  UTI_AddDoubleToTimeval(& tv, dseconds, & end_of_slew);
#line 442
  slew_start_tv = tv;
#line 443
  fast_slew_wanted = offset_register;
#line 444
  offset_register = 0.0;
#line 446
  SCH_RemoveTimeout(slew_timeout_id);
#line 447
  slew_timeout_id = SCH_AddTimeout(& end_of_slew, & handle_end_of_slew, (void *)0);
  }
#line 448
  return;
}
}
#line 453 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c"
static void initiate_slew(void) 
{ 
  double dseconds ;
  long tick_adjust ;
  long offset ;
  struct timeval T0___0 ;
  struct timeval end_of_slew ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  double tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  long min_allowed_tick ;
  long max_allowed_tick ;
  int tmp___5 ;
  int tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;

  {
#line 463
  if (! (! fast_slewing)) {
    {
#line 463
    __assert_fail("!fast_slewing", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c",
                  463U, "initiate_slew");
    }
  }
#line 465
  if (offset_register == 0.0) {
#line 466
    return;
  }
#line 470
  if (slow_slewing) {
    {
#line 471
    offset = 0L;
#line 472
    tmp = TMX_ApplyOffset(& offset);
    }
#line 472
    if (tmp < 0) {
      {
#line 473
      LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c",
                   473, "initiate_slew");
#line 473
      LOG_Fatal_Function((LOG_Facility )20, "adjtimex() failed");
      }
    }
    {
#line 475
    offset_register -= (double )offset / 1.0e6;
#line 476
    slow_slewing = 0;
#line 477
    update_slow_slew_error(0);
    }
  } else
#line 478
  if (nano_slewing) {
    {
#line 479
    tmp___0 = TMX_GetPLLOffsetLeft(& offset);
    }
#line 479
    if (tmp___0 < 0) {
      {
#line 480
      LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c",
                   480, "initiate_slew");
#line 480
      LOG_Fatal_Function((LOG_Facility )20, "adjtimex() failed");
      }
    }
    {
#line 482
    offset_register -= (double )offset / 1.0e9;
#line 483
    update_nano_slew_error(offset, 0);
#line 485
    offset = 0L;
#line 486
    tmp___1 = TMX_ApplyPLLOffset(offset, 0L);
    }
#line 486
    if (tmp___1 < 0) {
      {
#line 487
      LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c",
                   487, "initiate_slew");
#line 487
      LOG_Fatal_Function((LOG_Facility )20, "adjtimex() failed");
      }
    }
    {
#line 489
    nano_slewing = 0;
#line 490
    update_nano_slew_error(offset, 1);
    }
  }
#line 493
  if (have_nanopll) {
    {
#line 493
    tmp___8 = fabs(offset_register);
    }
#line 493
    if (tmp___8 < 0.5) {
#line 497
      offset = (long )(1.0e9 * - offset_register);
#line 500
      if (pll_time_constant < 0L) {
        {
#line 501
        tmp___2 = fabs(offset_register);
#line 501
        pll_time_constant = get_pll_constant(tmp___2);
        }
      }
#line 504
      if (pll_time_constant >= 0L) {
#line 504
        if (! (pll_time_constant <= 10L)) {
          {
#line 504
          __assert_fail("pll_time_constant >= 0 && pll_time_constant <= 10", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c",
                        505U, "initiate_slew");
          }
        }
      } else {
        {
#line 504
        __assert_fail("pll_time_constant >= 0 && pll_time_constant <= 10", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c",
                      505U, "initiate_slew");
        }
      }
      {
#line 507
      tmp___3 = TMX_ApplyPLLOffset(offset, pll_time_constant);
      }
#line 507
      if (tmp___3 < 0) {
        {
#line 508
        LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c",
                     508, "initiate_slew");
#line 508
        LOG_Fatal_Function((LOG_Facility )20, "adjtimex() failed");
        }
      }
      {
#line 510
      offset_register = 0.0;
#line 511
      nano_slewing = 1;
#line 512
      update_nano_slew_error(offset, 1);
      }
    } else {
#line 493
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 513
    tmp___7 = fabs(offset_register);
    }
#line 513
    if (tmp___7 < 0.2) {
      {
#line 515
      offset = our_round(1.0e6 * - offset_register);
#line 517
      offset_register += (double )offset / 1.0e6;
      }
#line 519
      if (offset != 0L) {
        {
#line 520
        tmp___4 = TMX_ApplyOffset(& offset);
        }
#line 520
        if (tmp___4 < 0) {
          {
#line 521
          LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c",
                       521, "initiate_slew");
#line 521
          LOG_Fatal_Function((LOG_Facility )20, "adjtimex() failed");
          }
        }
        {
#line 523
        slow_slewing = 1;
#line 524
        update_slow_slew_error((int )offset);
        }
      }
    } else {
#line 536
      min_allowed_tick = (long )(nominal_tick - max_tick_bias);
#line 537
      max_allowed_tick = (long )(nominal_tick + max_tick_bias);
#line 539
      if (offset_register > (double )0) {
#line 540
        if (current_tick <= min_allowed_tick) {
#line 541
          return;
        }
#line 544
        slewing_tick = current_tick - (long )slew_delta_tick;
#line 545
        if (slewing_tick < min_allowed_tick) {
#line 546
          slewing_tick = min_allowed_tick;
        }
      } else {
#line 549
        if (current_tick >= max_allowed_tick) {
#line 550
          return;
        }
#line 553
        slewing_tick = current_tick + (long )slew_delta_tick;
#line 554
        if (slewing_tick > max_allowed_tick) {
#line 555
          slewing_tick = max_allowed_tick;
        }
      }
#line 559
      tick_adjust = slewing_tick - current_tick;
#line 561
      delta_total_tick = (double )tick_adjust / 1.0e6;
#line 562
      dseconds = (- offset_register * (current_total_tick + delta_total_tick)) / delta_total_tick;
#line 564
      if (! (dseconds > 0.0)) {
        {
#line 564
        __assert_fail("dseconds > 0.0", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c",
                      564U, "initiate_slew");
        }
      }
      {
#line 567
      tmp___5 = gettimeofday((struct timeval */* __restrict  */)(& T0___0), (__timezone_ptr_t )((void *)0));
      }
#line 567
      if (tmp___5 < 0) {
        {
#line 568
        LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c",
                     568, "initiate_slew");
#line 568
        LOG_Fatal_Function((LOG_Facility )20, "gettimeofday() failed");
        }
      }
      {
#line 571
      tmp___6 = TMX_SetTick(slewing_tick);
      }
#line 571
      if (tmp___6 < 0) {
        {
#line 572
        LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c",
                     572, "initiate_slew");
#line 572
        LOG_Fatal_Function((LOG_Facility )20, "adjtimex() failed");
        }
      }
      {
#line 579
      update_fast_slew_error(& T0___0);
#line 580
      lcl_InvokeDispersionNotifyHandlers(fast_slew_error);
#line 582
      fast_slewing = 1;
#line 583
      slew_start_tv = T0___0;
      }
#line 585
      if (dseconds > (double )604800) {
#line 586
        dseconds = (double )604800;
      }
      {
#line 587
      UTI_AddDoubleToTimeval(& T0___0, dseconds, & end_of_slew);
#line 589
      slew_timeout_id = SCH_AddTimeout(& end_of_slew, & handle_end_of_slew, (void *)0);
#line 591
      fast_slew_wanted = offset_register;
#line 592
      offset_register = 0.0;
      }
    }
  }
#line 595
  return;
}
}
#line 602 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c"
static void handle_end_of_slew(void *anything ) 
{ 


  {
  {
#line 605
  stop_fast_slew();
#line 606
  initiate_slew();
  }
#line 607
  return;
}
}
#line 612 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c"
static void abort_slew(void) 
{ 


  {
#line 615
  if (fast_slewing) {
    {
#line 616
    stop_fast_slew();
#line 617
    SCH_RemoveTimeout(slew_timeout_id);
    }
  }
#line 619
  return;
}
}
#line 629 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c"
static void accrue_offset(double offset , double corr_rate ) 
{ 


  {
#line 633
  offset_register += offset;
#line 635
  correction_rate = corr_rate;
#line 638
  pll_time_constant = -1L;
#line 640
  if (! fast_slewing) {
    {
#line 641
    initiate_slew();
    }
  } else {
    {
#line 643
    adjust_fast_slew(current_total_tick, delta_total_tick);
    }
  }
#line 645
  return;
}
}
#line 650 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c"
static void apply_step_offset(double offset ) 
{ 
  struct timeval old_time ;
  struct timeval new_time ;
  double err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  double tmp___3 ;

  {
#line 656
  if (fast_slewing) {
    {
#line 657
    abort_slew();
    }
  }
#line 660
  if (have_setoffset) {
    {
#line 661
    tmp = TMX_ApplyStepOffset(- offset);
    }
#line 661
    if (tmp < 0) {
      {
#line 662
      LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c",
                   662, "apply_step_offset");
#line 662
      LOG_Fatal_Function((LOG_Facility )20, "adjtimex() failed");
      }
    }
  } else {
    {
#line 665
    tmp___0 = gettimeofday((struct timeval */* __restrict  */)(& old_time), (__timezone_ptr_t )((void *)0));
    }
#line 665
    if (tmp___0 < 0) {
      {
#line 666
      LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c",
                   666, "apply_step_offset");
#line 666
      LOG_Fatal_Function((LOG_Facility )20, "gettimeofday() failed");
      }
    }
    {
#line 669
    UTI_AddDoubleToTimeval(& old_time, - offset, & new_time);
#line 671
    tmp___1 = settimeofday((struct timeval  const  *)(& new_time), (struct timezone  const  *)((void *)0));
    }
#line 671
    if (tmp___1 < 0) {
      {
#line 672
      LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c",
                   672, "apply_step_offset");
#line 672
      LOG_Fatal_Function((LOG_Facility )20, "settimeofday() failed");
      }
    }
    {
#line 675
    tmp___2 = gettimeofday((struct timeval */* __restrict  */)(& old_time), (__timezone_ptr_t )((void *)0));
    }
#line 675
    if (tmp___2 < 0) {
      {
#line 676
      LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c",
                   676, "apply_step_offset");
#line 676
      LOG_Fatal_Function((LOG_Facility )20, "gettimeofday() failed");
      }
    }
    {
#line 679
    UTI_DiffTimevalsToDouble(& err, & old_time, & new_time);
#line 680
    tmp___3 = fabs(err);
#line 680
    lcl_InvokeDispersionNotifyHandlers(tmp___3);
    }
  }
  {
#line 683
  initiate_slew();
  }
#line 685
  return;
}
}
#line 694 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c"
static double set_frequency(double freq_ppm ) 
{ 
  long required_tick ;
  long min_allowed_tick ;
  long max_allowed_tick ;
  double required_freq ;
  double scaled_freq ;
  double old_total_tick ;
  int required_delta_tick ;
  long tmp ;
  int tmp___0 ;
  double old_delta_tick ;

  {
  {
#line 704
  tmp = our_round(freq_ppm / dhz);
#line 704
  required_delta_tick = (int )tmp;
#line 705
  required_freq = - (freq_ppm - dhz * (double )required_delta_tick);
#line 706
  required_tick = (long )(nominal_tick - required_delta_tick);
#line 707
  scaled_freq = freq_scale * required_freq;
#line 709
  min_allowed_tick = (long )(nominal_tick - max_tick_bias);
#line 710
  max_allowed_tick = (long )(nominal_tick + max_tick_bias);
  }
#line 712
  if (required_tick < min_allowed_tick) {
#line 712
    goto _L;
  } else
#line 712
  if (required_tick > max_allowed_tick) {
    _L: /* CIL Label */ 
    {
#line 713
    LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c",
                 713, "set_frequency");
#line 713
    LOG_Line_Function((LOG_Severity )1, (LOG_Facility )20, "Required tick %ld outside allowed range (%ld .. %ld)",
                      required_tick, min_allowed_tick, max_allowed_tick);
    }
#line 714
    if (required_tick < min_allowed_tick) {
#line 715
      required_tick = min_allowed_tick;
    } else {
#line 717
      required_tick = max_allowed_tick;
    }
  }
#line 721
  current_tick = required_tick;
#line 722
  old_total_tick = current_total_tick;
#line 723
  current_total_tick = ((double )current_tick + required_freq / dhz) / 1.0e6;
#line 726
  if (fast_slewing) {
#line 727
    required_tick = slewing_tick;
  }
  {
#line 730
  tmp___0 = TMX_SetFrequency(& scaled_freq, required_tick);
  }
#line 730
  if (tmp___0 < 0) {
    {
#line 731
    LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c",
                 731, "set_frequency");
#line 731
    LOG_Fatal_Function((LOG_Facility )20, "adjtimex failed for set_frequency, freq_ppm=%10.4e scaled_freq=%10.4e required_tick=%ld",
                       freq_ppm, scaled_freq, required_tick);
    }
  }
#line 735
  if (fast_slewing) {
    {
#line 738
    old_delta_tick = delta_total_tick;
#line 739
    delta_total_tick = ((double )slewing_tick + required_freq / dhz) / 1.0e6 - current_total_tick;
#line 741
    adjust_fast_slew(old_total_tick, old_delta_tick);
    }
  }
#line 744
  return (dhz * (double )((long )nominal_tick - current_tick) - scaled_freq / freq_scale);
}
}
#line 750 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c"
static double read_frequency(void) 
{ 
  double tick_term ;
  double unscaled_freq ;
  double freq_term ;
  long tick ;
  int tmp ;

  {
  {
#line 758
  tmp = TMX_GetFrequency(& unscaled_freq, & tick);
  }
#line 758
  if (tmp < 0) {
    {
#line 759
    LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c",
                 759, "read_frequency");
#line 759
    LOG_Fatal_Function((LOG_Facility )20, "adjtimex() failed");
    }
  }
#line 762
  if (fast_slewing) {
#line 763
    tick -= slewing_tick - current_tick;
  }
#line 766
  tick_term = dhz * (double )((long )nominal_tick - tick);
#line 767
  freq_term = unscaled_freq / freq_scale;
#line 774
  return (tick_term - freq_term);
}
}
#line 783 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c"
static void get_offset_correction(struct timeval *raw , double *corr , double *err ) 
{ 
  double fast_slew_duration ;
  double fast_slew_achieved ;
  double fast_slew_remaining ;
  long offset ;
  long noffset ;
  long toffset ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;

  {
#line 800
  if (! slow_slewing) {
#line 801
    offset = 0L;
  } else {
#line 803
    if (have_readonly_adjtime) {
      {
#line 804
      tmp = TMX_GetOffsetLeft(& offset);
      }
#line 804
      if (tmp < 0) {
        {
#line 805
        LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c",
                     805, "get_offset_correction");
#line 805
        LOG_Fatal_Function((LOG_Facility )20, "adjtimex() failed");
        }
      }
    } else {
      {
#line 808
      toffset = 0L;
#line 809
      tmp___0 = TMX_ApplyOffset(& toffset);
      }
#line 809
      if (tmp___0 < 0) {
        {
#line 810
        LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c",
                     810, "get_offset_correction");
#line 810
        LOG_Fatal_Function((LOG_Facility )20, "adjtimex() failed");
        }
      }
      {
#line 812
      offset = toffset;
#line 813
      tmp___1 = TMX_ApplyOffset(& toffset);
      }
#line 813
      if (tmp___1 < 0) {
        {
#line 814
        LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c",
                     814, "get_offset_correction");
#line 814
        LOG_Fatal_Function((LOG_Facility )20, "adjtimex() failed");
        }
      }
    }
#line 818
    if (offset == 0L) {
#line 820
      slow_slewing = 0;
    }
  }
#line 824
  if (! nano_slewing) {
#line 825
    noffset = 0L;
  } else {
    {
#line 827
    tmp___2 = TMX_GetPLLOffsetLeft(& noffset);
    }
#line 827
    if (tmp___2 < 0) {
      {
#line 828
      LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c",
                   828, "get_offset_correction");
#line 828
      LOG_Fatal_Function((LOG_Facility )20, "adjtimex() failed");
      }
    }
#line 830
    if (noffset == 0L) {
#line 831
      nano_slewing = 0;
    }
  }
#line 835
  if (fast_slewing) {
    {
#line 836
    UTI_DiffTimevalsToDouble(& fast_slew_duration, raw, & slew_start_tv);
#line 837
    fast_slew_achieved = (delta_total_tick * fast_slew_duration) / (current_total_tick + delta_total_tick);
#line 839
    fast_slew_remaining = fast_slew_wanted + fast_slew_achieved;
    }
  } else {
#line 841
    fast_slew_remaining = 0.0;
  }
#line 844
  *corr = (- (offset_register + fast_slew_remaining) + (double )offset / 1.0e6) + (double )noffset / 1.0e9;
#line 846
  if (err) {
    {
#line 847
    update_slow_slew_error((int )offset);
#line 848
    update_nano_slew_error(noffset, 0);
#line 849
    tmp___3 = get_slow_slew_error(raw);
#line 849
    tmp___4 = get_fast_slew_error(raw);
#line 849
    tmp___5 = get_nano_slew_error();
#line 849
    *err = (tmp___3 + tmp___4) + tmp___5;
    }
  }
#line 851
  return;
}
}
#line 855 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c"
static void set_leap(int leap ) 
{ 
  int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 858
  tmp = TMX_SetLeap(leap);
  }
#line 858
  if (tmp < 0) {
    {
#line 859
    LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c",
                 859, "set_leap");
#line 859
    LOG_Fatal_Function((LOG_Facility )20, "adjtimex() failed in set_leap");
    }
  }
  {
#line 862
  LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c",
               862, "set_leap");
  }
#line 862
  if (leap) {
#line 862
    if (leap > 0) {
#line 862
      tmp___0 = "insert";
    } else {
#line 862
      tmp___0 = "delete";
    }
#line 862
    tmp___1 = tmp___0;
  } else {
#line 862
    tmp___1 = "not insert/delete";
  }
  {
#line 862
  LOG_Line_Function((LOG_Severity )0, (LOG_Facility )20, "System clock status set to %s leap second",
                    tmp___1);
  }
#line 864
  return;
}
}
#line 873 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c"
static void guess_hz_and_shift_hz(int tick , int *hz___0 , int *shift_hz ) 
{ 
  int i ;
  int tick_lo ;
  int tick_hi ;
  int ihz ;
  double tick_nominal ;

  {
#line 879
  if (tick >= 9000) {
#line 879
    if (tick <= 11000) {
#line 880
      *hz___0 = 100;
#line 881
      *shift_hz = 7;
#line 882
      return;
    }
  }
#line 885
  i = 4;
  {
#line 885
  while (1) {
    while_continue: /* CIL Label */ ;
#line 885
    if (! (i < 16)) {
#line 885
      goto while_break;
    }
#line 886
    ihz = 1 << i;
#line 887
    tick_nominal = 1.0e6 / (double )ihz;
#line 888
    tick_lo = (int )(0.5 + (tick_nominal * 2.0) / 3.0);
#line 889
    tick_hi = (int )(0.5 + (tick_nominal * 4.0) / 3.0);
#line 891
    if (tick_lo < tick) {
#line 891
      if (tick <= tick_hi) {
#line 892
        *hz___0 = ihz;
#line 893
        *shift_hz = i;
#line 894
        return;
      }
    }
#line 885
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 899
  *hz___0 = 0;
#line 900
  *shift_hz = 0;
#line 901
  return;
}
}
#line 905 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c"
static int get_hz_and_shift_hz(int *hz___0 , int *shift_hz ) 
{ 
  int tmp ;
  long tmp___0 ;

  {
  {
#line 909
  tmp___0 = sysconf(2);
#line 909
  tmp = (int )tmp___0;
#line 909
  *hz___0 = tmp;
  }
#line 909
  if (tmp < 1) {
#line 910
    return (0);
  }
#line 913
  if (*hz___0 == 100) {
#line 914
    *shift_hz = 7;
#line 915
    return (1);
  }
#line 918
  *shift_hz = 1;
  {
#line 918
  while (1) {
    while_continue: /* CIL Label */ ;
#line 918
    if (! (*hz___0 >> *shift_hz > 1)) {
#line 918
      goto while_break;
    }
#line 918
    (*shift_hz) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 921
  return (1);
}
}
#line 929 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c"
static int kernelvercmp(int major1 , int minor1 , int patch1 , int major2 , int minor2 ,
                        int patch2 ) 
{ 


  {
#line 933
  if (major1 != major2) {
#line 934
    return (major1 - major2);
  }
#line 935
  if (minor1 != minor2) {
#line 936
    return (minor1 - minor2);
  }
#line 937
  return (patch1 - patch2);
}
}
#line 944 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c"
static void get_version_specific_details(void) 
{ 
  int major ;
  int minor ;
  int patch ;
  int shift_hz ;
  double dshift_hz ;
  double basic_freq_scale ;
  int config_hz ;
  int set_config_hz ;
  int set_config_freq_scale ;
  double config_freq_scale ;
  struct tmx_params tmx_params ;
  struct utsname uts ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 957
  tmp = get_hz_and_shift_hz(& hz, & shift_hz);
  }
#line 957
  if (! tmp) {
    {
#line 958
    TMX_ReadCurrentParams(& tmx_params);
#line 960
    guess_hz_and_shift_hz((int )tmx_params.tick, & hz, & shift_hz);
    }
#line 962
    if (! shift_hz) {
      {
#line 963
      LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c",
                   963, "get_version_specific_details");
#line 963
      LOG_Fatal_Function((LOG_Facility )20, "Can\'t determine hz (txc.tick=%ld txc.freq=%ld (%.8f) txc.offset=%ld)",
                         tmx_params.tick, tmx_params.freq, tmx_params.dfreq, tmx_params.offset);
      }
    }
  }
  {
#line 973
  CNF_GetLinuxHz(& set_config_hz, & config_hz);
  }
#line 974
  if (set_config_hz) {
#line 974
    hz = config_hz;
  }
  {
#line 978
  dhz = (double )hz;
#line 979
  dshift_hz = (double )(1UL << shift_hz);
#line 980
  basic_freq_scale = dshift_hz / dhz;
#line 981
  nominal_tick = (int )((1000000L + (long )(hz / 2)) / (long )hz);
#line 982
  slew_delta_tick = nominal_tick / 12;
#line 983
  max_tick_bias = nominal_tick / 10;
#line 984
  tick_update_hz = hz;
#line 1013
  tmp___0 = uname(& uts);
  }
#line 1013
  if (tmp___0 < 0) {
    {
#line 1014
    LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c",
                 1014, "get_version_specific_details");
#line 1014
    LOG_Fatal_Function((LOG_Facility )20, "Cannot uname(2) to get kernel version, sorry.");
    }
  }
  {
#line 1017
  patch = 0;
#line 1018
  tmp___1 = sscanf((char const   */* __restrict  */)(uts.release), (char const   */* __restrict  */)"%d.%d.%d",
                   & major, & minor, & patch);
  }
#line 1018
  if (tmp___1 < 2) {
    {
#line 1019
    LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c",
                 1019, "get_version_specific_details");
#line 1019
    LOG_Fatal_Function((LOG_Facility )20, "Cannot read information from uname, sorry");
    }
  }
  {
#line 1022
  LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c",
               1022, "get_version_specific_details");
#line 1022
  LOG_Line_Function((LOG_Severity )0, (LOG_Facility )20, "Linux kernel major=%d minor=%d patch=%d",
                    major, minor, patch);
#line 1024
  version_major = major;
#line 1025
  version_minor = minor;
#line 1026
  version_patchlevel = patch;
#line 1028
  tmp___2 = kernelvercmp(major, minor, patch, 2, 2, 0);
  }
#line 1028
  if (tmp___2 < 0) {
    {
#line 1029
    LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c",
                 1029, "get_version_specific_details");
#line 1029
    LOG_Fatal_Function((LOG_Facility )20, "Kernel version not supported, sorry.");
    }
  }
  {
#line 1032
  tmp___4 = kernelvercmp(major, minor, patch, 2, 6, 27);
  }
#line 1032
  if (tmp___4 < 0) {
#line 1033
    if (hz == 100) {
#line 1033
      freq_scale = 128.0 / 128.125;
    } else {
#line 1033
      freq_scale = basic_freq_scale;
    }
  } else {
    {
#line 1036
    freq_scale = 1.0;
#line 1038
    tmp___3 = kernelvercmp(major, minor, patch, 2, 6, 33);
    }
#line 1038
    if (tmp___3 < 0) {
#line 1041
      tick_update_hz = 2;
    }
  }
  {
#line 1047
  tmp___5 = kernelvercmp(major, minor, patch, 2, 6, 28);
  }
#line 1047
  if (tmp___5 < 0) {
#line 1048
    have_readonly_adjtime = 0;
  } else {
#line 1050
    have_readonly_adjtime = 1;
  }
  {
#line 1054
  tmp___6 = kernelvercmp(major, minor, patch, 2, 6, 27);
  }
#line 1054
  if (tmp___6 < 0) {
#line 1055
    have_nanopll = 0;
  } else {
#line 1057
    have_nanopll = 1;
  }
  {
#line 1061
  tmp___7 = kernelvercmp(major, minor, patch, 2, 6, 39);
  }
#line 1061
  if (tmp___7 < 0) {
#line 1062
    have_setoffset = 0;
  } else {
#line 1064
    have_setoffset = 1;
  }
  {
#line 1068
  tmp___8 = kernelvercmp(major, minor, patch, 2, 6, 31);
  }
#line 1068
  if (tmp___8 < 0) {
#line 1069
    shift_pll = 4;
  } else {
#line 1071
    shift_pll = 2;
  }
  {
#line 1075
  CNF_GetLinuxFreqScale(& set_config_freq_scale, & config_freq_scale);
  }
#line 1076
  if (set_config_freq_scale) {
#line 1077
    freq_scale = config_freq_scale;
  }
  {
#line 1080
  LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c",
               1080, "get_version_specific_details");
#line 1080
  LOG_Line_Function((LOG_Severity )0, (LOG_Facility )20, "hz=%d shift_hz=%d freq_scale=%.8f nominal_tick=%d slew_delta_tick=%d max_tick_bias=%d shift_pll=%d",
                    hz, shift_hz, freq_scale, nominal_tick, slew_delta_tick, max_tick_bias,
                    shift_pll);
  }
#line 1082
  return;
}
}
#line 1087 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c"
void SYS_Linux_Initialise(void) 
{ 
  long offset ;
  double freq ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 1093
  offset_register = 0.0;
#line 1094
  fast_slewing = 0;
#line 1096
  get_version_specific_details();
#line 1098
  offset = 0L;
#line 1099
  tmp = TMX_ApplyOffset(& offset);
  }
#line 1099
  if (tmp < 0) {
    {
#line 1100
    LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c",
                 1100, "SYS_Linux_Initialise");
#line 1100
    LOG_Fatal_Function((LOG_Facility )20, "adjtimex() failed");
    }
  }
#line 1103
  if (have_readonly_adjtime) {
    {
#line 1103
    tmp___0 = TMX_GetOffsetLeft(& offset);
    }
#line 1103
    if (tmp___0 < 0) {
      {
#line 1104
      LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c",
                   1104, "SYS_Linux_Initialise");
#line 1104
      LOG_Line_Function((LOG_Severity )0, (LOG_Facility )20, "adjtimex() doesn\'t support ADJ_OFFSET_SS_READ");
#line 1105
      have_readonly_adjtime = 0;
      }
    } else
#line 1103
    if (offset) {
      {
#line 1104
      LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c",
                   1104, "SYS_Linux_Initialise");
#line 1104
      LOG_Line_Function((LOG_Severity )0, (LOG_Facility )20, "adjtimex() doesn\'t support ADJ_OFFSET_SS_READ");
#line 1105
      have_readonly_adjtime = 0;
      }
    }
  }
#line 1108
  if (have_nanopll) {
    {
#line 1108
    tmp___1 = TMX_EnableNanoPLL();
    }
#line 1108
    if (tmp___1 < 0) {
      {
#line 1109
      LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c",
                   1109, "SYS_Linux_Initialise");
#line 1109
      LOG_Line_Function((LOG_Severity )0, (LOG_Facility )20, "adjtimex() doesn\'t support nanosecond PLL");
#line 1110
      have_nanopll = 0;
      }
    }
  }
#line 1113
  if (have_setoffset) {
    {
#line 1113
    tmp___2 = TMX_TestStepOffset();
    }
#line 1113
    if (tmp___2 < 0) {
      {
#line 1114
      LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c",
                   1114, "SYS_Linux_Initialise");
#line 1114
      LOG_Line_Function((LOG_Severity )0, (LOG_Facility )20, "adjtimex() doesn\'t support ADJ_SETOFFSET");
#line 1115
      have_setoffset = 0;
      }
    }
  }
  {
#line 1118
  tmp___3 = CNF_GetRTCSync();
#line 1118
  TMX_SetSync(tmp___3);
#line 1121
  TMX_GetFrequency(& freq, & current_tick);
#line 1122
  current_total_tick = ((double )current_tick + (freq / freq_scale) / dhz) / 1.0e6;
#line 1124
  lcl_RegisterSystemDrivers(& read_frequency, & set_frequency, & accrue_offset, & apply_step_offset,
                            & get_offset_correction, & set_leap);
  }
#line 1127
  return;
}
}
#line 1132 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c"
void SYS_Linux_Finalise(void) 
{ 


  {
  {
#line 1137
  abort_slew();
  }
#line 1138
  return;
}
}
#line 1192 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c"
void SYS_Linux_SetScheduler(int SchedPriority___0 ) 
{ 
  int pmax ;
  int pmin ;
  struct sched_param sched ;
  int tmp ;

  {
#line 1197
  if (SchedPriority___0 < 1) {
    {
#line 1198
    LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c",
                 1198, "SYS_Linux_SetScheduler");
#line 1198
    LOG_Fatal_Function((LOG_Facility )20, "Bad scheduler priority: %d", SchedPriority___0);
    }
  } else
#line 1197
  if (SchedPriority___0 > 99) {
    {
#line 1198
    LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c",
                 1198, "SYS_Linux_SetScheduler");
#line 1198
    LOG_Fatal_Function((LOG_Facility )20, "Bad scheduler priority: %d", SchedPriority___0);
    }
  } else {
    {
#line 1200
    sched.__sched_priority = SchedPriority___0;
#line 1201
    pmax = sched_get_priority_max(1);
#line 1202
    pmin = sched_get_priority_min(1);
    }
#line 1203
    if (SchedPriority___0 > pmax) {
#line 1204
      sched.__sched_priority = pmax;
    } else
#line 1206
    if (SchedPriority___0 < pmin) {
#line 1207
      sched.__sched_priority = pmin;
    }
    {
#line 1209
    tmp = sched_setscheduler(0, 1, (struct sched_param  const  *)(& sched));
    }
#line 1209
    if (tmp == -1) {
      {
#line 1210
      LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c",
                   1210, "SYS_Linux_SetScheduler");
#line 1210
      LOG_Line_Function((LOG_Severity )2, (LOG_Facility )20, "sched_setscheduler() failed");
      }
    }
  }
#line 1218
  return;
}
}
#line 1223 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c"
void SYS_Linux_MemLockAll(int LockAll___0 ) 
{ 
  struct rlimit rlim ;
  int tmp ;
  int tmp___0 ;

  {
#line 1226
  if (LockAll___0 == 1) {
    {
#line 1229
    rlim.rlim_max = (__rlim_t )-1;
#line 1230
    rlim.rlim_cur = (__rlim_t )-1;
#line 1231
    tmp___0 = setrlimit((__rlimit_resource_t )8, (struct rlimit  const  *)(& rlim));
    }
#line 1231
    if (tmp___0 < 0) {
      {
#line 1232
      LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c",
                   1232, "SYS_Linux_MemLockAll");
#line 1232
      LOG_Line_Function((LOG_Severity )2, (LOG_Facility )20, "setrlimit() failed: not locking into RAM");
      }
    } else {
      {
#line 1235
      tmp = mlockall(3);
      }
#line 1235
      if (tmp < 0) {
        {
#line 1236
        LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/sys_linux.c",
                     1236, "SYS_Linux_MemLockAll");
#line 1236
        LOG_Line_Function((LOG_Severity )2, (LOG_Facility )20, "mlockall() failed");
        }
      }
    }
  }
#line 1245
  return;
}
}
#line 47 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sourcestats.c"
int max_samples  ;
#line 48 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sourcestats.c"
int min_samples  ;
#line 59 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sourcestats.c"
static LOG_FileID logfileid___3  ;
#line 159
static void find_min_delay_sample(SST_Stats inst ) ;
#line 160
static int get_buf_index(SST_Stats inst , int i ) ;
#line 164 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sourcestats.c"
void SST_Initialise(void) 
{ 
  LOG_FileID tmp___0 ;
  int tmp___1 ;

  {
  {
#line 167
  tmp___1 = CNF_GetLogStatistics();
  }
#line 167
  if (tmp___1) {
    {
#line 167
    tmp___0 = LOG_FileOpen("statistics", "   Date (UTC) Time     IP Address    Std dev\'n Est offset  Offset sd  Diff freq   Est skew  Stress  Ns  Bs  Nr");
#line 167
    logfileid___3 = tmp___0;
    }
  } else {
#line 167
    logfileid___3 = -1;
  }
  {
#line 170
  max_samples = CNF_GetMaxSamples();
#line 171
  min_samples = CNF_GetMinSamples();
  }
#line 172
  return;
}
}
#line 176 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sourcestats.c"
void SST_Finalise(void) 
{ 


  {
#line 179
  return;
}
}
#line 184 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sourcestats.c"
SST_Stats SST_CreateInstance(uint32_t refid , IPAddr *addr ) 
{ 
  SST_Stats inst ;
  void *tmp ;

  {
  {
#line 188
  tmp = malloc(sizeof(struct SST_Stats_Record ));
#line 188
  inst = (struct SST_Stats_Record *)tmp;
#line 189
  inst->refid = refid;
#line 190
  inst->ip_addr = addr;
#line 191
  inst->n_samples = 0;
#line 192
  inst->runs_samples = 0;
#line 193
  inst->last_sample = 0;
#line 194
  inst->regression_ok = 0;
#line 195
  inst->best_single_sample = 0;
#line 196
  inst->min_delay_sample = 0;
#line 197
  inst->estimated_frequency = (double )0;
#line 198
  inst->skew = 2000.0e-6;
#line 199
  inst->skew_dirn = (SST_Skew_Direction )1;
#line 200
  inst->estimated_offset = 0.0;
#line 201
  inst->estimated_offset_sd = 86400.0;
#line 202
  inst->offset_time.tv_sec = (__time_t )0;
#line 203
  inst->offset_time.tv_usec = (__suseconds_t )0;
#line 204
  inst->variance = 16.0;
#line 205
  inst->nruns = 0;
  }
#line 206
  return (inst);
}
}
#line 212 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sourcestats.c"
void SST_DeleteInstance(SST_Stats inst ) 
{ 


  {
  {
#line 215
  free((void *)inst);
  }
#line 216
  return;
}
}
#line 222 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sourcestats.c"
static void prune_register(SST_Stats inst , int new_oldest ) 
{ 


  {
#line 225
  if (! new_oldest) {
#line 226
    return;
  }
#line 228
  if (! (inst->n_samples >= new_oldest)) {
    {
#line 228
    __assert_fail("inst->n_samples >= new_oldest", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sourcestats.c",
                  228U, "prune_register");
    }
  }
#line 229
  inst->n_samples -= new_oldest;
#line 230
  inst->runs_samples += new_oldest;
#line 231
  if (inst->runs_samples > inst->n_samples) {
#line 232
    inst->runs_samples = inst->n_samples;
  }
#line 234
  if (! (inst->n_samples + inst->runs_samples <= 128)) {
    {
#line 234
    __assert_fail("inst->n_samples + inst->runs_samples <= 64 * 2", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sourcestats.c",
                  234U, "prune_register");
    }
  }
  {
#line 236
  find_min_delay_sample(inst);
  }
#line 237
  return;
}
}
#line 241 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sourcestats.c"
void SST_AccumulateSample(SST_Stats inst , struct timeval *sample_time , double offset ,
                          double peer_delay , double peer_dispersion , double root_delay ,
                          double root_dispersion , int stratum ) 
{ 
  int n ;
  int m ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 251
  if (inst->n_samples > 0) {
#line 251
    if (inst->n_samples == 64) {
      {
#line 253
      prune_register(inst, 1);
      }
    } else
#line 251
    if (inst->n_samples == max_samples) {
      {
#line 253
      prune_register(inst, 1);
      }
    }
  }
#line 257
  if (inst->n_samples) {
    {
#line 257
    tmp___2 = UTI_CompareTimevals(& inst->sample_times[inst->last_sample], sample_time);
    }
#line 257
    if (tmp___2 >= 0) {
      {
#line 259
      LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/sourcestats.c",
                   259, "SST_AccumulateSample");
      }
#line 259
      if (inst->ip_addr) {
        {
#line 259
        tmp = UTI_IPToString(inst->ip_addr);
#line 259
        tmp___1 = tmp;
        }
      } else {
        {
#line 259
        tmp___0 = UTI_RefidToString(inst->refid);
#line 259
        tmp___1 = tmp___0;
        }
      }
      {
#line 259
      LOG_Line_Function((LOG_Severity )1, (LOG_Facility )5, "Out of order sample detected, discarding history for %s",
                        tmp___1);
#line 261
      prune_register(inst, inst->n_samples);
      }
    }
  }
#line 264
  tmp___3 = (inst->last_sample + 1) % 128;
#line 264
  inst->last_sample = tmp___3;
#line 264
  n = tmp___3;
#line 266
  m = n % 64;
#line 268
  inst->sample_times[n] = *sample_time;
#line 269
  inst->offsets[n] = offset;
#line 270
  inst->orig_offsets[m] = offset;
#line 271
  inst->peer_delays[m] = peer_delay;
#line 272
  inst->peer_dispersions[m] = peer_dispersion;
#line 273
  inst->root_delays[m] = root_delay;
#line 274
  inst->root_dispersions[m] = root_dispersion;
#line 275
  inst->strata[m] = stratum;
#line 277
  if (! inst->n_samples) {
#line 278
    inst->min_delay_sample = m;
  } else
#line 277
  if (inst->peer_delays[m] < inst->peer_delays[inst->min_delay_sample]) {
#line 278
    inst->min_delay_sample = m;
  }
#line 280
  (inst->n_samples) ++;
#line 281
  return;
}
}
#line 287 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sourcestats.c"
static int get_runsbuf_index(SST_Stats inst , int i ) 
{ 


  {
#line 290
  return ((int )((unsigned int )((((inst->last_sample + 256) - inst->n_samples) + i) + 1) % 128U));
}
}
#line 297 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sourcestats.c"
static int get_buf_index(SST_Stats inst , int i ) 
{ 


  {
#line 300
  return ((int )((unsigned int )((((inst->last_sample + 128) - inst->n_samples) + i) + 1) % 64U));
}
}
#line 309 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sourcestats.c"
static void convert_to_intervals(SST_Stats inst , double *times_back ) 
{ 
  struct timeval *newest_tv ;
  int i ;
  int tmp ;

  {
#line 315
  newest_tv = & inst->sample_times[inst->last_sample];
#line 316
  i = - inst->runs_samples;
  {
#line 316
  while (1) {
    while_continue: /* CIL Label */ ;
#line 316
    if (! (i < inst->n_samples)) {
#line 316
      goto while_break;
    }
    {
#line 318
    tmp = get_runsbuf_index(inst, i);
#line 318
    UTI_DiffTimevalsToDouble(times_back + i, & inst->sample_times[tmp], newest_tv);
#line 316
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 321
  return;
}
}
#line 325 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sourcestats.c"
static void find_best_sample_index(SST_Stats inst , double *times_back ) 
{ 
  double root_distance ;
  double best_root_distance ;
  double elapsed ;
  int i ;
  int j ;
  int best_index ;

  {
#line 335
  if (! inst->n_samples) {
#line 336
    return;
  }
#line 338
  best_index = -1;
#line 339
  best_root_distance = (double )1.79769313486231570815e+308L;
#line 341
  i = 0;
  {
#line 341
  while (1) {
    while_continue: /* CIL Label */ ;
#line 341
    if (! (i < inst->n_samples)) {
#line 341
      goto while_break;
    }
    {
#line 342
    j = get_buf_index(inst, i);
#line 344
    elapsed = - *(times_back + i);
    }
#line 345
    if (! (elapsed >= 0.0)) {
      {
#line 345
      __assert_fail("elapsed >= 0.0", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sourcestats.c",
                    345U, "find_best_sample_index");
      }
    }
#line 347
    root_distance = (inst->root_dispersions[j] + elapsed * inst->skew) + 0.5 * inst->root_delays[j];
#line 348
    if (root_distance < best_root_distance) {
#line 349
      best_root_distance = root_distance;
#line 350
      best_index = i;
    }
#line 341
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 354
  if (! (best_index >= 0)) {
    {
#line 354
    __assert_fail("best_index >= 0", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sourcestats.c",
                  354U, "find_best_sample_index");
    }
  }
#line 355
  inst->best_single_sample = best_index;
#line 360
  return;
}
}
#line 364 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sourcestats.c"
static void find_min_delay_sample(SST_Stats inst ) 
{ 
  int i ;
  int index___0 ;

  {
  {
#line 369
  inst->min_delay_sample = get_buf_index(inst, 0);
#line 371
  i = 1;
  }
  {
#line 371
  while (1) {
    while_continue: /* CIL Label */ ;
#line 371
    if (! (i < inst->n_samples)) {
#line 371
      goto while_break;
    }
    {
#line 372
    index___0 = get_buf_index(inst, i);
    }
#line 373
    if (inst->peer_delays[index___0] < inst->peer_delays[inst->min_delay_sample]) {
#line 374
      inst->min_delay_sample = index___0;
    }
#line 371
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 376
  return;
}
}
#line 393 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sourcestats.c"
void SST_DoNewRegression(SST_Stats inst ) 
{ 
  double times_back[128] ;
  double offsets[128] ;
  double peer_distances[64] ;
  double weights[64] ;
  int degrees_of_freedom ;
  int best_start ;
  int times_back_start ;
  double est_intercept ;
  double est_slope ;
  double est_var ;
  double est_intercept_sd ;
  double est_slope_sd ;
  int i ;
  int j ;
  int nruns ;
  double min_distance ;
  double mean_distance ;
  double sd_weight ;
  double sd ;
  double old_skew ;
  double old_freq ;
  double stress ;
  int tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;

  {
  {
#line 409
  convert_to_intervals(inst, times_back + inst->runs_samples);
  }
#line 411
  if (inst->n_samples > 0) {
#line 412
    i = - inst->runs_samples;
    {
#line 412
    while (1) {
      while_continue: /* CIL Label */ ;
#line 412
      if (! (i < inst->n_samples)) {
#line 412
        goto while_break;
      }
      {
#line 413
      tmp = get_runsbuf_index(inst, i);
#line 413
      offsets[i + inst->runs_samples] = inst->offsets[tmp];
#line 412
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 416
    i = 0;
#line 416
    mean_distance = 0.0;
#line 416
    min_distance = (double )1.79769313486231570815e+308L;
    {
#line 416
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 416
      if (! (i < inst->n_samples)) {
#line 416
        goto while_break___0;
      }
      {
#line 417
      j = get_buf_index(inst, i);
#line 418
      peer_distances[i] = 0.5 * inst->peer_delays[j] + inst->peer_dispersions[j];
#line 419
      mean_distance += peer_distances[i];
      }
#line 420
      if (peer_distances[i] < min_distance) {
#line 421
        min_distance = peer_distances[i];
      }
#line 416
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 424
    mean_distance /= (double )inst->n_samples;
#line 428
    sd = mean_distance - min_distance;
#line 429
    if (sd > min_distance) {
#line 430
      sd = min_distance;
    } else
#line 429
    if (sd <= 0.0) {
#line 430
      sd = min_distance;
    }
#line 432
    i = 0;
    {
#line 432
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 432
      if (! (i < inst->n_samples)) {
#line 432
        goto while_break___1;
      }
#line 433
      sd_weight = 1.0 + (1.0 * (peer_distances[i] - min_distance)) / sd;
#line 434
      weights[i] = sd_weight * sd_weight;
#line 432
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 438
  inst->regression_ok = RGR_FindBestRegression(times_back + inst->runs_samples, offsets + inst->runs_samples,
                                               weights, inst->n_samples, inst->runs_samples,
                                               min_samples, & est_intercept, & est_slope,
                                               & est_var, & est_intercept_sd, & est_slope_sd,
                                               & best_start, & nruns, & degrees_of_freedom);
  }
#line 446
  if (inst->regression_ok) {
    {
#line 448
    old_skew = inst->skew;
#line 449
    old_freq = inst->estimated_frequency;
#line 451
    inst->estimated_frequency = est_slope;
#line 452
    tmp___0 = RGR_GetTCoef(degrees_of_freedom);
#line 452
    inst->skew = est_slope_sd * tmp___0;
#line 453
    inst->estimated_offset = est_intercept;
#line 454
    inst->offset_time = inst->sample_times[inst->last_sample];
#line 455
    inst->estimated_offset_sd = est_intercept_sd;
#line 456
    inst->variance = est_var;
#line 457
    inst->nruns = nruns;
    }
#line 459
    if (inst->skew < 1.0e-12) {
#line 460
      inst->skew = 1.0e-12;
    }
    {
#line 462
    tmp___1 = fabs(old_freq - inst->estimated_frequency);
#line 462
    stress = tmp___1 / old_skew;
    }
#line 464
    if (best_start > 0) {
#line 467
      inst->skew_dirn = (SST_Skew_Direction )1;
    } else
#line 469
    if (inst->skew < old_skew) {
#line 470
      inst->skew_dirn = (SST_Skew_Direction )0;
    } else {
#line 472
      inst->skew_dirn = (SST_Skew_Direction )2;
    }
#line 476
    if (logfileid___3 != -1) {
      {
#line 477
      tmp___2 = sqrt(inst->variance);
      }
#line 477
      if (inst->ip_addr) {
        {
#line 477
        tmp___3 = UTI_IPToString(inst->ip_addr);
#line 477
        tmp___5 = tmp___3;
        }
      } else {
        {
#line 477
        tmp___4 = UTI_RefidToString(inst->refid);
#line 477
        tmp___5 = tmp___4;
        }
      }
      {
#line 477
      tmp___6 = UTI_TimeToLogForm(inst->offset_time.tv_sec);
#line 477
      LOG_FileWrite(logfileid___3, "%s %-15s %10.3e %10.3e %10.3e %10.3e %10.3e %7.1e %3d %3d %3d",
                    tmp___6, tmp___5, tmp___2, inst->estimated_offset, inst->estimated_offset_sd,
                    inst->estimated_frequency, inst->skew, stress, inst->n_samples,
                    best_start, nruns);
      }
    }
    {
#line 490
    times_back_start = inst->runs_samples + best_start;
#line 491
    prune_register(inst, best_start);
    }
  } else {
#line 496
    inst->estimated_frequency = 0.0;
#line 497
    inst->skew = 2000.0 / 1.0e6;
#line 498
    times_back_start = 0;
  }
  {
#line 501
  find_best_sample_index(inst, times_back + times_back_start);
  }
#line 503
  return;
}
}
#line 510 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sourcestats.c"
void SST_GetFrequencyRange(SST_Stats inst , double *lo , double *hi ) 
{ 
  double freq ;
  double skew ;

  {
#line 515
  freq = inst->estimated_frequency;
#line 516
  skew = inst->skew;
#line 517
  *lo = freq - skew;
#line 518
  *hi = freq + skew;
#line 523
  if (skew > 2000.0 / 1.0e6) {
#line 524
    *lo = - (2000.0 / 1.0e6);
#line 525
    *hi = 2000.0 / 1.0e6;
  }
#line 527
  return;
}
}
#line 531 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sourcestats.c"
void SST_GetSelectionData(SST_Stats inst , struct timeval *now , int *stratum , double *offset_lo_limit ,
                          double *offset_hi_limit , double *root_distance , double *variance ,
                          int *select_ok ) 
{ 
  double offset ;
  double sample_elapsed ;
  int i ;
  int j ;
  int tmp ;

  {
  {
#line 542
  i = get_runsbuf_index(inst, inst->best_single_sample);
#line 543
  j = get_buf_index(inst, inst->best_single_sample);
#line 545
  tmp = get_buf_index(inst, inst->n_samples - 1);
#line 545
  *stratum = inst->strata[tmp];
#line 546
  *variance = inst->variance;
#line 548
  UTI_DiffTimevalsToDouble(& sample_elapsed, now, & inst->sample_times[i]);
#line 549
  offset = inst->offsets[i] + sample_elapsed * inst->estimated_frequency;
#line 550
  *root_distance = (0.5 * inst->root_delays[j] + inst->root_dispersions[j]) + sample_elapsed * inst->skew;
#line 553
  *offset_lo_limit = offset - *root_distance;
#line 554
  *offset_hi_limit = offset + *root_distance;
#line 570
  *select_ok = inst->regression_ok;
  }
#line 576
  return;
}
}
#line 580 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sourcestats.c"
void SST_GetTrackingData(SST_Stats inst , struct timeval *ref_time , double *average_offset ,
                         double *offset_sd , double *frequency , double *skew , double *root_delay ,
                         double *root_dispersion ) 
{ 
  int i ;
  int j ;
  double elapsed_sample ;

  {
  {
#line 589
  i = get_runsbuf_index(inst, inst->best_single_sample);
#line 590
  j = get_buf_index(inst, inst->best_single_sample);
#line 592
  *ref_time = inst->offset_time;
#line 593
  *average_offset = inst->estimated_offset;
#line 594
  *offset_sd = inst->estimated_offset_sd;
#line 595
  *frequency = inst->estimated_frequency;
#line 596
  *skew = inst->skew;
#line 597
  *root_delay = inst->root_delays[j];
#line 599
  UTI_DiffTimevalsToDouble(& elapsed_sample, & inst->offset_time, & inst->sample_times[i]);
#line 600
  *root_dispersion = inst->root_dispersions[j] + inst->skew * elapsed_sample;
  }
#line 607
  return;
}
}
#line 611 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sourcestats.c"
void SST_SlewSamples(SST_Stats inst , struct timeval *when , double dfreq , double doffset ) 
{ 
  int m ;
  int i ;
  double delta_time ;
  struct timeval *sample ;
  struct timeval prev ;
  double prev_offset ;
  double prev_freq ;

  {
#line 619
  if (! inst->n_samples) {
#line 620
    return;
  }
#line 622
  m = - inst->runs_samples;
  {
#line 622
  while (1) {
    while_continue: /* CIL Label */ ;
#line 622
    if (! (m < inst->n_samples)) {
#line 622
      goto while_break;
    }
    {
#line 623
    i = get_runsbuf_index(inst, m);
#line 624
    sample = & inst->sample_times[i];
#line 625
    prev = *sample;
#line 626
    UTI_AdjustTimeval(sample, when, sample, & delta_time, dfreq, doffset);
#line 627
    prev_offset = inst->offsets[i];
#line 628
    inst->offsets[i] += delta_time;
#line 622
    m ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 639
  prev = inst->offset_time;
#line 640
  prev_offset = inst->estimated_offset;
#line 641
  prev_freq = inst->estimated_frequency;
#line 642
  UTI_AdjustTimeval(& inst->offset_time, when, & inst->offset_time, & delta_time,
                    dfreq, doffset);
#line 644
  inst->estimated_offset += delta_time;
#line 645
  inst->estimated_frequency -= dfreq;
  }
#line 655
  return;
}
}
#line 659 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sourcestats.c"
void SST_AddDispersion(SST_Stats inst , double dispersion ) 
{ 
  int m ;
  int i ;

  {
#line 664
  m = 0;
  {
#line 664
  while (1) {
    while_continue: /* CIL Label */ ;
#line 664
    if (! (m < inst->n_samples)) {
#line 664
      goto while_break;
    }
    {
#line 665
    i = get_buf_index(inst, m);
#line 666
    inst->root_dispersions[i] += dispersion;
#line 667
    inst->peer_dispersions[i] += dispersion;
#line 664
    m ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 669
  return;
}
}
#line 673 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sourcestats.c"
double SST_PredictOffset(SST_Stats inst , struct timeval *when ) 
{ 
  double elapsed ;

  {
#line 678
  if (inst->n_samples < 3) {
#line 682
    if (inst->n_samples > 0) {
#line 683
      return (inst->offsets[inst->last_sample]);
    } else {
#line 685
      return (0.0);
    }
  } else {
    {
#line 688
    UTI_DiffTimevalsToDouble(& elapsed, when, & inst->offset_time);
    }
#line 689
    return (inst->estimated_offset + elapsed * inst->estimated_frequency);
  }
}
}
#line 696 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sourcestats.c"
double SST_MinRoundTripDelay(SST_Stats inst ) 
{ 


  {
#line 699
  if (! inst->n_samples) {
#line 700
    return ((double )1.79769313486231570815e+308L);
  }
#line 701
  return (inst->peer_delays[inst->min_delay_sample]);
}
}
#line 706 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sourcestats.c"
int SST_IsGoodSample(SST_Stats inst , double offset , double delay , double max_delay_dev_ratio ,
                     double clock_error , struct timeval *when ) 
{ 
  double elapsed ;
  double allowed_increase ;
  double delay_increase ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;

  {
#line 712
  if (inst->n_samples < 3) {
#line 713
    return (1);
  }
  {
#line 715
  UTI_DiffTimevalsToDouble(& elapsed, when, & inst->offset_time);
#line 721
  tmp = sqrt(inst->variance);
#line 721
  allowed_increase = tmp * max_delay_dev_ratio + elapsed * (inst->skew + clock_error);
#line 723
  tmp___0 = SST_MinRoundTripDelay(inst);
#line 723
  delay_increase = (delay - tmp___0) / 2.0;
  }
#line 725
  if (delay_increase < allowed_increase) {
#line 726
    return (1);
  }
  {
#line 728
  offset -= inst->estimated_offset + elapsed * inst->estimated_frequency;
#line 733
  tmp___1 = fabs(offset);
  }
#line 733
  if (tmp___1 - delay_increase > allowed_increase) {
#line 734
    return (1);
  }
#line 740
  return (0);
}
}
#line 747 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sourcestats.c"
void SST_SaveToFile(SST_Stats inst , FILE *out ) 
{ 
  int m ;
  int i ;
  int j ;

  {
  {
#line 752
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%d\n", inst->n_samples);
#line 754
  m = 0;
  }
  {
#line 754
  while (1) {
    while_continue: /* CIL Label */ ;
#line 754
    if (! (m < inst->n_samples)) {
#line 754
      goto while_break;
    }
    {
#line 755
    i = get_runsbuf_index(inst, m);
#line 756
    j = get_buf_index(inst, m);
#line 758
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%08lx %08lx %.6e %.6e %.6e %.6e %.6e %.6e %.6e %d\n",
            (unsigned long )inst->sample_times[i].tv_sec, (unsigned long )inst->sample_times[i].tv_usec,
            inst->offsets[i], inst->orig_offsets[j], inst->peer_delays[j], inst->peer_dispersions[j],
            inst->root_delays[j], inst->root_dispersions[j], 1.0, inst->strata[j]);
#line 754
    m ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 771
  return;
}
}
#line 776 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sourcestats.c"
int SST_LoadFromFile(SST_Stats inst , FILE *in ) 
{ 
  int i ;
  int line_number___0 ;
  char line___0[1024] ;
  unsigned long sec ;
  unsigned long usec ;
  double weight ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 784
  tmp___1 = fgets((char */* __restrict  */)(line___0), (int )sizeof(line___0), (FILE */* __restrict  */)in);
  }
#line 784
  if (tmp___1) {
    {
#line 784
    tmp___2 = sscanf((char const   */* __restrict  */)(line___0), (char const   */* __restrict  */)"%u",
                     & inst->n_samples);
    }
#line 784
    if (tmp___2 == 1) {
#line 784
      if (inst->n_samples <= 64) {
#line 787
        line_number___0 = 2;
#line 789
        i = 0;
        {
#line 789
        while (1) {
          while_continue: /* CIL Label */ ;
#line 789
          if (! (i < inst->n_samples)) {
#line 789
            goto while_break;
          }
          {
#line 790
          tmp = fgets((char */* __restrict  */)(line___0), (int )sizeof(line___0),
                      (FILE */* __restrict  */)in);
          }
#line 790
          if (tmp) {
            {
#line 790
            tmp___0 = sscanf((char const   */* __restrict  */)(line___0), (char const   */* __restrict  */)"%lx%lx%lf%lf%lf%lf%lf%lf%lf%d\n",
                             & sec, & usec, & inst->offsets[i], & inst->orig_offsets[i],
                             & inst->peer_delays[i], & inst->peer_dispersions[i],
                             & inst->root_delays[i], & inst->root_dispersions[i],
                             & weight, & inst->strata[i]);
            }
#line 790
            if (tmp___0 != 10) {
              {
#line 804
              LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/sourcestats.c",
                           804, "SST_LoadFromFile");
#line 804
              LOG_Line_Function((LOG_Severity )1, (LOG_Facility )5, "Failed to read data from line %d of dump file",
                                line_number___0);
#line 805
              inst->n_samples = 0;
              }
#line 806
              return (0);
            } else {
#line 810
              inst->sample_times[i].tv_sec = (__time_t )sec;
#line 811
              inst->sample_times[i].tv_usec = (__suseconds_t )usec;
#line 813
              line_number___0 ++;
            }
          } else {
            {
#line 804
            LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/sourcestats.c",
                         804, "SST_LoadFromFile");
#line 804
            LOG_Line_Function((LOG_Severity )1, (LOG_Facility )5, "Failed to read data from line %d of dump file",
                              line_number___0);
#line 805
            inst->n_samples = 0;
            }
#line 806
            return (0);
          }
#line 789
          i ++;
        }
        while_break: /* CIL Label */ ;
        }
      } else {
        {
#line 817
        LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/sourcestats.c",
                     817, "SST_LoadFromFile");
#line 817
        LOG_Line_Function((LOG_Severity )1, (LOG_Facility )5, "Could not read number of samples from dump file");
#line 818
        inst->n_samples = 0;
        }
#line 819
        return (0);
      }
    } else {
      {
#line 817
      LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/sourcestats.c",
                   817, "SST_LoadFromFile");
#line 817
      LOG_Line_Function((LOG_Severity )1, (LOG_Facility )5, "Could not read number of samples from dump file");
#line 818
      inst->n_samples = 0;
      }
#line 819
      return (0);
    }
  } else {
    {
#line 817
    LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/sourcestats.c",
                 817, "SST_LoadFromFile");
#line 817
    LOG_Line_Function((LOG_Severity )1, (LOG_Facility )5, "Could not read number of samples from dump file");
#line 818
    inst->n_samples = 0;
    }
#line 819
    return (0);
  }
  {
#line 822
  inst->last_sample = inst->n_samples - 1;
#line 823
  inst->runs_samples = 0;
#line 825
  find_min_delay_sample(inst);
  }
#line 827
  return (1);
}
}
#line 833 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sourcestats.c"
void SST_DoSourceReport(SST_Stats inst , RPT_SourceReport *report , struct timeval *now ) 
{ 
  int i ;
  int j ;
  struct timeval ago ;

  {
#line 839
  if (inst->n_samples > 0) {
    {
#line 840
    i = get_runsbuf_index(inst, inst->n_samples - 1);
#line 841
    j = get_buf_index(inst, inst->n_samples - 1);
#line 842
    report->orig_latest_meas = inst->orig_offsets[j];
#line 843
    report->latest_meas = inst->offsets[i];
#line 844
    report->latest_meas_err = 0.5 * inst->root_delays[j] + inst->root_dispersions[j];
#line 845
    report->stratum = inst->strata[j];
#line 847
    UTI_DiffTimevals(& ago, now, & inst->sample_times[i]);
#line 848
    report->latest_meas_ago = (unsigned long )ago.tv_sec;
    }
  } else {
#line 850
    report->latest_meas_ago = 315360000UL;
#line 851
    report->orig_latest_meas = (double )0;
#line 852
    report->latest_meas = (double )0;
#line 853
    report->latest_meas_err = (double )0;
#line 854
    report->stratum = 0;
  }
#line 856
  return;
}
}
#line 861 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sourcestats.c"
SST_Skew_Direction SST_LastSkewChange(SST_Stats inst ) 
{ 


  {
#line 863
  return (inst->skew_dirn);
}
}
#line 868 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sourcestats.c"
int SST_Samples(SST_Stats inst ) 
{ 


  {
#line 871
  return (inst->n_samples);
}
}
#line 876 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/sourcestats.c"
void SST_DoSourcestatsReport(SST_Stats inst , RPT_SourcestatsReport *report , struct timeval *now ) 
{ 
  double dspan ;
  double elapsed ;
  double sample_elapsed ;
  int li ;
  int lj ;
  int bi ;
  int bj ;
  int tmp ;

  {
#line 883
  report->n_samples = (unsigned long )inst->n_samples;
#line 884
  report->n_runs = (unsigned long )inst->nruns;
#line 886
  if (inst->n_samples > 1) {
    {
#line 887
    li = get_runsbuf_index(inst, inst->n_samples - 1);
#line 888
    lj = get_buf_index(inst, inst->n_samples - 1);
#line 889
    tmp = get_runsbuf_index(inst, 0);
#line 889
    UTI_DiffTimevalsToDouble(& dspan, & inst->sample_times[li], & inst->sample_times[tmp]);
#line 891
    report->span_seconds = (unsigned long )(dspan + 0.5);
    }
#line 893
    if (inst->n_samples > 3) {
      {
#line 894
      UTI_DiffTimevalsToDouble(& elapsed, now, & inst->offset_time);
#line 895
      bi = get_runsbuf_index(inst, inst->best_single_sample);
#line 896
      bj = get_buf_index(inst, inst->best_single_sample);
#line 897
      UTI_DiffTimevalsToDouble(& sample_elapsed, now, & inst->sample_times[bi]);
#line 898
      report->est_offset = inst->estimated_offset + elapsed * inst->estimated_frequency;
#line 899
      report->est_offset_err = (inst->estimated_offset_sd + sample_elapsed * inst->skew) + (0.5 * inst->root_delays[bj] + inst->root_dispersions[bj]);
      }
    } else {
#line 903
      report->est_offset = inst->offsets[li];
#line 904
      report->est_offset_err = 0.5 * inst->root_delays[lj] + inst->root_dispersions[lj];
    }
  } else {
#line 907
    report->span_seconds = 0UL;
#line 908
    report->est_offset = (double )0;
#line 909
    report->est_offset_err = (double )0;
  }
  {
#line 912
  report->resid_freq_ppm = 1.0e6 * inst->estimated_frequency;
#line 913
  report->skew_ppm = 1.0e6 * inst->skew;
#line 914
  report->sd = sqrt(inst->variance);
  }
#line 915
  return;
}
}
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 183
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 53 "/usr/include/x86_64-linux-gnu/sys/shm.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) shmget)(key_t __key ,
                                                                             size_t __size ,
                                                                             int __shmflg ) ;
#line 56
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) shmat)(int __shmid ,
                                                                              void const   *__shmaddr ,
                                                                              int __shmflg ) ;
#line 60
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) shmdt)(void const   *__shmaddr ) ;
#line 61 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/refclock_shm.c"
static int shm_initialise(RCL_Instance instance ) 
{ 
  int id ;
  int param ;
  int perm ;
  char *s ;
  struct shmTime *shm ;
  char *tmp ;
  long tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 66
  tmp = RCL_GetDriverParameter(instance);
#line 66
  param = atoi((char const   *)tmp);
#line 67
  s = RCL_GetDriverOption(instance, (char *)"perm");
  }
#line 68
  if (s) {
    {
#line 68
    tmp___0 = strtol((char const   */* __restrict  */)s, (char **/* __restrict  */)((void *)0),
                     8);
#line 68
    perm = (int )(tmp___0 & 511L);
    }
  } else {
#line 68
    perm = 384;
  }
  {
#line 70
  id = shmget(1314148400 + param, sizeof(struct shmTime ), 512 | perm);
  }
#line 71
  if (id == -1) {
    {
#line 72
    LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/refclock_shm.c",
                 72, "shm_initialise");
#line 72
    LOG_Fatal_Function((LOG_Facility )26, "shmget() failed");
    }
#line 73
    return (0);
  }
  {
#line 76
  tmp___1 = shmat(id, (void const   *)0, 0);
#line 76
  shm = (struct shmTime *)tmp___1;
  }
#line 77
  if ((long )shm == -1L) {
    {
#line 78
    LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/refclock_shm.c",
                 78, "shm_initialise");
#line 78
    LOG_Fatal_Function((LOG_Facility )26, "shmat() failed");
    }
#line 79
    return (0);
  }
  {
#line 82
  RCL_SetDriverData(instance, (void *)shm);
  }
#line 83
  return (1);
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/refclock_shm.c"
static void shm_finalise(RCL_Instance instance ) 
{ 
  void *tmp ;

  {
  {
#line 88
  tmp = RCL_GetDriverData(instance);
#line 88
  shmdt((void const   *)tmp);
  }
#line 89
  return;
}
}
#line 91 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/refclock_shm.c"
static int shm_poll(RCL_Instance instance ) 
{ 
  struct timeval tv ;
  struct shmTime t ;
  struct shmTime *shm ;
  double offset ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 97
  tmp = RCL_GetDriverData(instance);
#line 97
  shm = (struct shmTime *)tmp;
#line 99
  t = *shm;
  }
#line 101
  if (t.mode == 1) {
#line 101
    if (t.count != shm->count) {
#line 106
      return (0);
    } else {
#line 101
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 101
  if (t.mode == 0) {
#line 101
    goto _L;
  } else
#line 101
  if (t.mode == 1) {
    _L: /* CIL Label */ 
#line 101
    if (! t.valid) {
#line 106
      return (0);
    }
  } else {
#line 106
    return (0);
  }
#line 109
  shm->valid = (int volatile   )0;
#line 111
  tv.tv_sec = t.receiveTimeStampSec;
#line 112
  tv.tv_usec = (__suseconds_t )t.receiveTimeStampUSec;
#line 114
  offset = (double )(t.clockTimeStampSec - t.receiveTimeStampSec);
#line 115
  if (t.clockTimeStampNSec / 1000 == t.clockTimeStampUSec) {
#line 115
    if (t.receiveTimeStampNSec / 1000 == t.receiveTimeStampUSec) {
#line 117
      offset += (double )(t.clockTimeStampNSec - t.receiveTimeStampNSec) * 1e-9;
    } else {
#line 119
      offset += (double )(t.clockTimeStampUSec - t.receiveTimeStampUSec) * 1e-6;
    }
  } else {
#line 119
    offset += (double )(t.clockTimeStampUSec - t.receiveTimeStampUSec) * 1e-6;
  }
  {
#line 121
  tmp___0 = RCL_AddSample(instance, & tv, offset, t.leap);
  }
#line 121
  return (tmp___0);
}
}
#line 124 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/refclock_shm.c"
RefclockDriver RCL_SHM_driver  =    {& shm_initialise, & shm_finalise, & shm_poll};
#line 689 "/usr/include/stdio.h"
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 873
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 879
extern int pclose(FILE *__stream ) ;
#line 100 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) exp)(double __x ) ;
#line 564 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 584
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) setenv)(char const   *__name ,
                                                                                             char const   *__value ,
                                                                                             int __replace ) ;
#line 588
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unsetenv)(char const   *__name ) ;
#line 293 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) tzset)(void) ;
#line 879 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gethostname)(char *__name ,
                                                                                                  size_t __len ) ;
#line 45 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c"
static int are_we_synchronised  ;
#line 46 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c"
static int enable_local_stratum  ;
#line 47 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c"
static int local_stratum___0  ;
#line 48 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c"
static NTP_Leap our_leap_status  ;
#line 49 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c"
static int our_leap_sec  ;
#line 50 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c"
static int our_stratum  ;
#line 51 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c"
static uint32_t our_ref_id  ;
#line 52 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c"
static IPAddr our_ref_ip  ;
#line 53 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c"
struct timeval our_ref_time  ;
#line 54 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c"
static double our_skew  ;
#line 55 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c"
static double our_residual_freq  ;
#line 56 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c"
static double our_root_delay  ;
#line 57 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c"
static double our_root_dispersion  ;
#line 59 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c"
static double max_update_skew___0  ;
#line 61 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c"
static double last_offset  ;
#line 62 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c"
static double avg2_offset  ;
#line 63 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c"
static int avg2_moving  ;
#line 65 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c"
static double correction_time_ratio___0  ;
#line 68 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c"
static int initialised___5  =    0;
#line 71 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c"
static int make_step_limit___0  ;
#line 72 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c"
static double make_step_threshold___0  ;
#line 76 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c"
static int max_offset_delay___0  ;
#line 77 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c"
static int max_offset_ignore___0  ;
#line 78 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c"
static double max_offset___0  ;
#line 81 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c"
static int do_log_change___0  ;
#line 82 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c"
static double log_change_threshold___0  ;
#line 85 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c"
static int do_mail_change  ;
#line 86 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c"
static double mail_change_threshold___0  ;
#line 87 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c"
static char *mail_change_user  ;
#line 90 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c"
static char *drift_file___0  =    (char *)((void *)0);
#line 91 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c"
static double drift_file_age  ;
#line 93
static void update_drift_file(double freq_ppm , double skew ) ;
#line 96 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c"
static char *leap_tzname  ;
#line 97 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c"
static time_t last_tz_leap_check  ;
#line 98 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c"
static NTP_Leap tz_leap  ;
#line 102 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c"
static LOG_FileID logfileid___4  ;
#line 119 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c"
static int fb_drift_min___0  ;
#line 120 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c"
static int fb_drift_max___0  ;
#line 122 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c"
static struct fb_drift *fb_drifts  =    (struct fb_drift *)((void *)0);
#line 123 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c"
static int next_fb_drift  ;
#line 124 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c"
static SCH_TimeoutID fb_drift_timeout_id  ;
#line 127 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c"
static struct timeval last_ref_update  ;
#line 128 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c"
static double last_ref_update_interval  ;
#line 132
static NTP_Leap get_tz_leap(time_t when ) ;
#line 136 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c"
static void handle_slew___0(struct timeval *raw , struct timeval *cooked , double dfreq ,
                            double doffset , int is_step_change , void *anything ) 
{ 


  {
#line 144
  if (is_step_change) {
    {
#line 145
    UTI_AddDoubleToTimeval(& last_ref_update, - doffset, & last_ref_update);
    }
  }
#line 147
  return;
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c"
void REF_Initialise(void) 
{ 
  FILE *in ;
  double file_freq_ppm ;
  double file_skew_ppm ;
  double our_frequency_ppm ;
  int tmp ;
  LOG_FileID tmp___1 ;
  int tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  NTP_Leap tmp___5 ;
  NTP_Leap tmp___6 ;
  void *tmp___7 ;

  {
  {
#line 158
  are_we_synchronised = 0;
#line 159
  our_leap_status = (NTP_Leap )3;
#line 160
  our_leap_sec = 0;
#line 161
  initialised___5 = 1;
#line 162
  our_root_dispersion = 1.0;
#line 163
  our_root_delay = 1.0;
#line 164
  our_frequency_ppm = 0.0;
#line 165
  our_skew = 1.0;
#line 166
  our_residual_freq = 0.0;
#line 167
  drift_file_age = 0.0;
#line 170
  drift_file___0 = CNF_GetDriftFile();
  }
#line 171
  if (drift_file___0) {
    {
#line 172
    in = fopen((char const   */* __restrict  */)drift_file___0, (char const   */* __restrict  */)"r");
    }
#line 173
    if (in) {
      {
#line 174
      tmp = fscanf((FILE */* __restrict  */)in, (char const   */* __restrict  */)"%lf%lf",
                   & file_freq_ppm, & file_skew_ppm);
      }
#line 174
      if (tmp == 2) {
#line 176
        our_frequency_ppm = file_freq_ppm;
#line 177
        our_skew = 1.0e-6 * file_skew_ppm;
#line 178
        if (our_skew < 1.0e-12) {
#line 179
          our_skew = 1.0e-12;
        }
        {
#line 180
        LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c",
                     180, "REF_Initialise");
#line 180
        LOG_Line_Function((LOG_Severity )0, (LOG_Facility )0, "Frequency %.3f +/- %.3f ppm read from %s",
                          file_freq_ppm, file_skew_ppm, drift_file___0);
#line 182
        LCL_SetAbsoluteFrequency(our_frequency_ppm);
        }
      } else {
        {
#line 184
        LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c",
                     184, "REF_Initialise");
#line 184
        LOG_Line_Function((LOG_Severity )1, (LOG_Facility )0, "Could not read valid frequency and skew from driftfile %s",
                          drift_file___0);
        }
      }
      {
#line 187
      fclose(in);
      }
    }
  }
#line 191
  if (our_frequency_ppm == 0.0) {
    {
#line 192
    our_frequency_ppm = LCL_ReadAbsoluteFrequency();
    }
#line 193
    if (our_frequency_ppm != 0.0) {
      {
#line 194
      LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c",
                   194, "REF_Initialise");
#line 194
      LOG_Line_Function((LOG_Severity )0, (LOG_Facility )0, "Initial frequency %.3f ppm",
                        our_frequency_ppm);
      }
    }
  }
  {
#line 198
  tmp___2 = CNF_GetLogTracking();
  }
#line 198
  if (tmp___2) {
    {
#line 198
    tmp___1 = LOG_FileOpen("tracking", "   Date (UTC) Time     IP Address   St   Freq ppm   Skew ppm     Offset L Co  Offset sd Rem. corr.");
#line 198
    logfileid___4 = tmp___1;
    }
  } else {
#line 198
    logfileid___4 = -1;
  }
  {
#line 202
  tmp___3 = CNF_GetMaxUpdateSkew();
#line 202
  tmp___4 = fabs(tmp___3);
#line 202
  max_update_skew___0 = tmp___4 * 1.0e-6;
#line 204
  correction_time_ratio___0 = CNF_GetCorrectionTimeRatio();
#line 206
  enable_local_stratum = CNF_AllowLocalReference(& local_stratum___0);
#line 208
  leap_tzname = CNF_GetLeapSecTimezone();
  }
#line 209
  if (leap_tzname) {
    {
#line 211
    tmp___5 = get_tz_leap((time_t )1214784000);
    }
#line 211
    if ((unsigned int )tmp___5 == 0U) {
      {
#line 211
      tmp___6 = get_tz_leap((time_t )1230681600);
      }
#line 211
      if ((unsigned int )tmp___6 == 1U) {
        {
#line 213
        LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c",
                     213, "REF_Initialise");
#line 213
        LOG_Line_Function((LOG_Severity )0, (LOG_Facility )0, "Using %s timezone to obtain leap second data",
                          leap_tzname);
        }
      } else {
        {
#line 215
        LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c",
                     215, "REF_Initialise");
#line 215
        LOG_Line_Function((LOG_Severity )1, (LOG_Facility )0, "Timezone %s failed leap second check, ignoring",
                          leap_tzname);
#line 216
        leap_tzname = (char *)((void *)0);
        }
      }
    } else {
      {
#line 215
      LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c",
                   215, "REF_Initialise");
#line 215
      LOG_Line_Function((LOG_Severity )1, (LOG_Facility )0, "Timezone %s failed leap second check, ignoring",
                        leap_tzname);
#line 216
      leap_tzname = (char *)((void *)0);
      }
    }
  }
  {
#line 220
  CNF_GetMakeStep(& make_step_limit___0, & make_step_threshold___0);
#line 221
  CNF_GetMaxChange(& max_offset_delay___0, & max_offset_ignore___0, & max_offset___0);
#line 222
  CNF_GetLogChange(& do_log_change___0, & log_change_threshold___0);
#line 223
  CNF_GetMailOnChange(& do_mail_change, & mail_change_threshold___0, & mail_change_user);
#line 225
  CNF_GetFallbackDrifts(& fb_drift_min___0, & fb_drift_max___0);
  }
#line 227
  if (fb_drift_max___0 >= fb_drift_min___0) {
#line 227
    if (fb_drift_min___0 > 0) {
      {
#line 228
      tmp___7 = malloc((unsigned long )((fb_drift_max___0 - fb_drift_min___0) + 1) * sizeof(struct fb_drift ));
#line 228
      fb_drifts = (struct fb_drift *)tmp___7;
#line 229
      memset((void *)fb_drifts, 0, sizeof(struct fb_drift ) * (unsigned long )((fb_drift_max___0 - fb_drift_min___0) + 1));
#line 230
      next_fb_drift = 0;
#line 231
      fb_drift_timeout_id = (SCH_TimeoutID )-1;
      }
    }
  }
  {
#line 234
  last_ref_update.tv_sec = (__time_t )0;
#line 235
  last_ref_update.tv_usec = (__suseconds_t )0;
#line 236
  last_ref_update_interval = 0.0;
#line 238
  LCL_AddParameterChangeHandler(& handle_slew___0, (void *)0);
  }
#line 241
  if (do_log_change___0) {
    {
#line 242
    log_change_threshold___0 = fabs(log_change_threshold___0);
    }
  }
  {
#line 246
  REF_SetUnsynchronised();
  }
#line 247
  return;
}
}
#line 251 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c"
void REF_Finalise(void) 
{ 
  double tmp ;

  {
#line 254
  if (our_leap_sec) {
    {
#line 255
    LCL_SetLeap(0);
    }
  }
#line 258
  if (drift_file___0) {
#line 258
    if (drift_file_age > 0.0) {
      {
#line 259
      tmp = LCL_ReadAbsoluteFrequency();
#line 259
      update_drift_file(tmp, our_skew);
      }
    }
  }
  {
#line 262
  free((void *)fb_drifts);
#line 264
  initialised___5 = 0;
  }
#line 265
  return;
}
}
#line 269 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c"
static double Sqr(double x ) 
{ 


  {
#line 272
  return (x * x);
}
}
#line 287 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c"
static void update_drift_file(double freq_ppm , double skew ) 
{ 
  struct stat buf ;
  char *temp_drift_file ;
  FILE *out ;
  size_t tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 296
  tmp = strlen((char const   *)drift_file___0);
#line 296
  tmp___0 = malloc(tmp + 8UL);
#line 296
  temp_drift_file = (char *)tmp___0;
  }
#line 298
  if (! temp_drift_file) {
#line 299
    return;
  }
  {
#line 302
  strcpy((char */* __restrict  */)temp_drift_file, (char const   */* __restrict  */)drift_file___0);
#line 303
  strcat((char */* __restrict  */)temp_drift_file, (char const   */* __restrict  */)".tmp");
#line 305
  out = fopen((char const   */* __restrict  */)temp_drift_file, (char const   */* __restrict  */)"w");
  }
#line 306
  if (! out) {
    {
#line 307
    free((void *)temp_drift_file);
#line 308
    LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c",
                 308, "update_drift_file");
#line 308
    LOG_Line_Function((LOG_Severity )1, (LOG_Facility )0, "Could not open temporary driftfile %s.tmp for writing",
                      drift_file___0);
    }
#line 310
    return;
  }
  {
#line 314
  tmp___1 = fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%20.6f %20.6f\n",
                    freq_ppm, 1.0e6 * skew);
#line 314
  tmp___2 = fclose(out);
  }
#line 314
  if ((tmp___1 < 0) | tmp___2) {
    {
#line 316
    free((void *)temp_drift_file);
#line 317
    LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c",
                 317, "update_drift_file");
#line 317
    LOG_Line_Function((LOG_Severity )1, (LOG_Facility )0, "Could not write to temporary driftfile %s.tmp",
                      drift_file___0);
    }
#line 319
    return;
  }
  {
#line 324
  tmp___4 = stat((char const   */* __restrict  */)drift_file___0, (struct stat */* __restrict  */)(& buf));
  }
#line 324
  if (! tmp___4) {
    {
#line 325
    tmp___3 = chown((char const   *)temp_drift_file, buf.st_uid, buf.st_gid);
    }
#line 325
    if (tmp___3) {
      {
#line 326
      LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c",
                   326, "update_drift_file");
#line 326
      LOG_Line_Function((LOG_Severity )1, (LOG_Facility )0, "Could not change ownership of temporary driftfile %s.tmp",
                        drift_file___0);
      }
    }
    {
#line 328
    chmod((char const   *)temp_drift_file, buf.st_mode & 511U);
    }
  }
  {
#line 333
  tmp___5 = rename((char const   *)temp_drift_file, (char const   *)drift_file___0);
  }
#line 333
  if (tmp___5) {
    {
#line 334
    unlink((char const   *)temp_drift_file);
#line 335
    free((void *)temp_drift_file);
#line 336
    LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c",
                 336, "update_drift_file");
#line 336
    LOG_Line_Function((LOG_Severity )1, (LOG_Facility )0, "Could not replace old driftfile %s with new one %s.tmp",
                      drift_file___0, drift_file___0);
    }
#line 338
    return;
  }
  {
#line 341
  free((void *)temp_drift_file);
  }
#line 342
  return;
}
}
#line 346 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c"
static void update_fb_drifts(double freq_ppm , double update_interval___0 ) 
{ 
  int i ;
  int secs ;
  double tmp ;
  double tmp___0 ;

  {
#line 351
  if (! are_we_synchronised) {
    {
#line 351
    __assert_fail("are_we_synchronised", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c",
                  351U, "update_fb_drifts");
    }
  }
#line 353
  if (next_fb_drift > 0) {
#line 359
    next_fb_drift = 0;
  }
#line 362
  if (fb_drift_timeout_id != 0xffffffffffffffffUL) {
    {
#line 363
    SCH_RemoveTimeout(fb_drift_timeout_id);
#line 364
    fb_drift_timeout_id = (SCH_TimeoutID )-1;
    }
  }
#line 367
  if (update_interval___0 < 0.0) {
#line 368
    return;
  } else
#line 367
  if (update_interval___0 > last_ref_update_interval * 4.0) {
#line 368
    return;
  }
#line 370
  i = 0;
  {
#line 370
  while (1) {
    while_continue: /* CIL Label */ ;
#line 370
    if (! (i < (fb_drift_max___0 - fb_drift_min___0) + 1)) {
#line 370
      goto while_break;
    }
    {
#line 372
    tmp = fabs(freq_ppm - (fb_drifts + i)->freq);
    }
#line 372
    if (tmp > 10.0) {
#line 373
      (fb_drifts + i)->secs = 0.0;
    }
#line 375
    secs = 1 << (i + fb_drift_min___0);
#line 376
    if ((fb_drifts + i)->secs < (double )secs) {
#line 379
      (fb_drifts + i)->freq = ((fb_drifts + i)->freq * (fb_drifts + i)->secs + (update_interval___0 * 0.5) * freq_ppm) / (update_interval___0 * 0.5 + (fb_drifts + i)->secs);
#line 381
      (fb_drifts + i)->secs += update_interval___0 * 0.5;
    } else {
      {
#line 386
      tmp___0 = exp(update_interval___0 / (double )secs);
#line 386
      (fb_drifts + i)->freq += ((double )1 - 1.0 / tmp___0) * (freq_ppm - (fb_drifts + i)->freq);
      }
    }
#line 370
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 395
  return;
}
}
#line 399 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c"
static void fb_drift_timeout(void *arg ) 
{ 


  {
#line 402
  if (! (are_we_synchronised == 0)) {
    {
#line 402
    __assert_fail("are_we_synchronised == 0", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c",
                  402U, "fb_drift_timeout");
    }
  }
#line 403
  if (next_fb_drift >= fb_drift_min___0) {
#line 403
    if (! (next_fb_drift <= fb_drift_max___0)) {
      {
#line 403
      __assert_fail("next_fb_drift >= fb_drift_min && next_fb_drift <= fb_drift_max",
                    "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c",
                    403U, "fb_drift_timeout");
      }
    }
  } else {
    {
#line 403
    __assert_fail("next_fb_drift >= fb_drift_min && next_fb_drift <= fb_drift_max",
                  "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c",
                  403U, "fb_drift_timeout");
    }
  }
  {
#line 405
  fb_drift_timeout_id = (SCH_TimeoutID )-1;
#line 407
  LCL_SetAbsoluteFrequency((fb_drifts + (next_fb_drift - fb_drift_min___0))->freq);
#line 408
  REF_SetUnsynchronised();
  }
#line 409
  return;
}
}
#line 413 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c"
static void schedule_fb_drift(struct timeval *now ) 
{ 
  int i ;
  int c ;
  int secs ;
  double unsynchronised ;
  struct timeval when ;

  {
#line 420
  if (fb_drift_timeout_id != 0xffffffffffffffffUL) {
#line 421
    return;
  }
  {
#line 423
  UTI_DiffTimevalsToDouble(& unsynchronised, now, & last_ref_update);
#line 425
  secs = 0;
#line 425
  c = secs;
#line 425
  i = fb_drift_min___0;
  }
  {
#line 425
  while (1) {
    while_continue: /* CIL Label */ ;
#line 425
    if (! (i <= fb_drift_max___0)) {
#line 425
      goto while_break;
    }
#line 426
    secs = 1 << i;
#line 428
    if ((fb_drifts + (i - fb_drift_min___0))->secs < (double )secs) {
#line 429
      goto __Cont;
    }
#line 431
    if (unsynchronised < (double )secs) {
#line 431
      if (i > next_fb_drift) {
#line 432
        goto while_break;
      }
    }
#line 434
    c = i;
    __Cont: /* CIL Label */ 
#line 425
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 437
  if (c > next_fb_drift) {
    {
#line 438
    LCL_SetAbsoluteFrequency((fb_drifts + (c - fb_drift_min___0))->freq);
#line 439
    next_fb_drift = c;
    }
  }
#line 445
  if (i <= fb_drift_max___0) {
    {
#line 446
    next_fb_drift = i;
#line 447
    UTI_AddDoubleToTimeval(now, (double )secs - unsynchronised, & when);
#line 448
    fb_drift_timeout_id = SCH_AddTimeout(& when, & fb_drift_timeout, (void *)0);
    }
  }
#line 453
  return;
}
}
#line 460 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c"
static void maybe_log_offset(double offset , time_t now ) 
{ 
  double abs_offset ;
  FILE *p ;
  char buffer___0[255] ;
  char host[255] ;
  struct tm stm ;
  int tmp ;
  struct tm *tmp___0 ;

  {
  {
#line 468
  abs_offset = fabs(offset);
  }
#line 470
  if (do_log_change___0) {
#line 470
    if (abs_offset > log_change_threshold___0) {
      {
#line 472
      LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c",
                   472, "maybe_log_offset");
#line 472
      LOG_Line_Function((LOG_Severity )1, (LOG_Facility )0, "System clock wrong by %.6f seconds, adjustment started",
                        - offset);
      }
    }
  }
#line 477
  if (do_mail_change) {
#line 477
    if (abs_offset > mail_change_threshold___0) {
      {
#line 479
      snprintf((char */* __restrict  */)(buffer___0), sizeof(buffer___0), (char const   */* __restrict  */)"%s %.128s",
               "/usr/lib/sendmail", mail_change_user);
#line 480
      p = popen((char const   *)(buffer___0), "w");
      }
#line 481
      if (p) {
        {
#line 482
        tmp = gethostname(host, sizeof(host));
        }
#line 482
        if (tmp < 0) {
          {
#line 483
          strcpy((char */* __restrict  */)(host), (char const   */* __restrict  */)"<UNKNOWN>");
          }
        }
        {
#line 485
        fprintf((FILE */* __restrict  */)p, (char const   */* __restrict  */)"Subject: chronyd reports change to system clock on node [%s]\n",
                host);
#line 486
        fputs((char const   */* __restrict  */)"\n", (FILE */* __restrict  */)p);
#line 487
        tmp___0 = localtime((time_t const   *)(& now));
#line 487
        stm = *tmp___0;
#line 488
        strftime((char */* __restrict  */)(buffer___0), sizeof(buffer___0), (char const   */* __restrict  */)"On %A, %d %B %Y\n  with the system clock reading %H:%M:%S (%Z)",
                 (struct tm  const  */* __restrict  */)(& stm));
#line 489
        fputs((char const   */* __restrict  */)(buffer___0), (FILE */* __restrict  */)p);
#line 493
        fprintf((FILE */* __restrict  */)p, (char const   */* __restrict  */)"\n\nchronyd started to apply an adjustment of %.3f seconds to it,\n  which exceeded the reporting threshold of %.3f seconds\n\n",
                - offset, mail_change_threshold___0);
#line 497
        pclose(p);
        }
      } else {
        {
#line 499
        LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c",
                     499, "maybe_log_offset");
#line 499
        LOG_Line_Function((LOG_Severity )2, (LOG_Facility )0, "Could not send mail notification to user %s\n",
                          mail_change_user);
        }
      }
    }
  }
#line 505
  return;
}
}
#line 509 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c"
static void maybe_make_step(void) 
{ 


  {
#line 512
  if (make_step_limit___0 == 0) {
#line 513
    return;
  } else
#line 514
  if (make_step_limit___0 > 0) {
#line 515
    make_step_limit___0 --;
  }
  {
#line 517
  LCL_MakeStep(make_step_threshold___0);
  }
#line 518
  return;
}
}
#line 522 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c"
static int is_offset_ok(double offset ) 
{ 
  char const   *tmp ;

  {
#line 525
  if (max_offset_delay___0 < 0) {
#line 526
    return (1);
  }
#line 528
  if (max_offset_delay___0 > 0) {
#line 529
    max_offset_delay___0 --;
#line 530
    return (1);
  }
  {
#line 533
  offset = fabs(offset);
  }
#line 534
  if (offset > max_offset___0) {
    {
#line 535
    LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c",
                 535, "is_offset_ok");
    }
#line 535
    if (! max_offset_ignore___0) {
#line 535
      tmp = "exiting";
    } else {
#line 535
      tmp = "ignored";
    }
    {
#line 535
    LOG_Line_Function((LOG_Severity )1, (LOG_Facility )0, "Adjustment of %.3f seconds exceeds the allowed maximum of %.3f seconds (%s) ",
                      offset, max_offset___0, tmp);
    }
#line 538
    if (! max_offset_ignore___0) {
      {
#line 539
      SCH_QuitProgram();
      }
    } else
#line 540
    if (max_offset_ignore___0 > 0) {
#line 541
      max_offset_ignore___0 --;
    }
#line 542
    return (0);
  }
#line 544
  return (1);
}
}
#line 549 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c"
static NTP_Leap get_tz_leap(time_t when ) 
{ 
  struct tm stm ;
  time_t t ;
  char *tz_env ;
  char tz_orig[128] ;
  struct tm *tmp ;
  size_t tmp___0 ;

  {
#line 557
  when = (when / 43200L) * 43200L;
#line 558
  if (last_tz_leap_check == when) {
#line 559
    return (tz_leap);
  }
  {
#line 561
  last_tz_leap_check = when;
#line 562
  tz_leap = (NTP_Leap )0;
#line 564
  tmp = gmtime((time_t const   *)(& when));
#line 564
  stm = *tmp;
  }
#line 567
  if (stm.tm_mon == 5) {
#line 567
    if (stm.tm_mday > 14) {
#line 568
      stm.tm_mday = 30;
    } else {
#line 567
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 569
  if (stm.tm_mon == 11) {
#line 569
    if (stm.tm_mday > 14) {
#line 570
      stm.tm_mday = 31;
    } else {
#line 572
      return (tz_leap);
    }
  } else {
#line 572
    return (tz_leap);
  }
  {
#line 575
  tz_env = getenv("TZ");
  }
#line 576
  if (tz_env) {
    {
#line 577
    tmp___0 = strlen((char const   *)tz_env);
    }
#line 577
    if (tmp___0 >= sizeof(tz_orig)) {
#line 578
      return (tz_leap);
    }
    {
#line 579
    strcpy((char */* __restrict  */)(tz_orig), (char const   */* __restrict  */)tz_env);
    }
  }
  {
#line 581
  setenv("TZ", (char const   *)leap_tzname, 1);
#line 582
  tzset();
#line 585
  stm.tm_sec = 60;
#line 586
  stm.tm_min = 59;
#line 587
  stm.tm_hour = 23;
#line 589
  t = mktime(& stm);
  }
#line 591
  if (tz_env) {
    {
#line 592
    setenv("TZ", (char const   *)(tz_orig), 1);
    }
  } else {
    {
#line 594
    unsetenv("TZ");
    }
  }
  {
#line 595
  tzset();
  }
#line 597
  if (t == -1L) {
#line 598
    return (tz_leap);
  }
#line 600
  if (stm.tm_sec == 60) {
#line 601
    tz_leap = (NTP_Leap )1;
  } else
#line 602
  if (stm.tm_sec == 1) {
#line 603
    tz_leap = (NTP_Leap )2;
  }
#line 605
  return (tz_leap);
}
}
#line 610 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c"
static void update_leap_status(NTP_Leap leap , time_t now ) 
{ 
  struct tm stm ;
  int leap_sec ;
  struct tm *tmp ;

  {
#line 616
  leap_sec = 0;
#line 618
  if (leap_tzname) {
#line 618
    if (now) {
#line 618
      if ((unsigned int )leap == 0U) {
        {
#line 619
        leap = get_tz_leap(now);
        }
      }
    }
  }
#line 621
  if ((unsigned int )leap == 1U) {
#line 621
    goto _L___2;
  } else
#line 621
  if ((unsigned int )leap == 2U) {
    _L___2: /* CIL Label */ 
    {
#line 625
    tmp = gmtime((time_t const   *)(& now));
#line 625
    stm = *tmp;
    }
#line 627
    if (stm.tm_mon != 5) {
#line 627
      if (stm.tm_mon != 11) {
#line 628
        leap = (NTP_Leap )0;
      } else {
#line 627
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 629
    if (stm.tm_mon == 5) {
#line 629
      if (stm.tm_mday == 30) {
#line 629
        goto _L;
      } else {
#line 629
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 629
    if (stm.tm_mon == 11) {
#line 629
      if (stm.tm_mday == 31) {
        _L: /* CIL Label */ 
#line 631
        if ((unsigned int )leap == 1U) {
#line 632
          leap_sec = 1;
        } else {
#line 634
          leap_sec = -1;
        }
      }
    }
  }
#line 639
  if (leap_sec != our_leap_sec) {
    {
#line 640
    LCL_SetLeap(leap_sec);
#line 641
    our_leap_sec = leap_sec;
    }
  }
#line 644
  our_leap_status = leap;
#line 645
  return;
}
}
#line 649 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c"
static void write_log(struct timeval *ref_time , char *ref , int stratum , NTP_Leap leap ,
                      double freq , double skew , double offset , int combined_sources ,
                      double offset_sd , double uncorrected_offset ) 
{ 
  char leap_codes[4] ;
  char *tmp ;

  {
#line 654
  leap_codes[0] = (char )'N';
#line 654
  leap_codes[1] = (char )'+';
#line 654
  leap_codes[2] = (char )'-';
#line 654
  leap_codes[3] = (char )'?';
#line 655
  if (logfileid___4 != -1) {
    {
#line 656
    tmp = UTI_TimeToLogForm(ref_time->tv_sec);
#line 656
    LOG_FileWrite(logfileid___4, "%s %-15s %2d %10.3f %10.3f %10.3e %1c %2d %10.3e %10.3e",
                  tmp, ref, stratum, freq, skew, offset, (int )leap_codes[leap], combined_sources,
                  offset_sd, uncorrected_offset);
    }
  }
#line 661
  return;
}
}
#line 665 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c"
void REF_SetReference(int stratum , NTP_Leap leap , int combined_sources , uint32_t ref_id ,
                      IPAddr *ref_ip , struct timeval *ref_time , double offset ,
                      double offset_sd , double frequency , double skew , double root_delay ,
                      double root_dispersion ) 
{ 
  double previous_skew ;
  double new_skew ;
  double previous_freq ;
  double new_freq ;
  double old_weight ;
  double new_weight ;
  double sum_weight ;
  double delta_freq1 ;
  double delta_freq2 ;
  double skew1 ;
  double skew2 ;
  double our_offset ;
  double our_frequency ;
  double abs_freq_ppm ;
  double update_interval___0 ;
  double elapsed ;
  double correction_rate___0 ;
  double uncorrected_offset ;
  struct timeval now ;
  struct timeval raw_now ;
  struct timeval ev_now ;
  struct timeval ev_raw_now ;
  double t ;
  int tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
#line 694
  if (! initialised___5) {
    {
#line 694
    __assert_fail("initialised", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c",
                  694U, "REF_SetReference");
    }
  }
#line 697
  if (skew < 1.0e-12) {
#line 698
    skew = 1.0e-12;
  }
#line 711
  t = (skew + skew) / skew;
#line 712
  if (t < 1.9) {
    {
#line 713
    LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c",
                 713, "REF_SetReference");
#line 713
    LOG_Line_Function((LOG_Severity )1, (LOG_Facility )0, "Bogus skew value encountered");
    }
#line 714
    return;
  } else
#line 712
  if (t > 2.1) {
    {
#line 713
    LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c",
                 713, "REF_SetReference");
#line 713
    LOG_Line_Function((LOG_Severity )1, (LOG_Facility )0, "Bogus skew value encountered");
    }
#line 714
    return;
  }
  {
#line 718
  LCL_ReadRawTime(& raw_now);
#line 721
  SCH_GetLastEventTime(& ev_now, (double *)((void *)0), & ev_raw_now);
#line 722
  UTI_DiffTimevalsToDouble(& uncorrected_offset, & ev_now, & ev_raw_now);
#line 723
  UTI_AddDoubleToTimeval(& raw_now, uncorrected_offset, & now);
#line 725
  UTI_DiffTimevalsToDouble(& elapsed, & now, ref_time);
#line 726
  our_offset = offset + elapsed * frequency;
#line 728
  tmp = is_offset_ok(our_offset);
  }
#line 728
  if (! tmp) {
#line 729
    return;
  }
#line 731
  if ((unsigned int )leap != 3U) {
#line 731
    are_we_synchronised = 1;
  } else {
#line 731
    are_we_synchronised = 0;
  }
#line 732
  our_stratum = stratum + 1;
#line 733
  our_ref_id = ref_id;
#line 734
  if (ref_ip) {
#line 735
    our_ref_ip = *ref_ip;
  } else {
#line 737
    our_ref_ip.family = (uint16_t )0;
  }
#line 738
  our_ref_time = *ref_time;
#line 739
  our_root_delay = root_delay;
#line 740
  our_root_dispersion = root_dispersion;
#line 742
  if (last_ref_update.tv_sec) {
    {
#line 743
    UTI_DiffTimevalsToDouble(& update_interval___0, & now, & last_ref_update);
    }
#line 744
    if (update_interval___0 < 0.0) {
#line 745
      update_interval___0 = 0.0;
    }
  } else {
#line 747
    update_interval___0 = 0.0;
  }
  {
#line 749
  last_ref_update = now;
#line 764
  correction_rate___0 = ((correction_time_ratio___0 * 0.5) * offset_sd) * update_interval___0;
#line 769
  tmp___4 = fabs(skew);
  }
#line 769
  if (tmp___4 < max_update_skew___0) {
#line 769
    goto _L;
  } else
#line 769
  if ((unsigned int )leap == 3U) {
    _L: /* CIL Label */ 
#line 771
    previous_skew = our_skew;
#line 772
    new_skew = skew;
#line 774
    previous_freq = 0.0;
#line 779
    new_freq = frequency;
#line 784
    if ((unsigned int )leap != 3U) {
      {
#line 784
      tmp___0 = Sqr(previous_skew);
#line 784
      old_weight = 1.0 / tmp___0;
      }
    } else {
#line 784
      old_weight = 0.0;
    }
    {
#line 785
    tmp___1 = Sqr(new_skew);
#line 785
    new_weight = 3.0 / tmp___1;
#line 787
    sum_weight = old_weight + new_weight;
#line 789
    our_frequency = (previous_freq * old_weight + new_freq * new_weight) / sum_weight;
#line 791
    delta_freq1 = previous_freq - our_frequency;
#line 792
    delta_freq2 = new_freq - our_frequency;
#line 794
    tmp___2 = Sqr(delta_freq1);
#line 794
    tmp___3 = Sqr(delta_freq2);
#line 794
    skew1 = sqrt((tmp___2 * old_weight + tmp___3 * new_weight) / sum_weight);
#line 795
    skew2 = (previous_skew * old_weight + new_skew * new_weight) / sum_weight;
#line 796
    our_skew = skew1 + skew2;
#line 798
    our_residual_freq = new_freq - our_frequency;
#line 800
    LCL_AccumulateFrequencyAndOffset(our_frequency, our_offset, correction_rate___0);
    }
  } else {
    {
#line 807
    LCL_AccumulateOffset(our_offset, correction_rate___0);
#line 809
    our_residual_freq = frequency;
    }
  }
  {
#line 812
  update_leap_status(leap, raw_now.tv_sec);
#line 813
  maybe_log_offset(our_offset, raw_now.tv_sec);
#line 814
  maybe_make_step();
#line 816
  abs_freq_ppm = LCL_ReadAbsoluteFrequency();
  }
#line 818
  if ((int )our_ref_ip.family != 0) {
    {
#line 818
    tmp___5 = UTI_IPToString(& our_ref_ip);
#line 818
    tmp___7 = tmp___5;
    }
  } else {
    {
#line 818
    tmp___6 = UTI_RefidToString(our_ref_id);
#line 818
    tmp___7 = tmp___6;
    }
  }
  {
#line 818
  write_log(& now, tmp___7, our_stratum, our_leap_status, abs_freq_ppm, 1.0e6 * our_skew,
            our_offset, combined_sources, offset_sd, uncorrected_offset);
  }
#line 829
  if (drift_file___0) {
#line 831
    drift_file_age += update_interval___0;
#line 832
    if (drift_file_age < 0.0) {
      {
#line 833
      update_drift_file(abs_freq_ppm, our_skew);
#line 834
      drift_file_age = 0.0;
      }
    } else
#line 832
    if (drift_file_age > 3600.0) {
      {
#line 833
      update_drift_file(abs_freq_ppm, our_skew);
#line 834
      drift_file_age = 0.0;
      }
    }
  }
#line 839
  if (fb_drifts) {
    {
#line 840
    update_fb_drifts(abs_freq_ppm, update_interval___0);
    }
  }
#line 843
  last_ref_update_interval = update_interval___0;
#line 844
  last_offset = our_offset;
#line 847
  if (avg2_moving) {
#line 848
    avg2_offset += 0.1 * (our_offset * our_offset - avg2_offset);
  } else {
#line 850
    if (avg2_offset > 0.0) {
#line 850
      if (avg2_offset < our_offset * our_offset) {
#line 851
        avg2_moving = 1;
      }
    }
#line 852
    avg2_offset = our_offset * our_offset;
  }
#line 854
  return;
}
}
#line 858 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c"
void REF_SetManualReference(struct timeval *ref_time , double offset , double frequency ,
                            double skew ) 
{ 
  uint32_t manual_refid ;

  {
  {
#line 867
  manual_refid = (uint32_t )1296125525;
#line 872
  REF_SetReference(0, (NTP_Leap )3, 1, manual_refid, (IPAddr *)((void *)0), ref_time,
                   offset, 0.0, frequency, skew, 0.0, 0.0);
  }
#line 874
  return;
}
}
#line 878 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c"
void REF_SetUnsynchronised(void) 
{ 
  struct timeval now ;
  struct timeval now_raw ;
  double uncorrected_offset ;
  double tmp ;

  {
#line 885
  if (! initialised___5) {
    {
#line 885
    __assert_fail("initialised", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c",
                  885U, "REF_SetUnsynchronised");
    }
  }
  {
#line 888
  SCH_GetLastEventTime(& now, (double *)((void *)0), & now_raw);
#line 889
  UTI_DiffTimevalsToDouble(& uncorrected_offset, & now, & now_raw);
  }
#line 891
  if (fb_drifts) {
    {
#line 892
    schedule_fb_drift(& now);
    }
  }
  {
#line 895
  update_leap_status((NTP_Leap )3, (time_t )0);
#line 896
  are_we_synchronised = 0;
#line 898
  tmp = LCL_ReadAbsoluteFrequency();
#line 898
  write_log(& now, (char *)"0.0.0.0", 0, our_leap_status, tmp, 1.0e6 * our_skew, 0.0,
            0, 0.0, uncorrected_offset);
  }
#line 908
  return;
}
}
#line 912 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c"
void REF_GetReferenceParams(struct timeval *local_time , int *is_synchronised , NTP_Leap *leap_status ,
                            int *stratum , uint32_t *ref_id , struct timeval *ref_time ,
                            double *root_delay , double *root_dispersion ) 
{ 
  double elapsed ;
  double extra_dispersion ;
  double tmp ;
  double tmp___0 ;
  __suseconds_t tmp___1 ;

  {
#line 928
  if (! initialised___5) {
    {
#line 928
    __assert_fail("initialised", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c",
                  928U, "REF_GetReferenceParams");
    }
  }
#line 930
  if (are_we_synchronised) {
    {
#line 932
    *is_synchronised = 1;
#line 934
    *stratum = our_stratum;
#line 936
    UTI_DiffTimevalsToDouble(& elapsed, local_time, & our_ref_time);
#line 937
    tmp = fabs(our_residual_freq);
#line 937
    tmp___0 = LCL_GetMaxClockError();
#line 937
    extra_dispersion = ((our_skew + tmp) + tmp___0) * elapsed;
#line 939
    *leap_status = our_leap_status;
#line 940
    *ref_id = our_ref_id;
#line 941
    *ref_time = our_ref_time;
#line 942
    *root_delay = our_root_delay;
#line 943
    *root_dispersion = our_root_dispersion + extra_dispersion;
    }
  } else
#line 945
  if (enable_local_stratum) {
    {
#line 947
    *is_synchronised = 1;
#line 949
    *stratum = local_stratum___0;
#line 950
    *ref_id = (uint32_t )2139029761UL;
#line 956
    *ref_time = *local_time;
#line 957
    (ref_time->tv_sec) --;
#line 961
    *leap_status = (NTP_Leap )0;
#line 963
    *root_delay = 0.0;
#line 964
    *root_dispersion = LCL_GetSysPrecisionAsQuantum();
    }
  } else {
#line 968
    *is_synchronised = 0;
#line 970
    *leap_status = (NTP_Leap )3;
#line 971
    *stratum = 0;
#line 972
    *ref_id = (uint32_t )0;
#line 973
    tmp___1 = (__suseconds_t )0;
#line 973
    ref_time->tv_usec = tmp___1;
#line 973
    ref_time->tv_sec = tmp___1;
#line 977
    *root_dispersion = 1.0;
#line 978
    *root_delay = 1.0;
  }
#line 981
  return;
}
}
#line 985 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c"
int REF_GetOurStratum(void) 
{ 


  {
#line 988
  if (are_we_synchronised) {
#line 989
    return (our_stratum);
  } else
#line 990
  if (enable_local_stratum) {
#line 991
    return (local_stratum___0);
  } else {
#line 993
    return (16);
  }
}
}
#line 999 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c"
void REF_ModifyMaxupdateskew(double new_max_update_skew ) 
{ 


  {
#line 1002
  max_update_skew___0 = new_max_update_skew * 1.0e-6;
#line 1006
  return;
}
}
#line 1010 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c"
void REF_EnableLocal(int stratum ) 
{ 


  {
#line 1013
  enable_local_stratum = 1;
#line 1014
  local_stratum___0 = stratum;
#line 1015
  return;
}
}
#line 1019 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c"
void REF_DisableLocal(void) 
{ 


  {
#line 1022
  enable_local_stratum = 0;
#line 1023
  return;
}
}
#line 1027 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c"
int REF_IsLocalActive(void) 
{ 
  int tmp ;

  {
#line 1030
  if (! are_we_synchronised) {
#line 1030
    if (enable_local_stratum) {
#line 1030
      tmp = 1;
    } else {
#line 1030
      tmp = 0;
    }
  } else {
#line 1030
    tmp = 0;
  }
#line 1030
  return (tmp);
}
}
#line 1035 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/reference.c"
void REF_GetTrackingReport(RPT_TrackingReport *rep ) 
{ 
  double elapsed ;
  double extra_dispersion ;
  struct timeval now_raw ;
  struct timeval now_cooked ;
  double correction ;
  double tmp ;
  double tmp___0 ;

  {
  {
#line 1043
  LCL_ReadRawTime(& now_raw);
#line 1044
  LCL_GetOffsetCorrection(& now_raw, & correction, (double *)((void *)0));
#line 1045
  UTI_AddDoubleToTimeval(& now_raw, correction, & now_cooked);
#line 1047
  rep->ref_id = (uint32_t )0;
#line 1048
  rep->ip_addr.family = (uint16_t )0;
#line 1049
  rep->stratum = 0UL;
#line 1050
  rep->leap_status = (unsigned long )our_leap_status;
#line 1051
  rep->ref_time.tv_sec = (__time_t )0;
#line 1052
  rep->ref_time.tv_usec = (__suseconds_t )0;
#line 1053
  rep->current_correction = correction;
#line 1054
  rep->freq_ppm = LCL_ReadAbsoluteFrequency();
#line 1055
  rep->resid_freq_ppm = 0.0;
#line 1056
  rep->skew_ppm = 0.0;
#line 1057
  rep->root_delay = 0.0;
#line 1058
  rep->root_dispersion = 0.0;
#line 1059
  rep->last_update_interval = last_ref_update_interval;
#line 1060
  rep->last_offset = last_offset;
#line 1061
  rep->rms_offset = sqrt(avg2_offset);
  }
#line 1063
  if (are_we_synchronised) {
    {
#line 1065
    UTI_DiffTimevalsToDouble(& elapsed, & now_cooked, & our_ref_time);
#line 1066
    tmp = fabs(our_residual_freq);
#line 1066
    tmp___0 = LCL_GetMaxClockError();
#line 1066
    extra_dispersion = ((our_skew + tmp) + tmp___0) * elapsed;
#line 1068
    rep->ref_id = our_ref_id;
#line 1069
    rep->ip_addr = our_ref_ip;
#line 1070
    rep->stratum = (unsigned long )our_stratum;
#line 1071
    rep->ref_time = our_ref_time;
#line 1072
    rep->resid_freq_ppm = 1.0e6 * our_residual_freq;
#line 1073
    rep->skew_ppm = 1.0e6 * our_skew;
#line 1074
    rep->root_delay = our_root_delay;
#line 1075
    rep->root_dispersion = our_root_dispersion + extra_dispersion;
    }
  } else
#line 1077
  if (enable_local_stratum) {
    {
#line 1079
    rep->ref_id = (uint32_t )2139029761UL;
#line 1080
    rep->ip_addr.family = (uint16_t )0;
#line 1081
    rep->stratum = (unsigned long )local_stratum___0;
#line 1082
    rep->ref_time = now_cooked;
#line 1083
    rep->root_dispersion = LCL_GetSysPrecisionAsQuantum();
    }
  }
#line 1086
  return;
}
}
#line 156 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern ssize_t recv(int __fd , void *__buf , size_t __n , int __flags ) ;
#line 48 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/refclock_sock.c"
static void read_sample(void *anything ) 
{ 
  struct sock_sample sample ;
  RCL_Instance instance ;
  int sockfd ;
  int s ;
  void *tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 54
  instance = (RCL_Instance )anything;
#line 55
  tmp = RCL_GetDriverData(instance);
#line 55
  sockfd = (int )((long )tmp);
#line 57
  tmp___0 = recv(sockfd, (void *)(& sample), sizeof(sample), 0);
#line 57
  s = (int )tmp___0;
  }
#line 59
  if (s < 0) {
#line 63
    return;
  }
#line 66
  if ((unsigned long )s != sizeof(sample)) {
#line 70
    return;
  }
#line 73
  if (sample.magic != 1397703499) {
#line 77
    return;
  }
#line 80
  if (sample.pulse) {
    {
#line 81
    RCL_AddPulse(instance, & sample.tv, sample.offset);
    }
  } else {
    {
#line 83
    RCL_AddSample(instance, & sample.tv, sample.offset, sample.leap);
    }
  }
#line 85
  return;
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/refclock_sock.c"
static int sock_initialise(RCL_Instance instance ) 
{ 
  struct sockaddr_un s ;
  int sockfd ;
  char *path ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 93
  path = RCL_GetDriverParameter(instance);
#line 95
  s.sun_family = (sa_family_t )1;
#line 96
  tmp = snprintf((char */* __restrict  */)(s.sun_path), sizeof(s.sun_path), (char const   */* __restrict  */)"%s",
                 path);
  }
#line 96
  if ((unsigned long )tmp >= sizeof(s.sun_path)) {
    {
#line 97
    LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/refclock_sock.c",
                 97, "sock_initialise");
#line 97
    LOG_Fatal_Function((LOG_Facility )26, "path %s is too long", path);
    }
#line 98
    return (0);
  }
  {
#line 101
  sockfd = socket(1, 2, 0);
  }
#line 102
  if (sockfd < 0) {
    {
#line 103
    LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/refclock_sock.c",
                 103, "sock_initialise");
#line 103
    LOG_Fatal_Function((LOG_Facility )26, "socket() failed");
    }
#line 104
    return (0);
  }
  {
#line 107
  UTI_FdSetCloexec(sockfd);
#line 109
  unlink((char const   *)path);
#line 110
  tmp___0 = bind(sockfd, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& s)),
                 (socklen_t )sizeof(s));
  }
#line 110
  if (tmp___0 < 0) {
    {
#line 111
    LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/refclock_sock.c",
                 111, "sock_initialise");
#line 111
    LOG_Fatal_Function((LOG_Facility )26, "bind() failed");
    }
#line 112
    return (0);
  }
  {
#line 115
  RCL_SetDriverData(instance, (void *)((long )sockfd));
#line 116
  SCH_AddInputFileHandler(sockfd, & read_sample, (SCH_ArbitraryArgument )instance);
  }
#line 117
  return (1);
}
}
#line 120 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/refclock_sock.c"
static void sock_finalise(RCL_Instance instance ) 
{ 
  int sockfd ;
  void *tmp ;

  {
  {
#line 124
  tmp = RCL_GetDriverData(instance);
#line 124
  sockfd = (int )((long )tmp);
#line 125
  SCH_RemoveInputFileHandler(sockfd);
#line 126
  close(sockfd);
  }
#line 127
  return;
}
}
#line 129 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/refclock_sock.c"
RefclockDriver RCL_SOCK_driver  =    {& sock_initialise, & sock_finalise, (int (*)(RCL_Instance instance ))((void *)0)};
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 109 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) log)(double __x ) ;
#line 153
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) pow)(double __x ,
                                                                             double __y ) ;
#line 58 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) inet_pton)(int __af ,
                                                                                char const   * __restrict  __cp ,
                                                                                void * __restrict  __buf ) ;
#line 64
extern  __attribute__((__nothrow__)) char const   *( __attribute__((__leaf__)) inet_ntop)(int __af ,
                                                                                          void const   * __restrict  __cp ,
                                                                                          char * __restrict  __buf ,
                                                                                          socklen_t __len ) ;
#line 38 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/util.h"
void UTI_TimevalToDouble(struct timeval *a , double *b ) ;
#line 42
void UTI_DoubleToTimeval(double a , struct timeval *b ) ;
#line 67
void UTI_AddDiffToTimeval(struct timeval *a , struct timeval *b , struct timeval *c ,
                          struct timeval *result ) ;
#line 71
char *UTI_TimevalToString(struct timeval *tv ) ;
#line 75
char *UTI_TimestampToString(NTP_int64 *ts ) ;
#line 37 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/util.c"
void UTI_TimevalToDouble(struct timeval *a , double *b ) 
{ 


  {
#line 40
  *b = (double )a->tv_sec + 1.0e-6 * (double )a->tv_usec;
#line 42
  return;
}
}
#line 46 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/util.c"
void UTI_DoubleToTimeval(double a , struct timeval *b ) 
{ 
  long int_part ;
  long frac_part ;

  {
  {
#line 50
  int_part = (long )a;
#line 51
  frac_part = (long )(0.5 + 1.0e6 * (a - (double )int_part));
#line 52
  b->tv_sec = int_part;
#line 53
  b->tv_usec = frac_part;
#line 54
  UTI_NormaliseTimeval(b);
  }
#line 55
  return;
}
}
#line 59 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/util.c"
int UTI_CompareTimevals(struct timeval *a , struct timeval *b ) 
{ 


  {
#line 62
  if (a->tv_sec < b->tv_sec) {
#line 63
    return (-1);
  } else
#line 64
  if (a->tv_sec > b->tv_sec) {
#line 65
    return (1);
  } else
#line 67
  if (a->tv_usec < b->tv_usec) {
#line 68
    return (-1);
  } else
#line 69
  if (a->tv_usec > b->tv_usec) {
#line 70
    return (1);
  } else {
#line 72
    return (0);
  }
}
}
#line 79 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/util.c"
void UTI_NormaliseTimeval(struct timeval *x ) 
{ 


  {
#line 83
  if (x->tv_usec >= 1000000L) {
#line 84
    x->tv_sec += x->tv_usec / 1000000L;
#line 85
    x->tv_usec %= 1000000L;
  } else
#line 83
  if (x->tv_usec <= -1000000L) {
#line 84
    x->tv_sec += x->tv_usec / 1000000L;
#line 85
    x->tv_usec %= 1000000L;
  }
#line 89
  if (x->tv_usec < 0L) {
#line 90
    (x->tv_sec) --;
#line 91
    x->tv_usec += 1000000L;
  }
#line 94
  return;
}
}
#line 98 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/util.c"
void UTI_DiffTimevals(struct timeval *result , struct timeval *a , struct timeval *b ) 
{ 


  {
  {
#line 103
  result->tv_sec = a->tv_sec - b->tv_sec;
#line 104
  result->tv_usec = a->tv_usec - b->tv_usec;
#line 109
  UTI_NormaliseTimeval(result);
  }
#line 110
  return;
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/util.c"
void UTI_DiffTimevalsToDouble(double *result , struct timeval *a , struct timeval *b ) 
{ 


  {
#line 120
  *result = (double )(a->tv_sec - b->tv_sec) + (double )(a->tv_usec - b->tv_usec) * 1.0e-6;
#line 122
  return;
}
}
#line 126 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/util.c"
void UTI_AddDoubleToTimeval(struct timeval *start , double increment , struct timeval *end ) 
{ 
  long int_part ;
  long frac_part ;
  double tmp ;

  {
#line 137
  int_part = (long )increment;
#line 138
  increment = (increment - (double )int_part) * 1.0e6;
#line 139
  if (increment > 0.0) {
#line 139
    tmp = increment + 0.5;
  } else {
#line 139
    tmp = increment - 0.5;
  }
  {
#line 139
  frac_part = (long )tmp;
#line 141
  end->tv_sec = int_part + start->tv_sec;
#line 142
  end->tv_usec = frac_part + start->tv_usec;
#line 144
  UTI_NormaliseTimeval(end);
  }
#line 145
  return;
}
}
#line 150 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/util.c"
void UTI_AverageDiffTimevals(struct timeval *earlier , struct timeval *later , struct timeval *average ,
                             double *diff ) 
{ 
  struct timeval tvdiff ;
  struct timeval tvhalf ;

  {
  {
#line 159
  UTI_DiffTimevals(& tvdiff, later, earlier);
#line 160
  *diff = (double )tvdiff.tv_sec + 1.0e-6 * (double )tvdiff.tv_usec;
  }
#line 162
  if (*diff < 0.0) {
#line 175
    *diff = 0.0;
  }
  {
#line 178
  tvhalf.tv_sec = tvdiff.tv_sec / 2L;
#line 179
  tvhalf.tv_usec = tvdiff.tv_usec / 2L + (tvdiff.tv_sec % 2L) * 500000L;
#line 181
  average->tv_sec = earlier->tv_sec + tvhalf.tv_sec;
#line 182
  average->tv_usec = earlier->tv_usec + tvhalf.tv_usec;
#line 185
  UTI_NormaliseTimeval(average);
  }
#line 187
  return;
}
}
#line 191 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/util.c"
void UTI_AddDiffToTimeval(struct timeval *a , struct timeval *b , struct timeval *c ,
                          struct timeval *result ) 
{ 
  double diff ;

  {
  {
#line 197
  UTI_DiffTimevalsToDouble(& diff, a, b);
#line 198
  UTI_AddDoubleToTimeval(c, diff, result);
  }
#line 199
  return;
}
}
#line 205 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/util.c"
static char buffer_pool[16][64]  ;
#line 206 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/util.c"
static int pool_ptr  =    0;
#line 214 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/util.c"
char *UTI_TimevalToString(struct timeval *tv ) 
{ 
  char buffer___0[64] ;
  char *result ;
  struct tm stm ;
  struct tm *tmp ;

  {
  {
#line 219
  tmp = gmtime((time_t const   *)(& tv->tv_sec));
#line 219
  stm = *tmp;
#line 220
  strftime((char */* __restrict  */)(buffer___0), sizeof(buffer___0), (char const   */* __restrict  */)"%a %x %X",
           (struct tm  const  */* __restrict  */)(& stm));
#line 221
  pool_ptr = (pool_ptr + 1) % 16;
#line 221
  result = buffer_pool[pool_ptr];
#line 222
  snprintf((char */* __restrict  */)result, (size_t )64, (char const   */* __restrict  */)"%s.%06ld",
           buffer___0, (unsigned long )tv->tv_usec);
  }
#line 223
  return (result);
}
}
#line 230 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/util.c"
char *UTI_TimestampToString(NTP_int64 *ts ) 
{ 
  struct timeval tv ;
  char *tmp ;

  {
  {
#line 234
  UTI_Int64ToTimeval(ts, & tv);
#line 235
  tmp = UTI_TimevalToString(& tv);
  }
#line 235
  return (tmp);
}
}
#line 240 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/util.c"
char *UTI_RefidToString(uint32_t ref_id ) 
{ 
  unsigned int i ;
  unsigned int j ;
  unsigned int c ;
  char buf[5] ;
  char *result ;
  unsigned int tmp ;
  unsigned short const   **tmp___0 ;

  {
#line 246
  j = 0U;
#line 246
  i = j;
  {
#line 246
  while (1) {
    while_continue: /* CIL Label */ ;
#line 246
    if (! (i < 4U)) {
#line 246
      goto while_break;
    }
    {
#line 247
    c = (ref_id >> (24U - i * 8U)) & 255U;
#line 248
    tmp___0 = __ctype_b_loc();
    }
#line 248
    if ((int const   )*(*tmp___0 + (int )c) & 16384) {
#line 249
      tmp = j;
#line 249
      j ++;
#line 249
      buf[tmp] = (char )c;
    }
#line 246
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 252
  buf[j] = (char )'\000';
#line 254
  pool_ptr = (pool_ptr + 1) % 16;
#line 254
  result = buffer_pool[pool_ptr];
#line 255
  snprintf((char */* __restrict  */)result, (size_t )64, (char const   */* __restrict  */)"%s",
           buf);
  }
#line 256
  return (result);
}
}
#line 261 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/util.c"
char *UTI_IPToString(IPAddr *addr ) 
{ 
  unsigned long a ;
  unsigned long b ;
  unsigned long c ;
  unsigned long d ;
  unsigned long ip ;
  uint8_t *ip6 ;
  char *result ;

  {
#line 268
  pool_ptr = (pool_ptr + 1) % 16;
#line 268
  result = buffer_pool[pool_ptr];
  {
#line 270
  if ((int )addr->family == 0) {
#line 270
    goto case_0;
  }
#line 273
  if ((int )addr->family == 1) {
#line 273
    goto case_1;
  }
#line 281
  if ((int )addr->family == 2) {
#line 281
    goto case_2;
  }
#line 291
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 271
  snprintf((char */* __restrict  */)result, (size_t )64, (char const   */* __restrict  */)"[UNSPEC]");
  }
#line 272
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 274
  ip = (unsigned long )addr->addr.in4;
#line 275
  a = (ip >> 24) & 255UL;
#line 276
  b = (ip >> 16) & 255UL;
#line 277
  c = (ip >> 8) & 255UL;
#line 278
  d = ip & 255UL;
#line 279
  snprintf((char */* __restrict  */)result, (size_t )64, (char const   */* __restrict  */)"%ld.%ld.%ld.%ld",
           a, b, c, d);
  }
#line 280
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 282
  ip6 = addr->addr.in6;
#line 284
  inet_ntop(10, (void const   */* __restrict  */)ip6, (char */* __restrict  */)result,
            (socklen_t )64);
  }
#line 290
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 292
  snprintf((char */* __restrict  */)result, (size_t )64, (char const   */* __restrict  */)"[UNKNOWN]");
  }
  switch_break: /* CIL Label */ ;
  }
#line 294
  return (result);
}
}
#line 299 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/util.c"
int UTI_StringToIP(char const   *addr , IPAddr *ip ) 
{ 
  struct in_addr in4 ;
  struct in6_addr in6 ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 306
  tmp = inet_pton(2, (char const   */* __restrict  */)addr, (void */* __restrict  */)(& in4));
  }
#line 306
  if (tmp > 0) {
    {
#line 307
    ip->family = (uint16_t )1;
#line 308
    ip->addr.in4 = ntohl(in4.s_addr);
    }
#line 309
    return (1);
  }
  {
#line 312
  tmp___0 = inet_pton(10, (char const   */* __restrict  */)addr, (void */* __restrict  */)(& in6));
  }
#line 312
  if (tmp___0 > 0) {
    {
#line 313
    ip->family = (uint16_t )2;
#line 314
    memcpy((void */* __restrict  */)(ip->addr.in6), (void const   */* __restrict  */)(in6.__in6_u.__u6_addr8),
           sizeof(ip->addr.in6));
    }
#line 315
    return (1);
  }
#line 329
  return (0);
}
}
#line 337 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/util.c"
static int MD5_hash  =    -1;
#line 334 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/util.c"
uint32_t UTI_IPToRefid(IPAddr *ip ) 
{ 
  unsigned char buf[16] ;
  unsigned int tmp ;

  {
  {
#line 341
  if ((int )ip->family == 1) {
#line 341
    goto case_1;
  }
#line 343
  if ((int )ip->family == 2) {
#line 343
    goto case_2;
  }
#line 340
  goto switch_break;
  case_1: /* CIL Label */ 
#line 342
  return (ip->addr.in4);
  case_2: /* CIL Label */ 
#line 344
  if (MD5_hash < 0) {
    {
#line 345
    MD5_hash = HSH_GetHashId("MD5");
    }
#line 346
    if (! (MD5_hash >= 0)) {
      {
#line 346
      __assert_fail("MD5_hash >= 0", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/util.c",
                    346U, "UTI_IPToRefid");
      }
    }
  }
  {
#line 349
  tmp = HSH_Hash(MD5_hash, (unsigned char const   *)(ip->addr.in6), (unsigned int )sizeof(ip->addr.in6),
                 (unsigned char const   *)((void *)0), 0U, buf, 16U);
  }
#line 349
  if (tmp != 16U) {
    {
#line 351
    __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/util.c",
                  351U, "UTI_IPToRefid");
    }
#line 352
    return ((uint32_t )0);
  }
#line 354
  return ((uint32_t )(((((int )buf[0] << 24) | ((int )buf[1] << 16)) | ((int )buf[2] << 8)) | (int )buf[3]));
  switch_break: /* CIL Label */ ;
  }
#line 356
  return ((uint32_t )0);
}
}
#line 361 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/util.c"
void UTI_IPHostToNetwork(IPAddr *src , IPAddr *dest ) 
{ 


  {
  {
#line 365
  memset((void *)dest, 0, sizeof(IPAddr ));
#line 367
  dest->family = htons(src->family);
  }
  {
#line 370
  if ((int )src->family == 1) {
#line 370
    goto case_1;
  }
#line 373
  if ((int )src->family == 2) {
#line 373
    goto case_2;
  }
#line 369
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 371
  dest->addr.in4 = htonl(src->addr.in4);
  }
#line 372
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 374
  memcpy((void */* __restrict  */)(dest->addr.in6), (void const   */* __restrict  */)(src->addr.in6),
         sizeof(dest->addr.in6));
  }
#line 375
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 377
  return;
}
}
#line 381 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/util.c"
void UTI_IPNetworkToHost(IPAddr *src , IPAddr *dest ) 
{ 


  {
  {
#line 384
  dest->family = ntohs(src->family);
  }
  {
#line 387
  if ((int )dest->family == 1) {
#line 387
    goto case_1;
  }
#line 390
  if ((int )dest->family == 2) {
#line 390
    goto case_2;
  }
#line 386
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 388
  dest->addr.in4 = ntohl(src->addr.in4);
  }
#line 389
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 391
  memcpy((void */* __restrict  */)(dest->addr.in6), (void const   */* __restrict  */)(src->addr.in6),
         sizeof(dest->addr.in6));
  }
#line 392
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 394
  return;
}
}
#line 398 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/util.c"
int UTI_CompareIPs(IPAddr *a , IPAddr *b , IPAddr *mask ) 
{ 
  int i ;
  int d ;

  {
#line 403
  if ((int )a->family != (int )b->family) {
#line 404
    return ((int )a->family - (int )b->family);
  }
#line 406
  if (mask) {
#line 406
    if ((int )mask->family != (int )b->family) {
#line 407
      mask = (IPAddr *)((void *)0);
    }
  }
  {
#line 410
  if ((int )a->family == 0) {
#line 410
    goto case_0;
  }
#line 412
  if ((int )a->family == 1) {
#line 412
    goto case_1;
  }
#line 417
  if ((int )a->family == 2) {
#line 417
    goto case_2;
  }
#line 409
  goto switch_break;
  case_0: /* CIL Label */ 
#line 411
  return (0);
  case_1: /* CIL Label */ 
#line 413
  if (mask) {
#line 414
    return ((int )((a->addr.in4 & mask->addr.in4) - (b->addr.in4 & mask->addr.in4)));
  } else {
#line 416
    return ((int )(a->addr.in4 - b->addr.in4));
  }
  case_2: /* CIL Label */ 
#line 418
  i = 0;
#line 418
  d = 0;
  {
#line 418
  while (1) {
    while_continue: /* CIL Label */ ;
#line 418
    if (! d) {
#line 418
      if (! (i < 16)) {
#line 418
        goto while_break;
      }
    } else {
#line 418
      goto while_break;
    }
#line 419
    if (mask) {
#line 420
      d = ((int )a->addr.in6[i] & (int )mask->addr.in6[i]) - ((int )b->addr.in6[i] & (int )mask->addr.in6[i]);
    } else {
#line 423
      d = (int )a->addr.in6[i] - (int )b->addr.in6[i];
    }
#line 418
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 425
  return (d);
  switch_break: /* CIL Label */ ;
  }
#line 427
  return (0);
}
}
#line 432 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/util.c"
char *UTI_TimeToLogForm(time_t t ) 
{ 
  struct tm stm ;
  char *result ;
  struct tm *tmp ;

  {
  {
#line 438
  pool_ptr = (pool_ptr + 1) % 16;
#line 438
  result = buffer_pool[pool_ptr];
#line 440
  tmp = gmtime((time_t const   *)(& t));
#line 440
  stm = *tmp;
#line 441
  strftime((char */* __restrict  */)result, (size_t )64, (char const   */* __restrict  */)"%Y-%m-%d %H:%M:%S",
           (struct tm  const  */* __restrict  */)(& stm));
  }
#line 443
  return (result);
}
}
#line 448 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/util.c"
void UTI_AdjustTimeval(struct timeval *old_tv , struct timeval *when , struct timeval *new_tv ,
                       double *delta_time , double dfreq , double doffset ) 
{ 
  double elapsed ;

  {
  {
#line 453
  UTI_DiffTimevalsToDouble(& elapsed, when, old_tv);
#line 454
  *delta_time = elapsed * dfreq - doffset;
#line 455
  UTI_AddDoubleToTimeval(old_tv, *delta_time, new_tv);
  }
#line 456
  return;
}
}
#line 460 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/util.c"
uint32_t UTI_GetNTPTsFuzz(int precision ) 
{ 
  uint32_t fuzz ;
  int fuzz_bits ;
  long tmp ;

  {
  {
#line 466
  fuzz_bits = 31 + precision;
#line 467
  tmp = random();
#line 467
  fuzz = (uint32_t )(tmp % (long )(1 << fuzz_bits));
  }
#line 469
  return (fuzz);
}
}
#line 474 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/util.c"
double UTI_Int32ToDouble(NTP_int32 x ) 
{ 
  uint32_t tmp ;

  {
  {
#line 477
  tmp = ntohl(x);
  }
#line 477
  return ((double )tmp / 65536.0);
}
}
#line 484 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/util.c"
NTP_int32 UTI_DoubleToInt32(double x ) 
{ 
  uint32_t tmp ;

  {
#line 487
  if (x > 4294967295.0 / 65536.0) {
#line 488
    x = 4294967295.0 / 65536.0;
  } else
#line 489
  if (x < (double )0) {
#line 490
    x = 0.0;
  }
  {
#line 491
  tmp = htonl((NTP_int32 )(0.5 + 65536.0 * x));
  }
#line 491
  return (tmp);
}
}
#line 500 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/util.c"
void UTI_TimevalToInt64(struct timeval *src , NTP_int64 *dest , uint32_t fuzz ) 
{ 
  unsigned long usec ;
  unsigned long sec ;
  uint32_t lo ;
  uint32_t tmp ;

  {
#line 504
  usec = (unsigned long )src->tv_usec;
#line 505
  sec = (unsigned long )src->tv_sec;
#line 510
  if (! usec) {
#line 510
    if (! sec) {
#line 511
      tmp = (uint32_t )0;
#line 511
      dest->lo = tmp;
#line 511
      dest->hi = tmp;
    } else {
      {
#line 513
      dest->hi = htonl((uint32_t )((unsigned long )src->tv_sec + 2208988800UL));
#line 516
      lo = (uint32_t )((4295UL * usec - (usec >> 5)) - (usec >> 9));
#line 519
      lo ^= fuzz;
#line 521
      dest->lo = htonl(lo);
      }
    }
  } else {
    {
#line 513
    dest->hi = htonl((uint32_t )((unsigned long )src->tv_sec + 2208988800UL));
#line 516
    lo = (uint32_t )((4295UL * usec - (usec >> 5)) - (usec >> 9));
#line 519
    lo ^= fuzz;
#line 521
    dest->lo = htonl(lo);
    }
  }
#line 523
  return;
}
}
#line 527 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/util.c"
void UTI_Int64ToTimeval(NTP_int64 *src , struct timeval *dest ) 
{ 
  uint32_t tmp ;
  uint32_t tmp___0 ;

  {
  {
#line 534
  tmp = ntohl(src->hi);
#line 534
  dest->tv_sec = (__time_t )((unsigned long )tmp - 2208988800UL);
#line 537
  tmp___0 = ntohl(src->lo);
#line 537
  dest->tv_usec = (__suseconds_t )((int )(0.5 + (double )tmp___0 / 4294.967296));
  }
#line 538
  return;
}
}
#line 542 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/util.c"
void UTI_TimevalNetworkToHost(Timeval *src , struct timeval *dest ) 
{ 
  uint32_t sec_low ;
  uint32_t sec_high ;
  uint32_t tmp ;
  struct timeval now ;

  {
  {
#line 547
  tmp = ntohl(src->tv_nsec);
#line 547
  dest->tv_usec = (__suseconds_t )(tmp / 1000U);
#line 548
  sec_high = ntohl(src->tv_sec_high);
#line 549
  sec_low = ntohl(src->tv_sec_low);
  }
#line 553
  if (sizeof(time_t ) > 4UL) {
#line 553
    if (sec_high == 2147483647U) {
      {
#line 556
      gettimeofday((struct timeval */* __restrict  */)(& now), (__timezone_ptr_t )((void *)0));
#line 557
      sec_high = (uint32_t )((now.tv_sec >> 16) >> 16);
      }
    }
  }
#line 559
  dest->tv_sec = (((time_t )sec_high << 16) << 16) | (long )sec_low;
#line 560
  return;
}
}
#line 564 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/util.c"
void UTI_TimevalHostToNetwork(struct timeval *src , Timeval *dest ) 
{ 


  {
  {
#line 567
  dest->tv_nsec = htonl((uint32_t )(src->tv_usec * 1000L));
  }
#line 568
  if (sizeof(time_t ) > 4UL) {
    {
#line 569
    dest->tv_sec_high = htonl((uint32_t )((src->tv_sec >> 16) >> 16));
    }
  } else {
    {
#line 571
    dest->tv_sec_high = htonl((uint32_t )2147483647);
    }
  }
  {
#line 572
  dest->tv_sec_low = htonl((uint32_t )src->tv_sec);
  }
#line 573
  return;
}
}
#line 584 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/util.c"
double UTI_FloatNetworkToHost(Float f ) 
{ 
  int32_t exp___0 ;
  int32_t coef ;
  int32_t x ;
  uint32_t tmp ;
  double tmp___0 ;

  {
  {
#line 589
  tmp = ntohl((uint32_t )f.f);
#line 589
  x = (int32_t )tmp;
#line 590
  exp___0 = (x >> ((int )sizeof(int32_t ) * 8 - 7)) - ((int )sizeof(int32_t ) * 8 - 7);
#line 591
  coef = (x << 7) >> 7;
#line 592
  tmp___0 = pow(2.0, (double )exp___0);
  }
#line 592
  return ((double )coef * tmp___0);
}
}
#line 595 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/util.c"
Float UTI_FloatHostToNetwork(double x ) 
{ 
  int32_t exp___0 ;
  int32_t coef ;
  int32_t neg ;
  Float f ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  uint32_t tmp___2 ;

  {
#line 601
  if (x < 0.0) {
#line 602
    x = - x;
#line 603
    neg = 1;
  } else {
#line 605
    neg = 0;
  }
#line 608
  if (x < 1.0e-100) {
#line 609
    coef = 0;
#line 609
    exp___0 = coef;
  } else
#line 610
  if (x > 1.0e100) {
#line 611
    exp___0 = - (- (1 << 6)) - 1;
#line 612
    coef = (- (- (1 << (((int )sizeof(int32_t ) * 8 - 7) - 1))) - 1) + neg;
  } else {
    {
#line 614
    tmp = log(x);
#line 614
    tmp___0 = log((double )2);
#line 614
    exp___0 = (int32_t )(tmp / tmp___0 + (double )1);
#line 615
    tmp___1 = pow(2.0, (double )(- exp___0 + ((int )sizeof(int32_t ) * 8 - 7)));
#line 615
    coef = (int32_t )(x * tmp___1 + 0.5);
    }
#line 617
    if (! (coef > 0)) {
      {
#line 617
      __assert_fail("coef > 0", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/util.c",
                    617U, "UTI_FloatHostToNetwork");
      }
    }
    {
#line 620
    while (1) {
      while_continue: /* CIL Label */ ;
#line 620
      if (! (coef > (- (- (1 << (((int )sizeof(int32_t ) * 8 - 7) - 1))) - 1) + neg)) {
#line 620
        goto while_break;
      }
#line 621
      coef >>= 1;
#line 622
      exp___0 ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 625
    if (exp___0 > - (- (1 << 6)) - 1) {
#line 627
      exp___0 = - (- (1 << 6)) - 1;
#line 628
      coef = (- (- (1 << (((int )sizeof(int32_t ) * 8 - 7) - 1))) - 1) + neg;
    } else
#line 629
    if (exp___0 < - (1 << 6)) {
#line 631
      if (exp___0 + ((int )sizeof(int32_t ) * 8 - 7) >= - (1 << 6)) {
#line 632
        coef >>= - (1 << 6) - exp___0;
#line 633
        exp___0 = - (1 << 6);
      } else {
#line 635
        coef = 0;
#line 635
        exp___0 = coef;
      }
    }
  }
#line 641
  if (neg) {
#line 642
    coef = (int32_t )(((uint32_t )(- coef) << 7) >> 7);
  }
  {
#line 644
  tmp___2 = htonl((uint32_t )((exp___0 << ((int )sizeof(int32_t ) * 8 - 7)) | coef));
#line 644
  f.f = (int32_t )tmp___2;
  }
#line 645
  return (f);
}
}
#line 650 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/util.c"
void UTI_FdSetCloexec(int fd___0 ) 
{ 
  int flags ;

  {
  {
#line 655
  flags = fcntl(fd___0, 1);
  }
#line 656
  if (flags != -1) {
    {
#line 657
    flags |= 1;
#line 658
    fcntl(fd___0, 2, flags);
    }
  }
#line 660
  return;
}
}
#line 664 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/util.c"
int UTI_GenerateNTPAuth(int hash_id , unsigned char const   *key , int key_len , unsigned char const   *data ,
                        int data_len , unsigned char *auth , int auth_len ) 
{ 
  unsigned int tmp ;

  {
  {
#line 668
  tmp = HSH_Hash(hash_id, key, (unsigned int )key_len, data, (unsigned int )data_len,
                 auth, (unsigned int )auth_len);
  }
#line 668
  return ((int )tmp);
}
}
#line 673 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/util.c"
int UTI_CheckNTPAuth(int hash_id , unsigned char const   *key , int key_len , unsigned char const   *data ,
                     int data_len , unsigned char const   *auth , int auth_len ) 
{ 
  unsigned char buf[64] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 679
  tmp = UTI_GenerateNTPAuth(hash_id, key, key_len, data, data_len, buf, (int )sizeof(buf));
  }
#line 679
  if (tmp == auth_len) {
    {
#line 679
    tmp___0 = memcmp((void const   *)(buf), (void const   *)auth, (size_t )auth_len);
    }
#line 679
    if (tmp___0) {
#line 679
      tmp___1 = 0;
    } else {
#line 679
      tmp___1 = 1;
    }
  } else {
#line 679
    tmp___1 = 0;
  }
#line 679
  return (tmp___1);
}
}
#line 685 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/util.c"
int UTI_DecodePasswordFromText(char *key ) 
{ 
  int i ;
  int j ;
  int len ;
  size_t tmp ;
  char buf[3] ;
  char *p ;
  long tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 688
  tmp = strlen((char const   *)key);
#line 688
  len = (int )tmp;
#line 691
  tmp___2 = strncmp((char const   *)key, "ASCII:", (size_t )6);
  }
#line 691
  if (tmp___2) {
    {
#line 694
    tmp___1 = strncmp((char const   *)key, "HEX:", (size_t )4);
    }
#line 694
    if (tmp___1) {
#line 709
      return (len);
    } else {
#line 695
      if ((len - 4) % 2) {
#line 696
        return (0);
      }
#line 698
      i = 0;
#line 698
      j = 4;
      {
#line 698
      while (1) {
        while_continue: /* CIL Label */ ;
#line 698
        if (! (j + 1 < len)) {
#line 698
          goto while_break;
        }
        {
#line 699
        buf[0] = *(key + j);
#line 699
        buf[1] = *(key + (j + 1));
#line 699
        buf[2] = (char )'\000';
#line 700
        tmp___0 = strtol((char const   */* __restrict  */)(buf), (char **/* __restrict  */)(& p),
                         16);
#line 700
        *(key + i) = (char )tmp___0;
        }
#line 702
        if ((unsigned long )p != (unsigned long )(buf + 2)) {
#line 703
          return (0);
        }
#line 698
        i ++;
#line 698
        j += 2;
      }
      while_break: /* CIL Label */ ;
      }
#line 706
      return (i);
    }
  } else {
    {
#line 692
    memmove((void *)key, (void const   *)(key + 6), (size_t )(len - 6));
    }
#line 693
    return (len - 6);
  }
}
}
#line 272 "/usr/include/x86_64-linux-gnu/bits/socket.h"
extern  __attribute__((__nothrow__)) struct cmsghdr *( __attribute__((__leaf__)) __cmsg_nxthdr)(struct msghdr *__mhdr ,
                                                                                                struct cmsghdr *__cmsg ) ;
#line 184 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern ssize_t sendmsg(int __fd , struct msghdr  const  *__message , int __flags ) ;
#line 202
extern ssize_t recvmsg(int __fd , struct msghdr *__message , int __flags ) ;
#line 51 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_io.c"
static int sock_fd4___1  ;
#line 53 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_io.c"
static int sock_fd6___1  ;
#line 57 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_io.c"
static int initialised___6  =    0;
#line 62
static int prepare_socket___1(int family ) ;
#line 63
static void read_from_socket___0(void *anything ) ;
#line 67 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_io.c"
static void do_size_checks(void) 
{ 


  {
#line 74
  if (! (sizeof(NTP_int32 ) == 4UL)) {
    {
#line 74
    __assert_fail("sizeof(NTP_int32) == 4", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_io.c",
                  74U, "do_size_checks");
    }
  }
#line 75
  if (! (sizeof(NTP_int64 ) == 8UL)) {
    {
#line 75
    __assert_fail("sizeof(NTP_int64) == 8", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_io.c",
                  75U, "do_size_checks");
    }
  }
#line 78
  if (! ((unsigned long )(& ((NTP_Packet *)0)->lvm) == 0UL)) {
    {
#line 78
    __assert_fail("__builtin_offsetof (NTP_Packet, lvm) == 0", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_io.c",
                  78U, "do_size_checks");
    }
  }
#line 79
  if (! ((unsigned long )(& ((NTP_Packet *)0)->stratum) == 1UL)) {
    {
#line 79
    __assert_fail("__builtin_offsetof (NTP_Packet, stratum) == 1", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_io.c",
                  79U, "do_size_checks");
    }
  }
#line 80
  if (! ((unsigned long )(& ((NTP_Packet *)0)->poll) == 2UL)) {
    {
#line 80
    __assert_fail("__builtin_offsetof (NTP_Packet, poll) == 2", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_io.c",
                  80U, "do_size_checks");
    }
  }
#line 81
  if (! ((unsigned long )(& ((NTP_Packet *)0)->precision) == 3UL)) {
    {
#line 81
    __assert_fail("__builtin_offsetof (NTP_Packet, precision) == 3", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_io.c",
                  81U, "do_size_checks");
    }
  }
#line 82
  if (! ((unsigned long )(& ((NTP_Packet *)0)->root_delay) == 4UL)) {
    {
#line 82
    __assert_fail("__builtin_offsetof (NTP_Packet, root_delay) == 4", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_io.c",
                  82U, "do_size_checks");
    }
  }
#line 83
  if (! ((unsigned long )(& ((NTP_Packet *)0)->root_dispersion) == 8UL)) {
    {
#line 83
    __assert_fail("__builtin_offsetof (NTP_Packet, root_dispersion) == 8", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_io.c",
                  83U, "do_size_checks");
    }
  }
#line 84
  if (! ((unsigned long )(& ((NTP_Packet *)0)->reference_id) == 12UL)) {
    {
#line 84
    __assert_fail("__builtin_offsetof (NTP_Packet, reference_id) == 12", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_io.c",
                  84U, "do_size_checks");
    }
  }
#line 85
  if (! ((unsigned long )(& ((NTP_Packet *)0)->reference_ts) == 16UL)) {
    {
#line 85
    __assert_fail("__builtin_offsetof (NTP_Packet, reference_ts) == 16", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_io.c",
                  85U, "do_size_checks");
    }
  }
#line 86
  if (! ((unsigned long )(& ((NTP_Packet *)0)->originate_ts) == 24UL)) {
    {
#line 86
    __assert_fail("__builtin_offsetof (NTP_Packet, originate_ts) == 24", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_io.c",
                  86U, "do_size_checks");
    }
  }
#line 87
  if (! ((unsigned long )(& ((NTP_Packet *)0)->receive_ts) == 32UL)) {
    {
#line 87
    __assert_fail("__builtin_offsetof (NTP_Packet, receive_ts) == 32", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_io.c",
                  87U, "do_size_checks");
    }
  }
#line 88
  if (! ((unsigned long )(& ((NTP_Packet *)0)->transmit_ts) == 40UL)) {
    {
#line 88
    __assert_fail("__builtin_offsetof (NTP_Packet, transmit_ts) == 40", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_io.c",
                  88U, "do_size_checks");
    }
  }
#line 90
  return;
}
}
#line 94 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_io.c"
static int prepare_socket___1(int family ) 
{ 
  union sockaddr_in46 my_addr ;
  socklen_t my_addr_len ;
  int sock_fd___0 ;
  unsigned short port_number ;
  IPAddr bind_address ;
  int on_off ;
  int *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  char const   *tmp___10 ;
  int tmp___11 ;

  {
  {
#line 102
  on_off = 1;
#line 104
  port_number = CNF_GetNTPPort();
#line 111
  sock_fd___0 = socket(family, 2, 0);
  }
#line 114
  if (sock_fd___0 < 0) {
    {
#line 115
    LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_io.c",
                 115, "prepare_socket");
#line 115
    tmp = __errno_location();
#line 115
    tmp___0 = strerror(*tmp);
    }
#line 115
    if (family == 2) {
#line 115
      tmp___1 = "IPv4";
    } else {
#line 115
      tmp___1 = "IPv6";
    }
    {
#line 115
    LOG_Line_Function((LOG_Severity )2, (LOG_Facility )1, "Could not open %s NTP socket : %s",
                      tmp___1, tmp___0);
    }
#line 117
    return (-1);
  }
  {
#line 121
  UTI_FdSetCloexec(sock_fd___0);
#line 124
  tmp___2 = setsockopt(sock_fd___0, 1, 2, (void const   *)((char *)(& on_off)), (socklen_t )sizeof(on_off));
  }
#line 124
  if (tmp___2 < 0) {
    {
#line 125
    LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_io.c",
                 125, "prepare_socket");
#line 125
    LOG_Line_Function((LOG_Severity )2, (LOG_Facility )1, "Could not set reuseaddr socket options");
    }
  }
  {
#line 130
  tmp___3 = setsockopt(sock_fd___0, 1, 6, (void const   *)((char *)(& on_off)), (socklen_t )sizeof(on_off));
  }
#line 130
  if (tmp___3 < 0) {
    {
#line 131
    LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_io.c",
                 131, "prepare_socket");
#line 131
    LOG_Line_Function((LOG_Severity )2, (LOG_Facility )1, "Could not set broadcast socket options");
    }
  }
  {
#line 137
  tmp___4 = setsockopt(sock_fd___0, 1, 29, (void const   *)((char *)(& on_off)), (socklen_t )sizeof(on_off));
  }
#line 137
  if (tmp___4 < 0) {
    {
#line 138
    LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_io.c",
                 138, "prepare_socket");
#line 138
    LOG_Line_Function((LOG_Severity )2, (LOG_Facility )1, "Could not set timestamp socket options");
    }
  }
#line 143
  if (family == 2) {
    {
#line 146
    tmp___5 = setsockopt(sock_fd___0, 0, 8, (void const   *)((char *)(& on_off)),
                         (socklen_t )sizeof(on_off));
    }
#line 146
    if (tmp___5 < 0) {
      {
#line 147
      LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_io.c",
                   147, "prepare_socket");
#line 147
      LOG_Line_Function((LOG_Severity )2, (LOG_Facility )1, "Could not request packet info using socket option");
      }
    }
  } else
#line 153
  if (family == 10) {
    {
#line 156
    tmp___6 = setsockopt(sock_fd___0, 41, 26, (void const   *)((char *)(& on_off)),
                         (socklen_t )sizeof(on_off));
    }
#line 156
    if (tmp___6 < 0) {
      {
#line 157
      LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_io.c",
                   157, "prepare_socket");
#line 157
      LOG_Line_Function((LOG_Severity )2, (LOG_Facility )1, "Could not request IPV6_V6ONLY socket option");
      }
    }
    {
#line 162
    tmp___7 = setsockopt(sock_fd___0, 41, 49, (void const   *)((char *)(& on_off)),
                         (socklen_t )sizeof(on_off));
    }
#line 162
    if (tmp___7 < 0) {
      {
#line 163
      LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_io.c",
                   163, "prepare_socket");
#line 163
      LOG_Line_Function((LOG_Severity )2, (LOG_Facility )1, "Could not request IPv6 packet info socket option");
      }
    }
  }
  {
#line 174
  memset((void *)(& my_addr), 0, sizeof(my_addr));
  }
  {
#line 177
  if (family == 2) {
#line 177
    goto case_2;
  }
#line 190
  if (family == 10) {
#line 190
    goto case_10;
  }
#line 204
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 178
  my_addr_len = (socklen_t )sizeof(my_addr.in4);
#line 179
  my_addr.in4.sin_family = (sa_family_t )family;
#line 180
  my_addr.in4.sin_port = htons(port_number);
#line 182
  CNF_GetBindAddress(1, & bind_address);
  }
#line 184
  if ((int )bind_address.family == 1) {
    {
#line 185
    my_addr.in4.sin_addr.s_addr = htonl(bind_address.addr.in4);
    }
  } else {
    {
#line 187
    my_addr.in4.sin_addr.s_addr = htonl((in_addr_t )0);
    }
  }
#line 188
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 191
  my_addr_len = (socklen_t )sizeof(my_addr.in6);
#line 192
  my_addr.in6.sin6_family = (sa_family_t )family;
#line 193
  my_addr.in6.sin6_port = htons(port_number);
#line 195
  CNF_GetBindAddress(2, & bind_address);
  }
#line 197
  if ((int )bind_address.family == 2) {
    {
#line 198
    memcpy((void */* __restrict  */)(my_addr.in6.sin6_addr.__in6_u.__u6_addr8), (void const   */* __restrict  */)(bind_address.addr.in6),
           sizeof(my_addr.in6.sin6_addr.__in6_u.__u6_addr8));
    }
  } else {
#line 201
    my_addr.in6.sin6_addr = (struct in6_addr )in6addr_any;
  }
#line 202
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 205
  __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_io.c",
                205U, "prepare_socket");
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 212
  tmp___11 = bind(sock_fd___0, (struct sockaddr  const  */* __restrict  */)(& my_addr.u),
                  my_addr_len);
  }
#line 212
  if (tmp___11 < 0) {
    {
#line 213
    LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_io.c",
                 213, "prepare_socket");
#line 213
    tmp___8 = __errno_location();
#line 213
    tmp___9 = strerror(*tmp___8);
    }
#line 213
    if (family == 2) {
#line 213
      tmp___10 = "IPv4";
    } else {
#line 213
      tmp___10 = "IPv6";
    }
    {
#line 213
    LOG_Line_Function((LOG_Severity )2, (LOG_Facility )1, "Could not bind %s NTP socket : %s",
                      tmp___10, tmp___9);
#line 215
    close(sock_fd___0);
    }
#line 216
    return (-1);
  }
  {
#line 220
  SCH_AddInputFileHandler(sock_fd___0, & read_from_socket___0, (void *)((long )sock_fd___0));
  }
#line 231
  return (sock_fd___0);
}
}
#line 236 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_io.c"
void NIO_Initialise(int family ) 
{ 


  {
#line 239
  if (! (! initialised___6)) {
    {
#line 239
    __assert_fail("!initialised", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_io.c",
                  239U, "NIO_Initialise");
    }
  }
  {
#line 240
  initialised___6 = 1;
#line 242
  do_size_checks();
  }
#line 244
  if (family == 0) {
    {
#line 245
    sock_fd4___1 = prepare_socket___1(2);
    }
  } else
#line 244
  if (family == 1) {
    {
#line 245
    sock_fd4___1 = prepare_socket___1(2);
    }
  } else {
#line 247
    sock_fd4___1 = -1;
  }
#line 249
  if (family == 0) {
    {
#line 250
    sock_fd6___1 = prepare_socket___1(10);
    }
  } else
#line 249
  if (family == 2) {
    {
#line 250
    sock_fd6___1 = prepare_socket___1(10);
    }
  } else {
#line 252
    sock_fd6___1 = -1;
  }
#line 255
  if (sock_fd4___1 < 0) {
#line 255
    if (sock_fd6___1 < 0) {
      {
#line 260
      LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_io.c",
                   260, "NIO_Initialise");
#line 260
      LOG_Fatal_Function((LOG_Facility )1, "Could not open any NTP socket");
      }
    }
  }
#line 262
  return;
}
}
#line 266 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_io.c"
void NIO_Finalise(void) 
{ 


  {
#line 269
  if (sock_fd4___1 >= 0) {
    {
#line 270
    SCH_RemoveInputFileHandler(sock_fd4___1);
#line 271
    close(sock_fd4___1);
    }
  }
#line 273
  sock_fd4___1 = -1;
#line 275
  if (sock_fd6___1 >= 0) {
    {
#line 276
    SCH_RemoveInputFileHandler(sock_fd6___1);
#line 277
    close(sock_fd6___1);
    }
  }
#line 279
  sock_fd6___1 = -1;
#line 281
  initialised___6 = 0;
#line 282
  return;
}
}
#line 289 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_io.c"
static void read_from_socket___0(void *anything ) 
{ 
  int status___0 ;
  int sock_fd___0 ;
  ReceiveBuffer message ;
  union sockaddr_in46 where_from ;
  unsigned int flags ;
  struct timeval now ;
  struct timeval now_raw ;
  double now_err ;
  NTP_Remote_Address remote_addr ;
  char cmsgbuf[256] ;
  struct msghdr msg ;
  struct iovec iov ;
  struct cmsghdr *cmsg ;
  ssize_t tmp ;
  struct in_pktinfo ipi ;
  struct in6_pktinfo ipi___0 ;
  struct timeval tv ;

  {
#line 298
  flags = 0U;
#line 307
  if (! initialised___6) {
    {
#line 307
    __assert_fail("initialised", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_io.c",
                  307U, "read_from_socket");
    }
  }
  {
#line 309
  SCH_GetLastEventTime(& now, & now_err, & now_raw);
#line 311
  iov.iov_base = (void *)(message.arbitrary);
#line 312
  iov.iov_len = sizeof(message);
#line 313
  msg.msg_name = (void *)(& where_from);
#line 314
  msg.msg_namelen = (socklen_t )sizeof(where_from);
#line 315
  msg.msg_iov = & iov;
#line 316
  msg.msg_iovlen = (size_t )1;
#line 317
  msg.msg_control = (void *)(cmsgbuf);
#line 318
  msg.msg_controllen = sizeof(cmsgbuf);
#line 319
  msg.msg_flags = 0;
#line 321
  sock_fd___0 = (int )((long )anything);
#line 322
  tmp = recvmsg(sock_fd___0, & msg, (int )flags);
#line 322
  status___0 = (int )tmp;
  }
#line 331
  if (status___0 > 0) {
    {
#line 332
    memset((void *)(& remote_addr), 0, sizeof(remote_addr));
    }
    {
#line 335
    if ((int )where_from.u.sa_family == 2) {
#line 335
      goto case_2;
    }
#line 341
    if ((int )where_from.u.sa_family == 10) {
#line 341
      goto case_10;
    }
#line 348
    goto switch_default;
    case_2: /* CIL Label */ 
    {
#line 336
    remote_addr.ip_addr.family = (uint16_t )1;
#line 337
    remote_addr.ip_addr.addr.in4 = ntohl(where_from.in4.sin_addr.s_addr);
#line 338
    remote_addr.port = ntohs(where_from.in4.sin_port);
    }
#line 339
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 342
    remote_addr.ip_addr.family = (uint16_t )2;
#line 343
    memcpy((void */* __restrict  */)(& remote_addr.ip_addr.addr.in6), (void const   */* __restrict  */)(where_from.in6.sin6_addr.__in6_u.__u6_addr8),
           sizeof(remote_addr.ip_addr.addr.in6));
#line 345
    remote_addr.port = ntohs(where_from.in6.sin6_port);
    }
#line 346
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 349
    __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_io.c",
                  349U, "read_from_socket");
    }
    switch_break: /* CIL Label */ ;
    }
#line 352
    if (msg.msg_controllen >= sizeof(struct cmsghdr )) {
#line 352
      cmsg = (struct cmsghdr *)msg.msg_control;
    } else {
#line 352
      cmsg = (struct cmsghdr *)0;
    }
    {
#line 352
    while (1) {
      while_continue: /* CIL Label */ ;
#line 352
      if (! cmsg) {
#line 352
        goto while_break;
      }
#line 354
      if (cmsg->cmsg_level == 0) {
#line 354
        if (cmsg->cmsg_type == 8) {
          {
#line 357
          memcpy((void */* __restrict  */)(& ipi), (void const   */* __restrict  */)(cmsg->__cmsg_data),
                 sizeof(ipi));
#line 358
          remote_addr.local_ip_addr.addr.in4 = ntohl(ipi.ipi_spec_dst.s_addr);
#line 359
          remote_addr.local_ip_addr.family = (uint16_t )1;
          }
        }
      }
#line 364
      if (cmsg->cmsg_level == 41) {
#line 364
        if (cmsg->cmsg_type == 50) {
          {
#line 367
          memcpy((void */* __restrict  */)(& ipi___0), (void const   */* __restrict  */)(cmsg->__cmsg_data),
                 sizeof(ipi___0));
#line 368
          memcpy((void */* __restrict  */)(& remote_addr.local_ip_addr.addr.in6),
                 (void const   */* __restrict  */)(& ipi___0.ipi6_addr.__in6_u.__u6_addr8),
                 sizeof(remote_addr.local_ip_addr.addr.in6));
#line 370
          remote_addr.local_ip_addr.family = (uint16_t )2;
          }
        }
      }
#line 375
      if (cmsg->cmsg_level == 1) {
#line 375
        if (cmsg->cmsg_type == 29) {
          {
#line 378
          memcpy((void */* __restrict  */)(& tv), (void const   */* __restrict  */)(cmsg->__cmsg_data),
                 sizeof(tv));
#line 381
          UTI_AddDiffToTimeval(& now, & now_raw, & tv, & now);
          }
        }
      }
      {
#line 352
      cmsg = __cmsg_nxthdr(& msg, cmsg);
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 386
    if ((unsigned long )status___0 >= (unsigned long )(& ((NTP_Packet *)0)->auth_keyid)) {
#line 386
      if ((unsigned long )status___0 <= sizeof(NTP_Packet )) {
        {
#line 388
        NSR_ProcessReceive(& message.ntp_pkt, & now, now_err, & remote_addr, status___0);
        }
      }
    }
  }
#line 396
  return;
}
}
#line 401 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_io.c"
static void send_packet(void *packet , int packetlen , NTP_Remote_Address *remote_addr ) 
{ 
  union sockaddr_in46 remote ;
  struct msghdr msg ;
  struct iovec iov ;
  char cmsgbuf[256] ;
  int cmsglen ;
  int sock_fd___0 ;
  socklen_t addrlen ;
  struct cmsghdr *cmsg ;
  struct in_pktinfo *ipi ;
  struct cmsghdr *cmsg___0 ;
  struct in6_pktinfo *ipi___0 ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  ssize_t tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;

  {
#line 412
  if (! initialised___6) {
    {
#line 412
    __assert_fail("initialised", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_io.c",
                  412U, "send_packet");
    }
  }
  {
#line 415
  if ((int )remote_addr->ip_addr.family == 1) {
#line 415
    goto case_1;
  }
#line 424
  if ((int )remote_addr->ip_addr.family == 2) {
#line 424
    goto case_2;
  }
#line 434
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 416
  memset((void *)(& remote.in4), 0, sizeof(remote.in4));
#line 417
  addrlen = (socklen_t )sizeof(remote.in4);
#line 418
  remote.in4.sin_family = (sa_family_t )2;
#line 419
  remote.in4.sin_port = htons(remote_addr->port);
#line 420
  remote.in4.sin_addr.s_addr = htonl(remote_addr->ip_addr.addr.in4);
#line 421
  sock_fd___0 = sock_fd4___1;
  }
#line 422
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 425
  memset((void *)(& remote.in6), 0, sizeof(remote.in6));
#line 426
  addrlen = (socklen_t )sizeof(remote.in6);
#line 427
  remote.in6.sin6_family = (sa_family_t )10;
#line 428
  remote.in6.sin6_port = htons(remote_addr->port);
#line 429
  memcpy((void */* __restrict  */)(& remote.in6.sin6_addr.__in6_u.__u6_addr8), (void const   */* __restrict  */)(& remote_addr->ip_addr.addr.in6),
         sizeof(remote.in6.sin6_addr.__in6_u.__u6_addr8));
#line 431
  sock_fd___0 = sock_fd6___1;
  }
#line 432
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 435
  return;
  switch_break: /* CIL Label */ ;
  }
#line 438
  if (sock_fd___0 < 0) {
#line 439
    return;
  }
#line 441
  iov.iov_base = packet;
#line 442
  iov.iov_len = (size_t )packetlen;
#line 443
  msg.msg_name = (void *)(& remote.u);
#line 444
  msg.msg_namelen = addrlen;
#line 445
  msg.msg_iov = & iov;
#line 446
  msg.msg_iovlen = (size_t )1;
#line 447
  msg.msg_control = (void *)(cmsgbuf);
#line 448
  msg.msg_controllen = sizeof(cmsgbuf);
#line 449
  msg.msg_flags = 0;
#line 450
  cmsglen = 0;
#line 453
  if ((int )remote_addr->local_ip_addr.family == 1) {
#line 457
    if (msg.msg_controllen >= sizeof(struct cmsghdr )) {
#line 457
      cmsg = (struct cmsghdr *)msg.msg_control;
    } else {
#line 457
      cmsg = (struct cmsghdr *)0;
    }
    {
#line 458
    memset((void *)cmsg, 0, (((sizeof(struct in_pktinfo ) + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL)) + (((sizeof(struct cmsghdr ) + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL)));
#line 459
    cmsglen = (int )((unsigned long )cmsglen + ((((sizeof(struct in_pktinfo ) + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL)) + (((sizeof(struct cmsghdr ) + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL))));
#line 461
    cmsg->cmsg_level = 0;
#line 462
    cmsg->cmsg_type = 8;
#line 463
    cmsg->cmsg_len = (((sizeof(struct cmsghdr ) + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL)) + sizeof(struct in_pktinfo );
#line 465
    ipi = (struct in_pktinfo *)(cmsg->__cmsg_data);
#line 466
    ipi->ipi_spec_dst.s_addr = htonl(remote_addr->local_ip_addr.addr.in4);
    }
  }
#line 471
  if ((int )remote_addr->local_ip_addr.family == 2) {
#line 475
    if (msg.msg_controllen >= sizeof(struct cmsghdr )) {
#line 475
      cmsg___0 = (struct cmsghdr *)msg.msg_control;
    } else {
#line 475
      cmsg___0 = (struct cmsghdr *)0;
    }
    {
#line 476
    memset((void *)cmsg___0, 0, (((sizeof(struct in6_pktinfo ) + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL)) + (((sizeof(struct cmsghdr ) + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL)));
#line 477
    cmsglen = (int )((unsigned long )cmsglen + ((((sizeof(struct in6_pktinfo ) + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL)) + (((sizeof(struct cmsghdr ) + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL))));
#line 479
    cmsg___0->cmsg_level = 41;
#line 480
    cmsg___0->cmsg_type = 50;
#line 481
    cmsg___0->cmsg_len = (((sizeof(struct cmsghdr ) + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL)) + sizeof(struct in6_pktinfo );
#line 483
    ipi___0 = (struct in6_pktinfo *)(cmsg___0->__cmsg_data);
#line 484
    memcpy((void */* __restrict  */)(& ipi___0->ipi6_addr.__in6_u.__u6_addr8), (void const   */* __restrict  */)(& remote_addr->local_ip_addr.addr.in6),
           sizeof(ipi___0->ipi6_addr.__in6_u.__u6_addr8));
    }
  }
#line 494
  msg.msg_controllen = (size_t )cmsglen;
#line 496
  if (! cmsglen) {
#line 497
    msg.msg_control = (void *)0;
  }
  {
#line 499
  tmp___2 = sendmsg(sock_fd___0, (struct msghdr  const  *)(& msg), 0);
  }
#line 499
  if (tmp___2 < 0L) {
    {
#line 499
    tmp___3 = __errno_location();
    }
#line 499
    if (*tmp___3 != 101) {
      {
#line 499
      tmp___4 = __errno_location();
      }
#line 499
      if (*tmp___4 != 100) {
        {
#line 499
        tmp___5 = LOG_RateLimited();
        }
#line 499
        if (! tmp___5) {
          {
#line 507
          LOG_Position("/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_io.c",
                       507, "send_packet");
#line 507
          tmp = __errno_location();
#line 507
          tmp___0 = strerror(*tmp);
#line 507
          tmp___1 = UTI_IPToString(& remote_addr->ip_addr);
#line 507
          LOG_Line_Function((LOG_Severity )1, (LOG_Facility )1, "Could not send to %s:%d : %s",
                            tmp___1, (int )remote_addr->port, tmp___0);
          }
        }
      }
    }
  }
#line 510
  return;
}
}
#line 515 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_io.c"
void NIO_SendNormalPacket(NTP_Packet *packet , NTP_Remote_Address *remote_addr ) 
{ 


  {
  {
#line 518
  send_packet((void *)packet, (int )((unsigned long )(& ((NTP_Packet *)0)->auth_keyid)),
              remote_addr);
  }
#line 519
  return;
}
}
#line 524 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_io.c"
void NIO_SendAuthenticatedPacket(NTP_Packet *packet , NTP_Remote_Address *remote_addr ,
                                 int auth_len ) 
{ 


  {
  {
#line 527
  send_packet((void *)packet, (int )((unsigned long )(& ((NTP_Packet *)0)->auth_keyid) + (unsigned long )auth_len),
              remote_addr);
  }
#line 528
  return;
}
}
#line 535 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/ntp_io.c"
void NIO_SendEcho(NTP_Remote_Address *remote_addr ) 
{ 
  unsigned long magic_message ;
  NTP_Remote_Address addr ;

  {
  {
#line 538
  magic_message = 3195711975UL;
#line 541
  addr = *remote_addr;
#line 542
  addr.port = (unsigned short)7;
#line 544
  send_packet((void *)(& magic_message), (int )sizeof(unsigned long ), & addr);
  }
#line 545
  return;
}
}
#line 170 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/refclock_pps.c"
RefclockDriver RCL_PPS_driver  =    {(int (*)(RCL_Instance instance ))((void *)0), (void (*)(RCL_Instance instance ))((void *)0),
    (int (*)(RCL_Instance instance ))((void *)0)};
/* compiler builtin: 
   void *__builtin_memcpy(void * , void const   * , unsigned long  ) ;  */
#line 124 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 122 "getdate.y"
static int gd_lex(void) ;
#line 123
static int gd_error(char *s  __attribute__((__unused__)) ) ;
#line 154 "getdate.y"
static char const   *yyInput  ;
#line 155 "getdate.y"
static int yyDayOrdinal  ;
#line 156 "getdate.y"
static int yyDayNumber  ;
#line 157 "getdate.y"
static int yyHaveDate  ;
#line 158 "getdate.y"
static int yyHaveDay  ;
#line 159 "getdate.y"
static int yyHaveRel  ;
#line 160 "getdate.y"
static int yyHaveTime  ;
#line 161 "getdate.y"
static int yyHaveZone  ;
#line 162 "getdate.y"
static int yyTimezone  ;
#line 163 "getdate.y"
static int yyDay  ;
#line 164 "getdate.y"
static int yyHour  ;
#line 165 "getdate.y"
static int yyMinutes  ;
#line 166 "getdate.y"
static int yyMonth  ;
#line 167 "getdate.y"
static int yySeconds  ;
#line 168 "getdate.y"
static int yyYear  ;
#line 169 "getdate.y"
static MERIDIAN yyMeridian  ;
#line 170 "getdate.y"
static int yyRelDay  ;
#line 171 "getdate.y"
static int yyRelHour  ;
#line 172 "getdate.y"
static int yyRelMinutes  ;
#line 173 "getdate.y"
static int yyRelMonth  ;
#line 174 "getdate.y"
static int yyRelSeconds  ;
#line 175 "getdate.y"
static int yyRelYear  ;
#line 558 "getdate.c"
static yytype_uint8 const   yytranslate[274]  = 
#line 558 "getdate.c"
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )20,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )21, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )19,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )6,      (yytype_uint8 const   )7,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )9,      (yytype_uint8 const   )10,      (yytype_uint8 const   )11,      (yytype_uint8 const   )12, 
        (yytype_uint8 const   )13,      (yytype_uint8 const   )14,      (yytype_uint8 const   )15,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )17,      (yytype_uint8 const   )18};
#line 661 "getdate.c"
static yytype_uint8 const   gd_r1[52]  = 
#line 661
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )22,      (yytype_uint8 const   )23,      (yytype_uint8 const   )23, 
        (yytype_uint8 const   )24,      (yytype_uint8 const   )24,      (yytype_uint8 const   )24,      (yytype_uint8 const   )24, 
        (yytype_uint8 const   )24,      (yytype_uint8 const   )24,      (yytype_uint8 const   )25,      (yytype_uint8 const   )25, 
        (yytype_uint8 const   )25,      (yytype_uint8 const   )25,      (yytype_uint8 const   )25,      (yytype_uint8 const   )26, 
        (yytype_uint8 const   )26,      (yytype_uint8 const   )26,      (yytype_uint8 const   )27,      (yytype_uint8 const   )27, 
        (yytype_uint8 const   )27,      (yytype_uint8 const   )28,      (yytype_uint8 const   )28,      (yytype_uint8 const   )28, 
        (yytype_uint8 const   )28,      (yytype_uint8 const   )28,      (yytype_uint8 const   )28,      (yytype_uint8 const   )28, 
        (yytype_uint8 const   )28,      (yytype_uint8 const   )29,      (yytype_uint8 const   )29,      (yytype_uint8 const   )30, 
        (yytype_uint8 const   )30,      (yytype_uint8 const   )30,      (yytype_uint8 const   )30,      (yytype_uint8 const   )30, 
        (yytype_uint8 const   )30,      (yytype_uint8 const   )30,      (yytype_uint8 const   )30,      (yytype_uint8 const   )30, 
        (yytype_uint8 const   )30,      (yytype_uint8 const   )30,      (yytype_uint8 const   )30,      (yytype_uint8 const   )30, 
        (yytype_uint8 const   )30,      (yytype_uint8 const   )30,      (yytype_uint8 const   )30,      (yytype_uint8 const   )30, 
        (yytype_uint8 const   )30,      (yytype_uint8 const   )31,      (yytype_uint8 const   )32,      (yytype_uint8 const   )32};
#line 672 "getdate.c"
static yytype_uint8 const   gd_r2[52]  = 
#line 672
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )0,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )6,      (yytype_uint8 const   )6,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )5,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )2,      (yytype_uint8 const   )4,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )0,      (yytype_uint8 const   )1};
#line 685 "getdate.c"
static yytype_uint8 const   yydefact[61]  = 
#line 685
  {      (yytype_uint8 const   )2,      (yytype_uint8 const   )0,      (yytype_uint8 const   )1,      (yytype_uint8 const   )18, 
        (yytype_uint8 const   )39,      (yytype_uint8 const   )16,      (yytype_uint8 const   )42,      (yytype_uint8 const   )45, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )36,      (yytype_uint8 const   )48,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )49,      (yytype_uint8 const   )33,      (yytype_uint8 const   )15,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )5,      (yytype_uint8 const   )7,      (yytype_uint8 const   )6, 
        (yytype_uint8 const   )8,      (yytype_uint8 const   )30,      (yytype_uint8 const   )9,      (yytype_uint8 const   )19, 
        (yytype_uint8 const   )25,      (yytype_uint8 const   )38,      (yytype_uint8 const   )41,      (yytype_uint8 const   )44, 
        (yytype_uint8 const   )35,      (yytype_uint8 const   )47,      (yytype_uint8 const   )32,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )37,      (yytype_uint8 const   )40,      (yytype_uint8 const   )10,      (yytype_uint8 const   )43, 
        (yytype_uint8 const   )27,      (yytype_uint8 const   )34,      (yytype_uint8 const   )46,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )31,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )17, 
        (yytype_uint8 const   )29,      (yytype_uint8 const   )0,      (yytype_uint8 const   )24,      (yytype_uint8 const   )28, 
        (yytype_uint8 const   )23,      (yytype_uint8 const   )50,      (yytype_uint8 const   )21,      (yytype_uint8 const   )26, 
        (yytype_uint8 const   )51,      (yytype_uint8 const   )12,      (yytype_uint8 const   )0,      (yytype_uint8 const   )11, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )50,      (yytype_uint8 const   )22,      (yytype_uint8 const   )14, 
        (yytype_uint8 const   )13};
#line 697 "getdate.c"
static yytype_int8 const   yydefgoto[11]  = 
#line 697
  {      (yytype_int8 const   )-1,      (yytype_int8 const   )1,      (yytype_int8 const   )15,      (yytype_int8 const   )16, 
        (yytype_int8 const   )17,      (yytype_int8 const   )18,      (yytype_int8 const   )19,      (yytype_int8 const   )20, 
        (yytype_int8 const   )21,      (yytype_int8 const   )22,      (yytype_int8 const   )55};
#line 706 "getdate.c"
static yytype_int8 const   gd_pact[61]  = 
#line 706
  {      (yytype_int8 const   )-20,      (yytype_int8 const   )0,      (yytype_int8 const   )-20,      (yytype_int8 const   )-19, 
        (yytype_int8 const   )-20,      (yytype_int8 const   )-20,      (yytype_int8 const   )-20,      (yytype_int8 const   )-20, 
        (yytype_int8 const   )-13,      (yytype_int8 const   )-20,      (yytype_int8 const   )-20,      (yytype_int8 const   )30, 
        (yytype_int8 const   )15,      (yytype_int8 const   )-20,      (yytype_int8 const   )14,      (yytype_int8 const   )-20, 
        (yytype_int8 const   )-20,      (yytype_int8 const   )-20,      (yytype_int8 const   )-20,      (yytype_int8 const   )-20, 
        (yytype_int8 const   )-20,      (yytype_int8 const   )19,      (yytype_int8 const   )-20,      (yytype_int8 const   )-20, 
        (yytype_int8 const   )4,      (yytype_int8 const   )-20,      (yytype_int8 const   )-20,      (yytype_int8 const   )-20, 
        (yytype_int8 const   )-20,      (yytype_int8 const   )-20,      (yytype_int8 const   )-20,      (yytype_int8 const   )-20, 
        (yytype_int8 const   )-20,      (yytype_int8 const   )-20,      (yytype_int8 const   )-20,      (yytype_int8 const   )-20, 
        (yytype_int8 const   )-6,      (yytype_int8 const   )-20,      (yytype_int8 const   )-20,      (yytype_int8 const   )16, 
        (yytype_int8 const   )-20,      (yytype_int8 const   )17,      (yytype_int8 const   )23,      (yytype_int8 const   )-20, 
        (yytype_int8 const   )-20,      (yytype_int8 const   )24,      (yytype_int8 const   )-20,      (yytype_int8 const   )-20, 
        (yytype_int8 const   )-20,      (yytype_int8 const   )27,      (yytype_int8 const   )28,      (yytype_int8 const   )-20, 
        (yytype_int8 const   )-20,      (yytype_int8 const   )-20,      (yytype_int8 const   )29,      (yytype_int8 const   )-20, 
        (yytype_int8 const   )32,      (yytype_int8 const   )-8,      (yytype_int8 const   )-20,      (yytype_int8 const   )-20, 
        (yytype_int8 const   )-20};
#line 718 "getdate.c"
static yytype_int8 const   yypgoto[11]  = 
#line 718
  {      (yytype_int8 const   )-20,      (yytype_int8 const   )-20,      (yytype_int8 const   )-20,      (yytype_int8 const   )-20, 
        (yytype_int8 const   )-20,      (yytype_int8 const   )-20,      (yytype_int8 const   )-20,      (yytype_int8 const   )-20, 
        (yytype_int8 const   )-20,      (yytype_int8 const   )-20,      (yytype_int8 const   )-7};
#line 729 "getdate.c"
static yytype_uint8 const   gd_yytable[51]  = 
#line 729
  {      (yytype_uint8 const   )2,      (yytype_uint8 const   )23,      (yytype_uint8 const   )52,      (yytype_uint8 const   )24, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )4,      (yytype_uint8 const   )5,      (yytype_uint8 const   )59, 
        (yytype_uint8 const   )6,      (yytype_uint8 const   )46,      (yytype_uint8 const   )47,      (yytype_uint8 const   )7, 
        (yytype_uint8 const   )8,      (yytype_uint8 const   )9,      (yytype_uint8 const   )10,      (yytype_uint8 const   )11, 
        (yytype_uint8 const   )12,      (yytype_uint8 const   )13,      (yytype_uint8 const   )14,      (yytype_uint8 const   )31, 
        (yytype_uint8 const   )32,      (yytype_uint8 const   )43,      (yytype_uint8 const   )44,      (yytype_uint8 const   )33, 
        (yytype_uint8 const   )45,      (yytype_uint8 const   )34,      (yytype_uint8 const   )35,      (yytype_uint8 const   )36, 
        (yytype_uint8 const   )37,      (yytype_uint8 const   )38,      (yytype_uint8 const   )39,      (yytype_uint8 const   )48, 
        (yytype_uint8 const   )40,      (yytype_uint8 const   )49,      (yytype_uint8 const   )41,      (yytype_uint8 const   )25, 
        (yytype_uint8 const   )42,      (yytype_uint8 const   )52,      (yytype_uint8 const   )26,      (yytype_uint8 const   )50, 
        (yytype_uint8 const   )51,      (yytype_uint8 const   )27,      (yytype_uint8 const   )53,      (yytype_uint8 const   )28, 
        (yytype_uint8 const   )29,      (yytype_uint8 const   )57,      (yytype_uint8 const   )54,      (yytype_uint8 const   )30, 
        (yytype_uint8 const   )58,      (yytype_uint8 const   )56,      (yytype_uint8 const   )60};
#line 739 "getdate.c"
static yytype_uint8 const   gd_yycheck[51]  = 
#line 739
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )20,      (yytype_uint8 const   )10,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )5,      (yytype_uint8 const   )6,      (yytype_uint8 const   )15, 
        (yytype_uint8 const   )8,      (yytype_uint8 const   )15,      (yytype_uint8 const   )16,      (yytype_uint8 const   )11, 
        (yytype_uint8 const   )12,      (yytype_uint8 const   )13,      (yytype_uint8 const   )14,      (yytype_uint8 const   )15, 
        (yytype_uint8 const   )16,      (yytype_uint8 const   )17,      (yytype_uint8 const   )18,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )7,      (yytype_uint8 const   )3,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )20,      (yytype_uint8 const   )10,      (yytype_uint8 const   )11,      (yytype_uint8 const   )12, 
        (yytype_uint8 const   )13,      (yytype_uint8 const   )14,      (yytype_uint8 const   )15,      (yytype_uint8 const   )15, 
        (yytype_uint8 const   )17,      (yytype_uint8 const   )16,      (yytype_uint8 const   )19,      (yytype_uint8 const   )5, 
        (yytype_uint8 const   )21,      (yytype_uint8 const   )10,      (yytype_uint8 const   )8,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )16,      (yytype_uint8 const   )11,      (yytype_uint8 const   )15,      (yytype_uint8 const   )13, 
        (yytype_uint8 const   )14,      (yytype_uint8 const   )16,      (yytype_uint8 const   )19,      (yytype_uint8 const   )17, 
        (yytype_uint8 const   )16,      (yytype_uint8 const   )21,      (yytype_uint8 const   )57};
#line 751 "getdate.c"
static yytype_uint8 const   yystos[61]  = 
#line 751
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )23,      (yytype_uint8 const   )0,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )6,      (yytype_uint8 const   )8,      (yytype_uint8 const   )11, 
        (yytype_uint8 const   )12,      (yytype_uint8 const   )13,      (yytype_uint8 const   )14,      (yytype_uint8 const   )15, 
        (yytype_uint8 const   )16,      (yytype_uint8 const   )17,      (yytype_uint8 const   )18,      (yytype_uint8 const   )24, 
        (yytype_uint8 const   )25,      (yytype_uint8 const   )26,      (yytype_uint8 const   )27,      (yytype_uint8 const   )28, 
        (yytype_uint8 const   )29,      (yytype_uint8 const   )30,      (yytype_uint8 const   )31,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )16,      (yytype_uint8 const   )5,      (yytype_uint8 const   )8,      (yytype_uint8 const   )11, 
        (yytype_uint8 const   )13,      (yytype_uint8 const   )14,      (yytype_uint8 const   )17,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )8,      (yytype_uint8 const   )10,      (yytype_uint8 const   )11, 
        (yytype_uint8 const   )12,      (yytype_uint8 const   )13,      (yytype_uint8 const   )14,      (yytype_uint8 const   )15, 
        (yytype_uint8 const   )17,      (yytype_uint8 const   )19,      (yytype_uint8 const   )21,      (yytype_uint8 const   )7, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )20,      (yytype_uint8 const   )15,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )15,      (yytype_uint8 const   )16,      (yytype_uint8 const   )16,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )10,      (yytype_uint8 const   )15,      (yytype_uint8 const   )19,      (yytype_uint8 const   )32, 
        (yytype_uint8 const   )21,      (yytype_uint8 const   )16,      (yytype_uint8 const   )16,      (yytype_uint8 const   )15, 
        (yytype_uint8 const   )32};
#line 1252 "getdate.c"
static void yydestruct(char const   *yymsg , int yytype , YYSTYPE *yyvaluep ) 
{ 


  {
#line 1264
  if (! yymsg) {
#line 1265
    yymsg = "Deleting";
  }
  {
#line 1271
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 1272
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1274
  return;
}
}
#line 1285
int gd_parse(void) ;
#line 1293 "getdate.c"
int gd_char  ;
#line 1296 "getdate.c"
YYSTYPE gd_lval  ;
#line 1299 "getdate.c"
int gd_nerrs  ;
#line 1320 "getdate.c"
int gd_parse(void) 
{ 
  int gd_state ;
  int yyerrstatus ;
  yytype_int16 yyssa[200] ;
  yytype_int16 *yyss ;
  yytype_int16 *yyssp ;
  YYSTYPE yyvsa[200] ;
  YYSTYPE *yyvs ;
  YYSTYPE *yyvsp ;
  unsigned long yystacksize ;
  int yyn ;
  int yyresult ;
  int yytoken ;
  YYSTYPE gd_val ;
  int gd_yylen ;
  unsigned long yysize ;
  yytype_int16 *yyss1 ;
  union yyalloc *yyptr ;
  void *tmp ;
  unsigned long yynewbytes ;
  unsigned long yynewbytes___0 ;

  {
#line 1373
  gd_yylen = 0;
#line 1375
  yytoken = 0;
#line 1376
  yyss = yyssa;
#line 1377
  yyvs = yyvsa;
#line 1378
  yystacksize = 200UL;
#line 1382
  gd_state = 0;
#line 1383
  yyerrstatus = 0;
#line 1384
  gd_nerrs = 0;
#line 1385
  gd_char = -2;
#line 1391
  yyssp = yyss;
#line 1392
  yyvsp = yyvs;
#line 1394
  goto yysetstate;
  yynewstate: 
#line 1402
  yyssp ++;
  yysetstate: 
#line 1405
  *yyssp = (yytype_int16 )gd_state;
#line 1407
  if ((unsigned long )((yyss + yystacksize) - 1) <= (unsigned long )yyssp) {
#line 1410
    yysize = (unsigned long )((yyssp - yyss) + 1L);
#line 1437
    if (10000UL <= yystacksize) {
#line 1438
      goto yyexhaustedlab;
    }
#line 1439
    yystacksize *= 2UL;
#line 1440
    if (10000UL < yystacksize) {
#line 1441
      yystacksize = 10000UL;
    }
    {
#line 1444
    yyss1 = yyss;
#line 1445
    tmp = malloc(yystacksize * (sizeof(yytype_int16 ) + sizeof(YYSTYPE )) + (sizeof(union yyalloc ) - 1UL));
#line 1445
    yyptr = (union yyalloc *)tmp;
    }
#line 1447
    if (! yyptr) {
#line 1448
      goto yyexhaustedlab;
    }
    {
#line 1449
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1449
      __builtin_memcpy((void *)(& yyptr->yyss_alloc), (void const   *)yyss, yysize * sizeof(*yyss));
#line 1449
      yyss = & yyptr->yyss_alloc;
#line 1449
      yynewbytes = yystacksize * sizeof(*yyss) + (sizeof(union yyalloc ) - 1UL);
#line 1449
      yyptr += yynewbytes / sizeof(*yyptr);
      }
#line 1449
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1450
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1450
      __builtin_memcpy((void *)(& yyptr->yyvs_alloc), (void const   *)yyvs, yysize * sizeof(*yyvs));
#line 1450
      yyvs = & yyptr->yyvs_alloc;
#line 1450
      yynewbytes___0 = yystacksize * sizeof(*yyvs) + (sizeof(union yyalloc ) - 1UL);
#line 1450
      yyptr += yynewbytes___0 / sizeof(*yyptr);
      }
#line 1450
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1452
    if ((unsigned long )yyss1 != (unsigned long )(yyssa)) {
      {
#line 1453
      free((void *)yyss1);
      }
    }
#line 1458
    yyssp = (yyss + yysize) - 1;
#line 1459
    yyvsp = (yyvs + yysize) - 1;
#line 1464
    if ((unsigned long )((yyss + yystacksize) - 1) <= (unsigned long )yyssp) {
#line 1465
      goto yyabortlab;
    }
  }
#line 1470
  if (gd_state == 2) {
#line 1471
    goto yyacceptlab;
  }
#line 1473
  goto yybackup;
  yybackup: 
#line 1484
  yyn = (int )gd_pact[gd_state];
#line 1485
  if (yyn == -20) {
#line 1486
    goto yydefault;
  }
#line 1491
  if (gd_char == -2) {
    {
#line 1494
    gd_char = gd_lex();
    }
  }
#line 1497
  if (gd_char <= 0) {
#line 1499
    yytoken = 0;
#line 1499
    gd_char = yytoken;
  } else
#line 1504
  if ((unsigned int )gd_char <= 273U) {
#line 1504
    yytoken = (int )yytranslate[gd_char];
  } else {
#line 1504
    yytoken = 2;
  }
#line 1510
  yyn += yytoken;
#line 1511
  if (yyn < 0) {
#line 1512
    goto yydefault;
  } else
#line 1511
  if (50 < yyn) {
#line 1512
    goto yydefault;
  } else
#line 1511
  if ((int const   )gd_yycheck[yyn] != (int const   )yytoken) {
#line 1512
    goto yydefault;
  }
#line 1513
  yyn = (int )gd_yytable[yyn];
#line 1514
  if (yyn <= 0) {
#line 1516
    if (yyn == 0) {
#line 1517
      goto yyerrlab;
    } else
#line 1516
    if (yyn == -1) {
#line 1517
      goto yyerrlab;
    }
#line 1518
    yyn = - yyn;
#line 1519
    goto yyreduce;
  }
#line 1524
  if (yyerrstatus) {
#line 1525
    yyerrstatus --;
  }
#line 1531
  gd_char = -2;
#line 1533
  gd_state = yyn;
#line 1534
  yyvsp ++;
#line 1534
  *yyvsp = gd_lval;
#line 1536
  goto yynewstate;
  yydefault: 
#line 1543
  yyn = (int )yydefact[gd_state];
#line 1544
  if (yyn == 0) {
#line 1545
    goto yyerrlab;
  }
#line 1546
  goto yyreduce;
  yyreduce: 
#line 1554
  gd_yylen = (int )gd_r2[yyn];
#line 1564
  gd_val = *(yyvsp + (1 - gd_yylen));
  {
#line 1570
  if (yyn == 4) {
#line 1570
    goto case_4;
  }
#line 207
  if (yyn == 5) {
#line 207 "getdate.y"
    goto case_5;
  }
#line 210
  if (yyn == 6) {
#line 210
    goto case_6;
  }
#line 213
  if (yyn == 7) {
#line 213
    goto case_7;
  }
#line 216
  if (yyn == 8) {
#line 216
    goto case_8;
  }
#line 219
  if (yyn == 10) {
#line 219
    goto case_10;
  }
#line 228
  if (yyn == 11) {
#line 228
    goto case_11;
  }
#line 234
  if (yyn == 12) {
#line 234
    goto case_12;
  }
#line 243
  if (yyn == 13) {
#line 243
    goto case_13;
  }
#line 249
  if (yyn == 14) {
#line 249
    goto case_14;
  }
#line 259
  if (yyn == 15) {
#line 259
    goto case_15;
  }
#line 264
  if (yyn == 16) {
#line 264
    goto case_16;
  }
#line 267
  if (yyn == 17) {
#line 267
    goto case_17;
  }
#line 271
  if (yyn == 18) {
#line 271
    goto case_18;
  }
#line 277
  if (yyn == 19) {
#line 277
    goto case_19;
  }
#line 281
  if (yyn == 20) {
#line 281
    goto case_20;
  }
#line 285
  if (yyn == 21) {
#line 285
    goto case_21;
  }
#line 291
  if (yyn == 22) {
#line 291
    goto case_22;
  }
#line 309
  if (yyn == 23) {
#line 309
    goto case_23;
  }
#line 315
  if (yyn == 24) {
#line 315
    goto case_24;
  }
#line 321
  if (yyn == 25) {
#line 321
    goto case_25;
  }
#line 325
  if (yyn == 26) {
#line 325
    goto case_26;
  }
#line 330
  if (yyn == 27) {
#line 330
    goto case_27;
  }
#line 334
  if (yyn == 28) {
#line 334
    goto case_28;
  }
#line 339
  if (yyn == 29) {
#line 339
    goto case_29;
  }
#line 349
  if (yyn == 31) {
#line 349
    goto case_31;
  }
#line 355
  if (yyn == 32) {
#line 355
    goto case_32;
  }
#line 358
  if (yyn == 33) {
#line 358
    goto case_33;
  }
#line 361
  if (yyn == 34) {
#line 361
    goto case_34;
  }
#line 364
  if (yyn == 35) {
#line 364
    goto case_35;
  }
#line 367
  if (yyn == 36) {
#line 367
    goto case_36;
  }
#line 370
  if (yyn == 37) {
#line 370
    goto case_37;
  }
#line 373
  if (yyn == 38) {
#line 373
    goto case_38;
  }
#line 376
  if (yyn == 39) {
#line 376
    goto case_39;
  }
#line 379
  if (yyn == 40) {
#line 379
    goto case_40;
  }
#line 382
  if (yyn == 41) {
#line 382
    goto case_41;
  }
#line 385
  if (yyn == 42) {
#line 385
    goto case_42;
  }
#line 388
  if (yyn == 43) {
#line 388
    goto case_43;
  }
#line 391
  if (yyn == 44) {
#line 391
    goto case_44;
  }
#line 394
  if (yyn == 45) {
#line 394
    goto case_45;
  }
#line 397
  if (yyn == 46) {
#line 397
    goto case_46;
  }
#line 400
  if (yyn == 47) {
#line 400
    goto case_47;
  }
#line 403
  if (yyn == 48) {
#line 403
    goto case_48;
  }
#line 406
  if (yyn == 49) {
#line 406
    goto case_49;
  }
#line 439
  if (yyn == 50) {
#line 439
    goto case_50;
  }
#line 445
  if (yyn == 51) {
#line 445
    goto case_51;
  }
#line 2073 "getdate.c"
  goto switch_default;
  case_4: /* CIL Label */ 
#line 203 "getdate.y"
  yyHaveTime ++;
#line 205
  goto switch_break;
  case_5: /* CIL Label */ 
#line 206
  yyHaveZone ++;
#line 208
  goto switch_break;
  case_6: /* CIL Label */ 
#line 209
  yyHaveDate ++;
#line 211
  goto switch_break;
  case_7: /* CIL Label */ 
#line 212
  yyHaveDay ++;
#line 214
  goto switch_break;
  case_8: /* CIL Label */ 
#line 215
  yyHaveRel ++;
#line 217
  goto switch_break;
  case_10: /* CIL Label */ 
#line 221
  yyHour = (yyvsp + -1)->Number;
#line 222
  yyMinutes = 0;
#line 223
  yySeconds = 0;
#line 224
  yyMeridian = (yyvsp + 0)->Meridian;
#line 226
  goto switch_break;
  case_11: /* CIL Label */ 
#line 227
  yyHour = (yyvsp + -3)->Number;
#line 228
  yyMinutes = (yyvsp + -1)->Number;
#line 229
  yySeconds = 0;
#line 230
  yyMeridian = (yyvsp + 0)->Meridian;
#line 232
  goto switch_break;
  case_12: /* CIL Label */ 
#line 233
  yyHour = (yyvsp + -3)->Number;
#line 234
  yyMinutes = (yyvsp + -1)->Number;
#line 235
  yyMeridian = (MERIDIAN )2;
#line 236
  yyHaveZone ++;
#line 237
  if ((yyvsp + 0)->Number < 0) {
#line 237
    yyTimezone = - (yyvsp + 0)->Number % 100 + (- (yyvsp + 0)->Number / 100) * 60;
  } else {
#line 237
    yyTimezone = - ((yyvsp + 0)->Number % 100 + ((yyvsp + 0)->Number / 100) * 60);
  }
#line 241
  goto switch_break;
  case_13: /* CIL Label */ 
#line 242
  yyHour = (yyvsp + -5)->Number;
#line 243
  yyMinutes = (yyvsp + -3)->Number;
#line 244
  yySeconds = (yyvsp + -1)->Number;
#line 245
  yyMeridian = (yyvsp + 0)->Meridian;
#line 247
  goto switch_break;
  case_14: /* CIL Label */ 
#line 248
  yyHour = (yyvsp + -5)->Number;
#line 249
  yyMinutes = (yyvsp + -3)->Number;
#line 250
  yySeconds = (yyvsp + -1)->Number;
#line 251
  yyMeridian = (MERIDIAN )2;
#line 252
  yyHaveZone ++;
#line 253
  if ((yyvsp + 0)->Number < 0) {
#line 253
    yyTimezone = - (yyvsp + 0)->Number % 100 + (- (yyvsp + 0)->Number / 100) * 60;
  } else {
#line 253
    yyTimezone = - ((yyvsp + 0)->Number % 100 + ((yyvsp + 0)->Number / 100) * 60);
  }
#line 257
  goto switch_break;
  case_15: /* CIL Label */ 
#line 260
  yyTimezone = (yyvsp + 0)->Number;
#line 262
  goto switch_break;
  case_16: /* CIL Label */ 
#line 263
  yyTimezone = (yyvsp + 0)->Number - 60;
#line 265
  goto switch_break;
  case_17: /* CIL Label */ 
#line 267
  yyTimezone = (yyvsp + -1)->Number - 60;
#line 269
  goto switch_break;
  case_18: /* CIL Label */ 
#line 272
  yyDayOrdinal = 1;
#line 273
  yyDayNumber = (yyvsp + 0)->Number;
#line 275
  goto switch_break;
  case_19: /* CIL Label */ 
#line 276
  yyDayOrdinal = 1;
#line 277
  yyDayNumber = (yyvsp + -1)->Number;
#line 279
  goto switch_break;
  case_20: /* CIL Label */ 
#line 280
  yyDayOrdinal = (yyvsp + -1)->Number;
#line 281
  yyDayNumber = (yyvsp + 0)->Number;
#line 283
  goto switch_break;
  case_21: /* CIL Label */ 
#line 286
  yyMonth = (yyvsp + -2)->Number;
#line 287
  yyDay = (yyvsp + 0)->Number;
#line 289
  goto switch_break;
  case_22: /* CIL Label */ 
#line 294
  if ((yyvsp + -4)->Number >= 1000) {
#line 296
    yyYear = (yyvsp + -4)->Number;
#line 297
    yyMonth = (yyvsp + -2)->Number;
#line 298
    yyDay = (yyvsp + 0)->Number;
  } else {
#line 302
    yyMonth = (yyvsp + -4)->Number;
#line 303
    yyDay = (yyvsp + -2)->Number;
#line 304
    yyYear = (yyvsp + 0)->Number;
  }
#line 307
  goto switch_break;
  case_23: /* CIL Label */ 
#line 309
  yyYear = (yyvsp + -2)->Number;
#line 310
  yyMonth = - (yyvsp + -1)->Number;
#line 311
  yyDay = - (yyvsp + 0)->Number;
#line 313
  goto switch_break;
  case_24: /* CIL Label */ 
#line 315
  yyDay = (yyvsp + -2)->Number;
#line 316
  yyMonth = (yyvsp + -1)->Number;
#line 317
  yyYear = - (yyvsp + 0)->Number;
#line 319
  goto switch_break;
  case_25: /* CIL Label */ 
#line 320
  yyMonth = (yyvsp + -1)->Number;
#line 321
  yyDay = (yyvsp + 0)->Number;
#line 323
  goto switch_break;
  case_26: /* CIL Label */ 
#line 324
  yyMonth = (yyvsp + -3)->Number;
#line 325
  yyDay = (yyvsp + -2)->Number;
#line 326
  yyYear = (yyvsp + 0)->Number;
#line 328
  goto switch_break;
  case_27: /* CIL Label */ 
#line 329
  yyMonth = (yyvsp + 0)->Number;
#line 330
  yyDay = (yyvsp + -1)->Number;
#line 332
  goto switch_break;
  case_28: /* CIL Label */ 
#line 333
  yyMonth = (yyvsp + -1)->Number;
#line 334
  yyDay = (yyvsp + -2)->Number;
#line 335
  yyYear = (yyvsp + 0)->Number;
#line 337
  goto switch_break;
  case_29: /* CIL Label */ 
#line 340
  yyRelSeconds = - yyRelSeconds;
#line 341
  yyRelMinutes = - yyRelMinutes;
#line 342
  yyRelHour = - yyRelHour;
#line 343
  yyRelDay = - yyRelDay;
#line 344
  yyRelMonth = - yyRelMonth;
#line 345
  yyRelYear = - yyRelYear;
#line 347
  goto switch_break;
  case_31: /* CIL Label */ 
#line 351
  yyRelYear += (yyvsp + -1)->Number * (yyvsp + 0)->Number;
#line 353
  goto switch_break;
  case_32: /* CIL Label */ 
#line 354
  yyRelYear += (yyvsp + -1)->Number * (yyvsp + 0)->Number;
#line 356
  goto switch_break;
  case_33: /* CIL Label */ 
#line 357
  yyRelYear += (yyvsp + 0)->Number;
#line 359
  goto switch_break;
  case_34: /* CIL Label */ 
#line 360
  yyRelMonth += (yyvsp + -1)->Number * (yyvsp + 0)->Number;
#line 362
  goto switch_break;
  case_35: /* CIL Label */ 
#line 363
  yyRelMonth += (yyvsp + -1)->Number * (yyvsp + 0)->Number;
#line 365
  goto switch_break;
  case_36: /* CIL Label */ 
#line 366
  yyRelMonth += (yyvsp + 0)->Number;
#line 368
  goto switch_break;
  case_37: /* CIL Label */ 
#line 369
  yyRelDay += (yyvsp + -1)->Number * (yyvsp + 0)->Number;
#line 371
  goto switch_break;
  case_38: /* CIL Label */ 
#line 372
  yyRelDay += (yyvsp + -1)->Number * (yyvsp + 0)->Number;
#line 374
  goto switch_break;
  case_39: /* CIL Label */ 
#line 375
  yyRelDay += (yyvsp + 0)->Number;
#line 377
  goto switch_break;
  case_40: /* CIL Label */ 
#line 378
  yyRelHour += (yyvsp + -1)->Number * (yyvsp + 0)->Number;
#line 380
  goto switch_break;
  case_41: /* CIL Label */ 
#line 381
  yyRelHour += (yyvsp + -1)->Number * (yyvsp + 0)->Number;
#line 383
  goto switch_break;
  case_42: /* CIL Label */ 
#line 384
  yyRelHour += (yyvsp + 0)->Number;
#line 386
  goto switch_break;
  case_43: /* CIL Label */ 
#line 387
  yyRelMinutes += (yyvsp + -1)->Number * (yyvsp + 0)->Number;
#line 389
  goto switch_break;
  case_44: /* CIL Label */ 
#line 390
  yyRelMinutes += (yyvsp + -1)->Number * (yyvsp + 0)->Number;
#line 392
  goto switch_break;
  case_45: /* CIL Label */ 
#line 393
  yyRelMinutes += (yyvsp + 0)->Number;
#line 395
  goto switch_break;
  case_46: /* CIL Label */ 
#line 396
  yyRelSeconds += (yyvsp + -1)->Number * (yyvsp + 0)->Number;
#line 398
  goto switch_break;
  case_47: /* CIL Label */ 
#line 399
  yyRelSeconds += (yyvsp + -1)->Number * (yyvsp + 0)->Number;
#line 401
  goto switch_break;
  case_48: /* CIL Label */ 
#line 402
  yyRelSeconds += (yyvsp + 0)->Number;
#line 404
  goto switch_break;
  case_49: /* CIL Label */ 
#line 408
  if (yyHaveTime) {
#line 408
    if (yyHaveDate) {
#line 408
      if (! yyHaveRel) {
#line 409
        yyYear = (yyvsp + 0)->Number;
      } else {
#line 408
        goto _L___0;
      }
    } else {
#line 408
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 412
  if ((yyvsp + 0)->Number > 10000) {
#line 414
    yyHaveDate ++;
#line 415
    yyDay = (yyvsp + 0)->Number % 100;
#line 416
    yyMonth = ((yyvsp + 0)->Number / 100) % 100;
#line 417
    yyYear = (yyvsp + 0)->Number / 10000;
  } else {
#line 421
    yyHaveTime ++;
#line 422
    if ((yyvsp + 0)->Number < 100) {
#line 424
      yyHour = (yyvsp + 0)->Number;
#line 425
      yyMinutes = 0;
    } else {
#line 429
      yyHour = (yyvsp + 0)->Number / 100;
#line 430
      yyMinutes = (yyvsp + 0)->Number % 100;
    }
#line 432
    yySeconds = 0;
#line 433
    yyMeridian = (MERIDIAN )2;
  }
#line 437
  goto switch_break;
  case_50: /* CIL Label */ 
#line 441
  gd_val.Meridian = (enum _MERIDIAN )2;
#line 443
  goto switch_break;
  case_51: /* CIL Label */ 
#line 445
  gd_val.Meridian = (yyvsp + 0)->Meridian;
#line 447
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 2073 "getdate.c"
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2077
  yyvsp -= gd_yylen;
#line 2077
  yyssp -= gd_yylen;
#line 2078
  gd_yylen = 0;
#line 2081
  yyvsp ++;
#line 2081
  *yyvsp = gd_val;
#line 2087
  yyn = (int )gd_r1[yyn];
#line 2089
  gd_state = (int )((int const   )yypgoto[yyn - 22] + (int const   )*yyssp);
#line 2090
  if (0 <= gd_state) {
#line 2090
    if (gd_state <= 50) {
#line 2090
      if ((int const   )gd_yycheck[gd_state] == (int const   )*yyssp) {
#line 2091
        gd_state = (int )gd_yytable[gd_state];
      } else {
#line 2093
        gd_state = (int )yydefgoto[yyn - 22];
      }
    } else {
#line 2093
      gd_state = (int )yydefgoto[yyn - 22];
    }
  } else {
#line 2093
    gd_state = (int )yydefgoto[yyn - 22];
  }
#line 2095
  goto yynewstate;
  yyerrlab: 
#line 2103
  if (! yyerrstatus) {
    {
#line 2105
    gd_nerrs ++;
#line 2107
    gd_error((char *)"syntax error");
    }
  }
#line 2145
  if (yyerrstatus == 3) {
#line 2150
    if (gd_char <= 0) {
#line 2153
      if (gd_char == 0) {
#line 2154
        goto yyabortlab;
      }
    } else {
      {
#line 2158
      yydestruct("Error: discarding", yytoken, & gd_lval);
#line 2160
      gd_char = -2;
      }
    }
  }
#line 2166
  goto yyerrlab1;
#line 2182
  yyvsp -= gd_yylen;
#line 2182
  yyssp -= gd_yylen;
#line 2183
  gd_yylen = 0;
#line 2185
  gd_state = (int )*yyssp;
#line 2186
  goto yyerrlab1;
  yyerrlab1: 
#line 2193
  yyerrstatus = 3;
  {
#line 2195
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2197
    yyn = (int )gd_pact[gd_state];
#line 2198
    if (yyn != -20) {
#line 2200
      yyn ++;
#line 2201
      if (0 <= yyn) {
#line 2201
        if (yyn <= 50) {
#line 2201
          if ((int const   )gd_yycheck[yyn] == 1) {
#line 2203
            yyn = (int )gd_yytable[yyn];
#line 2204
            if (0 < yyn) {
#line 2205
              goto while_break___1;
            }
          }
        }
      }
    }
#line 2210
    if ((unsigned long )yyssp == (unsigned long )yyss) {
#line 2211
      goto yyabortlab;
    }
    {
#line 2214
    yydestruct("Error: popping", (int )yystos[gd_state], yyvsp);
#line 2216
    yyvsp --;
#line 2216
    yyssp --;
#line 2217
    gd_state = (int )*yyssp;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2221
  yyvsp ++;
#line 2221
  *yyvsp = gd_lval;
#line 2227
  gd_state = yyn;
#line 2228
  goto yynewstate;
  yyacceptlab: 
#line 2235
  yyresult = 0;
#line 2236
  goto yyreturn;
  yyabortlab: 
#line 2242
  yyresult = 1;
#line 2243
  goto yyreturn;
  yyexhaustedlab: 
  {
#line 2250
  gd_error((char *)"memory exhausted");
#line 2251
  yyresult = 2;
  }
  yyreturn: 
#line 2256
  if (gd_char != -2) {
    {
#line 2257
    yydestruct("Cleanup: discarding lookahead", yytoken, & gd_lval);
    }
  }
#line 2261
  yyvsp -= gd_yylen;
#line 2261
  yyssp -= gd_yylen;
  {
#line 2263
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2263
    if (! ((unsigned long )yyssp != (unsigned long )yyss)) {
#line 2263
      goto while_break___2;
    }
    {
#line 2265
    yydestruct("Cleanup: popping", (int )yystos[*yyssp], yyvsp);
#line 2267
    yyvsp --;
#line 2267
    yyssp --;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 2270
  if ((unsigned long )yyss != (unsigned long )(yyssa)) {
    {
#line 2271
    free((void *)yyss);
    }
  }
#line 2278
  return (yyresult);
}
}
#line 515 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 26 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/getdate.h"
time_t get_date(char const   *p , time_t const   *now ) ;
#line 461 "getdate.y"
static TABLE const   MonthDayTable[25]  = 
#line 461 "getdate.y"
  {      {"january", 267, 1}, 
        {"february", 267, 2}, 
        {"march", 267, 3}, 
        {"april", 267, 4}, 
        {"may", 267, 5}, 
        {"june", 267, 6}, 
        {"july", 267, 7}, 
        {"august", 267, 8}, 
        {"september", 267, 9}, 
        {"sept", 267, 9}, 
        {"october", 267, 10}, 
        {"november", 267, 11}, 
        {"december", 267, 12}, 
        {"sunday", 259, 0}, 
        {"monday", 259, 1}, 
        {"tuesday", 259, 2}, 
        {"tues", 259, 2}, 
        {"wednesday", 259, 3}, 
        {"wednes", 259, 3}, 
        {"thursday", 259, 4}, 
        {"thur", 259, 4}, 
        {"thurs", 259, 4}, 
        {"friday", 259, 5}, 
        {"saturday", 259, 6}, 
        {(char const   *)((void *)0), 0, 0}};
#line 490 "getdate.y"
static TABLE const   UnitsTable[11]  = 
#line 490
  {      {"year", 272, 1}, 
        {"month", 268, 1}, 
        {"fortnight", 260, 14}, 
        {"week", 260, 7}, 
        {"day", 260, 1}, 
        {"hour", 263, 1}, 
        {"minute", 266, 1}, 
        {"min", 266, 1}, 
        {"second", 269, 1}, 
        {"sec", 269, 1}, 
        {(char const   *)((void *)0), 0, 0}};
#line 505 "getdate.y"
static TABLE const   OtherTable[20]  = 
#line 505
  {      {"tomorrow", 266, 1440}, 
        {"yesterday", 266, -1440}, 
        {"today", 266, 0}, 
        {"now", 266, 0}, 
        {"last", 271, -1}, 
        {"this", 266, 0}, 
        {"next", 271, 1}, 
        {"first", 271, 1}, 
        {"third", 271, 3}, 
        {"fourth", 271, 4}, 
        {"fifth", 271, 5}, 
        {"sixth", 271, 6}, 
        {"seventh", 271, 7}, 
        {"eighth", 271, 8}, 
        {"ninth", 271, 9}, 
        {"tenth", 271, 10}, 
        {"eleventh", 271, 11}, 
        {"twelfth", 271, 12}, 
        {"ago", 258, 1}, 
        {(char const   *)((void *)0), 0, 0}};
#line 530 "getdate.y"
static TABLE const   TimezoneTable[51]  = 
#line 530
  {      {"gmt", 273, 0}, 
        {"ut", 273, 0}, 
        {"utc", 273, 0}, 
        {"wet", 273, 0}, 
        {"bst", 261, 0}, 
        {"wat", 273, 60}, 
        {"at", 273, 120}, 
        {"ast", 273, 240}, 
        {"adt", 261, 240}, 
        {"est", 273, 300}, 
        {"edt", 261, 300}, 
        {"cst", 273, 360}, 
        {"cdt", 261, 360}, 
        {"mst", 273, 420}, 
        {"mdt", 261, 420}, 
        {"pst", 273, 480}, 
        {"pdt", 261, 480}, 
        {"yst", 273, 540}, 
        {"ydt", 261, 540}, 
        {"hst", 273, 600}, 
        {"hdt", 261, 600}, 
        {"cat", 273, 600}, 
        {"ahst", 273, 600}, 
        {"nt", 273, 660}, 
        {"idlw", 273, 720}, 
        {"cet", 273, -60}, 
        {"met", 273, -60}, 
        {"mewt", 273, -60}, 
        {"mest", 261, -60}, 
        {"mesz", 261, -60}, 
        {"swt", 273, -60}, 
        {"sst", 261, -60}, 
        {"fwt", 273, -60}, 
        {"fst", 261, -60}, 
        {"eet", 273, -120}, 
        {"bt", 273, -180}, 
        {"zp4", 273, -240}, 
        {"zp5", 273, -300}, 
        {"zp6", 273, -360}, 
        {"wast", 273, -420}, 
        {"wadt", 261, -420}, 
        {"cct", 273, -480}, 
        {"jst", 273, -540}, 
        {"east", 273, -600}, 
        {"eadt", 261, -600}, 
        {"gst", 273, -600}, 
        {"nzt", 273, -720}, 
        {"nzst", 273, -720}, 
        {"nzdt", 261, -720}, 
        {"idle", 273, -720}, 
        {(char const   *)((void *)0), 0, 0}};
#line 615 "getdate.y"
static TABLE const   MilitaryTable[26]  = 
#line 615
  {      {"a", 273, 60}, 
        {"b", 273, 120}, 
        {"c", 273, 180}, 
        {"d", 273, 240}, 
        {"e", 273, 300}, 
        {"f", 273, 360}, 
        {"g", 273, 420}, 
        {"h", 273, 480}, 
        {"i", 273, 540}, 
        {"k", 273, 600}, 
        {"l", 273, 660}, 
        {"m", 273, 720}, 
        {"n", 273, -60}, 
        {"o", 273, -120}, 
        {"p", 273, -180}, 
        {"q", 273, -240}, 
        {"r", 273, -300}, 
        {"s", 273, -360}, 
        {"t", 273, -420}, 
        {"u", 273, -480}, 
        {"v", 273, -540}, 
        {"w", 273, -600}, 
        {"x", 273, -660}, 
        {"y", 273, -720}, 
        {"z", 273, 0}, 
        {(char const   *)((void *)0), 0, 0}};
#line 648 "getdate.y"
static int gd_error(char *s  __attribute__((__unused__)) ) 
{ 


  {
#line 652
  return (0);
}
}
#line 655 "getdate.y"
static int ToHour(int Hours , MERIDIAN Meridian ) 
{ 


  {
  {
#line 662
  if ((unsigned int )Meridian == 2U) {
#line 662
    goto case_2;
  }
#line 666
  if ((unsigned int )Meridian == 0U) {
#line 666
    goto case_0;
  }
#line 672
  if ((unsigned int )Meridian == 1U) {
#line 672
    goto case_1;
  }
#line 678
  goto switch_default;
  case_2: /* CIL Label */ 
#line 663
  if (Hours < 0) {
#line 664
    return (-1);
  } else
#line 663
  if (Hours > 23) {
#line 664
    return (-1);
  }
#line 665
  return (Hours);
  case_0: /* CIL Label */ 
#line 667
  if (Hours < 1) {
#line 668
    return (-1);
  } else
#line 667
  if (Hours > 12) {
#line 668
    return (-1);
  }
#line 669
  if (Hours == 12) {
#line 670
    Hours = 0;
  }
#line 671
  return (Hours);
  case_1: /* CIL Label */ 
#line 673
  if (Hours < 1) {
#line 674
    return (-1);
  } else
#line 673
  if (Hours > 12) {
#line 674
    return (-1);
  }
#line 675
  if (Hours == 12) {
#line 676
    Hours = 0;
  }
#line 677
  return (Hours + 12);
  switch_default: /* CIL Label */ 
  {
#line 679
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
}
}
#line 684 "getdate.y"
static int ToYear(int Year ) 
{ 


  {
#line 688
  if (Year < 0) {
#line 689
    Year = - Year;
  }
#line 693
  if (Year < 69) {
#line 694
    Year += 2000;
  } else
#line 695
  if (Year < 100) {
#line 696
    Year += 1900;
  }
#line 698
  return (Year);
}
}
#line 701 "getdate.y"
static int LookupWord(char *buff ) 
{ 
  register char *p ;
  register char *q ;
  register TABLE const   *tp ;
  int i ;
  int abbrev ;
  int tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  size_t tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  unsigned short const   **tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;

  {
#line 712
  p = buff;
  {
#line 712
  while (1) {
    while_continue: /* CIL Label */ ;
#line 712
    if (! *p) {
#line 712
      goto while_break;
    }
#line 713
    if (((int )((unsigned char )*p) & -128) == 0) {
      {
#line 713
      tmp___0 = __ctype_b_loc();
      }
#line 713
      if ((int const   )*(*tmp___0 + (int )((unsigned char )*p)) & 256) {
        {
#line 714
        tmp = tolower((int )*p);
#line 714
        *p = (char )tmp;
        }
      }
    }
#line 712
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 716
  tmp___1 = strcmp((char const   *)buff, "am");
  }
#line 716
  if (tmp___1 == 0) {
#line 718
    gd_lval.Meridian = (enum _MERIDIAN )0;
#line 719
    return (265);
  } else {
    {
#line 716
    tmp___2 = strcmp((char const   *)buff, "a.m.");
    }
#line 716
    if (tmp___2 == 0) {
#line 718
      gd_lval.Meridian = (enum _MERIDIAN )0;
#line 719
      return (265);
    }
  }
  {
#line 721
  tmp___3 = strcmp((char const   *)buff, "pm");
  }
#line 721
  if (tmp___3 == 0) {
#line 723
    gd_lval.Meridian = (enum _MERIDIAN )1;
#line 724
    return (265);
  } else {
    {
#line 721
    tmp___4 = strcmp((char const   *)buff, "p.m.");
    }
#line 721
    if (tmp___4 == 0) {
#line 723
      gd_lval.Meridian = (enum _MERIDIAN )1;
#line 724
      return (265);
    }
  }
  {
#line 728
  tmp___6 = strlen((char const   *)buff);
  }
#line 728
  if (tmp___6 == 3UL) {
#line 729
    abbrev = 1;
  } else {
    {
#line 730
    tmp___5 = strlen((char const   *)buff);
    }
#line 730
    if (tmp___5 == 4UL) {
#line 730
      if ((int )*(buff + 3) == 46) {
#line 732
        abbrev = 1;
#line 733
        *(buff + 3) = (char )'\000';
      } else {
#line 736
        abbrev = 0;
      }
    } else {
#line 736
      abbrev = 0;
    }
  }
#line 738
  tp = MonthDayTable;
  {
#line 738
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 738
    if (! tp->name) {
#line 738
      goto while_break___0;
    }
#line 740
    if (abbrev) {
      {
#line 742
      tmp___7 = strncmp((char const   *)buff, (char const   *)tp->name, (size_t )3);
      }
#line 742
      if (tmp___7 == 0) {
#line 744
        gd_lval.Number = (int )tp->value;
#line 745
        return ((int )tp->type);
      }
    } else {
      {
#line 748
      tmp___8 = strcmp((char const   *)buff, (char const   *)tp->name);
      }
#line 748
      if (tmp___8 == 0) {
#line 750
        gd_lval.Number = (int )tp->value;
#line 751
        return ((int )tp->type);
      }
    }
#line 738
    tp ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 755
  tp = TimezoneTable;
  {
#line 755
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 755
    if (! tp->name) {
#line 755
      goto while_break___1;
    }
    {
#line 756
    tmp___9 = strcmp((char const   *)buff, (char const   *)tp->name);
    }
#line 756
    if (tmp___9 == 0) {
#line 758
      gd_lval.Number = (int )tp->value;
#line 759
      return ((int )tp->type);
    }
#line 755
    tp ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 762
  tmp___10 = strcmp((char const   *)buff, "dst");
  }
#line 762
  if (tmp___10 == 0) {
#line 763
    return (262);
  }
#line 765
  tp = UnitsTable;
  {
#line 765
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 765
    if (! tp->name) {
#line 765
      goto while_break___2;
    }
    {
#line 766
    tmp___11 = strcmp((char const   *)buff, (char const   *)tp->name);
    }
#line 766
    if (tmp___11 == 0) {
#line 768
      gd_lval.Number = (int )tp->value;
#line 769
      return ((int )tp->type);
    }
#line 765
    tp ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 773
  tmp___12 = strlen((char const   *)buff);
#line 773
  i = (int )(tmp___12 - 1UL);
  }
#line 774
  if ((int )*(buff + i) == 115) {
#line 776
    *(buff + i) = (char )'\000';
#line 777
    tp = UnitsTable;
    {
#line 777
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 777
      if (! tp->name) {
#line 777
        goto while_break___3;
      }
      {
#line 778
      tmp___13 = strcmp((char const   *)buff, (char const   *)tp->name);
      }
#line 778
      if (tmp___13 == 0) {
#line 780
        gd_lval.Number = (int )tp->value;
#line 781
        return ((int )tp->type);
      }
#line 777
      tp ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 783
    *(buff + i) = (char )'s';
  }
#line 786
  tp = OtherTable;
  {
#line 786
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 786
    if (! tp->name) {
#line 786
      goto while_break___4;
    }
    {
#line 787
    tmp___14 = strcmp((char const   *)buff, (char const   *)tp->name);
    }
#line 787
    if (tmp___14 == 0) {
#line 789
      gd_lval.Number = (int )tp->value;
#line 790
      return ((int )tp->type);
    }
#line 786
    tp ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 794
  if ((int )*(buff + 1) == 0) {
#line 794
    if (((int )((unsigned char )*buff) & -128) == 0) {
      {
#line 794
      tmp___16 = __ctype_b_loc();
      }
#line 794
      if ((int const   )*(*tmp___16 + (int )((unsigned char )*buff)) & 1024) {
#line 796
        tp = MilitaryTable;
        {
#line 796
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 796
          if (! tp->name) {
#line 796
            goto while_break___5;
          }
          {
#line 797
          tmp___15 = strcmp((char const   *)buff, (char const   *)tp->name);
          }
#line 797
          if (tmp___15 == 0) {
#line 799
            gd_lval.Number = (int )tp->value;
#line 800
            return ((int )tp->type);
          }
#line 796
          tp ++;
        }
        while_break___5: /* CIL Label */ ;
        }
      }
    }
  }
#line 805
  i = 0;
#line 805
  q = buff;
#line 805
  p = q;
  {
#line 805
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 805
    if (! *q) {
#line 805
      goto while_break___6;
    }
#line 806
    if ((int )*q != 46) {
#line 807
      tmp___17 = p;
#line 807
      p ++;
#line 807
      *tmp___17 = *q;
    } else {
#line 809
      i ++;
    }
#line 805
    q ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 810
  *p = (char )'\000';
#line 811
  if (i) {
#line 812
    tp = TimezoneTable;
    {
#line 812
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 812
      if (! tp->name) {
#line 812
        goto while_break___7;
      }
      {
#line 813
      tmp___18 = strcmp((char const   *)buff, (char const   *)tp->name);
      }
#line 813
      if (tmp___18 == 0) {
#line 815
        gd_lval.Number = (int )tp->value;
#line 816
        return ((int )tp->type);
      }
#line 812
      tp ++;
    }
    while_break___7: /* CIL Label */ ;
    }
  }
#line 819
  return (264);
}
}
#line 822 "getdate.y"
static int gd_lex(void) 
{ 
  register unsigned char c ;
  register char *p ;
  char buff[20] ;
  int Count ;
  int sign ;
  unsigned short const   **tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char const   *tmp___3 ;
  unsigned short const   **tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  unsigned short const   **tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;

  {
  {
#line 831
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 833
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 833
      if (((int )((unsigned char )*yyInput) & -128) == 0) {
        {
#line 833
        tmp = __ctype_b_loc();
        }
#line 833
        if (! ((int const   )*(*tmp + (int )((unsigned char )*yyInput)) & 8192)) {
#line 833
          goto while_break___0;
        }
      } else {
#line 833
        goto while_break___0;
      }
#line 834
      yyInput ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 836
    c = (unsigned char )*yyInput;
#line 836
    if ((unsigned int )c - 48U <= 9U) {
#line 836
      goto _L___0;
    } else
#line 836
    if ((int )c == 45) {
#line 836
      goto _L___0;
    } else
#line 836
    if ((int )c == 43) {
      _L___0: /* CIL Label */ 
#line 838
      if ((int )c == 45) {
#line 838
        goto _L;
      } else
#line 838
      if ((int )c == 43) {
        _L: /* CIL Label */ 
#line 840
        if ((int )c == 45) {
#line 840
          sign = -1;
        } else {
#line 840
          sign = 1;
        }
#line 841
        yyInput ++;
#line 841
        if (! ((unsigned int )*yyInput - 48U <= 9U)) {
#line 843
          goto __Cont;
        }
      } else {
#line 846
        sign = 0;
      }
#line 847
      gd_lval.Number = 0;
      {
#line 847
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 847
        tmp___0 = yyInput;
#line 847
        yyInput ++;
#line 847
        c = (unsigned char )*tmp___0;
#line 847
        if (! ((unsigned int )c - 48U <= 9U)) {
#line 847
          goto while_break___1;
        }
#line 848
        gd_lval.Number = (10 * gd_lval.Number + (int )c) - 48;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 849
      yyInput --;
#line 850
      if (sign < 0) {
#line 851
        gd_lval.Number = - gd_lval.Number;
      }
#line 852
      if (sign) {
#line 852
        tmp___1 = 270;
      } else {
#line 852
        tmp___1 = 271;
      }
#line 852
      return (tmp___1);
    }
#line 854
    if (((int )c & -128) == 0) {
      {
#line 854
      tmp___7 = __ctype_b_loc();
      }
#line 854
      if ((int const   )*(*tmp___7 + (int )c) & 1024) {
#line 856
        p = buff;
        {
#line 856
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 856
          tmp___3 = yyInput;
#line 856
          yyInput ++;
#line 856
          c = (unsigned char )*tmp___3;
#line 856
          if (((int )c & -128) == 0) {
            {
#line 856
            tmp___4 = __ctype_b_loc();
            }
#line 856
            if ((int const   )*(*tmp___4 + (int )c) & 1024) {
#line 856
              tmp___5 = 1;
            } else {
#line 856
              tmp___5 = 0;
            }
          } else {
#line 856
            tmp___5 = 0;
          }
#line 856
          if (! tmp___5) {
#line 856
            if (! ((int )c == 46)) {
#line 856
              goto while_break___2;
            }
          }
#line 857
          if ((unsigned long )p < (unsigned long )(& buff[sizeof(buff) - 1UL])) {
#line 858
            tmp___2 = p;
#line 858
            p ++;
#line 858
            *tmp___2 = (char )c;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 859
        *p = (char )'\000';
#line 860
        yyInput --;
#line 861
        tmp___6 = LookupWord(buff);
        }
#line 861
        return (tmp___6);
      }
    }
#line 863
    if ((int )c != 40) {
#line 864
      tmp___8 = yyInput;
#line 864
      yyInput ++;
#line 864
      return ((int )*tmp___8);
    }
#line 865
    Count = 0;
    {
#line 866
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 868
      tmp___9 = yyInput;
#line 868
      yyInput ++;
#line 868
      c = (unsigned char )*tmp___9;
#line 869
      if ((int )c == 0) {
#line 870
        return ((int )c);
      }
#line 871
      if ((int )c == 40) {
#line 872
        Count ++;
      } else
#line 873
      if ((int )c == 41) {
#line 874
        Count --;
      }
#line 866
      if (! (Count > 0)) {
#line 866
        goto while_break___3;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 883 "getdate.y"
static long difftm(struct tm *a , struct tm *b ) 
{ 
  int ay ;
  int by ;
  long days ;

  {
#line 886
  ay = a->tm_year + 1899;
#line 887
  by = b->tm_year + 1899;
#line 888
  days = (long )((((a->tm_yday - b->tm_yday) + ((ay >> 2) - (by >> 2))) - (ay / 100 - by / 100)) + ((ay / 100 >> 2) - (by / 100 >> 2))) + (long )(ay - by) * 365L;
#line 898
  return (60L * (60L * (24L * days + (long )(a->tm_hour - b->tm_hour)) + (long )(a->tm_min - b->tm_min)) + (long )(a->tm_sec - b->tm_sec));
}
}
#line 903 "getdate.y"
time_t get_date(char const   *p , time_t const   *now ) 
{ 
  struct tm tm ;
  struct tm tm0 ;
  struct tm *tmp ;
  time_t Start ;
  time_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  long delta ;
  struct tm *gmt ;
  struct tm *tmp___3 ;
  long tmp___4 ;

  {
#line 909
  yyInput = p;
#line 910
  if (now) {
#line 910
    Start = (time_t )*now;
  } else {
    {
#line 910
    tmp___0 = time((time_t *)((void *)0));
#line 910
    Start = tmp___0;
    }
  }
  {
#line 911
  tmp = localtime((time_t const   *)(& Start));
  }
#line 912
  if (! tmp) {
#line 913
    return ((time_t )-1);
  }
  {
#line 914
  yyYear = tmp->tm_year + 1900;
#line 915
  yyMonth = tmp->tm_mon + 1;
#line 916
  yyDay = tmp->tm_mday;
#line 917
  yyHour = tmp->tm_hour;
#line 918
  yyMinutes = tmp->tm_min;
#line 919
  yySeconds = tmp->tm_sec;
#line 920
  tm.tm_isdst = tmp->tm_isdst;
#line 921
  yyMeridian = (MERIDIAN )2;
#line 922
  yyRelSeconds = 0;
#line 923
  yyRelMinutes = 0;
#line 924
  yyRelHour = 0;
#line 925
  yyRelDay = 0;
#line 926
  yyRelMonth = 0;
#line 927
  yyRelYear = 0;
#line 928
  yyHaveDate = 0;
#line 929
  yyHaveDay = 0;
#line 930
  yyHaveRel = 0;
#line 931
  yyHaveTime = 0;
#line 932
  yyHaveZone = 0;
#line 934
  tmp___1 = gd_parse();
  }
#line 934
  if (tmp___1) {
#line 936
    return ((time_t )-1);
  } else
#line 934
  if (yyHaveTime > 1) {
#line 936
    return ((time_t )-1);
  } else
#line 934
  if (yyHaveZone > 1) {
#line 936
    return ((time_t )-1);
  } else
#line 934
  if (yyHaveDate > 1) {
#line 936
    return ((time_t )-1);
  } else
#line 934
  if (yyHaveDay > 1) {
#line 936
    return ((time_t )-1);
  }
  {
#line 938
  tmp___2 = ToYear(yyYear);
#line 938
  tm.tm_year = (tmp___2 - 1900) + yyRelYear;
#line 939
  tm.tm_mon = (yyMonth - 1) + yyRelMonth;
#line 940
  tm.tm_mday = yyDay + yyRelDay;
  }
#line 941
  if (yyHaveTime) {
#line 941
    goto _L;
  } else
#line 941
  if (yyHaveRel) {
#line 941
    if (! yyHaveDate) {
#line 941
      if (! yyHaveDay) {
        _L: /* CIL Label */ 
        {
#line 943
        tm.tm_hour = ToHour(yyHour, yyMeridian);
        }
#line 944
        if (tm.tm_hour < 0) {
#line 945
          return ((time_t )-1);
        }
#line 946
        tm.tm_min = yyMinutes;
#line 947
        tm.tm_sec = yySeconds;
      } else {
#line 951
        tm.tm_sec = 0;
#line 951
        tm.tm_min = tm.tm_sec;
#line 951
        tm.tm_hour = tm.tm_min;
      }
    } else {
#line 951
      tm.tm_sec = 0;
#line 951
      tm.tm_min = tm.tm_sec;
#line 951
      tm.tm_hour = tm.tm_min;
    }
  } else {
#line 951
    tm.tm_sec = 0;
#line 951
    tm.tm_min = tm.tm_sec;
#line 951
    tm.tm_hour = tm.tm_min;
  }
#line 953
  tm.tm_hour += yyRelHour;
#line 954
  tm.tm_min += yyRelMinutes;
#line 955
  tm.tm_sec += yyRelSeconds;
#line 959
  if (((((yyHaveDate | yyHaveDay) | yyHaveTime) | yyRelDay) | yyRelMonth) | yyRelYear) {
#line 960
    tm.tm_isdst = -1;
  }
  {
#line 962
  tm0 = tm;
#line 964
  Start = mktime(& tm);
  }
#line 966
  if (Start == -1L) {
#line 977
    if (yyHaveZone) {
#line 979
      tm = tm0;
#line 980
      if (tm.tm_year <= 70) {
#line 982
        (tm.tm_mday) ++;
#line 983
        yyTimezone -= 1440;
      } else {
#line 987
        (tm.tm_mday) --;
#line 988
        yyTimezone += 1440;
      }
      {
#line 990
      Start = mktime(& tm);
      }
    }
#line 993
    if (Start == -1L) {
#line 994
      return (Start);
    }
  }
#line 997
  if (yyHaveDay) {
#line 997
    if (! yyHaveDate) {
      {
#line 999
      tm.tm_mday += ((yyDayNumber - tm.tm_wday) + 7) % 7 + 7 * (yyDayOrdinal - (0 < yyDayOrdinal));
#line 1001
      Start = mktime(& tm);
      }
#line 1002
      if (Start == -1L) {
#line 1003
        return (Start);
      }
    }
  }
#line 1006
  if (yyHaveZone) {
    {
#line 1009
    tmp___3 = gmtime((time_t const   *)(& Start));
#line 1009
    gmt = tmp___3;
    }
#line 1010
    if (! gmt) {
#line 1011
      return ((time_t )-1);
    }
    {
#line 1012
    tmp___4 = difftm(& tm, gmt);
#line 1012
    delta = (long )yyTimezone * 60L + tmp___4;
    }
#line 1013
    if ((Start + delta < Start) != (delta < 0L)) {
#line 1014
      return ((time_t )-1);
    }
#line 1015
    Start += delta;
  }
#line 1018
  return (Start);
}
}
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 846
extern void perror(char const   *__s ) ;
#line 261 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) asctime)(struct tm  const  *__tp ) ;
#line 444 "/usr/include/unistd.h"
extern unsigned int sleep(unsigned int __seconds ) ;
#line 779
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
#line 948
extern char *( __attribute__((__nonnull__(1))) getpass)(char const   *__prompt ) ;
#line 61 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static int sock_fd  ;
#line 62 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
union sockaddr_in46 his_addr  ;
#line 63 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static socklen_t his_addr_len  ;
#line 65 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static int on_terminal  =    0;
#line 67 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static int no_dns  =    0;
#line 78 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static char buffer[64]  ;
#line 79
static char *time_to_log_form(time_t t ) ;
#line 79 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static char const   *months[12]  = 
#line 79
  {      "Jan",      "Feb",      "Mar",      "Apr", 
        "May",      "Jun",      "Jul",      "Aug", 
        "Sep",      "Oct",      "Nov",      "Dec"};
#line 74 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static char *time_to_log_form(time_t t ) 
{ 
  struct tm stm ;
  struct tm *tmp ;

  {
  {
#line 84
  tmp = gmtime((time_t const   *)(& t));
#line 84
  stm = *tmp;
#line 85
  snprintf((char */* __restrict  */)(buffer), sizeof(buffer), (char const   */* __restrict  */)"%2d%s%02d %02d:%02d:%02d",
           stm.tm_mday, months[stm.tm_mon], stm.tm_year % 100, stm.tm_hour, stm.tm_min,
           stm.tm_sec);
  }
#line 90
  return (buffer);
}
}
#line 100 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static char line[2048]  ;
#line 101
static char *read_line(void) ;
#line 101 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static char const   *prompt  =    "chronyc> ";
#line 97 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static char *read_line(void) 
{ 
  char *tmp ;

  {
#line 103
  if (on_terminal) {
    {
#line 124
    printf((char const   */* __restrict  */)"%s", prompt);
    }
  }
  {
#line 127
  tmp = fgets((char */* __restrict  */)(line), (int )sizeof(line), (FILE */* __restrict  */)stdin);
  }
#line 127
  if (tmp) {
#line 128
    return (line);
  } else {
#line 130
    return ((char *)((void *)0));
  }
}
}
#line 138 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static void open_io(char const   *hostname , int port ) 
{ 
  IPAddr ip ;
  DNS_Status tmp ;

  {
  {
#line 144
  tmp = DNS_Name2IPAddress(hostname, & ip);
  }
#line 144
  if ((unsigned int )tmp != 0U) {
    {
#line 145
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not get IP address for %s\n",
            hostname);
#line 146
    exit(1);
    }
  }
  {
#line 149
  memset((void *)(& his_addr), 0, sizeof(his_addr));
  }
  {
#line 152
  if ((int )ip.family == 1) {
#line 152
    goto case_1;
  }
#line 161
  if ((int )ip.family == 2) {
#line 161
    goto case_2;
  }
#line 171
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 153
  sock_fd = socket(2, 2, 0);
#line 155
  his_addr.in4.sin_family = (sa_family_t )2;
#line 156
  his_addr.in4.sin_addr.s_addr = htonl(ip.addr.in4);
#line 157
  his_addr.in4.sin_port = htons((uint16_t )port);
#line 158
  his_addr_len = (socklen_t )sizeof(his_addr.in4);
  }
#line 159
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 162
  sock_fd = socket(10, 2, 0);
#line 164
  his_addr.in6.sin6_family = (sa_family_t )10;
#line 165
  memcpy((void */* __restrict  */)(his_addr.in6.sin6_addr.__in6_u.__u6_addr8), (void const   */* __restrict  */)(ip.addr.in6),
         sizeof(his_addr.in6.sin6_addr.__in6_u.__u6_addr8));
#line 167
  his_addr.in6.sin6_port = htons((uint16_t )port);
#line 168
  his_addr_len = (socklen_t )sizeof(his_addr.in6);
  }
#line 169
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 172
  __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c",
                172U, "open_io");
  }
  switch_break: /* CIL Label */ ;
  }
#line 175
  if (sock_fd < 0) {
    {
#line 176
    perror("Can\'t create socket");
#line 177
    exit(1);
    }
  }
#line 179
  return;
}
}
#line 183 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static void close_io(void) 
{ 


  {
  {
#line 187
  close(sock_fd);
  }
#line 189
  return;
}
}
#line 193 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static void bits_to_mask(int bits , int family , IPAddr *mask ) 
{ 
  int i ;
  int tmp ;

  {
#line 198
  mask->family = (uint16_t )family;
  {
#line 200
  if (family == 1) {
#line 200
    goto case_1;
  }
#line 210
  if (family == 2) {
#line 210
    goto case_2;
  }
#line 220
  goto switch_default;
  case_1: /* CIL Label */ 
#line 201
  if (bits < 0) {
#line 202
    bits = 32;
  }
#line 203
  if (bits > 0) {
#line 204
    mask->addr.in4 = (uint32_t )-1;
#line 205
    mask->addr.in4 <<= 32 - bits;
  } else {
#line 207
    mask->addr.in4 = (uint32_t )0;
  }
#line 209
  goto switch_break;
  case_2: /* CIL Label */ 
#line 211
  if (bits > 128) {
#line 212
    bits = 128;
  } else
#line 211
  if (bits < 0) {
#line 212
    bits = 128;
  }
#line 213
  i = 0;
  {
#line 213
  while (1) {
    while_continue: /* CIL Label */ ;
#line 213
    if (! (i < bits / 8)) {
#line 213
      goto while_break;
    }
#line 214
    mask->addr.in6[i] = (uint8_t )255;
#line 213
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 215
  if (i < 16) {
#line 216
    tmp = i;
#line 216
    i ++;
#line 216
    mask->addr.in6[tmp] = (uint8_t )((255 << (8 - bits % 8)) & 255);
  }
  {
#line 217
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 217
    if (! (i < 16)) {
#line 217
      goto while_break___0;
    }
#line 218
    mask->addr.in6[i] = (uint8_t )0;
#line 217
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 219
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 221
  __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c",
                221U, "bits_to_mask");
  }
  switch_break: /* CIL Label */ ;
  }
#line 223
  return;
}
}
#line 227 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static int read_mask_address(char *line___0 , IPAddr *mask , IPAddr *address ) 
{ 
  unsigned int bits ;
  char *p ;
  char *q ;
  uint16_t tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  DNS_Status tmp___4 ;

  {
#line 233
  p = line___0;
#line 234
  if (! *p) {
#line 235
    tmp = (uint16_t )0;
#line 235
    address->family = tmp;
#line 235
    mask->family = tmp;
#line 236
    return (1);
  } else {
    {
#line 238
    q = strchr((char const   *)p, '/');
    }
#line 239
    if (q) {
      {
#line 240
      tmp___0 = q;
#line 240
      q ++;
#line 240
      *tmp___0 = (char)0;
#line 241
      tmp___3 = UTI_StringToIP((char const   *)p, mask);
      }
#line 241
      if (tmp___3) {
        {
#line 242
        p = q;
#line 243
        tmp___2 = UTI_StringToIP((char const   *)p, address);
        }
#line 243
        if (tmp___2) {
#line 244
          if ((int )address->family == (int )mask->family) {
#line 245
            return (1);
          }
        } else {
          {
#line 246
          tmp___1 = sscanf((char const   */* __restrict  */)p, (char const   */* __restrict  */)"%u",
                           & bits);
          }
#line 246
          if (tmp___1 == 1) {
            {
#line 247
            *address = *mask;
#line 248
            bits_to_mask((int )bits, (int )address->family, mask);
            }
#line 249
            return (1);
          }
        }
      }
    } else {
      {
#line 253
      tmp___4 = DNS_Name2IPAddress((char const   *)p, address);
      }
#line 253
      if ((unsigned int )tmp___4 == 0U) {
        {
#line 254
        bits_to_mask(-1, (int )address->family, mask);
        }
#line 255
        return (1);
      } else {
        {
#line 257
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not get address for hostname\n");
        }
#line 258
        return (0);
      }
    }
  }
  {
#line 263
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid syntax for mask/address\n");
  }
#line 264
  return (0);
}
}
#line 269 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static int process_cmd_offline(CMD_Request *msg , char *line___0 ) 
{ 
  IPAddr mask ;
  IPAddr address ;
  int ok ;
  int tmp ;

  {
  {
#line 275
  tmp = read_mask_address(line___0, & mask, & address);
  }
#line 275
  if (tmp) {
    {
#line 276
    UTI_IPHostToNetwork(& mask, & msg->data.offline.mask);
#line 277
    UTI_IPHostToNetwork(& address, & msg->data.offline.address);
#line 278
    msg->command = htons((uint16_t )2);
#line 279
    ok = 1;
    }
  } else {
#line 281
    ok = 0;
  }
#line 284
  return (ok);
}
}
#line 291 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static int process_cmd_online(CMD_Request *msg , char *line___0 ) 
{ 
  IPAddr mask ;
  IPAddr address ;
  int ok ;
  int tmp ;

  {
  {
#line 297
  tmp = read_mask_address(line___0, & mask, & address);
  }
#line 297
  if (tmp) {
    {
#line 298
    UTI_IPHostToNetwork(& mask, & msg->data.online.mask);
#line 299
    UTI_IPHostToNetwork(& address, & msg->data.online.address);
#line 300
    msg->command = htons((uint16_t )1);
#line 301
    ok = 1;
    }
  } else {
#line 303
    ok = 0;
  }
#line 306
  return (ok);
}
}
#line 312 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static int read_address_integer(char *line___0 , IPAddr *address , int *value ) 
{ 
  char *hostname ;
  int ok ;
  DNS_Status tmp ;
  int tmp___0 ;

  {
  {
#line 316
  ok = 0;
#line 318
  hostname = line___0;
#line 319
  line___0 = CPS_SplitWord(line___0);
#line 321
  tmp___0 = sscanf((char const   */* __restrict  */)line___0, (char const   */* __restrict  */)"%d",
                   value);
  }
#line 321
  if (tmp___0 != 1) {
    {
#line 322
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid syntax for address value\n");
#line 323
    ok = 0;
    }
  } else {
    {
#line 325
    tmp = DNS_Name2IPAddress((char const   *)hostname, address);
    }
#line 325
    if ((unsigned int )tmp != 0U) {
      {
#line 326
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not get address for hostname\n");
#line 327
      ok = 0;
      }
    } else {
#line 329
      ok = 1;
    }
  }
#line 333
  return (ok);
}
}
#line 340 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static int read_address_double(char *line___0 , IPAddr *address , double *value ) 
{ 
  char *hostname ;
  int ok ;
  DNS_Status tmp ;
  int tmp___0 ;

  {
  {
#line 344
  ok = 0;
#line 346
  hostname = line___0;
#line 347
  line___0 = CPS_SplitWord(line___0);
#line 349
  tmp___0 = sscanf((char const   */* __restrict  */)line___0, (char const   */* __restrict  */)"%lf",
                   value);
  }
#line 349
  if (tmp___0 != 1) {
    {
#line 350
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid syntax for address value\n");
#line 351
    ok = 0;
    }
  } else {
    {
#line 353
    tmp = DNS_Name2IPAddress((char const   *)hostname, address);
    }
#line 353
    if ((unsigned int )tmp != 0U) {
      {
#line 354
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not get address for hostname\n");
#line 355
      ok = 0;
      }
    } else {
#line 357
      ok = 1;
    }
  }
#line 361
  return (ok);
}
}
#line 368 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static int process_cmd_minpoll(CMD_Request *msg , char *line___0 ) 
{ 
  IPAddr address ;
  int minpoll ;
  int ok ;
  uint32_t tmp ;
  int tmp___0 ;

  {
  {
#line 375
  tmp___0 = read_address_integer(line___0, & address, & minpoll);
  }
#line 375
  if (tmp___0) {
    {
#line 376
    UTI_IPHostToNetwork(& address, & msg->data.modify_minpoll.address);
#line 377
    tmp = htonl((uint32_t )minpoll);
#line 377
    msg->data.modify_minpoll.new_minpoll = (int32_t )tmp;
#line 378
    msg->command = htons((uint16_t )4);
#line 379
    ok = 1;
    }
  } else {
#line 381
    ok = 0;
  }
#line 384
  return (ok);
}
}
#line 390 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static int process_cmd_maxpoll(CMD_Request *msg , char *line___0 ) 
{ 
  IPAddr address ;
  int maxpoll ;
  int ok ;
  uint32_t tmp ;
  int tmp___0 ;

  {
  {
#line 397
  tmp___0 = read_address_integer(line___0, & address, & maxpoll);
  }
#line 397
  if (tmp___0) {
    {
#line 398
    UTI_IPHostToNetwork(& address, & msg->data.modify_maxpoll.address);
#line 399
    tmp = htonl((uint32_t )maxpoll);
#line 399
    msg->data.modify_maxpoll.new_maxpoll = (int32_t )tmp;
#line 400
    msg->command = htons((uint16_t )5);
#line 401
    ok = 1;
    }
  } else {
#line 403
    ok = 0;
  }
#line 406
  return (ok);
}
}
#line 412 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static int process_cmd_maxdelay(CMD_Request *msg , char *line___0 ) 
{ 
  IPAddr address ;
  double max_delay ;
  int ok ;
  int tmp ;

  {
  {
#line 419
  tmp = read_address_double(line___0, & address, & max_delay);
  }
#line 419
  if (tmp) {
    {
#line 420
    UTI_IPHostToNetwork(& address, & msg->data.modify_maxdelay.address);
#line 421
    msg->data.modify_maxdelay.new_max_delay = UTI_FloatHostToNetwork(max_delay);
#line 422
    msg->command = htons((uint16_t )7);
#line 423
    ok = 1;
    }
  } else {
#line 425
    ok = 0;
  }
#line 428
  return (ok);
}
}
#line 434 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static int process_cmd_maxdelaydevratio(CMD_Request *msg , char *line___0 ) 
{ 
  IPAddr address ;
  double max_delay_dev_ratio ;
  int ok ;
  int tmp ;

  {
  {
#line 441
  tmp = read_address_double(line___0, & address, & max_delay_dev_ratio);
  }
#line 441
  if (tmp) {
    {
#line 442
    UTI_IPHostToNetwork(& address, & msg->data.modify_maxdelaydevratio.address);
#line 443
    msg->data.modify_maxdelayratio.new_max_delay_ratio = UTI_FloatHostToNetwork(max_delay_dev_ratio);
#line 444
    msg->command = htons((uint16_t )47);
#line 445
    ok = 1;
    }
  } else {
#line 447
    ok = 0;
  }
#line 450
  return (ok);
}
}
#line 456 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static int process_cmd_maxdelayratio(CMD_Request *msg , char *line___0 ) 
{ 
  IPAddr address ;
  double max_delay_ratio ;
  int ok ;
  int tmp ;

  {
  {
#line 463
  tmp = read_address_double(line___0, & address, & max_delay_ratio);
  }
#line 463
  if (tmp) {
    {
#line 464
    UTI_IPHostToNetwork(& address, & msg->data.modify_maxdelayratio.address);
#line 465
    msg->data.modify_maxdelayratio.new_max_delay_ratio = UTI_FloatHostToNetwork(max_delay_ratio);
#line 466
    msg->command = htons((uint16_t )8);
#line 467
    ok = 1;
    }
  } else {
#line 469
    ok = 0;
  }
#line 472
  return (ok);
}
}
#line 478 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static int process_cmd_minstratum(CMD_Request *msg , char *line___0 ) 
{ 
  IPAddr address ;
  int min_stratum ;
  int ok ;
  uint32_t tmp ;
  int tmp___0 ;

  {
  {
#line 485
  tmp___0 = read_address_integer(line___0, & address, & min_stratum);
  }
#line 485
  if (tmp___0) {
    {
#line 486
    UTI_IPHostToNetwork(& address, & msg->data.modify_minstratum.address);
#line 487
    tmp = htonl((uint32_t )min_stratum);
#line 487
    msg->data.modify_minstratum.new_min_stratum = (int32_t )tmp;
#line 488
    msg->command = htons((uint16_t )45);
#line 489
    ok = 1;
    }
  } else {
#line 491
    ok = 0;
  }
#line 494
  return (ok);
}
}
#line 500 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static int process_cmd_polltarget(CMD_Request *msg , char *line___0 ) 
{ 
  IPAddr address ;
  int poll_target ;
  int ok ;
  uint32_t tmp ;
  int tmp___0 ;

  {
  {
#line 507
  tmp___0 = read_address_integer(line___0, & address, & poll_target);
  }
#line 507
  if (tmp___0) {
    {
#line 508
    UTI_IPHostToNetwork(& address, & msg->data.modify_polltarget.address);
#line 509
    tmp = htonl((uint32_t )poll_target);
#line 509
    msg->data.modify_polltarget.new_poll_target = (int32_t )tmp;
#line 510
    msg->command = htons((uint16_t )46);
#line 511
    ok = 1;
    }
  } else {
#line 513
    ok = 0;
  }
#line 516
  return (ok);
}
}
#line 522 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static int process_cmd_maxupdateskew(CMD_Request *msg , char *line___0 ) 
{ 
  int ok ;
  double new_max_update_skew ;
  int tmp ;

  {
  {
#line 528
  tmp = sscanf((char const   */* __restrict  */)line___0, (char const   */* __restrict  */)"%lf",
               & new_max_update_skew);
  }
#line 528
  if (tmp == 1) {
    {
#line 529
    msg->data.modify_maxupdateskew.new_max_update_skew = UTI_FloatHostToNetwork(new_max_update_skew);
#line 530
    msg->command = htons((uint16_t )9);
#line 531
    ok = 1;
    }
  } else {
#line 533
    ok = 0;
  }
#line 536
  return (ok);
}
}
#line 542 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static void process_cmd_dump(CMD_Request *msg , char *line___0 ) 
{ 
  uint32_t tmp ;

  {
  {
#line 545
  msg->command = htons((uint16_t )6);
#line 546
  tmp = htonl((uint32_t )0);
#line 546
  msg->data.dump.pad = (int32_t )tmp;
  }
#line 547
  return;
}
}
#line 551 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static void process_cmd_writertc(CMD_Request *msg , char *line___0 ) 
{ 


  {
  {
#line 554
  msg->command = htons((uint16_t )30);
  }
#line 555
  return;
}
}
#line 559 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static void process_cmd_trimrtc(CMD_Request *msg , char *line___0 ) 
{ 


  {
  {
#line 562
  msg->command = htons((uint16_t )36);
  }
#line 563
  return;
}
}
#line 567 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static void process_cmd_cyclelogs(CMD_Request *msg , char *line___0 ) 
{ 


  {
  {
#line 570
  msg->command = htons((uint16_t )37);
  }
#line 571
  return;
}
}
#line 575 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static int process_cmd_burst(CMD_Request *msg , char *line___0 ) 
{ 
  int n_good_samples ;
  int n_total_samples ;
  char *s1 ;
  char *s2 ;
  IPAddr address ;
  IPAddr mask ;
  int tmp ;
  int tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;

  {
  {
#line 582
  s1 = line___0;
#line 583
  s2 = CPS_SplitWord(s1);
#line 584
  CPS_SplitWord(s2);
#line 586
  tmp = sscanf((char const   */* __restrict  */)s1, (char const   */* __restrict  */)"%d/%d",
               & n_good_samples, & n_total_samples);
  }
#line 586
  if (tmp != 2) {
    {
#line 587
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid syntax for burst command\n");
    }
#line 588
    return (0);
  }
#line 591
  address.family = (uint16_t )0;
#line 591
  mask.family = address.family;
#line 592
  if (*s2) {
    {
#line 592
    tmp___0 = read_mask_address(s2, & mask, & address);
    }
#line 592
    if (! tmp___0) {
#line 593
      return (0);
    }
  }
  {
#line 596
  msg->command = htons((uint16_t )3);
#line 597
  tmp___1 = ntohl((uint32_t )n_good_samples);
#line 597
  msg->data.burst.n_good_samples = (int32_t )tmp___1;
#line 598
  tmp___2 = ntohl((uint32_t )n_total_samples);
#line 598
  msg->data.burst.n_total_samples = (int32_t )tmp___2;
#line 600
  UTI_IPHostToNetwork(& mask, & msg->data.burst.mask);
#line 601
  UTI_IPHostToNetwork(& address, & msg->data.burst.address);
  }
#line 603
  return (1);
}
}
#line 608 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static int process_cmd_local(CMD_Request *msg , char const   *line___0 ) 
{ 
  char const   *p ;
  int stratum ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 614
  p = line___0;
#line 616
  if (! *p) {
#line 617
    return (0);
  } else {
    {
#line 618
    tmp___4 = strcmp(p, "off");
    }
#line 618
    if (tmp___4) {
      {
#line 621
      tmp___3 = sscanf((char const   */* __restrict  */)p, (char const   */* __restrict  */)"stratum%d",
                       & stratum);
      }
#line 621
      if (tmp___3 == 1) {
        {
#line 622
        tmp___1 = htonl((uint32_t )1);
#line 622
        msg->data.local.on_off = (int32_t )tmp___1;
#line 623
        tmp___2 = htonl((uint32_t )stratum);
#line 623
        msg->data.local.stratum = (int32_t )tmp___2;
        }
      } else {
        {
#line 625
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid syntax for local command\n");
        }
#line 626
        return (0);
      }
    } else {
      {
#line 619
      tmp = htonl((uint32_t )0);
#line 619
      msg->data.local.on_off = (int32_t )tmp;
#line 620
      tmp___0 = htonl((uint32_t )0);
#line 620
      msg->data.local.stratum = (int32_t )tmp___0;
      }
    }
  }
  {
#line 629
  msg->command = htons((uint16_t )12);
  }
#line 630
  return (1);
}
}
#line 635 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static int process_cmd_manual(CMD_Request *msg , char const   *line___0 ) 
{ 
  char const   *p ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 640
  p = line___0;
#line 642
  if (! *p) {
#line 643
    return (0);
  } else {
    {
#line 644
    tmp___4 = strcmp(p, "off");
    }
#line 644
    if (tmp___4) {
      {
#line 646
      tmp___3 = strcmp(p, "on");
      }
#line 646
      if (tmp___3) {
        {
#line 648
        tmp___2 = strcmp(p, "reset");
        }
#line 648
        if (tmp___2) {
#line 651
          return (0);
        } else {
          {
#line 649
          tmp___1 = htonl((uint32_t )2);
#line 649
          msg->data.manual.option = (int32_t )tmp___1;
          }
        }
      } else {
        {
#line 647
        tmp___0 = htonl((uint32_t )1);
#line 647
        msg->data.manual.option = (int32_t )tmp___0;
        }
      }
    } else {
      {
#line 645
      tmp = htonl((uint32_t )0);
#line 645
      msg->data.manual.option = (int32_t )tmp;
      }
    }
  }
  {
#line 653
  msg->command = htons((uint16_t )13);
  }
#line 655
  return (1);
}
}
#line 660 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static int parse_allow_deny___0(CMD_Request *msg , char *line___0 ) 
{ 
  unsigned long a ;
  unsigned long b ;
  unsigned long c ;
  unsigned long d ;
  unsigned long n ;
  IPAddr ip ;
  char *p ;
  uint32_t tmp ;
  char *slashpos ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  DNS_Status tmp___2 ;
  uint32_t tmp___3 ;
  uint32_t tmp___4 ;
  uint32_t tmp___5 ;
  uint32_t tmp___6 ;
  uint32_t tmp___7 ;
  uint32_t tmp___8 ;
  int specified_subnet_bits ;
  int n___0 ;
  uint32_t tmp___9 ;
  uint32_t tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
#line 667
  p = line___0;
#line 668
  if (! *p) {
    {
#line 670
    ip.family = (uint16_t )0;
#line 671
    UTI_IPHostToNetwork(& ip, & msg->data.allow_deny.ip);
#line 672
    tmp = htonl((uint32_t )0);
#line 672
    msg->data.allow_deny.subnet_bits = (int32_t )tmp;
    }
  } else {
    {
#line 675
    slashpos = strchr((char const   *)p, '/');
    }
#line 676
    if (slashpos) {
#line 676
      *slashpos = (char)0;
    }
    {
#line 678
    n = 0UL;
#line 679
    tmp___11 = UTI_StringToIP((char const   *)p, & ip);
    }
#line 679
    if (tmp___11) {
      _L: /* CIL Label */ 
#line 695
      if (n == 0UL) {
#line 696
        if ((int )ip.family == 2) {
          {
#line 697
          tmp___3 = htonl((uint32_t )128);
#line 697
          msg->data.allow_deny.subnet_bits = (int32_t )tmp___3;
          }
        } else {
          {
#line 699
          tmp___4 = htonl((uint32_t )32);
#line 699
          msg->data.allow_deny.subnet_bits = (int32_t )tmp___4;
          }
        }
      } else {
#line 701
        ip.family = (uint16_t )1;
#line 703
        a &= 255UL;
#line 704
        b &= 255UL;
#line 705
        c &= 255UL;
#line 706
        d &= 255UL;
        {
#line 709
        if (n == 1UL) {
#line 709
          goto case_1;
        }
#line 713
        if (n == 2UL) {
#line 713
          goto case_2;
        }
#line 717
        if (n == 3UL) {
#line 717
          goto case_3;
        }
#line 721
        if (n == 4UL) {
#line 721
          goto case_4;
        }
#line 725
        goto switch_default;
        case_1: /* CIL Label */ 
        {
#line 710
        ip.addr.in4 = htonl((uint32_t )(a << 24));
#line 711
        tmp___5 = htonl((uint32_t )8);
#line 711
        msg->data.allow_deny.subnet_bits = (int32_t )tmp___5;
        }
#line 712
        goto switch_break;
        case_2: /* CIL Label */ 
        {
#line 714
        ip.addr.in4 = htonl((uint32_t )((a << 24) | (b << 16)));
#line 715
        tmp___6 = htonl((uint32_t )16);
#line 715
        msg->data.allow_deny.subnet_bits = (int32_t )tmp___6;
        }
#line 716
        goto switch_break;
        case_3: /* CIL Label */ 
        {
#line 718
        ip.addr.in4 = htonl((uint32_t )(((a << 24) | (b << 16)) | (c << 8)));
#line 719
        tmp___7 = htonl((uint32_t )24);
#line 719
        msg->data.allow_deny.subnet_bits = (int32_t )tmp___7;
        }
#line 720
        goto switch_break;
        case_4: /* CIL Label */ 
        {
#line 722
        ip.addr.in4 = htonl((uint32_t )((((a << 24) | (b << 16)) | (c << 8)) | d));
#line 723
        tmp___8 = htonl((uint32_t )32);
#line 723
        msg->data.allow_deny.subnet_bits = (int32_t )tmp___8;
        }
#line 724
        goto switch_break;
        switch_default: /* CIL Label */ 
        {
#line 726
        __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c",
                      726U, "parse_allow_deny");
        }
        switch_break: /* CIL Label */ ;
        }
      }
      {
#line 730
      UTI_IPHostToNetwork(& ip, & msg->data.allow_deny.ip);
      }
#line 732
      if (slashpos) {
        {
#line 734
        n___0 = sscanf((char const   */* __restrict  */)(slashpos + 1), (char const   */* __restrict  */)"%d",
                       & specified_subnet_bits);
        }
#line 735
        if (n___0 == 1) {
          {
#line 736
          tmp___9 = htonl((uint32_t )specified_subnet_bits);
#line 736
          msg->data.allow_deny.subnet_bits = (int32_t )tmp___9;
          }
        } else {
          {
#line 738
          tmp___10 = ntohl((uint32_t )msg->data.allow_deny.subnet_bits);
#line 738
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: badly formatted subnet size, using %ld\n",
                  (long )tmp___10);
          }
        }
      }
    } else {
      {
#line 679
      tmp___12 = sscanf((char const   */* __restrict  */)p, (char const   */* __restrict  */)"%lu.%lu.%lu.%lu",
                        & a, & b, & c, & d);
#line 679
      n = (unsigned long )tmp___12;
      }
#line 679
      if (n == 0UL) {
        {
#line 683
        tmp___2 = DNS_Name2IPAddress((char const   *)p, & ip);
        }
#line 683
        if ((unsigned int )tmp___2 != 0U) {
          {
#line 684
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not read address\n");
          }
#line 685
          return (0);
        } else {
          {
#line 687
          UTI_IPHostToNetwork(& ip, & msg->data.allow_deny.ip);
          }
#line 688
          if ((int )ip.family == 2) {
            {
#line 689
            tmp___0 = htonl((uint32_t )128);
#line 689
            msg->data.allow_deny.subnet_bits = (int32_t )tmp___0;
            }
          } else {
            {
#line 691
            tmp___1 = htonl((uint32_t )32);
#line 691
            msg->data.allow_deny.subnet_bits = (int32_t )tmp___1;
            }
          }
        }
      } else {
#line 679
        goto _L;
      }
    }
  }
#line 743
  return (1);
}
}
#line 748 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static int process_cmd_allow(CMD_Request *msg , char *line___0 ) 
{ 
  int status___0 ;

  {
  {
#line 752
  msg->command = htons((uint16_t )17);
#line 753
  status___0 = parse_allow_deny___0(msg, line___0);
  }
#line 754
  return (status___0);
}
}
#line 759 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static int process_cmd_allowall(CMD_Request *msg , char *line___0 ) 
{ 
  int status___0 ;

  {
  {
#line 763
  msg->command = htons((uint16_t )18);
#line 764
  status___0 = parse_allow_deny___0(msg, line___0);
  }
#line 765
  return (status___0);
}
}
#line 770 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static int process_cmd_deny(CMD_Request *msg , char *line___0 ) 
{ 
  int status___0 ;

  {
  {
#line 774
  msg->command = htons((uint16_t )19);
#line 775
  status___0 = parse_allow_deny___0(msg, line___0);
  }
#line 776
  return (status___0);
}
}
#line 781 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static int process_cmd_denyall(CMD_Request *msg , char *line___0 ) 
{ 
  int status___0 ;

  {
  {
#line 785
  msg->command = htons((uint16_t )20);
#line 786
  status___0 = parse_allow_deny___0(msg, line___0);
  }
#line 787
  return (status___0);
}
}
#line 792 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static int process_cmd_cmdallow(CMD_Request *msg , char *line___0 ) 
{ 
  int status___0 ;

  {
  {
#line 796
  msg->command = htons((uint16_t )21);
#line 797
  status___0 = parse_allow_deny___0(msg, line___0);
  }
#line 798
  return (status___0);
}
}
#line 803 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static int process_cmd_cmdallowall(CMD_Request *msg , char *line___0 ) 
{ 
  int status___0 ;

  {
  {
#line 807
  msg->command = htons((uint16_t )22);
#line 808
  status___0 = parse_allow_deny___0(msg, line___0);
  }
#line 809
  return (status___0);
}
}
#line 814 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static int process_cmd_cmddeny(CMD_Request *msg , char *line___0 ) 
{ 
  int status___0 ;

  {
  {
#line 818
  msg->command = htons((uint16_t )23);
#line 819
  status___0 = parse_allow_deny___0(msg, line___0);
  }
#line 820
  return (status___0);
}
}
#line 825 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static int process_cmd_cmddenyall(CMD_Request *msg , char *line___0 ) 
{ 
  int status___0 ;

  {
  {
#line 829
  msg->command = htons((uint16_t )24);
#line 830
  status___0 = parse_allow_deny___0(msg, line___0);
  }
#line 831
  return (status___0);
}
}
#line 836 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static int accheck_getaddr(char *line___0 , IPAddr *addr ) 
{ 
  unsigned long a ;
  unsigned long b ;
  unsigned long c ;
  unsigned long d ;
  IPAddr ip ;
  char *p ;
  DNS_Status tmp ;
  int tmp___0 ;

  {
#line 842
  p = line___0;
#line 843
  if (! *p) {
#line 844
    return (0);
  } else {
    {
#line 846
    tmp___0 = sscanf((char const   */* __restrict  */)p, (char const   */* __restrict  */)"%lu.%lu.%lu.%lu",
                     & a, & b, & c, & d);
    }
#line 846
    if (tmp___0 == 4) {
#line 847
      addr->family = (uint16_t )1;
#line 848
      addr->addr.in4 = (uint32_t )((((a << 24) | (b << 16)) | (c << 8)) | d);
#line 849
      return (1);
    } else {
      {
#line 851
      tmp = DNS_Name2IPAddress((char const   *)p, & ip);
      }
#line 851
      if ((unsigned int )tmp != 0U) {
#line 852
        return (0);
      } else {
#line 854
        *addr = ip;
#line 855
        return (1);
      }
    }
  }
}
}
#line 863 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static int process_cmd_accheck(CMD_Request *msg , char *line___0 ) 
{ 
  IPAddr ip ;
  int tmp ;

  {
  {
#line 867
  msg->command = htons((uint16_t )25);
#line 868
  tmp = accheck_getaddr(line___0, & ip);
  }
#line 868
  if (tmp) {
    {
#line 869
    UTI_IPHostToNetwork(& ip, & msg->data.ac_check.ip);
    }
#line 870
    return (1);
  } else {
    {
#line 872
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not read address\n");
    }
#line 873
    return (0);
  }
}
}
#line 879 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static int process_cmd_cmdaccheck(CMD_Request *msg , char *line___0 ) 
{ 
  IPAddr ip ;
  int tmp ;

  {
  {
#line 883
  msg->command = htons((uint16_t )26);
#line 884
  tmp = accheck_getaddr(line___0, & ip);
  }
#line 884
  if (tmp) {
    {
#line 885
    UTI_IPHostToNetwork(& ip, & msg->data.ac_check.ip);
    }
#line 886
    return (1);
  } else {
    {
#line 888
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not read address\n");
    }
#line 889
    return (0);
  }
}
}
#line 895 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static void process_cmd_dfreq(CMD_Request *msg , char *line___0 ) 
{ 
  double dfreq ;
  int tmp ;

  {
  {
#line 899
  msg->command = htons((uint16_t )31);
#line 900
  tmp = sscanf((char const   */* __restrict  */)line___0, (char const   */* __restrict  */)"%lf",
               & dfreq);
  }
#line 900
  if (tmp == 1) {
    {
#line 901
    msg->data.dfreq.dfreq = UTI_FloatHostToNetwork(dfreq);
    }
  } else {
    {
#line 903
    msg->data.dfreq.dfreq = UTI_FloatHostToNetwork(0.0);
    }
  }
#line 905
  return;
}
}
#line 909 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static void cvt_to_sec_usec(double x , long *sec , long *usec ) 
{ 
  long s ;
  long us ;

  {
#line 912
  s = (long )x;
#line 913
  us = (long )(0.5 + 1.0e6 * (x - (double )s));
  {
#line 914
  while (1) {
    while_continue: /* CIL Label */ ;
#line 914
    if (! (us >= 1000000L)) {
#line 914
      goto while_break;
    }
#line 915
    us -= 1000000L;
#line 916
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 918
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 918
    if (! (us < 0L)) {
#line 918
      goto while_break___0;
    }
#line 919
    us += 1000000L;
#line 920
    s --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 923
  *sec = s;
#line 924
  *usec = us;
#line 925
  return;
}
}
#line 929 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static void process_cmd_doffset(CMD_Request *msg , char *line___0 ) 
{ 
  double doffset ;
  long sec ;
  long usec ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  int tmp___3 ;

  {
  {
#line 934
  msg->command = htons((uint16_t )32);
#line 935
  tmp___3 = sscanf((char const   */* __restrict  */)line___0, (char const   */* __restrict  */)"%lf",
                   & doffset);
  }
#line 935
  if (tmp___3 == 1) {
    {
#line 936
    cvt_to_sec_usec(doffset, & sec, & usec);
#line 937
    tmp = htonl((uint32_t )sec);
#line 937
    msg->data.doffset.sec = (int32_t )tmp;
#line 938
    tmp___0 = htonl((uint32_t )usec);
#line 938
    msg->data.doffset.usec = (int32_t )tmp___0;
    }
  } else {
    {
#line 940
    tmp___1 = htonl((uint32_t )0);
#line 940
    msg->data.doffset.sec = (int32_t )tmp___1;
#line 941
    tmp___2 = htonl((uint32_t )0);
#line 941
    msg->data.doffset.usec = (int32_t )tmp___2;
    }
  }
#line 943
  return;
}
}
#line 947 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static int process_cmd_add_server_or_peer(CMD_Request *msg , char *line___0 ) 
{ 
  CPS_NTP_Source data ;
  CPS_Status status___0 ;
  IPAddr ip_addr ;
  int result ;
  DNS_Status tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
#line 953
  result = 0;
#line 955
  status___0 = CPS_ParseNTPSourceAdd(line___0, & data);
  }
  {
#line 957
  if ((unsigned int )status___0 == 0U) {
#line 957
    goto case_0;
  }
#line 997
  if ((unsigned int )status___0 == 1U) {
#line 997
    goto case_1;
  }
#line 1000
  if ((unsigned int )status___0 == 2U) {
#line 1000
    goto case_2;
  }
#line 1003
  if ((unsigned int )status___0 == 3U) {
#line 1003
    goto case_3;
  }
#line 1006
  if ((unsigned int )status___0 == 4U) {
#line 1006
    goto case_4;
  }
#line 1009
  if ((unsigned int )status___0 == 5U) {
#line 1009
    goto case_5;
  }
#line 1012
  if ((unsigned int )status___0 == 6U) {
#line 1012
    goto case_6;
  }
#line 1015
  if ((unsigned int )status___0 == 7U) {
#line 1015
    goto case_7;
  }
#line 1018
  if ((unsigned int )status___0 == 8U) {
#line 1018
    goto case_8;
  }
#line 1021
  if ((unsigned int )status___0 == 9U) {
#line 1021
    goto case_9;
  }
#line 1024
  if ((unsigned int )status___0 == 10U) {
#line 1024
    goto case_10;
  }
#line 1027
  if ((unsigned int )status___0 == 11U) {
#line 1027
    goto case_11;
  }
#line 1030
  if ((unsigned int )status___0 == 12U) {
#line 1030
    goto case_12;
  }
#line 956
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 958
  tmp = DNS_Name2IPAddress((char const   *)data.name, & ip_addr);
  }
#line 958
  if ((unsigned int )tmp != 0U) {
    {
#line 959
    free((void *)data.name);
#line 960
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid host/IP address\n");
    }
#line 961
    goto switch_break;
  }
  {
#line 963
  free((void *)data.name);
  }
#line 965
  if (data.params.min_stratum != 0) {
    {
#line 966
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Option minstratum not supported\n");
    }
#line 967
    goto switch_break;
  }
#line 970
  if (data.params.poll_target != 6) {
    {
#line 971
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Option polltarget not supported\n");
    }
#line 972
    goto switch_break;
  }
#line 975
  if (data.params.max_delay_dev_ratio != 10.0) {
    {
#line 976
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Option maxdelaydevratio not supported\n");
    }
#line 977
    goto switch_break;
  }
  {
#line 980
  msg->data.ntp_source.port = htonl((uint32_t )((unsigned long )data.port));
#line 981
  UTI_IPHostToNetwork(& ip_addr, & msg->data.ntp_source.ip_addr);
#line 982
  tmp___0 = htonl((uint32_t )data.params.minpoll);
#line 982
  msg->data.ntp_source.minpoll = (int32_t )tmp___0;
#line 983
  tmp___1 = htonl((uint32_t )data.params.maxpoll);
#line 983
  msg->data.ntp_source.maxpoll = (int32_t )tmp___1;
#line 984
  tmp___2 = htonl((uint32_t )data.params.presend_minpoll);
#line 984
  msg->data.ntp_source.presend_minpoll = (int32_t )tmp___2;
#line 985
  msg->data.ntp_source.authkey = htonl((uint32_t )data.params.authkey);
#line 986
  msg->data.ntp_source.max_delay = UTI_FloatHostToNetwork(data.params.max_delay);
#line 987
  msg->data.ntp_source.max_delay_ratio = UTI_FloatHostToNetwork(data.params.max_delay_ratio);
  }
#line 988
  if (data.params.online) {
#line 988
    tmp___3 = 1;
  } else {
#line 988
    tmp___3 = 0;
  }
#line 988
  if (data.params.auto_offline) {
#line 988
    tmp___4 = 2;
  } else {
#line 988
    tmp___4 = 0;
  }
#line 988
  if (data.params.iburst) {
#line 988
    tmp___5 = 4;
  } else {
#line 988
    tmp___5 = 0;
  }
#line 988
  if ((unsigned int )data.params.sel_option == 2U) {
#line 988
    tmp___6 = 8;
  } else {
#line 988
    tmp___6 = 0;
  }
#line 988
  if ((unsigned int )data.params.sel_option == 1U) {
#line 988
    tmp___7 = 16;
  } else {
#line 988
    tmp___7 = 0;
  }
  {
#line 988
  msg->data.ntp_source.flags = htonl((uint32_t )((((tmp___3 | tmp___4) | tmp___5) | tmp___6) | tmp___7));
#line 994
  result = 1;
  }
#line 996
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 998
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unrecognized subcommand\n");
  }
#line 999
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1001
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid host/IP address\n");
  }
#line 1002
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 1004
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unreadable port number\n");
  }
#line 1005
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 1007
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unreadable minpoll value\n");
  }
#line 1008
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 1010
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unreadable maxpoll value\n");
  }
#line 1011
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 1013
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unreadable presend value\n");
  }
#line 1014
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 1016
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unreadable max delay dev ratio value\n");
  }
#line 1017
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 1019
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unreadable max delay ratio value\n");
  }
#line 1020
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 1022
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unreadable max delay value\n");
  }
#line 1023
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 1025
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unreadable key value\n");
  }
#line 1026
  goto switch_break;
  case_11: /* CIL Label */ 
  {
#line 1028
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unreadable minstratum value\n");
  }
#line 1029
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 1031
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unreadable polltarget value\n");
  }
#line 1032
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1035
  return (result);
}
}
#line 1040 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static int process_cmd_add_server(CMD_Request *msg , char *line___0 ) 
{ 
  int tmp ;

  {
  {
#line 1043
  msg->command = htons((uint16_t )27);
#line 1044
  tmp = process_cmd_add_server_or_peer(msg, line___0);
  }
#line 1044
  return (tmp);
}
}
#line 1049 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static int process_cmd_add_peer(CMD_Request *msg , char *line___0 ) 
{ 
  int tmp ;

  {
  {
#line 1052
  msg->command = htons((uint16_t )28);
#line 1053
  tmp = process_cmd_add_server_or_peer(msg, line___0);
  }
#line 1053
  return (tmp);
}
}
#line 1058 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static int process_cmd_delete(CMD_Request *msg , char *line___0 ) 
{ 
  char *hostname ;
  int ok ;
  IPAddr address ;
  DNS_Status tmp ;

  {
  {
#line 1062
  ok = 0;
#line 1065
  msg->command = htons((uint16_t )29);
#line 1066
  hostname = line___0;
#line 1067
  CPS_SplitWord(line___0);
  }
#line 1069
  if (! *hostname) {
    {
#line 1070
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid syntax for address\n");
#line 1071
    ok = 0;
    }
  } else {
    {
#line 1073
    tmp = DNS_Name2IPAddress((char const   *)hostname, & address);
    }
#line 1073
    if ((unsigned int )tmp != 0U) {
      {
#line 1074
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not get address for hostname\n");
#line 1075
      ok = 0;
      }
    } else {
      {
#line 1077
      UTI_IPHostToNetwork(& address, & msg->data.del_source.ip_addr);
#line 1078
      ok = 1;
      }
    }
  }
#line 1082
  return (ok);
}
}
#line 1088 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static char *password  =    (char *)((void *)0);
#line 1089 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static int password_length  ;
#line 1090 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static int auth_hash_id  ;
#line 1094 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static int process_cmd_password(CMD_Request *msg , char *line___0 ) 
{ 
  char *p ;
  struct timeval now ;
  int i ;
  int len ;
  size_t tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 1102
  if (password) {
#line 1103
    i = 0;
    {
#line 1103
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1103
      if (! (i < password_length)) {
#line 1103
        goto while_break;
      }
#line 1104
      *(password + i) = (char)0;
#line 1103
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1105
    free((void *)password);
#line 1106
    password = (char *)((void *)0);
    }
  }
#line 1109
  p = line___0;
#line 1111
  if (! *p) {
    {
#line 1113
    p = getpass("Password: ");
    }
  }
#line 1116
  if (! *p) {
#line 1117
    return (0);
  }
  {
#line 1119
  tmp = strlen((char const   *)p);
#line 1119
  len = (int )tmp;
#line 1120
  password_length = UTI_DecodePasswordFromText(p);
  }
#line 1122
  if (password_length > 0) {
    {
#line 1123
    tmp___0 = malloc((size_t )password_length);
#line 1123
    password = (char *)tmp___0;
#line 1124
    memcpy((void */* __restrict  */)password, (void const   */* __restrict  */)p,
           (size_t )password_length);
    }
  }
#line 1128
  i = 0;
  {
#line 1128
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1128
    if (! (i < len)) {
#line 1128
      goto while_break___0;
    }
#line 1129
    *(p + i) = (char)0;
#line 1128
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1131
  if (password_length <= 0) {
    {
#line 1132
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not decode password\n");
    }
#line 1133
    return (0);
  }
  {
#line 1136
  tmp___1 = gettimeofday((struct timeval */* __restrict  */)(& now), (__timezone_ptr_t )((void *)0));
  }
#line 1136
  if (tmp___1 < 0) {
    {
#line 1137
    printf((char const   */* __restrict  */)"500 - Could not read time of day\n");
    }
#line 1138
    return (0);
  } else {
    {
#line 1140
    msg->command = htons((uint16_t )10);
#line 1141
    UTI_TimevalHostToNetwork(& now, & msg->data.logon.ts);
    }
#line 1142
    return (1);
  }
}
}
#line 1148 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static int generate_auth(CMD_Request *msg ) 
{ 
  int data_len ;
  int tmp ;

  {
  {
#line 1153
  data_len = PKL_CommandLength(msg);
  }
#line 1155
  if (! (auth_hash_id >= 0)) {
    {
#line 1155
    __assert_fail("auth_hash_id >= 0", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c",
                  1155U, "generate_auth");
    }
  }
  {
#line 1157
  tmp = UTI_GenerateNTPAuth(auth_hash_id, (unsigned char const   *)((unsigned char *)password),
                            password_length, (unsigned char const   *)((unsigned char *)msg),
                            data_len, (unsigned char *)msg + data_len, (int )sizeof(msg->auth));
  }
#line 1157
  return (tmp);
}
}
#line 1163 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static int check_reply_auth(CMD_Reply *msg , int len ) 
{ 
  int data_len ;
  int tmp ;

  {
  {
#line 1168
  data_len = PKL_ReplyLength(msg);
  }
#line 1170
  if (! (auth_hash_id >= 0)) {
    {
#line 1170
    __assert_fail("auth_hash_id >= 0", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c",
                  1170U, "check_reply_auth");
    }
  }
  {
#line 1172
  tmp = UTI_CheckNTPAuth(auth_hash_id, (unsigned char const   *)((unsigned char *)password),
                         password_length, (unsigned char const   *)((unsigned char *)msg),
                         data_len, (unsigned char const   *)((unsigned char *)msg + data_len),
                         len - data_len);
  }
#line 1172
  return (tmp);
}
}
#line 1179 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static void give_help(void) 
{ 


  {
  {
#line 1182
  printf((char const   */* __restrict  */)"Commands:\n");
#line 1183
  printf((char const   */* __restrict  */)"accheck <address> : Check whether NTP access is allowed to <address>\n");
#line 1184
  printf((char const   */* __restrict  */)"activity : Check how many NTP sources are online/offline\n");
#line 1185
  printf((char const   */* __restrict  */)"add peer <address> ... : Add a new NTP peer\n");
#line 1186
  printf((char const   */* __restrict  */)"add server <address> ... : Add a new NTP server\n");
#line 1187
  printf((char const   */* __restrict  */)"allow [<subnet-addr>] : Allow NTP access to that subnet as a default\n");
#line 1188
  printf((char const   */* __restrict  */)"allow all [<subnet-addr>] : Allow NTP access to that subnet and all children\n");
#line 1189
  printf((char const   */* __restrict  */)"burst <n-good>/<n-max> [<mask>/<masked-address>] : Start a rapid set of measurements\n");
#line 1190
  printf((char const   */* __restrict  */)"clients : Report on clients that have accessed the server\n");
#line 1191
  printf((char const   */* __restrict  */)"cmdaccheck <address> : Check whether command access is allowed to <address>\n");
#line 1192
  printf((char const   */* __restrict  */)"cmdallow [<subnet-addr>] : Allow command access to that subnet as a default\n");
#line 1193
  printf((char const   */* __restrict  */)"cmdallow all [<subnet-addr>] : Allow command access to that subnet and all children\n");
#line 1194
  printf((char const   */* __restrict  */)"cmddeny [<subnet-addr>] : Deny command access to that subnet as a default\n");
#line 1195
  printf((char const   */* __restrict  */)"cmddeny all [<subnet-addr>] : Deny command access to that subnet and all children\n");
#line 1196
  printf((char const   */* __restrict  */)"cyclelogs : Close and re-open logs files\n");
#line 1197
  printf((char const   */* __restrict  */)"delete <address> : Remove an NTP server or peer\n");
#line 1198
  printf((char const   */* __restrict  */)"deny [<subnet-addr>] : Deny NTP access to that subnet as a default\n");
#line 1199
  printf((char const   */* __restrict  */)"deny all [<subnet-addr>] : Deny NTP access to that subnet and all children\n");
#line 1200
  printf((char const   */* __restrict  */)"dump : Dump all measurements to save files\n");
#line 1201
  printf((char const   */* __restrict  */)"local off : Disable server capability for unsynchronised clock\n");
#line 1202
  printf((char const   */* __restrict  */)"local stratum <stratum> : Enable server capability for unsynchronised clock\n");
#line 1203
  printf((char const   */* __restrict  */)"makestep : Jump the time to remove any correction being slewed\n");
#line 1204
  printf((char const   */* __restrict  */)"manual off|on|reset : Disable/enable/reset settime command and statistics\n");
#line 1205
  printf((char const   */* __restrict  */)"manual list : Show previous settime entries\n");
#line 1206
  printf((char const   */* __restrict  */)"maxdelay <address> <new-max-delay> : Modify maximum round-trip valid sample delay for source\n");
#line 1207
  printf((char const   */* __restrict  */)"maxdelayratio <address> <new-max-ratio> : Modify max round-trip delay ratio for source\n");
#line 1208
  printf((char const   */* __restrict  */)"maxdelaydevratio <address> <new-max-ratio> : Modify max round-trip delay dev ratio for source\n");
#line 1209
  printf((char const   */* __restrict  */)"maxpoll <address> <new-maxpoll> : Modify maximum polling interval of source\n");
#line 1210
  printf((char const   */* __restrict  */)"maxupdateskew <new-max-skew> : Modify maximum skew for a clock frequency update to be made\n");
#line 1211
  printf((char const   */* __restrict  */)"minpoll <address> <new-minpoll> : Modify minimum polling interval of source\n");
#line 1212
  printf((char const   */* __restrict  */)"minstratum <address> <new-min-stratum> : Modify minimum stratum of source\n");
#line 1213
  printf((char const   */* __restrict  */)"offline [<mask>/<masked-address>] : Set sources in subnet to offline status\n");
#line 1214
  printf((char const   */* __restrict  */)"online [<mask>/<masked-address>] : Set sources in subnet to online status\n");
#line 1215
  printf((char const   */* __restrict  */)"password [<new-password>] : Set command authentication password\n");
#line 1216
  printf((char const   */* __restrict  */)"polltarget <address> <new-poll-target> : Modify poll target of source\n");
#line 1217
  printf((char const   */* __restrict  */)"reselect : Reselect synchronisation source\n");
#line 1218
  printf((char const   */* __restrict  */)"rtcdata : Print current RTC performance parameters\n");
#line 1219
  printf((char const   */* __restrict  */)"settime <date/time (e.g. Nov 21, 1997 16:30:05 or 16:30:05)> : Manually set the daemon time\n");
#line 1220
  printf((char const   */* __restrict  */)"sources [-v] : Display information about current sources\n");
#line 1221
  printf((char const   */* __restrict  */)"sourcestats [-v] : Display estimation information about current sources\n");
#line 1222
  printf((char const   */* __restrict  */)"tracking : Display system time information\n");
#line 1223
  printf((char const   */* __restrict  */)"trimrtc : Correct RTC relative to system clock\n");
#line 1224
  printf((char const   */* __restrict  */)"waitsync [max-tries [max-correction [max-skew]]] : Wait until synchronised\n");
#line 1225
  printf((char const   */* __restrict  */)"writertc : Save RTC parameters to file\n");
#line 1226
  printf((char const   */* __restrict  */)"\n");
#line 1227
  printf((char const   */* __restrict  */)"authhash <name>: Set command authentication hash function\n");
#line 1228
  printf((char const   */* __restrict  */)"dns -n|+n : Disable/enable resolving IP addresses to hostnames\n");
#line 1229
  printf((char const   */* __restrict  */)"dns -4|-6|-46 : Resolve hostnames only to IPv4/IPv6/both addresses\n");
#line 1230
  printf((char const   */* __restrict  */)"timeout <milliseconds> : Set initial response timeout\n");
#line 1231
  printf((char const   */* __restrict  */)"retries <n> : Set maximum number of retries\n");
#line 1232
  printf((char const   */* __restrict  */)"exit|quit : Leave the program\n");
#line 1233
  printf((char const   */* __restrict  */)"help : Generate this help\n");
#line 1234
  printf((char const   */* __restrict  */)"\n");
  }
#line 1235
  return;
}
}
#line 1239 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static unsigned long sequence  =    0UL;
#line 1240 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static unsigned long utoken___0  =    0UL;
#line 1241 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static unsigned long token  =    0UL;
#line 1243 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static int max_retries  =    2;
#line 1244 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static int initial_timeout  =    1000;
#line 1251 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static int submit_request(CMD_Request *request , CMD_Reply *reply , int *reply_auth_ok ) 
{ 
  unsigned long tx_sequence ;
  socklen_t where_from_len ;
  union sockaddr_in46 where_from ;
  int bad_length ;
  int bad_sender ;
  int bad_sequence ;
  int bad_header ;
  int select_status ;
  int recvfrom_status ;
  int read_length ;
  int expected_length ;
  int command_length ;
  int auth_length ;
  struct timeval tv ;
  int timeout ;
  int n_attempts ;
  fd_set rdfd ;
  fd_set wrfd ;
  fd_set exfd ;
  unsigned long tmp ;
  uint16_t tmp___0 ;
  ssize_t tmp___1 ;
  int __d0 ;
  int __d1 ;
  int __d0___0 ;
  int __d1___0 ;
  int __d0___1 ;
  int __d1___1 ;
  ssize_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  uint32_t tmp___6 ;
  uint16_t tmp___7 ;
  int tmp___8 ;
  uint32_t tmp___9 ;
  uint32_t tmp___10 ;
  uint32_t tmp___11 ;

  {
  {
#line 1269
  request->version = (uint8_t )5;
#line 1270
  request->pkt_type = (uint8_t )1;
#line 1271
  request->res1 = (uint8_t )0;
#line 1272
  request->res2 = (uint8_t )0;
#line 1273
  tmp = sequence;
#line 1273
  sequence ++;
#line 1273
  tx_sequence = tmp;
#line 1274
  request->sequence = htonl((uint32_t )tx_sequence);
#line 1275
  request->attempt = (uint16_t )0;
#line 1276
  request->utoken = htonl((uint32_t )utoken___0);
#line 1277
  request->token = htonl((uint32_t )token);
#line 1279
  timeout = initial_timeout;
#line 1281
  n_attempts = 0;
  }
  {
#line 1283
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1286
    if (password) {
#line 1287
      if (! utoken___0) {
        {
#line 1290
        request->utoken = htonl((uint32_t )269488144);
        }
      } else {
        {
#line 1287
        tmp___0 = htons((uint16_t )10);
        }
#line 1287
        if ((int )request->command == (int )tmp___0) {
          {
#line 1290
          request->utoken = htonl((uint32_t )269488144);
          }
        }
      }
      {
#line 1292
      auth_length = generate_auth(request);
      }
    } else {
#line 1294
      auth_length = 0;
    }
    {
#line 1297
    command_length = PKL_CommandLength(request);
    }
#line 1298
    if (! (command_length > 0)) {
      {
#line 1298
      __assert_fail("command_length > 0", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c",
                    1298U, "submit_request");
      }
    }
#line 1302
    if (! auth_length) {
      {
#line 1303
      memset((void *)((char *)request + command_length), 0, (size_t )16);
#line 1304
      auth_length = 16;
      }
    }
    {
#line 1311
    tmp___1 = sendto(sock_fd, (void const   *)((void *)request), (size_t )(command_length + auth_length),
                     0, (struct sockaddr  const  */* __restrict  */)(& his_addr.u),
                     his_addr_len);
    }
#line 1311
    if (tmp___1 < 0L) {
#line 1318
      return (0);
    }
#line 1322
    request->attempt = (uint16_t )((int )request->attempt + 1);
#line 1324
    tv.tv_sec = (__time_t )(timeout / 1000);
#line 1325
    tv.tv_usec = (__suseconds_t )((timeout % 1000) * 1000);
#line 1326
    timeout *= 2;
    {
#line 1328
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1328
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& rdfd.fds_bits[0]): "memory");
#line 1328
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1329
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1329
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0___0), "=D" (__d1___0): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& wrfd.fds_bits[0]): "memory");
#line 1329
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1330
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1330
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0___1), "=D" (__d1___1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& exfd.fds_bits[0]): "memory");
#line 1330
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 1332
    rdfd.fds_bits[sock_fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << sock_fd % (8 * (int )sizeof(__fd_mask ));
#line 1334
    select_status = select(sock_fd + 1, (fd_set */* __restrict  */)(& rdfd), (fd_set */* __restrict  */)(& wrfd),
                           (fd_set */* __restrict  */)(& exfd), (struct timeval */* __restrict  */)(& tv));
    }
#line 1336
    if (! (select_status < 0)) {
#line 1340
      if (select_status == 0) {
#line 1342
        n_attempts ++;
#line 1343
        if (n_attempts > max_retries) {
#line 1344
          return (0);
        }
#line 1348
        goto __Cont;
      } else {
        {
#line 1352
        where_from_len = (socklen_t )sizeof(where_from);
#line 1353
        tmp___2 = recvfrom(sock_fd, (void */* __restrict  */)((void *)reply), sizeof(CMD_Reply ),
                           0, (struct sockaddr */* __restrict  */)(& where_from.u),
                           (socklen_t */* __restrict  */)(& where_from_len));
#line 1353
        recvfrom_status = (int )tmp___2;
        }
#line 1361
        if (recvfrom_status < 0) {
#line 1365
          n_attempts ++;
#line 1366
          if (n_attempts > max_retries) {
#line 1367
            return (0);
          }
        } else {
          {
#line 1371
          read_length = recvfrom_status;
#line 1372
          expected_length = PKL_ReplyLength(reply);
          }
#line 1374
          if (read_length < expected_length) {
#line 1374
            tmp___3 = 1;
          } else
#line 1374
          if ((unsigned long )expected_length < (unsigned long )(& ((CMD_Reply *)0)->data)) {
#line 1374
            tmp___3 = 1;
          } else {
#line 1374
            tmp___3 = 0;
          }
#line 1374
          bad_length = tmp___3;
#line 1376
          if ((int )where_from.u.sa_family != (int )his_addr.u.sa_family) {
#line 1376
            tmp___5 = 1;
          } else
#line 1376
          if ((int )where_from.u.sa_family == 2) {
#line 1376
            if (where_from.in4.sin_addr.s_addr != his_addr.in4.sin_addr.s_addr) {
#line 1376
              tmp___5 = 1;
            } else
#line 1376
            if ((int )where_from.in4.sin_port != (int )his_addr.in4.sin_port) {
#line 1376
              tmp___5 = 1;
            } else {
#line 1376
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 1376
          if ((int )where_from.u.sa_family == 10) {
            {
#line 1376
            tmp___4 = memcmp((void const   *)(where_from.in6.sin6_addr.__in6_u.__u6_addr8),
                             (void const   *)(his_addr.in6.sin6_addr.__in6_u.__u6_addr8),
                             sizeof(where_from.in6.sin6_addr.__in6_u.__u6_addr8));
            }
#line 1376
            if (tmp___4 != 0) {
#line 1376
              tmp___5 = 1;
            } else
#line 1376
            if ((int )where_from.in6.sin6_port != (int )his_addr.in6.sin6_port) {
#line 1376
              tmp___5 = 1;
            } else {
#line 1376
              tmp___5 = 0;
            }
          } else {
#line 1376
            tmp___5 = 0;
          }
#line 1376
          bad_sender = tmp___5;
#line 1388
          if (! bad_length) {
            {
#line 1389
            tmp___6 = ntohl(reply->sequence);
#line 1389
            bad_sequence = (unsigned long )tmp___6 != tx_sequence;
            }
          } else {
#line 1391
            bad_sequence = 0;
          }
#line 1394
          if (bad_length) {
#line 1394
            goto _L___0;
          } else
#line 1394
          if (bad_sender) {
#line 1394
            goto _L___0;
          } else
#line 1394
          if (bad_sequence) {
            _L___0: /* CIL Label */ 
#line 1395
            n_attempts ++;
#line 1396
            if (n_attempts > max_retries) {
#line 1397
              return (0);
            }
#line 1399
            goto __Cont;
          }
#line 1402
          if ((int )reply->version != 5) {
#line 1402
            if ((int )reply->version >= 4) {
              {
#line 1402
              tmp___7 = ntohs(reply->status);
              }
#line 1402
              if ((int )tmp___7 == 18) {
#line 1402
                goto _L___1;
              } else {
#line 1402
                tmp___8 = 1;
              }
            } else {
#line 1402
              tmp___8 = 1;
            }
          } else
          _L___1: /* CIL Label */ 
#line 1402
          if ((int )reply->pkt_type != 2) {
#line 1402
            tmp___8 = 1;
          } else
#line 1402
          if ((int )reply->res1 != 0) {
#line 1402
            tmp___8 = 1;
          } else
#line 1402
          if ((int )reply->res2 != 0) {
#line 1402
            tmp___8 = 1;
          } else
#line 1402
          if ((int )reply->command != (int )request->command) {
#line 1402
            tmp___8 = 1;
          } else {
#line 1402
            tmp___8 = 0;
          }
#line 1402
          bad_header = tmp___8;
#line 1410
          if (bad_header) {
#line 1411
            n_attempts ++;
#line 1412
            if (n_attempts > max_retries) {
#line 1413
              return (0);
            }
#line 1415
            goto __Cont;
          }
#line 1429
          if (password) {
            {
#line 1430
            *reply_auth_ok = check_reply_auth(reply, read_length);
            }
          } else {
#line 1434
            *reply_auth_ok = 1;
          }
          {
#line 1437
          tmp___9 = ntohl(reply->utoken);
#line 1437
          utoken___0 = (unsigned long )tmp___9;
          }
#line 1439
          if (*reply_auth_ok) {
            {
#line 1446
            tmp___10 = ntohl(reply->utoken);
#line 1446
            utoken___0 = (unsigned long )tmp___10;
#line 1447
            tmp___11 = ntohl(reply->token);
#line 1447
            token = (unsigned long )tmp___11;
            }
          }
#line 1450
          goto while_break;
        }
      }
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1456
  return (1);
}
}
#line 1461 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static int request_reply(CMD_Request *request , CMD_Reply *reply , int requested_reply ,
                         int verbose ) 
{ 
  int reply_auth_ok ;
  int status___0 ;
  int tmp ;
  uint16_t tmp___0 ;
  uint16_t tmp___1 ;

  {
  {
#line 1467
  tmp = submit_request(request, reply, & reply_auth_ok);
  }
#line 1467
  if (! tmp) {
    {
#line 1468
    printf((char const   */* __restrict  */)"506 Cannot talk to daemon\n");
    }
#line 1469
    return (0);
  }
  {
#line 1472
  tmp___0 = ntohs(reply->status);
#line 1472
  status___0 = (int )tmp___0;
  }
#line 1474
  if (verbose) {
#line 1474
    goto _L;
  } else
#line 1474
  if (status___0 != 0) {
    _L: /* CIL Label */ 
    {
#line 1476
    if (status___0 == 0) {
#line 1476
      goto case_0;
    }
#line 1479
    if (status___0 == 8) {
#line 1479
      goto case_8;
    }
#line 1482
    if (status___0 == 9) {
#line 1482
      goto case_9;
    }
#line 1485
    if (status___0 == 1) {
#line 1485
      goto case_1;
    }
#line 1488
    if (status___0 == 2) {
#line 1488
      goto case_2;
    }
#line 1491
    if (status___0 == 3) {
#line 1491
      goto case_3;
    }
#line 1494
    if (status___0 == 4) {
#line 1494
      goto case_4;
    }
#line 1497
    if (status___0 == 5) {
#line 1497
      goto case_5;
    }
#line 1500
    if (status___0 == 6) {
#line 1500
      goto case_6;
    }
#line 1503
    if (status___0 == 7) {
#line 1503
      goto case_7;
    }
#line 1506
    if (status___0 == 10) {
#line 1506
      goto case_10;
    }
#line 1509
    if (status___0 == 11) {
#line 1509
      goto case_11;
    }
#line 1512
    if (status___0 == 12) {
#line 1512
      goto case_12;
    }
#line 1515
    if (status___0 == 13) {
#line 1515
      goto case_13;
    }
#line 1518
    if (status___0 == 14) {
#line 1518
      goto case_14;
    }
#line 1521
    if (status___0 == 17) {
#line 1521
      goto case_17;
    }
#line 1524
    if (status___0 == 16) {
#line 1524
      goto case_16;
    }
#line 1527
    if (status___0 == 18) {
#line 1527
      goto case_18;
    }
#line 1530
    if (status___0 == 19) {
#line 1530
      goto case_19;
    }
#line 1533
    if (status___0 == 15) {
#line 1533
      goto case_15;
    }
#line 1536
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 1477
    printf((char const   */* __restrict  */)"200 OK");
    }
#line 1478
    goto switch_break;
    case_8: /* CIL Label */ 
    {
#line 1480
    printf((char const   */* __restrict  */)"208 Access allowed");
    }
#line 1481
    goto switch_break;
    case_9: /* CIL Label */ 
    {
#line 1483
    printf((char const   */* __restrict  */)"209 Access denied");
    }
#line 1484
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 1486
    printf((char const   */* __restrict  */)"500 Failure");
    }
#line 1487
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 1489
    printf((char const   */* __restrict  */)"501 Not authorised");
    }
#line 1490
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 1492
    printf((char const   */* __restrict  */)"502 Invalid command");
    }
#line 1493
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 1495
    printf((char const   */* __restrict  */)"503 No such source");
    }
#line 1496
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 1498
    printf((char const   */* __restrict  */)"504 Duplicate or stale logon detected");
    }
#line 1499
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 1501
    printf((char const   */* __restrict  */)"505 Facility not enabled in daemon");
    }
#line 1502
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 1504
    printf((char const   */* __restrict  */)"507 Bad subnet");
    }
#line 1505
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 1507
    printf((char const   */* __restrict  */)"510 No command access from this host");
    }
#line 1508
    goto switch_break;
    case_11: /* CIL Label */ 
    {
#line 1510
    printf((char const   */* __restrict  */)"511 Source already present");
    }
#line 1511
    goto switch_break;
    case_12: /* CIL Label */ 
    {
#line 1513
    printf((char const   */* __restrict  */)"512 Too many sources present");
    }
#line 1514
    goto switch_break;
    case_13: /* CIL Label */ 
    {
#line 1516
    printf((char const   */* __restrict  */)"513 RTC driver not running");
    }
#line 1517
    goto switch_break;
    case_14: /* CIL Label */ 
    {
#line 1519
    printf((char const   */* __restrict  */)"514 Can\'t write RTC parameters");
    }
#line 1520
    goto switch_break;
    case_17: /* CIL Label */ 
    {
#line 1522
    printf((char const   */* __restrict  */)"515 Invalid address family");
    }
#line 1523
    goto switch_break;
    case_16: /* CIL Label */ 
    {
#line 1525
    printf((char const   */* __restrict  */)"516 Sample index out of range");
    }
#line 1526
    goto switch_break;
    case_18: /* CIL Label */ 
    {
#line 1528
    printf((char const   */* __restrict  */)"517 Protocol version mismatch");
    }
#line 1529
    goto switch_break;
    case_19: /* CIL Label */ 
    {
#line 1531
    printf((char const   */* __restrict  */)"518 Packet length mismatch");
    }
#line 1532
    goto switch_break;
    case_15: /* CIL Label */ 
    {
#line 1534
    printf((char const   */* __restrict  */)"519 Client logging is not active in the daemon");
    }
#line 1535
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1537
    printf((char const   */* __restrict  */)"520 Got unexpected error from daemon");
    }
    switch_break: /* CIL Label */ ;
    }
#line 1539
    if (reply_auth_ok) {
      {
#line 1540
      printf((char const   */* __restrict  */)"\n");
      }
    } else {
      {
#line 1542
      printf((char const   */* __restrict  */)" --- Reply not authenticated\n");
      }
    }
  }
#line 1546
  if (status___0 != 0) {
#line 1546
    if (status___0 != 8) {
#line 1546
      if (status___0 != 9) {
#line 1548
        return (0);
      }
    }
  }
  {
#line 1551
  tmp___1 = ntohs(reply->reply);
  }
#line 1551
  if ((int )tmp___1 != requested_reply) {
    {
#line 1552
    printf((char const   */* __restrict  */)"508 Bad reply from daemon\n");
    }
#line 1553
    return (0);
  }
#line 1556
  return (1);
}
}
#line 1561 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static void print_seconds(unsigned long s ) 
{ 
  unsigned long d ;

  {
#line 1565
  if (s <= 1024UL) {
    {
#line 1566
    printf((char const   */* __restrict  */)"%4ld", s);
    }
  } else
#line 1567
  if (s < 36000UL) {
    {
#line 1568
    printf((char const   */* __restrict  */)"%3ldm", s / 60UL);
    }
  } else
#line 1569
  if (s < 345600UL) {
    {
#line 1570
    printf((char const   */* __restrict  */)"%3ldh", s / 3600UL);
    }
  } else {
#line 1572
    d = s / 86400UL;
#line 1573
    if (d > 999UL) {
      {
#line 1574
      printf((char const   */* __restrict  */)"%3ldy", d / 365UL);
      }
    } else {
      {
#line 1576
      printf((char const   */* __restrict  */)"%3ldd", d);
      }
    }
  }
#line 1579
  return;
}
}
#line 1583 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static void print_nanoseconds(double s ) 
{ 


  {
  {
#line 1586
  s = fabs(s);
  }
#line 1588
  if (s < 9999.5e-9) {
    {
#line 1589
    printf((char const   */* __restrict  */)"%4.0fns", s * 1e9);
    }
  } else
#line 1590
  if (s < 9999.5e-6) {
    {
#line 1591
    printf((char const   */* __restrict  */)"%4.0fus", s * 1e6);
    }
  } else
#line 1592
  if (s < 9999.5e-3) {
    {
#line 1593
    printf((char const   */* __restrict  */)"%4.0fms", s * 1e3);
    }
  } else
#line 1594
  if (s < 999.5) {
    {
#line 1595
    printf((char const   */* __restrict  */)"%5.1fs", s);
    }
  } else
#line 1596
  if (s < 99999.5) {
    {
#line 1597
    printf((char const   */* __restrict  */)"%5.0fs", s);
    }
  } else
#line 1598
  if (s < 99999.5 * (double )60) {
    {
#line 1599
    printf((char const   */* __restrict  */)"%5.0fm", s / (double )60);
    }
  } else
#line 1600
  if (s < 99999.5 * (double )3600) {
    {
#line 1601
    printf((char const   */* __restrict  */)"%5.0fh", s / (double )3600);
    }
  } else
#line 1602
  if (s < (99999.5 * (double )3600) * (double )24) {
    {
#line 1603
    printf((char const   */* __restrict  */)"%5.0fd", s / (double )86400);
    }
  } else {
    {
#line 1605
    printf((char const   */* __restrict  */)"%5.0fy", s / (double )31536000);
    }
  }
#line 1607
  return;
}
}
#line 1611 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static void print_signed_nanoseconds(double s ) 
{ 
  double x ;

  {
  {
#line 1616
  x = fabs(s);
  }
#line 1618
  if (x < 9999.5e-9) {
    {
#line 1619
    printf((char const   */* __restrict  */)"%+5.0fns", s * 1e9);
    }
  } else
#line 1620
  if (x < 9999.5e-6) {
    {
#line 1621
    printf((char const   */* __restrict  */)"%+5.0fus", s * 1e6);
    }
  } else
#line 1622
  if (x < 9999.5e-3) {
    {
#line 1623
    printf((char const   */* __restrict  */)"%+5.0fms", s * 1e3);
    }
  } else
#line 1624
  if (x < 999.5) {
    {
#line 1625
    printf((char const   */* __restrict  */)"%+6.1fs", s);
    }
  } else
#line 1626
  if (x < 99999.5) {
    {
#line 1627
    printf((char const   */* __restrict  */)"%+6.0fs", s);
    }
  } else
#line 1628
  if (x < 99999.5 * (double )60) {
    {
#line 1629
    printf((char const   */* __restrict  */)"%+6.0fm", s / (double )60);
    }
  } else
#line 1630
  if (x < 99999.5 * (double )3600) {
    {
#line 1631
    printf((char const   */* __restrict  */)"%+6.0fh", s / (double )3600);
    }
  } else
#line 1632
  if (x < (99999.5 * (double )3600) * (double )24) {
    {
#line 1633
    printf((char const   */* __restrict  */)"%+6.0fd", s / (double )86400);
    }
  } else {
    {
#line 1635
    printf((char const   */* __restrict  */)"%+6.0fy", s / (double )31536000);
    }
  }
#line 1637
  return;
}
}
#line 1641 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static void print_freq_ppm(double f ) 
{ 
  double tmp ;

  {
  {
#line 1644
  tmp = fabs(f);
  }
#line 1644
  if (tmp < 99999.5) {
    {
#line 1645
    printf((char const   */* __restrict  */)"%10.3f", f);
    }
  } else {
    {
#line 1647
    printf((char const   */* __restrict  */)"%10.0f", f);
    }
  }
#line 1649
  return;
}
}
#line 1653 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static int check_for_verbose_flag(char *line___0 ) 
{ 
  char *p ;
  int tmp ;

  {
  {
#line 1656
  p = line___0;
#line 1657
  tmp = strcmp((char const   *)p, "-v");
  }
#line 1657
  if (tmp) {
#line 1660
    return (0);
  } else {
#line 1658
    return (1);
  }
}
}
#line 1666 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static int process_cmd_sources(char *line___0 ) 
{ 
  CMD_Request request ;
  CMD_Reply reply ;
  int n_sources___3 ;
  int i ;
  int verbose ;
  double orig_latest_meas ;
  double latest_meas ;
  double latest_meas_err ;
  IPAddr ip_addr ;
  uint32_t latest_meas_ago ;
  uint16_t poll ;
  uint16_t stratum ;
  uint16_t state ;
  uint16_t mode ;
  uint16_t flags ;
  uint16_t reachability ;
  char hostname_buf[50] ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 1672
  verbose = 0;
#line 1682
  verbose = check_for_verbose_flag(line___0);
#line 1684
  request.command = htons((uint16_t )14);
#line 1685
  tmp___4 = request_reply(& request, & reply, 2, 0);
  }
#line 1685
  if (tmp___4) {
    {
#line 1686
    tmp = ntohl(reply.data.n_sources.n_sources);
#line 1686
    n_sources___3 = (int )tmp;
#line 1687
    printf((char const   */* __restrict  */)"210 Number of sources = %d\n", n_sources___3);
    }
#line 1688
    if (verbose) {
      {
#line 1689
      printf((char const   */* __restrict  */)"\n");
#line 1690
      printf((char const   */* __restrict  */)"  .-- Source mode  \'^\' = server, \'=\' = peer, \'#\' = local clock.\n");
#line 1691
      printf((char const   */* __restrict  */)" / .- Source state \'*\' = current synced, \'+\' = combined , \'-\' = not combined,\n");
#line 1692
      printf((char const   */* __restrict  */)"| /   \'?\' = unreachable, \'x\' = time may be in error, \'~\' = time too variable.\n");
#line 1693
      printf((char const   */* __restrict  */)"||                                                 .- xxxx [ yyyy ] +/- zzzz\n");
#line 1694
      printf((char const   */* __restrict  */)"||                                                /   xxxx = adjusted offset,\n");
#line 1695
      printf((char const   */* __restrict  */)"||         Log2(Polling interval) -.             |    yyyy = measured offset,\n");
#line 1696
      printf((char const   */* __restrict  */)"||                                  \\            |    zzzz = estimated error.\n");
#line 1697
      printf((char const   */* __restrict  */)"||                                   |           |                         \n");
      }
    }
    {
#line 1700
    printf((char const   */* __restrict  */)"MS Name/IP address         Stratum Poll Reach LastRx Last sample\n");
#line 1701
    printf((char const   */* __restrict  */)"===============================================================================\n");
#line 1705
    i = 0;
    }
    {
#line 1705
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1705
      if (! (i < n_sources___3)) {
#line 1705
        goto while_break;
      }
      {
#line 1706
      request.command = htons((uint16_t )15);
#line 1707
      tmp___0 = htonl((uint32_t )i);
#line 1707
      request.data.source_data.index = (int32_t )tmp___0;
#line 1708
      tmp___3 = request_reply(& request, & reply, 3, 0);
      }
#line 1708
      if (tmp___3) {
        {
#line 1709
        UTI_IPNetworkToHost(& reply.data.source_data.ip_addr, & ip_addr);
#line 1710
        poll = ntohs(reply.data.source_data.poll);
#line 1711
        stratum = ntohs(reply.data.source_data.stratum);
#line 1712
        state = ntohs(reply.data.source_data.state);
#line 1713
        mode = ntohs(reply.data.source_data.mode);
#line 1714
        flags = ntohs(reply.data.source_data.flags);
#line 1715
        reachability = ntohs(reply.data.source_data.reachability);
#line 1716
        latest_meas_ago = ntohl(reply.data.source_data.since_sample);
#line 1717
        orig_latest_meas = UTI_FloatNetworkToHost(reply.data.source_data.orig_latest_meas);
#line 1718
        latest_meas = UTI_FloatNetworkToHost(reply.data.source_data.latest_meas);
#line 1719
        latest_meas_err = UTI_FloatNetworkToHost(reply.data.source_data.latest_meas_err);
        }
#line 1721
        if ((int )mode == 2) {
          {
#line 1722
          tmp___1 = UTI_RefidToString(ip_addr.addr.in4);
#line 1722
          snprintf((char */* __restrict  */)(hostname_buf), sizeof(hostname_buf),
                   (char const   */* __restrict  */)"%s", tmp___1);
          }
        } else
#line 1723
        if (no_dns) {
          {
#line 1724
          tmp___2 = UTI_IPToString(& ip_addr);
#line 1724
          snprintf((char */* __restrict  */)(hostname_buf), sizeof(hostname_buf),
                   (char const   */* __restrict  */)"%s", tmp___2);
          }
        } else {
          {
#line 1726
          DNS_IPAddress2Name(& ip_addr, hostname_buf, (int )sizeof(hostname_buf));
#line 1727
          hostname_buf[25] = (char)0;
          }
        }
        {
#line 1731
        if ((int )mode == 0) {
#line 1731
          goto case_0;
        }
#line 1733
        if ((int )mode == 1) {
#line 1733
          goto case_1;
        }
#line 1735
        if ((int )mode == 2) {
#line 1735
          goto case_2;
        }
#line 1737
        goto switch_default;
        case_0: /* CIL Label */ 
        {
#line 1732
        printf((char const   */* __restrict  */)"^");
        }
#line 1732
        goto switch_break;
        case_1: /* CIL Label */ 
        {
#line 1734
        printf((char const   */* __restrict  */)"=");
        }
#line 1734
        goto switch_break;
        case_2: /* CIL Label */ 
        {
#line 1736
        printf((char const   */* __restrict  */)"#");
        }
#line 1736
        goto switch_break;
        switch_default: /* CIL Label */ 
        {
#line 1738
        printf((char const   */* __restrict  */)" ");
        }
        switch_break: /* CIL Label */ ;
        }
        {
#line 1741
        if ((int )state == 0) {
#line 1741
          goto case_0___0;
        }
#line 1743
        if ((int )state == 1) {
#line 1743
          goto case_1___0;
        }
#line 1745
        if ((int )state == 2) {
#line 1745
          goto case_2___0;
        }
#line 1747
        if ((int )state == 3) {
#line 1747
          goto case_3;
        }
#line 1749
        if ((int )state == 4) {
#line 1749
          goto case_4;
        }
#line 1751
        if ((int )state == 5) {
#line 1751
          goto case_5;
        }
#line 1753
        goto switch_default___0;
        case_0___0: /* CIL Label */ 
        {
#line 1742
        printf((char const   */* __restrict  */)"*");
        }
#line 1742
        goto switch_break___0;
        case_1___0: /* CIL Label */ 
        {
#line 1744
        printf((char const   */* __restrict  */)"?");
        }
#line 1744
        goto switch_break___0;
        case_2___0: /* CIL Label */ 
        {
#line 1746
        printf((char const   */* __restrict  */)"x");
        }
#line 1746
        goto switch_break___0;
        case_3: /* CIL Label */ 
        {
#line 1748
        printf((char const   */* __restrict  */)"~");
        }
#line 1748
        goto switch_break___0;
        case_4: /* CIL Label */ 
        {
#line 1750
        printf((char const   */* __restrict  */)"+");
        }
#line 1750
        goto switch_break___0;
        case_5: /* CIL Label */ 
        {
#line 1752
        printf((char const   */* __restrict  */)"-");
        }
#line 1752
        goto switch_break___0;
        switch_default___0: /* CIL Label */ 
        {
#line 1754
        printf((char const   */* __restrict  */)" ");
        }
        switch_break___0: /* CIL Label */ ;
        }
        {
#line 1757
        goto switch_default___1;
        switch_default___1: /* CIL Label */ 
#line 1758
        goto switch_break___1;
        switch_break___1: /* CIL Label */ ;
        }
        {
#line 1761
        printf((char const   */* __restrict  */)" %-27s  %2d  %2d   %3o  ", hostname_buf,
               (int )stratum, (int )poll, (int )reachability);
#line 1762
        print_seconds((unsigned long )latest_meas_ago);
#line 1763
        printf((char const   */* __restrict  */)"  ");
#line 1764
        print_signed_nanoseconds(latest_meas);
#line 1765
        printf((char const   */* __restrict  */)"[");
#line 1766
        print_signed_nanoseconds(orig_latest_meas);
#line 1767
        printf((char const   */* __restrict  */)"]");
#line 1768
        printf((char const   */* __restrict  */)" +/- ");
#line 1769
        print_nanoseconds(latest_meas_err);
#line 1770
        printf((char const   */* __restrict  */)"\n");
        }
      } else {
#line 1772
        return (0);
      }
#line 1705
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 1776
    return (0);
  }
#line 1778
  return (1);
}
}
#line 1783 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static int process_cmd_sourcestats(char *line___0 ) 
{ 
  CMD_Request request ;
  CMD_Reply reply ;
  int n_sources___3 ;
  int i ;
  int verbose ;
  char hostname_buf[50] ;
  unsigned long n_samples___1 ;
  unsigned long n_runs___0 ;
  unsigned long span_seconds ;
  double resid_freq_ppm ;
  double skew_ppm ;
  double sd ;
  double est_offset ;
  uint32_t ref_id ;
  IPAddr ip_addr ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  uint32_t tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
#line 1789
  verbose = 0;
#line 1797
  verbose = check_for_verbose_flag(line___0);
#line 1799
  request.command = htons((uint16_t )14);
#line 1800
  tmp___7 = request_reply(& request, & reply, 2, 0);
  }
#line 1800
  if (tmp___7) {
    {
#line 1801
    tmp = ntohl(reply.data.n_sources.n_sources);
#line 1801
    n_sources___3 = (int )tmp;
#line 1802
    printf((char const   */* __restrict  */)"210 Number of sources = %d\n", n_sources___3);
    }
#line 1803
    if (verbose) {
      {
#line 1804
      printf((char const   */* __restrict  */)"                             .- Number of sample points in measurement set.\n");
#line 1805
      printf((char const   */* __restrict  */)"                            /    .- Number of residual runs with same sign.\n");
#line 1806
      printf((char const   */* __restrict  */)"                           |    /    .- Length of measurement set (time).\n");
#line 1807
      printf((char const   */* __restrict  */)"                           |   |    /      .- Est. clock freq error (ppm).\n");
#line 1808
      printf((char const   */* __restrict  */)"                           |   |   |      /           .- Est. error in freq.\n");
#line 1809
      printf((char const   */* __restrict  */)"                           |   |   |     |           /         .- Est. offset.\n");
#line 1810
      printf((char const   */* __restrict  */)"                           |   |   |     |          |          |   On the -.\n");
#line 1811
      printf((char const   */* __restrict  */)"                           |   |   |     |          |          |   samples. \\\n");
#line 1812
      printf((char const   */* __restrict  */)"                           |   |   |     |          |          |             |\n");
      }
    }
    {
#line 1815
    printf((char const   */* __restrict  */)"Name/IP Address            NP  NR  Span  Frequency  Freq Skew  Offset  Std Dev\n");
#line 1816
    printf((char const   */* __restrict  */)"==============================================================================\n");
#line 1820
    i = 0;
    }
    {
#line 1820
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1820
      if (! (i < n_sources___3)) {
#line 1820
        goto while_break;
      }
      {
#line 1821
      request.command = htons((uint16_t )34);
#line 1822
      tmp___0 = htonl((uint32_t )i);
#line 1822
      request.data.source_data.index = (int32_t )tmp___0;
#line 1823
      tmp___6 = request_reply(& request, & reply, 6, 0);
      }
#line 1823
      if (tmp___6) {
        {
#line 1824
        ref_id = ntohl(reply.data.sourcestats.ref_id);
#line 1825
        UTI_IPNetworkToHost(& reply.data.sourcestats.ip_addr, & ip_addr);
#line 1826
        tmp___1 = ntohl(reply.data.sourcestats.n_samples);
#line 1826
        n_samples___1 = (unsigned long )tmp___1;
#line 1827
        tmp___2 = ntohl(reply.data.sourcestats.n_runs);
#line 1827
        n_runs___0 = (unsigned long )tmp___2;
#line 1828
        tmp___3 = ntohl(reply.data.sourcestats.span_seconds);
#line 1828
        span_seconds = (unsigned long )tmp___3;
#line 1829
        resid_freq_ppm = UTI_FloatNetworkToHost(reply.data.sourcestats.resid_freq_ppm);
#line 1830
        skew_ppm = UTI_FloatNetworkToHost(reply.data.sourcestats.skew_ppm);
#line 1831
        sd = UTI_FloatNetworkToHost(reply.data.sourcestats.sd);
#line 1832
        est_offset = UTI_FloatNetworkToHost(reply.data.sourcestats.est_offset);
        }
#line 1835
        if ((int )ip_addr.family == 0) {
          {
#line 1836
          tmp___4 = UTI_RefidToString(ref_id);
#line 1836
          snprintf((char */* __restrict  */)(hostname_buf), sizeof(hostname_buf),
                   (char const   */* __restrict  */)"%s", tmp___4);
          }
        } else
#line 1837
        if (no_dns) {
          {
#line 1838
          tmp___5 = UTI_IPToString(& ip_addr);
#line 1838
          snprintf((char */* __restrict  */)(hostname_buf), sizeof(hostname_buf),
                   (char const   */* __restrict  */)"%s", tmp___5);
          }
        } else {
          {
#line 1840
          DNS_IPAddress2Name(& ip_addr, hostname_buf, (int )sizeof(hostname_buf));
#line 1841
          hostname_buf[25] = (char)0;
          }
        }
        {
#line 1844
        printf((char const   */* __restrict  */)"%-25s %3lu %3lu  ", hostname_buf,
               n_samples___1, n_runs___0);
#line 1845
        print_seconds(span_seconds);
#line 1846
        printf((char const   */* __restrict  */)" ");
#line 1847
        print_freq_ppm(resid_freq_ppm);
#line 1848
        printf((char const   */* __restrict  */)" ");
#line 1849
        print_freq_ppm(skew_ppm);
#line 1850
        printf((char const   */* __restrict  */)"  ");
#line 1851
        print_signed_nanoseconds(est_offset);
#line 1852
        printf((char const   */* __restrict  */)"  ");
#line 1853
        print_nanoseconds(sd);
#line 1854
        printf((char const   */* __restrict  */)"\n");
        }
      } else {
#line 1856
        return (0);
      }
#line 1820
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 1860
    return (0);
  }
#line 1862
  return (1);
}
}
#line 1867 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static int process_cmd_tracking(char *line___0 ) 
{ 
  CMD_Request request ;
  CMD_Reply reply ;
  IPAddr ip_addr ;
  uint32_t ref_id ;
  char host[50] ;
  char *ref_ip ;
  struct timeval ref_time ;
  struct tm ref_time_tm ;
  unsigned long a ;
  unsigned long b ;
  unsigned long c ;
  unsigned long d ;
  double correction ;
  double last_offset___0 ;
  double rms_offset ;
  double freq_ppm ;
  double resid_freq_ppm ;
  double skew_ppm ;
  double root_delay ;
  double root_dispersion ;
  double last_update_interval ;
  char const   *leap_status ;
  uint16_t tmp ;
  uint16_t tmp___0 ;
  struct tm *tmp___1 ;
  char *tmp___2 ;
  char const   *tmp___3 ;
  double tmp___4 ;
  char const   *tmp___5 ;
  double tmp___6 ;
  int tmp___7 ;

  {
  {
#line 1890
  request.command = htons((uint16_t )33);
#line 1891
  tmp___7 = request_reply(& request, & reply, 5, 0);
  }
#line 1891
  if (tmp___7) {
    {
#line 1892
    ref_id = ntohl(reply.data.tracking.ref_id);
#line 1893
    a = (unsigned long )(ref_id >> 24);
#line 1894
    b = (unsigned long )((ref_id >> 16) & 255U);
#line 1895
    c = (unsigned long )((ref_id >> 8) & 255U);
#line 1896
    d = (unsigned long )(ref_id & 255U);
#line 1898
    UTI_IPNetworkToHost(& reply.data.tracking.ip_addr, & ip_addr);
    }
#line 1899
    if ((int )ip_addr.family == 0) {
      {
#line 1900
      ref_ip = UTI_RefidToString(ref_id);
      }
    } else
#line 1901
    if (no_dns) {
      {
#line 1902
      ref_ip = UTI_IPToString(& ip_addr);
      }
    } else {
      {
#line 1904
      DNS_IPAddress2Name(& ip_addr, host, (int )sizeof(host));
#line 1905
      ref_ip = host;
      }
    }
    {
#line 1908
    tmp = ntohs(reply.data.tracking.leap_status);
    }
    {
#line 1909
    if ((int )tmp == 0) {
#line 1909
      goto case_0;
    }
#line 1912
    if ((int )tmp == 1) {
#line 1912
      goto case_1;
    }
#line 1915
    if ((int )tmp == 2) {
#line 1915
      goto case_2;
    }
#line 1918
    if ((int )tmp == 3) {
#line 1918
      goto case_3;
    }
#line 1921
    goto switch_default;
    case_0: /* CIL Label */ 
#line 1910
    leap_status = "Normal";
#line 1911
    goto switch_break;
    case_1: /* CIL Label */ 
#line 1913
    leap_status = "Insert second";
#line 1914
    goto switch_break;
    case_2: /* CIL Label */ 
#line 1916
    leap_status = "Delete second";
#line 1917
    goto switch_break;
    case_3: /* CIL Label */ 
#line 1919
    leap_status = "Not synchronised";
#line 1920
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1922
    leap_status = "Unknown";
#line 1923
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 1926
    printf((char const   */* __restrict  */)"Reference ID    : %lu.%lu.%lu.%lu (%s)\n",
           a, b, c, d, ref_ip);
#line 1927
    tmp___0 = ntohs(reply.data.tracking.stratum);
#line 1927
    printf((char const   */* __restrict  */)"Stratum         : %lu\n", (unsigned long )tmp___0);
#line 1928
    UTI_TimevalNetworkToHost(& reply.data.tracking.ref_time, & ref_time);
#line 1929
    tmp___1 = gmtime((time_t const   *)(& ref_time.tv_sec));
#line 1929
    ref_time_tm = *tmp___1;
#line 1930
    tmp___2 = asctime((struct tm  const  *)(& ref_time_tm));
#line 1930
    printf((char const   */* __restrict  */)"Ref time (UTC)  : %s", tmp___2);
#line 1931
    correction = UTI_FloatNetworkToHost(reply.data.tracking.current_correction);
#line 1932
    last_offset___0 = UTI_FloatNetworkToHost(reply.data.tracking.last_offset);
#line 1933
    rms_offset = UTI_FloatNetworkToHost(reply.data.tracking.rms_offset);
    }
#line 1934
    if (correction > 0.0) {
#line 1934
      tmp___3 = "slow";
    } else {
#line 1934
      tmp___3 = "fast";
    }
    {
#line 1934
    tmp___4 = fabs(correction);
#line 1934
    printf((char const   */* __restrict  */)"System time     : %.9f seconds %s of NTP time\n",
           tmp___4, tmp___3);
#line 1936
    printf((char const   */* __restrict  */)"Last offset     : %.9f seconds\n", last_offset___0);
#line 1937
    printf((char const   */* __restrict  */)"RMS offset      : %.9f seconds\n", rms_offset);
#line 1938
    freq_ppm = UTI_FloatNetworkToHost(reply.data.tracking.freq_ppm);
#line 1939
    resid_freq_ppm = UTI_FloatNetworkToHost(reply.data.tracking.resid_freq_ppm);
#line 1940
    skew_ppm = UTI_FloatNetworkToHost(reply.data.tracking.skew_ppm);
#line 1941
    root_delay = UTI_FloatNetworkToHost(reply.data.tracking.root_delay);
#line 1942
    root_dispersion = UTI_FloatNetworkToHost(reply.data.tracking.root_dispersion);
#line 1943
    last_update_interval = UTI_FloatNetworkToHost(reply.data.tracking.last_update_interval);
    }
#line 1944
    if (freq_ppm < 0.0) {
#line 1944
      tmp___5 = "slow";
    } else {
#line 1944
      tmp___5 = "fast";
    }
    {
#line 1944
    tmp___6 = fabs(freq_ppm);
#line 1944
    printf((char const   */* __restrict  */)"Frequency       : %.3f ppm %s\n", tmp___6,
           tmp___5);
#line 1945
    printf((char const   */* __restrict  */)"Residual freq   : %.3f ppm\n", resid_freq_ppm);
#line 1946
    printf((char const   */* __restrict  */)"Skew            : %.3f ppm\n", skew_ppm);
#line 1947
    printf((char const   */* __restrict  */)"Root delay      : %.6f seconds\n", root_delay);
#line 1948
    printf((char const   */* __restrict  */)"Root dispersion : %.6f seconds\n", root_dispersion);
#line 1949
    printf((char const   */* __restrict  */)"Update interval : %.1f seconds\n", last_update_interval);
#line 1950
    printf((char const   */* __restrict  */)"Leap status     : %s\n", leap_status);
    }
#line 1951
    return (1);
  }
#line 1953
  return (0);
}
}
#line 1957 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static int process_cmd_rtcreport(char *line___0 ) 
{ 
  CMD_Request request ;
  CMD_Reply reply ;
  struct timeval ref_time ;
  struct tm ref_time_tm ;
  unsigned short n_samples___1 ;
  unsigned short n_runs___0 ;
  unsigned long span_seconds ;
  double coef_seconds_fast___0 ;
  double coef_gain_rate_ppm ;
  struct tm *tmp ;
  uint32_t tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 1970
  request.command = htons((uint16_t )35);
#line 1971
  tmp___2 = request_reply(& request, & reply, 7, 0);
  }
#line 1971
  if (tmp___2) {
    {
#line 1972
    UTI_TimevalNetworkToHost(& reply.data.rtc.ref_time, & ref_time);
#line 1973
    tmp = gmtime((time_t const   *)(& ref_time.tv_sec));
#line 1973
    ref_time_tm = *tmp;
#line 1974
    n_samples___1 = ntohs(reply.data.rtc.n_samples);
#line 1975
    n_runs___0 = ntohs(reply.data.rtc.n_runs);
#line 1976
    tmp___0 = ntohl(reply.data.rtc.span_seconds);
#line 1976
    span_seconds = (unsigned long )tmp___0;
#line 1977
    coef_seconds_fast___0 = UTI_FloatNetworkToHost(reply.data.rtc.rtc_seconds_fast);
#line 1978
    coef_gain_rate_ppm = UTI_FloatNetworkToHost(reply.data.rtc.rtc_gain_rate_ppm);
#line 1979
    tmp___1 = asctime((struct tm  const  *)(& ref_time_tm));
#line 1979
    printf((char const   */* __restrict  */)"RTC ref time (UTC) : %s", tmp___1);
#line 1980
    printf((char const   */* __restrict  */)"Number of samples  : %d\n", (int )n_samples___1);
#line 1981
    printf((char const   */* __restrict  */)"Number of runs     : %d\n", (int )n_runs___0);
#line 1982
    printf((char const   */* __restrict  */)"Sample span period : ");
#line 1983
    print_seconds(span_seconds);
#line 1984
    printf((char const   */* __restrict  */)"\n");
#line 1985
    printf((char const   */* __restrict  */)"RTC is fast by     : %12.6f seconds\n",
           coef_seconds_fast___0);
#line 1986
    printf((char const   */* __restrict  */)"RTC gains time at  : %9.3f ppm\n", coef_gain_rate_ppm);
    }
#line 1987
    return (1);
  }
#line 1989
  return (0);
}
}
#line 1994 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static int process_cmd_clients(char *line___0 ) 
{ 
  CMD_Request request ;
  CMD_Reply reply ;
  unsigned long next_index ;
  int j ;
  IPAddr ip ;
  unsigned long client_hits ;
  unsigned long peer_hits ;
  unsigned long cmd_hits_auth ;
  unsigned long cmd_hits_normal ;
  unsigned long cmd_hits_bad ;
  unsigned long last_ntp_hit_ago ;
  unsigned long last_cmd_hit_ago ;
  char hostname_buf[50] ;
  int n_replies ;
  int n_indices_in_table ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  uint32_t tmp___3 ;
  uint32_t tmp___4 ;
  uint32_t tmp___5 ;
  uint32_t tmp___6 ;
  uint32_t tmp___7 ;
  char *tmp___8 ;
  uint32_t tmp___9 ;
  int tmp___10 ;

  {
  {
#line 2014
  next_index = 0UL;
#line 2016
  printf((char const   */* __restrict  */)"Hostname                   Client    Peer CmdAuth CmdNorm  CmdBad  LstN  LstC\n=========================  ======  ======  ======  ======  ======  ====  ====\n");
  }
  {
#line 2019
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2021
    request.command = htons((uint16_t )40);
#line 2022
    request.data.client_accesses_by_index.first_index = htonl((uint32_t )next_index);
#line 2023
    request.data.client_accesses_by_index.n_indices = htonl((uint32_t )8);
#line 2025
    tmp___10 = request_reply(& request, & reply, 10, 0);
    }
#line 2025
    if (tmp___10) {
      {
#line 2026
      tmp = ntohl(reply.data.client_accesses_by_index.n_clients);
#line 2026
      n_replies = (int )tmp;
#line 2027
      tmp___0 = ntohl(reply.data.client_accesses_by_index.n_indices);
#line 2027
      n_indices_in_table = (int )tmp___0;
      }
#line 2028
      if (n_replies == 0) {
#line 2029
        goto finished;
      }
#line 2031
      j = 0;
      {
#line 2031
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2031
        if (! (j < n_replies)) {
#line 2031
          goto while_break___0;
        }
        {
#line 2032
        UTI_IPNetworkToHost(& reply.data.client_accesses_by_index.clients[j].ip, & ip);
        }
#line 2033
        if ((int )ip.family != 0) {
          {
#line 2042
          tmp___1 = ntohl(reply.data.client_accesses_by_index.clients[j].client_hits);
#line 2042
          client_hits = (unsigned long )tmp___1;
#line 2043
          tmp___2 = ntohl(reply.data.client_accesses_by_index.clients[j].peer_hits);
#line 2043
          peer_hits = (unsigned long )tmp___2;
#line 2044
          tmp___3 = ntohl(reply.data.client_accesses_by_index.clients[j].cmd_hits_auth);
#line 2044
          cmd_hits_auth = (unsigned long )tmp___3;
#line 2045
          tmp___4 = ntohl(reply.data.client_accesses_by_index.clients[j].cmd_hits_normal);
#line 2045
          cmd_hits_normal = (unsigned long )tmp___4;
#line 2046
          tmp___5 = ntohl(reply.data.client_accesses_by_index.clients[j].cmd_hits_bad);
#line 2046
          cmd_hits_bad = (unsigned long )tmp___5;
#line 2047
          tmp___6 = ntohl(reply.data.client_accesses_by_index.clients[j].last_ntp_hit_ago);
#line 2047
          last_ntp_hit_ago = (unsigned long )tmp___6;
#line 2048
          tmp___7 = ntohl(reply.data.client_accesses_by_index.clients[j].last_cmd_hit_ago);
#line 2048
          last_cmd_hit_ago = (unsigned long )tmp___7;
          }
#line 2050
          if (no_dns) {
            {
#line 2051
            tmp___8 = UTI_IPToString(& ip);
#line 2051
            snprintf((char */* __restrict  */)(hostname_buf), sizeof(hostname_buf),
                     (char const   */* __restrict  */)"%s", tmp___8);
            }
          } else {
            {
#line 2054
            DNS_IPAddress2Name(& ip, hostname_buf, (int )sizeof(hostname_buf));
#line 2055
            hostname_buf[25] = (char)0;
            }
          }
          {
#line 2057
          printf((char const   */* __restrict  */)"%-25s  %6ld  %6ld  %6ld  %6ld  %6ld  ",
                 hostname_buf, client_hits, peer_hits, cmd_hits_auth, cmd_hits_normal,
                 cmd_hits_bad);
#line 2061
          print_seconds(last_ntp_hit_ago);
#line 2062
          printf((char const   */* __restrict  */)"  ");
#line 2063
          print_seconds(last_cmd_hit_ago);
#line 2064
          printf((char const   */* __restrict  */)"\n");
          }
        }
#line 2031
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 2069
      tmp___9 = ntohl(reply.data.client_accesses_by_index.next_index);
#line 2069
      next_index = (unsigned long )tmp___9;
      }
#line 2070
      if (next_index >= (unsigned long )n_indices_in_table) {
#line 2071
        goto finished;
      }
    } else {
#line 2074
      return (0);
    }
  }
  while_break: /* CIL Label */ ;
  }
  finished: 
#line 2080
  return (1);
}
}
#line 2086 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static int process_cmd_manual_list(char const   *line___0 ) 
{ 
  CMD_Request request ;
  CMD_Reply reply ;
  int n_samples___1 ;
  RPY_ManualListSample *sample ;
  int i ;
  struct timeval when ;
  double slewed_offset ;
  double orig_offset ;
  double residual ;
  uint32_t tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 2097
  request.command = htons((uint16_t )41);
#line 2098
  tmp___1 = request_reply(& request, & reply, 11, 0);
  }
#line 2098
  if (tmp___1) {
    {
#line 2099
    tmp = ntohl(reply.data.manual_list.n_samples);
#line 2099
    n_samples___1 = (int )tmp;
#line 2100
    printf((char const   */* __restrict  */)"210 n_samples = %d\n", n_samples___1);
#line 2101
    printf((char const   */* __restrict  */)"#    Date  Time(UTC)    Slewed   Original   Residual\n====================================================\n");
#line 2103
    i = 0;
    }
    {
#line 2103
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2103
      if (! (i < n_samples___1)) {
#line 2103
        goto while_break;
      }
      {
#line 2104
      sample = & reply.data.manual_list.samples[i];
#line 2105
      UTI_TimevalNetworkToHost(& sample->when, & when);
#line 2106
      slewed_offset = UTI_FloatNetworkToHost(sample->slewed_offset);
#line 2107
      orig_offset = UTI_FloatNetworkToHost(sample->orig_offset);
#line 2108
      residual = UTI_FloatNetworkToHost(sample->residual);
#line 2109
      tmp___0 = time_to_log_form(when.tv_sec);
#line 2109
      printf((char const   */* __restrict  */)"%2d %s %10.2f %10.2f %10.2f\n", i,
             tmp___0, slewed_offset, orig_offset, residual);
#line 2103
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 2111
    return (1);
  }
#line 2113
  return (0);
}
}
#line 2118 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static int process_cmd_manual_delete(CMD_Request *msg , char const   *line___0 ) 
{ 
  int index___0 ;
  int tmp ;
  uint32_t tmp___0 ;

  {
  {
#line 2123
  tmp = sscanf((char const   */* __restrict  */)line___0, (char const   */* __restrict  */)"%d",
               & index___0);
  }
#line 2123
  if (tmp != 1) {
    {
#line 2124
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad syntax for manual delete command\n");
    }
#line 2125
    return (0);
  }
  {
#line 2129
  msg->command = htons((uint16_t )42);
#line 2130
  tmp___0 = htonl((uint32_t )index___0);
#line 2130
  msg->data.manual_delete.index = (int32_t )tmp___0;
  }
#line 2131
  return (1);
}
}
#line 2136 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static int process_cmd_settime(char *line___0 ) 
{ 
  struct timeval ts ;
  time_t now ;
  time_t new_time ;
  CMD_Request request ;
  CMD_Reply reply ;
  long offset_cs ;
  double dfreq_ppm ;
  double new_afreq_ppm ;
  double offset ;
  uint32_t tmp ;
  int tmp___0 ;

  {
  {
#line 2147
  now = time((time_t *)((void *)0));
#line 2148
  new_time = get_date((char const   *)line___0, (time_t const   *)(& now));
  }
#line 2150
  if (new_time == -1L) {
    {
#line 2151
    printf((char const   */* __restrict  */)"510 - Could not parse date string\n");
    }
  } else {
    {
#line 2153
    ts.tv_sec = new_time;
#line 2154
    ts.tv_usec = (__suseconds_t )0;
#line 2155
    UTI_TimevalHostToNetwork(& ts, & request.data.settime.ts);
#line 2156
    request.command = htons((uint16_t )11);
#line 2157
    tmp___0 = request_reply(& request, & reply, 4, 1);
    }
#line 2157
    if (tmp___0) {
      {
#line 2158
      tmp = ntohl(reply.data.manual_timestamp.centiseconds);
#line 2158
      offset_cs = (long )tmp;
#line 2159
      offset = 0.01 * (double )((int32_t )offset_cs);
#line 2160
      dfreq_ppm = UTI_FloatNetworkToHost(reply.data.manual_timestamp.dfreq_ppm);
#line 2161
      new_afreq_ppm = UTI_FloatNetworkToHost(reply.data.manual_timestamp.new_afreq_ppm);
#line 2162
      printf((char const   */* __restrict  */)"Clock was %.2f seconds fast.  Frequency change = %.2fppm, new frequency = %.2fppm\n",
             offset, dfreq_ppm, new_afreq_ppm);
      }
#line 2164
      return (1);
    }
  }
#line 2167
  return (0);
}
}
#line 2172 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static void process_cmd_rekey(CMD_Request *msg , char *line___0 ) 
{ 


  {
  {
#line 2175
  msg->command = htons((uint16_t )16);
  }
#line 2176
  return;
}
}
#line 2180 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static void process_cmd_makestep(CMD_Request *msg , char *line___0 ) 
{ 


  {
  {
#line 2183
  msg->command = htons((uint16_t )43);
  }
#line 2184
  return;
}
}
#line 2188 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static int process_cmd_activity(char const   *line___0 ) 
{ 
  CMD_Request request ;
  CMD_Reply reply ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  uint32_t tmp___3 ;
  int tmp___4 ;

  {
  {
#line 2193
  request.command = htons((uint16_t )44);
#line 2194
  tmp___4 = request_reply(& request, & reply, 12, 1);
  }
#line 2194
  if (tmp___4) {
    {
#line 2195
    tmp = ntohl((uint32_t )reply.data.activity.unresolved);
#line 2195
    tmp___0 = ntohl((uint32_t )reply.data.activity.burst_offline);
#line 2195
    tmp___1 = ntohl((uint32_t )reply.data.activity.burst_online);
#line 2195
    tmp___2 = ntohl((uint32_t )reply.data.activity.offline);
#line 2195
    tmp___3 = ntohl((uint32_t )reply.data.activity.online);
#line 2195
    printf((char const   */* __restrict  */)"%ld sources online\n%ld sources offline\n%ld sources doing burst (return to online)\n%ld sources doing burst (return to offline)\n%ld sources with unknown address\n",
           (long )tmp___3, (long )tmp___2, (long )tmp___1, (long )tmp___0, (long )tmp);
    }
#line 2206
    return (1);
  }
#line 2208
  return (0);
}
}
#line 2213 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static int process_cmd_reselectdist(CMD_Request *msg , char *line___0 ) 
{ 
  double dist ;
  int ok ;
  int tmp ;

  {
  {
#line 2218
  msg->command = htons((uint16_t )49);
#line 2219
  tmp = sscanf((char const   */* __restrict  */)line___0, (char const   */* __restrict  */)"%lf",
               & dist);
  }
#line 2219
  if (tmp == 1) {
    {
#line 2220
    msg->data.reselect_distance.distance = UTI_FloatHostToNetwork(dist);
#line 2221
    ok = 1;
    }
  } else {
#line 2223
    ok = 0;
  }
#line 2225
  return (ok);
}
}
#line 2230 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static void process_cmd_reselect(CMD_Request *msg , char *line___0 ) 
{ 


  {
  {
#line 2233
  msg->command = htons((uint16_t )48);
  }
#line 2234
  return;
}
}
#line 2238 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static int process_cmd_waitsync(char *line___0 ) 
{ 
  CMD_Request request ;
  CMD_Reply reply ;
  uint32_t ref_id ;
  uint32_t a ;
  uint32_t b ;
  uint32_t c ;
  uint32_t d ;
  double correction ;
  double skew_ppm ;
  double max_correction ;
  double max_skew_ppm ;
  int ret ;
  int max_tries ;
  int i ;
  int tmp ;

  {
  {
#line 2245
  ret = 0;
#line 2247
  max_tries = 0;
#line 2248
  max_correction = 0.0;
#line 2249
  max_skew_ppm = 0.0;
#line 2251
  sscanf((char const   */* __restrict  */)line___0, (char const   */* __restrict  */)"%d %lf %lf",
         & max_tries, & max_correction, & max_skew_ppm);
#line 2253
  request.command = htons((uint16_t )33);
#line 2255
  i = 1;
  }
  {
#line 2255
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2256
    tmp = request_reply(& request, & reply, 5, 0);
    }
#line 2256
    if (tmp) {
      {
#line 2257
      ref_id = ntohl(reply.data.tracking.ref_id);
#line 2258
      a = ref_id >> 24;
#line 2259
      b = (ref_id >> 16) & 255U;
#line 2260
      c = (ref_id >> 8) & 255U;
#line 2261
      d = ref_id & 255U;
#line 2263
      correction = UTI_FloatNetworkToHost(reply.data.tracking.current_correction);
#line 2264
      correction = fabs(correction);
#line 2265
      skew_ppm = UTI_FloatNetworkToHost(reply.data.tracking.skew_ppm);
#line 2267
      printf((char const   */* __restrict  */)"try: %d, refid: %d.%d.%d.%d, correction: %.9f, skew: %.3f\n",
             i, a, b, c, d, correction, skew_ppm);
      }
#line 2270
      if (ref_id != 0U) {
#line 2270
        if ((long )ref_id != 2139029761L) {
#line 2270
          if (max_correction == 0.0) {
#line 2270
            goto _L;
          } else
#line 2270
          if (correction <= max_correction) {
            _L: /* CIL Label */ 
#line 2270
            if (max_skew_ppm == 0.0) {
#line 2273
              ret = 1;
            } else
#line 2270
            if (skew_ppm <= max_skew_ppm) {
#line 2273
              ret = 1;
            }
          }
        }
      }
    }
#line 2277
    if (! ret) {
#line 2277
      if (! max_tries) {
        {
#line 2278
        sleep(10U);
        }
      } else
#line 2277
      if (i < max_tries) {
        {
#line 2278
        sleep(10U);
        }
      } else {
#line 2280
        goto while_break;
      }
    } else {
#line 2280
      goto while_break;
    }
#line 2255
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2283
  return (ret);
}
}
#line 2288 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static int process_cmd_dns(char const   *line___0 ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 2291
  tmp___3 = strcmp(line___0, "-46");
  }
#line 2291
  if (tmp___3) {
    {
#line 2293
    tmp___2 = strcmp(line___0, "-4");
    }
#line 2293
    if (tmp___2) {
      {
#line 2295
      tmp___1 = strcmp(line___0, "-6");
      }
#line 2295
      if (tmp___1) {
        {
#line 2297
        tmp___0 = strcmp(line___0, "-n");
        }
#line 2297
        if (tmp___0) {
          {
#line 2299
          tmp = strcmp(line___0, "+n");
          }
#line 2299
          if (tmp) {
            {
#line 2302
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unrecognized dns command\n");
            }
#line 2303
            return (0);
          } else {
#line 2300
            no_dns = 0;
          }
        } else {
#line 2298
          no_dns = 1;
        }
      } else {
        {
#line 2296
        DNS_SetAddressFamily(2);
        }
      }
    } else {
      {
#line 2294
      DNS_SetAddressFamily(1);
      }
    }
  } else {
    {
#line 2292
    DNS_SetAddressFamily(0);
    }
  }
#line 2305
  return (1);
}
}
#line 2310 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static int process_cmd_authhash(char const   *line___0 ) 
{ 
  char const   *hash_name ;
  int new_hash_id ;

  {
#line 2316
  if (! (auth_hash_id >= 0)) {
    {
#line 2316
    __assert_fail("auth_hash_id >= 0", "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c",
                  2316U, "process_cmd_authhash");
    }
  }
#line 2317
  hash_name = line___0;
#line 2319
  if (! *hash_name) {
    {
#line 2320
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not parse hash name\n");
    }
#line 2321
    return (0);
  }
  {
#line 2324
  new_hash_id = HSH_GetHashId(hash_name);
  }
#line 2325
  if (new_hash_id < 0) {
    {
#line 2326
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unknown hash name: %s\n",
            hash_name);
    }
#line 2327
    return (0);
  }
#line 2330
  auth_hash_id = new_hash_id;
#line 2332
  return (1);
}
}
#line 2337 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static int process_cmd_timeout(char const   *line___0 ) 
{ 
  int timeout ;

  {
  {
#line 2342
  timeout = atoi(line___0);
  }
#line 2343
  if (timeout < 100) {
    {
#line 2344
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Timeout %d is too short\n",
            timeout);
    }
#line 2345
    return (0);
  }
#line 2347
  initial_timeout = timeout;
#line 2348
  return (1);
}
}
#line 2353 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static int process_cmd_retries(char const   *line___0 ) 
{ 
  int retries ;

  {
  {
#line 2358
  retries = atoi(line___0);
  }
#line 2359
  if (retries < 0) {
    {
#line 2360
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid maximum number of retries\n");
    }
#line 2361
    return (0);
  }
#line 2363
  max_retries = retries;
#line 2364
  return (1);
}
}
#line 2369 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static int process_line(char *line___0 , int *quit ) 
{ 
  char *command ;
  int do_normal_submit ;
  int ret ;
  CMD_Request tx_message ;
  CMD_Reply rx_message ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;

  {
  {
#line 2378
  *quit = 0;
#line 2379
  ret = 0;
#line 2381
  do_normal_submit = 1;
#line 2383
  CPS_NormalizeLine(line___0);
  }
#line 2385
  if (! *line___0) {
    {
#line 2386
    fflush(stderr);
#line 2387
    fflush(stdout);
    }
#line 2388
    return (1);
  }
  {
#line 2391
  command = line___0;
#line 2392
  line___0 = CPS_SplitWord(line___0);
#line 2394
  tmp___61 = strcmp((char const   *)command, "accheck");
  }
#line 2394
  if (tmp___61) {
    {
#line 2396
    tmp___60 = strcmp((char const   *)command, "activity");
    }
#line 2396
    if (tmp___60) {
      {
#line 2399
      tmp___58 = strcmp((char const   *)command, "add");
      }
#line 2399
      if (tmp___58) {
        _L___0: /* CIL Label */ 
        {
#line 2401
        tmp___56 = strcmp((char const   *)command, "add");
        }
#line 2401
        if (tmp___56) {
          _L: /* CIL Label */ 
          {
#line 2403
          tmp___55 = strcmp((char const   *)command, "allow");
          }
#line 2403
          if (tmp___55) {
            {
#line 2409
            tmp___54 = strcmp((char const   *)command, "authhash");
            }
#line 2409
            if (tmp___54) {
              {
#line 2412
              tmp___53 = strcmp((char const   *)command, "burst");
              }
#line 2412
              if (tmp___53) {
                {
#line 2414
                tmp___52 = strcmp((char const   *)command, "clients");
                }
#line 2414
                if (tmp___52) {
                  {
#line 2417
                  tmp___51 = strcmp((char const   *)command, "cmdaccheck");
                  }
#line 2417
                  if (tmp___51) {
                    {
#line 2419
                    tmp___50 = strcmp((char const   *)command, "cmdallow");
                    }
#line 2419
                    if (tmp___50) {
                      {
#line 2425
                      tmp___49 = strcmp((char const   *)command, "cmddeny");
                      }
#line 2425
                      if (tmp___49) {
                        {
#line 2432
                        tmp___48 = strcmp((char const   *)command, "cyclelogs");
                        }
#line 2432
                        if (tmp___48) {
                          {
#line 2434
                          tmp___47 = strcmp((char const   *)command, "delete");
                          }
#line 2434
                          if (tmp___47) {
                            {
#line 2436
                            tmp___46 = strcmp((char const   *)command, "deny");
                            }
#line 2436
                            if (tmp___46) {
                              {
#line 2442
                              tmp___45 = strcmp((char const   *)command, "dfreq");
                              }
#line 2442
                              if (tmp___45) {
                                {
#line 2444
                                tmp___44 = strcmp((char const   *)command, "dns");
                                }
#line 2444
                                if (tmp___44) {
                                  {
#line 2447
                                  tmp___43 = strcmp((char const   *)command, "doffset");
                                  }
#line 2447
                                  if (tmp___43) {
                                    {
#line 2449
                                    tmp___42 = strcmp((char const   *)command, "dump");
                                    }
#line 2449
                                    if (tmp___42) {
                                      {
#line 2451
                                      tmp___41 = strcmp((char const   *)command, "exit");
                                      }
#line 2451
                                      if (tmp___41) {
                                        {
#line 2455
                                        tmp___40 = strcmp((char const   *)command,
                                                          "help");
                                        }
#line 2455
                                        if (tmp___40) {
                                          {
#line 2459
                                          tmp___39 = strcmp((char const   *)command,
                                                            "local");
                                          }
#line 2459
                                          if (tmp___39) {
                                            {
#line 2461
                                            tmp___38 = strcmp((char const   *)command,
                                                              "makestep");
                                            }
#line 2461
                                            if (tmp___38) {
                                              {
#line 2463
                                              tmp___37 = strcmp((char const   *)command,
                                                                "manual");
                                              }
#line 2463
                                              if (tmp___37) {
                                                {
#line 2472
                                                tmp___36 = strcmp((char const   *)command,
                                                                  "maxdelay");
                                                }
#line 2472
                                                if (tmp___36) {
                                                  {
#line 2474
                                                  tmp___35 = strcmp((char const   *)command,
                                                                    "maxdelaydevratio");
                                                  }
#line 2474
                                                  if (tmp___35) {
                                                    {
#line 2476
                                                    tmp___34 = strcmp((char const   *)command,
                                                                      "maxdelayratio");
                                                    }
#line 2476
                                                    if (tmp___34) {
                                                      {
#line 2478
                                                      tmp___33 = strcmp((char const   *)command,
                                                                        "maxpoll");
                                                      }
#line 2478
                                                      if (tmp___33) {
                                                        {
#line 2480
                                                        tmp___32 = strcmp((char const   *)command,
                                                                          "maxupdateskew");
                                                        }
#line 2480
                                                        if (tmp___32) {
                                                          {
#line 2482
                                                          tmp___31 = strcmp((char const   *)command,
                                                                            "minpoll");
                                                          }
#line 2482
                                                          if (tmp___31) {
                                                            {
#line 2484
                                                            tmp___30 = strcmp((char const   *)command,
                                                                              "minstratum");
                                                            }
#line 2484
                                                            if (tmp___30) {
                                                              {
#line 2486
                                                              tmp___29 = strcmp((char const   *)command,
                                                                                "offline");
                                                              }
#line 2486
                                                              if (tmp___29) {
                                                                {
#line 2488
                                                                tmp___28 = strcmp((char const   *)command,
                                                                                  "online");
                                                                }
#line 2488
                                                                if (tmp___28) {
                                                                  {
#line 2490
                                                                  tmp___27 = strcmp((char const   *)command,
                                                                                    "password");
                                                                  }
#line 2490
                                                                  if (tmp___27) {
                                                                    {
#line 2492
                                                                    tmp___26 = strcmp((char const   *)command,
                                                                                      "polltarget");
                                                                    }
#line 2492
                                                                    if (tmp___26) {
                                                                      {
#line 2494
                                                                      tmp___25 = strcmp((char const   *)command,
                                                                                        "quit");
                                                                      }
#line 2494
                                                                      if (tmp___25) {
                                                                        {
#line 2498
                                                                        tmp___24 = strcmp((char const   *)command,
                                                                                          "rekey");
                                                                        }
#line 2498
                                                                        if (tmp___24) {
                                                                          {
#line 2500
                                                                          tmp___23 = strcmp((char const   *)command,
                                                                                            "reselect");
                                                                          }
#line 2500
                                                                          if (tmp___23) {
                                                                            {
#line 2502
                                                                            tmp___22 = strcmp((char const   *)command,
                                                                                              "reselectdist");
                                                                            }
#line 2502
                                                                            if (tmp___22) {
                                                                              {
#line 2504
                                                                              tmp___21 = strcmp((char const   *)command,
                                                                                                "retries");
                                                                              }
#line 2504
                                                                              if (tmp___21) {
                                                                                {
#line 2507
                                                                                tmp___20 = strcmp((char const   *)command,
                                                                                                  "rtcdata");
                                                                                }
#line 2507
                                                                                if (tmp___20) {
                                                                                  {
#line 2510
                                                                                  tmp___19 = strcmp((char const   *)command,
                                                                                                    "settime");
                                                                                  }
#line 2510
                                                                                  if (tmp___19) {
                                                                                    {
#line 2513
                                                                                    tmp___18 = strcmp((char const   *)command,
                                                                                                      "sources");
                                                                                    }
#line 2513
                                                                                    if (tmp___18) {
                                                                                      {
#line 2516
                                                                                      tmp___17 = strcmp((char const   *)command,
                                                                                                        "sourcestats");
                                                                                      }
#line 2516
                                                                                      if (tmp___17) {
                                                                                        {
#line 2519
                                                                                        tmp___16 = strcmp((char const   *)command,
                                                                                                          "timeout");
                                                                                        }
#line 2519
                                                                                        if (tmp___16) {
                                                                                          {
#line 2522
                                                                                          tmp___15 = strcmp((char const   *)command,
                                                                                                            "tracking");
                                                                                          }
#line 2522
                                                                                          if (tmp___15) {
                                                                                            {
#line 2525
                                                                                            tmp___14 = strcmp((char const   *)command,
                                                                                                              "trimrtc");
                                                                                            }
#line 2525
                                                                                            if (tmp___14) {
                                                                                              {
#line 2527
                                                                                              tmp___13 = strcmp((char const   *)command,
                                                                                                                "waitsync");
                                                                                              }
#line 2527
                                                                                              if (tmp___13) {
                                                                                                {
#line 2530
                                                                                                tmp___12 = strcmp((char const   *)command,
                                                                                                                  "writertc");
                                                                                                }
#line 2530
                                                                                                if (tmp___12) {
                                                                                                  {
#line 2533
                                                                                                  fprintf((FILE */* __restrict  */)stderr,
                                                                                                          (char const   */* __restrict  */)"Unrecognized command\n");
#line 2534
                                                                                                  do_normal_submit = 0;
                                                                                                  }
                                                                                                } else {
                                                                                                  {
#line 2531
                                                                                                  process_cmd_writertc(& tx_message,
                                                                                                                       line___0);
                                                                                                  }
                                                                                                }
                                                                                              } else {
                                                                                                {
#line 2528
                                                                                                ret = process_cmd_waitsync(line___0);
#line 2529
                                                                                                do_normal_submit = 0;
                                                                                                }
                                                                                              }
                                                                                            } else {
                                                                                              {
#line 2526
                                                                                              process_cmd_trimrtc(& tx_message,
                                                                                                                  line___0);
                                                                                              }
                                                                                            }
                                                                                          } else {
                                                                                            {
#line 2523
                                                                                            ret = process_cmd_tracking(line___0);
#line 2524
                                                                                            do_normal_submit = 0;
                                                                                            }
                                                                                          }
                                                                                        } else {
                                                                                          {
#line 2520
                                                                                          ret = process_cmd_timeout((char const   *)line___0);
#line 2521
                                                                                          do_normal_submit = 0;
                                                                                          }
                                                                                        }
                                                                                      } else {
                                                                                        {
#line 2517
                                                                                        do_normal_submit = 0;
#line 2518
                                                                                        ret = process_cmd_sourcestats(line___0);
                                                                                        }
                                                                                      }
                                                                                    } else {
                                                                                      {
#line 2514
                                                                                      do_normal_submit = 0;
#line 2515
                                                                                      ret = process_cmd_sources(line___0);
                                                                                      }
                                                                                    }
                                                                                  } else {
                                                                                    {
#line 2511
                                                                                    do_normal_submit = 0;
#line 2512
                                                                                    ret = process_cmd_settime(line___0);
                                                                                    }
                                                                                  }
                                                                                } else {
                                                                                  {
#line 2508
                                                                                  do_normal_submit = 0;
#line 2509
                                                                                  ret = process_cmd_rtcreport(line___0);
                                                                                  }
                                                                                }
                                                                              } else {
                                                                                {
#line 2505
                                                                                ret = process_cmd_retries((char const   *)line___0);
#line 2506
                                                                                do_normal_submit = 0;
                                                                                }
                                                                              }
                                                                            } else {
                                                                              {
#line 2503
                                                                              do_normal_submit = process_cmd_reselectdist(& tx_message,
                                                                                                                          line___0);
                                                                              }
                                                                            }
                                                                          } else {
                                                                            {
#line 2501
                                                                            process_cmd_reselect(& tx_message,
                                                                                                 line___0);
                                                                            }
                                                                          }
                                                                        } else {
                                                                          {
#line 2499
                                                                          process_cmd_rekey(& tx_message,
                                                                                            line___0);
                                                                          }
                                                                        }
                                                                      } else {
#line 2495
                                                                        do_normal_submit = 0;
#line 2496
                                                                        *quit = 1;
#line 2497
                                                                        ret = 1;
                                                                      }
                                                                    } else {
                                                                      {
#line 2493
                                                                      do_normal_submit = process_cmd_polltarget(& tx_message,
                                                                                                                line___0);
                                                                      }
                                                                    }
                                                                  } else {
                                                                    {
#line 2491
                                                                    do_normal_submit = process_cmd_password(& tx_message,
                                                                                                            line___0);
                                                                    }
                                                                  }
                                                                } else {
                                                                  {
#line 2489
                                                                  do_normal_submit = process_cmd_online(& tx_message,
                                                                                                        line___0);
                                                                  }
                                                                }
                                                              } else {
                                                                {
#line 2487
                                                                do_normal_submit = process_cmd_offline(& tx_message,
                                                                                                       line___0);
                                                                }
                                                              }
                                                            } else {
                                                              {
#line 2485
                                                              do_normal_submit = process_cmd_minstratum(& tx_message,
                                                                                                        line___0);
                                                              }
                                                            }
                                                          } else {
                                                            {
#line 2483
                                                            do_normal_submit = process_cmd_minpoll(& tx_message,
                                                                                                   line___0);
                                                            }
                                                          }
                                                        } else {
                                                          {
#line 2481
                                                          do_normal_submit = process_cmd_maxupdateskew(& tx_message,
                                                                                                       line___0);
                                                          }
                                                        }
                                                      } else {
                                                        {
#line 2479
                                                        do_normal_submit = process_cmd_maxpoll(& tx_message,
                                                                                               line___0);
                                                        }
                                                      }
                                                    } else {
                                                      {
#line 2477
                                                      do_normal_submit = process_cmd_maxdelayratio(& tx_message,
                                                                                                   line___0);
                                                      }
                                                    }
                                                  } else {
                                                    {
#line 2475
                                                    do_normal_submit = process_cmd_maxdelaydevratio(& tx_message,
                                                                                                    line___0);
                                                    }
                                                  }
                                                } else {
                                                  {
#line 2473
                                                  do_normal_submit = process_cmd_maxdelay(& tx_message,
                                                                                          line___0);
                                                  }
                                                }
                                              } else {
                                                {
#line 2464
                                                tmp___11 = strncmp((char const   *)line___0,
                                                                   "list", (size_t )4);
                                                }
#line 2464
                                                if (tmp___11) {
                                                  {
#line 2467
                                                  tmp___10 = strncmp((char const   *)line___0,
                                                                     "delete", (size_t )6);
                                                  }
#line 2467
                                                  if (tmp___10) {
                                                    {
#line 2470
                                                    do_normal_submit = process_cmd_manual(& tx_message,
                                                                                          (char const   *)line___0);
                                                    }
                                                  } else {
                                                    {
#line 2468
                                                    tmp___9 = CPS_SplitWord(line___0);
#line 2468
                                                    do_normal_submit = process_cmd_manual_delete(& tx_message,
                                                                                                 (char const   *)tmp___9);
                                                    }
                                                  }
                                                } else {
                                                  {
#line 2465
                                                  do_normal_submit = 0;
#line 2466
                                                  tmp___8 = CPS_SplitWord(line___0);
#line 2466
                                                  ret = process_cmd_manual_list((char const   *)tmp___8);
                                                  }
                                                }
                                              }
                                            } else {
                                              {
#line 2462
                                              process_cmd_makestep(& tx_message, line___0);
                                              }
                                            }
                                          } else {
                                            {
#line 2460
                                            do_normal_submit = process_cmd_local(& tx_message,
                                                                                 (char const   *)line___0);
                                            }
                                          }
                                        } else {
                                          {
#line 2456
                                          do_normal_submit = 0;
#line 2457
                                          give_help();
#line 2458
                                          ret = 1;
                                          }
                                        }
                                      } else {
#line 2452
                                        do_normal_submit = 0;
#line 2453
                                        *quit = 1;
#line 2454
                                        ret = 1;
                                      }
                                    } else {
                                      {
#line 2450
                                      process_cmd_dump(& tx_message, line___0);
                                      }
                                    }
                                  } else {
                                    {
#line 2448
                                    process_cmd_doffset(& tx_message, line___0);
                                    }
                                  }
                                } else {
                                  {
#line 2445
                                  ret = process_cmd_dns((char const   *)line___0);
#line 2446
                                  do_normal_submit = 0;
                                  }
                                }
                              } else {
                                {
#line 2443
                                process_cmd_dfreq(& tx_message, line___0);
                                }
                              }
                            } else {
                              {
#line 2437
                              tmp___7 = strncmp((char const   *)line___0, "all", (size_t )3);
                              }
#line 2437
                              if (tmp___7) {
                                {
#line 2440
                                do_normal_submit = process_cmd_deny(& tx_message,
                                                                    line___0);
                                }
                              } else {
                                {
#line 2438
                                tmp___6 = CPS_SplitWord(line___0);
#line 2438
                                do_normal_submit = process_cmd_denyall(& tx_message,
                                                                       tmp___6);
                                }
                              }
                            }
                          } else {
                            {
#line 2435
                            do_normal_submit = process_cmd_delete(& tx_message, line___0);
                            }
                          }
                        } else {
                          {
#line 2433
                          process_cmd_cyclelogs(& tx_message, line___0);
                          }
                        }
                      } else {
                        {
#line 2426
                        tmp___5 = strncmp((char const   *)line___0, "all", (size_t )3);
                        }
#line 2426
                        if (tmp___5) {
                          {
#line 2430
                          do_normal_submit = process_cmd_cmddeny(& tx_message, line___0);
                          }
                        } else {
                          {
#line 2427
                          line___0 = CPS_SplitWord(line___0);
#line 2428
                          do_normal_submit = process_cmd_cmddenyall(& tx_message,
                                                                    line___0);
                          }
                        }
                      }
                    } else {
                      {
#line 2420
                      tmp___4 = strncmp((char const   *)line___0, "all", (size_t )3);
                      }
#line 2420
                      if (tmp___4) {
                        {
#line 2423
                        do_normal_submit = process_cmd_cmdallow(& tx_message, line___0);
                        }
                      } else {
                        {
#line 2421
                        tmp___3 = CPS_SplitWord(line___0);
#line 2421
                        do_normal_submit = process_cmd_cmdallowall(& tx_message, tmp___3);
                        }
                      }
                    }
                  } else {
                    {
#line 2418
                    do_normal_submit = process_cmd_cmdaccheck(& tx_message, line___0);
                    }
                  }
                } else {
                  {
#line 2415
                  ret = process_cmd_clients(line___0);
#line 2416
                  do_normal_submit = 0;
                  }
                }
              } else {
                {
#line 2413
                do_normal_submit = process_cmd_burst(& tx_message, line___0);
                }
              }
            } else {
              {
#line 2410
              ret = process_cmd_authhash((char const   *)line___0);
#line 2411
              do_normal_submit = 0;
              }
            }
          } else {
            {
#line 2404
            tmp___2 = strncmp((char const   *)line___0, "all", (size_t )3);
            }
#line 2404
            if (tmp___2) {
              {
#line 2407
              do_normal_submit = process_cmd_allow(& tx_message, line___0);
              }
            } else {
              {
#line 2405
              tmp___1 = CPS_SplitWord(line___0);
#line 2405
              do_normal_submit = process_cmd_allowall(& tx_message, tmp___1);
              }
            }
          }
        } else {
          {
#line 2401
          tmp___57 = strncmp((char const   *)line___0, "server", (size_t )6);
          }
#line 2401
          if (tmp___57) {
#line 2401
            goto _L;
          } else {
            {
#line 2402
            tmp___0 = CPS_SplitWord(line___0);
#line 2402
            do_normal_submit = process_cmd_add_server(& tx_message, tmp___0);
            }
          }
        }
      } else {
        {
#line 2399
        tmp___59 = strncmp((char const   *)line___0, "peer", (size_t )4);
        }
#line 2399
        if (tmp___59) {
#line 2399
          goto _L___0;
        } else {
          {
#line 2400
          tmp = CPS_SplitWord(line___0);
#line 2400
          do_normal_submit = process_cmd_add_peer(& tx_message, tmp);
          }
        }
      }
    } else {
      {
#line 2397
      do_normal_submit = 0;
#line 2398
      ret = process_cmd_activity((char const   *)line___0);
      }
    }
  } else {
    {
#line 2395
    do_normal_submit = process_cmd_accheck(& tx_message, line___0);
    }
  }
#line 2537
  if (do_normal_submit) {
    {
#line 2538
    ret = request_reply(& tx_message, & rx_message, 1, 1);
    }
  }
  {
#line 2540
  fflush(stderr);
#line 2541
  fflush(stdout);
  }
#line 2542
  return (ret);
}
}
#line 2547 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static int authenticate_from_config(char const   *filename___0 ) 
{ 
  CMD_Request tx_message ;
  CMD_Reply rx_message ;
  char line___0[2048] ;
  char keyfile[2048] ;
  char *command ;
  char *arg ;
  char *password___0 ;
  char const   *hashname ;
  unsigned long key_id ;
  unsigned long key_id2 ;
  int ret ;
  FILE *in ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 2554
  key_id = 0UL;
#line 2554
  key_id2 = 0xffffffffffffffffUL;
#line 2558
  in = fopen((char const   */* __restrict  */)filename___0, (char const   */* __restrict  */)"r");
  }
#line 2559
  if (! in) {
    {
#line 2560
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not open file %s\n",
            filename___0);
    }
#line 2561
    return (0);
  }
#line 2564
  keyfile[0] = (char )'\000';
  {
#line 2565
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2565
    tmp___2 = fgets((char */* __restrict  */)(line___0), (int )sizeof(line___0), (FILE */* __restrict  */)in);
    }
#line 2565
    if (! tmp___2) {
#line 2565
      goto while_break;
    }
    {
#line 2566
    CPS_NormalizeLine(line___0);
#line 2567
    command = line___0;
#line 2568
    arg = CPS_SplitWord(line___0);
#line 2569
    tmp___1 = strcasecmp((char const   *)command, "keyfile");
    }
#line 2569
    if (tmp___1) {
      {
#line 2571
      tmp___0 = strcasecmp((char const   *)command, "commandkey");
      }
#line 2571
      if (! tmp___0) {
        {
#line 2572
        tmp = sscanf((char const   */* __restrict  */)arg, (char const   */* __restrict  */)"%lu",
                     & key_id);
        }
#line 2572
        if (tmp != 1) {
#line 2573
          key_id = 0xffffffffffffffffUL;
        }
      }
    } else {
      {
#line 2570
      snprintf((char */* __restrict  */)(keyfile), sizeof(keyfile), (char const   */* __restrict  */)"%s",
               arg);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2576
  fclose(in);
  }
#line 2578
  if (! keyfile[0]) {
    {
#line 2579
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not read keyfile or commandkey in file %s\n",
            filename___0);
    }
#line 2580
    return (0);
  } else
#line 2578
  if (key_id == 0xffffffffffffffffUL) {
    {
#line 2579
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not read keyfile or commandkey in file %s\n",
            filename___0);
    }
#line 2580
    return (0);
  }
  {
#line 2583
  in = fopen((char const   */* __restrict  */)(keyfile), (char const   */* __restrict  */)"r");
  }
#line 2584
  if (! in) {
    {
#line 2585
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not open keyfile %s\n",
            filename___0);
    }
#line 2586
    return (0);
  }
  {
#line 2589
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 2589
    tmp___4 = fgets((char */* __restrict  */)(line___0), (int )sizeof(line___0), (FILE */* __restrict  */)in);
    }
#line 2589
    if (! tmp___4) {
#line 2589
      goto while_break___0;
    }
    {
#line 2590
    CPS_NormalizeLine(line___0);
    }
#line 2591
    if (! line___0[0]) {
#line 2592
      goto while_continue___0;
    } else {
      {
#line 2591
      tmp___3 = CPS_ParseKey(line___0, & key_id2, & hashname, & password___0);
      }
#line 2591
      if (! tmp___3) {
#line 2592
        goto while_continue___0;
      }
    }
#line 2593
    if (key_id == key_id2) {
#line 2594
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2596
  fclose(in);
  }
#line 2598
  if (key_id == key_id2) {
    {
#line 2599
    tmp___5 = process_cmd_authhash(hashname);
    }
#line 2599
    if (tmp___5) {
      {
#line 2599
      tmp___6 = process_cmd_password(& tx_message, password___0);
      }
#line 2599
      if (tmp___6) {
        {
#line 2601
        ret = request_reply(& tx_message, & rx_message, 1, 1);
        }
      } else {
#line 2603
        ret = 0;
      }
    } else {
#line 2603
      ret = 0;
    }
  } else {
    {
#line 2606
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not find key %lu in keyfile %s\n",
            key_id, keyfile);
#line 2607
    ret = 0;
    }
  }
  {
#line 2611
  memset((void *)(line___0), 0, sizeof(line___0));
  }
#line 2613
  return (ret);
}
}
#line 2618 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static int process_args(int argc , char **argv , int multi ) 
{ 
  int total_length ;
  int i ;
  int ret ;
  int quit ;
  char *line___0 ;
  size_t tmp ;
  void *tmp___0 ;

  {
#line 2624
  total_length = 0;
#line 2625
  i = 0;
  {
#line 2625
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2625
    if (! (i < argc)) {
#line 2625
      goto while_break;
    }
    {
#line 2626
    tmp = strlen((char const   *)*(argv + i));
#line 2626
    total_length = (int )((size_t )total_length + (tmp + 1UL));
#line 2625
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2629
  tmp___0 = malloc((unsigned long )(2 + total_length) * sizeof(char ));
#line 2629
  line___0 = (char *)tmp___0;
#line 2631
  i = 0;
  }
  {
#line 2631
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2631
    if (! (i < argc)) {
#line 2631
      goto while_break___0;
    }
#line 2632
    *(line___0 + 0) = (char )'\000';
#line 2633
    if (multi) {
      {
#line 2634
      strcat((char */* __restrict  */)line___0, (char const   */* __restrict  */)*(argv + i));
      }
    } else {
      {
#line 2636
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2636
        if (! (i < argc)) {
#line 2636
          goto while_break___1;
        }
        {
#line 2637
        strcat((char */* __restrict  */)line___0, (char const   */* __restrict  */)*(argv + i));
        }
#line 2638
        if (i + 1 < argc) {
          {
#line 2639
          strcat((char */* __restrict  */)line___0, (char const   */* __restrict  */)" ");
          }
        }
#line 2636
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    {
#line 2643
    ret = process_line(line___0, & quit);
    }
#line 2644
    if (! ret) {
#line 2645
      goto while_break___0;
    } else
#line 2644
    if (quit) {
#line 2645
      goto while_break___0;
    }
#line 2631
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2648
  free((void *)line___0);
  }
#line 2650
  return (ret);
}
}
#line 2655 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/client.c"
static void display_gpl(void) 
{ 


  {
  {
#line 2658
  printf((char const   */* __restrict  */)"chrony version %s\nCopyright (C) 1997-2003, 2007, 2009-2013 Richard P. Curnow and others\nchrony comes with ABSOLUTELY NO WARRANTY.  This is free software, and\nyou are welcome to redistribute it under certain conditions.  See the\nGNU General Public License version 2 for details.\n\n",
         "1.29");
  }
#line 2664
  return;
}
}
#line 38 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/nameserv.c"
static int address_family___0  =    0;
#line 205 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/util.c"
static char buffer_pool___0[16][64]  ;
#line 206 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/util.c"
static int pool_ptr___0  =    0;
#line 337 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/util.c"
static int MD5_hash___0  =    -1;
#line 54 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/md5.c"
static void Transform___0(UINT4 *buf , UINT4 *in ) ;
#line 57 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/md5.c"
static unsigned char const   PADDING___0[64]  = 
#line 57
  {      (unsigned char const   )128,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0};
#line 217 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/md5.c"
static void Transform___0(UINT4 *buf , UINT4 *in ) 
{ 
  UINT4 a ;
  UINT4 b ;
  UINT4 c ;
  UINT4 d ;

  {
#line 221
  a = *(buf + 0);
#line 221
  b = *(buf + 1);
#line 221
  c = *(buf + 2);
#line 221
  d = *(buf + 3);
#line 229
  a += (((b & c) | (~ b & d)) + *(in + 0)) + 3614090360U;
#line 229
  a = (a << 7) | (a >> 25);
#line 229
  a += b;
#line 230
  d += (((a & b) | (~ a & c)) + *(in + 1)) + 3905402710U;
#line 230
  d = (d << 12) | (d >> 20);
#line 230
  d += a;
#line 231
  c += (((d & a) | (~ d & b)) + *(in + 2)) + 606105819U;
#line 231
  c = (c << 17) | (c >> 15);
#line 231
  c += d;
#line 232
  b += (((c & d) | (~ c & a)) + *(in + 3)) + 3250441966U;
#line 232
  b = (b << 22) | (b >> 10);
#line 232
  b += c;
#line 233
  a += (((b & c) | (~ b & d)) + *(in + 4)) + 4118548399U;
#line 233
  a = (a << 7) | (a >> 25);
#line 233
  a += b;
#line 234
  d += (((a & b) | (~ a & c)) + *(in + 5)) + 1200080426U;
#line 234
  d = (d << 12) | (d >> 20);
#line 234
  d += a;
#line 235
  c += (((d & a) | (~ d & b)) + *(in + 6)) + 2821735955U;
#line 235
  c = (c << 17) | (c >> 15);
#line 235
  c += d;
#line 236
  b += (((c & d) | (~ c & a)) + *(in + 7)) + 4249261313U;
#line 236
  b = (b << 22) | (b >> 10);
#line 236
  b += c;
#line 237
  a += (((b & c) | (~ b & d)) + *(in + 8)) + 1770035416U;
#line 237
  a = (a << 7) | (a >> 25);
#line 237
  a += b;
#line 238
  d += (((a & b) | (~ a & c)) + *(in + 9)) + 2336552879U;
#line 238
  d = (d << 12) | (d >> 20);
#line 238
  d += a;
#line 239
  c += (((d & a) | (~ d & b)) + *(in + 10)) + 4294925233U;
#line 239
  c = (c << 17) | (c >> 15);
#line 239
  c += d;
#line 240
  b += (((c & d) | (~ c & a)) + *(in + 11)) + 2304563134U;
#line 240
  b = (b << 22) | (b >> 10);
#line 240
  b += c;
#line 241
  a += (((b & c) | (~ b & d)) + *(in + 12)) + 1804603682U;
#line 241
  a = (a << 7) | (a >> 25);
#line 241
  a += b;
#line 242
  d += (((a & b) | (~ a & c)) + *(in + 13)) + 4254626195U;
#line 242
  d = (d << 12) | (d >> 20);
#line 242
  d += a;
#line 243
  c += (((d & a) | (~ d & b)) + *(in + 14)) + 2792965006U;
#line 243
  c = (c << 17) | (c >> 15);
#line 243
  c += d;
#line 244
  b += (((c & d) | (~ c & a)) + *(in + 15)) + 1236535329U;
#line 244
  b = (b << 22) | (b >> 10);
#line 244
  b += c;
#line 251
  a += (((b & d) | (c & ~ d)) + *(in + 1)) + 4129170786U;
#line 251
  a = (a << 5) | (a >> 27);
#line 251
  a += b;
#line 252
  d += (((a & c) | (b & ~ c)) + *(in + 6)) + 3225465664U;
#line 252
  d = (d << 9) | (d >> 23);
#line 252
  d += a;
#line 253
  c += (((d & b) | (a & ~ b)) + *(in + 11)) + 643717713U;
#line 253
  c = (c << 14) | (c >> 18);
#line 253
  c += d;
#line 254
  b += (((c & a) | (d & ~ a)) + *(in + 0)) + 3921069994U;
#line 254
  b = (b << 20) | (b >> 12);
#line 254
  b += c;
#line 255
  a += (((b & d) | (c & ~ d)) + *(in + 5)) + 3593408605U;
#line 255
  a = (a << 5) | (a >> 27);
#line 255
  a += b;
#line 256
  d += (((a & c) | (b & ~ c)) + *(in + 10)) + 38016083U;
#line 256
  d = (d << 9) | (d >> 23);
#line 256
  d += a;
#line 257
  c += (((d & b) | (a & ~ b)) + *(in + 15)) + 3634488961U;
#line 257
  c = (c << 14) | (c >> 18);
#line 257
  c += d;
#line 258
  b += (((c & a) | (d & ~ a)) + *(in + 4)) + 3889429448U;
#line 258
  b = (b << 20) | (b >> 12);
#line 258
  b += c;
#line 259
  a += (((b & d) | (c & ~ d)) + *(in + 9)) + 568446438U;
#line 259
  a = (a << 5) | (a >> 27);
#line 259
  a += b;
#line 260
  d += (((a & c) | (b & ~ c)) + *(in + 14)) + 3275163606U;
#line 260
  d = (d << 9) | (d >> 23);
#line 260
  d += a;
#line 261
  c += (((d & b) | (a & ~ b)) + *(in + 3)) + 4107603335U;
#line 261
  c = (c << 14) | (c >> 18);
#line 261
  c += d;
#line 262
  b += (((c & a) | (d & ~ a)) + *(in + 8)) + 1163531501U;
#line 262
  b = (b << 20) | (b >> 12);
#line 262
  b += c;
#line 263
  a += (((b & d) | (c & ~ d)) + *(in + 13)) + 2850285829U;
#line 263
  a = (a << 5) | (a >> 27);
#line 263
  a += b;
#line 264
  d += (((a & c) | (b & ~ c)) + *(in + 2)) + 4243563512U;
#line 264
  d = (d << 9) | (d >> 23);
#line 264
  d += a;
#line 265
  c += (((d & b) | (a & ~ b)) + *(in + 7)) + 1735328473U;
#line 265
  c = (c << 14) | (c >> 18);
#line 265
  c += d;
#line 266
  b += (((c & a) | (d & ~ a)) + *(in + 12)) + 2368359562U;
#line 266
  b = (b << 20) | (b >> 12);
#line 266
  b += c;
#line 273
  a += (((b ^ c) ^ d) + *(in + 5)) + 4294588738U;
#line 273
  a = (a << 4) | (a >> 28);
#line 273
  a += b;
#line 274
  d += (((a ^ b) ^ c) + *(in + 8)) + 2272392833U;
#line 274
  d = (d << 11) | (d >> 21);
#line 274
  d += a;
#line 275
  c += (((d ^ a) ^ b) + *(in + 11)) + 1839030562U;
#line 275
  c = (c << 16) | (c >> 16);
#line 275
  c += d;
#line 276
  b += (((c ^ d) ^ a) + *(in + 14)) + 4259657740U;
#line 276
  b = (b << 23) | (b >> 9);
#line 276
  b += c;
#line 277
  a += (((b ^ c) ^ d) + *(in + 1)) + 2763975236U;
#line 277
  a = (a << 4) | (a >> 28);
#line 277
  a += b;
#line 278
  d += (((a ^ b) ^ c) + *(in + 4)) + 1272893353U;
#line 278
  d = (d << 11) | (d >> 21);
#line 278
  d += a;
#line 279
  c += (((d ^ a) ^ b) + *(in + 7)) + 4139469664U;
#line 279
  c = (c << 16) | (c >> 16);
#line 279
  c += d;
#line 280
  b += (((c ^ d) ^ a) + *(in + 10)) + 3200236656U;
#line 280
  b = (b << 23) | (b >> 9);
#line 280
  b += c;
#line 281
  a += (((b ^ c) ^ d) + *(in + 13)) + 681279174U;
#line 281
  a = (a << 4) | (a >> 28);
#line 281
  a += b;
#line 282
  d += (((a ^ b) ^ c) + *(in + 0)) + 3936430074U;
#line 282
  d = (d << 11) | (d >> 21);
#line 282
  d += a;
#line 283
  c += (((d ^ a) ^ b) + *(in + 3)) + 3572445317U;
#line 283
  c = (c << 16) | (c >> 16);
#line 283
  c += d;
#line 284
  b += (((c ^ d) ^ a) + *(in + 6)) + 76029189U;
#line 284
  b = (b << 23) | (b >> 9);
#line 284
  b += c;
#line 285
  a += (((b ^ c) ^ d) + *(in + 9)) + 3654602809U;
#line 285
  a = (a << 4) | (a >> 28);
#line 285
  a += b;
#line 286
  d += (((a ^ b) ^ c) + *(in + 12)) + 3873151461U;
#line 286
  d = (d << 11) | (d >> 21);
#line 286
  d += a;
#line 287
  c += (((d ^ a) ^ b) + *(in + 15)) + 530742520U;
#line 287
  c = (c << 16) | (c >> 16);
#line 287
  c += d;
#line 288
  b += (((c ^ d) ^ a) + *(in + 2)) + 3299628645U;
#line 288
  b = (b << 23) | (b >> 9);
#line 288
  b += c;
#line 295
  a += ((c ^ (b | ~ d)) + *(in + 0)) + 4096336452U;
#line 295
  a = (a << 6) | (a >> 26);
#line 295
  a += b;
#line 296
  d += ((b ^ (a | ~ c)) + *(in + 7)) + 1126891415U;
#line 296
  d = (d << 10) | (d >> 22);
#line 296
  d += a;
#line 297
  c += ((a ^ (d | ~ b)) + *(in + 14)) + 2878612391U;
#line 297
  c = (c << 15) | (c >> 17);
#line 297
  c += d;
#line 298
  b += ((d ^ (c | ~ a)) + *(in + 5)) + 4237533241U;
#line 298
  b = (b << 21) | (b >> 11);
#line 298
  b += c;
#line 299
  a += ((c ^ (b | ~ d)) + *(in + 12)) + 1700485571U;
#line 299
  a = (a << 6) | (a >> 26);
#line 299
  a += b;
#line 300
  d += ((b ^ (a | ~ c)) + *(in + 3)) + 2399980690U;
#line 300
  d = (d << 10) | (d >> 22);
#line 300
  d += a;
#line 301
  c += ((a ^ (d | ~ b)) + *(in + 10)) + 4293915773U;
#line 301
  c = (c << 15) | (c >> 17);
#line 301
  c += d;
#line 302
  b += ((d ^ (c | ~ a)) + *(in + 1)) + 2240044497U;
#line 302
  b = (b << 21) | (b >> 11);
#line 302
  b += c;
#line 303
  a += ((c ^ (b | ~ d)) + *(in + 8)) + 1873313359U;
#line 303
  a = (a << 6) | (a >> 26);
#line 303
  a += b;
#line 304
  d += ((b ^ (a | ~ c)) + *(in + 15)) + 4264355552U;
#line 304
  d = (d << 10) | (d >> 22);
#line 304
  d += a;
#line 305
  c += ((a ^ (d | ~ b)) + *(in + 6)) + 2734768916U;
#line 305
  c = (c << 15) | (c >> 17);
#line 305
  c += d;
#line 306
  b += ((d ^ (c | ~ a)) + *(in + 13)) + 1309151649U;
#line 306
  b = (b << 21) | (b >> 11);
#line 306
  b += c;
#line 307
  a += ((c ^ (b | ~ d)) + *(in + 4)) + 4149444226U;
#line 307
  a = (a << 6) | (a >> 26);
#line 307
  a += b;
#line 308
  d += ((b ^ (a | ~ c)) + *(in + 11)) + 3174756917U;
#line 308
  d = (d << 10) | (d >> 22);
#line 308
  d += a;
#line 309
  c += ((a ^ (d | ~ b)) + *(in + 2)) + 718787259U;
#line 309
  c = (c << 15) | (c >> 17);
#line 309
  c += d;
#line 310
  b += ((d ^ (c | ~ a)) + *(in + 9)) + 3951481745U;
#line 310
  b = (b << 21) | (b >> 11);
#line 310
  b += c;
#line 312
  *(buf + 0) += a;
#line 313
  *(buf + 1) += b;
#line 314
  *(buf + 2) += c;
#line 315
  *(buf + 3) += d;
#line 316
  return;
}
}
#line 35 "/home/june/repo/benchmarks/collector/temp/chrony-1.29/hash_intmd5.c"
static MD5_CTX ctx___0  ;
