/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 128 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino64_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 55 "/usr/include/stdint.h"
typedef unsigned long uint64_t;
#line 104 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino64_t d_ino ;
   __off64_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 92 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
struct addr_hctl {
   int h ;
   int c ;
   int t ;
   uint64_t l ;
   unsigned char lun_arr[8] ;
};
#line 103 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
struct lsscsi_opt_coll {
   int long_opt ;
   int classic ;
   int generic ;
   int dev_maj_min ;
   int kname ;
   int lunhex ;
   int protection ;
   int protmode ;
   int scsi_id ;
   int size ;
   int transport ;
   int verbose ;
   int wwn ;
};
#line 187
enum dev_type {
    BLK_DEV = 0,
    CHR_DEV = 1
} ;
#line 189 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
struct dev_node_entry {
   unsigned int maj ;
   unsigned int min ;
   enum dev_type type ;
   time_t mtime ;
   char name[384] ;
};
#line 196 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
struct dev_node_list {
   struct dev_node_list *next ;
   unsigned int count ;
   struct dev_node_entry nodes[16] ;
};
#line 203 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
struct disk_wwn_node_entry {
   char wwn[32] ;
   char disk_bname[12] ;
};
#line 209 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
struct disk_wwn_node_list {
   struct disk_wwn_node_list *next ;
   unsigned int count ;
   struct disk_wwn_node_entry nodes[16] ;
};
#line 216 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
struct item_t {
   char name[256] ;
   int ft ;
   int d_type ;
};
#line 304
enum string_size_units {
    STRING_UNITS_10 = 0,
    STRING_UNITS_2 = 1
} ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 283
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes )  __asm__("fopen64")  ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 157
extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1), __leaf__)) atoll)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 27 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h"
extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) gnu_dev_major)(unsigned long long __dev )  __attribute__((__const__)) ;
#line 30
extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) gnu_dev_minor)(unsigned long long __dev )  __attribute__((__const__)) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 96
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memchr)(void const   *__s ,
                                                                                               int __c ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 121
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memrchr)(void const   *__s ,
                                                                                                int __c ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 497 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 511
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) getcwd)(char *__buf ,
                                                                               size_t __size ) ;
#line 809
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__nonnull__(1,2), __leaf__)) readlink)(char const   * __restrict  __path ,
                                                                                                     char * __restrict  __buf ,
                                                                                                     size_t __len ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 173
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long)(int ___argc ,
                                                                                  char * const  *___argv ,
                                                                                  char const   *__shortopts ,
                                                                                  struct option  const  *__longopts ,
                                                                                  int *__longind ) ;
#line 217 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf )  __asm__("stat64")  ;
#line 267
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) lstat)(char const   * __restrict  __file ,
                                                                                              struct stat * __restrict  __buf )  __asm__("lstat64")  ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 165
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp )  __asm__("readdir64")  ;
#line 262
extern int ( __attribute__((__nonnull__(1,2))) scandir)(char const   * __restrict  __dir ,
                                                        struct dirent *** __restrict  __namelist ,
                                                        int (*__selector)(struct dirent  const  * ) ,
                                                        int (*__cmp)(struct dirent  const  ** ,
                                                                     struct dirent  const  ** ) )  __asm__("scandir64")  ;
#line 34 "/usr/include/libgen.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) __xpg_basename)(char *__path ) ;
#line 195 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) difftime)(time_t __time1 ,
                                                                                  time_t __time0 )  __attribute__((__const__)) ;
#line 37 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static char const   *version_str  =    "0.27  2013/05/08 [svn: r111]";
#line 69 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static int transport_id  =    0;
#line 72 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static char const   *sysfsroot  =    "/sys";
#line 73 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static char const   *bus_scsi_devs  =    "/bus/scsi/devices";
#line 74 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static char const   *class_scsi_dev  =    "/class/scsi_device/";
#line 75 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static char const   *scsi_host  =    "/class/scsi_host/";
#line 76 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static char const   *spi_host  =    "/class/spi_host/";
#line 77 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static char const   *spi_transport  =    "/class/spi_transport/";
#line 78 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static char const   *sas_host  =    "/class/sas_host/";
#line 79 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static char const   *sas_phy  =    "/class/sas_phy/";
#line 80 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static char const   *sas_port  =    "/class/sas_port/";
#line 81 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static char const   *sas_device  =    "/class/sas_device/";
#line 82 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static char const   *sas_end_device  =    "/class/sas_end_device/";
#line 83 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static char const   *fc_host  =    "/class/fc_host/";
#line 84 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static char const   *fc_transport  =    "/class/fc_transport/";
#line 85 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static char const   *fc_remote_ports  =    "/class/fc_remote_ports/";
#line 86 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static char const   *iscsi_host  =    "/class/iscsi_host/";
#line 87 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static char const   *iscsi_session  =    "/class/iscsi_session/";
#line 88 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static char const   *dev_dir  =    "/dev";
#line 89 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static char const   *dev_disk_byid_dir  =    "/dev/disk/by-id";
#line 100 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
struct addr_hctl filter  ;
#line 101 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static int filter_active  =    0;
#line 120 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static char const   *scsi_device_types[32]  = 
#line 120
  {      "Direct-Access",      "Sequential-Access",      "Printer",      "Processor", 
        "Write-once",      "CD-ROM",      "Scanner",      "Optical memory", 
        "Medium Changer",      "Communications",      "Unknown (0xa)",      "Unknown (0xb)", 
        "Storage array",      "Enclosure",      "Simplified direct-access",      "Optical card read/writer", 
        "Bridge controller",      "Object based storage",      "Automation Drive interface",      "Reserved (0x13)", 
        "Reserved (0x14)",      "Reserved (0x15)",      "Reserved (0x16)",      "Reserved (0x17)", 
        "Reserved (0x18)",      "Reserved (0x19)",      "Reserved (0x1a)",      "Reserved (0x1b)", 
        "Reserved (0x1c)",      "Reserved (0x1e)",      "Well known LU",      "No device"};
#line 149 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static char const   *scsi_short_device_types[32]  = 
#line 149
  {      "disk   ",      "tape   ",      "printer",      "process", 
        "worm   ",      "cd/dvd ",      "scanner",      "optical", 
        "mediumx",      "comms  ",      "(0xa)  ",      "(0xb)  ", 
        "storage",      "enclosu",      "sim dsk",      "opti rd", 
        "bridge ",      "osd    ",      "adi    ",      "(0x13) ", 
        "(0x14) ",      "(0x15) ",      "(0x16) ",      "(0x17) ", 
        "(0x18) ",      "(0x19) ",      "(0x1a) ",      "(0x1b) ", 
        "(0x1c) ",      "(0x1e) ",      "wlun   ",      "no dev "};
#line 160 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static struct option long_options[20]  = 
#line 160
  {      {"classic", 0, (int *)0, 'c'}, 
        {"device", 0, (int *)0, 'd'}, 
        {"generic", 0, (int *)0, 'g'}, 
        {"help", 0, (int *)0, 'h'}, 
        {"hosts", 0, (int *)0, 'H'}, 
        {"kname", 0, (int *)0, 'k'}, 
        {"long", 0, (int *)0, 'l'}, 
        {"list", 0, (int *)0, 'L'}, 
        {"lunhex", 0, (int *)0, 'x'}, 
        {"protection", 0, (int *)0, 'p'}, 
        {"protmode", 0, (int *)0, 'P'}, 
        {"scsi_id", 0, (int *)0, 'i'}, 
        {"scsi-id", 0, (int *)0, 'i'}, 
        {"size", 0, (int *)0, 's'}, 
        {"sysfsroot", 1, (int *)0, 'y'}, 
        {"transport", 0, (int *)0, 't'}, 
        {"verbose", 0, (int *)0, 'v'}, 
        {"version", 0, (int *)0, 'V'}, 
        {"wwn", 0, (int *)0, 'w'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 201 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static struct dev_node_list *dev_node_listhead  =    (struct dev_node_list *)((void *)0);
#line 214 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static struct disk_wwn_node_list *disk_wwn_node_listhead  =    (struct disk_wwn_node_list *)((void *)0);
#line 222 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static struct item_t non_sg  ;
#line 223 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static struct item_t aa_sg  ;
#line 224 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static struct item_t aa_first  ;
#line 225 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static struct item_t enclosure_device  ;
#line 227 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static char sas_low_phy[256]  ;
#line 228 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static char sas_hold_end_device[256]  ;
#line 230 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static char const   *iscsi_dir_name  ;
#line 231 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static struct addr_hctl  const  *iscsi_target_hct  ;
#line 232 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static int iscsi_tsession_num  ;
#line 234 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static char errpath[4096]  ;
#line 237 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static char const   *usage_message  =    "Usage: lsscsi   [--classic] [--device] [--generic] [--help] [--hosts]\n\t\t[--kname] [--list] [--lunhex] [--long] [--protection]\n\t\t[--scsi_id] [--size] [--sysfsroot=PATH] [--transport]\n\t\t[--verbose] [--version] [--wwn] [<h:c:t:l>]\n  where:\n    --classic|-c      alternate output similar to \'cat /proc/scsi/scsi\'\n    --device|-d       show device node\'s major + minor numbers\n    --generic|-g      show scsi generic device name\n    --help|-h         this usage information\n    --hosts|-H        lists scsi hosts rather than scsi devices\n    --kname|-k        show kernel name instead of device node name\n    --list|-L         additional information output one\n                      attribute=value per line\n    --long|-l         additional information output\n    --lunhex|-x       show LUN part of tuple as hex number in T10 format;\n                      use twice to get full 16 digit hexadecimal LUN\n    --protection|-p   show target and initiator protection information\n    --protmode|-P     show negotiated protection information mode\n    --scsi_id|-i      show udev derived /dev/disk/by-id/scsi* entry\n    --size|-s         show disk size\n    --sysfsroot=PATH|-y PATH    set sysfs mount point to PATH (def: /sys)\n    --transport|-t    transport information for target or, if \'--hosts\'\n                      given, for initiator\n    --verbose|-v      output path names where data is found\n    --version|-V      output version string and exit\n    --wwn|-w          output WWN for disks (from /dev/disk/by-id/wwn*)\n    <h:c:t:l>         filter output list (def: \'*:*:*:*\' (all))\n\nList SCSI devices or hosts, optionally with additional information\n";
#line 268 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static void usage(void) 
{ 


  {
  {
#line 271
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
          usage_message);
  }
#line 272
  return;
}
}
#line 277 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static void my_strcopy(char *dest , char const   *src , int dest_maxlen ) 
{ 
  char const   *lp ;
  void *tmp ;

  {
#line 282
  if (dest_maxlen < 1) {
#line 283
    return;
  }
  {
#line 284
  tmp = memchr((void const   *)src, 0, (size_t )dest_maxlen);
#line 284
  lp = (char const   *)tmp;
  }
#line 285
  if ((unsigned long )((void *)0) == (unsigned long )lp) {
    {
#line 286
    memcpy((void */* __restrict  */)dest, (void const   */* __restrict  */)src, (size_t )(dest_maxlen - 1));
#line 287
    *(dest + (dest_maxlen - 1)) = (char )'\000';
    }
  } else {
    {
#line 289
    memcpy((void */* __restrict  */)dest, (void const   */* __restrict  */)src, (size_t )((lp - src) + 1L));
    }
  }
#line 290
  return;
}
}
#line 294 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static unsigned int do_div_rem(uint64_t *np , unsigned int base ) 
{ 
  unsigned int res ;

  {
#line 299
  res = (unsigned int )(*np % (unsigned long )base);
#line 300
  *np /= (uint64_t )base;
#line 301
  return (res);
}
}
#line 321 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static int string_get_size(uint64_t size , enum string_size_units  const  units ,
                           char *buf , int len ) 
{ 
  char const   *units_10[10] ;
  char const   *units_2[10] ;
  char const   **units_str[2] ;
  unsigned int divisor[2] ;
  int i ;
  int j ;
  unsigned int res ;
  uint64_t sf_cap ;
  uint64_t remainder ;
  char tmp[8] ;
  unsigned int tmp___0 ;

  {
#line 325
  units_10[0] = "B";
#line 325
  units_10[1] = "kB";
#line 325
  units_10[2] = "MB";
#line 325
  units_10[3] = "GB";
#line 325
  units_10[4] = "TB";
#line 325
  units_10[5] = "PB";
#line 325
  units_10[6] = "EB";
#line 325
  units_10[7] = "ZB";
#line 325
  units_10[8] = "YB";
#line 325
  units_10[9] = (char const   *)((void *)0);
#line 327
  units_2[0] = "B";
#line 327
  units_2[1] = "KiB";
#line 327
  units_2[2] = "MiB";
#line 327
  units_2[3] = "GiB";
#line 327
  units_2[4] = "TiB";
#line 327
  units_2[5] = "PiB";
#line 327
  units_2[6] = "EiB";
#line 327
  units_2[7] = "ZiB";
#line 327
  units_2[8] = "YiB";
#line 327
  units_2[9] = (char const   *)((void *)0);
#line 329
  units_str[0] = units_10;
#line 329
  units_str[1] = units_2;
#line 333
  divisor[0] = 1000U;
#line 333
  divisor[1] = 1024U;
#line 340
  remainder = (uint64_t )0;
#line 343
  tmp[0] = (char )'\000';
#line 344
  i = 0;
#line 345
  if (size >= (uint64_t )divisor[units]) {
    {
#line 346
    while (1) {
      while_continue: /* CIL Label */ ;
#line 346
      if (size >= (uint64_t )divisor[units]) {
#line 346
        if (! *(units_str[units] + i)) {
#line 346
          goto while_break;
        }
      } else {
#line 346
        goto while_break;
      }
      {
#line 347
      tmp___0 = do_div_rem(& size, divisor[units]);
#line 347
      remainder = (uint64_t )tmp___0;
#line 348
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 351
    sf_cap = size;
#line 352
    j = 0;
    {
#line 352
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 352
      if (! (sf_cap * 10UL < 1000UL)) {
#line 352
        goto while_break___0;
      }
#line 353
      sf_cap *= 10UL;
#line 352
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 355
    if (j) {
      {
#line 356
      remainder *= 1000UL;
#line 357
      do_div_rem(& remainder, divisor[units]);
#line 358
      res = (unsigned int )remainder;
#line 359
      snprintf((char */* __restrict  */)(tmp), sizeof(tmp), (char const   */* __restrict  */)".%03u",
               res);
#line 360
      tmp[j + 1] = (char )'\000';
      }
    }
  }
  {
#line 364
  res = (unsigned int )size;
#line 365
  snprintf((char */* __restrict  */)buf, (size_t )len, (char const   */* __restrict  */)"%u%s%s",
           res, tmp, *(units_str[units] + i));
  }
#line 367
  return (0);
}
}
#line 372 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static int cmp_hctl(struct addr_hctl  const  *le , struct addr_hctl  const  *ri ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 375
  if (le->h == ri->h) {
#line 376
    if (le->c == ri->c) {
#line 377
      if (le->t == ri->t) {
#line 378
        if (le->l == ri->l) {
#line 378
          tmp___0 = 0;
        } else {
#line 378
          if (le->l < ri->l) {
#line 378
            tmp = -1;
          } else {
#line 378
            tmp = 1;
          }
#line 378
          tmp___0 = tmp;
        }
#line 378
        return (tmp___0);
      } else {
#line 381
        if (le->t < ri->t) {
#line 381
          tmp___1 = -1;
        } else {
#line 381
          tmp___1 = 1;
        }
#line 381
        return (tmp___1);
      }
    } else {
#line 383
      if (le->c < ri->c) {
#line 383
        tmp___2 = -1;
      } else {
#line 383
        tmp___2 = 1;
      }
#line 383
      return (tmp___2);
    }
  } else {
#line 385
    if (le->h < ri->h) {
#line 385
      tmp___3 = -1;
    } else {
#line 385
      tmp___3 = 1;
    }
#line 385
    return (tmp___3);
  }
}
}
#line 388 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static void invalidate_hctl(struct addr_hctl *p ) 
{ 
  int k ;

  {
#line 393
  if (p) {
#line 394
    p->h = -1;
#line 395
    p->c = -1;
#line 396
    p->t = -1;
#line 397
    p->l = (uint64_t )(~ 0);
#line 398
    k = 0;
    {
#line 398
    while (1) {
      while_continue: /* CIL Label */ ;
#line 398
      if (! (k < 8)) {
#line 398
        goto while_break;
      }
#line 399
      p->lun_arr[k] = (unsigned char)255;
#line 398
      k ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 401
  return;
}
}
#line 406 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static int first_scandir_select(struct dirent  const  *s ) 
{ 


  {
#line 409
  if (0 != aa_first.ft) {
#line 410
    return (0);
  }
#line 411
  if (10 != (int )s->d_type) {
#line 411
    if (4 != (int )s->d_type) {
#line 413
      return (0);
    } else
#line 411
    if (46 == (int )s->d_name[0]) {
#line 413
      return (0);
    }
  }
  {
#line 414
  my_strcopy(aa_first.name, (char const   *)(s->d_name), 256);
#line 415
  aa_first.ft = 2;
#line 416
  aa_first.d_type = (int )s->d_type;
  }
#line 417
  return (1);
}
}
#line 420 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static int sub_scandir_select(struct dirent  const  *s ) 
{ 


  {
#line 423
  if ((int const   )s->d_type == 10) {
#line 424
    return (1);
  }
#line 426
  if ((int const   )s->d_type == 4) {
#line 426
    if ((int )s->d_name[0] != 46) {
#line 427
      return (1);
    }
  }
#line 429
  return (0);
}
}
#line 432 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static int sd_scandir_select(struct dirent  const  *s ) 
{ 
  char *tmp ;

  {
#line 435
  if ((int const   )s->d_type != 10) {
#line 435
    if ((int const   )s->d_type != 4) {
#line 436
      return (0);
    }
  }
#line 438
  if ((int )s->d_name[0] == 46) {
#line 439
    return (0);
  }
  {
#line 441
  tmp = strstr((char const   *)(s->d_name), "scsi_disk");
  }
#line 441
  if (tmp) {
#line 442
    return (1);
  }
#line 444
  return (0);
}
}
#line 450 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static int block_scandir_select(struct dirent  const  *s ) 
{ 
  char *tmp ;

  {
#line 453
  if ((int const   )s->d_type != 10) {
#line 453
    if ((int const   )s->d_type != 4) {
#line 454
      return (0);
    }
  }
#line 456
  if ((int )s->d_name[0] == 46) {
#line 457
    return (0);
  }
  {
#line 459
  tmp = strstr((char const   *)(s->d_name), "block");
  }
#line 459
  if (tmp) {
#line 460
    return (1);
  }
#line 462
  return (0);
}
}
#line 467 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static int sub_scan(char *dir_name , char const   *sub_str , int (*fn)(struct dirent  const  * ) ) 
{ 
  struct dirent **namelist ;
  int num ;
  int i ;
  int len ;
  size_t tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 473
  num = scandir((char const   */* __restrict  */)dir_name, (struct dirent ***/* __restrict  */)(& namelist),
                fn, (int (*)(struct dirent  const  ** , struct dirent  const  ** ))((void *)0));
  }
#line 474
  if (num <= 0) {
#line 475
    return (0);
  }
  {
#line 476
  tmp = strlen((char const   *)dir_name);
#line 476
  len = (int )tmp;
  }
#line 477
  if (len >= 4096) {
#line 478
    return (0);
  }
  {
#line 479
  snprintf((char */* __restrict  */)(dir_name + len), (size_t )(4096 - len), (char const   */* __restrict  */)"/%s",
           (*(namelist + 0))->d_name);
#line 481
  i = 0;
  }
  {
#line 481
  while (1) {
    while_continue: /* CIL Label */ ;
#line 481
    if (! (i < num)) {
#line 481
      goto while_break;
    }
    {
#line 482
    free((void *)*(namelist + i));
#line 481
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 483
  free((void *)namelist);
  }
#line 485
  if (num) {
    {
#line 485
    tmp___1 = strstr((char const   *)dir_name, sub_str);
    }
#line 485
    if ((unsigned long )tmp___1 == (unsigned long )((char *)0)) {
      {
#line 486
      num = scandir((char const   */* __restrict  */)dir_name, (struct dirent ***/* __restrict  */)(& namelist),
                    & sub_scandir_select, (int (*)(struct dirent  const  ** , struct dirent  const  ** ))((void *)0));
      }
#line 487
      if (num <= 0) {
#line 488
        return (0);
      }
      {
#line 489
      tmp___0 = strlen((char const   *)dir_name);
#line 489
      len = (int )tmp___0;
      }
#line 490
      if (len >= 4096) {
#line 491
        return (0);
      }
      {
#line 492
      snprintf((char */* __restrict  */)(dir_name + len), (size_t )(4096 - len), (char const   */* __restrict  */)"/%s",
               (*(namelist + 0))->d_name);
#line 495
      i = 0;
      }
      {
#line 495
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 495
        if (! (i < num)) {
#line 495
          goto while_break___0;
        }
        {
#line 496
        free((void *)*(namelist + i));
#line 495
        i ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 497
      free((void *)namelist);
      }
    }
  }
#line 499
  return (1);
}
}
#line 505 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static int block_scan(char *dir_name ) 
{ 
  int tmp ;

  {
  {
#line 508
  tmp = sub_scan(dir_name, "block:", & block_scandir_select);
  }
#line 508
  return (tmp);
}
}
#line 514 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static int sd_scan(char *dir_name ) 
{ 
  int tmp ;

  {
  {
#line 517
  tmp = sub_scan(dir_name, "scsi_disk:", & sd_scandir_select);
  }
#line 517
  return (tmp);
}
}
#line 520 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static int enclosure_device_scandir_select(struct dirent  const  *s ) 
{ 
  char *tmp ;

  {
#line 523
  if (10 != (int )s->d_type) {
#line 523
    if (4 != (int )s->d_type) {
#line 525
      return (0);
    } else
#line 523
    if (46 == (int )s->d_name[0]) {
#line 525
      return (0);
    }
  }
  {
#line 526
  tmp = strstr((char const   *)(s->d_name), "enclosure_device");
  }
#line 526
  if (tmp) {
    {
#line 527
    my_strcopy(enclosure_device.name, (char const   *)(s->d_name), 256);
#line 528
    enclosure_device.ft = 2;
#line 529
    enclosure_device.d_type = (int )s->d_type;
    }
#line 530
    return (1);
  }
#line 532
  return (0);
}
}
#line 539 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static int enclosure_device_scan(char const   *dir_name , struct lsscsi_opt_coll  const  *op ) 
{ 
  struct dirent **namelist ;
  int num ;
  int k ;

  {
  {
#line 545
  num = scandir((char const   */* __restrict  */)dir_name, (struct dirent ***/* __restrict  */)(& namelist),
                & enclosure_device_scandir_select, (int (*)(struct dirent  const  ** ,
                                                            struct dirent  const  ** ))((void *)0));
  }
#line 547
  if (num < 0) {
#line 548
    if (op->verbose > 0) {
      {
#line 549
      snprintf((char */* __restrict  */)(errpath), (size_t )4096, (char const   */* __restrict  */)"scandir: %s",
               dir_name);
#line 550
      perror((char const   *)(errpath));
      }
    }
#line 552
    return (-1);
  }
#line 554
  k = 0;
  {
#line 554
  while (1) {
    while_continue: /* CIL Label */ ;
#line 554
    if (! (k < num)) {
#line 554
      goto while_break;
    }
    {
#line 555
    free((void *)*(namelist + k));
#line 554
    k ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 556
  free((void *)namelist);
  }
#line 557
  return (num);
}
}
#line 561 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static int scan_for_first(char const   *dir_name , struct lsscsi_opt_coll  const  *op ) 
{ 
  struct dirent **namelist ;
  int num ;
  int k ;

  {
  {
#line 567
  aa_first.ft = 0;
#line 568
  num = scandir((char const   */* __restrict  */)dir_name, (struct dirent ***/* __restrict  */)(& namelist),
                & first_scandir_select, (int (*)(struct dirent  const  ** , struct dirent  const  ** ))((void *)0));
  }
#line 569
  if (num < 0) {
#line 570
    if (op->verbose > 0) {
      {
#line 571
      snprintf((char */* __restrict  */)(errpath), (size_t )4096, (char const   */* __restrict  */)"scandir: %s",
               dir_name);
#line 572
      perror((char const   *)(errpath));
      }
    }
#line 574
    return (-1);
  }
#line 576
  k = 0;
  {
#line 576
  while (1) {
    while_continue: /* CIL Label */ ;
#line 576
    if (! (k < num)) {
#line 576
      goto while_break;
    }
    {
#line 577
    free((void *)*(namelist + k));
#line 576
    k ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 578
  free((void *)namelist);
  }
#line 579
  return (num);
}
}
#line 582 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static int non_sg_scandir_select(struct dirent  const  *s ) 
{ 
  int len ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 587
  if (0 != non_sg.ft) {
#line 588
    return (0);
  }
#line 589
  if (10 != (int )s->d_type) {
#line 589
    if (4 != (int )s->d_type) {
#line 591
      return (0);
    } else
#line 589
    if (46 == (int )s->d_name[0]) {
#line 591
      return (0);
    }
  }
  {
#line 592
  tmp___5 = strncmp("scsi_changer", (char const   *)(s->d_name), (size_t )12);
  }
#line 592
  if (0 == tmp___5) {
    {
#line 593
    my_strcopy(non_sg.name, (char const   *)(s->d_name), 256);
#line 594
    non_sg.ft = 2;
#line 595
    non_sg.d_type = (int )s->d_type;
    }
#line 596
    return (1);
  } else {
    {
#line 597
    tmp___4 = strncmp("block", (char const   *)(s->d_name), (size_t )5);
    }
#line 597
    if (0 == tmp___4) {
      {
#line 598
      my_strcopy(non_sg.name, (char const   *)(s->d_name), 256);
#line 599
      non_sg.ft = 1;
#line 600
      non_sg.d_type = (int )s->d_type;
      }
#line 601
      return (1);
    } else {
      {
#line 602
      tmp___3 = strcmp("tape", (char const   *)(s->d_name));
      }
#line 602
      if (0 == tmp___3) {
        {
#line 603
        my_strcopy(non_sg.name, (char const   *)(s->d_name), 256);
#line 604
        non_sg.ft = 2;
#line 605
        non_sg.d_type = (int )s->d_type;
        }
#line 606
        return (1);
      } else {
        {
#line 607
        tmp___2 = strncmp("scsi_tape:st", (char const   *)(s->d_name), (size_t )12);
        }
#line 607
        if (0 == tmp___2) {
          {
#line 608
          tmp = strlen((char const   *)(s->d_name));
#line 608
          len = (int )tmp;
#line 609
          tmp___0 = __ctype_b_loc();
          }
#line 609
          if ((int const   )*(*tmp___0 + (int )s->d_name[len - 1]) & 2048) {
            {
#line 611
            my_strcopy(non_sg.name, (char const   *)(s->d_name), 256);
#line 612
            non_sg.ft = 2;
#line 613
            non_sg.d_type = (int )s->d_type;
            }
#line 614
            return (1);
          } else {
#line 616
            return (0);
          }
        } else {
          {
#line 617
          tmp___1 = strncmp("onstream_tape:os", (char const   *)(s->d_name), (size_t )16);
          }
#line 617
          if (0 == tmp___1) {
            {
#line 618
            my_strcopy(non_sg.name, (char const   *)(s->d_name), 256);
#line 619
            non_sg.ft = 2;
#line 620
            non_sg.d_type = (int )s->d_type;
            }
#line 621
            return (1);
          } else {
#line 623
            return (0);
          }
        }
      }
    }
  }
}
}
#line 626 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static int non_sg_scan(char const   *dir_name , struct lsscsi_opt_coll  const  *op ) 
{ 
  struct dirent **namelist ;
  int num ;
  int k ;

  {
  {
#line 632
  non_sg.ft = 0;
#line 633
  num = scandir((char const   */* __restrict  */)dir_name, (struct dirent ***/* __restrict  */)(& namelist),
                & non_sg_scandir_select, (int (*)(struct dirent  const  ** , struct dirent  const  ** ))((void *)0));
  }
#line 634
  if (num < 0) {
#line 635
    if (op->verbose > 0) {
      {
#line 636
      snprintf((char */* __restrict  */)(errpath), (size_t )4096, (char const   */* __restrict  */)"scandir: %s",
               dir_name);
#line 637
      perror((char const   *)(errpath));
      }
    }
#line 639
    return (-1);
  }
#line 641
  k = 0;
  {
#line 641
  while (1) {
    while_continue: /* CIL Label */ ;
#line 641
    if (! (k < num)) {
#line 641
      goto while_break;
    }
    {
#line 642
    free((void *)*(namelist + k));
#line 641
    k ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 643
  free((void *)namelist);
  }
#line 644
  return (num);
}
}
#line 648 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static int sg_scandir_select(struct dirent  const  *s ) 
{ 
  int tmp ;

  {
#line 651
  if (0 != aa_sg.ft) {
#line 652
    return (0);
  }
#line 653
  if (10 != (int )s->d_type) {
#line 653
    if (4 != (int )s->d_type) {
#line 655
      return (0);
    } else
#line 653
    if (46 == (int )s->d_name[0]) {
#line 655
      return (0);
    }
  }
  {
#line 656
  tmp = strncmp("scsi_generic", (char const   *)(s->d_name), (size_t )12);
  }
#line 656
  if (0 == tmp) {
    {
#line 657
    my_strcopy(aa_sg.name, (char const   *)(s->d_name), 256);
#line 658
    aa_sg.ft = 2;
#line 659
    aa_sg.d_type = (int )s->d_type;
    }
#line 660
    return (1);
  } else {
#line 662
    return (0);
  }
}
}
#line 665 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static int sg_scan(char const   *dir_name ) 
{ 
  struct dirent **namelist ;
  int num ;
  int k ;

  {
  {
#line 671
  aa_sg.ft = 0;
#line 672
  num = scandir((char const   */* __restrict  */)dir_name, (struct dirent ***/* __restrict  */)(& namelist),
                & sg_scandir_select, (int (*)(struct dirent  const  ** , struct dirent  const  ** ))((void *)0));
  }
#line 673
  if (num < 0) {
#line 674
    return (-1);
  }
#line 675
  k = 0;
  {
#line 675
  while (1) {
    while_continue: /* CIL Label */ ;
#line 675
    if (! (k < num)) {
#line 675
      goto while_break;
    }
    {
#line 676
    free((void *)*(namelist + k));
#line 675
    k ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 677
  free((void *)namelist);
  }
#line 678
  return (num);
}
}
#line 682 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static int sas_port_scandir_select(struct dirent  const  *s ) 
{ 
  int tmp ;

  {
#line 685
  if (10 != (int )s->d_type) {
#line 685
    if (4 != (int )s->d_type) {
#line 686
      return (0);
    }
  }
  {
#line 687
  tmp = strncmp("port-", (char const   *)(s->d_name), (size_t )5);
  }
#line 687
  if (0 == tmp) {
#line 688
    return (1);
  }
#line 689
  return (0);
}
}
#line 692 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static int sas_port_scan(char const   *dir_name , struct dirent ***port_list ) 
{ 
  struct dirent **namelist ;
  int num ;

  {
  {
#line 698
  namelist = (struct dirent **)((void *)0);
#line 699
  num = scandir((char const   */* __restrict  */)dir_name, (struct dirent ***/* __restrict  */)(& namelist),
                & sas_port_scandir_select, (int (*)(struct dirent  const  ** , struct dirent  const  ** ))((void *)0));
  }
#line 700
  if (num < 0) {
#line 701
    *port_list = (struct dirent **)((void *)0);
#line 702
    return (-1);
  }
#line 704
  *port_list = namelist;
#line 705
  return (num);
}
}
#line 709 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static int sas_low_phy_scandir_select(struct dirent  const  *s ) 
{ 
  char *cp ;
  int n ;
  int m ;
  char *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
#line 715
  if (10 != (int )s->d_type) {
#line 715
    if (4 != (int )s->d_type) {
#line 716
      return (0);
    }
  }
  {
#line 717
  tmp___1 = strncmp("phy", (char const   *)(s->d_name), (size_t )3);
  }
#line 717
  if (0 == tmp___1) {
    {
#line 718
    tmp___0 = strlen((char const   *)(sas_low_phy));
    }
#line 718
    if (0UL == tmp___0) {
      {
#line 719
      my_strcopy(sas_low_phy, (char const   *)(s->d_name), 256);
      }
    } else {
      {
#line 721
      tmp = strrchr((char const   *)(s->d_name), ':');
#line 721
      cp = tmp;
      }
#line 722
      if ((unsigned long )((void *)0) == (unsigned long )cp) {
#line 723
        return (0);
      }
      {
#line 724
      n = atoi((char const   *)(cp + 1));
#line 725
      cp = strrchr((char const   *)(sas_low_phy), ':');
      }
#line 726
      if ((unsigned long )((void *)0) == (unsigned long )cp) {
#line 727
        return (0);
      }
      {
#line 728
      m = atoi((char const   *)(cp + 1));
      }
#line 729
      if (n < m) {
        {
#line 730
        my_strcopy(sas_low_phy, (char const   *)(s->d_name), 256);
        }
      }
    }
#line 732
    return (1);
  } else {
#line 734
    return (0);
  }
}
}
#line 737 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static int sas_low_phy_scan(char const   *dir_name , struct dirent ***phy_list ) 
{ 
  struct dirent **namelist ;
  int num ;
  int k ;

  {
  {
#line 740
  namelist = (struct dirent **)((void *)0);
#line 743
  memset((void *)(sas_low_phy), 0, sizeof(sas_low_phy));
#line 744
  num = scandir((char const   */* __restrict  */)dir_name, (struct dirent ***/* __restrict  */)(& namelist),
                & sas_low_phy_scandir_select, (int (*)(struct dirent  const  ** ,
                                                       struct dirent  const  ** ))((void *)0));
  }
#line 745
  if (num < 0) {
#line 746
    return (-1);
  }
#line 747
  if (! phy_list) {
#line 748
    k = 0;
    {
#line 748
    while (1) {
      while_continue: /* CIL Label */ ;
#line 748
      if (! (k < num)) {
#line 748
        goto while_break;
      }
      {
#line 749
      free((void *)*(namelist + k));
#line 748
      k ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 750
    free((void *)namelist);
    }
  } else {
#line 753
    *phy_list = namelist;
  }
#line 754
  return (num);
}
}
#line 757 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static int iscsi_target_scandir_select(struct dirent  const  *s ) 
{ 
  char buff[4096] ;
  int off ;
  struct stat a_stat ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 764
  if (10 != (int )s->d_type) {
#line 764
    if (4 != (int )s->d_type) {
#line 765
      return (0);
    }
  }
  {
#line 766
  tmp___1 = strncmp("session", (char const   *)(s->d_name), (size_t )7);
  }
#line 766
  if (0 == tmp___1) {
    {
#line 767
    iscsi_tsession_num = atoi((char const   *)(s->d_name + 7));
#line 768
    my_strcopy(buff, iscsi_dir_name, 4096);
#line 769
    tmp = strlen((char const   *)(buff));
#line 769
    off = (int )tmp;
#line 770
    snprintf((char */* __restrict  */)(buff + off), sizeof(buff) - (unsigned long )off,
             (char const   */* __restrict  */)"/%s/target%d:%d:%d", s->d_name, iscsi_target_hct->h,
             iscsi_target_hct->c, iscsi_target_hct->t);
#line 773
    tmp___0 = stat((char const   */* __restrict  */)(buff), (struct stat */* __restrict  */)(& a_stat));
    }
#line 773
    if (tmp___0 >= 0) {
#line 773
      if ((a_stat.st_mode & 61440U) == 16384U) {
#line 774
        return (1);
      } else {
#line 776
        return (0);
      }
    } else {
#line 776
      return (0);
    }
  } else {
#line 778
    return (0);
  }
}
}
#line 781 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static int iscsi_target_scan(char const   *dir_name , struct addr_hctl  const  *hctl ) 
{ 
  struct dirent **namelist ;
  int num ;
  int k ;

  {
  {
#line 787
  iscsi_dir_name = dir_name;
#line 788
  iscsi_target_hct = hctl;
#line 789
  iscsi_tsession_num = -1;
#line 790
  num = scandir((char const   */* __restrict  */)dir_name, (struct dirent ***/* __restrict  */)(& namelist),
                & iscsi_target_scandir_select, (int (*)(struct dirent  const  ** ,
                                                        struct dirent  const  ** ))((void *)0));
  }
#line 791
  if (num < 0) {
#line 792
    return (-1);
  }
#line 793
  k = 0;
  {
#line 793
  while (1) {
    while_continue: /* CIL Label */ ;
#line 793
    if (! (k < num)) {
#line 793
      goto while_break;
    }
    {
#line 794
    free((void *)*(namelist + k));
#line 793
    k ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 795
  free((void *)namelist);
  }
#line 796
  return (num);
}
}
#line 802 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static int if_directory_chdir(char const   *dir_name , char const   *base_name ) 
{ 
  char b[4096] ;
  struct stat a_stat ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 808
  snprintf((char */* __restrict  */)(b), sizeof(b), (char const   */* __restrict  */)"%s/%s",
           dir_name, base_name);
#line 809
  tmp = stat((char const   */* __restrict  */)(b), (struct stat */* __restrict  */)(& a_stat));
  }
#line 809
  if (tmp < 0) {
#line 810
    return (0);
  }
#line 811
  if ((a_stat.st_mode & 61440U) == 16384U) {
    {
#line 812
    tmp___0 = chdir((char const   *)(b));
    }
#line 812
    if (tmp___0 < 0) {
#line 813
      return (0);
    }
#line 814
    return (1);
  }
#line 816
  return (0);
}
}
#line 823 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static int if_directory_ch2generic(char const   *dir_name ) 
{ 
  char b[4096] ;
  struct stat a_stat ;
  char const   *old_name ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 828
  old_name = "generic";
#line 830
  snprintf((char */* __restrict  */)(b), sizeof(b), (char const   */* __restrict  */)"%s/%s",
           dir_name, old_name);
#line 831
  tmp___0 = stat((char const   */* __restrict  */)(b), (struct stat */* __restrict  */)(& a_stat));
  }
#line 831
  if (tmp___0 >= 0) {
#line 831
    if ((a_stat.st_mode & 61440U) == 16384U) {
      {
#line 832
      tmp = chdir((char const   *)(b));
      }
#line 832
      if (tmp < 0) {
#line 833
        return (0);
      }
#line 834
      return (1);
    }
  }
  {
#line 837
  tmp___1 = sg_scan(dir_name);
  }
#line 837
  if (1 != tmp___1) {
#line 838
    return (0);
  }
  {
#line 839
  snprintf((char */* __restrict  */)(b), sizeof(b), (char const   */* __restrict  */)"%s/%s",
           dir_name, aa_sg.name);
#line 840
  tmp___2 = stat((char const   */* __restrict  */)(b), (struct stat */* __restrict  */)(& a_stat));
  }
#line 840
  if (tmp___2 < 0) {
#line 841
    return (0);
  }
#line 842
  if ((a_stat.st_mode & 61440U) == 16384U) {
    {
#line 843
    tmp___3 = chdir((char const   *)(b));
    }
#line 843
    if (tmp___3 < 0) {
#line 844
      return (0);
    }
#line 845
    return (1);
  }
#line 847
  return (0);
}
}
#line 853 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static int get_value(char const   *dir_name , char const   *base_name , char *value ,
                     int max_value_len ) 
{ 
  char b[4096] ;
  FILE *f ;
  int len ;
  char *tmp ;
  size_t tmp___0 ;

  {
  {
#line 861
  snprintf((char */* __restrict  */)(b), sizeof(b), (char const   */* __restrict  */)"%s/%s",
           dir_name, base_name);
#line 862
  f = fopen((char const   */* __restrict  */)(b), (char const   */* __restrict  */)"r");
  }
#line 862
  if ((unsigned long )((void *)0) == (unsigned long )f) {
#line 863
    return (0);
  }
  {
#line 865
  tmp = fgets((char */* __restrict  */)value, max_value_len, (FILE */* __restrict  */)f);
  }
#line 865
  if ((unsigned long )((void *)0) == (unsigned long )tmp) {
    {
#line 867
    *(value + 0) = (char )'\000';
#line 868
    fclose(f);
    }
#line 869
    return (1);
  }
  {
#line 871
  tmp___0 = strlen((char const   *)value);
#line 871
  len = (int )tmp___0;
  }
#line 872
  if (len > 0) {
#line 872
    if ((int )*(value + (len - 1)) == 10) {
#line 873
      *(value + (len - 1)) = (char )'\000';
    }
  }
  {
#line 874
  fclose(f);
  }
#line 875
  return (1);
}
}
#line 879 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static void collect_dev_nodes(void) 
{ 
  DIR *dirp ;
  struct dirent *dep ;
  char device_path[384] ;
  struct stat stats ;
  struct dev_node_list *cur_list ;
  struct dev_node_list *prev_list ;
  struct dev_node_entry *cur_ent ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 889
  if (dev_node_listhead) {
#line 890
    return;
  }
  {
#line 892
  tmp = malloc(sizeof(struct dev_node_list ));
#line 892
  dev_node_listhead = (struct dev_node_list *)tmp;
  }
#line 894
  if (! dev_node_listhead) {
#line 895
    return;
  }
  {
#line 897
  cur_list = dev_node_listhead;
#line 898
  cur_list->next = (struct dev_node_list *)((void *)0);
#line 899
  cur_list->count = 0U;
#line 901
  dirp = opendir(dev_dir);
  }
#line 902
  if ((unsigned long )dirp == (unsigned long )((void *)0)) {
#line 903
    return;
  }
  {
#line 905
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 906
    dep = readdir(dirp);
    }
#line 907
    if ((unsigned long )dep == (unsigned long )((void *)0)) {
#line 908
      goto while_break;
    }
    {
#line 910
    snprintf((char */* __restrict  */)(device_path), sizeof(device_path), (char const   */* __restrict  */)"%s/%s",
             dev_dir, dep->d_name);
#line 914
    tmp___0 = lstat((char const   */* __restrict  */)(device_path), (struct stat */* __restrict  */)(& stats));
    }
#line 914
    if (tmp___0) {
#line 915
      goto while_continue;
    }
#line 918
    if (! ((stats.st_mode & 61440U) == 24576U)) {
#line 918
      if (! ((stats.st_mode & 61440U) == 8192U)) {
#line 919
        goto while_continue;
      }
    }
#line 922
    if (cur_list->count >= 16U) {
      {
#line 923
      prev_list = cur_list;
#line 924
      tmp___1 = malloc(sizeof(struct dev_node_list ));
#line 924
      cur_list = (struct dev_node_list *)tmp___1;
      }
#line 926
      if (! cur_list) {
#line 926
        goto while_break;
      }
#line 927
      prev_list->next = cur_list;
#line 928
      cur_list->next = (struct dev_node_list *)((void *)0);
#line 929
      cur_list->count = 0U;
    }
    {
#line 932
    cur_ent = & cur_list->nodes[cur_list->count];
#line 933
    cur_ent->maj = gnu_dev_major((unsigned long long )stats.st_rdev);
#line 934
    cur_ent->min = gnu_dev_minor((unsigned long long )stats.st_rdev);
    }
#line 935
    if ((stats.st_mode & 61440U) == 24576U) {
#line 936
      cur_ent->type = (enum dev_type )0;
    } else
#line 937
    if ((stats.st_mode & 61440U) == 8192U) {
#line 938
      cur_ent->type = (enum dev_type )1;
    }
    {
#line 939
    cur_ent->mtime = stats.st_mtim.tv_sec;
#line 940
    my_strcopy(cur_ent->name, (char const   *)(device_path), (int )sizeof(cur_ent->name));
#line 942
    (cur_list->count) ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 945
  closedir(dirp);
  }
#line 946
  return;
}
}
#line 949 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static void free_dev_node_list(void) 
{ 
  struct dev_node_list *cur_list ;
  struct dev_node_list *next_list ;

  {
#line 952
  if (dev_node_listhead) {
#line 955
    cur_list = dev_node_listhead;
    {
#line 956
    while (1) {
      while_continue: /* CIL Label */ ;
#line 956
      if (! cur_list) {
#line 956
        goto while_break;
      }
      {
#line 957
      next_list = cur_list->next;
#line 958
      free((void *)cur_list);
#line 959
      cur_list = next_list;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 962
    dev_node_listhead = (struct dev_node_list *)((void *)0);
  }
#line 964
  return;
}
}
#line 969 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static int get_dev_node(char const   *wd , char *node , enum dev_type type ) 
{ 
  struct dev_node_list *cur_list ;
  struct dev_node_entry *cur_ent ;
  char value[256] ;
  unsigned int maj ;
  unsigned int min ;
  time_t newest_mtime ;
  int match_found ;
  unsigned int k ;
  int tmp ;
  double tmp___0 ;

  {
  {
#line 976
  newest_mtime = (time_t )0;
#line 977
  match_found = 0;
#line 978
  k = 0U;
#line 981
  memcpy((void */* __restrict  */)node, (void const   */* __restrict  */)"-", (size_t )2);
  }
#line 982
  if ((unsigned long )dev_node_listhead == (unsigned long )((void *)0)) {
    {
#line 983
    collect_dev_nodes();
    }
#line 984
    if ((unsigned long )dev_node_listhead == (unsigned long )((void *)0)) {
#line 985
      goto exit;
    }
  }
  {
#line 989
  tmp = get_value(wd, "dev", value, 256);
  }
#line 989
  if (! tmp) {
#line 990
    goto exit;
  }
  {
#line 991
  sscanf((char const   */* __restrict  */)(value), (char const   */* __restrict  */)"%u:%u",
         & maj, & min);
#line 994
  cur_list = dev_node_listhead;
  }
  {
#line 996
  while (1) {
    while_continue: /* CIL Label */ ;
#line 997
    if (k >= cur_list->count) {
#line 998
      cur_list = cur_list->next;
#line 999
      if (! cur_list) {
#line 1000
        goto while_break;
      }
#line 1001
      k = 0U;
    }
#line 1004
    cur_ent = & cur_list->nodes[k];
#line 1005
    k ++;
#line 1007
    if (maj == cur_ent->maj) {
#line 1007
      if (min == cur_ent->min) {
#line 1007
        if ((unsigned int )type == (unsigned int )cur_ent->type) {
#line 1010
          if (! match_found) {
            {
#line 1012
            newest_mtime = cur_ent->mtime;
#line 1013
            my_strcopy(node, (char const   *)(cur_ent->name), 256);
            }
          } else {
            {
#line 1010
            tmp___0 = difftime(cur_ent->mtime, newest_mtime);
            }
#line 1010
            if (tmp___0 > (double )0) {
              {
#line 1012
              newest_mtime = cur_ent->mtime;
#line 1013
              my_strcopy(node, (char const   *)(cur_ent->name), 256);
              }
            }
          }
#line 1015
          match_found = 1;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  exit: 
#line 1020
  return (match_found);
}
}
#line 1027 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static int collect_disk_wwn_nodes(void) 
{ 
  int k ;
  int num ;
  DIR *dirp ;
  struct dirent *dep ;
  char device_path[4097] ;
  char symlink_path[4097] ;
  struct stat stats ;
  struct disk_wwn_node_list *cur_list ;
  struct disk_wwn_node_list *prev_list ;
  struct disk_wwn_node_entry *cur_ent ;
  void *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  ssize_t tmp___3 ;
  void *tmp___4 ;
  char *tmp___5 ;

  {
#line 1031
  num = 0;
#line 1040
  if (disk_wwn_node_listhead) {
#line 1041
    return (num);
  }
  {
#line 1043
  tmp = malloc(sizeof(struct disk_wwn_node_list ));
#line 1043
  disk_wwn_node_listhead = (struct disk_wwn_node_list *)tmp;
  }
#line 1045
  if (! disk_wwn_node_listhead) {
#line 1046
    return (-1);
  }
  {
#line 1048
  cur_list = disk_wwn_node_listhead;
#line 1049
  memset((void *)cur_list, 0, sizeof(struct disk_wwn_node_list ));
#line 1051
  dirp = opendir(dev_disk_byid_dir);
  }
#line 1052
  if ((unsigned long )dirp == (unsigned long )((void *)0)) {
#line 1053
    return (-1);
  }
  {
#line 1055
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1056
    dep = readdir(dirp);
    }
#line 1057
    if ((unsigned long )dep == (unsigned long )((void *)0)) {
#line 1058
      goto while_break;
    }
    {
#line 1059
    tmp___0 = memcmp((void const   *)"wwn-", (void const   *)(dep->d_name), (size_t )4);
    }
#line 1059
    if (tmp___0) {
#line 1060
      goto while_continue;
    }
    {
#line 1061
    tmp___1 = strstr((char const   *)(dep->d_name), "part");
    }
#line 1061
    if (tmp___1) {
#line 1062
      goto while_continue;
    }
    {
#line 1064
    snprintf((char */* __restrict  */)(device_path), (size_t )4096, (char const   */* __restrict  */)"%s/%s",
             dev_disk_byid_dir, dep->d_name);
#line 1066
    device_path[4096] = (char )'\000';
#line 1067
    tmp___2 = lstat((char const   */* __restrict  */)(device_path), (struct stat */* __restrict  */)(& stats));
    }
#line 1067
    if (tmp___2) {
#line 1068
      goto while_continue;
    }
#line 1069
    if (! ((stats.st_mode & 61440U) == 40960U)) {
#line 1070
      goto while_continue;
    }
    {
#line 1071
    tmp___3 = readlink((char const   */* __restrict  */)(device_path), (char */* __restrict  */)(symlink_path),
                       (size_t )4096);
#line 1071
    k = (int )tmp___3;
    }
#line 1071
    if (k < 1) {
#line 1072
      goto while_continue;
    }
#line 1073
    symlink_path[k] = (char )'\000';
#line 1076
    if (cur_list->count >= 16U) {
      {
#line 1077
      prev_list = cur_list;
#line 1078
      tmp___4 = malloc(sizeof(struct disk_wwn_node_list ));
#line 1078
      cur_list = (struct disk_wwn_node_list *)tmp___4;
      }
#line 1080
      if (! cur_list) {
#line 1081
        goto while_break;
      }
      {
#line 1082
      memset((void *)cur_list, 0, sizeof(struct disk_wwn_node_list ));
#line 1083
      prev_list->next = cur_list;
      }
    }
    {
#line 1086
    cur_ent = & cur_list->nodes[cur_list->count];
#line 1087
    my_strcopy(cur_ent->wwn, (char const   *)(dep->d_name + 4), (int )sizeof(cur_ent->wwn));
#line 1089
    tmp___5 = __xpg_basename(symlink_path);
#line 1089
    my_strcopy(cur_ent->disk_bname, (char const   *)tmp___5, (int )sizeof(cur_ent->disk_bname));
#line 1091
    (cur_list->count) ++;
#line 1092
    num ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1094
  closedir(dirp);
  }
#line 1095
  return (num);
}
}
#line 1099 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static void free_disk_wwn_node_list(void) 
{ 
  struct disk_wwn_node_list *cur_list ;
  struct disk_wwn_node_list *next_list ;

  {
#line 1102
  if (disk_wwn_node_listhead) {
#line 1105
    cur_list = disk_wwn_node_listhead;
    {
#line 1106
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1106
      if (! cur_list) {
#line 1106
        goto while_break;
      }
      {
#line 1107
      next_list = cur_list->next;
#line 1108
      free((void *)cur_list);
#line 1109
      cur_list = next_list;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 1112
    disk_wwn_node_listhead = (struct disk_wwn_node_list *)((void *)0);
  }
#line 1114
  return;
}
}
#line 1118 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static int get_disk_wwn(char const   *wd , char *wwn_str , int max_wwn_str_len ) 
{ 
  struct disk_wwn_node_list *cur_list ;
  struct disk_wwn_node_entry *cur_ent ;
  char name[4096] ;
  char *bn ;
  unsigned int k ;
  int tmp ;

  {
  {
#line 1125
  k = 0U;
#line 1127
  my_strcopy(name, wd, (int )sizeof(name));
#line 1128
  name[sizeof(name) - 1UL] = (char )'\000';
#line 1129
  bn = __xpg_basename(name);
  }
#line 1130
  if ((unsigned long )disk_wwn_node_listhead == (unsigned long )((void *)0)) {
    {
#line 1131
    collect_disk_wwn_nodes();
    }
#line 1132
    if ((unsigned long )disk_wwn_node_listhead == (unsigned long )((void *)0)) {
#line 1133
      return (0);
    }
  }
#line 1135
  cur_list = disk_wwn_node_listhead;
  {
#line 1136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1137
    if (k >= cur_list->count) {
#line 1138
      cur_list = cur_list->next;
#line 1139
      if (! cur_list) {
#line 1140
        goto while_break;
      }
#line 1141
      k = 0U;
    }
    {
#line 1143
    cur_ent = & cur_list->nodes[k];
#line 1144
    k ++;
#line 1145
    tmp = strcmp((char const   *)(cur_ent->disk_bname), (char const   *)bn);
    }
#line 1145
    if (0 == tmp) {
      {
#line 1146
      my_strcopy(wwn_str, (char const   *)(cur_ent->wwn), max_wwn_str_len);
#line 1147
      *(wwn_str + (max_wwn_str_len - 1)) = (char )'\000';
      }
#line 1148
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1151
  return (0);
}
}
#line 1163 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static char *lookup_dev(char const   *dir , char const   *pfx , char const   *dev ) 
{ 
  struct stat stats ;
  unsigned int st_rdev ;
  DIR *dirp ;
  struct dirent *entry ;
  char *result ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;

  {
  {
#line 1170
  result = (char *)((void *)0);
#line 1172
  tmp = stat((char const   */* __restrict  */)dev, (struct stat */* __restrict  */)(& stats));
  }
#line 1172
  if (tmp < 0) {
#line 1173
    goto out;
  }
  {
#line 1174
  st_rdev = (unsigned int )stats.st_rdev;
#line 1175
  tmp___0 = chdir(dir);
  }
#line 1175
  if (tmp___0 < 0) {
#line 1176
    goto out;
  }
  {
#line 1177
  dirp = opendir(dir);
  }
#line 1178
  if (! dirp) {
#line 1179
    goto out;
  }
  {
#line 1180
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1180
    entry = readdir(dirp);
    }
#line 1180
    if (! ((unsigned long )entry != (unsigned long )((void *)0))) {
#line 1180
      goto while_break;
    }
    {
#line 1181
    tmp___2 = stat((char const   */* __restrict  */)(entry->d_name), (struct stat */* __restrict  */)(& stats));
    }
#line 1181
    if (tmp___2 >= 0) {
#line 1181
      if (stats.st_rdev == (__dev_t )st_rdev) {
        {
#line 1181
        tmp___3 = strlen(pfx);
#line 1181
        tmp___4 = strncmp((char const   *)(entry->d_name), pfx, tmp___3);
        }
#line 1181
        if (tmp___4 == 0) {
          {
#line 1184
          tmp___1 = strlen(pfx);
#line 1184
          result = strdup((char const   *)(entry->d_name + tmp___1));
          }
#line 1185
          goto while_break;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1188
  closedir(dirp);
  }
  out: 
#line 1190
  return (result);
}
}
#line 1200 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static char *get_disk_scsi_id(char const   *dev_node ) 
{ 
  char sys_block[64] ;
  char holder[16] ;
  char *scsi_id ;
  DIR *dir ;
  struct dirent *entry ;

  {
  {
#line 1205
  scsi_id = (char *)((void *)0);
#line 1209
  scsi_id = lookup_dev(dev_disk_byid_dir, "scsi-", dev_node);
  }
#line 1210
  if (scsi_id) {
#line 1211
    goto out;
  }
  {
#line 1212
  scsi_id = lookup_dev(dev_disk_byid_dir, "dm-uuid-mpath-", dev_node);
  }
#line 1213
  if (scsi_id) {
#line 1214
    goto out;
  }
  {
#line 1215
  scsi_id = lookup_dev(dev_disk_byid_dir, "usb-", dev_node);
  }
#line 1216
  if (scsi_id) {
#line 1217
    goto out;
  }
  {
#line 1218
  snprintf((char */* __restrict  */)(sys_block), sizeof(sys_block), (char const   */* __restrict  */)"%s/class/block/%s/holders",
           sysfsroot, dev_node + 5);
#line 1220
  dir = opendir((char const   *)(sys_block));
  }
#line 1221
  if (! dir) {
#line 1222
    goto out;
  }
  {
#line 1223
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1223
    entry = readdir(dir);
    }
#line 1223
    if (! ((unsigned long )entry != (unsigned long )((void *)0))) {
#line 1223
      goto while_break;
    }
    {
#line 1224
    snprintf((char */* __restrict  */)(holder), sizeof(holder), (char const   */* __restrict  */)"/dev/%s",
             entry->d_name);
#line 1225
    scsi_id = get_disk_scsi_id((char const   *)(holder));
    }
#line 1226
    if (scsi_id) {
#line 1227
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1229
  closedir(dir);
  }
  out: 
#line 1231
  return (scsi_id);
}
}
#line 1239 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static char *get_usb_devname(char const   *hname , char const   *devname , char *b ,
                             int b_len ) 
{ 
  char buff[384] ;
  char bf2[4096] ;
  int len ;
  char const   *np ;
  char *cp ;
  char *c2p ;
  void *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 1249
  if (hname) {
    {
#line 1250
    snprintf((char */* __restrict  */)(buff), sizeof(buff), (char const   */* __restrict  */)"%s%s",
             sysfsroot, scsi_host);
#line 1251
    np = hname;
    }
  } else
#line 1252
  if (devname) {
    {
#line 1253
    snprintf((char */* __restrict  */)(buff), sizeof(buff), (char const   */* __restrict  */)"%s%s",
             sysfsroot, class_scsi_dev);
#line 1255
    np = devname;
    }
  } else {
#line 1257
    return ((char *)((void *)0));
  }
  {
#line 1258
  tmp___0 = if_directory_chdir((char const   *)(buff), np);
  }
#line 1258
  if (tmp___0) {
    {
#line 1258
    tmp___1 = getcwd(bf2, sizeof(bf2));
    }
#line 1258
    if (tmp___1) {
      {
#line 1258
      tmp___2 = strstr((char const   *)(bf2), "usb");
      }
#line 1258
      if (tmp___2) {
#line 1260
        if (b_len > 0) {
#line 1261
          *(b + 0) = (char )'\000';
        }
        {
#line 1262
        cp = strstr((char const   *)(bf2), "/host");
        }
#line 1262
        if (cp) {
#line 1263
          len = (int )((cp - bf2) - 1L);
#line 1264
          if (len > 0) {
            {
#line 1264
            tmp = memrchr((void const   *)(bf2), '/', (size_t )len);
#line 1264
            c2p = (char *)tmp;
            }
#line 1264
            if (c2p) {
              {
#line 1266
              c2p ++;
#line 1266
              len = (int )(cp - c2p);
#line 1267
              snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"%.*s",
                       len, c2p);
              }
            }
          }
        }
#line 1270
        return (b);
      }
    }
  }
#line 1272
  return ((char *)((void *)0));
}
}
#line 1278 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static int parse_colon_list(char const   *colon_list , struct addr_hctl *outp ) 
{ 
  int k ;
  unsigned short u ;
  uint64_t z ;
  char const   *elem_end ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
#line 1286
  if (! colon_list) {
#line 1287
    return (0);
  } else
#line 1286
  if (! outp) {
#line 1287
    return (0);
  }
  {
#line 1288
  tmp = sscanf((char const   */* __restrict  */)colon_list, (char const   */* __restrict  */)"%d",
               & outp->h);
  }
#line 1288
  if (1 != tmp) {
#line 1289
    return (0);
  }
  {
#line 1290
  tmp___0 = strchr(colon_list, ':');
#line 1290
  elem_end = (char const   *)tmp___0;
  }
#line 1290
  if ((unsigned long )((void *)0) == (unsigned long )elem_end) {
#line 1291
    return (0);
  }
  {
#line 1292
  colon_list = elem_end + 1;
#line 1293
  tmp___1 = sscanf((char const   */* __restrict  */)colon_list, (char const   */* __restrict  */)"%d",
                   & outp->c);
  }
#line 1293
  if (1 != tmp___1) {
#line 1294
    return (0);
  }
  {
#line 1295
  tmp___2 = strchr(colon_list, ':');
#line 1295
  elem_end = (char const   *)tmp___2;
  }
#line 1295
  if ((unsigned long )((void *)0) == (unsigned long )elem_end) {
#line 1296
    return (0);
  }
  {
#line 1297
  colon_list = elem_end + 1;
#line 1298
  tmp___3 = sscanf((char const   */* __restrict  */)colon_list, (char const   */* __restrict  */)"%d",
                   & outp->t);
  }
#line 1298
  if (1 != tmp___3) {
#line 1299
    return (0);
  }
  {
#line 1300
  tmp___4 = strchr(colon_list, ':');
#line 1300
  elem_end = (char const   *)tmp___4;
  }
#line 1300
  if ((unsigned long )((void *)0) == (unsigned long )elem_end) {
#line 1301
    return (0);
  }
  {
#line 1302
  colon_list = elem_end + 1;
#line 1303
  tmp___5 = sscanf((char const   */* __restrict  */)colon_list, (char const   */* __restrict  */)"%lu",
                   & outp->l);
  }
#line 1303
  if (1 != tmp___5) {
#line 1304
    return (0);
  }
#line 1305
  z = outp->l;
#line 1306
  k = 0;
  {
#line 1306
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1306
    if (! (k < 4)) {
#line 1306
      goto while_break;
    }
#line 1307
    u = (unsigned short )(z & 65535UL);
#line 1308
    outp->lun_arr[2 * k + 1] = (unsigned char )((int )u & 255);
#line 1309
    outp->lun_arr[2 * k] = (unsigned char )(((int )u >> 8) & 255);
#line 1306
    k ++;
#line 1306
    z >>= 16;
  }
  while_break: /* CIL Label */ ;
  }
#line 1311
  return (1);
}
}
#line 1315 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static void print_enclosure_device(char const   *devname , char const   *path , struct lsscsi_opt_coll  const  *op ) 
{ 
  struct addr_hctl hctl ;
  char b[4096] ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1322
  tmp___0 = parse_colon_list(devname, & hctl);
  }
#line 1322
  if (tmp___0) {
    {
#line 1323
    snprintf((char */* __restrict  */)(b), sizeof(b), (char const   */* __restrict  */)"%s/device/target%d:%d:%d/%d:%d:%d:%lu",
             path, hctl.h, hctl.c, hctl.t, hctl.h, hctl.c, hctl.t, hctl.l);
#line 1327
    tmp = enclosure_device_scan((char const   *)(b), op);
    }
#line 1327
    if (tmp > 0) {
      {
#line 1328
      printf((char const   */* __restrict  */)"  %s\n", enclosure_device.name);
      }
    }
  }
#line 1330
  return;
}
}
#line 1335 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static int transport_init(char const   *devname , int b_len , char *b ) 
{ 
  char buff[384] ;
  char wd[4096] ;
  int off ;
  char *cp ;
  struct stat a_stat ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;
  size_t tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  size_t tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  char *t ;
  char buff2[384] ;
  ssize_t tmp___16 ;
  size_t tmp___17 ;
  size_t tmp___18 ;
  size_t tmp___19 ;
  size_t tmp___20 ;
  size_t tmp___21 ;
  size_t tmp___22 ;
  int tmp___23 ;
  size_t tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  char *tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;

  {
  {
#line 1346
  snprintf((char */* __restrict  */)(buff), sizeof(buff), (char const   */* __restrict  */)"%s%s%s",
           sysfsroot, spi_host, devname);
#line 1347
  tmp = stat((char const   */* __restrict  */)(buff), (struct stat */* __restrict  */)(& a_stat));
  }
#line 1347
  if (tmp >= 0) {
#line 1347
    if ((a_stat.st_mode & 61440U) == 16384U) {
      {
#line 1348
      transport_id = 1;
#line 1349
      snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"spi:");
      }
#line 1350
      return (1);
    }
  }
  {
#line 1354
  snprintf((char */* __restrict  */)(buff), sizeof(buff), (char const   */* __restrict  */)"%s%s%s",
           sysfsroot, fc_host, devname);
#line 1355
  tmp___7 = stat((char const   */* __restrict  */)(buff), (struct stat */* __restrict  */)(& a_stat));
  }
#line 1355
  if (tmp___7 >= 0) {
#line 1355
    if ((a_stat.st_mode & 61440U) == 16384U) {
      {
#line 1356
      tmp___1 = get_value((char const   *)(buff), "symbolic_name", wd, (int )sizeof(wd));
      }
#line 1356
      if (tmp___1) {
        {
#line 1357
        tmp___0 = strstr((char const   *)(wd), " over ");
        }
#line 1357
        if (tmp___0) {
          {
#line 1358
          transport_id = 10;
#line 1359
          snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"fcoe:");
          }
        }
      }
#line 1362
      if (transport_id != 10) {
        {
#line 1363
        transport_id = 2;
#line 1364
        snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"fc:");
        }
      }
      {
#line 1366
      tmp___2 = strlen((char const   *)b);
#line 1366
      off = (int )tmp___2;
#line 1367
      tmp___5 = get_value((char const   *)(buff), "port_name", b + off, b_len - off);
      }
#line 1367
      if (tmp___5) {
        {
#line 1368
        tmp___3 = strlen((char const   *)b);
#line 1368
        off = (int )tmp___3;
#line 1369
        my_strcopy(b + off, ",", (int )(sizeof(b) - (unsigned long )off));
#line 1370
        tmp___4 = strlen((char const   *)b);
#line 1370
        off = (int )tmp___4;
        }
      } else {
#line 1372
        return (0);
      }
      {
#line 1373
      tmp___6 = get_value((char const   *)(buff), "port_id", b + off, b_len - off);
      }
#line 1373
      if (tmp___6) {
#line 1374
        return (1);
      } else {
#line 1376
        return (0);
      }
    }
  }
  {
#line 1381
  snprintf((char */* __restrict  */)(buff), sizeof(buff), (char const   */* __restrict  */)"%s%s%s",
           sysfsroot, sas_host, devname);
#line 1382
  tmp___12 = stat((char const   */* __restrict  */)(buff), (struct stat */* __restrict  */)(& a_stat));
  }
#line 1382
  if (tmp___12 >= 0) {
#line 1382
    if ((a_stat.st_mode & 61440U) == 16384U) {
      {
#line 1383
      transport_id = 3;
#line 1384
      tmp___8 = strlen((char const   *)(buff));
#line 1384
      off = (int )tmp___8;
#line 1385
      snprintf((char */* __restrict  */)(buff + off), sizeof(buff) - (unsigned long )off,
               (char const   */* __restrict  */)"/device");
#line 1386
      tmp___9 = sas_low_phy_scan((char const   *)(buff), (struct dirent ***)((void *)0));
      }
#line 1386
      if (tmp___9 < 1) {
#line 1387
        return (0);
      }
      {
#line 1388
      snprintf((char */* __restrict  */)(buff), sizeof(buff), (char const   */* __restrict  */)"%s%s%s",
               sysfsroot, sas_phy, sas_low_phy);
#line 1390
      snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"sas:");
#line 1391
      tmp___10 = strlen((char const   *)b);
#line 1391
      off = (int )tmp___10;
#line 1392
      tmp___11 = get_value((char const   *)(buff), "sas_address", b + off, b_len - off);
      }
#line 1392
      if (tmp___11) {
#line 1393
        return (1);
      } else {
        {
#line 1395
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"_init: no sas_address, wd=%s\n",
                buff);
        }
      }
    }
  }
  {
#line 1400
  snprintf((char */* __restrict  */)(buff), sizeof(buff), (char const   */* __restrict  */)"%s%s%s%s",
           sysfsroot, scsi_host, devname, "/device/sas/ha");
#line 1402
  tmp___15 = stat((char const   */* __restrict  */)(buff), (struct stat */* __restrict  */)(& a_stat));
  }
#line 1402
  if (tmp___15 >= 0) {
#line 1402
    if ((a_stat.st_mode & 61440U) == 16384U) {
      {
#line 1403
      transport_id = 4;
#line 1404
      snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"sas:");
#line 1405
      tmp___13 = strlen((char const   *)b);
#line 1405
      off = (int )tmp___13;
#line 1406
      tmp___14 = get_value((char const   *)(buff), "device_name", b + off, b_len - off);
      }
#line 1406
      if (tmp___14) {
#line 1407
        return (1);
      } else {
        {
#line 1409
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"_init: no device_name, wd=%s\n",
                buff);
        }
      }
    }
  }
  {
#line 1414
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1418
    snprintf((char */* __restrict  */)(buff), sizeof(buff), (char const   */* __restrict  */)"%s%s%s%s",
             sysfsroot, scsi_host, devname, "/device");
#line 1420
    tmp___16 = readlink((char const   */* __restrict  */)(buff), (char */* __restrict  */)(buff2),
                        sizeof(buff2));
    }
#line 1420
    if (tmp___16 <= 0L) {
#line 1421
      goto while_break;
    }
    {
#line 1424
    t = strstr((char const   *)(buff2), "/fw-host");
    }
#line 1424
    if (! t) {
#line 1425
      goto while_break;
    }
    {
#line 1426
    transport_id = 6;
#line 1429
    t = strchr((char const   *)(t + 1), '/');
    }
#line 1429
    if (! t) {
#line 1430
      goto while_break;
    }
    {
#line 1431
    *t = (char)0;
#line 1434
    tmp___17 = strlen((char const   *)(buff));
#line 1434
    tmp___18 = strlen("device");
#line 1434
    buff[tmp___17 - tmp___18] = (char)0;
#line 1435
    tmp___19 = strlen((char const   *)(buff));
#line 1435
    tmp___20 = strlen((char const   *)(buff2));
#line 1435
    tmp___21 = strlen("host_id/guid");
    }
#line 1435
    if (((tmp___19 + tmp___20) + tmp___21) + 2UL > sizeof(buff)) {
#line 1437
      goto while_break;
    }
    {
#line 1438
    tmp___22 = strlen((char const   *)(buff));
#line 1438
    my_strcopy(buff + tmp___22, (char const   *)(buff2), (int )sizeof(buff));
#line 1441
    tmp___23 = get_value((char const   *)(buff), "host_id/guid", buff2, (int )sizeof(buff2));
    }
#line 1441
    if (tmp___23) {
      {
#line 1441
      tmp___24 = strlen((char const   *)(buff2));
      }
#line 1441
      if (tmp___24 != 18UL) {
#line 1443
        goto while_break;
      }
    } else {
#line 1443
      goto while_break;
    }
    {
#line 1444
    snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"sbp:%s",
             buff2 + 2);
    }
#line 1445
    return (1);
#line 1414
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1449
  snprintf((char */* __restrict  */)(buff), sizeof(buff), (char const   */* __restrict  */)"%s%s%s",
           sysfsroot, iscsi_host, devname);
#line 1450
  tmp___25 = stat((char const   */* __restrict  */)(buff), (struct stat */* __restrict  */)(& a_stat));
  }
#line 1450
  if (tmp___25 >= 0) {
#line 1450
    if ((a_stat.st_mode & 61440U) == 16384U) {
      {
#line 1451
      transport_id = 5;
#line 1452
      snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"iscsi:");
      }
#line 1456
      return (1);
    }
  }
  {
#line 1460
  cp = get_usb_devname(devname, (char const   *)((void *)0), wd, (int )(sizeof(wd) - 1UL));
  }
#line 1461
  if (cp) {
    {
#line 1462
    transport_id = 7;
#line 1463
    snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"usb: %s",
             cp);
    }
#line 1464
    return (1);
  }
  {
#line 1468
  snprintf((char */* __restrict  */)(buff), sizeof(buff), (char const   */* __restrict  */)"%s%s%s",
           sysfsroot, scsi_host, devname);
#line 1469
  tmp___29 = get_value((char const   *)(buff), "proc_name", wd, (int )sizeof(wd));
  }
#line 1469
  if (tmp___29) {
    {
#line 1470
    tmp___28 = strcmp("ahci", (char const   *)(wd));
    }
#line 1470
    if (0 == tmp___28) {
      {
#line 1471
      transport_id = 9;
#line 1472
      snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"sata:");
      }
#line 1473
      return (1);
    } else {
      {
#line 1474
      tmp___27 = strstr((char const   *)(wd), "ata");
      }
#line 1474
      if (tmp___27) {
        {
#line 1475
        tmp___26 = memcmp((void const   *)"sata", (void const   *)(wd), (size_t )4);
        }
#line 1475
        if (0 == tmp___26) {
          {
#line 1476
          transport_id = 9;
#line 1477
          snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"sata:");
          }
#line 1478
          return (1);
        }
        {
#line 1480
        transport_id = 8;
#line 1481
        snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"ata:");
        }
#line 1482
        return (1);
      }
    }
  }
#line 1485
  return (0);
}
}
#line 1491 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static void transport_init_longer(char const   *path_name , struct lsscsi_opt_coll  const  *op ) 
{ 
  char buff[4096] ;
  char bname[256] ;
  char value[256] ;
  char *cp ;
  struct stat a_stat ;
  struct dirent **phylist ;
  struct dirent **portlist ;
  int phynum ;
  int portnum ;
  int i ;
  int j ;
  int len ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  size_t tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  char *tmp___53 ;

  {
  {
#line 1506
  my_strcopy(buff, path_name, (int )sizeof(buff));
#line 1507
  cp = __xpg_basename(buff);
#line 1508
  my_strcopy(bname, (char const   *)cp, (int )sizeof(bname));
#line 1509
  bname[sizeof(bname) - 1UL] = (char )'\000';
#line 1510
  cp = bname;
  }
  {
#line 1512
  if (transport_id == 1) {
#line 1512
    goto case_1;
  }
#line 1520
  if (transport_id == 10) {
#line 1520
    goto case_10;
  }
#line 1520
  if (transport_id == 2) {
#line 1520
    goto case_10;
  }
#line 1563
  if (transport_id == 3) {
#line 1563
    goto case_3;
  }
#line 1693
  if (transport_id == 4) {
#line 1693
    goto case_4;
  }
#line 1731
  if (transport_id == 5) {
#line 1731
    goto case_5;
  }
#line 1737
  if (transport_id == 6) {
#line 1737
    goto case_6;
  }
#line 1740
  if (transport_id == 7) {
#line 1740
    goto case_7;
  }
#line 1745
  if (transport_id == 8) {
#line 1745
    goto case_8;
  }
#line 1748
  if (transport_id == 9) {
#line 1748
    goto case_9;
  }
#line 1751
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 1513
  printf((char const   */* __restrict  */)"  transport=spi\n");
#line 1514
  snprintf((char */* __restrict  */)(buff), sizeof(buff), (char const   */* __restrict  */)"%s%s%s",
           sysfsroot, spi_host, cp);
#line 1516
  tmp = get_value((char const   *)(buff), "signalling", value, (int )sizeof(value));
  }
#line 1516
  if (tmp) {
    {
#line 1517
    printf((char const   */* __restrict  */)"  signalling=%s\n", value);
    }
  }
#line 1518
  goto switch_break;
  case_10: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 1521
  if (transport_id == 2) {
#line 1521
    tmp___0 = "fc:";
  } else {
#line 1521
    tmp___0 = "fcoe:";
  }
  {
#line 1521
  printf((char const   */* __restrict  */)"  transport=%s\n", tmp___0);
#line 1523
  snprintf((char */* __restrict  */)(buff), sizeof(buff), (char const   */* __restrict  */)"%s%s%s",
           path_name, "/device/fc_host/", cp);
#line 1525
  tmp___1 = stat((char const   */* __restrict  */)(buff), (struct stat */* __restrict  */)(& a_stat));
  }
#line 1525
  if (tmp___1 < 0) {
#line 1526
    if (op->verbose > 2) {
      {
#line 1527
      printf((char const   */* __restrict  */)"no fc_host directory\n");
      }
    }
#line 1528
    goto switch_break;
  }
  {
#line 1530
  tmp___2 = get_value((char const   *)(buff), "active_fc4s", value, (int )sizeof(value));
  }
#line 1530
  if (tmp___2) {
    {
#line 1531
    printf((char const   */* __restrict  */)"  active_fc4s=%s\n", value);
    }
  }
  {
#line 1532
  tmp___3 = get_value((char const   *)(buff), "supported_fc4s", value, (int )sizeof(value));
  }
#line 1532
  if (tmp___3) {
    {
#line 1533
    printf((char const   */* __restrict  */)"  supported_fc4s=%s\n", value);
    }
  }
  {
#line 1534
  tmp___4 = get_value((char const   *)(buff), "fabric_name", value, (int )sizeof(value));
  }
#line 1534
  if (tmp___4) {
    {
#line 1535
    printf((char const   */* __restrict  */)"  fabric_name=%s\n", value);
    }
  }
  {
#line 1536
  tmp___5 = get_value((char const   *)(buff), "maxframe_size", value, (int )sizeof(value));
  }
#line 1536
  if (tmp___5) {
    {
#line 1537
    printf((char const   */* __restrict  */)"  maxframe_size=%s\n", value);
    }
  }
  {
#line 1538
  tmp___6 = get_value((char const   *)(buff), "max_npiv_vports", value, (int )sizeof(value));
  }
#line 1538
  if (tmp___6) {
    {
#line 1539
    printf((char const   */* __restrict  */)"  max_npiv_vports=%s\n", value);
    }
  }
  {
#line 1540
  tmp___7 = get_value((char const   *)(buff), "npiv_vports_inuse", value, (int )sizeof(value));
  }
#line 1540
  if (tmp___7) {
    {
#line 1541
    printf((char const   */* __restrict  */)"  npiv_vports_inuse=%s\n", value);
    }
  }
  {
#line 1542
  tmp___8 = get_value((char const   *)(buff), "node_name", value, (int )sizeof(value));
  }
#line 1542
  if (tmp___8) {
    {
#line 1543
    printf((char const   */* __restrict  */)"  node_name=%s\n", value);
    }
  }
  {
#line 1544
  tmp___9 = get_value((char const   *)(buff), "port_name", value, (int )sizeof(value));
  }
#line 1544
  if (tmp___9) {
    {
#line 1545
    printf((char const   */* __restrict  */)"  port_name=%s\n", value);
    }
  }
  {
#line 1546
  tmp___10 = get_value((char const   *)(buff), "port_id", value, (int )sizeof(value));
  }
#line 1546
  if (tmp___10) {
    {
#line 1547
    printf((char const   */* __restrict  */)"  port_id=%s\n", value);
    }
  }
  {
#line 1548
  tmp___11 = get_value((char const   *)(buff), "port_state", value, (int )sizeof(value));
  }
#line 1548
  if (tmp___11) {
    {
#line 1549
    printf((char const   */* __restrict  */)"  port_state=%s\n", value);
    }
  }
  {
#line 1550
  tmp___12 = get_value((char const   *)(buff), "port_type", value, (int )sizeof(value));
  }
#line 1550
  if (tmp___12) {
    {
#line 1551
    printf((char const   */* __restrict  */)"  port_type=%s\n", value);
    }
  }
  {
#line 1552
  tmp___13 = get_value((char const   *)(buff), "speed", value, (int )sizeof(value));
  }
#line 1552
  if (tmp___13) {
    {
#line 1553
    printf((char const   */* __restrict  */)"  speed=%s\n", value);
    }
  }
  {
#line 1554
  tmp___14 = get_value((char const   *)(buff), "supported_speeds", value, (int )sizeof(value));
  }
#line 1554
  if (tmp___14) {
    {
#line 1555
    printf((char const   */* __restrict  */)"  supported_speeds=%s\n", value);
    }
  }
  {
#line 1556
  tmp___15 = get_value((char const   *)(buff), "supported_classes", value, (int )sizeof(value));
  }
#line 1556
  if (tmp___15) {
    {
#line 1557
    printf((char const   */* __restrict  */)"  supported_classes=%s\n", value);
    }
  }
  {
#line 1558
  tmp___16 = get_value((char const   *)(buff), "tgtid_bind_type", value, (int )sizeof(value));
  }
#line 1558
  if (tmp___16) {
    {
#line 1559
    printf((char const   */* __restrict  */)"  tgtid_bind_type=%s\n", value);
    }
  }
#line 1560
  if (op->verbose > 2) {
    {
#line 1561
    printf((char const   */* __restrict  */)"fetched from directory: %s\n", buff);
    }
  }
#line 1562
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 1564
  printf((char const   */* __restrict  */)"  transport=sas\n");
#line 1565
  snprintf((char */* __restrict  */)(buff), sizeof(buff), (char const   */* __restrict  */)"%s%s",
           path_name, "/device");
#line 1566
  portnum = sas_port_scan((char const   *)(buff), & portlist);
  }
#line 1566
  if (portnum < 1) {
    {
#line 1568
    printf((char const   */* __restrict  */)"  no configured ports\n");
#line 1569
    phynum = sas_low_phy_scan((char const   *)(buff), & phylist);
    }
#line 1569
    if (phynum < 1) {
      {
#line 1570
      printf((char const   */* __restrict  */)"  no configured phys\n");
      }
#line 1571
      return;
    }
#line 1573
    i = 0;
    {
#line 1573
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1573
      if (! (i < phynum)) {
#line 1573
        goto while_break;
      }
      {
#line 1575
      snprintf((char */* __restrict  */)(buff), sizeof(buff), (char const   */* __restrict  */)"%s%s%s",
               sysfsroot, sas_phy, (*(phylist + i))->d_name);
#line 1578
      printf((char const   */* __restrict  */)"  %s\n", (*(phylist + i))->d_name);
#line 1579
      tmp___17 = get_value((char const   *)(buff), "sas_address", value, (int )sizeof(value));
      }
#line 1579
      if (tmp___17) {
        {
#line 1581
        printf((char const   */* __restrict  */)"    sas_address=%s\n", value);
        }
      }
      {
#line 1582
      tmp___18 = get_value((char const   *)(buff), "phy_identifier", value, (int )sizeof(value));
      }
#line 1582
      if (tmp___18) {
        {
#line 1584
        printf((char const   */* __restrict  */)"    phy_identifier=%s\n", value);
        }
      }
      {
#line 1586
      tmp___19 = get_value((char const   *)(buff), "minimum_linkrate", value, (int )sizeof(value));
      }
#line 1586
      if (tmp___19) {
        {
#line 1588
        printf((char const   */* __restrict  */)"    minimum_linkrate=%s\n", value);
        }
      }
      {
#line 1590
      tmp___20 = get_value((char const   *)(buff), "minimum_linkrate_hw", value, (int )sizeof(value));
      }
#line 1590
      if (tmp___20) {
        {
#line 1592
        printf((char const   */* __restrict  */)"    minimum_linkrate_hw=%s\n", value);
        }
      }
      {
#line 1594
      tmp___21 = get_value((char const   *)(buff), "maximum_linkrate", value, (int )sizeof(value));
      }
#line 1594
      if (tmp___21) {
        {
#line 1596
        printf((char const   */* __restrict  */)"    maximum_linkrate=%s\n", value);
        }
      }
      {
#line 1598
      tmp___22 = get_value((char const   *)(buff), "maximum_linkrate_hw", value, (int )sizeof(value));
      }
#line 1598
      if (tmp___22) {
        {
#line 1600
        printf((char const   */* __restrict  */)"    maximum_linkrate_hw=%s\n", value);
        }
      }
      {
#line 1602
      tmp___23 = get_value((char const   *)(buff), "negotiated_linkrate", value, (int )sizeof(value));
      }
#line 1602
      if (tmp___23) {
        {
#line 1604
        printf((char const   */* __restrict  */)"    negotiated_linkrate=%s\n", value);
        }
      }
#line 1573
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1607
    return;
  }
#line 1609
  i = 0;
  {
#line 1609
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1609
    if (! (i < portnum)) {
#line 1609
      goto while_break___0;
    }
    {
#line 1610
    snprintf((char */* __restrict  */)(buff), sizeof(buff), (char const   */* __restrict  */)"%s%s%s",
             path_name, "/device/", (*(portlist + i))->d_name);
#line 1612
    phynum = sas_low_phy_scan((char const   *)(buff), & phylist);
    }
#line 1612
    if (phynum < 1) {
      {
#line 1613
      printf((char const   */* __restrict  */)"  %s: phy list not available\n", (*(portlist + i))->d_name);
#line 1615
      free((void *)*(portlist + i));
      }
#line 1616
      goto __Cont;
    }
    {
#line 1619
    snprintf((char */* __restrict  */)(buff), sizeof(buff), (char const   */* __restrict  */)"%s%s%s",
             sysfsroot, sas_port, (*(portlist + i))->d_name);
#line 1621
    tmp___24 = get_value((char const   *)(buff), "num_phys", value, (int )sizeof(value));
    }
#line 1621
    if (tmp___24) {
      {
#line 1623
      printf((char const   */* __restrict  */)"  %s: num_phys=%s,", (*(portlist + i))->d_name,
             value);
#line 1625
      j = 0;
      }
      {
#line 1625
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1625
        if (! (j < phynum)) {
#line 1625
          goto while_break___1;
        }
        {
#line 1626
        printf((char const   */* __restrict  */)" %s", (*(phylist + j))->d_name);
#line 1627
        free((void *)*(phylist + j));
#line 1625
        j ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 1629
      printf((char const   */* __restrict  */)"\n");
      }
#line 1630
      if (op->verbose > 2) {
        {
#line 1631
        printf((char const   */* __restrict  */)"  fetched from directory: %s\n",
               buff);
        }
      }
      {
#line 1633
      free((void *)phylist);
      }
    }
    {
#line 1635
    snprintf((char */* __restrict  */)(buff), sizeof(buff), (char const   */* __restrict  */)"%s%s%s",
             sysfsroot, sas_phy, sas_low_phy);
#line 1637
    tmp___25 = get_value((char const   *)(buff), "device_type", value, (int )sizeof(value));
    }
#line 1637
    if (tmp___25) {
      {
#line 1639
      printf((char const   */* __restrict  */)"    device_type=%s\n", value);
      }
    }
    {
#line 1640
    tmp___26 = get_value((char const   *)(buff), "initiator_port_protocols", value,
                         (int )sizeof(value));
    }
#line 1640
    if (tmp___26) {
      {
#line 1642
      printf((char const   */* __restrict  */)"    initiator_port_protocols=%s\n",
             value);
      }
    }
    {
#line 1644
    tmp___27 = get_value((char const   *)(buff), "invalid_dword_count", value, (int )sizeof(value));
    }
#line 1644
    if (tmp___27) {
      {
#line 1646
      printf((char const   */* __restrict  */)"    invalid_dword_count=%s\n", value);
      }
    }
    {
#line 1647
    tmp___28 = get_value((char const   *)(buff), "loss_of_dword_sync_count", value,
                         (int )sizeof(value));
    }
#line 1647
    if (tmp___28) {
      {
#line 1649
      printf((char const   */* __restrict  */)"    loss_of_dword_sync_count=%s\n",
             value);
      }
    }
    {
#line 1651
    tmp___29 = get_value((char const   *)(buff), "minimum_linkrate", value, (int )sizeof(value));
    }
#line 1651
    if (tmp___29) {
      {
#line 1653
      printf((char const   */* __restrict  */)"    minimum_linkrate=%s\n", value);
      }
    }
    {
#line 1654
    tmp___30 = get_value((char const   *)(buff), "minimum_linkrate_hw", value, (int )sizeof(value));
    }
#line 1654
    if (tmp___30) {
      {
#line 1656
      printf((char const   */* __restrict  */)"    minimum_linkrate_hw=%s\n", value);
      }
    }
    {
#line 1657
    tmp___31 = get_value((char const   *)(buff), "maximum_linkrate", value, (int )sizeof(value));
    }
#line 1657
    if (tmp___31) {
      {
#line 1659
      printf((char const   */* __restrict  */)"    maximum_linkrate=%s\n", value);
      }
    }
    {
#line 1660
    tmp___32 = get_value((char const   *)(buff), "maximum_linkrate_hw", value, (int )sizeof(value));
    }
#line 1660
    if (tmp___32) {
      {
#line 1662
      printf((char const   */* __restrict  */)"    maximum_linkrate_hw=%s\n", value);
      }
    }
    {
#line 1663
    tmp___33 = get_value((char const   *)(buff), "negotiated_linkrate", value, (int )sizeof(value));
    }
#line 1663
    if (tmp___33) {
      {
#line 1665
      printf((char const   */* __restrict  */)"    negotiated_linkrate=%s\n", value);
      }
    }
    {
#line 1666
    tmp___34 = get_value((char const   *)(buff), "phy_identifier", value, (int )sizeof(value));
    }
#line 1666
    if (tmp___34) {
      {
#line 1668
      printf((char const   */* __restrict  */)"    phy_identifier=%s\n", value);
      }
    }
    {
#line 1669
    tmp___35 = get_value((char const   *)(buff), "phy_reset_problem_count", value,
                         (int )sizeof(value));
    }
#line 1669
    if (tmp___35) {
      {
#line 1671
      printf((char const   */* __restrict  */)"    phy_reset_problem_count=%s\n",
             value);
      }
    }
    {
#line 1673
    tmp___36 = get_value((char const   *)(buff), "running_disparity_error_count",
                         value, (int )sizeof(value));
    }
#line 1673
    if (tmp___36) {
      {
#line 1675
      printf((char const   */* __restrict  */)"    running_disparity_error_count=%s\n",
             value);
      }
    }
    {
#line 1677
    tmp___37 = get_value((char const   *)(buff), "sas_address", value, (int )sizeof(value));
    }
#line 1677
    if (tmp___37) {
      {
#line 1679
      printf((char const   */* __restrict  */)"    sas_address=%s\n", value);
      }
    }
    {
#line 1680
    tmp___38 = get_value((char const   *)(buff), "target_port_protocols", value, (int )sizeof(value));
    }
#line 1680
    if (tmp___38) {
      {
#line 1682
      printf((char const   */* __restrict  */)"    target_port_protocols=%s\n", value);
      }
    }
#line 1684
    if (op->verbose > 2) {
      {
#line 1685
      printf((char const   */* __restrict  */)"  fetched from directory: %s\n", buff);
      }
    }
    {
#line 1687
    free((void *)*(portlist + i));
    }
    __Cont: /* CIL Label */ 
#line 1609
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1690
  free((void *)portlist);
  }
#line 1692
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 1694
  printf((char const   */* __restrict  */)"  transport=sas\n");
#line 1695
  printf((char const   */* __restrict  */)"  sub_transport=sas_class\n");
#line 1696
  snprintf((char */* __restrict  */)(buff), sizeof(buff), (char const   */* __restrict  */)"%s%s",
           path_name, "/device/sas/ha");
#line 1698
  tmp___39 = get_value((char const   *)(buff), "device_name", value, (int )sizeof(value));
  }
#line 1698
  if (tmp___39) {
    {
#line 1699
    printf((char const   */* __restrict  */)"  device_name=%s\n", value);
    }
  }
  {
#line 1700
  tmp___40 = get_value((char const   *)(buff), "ha_name", value, (int )sizeof(value));
  }
#line 1700
  if (tmp___40) {
    {
#line 1701
    printf((char const   */* __restrict  */)"  ha_name=%s\n", value);
    }
  }
  {
#line 1702
  tmp___41 = get_value((char const   *)(buff), "version_descriptor", value, (int )sizeof(value));
  }
#line 1702
  if (tmp___41) {
    {
#line 1704
    printf((char const   */* __restrict  */)"  version_descriptor=%s\n", value);
    }
  }
  {
#line 1705
  printf((char const   */* __restrict  */)"  phy0:\n");
#line 1706
  tmp___42 = strlen((char const   *)(buff));
#line 1706
  len = (int )tmp___42;
#line 1707
  snprintf((char */* __restrict  */)(buff + len), sizeof(buff) - (unsigned long )len,
           (char const   */* __restrict  */)"%s", "/phys/0");
#line 1708
  tmp___43 = get_value((char const   *)(buff), "class", value, (int )sizeof(value));
  }
#line 1708
  if (tmp___43) {
    {
#line 1709
    printf((char const   */* __restrict  */)"    class=%s\n", value);
    }
  }
  {
#line 1710
  tmp___44 = get_value((char const   *)(buff), "enabled", value, (int )sizeof(value));
  }
#line 1710
  if (tmp___44) {
    {
#line 1711
    printf((char const   */* __restrict  */)"    enabled=%s\n", value);
    }
  }
  {
#line 1712
  tmp___45 = get_value((char const   *)(buff), "id", value, (int )sizeof(value));
  }
#line 1712
  if (tmp___45) {
    {
#line 1713
    printf((char const   */* __restrict  */)"    id=%s\n", value);
    }
  }
  {
#line 1714
  tmp___46 = get_value((char const   *)(buff), "iproto", value, (int )sizeof(value));
  }
#line 1714
  if (tmp___46) {
    {
#line 1715
    printf((char const   */* __restrict  */)"    iproto=%s\n", value);
    }
  }
  {
#line 1716
  tmp___47 = get_value((char const   *)(buff), "linkrate", value, (int )sizeof(value));
  }
#line 1716
  if (tmp___47) {
    {
#line 1717
    printf((char const   */* __restrict  */)"    linkrate=%s\n", value);
    }
  }
  {
#line 1718
  tmp___48 = get_value((char const   *)(buff), "oob_mode", value, (int )sizeof(value));
  }
#line 1718
  if (tmp___48) {
    {
#line 1719
    printf((char const   */* __restrict  */)"    oob_mode=%s\n", value);
    }
  }
  {
#line 1720
  tmp___49 = get_value((char const   *)(buff), "role", value, (int )sizeof(value));
  }
#line 1720
  if (tmp___49) {
    {
#line 1721
    printf((char const   */* __restrict  */)"    role=%s\n", value);
    }
  }
  {
#line 1722
  tmp___50 = get_value((char const   *)(buff), "sas_addr", value, (int )sizeof(value));
  }
#line 1722
  if (tmp___50) {
    {
#line 1723
    printf((char const   */* __restrict  */)"    sas_addr=%s\n", value);
    }
  }
  {
#line 1724
  tmp___51 = get_value((char const   *)(buff), "tproto", value, (int )sizeof(value));
  }
#line 1724
  if (tmp___51) {
    {
#line 1725
    printf((char const   */* __restrict  */)"    tproto=%s\n", value);
    }
  }
  {
#line 1726
  tmp___52 = get_value((char const   *)(buff), "type", value, (int )sizeof(value));
  }
#line 1726
  if (tmp___52) {
    {
#line 1727
    printf((char const   */* __restrict  */)"    type=%s\n", value);
    }
  }
#line 1728
  if (op->verbose > 2) {
    {
#line 1729
    printf((char const   */* __restrict  */)"fetched from directory: %s\n", buff);
    }
  }
#line 1730
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 1732
  printf((char const   */* __restrict  */)"  transport=iSCSI\n");
  }
#line 1736
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 1738
  printf((char const   */* __restrict  */)"  transport=sbp\n");
  }
#line 1739
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 1741
  printf((char const   */* __restrict  */)"  transport=usb\n");
#line 1742
  tmp___53 = get_usb_devname((char const   *)cp, (char const   *)((void *)0), value,
                             (int )sizeof(value));
#line 1742
  printf((char const   */* __restrict  */)"  device_name=%s\n", tmp___53);
  }
#line 1744
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 1746
  printf((char const   */* __restrict  */)"  transport=ata\n");
  }
#line 1747
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 1749
  printf((char const   */* __restrict  */)"  transport=sata\n");
  }
#line 1750
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1752
  if (op->verbose > 1) {
    {
#line 1753
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"No transport information\n");
    }
  }
#line 1754
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1756
  return;
}
}
#line 1761 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static int transport_tport(char const   *devname , int b_len , char *b ) 
{ 
  char buff[384] ;
  char wd[4096] ;
  char nm[256] ;
  char tpgt[256] ;
  char *cp ;
  struct addr_hctl hctl ;
  int off ;
  int n ;
  struct stat a_stat ;
  int tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  size_t tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;

  {
  {
#line 1774
  tmp = parse_colon_list(devname, & hctl);
  }
#line 1774
  if (! tmp) {
#line 1775
    return (0);
  }
  {
#line 1778
  snprintf((char */* __restrict  */)(buff), sizeof(buff), (char const   */* __restrict  */)"%s%shost%d",
           sysfsroot, sas_host, hctl.h);
#line 1780
  tmp___4 = stat((char const   */* __restrict  */)(buff), (struct stat */* __restrict  */)(& a_stat));
  }
#line 1780
  if (tmp___4 >= 0) {
#line 1780
    if ((a_stat.st_mode & 61440U) == 16384U) {
      {
#line 1782
      transport_id = 3;
#line 1783
      snprintf((char */* __restrict  */)(buff), sizeof(buff), (char const   */* __restrict  */)"%s%s%s",
               sysfsroot, class_scsi_dev, devname);
#line 1785
      tmp___3 = if_directory_chdir((char const   *)(buff), "device");
      }
#line 1785
      if (tmp___3) {
        {
#line 1786
        tmp___0 = getcwd(wd, sizeof(wd));
        }
#line 1786
        if ((unsigned long )((void *)0) == (unsigned long )tmp___0) {
#line 1787
          return (0);
        }
        {
#line 1788
        cp = strrchr((char const   *)(wd), '/');
        }
#line 1789
        if ((unsigned long )((void *)0) == (unsigned long )cp) {
#line 1790
          return (0);
        }
        {
#line 1791
        *cp = (char )'\000';
#line 1792
        cp = strrchr((char const   *)(wd), '/');
        }
#line 1793
        if ((unsigned long )((void *)0) == (unsigned long )cp) {
#line 1794
          return (0);
        }
        {
#line 1795
        *cp = (char )'\000';
#line 1796
        cp = __xpg_basename(wd);
#line 1797
        my_strcopy(sas_hold_end_device, (char const   *)cp, (int )sizeof(sas_hold_end_device));
#line 1799
        snprintf((char */* __restrict  */)(buff), sizeof(buff), (char const   */* __restrict  */)"%s%s%s",
                 sysfsroot, sas_device, cp);
#line 1802
        snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"sas:");
#line 1803
        tmp___1 = strlen((char const   *)b);
#line 1803
        off = (int )tmp___1;
#line 1804
        tmp___2 = get_value((char const   *)(buff), "sas_address", b + off, b_len - off);
        }
#line 1804
        if (tmp___2) {
#line 1806
          return (1);
        } else {
          {
#line 1808
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"_tport: no sas_address, wd=%s\n",
                  buff);
          }
        }
      } else {
        {
#line 1811
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"_tport: down FAILED: %s\n",
                buff);
        }
      }
#line 1812
      return (0);
    }
  }
  {
#line 1816
  snprintf((char */* __restrict  */)(buff), sizeof(buff), (char const   */* __restrict  */)"%s%shost%d",
           sysfsroot, spi_host, hctl.h);
#line 1818
  tmp___5 = stat((char const   */* __restrict  */)(buff), (struct stat */* __restrict  */)(& a_stat));
  }
#line 1818
  if (tmp___5 >= 0) {
#line 1818
    if ((a_stat.st_mode & 61440U) == 16384U) {
      {
#line 1819
      transport_id = 1;
#line 1820
      snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"spi:%d",
               hctl.t);
      }
#line 1821
      return (1);
    }
  }
  {
#line 1825
  snprintf((char */* __restrict  */)(buff), sizeof(buff), (char const   */* __restrict  */)"%s%shost%d",
           sysfsroot, fc_host, hctl.h);
#line 1827
  tmp___13 = stat((char const   */* __restrict  */)(buff), (struct stat */* __restrict  */)(& a_stat));
  }
#line 1827
  if (tmp___13 >= 0) {
#line 1827
    if ((a_stat.st_mode & 61440U) == 16384U) {
      {
#line 1828
      tmp___7 = get_value((char const   *)(buff), "symbolic_name", wd, (int )sizeof(wd));
      }
#line 1828
      if (tmp___7) {
        {
#line 1829
        tmp___6 = strstr((char const   *)(wd), " over ");
        }
#line 1829
        if (tmp___6) {
          {
#line 1830
          transport_id = 10;
#line 1831
          snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"fcoe:");
          }
        }
      }
#line 1834
      if (transport_id != 10) {
        {
#line 1835
        transport_id = 2;
#line 1836
        snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"fc:");
        }
      }
      {
#line 1838
      snprintf((char */* __restrict  */)(buff), sizeof(buff), (char const   */* __restrict  */)"%s%starget%d:%d:%d",
               sysfsroot, fc_transport, hctl.h, hctl.c, hctl.t);
#line 1840
      tmp___8 = strlen((char const   *)b);
#line 1840
      off = (int )tmp___8;
#line 1841
      tmp___11 = get_value((char const   *)(buff), "port_name", b + off, b_len - off);
      }
#line 1841
      if (tmp___11) {
        {
#line 1842
        tmp___9 = strlen((char const   *)b);
#line 1842
        off = (int )tmp___9;
#line 1843
        my_strcopy(b + off, ",", (int )(sizeof(b) - (unsigned long )off));
#line 1844
        tmp___10 = strlen((char const   *)b);
#line 1844
        off = (int )tmp___10;
        }
      } else {
#line 1846
        return (0);
      }
      {
#line 1847
      tmp___12 = get_value((char const   *)(buff), "port_id", b + off, b_len - off);
      }
#line 1847
      if (tmp___12) {
#line 1848
        return (1);
      } else {
#line 1850
        return (0);
      }
    }
  }
  {
#line 1854
  snprintf((char */* __restrict  */)(buff), sizeof(buff), (char const   */* __restrict  */)"%s%s/%s",
           sysfsroot, bus_scsi_devs, devname);
#line 1856
  tmp___17 = if_directory_chdir((char const   *)(buff), "sas_device");
  }
#line 1856
  if (tmp___17) {
    {
#line 1857
    transport_id = 4;
#line 1858
    snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"sas:");
#line 1859
    tmp___14 = strlen((char const   *)b);
#line 1859
    off = (int )tmp___14;
#line 1860
    tmp___15 = get_value(".", "sas_addr", b + off, b_len - off);
    }
#line 1860
    if (tmp___15) {
#line 1861
      return (1);
    } else {
      {
#line 1863
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"_tport: no sas_addr, wd=%s\n",
              buff);
      }
    }
  } else {
    {
#line 1865
    tmp___16 = get_value((char const   *)(buff), "ieee1394_id", wd, (int )sizeof(wd));
    }
#line 1865
    if (tmp___16) {
      {
#line 1867
      transport_id = 6;
#line 1868
      snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"sbp:%s",
               wd);
      }
#line 1869
      return (1);
    }
  }
  {
#line 1873
  snprintf((char */* __restrict  */)(buff), sizeof(buff), (char const   */* __restrict  */)"%s%shost%d/device",
           sysfsroot, iscsi_host, hctl.h);
#line 1875
  tmp___21 = stat((char const   */* __restrict  */)(buff), (struct stat */* __restrict  */)(& a_stat));
  }
#line 1875
  if (tmp___21 >= 0) {
#line 1875
    if ((a_stat.st_mode & 61440U) == 16384U) {
      {
#line 1876
      tmp___18 = iscsi_target_scan((char const   *)(buff), (struct addr_hctl  const  *)(& hctl));
      }
#line 1876
      if (1 != tmp___18) {
#line 1877
        return (0);
      }
      {
#line 1878
      transport_id = 5;
#line 1879
      snprintf((char */* __restrict  */)(buff), sizeof(buff), (char const   */* __restrict  */)"%s%ssession%d",
               sysfsroot, iscsi_session, iscsi_tsession_num);
#line 1881
      tmp___19 = get_value((char const   *)(buff), "targetname", nm, (int )sizeof(nm));
      }
#line 1881
      if (! tmp___19) {
#line 1882
        return (0);
      }
      {
#line 1883
      tmp___20 = get_value((char const   *)(buff), "tpgt", tpgt, (int )sizeof(tpgt));
      }
#line 1883
      if (! tmp___20) {
#line 1884
        return (0);
      }
      {
#line 1885
      n = atoi((char const   *)(tpgt));
#line 1887
      snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"%s,t,0x%x",
               nm, n);
      }
#line 1890
      return (1);
    }
  }
  {
#line 1894
  cp = get_usb_devname((char const   *)((void *)0), devname, wd, (int )(sizeof(wd) - 1UL));
  }
#line 1895
  if (cp) {
    {
#line 1896
    transport_id = 7;
#line 1897
    snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"usb: %s",
             cp);
    }
#line 1898
    return (1);
  }
  {
#line 1902
  snprintf((char */* __restrict  */)(buff), sizeof(buff), (char const   */* __restrict  */)"%s%shost%d",
           sysfsroot, scsi_host, hctl.h);
#line 1904
  tmp___25 = get_value((char const   *)(buff), "proc_name", wd, (int )sizeof(wd));
  }
#line 1904
  if (tmp___25) {
    {
#line 1905
    tmp___24 = strcmp("ahci", (char const   *)(wd));
    }
#line 1905
    if (0 == tmp___24) {
      {
#line 1906
      transport_id = 9;
#line 1907
      snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"sata:");
      }
#line 1908
      return (1);
    } else {
      {
#line 1909
      tmp___23 = strstr((char const   *)(wd), "ata");
      }
#line 1909
      if (tmp___23) {
        {
#line 1910
        tmp___22 = memcmp((void const   *)"sata", (void const   *)(wd), (size_t )4);
        }
#line 1910
        if (0 == tmp___22) {
          {
#line 1911
          transport_id = 9;
#line 1912
          snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"sata:");
          }
#line 1913
          return (1);
        }
        {
#line 1915
        transport_id = 8;
#line 1916
        snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"ata:");
        }
#line 1917
        return (1);
      }
    }
  }
#line 1920
  return (0);
}
}
#line 1925 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static void transport_tport_longer(char const   *devname , struct lsscsi_opt_coll  const  *op ) 
{ 
  char path_name[384] ;
  char buff[384] ;
  char b2[384] ;
  char wd[4096] ;
  char value[256] ;
  struct addr_hctl hctl ;
  char *cp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char const   *tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  char *tmp___62 ;
  int tmp___63 ;
  char *tmp___64 ;

  {
  {
#line 1944
  snprintf((char */* __restrict  */)(path_name), sizeof(path_name), (char const   */* __restrict  */)"%s%s%s",
           sysfsroot, class_scsi_dev, devname);
#line 1946
  my_strcopy(buff, (char const   *)(path_name), (int )sizeof(buff));
  }
  {
#line 1949
  if (transport_id == 1) {
#line 1949
    goto case_1;
  }
#line 1972
  if (transport_id == 10) {
#line 1972
    goto case_10;
  }
#line 1972
  if (transport_id == 2) {
#line 1972
    goto case_10;
  }
#line 2028
  if (transport_id == 3) {
#line 2028
    goto case_3;
  }
#line 2074
  if (transport_id == 4) {
#line 2074
    goto case_4;
  }
#line 2114
  if (transport_id == 5) {
#line 2114
    goto case_5;
  }
#line 2148
  if (transport_id == 6) {
#line 2148
    goto case_6;
  }
#line 2159
  if (transport_id == 7) {
#line 2159
    goto case_7;
  }
#line 2164
  if (transport_id == 8) {
#line 2164
    goto case_8;
  }
#line 2167
  if (transport_id == 9) {
#line 2167
    goto case_9;
  }
#line 2170
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 1950
  printf((char const   */* __restrict  */)"  transport=spi\n");
#line 1951
  tmp = parse_colon_list(devname, & hctl);
  }
#line 1951
  if (! tmp) {
#line 1952
    goto switch_break;
  }
  {
#line 1953
  snprintf((char */* __restrict  */)(buff), sizeof(buff), (char const   */* __restrict  */)"%s%starget%d:%d:%d",
           sysfsroot, spi_transport, hctl.h, hctl.c, hctl.t);
#line 1955
  printf((char const   */* __restrict  */)"  target_id=%d\n", hctl.t);
#line 1956
  tmp___0 = get_value((char const   *)(buff), "dt", value, (int )sizeof(value));
  }
#line 1956
  if (tmp___0) {
    {
#line 1957
    printf((char const   */* __restrict  */)"  dt=%s\n", value);
    }
  }
  {
#line 1958
  tmp___1 = get_value((char const   *)(buff), "max_offset", value, (int )sizeof(value));
  }
#line 1958
  if (tmp___1) {
    {
#line 1959
    printf((char const   */* __restrict  */)"  max_offset=%s\n", value);
    }
  }
  {
#line 1960
  tmp___2 = get_value((char const   *)(buff), "max_width", value, (int )sizeof(value));
  }
#line 1960
  if (tmp___2) {
    {
#line 1961
    printf((char const   */* __restrict  */)"  max_width=%s\n", value);
    }
  }
  {
#line 1962
  tmp___3 = get_value((char const   *)(buff), "min_period", value, (int )sizeof(value));
  }
#line 1962
  if (tmp___3) {
    {
#line 1963
    printf((char const   */* __restrict  */)"  min_period=%s\n", value);
    }
  }
  {
#line 1964
  tmp___4 = get_value((char const   *)(buff), "offset", value, (int )sizeof(value));
  }
#line 1964
  if (tmp___4) {
    {
#line 1965
    printf((char const   */* __restrict  */)"  offset=%s\n", value);
    }
  }
  {
#line 1966
  tmp___5 = get_value((char const   *)(buff), "period", value, (int )sizeof(value));
  }
#line 1966
  if (tmp___5) {
    {
#line 1967
    printf((char const   */* __restrict  */)"  period=%s\n", value);
    }
  }
  {
#line 1968
  tmp___6 = get_value((char const   *)(buff), "width", value, (int )sizeof(value));
  }
#line 1968
  if (tmp___6) {
    {
#line 1969
    printf((char const   */* __restrict  */)"  width=%s\n", value);
    }
  }
#line 1970
  goto switch_break;
  case_10: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 1973
  if (transport_id == 2) {
#line 1973
    tmp___7 = "fc:";
  } else {
#line 1973
    tmp___7 = "fcoe:";
  }
  {
#line 1973
  printf((char const   */* __restrict  */)"  transport=%s\n", tmp___7);
#line 1975
  tmp___8 = if_directory_chdir((char const   *)(path_name), "device");
  }
#line 1975
  if (! tmp___8) {
#line 1976
    return;
  }
  {
#line 1977
  tmp___9 = getcwd(wd, sizeof(wd));
  }
#line 1977
  if ((unsigned long )((void *)0) == (unsigned long )tmp___9) {
#line 1978
    return;
  }
  {
#line 1979
  cp = strrchr((char const   *)(wd), '/');
  }
#line 1980
  if ((unsigned long )((void *)0) == (unsigned long )cp) {
#line 1981
    return;
  }
  {
#line 1982
  *cp = (char )'\000';
#line 1983
  cp = strrchr((char const   *)(wd), '/');
  }
#line 1984
  if ((unsigned long )((void *)0) == (unsigned long )cp) {
#line 1985
    return;
  }
  {
#line 1986
  *cp = (char )'\000';
#line 1987
  cp = __xpg_basename(wd);
#line 1988
  snprintf((char */* __restrict  */)(buff), sizeof(buff), (char const   */* __restrict  */)"%s%s",
           "fc_remote_ports/", cp);
#line 1989
  tmp___11 = if_directory_chdir((char const   *)(wd), (char const   *)(buff));
  }
#line 1989
  if (tmp___11) {
    {
#line 1990
    tmp___10 = getcwd(buff, sizeof(buff));
    }
#line 1990
    if ((unsigned long )((void *)0) == (unsigned long )tmp___10) {
#line 1991
      return;
    }
  } else {
    {
#line 1994
    snprintf((char */* __restrict  */)(buff), sizeof(buff), (char const   */* __restrict  */)"%s%s%s/",
             sysfsroot, fc_remote_ports, cp);
    }
  }
  {
#line 1997
  snprintf((char */* __restrict  */)(b2), sizeof(b2), (char const   */* __restrict  */)"%s%s",
           path_name, "/device/");
#line 1998
  tmp___12 = get_value((char const   *)(b2), "vendor", value, (int )sizeof(value));
  }
#line 1998
  if (tmp___12) {
    {
#line 1999
    printf((char const   */* __restrict  */)"  vendor=%s\n", value);
    }
  }
  {
#line 2000
  tmp___13 = get_value((char const   *)(b2), "model", value, (int )sizeof(value));
  }
#line 2000
  if (tmp___13) {
    {
#line 2001
    printf((char const   */* __restrict  */)"  model=%s\n", value);
    }
  }
  {
#line 2002
  printf((char const   */* __restrict  */)"  %s\n", cp);
#line 2003
  tmp___14 = get_value((char const   *)(buff), "node_name", value, (int )sizeof(value));
  }
#line 2003
  if (tmp___14) {
    {
#line 2004
    printf((char const   */* __restrict  */)"  node_name=%s\n", value);
    }
  }
  {
#line 2005
  tmp___15 = get_value((char const   *)(buff), "port_name", value, (int )sizeof(value));
  }
#line 2005
  if (tmp___15) {
    {
#line 2006
    printf((char const   */* __restrict  */)"  port_name=%s\n", value);
    }
  }
  {
#line 2007
  tmp___16 = get_value((char const   *)(buff), "port_id", value, (int )sizeof(value));
  }
#line 2007
  if (tmp___16) {
    {
#line 2008
    printf((char const   */* __restrict  */)"  port_id=%s\n", value);
    }
  }
  {
#line 2009
  tmp___17 = get_value((char const   *)(buff), "port_state", value, (int )sizeof(value));
  }
#line 2009
  if (tmp___17) {
    {
#line 2010
    printf((char const   */* __restrict  */)"  port_state=%s\n", value);
    }
  }
  {
#line 2011
  tmp___18 = get_value((char const   *)(buff), "roles", value, (int )sizeof(value));
  }
#line 2011
  if (tmp___18) {
    {
#line 2012
    printf((char const   */* __restrict  */)"  roles=%s\n", value);
    }
  }
  {
#line 2013
  print_enclosure_device(devname, (char const   *)(b2), op);
#line 2014
  tmp___19 = get_value((char const   *)(buff), "scsi_target_id", value, (int )sizeof(value));
  }
#line 2014
  if (tmp___19) {
    {
#line 2015
    printf((char const   */* __restrict  */)"  scsi_target_id=%s\n", value);
    }
  }
  {
#line 2016
  tmp___20 = get_value((char const   *)(buff), "supported_classes", value, (int )sizeof(value));
  }
#line 2016
  if (tmp___20) {
    {
#line 2018
    printf((char const   */* __restrict  */)"  supported_classes=%s\n", value);
    }
  }
  {
#line 2019
  tmp___21 = get_value((char const   *)(buff), "fast_io_fail_tmo", value, (int )sizeof(value));
  }
#line 2019
  if (tmp___21) {
    {
#line 2020
    printf((char const   */* __restrict  */)"  fast_io_fail_tmo=%s\n", value);
    }
  }
  {
#line 2021
  tmp___22 = get_value((char const   *)(buff), "dev_loss_tmo", value, (int )sizeof(value));
  }
#line 2021
  if (tmp___22) {
    {
#line 2022
    printf((char const   */* __restrict  */)"  dev_loss_tmo=%s\n", value);
    }
  }
#line 2023
  if (op->verbose > 2) {
    {
#line 2024
    printf((char const   */* __restrict  */)"  fetched from directory: %s\n", buff);
#line 2025
    printf((char const   */* __restrict  */)"  fetched from directory: %s\n", b2);
    }
  }
#line 2027
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 2029
  printf((char const   */* __restrict  */)"  transport=sas\n");
#line 2030
  snprintf((char */* __restrict  */)(buff), sizeof(buff), (char const   */* __restrict  */)"%s%s%s",
           sysfsroot, sas_device, sas_hold_end_device);
#line 2033
  snprintf((char */* __restrict  */)(b2), sizeof(b2), (char const   */* __restrict  */)"%s%s",
           path_name, "/device/");
#line 2034
  tmp___23 = get_value((char const   *)(b2), "vendor", value, (int )sizeof(value));
  }
#line 2034
  if (tmp___23) {
    {
#line 2035
    printf((char const   */* __restrict  */)"  vendor=%s\n", value);
    }
  }
  {
#line 2036
  tmp___24 = get_value((char const   *)(b2), "model", value, (int )sizeof(value));
  }
#line 2036
  if (tmp___24) {
    {
#line 2037
    printf((char const   */* __restrict  */)"  model=%s\n", value);
    }
  }
  {
#line 2039
  snprintf((char */* __restrict  */)(b2), sizeof(b2), (char const   */* __restrict  */)"%s%s%s",
           sysfsroot, sas_end_device, sas_hold_end_device);
#line 2041
  tmp___25 = get_value((char const   *)(buff), "bay_identifier", value, (int )sizeof(value));
  }
#line 2041
  if (tmp___25) {
    {
#line 2042
    printf((char const   */* __restrict  */)"  bay_identifier=%s\n", value);
    }
  }
  {
#line 2043
  print_enclosure_device(devname, (char const   *)(b2), op);
#line 2044
  tmp___26 = get_value((char const   *)(buff), "enclosure_identifier", value, (int )sizeof(value));
  }
#line 2044
  if (tmp___26) {
    {
#line 2046
    printf((char const   */* __restrict  */)"  enclosure_identifier=%s\n", value);
    }
  }
  {
#line 2047
  tmp___27 = get_value((char const   *)(buff), "initiator_port_protocols", value,
                       (int )sizeof(value));
  }
#line 2047
  if (tmp___27) {
    {
#line 2049
    printf((char const   */* __restrict  */)"  initiator_port_protocols=%s\n", value);
    }
  }
  {
#line 2050
  tmp___28 = get_value((char const   *)(b2), "initiator_response_timeout", value,
                       (int )sizeof(value));
  }
#line 2050
  if (tmp___28) {
    {
#line 2052
    printf((char const   */* __restrict  */)"  initiator_response_timeout=%s\n", value);
    }
  }
  {
#line 2053
  tmp___29 = get_value((char const   *)(b2), "I_T_nexus_loss_timeout", value, (int )sizeof(value));
  }
#line 2053
  if (tmp___29) {
    {
#line 2055
    printf((char const   */* __restrict  */)"  I_T_nexus_loss_timeout=%s\n", value);
    }
  }
  {
#line 2056
  tmp___30 = get_value((char const   *)(buff), "phy_identifier", value, (int )sizeof(value));
  }
#line 2056
  if (tmp___30) {
    {
#line 2057
    printf((char const   */* __restrict  */)"  phy_identifier=%s\n", value);
    }
  }
  {
#line 2058
  tmp___31 = get_value((char const   *)(b2), "ready_led_meaning", value, (int )sizeof(value));
  }
#line 2058
  if (tmp___31) {
    {
#line 2059
    printf((char const   */* __restrict  */)"  ready_led_meaning=%s\n", value);
    }
  }
  {
#line 2060
  tmp___32 = get_value((char const   *)(buff), "sas_address", value, (int )sizeof(value));
  }
#line 2060
  if (tmp___32) {
    {
#line 2061
    printf((char const   */* __restrict  */)"  sas_address=%s\n", value);
    }
  }
  {
#line 2062
  tmp___33 = get_value((char const   *)(buff), "target_port_protocols", value, (int )sizeof(value));
  }
#line 2062
  if (tmp___33) {
    {
#line 2064
    printf((char const   */* __restrict  */)"  target_port_protocols=%s\n", value);
    }
  }
  {
#line 2065
  tmp___34 = get_value((char const   *)(b2), "tlr_enabled", value, (int )sizeof(value));
  }
#line 2065
  if (tmp___34) {
    {
#line 2066
    printf((char const   */* __restrict  */)"  tlr_enabled=%s\n", value);
    }
  }
  {
#line 2067
  tmp___35 = get_value((char const   *)(b2), "tlr_supported", value, (int )sizeof(value));
  }
#line 2067
  if (tmp___35) {
    {
#line 2068
    printf((char const   */* __restrict  */)"  tlr_supported=%s\n", value);
    }
  }
#line 2069
  if (op->verbose > 2) {
    {
#line 2070
    printf((char const   */* __restrict  */)"fetched from directory: %s\n", buff);
#line 2071
    printf((char const   */* __restrict  */)"fetched from directory: %s\n", b2);
    }
  }
#line 2073
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 2075
  printf((char const   */* __restrict  */)"  transport=sas\n");
#line 2076
  printf((char const   */* __restrict  */)"  sub_transport=sas_class\n");
#line 2077
  snprintf((char */* __restrict  */)(buff), sizeof(buff), (char const   */* __restrict  */)"%s%s",
           path_name, "/device/sas_device");
#line 2079
  tmp___36 = get_value((char const   *)(buff), "device_name", value, (int )sizeof(value));
  }
#line 2079
  if (tmp___36) {
    {
#line 2080
    printf((char const   */* __restrict  */)"  device_name=%s\n", value);
    }
  }
  {
#line 2081
  tmp___37 = get_value((char const   *)(buff), "dev_type", value, (int )sizeof(value));
  }
#line 2081
  if (tmp___37) {
    {
#line 2082
    printf((char const   */* __restrict  */)"  dev_type=%s\n", value);
    }
  }
  {
#line 2083
  tmp___38 = get_value((char const   *)(buff), "iproto", value, (int )sizeof(value));
  }
#line 2083
  if (tmp___38) {
    {
#line 2084
    printf((char const   */* __restrict  */)"  iproto=%s\n", value);
    }
  }
  {
#line 2085
  tmp___39 = get_value((char const   *)(buff), "iresp_timeout", value, (int )sizeof(value));
  }
#line 2085
  if (tmp___39) {
    {
#line 2086
    printf((char const   */* __restrict  */)"  iresp_timeout=%s\n", value);
    }
  }
  {
#line 2087
  tmp___40 = get_value((char const   *)(buff), "itnl_timeout", value, (int )sizeof(value));
  }
#line 2087
  if (tmp___40) {
    {
#line 2088
    printf((char const   */* __restrict  */)"  itnl_timeout=%s\n", value);
    }
  }
  {
#line 2089
  tmp___41 = get_value((char const   *)(buff), "linkrate", value, (int )sizeof(value));
  }
#line 2089
  if (tmp___41) {
    {
#line 2090
    printf((char const   */* __restrict  */)"  linkrate=%s\n", value);
    }
  }
  {
#line 2091
  tmp___42 = get_value((char const   *)(buff), "max_linkrate", value, (int )sizeof(value));
  }
#line 2091
  if (tmp___42) {
    {
#line 2092
    printf((char const   */* __restrict  */)"  max_linkrate=%s\n", value);
    }
  }
  {
#line 2093
  tmp___43 = get_value((char const   *)(buff), "max_pathways", value, (int )sizeof(value));
  }
#line 2093
  if (tmp___43) {
    {
#line 2094
    printf((char const   */* __restrict  */)"  max_pathways=%s\n", value);
    }
  }
  {
#line 2095
  tmp___44 = get_value((char const   *)(buff), "min_linkrate", value, (int )sizeof(value));
  }
#line 2095
  if (tmp___44) {
    {
#line 2096
    printf((char const   */* __restrict  */)"  min_linkrate=%s\n", value);
    }
  }
  {
#line 2097
  tmp___45 = get_value((char const   *)(buff), "pathways", value, (int )sizeof(value));
  }
#line 2097
  if (tmp___45) {
    {
#line 2098
    printf((char const   */* __restrict  */)"  pathways=%s\n", value);
    }
  }
  {
#line 2099
  tmp___46 = get_value((char const   *)(buff), "ready_led_meaning", value, (int )sizeof(value));
  }
#line 2099
  if (tmp___46) {
    {
#line 2101
    printf((char const   */* __restrict  */)"  ready_led_meaning=%s\n", value);
    }
  }
  {
#line 2102
  tmp___47 = get_value((char const   *)(buff), "rl_wlun", value, (int )sizeof(value));
  }
#line 2102
  if (tmp___47) {
    {
#line 2103
    printf((char const   */* __restrict  */)"  rl_wlun=%s\n", value);
    }
  }
  {
#line 2104
  tmp___48 = get_value((char const   *)(buff), "sas_addr", value, (int )sizeof(value));
  }
#line 2104
  if (tmp___48) {
    {
#line 2105
    printf((char const   */* __restrict  */)"  sas_addr=%s\n", value);
    }
  }
  {
#line 2106
  tmp___49 = get_value((char const   *)(buff), "tproto", value, (int )sizeof(value));
  }
#line 2106
  if (tmp___49) {
    {
#line 2107
    printf((char const   */* __restrict  */)"  tproto=%s\n", value);
    }
  }
  {
#line 2108
  tmp___50 = get_value((char const   *)(buff), "transport_layer_retries", value, (int )sizeof(value));
  }
#line 2108
  if (tmp___50) {
    {
#line 2110
    printf((char const   */* __restrict  */)"  transport_layer_retries=%s\n", value);
    }
  }
#line 2111
  if (op->verbose > 2) {
    {
#line 2112
    printf((char const   */* __restrict  */)"fetched from directory: %s\n", buff);
    }
  }
#line 2113
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 2115
  printf((char const   */* __restrict  */)"  transport=iSCSI\n");
#line 2116
  snprintf((char */* __restrict  */)(buff), sizeof(buff), (char const   */* __restrict  */)"%s%ssession%d",
           sysfsroot, iscsi_session, iscsi_tsession_num);
#line 2118
  tmp___51 = get_value((char const   *)(buff), "targetname", value, (int )sizeof(value));
  }
#line 2118
  if (tmp___51) {
    {
#line 2119
    printf((char const   */* __restrict  */)"  targetname=%s\n", value);
    }
  }
  {
#line 2120
  tmp___52 = get_value((char const   *)(buff), "tpgt", value, (int )sizeof(value));
  }
#line 2120
  if (tmp___52) {
    {
#line 2121
    printf((char const   */* __restrict  */)"  tpgt=%s\n", value);
    }
  }
  {
#line 2122
  tmp___53 = get_value((char const   *)(buff), "data_pdu_in_order", value, (int )sizeof(value));
  }
#line 2122
  if (tmp___53) {
    {
#line 2124
    printf((char const   */* __restrict  */)"  data_pdu_in_order=%s\n", value);
    }
  }
  {
#line 2125
  tmp___54 = get_value((char const   *)(buff), "data_seq_in_order", value, (int )sizeof(value));
  }
#line 2125
  if (tmp___54) {
    {
#line 2127
    printf((char const   */* __restrict  */)"  data_seq_in_order=%s\n", value);
    }
  }
  {
#line 2128
  tmp___55 = get_value((char const   *)(buff), "erl", value, (int )sizeof(value));
  }
#line 2128
  if (tmp___55) {
    {
#line 2129
    printf((char const   */* __restrict  */)"  erl=%s\n", value);
    }
  }
  {
#line 2130
  tmp___56 = get_value((char const   *)(buff), "first_burst_len", value, (int )sizeof(value));
  }
#line 2130
  if (tmp___56) {
    {
#line 2131
    printf((char const   */* __restrict  */)"  first_burst_len=%s\n", value);
    }
  }
  {
#line 2132
  tmp___57 = get_value((char const   *)(buff), "initial_r2t", value, (int )sizeof(value));
  }
#line 2132
  if (tmp___57) {
    {
#line 2133
    printf((char const   */* __restrict  */)"  initial_r2t=%s\n", value);
    }
  }
  {
#line 2134
  tmp___58 = get_value((char const   *)(buff), "max_burst_len", value, (int )sizeof(value));
  }
#line 2134
  if (tmp___58) {
    {
#line 2135
    printf((char const   */* __restrict  */)"  max_burst_len=%s\n", value);
    }
  }
  {
#line 2136
  tmp___59 = get_value((char const   *)(buff), "max_outstanding_r2t", value, (int )sizeof(value));
  }
#line 2136
  if (tmp___59) {
    {
#line 2138
    printf((char const   */* __restrict  */)"  max_outstanding_r2t=%s\n", value);
    }
  }
  {
#line 2139
  tmp___60 = get_value((char const   *)(buff), "recovery_tmo", value, (int )sizeof(value));
  }
#line 2139
  if (tmp___60) {
    {
#line 2140
    printf((char const   */* __restrict  */)"  recovery_tmo=%s\n", value);
    }
  }
#line 2145
  if (op->verbose > 2) {
    {
#line 2146
    printf((char const   */* __restrict  */)"fetched from directory: %s\n", buff);
    }
  }
#line 2147
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 2149
  printf((char const   */* __restrict  */)"  transport=sbp\n");
#line 2150
  tmp___61 = if_directory_chdir((char const   *)(path_name), "device");
  }
#line 2150
  if (! tmp___61) {
#line 2151
    return;
  }
  {
#line 2152
  tmp___62 = getcwd(wd, sizeof(wd));
  }
#line 2152
  if ((unsigned long )((void *)0) == (unsigned long )tmp___62) {
#line 2153
    return;
  }
  {
#line 2154
  tmp___63 = get_value((char const   *)(wd), "ieee1394_id", value, (int )sizeof(value));
  }
#line 2154
  if (tmp___63) {
    {
#line 2155
    printf((char const   */* __restrict  */)"  ieee1394_id=%s\n", value);
    }
  }
#line 2156
  if (op->verbose > 2) {
    {
#line 2157
    printf((char const   */* __restrict  */)"fetched from directory: %s\n", buff);
    }
  }
#line 2158
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 2160
  printf((char const   */* __restrict  */)"  transport=usb\n");
#line 2161
  tmp___64 = get_usb_devname((char const   *)((void *)0), devname, value, (int )sizeof(value));
#line 2161
  printf((char const   */* __restrict  */)"  device_name=%s\n", tmp___64);
  }
#line 2163
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 2165
  printf((char const   */* __restrict  */)"  transport=ata\n");
  }
#line 2166
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 2168
  printf((char const   */* __restrict  */)"  transport=sata\n");
  }
#line 2169
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 2171
  if (op->verbose > 1) {
    {
#line 2172
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"No transport information\n");
    }
  }
#line 2173
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2175
  return;
}
}
#line 2177 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static void longer_d_entry(char const   *path_name , char const   *devname , struct lsscsi_opt_coll  const  *op ) 
{ 
  char value[256] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;

  {
#line 2183
  if (op->transport > 0) {
    {
#line 2184
    transport_tport_longer(devname, op);
    }
#line 2185
    return;
  }
#line 2187
  if (op->long_opt >= 3) {
    {
#line 2188
    tmp = get_value(path_name, "device_blocked", value, (int )sizeof(value));
    }
#line 2188
    if (tmp) {
      {
#line 2190
      printf((char const   */* __restrict  */)"  device_blocked=%s\n", value);
      }
    } else
#line 2191
    if (op->verbose > 0) {
      {
#line 2192
      printf((char const   */* __restrict  */)"  device_blocked=?\n");
      }
    }
    {
#line 2193
    tmp___0 = get_value(path_name, "iocounterbits", value, (int )sizeof(value));
    }
#line 2193
    if (tmp___0) {
      {
#line 2195
      printf((char const   */* __restrict  */)"  iocounterbits=%s\n", value);
      }
    } else
#line 2196
    if (op->verbose > 0) {
      {
#line 2197
      printf((char const   */* __restrict  */)"  iocounterbits=?\n");
      }
    }
    {
#line 2198
    tmp___1 = get_value(path_name, "iodone_cnt", value, (int )sizeof(value));
    }
#line 2198
    if (tmp___1) {
      {
#line 2199
      printf((char const   */* __restrict  */)"  iodone_cnt=%s\n", value);
      }
    } else
#line 2200
    if (op->verbose > 0) {
      {
#line 2201
      printf((char const   */* __restrict  */)"  iodone_cnt=?\n");
      }
    }
    {
#line 2202
    tmp___2 = get_value(path_name, "ioerr_cnt", value, (int )sizeof(value));
    }
#line 2202
    if (tmp___2) {
      {
#line 2203
      printf((char const   */* __restrict  */)"  ioerr_cnt=%s\n", value);
      }
    } else
#line 2204
    if (op->verbose > 0) {
      {
#line 2205
      printf((char const   */* __restrict  */)"  ioerr_cnt=?\n");
      }
    }
    {
#line 2206
    tmp___3 = get_value(path_name, "iorequest_cnt", value, (int )sizeof(value));
    }
#line 2206
    if (tmp___3) {
      {
#line 2208
      printf((char const   */* __restrict  */)"  iorequest_cnt=%s\n", value);
      }
    } else
#line 2209
    if (op->verbose > 0) {
      {
#line 2210
      printf((char const   */* __restrict  */)"  iorequest_cnt=?\n");
      }
    }
    {
#line 2211
    tmp___4 = get_value(path_name, "queue_depth", value, (int )sizeof(value));
    }
#line 2211
    if (tmp___4) {
      {
#line 2213
      printf((char const   */* __restrict  */)"  queue_depth=%s\n", value);
      }
    } else
#line 2214
    if (op->verbose > 0) {
      {
#line 2215
      printf((char const   */* __restrict  */)"  queue_depth=?\n");
      }
    }
    {
#line 2216
    tmp___5 = get_value(path_name, "queue_type", value, (int )sizeof(value));
    }
#line 2216
    if (tmp___5) {
      {
#line 2218
      printf((char const   */* __restrict  */)"  queue_type=%s\n", value);
      }
    } else
#line 2219
    if (op->verbose > 0) {
      {
#line 2220
      printf((char const   */* __restrict  */)"  queue_type=?\n");
      }
    }
    {
#line 2221
    tmp___6 = get_value(path_name, "scsi_level", value, (int )sizeof(value));
    }
#line 2221
    if (tmp___6) {
      {
#line 2223
      printf((char const   */* __restrict  */)"  scsi_level=%s\n", value);
      }
    } else
#line 2224
    if (op->verbose > 0) {
      {
#line 2225
      printf((char const   */* __restrict  */)"  scsi_level=?\n");
      }
    }
    {
#line 2226
    tmp___7 = get_value(path_name, "state", value, (int )sizeof(value));
    }
#line 2226
    if (tmp___7) {
      {
#line 2228
      printf((char const   */* __restrict  */)"  state=%s\n", value);
      }
    } else
#line 2229
    if (op->verbose > 0) {
      {
#line 2230
      printf((char const   */* __restrict  */)"  state=?\n");
      }
    }
    {
#line 2231
    tmp___8 = get_value(path_name, "timeout", value, (int )sizeof(value));
    }
#line 2231
    if (tmp___8) {
      {
#line 2233
      printf((char const   */* __restrict  */)"  timeout=%s\n", value);
      }
    } else
#line 2234
    if (op->verbose > 0) {
      {
#line 2235
      printf((char const   */* __restrict  */)"  timeout=?\n");
      }
    }
    {
#line 2236
    tmp___9 = get_value(path_name, "type", value, (int )sizeof(value));
    }
#line 2236
    if (tmp___9) {
      {
#line 2238
      printf((char const   */* __restrict  */)"  type=%s\n", value);
      }
    } else
#line 2239
    if (op->verbose > 0) {
      {
#line 2240
      printf((char const   */* __restrict  */)"  type=?\n");
      }
    }
#line 2241
    return;
  }
  {
#line 2244
  tmp___10 = get_value(path_name, "state", value, (int )sizeof(value));
  }
#line 2244
  if (tmp___10) {
    {
#line 2245
    printf((char const   */* __restrict  */)"  state=%s", value);
    }
  } else {
    {
#line 2247
    printf((char const   */* __restrict  */)"  state=?");
    }
  }
  {
#line 2248
  tmp___11 = get_value(path_name, "queue_depth", value, (int )sizeof(value));
  }
#line 2248
  if (tmp___11) {
    {
#line 2249
    printf((char const   */* __restrict  */)" queue_depth=%s", value);
    }
  } else {
    {
#line 2251
    printf((char const   */* __restrict  */)" queue_depth=?");
    }
  }
  {
#line 2252
  tmp___12 = get_value(path_name, "scsi_level", value, (int )sizeof(value));
  }
#line 2252
  if (tmp___12) {
    {
#line 2253
    printf((char const   */* __restrict  */)" scsi_level=%s", value);
    }
  } else {
    {
#line 2255
    printf((char const   */* __restrict  */)" scsi_level=?");
    }
  }
  {
#line 2256
  tmp___13 = get_value(path_name, "type", value, (int )sizeof(value));
  }
#line 2256
  if (tmp___13) {
    {
#line 2257
    printf((char const   */* __restrict  */)" type=%s", value);
    }
  } else {
    {
#line 2259
    printf((char const   */* __restrict  */)" type=?");
    }
  }
  {
#line 2260
  tmp___14 = get_value(path_name, "device_blocked", value, (int )sizeof(value));
  }
#line 2260
  if (tmp___14) {
    {
#line 2261
    printf((char const   */* __restrict  */)" device_blocked=%s", value);
    }
  } else {
    {
#line 2263
    printf((char const   */* __restrict  */)" device_blocked=?");
    }
  }
  {
#line 2264
  tmp___15 = get_value(path_name, "timeout", value, (int )sizeof(value));
  }
#line 2264
  if (tmp___15) {
    {
#line 2265
    printf((char const   */* __restrict  */)" timeout=%s", value);
    }
  } else {
    {
#line 2267
    printf((char const   */* __restrict  */)" timeout=?");
    }
  }
  {
#line 2268
  printf((char const   */* __restrict  */)"\n");
  }
#line 2269
  if (op->long_opt == 2) {
    {
#line 2270
    tmp___16 = get_value(path_name, "iocounterbits", value, (int )sizeof(value));
    }
#line 2270
    if (tmp___16) {
      {
#line 2272
      printf((char const   */* __restrict  */)"  iocounterbits=%s", value);
      }
    } else {
      {
#line 2274
      printf((char const   */* __restrict  */)"  iocounterbits=?");
      }
    }
    {
#line 2275
    tmp___17 = get_value(path_name, "iodone_cnt", value, (int )sizeof(value));
    }
#line 2275
    if (tmp___17) {
      {
#line 2277
      printf((char const   */* __restrict  */)" iodone_cnt=%s", value);
      }
    } else {
      {
#line 2279
      printf((char const   */* __restrict  */)" iodone_cnt=?");
      }
    }
    {
#line 2280
    tmp___18 = get_value(path_name, "ioerr_cnt", value, (int )sizeof(value));
    }
#line 2280
    if (tmp___18) {
      {
#line 2282
      printf((char const   */* __restrict  */)" ioerr_cnt=%s", value);
      }
    } else {
      {
#line 2284
      printf((char const   */* __restrict  */)" ioerr_cnt=?");
      }
    }
    {
#line 2285
    tmp___19 = get_value(path_name, "iorequest_cnt", value, (int )sizeof(value));
    }
#line 2285
    if (tmp___19) {
      {
#line 2287
      printf((char const   */* __restrict  */)" iorequest_cnt=%s", value);
      }
    } else {
      {
#line 2289
      printf((char const   */* __restrict  */)" iorequest_cnt=?");
      }
    }
    {
#line 2290
    printf((char const   */* __restrict  */)"\n");
#line 2291
    tmp___20 = get_value(path_name, "queue_type", value, (int )sizeof(value));
    }
#line 2291
    if (tmp___20) {
      {
#line 2293
      printf((char const   */* __restrict  */)"  queue_type=%s", value);
      }
    } else {
      {
#line 2295
      printf((char const   */* __restrict  */)"  queue_type=?");
      }
    }
    {
#line 2296
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 2298
  return;
}
}
#line 2300 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static void one_classic_sdev_entry(char const   *dir_name , char const   *devname ,
                                   struct lsscsi_opt_coll  const  *op ) 
{ 
  struct addr_hctl hctl ;
  char buff[384] ;
  char wd[4096] ;
  char dev_node[256] ;
  char value[256] ;
  int type ;
  int scsi_level ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;

  {
  {
#line 2311
  snprintf((char */* __restrict  */)(buff), sizeof(buff), (char const   */* __restrict  */)"%s/%s",
           dir_name, devname);
#line 2312
  tmp = parse_colon_list(devname, & hctl);
  }
#line 2312
  if (! tmp) {
    {
#line 2313
    invalidate_hctl(& hctl);
    }
  }
  {
#line 2314
  printf((char const   */* __restrict  */)"Host: scsi%d Channel: %02d Target: %02d Lun: %02lu\n",
         hctl.h, hctl.c, hctl.t, hctl.l);
#line 2317
  tmp___0 = get_value((char const   *)(buff), "vendor", value, (int )sizeof(value));
  }
#line 2317
  if (tmp___0) {
    {
#line 2318
    printf((char const   */* __restrict  */)"  Vendor: %-8s", value);
    }
  } else {
    {
#line 2320
    printf((char const   */* __restrict  */)"  Vendor: ?       ");
    }
  }
  {
#line 2321
  tmp___1 = get_value((char const   *)(buff), "model", value, (int )sizeof(value));
  }
#line 2321
  if (tmp___1) {
    {
#line 2322
    printf((char const   */* __restrict  */)" Model: %-16s", value);
    }
  } else {
    {
#line 2324
    printf((char const   */* __restrict  */)" Model: ?               ");
    }
  }
  {
#line 2325
  tmp___2 = get_value((char const   *)(buff), "rev", value, (int )sizeof(value));
  }
#line 2325
  if (tmp___2) {
    {
#line 2326
    printf((char const   */* __restrict  */)" Rev: %-4s", value);
    }
  } else {
    {
#line 2328
    printf((char const   */* __restrict  */)" Rev: ?   ");
    }
  }
  {
#line 2329
  printf((char const   */* __restrict  */)"\n");
#line 2330
  tmp___4 = get_value((char const   *)(buff), "type", value, (int )sizeof(value));
  }
#line 2330
  if (tmp___4) {
    {
#line 2332
    tmp___3 = sscanf((char const   */* __restrict  */)(value), (char const   */* __restrict  */)"%d",
                     & type);
    }
#line 2332
    if (1 != tmp___3) {
      {
#line 2333
      printf((char const   */* __restrict  */)"  Type:   %-33s", "??");
      }
    } else
#line 2334
    if (type < 0) {
      {
#line 2335
      printf((char const   */* __restrict  */)"  Type:   %-33s", "???");
      }
    } else
#line 2334
    if (type > 31) {
      {
#line 2335
      printf((char const   */* __restrict  */)"  Type:   %-33s", "???");
      }
    } else {
      {
#line 2337
      printf((char const   */* __restrict  */)"  Type:   %-33s", scsi_device_types[type]);
      }
    }
  } else {
    {
#line 2331
    printf((char const   */* __restrict  */)"  Type:   %-33s", "?");
    }
  }
  {
#line 2338
  tmp___7 = get_value((char const   *)(buff), "scsi_level", value, (int )sizeof(value));
  }
#line 2338
  if (tmp___7) {
    {
#line 2340
    tmp___6 = sscanf((char const   */* __restrict  */)(value), (char const   */* __restrict  */)"%d",
                     & scsi_level);
    }
#line 2340
    if (1 != tmp___6) {
      {
#line 2341
      printf((char const   */* __restrict  */)"ANSI SCSI revision: ??\n");
      }
    } else {
#line 2343
      if (scsi_level - 1) {
#line 2343
        tmp___5 = scsi_level - 1;
      } else {
#line 2343
        tmp___5 = 1;
      }
      {
#line 2343
      printf((char const   */* __restrict  */)"ANSI SCSI revision: %02x\n", tmp___5);
      }
    }
  } else {
    {
#line 2339
    printf((char const   */* __restrict  */)"ANSI SCSI revision: ?\n");
    }
  }
#line 2345
  if (op->generic) {
    {
#line 2346
    tmp___11 = if_directory_ch2generic((char const   *)(buff));
    }
#line 2346
    if (tmp___11) {
      {
#line 2347
      tmp___10 = getcwd(wd, sizeof(wd));
      }
#line 2347
      if ((unsigned long )((void *)0) == (unsigned long )tmp___10) {
        {
#line 2348
        printf((char const   */* __restrict  */)"generic_dev error\n");
        }
      } else {
#line 2350
        if (op->kname) {
          {
#line 2351
          tmp___8 = __xpg_basename(wd);
#line 2351
          snprintf((char */* __restrict  */)(dev_node), sizeof(dev_node), (char const   */* __restrict  */)"%s/%s",
                   dev_dir, tmp___8);
          }
        } else {
          {
#line 2354
          tmp___9 = get_dev_node((char const   *)(wd), dev_node, (enum dev_type )1);
          }
#line 2354
          if (! tmp___9) {
            {
#line 2356
            snprintf((char */* __restrict  */)(dev_node), sizeof(dev_node), (char const   */* __restrict  */)"-");
            }
          }
        }
        {
#line 2358
        printf((char const   */* __restrict  */)"%s\n", dev_node);
        }
      }
    } else {
      {
#line 2362
      printf((char const   */* __restrict  */)"-\n");
      }
    }
  }
#line 2364
  if (op->long_opt > 0) {
    {
#line 2365
    longer_d_entry((char const   *)(buff), devname, op);
    }
  }
#line 2366
  if (op->verbose) {
    {
#line 2367
    printf((char const   */* __restrict  */)"  dir: %s\n", buff);
    }
  }
#line 2368
  return;
}
}
#line 2370 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static void tag_lun_helper(int *tag_arr , int kk , int num ) 
{ 
  int j ;

  {
#line 2375
  j = 0;
  {
#line 2375
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2375
    if (! (j < num)) {
#line 2375
      goto while_break;
    }
#line 2376
    if (kk > 0) {
#line 2376
      if (0 == j) {
#line 2376
        *(tag_arr + (2 * kk + j)) = 2;
      } else {
#line 2376
        *(tag_arr + (2 * kk + j)) = 1;
      }
    } else {
#line 2376
      *(tag_arr + (2 * kk + j)) = 1;
    }
#line 2375
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2377
  return;
}
}
#line 2384 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static void tag_lun(unsigned char const   *lunp , int *tag_arr ) 
{ 
  int k ;
  int a_method ;
  int bus_id ;
  int len_fld ;
  int e_a_method ;
  int next_level ;
  unsigned char not_spec[2] ;
  int tmp ;

  {
#line 2388
  not_spec[0] = (unsigned char)255;
#line 2388
  not_spec[1] = (unsigned char)255;
#line 2390
  if ((unsigned long )((void *)0) == (unsigned long )tag_arr) {
#line 2391
    return;
  }
#line 2392
  k = 0;
  {
#line 2392
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2392
    if (! (k < 8)) {
#line 2392
      goto while_break;
    }
#line 2393
    *(tag_arr + k) = 0;
#line 2392
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2394
  if ((unsigned long )((void *)0) == (unsigned long )lunp) {
#line 2395
    return;
  }
  {
#line 2396
  tmp = memcmp((void const   *)lunp, (void const   *)(not_spec), sizeof(not_spec));
  }
#line 2396
  if (0 == tmp) {
#line 2397
    k = 0;
    {
#line 2397
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2397
      if (! (k < 2)) {
#line 2397
        goto while_break___0;
      }
#line 2398
      *(tag_arr + k) = 1;
#line 2397
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2399
    return;
  }
#line 2401
  k = 0;
  {
#line 2401
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2401
    if (! (k < 4)) {
#line 2401
      goto while_break___1;
    }
#line 2402
    next_level = 0;
#line 2403
    a_method = (int )(((int const   )*(lunp + 0) >> 6) & 3);
    {
#line 2405
    if (a_method == 0) {
#line 2405
      goto case_0;
    }
#line 2411
    if (a_method == 1) {
#line 2411
      goto case_1;
    }
#line 2414
    if (a_method == 2) {
#line 2414
      goto case_2;
    }
#line 2417
    if (a_method == 3) {
#line 2417
      goto case_3;
    }
#line 2440
    goto switch_default;
    case_0: /* CIL Label */ 
#line 2406
    bus_id = (int )((int const   )*(lunp + 0) & 63);
#line 2407
    if (bus_id) {
#line 2408
      next_level = 1;
    }
    {
#line 2409
    tag_lun_helper(tag_arr, k, 2);
    }
#line 2410
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 2412
    tag_lun_helper(tag_arr, k, 2);
    }
#line 2413
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 2415
    tag_lun_helper(tag_arr, k, 2);
    }
#line 2416
    goto switch_break;
    case_3: /* CIL Label */ 
#line 2418
    len_fld = (int )(((int const   )*(lunp + 0) & 48) >> 4);
#line 2419
    e_a_method = (int )((int const   )*(lunp + 0) & 15);
#line 2420
    if (0 == len_fld) {
#line 2420
      if (1 == e_a_method) {
        {
#line 2421
        tag_lun_helper(tag_arr, k, 2);
        }
      } else {
#line 2420
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 2422
    if (1 == len_fld) {
#line 2422
      if (2 == e_a_method) {
        {
#line 2423
        tag_lun_helper(tag_arr, k, 4);
        }
      } else {
#line 2422
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 2424
    if (2 == len_fld) {
#line 2424
      if (2 == e_a_method) {
        {
#line 2425
        tag_lun_helper(tag_arr, k, 6);
        }
      } else {
#line 2424
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 2426
    if (3 == len_fld) {
#line 2426
      if (15 == e_a_method) {
#line 2427
        if (k > 0) {
#line 2427
          *(tag_arr + 2 * k) = 2;
        } else {
#line 2427
          *(tag_arr + 2 * k) = 1;
        }
      } else {
#line 2426
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 2429
    if (len_fld < 2) {
      {
#line 2430
      tag_lun_helper(tag_arr, k, 4);
      }
    } else {
      {
#line 2432
      tag_lun_helper(tag_arr, k, 6);
      }
#line 2433
      if (3 == len_fld) {
#line 2434
        *(tag_arr + (2 * k + 6)) = 1;
#line 2435
        *(tag_arr + (2 * k + 7)) = 1;
      }
    }
#line 2439
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 2441
    tag_lun_helper(tag_arr, k, 2);
    }
#line 2442
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 2444
    if (! next_level) {
#line 2445
      goto while_break___1;
    }
#line 2401
    k ++;
#line 2401
    lunp += 2;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2447
  return;
}
}
#line 2449 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static uint64_t lun_word_flip(uint64_t in ) 
{ 
  uint64_t res ;
  int k ;

  {
#line 2452
  res = (uint64_t )0;
#line 2455
  k = 0;
  {
#line 2455
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2456
    res |= in & 65535UL;
#line 2457
    if (k > 2) {
#line 2458
      goto while_break;
    }
#line 2459
    res <<= 16;
#line 2460
    in >>= 16;
#line 2455
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2462
  return (res);
}
}
#line 2466 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static void one_sdev_entry(char const   *dir_name , char const   *devname , struct lsscsi_opt_coll  const  *op ) 
{ 
  char buff[384] ;
  char wd[4096] ;
  char extra[384] ;
  char value[256] ;
  int type ;
  int k ;
  int n ;
  int len ;
  int ta ;
  int devname_len ;
  int get_wwn ;
  struct addr_hctl hctl ;
  int tag_arr[16] ;
  size_t tmp ;
  char const   *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  uint64_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  char dev_node[256] ;
  unsigned int tmp___14 ;
  char wwn_str[34] ;
  enum dev_type typ ;
  int tmp___15 ;
  char *tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  char *scsi_id ;
  char const   *tmp___19 ;
  int tmp___20 ;
  char dev_node___0[256] ;
  unsigned int tmp___21 ;
  char *tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  char *tmp___25 ;
  int tmp___26 ;
  char sddir[384] ;
  char blkdir[384] ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  char sddir___0[384] ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  char blkdir___0[384] ;
  uint64_t blocks ;
  long long tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  char *tmp___43 ;
  int tmp___44 ;

  {
#line 2475
  devname_len = 13;
#line 2476
  get_wwn = 0;
#line 2480
  if (op->classic) {
    {
#line 2481
    one_classic_sdev_entry(dir_name, devname, op);
    }
#line 2482
    return;
  }
  {
#line 2484
  len = (int )sizeof(value);
#line 2485
  snprintf((char */* __restrict  */)(buff), sizeof(buff), (char const   */* __restrict  */)"%s/%s",
           dir_name, devname);
  }
#line 2486
  if (op->lunhex) {
    {
#line 2486
    tmp___4 = parse_colon_list(devname, & hctl);
    }
#line 2486
    if (tmp___4) {
      {
#line 2487
      snprintf((char */* __restrict  */)(value), (size_t )len, (char const   */* __restrict  */)"[%d:%d:%d:0x",
               hctl.h, hctl.c, hctl.t);
      }
#line 2489
      if (1 == (int )op->lunhex) {
        {
#line 2490
        tag_lun((unsigned char const   *)(hctl.lun_arr), tag_arr);
#line 2491
        k = 0;
        }
        {
#line 2491
        while (1) {
          while_continue: /* CIL Label */ ;
#line 2491
          if (! (k < 8)) {
#line 2491
            goto while_break;
          }
#line 2492
          ta = tag_arr[k];
#line 2493
          if (ta <= 0) {
#line 2494
            goto while_break;
          }
          {
#line 2495
          tmp = strlen((char const   *)(value));
#line 2495
          n = (int )tmp;
          }
#line 2496
          if (ta > 1) {
#line 2496
            tmp___0 = "_";
          } else {
#line 2496
            tmp___0 = "";
          }
          {
#line 2496
          snprintf((char */* __restrict  */)(value + n), (size_t )(len - n), (char const   */* __restrict  */)"%s%02x",
                   tmp___0, (int )hctl.lun_arr[k]);
#line 2491
          k ++;
          }
        }
        while_break: /* CIL Label */ ;
        }
        {
#line 2500
        tmp___1 = strlen((char const   *)(value));
#line 2500
        n = (int )tmp___1;
#line 2501
        snprintf((char */* __restrict  */)(value + n), (size_t )(len - n), (char const   */* __restrict  */)"]");
        }
      } else {
        {
#line 2503
        tmp___2 = strlen((char const   *)(value));
#line 2503
        n = (int )tmp___2;
#line 2504
        tmp___3 = lun_word_flip(hctl.l);
#line 2504
        snprintf((char */* __restrict  */)(value + n), (size_t )(len - n), (char const   */* __restrict  */)"%016lx]",
                 tmp___3);
        }
      }
#line 2507
      devname_len = 28;
    } else {
      {
#line 2509
      snprintf((char */* __restrict  */)(value), sizeof(value), (char const   */* __restrict  */)"[%s]",
               devname);
      }
    }
  } else {
    {
#line 2509
    snprintf((char */* __restrict  */)(value), sizeof(value), (char const   */* __restrict  */)"[%s]",
             devname);
    }
  }
  {
#line 2511
  printf((char const   */* __restrict  */)"%-*s", devname_len, value);
#line 2512
  tmp___6 = get_value((char const   *)(buff), "type", value, (int )sizeof(value));
  }
#line 2512
  if (tmp___6) {
    {
#line 2514
    tmp___5 = sscanf((char const   */* __restrict  */)(value), (char const   */* __restrict  */)"%d",
                     & type);
    }
#line 2514
    if (1 != tmp___5) {
      {
#line 2515
      printf((char const   */* __restrict  */)"type??  ");
      }
    } else
#line 2516
    if (type < 0) {
      {
#line 2517
      printf((char const   */* __restrict  */)"type??? ");
      }
    } else
#line 2516
    if (type > 31) {
      {
#line 2517
      printf((char const   */* __restrict  */)"type??? ");
      }
    } else {
      {
#line 2519
      printf((char const   */* __restrict  */)"%s ", scsi_short_device_types[type]);
      }
    }
  } else {
    {
#line 2513
    printf((char const   */* __restrict  */)"type?   ");
    }
  }
#line 2521
  if (op->wwn) {
#line 2522
    get_wwn ++;
  } else
#line 2523
  if (0 == (int )op->transport) {
    {
#line 2524
    tmp___7 = get_value((char const   *)(buff), "vendor", value, (int )sizeof(value));
    }
#line 2524
    if (tmp___7) {
      {
#line 2525
      printf((char const   */* __restrict  */)"%-8s ", value);
      }
    } else {
      {
#line 2527
      printf((char const   */* __restrict  */)"vendor?  ");
      }
    }
    {
#line 2529
    tmp___8 = get_value((char const   *)(buff), "model", value, (int )sizeof(value));
    }
#line 2529
    if (tmp___8) {
      {
#line 2530
      printf((char const   */* __restrict  */)"%-16s ", value);
      }
    } else {
      {
#line 2532
      printf((char const   */* __restrict  */)"model?           ");
      }
    }
    {
#line 2534
    tmp___9 = get_value((char const   *)(buff), "rev", value, (int )sizeof(value));
    }
#line 2534
    if (tmp___9) {
      {
#line 2535
      printf((char const   */* __restrict  */)"%-4s  ", value);
      }
    } else {
      {
#line 2537
      printf((char const   */* __restrict  */)"rev?  ");
      }
    }
  } else {
    {
#line 2539
    tmp___10 = transport_tport(devname, (int )sizeof(value), value);
    }
#line 2539
    if (tmp___10) {
      {
#line 2541
      printf((char const   */* __restrict  */)"%-30s  ", value);
      }
    } else {
      {
#line 2543
      printf((char const   */* __restrict  */)"                                ");
      }
    }
  }
  {
#line 2546
  tmp___20 = non_sg_scan((char const   *)(buff), op);
  }
#line 2546
  if (1 == tmp___20) {
#line 2547
    if (4 == non_sg.d_type) {
      {
#line 2548
      snprintf((char */* __restrict  */)(wd), sizeof(wd), (char const   */* __restrict  */)"%s/%s",
               buff, non_sg.name);
#line 2549
      tmp___11 = scan_for_first((char const   *)(wd), op);
      }
#line 2549
      if (1 == tmp___11) {
        {
#line 2550
        my_strcopy(extra, (char const   *)(aa_first.name), (int )sizeof(extra));
        }
      } else {
        {
#line 2553
        printf((char const   */* __restrict  */)"unexpected scan_for_first error");
#line 2554
        wd[0] = (char )'\000';
        }
      }
    } else {
      {
#line 2557
      my_strcopy(wd, (char const   *)(buff), (int )sizeof(wd));
#line 2558
      my_strcopy(extra, (char const   *)(non_sg.name), (int )sizeof(extra));
      }
    }
#line 2560
    if (wd[0]) {
      {
#line 2560
      tmp___13 = if_directory_chdir((char const   *)(wd), (char const   *)(extra));
      }
#line 2560
      if (tmp___13) {
        {
#line 2561
        tmp___12 = getcwd(wd, sizeof(wd));
        }
#line 2561
        if ((unsigned long )((void *)0) == (unsigned long )tmp___12) {
          {
#line 2562
          printf((char const   */* __restrict  */)"getcwd error");
#line 2563
          wd[0] = (char )'\000';
          }
        }
      }
    }
#line 2566
    if (wd[0]) {
#line 2567
      dev_node[0] = (char )'\000';
#line 2567
      tmp___14 = 1U;
      {
#line 2567
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2567
        if (tmp___14 >= 256U) {
#line 2567
          goto while_break___0;
        }
#line 2567
        dev_node[tmp___14] = (char)0;
#line 2567
        tmp___14 ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 2571
      if (1 == non_sg.ft) {
#line 2571
        typ = (enum dev_type )0;
      } else {
#line 2571
        typ = (enum dev_type )1;
      }
#line 2572
      if (get_wwn) {
#line 2573
        if (0U == (unsigned int )typ) {
          {
#line 2573
          tmp___15 = get_disk_wwn((char const   *)(wd), wwn_str, (int )sizeof(wwn_str));
          }
#line 2573
          if (tmp___15) {
            {
#line 2575
            printf((char const   */* __restrict  */)"%-30s  ", wwn_str);
            }
          } else {
            {
#line 2577
            printf((char const   */* __restrict  */)"                                ");
            }
          }
        } else {
          {
#line 2577
          printf((char const   */* __restrict  */)"                                ");
          }
        }
      }
#line 2581
      if (op->kname) {
        {
#line 2582
        tmp___16 = __xpg_basename(wd);
#line 2582
        snprintf((char */* __restrict  */)(dev_node), sizeof(dev_node), (char const   */* __restrict  */)"%s/%s",
                 dev_dir, tmp___16);
        }
      } else {
        {
#line 2584
        tmp___17 = get_dev_node((char const   *)(wd), dev_node, typ);
        }
#line 2584
        if (! tmp___17) {
          {
#line 2585
          snprintf((char */* __restrict  */)(dev_node), sizeof(dev_node), (char const   */* __restrict  */)"-       ");
          }
        }
      }
      {
#line 2588
      printf((char const   */* __restrict  */)"%-9s", dev_node);
      }
#line 2589
      if (op->dev_maj_min) {
        {
#line 2590
        tmp___18 = get_value((char const   *)(wd), "dev", value, (int )sizeof(value));
        }
#line 2590
        if (tmp___18) {
          {
#line 2592
          printf((char const   */* __restrict  */)"[%s]", value);
          }
        } else {
          {
#line 2594
          printf((char const   */* __restrict  */)"[dev?]");
          }
        }
      }
#line 2597
      if (op->scsi_id) {
        {
#line 2600
        scsi_id = get_disk_scsi_id((char const   *)(dev_node));
        }
#line 2601
        if (scsi_id) {
#line 2601
          tmp___19 = (char const   *)scsi_id;
        } else {
#line 2601
          tmp___19 = "-";
        }
        {
#line 2601
        printf((char const   */* __restrict  */)"  %s", tmp___19);
#line 2602
        free((void *)scsi_id);
        }
      }
    }
  } else {
#line 2606
    if (get_wwn) {
      {
#line 2607
      printf((char const   */* __restrict  */)"                                ");
      }
    }
#line 2608
    if (op->scsi_id) {
      {
#line 2609
      printf((char const   */* __restrict  */)"%-9s  -", "-");
      }
    } else {
      {
#line 2611
      printf((char const   */* __restrict  */)"%-9s", "-");
      }
    }
  }
#line 2614
  if (op->generic) {
    {
#line 2615
    tmp___26 = if_directory_ch2generic((char const   *)(buff));
    }
#line 2615
    if (tmp___26) {
      {
#line 2616
      tmp___25 = getcwd(wd, sizeof(wd));
      }
#line 2616
      if ((unsigned long )((void *)0) == (unsigned long )tmp___25) {
        {
#line 2617
        printf((char const   */* __restrict  */)"  generic_dev error");
        }
      } else {
#line 2619
        dev_node___0[0] = (char )'\000';
#line 2619
        tmp___21 = 1U;
        {
#line 2619
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 2619
          if (tmp___21 >= 256U) {
#line 2619
            goto while_break___1;
          }
#line 2619
          dev_node___0[tmp___21] = (char)0;
#line 2619
          tmp___21 ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 2621
        if (op->kname) {
          {
#line 2622
          tmp___22 = __xpg_basename(wd);
#line 2622
          snprintf((char */* __restrict  */)(dev_node___0), sizeof(dev_node___0),
                   (char const   */* __restrict  */)"%s/%s", dev_dir, tmp___22);
          }
        } else {
          {
#line 2625
          tmp___23 = get_dev_node((char const   *)(wd), dev_node___0, (enum dev_type )1);
          }
#line 2625
          if (! tmp___23) {
            {
#line 2627
            snprintf((char */* __restrict  */)(dev_node___0), sizeof(dev_node___0),
                     (char const   */* __restrict  */)"-");
            }
          }
        }
        {
#line 2629
        printf((char const   */* __restrict  */)"  %-9s", dev_node___0);
        }
#line 2630
        if (op->dev_maj_min) {
          {
#line 2631
          tmp___24 = get_value((char const   *)(wd), "dev", value, (int )sizeof(value));
          }
#line 2631
          if (tmp___24) {
            {
#line 2633
            printf((char const   */* __restrict  */)"[%s]", value);
            }
          } else {
            {
#line 2635
            printf((char const   */* __restrict  */)"[dev?]");
            }
          }
        }
      }
    } else {
      {
#line 2640
      printf((char const   */* __restrict  */)"  %-9s", "-");
      }
    }
  }
#line 2643
  if (op->protection) {
    {
#line 2647
    my_strcopy(sddir, (char const   *)(buff), (int )sizeof(sddir));
#line 2648
    my_strcopy(blkdir, (char const   *)(buff), (int )sizeof(blkdir));
#line 2650
    tmp___28 = sd_scan(sddir);
    }
#line 2650
    if (tmp___28) {
      {
#line 2650
      tmp___29 = if_directory_chdir((char const   *)(sddir), ".");
      }
#line 2650
      if (tmp___29) {
        {
#line 2650
        tmp___30 = get_value(".", "protection_type", value, (int )sizeof(value));
        }
#line 2650
        if (tmp___30) {
          {
#line 2654
          tmp___27 = strncmp((char const   *)(value), "0", (size_t )1);
          }
#line 2654
          if (tmp___27) {
            {
#line 2657
            printf((char const   */* __restrict  */)"  DIF/Type%1s", value);
            }
          } else {
            {
#line 2655
            printf((char const   */* __restrict  */)"  %-9s", "-");
            }
          }
        } else {
          {
#line 2660
          printf((char const   */* __restrict  */)"  %-9s", "-");
          }
        }
      } else {
        {
#line 2660
        printf((char const   */* __restrict  */)"  %-9s", "-");
        }
      }
    } else {
      {
#line 2660
      printf((char const   */* __restrict  */)"  %-9s", "-");
      }
    }
    {
#line 2662
    tmp___31 = block_scan(blkdir);
    }
#line 2662
    if (tmp___31) {
      {
#line 2662
      tmp___32 = if_directory_chdir((char const   *)(blkdir), "integrity");
      }
#line 2662
      if (tmp___32) {
        {
#line 2662
        tmp___33 = get_value(".", "format", value, (int )sizeof(value));
        }
#line 2662
        if (tmp___33) {
          {
#line 2665
          printf((char const   */* __restrict  */)"  %-16s", value);
          }
        } else {
          {
#line 2667
          printf((char const   */* __restrict  */)"  %-16s", "-");
          }
        }
      } else {
        {
#line 2667
        printf((char const   */* __restrict  */)"  %-16s", "-");
        }
      }
    } else {
      {
#line 2667
      printf((char const   */* __restrict  */)"  %-16s", "-");
      }
    }
  }
#line 2670
  if (op->protmode) {
    {
#line 2673
    my_strcopy(sddir___0, (char const   *)(buff), (int )sizeof(sddir___0));
#line 2675
    tmp___35 = sd_scan(sddir___0);
    }
#line 2675
    if (tmp___35) {
      {
#line 2675
      tmp___36 = if_directory_chdir((char const   *)(sddir___0), ".");
      }
#line 2675
      if (tmp___36) {
        {
#line 2675
        tmp___37 = get_value((char const   *)(sddir___0), "protection_mode", value,
                             (int )sizeof(value));
        }
#line 2675
        if (tmp___37) {
          {
#line 2680
          tmp___34 = strcmp((char const   *)(value), "none");
          }
#line 2680
          if (tmp___34) {
            {
#line 2683
            printf((char const   */* __restrict  */)"  %-4s", value);
            }
          } else {
            {
#line 2681
            printf((char const   */* __restrict  */)"  %-4s", "-");
            }
          }
        } else {
          {
#line 2685
          printf((char const   */* __restrict  */)"  %-4s", "-");
          }
        }
      } else {
        {
#line 2685
        printf((char const   */* __restrict  */)"  %-4s", "-");
        }
      }
    } else {
      {
#line 2685
      printf((char const   */* __restrict  */)"  %-4s", "-");
      }
    }
  }
#line 2688
  if (op->size) {
    {
#line 2691
    my_strcopy(blkdir___0, (char const   *)(buff), (int )sizeof(blkdir___0));
#line 2693
    value[0] = (char)0;
    }
#line 2694
    if (type == 0) {
      {
#line 2694
      tmp___40 = block_scan(blkdir___0);
      }
#line 2694
      if (tmp___40) {
        {
#line 2694
        tmp___41 = if_directory_chdir((char const   *)(blkdir___0), ".");
        }
#line 2694
        if (tmp___41) {
          {
#line 2694
          tmp___42 = get_value(".", "size", value, (int )sizeof(value));
          }
#line 2694
          if (tmp___42) {
            {
#line 2698
            tmp___38 = atoll((char const   *)(value));
#line 2698
            blocks = (uint64_t )tmp___38;
#line 2700
            blocks <<= 9;
            }
#line 2701
            if (blocks > 0UL) {
              {
#line 2701
              tmp___39 = string_get_size(blocks, (enum string_size_units  const  )0,
                                         value, (int )sizeof(value));
              }
#line 2701
              if (tmp___39) {
                {
#line 2706
                printf((char const   */* __restrict  */)"  %6s", "-");
                }
              } else {
                {
#line 2704
                printf((char const   */* __restrict  */)"  %6s", value);
                }
              }
            } else {
              {
#line 2706
              printf((char const   */* __restrict  */)"  %6s", "-");
              }
            }
          } else {
            {
#line 2708
            printf((char const   */* __restrict  */)"  %6s", "-");
            }
          }
        } else {
          {
#line 2708
          printf((char const   */* __restrict  */)"  %6s", "-");
          }
        }
      } else {
        {
#line 2708
        printf((char const   */* __restrict  */)"  %6s", "-");
        }
      }
    } else {
      {
#line 2708
      printf((char const   */* __restrict  */)"  %6s", "-");
      }
    }
  }
  {
#line 2711
  printf((char const   */* __restrict  */)"\n");
  }
#line 2712
  if (op->long_opt > 0) {
    {
#line 2713
    longer_d_entry((char const   *)(buff), devname, op);
    }
  }
#line 2714
  if (op->verbose > 0) {
    {
#line 2715
    printf((char const   */* __restrict  */)"  dir: %s  [", buff);
#line 2716
    tmp___44 = if_directory_chdir((char const   *)(buff), "");
    }
#line 2716
    if (tmp___44) {
      {
#line 2717
      tmp___43 = getcwd(wd, sizeof(wd));
      }
#line 2717
      if ((unsigned long )((void *)0) == (unsigned long )tmp___43) {
        {
#line 2718
        printf((char const   */* __restrict  */)"?");
        }
      } else {
        {
#line 2720
        printf((char const   */* __restrict  */)"%s", wd);
        }
      }
    }
    {
#line 2722
    printf((char const   */* __restrict  */)"]\n");
    }
  }
#line 2724
  return;
}
}
#line 2726 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static int sdev_scandir_select(struct dirent  const  *s ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  struct addr_hctl s_hctl ;
  int tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 2730
  tmp = strstr((char const   *)(s->d_name), "mt");
  }
#line 2730
  if (tmp) {
#line 2731
    return (0);
  }
  {
#line 2732
  tmp___0 = strstr((char const   *)(s->d_name), "ot");
  }
#line 2732
  if (tmp___0) {
#line 2733
    return (0);
  }
  {
#line 2734
  tmp___1 = strstr((char const   *)(s->d_name), "gen");
  }
#line 2734
  if (tmp___1) {
#line 2735
    return (0);
  }
  {
#line 2737
  tmp___2 = strncmp((char const   *)(s->d_name), "host", (size_t )4);
  }
#line 2737
  if (! tmp___2) {
#line 2738
    return (0);
  }
  {
#line 2739
  tmp___3 = strncmp((char const   *)(s->d_name), "target", (size_t )6);
  }
#line 2739
  if (! tmp___3) {
#line 2740
    return (0);
  }
  {
#line 2741
  tmp___5 = strchr((char const   *)(s->d_name), ':');
  }
#line 2741
  if (tmp___5) {
#line 2742
    if (filter_active) {
      {
#line 2745
      tmp___4 = parse_colon_list((char const   *)(s->d_name), & s_hctl);
      }
#line 2745
      if (! tmp___4) {
        {
#line 2746
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sdev_scandir_select: parse failed\n");
        }
#line 2748
        return (0);
      }
#line 2750
      if (-1 == filter.h) {
#line 2750
        goto _L___1;
      } else
#line 2750
      if (s_hctl.h == filter.h) {
        _L___1: /* CIL Label */ 
#line 2750
        if (-1 == filter.c) {
#line 2750
          goto _L___0;
        } else
#line 2750
        if (s_hctl.c == filter.c) {
          _L___0: /* CIL Label */ 
#line 2750
          if (-1 == filter.t) {
#line 2750
            goto _L;
          } else
#line 2750
          if (s_hctl.t == filter.t) {
            _L: /* CIL Label */ 
#line 2750
            if (0xffffffffffffffffUL == filter.l) {
#line 2755
              return (1);
            } else
#line 2750
            if (s_hctl.l == filter.l) {
#line 2755
              return (1);
            } else {
#line 2757
              return (0);
            }
          } else {
#line 2757
            return (0);
          }
        } else {
#line 2757
          return (0);
        }
      } else {
#line 2757
        return (0);
      }
    } else {
#line 2759
      return (1);
    }
  }
#line 2762
  return (0);
}
}
#line 2770 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static int sdev_scandir_sort(struct dirent  const  **a , struct dirent  const  **b ) 
{ 
  char const   *lnam ;
  char const   *rnam ;
  struct addr_hctl left_hctl ;
  struct addr_hctl right_hctl ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 2773
  lnam = (char const   *)((*a)->d_name);
#line 2774
  rnam = (char const   *)((*b)->d_name);
#line 2778
  tmp = parse_colon_list(lnam, & left_hctl);
  }
#line 2778
  if (! tmp) {
    {
#line 2779
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sdev_scandir_sort: left parse failed\n");
    }
#line 2780
    return (-1);
  }
  {
#line 2782
  tmp___0 = parse_colon_list(rnam, & right_hctl);
  }
#line 2782
  if (! tmp___0) {
    {
#line 2783
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sdev_scandir_sort: right parse failed\n");
    }
#line 2784
    return (1);
  }
  {
#line 2786
  tmp___1 = cmp_hctl((struct addr_hctl  const  *)(& left_hctl), (struct addr_hctl  const  *)(& right_hctl));
  }
#line 2786
  return (tmp___1);
}
}
#line 2790 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static void list_sdevices(struct lsscsi_opt_coll  const  *op ) 
{ 
  char buff[384] ;
  char name[256] ;
  struct dirent **namelist ;
  int num ;
  int k ;
  char const   *tmp ;

  {
  {
#line 2798
  snprintf((char */* __restrict  */)(buff), sizeof(buff), (char const   */* __restrict  */)"%s%s",
           sysfsroot, bus_scsi_devs);
#line 2800
  num = scandir((char const   */* __restrict  */)(buff), (struct dirent ***/* __restrict  */)(& namelist),
                & sdev_scandir_select, & sdev_scandir_sort);
  }
#line 2802
  if (num < 0) {
#line 2803
    if (op->verbose > 0) {
      {
#line 2804
      snprintf((char */* __restrict  */)(name), sizeof(name), (char const   */* __restrict  */)"scandir: %s",
               buff);
#line 2805
      perror((char const   *)(name));
#line 2806
      printf((char const   */* __restrict  */)"SCSI mid level module may not be loaded\n");
      }
    }
#line 2808
    if (op->classic) {
      {
#line 2809
      printf((char const   */* __restrict  */)"Attached devices: none\n");
      }
    }
#line 2810
    return;
  }
#line 2812
  if (op->classic) {
#line 2813
    if (num) {
#line 2813
      tmp = "";
    } else {
#line 2813
      tmp = "none";
    }
    {
#line 2813
    printf((char const   */* __restrict  */)"Attached devices: %s\n", tmp);
    }
  }
#line 2815
  k = 0;
  {
#line 2815
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2815
    if (! (k < num)) {
#line 2815
      goto while_break;
    }
    {
#line 2816
    my_strcopy(name, (char const   *)((*(namelist + k))->d_name), (int )sizeof(name));
#line 2817
    transport_id = 0;
#line 2818
    one_sdev_entry((char const   *)(buff), (char const   *)(name), op);
#line 2819
    free((void *)*(namelist + k));
#line 2815
    k ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2821
  free((void *)namelist);
  }
#line 2822
  if (op->wwn) {
    {
#line 2823
    free_disk_wwn_node_list();
    }
  }
#line 2824
  return;
}
}
#line 2827 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static void longer_h_entry(char const   *path_name , struct lsscsi_opt_coll  const  *op ) 
{ 
  char value[256] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
#line 2832
  if (op->transport > 0) {
    {
#line 2833
    transport_init_longer(path_name, op);
    }
#line 2834
    return;
  }
#line 2836
  if (op->long_opt >= 3) {
    {
#line 2837
    tmp = get_value(path_name, "can_queue", value, (int )sizeof(value));
    }
#line 2837
    if (tmp) {
      {
#line 2838
      printf((char const   */* __restrict  */)"  can_queue=%s\n", value);
      }
    } else
#line 2839
    if (op->verbose) {
      {
#line 2840
      printf((char const   */* __restrict  */)"  can_queue=?\n");
      }
    }
    {
#line 2841
    tmp___0 = get_value(path_name, "cmd_per_lun", value, (int )sizeof(value));
    }
#line 2841
    if (tmp___0) {
      {
#line 2842
      printf((char const   */* __restrict  */)"  cmd_per_lun=%s\n", value);
      }
    } else
#line 2843
    if (op->verbose) {
      {
#line 2844
      printf((char const   */* __restrict  */)"  cmd_per_lun=?\n");
      }
    }
    {
#line 2845
    tmp___1 = get_value(path_name, "host_busy", value, (int )sizeof(value));
    }
#line 2845
    if (tmp___1) {
      {
#line 2846
      printf((char const   */* __restrict  */)"  host_busy=%s\n", value);
      }
    } else
#line 2847
    if (op->verbose) {
      {
#line 2848
      printf((char const   */* __restrict  */)"  host_busy=?\n");
      }
    }
    {
#line 2849
    tmp___2 = get_value(path_name, "sg_tablesize", value, (int )sizeof(value));
    }
#line 2849
    if (tmp___2) {
      {
#line 2851
      printf((char const   */* __restrict  */)"  sg_tablesize=%s\n", value);
      }
    } else
#line 2852
    if (op->verbose) {
      {
#line 2853
      printf((char const   */* __restrict  */)"  sg_tablesize=?\n");
      }
    }
    {
#line 2854
    tmp___3 = get_value(path_name, "state", value, (int )sizeof(value));
    }
#line 2854
    if (tmp___3) {
      {
#line 2855
      printf((char const   */* __restrict  */)"  state=%s\n", value);
      }
    } else
#line 2856
    if (op->verbose) {
      {
#line 2857
      printf((char const   */* __restrict  */)"  state=?\n");
      }
    }
    {
#line 2858
    tmp___4 = get_value(path_name, "unchecked_isa_dma", value, (int )sizeof(value));
    }
#line 2858
    if (tmp___4) {
      {
#line 2860
      printf((char const   */* __restrict  */)"  unchecked_isa_dma=%s\n", value);
      }
    } else
#line 2861
    if (op->verbose) {
      {
#line 2862
      printf((char const   */* __restrict  */)"  unchecked_isa_dma=?\n");
      }
    }
    {
#line 2863
    tmp___5 = get_value(path_name, "unique_id", value, (int )sizeof(value));
    }
#line 2863
    if (tmp___5) {
      {
#line 2864
      printf((char const   */* __restrict  */)"  unique_id=%s\n", value);
      }
    } else
#line 2865
    if (op->verbose) {
      {
#line 2866
      printf((char const   */* __restrict  */)"  unique_id=?\n");
      }
    }
  } else
#line 2867
  if (op->long_opt > 0) {
    {
#line 2868
    tmp___6 = get_value(path_name, "cmd_per_lun", value, (int )sizeof(value));
    }
#line 2868
    if (tmp___6) {
      {
#line 2869
      printf((char const   */* __restrict  */)"  cmd_per_lun=%-4s ", value);
      }
    } else {
      {
#line 2871
      printf((char const   */* __restrict  */)"  cmd_per_lun=???? ");
      }
    }
    {
#line 2873
    tmp___7 = get_value(path_name, "host_busy", value, (int )sizeof(value));
    }
#line 2873
    if (tmp___7) {
      {
#line 2874
      printf((char const   */* __restrict  */)"host_busy=%-4s ", value);
      }
    } else {
      {
#line 2876
      printf((char const   */* __restrict  */)"host_busy=???? ");
      }
    }
    {
#line 2878
    tmp___8 = get_value(path_name, "sg_tablesize", value, (int )sizeof(value));
    }
#line 2878
    if (tmp___8) {
      {
#line 2880
      printf((char const   */* __restrict  */)"sg_tablesize=%-4s ", value);
      }
    } else {
      {
#line 2882
      printf((char const   */* __restrict  */)"sg_tablesize=???? ");
      }
    }
    {
#line 2884
    tmp___9 = get_value(path_name, "unchecked_isa_dma", value, (int )sizeof(value));
    }
#line 2884
    if (tmp___9) {
      {
#line 2886
      printf((char const   */* __restrict  */)"unchecked_isa_dma=%-2s ", value);
      }
    } else {
      {
#line 2888
      printf((char const   */* __restrict  */)"unchecked_isa_dma=?? ");
      }
    }
    {
#line 2889
    printf((char const   */* __restrict  */)"\n");
    }
#line 2890
    if (2 == (int )op->long_opt) {
      {
#line 2891
      tmp___10 = get_value(path_name, "can_queue", value, (int )sizeof(value));
      }
#line 2891
      if (tmp___10) {
        {
#line 2893
        printf((char const   */* __restrict  */)"  can_queue=%-4s ", value);
        }
      }
      {
#line 2894
      tmp___11 = get_value(path_name, "state", value, (int )sizeof(value));
      }
#line 2894
      if (tmp___11) {
        {
#line 2896
        printf((char const   */* __restrict  */)"  state=%-8s ", value);
        }
      }
      {
#line 2897
      tmp___12 = get_value(path_name, "unique_id", value, (int )sizeof(value));
      }
#line 2897
      if (tmp___12) {
        {
#line 2899
        printf((char const   */* __restrict  */)"  unique_id=%-2s ", value);
        }
      }
      {
#line 2900
      printf((char const   */* __restrict  */)"\n");
      }
    }
  }
#line 2903
  return;
}
}
#line 2905 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static void one_host_entry(char const   *dir_name , char const   *devname , struct lsscsi_opt_coll  const  *op ) 
{ 
  char buff[384] ;
  char value[256] ;
  char wd[4096] ;
  char const   *nullname1 ;
  char const   *nullname2 ;
  unsigned int host_id ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;

  {
#line 2912
  nullname1 = "<NULL>";
#line 2913
  nullname2 = "(null)";
#line 2916
  if (op->classic) {
    {
#line 2918
    printf((char const   */* __restrict  */)"  <\'--classic\' not supported for hosts>\n");
    }
#line 2919
    return;
  }
  {
#line 2921
  tmp = sscanf((char const   */* __restrict  */)devname, (char const   */* __restrict  */)"host%u",
               & host_id);
  }
#line 2921
  if (1 == tmp) {
    {
#line 2922
    printf((char const   */* __restrict  */)"[%u]  ", host_id);
    }
  } else {
    {
#line 2924
    printf((char const   */* __restrict  */)"[?]  ");
    }
  }
  {
#line 2925
  snprintf((char */* __restrict  */)(buff), sizeof(buff), (char const   */* __restrict  */)"%s/%s",
           dir_name, devname);
#line 2926
  tmp___3 = get_value((char const   *)(buff), "proc_name", value, (int )sizeof(value));
  }
#line 2926
  if (tmp___3) {
    {
#line 2926
    tmp___4 = strncmp((char const   *)(value), nullname1, (size_t )6);
    }
#line 2926
    if (tmp___4) {
      {
#line 2926
      tmp___5 = strncmp((char const   *)(value), nullname2, (size_t )6);
      }
#line 2926
      if (tmp___5) {
        {
#line 2928
        printf((char const   */* __restrict  */)"  %-12s  ", value);
        }
      } else {
#line 2926
        goto _L___0;
      }
    } else {
#line 2926
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    {
#line 2929
    tmp___2 = if_directory_chdir((char const   *)(buff), "device/../driver");
    }
#line 2929
    if (tmp___2) {
      {
#line 2930
      tmp___1 = getcwd(wd, sizeof(wd));
      }
#line 2930
      if ((unsigned long )((void *)0) == (unsigned long )tmp___1) {
        {
#line 2931
        printf((char const   */* __restrict  */)"  %-12s  ", nullname2);
        }
      } else {
        {
#line 2933
        tmp___0 = __xpg_basename(wd);
#line 2933
        printf((char const   */* __restrict  */)"  %-12s  ", tmp___0);
        }
      }
    } else {
      {
#line 2936
      printf((char const   */* __restrict  */)"  proc_name=????  ");
      }
    }
  }
#line 2937
  if (op->transport > 0) {
    {
#line 2938
    tmp___6 = transport_init(devname, (int )sizeof(value), value);
    }
#line 2938
    if (tmp___6) {
      {
#line 2939
      printf((char const   */* __restrict  */)"%s\n", value);
      }
    } else {
      {
#line 2941
      printf((char const   */* __restrict  */)"\n");
      }
    }
  } else {
    {
#line 2943
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 2945
  if (op->long_opt > 0) {
    {
#line 2946
    longer_h_entry((char const   *)(buff), op);
    }
  }
#line 2948
  if (op->verbose > 0) {
    {
#line 2949
    printf((char const   */* __restrict  */)"  dir: %s\n  device dir: ", buff);
#line 2950
    tmp___8 = if_directory_chdir((char const   *)(buff), "device");
    }
#line 2950
    if (tmp___8) {
      {
#line 2951
      tmp___7 = getcwd(wd, sizeof(wd));
      }
#line 2951
      if ((unsigned long )((void *)0) == (unsigned long )tmp___7) {
        {
#line 2952
        printf((char const   */* __restrict  */)"?");
        }
      } else {
        {
#line 2954
        printf((char const   */* __restrict  */)"%s", wd);
        }
      }
    }
    {
#line 2956
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 2958
  return;
}
}
#line 2960 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static int host_scandir_select(struct dirent  const  *s ) 
{ 
  int h ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 2965
  tmp___0 = strncmp("host", (char const   *)(s->d_name), (size_t )4);
  }
#line 2965
  if (0 == tmp___0) {
#line 2966
    if (filter_active) {
#line 2967
      if (-1 == filter.h) {
#line 2968
        return (1);
      } else {
        {
#line 2969
        tmp = sscanf((char const   */* __restrict  */)(s->d_name + 4), (char const   */* __restrict  */)"%d",
                     & h);
        }
#line 2969
        if (1 == tmp) {
#line 2969
          if (h == filter.h) {
#line 2971
            return (1);
          } else {
#line 2973
            return (0);
          }
        } else {
#line 2973
          return (0);
        }
      }
    } else {
#line 2975
      return (1);
    }
  }
#line 2977
  return (0);
}
}
#line 2985 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static int host_scandir_sort(struct dirent  const  **a , struct dirent  const  **b ) 
{ 
  char const   *lnam ;
  char const   *rnam ;
  unsigned int l ;
  unsigned int r ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 2988
  lnam = (char const   *)((*a)->d_name);
#line 2989
  rnam = (char const   *)((*b)->d_name);
#line 2992
  tmp = sscanf((char const   */* __restrict  */)lnam, (char const   */* __restrict  */)"host%u",
               & l);
  }
#line 2992
  if (1 != tmp) {
#line 2993
    return (-1);
  }
  {
#line 2994
  tmp___0 = sscanf((char const   */* __restrict  */)rnam, (char const   */* __restrict  */)"host%u",
                   & r);
  }
#line 2994
  if (1 != tmp___0) {
#line 2995
    return (1);
  }
#line 2996
  if (l < r) {
#line 2997
    return (-1);
  } else
#line 2998
  if (r < l) {
#line 2999
    return (1);
  }
#line 3000
  return (0);
}
}
#line 3003 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static void list_hosts(struct lsscsi_opt_coll  const  *op ) 
{ 
  char buff[384] ;
  char name[256] ;
  struct dirent **namelist ;
  int num ;
  int k ;
  char const   *tmp ;

  {
  {
#line 3011
  snprintf((char */* __restrict  */)(buff), sizeof(buff), (char const   */* __restrict  */)"%s%s",
           sysfsroot, scsi_host);
#line 3013
  num = scandir((char const   */* __restrict  */)(buff), (struct dirent ***/* __restrict  */)(& namelist),
                & host_scandir_select, & host_scandir_sort);
  }
#line 3015
  if (num < 0) {
    {
#line 3016
    snprintf((char */* __restrict  */)(name), sizeof(name), (char const   */* __restrict  */)"scandir: %s",
             buff);
#line 3017
    perror((char const   *)(name));
    }
#line 3018
    return;
  }
#line 3020
  if (op->classic) {
#line 3021
    if (num) {
#line 3021
      tmp = "";
    } else {
#line 3021
      tmp = "none";
    }
    {
#line 3021
    printf((char const   */* __restrict  */)"Attached hosts: %s\n", tmp);
    }
  }
#line 3023
  k = 0;
  {
#line 3023
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3023
    if (! (k < num)) {
#line 3023
      goto while_break;
    }
    {
#line 3024
    my_strcopy(name, (char const   *)((*(namelist + k))->d_name), (int )sizeof(name));
#line 3025
    transport_id = 0;
#line 3026
    one_host_entry((char const   *)(buff), (char const   *)(name), op);
#line 3027
    free((void *)*(namelist + k));
#line 3023
    k ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3029
  free((void *)namelist);
  }
#line 3030
  return;
}
}
#line 3033 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static int one_filter_arg(char const   *arg , struct addr_hctl *filtp ) 
{ 
  char const   *cp ;
  char const   *cpe ;
  char buff[64] ;
  int val ;
  int k ;
  int n ;
  int res ;
  uint64_t val64 ;
  char *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
#line 3042
  cp = arg;
  {
#line 3043
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3043
    if (! ((int const   )*cp == 32)) {
#line 3043
      if (! ((int const   )*cp == 9)) {
#line 3043
        if (! ((int const   )*cp == 91)) {
#line 3043
          goto while_break;
        }
      }
    }
#line 3044
    cp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3045
  if (0 == (int )*cp) {
#line 3046
    return (0);
  }
#line 3047
  k = 0;
  {
#line 3047
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3047
    if (! *cp) {
#line 3047
      goto while_break___0;
    }
    {
#line 3048
    tmp = strchr(cp, ':');
#line 3048
    cpe = (char const   *)tmp;
    }
#line 3049
    if (cpe) {
#line 3050
      n = (int )(cpe - cp);
    } else {
      {
#line 3052
      tmp___0 = strlen(cp);
#line 3052
      n = (int )tmp___0;
#line 3053
      cpe = (cp + n) - 1;
      }
    }
#line 3055
    val = -1;
#line 3056
    val64 = (uint64_t )(~ 0);
#line 3057
    if (n > (int )sizeof(buff) - 1) {
      {
#line 3058
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"intermediate sting in %s too long (n=%d)\n",
              arg, n);
      }
#line 3060
      return (1);
    }
#line 3062
    if (n > 0) {
#line 3062
      if (45 != (int )*cp) {
#line 3062
        if (42 != (int )*cp) {
#line 3062
          if (63 != (int )*cp) {
            {
#line 3063
            memcpy((void */* __restrict  */)(buff), (void const   */* __restrict  */)cp,
                   (size_t )n);
#line 3064
            buff[n] = (char )'\000';
            }
#line 3065
            if (3 == k) {
#line 3066
              if (48 == (int )buff[0]) {
                {
#line 3066
                tmp___1 = toupper((int )buff[1]);
                }
#line 3066
                if (88 == tmp___1) {
                  {
#line 3068
                  res = sscanf((char const   */* __restrict  */)(buff), (char const   */* __restrict  */)"%lx",
                               & val64);
                  }
                } else {
                  {
#line 3071
                  res = sscanf((char const   */* __restrict  */)(buff), (char const   */* __restrict  */)"%lu",
                               & val64);
                  }
                }
              } else {
                {
#line 3071
                res = sscanf((char const   */* __restrict  */)(buff), (char const   */* __restrict  */)"%lu",
                             & val64);
                }
              }
            } else {
              {
#line 3074
              res = sscanf((char const   */* __restrict  */)(buff), (char const   */* __restrict  */)"%d",
                           & val);
              }
            }
#line 3075
            if (1 != res) {
              {
#line 3075
              tmp___2 = strchr((char const   *)(buff), ']');
              }
#line 3075
              if ((unsigned long )((void *)0) == (unsigned long )tmp___2) {
                {
#line 3077
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cannot decode %s as an integer\n",
                        buff);
                }
#line 3079
                return (1);
              }
            }
          }
        }
      }
    }
    {
#line 3083
    if (k == 0) {
#line 3083
      goto case_0;
    }
#line 3084
    if (k == 1) {
#line 3084
      goto case_1;
    }
#line 3085
    if (k == 2) {
#line 3085
      goto case_2;
    }
#line 3086
    if (k == 3) {
#line 3086
      goto case_3;
    }
#line 3087
    goto switch_default;
    case_0: /* CIL Label */ 
#line 3083
    filtp->h = val;
#line 3083
    goto switch_break;
    case_1: /* CIL Label */ 
#line 3084
    filtp->c = val;
#line 3084
    goto switch_break;
    case_2: /* CIL Label */ 
#line 3085
    filtp->t = val;
#line 3085
    goto switch_break;
    case_3: /* CIL Label */ 
#line 3086
    filtp->l = val64;
#line 3086
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 3088
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"expect three colons at most in %s\n",
            arg);
    }
#line 3090
    return (1);
    switch_break: /* CIL Label */ ;
    }
#line 3047
    cp = cpe + 1;
#line 3047
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 3093
  return (0);
}
}
#line 3097 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
static int decode_filter_arg(char const   *a1p , char const   *a2p , char const   *a3p ,
                             char const   *a4p , struct addr_hctl *filtp ) 
{ 
  char b1[256] ;
  char *b1p ;
  int n ;
  int rem ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;
  size_t tmp___6 ;
  char *tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;

  {
#line 3105
  if ((unsigned long )((void *)0) == (unsigned long )a1p) {
    {
#line 3106
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad call to decode_filter\n");
    }
#line 3107
    return (1);
  } else
#line 3105
  if ((unsigned long )((void *)0) == (unsigned long )filtp) {
    {
#line 3106
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad call to decode_filter\n");
    }
#line 3107
    return (1);
  }
  {
#line 3109
  filtp->h = -1;
#line 3110
  filtp->c = -1;
#line 3111
  filtp->t = -1;
#line 3112
  filtp->l = (uint64_t )(~ 0);
#line 3113
  tmp = strncmp("host", a1p, (size_t )4);
  }
#line 3113
  if (0 == tmp) {
    {
#line 3113
    tmp___0 = sscanf((char const   */* __restrict  */)a1p, (char const   */* __restrict  */)"host%d",
                     & n);
    }
#line 3113
    if (1 == tmp___0) {
#line 3113
      if (n >= 0) {
#line 3115
        filtp->h = n;
#line 3116
        return (0);
      }
    }
  }
#line 3118
  if ((unsigned long )((void *)0) == (unsigned long )a2p) {
    {
#line 3119
    tmp___1 = one_filter_arg(a1p, filtp);
    }
#line 3119
    return (tmp___1);
  } else {
    {
#line 3118
    tmp___10 = strchr(a1p, ':');
    }
#line 3118
    if (tmp___10) {
      {
#line 3119
      tmp___1 = one_filter_arg(a1p, filtp);
      }
#line 3119
      return (tmp___1);
    } else {
      {
#line 3121
      rem = (int )(sizeof(b1) - 5UL);
#line 3122
      b1p = b1;
#line 3123
      tmp___2 = strlen(a1p);
#line 3123
      n = (int )tmp___2;
      }
#line 3123
      if (n > rem) {
#line 3124
        goto err_out;
      }
      {
#line 3125
      my_strcopy(b1p, a1p, rem);
#line 3126
      b1p += n;
#line 3127
      tmp___3 = b1p;
#line 3127
      b1p ++;
#line 3127
      *tmp___3 = (char )':';
#line 3128
      rem -= n + 1;
#line 3129
      tmp___4 = strlen(a2p);
#line 3129
      n = (int )tmp___4;
      }
#line 3129
      if (n > rem) {
#line 3130
        goto err_out;
      }
      {
#line 3131
      my_strcopy(b1p, a2p, rem);
      }
#line 3132
      if (a3p) {
        {
#line 3133
        b1p += n;
#line 3134
        tmp___5 = b1p;
#line 3134
        b1p ++;
#line 3134
        *tmp___5 = (char )':';
#line 3135
        rem -= n + 1;
#line 3136
        tmp___6 = strlen(a3p);
#line 3136
        n = (int )tmp___6;
        }
#line 3136
        if (n > rem) {
#line 3137
          goto err_out;
        }
        {
#line 3138
        my_strcopy(b1p, a3p, rem);
        }
#line 3139
        if (a4p) {
          {
#line 3140
          b1p += n;
#line 3141
          tmp___7 = b1p;
#line 3141
          b1p ++;
#line 3141
          *tmp___7 = (char )':';
#line 3142
          rem -= n + 1;
#line 3143
          tmp___8 = strlen(a4p);
#line 3143
          n = (int )tmp___8;
          }
#line 3143
          if (n > rem) {
#line 3144
            goto err_out;
          }
          {
#line 3145
          my_strcopy(b1p, a4p, rem);
          }
        }
      }
      {
#line 3148
      tmp___9 = one_filter_arg((char const   *)(b1), filtp);
      }
#line 3148
      return (tmp___9);
    }
  }
  err_out: 
  {
#line 3151
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"filter arguments exceed internal buffer size (%d)\n",
          (int )sizeof(b1));
  }
#line 3153
  return (1);
}
}
#line 3157 "/home/wheatley/newnew/temp/lsscsi-0.27/src/lsscsi.c"
int main(int argc , char **argv ) 
{ 
  int c ;
  int do_sdevices ;
  int do_hosts ;
  struct lsscsi_opt_coll opts ;
  char const   *cp ;
  char *tmp ;
  int option_index ;
  char const   *a1p ;
  char const   *a2p ;
  char const   *a3p ;
  char const   *a4p ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 3161
  do_sdevices = 1;
#line 3162
  do_hosts = 0;
#line 3166
  tmp = getenv("LSSCSI_LUNHEX_OPT");
#line 3166
  cp = (char const   *)tmp;
#line 3167
  invalidate_hctl(& filter);
#line 3168
  memset((void *)(& opts), 0, sizeof(opts));
  }
  {
#line 3169
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3170
    option_index = 0;
#line 3172
    c = getopt_long(argc, (char * const  *)argv, "cdghHiklLpPstvVwxy:", (struct option  const  *)(long_options),
                    & option_index);
    }
#line 3174
    if (c == -1) {
#line 3175
      goto while_break;
    }
    {
#line 3178
    if (c == 99) {
#line 3178
      goto case_99;
    }
#line 3181
    if (c == 100) {
#line 3181
      goto case_100;
    }
#line 3184
    if (c == 103) {
#line 3184
      goto case_103;
    }
#line 3187
    if (c == 104) {
#line 3187
      goto case_104;
    }
#line 3190
    if (c == 72) {
#line 3190
      goto case_72;
    }
#line 3193
    if (c == 105) {
#line 3193
      goto case_105;
    }
#line 3196
    if (c == 107) {
#line 3196
      goto case_107;
    }
#line 3199
    if (c == 108) {
#line 3199
      goto case_108;
    }
#line 3202
    if (c == 76) {
#line 3202
      goto case_76;
    }
#line 3205
    if (c == 112) {
#line 3205
      goto case_112;
    }
#line 3208
    if (c == 80) {
#line 3208
      goto case_80;
    }
#line 3211
    if (c == 115) {
#line 3211
      goto case_115;
    }
#line 3214
    if (c == 116) {
#line 3214
      goto case_116;
    }
#line 3217
    if (c == 118) {
#line 3217
      goto case_118;
    }
#line 3220
    if (c == 86) {
#line 3220
      goto case_86;
    }
#line 3223
    if (c == 119) {
#line 3223
      goto case_119;
    }
#line 3226
    if (c == 120) {
#line 3226
      goto case_120;
    }
#line 3229
    if (c == 121) {
#line 3229
      goto case_121;
    }
#line 3232
    if (c == 63) {
#line 3232
      goto case_63;
    }
#line 3235
    goto switch_default;
    case_99: /* CIL Label */ 
#line 3179
    (opts.classic) ++;
#line 3180
    goto switch_break;
    case_100: /* CIL Label */ 
#line 3182
    (opts.dev_maj_min) ++;
#line 3183
    goto switch_break;
    case_103: /* CIL Label */ 
#line 3185
    (opts.generic) ++;
#line 3186
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 3188
    usage();
    }
#line 3189
    return (0);
    case_72: /* CIL Label */ 
#line 3191
    do_hosts ++;
#line 3192
    goto switch_break;
    case_105: /* CIL Label */ 
#line 3194
    (opts.scsi_id) ++;
#line 3195
    goto switch_break;
    case_107: /* CIL Label */ 
#line 3197
    (opts.kname) ++;
#line 3198
    goto switch_break;
    case_108: /* CIL Label */ 
#line 3200
    (opts.long_opt) ++;
#line 3201
    goto switch_break;
    case_76: /* CIL Label */ 
#line 3203
    opts.long_opt += 3;
#line 3204
    goto switch_break;
    case_112: /* CIL Label */ 
#line 3206
    (opts.protection) ++;
#line 3207
    goto switch_break;
    case_80: /* CIL Label */ 
#line 3209
    (opts.protmode) ++;
#line 3210
    goto switch_break;
    case_115: /* CIL Label */ 
#line 3212
    (opts.size) ++;
#line 3213
    goto switch_break;
    case_116: /* CIL Label */ 
#line 3215
    (opts.transport) ++;
#line 3216
    goto switch_break;
    case_118: /* CIL Label */ 
#line 3218
    (opts.verbose) ++;
#line 3219
    goto switch_break;
    case_86: /* CIL Label */ 
    {
#line 3221
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"version: %s\n",
            version_str);
    }
#line 3222
    return (0);
    case_119: /* CIL Label */ 
#line 3224
    (opts.wwn) ++;
#line 3225
    goto switch_break;
    case_120: /* CIL Label */ 
#line 3227
    (opts.lunhex) ++;
#line 3228
    goto switch_break;
    case_121: /* CIL Label */ 
#line 3230
    sysfsroot = (char const   *)optarg;
#line 3231
    goto switch_break;
    case_63: /* CIL Label */ 
    {
#line 3233
    usage();
    }
#line 3234
    return (1);
    switch_default: /* CIL Label */ 
    {
#line 3236
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"?? getopt returned character code 0x%x ??\n",
            c);
#line 3238
    usage();
    }
#line 3239
    return (1);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3243
  if (optind < argc) {
#line 3244
    a1p = (char const   *)((void *)0);
#line 3245
    a2p = (char const   *)((void *)0);
#line 3246
    a3p = (char const   *)((void *)0);
#line 3247
    a4p = (char const   *)((void *)0);
#line 3249
    if (optind + 4 < argc) {
      {
#line 3250
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unexpected non-option arguments: ");
      }
      {
#line 3251
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 3251
        if (! (optind < argc)) {
#line 3251
          goto while_break___0;
        }
        {
#line 3252
        tmp___0 = optind;
#line 3252
        optind ++;
#line 3252
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s ",
                *(argv + tmp___0));
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 3253
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
#line 3254
      return (1);
    }
#line 3256
    tmp___1 = optind;
#line 3256
    optind ++;
#line 3256
    a1p = (char const   *)*(argv + tmp___1);
#line 3257
    if (optind < argc) {
#line 3258
      tmp___2 = optind;
#line 3258
      optind ++;
#line 3258
      a2p = (char const   *)*(argv + tmp___2);
#line 3259
      if (optind < argc) {
#line 3260
        tmp___3 = optind;
#line 3260
        optind ++;
#line 3260
        a3p = (char const   *)*(argv + tmp___3);
#line 3261
        if (optind < argc) {
#line 3262
          tmp___4 = optind;
#line 3262
          optind ++;
#line 3262
          a4p = (char const   *)*(argv + tmp___4);
        }
      }
    }
    {
#line 3265
    tmp___5 = decode_filter_arg(a1p, a2p, a3p, a4p, & filter);
    }
#line 3265
    if (tmp___5) {
#line 3266
      return (1);
    }
#line 3267
    if (filter.h != -1) {
#line 3269
      filter_active = 1;
    } else
#line 3267
    if (filter.c != -1) {
#line 3269
      filter_active = 1;
    } else
#line 3267
    if (filter.t != -1) {
#line 3269
      filter_active = 1;
    } else
#line 3267
    if (filter.l != 0xffffffffffffffffUL) {
#line 3269
      filter_active = 1;
    }
  }
#line 3271
  if (0 == opts.lunhex) {
#line 3271
    if (cp) {
      {
#line 3272
      tmp___6 = sscanf((char const   */* __restrict  */)cp, (char const   */* __restrict  */)"%d",
                       & c);
      }
#line 3272
      if (1 == tmp___6) {
#line 3273
        opts.lunhex = c;
      }
    }
  }
#line 3275
  if (opts.transport > 0) {
#line 3275
    if (1 == opts.long_opt) {
      {
#line 3277
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"please \'--list\' (rather than \'--long\') with --transport\n");
      }
#line 3279
      return (1);
    } else
#line 3275
    if (2 == opts.long_opt) {
      {
#line 3277
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"please \'--list\' (rather than \'--long\') with --transport\n");
      }
#line 3279
      return (1);
    }
  }
#line 3281
  if (opts.verbose > 1) {
    {
#line 3282
    printf((char const   */* __restrict  */)" sysfsroot: %s\n", sysfsroot);
    }
  }
#line 3284
  if (do_hosts) {
    {
#line 3285
    list_hosts((struct lsscsi_opt_coll  const  *)(& opts));
    }
  } else
#line 3286
  if (do_sdevices) {
    {
#line 3287
    list_sdevices((struct lsscsi_opt_coll  const  *)(& opts));
    }
  }
  {
#line 3289
  free_dev_node_list();
  }
#line 3291
  return (0);
}
}
