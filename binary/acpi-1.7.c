/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 104 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 51 "/home/june/collector/temp/acpi-1.7/acpi.h"
struct device {
   int type ;
   char *proc ;
   char *sys ;
   char *sys_dev ;
};
#line 59
struct list;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 23 "/home/june/collector/temp/acpi-1.7/list.h"
struct list {
   void *data ;
   struct list *next ;
};
#line 28 "/home/june/collector/temp/acpi-1.7/list.h"
struct field {
   char *attr ;
   char *value ;
};
#line 119 "/home/june/collector/temp/acpi-1.7/acpi.c"
struct file_list {
   char *file ;
   char *attr ;
};
#line 486 "/home/june/collector/temp/acpi-1.7/acpi.c"
struct __anonstruct_trip_29 {
   float trip_temp ;
   char *trip_type ;
};
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 483 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 176 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 173
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long)(int ___argc ,
                                                                                  char * const  *___argv ,
                                                                                  char const   *__shortopts ,
                                                                                  struct option  const  *__longopts ,
                                                                                  int *__longind ) ;
#line 51 "/home/june/collector/temp/acpi-1.7/acpi.h"
struct device device[4] ;
#line 59
struct list *find_devices(char *acpi_path , int device_nr , int proc_interface ) ;
#line 61
void free_devices(struct list *devices ) ;
#line 63
void print_battery_information(struct list *batteries , int show_empty_slots , int show_capacity ) ;
#line 65
void print_ac_adapter_information(struct list *ac_adapters , int show_empty_slots ) ;
#line 67
void print_thermal_information(struct list *thermal , int show_empty_slots , int temp_units ,
                               int show_trip_points ) ;
#line 69
void print_cooling_information(struct list *cooling , int show_empty_slots ) ;
#line 28 "/home/june/collector/temp/acpi-1.7/main.c"
struct device device[4]  = {      {0, (char *)"battery", (char *)"power_supply", (char *)"BAT"}, 
        {1, (char *)"ac_adapter", (char *)"power_supply", (char *)"AC"}, 
        {2, (char *)"thermal_zone", (char *)"thermal", (char *)"thermal_zone"}, 
        {3, (char *)"fan", (char *)"thermal", (char *)"cooling_device"}};
#line 35 "/home/june/collector/temp/acpi-1.7/main.c"
static void do_show_batteries(char *acpi_path , int show_empty_slots , int show_details ,
                              int proc_interface ) 
{ 
  struct list *batteries ;

  {
  {
#line 39
  batteries = find_devices(acpi_path, 0, proc_interface);
#line 40
  print_battery_information(batteries, show_empty_slots, show_details);
#line 41
  free_devices(batteries);
  }
#line 42
  return;
}
}
#line 44 "/home/june/collector/temp/acpi-1.7/main.c"
static void do_show_ac_adapter(char *acpi_path , int show_empty_slots , int proc_interface ) 
{ 
  struct list *ac_adapter ;

  {
  {
#line 48
  ac_adapter = find_devices(acpi_path, 1, proc_interface);
#line 49
  print_ac_adapter_information(ac_adapter, show_empty_slots);
#line 50
  free_devices(ac_adapter);
  }
#line 51
  return;
}
}
#line 53 "/home/june/collector/temp/acpi-1.7/main.c"
static void do_show_thermal(char *acpi_path , int show_empty_slots , int temperature_units ,
                            int show_details , int proc_interface ) 
{ 
  struct list *thermal ;

  {
  {
#line 56
  thermal = find_devices(acpi_path, 2, proc_interface);
#line 57
  print_thermal_information(thermal, show_empty_slots, temperature_units, show_details);
#line 58
  free_devices(thermal);
  }
#line 59
  return;
}
}
#line 61 "/home/june/collector/temp/acpi-1.7/main.c"
static void do_show_cooling(char *acpi_path , int show_empty_slots , int proc_interface ) 
{ 
  struct list *cooling ;

  {
  {
#line 64
  cooling = find_devices(acpi_path, 3, proc_interface);
#line 65
  print_cooling_information(cooling, show_empty_slots);
#line 66
  free_devices(cooling);
  }
#line 67
  return;
}
}
#line 69 "/home/june/collector/temp/acpi-1.7/main.c"
static int version(void) 
{ 


  {
  {
#line 71
  printf((char const   */* __restrict  */)"acpi 1.7\n\nCopyright (C) 2001 Grahame Bowland.\n              2008-2012 Michael Meskes.\nThis is free software; see the source for copying conditions.  There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n");
  }
#line 78
  return (1);
}
}
#line 81 "/home/june/collector/temp/acpi-1.7/main.c"
static int usage(char **argv ) 
{ 


  {
  {
#line 83
  printf((char const   */* __restrict  */)"Usage: acpi [OPTION]...\nShows information from the /proc filesystem, such as battery status or\nthermal information.\n\n  -b, --battery            battery information\n  -i, --details            show additional details if available:\n                             - battery capacity information\n                             - temperature trip points\n  -a, --ac-adapter         ac adapter information\n  -t, --thermal            thermal information\n  -c, --cooling            cooling information\n  -V, --everything         show every device, overrides above options\n  -s, --show-empty         show non-operational devices\n  -f, --fahrenheit         use fahrenheit as the temperature unit\n  -k, --kelvin             use kelvin as the temperature unit\n  -d, --directory <dir>    path to ACPI info (/sys/class resp. /proc/acpi)\n  -p, --proc               use old proc interface instead of new sys interface\n  -h, --help               display this help and exit\n  -v, --version            output version information and exit\n\nBy default, acpi displays information on installed system batteries.\nNon-operational devices, for example empty battery slots are hidden.\nThe default unit of temperature is degrees celsius.\n\nReport bugs to Michael Meskes <meskes@debian.org>.\n");
  }
#line 110
  return (1);
}
}
#line 113 "/home/june/collector/temp/acpi-1.7/main.c"
static struct option long_options[15]  = 
#line 113
  {      {"help", 0, (int *)0, 'h'}, 
        {"version", 0, (int *)0, 'v'}, 
        {"verbose", 0, (int *)0, 'V'}, 
        {"battery", 0, (int *)0, 'b'}, 
        {"ac-adapter", 0, (int *)0, 'a'}, 
        {"thermal", 0, (int *)0, 't'}, 
        {"cooling", 0, (int *)0, 'c'}, 
        {"show-empty", 0, (int *)0, 's'}, 
        {"fahrenheit", 0, (int *)0, 'f'}, 
        {"kelvin", 0, (int *)0, 'k'}, 
        {"directory", 1, (int *)0, 'd'}, 
        {"everything", 0, (int *)0, 'V'}, 
        {"proc", 0, (int *)0, 'p'}, 
        {"details", 0, (int *)0, 'i'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 131 "/home/june/collector/temp/acpi-1.7/main.c"
int main(int argc , char **argv ) 
{ 
  int show_batteries ;
  int show_ac_adapter ;
  int show_thermal ;
  int show_cooling ;
  int show_empty_slots ;
  int show_details ;
  int proc_interface ;
  int temperature_units ;
  int ch ;
  int option_index ;
  char *acpi_path ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 133
  show_batteries = 0;
#line 134
  show_ac_adapter = 0;
#line 135
  show_thermal = 0;
#line 136
  show_cooling = 0;
#line 137
  show_empty_slots = 0;
#line 138
  show_details = 0;
#line 139
  proc_interface = 0;
#line 140
  temperature_units = 1;
#line 142
  tmp = strdup("/sys/class");
#line 142
  acpi_path = tmp;
  }
#line 144
  if (! acpi_path) {
    {
#line 145
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of memory in main()\n");
    }
#line 146
    return (-1);
  }
  {
#line 149
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 149
    ch = getopt_long(argc, (char * const  *)argv, "ipVbtashvfkcd:", (struct option  const  *)(long_options),
                     & option_index);
    }
#line 149
    if (! (ch != -1)) {
#line 149
      goto while_break;
    }
    {
#line 151
    if (ch == 86) {
#line 151
      goto case_86;
    }
#line 154
    if (ch == 98) {
#line 154
      goto case_98;
    }
#line 157
    if (ch == 97) {
#line 157
      goto case_97;
    }
#line 160
    if (ch == 116) {
#line 160
      goto case_116;
    }
#line 163
    if (ch == 99) {
#line 163
      goto case_99;
    }
#line 166
    if (ch == 115) {
#line 166
      goto case_115;
    }
#line 169
    if (ch == 105) {
#line 169
      goto case_105;
    }
#line 172
    if (ch == 118) {
#line 172
      goto case_118;
    }
#line 175
    if (ch == 102) {
#line 175
      goto case_102;
    }
#line 178
    if (ch == 107) {
#line 178
      goto case_107;
    }
#line 181
    if (ch == 112) {
#line 181
      goto case_112;
    }
#line 190
    if (ch == 100) {
#line 190
      goto case_100;
    }
#line 199
    goto switch_default;
    case_86: /* CIL Label */ 
#line 152
    show_details = 1;
#line 152
    show_cooling = show_details;
#line 152
    show_thermal = show_cooling;
#line 152
    show_ac_adapter = show_thermal;
#line 152
    show_batteries = show_ac_adapter;
#line 153
    goto switch_break;
    case_98: /* CIL Label */ 
#line 155
    show_batteries = 1;
#line 156
    goto switch_break;
    case_97: /* CIL Label */ 
#line 158
    show_ac_adapter = 1;
#line 159
    goto switch_break;
    case_116: /* CIL Label */ 
#line 161
    show_thermal = 1;
#line 162
    goto switch_break;
    case_99: /* CIL Label */ 
#line 164
    show_cooling = 1;
#line 165
    goto switch_break;
    case_115: /* CIL Label */ 
#line 167
    show_empty_slots = 1;
#line 168
    goto switch_break;
    case_105: /* CIL Label */ 
#line 170
    show_details = 1;
#line 171
    goto switch_break;
    case_118: /* CIL Label */ 
    {
#line 173
    tmp___0 = version();
    }
#line 173
    return (tmp___0);
#line 174
    goto switch_break;
    case_102: /* CIL Label */ 
#line 176
    temperature_units = 2;
#line 177
    goto switch_break;
    case_107: /* CIL Label */ 
#line 179
    temperature_units = 0;
#line 180
    goto switch_break;
    case_112: /* CIL Label */ 
    {
#line 182
    proc_interface = 1;
#line 183
    free((void *)acpi_path);
#line 184
    acpi_path = strdup("/proc/acpi");
    }
#line 185
    if (! acpi_path) {
      {
#line 186
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of memory in main()\n");
      }
#line 187
      return (-1);
    }
#line 189
    goto switch_break;
    case_100: /* CIL Label */ 
    {
#line 191
    free((void *)acpi_path);
#line 192
    acpi_path = strdup((char const   *)optarg);
    }
#line 193
    if (! acpi_path) {
      {
#line 194
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of memory in main()\n");
      }
#line 195
      return (-1);
    }
#line 197
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 200
    tmp___1 = usage(argv);
    }
#line 200
    return (tmp___1);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 205
  if (! show_batteries) {
#line 205
    if (! show_ac_adapter) {
#line 205
      if (! show_thermal) {
#line 205
        if (! show_cooling) {
#line 206
          show_batteries = 1;
        }
      }
    }
  }
#line 208
  if (show_batteries) {
    {
#line 209
    do_show_batteries(acpi_path, show_empty_slots, show_details, proc_interface);
    }
  }
#line 211
  if (show_ac_adapter) {
    {
#line 212
    do_show_ac_adapter(acpi_path, show_empty_slots, proc_interface);
    }
  }
#line 214
  if (show_thermal) {
    {
#line 215
    do_show_thermal(acpi_path, show_empty_slots, temperature_units, show_details,
                    proc_interface);
    }
  }
#line 217
  if (show_cooling) {
    {
#line 218
    do_show_cooling(acpi_path, show_empty_slots, proc_interface);
    }
  }
#line 220
  return (0);
}
}
#line 497 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 162
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 45 "/home/june/collector/temp/acpi-1.7/list.h"
struct list *list_append(struct list *node , void *data ) ;
#line 52
struct list *list_next(struct list *node ) ;
#line 66
void list_free(struct list *node ) ;
#line 44 "/home/june/collector/temp/acpi-1.7/acpi.c"
static int ignore_directory_entry(struct dirent *de ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 46
  tmp = strcmp((char const   *)(de->d_name), ".");
  }
#line 46
  if (tmp) {
    {
#line 46
    tmp___0 = strcmp((char const   *)(de->d_name), "..");
    }
#line 46
    if (tmp___0) {
#line 46
      tmp___1 = 0;
    } else {
#line 46
      tmp___1 = 1;
    }
  } else {
#line 46
    tmp___1 = 1;
  }
#line 46
  return (tmp___1);
}
}
#line 49 "/home/june/collector/temp/acpi-1.7/acpi.c"
static struct field *parse_field(char *buf , char *given_attr ) 
{ 
  struct field *rval ;
  char *p ;
  char *attr ;
  char *value ;
  int has_attr ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;

  {
  {
#line 55
  has_attr = 0;
#line 57
  tmp = calloc((size_t )1024, sizeof(char ));
#line 57
  attr = (char *)tmp;
#line 58
  tmp___0 = calloc((size_t )1024, sizeof(char ));
#line 58
  value = (char *)tmp___0;
#line 59
  tmp___1 = malloc(sizeof(struct field ));
#line 59
  rval = (struct field *)tmp___1;
  }
#line 60
  if (! rval) {
    {
#line 61
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of memory. Could not allocate memory in parse_field.\n");
#line 62
    exit(1);
    }
  } else
#line 60
  if (! attr) {
    {
#line 61
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of memory. Could not allocate memory in parse_field.\n");
#line 62
    exit(1);
    }
  } else
#line 60
  if (! value) {
    {
#line 61
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of memory. Could not allocate memory in parse_field.\n");
#line 62
    exit(1);
    }
  }
#line 65
  p = buf;
#line 66
  if (! given_attr) {
    {
#line 67
    while (1) {
      while_continue: /* CIL Label */ ;
#line 67
      tmp___2 = p;
#line 67
      p ++;
#line 67
      if (! *tmp___2) {
#line 67
        goto while_break;
      }
#line 68
      if ((int )*p == 58) {
        {
#line 69
        strncpy((char */* __restrict  */)attr, (char const   */* __restrict  */)buf,
                (size_t )(p - buf));
#line 70
        has_attr = 1;
        }
#line 71
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 74
    if (! has_attr) {
      {
#line 75
      free((void *)attr);
#line 76
      free((void *)value);
#line 77
      free((void *)rval);
      }
#line 78
      return ((struct field *)((void *)0));
    }
#line 80
    if ((int )*p == 32) {
#line 81
      p ++;
    }
    {
#line 82
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 82
      tmp___3 = p;
#line 82
      p ++;
#line 82
      if (! *tmp___3) {
#line 82
        goto while_break___0;
      }
#line 83
      if ((int )*p != 32) {
#line 84
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
    {
#line 87
    strncpy((char */* __restrict  */)attr, (char const   */* __restrict  */)given_attr,
            (size_t )1024);
    }
  }
  {
#line 89
  strncpy((char */* __restrict  */)value, (char const   */* __restrict  */)p, (size_t )1024);
#line 90
  tmp___5 = strlen((char const   *)attr);
  }
#line 90
  if ((int )*(attr + (tmp___5 - 1UL)) == 10) {
    {
#line 91
    tmp___4 = strlen((char const   *)attr);
#line 91
    *(attr + (tmp___4 - 1UL)) = (char )'\000';
    }
  }
  {
#line 92
  tmp___7 = strlen((char const   *)value);
  }
#line 92
  if ((int )*(value + (tmp___7 - 1UL)) == 10) {
    {
#line 93
    tmp___6 = strlen((char const   *)value);
#line 93
    *(value + (tmp___6 - 1UL)) = (char )'\000';
    }
  }
#line 94
  rval->attr = attr;
#line 95
  rval->value = value;
#line 96
  return (rval);
}
}
#line 99 "/home/june/collector/temp/acpi-1.7/acpi.c"
static struct list *parse_info_file(struct list *l , char *filename , char *given_attr ) 
{ 
  FILE *fd ;
  char buf[1024] ;
  struct field *f ;
  char *tmp ;

  {
  {
#line 104
  fd = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 105
  if (! fd) {
#line 106
    return (l);
  }
  {
#line 108
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 108
    tmp = fgets((char */* __restrict  */)(buf), 1024, (FILE */* __restrict  */)fd);
    }
#line 108
    if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 108
      goto while_break;
    }
    {
#line 110
    f = parse_field(buf, given_attr);
    }
#line 111
    if (! f) {
#line 112
      goto while_continue;
    }
    {
#line 113
    l = list_append(l, (void *)f);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 115
  fclose(fd);
  }
#line 116
  return (l);
}
}
#line 124 "/home/june/collector/temp/acpi-1.7/acpi.c"
static struct file_list sys_list[26]  = 
#line 124
  {      {(char *)"current_now", (char *)"current_now"}, 
        {(char *)"power_now", (char *)"power_now"}, 
        {(char *)"charge_now", (char *)"charge_now"}, 
        {(char *)"energy_now", (char *)"energy_now"}, 
        {(char *)"voltage_now", (char *)"voltage_now"}, 
        {(char *)"voltage_min_design", (char *)"voltage_min_design"}, 
        {(char *)"charge_full", (char *)"charge_full"}, 
        {(char *)"energy_full", (char *)"energy_full"}, 
        {(char *)"charge_full_design", (char *)"charge_full_design"}, 
        {(char *)"energy_full_design", (char *)"energy_full_design"}, 
        {(char *)"online", (char *)"online"}, 
        {(char *)"status", (char *)"charging state"}, 
        {(char *)"type", (char *)"type"}, 
        {(char *)"temp", (char *)"sys_temp"}, 
        {(char *)"trip_point_0_type", (char *)"trip_point_0_type"}, 
        {(char *)"trip_point_0_temp", (char *)"trip_point_0_temp"}, 
        {(char *)"trip_point_1_type", (char *)"trip_point_1_type"}, 
        {(char *)"trip_point_1_temp", (char *)"trip_point_1_temp"}, 
        {(char *)"trip_point_2_type", (char *)"trip_point_2_type"}, 
        {(char *)"trip_point_2_temp", (char *)"trip_point_2_temp"}, 
        {(char *)"trip_point_3_type", (char *)"trip_point_3_type"}, 
        {(char *)"trip_point_3_temp", (char *)"trip_point_3_temp"}, 
        {(char *)"trip_point_4_type", (char *)"trip_point_4_type"}, 
        {(char *)"trip_point_4_temp", (char *)"trip_point_4_temp"}, 
        {(char *)"cur_state", (char *)"cur_state"}, 
        {(char *)"max_state", (char *)"max_state"}};
#line 153 "/home/june/collector/temp/acpi-1.7/acpi.c"
static struct file_list proc_list[5]  = {      {(char *)"state", (char *)((void *)0)}, 
        {(char *)"status", (char *)((void *)0)}, 
        {(char *)"info", (char *)((void *)0)}, 
        {(char *)"temperature", (char *)((void *)0)}, 
        {(char *)"cooling_mode", (char *)((void *)0)}};
#line 161 "/home/june/collector/temp/acpi-1.7/acpi.c"
static struct list *get_info(char *device_name , int proc_interface ) 
{ 
  struct list *rval ;
  struct file_list *list ;
  struct file_list *tmp ;
  int i ;
  int n ;
  unsigned long tmp___0 ;
  char *filename ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;

  {
#line 163
  rval = (struct list *)((void *)0);
#line 164
  if (proc_interface) {
#line 164
    tmp = proc_list;
  } else {
#line 164
    tmp = sys_list;
  }
#line 164
  list = tmp;
#line 165
  if (proc_interface) {
#line 165
    tmp___0 = sizeof(proc_list);
  } else {
#line 165
    tmp___0 = sizeof(sys_list);
  }
  {
#line 165
  n = (int )(tmp___0 / sizeof(struct file_list ));
#line 166
  tmp___1 = strlen((char const   *)device_name);
#line 166
  tmp___2 = strlen("/energy_full_design ");
#line 166
  tmp___3 = malloc(tmp___1 + tmp___2);
#line 166
  filename = (char *)tmp___3;
  }
#line 168
  if ((unsigned long )filename == (unsigned long )((void *)0)) {
    {
#line 169
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of memory. Could not allocate memory in get_info.\n");
    }
#line 170
    return ((struct list *)((void *)0));
  }
#line 173
  i = 0;
  {
#line 173
  while (1) {
    while_continue: /* CIL Label */ ;
#line 173
    if (! (i < n)) {
#line 173
      goto while_break;
    }
    {
#line 174
    sprintf((char */* __restrict  */)filename, (char const   */* __restrict  */)"%s/%s",
            device_name, (list + i)->file);
#line 175
    rval = parse_info_file(rval, filename, (list + i)->attr);
#line 173
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 178
  return (rval);
}
}
#line 181 "/home/june/collector/temp/acpi-1.7/acpi.c"
void free_devices(struct list *devices ) 
{ 
  struct list *p ;
  struct list *r ;
  struct list *s ;
  struct field *f ;

  {
#line 186
  p = devices;
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 187
    if (! p) {
#line 187
      goto while_break;
    }
#line 188
    s = (struct list *)p->data;
#line 188
    r = s;
    {
#line 189
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 189
      if (! r) {
#line 189
        goto while_break___0;
      }
      {
#line 190
      f = (struct field *)r->data;
#line 191
      free((void *)f->attr);
#line 192
      free((void *)f->value);
#line 193
      free((void *)f);
#line 194
      r = r->next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 196
    list_free(s);
#line 197
    p = p->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 199
  list_free(devices);
  }
#line 200
  return;
}
}
#line 202 "/home/june/collector/temp/acpi-1.7/acpi.c"
struct list *find_devices(char *acpi_path , int device_nr , int proc_interface ) 
{ 
  DIR *d ;
  struct dirent *de ;
  struct list *device_info ;
  struct list *rval ;
  char *device_type ;
  char *tmp ;
  int found_data ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 208
  rval = (struct list *)((void *)0);
#line 209
  if (proc_interface) {
#line 209
    tmp = device[device_nr].proc;
  } else {
#line 209
    tmp = device[device_nr].sys;
  }
  {
#line 209
  device_type = tmp;
#line 210
  found_data = 0;
#line 212
  tmp___0 = chdir((char const   *)acpi_path);
  }
#line 212
  if (tmp___0 < 0) {
    {
#line 213
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"No ACPI support in kernel, or incorrect acpi_path (\"%s\").\n",
            acpi_path);
#line 214
    exit(1);
    }
  }
  {
#line 217
  tmp___2 = chdir((char const   *)device_type);
  }
#line 217
  if (tmp___2 == 0) {
    {
#line 218
    d = opendir(".");
    }
#line 219
    if (! d) {
#line 220
      return ((struct list *)((void *)0));
    }
    {
#line 222
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 222
      de = readdir(d);
      }
#line 222
      if (! de) {
#line 222
        goto while_break;
      }
      {
#line 223
      tmp___1 = ignore_directory_entry(de);
      }
#line 223
      if (tmp___1) {
#line 224
        goto while_continue;
      }
      {
#line 226
      found_data = 1;
#line 227
      device_info = get_info(de->d_name, proc_interface);
      }
#line 229
      if (device_info) {
        {
#line 230
        rval = list_append(rval, (void *)device_info);
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 232
    closedir(d);
    }
  }
#line 235
  if (! found_data) {
    {
#line 236
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"No support for device type: %s\n",
            device_type);
    }
#line 237
    return ((struct list *)((void *)0));
  }
#line 240
  return (rval);
}
}
#line 243 "/home/june/collector/temp/acpi-1.7/acpi.c"
static int get_unit_value(char *value ) 
{ 
  int n ;

  {
  {
#line 245
  n = -1;
#line 246
  sscanf((char const   */* __restrict  */)value, (char const   */* __restrict  */)"%d",
         & n);
  }
#line 247
  return (n);
}
}
#line 250 "/home/june/collector/temp/acpi-1.7/acpi.c"
void print_battery_information(struct list *batteries , int show_empty_slots , int show_capacity ) 
{ 
  struct list *battery ;
  struct list *fields ;
  struct field *value ;
  int battery_num ;
  int remaining_capacity ;
  int remaining_energy ;
  int present_rate ;
  int voltage ;
  int design_capacity ;
  int design_capacity_unit ;
  int last_capacity ;
  int last_capacity_unit ;
  int hours ;
  int minutes ;
  int seconds ;
  int percentage ;
  char *state ;
  char *poststr ;
  int type_battery ;
  char capacity_unit[4] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;

  {
#line 252
  battery = batteries;
#line 255
  battery_num = 1;
  {
#line 257
  while (1) {
    while_continue: /* CIL Label */ ;
#line 257
    if (! battery) {
#line 257
      goto while_break;
    }
#line 258
    remaining_capacity = -1;
#line 259
    remaining_energy = -1;
#line 260
    present_rate = -1;
#line 261
    voltage = -1;
#line 262
    design_capacity = -1;
#line 263
    design_capacity_unit = -1;
#line 264
    last_capacity = -1;
#line 265
    last_capacity_unit = -1;
#line 268
    state = (char *)((void *)0);
#line 269
    type_battery = 1;
#line 270
    capacity_unit[0] = (char )'m';
#line 270
    capacity_unit[1] = (char )'A';
#line 270
    capacity_unit[2] = (char )'h';
#line 270
    capacity_unit[3] = (char )'\000';
#line 272
    fields = (struct list *)battery->data;
    {
#line 273
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 273
      if (! fields) {
#line 273
        goto while_break___0;
      }
      {
#line 274
      value = (struct field *)fields->data;
#line 275
      tmp___23 = strcasecmp((char const   *)value->attr, "remaining capacity");
      }
#line 275
      if (tmp___23) {
        {
#line 279
        tmp___22 = strcmp((char const   *)value->attr, "charge_now");
        }
#line 279
        if (tmp___22) {
          {
#line 283
          tmp___21 = strcmp((char const   *)value->attr, "energy_now");
          }
#line 283
          if (tmp___21) {
            {
#line 287
            tmp___20 = strcasecmp((char const   *)value->attr, "present rate");
            }
#line 287
            if (tmp___20) {
              {
#line 289
              tmp___19 = strcmp((char const   *)value->attr, "current_now");
              }
#line 289
              if (tmp___19) {
                {
#line 291
                tmp___18 = strcmp((char const   *)value->attr, "power_now");
                }
#line 291
                if (tmp___18) {
                  {
#line 293
                  tmp___17 = strcasecmp((char const   *)value->attr, "last full capacity");
                  }
#line 293
                  if (tmp___17) {
                    {
#line 297
                    tmp___16 = strcmp((char const   *)value->attr, "charge_full");
                    }
#line 297
                    if (tmp___16) {
                      {
#line 301
                      tmp___15 = strcmp((char const   *)value->attr, "energy_full");
                      }
#line 301
                      if (tmp___15) {
                        {
#line 305
                        tmp___14 = strcmp((char const   *)value->attr, "charge_full_design");
                        }
#line 305
                        if (tmp___14) {
                          {
#line 307
                          tmp___13 = strcmp((char const   *)value->attr, "energy_full_design");
                          }
#line 307
                          if (tmp___13) {
                            {
#line 310
                            tmp___12 = strcmp((char const   *)value->attr, "type");
                            }
#line 310
                            if (tmp___12) {
                              {
#line 312
                              tmp___10 = strcmp((char const   *)value->attr, "charging state");
                              }
#line 312
                              if (tmp___10) {
                                {
#line 312
                                tmp___11 = strcmp((char const   *)value->attr, "State");
                                }
#line 312
                                if (tmp___11) {
                                  {
#line 314
                                  tmp___9 = strcmp((char const   *)value->attr, "voltage_now");
                                  }
#line 314
                                  if (! tmp___9) {
                                    {
#line 315
                                    tmp___8 = get_unit_value(value->value);
#line 315
                                    voltage = tmp___8 / 1000;
                                    }
#line 316
                                    if (! voltage) {
#line 317
                                      voltage = -1;
                                    }
                                  }
                                } else {
#line 313
                                  state = value->value;
                                }
                              } else {
#line 313
                                state = value->value;
                              }
                            } else {
                              {
#line 311
                              tmp___7 = strcasecmp((char const   *)value->value, "battery");
#line 311
                              type_battery = tmp___7 == 0;
                              }
                            }
                          } else {
                            {
#line 308
                            tmp___6 = get_unit_value(value->value);
#line 308
                            design_capacity_unit = tmp___6 / 1000;
                            }
                          }
                        } else {
                          {
#line 306
                          tmp___5 = get_unit_value(value->value);
#line 306
                          design_capacity = tmp___5 / 1000;
                          }
                        }
                      } else {
                        {
#line 302
                        tmp___4 = get_unit_value(value->value);
#line 302
                        last_capacity_unit = tmp___4 / 1000;
                        }
#line 303
                        if (! state) {
                          {
#line 304
                          state = strdup("available");
                          }
                        }
                      }
                    } else {
                      {
#line 298
                      tmp___3 = get_unit_value(value->value);
#line 298
                      last_capacity = tmp___3 / 1000;
                      }
#line 299
                      if (! state) {
                        {
#line 300
                        state = strdup("available");
                        }
                      }
                    }
                  } else {
                    {
#line 294
                    last_capacity = get_unit_value(value->value);
                    }
#line 295
                    if (! state) {
                      {
#line 296
                      state = strdup("available");
                      }
                    }
                  }
                } else {
                  {
#line 292
                  tmp___2 = get_unit_value(value->value);
#line 292
                  present_rate = tmp___2 / 1000;
                  }
                }
              } else {
                {
#line 290
                tmp___1 = get_unit_value(value->value);
#line 290
                present_rate = tmp___1 / 1000;
                }
              }
            } else {
              {
#line 288
              present_rate = get_unit_value(value->value);
              }
            }
          } else {
            {
#line 284
            tmp___0 = get_unit_value(value->value);
#line 284
            remaining_energy = tmp___0 / 1000;
            }
#line 285
            if (! state) {
              {
#line 286
              state = strdup("available");
              }
            }
          }
        } else {
          {
#line 280
          tmp = get_unit_value(value->value);
#line 280
          remaining_capacity = tmp / 1000;
          }
#line 281
          if (! state) {
            {
#line 282
            state = strdup("available");
            }
          }
        }
      } else {
        {
#line 276
        remaining_capacity = get_unit_value(value->value);
        }
#line 277
        if (! state) {
          {
#line 278
          state = strdup("available");
          }
        }
      }
      {
#line 319
      fields = list_next(fields);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 321
    if (type_battery) {
#line 322
      if (! state) {
#line 323
        if (show_empty_slots) {
          {
#line 324
          printf((char const   */* __restrict  */)"%s %d: slot empty\n", "Battery",
                 battery_num - 1);
          }
        }
      } else {
#line 327
        if (last_capacity_unit != -1) {
#line 327
          if (last_capacity == -1) {
#line 328
            if (voltage != -1) {
#line 329
              last_capacity = (last_capacity_unit * 1000) / voltage;
            } else {
              {
#line 331
              last_capacity = last_capacity_unit;
#line 332
              strcpy((char */* __restrict  */)(capacity_unit), (char const   */* __restrict  */)"mWh");
              }
            }
          }
        }
#line 335
        if (design_capacity_unit != -1) {
#line 335
          if (design_capacity == -1) {
#line 336
            if (voltage != -1) {
#line 337
              design_capacity = (design_capacity_unit * 1000) / voltage;
            } else {
              {
#line 339
              design_capacity = design_capacity_unit;
#line 340
              strcpy((char */* __restrict  */)(capacity_unit), (char const   */* __restrict  */)"mWh");
              }
            }
          }
        }
#line 343
        if (remaining_energy != -1) {
#line 343
          if (remaining_capacity == -1) {
#line 344
            if (voltage != -1) {
#line 345
              remaining_capacity = (remaining_energy * 1000) / voltage;
#line 346
              present_rate = (present_rate * 1000) / voltage;
            } else {
#line 348
              remaining_capacity = remaining_energy;
            }
          }
        }
#line 351
        if ((double )last_capacity < 0.01) {
#line 352
          percentage = 0;
        } else {
#line 354
          percentage = (remaining_capacity * 100) / last_capacity;
        }
#line 356
        if (percentage > 100) {
#line 357
          percentage = 100;
        }
        {
#line 359
        printf((char const   */* __restrict  */)"%s %d: %s, %d%%", "Battery", battery_num - 1,
               state, percentage);
        }
#line 361
        if (present_rate == -1) {
#line 362
          poststr = (char *)"rate information unavailable";
#line 363
          seconds = -1;
        } else {
          {
#line 364
          tmp___25 = strcasecmp((char const   *)state, "charging");
          }
#line 364
          if (tmp___25) {
            {
#line 372
            tmp___24 = strcasecmp((char const   *)state, "discharging");
            }
#line 372
            if (tmp___24) {
#line 381
              poststr = (char *)((void *)0);
#line 382
              seconds = -1;
            } else
#line 373
            if ((double )present_rate > 0.01) {
#line 374
              seconds = (3600 * remaining_capacity) / present_rate;
#line 375
              poststr = (char *)" remaining";
            } else {
#line 377
              poststr = (char *)"discharging at zero rate - will never fully discharge.";
#line 378
              seconds = -1;
            }
          } else
#line 365
          if ((double )present_rate > 0.01) {
#line 366
            seconds = (3600 * (last_capacity - remaining_capacity)) / present_rate;
#line 367
            poststr = (char *)" until charged";
          } else {
#line 369
            poststr = (char *)"charging at zero rate - will never fully charge.";
#line 370
            seconds = -1;
          }
        }
#line 385
        if (seconds > 0) {
          {
#line 386
          hours = seconds / 3600;
#line 387
          seconds -= 3600 * hours;
#line 388
          minutes = seconds / 60;
#line 389
          seconds -= 60 * minutes;
#line 390
          printf((char const   */* __restrict  */)", %02d:%02d:%02d%s", hours, minutes,
                 seconds, poststr);
          }
        } else
#line 391
        if ((unsigned long )poststr != (unsigned long )((void *)0)) {
          {
#line 392
          printf((char const   */* __restrict  */)", %s", poststr);
          }
        }
        {
#line 395
        printf((char const   */* __restrict  */)"\n");
        }
#line 397
        if (show_capacity) {
#line 397
          if (design_capacity > 0) {
#line 398
            if (last_capacity <= 100) {
#line 400
              percentage = last_capacity;
#line 401
              last_capacity = (percentage * design_capacity) / 100;
            } else {
#line 403
              percentage = (last_capacity * 100) / design_capacity;
            }
#line 405
            if (percentage > 100) {
#line 406
              percentage = 100;
            }
            {
#line 408
            printf((char const   */* __restrict  */)"%s %d: design capacity %d %s, last full capacity %d %s = %d%%\n",
                   "Battery", battery_num - 1, design_capacity, capacity_unit, last_capacity,
                   capacity_unit, percentage);
            }
          }
        }
      }
#line 412
      battery_num ++;
    }
    {
#line 414
    battery = list_next(battery);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 416
  return;
}
}
#line 418 "/home/june/collector/temp/acpi-1.7/acpi.c"
void print_ac_adapter_information(struct list *ac_adapters , int show_empty_slots ) 
{ 
  struct list *adapter ;
  struct list *fields ;
  struct field *value ;
  int adapter_num ;
  char *state ;
  int type_ac ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 420
  adapter = ac_adapters;
#line 423
  adapter_num = 1;
  {
#line 425
  while (1) {
    while_continue: /* CIL Label */ ;
#line 425
    if (! adapter) {
#line 425
      goto while_break;
    }
#line 426
    state = (char *)((void *)0);
#line 427
    type_ac = 1;
#line 429
    fields = (struct list *)adapter->data;
    {
#line 430
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 430
      if (! fields) {
#line 430
        goto while_break___0;
      }
      {
#line 431
      value = (struct field *)fields->data;
#line 432
      tmp___4 = strcmp((char const   *)value->attr, "state");
      }
#line 432
      if (tmp___4) {
        {
#line 432
        tmp___5 = strcmp((char const   *)value->attr, "status");
        }
#line 432
        if (tmp___5) {
          {
#line 434
          tmp___3 = strcmp((char const   *)value->attr, "online");
          }
#line 434
          if (tmp___3) {
            {
#line 436
            tmp___2 = strcmp((char const   *)value->attr, "type");
            }
#line 436
            if (! tmp___2) {
              {
#line 437
              tmp___1 = strcasecmp((char const   *)value->value, "mains");
#line 437
              type_ac = tmp___1 == 0;
              }
            }
          } else {
            {
#line 435
            tmp___0 = get_unit_value(value->value);
            }
#line 435
            if (tmp___0) {
#line 435
              state = (char *)"on-line";
            } else {
#line 435
              state = (char *)"off-line";
            }
          }
        } else {
#line 433
          state = value->value;
        }
      } else {
#line 433
        state = value->value;
      }
      {
#line 439
      fields = list_next(fields);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 441
    if (type_ac) {
#line 442
      if (! state) {
#line 443
        if (show_empty_slots) {
          {
#line 444
          printf((char const   */* __restrict  */)"%s %d: slot empty\n", "Adapter",
                 adapter_num - 1);
          }
        }
      } else {
        {
#line 446
        printf((char const   */* __restrict  */)"%s %d: %s\n", "Adapter", adapter_num - 1,
               state);
        }
      }
#line 449
      adapter_num ++;
    }
    {
#line 451
    adapter = list_next(adapter);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 453
  return;
}
}
#line 455 "/home/june/collector/temp/acpi-1.7/acpi.c"
static double get_real_temp(float temperature , char **scale , int temp_units ) 
{ 
  double real_temp ;

  {
#line 457
  real_temp = (double )temperature;
  {
#line 460
  if (temp_units == 1) {
#line 460
    goto case_1;
  }
#line 463
  if (temp_units == 2) {
#line 463
    goto case_2;
  }
#line 468
  goto switch_default;
  case_1: /* CIL Label */ 
#line 461
  *scale = (char *)"degrees C";
#line 462
  goto switch_break;
  case_2: /* CIL Label */ 
#line 464
  real_temp = real_temp * 1.8 + (double )32;
#line 465
  *scale = (char *)"degrees F";
#line 466
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 469
  real_temp += 273.1;
#line 470
  *scale = (char *)"kelvin";
#line 471
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 473
  return (real_temp);
}
}
#line 476 "/home/june/collector/temp/acpi-1.7/acpi.c"
void print_thermal_information(struct list *thermal , int show_empty_slots , int temp_units ,
                               int show_trip_points ) 
{ 
  struct list *sensor ;
  struct list *fields ;
  struct field *value ;
  int sensor_num ;
  int type_zone ;
  float temperature ;
  struct __anonstruct_trip_29 trip[5] ;
  char str[20] ;
  char *state ;
  char *scale ;
  double real_temp ;
  int i ;
  int trip_points ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 478
  sensor = thermal;
#line 481
  sensor_num = 1;
#line 482
  type_zone = 1;
  {
#line 484
  while (1) {
    while_continue: /* CIL Label */ ;
#line 484
    if (! sensor) {
#line 484
      goto while_break;
    }
    {
#line 485
    temperature = (float )-1;
#line 490
    str[0] = (char )'t';
#line 490
    str[1] = (char )'r';
#line 490
    str[2] = (char )'i';
#line 490
    str[3] = (char )'p';
#line 490
    str[4] = (char )'_';
#line 490
    str[5] = (char )'p';
#line 490
    str[6] = (char )'o';
#line 490
    str[7] = (char )'i';
#line 490
    str[8] = (char )'n';
#line 490
    str[9] = (char )'t';
#line 490
    str[10] = (char )'_';
#line 490
    str[11] = (char )'1';
#line 490
    str[12] = (char )'2';
#line 490
    str[13] = (char )'3';
#line 490
    str[14] = (char )'_';
#line 490
    str[15] = (char )'t';
#line 490
    str[16] = (char )'y';
#line 490
    str[17] = (char )'p';
#line 490
    str[18] = (char )'e';
#line 490
    str[19] = (char )'\000';
#line 491
    state = (char *)((void *)0);
#line 493
    trip_points = -1;
#line 495
    memset((void *)(trip), 0, sizeof(trip));
#line 496
    fields = (struct list *)sensor->data;
    }
    {
#line 497
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 497
      if (! fields) {
#line 497
        goto while_break___0;
      }
      {
#line 498
      value = (struct field *)fields->data;
#line 499
      tmp___11 = strcmp((char const   *)value->attr, "state");
      }
#line 499
      if (tmp___11) {
        {
#line 501
        tmp___10 = strcmp((char const   *)value->attr, "type");
        }
#line 501
        if (tmp___10) {
          {
#line 505
          tmp___9 = strcmp((char const   *)value->attr, "temperature");
          }
#line 505
          if (tmp___9) {
            {
#line 511
            tmp___8 = strcmp((char const   *)value->attr, "sys_temp");
            }
#line 511
            if (tmp___8) {
#line 516
              i = 0;
              {
#line 516
              while (1) {
                while_continue___1: /* CIL Label */ ;
#line 516
                if (! (i < 5)) {
#line 516
                  goto while_break___1;
                }
                {
#line 518
                sprintf((char */* __restrict  */)(str), (char const   */* __restrict  */)"trip_point_%d_temp",
                        i);
#line 519
                tmp___6 = strcmp((char const   *)value->attr, (char const   *)(str));
                }
#line 519
                if (! tmp___6) {
                  {
#line 520
                  tmp___5 = get_unit_value(value->value);
#line 520
                  trip[i].trip_temp = (float )((double )tmp___5 / 1000.0);
                  }
                }
                {
#line 522
                sprintf((char */* __restrict  */)(str), (char const   */* __restrict  */)"trip_point_%d_type",
                        i);
#line 523
                tmp___7 = strcmp((char const   *)value->attr, (char const   *)(str));
                }
#line 523
                if (! tmp___7) {
#line 524
                  trip[i].trip_type = value->value;
#line 525
                  if (i > trip_points) {
#line 526
                    trip_points = i;
                  }
                }
#line 516
                i ++;
              }
              while_break___1: /* CIL Label */ ;
              }
            } else {
              {
#line 512
              tmp___4 = get_unit_value(value->value);
#line 512
              temperature = (float )((double )tmp___4 / 1000.0);
              }
#line 513
              if (! state) {
                {
#line 514
                state = strdup("ok");
                }
              }
            }
          } else {
            {
#line 506
            tmp___2 = get_unit_value(value->value);
#line 506
            temperature = (float )tmp___2;
#line 507
            tmp___3 = strstr((char const   *)value->value, "dK");
            }
#line 507
            if (tmp___3) {
#line 508
              temperature = (float )((double )(temperature / (float )10) - 273.1);
            }
#line 509
            if (! state) {
              {
#line 510
              state = strdup("ok");
              }
            }
          }
        } else {
          {
#line 502
          tmp = strstr((char const   *)value->value, "thermal zone");
          }
#line 502
          if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 502
            tmp___1 = 1;
          } else {
            {
#line 502
            tmp___0 = strstr((char const   *)value->value, "acpitz");
            }
#line 502
            if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 502
              tmp___1 = 1;
            } else {
#line 502
              tmp___1 = 0;
            }
          }
#line 502
          type_zone = tmp___1;
#line 503
          if (! state) {
            {
#line 504
            state = strdup("ok");
            }
          }
        }
      } else {
#line 500
        state = value->value;
      }
      {
#line 530
      fields = list_next(fields);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 532
    if (type_zone) {
#line 533
      i = 0;
      {
#line 533
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 533
        if (! (i <= trip_points)) {
#line 533
          goto while_break___2;
        }
#line 535
        if (temperature >= trip[i].trip_temp) {
#line 535
          if ((double )trip[i].trip_temp >= 0.01) {
#line 536
            state = trip[i].trip_type;
#line 537
            goto while_break___2;
          }
        }
#line 533
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 540
      if (! state) {
#line 541
        if (show_empty_slots) {
          {
#line 542
          printf((char const   */* __restrict  */)"%s %d: slot empty\n", "Thermal",
                 sensor_num - 1);
          }
        }
      } else {
        {
#line 544
        real_temp = get_real_temp(temperature, & scale, temp_units);
#line 545
        printf((char const   */* __restrict  */)"%s %d: %s, %.1f %s\n", "Thermal",
               sensor_num - 1, state, real_temp, scale);
        }
#line 546
        if (show_trip_points) {
#line 547
          i = 0;
          {
#line 547
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 547
            if (! (i <= trip_points)) {
#line 547
              goto while_break___3;
            }
#line 549
            if ((double )trip[i].trip_temp >= 0.01) {
              {
#line 550
              real_temp = get_real_temp(trip[i].trip_temp, & scale, temp_units);
#line 551
              printf((char const   */* __restrict  */)"%s %d: trip point %d switches to mode %s at temperature %.1f %s\n",
                     "Thermal", sensor_num - 1, i, trip[i].trip_type, real_temp, scale);
              }
            }
#line 547
            i ++;
          }
          while_break___3: /* CIL Label */ ;
          }
        }
      }
#line 557
      sensor_num ++;
    }
    {
#line 559
    sensor = list_next(sensor);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 561
  return;
}
}
#line 563 "/home/june/collector/temp/acpi-1.7/acpi.c"
void print_cooling_information(struct list *cooling , int show_empty_slots ) 
{ 
  struct list *sensor ;
  struct list *fields ;
  struct field *value ;
  int sensor_num ;
  char *state ;
  char *type ;
  int cur_state ;
  int max_state ;
  int type_cooling ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 565
  sensor = cooling;
#line 568
  sensor_num = 1;
  {
#line 570
  while (1) {
    while_continue: /* CIL Label */ ;
#line 570
    if (! sensor) {
#line 570
      goto while_break;
    }
#line 571
    state = (char *)((void *)0);
#line 571
    type = (char *)((void *)0);
#line 572
    cur_state = -1;
#line 572
    max_state = -1;
#line 573
    type_cooling = 1;
#line 575
    fields = (struct list *)sensor->data;
    {
#line 576
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 576
      if (! fields) {
#line 576
        goto while_break___0;
      }
      {
#line 577
      value = (struct field *)fields->data;
#line 578
      tmp___5 = strcmp((char const   *)value->attr, "status");
      }
#line 578
      if (tmp___5) {
        {
#line 580
        tmp___4 = strcmp((char const   *)value->attr, "type");
        }
#line 580
        if (tmp___4) {
          {
#line 583
          tmp___3 = strcmp((char const   *)value->attr, "cur_state");
          }
#line 583
          if (tmp___3) {
            {
#line 585
            tmp___2 = strcmp((char const   *)value->attr, "max_state");
            }
#line 585
            if (! tmp___2) {
              {
#line 586
              max_state = get_unit_value(value->value);
              }
            }
          } else {
            {
#line 584
            cur_state = get_unit_value(value->value);
            }
          }
        } else {
          {
#line 581
          type = value->value;
#line 582
          tmp = strstr((char const   *)type, "thermal zone");
          }
#line 582
          if ((unsigned long )tmp == (unsigned long )((void *)0)) {
            {
#line 582
            tmp___0 = strstr((char const   *)type, "acpitz");
            }
#line 582
            if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 582
              tmp___1 = 1;
            } else {
#line 582
              tmp___1 = 0;
            }
          } else {
#line 582
            tmp___1 = 0;
          }
#line 582
          type_cooling = tmp___1;
        }
      } else {
#line 579
        state = value->value;
      }
      {
#line 588
      fields = list_next(fields);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 590
    if (type_cooling) {
#line 591
      if (! state) {
#line 591
        if (! type) {
#line 592
          if (show_empty_slots) {
            {
#line 593
            printf((char const   */* __restrict  */)"%s %d: slot empty\n", "Cooling",
                   sensor_num - 1);
            }
          }
        } else {
#line 591
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 594
      if (state) {
        {
#line 595
        printf((char const   */* __restrict  */)"%s %d: %s\n", "Cooling", sensor_num - 1,
               state);
        }
      } else
#line 596
      if (cur_state < 0) {
        {
#line 597
        printf((char const   */* __restrict  */)"%s %d: %s no state information available\n",
               "Cooling", sensor_num - 1, type);
        }
      } else
#line 596
      if (max_state < 0) {
        {
#line 597
        printf((char const   */* __restrict  */)"%s %d: %s no state information available\n",
               "Cooling", sensor_num - 1, type);
        }
      } else {
        {
#line 599
        printf((char const   */* __restrict  */)"%s %d: %s %d of %d\n", "Cooling",
               sensor_num - 1, type, cur_state, max_state);
        }
      }
#line 602
      sensor_num ++;
    }
    {
#line 605
    sensor = list_next(sensor);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 607
  return;
}
}
#line 38 "/home/june/collector/temp/acpi-1.7/list.h"
struct list *list_new(void *data ) ;
#line 59
unsigned int list_length(struct list *node ) ;
#line 24 "/home/june/collector/temp/acpi-1.7/list.c"
struct list *list_new(void *data ) 
{ 
  struct list *r ;
  void *tmp ;

  {
  {
#line 28
  tmp = malloc(sizeof(struct list ));
#line 28
  r = (struct list *)tmp;
  }
#line 29
  if (! r) {
    {
#line 30
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of memory. Could not allocate memory in list_new_node.\n");
#line 31
    exit(1);
    }
  }
#line 33
  r->data = data;
#line 34
  r->next = (struct list *)((void *)0);
#line 35
  return (r);
}
}
#line 38 "/home/june/collector/temp/acpi-1.7/list.c"
struct list *list_append(struct list *node , void *data ) 
{ 
  struct list *r ;

  {
  {
#line 42
  r = list_new(data);
#line 43
  r->next = node;
  }
#line 44
  return (r);
}
}
#line 47 "/home/june/collector/temp/acpi-1.7/list.c"
struct list *list_next(struct list *node ) 
{ 


  {
#line 49
  return (node->next);
}
}
#line 52 "/home/june/collector/temp/acpi-1.7/list.c"
unsigned int list_length(struct list *node ) 
{ 
  unsigned int l ;

  {
#line 54
  l = 0U;
  {
#line 55
  while (1) {
    while_continue: /* CIL Label */ ;
#line 55
    if (! node) {
#line 55
      goto while_break;
    }
#line 56
    l ++;
#line 57
    node = node->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 59
  return (l);
}
}
#line 62 "/home/june/collector/temp/acpi-1.7/list.c"
void list_free(struct list *node ) 
{ 
  struct list *p ;
  struct list *next ;

  {
#line 65
  p = node;
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 66
    if (! p) {
#line 66
      goto while_break;
    }
    {
#line 67
    next = p->next;
#line 68
    free((void *)p);
#line 69
    p = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 71
  return;
}
}
