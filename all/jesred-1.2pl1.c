/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 209 "/usr/include/netinet/in.h"
union __anonunion___in6_u_32 {
   uint8_t __u6_addr8[16] ;
   uint16_t __u6_addr16[8] ;
   uint32_t __u6_addr32[4] ;
};
#line 209 "/usr/include/netinet/in.h"
struct in6_addr {
   union __anonunion___in6_u_32 __in6_u ;
};
#line 43 "/usr/include/regex.h"
typedef unsigned long reg_syntax_t;
#line 368 "/usr/include/regex.h"
struct re_pattern_buffer {
   unsigned char *__buffer ;
   unsigned long __allocated ;
   unsigned long __used ;
   reg_syntax_t __syntax ;
   char *__fastmap ;
   unsigned char *__translate ;
   size_t re_nsub ;
   unsigned int __can_be_null : 1 ;
   unsigned int __regs_allocated : 2 ;
   unsigned int __fastmap_accurate : 1 ;
   unsigned int __no_sub : 1 ;
   unsigned int __not_bol : 1 ;
   unsigned int __not_eol : 1 ;
   unsigned int __newline_anchor : 1 ;
};
#line 434 "/usr/include/regex.h"
typedef struct re_pattern_buffer regex_t;
#line 26 "/home/june/repo/benchmarks/collector/temp/jesred-1.2pl1/log.h"
enum __anonenum_log_code_35 {
    MATCH = 0,
    ERROR = 1,
    DEBG = 2,
    INFO = 3
} ;
#line 26 "/home/june/repo/benchmarks/collector/temp/jesred-1.2pl1/log.h"
typedef enum __anonenum_log_code_35 log_code;
#line 102 "/home/june/repo/benchmarks/collector/temp/jesred-1.2pl1/ip_list.h"
enum __anonenum_ip_access_type_36 {
    IP_ALLOW = 0,
    IP_DENY = 1
} ;
#line 102 "/home/june/repo/benchmarks/collector/temp/jesred-1.2pl1/ip_list.h"
typedef enum __anonenum_ip_access_type_36 ip_access_type;
#line 107 "/home/june/repo/benchmarks/collector/temp/jesred-1.2pl1/ip_list.h"
struct _ip_acl {
   struct in_addr addr ;
   struct in_addr mask ;
   struct in6_addr addr6 ;
   struct in6_addr mask6 ;
   int af ;
   ip_access_type access ;
   struct _ip_acl *next ;
};
#line 107 "/home/june/repo/benchmarks/collector/temp/jesred-1.2pl1/ip_list.h"
typedef struct _ip_acl ip_acl;
#line 39 "/home/june/repo/benchmarks/collector/temp/jesred-1.2pl1/pattern_list.h"
struct _pattern_item {
   char *pattern ;
   char *replacement ;
   char *urlgroup ;
   int case_sensitive ;
   int type ;
   regex_t cpattern ;
   struct _pattern_item *next ;
};
#line 39 "/home/june/repo/benchmarks/collector/temp/jesred-1.2pl1/pattern_list.h"
typedef struct _pattern_item pattern_item;
#line 437 "/usr/include/regex.h"
typedef int regoff_t;
#line 463 "/usr/include/regex.h"
struct __anonstruct_regmatch_t_27 {
   regoff_t rm_so ;
   regoff_t rm_eo ;
};
#line 463 "/usr/include/regex.h"
typedef struct __anonstruct_regmatch_t_27 regmatch_t;
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 98 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 483 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 289
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strspn)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 33 "/home/june/repo/benchmarks/collector/temp/jesred-1.2pl1/log.h"
void mylog(log_code c , char *format  , ...) ;
#line 29 "/home/june/repo/benchmarks/collector/temp/jesred-1.2pl1/main.h"
int echo_mode ;
#line 34
int allow_siblings ;
#line 119 "/home/june/repo/benchmarks/collector/temp/jesred-1.2pl1/ip_list.h"
void addToIPACL(ip_acl **list , char const   *ip_str ) ;
#line 54 "/home/june/repo/benchmarks/collector/temp/jesred-1.2pl1/pattern_list.h"
void add_to_patterns(char *pattern , pattern_item **plist ) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/jesred-1.2pl1/config.h"
void read_allow(char **file , ip_acl **list ) ;
#line 29
void read_rules(char **file , pattern_item **plist ) ;
#line 30
void read_config(char **allow , char **rules , char **redirect , char **rewrite ) ;
#line 47 "/home/june/repo/benchmarks/collector/temp/jesred-1.2pl1/config.c"
char *CleanLine(char const   *line ) ;
#line 49 "/home/june/repo/benchmarks/collector/temp/jesred-1.2pl1/config.c"
char const   * const  w_space  =    (char const   */* const  */)" \t\n\r";
#line 51 "/home/june/repo/benchmarks/collector/temp/jesred-1.2pl1/config.c"
void read_allow(char **file , ip_acl **list ) 
{ 
  FILE *fd ;
  char *token ;
  char buff[4096] ;
  int *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 54
  token = (char *)((void *)0);
#line 58
  fd = fopen((char const   */* __restrict  */)*file, (char const   */* __restrict  */)"r");
  }
#line 59
  if ((unsigned long )fd == (unsigned long )((void *)0)) {
    {
#line 60
    tmp = __errno_location();
#line 60
    token = strerror(*tmp);
    }
#line 61
    if (*file) {
#line 61
      tmp___0 = (char const   *)*file;
    } else {
#line 61
      tmp___0 = "";
    }
    {
#line 61
    mylog((log_code )1, (char *)"unable to open local addresses file %s: %s\n", tmp___0,
          token);
#line 63
    echo_mode = 1;
    }
#line 64
    return;
  }
  {
#line 67
  mylog((log_code )3, (char *)"Loading IP List from %s\n", *file);
  }
  {
#line 68
  while (1) {
    while_continue: /* CIL Label */ ;
#line 68
    if (! echo_mode) {
      {
#line 68
      tmp___1 = fgets((char */* __restrict  */)(buff), 4096, (FILE */* __restrict  */)fd);
      }
#line 68
      if (! ((unsigned long )tmp___1 != (unsigned long )((void *)0))) {
#line 68
        goto while_break;
      }
    } else {
#line 68
      goto while_break;
    }
    {
#line 69
    token = CleanLine((char const   *)(buff));
    }
#line 70
    if ((unsigned long )token == (unsigned long )((void *)0)) {
#line 71
      goto while_continue;
    }
    {
#line 72
    addToIPACL(list, (char const   *)token);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 74
  fclose(fd);
  }
#line 75
  if (*file) {
    {
#line 75
    free((void *)*file);
#line 75
    *file = (char *)((void *)0);
    }
  }
#line 76
  return;
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/jesred-1.2pl1/config.c"
void read_config(char **allow , char **rules , char **redirect , char **rewrite ) 
{ 
  FILE *fd ;
  char *token ;
  char *token2 ;
  char buff[4096] ;
  int *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;

  {
  {
#line 85
  echo_mode = 0;
#line 86
  allow_siblings = 0;
#line 87
  strcpy((char */* __restrict  */)(buff), (char const   */* __restrict  */)"/etc");
#line 88
  strcat((char */* __restrict  */)(buff), (char const   */* __restrict  */)"/");
#line 89
  strcat((char */* __restrict  */)(buff), (char const   */* __restrict  */)"jesred.conf");
#line 90
  fd = fopen((char const   */* __restrict  */)(buff), (char const   */* __restrict  */)"r");
  }
#line 90
  if ((unsigned long )fd == (unsigned long )((void *)0)) {
    {
#line 91
    tmp = __errno_location();
#line 91
    token = strerror(*tmp);
#line 92
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t open config file %s for reading: %s\nUsing echo mode!!!\n",
            buff, token);
#line 95
    echo_mode ++;
    }
#line 96
    return;
  }
#line 99
  if (*allow) {
    {
#line 99
    free((void *)*allow);
#line 99
    *allow = (char *)((void *)0);
    }
  }
#line 100
  if (*rules) {
    {
#line 100
    free((void *)*rules);
#line 100
    *rules = (char *)((void *)0);
    }
  }
#line 101
  if (*redirect) {
    {
#line 101
    free((void *)*redirect);
#line 101
    *redirect = (char *)((void *)0);
    }
  }
#line 102
  if (*rewrite) {
    {
#line 102
    free((void *)*rewrite);
#line 102
    *rewrite = (char *)((void *)0);
    }
  }
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 103
    tmp___8 = fgets((char */* __restrict  */)(buff), 4096, (FILE */* __restrict  */)fd);
    }
#line 103
    if (! ((unsigned long )tmp___8 != (unsigned long )((void *)0))) {
#line 103
      goto while_break;
    }
    {
#line 104
    token = CleanLine((char const   *)(buff));
    }
#line 105
    if ((unsigned long )token == (unsigned long )((void *)0)) {
#line 106
      goto while_continue;
    }
    {
#line 107
    token2 = strchr((char const   *)token, '=');
    }
#line 108
    if (token2) {
      {
#line 109
      *token2 = (char )'\000';
#line 110
      token = CleanLine((char const   *)token);
      }
#line 111
      if (! token) {
#line 112
        goto while_continue;
      }
      {
#line 113
      token2 ++;
#line 114
      token2 = CleanLine((char const   *)token2);
      }
#line 115
      if (! token2) {
#line 116
        goto while_continue;
      }
      {
#line 117
      tmp___7 = strcasecmp((char const   *)token, "allow");
      }
#line 117
      if (tmp___7) {
        {
#line 119
        tmp___6 = strcasecmp((char const   *)token, "rules");
        }
#line 119
        if (tmp___6) {
          {
#line 121
          tmp___5 = strcasecmp((char const   *)token, "redirect_log");
          }
#line 121
          if (tmp___5) {
            {
#line 123
            tmp___4 = strcasecmp((char const   *)token, "rewrite_log");
            }
#line 123
            if (tmp___4) {
              {
#line 130
              tmp___3 = strcasecmp((char const   *)token, "siblings");
              }
#line 130
              if (tmp___3) {
#line 135
                if (token2) {
#line 135
                  tmp___1 = (char const   *)token2;
                } else {
#line 135
                  tmp___1 = "";
                }
#line 135
                if (token) {
#line 135
                  tmp___2 = (char const   *)token;
                } else {
#line 135
                  tmp___2 = "";
                }
                {
#line 135
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unknown keyword or value \"%s = %s\" - ignored\n",
                        tmp___2, tmp___1);
                }
              } else {
                {
#line 131
                tmp___0 = strcasecmp((char const   *)token2, "true");
                }
#line 131
                if (! tmp___0) {
#line 132
                  allow_siblings ++;
                }
              }
            } else {
              {
#line 124
              *rewrite = strdup((char const   *)token2);
              }
            }
          } else {
            {
#line 122
            *redirect = strdup((char const   *)token2);
            }
          }
        } else {
          {
#line 120
          *rules = strdup((char const   *)token2);
          }
        }
      } else {
        {
#line 118
        *allow = strdup((char const   *)token2);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 140
  fclose(fd);
  }
#line 141
  return;
}
}
#line 144 "/home/june/repo/benchmarks/collector/temp/jesred-1.2pl1/config.c"
char *CleanLine(char const   *line ) 
{ 
  char *token ;
  int i ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 146
  token = (char *)((void *)0);
#line 149
  token = (char *)line;
#line 150
  tmp___0 = strlen(line);
  }
#line 150
  if ((int )*(token + (tmp___0 - 1UL)) == 10) {
    {
#line 151
    tmp = strlen(line);
#line 151
    *(token + (tmp - 1UL)) = (char )'\000';
    }
  }
  {
#line 153
  tmp___1 = strspn(line, (char const   *)w_space);
#line 153
  token += tmp___1;
  }
#line 154
  if ((int )*token == 35) {
#line 155
    return ((char *)((void *)0));
  }
  {
#line 157
  tmp___2 = strlen((char const   *)token);
#line 157
  i = (int )(tmp___2 - 1UL);
  }
  {
#line 157
  while (1) {
    while_continue: /* CIL Label */ ;
#line 157
    if (! (i >= 0)) {
#line 157
      goto while_break;
    }
#line 158
    if ((int )*(token + i) != 32) {
#line 159
      goto while_break;
    } else {
#line 161
      *(token + i) = (char )'\000';
    }
#line 157
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 163
  if ((int )*token == 0) {
#line 164
    return ((char *)((void *)0));
  }
#line 166
  return (token);
}
}
#line 171 "/home/june/repo/benchmarks/collector/temp/jesred-1.2pl1/config.c"
void read_rules(char **file , pattern_item **plist ) 
{ 
  char buff[4096] ;
  FILE *fd ;
  char *token ;
  int *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;

  {
#line 175
  token = (char *)((void *)0);
#line 177
  if (! *file) {
#line 177
    goto _L;
  } else {
    {
#line 177
    fd = fopen((char const   */* __restrict  */)*file, (char const   */* __restrict  */)"rt");
    }
#line 177
    if ((unsigned long )fd == (unsigned long )((void *)0)) {
      _L: /* CIL Label */ 
      {
#line 178
      echo_mode = 1;
#line 179
      tmp = __errno_location();
#line 179
      token = strerror(*tmp);
      }
#line 180
      if (*file) {
#line 180
        tmp___0 = (char const   *)*file;
      } else {
#line 180
        tmp___0 = "";
      }
      {
#line 180
      mylog((log_code )1, (char *)"unable to open redirect patterns file %s: %s\n",
            tmp___0, token);
      }
#line 182
      return;
    }
  }
  {
#line 184
  mylog((log_code )3, (char *)"Reading Patterns from config %s\n", *file);
  }
  {
#line 186
  while (1) {
    while_continue: /* CIL Label */ ;
#line 186
    if (! echo_mode) {
      {
#line 186
      tmp___1 = fgets((char */* __restrict  */)(buff), 4096, (FILE */* __restrict  */)fd);
      }
#line 186
      if (! ((unsigned long )tmp___1 != (unsigned long )((void *)0))) {
#line 186
        goto while_break;
      }
    } else {
#line 186
      goto while_break;
    }
    {
#line 189
    token = CleanLine((char const   *)(buff));
    }
#line 190
    if (! token) {
#line 191
      goto while_continue;
    }
    {
#line 192
    add_to_patterns(token, plist);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 194
  fclose(fd);
  }
#line 195
  if (*file) {
    {
#line 195
    free((void *)*file);
#line 195
    *file = (char *)((void *)0);
    }
  }
#line 196
  return;
}
}
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 34 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) in_addr_t ( __attribute__((__leaf__)) inet_addr)(char const   *__cp ) ;
#line 58
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) inet_pton)(int __af ,
                                                                                char const   * __restrict  __cp ,
                                                                                void * __restrict  __buf ) ;
#line 577 "/usr/include/regex.h"
extern int regexec(regex_t const   * __restrict  __preg , char const   * __restrict  __string ,
                   size_t __nmatch , regmatch_t * __restrict  __pmatch , int __eflags ) ;
#line 120 "/home/june/repo/benchmarks/collector/temp/jesred-1.2pl1/ip_list.h"
ip_access_type ip_access_check(int afamily , void const   *address , ip_acl const   *list ) ;
#line 31 "/home/june/repo/benchmarks/collector/temp/jesred-1.2pl1/rewrite.h"
int parse_buff(char *buff , char **url , char **src_addr , char **ident , char **method ,
               char **urlgroup , ip_acl *ip , pattern_item *p___0 ) ;
#line 52 "/home/june/repo/benchmarks/collector/temp/jesred-1.2pl1/rewrite.c"
int count_parenthesis(char *pattern ) ;
#line 57
int replace_string(pattern_item *curr , char *url , char *buffer ) ;
#line 62 "/home/june/repo/benchmarks/collector/temp/jesred-1.2pl1/rewrite.c"
int parse_buff(char *buff , char **url , char **src_addr , char **ident , char **method ,
               char **urlgroup , ip_acl *ip , pattern_item *p___0 ) 
{ 
  int c ;
  int i ;
  struct in_addr address ;
  struct in6_addr address6 ;
  char *token ;
  char *new_token ;
  char *end[5] ;
  int family ;
  int tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  ip_access_type tmp___6 ;

  {
  {
#line 72
  family = 2;
#line 75
  c = 0;
#line 76
  *urlgroup = (char *)'\000';
#line 78
  token = strchr((char const   *)buff, ' ');
  }
#line 79
  if (token) {
    {
#line 80
    c ++;
#line 81
    *token = (char )'\000';
#line 82
    end[0] = token;
#line 83
    *url = buff;
#line 85
    token ++;
#line 85
    new_token = strchr((char const   *)token, ' ');
    }
#line 86
    if (new_token) {
      {
#line 87
      c ++;
#line 88
      *new_token = (char )'\000';
#line 89
      end[1] = new_token;
#line 90
      *src_addr = token;
#line 92
      new_token ++;
#line 92
      token = strchr((char const   *)new_token, ' ');
      }
#line 93
      if (token) {
        {
#line 94
        c ++;
#line 95
        *token = (char )'\000';
#line 96
        end[2] = token;
#line 97
        *ident = new_token;
#line 113
        token ++;
#line 113
        new_token = strchr((char const   *)token, ' ');
        }
#line 113
        if (! new_token) {
          {
#line 114
          new_token = strchr((char const   *)token, '\n');
          }
        }
#line 115
        if (new_token) {
          {
#line 116
          c ++;
#line 117
          *new_token = (char )'\000';
#line 118
          end[3] = new_token;
#line 119
          *method = token;
#line 122
          new_token ++;
#line 122
          token = strchr((char const   *)new_token, ' ');
          }
#line 122
          if (! token) {
            {
#line 123
            token = strchr((char const   *)new_token, '\n');
            }
          }
#line 124
          if (token) {
            {
#line 126
            c ++;
#line 127
            *token = (char )'\000';
#line 128
            end[4] = token;
#line 134
            tmp = strcmp((char const   *)new_token, "-");
            }
#line 134
            if (tmp) {
              {
#line 134
              tmp___0 = strchr((char const   *)new_token, '=');
              }
#line 134
              if (! tmp___0) {
#line 135
                *urlgroup = new_token;
              }
            }
          }
        }
      }
    }
  }
#line 145
  if (c != 5) {
#line 145
    if (c != 4) {
#line 146
      i = 0;
      {
#line 146
      while (1) {
        while_continue: /* CIL Label */ ;
#line 146
        if (! (i < c)) {
#line 146
          goto while_break;
        }
#line 147
        if (end[i]) {
#line 148
          *(end[i]) = (char )' ';
        }
#line 146
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 150
      mylog((log_code )1, (char *)"incorrect input (%d): %s", c, buff);
      }
#line 151
      return (1);
    }
  }
  {
#line 164
  tmp___2 = strlen((char const   *)*url);
  }
#line 164
  if (tmp___2 <= 7UL) {
    {
#line 165
    tmp___1 = strlen((char const   *)*url);
#line 165
    mylog((log_code )1, (char *)"strlen url to short (%d)\n", tmp___1);
    }
#line 166
    return (1);
  }
  {
#line 170
  token = strchr((char const   *)*src_addr, '/');
  }
#line 171
  if (token) {
#line 172
    *token = (char )'\000';
  }
  {
#line 177
  address.s_addr = inet_addr((char const   *)*src_addr);
  }
#line 177
  if (address.s_addr == 4294967295U) {
    {
#line 180
    tmp___4 = inet_pton(10, (char const   */* __restrict  */)*src_addr, (void */* __restrict  */)(& address6.__in6_u.__u6_addr8));
    }
#line 180
    if (tmp___4) {
#line 189
      family = 10;
    } else {
#line 182
      if (*src_addr) {
#line 182
        tmp___3 = (char const   *)*src_addr;
      } else {
#line 182
        tmp___3 = "";
      }
      {
#line 182
      mylog((log_code )1, (char *)"client IP address not valid %s\n", tmp___3);
      }
#line 184
      if (token) {
#line 185
        *token = (char )'/';
      }
#line 186
      return (1);
    }
  }
#line 191
  if (token) {
#line 192
    *token = (char )'/';
  }
#line 195
  if (family == 2) {
#line 195
    tmp___5 = (void *)(& address);
  } else {
#line 195
    tmp___5 = (void *)(& address6);
  }
  {
#line 195
  tmp___6 = ip_access_check(family, (void const   *)tmp___5, (ip_acl const   *)ip);
  }
#line 195
  if ((unsigned int )tmp___6 == 1U) {
#line 200
    return (1);
  }
#line 202
  return (0);
}
}
#line 208 "/home/june/repo/benchmarks/collector/temp/jesred-1.2pl1/rewrite.c"
int pattern_compare(char *url , char *urlgroup , char *newurl , pattern_item *phead ) 
{ 
  pattern_item *curr ;
  int pos ;
  int len ;
  int i ;
  int matched ;
  int pattern_no ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 216
  pattern_no = 0;
#line 217
  curr = (pattern_item *)((void *)0);
#line 219
  curr = phead;
  {
#line 219
  while (1) {
    while_continue: /* CIL Label */ ;
#line 219
    if (! ((unsigned long )curr != (unsigned long )((void *)0))) {
#line 219
      goto while_break;
    }
#line 220
    pattern_no ++;
#line 221
    matched = 1;
#line 225
    if (curr->urlgroup) {
#line 226
      if (! urlgroup) {
#line 228
        matched = 0;
#line 229
        goto __Cont;
      } else {
        {
#line 226
        tmp = strcmp((char const   *)curr->urlgroup, (char const   *)urlgroup);
        }
#line 226
        if (tmp != 0) {
#line 228
          matched = 0;
#line 229
          goto __Cont;
        }
      }
    }
#line 233
    if (curr->type == 3) {
      {
#line 234
      tmp___0 = strlen((char const   *)curr->pattern);
#line 234
      len = (int )tmp___0;
#line 235
      tmp___1 = strlen((char const   *)url);
#line 235
      pos = (int )(tmp___1 - (size_t )len);
#line 236
      i = 0;
      }
      {
#line 236
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 236
        if (! (i <= len)) {
#line 236
          goto while_break___0;
        }
#line 237
        if ((int )*(url + pos) != (int )*(curr->pattern + i)) {
#line 238
          matched = 0;
#line 239
          goto while_break___0;
        }
#line 241
        pos ++;
#line 236
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 243
      if (matched) {
#line 248
        return (0 - pattern_no);
      }
    } else
#line 282
    if (curr->type == 2) {
      {
#line 283
      tmp___2 = replace_string(curr, url, newurl);
      }
#line 283
      if (tmp___2 == 1) {
#line 284
        return (pattern_no);
      }
    } else {
      {
#line 287
      tmp___3 = regexec((regex_t const   */* __restrict  */)(& curr->cpattern), (char const   */* __restrict  */)url,
                        (size_t )0, (regmatch_t */* __restrict  */)0, 0);
      }
#line 287
      if (tmp___3 == 0) {
        {
#line 288
        strcpy((char */* __restrict  */)newurl, (char const   */* __restrict  */)curr->replacement);
        }
#line 289
        return (pattern_no);
      }
    }
    __Cont: /* CIL Label */ 
#line 219
    curr = curr->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 297
  return (0);
}
}
#line 300 "/home/june/repo/benchmarks/collector/temp/jesred-1.2pl1/rewrite.c"
int replace_string(pattern_item *curr , char *url , char *buffer ) 
{ 
  regmatch_t match_data[10] ;
  int parenthesis ;
  char *in_ptr ;
  char *out_ptr ;
  int replay_num ;
  int count ;
  int tmp ;
  unsigned short const   **tmp___0 ;

  {
  {
#line 312
  tmp = regexec((regex_t const   */* __restrict  */)(& curr->cpattern), (char const   */* __restrict  */)url,
                (size_t )10, (regmatch_t */* __restrict  */)(& match_data[0]), 0);
  }
#line 312
  if (tmp != 0) {
#line 313
    return (0);
  }
  {
#line 316
  in_ptr = curr->replacement;
#line 317
  out_ptr = buffer;
#line 320
  parenthesis = count_parenthesis(curr->pattern);
  }
#line 321
  if (parenthesis < 0) {
#line 323
    return (0);
  }
  {
#line 327
  while (1) {
    while_continue: /* CIL Label */ ;
#line 327
    if (! ((int )*in_ptr != 0)) {
#line 327
      goto while_break;
    }
    {
#line 328
    tmp___0 = __ctype_b_loc();
    }
#line 328
    if ((int const   )*(*tmp___0 + (int )*in_ptr) & 2048) {
      {
#line 331
      if (in_ptr - curr->replacement == 0L) {
#line 331
        goto case_0;
      }
#line 341
      if (in_ptr - curr->replacement == 1L) {
#line 341
        goto case_1;
      }
#line 350
      goto switch_default;
      case_0: /* CIL Label */ 
#line 336
      *out_ptr = *in_ptr;
#line 337
      out_ptr ++;
#line 338
      in_ptr ++;
#line 339
      goto while_continue;
      case_1: /* CIL Label */ 
#line 343
      if ((int )*(in_ptr - 1) != 92) {
#line 344
        *out_ptr = *in_ptr;
#line 345
        out_ptr ++;
#line 346
        in_ptr ++;
#line 347
        goto while_continue;
      }
#line 349
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 354
      if ((int )*(in_ptr - 1) != 92) {
#line 356
        *out_ptr = *in_ptr;
#line 357
        out_ptr ++;
#line 358
        in_ptr ++;
#line 359
        goto while_continue;
      } else
#line 354
      if ((int )*(in_ptr - 1) == 92) {
#line 354
        if ((int )*(in_ptr - 2) == 92) {
#line 356
          *out_ptr = *in_ptr;
#line 357
          out_ptr ++;
#line 358
          in_ptr ++;
#line 359
          goto while_continue;
        }
      }
      switch_break: /* CIL Label */ ;
      }
#line 367
      out_ptr --;
#line 371
      replay_num = (int )*in_ptr - 48;
#line 374
      count = match_data[replay_num].rm_so;
      {
#line 374
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 374
        if (! (count < match_data[replay_num].rm_eo)) {
#line 374
          goto while_break___0;
        }
#line 377
        *out_ptr = *(url + count);
#line 378
        out_ptr ++;
#line 374
        count ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 382
      in_ptr ++;
    } else {
#line 384
      *out_ptr = *in_ptr;
#line 385
      out_ptr ++;
#line 386
      in_ptr ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 394
  *out_ptr = (char )'\000';
#line 397
  return (1);
}
}
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 846 "/usr/include/stdio.h"
extern void perror(char const   *__s ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 104 "/home/june/repo/benchmarks/collector/temp/jesred-1.2pl1/util.h"
void HUPhandler(int kill___0 ) ;
#line 105
void KILLhandler(int kill___0 ) ;
#line 106
void *xcalloc(size_t n , size_t sz ) ;
#line 107
char *savestr(char const   *str ) ;
#line 108
void delstr(char *str ) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/jesred-1.2pl1/log.h"
void closeLogs(void) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/jesred-1.2pl1/main.h"
int sig_hup ;
#line 109 "/home/june/repo/benchmarks/collector/temp/jesred-1.2pl1/util.c"
void HUPhandler(int kill___0 ) 
{ 


  {
  {
#line 112
  sig_hup = 1;
#line 113
  mylog((log_code )1, (char *)"HUP received.  Reconfiguring....\n");
#line 114
  signal(1, & HUPhandler);
  }
#line 115
  return;
}
}
#line 117 "/home/june/repo/benchmarks/collector/temp/jesred-1.2pl1/util.c"
void KILLhandler(int kill___0 ) 
{ 


  {
  {
#line 120
  sig_hup = 1;
#line 121
  mylog((log_code )1, (char *)"KILL received.  Shutting down....\n");
#line 122
  closeLogs();
#line 123
  exit(1);
  }
}
}
#line 134 "/home/june/repo/benchmarks/collector/temp/jesred-1.2pl1/util.c"
static void *p  ;
#line 131 "/home/june/repo/benchmarks/collector/temp/jesred-1.2pl1/util.c"
void *xcalloc(size_t n , size_t sz ) 
{ 


  {
#line 136
  if (n < 1UL) {
#line 137
    n = (size_t )1;
  }
#line 138
  if (sz < 1UL) {
#line 139
    sz = (size_t )1;
  }
  {
#line 140
  p = calloc(n, sz);
  }
#line 140
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 141
    perror("xcalloc");
    }
  }
#line 143
  return (p);
}
}
#line 146 "/home/june/repo/benchmarks/collector/temp/jesred-1.2pl1/util.c"
char *savestr(char const   *str ) 
{ 
  char *save ;
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 151
  tmp = strlen(str);
#line 151
  tmp___0 = malloc(tmp + 1UL);
#line 151
  save = (char *)tmp___0;
  }
#line 152
  if ((unsigned long )save == (unsigned long )((void *)0)) {
    {
#line 153
    perror("Problems allocating memory for a string:");
#line 154
    mylog((log_code )1, (char *)"Problems allocating memory for \"%s\"", str);
    }
  } else {
    {
#line 157
    strcpy((char */* __restrict  */)save, (char const   */* __restrict  */)str);
    }
  }
#line 159
  return (save);
}
}
#line 162 "/home/june/repo/benchmarks/collector/temp/jesred-1.2pl1/util.c"
void delstr(char *str ) 
{ 


  {
#line 165
  if (str) {
    {
#line 165
    free((void *)str);
#line 165
    str = (char *)((void *)0);
    }
  }
#line 166
  return;
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 242 "/usr/include/stdio.h"
extern int fflush(FILE *__stream ) ;
#line 390
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 36 "/home/june/repo/benchmarks/collector/temp/jesred-1.2pl1/main.h"
int interactive ;
#line 38
FILE *fd_rewrite ;
#line 39
FILE *fd_redirect ;
#line 35 "/home/june/repo/benchmarks/collector/temp/jesred-1.2pl1/log.h"
void openLogs(char **redirect , char **rewrite ) ;
#line 33 "/home/june/repo/benchmarks/collector/temp/jesred-1.2pl1/log.c"
FILE *openFile(char *file ) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/jesred-1.2pl1/log.c"
void openLogs(char **redirect , char **rewrite ) 
{ 


  {
#line 38
  if (*rewrite) {
    {
#line 39
    fd_rewrite = openFile(*rewrite);
    }
#line 40
    if (*rewrite) {
      {
#line 40
      free((void *)*rewrite);
#line 40
      *rewrite = (char *)((void *)0);
      }
    }
  } else {
#line 43
    fd_rewrite = (FILE *)((void *)0);
  }
#line 44
  if (*redirect) {
    {
#line 45
    fd_redirect = openFile(*redirect);
    }
#line 46
    if (*redirect) {
      {
#line 46
      free((void *)*redirect);
#line 46
      *redirect = (char *)((void *)0);
      }
    }
  } else {
#line 49
    fd_redirect = (FILE *)((void *)0);
  }
#line 50
  return;
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/jesred-1.2pl1/log.c"
FILE *openFile(char *file ) 
{ 
  FILE *fd ;

  {
  {
#line 58
  fd = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"a+");
  }
#line 58
  if ((unsigned long )fd == (unsigned long )((void *)0)) {
    {
#line 59
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: Can\'t open file %s for writing! \nSkipping all related messages!\n",
            file);
    }
  }
#line 62
  return (fd);
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/jesred-1.2pl1/log.c"
void mylog(log_code c , char *format  , ...) 
{ 
  FILE *fd ;
  char msg[4096] ;
  va_list args ;
  struct timeval current_time ;
  int tmp ;

  {
  {
#line 73
  __builtin_va_start(args, format);
#line 75
  tmp = vsnprintf((char */* __restrict  */)(msg), (size_t )4096, (char const   */* __restrict  */)format,
                  args);
  }
#line 75
  if (tmp > 4095) {
#line 78
    return;
  }
  {
#line 80
  __builtin_va_end(args);
  }
#line 82
  if (interactive) {
    {
#line 83
    gettimeofday((struct timeval */* __restrict  */)(& current_time), (__timezone_ptr_t )((void *)0));
#line 84
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%d.%03d %s",
            (int )current_time.tv_sec, (int )current_time.tv_usec / 1000, msg);
#line 86
    fflush(stderr);
    }
#line 87
    return;
  }
#line 89
  if ((unsigned int )c == 0U) {
#line 90
    if (! fd_rewrite) {
#line 91
      return;
    }
#line 92
    fd = fd_rewrite;
  } else
#line 94
  if ((unsigned int )c == 1U) {
#line 94
    goto _L;
  } else
#line 94
  if ((unsigned int )c == 3U) {
    _L: /* CIL Label */ 
#line 95
    if (! fd_redirect) {
#line 96
      return;
    }
#line 97
    fd = fd_redirect;
  } else {
#line 107
    return;
  }
  {
#line 108
  gettimeofday((struct timeval */* __restrict  */)(& current_time), (__timezone_ptr_t )((void *)0));
#line 109
  fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"%d.%03d %s",
          (int )current_time.tv_sec, (int )current_time.tv_usec / 1000, msg);
#line 111
  fflush(fd);
  }
#line 112
  return;
}
}
#line 114 "/home/june/repo/benchmarks/collector/temp/jesred-1.2pl1/log.c"
void closeLogs(void) 
{ 


  {
#line 116
  if (fd_rewrite) {
    {
#line 117
    fclose(fd_rewrite);
    }
  }
#line 118
  if (fd_redirect) {
    {
#line 119
    fclose(fd_redirect);
    }
  }
#line 120
  return;
}
}
#line 433 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 573 "/usr/include/regex.h"
extern int regcomp(regex_t * __restrict  __preg , char const   * __restrict  __pattern ,
                   int __cflags ) ;
#line 585
extern void regfree(regex_t *__preg ) ;
#line 55 "/home/june/repo/benchmarks/collector/temp/jesred-1.2pl1/pattern_list.h"
void plist_destroy(pattern_item **a ) ;
#line 48 "/home/june/repo/benchmarks/collector/temp/jesred-1.2pl1/pattern_list.c"
void add_to_plist(pattern_item pattern , pattern_item **plist ) ;
#line 53 "/home/june/repo/benchmarks/collector/temp/jesred-1.2pl1/pattern_list.c"
void add_to_patterns(char *pattern , pattern_item **plist ) 
{ 
  char *rgxurl ;
  char *repurl ;
  char *urlgroup ;
  regex_t compiled ;
  pattern_item rpattern ;
  int abort_type ;
  int stored ;
  char type[4096] ;
  char arg1[4096] ;
  char arg2[4096] ;
  char arg3[4096] ;
  char arg4[4096] ;
  int regex_flags ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  void *tmp___9 ;
  size_t tmp___10 ;
  void *tmp___11 ;
  size_t tmp___12 ;
  void *tmp___13 ;

  {
  {
#line 56
  rgxurl = (char *)"";
#line 57
  repurl = (char *)"";
#line 61
  urlgroup = (char *)((void *)0);
#line 64
  abort_type = 0;
#line 78
  regex_flags = 1;
#line 80
  rpattern.type = 2;
#line 81
  rpattern.case_sensitive = 1;
#line 83
  stored = sscanf((char const   */* __restrict  */)pattern, (char const   */* __restrict  */)"%s %s %s %s %s",
                  type, arg1, arg2, arg3, arg4);
  }
#line 85
  if (stored < 2) {
    {
#line 86
    mylog((log_code )1, (char *)"unable to get a pair of patterns in add_to_patterns() for [%s]\n",
          pattern);
#line 88
    echo_mode = 1;
    }
#line 89
    return;
  } else
#line 85
  if (stored > 4) {
    {
#line 86
    mylog((log_code )1, (char *)"unable to get a pair of patterns in add_to_patterns() for [%s]\n",
          pattern);
#line 88
    echo_mode = 1;
    }
#line 89
    return;
  }
  {
#line 93
  tmp___3 = strcmp((char const   *)(type), "regexug");
  }
#line 93
  if (tmp___3 == 0) {
#line 93
    goto _L___0;
  } else {
    {
#line 93
    tmp___4 = strcmp((char const   *)(type), "regexiug");
    }
#line 93
    if (tmp___4 == 0) {
      _L___0: /* CIL Label */ 
      {
#line 96
      if (stored == 3) {
#line 96
        goto case_3;
      }
#line 99
      if (stored == 4) {
#line 99
        goto case_4;
      }
#line 110
      goto switch_default;
      case_3: /* CIL Label */ 
#line 96
      urlgroup = arg1;
#line 97
      rgxurl = arg2;
#line 98
      goto switch_break;
      case_4: /* CIL Label */ 
#line 99
      urlgroup = arg1;
#line 100
      rgxurl = arg2;
#line 101
      repurl = arg3;
#line 102
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 110
      mylog((log_code )1, (char *)"unable to parse rule for [%s]\n", pattern);
#line 111
      echo_mode = 1;
      }
#line 112
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else {
      {
#line 115
      tmp___1 = strcmp((char const   *)(type), "regex");
      }
#line 115
      if (tmp___1 == 0) {
#line 115
        goto _L;
      } else {
        {
#line 115
        tmp___2 = strcmp((char const   *)(type), "regexi");
        }
#line 115
        if (tmp___2 == 0) {
          _L: /* CIL Label */ 
          {
#line 118
          if (stored == 2) {
#line 118
            goto case_2;
          }
#line 121
          if (stored == 3) {
#line 121
            goto case_3___0;
          }
#line 130
          goto switch_default___0;
          case_2: /* CIL Label */ 
          {
#line 118
          rgxurl = arg1;
#line 119
          strcpy((char */* __restrict  */)repurl, (char const   */* __restrict  */)"");
          }
#line 120
          goto switch_break___0;
          case_3___0: /* CIL Label */ 
#line 121
          rgxurl = arg1;
#line 122
          repurl = arg2;
#line 123
          goto switch_break___0;
          switch_default___0: /* CIL Label */ 
          {
#line 130
          mylog((log_code )1, (char *)"unable to parse rule for [%s]\n", pattern);
#line 131
          echo_mode = 1;
          }
#line 132
          goto switch_break___0;
          switch_break___0: /* CIL Label */ ;
          }
        } else {
          {
#line 135
          tmp___0 = strcmp((char const   *)(type), "abortug");
          }
#line 135
          if (tmp___0 == 0) {
#line 136
            rpattern.type = 3;
#line 137
            abort_type = 1;
#line 138
            if (stored == 3) {
#line 139
              urlgroup = arg1;
#line 140
              rgxurl = arg2;
            } else {
              {
#line 142
              mylog((log_code )1, (char *)"unable to parse rule for [%s]\n", pattern);
#line 143
              echo_mode = 1;
              }
            }
          } else {
            {
#line 146
            tmp = strcmp((char const   *)(type), "abort");
            }
#line 146
            if (tmp == 0) {
#line 147
              rpattern.type = 3;
#line 148
              abort_type = 1;
#line 149
              if (stored == 2) {
#line 150
                rgxurl = arg1;
              } else {
                {
#line 152
                mylog((log_code )1, (char *)"unable to parse rule for [%s]\n", pattern);
#line 153
                echo_mode = 1;
                }
              }
            } else {
              {
#line 157
              mylog((log_code )1, (char *)"unable to parse rule for [%s]\n", pattern);
#line 158
              echo_mode = 1;
              }
            }
          }
        }
      }
    }
  }
  {
#line 161
  tmp___5 = strcmp((char const   *)(type), "regexi");
  }
#line 161
  if (tmp___5 == 0) {
#line 162
    regex_flags |= 1 << 1;
#line 163
    rpattern.case_sensitive = 0;
  } else {
    {
#line 161
    tmp___6 = strcmp((char const   *)(type), "regexiug");
    }
#line 161
    if (tmp___6 == 0) {
#line 162
      regex_flags |= 1 << 1;
#line 163
      rpattern.case_sensitive = 0;
    }
  }
  {
#line 166
  tmp___7 = regcomp((regex_t */* __restrict  */)(& compiled), (char const   */* __restrict  */)rgxurl,
                    regex_flags);
  }
#line 166
  if (tmp___7) {
    {
#line 167
    mylog((log_code )1, (char *)"Invalid regex [%s] in pattern file\n", rgxurl);
#line 168
    echo_mode = 1;
    }
#line 169
    return;
  }
  {
#line 171
  rpattern.cpattern = compiled;
#line 172
  tmp___8 = strlen((char const   *)rgxurl);
#line 172
  tmp___9 = malloc(sizeof(char ) * (tmp___8 + 1UL));
#line 172
  rpattern.pattern = (char *)tmp___9;
  }
#line 173
  if ((unsigned long )rpattern.pattern == (unsigned long )((void *)0)) {
    {
#line 174
    mylog((log_code )1, (char *)"unable to allocate memory in add_to_patterns()\n");
#line 175
    echo_mode = 1;
    }
#line 176
    return;
  }
  {
#line 178
  strcpy((char */* __restrict  */)rpattern.pattern, (char const   */* __restrict  */)rgxurl);
#line 179
  tmp___10 = strlen((char const   *)repurl);
#line 179
  tmp___11 = malloc(sizeof(char ) * (tmp___10 + 1UL));
#line 179
  rpattern.replacement = (char *)tmp___11;
  }
#line 180
  if ((unsigned long )rpattern.replacement == (unsigned long )((void *)0)) {
    {
#line 181
    mylog((log_code )1, (char *)"unable to allocate memory in add_to_patterns()\n");
#line 182
    echo_mode = 1;
    }
#line 183
    return;
  }
  {
#line 185
  strcpy((char */* __restrict  */)rpattern.replacement, (char const   */* __restrict  */)repurl);
  }
#line 205
  if (urlgroup) {
    {
#line 206
    tmp___12 = strlen((char const   *)urlgroup);
#line 206
    tmp___13 = malloc(sizeof(char ) * (tmp___12 + 1UL));
#line 206
    rpattern.urlgroup = (char *)tmp___13;
    }
#line 207
    if ((unsigned long )rpattern.urlgroup == (unsigned long )((void *)0)) {
      {
#line 208
      mylog((log_code )1, (char *)"unable to allocate memory in add_to_patterns()\n");
#line 209
      echo_mode = 1;
      }
#line 210
      return;
    }
    {
#line 212
    strcpy((char */* __restrict  */)rpattern.urlgroup, (char const   */* __restrict  */)urlgroup);
    }
  } else {
#line 215
    rpattern.urlgroup = (char *)((void *)0);
  }
  {
#line 218
  add_to_plist(rpattern, plist);
  }
#line 219
  return;
}
}
#line 280 "/home/june/repo/benchmarks/collector/temp/jesred-1.2pl1/pattern_list.c"
void add_to_plist(pattern_item pattern , pattern_item **plist ) 
{ 
  pattern_item *curr ;
  pattern_item *new ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 285
  curr = (pattern_item *)((void *)0);
#line 286
  new = (pattern_item *)((void *)0);
#line 288
  if (! *plist) {
    {
#line 290
    tmp = xcalloc((size_t )1, sizeof(pattern_item ));
#line 290
    *plist = (pattern_item *)tmp;
#line 291
    new = *plist;
    }
  } else {
#line 294
    curr = *plist;
    {
#line 295
    while (1) {
      while_continue: /* CIL Label */ ;
#line 295
      if (! curr->next) {
#line 295
        goto while_break;
      }
#line 296
      curr = curr->next;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 297
    tmp___0 = xcalloc((size_t )1, sizeof(pattern_item ));
#line 297
    new = (pattern_item *)tmp___0;
#line 298
    curr->next = new;
    }
  }
#line 300
  if (! new) {
    {
#line 301
    mylog((log_code )1, (char *)"unable to allocate memory in add_to_plist()\n");
#line 303
    echo_mode = 1;
    }
#line 304
    return;
  }
#line 306
  new->pattern = pattern.pattern;
#line 307
  new->replacement = pattern.replacement;
#line 308
  new->type = pattern.type;
#line 314
  new->case_sensitive = pattern.case_sensitive;
#line 315
  new->urlgroup = pattern.urlgroup;
#line 318
  new->cpattern = pattern.cpattern;
#line 319
  new->next = (struct _pattern_item *)((void *)0);
#line 320
  return;
}
}
#line 322 "/home/june/repo/benchmarks/collector/temp/jesred-1.2pl1/pattern_list.c"
int count_parenthesis(char *pattern ) 
{ 
  int lcount ;
  int rcount ;
  int i ;
  size_t tmp ;

  {
#line 324
  lcount = 0;
#line 325
  rcount = 0;
#line 329
  i = 0;
  {
#line 329
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 329
    tmp = strlen((char const   *)pattern);
    }
#line 329
    if (! ((size_t )i < tmp)) {
#line 329
      goto while_break;
    }
#line 331
    if ((int )*(pattern + i) == 40) {
#line 333
      if (i != 0) {
#line 333
        if ((int )*(pattern + (i - 1)) == 92) {
#line 334
          goto __Cont;
        } else {
#line 336
          lcount ++;
        }
      } else {
#line 336
        lcount ++;
      }
    }
#line 338
    if ((int )*(pattern + i) == 41) {
#line 339
      if (i != 0) {
#line 339
        if ((int )*(pattern + (i - 1)) == 92) {
#line 340
          goto __Cont;
        } else {
#line 342
          rcount ++;
        }
      } else {
#line 342
        rcount ++;
      }
    }
    __Cont: /* CIL Label */ 
#line 329
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 346
  if (lcount != rcount) {
#line 347
    return (-1);
  }
#line 348
  return (lcount);
}
}
#line 387 "/home/june/repo/benchmarks/collector/temp/jesred-1.2pl1/pattern_list.c"
void plist_destroy(pattern_item **a ) 
{ 
  pattern_item *b ;
  pattern_item *n ;

  {
#line 392
  b = *a;
  {
#line 392
  while (1) {
    while_continue: /* CIL Label */ ;
#line 392
    if (! b) {
#line 392
      goto while_break;
    }
#line 393
    n = b->next;
#line 394
    if (b->pattern) {
      {
#line 394
      free((void *)b->pattern);
#line 394
      b->pattern = (char *)((void *)0);
      }
    }
#line 395
    if (b->replacement) {
      {
#line 395
      free((void *)b->replacement);
#line 395
      b->replacement = (char *)((void *)0);
      }
    }
    {
#line 400
    regfree(& b->cpattern);
    }
#line 401
    if (b) {
      {
#line 401
      free((void *)b);
#line 401
      b = (pattern_item *)((void *)0);
      }
    }
#line 392
    b = n;
  }
  while_break: /* CIL Label */ ;
  }
#line 403
  *a = (pattern_item *)((void *)0);
#line 404
  return;
}
}
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 377 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) htonl)(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 118 "/home/june/repo/benchmarks/collector/temp/jesred-1.2pl1/ip_list.h"
void ip_acl_destroy(ip_acl **a ) ;
#line 118 "/home/june/repo/benchmarks/collector/temp/jesred-1.2pl1/ip_list.c"
ip_access_type ip_access_check(int afamily , void const   *address , ip_acl const   *list ) 
{ 
  ip_acl const   *p___0 ;
  struct in_addr h ;
  ip_access_type response ;
  int i ;
  int equal ;

  {
#line 121
  p___0 = (ip_acl const   *)((void *)0);
#line 123
  response = (ip_access_type )1;
#line 132
  if (list) {
#line 134
    p___0 = list;
    {
#line 134
    while (1) {
      while_continue: /* CIL Label */ ;
#line 134
      if (! p___0) {
#line 134
        goto while_break;
      }
#line 136
      if (p___0->af != (int const   )afamily) {
#line 137
        goto __Cont;
      }
#line 138
      if (p___0->af == 2) {
#line 140
        h.s_addr = ((struct in_addr *)address)->s_addr & (unsigned int )p___0->mask.s_addr;
#line 141
        if (h.s_addr == (in_addr_t )p___0->addr.s_addr) {
#line 143
          response = (ip_access_type )p___0->access;
#line 144
          goto while_break;
        }
      } else
#line 147
      if (p___0->af == 10) {
#line 149
        equal = 1;
#line 151
        i = 0;
        {
#line 151
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 151
          if (! ((unsigned long )i < sizeof(p___0->addr6.__in6_u.__u6_addr8))) {
#line 151
            goto while_break___0;
          }
#line 153
          if ((int )p___0->addr6.__in6_u.__u6_addr8[i] != ((int )((struct in6_addr *)address)->__in6_u.__u6_addr8[i] & (int )p___0->mask6.__in6_u.__u6_addr8[i])) {
#line 156
            equal = 0;
#line 157
            goto while_break___0;
          }
#line 151
          i ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 160
        if (equal) {
#line 162
          response = (ip_access_type )p___0->access;
#line 163
          goto while_break;
        }
      }
      __Cont: /* CIL Label */ 
#line 134
      p___0 = (ip_acl const   *)p___0->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 173
  return (response);
}
}
#line 176 "/home/june/repo/benchmarks/collector/temp/jesred-1.2pl1/ip_list.c"
void addToIPACL(ip_acl **list , char const   *ip_str ) 
{ 
  ip_acl *p___0 ;
  ip_acl *q ;
  int inv ;
  int masklen ;
  char *masklenp ;
  int family ;
  int i ;
  char *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  uint32_t tmp___5 ;

  {
#line 180
  inv = 0;
#line 184
  if (! ip_str) {
#line 185
    return;
  }
#line 189
  if ((int const   )*ip_str == 33) {
#line 190
    ip_str ++;
#line 191
    inv ++;
  }
  {
#line 194
  tmp___0 = strchr(ip_str, ':');
  }
#line 194
  if (tmp___0) {
#line 194
    family = 10;
  } else {
#line 194
    family = 2;
  }
  {
#line 196
  masklenp = strchr(ip_str, '/');
  }
#line 197
  if (! masklenp) {
    {
#line 199
    mylog((log_code )1, (char *)"Ignoring invalid IP acl line \'%s\': no mask len\n",
          ip_str);
    }
#line 200
    return;
  }
  {
#line 202
  *masklenp = (char)0;
#line 203
  masklenp ++;
#line 203
  masklen = atoi((char const   *)masklenp);
  }
#line 204
  if (masklen < 0) {
    {
#line 207
    mylog((log_code )1, (char *)"Ignoring invalid IP acl line \'%s\': bad mask len\n",
          ip_str);
    }
#line 208
    return;
  } else
#line 204
  if (family == 10) {
#line 204
    if (masklen > 128) {
      {
#line 207
      mylog((log_code )1, (char *)"Ignoring invalid IP acl line \'%s\': bad mask len\n",
            ip_str);
      }
#line 208
      return;
    } else {
#line 204
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 204
  if (family == 2) {
#line 204
    if (masklen > 32) {
      {
#line 207
      mylog((log_code )1, (char *)"Ignoring invalid IP acl line \'%s\': bad mask len\n",
            ip_str);
      }
#line 208
      return;
    }
  }
#line 212
  if (! *list) {
    {
#line 214
    tmp___1 = xcalloc((size_t )1, sizeof(ip_acl ));
#line 214
    *list = (ip_acl *)tmp___1;
#line 215
    (*list)->next = (struct _ip_acl *)((void *)0);
#line 216
    q = *list;
#line 217
    p___0 = (ip_acl *)((void *)0);
    }
  } else {
#line 220
    p___0 = *list;
    {
#line 221
    while (1) {
      while_continue: /* CIL Label */ ;
#line 221
      if (! p___0->next) {
#line 221
        goto while_break;
      }
#line 222
      p___0 = p___0->next;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 223
    tmp___2 = xcalloc((size_t )1, sizeof(ip_acl ));
#line 223
    q = (ip_acl *)tmp___2;
#line 224
    q->next = (struct _ip_acl *)((void *)0);
#line 225
    p___0->next = q;
    }
  }
#line 228
  q->af = family;
#line 230
  if (family == 2) {
#line 230
    tmp___3 = (void *)(& q->addr.s_addr);
  } else {
#line 230
    tmp___3 = (void *)(& q->addr6.__in6_u.__u6_addr8);
  }
  {
#line 230
  tmp___4 = inet_pton(family, (char const   */* __restrict  */)ip_str, (void */* __restrict  */)tmp___3);
  }
#line 230
  if (! tmp___4) {
    {
#line 233
    mylog((log_code )1, (char *)"Ignoring invalid IP acl line \'%s\'\n", ip_str);
    }
#line 234
    if (q) {
      {
#line 234
      free((void *)q);
#line 234
      q = (ip_acl *)((void *)0);
      }
    }
#line 235
    if (p___0) {
#line 236
      p___0->next = (struct _ip_acl *)((void *)0);
    } else {
#line 238
      *list = (ip_acl *)((void *)0);
    }
#line 239
    return;
  }
#line 242
  if (inv) {
#line 242
    q->access = (ip_access_type )1;
  } else {
#line 242
    q->access = (ip_access_type )0;
  }
#line 244
  if (family == 2) {
#line 246
    if (masklen) {
      {
#line 246
      tmp___5 = htonl((uint32_t )(4294967295UL << (32 - masklen)));
#line 246
      q->mask.s_addr = tmp___5;
      }
    } else {
#line 246
      q->mask.s_addr = (in_addr_t )0;
    }
  } else {
#line 250
    i = 0;
    {
#line 250
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 250
      if (! ((unsigned long )i < sizeof(q->mask6.__in6_u.__u6_addr8))) {
#line 250
        goto while_break___0;
      }
#line 252
      if (i < masklen / 8) {
#line 254
        q->mask6.__in6_u.__u6_addr8[i] = (uint8_t )255;
      } else
#line 256
      if (i > masklen / 8) {
#line 258
        q->mask6.__in6_u.__u6_addr8[i] = (uint8_t )0;
      } else {
#line 262
        q->mask6.__in6_u.__u6_addr8[i] = (uint8_t )(255 & (255 << (8 - masklen % 8)));
      }
#line 250
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 266
  return;
}
}
#line 268 "/home/june/repo/benchmarks/collector/temp/jesred-1.2pl1/ip_list.c"
void ip_acl_destroy(ip_acl **a ) 
{ 
  ip_acl *b ;
  ip_acl *n ;

  {
#line 273
  b = *a;
  {
#line 273
  while (1) {
    while_continue: /* CIL Label */ ;
#line 273
    if (! b) {
#line 273
      goto while_break;
    }
#line 274
    n = b->next;
#line 275
    if (b) {
      {
#line 275
      free((void *)b);
#line 275
      b = (ip_acl *)((void *)0);
      }
    }
#line 273
    b = n;
  }
  while_break: /* CIL Label */ ;
  }
#line 277
  *a = (ip_acl *)((void *)0);
#line 278
  return;
}
}
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 695
extern int puts(char const   *__s ) ;
#line 628 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 675
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 150 "/usr/include/getopt.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 53 "/home/june/repo/benchmarks/collector/temp/jesred-1.2pl1/main.c"
static void Usage(void) ;
#line 54
static void GetOptions(int argc , char **argv ) ;
#line 56 "/home/june/repo/benchmarks/collector/temp/jesred-1.2pl1/main.c"
int echo_mode  =    0;
#line 57 "/home/june/repo/benchmarks/collector/temp/jesred-1.2pl1/main.c"
int sig_hup  =    0;
#line 58 "/home/june/repo/benchmarks/collector/temp/jesred-1.2pl1/main.c"
int interactive  =    0;
#line 59 "/home/june/repo/benchmarks/collector/temp/jesred-1.2pl1/main.c"
int allow_siblings  =    0;
#line 63 "/home/june/repo/benchmarks/collector/temp/jesred-1.2pl1/main.c"
FILE *fd_redirect  =    (FILE *)((void *)0);
#line 64 "/home/june/repo/benchmarks/collector/temp/jesred-1.2pl1/main.c"
FILE *fd_rewrite  =    (FILE *)((void *)0);
#line 67 "/home/june/repo/benchmarks/collector/temp/jesred-1.2pl1/main.c"
int main(int argc , char **argv ) 
{ 
  char *f_allow ;
  char *f_rules ;
  char *f_rewrite ;
  char *f_redirect ;
  char buff[4096] ;
  char redirect_url[4096] ;
  char *url ;
  char *src_addr ;
  char *ident ;
  char *method ;
  char *urlgroup ;
  int finished ;
  int buff_status ;
  ip_acl *ip_list ;
  pattern_item *pattern_list ;
  __uid_t tmp ;
  int val ;
  __pid_t tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 69
  f_allow = (char *)((void *)0);
#line 70
  f_rules = (char *)((void *)0);
#line 71
  f_rewrite = (char *)((void *)0);
#line 72
  f_redirect = (char *)((void *)0);
#line 79
  finished = 0;
#line 80
  buff_status = 0;
#line 81
  ip_list = (ip_acl *)((void *)0);
#line 82
  pattern_list = (pattern_item *)((void *)0);
#line 85
  tmp = getuid();
  }
#line 85
  if ((int )tmp == 0) {
    {
#line 86
    interactive = 1;
#line 87
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s running as UID 0: writing logs to stderr\n",
            "JESRED");
    }
  }
  {
#line 89
  signal(1, & HUPhandler);
#line 90
  signal(9, & KILLhandler);
#line 91
  GetOptions(argc, argv);
  }
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;
#line 95
    if (! (! finished)) {
#line 95
      goto while_break;
    }
    {
#line 98
    sig_hup = 0;
#line 99
    mylog((log_code )3, (char *)"Freeing up old linked lists\n");
#line 100
    ip_acl_destroy(& ip_list);
#line 101
    plist_destroy(& pattern_list);
#line 102
    closeLogs();
#line 103
    read_config(& f_allow, & f_rules, & f_redirect, & f_rewrite);
    }
#line 104
    if (! interactive) {
      {
#line 105
      openLogs(& f_redirect, & f_rewrite);
      }
    }
    {
#line 106
    read_allow(& f_allow, & ip_list);
#line 107
    read_rules(& f_rules, & pattern_list);
    }
#line 109
    if (echo_mode) {
      {
#line 110
      mylog((log_code )1, (char *)"Invalid condition - continuing in ECHO mode\n");
      }
    }
    {
#line 111
    tmp___0 = getpid();
#line 111
    mylog((log_code )3, (char *)"%s (PID %d) started\n", "JESRED", tmp___0);
    }
    {
#line 113
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 113
      if (! sig_hup) {
        {
#line 113
        tmp___1 = fgets((char */* __restrict  */)(buff), 4096, (FILE */* __restrict  */)stdin);
        }
#line 113
        if (! ((unsigned long )tmp___1 != (unsigned long )((void *)0))) {
#line 113
          goto while_break___0;
        }
      } else {
#line 113
        goto while_break___0;
      }
#line 114
      if (echo_mode) {
        {
#line 115
        puts("");
#line 116
        fflush(stdout);
        }
#line 117
        goto while_continue___0;
      }
      {
#line 120
      buff_status = parse_buff(buff, & url, & src_addr, & ident, & method, & urlgroup,
                               ip_list, pattern_list);
      }
#line 123
      if (buff_status) {
        {
#line 124
        puts("");
#line 125
        fflush(stdout);
        }
#line 126
        goto while_continue___0;
      }
#line 129
      if (echo_mode) {
        {
#line 130
        puts("");
#line 131
        fflush(stdout);
#line 132
        mylog((log_code )1, (char *)"Invalid condition - continuing in ECHO mode\n");
        }
#line 133
        goto while_continue___0;
      }
      {
#line 136
      val = pattern_compare(url, urlgroup, redirect_url, pattern_list);
      }
#line 137
      if (val < 1) {
        {
#line 139
        puts("");
#line 140
        fflush(stdout);
        }
#line 141
        goto while_continue___0;
      } else
#line 145
      if ((int )redirect_url[0] == 0) {
        {
#line 147
        puts("");
#line 148
        fflush(stdout);
        }
      } else {
        {
#line 151
        printf((char const   */* __restrict  */)"%s %s %s %s\n", redirect_url, src_addr,
               ident, method);
#line 153
        fflush(stdout);
#line 154
        mylog((log_code )0, (char *)"%s %s %s %d\n", src_addr, url, redirect_url,
              val);
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 159
    if (! sig_hup) {
#line 160
      finished = 1;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 162
  ip_acl_destroy(& ip_list);
#line 163
  plist_destroy(& pattern_list);
#line 164
  closeLogs();
  }
#line 165
  if (f_rewrite) {
    {
#line 165
    free((void *)f_rewrite);
#line 165
    f_rewrite = (char *)((void *)0);
    }
  }
#line 166
  if (f_redirect) {
    {
#line 166
    free((void *)f_redirect);
#line 166
    f_redirect = (char *)((void *)0);
    }
  }
#line 167
  return (0);
}
}
#line 170 "/home/june/repo/benchmarks/collector/temp/jesred-1.2pl1/main.c"
static void GetOptions(int argc , char **argv ) 
{ 
  int c ;

  {
  {
#line 177
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 177
    c = getopt(argc, (char * const  *)argv, "hv");
    }
#line 177
    if (! (c != -1)) {
#line 177
      goto while_break;
    }
    {
#line 179
    if (c == 104) {
#line 179
      goto case_104;
    }
#line 182
    if (c == 118) {
#line 182
      goto case_118;
    }
#line 186
    goto switch_default;
    case_104: /* CIL Label */ 
    {
#line 180
    Usage();
    }
#line 181
    goto switch_break;
    case_118: /* CIL Label */ 
    {
#line 183
    printf((char const   */* __restrict  */)"%s %s  (C) by %s  (%s)\n%s\n", "JESRED",
           "1.2", "Jens Elkner", "elkner@ivs.cs.uni-magdeburg.de", "http://ivs.cs.uni-magdeburg.de/~elkner/webtools/jesred/");
#line 185
    exit(0);
    }
    switch_default: /* CIL Label */ 
    {
#line 187
    Usage();
    }
#line 188
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 191
  return;
}
}
#line 193 "/home/june/repo/benchmarks/collector/temp/jesred-1.2pl1/main.c"
static void Usage(void) 
{ 


  {
  {
#line 197
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: %s [-h] [-v]\n\n   -h         print this and exit\n   -v         show version and exit\n",
          "JESRED");
#line 202
  exit(1);
  }
}
}
