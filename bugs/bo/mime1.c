/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h"
typedef unsigned long size_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __u_char;
#line 31 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __u_short;
#line 33 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __u_long;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 33 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_char u_char;
#line 34 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_short u_short;
#line 36 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_long u_long;
#line 48 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ino_t ino_t;
#line 60 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __dev_t dev_t;
#line 65 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __gid_t gid_t;
#line 80 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uid_t uid_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 78 "my-sendmail.h"
struct header {
   char *h_field ;
   char *h_value ;
   struct header *h_link ;
   u_short h_flags ;
};
#line 87 "my-sendmail.h"
typedef struct header HDR;
#line 90 "my-sendmail.h"
struct address {
   char *q_paddr ;
   char *q_user ;
   char *q_ruser ;
   char *q_host ;
   u_long q_flags ;
   uid_t q_uid ;
   gid_t q_gid ;
   char *q_home ;
   char *q_fullname ;
   struct address *q_next ;
   struct address *q_alias ;
   char *q_owner ;
   struct address *q_tchain ;
   char *q_orcpt ;
   char *q_status ;
   char *q_rstatus ;
   char *q_statmta ;
   short q_specificity ;
};
#line 114 "my-sendmail.h"
typedef struct address ADDRESS;
#line 118 "my-sendmail.h"
struct envelope {
   HDR *e_header ;
   long e_msgpriority ;
   time_t e_ctime ;
   char *e_to ;
   ADDRESS e_from ;
   char *e_sender ;
   char **e_fromdomain ;
   ADDRESS *e_sendqueue ;
   ADDRESS *e_errorqueue ;
   long e_msgsize ;
   long e_flags ;
   int e_nrcpts ;
   short e_class ;
   short e_hopcount ;
   short e_nsent ;
   short e_sendmode ;
   short e_errormode ;
   short e_timeoutclass ;
   struct envelope *e_parent ;
   struct envelope *e_sibling ;
   char *e_bodytype ;
   FILE *e_dfp ;
   char *e_id ;
   FILE *e_xfp ;
   FILE *e_lockfp ;
   char *e_message ;
   char *e_statmsg ;
   char *e_msgboundary ;
   char *e_origrcpt ;
   char *e_envid ;
   char *e_status ;
   time_t e_dtime ;
   int e_ntries ;
   dev_t e_dfdev ;
   ino_t e_dfino ;
   char *e_macro[256] ;
};
#line 159 "my-sendmail.h"
typedef struct envelope ENVELOPE;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 75 "my-sendmail.h"
int mime_fromqp(u_char *infile , u_char **outfile , int state , int maxlen ) ;
#line 166
char *xalloc(int sz ) ;
#line 167
void mime7to8(HDR *header , ENVELOPE *e ) ;
#line 70 "mime1-bad.c"
char *xalloc(int sz ) 
{ 
  register char *p ;
  void *tmp ;
  char *__cil_tmp4 ;

  {
#line 77
  if (sz <= 0) {
#line 78
    sz = 1;
  }
  {
#line 80
  tmp = malloc((size_t )((unsigned int )sz));
#line 80
  p = (char *)tmp;
  }
#line 81
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 83
    perror("Out of memory!!");
    }
  }
#line 85
  return (p);
}
}
#line 88
char *hvalue(char *field , HDR *header ) ;
#line 113 "mime1-bad.c"
void mime7to8(HDR *header , ENVELOPE *e ) 
{ 
  register char *p ;
  u_char *obp ;
  char buf[50] ;
  char canary[10] ;
  u_char obuf[50] ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
  {
#line 124
  strcpy((char */* __restrict  */)(canary), (char const   */* __restrict  */)"GOOD");
#line 126
  tmp = hvalue((char *)"Content-Transfer-Encoding", header);
#line 126
  p = tmp;
  }
#line 127
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 129
    printf((char const   */* __restrict  */)"Content-Transfer-Encoding not found in header\n");
    }
#line 130
    return;
  }
  {
#line 141
  tmp___2 = strcasecmp((char const   *)p, "base64");
  }
#line 141
  if (tmp___2 == 0) {
    {
#line 143
    printf((char const   */* __restrict  */)"We do not handle base64 encoding...\n");
    }
#line 144
    return;
  } else {
#line 149
    obp = obuf;
    {
#line 150
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 150
      tmp___1 = fgets((char */* __restrict  */)(buf), (int )sizeof(buf), (FILE */* __restrict  */)e->e_dfp);
      }
#line 150
      if (! ((unsigned long )tmp___1 != (unsigned long )((void *)0))) {
#line 150
        goto while_break;
      }
      {
#line 152
      printf((char const   */* __restrict  */)"buf-obuf=%u\n", buf - (char *)(obuf));
#line 153
      printf((char const   */* __restrict  */)"obp-obuf=%u\n", obp - obuf);
#line 154
      printf((char const   */* __restrict  */)"canary-obuf=%u\n", canary - (char *)(obuf));
#line 156
      tmp___0 = mime_fromqp((u_char *)(buf), & obp, 0, 50);
      }
#line 156
      if (tmp___0 == 0) {
        {
#line 157
        printf((char const   */* __restrict  */)"canary = %s\n", canary);
        }
      } else {
        {
#line 162
        obp = obuf;
#line 163
        printf((char const   */* __restrict  */)"canary = %s\n", canary);
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 169
  printf((char const   */* __restrict  */)"obuf = %s\n", obuf);
#line 170
  printf((char const   */* __restrict  */)"canary should be GOOD\n");
#line 171
  printf((char const   */* __restrict  */)"canary = %s\n", canary);
  }
#line 172
  return;
}
}
#line 185 "mime1-bad.c"
static char index_hex[128]  = 
#line 185
  {      (char)-1,      (char)-1,      (char)-1,      (char)-1, 
        (char)-1,      (char)-1,      (char)-1,      (char)-1, 
        (char)-1,      (char)-1,      (char)-1,      (char)-1, 
        (char)-1,      (char)-1,      (char)-1,      (char)-1, 
        (char)-1,      (char)-1,      (char)-1,      (char)-1, 
        (char)-1,      (char)-1,      (char)-1,      (char)-1, 
        (char)-1,      (char)-1,      (char)-1,      (char)-1, 
        (char)-1,      (char)-1,      (char)-1,      (char)-1, 
        (char)-1,      (char)-1,      (char)-1,      (char)-1, 
        (char)-1,      (char)-1,      (char)-1,      (char)-1, 
        (char)-1,      (char)-1,      (char)-1,      (char)-1, 
        (char)-1,      (char)-1,      (char)-1,      (char)-1, 
        (char)0,      (char)1,      (char)2,      (char)3, 
        (char)4,      (char)5,      (char)6,      (char)7, 
        (char)8,      (char)9,      (char)-1,      (char)-1, 
        (char)-1,      (char)-1,      (char)-1,      (char)-1, 
        (char)-1,      (char)10,      (char)11,      (char)12, 
        (char)13,      (char)14,      (char)15,      (char)-1, 
        (char)-1,      (char)-1,      (char)-1,      (char)-1, 
        (char)-1,      (char)-1,      (char)-1,      (char)-1, 
        (char)-1,      (char)-1,      (char)-1,      (char)-1, 
        (char)-1,      (char)-1,      (char)-1,      (char)-1, 
        (char)-1,      (char)-1,      (char)-1,      (char)-1, 
        (char)-1,      (char)-1,      (char)-1,      (char)-1, 
        (char)-1,      (char)10,      (char)11,      (char)12, 
        (char)13,      (char)14,      (char)15,      (char)-1, 
        (char)-1,      (char)-1,      (char)-1,      (char)-1, 
        (char)-1,      (char)-1,      (char)-1,      (char)-1, 
        (char)-1,      (char)-1,      (char)-1,      (char)-1, 
        (char)-1,      (char)-1,      (char)-1,      (char)-1, 
        (char)-1,      (char)-1,      (char)-1,      (char)-1, 
        (char)-1,      (char)-1,      (char)-1,      (char)-1};
#line 199 "mime1-bad.c"
int mime_fromqp(u_char *infile , u_char **outfile , int state , int maxlen ) 
{ 
  u_char *ooutfile ;
  int c1 ;
  int c2 ;
  int nchar ;
  u_char *tmp ;
  u_char *tmp___0 ;
  u_char *tmp___1 ;
  u_char *tmp___2 ;
  u_char *tmp___3 ;
  u_char *tmp___4 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
#line 208
  nchar = 0;
#line 210
  ooutfile = *outfile;
  {
#line 212
  while (1) {
    while_continue: /* CIL Label */ ;
#line 212
    tmp___3 = infile;
#line 212
    infile ++;
#line 212
    c1 = (int )*tmp___3;
#line 212
    if (! (c1 != 0)) {
#line 212
      goto while_break;
    }
#line 214
    if (c1 == 61) {
#line 216
      tmp = infile;
#line 216
      infile ++;
#line 216
      c1 = (int )*tmp;
#line 216
      if (c1 == 0) {
#line 217
        goto while_break;
      }
#line 219
      if (c1 == 10) {
#line 221
        if (state == 0) {
#line 222
          return (0);
        }
      } else {
#line 226
        tmp___0 = infile;
#line 226
        infile ++;
#line 226
        c2 = (int )*tmp___0;
#line 226
        if (c2 == 0) {
#line 227
          goto while_break;
        }
#line 229
        if (c1 < 0) {
#line 229
          c1 = -1;
        } else
#line 229
        if (c1 > 127) {
#line 229
          c1 = -1;
        } else {
#line 229
          c1 = (int )index_hex[c1];
        }
#line 230
        if (c2 < 0) {
#line 230
          c2 = -1;
        } else
#line 230
        if (c2 > 127) {
#line 230
          c2 = -1;
        } else {
#line 230
          c2 = (int )index_hex[c2];
        }
#line 232
        nchar ++;
#line 232
        if (nchar > maxlen) {
#line 233
          goto while_break;
        }
        {
#line 235
        printf((char const   */* __restrict  */)"1: outfile - ooutfile = %d  <?  MAXLINE=%d\n",
               *outfile - ooutfile, 50);
        }
#line 236
        if (! (*outfile - ooutfile < 50L)) {
          {
#line 236
          __assert_fail("*outfile - ooutfile < 50", "mime1-bad.c", 236U, "mime_fromqp");
          }
        }
#line 239
        tmp___1 = *outfile;
#line 239
        (*outfile) ++;
#line 239
        *tmp___1 = (u_char )((c1 << 4) | c2);
      }
    } else {
#line 244
      if (state == 1) {
#line 244
        if (c1 == 95) {
#line 245
          c1 = ' ';
        }
      }
#line 247
      nchar ++;
#line 247
      if (nchar > maxlen) {
#line 248
        goto while_break;
      }
      {
#line 250
      printf((char const   */* __restrict  */)"2: outfile - ooutfile = %d  <?  MAXLINE=%d\n",
             *outfile - ooutfile, 50);
      }
#line 251
      if (! (*outfile - ooutfile < 50L)) {
        {
#line 251
        __assert_fail("*outfile - ooutfile < 50", "mime1-bad.c", 251U, "mime_fromqp");
        }
      }
#line 254
      tmp___2 = *outfile;
#line 254
      (*outfile) ++;
#line 254
      *tmp___2 = (u_char )c1;
#line 256
      if (c1 == 10) {
#line 257
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 262
  printf((char const   */* __restrict  */)"3: outfile - ooutfile = %d  <?  MAXLINE=%d\n",
         *outfile - ooutfile, 50);
  }
#line 263
  if (! (*outfile - ooutfile < 50L)) {
    {
#line 263
    __assert_fail("*outfile - ooutfile < 50", "mime1-bad.c", 263U, "mime_fromqp");
    }
  }
#line 266
  tmp___4 = *outfile;
#line 266
  (*outfile) ++;
#line 266
  *tmp___4 = (u_char )'\000';
#line 267
  return (1);
}
}
#line 289 "mime1-bad.c"
char *hvalue(char *field , HDR *header ) 
{ 
  register HDR *h ;
  int tmp ;

  {
#line 295
  h = header;
  {
#line 295
  while (1) {
    while_continue: /* CIL Label */ ;
#line 295
    if (! ((unsigned long )h != (unsigned long )((void *)0))) {
#line 295
      goto while_break;
    }
#line 297
    if (! (((int )h->h_flags & 4) != 0)) {
      {
#line 297
      tmp = strcasecmp((char const   *)h->h_field, (char const   *)field);
      }
#line 297
      if (tmp == 0) {
#line 299
        return (h->h_value);
      }
    }
#line 295
    h = h->h_link;
  }
  while_break: /* CIL Label */ ;
  }
#line 301
  return ((char *)((void *)0));
}
}
#line 238 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 273
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 68 "main.c"
int main(int argc , char **argv ) 
{ 
  HDR *header ;
  register ENVELOPE *e ;
  FILE *temp ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 74
  if (! (argc == 2)) {
    {
#line 74
    __assert_fail("argc == 2", "main.c", 74U, "main");
    }
  }
  {
#line 75
  temp = fopen((char const   */* __restrict  */)*(argv + 1), (char const   */* __restrict  */)"r");
  }
#line 76
  if (! ((unsigned long )temp != (unsigned long )((void *)0))) {
    {
#line 76
    __assert_fail("temp != ((void *)0)", "main.c", 76U, "main");
    }
  }
  {
#line 78
  tmp = malloc(sizeof(struct header ));
#line 78
  header = (HDR *)tmp;
#line 80
  tmp___0 = malloc(sizeof(char ) * 100UL);
#line 80
  header->h_field = (char *)tmp___0;
#line 81
  header->h_field = (char *)"Content-Transfer-Encoding";
#line 82
  tmp___1 = malloc(sizeof(char ) * 100UL);
#line 82
  header->h_value = (char *)tmp___1;
#line 83
  header->h_value = (char *)"quoted-printable";
#line 85
  tmp___2 = malloc(sizeof(struct envelope ));
#line 85
  e = (ENVELOPE *)tmp___2;
#line 87
  tmp___3 = malloc(sizeof(char ) * 50UL);
#line 87
  e->e_id = (char *)tmp___3;
#line 88
  e->e_id = (char *)"First Entry";
#line 91
  e->e_dfp = temp;
#line 92
  mime7to8(header, e);
#line 94
  fclose(temp);
  }
#line 96
  return (0);
}
}
