/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __useconds_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 49 "/home/june/repo/benchmarks/collector/temp/hdapsd-20090401/src/hdapsd.h"
enum interfaces {
    INTERFACE_NONE = 0,
    INTERFACE_HDAPS = 1,
    INTERFACE_AMS = 2
} ;
#line 57
enum kernel {
    PROTECT = 0,
    UNLOAD_HEADS = 1
} ;
#line 62 "/home/june/repo/benchmarks/collector/temp/hdapsd-20090401/src/hdapsd.h"
struct list {
   char name[40] ;
   char protect_file[4096] ;
   struct list *next ;
};
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 48 "/usr/include/x86_64-linux-gnu/sys/utsname.h"
struct utsname {
   char sysname[65] ;
   char nodename[65] ;
   char release[65] ;
   char version[65] ;
   char machine[65] ;
   char __domainname[65] ;
};
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 104 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 23 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 25 "/usr/include/asm-generic/int-ll64.h"
typedef int __s32;
#line 22 "/usr/include/linux/input.h"
struct input_event {
   struct timeval time ;
   __u16 type ;
   __u16 code ;
   __s32 value ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 390
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 846
extern void perror(char const   *__s ) ;
#line 55 "/home/june/repo/benchmarks/collector/temp/hdapsd-20090401/src/hdapsd.h"
char *interface_names[3]  = {      (char *)"none",      (char *)"HDAPS",      (char *)"AMS"};
#line 1 "/home/june/repo/benchmarks/collector/temp/hdapsd-20090401/src/input-helper.h"
int device_open(int id ) ;
#line 2
int device_find_byphys(char *phys ) ;
#line 3
int device_find_byname(char *name ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 717
extern int system(char const   *__command ) ;
#line 287 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *__name ,
                                                                                             int __type ) ;
#line 353
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 444
extern unsigned int sleep(unsigned int __seconds ) ;
#line 460
extern int usleep(__useconds_t __useconds ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 937 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) daemon)(int __nochdir ,
                                                                             int __noclose ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 264
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) ctime)(time_t const   *__timer ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 124 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 81 "/usr/include/x86_64-linux-gnu/sys/utsname.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) uname)(struct utsname *__name ) ;
#line 111 "/usr/include/x86_64-linux-gnu/sys/mman.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) mlockall)(int __flags ) ;
#line 115
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) munlockall)(void) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 173 "/usr/include/getopt.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long)(int ___argc ,
                                                                                  char * const  *___argv ,
                                                                                  char const   *__shortopts ,
                                                                                  struct option  const  *__longopts ,
                                                                                  int *__longind ) ;
#line 175 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void closelog(void) ;
#line 181
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 190
extern void ( /* format attribute */  syslog)(int __pri , char const   *__fmt  , ...) ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 162
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 52 "/home/june/repo/benchmarks/collector/temp/hdapsd-20090401/src/hdapsd.c"
static int verbose  =    0;
#line 53 "/home/june/repo/benchmarks/collector/temp/hdapsd-20090401/src/hdapsd.c"
static int pause_now  =    0;
#line 54 "/home/june/repo/benchmarks/collector/temp/hdapsd-20090401/src/hdapsd.c"
static int dry_run  =    0;
#line 55 "/home/june/repo/benchmarks/collector/temp/hdapsd-20090401/src/hdapsd.c"
static int poll_sysfs  =    0;
#line 56 "/home/june/repo/benchmarks/collector/temp/hdapsd-20090401/src/hdapsd.c"
static int sampling_rate  =    0;
#line 57 "/home/june/repo/benchmarks/collector/temp/hdapsd-20090401/src/hdapsd.c"
static int running  =    1;
#line 58 "/home/june/repo/benchmarks/collector/temp/hdapsd-20090401/src/hdapsd.c"
static int background  =    0;
#line 59 "/home/june/repo/benchmarks/collector/temp/hdapsd-20090401/src/hdapsd.c"
static int dosyslog  =    0;
#line 61 "/home/june/repo/benchmarks/collector/temp/hdapsd-20090401/src/hdapsd.c"
char pid_file[4096]  = {      (char )'\000'};
#line 62 "/home/june/repo/benchmarks/collector/temp/hdapsd-20090401/src/hdapsd.c"
int hdaps_input_fd  =    0;
#line 63 "/home/june/repo/benchmarks/collector/temp/hdapsd-20090401/src/hdapsd.c"
int hdaps_input_nr  =    -1;
#line 65 "/home/june/repo/benchmarks/collector/temp/hdapsd-20090401/src/hdapsd.c"
struct list *disklist  =    (struct list *)((void *)0);
#line 66 "/home/june/repo/benchmarks/collector/temp/hdapsd-20090401/src/hdapsd.c"
enum kernel kernel_interface  =    (enum kernel )1;
#line 67 "/home/june/repo/benchmarks/collector/temp/hdapsd-20090401/src/hdapsd.c"
enum interfaces position_interface  =    (enum interfaces )0;
#line 73 "/home/june/repo/benchmarks/collector/temp/hdapsd-20090401/src/hdapsd.c"
void printlog(FILE *stream , char const   *fmt  , ...) 
{ 
  time_t now ;
  int len ;
  char *msg ;
  unsigned long __lengthofmsg ;
  void *tmp ;
  va_list ap ;
  char *tmp___0 ;

  {
  {
#line 76
  len = (int )sizeof(fmt);
#line 78
  __lengthofmsg = (unsigned long )(len + 1024);
#line 78
  tmp = __builtin_alloca(sizeof(*msg) * __lengthofmsg);
#line 78
  msg = (char *)tmp;
#line 80
  __builtin_va_start(ap, fmt);
#line 81
  vsnprintf((char */* __restrict  */)msg, (size_t )(len + 1024), (char const   */* __restrict  */)fmt,
            ap);
#line 82
  __builtin_va_end(ap);
  }
#line 84
  if (dosyslog) {
    {
#line 85
    syslog(6, (char const   *)msg);
    }
  } else {
    {
#line 87
    now = time((time_t *)((void *)0));
#line 88
    tmp___0 = ctime((time_t const   *)(& now));
#line 88
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%.24s: %s\n",
            tmp___0, msg);
    }
  }
#line 90
  return;
}
}
#line 104 "/home/june/repo/benchmarks/collector/temp/hdapsd-20090401/src/hdapsd.c"
static int slurp_file(char const   *filename , char *buf ) 
{ 
  int ret ;
  int fd ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  ssize_t tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;

  {
  {
#line 107
  tmp = open(filename, 0);
#line 107
  fd = tmp;
  }
#line 108
  if (fd < 0) {
    {
#line 109
    tmp___0 = __errno_location();
#line 109
    tmp___1 = strerror(*tmp___0);
#line 109
    printlog(stderr, "Could not open %s: %s.\nDo you have the hdaps module loaded?",
             filename, tmp___1);
    }
#line 110
    return (fd);
  }
  {
#line 113
  tmp___2 = read(fd, (void *)buf, (size_t )39);
#line 113
  ret = (int )tmp___2;
  }
#line 114
  if (ret < 0) {
    {
#line 115
    tmp___3 = __errno_location();
#line 115
    tmp___4 = strerror(*tmp___3);
#line 115
    printlog(stderr, "Could not read from %s: %s", filename, tmp___4);
    }
  } else {
#line 117
    *(buf + ret) = (char)0;
#line 118
    ret = 0;
  }
  {
#line 121
  tmp___7 = close(fd);
  }
#line 121
  if (tmp___7) {
    {
#line 122
    tmp___5 = __errno_location();
#line 122
    tmp___6 = strerror(*tmp___5);
#line 122
    printlog(stderr, "Could not close %s: %s", filename, tmp___6);
    }
  }
#line 124
  return (ret);
}
}
#line 132 "/home/june/repo/benchmarks/collector/temp/hdapsd-20090401/src/hdapsd.c"
static int read_position_from_hdaps(int *x , int *y ) 
{ 
  char buf[40] ;
  int ret ;
  int tmp ;

  {
  {
#line 136
  ret = slurp_file("/sys/devices/platform/hdaps/position", buf);
  }
#line 136
  if (ret) {
#line 137
    return (ret);
  }
  {
#line 138
  tmp = sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"(%d,%d)\n",
               x, y);
  }
#line 138
  return (tmp != 2);
}
}
#line 144 "/home/june/repo/benchmarks/collector/temp/hdapsd-20090401/src/hdapsd.c"
static int read_position_from_ams(int *x , int *y , int *z ) 
{ 
  char buf[40] ;
  int ret ;
  int tmp ;

  {
  {
#line 148
  ret = slurp_file("/sys/devices/ams/current", buf);
  }
#line 148
  if (ret) {
#line 149
    return (ret);
  }
  {
#line 150
  tmp = sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"%d %d %d\n",
               x, y, z);
  }
#line 150
  return (tmp != 3);
}
}
#line 157 "/home/june/repo/benchmarks/collector/temp/hdapsd-20090401/src/hdapsd.c"
static int read_position_from_sysfs(int *x , int *y , int *z ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 159
  if ((unsigned int )position_interface == 1U) {
    {
#line 160
    tmp = read_position_from_hdaps(x, y);
    }
#line 160
    return (tmp);
  } else
#line 161
  if ((unsigned int )position_interface == 2U) {
    {
#line 162
    tmp___0 = read_position_from_ams(x, y, z);
    }
#line 162
    return (tmp___0);
  }
#line 163
  return (-1);
}
}
#line 170 "/home/june/repo/benchmarks/collector/temp/hdapsd-20090401/src/hdapsd.c"
static int read_int(char const   *filename ) 
{ 
  char buf[40] ;
  int ret ;
  int tmp ;

  {
  {
#line 174
  ret = slurp_file(filename, buf);
  }
#line 174
  if (ret) {
#line 175
    return (ret);
  }
  {
#line 176
  tmp = sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"%d\n",
               & ret);
  }
#line 176
  if (tmp != 1) {
#line 177
    return (-5);
  }
#line 178
  return (ret);
}
}
#line 184 "/home/june/repo/benchmarks/collector/temp/hdapsd-20090401/src/hdapsd.c"
static int get_km_activity(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 186
  if ((unsigned int )position_interface != 1U) {
#line 187
    return (0);
  }
  {
#line 188
  tmp = read_int("/sys/devices/platform/hdaps/keyboard_activity");
  }
#line 188
  if (tmp == 1) {
#line 189
    return (1);
  }
  {
#line 190
  tmp___0 = read_int("/sys/devices/platform/hdaps/mouse_activity");
  }
#line 190
  if (tmp___0 == 1) {
#line 191
    return (1);
  }
#line 192
  return (0);
}
}
#line 201 "/home/june/repo/benchmarks/collector/temp/hdapsd-20090401/src/hdapsd.c"
static int read_position_from_inputdev(int *x , int *y , int *z , double *utime ) 
{ 
  struct input_event ev ;
  int len ;
  int done ;
  ssize_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
#line 204
  done = 0;
#line 205
  *utime = (double )0;
  {
#line 206
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 207
    tmp = read(hdaps_input_fd, (void *)(& ev), sizeof(struct input_event ));
#line 207
    len = (int )tmp;
    }
#line 208
    if (len < 0) {
      {
#line 209
      tmp___0 = __errno_location();
#line 209
      tmp___1 = strerror(*tmp___0);
#line 209
      printlog(stderr, "ERROR: failed reading from input device: /dev/input/event%d  (%s).",
               hdaps_input_nr, tmp___1);
      }
#line 210
      return (len);
    }
#line 212
    if (len < (int )sizeof(struct input_event )) {
      {
#line 213
      printlog(stderr, "ERROR: short read from input device: /dev/input/event%d (%d bytes).",
               hdaps_input_nr, len);
      }
#line 214
      return (-5);
    }
    {
#line 217
    if ((int )ev.type == 3) {
#line 217
      goto case_3;
    }
#line 232
    if ((int )ev.type == 0) {
#line 232
      goto case_0___0;
    }
#line 235
    goto switch_default___0;
    case_3: /* CIL Label */ 
    {
#line 219
    if ((int )ev.code == 0) {
#line 219
      goto case_0;
    }
#line 222
    if ((int )ev.code == 1) {
#line 222
      goto case_1;
    }
#line 225
    if ((int )ev.code == 2) {
#line 225
      goto case_2;
    }
#line 228
    goto switch_default;
    case_0: /* CIL Label */ 
#line 220
    *x = ev.value;
#line 221
    goto switch_break___0;
    case_1: /* CIL Label */ 
#line 223
    *y = ev.value;
#line 224
    goto switch_break___0;
    case_2: /* CIL Label */ 
#line 226
    *z = ev.value;
#line 227
    goto switch_break___0;
    switch_default: /* CIL Label */ 
#line 229
    goto while_continue;
    switch_break___0: /* CIL Label */ ;
    }
#line 231
    goto switch_break;
    case_0___0: /* CIL Label */ 
#line 233
    done = 1;
#line 234
    goto switch_break;
    switch_default___0: /* CIL Label */ 
#line 236
    goto while_continue;
    switch_break: /* CIL Label */ ;
    }
#line 238
    if (! *utime) {
#line 239
      *utime = (double )ev.time.tv_sec + (double )ev.time.tv_usec / 1000000.0;
    }
#line 240
    if (done) {
#line 241
      return (0);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 249 "/home/june/repo/benchmarks/collector/temp/hdapsd-20090401/src/hdapsd.c"
static int write_protect(char const   *path , int val ) 
{ 
  int fd ;
  int ret ;
  char buf[40] ;
  size_t tmp ;
  ssize_t tmp___0 ;
  int tmp___1 ;

  {
#line 254
  if (dry_run) {
#line 255
    return (0);
  }
  {
#line 257
  snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%d",
           val);
#line 259
  fd = open(path, 1);
  }
#line 260
  if (fd < 0) {
    {
#line 261
    printlog(stderr, "Could not open %s", path);
    }
#line 262
    return (fd);
  }
  {
#line 265
  tmp = strlen((char const   *)(buf));
#line 265
  tmp___0 = write(fd, (void const   *)(buf), tmp);
#line 265
  ret = (int )tmp___0;
  }
#line 267
  if (ret < 0) {
    {
#line 268
    printlog(stderr, "Could not write to %s.\nDoes your kernel/drive support IDLE_IMMEDIATE with UNLOAD?",
             path);
    }
#line 269
    goto out;
  }
#line 271
  ret = 0;
  out: 
  {
#line 274
  tmp___1 = close(fd);
  }
#line 274
  if (tmp___1) {
    {
#line 275
    printlog(stderr, "Could not close %s", path);
    }
  }
#line 277
  return (ret);
}
}
#line 280 "/home/june/repo/benchmarks/collector/temp/hdapsd-20090401/src/hdapsd.c"
double get_utime(void) 
{ 
  struct timeval tv ;
  int ret ;
  int tmp ;

  {
  {
#line 283
  tmp = gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )((void *)0));
#line 283
  ret = tmp;
  }
#line 284
  if (ret) {
    {
#line 285
    perror("gettimeofday");
#line 286
    exit(1);
    }
  }
#line 288
  return ((double )tv.tv_sec + (double )tv.tv_usec / 1000000.0);
}
}
#line 294 "/home/june/repo/benchmarks/collector/temp/hdapsd-20090401/src/hdapsd.c"
void SIGUSR1_handler(int sig ) 
{ 


  {
  {
#line 296
  signal(10, & SIGUSR1_handler);
#line 297
  pause_now = 1;
  }
#line 298
  return;
}
}
#line 303 "/home/june/repo/benchmarks/collector/temp/hdapsd-20090401/src/hdapsd.c"
void SIGTERM_handler(int sig ) 
{ 


  {
  {
#line 305
  signal(15, & SIGTERM_handler);
#line 306
  running = 0;
  }
#line 307
  return;
}
}
#line 312 "/home/june/repo/benchmarks/collector/temp/hdapsd-20090401/src/hdapsd.c"
void version(void) 
{ 


  {
  {
#line 314
  printf((char const   */* __restrict  */)"hdapsd 20090401\n");
#line 315
  exit(0);
  }
}
}
#line 321 "/home/june/repo/benchmarks/collector/temp/hdapsd-20090401/src/hdapsd.c"
void usage(void) 
{ 


  {
  {
#line 323
  printf((char const   */* __restrict  */)"Usage: hdapsd [OPTIONS]\n");
#line 324
  printf((char const   */* __restrict  */)"\n");
#line 325
  printf((char const   */* __restrict  */)"   -d --device=<device>              <device> is likely to be hda or sda.\n");
#line 326
  printf((char const   */* __restrict  */)"                                     Can be given multiple times\n");
#line 327
  printf((char const   */* __restrict  */)"                                     to protect multiple devices.\n");
#line 328
  printf((char const   */* __restrict  */)"   -f --force                        Force unloading heads, even if kernel thinks\n");
#line 329
  printf((char const   */* __restrict  */)"                                     differently (on pre ATA7 drives).\n");
#line 330
  printf((char const   */* __restrict  */)"                                     This only works when adding devices by hand (-d).\n");
#line 331
  printf((char const   */* __restrict  */)"   -s --sensitivity=<sensitivity>    How sensitive hdapsd should be to movements.\n");
#line 332
  printf((char const   */* __restrict  */)"                                     Defaults to 15, higher value means less\n");
#line 333
  printf((char const   */* __restrict  */)"                                     sensitive.\n");
#line 334
  printf((char const   */* __restrict  */)"   -a --adaptive                     Adaptive threshold (automatic increase\n");
#line 335
  printf((char const   */* __restrict  */)"                                     when the built-in keyboard/mouse are used).\n");
#line 336
  printf((char const   */* __restrict  */)"   -v --verbose                      Get verbose statistics.\n");
#line 337
  printf((char const   */* __restrict  */)"   -b --background                   Run the process in the background.\n");
#line 338
  printf((char const   */* __restrict  */)"   -p --pidfile[=<pidfile>]          Create a pid file when running\n");
#line 339
  printf((char const   */* __restrict  */)"                                     in background.\n");
#line 340
  printf((char const   */* __restrict  */)"                                     If <pidfile> is not specified,\n");
#line 341
  printf((char const   */* __restrict  */)"                                     it\'s set to %s.\n",
         "/var/run/hdapsd.pid");
#line 342
  printf((char const   */* __restrict  */)"   -t --dry-run                      Don\'t actually park the drive.\n");
#line 343
  printf((char const   */* __restrict  */)"   -y --poll-sysfs                   Force use of sysfs interface to\n");
#line 344
  printf((char const   */* __restrict  */)"                                     accelerometer.\n");
#line 345
  printf((char const   */* __restrict  */)"   -l --syslog                       Log to syslog instead of stdout/stderr.\n");
#line 346
  printf((char const   */* __restrict  */)"\n");
#line 347
  printf((char const   */* __restrict  */)"   -V --version                      Display version information and exit.\n");
#line 348
  printf((char const   */* __restrict  */)"   -h --help                         Display this message and exit.\n");
#line 349
  printf((char const   */* __restrict  */)"\n");
#line 350
  printf((char const   */* __restrict  */)"You can send SIGUSR1 to deactivate hdapsd for %d seconds.\n",
         8);
#line 352
  printf((char const   */* __restrict  */)"\n");
#line 353
  printf((char const   */* __restrict  */)"Send bugs, comments and suggestions to hdaps-devel@lists.sourceforge.net\n");
#line 354
  exit(1);
  }
}
}
#line 360 "/home/june/repo/benchmarks/collector/temp/hdapsd-20090401/src/hdapsd.c"
void check_thresh(double val_sqr , double thresh , int *above , int *near , char *reason_out ,
                  char reason_mark ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 363
  if (val_sqr > ((thresh * thresh) * 0.8) * 0.8) {
    {
#line 364
    *near = 1;
#line 365
    tmp = tolower((int )reason_mark);
#line 365
    *reason_out = (char )tmp;
    }
  }
#line 367
  if (val_sqr > thresh * thresh) {
    {
#line 368
    *above = 1;
#line 369
    tmp___0 = toupper((int )reason_mark);
#line 369
    *reason_out = (char )tmp___0;
    }
  }
#line 371
  return;
}
}
#line 392
int analyze(int x , int y , double unow , double base_threshold , int adaptive , int parked ) ;
#line 392 "/home/june/repo/benchmarks/collector/temp/hdapsd-20090401/src/hdapsd.c"
static int x_last  =    0;
#line 392 "/home/june/repo/benchmarks/collector/temp/hdapsd-20090401/src/hdapsd.c"
static int y_last  =    0;
#line 393 "/home/june/repo/benchmarks/collector/temp/hdapsd-20090401/src/hdapsd.c"
static double unow_last  =    (double )0;
#line 393 "/home/june/repo/benchmarks/collector/temp/hdapsd-20090401/src/hdapsd.c"
static double x_veloc_last  =    (double )0;
#line 393 "/home/june/repo/benchmarks/collector/temp/hdapsd-20090401/src/hdapsd.c"
static double y_veloc_last  =    (double )0;
#line 394 "/home/june/repo/benchmarks/collector/temp/hdapsd-20090401/src/hdapsd.c"
static double x_avg_veloc  =    (double )0;
#line 394 "/home/june/repo/benchmarks/collector/temp/hdapsd-20090401/src/hdapsd.c"
static double y_avg_veloc  =    (double )0;
#line 395 "/home/june/repo/benchmarks/collector/temp/hdapsd-20090401/src/hdapsd.c"
static int history  =    0;
#line 396 "/home/june/repo/benchmarks/collector/temp/hdapsd-20090401/src/hdapsd.c"
static double adaptive_threshold  =    (double )-1;
#line 397 "/home/june/repo/benchmarks/collector/temp/hdapsd-20090401/src/hdapsd.c"
static int last_thresh_change  =    0;
#line 398 "/home/june/repo/benchmarks/collector/temp/hdapsd-20090401/src/hdapsd.c"
static int last_near_thresh  =    0;
#line 399 "/home/june/repo/benchmarks/collector/temp/hdapsd-20090401/src/hdapsd.c"
static int last_km_activity  ;
#line 389 "/home/june/repo/benchmarks/collector/temp/hdapsd-20090401/src/hdapsd.c"
int analyze(int x , int y , double unow , double base_threshold , int adaptive , int parked ) 
{ 
  double udelta ;
  double x_delta ;
  double y_delta ;
  double x_veloc ;
  double y_veloc ;
  double x_accel ;
  double y_accel ;
  double veloc_sqr ;
  double accel_sqr ;
  double avg_veloc_sqr ;
  double exp_weight ;
  double threshold ;
  char reason[4] ;
  int recently_near_thresh ;
  int above ;
  int near ;
  int tmp ;

  {
#line 407
  above = 0;
#line 407
  near = 0;
#line 410
  if (adaptive_threshold < (double )0) {
#line 411
    adaptive_threshold = base_threshold;
  }
#line 412
  recently_near_thresh = unow < (double )last_near_thresh + 3.0;
#line 413
  if (adaptive) {
#line 413
    if (recently_near_thresh) {
      {
#line 413
      tmp = get_km_activity();
      }
#line 413
      if (tmp) {
#line 414
        last_km_activity = (int )unow;
      }
    }
  }
#line 415
  if (adaptive) {
#line 415
    if (unow > (double )last_thresh_change + 1.0) {
#line 416
      if (recently_near_thresh) {
#line 417
        if (last_km_activity > last_near_thresh) {
#line 417
          if (last_km_activity > last_thresh_change) {
#line 420
            adaptive_threshold *= 1.1;
#line 421
            last_thresh_change = (int )unow;
          }
        }
      } else {
#line 425
        adaptive_threshold *= 0.9985;
#line 426
        if (adaptive_threshold < base_threshold) {
#line 427
          adaptive_threshold = base_threshold;
        }
#line 428
        last_thresh_change = (int )unow;
      }
    }
  }
#line 433
  udelta = unow - unow_last;
#line 434
  x_delta = (double )(x - x_last);
#line 435
  y_delta = (double )(y - y_last);
#line 438
  x_veloc = x_delta / udelta;
#line 439
  y_veloc = y_delta / udelta;
#line 440
  veloc_sqr = x_veloc * x_veloc + y_veloc * y_veloc;
#line 443
  x_accel = (x_veloc - x_veloc_last) / udelta;
#line 444
  y_accel = (y_veloc - y_veloc_last) / udelta;
#line 445
  accel_sqr = x_accel * x_accel + y_accel * y_accel;
#line 448
  exp_weight = udelta / 0.3;
#line 449
  exp_weight = (double )1 - 1.0 / ((double )1 + exp_weight);
#line 450
  x_avg_veloc = exp_weight * x_veloc + ((double )1 - exp_weight) * x_avg_veloc;
#line 451
  y_avg_veloc = exp_weight * y_veloc + ((double )1 - exp_weight) * y_avg_veloc;
#line 452
  avg_veloc_sqr = x_avg_veloc * x_avg_veloc + y_avg_veloc * y_avg_veloc;
#line 454
  threshold = adaptive_threshold;
#line 455
  if (parked) {
#line 456
    threshold *= 0.8;
  }
  {
#line 459
  strcpy((char */* __restrict  */)(reason), (char const   */* __restrict  */)"   ");
#line 461
  check_thresh(veloc_sqr, threshold * 30.0, & above, & near, reason + 0, (char )'V');
#line 463
  check_thresh(accel_sqr, threshold * (30.0 * (double )60), & above, & near, reason + 1,
               (char )'A');
#line 465
  check_thresh(avg_veloc_sqr, threshold * 3.0, & above, & near, reason + 2, (char )'X');
  }
#line 468
  if (verbose) {
    {
#line 469
    printf((char const   */* __restrict  */)"dt=%5.3f  dpos=(%3g,%3g)  vel=(%6.1f,%6.1f)*%g  acc=(%6.1f,%6.1f)*%g  avg_vel=(%6.1f,%6.1f)*%g  thr=%.1f  %s\n",
           udelta, x_delta, y_delta, x_veloc / 30.0, y_veloc / 30.0, 30.0 * 1.0, x_accel / (30.0 * (double )60),
           y_accel / (30.0 * (double )60), (30.0 * (double )60) * 1.0, x_avg_veloc / 3.0,
           y_avg_veloc / 3.0, 3.0 * 1.0, threshold, reason);
    }
  }
#line 491
  if (udelta > 1.0) {
#line 492
    history = 0;
#line 493
    y_avg_veloc = (double )0;
#line 493
    x_avg_veloc = y_avg_veloc;
  }
#line 496
  if (history < 2) {
#line 497
    above = 0;
#line 498
    near = 0;
#line 499
    history ++;
  }
#line 502
  if (near) {
#line 503
    last_near_thresh = (int )unow;
  }
#line 505
  x_last = x;
#line 506
  y_last = y;
#line 507
  x_veloc_last = x_veloc;
#line 508
  y_veloc_last = y_veloc;
#line 509
  unow_last = unow;
#line 511
  return (above);
}
}
#line 517 "/home/june/repo/benchmarks/collector/temp/hdapsd-20090401/src/hdapsd.c"
void add_disk(char *disk ) 
{ 
  char protect_file[4096] ;
  unsigned int tmp ;
  void *tmp___0 ;
  struct list *p ;
  void *tmp___1 ;

  {
#line 519
  protect_file[0] = (char )'\000';
#line 519
  tmp = 1U;
  {
#line 519
  while (1) {
    while_continue: /* CIL Label */ ;
#line 519
    if (tmp >= 4096U) {
#line 519
      goto while_break;
    }
#line 519
    protect_file[tmp] = (char)0;
#line 519
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 520
  if ((unsigned int )kernel_interface == 1U) {
    {
#line 521
    snprintf((char */* __restrict  */)(protect_file), sizeof(protect_file), (char const   */* __restrict  */)"/sys/block/%s/device/unload_heads",
             disk);
    }
  } else {
    {
#line 523
    snprintf((char */* __restrict  */)(protect_file), sizeof(protect_file), (char const   */* __restrict  */)"/sys/block/%s/queue/protect",
             disk);
    }
  }
#line 526
  if ((unsigned long )disklist == (unsigned long )((void *)0)) {
    {
#line 527
    tmp___0 = malloc(sizeof(struct list ));
#line 527
    disklist = (struct list *)tmp___0;
    }
#line 528
    if ((unsigned long )disklist == (unsigned long )((void *)0)) {
      {
#line 529
      printlog(stderr, "Error allocating memory.");
#line 530
      exit(1);
      }
    } else {
      {
#line 533
      strncpy((char */* __restrict  */)(disklist->name), (char const   */* __restrict  */)disk,
              sizeof(disklist->name));
#line 534
      strncpy((char */* __restrict  */)(disklist->protect_file), (char const   */* __restrict  */)(protect_file),
              sizeof(disklist->protect_file));
#line 535
      disklist->next = (struct list *)((void *)0);
      }
    }
  } else {
#line 539
    p = disklist;
    {
#line 540
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 540
      if (! ((unsigned long )p->next != (unsigned long )((void *)0))) {
#line 540
        goto while_break___0;
      }
#line 541
      p = p->next;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 542
    tmp___1 = malloc(sizeof(struct list ));
#line 542
    p->next = (struct list *)tmp___1;
    }
#line 543
    if ((unsigned long )p->next == (unsigned long )((void *)0)) {
      {
#line 544
      printlog(stderr, "Error allocating memory.");
#line 545
      exit(1);
      }
    } else {
      {
#line 548
      strncpy((char */* __restrict  */)((p->next)->name), (char const   */* __restrict  */)disk,
              sizeof((p->next)->name));
#line 549
      strncpy((char */* __restrict  */)((p->next)->protect_file), (char const   */* __restrict  */)(protect_file),
              sizeof((p->next)->protect_file));
#line 550
      (p->next)->next = (struct list *)((void *)0);
      }
    }
  }
#line 553
  return;
}
}
#line 558 "/home/june/repo/benchmarks/collector/temp/hdapsd-20090401/src/hdapsd.c"
void free_disk(struct list *disk ) 
{ 


  {
#line 560
  if ((unsigned long )disk != (unsigned long )((void *)0)) {
#line 561
    if ((unsigned long )disk->next != (unsigned long )((void *)0)) {
      {
#line 562
      free_disk(disk->next);
      }
    }
    {
#line 563
    free((void *)disk);
    }
  }
#line 565
  return;
}
}
#line 570 "/home/june/repo/benchmarks/collector/temp/hdapsd-20090401/src/hdapsd.c"
int select_interface(int modprobe ) 
{ 
  int fd ;
  char *modules[3] ;
  int mod_index ;
  char command[64] ;

  {
#line 574
  modules[0] = (char *)"hdaps_ec";
#line 574
  modules[1] = (char *)"hdaps";
#line 574
  modules[2] = (char *)"ams";
#line 578
  if (modprobe) {
#line 579
    mod_index = 0;
    {
#line 579
    while (1) {
      while_continue: /* CIL Label */ ;
#line 579
      if (! ((unsigned long )mod_index < sizeof(modules) / sizeof(modules[0]))) {
#line 579
        goto while_break;
      }
      {
#line 580
      snprintf((char */* __restrict  */)(command), sizeof(command), (char const   */* __restrict  */)"modprobe %s 1>/dev/null 2>/dev/null",
               modules[mod_index]);
#line 581
      system((char const   *)(command));
#line 579
      mod_index ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 585
  fd = open("/sys/devices/platform/hdaps/position", 0);
  }
#line 586
  if (fd < 0) {
    {
#line 587
    fd = open("/sys/devices/ams/current", 0);
    }
#line 588
    if (fd < 0) {
#line 589
      position_interface = (enum interfaces )0;
    } else {
      {
#line 592
      close(fd);
#line 593
      position_interface = (enum interfaces )2;
      }
    }
  } else {
    {
#line 597
    close(fd);
#line 598
    position_interface = (enum interfaces )1;
    }
  }
#line 600
  return ((int )position_interface);
}
}
#line 606 "/home/june/repo/benchmarks/collector/temp/hdapsd-20090401/src/hdapsd.c"
int autodetect_devices(void) 
{ 
  int num_devices ;
  DIR *dp ;
  struct dirent *ep ;
  char path[4096] ;
  char removable[4096] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 608
  num_devices = 0;
#line 611
  dp = opendir("/sys/block");
  }
#line 612
  if ((unsigned long )dp != (unsigned long )((void *)0)) {
    {
#line 613
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 613
      ep = readdir(dp);
      }
#line 613
      if (! ep) {
#line 613
        goto while_break;
      }
      {
#line 616
      snprintf((char */* __restrict  */)(removable), sizeof(removable), (char const   */* __restrict  */)"/sys/block/%s/removable",
               ep->d_name);
      }
#line 618
      if ((unsigned int )kernel_interface == 1U) {
        {
#line 619
        snprintf((char */* __restrict  */)(path), sizeof(path), (char const   */* __restrict  */)"/sys/block/%s/device/unload_heads",
                 ep->d_name);
        }
      } else {
        {
#line 621
        snprintf((char */* __restrict  */)(path), sizeof(path), (char const   */* __restrict  */)"/sys/block/%s/queue/protect",
                 ep->d_name);
        }
      }
      {
#line 623
      tmp = access((char const   *)(path), 0);
      }
#line 623
      if (tmp == 0) {
        {
#line 623
        tmp___0 = read_int((char const   *)(removable));
        }
#line 623
        if (tmp___0 == 0) {
          {
#line 623
          tmp___1 = read_int((char const   *)(path));
          }
#line 623
          if (tmp___1 >= 0) {
            {
#line 624
            printlog(stdout, "Adding autodetected device: %s", ep->d_name);
#line 625
            add_disk(ep->d_name);
#line 626
            num_devices ++;
            }
          }
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 629
    closedir(dp);
    }
  }
#line 631
  return (num_devices);
}
}
#line 638 "/home/june/repo/benchmarks/collector/temp/hdapsd-20090401/src/hdapsd.c"
int main(int argc , char **argv ) 
{ 
  struct utsname sysinfo ;
  struct list *p ;
  int c ;
  int park_now ;
  int protect_factor ;
  int x ;
  int y ;
  int z ;
  int fd ;
  int i ;
  int ret ;
  int threshold ;
  int adaptive ;
  int pidfile ;
  int parked ;
  int forceadd ;
  double unow ;
  double parked_utime ;
  struct option longopts[13] ;
  int tmp ;
  int tmp___0 ;
  char protect_method[4096] ;
  unsigned int tmp___1 ;
  size_t tmp___2 ;
  ssize_t tmp___3 ;
  size_t tmp___4 ;
  ssize_t tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  char buf[40] ;
  __pid_t tmp___9 ;
  size_t tmp___10 ;
  ssize_t tmp___11 ;
  int tmp___12 ;
  char const   *tmp___13 ;
  double oldunow ;
  int oldx ;
  int oldy ;
  int oldz ;
  int tmp___14 ;

  {
  {
#line 641
  p = (struct list *)((void *)0);
#line 643
  x = 0;
#line 643
  y = 0;
#line 643
  z = 0;
#line 644
  threshold = 15;
#line 644
  adaptive = 0;
#line 644
  pidfile = 0;
#line 644
  parked = 0;
#line 644
  forceadd = 0;
#line 646
  unow = (double )0;
#line 646
  parked_utime = (double )0;
#line 648
  longopts[0].name = "device";
#line 648
  longopts[0].has_arg = 1;
#line 648
  longopts[0].flag = (int *)((void *)0);
#line 648
  longopts[0].val = 'd';
#line 648
  longopts[1].name = "sensitivity";
#line 648
  longopts[1].has_arg = 1;
#line 648
  longopts[1].flag = (int *)((void *)0);
#line 648
  longopts[1].val = 's';
#line 648
  longopts[2].name = "adaptive";
#line 648
  longopts[2].has_arg = 0;
#line 648
  longopts[2].flag = (int *)((void *)0);
#line 648
  longopts[2].val = 'a';
#line 648
  longopts[3].name = "verbose";
#line 648
  longopts[3].has_arg = 0;
#line 648
  longopts[3].flag = (int *)((void *)0);
#line 648
  longopts[3].val = 'v';
#line 648
  longopts[4].name = "background";
#line 648
  longopts[4].has_arg = 0;
#line 648
  longopts[4].flag = (int *)((void *)0);
#line 648
  longopts[4].val = 'b';
#line 648
  longopts[5].name = "pidfile";
#line 648
  longopts[5].has_arg = 2;
#line 648
  longopts[5].flag = (int *)((void *)0);
#line 648
  longopts[5].val = 'p';
#line 648
  longopts[6].name = "dry-run";
#line 648
  longopts[6].has_arg = 0;
#line 648
  longopts[6].flag = (int *)((void *)0);
#line 648
  longopts[6].val = 't';
#line 648
  longopts[7].name = "poll-sysfs";
#line 648
  longopts[7].has_arg = 0;
#line 648
  longopts[7].flag = (int *)((void *)0);
#line 648
  longopts[7].val = 'y';
#line 648
  longopts[8].name = "version";
#line 648
  longopts[8].has_arg = 0;
#line 648
  longopts[8].flag = (int *)((void *)0);
#line 648
  longopts[8].val = 'V';
#line 648
  longopts[9].name = "help";
#line 648
  longopts[9].has_arg = 0;
#line 648
  longopts[9].flag = (int *)((void *)0);
#line 648
  longopts[9].val = 'h';
#line 648
  longopts[10].name = "syslog";
#line 648
  longopts[10].has_arg = 0;
#line 648
  longopts[10].flag = (int *)((void *)0);
#line 648
  longopts[10].val = 'l';
#line 648
  longopts[11].name = "force";
#line 648
  longopts[11].has_arg = 0;
#line 648
  longopts[11].flag = (int *)((void *)0);
#line 648
  longopts[11].val = 'f';
#line 648
  longopts[12].name = (char const   *)((void *)0);
#line 648
  longopts[12].has_arg = 0;
#line 648
  longopts[12].flag = (int *)((void *)0);
#line 648
  longopts[12].val = 0;
#line 665
  tmp = uname(& sysinfo);
  }
#line 665
  if (tmp < 0) {
#line 666
    protect_factor = 1000;
#line 667
    kernel_interface = (enum kernel )1;
  } else {
    {
#line 665
    tmp___0 = strcmp("2.6.27", (char const   *)(sysinfo.release));
    }
#line 665
    if (tmp___0 <= 0) {
#line 666
      protect_factor = 1000;
#line 667
      kernel_interface = (enum kernel )1;
    } else {
#line 670
      protect_factor = 1;
#line 671
      kernel_interface = (enum kernel )0;
    }
  }
  {
#line 674
  openlog("hdapsd", 1, 3 << 3);
  }
  {
#line 676
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 676
    c = getopt_long(argc, (char * const  *)argv, "d:s:vbap::tyVhlf", (struct option  const  *)(longopts),
                    (int *)((void *)0));
    }
#line 676
    if (! (c != -1)) {
#line 676
      goto while_break;
    }
    {
#line 678
    if (c == 100) {
#line 678
      goto case_100;
    }
#line 681
    if (c == 115) {
#line 681
      goto case_115;
    }
#line 684
    if (c == 98) {
#line 684
      goto case_98;
    }
#line 687
    if (c == 97) {
#line 687
      goto case_97;
    }
#line 690
    if (c == 118) {
#line 690
      goto case_118;
    }
#line 693
    if (c == 112) {
#line 693
      goto case_112;
    }
#line 701
    if (c == 116) {
#line 701
      goto case_116;
    }
#line 705
    if (c == 121) {
#line 705
      goto case_121;
    }
#line 708
    if (c == 86) {
#line 708
      goto case_86;
    }
#line 711
    if (c == 108) {
#line 711
      goto case_108;
    }
#line 714
    if (c == 102) {
#line 714
      goto case_102;
    }
#line 718
    goto switch_default;
    case_100: /* CIL Label */ 
    {
#line 679
    add_disk(optarg);
    }
#line 680
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 682
    threshold = atoi((char const   *)optarg);
    }
#line 683
    goto switch_break;
    case_98: /* CIL Label */ 
#line 685
    background = 1;
#line 686
    goto switch_break;
    case_97: /* CIL Label */ 
#line 688
    adaptive = 1;
#line 689
    goto switch_break;
    case_118: /* CIL Label */ 
#line 691
    verbose = 1;
#line 692
    goto switch_break;
    case_112: /* CIL Label */ 
#line 694
    pidfile = 1;
#line 695
    if ((unsigned long )optarg == (unsigned long )((void *)0)) {
      {
#line 696
      snprintf((char */* __restrict  */)(pid_file), sizeof(pid_file), (char const   */* __restrict  */)"%s",
               "/var/run/hdapsd.pid");
      }
    } else {
      {
#line 698
      snprintf((char */* __restrict  */)(pid_file), sizeof(pid_file), (char const   */* __restrict  */)"%s",
               optarg);
      }
    }
#line 700
    goto switch_break;
    case_116: /* CIL Label */ 
    {
#line 702
    printlog(stdout, "Dry run, will not actually park heads or freeze queue.");
#line 703
    dry_run = 1;
    }
#line 704
    goto switch_break;
    case_121: /* CIL Label */ 
#line 706
    poll_sysfs = 1;
#line 707
    goto switch_break;
    case_86: /* CIL Label */ 
    {
#line 709
    version();
    }
#line 710
    goto switch_break;
    case_108: /* CIL Label */ 
#line 712
    dosyslog = 1;
#line 713
    goto switch_break;
    case_102: /* CIL Label */ 
#line 715
    forceadd = 1;
#line 716
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 719
    usage();
    }
#line 720
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 724
  printlog(stdout, "Starting hdapsd");
  }
#line 726
  if (disklist) {
#line 726
    if (forceadd) {
#line 727
      protect_method[0] = (char )'\000';
#line 727
      tmp___1 = 1U;
      {
#line 727
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 727
        if (tmp___1 >= 4096U) {
#line 727
          goto while_break___0;
        }
#line 727
        protect_method[tmp___1] = (char)0;
#line 727
        tmp___1 ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 728
      p = disklist;
      {
#line 729
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 729
        if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 729
          goto while_break___1;
        }
        {
#line 730
        snprintf((char */* __restrict  */)(protect_method), sizeof(protect_method),
                 (char const   */* __restrict  */)"/sys/block/%s/queue/protect_method",
                 p->name);
        }
#line 731
        if ((unsigned int )kernel_interface == 1U) {
          {
#line 732
          fd = open((char const   *)(p->protect_file), 2);
          }
        } else {
          {
#line 734
          fd = open((char const   *)(protect_method), 2);
          }
        }
#line 735
        if (fd > 0) {
#line 736
          if ((unsigned int )kernel_interface == 1U) {
            {
#line 737
            tmp___2 = strlen("-1");
#line 737
            tmp___3 = write(fd, (void const   *)"-1", tmp___2);
#line 737
            ret = (int )tmp___3;
            }
          } else {
            {
#line 739
            tmp___4 = strlen("unload");
#line 739
            tmp___5 = write(fd, (void const   *)"unload", tmp___4);
#line 739
            ret = (int )tmp___5;
            }
          }
#line 740
          if (ret == -1) {
            {
#line 741
            printlog(stderr, "Could not forcely enable UNLOAD feature for %s", p->name);
            }
          } else {
            {
#line 743
            printlog(stdout, "Forcely enabled UNLOAD for %s", p->name);
            }
          }
          {
#line 744
          close(fd);
          }
        } else {
          {
#line 747
          printlog(stderr, "Could not open %s for forcely enabling UNLOAD feature",
                   p->protect_file);
          }
        }
#line 749
        p = p->next;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  }
#line 753
  if ((unsigned long )disklist == (unsigned long )((void *)0)) {
    {
#line 754
    printlog(stdout, "WARNING: You did not supply any devices to protect, trying autodetection.");
#line 755
    tmp___6 = autodetect_devices();
    }
#line 755
    if (tmp___6 < 1) {
      {
#line 756
      printlog(stderr, "Could not detect any devices.");
      }
    }
  }
#line 759
  if ((unsigned long )disklist == (unsigned long )((void *)0)) {
    {
#line 760
    usage(argv);
    }
  }
  {
#line 763
  select_interface(0);
  }
#line 764
  if (! position_interface) {
    {
#line 765
    select_interface(1);
    }
  }
#line 767
  if (! position_interface) {
    {
#line 768
    printlog(stdout, "Could not find a suitable interface");
    }
#line 769
    return (-1);
  } else {
    {
#line 772
    printlog(stdout, "Selected interface: %s", interface_names[position_interface]);
    }
  }
#line 774
  if (! poll_sysfs) {
#line 775
    if ((unsigned int )position_interface == 1U) {
      {
#line 776
      hdaps_input_nr = device_find_byphys((char *)"hdaps/input1");
#line 777
      hdaps_input_fd = device_open(hdaps_input_nr);
      }
#line 778
      if (hdaps_input_fd < 0) {
        {
#line 779
        tmp___7 = __errno_location();
#line 779
        tmp___8 = strerror(*tmp___7);
#line 779
        printlog(stdout, "WARNING: Could not find hdaps input device (%s). You may be using an incompatible version of the hdaps module. Falling back to reading the position from sysfs (uses more power).\nUse \'-y\' to silence this warning.",
                 tmp___8);
#line 785
        poll_sysfs = 1;
        }
      } else {
        {
#line 788
        printlog(stdout, "Selected HDAPS input device: /dev/input/event%d", hdaps_input_nr);
        }
      }
    } else
#line 790
    if ((unsigned int )position_interface == 2U) {
      {
#line 791
      hdaps_input_nr = device_find_byname((char *)"Apple Motion Sensor");
#line 792
      hdaps_input_fd = device_open(hdaps_input_nr);
      }
#line 793
      if (hdaps_input_fd < 0) {
        {
#line 794
        printlog(stdout, "WARNING: Could not find AMS input device, do you need to set joystick=1?");
#line 796
        poll_sysfs = 1;
        }
      } else {
        {
#line 799
        printlog(stdout, "Selected AMS input device /dev/input/event%d", hdaps_input_nr);
        }
      }
    }
  }
#line 804
  if (background) {
#line 805
    verbose = 0;
#line 806
    if (pidfile) {
      {
#line 807
      fd = open((char const   *)(pid_file), 65, 420);
      }
#line 808
      if (fd < 0) {
        {
#line 809
        printlog(stderr, "Could not create pidfile: %s", pid_file);
        }
#line 810
        return (1);
      }
    }
    {
#line 813
    daemon(0, 0);
    }
#line 814
    if (pidfile) {
      {
#line 816
      tmp___9 = getpid();
#line 816
      snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%d\n",
               tmp___9);
#line 817
      tmp___10 = strlen((char const   *)(buf));
#line 817
      tmp___11 = write(fd, (void const   *)(buf), tmp___10);
#line 817
      ret = (int )tmp___11;
      }
#line 818
      if (ret < 0) {
        {
#line 819
        printlog(stderr, "Could not write to pidfile %s", pid_file);
        }
#line 820
        return (1);
      }
      {
#line 822
      tmp___12 = close(fd);
      }
#line 822
      if (tmp___12) {
        {
#line 823
        printlog(stderr, "Could not close pidfile %s", pid_file);
        }
#line 824
        return (1);
      }
    }
  }
  {
#line 829
  mlockall(2);
  }
#line 831
  if (verbose) {
#line 832
    p = disklist;
    {
#line 833
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 833
      if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 833
        goto while_break___2;
      }
      {
#line 834
      printf((char const   */* __restrict  */)"disk: %s\n", p->name);
#line 835
      p = p->next;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 837
    printf((char const   */* __restrict  */)"threshold: %i\n", threshold);
    }
#line 838
    if (poll_sysfs) {
#line 838
      tmp___13 = "poll-sysfs";
    } else {
#line 838
      tmp___13 = "input-dev";
    }
    {
#line 838
    printf((char const   */* __restrict  */)"read_method: %s\n", tmp___13);
    }
  }
#line 843
  p = disklist;
  {
#line 844
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 844
    if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 844
      if (! (! dry_run)) {
#line 844
        goto while_break___3;
      }
    } else {
#line 844
      goto while_break___3;
    }
    {
#line 845
    fd = open((char const   *)(p->protect_file), 2);
    }
#line 846
    if (background) {
#line 847
      i = 0;
      {
#line 847
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 847
        if (fd < 0) {
#line 847
          if (! (i < 100)) {
#line 847
            goto while_break___4;
          }
        } else {
#line 847
          goto while_break___4;
        }
        {
#line 848
        usleep((__useconds_t )100000);
#line 849
        fd = open((char const   *)(p->protect_file), 2);
#line 847
        i ++;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
    }
#line 851
    if (fd < 0) {
      {
#line 852
      printlog(stderr, "Could not open %s\nDoes your kernel/drive support IDLE_IMMEDIATE with UNLOAD?",
               p->protect_file);
#line 853
      free_disk(disklist);
      }
#line 854
      return (1);
    }
    {
#line 856
    close(fd);
#line 857
    p = p->next;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 862
  ret = read_position_from_sysfs(& x, & y, & z);
  }
#line 863
  if (background) {
#line 864
    i = 0;
    {
#line 864
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 864
      if (ret) {
#line 864
        if (! (i < 100)) {
#line 864
          goto while_break___5;
        }
      } else {
#line 864
        goto while_break___5;
      }
      {
#line 865
      usleep((__useconds_t )100000);
#line 866
      ret = read_position_from_sysfs(& x, & y, & z);
#line 864
      i ++;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
  }
#line 868
  if (ret) {
    {
#line 869
    printlog(stderr, "Could not read position from sysfs.");
    }
#line 870
    return (1);
  }
#line 874
  if ((unsigned int )position_interface == 1U) {
    {
#line 875
    sampling_rate = read_int("/sys/devices/platform/hdaps/sampling_rate");
    }
  }
#line 876
  if (sampling_rate <= 0) {
#line 877
    sampling_rate = 50;
  }
#line 878
  if (verbose) {
    {
#line 879
    printf((char const   */* __restrict  */)"sampling_rate: %d\n", sampling_rate);
    }
  }
  {
#line 881
  signal(10, & SIGUSR1_handler);
#line 883
  signal(15, & SIGTERM_handler);
  }
  {
#line 885
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 885
    if (! running) {
#line 885
      goto while_break___6;
    }
#line 886
    if (poll_sysfs) {
      {
#line 887
      usleep((__useconds_t )(1000000 / sampling_rate));
#line 888
      ret = read_position_from_sysfs(& x, & y, & z);
#line 889
      unow = get_utime();
      }
    } else {
      {
#line 891
      oldunow = unow;
#line 892
      oldx = x;
#line 892
      oldy = y;
#line 892
      oldz = z;
#line 893
      ret = read_position_from_inputdev(& x, & y, & z, & unow);
      }
#line 899
      if (! ret) {
#line 899
        if (oldunow) {
#line 899
          if (unow - oldunow > 1.5 / (double )sampling_rate) {
            {
#line 900
            analyze(oldx, oldy, unow - 1.0 / (double )sampling_rate, (double )threshold,
                    adaptive, parked);
            }
          }
        }
      }
    }
#line 904
    if (ret) {
#line 905
      if (verbose) {
        {
#line 906
        printf((char const   */* __restrict  */)"readout error (%d)\n", ret);
        }
      }
#line 907
      goto while_continue___6;
    }
    {
#line 910
    park_now = analyze(x, y, unow, (double )threshold, adaptive, parked);
    }
#line 912
    if (park_now) {
#line 912
      if (! pause_now) {
#line 913
        if (! parked) {
#line 913
          goto _L;
        } else
#line 913
        if (unow > parked_utime + 0.1) {
          _L: /* CIL Label */ 
#line 915
          p = disklist;
          {
#line 916
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 916
            if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 916
              goto while_break___7;
            }
            {
#line 917
            write_protect((char const   *)(p->protect_file), 5 * protect_factor);
#line 919
            p = p->next;
            }
          }
          while_break___7: /* CIL Label */ ;
          }
#line 925
          if (! parked) {
            {
#line 926
            printlog(stdout, "parking");
            }
          }
#line 927
          parked = 1;
#line 928
          parked_utime = unow;
        }
      } else {
#line 912
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
#line 931
      if (parked) {
#line 931
        if (pause_now) {
#line 931
          goto _L___0;
        } else
#line 931
        if (unow > parked_utime + (double )1) {
          _L___0: /* CIL Label */ 
#line 934
          p = disklist;
          {
#line 935
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 935
            if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 935
              goto while_break___8;
            }
#line 936
            if (! dry_run) {
              {
#line 936
              tmp___14 = read_int((char const   *)(p->protect_file));
              }
#line 936
              if (! tmp___14) {
                {
#line 937
                printlog(stderr, "Error! Not parked when we thought we were... (paged out and timer expired?)");
                }
              }
            }
            {
#line 941
            write_protect((char const   *)(p->protect_file), 0);
#line 942
            p = p->next;
            }
          }
          while_break___8: /* CIL Label */ ;
          }
          {
#line 944
          parked = 0;
#line 945
          printlog(stdout, "un-parking");
          }
        }
      }
      {
#line 947
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 947
        if (! pause_now) {
#line 947
          goto while_break___9;
        }
        {
#line 948
        pause_now = 0;
#line 949
        printlog(stdout, "pausing for %d seconds", 8);
#line 950
        sleep(8U);
        }
      }
      while_break___9: /* CIL Label */ ;
      }
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 956
  free_disk(disklist);
#line 957
  printlog(stdout, "Terminating hdapsd");
#line 958
  closelog();
  }
#line 959
  if (pidfile) {
    {
#line 960
    unlink((char const   *)(pid_file));
    }
  }
  {
#line 961
  munlockall();
  }
#line 962
  return (ret);
}
}
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/hdapsd-20090401/src/input-helper.c"
int device_open(int id ) 
{ 
  char node[32] ;
  int fd ;

  {
  {
#line 32
  snprintf((char */* __restrict  */)(node), (size_t )32, (char const   */* __restrict  */)"/dev/input/event%d",
           id);
#line 33
  fd = open((char const   *)(node), 0);
  }
#line 34
  if (fd < 0) {
#line 35
    return (-1);
  }
#line 37
  return (fd);
}
}
#line 40 "/home/june/repo/benchmarks/collector/temp/hdapsd-20090401/src/input-helper.c"
int device_find_byphys(char *phys ) 
{ 
  int fd ;
  int i ;
  int rc ;
  char buf[1024] ;
  int tmp ;

  {
#line 44
  i = 0;
  {
#line 44
  while (1) {
    while_continue: /* CIL Label */ ;
#line 44
    if (! (i < 32)) {
#line 44
      goto while_break;
    }
    {
#line 45
    fd = device_open(i);
    }
#line 46
    if (fd > 0) {
      {
#line 47
      rc = ioctl(fd, (unsigned long )(((2U << 30) | (unsigned int )(69 << 8)) | 7U) | (sizeof(buf) << 16),
                 buf);
      }
#line 48
      if (rc >= 0) {
        {
#line 48
        tmp = strcmp((char const   *)phys, (char const   *)(buf));
        }
#line 48
        if (tmp == 0) {
          {
#line 49
          close(fd);
          }
#line 50
          return (i);
        }
      }
    }
    {
#line 53
    close(fd);
#line 44
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 55
  return (-1);
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/hdapsd-20090401/src/input-helper.c"
int device_find_byname(char *name ) 
{ 
  int fd ;
  int i ;
  int rc ;
  char buf[1024] ;
  int tmp ;

  {
#line 62
  i = 0;
  {
#line 62
  while (1) {
    while_continue: /* CIL Label */ ;
#line 62
    if (! (i < 32)) {
#line 62
      goto while_break;
    }
    {
#line 63
    fd = device_open(i);
    }
#line 64
    if (fd > 0) {
      {
#line 65
      rc = ioctl(fd, (unsigned long )(((2U << 30) | (unsigned int )(69 << 8)) | 6U) | (sizeof(buf) << 16),
                 buf);
      }
#line 66
      if (rc >= 0) {
        {
#line 66
        tmp = strcmp((char const   *)name, (char const   *)(buf));
        }
#line 66
        if (tmp == 0) {
          {
#line 67
          close(fd);
          }
#line 68
          return (i);
        }
      }
    }
    {
#line 71
    close(fd);
#line 62
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 73
  return (-1);
}
}
