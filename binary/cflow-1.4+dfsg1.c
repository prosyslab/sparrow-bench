/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 896 "/usr/include/stdio.h"
struct obstack;
#line 144 "../gnu/obstack.h"
struct _obstack_chunk {
   char *limit ;
   struct _obstack_chunk *prev ;
   char contents[4] ;
};
#line 151 "../gnu/obstack.h"
union __anonunion_temp_29 {
   long tempint ;
   void *tempptr ;
};
#line 151 "../gnu/obstack.h"
struct obstack {
   long chunk_size ;
   struct _obstack_chunk *chunk ;
   char *object_base ;
   char *next_free ;
   char *chunk_limit ;
   union __anonunion_temp_29 temp ;
   int alignment_mask ;
   struct _obstack_chunk *(*chunkfun)(void * , long  ) ;
   void (*freefun)(void * , struct _obstack_chunk * ) ;
   void *extra_arg ;
   unsigned int use_extra_arg : 1 ;
   unsigned int maybe_empty_object : 1 ;
   unsigned int alloc_failed : 1 ;
};
#line 48 "./cflow.h"
struct linked_list;
#line 48 "./cflow.h"
struct linked_list_entry {
   struct linked_list_entry *next ;
   struct linked_list_entry *prev ;
   struct linked_list *list ;
   void *data ;
};
#line 56 "./cflow.h"
struct linked_list {
   void (*free_data)(void * ) ;
   struct linked_list_entry *head ;
   struct linked_list_entry *tail ;
};
#line 63
enum symtype {
    SymUndefined = 0,
    SymToken = 1,
    SymIdentifier = 2
} ;
#line 69
enum storage {
    ExternStorage = 0,
    ExplicitExternStorage = 1,
    StaticStorage = 2,
    AutoStorage = 3,
    AnyStorage = 4
} ;
#line 82
enum symbol_flag {
    symbol_none = 0,
    symbol_temp = 1,
    symbol_parm = 2,
    symbol_alias = 3
} ;
#line 90
struct symbol;
#line 90 "./cflow.h"
typedef struct symbol Symbol;
#line 92
struct table_entry;
#line 92 "./cflow.h"
struct symbol {
   struct table_entry *owner ;
   Symbol *next ;
   struct linked_list_entry *entry ;
   enum symtype type ;
   char *name ;
   enum symbol_flag flag ;
   struct symbol *alias ;
   int active ;
   int expand_line ;
   int token_type ;
   char *source ;
   int def_line ;
   struct linked_list *ref_line ;
   int level ;
   char *decl ;
   enum storage storage ;
   int arity ;
   int recursive ;
   size_t ord ;
   struct linked_list *caller ;
   struct linked_list *callee ;
};
#line 40 "./parser.h"
struct __anonstruct_YYSTYPE_34 {
   char *str ;
};
#line 40 "./parser.h"
typedef struct __anonstruct_YYSTYPE_34 YYSTYPE;
#line 82 "c.c"
typedef short flex_int16_t;
#line 83 "c.c"
typedef int flex_int32_t;
#line 201
struct yy_buffer_state;
#line 201 "c.c"
typedef struct yy_buffer_state *YY_BUFFER_STATE;
#line 238 "c.c"
typedef size_t yy_size_t;
#line 243 "c.c"
struct yy_buffer_state {
   FILE *yy_input_file ;
   char *yy_ch_buf ;
   char *yy_buf_pos ;
   yy_size_t yy_buf_size ;
   int yy_n_chars ;
   int yy_is_our_buffer ;
   int yy_is_interactive ;
   int yy_at_bol ;
   int yy_bs_lineno ;
   int yy_bs_column ;
   int yy_fill_buffer ;
   int yy_buffer_status ;
};
#line 416 "c.c"
typedef unsigned char YY_CHAR;
#line 420 "c.c"
typedef int yy_state_type;
#line 217 "./cflow.h"
enum __anonenum_cflow_output_command_32 {
    cflow_output_init = 0,
    cflow_output_begin = 1,
    cflow_output_end = 2,
    cflow_output_newline = 3,
    cflow_output_separator = 4,
    cflow_output_symbol = 5,
    cflow_output_text = 6
} ;
#line 217 "./cflow.h"
typedef enum __anonenum_cflow_output_command_32 cflow_output_command;
#line 227 "./cflow.h"
struct output_symbol {
   int direct ;
   int level ;
   int last ;
   Symbol *sym ;
};
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 98 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 94 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-fmtstream.h"
struct argp_fmtstream {
   FILE *stream ;
   size_t lmargin ;
   size_t rmargin ;
   ssize_t wmargin ;
   size_t point_offs ;
   ssize_t point_col ;
   char *buf ;
   char *p ;
   char *end ;
};
#line 111 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-fmtstream.h"
typedef struct argp_fmtstream *argp_fmtstream_t;
#line 68 "/usr/include/errno.h"
typedef int error_t;
#line 47 "../gnu/hash.h"
struct hash_tuning {
   float shrink_threshold ;
   float shrink_factor ;
   float growth_threshold ;
   float growth_factor ;
   _Bool is_n_buckets ;
};
#line 59 "../gnu/hash.h"
typedef struct hash_tuning Hash_tuning;
#line 61
struct hash_table;
#line 63 "../gnu/hash.h"
typedef struct hash_table Hash_table;
#line 42 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/symbol.c"
struct table_entry {
   Symbol *sym ;
};
#line 280 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/symbol.c"
struct collect_data {
   Symbol **sym ;
   int (*sel)(Symbol *p ) ;
   size_t index ;
};
#line 80 "../gnu/argp.h"
struct argp_option {
   char const   *name ;
   int key ;
   char const   *arg ;
   int flags ;
   char const   *doc ;
   int group ;
};
#line 154
struct argp;
#line 155
struct argp_state;
#line 156
struct argp_child;
#line 228 "../gnu/argp.h"
struct argp {
   struct argp_option  const  *options ;
   error_t (*parser)(int key , char *arg , struct argp_state *state ) ;
   char const   *args_doc ;
   char const   *doc ;
   struct argp_child  const  *children ;
   char *(*help_filter)(int __key , char const   *__text , void *__input ) ;
   char const   *argp_domain ;
};
#line 296 "../gnu/argp.h"
struct argp_child {
   struct argp  const  *argp ;
   int flags ;
   char const   *header ;
   int group ;
};
#line 321 "../gnu/argp.h"
struct argp_state {
   struct argp  const  *root_argp ;
   int argc ;
   char **argv ;
   int next ;
   unsigned int flags ;
   unsigned int arg_num ;
   int quoted ;
   void *input ;
   void **child_inputs ;
   void *hook ;
   char *name ;
   FILE *err_stream ;
   FILE *out_stream ;
   void *pstate ;
};
#line 170 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/main.c"
struct option_type {
   char *str ;
   int min_match ;
   int type ;
};
#line 184 "./getopt.h"
struct rpl_option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 36 "./getopt_int.h"
enum __anonenum___ordering_24 {
    REQUIRE_ORDER = 0,
    PERMUTE = 1,
    RETURN_IN_ORDER = 2
} ;
#line 36 "./getopt_int.h"
struct _getopt_data {
   int rpl_optind ;
   int rpl_opterr ;
   int rpl_optopt ;
   char *rpl_optarg ;
   int __initialized ;
   char *__nextchar ;
   enum __anonenum___ordering_24 __ordering ;
   int __posixly_correct ;
   int __first_nonopt ;
   int __last_nonopt ;
};
#line 195 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-parse.c"
struct group {
   error_t (*parser)(int key , char *arg , struct argp_state *state ) ;
   struct argp  const  *argp ;
   char *short_end ;
   unsigned int args_processed ;
   struct group *parent ;
   unsigned int parent_index ;
   void *input ;
   void **child_inputs ;
   void *hook ;
};
#line 242 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-parse.c"
struct parser {
   struct argp  const  *argp ;
   char *short_opts ;
   struct rpl_option *long_opts ;
   struct _getopt_data opt_data ;
   struct group *groups ;
   struct group *egroup ;
   void **child_inputs ;
   int try_getopt ;
   struct argp_state state ;
   void *storage ;
};
#line 277 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-parse.c"
struct parser_convert_state {
   struct parser *parser ;
   char *short_end ;
   struct rpl_option *long_end ;
   void **child_inputs_end ;
};
#line 418 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-parse.c"
struct parser_sizes {
   size_t short_len ;
   size_t long_len ;
   size_t num_groups ;
   size_t num_child_inputs ;
};
#line 492 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-parse.c"
struct __anonstruct_32 {
   char c ;
   struct rpl_option x ;
};
#line 492 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-parse.c"
struct __anonstruct_34 {
   char c ;
   struct rpl_option x ;
};
#line 492 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-parse.c"
struct __anonstruct_36 {
   char c ;
   struct rpl_option x ;
};
#line 77 "./cflow.h"
struct __anonstruct_Ref_31 {
   int line ;
   char *source ;
};
#line 77 "./cflow.h"
typedef struct __anonstruct_Ref_31 Ref;
#line 250
struct cflow_depmap;
#line 250 "./cflow.h"
typedef struct cflow_depmap *cflow_depmap_t;
#line 62 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/output.c"
struct output_driver {
   char *name ;
   int (*handler)(cflow_output_command cmd , FILE *outfile , int line , void *data ,
                  void *handler_data ) ;
   void *handler_data ;
};
#line 79 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-help.c"
struct uparams {
   int dup_args ;
   int dup_args_note ;
   int short_opt_col ;
   int long_opt_col ;
   int doc_opt_col ;
   int opt_doc_col ;
   int header_col ;
   int usage_indent ;
   int rmargin ;
   int valid ;
};
#line 113 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-help.c"
struct uparam_name {
   char const   *name ;
   int is_bool ;
   size_t uparams_offs ;
};
#line 352
struct hol_cluster;
#line 354 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-help.c"
struct hol_entry {
   struct argp_option  const  *opt ;
   unsigned int num ;
   char *short_options ;
   int group ;
   struct hol_cluster *cluster ;
   struct argp  const  *argp ;
   unsigned int ord ;
};
#line 385 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-help.c"
struct hol_cluster {
   char const   *header ;
   int index ;
   int group ;
   struct hol_cluster *parent ;
   struct argp  const  *argp ;
   int depth ;
   struct hol_cluster *next ;
};
#line 415 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-help.c"
struct hol {
   struct hol_entry *entries ;
   unsigned int num_entries ;
   char *short_options ;
   struct hol_cluster *clusters ;
};
#line 979 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-help.c"
struct hol_help_state {
   struct hol_entry *prev_entry ;
   int sep_groups ;
   int suppressed_dup_arg ;
};
#line 996 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-help.c"
struct pentry_state {
   struct hol_entry  const  *entry ;
   argp_fmtstream_t stream ;
   struct hol_help_state *hhstate ;
   int first ;
   struct argp_state  const  *state ;
};
#line 76 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/depmap.c"
struct cflow_depmap {
   size_t nrows ;
   size_t rowlen ;
   unsigned int r[1] ;
};
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 22 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/parser.c"
struct __anonstruct_Ident_34 {
   char *name ;
   int type_end ;
   int parmcnt ;
   int line ;
   enum storage storage ;
};
#line 22 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/parser.c"
typedef struct __anonstruct_Ident_34 Ident;
#line 57 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/parser.c"
struct __anonstruct_TOKSTK_35 {
   int type ;
   char *token ;
   int line ;
};
#line 57 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/parser.c"
typedef struct __anonstruct_TOKSTK_35 TOKSTK;
#line 63 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/parser.c"
typedef int Stackpos[1];
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 386 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 39 "./argcv.h"
int argcv_get(char const   *command , char const   *delim , char const   *cmnt , int *argc ,
              char ***argv ) ;
#line 42
int argcv_string(int argc , char **argv , char **pstring ) ;
#line 43
int argcv_free(int argc , char **argv ) ;
#line 44
int argcv_unquote_char(int c ) ;
#line 45
int argcv_quote_char(int c ) ;
#line 46
size_t argcv_quoted_length(char const   *str , int *quote ) ;
#line 47
void argcv_unquote_copy(char *dst , char const   *src , size_t n ) ;
#line 48
void argcv_quote_copy(char *dst , char const   *src ) ;
#line 38 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/argcv.c"
static int argcv_scan(int len , char const   *command , char const   *delim , char const   *cmnt ,
                      int *start , int *end___0 , int *save ) 
{ 
  int i ;
  int j ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 42
  i = 0;
  {
#line 44
  while (1) {
    while_continue: /* CIL Label */ ;
#line 46
    i = *save;
#line 48
    if (i >= len) {
#line 49
      return (i + 1);
    }
    {
#line 52
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 52
      if (i < len) {
#line 52
        if (! ((int const   )*(command + i) == 32)) {
#line 52
          if (! ((int const   )*(command + i) == 9)) {
#line 52
            if (! ((int const   )*(command + i) == 10)) {
#line 52
              goto while_break___0;
            }
          }
        }
      } else {
#line 52
        goto while_break___0;
      }
#line 53
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 54
    *start = i;
#line 56
    tmp___0 = strchr(delim, (int )*(command + i));
    }
#line 56
    if (! ((unsigned long )tmp___0 != (unsigned long )((void *)0))) {
      {
#line 58
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 58
        if (! (i < len)) {
#line 58
          goto while_break___1;
        }
#line 60
        if ((int const   )*(command + i) == 92) {
#line 62
          i ++;
#line 62
          if (i == len) {
#line 63
            goto while_break___1;
          }
#line 64
          i ++;
#line 65
          goto while_continue___1;
        }
#line 68
        if ((int const   )*(command + i) == 39) {
#line 68
          goto _L;
        } else
#line 68
        if ((int const   )*(command + i) == 34) {
          _L: /* CIL Label */ 
#line 71
          j = i + 1;
          {
#line 71
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 71
            if (j < len) {
#line 71
              if (! ((int const   )*(command + j) != (int const   )*(command + i))) {
#line 71
                goto while_break___2;
              }
            } else {
#line 71
              goto while_break___2;
            }
#line 72
            if ((int const   )*(command + j) == 92) {
#line 73
              j ++;
            }
#line 71
            j ++;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 74
          if (j < len) {
#line 75
            i = j + 1;
          } else {
#line 77
            i ++;
          }
        } else
#line 79
        if ((int const   )*(command + i) == 32) {
#line 80
          goto while_break___1;
        } else
#line 79
        if ((int const   )*(command + i) == 9) {
#line 80
          goto while_break___1;
        } else
#line 79
        if ((int const   )*(command + i) == 10) {
#line 80
          goto while_break___1;
        } else {
          {
#line 79
          tmp = strchr(delim, (int )*(command + i));
          }
#line 79
          if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 80
            goto while_break___1;
          } else {
#line 82
            i ++;
          }
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 84
      i --;
    }
#line 87
    *end___0 = i;
#line 88
    *save = i + 1;
#line 92
    if (*save <= len) {
#line 94
      if (cmnt) {
        {
#line 94
        tmp___1 = strchr(cmnt, (int )*(command + *start));
        }
#line 94
        if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
#line 96
          i = *save;
          {
#line 97
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 97
            if (i < len) {
#line 97
              if (! ((int const   )*(command + i) != 10)) {
#line 97
                goto while_break___3;
              }
            } else {
#line 97
              goto while_break___3;
            }
#line 98
            i ++;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 100
          *save = i;
#line 101
          goto __Cont;
        }
      }
    }
#line 104
    goto while_break;
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 106
  return (*save);
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/argcv.c"
static char quote_transtab[15]  = 
#line 109
  {      (char )'\\',      (char )'\\',      (char )'a',      (char )'\a', 
        (char )'b',      (char )'\b',      (char )'f',      (char )'\f', 
        (char )'n',      (char )'\n',      (char )'r',      (char )'\r', 
        (char )'t',      (char )'\t',      (char )'\000'};
#line 111 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/argcv.c"
int argcv_unquote_char(int c ) 
{ 
  char *p ;

  {
#line 116
  p = quote_transtab;
  {
#line 116
  while (1) {
    while_continue: /* CIL Label */ ;
#line 116
    if (! *p) {
#line 116
      goto while_break;
    }
#line 118
    if ((int )*p == c) {
#line 119
      return ((int )*(p + 1));
    }
#line 116
    p += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 121
  return (c);
}
}
#line 124 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/argcv.c"
int argcv_quote_char(int c ) 
{ 
  char *p ;

  {
#line 129
  p = (quote_transtab + sizeof(quote_transtab)) - 2;
  {
#line 129
  while (1) {
    while_continue: /* CIL Label */ ;
#line 129
    if (! ((unsigned long )p > (unsigned long )(quote_transtab))) {
#line 129
      goto while_break;
    }
#line 132
    if ((int )*p == c) {
#line 133
      return ((int )*(p + -1));
    }
#line 129
    p -= 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 135
  return (-1);
}
}
#line 141 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/argcv.c"
static int xtonum(int *pval , char const   *src , int base , int cnt ) 
{ 
  int i ;
  int val ;
  int n ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;

  {
#line 146
  i = 0;
#line 146
  val = 0;
  {
#line 146
  while (1) {
    while_continue: /* CIL Label */ ;
#line 146
    if (! (i < cnt)) {
#line 146
      goto while_break;
    }
#line 148
    n = (int )*((unsigned char *)src);
#line 149
    if (n > 127) {
#line 150
      goto while_break;
    } else {
      {
#line 149
      tmp___4 = __ctype_b_loc();
      }
#line 149
      if ((int const   )*(*tmp___4 + n) & 2048) {
#line 149
        n -= 48;
      } else {
        {
#line 149
        tmp___3 = __ctype_b_loc();
        }
#line 149
        if ((int const   )*(*tmp___3 + n) & 4096) {
          {
#line 149
          tmp___1 = toupper(n);
#line 149
          tmp___2 = (tmp___1 - 65) + 10;
          }
        } else {
#line 149
          tmp___2 = 255;
        }
#line 149
        n = tmp___2;
      }
#line 149
      if (n >= base) {
#line 150
        goto while_break;
      }
    }
#line 151
    val = val * base + n;
#line 146
    i ++;
#line 146
    src ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 153
  *pval = val;
#line 154
  return (i);
}
}
#line 157 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/argcv.c"
size_t argcv_quoted_length(char const   *str , int *quote ) 
{ 
  size_t len ;
  int tmp ;
  unsigned short const   **tmp___0 ;

  {
#line 160
  len = (size_t )0;
#line 162
  *quote = 0;
  {
#line 163
  while (1) {
    while_continue: /* CIL Label */ ;
#line 163
    if (! *str) {
#line 163
      goto while_break;
    }
#line 165
    if ((int const   )*str == 32) {
#line 167
      len ++;
#line 168
      *quote = 1;
    } else
#line 170
    if ((int const   )*str == 34) {
#line 172
      len += 2UL;
#line 173
      *quote = 1;
    } else
#line 170
    if ((int const   )*str == 39) {
#line 172
      len += 2UL;
#line 173
      *quote = 1;
    } else
#line 175
    if ((int const   )*str != 9) {
#line 175
      if ((int const   )*str != 92) {
        {
#line 175
        tmp___0 = __ctype_b_loc();
        }
#line 175
        if ((int const   )*(*tmp___0 + (int )*str) & 16384) {
#line 176
          len ++;
        } else {
#line 175
          goto _L___0;
        }
      } else {
#line 175
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      {
#line 177
      tmp = argcv_quote_char((int )*str);
      }
#line 177
      if (tmp != -1) {
#line 178
        len += 2UL;
      } else {
#line 180
        len += 4UL;
      }
    }
#line 163
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 182
  return (len);
}
}
#line 185 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/argcv.c"
void argcv_unquote_copy(char *dst , char const   *src , size_t n ) 
{ 
  int i ;
  int c ;
  int expect_delim ;
  char const   *p ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int off ;
  int tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  int off___0 ;
  int tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  unsigned short const   **tmp___23 ;
  char *tmp___24 ;
  int tmp___25 ;

  {
#line 188
  i = 0;
#line 190
  expect_delim = 0;
  {
#line 192
  while (1) {
    while_continue: /* CIL Label */ ;
#line 192
    if (! ((size_t )i < n)) {
#line 192
      goto while_break;
    }
    {
#line 197
    if ((int const   )*(src + i) == 34) {
#line 197
      goto case_34;
    }
#line 197
    if ((int const   )*(src + i) == 39) {
#line 197
      goto case_34;
    }
#line 216
    if ((int const   )*(src + i) == 92) {
#line 216
      goto case_92;
    }
#line 266
    goto switch_default;
    case_34: /* CIL Label */ 
    case_39: /* CIL Label */ 
#line 198
    if (! expect_delim) {
#line 202
      p = (src + i) + 1;
      {
#line 202
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 202
        if (*p) {
#line 202
          if (! ((int const   )*p != (int const   )*(src + i))) {
#line 202
            goto while_break___0;
          }
        } else {
#line 202
          goto while_break___0;
        }
#line 203
        if ((int const   )*p == 92) {
#line 204
          p ++;
        }
#line 202
        p ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 205
      if (*p) {
#line 206
        tmp = i;
#line 206
        i ++;
#line 206
        expect_delim = (int )*(src + tmp);
      } else {
#line 208
        tmp___0 = dst;
#line 208
        dst ++;
#line 208
        tmp___1 = i;
#line 208
        i ++;
#line 208
        *tmp___0 = (char )*(src + tmp___1);
      }
    } else
#line 210
    if (expect_delim == (int )*(src + i)) {
#line 211
      i ++;
    } else {
#line 213
      tmp___2 = dst;
#line 213
      dst ++;
#line 213
      tmp___3 = i;
#line 213
      i ++;
#line 213
      *tmp___2 = (char )*(src + tmp___3);
    }
#line 214
    goto switch_break;
    case_92: /* CIL Label */ 
#line 217
    i ++;
#line 218
    if ((int const   )*(src + i) == 120) {
#line 218
      goto _L___0;
    } else
#line 218
    if ((int const   )*(src + i) == 88) {
      _L___0: /* CIL Label */ 
#line 220
      if (n - (size_t )i < 2UL) {
#line 222
        tmp___4 = dst;
#line 222
        dst ++;
#line 222
        *tmp___4 = (char )'\\';
#line 223
        tmp___5 = dst;
#line 223
        dst ++;
#line 223
        tmp___6 = i;
#line 223
        i ++;
#line 223
        *tmp___5 = (char )*(src + tmp___6);
      } else {
        {
#line 227
        tmp___7 = xtonum(& c, (src + i) + 1, 16, 2);
#line 227
        off = tmp___7;
        }
#line 228
        if (off == 0) {
#line 230
          tmp___8 = dst;
#line 230
          dst ++;
#line 230
          *tmp___8 = (char )'\\';
#line 231
          tmp___9 = dst;
#line 231
          dst ++;
#line 231
          tmp___10 = i;
#line 231
          i ++;
#line 231
          *tmp___9 = (char )*(src + tmp___10);
        } else {
#line 235
          tmp___11 = dst;
#line 235
          dst ++;
#line 235
          *tmp___11 = (char )c;
#line 236
          i += off + 1;
        }
      }
    } else
#line 240
    if ((int )((unsigned char )*(src + i)) < 128) {
      {
#line 240
      tmp___23 = __ctype_b_loc();
      }
#line 240
      if ((int const   )*(*tmp___23 + (int )*(src + i)) & 2048) {
#line 242
        if (n - (size_t )i < 1UL) {
#line 244
          tmp___12 = dst;
#line 244
          dst ++;
#line 244
          *tmp___12 = (char )'\\';
#line 245
          tmp___13 = dst;
#line 245
          dst ++;
#line 245
          tmp___14 = i;
#line 245
          i ++;
#line 245
          *tmp___13 = (char )*(src + tmp___14);
        } else {
          {
#line 249
          tmp___15 = xtonum(& c, src + i, 8, 3);
#line 249
          off___0 = tmp___15;
          }
#line 250
          if (off___0 == 0) {
#line 252
            tmp___16 = dst;
#line 252
            dst ++;
#line 252
            *tmp___16 = (char )'\\';
#line 253
            tmp___17 = dst;
#line 253
            dst ++;
#line 253
            tmp___18 = i;
#line 253
            i ++;
#line 253
            *tmp___17 = (char )*(src + tmp___18);
          } else {
#line 257
            tmp___19 = dst;
#line 257
            dst ++;
#line 257
            *tmp___19 = (char )c;
#line 258
            i += off___0;
          }
        }
      } else {
#line 240
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 263
      tmp___20 = dst;
#line 263
      dst ++;
#line 263
      tmp___21 = i;
#line 263
      i ++;
#line 263
      tmp___22 = argcv_unquote_char((int )*(src + tmp___21));
#line 263
      *tmp___20 = (char )tmp___22;
      }
    }
#line 264
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 267
    tmp___24 = dst;
#line 267
    dst ++;
#line 267
    tmp___25 = i;
#line 267
    i ++;
#line 267
    *tmp___24 = (char )*(src + tmp___25);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 270
  *dst = (char)0;
#line 271
  return;
}
}
#line 273 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/argcv.c"
void argcv_quote_copy(char *dst , char const   *src ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int c ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char tmp___5[4] ;
  unsigned short const   **tmp___6 ;

  {
  {
#line 276
  while (1) {
    while_continue: /* CIL Label */ ;
#line 276
    if (! *src) {
#line 276
      goto while_break;
    }
#line 278
    if ((int const   )*src == 34) {
#line 278
      goto _L___1;
    } else
#line 278
    if ((int const   )*src == 39) {
      _L___1: /* CIL Label */ 
#line 280
      tmp = dst;
#line 280
      dst ++;
#line 280
      *tmp = (char )'\\';
#line 281
      tmp___0 = dst;
#line 281
      dst ++;
#line 281
      *tmp___0 = (char )*src;
    } else
#line 283
    if ((int const   )*src != 9) {
#line 283
      if ((int const   )*src != 92) {
        {
#line 283
        tmp___6 = __ctype_b_loc();
        }
#line 283
        if ((int const   )*(*tmp___6 + (int )*src) & 16384) {
#line 284
          tmp___1 = dst;
#line 284
          dst ++;
#line 284
          *tmp___1 = (char )*src;
        } else {
#line 283
          goto _L___0;
        }
      } else {
#line 283
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      {
#line 287
      tmp___2 = argcv_quote_char((int )*src);
#line 287
      c = tmp___2;
#line 288
      tmp___3 = dst;
#line 288
      dst ++;
#line 288
      *tmp___3 = (char )'\\';
      }
#line 289
      if (c != -1) {
#line 290
        tmp___4 = dst;
#line 290
        dst ++;
#line 290
        *tmp___4 = (char )c;
      } else {
        {
#line 294
        snprintf((char */* __restrict  */)(tmp___5), sizeof(tmp___5), (char const   */* __restrict  */)"%03o",
                 (int )*((unsigned char *)src));
#line 295
        memcpy((void */* __restrict  */)dst, (void const   */* __restrict  */)(tmp___5),
               (size_t )3);
#line 296
        dst += 3;
        }
      }
    }
#line 276
    src ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 300
  return;
}
}
#line 302 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/argcv.c"
int argcv_get(char const   *command , char const   *delim , char const   *cmnt , int *argc ,
              char ***argv ) 
{ 
  int len ;
  size_t tmp ;
  int i ;
  int start ;
  int end___0 ;
  int save ;
  int tmp___0 ;
  void *tmp___1 ;
  int n ;
  void *tmp___2 ;

  {
  {
#line 306
  tmp = strlen(command);
#line 306
  len = (int )tmp;
#line 307
  i = 0;
#line 310
  *argv = (char **)((void *)0);
#line 313
  *argc = 0;
#line 314
  save = 0;
  }
  {
#line 316
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 316
    tmp___0 = argcv_scan(len, command, delim, cmnt, & start, & end___0, & save);
    }
#line 316
    if (! (tmp___0 <= len)) {
#line 316
      goto while_break;
    }
#line 317
    (*argc) ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 319
  tmp___1 = calloc((size_t )(*argc + 1), sizeof(char *));
#line 319
  *argv = (char **)tmp___1;
  }
#line 320
  if ((unsigned long )*argv == (unsigned long )((void *)0)) {
#line 321
    return (12);
  }
#line 323
  i = 0;
#line 324
  save = 0;
#line 325
  i = 0;
  {
#line 325
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 325
    if (! (i < *argc)) {
#line 325
      goto while_break___0;
    }
    {
#line 328
    argcv_scan(len, command, delim, cmnt, & start, & end___0, & save);
    }
#line 330
    if ((int const   )*(command + start) == 34) {
#line 330
      goto _L;
    } else
#line 330
    if ((int const   )*(command + end___0) == 39) {
      _L: /* CIL Label */ 
#line 330
      if ((int const   )*(command + end___0) == (int const   )*(command + start)) {
#line 333
        start ++;
#line 334
        end___0 --;
      }
    }
    {
#line 336
    n = (end___0 - start) + 1;
#line 337
    tmp___2 = calloc((size_t )(n + 1), sizeof(char ));
#line 337
    *(*argv + i) = (char *)tmp___2;
    }
#line 338
    if ((unsigned long )*(*argv + i) == (unsigned long )((void *)0)) {
#line 339
      return (12);
    }
    {
#line 340
    argcv_unquote_copy(*(*argv + i), command + start, (size_t )n);
#line 341
    *(*(*argv + i) + n) = (char)0;
#line 325
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 343
  *(*argv + i) = (char *)((void *)0);
#line 344
  return (0);
}
}
#line 352 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/argcv.c"
int argcv_free(int argc , char **argv ) 
{ 


  {
  {
#line 355
  while (1) {
    while_continue: /* CIL Label */ ;
#line 355
    argc --;
#line 355
    if (! (argc >= 0)) {
#line 355
      goto while_break;
    }
#line 356
    if (*(argv + argc)) {
      {
#line 357
      free((void *)*(argv + argc));
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 358
  free((void *)argv);
  }
#line 359
  return (0);
}
}
#line 364 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/argcv.c"
int argcv_string(int argc , char **argv , char **pstring ) 
{ 
  size_t i ;
  size_t j ;
  size_t len ;
  char *buffer ;
  void *tmp ;
  int quote ;
  int toklen ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  unsigned short const   **tmp___5 ;

  {
#line 371
  if ((unsigned long )pstring == (unsigned long )((void *)0)) {
#line 372
    return (22);
  }
  {
#line 374
  tmp = malloc((size_t )1);
#line 374
  buffer = (char *)tmp;
  }
#line 375
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
#line 376
    return (12);
  }
#line 377
  *buffer = (char )'\000';
#line 379
  j = (size_t )0;
#line 379
  i = j;
#line 379
  len = i;
  {
#line 379
  while (1) {
    while_continue: /* CIL Label */ ;
#line 379
    if (! (i < (size_t )argc)) {
#line 379
      goto while_break;
    }
    {
#line 384
    tmp___0 = argcv_quoted_length((char const   *)*(argv + i), & quote);
#line 384
    toklen = (int )tmp___0;
#line 386
    len += (size_t )(toklen + 2);
    }
#line 387
    if (quote) {
#line 388
      len += 2UL;
    }
    {
#line 390
    tmp___1 = realloc((void *)buffer, len);
#line 390
    buffer = (char *)tmp___1;
    }
#line 391
    if ((unsigned long )buffer == (unsigned long )((void *)0)) {
#line 392
      return (12);
    }
#line 394
    if (i != 0UL) {
#line 395
      tmp___2 = j;
#line 395
      j ++;
#line 395
      *(buffer + tmp___2) = (char )' ';
    }
#line 396
    if (quote) {
#line 397
      tmp___3 = j;
#line 397
      j ++;
#line 397
      *(buffer + tmp___3) = (char )'\"';
    }
    {
#line 398
    argcv_quote_copy(buffer + j, (char const   *)*(argv + i));
#line 399
    j += (size_t )toklen;
    }
#line 400
    if (quote) {
#line 401
      tmp___4 = j;
#line 401
      j ++;
#line 401
      *(buffer + tmp___4) = (char )'\"';
    }
#line 379
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 404
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 404
    if (j > 0UL) {
      {
#line 404
      tmp___5 = __ctype_b_loc();
      }
#line 404
      if (! ((int const   )*(*tmp___5 + (int )*(buffer + (j - 1UL))) & 8192)) {
#line 404
        goto while_break___0;
      }
    } else {
#line 404
      goto while_break___0;
    }
#line 404
    j --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 406
  *(buffer + j) = (char)0;
#line 407
  if (pstring) {
#line 408
    *pstring = buffer;
  }
#line 409
  return (0);
}
}
#line 26 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-ba.c"
char const   *argp_program_bug_address  ;
#line 434 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 826
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) clearerr)(FILE *__stream ) ;
#line 830
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 858
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 873
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 879
extern int pclose(FILE *__stream ) ;
#line 187 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 779 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 182 "../gnu/obstack.h"
extern void _obstack_newchunk(struct obstack * , int  ) ;
#line 183
extern int _obstack_begin(struct obstack * , int  , int  , void *(*)(long  ) , void (*)(void * ) ) ;
#line 195
extern void obstack_free(struct obstack *obstack , void *block ) ;
#line 44 "../gnu/error.h"
extern void ( /* format attribute */  error)(int __status , int __errnum , char const   *__format 
                                             , ...) ;
#line 47
extern void ( /* format attribute */  error_at_line)(int __status , int __errnum ,
                                                     char const   *__fname , unsigned int __lineno ,
                                                     char const   *__format  , ...) ;
#line 57 "../gnu/xalloc.h"
extern void *xmalloc(size_t s )  __attribute__((__malloc__)) ;
#line 60
extern void *xrealloc(void *p , size_t s ) ;
#line 63
extern char *xstrdup(char const   *str )  __attribute__((__malloc__)) ;
#line 39 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) gettext)(char const   *__msgid )  __attribute__((__format_arg__(1))) ;
#line 162 "./cflow.h"
int debug ;
#line 163
int preprocess_option ;
#line 171 "./cflow.h"
unsigned int input_file_count  ;
#line 178
Symbol *lookup(char const   *name ) ;
#line 179
Symbol *install(char *name , int flags ) ;
#line 183
void delete_statics(void) ;
#line 199
int get_token(void) ;
#line 200
int source(char *name ) ;
#line 201
void init_lex(int debug_level ) ;
#line 202
void set_preprocessor(char const   *arg___0 ) ;
#line 203
void pp_option(char const   *arg___0 ) ;
#line 44 "./parser.h"
YYSTYPE yylval  ;
#line 45 "./parser.h"
char *filename  ;
#line 46 "./parser.h"
char *canonical_filename  ;
#line 47 "./parser.h"
int line_num  ;
#line 49
int yylex(void) ;
#line 205 "c.c"
int yyleng  ;
#line 210
FILE *yyin ;
#line 210
FILE *yyout ;
#line 317 "c.c"
static size_t yy_buffer_stack_top  =    (size_t )0;
#line 318 "c.c"
static size_t yy_buffer_stack_max  =    (size_t )0;
#line 319 "c.c"
static YY_BUFFER_STATE *yy_buffer_stack  =    (YY_BUFFER_STATE *)0;
#line 346 "c.c"
static char yy_hold_char  ;
#line 347 "c.c"
static int yy_n_chars  ;
#line 351 "c.c"
static char *yy_c_buf_p  =    (char *)0;
#line 352 "c.c"
static int yy_init  =    0;
#line 353 "c.c"
static int yy_start  =    0;
#line 358 "c.c"
static int yy_did_buffer_switch_on_eof  ;
#line 363
void yyrestart(FILE *input_file ) ;
#line 364
void yy_switch_to_buffer(YY_BUFFER_STATE new_buffer ) ;
#line 365
YY_BUFFER_STATE yy_create_buffer(FILE *file , int size ) ;
#line 366
void yy_delete_buffer(YY_BUFFER_STATE b ) ;
#line 367
void yy_flush_buffer(YY_BUFFER_STATE b ) ;
#line 368
void yypush_buffer_state(YY_BUFFER_STATE new_buffer ) ;
#line 369
void yypop_buffer_state(void) ;
#line 371
static void yyensure_buffer_stack(void) ;
#line 372
static void yy_load_buffer_state(void) ;
#line 373
static void yy_init_buffer(YY_BUFFER_STATE b , FILE *file ) ;
#line 377
YY_BUFFER_STATE yy_scan_buffer(char *base , yy_size_t size ) ;
#line 378
YY_BUFFER_STATE yy_scan_string(char const   *yystr ) ;
#line 379
YY_BUFFER_STATE yy_scan_bytes(char const   *yybytes , int _yybytes_len ) ;
#line 383
void *yyalloc(yy_size_t size ) ;
#line 384
void *yyrealloc(void *ptr , yy_size_t size ) ;
#line 385
void yyfree(void *ptr ) ;
#line 418 "c.c"
FILE *yyin  =    (FILE *)0;
#line 418 "c.c"
FILE *yyout  =    (FILE *)0;
#line 422
int yylineno ;
#line 424 "c.c"
int yylineno  =    1;
#line 426 "c.c"
char *yytext  ;
#line 431
static yy_state_type yy_get_previous_state(void) ;
#line 432
static yy_state_type yy_try_NUL_trans(yy_state_type yy_current_state ) ;
#line 433
static int yy_get_next_buffer(void) ;
#line 434
static void yy_fatal_error(char const   *msg ) ;
#line 460 "c.c"
static flex_int16_t const   yy_accept[191]  = 
#line 460
  {      (flex_int16_t const   )0,      (flex_int16_t const   )77,      (flex_int16_t const   )77,      (flex_int16_t const   )3, 
        (flex_int16_t const   )3,      (flex_int16_t const   )67,      (flex_int16_t const   )67,      (flex_int16_t const   )72, 
        (flex_int16_t const   )72,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )82, 
        (flex_int16_t const   )80,      (flex_int16_t const   )77,      (flex_int16_t const   )76,      (flex_int16_t const   )46, 
        (flex_int16_t const   )66,      (flex_int16_t const   )80,      (flex_int16_t const   )28,      (flex_int16_t const   )42, 
        (flex_int16_t const   )80,      (flex_int16_t const   )21,      (flex_int16_t const   )30,      (flex_int16_t const   )32, 
        (flex_int16_t const   )23,      (flex_int16_t const   )26,      (flex_int16_t const   )61,      (flex_int16_t const   )80, 
        (flex_int16_t const   )50,      (flex_int16_t const   )44,      (flex_int16_t const   )48,      (flex_int16_t const   )60, 
        (flex_int16_t const   )38,      (flex_int16_t const   )60,      (flex_int16_t const   )60,      (flex_int16_t const   )60, 
        (flex_int16_t const   )60,      (flex_int16_t const   )60,      (flex_int16_t const   )40,      (flex_int16_t const   )77, 
        (flex_int16_t const   )80,      (flex_int16_t const   )78,      (flex_int16_t const   )79,      (flex_int16_t const   )3, 
        (flex_int16_t const   )4,      (flex_int16_t const   )5,      (flex_int16_t const   )67,      (flex_int16_t const   )68, 
        (flex_int16_t const   )71,      (flex_int16_t const   )81,      (flex_int16_t const   )75,      (flex_int16_t const   )72, 
        (flex_int16_t const   )73,      (flex_int16_t const   )74,      (flex_int16_t const   )81,      (flex_int16_t const   )13, 
        (flex_int16_t const   )81,      (flex_int16_t const   )77,      (flex_int16_t const   )0,      (flex_int16_t const   )45, 
        (flex_int16_t const   )0,      (flex_int16_t const   )11,      (flex_int16_t const   )27,      (flex_int16_t const   )41, 
        (flex_int16_t const   )35,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )24, 
        (flex_int16_t const   )53,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )29,      (flex_int16_t const   )54,      (flex_int16_t const   )31,      (flex_int16_t const   )22, 
        (flex_int16_t const   )0,      (flex_int16_t const   )64,      (flex_int16_t const   )2,      (flex_int16_t const   )0, 
        (flex_int16_t const   )25,      (flex_int16_t const   )65,      (flex_int16_t const   )61,      (flex_int16_t const   )0, 
        (flex_int16_t const   )63,      (flex_int16_t const   )62,      (flex_int16_t const   )62,      (flex_int16_t const   )51, 
        (flex_int16_t const   )49,      (flex_int16_t const   )43,      (flex_int16_t const   )47,      (flex_int16_t const   )52, 
        (flex_int16_t const   )60,      (flex_int16_t const   )37,      (flex_int16_t const   )60,      (flex_int16_t const   )60, 
        (flex_int16_t const   )60,      (flex_int16_t const   )60,      (flex_int16_t const   )60,      (flex_int16_t const   )60, 
        (flex_int16_t const   )36,      (flex_int16_t const   )39,      (flex_int16_t const   )77,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )3,      (flex_int16_t const   )4,      (flex_int16_t const   )5, 
        (flex_int16_t const   )6,      (flex_int16_t const   )5,      (flex_int16_t const   )7,      (flex_int16_t const   )67, 
        (flex_int16_t const   )69,      (flex_int16_t const   )70,      (flex_int16_t const   )72,      (flex_int16_t const   )0, 
        (flex_int16_t const   )13,      (flex_int16_t const   )0,      (flex_int16_t const   )12,      (flex_int16_t const   )55, 
        (flex_int16_t const   )0,      (flex_int16_t const   )55,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )59,      (flex_int16_t const   )64,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )1,      (flex_int16_t const   )0,      (flex_int16_t const   )63,      (flex_int16_t const   )33, 
        (flex_int16_t const   )34,      (flex_int16_t const   )60,      (flex_int16_t const   )60,      (flex_int16_t const   )60, 
        (flex_int16_t const   )60,      (flex_int16_t const   )60,      (flex_int16_t const   )60,      (flex_int16_t const   )60, 
        (flex_int16_t const   )0,      (flex_int16_t const   )9,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )10,      (flex_int16_t const   )0,      (flex_int16_t const   )56,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )64,      (flex_int16_t const   )0, 
        (flex_int16_t const   )65,      (flex_int16_t const   )14,      (flex_int16_t const   )20,      (flex_int16_t const   )60, 
        (flex_int16_t const   )60,      (flex_int16_t const   )60,      (flex_int16_t const   )60,      (flex_int16_t const   )60, 
        (flex_int16_t const   )9,      (flex_int16_t const   )0,      (flex_int16_t const   )57,      (flex_int16_t const   )0, 
        (flex_int16_t const   )58,      (flex_int16_t const   )0,      (flex_int16_t const   )64,      (flex_int16_t const   )65, 
        (flex_int16_t const   )60,      (flex_int16_t const   )60,      (flex_int16_t const   )60,      (flex_int16_t const   )60, 
        (flex_int16_t const   )19,      (flex_int16_t const   )0,      (flex_int16_t const   )15,      (flex_int16_t const   )16, 
        (flex_int16_t const   )18,      (flex_int16_t const   )60,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )17,      (flex_int16_t const   )0,      (flex_int16_t const   )8,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )8,      (flex_int16_t const   )0};
#line 484 "c.c"
static flex_int32_t const   yy_ec[256]  = 
#line 484
  {      (flex_int32_t const   )0,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )2,      (flex_int32_t const   )3,      (flex_int32_t const   )1, 
        (flex_int32_t const   )2,      (flex_int32_t const   )2,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )2,      (flex_int32_t const   )4,      (flex_int32_t const   )5,      (flex_int32_t const   )6, 
        (flex_int32_t const   )1,      (flex_int32_t const   )7,      (flex_int32_t const   )8,      (flex_int32_t const   )9, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )10,      (flex_int32_t const   )11, 
        (flex_int32_t const   )1,      (flex_int32_t const   )12,      (flex_int32_t const   )13,      (flex_int32_t const   )14, 
        (flex_int32_t const   )15,      (flex_int32_t const   )16,      (flex_int32_t const   )16,      (flex_int32_t const   )16, 
        (flex_int32_t const   )16,      (flex_int32_t const   )16,      (flex_int32_t const   )16,      (flex_int32_t const   )16, 
        (flex_int32_t const   )17,      (flex_int32_t const   )17,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )18,      (flex_int32_t const   )19,      (flex_int32_t const   )20,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )21,      (flex_int32_t const   )21,      (flex_int32_t const   )21, 
        (flex_int32_t const   )21,      (flex_int32_t const   )22,      (flex_int32_t const   )21,      (flex_int32_t const   )23, 
        (flex_int32_t const   )23,      (flex_int32_t const   )23,      (flex_int32_t const   )23,      (flex_int32_t const   )23, 
        (flex_int32_t const   )23,      (flex_int32_t const   )23,      (flex_int32_t const   )23,      (flex_int32_t const   )23, 
        (flex_int32_t const   )23,      (flex_int32_t const   )23,      (flex_int32_t const   )23,      (flex_int32_t const   )23, 
        (flex_int32_t const   )23,      (flex_int32_t const   )23,      (flex_int32_t const   )23,      (flex_int32_t const   )23, 
        (flex_int32_t const   )24,      (flex_int32_t const   )23,      (flex_int32_t const   )23,      (flex_int32_t const   )1, 
        (flex_int32_t const   )25,      (flex_int32_t const   )1,      (flex_int32_t const   )26,      (flex_int32_t const   )23, 
        (flex_int32_t const   )1,      (flex_int32_t const   )27,      (flex_int32_t const   )21,      (flex_int32_t const   )28, 
        (flex_int32_t const   )29,      (flex_int32_t const   )30,      (flex_int32_t const   )31,      (flex_int32_t const   )23, 
        (flex_int32_t const   )23,      (flex_int32_t const   )32,      (flex_int32_t const   )23,      (flex_int32_t const   )23, 
        (flex_int32_t const   )33,      (flex_int32_t const   )34,      (flex_int32_t const   )35,      (flex_int32_t const   )36, 
        (flex_int32_t const   )37,      (flex_int32_t const   )23,      (flex_int32_t const   )38,      (flex_int32_t const   )39, 
        (flex_int32_t const   )40,      (flex_int32_t const   )41,      (flex_int32_t const   )23,      (flex_int32_t const   )23, 
        (flex_int32_t const   )42,      (flex_int32_t const   )43,      (flex_int32_t const   )23,      (flex_int32_t const   )44, 
        (flex_int32_t const   )45,      (flex_int32_t const   )46,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1};
#line 516 "c.c"
static flex_int32_t const   yy_meta[47]  = 
#line 516
  {      (flex_int32_t const   )0,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )2, 
        (flex_int32_t const   )1,      (flex_int32_t const   )3,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )4,      (flex_int32_t const   )5,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )6, 
        (flex_int32_t const   )6,      (flex_int32_t const   )6,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )6,      (flex_int32_t const   )7,      (flex_int32_t const   )8, 
        (flex_int32_t const   )8,      (flex_int32_t const   )3,      (flex_int32_t const   )1,      (flex_int32_t const   )6, 
        (flex_int32_t const   )6,      (flex_int32_t const   )6,      (flex_int32_t const   )7,      (flex_int32_t const   )6, 
        (flex_int32_t const   )8,      (flex_int32_t const   )8,      (flex_int32_t const   )8,      (flex_int32_t const   )8, 
        (flex_int32_t const   )8,      (flex_int32_t const   )8,      (flex_int32_t const   )8,      (flex_int32_t const   )8, 
        (flex_int32_t const   )8,      (flex_int32_t const   )8,      (flex_int32_t const   )8,      (flex_int32_t const   )8, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1};
#line 525 "c.c"
static flex_int16_t const   yy_base[212]  = 
#line 525
  {      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )45,      (flex_int16_t const   )45, 
        (flex_int16_t const   )46,      (flex_int16_t const   )47,      (flex_int16_t const   )54,      (flex_int16_t const   )58, 
        (flex_int16_t const   )62,      (flex_int16_t const   )50,      (flex_int16_t const   )51,      (flex_int16_t const   )469, 
        (flex_int16_t const   )484,      (flex_int16_t const   )56,      (flex_int16_t const   )484,      (flex_int16_t const   )424, 
        (flex_int16_t const   )484,      (flex_int16_t const   )417,      (flex_int16_t const   )400,      (flex_int16_t const   )58, 
        (flex_int16_t const   )381,      (flex_int16_t const   )370,      (flex_int16_t const   )67,      (flex_int16_t const   )80, 
        (flex_int16_t const   )88,      (flex_int16_t const   )71,      (flex_int16_t const   )93,      (flex_int16_t const   )98, 
        (flex_int16_t const   )50,      (flex_int16_t const   )357,      (flex_int16_t const   )51,      (flex_int16_t const   )0, 
        (flex_int16_t const   )314,      (flex_int16_t const   )291,      (flex_int16_t const   )52,      (flex_int16_t const   )291, 
        (flex_int16_t const   )287,      (flex_int16_t const   )294,      (flex_int16_t const   )79,      (flex_int16_t const   )110, 
        (flex_int16_t const   )134,      (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )325, 
        (flex_int16_t const   )484,      (flex_int16_t const   )115,      (flex_int16_t const   )0,      (flex_int16_t const   )484, 
        (flex_int16_t const   )484,      (flex_int16_t const   )324,      (flex_int16_t const   )484,      (flex_int16_t const   )321, 
        (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )116,      (flex_int16_t const   )484, 
        (flex_int16_t const   )117,      (flex_int16_t const   )120,      (flex_int16_t const   )319,      (flex_int16_t const   )484, 
        (flex_int16_t const   )318,      (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484, 
        (flex_int16_t const   )484,      (flex_int16_t const   )311,      (flex_int16_t const   )123,      (flex_int16_t const   )484, 
        (flex_int16_t const   )484,      (flex_int16_t const   )128,      (flex_int16_t const   )139,      (flex_int16_t const   )145, 
        (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484, 
        (flex_int16_t const   )305,      (flex_int16_t const   )153,      (flex_int16_t const   )484,      (flex_int16_t const   )314, 
        (flex_int16_t const   )484,      (flex_int16_t const   )156,      (flex_int16_t const   )164,      (flex_int16_t const   )172, 
        (flex_int16_t const   )0,      (flex_int16_t const   )484,      (flex_int16_t const   )177,      (flex_int16_t const   )296, 
        (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )295, 
        (flex_int16_t const   )0,      (flex_int16_t const   )484,      (flex_int16_t const   )262,      (flex_int16_t const   )260, 
        (flex_int16_t const   )258,      (flex_int16_t const   )96,      (flex_int16_t const   )258,      (flex_int16_t const   )254, 
        (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )125,      (flex_int16_t const   )193, 
        (flex_int16_t const   )173,      (flex_int16_t const   )225,      (flex_int16_t const   )188,      (flex_int16_t const   )181, 
        (flex_int16_t const   )197,      (flex_int16_t const   )272,      (flex_int16_t const   )484,      (flex_int16_t const   )143, 
        (flex_int16_t const   )484,      (flex_int16_t const   )209,      (flex_int16_t const   )484,      (flex_int16_t const   )0, 
        (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )270,      (flex_int16_t const   )196, 
        (flex_int16_t const   )484,      (flex_int16_t const   )199,      (flex_int16_t const   )484,      (flex_int16_t const   )484, 
        (flex_int16_t const   )259,      (flex_int16_t const   )226,      (flex_int16_t const   )216,      (flex_int16_t const   )225, 
        (flex_int16_t const   )484,      (flex_int16_t const   )221,      (flex_int16_t const   )237,      (flex_int16_t const   )227, 
        (flex_int16_t const   )484,      (flex_int16_t const   )244,      (flex_int16_t const   )0,      (flex_int16_t const   )484, 
        (flex_int16_t const   )484,      (flex_int16_t const   )184,      (flex_int16_t const   )173,      (flex_int16_t const   )171, 
        (flex_int16_t const   )157,      (flex_int16_t const   )141,      (flex_int16_t const   )144,      (flex_int16_t const   )130, 
        (flex_int16_t const   )208,      (flex_int16_t const   )484,      (flex_int16_t const   )254,      (flex_int16_t const   )214, 
        (flex_int16_t const   )484,      (flex_int16_t const   )241,      (flex_int16_t const   )484,      (flex_int16_t const   )258, 
        (flex_int16_t const   )155,      (flex_int16_t const   )199,      (flex_int16_t const   )230,      (flex_int16_t const   )247, 
        (flex_int16_t const   )265,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )125, 
        (flex_int16_t const   )116,      (flex_int16_t const   )112,      (flex_int16_t const   )104,      (flex_int16_t const   )95, 
        (flex_int16_t const   )484,      (flex_int16_t const   )262,      (flex_int16_t const   )484,      (flex_int16_t const   )119, 
        (flex_int16_t const   )484,      (flex_int16_t const   )112,      (flex_int16_t const   )268,      (flex_int16_t const   )273, 
        (flex_int16_t const   )72,      (flex_int16_t const   )74,      (flex_int16_t const   )48,      (flex_int16_t const   )44, 
        (flex_int16_t const   )0,      (flex_int16_t const   )291,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )42,      (flex_int16_t const   )294,      (flex_int16_t const   )288, 
        (flex_int16_t const   )0,      (flex_int16_t const   )274,      (flex_int16_t const   )484,      (flex_int16_t const   )309, 
        (flex_int16_t const   )275,      (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )334, 
        (flex_int16_t const   )342,      (flex_int16_t const   )350,      (flex_int16_t const   )358,      (flex_int16_t const   )366, 
        (flex_int16_t const   )374,      (flex_int16_t const   )382,      (flex_int16_t const   )385,      (flex_int16_t const   )393, 
        (flex_int16_t const   )401,      (flex_int16_t const   )409,      (flex_int16_t const   )417,      (flex_int16_t const   )425, 
        (flex_int16_t const   )433,      (flex_int16_t const   )441,      (flex_int16_t const   )449,      (flex_int16_t const   )452, 
        (flex_int16_t const   )459,      (flex_int16_t const   )464,      (flex_int16_t const   )468,      (flex_int16_t const   )475};
#line 553 "c.c"
static flex_int16_t const   yy_def[212]  = 
#line 553
  {      (flex_int16_t const   )0,      (flex_int16_t const   )190,      (flex_int16_t const   )1,      (flex_int16_t const   )191, 
        (flex_int16_t const   )191,      (flex_int16_t const   )192,      (flex_int16_t const   )192,      (flex_int16_t const   )193, 
        (flex_int16_t const   )193,      (flex_int16_t const   )194,      (flex_int16_t const   )194,      (flex_int16_t const   )190, 
        (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )190, 
        (flex_int16_t const   )190,      (flex_int16_t const   )195,      (flex_int16_t const   )190,      (flex_int16_t const   )190, 
        (flex_int16_t const   )196,      (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )190, 
        (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )197, 
        (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )198, 
        (flex_int16_t const   )190,      (flex_int16_t const   )198,      (flex_int16_t const   )198,      (flex_int16_t const   )198, 
        (flex_int16_t const   )198,      (flex_int16_t const   )198,      (flex_int16_t const   )190,      (flex_int16_t const   )190, 
        (flex_int16_t const   )199,      (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )200, 
        (flex_int16_t const   )190,      (flex_int16_t const   )201,      (flex_int16_t const   )202,      (flex_int16_t const   )190, 
        (flex_int16_t const   )190,      (flex_int16_t const   )203,      (flex_int16_t const   )190,      (flex_int16_t const   )190, 
        (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )204,      (flex_int16_t const   )190, 
        (flex_int16_t const   )204,      (flex_int16_t const   )190,      (flex_int16_t const   )195,      (flex_int16_t const   )190, 
        (flex_int16_t const   )195,      (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )190, 
        (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )205,      (flex_int16_t const   )190, 
        (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )197, 
        (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )190, 
        (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )206, 
        (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )190, 
        (flex_int16_t const   )207,      (flex_int16_t const   )190,      (flex_int16_t const   )197,      (flex_int16_t const   )190, 
        (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )190, 
        (flex_int16_t const   )198,      (flex_int16_t const   )190,      (flex_int16_t const   )198,      (flex_int16_t const   )198, 
        (flex_int16_t const   )198,      (flex_int16_t const   )198,      (flex_int16_t const   )198,      (flex_int16_t const   )198, 
        (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )199, 
        (flex_int16_t const   )199,      (flex_int16_t const   )199,      (flex_int16_t const   )208,      (flex_int16_t const   )199, 
        (flex_int16_t const   )199,      (flex_int16_t const   )200,      (flex_int16_t const   )190,      (flex_int16_t const   )201, 
        (flex_int16_t const   )190,      (flex_int16_t const   )201,      (flex_int16_t const   )190,      (flex_int16_t const   )202, 
        (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )204, 
        (flex_int16_t const   )190,      (flex_int16_t const   )204,      (flex_int16_t const   )190,      (flex_int16_t const   )190, 
        (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )209, 
        (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )206, 
        (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )207,      (flex_int16_t const   )190, 
        (flex_int16_t const   )190,      (flex_int16_t const   )198,      (flex_int16_t const   )198,      (flex_int16_t const   )198, 
        (flex_int16_t const   )198,      (flex_int16_t const   )198,      (flex_int16_t const   )198,      (flex_int16_t const   )198, 
        (flex_int16_t const   )208,      (flex_int16_t const   )190,      (flex_int16_t const   )208,      (flex_int16_t const   )208, 
        (flex_int16_t const   )190,      (flex_int16_t const   )199,      (flex_int16_t const   )190,      (flex_int16_t const   )190, 
        (flex_int16_t const   )210,      (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )190, 
        (flex_int16_t const   )190,      (flex_int16_t const   )198,      (flex_int16_t const   )198,      (flex_int16_t const   )198, 
        (flex_int16_t const   )198,      (flex_int16_t const   )198,      (flex_int16_t const   )198,      (flex_int16_t const   )198, 
        (flex_int16_t const   )190,      (flex_int16_t const   )199,      (flex_int16_t const   )190,      (flex_int16_t const   )190, 
        (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )190, 
        (flex_int16_t const   )198,      (flex_int16_t const   )198,      (flex_int16_t const   )198,      (flex_int16_t const   )198, 
        (flex_int16_t const   )198,      (flex_int16_t const   )199,      (flex_int16_t const   )198,      (flex_int16_t const   )198, 
        (flex_int16_t const   )198,      (flex_int16_t const   )198,      (flex_int16_t const   )199,      (flex_int16_t const   )211, 
        (flex_int16_t const   )198,      (flex_int16_t const   )211,      (flex_int16_t const   )190,      (flex_int16_t const   )211, 
        (flex_int16_t const   )211,      (flex_int16_t const   )190,      (flex_int16_t const   )0,      (flex_int16_t const   )190, 
        (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )190, 
        (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )190, 
        (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )190, 
        (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )190, 
        (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )190};
#line 581 "c.c"
static flex_int16_t const   yy_nxt[531]  = 
#line 581
  {      (flex_int16_t const   )0,      (flex_int16_t const   )12,      (flex_int16_t const   )13,      (flex_int16_t const   )14, 
        (flex_int16_t const   )15,      (flex_int16_t const   )16,      (flex_int16_t const   )17,      (flex_int16_t const   )18, 
        (flex_int16_t const   )19,      (flex_int16_t const   )20,      (flex_int16_t const   )21,      (flex_int16_t const   )22, 
        (flex_int16_t const   )23,      (flex_int16_t const   )24,      (flex_int16_t const   )25,      (flex_int16_t const   )26, 
        (flex_int16_t const   )27,      (flex_int16_t const   )27,      (flex_int16_t const   )28,      (flex_int16_t const   )29, 
        (flex_int16_t const   )30,      (flex_int16_t const   )31,      (flex_int16_t const   )31,      (flex_int16_t const   )31, 
        (flex_int16_t const   )31,      (flex_int16_t const   )12,      (flex_int16_t const   )32,      (flex_int16_t const   )33, 
        (flex_int16_t const   )31,      (flex_int16_t const   )31,      (flex_int16_t const   )34,      (flex_int16_t const   )31, 
        (flex_int16_t const   )31,      (flex_int16_t const   )31,      (flex_int16_t const   )31,      (flex_int16_t const   )31, 
        (flex_int16_t const   )31,      (flex_int16_t const   )31,      (flex_int16_t const   )31,      (flex_int16_t const   )35, 
        (flex_int16_t const   )36,      (flex_int16_t const   )37,      (flex_int16_t const   )31,      (flex_int16_t const   )31, 
        (flex_int16_t const   )12,      (flex_int16_t const   )38,      (flex_int16_t const   )12,      (flex_int16_t const   )39, 
        (flex_int16_t const   )44,      (flex_int16_t const   )44,      (flex_int16_t const   )47,      (flex_int16_t const   )40, 
        (flex_int16_t const   )48,      (flex_int16_t const   )55,      (flex_int16_t const   )55,      (flex_int16_t const   )45, 
        (flex_int16_t const   )45,      (flex_int16_t const   )47,      (flex_int16_t const   )57,      (flex_int16_t const   )48, 
        (flex_int16_t const   )51,      (flex_int16_t const   )52,      (flex_int16_t const   )58,      (flex_int16_t const   )53, 
        (flex_int16_t const   )51,      (flex_int16_t const   )52,      (flex_int16_t const   )63,      (flex_int16_t const   )53, 
        (flex_int16_t const   )87,      (flex_int16_t const   )88,      (flex_int16_t const   )90,      (flex_int16_t const   )91, 
        (flex_int16_t const   )49,      (flex_int16_t const   )184,      (flex_int16_t const   )181,      (flex_int16_t const   )56, 
        (flex_int16_t const   )56,      (flex_int16_t const   )64,      (flex_int16_t const   )68,      (flex_int16_t const   )49, 
        (flex_int16_t const   )69,      (flex_int16_t const   )78,      (flex_int16_t const   )70,      (flex_int16_t const   )71, 
        (flex_int16_t const   )71,      (flex_int16_t const   )79,      (flex_int16_t const   )72,      (flex_int16_t const   )95, 
        (flex_int16_t const   )180,      (flex_int16_t const   )41,      (flex_int16_t const   )80,      (flex_int16_t const   )42, 
        (flex_int16_t const   )73,      (flex_int16_t const   )69,      (flex_int16_t const   )96,      (flex_int16_t const   )70, 
        (flex_int16_t const   )71,      (flex_int16_t const   )71,      (flex_int16_t const   )100,      (flex_int16_t const   )74, 
        (flex_int16_t const   )75,      (flex_int16_t const   )76,      (flex_int16_t const   )179,      (flex_int16_t const   )77, 
        (flex_int16_t const   )77,      (flex_int16_t const   )77,      (flex_int16_t const   )81,      (flex_int16_t const   )178, 
        (flex_int16_t const   )82,      (flex_int16_t const   )82,      (flex_int16_t const   )83,      (flex_int16_t const   )81, 
        (flex_int16_t const   )102,      (flex_int16_t const   )86,      (flex_int16_t const   )86,      (flex_int16_t const   )86, 
        (flex_int16_t const   )103,      (flex_int16_t const   )84,      (flex_int16_t const   )112,      (flex_int16_t const   )120, 
        (flex_int16_t const   )122,      (flex_int16_t const   )168,      (flex_int16_t const   )57,      (flex_int16_t const   )140, 
        (flex_int16_t const   )101,      (flex_int16_t const   )113,      (flex_int16_t const   )58,      (flex_int16_t const   )102, 
        (flex_int16_t const   )166,      (flex_int16_t const   )114,      (flex_int16_t const   )176,      (flex_int16_t const   )103, 
        (flex_int16_t const   )125,      (flex_int16_t const   )175,      (flex_int16_t const   )141,      (flex_int16_t const   )84, 
        (flex_int16_t const   )105,      (flex_int16_t const   )61,      (flex_int16_t const   )126,      (flex_int16_t const   )126, 
        (flex_int16_t const   )174,      (flex_int16_t const   )121,      (flex_int16_t const   )121,      (flex_int16_t const   )77, 
        (flex_int16_t const   )77,      (flex_int16_t const   )77,      (flex_int16_t const   )112,      (flex_int16_t const   )127, 
        (flex_int16_t const   )173,      (flex_int16_t const   )106,      (flex_int16_t const   )106,      (flex_int16_t const   )106, 
        (flex_int16_t const   )81,      (flex_int16_t const   )190,      (flex_int16_t const   )83,      (flex_int16_t const   )83, 
        (flex_int16_t const   )83,      (flex_int16_t const   )190,      (flex_int16_t const   )81,      (flex_int16_t const   )107, 
        (flex_int16_t const   )86,      (flex_int16_t const   )86,      (flex_int16_t const   )86,      (flex_int16_t const   )172, 
        (flex_int16_t const   )168,      (flex_int16_t const   )127,      (flex_int16_t const   )163,      (flex_int16_t const   )108, 
        (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )77, 
        (flex_int16_t const   )77,      (flex_int16_t const   )77,      (flex_int16_t const   )162,      (flex_int16_t const   )130, 
        (flex_int16_t const   )61,      (flex_int16_t const   )81,      (flex_int16_t const   )133,      (flex_int16_t const   )82, 
        (flex_int16_t const   )82,      (flex_int16_t const   )83,      (flex_int16_t const   )161,      (flex_int16_t const   )130, 
        (flex_int16_t const   )148,      (flex_int16_t const   )81,      (flex_int16_t const   )133,      (flex_int16_t const   )83, 
        (flex_int16_t const   )83,      (flex_int16_t const   )83,      (flex_int16_t const   )81,      (flex_int16_t const   )145, 
        (flex_int16_t const   )86,      (flex_int16_t const   )86,      (flex_int16_t const   )86,      (flex_int16_t const   )105, 
        (flex_int16_t const   )61,      (flex_int16_t const   )160,      (flex_int16_t const   )107,      (flex_int16_t const   )120, 
        (flex_int16_t const   )61,      (flex_int16_t const   )159,      (flex_int16_t const   )122,      (flex_int16_t const   )146, 
        (flex_int16_t const   )146,      (flex_int16_t const   )146,      (flex_int16_t const   )107,      (flex_int16_t const   )158, 
        (flex_int16_t const   )106,      (flex_int16_t const   )106,      (flex_int16_t const   )106,      (flex_int16_t const   )145, 
        (flex_int16_t const   )112,      (flex_int16_t const   )147,      (flex_int16_t const   )154,      (flex_int16_t const   )154, 
        (flex_int16_t const   )154,      (flex_int16_t const   )164,      (flex_int16_t const   )107,      (flex_int16_t const   )113, 
        (flex_int16_t const   )157,      (flex_int16_t const   )121,      (flex_int16_t const   )107,      (flex_int16_t const   )114, 
        (flex_int16_t const   )121,      (flex_int16_t const   )150,      (flex_int16_t const   )108,      (flex_int16_t const   )105, 
        (flex_int16_t const   )61,      (flex_int16_t const   )149,      (flex_int16_t const   )132,      (flex_int16_t const   )151, 
        (flex_int16_t const   )151,      (flex_int16_t const   )147,      (flex_int16_t const   )150,      (flex_int16_t const   )150, 
        (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )147, 
        (flex_int16_t const   )106,      (flex_int16_t const   )106,      (flex_int16_t const   )106,      (flex_int16_t const   )130, 
        (flex_int16_t const   )61,      (flex_int16_t const   )170,      (flex_int16_t const   )170,      (flex_int16_t const   )170, 
        (flex_int16_t const   )153,      (flex_int16_t const   )153,      (flex_int16_t const   )107,      (flex_int16_t const   )130, 
        (flex_int16_t const   )154,      (flex_int16_t const   )154,      (flex_int16_t const   )154,      (flex_int16_t const   )155, 
        (flex_int16_t const   )155,      (flex_int16_t const   )145,      (flex_int16_t const   )108,      (flex_int16_t const   )156, 
        (flex_int16_t const   )156,      (flex_int16_t const   )156,      (flex_int16_t const   )156,      (flex_int16_t const   )156, 
        (flex_int16_t const   )156,      (flex_int16_t const   )61,      (flex_int16_t const   )107,      (flex_int16_t const   )166, 
        (flex_int16_t const   )150,      (flex_int16_t const   )146,      (flex_int16_t const   )146,      (flex_int16_t const   )146, 
        (flex_int16_t const   )118,      (flex_int16_t const   )167,      (flex_int16_t const   )167,      (flex_int16_t const   )110, 
        (flex_int16_t const   )165,      (flex_int16_t const   )186,      (flex_int16_t const   )189,      (flex_int16_t const   )147, 
        (flex_int16_t const   )171,      (flex_int16_t const   )171,      (flex_int16_t const   )171,      (flex_int16_t const   )170, 
        (flex_int16_t const   )170,      (flex_int16_t const   )170,      (flex_int16_t const   )143,      (flex_int16_t const   )107, 
        (flex_int16_t const   )171,      (flex_int16_t const   )171,      (flex_int16_t const   )171,      (flex_int16_t const   )186, 
        (flex_int16_t const   )177,      (flex_int16_t const   )182,      (flex_int16_t const   )61,      (flex_int16_t const   )142, 
        (flex_int16_t const   )182,      (flex_int16_t const   )61,      (flex_int16_t const   )139,      (flex_int16_t const   )188, 
        (flex_int16_t const   )188,      (flex_int16_t const   )138,      (flex_int16_t const   )137,      (flex_int16_t const   )187, 
        (flex_int16_t const   )187,      (flex_int16_t const   )187,      (flex_int16_t const   )183,      (flex_int16_t const   )183, 
        (flex_int16_t const   )183,      (flex_int16_t const   )183,      (flex_int16_t const   )183,      (flex_int16_t const   )183, 
        (flex_int16_t const   )186,      (flex_int16_t const   )188,      (flex_int16_t const   )136,      (flex_int16_t const   )135, 
        (flex_int16_t const   )107,      (flex_int16_t const   )132,      (flex_int16_t const   )128,      (flex_int16_t const   )107, 
        (flex_int16_t const   )123,      (flex_int16_t const   )61,      (flex_int16_t const   )61,      (flex_int16_t const   )118, 
        (flex_int16_t const   )187,      (flex_int16_t const   )187,      (flex_int16_t const   )187,      (flex_int16_t const   )117, 
        (flex_int16_t const   )110,      (flex_int16_t const   )99,      (flex_int16_t const   )98,      (flex_int16_t const   )97, 
        (flex_int16_t const   )94,      (flex_int16_t const   )93,      (flex_int16_t const   )188,      (flex_int16_t const   )43, 
        (flex_int16_t const   )43,      (flex_int16_t const   )43,      (flex_int16_t const   )43,      (flex_int16_t const   )43, 
        (flex_int16_t const   )43,      (flex_int16_t const   )43,      (flex_int16_t const   )43,      (flex_int16_t const   )46, 
        (flex_int16_t const   )46,      (flex_int16_t const   )46,      (flex_int16_t const   )46,      (flex_int16_t const   )46, 
        (flex_int16_t const   )46,      (flex_int16_t const   )46,      (flex_int16_t const   )46,      (flex_int16_t const   )50, 
        (flex_int16_t const   )50,      (flex_int16_t const   )50,      (flex_int16_t const   )50,      (flex_int16_t const   )50, 
        (flex_int16_t const   )50,      (flex_int16_t const   )50,      (flex_int16_t const   )50,      (flex_int16_t const   )54, 
        (flex_int16_t const   )54,      (flex_int16_t const   )54,      (flex_int16_t const   )54,      (flex_int16_t const   )54, 
        (flex_int16_t const   )54,      (flex_int16_t const   )54,      (flex_int16_t const   )54,      (flex_int16_t const   )60, 
        (flex_int16_t const   )60,      (flex_int16_t const   )60,      (flex_int16_t const   )60,      (flex_int16_t const   )60, 
        (flex_int16_t const   )60,      (flex_int16_t const   )60,      (flex_int16_t const   )60,      (flex_int16_t const   )65, 
        (flex_int16_t const   )89,      (flex_int16_t const   )65,      (flex_int16_t const   )65,      (flex_int16_t const   )65, 
        (flex_int16_t const   )65,      (flex_int16_t const   )65,      (flex_int16_t const   )65,      (flex_int16_t const   )85, 
        (flex_int16_t const   )85,      (flex_int16_t const   )85,      (flex_int16_t const   )85,      (flex_int16_t const   )85, 
        (flex_int16_t const   )85,      (flex_int16_t const   )67,      (flex_int16_t const   )85,      (flex_int16_t const   )92, 
        (flex_int16_t const   )92,      (flex_int16_t const   )92,      (flex_int16_t const   )104,      (flex_int16_t const   )104, 
        (flex_int16_t const   )104,      (flex_int16_t const   )104,      (flex_int16_t const   )104,      (flex_int16_t const   )104, 
        (flex_int16_t const   )104,      (flex_int16_t const   )104,      (flex_int16_t const   )109,      (flex_int16_t const   )109, 
        (flex_int16_t const   )109,      (flex_int16_t const   )109,      (flex_int16_t const   )66,      (flex_int16_t const   )109, 
        (flex_int16_t const   )109,      (flex_int16_t const   )109,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )115,      (flex_int16_t const   )62, 
        (flex_int16_t const   )61,      (flex_int16_t const   )115,      (flex_int16_t const   )115,      (flex_int16_t const   )115, 
        (flex_int16_t const   )115,      (flex_int16_t const   )115,      (flex_int16_t const   )116,      (flex_int16_t const   )116, 
        (flex_int16_t const   )116,      (flex_int16_t const   )116,      (flex_int16_t const   )116,      (flex_int16_t const   )116, 
        (flex_int16_t const   )116,      (flex_int16_t const   )116,      (flex_int16_t const   )119,      (flex_int16_t const   )119, 
        (flex_int16_t const   )119,      (flex_int16_t const   )119,      (flex_int16_t const   )119,      (flex_int16_t const   )119, 
        (flex_int16_t const   )119,      (flex_int16_t const   )119,      (flex_int16_t const   )124,      (flex_int16_t const   )59, 
        (flex_int16_t const   )124,      (flex_int16_t const   )124,      (flex_int16_t const   )124,      (flex_int16_t const   )124, 
        (flex_int16_t const   )124,      (flex_int16_t const   )124,      (flex_int16_t const   )131,      (flex_int16_t const   )131, 
        (flex_int16_t const   )131,      (flex_int16_t const   )131,      (flex_int16_t const   )131,      (flex_int16_t const   )131, 
        (flex_int16_t const   )131,      (flex_int16_t const   )131,      (flex_int16_t const   )134,      (flex_int16_t const   )134, 
        (flex_int16_t const   )144,      (flex_int16_t const   )144,      (flex_int16_t const   )144,      (flex_int16_t const   )144, 
        (flex_int16_t const   )144,      (flex_int16_t const   )144,      (flex_int16_t const   )144,      (flex_int16_t const   )144, 
        (flex_int16_t const   )152,      (flex_int16_t const   )190,      (flex_int16_t const   )152,      (flex_int16_t const   )152, 
        (flex_int16_t const   )169,      (flex_int16_t const   )190,      (flex_int16_t const   )169,      (flex_int16_t const   )169, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )11,      (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )190, 
        (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )190, 
        (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )190, 
        (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )190, 
        (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )190, 
        (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )190, 
        (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )190, 
        (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )190, 
        (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )190, 
        (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )190, 
        (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )190, 
        (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )190};
#line 643 "c.c"
static flex_int16_t const   yy_chk[531]  = 
#line 643
  {      (flex_int16_t const   )0,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )2, 
        (flex_int16_t const   )3,      (flex_int16_t const   )4,      (flex_int16_t const   )5,      (flex_int16_t const   )2, 
        (flex_int16_t const   )5,      (flex_int16_t const   )9,      (flex_int16_t const   )10,      (flex_int16_t const   )3, 
        (flex_int16_t const   )4,      (flex_int16_t const   )6,      (flex_int16_t const   )13,      (flex_int16_t const   )6, 
        (flex_int16_t const   )7,      (flex_int16_t const   )7,      (flex_int16_t const   )13,      (flex_int16_t const   )7, 
        (flex_int16_t const   )8,      (flex_int16_t const   )8,      (flex_int16_t const   )19,      (flex_int16_t const   )8, 
        (flex_int16_t const   )28,      (flex_int16_t const   )28,      (flex_int16_t const   )30,      (flex_int16_t const   )30, 
        (flex_int16_t const   )5,      (flex_int16_t const   )181,      (flex_int16_t const   )175,      (flex_int16_t const   )9, 
        (flex_int16_t const   )10,      (flex_int16_t const   )19,      (flex_int16_t const   )22,      (flex_int16_t const   )6, 
        (flex_int16_t const   )22,      (flex_int16_t const   )25,      (flex_int16_t const   )22,      (flex_int16_t const   )22, 
        (flex_int16_t const   )22,      (flex_int16_t const   )25,      (flex_int16_t const   )22,      (flex_int16_t const   )34, 
        (flex_int16_t const   )174,      (flex_int16_t const   )2,      (flex_int16_t const   )25,      (flex_int16_t const   )2, 
        (flex_int16_t const   )23,      (flex_int16_t const   )23,      (flex_int16_t const   )34,      (flex_int16_t const   )23, 
        (flex_int16_t const   )23,      (flex_int16_t const   )23,      (flex_int16_t const   )38,      (flex_int16_t const   )23, 
        (flex_int16_t const   )23,      (flex_int16_t const   )24,      (flex_int16_t const   )173,      (flex_int16_t const   )24, 
        (flex_int16_t const   )24,      (flex_int16_t const   )24,      (flex_int16_t const   )26,      (flex_int16_t const   )172, 
        (flex_int16_t const   )26,      (flex_int16_t const   )26,      (flex_int16_t const   )26,      (flex_int16_t const   )27, 
        (flex_int16_t const   )39,      (flex_int16_t const   )27,      (flex_int16_t const   )27,      (flex_int16_t const   )27, 
        (flex_int16_t const   )39,      (flex_int16_t const   )26,      (flex_int16_t const   )45,      (flex_int16_t const   )54, 
        (flex_int16_t const   )56,      (flex_int16_t const   )169,      (flex_int16_t const   )57,      (flex_int16_t const   )97, 
        (flex_int16_t const   )38,      (flex_int16_t const   )45,      (flex_int16_t const   )57,      (flex_int16_t const   )102, 
        (flex_int16_t const   )167,      (flex_int16_t const   )45,      (flex_int16_t const   )163,      (flex_int16_t const   )102, 
        (flex_int16_t const   )66,      (flex_int16_t const   )162,      (flex_int16_t const   )97,      (flex_int16_t const   )26, 
        (flex_int16_t const   )40,      (flex_int16_t const   )40,      (flex_int16_t const   )66,      (flex_int16_t const   )66, 
        (flex_int16_t const   )161,      (flex_int16_t const   )54,      (flex_int16_t const   )56,      (flex_int16_t const   )69, 
        (flex_int16_t const   )69,      (flex_int16_t const   )69,      (flex_int16_t const   )111,      (flex_int16_t const   )66, 
        (flex_int16_t const   )160,      (flex_int16_t const   )40,      (flex_int16_t const   )40,      (flex_int16_t const   )40, 
        (flex_int16_t const   )70,      (flex_int16_t const   )111,      (flex_int16_t const   )70,      (flex_int16_t const   )70, 
        (flex_int16_t const   )70,      (flex_int16_t const   )111,      (flex_int16_t const   )71,      (flex_int16_t const   )40, 
        (flex_int16_t const   )71,      (flex_int16_t const   )71,      (flex_int16_t const   )71,      (flex_int16_t const   )159, 
        (flex_int16_t const   )152,      (flex_int16_t const   )66,      (flex_int16_t const   )143,      (flex_int16_t const   )40, 
        (flex_int16_t const   )77,      (flex_int16_t const   )77,      (flex_int16_t const   )77,      (flex_int16_t const   )81, 
        (flex_int16_t const   )81,      (flex_int16_t const   )81,      (flex_int16_t const   )142,      (flex_int16_t const   )77, 
        (flex_int16_t const   )104,      (flex_int16_t const   )82,      (flex_int16_t const   )81,      (flex_int16_t const   )82, 
        (flex_int16_t const   )82,      (flex_int16_t const   )82,      (flex_int16_t const   )141,      (flex_int16_t const   )77, 
        (flex_int16_t const   )107,      (flex_int16_t const   )83,      (flex_int16_t const   )81,      (flex_int16_t const   )83, 
        (flex_int16_t const   )83,      (flex_int16_t const   )83,      (flex_int16_t const   )86,      (flex_int16_t const   )106, 
        (flex_int16_t const   )86,      (flex_int16_t const   )86,      (flex_int16_t const   )86,      (flex_int16_t const   )103, 
        (flex_int16_t const   )103,      (flex_int16_t const   )140,      (flex_int16_t const   )104,      (flex_int16_t const   )119, 
        (flex_int16_t const   )108,      (flex_int16_t const   )139,      (flex_int16_t const   )121,      (flex_int16_t const   )106, 
        (flex_int16_t const   )106,      (flex_int16_t const   )106,      (flex_int16_t const   )107,      (flex_int16_t const   )138, 
        (flex_int16_t const   )103,      (flex_int16_t const   )103,      (flex_int16_t const   )103,      (flex_int16_t const   )144, 
        (flex_int16_t const   )113,      (flex_int16_t const   )106,      (flex_int16_t const   )153,      (flex_int16_t const   )153, 
        (flex_int16_t const   )153,      (flex_int16_t const   )147,      (flex_int16_t const   )103,      (flex_int16_t const   )113, 
        (flex_int16_t const   )137,      (flex_int16_t const   )119,      (flex_int16_t const   )108,      (flex_int16_t const   )113, 
        (flex_int16_t const   )121,      (flex_int16_t const   )126,      (flex_int16_t const   )103,      (flex_int16_t const   )105, 
        (flex_int16_t const   )105,      (flex_int16_t const   )108,      (flex_int16_t const   )131,      (flex_int16_t const   )126, 
        (flex_int16_t const   )126,      (flex_int16_t const   )144,      (flex_int16_t const   )127,      (flex_int16_t const   )125, 
        (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )147, 
        (flex_int16_t const   )105,      (flex_int16_t const   )105,      (flex_int16_t const   )105,      (flex_int16_t const   )129, 
        (flex_int16_t const   )149,      (flex_int16_t const   )154,      (flex_int16_t const   )154,      (flex_int16_t const   )154, 
        (flex_int16_t const   )130,      (flex_int16_t const   )130,      (flex_int16_t const   )105,      (flex_int16_t const   )129, 
        (flex_int16_t const   )130,      (flex_int16_t const   )130,      (flex_int16_t const   )130,      (flex_int16_t const   )133, 
        (flex_int16_t const   )133,      (flex_int16_t const   )146,      (flex_int16_t const   )105,      (flex_int16_t const   )133, 
        (flex_int16_t const   )133,      (flex_int16_t const   )133,      (flex_int16_t const   )155,      (flex_int16_t const   )155, 
        (flex_int16_t const   )155,      (flex_int16_t const   )165,      (flex_int16_t const   )149,      (flex_int16_t const   )151, 
        (flex_int16_t const   )124,      (flex_int16_t const   )146,      (flex_int16_t const   )146,      (flex_int16_t const   )146, 
        (flex_int16_t const   )118,      (flex_int16_t const   )151,      (flex_int16_t const   )151,      (flex_int16_t const   )109, 
        (flex_int16_t const   )149,      (flex_int16_t const   )185,      (flex_int16_t const   )188,      (flex_int16_t const   )146, 
        (flex_int16_t const   )156,      (flex_int16_t const   )156,      (flex_int16_t const   )156,      (flex_int16_t const   )170, 
        (flex_int16_t const   )170,      (flex_int16_t const   )170,      (flex_int16_t const   )99,      (flex_int16_t const   )165, 
        (flex_int16_t const   )171,      (flex_int16_t const   )171,      (flex_int16_t const   )171,      (flex_int16_t const   )183, 
        (flex_int16_t const   )165,      (flex_int16_t const   )177,      (flex_int16_t const   )177,      (flex_int16_t const   )98, 
        (flex_int16_t const   )182,      (flex_int16_t const   )182,      (flex_int16_t const   )96,      (flex_int16_t const   )185, 
        (flex_int16_t const   )188,      (flex_int16_t const   )95,      (flex_int16_t const   )94,      (flex_int16_t const   )183, 
        (flex_int16_t const   )183,      (flex_int16_t const   )183,      (flex_int16_t const   )177,      (flex_int16_t const   )177, 
        (flex_int16_t const   )177,      (flex_int16_t const   )182,      (flex_int16_t const   )182,      (flex_int16_t const   )182, 
        (flex_int16_t const   )187,      (flex_int16_t const   )183,      (flex_int16_t const   )91,      (flex_int16_t const   )87, 
        (flex_int16_t const   )177,      (flex_int16_t const   )79,      (flex_int16_t const   )76,      (flex_int16_t const   )182, 
        (flex_int16_t const   )65,      (flex_int16_t const   )60,      (flex_int16_t const   )58,      (flex_int16_t const   )51, 
        (flex_int16_t const   )187,      (flex_int16_t const   )187,      (flex_int16_t const   )187,      (flex_int16_t const   )49, 
        (flex_int16_t const   )43,      (flex_int16_t const   )37,      (flex_int16_t const   )36,      (flex_int16_t const   )35, 
        (flex_int16_t const   )33,      (flex_int16_t const   )32,      (flex_int16_t const   )187,      (flex_int16_t const   )191, 
        (flex_int16_t const   )191,      (flex_int16_t const   )191,      (flex_int16_t const   )191,      (flex_int16_t const   )191, 
        (flex_int16_t const   )191,      (flex_int16_t const   )191,      (flex_int16_t const   )191,      (flex_int16_t const   )192, 
        (flex_int16_t const   )192,      (flex_int16_t const   )192,      (flex_int16_t const   )192,      (flex_int16_t const   )192, 
        (flex_int16_t const   )192,      (flex_int16_t const   )192,      (flex_int16_t const   )192,      (flex_int16_t const   )193, 
        (flex_int16_t const   )193,      (flex_int16_t const   )193,      (flex_int16_t const   )193,      (flex_int16_t const   )193, 
        (flex_int16_t const   )193,      (flex_int16_t const   )193,      (flex_int16_t const   )193,      (flex_int16_t const   )194, 
        (flex_int16_t const   )194,      (flex_int16_t const   )194,      (flex_int16_t const   )194,      (flex_int16_t const   )194, 
        (flex_int16_t const   )194,      (flex_int16_t const   )194,      (flex_int16_t const   )194,      (flex_int16_t const   )195, 
        (flex_int16_t const   )195,      (flex_int16_t const   )195,      (flex_int16_t const   )195,      (flex_int16_t const   )195, 
        (flex_int16_t const   )195,      (flex_int16_t const   )195,      (flex_int16_t const   )195,      (flex_int16_t const   )196, 
        (flex_int16_t const   )29,      (flex_int16_t const   )196,      (flex_int16_t const   )196,      (flex_int16_t const   )196, 
        (flex_int16_t const   )196,      (flex_int16_t const   )196,      (flex_int16_t const   )196,      (flex_int16_t const   )197, 
        (flex_int16_t const   )197,      (flex_int16_t const   )197,      (flex_int16_t const   )197,      (flex_int16_t const   )197, 
        (flex_int16_t const   )197,      (flex_int16_t const   )21,      (flex_int16_t const   )197,      (flex_int16_t const   )198, 
        (flex_int16_t const   )198,      (flex_int16_t const   )198,      (flex_int16_t const   )199,      (flex_int16_t const   )199, 
        (flex_int16_t const   )199,      (flex_int16_t const   )199,      (flex_int16_t const   )199,      (flex_int16_t const   )199, 
        (flex_int16_t const   )199,      (flex_int16_t const   )199,      (flex_int16_t const   )200,      (flex_int16_t const   )200, 
        (flex_int16_t const   )200,      (flex_int16_t const   )200,      (flex_int16_t const   )20,      (flex_int16_t const   )200, 
        (flex_int16_t const   )200,      (flex_int16_t const   )200,      (flex_int16_t const   )201,      (flex_int16_t const   )201, 
        (flex_int16_t const   )201,      (flex_int16_t const   )201,      (flex_int16_t const   )201,      (flex_int16_t const   )201, 
        (flex_int16_t const   )201,      (flex_int16_t const   )201,      (flex_int16_t const   )202,      (flex_int16_t const   )18, 
        (flex_int16_t const   )17,      (flex_int16_t const   )202,      (flex_int16_t const   )202,      (flex_int16_t const   )202, 
        (flex_int16_t const   )202,      (flex_int16_t const   )202,      (flex_int16_t const   )203,      (flex_int16_t const   )203, 
        (flex_int16_t const   )203,      (flex_int16_t const   )203,      (flex_int16_t const   )203,      (flex_int16_t const   )203, 
        (flex_int16_t const   )203,      (flex_int16_t const   )203,      (flex_int16_t const   )204,      (flex_int16_t const   )204, 
        (flex_int16_t const   )204,      (flex_int16_t const   )204,      (flex_int16_t const   )204,      (flex_int16_t const   )204, 
        (flex_int16_t const   )204,      (flex_int16_t const   )204,      (flex_int16_t const   )205,      (flex_int16_t const   )15, 
        (flex_int16_t const   )205,      (flex_int16_t const   )205,      (flex_int16_t const   )205,      (flex_int16_t const   )205, 
        (flex_int16_t const   )205,      (flex_int16_t const   )205,      (flex_int16_t const   )206,      (flex_int16_t const   )206, 
        (flex_int16_t const   )206,      (flex_int16_t const   )206,      (flex_int16_t const   )206,      (flex_int16_t const   )206, 
        (flex_int16_t const   )206,      (flex_int16_t const   )206,      (flex_int16_t const   )207,      (flex_int16_t const   )207, 
        (flex_int16_t const   )208,      (flex_int16_t const   )208,      (flex_int16_t const   )208,      (flex_int16_t const   )208, 
        (flex_int16_t const   )208,      (flex_int16_t const   )208,      (flex_int16_t const   )208,      (flex_int16_t const   )208, 
        (flex_int16_t const   )209,      (flex_int16_t const   )11,      (flex_int16_t const   )209,      (flex_int16_t const   )209, 
        (flex_int16_t const   )210,      (flex_int16_t const   )0,      (flex_int16_t const   )210,      (flex_int16_t const   )210, 
        (flex_int16_t const   )211,      (flex_int16_t const   )211,      (flex_int16_t const   )211,      (flex_int16_t const   )211, 
        (flex_int16_t const   )211,      (flex_int16_t const   )211,      (flex_int16_t const   )211,      (flex_int16_t const   )211, 
        (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )190, 
        (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )190, 
        (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )190, 
        (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )190, 
        (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )190, 
        (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )190, 
        (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )190, 
        (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )190, 
        (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )190, 
        (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )190, 
        (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )190, 
        (flex_int16_t const   )190,      (flex_int16_t const   )190,      (flex_int16_t const   )190};
#line 705 "c.c"
static yy_state_type yy_last_accepting_state  ;
#line 706 "c.c"
static char *yy_last_accepting_cpos  ;
#line 708
int yy_flex_debug ;
#line 709 "c.c"
int yy_flex_debug  =    1;
#line 711 "c.c"
static flex_int16_t const   yy_rule_linenum[81]  = 
#line 711
  {      (flex_int16_t const   )0,      (flex_int16_t const   )58,      (flex_int16_t const   )59,      (flex_int16_t const   )60, 
        (flex_int16_t const   )61,      (flex_int16_t const   )62,      (flex_int16_t const   )63,      (flex_int16_t const   )64, 
        (flex_int16_t const   )66,      (flex_int16_t const   )67,      (flex_int16_t const   )69,      (flex_int16_t const   )70, 
        (flex_int16_t const   )71,      (flex_int16_t const   )72,      (flex_int16_t const   )74,      (flex_int16_t const   )75, 
        (flex_int16_t const   )76,      (flex_int16_t const   )77,      (flex_int16_t const   )78,      (flex_int16_t const   )79, 
        (flex_int16_t const   )80,      (flex_int16_t const   )81,      (flex_int16_t const   )87,      (flex_int16_t const   )88, 
        (flex_int16_t const   )89,      (flex_int16_t const   )90,      (flex_int16_t const   )91,      (flex_int16_t const   )92, 
        (flex_int16_t const   )93,      (flex_int16_t const   )94,      (flex_int16_t const   )95,      (flex_int16_t const   )96, 
        (flex_int16_t const   )97,      (flex_int16_t const   )98,      (flex_int16_t const   )99,      (flex_int16_t const   )100, 
        (flex_int16_t const   )101,      (flex_int16_t const   )102,      (flex_int16_t const   )103,      (flex_int16_t const   )104, 
        (flex_int16_t const   )105,      (flex_int16_t const   )106,      (flex_int16_t const   )107,      (flex_int16_t const   )108, 
        (flex_int16_t const   )109,      (flex_int16_t const   )110,      (flex_int16_t const   )111,      (flex_int16_t const   )112, 
        (flex_int16_t const   )113,      (flex_int16_t const   )114,      (flex_int16_t const   )115,      (flex_int16_t const   )116, 
        (flex_int16_t const   )117,      (flex_int16_t const   )118,      (flex_int16_t const   )119,      (flex_int16_t const   )120, 
        (flex_int16_t const   )121,      (flex_int16_t const   )122,      (flex_int16_t const   )123,      (flex_int16_t const   )127, 
        (flex_int16_t const   )128,      (flex_int16_t const   )129,      (flex_int16_t const   )133,      (flex_int16_t const   )137, 
        (flex_int16_t const   )138,      (flex_int16_t const   )139,      (flex_int16_t const   )152,      (flex_int16_t const   )153, 
        (flex_int16_t const   )154,      (flex_int16_t const   )155,      (flex_int16_t const   )156,      (flex_int16_t const   )157, 
        (flex_int16_t const   )158,      (flex_int16_t const   )159,      (flex_int16_t const   )160,      (flex_int16_t const   )161, 
        (flex_int16_t const   )166,      (flex_int16_t const   )167,      (flex_int16_t const   )169,      (flex_int16_t const   )170, 
        (flex_int16_t const   )171};
#line 31 "c.l"
struct obstack string_stk  ;
#line 39
int ident(void) ;
#line 40
void update_loc(void) ;
#line 46 "c.l"
static int prev_token  ;
#line 801 "c.c"
static int yy_init_globals(void) ;
#line 811
int yylex_destroy(void) ;
#line 813
int yyget_debug(void) ;
#line 815
void yyset_debug(int bdebug ) ;
#line 821
FILE *yyget_in(void) ;
#line 823
void yyset_in(FILE *in_str ) ;
#line 825
FILE *yyget_out(void) ;
#line 827
void yyset_out(FILE *out_str ) ;
#line 829
int yyget_leng(void) ;
#line 831
char *yyget_text(void) ;
#line 833
int yyget_lineno(void) ;
#line 835
void yyset_lineno(int line_number ) ;
#line 848
int yywrap(void) ;
#line 854
static void yyunput(int c , char *yy_bp ) ;
#line 875
static int input(void) ;
#line 1015 "c.c"
int yylex(void) 
{ 
  register yy_state_type yy_current_state ;
  register char *yy_cp ;
  register char *yy_bp ;
  register int yy_act ;
  YY_BUFFER_STATE tmp ;
  register YY_CHAR yy_c ;
  int tmp___0 ;
  struct obstack *__o ;
  int __len ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___1 ;
  char *tmp___2 ;
  int yyless_macro_arg ;
  struct obstack *__o___0 ;
  int __len___0 ;
  struct obstack *__o1___0 ;
  void *__value___0 ;
  char *tmp___3 ;
  char *tmp___4 ;
  struct obstack *__o___1 ;
  int __len___1 ;
  struct obstack *__o1___1 ;
  void *__value___1 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int yyless_macro_arg___0 ;
  int yy_amount_of_matched_text ;
  yy_state_type yy_next_state ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 1027
  if (! yy_init) {
#line 1029
    yy_init = 1;
#line 1035
    if (! yy_start) {
#line 1036
      yy_start = 1;
    }
#line 1038
    if (! yyin) {
#line 1040
      yyin = stdin;
    }
#line 1045
    if (! yyout) {
#line 1047
      yyout = stdout;
    }
#line 1052
    if (yy_buffer_stack) {
#line 1052
      tmp = *(yy_buffer_stack + yy_buffer_stack_top);
    } else {
#line 1052
      tmp = (YY_BUFFER_STATE )((void *)0);
    }
#line 1052
    if (! tmp) {
      {
#line 1053
      yyensure_buffer_stack();
#line 1054
      *(yy_buffer_stack + yy_buffer_stack_top) = yy_create_buffer(yyin, 16384);
      }
    }
    {
#line 1058
    yy_load_buffer_state();
    }
  }
  {
#line 1061
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1064
    yy_cp = yy_c_buf_p;
#line 1067
    *yy_cp = yy_hold_char;
#line 1072
    yy_bp = yy_cp;
#line 1075
    yy_current_state = yy_start;
#line 1076
    yy_current_state += (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol;
    yy_match: 
    {
#line 1078
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1080
      yy_c = (YY_CHAR )yy_ec[(unsigned int )((unsigned char )*yy_cp)];
#line 1081
      if (yy_accept[yy_current_state]) {
#line 1083
        yy_last_accepting_state = yy_current_state;
#line 1084
        yy_last_accepting_cpos = yy_cp;
      }
      {
#line 1086
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1086
        if (! ((int const   )yy_chk[(int const   )yy_base[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 1086
          goto while_break___1;
        }
#line 1088
        yy_current_state = (int )yy_def[yy_current_state];
#line 1089
        if (yy_current_state >= 191) {
#line 1090
          yy_c = (YY_CHAR )yy_meta[(unsigned int )yy_c];
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1092
      yy_current_state = (yy_state_type )yy_nxt[(unsigned int )yy_base[yy_current_state] + (unsigned int )yy_c];
#line 1093
      yy_cp ++;
#line 1078
      if (! ((int const   )yy_base[yy_current_state] != 484)) {
#line 1078
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    yy_find_action: 
#line 1099
    yy_act = (int )yy_accept[yy_current_state];
#line 1100
    if (yy_act == 0) {
#line 1102
      yy_cp = yy_last_accepting_cpos;
#line 1103
      yy_current_state = yy_last_accepting_state;
#line 1104
      yy_act = (int )yy_accept[yy_current_state];
    }
#line 1107
    yytext = yy_bp;
#line 1107
    yyleng = (int )((size_t )(yy_cp - yy_bp));
#line 1107
    yy_hold_char = *yy_cp;
#line 1107
    *yy_cp = (char )'\000';
#line 1107
    yy_c_buf_p = yy_cp;
    do_action: 
#line 1114
    if (yy_flex_debug) {
#line 1116
      if (yy_act == 0) {
        {
#line 1117
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"--scanner backing up\n");
        }
      } else
#line 1118
      if (yy_act < 81) {
        {
#line 1119
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"--accepting rule at line %ld (\"%s\")\n",
                (long )yy_rule_linenum[yy_act], yytext);
        }
      } else
#line 1121
      if (yy_act == 81) {
        {
#line 1122
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"--accepting default rule (\"%s\")\n",
                yytext);
        }
      } else
#line 1124
      if (yy_act == 82) {
        {
#line 1125
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"--(end of buffer or a NUL)\n");
        }
      } else {
        {
#line 1127
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"--EOF (start condition %d)\n",
                (yy_start - 1) / 2);
        }
      }
    }
    {
#line 1133
    if (yy_act == 0) {
#line 1133
      goto case_0;
    }
#line 1140
    if (yy_act == 1) {
#line 1140
      goto case_1;
    }
#line 60
    if (yy_act == 2) {
#line 60 "c.l"
      goto case_2;
    }
#line 61
    if (yy_act == 3) {
#line 61
      goto case_3;
    }
#line 62
    if (yy_act == 4) {
#line 62
      goto case_4;
    }
#line 63
    if (yy_act == 5) {
#line 63
      goto case_5;
    }
#line 64
    if (yy_act == 6) {
#line 64
      goto case_6;
    }
#line 65
    if (yy_act == 7) {
#line 65
      goto case_7;
    }
#line 67
    if (yy_act == 9) {
#line 67
      goto case_9;
    }
#line 67
    if (yy_act == 8) {
#line 67
      goto case_9;
    }
#line 70
    if (yy_act == 10) {
#line 70
      goto case_10;
    }
#line 71
    if (yy_act == 11) {
#line 71
      goto case_11;
    }
#line 72
    if (yy_act == 12) {
#line 72
      goto case_12;
    }
#line 73
    if (yy_act == 13) {
#line 73
      goto case_13;
    }
#line 75
    if (yy_act == 14) {
#line 75
      goto case_14;
    }
#line 76
    if (yy_act == 15) {
#line 76
      goto case_15;
    }
#line 77
    if (yy_act == 16) {
#line 77
      goto case_16;
    }
#line 78
    if (yy_act == 17) {
#line 78
      goto case_17;
    }
#line 79
    if (yy_act == 18) {
#line 79
      goto case_18;
    }
#line 80
    if (yy_act == 19) {
#line 80
      goto case_19;
    }
#line 81
    if (yy_act == 20) {
#line 81
      goto case_20;
    }
#line 82
    if (yy_act == 21) {
#line 82
      goto case_21;
    }
#line 88
    if (yy_act == 22) {
#line 88
      goto case_22;
    }
#line 89
    if (yy_act == 23) {
#line 89
      goto case_23;
    }
#line 90
    if (yy_act == 24) {
#line 90
      goto case_24;
    }
#line 91
    if (yy_act == 25) {
#line 91
      goto case_25;
    }
#line 92
    if (yy_act == 26) {
#line 92
      goto case_26;
    }
#line 93
    if (yy_act == 27) {
#line 93
      goto case_27;
    }
#line 94
    if (yy_act == 28) {
#line 94
      goto case_28;
    }
#line 95
    if (yy_act == 29) {
#line 95
      goto case_29;
    }
#line 96
    if (yy_act == 30) {
#line 96
      goto case_30;
    }
#line 97
    if (yy_act == 31) {
#line 97
      goto case_31;
    }
#line 98
    if (yy_act == 32) {
#line 98
      goto case_32;
    }
#line 99
    if (yy_act == 33) {
#line 99
      goto case_33;
    }
#line 100
    if (yy_act == 34) {
#line 100
      goto case_34;
    }
#line 101
    if (yy_act == 35) {
#line 101
      goto case_35;
    }
#line 102
    if (yy_act == 36) {
#line 102
      goto case_36;
    }
#line 103
    if (yy_act == 37) {
#line 103
      goto case_37;
    }
#line 104
    if (yy_act == 38) {
#line 104
      goto case_38;
    }
#line 105
    if (yy_act == 39) {
#line 105
      goto case_39;
    }
#line 106
    if (yy_act == 40) {
#line 106
      goto case_40;
    }
#line 107
    if (yy_act == 41) {
#line 107
      goto case_41;
    }
#line 108
    if (yy_act == 42) {
#line 108
      goto case_42;
    }
#line 109
    if (yy_act == 43) {
#line 109
      goto case_43;
    }
#line 110
    if (yy_act == 44) {
#line 110
      goto case_44;
    }
#line 111
    if (yy_act == 45) {
#line 111
      goto case_45;
    }
#line 112
    if (yy_act == 46) {
#line 112
      goto case_46;
    }
#line 113
    if (yy_act == 47) {
#line 113
      goto case_47;
    }
#line 114
    if (yy_act == 48) {
#line 114
      goto case_48;
    }
#line 115
    if (yy_act == 49) {
#line 115
      goto case_49;
    }
#line 116
    if (yy_act == 50) {
#line 116
      goto case_50;
    }
#line 117
    if (yy_act == 51) {
#line 117
      goto case_51;
    }
#line 118
    if (yy_act == 52) {
#line 118
      goto case_52;
    }
#line 119
    if (yy_act == 53) {
#line 119
      goto case_53;
    }
#line 120
    if (yy_act == 54) {
#line 120
      goto case_54;
    }
#line 123
    if (yy_act == 58) {
#line 123
      goto case_58;
    }
#line 123
    if (yy_act == 57) {
#line 123
      goto case_58;
    }
#line 123
    if (yy_act == 56) {
#line 123
      goto case_58;
    }
#line 123
    if (yy_act == 55) {
#line 123
      goto case_58;
    }
#line 128
    if (yy_act == 60) {
#line 128
      goto case_60;
    }
#line 128
    if (yy_act == 59) {
#line 128
      goto case_60;
    }
#line 130
    if (yy_act == 61) {
#line 130
      goto case_61;
    }
#line 134
    if (yy_act == 62) {
#line 134
      goto case_62;
    }
#line 139
    if (yy_act == 65) {
#line 139
      goto case_65;
    }
#line 139
    if (yy_act == 64) {
#line 139
      goto case_65;
    }
#line 139
    if (yy_act == 63) {
#line 139
      goto case_65;
    }
#line 152
    if (yy_act == 66) {
#line 152
      goto case_66;
    }
#line 154
    if (yy_act == 67) {
#line 154
      goto case_67;
    }
#line 155
    if (yy_act == 68) {
#line 155
      goto case_68;
    }
#line 156
    if (yy_act == 69) {
#line 156
      goto case_69;
    }
#line 157
    if (yy_act == 70) {
#line 157
      goto case_70;
    }
#line 158
    if (yy_act == 71) {
#line 158
      goto case_71;
    }
#line 159
    if (yy_act == 72) {
#line 159
      goto case_72;
    }
#line 160
    if (yy_act == 73) {
#line 160
      goto case_73;
    }
#line 161
    if (yy_act == 74) {
#line 161
      goto case_74;
    }
#line 162
    if (yy_act == 75) {
#line 162
      goto case_75;
    }
#line 167
    if (yy_act == 76) {
#line 167
      goto case_76;
    }
#line 168
    if (yy_act == 77) {
#line 168
      goto case_77;
    }
#line 170
    if (yy_act == 78) {
#line 170
      goto case_78;
    }
#line 171
    if (yy_act == 79) {
#line 171
      goto case_79;
    }
#line 172
    if (yy_act == 80) {
#line 172
      goto case_80;
    }
#line 173
    if (yy_act == 81) {
#line 173
      goto case_81;
    }
#line 1576
    if (yy_act == 87) {
#line 1576 "c.c"
      goto case_87;
    }
#line 1576
    if (yy_act == 86) {
#line 1576
      goto case_87;
    }
#line 1576
    if (yy_act == 85) {
#line 1576
      goto case_87;
    }
#line 1576
    if (yy_act == 84) {
#line 1576
      goto case_87;
    }
#line 1576
    if (yy_act == 83) {
#line 1576
      goto case_87;
    }
#line 1579
    if (yy_act == 82) {
#line 1579
      goto case_82;
    }
#line 1702
    goto switch_default;
    case_0: /* CIL Label */ 
#line 1135
    *yy_cp = yy_hold_char;
#line 1136
    yy_cp = yy_last_accepting_cpos;
#line 1137
    yy_current_state = yy_last_accepting_state;
#line 1138
    goto yy_find_action;
    case_1: /* CIL Label */ 
#line 1142
    if (yyleng > 0) {
#line 1142
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 58 "c.l"
    line_num ++;
#line 59
    goto switch_break;
    case_2: /* CIL Label */ 
#line 61
    if (yyleng > 0) {
#line 61
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 59
    yy_start = 3;
#line 60
    goto switch_break;
    case_3: /* CIL Label */ 
#line 62
    if (yyleng > 0) {
#line 62
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 61
    goto switch_break;
    case_4: /* CIL Label */ 
#line 64
    if (yyleng > 0) {
#line 64
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 61
    line_num ++;
#line 62
    goto switch_break;
    case_5: /* CIL Label */ 
#line 64
    if (yyleng > 0) {
#line 64
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 63
    goto switch_break;
    case_6: /* CIL Label */ 
#line 66
    if (yyleng > 0) {
#line 66
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 63
    line_num ++;
#line 64
    goto switch_break;
    case_7: /* CIL Label */ 
#line 66
    if (yyleng > 0) {
#line 66
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 64
    yy_start = 1;
#line 65
    goto switch_break;
    case_9: /* CIL Label */ 
    case_8: /* CIL Label */ 
#line 69
    if (yyleng > 0) {
#line 69
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
    {
#line 67
    update_loc();
    }
#line 68
    goto switch_break;
    case_10: /* CIL Label */ 
#line 72
    if (yyleng > 0) {
#line 72
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 69
    yy_start = 9;
#line 69
    line_num ++;
#line 70
    goto switch_break;
    case_11: /* CIL Label */ 
#line 73
    if (yyleng > 0) {
#line 73
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 70
    line_num ++;
#line 71
    goto switch_break;
    case_12: /* CIL Label */ 
#line 74
    if (yyleng > 0) {
#line 74
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 71
    line_num ++;
#line 72
    goto switch_break;
    case_13: /* CIL Label */ 
#line 75
    if (yyleng > 0) {
#line 75
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 72
    yy_start = 1;
#line 72
    line_num ++;
#line 73
    goto switch_break;
    case_14: /* CIL Label */ 
#line 76
    if (yyleng > 0) {
#line 76
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 75
    goto switch_break;
    case_15: /* CIL Label */ 
#line 77
    if (yyleng > 0) {
#line 77
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 75
    return (261);
#line 76
    goto switch_break;
    case_16: /* CIL Label */ 
#line 78
    if (yyleng > 0) {
#line 78
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 76
    return (262);
#line 77
    goto switch_break;
    case_17: /* CIL Label */ 
#line 79
    if (yyleng > 0) {
#line 79
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 77
    return (263);
#line 78
    goto switch_break;
    case_18: /* CIL Label */ 
#line 80
    if (yyleng > 0) {
#line 80
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 78
    yylval.str = (char *)"struct";
#line 78
    return (264);
#line 79
    goto switch_break;
    case_19: /* CIL Label */ 
#line 81
    if (yyleng > 0) {
#line 81
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 79
    yylval.str = (char *)"union";
#line 79
    return (264);
#line 80
    goto switch_break;
    case_20: /* CIL Label */ 
#line 82
    if (yyleng > 0) {
#line 82
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 80
    yylval.str = (char *)"enum";
#line 80
    return (264);
#line 81
    goto switch_break;
    case_21: /* CIL Label */ 
#line 83
    if (yyleng > 0) {
#line 83
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 81
    yylval.str = (char *)"*";
#line 82
    return (265);
#line 84
    goto switch_break;
    case_22: /* CIL Label */ 
#line 89
    if (yyleng > 0) {
#line 89
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 87
    yylval.str = (char *)"->";
#line 87
    return (269);
#line 88
    goto switch_break;
    case_23: /* CIL Label */ 
#line 90
    if (yyleng > 0) {
#line 90
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 88
    yylval.str = (char *)".";
#line 88
    return (269);
#line 89
    goto switch_break;
    case_24: /* CIL Label */ 
#line 91
    if (yyleng > 0) {
#line 91
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 89
    yylval.str = (char *)"*=";
#line 89
    return (266);
#line 90
    goto switch_break;
    case_25: /* CIL Label */ 
#line 92
    if (yyleng > 0) {
#line 92
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 90
    yylval.str = (char *)"/=";
#line 90
    return (266);
#line 91
    goto switch_break;
    case_26: /* CIL Label */ 
#line 93
    if (yyleng > 0) {
#line 93
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 91
    yylval.str = (char *)"/";
#line 91
    return (266);
#line 92
    goto switch_break;
    case_27: /* CIL Label */ 
#line 94
    if (yyleng > 0) {
#line 94
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 92
    yylval.str = (char *)"%=";
#line 92
    return (266);
#line 93
    goto switch_break;
    case_28: /* CIL Label */ 
#line 95
    if (yyleng > 0) {
#line 95
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 93
    yylval.str = (char *)"%";
#line 93
    return (266);
#line 94
    goto switch_break;
    case_29: /* CIL Label */ 
#line 96
    if (yyleng > 0) {
#line 96
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 94
    yylval.str = (char *)"+=";
#line 94
    return (266);
#line 95
    goto switch_break;
    case_30: /* CIL Label */ 
#line 97
    if (yyleng > 0) {
#line 97
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 95
    yylval.str = (char *)"+";
#line 95
    return (266);
#line 96
    goto switch_break;
    case_31: /* CIL Label */ 
#line 98
    if (yyleng > 0) {
#line 98
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 96
    yylval.str = (char *)"-=";
#line 96
    return (266);
#line 97
    goto switch_break;
    case_32: /* CIL Label */ 
#line 99
    if (yyleng > 0) {
#line 99
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 97
    yylval.str = (char *)"-";
#line 97
    return (266);
#line 98
    goto switch_break;
    case_33: /* CIL Label */ 
#line 100
    if (yyleng > 0) {
#line 100
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 98
    yylval.str = (char *)"<<=";
#line 98
    return (266);
#line 99
    goto switch_break;
    case_34: /* CIL Label */ 
#line 101
    if (yyleng > 0) {
#line 101
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 99
    yylval.str = (char *)">>=";
#line 99
    return (266);
#line 100
    goto switch_break;
    case_35: /* CIL Label */ 
#line 102
    if (yyleng > 0) {
#line 102
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 100
    yylval.str = (char *)"&=";
#line 100
    return (266);
#line 101
    goto switch_break;
    case_36: /* CIL Label */ 
#line 103
    if (yyleng > 0) {
#line 103
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 101
    yylval.str = (char *)"|=";
#line 101
    return (266);
#line 102
    goto switch_break;
    case_37: /* CIL Label */ 
#line 104
    if (yyleng > 0) {
#line 104
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 102
    yylval.str = (char *)"^=";
#line 102
    return (266);
#line 103
    goto switch_break;
    case_38: /* CIL Label */ 
#line 105
    if (yyleng > 0) {
#line 105
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 103
    yylval.str = (char *)"^";
#line 103
    return (266);
#line 104
    goto switch_break;
    case_39: /* CIL Label */ 
#line 106
    if (yyleng > 0) {
#line 106
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 104
    yylval.str = (char *)"||";
#line 104
    return (266);
#line 105
    goto switch_break;
    case_40: /* CIL Label */ 
#line 107
    if (yyleng > 0) {
#line 107
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 105
    yylval.str = (char *)"|";
#line 105
    return (266);
#line 106
    goto switch_break;
    case_41: /* CIL Label */ 
#line 108
    if (yyleng > 0) {
#line 108
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 106
    yylval.str = (char *)"&&";
#line 106
    return (266);
#line 107
    goto switch_break;
    case_42: /* CIL Label */ 
#line 109
    if (yyleng > 0) {
#line 109
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 107
    yylval.str = (char *)"&";
#line 107
    return (266);
#line 108
    goto switch_break;
    case_43: /* CIL Label */ 
#line 110
    if (yyleng > 0) {
#line 110
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 108
    yylval.str = (char *)"==";
#line 108
    return (266);
#line 109
    goto switch_break;
    case_44: /* CIL Label */ 
#line 111
    if (yyleng > 0) {
#line 111
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 109
    yylval.str = (char *)"=";
#line 109
    return ('=');
#line 110
    goto switch_break;
    case_45: /* CIL Label */ 
#line 112
    if (yyleng > 0) {
#line 112
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 110
    yylval.str = (char *)"!=";
#line 110
    return (266);
#line 111
    goto switch_break;
    case_46: /* CIL Label */ 
#line 113
    if (yyleng > 0) {
#line 113
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 111
    yylval.str = (char *)"!";
#line 111
    return (266);
#line 112
    goto switch_break;
    case_47: /* CIL Label */ 
#line 114
    if (yyleng > 0) {
#line 114
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 112
    yylval.str = (char *)">=";
#line 112
    return (266);
#line 113
    goto switch_break;
    case_48: /* CIL Label */ 
#line 115
    if (yyleng > 0) {
#line 115
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 113
    yylval.str = (char *)">";
#line 113
    return (266);
#line 114
    goto switch_break;
    case_49: /* CIL Label */ 
#line 116
    if (yyleng > 0) {
#line 116
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 114
    yylval.str = (char *)"<=";
#line 114
    return (266);
#line 115
    goto switch_break;
    case_50: /* CIL Label */ 
#line 117
    if (yyleng > 0) {
#line 117
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 115
    yylval.str = (char *)"<";
#line 115
    return (266);
#line 116
    goto switch_break;
    case_51: /* CIL Label */ 
#line 118
    if (yyleng > 0) {
#line 118
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 116
    yylval.str = (char *)"<<";
#line 116
    return (266);
#line 117
    goto switch_break;
    case_52: /* CIL Label */ 
#line 119
    if (yyleng > 0) {
#line 119
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 117
    yylval.str = (char *)">>";
#line 117
    return (266);
#line 118
    goto switch_break;
    case_53: /* CIL Label */ 
#line 120
    if (yyleng > 0) {
#line 120
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 118
    yylval.str = (char *)"++";
#line 118
    return (266);
#line 119
    goto switch_break;
    case_54: /* CIL Label */ 
#line 121
    if (yyleng > 0) {
#line 121
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 119
    yylval.str = (char *)"--";
#line 119
    return (266);
#line 120
    goto switch_break;
    case_58: /* CIL Label */ 
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
#line 124
    if (yyleng > 0) {
#line 124
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 123
    return (271);
#line 124
    goto switch_break;
    case_60: /* CIL Label */ 
    case_59: /* CIL Label */ 
#line 129
    if (yyleng > 0) {
#line 129
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
    {
#line 128
    tmp___0 = ident();
    }
#line 128
    return (tmp___0);
#line 129
    goto switch_break;
    case_61: /* CIL Label */ 
#line 131
    if (yyleng > 0) {
#line 131
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 129
    __o = & string_stk;
#line 129
    __len = yyleng + 1;
#line 129
    if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
      {
#line 129
      _obstack_newchunk(__o, __len);
      }
    }
    {
#line 129
    memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)yytext,
           (size_t )__len);
#line 129
    __o->next_free += __len;
#line 130
    __o1 = & string_stk;
#line 130
    __value = (void *)__o1->object_base;
    }
#line 130
    if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 130
      __o1->maybe_empty_object = 1U;
    }
#line 130
    if (sizeof(long ) < sizeof(void *)) {
#line 130
      tmp___1 = __o1->object_base;
    } else {
#line 130
      tmp___1 = (char *)0;
    }
#line 130
    if (sizeof(long ) < sizeof(void *)) {
#line 130
      tmp___2 = __o1->object_base;
    } else {
#line 130
      tmp___2 = (char *)0;
    }
#line 130
    __o1->next_free = tmp___1 + (((__o1->next_free - tmp___2) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 130
    if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 130
      __o1->next_free = __o1->chunk_limit;
    }
#line 130
    __o1->object_base = __o1->next_free;
#line 130
    yylval.str = (char *)__value;
#line 131
    return (257);
#line 133
    goto switch_break;
    case_62: /* CIL Label */ 
#line 136
    if (yyleng > 0) {
#line 136
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
    {
#line 133
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 133
      yyless_macro_arg = yyleng - 1;
#line 133
      *yy_cp = yy_hold_char;
#line 133
      yy_cp = (yy_bp + yyless_macro_arg) - 0;
#line 133
      yy_c_buf_p = yy_cp;
#line 133
      yytext = yy_bp;
#line 133
      yyleng = (int )((size_t )(yy_cp - yy_bp));
#line 133
      yy_hold_char = *yy_cp;
#line 133
      *yy_cp = (char )'\000';
#line 133
      yy_c_buf_p = yy_cp;
#line 133
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 134
    __o___0 = & string_stk;
#line 134
    __len___0 = yyleng + 1;
#line 134
    if ((unsigned long )(__o___0->next_free + __len___0) > (unsigned long )__o___0->chunk_limit) {
      {
#line 134
      _obstack_newchunk(__o___0, __len___0);
      }
    }
    {
#line 134
    memcpy((void */* __restrict  */)__o___0->next_free, (void const   */* __restrict  */)yytext,
           (size_t )__len___0);
#line 134
    __o___0->next_free += __len___0;
#line 135
    __o1___0 = & string_stk;
#line 135
    __value___0 = (void *)__o1___0->object_base;
    }
#line 135
    if ((unsigned long )__o1___0->next_free == (unsigned long )__value___0) {
#line 135
      __o1___0->maybe_empty_object = 1U;
    }
#line 135
    if (sizeof(long ) < sizeof(void *)) {
#line 135
      tmp___3 = __o1___0->object_base;
    } else {
#line 135
      tmp___3 = (char *)0;
    }
#line 135
    if (sizeof(long ) < sizeof(void *)) {
#line 135
      tmp___4 = __o1___0->object_base;
    } else {
#line 135
      tmp___4 = (char *)0;
    }
#line 135
    __o1___0->next_free = tmp___3 + (((__o1___0->next_free - tmp___4) + (long )__o1___0->alignment_mask) & (long )(~ __o1___0->alignment_mask));
#line 135
    if (__o1___0->next_free - (char *)__o1___0->chunk > __o1___0->chunk_limit - (char *)__o1___0->chunk) {
#line 135
      __o1___0->next_free = __o1___0->chunk_limit;
    }
#line 135
    __o1___0->object_base = __o1___0->next_free;
#line 135
    yylval.str = (char *)__value___0;
#line 136
    return (257);
#line 137
    goto switch_break;
    case_65: /* CIL Label */ 
    case_64: /* CIL Label */ 
    case_63: /* CIL Label */ 
#line 140
    if (yyleng > 0) {
#line 140
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 140
    __o___1 = & string_stk;
#line 140
    __len___1 = yyleng + 1;
#line 140
    if ((unsigned long )(__o___1->next_free + __len___1) > (unsigned long )__o___1->chunk_limit) {
      {
#line 140
      _obstack_newchunk(__o___1, __len___1);
      }
    }
    {
#line 140
    memcpy((void */* __restrict  */)__o___1->next_free, (void const   */* __restrict  */)yytext,
           (size_t )__len___1);
#line 140
    __o___1->next_free += __len___1;
#line 141
    __o1___1 = & string_stk;
#line 141
    __value___1 = (void *)__o1___1->object_base;
    }
#line 141
    if ((unsigned long )__o1___1->next_free == (unsigned long )__value___1) {
#line 141
      __o1___1->maybe_empty_object = 1U;
    }
#line 141
    if (sizeof(long ) < sizeof(void *)) {
#line 141
      tmp___5 = __o1___1->object_base;
    } else {
#line 141
      tmp___5 = (char *)0;
    }
#line 141
    if (sizeof(long ) < sizeof(void *)) {
#line 141
      tmp___6 = __o1___1->object_base;
    } else {
#line 141
      tmp___6 = (char *)0;
    }
#line 141
    __o1___1->next_free = tmp___5 + (((__o1___1->next_free - tmp___6) + (long )__o1___1->alignment_mask) & (long )(~ __o1___1->alignment_mask));
#line 141
    if (__o1___1->next_free - (char *)__o1___1->chunk > __o1___1->chunk_limit - (char *)__o1___1->chunk) {
#line 141
      __o1___1->next_free = __o1___1->chunk_limit;
    }
#line 141
    __o1___1->object_base = __o1___1->next_free;
#line 141
    yylval.str = (char *)__value___1;
#line 142
    return (257);
#line 144
    goto switch_break;
    case_66: /* CIL Label */ 
#line 153
    if (yyleng > 0) {
#line 153
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 152
    yy_start = 5;
#line 153
    goto switch_break;
    case_67: /* CIL Label */ 
#line 155
    if (yyleng > 0) {
#line 155
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 154
    goto switch_break;
    case_68: /* CIL Label */ 
#line 157
    if (yyleng > 0) {
#line 157
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
    {
#line 154
    line_num ++;
#line 154
    tmp___7 = gettext("unterminated string?");
#line 154
    error_at_line(0, 0, (char const   *)filename, (unsigned int )line_num, "%s", tmp___7);
    }
#line 155
    goto switch_break;
    case_69: /* CIL Label */ 
#line 157
    if (yyleng > 0) {
#line 157
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 156
    goto switch_break;
    case_70: /* CIL Label */ 
#line 159
    if (yyleng > 0) {
#line 159
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 156
    line_num ++;
#line 157
    goto switch_break;
    case_71: /* CIL Label */ 
#line 159
    if (yyleng > 0) {
#line 159
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 157
    yy_start = 7;
#line 158
    goto switch_break;
    case_72: /* CIL Label */ 
#line 160
    if (yyleng > 0) {
#line 160
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 159
    goto switch_break;
    case_73: /* CIL Label */ 
#line 162
    if (yyleng > 0) {
#line 162
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 159
    line_num ++;
#line 160
    goto switch_break;
    case_74: /* CIL Label */ 
#line 162
    if (yyleng > 0) {
#line 162
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 160
    yy_start = 5;
#line 161
    goto switch_break;
    case_75: /* CIL Label */ 
#line 163
    if (yyleng > 0) {
#line 163
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 162
    yy_start = 1;
    {
#line 163
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 163
      yyless_macro_arg___0 = 0;
#line 163
      *yy_cp = yy_hold_char;
#line 163
      yy_cp = (yy_bp + yyless_macro_arg___0) - 0;
#line 163
      yy_c_buf_p = yy_cp;
#line 163
      yytext = yy_bp;
#line 163
      yyleng = (int )((size_t )(yy_cp - yy_bp));
#line 163
      yy_hold_char = *yy_cp;
#line 163
      *yy_cp = (char )'\000';
#line 163
      yy_c_buf_p = yy_cp;
#line 163
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 164
    return (271);
#line 166
    goto switch_break;
    case_76: /* CIL Label */ 
#line 169
    if (yyleng > 0) {
#line 169
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 166
    line_num ++;
#line 167
    goto switch_break;
    case_77: /* CIL Label */ 
#line 169
    if (yyleng > 0) {
#line 169
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 168
    goto switch_break;
    case_78: /* CIL Label */ 
#line 171
    if (yyleng > 0) {
#line 171
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 169
    return (258);
#line 170
    goto switch_break;
    case_79: /* CIL Label */ 
#line 172
    if (yyleng > 0) {
#line 172
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 170
    return (259);
#line 171
    goto switch_break;
    case_80: /* CIL Label */ 
#line 173
    if (yyleng > 0) {
#line 173
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 171
    return ((int )*(yytext + 0));
#line 172
    goto switch_break;
    case_81: /* CIL Label */ 
#line 174
    if (yyleng > 0) {
#line 174
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
    {
#line 172
    fwrite((void const   */* __restrict  */)yytext, (size_t )yyleng, (size_t )1, (FILE */* __restrict  */)yyout);
    }
#line 173
    goto switch_break;
    case_87: /* CIL Label */ 
    case_86: /* CIL Label */ 
    case_85: /* CIL Label */ 
    case_84: /* CIL Label */ 
    case_83: /* CIL Label */ 
#line 1577 "c.c"
    return (0);
    case_82: /* CIL Label */ 
#line 1582
    yy_amount_of_matched_text = (int )(yy_cp - yytext) - 1;
#line 1585
    *yy_cp = yy_hold_char;
#line 1588
    if ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_buffer_status == 0) {
#line 1599
      yy_n_chars = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars;
#line 1600
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_input_file = yyin;
#line 1601
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buffer_status = 1;
    }
#line 1611
    if ((unsigned long )yy_c_buf_p <= (unsigned long )((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + yy_n_chars)) {
      {
#line 1615
      yy_c_buf_p = yytext + yy_amount_of_matched_text;
#line 1617
      yy_current_state = yy_get_previous_state();
#line 1628
      yy_next_state = yy_try_NUL_trans(yy_current_state);
#line 1630
      yy_bp = yytext + 0;
      }
#line 1632
      if (yy_next_state) {
#line 1635
        yy_c_buf_p ++;
#line 1635
        yy_cp = yy_c_buf_p;
#line 1636
        yy_current_state = yy_next_state;
#line 1637
        goto yy_match;
      } else {
#line 1643
        yy_cp = yy_c_buf_p;
#line 1644
        goto yy_find_action;
      }
    } else {
      {
#line 1648
      tmp___8 = yy_get_next_buffer();
      }
      {
#line 1650
      if (tmp___8 == 1) {
#line 1650
        goto case_1___0;
      }
#line 1679
      if (tmp___8 == 0) {
#line 1679
        goto case_0___0;
      }
#line 1689
      if (tmp___8 == 2) {
#line 1689
        goto case_2___0;
      }
#line 1648
      goto switch_break___0;
      case_1___0: /* CIL Label */ 
      {
#line 1652
      yy_did_buffer_switch_on_eof = 0;
#line 1654
      tmp___9 = yywrap();
      }
#line 1654
      if (tmp___9) {
#line 1665
        yy_c_buf_p = yytext + 0;
#line 1667
        yy_act = (82 + (yy_start - 1) / 2) + 1;
#line 1668
        goto do_action;
      } else
#line 1673
      if (! yy_did_buffer_switch_on_eof) {
        {
#line 1674
        yyrestart(yyin);
        }
      }
#line 1676
      goto switch_break___0;
      case_0___0: /* CIL Label */ 
      {
#line 1680
      yy_c_buf_p = yytext + yy_amount_of_matched_text;
#line 1683
      yy_current_state = yy_get_previous_state();
#line 1685
      yy_cp = yy_c_buf_p;
#line 1686
      yy_bp = yytext + 0;
      }
#line 1687
      goto yy_match;
      case_2___0: /* CIL Label */ 
      {
#line 1690
      yy_c_buf_p = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + yy_n_chars;
#line 1693
      yy_current_state = yy_get_previous_state();
#line 1695
      yy_cp = yy_c_buf_p;
#line 1696
      yy_bp = yytext + 0;
      }
#line 1697
      goto yy_find_action;
      switch_break___0: /* CIL Label */ ;
      }
    }
#line 1699
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1703
    yy_fatal_error("fatal flex scanner internal error--no action found");
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1725 "c.c"
static int yy_get_next_buffer(void) 
{ 
  register char *dest ;
  register char *source___0 ;
  register int number_to_move ;
  register int i ;
  int ret_val ;
  char *tmp ;
  char *tmp___0 ;
  int num_to_read ;
  YY_BUFFER_STATE b ;
  YY_BUFFER_STATE tmp___1 ;
  int yy_c_buf_p_offset ;
  int new_size ;
  void *tmp___2 ;
  int c ;
  int n ;
  int tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;
  yy_size_t new_size___0 ;
  void *tmp___10 ;

  {
#line 1730
  dest = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf;
#line 1731
  source___0 = yytext;
#line 1735
  if ((unsigned long )yy_c_buf_p > (unsigned long )((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + (yy_n_chars + 1))) {
    {
#line 1736
    yy_fatal_error("fatal flex scanner internal error--end of buffer missed");
    }
  }
#line 1739
  if ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_fill_buffer == 0) {
#line 1741
    if (yy_c_buf_p - yytext == 1L) {
#line 1746
      return (1);
    } else {
#line 1754
      return (2);
    }
  }
#line 1761
  number_to_move = (int )(yy_c_buf_p - yytext) - 1;
#line 1763
  i = 0;
  {
#line 1763
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1763
    if (! (i < number_to_move)) {
#line 1763
      goto while_break;
    }
#line 1764
    tmp = dest;
#line 1764
    dest ++;
#line 1764
    tmp___0 = source___0;
#line 1764
    source___0 ++;
#line 1764
    *tmp = *tmp___0;
#line 1763
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1766
  if ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_buffer_status == 2) {
#line 1770
    yy_n_chars = 0;
#line 1770
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars = yy_n_chars;
  } else {
#line 1774
    num_to_read = (int )(((*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_size - (yy_size_t )number_to_move) - 1UL);
    {
#line 1777
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1777
      if (! (num_to_read <= 0)) {
#line 1777
        goto while_break___0;
      }
#line 1781
      if (yy_buffer_stack) {
#line 1781
        tmp___1 = *(yy_buffer_stack + yy_buffer_stack_top);
      } else {
#line 1781
        tmp___1 = (YY_BUFFER_STATE )((void *)0);
      }
#line 1781
      b = tmp___1;
#line 1783
      yy_c_buf_p_offset = (int )(yy_c_buf_p - b->yy_ch_buf);
#line 1786
      if (b->yy_is_our_buffer) {
#line 1788
        new_size = (int )(b->yy_buf_size * 2UL);
#line 1790
        if (new_size <= 0) {
#line 1791
          b->yy_buf_size += b->yy_buf_size / 8UL;
        } else {
#line 1793
          b->yy_buf_size *= 2UL;
        }
        {
#line 1795
        tmp___2 = yyrealloc((void *)b->yy_ch_buf, b->yy_buf_size + 2UL);
#line 1795
        b->yy_ch_buf = (char *)tmp___2;
        }
      } else {
#line 1801
        b->yy_ch_buf = (char *)0;
      }
#line 1803
      if (! b->yy_ch_buf) {
        {
#line 1804
        yy_fatal_error("fatal error - scanner input buffer overflow");
        }
      }
#line 1807
      yy_c_buf_p = b->yy_ch_buf + yy_c_buf_p_offset;
#line 1809
      num_to_read = (int )(((*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_size - (yy_size_t )number_to_move) - 1UL);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1814
    if (num_to_read > 8192) {
#line 1815
      num_to_read = 8192;
    }
#line 1818
    if ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_is_interactive) {
#line 1818
      c = '*';
#line 1818
      n = 0;
      {
#line 1818
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1818
        if ((size_t )n < (size_t )num_to_read) {
          {
#line 1818
          c = _IO_getc(yyin);
          }
#line 1818
          if (c != -1) {
#line 1818
            if (! (c != 10)) {
#line 1818
              goto while_break___1;
            }
          } else {
#line 1818
            goto while_break___1;
          }
        } else {
#line 1818
          goto while_break___1;
        }
#line 1818
        *(((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + number_to_move) + n) = (char )c;
#line 1818
        n ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1818
      if (c == 10) {
#line 1818
        tmp___3 = n;
#line 1818
        n ++;
#line 1818
        *(((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + number_to_move) + tmp___3) = (char )c;
      }
#line 1818
      if (c == -1) {
        {
#line 1818
        tmp___4 = ferror(yyin);
        }
#line 1818
        if (tmp___4) {
          {
#line 1818
          yy_fatal_error("input in flex scanner failed");
          }
        }
      }
#line 1818
      yy_n_chars = n;
    } else {
      {
#line 1818
      tmp___5 = __errno_location();
#line 1818
      *tmp___5 = 0;
      }
      {
#line 1818
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 1818
        tmp___8 = fread((void */* __restrict  */)((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + number_to_move),
                        (size_t )1, (size_t )num_to_read, (FILE */* __restrict  */)yyin);
#line 1818
        yy_n_chars = (int )tmp___8;
        }
#line 1818
        if (yy_n_chars == 0) {
          {
#line 1818
          tmp___9 = ferror(yyin);
          }
#line 1818
          if (! tmp___9) {
#line 1818
            goto while_break___2;
          }
        } else {
#line 1818
          goto while_break___2;
        }
        {
#line 1818
        tmp___6 = __errno_location();
        }
#line 1818
        if (*tmp___6 != 4) {
          {
#line 1818
          yy_fatal_error("input in flex scanner failed");
          }
#line 1818
          goto while_break___2;
        }
        {
#line 1818
        tmp___7 = __errno_location();
#line 1818
        *tmp___7 = 0;
#line 1818
        clearerr(yyin);
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 1821
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars = yy_n_chars;
  }
#line 1824
  if (yy_n_chars == 0) {
#line 1826
    if (number_to_move == 0) {
      {
#line 1828
      ret_val = 1;
#line 1829
      yyrestart(yyin);
      }
    } else {
#line 1834
      ret_val = 2;
#line 1835
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buffer_status = 2;
    }
  } else {
#line 1841
    ret_val = 0;
  }
#line 1843
  if ((yy_size_t )(yy_n_chars + number_to_move) > (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_size) {
    {
#line 1845
    new_size___0 = (yy_size_t )((yy_n_chars + number_to_move) + (yy_n_chars >> 1));
#line 1846
    tmp___10 = yyrealloc((void *)(*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf,
                         new_size___0);
#line 1846
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf = (char *)tmp___10;
    }
#line 1847
    if (! (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf) {
      {
#line 1848
      yy_fatal_error("out of dynamic memory in yy_get_next_buffer()");
      }
    }
  }
#line 1851
  yy_n_chars += number_to_move;
#line 1852
  *((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + yy_n_chars) = (char)0;
#line 1853
  *((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + (yy_n_chars + 1)) = (char)0;
#line 1855
  yytext = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + 0;
#line 1857
  return (ret_val);
}
}
#line 1865 "c.c"
static yy_state_type yy_get_previous_state(void) 
{ 
  register yy_state_type yy_current_state ;
  register char *yy_cp ;
  register YY_CHAR yy_c ;
  flex_int32_t tmp ;

  {
#line 1874
  yy_current_state = yy_start;
#line 1875
  yy_current_state += (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol;
#line 1877
  yy_cp = yytext + 0;
  {
#line 1877
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1877
    if (! ((unsigned long )yy_cp < (unsigned long )yy_c_buf_p)) {
#line 1877
      goto while_break;
    }
#line 1880
    if (*yy_cp) {
#line 1880
      tmp = yy_ec[(unsigned int )((unsigned char )*yy_cp)];
    } else {
#line 1880
      tmp = (flex_int32_t const   )1;
    }
#line 1880
    yy_c = (YY_CHAR )tmp;
#line 1881
    if (yy_accept[yy_current_state]) {
#line 1883
      yy_last_accepting_state = yy_current_state;
#line 1884
      yy_last_accepting_cpos = yy_cp;
    }
    {
#line 1886
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1886
      if (! ((int const   )yy_chk[(int const   )yy_base[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 1886
        goto while_break___0;
      }
#line 1888
      yy_current_state = (int )yy_def[yy_current_state];
#line 1889
      if (yy_current_state >= 191) {
#line 1890
        yy_c = (YY_CHAR )yy_meta[(unsigned int )yy_c];
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1892
    yy_current_state = (yy_state_type )yy_nxt[(unsigned int )yy_base[yy_current_state] + (unsigned int )yy_c];
#line 1877
    yy_cp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1895
  return (yy_current_state);
}
}
#line 1904 "c.c"
static yy_state_type yy_try_NUL_trans(yy_state_type yy_current_state ) 
{ 
  register int yy_is_jam ;
  register char *yy_cp ;
  register YY_CHAR yy_c ;
  int tmp ;

  {
#line 1911
  yy_cp = yy_c_buf_p;
#line 1913
  yy_c = (YY_CHAR )1;
#line 1914
  if (yy_accept[yy_current_state]) {
#line 1916
    yy_last_accepting_state = yy_current_state;
#line 1917
    yy_last_accepting_cpos = yy_cp;
  }
  {
#line 1919
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1919
    if (! ((int const   )yy_chk[(int const   )yy_base[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 1919
      goto while_break;
    }
#line 1921
    yy_current_state = (int )yy_def[yy_current_state];
#line 1922
    if (yy_current_state >= 191) {
#line 1923
      yy_c = (YY_CHAR )yy_meta[(unsigned int )yy_c];
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1925
  yy_current_state = (yy_state_type )yy_nxt[(unsigned int )yy_base[yy_current_state] + (unsigned int )yy_c];
#line 1926
  yy_is_jam = yy_current_state == 190;
#line 1928
  if (yy_is_jam) {
#line 1928
    tmp = 0;
  } else {
#line 1928
    tmp = yy_current_state;
  }
#line 1928
  return (tmp);
}
}
#line 1933 "c.c"
static void yyunput(int c , char *yy_bp ) 
{ 
  register char *yy_cp ;
  register int number_to_move ;
  register char *dest ;
  register char *source___0 ;

  {
#line 1940
  yy_cp = yy_c_buf_p;
#line 1943
  *yy_cp = yy_hold_char;
#line 1945
  if ((unsigned long )yy_cp < (unsigned long )((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + 2)) {
#line 1948
    number_to_move = yy_n_chars + 2;
#line 1949
    dest = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_size + 2UL);
#line 1951
    source___0 = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + number_to_move;
    {
#line 1954
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1954
      if (! ((unsigned long )source___0 > (unsigned long )(*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf)) {
#line 1954
        goto while_break;
      }
#line 1955
      dest --;
#line 1955
      source___0 --;
#line 1955
      *dest = *source___0;
    }
    while_break: /* CIL Label */ ;
    }
#line 1957
    yy_cp += (int )(dest - source___0);
#line 1958
    yy_bp += (int )(dest - source___0);
#line 1959
    yy_n_chars = (int )(*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_size;
#line 1959
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars = yy_n_chars;
#line 1962
    if ((unsigned long )yy_cp < (unsigned long )((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + 2)) {
      {
#line 1963
      yy_fatal_error("flex scanner push-back overflow");
      }
    }
  }
#line 1966
  yy_cp --;
#line 1966
  *yy_cp = (char )c;
#line 1970
  yytext = yy_bp;
#line 1971
  yy_hold_char = *yy_cp;
#line 1972
  yy_c_buf_p = yy_cp;
#line 1973
  return;
}
}
#line 1983 "c.c"
static int input(void) 
{ 
  int c ;
  int offset ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1992
  *yy_c_buf_p = yy_hold_char;
#line 1994
  if ((int )*yy_c_buf_p == 0) {
#line 2000
    if ((unsigned long )yy_c_buf_p < (unsigned long )((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + yy_n_chars)) {
#line 2002
      *yy_c_buf_p = (char )'\000';
    } else {
      {
#line 2006
      offset = (int )(yy_c_buf_p - yytext);
#line 2007
      yy_c_buf_p ++;
#line 2009
      tmp = yy_get_next_buffer();
      }
      {
#line 2011
      if (tmp == 2) {
#line 2011
        goto case_2;
      }
#line 2027
      if (tmp == 1) {
#line 2027
        goto case_1;
      }
#line 2041
      if (tmp == 0) {
#line 2041
        goto case_0;
      }
#line 2009
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 2023
      yyrestart(yyin);
      }
      case_1: /* CIL Label */ 
      {
#line 2029
      tmp___0 = yywrap();
      }
#line 2029
      if (tmp___0) {
#line 2030
        return (-1);
      }
#line 2032
      if (! yy_did_buffer_switch_on_eof) {
        {
#line 2033
        yyrestart(yyin);
        }
      }
      {
#line 2037
      tmp___1 = input();
      }
#line 2037
      return (tmp___1);
      case_0: /* CIL Label */ 
#line 2042
      yy_c_buf_p = yytext + offset;
#line 2043
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 2048
  c = (int )*((unsigned char *)yy_c_buf_p);
#line 2049
  *yy_c_buf_p = (char )'\000';
#line 2050
  yy_c_buf_p ++;
#line 2050
  yy_hold_char = *yy_c_buf_p;
#line 2053
  (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = c == 10;
#line 2055
  return (c);
}
}
#line 2067 "c.c"
void yyrestart(FILE *input_file ) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
#line 2073
  if (yy_buffer_stack) {
#line 2073
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 2073
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 2073
  if (! tmp) {
    {
#line 2074
    yyensure_buffer_stack();
#line 2075
    *(yy_buffer_stack + yy_buffer_stack_top) = yy_create_buffer(yyin, 16384);
    }
  }
#line 2079
  if (yy_buffer_stack) {
#line 2079
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 2079
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 2079
  yy_init_buffer(tmp___0, input_file);
#line 2080
  yy_load_buffer_state();
  }
#line 2081
  return;
}
}
#line 2088 "c.c"
void yy_switch_to_buffer(YY_BUFFER_STATE new_buffer ) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 2099
  yyensure_buffer_stack();
  }
#line 2100
  if (yy_buffer_stack) {
#line 2100
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 2100
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 2100
  if ((unsigned long )tmp == (unsigned long )new_buffer) {
#line 2101
    return;
  }
#line 2103
  if (yy_buffer_stack) {
#line 2103
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 2103
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 2103
  if (tmp___0) {
#line 2106
    *yy_c_buf_p = yy_hold_char;
#line 2107
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_pos = yy_c_buf_p;
#line 2108
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars = yy_n_chars;
  }
  {
#line 2111
  *(yy_buffer_stack + yy_buffer_stack_top) = new_buffer;
#line 2112
  yy_load_buffer_state();
#line 2119
  yy_did_buffer_switch_on_eof = 1;
  }
#line 2120
  return;
}
}
#line 2123 "c.c"
static void yy_load_buffer_state(void) 
{ 


  {
#line 2128
  yy_n_chars = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars;
#line 2129
  yy_c_buf_p = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_pos;
#line 2129
  yytext = yy_c_buf_p;
#line 2130
  yyin = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_input_file;
#line 2131
  yy_hold_char = *yy_c_buf_p;
#line 2132
  return;
}
}
#line 2141 "c.c"
YY_BUFFER_STATE yy_create_buffer(FILE *file , int size ) 
{ 
  YY_BUFFER_STATE b ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 2148
  tmp = yyalloc(sizeof(struct yy_buffer_state ));
#line 2148
  b = (YY_BUFFER_STATE )tmp;
  }
#line 2149
  if (! b) {
    {
#line 2150
    yy_fatal_error("out of dynamic memory in yy_create_buffer()");
    }
  }
  {
#line 2152
  b->yy_buf_size = (yy_size_t )size;
#line 2157
  tmp___0 = yyalloc(b->yy_buf_size + 2UL);
#line 2157
  b->yy_ch_buf = (char *)tmp___0;
  }
#line 2158
  if (! b->yy_ch_buf) {
    {
#line 2159
    yy_fatal_error("out of dynamic memory in yy_create_buffer()");
    }
  }
  {
#line 2161
  b->yy_is_our_buffer = 1;
#line 2163
  yy_init_buffer(b, file);
  }
#line 2165
  return (b);
}
}
#line 2173 "c.c"
void yy_delete_buffer(YY_BUFFER_STATE b ) 
{ 
  YY_BUFFER_STATE tmp ;

  {
#line 2179
  if (! b) {
#line 2180
    return;
  }
#line 2182
  if (yy_buffer_stack) {
#line 2182
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 2182
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 2182
  if ((unsigned long )b == (unsigned long )tmp) {
#line 2183
    *(yy_buffer_stack + yy_buffer_stack_top) = (YY_BUFFER_STATE )0;
  }
#line 2185
  if (b->yy_is_our_buffer) {
    {
#line 2186
    yyfree((void *)b->yy_ch_buf);
    }
  }
  {
#line 2188
  yyfree((void *)b);
  }
#line 2189
  return;
}
}
#line 2207 "c.c"
static void yy_init_buffer(YY_BUFFER_STATE b , FILE *file ) 
{ 
  int oerrno ;
  int *tmp ;
  YY_BUFFER_STATE tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 2213
  tmp = __errno_location();
#line 2213
  oerrno = *tmp;
#line 2215
  yy_flush_buffer(b);
#line 2217
  b->yy_input_file = file;
#line 2218
  b->yy_fill_buffer = 1;
  }
#line 2224
  if (yy_buffer_stack) {
#line 2224
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 2224
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 2224
  if ((unsigned long )b != (unsigned long )tmp___0) {
#line 2225
    b->yy_bs_lineno = 1;
#line 2226
    b->yy_bs_column = 0;
  }
#line 2231
  if (file) {
    {
#line 2231
    tmp___1 = fileno(file);
#line 2231
    tmp___2 = isatty(tmp___1);
#line 2231
    b->yy_is_interactive = tmp___2 > 0;
    }
  } else {
#line 2231
    b->yy_is_interactive = 0;
  }
  {
#line 2236
  tmp___3 = __errno_location();
#line 2236
  *tmp___3 = oerrno;
  }
#line 2237
  return;
}
}
#line 2244 "c.c"
void yy_flush_buffer(YY_BUFFER_STATE b ) 
{ 
  YY_BUFFER_STATE tmp ;

  {
#line 2249
  if (! b) {
#line 2250
    return;
  }
#line 2252
  b->yy_n_chars = 0;
#line 2258
  *(b->yy_ch_buf + 0) = (char)0;
#line 2259
  *(b->yy_ch_buf + 1) = (char)0;
#line 2261
  b->yy_buf_pos = b->yy_ch_buf + 0;
#line 2263
  b->yy_at_bol = 1;
#line 2264
  b->yy_buffer_status = 0;
#line 2266
  if (yy_buffer_stack) {
#line 2266
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 2266
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 2266
  if ((unsigned long )b == (unsigned long )tmp) {
    {
#line 2267
    yy_load_buffer_state();
    }
  }
#line 2268
  return;
}
}
#line 2278 "c.c"
void yypush_buffer_state(YY_BUFFER_STATE new_buffer ) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
#line 2283
  if ((unsigned long )new_buffer == (unsigned long )((void *)0)) {
#line 2284
    return;
  }
  {
#line 2286
  yyensure_buffer_stack();
  }
#line 2289
  if (yy_buffer_stack) {
#line 2289
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 2289
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 2289
  if (tmp) {
#line 2292
    *yy_c_buf_p = yy_hold_char;
#line 2293
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_pos = yy_c_buf_p;
#line 2294
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars = yy_n_chars;
  }
#line 2298
  if (yy_buffer_stack) {
#line 2298
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 2298
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 2298
  if (tmp___0) {
#line 2299
    yy_buffer_stack_top ++;
  }
  {
#line 2300
  *(yy_buffer_stack + yy_buffer_stack_top) = new_buffer;
#line 2303
  yy_load_buffer_state();
#line 2304
  yy_did_buffer_switch_on_eof = 1;
  }
#line 2305
  return;
}
}
#line 2314 "c.c"
void yypop_buffer_state(void) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;
  YY_BUFFER_STATE tmp___1 ;

  {
#line 2319
  if (yy_buffer_stack) {
#line 2319
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 2319
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 2319
  if (! tmp) {
#line 2320
    return;
  }
#line 2322
  if (yy_buffer_stack) {
#line 2322
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 2322
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 2322
  yy_delete_buffer(tmp___0);
#line 2323
  *(yy_buffer_stack + yy_buffer_stack_top) = (YY_BUFFER_STATE )((void *)0);
  }
#line 2324
  if (yy_buffer_stack_top > 0UL) {
#line 2325
    yy_buffer_stack_top --;
  }
#line 2327
  if (yy_buffer_stack) {
#line 2327
    tmp___1 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 2327
    tmp___1 = (YY_BUFFER_STATE )((void *)0);
  }
#line 2327
  if (tmp___1) {
    {
#line 2328
    yy_load_buffer_state();
#line 2329
    yy_did_buffer_switch_on_eof = 1;
    }
  }
#line 2331
  return;
}
}
#line 2339 "c.c"
static void yyensure_buffer_stack(void) 
{ 
  int num_to_alloc ;
  void *tmp ;
  int grow_size ;
  void *tmp___0 ;

  {
#line 2346
  if (! yy_buffer_stack) {
    {
#line 2352
    num_to_alloc = 1;
#line 2353
    tmp = yyalloc((unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *));
#line 2353
    yy_buffer_stack = (struct yy_buffer_state **)tmp;
    }
#line 2356
    if (! yy_buffer_stack) {
      {
#line 2357
      yy_fatal_error("out of dynamic memory in yyensure_buffer_stack()");
      }
    }
    {
#line 2359
    memset((void *)yy_buffer_stack, 0, (unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *));
#line 2361
    yy_buffer_stack_max = (size_t )num_to_alloc;
#line 2362
    yy_buffer_stack_top = (size_t )0;
    }
#line 2363
    return;
  }
#line 2366
  if (yy_buffer_stack_top >= yy_buffer_stack_max - 1UL) {
    {
#line 2369
    grow_size = 8;
#line 2371
    num_to_alloc = (int )(yy_buffer_stack_max + (size_t )grow_size);
#line 2372
    tmp___0 = yyrealloc((void *)yy_buffer_stack, (unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *));
#line 2372
    yy_buffer_stack = (struct yy_buffer_state **)tmp___0;
    }
#line 2376
    if (! yy_buffer_stack) {
      {
#line 2377
      yy_fatal_error("out of dynamic memory in yyensure_buffer_stack()");
      }
    }
    {
#line 2380
    memset((void *)(yy_buffer_stack + yy_buffer_stack_max), 0, (unsigned long )grow_size * sizeof(struct yy_buffer_state *));
#line 2381
    yy_buffer_stack_max = (size_t )num_to_alloc;
    }
  }
#line 2383
  return;
}
}
#line 2393 "c.c"
YY_BUFFER_STATE yy_scan_buffer(char *base , yy_size_t size ) 
{ 
  YY_BUFFER_STATE b ;
  void *tmp ;
  char *tmp___0 ;

  {
#line 2397
  if (size < 2UL) {
#line 2401
    return ((YY_BUFFER_STATE )0);
  } else
#line 2397
  if ((int )*(base + (size - 2UL)) != 0) {
#line 2401
    return ((YY_BUFFER_STATE )0);
  } else
#line 2397
  if ((int )*(base + (size - 1UL)) != 0) {
#line 2401
    return ((YY_BUFFER_STATE )0);
  }
  {
#line 2403
  tmp = yyalloc(sizeof(struct yy_buffer_state ));
#line 2403
  b = (YY_BUFFER_STATE )tmp;
  }
#line 2404
  if (! b) {
    {
#line 2405
    yy_fatal_error("out of dynamic memory in yy_scan_buffer()");
    }
  }
  {
#line 2407
  b->yy_buf_size = size - 2UL;
#line 2408
  tmp___0 = base;
#line 2408
  b->yy_ch_buf = tmp___0;
#line 2408
  b->yy_buf_pos = tmp___0;
#line 2409
  b->yy_is_our_buffer = 0;
#line 2410
  b->yy_input_file = (FILE *)0;
#line 2411
  b->yy_n_chars = (int )b->yy_buf_size;
#line 2412
  b->yy_is_interactive = 0;
#line 2413
  b->yy_at_bol = 1;
#line 2414
  b->yy_fill_buffer = 0;
#line 2415
  b->yy_buffer_status = 0;
#line 2417
  yy_switch_to_buffer(b);
  }
#line 2419
  return (b);
}
}
#line 2432 "c.c"
YY_BUFFER_STATE yy_scan_string(char const   *yystr ) 
{ 
  size_t tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 2435
  tmp = strlen(yystr);
#line 2435
  tmp___0 = yy_scan_bytes(yystr, (int )tmp);
  }
#line 2435
  return (tmp___0);
}
}
#line 2447 "c.c"
YY_BUFFER_STATE yy_scan_bytes(char const   *yybytes , int _yybytes_len ) 
{ 
  YY_BUFFER_STATE b ;
  char *buf ;
  yy_size_t n ;
  int i ;
  void *tmp ;
  char tmp___0 ;

  {
  {
#line 2455
  n = (yy_size_t )(_yybytes_len + 2);
#line 2456
  tmp = yyalloc(n);
#line 2456
  buf = (char *)tmp;
  }
#line 2457
  if (! buf) {
    {
#line 2458
    yy_fatal_error("out of dynamic memory in yy_scan_bytes()");
    }
  }
#line 2460
  i = 0;
  {
#line 2460
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2460
    if (! (i < _yybytes_len)) {
#line 2460
      goto while_break;
    }
#line 2461
    *(buf + i) = (char )*(yybytes + i);
#line 2460
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2463
  tmp___0 = (char)0;
#line 2463
  *(buf + (_yybytes_len + 1)) = tmp___0;
#line 2463
  *(buf + _yybytes_len) = tmp___0;
#line 2465
  b = yy_scan_buffer(buf, n);
  }
#line 2466
  if (! b) {
    {
#line 2467
    yy_fatal_error("bad buffer in yy_scan_bytes()");
    }
  }
#line 2472
  b->yy_is_our_buffer = 1;
#line 2474
  return (b);
}
}
#line 2483 "c.c"
static void yy_fatal_error(char const   *msg ) 
{ 


  {
  {
#line 2485
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          msg);
#line 2486
  exit(2);
  }
}
}
#line 2518 "c.c"
int yyget_lineno(void) 
{ 


  {
#line 2521
  return (yylineno);
}
}
#line 2527 "c.c"
FILE *yyget_in(void) 
{ 


  {
#line 2529
  return (yyin);
}
}
#line 2535 "c.c"
FILE *yyget_out(void) 
{ 


  {
#line 2537
  return (yyout);
}
}
#line 2543 "c.c"
int yyget_leng(void) 
{ 


  {
#line 2545
  return (yyleng);
}
}
#line 2552 "c.c"
char *yyget_text(void) 
{ 


  {
#line 2554
  return (yytext);
}
}
#line 2564 "c.c"
void yyset_lineno(int line_number ) 
{ 


  {
#line 2567
  yylineno = line_number;
#line 2568
  return;
}
}
#line 2576 "c.c"
void yyset_in(FILE *in_str ) 
{ 


  {
#line 2578
  yyin = in_str;
#line 2579
  return;
}
}
#line 2581 "c.c"
void yyset_out(FILE *out_str ) 
{ 


  {
#line 2583
  yyout = out_str;
#line 2584
  return;
}
}
#line 2586 "c.c"
int yyget_debug(void) 
{ 


  {
#line 2588
  return (yy_flex_debug);
}
}
#line 2591 "c.c"
void yyset_debug(int bdebug ) 
{ 


  {
#line 2593
  yy_flex_debug = bdebug;
#line 2594
  return;
}
}
#line 2604 "c.c"
static int yy_init_globals(void) 
{ 


  {
#line 2610
  yy_buffer_stack = (YY_BUFFER_STATE *)0;
#line 2611
  yy_buffer_stack_top = (size_t )0;
#line 2612
  yy_buffer_stack_max = (size_t )0;
#line 2613
  yy_c_buf_p = (char *)0;
#line 2614
  yy_init = 0;
#line 2615
  yy_start = 0;
#line 2622
  yyin = (FILE *)0;
#line 2623
  yyout = (FILE *)0;
#line 2629
  return (0);
}
}
#line 2635 "c.c"
int yylex_destroy(void) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 2639
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2639
    if (yy_buffer_stack) {
#line 2639
      tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
    } else {
#line 2639
      tmp___0 = (YY_BUFFER_STATE )((void *)0);
    }
#line 2639
    if (! tmp___0) {
#line 2639
      goto while_break;
    }
#line 2640
    if (yy_buffer_stack) {
#line 2640
      tmp = *(yy_buffer_stack + yy_buffer_stack_top);
    } else {
#line 2640
      tmp = (YY_BUFFER_STATE )((void *)0);
    }
    {
#line 2640
    yy_delete_buffer(tmp);
#line 2641
    *(yy_buffer_stack + yy_buffer_stack_top) = (YY_BUFFER_STATE )((void *)0);
#line 2642
    yypop_buffer_state();
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2646
  yyfree((void *)yy_buffer_stack);
#line 2647
  yy_buffer_stack = (YY_BUFFER_STATE *)((void *)0);
#line 2651
  yy_init_globals();
  }
#line 2655
  return (0);
}
}
#line 2683 "c.c"
void *yyalloc(yy_size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 2685
  tmp = malloc(size);
  }
#line 2685
  return (tmp);
}
}
#line 2688 "c.c"
void *yyrealloc(void *ptr , yy_size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 2697
  tmp = realloc((void *)((char *)ptr), size);
  }
#line 2697
  return (tmp);
}
}
#line 2700 "c.c"
void yyfree(void *ptr ) 
{ 


  {
  {
#line 2702
  free((void *)((char *)ptr));
  }
#line 2703
  return;
}
}
#line 175 "c.l"
static char *keywords[13]  = 
#line 175 "c.l"
  {      (char *)"break",      (char *)"case",      (char *)"continue",      (char *)"default", 
        (char *)"do",      (char *)"else",      (char *)"for",      (char *)"goto", 
        (char *)"if",      (char *)"return",      (char *)"sizeof",      (char *)"switch", 
        (char *)"while"};
#line 191 "c.l"
static char *types[5]  = {      (char *)"char",      (char *)"double",      (char *)"float",      (char *)"int", 
        (char *)"void"};
#line 199 "c.l"
static char *qualifiers[9]  = 
#line 199
  {      (char *)"long",      (char *)"const",      (char *)"register",      (char *)"restrict", 
        (char *)"short",      (char *)"signed",      (char *)"unsigned",      (char *)"volatile", 
        (char *)"inline"};
#line 211 "c.l"
void init_tokens(void) 
{ 
  int i ;
  Symbol *sp ;

  {
#line 217
  i = 0;
  {
#line 217
  while (1) {
    while_continue: /* CIL Label */ ;
#line 217
    if (! ((unsigned long )i < sizeof(keywords) / sizeof(keywords[0]))) {
#line 217
      goto while_break;
    }
    {
#line 218
    sp = install(keywords[i], 1);
#line 219
    sp->type = (enum symtype )1;
#line 220
    sp->token_type = 257;
#line 217
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 223
  i = 0;
  {
#line 223
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 223
    if (! ((unsigned long )i < sizeof(types) / sizeof(types[0]))) {
#line 223
      goto while_break___0;
    }
    {
#line 224
    sp = install(types[i], 1);
#line 225
    sp->type = (enum symtype )1;
#line 226
    sp->token_type = 270;
#line 227
    sp->source = (char *)((void *)0);
#line 228
    sp->def_line = -1;
#line 229
    sp->ref_line = (struct linked_list *)((void *)0);
#line 223
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 232
  i = 0;
  {
#line 232
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 232
    if (! ((unsigned long )i < sizeof(qualifiers) / sizeof(qualifiers[0]))) {
#line 232
      goto while_break___1;
    }
    {
#line 233
    sp = install(qualifiers[i], 1);
#line 234
    sp->type = (enum symtype )1;
#line 235
    sp->token_type = 273;
#line 236
    sp->source = (char *)((void *)0);
#line 237
    sp->def_line = -1;
#line 238
    sp->ref_line = (struct linked_list *)((void *)0);
#line 232
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 240
  sp = install((char *)"...", 1);
#line 241
  sp->type = (enum symtype )1;
#line 242
  sp->token_type = 260;
#line 243
  sp->source = (char *)((void *)0);
#line 244
  sp->def_line = -1;
#line 245
  sp->ref_line = (struct linked_list *)((void *)0);
  }
#line 246
  return;
}
}
#line 248 "c.l"
void init_lex(int debug_level ) 
{ 


  {
  {
#line 251
  yy_flex_debug = debug_level;
#line 252
  _obstack_begin(& string_stk, 0, 0, (void *(*)(long  ))(& xmalloc), (void (*)(void * ))(& free));
#line 253
  init_tokens();
  }
#line 254
  return;
}
}
#line 256 "c.l"
int ident(void) 
{ 
  Symbol *sp ;
  Symbol *tmp ;
  struct obstack *__o ;
  int __len ;
  struct obstack *__o___0 ;
  char *tmp___0 ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 267
  if (prev_token != 264) {
    {
#line 268
    tmp = lookup((char const   *)yytext);
#line 268
    sp = tmp;
    }
#line 269
    if (sp) {
#line 269
      if ((unsigned int )sp->type == 1U) {
#line 270
        yylval.str = sp->name;
#line 271
        return (sp->token_type);
      }
    }
  }
#line 274
  __o = & string_stk;
#line 274
  __len = yyleng;
#line 274
  if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
    {
#line 274
    _obstack_newchunk(__o, __len);
    }
  }
  {
#line 274
  memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)yytext,
         (size_t )__len);
#line 274
  __o->next_free += __len;
#line 275
  __o___0 = & string_stk;
  }
#line 275
  if ((unsigned long )(__o___0->next_free + 1) > (unsigned long )__o___0->chunk_limit) {
    {
#line 275
    _obstack_newchunk(__o___0, 1);
    }
  }
#line 275
  tmp___0 = __o___0->next_free;
#line 275
  (__o___0->next_free) ++;
#line 275
  *tmp___0 = (char)0;
#line 276
  __o1 = & string_stk;
#line 276
  __value = (void *)__o1->object_base;
#line 276
  if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 276
    __o1->maybe_empty_object = 1U;
  }
#line 276
  if (sizeof(long ) < sizeof(void *)) {
#line 276
    tmp___1 = __o1->object_base;
  } else {
#line 276
    tmp___1 = (char *)0;
  }
#line 276
  if (sizeof(long ) < sizeof(void *)) {
#line 276
    tmp___2 = __o1->object_base;
  } else {
#line 276
    tmp___2 = (char *)0;
  }
#line 276
  __o1->next_free = tmp___1 + (((__o1->next_free - tmp___2) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 276
  if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 276
    __o1->next_free = __o1->chunk_limit;
  }
#line 276
  __o1->object_base = __o1->next_free;
#line 276
  yylval.str = (char *)__value;
#line 277
  return (260);
}
}
#line 282 "c.l"
char *pp_bin  ;
#line 283 "c.l"
char *pp_opts  ;
#line 284 "c.l"
static struct obstack *opt_stack  ;
#line 286 "c.l"
void set_preprocessor(char const   *arg___0 ) 
{ 
  char *tmp ;

  {
#line 289
  if (arg___0) {
    {
#line 289
    tmp = xstrdup(arg___0);
#line 289
    pp_bin = tmp;
    }
  } else {
#line 289
    pp_bin = (char *)((void *)0);
  }
#line 290
  return;
}
}
#line 292 "c.l"
void pp_option(char const   *arg___0 ) 
{ 
  void *tmp ;
  struct obstack *__o ;
  char *tmp___0 ;
  struct obstack *__o___0 ;
  int __len ;
  size_t tmp___1 ;

  {
#line 295
  if (! opt_stack) {
#line 296
    if (! pp_bin) {
#line 297
      pp_bin = (char *)"/usr/bin/cpp";
    }
    {
#line 298
    tmp = xmalloc(sizeof(*opt_stack));
#line 298
    opt_stack = (struct obstack *)tmp;
#line 299
    _obstack_begin(opt_stack, 0, 0, (void *(*)(long  ))(& xmalloc), (void (*)(void * ))(& free));
    }
  }
#line 301
  __o = opt_stack;
#line 301
  if ((unsigned long )(__o->next_free + 1) > (unsigned long )__o->chunk_limit) {
    {
#line 301
    _obstack_newchunk(__o, 1);
    }
  }
  {
#line 301
  tmp___0 = __o->next_free;
#line 301
  (__o->next_free) ++;
#line 301
  *tmp___0 = (char )' ';
#line 302
  __o___0 = opt_stack;
#line 302
  tmp___1 = strlen(arg___0);
#line 302
  __len = (int )tmp___1;
  }
#line 302
  if ((unsigned long )(__o___0->next_free + __len) > (unsigned long )__o___0->chunk_limit) {
    {
#line 302
    _obstack_newchunk(__o___0, __len);
    }
  }
  {
#line 302
  memcpy((void */* __restrict  */)__o___0->next_free, (void const   */* __restrict  */)arg___0,
         (size_t )__len);
#line 302
  __o___0->next_free += __len;
  }
#line 303
  return;
}
}
#line 305 "c.l"
void pp_finalize(void) 
{ 
  char *s ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  struct obstack *__o ;
  void *__obj ;
  char *tmp___4 ;

  {
#line 308
  __o1 = opt_stack;
#line 308
  __value = (void *)__o1->object_base;
#line 308
  if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 308
    __o1->maybe_empty_object = 1U;
  }
#line 308
  if (sizeof(long ) < sizeof(void *)) {
#line 308
    tmp = __o1->object_base;
  } else {
#line 308
    tmp = (char *)0;
  }
#line 308
  if (sizeof(long ) < sizeof(void *)) {
#line 308
    tmp___0 = __o1->object_base;
  } else {
#line 308
    tmp___0 = (char *)0;
  }
#line 308
  __o1->next_free = tmp + (((__o1->next_free - tmp___0) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 308
  if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 308
    __o1->next_free = __o1->chunk_limit;
  }
#line 308
  __o1->object_base = __o1->next_free;
#line 308
  s = (char *)__value;
#line 309
  if (! pp_opts) {
    {
#line 310
    pp_opts = xstrdup((char const   *)s);
    }
  } else {
    {
#line 312
    tmp___1 = strlen((char const   *)pp_opts);
#line 312
    tmp___2 = strlen((char const   *)s);
#line 312
    tmp___3 = xrealloc((void *)pp_opts, (tmp___1 + tmp___2) + 1UL);
#line 312
    pp_opts = (char *)tmp___3;
#line 313
    strcat((char */* __restrict  */)pp_opts, (char const   */* __restrict  */)s);
    }
  }
#line 315
  __o = opt_stack;
#line 315
  __obj = (void *)s;
#line 315
  if ((unsigned long )__obj > (unsigned long )((void *)__o->chunk)) {
#line 315
    if ((unsigned long )__obj < (unsigned long )((void *)__o->chunk_limit)) {
#line 315
      tmp___4 = (char *)__obj;
#line 315
      __o->object_base = tmp___4;
#line 315
      __o->next_free = tmp___4;
    } else {
      {
#line 315
      obstack_free(__o, __obj);
      }
    }
  } else {
    {
#line 315
    obstack_free(__o, __obj);
    }
  }
  {
#line 316
  free((void *)opt_stack);
#line 317
  opt_stack = (struct obstack *)((void *)0);
  }
#line 318
  return;
}
}
#line 320 "c.l"
FILE *pp_open(char const   *name ) 
{ 
  FILE *fp ;
  char *s ;
  size_t size ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;

  {
#line 327
  if (opt_stack) {
    {
#line 328
    pp_finalize();
    }
  }
  {
#line 329
  tmp = strlen((char const   *)pp_bin);
#line 329
  tmp___0 = strlen(name);
#line 329
  size = ((tmp + 1UL) + tmp___0) + 1UL;
  }
#line 330
  if (pp_opts) {
    {
#line 331
    tmp___1 = strlen((char const   *)pp_opts);
#line 331
    size += tmp___1;
    }
  }
  {
#line 332
  tmp___2 = xmalloc(size);
#line 332
  s = (char *)tmp___2;
#line 333
  strcpy((char */* __restrict  */)s, (char const   */* __restrict  */)pp_bin);
  }
#line 334
  if (pp_opts) {
    {
#line 335
    strcat((char */* __restrict  */)s, (char const   */* __restrict  */)pp_opts);
    }
  }
  {
#line 336
  strcat((char */* __restrict  */)s, (char const   */* __restrict  */)" ");
#line 337
  strcat((char */* __restrict  */)s, (char const   */* __restrict  */)name);
  }
#line 338
  if (debug) {
    {
#line 339
    tmp___3 = gettext("Command line: %s\n");
#line 339
    printf((char const   */* __restrict  */)tmp___3, s);
    }
  }
  {
#line 340
  fp = popen((char const   *)s, "r");
  }
#line 341
  if (! fp) {
    {
#line 342
    tmp___4 = gettext("cannot execute `%s\'");
#line 342
    tmp___5 = __errno_location();
#line 342
    error(0, *tmp___5, (char const   *)tmp___4, s);
    }
  }
  {
#line 343
  free((void *)s);
  }
#line 344
  return (fp);
}
}
#line 347 "c.l"
void pp_close(FILE *fp ) 
{ 


  {
  {
#line 350
  pclose(fp);
  }
#line 351
  return;
}
}
#line 355 "c.l"
int yywrap(void) 
{ 
  YY_BUFFER_STATE tmp ;

  {
#line 358
  if (! yyin) {
#line 359
    return (1);
  }
#line 360
  if (preprocess_option) {
    {
#line 361
    pp_close(yyin);
    }
  } else {
    {
#line 363
    fclose(yyin);
    }
  }
#line 364
  yyin = (FILE *)((void *)0);
#line 366
  if (yy_buffer_stack) {
#line 366
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 366
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 366
  yy_delete_buffer(tmp);
#line 368
  delete_statics();
  }
#line 369
  return (1);
}
}
#line 372 "c.l"
static int hit_eof  ;
#line 374 "c.l"
int get_token(void) 
{ 
  int tok___0 ;

  {
#line 379
  if (hit_eof) {
#line 380
    tok___0 = 0;
  } else {
    {
#line 382
    tok___0 = yylex();
#line 383
    prev_token = tok___0;
    }
#line 384
    if (! tok___0) {
#line 385
      hit_eof = 1;
    }
  }
#line 387
  return (tok___0);
}
}
#line 390 "c.l"
int source(char *name ) 
{ 
  FILE *fp ;
  char *tmp ;
  int *tmp___0 ;
  struct obstack *__o ;
  int __len ;
  size_t tmp___1 ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 395
  fp = fopen((char const   */* __restrict  */)name, (char const   */* __restrict  */)"r");
  }
#line 396
  if (! fp) {
    {
#line 397
    tmp = gettext("cannot open `%s\'");
#line 397
    tmp___0 = __errno_location();
#line 397
    error(0, *tmp___0, (char const   *)tmp, name);
    }
#line 398
    return (1);
  }
#line 400
  if (preprocess_option) {
    {
#line 401
    fclose(fp);
#line 402
    fp = pp_open((char const   *)name);
    }
#line 403
    if (! fp) {
#line 404
      return (1);
    }
  }
  {
#line 406
  __o = & string_stk;
#line 406
  tmp___1 = strlen((char const   *)name);
#line 406
  __len = (int )(tmp___1 + 1UL);
  }
#line 406
  if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
    {
#line 406
    _obstack_newchunk(__o, __len);
    }
  }
  {
#line 406
  memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)name,
         (size_t )__len);
#line 406
  __o->next_free += __len;
#line 407
  __o1 = & string_stk;
#line 407
  __value = (void *)__o1->object_base;
  }
#line 407
  if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 407
    __o1->maybe_empty_object = 1U;
  }
#line 407
  if (sizeof(long ) < sizeof(void *)) {
#line 407
    tmp___2 = __o1->object_base;
  } else {
#line 407
    tmp___2 = (char *)0;
  }
#line 407
  if (sizeof(long ) < sizeof(void *)) {
#line 407
    tmp___3 = __o1->object_base;
  } else {
#line 407
    tmp___3 = (char *)0;
  }
#line 407
  __o1->next_free = tmp___2 + (((__o1->next_free - tmp___3) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 407
  if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 407
    __o1->next_free = __o1->chunk_limit;
  }
  {
#line 407
  __o1->object_base = __o1->next_free;
#line 407
  filename = (char *)__value;
#line 408
  canonical_filename = filename;
#line 409
  line_num = 1;
#line 410
  input_file_count ++;
#line 411
  hit_eof = 0;
#line 413
  yyrestart(fp);
  }
#line 414
  return (0);
}
}
#line 417 "c.l"
static int getnum(unsigned int base , int count ) 
{ 
  int c ;
  int n ;
  unsigned int i ;
  int tmp ;
  unsigned short const   **tmp___0 ;

  {
#line 423
  n = 0;
  {
#line 423
  while (1) {
    while_continue: /* CIL Label */ ;
#line 423
    if (! count) {
#line 423
      goto while_break;
    }
    {
#line 424
    tmp___0 = __ctype_b_loc();
#line 424
    c = input();
    }
#line 424
    if ((int const   )*(*tmp___0 + c) & 2048) {
#line 425
      i = (unsigned int )(c - 48);
    } else {
      {
#line 427
      tmp = toupper(c);
#line 427
      i = (unsigned int )((tmp - 65) + 10);
      }
    }
#line 428
    if (i > base) {
      {
#line 429
      yyunput(c, yytext);
      }
#line 430
      goto while_break;
    }
#line 432
    n = (int )((unsigned int )n * base + i);
#line 423
    count --;
  }
  while_break: /* CIL Label */ ;
  }
#line 434
  return (n);
}
}
#line 437 "c.l"
int backslash(void) 
{ 
  int c ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 442
  c = input();
  }
  {
#line 443
  if (c == 97) {
#line 443
    goto case_97;
  }
#line 444
  if (c == 98) {
#line 444
    goto case_98;
  }
#line 445
  if (c == 102) {
#line 445
    goto case_102;
  }
#line 446
  if (c == 110) {
#line 446
    goto case_110;
  }
#line 447
  if (c == 114) {
#line 447
    goto case_114;
  }
#line 448
  if (c == 116) {
#line 448
    goto case_116;
  }
#line 449
  if (c == 120) {
#line 449
    goto case_120;
  }
#line 450
  if (c == 48) {
#line 450
    goto case_48;
  }
#line 442
  goto switch_break;
  case_97: /* CIL Label */ 
#line 443
  return ('\a');
  case_98: /* CIL Label */ 
#line 444
  return ('\b');
  case_102: /* CIL Label */ 
#line 445
  return ('\f');
  case_110: /* CIL Label */ 
#line 446
  return ('\n');
  case_114: /* CIL Label */ 
#line 447
  return ('\r');
  case_116: /* CIL Label */ 
#line 448
  return ('\t');
  case_120: /* CIL Label */ 
  {
#line 449
  tmp = getnum(16U, 2);
  }
#line 449
  return (tmp);
  case_48: /* CIL Label */ 
  {
#line 450
  tmp___0 = getnum(8U, 3);
  }
#line 450
  return (tmp___0);
  switch_break: /* CIL Label */ ;
  }
#line 452
  return (c);
}
}
#line 455 "c.l"
void update_loc(void) 
{ 
  char *p ;
  char *tmp ;
  unsigned short const   **tmp___0 ;
  unsigned long tmp___1 ;
  unsigned short const   **tmp___2 ;
  int n ;
  struct obstack *__o ;
  int __len ;
  struct obstack *__o___0 ;
  char *tmp___3 ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;

  {
  {
#line 460
  tmp = strchr((char const   *)yytext, '#');
#line 460
  p = tmp + 1;
  }
  {
#line 460
  while (1) {
    while_continue: /* CIL Label */ ;
#line 460
    if (*p) {
      {
#line 460
      tmp___0 = __ctype_b_loc();
      }
#line 460
      if (! ((int const   )*(*tmp___0 + (int )*p) & 8192)) {
#line 460
        goto while_break;
      }
    } else {
#line 460
      goto while_break;
    }
#line 460
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 462
  if ((int )*(p + 0) == 108) {
#line 463
    p += 4;
  }
  {
#line 465
  tmp___1 = strtoul((char const   */* __restrict  */)p, (char **/* __restrict  */)(& p),
                    10);
#line 465
  line_num = (int )tmp___1;
  }
  {
#line 466
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 466
    if (*p) {
      {
#line 466
      tmp___2 = __ctype_b_loc();
      }
#line 466
      if (! ((int const   )*(*tmp___2 + (int )*p) & 8192)) {
#line 466
        goto while_break___0;
      }
    } else {
#line 466
      goto while_break___0;
    }
#line 466
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 468
  if ((int )*(p + 0) == 34) {
#line 471
    p ++;
#line 471
    n = 0;
    {
#line 471
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 471
      if (*(p + n)) {
#line 471
        if (! ((int )*(p + n) != 34)) {
#line 471
          goto while_break___1;
        }
      } else {
#line 471
        goto while_break___1;
      }
#line 471
      n ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 473
    __o = & string_stk;
#line 473
    __len = n;
#line 473
    if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
      {
#line 473
      _obstack_newchunk(__o, __len);
      }
    }
    {
#line 473
    memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)p,
           (size_t )__len);
#line 473
    __o->next_free += __len;
#line 474
    __o___0 = & string_stk;
    }
#line 474
    if ((unsigned long )(__o___0->next_free + 1) > (unsigned long )__o___0->chunk_limit) {
      {
#line 474
      _obstack_newchunk(__o___0, 1);
      }
    }
#line 474
    tmp___3 = __o___0->next_free;
#line 474
    (__o___0->next_free) ++;
#line 474
    *tmp___3 = (char)0;
#line 475
    __o1 = & string_stk;
#line 475
    __value = (void *)__o1->object_base;
#line 475
    if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 475
      __o1->maybe_empty_object = 1U;
    }
#line 475
    if (sizeof(long ) < sizeof(void *)) {
#line 475
      tmp___4 = __o1->object_base;
    } else {
#line 475
      tmp___4 = (char *)0;
    }
#line 475
    if (sizeof(long ) < sizeof(void *)) {
#line 475
      tmp___5 = __o1->object_base;
    } else {
#line 475
      tmp___5 = (char *)0;
    }
#line 475
    __o1->next_free = tmp___4 + (((__o1->next_free - tmp___5) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 475
    if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 475
      __o1->next_free = __o1->chunk_limit;
    }
#line 475
    __o1->object_base = __o1->next_free;
#line 475
    filename = (char *)__value;
  }
#line 477
  if (debug > 1) {
    {
#line 478
    tmp___6 = gettext("New location: %s:%d\n");
#line 478
    printf((char const   */* __restrict  */)tmp___6, filename, line_num);
    }
  }
#line 479
  return;
}
}
#line 188 "./cflow.h"
struct linked_list *linked_list_create(void (*fun)(void * ) ) ;
#line 189
void linked_list_destroy(struct linked_list **plist ) ;
#line 190
void linked_list_append(struct linked_list **plist , void *data ) ;
#line 192
void linked_list_iterate(struct linked_list **plist , int (*itr)(void * , void * ) ,
                         void *data ) ;
#line 194
void linked_list_unlink(struct linked_list *list , struct linked_list_entry *ent ) ;
#line 197
int data_in_list(void *data , struct linked_list *list ) ;
#line 21 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/linked-list.c"
static struct linked_list *deref_linked_list(struct linked_list **plist ) 
{ 
  struct linked_list *list ;
  void *tmp ;
  struct linked_list_entry *tmp___0 ;

  {
#line 24
  if (! *plist) {
    {
#line 25
    tmp = xmalloc(sizeof(*list));
#line 25
    list = (struct linked_list *)tmp;
#line 26
    list->free_data = (void (*)(void * ))((void *)0);
#line 27
    tmp___0 = (struct linked_list_entry *)((void *)0);
#line 27
    list->tail = tmp___0;
#line 27
    list->head = tmp___0;
#line 28
    *plist = list;
    }
  }
#line 30
  return (*plist);
}
}
#line 34 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/linked-list.c"
struct linked_list *linked_list_create(void (*fun)(void * ) ) 
{ 
  struct linked_list *list ;
  void *tmp ;
  struct linked_list_entry *tmp___0 ;

  {
  {
#line 37
  tmp = xmalloc(sizeof(*list));
#line 37
  list = (struct linked_list *)tmp;
#line 38
  list->free_data = fun;
#line 39
  tmp___0 = (struct linked_list_entry *)((void *)0);
#line 39
  list->tail = tmp___0;
#line 39
  list->head = tmp___0;
  }
#line 40
  return (list);
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/linked-list.c"
void linked_list_append(struct linked_list **plist , void *data ) 
{ 
  struct linked_list *list ;
  struct linked_list *tmp ;
  struct linked_list_entry *entry ;
  void *tmp___0 ;

  {
  {
#line 46
  tmp = deref_linked_list(plist);
#line 46
  list = tmp;
#line 47
  tmp___0 = xmalloc(sizeof(*entry));
#line 47
  entry = (struct linked_list_entry *)tmp___0;
#line 49
  entry->list = list;
#line 50
  entry->data = data;
#line 51
  entry->next = (struct linked_list_entry *)((void *)0);
#line 52
  entry->prev = list->tail;
  }
#line 53
  if (list->tail) {
#line 54
    (list->tail)->next = entry;
  } else {
#line 56
    list->head = entry;
  }
#line 57
  list->tail = entry;
#line 58
  return;
}
}
#line 79 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/linked-list.c"
void linked_list_destroy(struct linked_list **plist ) 
{ 
  struct linked_list *list ;
  struct linked_list_entry *p ;
  struct linked_list_entry *next ;

  {
#line 82
  if (plist) {
#line 82
    if (*plist) {
#line 83
      list = *plist;
#line 86
      p = list->head;
      {
#line 86
      while (1) {
        while_continue: /* CIL Label */ ;
#line 86
        if (! p) {
#line 86
          goto while_break;
        }
#line 87
        next = p->next;
#line 88
        if (list->free_data) {
          {
#line 89
          (*(list->free_data))(p->data);
          }
        }
        {
#line 90
        free((void *)p);
#line 91
        p = next;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 93
      free((void *)list);
#line 94
      *plist = (struct linked_list *)((void *)0);
      }
    }
  }
#line 96
  return;
}
}
#line 98 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/linked-list.c"
void linked_list_unlink(struct linked_list *list , struct linked_list_entry *ent ) 
{ 
  struct linked_list_entry *p ;

  {
#line 103
  p = ent->prev;
#line 103
  if (p) {
#line 104
    p->next = ent->next;
  } else {
#line 106
    list->head = ent->next;
  }
#line 108
  p = ent->next;
#line 108
  if (p) {
#line 109
    p->prev = ent->prev;
  } else {
#line 111
    list->tail = ent->prev;
  }
#line 112
  if (list->free_data) {
    {
#line 113
    (*(list->free_data))(ent->data);
    }
  }
  {
#line 114
  free((void *)ent);
  }
#line 115
  return;
}
}
#line 117 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/linked-list.c"
void linked_list_iterate(struct linked_list **plist , int (*itr)(void * , void * ) ,
                         void *data ) 
{ 
  struct linked_list *list ;
  struct linked_list_entry *p ;
  struct linked_list_entry *next ;
  int tmp ;

  {
#line 124
  if (! *plist) {
#line 125
    return;
  }
#line 126
  list = *plist;
#line 127
  if (list) {
#line 127
    p = list->head;
  } else {
#line 127
    p = (struct linked_list_entry *)((void *)0);
  }
  {
#line 127
  while (1) {
    while_continue: /* CIL Label */ ;
#line 127
    if (! p) {
#line 127
      goto while_break;
    }
    {
#line 128
    next = p->next;
#line 130
    tmp = (*itr)(p->data, data);
    }
#line 130
    if (tmp) {
      {
#line 131
      linked_list_unlink(list, p);
      }
    }
#line 132
    p = next;
  }
  while_break: /* CIL Label */ ;
  }
#line 134
  if (! list->head) {
    {
#line 135
    linked_list_destroy(& list);
    }
  }
#line 136
  *plist = list;
#line 137
  return;
}
}
#line 139 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/linked-list.c"
int data_in_list(void *data , struct linked_list *list ) 
{ 
  struct linked_list_entry *p ;

  {
#line 144
  if (list) {
#line 144
    p = list->head;
  } else {
#line 144
    p = (struct linked_list_entry *)((void *)0);
  }
  {
#line 144
  while (1) {
    while_continue: /* CIL Label */ ;
#line 144
    if (! p) {
#line 144
      goto while_break;
    }
#line 145
    if ((unsigned long )p->data == (unsigned long )data) {
#line 146
      return (1);
    }
#line 144
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 147
  return (0);
}
}
#line 69 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/dirname.h"
extern size_t base_len(char const   *file ) ;
#line 71
extern char *last_component(char const   *file ) ;
#line 73
_Bool strip_trailing_slashes(char *file ) ;
#line 31 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/stripslash.c"
_Bool strip_trailing_slashes(char *file ) 
{ 
  char *base ;
  char *tmp ;
  char *base_lim ;
  _Bool had_slash ;
  size_t tmp___0 ;

  {
  {
#line 34
  tmp = last_component((char const   *)file);
#line 34
  base = tmp;
  }
#line 40
  if (! *base) {
#line 41
    base = file;
  }
  {
#line 42
  tmp___0 = base_len((char const   *)base);
#line 42
  base_lim = base + tmp___0;
#line 43
  had_slash = (_Bool )((int )*base_lim != 0);
#line 44
  *base_lim = (char )'\000';
  }
#line 45
  return (had_slash);
}
}
#line 141 "./cflow.h"
FILE *outfile ;
#line 155
int print_as_tree ;
#line 156
int brief_listing ;
#line 161
int emacs_option ;
#line 209
void newline(void) ;
#line 210
void print_level(int lev , int last ) ;
#line 242
int gnu_output_handler(cflow_output_command cmd , FILE *outfile___0 , int line , void *data ,
                       void *handler_data ) ;
#line 21 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/gnu.c"
void print_function_name(Symbol *sym , int has_subtree ) 
{ 


  {
  {
#line 24
  fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"%s",
          sym->name);
  }
#line 25
  if (sym->arity >= 0) {
    {
#line 26
    fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"()");
    }
  }
#line 27
  if (sym->decl) {
    {
#line 28
    fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)" <%s at %s:%d>",
            sym->decl, sym->source, sym->def_line);
    }
  }
#line 32
  if (sym->active) {
    {
#line 33
    fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)" (recursive: see %d)",
            sym->active - 1);
    }
#line 34
    return;
  }
#line 36
  if (sym->recursive) {
    {
#line 37
    fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)" (R)");
    }
  }
#line 38
  if (! print_as_tree) {
#line 38
    if (has_subtree) {
      {
#line 39
      fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)":");
      }
    }
  }
#line 40
  return;
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/gnu.c"
static int print_symbol(FILE *outfile___0 , int line , struct output_symbol *s ) 
{ 
  int has_subtree ;
  int tmp ;

  {
#line 46
  if (s->direct) {
#line 46
    tmp = (unsigned long )(s->sym)->callee != (unsigned long )((void *)0);
  } else {
#line 46
    tmp = (unsigned long )(s->sym)->caller != (unsigned long )((void *)0);
  }
  {
#line 46
  has_subtree = tmp;
#line 50
  print_level(s->level, s->last);
#line 51
  print_function_name(s->sym, has_subtree);
  }
#line 53
  if (brief_listing) {
#line 54
    if ((s->sym)->expand_line) {
      {
#line 55
      fprintf((FILE */* __restrict  */)outfile___0, (char const   */* __restrict  */)" [see %d]",
              (s->sym)->expand_line);
      }
#line 56
      return (1);
    } else
#line 57
    if ((s->sym)->callee) {
#line 58
      (s->sym)->expand_line = line;
    }
  }
#line 60
  return (0);
}
}
#line 63 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/gnu.c"
int gnu_output_handler(cflow_output_command cmd , FILE *outfile___0 , int line , void *data ,
                       void *handler_data ) 
{ 
  int tmp ;

  {
  {
#line 69
  if ((unsigned int )cmd == 1U) {
#line 69
    goto case_1;
  }
#line 78
  if ((unsigned int )cmd == 4U) {
#line 78
    goto case_4;
  }
#line 78
  if ((unsigned int )cmd == 2U) {
#line 78
    goto case_4;
  }
#line 78
  if ((unsigned int )cmd == 0U) {
#line 78
    goto case_4;
  }
#line 80
  if ((unsigned int )cmd == 3U) {
#line 80
    goto case_3;
  }
#line 83
  if ((unsigned int )cmd == 6U) {
#line 83
    goto case_6;
  }
#line 86
  if ((unsigned int )cmd == 5U) {
#line 86
    goto case_5;
  }
#line 68
  goto switch_break;
  case_1: /* CIL Label */ 
#line 70
  if (emacs_option) {
    {
#line 71
    fprintf((FILE */* __restrict  */)outfile___0, (char const   */* __restrict  */)";; This file is generated by %s. -*- cflow -*-",
            "GNU cflow 1.4");
#line 73
    newline();
    }
  }
#line 75
  goto switch_break;
  case_4: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 79
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 81
  fprintf((FILE */* __restrict  */)outfile___0, (char const   */* __restrict  */)"\n");
  }
#line 82
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 84
  fprintf((FILE */* __restrict  */)outfile___0, (char const   */* __restrict  */)"%s",
          (char *)data);
  }
#line 85
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 87
  tmp = print_symbol(outfile___0, line, (struct output_symbol *)data);
  }
#line 87
  return (tmp);
  switch_break: /* CIL Label */ ;
  }
#line 89
  return (0);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 50 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 96
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memchr)(void const   *__s ,
                                                                                               int __c ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 390 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 602
extern int putc_unlocked(int __c , FILE *__stream ) ;
#line 739
extern size_t fwrite_unlocked(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                              FILE * __restrict  __stream ) ;
#line 123 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-fmtstream.h"
argp_fmtstream_t argp_make_fmtstream(FILE *stream , size_t lmargin , size_t rmargin ,
                                     ssize_t wmargin ) ;
#line 130
void argp_fmtstream_free(argp_fmtstream_t fs ) ;
#line 135
ssize_t ( /* format attribute */  argp_fmtstream_printf)(struct argp_fmtstream *fs ,
                                                         char const   *fmt  , ...) ;
#line 185
void _argp_fmtstream_update(argp_fmtstream_t fs ) ;
#line 187
int _argp_fmtstream_ensure(struct argp_fmtstream *fs , size_t amount ) ;
#line 58 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-fmtstream.c"
argp_fmtstream_t argp_make_fmtstream(FILE *stream , size_t lmargin , size_t rmargin ,
                                     ssize_t wmargin ) 
{ 
  argp_fmtstream_t fs ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 64
  tmp = malloc(sizeof(struct argp_fmtstream ));
#line 64
  fs = (struct argp_fmtstream *)tmp;
  }
#line 65
  if ((unsigned long )fs != (unsigned long )((void *)0)) {
    {
#line 67
    fs->stream = stream;
#line 69
    fs->lmargin = lmargin;
#line 70
    fs->rmargin = rmargin;
#line 71
    fs->wmargin = wmargin;
#line 72
    fs->point_col = (ssize_t )0;
#line 73
    fs->point_offs = (size_t )0;
#line 75
    tmp___0 = malloc((size_t )200);
#line 75
    fs->buf = (char *)tmp___0;
    }
#line 76
    if (! fs->buf) {
      {
#line 78
      free((void *)fs);
#line 79
      fs = (argp_fmtstream_t )0;
      }
    } else {
#line 83
      fs->p = fs->buf;
#line 84
      fs->end = fs->buf + 200;
    }
  }
#line 88
  return (fs);
}
}
#line 98 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-fmtstream.c"
void argp_fmtstream_free(argp_fmtstream_t fs ) 
{ 


  {
  {
#line 101
  _argp_fmtstream_update(fs);
  }
#line 102
  if ((unsigned long )fs->p > (unsigned long )fs->buf) {
    {
#line 107
    fwrite_unlocked((void const   */* __restrict  */)fs->buf, (size_t )1, (size_t )(fs->p - fs->buf),
                    (FILE */* __restrict  */)fs->stream);
    }
  }
  {
#line 110
  free((void *)fs->buf);
#line 111
  free((void *)fs);
  }
#line 112
  return;
}
}
#line 122 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-fmtstream.c"
void _argp_fmtstream_update(argp_fmtstream_t fs ) 
{ 
  char *buf ;
  char *nl ;
  size_t len ;
  size_t r ;
  size_t pad ;
  size_t i ;
  void *tmp ;
  char *p ;
  char *nextline ;
  int i___0 ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  size_t mv ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;

  {
#line 129
  buf = fs->buf + fs->point_offs;
  {
#line 130
  while (1) {
    while_continue: /* CIL Label */ ;
#line 130
    if (! ((unsigned long )buf < (unsigned long )fs->p)) {
#line 130
      goto while_break;
    }
#line 134
    if (fs->point_col == 0L) {
#line 134
      if (fs->lmargin != 0UL) {
#line 137
        pad = fs->lmargin;
#line 138
        if ((unsigned long )(fs->p + pad) < (unsigned long )fs->end) {
          {
#line 142
          memmove((void *)(buf + pad), (void const   *)buf, (size_t )(fs->p - buf));
#line 143
          fs->p += pad;
#line 144
          memset((void *)buf, ' ', pad);
#line 145
          buf += pad;
          }
        } else {
#line 151
          i = (size_t )0;
          {
#line 151
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 151
            if (! (i < pad)) {
#line 151
              goto while_break___0;
            }
            {
#line 158
            putc_unlocked(' ', fs->stream);
#line 151
            i ++;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
        }
#line 161
        fs->point_col = (ssize_t )pad;
      }
    }
    {
#line 164
    len = (size_t )(fs->p - buf);
#line 165
    tmp = memchr((void const   *)buf, '\n', len);
#line 165
    nl = (char *)tmp;
    }
#line 167
    if (fs->point_col < 0L) {
#line 168
      fs->point_col = (ssize_t )0;
    }
#line 170
    if (! nl) {
#line 174
      if ((size_t )fs->point_col + len < fs->rmargin) {
#line 179
        fs->point_col = (ssize_t )((size_t )fs->point_col + len);
#line 180
        goto while_break;
      } else {
#line 185
        nl = fs->p;
      }
    } else
#line 187
    if (fs->point_col + (nl - buf) < (ssize_t )fs->rmargin) {
#line 191
      fs->point_col = (ssize_t )0;
#line 192
      buf = nl + 1;
#line 193
      goto while_continue;
    }
#line 197
    r = fs->rmargin - 1UL;
#line 199
    if (fs->wmargin < 0L) {
#line 203
      if ((unsigned long )nl < (unsigned long )fs->p) {
        {
#line 205
        memmove((void *)(buf + (r - (size_t )fs->point_col)), (void const   *)nl,
                (size_t )(fs->p - nl));
#line 206
        fs->p -= (buf + (r - (size_t )fs->point_col)) - nl;
#line 208
        fs->point_col = (ssize_t )0;
#line 209
        buf += r + 1UL;
        }
      } else {
#line 216
        fs->point_col = (ssize_t )((size_t )fs->point_col + len);
#line 217
        fs->p -= (size_t )fs->point_col - r;
#line 218
        goto while_break;
      }
    } else {
#line 230
      p = buf + ((r + 1UL) - (size_t )fs->point_col);
      {
#line 231
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 231
        if ((unsigned long )p >= (unsigned long )buf) {
          {
#line 231
          tmp___0 = __ctype_b_loc();
          }
#line 231
          if ((int const   )*(*tmp___0 + (int )((unsigned char )*p)) & 1) {
#line 231
            goto while_break___1;
          }
        } else {
#line 231
          goto while_break___1;
        }
#line 232
        p --;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 233
      nextline = p + 1;
#line 235
      if ((unsigned long )nextline > (unsigned long )buf) {
#line 238
        if ((unsigned long )p >= (unsigned long )buf) {
          {
#line 239
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 240
            p --;
#line 239
            if ((unsigned long )p >= (unsigned long )buf) {
              {
#line 239
              tmp___1 = __ctype_b_loc();
              }
#line 239
              if (! ((int const   )*(*tmp___1 + (int )((unsigned char )*p)) & 1)) {
#line 239
                goto while_break___2;
              }
            } else {
#line 239
              goto while_break___2;
            }
          }
          while_break___2: /* CIL Label */ ;
          }
        }
#line 242
        nl = p + 1;
      } else {
#line 248
        p = buf + ((r + 1UL) - (size_t )fs->point_col);
#line 250
        if ((unsigned long )p < (unsigned long )nl) {
          {
#line 251
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 252
            p ++;
#line 251
            if ((unsigned long )p < (unsigned long )nl) {
              {
#line 251
              tmp___2 = __ctype_b_loc();
              }
#line 251
              if ((int const   )*(*tmp___2 + (int )((unsigned char )*p)) & 1) {
#line 251
                goto while_break___3;
              }
            } else {
#line 251
              goto while_break___3;
            }
          }
          while_break___3: /* CIL Label */ ;
          }
        }
#line 254
        if ((unsigned long )p == (unsigned long )nl) {
#line 257
          fs->point_col = (ssize_t )0;
#line 258
          buf = nl + 1;
#line 259
          goto while_continue;
        }
#line 262
        nl = p;
        {
#line 264
        while (1) {
          while_continue___4: /* CIL Label */ ;
          {
#line 265
          p ++;
#line 264
          tmp___3 = __ctype_b_loc();
          }
#line 264
          if (! ((int const   )*(*tmp___3 + (int )((unsigned char )*p)) & 1)) {
#line 264
            goto while_break___4;
          }
        }
        while_break___4: /* CIL Label */ ;
        }
#line 268
        nextline = p;
      }
#line 276
      if ((unsigned long )nextline == (unsigned long )((buf + len) + 1)) {
#line 276
        tmp___6 = fs->end - nl < fs->wmargin + 1L;
      } else {
#line 276
        tmp___6 = nextline - (nl + 1) < fs->wmargin;
      }
#line 276
      if (tmp___6) {
#line 276
        if ((unsigned long )fs->p > (unsigned long )nextline) {
#line 282
          if (fs->end - fs->p > fs->wmargin + 1L) {
            {
#line 285
            mv = (size_t )(fs->p - nextline);
#line 286
            memmove((void *)((nl + 1) + fs->wmargin), (void const   *)nextline, mv);
#line 287
            nextline = (nl + 1) + fs->wmargin;
#line 288
            len = (size_t )((nextline + mv) - buf);
#line 289
            tmp___4 = nl;
#line 289
            nl ++;
#line 289
            *tmp___4 = (char )'\n';
            }
          } else {
#line 298
            if ((unsigned long )nl > (unsigned long )fs->buf) {
              {
#line 299
              fwrite_unlocked((void const   */* __restrict  */)fs->buf, (size_t )1,
                              (size_t )(nl - fs->buf), (FILE */* __restrict  */)fs->stream);
              }
            }
            {
#line 300
            putc_unlocked('\n', fs->stream);
#line 303
            len += (size_t )(buf - fs->buf);
#line 304
            buf = fs->buf;
#line 304
            nl = buf;
            }
          }
        } else {
#line 310
          tmp___5 = nl;
#line 310
          nl ++;
#line 310
          *tmp___5 = (char )'\n';
        }
      } else {
#line 310
        tmp___5 = nl;
#line 310
        nl ++;
#line 310
        *tmp___5 = (char )'\n';
      }
#line 312
      if (nextline - nl >= fs->wmargin) {
#line 312
        goto _L;
      } else
#line 312
      if ((unsigned long )nextline == (unsigned long )((buf + len) + 1)) {
#line 312
        if (fs->end - nextline >= fs->wmargin) {
          _L: /* CIL Label */ 
#line 315
          i___0 = 0;
          {
#line 315
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 315
            if (! ((ssize_t )i___0 < fs->wmargin)) {
#line 315
              goto while_break___5;
            }
#line 316
            tmp___7 = nl;
#line 316
            nl ++;
#line 316
            *tmp___7 = (char )' ';
#line 315
            i___0 ++;
          }
          while_break___5: /* CIL Label */ ;
          }
        } else {
#line 312
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 318
        i___0 = 0;
        {
#line 318
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 318
          if (! ((ssize_t )i___0 < fs->wmargin)) {
#line 318
            goto while_break___6;
          }
          {
#line 324
          putc_unlocked(' ', fs->stream);
#line 318
          i___0 ++;
          }
        }
        while_break___6: /* CIL Label */ ;
        }
      }
#line 328
      if ((unsigned long )nl < (unsigned long )nextline) {
        {
#line 329
        memmove((void *)nl, (void const   *)nextline, (size_t )((buf + len) - nextline));
        }
      }
#line 330
      len -= (size_t )(nextline - buf);
#line 333
      buf = nl;
#line 336
      fs->p = nl + len;
#line 341
      if (fs->wmargin) {
#line 341
        fs->point_col = fs->wmargin;
      } else {
#line 341
        fs->point_col = (ssize_t )-1;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 346
  fs->point_offs = (size_t )(fs->p - fs->buf);
#line 347
  return;
}
}
#line 351 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-fmtstream.c"
int _argp_fmtstream_ensure(struct argp_fmtstream *fs , size_t amount ) 
{ 
  ssize_t wrote ;
  size_t tmp ;
  size_t old_size ;
  size_t new_size ;
  char *new_buf ;
  int *tmp___0 ;
  void *tmp___1 ;

  {
#line 354
  if ((size_t )(fs->end - fs->p) < amount) {
    {
#line 359
    _argp_fmtstream_update(fs);
#line 365
    tmp = fwrite_unlocked((void const   */* __restrict  */)fs->buf, (size_t )1, (size_t )(fs->p - fs->buf),
                          (FILE */* __restrict  */)fs->stream);
#line 365
    wrote = (ssize_t )tmp;
    }
#line 367
    if (wrote == fs->p - fs->buf) {
#line 369
      fs->p = fs->buf;
#line 370
      fs->point_offs = (size_t )0;
    } else {
      {
#line 374
      fs->p -= wrote;
#line 375
      fs->point_offs -= (size_t )wrote;
#line 376
      memmove((void *)fs->buf, (void const   *)(fs->buf + wrote), (size_t )(fs->p - fs->buf));
      }
#line 377
      return (0);
    }
#line 380
    if ((size_t )(fs->end - fs->buf) < amount) {
#line 383
      old_size = (size_t )(fs->end - fs->buf);
#line 384
      new_size = old_size + amount;
#line 387
      if (new_size < old_size) {
        {
#line 389
        tmp___0 = __errno_location();
#line 389
        *tmp___0 = 12;
        }
#line 390
        return (0);
      } else {
        {
#line 387
        tmp___1 = realloc((void *)fs->buf, new_size);
#line 387
        new_buf = (char *)tmp___1;
        }
#line 387
        if (! new_buf) {
          {
#line 389
          tmp___0 = __errno_location();
#line 389
          *tmp___0 = 12;
          }
#line 390
          return (0);
        }
      }
#line 393
      fs->buf = new_buf;
#line 394
      fs->end = new_buf + new_size;
#line 395
      fs->p = fs->buf;
    }
  }
#line 399
  return (1);
}
}
#line 402 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-fmtstream.c"
ssize_t ( /* format attribute */  argp_fmtstream_printf)(struct argp_fmtstream *fs ,
                                                         char const   *fmt  , ...) 
{ 
  int out ;
  size_t avail ;
  size_t size_guess ;
  va_list args ;
  int tmp ;

  {
#line 407
  size_guess = (size_t )150;
  {
#line 409
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 413
    tmp = _argp_fmtstream_ensure(fs, size_guess);
    }
#line 413
    if (! tmp) {
#line 414
      return ((ssize_t )-1);
    }
    {
#line 416
    __builtin_va_start(args, fmt);
#line 417
    avail = (size_t )(fs->end - fs->p);
#line 418
    out = vsnprintf((char */* __restrict  */)fs->p, avail, (char const   */* __restrict  */)fmt,
                    args);
#line 419
    __builtin_va_end(args);
    }
#line 420
    if ((size_t )out >= avail) {
#line 421
      size_guess = (size_t )(out + 1);
    }
#line 409
    if (! ((size_t )out >= avail)) {
#line 409
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 425
  fs->p += out;
#line 427
  return ((ssize_t )out);
}
}
#line 260 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-fmtstream.h"
size_t argp_fmtstream_write(argp_fmtstream_t __fs , char const   *__str , size_t __len ) 
{ 
  int tmp ;

  {
#line 264
  if ((unsigned long )(__fs->p + __len) <= (unsigned long )__fs->end) {
    {
#line 266
    memcpy((void */* __restrict  */)__fs->p, (void const   */* __restrict  */)__str,
           __len);
#line 267
    __fs->p += __len;
    }
#line 268
    return (__len);
  } else {
    {
#line 264
    tmp = _argp_fmtstream_ensure(__fs, __len);
    }
#line 264
    if (tmp) {
      {
#line 266
      memcpy((void */* __restrict  */)__fs->p, (void const   */* __restrict  */)__str,
             __len);
#line 267
      __fs->p += __len;
      }
#line 268
      return (__len);
    } else {
#line 271
      return ((size_t )0);
    }
  }
}
}
#line 274 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-fmtstream.h"
int argp_fmtstream_puts(argp_fmtstream_t __fs , char const   *__str ) 
{ 
  size_t __len ;
  size_t tmp ;
  size_t __wrote ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 277
  tmp = strlen(__str);
#line 277
  __len = tmp;
  }
#line 278
  if (__len) {
    {
#line 280
    tmp___0 = argp_fmtstream_write(__fs, __str, __len);
#line 280
    __wrote = tmp___0;
    }
#line 281
    if (__wrote == __len) {
#line 281
      tmp___1 = 0;
    } else {
#line 281
      tmp___1 = -1;
    }
#line 281
    return (tmp___1);
  } else {
#line 284
    return (0);
  }
}
}
#line 287 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-fmtstream.h"
int argp_fmtstream_putc(argp_fmtstream_t __fs , int __ch ) 
{ 
  char *tmp ;
  char tmp___0 ;
  int tmp___1 ;

  {
#line 290
  if ((unsigned long )__fs->p < (unsigned long )__fs->end) {
#line 291
    tmp = __fs->p;
#line 291
    (__fs->p) ++;
#line 291
    tmp___0 = (char )__ch;
#line 291
    *tmp = tmp___0;
#line 291
    return ((int )tmp___0);
  } else {
    {
#line 290
    tmp___1 = _argp_fmtstream_ensure(__fs, (size_t )1);
    }
#line 290
    if (tmp___1) {
#line 291
      tmp = __fs->p;
#line 291
      (__fs->p) ++;
#line 291
      tmp___0 = (char )__ch;
#line 291
      *tmp = tmp___0;
#line 291
      return ((int )tmp___0);
    } else {
#line 293
      return (-1);
    }
  }
}
}
#line 297 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-fmtstream.h"
size_t argp_fmtstream_set_lmargin(argp_fmtstream_t __fs , size_t __lmargin ) 
{ 
  size_t __old ;

  {
#line 301
  if ((size_t )(__fs->p - __fs->buf) > __fs->point_offs) {
    {
#line 302
    _argp_fmtstream_update(__fs);
    }
  }
#line 303
  __old = __fs->lmargin;
#line 304
  __fs->lmargin = __lmargin;
#line 305
  return (__old);
}
}
#line 309 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-fmtstream.h"
size_t argp_fmtstream_set_rmargin(argp_fmtstream_t __fs , size_t __rmargin ) 
{ 
  size_t __old ;

  {
#line 313
  if ((size_t )(__fs->p - __fs->buf) > __fs->point_offs) {
    {
#line 314
    _argp_fmtstream_update(__fs);
    }
  }
#line 315
  __old = __fs->rmargin;
#line 316
  __fs->rmargin = __rmargin;
#line 317
  return (__old);
}
}
#line 321 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-fmtstream.h"
size_t argp_fmtstream_set_wmargin(argp_fmtstream_t __fs , size_t __wmargin ) 
{ 
  size_t __old ;

  {
#line 325
  if ((size_t )(__fs->p - __fs->buf) > __fs->point_offs) {
    {
#line 326
    _argp_fmtstream_update(__fs);
    }
  }
#line 327
  __old = (size_t )__fs->wmargin;
#line 328
  __fs->wmargin = (ssize_t )__wmargin;
#line 329
  return (__old);
}
}
#line 333 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-fmtstream.h"
size_t argp_fmtstream_point(argp_fmtstream_t __fs ) 
{ 
  ssize_t tmp ;

  {
#line 336
  if ((size_t )(__fs->p - __fs->buf) > __fs->point_offs) {
    {
#line 337
    _argp_fmtstream_update(__fs);
    }
  }
#line 338
  if (__fs->point_col >= 0L) {
#line 338
    tmp = __fs->point_col;
  } else {
#line 338
    tmp = (ssize_t )0;
  }
#line 338
  return ((size_t )tmp);
}
}
#line 468 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp.h"
error_t argp_err_exit_status ;
#line 32 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-eexst.c"
error_t argp_err_exit_status  =    64;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 55 "../gnu/xalloc.h"
 __attribute__((__noreturn__)) void xalloc_die(void) ;
#line 157 "./cflow.h"
int reverse_tree ;
#line 180
Symbol *install_ident(char *name , enum storage storage ) ;
#line 181
void ident_change_storage(Symbol *sp , enum storage storage ) ;
#line 182
void delete_autos(int level___0 ) ;
#line 184
void delete_parms(int level___0 ) ;
#line 185
void move_parms(int level___0 ) ;
#line 186
size_t collect_symbols(Symbol ***return_sym , int (*sel)(Symbol *p ) , size_t reserved_slots ) ;
#line 187
size_t collect_functions(Symbol ***return_sym ) ;
#line 213
int symbol_is_function(Symbol *symp ) ;
#line 72 "../gnu/hash.h"
extern void *hash_lookup(Hash_table const   * , void const   * ) ;
#line 78
extern size_t hash_do_for_each(Hash_table const   * , _Bool (*)(void * , void * ) ,
                               void * ) ;
#line 81
extern size_t hash_string(char const   * , size_t  ) ;
#line 83
extern Hash_table *( __attribute__((__warn_unused_result__)) hash_initialize)(size_t  ,
                                                                              Hash_tuning const   * ,
                                                                              size_t (*)(void const   * ,
                                                                                         size_t  ) ,
                                                                              _Bool (*)(void const   * ,
                                                                                        void const   * ) ,
                                                                              void (*)(void * ) ) ;
#line 91
extern void *( __attribute__((__warn_unused_result__)) hash_insert)(Hash_table * ,
                                                                    void const   * ) ;
#line 23 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/symbol.c"
static Hash_table *symbol_table  ;
#line 25 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/symbol.c"
static struct linked_list *static_symbol_list  ;
#line 26 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/symbol.c"
static struct linked_list *auto_symbol_list  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/symbol.c"
static struct linked_list *static_func_list  ;
#line 29 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/symbol.c"
static void append_symbol(struct linked_list **plist , Symbol *sp ) 
{ 
  int tmp ;

  {
#line 32
  if (sp->entry) {
    {
#line 33
    linked_list_unlink((sp->entry)->list, sp->entry);
#line 34
    sp->entry = (struct linked_list_entry *)((void *)0);
    }
  }
  {
#line 36
  tmp = data_in_list((void *)sp, *plist);
  }
#line 36
  if (! tmp) {
    {
#line 37
    linked_list_append(plist, (void *)sp);
#line 38
    sp->entry = (*plist)->tail;
    }
  }
#line 40
  return;
}
}
#line 47 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/symbol.c"
static size_t hash_symbol_hasher(void const   *data , unsigned int n_buckets ) 
{ 
  struct table_entry  const  *t ;
  size_t tmp ;

  {
#line 50
  t = (struct table_entry  const  *)data;
#line 51
  if (! t->sym) {
#line 52
    return ((size_t )data % (unsigned long )n_buckets);
  }
  {
#line 53
  tmp = hash_string((char const   *)(t->sym)->name, (size_t )n_buckets);
  }
#line 53
  return (tmp);
}
}
#line 57 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/symbol.c"
static _Bool hash_symbol_compare(void const   *data1 , void const   *data2 ) 
{ 
  struct table_entry  const  *t1 ;
  struct table_entry  const  *t2 ;
  int tmp ;
  int tmp___0 ;

  {
#line 60
  t1 = (struct table_entry  const  *)data1;
#line 61
  t2 = (struct table_entry  const  *)data2;
#line 62
  if (t1->sym) {
#line 62
    if (t2->sym) {
      {
#line 62
      tmp = strcmp((char const   *)(t1->sym)->name, (char const   *)(t2->sym)->name);
      }
#line 62
      if (tmp == 0) {
#line 62
        tmp___0 = 1;
      } else {
#line 62
        tmp___0 = 0;
      }
    } else {
#line 62
      tmp___0 = 0;
    }
  } else {
#line 62
    tmp___0 = 0;
  }
#line 62
  return ((_Bool )tmp___0);
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/symbol.c"
Symbol *lookup(char const   *name ) 
{ 
  Symbol s ;
  Symbol *sym ;
  struct table_entry t ;
  struct table_entry *tp ;
  void *tmp ;

  {
#line 71
  if (! symbol_table) {
#line 72
    return ((Symbol *)((void *)0));
  }
  {
#line 73
  s.name = (char *)name;
#line 74
  t.sym = & s;
#line 75
  tmp = hash_lookup((Hash_table const   *)symbol_table, (void const   *)(& t));
#line 75
  tp = (struct table_entry *)tmp;
  }
#line 76
  if (tp) {
#line 77
    sym = tp->sym;
    {
#line 78
    while (1) {
      while_continue: /* CIL Label */ ;
#line 78
      if ((unsigned int )sym->type == 1U) {
#line 78
        if (! ((unsigned int )sym->flag == 3U)) {
#line 78
          goto while_break;
        }
      } else {
#line 78
        goto while_break;
      }
#line 79
      sym = sym->alias;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 81
    sym = (Symbol *)((void *)0);
  }
#line 82
  return (sym);
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/symbol.c"
Symbol *install(char *name , int flags ) 
{ 
  Symbol *sym ;
  struct table_entry *tp ;
  struct table_entry *ret ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 93
  tmp = xmalloc(sizeof(*sym));
#line 93
  sym = (Symbol *)tmp;
#line 94
  memset((void *)sym, 0, sizeof(*sym));
#line 95
  sym->type = (enum symtype )0;
#line 96
  sym->name = name;
#line 98
  tmp___0 = xmalloc(sizeof(*tp));
#line 98
  tp = (struct table_entry *)tmp___0;
#line 99
  tp->sym = sym;
  }
#line 101
  if (flags & 2) {
#line 101
    if (canonical_filename) {
      {
#line 101
      tmp___1 = strcmp((char const   *)filename, (char const   *)canonical_filename);
      }
#line 101
      if (tmp___1) {
        {
#line 104
        sym->flag = (enum symbol_flag )1;
#line 105
        append_symbol(& static_symbol_list, sym);
        }
      } else {
#line 101
        goto _L___0;
      }
    } else {
#line 101
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 101
  if (flags & 4) {
    {
#line 104
    sym->flag = (enum symbol_flag )1;
#line 105
    append_symbol(& static_symbol_list, sym);
    }
  } else {
#line 107
    sym->flag = (enum symbol_flag )0;
  }
#line 109
  if (symbol_table) {
#line 109
    goto _L___1;
  } else {
    {
#line 109
    symbol_table = hash_initialize((size_t )0, (Hash_tuning const   *)0, (size_t (*)(void const   * ,
                                                                                     size_t  ))(& hash_symbol_hasher),
                                   & hash_symbol_compare, (void (*)(void * ))0);
    }
#line 109
    if (symbol_table) {
      _L___1: /* CIL Label */ 
      {
#line 109
      tmp___2 = hash_insert(symbol_table, (void const   *)tp);
#line 109
      ret = (struct table_entry *)tmp___2;
      }
#line 109
      if (! ret) {
        {
#line 114
        xalloc_die();
        }
      }
    } else {
      {
#line 114
      xalloc_die();
      }
    }
  }
#line 116
  if ((unsigned long )ret != (unsigned long )tp) {
#line 117
    if (flags & 1) {
      {
#line 118
      free((void *)sym);
#line 119
      free((void *)tp);
      }
#line 120
      return (ret->sym);
    }
#line 122
    if ((unsigned int )(ret->sym)->type != 0U) {
#line 123
      sym->next = ret->sym;
    }
    {
#line 124
    ret->sym = sym;
#line 125
    free((void *)tp);
    }
  }
#line 127
  sym->owner = ret;
#line 128
  return (sym);
}
}
#line 131 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/symbol.c"
void ident_change_storage(Symbol *sp , enum storage storage ) 
{ 


  {
#line 134
  if ((unsigned int )sp->storage == (unsigned int )storage) {
#line 135
    return;
  }
  {
#line 140
  if ((unsigned int )storage == 2U) {
#line 140
    goto case_2;
  }
#line 143
  if ((unsigned int )storage == 3U) {
#line 143
    goto case_3;
  }
#line 146
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 141
  append_symbol(& static_symbol_list, sp);
  }
#line 142
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 144
  append_symbol(& auto_symbol_list, sp);
  }
#line 145
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 147
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 149
  sp->storage = storage;
#line 150
  return;
}
}
#line 152 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/symbol.c"
Symbol *install_ident(char *name , enum storage storage ) 
{ 
  Symbol *sp ;
  int tmp ;
  struct linked_list *tmp___0 ;

  {
#line 157
  if ((unsigned int )storage != 3U) {
#line 157
    tmp = 2;
  } else {
#line 157
    tmp = 0;
  }
  {
#line 157
  sp = install(name, tmp);
#line 160
  sp->type = (enum symtype )2;
#line 161
  sp->arity = -1;
#line 162
  sp->storage = (enum storage )0;
#line 163
  sp->decl = (char *)((void *)0);
#line 164
  sp->source = (char *)((void *)0);
#line 165
  sp->def_line = -1;
#line 166
  sp->ref_line = (struct linked_list *)((void *)0);
#line 167
  tmp___0 = (struct linked_list *)((void *)0);
#line 167
  sp->callee = tmp___0;
#line 167
  sp->caller = tmp___0;
#line 168
  sp->level = -1;
#line 169
  ident_change_storage(sp, storage);
  }
#line 170
  return (sp);
}
}
#line 174 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/symbol.c"
static void unlink_symbol(Symbol *sym ) 
{ 
  Symbol *s ;
  Symbol *prev ;
  struct table_entry *tp ;
  Symbol *next ;

  {
#line 177
  prev = (Symbol *)((void *)0);
#line 178
  tp = sym->owner;
#line 179
  s = tp->sym;
  {
#line 179
  while (1) {
    while_continue: /* CIL Label */ ;
#line 179
    if (! s) {
#line 179
      goto while_break;
    }
#line 180
    next = s->next;
#line 181
    if ((unsigned long )s == (unsigned long )sym) {
#line 182
      if (prev) {
#line 183
        prev->next = next;
      } else {
#line 185
        tp->sym = next;
      }
#line 186
      goto while_break;
    } else {
#line 188
      prev = s;
    }
#line 189
    s = next;
  }
  while_break: /* CIL Label */ ;
  }
#line 192
  sym->owner = (struct table_entry *)((void *)0);
#line 193
  return;
}
}
#line 196 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/symbol.c"
static void delete_symbol(Symbol *sym ) 
{ 


  {
  {
#line 199
  unlink_symbol(sym);
  }
#line 202
  if ((unsigned long )sym->ref_line == (unsigned long )((void *)0)) {
#line 202
    if (reverse_tree) {
#line 202
      if (! sym->callee) {
        {
#line 203
        linked_list_destroy(& sym->ref_line);
#line 204
        linked_list_destroy(& sym->caller);
#line 205
        linked_list_destroy(& sym->callee);
#line 206
        free((void *)sym);
        }
      }
    } else {
      {
#line 203
      linked_list_destroy(& sym->ref_line);
#line 204
      linked_list_destroy(& sym->caller);
#line 205
      linked_list_destroy(& sym->callee);
#line 206
      free((void *)sym);
      }
    }
  }
#line 208
  return;
}
}
#line 219 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/symbol.c"
static void static_free(void *data ) 
{ 
  Symbol *sym ;
  struct table_entry *t ;
  int tmp ;

  {
#line 222
  sym = (Symbol *)data;
#line 223
  t = sym->owner;
#line 225
  if (! t) {
#line 226
    return;
  }
#line 227
  if ((unsigned int )sym->flag == 1U) {
    {
#line 228
    delete_symbol(sym);
    }
  } else {
    {
#line 230
    unlink_symbol(sym);
#line 231
    tmp = symbol_is_function(sym);
    }
#line 231
    if (tmp) {
      {
#line 232
      linked_list_append(& static_func_list, (void *)sym);
      }
    }
  }
#line 234
  return;
}
}
#line 236 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/symbol.c"
void delete_statics(void) 
{ 


  {
#line 239
  if (static_symbol_list) {
    {
#line 240
    static_symbol_list->free_data = & static_free;
#line 241
    linked_list_destroy(& static_symbol_list);
    }
  }
#line 243
  return;
}
}
#line 249 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/symbol.c"
int delete_level_autos(void *data , void *call_data ) 
{ 
  int level___0 ;
  Symbol *s ;

  {
#line 252
  level___0 = *((int *)call_data);
#line 253
  s = (Symbol *)data;
#line 254
  if (s->level == level___0) {
    {
#line 255
    delete_symbol(s);
    }
#line 256
    return (1);
  }
#line 258
  return (0);
}
}
#line 261 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/symbol.c"
int delete_level_statics(void *data , void *call_data ) 
{ 
  int level___0 ;
  Symbol *s ;

  {
#line 264
  level___0 = *((int *)call_data);
#line 265
  s = (Symbol *)data;
#line 266
  if (s->level == level___0) {
    {
#line 267
    unlink_symbol(s);
    }
#line 268
    return (1);
  }
#line 270
  return (0);
}
}
#line 273 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/symbol.c"
void delete_autos(int level___0 ) 
{ 


  {
  {
#line 276
  linked_list_iterate(& auto_symbol_list, & delete_level_autos, (void *)(& level___0));
#line 277
  linked_list_iterate(& static_symbol_list, & delete_level_statics, (void *)(& level___0));
  }
#line 278
  return;
}
}
#line 286 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/symbol.c"
static _Bool collect_processor(void *data , void *proc_data ) 
{ 
  struct table_entry *t ;
  struct collect_data *cd ;
  Symbol *s ;
  int tmp ;

  {
#line 289
  t = (struct table_entry *)data;
#line 290
  cd = (struct collect_data *)proc_data;
#line 292
  s = t->sym;
  {
#line 292
  while (1) {
    while_continue: /* CIL Label */ ;
#line 292
    if (! s) {
#line 292
      goto while_break;
    }
    {
#line 293
    tmp = (*(cd->sel))(s);
    }
#line 293
    if (tmp) {
#line 294
      if (cd->sym) {
#line 295
        *(cd->sym + cd->index) = s;
      }
#line 296
      (cd->index) ++;
    }
#line 292
    s = s->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 299
  return ((_Bool)1);
}
}
#line 302 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/symbol.c"
size_t collect_symbols(Symbol ***return_sym , int (*sel)(Symbol *p ) , size_t reserved_slots ) 
{ 
  struct collect_data cdata ;
  void *tmp ;

  {
  {
#line 308
  cdata.sym = (Symbol **)((void *)0);
#line 309
  cdata.index = (size_t )0;
#line 310
  cdata.sel = sel;
#line 311
  hash_do_for_each((Hash_table const   *)symbol_table, & collect_processor, (void *)(& cdata));
#line 312
  tmp = calloc(cdata.index + reserved_slots, sizeof(*(cdata.sym)));
#line 312
  cdata.sym = (Symbol **)tmp;
  }
#line 313
  if (! cdata.sym) {
    {
#line 314
    xalloc_die();
    }
  }
  {
#line 315
  cdata.index = (size_t )0;
#line 316
  hash_do_for_each((Hash_table const   *)symbol_table, & collect_processor, (void *)(& cdata));
#line 317
  *return_sym = cdata.sym;
  }
#line 318
  return (cdata.index);
}
}
#line 321 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/symbol.c"
size_t collect_functions(Symbol ***return_sym ) 
{ 
  Symbol **symbols ;
  size_t num ;
  size_t snum ;
  struct linked_list_entry *p ;
  size_t tmp ;

  {
#line 329
  snum = (size_t )0;
#line 330
  if (static_func_list) {
#line 331
    if (static_func_list) {
#line 331
      p = static_func_list->head;
    } else {
#line 331
      p = (struct linked_list_entry *)((void *)0);
    }
    {
#line 331
    while (1) {
      while_continue: /* CIL Label */ ;
#line 331
      if (! p) {
#line 331
        goto while_break;
      }
#line 332
      snum ++;
#line 331
      p = p->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 335
  num = collect_symbols(& symbols, & symbol_is_function, snum);
  }
#line 338
  if (snum) {
#line 339
    if (static_func_list) {
#line 339
      p = static_func_list->head;
    } else {
#line 339
      p = (struct linked_list_entry *)((void *)0);
    }
    {
#line 339
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 339
      if (! p) {
#line 339
        goto while_break___0;
      }
#line 340
      tmp = num;
#line 340
      num ++;
#line 340
      *(symbols + tmp) = (Symbol *)p->data;
#line 339
      p = p->next;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 341
  *return_sym = symbols;
#line 342
  return (num);
}
}
#line 349 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/symbol.c"
int delete_parms_itr(void *data , void *call_data ) 
{ 
  int level___0 ;
  Symbol *s ;
  struct table_entry *t ;

  {
#line 352
  level___0 = *((int *)call_data);
#line 353
  s = (Symbol *)data;
#line 354
  t = s->owner;
#line 356
  if (! t) {
#line 357
    return (1);
  }
#line 358
  if ((unsigned int )s->type == 2U) {
#line 358
    if ((unsigned int )s->storage == 3U) {
#line 358
      if ((unsigned int )s->flag == 2U) {
#line 358
        if (s->level > level___0) {
          {
#line 360
          delete_symbol(s);
          }
#line 361
          return (1);
        }
      }
    }
  }
#line 363
  return (0);
}
}
#line 367 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/symbol.c"
void delete_parms(int level___0 ) 
{ 


  {
  {
#line 370
  linked_list_iterate(& auto_symbol_list, & delete_parms_itr, (void *)(& level___0));
  }
#line 371
  return;
}
}
#line 375 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/symbol.c"
void move_parms(int level___0 ) 
{ 
  struct linked_list_entry *p ;
  Symbol *s ;

  {
#line 380
  if (auto_symbol_list) {
#line 380
    p = auto_symbol_list->head;
  } else {
#line 380
    p = (struct linked_list_entry *)((void *)0);
  }
  {
#line 380
  while (1) {
    while_continue: /* CIL Label */ ;
#line 380
    if (! p) {
#line 380
      goto while_break;
    }
#line 381
    s = (Symbol *)p->data;
#line 383
    if ((unsigned int )s->type == 2U) {
#line 383
      if ((unsigned int )s->storage == 3U) {
#line 383
        if ((unsigned int )s->flag == 2U) {
#line 385
          s->level = level___0;
#line 386
          s->flag = (enum symbol_flag )0;
        }
      }
    }
#line 380
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 389
  return;
}
}
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 183
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 69 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 184
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strndup)(char const   *__string ,
                                                                                                size_t __n )  __attribute__((__malloc__)) ;
#line 137 "../gnu/getopt.h"
extern char *rpl_optarg ;
#line 82 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) textdomain)(char const   *__domainname ) ;
#line 86
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) bindtextdomain)(char const   *__domainname ,
                                                                                       char const   *__dirname ) ;
#line 124 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) setlocale)(int __category ,
                                                                                  char const   *__locale ) ;
#line 142 "./cflow.h"
char *outname ;
#line 144 "./cflow.h"
int verbose  ;
#line 145
int print_option ;
#line 146 "./cflow.h"
int use_indentation  ;
#line 148 "./cflow.h"
int record_defines  ;
#line 149 "./cflow.h"
int strict_ansi  ;
#line 150
char *level_indent[2] ;
#line 151
char *level_end[2] ;
#line 152
char *level_begin ;
#line 153 "./cflow.h"
int print_levels  ;
#line 154 "./cflow.h"
int print_line_numbers  ;
#line 155 "./cflow.h"
int print_as_tree  ;
#line 156 "./cflow.h"
int brief_listing  ;
#line 157 "./cflow.h"
int reverse_tree  ;
#line 159
char *start_name ;
#line 160 "./cflow.h"
int max_depth  ;
#line 161 "./cflow.h"
int emacs_option  ;
#line 162 "./cflow.h"
int debug  ;
#line 164 "./cflow.h"
int omit_arguments_option  ;
#line 165 "./cflow.h"
int omit_symbol_names_option  ;
#line 167
int token_stack_length ;
#line 205
void init_parse(void) ;
#line 206
int yyparse(void) ;
#line 208
void output(void) ;
#line 211
int globals_only(void) ;
#line 212
int include_symbol(Symbol *sym ) ;
#line 215
void sourcerc(int *argc_ptr , char ***argv_ptr ) ;
#line 234
int register_output(char const   *name , int (*handler)(cflow_output_command cmd ,
                                                        FILE *outfile , int line ,
                                                        void *data , void *handler_data ) ,
                    void *handler_data ) ;
#line 239
int select_output_driver(char const   *name ) ;
#line 240
void output_init(void) ;
#line 245
int posix_output_handler(cflow_output_command cmd , FILE *outfile___0 , int line ,
                         void *data , void *handler_data ) ;
#line 418 "../gnu/argp.h"
error_t argp_parse(struct argp  const  * __restrict  argp___0 , int argc , char ** __restrict  argv ,
                   unsigned int flags , int * __restrict  end_index , void * __restrict  input___0 ) ;
#line 534
void ( /* format attribute */  argp_error)(struct argp_state  const  * __restrict  state ,
                                           char const   * __restrict  fmt  , ...) ;
#line 36 "../gnu/argp-version-etc.h"
extern void argp_version_setup(char const   *name , char const   * const  *authors ) ;
#line 37 "../gnu/progname.h"
extern void set_program_name(char const   *argv0 ) ;
#line 36 "../gnu/version-etc.h"
char const   version_etc_copyright[63] ;
#line 27 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/main.c"
char const   *argp_program_bug_address  =    "<bug-cflow@gnu.org>";
#line 28 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/main.c"
static char doc[180]  = 
#line 28
  {      (char )'g',      (char )'e',      (char )'n',      (char )'e', 
        (char )'r',      (char )'a',      (char )'t',      (char )'e', 
        (char )' ',      (char )'a',      (char )' ',      (char )'p', 
        (char )'r',      (char )'o',      (char )'g',      (char )'r', 
        (char )'a',      (char )'m',      (char )' ',      (char )'f', 
        (char )'l',      (char )'o',      (char )'w',      (char )'g', 
        (char )'r',      (char )'a',      (char )'p',      (char )'h', 
        (char )'\v',      (char )'*',      (char )' ',      (char )'T', 
        (char )'h',      (char )'e',      (char )' ',      (char )'e', 
        (char )'f',      (char )'f',      (char )'e',      (char )'c', 
        (char )'t',      (char )' ',      (char )'o',      (char )'f', 
        (char )' ',      (char )'e',      (char )'a',      (char )'c', 
        (char )'h',      (char )' ',      (char )'o',      (char )'p', 
        (char )'t',      (char )'i',      (char )'o',      (char )'n', 
        (char )' ',      (char )'m',      (char )'a',      (char )'r', 
        (char )'k',      (char )'e',      (char )'d',      (char )' ', 
        (char )'w',      (char )'i',      (char )'t',      (char )'h', 
        (char )' ',      (char )'a',      (char )'n',      (char )' ', 
        (char )'a',      (char )'s',      (char )'t',      (char )'e', 
        (char )'r',      (char )'i',      (char )'s',      (char )'k', 
        (char )' ',      (char )'i',      (char )'s',      (char )' ', 
        (char )'r',      (char )'e',      (char )'v',      (char )'e', 
        (char )'r',      (char )'s',      (char )'e',      (char )'d', 
        (char )' ',      (char )'i',      (char )'f',      (char )' ', 
        (char )'t',      (char )'h',      (char )'e',      (char )' ', 
        (char )'o',      (char )'p',      (char )'t',      (char )'i', 
        (char )'o',      (char )'n',      (char )'\'',      (char )'s', 
        (char )' ',      (char )'l',      (char )'o',      (char )'n', 
        (char )'g',      (char )' ',      (char )'n',      (char )'a', 
        (char )'m',      (char )'e',      (char )' ',      (char )'i', 
        (char )'s',      (char )' ',      (char )'p',      (char )'r', 
        (char )'e',      (char )'f',      (char )'i',      (char )'x', 
        (char )'e',      (char )'d',      (char )' ',      (char )'w', 
        (char )'i',      (char )'t',      (char )'h',      (char )' ', 
        (char )'`',      (char )'n',      (char )'o',      (char )'-', 
        (char )'\'',      (char )'.',      (char )' ',      (char )'F', 
        (char )'o',      (char )'r',      (char )' ',      (char )'e', 
        (char )'x',      (char )'a',      (char )'m',      (char )'p', 
        (char )'l',      (char )'e',      (char )',',      (char )' ', 
        (char )'-',      (char )'-',      (char )'n',      (char )'o', 
        (char )'-',      (char )'c',      (char )'p',      (char )'p', 
        (char )' ',      (char )'c',      (char )'a',      (char )'n', 
        (char )'c',      (char )'e',      (char )'l',      (char )'s', 
        (char )' ',      (char )'-',      (char )'-',      (char )'c', 
        (char )'p',      (char )'p',      (char )'.',      (char )'\000'};
#line 31 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/main.c"
char const   *program_authors[2]  = {      "Sergey Poznyakoff",      (char const   *)((void *)0)};
#line 58 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/main.c"
static struct argp_option options[49]  = 
#line 58
  {      {(char const   *)((void *)0), 0, (char const   *)((void *)0), 0, "General options:",
      0}, 
        {"depth", 'd', "NUMBER", 0, "Set the depth at which the flowgraph is cut off",
      1}, 
        {"include", 'i', "CLASSES", 0, "Include specified classes of symbols (see below). Prepend CLASSES with ^ or - to exclude them from the output",
      1}, 
        {"format", 'f', "NAME", 0, "Use given output format NAME. Valid names are `gnu\' (default) and `posix\'",
      1}, 
        {"reverse", 'r', (char const   *)((void *)0), 0, "* Print reverse call tree",
      1}, 
        {"xref", 'x', (char const   *)((void *)0), 0, "Produce cross-reference listing only",
      1}, 
        {"print", 'P', "OPT", 2, "Set printing option to OPT. Valid OPT values are: xref (or cross-ref), tree. Any unambiguous abbreviation of the above is also accepted",
      1}, 
        {"output", 'o', "FILE", 0, "Set output file name (default -, meaning stdout)",
      1}, 
        {(char const   *)((void *)0), 0, (char const   *)((void *)0), 0, "Symbols classes for --include argument",
      2}, 
        {"  x", 0, (char const   *)((void *)0), 40, "all data symbols, both external and static",
      3}, 
        {"  _", 0, (char const   *)((void *)0), 40, "symbols whose names begin with an underscore",
      3}, 
        {"  s", 0, (char const   *)((void *)0), 40, "static symbols", 3}, 
        {"  t", 0, (char const   *)((void *)0), 40, "typedefs (for cross-references only)",
      3}, 
        {(char const   *)((void *)0), 0, (char const   *)((void *)0), 0, "Parser control:",
      10}, 
        {"use-indentation", 'S', (char const   *)((void *)0), 0, "* Rely on indentation",
      11}, 
        {"no-use-indentation", 262, (char const   *)((void *)0), 2, "", 11}, 
        {"ansi", 'a', (char const   *)((void *)0), 0, "* Accept only sources in ANSI C",
      11}, 
        {"no-ansi", 263, (char const   *)((void *)0), 2, "", 11}, 
        {"pushdown", 'p', "NUMBER", 0, "Set initial token stack size to NUMBER", 11}, 
        {"symbol",
      's', "SYMBOL:[=]TYPE", 0, "Register SYMBOL with given TYPE, or define an alias (if := is used). Valid types are: keyword (or kw), modifier, qualifier, identifier, type, wrapper. Any unambiguous abbreviation of the above is also accepted",
      11}, 
        {"main", 'm', "NAME", 0, "Assume main function to be called NAME", 11}, 
        {"define", 'D', "NAME[=DEFN]", 0, "Predefine NAME as a macro", 11}, 
        {"undefine", 'U', "NAME", 0, "Cancel any previous definition of NAME", 11}, 
        {"include-dir", 'I', "DIR", 0, "Add the directory DIR to the list of directories to be searched for header files.",
      11}, 
        {"preprocess", 259, "COMMAND", 1, "* Run the specified preprocessor command",
      11}, 
        {"cpp", 0, (char const   *)((void *)0), 4, (char const   *)((void *)0), 11}, 
        {"no-preprocess", 260, (char const   *)((void *)0), 2, "", 11}, 
        {"no-cpp", 0, (char const   *)((void *)0), 6, (char const   *)((void *)0), 11}, 
        {(char const   *)((void *)0),
      0, (char const   *)((void *)0), 0, "Output control:", 20}, 
        {"number", 'n', (char const   *)((void *)0), 0, "* Print line numbers", 21}, 
        {"no-number", 268, (char const   *)((void *)0), 2, "", 21}, 
        {"print-level", 'l', (char const   *)((void *)0), 0, "* Print nesting level along with the call tree",
      21}, 
        {"no-print-level", 269, (char const   *)((void *)0), 2, "", 21}, 
        {"level-indent", 257, "ELEMENT", 0, "Control graph appearance", 21}, 
        {"tree", 'T', (char const   *)((void *)0), 0, "* Draw ASCII art tree", 21}, 
        {"no-tree", 264, (char const   *)((void *)0), 2, "", 21}, 
        {"brief", 'b', (char const   *)((void *)0), 0, "* Brief output", 21}, 
        {"no-brief", 265, (char const   *)((void *)0), 2, "", 21}, 
        {"emacs", 261, (char const   *)((void *)0), 0, "* Additionally format output for use with GNU Emacs",
      21}, 
        {"no-emacs", 266, (char const   *)((void *)0), 2, "", 21}, 
        {"omit-arguments", 271, (char const   *)((void *)0), 0, "* Do not print argument lists in function declarations",
      21}, 
        {"no-ignore-arguments", 272, (char const   *)((void *)0), 2, "", 21}, 
        {"omit-symbol-names", 273, (char const   *)((void *)0), 0, "* Do not print symbol names in declaration strings",
      21}, 
        {"no-omit-symbol-names", 274, (char const   *)((void *)0), 2, "", 21}, 
        {(char const   *)((void *)0), 0, (char const   *)((void *)0), 0, "Informational options:",
      30}, 
        {"verbose", 'v', (char const   *)((void *)0), 0, "* Verbose error diagnostics",
      31}, 
        {"no-verbose", 267, (char const   *)((void *)0), 2, "", 31}, 
        {"debug", 258, "NUMBER", 1, "Set debugging level", 31}, 
        {(char const   *)0, 0, (char const   *)0, 0, (char const   *)0, 0}};
#line 177 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/main.c"
char *outname  =    (char *)"-";
#line 178 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/main.c"
int print_option  =    0;
#line 211 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/main.c"
int symbol_map  ;
#line 213 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/main.c"
char *level_indent[2]  = {      (char *)((void *)0),      (char *)((void *)0)};
#line 214 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/main.c"
char *level_end[2]  = {      (char *)"",      (char *)""};
#line 215 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/main.c"
char *level_begin  =    (char *)"";
#line 217 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/main.c"
int preprocess_option  =    0;
#line 219 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/main.c"
char *start_name  =    (char *)"main";
#line 221 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/main.c"
struct linked_list *arglist  ;
#line 227 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/main.c"
static int find_option_type(struct option_type *optype , char const   *str , int len ) 
{ 
  size_t tmp ;
  int tmp___0 ;

  {
#line 230
  if (len == 0) {
    {
#line 231
    tmp = strlen(str);
#line 231
    len = (int )tmp;
    }
  }
  {
#line 232
  while (1) {
    while_continue: /* CIL Label */ ;
#line 232
    if (! optype->str) {
#line 232
      goto while_break;
    }
#line 233
    if (len >= optype->min_match) {
      {
#line 233
      tmp___0 = memcmp((void const   *)str, (void const   *)optype->str, (size_t )len);
      }
#line 233
      if (tmp___0 == 0) {
#line 235
        return (optype->type);
      }
    }
#line 232
    optype ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 238
  return (0);
}
}
#line 242 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/main.c"
static struct option_type symbol_optype[8]  = 
#line 242
  {      {(char *)"keyword", 2, 257}, 
        {(char *)"kw", 2, 257}, 
        {(char *)"modifier", 1, 265}, 
        {(char *)"identifier", 1, 260}, 
        {(char *)"type", 1, 270}, 
        {(char *)"wrapper", 1, 272}, 
        {(char *)"qualifier", 1, 273}, 
        {(char *)0, 0, 0}};
#line 257 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/main.c"
static void symbol_override(char const   *str ) 
{ 
  char const   *ptr ;
  char *name ;
  Symbol *sp ;
  char *tmp ;
  char *tmp___0 ;
  Symbol *alias ;
  Symbol *tmp___1 ;
  char *tmp___2 ;
  int type ;
  int tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 264
  tmp = strchr(str, ':');
#line 264
  ptr = (char const   *)tmp;
  }
#line 265
  if (! ptr) {
    {
#line 266
    tmp___0 = gettext("%s: no symbol type supplied");
#line 266
    error(0, 0, (char const   *)tmp___0, str);
    }
#line 267
    return;
  } else {
    {
#line 269
    name = strndup(str, (size_t )(ptr - str));
    }
#line 270
    if ((int const   )*(ptr + 1) == 61) {
      {
#line 271
      tmp___1 = lookup(ptr + 2);
#line 271
      alias = tmp___1;
      }
#line 272
      if (! alias) {
        {
#line 273
        tmp___2 = xstrdup(ptr + 2);
#line 273
        alias = install(tmp___2, 1);
#line 274
        alias->type = (enum symtype )1;
#line 275
        alias->token_type = 0;
#line 276
        alias->source = (char *)((void *)0);
#line 277
        alias->def_line = -1;
#line 278
        alias->ref_line = (struct linked_list *)((void *)0);
        }
      }
      {
#line 280
      sp = install(name, 1);
#line 281
      sp->type = (enum symtype )1;
#line 282
      sp->alias = alias;
#line 283
      sp->flag = (enum symbol_flag )3;
      }
    } else {
      {
#line 285
      tmp___3 = find_option_type(symbol_optype, ptr + 1, 0);
#line 285
      type = tmp___3;
      }
#line 286
      if (type == 0) {
        {
#line 287
        tmp___4 = gettext("unknown symbol type: %s");
#line 287
        error(0, 0, (char const   *)tmp___4, ptr + 1);
        }
#line 288
        return;
      }
      {
#line 290
      sp = install(name, 1);
#line 291
      sp->type = (enum symtype )1;
#line 292
      sp->token_type = type;
      }
    }
#line 294
    sp->source = (char *)((void *)0);
#line 295
    sp->def_line = -1;
#line 296
    sp->ref_line = (struct linked_list *)((void *)0);
  }
#line 298
  return;
}
}
#line 301 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/main.c"
static struct option_type print_optype[4]  = {      {(char *)"xref", 1, 1}, 
        {(char *)"cross-ref", 1, 1}, 
        {(char *)"tree", 1, 2}, 
        {(char *)0, 0, 0}};
#line 308 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/main.c"
static void set_print_option(char *str ) 
{ 
  int opt ;
  char *tmp ;

  {
  {
#line 313
  opt = find_option_type(print_optype, (char const   *)str, 0);
  }
#line 314
  if (opt == 0) {
    {
#line 315
    tmp = gettext("unknown print option: %s");
#line 315
    error(0, 0, (char const   *)tmp, str);
    }
#line 316
    return;
  }
#line 318
  print_option |= opt;
#line 319
  return;
}
}
#line 326 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/main.c"
static int number(char const   **str_ptr , int base , int count ) 
{ 
  int c ;
  int n ;
  unsigned int i ;
  char const   *str ;
  char const   *tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
#line 331
  str = *str_ptr;
#line 333
  n = 0;
  {
#line 333
  while (1) {
    while_continue: /* CIL Label */ ;
#line 333
    if (*str) {
#line 333
      if (! count) {
#line 333
        goto while_break;
      }
    } else {
#line 333
      goto while_break;
    }
    {
#line 334
    tmp = str;
#line 334
    str ++;
#line 334
    c = (int )*tmp;
#line 335
    tmp___1 = __ctype_b_loc();
    }
#line 335
    if ((int const   )*(*tmp___1 + c) & 2048) {
#line 336
      i = (unsigned int )(c - 48);
    } else {
      {
#line 338
      tmp___0 = toupper(c);
#line 338
      i = (unsigned int )((tmp___0 - 65) + 10);
      }
    }
#line 339
    if (i > (unsigned int )base) {
#line 340
      goto while_break;
    }
#line 342
    n = (int )((unsigned int )(n * base) + i);
#line 333
    count --;
  }
  while_break: /* CIL Label */ ;
  }
#line 344
  *str_ptr = str - 1;
#line 345
  return (n);
}
}
#line 370 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/main.c"
static struct option_type level_indent_optype[6]  = {      {(char *)"begin", 1, 1}, 
        {(char *)"start", 1, 1}, 
        {(char *)"0", 1, 2}, 
        {(char *)"1", 1, 3}, 
        {(char *)"end0", 4, 4}, 
        {(char *)"end1", 4, 5}};
#line 382 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/main.c"
static char text[216]  ;
#line 379 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/main.c"
static void parse_level_string(char const   *str , char **return_ptr ) 
{ 
  char *p ;
  int i ;
  int c ;
  int num ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  long tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char const   *tmp___15 ;
  char *tmp___16 ;

  {
  {
#line 386
  p = text;
#line 387
  memset((void *)(text), ' ', sizeof(text));
#line 388
  text[sizeof(text) - 1UL] = (char)0;
  }
  {
#line 390
  while (1) {
    while_continue: /* CIL Label */ ;
#line 390
    if (! *str) {
#line 390
      goto while_break;
    }
    {
#line 392
    if ((int const   )*str == 92) {
#line 392
      goto case_92;
    }
#line 429
    if ((int const   )*str == 120) {
#line 429
      goto case_120___0;
    }
#line 443
    goto copy;
    case_92: /* CIL Label */ 
#line 393
    str ++;
    {
#line 394
    if ((int const   )*str == 97) {
#line 394
      goto case_97;
    }
#line 397
    if ((int const   )*str == 98) {
#line 397
      goto case_98;
    }
#line 400
    if ((int const   )*str == 101) {
#line 400
      goto case_101;
    }
#line 403
    if ((int const   )*str == 102) {
#line 403
      goto case_102;
    }
#line 406
    if ((int const   )*str == 110) {
#line 406
      goto case_110;
    }
#line 409
    if ((int const   )*str == 114) {
#line 409
      goto case_114;
    }
#line 412
    if ((int const   )*str == 116) {
#line 412
      goto case_116;
    }
#line 416
    if ((int const   )*str == 88) {
#line 416
      goto case_88;
    }
#line 416
    if ((int const   )*str == 120) {
#line 416
      goto case_88;
    }
#line 420
    if ((int const   )*str == 48) {
#line 420
      goto case_48;
    }
#line 424
    goto switch_default;
    case_97: /* CIL Label */ 
#line 395
    tmp = p;
#line 395
    p ++;
#line 395
    *tmp = (char )'\a';
#line 396
    goto switch_break___0;
    case_98: /* CIL Label */ 
#line 398
    tmp___0 = p;
#line 398
    p ++;
#line 398
    *tmp___0 = (char )'\b';
#line 399
    goto switch_break___0;
    case_101: /* CIL Label */ 
#line 401
    tmp___1 = p;
#line 401
    p ++;
#line 401
    *tmp___1 = (char )'\033';
#line 402
    goto switch_break___0;
    case_102: /* CIL Label */ 
#line 404
    tmp___2 = p;
#line 404
    p ++;
#line 404
    *tmp___2 = (char )'\f';
#line 405
    goto switch_break___0;
    case_110: /* CIL Label */ 
#line 407
    tmp___3 = p;
#line 407
    p ++;
#line 407
    *tmp___3 = (char )'\n';
#line 408
    goto switch_break___0;
    case_114: /* CIL Label */ 
#line 410
    tmp___4 = p;
#line 410
    p ++;
#line 410
    *tmp___4 = (char )'\r';
#line 411
    goto switch_break___0;
    case_116: /* CIL Label */ 
#line 413
    tmp___5 = p;
#line 413
    p ++;
#line 413
    *tmp___5 = (char )'\t';
#line 414
    goto switch_break___0;
    case_88: /* CIL Label */ 
    case_120: /* CIL Label */ 
    {
#line 417
    str ++;
#line 418
    tmp___6 = p;
#line 418
    p ++;
#line 418
    tmp___7 = number(& str, 16, 2);
#line 418
    *tmp___6 = (char )tmp___7;
    }
#line 419
    goto switch_break___0;
    case_48: /* CIL Label */ 
    {
#line 421
    str ++;
#line 422
    tmp___8 = p;
#line 422
    p ++;
#line 422
    tmp___9 = number(& str, 8, 3);
#line 422
    *tmp___8 = (char )tmp___9;
    }
#line 423
    goto switch_break___0;
    switch_default: /* CIL Label */ 
#line 425
    tmp___10 = p;
#line 425
    p ++;
#line 425
    *tmp___10 = (char )*str;
    switch_break___0: /* CIL Label */ ;
    }
#line 427
    str ++;
#line 428
    goto switch_break;
    case_120___0: /* CIL Label */ 
#line 430
    if ((unsigned long )p == (unsigned long )(text)) {
#line 431
      goto copy;
    }
    {
#line 433
    tmp___11 = strtol((char const   */* __restrict  */)(str + 1), (char **/* __restrict  */)((char **)(& str)),
                      10);
#line 433
    num = (int )tmp___11;
#line 434
    c = (int )*(p + -1);
#line 435
    i = 1;
    }
    {
#line 435
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 435
      if (! (i < num)) {
#line 435
        goto while_break___0;
      }
#line 436
      tmp___12 = p;
#line 436
      p ++;
#line 436
      *tmp___12 = (char )c;
#line 437
      if ((int )*p == 0) {
        {
#line 438
        tmp___13 = gettext("level indent string is too long");
#line 438
        error(1, 0, (char const   *)tmp___13);
        }
#line 439
        return;
      }
#line 435
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 442
    goto switch_break;
    copy: 
    switch_default___0: /* CIL Label */ 
#line 445
    tmp___14 = p;
#line 445
    p ++;
#line 445
    tmp___15 = str;
#line 445
    str ++;
#line 445
    *tmp___14 = (char )*tmp___15;
#line 446
    if ((int )*p == 0) {
      {
#line 447
      tmp___16 = gettext("level indent string is too long");
#line 447
      error(1, 0, (char const   *)tmp___16);
      }
#line 448
      return;
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 452
  *p = (char)0;
#line 453
  *return_ptr = strdup((char const   *)(text));
  }
#line 454
  return;
}
}
#line 456 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/main.c"
static void set_level_indent(char const   *str ) 
{ 
  long n ;
  char const   *p ;
  char *q ;
  char *s ;
  void *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 463
  n = strtol((char const   */* __restrict  */)str, (char **/* __restrict  */)(& q),
             0);
  }
#line 464
  if ((int )*q == 0) {
#line 464
    if (n > 0L) {
      {
#line 465
      tmp = xmalloc((size_t )(n + 1L));
#line 465
      s = (char *)tmp;
#line 466
      memset((void *)s, ' ', (size_t )(n - 1L));
#line 467
      *(s + (n - 1L)) = (char)0;
#line 468
      level_indent[1] = s;
#line 468
      level_indent[0] = level_indent[1];
      }
#line 469
      return;
    }
  }
#line 472
  p = str;
  {
#line 473
  while (1) {
    while_continue: /* CIL Label */ ;
#line 473
    if (! ((int const   )*p != 61)) {
#line 473
      goto while_break;
    }
#line 474
    if ((int const   )*p == 0) {
      {
#line 475
      tmp___0 = gettext("level-indent syntax");
#line 475
      error(1, 0, (char const   *)tmp___0);
      }
#line 476
      return;
    }
#line 478
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 480
  p ++;
#line 482
  tmp___1 = find_option_type(level_indent_optype, str, (int )((p - str) - 1L));
  }
  {
#line 483
  if (tmp___1 == 1) {
#line 483
    goto case_1;
  }
#line 486
  if (tmp___1 == 2) {
#line 486
    goto case_2;
  }
#line 489
  if (tmp___1 == 3) {
#line 489
    goto case_3;
  }
#line 492
  if (tmp___1 == 4) {
#line 492
    goto case_4;
  }
#line 495
  if (tmp___1 == 5) {
#line 495
    goto case_5;
  }
#line 498
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 484
  parse_level_string(p, & level_begin);
  }
#line 485
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 487
  parse_level_string(p, & level_indent[0]);
  }
#line 488
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 490
  parse_level_string(p, & level_indent[1]);
  }
#line 491
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 493
  parse_level_string(p, & level_end[0]);
  }
#line 494
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 496
  parse_level_string(p, & level_end[1]);
  }
#line 497
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 499
  tmp___2 = gettext("unknown level indent option: %s");
#line 499
  error(1, 0, (char const   *)tmp___2, str);
  }
  switch_break: /* CIL Label */ ;
  }
#line 501
  return;
}
}
#line 503 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/main.c"
static void add_name(char const   *name ) 
{ 


  {
  {
#line 506
  linked_list_append(& arglist, (void *)name);
  }
#line 507
  return;
}
}
#line 509 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/main.c"
static void add_preproc_option(int key , char const   *arg___0 ) 
{ 
  char *opt ;
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 512
  tmp = strlen(arg___0);
#line 512
  tmp___0 = xmalloc(3UL + tmp);
#line 512
  opt = (char *)tmp___0;
#line 513
  sprintf((char */* __restrict  */)opt, (char const   */* __restrict  */)"-%c%s",
          key, arg___0);
#line 514
  add_name((char const   *)opt);
#line 515
  preprocess_option = 1;
  }
#line 516
  return;
}
}
#line 518 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/main.c"
static error_t parse_opt(int key , char *arg___0 , struct argp_state *state ) 
{ 
  int num ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  char const   *tmp___13 ;

  {
  {
#line 524
  if (key == 97) {
#line 524
    goto case_97;
  }
#line 527
  if (key == 263) {
#line 527
    goto case_263;
  }
#line 530
  if (key == 258) {
#line 530
    goto case_258;
  }
#line 533
  if (key == 80) {
#line 533
    goto case_80;
  }
#line 536
  if (key == 83) {
#line 536
    goto case_83;
  }
#line 539
  if (key == 262) {
#line 539
    goto case_262;
  }
#line 542
  if (key == 84) {
#line 542
    goto case_84;
  }
#line 549
  if (key == 264) {
#line 549
    goto case_264;
  }
#line 554
  if (key == 98) {
#line 554
    goto case_98;
  }
#line 557
  if (key == 265) {
#line 557
    goto case_265;
  }
#line 560
  if (key == 100) {
#line 560
    goto case_100;
  }
#line 565
  if (key == 256) {
#line 565
    goto case_256;
  }
#line 568
  if (key == 261) {
#line 568
    goto case_261;
  }
#line 571
  if (key == 266) {
#line 571
    goto case_266;
  }
#line 574
  if (key == 102) {
#line 574
    goto case_102;
  }
#line 579
  if (key == 257) {
#line 579
    goto case_257;
  }
#line 582
  if (key == 105) {
#line 582
    goto case_105;
  }
#line 607
  if (key == 271) {
#line 607
    goto case_271;
  }
#line 610
  if (key == 272) {
#line 610
    goto case_272;
  }
#line 613
  if (key == 273) {
#line 613
    goto case_273;
  }
#line 616
  if (key == 274) {
#line 616
    goto case_274;
  }
#line 619
  if (key == 108) {
#line 619
    goto case_108;
  }
#line 622
  if (key == 269) {
#line 622
    goto case_269;
  }
#line 625
  if (key == 109) {
#line 625
    goto case_109;
  }
#line 628
  if (key == 110) {
#line 628
    goto case_110;
  }
#line 631
  if (key == 268) {
#line 631
    goto case_268;
  }
#line 634
  if (key == 111) {
#line 634
    goto case_111;
  }
#line 637
  if (key == 112) {
#line 637
    goto case_112;
  }
#line 642
  if (key == 114) {
#line 642
    goto case_114;
  }
#line 645
  if (key == 270) {
#line 645
    goto case_270;
  }
#line 648
  if (key == 115) {
#line 648
    goto case_115___0;
  }
#line 651
  if (key == 118) {
#line 651
    goto case_118;
  }
#line 654
  if (key == 267) {
#line 654
    goto case_267;
  }
#line 657
  if (key == 120) {
#line 657
    goto case_120___0;
  }
#line 660
  if (key == 259) {
#line 660
    goto case_259;
  }
#line 664
  if (key == 260) {
#line 664
    goto case_260;
  }
#line 667
  if (key == 0) {
#line 667
    goto case_0;
  }
#line 672
  if (key == 85) {
#line 672
    goto case_85;
  }
#line 672
  if (key == 68) {
#line 672
    goto case_85;
  }
#line 672
  if (key == 73) {
#line 672
    goto case_85;
  }
#line 675
  goto switch_default___0;
  case_97: /* CIL Label */ 
#line 525
  strict_ansi = 1;
#line 526
  goto switch_break;
  case_263: /* CIL Label */ 
#line 528
  strict_ansi = 0;
#line 529
  goto switch_break;
  case_258: /* CIL Label */ 
#line 531
  if (arg___0) {
    {
#line 531
    tmp = atoi((char const   *)arg___0);
#line 531
    debug = tmp;
    }
  } else {
#line 531
    debug = 1;
  }
#line 532
  goto switch_break;
  case_80: /* CIL Label */ 
  {
#line 534
  set_print_option(arg___0);
  }
#line 535
  goto switch_break;
  case_83: /* CIL Label */ 
#line 537
  use_indentation = 1;
#line 538
  goto switch_break;
  case_262: /* CIL Label */ 
#line 540
  use_indentation = 0;
#line 541
  goto switch_break;
  case_84: /* CIL Label */ 
  {
#line 543
  print_as_tree = 1;
#line 544
  set_level_indent("0=  ");
#line 545
  set_level_indent("1=| ");
#line 546
  set_level_indent("end0=+-");
#line 547
  set_level_indent("end1=\\\\-");
  }
#line 548
  goto switch_break;
  case_264: /* CIL Label */ 
#line 550
  print_as_tree = 0;
#line 551
  level_indent[1] = (char *)((void *)0);
#line 551
  level_indent[0] = level_indent[1];
#line 552
  level_end[0] = (char *)((void *)0);
#line 552
  level_end[0] = level_end[0];
#line 553
  goto switch_break;
  case_98: /* CIL Label */ 
#line 555
  brief_listing = 1;
#line 556
  goto switch_break;
  case_265: /* CIL Label */ 
#line 558
  brief_listing = 0;
#line 559
  goto switch_break;
  case_100: /* CIL Label */ 
  {
#line 561
  max_depth = atoi((char const   *)arg___0);
  }
#line 562
  if (max_depth < 0) {
#line 563
    max_depth = 0;
  }
#line 564
  goto switch_break;
  case_256: /* CIL Label */ 
#line 566
  record_defines = 1;
#line 567
  goto switch_break;
  case_261: /* CIL Label */ 
#line 569
  emacs_option = 1;
#line 570
  goto switch_break;
  case_266: /* CIL Label */ 
#line 572
  emacs_option = 0;
#line 573
  goto switch_break;
  case_102: /* CIL Label */ 
  {
#line 575
  tmp___1 = select_output_driver((char const   *)arg___0);
  }
#line 575
  if (tmp___1) {
    {
#line 576
    tmp___0 = gettext("%s: No such output driver");
#line 576
    argp_error((struct argp_state  const  */* __restrict  */)state, (char const   */* __restrict  */)tmp___0,
               rpl_optarg);
    }
  }
  {
#line 577
  output_init();
  }
#line 578
  goto switch_break;
  case_257: /* CIL Label */ 
  {
#line 580
  set_level_indent((char const   *)arg___0);
  }
#line 581
  goto switch_break;
  case_105: /* CIL Label */ 
#line 583
  num = 1;
  {
#line 584
  while (1) {
    while_continue: /* CIL Label */ ;
#line 584
    if (! *arg___0) {
#line 584
      goto while_break;
    }
    {
#line 587
    if ((int )*arg___0 == 94) {
#line 587
      goto case_94;
    }
#line 587
    if ((int )*arg___0 == 45) {
#line 587
      goto case_94;
    }
#line 590
    if ((int )*arg___0 == 43) {
#line 590
      goto case_43;
    }
#line 597
    if ((int )*arg___0 == 117) {
#line 597
      goto case_117;
    }
#line 597
    if ((int )*arg___0 == 116) {
#line 597
      goto case_117;
    }
#line 597
    if ((int )*arg___0 == 115) {
#line 597
      goto case_117;
    }
#line 597
    if ((int )*arg___0 == 95) {
#line 597
      goto case_117;
    }
#line 597
    if ((int )*arg___0 == 120) {
#line 597
      goto case_117;
    }
#line 603
    goto switch_default;
    case_94: /* CIL Label */ 
    case_45: /* CIL Label */ 
#line 588
    num = 0;
#line 589
    goto switch_break___0;
    case_43: /* CIL Label */ 
#line 591
    num = 1;
#line 592
    goto switch_break___0;
    case_117: /* CIL Label */ 
    case_116: /* CIL Label */ 
    case_115: /* CIL Label */ 
    case_95: /* CIL Label */ 
    case_120: /* CIL Label */ 
#line 598
    if (num) {
#line 599
      if ((int )*arg___0 == 120) {
#line 599
        tmp___6 = 2;
      } else {
#line 599
        if ((int )*arg___0 == 95) {
#line 599
          tmp___5 = 8;
        } else {
#line 599
          if ((int )*arg___0 == 115) {
#line 599
            tmp___4 = 4;
          } else {
#line 599
            if ((int )*arg___0 == 116) {
#line 599
              tmp___3 = 16;
            } else {
#line 599
              if ((int )*arg___0 == 117) {
#line 599
                tmp___2 = 32;
              } else {
#line 599
                tmp___2 = 0;
              }
#line 599
              tmp___3 = tmp___2;
            }
#line 599
            tmp___4 = tmp___3;
          }
#line 599
          tmp___5 = tmp___4;
        }
#line 599
        tmp___6 = tmp___5;
      }
#line 599
      symbol_map |= tmp___6;
    } else {
#line 601
      if ((int )*arg___0 == 120) {
#line 601
        tmp___11 = 2;
      } else {
#line 601
        if ((int )*arg___0 == 95) {
#line 601
          tmp___10 = 8;
        } else {
#line 601
          if ((int )*arg___0 == 115) {
#line 601
            tmp___9 = 4;
          } else {
#line 601
            if ((int )*arg___0 == 116) {
#line 601
              tmp___8 = 16;
            } else {
#line 601
              if ((int )*arg___0 == 117) {
#line 601
                tmp___7 = 32;
              } else {
#line 601
                tmp___7 = 0;
              }
#line 601
              tmp___8 = tmp___7;
            }
#line 601
            tmp___9 = tmp___8;
          }
#line 601
          tmp___10 = tmp___9;
        }
#line 601
        tmp___11 = tmp___10;
      }
#line 601
      symbol_map &= ~ tmp___11;
    }
#line 602
    goto switch_break___0;
    switch_default: /* CIL Label */ 
    {
#line 604
    tmp___12 = gettext("Unknown symbol class: %c");
#line 604
    argp_error((struct argp_state  const  */* __restrict  */)state, (char const   */* __restrict  */)tmp___12,
               (int )*arg___0);
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 584
    arg___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 606
  goto switch_break;
  case_271: /* CIL Label */ 
#line 608
  omit_arguments_option = 1;
#line 609
  goto switch_break;
  case_272: /* CIL Label */ 
#line 611
  omit_arguments_option = 0;
#line 612
  goto switch_break;
  case_273: /* CIL Label */ 
#line 614
  omit_symbol_names_option = 1;
#line 615
  goto switch_break;
  case_274: /* CIL Label */ 
#line 617
  omit_symbol_names_option = 0;
#line 618
  goto switch_break;
  case_108: /* CIL Label */ 
#line 620
  print_levels = 1;
#line 621
  goto switch_break;
  case_269: /* CIL Label */ 
#line 623
  print_levels = 0;
#line 624
  goto switch_break;
  case_109: /* CIL Label */ 
  {
#line 626
  start_name = strdup((char const   *)arg___0);
  }
#line 627
  goto switch_break;
  case_110: /* CIL Label */ 
#line 629
  print_line_numbers = 1;
#line 630
  goto switch_break;
  case_268: /* CIL Label */ 
#line 632
  print_line_numbers = 0;
#line 633
  goto switch_break;
  case_111: /* CIL Label */ 
  {
#line 635
  outname = strdup((char const   *)arg___0);
  }
#line 636
  goto switch_break;
  case_112: /* CIL Label */ 
  {
#line 638
  num = atoi((char const   *)arg___0);
  }
#line 639
  if (num > 0) {
#line 640
    token_stack_length = num;
  }
#line 641
  goto switch_break;
  case_114: /* CIL Label */ 
#line 643
  reverse_tree = 1;
#line 644
  goto switch_break;
  case_270: /* CIL Label */ 
#line 646
  reverse_tree = 0;
#line 647
  goto switch_break;
  case_115___0: /* CIL Label */ 
  {
#line 649
  symbol_override((char const   *)arg___0);
  }
#line 650
  goto switch_break;
  case_118: /* CIL Label */ 
#line 652
  verbose = 1;
#line 653
  goto switch_break;
  case_267: /* CIL Label */ 
#line 655
  verbose = 0;
#line 656
  goto switch_break;
  case_120___0: /* CIL Label */ 
#line 658
  print_option = 1;
#line 659
  goto switch_break;
  case_259: /* CIL Label */ 
#line 661
  preprocess_option = 1;
#line 662
  if (arg___0) {
#line 662
    tmp___13 = (char const   *)arg___0;
  } else {
#line 662
    tmp___13 = "/usr/bin/cpp";
  }
  {
#line 662
  set_preprocessor(tmp___13);
  }
#line 663
  goto switch_break;
  case_260: /* CIL Label */ 
#line 665
  preprocess_option = 0;
#line 666
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 668
  add_name((char const   *)arg___0);
  }
#line 669
  goto switch_break;
  case_85: /* CIL Label */ 
  case_68: /* CIL Label */ 
  case_73: /* CIL Label */ 
  {
#line 673
  add_preproc_option(key, (char const   *)arg___0);
  }
#line 674
  goto switch_break;
  switch_default___0: /* CIL Label */ 
#line 676
  return (7);
  switch_break: /* CIL Label */ ;
  }
#line 678
  return (0);
}
}
#line 681 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/main.c"
static struct argp argp  =    {(struct argp_option  const  *)(options), & parse_opt, "[FILE]...", (char const   *)(doc),
    (struct argp_child  const  *)((void *)0), (char *(*)(int __key , char const   *__text ,
                                                         void *__input ))((void *)0),
    (char const   *)((void *)0)};
#line 691 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/main.c"
int globals_only(void) 
{ 


  {
#line 694
  return (! (symbol_map & 4));
}
}
#line 697 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/main.c"
int include_symbol(Symbol *sym ) 
{ 
  int type ;

  {
#line 700
  type = 0;
#line 702
  if (! sym) {
#line 703
    return (0);
  }
#line 705
  if ((unsigned int )sym->type == 2U) {
#line 706
    if ((int )*(sym->name + 0) == 95) {
#line 706
      if (! (symbol_map & 8)) {
#line 707
        return (0);
      }
    }
#line 709
    if ((unsigned int )sym->storage == 2U) {
#line 710
      type |= 4;
    }
#line 711
    if (sym->arity == -1) {
#line 711
      if ((unsigned int )sym->storage != 3U) {
#line 712
        type |= 2;
      } else {
#line 711
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 713
    if (sym->arity >= 0) {
#line 714
      type |= 1;
    }
#line 716
    if (! sym->source) {
#line 717
      type |= 32;
    }
  } else
#line 719
  if ((unsigned int )sym->type == 1U) {
#line 720
    if (sym->token_type == 270) {
#line 720
      if (sym->source) {
#line 721
        type |= 16;
      } else {
#line 723
        return (0);
      }
    } else {
#line 723
      return (0);
    }
  }
#line 725
  return ((symbol_map & type) == type);
}
}
#line 728
 __attribute__((__noreturn__)) void xalloc_die(void) ;
#line 728 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/main.c"
void xalloc_die(void) 
{ 
  char *tmp ;

  {
  {
#line 731
  tmp = gettext("Exiting");
#line 731
  error(1, 12, (char const   *)tmp);
  }
}
}
#line 734 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/main.c"
void init(void) 
{ 


  {
#line 737
  if ((unsigned long )level_indent[0] == (unsigned long )((void *)0)) {
#line 738
    level_indent[0] = (char *)"    ";
  }
#line 739
  if ((unsigned long )level_indent[1] == (unsigned long )((void *)0)) {
#line 740
    level_indent[1] = level_indent[0];
  }
#line 741
  if ((unsigned long )level_end[0] == (unsigned long )((void *)0)) {
#line 742
    level_end[0] = (char *)"";
  }
#line 743
  if ((unsigned long )level_end[1] == (unsigned long )((void *)0)) {
#line 744
    level_end[1] = (char *)"";
  }
  {
#line 746
  init_lex(debug > 1);
#line 747
  init_parse();
  }
#line 748
  return;
}
}
#line 750 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/main.c"
char const   version_etc_copyright[63]  = 
#line 750
  {      (char const   )'C',      (char const   )'o',      (char const   )'p',      (char const   )'y', 
        (char const   )'r',      (char const   )'i',      (char const   )'g',      (char const   )'h', 
        (char const   )'t',      (char const   )' ',      (char const   )'%',      (char const   )'s', 
        (char const   )' ',      (char const   )'2',      (char const   )'0',      (char const   )'0', 
        (char const   )'5',      (char const   )',',      (char const   )' ',      (char const   )'2', 
        (char const   )'0',      (char const   )'0',      (char const   )'6',      (char const   )',', 
        (char const   )' ',      (char const   )'2',      (char const   )'0',      (char const   )'0', 
        (char const   )'9',      (char const   )',',      (char const   )' ',      (char const   )'2', 
        (char const   )'0',      (char const   )'1',      (char const   )'0',      (char const   )',', 
        (char const   )' ',      (char const   )'2',      (char const   )'0',      (char const   )'1', 
        (char const   )'1',      (char const   )' ',      (char const   )'%',      (char const   )'d', 
        (char const   )' ',      (char const   )'S',      (char const   )'e',      (char const   )'r', 
        (char const   )'g',      (char const   )'e',      (char const   )'y',      (char const   )' ', 
        (char const   )'P',      (char const   )'o',      (char const   )'z',      (char const   )'n', 
        (char const   )'y',      (char const   )'a',      (char const   )'k',      (char const   )'o', 
        (char const   )'f',      (char const   )'f',      (char const   )'\000'};
#line 756 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/main.c"
int main(int argc , char **argv ) 
{ 
  int index___0 ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  error_t tmp___2 ;
  struct linked_list_entry *p ;
  char *s ;
  int tmp___3 ;
  char **tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;

  {
  {
#line 761
  set_program_name((char const   *)*(argv + 0));
#line 762
  argp_version_setup("cflow", (char const   * const  *)(program_authors));
#line 764
  setlocale(6, "");
#line 765
  bindtextdomain("cflow", "/usr/local/share/locale");
#line 766
  textdomain("cflow");
#line 768
  register_output("gnu", & gnu_output_handler, (void *)0);
#line 769
  register_output("posix", & posix_output_handler, (void *)0);
#line 771
  symbol_map = 37;
#line 773
  tmp___1 = getenv("POSIXLY_CORRECT");
  }
#line 773
  if (tmp___1) {
    {
#line 774
    tmp___0 = select_output_driver("posix");
    }
#line 774
    if (tmp___0) {
      {
#line 775
      tmp = gettext("%s: No such output driver");
#line 775
      error(1, 0, (char const   *)tmp, "posix");
      }
    }
    {
#line 776
    output_init();
    }
  }
  {
#line 779
  sourcerc(& argc, & argv);
#line 780
  tmp___2 = argp_parse((struct argp  const  */* __restrict  */)(& argp), argc, (char **/* __restrict  */)argv,
                       8U, (int */* __restrict  */)(& index___0), (void */* __restrict  */)((void *)0));
  }
#line 780
  if (tmp___2) {
    {
#line 781
    exit(1);
    }
  }
#line 783
  if (print_option == 0) {
#line 784
    print_option = 2;
  }
  {
#line 786
  init();
  }
#line 788
  if (arglist) {
#line 791
    p = arglist->head;
    {
#line 791
    while (1) {
      while_continue: /* CIL Label */ ;
#line 791
      if (! p) {
#line 791
        goto while_break;
      }
#line 792
      s = (char *)p->data;
#line 793
      if ((int )*(s + 0) == 45) {
        {
#line 794
        pp_option((char const   *)s);
        }
      } else {
        {
#line 795
        tmp___3 = source(s);
        }
#line 795
        if (tmp___3 == 0) {
          {
#line 796
          yyparse();
          }
        }
      }
#line 791
      p = p->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 800
  argc -= index___0;
#line 801
  argv += index___0;
  {
#line 803
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 803
    tmp___6 = argc;
#line 803
    argc --;
#line 803
    if (! tmp___6) {
#line 803
      goto while_break___0;
    }
    {
#line 804
    tmp___4 = argv;
#line 804
    argv ++;
#line 804
    tmp___5 = source(*tmp___4);
    }
#line 804
    if (tmp___5 == 0) {
      {
#line 805
      yyparse();
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 808
  if (input_file_count == 0U) {
    {
#line 809
    tmp___7 = gettext("no input files");
#line 809
    error(1, 0, (char const   *)tmp___7);
    }
  }
  {
#line 811
  output();
  }
#line 812
  return (0);
}
}
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 444 "/usr/include/unistd.h"
extern unsigned int sleep(unsigned int __seconds ) ;
#line 123 "./getopt_int.h"
extern int _getopt_long_r(int ___argc , char **___argv , char const   *__shortopts ,
                          struct rpl_option  const  *__longopts , int *__longind ,
                          struct _getopt_data *__data ) ;
#line 128
extern int _getopt_long_only_r(int ___argc , char **___argv , char const   *__shortopts ,
                               struct rpl_option  const  *__longopts , int *__longind ,
                               struct _getopt_data *__data ) ;
#line 44 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) dgettext)(char const   *__domainname ,
                                                                                 char const   *__msgid )  __attribute__((__format_arg__(2))) ;
#line 54 "/usr/include/errno.h"
extern char *program_invocation_name ;
#line 54
extern char *program_invocation_short_name ;
#line 447 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp.h"
extern char const   *argp_program_version ;
#line 454
extern void (*argp_program_version_hook)(FILE * __restrict  __stream , struct argp_state * __restrict  __state ) ;
#line 518
void argp_state_help(struct argp_state  const  * __restrict  state , FILE * __restrict  stream ,
                     unsigned int flags ) ;
#line 560
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) _option_is_short)(struct argp_option  const  *__opt ) ;
#line 565
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) _option_is_end)(struct argp_option  const  *__opt ) ;
#line 571
 __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) _argp_input)(struct argp  const  * __restrict  argp___0 ,
                                                                             struct argp_state  const  * __restrict  state ) ;
#line 75 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-parse.c"
static int volatile   _argp_hang  ;
#line 81 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-parse.c"
static struct argp_option  const  argp_default_options[5]  = {      {"help", '?', (char const   *)0, 0, "give this help list", -1}, 
        {"usage", -3, (char const   *)0, 0, "give a short usage message", 0}, 
        {"program-name", -2, "NAME", 2, "set the program name", 0}, 
        {"HANG", -4, "SECS", 3, "hang for SECS seconds (default 3600)", 0}, 
        {(char const   *)((void *)0), 0, (char const   *)0, 0, (char const   *)((void *)0),
      0}};
#line 91 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-parse.c"
static error_t argp_default_parser(int key , char *arg___0 , struct argp_state *state ) 
{ 
  char const   *tmp ;
  int tmp___0 ;
  int volatile   tmp___1 ;

  {
  {
#line 96
  if (key == 63) {
#line 96
    goto case_63;
  }
#line 99
  if (key == -3) {
#line 99
    goto case_neg_3;
  }
#line 104
  if (key == -2) {
#line 104
    goto case_neg_2;
  }
#line 126
  if (key == -4) {
#line 126
    goto case_neg_4;
  }
#line 132
  goto switch_default;
  case_63: /* CIL Label */ 
  {
#line 97
  argp_state_help((struct argp_state  const  */* __restrict  */)state, (FILE */* __restrict  */)state->out_stream,
                  634U);
  }
#line 98
  goto switch_break;
  case_neg_3: /* CIL Label */ 
  {
#line 100
  argp_state_help((struct argp_state  const  */* __restrict  */)state, (FILE */* __restrict  */)state->out_stream,
                  513U);
  }
#line 102
  goto switch_break;
  case_neg_2: /* CIL Label */ 
  {
#line 106
  program_invocation_name = arg___0;
#line 113
  state->name = last_component((char const   *)arg___0);
#line 116
  program_invocation_short_name = state->name;
  }
#line 119
  if ((state->flags & 3U) == 1U) {
#line 122
    *(state->argv + 0) = arg___0;
  }
#line 124
  goto switch_break;
  case_neg_4: /* CIL Label */ 
#line 127
  if (arg___0) {
#line 127
    tmp = (char const   *)arg___0;
  } else {
#line 127
    tmp = "3600";
  }
  {
#line 127
  tmp___0 = atoi(tmp);
#line 127
  _argp_hang = (int volatile   )tmp___0;
  }
  {
#line 128
  while (1) {
    while_continue: /* CIL Label */ ;
#line 128
    tmp___1 = _argp_hang;
#line 128
    _argp_hang -= (int volatile   )1;
#line 128
    if (! (tmp___1 > (int volatile   )0)) {
#line 128
      goto while_break;
    }
    {
#line 129
    sleep(1U);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 130
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 133
  return (7);
  switch_break: /* CIL Label */ ;
  }
#line 135
  return (0);
}
}
#line 138 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-parse.c"
static struct argp  const  argp_default_argp  =    {argp_default_options, & argp_default_parser, (char const   *)((void *)0), (char const   *)((void *)0),
    (struct argp_child  const  *)((void *)0), (char *(*)(int __key , char const   *__text ,
                                                         void *__input ))((void *)0),
    "libc"};
#line 142 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-parse.c"
static struct argp_option  const  argp_version_options[2]  = {      {"version", 'V', (char const   *)0, 0, "print program version", -1}, 
        {(char const   *)((void *)0), 0, (char const   *)0, 0, (char const   *)((void *)0),
      0}};
#line 148 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-parse.c"
static error_t argp_version_parser(int key , char *arg___0 , struct argp_state *state ) 
{ 
  char *tmp ;

  {
  {
#line 153
  if (key == 86) {
#line 153
    goto case_86;
  }
#line 164
  goto switch_default;
  case_86: /* CIL Label */ 
#line 154
  if (argp_program_version_hook) {
    {
#line 155
    (*argp_program_version_hook)((FILE */* __restrict  */)state->out_stream, (struct argp_state */* __restrict  */)state);
    }
  } else
#line 156
  if (argp_program_version) {
    {
#line 157
    fprintf((FILE */* __restrict  */)state->out_stream, (char const   */* __restrict  */)"%s\n",
            argp_program_version);
    }
  } else {
    {
#line 159
    tmp = dgettext((char const   *)(state->root_argp)->argp_domain, "(PROGRAM ERROR) No version known!?");
#line 159
    argp_error((struct argp_state  const  */* __restrict  */)state, (char const   */* __restrict  */)tmp);
    }
  }
#line 161
  if (! (state->flags & 32U)) {
    {
#line 162
    exit(0);
    }
  }
#line 163
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 165
  return (7);
  switch_break: /* CIL Label */ ;
  }
#line 167
  return (0);
}
}
#line 170 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-parse.c"
static struct argp  const  argp_version_argp  =    {argp_version_options, & argp_version_parser, (char const   *)((void *)0), (char const   *)((void *)0),
    (struct argp_child  const  *)((void *)0), (char *(*)(int __key , char const   *__text ,
                                                         void *__input ))((void *)0),
    "libc"};
#line 176 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-parse.c"
static int find_long_option(struct rpl_option *long_options , char const   *name ) 
{ 
  struct rpl_option *l ;
  int tmp ;

  {
#line 179
  l = long_options;
  {
#line 180
  while (1) {
    while_continue: /* CIL Label */ ;
#line 180
    if (! ((unsigned long )l->name != (unsigned long )((void *)0))) {
#line 180
      goto while_break;
    }
#line 181
    if ((unsigned long )name != (unsigned long )((void *)0)) {
      {
#line 181
      tmp = strcmp(l->name, name);
      }
#line 181
      if (tmp == 0) {
#line 182
        return ((int )(l - long_options));
      } else {
#line 184
        l ++;
      }
    } else {
#line 184
      l ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 185
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 186
    return ((int )(l - long_options));
  } else {
#line 188
    return (-1);
  }
}
}
#line 224 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-parse.c"
static error_t group_parse(struct group *group , struct argp_state *state , int key ,
                           char *arg___0 ) 
{ 
  error_t err ;

  {
#line 227
  if (group->parser) {
    {
#line 230
    state->hook = group->hook;
#line 231
    state->input = group->input;
#line 232
    state->child_inputs = group->child_inputs;
#line 233
    state->arg_num = group->args_processed;
#line 234
    err = (*(group->parser))(key, arg___0, state);
#line 235
    group->hook = state->hook;
    }
#line 236
    return (err);
  } else {
#line 239
    return (7);
  }
}
}
#line 289 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-parse.c"
static struct group *convert_options(struct argp  const  *argp___0 , struct group *parent ,
                                     unsigned int parent_index , struct group *group ,
                                     struct parser_convert_state *cvt ) 
{ 
  struct argp_option  const  *real ;
  struct argp_child  const  *children ;
  struct argp_option  const  *opt ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  unsigned int num_children ;
  struct group *tmp___6 ;
  unsigned int index___0 ;
  unsigned int tmp___7 ;
  struct argp_child  const  *tmp___8 ;

  {
#line 295
  real = (struct argp_option  const  *)argp___0->options;
#line 296
  children = (struct argp_child  const  *)argp___0->children;
#line 298
  if (real) {
#line 298
    goto _L;
  } else
#line 298
  if (argp___0->parser) {
    _L: /* CIL Label */ 
#line 302
    if (real) {
#line 303
      opt = real;
      {
#line 303
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 303
        tmp___5 = _option_is_end(opt);
        }
#line 303
        if (tmp___5) {
#line 303
          goto while_break;
        }
#line 305
        if (! (opt->flags & 4)) {
#line 307
          real = opt;
        }
#line 309
        if (! (real->flags & 8)) {
          {
#line 312
          tmp___2 = _option_is_short(opt);
          }
#line 312
          if (tmp___2) {
#line 315
            tmp = cvt->short_end;
#line 315
            (cvt->short_end) ++;
#line 315
            *tmp = (char )opt->key;
#line 316
            if (real->arg) {
#line 318
              tmp___0 = cvt->short_end;
#line 318
              (cvt->short_end) ++;
#line 318
              *tmp___0 = (char )':';
#line 319
              if (real->flags & 1) {
#line 320
                tmp___1 = cvt->short_end;
#line 320
                (cvt->short_end) ++;
#line 320
                *tmp___1 = (char )':';
              }
            }
#line 322
            *(cvt->short_end) = (char )'\000';
          }
#line 325
          if (opt->name) {
            {
#line 325
            tmp___4 = find_long_option((cvt->parser)->long_opts, (char const   *)opt->name);
            }
#line 325
            if (tmp___4 < 0) {
#line 329
              (cvt->long_end)->name = (char const   *)opt->name;
#line 330
              if (real->arg) {
#line 330
                if (real->flags & 1) {
#line 330
                  tmp___3 = 2;
                } else {
#line 330
                  tmp___3 = 1;
                }
#line 330
                (cvt->long_end)->has_arg = tmp___3;
              } else {
#line 330
                (cvt->long_end)->has_arg = 0;
              }
#line 336
              (cvt->long_end)->flag = (int *)0;
#line 343
              (cvt->long_end)->val = (int )((long )((opt->key | real->key) & (int const   )((1 << (sizeof(((struct rpl_option *)0)->val) * 8UL - 8UL)) - 1)) + (((group - (cvt->parser)->groups) + 1L) << (sizeof(((struct rpl_option *)0)->val) * 8UL - 8UL)));
#line 348
              (cvt->long_end) ++;
#line 348
              (cvt->long_end)->name = (char const   *)((void *)0);
            }
          }
        }
#line 303
        opt ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 353
    group->parser = (error_t (*)(int key , char *arg , struct argp_state *state ))argp___0->parser;
#line 354
    group->argp = argp___0;
#line 355
    group->short_end = cvt->short_end;
#line 356
    group->args_processed = 0U;
#line 357
    group->parent = parent;
#line 358
    group->parent_index = parent_index;
#line 359
    group->input = (void *)0;
#line 360
    group->hook = (void *)0;
#line 361
    group->child_inputs = (void **)0;
#line 363
    if (children) {
#line 367
      num_children = 0U;
      {
#line 368
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 368
        if (! (children + num_children)->argp) {
#line 368
          goto while_break___0;
        }
#line 369
        num_children ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 370
      group->child_inputs = cvt->child_inputs_end;
#line 371
      cvt->child_inputs_end += num_children;
    }
#line 374
    tmp___6 = group;
#line 374
    group ++;
#line 374
    parent = tmp___6;
  } else {
#line 377
    parent = (struct group *)0;
  }
#line 379
  if (children) {
#line 381
    index___0 = 0U;
    {
#line 382
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 382
      if (! children->argp) {
#line 382
        goto while_break___1;
      }
      {
#line 383
      tmp___7 = index___0;
#line 383
      index___0 ++;
#line 383
      tmp___8 = children;
#line 383
      children ++;
#line 383
      group = convert_options((struct argp  const  *)tmp___8->argp, parent, tmp___7,
                              group, cvt);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 387
  return (group);
}
}
#line 391 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-parse.c"
static void parser_convert(struct parser *parser , struct argp  const  *argp___0 ,
                           int flags ) 
{ 
  struct parser_convert_state cvt ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 396
  cvt.parser = parser;
#line 397
  cvt.short_end = parser->short_opts;
#line 398
  cvt.long_end = parser->long_opts;
#line 399
  cvt.child_inputs_end = parser->child_inputs;
#line 401
  if (flags & 8) {
#line 402
    tmp = cvt.short_end;
#line 402
    (cvt.short_end) ++;
#line 402
    *tmp = (char )'-';
  } else
#line 403
  if (flags & 4) {
#line 404
    tmp___0 = cvt.short_end;
#line 404
    (cvt.short_end) ++;
#line 404
    *tmp___0 = (char )'+';
  }
#line 405
  *(cvt.short_end) = (char )'\000';
#line 407
  (cvt.long_end)->name = (char const   *)((void *)0);
#line 409
  parser->argp = argp___0;
#line 411
  if (argp___0) {
    {
#line 412
    parser->egroup = convert_options(argp___0, (struct group *)0, 0U, parser->groups,
                                     & cvt);
    }
  } else {
#line 414
    parser->egroup = parser->groups;
  }
#line 415
  return;
}
}
#line 430 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-parse.c"
static void calc_sizes(struct argp  const  *argp___0 , struct parser_sizes *szs ) 
{ 
  struct argp_child  const  *child ;
  struct argp_option  const  *opt ;
  int num_opts ;
  struct argp_option  const  *tmp ;
  int tmp___0 ;
  struct argp_child  const  *tmp___1 ;

  {
#line 433
  child = (struct argp_child  const  *)argp___0->children;
#line 434
  opt = (struct argp_option  const  *)argp___0->options;
#line 436
  if (opt) {
#line 436
    goto _L;
  } else
#line 436
  if (argp___0->parser) {
    _L: /* CIL Label */ 
#line 438
    (szs->num_groups) ++;
#line 439
    if (opt) {
#line 441
      num_opts = 0;
      {
#line 442
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 442
        tmp = opt;
#line 442
        opt ++;
#line 442
        tmp___0 = _option_is_end(tmp);
        }
#line 442
        if (tmp___0) {
#line 442
          goto while_break;
        }
#line 443
        num_opts ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 444
      szs->short_len += (size_t )(num_opts * 3);
#line 445
      szs->long_len += (size_t )num_opts;
    }
  }
#line 449
  if (child) {
    {
#line 450
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 450
      if (! child->argp) {
#line 450
        goto while_break___0;
      }
      {
#line 452
      tmp___1 = child;
#line 452
      child ++;
#line 452
      calc_sizes((struct argp  const  *)tmp___1->argp, szs);
#line 453
      (szs->num_child_inputs) ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 455
  return;
}
}
#line 458 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-parse.c"
static error_t parser_init(struct parser *parser , struct argp  const  *argp___0 ,
                           int argc , char **argv , int flags , void *input___0 ) 
{ 
  error_t err ;
  struct group *group ;
  struct parser_sizes szs ;
  struct _getopt_data opt_data ;
  char *storage ;
  size_t glen ;
  size_t gsum ;
  size_t clen ;
  size_t csum ;
  size_t llen ;
  size_t lsum ;
  size_t slen ;
  size_t ssum ;

  {
#line 462
  err = 0;
#line 465
  opt_data.rpl_optind = 1;
#line 465
  opt_data.rpl_opterr = 1;
#line 465
  opt_data.rpl_optopt = 0;
#line 465
  opt_data.rpl_optarg = (char *)0;
#line 465
  opt_data.__initialized = 0;
#line 465
  opt_data.__nextchar = (char *)0;
#line 465
  opt_data.__ordering = 0U;
#line 465
  opt_data.__posixly_correct = 0;
#line 465
  opt_data.__first_nonopt = 0;
#line 465
  opt_data.__last_nonopt = 0;
#line 472
  if (flags & 4) {
#line 472
    szs.short_len = (size_t )0;
  } else {
#line 472
    szs.short_len = (size_t )1;
  }
#line 473
  szs.long_len = (size_t )0;
#line 474
  szs.num_groups = (size_t )0;
#line 475
  szs.num_child_inputs = (size_t )0;
#line 477
  if (argp___0) {
    {
#line 478
    calc_sizes(argp___0, & szs);
    }
  }
  {
#line 481
  glen = (szs.num_groups + 1UL) * sizeof(struct group );
#line 482
  clen = szs.num_child_inputs * sizeof(void *);
#line 483
  llen = (szs.long_len + 1UL) * sizeof(struct rpl_option );
#line 484
  slen = szs.short_len + 1UL;
#line 491
  gsum = glen;
#line 492
  csum = ((((gsum + clen) + (unsigned long )(& ((struct __anonstruct_32 *)0)->x)) - 1UL) / (unsigned long )(& ((struct __anonstruct_34 *)0)->x)) * (unsigned long )(& ((struct __anonstruct_36 *)0)->x);
#line 493
  lsum = csum + llen;
#line 494
  ssum = lsum + slen;
#line 496
  parser->storage = malloc(ssum);
  }
#line 497
  if (! parser->storage) {
#line 498
    return (12);
  }
  {
#line 500
  storage = (char *)parser->storage;
#line 501
  parser->groups = (struct group *)parser->storage;
#line 502
  parser->child_inputs = (void **)(storage + gsum);
#line 503
  parser->long_opts = (struct rpl_option *)(storage + csum);
#line 504
  parser->short_opts = storage + lsum;
#line 505
  parser->opt_data = opt_data;
#line 507
  memset((void *)parser->child_inputs, 0, clen);
#line 508
  parser_convert(parser, argp___0, flags);
#line 510
  memset((void *)(& parser->state), 0, sizeof(struct argp_state ));
#line 511
  parser->state.root_argp = parser->argp;
#line 512
  parser->state.argc = argc;
#line 513
  parser->state.argv = argv;
#line 514
  parser->state.flags = (unsigned int )flags;
#line 515
  parser->state.err_stream = stderr;
#line 516
  parser->state.out_stream = stdout;
#line 517
  parser->state.next = 0;
#line 518
  parser->state.pstate = (void *)parser;
#line 520
  parser->try_getopt = 1;
  }
#line 524
  if ((unsigned long )parser->groups < (unsigned long )parser->egroup) {
#line 525
    (parser->groups)->input = input___0;
  }
#line 526
  group = parser->groups;
  {
#line 526
  while (1) {
    while_continue: /* CIL Label */ ;
#line 526
    if ((unsigned long )group < (unsigned long )parser->egroup) {
#line 526
      if (! (! err)) {
#line 526
        if (! (err == 7)) {
#line 526
          goto while_break;
        }
      }
    } else {
#line 526
      goto while_break;
    }
#line 530
    if (group->parent) {
#line 532
      group->input = *((group->parent)->child_inputs + group->parent_index);
    }
#line 534
    if (! group->parser) {
#line 534
      if ((group->argp)->children) {
#line 534
        if (((group->argp)->children)->argp) {
#line 539
          *(group->child_inputs + 0) = group->input;
        }
      }
    }
    {
#line 541
    err = group_parse(group, & parser->state, 16777219, (char *)0);
#line 526
    group ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 543
  if (err == 7) {
#line 544
    err = 0;
  }
#line 546
  if (err) {
#line 547
    return (err);
  }
#line 549
  if (parser->state.flags & 2U) {
#line 551
    parser->opt_data.rpl_opterr = 0;
#line 552
    if (parser->state.flags & 1U) {
#line 555
      (parser->state.argv) --;
#line 555
      (parser->state.argc) ++;
    }
  } else {
#line 558
    parser->opt_data.rpl_opterr = 1;
  }
#line 560
  if ((unsigned long )parser->state.argv == (unsigned long )argv) {
#line 560
    if (*(argv + 0)) {
      {
#line 562
      parser->state.name = last_component((char const   *)*(argv + 0));
      }
    } else {
#line 564
      parser->state.name = program_invocation_short_name;
    }
  } else {
#line 564
    parser->state.name = program_invocation_short_name;
  }
#line 566
  return (0);
}
}
#line 570 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-parse.c"
static error_t parser_finalize(struct parser *parser , error_t err , int arg_ebadkey ,
                               int *end_index ) 
{ 
  struct group *group ;
  char *tmp ;

  {
#line 576
  if (err == 7) {
#line 576
    if (arg_ebadkey) {
#line 578
      err = 0;
    }
  }
#line 580
  if (! err) {
#line 582
    if (parser->state.next == parser->state.argc) {
#line 586
      group = parser->groups;
      {
#line 586
      while (1) {
        while_continue: /* CIL Label */ ;
#line 586
        if ((unsigned long )group < (unsigned long )parser->egroup) {
#line 586
          if (! (! err)) {
#line 586
            if (! (err == 7)) {
#line 586
              goto while_break;
            }
          }
        } else {
#line 586
          goto while_break;
        }
#line 589
        if (group->args_processed == 0U) {
          {
#line 590
          err = group_parse(group, & parser->state, 16777218, (char *)0);
          }
        }
#line 586
        group ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 591
      group = parser->egroup - 1;
      {
#line 591
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 591
        if ((unsigned long )group >= (unsigned long )parser->groups) {
#line 591
          if (! (! err)) {
#line 591
            if (! (err == 7)) {
#line 591
              goto while_break___0;
            }
          }
        } else {
#line 591
          goto while_break___0;
        }
        {
#line 594
        err = group_parse(group, & parser->state, 16777217, (char *)0);
#line 591
        group --;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 596
      if (err == 7) {
#line 597
        err = 0;
      }
#line 600
      if (end_index) {
#line 601
        *end_index = parser->state.next;
      }
    } else
#line 603
    if (end_index) {
#line 605
      *end_index = parser->state.next;
    } else {
#line 609
      if (! (parser->state.flags & 2U)) {
#line 609
        if (parser->state.err_stream) {
          {
#line 611
          tmp = dgettext((char const   *)(parser->argp)->argp_domain, "%s: Too many arguments\n");
#line 611
          fprintf((FILE */* __restrict  */)parser->state.err_stream, (char const   */* __restrict  */)tmp,
                  parser->state.name);
          }
        }
      }
#line 615
      err = 7;
    }
  }
#line 622
  if (err) {
#line 625
    if (err == 7) {
      {
#line 628
      argp_state_help((struct argp_state  const  */* __restrict  */)(& parser->state),
                      (FILE */* __restrict  */)parser->state.err_stream, 260U);
      }
    }
#line 632
    group = parser->groups;
    {
#line 632
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 632
      if (! ((unsigned long )group < (unsigned long )parser->egroup)) {
#line 632
        goto while_break___1;
      }
      {
#line 633
      group_parse(group, & parser->state, 16777221, (char *)0);
#line 632
      group ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  } else {
#line 641
    group = parser->egroup - 1;
    {
#line 641
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 641
      if ((unsigned long )group >= (unsigned long )parser->groups) {
#line 641
        if (! (! err)) {
#line 641
          if (! (err == 7)) {
#line 641
            goto while_break___2;
          }
        }
      } else {
#line 641
        goto while_break___2;
      }
      {
#line 644
      err = group_parse(group, & parser->state, 16777220, (char *)0);
#line 641
      group --;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 645
    if (err == 7) {
#line 646
      err = 0;
    }
  }
#line 650
  group = parser->egroup - 1;
  {
#line 650
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 650
    if (! ((unsigned long )group >= (unsigned long )parser->groups)) {
#line 650
      goto while_break___3;
    }
    {
#line 651
    group_parse(group, & parser->state, 16777223, (char *)0);
#line 650
    group --;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 653
  if (err == 7) {
#line 654
    err = 22;
  }
  {
#line 656
  free(parser->storage);
  }
#line 658
  return (err);
}
}
#line 666 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-parse.c"
static error_t parser_parse_arg(struct parser *parser , char *val ) 
{ 
  int index___0 ;
  error_t err ;
  struct group *group ;
  int key ;

  {
#line 671
  (parser->state.next) --;
#line 671
  index___0 = parser->state.next;
#line 672
  err = 7;
#line 674
  key = 0;
#line 677
  group = parser->groups;
  {
#line 677
  while (1) {
    while_continue: /* CIL Label */ ;
#line 677
    if ((unsigned long )group < (unsigned long )parser->egroup) {
#line 677
      if (! (err == 7)) {
#line 677
        goto while_break;
      }
    } else {
#line 677
      goto while_break;
    }
    {
#line 681
    (parser->state.next) ++;
#line 682
    key = 0;
#line 683
    err = group_parse(group, & parser->state, key, val);
    }
#line 685
    if (err == 7) {
      {
#line 688
      (parser->state.next) --;
#line 689
      key = 16777222;
#line 690
      err = group_parse(group, & parser->state, key, (char *)0);
      }
    }
#line 677
    group ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 694
  if (! err) {
#line 696
    if (key == 16777222) {
#line 700
      parser->state.next = parser->state.argc;
    }
#line 702
    if (parser->state.next > index___0) {
#line 706
      group --;
#line 706
      group->args_processed += (unsigned int )(parser->state.next - index___0);
    } else {
#line 709
      parser->try_getopt = 1;
    }
  }
#line 712
  return (err);
}
}
#line 755
static error_t parser_parse_opt(struct parser *parser , int opt , char *val ) ;
#line 755 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-parse.c"
static char const   bad_key_err[53]  = 
#line 755
  {      (char const   )'(',      (char const   )'P',      (char const   )'R',      (char const   )'O', 
        (char const   )'G',      (char const   )'R',      (char const   )'A',      (char const   )'M', 
        (char const   )' ',      (char const   )'E',      (char const   )'R',      (char const   )'R', 
        (char const   )'O',      (char const   )'R',      (char const   )')',      (char const   )' ', 
        (char const   )'O',      (char const   )'p',      (char const   )'t',      (char const   )'i', 
        (char const   )'o',      (char const   )'n',      (char const   )' ',      (char const   )'s', 
        (char const   )'h',      (char const   )'o',      (char const   )'u',      (char const   )'l', 
        (char const   )'d',      (char const   )' ',      (char const   )'h',      (char const   )'a', 
        (char const   )'v',      (char const   )'e',      (char const   )' ',      (char const   )'b', 
        (char const   )'e',      (char const   )'e',      (char const   )'n',      (char const   )' ', 
        (char const   )'r',      (char const   )'e',      (char const   )'c',      (char const   )'o', 
        (char const   )'g',      (char const   )'n',      (char const   )'i',      (char const   )'z', 
        (char const   )'e',      (char const   )'d',      (char const   )'!',      (char const   )'?', 
        (char const   )'\000'};
#line 717 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-parse.c"
static error_t parser_parse_opt(struct parser *parser , int opt , char *val ) 
{ 
  int group_key ;
  error_t err ;
  struct group *group ;
  char *short_index ;
  char *tmp ;
  char *tmp___0 ;
  struct rpl_option *long_opt ;
  char *tmp___1 ;
  char const   *tmp___2 ;

  {
#line 722
  group_key = opt >> (sizeof(((struct rpl_option *)0)->val) * 8UL - 8UL);
#line 723
  err = 7;
#line 725
  if (group_key == 0) {
    {
#line 731
    tmp = strchr((char const   *)parser->short_opts, opt);
#line 731
    short_index = tmp;
    }
#line 733
    if (short_index) {
#line 734
      group = parser->groups;
      {
#line 734
      while (1) {
        while_continue: /* CIL Label */ ;
#line 734
        if (! ((unsigned long )group < (unsigned long )parser->egroup)) {
#line 734
          goto while_break;
        }
#line 735
        if ((unsigned long )group->short_end > (unsigned long )short_index) {
          {
#line 737
          err = group_parse(group, & parser->state, opt, parser->opt_data.rpl_optarg);
          }
#line 739
          goto while_break;
        }
#line 734
        group ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  } else {
    {
#line 745
    err = group_parse(parser->groups + (group_key - 1), & parser->state, (opt << 8) >> 8,
                      parser->opt_data.rpl_optarg);
    }
  }
#line 750
  if (err == 7) {
#line 757
    if (group_key == 0) {
      {
#line 758
      tmp___0 = dgettext((char const   *)(parser->argp)->argp_domain, bad_key_err);
#line 758
      argp_error((struct argp_state  const  */* __restrict  */)(& parser->state),
                 (char const   */* __restrict  */)"-%c: %s", opt, tmp___0);
      }
    } else {
#line 762
      long_opt = parser->long_opts;
      {
#line 763
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 763
        if (long_opt->val != opt) {
#line 763
          if (! long_opt->name) {
#line 763
            goto while_break___0;
          }
        } else {
#line 763
          goto while_break___0;
        }
#line 764
        long_opt ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 765
      tmp___1 = dgettext((char const   *)(parser->argp)->argp_domain, bad_key_err);
      }
#line 765
      if (long_opt->name) {
#line 765
        tmp___2 = long_opt->name;
      } else {
#line 765
        tmp___2 = "???";
      }
      {
#line 765
      argp_error((struct argp_state  const  */* __restrict  */)(& parser->state),
                 (char const   */* __restrict  */)"--%s: %s", tmp___2, tmp___1);
      }
    }
  }
#line 771
  return (err);
}
}
#line 778 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-parse.c"
static error_t parser_parse_next(struct parser *parser , int *arg_ebadkey ) 
{ 
  int opt ;
  error_t err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 782
  err = 0;
#line 784
  if (parser->state.quoted) {
#line 784
    if (parser->state.next < parser->state.quoted) {
#line 789
      parser->state.quoted = 0;
    }
  }
#line 791
  if (parser->try_getopt) {
#line 791
    if (! parser->state.quoted) {
#line 795
      parser->opt_data.rpl_optind = parser->state.next;
#line 797
      parser->opt_data.rpl_optopt = -1;
#line 798
      if (parser->state.flags & 64U) {
        {
#line 799
        opt = _getopt_long_only_r(parser->state.argc, parser->state.argv, (char const   *)parser->short_opts,
                                  (struct rpl_option  const  *)parser->long_opts,
                                  (int *)0, & parser->opt_data);
        }
      } else {
        {
#line 803
        opt = _getopt_long_r(parser->state.argc, parser->state.argv, (char const   *)parser->short_opts,
                             (struct rpl_option  const  *)parser->long_opts, (int *)0,
                             & parser->opt_data);
        }
      }
#line 807
      parser->state.next = parser->opt_data.rpl_optind;
#line 809
      if (opt == -1) {
#line 813
        parser->try_getopt = 0;
#line 814
        if (parser->state.next > 1) {
          {
#line 814
          tmp = strcmp((char const   *)*(parser->state.argv + (parser->state.next - 1)),
                       "--");
          }
#line 814
          if (tmp == 0) {
#line 821
            parser->state.quoted = parser->state.next;
          }
        }
      } else
#line 823
      if (opt == 63) {
#line 823
        if (parser->opt_data.rpl_optopt != -1) {
#line 828
          *arg_ebadkey = 0;
#line 829
          return (7);
        }
      }
    } else {
#line 833
      opt = -1;
    }
  } else {
#line 833
    opt = -1;
  }
#line 835
  if (opt == -1) {
#line 838
    if (parser->state.next >= parser->state.argc) {
#line 842
      *arg_ebadkey = 1;
#line 843
      return (7);
    } else
#line 838
    if (parser->state.flags & 4U) {
#line 842
      *arg_ebadkey = 1;
#line 843
      return (7);
    } else {
#line 848
      opt = 1;
#line 849
      tmp___0 = parser->state.next;
#line 849
      (parser->state.next) ++;
#line 849
      parser->opt_data.rpl_optarg = *(parser->state.argv + tmp___0);
    }
  }
#line 853
  if (opt == 1) {
    {
#line 855
    err = parser_parse_arg(parser, parser->opt_data.rpl_optarg);
    }
  } else {
    {
#line 857
    err = parser_parse_opt(parser, opt, parser->opt_data.rpl_optarg);
    }
  }
#line 859
  if (err == 7) {
#line 860
    if (opt == -1) {
#line 860
      tmp___1 = 1;
    } else
#line 860
    if (opt == 1) {
#line 860
      tmp___1 = 1;
    } else {
#line 860
      tmp___1 = 0;
    }
#line 860
    *arg_ebadkey = tmp___1;
  }
#line 862
  return (err);
}
}
#line 870 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-parse.c"
error_t argp_parse(struct argp  const  * __restrict  argp___0 , int argc , char ** __restrict  argv ,
                   unsigned int flags , int * __restrict  end_index , void * __restrict  input___0 ) 
{ 
  error_t err ;
  struct parser parser ;
  int arg_ebadkey ;
  struct argp_child *child ;
  void *tmp ;
  struct argp *top_argp ;
  void *tmp___0 ;
  struct argp_child *tmp___1 ;
  struct argp_child *tmp___2 ;
  struct argp_child *tmp___3 ;

  {
#line 879
  arg_ebadkey = 0;
#line 882
  if (! (flags & 1U)) {
#line 885
    if (! program_invocation_name) {
#line 886
      program_invocation_name = *(argv + 0);
    }
#line 889
    if (! program_invocation_short_name) {
      {
#line 890
      program_invocation_short_name = last_component((char const   *)*(argv + 0));
      }
    }
  }
#line 895
  if (! (flags & 16U)) {
    {
#line 898
    tmp = __builtin_alloca(4UL * sizeof(struct argp_child ));
#line 898
    child = (struct argp_child *)tmp;
#line 899
    tmp___0 = __builtin_alloca(sizeof(struct argp ));
#line 899
    top_argp = (struct argp *)tmp___0;
#line 903
    memset((void *)top_argp, 0, sizeof(*top_argp));
#line 904
    top_argp->children = (struct argp_child  const  *)child;
#line 906
    memset((void *)child, 0, 4UL * sizeof(struct argp_child ));
    }
#line 908
    if (argp___0) {
#line 909
      tmp___1 = child;
#line 909
      child ++;
#line 909
      tmp___1->argp = (struct argp  const  *)argp___0;
    }
#line 910
    tmp___2 = child;
#line 910
    child ++;
#line 910
    tmp___2->argp = & argp_default_argp;
#line 911
    if (argp_program_version) {
#line 912
      tmp___3 = child;
#line 912
      child ++;
#line 912
      tmp___3->argp = & argp_version_argp;
    } else
#line 911
    if (argp_program_version_hook) {
#line 912
      tmp___3 = child;
#line 912
      child ++;
#line 912
      tmp___3->argp = & argp_version_argp;
    }
#line 913
    child->argp = (struct argp  const  *)0;
#line 915
    argp___0 = (struct argp  const  */* __restrict  */)top_argp;
  }
  {
#line 919
  err = parser_init(& parser, (struct argp  const  *)argp___0, argc, (char **)argv,
                    (int )flags, (void *)input___0);
  }
#line 921
  if (! err) {
    {
#line 924
    while (1) {
      while_continue: /* CIL Label */ ;
#line 924
      if (! (! err)) {
#line 924
        goto while_break;
      }
      {
#line 925
      err = parser_parse_next(& parser, & arg_ebadkey);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 926
    err = parser_finalize(& parser, err, arg_ebadkey, (int *)end_index);
    }
  }
#line 929
  return (err);
}
}
#line 937
 __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) _argp_input)(struct argp  const  * __restrict  argp___0 ,
                                                                             struct argp_state  const  * __restrict  state ) ;
#line 937 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-parse.c"
void *( __attribute__((__leaf__)) _argp_input)(struct argp  const  * __restrict  argp___0 ,
                                               struct argp_state  const  * __restrict  state ) 
{ 
  struct group *group ;
  struct parser *parser ;

  {
#line 940
  if (state) {
#line 943
    parser = (struct parser *)state->pstate;
#line 945
    group = parser->groups;
    {
#line 945
    while (1) {
      while_continue: /* CIL Label */ ;
#line 945
      if (! ((unsigned long )group < (unsigned long )parser->egroup)) {
#line 945
        goto while_break;
      }
#line 946
      if ((unsigned long )group->argp == (unsigned long )argp___0) {
#line 947
        return (group->input);
      }
#line 945
      group ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 950
  return ((void *)0);
}
}
#line 515 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 765
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 140 "./cflow.h"
unsigned char *level_mark  ;
#line 141 "./cflow.h"
FILE *outfile  ;
#line 158
int out_line ;
#line 251
cflow_depmap_t depmap_alloc(size_t count ) ;
#line 252
void depmap_set(cflow_depmap_t dmap , size_t row , size_t col ) ;
#line 253
int depmap_isset(cflow_depmap_t dmap , size_t row , size_t col ) ;
#line 254
void depmap_tc(cflow_depmap_t dmap ) ;
#line 26 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/output.c"
int level_mark_size  =    0;
#line 27 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/output.c"
int level_mark_incr  =    128;
#line 29 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/output.c"
int out_line  =    1;
#line 32 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/output.c"
static void set_level_mark(int lev , int mark___0 ) 
{ 
  void *tmp ;

  {
#line 35
  if (lev >= level_mark_size) {
    {
#line 36
    level_mark_size += level_mark_incr;
#line 37
    tmp = xrealloc((void *)level_mark, (size_t )level_mark_size);
#line 37
    level_mark = (unsigned char *)tmp;
    }
  }
#line 39
  *(level_mark + lev) = (unsigned char )mark___0;
#line 40
  return;
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/output.c"
void print_level(int lev , int last ) 
{ 
  int i ;

  {
#line 49
  if (print_line_numbers) {
    {
#line 50
    fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"%5d ",
            out_line);
    }
  }
#line 51
  if (print_levels) {
    {
#line 52
    fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"{%4d} ",
            lev);
    }
  }
  {
#line 53
  fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"%s",
          level_begin);
#line 54
  i = 0;
  }
  {
#line 54
  while (1) {
    while_continue: /* CIL Label */ ;
#line 54
    if (! (i < lev)) {
#line 54
      goto while_break;
    }
    {
#line 55
    fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"%s",
            level_indent[*(level_mark + i)]);
#line 54
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 56
  fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"%s",
          level_end[last]);
  }
#line 57
  return;
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/output.c"
static int driver_index  ;
#line 71 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/output.c"
static int driver_max  =    0;
#line 72 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/output.c"
struct output_driver output_driver[8]  ;
#line 74 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/output.c"
int register_output(char const   *name , int (*handler)(cflow_output_command cmd ,
                                                        FILE *outfile , int line ,
                                                        void *data , void *handler_data ) ,
                    void *handler_data ) 
{ 
  int tmp ;

  {
#line 81
  if (driver_max == 7) {
    {
#line 82
    abort();
    }
  }
  {
#line 83
  output_driver[driver_max].name = strdup(name);
#line 84
  output_driver[driver_max].handler = handler;
#line 85
  output_driver[driver_max].handler_data = handler_data;
#line 86
  tmp = driver_max;
#line 86
  driver_max ++;
  }
#line 86
  return (tmp);
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/output.c"
int select_output_driver(char const   *name ) 
{ 
  int i ;
  int tmp ;

  {
#line 93
  i = 0;
  {
#line 93
  while (1) {
    while_continue: /* CIL Label */ ;
#line 93
    if (! (i < driver_max)) {
#line 93
      goto while_break;
    }
    {
#line 94
    tmp = strcmp((char const   *)output_driver[i].name, name);
    }
#line 94
    if (tmp == 0) {
#line 95
      driver_index = i;
#line 96
      return (0);
    }
#line 93
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  return (-1);
}
}
#line 101 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/output.c"
void output_init(void) 
{ 


  {
  {
#line 104
  (*(output_driver[driver_index].handler))((cflow_output_command )0, (FILE *)((void *)0),
                                           0, (void *)0, output_driver[driver_index].handler_data);
  }
#line 108
  return;
}
}
#line 110 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/output.c"
void newline(void) 
{ 


  {
  {
#line 113
  (*(output_driver[driver_index].handler))((cflow_output_command )3, outfile, out_line,
                                           (void *)0, output_driver[driver_index].handler_data);
#line 117
  out_line ++;
  }
#line 118
  return;
}
}
#line 120 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/output.c"
static void begin(void) 
{ 


  {
  {
#line 123
  (*(output_driver[driver_index].handler))((cflow_output_command )1, outfile, out_line,
                                           (void *)0, output_driver[driver_index].handler_data);
  }
#line 127
  return;
}
}
#line 129 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/output.c"
static void end(void) 
{ 


  {
  {
#line 132
  (*(output_driver[driver_index].handler))((cflow_output_command )2, outfile, out_line,
                                           (void *)0, output_driver[driver_index].handler_data);
  }
#line 136
  return;
}
}
#line 138 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/output.c"
static void separator(void) 
{ 


  {
  {
#line 141
  (*(output_driver[driver_index].handler))((cflow_output_command )4, outfile, out_line,
                                           (void *)0, output_driver[driver_index].handler_data);
  }
#line 145
  return;
}
}
#line 158 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/output.c"
static int print_symbol___0(int direct , int level___0 , int last , Symbol *sym ) 
{ 
  struct output_symbol output_symbol ;
  int tmp ;

  {
  {
#line 163
  output_symbol.direct = direct;
#line 164
  output_symbol.level = level___0;
#line 165
  output_symbol.last = last;
#line 166
  output_symbol.sym = sym;
#line 168
  tmp = (*(output_driver[driver_index].handler))((cflow_output_command )5, outfile,
                                                 out_line, (void *)(& output_symbol),
                                                 output_driver[driver_index].handler_data);
  }
#line 168
  return (tmp);
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/output.c"
static int compare(void const   *ap , void const   *bp ) 
{ 
  Symbol * const  *a ;
  Symbol * const  *b ;
  int tmp ;

  {
  {
#line 178
  a = (Symbol * const  *)ap;
#line 179
  b = (Symbol * const  *)bp;
#line 180
  tmp = strcmp((char const   *)(*a)->name, (char const   *)(*b)->name);
  }
#line 180
  return (tmp);
}
}
#line 183 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/output.c"
static int is_var(Symbol *symp ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 186
  tmp___0 = include_symbol(symp);
  }
#line 186
  if (tmp___0) {
#line 187
    if ((unsigned int )symp->type == 2U) {
#line 188
      if ((unsigned int )symp->storage == 0U) {
#line 188
        tmp = 1;
      } else
#line 188
      if ((unsigned int )symp->storage == 2U) {
#line 188
        tmp = 1;
      } else {
#line 188
        tmp = 0;
      }
#line 188
      return (tmp);
    } else {
#line 191
      return (1);
    }
  }
#line 193
  return (0);
}
}
#line 196 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/output.c"
int symbol_is_function(Symbol *symp ) 
{ 
  int tmp ;

  {
#line 199
  if ((unsigned int )symp->type == 2U) {
#line 199
    if (symp->arity >= 0) {
#line 199
      tmp = 1;
    } else {
#line 199
      tmp = 0;
    }
  } else {
#line 199
    tmp = 0;
  }
#line 199
  return (tmp);
}
}
#line 202 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/output.c"
static void clear_active(Symbol *sym ) 
{ 


  {
#line 205
  sym->active = 0;
#line 206
  return;
}
}
#line 210 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/output.c"
void print_refs(char *name , struct linked_list *reflist ) 
{ 
  Ref *refptr ;
  struct linked_list_entry *p ;

  {
#line 216
  if (reflist) {
#line 216
    p = reflist->head;
  } else {
#line 216
    p = (struct linked_list_entry *)((void *)0);
  }
  {
#line 216
  while (1) {
    while_continue: /* CIL Label */ ;
#line 216
    if (! p) {
#line 216
      goto while_break;
    }
    {
#line 217
    refptr = (Ref *)p->data;
#line 218
    fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"%s   %s:%d\n",
            name, refptr->source, refptr->line);
#line 216
    p = p->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 223
  return;
}
}
#line 225 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/output.c"
static void print_function(Symbol *symp ) 
{ 


  {
#line 228
  if (symp->source) {
    {
#line 229
    fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"%s * %s:%d %s\n",
            symp->name, symp->source, symp->def_line, symp->decl);
    }
  }
  {
#line 235
  print_refs(symp->name, symp->ref_line);
  }
#line 236
  return;
}
}
#line 238 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/output.c"
static void print_type(Symbol *symp ) 
{ 


  {
#line 241
  if (symp->source) {
    {
#line 242
    fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"%s t %s:%d\n",
            symp->name, symp->source, symp->def_line);
    }
  }
#line 246
  return;
}
}
#line 248 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/output.c"
void xref_output(void) 
{ 
  Symbol **symbols ;
  Symbol *symp ;
  size_t i ;
  size_t num ;

  {
  {
#line 254
  num = collect_symbols(& symbols, (int (*)())(& is_var), (size_t )0);
#line 255
  qsort((void *)symbols, num, sizeof(*symbols), & compare);
#line 258
  i = (size_t )0;
  }
  {
#line 258
  while (1) {
    while_continue: /* CIL Label */ ;
#line 258
    if (! (i < num)) {
#line 258
      goto while_break;
    }
#line 259
    symp = *(symbols + i);
    {
#line 261
    if ((unsigned int )symp->type == 2U) {
#line 261
      goto case_2;
    }
#line 264
    if ((unsigned int )symp->type == 1U) {
#line 264
      goto case_1;
    }
#line 267
    if ((unsigned int )symp->type == 0U) {
#line 267
      goto case_0;
    }
#line 260
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 262
    print_function(symp);
    }
#line 263
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 265
    print_type(symp);
    }
#line 266
    goto switch_break;
    case_0: /* CIL Label */ 
#line 268
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 258
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 271
  free((void *)symbols);
  }
#line 272
  return;
}
}
#line 278 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/output.c"
static void set_active(Symbol *sym ) 
{ 


  {
#line 281
  sym->active = out_line;
#line 282
  return;
}
}
#line 284 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/output.c"
static int is_printable(struct linked_list_entry *p ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 287
  if ((unsigned long )p != (unsigned long )((void *)0)) {
    {
#line 287
    tmp = include_symbol((Symbol *)p->data);
    }
#line 287
    if (tmp) {
#line 287
      tmp___0 = 1;
    } else {
#line 287
      tmp___0 = 0;
    }
  } else {
#line 287
    tmp___0 = 0;
  }
#line 287
  return (tmp___0);
}
}
#line 290 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/output.c"
static int is_last(struct linked_list_entry *p ) 
{ 
  int tmp ;

  {
  {
#line 293
  while (1) {
    while_continue: /* CIL Label */ ;
#line 293
    p = p->next;
#line 293
    if (! p) {
#line 293
      goto while_break;
    }
    {
#line 294
    tmp = is_printable(p);
    }
#line 294
    if (tmp) {
#line 295
      return (0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 296
  return (1);
}
}
#line 301 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/output.c"
static void direct_tree(int lev , int last , Symbol *sym ) 
{ 
  struct linked_list_entry *p ;
  int rc ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 307
  if ((unsigned int )sym->type == 0U) {
#line 310
    return;
  } else
#line 307
  if (max_depth) {
#line 307
    if (lev >= max_depth) {
#line 310
      return;
    } else {
#line 307
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 307
    tmp = include_symbol(sym);
    }
#line 307
    if (! tmp) {
#line 310
      return;
    }
  }
  {
#line 312
  rc = print_symbol___0(1, lev, last, sym);
#line 313
  newline();
  }
#line 314
  if (rc) {
#line 315
    return;
  } else
#line 314
  if (sym->active) {
#line 315
    return;
  }
  {
#line 316
  set_active(sym);
  }
#line 317
  if (sym->callee) {
#line 317
    p = (sym->callee)->head;
  } else {
#line 317
    p = (struct linked_list_entry *)((void *)0);
  }
  {
#line 317
  while (1) {
    while_continue: /* CIL Label */ ;
#line 317
    if (! p) {
#line 317
      goto while_break;
    }
    {
#line 318
    tmp___0 = is_last(p);
    }
#line 318
    if (tmp___0) {
#line 318
      tmp___1 = 0;
    } else {
#line 318
      tmp___1 = 1;
    }
    {
#line 318
    set_level_mark(lev + 1, tmp___1);
#line 319
    tmp___2 = is_last(p);
#line 319
    direct_tree(lev + 1, tmp___2, (Symbol *)p->data);
#line 317
    p = p->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 321
  clear_active(sym);
  }
#line 322
  return;
}
}
#line 326 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/output.c"
static void inverted_tree(int lev , int last , Symbol *sym ) 
{ 
  struct linked_list_entry *p ;
  int rc ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 332
  if ((unsigned int )sym->type == 0U) {
#line 335
    return;
  } else
#line 332
  if (max_depth) {
#line 332
    if (lev >= max_depth) {
#line 335
      return;
    } else {
#line 332
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 332
    tmp = include_symbol(sym);
    }
#line 332
    if (! tmp) {
#line 335
      return;
    }
  }
  {
#line 336
  rc = print_symbol___0(0, lev, last, sym);
#line 337
  newline();
  }
#line 338
  if (rc) {
#line 339
    return;
  } else
#line 338
  if (sym->active) {
#line 339
    return;
  }
  {
#line 340
  set_active(sym);
  }
#line 341
  if (sym->caller) {
#line 341
    p = (sym->caller)->head;
  } else {
#line 341
    p = (struct linked_list_entry *)((void *)0);
  }
  {
#line 341
  while (1) {
    while_continue: /* CIL Label */ ;
#line 341
    if (! p) {
#line 341
      goto while_break;
    }
    {
#line 342
    tmp___0 = is_last(p);
    }
#line 342
    if (tmp___0) {
#line 342
      tmp___1 = 0;
    } else {
#line 342
      tmp___1 = 1;
    }
    {
#line 342
    set_level_mark(lev + 1, tmp___1);
#line 343
    tmp___2 = is_last(p);
#line 343
    inverted_tree(lev + 1, tmp___2, (Symbol *)p->data);
#line 341
    p = p->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 345
  clear_active(sym);
  }
#line 346
  return;
}
}
#line 348 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/output.c"
static void tree_output(void) 
{ 
  Symbol **symbols ;
  Symbol *main_sym ;
  size_t i ;
  size_t num ;
  cflow_depmap_t depmap ;
  struct linked_list_entry *p ;
  Symbol *s ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 356
  num = collect_functions(& symbols);
#line 357
  i = (size_t )0;
  }
  {
#line 357
  while (1) {
    while_continue: /* CIL Label */ ;
#line 357
    if (! (i < num)) {
#line 357
      goto while_break;
    }
#line 358
    (*(symbols + i))->ord = i;
#line 357
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 361
  depmap = depmap_alloc(num);
#line 362
  i = (size_t )0;
  }
  {
#line 362
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 362
    if (! (i < num)) {
#line 362
      goto while_break___0;
    }
#line 363
    if ((*(symbols + i))->callee) {
#line 366
      if ((*(symbols + i))->callee) {
#line 366
        p = ((*(symbols + i))->callee)->head;
      } else {
#line 366
        p = (struct linked_list_entry *)((void *)0);
      }
      {
#line 366
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 366
        if (! p) {
#line 366
          goto while_break___1;
        }
        {
#line 368
        s = (Symbol *)p->data;
#line 369
        tmp = symbol_is_function(s);
        }
#line 369
        if (tmp) {
          {
#line 370
          depmap_set(depmap, i, ((Symbol *)p->data)->ord);
          }
        }
#line 366
        p = p->next;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 362
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 375
  depmap_tc(depmap);
#line 378
  i = (size_t )0;
  }
  {
#line 378
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 378
    if (! (i < num)) {
#line 378
      goto while_break___2;
    }
    {
#line 379
    tmp___0 = depmap_isset(depmap, i, i);
    }
#line 379
    if (tmp___0) {
#line 380
      (*(symbols + i))->recursive = 1;
    }
#line 378
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 381
  free((void *)depmap);
#line 382
  free((void *)symbols);
#line 385
  num = collect_symbols(& symbols, (int (*)())(& is_var), (size_t )0);
#line 386
  qsort((void *)symbols, num, sizeof(*symbols), & compare);
#line 389
  begin();
  }
#line 391
  if (reverse_tree) {
#line 392
    i = (size_t )0;
    {
#line 392
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 392
      if (! (i < num)) {
#line 392
        goto while_break___3;
      }
      {
#line 393
      inverted_tree(0, 0, *(symbols + i));
#line 394
      separator();
#line 392
      i ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
  } else {
    {
#line 397
    main_sym = lookup((char const   *)start_name);
    }
#line 398
    if (main_sym) {
      {
#line 399
      direct_tree(0, 0, main_sym);
#line 400
      separator();
      }
    } else {
#line 402
      i = (size_t )0;
      {
#line 402
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 402
        if (! (i < num)) {
#line 402
          goto while_break___4;
        }
#line 403
        if ((unsigned long )(*(symbols + i))->callee == (unsigned long )((void *)0)) {
#line 404
          goto __Cont;
        }
        {
#line 405
        direct_tree(0, 0, *(symbols + i));
#line 406
        separator();
        }
        __Cont: /* CIL Label */ 
#line 402
        i ++;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
  }
  {
#line 411
  end();
#line 413
  free((void *)symbols);
  }
#line 414
  return;
}
}
#line 416 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/output.c"
void output(void) 
{ 
  char *tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 419
  tmp___1 = strcmp((char const   *)outname, "-");
  }
#line 419
  if (tmp___1 == 0) {
#line 420
    outfile = stdout;
  } else {
    {
#line 422
    outfile = fopen((char const   */* __restrict  */)outname, (char const   */* __restrict  */)"w");
    }
#line 423
    if (! outfile) {
      {
#line 424
      tmp = gettext("cannot open file `%s\'");
#line 424
      tmp___0 = __errno_location();
#line 424
      error(2, *tmp___0, (char const   *)tmp, outname);
      }
    }
  }
  {
#line 427
  set_level_mark(0, 0);
  }
#line 428
  if (print_option & 1) {
    {
#line 429
    xref_output();
    }
  }
#line 431
  if (print_option & 2) {
    {
#line 432
    tree_output();
    }
  }
  {
#line 434
  fclose(outfile);
  }
#line 435
  return;
}
}
#line 147 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 277
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchrnul)(char const   *__s ,
                                                                                                  int __c )  __attribute__((__pure__)) ;
#line 391
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) mempcpy)(void * __restrict  __dest ,
                                                                                                  void const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 438
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2), __leaf__)) strerror_r)(int __errnum ,
                                                                                                   char *__buf ,
                                                                                                   size_t __buflen ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 124 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 371 "/usr/include/stdio.h"
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 726
extern int fputs_unlocked(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 913
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) flockfile)(FILE *__stream ) ;
#line 920
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) funlockfile)(FILE *__stream ) ;
#line 501 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp.h"
void argp_help(struct argp  const  * __restrict  argp___0 , FILE * __restrict  stream ,
               unsigned int flags , char * __restrict  name ) ;
#line 549
void ( /* format attribute */  argp_failure)(struct argp_state  const  * __restrict  state ,
                                             int status , int errnum , char const   * __restrict  fmt 
                                             , ...) ;
#line 105 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-help.c"
static struct uparams uparams  = 
#line 105 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-help.c"
     {0, 1, 2, 6, 2, 29, 1, 12, 79, 0};
#line 121 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-help.c"
static struct uparam_name  const  uparam_names[10]  = 
#line 121
  {      {"dup-args", 1, (unsigned long )(& ((struct uparams *)0)->dup_args)}, 
        {"dup-args-note", 1, (unsigned long )(& ((struct uparams *)0)->dup_args_note)}, 
        {"short-opt-col",
      0, (unsigned long )(& ((struct uparams *)0)->short_opt_col)}, 
        {"long-opt-col", 0, (unsigned long )(& ((struct uparams *)0)->long_opt_col)}, 
        {"doc-opt-col",
      0, (unsigned long )(& ((struct uparams *)0)->doc_opt_col)}, 
        {"opt-doc-col", 0, (unsigned long )(& ((struct uparams *)0)->opt_doc_col)}, 
        {"header-col", 0, (unsigned long )(& ((struct uparams *)0)->header_col)}, 
        {"usage-indent", 0, (unsigned long )(& ((struct uparams *)0)->usage_indent)}, 
        {"rmargin",
      0, (unsigned long )(& ((struct uparams *)0)->rmargin)}, 
        {(char const   *)0, 0, 0UL}};
#line 135 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-help.c"
static void validate_uparams(struct argp_state  const  *state , struct uparams *upptr ) 
{ 
  struct uparam_name  const  *up ;
  char *tmp ;

  {
#line 140
  up = uparam_names;
  {
#line 140
  while (1) {
    while_continue: /* CIL Label */ ;
#line 140
    if (! up->name) {
#line 140
      goto while_break;
    }
#line 142
    if (up->is_bool) {
#line 144
      goto __Cont;
    } else
#line 142
    if (up->uparams_offs == (size_t const   )((unsigned long )(& ((struct uparams *)0)->rmargin))) {
#line 144
      goto __Cont;
    }
#line 145
    if (*((int *)((char *)upptr + up->uparams_offs)) >= upptr->rmargin) {
      {
#line 147
      tmp = dgettext((char const   *)(state->root_argp)->argp_domain, "ARGP_HELP_FMT: %s value is less than or equal to %s");
#line 147
      argp_failure((struct argp_state  const  */* __restrict  */)state, 0, 0, (char const   */* __restrict  */)tmp,
                   "rmargin", up->name);
      }
#line 152
      return;
    }
    __Cont: /* CIL Label */ 
#line 140
    up ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 155
  uparams = *upptr;
#line 156
  uparams.valid = 1;
#line 157
  return;
}
}
#line 160 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-help.c"
static void fill_in_uparams(struct argp_state  const  *state ) 
{ 
  char const   *var ;
  char *tmp ;
  struct uparams new_params ;
  unsigned short const   **tmp___0 ;
  size_t var_len ;
  struct uparam_name  const  *un ;
  int unspec ;
  int val ;
  char const   *arg___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  unsigned short const   **tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  unsigned short const   **tmp___13 ;

  {
  {
#line 163
  tmp = getenv("ARGP_HELP_FMT");
#line 163
  var = (char const   *)tmp;
#line 164
  new_params = uparams;
  }
#line 168
  if (var) {
    {
#line 171
    while (1) {
      while_continue: /* CIL Label */ ;
#line 171
      if (! *var) {
#line 171
        goto while_break;
      }
      {
#line 173
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 173
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 173
          tmp___0 = __ctype_b_loc();
          }
#line 173
          if (! ((int const   )*(*tmp___0 + (int )((unsigned char )*var)) & 8192)) {
#line 173
            goto while_break___1;
          }
#line 173
          var ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 173
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 175
      tmp___13 = __ctype_b_loc();
      }
#line 175
      if ((int const   )*(*tmp___13 + (int )((unsigned char )*var)) & 1024) {
#line 179
        unspec = 0;
#line 179
        val = 0;
#line 180
        arg___0 = var;
        {
#line 182
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
#line 182
          tmp___1 = __ctype_b_loc();
          }
#line 182
          if (! ((int const   )*(*tmp___1 + (int )((unsigned char )*arg___0)) & 8)) {
#line 182
            if (! ((int const   )*arg___0 == 45)) {
#line 182
              if (! ((int const   )*arg___0 == 95)) {
#line 182
                goto while_break___2;
              }
            }
          }
#line 183
          arg___0 ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 184
        var_len = (size_t )(arg___0 - var);
        {
#line 186
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 186
          while (1) {
            while_continue___4: /* CIL Label */ ;
            {
#line 186
            tmp___2 = __ctype_b_loc();
            }
#line 186
            if (! ((int const   )*(*tmp___2 + (int )((unsigned char )*arg___0)) & 8192)) {
#line 186
              goto while_break___4;
            }
#line 186
            arg___0 ++;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 186
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 188
        if ((int const   )*arg___0 == 0) {
#line 189
          unspec = 1;
        } else
#line 188
        if ((int const   )*arg___0 == 44) {
#line 189
          unspec = 1;
        } else
#line 190
        if ((int const   )*arg___0 == 61) {
#line 192
          arg___0 ++;
          {
#line 193
          while (1) {
            while_continue___5: /* CIL Label */ ;
            {
#line 193
            while (1) {
              while_continue___6: /* CIL Label */ ;
              {
#line 193
              tmp___3 = __ctype_b_loc();
              }
#line 193
              if (! ((int const   )*(*tmp___3 + (int )((unsigned char )*arg___0)) & 8192)) {
#line 193
                goto while_break___6;
              }
#line 193
              arg___0 ++;
            }
            while_break___6: /* CIL Label */ ;
            }
#line 193
            goto while_break___5;
          }
          while_break___5: /* CIL Label */ ;
          }
        }
#line 196
        if (unspec) {
#line 198
          if ((int const   )*(var + 0) == 110) {
#line 198
            if ((int const   )*(var + 1) == 111) {
#line 198
              if ((int const   )*(var + 2) == 45) {
#line 200
                val = 0;
#line 201
                var += 3;
#line 202
                var_len -= 3UL;
              } else {
#line 205
                val = 1;
              }
            } else {
#line 205
              val = 1;
            }
          } else {
#line 205
            val = 1;
          }
        } else {
          {
#line 207
          tmp___6 = __ctype_b_loc();
          }
#line 207
          if ((int const   )*(*tmp___6 + (int )((unsigned char )*arg___0)) & 2048) {
            {
#line 209
            val = atoi(arg___0);
            }
            {
#line 210
            while (1) {
              while_continue___7: /* CIL Label */ ;
              {
#line 210
              tmp___4 = __ctype_b_loc();
              }
#line 210
              if (! ((int const   )*(*tmp___4 + (int )((unsigned char )*arg___0)) & 2048)) {
#line 210
                goto while_break___7;
              }
#line 211
              arg___0 ++;
            }
            while_break___7: /* CIL Label */ ;
            }
            {
#line 212
            while (1) {
              while_continue___8: /* CIL Label */ ;
              {
#line 212
              while (1) {
                while_continue___9: /* CIL Label */ ;
                {
#line 212
                tmp___5 = __ctype_b_loc();
                }
#line 212
                if (! ((int const   )*(*tmp___5 + (int )((unsigned char )*arg___0)) & 8192)) {
#line 212
                  goto while_break___9;
                }
#line 212
                arg___0 ++;
              }
              while_break___9: /* CIL Label */ ;
              }
#line 212
              goto while_break___8;
            }
            while_break___8: /* CIL Label */ ;
            }
          }
        }
#line 215
        un = uparam_names;
        {
#line 215
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 215
          if (! un->name) {
#line 215
            goto while_break___10;
          }
          {
#line 216
          tmp___9 = strlen((char const   *)un->name);
          }
#line 216
          if (tmp___9 == var_len) {
            {
#line 216
            tmp___10 = strncmp(var, (char const   *)un->name, var_len);
            }
#line 216
            if (tmp___10 == 0) {
#line 219
              if (unspec) {
#line 219
                if (! un->is_bool) {
                  {
#line 220
                  tmp___7 = dgettext((char const   *)(state->root_argp)->argp_domain,
                                     "%.*s: ARGP_HELP_FMT parameter requires a value");
#line 220
                  argp_failure((struct argp_state  const  */* __restrict  */)state,
                               0, 0, (char const   */* __restrict  */)tmp___7, (int )var_len,
                               var);
                  }
                } else {
#line 219
                  goto _L;
                }
              } else
              _L: /* CIL Label */ 
#line 225
              if (val < 0) {
                {
#line 226
                tmp___8 = dgettext((char const   *)(state->root_argp)->argp_domain,
                                   "%.*s: ARGP_HELP_FMT parameter must be positive");
#line 226
                argp_failure((struct argp_state  const  */* __restrict  */)state,
                             0, 0, (char const   */* __restrict  */)tmp___8, (int )var_len,
                             var);
                }
              } else {
#line 232
                *((int *)((char *)(& new_params) + un->uparams_offs)) = val;
              }
#line 233
              goto while_break___10;
            }
          }
#line 215
          un ++;
        }
        while_break___10: /* CIL Label */ ;
        }
#line 235
        if (! un->name) {
          {
#line 236
          tmp___11 = dgettext((char const   *)(state->root_argp)->argp_domain, "%.*s: Unknown ARGP_HELP_FMT parameter");
#line 236
          argp_failure((struct argp_state  const  */* __restrict  */)state, 0, 0,
                       (char const   */* __restrict  */)tmp___11, (int )var_len, var);
          }
        }
#line 241
        var = arg___0;
#line 242
        if ((int const   )*var == 44) {
#line 243
          var ++;
        }
      } else
#line 245
      if (*var) {
        {
#line 247
        tmp___12 = dgettext((char const   *)(state->root_argp)->argp_domain, "Garbage in ARGP_HELP_FMT: %s");
#line 247
        argp_failure((struct argp_state  const  */* __restrict  */)state, 0, 0, (char const   */* __restrict  */)tmp___12,
                     var);
        }
#line 250
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 253
    validate_uparams(state, & new_params);
    }
  }
#line 255
  return;
}
}
#line 341 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-help.c"
static int find_char(char ch , char *beg , char *end___0 ) 
{ 


  {
  {
#line 344
  while (1) {
    while_continue: /* CIL Label */ ;
#line 344
    if (! ((unsigned long )beg < (unsigned long )end___0)) {
#line 344
      goto while_break;
    }
#line 345
    if ((int )*beg == (int )ch) {
#line 346
      return (1);
    } else {
#line 348
      beg ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 349
  return (0);
}
}
#line 433 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-help.c"
static struct hol *make_hol(struct argp  const  *argp___0 , struct hol_cluster *cluster ) 
{ 
  char *so ;
  struct argp_option  const  *o ;
  struct argp_option  const  *opts ;
  struct hol_entry *entry ;
  unsigned int num_short_options ;
  struct hol *hol ;
  void *tmp ;
  int cur_group ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 438
  opts = (struct argp_option  const  *)argp___0->options;
#line 440
  num_short_options = 0U;
#line 441
  tmp = malloc(sizeof(struct hol ));
#line 441
  hol = (struct hol *)tmp;
  }
#line 443
  if (! hol) {
    {
#line 443
    __assert_fail("hol", "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-help.c",
                  443U, "make_hol");
    }
  }
#line 445
  hol->num_entries = 0U;
#line 446
  hol->clusters = (struct hol_cluster *)0;
#line 448
  if (opts) {
#line 450
    cur_group = 0;
#line 453
    if (! (! (opts->flags & 4))) {
      {
#line 453
      __assert_fail("! ((opts)->flags & 0x4)", "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-help.c",
                    453U, "make_hol");
      }
    }
#line 456
    o = opts;
    {
#line 456
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 456
      tmp___1 = _option_is_end(o);
      }
#line 456
      if (tmp___1) {
#line 456
        goto while_break;
      }
#line 458
      if (! (o->flags & 4)) {
#line 459
        (hol->num_entries) ++;
      }
      {
#line 460
      tmp___0 = _option_is_short(o);
      }
#line 460
      if (tmp___0) {
#line 461
        num_short_options ++;
      }
#line 456
      o ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 464
    tmp___2 = malloc(sizeof(struct hol_entry ) * (unsigned long )hol->num_entries);
#line 464
    hol->entries = (struct hol_entry *)tmp___2;
#line 465
    tmp___3 = malloc((size_t )(num_short_options + 1U));
#line 465
    hol->short_options = (char *)tmp___3;
    }
#line 467
    if (hol->entries) {
#line 467
      if (! hol->short_options) {
        {
#line 467
        __assert_fail("hol->entries && hol->short_options", "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-help.c",
                      467U, "make_hol");
        }
      }
    } else {
      {
#line 467
      __assert_fail("hol->entries && hol->short_options", "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-help.c",
                    467U, "make_hol");
      }
    }
#line 472
    so = hol->short_options;
#line 473
    o = opts;
#line 473
    entry = hol->entries;
    {
#line 473
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 473
      tmp___9 = _option_is_end(o);
      }
#line 473
      if (tmp___9) {
#line 473
        goto while_break___0;
      }
#line 475
      entry->opt = o;
#line 476
      entry->num = 0U;
#line 477
      entry->short_options = so;
#line 478
      if (o->group) {
#line 478
        cur_group = (int )o->group;
      } else {
#line 478
        if (! o->name) {
#line 478
          if (! o->key) {
#line 478
            tmp___4 = cur_group + 1;
          } else {
#line 478
            tmp___4 = cur_group;
          }
        } else {
#line 478
          tmp___4 = cur_group;
        }
#line 478
        cur_group = tmp___4;
      }
#line 478
      entry->group = cur_group;
#line 484
      entry->cluster = cluster;
#line 485
      entry->argp = argp___0;
      {
#line 487
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 489
        (entry->num) ++;
#line 490
        tmp___6 = _option_is_short(o);
        }
#line 490
        if (tmp___6) {
          {
#line 490
          tmp___7 = find_char((char )o->key, hol->short_options, so);
          }
#line 490
          if (! tmp___7) {
#line 492
            tmp___5 = so;
#line 492
            so ++;
#line 492
            *tmp___5 = (char )o->key;
          }
        }
        {
#line 493
        o ++;
#line 487
        tmp___8 = _option_is_end(o);
        }
#line 487
        if (tmp___8) {
#line 487
          goto while_break___1;
        } else
#line 487
        if (! (o->flags & 4)) {
#line 487
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 473
      entry ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 497
    *so = (char )'\000';
  }
#line 500
  return (hol);
}
}
#line 506 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-help.c"
static struct hol_cluster *hol_add_cluster(struct hol *hol , int group , char const   *header ,
                                           int index___0 , struct hol_cluster *parent ,
                                           struct argp  const  *argp___0 ) 
{ 
  struct hol_cluster *cl ;
  void *tmp ;

  {
  {
#line 510
  tmp = malloc(sizeof(struct hol_cluster ));
#line 510
  cl = (struct hol_cluster *)tmp;
  }
#line 511
  if (cl) {
#line 513
    cl->group = group;
#line 514
    cl->header = header;
#line 516
    cl->index = index___0;
#line 517
    cl->parent = parent;
#line 518
    cl->argp = argp___0;
#line 519
    if (parent) {
#line 519
      cl->depth = parent->depth + 1;
    } else {
#line 519
      cl->depth = 0;
    }
#line 521
    cl->next = hol->clusters;
#line 522
    hol->clusters = cl;
  }
#line 524
  return (cl);
}
}
#line 528 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-help.c"
static void hol_free(struct hol *hol ) 
{ 
  struct hol_cluster *cl ;
  struct hol_cluster *next ;

  {
#line 531
  cl = hol->clusters;
  {
#line 533
  while (1) {
    while_continue: /* CIL Label */ ;
#line 533
    if (! cl) {
#line 533
      goto while_break;
    }
    {
#line 535
    next = cl->next;
#line 536
    free((void *)cl);
#line 537
    cl = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 540
  if (hol->num_entries > 0U) {
    {
#line 542
    free((void *)hol->entries);
#line 543
    free((void *)hol->short_options);
    }
  }
  {
#line 546
  free((void *)hol);
  }
#line 547
  return;
}
}
#line 549 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-help.c"
static int hol_entry_short_iterate(struct hol_entry  const  *entry , int (*func)(struct argp_option  const  *opt ,
                                                                                 struct argp_option  const  *real ,
                                                                                 char const   *domain ,
                                                                                 void *cookie ) ,
                                   char const   *domain , void *cookie ) 
{ 
  unsigned int nopts ;
  int val ;
  struct argp_option  const  *opt ;
  struct argp_option  const  *real ;
  char *so ;
  int tmp ;

  {
#line 557
  val = 0;
#line 558
  real = (struct argp_option  const  *)entry->opt;
#line 559
  so = (char *)entry->short_options;
#line 561
  opt = real;
#line 561
  nopts = (unsigned int )entry->num;
  {
#line 561
  while (1) {
    while_continue: /* CIL Label */ ;
#line 561
    if (nopts > 0U) {
#line 561
      if (! (! val)) {
#line 561
        goto while_break;
      }
    } else {
#line 561
      goto while_break;
    }
    {
#line 562
    tmp = _option_is_short(opt);
    }
#line 562
    if (tmp) {
#line 562
      if ((int )*so == (int )opt->key) {
#line 564
        if (! (opt->flags & 4)) {
#line 565
          real = opt;
        }
#line 566
        if (! (opt->flags & 2)) {
          {
#line 567
          val = (*func)(opt, real, domain, cookie);
          }
        }
#line 568
        so ++;
      }
    }
#line 561
    opt ++;
#line 561
    nopts --;
  }
  while_break: /* CIL Label */ ;
  }
#line 571
  return (val);
}
}
#line 574 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-help.c"
__inline static int ( __attribute__((__always_inline__)) hol_entry_long_iterate)(struct hol_entry  const  *entry ,
                                                                                 int (*func)(struct argp_option  const  *opt ,
                                                                                             struct argp_option  const  *real ,
                                                                                             char const   *domain ,
                                                                                             void *cookie ) ,
                                                                                 char const   *domain ,
                                                                                 void *cookie ) 
{ 
  unsigned int nopts ;
  int val ;
  struct argp_option  const  *opt ;
  struct argp_option  const  *real ;

  {
#line 583
  val = 0;
#line 584
  real = (struct argp_option  const  *)entry->opt;
#line 586
  opt = real;
#line 586
  nopts = (unsigned int )entry->num;
  {
#line 586
  while (1) {
    while_continue: /* CIL Label */ ;
#line 586
    if (nopts > 0U) {
#line 586
      if (! (! val)) {
#line 586
        goto while_break;
      }
    } else {
#line 586
      goto while_break;
    }
#line 587
    if (opt->name) {
#line 589
      if (! (opt->flags & 4)) {
#line 590
        real = opt;
      }
#line 591
      if (! (opt->flags & 2)) {
        {
#line 592
        val = (*func)(opt, real, domain, cookie);
        }
      }
    }
#line 586
    opt ++;
#line 586
    nopts --;
  }
  while_break: /* CIL Label */ ;
  }
#line 595
  return (val);
}
}
#line 599 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-help.c"
static int until_short(struct argp_option  const  *opt , struct argp_option  const  *real ,
                       char const   *domain , void *cookie ) 
{ 
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 603
  tmp___1 = _option_is_short(opt);
  }
#line 603
  if (tmp___1) {
#line 603
    tmp___0 = opt->key;
  } else {
#line 603
    tmp___0 = (int const   )0;
  }
#line 603
  return ((int )tmp___0);
}
}
#line 607 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-help.c"
static char hol_entry_first_short(struct hol_entry  const  *entry ) 
{ 
  int tmp ;

  {
  {
#line 610
  tmp = hol_entry_short_iterate(entry, & until_short, (char const   *)(entry->argp)->argp_domain,
                                (void *)0);
  }
#line 610
  return ((char )tmp);
}
}
#line 615 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-help.c"
static char const   *hol_entry_first_long(struct hol_entry  const  *entry ) 
{ 
  struct argp_option  const  *opt ;
  unsigned int num ;

  {
#line 620
  opt = (struct argp_option  const  *)entry->opt;
#line 620
  num = (unsigned int )entry->num;
  {
#line 620
  while (1) {
    while_continue: /* CIL Label */ ;
#line 620
    if (! (num > 0U)) {
#line 620
      goto while_break;
    }
#line 621
    if (opt->name) {
#line 621
      if (! (opt->flags & 2)) {
#line 622
        return ((char const   *)opt->name);
      }
    }
#line 620
    opt ++;
#line 620
    num --;
  }
  while_break: /* CIL Label */ ;
  }
#line 623
  return ((char const   *)0);
}
}
#line 628 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-help.c"
static struct hol_entry *hol_find_entry(struct hol *hol , char const   *name ) 
{ 
  struct hol_entry *entry ;
  unsigned int num_entries ;
  struct argp_option  const  *opt ;
  unsigned int num_opts ;
  int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 631
  entry = hol->entries;
#line 632
  num_entries = hol->num_entries;
  {
#line 634
  while (1) {
    while_continue: /* CIL Label */ ;
#line 634
    tmp___1 = num_entries;
#line 634
    num_entries --;
#line 634
    if (! (tmp___1 > 0U)) {
#line 634
      goto while_break;
    }
#line 636
    opt = entry->opt;
#line 637
    num_opts = entry->num;
    {
#line 639
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 639
      tmp___0 = num_opts;
#line 639
      num_opts --;
#line 639
      if (! (tmp___0 > 0U)) {
#line 639
        goto while_break___0;
      }
#line 640
      if (opt->name) {
#line 640
        if (! (opt->flags & 2)) {
          {
#line 640
          tmp = strcmp((char const   *)opt->name, name);
          }
#line 640
          if (tmp == 0) {
#line 641
            return (entry);
          } else {
#line 643
            opt ++;
          }
        } else {
#line 643
          opt ++;
        }
      } else {
#line 643
        opt ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 645
    entry ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 648
  return ((struct hol_entry *)0);
}
}
#line 653 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-help.c"
static void hol_set_group(struct hol *hol , char const   *name , int group ) 
{ 
  struct hol_entry *entry ;
  struct hol_entry *tmp ;

  {
  {
#line 656
  tmp = hol_find_entry(hol, name);
#line 656
  entry = tmp;
  }
#line 657
  if (entry) {
#line 658
    entry->group = group;
  }
#line 659
  return;
}
}
#line 663 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-help.c"
static int group_cmp(int group1 , int group2 , int eq ) 
{ 


  {
#line 666
  if (group1 == group2) {
#line 667
    return (eq);
  } else
#line 668
  if (group1 < 0) {
#line 668
    if (group2 < 0) {
#line 669
      return (group1 - group2);
    } else {
#line 668
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 668
  if (group1 >= 0) {
#line 668
    if (group2 >= 0) {
#line 669
      return (group1 - group2);
    } else {
#line 671
      return (group2 - group1);
    }
  } else {
#line 671
    return (group2 - group1);
  }
}
}
#line 676 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-help.c"
static int hol_cluster_cmp(struct hol_cluster  const  *cl1 , struct hol_cluster  const  *cl2 ) 
{ 
  int tmp ;

  {
  {
#line 683
  while (1) {
    while_continue: /* CIL Label */ ;
#line 683
    if (! (cl1->depth > cl2->depth)) {
#line 683
      goto while_break;
    }
#line 684
    cl1 = (struct hol_cluster  const  *)cl1->parent;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 685
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 685
    if (! (cl2->depth > cl1->depth)) {
#line 685
      goto while_break___0;
    }
#line 686
    cl2 = (struct hol_cluster  const  *)cl2->parent;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 690
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 690
    if (! ((unsigned long )cl1->parent != (unsigned long )cl2->parent)) {
#line 690
      goto while_break___1;
    }
#line 691
    cl1 = (struct hol_cluster  const  *)cl1->parent;
#line 691
    cl2 = (struct hol_cluster  const  *)cl2->parent;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 693
  tmp = group_cmp((int )cl1->group, (int )cl2->group, (int )(cl2->index - cl1->index));
  }
#line 693
  return (tmp);
}
}
#line 698 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-help.c"
static struct hol_cluster *hol_cluster_base(struct hol_cluster *cl ) 
{ 


  {
  {
#line 701
  while (1) {
    while_continue: /* CIL Label */ ;
#line 701
    if (! cl->parent) {
#line 701
      goto while_break;
    }
#line 702
    cl = cl->parent;
  }
  while_break: /* CIL Label */ ;
  }
#line 703
  return (cl);
}
}
#line 707 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-help.c"
static int hol_cluster_is_child(struct hol_cluster  const  *cl1 , struct hol_cluster  const  *cl2 ) 
{ 


  {
  {
#line 711
  while (1) {
    while_continue: /* CIL Label */ ;
#line 711
    if (cl1) {
#line 711
      if (! ((unsigned long )cl1 != (unsigned long )cl2)) {
#line 711
        goto while_break;
      }
    } else {
#line 711
      goto while_break;
    }
#line 712
    cl1 = (struct hol_cluster  const  *)cl1->parent;
  }
  while_break: /* CIL Label */ ;
  }
#line 713
  return ((unsigned long )cl1 == (unsigned long )cl2);
}
}
#line 719 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-help.c"
static int canon_doc_option(char const   **name ) 
{ 
  int non_opt ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;

  {
#line 724
  if (! *name) {
#line 725
    non_opt = 1;
  } else {
    {
#line 729
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 729
      tmp = __ctype_b_loc();
      }
#line 729
      if (! ((int const   )*(*tmp + (int )((unsigned char )*(*name))) & 8192)) {
#line 729
        goto while_break;
      }
#line 730
      (*name) ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 732
    non_opt = (int const   )*(*name) != 45;
    {
#line 734
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 734
      if (*(*name)) {
        {
#line 734
        tmp___0 = __ctype_b_loc();
        }
#line 734
        if ((int const   )*(*tmp___0 + (int )((unsigned char )*(*name))) & 8) {
#line 734
          goto while_break___0;
        }
      } else {
#line 734
        goto while_break___0;
      }
#line 735
      (*name) ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 737
  return (non_opt);
}
}
#line 744 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-help.c"
static int hol_entry_cmp(struct hol_entry  const  *entry1 , struct hol_entry  const  *entry2 ) 
{ 
  int group1 ;
  int group2 ;
  int rc ;
  struct hol_cluster *tmp ;
  int tmp___0 ;
  struct hol_cluster *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int short1 ;
  char tmp___5 ;
  int short2 ;
  char tmp___6 ;
  int doc1 ;
  int doc2 ;
  char const   *long1 ;
  char const   *tmp___7 ;
  char const   *long2 ;
  char const   *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  unsigned char first1 ;
  int tmp___11 ;
  int tmp___12 ;
  unsigned char first2 ;
  int tmp___13 ;
  int tmp___14 ;
  int lower_cmp ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;

  {
#line 750
  group1 = (int )entry1->group;
#line 750
  group2 = (int )entry2->group;
#line 753
  if ((unsigned long )entry1->cluster != (unsigned long )entry2->cluster) {
#line 757
    if (! entry1->cluster) {
      {
#line 762
      tmp = hol_cluster_base((struct hol_cluster *)entry2->cluster);
#line 762
      tmp___0 = group_cmp(group1, tmp->group, -1);
      }
#line 762
      return (tmp___0);
    } else
#line 763
    if (! entry2->cluster) {
      {
#line 765
      tmp___1 = hol_cluster_base((struct hol_cluster *)entry1->cluster);
#line 765
      tmp___2 = group_cmp(tmp___1->group, group2, 1);
      }
#line 765
      return (tmp___2);
    } else {
      {
#line 768
      rc = hol_cluster_cmp((struct hol_cluster  const  *)entry1->cluster, (struct hol_cluster  const  *)entry2->cluster);
      }
#line 768
      if (rc) {
#line 768
        tmp___4 = rc;
      } else {
#line 768
        if (entry1->ord < entry2->ord) {
#line 768
          tmp___3 = -1;
        } else {
#line 768
          tmp___3 = 1;
        }
#line 768
        tmp___4 = tmp___3;
      }
#line 768
      return (tmp___4);
    }
  } else
#line 771
  if (group1 == group2) {
    {
#line 775
    tmp___5 = hol_entry_first_short(entry1);
#line 775
    short1 = (int )tmp___5;
#line 776
    tmp___6 = hol_entry_first_short(entry2);
#line 776
    short2 = (int )tmp___6;
#line 777
    doc1 = (int )((entry1->opt)->flags & 8);
#line 778
    doc2 = (int )((entry2->opt)->flags & 8);
#line 779
    tmp___7 = hol_entry_first_long(entry1);
#line 779
    long1 = tmp___7;
#line 780
    tmp___8 = hol_entry_first_long(entry2);
#line 780
    long2 = tmp___8;
    }
#line 782
    if (doc1) {
      {
#line 783
      doc1 = canon_doc_option(& long1);
      }
    }
#line 784
    if (doc2) {
      {
#line 785
      doc2 = canon_doc_option(& long2);
      }
    }
#line 787
    if (doc1 != doc2) {
#line 790
      return (doc1 - doc2);
    } else
#line 791
    if (! short1) {
#line 791
      if (! short2) {
#line 791
        if (long1) {
#line 791
          if (long2) {
            {
#line 793
            rc = strcasecmp(long1, long2);
            }
#line 793
            if (rc) {
#line 793
              tmp___10 = rc;
            } else {
#line 793
              if (entry1->ord < entry2->ord) {
#line 793
                tmp___9 = -1;
              } else {
#line 793
                tmp___9 = 1;
              }
#line 793
              tmp___10 = tmp___9;
            }
#line 793
            return (tmp___10);
          } else {
#line 791
            goto _L___1;
          }
        } else {
#line 791
          goto _L___1;
        }
      } else {
#line 791
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
#line 802
      if (short1) {
#line 802
        tmp___12 = short1;
      } else {
#line 802
        if (long1) {
#line 802
          tmp___11 = (int const   )*long1;
        } else {
#line 802
          tmp___11 = (int const   )0;
        }
#line 802
        tmp___12 = (int )tmp___11;
      }
#line 802
      first1 = (unsigned char )tmp___12;
#line 803
      if (short2) {
#line 803
        tmp___14 = short2;
      } else {
#line 803
        if (long2) {
#line 803
          tmp___13 = (int const   )*long2;
        } else {
#line 803
          tmp___13 = (int const   )0;
        }
#line 803
        tmp___14 = (int )tmp___13;
      }
      {
#line 803
      first2 = (unsigned char )tmp___14;
#line 806
      tmp___15 = tolower((int )first1);
#line 806
      tmp___16 = tolower((int )first2);
#line 806
      lower_cmp = tmp___15 - tmp___16;
      }
#line 809
      if (lower_cmp) {
#line 809
        tmp___19 = lower_cmp;
      } else {
#line 809
        rc = (int )first2 - (int )first1;
#line 809
        if (rc) {
#line 809
          tmp___18 = rc;
        } else {
#line 809
          if (entry1->ord < entry2->ord) {
#line 809
            tmp___17 = -1;
          } else {
#line 809
            tmp___17 = 1;
          }
#line 809
          tmp___18 = tmp___17;
        }
#line 809
        tmp___19 = tmp___18;
      }
#line 809
      return (tmp___19);
    }
  } else {
#line 817
    if (entry1->ord < entry2->ord) {
#line 817
      tmp___20 = -1;
    } else {
#line 817
      tmp___20 = 1;
    }
    {
#line 817
    tmp___21 = group_cmp(group1, group2, tmp___20);
    }
#line 817
    return (tmp___21);
  }
}
}
#line 821 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-help.c"
static int hol_entry_qcmp(void const   *entry1_v , void const   *entry2_v ) 
{ 
  int tmp ;

  {
  {
#line 824
  tmp = hol_entry_cmp((struct hol_entry  const  *)entry1_v, (struct hol_entry  const  *)entry2_v);
  }
#line 824
  return (tmp);
}
}
#line 830 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-help.c"
static void hol_sort(struct hol *hol ) 
{ 
  unsigned int i ;
  struct hol_entry *e ;

  {
#line 833
  if (hol->num_entries > 0U) {
#line 837
    i = 0U;
#line 837
    e = hol->entries;
    {
#line 837
    while (1) {
      while_continue: /* CIL Label */ ;
#line 837
      if (! (i < hol->num_entries)) {
#line 837
        goto while_break;
      }
#line 838
      e->ord = i;
#line 837
      i ++;
#line 837
      e ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 839
    qsort((void *)hol->entries, (size_t )hol->num_entries, sizeof(struct hol_entry ),
          & hol_entry_qcmp);
    }
  }
#line 842
  return;
}
}
#line 846 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-help.c"
static void hol_append(struct hol *hol , struct hol *more ) 
{ 
  struct hol_cluster **cl_end ;
  unsigned int left ;
  char *so ;
  char *more_so ;
  struct hol_entry *e ;
  unsigned int num_entries ;
  struct hol_entry *entries ;
  void *tmp ;
  unsigned int hol_so_len ;
  size_t tmp___0 ;
  char *short_options ;
  size_t tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int opts_left ;
  struct argp_option  const  *opt ;
  int ch ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 849
  cl_end = & hol->clusters;
  {
#line 852
  while (1) {
    while_continue: /* CIL Label */ ;
#line 852
    if (! *cl_end) {
#line 852
      goto while_break;
    }
#line 853
    cl_end = & (*cl_end)->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 854
  *cl_end = more->clusters;
#line 855
  more->clusters = (struct hol_cluster *)0;
#line 858
  if (more->num_entries > 0U) {
#line 860
    if (hol->num_entries == 0U) {
#line 862
      hol->num_entries = more->num_entries;
#line 863
      hol->entries = more->entries;
#line 864
      hol->short_options = more->short_options;
#line 865
      more->num_entries = 0U;
    } else {
      {
#line 874
      num_entries = hol->num_entries + more->num_entries;
#line 875
      tmp = malloc((unsigned long )num_entries * sizeof(struct hol_entry ));
#line 875
      entries = (struct hol_entry *)tmp;
#line 877
      tmp___0 = strlen((char const   *)hol->short_options);
#line 877
      hol_so_len = (unsigned int )tmp___0;
#line 878
      tmp___1 = strlen((char const   *)more->short_options);
#line 878
      tmp___2 = malloc(((size_t )hol_so_len + tmp___1) + 1UL);
#line 878
      short_options = (char *)tmp___2;
      }
#line 881
      if (entries) {
#line 881
        if (! short_options) {
          {
#line 881
          __assert_fail("entries && short_options", "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-help.c",
                        881U, "hol_append");
          }
        }
      } else {
        {
#line 881
        __assert_fail("entries && short_options", "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-help.c",
                      881U, "hol_append");
        }
      }
      {
#line 885
      tmp___3 = mempcpy((void */* __restrict  */)entries, (void const   */* __restrict  */)hol->entries,
                        (unsigned long )hol->num_entries * sizeof(struct hol_entry ));
#line 885
      mempcpy((void */* __restrict  */)tmp___3, (void const   */* __restrict  */)more->entries,
              (unsigned long )more->num_entries * sizeof(struct hol_entry ));
#line 890
      mempcpy((void */* __restrict  */)short_options, (void const   */* __restrict  */)hol->short_options,
              (size_t )hol_so_len);
#line 893
      e = entries;
#line 893
      left = hol->num_entries;
      }
      {
#line 893
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 893
        if (! (left > 0U)) {
#line 893
          goto while_break___0;
        }
#line 894
        e->short_options += short_options - hol->short_options;
#line 893
        e ++;
#line 893
        left --;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 898
      so = short_options + hol_so_len;
#line 899
      more_so = more->short_options;
#line 900
      left = more->num_entries;
      {
#line 900
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 900
        if (! (left > 0U)) {
#line 900
          goto while_break___1;
        }
#line 905
        e->short_options = so;
#line 907
        opts_left = (int )e->num;
#line 907
        opt = e->opt;
        {
#line 907
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 907
          if (! opts_left) {
#line 907
            goto while_break___2;
          }
          {
#line 909
          ch = (int )*more_so;
#line 910
          tmp___6 = _option_is_short(opt);
          }
#line 910
          if (tmp___6) {
#line 910
            if (ch == (int )opt->key) {
              {
#line 913
              tmp___5 = find_char((char )ch, short_options, short_options + hol_so_len);
              }
#line 913
              if (! tmp___5) {
#line 917
                tmp___4 = so;
#line 917
                so ++;
#line 917
                *tmp___4 = (char )ch;
              }
#line 918
              more_so ++;
            }
          }
#line 907
          opt ++;
#line 907
          opts_left --;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 900
        e ++;
#line 900
        left --;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 923
      *so = (char )'\000';
#line 925
      free((void *)hol->entries);
#line 926
      free((void *)hol->short_options);
#line 928
      hol->entries = entries;
#line 929
      hol->num_entries = num_entries;
#line 930
      hol->short_options = short_options;
      }
    }
  }
  {
#line 934
  hol_free(more);
  }
#line 935
  return;
}
}
#line 938 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-help.c"
static void indent_to(argp_fmtstream_t stream , unsigned int col ) 
{ 
  int needed ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 941
  tmp = argp_fmtstream_point(stream);
#line 941
  needed = (int )((size_t )col - tmp);
  }
  {
#line 942
  while (1) {
    while_continue: /* CIL Label */ ;
#line 942
    tmp___0 = needed;
#line 942
    needed --;
#line 942
    if (! (tmp___0 > 0)) {
#line 942
      goto while_break;
    }
    {
#line 943
    argp_fmtstream_putc(stream, ' ');
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 944
  return;
}
}
#line 948 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-help.c"
static void space(argp_fmtstream_t stream , size_t ensure ) 
{ 
  size_t tmp ;

  {
  {
#line 951
  tmp = argp_fmtstream_point(stream);
  }
#line 951
  if (tmp + ensure >= stream->rmargin) {
    {
#line 953
    argp_fmtstream_putc(stream, '\n');
    }
  } else {
    {
#line 955
    argp_fmtstream_putc(stream, ' ');
    }
  }
#line 956
  return;
}
}
#line 961 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-help.c"
static void arg(struct argp_option  const  *real , char const   *req_fmt , char const   *opt_fmt ,
                char const   *domain , argp_fmtstream_t stream ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
#line 965
  if (real->arg) {
#line 967
    if (real->flags & 1) {
      {
#line 968
      tmp = dgettext(domain, (char const   *)real->arg);
#line 968
      argp_fmtstream_printf(stream, opt_fmt, tmp);
      }
    } else {
      {
#line 971
      tmp___0 = dgettext(domain, (char const   *)real->arg);
#line 971
      argp_fmtstream_printf(stream, req_fmt, tmp___0);
      }
    }
  }
#line 974
  return;
}
}
#line 1010 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-help.c"
static char const   *filter_doc(char const   *doc___0 , int key , struct argp  const  *argp___0 ,
                                struct argp_state  const  *state ) 
{ 
  void *input___0 ;
  void *tmp ;
  char *tmp___0 ;

  {
#line 1014
  if (argp___0->help_filter) {
    {
#line 1017
    tmp = _argp_input((struct argp  const  */* __restrict  */)argp___0, (struct argp_state  const  */* __restrict  */)state);
#line 1017
    input___0 = tmp;
#line 1018
    tmp___0 = (*(argp___0->help_filter))(key, doc___0, input___0);
    }
#line 1018
    return ((char const   *)tmp___0);
  } else {
#line 1022
    return (doc___0);
  }
}
}
#line 1030 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-help.c"
static void print_header(char const   *str , struct argp  const  *argp___0 , struct pentry_state *pest ) 
{ 
  char const   *tstr ;
  char *tmp ;
  char const   *fstr ;
  char const   *tmp___0 ;

  {
  {
#line 1034
  tmp = dgettext((char const   *)argp___0->argp_domain, str);
#line 1034
  tstr = (char const   *)tmp;
#line 1035
  tmp___0 = filter_doc(tstr, 33554435, argp___0, pest->state);
#line 1035
  fstr = tmp___0;
  }
#line 1037
  if (fstr) {
#line 1039
    if (*fstr) {
#line 1041
      if ((pest->hhstate)->prev_entry) {
        {
#line 1043
        argp_fmtstream_putc(pest->stream, '\n');
        }
      }
      {
#line 1044
      indent_to(pest->stream, (unsigned int )uparams.header_col);
#line 1045
      argp_fmtstream_set_lmargin(pest->stream, (size_t )uparams.header_col);
#line 1046
      argp_fmtstream_set_wmargin(pest->stream, (size_t )uparams.header_col);
#line 1047
      argp_fmtstream_puts(pest->stream, fstr);
#line 1048
      argp_fmtstream_set_lmargin(pest->stream, (size_t )0);
#line 1049
      argp_fmtstream_putc(pest->stream, '\n');
      }
    }
#line 1052
    (pest->hhstate)->sep_groups = 1;
  }
#line 1055
  if ((unsigned long )fstr != (unsigned long )tstr) {
    {
#line 1056
    free((void *)((char *)fstr));
    }
  }
#line 1057
  return;
}
}
#line 1063 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-help.c"
static void comma(unsigned int col , struct pentry_state *pest ) 
{ 
  struct hol_entry  const  *pe ;
  struct hol_cluster  const  *cl ;
  int old_wm ;
  int tmp ;

  {
#line 1066
  if (pest->first) {
#line 1068
    pe = (struct hol_entry  const  *)(pest->hhstate)->prev_entry;
#line 1069
    cl = (struct hol_cluster  const  *)(pest->entry)->cluster;
#line 1071
    if ((pest->hhstate)->sep_groups) {
#line 1071
      if (pe) {
#line 1071
        if ((pest->entry)->group != pe->group) {
          {
#line 1072
          argp_fmtstream_putc(pest->stream, '\n');
          }
        }
      }
    }
#line 1074
    if (cl) {
#line 1074
      if (cl->header) {
#line 1074
        if (*(cl->header)) {
#line 1074
          if (! pe) {
            {
#line 1083
            old_wm = (int )(pest->stream)->wmargin;
#line 1084
            print_header((char const   *)cl->header, (struct argp  const  *)cl->argp,
                         pest);
#line 1085
            argp_fmtstream_set_wmargin(pest->stream, (size_t )old_wm);
            }
          } else
#line 1074
          if ((unsigned long )pe->cluster != (unsigned long )cl) {
            {
#line 1074
            tmp = hol_cluster_is_child((struct hol_cluster  const  *)pe->cluster,
                                       cl);
            }
#line 1074
            if (! tmp) {
              {
#line 1083
              old_wm = (int )(pest->stream)->wmargin;
#line 1084
              print_header((char const   *)cl->header, (struct argp  const  *)cl->argp,
                           pest);
#line 1085
              argp_fmtstream_set_wmargin(pest->stream, (size_t )old_wm);
              }
            }
          }
        }
      }
    }
#line 1088
    pest->first = 0;
  } else {
    {
#line 1091
    argp_fmtstream_puts(pest->stream, ", ");
    }
  }
  {
#line 1093
  indent_to(pest->stream, col);
  }
#line 1094
  return;
}
}
#line 1097 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-help.c"
static void hol_entry_help(struct hol_entry *entry , struct argp_state  const  *state ,
                           argp_fmtstream_t stream , struct hol_help_state *hhstate ) 
{ 
  unsigned int num ;
  struct argp_option  const  *real ;
  struct argp_option  const  *opt ;
  char *so ;
  int have_long_opt ;
  int old_lm ;
  size_t tmp ;
  int old_wm ;
  struct pentry_state pest ;
  int tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  int first_long_opt ;
  int tmp___3 ;
  char const   *tstr ;
  char *tmp___4 ;
  char *tmp___5 ;
  char const   *fstr ;
  char const   *tmp___6 ;
  unsigned int col ;
  size_t tmp___7 ;

  {
  {
#line 1102
  real = entry->opt;
#line 1103
  so = entry->short_options;
#line 1104
  have_long_opt = 0;
#line 1106
  tmp = argp_fmtstream_set_lmargin(stream, (size_t )0);
#line 1106
  old_lm = (int )tmp;
#line 1107
  old_wm = (int )stream->wmargin;
#line 1112
  pest.entry = (struct hol_entry  const  *)entry;
#line 1113
  pest.stream = stream;
#line 1114
  pest.hhstate = hhstate;
#line 1115
  pest.first = 1;
#line 1116
  pest.state = state;
  }
#line 1118
  if (! (real->flags & 8)) {
#line 1119
    opt = real;
#line 1119
    num = entry->num;
    {
#line 1119
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1119
      if (! (num > 0U)) {
#line 1119
        goto while_break;
      }
#line 1120
      if (opt->name) {
#line 1120
        if (! (opt->flags & 2)) {
#line 1122
          have_long_opt = 1;
#line 1123
          goto while_break;
        }
      }
#line 1119
      opt ++;
#line 1119
      num --;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 1127
  argp_fmtstream_set_wmargin(stream, (size_t )uparams.short_opt_col);
#line 1128
  opt = real;
#line 1128
  num = entry->num;
  }
  {
#line 1128
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1128
    if (! (num > 0U)) {
#line 1128
      goto while_break___0;
    }
    {
#line 1129
    tmp___0 = _option_is_short(opt);
    }
#line 1129
    if (tmp___0) {
#line 1129
      if (opt->key == (int const   )*so) {
#line 1132
        if (! (opt->flags & 2)) {
          {
#line 1134
          comma((unsigned int )uparams.short_opt_col, & pest);
#line 1135
          argp_fmtstream_putc(stream, '-');
#line 1136
          argp_fmtstream_putc(stream, (int )*so);
          }
#line 1137
          if (! have_long_opt) {
            {
#line 1138
            arg(real, " %s", "[%s]", (char const   *)(state->root_argp)->argp_domain,
                stream);
            }
          } else
#line 1137
          if (uparams.dup_args) {
            {
#line 1138
            arg(real, " %s", "[%s]", (char const   *)(state->root_argp)->argp_domain,
                stream);
            }
          } else
#line 1139
          if (real->arg) {
#line 1140
            hhstate->suppressed_dup_arg = 1;
          }
        }
#line 1142
        so ++;
      }
    }
#line 1128
    opt ++;
#line 1128
    num --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1146
  if (real->flags & 8) {
    {
#line 1149
    argp_fmtstream_set_wmargin(stream, (size_t )uparams.doc_opt_col);
#line 1150
    opt = real;
#line 1150
    num = entry->num;
    }
    {
#line 1150
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1150
      if (! (num > 0U)) {
#line 1150
        goto while_break___1;
      }
#line 1151
      if (opt->name) {
#line 1151
        if (*(opt->name)) {
#line 1151
          if (! (opt->flags & 2)) {
            {
#line 1153
            comma((unsigned int )uparams.doc_opt_col, & pest);
            }
#line 1157
            if (opt->flags & 32) {
#line 1157
              tmp___2 = opt->name;
            } else {
              {
#line 1157
              tmp___1 = dgettext((char const   *)(state->root_argp)->argp_domain,
                                 (char const   *)opt->name);
#line 1157
              tmp___2 = (char const   */* const  */)tmp___1;
              }
            }
            {
#line 1157
            argp_fmtstream_puts(stream, (char const   *)tmp___2);
            }
          }
        }
      }
#line 1150
      opt ++;
#line 1150
      num --;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else {
    {
#line 1167
    first_long_opt = 1;
#line 1169
    argp_fmtstream_set_wmargin(stream, (size_t )uparams.long_opt_col);
#line 1170
    opt = real;
#line 1170
    num = entry->num;
    }
    {
#line 1170
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1170
      if (! (num > 0U)) {
#line 1170
        goto while_break___2;
      }
#line 1171
      if (opt->name) {
#line 1171
        if (! (opt->flags & 2)) {
          {
#line 1173
          comma((unsigned int )uparams.long_opt_col, & pest);
#line 1174
          argp_fmtstream_printf(stream, "--%s", opt->name);
          }
#line 1175
          if (first_long_opt) {
            {
#line 1176
            arg(real, "=%s", "[=%s]", (char const   *)(state->root_argp)->argp_domain,
                stream);
            }
          } else
#line 1175
          if (uparams.dup_args) {
            {
#line 1176
            arg(real, "=%s", "[=%s]", (char const   *)(state->root_argp)->argp_domain,
                stream);
            }
          } else
#line 1178
          if (real->arg) {
#line 1179
            hhstate->suppressed_dup_arg = 1;
          }
        }
      }
#line 1170
      opt ++;
#line 1170
      num --;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  {
#line 1184
  argp_fmtstream_set_lmargin(stream, (size_t )0);
  }
#line 1186
  if (pest.first) {
    {
#line 1189
    tmp___3 = _option_is_short(real);
    }
#line 1189
    if (tmp___3) {
#line 1194
      goto cleanup;
    } else
#line 1189
    if (! real->name) {
      {
#line 1191
      print_header((char const   *)real->doc, entry->argp, & pest);
      }
    } else {
#line 1194
      goto cleanup;
    }
  } else {
#line 1198
    if (real->doc) {
      {
#line 1198
      tmp___4 = dgettext((char const   *)(state->root_argp)->argp_domain, (char const   *)real->doc);
#line 1198
      tmp___5 = tmp___4;
      }
    } else {
#line 1198
      tmp___5 = (char *)0;
    }
    {
#line 1198
    tstr = (char const   *)tmp___5;
#line 1200
    tmp___6 = filter_doc(tstr, (int )real->key, entry->argp, state);
#line 1200
    fstr = tmp___6;
    }
#line 1201
    if (fstr) {
#line 1201
      if (*fstr) {
        {
#line 1203
        tmp___7 = argp_fmtstream_point(stream);
#line 1203
        col = (unsigned int )tmp___7;
#line 1205
        argp_fmtstream_set_lmargin(stream, (size_t )uparams.opt_doc_col);
#line 1206
        argp_fmtstream_set_wmargin(stream, (size_t )uparams.opt_doc_col);
        }
#line 1208
        if (col > (unsigned int )(uparams.opt_doc_col + 3)) {
          {
#line 1209
          argp_fmtstream_putc(stream, '\n');
          }
        } else
#line 1210
        if (col >= (unsigned int )uparams.opt_doc_col) {
          {
#line 1211
          argp_fmtstream_puts(stream, "   ");
          }
        } else {
          {
#line 1213
          indent_to(stream, (unsigned int )uparams.opt_doc_col);
          }
        }
        {
#line 1215
        argp_fmtstream_puts(stream, fstr);
        }
      }
    }
#line 1217
    if (fstr) {
#line 1217
      if ((unsigned long )fstr != (unsigned long )tstr) {
        {
#line 1218
        free((void *)((char *)fstr));
        }
      }
    }
    {
#line 1221
    argp_fmtstream_set_lmargin(stream, (size_t )0);
#line 1222
    argp_fmtstream_putc(stream, '\n');
    }
  }
#line 1225
  hhstate->prev_entry = entry;
  cleanup: 
  {
#line 1228
  argp_fmtstream_set_lmargin(stream, (size_t )old_lm);
#line 1229
  argp_fmtstream_set_wmargin(stream, (size_t )old_wm);
  }
#line 1230
  return;
}
}
#line 1233 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-help.c"
static void hol_help(struct hol *hol , struct argp_state  const  *state , argp_fmtstream_t stream ) 
{ 
  unsigned int num ;
  struct hol_entry *entry ;
  struct hol_help_state hhstate ;
  char const   *tstr ;
  char *tmp ;
  char const   *fstr ;
  struct argp  const  *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 1239
  hhstate.prev_entry = (struct hol_entry *)0;
#line 1239
  hhstate.sep_groups = 0;
#line 1239
  hhstate.suppressed_dup_arg = 0;
#line 1241
  entry = hol->entries;
#line 1241
  num = hol->num_entries;
  {
#line 1241
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1241
    if (! (num > 0U)) {
#line 1241
      goto while_break;
    }
    {
#line 1242
    hol_entry_help(entry, state, stream, & hhstate);
#line 1241
    entry ++;
#line 1241
    num --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1244
  if (hhstate.suppressed_dup_arg) {
#line 1244
    if (uparams.dup_args_note) {
      {
#line 1246
      tmp = dgettext((char const   *)(state->root_argp)->argp_domain, "Mandatory or optional arguments to long options are also mandatory or optional for any corresponding short options.");
#line 1246
      tstr = (char const   *)tmp;
      }
#line 1249
      if (state) {
#line 1249
        tmp___0 = state->root_argp;
      } else {
#line 1249
        tmp___0 = (struct argp  const  */* const  */)0;
      }
      {
#line 1249
      tmp___1 = filter_doc(tstr, 33554437, (struct argp  const  *)tmp___0, state);
#line 1249
      fstr = tmp___1;
      }
#line 1251
      if (fstr) {
#line 1251
        if (*fstr) {
          {
#line 1253
          argp_fmtstream_putc(stream, '\n');
#line 1254
          argp_fmtstream_puts(stream, fstr);
#line 1255
          argp_fmtstream_putc(stream, '\n');
          }
        }
      }
#line 1257
      if (fstr) {
#line 1257
        if ((unsigned long )fstr != (unsigned long )tstr) {
          {
#line 1258
          free((void *)((char *)fstr));
          }
        }
      }
    }
  }
#line 1260
  return;
}
}
#line 1266 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-help.c"
static int add_argless_short_opt(struct argp_option  const  *opt , struct argp_option  const  *real ,
                                 char const   *domain , void *cookie ) 
{ 
  char **snao_end ;
  char *tmp ;

  {
#line 1271
  snao_end = (char **)cookie;
#line 1272
  if (! opt->arg) {
#line 1272
    if (! real->arg) {
#line 1272
      if (! ((opt->flags | real->flags) & 16)) {
#line 1274
        tmp = *snao_end;
#line 1274
        (*snao_end) ++;
#line 1274
        *tmp = (char )opt->key;
      }
    }
  }
#line 1275
  return (0);
}
}
#line 1280 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-help.c"
static int usage_argful_short_opt(struct argp_option  const  *opt , struct argp_option  const  *real ,
                                  char const   *domain , void *cookie ) 
{ 
  argp_fmtstream_t stream ;
  char const   *arg___0 ;
  int flags ;
  char *tmp ;
  size_t tmp___0 ;

  {
#line 1285
  stream = (argp_fmtstream_t )cookie;
#line 1286
  arg___0 = (char const   *)opt->arg;
#line 1287
  flags = (int )(opt->flags | real->flags);
#line 1289
  if (! arg___0) {
#line 1290
    arg___0 = (char const   *)real->arg;
  }
#line 1292
  if (arg___0) {
#line 1292
    if (! (flags & 16)) {
      {
#line 1294
      tmp = dgettext(domain, arg___0);
#line 1294
      arg___0 = (char const   *)tmp;
      }
#line 1296
      if (flags & 1) {
        {
#line 1297
        argp_fmtstream_printf(stream, " [-%c[%s]]", opt->key, arg___0);
        }
      } else {
        {
#line 1302
        tmp___0 = strlen(arg___0);
#line 1302
        space(stream, 6UL + tmp___0);
#line 1303
        argp_fmtstream_printf(stream, "[-%c %s]", opt->key, arg___0);
        }
      }
    }
  }
#line 1307
  return (0);
}
}
#line 1312 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-help.c"
static int usage_long_opt(struct argp_option  const  *opt , struct argp_option  const  *real ,
                          char const   *domain , void *cookie ) 
{ 
  argp_fmtstream_t stream ;
  char const   *arg___0 ;
  int flags ;
  char *tmp ;

  {
#line 1317
  stream = (argp_fmtstream_t )cookie;
#line 1318
  arg___0 = (char const   *)opt->arg;
#line 1319
  flags = (int )(opt->flags | real->flags);
#line 1321
  if (! arg___0) {
#line 1322
    arg___0 = (char const   *)real->arg;
  }
#line 1324
  if (! (flags & 16)) {
#line 1324
    if (! (opt->flags & 8)) {
#line 1326
      if (arg___0) {
        {
#line 1328
        tmp = dgettext(domain, arg___0);
#line 1328
        arg___0 = (char const   *)tmp;
        }
#line 1329
        if (flags & 1) {
          {
#line 1330
          argp_fmtstream_printf(stream, " [--%s[=%s]]", opt->name, arg___0);
          }
        } else {
          {
#line 1332
          argp_fmtstream_printf(stream, " [--%s=%s]", opt->name, arg___0);
          }
        }
      } else {
        {
#line 1335
        argp_fmtstream_printf(stream, " [--%s]", opt->name);
        }
      }
    }
  }
#line 1338
  return (0);
}
}
#line 1342 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-help.c"
static void hol_usage(struct hol *hol , argp_fmtstream_t stream ) 
{ 
  unsigned int nentries ;
  struct hol_entry *entry ;
  char *short_no_arg_opts ;
  size_t tmp ;
  void *tmp___0 ;
  char *snao_end ;
  char *tmp___1 ;

  {
#line 1345
  if (hol->num_entries > 0U) {
    {
#line 1349
    tmp = strlen((char const   *)hol->short_options);
#line 1349
    tmp___0 = __builtin_alloca(tmp + 1UL);
#line 1349
    short_no_arg_opts = (char *)tmp___0;
#line 1350
    snao_end = short_no_arg_opts;
#line 1353
    entry = hol->entries;
#line 1353
    nentries = hol->num_entries;
    }
    {
#line 1353
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1353
      if (! (nentries > 0U)) {
#line 1353
        goto while_break;
      }
      {
#line 1356
      hol_entry_short_iterate((struct hol_entry  const  *)entry, & add_argless_short_opt,
                              (char const   *)(entry->argp)->argp_domain, (void *)(& snao_end));
#line 1353
      entry ++;
#line 1353
      nentries --;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 1358
    if ((unsigned long )snao_end > (unsigned long )short_no_arg_opts) {
      {
#line 1360
      tmp___1 = snao_end;
#line 1360
      snao_end ++;
#line 1360
      *tmp___1 = (char)0;
#line 1361
      argp_fmtstream_printf(stream, " [-%s]", short_no_arg_opts);
      }
    }
#line 1365
    entry = hol->entries;
#line 1365
    nentries = hol->num_entries;
    {
#line 1365
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1365
      if (! (nentries > 0U)) {
#line 1365
        goto while_break___0;
      }
      {
#line 1368
      hol_entry_short_iterate((struct hol_entry  const  *)entry, & usage_argful_short_opt,
                              (char const   *)(entry->argp)->argp_domain, (void *)stream);
#line 1365
      entry ++;
#line 1365
      nentries --;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1372
    entry = hol->entries;
#line 1372
    nentries = hol->num_entries;
    {
#line 1372
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1372
      if (! (nentries > 0U)) {
#line 1372
        goto while_break___1;
      }
      {
#line 1375
      hol_entry_long_iterate((struct hol_entry  const  *)entry, & usage_long_opt,
                             (char const   *)(entry->argp)->argp_domain, (void *)stream);
#line 1372
      entry ++;
#line 1372
      nentries --;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1378
  return;
}
}
#line 1382 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-help.c"
static struct hol *argp_hol(struct argp  const  *argp___0 , struct hol_cluster *cluster ) 
{ 
  struct argp_child  const  *child ;
  struct hol *hol ;
  struct hol *tmp ;
  struct hol_cluster *child_cluster ;
  struct hol_cluster *tmp___0 ;
  struct hol_cluster *tmp___1 ;
  struct hol *tmp___2 ;

  {
  {
#line 1385
  child = (struct argp_child  const  *)argp___0->children;
#line 1386
  tmp = make_hol(argp___0, cluster);
#line 1386
  hol = tmp;
  }
#line 1387
  if (child) {
    {
#line 1388
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1388
      if (! child->argp) {
#line 1388
        goto while_break;
      }
#line 1390
      if (child->group) {
        {
#line 1390
        tmp___0 = hol_add_cluster(hol, (int )child->group, (char const   *)child->header,
                                  (int )(child - (struct argp_child  const  *)argp___0->children),
                                  cluster, argp___0);
#line 1390
        tmp___1 = tmp___0;
        }
      } else
#line 1390
      if (child->header) {
        {
#line 1390
        tmp___0 = hol_add_cluster(hol, (int )child->group, (char const   *)child->header,
                                  (int )(child - (struct argp_child  const  *)argp___0->children),
                                  cluster, argp___0);
#line 1390
        tmp___1 = tmp___0;
        }
      } else {
#line 1390
        tmp___1 = cluster;
      }
      {
#line 1390
      child_cluster = tmp___1;
#line 1397
      tmp___2 = argp_hol((struct argp  const  *)child->argp, child_cluster);
#line 1397
      hol_append(hol, tmp___2);
#line 1398
      child ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1400
  return (hol);
}
}
#line 1405 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-help.c"
static size_t argp_args_levels(struct argp  const  *argp___0 ) 
{ 
  size_t levels ;
  struct argp_child  const  *child ;
  char *tmp ;
  struct argp_child  const  *tmp___0 ;
  size_t tmp___1 ;

  {
#line 1408
  levels = (size_t )0;
#line 1409
  child = (struct argp_child  const  *)argp___0->children;
#line 1411
  if (argp___0->args_doc) {
    {
#line 1411
    tmp = strchr((char const   *)argp___0->args_doc, '\n');
    }
#line 1411
    if (tmp) {
#line 1412
      levels ++;
    }
  }
#line 1414
  if (child) {
    {
#line 1415
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1415
      if (! child->argp) {
#line 1415
        goto while_break;
      }
      {
#line 1416
      tmp___0 = child;
#line 1416
      child ++;
#line 1416
      tmp___1 = argp_args_levels((struct argp  const  *)tmp___0->argp);
#line 1416
      levels += tmp___1;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1418
  return (levels);
}
}
#line 1426 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-help.c"
static int argp_args_usage(struct argp  const  *argp___0 , struct argp_state  const  *state ,
                           char **levels , int advance , argp_fmtstream_t stream ) 
{ 
  char *our_level ;
  int multiple ;
  struct argp_child  const  *child ;
  char const   *tdoc ;
  char *tmp ;
  char const   *nl ;
  char const   *fdoc ;
  char const   *tmp___0 ;
  char const   *cp ;
  char *tmp___1 ;
  int i ;
  char *tmp___2 ;
  struct argp_child  const  *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 1430
  our_level = *levels;
#line 1431
  multiple = 0;
#line 1432
  child = (struct argp_child  const  *)argp___0->children;
#line 1433
  tmp = dgettext((char const   *)argp___0->argp_domain, (char const   *)argp___0->args_doc);
#line 1433
  tdoc = (char const   *)tmp;
#line 1433
  nl = (char const   *)0;
#line 1434
  tmp___0 = filter_doc(tdoc, 33554438, argp___0, state);
#line 1434
  fdoc = tmp___0;
  }
#line 1436
  if (fdoc) {
    {
#line 1438
    cp = fdoc;
#line 1439
    tmp___1 = strchrnul(cp, '\n');
#line 1439
    nl = (char const   *)tmp___1;
    }
#line 1440
    if ((int const   )*nl != 0) {
#line 1445
      multiple = 1;
#line 1446
      i = 0;
      {
#line 1446
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1446
        if (! (i < (int )*our_level)) {
#line 1446
          goto while_break;
        }
        {
#line 1447
        cp = nl + 1;
#line 1447
        tmp___2 = strchrnul(cp, '\n');
#line 1447
        nl = (char const   *)tmp___2;
#line 1446
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 1448
      (*levels) ++;
    }
    {
#line 1453
    space(stream, (size_t )((nl + 1) - cp));
#line 1455
    argp_fmtstream_write(stream, cp, (size_t )(nl - cp));
    }
  }
#line 1457
  if (fdoc) {
#line 1457
    if ((unsigned long )fdoc != (unsigned long )tdoc) {
      {
#line 1458
      free((void *)((char *)fdoc));
      }
    }
  }
#line 1460
  if (child) {
    {
#line 1461
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1461
      if (! child->argp) {
#line 1461
        goto while_break___0;
      }
      {
#line 1462
      tmp___3 = child;
#line 1462
      child ++;
#line 1462
      tmp___4 = argp_args_usage((struct argp  const  *)tmp___3->argp, state, levels,
                                advance, stream);
      }
#line 1462
      if (tmp___4) {
#line 1462
        tmp___5 = 0;
      } else {
#line 1462
        tmp___5 = 1;
      }
#line 1462
      advance = tmp___5;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1464
  if (advance) {
#line 1464
    if (multiple) {
#line 1467
      if (*nl) {
#line 1470
        *our_level = (char )((int )*our_level + 1);
#line 1471
        advance = 0;
      } else
#line 1473
      if ((int )*our_level > 0) {
#line 1475
        *our_level = (char)0;
      }
    }
  }
#line 1478
  return (! advance);
}
}
#line 1488 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-help.c"
static int argp_doc(struct argp  const  *argp___0 , struct argp_state  const  *state ,
                    int post , int pre_blank , int first_only , argp_fmtstream_t stream ) 
{ 
  char const   *text___0 ;
  char const   *inp_text ;
  size_t inp_text_len ;
  char const   *trans_text ;
  void *input___0 ;
  int anything ;
  struct argp_child  const  *child ;
  char *vt ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  struct argp_child  const  *tmp___8 ;
  int tmp___9 ;

  {
#line 1495
  inp_text_len = (size_t )0;
#line 1497
  input___0 = (void *)0;
#line 1498
  anything = 0;
#line 1499
  child = (struct argp_child  const  *)argp___0->children;
#line 1501
  if (argp___0->doc) {
    {
#line 1503
    tmp = strchr((char const   *)argp___0->doc, '\v');
#line 1503
    vt = tmp;
    }
#line 1504
    if (vt) {
#line 1506
      if (post) {
#line 1507
        inp_text = (char const   *)(vt + 1);
      } else {
        {
#line 1510
        inp_text_len = (size_t )(vt - (char *)argp___0->doc);
#line 1511
        tmp___0 = strndup((char const   *)argp___0->doc, inp_text_len);
#line 1511
        inp_text = (char const   *)tmp___0;
        }
      }
    } else
#line 1515
    if (post) {
#line 1515
      inp_text = (char const   *)0;
    } else {
#line 1515
      inp_text = (char const   *)argp___0->doc;
    }
#line 1516
    if (inp_text) {
      {
#line 1516
      tmp___1 = dgettext((char const   *)argp___0->argp_domain, inp_text);
#line 1516
      trans_text = (char const   *)tmp___1;
      }
    } else {
#line 1516
      trans_text = (char const   *)((void *)0);
    }
  } else {
#line 1519
    inp_text = (char const   *)0;
#line 1519
    trans_text = inp_text;
  }
#line 1521
  if (argp___0->help_filter) {
    {
#line 1524
    input___0 = _argp_input((struct argp  const  */* __restrict  */)argp___0, (struct argp_state  const  */* __restrict  */)state);
    }
#line 1525
    if (post) {
#line 1525
      tmp___2 = 33554434;
    } else {
#line 1525
      tmp___2 = 33554433;
    }
    {
#line 1525
    tmp___3 = (*(argp___0->help_filter))(tmp___2, trans_text, input___0);
#line 1525
    text___0 = (char const   *)tmp___3;
    }
  } else {
#line 1532
    text___0 = trans_text;
  }
#line 1534
  if (text___0) {
#line 1536
    if (pre_blank) {
      {
#line 1537
      argp_fmtstream_putc(stream, '\n');
      }
    }
    {
#line 1539
    argp_fmtstream_puts(stream, text___0);
#line 1541
    tmp___4 = argp_fmtstream_point(stream);
    }
#line 1541
    if (tmp___4 > stream->lmargin) {
      {
#line 1542
      argp_fmtstream_putc(stream, '\n');
      }
    }
#line 1544
    anything = 1;
  }
#line 1547
  if (text___0) {
#line 1547
    if ((unsigned long )text___0 != (unsigned long )trans_text) {
      {
#line 1548
      free((void *)((char *)text___0));
      }
    }
  }
#line 1550
  if (inp_text) {
#line 1550
    if (inp_text_len) {
      {
#line 1551
      free((void *)((char *)inp_text));
      }
    }
  }
#line 1553
  if (post) {
#line 1553
    if (argp___0->help_filter) {
      {
#line 1556
      tmp___5 = (*(argp___0->help_filter))(33554436, (char const   *)0, input___0);
#line 1556
      text___0 = (char const   *)tmp___5;
      }
#line 1557
      if (text___0) {
#line 1559
        if (anything) {
          {
#line 1560
          argp_fmtstream_putc(stream, '\n');
          }
        } else
#line 1559
        if (pre_blank) {
          {
#line 1560
          argp_fmtstream_putc(stream, '\n');
          }
        }
        {
#line 1561
        argp_fmtstream_puts(stream, text___0);
#line 1562
        free((void *)((char *)text___0));
#line 1563
        tmp___6 = argp_fmtstream_point(stream);
        }
#line 1563
        if (tmp___6 > stream->lmargin) {
          {
#line 1565
          argp_fmtstream_putc(stream, '\n');
          }
        }
#line 1566
        anything = 1;
      }
    }
  }
#line 1570
  if (child) {
    {
#line 1571
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1571
      if (child->argp) {
#line 1571
        if (first_only) {
#line 1571
          if (anything) {
#line 1571
            goto while_break;
          }
        }
      } else {
#line 1571
        goto while_break;
      }
#line 1572
      if (anything) {
#line 1572
        tmp___7 = 1;
      } else
#line 1572
      if (pre_blank) {
#line 1572
        tmp___7 = 1;
      } else {
#line 1572
        tmp___7 = 0;
      }
      {
#line 1572
      tmp___8 = child;
#line 1572
      child ++;
#line 1572
      tmp___9 = argp_doc((struct argp  const  *)tmp___8->argp, state, post, tmp___7,
                         first_only, stream);
#line 1572
      anything |= tmp___9;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1577
  return (anything);
}
}
#line 1584 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-help.c"
static void _help(struct argp  const  *argp___0 , struct argp_state  const  *state ,
                  FILE *stream , unsigned int flags , char *name ) 
{ 
  int anything ;
  struct hol *hol ;
  argp_fmtstream_t fs ;
  int first_pattern ;
  int more_patterns ;
  size_t num_pattern_levels ;
  size_t tmp ;
  char *pattern_levels ;
  void *tmp___0 ;
  int old_lm ;
  int old_wm ;
  size_t tmp___1 ;
  char *levels ;
  char *tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;

  {
#line 1588
  anything = 0;
#line 1589
  hol = (struct hol *)0;
#line 1592
  if (! stream) {
#line 1593
    return;
  }
  {
#line 1596
  flockfile(stream);
  }
#line 1599
  if (! uparams.valid) {
    {
#line 1600
    fill_in_uparams(state);
    }
  }
  {
#line 1602
  fs = argp_make_fmtstream(stream, (size_t )0, (size_t )uparams.rmargin, (ssize_t )0);
  }
#line 1603
  if (! fs) {
    {
#line 1606
    funlockfile(stream);
    }
#line 1608
    return;
  }
#line 1611
  if (flags & 11U) {
    {
#line 1613
    hol = argp_hol(argp___0, (struct hol_cluster *)0);
#line 1616
    hol_set_group(hol, "help", -1);
#line 1617
    hol_set_group(hol, "version", -1);
#line 1619
    hol_sort(hol);
    }
  }
#line 1622
  if (flags & 3U) {
    {
#line 1625
    first_pattern = 1;
#line 1626
    tmp = argp_args_levels(argp___0);
#line 1626
    num_pattern_levels = tmp;
#line 1627
    tmp___0 = __builtin_alloca(num_pattern_levels);
#line 1627
    pattern_levels = (char *)tmp___0;
#line 1629
    memset((void *)pattern_levels, 0, num_pattern_levels);
    }
    {
#line 1631
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1634
      tmp___1 = argp_fmtstream_set_wmargin(fs, (size_t )uparams.usage_indent);
#line 1634
      old_wm = (int )tmp___1;
#line 1635
      levels = pattern_levels;
      }
#line 1637
      if (first_pattern) {
        {
#line 1638
        tmp___2 = dgettext((char const   *)argp___0->argp_domain, "Usage:");
#line 1638
        argp_fmtstream_printf(fs, "%s %s", tmp___2, name);
        }
      } else {
        {
#line 1642
        tmp___3 = dgettext((char const   *)argp___0->argp_domain, "  or: ");
#line 1642
        argp_fmtstream_printf(fs, "%s %s", tmp___3, name);
        }
      }
      {
#line 1648
      tmp___4 = argp_fmtstream_set_lmargin(fs, (size_t )uparams.usage_indent);
#line 1648
      old_lm = (int )tmp___4;
      }
#line 1650
      if (flags & 2U) {
#line 1653
        if (hol->num_entries > 0U) {
          {
#line 1654
          tmp___5 = dgettext((char const   *)argp___0->argp_domain, " [OPTION...]");
#line 1654
          argp_fmtstream_puts(fs, (char const   *)tmp___5);
          }
        }
      } else {
        {
#line 1660
        hol_usage(hol, fs);
#line 1661
        flags |= 2U;
        }
      }
      {
#line 1664
      more_patterns = argp_args_usage(argp___0, state, & levels, 1, fs);
#line 1666
      argp_fmtstream_set_wmargin(fs, (size_t )old_wm);
#line 1667
      argp_fmtstream_set_lmargin(fs, (size_t )old_lm);
#line 1669
      argp_fmtstream_putc(fs, '\n');
#line 1670
      anything = 1;
#line 1672
      first_pattern = 0;
      }
#line 1631
      if (! more_patterns) {
#line 1631
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1677
  if (flags & 16U) {
    {
#line 1678
    tmp___6 = argp_doc(argp___0, state, 0, 0, 1, fs);
#line 1678
    anything |= tmp___6;
    }
  }
#line 1680
  if (flags & 4U) {
    {
#line 1682
    tmp___7 = dgettext((char const   *)argp___0->argp_domain, "Try `%s --help\' or `%s --usage\' for more information.\n");
#line 1682
    argp_fmtstream_printf(fs, (char const   *)tmp___7, name, name);
#line 1685
    anything = 1;
    }
  }
#line 1688
  if (flags & 8U) {
#line 1692
    if (hol->num_entries > 0U) {
#line 1694
      if (anything) {
        {
#line 1695
        argp_fmtstream_putc(fs, '\n');
        }
      }
      {
#line 1696
      hol_help(hol, state, fs);
#line 1697
      anything = 1;
      }
    }
  }
#line 1701
  if (flags & 32U) {
    {
#line 1703
    tmp___8 = argp_doc(argp___0, state, 1, anything, 0, fs);
#line 1703
    anything |= tmp___8;
    }
  }
#line 1705
  if (flags & 64U) {
#line 1705
    if (argp_program_bug_address) {
#line 1707
      if (anything) {
        {
#line 1708
        argp_fmtstream_putc(fs, '\n');
        }
      }
      {
#line 1709
      tmp___9 = dgettext((char const   *)argp___0->argp_domain, "Report bugs to %s.\n");
#line 1709
      argp_fmtstream_printf(fs, (char const   *)tmp___9, argp_program_bug_address);
#line 1712
      anything = 1;
      }
    }
  }
  {
#line 1716
  funlockfile(stream);
  }
#line 1719
  if (hol) {
    {
#line 1720
    hol_free(hol);
    }
  }
  {
#line 1722
  argp_fmtstream_free(fs);
  }
#line 1723
  return;
}
}
#line 1727 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-help.c"
void argp_help(struct argp  const  * __restrict  argp___0 , FILE * __restrict  stream ,
               unsigned int flags , char * __restrict  name ) 
{ 
  struct argp_state state ;

  {
  {
#line 1731
  memset((void *)(& state), 0, sizeof(state));
#line 1732
  state.root_argp = (struct argp  const  *)argp___0;
#line 1733
  _help((struct argp  const  *)argp___0, (struct argp_state  const  *)(& state), (FILE *)stream,
        flags, (char *)name);
  }
#line 1734
  return;
}
}
#line 1759 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-help.c"
void argp_state_help(struct argp_state  const  * __restrict  state , FILE * __restrict  stream ,
                     unsigned int flags ) 
{ 
  char *tmp ;
  struct argp  const  *tmp___0 ;

  {
#line 1762
  if (! state) {
#line 1762
    goto _L___0;
  } else
#line 1762
  if (! (state->flags & 2U)) {
    _L___0: /* CIL Label */ 
#line 1762
    if (stream) {
#line 1764
      if (state) {
#line 1764
        if (state->flags & 64U) {
#line 1765
          flags |= 128U;
        }
      }
#line 1767
      if (state) {
#line 1767
        tmp = state->name;
      } else {
#line 1767
        tmp = (char */* const  */)program_invocation_short_name;
      }
#line 1767
      if (state) {
#line 1767
        tmp___0 = state->root_argp;
      } else {
#line 1767
        tmp___0 = (struct argp  const  */* const  */)0;
      }
      {
#line 1767
      _help((struct argp  const  *)tmp___0, (struct argp_state  const  *)state, (FILE *)stream,
            flags, (char *)tmp);
      }
#line 1770
      if (! state) {
#line 1770
        goto _L;
      } else
#line 1770
      if (! (state->flags & 32U)) {
        _L: /* CIL Label */ 
#line 1772
        if (flags & 256U) {
          {
#line 1773
          exit(argp_err_exit_status);
          }
        }
#line 1774
        if (flags & 512U) {
          {
#line 1775
          exit(0);
          }
        }
      }
    }
  }
#line 1778
  return;
}
}
#line 1786 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-help.c"
void ( /* format attribute */  argp_error)(struct argp_state  const  * __restrict  state ,
                                           char const   * __restrict  fmt  , ...) 
{ 
  FILE *stream ;
  struct _IO_FILE *tmp ;
  va_list ap ;
  char *tmp___0 ;

  {
#line 1789
  if (! state) {
#line 1789
    goto _L;
  } else
#line 1789
  if (! (state->flags & 2U)) {
    _L: /* CIL Label */ 
#line 1791
    if (state) {
#line 1791
      tmp = state->err_stream;
    } else {
#line 1791
      tmp = (struct _IO_FILE */* const  */)stderr;
    }
#line 1791
    stream = (FILE *)tmp;
#line 1793
    if (stream) {
      {
#line 1798
      flockfile(stream);
#line 1801
      __builtin_va_start(ap, fmt);
      }
#line 1820
      if (state) {
#line 1820
        tmp___0 = state->name;
      } else {
#line 1820
        tmp___0 = (char */* const  */)program_invocation_short_name;
      }
      {
#line 1820
      fputs_unlocked((char const   */* __restrict  */)tmp___0, (FILE */* __restrict  */)stream);
#line 1823
      putc_unlocked(':', stream);
#line 1824
      putc_unlocked(' ', stream);
#line 1826
      vfprintf((FILE */* __restrict  */)stream, fmt, ap);
#line 1828
      putc_unlocked('\n', stream);
#line 1831
      argp_state_help(state, (FILE */* __restrict  */)stream, 260U);
#line 1833
      __builtin_va_end(ap);
#line 1836
      funlockfile(stream);
      }
    }
  }
#line 1840
  return;
}
}
#line 1853 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/gnu/argp-help.c"
void ( /* format attribute */  argp_failure)(struct argp_state  const  * __restrict  state ,
                                             int status , int errnum , char const   * __restrict  fmt 
                                             , ...) 
{ 
  FILE *stream ;
  struct _IO_FILE *tmp ;
  char *tmp___0 ;
  va_list ap ;
  char buf[200] ;
  char const   *s ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
#line 1857
  if (! state) {
#line 1857
    goto _L;
  } else
#line 1857
  if (! (state->flags & 2U)) {
    _L: /* CIL Label */ 
#line 1859
    if (state) {
#line 1859
      tmp = state->err_stream;
    } else {
#line 1859
      tmp = (struct _IO_FILE */* const  */)stderr;
    }
#line 1859
    stream = (FILE *)tmp;
#line 1861
    if (stream) {
      {
#line 1864
      flockfile(stream);
      }
#line 1873
      if (state) {
#line 1873
        tmp___0 = state->name;
      } else {
#line 1873
        tmp___0 = (char */* const  */)program_invocation_short_name;
      }
      {
#line 1873
      fputs_unlocked((char const   */* __restrict  */)tmp___0, (FILE */* __restrict  */)stream);
      }
#line 1877
      if (fmt) {
        {
#line 1881
        __builtin_va_start(ap, fmt);
#line 1897
        putc_unlocked(':', stream);
#line 1898
        putc_unlocked(' ', stream);
#line 1900
        vfprintf((FILE */* __restrict  */)stream, fmt, ap);
#line 1903
        __builtin_va_end(ap);
        }
      }
#line 1906
      if (errnum) {
        {
#line 1917
        s = (char const   *)((void *)0);
#line 1918
        putc_unlocked(':', stream);
#line 1919
        putc_unlocked(' ', stream);
#line 1921
        tmp___1 = strerror_r(errnum, buf, sizeof(buf));
#line 1921
        s = (char const   *)tmp___1;
        }
#line 1927
        if (! s) {
          {
#line 1927
          tmp___3 = strerror(errnum);
#line 1927
          s = (char const   *)tmp___3;
          }
#line 1927
          if (! s) {
            {
#line 1928
            tmp___2 = dgettext((char const   *)(state->root_argp)->argp_domain, "Unknown system error");
#line 1928
            s = (char const   *)tmp___2;
            }
          }
        }
        {
#line 1931
        fputs((char const   */* __restrict  */)s, (FILE */* __restrict  */)stream);
        }
      }
      {
#line 1940
      putc_unlocked('\n', stream);
#line 1943
      funlockfile(stream);
      }
#line 1946
      if (status) {
#line 1946
        if (! state) {
          {
#line 1947
          exit(status);
          }
        } else
#line 1946
        if (! (state->flags & 32U)) {
          {
#line 1947
          exit(status);
          }
        }
      }
    }
  }
#line 1950
  return;
}
}
#line 58 "../gnu/xalloc.h"
extern void *xzalloc(size_t s )  __attribute__((__malloc__)) ;
#line 29 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/depmap.c"
static void transitive_closure(unsigned int *R , int n ) 
{ 
  register size_t rowsize ;
  register unsigned int mask ;
  register unsigned int *rowj ;
  register unsigned int *rp ;
  register unsigned int *rend ;
  register unsigned int *ccol ;
  unsigned int *relend ;
  unsigned int *cword ;
  unsigned int *rowi ;
  unsigned int *tmp ;
  unsigned int *tmp___0 ;

  {
#line 43
  rowsize = ((((unsigned long )n + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL)) * sizeof(unsigned int );
#line 44
  relend = (unsigned int *)((char *)R + (size_t )n * rowsize);
#line 46
  cword = R;
#line 47
  mask = 1U;
#line 48
  rowi = R;
  {
#line 49
  while (1) {
    while_continue: /* CIL Label */ ;
#line 49
    if (! ((unsigned long )rowi < (unsigned long )relend)) {
#line 49
      goto while_break;
    }
#line 50
    ccol = cword;
#line 51
    rowj = R;
    {
#line 53
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 53
      if (! ((unsigned long )rowj < (unsigned long )relend)) {
#line 53
        goto while_break___0;
      }
#line 54
      if (*ccol & mask) {
#line 55
        rp = rowi;
#line 56
        rend = (unsigned int *)((char *)rowj + rowsize);
        {
#line 58
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 58
          if (! ((unsigned long )rowj < (unsigned long )rend)) {
#line 58
            goto while_break___1;
          }
#line 59
          tmp = rowj;
#line 59
          rowj ++;
#line 59
          tmp___0 = rp;
#line 59
          rp ++;
#line 59
          *tmp |= *tmp___0;
        }
        while_break___1: /* CIL Label */ ;
        }
      } else {
#line 61
        rowj = (unsigned int *)((char *)rowj + rowsize);
      }
#line 64
      ccol = (unsigned int *)((char *)ccol + rowsize);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 67
    mask <<= 1;
#line 68
    if (mask == 0U) {
#line 69
      mask = 1U;
#line 70
      cword ++;
    }
#line 72
    rowi = (unsigned int *)((char *)rowi + rowsize);
  }
  while_break: /* CIL Label */ ;
  }
#line 74
  return;
}
}
#line 82 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/depmap.c"
cflow_depmap_t depmap_alloc(size_t count ) 
{ 
  size_t size ;
  cflow_depmap_t dmap ;
  void *tmp ;

  {
  {
#line 85
  size = ((count + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL);
#line 86
  tmp = xzalloc((sizeof(*dmap) - 1UL) + (count * size) * sizeof(unsigned int ));
#line 86
  dmap = (cflow_depmap_t )tmp;
#line 88
  dmap->nrows = count;
#line 89
  dmap->rowlen = size;
  }
#line 90
  return (dmap);
}
}
#line 93 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/depmap.c"
static unsigned int *depmap_rowptr(cflow_depmap_t dmap , size_t row ) 
{ 


  {
#line 96
  return (dmap->r + dmap->rowlen * row);
}
}
#line 99 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/depmap.c"
void depmap_set(cflow_depmap_t dmap , size_t row , size_t col ) 
{ 
  unsigned int *rptr ;
  unsigned int *tmp ;

  {
  {
#line 102
  tmp = depmap_rowptr(dmap, row);
#line 102
  rptr = tmp;
#line 103
  *(rptr + col / (sizeof(unsigned int ) * 8UL)) |= (unsigned int )(1 << col % (sizeof(unsigned int ) * 8UL));
  }
#line 104
  return;
}
}
#line 106 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/depmap.c"
int depmap_isset(cflow_depmap_t dmap , size_t row , size_t col ) 
{ 
  unsigned int *rptr ;
  unsigned int *tmp ;

  {
  {
#line 109
  tmp = depmap_rowptr(dmap, row);
#line 109
  rptr = tmp;
  }
#line 110
  return ((*(rptr + col / (sizeof(unsigned int ) * 8UL)) & (unsigned int )(1 << col % (sizeof(unsigned int ) * 8UL))) != 0U);
}
}
#line 113 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/depmap.c"
void depmap_tc(cflow_depmap_t dmap ) 
{ 


  {
  {
#line 116
  transitive_closure(dmap->r, (int )dmap->nrows);
  }
#line 117
  return;
}
}
#line 22 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/posix.c"
static void print_symbol_type(FILE *outfile___0 , Symbol *sym ) 
{ 


  {
#line 25
  if (sym->decl) {
    {
#line 26
    fprintf((FILE */* __restrict  */)outfile___0, (char const   */* __restrict  */)"%s, <%s %d>",
            sym->decl, sym->source, sym->def_line);
    }
  } else {
    {
#line 31
    fprintf((FILE */* __restrict  */)outfile___0, (char const   */* __restrict  */)"<>");
    }
  }
#line 32
  return;
}
}
#line 34 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/posix.c"
static int print_symbol___1(FILE *outfile___0 , int line , struct output_symbol *s ) 
{ 


  {
  {
#line 37
  print_level(s->level, s->last);
#line 38
  fprintf((FILE */* __restrict  */)outfile___0, (char const   */* __restrict  */)"%s: ",
          (s->sym)->name);
  }
#line 40
  if (brief_listing) {
#line 41
    if ((s->sym)->expand_line) {
      {
#line 42
      fprintf((FILE */* __restrict  */)outfile___0, (char const   */* __restrict  */)"%d",
              (s->sym)->expand_line);
      }
#line 43
      return (1);
    } else
#line 44
    if ((s->sym)->callee) {
#line 45
      (s->sym)->expand_line = line;
    }
  }
  {
#line 47
  print_symbol_type(outfile___0, s->sym);
  }
#line 48
  return (0);
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/posix.c"
int posix_output_handler(cflow_output_command cmd , FILE *outfile___0 , int line ,
                         void *data , void *handler_data ) 
{ 
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 57
  if ((unsigned int )cmd == 0U) {
#line 57
    goto case_0;
  }
#line 65
  if ((unsigned int )cmd == 4U) {
#line 65
    goto case_4;
  }
#line 65
  if ((unsigned int )cmd == 2U) {
#line 65
    goto case_4;
  }
#line 65
  if ((unsigned int )cmd == 1U) {
#line 65
    goto case_4;
  }
#line 67
  if ((unsigned int )cmd == 3U) {
#line 67
    goto case_3;
  }
#line 70
  if ((unsigned int )cmd == 6U) {
#line 70
    goto case_6;
  }
#line 73
  if ((unsigned int )cmd == 5U) {
#line 73
    goto case_5;
  }
#line 56
  goto switch_break;
  case_0: /* CIL Label */ 
#line 59
  if (emacs_option) {
    {
#line 60
    tmp = gettext("--format=posix is not compatible with --emacs");
#line 60
    error(1, 0, (char const   *)tmp);
    }
  }
#line 61
  omit_symbol_names_option = 1;
#line 61
  print_line_numbers = omit_symbol_names_option;
#line 61
  brief_listing = print_line_numbers;
#line 62
  goto switch_break;
  case_4: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 66
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 68
  fprintf((FILE */* __restrict  */)outfile___0, (char const   */* __restrict  */)"\n");
  }
#line 69
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 71
  fprintf((FILE */* __restrict  */)outfile___0, (char const   */* __restrict  */)"%s",
          (char *)data);
  }
#line 72
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 74
  tmp___0 = print_symbol___1(outfile___0, line, (struct output_symbol *)data);
  }
#line 74
  return (tmp___0);
  switch_break: /* CIL Label */ ;
  }
#line 76
  return (0);
}
}
#line 348 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2), __leaf__)) strtok)(char * __restrict  __s ,
                                                                                               char const   * __restrict  __delim ) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 29 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/rc.c"
static void expand_argcv(int *argc_ptr , char ***argv_ptr , int argc , char **argv ) 
{ 
  int i ;
  void *tmp ;

  {
  {
#line 34
  tmp = xrealloc((void *)*argv_ptr, (unsigned long )((*argc_ptr + argc) + 1) * sizeof(*(*argv_ptr)));
#line 34
  *argv_ptr = (char **)tmp;
#line 36
  i = 0;
  }
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
#line 36
    if (! (i <= argc)) {
#line 36
      goto while_break;
    }
#line 37
    *(*argv_ptr + (*argc_ptr + i)) = *(argv + i);
#line 36
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 38
  *argc_ptr += argc;
#line 39
  return;
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/rc.c"
void parse_rc(int *argc_ptr , char ***argv_ptr , char *name ) 
{ 
  struct stat st ;
  FILE *rcfile ;
  int size ;
  char *buf ;
  char *p ;
  int tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  size_t tmp___4 ;
  int argc ;
  char **argv ;

  {
  {
#line 51
  tmp = stat((char const   */* __restrict  */)name, (struct stat */* __restrict  */)(& st));
  }
#line 51
  if (tmp) {
#line 52
    return;
  }
  {
#line 53
  tmp___0 = malloc((size_t )(st.st_size + 1L));
#line 53
  buf = (char *)tmp___0;
  }
#line 54
  if (! buf) {
    {
#line 55
    tmp___1 = gettext("not enough memory to process rc file");
#line 55
    error(0, 0, (char const   *)tmp___1);
    }
#line 56
    return;
  }
  {
#line 58
  rcfile = fopen((char const   */* __restrict  */)name, (char const   */* __restrict  */)"r");
  }
#line 59
  if (! rcfile) {
    {
#line 60
    tmp___2 = gettext("cannot open `%s\'");
#line 60
    tmp___3 = __errno_location();
#line 60
    error(0, *tmp___3, (char const   *)tmp___2, name);
    }
#line 61
    return;
  }
  {
#line 63
  tmp___4 = fread((void */* __restrict  */)buf, (size_t )1, (size_t )st.st_size, (FILE */* __restrict  */)rcfile);
#line 63
  size = (int )tmp___4;
#line 64
  *(buf + size) = (char)0;
#line 65
  fclose(rcfile);
#line 67
  p = strtok((char */* __restrict  */)buf, (char const   */* __restrict  */)"\n");
  }
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
#line 67
    if (! p) {
#line 67
      goto while_break;
    }
    {
#line 71
    argcv_get((char const   *)p, "", "#", & argc, & argv);
#line 72
    expand_argcv(argc_ptr, argv_ptr, argc, argv);
#line 73
    free((void *)argv);
#line 67
    p = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"\n");
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 75
  free((void *)buf);
  }
#line 76
  return;
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/rc.c"
void sourcerc(int *argc_ptr , char ***argv_ptr ) 
{ 
  char *env ;
  int xargc ;
  char **xargv ;
  void *tmp ;
  int argc ;
  char **argv ;
  char *home ;
  char *tmp___0 ;
  int len ;
  size_t tmp___1 ;
  char *buf ;
  void *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 90
  xargc = 1;
#line 93
  tmp = xmalloc(2UL * sizeof(*xargv));
#line 93
  xargv = (char **)tmp;
#line 94
  *(xargv + 0) = *(*argv_ptr);
#line 95
  *(xargv + 1) = (char *)((void *)0);
#line 97
  env = getenv("CFLOW_OPTIONS");
  }
#line 98
  if (env) {
    {
#line 102
    argcv_get((char const   *)env, "", "#", & argc, & argv);
#line 103
    expand_argcv(& xargc, & xargv, argc, argv);
#line 104
    free((void *)argv);
    }
  }
  {
#line 107
  env = getenv("CFLOWRC");
  }
#line 108
  if (env) {
    {
#line 109
    parse_rc(& xargc, & xargv, env);
    }
  } else {
    {
#line 111
    tmp___0 = getenv("HOME");
#line 111
    home = tmp___0;
    }
#line 112
    if (home) {
      {
#line 113
      tmp___1 = strlen((char const   *)home);
#line 113
      len = (int )tmp___1;
#line 114
      tmp___2 = malloc(((unsigned long )len + sizeof(".cflowrc")) + (unsigned long )((int )*(home + (len - 1)) != 47));
#line 114
      buf = (char *)tmp___2;
      }
#line 116
      if (! buf) {
#line 117
        return;
      }
      {
#line 118
      strcpy((char */* __restrict  */)buf, (char const   */* __restrict  */)home);
      }
#line 119
      if ((int )*(home + (len - 1)) != 47) {
#line 120
        tmp___3 = len;
#line 120
        len ++;
#line 120
        *(buf + tmp___3) = (char )'/';
      }
      {
#line 121
      strcpy((char */* __restrict  */)(buf + len), (char const   */* __restrict  */)".cflowrc");
#line 122
      parse_rc(& xargc, & xargv, buf);
#line 123
      free((void *)buf);
      }
    }
  }
#line 127
  if (xargc > 1) {
    {
#line 128
    expand_argcv(& xargc, & xargv, *argc_ptr - 1, *argv_ptr + 1);
#line 129
    *argc_ptr = xargc;
#line 130
    *argv_ptr = xargv;
    }
  }
#line 132
  return;
}
}
#line 168 "./cflow.h"
int token_stack_increase ;
#line 30 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/parser.c"
void parse_declaration(Ident *ident___0 , int parm ) ;
#line 31
void parse_variable_declaration(Ident *ident___0 , int parm ) ;
#line 32
void parse_function_declaration(Ident *ident___0 , int parm ) ;
#line 33
void parse_dcl(Ident *ident___0 , int maybe_knr ) ;
#line 34
void parse_knr_dcl(Ident *ident___0 ) ;
#line 35
void parse_typedef(void) ;
#line 36
void expression(void) ;
#line 37
void initializer_list(void) ;
#line 38
void func_body(void) ;
#line 39
void declare(Ident *ident___0 , int maybe_knr ) ;
#line 40
void declare_type(Ident *ident___0 ) ;
#line 41
int dcl(Ident *idptr ) ;
#line 42
int parmdcl(Ident *idptr ) ;
#line 43
int dirdcl(Ident *idptr ) ;
#line 44
void skip_struct(void) ;
#line 45
Symbol *get_symbol(char *name ) ;
#line 46
void maybe_parm_list(int *parm_cnt_return ) ;
#line 48
void call(char *name , int line ) ;
#line 49
void reference(char *name , int line ) ;
#line 51 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/parser.c"
int level  ;
#line 52 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/parser.c"
Symbol *caller  ;
#line 53 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/parser.c"
struct obstack text_stk  ;
#line 55 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/parser.c"
int parm_level  ;
#line 65 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/parser.c"
TOKSTK tok  ;
#line 66 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/parser.c"
TOKSTK *token_stack  ;
#line 67 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/parser.c"
int tos  ;
#line 68 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/parser.c"
int curs  ;
#line 69 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/parser.c"
int token_stack_length  =    64;
#line 70 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/parser.c"
int token_stack_increase  =    32;
#line 71 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/parser.c"
static int need_space  ;
#line 73
void mark(int *pos ) ;
#line 74
void restore(int *pos ) ;
#line 75
void tokpush(int type , int line , char *token ) ;
#line 76
void save_token(TOKSTK *tokptr ) ;
#line 78 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/parser.c"
static void print_token(TOKSTK *tokptr ) 
{ 


  {
  {
#line 89
  if (tokptr->type == 266) {
#line 89
    goto case_266;
  }
#line 89
  if (tokptr->type == 273) {
#line 89
    goto case_266;
  }
#line 89
  if (tokptr->type == 272) {
#line 89
    goto case_266;
  }
#line 89
  if (tokptr->type == 264) {
#line 89
    goto case_266;
  }
#line 89
  if (tokptr->type == 265) {
#line 89
    goto case_266;
  }
#line 89
  if (tokptr->type == 257) {
#line 89
    goto case_266;
  }
#line 89
  if (tokptr->type == 270) {
#line 89
    goto case_266;
  }
#line 89
  if (tokptr->type == 260) {
#line 89
    goto case_266;
  }
#line 93
  if (tokptr->type == 123) {
#line 93
    goto case_123;
  }
#line 93
  if (tokptr->type == 258) {
#line 93
    goto case_123;
  }
#line 97
  if (tokptr->type == 125) {
#line 97
    goto case_125;
  }
#line 97
  if (tokptr->type == 259) {
#line 97
    goto case_125;
  }
#line 100
  if (tokptr->type == 261) {
#line 100
    goto case_261;
  }
#line 103
  if (tokptr->type == 262) {
#line 103
    goto case_262;
  }
#line 106
  if (tokptr->type == 263) {
#line 106
    goto case_263;
  }
#line 109
  if (tokptr->type == 271) {
#line 109
    goto case_271;
  }
#line 112
  goto switch_default;
  case_266: /* CIL Label */ 
  case_273: /* CIL Label */ 
  case_272: /* CIL Label */ 
  case_264: /* CIL Label */ 
  case_265: /* CIL Label */ 
  case_257: /* CIL Label */ 
  case_270: /* CIL Label */ 
  case_260: /* CIL Label */ 
  {
#line 90
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"`%s\'",
          tokptr->token);
  }
#line 91
  goto switch_break;
  case_123: /* CIL Label */ 
  case_258: /* CIL Label */ 
  {
#line 94
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"`{\'");
  }
#line 95
  goto switch_break;
  case_125: /* CIL Label */ 
  case_259: /* CIL Label */ 
  {
#line 98
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"`}\'");
  }
#line 99
  goto switch_break;
  case_261: /* CIL Label */ 
  {
#line 101
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"`extern\'");
  }
#line 102
  goto switch_break;
  case_262: /* CIL Label */ 
  {
#line 104
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"`static\'");
  }
#line 105
  goto switch_break;
  case_263: /* CIL Label */ 
  {
#line 107
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"`typedef\'");
  }
#line 108
  goto switch_break;
  case_271: /* CIL Label */ 
  {
#line 110
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\"%s\"",
          tokptr->token);
  }
#line 111
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 113
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"`%c\'",
          tokptr->type);
  }
  switch_break: /* CIL Label */ ;
  }
#line 115
  return;
}
}
#line 117 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/parser.c"
static void file_error(char *msg , TOKSTK *tokptr ) 
{ 
  char *tmp ;

  {
  {
#line 120
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d: %s",
          filename, tok.line, msg);
  }
#line 121
  if (tokptr) {
    {
#line 122
    tmp = gettext(" near ");
#line 122
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp);
#line 123
    print_token(tokptr);
    }
  }
  {
#line 125
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
  }
#line 126
  return;
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/parser.c"
void mark(int *pos ) 
{ 


  {
#line 131
  *(pos + 0) = curs;
#line 132
  return;
}
}
#line 134 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/parser.c"
void restore(int *pos ) 
{ 


  {
#line 137
  curs = *(pos + 0);
#line 138
  if (curs) {
#line 139
    tok = *(token_stack + (curs - 1));
  }
#line 140
  return;
}
}
#line 142 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/parser.c"
void tokpush(int type , int line , char *token ) 
{ 
  void *tmp ;

  {
#line 145
  (token_stack + tos)->type = type;
#line 146
  (token_stack + tos)->token = token;
#line 147
  (token_stack + tos)->line = line;
#line 148
  tos ++;
#line 148
  if (tos == token_stack_length) {
    {
#line 149
    token_stack_length += token_stack_increase;
#line 150
    tmp = xrealloc((void *)token_stack, (unsigned long )token_stack_length * sizeof(*token_stack));
#line 150
    token_stack = (TOKSTK *)tmp;
    }
  }
#line 153
  return;
}
}
#line 155 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/parser.c"
void cleanup_stack(void) 
{ 
  int delta ;

  {
#line 158
  delta = tos - curs;
#line 160
  if (delta) {
    {
#line 161
    memmove((void *)token_stack, (void const   *)(token_stack + curs), (unsigned long )delta * sizeof(*(token_stack + 0)));
    }
  }
#line 163
  tos = delta;
#line 164
  curs = 0;
#line 165
  return;
}
}
#line 167 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/parser.c"
void clearstack(void) 
{ 


  {
#line 170
  curs = 0;
#line 170
  tos = curs;
#line 171
  return;
}
}
#line 173 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/parser.c"
int nexttoken(void) 
{ 
  int type ;

  {
#line 178
  if (curs == tos) {
    {
#line 179
    type = get_token();
#line 180
    tokpush(type, line_num, yylval.str);
    }
  }
#line 182
  tok = *(token_stack + curs);
#line 183
  curs ++;
#line 184
  return (tok.type);
}
}
#line 187 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/parser.c"
int putback(void) 
{ 
  char *tmp ;

  {
#line 190
  if (curs == 0) {
    {
#line 191
    tmp = gettext("INTERNAL ERROR: cannot return token to stream");
#line 191
    error(10, 0, (char const   *)tmp);
    }
  }
#line 192
  curs --;
#line 193
  if (curs > 0) {
#line 194
    tok.type = (token_stack + (curs - 1))->type;
#line 195
    tok.token = (token_stack + (curs - 1))->token;
  } else {
#line 197
    tok.type = 0;
  }
#line 198
  return (tok.type);
}
}
#line 201 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/parser.c"
void init_parse(void) 
{ 
  void *tmp ;

  {
  {
#line 204
  _obstack_begin(& text_stk, 0, 0, (void *(*)(long  ))(& xmalloc), (void (*)(void * ))(& free));
#line 205
  tmp = xmalloc((unsigned long )token_stack_length * sizeof(*token_stack));
#line 205
  token_stack = (TOKSTK *)tmp;
#line 206
  clearstack();
  }
#line 207
  return;
}
}
#line 209 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/parser.c"
void save_token(TOKSTK *tokptr ) 
{ 
  int len ;
  struct obstack *__o ;
  char *tmp ;
  size_t tmp___0 ;
  struct obstack *__o___0 ;
  int __len ;
  struct obstack *__o___1 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  struct obstack *__o___2 ;
  int __len___0 ;
  struct obstack *__o___3 ;
  char *tmp___3 ;
  struct obstack *__o___4 ;
  char *tmp___4 ;
  struct obstack *__o___5 ;
  char *tmp___5 ;
  struct obstack *__o___6 ;
  char *tmp___6 ;
  struct obstack *__o___7 ;
  char *tmp___7 ;
  struct obstack *__o___8 ;
  char *tmp___8 ;
  struct obstack *__o___9 ;
  int __len___1 ;
  size_t tmp___9 ;
  char *tmp___10 ;

  {
  {
#line 220
  if (tokptr->type == 273) {
#line 220
    goto case_273;
  }
#line 220
  if (tokptr->type == 257) {
#line 220
    goto case_273;
  }
#line 220
  if (tokptr->type == 272) {
#line 220
    goto case_273;
  }
#line 220
  if (tokptr->type == 264) {
#line 220
    goto case_273;
  }
#line 220
  if (tokptr->type == 270) {
#line 220
    goto case_273;
  }
#line 220
  if (tokptr->type == 260) {
#line 220
    goto case_273;
  }
#line 227
  if (tokptr->type == 265) {
#line 227
    goto case_265;
  }
#line 238
  if (tokptr->type == 262) {
#line 238
    goto case_262;
  }
#line 238
  if (tokptr->type == 261) {
#line 238
    goto case_262;
  }
#line 240
  if (tokptr->type == 44) {
#line 240
    goto case_44;
  }
#line 244
  if (tokptr->type == 40) {
#line 244
    goto case_40;
  }
#line 250
  if (tokptr->type == 41) {
#line 250
    goto case_41;
  }
#line 255
  if (tokptr->type == 93) {
#line 255
    goto case_93;
  }
#line 255
  if (tokptr->type == 91) {
#line 255
    goto case_93;
  }
#line 259
  if (tokptr->type == 266) {
#line 259
    goto case_266;
  }
#line 264
  goto switch_default;
  case_273: /* CIL Label */ 
  case_257: /* CIL Label */ 
  case_272: /* CIL Label */ 
  case_264: /* CIL Label */ 
  case_270: /* CIL Label */ 
  case_260: /* CIL Label */ 
#line 221
  if (need_space) {
#line 222
    __o = & text_stk;
#line 222
    if ((unsigned long )(__o->next_free + 1) > (unsigned long )__o->chunk_limit) {
      {
#line 222
      _obstack_newchunk(__o, 1);
      }
    }
#line 222
    tmp = __o->next_free;
#line 222
    (__o->next_free) ++;
#line 222
    *tmp = (char )' ';
  }
  {
#line 223
  tmp___0 = strlen((char const   *)tokptr->token);
#line 223
  len = (int )tmp___0;
#line 224
  __o___0 = & text_stk;
#line 224
  __len = len;
  }
#line 224
  if ((unsigned long )(__o___0->next_free + __len) > (unsigned long )__o___0->chunk_limit) {
    {
#line 224
    _obstack_newchunk(__o___0, __len);
    }
  }
  {
#line 224
  memcpy((void */* __restrict  */)__o___0->next_free, (void const   */* __restrict  */)tokptr->token,
         (size_t )__len);
#line 224
  __o___0->next_free += __len;
#line 225
  need_space = 1;
  }
#line 226
  goto switch_break;
  case_265: /* CIL Label */ 
#line 228
  if (need_space) {
#line 229
    __o___1 = & text_stk;
#line 229
    if ((unsigned long )(__o___1->next_free + 1) > (unsigned long )__o___1->chunk_limit) {
      {
#line 229
      _obstack_newchunk(__o___1, 1);
      }
    }
#line 229
    tmp___1 = __o___1->next_free;
#line 229
    (__o___1->next_free) ++;
#line 229
    *tmp___1 = (char )' ';
  }
#line 230
  if ((int )*(tokptr->token + 0) == 42) {
#line 231
    need_space = 0;
  } else {
#line 233
    need_space = 1;
  }
  {
#line 234
  tmp___2 = strlen((char const   *)tokptr->token);
#line 234
  len = (int )tmp___2;
#line 235
  __o___2 = & text_stk;
#line 235
  __len___0 = len;
  }
#line 235
  if ((unsigned long )(__o___2->next_free + __len___0) > (unsigned long )__o___2->chunk_limit) {
    {
#line 235
    _obstack_newchunk(__o___2, __len___0);
    }
  }
  {
#line 235
  memcpy((void */* __restrict  */)__o___2->next_free, (void const   */* __restrict  */)tokptr->token,
         (size_t )__len___0);
#line 235
  __o___2->next_free += __len___0;
  }
#line 236
  goto switch_break;
  case_262: /* CIL Label */ 
  case_261: /* CIL Label */ 
#line 239
  goto switch_break;
  case_44: /* CIL Label */ 
#line 241
  __o___3 = & text_stk;
#line 241
  if ((unsigned long )(__o___3->next_free + 1) > (unsigned long )__o___3->chunk_limit) {
    {
#line 241
    _obstack_newchunk(__o___3, 1);
    }
  }
#line 241
  tmp___3 = __o___3->next_free;
#line 241
  (__o___3->next_free) ++;
#line 241
  *tmp___3 = (char )',';
#line 242
  need_space = 1;
#line 243
  goto switch_break;
  case_40: /* CIL Label */ 
#line 245
  if (need_space) {
#line 246
    __o___4 = & text_stk;
#line 246
    if ((unsigned long )(__o___4->next_free + 1) > (unsigned long )__o___4->chunk_limit) {
      {
#line 246
      _obstack_newchunk(__o___4, 1);
      }
    }
#line 246
    tmp___4 = __o___4->next_free;
#line 246
    (__o___4->next_free) ++;
#line 246
    *tmp___4 = (char )' ';
  }
#line 247
  __o___5 = & text_stk;
#line 247
  if ((unsigned long )(__o___5->next_free + 1) > (unsigned long )__o___5->chunk_limit) {
    {
#line 247
    _obstack_newchunk(__o___5, 1);
    }
  }
#line 247
  tmp___5 = __o___5->next_free;
#line 247
  (__o___5->next_free) ++;
#line 247
  *tmp___5 = (char )tokptr->type;
#line 248
  need_space = 0;
#line 249
  goto switch_break;
  case_41: /* CIL Label */ 
#line 251
  __o___6 = & text_stk;
#line 251
  if ((unsigned long )(__o___6->next_free + 1) > (unsigned long )__o___6->chunk_limit) {
    {
#line 251
    _obstack_newchunk(__o___6, 1);
    }
  }
#line 251
  tmp___6 = __o___6->next_free;
#line 251
  (__o___6->next_free) ++;
#line 251
  *tmp___6 = (char )tokptr->type;
#line 252
  need_space = 1;
#line 253
  goto switch_break;
  case_93: /* CIL Label */ 
  case_91: /* CIL Label */ 
#line 256
  __o___7 = & text_stk;
#line 256
  if ((unsigned long )(__o___7->next_free + 1) > (unsigned long )__o___7->chunk_limit) {
    {
#line 256
    _obstack_newchunk(__o___7, 1);
    }
  }
#line 256
  tmp___7 = __o___7->next_free;
#line 256
  (__o___7->next_free) ++;
#line 256
  *tmp___7 = (char )tokptr->type;
#line 257
  need_space = 0;
#line 258
  goto switch_break;
  case_266: /* CIL Label */ 
#line 260
  __o___8 = & text_stk;
#line 260
  if ((unsigned long )(__o___8->next_free + 1) > (unsigned long )__o___8->chunk_limit) {
    {
#line 260
    _obstack_newchunk(__o___8, 1);
    }
  }
  {
#line 260
  tmp___8 = __o___8->next_free;
#line 260
  (__o___8->next_free) ++;
#line 260
  *tmp___8 = (char )' ';
#line 261
  __o___9 = & text_stk;
#line 261
  tmp___9 = strlen((char const   *)tokptr->token);
#line 261
  __len___1 = (int )tmp___9;
  }
#line 261
  if ((unsigned long )(__o___9->next_free + __len___1) > (unsigned long )__o___9->chunk_limit) {
    {
#line 261
    _obstack_newchunk(__o___9, __len___1);
    }
  }
  {
#line 261
  memcpy((void */* __restrict  */)__o___9->next_free, (void const   */* __restrict  */)tokptr->token,
         (size_t )__len___1);
#line 261
  __o___9->next_free += __len___1;
#line 262
  need_space = 1;
  }
#line 263
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 265
  if (verbose) {
    {
#line 266
    tmp___10 = gettext("unrecognized definition");
#line 266
    file_error(tmp___10, tokptr);
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 268
  return;
}
}
#line 270 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/parser.c"
static Stackpos start_pos  ;
#line 271 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/parser.c"
static int save_end  ;
#line 273 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/parser.c"
void save_stack(void) 
{ 


  {
  {
#line 276
  mark((int *)(start_pos));
#line 277
  save_end = curs - 1;
  }
#line 278
  return;
}
}
#line 280 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/parser.c"
void undo_save_stack(void) 
{ 


  {
#line 283
  save_end = -1;
#line 284
  return;
}
}
#line 286 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/parser.c"
char *finish_save_stack(char *name ) 
{ 
  int i ;
  int level___0 ;
  int found_ident ;
  int tmp ;
  struct obstack *__o ;
  char *tmp___0 ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 290
  level___0 = 0;
#line 291
  found_ident = ! omit_symbol_names_option;
#line 293
  need_space = 0;
#line 294
  i = 0;
  {
#line 294
  while (1) {
    while_continue: /* CIL Label */ ;
#line 294
    if (! (i < save_end)) {
#line 294
      goto while_break;
    }
    {
#line 296
    if ((token_stack + i)->type == 40) {
#line 296
      goto case_40;
    }
#line 304
    if ((token_stack + i)->type == 41) {
#line 304
      goto case_41;
    }
#line 308
    if ((token_stack + i)->type == 260) {
#line 308
      goto case_260;
    }
#line 295
    goto switch_break;
    case_40: /* CIL Label */ 
#line 297
    if (omit_arguments_option) {
#line 298
      if (level___0 == 0) {
        {
#line 299
        save_token(token_stack + i);
        }
      }
#line 301
      level___0 ++;
    }
#line 303
    goto switch_break;
    case_41: /* CIL Label */ 
#line 305
    if (omit_arguments_option) {
#line 306
      level___0 --;
    }
#line 307
    goto switch_break;
    case_260: /* CIL Label */ 
#line 309
    if (! found_ident) {
      {
#line 309
      tmp = strcmp((char const   *)name, (char const   *)(token_stack + i)->token);
      }
#line 309
      if (tmp == 0) {
#line 310
        need_space = 1;
#line 311
        found_ident = 1;
#line 312
        goto __Cont;
      }
    }
    switch_break: /* CIL Label */ ;
    }
#line 315
    if (level___0 == 0) {
      {
#line 316
      save_token(token_stack + i);
      }
    }
    __Cont: /* CIL Label */ 
#line 294
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 318
  __o = & text_stk;
#line 318
  if ((unsigned long )(__o->next_free + 1) > (unsigned long )__o->chunk_limit) {
    {
#line 318
    _obstack_newchunk(__o, 1);
    }
  }
#line 318
  tmp___0 = __o->next_free;
#line 318
  (__o->next_free) ++;
#line 318
  *tmp___0 = (char)0;
#line 319
  __o1 = & text_stk;
#line 319
  __value = (void *)__o1->object_base;
#line 319
  if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 319
    __o1->maybe_empty_object = 1U;
  }
#line 319
  if (sizeof(long ) < sizeof(void *)) {
#line 319
    tmp___1 = __o1->object_base;
  } else {
#line 319
    tmp___1 = (char *)0;
  }
#line 319
  if (sizeof(long ) < sizeof(void *)) {
#line 319
    tmp___2 = __o1->object_base;
  } else {
#line 319
    tmp___2 = (char *)0;
  }
#line 319
  __o1->next_free = tmp___1 + (((__o1->next_free - tmp___2) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 319
  if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 319
    __o1->next_free = __o1->chunk_limit;
  }
#line 319
  __o1->object_base = __o1->next_free;
#line 319
  return ((char *)__value);
}
}
#line 322 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/parser.c"
void skip_to(int c ) 
{ 
  int tmp ;

  {
  {
#line 325
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 325
    tmp = nexttoken();
    }
#line 325
    if (! tmp) {
#line 325
      goto while_break;
    }
#line 326
    if (tok.type == c) {
#line 327
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 329
  return;
}
}
#line 331 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/parser.c"
int skip_balanced(int open_tok , int close_tok , int level___0 ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 334
  if (level___0 == 0) {
    {
#line 335
    tmp = nexttoken();
    }
#line 335
    if (tmp != open_tok) {
#line 336
      return (1);
    }
#line 338
    level___0 ++;
  }
  {
#line 340
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 340
    tmp___0 = nexttoken();
    }
#line 340
    if (! tmp___0) {
#line 340
      goto while_break;
    }
#line 341
    if (tok.type == 258) {
#line 341
      if (open_tok == 123) {
#line 342
        tok.type = '{';
      } else {
#line 341
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 343
    if (tok.type == 259) {
#line 343
      if (close_tok == 125) {
#line 344
        tok.type = '}';
      }
    }
#line 346
    if (tok.type == open_tok) {
#line 347
      level___0 ++;
    } else
#line 348
    if (tok.type == close_tok) {
#line 349
      level___0 --;
#line 349
      if (level___0 == 0) {
        {
#line 350
        nexttoken();
        }
#line 351
        return (0);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 355
  return (-1);
}
}
#line 358 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/parser.c"
int yyparse(void) 
{ 
  Ident identifier ;
  int tmp ;

  {
  {
#line 363
  level = 0;
#line 364
  caller = (Symbol *)((void *)0);
#line 365
  clearstack();
  }
  {
#line 366
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 366
    tmp = nexttoken();
    }
#line 366
    if (! tmp) {
#line 366
      goto while_break;
    }
#line 367
    identifier.storage = (enum storage )0;
    {
#line 369
    if (tok.type == 0) {
#line 369
      goto case_0;
    }
#line 371
    if (tok.type == 273) {
#line 371
      goto case_273;
    }
#line 373
    if (tok.type == 263) {
#line 373
      goto case_263;
    }
#line 376
    if (tok.type == 261) {
#line 376
      goto case_261;
    }
#line 380
    if (tok.type == 262) {
#line 380
      goto case_262;
    }
#line 384
    goto switch_default;
    case_0: /* CIL Label */ 
#line 370
    return (0);
    case_273: /* CIL Label */ 
#line 372
    goto while_continue;
    case_263: /* CIL Label */ 
    {
#line 374
    parse_typedef();
    }
#line 375
    goto switch_break;
    case_261: /* CIL Label */ 
    {
#line 377
    identifier.storage = (enum storage )1;
#line 378
    parse_declaration(& identifier, 0);
    }
#line 379
    goto switch_break;
    case_262: /* CIL Label */ 
    {
#line 381
    identifier.storage = (enum storage )2;
#line 382
    nexttoken();
    }
    switch_default: /* CIL Label */ 
    {
#line 385
    parse_declaration(& identifier, 0);
    }
#line 386
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 388
    cleanup_stack();
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 390
  return (0);
}
}
#line 393 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/parser.c"
static int is_function(void) 
{ 
  Stackpos sp ;
  int res ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 397
  res = 0;
#line 399
  mark((int *)(sp));
  }
  {
#line 400
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 407
    if (tok.type == 261) {
#line 407
      goto case_261;
    }
#line 407
    if (tok.type == 262) {
#line 407
      goto case_261;
    }
#line 407
    if (tok.type == 265) {
#line 407
      goto case_261;
    }
#line 407
    if (tok.type == 260) {
#line 407
      goto case_261;
    }
#line 407
    if (tok.type == 270) {
#line 407
      goto case_261;
    }
#line 407
    if (tok.type == 273) {
#line 407
      goto case_261;
    }
#line 410
    if (tok.type == 272) {
#line 410
      goto case_272;
    }
#line 415
    if (tok.type == 40) {
#line 415
      goto case_40;
    }
#line 418
    goto switch_default;
    case_261: /* CIL Label */ 
    case_262: /* CIL Label */ 
    case_265: /* CIL Label */ 
    case_260: /* CIL Label */ 
    case_270: /* CIL Label */ 
    case_273: /* CIL Label */ 
    {
#line 408
    nexttoken();
    }
#line 409
    goto while_continue;
    case_272: /* CIL Label */ 
    {
#line 411
    tmp___0 = skip_balanced('(', ')', 0);
    }
#line 411
    if (tmp___0 == -1) {
      {
#line 412
      tmp = gettext("unexpected end of file in declaration");
#line 412
      file_error(tmp, (TOKSTK *)((void *)0));
      }
    }
#line 414
    goto while_continue;
    case_40: /* CIL Label */ 
    {
#line 416
    tmp___1 = nexttoken();
#line 416
    res = tmp___1 != 265;
    }
#line 417
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 419
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 421
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 424
  restore((int *)(sp));
  }
#line 425
  return (res);
}
}
#line 428 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/parser.c"
void parse_declaration(Ident *ident___0 , int parm ) 
{ 
  int tmp ;

  {
  {
#line 431
  tmp = is_function();
  }
#line 431
  if (tmp) {
    {
#line 432
    parse_function_declaration(ident___0, parm);
    }
  } else {
    {
#line 434
    parse_variable_declaration(ident___0, parm);
    }
  }
  {
#line 435
  delete_parms(parm_level);
  }
#line 436
  return;
}
}
#line 439 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/parser.c"
void expression(void) 
{ 
  char *name ;
  int line ;
  int parens_lev ;
  char *tmp ;
  int tmp___0 ;

  {
#line 446
  parens_lev = 0;
  {
#line 447
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 449
    if (tok.type == 59) {
#line 449
      goto case_59;
    }
#line 454
    if (tok.type == 259) {
#line 454
      goto case_259;
    }
#line 454
    if (tok.type == 125) {
#line 454
      goto case_259;
    }
#line 454
    if (tok.type == 258) {
#line 454
      goto case_259;
    }
#line 454
    if (tok.type == 123) {
#line 454
      goto case_259;
    }
#line 457
    if (tok.type == 44) {
#line 457
      goto case_44;
    }
#line 461
    if (tok.type == 0) {
#line 461
      goto case_0;
    }
#line 467
    if (tok.type == 260) {
#line 467
      goto case_260;
    }
#line 484
    if (tok.type == 40) {
#line 484
      goto case_40;
    }
#line 493
    if (tok.type == 41) {
#line 493
      goto case_41;
    }
#line 448
    goto switch_break;
    case_59: /* CIL Label */ 
#line 450
    return;
    case_259: /* CIL Label */ 
    case_125: /* CIL Label */ 
    case_258: /* CIL Label */ 
    case_123: /* CIL Label */ 
    {
#line 455
    putback();
    }
#line 456
    return;
    case_44: /* CIL Label */ 
#line 458
    if (parens_lev == 0) {
#line 459
      return;
    }
#line 460
    goto switch_break;
    case_0: /* CIL Label */ 
#line 462
    if (verbose) {
      {
#line 463
      tmp = gettext("unexpected end of file in expression");
#line 463
      file_error(tmp, (TOKSTK *)((void *)0));
      }
    }
#line 465
    return;
    case_260: /* CIL Label */ 
    {
#line 468
    name = tok.token;
#line 469
    line = tok.line;
#line 470
    nexttoken();
    }
#line 471
    if (tok.type == 40) {
      {
#line 472
      call(name, line);
#line 473
      parens_lev ++;
      }
    } else {
      {
#line 475
      reference(name, line);
      }
#line 476
      if (tok.type == 269) {
        {
#line 477
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 477
          if (! (tok.type == 269)) {
#line 477
            goto while_break___0;
          }
          {
#line 478
          nexttoken();
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      } else {
        {
#line 480
        putback();
        }
      }
    }
#line 483
    goto switch_break;
    case_40: /* CIL Label */ 
    {
#line 486
    tmp___0 = nexttoken();
    }
#line 486
    if (tmp___0 == 270) {
      {
#line 487
      skip_to(')');
      }
    } else {
      {
#line 489
      putback();
#line 490
      parens_lev ++;
      }
    }
#line 492
    goto switch_break;
    case_41: /* CIL Label */ 
#line 494
    parens_lev --;
#line 495
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 497
    nexttoken();
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 501 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/parser.c"
void parse_function_declaration(Ident *ident___0 , int parm ) 
{ 
  int error_recovery ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 504
  error_recovery = 0;
#line 505
  ident___0->type_end = -1;
#line 506
  parse_knr_dcl(ident___0);
  }
  restart: 
  {
#line 510
  if (tok.type == 41) {
#line 510
    goto case_41;
  }
#line 525
  if (tok.type == 44) {
#line 525
    goto case_44;
  }
#line 525
  if (tok.type == 59) {
#line 525
    goto case_44;
  }
#line 528
  if (tok.type == 123) {
#line 528
    goto case_123;
  }
#line 528
  if (tok.type == 258) {
#line 528
    goto case_123;
  }
#line 534
  if (tok.type == 0) {
#line 534
    goto case_0;
  }
#line 514
  goto switch_default;
  case_41: /* CIL Label */ 
#line 511
  if (parm) {
#line 512
    goto switch_break;
  }
  switch_default: /* CIL Label */ 
#line 515
  if (error_recovery) {
    {
#line 516
    nexttoken();
    }
  } else {
#line 518
    if (verbose) {
      {
#line 519
      tmp = gettext("expected `;\'");
#line 519
      file_error(tmp, & tok);
      }
    }
#line 520
    error_recovery = 1;
  }
#line 522
  goto restart;
  case_44: /* CIL Label */ 
  case_59: /* CIL Label */ 
#line 526
  goto switch_break;
  case_123: /* CIL Label */ 
  case_258: /* CIL Label */ 
#line 529
  if (ident___0->name) {
    {
#line 530
    caller = lookup((char const   *)ident___0->name);
#line 531
    func_body();
    }
  }
#line 533
  goto switch_break;
  case_0: /* CIL Label */ 
#line 535
  if (verbose) {
    {
#line 536
    tmp___0 = gettext("unexpected end of file in declaration");
#line 536
    file_error(tmp___0, (TOKSTK *)((void *)0));
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 538
  return;
}
}
#line 540 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/parser.c"
int fake_struct(Ident *ident___0 ) 
{ 
  Stackpos sp ;
  int tmp ;
  TOKSTK hold ;
  char *tmp___0 ;

  {
  {
#line 545
  mark((int *)(sp));
#line 546
  ident___0->type_end = -1;
  }
#line 547
  if (tok.type == 264) {
    {
#line 548
    tmp = nexttoken();
    }
#line 548
    if (tmp == 260) {
#line 549
      ident___0->type_end = tos;
    }
    {
#line 551
    putback();
#line 552
    skip_struct();
    }
#line 553
    if (tok.type == 260) {
#line 553
      goto _L;
    } else
#line 553
    if (tok.type == 265) {
      _L: /* CIL Label */ 
      {
#line 554
      hold = tok;
#line 555
      restore((int *)(sp));
      }
#line 556
      if (ident___0->type_end == -1) {
#line 558
        tos = curs;
#line 559
        (token_stack + curs)->type = 260;
#line 560
        (token_stack + curs)->token = (char *)"{ ... }";
#line 561
        tos ++;
      } else {
#line 563
        tos = curs + 1;
      }
      {
#line 565
      tokpush(hold.type, hold.line, hold.token);
      }
    } else
#line 566
    if (tok.type == 40) {
#line 567
      return (0);
    } else
#line 568
    if (tok.type != 59) {
      {
#line 569
      tmp___0 = gettext("missing `;\' after struct declaration");
#line 569
      file_error(tmp___0, & tok);
      }
    }
#line 570
    return (1);
  }
#line 572
  return (0);
}
}
#line 575 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/parser.c"
void parse_variable_declaration(Ident *ident___0 , int parm ) 
{ 
  Stackpos sp ;
  int tmp ;
  TOKSTK hold ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 580
  mark((int *)(sp));
#line 581
  ident___0->type_end = -1;
  }
#line 582
  if (tok.type == 264) {
    {
#line 583
    tmp = nexttoken();
    }
#line 583
    if (tmp == 260) {
#line 584
      ident___0->type_end = tos;
    }
    {
#line 586
    putback();
#line 587
    skip_struct();
    }
    {
#line 588
    while (1) {
      while_continue: /* CIL Label */ ;
#line 588
      if (! (tok.type == 265)) {
#line 588
        if (! (tok.type == 273)) {
#line 588
          goto while_break;
        }
      }
      {
#line 589
      nexttoken();
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 590
    if (tok.type == 260) {
      {
#line 591
      hold = tok;
#line 592
      restore((int *)(sp));
      }
#line 593
      if (ident___0->type_end == -1) {
#line 595
        tos = curs;
#line 596
        (token_stack + curs)->type = 260;
#line 597
        (token_stack + curs)->token = (char *)"{ ... }";
#line 598
        tos ++;
      } else {
#line 600
        tos = curs + 1;
      }
      {
#line 602
      tokpush(hold.type, hold.line, hold.token);
      }
    } else {
#line 604
      if (tok.type == 59) {
#line 605
        return;
      }
      {
#line 606
      restore((int *)(sp));
      }
    }
  }
  again: 
  {
#line 610
  parse_dcl(ident___0, 0);
  }
  select: 
  {
#line 614
  if (tok.type == 41) {
#line 614
    goto case_41;
  }
#line 623
  if (tok.type == 59) {
#line 623
    goto case_59;
  }
#line 625
  if (tok.type == 44) {
#line 625
    goto case_44;
  }
#line 631
  if (tok.type == 61) {
#line 631
    goto case_61;
  }
#line 640
  if (tok.type == 123) {
#line 640
    goto case_123;
  }
#line 640
  if (tok.type == 258) {
#line 640
    goto case_123;
  }
#line 643
  if (tok.type == 0) {
#line 643
    goto case_0;
  }
#line 618
  goto switch_default;
  case_41: /* CIL Label */ 
#line 615
  if (parm) {
#line 616
    goto switch_break;
  }
  switch_default: /* CIL Label */ 
#line 619
  if (verbose) {
    {
#line 620
    tmp___0 = gettext("expected `;\'");
#line 620
    file_error(tmp___0, & tok);
    }
  }
  case_59: /* CIL Label */ 
#line 624
  goto switch_break;
  case_44: /* CIL Label */ 
#line 626
  if (parm) {
#line 627
    goto switch_break;
  }
  {
#line 628
  tos = ident___0->type_end;
#line 629
  restore((int *)(sp));
  }
#line 630
  goto again;
  case_61: /* CIL Label */ 
  {
#line 632
  nexttoken();
  }
#line 633
  if (tok.type == 123) {
    {
#line 634
    initializer_list();
    }
  } else
#line 633
  if (tok.type == 258) {
    {
#line 634
    initializer_list();
    }
  } else {
    {
#line 636
    expression();
    }
  }
#line 637
  goto select;
#line 638
  goto switch_break;
  case_123: /* CIL Label */ 
  case_258: /* CIL Label */ 
  {
#line 641
  func_body();
  }
#line 642
  goto switch_break;
  case_0: /* CIL Label */ 
#line 644
  if (verbose) {
    {
#line 645
    tmp___1 = gettext("unexpected end of file in declaration");
#line 645
    file_error(tmp___1, (TOKSTK *)((void *)0));
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 647
  return;
}
}
#line 649 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/parser.c"
void initializer_list(void) 
{ 
  int lev ;
  char *tmp ;

  {
#line 652
  lev = 0;
  {
#line 653
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 656
    if (tok.type == 258) {
#line 656
      goto case_258;
    }
#line 656
    if (tok.type == 123) {
#line 656
      goto case_258;
    }
#line 660
    if (tok.type == 259) {
#line 660
      goto case_259;
    }
#line 660
    if (tok.type == 125) {
#line 660
      goto case_259;
    }
#line 666
    if (tok.type == 0) {
#line 666
      goto case_0;
    }
#line 670
    if (tok.type == 44) {
#line 670
      goto case_44;
    }
#line 672
    goto switch_default;
    case_258: /* CIL Label */ 
    case_123: /* CIL Label */ 
#line 657
    lev ++;
#line 658
    goto switch_break;
    case_259: /* CIL Label */ 
    case_125: /* CIL Label */ 
#line 661
    lev --;
#line 661
    if (lev <= 0) {
      {
#line 662
      nexttoken();
      }
#line 663
      return;
    }
#line 665
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 667
    tmp = gettext("unexpected end of file in initializer list");
#line 667
    file_error(tmp, (TOKSTK *)((void *)0));
    }
#line 669
    return;
    case_44: /* CIL Label */ 
#line 671
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 673
    expression();
    }
#line 674
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 676
    nexttoken();
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 680 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/parser.c"
void parse_knr_dcl(Ident *ident___0 ) 
{ 


  {
  {
#line 683
  ident___0->type_end = -1;
#line 684
  parse_dcl(ident___0, ! strict_ansi);
  }
#line 685
  return;
}
}
#line 687 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/parser.c"
void skip_struct(void) 
{ 
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 690
  tmp = nexttoken();
  }
#line 690
  if (tmp == 260) {
    {
#line 691
    nexttoken();
    }
  } else
#line 692
  if (tok.type == 59) {
#line 693
    return;
  }
#line 695
  if (tok.type == 123) {
#line 695
    goto _L;
  } else
#line 695
  if (tok.type == 258) {
    _L: /* CIL Label */ 
    {
#line 696
    tmp___1 = skip_balanced('{', '}', 1);
    }
#line 696
    if (tmp___1 == -1) {
      {
#line 697
      tmp___0 = gettext("unexpected end of file in struct");
#line 697
      file_error(tmp___0, (TOKSTK *)((void *)0));
      }
#line 698
      return;
    }
  }
  {
#line 702
  while (1) {
    while_continue: /* CIL Label */ ;
#line 702
    if (! (tok.type == 272)) {
#line 702
      goto while_break;
    }
    {
#line 703
    tmp___3 = skip_balanced('(', ')', 0);
    }
#line 703
    if (tmp___3 == -1) {
      {
#line 704
      tmp___2 = gettext("unexpected end of file in struct");
#line 704
      file_error(tmp___2, (TOKSTK *)((void *)0));
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 706
  return;
}
}
#line 708 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/parser.c"
void parse_typedef(void) 
{ 
  Ident ident___0 ;
  int tmp ;

  {
  {
#line 713
  ident___0.name = (char *)((void *)0);
#line 714
  ident___0.type_end = -1;
#line 715
  ident___0.parmcnt = -1;
#line 716
  ident___0.line = -1;
#line 717
  ident___0.storage = (enum storage )4;
#line 719
  nexttoken();
#line 720
  tmp = fake_struct(& ident___0);
  }
#line 720
  if (! tmp) {
    {
#line 721
    putback();
    }
  }
  {
#line 723
  dcl(& ident___0);
  }
#line 724
  if (ident___0.name) {
    {
#line 725
    declare_type(& ident___0);
    }
  }
#line 726
  return;
}
}
#line 728 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/parser.c"
void parse_dcl(Ident *ident___0 , int maybe_knr ) 
{ 


  {
  {
#line 731
  ident___0->parmcnt = -1;
#line 732
  ident___0->name = (char *)((void *)0);
#line 733
  putback();
#line 734
  dcl(ident___0);
#line 735
  save_stack();
  }
#line 736
  if (ident___0->name) {
    {
#line 737
    declare(ident___0, maybe_knr);
    }
  } else {
    {
#line 739
    undo_save_stack();
    }
  }
#line 740
  return;
}
}
#line 742 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/parser.c"
int dcl(Ident *idptr ) 
{ 
  char *tmp ;
  int tmp___0 ;
  int type ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 745
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 745
    tmp___1 = nexttoken();
    }
#line 745
    if (tmp___1 != 0) {
#line 745
      if (! (tok.type != 40)) {
#line 745
        goto while_break;
      }
    } else {
#line 745
      goto while_break;
    }
#line 746
    if (tok.type == 265) {
#line 747
      if (idptr) {
#line 747
        if (idptr->type_end == -1) {
#line 748
          idptr->type_end = curs - 1;
        }
      }
    } else
#line 749
    if (tok.type == 272) {
      {
#line 750
      tmp___0 = skip_balanced('(', ')', 0);
      }
#line 750
      if (tmp___0 == -1) {
        {
#line 751
        tmp = gettext("unexpected end of file in function declaration");
#line 751
        file_error(tmp, (TOKSTK *)((void *)0));
        }
#line 753
        return (1);
      }
    } else
#line 755
    if (tok.type == 260) {
      {
#line 758
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 758
        if (! (tok.type == 260)) {
#line 758
          goto while_break___0;
        }
        {
#line 759
        nexttoken();
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 760
      type = tok.type;
#line 761
      putback();
      }
#line 762
      if (! (type == 270)) {
#line 762
        if (! (type == 265)) {
#line 762
          if (! (type == 273)) {
#line 764
            goto while_break;
          }
        }
      }
    } else
#line 765
    if (tok.type == 41) {
#line 766
      return (1);
    } else
#line 765
    if (tok.type == 59) {
#line 766
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 769
  if (idptr) {
#line 769
    if (idptr->type_end == -1) {
#line 770
      idptr->type_end = curs - 1;
    }
  }
  {
#line 771
  tmp___2 = dirdcl(idptr);
  }
#line 771
  return (tmp___2);
}
}
#line 774 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/parser.c"
int dirdcl(Ident *idptr ) 
{ 
  int wrapper ;
  int *parm_ptr ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 777
  wrapper = 0;
#line 778
  parm_ptr = (int *)((void *)0);
#line 780
  if (tok.type == 40) {
    {
#line 781
    dcl(idptr);
    }
#line 782
    if (tok.type != 41) {
#line 782
      if (verbose) {
        {
#line 783
        tmp = gettext("expected `)\'");
#line 783
        file_error(tmp, & tok);
        }
#line 784
        return (1);
      }
    }
  } else
#line 786
  if (tok.type == 260) {
#line 787
    if (idptr) {
#line 788
      idptr->name = tok.token;
#line 789
      idptr->line = tok.line;
#line 790
      parm_ptr = & idptr->parmcnt;
    }
  }
  {
#line 794
  tmp___0 = nexttoken();
  }
#line 794
  if (tmp___0 == 272) {
    {
#line 795
    wrapper = 1;
#line 796
    nexttoken();
    }
  } else {
    {
#line 798
    putback();
    }
  }
  {
#line 800
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 800
    tmp___2 = nexttoken();
    }
#line 800
    if (! (tmp___2 == 91)) {
#line 800
      if (! (tok.type == 40)) {
#line 800
        goto while_break;
      }
    }
#line 801
    if (tok.type == 91) {
      {
#line 802
      skip_to(']');
      }
    } else {
      {
#line 804
      maybe_parm_list(parm_ptr);
      }
#line 805
      if (tok.type != 41) {
#line 805
        if (verbose) {
          {
#line 806
          tmp___1 = gettext("expected `)\'");
#line 806
          file_error(tmp___1, & tok);
          }
#line 807
          return (1);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 811
  if (wrapper) {
    {
#line 812
    nexttoken();
    }
  }
  {
#line 814
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 814
    if (! (tok.type == 272)) {
#line 814
      goto while_break___0;
    }
    {
#line 815
    tmp___4 = skip_balanced('(', ')', 0);
    }
#line 815
    if (tmp___4 == -1) {
      {
#line 816
      tmp___3 = gettext("unexpected end of file in function declaration");
#line 816
      file_error(tmp___3, (TOKSTK *)((void *)0));
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 820
  return (0);
}
}
#line 823 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/parser.c"
int parmdcl(Ident *idptr ) 
{ 
  int type ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 828
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 828
    tmp = nexttoken();
    }
#line 828
    if (tmp != 0) {
#line 828
      if (! (tok.type != 40)) {
#line 828
        goto while_break;
      }
    } else {
#line 828
      goto while_break;
    }
#line 829
    if (tok.type == 265) {
#line 830
      if (idptr) {
#line 830
        if (idptr->type_end == -1) {
#line 831
          idptr->type_end = curs - 1;
        }
      }
    } else
#line 832
    if (tok.type == 260) {
      {
#line 833
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 833
        if (! (tok.type == 260)) {
#line 833
          goto while_break___0;
        }
        {
#line 834
        nexttoken();
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 835
      type = tok.type;
#line 836
      putback();
      }
#line 837
      if (type != 265) {
#line 838
        goto while_break;
      }
    } else
#line 839
    if (tok.type == 41) {
#line 840
      return (0);
    } else
#line 839
    if (tok.type == 44) {
#line 840
      return (0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 842
  if (idptr) {
#line 842
    if (idptr->type_end == -1) {
#line 843
      idptr->type_end = curs - 1;
    }
  }
  {
#line 844
  tmp___0 = dirdcl(idptr);
  }
#line 844
  return (tmp___0);
}
}
#line 848 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/parser.c"
void maybe_parm_list(int *parm_cnt_return ) 
{ 
  int parmcnt ;
  Ident ident___0 ;
  int level___0 ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
#line 851
  parmcnt = 0;
#line 855
  parm_level ++;
  {
#line 856
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 856
    tmp___2 = nexttoken();
    }
#line 856
    if (! tmp___2) {
#line 856
      goto while_break;
    }
    {
#line 858
    if (tok.type == 41) {
#line 858
      goto case_41;
    }
#line 863
    if (tok.type == 44) {
#line 863
      goto case_44;
    }
#line 870
    if (tok.type == 270) {
#line 870
      goto case_270;
    }
#line 870
    if (tok.type == 267) {
#line 870
      goto case_270;
    }
#line 870
    if (tok.type == 264) {
#line 870
      goto case_270;
    }
#line 870
    if (tok.type == 265) {
#line 870
      goto case_270;
    }
#line 870
    if (tok.type == 260) {
#line 870
      goto case_270;
    }
#line 870
    if (tok.type == 273) {
#line 870
      goto case_270;
    }
#line 876
    goto switch_default;
    case_41: /* CIL Label */ 
#line 859
    if (parm_cnt_return) {
#line 860
      *parm_cnt_return = parmcnt;
    }
#line 861
    parm_level --;
#line 862
    return;
    case_44: /* CIL Label */ 
#line 864
    goto switch_break;
    case_270: /* CIL Label */ 
    case_267: /* CIL Label */ 
    case_264: /* CIL Label */ 
    case_265: /* CIL Label */ 
    case_260: /* CIL Label */ 
    case_273: /* CIL Label */ 
    {
#line 871
    parmcnt ++;
#line 872
    ident___0.storage = (enum storage )3;
#line 873
    parse_declaration(& ident___0, 1);
#line 874
    putback();
    }
#line 875
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 877
    if (verbose) {
      {
#line 878
      tmp = gettext("unexpected token in parameter list");
#line 878
      file_error(tmp, & tok);
      }
    }
#line 880
    level___0 = 0;
    {
#line 881
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 882
      if (tok.type == 40) {
#line 883
        level___0 ++;
      } else
#line 884
      if (tok.type == 41) {
#line 885
        tmp___0 = level___0;
#line 885
        level___0 --;
#line 885
        if (tmp___0 == 0) {
#line 886
          goto while_break___0;
        }
      }
      {
#line 881
      tmp___1 = nexttoken();
      }
#line 881
      if (! tmp___1) {
#line 881
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 890
    putback();
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 893
  if (verbose) {
    {
#line 894
    tmp___3 = gettext("unexpected end of file in parameter list");
#line 894
    file_error(tmp___3, (TOKSTK *)((void *)0));
    }
  }
#line 895
  return;
}
}
#line 897 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/parser.c"
void func_body(void) 
{ 
  Ident ident___0 ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 902
  level ++;
#line 903
  move_parms(level);
  }
  {
#line 904
  while (1) {
    while_continue: /* CIL Label */ ;
#line 904
    if (! level) {
#line 904
      goto while_break;
    }
    {
#line 905
    cleanup_stack();
#line 906
    nexttoken();
    }
    {
#line 911
    if (tok.type == 262) {
#line 911
      goto case_262;
    }
#line 917
    if (tok.type == 264) {
#line 917
      goto case_264;
    }
#line 917
    if (tok.type == 270) {
#line 917
      goto case_264;
    }
#line 921
    if (tok.type == 261) {
#line 921
      goto case_261;
    }
#line 926
    if (tok.type == 123) {
#line 926
      goto case_123;
    }
#line 926
    if (tok.type == 258) {
#line 926
      goto case_123;
    }
#line 929
    if (tok.type == 259) {
#line 929
      goto case_259;
    }
#line 940
    if (tok.type == 125) {
#line 940
      goto case_125;
    }
#line 944
    if (tok.type == 0) {
#line 944
      goto case_0;
    }
#line 908
    goto switch_default;
    switch_default: /* CIL Label */ 
    {
#line 909
    expression();
    }
#line 910
    goto switch_break;
    case_262: /* CIL Label */ 
    {
#line 912
    ident___0.storage = (enum storage )2;
#line 913
    nexttoken();
#line 914
    parse_variable_declaration(& ident___0, 0);
    }
#line 915
    goto switch_break;
    case_264: /* CIL Label */ 
    case_270: /* CIL Label */ 
    {
#line 918
    ident___0.storage = (enum storage )3;
#line 919
    parse_variable_declaration(& ident___0, 0);
    }
#line 920
    goto switch_break;
    case_261: /* CIL Label */ 
    {
#line 922
    ident___0.storage = (enum storage )1;
#line 923
    parse_declaration(& ident___0, 0);
    }
#line 924
    goto switch_break;
    case_123: /* CIL Label */ 
    case_258: /* CIL Label */ 
#line 927
    level ++;
#line 928
    goto switch_break;
    case_259: /* CIL Label */ 
#line 930
    if (use_indentation) {
#line 931
      if (verbose) {
#line 931
        if (level != 1) {
          {
#line 932
          tmp = gettext("forced function body close");
#line 932
          file_error(tmp, (TOKSTK *)((void *)0));
          }
        }
      }
      {
#line 933
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 933
        if (! level) {
#line 933
          goto while_break___0;
        }
        {
#line 934
        delete_autos(level);
#line 933
        level --;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 936
      goto switch_break;
    }
    case_125: /* CIL Label */ 
    {
#line 941
    delete_autos(level);
#line 942
    level --;
    }
#line 943
    goto switch_break;
    case_0: /* CIL Label */ 
#line 945
    if (verbose) {
      {
#line 946
      tmp___0 = gettext("unexpected end of file in function body");
#line 946
      file_error(tmp___0, (TOKSTK *)((void *)0));
      }
    }
#line 948
    caller = (Symbol *)((void *)0);
#line 949
    return;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 952
  caller = (Symbol *)((void *)0);
#line 953
  return;
}
}
#line 955 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/parser.c"
int get_knr_args(Ident *ident___0 ) 
{ 
  int parmcnt ;
  int stop ;
  Stackpos sp ;
  Stackpos new_sp ;
  Ident id ;
  int tmp ;

  {
  {
#line 965
  if (tok.type == 264) {
#line 965
    goto case_264;
  }
#line 965
  if (tok.type == 270) {
#line 965
    goto case_264;
  }
#line 965
  if (tok.type == 260) {
#line 965
    goto case_264;
  }
#line 962
  goto switch_break;
  case_264: /* CIL Label */ 
  case_270: /* CIL Label */ 
  case_260: /* CIL Label */ 
  {
#line 968
  mark((int *)(sp));
#line 969
  parmcnt = 0;
#line 971
  stop = 0;
  }
  {
#line 971
  while (1) {
    while_continue: /* CIL Label */ ;
#line 971
    if (! stop) {
#line 971
      if (! (parmcnt < ident___0->parmcnt)) {
#line 971
        goto while_break;
      }
    } else {
#line 971
      goto while_break;
    }
#line 973
    id.type_end = -1;
    {
#line 976
    if (tok.type == 258) {
#line 976
      goto case_258;
    }
#line 976
    if (tok.type == 123) {
#line 976
      goto case_258;
    }
#line 982
    if (tok.type == 264) {
#line 982
      goto case_264___0;
    }
#line 982
    if (tok.type == 260) {
#line 982
      goto case_264___0;
    }
#line 982
    if (tok.type == 270) {
#line 982
      goto case_264___0;
    }
#line 999
    goto switch_default;
    case_258: /* CIL Label */ 
    case_123: /* CIL Label */ 
    {
#line 977
    putback();
#line 978
    stop = 1;
    }
#line 979
    goto switch_break___0;
    case_264___0: /* CIL Label */ 
    case_260___0: /* CIL Label */ 
    case_270___0: /* CIL Label */ 
    {
#line 983
    putback();
#line 984
    mark((int *)(new_sp));
#line 985
    tmp = dcl(& id);
    }
#line 985
    if (tmp == 0) {
#line 986
      parmcnt ++;
#line 987
      if (tok.type == 44) {
        {
#line 988
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 989
          tos = id.type_end;
#line 990
          restore((int *)(new_sp));
#line 991
          dcl(& id);
          }
#line 988
          if (! (tok.type == 44)) {
#line 988
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      } else
#line 993
      if (tok.type != 59) {
        {
#line 994
        putback();
        }
      }
#line 995
      goto switch_break___0;
    }
    switch_default: /* CIL Label */ 
    {
#line 1000
    restore((int *)(sp));
    }
#line 1001
    return (1);
    switch_break___0: /* CIL Label */ ;
    }
    {
#line 971
    nexttoken();
    }
  }
  while_break: /* CIL Label */ ;
  }
  switch_break: /* CIL Label */ ;
  }
#line 1005
  return (0);
}
}
#line 1008 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/parser.c"
void declare(Ident *ident___0 , int maybe_knr ) 
{ 
  Symbol *sp ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  unsigned int tmp___3 ;
  char *tmp___4 ;

  {
#line 1013
  if ((unsigned int )ident___0->storage == 3U) {
    {
#line 1014
    undo_save_stack();
#line 1015
    sp = install_ident(ident___0->name, ident___0->storage);
    }
#line 1016
    if (parm_level) {
#line 1017
      sp->level = parm_level;
#line 1018
      sp->flag = (enum symbol_flag )2;
    } else {
#line 1020
      sp->level = level;
    }
#line 1021
    sp->arity = -1;
#line 1022
    return;
  }
#line 1025
  if (ident___0->parmcnt >= 0) {
#line 1025
    if (! maybe_knr) {
#line 1025
      goto _L___1;
    } else {
      {
#line 1025
      tmp = get_knr_args(ident___0);
      }
#line 1025
      if (tmp == 0) {
        _L___1: /* CIL Label */ 
#line 1025
        if (tok.type == 123) {
#line 1025
          goto _L___0;
        } else
#line 1025
        if (tok.type == 258) {
#line 1025
          goto _L___0;
        } else
#line 1025
        if (tok.type == 270) {
#line 1025
          goto _L___0;
        } else
#line 1025
        if (tok.type == 272) {
#line 1025
          goto _L___0;
        } else {
          {
#line 1030
          undo_save_stack();
          }
#line 1032
          return;
        }
      } else {
#line 1025
        goto _L___0;
      }
    }
  } else
  _L___0: /* CIL Label */ 
#line 1025
  if (ident___0->parmcnt < 0) {
#line 1025
    if ((unsigned int )ident___0->storage == 1U) {
      {
#line 1030
      undo_save_stack();
      }
#line 1032
      return;
    }
  }
  {
#line 1035
  sp = get_symbol(ident___0->name);
  }
#line 1036
  if (sp->source) {
#line 1037
    if ((unsigned int )ident___0->storage == 2U) {
#line 1037
      if ((unsigned int )sp->storage != 2U) {
        {
#line 1039
        sp = install_ident(ident___0->name, ident___0->storage);
        }
      } else
#line 1037
      if (level > 0) {
        {
#line 1039
        sp = install_ident(ident___0->name, ident___0->storage);
        }
      } else {
#line 1037
        goto _L___2;
      }
    } else {
      _L___2: /* CIL Label */ 
#line 1041
      if (sp->arity >= 0) {
        {
#line 1042
        tmp___0 = gettext("%s/%d redefined");
#line 1042
        error_at_line(0, 0, (char const   *)filename, (unsigned int )ident___0->line,
                      (char const   *)tmp___0, ident___0->name, sp->arity);
        }
      } else {
        {
#line 1046
        tmp___1 = gettext("%s redefined");
#line 1046
        error_at_line(0, 0, (char const   *)filename, (unsigned int )ident___0->line,
                      (char const   *)tmp___1, ident___0->name);
        }
      }
      {
#line 1049
      tmp___2 = gettext("this is the place of previous definition");
#line 1049
      error_at_line(0, 0, (char const   *)sp->source, (unsigned int )sp->def_line,
                    (char const   *)tmp___2);
      }
    }
  }
#line 1054
  sp->type = (enum symtype )2;
#line 1055
  sp->arity = ident___0->parmcnt;
#line 1056
  if ((unsigned int )ident___0->storage == 1U) {
#line 1056
    tmp___3 = 0U;
  } else {
#line 1056
    tmp___3 = (unsigned int )ident___0->storage;
  }
  {
#line 1056
  ident_change_storage(sp, (enum storage )tmp___3);
#line 1059
  sp->decl = finish_save_stack(ident___0->name);
#line 1060
  sp->source = filename;
#line 1061
  sp->def_line = ident___0->line;
#line 1062
  sp->level = level;
  }
#line 1063
  if (debug) {
    {
#line 1064
    tmp___4 = gettext("%s:%d: %s/%d defined to %s\n");
#line 1064
    printf((char const   */* __restrict  */)tmp___4, filename, line_num, ident___0->name,
           ident___0->parmcnt, sp->decl);
    }
  }
#line 1069
  return;
}
}
#line 1071 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/parser.c"
void declare_type(Ident *ident___0 ) 
{ 
  Symbol *sp ;
  char *tmp ;

  {
  {
#line 1076
  undo_save_stack();
#line 1077
  sp = lookup((char const   *)ident___0->name);
  }
  {
#line 1078
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1078
    if (! sp) {
#line 1078
      goto while_break;
    }
#line 1079
    if ((unsigned int )sp->type == 1U) {
#line 1079
      if (sp->token_type == 270) {
#line 1080
        goto while_break;
      }
    }
#line 1078
    sp = sp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1081
  if (! sp) {
    {
#line 1082
    sp = install(ident___0->name, 4);
    }
  }
#line 1083
  sp->type = (enum symtype )1;
#line 1084
  sp->token_type = 270;
#line 1085
  sp->source = filename;
#line 1086
  sp->def_line = ident___0->line;
#line 1087
  sp->ref_line = (struct linked_list *)((void *)0);
#line 1088
  if (debug) {
    {
#line 1089
    tmp = gettext("%s:%d: type %s\n");
#line 1089
    printf((char const   */* __restrict  */)tmp, filename, line_num, ident___0->name);
    }
  }
#line 1090
  return;
}
}
#line 1092 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/parser.c"
Symbol *get_symbol(char *name ) 
{ 
  Symbol *sp ;
  Symbol *tmp ;
  int tmp___0 ;
  Symbol *tmp___1 ;

  {
  {
#line 1095
  tmp = lookup((char const   *)name);
#line 1095
  sp = tmp;
  }
#line 1097
  if (sp) {
    {
#line 1098
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1098
      if (! sp) {
#line 1098
        goto while_break;
      }
#line 1099
      if ((unsigned int )sp->type == 2U) {
        {
#line 1099
        tmp___0 = strcmp((char const   *)sp->name, (char const   *)name);
        }
#line 1099
        if (tmp___0 == 0) {
#line 1100
          goto while_break;
        }
      }
#line 1098
      sp = sp->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 1102
    if (sp) {
#line 1103
      return (sp);
    }
  }
  {
#line 1105
  tmp___1 = install_ident(name, (enum storage )0);
  }
#line 1105
  return (tmp___1);
}
}
#line 1108 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/parser.c"
Symbol *add_reference(char *name , int line ) 
{ 
  Symbol *sp ;
  Symbol *tmp ;
  Ref *refptr ;
  int tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 1111
  tmp = get_symbol(name);
#line 1111
  sp = tmp;
  }
#line 1114
  if ((unsigned int )sp->storage == 3U) {
#line 1116
    return ((Symbol *)((void *)0));
  } else
#line 1114
  if ((unsigned int )sp->storage == 2U) {
    {
#line 1114
    tmp___0 = globals_only();
    }
#line 1114
    if (tmp___0) {
#line 1116
      return ((Symbol *)((void *)0));
    }
  }
  {
#line 1117
  tmp___1 = xmalloc(sizeof(*refptr));
#line 1117
  refptr = (Ref *)tmp___1;
#line 1118
  refptr->source = filename;
#line 1119
  refptr->line = line;
  }
#line 1120
  if (! sp->ref_line) {
    {
#line 1121
    sp->ref_line = linked_list_create((void (*)(void * ))(& free));
    }
  }
  {
#line 1122
  linked_list_append(& sp->ref_line, (void *)refptr);
  }
#line 1123
  return (sp);
}
}
#line 1127 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/parser.c"
void call(char *name , int line ) 
{ 
  Symbol *sp ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1132
  sp = add_reference(name, line);
  }
#line 1133
  if (! sp) {
#line 1134
    return;
  }
#line 1135
  if (sp->arity < 0) {
#line 1136
    sp->arity = 0;
  }
#line 1137
  if (caller) {
    {
#line 1138
    tmp = data_in_list((void *)caller, sp->caller);
    }
#line 1138
    if (! tmp) {
      {
#line 1139
      linked_list_append(& sp->caller, (void *)caller);
      }
    }
    {
#line 1140
    tmp___0 = data_in_list((void *)sp, caller->callee);
    }
#line 1140
    if (! tmp___0) {
      {
#line 1141
      linked_list_append(& caller->callee, (void *)sp);
      }
    }
  }
#line 1143
  return;
}
}
#line 1145 "/home/june/repo/benchmarks/collector/temp/cflow-1.4+dfsg1/src/parser.c"
void reference(char *name , int line ) 
{ 
  Symbol *sp ;
  Symbol *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1148
  tmp = add_reference(name, line);
#line 1148
  sp = tmp;
  }
#line 1149
  if (! sp) {
#line 1150
    return;
  }
#line 1151
  if (caller) {
    {
#line 1152
    tmp___0 = data_in_list((void *)caller, sp->caller);
    }
#line 1152
    if (! tmp___0) {
      {
#line 1153
      linked_list_append(& sp->caller, (void *)caller);
      }
    }
    {
#line 1154
    tmp___1 = data_in_list((void *)sp, caller->callee);
    }
#line 1154
    if (! tmp___1) {
      {
#line 1155
      linked_list_append(& caller->callee, (void *)sp);
      }
    }
  }
#line 1157
  return;
}
}
