/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 136 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __rlim_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_3 {
   __fd_mask fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_3 fd_set;
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 31 "/usr/include/x86_64-linux-gnu/bits/resource.h"
enum __rlimit_resource {
    RLIMIT_CPU = 0,
    RLIMIT_FSIZE = 1,
    RLIMIT_DATA = 2,
    RLIMIT_STACK = 3,
    RLIMIT_CORE = 4,
    __RLIMIT_RSS = 5,
    RLIMIT_NOFILE = 7,
    __RLIMIT_OFILE = 7,
    RLIMIT_AS = 9,
    __RLIMIT_NPROC = 6,
    __RLIMIT_MEMLOCK = 8,
    __RLIMIT_LOCKS = 10,
    __RLIMIT_SIGPENDING = 11,
    __RLIMIT_MSGQUEUE = 12,
    __RLIMIT_NICE = 13,
    __RLIMIT_RTPRIO = 14,
    __RLIMIT_RTTIME = 15,
    __RLIMIT_NLIMITS = 16,
    __RLIM_NLIMITS = 16
} ;
#line 131 "/usr/include/x86_64-linux-gnu/bits/resource.h"
typedef __rlim_t rlim_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/resource.h"
struct rlimit {
   rlim_t rlim_cur ;
   rlim_t rlim_max ;
};
#line 38 "/usr/include/x86_64-linux-gnu/sys/resource.h"
typedef enum __rlimit_resource __rlimit_resource_t;
#line 12 "/home/wheatley/newnew/temp/proxycheck-0.49a/event.h"
struct ev_ct;
#line 13
struct ev_tm;
#line 15 "/home/wheatley/newnew/temp/proxycheck-0.49a/event.h"
typedef long long ev_time_t;
#line 47 "/home/wheatley/newnew/temp/proxycheck-0.49a/event.h"
typedef void ev_io_cbck_f(void *data , int revents , int fd , struct ev_ct *ct );
#line 57 "/home/wheatley/newnew/temp/proxycheck-0.49a/event.h"
typedef void ev_tm_cbck_f(void *data , struct ev_tm *tmr , struct ev_ct *ct );
#line 59 "/home/wheatley/newnew/temp/proxycheck-0.49a/event.h"
struct ev_tm {
   struct ev_tm *evtm_prev ;
   struct ev_tm *evtm_next ;
   ev_time_t evtm_when ;
   ev_tm_cbck_f *evtm_cbck ;
   void *evtm_data ;
};
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 55 "/usr/include/stdint.h"
typedef unsigned long uint64_t;
#line 79 "/usr/include/x86_64-linux-gnu/sys/epoll.h"
union epoll_data {
   void *ptr ;
   int fd ;
   uint32_t u32 ;
   uint64_t u64 ;
};
#line 79 "/usr/include/x86_64-linux-gnu/sys/epoll.h"
typedef union epoll_data epoll_data_t;
#line 87 "/usr/include/x86_64-linux-gnu/sys/epoll.h"
struct epoll_event {
   uint32_t events ;
   epoll_data_t data ;
} __attribute__((__packed__)) ;
#line 36 "/usr/include/x86_64-linux-gnu/sys/poll.h"
typedef unsigned long nfds_t;
#line 39 "/usr/include/x86_64-linux-gnu/sys/poll.h"
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
#line 50 "/home/wheatley/newnew/temp/proxycheck-0.49a/event.c"
struct ev_fd {
   short events ;
   short revents ;
   int pfdi ;
   ev_io_cbck_f *cbck ;
   void *data ;
   struct ev_fd *next ;
};
#line 61
struct ev_method;
#line 73 "/home/wheatley/newnew/temp/proxycheck-0.49a/event.c"
struct ev_ct {
   struct ev_tm *tmhead ;
   struct ev_tm *tmtail ;
   int tmcnt ;
   ev_time_t tmsum ;
   int loop ;
   struct ev_fd *efd ;
   int aefd ;
   int maxfd ;
   int nfd ;
   struct ev_method  const  *method ;
   int sigpipe[2] ;
   int sigcnt ;
   int qfd ;
   struct pollfd *pfd ;
   int apfd ;
   fd_set rfdset ;
   fd_set wfdset ;
   fd_set xfdset ;
};
#line 529 "/home/wheatley/newnew/temp/proxycheck-0.49a/event.c"
struct ev_method {
   char const   *name ;
   int type ;
   int (*init)(struct ev_ct *ct , int maxfd ) ;
   int (*wait)(struct ev_ct *ct , int tmo , struct ev_fd **pefd ) ;
   int (*add)(struct ev_ct *ct , int fd , int events ) ;
   int (*mod)(struct ev_ct *ct , int fd , int events ) ;
   int (*del)(struct ev_ct *ct , int fd ) ;
   int maxfd ;
};
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 220 "/usr/include/unistd.h"
typedef __ssize_t ssize_t;
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 90 "/usr/include/x86_64-linux-gnu/sys/socket.h"
struct sockaddr_in;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 100 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 23 "/home/wheatley/newnew/temp/proxycheck-0.49a/pxy.h"
struct pxyconn;
#line 23 "/home/wheatley/newnew/temp/proxycheck-0.49a/pxy.h"
typedef struct pxyconn pxyconn_t;
#line 25 "/home/wheatley/newnew/temp/proxycheck-0.49a/pxy.h"
typedef unsigned short ipport_t;
#line 27 "/home/wheatley/newnew/temp/proxycheck-0.49a/pxy.h"
struct __anonstruct_pxybuf_t_63 {
   unsigned int len ;
   char buf[128UL - 3UL * sizeof(unsigned int )] ;
};
#line 27 "/home/wheatley/newnew/temp/proxycheck-0.49a/pxy.h"
typedef struct __anonstruct_pxybuf_t_63 pxybuf_t;
#line 35 "/home/wheatley/newnew/temp/proxycheck-0.49a/pxy.h"
struct __anonstruct_pxyproto_t_64 {
   char const   *name ;
   char const   *aname ;
   char const   *transport ;
   char const   *fullname ;
   int family ;
   void (*handler)(pxyconn_t * , int  ) ;
   int (*check)(pxyconn_t *c , char *buf , int l ) ;
};
#line 35 "/home/wheatley/newnew/temp/proxycheck-0.49a/pxy.h"
typedef struct __anonstruct_pxyproto_t_64 pxyproto_t;
#line 47 "/home/wheatley/newnew/temp/proxycheck-0.49a/pxy.h"
struct __anonstruct_pxyprobe_t_65 {
   pxyproto_t const   *proto ;
   ipport_t const   *ports ;
   int advanced ;
};
#line 47 "/home/wheatley/newnew/temp/proxycheck-0.49a/pxy.h"
typedef struct __anonstruct_pxyprobe_t_65 pxyprobe_t;
#line 62 "/home/wheatley/newnew/temp/proxycheck-0.49a/pxy.h"
struct pxyconn {
   int fd ;
   struct in_addr pxyaddr ;
   struct in_addr dstaddr ;
   ipport_t pxyport ;
   ipport_t dstport ;
   pxyproto_t const   *proto ;
   pxybuf_t *buf ;
   int pxystate ;
   int appstate ;
   int nread ;
   void *data ;
   char *detail ;
   struct ev_tm timer ;
   pxyconn_t *next ;
};
#line 25 "/home/wheatley/newnew/temp/proxycheck-0.49a/proxycheck.c"
struct __anonstruct_pxyprotoport_t_66 {
   pxyproto_t const   *proto ;
   ipport_t port ;
};
#line 25 "/home/wheatley/newnew/temp/proxycheck-0.49a/proxycheck.c"
typedef struct __anonstruct_pxyprotoport_t_66 pxyprotoport_t;
#line 30 "/home/wheatley/newnew/temp/proxycheck-0.49a/proxycheck.c"
struct pxyhost {
   struct in_addr addr ;
   pxyprotoport_t *pps ;
   pxyprotoport_t *cpp ;
   int nopen ;
   int nactive ;
   struct pxyhost *next ;
};
#line 30 "/home/wheatley/newnew/temp/proxycheck-0.49a/proxycheck.c"
typedef struct pxyhost pxyhost_t;
#line 60 "/home/wheatley/newnew/temp/proxycheck-0.49a/proxycheck.c"
struct __anonstruct_pxycheck_t_67 {
   char *name ;
   void (*connh)(pxyconn_t *c , int e ) ;
   int (*getdata)(pxyconn_t *c ) ;
   void (*exph)(pxyconn_t *c , int e ) ;
   int (*init)(char *arg ) ;
   char *arg ;
   char *descr ;
};
#line 60 "/home/wheatley/newnew/temp/proxycheck-0.49a/proxycheck.c"
typedef struct __anonstruct_pxycheck_t_67 pxycheck_t;
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 50 "/usr/include/x86_64-linux-gnu/sys/resource.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getrlimit)(__rlimit_resource_t __resource ,
                                                                                struct rlimit *__rlimits ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 24 "/home/wheatley/newnew/temp/proxycheck-0.49a/event.h"
int ev_init(int maxfdhint , int type ) ;
#line 25
void ev_free(void) ;
#line 27
struct ev_ct *ev_ct_new(int maxfdhint , int type ) ;
#line 28
void ev_ct_free(struct ev_ct *ct ) ;
#line 30
char const   *ev_method_name(struct ev_ct  const  *ct ) ;
#line 31
int ev_method(struct ev_ct  const  *ct ) ;
#line 33
int ev_wait(struct ev_ct *ct , int timeout ) ;
#line 35
ev_time_t ev_gettime(void) ;
#line 36 "/home/wheatley/newnew/temp/proxycheck-0.49a/event.h"
ev_time_t ev_now  ;
#line 37 "/home/wheatley/newnew/temp/proxycheck-0.49a/event.h"
time_t ev_time  ;
#line 39
int ev_fdlimit(void) ;
#line 49
int ev_io_add(struct ev_ct *ct , int fd , int events , ev_io_cbck_f *cb , void *data ) ;
#line 51
int ev_io_mod(struct ev_ct *ct , int fd , int events , ev_io_cbck_f *cb , void *data ) ;
#line 53
int ev_io_del(struct ev_ct *ct , int fd ) ;
#line 54
int ev_io_count(struct ev_ct  const  *ct ) ;
#line 66
struct ev_tm *ev_tm_add(struct ev_ct *ct , struct ev_tm *tmr , int mstimeout , ev_tm_cbck_f *cbck ,
                        void *data ) ;
#line 69
struct ev_tm *ev_ts_add(struct ev_ct *ct , struct ev_tm *tmr , int stimeout , ev_tm_cbck_f *cbck ,
                        void *data ) ;
#line 72
int ev_tm_del(struct ev_ct *ct , struct ev_tm *tmr ) ;
#line 73
int ev_tm_count(struct ev_ct  const  *ct ) ;
#line 74
ev_time_t ev_tm_first(struct ev_ct  const  *ct ) ;
#line 75
int ev_tm_timeout(struct ev_ct  const  *ct ) ;
#line 100 "/usr/include/x86_64-linux-gnu/sys/epoll.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) epoll_create)(int __size ) ;
#line 113
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) epoll_ctl)(int __epfd ,
                                                                                int __op ,
                                                                                int __fd ,
                                                                                struct epoll_event *__event ) ;
#line 127
extern int epoll_wait(int __epfd , struct epoll_event *__events , int __maxevents ,
                      int __timeout ) ;
#line 57 "/usr/include/x86_64-linux-gnu/sys/poll.h"
extern int poll(struct pollfd *__fds , nfds_t __nfds , int __timeout ) ;
#line 121 "/home/wheatley/newnew/temp/proxycheck-0.49a/event.c"
static int evio_epoll_init(struct ev_ct *ct , int maxfd ) 
{ 
  int epfd ;
  int tmp ;

  {
  {
#line 122
  tmp = epoll_create(maxfd);
#line 122
  epfd = tmp;
  }
#line 124
  if (epfd < 0) {
#line 125
    return (-1);
  }
#line 126
  ct->qfd = epfd;
#line 127
  return (0);
}
}
#line 130 "/home/wheatley/newnew/temp/proxycheck-0.49a/event.c"
static int evio_epoll_ctl(struct ev_ct *ct , int func , int fd , int events ) 
{ 
  struct epoll_event ev ;
  int tmp ;

  {
  {
#line 132
  ev.events = (uint32_t )events;
#line 133
  ev.data.fd = fd;
#line 134
  tmp = epoll_ctl(ct->qfd, func, fd, & ev);
  }
#line 134
  return (tmp);
}
}
#line 137 "/home/wheatley/newnew/temp/proxycheck-0.49a/event.c"
static int evio_epoll_add(struct ev_ct *ct , int fd , int events ) 
{ 
  int tmp ;

  {
  {
#line 138
  tmp = evio_epoll_ctl(ct, 1, fd, events);
  }
#line 138
  return (tmp);
}
}
#line 141 "/home/wheatley/newnew/temp/proxycheck-0.49a/event.c"
static int evio_epoll_mod(struct ev_ct *ct , int fd , int events ) 
{ 
  int tmp ;

  {
  {
#line 142
  tmp = evio_epoll_ctl(ct, 3, fd, events);
  }
#line 142
  return (tmp);
}
}
#line 145 "/home/wheatley/newnew/temp/proxycheck-0.49a/event.c"
static int evio_epoll_del(struct ev_ct *ct , int fd ) 
{ 
  int tmp ;

  {
  {
#line 146
  tmp = evio_epoll_ctl(ct, 2, fd, 0);
  }
#line 146
  return (tmp);
}
}
#line 149 "/home/wheatley/newnew/temp/proxycheck-0.49a/event.c"
static int evio_epoll_wait(struct ev_ct *ct , int timeout , struct ev_fd **efdp ) 
{ 
  struct epoll_event epev[200] ;
  int ready ;
  int tmp ;
  struct epoll_event *ep ;
  struct epoll_event *epe ;
  struct ev_fd *efd ;

  {
#line 156
  if (timeout < 0) {
#line 156
    tmp = -1;
  } else {
#line 156
    tmp = timeout;
  }
  {
#line 156
  ready = epoll_wait(ct->qfd, epev, 200, tmp);
  }
#line 157
  if (ready > 0) {
#line 159
    ep = epev;
#line 159
    epe = epev + ready;
    {
#line 160
    while (1) {
      while_continue: /* CIL Label */ ;
#line 161
      efd = ct->efd + ep->data.fd;
#line 162
      if (ep->data.fd >= 0) {
#line 162
        if (! (ep->data.fd <= ct->maxfd)) {
          {
#line 162
          __assert_fail("ep->data.fd >= 0 && ep->data.fd <= ct->maxfd", "/home/wheatley/newnew/temp/proxycheck-0.49a/event.c",
                        162U, "evio_epoll_wait");
          }
        }
      } else {
        {
#line 162
        __assert_fail("ep->data.fd >= 0 && ep->data.fd <= ct->maxfd", "/home/wheatley/newnew/temp/proxycheck-0.49a/event.c",
                      162U, "evio_epoll_wait");
        }
      }
#line 163
      if (! ((unsigned long )efd->cbck != (unsigned long )((void *)0))) {
        {
#line 163
        __assert_fail("efd->cbck != ((void *)0)", "/home/wheatley/newnew/temp/proxycheck-0.49a/event.c",
                      163U, "evio_epoll_wait");
        }
      }
#line 164
      if (! ((unsigned long )efd->next == (unsigned long )((void *)0))) {
        {
#line 164
        __assert_fail("efd->next == ((void *)0)", "/home/wheatley/newnew/temp/proxycheck-0.49a/event.c",
                      164U, "evio_epoll_wait");
        }
      }
#line 165
      if (! ((int )efd->revents == 0)) {
        {
#line 165
        __assert_fail("efd->revents == 0", "/home/wheatley/newnew/temp/proxycheck-0.49a/event.c",
                      165U, "evio_epoll_wait");
        }
      }
#line 166
      efd->revents = (short )ep->events;
#line 167
      *efdp = efd;
#line 168
      efdp = & efd->next;
#line 160
      ep ++;
#line 160
      if (! ((unsigned long )ep < (unsigned long )epe)) {
#line 160
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 171
  *efdp = (struct ev_fd *)((void *)0);
#line 172
  return (ready);
}
}
#line 332 "/home/wheatley/newnew/temp/proxycheck-0.49a/event.c"
static int evio_poll_init(struct ev_ct *ct , int maxfd ) 
{ 
  struct pollfd *pfd ;
  void *tmp ;
  int *tmp___0 ;

  {
#line 335
  if (maxfd < 64) {
#line 335
    maxfd = (maxfd & -4) + 4;
  } else {
#line 335
    maxfd = (maxfd & -32) + 32;
  }
  {
#line 336
  tmp = calloc((size_t )maxfd, sizeof(struct pollfd ));
#line 336
  pfd = (struct pollfd *)tmp;
  }
#line 337
  if (! pfd) {
    {
#line 338
    tmp___0 = __errno_location();
#line 338
    *tmp___0 = 12;
    }
#line 338
    return (-1);
  }
#line 339
  ct->pfd = pfd;
#line 340
  ct->apfd = maxfd;
#line 341
  return (0);
}
}
#line 344 "/home/wheatley/newnew/temp/proxycheck-0.49a/event.c"
static int evio_poll_add(struct ev_ct *ct , int fd , int events ) 
{ 
  struct pollfd *pfd ;
  int pfdi ;
  int apfd ;
  int tmp ;
  struct pollfd *pfdp ;
  struct pollfd *pfde ;
  void *tmp___0 ;
  int *tmp___1 ;

  {
#line 346
  pfdi = ct->nfd;
#line 347
  if (pfdi >= ct->apfd) {
#line 348
    if (pfdi + 1 < 64) {
#line 348
      tmp = ((pfdi + 1) & -4) + 4;
    } else {
#line 348
      tmp = ((pfdi + 1) & -32) + 32;
    }
    {
#line 348
    apfd = tmp;
#line 350
    tmp___0 = realloc((void *)ct->pfd, sizeof(struct pollfd ) * (unsigned long )apfd);
#line 350
    pfd = (struct pollfd *)tmp___0;
    }
#line 351
    if (! pfd) {
      {
#line 352
      tmp___1 = __errno_location();
#line 352
      *tmp___1 = 12;
      }
#line 352
      return (-1);
    }
#line 353
    pfdp = pfd + pfdi;
#line 353
    pfde = pfd + apfd;
    {
#line 353
    while (1) {
      while_continue: /* CIL Label */ ;
#line 353
      if (! ((unsigned long )pfdp < (unsigned long )pfde)) {
#line 353
        goto while_break;
      }
#line 354
      pfdp->fd = -1;
#line 353
      pfdp ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 355
    ct->pfd = pfd;
#line 356
    ct->apfd = apfd;
  }
#line 358
  pfd = ct->pfd + pfdi;
#line 359
  if (! ((int )pfd->events == 0)) {
    {
#line 359
    __assert_fail("pfd->events == 0", "/home/wheatley/newnew/temp/proxycheck-0.49a/event.c",
                  359U, "evio_poll_add");
    }
  }
#line 360
  pfd->fd = fd;
#line 361
  pfd->events = (short )events;
#line 362
  pfd->revents = (short)0;
#line 363
  if (! ((ct->efd + fd)->pfdi < 0)) {
    {
#line 363
    __assert_fail("ct->efd[fd].pfdi < 0", "/home/wheatley/newnew/temp/proxycheck-0.49a/event.c",
                  363U, "evio_poll_add");
    }
  }
#line 364
  (ct->efd + fd)->pfdi = pfdi;
#line 365
  return (0);
}
}
#line 368 "/home/wheatley/newnew/temp/proxycheck-0.49a/event.c"
static int evio_poll_mod(struct ev_ct *ct , int fd , int events ) 
{ 
  struct ev_fd *efd ;
  int pfdi ;

  {
#line 369
  efd = ct->efd + fd;
#line 370
  pfdi = efd->pfdi;
#line 371
  if (pfdi >= 0) {
#line 371
    if (! (pfdi <= ct->nfd)) {
      {
#line 371
      __assert_fail("pfdi >= 0 && pfdi <= ct->nfd", "/home/wheatley/newnew/temp/proxycheck-0.49a/event.c",
                    371U, "evio_poll_mod");
      }
    }
  } else {
    {
#line 371
    __assert_fail("pfdi >= 0 && pfdi <= ct->nfd", "/home/wheatley/newnew/temp/proxycheck-0.49a/event.c",
                  371U, "evio_poll_mod");
    }
  }
#line 372
  if (! ((ct->pfd + pfdi)->fd == fd)) {
    {
#line 372
    __assert_fail("ct->pfd[pfdi].fd == fd", "/home/wheatley/newnew/temp/proxycheck-0.49a/event.c",
                  372U, "evio_poll_mod");
    }
  }
#line 373
  (ct->pfd + pfdi)->events = (short )events;
#line 374
  return (0);
}
}
#line 377 "/home/wheatley/newnew/temp/proxycheck-0.49a/event.c"
static int evio_poll_del(struct ev_ct *ct , int fd ) 
{ 
  struct ev_fd *efd ;
  int pfdi ;
  int lastfd ;

  {
#line 378
  efd = ct->efd + fd;
#line 379
  pfdi = efd->pfdi;
#line 381
  if (pfdi >= 0) {
#line 381
    if (! (pfdi <= ct->nfd)) {
      {
#line 381
      __assert_fail("pfdi >= 0 && pfdi <= ct->nfd", "/home/wheatley/newnew/temp/proxycheck-0.49a/event.c",
                    381U, "evio_poll_del");
      }
    }
  } else {
    {
#line 381
    __assert_fail("pfdi >= 0 && pfdi <= ct->nfd", "/home/wheatley/newnew/temp/proxycheck-0.49a/event.c",
                  381U, "evio_poll_del");
    }
  }
#line 382
  if (! ((ct->pfd + pfdi)->fd == fd)) {
    {
#line 382
    __assert_fail("ct->pfd[pfdi].fd == fd", "/home/wheatley/newnew/temp/proxycheck-0.49a/event.c",
                  382U, "evio_poll_del");
    }
  }
#line 383
  (ct->pfd + pfdi)->fd = -1;
#line 384
  efd->pfdi = -1;
#line 385
  lastfd = ct->nfd - 1;
#line 386
  if (lastfd != pfdi) {
#line 388
    *(ct->pfd + pfdi) = *(ct->pfd + lastfd);
#line 389
    (ct->efd + (ct->pfd + pfdi)->fd)->pfdi = pfdi;
  }
#line 391
  (ct->pfd + lastfd)->fd = -1;
#line 392
  efd->pfdi = -1;
#line 393
  return (0);
}
}
#line 396 "/home/wheatley/newnew/temp/proxycheck-0.49a/event.c"
static int evio_poll_wait(struct ev_ct *ct , int timeout , struct ev_fd **efdp ) 
{ 
  struct pollfd *pfd ;
  struct pollfd *pfde ;
  struct ev_fd *efd ;
  int ready ;
  int cnt ;

  {
  {
#line 403
  pfd = ct->pfd;
#line 404
  ready = poll(pfd, (nfds_t )ct->nfd, timeout);
  }
#line 405
  if (ready > 0) {
#line 408
    pfde = pfd + ct->nfd;
#line 408
    cnt = ready;
    {
#line 408
    while (1) {
      while_continue: /* CIL Label */ ;
#line 408
      if (! ((unsigned long )pfd < (unsigned long )pfde)) {
#line 408
        goto while_break;
      }
#line 409
      if (pfd->fd >= 0) {
#line 409
        if (! (pfd->fd <= ct->maxfd)) {
          {
#line 409
          __assert_fail("pfd->fd >= 0 && pfd->fd <= ct->maxfd", "/home/wheatley/newnew/temp/proxycheck-0.49a/event.c",
                        409U, "evio_poll_wait");
          }
        }
      } else {
        {
#line 409
        __assert_fail("pfd->fd >= 0 && pfd->fd <= ct->maxfd", "/home/wheatley/newnew/temp/proxycheck-0.49a/event.c",
                      409U, "evio_poll_wait");
        }
      }
#line 410
      efd = ct->efd + pfd->fd;
#line 411
      if (! ((long )efd->pfdi == pfd - ct->pfd)) {
        {
#line 411
        __assert_fail("efd->pfdi == pfd - ct->pfd", "/home/wheatley/newnew/temp/proxycheck-0.49a/event.c",
                      411U, "evio_poll_wait");
        }
      }
#line 412
      if (! ((unsigned long )efd->cbck != (unsigned long )((void *)0))) {
        {
#line 412
        __assert_fail("efd->cbck != ((void *)0)", "/home/wheatley/newnew/temp/proxycheck-0.49a/event.c",
                      412U, "evio_poll_wait");
        }
      }
#line 413
      if (pfd->revents) {
#line 414
        if ((int )pfd->revents & 8) {
#line 414
          efd->revents = (short)7;
        } else {
#line 414
          efd->revents = pfd->revents;
        }
#line 416
        *efdp = efd;
#line 417
        efdp = & efd->next;
#line 418
        cnt --;
#line 418
        if (cnt) {
#line 419
          goto while_break;
        }
      }
#line 408
      pfd ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 424
  *efdp = (struct ev_fd *)((void *)0);
#line 425
  return (ready);
}
}
#line 433 "/home/wheatley/newnew/temp/proxycheck-0.49a/event.c"
static int evio_select_init(struct ev_ct *ct , int maxfd ) 
{ 
  int __d0 ;
  int __d1 ;
  int __d0___0 ;
  int __d1___0 ;
  int __d0___1 ;
  int __d1___1 ;

  {
  {
#line 434
  while (1) {
    while_continue: /* CIL Label */ ;
#line 434
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& ct->rfdset.fds_bits[0]): "memory");
#line 434
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 435
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 435
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0___0), "=D" (__d1___0): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& ct->wfdset.fds_bits[0]): "memory");
#line 435
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 436
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 436
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0___1), "=D" (__d1___1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& ct->xfdset.fds_bits[0]): "memory");
#line 436
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 437
  maxfd = maxfd;
#line 438
  return (0);
}
}
#line 441 "/home/wheatley/newnew/temp/proxycheck-0.49a/event.c"
static int evio_select_add(struct ev_ct *ct , int fd , int events ) 
{ 


  {
#line 442
  if (! (fd < 1024)) {
    {
#line 442
    __assert_fail("fd < 1024", "/home/wheatley/newnew/temp/proxycheck-0.49a/event.c",
                  442U, "evio_select_add");
    }
  }
#line 443
  if (events & 1) {
#line 443
    ct->rfdset.fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << fd % (8 * (int )sizeof(__fd_mask ));
  }
#line 444
  if (events & 4) {
#line 444
    ct->wfdset.fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << fd % (8 * (int )sizeof(__fd_mask ));
  }
#line 445
  if (events & 2) {
#line 445
    ct->xfdset.fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << fd % (8 * (int )sizeof(__fd_mask ));
  }
#line 446
  return (0);
}
}
#line 449 "/home/wheatley/newnew/temp/proxycheck-0.49a/event.c"
static int evio_select_mod(struct ev_ct *ct , int fd , int events ) 
{ 


  {
#line 450
  if (events & 1) {
#line 450
    ct->rfdset.fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << fd % (8 * (int )sizeof(__fd_mask ));
  } else {
#line 451
    ct->rfdset.fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] &= ~ (1L << fd % (8 * (int )sizeof(__fd_mask )));
  }
#line 452
  if (events & 4) {
#line 452
    ct->wfdset.fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << fd % (8 * (int )sizeof(__fd_mask ));
  } else {
#line 453
    ct->wfdset.fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] &= ~ (1L << fd % (8 * (int )sizeof(__fd_mask )));
  }
#line 454
  if (events & 2) {
#line 454
    ct->xfdset.fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << fd % (8 * (int )sizeof(__fd_mask ));
  } else {
#line 455
    ct->xfdset.fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] &= ~ (1L << fd % (8 * (int )sizeof(__fd_mask )));
  }
#line 456
  return (0);
}
}
#line 459 "/home/wheatley/newnew/temp/proxycheck-0.49a/event.c"
static int evio_select_del(struct ev_ct *ct , int fd ) 
{ 


  {
#line 460
  ct->rfdset.fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] &= ~ (1L << fd % (8 * (int )sizeof(__fd_mask )));
#line 461
  ct->wfdset.fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] &= ~ (1L << fd % (8 * (int )sizeof(__fd_mask )));
#line 462
  ct->xfdset.fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] &= ~ (1L << fd % (8 * (int )sizeof(__fd_mask )));
#line 463
  return (0);
}
}
#line 466 "/home/wheatley/newnew/temp/proxycheck-0.49a/event.c"
static int evio_select_wait(struct ev_ct *ct , int timeout , struct ev_fd **efdp ) 
{ 
  int ready ;
  int cur ;
  int fd ;
  fd_set fdr ;
  fd_set fdw ;
  fd_set fdx ;
  struct timeval tv ;
  struct timeval *tvp ;
  int revents ;
  struct ev_fd *efd ;

  {
#line 469
  fdr = ct->rfdset;
#line 470
  fdw = ct->wfdset;
#line 471
  fdx = ct->xfdset;
#line 474
  if (timeout < 0) {
#line 475
    tvp = (struct timeval *)((void *)0);
  } else {
#line 477
    tv.tv_sec = (__time_t )(timeout / 1000);
#line 478
    tv.tv_usec = (__suseconds_t )((timeout % 1000) * 1000);
#line 479
    tvp = & tv;
  }
  {
#line 483
  ready = select(ct->maxfd + 1, (fd_set */* __restrict  */)(& fdr), (fd_set */* __restrict  */)(& fdw),
                 (fd_set */* __restrict  */)(& fdx), (struct timeval */* __restrict  */)tvp);
  }
#line 484
  if (ready > 0) {
#line 486
    fd = 0;
#line 486
    cur = ready;
    {
#line 486
    while (1) {
      while_continue: /* CIL Label */ ;
#line 486
      if (! (fd <= ct->maxfd)) {
#line 486
        goto while_break;
      }
#line 487
      revents = 0;
#line 488
      efd = ct->efd + fd;
#line 489
      if (! efd->cbck) {
#line 489
        goto __Cont;
      }
#line 490
      if ((fdr.fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] & (1L << fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 490
        revents |= 1;
      }
#line 491
      if ((fdw.fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] & (1L << fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 491
        revents |= 4;
      }
#line 492
      if ((fdx.fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] & (1L << fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 492
        revents |= 2;
      }
#line 493
      if (! revents) {
#line 493
        goto __Cont;
      }
#line 494
      if (! (! efd->next)) {
        {
#line 494
        __assert_fail("!efd->next", "/home/wheatley/newnew/temp/proxycheck-0.49a/event.c",
                      494U, "evio_select_wait");
        }
      }
#line 495
      if (! (! efd->revents)) {
        {
#line 495
        __assert_fail("!efd->revents", "/home/wheatley/newnew/temp/proxycheck-0.49a/event.c",
                      495U, "evio_select_wait");
        }
      }
#line 496
      efd->revents = (short )revents;
#line 497
      *efdp = efd;
#line 498
      efdp = & efd->next;
#line 499
      cur --;
#line 499
      if (! cur) {
#line 499
        goto while_break;
      }
      __Cont: /* CIL Label */ 
#line 486
      fd ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 503
  *efdp = (struct ev_fd *)((void *)0);
#line 504
  return (ready);
}
}
#line 508 "/home/wheatley/newnew/temp/proxycheck-0.49a/event.c"
static struct ev_ct *ev_defct  ;
#line 514 "/home/wheatley/newnew/temp/proxycheck-0.49a/event.c"
ev_time_t ev_gettime(void) 
{ 
  struct timeval tv ;

  {
  {
#line 516
  gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )((void *)0));
#line 517
  ev_time = tv.tv_sec;
#line 518
  ev_now = (ev_time_t )tv.tv_sec * 1000LL + (ev_time_t )(tv.tv_usec / 1000L);
  }
#line 519
  return (ev_now);
}
}
#line 522 "/home/wheatley/newnew/temp/proxycheck-0.49a/event.c"
int ev_fdlimit(void) 
{ 
  struct rlimit rlim ;

  {
  {
#line 524
  getrlimit((__rlimit_resource_t )7, & rlim);
  }
#line 525
  return ((int )rlim.rlim_cur);
}
}
#line 540 "/home/wheatley/newnew/temp/proxycheck-0.49a/event.c"
static struct ev_method  const  methods[3]  = {      {"epoll", 4, & evio_epoll_init, & evio_epoll_wait, & evio_epoll_add, & evio_epoll_mod,
      & evio_epoll_del, 0}, 
        {"poll", 2, & evio_poll_init, & evio_poll_wait, & evio_poll_add, & evio_poll_mod,
      & evio_poll_del, 0}, 
        {"select", 1, & evio_select_init, & evio_select_wait, & evio_select_add, & evio_select_mod,
      & evio_select_del, 1023}};
#line 560 "/home/wheatley/newnew/temp/proxycheck-0.49a/event.c"
struct ev_ct *ev_ct_new(int maxfdhint , int type ) 
{ 
  unsigned int i ;
  struct ev_ct *ct ;
  struct ev_method  const  *em ;
  int maxfd ;
  char const   *method ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  int *tmp___6 ;
  struct ev_fd *efd ;
  struct ev_fd *efde ;

  {
  {
#line 567
  ev_gettime();
#line 568
  tmp = calloc((size_t )1, sizeof(struct ev_ct ));
#line 568
  ct = (struct ev_ct *)tmp;
  }
#line 569
  if (! ct) {
    {
#line 570
    tmp___0 = __errno_location();
#line 570
    *tmp___0 = 12;
    }
#line 570
    return ((struct ev_ct *)0);
  }
#line 571
  ct->qfd = -1;
#line 572
  i = 0U;
#line 573
  if (maxfdhint <= 0) {
    {
#line 574
    maxfdhint = ev_fdlimit();
    }
  }
#line 575
  if (maxfdhint < 64) {
#line 575
    maxfdhint = (maxfdhint & -4) + 4;
  } else {
#line 575
    maxfdhint = (maxfdhint & -32) + 32;
  }
  {
#line 576
  tmp___1 = getenv("EV_METHOD");
#line 576
  method = (char const   *)tmp___1;
  }
#line 577
  if (method) {
#line 578
    type = 65535;
  } else
#line 577
  if (! type) {
#line 578
    type = 65535;
  }
  {
#line 580
  tmp___2 = __errno_location();
#line 580
  *tmp___2 = 95;
  }
  {
#line 584
  while (1) {
    while_continue: /* CIL Label */ ;
#line 585
    em = & methods[i];
#line 586
    if (em->type & (int const   )type) {
#line 586
      if (! method) {
#line 586
        goto _L;
      } else {
        {
#line 586
        tmp___4 = strcmp(method, (char const   *)em->name);
        }
#line 586
        if (tmp___4 == 0) {
          _L: /* CIL Label */ 
#line 587
          if (em->maxfd) {
#line 587
            if (em->maxfd < (int const   )maxfdhint) {
#line 587
              maxfd = (int )em->maxfd;
            } else {
#line 587
              maxfd = maxfdhint;
            }
          } else {
#line 587
            maxfd = maxfdhint;
          }
          {
#line 589
          tmp___3 = (*(em->init))(ct, maxfd);
          }
#line 589
          if (tmp___3 == 0) {
#line 590
            goto while_break;
          }
        }
      }
    }
#line 592
    i ++;
#line 592
    if ((unsigned long )i < sizeof(methods) / sizeof(methods[0])) {
#line 593
      goto __Cont;
    }
    {
#line 594
    free((void *)ct);
    }
#line 595
    return ((struct ev_ct *)((void *)0));
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 598
  tmp___5 = calloc((size_t )maxfd, sizeof(struct ev_fd ));
#line 598
  ct->efd = (struct ev_fd *)tmp___5;
  }
#line 599
  if (! ct->efd) {
#line 600
    if (ct->qfd >= 0) {
      {
#line 600
      close(ct->qfd);
      }
    }
#line 602
    if (ct->pfd) {
      {
#line 602
      free((void *)ct->pfd);
      }
    }
    {
#line 604
    free((void *)ct);
#line 605
    tmp___6 = __errno_location();
#line 605
    *tmp___6 = 12;
    }
#line 606
    return ((struct ev_ct *)((void *)0));
  }
#line 610
  efd = ct->efd;
#line 610
  efde = efd + maxfd;
  {
#line 610
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 610
    if (! ((unsigned long )efd < (unsigned long )efde)) {
#line 610
      goto while_break___0;
    }
#line 611
    efd->pfdi = -1;
#line 610
    efd ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 614
  ct->aefd = maxfd;
#line 615
  ct->method = em;
#line 616
  ct->maxfd = -1;
#line 617
  return (ct);
}
}
#line 620 "/home/wheatley/newnew/temp/proxycheck-0.49a/event.c"
void ev_ct_free(struct ev_ct *ct ) 
{ 


  {
#line 621
  if (! ct) {
#line 621
    ct = ev_defct;
  }
#line 622
  if (ct->qfd >= 0) {
    {
#line 622
    close(ct->qfd);
    }
  }
#line 624
  if (ct->pfd) {
    {
#line 624
    free((void *)ct->pfd);
    }
  }
  {
#line 626
  free((void *)ct->efd);
#line 627
  free((void *)ct);
  }
#line 628
  if ((unsigned long )ct == (unsigned long )ev_defct) {
#line 629
    ev_defct = (struct ev_ct *)((void *)0);
  }
#line 630
  return;
}
}
#line 632 "/home/wheatley/newnew/temp/proxycheck-0.49a/event.c"
char const   *ev_method_name(struct ev_ct  const  *ct ) 
{ 


  {
#line 633
  if (! ct) {
#line 633
    ct = (struct ev_ct  const  *)ev_defct;
  }
#line 634
  return ((char const   *)(ct->method)->name);
}
}
#line 637 "/home/wheatley/newnew/temp/proxycheck-0.49a/event.c"
int ev_method(struct ev_ct  const  *ct ) 
{ 


  {
#line 638
  if (! ct) {
#line 638
    ct = (struct ev_ct  const  *)ev_defct;
  }
#line 639
  return ((int )(ct->method)->type);
}
}
#line 642 "/home/wheatley/newnew/temp/proxycheck-0.49a/event.c"
int ev_init(int maxfdhint , int type ) 
{ 


  {
#line 643
  if (! ev_defct) {
    {
#line 643
    ev_defct = ev_ct_new(maxfdhint, type);
    }
#line 643
    if (! ev_defct) {
#line 644
      return (-1);
    }
  }
#line 645
  return (0);
}
}
#line 648 "/home/wheatley/newnew/temp/proxycheck-0.49a/event.c"
void ev_free(void) 
{ 


  {
#line 649
  if (ev_defct) {
    {
#line 650
    ev_ct_free(ev_defct);
    }
  }
#line 651
  return;
}
}
#line 661 "/home/wheatley/newnew/temp/proxycheck-0.49a/event.c"
int ev_io_add(struct ev_ct *ct , int fd , int events , ev_io_cbck_f *cb , void *data ) 
{ 
  int r ;
  struct ev_fd *efd ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  struct ev_fd *efdp ;
  struct ev_fd *efde ;
  int *tmp___4 ;

  {
#line 665
  if (! ct) {
#line 665
    ct = ev_defct;
  }
#line 666
  if (fd < 0) {
    {
#line 666
    tmp = __errno_location();
#line 666
    *tmp = 22;
    }
#line 666
    return (-1);
  }
#line 667
  if (! cb) {
    {
#line 668
    tmp___0 = __errno_location();
#line 668
    *tmp___0 = 14;
    }
#line 668
    return (-1);
  }
#line 669
  if ((ct->method)->maxfd) {
#line 669
    if (fd > (int )(ct->method)->maxfd) {
      {
#line 670
      tmp___1 = __errno_location();
#line 670
      *tmp___1 = 24;
      }
#line 670
      return (-1);
    }
  }
#line 671
  if (fd >= ct->aefd) {
#line 672
    if (fd < 64) {
#line 672
      r = (fd & -4) + 4;
    } else {
#line 672
      r = (fd & -32) + 32;
    }
    {
#line 673
    tmp___2 = realloc((void *)ct->efd, sizeof(struct ev_fd ) * (unsigned long )r);
#line 673
    efd = (struct ev_fd *)tmp___2;
    }
#line 674
    if (! efd) {
      {
#line 675
      tmp___3 = __errno_location();
#line 675
      *tmp___3 = 12;
      }
#line 675
      return (-1);
    }
    {
#line 676
    memset((void *)efd, 0, sizeof(struct ev_fd ) * (unsigned long )(r - ct->aefd));
#line 679
    efdp = efd + ct->aefd;
#line 679
    efde = efd + r;
    }
    {
#line 679
    while (1) {
      while_continue: /* CIL Label */ ;
#line 679
      if (! ((unsigned long )efdp < (unsigned long )efde)) {
#line 679
        goto while_break;
      }
#line 680
      efdp->pfdi = -1;
#line 679
      efdp ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 683
    ct->efd = efd;
#line 684
    ct->aefd = r;
  }
#line 686
  efd = ct->efd + fd;
#line 687
  if (efd->cbck) {
    {
#line 688
    tmp___4 = __errno_location();
#line 688
    *tmp___4 = 17;
    }
#line 688
    return (-1);
  }
  {
#line 689
  r = (*((ct->method)->add))(ct, fd, events);
  }
#line 690
  if (r != 0) {
#line 691
    return (r);
  }
#line 692
  efd->cbck = cb;
#line 693
  efd->data = data;
#line 694
  if (ct->maxfd < fd) {
#line 695
    ct->maxfd = fd;
  }
#line 696
  (ct->nfd) ++;
#line 697
  return (0);
}
}
#line 701 "/home/wheatley/newnew/temp/proxycheck-0.49a/event.c"
int ev_io_mod(struct ev_ct *ct , int fd , int events , ev_io_cbck_f *cb , void *data ) 
{ 
  int r ;
  struct ev_fd *efd ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;

  {
#line 705
  if (! ct) {
#line 705
    ct = ev_defct;
  }
#line 706
  if (fd < 0) {
    {
#line 706
    tmp = __errno_location();
#line 706
    *tmp = 22;
    }
#line 706
    return (-1);
  }
#line 706
  if (fd > ct->maxfd) {
    {
#line 706
    tmp___0 = __errno_location();
#line 706
    *tmp___0 = 2;
    }
#line 706
    return (-1);
  }
#line 706
  efd = ct->efd + fd;
#line 706
  if (! efd->cbck) {
    {
#line 706
    tmp___1 = __errno_location();
#line 706
    *tmp___1 = 2;
    }
#line 706
    return (-1);
  }
#line 707
  if (! cb) {
    {
#line 708
    tmp___2 = __errno_location();
#line 708
    *tmp___2 = 14;
    }
#line 708
    return (-1);
  }
  {
#line 709
  r = (*((ct->method)->mod))(ct, fd, events);
  }
#line 710
  if (r != 0) {
#line 711
    return (r);
  }
#line 712
  efd->cbck = cb;
#line 713
  efd->data = data;
#line 714
  efd->events = (short )events;
#line 715
  efd->revents = (short)0;
#line 716
  return (0);
}
}
#line 720 "/home/wheatley/newnew/temp/proxycheck-0.49a/event.c"
int ev_io_del(struct ev_ct *ct , int fd ) 
{ 
  struct ev_fd *efd ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  short tmp___2 ;

  {
#line 722
  if (! ct) {
#line 722
    ct = ev_defct;
  }
#line 723
  if (fd < 0) {
    {
#line 723
    tmp = __errno_location();
#line 723
    *tmp = 22;
    }
#line 723
    return (-1);
  }
#line 723
  if (fd > ct->maxfd) {
    {
#line 723
    tmp___0 = __errno_location();
#line 723
    *tmp___0 = 2;
    }
#line 723
    return (-1);
  }
#line 723
  efd = ct->efd + fd;
#line 723
  if (! efd->cbck) {
    {
#line 723
    tmp___1 = __errno_location();
#line 723
    *tmp___1 = 2;
    }
#line 723
    return (-1);
  }
  {
#line 724
  (*((ct->method)->del))(ct, fd);
#line 725
  efd->cbck = (ev_io_cbck_f *)((void *)0);
#line 726
  efd->data = (void *)0;
#line 727
  tmp___2 = (short)0;
#line 727
  efd->revents = tmp___2;
#line 727
  efd->events = tmp___2;
  }
#line 728
  if (ct->maxfd == fd) {
    {
#line 729
    while (1) {
      while_continue: /* CIL Label */ ;
#line 729
      fd --;
#line 729
      if (fd >= 0) {
#line 729
        if (! ((unsigned long )(ct->efd + fd)->cbck == (unsigned long )((void *)0))) {
#line 729
          goto while_break;
        }
      } else {
#line 729
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 731
    ct->maxfd = fd;
  }
#line 733
  (ct->nfd) --;
#line 734
  return (0);
}
}
#line 737 "/home/wheatley/newnew/temp/proxycheck-0.49a/event.c"
int ev_io_count(struct ev_ct  const  *ct ) 
{ 


  {
#line 738
  if (! ct) {
#line 738
    ct = (struct ev_ct  const  *)ev_defct;
  }
#line 739
  return ((int )ct->nfd);
}
}
#line 745 "/home/wheatley/newnew/temp/proxycheck-0.49a/event.c"
static struct ev_tm *ev_tm_new(struct ev_ct *ct , struct ev_tm *tmr , ev_time_t when ,
                               ev_tm_cbck_f *cbck , void *data ) 
{ 
  int *tmp ;
  int *tmp___0 ;
  void *tmp___1 ;
  struct ev_tm *tmp___2 ;
  struct ev_tm *tmp___3 ;
  struct ev_tm *prev ;
  struct ev_tm *next ;

  {
#line 748
  if (! ct) {
#line 748
    ct = ev_defct;
  }
#line 749
  if (! cbck) {
    {
#line 750
    tmp = __errno_location();
#line 750
    *tmp = 14;
    }
#line 750
    return ((struct ev_tm *)0);
  }
#line 751
  if (tmr) {
#line 752
    if (! tmr->evtm_prev) {
#line 752
      if (! tmr->evtm_next) {
#line 752
        if (! (! tmr->evtm_when)) {
          {
#line 752
          __assert_fail("!tmr->evtm_prev && !tmr->evtm_next && !tmr->evtm_when", "/home/wheatley/newnew/temp/proxycheck-0.49a/event.c",
                        752U, "ev_tm_new");
          }
        }
      } else {
        {
#line 752
        __assert_fail("!tmr->evtm_prev && !tmr->evtm_next && !tmr->evtm_when", "/home/wheatley/newnew/temp/proxycheck-0.49a/event.c",
                      752U, "ev_tm_new");
        }
      }
    } else {
      {
#line 752
      __assert_fail("!tmr->evtm_prev && !tmr->evtm_next && !tmr->evtm_when", "/home/wheatley/newnew/temp/proxycheck-0.49a/event.c",
                    752U, "ev_tm_new");
      }
    }
  } else {
    {
#line 753
    tmp___1 = malloc(sizeof(struct ev_tm ));
#line 753
    tmr = (struct ev_tm *)tmp___1;
    }
#line 753
    if ((unsigned long )tmr == (unsigned long )((void *)0)) {
      {
#line 754
      tmp___0 = __errno_location();
#line 754
      *tmp___0 = 12;
      }
#line 754
      return ((struct ev_tm *)0);
    }
  }
#line 755
  tmr->evtm_when = when;
#line 756
  tmr->evtm_cbck = cbck;
#line 757
  tmr->evtm_data = data;
#line 759
  if (! ct->tmhead) {
#line 761
    if (! ct->tmtail) {
#line 761
      if (! ct->tmcnt) {
#line 761
        if (! (! ct->tmsum)) {
          {
#line 761
          __assert_fail("!ct->tmtail && !ct->tmcnt && !ct->tmsum", "/home/wheatley/newnew/temp/proxycheck-0.49a/event.c",
                        761U, "ev_tm_new");
          }
        }
      } else {
        {
#line 761
        __assert_fail("!ct->tmtail && !ct->tmcnt && !ct->tmsum", "/home/wheatley/newnew/temp/proxycheck-0.49a/event.c",
                      761U, "ev_tm_new");
        }
      }
    } else {
      {
#line 761
      __assert_fail("!ct->tmtail && !ct->tmcnt && !ct->tmsum", "/home/wheatley/newnew/temp/proxycheck-0.49a/event.c",
                    761U, "ev_tm_new");
      }
    }
#line 762
    tmp___2 = tmr;
#line 762
    ct->tmtail = tmp___2;
#line 762
    ct->tmhead = tmp___2;
#line 763
    tmp___3 = (struct ev_tm *)((void *)0);
#line 763
    tmr->evtm_prev = tmp___3;
#line 763
    tmr->evtm_next = tmp___3;
  } else
#line 765
  if (when >= (ct->tmtail)->evtm_when) {
#line 767
    (ct->tmtail)->evtm_next = tmr;
#line 768
    tmr->evtm_prev = ct->tmtail;
#line 769
    ct->tmtail = tmr;
#line 770
    tmr->evtm_next = (struct ev_tm *)((void *)0);
  } else
#line 772
  if (when < (ct->tmhead)->evtm_when) {
#line 774
    (ct->tmhead)->evtm_prev = tmr;
#line 775
    tmr->evtm_next = ct->tmhead;
#line 776
    ct->tmhead = tmr;
#line 777
    tmr->evtm_prev = (struct ev_tm *)((void *)0);
  } else
#line 779
  if (ct->tmsum <= when * (ev_time_t )ct->tmcnt) {
#line 781
    prev = ct->tmtail;
    {
#line 782
    while (1) {
      while_continue: /* CIL Label */ ;
#line 782
      if (! (prev->evtm_when > when)) {
#line 782
        goto while_break;
      }
#line 783
      if (prev->evtm_prev) {
#line 783
        if (! (prev->evtm_when >= (prev->evtm_prev)->evtm_when)) {
          {
#line 783
          __assert_fail("prev->evtm_prev && prev->evtm_when >= prev->evtm_prev->evtm_when",
                        "/home/wheatley/newnew/temp/proxycheck-0.49a/event.c", 783U,
                        "ev_tm_new");
          }
        }
      } else {
        {
#line 783
        __assert_fail("prev->evtm_prev && prev->evtm_when >= prev->evtm_prev->evtm_when",
                      "/home/wheatley/newnew/temp/proxycheck-0.49a/event.c", 783U,
                      "ev_tm_new");
        }
      }
#line 784
      prev = prev->evtm_prev;
    }
    while_break: /* CIL Label */ ;
    }
#line 786
    tmr->evtm_prev = prev;
#line 787
    tmr->evtm_next = prev->evtm_next;
#line 788
    (prev->evtm_next)->evtm_prev = tmr;
#line 789
    prev->evtm_next = tmr;
  } else {
#line 793
    next = ct->tmhead;
    {
#line 794
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 794
      if (! (next->evtm_when <= when)) {
#line 794
        goto while_break___0;
      }
#line 795
      if (next->evtm_next) {
#line 795
        if (! (next->evtm_when <= (next->evtm_next)->evtm_when)) {
          {
#line 795
          __assert_fail("next->evtm_next && next->evtm_when <= next->evtm_next->evtm_when",
                        "/home/wheatley/newnew/temp/proxycheck-0.49a/event.c", 795U,
                        "ev_tm_new");
          }
        }
      } else {
        {
#line 795
        __assert_fail("next->evtm_next && next->evtm_when <= next->evtm_next->evtm_when",
                      "/home/wheatley/newnew/temp/proxycheck-0.49a/event.c", 795U,
                      "ev_tm_new");
        }
      }
#line 796
      next = next->evtm_next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 798
    tmr->evtm_next = next;
#line 799
    tmr->evtm_prev = next->evtm_prev;
#line 800
    (next->evtm_prev)->evtm_next = tmr;
#line 801
    next->evtm_prev = tmr;
  }
#line 803
  (ct->tmcnt) ++;
#line 804
  ct->tmsum += when;
#line 805
  return (tmr);
}
}
#line 808 "/home/wheatley/newnew/temp/proxycheck-0.49a/event.c"
struct ev_tm *ev_tm_add(struct ev_ct *ct , struct ev_tm *tmr , int mstimeout , ev_tm_cbck_f *cbck ,
                        void *data ) 
{ 
  int *tmp ;
  struct ev_tm *tmp___0 ;

  {
#line 811
  if (mstimeout < 0) {
    {
#line 812
    tmp = __errno_location();
#line 812
    *tmp = 22;
    }
#line 812
    return ((struct ev_tm *)0);
  } else {
    {
#line 814
    tmp___0 = ev_tm_new(ct, tmr, ev_now + (ev_time_t )mstimeout, cbck, data);
    }
#line 814
    return (tmp___0);
  }
}
}
#line 817 "/home/wheatley/newnew/temp/proxycheck-0.49a/event.c"
struct ev_tm *ev_ts_add(struct ev_ct *ct , struct ev_tm *tmr , int stimeout , ev_tm_cbck_f *cbck ,
                        void *data ) 
{ 
  int *tmp ;
  struct ev_tm *tmp___0 ;

  {
#line 820
  if (stimeout < 0) {
    {
#line 821
    tmp = __errno_location();
#line 821
    *tmp = 22;
    }
#line 821
    return ((struct ev_tm *)0);
  } else {
    {
#line 823
    tmp___0 = ev_tm_new(ct, tmr, ((ev_now + 500LL) / 1000LL + (ev_time_t )stimeout) * 1000LL,
                        cbck, data);
    }
#line 823
    return (tmp___0);
  }
}
}
#line 827 "/home/wheatley/newnew/temp/proxycheck-0.49a/event.c"
int ev_tm_del(struct ev_ct *ct , struct ev_tm *tmr ) 
{ 
  int mstimeout ;
  int *tmp ;
  struct ev_tm *tmp___0 ;

  {
#line 829
  if (! ct) {
#line 829
    ct = ev_defct;
  }
#line 830
  if (! tmr->evtm_when) {
#line 831
    if ((unsigned long )tmr->evtm_prev == (unsigned long )((void *)0)) {
#line 831
      if (! ((unsigned long )tmr->evtm_next == (unsigned long )((void *)0))) {
        {
#line 831
        __assert_fail("tmr->evtm_prev == ((void *)0) && tmr->evtm_next == ((void *)0)",
                      "/home/wheatley/newnew/temp/proxycheck-0.49a/event.c", 831U,
                      "ev_tm_del");
        }
      }
    } else {
      {
#line 831
      __assert_fail("tmr->evtm_prev == ((void *)0) && tmr->evtm_next == ((void *)0)",
                    "/home/wheatley/newnew/temp/proxycheck-0.49a/event.c", 831U, "ev_tm_del");
      }
    }
    {
#line 832
    tmp = __errno_location();
#line 832
    *tmp = 2;
    }
#line 832
    return (-1);
  }
#line 834
  if (! ((unsigned long )tmr->evtm_prev != (unsigned long )((void *)0))) {
#line 834
    if (! ((unsigned long )ct->tmhead == (unsigned long )tmr)) {
      {
#line 834
      __assert_fail("tmr->evtm_prev != ((void *)0) || ct->tmhead == tmr", "/home/wheatley/newnew/temp/proxycheck-0.49a/event.c",
                    834U, "ev_tm_del");
      }
    }
  }
#line 835
  if (! ((unsigned long )tmr->evtm_next != (unsigned long )((void *)0))) {
#line 835
    if (! ((unsigned long )ct->tmtail == (unsigned long )tmr)) {
      {
#line 835
      __assert_fail("tmr->evtm_next != ((void *)0) || ct->tmtail == tmr", "/home/wheatley/newnew/temp/proxycheck-0.49a/event.c",
                    835U, "ev_tm_del");
      }
    }
  }
#line 836
  if (tmr->evtm_prev) {
#line 837
    (tmr->evtm_prev)->evtm_next = tmr->evtm_next;
  } else {
#line 839
    ct->tmhead = tmr->evtm_next;
  }
#line 840
  if (tmr->evtm_next) {
#line 841
    (tmr->evtm_next)->evtm_prev = tmr->evtm_prev;
  } else {
#line 843
    ct->tmtail = tmr->evtm_prev;
  }
#line 844
  (ct->tmcnt) --;
#line 845
  ct->tmsum -= tmr->evtm_when;
#line 846
  if (tmr->evtm_when < ev_now) {
#line 846
    mstimeout = 0;
  } else {
#line 846
    mstimeout = (int )(tmr->evtm_when - ev_now);
  }
#line 847
  tmp___0 = (struct ev_tm *)((void *)0);
#line 847
  tmr->evtm_next = tmp___0;
#line 847
  tmr->evtm_prev = tmp___0;
#line 848
  tmr->evtm_when = (ev_time_t )0;
#line 849
  return (mstimeout);
}
}
#line 853 "/home/wheatley/newnew/temp/proxycheck-0.49a/event.c"
ev_time_t ev_tm_first(struct ev_ct  const  *ct ) 
{ 
  ev_time_t tmp ;

  {
#line 854
  if (! ct) {
#line 854
    ct = (struct ev_ct  const  *)ev_defct;
  }
#line 855
  if (ct->tmhead) {
#line 855
    tmp = (ct->tmhead)->evtm_when;
  } else {
#line 855
    tmp = (ev_time_t )0;
  }
#line 855
  return (tmp);
}
}
#line 860 "/home/wheatley/newnew/temp/proxycheck-0.49a/event.c"
int ev_tm_timeout(struct ev_ct  const  *ct ) 
{ 


  {
#line 861
  if (! ct) {
#line 861
    ct = (struct ev_ct  const  *)ev_defct;
  }
#line 862
  if (! ct->tmhead) {
#line 862
    return (-1);
  }
#line 863
  if ((ct->tmhead)->evtm_when > ev_now) {
#line 863
    return (0);
  }
#line 864
  return ((int )((ct->tmhead)->evtm_when - ev_now));
}
}
#line 867 "/home/wheatley/newnew/temp/proxycheck-0.49a/event.c"
int ev_tm_count(struct ev_ct  const  *ct ) 
{ 


  {
#line 868
  if (! ct) {
#line 868
    ct = (struct ev_ct  const  *)ev_defct;
  }
#line 869
  return ((int )ct->tmcnt);
}
}
#line 873 "/home/wheatley/newnew/temp/proxycheck-0.49a/event.c"
int ev_wait(struct ev_ct *ct , int timeout ) 
{ 
  struct ev_tm *tmr ;
  struct ev_fd *efdl ;
  int r ;
  int saved_errno ;
  int *tmp ;
  int *tmp___0 ;
  struct ev_tm *tmp___1 ;
  struct ev_tm *tmp___2 ;
  struct ev_fd *efd ;
  int revents ;
  int *tmp___3 ;

  {
#line 877
  saved_errno = 0;
#line 878
  if (! ct) {
#line 878
    ct = ev_defct;
  }
#line 879
  if (ct->loop) {
    {
#line 880
    tmp = __errno_location();
#line 880
    *tmp = 11;
    }
#line 880
    return (-1);
  }
#line 881
  ct->loop = 1;
#line 882
  if (timeout) {
#line 882
    if (ct->tmhead) {
#line 883
      r = (int )((ct->tmhead)->evtm_when - ev_now);
#line 884
      if (r < 0) {
#line 885
        timeout = 0;
      } else
#line 886
      if (timeout < 0) {
#line 887
        timeout = r;
      } else
#line 886
      if (r < timeout) {
#line 887
        timeout = r;
      }
    }
  }
  {
#line 889
  r = (*((ct->method)->wait))(ct, timeout, & efdl);
  }
#line 890
  if (r < 0) {
    {
#line 891
    tmp___0 = __errno_location();
#line 891
    saved_errno = *tmp___0;
    }
  }
  {
#line 892
  ev_gettime();
  }
  {
#line 893
  while (1) {
    while_continue: /* CIL Label */ ;
#line 893
    tmr = ct->tmhead;
#line 893
    if ((unsigned long )tmr != (unsigned long )((void *)0)) {
#line 893
      if (! (tmr->evtm_when <= ev_now)) {
#line 893
        goto while_break;
      }
    } else {
#line 893
      goto while_break;
    }
#line 894
    tmp___1 = tmr->evtm_next;
#line 894
    ct->tmhead = tmp___1;
#line 894
    if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
#line 895
      (tmr->evtm_next)->evtm_prev = (struct ev_tm *)((void *)0);
    } else {
#line 897
      ct->tmtail = (struct ev_tm *)((void *)0);
    }
    {
#line 898
    (ct->tmcnt) --;
#line 899
    ct->tmsum -= tmr->evtm_when;
#line 900
    tmp___2 = (struct ev_tm *)((void *)0);
#line 900
    tmr->evtm_next = tmp___2;
#line 900
    tmr->evtm_prev = tmp___2;
#line 901
    tmr->evtm_when = (ev_time_t )0;
#line 902
    (*(tmr->evtm_cbck))(tmr->evtm_data, tmr, ct);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 904
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 904
    if (! efdl) {
#line 904
      goto while_break___0;
    }
#line 905
    efd = efdl;
#line 906
    revents = (int )efd->revents;
#line 907
    efdl = efd->next;
#line 908
    efd->revents = (short)0;
#line 909
    efd->next = (struct ev_fd *)((void *)0);
#line 910
    if (revents) {
      {
#line 911
      (*(efd->cbck))(efd->data, revents, (int )(efd - ct->efd), ct);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 913
  ct->loop = 0;
#line 914
  if (r < 0) {
    {
#line 915
    tmp___3 = __errno_location();
#line 915
    *tmp___3 = saved_errno;
    }
  }
#line 916
  return (r);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 366 "/usr/include/unistd.h"
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 432
extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) alarm)(unsigned int __seconds ) ;
#line 675
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 678
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) geteuid)(void) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 123
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  * __restrict  __addr ,
                                                                           socklen_t __len ) ;
#line 137
extern int connect(int __fd , struct sockaddr  const  * __restrict  __addr , socklen_t __len ) ;
#line 149
extern ssize_t send(int __fd , void const   *__buf , size_t __n , int __flags ) ;
#line 156
extern ssize_t recv(int __fd , void *__buf , size_t __n , int __flags ) ;
#line 374 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) ntohl)(uint32_t __netlong )  __attribute__((__const__)) ;
#line 379
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 144 "/usr/include/netdb.h"
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 53 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) inet_ntoa)(struct in_addr __in ) ;
#line 73
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) inet_aton)(char const   *__cp ,
                                                                                struct in_addr *__inp ) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 379
extern  __attribute__((__nothrow__)) int vsprintf(char * __restrict  __s , char const   * __restrict  __format ,
                                                  __gnuc_va_list __arg ) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 580
extern int putchar(int __c ) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 515 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 382
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,3), __leaf__)) memmem)(void const   *__haystack ,
                                                                                                 size_t __haystacklen ,
                                                                                                 void const   *__needle ,
                                                                                                 size_t __needlelen )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 32 "/home/wheatley/newnew/temp/proxycheck-0.49a/pxy.h"
char pxybuf[8193] ;
#line 45
pxyproto_t const   pxyprotos[8] ;
#line 53
pxyprobe_t const   pxyprobes[13] ;
#line 79
int pxytimeout ;
#line 85
pxyconn_t *pxynew(void) ;
#line 88
void pxyfree(pxyconn_t *c ) ;
#line 91
int pxystart(pxyconn_t *c , int fd ) ;
#line 94
int pxyrenew(pxyconn_t *c , int tmo , void (*tmfn)(pxyconn_t * ) ) ;
#line 96
int pxyreqio(pxyconn_t *c , int e , void (*iofn)(pxyconn_t * , int  ) ) ;
#line 98
int pxyreqiot(pxyconn_t *c , int e , void (*iofn)(pxyconn_t * , int  ) , int tmo ,
              void (*tmfn)(pxyconn_t * ) ) ;
#line 110
int pxyreadnext(pxyconn_t *c , int minlen , int *tlen , int loglevel ) ;
#line 114
int pxysave(pxyconn_t *c , char *buf , unsigned int len , unsigned int max ) ;
#line 117
int pxywrite(pxyconn_t *c , char const   *buf , int len , int level ) ;
#line 118
int ( /* format attribute */  pxyprintf)(pxyconn_t *c , int loglevel , char const   *fmt 
                                         , ...) ;
#line 122
void ( /* format attribute */  pxyinfo)(pxyconn_t const   *c , int level , char const   *fmt 
                                        , ...) ;
#line 124
void pxyaction(pxyconn_t *c , int result ) ;
#line 128
int pxygetdata(pxyconn_t *c ) ;
#line 131
void pxycheckdata(pxyconn_t *c ) ;
#line 135
void pxyvio(pxyconn_t *c , int level , int direction , char const   *s , int len ) ;
#line 39 "/home/wheatley/newnew/temp/proxycheck-0.49a/proxycheck.c"
static char *progname  ;
#line 40 "/home/wheatley/newnew/temp/proxycheck-0.49a/proxycheck.c"
static int verbose  ;
#line 41 "/home/wheatley/newnew/temp/proxycheck-0.49a/proxycheck.c"
static int maxconn  ;
#line 42 "/home/wheatley/newnew/temp/proxycheck-0.49a/proxycheck.c"
static int maxhconn  ;
#line 43 "/home/wheatley/newnew/temp/proxycheck-0.49a/proxycheck.c"
static int stopfound  ;
#line 44 "/home/wheatley/newnew/temp/proxycheck-0.49a/proxycheck.c"
struct sockaddr_in baddr  ;
#line 45 "/home/wheatley/newnew/temp/proxycheck-0.49a/proxycheck.c"
static pxyhost_t *hosts  ;
#line 46 "/home/wheatley/newnew/temp/proxycheck-0.49a/proxycheck.c"
static int nhosts  ;
#line 47 "/home/wheatley/newnew/temp/proxycheck-0.49a/proxycheck.c"
static pxyhost_t *chost  ;
#line 48 "/home/wheatley/newnew/temp/proxycheck-0.49a/proxycheck.c"
static pxyprotoport_t *pps  ;
#line 49 "/home/wheatley/newnew/temp/proxycheck-0.49a/proxycheck.c"
static int ntodo  ;
#line 50 "/home/wheatley/newnew/temp/proxycheck-0.49a/proxycheck.c"
static int nactive  ;
#line 51 "/home/wheatley/newnew/temp/proxycheck-0.49a/proxycheck.c"
static int nhopen  ;
#line 51 "/home/wheatley/newnew/temp/proxycheck-0.49a/proxycheck.c"
static int npopen  ;
#line 52 "/home/wheatley/newnew/temp/proxycheck-0.49a/proxycheck.c"
static long nread  ;
#line 53 "/home/wheatley/newnew/temp/proxycheck-0.49a/proxycheck.c"
static char *dstspec  ;
#line 54 "/home/wheatley/newnew/temp/proxycheck-0.49a/proxycheck.c"
static struct in_addr dstaddr  ;
#line 55 "/home/wheatley/newnew/temp/proxycheck-0.49a/proxycheck.c"
static ipport_t dstport  ;
#line 56 "/home/wheatley/newnew/temp/proxycheck-0.49a/proxycheck.c"
static int printclosed  ;
#line 57 "/home/wheatley/newnew/temp/proxycheck-0.49a/proxycheck.c"
static int extinfo  ;
#line 58 "/home/wheatley/newnew/temp/proxycheck-0.49a/proxycheck.c"
static int advanced  ;
#line 69
pxycheck_t const   checks[3] ;
#line 70 "/home/wheatley/newnew/temp/proxycheck-0.49a/proxycheck.c"
static pxycheck_t const   *check  ;
#line 72 "/home/wheatley/newnew/temp/proxycheck-0.49a/proxycheck.c"
static void ( /* format attribute */  err)(int errnum , char const   *fmt  , ...) 
{ 
  char buf[1024] ;
  int l ;
  int tmp ;
  va_list ap ;
  int tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 75
  tmp = sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%s: ",
                progname);
#line 75
  l = tmp;
#line 77
  __builtin_va_start(ap, fmt);
#line 78
  tmp___0 = vsprintf((char */* __restrict  */)(buf + l), (char const   */* __restrict  */)fmt,
                     ap);
#line 78
  l += tmp___0;
#line 79
  __builtin_va_end(ap);
  }
#line 80
  if (errnum) {
    {
#line 81
    tmp___1 = __errno_location();
#line 81
    tmp___2 = strerror(*tmp___1);
#line 81
    tmp___3 = sprintf((char */* __restrict  */)(buf + l), (char const   */* __restrict  */)": %s\n",
                      tmp___2);
#line 81
    l += tmp___3;
    }
  } else {
#line 83
    tmp___4 = l;
#line 83
    l ++;
#line 83
    buf[tmp___4] = (char )'\n';
  }
  {
#line 84
  write(2, (void const   *)(buf), (size_t )l);
#line 85
  exit(1);
  }
}
}
#line 88 "/home/wheatley/newnew/temp/proxycheck-0.49a/proxycheck.c"
void ( /* format attribute */  pxyinfo)(pxyconn_t const   *c , int level , char const   *fmt 
                                        , ...) 
{ 
  char buf[512] ;
  int len ;
  va_list ap ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 90
  if (level <= verbose) {
#line 94
    if (c) {
      {
#line 95
      tmp = inet_ntoa((struct in_addr )c->pxyaddr);
#line 95
      len = sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%s:%s:%d: ",
                    tmp, (c->proto)->aname, (int const   )c->pxyport);
      }
    } else {
#line 98
      len = 0;
    }
    {
#line 99
    __builtin_va_start(ap, fmt);
#line 100
    tmp___0 = vsprintf((char */* __restrict  */)(buf + len), (char const   */* __restrict  */)fmt,
                       ap);
#line 100
    len += tmp___0;
#line 101
    __builtin_va_end(ap);
#line 102
    tmp___1 = len;
#line 102
    len ++;
#line 102
    buf[tmp___1] = (char )'\n';
#line 103
    write(2, (void const   *)(buf), (size_t )len);
    }
  }
#line 105
  return;
}
}
#line 107 "/home/wheatley/newnew/temp/proxycheck-0.49a/proxycheck.c"
void pxyvio(pxyconn_t *c , int level , int direction , char const   *s , int len ) 
{ 
  char buf[90] ;
  char *bs ;
  char *bp ;
  char const   *e ;
  char *be ;
  char const   *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;

  {
#line 109
  if (level <= verbose) {
#line 112
    e = s + len;
#line 113
    be = ((buf + sizeof(buf)) - 1) - 4;
#line 114
    if (direction > 0) {
#line 114
      tmp = ">>";
    } else {
#line 114
      tmp = "<<";
    }
    {
#line 114
    tmp___0 = inet_ntoa(c->pxyaddr);
#line 114
    tmp___1 = sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%s:%s:%d: %s ",
                      tmp___0, (c->proto)->aname, (int )c->pxyport, tmp);
#line 114
    bs = buf + tmp___1;
#line 117
    bp = bs;
    }
    {
#line 120
    while (1) {
      while_continue: /* CIL Label */ ;
#line 120
      if (! ((unsigned long )s < (unsigned long )e)) {
#line 120
        goto while_break;
      }
#line 121
      if ((unsigned long )bp >= (unsigned long )be) {
        {
#line 122
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 122
          tmp___2 = bp;
#line 122
          bp ++;
#line 122
          *tmp___2 = (char )'\n';
#line 122
          write(2, (void const   *)(buf), (size_t )(bp - buf));
#line 122
          bp = bs;
          }
#line 122
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
      {
#line 124
      if ((int const   )*s == 10) {
#line 124
        goto case_10;
      }
#line 125
      if ((int const   )*s == 13) {
#line 125
        goto case_13;
      }
#line 126
      if ((int const   )*s == 9) {
#line 126
        goto case_9;
      }
#line 127
      if ((int const   )*s == 92) {
#line 127
        goto case_92;
      }
#line 128
      goto switch_default;
      case_10: /* CIL Label */ 
#line 124
      tmp___3 = bp;
#line 124
      bp ++;
#line 124
      *tmp___3 = (char )'\\';
#line 124
      tmp___4 = bp;
#line 124
      bp ++;
#line 124
      *tmp___4 = (char )'n';
#line 124
      goto switch_break;
      case_13: /* CIL Label */ 
#line 125
      tmp___5 = bp;
#line 125
      bp ++;
#line 125
      *tmp___5 = (char )'\\';
#line 125
      tmp___6 = bp;
#line 125
      bp ++;
#line 125
      *tmp___6 = (char )'r';
#line 125
      goto switch_break;
      case_9: /* CIL Label */ 
#line 126
      tmp___7 = bp;
#line 126
      bp ++;
#line 126
      *tmp___7 = (char )'\\';
#line 126
      tmp___8 = bp;
#line 126
      bp ++;
#line 126
      *tmp___8 = (char )'t';
#line 126
      goto switch_break;
      case_92: /* CIL Label */ 
#line 127
      tmp___9 = bp;
#line 127
      bp ++;
#line 127
      *tmp___9 = (char )'\\';
#line 127
      tmp___10 = bp;
#line 127
      bp ++;
#line 127
      *tmp___10 = (char )'\\';
#line 127
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 129
      if ((int const   )*s < 32) {
        {
#line 130
        tmp___11 = sprintf((char */* __restrict  */)bp, (char const   */* __restrict  */)"\\%o",
                           (int )((unsigned char )*s));
#line 130
        bp += tmp___11;
        }
      } else
#line 129
      if ((int const   )*s >= 127) {
        {
#line 130
        tmp___11 = sprintf((char */* __restrict  */)bp, (char const   */* __restrict  */)"\\%o",
                           (int )((unsigned char )*s));
#line 130
        bp += tmp___11;
        }
      } else {
#line 132
        tmp___12 = bp;
#line 132
        bp ++;
#line 132
        *tmp___12 = (char )*s;
      }
      switch_break: /* CIL Label */ ;
      }
#line 134
      if ((int const   )*s == 10) {
        {
#line 135
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 135
          tmp___13 = bp;
#line 135
          bp ++;
#line 135
          *tmp___13 = (char )'\n';
#line 135
          write(2, (void const   *)(buf), (size_t )(bp - buf));
#line 135
          bp = bs;
          }
#line 135
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 136
      s ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 138
    if ((unsigned long )bp > (unsigned long )bs) {
      {
#line 139
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 139
        tmp___14 = bp;
#line 139
        bp ++;
#line 139
        *tmp___14 = (char )'\n';
#line 139
        write(2, (void const   *)(buf), (size_t )(bp - buf));
#line 139
        bp = bs;
        }
#line 139
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
  }
#line 142
  return;
}
}
#line 144 "/home/wheatley/newnew/temp/proxycheck-0.49a/proxycheck.c"
void *emalloc(unsigned int size ) 
{ 
  void *ptr ;
  void *tmp ;

  {
  {
#line 145
  tmp = malloc((size_t )size);
#line 145
  ptr = tmp;
  }
#line 146
  if (! ptr) {
    {
#line 147
    err(0, "out of memory (%d bytes)", size);
    }
  }
#line 148
  return (ptr);
}
}
#line 151 "/home/wheatley/newnew/temp/proxycheck-0.49a/proxycheck.c"
void *erealloc(void *ptr , unsigned int size ) 
{ 


  {
  {
#line 152
  ptr = realloc(ptr, (size_t )size);
  }
#line 153
  if (! ptr) {
    {
#line 154
    err(0, "out of memory (%d bytes)", size);
    }
  }
#line 155
  return (ptr);
}
}
#line 158 "/home/wheatley/newnew/temp/proxycheck-0.49a/proxycheck.c"
static int satoi(char const   *s ) 
{ 
  int c ;
  char const   *tmp ;
  int tmp___0 ;

  {
#line 160
  c = 0;
#line 161
  if ((int const   )*s < 48) {
#line 161
    return (-1);
  } else
#line 161
  if ((int const   )*s > 57) {
#line 161
    return (-1);
  }
  {
#line 162
  while (1) {
    while_continue: /* CIL Label */ ;
#line 163
    tmp = s;
#line 163
    s ++;
#line 163
    c = c * 10 + (int )((int const   )*tmp - 48);
#line 162
    if ((int const   )*s >= 48) {
#line 162
      if (! ((int const   )*s <= 57)) {
#line 162
        goto while_break;
      }
    } else {
#line 162
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 165
  if (*s) {
#line 165
    tmp___0 = -1;
  } else {
#line 165
    tmp___0 = c;
  }
#line 165
  return (tmp___0);
}
}
#line 168 "/home/wheatley/newnew/temp/proxycheck-0.49a/proxycheck.c"
static int hostaddr(char const   *s , struct in_addr *a ) 
{ 
  struct hostent *he ;
  struct hostent *tmp ;
  int tmp___0 ;

  {
  {
#line 170
  tmp___0 = inet_aton(s, a);
  }
#line 170
  if (! tmp___0) {
    {
#line 171
    tmp = gethostbyname(s);
#line 171
    he = tmp;
    }
#line 172
    if (! he) {
#line 172
      return (0);
    }
#line 173
    if (he->h_addrtype != 2) {
#line 175
      return (0);
    } else
#line 173
    if (he->h_length != 4) {
#line 175
      return (0);
    }
    {
#line 176
    memcpy((void */* __restrict  */)(& a->s_addr), (void const   */* __restrict  */)*(he->h_addr_list + 0),
           (size_t )4);
    }
  }
#line 178
  return (1);
}
}
#line 181 "/home/wheatley/newnew/temp/proxycheck-0.49a/proxycheck.c"
static ipport_t portnum(char const   *s ) 
{ 
  int p ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 183
  tmp = satoi(s);
#line 183
  p = tmp;
  }
#line 184
  if (p < 1) {
#line 184
    tmp___0 = 0;
  } else
#line 184
  if (p > 65535) {
#line 184
    tmp___0 = 0;
  } else {
#line 184
    tmp___0 = (int )((ipport_t )p);
  }
#line 184
  return ((ipport_t )tmp___0);
}
}
#line 187 "/home/wheatley/newnew/temp/proxycheck-0.49a/proxycheck.c"
static pxyhost_t *findhost(struct in_addr addr ) 
{ 
  register pxyhost_t *h ;
  void *tmp ;

  {
#line 190
  h = hosts;
  {
#line 190
  while (1) {
    while_continue: /* CIL Label */ ;
#line 190
    if (! h) {
#line 190
      goto while_break;
    }
#line 191
    if (h->addr.s_addr == addr.s_addr) {
#line 192
      return (h);
    }
#line 190
    h = h->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 193
  tmp = emalloc((unsigned int )sizeof(*h));
#line 193
  h = (pxyhost_t *)tmp;
#line 194
  memset((void *)h, 0, sizeof(*h));
#line 195
  h->addr = addr;
#line 196
  h->next = hosts;
#line 197
  hosts = h;
  }
#line 198
  return (h);
}
}
#line 201 "/home/wheatley/newnew/temp/proxycheck-0.49a/proxycheck.c"
static void donehost(pxyhost_t *h ) 
{ 
  pxyhost_t *hp ;
  char *tmp ;

  {
  {
#line 204
  tmp = inet_ntoa(h->addr);
#line 204
  pxyinfo((pxyconn_t const   *)((void *)0), 4, "%s: done, numopen=%d", tmp, h->nopen);
  }
#line 205
  if ((unsigned long )h->pps != (unsigned long )pps) {
    {
#line 206
    free((void *)h->pps);
    }
  }
#line 207
  if ((unsigned long )h == (unsigned long )hosts) {
#line 208
    hosts = h->next;
  } else {
#line 210
    hp = hosts;
    {
#line 211
    while (1) {
      while_continue: /* CIL Label */ ;
#line 211
      if (! ((unsigned long )hp->next != (unsigned long )h)) {
#line 211
        goto while_break;
      }
#line 212
      hp = hp->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 213
    hp->next = h->next;
  }
#line 215
  hp = h->next;
#line 216
  if ((unsigned long )chost == (unsigned long )h) {
#line 217
    if (hp) {
#line 217
      chost = hp;
    } else {
#line 217
      chost = hosts;
    }
  }
  {
#line 218
  free((void *)h);
#line 219
  nhosts --;
  }
#line 220
  return;
}
}
#line 222 "/home/wheatley/newnew/temp/proxycheck-0.49a/proxycheck.c"
static void ( /* format attribute */  usage)(char const   *fmt  , ...) 
{ 
  char buf[256] ;
  int l ;
  int tmp ;
  va_list ap ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 225
  tmp = sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%s: ",
                progname);
#line 225
  l = tmp;
#line 227
  __builtin_va_start(ap, fmt);
#line 228
  tmp___0 = vsprintf((char */* __restrict  */)(buf + l), (char const   */* __restrict  */)fmt,
                     ap);
#line 228
  l += tmp___0;
#line 229
  __builtin_va_end(ap);
#line 230
  tmp___1 = sprintf((char */* __restrict  */)(buf + l), (char const   */* __restrict  */)"\n%s: `%s -h\' for help\n",
                    progname, progname);
#line 230
  l += tmp___1;
#line 231
  write(2, (void const   *)(buf), (size_t )l);
#line 232
  exit(1);
  }
}
}
#line 237 "/home/wheatley/newnew/temp/proxycheck-0.49a/proxycheck.c"
static pxyprotoport_t *addprotoport(pxyprotoport_t *pp , ipport_t port , pxyproto_t const   *proto ) 
{ 
  pxyprotoport_t *p ;
  void *tmp ;
  int n ;
  void *tmp___0 ;

  {
#line 240
  if (! pp) {
    {
#line 241
    tmp = emalloc((unsigned int )(sizeof(*pp) * 5UL));
#line 241
    pp = (pxyprotoport_t *)tmp;
#line 242
    p = pp;
    }
  } else {
#line 246
    n = 0;
    {
#line 246
    while (1) {
      while_continue: /* CIL Label */ ;
#line 246
      if (! (pp + n)->port) {
#line 246
        goto while_break;
      }
#line 247
      if ((int )(pp + n)->port == (int )port) {
#line 247
        if ((unsigned long )(pp + n)->proto == (unsigned long )proto) {
#line 248
          return (pp);
        }
      }
#line 246
      n ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 249
    if (! (n & 3)) {
      {
#line 250
      tmp___0 = erealloc((void *)pp, (unsigned int )(sizeof(*pp) * (unsigned long )(n + 5)));
#line 250
      pp = (pxyprotoport_t *)tmp___0;
      }
    }
#line 251
    p = pp + n;
  }
#line 253
  p->port = port;
#line 254
  p->proto = proto;
#line 255
  (p + 1)->port = (ipport_t )0;
#line 256
  (p + 1)->proto = (pxyproto_t const   *)((void *)0);
#line 257
  return (pp);
}
}
#line 267
static pxyprotoport_t *parseprotoport(pxyprotoport_t *pp , char *s ) ;
#line 267 "/home/wheatley/newnew/temp/proxycheck-0.49a/proxycheck.c"
static char const   *delims  =    ",|/; \t";
#line 260 "/home/wheatley/newnew/temp/proxycheck-0.49a/proxycheck.c"
static pxyprotoport_t *parseprotoport(pxyprotoport_t *pp , char *s ) 
{ 
  char *p ;
  pxyprobe_t const   *probe ;
  ipport_t const   *portp ;
  ipport_t port ;
  int n ;
  int found ;
  pxyproto_t const   *proto ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 268
  p = strchr((char const   *)s, ':');
  }
#line 268
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 270
    *p = (char )'\000';
#line 271
    proto = pxyprotos;
    {
#line 272
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 272
      tmp = strcmp((char const   *)proto->name, (char const   *)s);
      }
#line 272
      if (tmp != 0) {
        {
#line 272
        tmp___0 = strcmp((char const   *)proto->aname, (char const   *)s);
        }
#line 272
        if (! (tmp___0 != 0)) {
#line 272
          goto while_break;
        }
      } else {
#line 272
        goto while_break;
      }
#line 273
      proto ++;
#line 273
      if (! proto->name) {
        {
#line 274
        usage("invalid protocol `%s\'", s);
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 275
    tmp___1 = p;
#line 275
    p ++;
#line 275
    *tmp___1 = (char )':';
#line 276
    found = 0;
    {
#line 277
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 277
      if (! *p) {
#line 277
        goto while_break___0;
      }
      {
#line 278
      tmp___2 = strchr(delims, (int )*p);
      }
#line 278
      if (tmp___2) {
#line 278
        p ++;
#line 278
        goto while_continue___0;
      }
#line 279
      s = p;
#line 280
      n = 0;
      {
#line 281
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 281
        if ((int )*p >= 48) {
#line 281
          if ((int )*p <= 57) {
#line 281
            if (! ((unsigned long )p < (unsigned long )(s + 5))) {
#line 281
              goto while_break___1;
            }
          } else {
#line 281
            goto while_break___1;
          }
        } else {
#line 281
          goto while_break___1;
        }
#line 282
        tmp___3 = p;
#line 282
        p ++;
#line 282
        n = n * 10 + ((int )*tmp___3 - 48);
      }
      while_break___1: /* CIL Label */ ;
      }
#line 283
      if (! n) {
        {
#line 284
        usage("invalid port specification near `%s\'", s);
        }
      } else
#line 283
      if (n > 65535) {
        {
#line 284
        usage("invalid port specification near `%s\'", s);
        }
      }
      {
#line 285
      found ++;
#line 286
      pp = addprotoport(pp, (ipport_t )n, proto);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 288
    if (! found) {
#line 289
      probe = pxyprobes;
      {
#line 290
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 290
        if (! probe->proto) {
#line 290
          goto while_break___2;
        }
#line 291
        if ((unsigned long )probe->proto == (unsigned long )proto) {
#line 292
          portp = (ipport_t const   *)probe->ports;
          {
#line 292
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 292
            if (! *portp) {
#line 292
              goto while_break___3;
            }
            {
#line 293
            pp = addprotoport(pp, (ipport_t )*portp, proto);
#line 292
            portp ++;
            }
          }
          while_break___3: /* CIL Label */ ;
          }
#line 294
          if (probe->advanced >= (int const   )advanced) {
#line 295
            goto while_break___2;
          }
        }
#line 297
        probe ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
  } else {
#line 302
    p = s;
    {
#line 303
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 303
      if (! *p) {
#line 303
        goto while_break___4;
      }
      {
#line 304
      tmp___4 = strchr(delims, (int )*p);
      }
#line 304
      if (tmp___4) {
#line 304
        p ++;
#line 304
        goto while_continue___4;
      }
#line 305
      s = p;
#line 306
      n = 0;
      {
#line 307
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 307
        if ((int )*p >= 48) {
#line 307
          if ((int )*p <= 57) {
#line 307
            if (! ((unsigned long )p < (unsigned long )(s + 5))) {
#line 307
              goto while_break___5;
            }
          } else {
#line 307
            goto while_break___5;
          }
        } else {
#line 307
          goto while_break___5;
        }
#line 308
        tmp___5 = p;
#line 308
        p ++;
#line 308
        n = n * 10 + ((int )*tmp___5 - 48);
      }
      while_break___5: /* CIL Label */ ;
      }
#line 309
      if (! n) {
        {
#line 310
        usage("invalid port specification near `%s\'", s);
        }
      } else
#line 309
      if (n > 65535) {
        {
#line 310
        usage("invalid port specification near `%s\'", s);
        }
      }
#line 311
      port = (ipport_t )n;
#line 312
      found = 0;
#line 313
      probe = pxyprobes;
      {
#line 314
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 314
        if (probe->proto) {
#line 314
          if (! (! found)) {
#line 314
            if (! (probe->advanced <= (int const   )advanced)) {
#line 314
              goto while_break___6;
            }
          }
        } else {
#line 314
          goto while_break___6;
        }
#line 315
        portp = (ipport_t const   *)probe->ports;
        {
#line 315
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 315
          if (! *portp) {
#line 315
            goto while_break___7;
          }
#line 316
          if ((int const   )*portp == (int const   )port) {
            {
#line 317
            pp = addprotoport(pp, port, (pxyproto_t const   *)probe->proto);
#line 318
            found = 1;
            }
#line 319
            goto while_break___7;
          }
#line 315
          portp ++;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 321
        probe ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 323
      if (! found) {
#line 324
        probe = pxyprobes;
        {
#line 324
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 324
          if (! probe->proto) {
#line 324
            goto while_break___8;
          }
#line 325
          if (probe->advanced <= (int const   )advanced) {
            {
#line 326
            pp = addprotoport(pp, port, (pxyproto_t const   *)probe->proto);
            }
          }
#line 324
          probe ++;
        }
        while_break___8: /* CIL Label */ ;
        }
      }
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 329
  return (pp);
}
}
#line 332 "/home/wheatley/newnew/temp/proxycheck-0.49a/proxycheck.c"
static int numprotoports(pxyprotoport_t const   *pp ) 
{ 
  pxyprotoport_t const   *ppp ;

  {
#line 334
  ppp = pp;
  {
#line 335
  while (1) {
    while_continue: /* CIL Label */ ;
#line 335
    if (! ppp->port) {
#line 335
      goto while_break;
    }
#line 335
    ppp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 336
  return ((int )(ppp - pp));
}
}
#line 339 "/home/wheatley/newnew/temp/proxycheck-0.49a/proxycheck.c"
static void addent(char *p ) 
{ 
  char *n ;
  struct in_addr addr ;
  pxyhost_t *h ;
  int tmp ;
  char *tmp___0 ;

  {
  {
#line 340
  n = p;
#line 343
  p = strchr((char const   *)n, ':');
  }
#line 343
  if (p) {
#line 343
    *p = (char )'\000';
  }
  {
#line 344
  tmp = hostaddr((char const   *)n, & addr);
  }
#line 344
  if (! tmp) {
    {
#line 345
    usage("invalid IP address `%s\'", n);
    }
  }
  {
#line 346
  h = findhost(addr);
  }
#line 347
  if (p) {
#line 348
    tmp___0 = p;
#line 348
    p ++;
#line 348
    *tmp___0 = (char )':';
#line 349
    if (*p) {
      {
#line 350
      h->pps = parseprotoport(h->pps, p);
      }
    } else {
#line 352
      h->nopen = 1;
    }
  } else {
#line 355
    h->nopen = 1;
  }
#line 356
  return;
}
}
#line 358 "/home/wheatley/newnew/temp/proxycheck-0.49a/proxycheck.c"
static void init(int argc , char **argv ) 
{ 
  int c ;
  int timeout ;
  pxyhost_t *h ;
  pxyproto_t const   *proto ;
  pxyprobe_t const   *probe ;
  ipport_t const   *portp ;
  pxyprotoport_t *pp ;
  char *p ;
  int npps ;
  char const   *readin ;
  int add_defaults ;
  char *check_arg ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  ipport_t const   *tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  char **tmp___5 ;
  FILE *f ;
  char buf[8192] ;
  int *tmp___6 ;
  char *p___0 ;
  char *e ;
  char *tmp___7 ;
  __uid_t tmp___8 ;
  __uid_t tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
  {
#line 361
  timeout = 0;
#line 369
  readin = (char const   *)((void *)0);
#line 370
  add_defaults = 0;
#line 371
  check_arg = (char *)((void *)0);
#line 373
  progname = strrchr((char const   *)*(argv + 0), '/');
  }
#line 373
  if ((unsigned long )progname != (unsigned long )((void *)0)) {
#line 374
    progname ++;
#line 374
    *(argv + 0) = progname;
  } else {
#line 376
    progname = *(argv + 0);
  }
  {
#line 378
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 378
    c = getopt(argc, (char * const  *)argv, "vd:c:p:Db:t:m:M:i:nasxh");
    }
#line 378
    if (! (c != -1)) {
#line 378
      goto while_break;
    }
    {
#line 382
    if (c == 118) {
#line 382
      goto case_118;
    }
#line 386
    if (c == 112) {
#line 386
      goto case_112;
    }
#line 390
    if (c == 100) {
#line 390
      goto case_100;
    }
#line 394
    if (c == 68) {
#line 394
      goto case_68;
    }
#line 398
    if (c == 99) {
#line 398
      goto case_99;
    }
#line 415
    if (c == 98) {
#line 415
      goto case_98;
    }
#line 421
    if (c == 116) {
#line 421
      goto case_116;
    }
#line 426
    if (c == 109) {
#line 426
      goto case_109;
    }
#line 431
    if (c == 77) {
#line 431
      goto case_77;
    }
#line 437
    if (c == 105) {
#line 437
      goto case_105;
    }
#line 441
    if (c == 110) {
#line 441
      goto case_110;
    }
#line 445
    if (c == 97) {
#line 445
      goto case_97;
    }
#line 449
    if (c == 115) {
#line 449
      goto case_115;
    }
#line 453
    if (c == 120) {
#line 453
      goto case_120;
    }
#line 457
    if (c == 104) {
#line 457
      goto case_104;
    }
#line 504
    goto switch_default;
    case_118: /* CIL Label */ 
#line 383
    verbose ++;
#line 384
    goto switch_break;
    case_112: /* CIL Label */ 
    {
#line 387
    pps = parseprotoport(pps, optarg);
    }
#line 388
    goto switch_break;
    case_100: /* CIL Label */ 
#line 391
    dstspec = optarg;
#line 392
    goto switch_break;
    case_68: /* CIL Label */ 
#line 395
    add_defaults ++;
#line 396
    goto switch_break;
    case_99: /* CIL Label */ 
    {
#line 399
    p = strchr((char const   *)optarg, ':');
    }
#line 399
    if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 400
      *p = (char )'\000';
    }
#line 401
    check = checks;
    {
#line 401
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 402
      if (! check->name) {
        {
#line 403
        usage("unknown check `%s\'", optarg);
        }
      } else {
        {
#line 404
        tmp = strcmp((char const   *)optarg, (char const   *)check->name);
        }
#line 404
        if (tmp == 0) {
#line 405
          goto while_break___0;
        }
      }
#line 401
      check ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 406
    if (p) {
#line 407
      check_arg = p + 1;
#line 407
      *p = (char )':';
    } else {
      {
#line 409
      tmp___0 = strcmp((char const   *)optarg, "chat");
      }
#line 409
      if (tmp___0 == 0) {
        {
#line 410
        usage("this check requires parameters");
        }
      } else {
#line 412
        check_arg = (char *)((void *)0);
      }
    }
#line 413
    goto switch_break;
    case_98: /* CIL Label */ 
    {
#line 416
    tmp___1 = hostaddr((char const   *)optarg, & baddr.sin_addr);
    }
#line 416
    if (! tmp___1) {
      {
#line 417
      usage("unknown host `%s\'", optarg);
      }
    }
#line 418
    baddr.sin_family = (sa_family_t )2;
#line 419
    goto switch_break;
    case_116: /* CIL Label */ 
    {
#line 422
    timeout = satoi((char const   *)optarg);
    }
#line 422
    if (timeout < 1) {
      {
#line 423
      usage("invalid timeout `%s\'", optarg);
      }
    } else
#line 422
    if (timeout > 1000) {
      {
#line 423
      usage("invalid timeout `%s\'", optarg);
      }
    }
#line 424
    goto switch_break;
    case_109: /* CIL Label */ 
    {
#line 427
    maxconn = satoi((char const   *)optarg);
    }
#line 427
    if (maxconn < 1) {
      {
#line 428
      usage("invalid maximum number of connections `%s\'", optarg);
      }
    }
#line 429
    goto switch_break;
    case_77: /* CIL Label */ 
    {
#line 432
    maxhconn = satoi((char const   *)optarg);
    }
#line 432
    if (maxhconn < 0) {
      {
#line 433
      usage("invalid maximum number of connections to one host `%s\'", optarg);
      }
    }
#line 435
    goto switch_break;
    case_105: /* CIL Label */ 
#line 438
    readin = (char const   *)optarg;
#line 439
    goto switch_break;
    case_110: /* CIL Label */ 
#line 442
    printclosed = 1;
#line 443
    goto switch_break;
    case_97: /* CIL Label */ 
#line 446
    advanced ++;
#line 447
    goto switch_break;
    case_115: /* CIL Label */ 
#line 450
    stopfound ++;
#line 451
    goto switch_break;
    case_120: /* CIL Label */ 
#line 454
    extinfo = 1;
#line 455
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 458
    printf((char const   */* __restrict  */)"%s: Open proxy checker version 0.49a 2004-05-29\nUsage is: `%s options host[:proto_port_spec]...\'\nwhere options are:\n -h - print this help and exit\n -d dsthost:dstport - destination to connect to (required)\n -c check[:params] - method to check proxy (required, see below)\n -p proto_port_spec - proxy port/protocol specification\n   (may be used more than once) - see below\n -D - do not reset default portlist in case -p option specified\n -a - use \"advanced\" protocols too (more -a\'s means more advanced)\n -t timeout - general timeout in secounds, default %d\n -m maxconn - maximum number of parallel connections\n -M maxhconn - maximum number of parallel connections to one host\n -s - stop probing a host after first found open proxy\n -b bindaddr - bind to specified address\n -x - print extended info (proxy software etc) if known\n -n - also print a line about definitely closed proxies\n\nproto_port_spec is in the form [proto:][port,port,...].\nIf portlist is omitted, default ports for given protocols\nwill be tried; if proto is omitted, either all protocols will\nbe tried (if port is not known), or the protocols which are\nassotiated with this port.\n\nThe following protocols are recognized:\n",
           progname, progname, pxytimeout / 1000);
#line 485
    proto = pxyprotos;
    }
    {
#line 485
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 485
      if (! proto->name) {
#line 485
        goto while_break___1;
      }
      {
#line 486
      printf((char const   */* __restrict  */)" %s (%s, %s, %s)\n", proto->aname,
             proto->name, proto->transport, proto->fullname);
#line 485
      proto ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 488
    printf((char const   */* __restrict  */)"\nThe following probes are made (level cf. -a):\n");
#line 489
    probe = pxyprobes;
    }
    {
#line 489
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 489
      if (! probe->proto) {
#line 489
        goto while_break___2;
      }
      {
#line 490
      printf((char const   */* __restrict  */)" %s (level %d): ", (probe->proto)->aname,
             probe->advanced);
#line 491
      portp = (ipport_t const   *)probe->ports;
      }
      {
#line 491
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 492
        tmp___2 = portp;
#line 492
        portp ++;
#line 492
        printf((char const   */* __restrict  */)"%d", (int const   )*tmp___2);
        }
#line 493
        if (*portp) {
#line 493
          tmp___3 = ',';
        } else {
#line 493
          tmp___3 = '\n';
        }
        {
#line 493
        putchar(tmp___3);
        }
#line 494
        if (! *portp) {
#line 494
          goto while_break___3;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 489
      probe ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 497
    printf((char const   */* __restrict  */)"\nThe following checks are available:\n");
#line 498
    check = checks;
    }
    {
#line 498
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 498
      if (! check->name) {
#line 498
        goto while_break___4;
      }
#line 499
      if (check->arg) {
#line 499
        tmp___4 = (char const   */* const  */)check->arg;
      } else {
#line 499
        tmp___4 = (char const   */* const  */)"";
      }
      {
#line 499
      printf((char const   */* __restrict  */)" %s%s - %s", check->name, tmp___4,
             check->descr);
#line 498
      check ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 502
    exit(0);
    }
    switch_default: /* CIL Label */ 
    {
#line 505
    err(0, "`%s -h\' for help", progname);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 508
  argc -= optind;
#line 508
  argv += optind;
#line 509
  if (! *argv) {
#line 509
    if (! readin) {
      {
#line 510
      usage("no host(s) to check specified");
      }
    }
  }
#line 512
  if (! check) {
    {
#line 513
    usage("no action (-c) specified");
    }
  }
  {
#line 515
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 515
    if (! *argv) {
#line 515
      goto while_break___5;
    }
    {
#line 516
    tmp___5 = argv;
#line 516
    argv ++;
#line 516
    addent(*tmp___5);
    }
  }
  while_break___5: /* CIL Label */ ;
  }
#line 517
  if (readin) {
#line 520
    if ((int const   )*(readin + 0) == 45) {
#line 520
      if ((int const   )*(readin + 1) == 0) {
#line 521
        f = stdin;
      } else {
#line 520
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 522
      f = fopen((char const   */* __restrict  */)readin, (char const   */* __restrict  */)"r");
      }
#line 522
      if ((unsigned long )f == (unsigned long )((void *)0)) {
        {
#line 523
        tmp___6 = __errno_location();
#line 523
        err(*tmp___6, "unable to open %s", readin);
        }
      }
    }
    {
#line 524
    while (1) {
      while_continue___6: /* CIL Label */ ;
      {
#line 524
      tmp___7 = fgets((char */* __restrict  */)(buf), (int )sizeof(buf), (FILE */* __restrict  */)f);
      }
#line 524
      if (! tmp___7) {
#line 524
        goto while_break___6;
      }
#line 525
      p___0 = buf;
      {
#line 527
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 527
        if (! ((int )*p___0 == 32)) {
#line 527
          if (! ((int )*p___0 == 9)) {
#line 527
            goto while_break___7;
          }
        }
#line 528
        p___0 ++;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 529
      if ((int )*p___0 == 35) {
#line 530
        goto while_continue___6;
      } else
#line 529
      if ((int )*p___0 == 10) {
#line 530
        goto while_continue___6;
      } else
#line 529
      if (! *p___0) {
#line 530
        goto while_continue___6;
      }
      {
#line 531
      e = strchr((char const   *)p___0, '\n');
      }
#line 531
      if ((unsigned long )e != (unsigned long )((void *)0)) {
#line 532
        *e = (char )'\000';
      }
      {
#line 533
      addent(p___0);
      }
    }
    while_break___6: /* CIL Label */ ;
    }
#line 535
    if ((unsigned long )f != (unsigned long )stdin) {
      {
#line 536
      fclose(f);
      }
    }
  }
  {
#line 539
  tmp___8 = getuid();
  }
#line 539
  if (tmp___8 == 0U) {
    {
#line 540
    pxyinfo((pxyconn_t const   *)((void *)0), 0, "warning: do not run this program as root");
    }
  } else {
    {
#line 539
    tmp___9 = geteuid();
    }
#line 539
    if (tmp___9 == 0U) {
      {
#line 540
      pxyinfo((pxyconn_t const   *)((void *)0), 0, "warning: do not run this program as root");
      }
    }
  }
  {
#line 542
  (*(check->init))(check_arg);
  }
#line 544
  if (! dstspec) {
    {
#line 545
    usage("no destination (-d) specified");
    }
  }
  {
#line 547
  p = strchr((char const   *)dstspec, ':');
  }
#line 547
  if (! p) {
    {
#line 548
    usage("destination port missing in `%s\'", dstspec);
    }
  }
  {
#line 549
  *p = (char )'\000';
#line 550
  tmp___10 = hostaddr((char const   *)dstspec, & dstaddr);
  }
#line 550
  if (! tmp___10) {
    {
#line 551
    usage("unknown destination host `%s\'", dstspec);
    }
  }
  {
#line 552
  dstport = portnum((char const   *)(p + 1));
  }
#line 552
  if (! dstport) {
    {
#line 553
    usage("invalid destination port `%s\'", p + 1);
    }
  }
#line 554
  *p = (char )':';
#line 557
  if (! pps) {
#line 557
    goto _L___0;
  } else
#line 557
  if (add_defaults) {
    _L___0: /* CIL Label */ 
#line 558
    probe = pxyprobes;
    {
#line 558
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 558
      if (! probe->proto) {
#line 558
        goto while_break___8;
      }
#line 559
      if (probe->advanced <= (int const   )advanced) {
#line 560
        portp = (ipport_t const   *)probe->ports;
        {
#line 560
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 560
          if (! *portp) {
#line 560
            goto while_break___9;
          }
          {
#line 561
          pps = addprotoport(pps, (ipport_t )*portp, (pxyproto_t const   *)probe->proto);
#line 560
          portp ++;
          }
        }
        while_break___9: /* CIL Label */ ;
        }
      }
#line 558
      probe ++;
    }
    while_break___8: /* CIL Label */ ;
    }
  }
  {
#line 563
  npps = numprotoports((pxyprotoport_t const   *)pps);
#line 565
  h = hosts;
  }
  {
#line 565
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 565
    if (! h) {
#line 565
      goto while_break___10;
    }
#line 566
    nhosts ++;
#line 567
    if (! h->pps) {
#line 568
      h->pps = pps;
#line 568
      ntodo += npps;
    } else {
#line 570
      if (h->nopen) {
#line 571
        pp = pps;
        {
#line 571
        while (1) {
          while_continue___11: /* CIL Label */ ;
#line 571
          if (! pp->port) {
#line 571
            goto while_break___11;
          }
          {
#line 572
          h->pps = addprotoport(h->pps, pp->port, pp->proto);
#line 571
          pp ++;
          }
        }
        while_break___11: /* CIL Label */ ;
        }
      }
      {
#line 574
      tmp___11 = numprotoports((pxyprotoport_t const   *)h->pps);
#line 574
      ntodo += tmp___11;
      }
    }
#line 576
    h->nopen = 0;
#line 577
    h->cpp = h->pps;
#line 565
    h = h->next;
  }
  while_break___10: /* CIL Label */ ;
  }
  {
#line 588
  pxyinfo((pxyconn_t const   *)((void *)0), 1, "To check: hosts=%d, proto:ports=%d, host:proto:ports=%d",
          nhosts, npps, ntodo);
  }
#line 592
  if (timeout) {
#line 593
    pxytimeout = timeout * 1000;
  }
  {
#line 594
  chost = hosts;
#line 596
  signal(13, (void (*)(int  ))1);
  }
#line 597
  return;
}
}
#line 599 "/home/wheatley/newnew/temp/proxycheck-0.49a/proxycheck.c"
static int nextconn(void) 
{ 
  pxyconn_t *c ;
  pxyprotoport_t *pp ;
  pxyhost_t *h ;
  int fd ;
  struct sockaddr_in sin ;
  int *tmp ;
  int *tmp___0 ;
  pxyprotoport_t *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;

  {
#line 607
  if (! ntodo) {
#line 608
    return (0);
  }
#line 610
  if (maxconn) {
#line 610
    if (nactive >= maxconn) {
#line 611
      return (0);
    }
  }
#line 614
  h = chost;
#line 614
  fd = 0;
  {
#line 615
  while (1) {
    while_continue: /* CIL Label */ ;
#line 616
    if ((h->cpp)->port) {
#line 616
      if (! maxhconn) {
#line 617
        fd = 1;
#line 618
        goto while_break;
      } else
#line 616
      if (h->nactive < maxhconn) {
#line 617
        fd = 1;
#line 618
        goto while_break;
      }
    }
#line 620
    h = h->next;
#line 620
    if (! h) {
#line 621
      h = hosts;
    }
#line 615
    if (! ((unsigned long )h != (unsigned long )chost)) {
#line 615
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 623
  if (! fd) {
#line 624
    return (0);
  }
  {
#line 626
  fd = socket(2, 1, 6);
  }
#line 627
  if (fd < 0) {
    {
#line 628
    tmp___0 = __errno_location();
    }
#line 628
    if (*tmp___0 != 24) {
      {
#line 629
      tmp = __errno_location();
#line 629
      err(*tmp, "unable to create socket");
      }
    }
#line 630
    if (! maxconn) {
      {
#line 631
      pxyinfo((pxyconn_t const   *)((void *)0), 1, "limiting max number of connections to %d",
              nactive);
#line 633
      maxconn = nactive;
      }
    } else
#line 630
    if (maxconn > nactive) {
      {
#line 631
      pxyinfo((pxyconn_t const   *)((void *)0), 1, "limiting max number of connections to %d",
              nactive);
#line 633
      maxconn = nactive;
      }
    }
#line 635
    return (0);
  }
#line 638
  tmp___1 = h->cpp;
#line 638
  (h->cpp) ++;
#line 638
  pp = tmp___1;
#line 639
  chost = h->next;
#line 639
  if (! chost) {
#line 640
    chost = hosts;
  }
#line 641
  ntodo --;
#line 643
  if (baddr.sin_addr.s_addr) {
    {
#line 643
    tmp___4 = bind(fd, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& baddr)),
                   (socklen_t )sizeof(baddr));
    }
#line 643
    if (tmp___4 < 0) {
      {
#line 645
      tmp___2 = inet_ntoa(baddr.sin_addr);
#line 645
      tmp___3 = __errno_location();
#line 645
      err(*tmp___3, "unable to bind to %s", tmp___2);
      }
    }
  }
  {
#line 646
  tmp___6 = fcntl(fd, 4, 2050);
  }
#line 646
  if (tmp___6 < 0) {
    {
#line 648
    tmp___5 = __errno_location();
#line 648
    err(*tmp___5, "unable to set socket flags");
    }
  }
  {
#line 650
  c = pxynew();
  }
#line 651
  if (! c) {
    {
#line 652
    abort();
    }
  }
  {
#line 654
  c->pxyaddr = h->addr;
#line 655
  c->pxyport = pp->port;
#line 656
  c->proto = pp->proto;
#line 657
  c->dstaddr = dstaddr;
#line 658
  c->dstport = dstport;
#line 659
  c->data = (void *)h;
#line 661
  (h->nactive) ++;
#line 661
  nactive ++;
#line 666
  tmp___8 = pxystart(c, fd);
  }
#line 666
  if (! tmp___8) {
    {
#line 667
    tmp___7 = __errno_location();
#line 667
    err(*tmp___7, "unable to enqueue testing request");
    }
  }
  {
#line 669
  sin.sin_family = (sa_family_t )2;
#line 670
  sin.sin_addr = h->addr;
#line 671
  sin.sin_port = htons(pp->port);
#line 672
  tmp___9 = connect(fd, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& sin)),
                    (socklen_t )sizeof(sin));
  }
#line 672
  if (tmp___9 != 0) {
    {
#line 672
    tmp___10 = __errno_location();
    }
#line 672
    if (*tmp___10 != 115) {
      {
#line 674
      pxyaction(c, -1);
      }
    }
  }
#line 676
  return (1);
}
}
#line 679 "/home/wheatley/newnew/temp/proxycheck-0.49a/proxycheck.c"
static void freeconn(pxyconn_t *c ) 
{ 
  int fd ;
  pxyhost_t *h ;
  int skip ;
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 681
  fd = c->fd;
#line 682
  h = (pxyhost_t *)c->data;
#line 683
  nread += (long )c->nread;
#line 684
  (h->nactive) --;
#line 685
  nactive --;
#line 686
  pxyinfo((pxyconn_t const   *)c, 5, "done, nactive=%d ntodo=%d", nactive, ntodo);
#line 687
  pxyfree(c);
#line 688
  close(fd);
  }
#line 689
  if (stopfound) {
#line 689
    if (h->nopen) {
#line 689
      if ((h->cpp)->port) {
#line 697
        skip = 0;
        {
#line 698
        while (1) {
          while_continue: /* CIL Label */ ;
#line 699
          (h->cpp) ++;
#line 700
          skip ++;
#line 698
          if (! (h->cpp)->port) {
#line 698
            goto while_break;
          }
        }
        while_break: /* CIL Label */ ;
        }
        {
#line 702
        ntodo -= skip;
#line 703
        tmp = inet_ntoa(h->addr);
#line 703
        pxyinfo((pxyconn_t const   *)((void *)0), 3, "%s: skipping %d other probes for this host (%d active)",
                tmp, skip, h->nactive);
        }
      }
    }
  }
#line 706
  if (! h->nactive) {
#line 706
    if (! (h->cpp)->port) {
      {
#line 707
      donehost(h);
      }
    }
  }
  {
#line 708
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 708
    tmp___0 = nextconn();
    }
#line 708
    if (! tmp___0) {
#line 708
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 710
  return;
}
}
#line 712 "/home/wheatley/newnew/temp/proxycheck-0.49a/proxycheck.c"
static void isopen(pxyconn_t *c , int is_open , char const   *info ) 
{ 
  pxyhost_t *h ;
  char buf[8192] ;
  int l ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 714
  h = (pxyhost_t *)c->data;
#line 715
  if (is_open) {
#line 715
    goto _L;
  } else
#line 715
  if (printclosed) {
    _L: /* CIL Label */ 
    {
#line 717
    tmp = inet_ntoa(c->pxyaddr);
#line 717
    tmp___0 = sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%s %s:%d ",
                      tmp, (c->proto)->aname, (int )c->pxyport);
#line 717
    l = tmp___0;
    }
#line 719
    if (is_open) {
      {
#line 720
      tmp___1 = sprintf((char */* __restrict  */)(buf + l), (char const   */* __restrict  */)"open");
#line 720
      l += tmp___1;
      }
#line 721
      if (info) {
        {
#line 722
        tmp___2 = sprintf((char */* __restrict  */)(buf + l), (char const   */* __restrict  */)" %s",
                          info);
#line 722
        l += tmp___2;
        }
      }
    } else {
      {
#line 725
      tmp___3 = sprintf((char */* __restrict  */)(buf + l), (char const   */* __restrict  */)"closed");
#line 725
      l += tmp___3;
      }
    }
#line 726
    if (extinfo) {
#line 726
      if (c->detail) {
        {
#line 727
        tmp___4 = sprintf((char */* __restrict  */)(buf + l), (char const   */* __restrict  */)" [%s]",
                          c->detail);
#line 727
        l += tmp___4;
        }
      }
    }
    {
#line 728
    tmp___5 = l;
#line 728
    l ++;
#line 728
    buf[tmp___5] = (char )'\n';
#line 729
    write(1, (void const   *)(buf), (size_t )l);
    }
  }
#line 731
  if (is_open) {
#line 732
    tmp___6 = h->nopen;
#line 732
    (h->nopen) ++;
#line 732
    if (! tmp___6) {
#line 733
      nhopen ++;
    }
#line 734
    npopen ++;
  }
  {
#line 736
  freeconn(c);
  }
#line 737
  return;
}
}
#line 739 "/home/wheatley/newnew/temp/proxycheck-0.49a/proxycheck.c"
void pxyaction(pxyconn_t *c , int result ) 
{ 
  int tmp ;
  int *tmp___1 ;
  char *tmp___2 ;
  char const   *tmp___3 ;
  int *tmp___4 ;
  char const   *tmp___5 ;
  int tmp___6 ;

  {
#line 740
  if (! result) {
    {
#line 741
    tmp = pxyreqiot(c, 1, (void (*)(pxyconn_t * , int  ))check->connh, 0, (void (*)(pxyconn_t * ))((void *)0));
    }
#line 741
    if (tmp) {
      {
#line 742
      (*(check->connh))(c, 1);
      }
    }
  } else {
#line 745
    if (result < 0) {
      {
#line 746
      tmp___4 = __errno_location();
      }
#line 746
      if (*tmp___4) {
        {
#line 746
        tmp___1 = __errno_location();
#line 746
        tmp___2 = strerror(*tmp___1);
#line 746
        tmp___3 = (char const   *)tmp___2;
        }
      } else {
#line 746
        tmp___3 = "EOF";
      }
#line 746
      if (c->pxystate) {
#line 746
        tmp___5 = "%s";
      } else {
#line 746
        tmp___5 = "connect: %s";
      }
#line 746
      if (c->pxystate) {
#line 746
        tmp___6 = 3;
      } else {
#line 746
        tmp___6 = 4;
      }
      {
#line 746
      pxyinfo((pxyconn_t const   *)c, tmp___6, tmp___5, tmp___3);
      }
    } else
#line 748
    if (result > 1) {
      {
#line 749
      isopen(c, 0, (char const   *)((void *)0));
      }
#line 750
      return;
    }
    {
#line 754
    freeconn(c);
    }
  }
#line 756
  return;
}
}
#line 758 "/home/wheatley/newnew/temp/proxycheck-0.49a/proxycheck.c"
void pxycheckdata(pxyconn_t *c ) 
{ 
  int tmp ;

  {
  {
#line 759
  tmp = pxyreqio(c, 1, (void (*)(pxyconn_t * , int  ))check->exph);
  }
#line 759
  if (tmp) {
    {
#line 760
    (*(check->exph))(c, 1);
    }
  }
#line 761
  return;
}
}
#line 763 "/home/wheatley/newnew/temp/proxycheck-0.49a/proxycheck.c"
int pxygetdata(pxyconn_t *c ) 
{ 
  int tmp ;

  {
  {
#line 764
  tmp = (*(check->getdata))(c);
  }
#line 764
  return (tmp);
}
}
#line 766 "/home/wheatley/newnew/temp/proxycheck-0.49a/proxycheck.c"
int main(int argc , char **argv ) 
{ 
  time_t start ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  time_t tmp___5 ;
  int tmp___6 ;

  {
  {
#line 769
  init(argc, argv);
#line 770
  tmp___0 = ev_init(0, 29);
  }
#line 770
  if (tmp___0 != 0) {
    {
#line 771
    tmp = __errno_location();
#line 771
    err(*tmp, "ev_init");
    }
  }
  {
#line 773
  start = time((time_t *)((void *)0));
  }
  {
#line 775
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 775
    tmp___1 = nextconn();
    }
#line 775
    if (! tmp___1) {
#line 775
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 778
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 778
    if (! nactive) {
#line 778
      goto while_break___0;
    }
    {
#line 779
    tmp___3 = ev_wait((struct ev_ct *)0, -1);
    }
#line 779
    if (tmp___3 < 0) {
      {
#line 779
      tmp___4 = __errno_location();
      }
#line 779
      if (*tmp___4 != 4) {
        {
#line 780
        tmp___2 = __errno_location();
#line 780
        err(*tmp___2, "ev_wait");
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 782
  tmp___5 = time((time_t *)((void *)0));
#line 782
  pxyinfo((pxyconn_t const   *)((void *)0), 1, "NumOpen=%d(%d) NRead=%ld Time=%d",
          nhopen, npopen, nread, (int )(tmp___5 - start));
  }
#line 785
  if (nhopen) {
#line 785
    tmp___6 = 100;
  } else {
#line 785
    tmp___6 = 0;
  }
#line 785
  return (tmp___6);
}
}
#line 788 "/home/wheatley/newnew/temp/proxycheck-0.49a/proxycheck.c"
static char *findip(pxyconn_t *c , char *buf ) 
{ 
  unsigned int o1 ;
  unsigned int o2 ;
  unsigned int o3 ;
  unsigned int o4 ;
  int l ;
  int tmp ;
  uint32_t tmp___0 ;

  {
  {
#line 792
  while (1) {
    while_continue: /* CIL Label */ ;
#line 792
    if ((int )*buf >= 32) {
#line 792
      if (! ((int )*buf != 91)) {
#line 792
        goto while_break;
      }
    } else {
#line 792
      goto while_break;
    }
#line 792
    buf ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 793
  if ((int )*buf == 91) {
    {
#line 793
    buf ++;
#line 793
    tmp = sscanf((char const   */* __restrict  */)buf, (char const   */* __restrict  */)"%3u.%3u.%3u.%3u%n]",
                 & o1, & o2, & o3, & o4, & l);
    }
#line 793
    if (tmp == 4) {
#line 793
      if (o1) {
#line 793
        if (o1 < 256U) {
#line 793
          if (o2 < 256U) {
#line 793
            if (o3 < 256U) {
#line 793
              if (o4 < 256U) {
                {
#line 793
                tmp___0 = ntohl(c->pxyaddr.s_addr);
                }
#line 793
                if (((((o1 << 24) | (o2 << 16)) | (o3 << 8)) | o4) != tmp___0) {
#line 797
                  *(buf + l) = (char )'\000';
#line 798
                  return (buf);
                }
              }
            }
          }
        }
      }
    }
  }
#line 800
  return ((char *)((void *)0));
}
}
#line 803 "/home/wheatley/newnew/temp/proxycheck-0.49a/proxycheck.c"
static char *sendstr  ;
#line 804 "/home/wheatley/newnew/temp/proxycheck-0.49a/proxycheck.c"
static char *expstr  ;
#line 805 "/home/wheatley/newnew/temp/proxycheck-0.49a/proxycheck.c"
static unsigned int explen  ;
#line 807 "/home/wheatley/newnew/temp/proxycheck-0.49a/proxycheck.c"
static int expectd(pxyconn_t *c ) 
{ 
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 808
  if (sendstr) {
    {
#line 808
    tmp = sprintf((char */* __restrict  */)(pxybuf), (char const   */* __restrict  */)"%s\r\n",
                  sendstr);
#line 808
    tmp___2 = tmp;
    }
  } else {
    {
#line 808
    tmp___0 = inet_ntoa(c->pxyaddr);
#line 808
    tmp___1 = sprintf((char */* __restrict  */)(pxybuf), (char const   */* __restrict  */)"%s:%s:%d\r\n",
                      (c->proto)->aname, tmp___0, (int )c->pxyport);
#line 808
    tmp___2 = tmp___1;
    }
  }
#line 808
  return (tmp___2);
}
}
#line 814 "/home/wheatley/newnew/temp/proxycheck-0.49a/proxycheck.c"
static void expectw(pxyconn_t *c , int e  __attribute__((__unused__)) ) 
{ 
  int l ;
  char *p ;
  char *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 818
  tmp___2 = pxyreadnext(c, 1, & l, 3);
  }
#line 818
  if (! (tmp___2 <= 0)) {
#line 820
    if ((c->proto)->check) {
      {
#line 820
      tmp___1 = (*((c->proto)->check))(c, pxybuf, l);
      }
#line 820
      if (tmp___1) {
#line 820
        return;
      } else {
#line 820
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 821
      tmp___0 = memmem((void const   *)(pxybuf), (size_t )l, (void const   *)expstr,
                       (size_t )explen);
#line 821
      p = (char *)tmp___0;
      }
#line 821
      if ((unsigned long )p != (unsigned long )((void *)0)) {
        {
#line 823
        tmp = findip(c, p + explen);
#line 823
        isopen(c, 1, (char const   *)tmp);
        }
      } else {
        {
#line 825
        pxysave(c, pxybuf, (unsigned int )l, explen);
        }
      }
    }
  }
#line 826
  return;
}
}
#line 828 "/home/wheatley/newnew/temp/proxycheck-0.49a/proxycheck.c"
static void expecth(pxyconn_t *c , int e  __attribute__((__unused__)) ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 830
  tmp = expectd(c);
#line 830
  tmp___0 = pxywrite(c, (char const   *)(pxybuf), tmp, 3);
  }
#line 830
  if (tmp___0) {
    {
#line 831
    pxyreqio(c, 1, & expectw);
    }
  }
#line 832
  return;
}
}
#line 834 "/home/wheatley/newnew/temp/proxycheck-0.49a/proxycheck.c"
static int expecti(char *arg ) 
{ 
  char *p ;
  char *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 835
  tmp = strchr((char const   *)arg, ':');
#line 835
  p = tmp;
  }
#line 836
  if (! p) {
    {
#line 837
    usage("send:expect strings expected");
    }
  } else
#line 836
  if (! *(p + 1)) {
    {
#line 837
    usage("send:expect strings expected");
    }
  }
#line 838
  if ((unsigned long )p != (unsigned long )arg) {
#line 839
    sendstr = arg;
#line 840
    tmp___0 = p;
#line 840
    p ++;
#line 840
    *tmp___0 = (char )'\000';
#line 841
    arg = p;
  } else {
#line 844
    arg ++;
  }
#line 845
  expstr = arg;
#line 845
  if (expstr) {
    {
#line 845
    tmp___1 = strlen((char const   *)arg);
#line 845
    explen = (unsigned int )tmp___1;
    }
#line 845
    if (explen) {
#line 847
      if ((unsigned long )explen >= sizeof(((pxybuf_t *)0)->buf)) {
        {
#line 848
        usage("expect string is too long");
        }
      }
    } else {
      {
#line 846
      usage("specify a string to expect");
      }
    }
  } else {
    {
#line 846
    usage("specify a string to expect");
    }
  }
#line 849
  return (0);
}
}
#line 854 "/home/wheatley/newnew/temp/proxycheck-0.49a/proxycheck.c"
static char dsblcookie[33]  ;
#line 855 "/home/wheatley/newnew/temp/proxycheck-0.49a/proxycheck.c"
static char *dsbluser  ;
#line 855 "/home/wheatley/newnew/temp/proxycheck-0.49a/proxycheck.c"
static char *dsblpass  ;
#line 855 "/home/wheatley/newnew/temp/proxycheck-0.49a/proxycheck.c"
static char *dsblrcpt  ;
#line 855 "/home/wheatley/newnew/temp/proxycheck-0.49a/proxycheck.c"
static char *dsblfrom  ;
#line 857 "/home/wheatley/newnew/temp/proxycheck-0.49a/proxycheck.c"
static int dsblmsg(char *buf , pxyconn_t *c ) 
{ 
  char pxyaddr[sizeof("255.255.255.255")] ;
  int l ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 860
  tmp = inet_ntoa(c->pxyaddr);
#line 860
  strcpy((char */* __restrict  */)(pxyaddr), (char const   */* __restrict  */)tmp);
#line 861
  tmp___0 = inet_ntoa(c->dstaddr);
#line 861
  l = sprintf((char */* __restrict  */)buf, (char const   */* __restrict  */)"Message-ID: <%s@%s>\r\nTo: <%s>\r\nSubject: Open %s Proxy test message\r\n\r\nDSBL LISTME: %s [%s]:%d\r\n%s\r\nConnect to %s:%d\r\n",
              dsblcookie, dsblfrom, dsblrcpt, (c->proto)->fullname, (c->proto)->name,
              pxyaddr, (int )c->pxyport, dsblcookie, tmp___0, (int )c->dstport);
  }
#line 875
  if (c->detail) {
    {
#line 876
    tmp___1 = sprintf((char */* __restrict  */)(buf + l), (char const   */* __restrict  */)"Proxy info: %s\r\n",
                      c->detail);
#line 876
    l += tmp___1;
    }
  }
  {
#line 877
  tmp___2 = sprintf((char */* __restrict  */)(buf + l), (char const   */* __restrict  */)"DSBL END\r\n\r\n.\r\n");
#line 877
  l += tmp___2;
  }
#line 878
  return (l);
}
}
#line 881 "/home/wheatley/newnew/temp/proxycheck-0.49a/proxycheck.c"
static int dsbld(pxyconn_t *c ) 
{ 
  int l ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 882
  tmp = inet_ntoa(c->pxyaddr);
#line 882
  tmp___0 = sprintf((char */* __restrict  */)(pxybuf), (char const   */* __restrict  */)"HELO [%s]\r\nMAIL FROM:<%s>\r\nRCPT TO:<%s>\r\nDATA\r\n",
                    tmp, dsblfrom, dsblrcpt);
#line 882
  l = tmp___0;
#line 890
  tmp___1 = dsblmsg(pxybuf + l, c);
#line 890
  l += tmp___1;
#line 891
  tmp___2 = sprintf((char */* __restrict  */)(pxybuf + l), (char const   */* __restrict  */)"QUIT\r\n");
#line 891
  l += tmp___2;
  }
#line 892
  return (l);
}
}
#line 895 "/home/wheatley/newnew/temp/proxycheck-0.49a/proxycheck.c"
static void dsblo(pxyconn_t *c , char *line ) 
{ 
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 897
  tmp___2 = memcmp((void const   *)line, (void const   *)"250 listed [", (size_t )12);
  }
#line 897
  if (tmp___2) {
#line 897
    tmp___1 = (char *)((void *)0);
  } else {
    {
#line 897
    tmp___0 = findip(c, line + 11);
#line 897
    tmp___1 = tmp___0;
    }
  }
  {
#line 897
  isopen(c, 1, (char const   *)tmp___1);
  }
#line 898
  return;
}
}
#line 900 "/home/wheatley/newnew/temp/proxycheck-0.49a/proxycheck.c"
static void dsble(pxyconn_t *c , int e  __attribute__((__unused__)) ) 
{ 
  int l ;
  char *s ;
  int tmp ;
  int tmp___0 ;
  char *n ;
  char const   *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 911
  tmp = pxyreadnext(c, 1, & l, 3);
  }
#line 911
  if (tmp <= 0) {
#line 911
    return;
  }
#line 912
  if ((c->proto)->check) {
    {
#line 912
    tmp___0 = (*((c->proto)->check))(c, pxybuf, l);
    }
#line 912
    if (tmp___0) {
#line 912
      return;
    }
  }
#line 913
  s = pxybuf;
  {
#line 914
  while (1) {
    while_continue: /* CIL Label */ ;
#line 915
    if (c->appstate == 3) {
#line 915
      tmp___1 = "\r\n3";
    } else {
#line 915
      tmp___1 = "\r\n2";
    }
    {
#line 915
    tmp___2 = memmem((void const   *)s, (size_t )l, (void const   *)tmp___1, (size_t )3);
#line 915
    n = (char *)tmp___2;
    }
#line 916
    if (! n) {
#line 916
      goto while_break;
    }
#line 917
    n += 2;
#line 918
    l = (int )((long )l - (n - s));
#line 919
    s = n;
#line 920
    tmp___3 = c->appstate;
#line 920
    (c->appstate) ++;
#line 920
    if (tmp___3 == 4) {
      {
#line 921
      dsblo(c, n);
      }
#line 922
      return;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 925
  pxysave(c, s, (unsigned int )l, 0U);
  }
#line 926
  return;
}
}
#line 928 "/home/wheatley/newnew/temp/proxycheck-0.49a/proxycheck.c"
static void dsblh(pxyconn_t *c , int e  __attribute__((__unused__)) ) 
{ 
  int l ;
  char *p ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  void *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  void *tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;

  {
  {
#line 942
  if (c->appstate == 0) {
#line 942
    goto case_0;
  }
#line 949
  if (c->appstate == 3) {
#line 949
    goto case_3;
  }
#line 949
  if (c->appstate == 2) {
#line 949
    goto case_3;
  }
#line 949
  if (c->appstate == 1) {
#line 949
    goto case_3;
  }
#line 966
  if (c->appstate == 4) {
#line 966
    goto case_4;
  }
#line 980
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 943
  tmp = inet_ntoa(c->pxyaddr);
#line 943
  tmp___0 = pxyprintf(c, 3, "HELO [%s]\r\n", tmp);
  }
#line 943
  if (tmp___0) {
#line 944
    c->appstate = 1;
  }
#line 945
  goto switch_break;
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 950
  tmp___10 = pxyreadnext(c, 1, & l, 3);
  }
#line 950
  if (! (tmp___10 <= 0)) {
    {
#line 952
    tmp___9 = memmem((void const   *)(pxybuf), (size_t )l, (void const   *)"\r\n2",
                     (size_t )3);
#line 952
    p = (char *)tmp___9;
    }
#line 952
    if (p) {
#line 953
      if (c->appstate == 1) {
        {
#line 953
        tmp___1 = sprintf((char */* __restrict  */)(pxybuf), (char const   */* __restrict  */)"MAIL FROM:<%s>\r\n",
                          dsblfrom);
#line 953
        l = tmp___1;
        }
      } else {
#line 953
        if (c->appstate == 2) {
          {
#line 953
          tmp___2 = sprintf((char */* __restrict  */)(pxybuf), (char const   */* __restrict  */)"RCPT TO:<%s>\r\n",
                            dsblrcpt);
#line 953
          tmp___4 = tmp___2;
          }
        } else {
          {
#line 953
          tmp___3 = sprintf((char */* __restrict  */)(pxybuf), (char const   */* __restrict  */)"DATA\r\n");
#line 953
          tmp___4 = tmp___3;
          }
        }
#line 953
        l = tmp___4;
      }
      {
#line 956
      tmp___5 = pxysave(c, pxybuf, (unsigned int )l, 10U);
      }
#line 956
      if (tmp___5) {
        {
#line 956
        tmp___6 = pxywrite(c, (char const   *)(pxybuf), l, 3);
        }
#line 956
        if (tmp___6) {
          {
#line 956
          tmp___7 = pxyrenew(c, pxytimeout / 2, (void (*)(pxyconn_t * ))((void *)0));
          }
#line 956
          if (tmp___7) {
#line 959
            (c->appstate) ++;
          }
        }
      }
    } else
#line 961
    if (c->appstate != 1) {
      {
#line 963
      pxysave(c, pxybuf, (unsigned int )l, 10U);
      }
    } else
#line 961
    if (! (c->proto)->check) {
      {
#line 963
      pxysave(c, pxybuf, (unsigned int )l, 10U);
      }
    } else {
      {
#line 961
      tmp___8 = (*((c->proto)->check))(c, pxybuf, l);
      }
#line 961
      if (! tmp___8) {
        {
#line 963
        pxysave(c, pxybuf, (unsigned int )l, 10U);
        }
      }
    }
  }
#line 964
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 967
  tmp___17 = pxyreadnext(c, 1, & l, 3);
  }
#line 967
  if (! (tmp___17 <= 0)) {
    {
#line 969
    tmp___16 = memmem((void const   *)(pxybuf), (size_t )l, (void const   *)"\r\n3",
                      (size_t )3);
#line 969
    p = (char *)tmp___16;
    }
#line 969
    if (p) {
#line 970
      if (verbose < 6) {
        {
#line 970
        pxyinfo((pxyconn_t const   *)c, 2, "sending message");
        }
      }
      {
#line 971
      tmp___11 = dsblmsg(pxybuf, c);
#line 971
      tmp___12 = pxywrite(c, (char const   *)(pxybuf), tmp___11, 6);
      }
#line 971
      if (tmp___12) {
        {
#line 971
        tmp___13 = pxywrite(c, "QUIT\r\n", 6, 3);
        }
#line 971
        if (tmp___13) {
          {
#line 971
          tmp___14 = pxysave(c, (char *)((void *)0), 0U, 0U);
          }
#line 971
          if (tmp___14) {
            {
#line 971
            tmp___15 = pxyrenew(c, 0, (void (*)(pxyconn_t * ))((void *)0));
            }
#line 971
            if (tmp___15) {
#line 974
              c->appstate = 5;
            }
          }
        }
      }
    } else {
      {
#line 977
      pxysave(c, pxybuf, (unsigned int )l, 10U);
      }
    }
  }
#line 978
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 981
  tmp___18 = pxyreadnext(c, 1, & l, 3);
  }
#line 981
  if (! (tmp___18 <= 0)) {
#line 983
    if ((int )pxybuf[0] == 50) {
#line 983
      if ((int )pxybuf[3] == 32) {
        {
#line 984
        dsblo(c, pxybuf);
        }
      } else {
        {
#line 986
        pxysave(c, pxybuf, (unsigned int )l, 10U);
        }
      }
    } else {
      {
#line 986
      pxysave(c, pxybuf, (unsigned int )l, 10U);
      }
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 988
  return;
}
}
#line 990 "/home/wheatley/newnew/temp/proxycheck-0.49a/proxycheck.c"
static char *egetenv(char const   *name , char *def ) 
{ 
  char *v ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 991
  tmp = getenv(name);
#line 991
  v = tmp;
  }
#line 992
  if (v) {
#line 992
    tmp___0 = v;
  } else {
#line 992
    tmp___0 = def;
  }
#line 992
  return (tmp___0);
}
}
#line 995 "/home/wheatley/newnew/temp/proxycheck-0.49a/proxycheck.c"
static void dsbl_cookie_alarm(int sig  __attribute__((__unused__)) ) 
{ 


  {
  {
#line 996
  err(0, "unable to obtain cookie: timeout");
  }
#line 997
  return;
}
}
#line 999 "/home/wheatley/newnew/temp/proxycheck-0.49a/proxycheck.c"
static int dsbli(char *arg ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *chost___0 ;
  char *tmp___1 ;
  struct sockaddr_in sin ;
  int fd ;
  int l ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  ssize_t tmp___6 ;
  ssize_t tmp___7 ;
  size_t tmp___8 ;

  {
#line 1001
  if (! dstspec) {
#line 1002
    if (arg) {
#line 1002
      if (*arg) {
#line 1002
        dstspec = arg;
      } else {
        {
#line 1002
        tmp = egetenv("DSBL_SMTP", (char *)"mx.listme.dsbl.org");
#line 1002
        dstspec = tmp;
        }
      }
    } else {
      {
#line 1002
      tmp = egetenv("DSBL_SMTP", (char *)"mx.listme.dsbl.org");
#line 1002
      dstspec = tmp;
      }
    }
  }
  {
#line 1003
  tmp___0 = strchr((char const   *)dstspec, ':');
  }
#line 1003
  if (! tmp___0) {
    {
#line 1004
    sprintf((char */* __restrict  */)(pxybuf), (char const   */* __restrict  */)"%s:25",
            dstspec);
#line 1005
    dstspec = strdup((char const   *)(pxybuf));
    }
  }
  {
#line 1008
  dsbluser = egetenv("DSBL_USER", (char *)"anonimous");
#line 1009
  dsblpass = egetenv("DSBL_PASS", (char *)"");
#line 1010
  dsblfrom = egetenv("DSBL_FROM", dsbluser);
#line 1011
  dsblrcpt = egetenv("DSBL_RCPT", (char *)"listme@listme.dsbl.org");
#line 1012
  arg = getenv("DSBL_COOKIE");
  }
#line 1012
  if (arg) {
    {
#line 1035
    tmp___8 = strlen((char const   *)arg);
    }
#line 1035
    if (tmp___8 != 32UL) {
      {
#line 1036
      usage("invalid dsbl cookie `%s\'", arg);
      }
    } else {
      {
#line 1038
      strcpy((char */* __restrict  */)(dsblcookie), (char const   */* __restrict  */)arg);
      }
    }
  } else {
    {
#line 1013
    tmp___1 = egetenv("DSBL_COOKIE_HOST", (char *)"cookie.dsbl.org");
#line 1013
    chost___0 = tmp___1;
#line 1018
    sin.sin_family = (sa_family_t )2;
#line 1019
    sin.sin_port = htons((uint16_t )200);
#line 1020
    tmp___2 = hostaddr((char const   *)chost___0, & sin.sin_addr);
    }
#line 1020
    if (! tmp___2) {
      {
#line 1021
      err(0, "unknown DSBL cookie host %s", chost___0);
      }
    }
    {
#line 1022
    signal(14, & dsbl_cookie_alarm);
#line 1023
    alarm(180U);
#line 1024
    fd = socket(2, 1, 6);
    }
#line 1024
    if (fd < 0) {
      {
#line 1026
      tmp___3 = __errno_location();
#line 1026
      err(*tmp___3, "unable to connect to cookie server");
      }
    } else {
      {
#line 1024
      tmp___4 = connect(fd, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& sin)),
                        (socklen_t )sizeof(sin));
      }
#line 1024
      if (tmp___4 < 0) {
        {
#line 1026
        tmp___3 = __errno_location();
#line 1026
        err(*tmp___3, "unable to connect to cookie server");
        }
      }
    }
    {
#line 1027
    l = sprintf((char */* __restrict  */)(pxybuf), (char const   */* __restrict  */)"%s\n%s\n",
                dsbluser, dsblpass);
#line 1028
    tmp___6 = send(fd, (void const   *)(pxybuf), (size_t )l, 0);
    }
#line 1028
    if (tmp___6 < 0L) {
      {
#line 1030
      tmp___5 = __errno_location();
#line 1030
      err(*tmp___5, "unable to obtain cookie");
      }
    } else {
      {
#line 1028
      tmp___7 = recv(fd, (void *)(dsblcookie), (size_t )32, 0);
      }
#line 1028
      if (tmp___7 != 32L) {
        {
#line 1030
        tmp___5 = __errno_location();
#line 1030
        err(*tmp___5, "unable to obtain cookie");
        }
      }
    }
    {
#line 1031
    alarm(0U);
#line 1032
    close(fd);
#line 1033
    dsblcookie[32] = (char)0;
    }
  }
  {
#line 1039
  pxyinfo((pxyconn_t const   *)((void *)0), 4, "dsbl cookie: %s", dsblcookie);
  }
#line 1040
  return (0);
}
}
#line 1043 "/home/wheatley/newnew/temp/proxycheck-0.49a/proxycheck.c"
pxycheck_t const   checks[3]  = {      {(char *)"chat", & expecth, & expectd, & expectw, & expecti, (char *)":sendstr:expectstr",
      (char *)"perform a little chat: send `sendstr\'\n   to the remote system  and assume proxy is open is `expectstr\'\n   is returned.  `sendstr\' defaults to proto:ip:port\n"}, 
        {(char *)"dsbl",
      & dsblh, & dsbld, & dsble, & dsbli, (char *)"[:smtpserver[:port]]", (char *)"attempt to submit proxy to DSBL-like system\n   DSBL settings are expected to be in environment:\n\t$DSBL_USER - username (anonimous)\n\t$DSBL_PASS - password (default is empty)\n\t$DSBL_COOKIE_HOST - cookie server (cookie.dsbl.org)\n\t$DSBL_COOKIE - already obtained DSBL cookie\n\t$DSBL_RCPT - recipient (listme@listme.dsbl.org)\n\t$DSBL_FROM - sender address (nobody)\n\t$DSBL_SMTP - smtp server if -d not given (mx.listme.dsbl.org)\n"}, 
        {(char *)0,
      (void (*)(pxyconn_t *c , int e ))0, (int (*)(pxyconn_t *c ))0, (void (*)(pxyconn_t *c ,
                                                                               int e ))0,
      (int (*)(char *arg ))0, (char *)0, (char *)0}};
#line 360 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 32 "/home/wheatley/newnew/temp/proxycheck-0.49a/pxy.h"
char pxybuf[8193]  ;
#line 105
int pxyread(pxyconn_t *c , char *buf , int l , int minlen , int level ) ;
#line 20 "/home/wheatley/newnew/temp/proxycheck-0.49a/pxy.c"
int pxytimeout  =    30000;
#line 23 "/home/wheatley/newnew/temp/proxycheck-0.49a/pxy.c"
static void timedout(pxyconn_t *c ) 
{ 
  int *tmp ;

  {
  {
#line 25
  tmp = __errno_location();
#line 25
  *tmp = 110;
#line 26
  pxyaction(c, -1);
  }
#line 27
  return;
}
}
#line 29 "/home/wheatley/newnew/temp/proxycheck-0.49a/pxy.c"
int pxyrenew(pxyconn_t *c , int tmo , void (*tmfn)(pxyconn_t * ) ) 
{ 
  int tmp ;
  struct ev_tm *tmp___0 ;

  {
#line 30
  if (! tmfn) {
#line 30
    tmfn = & timedout;
  }
  {
#line 31
  ev_tm_del((struct ev_ct *)0, & c->timer);
  }
#line 32
  if (tmo) {
#line 32
    tmp = tmo;
  } else {
#line 32
    tmp = pxytimeout;
  }
  {
#line 32
  tmp___0 = ev_tm_add((struct ev_ct *)0, & c->timer, tmp, (ev_tm_cbck_f *)tmfn, (void *)c);
  }
#line 32
  if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 33
    return (1);
  } else {
    {
#line 35
    pxyaction(c, -1);
    }
#line 36
    return (0);
  }
}
}
#line 40 "/home/wheatley/newnew/temp/proxycheck-0.49a/pxy.c"
pxyconn_t *pxynew(void) 
{ 
  pxyconn_t *c ;
  void *tmp ;

  {
  {
#line 41
  tmp = malloc(sizeof(pxyconn_t ));
#line 41
  c = (pxyconn_t *)tmp;
  }
#line 42
  if (c) {
    {
#line 43
    memset((void *)c, 0, sizeof(*c));
    }
  }
#line 44
  return (c);
}
}
#line 47 "/home/wheatley/newnew/temp/proxycheck-0.49a/pxy.c"
void pxyfree(pxyconn_t *c ) 
{ 


  {
  {
#line 48
  ev_tm_del((struct ev_ct *)0, & c->timer);
  }
#line 49
  if (c->fd >= 0) {
    {
#line 50
    ev_io_del((struct ev_ct *)0, c->fd);
    }
  }
#line 51
  if (c->detail) {
    {
#line 52
    free((void *)c->detail);
    }
  }
#line 53
  if (c->buf) {
    {
#line 54
    free((void *)c->buf);
#line 55
    c->buf = (pxybuf_t *)((void *)0);
    }
  }
  {
#line 57
  free((void *)c);
  }
#line 58
  return;
}
}
#line 60 "/home/wheatley/newnew/temp/proxycheck-0.49a/pxy.c"
int pxyreqio(pxyconn_t *c , int e , void (*iofn)(pxyconn_t * , int  ) ) 
{ 
  int tmp ;

  {
  {
#line 62
  tmp = ev_io_mod((struct ev_ct *)0, c->fd, e, (ev_io_cbck_f *)iofn, (void *)c);
  }
#line 62
  if (tmp == 0) {
#line 63
    return (1);
  } else {
    {
#line 65
    pxyaction(c, -1);
    }
#line 66
    return (0);
  }
}
}
#line 70 "/home/wheatley/newnew/temp/proxycheck-0.49a/pxy.c"
int pxyreqiot(pxyconn_t *c , int e , void (*iofn)(pxyconn_t * , int  ) , int tmo ,
              void (*tmfn)(pxyconn_t * ) ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 73
  tmp = pxyreqio(c, e, iofn);
  }
#line 73
  if (tmp) {
    {
#line 73
    tmp___0 = pxyrenew(c, tmo, tmfn);
    }
#line 73
    if (tmp___0) {
#line 73
      tmp___1 = 1;
    } else {
#line 73
      tmp___1 = 0;
    }
  } else {
#line 73
    tmp___1 = 0;
  }
#line 73
  return (tmp___1);
}
}
#line 76 "/home/wheatley/newnew/temp/proxycheck-0.49a/pxy.c"
int pxywrite(pxyconn_t *c , char const   *buf , int len , int level ) 
{ 
  int r ;
  int tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 78
  tmp___0 = write(c->fd, (void const   *)buf, (size_t )len);
#line 78
  r = (int )tmp___0;
  }
#line 78
  if (r <= 0) {
#line 79
    if (r < 0) {
#line 79
      tmp = -1;
    } else {
#line 79
      tmp = 1;
    }
    {
#line 79
    pxyaction(c, tmp);
    }
#line 80
    return (0);
  } else {
    {
#line 83
    pxyvio(c, level, 1, buf, len);
    }
#line 84
    return (1);
  }
}
}
#line 88 "/home/wheatley/newnew/temp/proxycheck-0.49a/pxy.c"
int ( /* format attribute */  pxyprintf)(pxyconn_t *c , int loglevel , char const   *fmt 
                                         , ...) 
{ 
  va_list ap ;
  int l ;
  int tmp ;

  {
  {
#line 91
  __builtin_va_start(ap, fmt);
#line 92
  l = vsprintf((char */* __restrict  */)(pxybuf), (char const   */* __restrict  */)fmt,
               ap);
#line 93
  __builtin_va_end(ap);
#line 94
  tmp = pxywrite(c, (char const   *)(pxybuf), l, loglevel);
  }
#line 94
  return (tmp);
}
}
#line 97 "/home/wheatley/newnew/temp/proxycheck-0.49a/pxy.c"
int pxystart(pxyconn_t *c , int fd ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 98
  c->fd = fd;
#line 99
  tmp___0 = ev_io_add((struct ev_ct *)0, fd, 4, (ev_io_cbck_f *)(c->proto)->handler,
                      (void *)c);
  }
#line 99
  if (tmp___0 != 0) {
    {
#line 100
    pxyaction(c, -1);
    }
#line 101
    return (0);
  } else {
    {
#line 104
    tmp = pxyrenew(c, pxytimeout / 2, (void (*)(pxyconn_t * ))((void *)0));
    }
#line 104
    return (tmp);
  }
}
}
#line 107 "/home/wheatley/newnew/temp/proxycheck-0.49a/pxy.c"
int pxyread(pxyconn_t *c , char *buf , int l , int minlen , int level ) 
{ 
  ssize_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 108
  tmp = read(c->fd, (void *)buf, (size_t )l);
#line 108
  l = (int )tmp;
  }
#line 109
  if (l > 0) {
    {
#line 110
    pxyvio(c, level, 0, (char const   *)buf, l);
#line 111
    c->nread += l;
    }
  } else
#line 113
  if (l < 0) {
#line 114
    if (minlen) {
      {
#line 115
      pxyaction(c, -1);
      }
#line 116
      return (-1);
    } else {
      {
#line 114
      tmp___0 = __errno_location();
      }
#line 114
      if (*tmp___0 != 11) {
        {
#line 115
        pxyaction(c, -1);
        }
#line 116
        return (-1);
      } else {
#line 119
        l = 0;
      }
    }
  } else {
    {
#line 122
    tmp___1 = __errno_location();
#line 122
    *tmp___1 = 0;
#line 123
    pxyaction(c, -1);
    }
#line 124
    return (-1);
  }
#line 126
  *(buf + l) = (char )'\000';
#line 127
  return (l);
}
}
#line 130 "/home/wheatley/newnew/temp/proxycheck-0.49a/pxy.c"
int pxyreadnext(pxyconn_t *c , int minlen , int *tlen , int loglevel ) 
{ 
  int l ;
  int r ;

  {
#line 132
  if (c->buf) {
#line 132
    l = (int )(c->buf)->len;
#line 132
    if (l != 0) {
      {
#line 133
      memcpy((void */* __restrict  */)(pxybuf), (void const   */* __restrict  */)((c->buf)->buf),
             (size_t )l);
      }
    } else {
#line 135
      l = 0;
    }
  } else {
#line 135
    l = 0;
  }
  {
#line 136
  r = pxyread(c, pxybuf + l, (int )((sizeof(pxybuf) - (unsigned long )l) - 1UL), minlen,
              loglevel);
  }
#line 137
  if (r >= 0) {
#line 137
    if (tlen) {
#line 138
      *tlen = r + l;
    }
  }
#line 139
  return (r);
}
}
#line 142 "/home/wheatley/newnew/temp/proxycheck-0.49a/pxy.c"
int pxysave(pxyconn_t *c , char *buf , unsigned int len , unsigned int max ) 
{ 
  int *tmp ;
  pxybuf_t *tmp___0 ;
  void *tmp___1 ;

  {
#line 143
  if (c->nread > 2048) {
    {
#line 144
    pxyinfo((pxyconn_t const   *)c, 2, "too much input");
#line 145
    pxyaction(c, 2);
    }
#line 146
    return (0);
  }
#line 148
  if (buf) {
#line 148
    if (len > 0U) {
#line 149
      if (! c->buf) {
        {
#line 149
        tmp___1 = malloc(sizeof(pxybuf_t ));
#line 149
        tmp___0 = (pxybuf_t *)tmp___1;
#line 149
        c->buf = tmp___0;
        }
#line 149
        if (! tmp___0) {
          {
#line 150
          tmp = __errno_location();
#line 150
          *tmp = 12;
#line 151
          pxyaction(c, -1);
          }
#line 152
          return (0);
        }
      }
#line 154
      if ((unsigned long )len > sizeof((c->buf)->buf)) {
#line 155
        buf += (unsigned long )len - sizeof((c->buf)->buf);
#line 156
        len = (unsigned int )sizeof((c->buf)->buf);
      }
#line 158
      if (max) {
#line 158
        if (len > max) {
#line 159
          buf += len - max;
#line 160
          len = max;
        }
      }
      {
#line 162
      memcpy((void */* __restrict  */)((c->buf)->buf), (void const   */* __restrict  */)buf,
             (size_t )len);
#line 163
      (c->buf)->len = len;
      }
    } else {
#line 148
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 165
  if (c->buf) {
#line 166
    (c->buf)->len = 0U;
  }
#line 167
  return (1);
}
}
#line 172 "/home/wheatley/newnew/temp/proxycheck-0.49a/pxy.c"
char *memcfind(char const   *buf , int l , char const   *str ) 
{ 
  char const   *s ;
  char const   *b ;
  char const   *e ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 174
  tmp = strlen(str);
#line 174
  e = (buf + l) - tmp;
  }
  {
#line 174
  while (1) {
    while_continue: /* CIL Label */ ;
#line 174
    if (! ((unsigned long )buf <= (unsigned long )e)) {
#line 174
      goto while_break;
    }
#line 176
    if ((int const   )*buf >= 65) {
#line 176
      if ((int const   )*buf <= 90) {
#line 176
        tmp___0 = ((int const   )*buf - 65) + 97;
      } else {
#line 176
        tmp___0 = (int const   )*buf;
      }
    } else {
#line 176
      tmp___0 = (int const   )*buf;
    }
#line 176
    if (tmp___0 != (int const   )*str) {
#line 176
      goto __Cont;
    }
#line 177
    s = str + 1;
#line 177
    b = buf + 1;
    {
#line 178
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 179
      if (! *s) {
#line 179
        return ((char *)buf);
      }
#line 180
      if ((int const   )*b >= 65) {
#line 180
        if ((int const   )*b <= 90) {
#line 180
          tmp___1 = ((int const   )*b - 65) + 97;
        } else {
#line 180
          tmp___1 = (int const   )*b;
        }
      } else {
#line 180
        tmp___1 = (int const   )*b;
      }
#line 180
      if ((int const   )*s != tmp___1) {
#line 180
        goto while_break___0;
      }
#line 181
      s ++;
#line 181
      b ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 174
    buf ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 184
  return ((char *)((void *)0));
}
}
#line 188 "/home/wheatley/newnew/temp/proxycheck-0.49a/pxy.c"
static int httpheaders(pxyconn_t *c , char *buf , int l ) 
{ 
  char *a ;
  int r ;
  int tmp ;
  int via ;
  char *e ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 191
  tmp = memcmp((void const   *)buf, (void const   *)"HTTP/", (size_t )5);
  }
#line 191
  if (tmp != 0) {
#line 198
    return (0);
  } else {
    {
#line 191
    a = strchr((char const   *)buf, ' ');
    }
#line 191
    if (a) {
#line 191
      if ((unsigned long )a > (unsigned long )(buf + 8)) {
#line 198
        return (0);
      } else
#line 191
      if ((int )*(a + 1) < 49) {
#line 198
        return (0);
      } else
#line 191
      if ((int )*(a + 1) > 57) {
#line 198
        return (0);
      } else
#line 191
      if ((int )*(a + 2) < 48) {
#line 198
        return (0);
      } else
#line 191
      if ((int )*(a + 2) > 57) {
#line 198
        return (0);
      } else
#line 191
      if ((int )*(a + 3) < 48) {
#line 198
        return (0);
      } else
#line 191
      if ((int )*(a + 3) > 57) {
#line 198
        return (0);
      } else
#line 191
      if ((int )*(a + 4) != 32) {
#line 198
        return (0);
      }
    } else {
#line 198
      return (0);
    }
  }
  {
#line 199
  r = (((int )*(a + 1) - 48) * 100 + ((int )*(a + 2) - 48) * 10) + ((int )*(a + 3) - 48);
#line 202
  a = memcfind((char const   *)buf, l, "\nproxy-agent: ");
  }
#line 202
  if (a) {
#line 202
    goto _L;
  } else {
    {
#line 202
    a = memcfind((char const   *)buf, l, "\nvia: ");
    }
#line 202
    if (a) {
      _L: /* CIL Label */ 
#line 206
      a ++;
#line 207
      if ((int )*a == 86) {
#line 207
        tmp___2 = 1;
      } else
#line 207
      if ((int )*a == 118) {
#line 207
        tmp___2 = 1;
      } else {
#line 207
        tmp___2 = 0;
      }
#line 207
      via = tmp___2;
#line 207
      if (via) {
#line 207
        tmp___1 = 5;
      } else {
#line 207
        tmp___1 = 13;
      }
#line 207
      a += tmp___1;
      {
#line 208
      while (1) {
        while_continue: /* CIL Label */ ;
#line 208
        if (! ((int )*a == 32)) {
#line 208
          goto while_break;
        }
#line 208
        a ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 209
      if (via) {
        {
#line 210
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 210
          if (! ((int )*a > 32)) {
#line 210
            goto while_break___0;
          }
#line 210
          a ++;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 211
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 211
          if (! ((int )*a == 32)) {
#line 211
            goto while_break___1;
          }
#line 211
          a ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 213
      e = a;
      {
#line 214
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 214
        if ((int )((unsigned char )*e) >= 32) {
#line 214
          if (! ((int )*e != 127)) {
#line 214
            goto while_break___2;
          }
        } else {
#line 214
          goto while_break___2;
        }
#line 214
        e ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 215
      if ((unsigned long )e != (unsigned long )a) {
#line 216
        if (e - a > 60L) {
#line 216
          *(a + 65) = (char )'\000';
        } else {
#line 217
          *e = (char )'\000';
        }
        {
#line 218
        c->detail = strdup((char const   *)a);
#line 219
        pxyinfo((pxyconn_t const   *)c, 2, "Proxy-agent: %s", a);
        }
      }
    }
  }
#line 223
  if (r / 100 != 2) {
    {
#line 225
    pxyinfo((pxyconn_t const   *)c, 2, "HTTP request refused or failed (%d)", r);
    }
#line 227
    if (r == 407) {
      {
#line 232
      pxyaction(c, 2);
      }
    } else
#line 227
    if (r == 400) {
      {
#line 232
      pxyaction(c, 2);
      }
    } else
#line 227
    if (r == 302) {
      {
#line 232
      pxyaction(c, 2);
      }
    } else {
      {
#line 234
      pxyaction(c, 1);
      }
    }
#line 235
    return (-1);
  }
#line 238
  return (r);
}
}
#line 241 "/home/wheatley/newnew/temp/proxycheck-0.49a/pxy.c"
static int hcc(pxyconn_t *c , char *buf , int l ) 
{ 
  int r ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 248
  if (c->pxystate > 1) {
#line 249
    return (0);
  }
  {
#line 250
  c->pxystate = 2;
#line 251
  tmp = memcfind((char const   *)buf, l, "hwarang/");
  }
#line 251
  if (tmp) {
    {
#line 252
    pxyinfo((pxyconn_t const   *)c, 2, "probably HwaRang \"lazy\" proxy");
    }
  }
  {
#line 253
  r = httpheaders(c, buf, l);
  }
#line 254
  if (! r) {
#line 254
    return (0);
  }
#line 255
  if (r < 0) {
#line 255
    return (1);
  }
  {
#line 258
  tmp___0 = memcfind((char const   *)buf, l, "content-length:");
  }
#line 258
  if (tmp___0) {
    {
#line 260
    pxyinfo((pxyconn_t const   *)c, 2, "HTTP CONNECT answered with a page (code %d)",
            r);
#line 261
    pxyaction(c, 1);
    }
#line 262
    return (1);
  } else {
    {
#line 265
    pxyinfo((pxyconn_t const   *)c, 2, "HTTP request successeful (%d)", r);
    }
#line 266
    return (0);
  }
}
}
#line 271 "/home/wheatley/newnew/temp/proxycheck-0.49a/pxy.c"
static void hch(pxyconn_t *c , int e  __attribute__((__unused__)) ) 
{ 
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 276
  if (c->pxystate == 0) {
    {
#line 278
    tmp = inet_ntoa(c->dstaddr);
#line 278
    tmp___0 = pxyprintf(c, 3, "CONNECT %s:%d HTTP/1.0\r\n", tmp, (int )c->dstport);
    }
#line 278
    if (tmp___0) {
      {
#line 278
      tmp___1 = pxywrite(c, "\r\n", 2, 3);
      }
#line 278
      if (tmp___1) {
        {
#line 278
        tmp___2 = pxyreqiot(c, 1, & hch, 0, (void (*)(pxyconn_t * ))((void *)0));
        }
#line 278
        if (tmp___2) {
#line 282
          c->pxystate = 1;
        }
      }
    }
  } else {
    {
#line 288
    pxyaction(c, 0);
    }
  }
#line 289
  return;
}
}
#line 293 "/home/wheatley/newnew/temp/proxycheck-0.49a/pxy.c"
static int hxc(pxyconn_t *c , char *buf , int l ) 
{ 
  int r ;

  {
#line 296
  if (c->pxystate > 2) {
#line 296
    return (0);
  }
  {
#line 297
  c->pxystate = 2;
#line 298
  r = httpheaders(c, buf, l);
  }
#line 299
  if (! r) {
#line 299
    return (0);
  }
#line 300
  if (r < 0) {
#line 300
    return (1);
  }
  {
#line 302
  pxyinfo((pxyconn_t const   *)c, 2, "HTTP request successeful (%d)", r);
  }
#line 303
  return (0);
}
}
#line 307 "/home/wheatley/newnew/temp/proxycheck-0.49a/pxy.c"
static void hxh(pxyconn_t *c , int e  __attribute__((__unused__)) ) 
{ 
  int dl ;
  int tmp ;
  char *b ;
  int l ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 308
  if (! c->pxystate) {
    {
#line 309
    tmp = pxygetdata(c);
#line 309
    dl = tmp;
#line 310
    b = (pxybuf + dl) + 1;
#line 311
    tmp___0 = inet_ntoa(c->dstaddr);
#line 311
    tmp___1 = strchr((char const   *)(c->proto)->fullname, ' ');
#line 311
    tmp___2 = sprintf((char */* __restrict  */)b, (char const   */* __restrict  */)"%s http://%s:%d/ HTTP/1.0\r\nContent-length: %d\r\nConnection: close\r\n\r\n",
                      tmp___1 + 1, tmp___0, (int )c->dstport, dl);
#line 311
    l = tmp___2;
#line 318
    tmp___4 = pxywrite(c, (char const   *)b, l, 3);
    }
#line 318
    if (tmp___4) {
      {
#line 319
      c->pxystate = 1;
#line 320
      pxyinfo((pxyconn_t const   *)c, 3, "sending data");
#line 321
      tmp___3 = pxywrite(c, (char const   *)(pxybuf), dl, 6);
      }
#line 321
      if (tmp___3) {
        {
#line 322
        pxyreqiot(c, 1, & hxh, 0, (void (*)(pxyconn_t * ))((void *)0));
        }
      }
    }
  } else {
    {
#line 326
    pxycheckdata(c);
    }
  }
#line 327
  return;
}
}
#line 329 "/home/wheatley/newnew/temp/proxycheck-0.49a/pxy.c"
static void s5h(pxyconn_t *c , int e  __attribute__((__unused__)) ) 
{ 
  int l ;
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  ipport_t p ;
  uint16_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *s ;

  {
#line 336
  if (! c->pxystate) {
    {
#line 337
    pxybuf[0] = (char)5;
#line 338
    pxybuf[1] = (char)1;
#line 339
    pxybuf[2] = (char)0;
#line 340
    tmp = pxywrite(c, (char const   *)(pxybuf), 3, 4);
    }
#line 340
    if (tmp) {
      {
#line 340
      tmp___0 = pxyreqiot(c, 1, & s5h, pxytimeout / 2, (void (*)(pxyconn_t * ))((void *)0));
      }
#line 340
      if (tmp___0) {
#line 342
        c->pxystate = 1;
      }
    }
  } else
#line 344
  if (c->pxystate == 1) {
    {
#line 345
    l = pxyread(c, pxybuf, 4, 2, 4);
    }
#line 345
    if (! (l <= 0)) {
#line 347
      if ((int )pxybuf[1] != 0) {
#line 348
        if ((int )pxybuf[0] == 0) {
#line 348
          if ((int )pxybuf[1] == 91) {
#line 348
            tmp___1 = ", socks4-only server";
          } else {
#line 348
            tmp___1 = "";
          }
        } else {
#line 348
          tmp___1 = "";
        }
        {
#line 348
        pxyinfo((pxyconn_t const   *)c, 2, "auth rejected (v=%d c=%d%s)", (int )((unsigned char )pxybuf[0]),
                (int )((unsigned char )pxybuf[1]), tmp___1);
#line 352
        pxyaction(c, 2);
        }
      } else
#line 354
      if (l > 2) {
        {
#line 355
        pxyinfo((pxyconn_t const   *)c, 2, "too much socks5 data v=%d c=%d %d %d",
                (int )((unsigned char )pxybuf[0]), (int )((unsigned char )pxybuf[1]),
                (int )((unsigned char )pxybuf[2]), (int )((unsigned char )pxybuf[3]));
#line 358
        pxyaction(c, 2);
        }
      } else {
        {
#line 361
        tmp___2 = htons(c->dstport);
#line 361
        p = tmp___2;
#line 362
        pxyinfo((pxyconn_t const   *)c, 3, "auth accepted");
#line 363
        pxybuf[0] = (char)5;
#line 364
        pxybuf[1] = (char)1;
#line 365
        pxybuf[2] = (char)0;
#line 366
        pxybuf[3] = (char)1;
#line 367
        memcpy((void */* __restrict  */)(pxybuf + 4), (void const   */* __restrict  */)(& c->dstaddr.s_addr),
               (size_t )4);
#line 368
        memcpy((void */* __restrict  */)(pxybuf + 8), (void const   */* __restrict  */)(& p),
               (size_t )2);
#line 369
        tmp___3 = pxywrite(c, (char const   *)(pxybuf), 10, 4);
        }
#line 369
        if (tmp___3) {
          {
#line 369
          tmp___4 = pxyrenew(c, 0, (void (*)(pxyconn_t * ))((void *)0));
          }
#line 369
          if (tmp___4) {
#line 370
            c->pxystate = 2;
          }
        }
      }
    }
  } else {
    {
#line 373
    l = pxyread(c, pxybuf, 10, 2, 4);
    }
#line 373
    if (! (l <= 0)) {
#line 375
      if ((int )pxybuf[1] == 0) {
        {
#line 376
        pxyinfo((pxyconn_t const   *)c, 2, "request granted (v=%d c=%d l=%d)", (int )((unsigned char )pxybuf[0]),
                (int )((unsigned char )pxybuf[1]), l);
#line 378
        pxyaction(c, 0);
        }
      } else {
        {
#line 383
        if ((int )pxybuf[1] == 1) {
#line 383
          goto case_1;
        }
#line 384
        if ((int )pxybuf[1] == 2) {
#line 384
          goto case_2;
        }
#line 385
        if ((int )pxybuf[1] == 3) {
#line 385
          goto case_3;
        }
#line 386
        if ((int )pxybuf[1] == 4) {
#line 386
          goto case_4;
        }
#line 387
        if ((int )pxybuf[1] == 5) {
#line 387
          goto case_5;
        }
#line 388
        if ((int )pxybuf[1] == 6) {
#line 388
          goto case_6;
        }
#line 389
        if ((int )pxybuf[1] == 7) {
#line 389
          goto case_7;
        }
#line 390
        if ((int )pxybuf[1] == 8) {
#line 390
          goto case_8;
        }
#line 391
        goto switch_default;
        case_1: /* CIL Label */ 
#line 383
        s = (char *)"general server failure";
#line 383
        l = 1;
#line 383
        goto switch_break;
        case_2: /* CIL Label */ 
#line 384
        s = (char *)"connection not allowed by ruleset";
#line 384
        l = 2;
#line 384
        goto switch_break;
        case_3: /* CIL Label */ 
#line 385
        s = (char *)"network unreachable";
#line 385
        l = 1;
#line 385
        goto switch_break;
        case_4: /* CIL Label */ 
#line 386
        s = (char *)"host unreachable";
#line 386
        l = 1;
#line 386
        goto switch_break;
        case_5: /* CIL Label */ 
#line 387
        s = (char *)"connection refused";
#line 387
        l = 1;
#line 387
        goto switch_break;
        case_6: /* CIL Label */ 
#line 388
        s = (char *)"TTL expired";
#line 388
        l = 1;
#line 388
        goto switch_break;
        case_7: /* CIL Label */ 
#line 389
        s = (char *)"command not supported";
#line 389
        l = 2;
#line 389
        goto switch_break;
        case_8: /* CIL Label */ 
#line 390
        s = (char *)"address type not supported";
#line 390
        l = 2;
#line 390
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 391
        s = (char *)"unexpected response";
#line 391
        l = 1;
#line 391
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
        {
#line 393
        pxyinfo((pxyconn_t const   *)c, 2, "%s (v=%d c=%d)", s, (int )((unsigned char )pxybuf[0]),
                (int )((unsigned char )pxybuf[1]));
#line 395
        pxyaction(c, l);
        }
      }
    }
  }
#line 397
  return;
}
}
#line 399 "/home/wheatley/newnew/temp/proxycheck-0.49a/pxy.c"
static void s4h(pxyconn_t *c , int e  __attribute__((__unused__)) ) 
{ 
  int l ;
  ipport_t p ;
  uint16_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *s ;

  {
#line 405
  if (! c->pxystate) {
    {
#line 406
    tmp = htons(c->dstport);
#line 406
    p = tmp;
#line 407
    pxybuf[0] = (char)4;
#line 408
    pxybuf[1] = (char)1;
#line 409
    memcpy((void */* __restrict  */)(pxybuf + 2), (void const   */* __restrict  */)(& p),
           (size_t )2);
#line 410
    memcpy((void */* __restrict  */)(pxybuf + 4), (void const   */* __restrict  */)(& c->dstaddr.s_addr),
           (size_t )4);
#line 411
    pxybuf[8] = (char)0;
#line 412
    tmp___0 = pxywrite(c, (char const   *)(pxybuf), 9, 4);
    }
#line 412
    if (tmp___0) {
      {
#line 412
      tmp___1 = pxyreqiot(c, 1, & s4h, 0, (void (*)(pxyconn_t * ))((void *)0));
      }
#line 412
      if (tmp___1) {
#line 413
        c->pxystate = 1;
      }
    }
  } else {
    {
#line 415
    l = pxyread(c, pxybuf, 8, 8, 4);
    }
#line 415
    if (! (l <= 0)) {
#line 417
      if ((int )pxybuf[1] == 90) {
        {
#line 418
        pxyinfo((pxyconn_t const   *)c, 2, "request granted (v=%d c=%d)", (int )((unsigned char )pxybuf[0]),
                (int )((unsigned char )pxybuf[1]));
#line 420
        pxyaction(c, 0);
        }
      } else {
        {
#line 425
        if ((int )pxybuf[1] == 91) {
#line 425
          goto case_91;
        }
#line 426
        if ((int )pxybuf[1] == 92) {
#line 426
          goto case_92;
        }
#line 427
        if ((int )pxybuf[1] == 93) {
#line 427
          goto case_93;
        }
#line 428
        if ((int )pxybuf[1] == 1) {
#line 428
          goto case_1;
        }
#line 434
        goto switch_default;
        case_91: /* CIL Label */ 
#line 425
        s = (char *)"request rejected or failed";
#line 425
        goto switch_break;
        case_92: /* CIL Label */ 
#line 426
        s = (char *)"identd required";
#line 426
        goto switch_break;
        case_93: /* CIL Label */ 
#line 427
        s = (char *)"identd info mismatch";
#line 427
        goto switch_break;
        case_1: /* CIL Label */ 
#line 429
        if ((int )pxybuf[0] == 5) {
          {
#line 430
          pxyinfo((pxyconn_t const   *)c, 2, "request rejected (v=5 c=1, socks5-only server)");
#line 431
          pxyaction(c, 2);
          }
#line 432
          return;
        }
        switch_default: /* CIL Label */ 
#line 434
        s = (char *)"unexpected response";
#line 434
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
        {
#line 436
        pxyinfo((pxyconn_t const   *)c, 2, "%s (v=%d c=%d)", s, (int )((unsigned char )pxybuf[0]),
                (int )((unsigned char )pxybuf[1]));
#line 438
        pxyaction(c, 1);
        }
      }
    }
  }
#line 440
  return;
}
}
#line 442 "/home/wheatley/newnew/temp/proxycheck-0.49a/pxy.c"
static int checklist(char const   *buf , int l , char const   * const  *lp ) 
{ 
  char const   * const  *sp ;
  size_t tmp ;
  void *tmp___0 ;

  {
#line 444
  sp = lp;
  {
#line 445
  while (1) {
    while_continue: /* CIL Label */ ;
#line 445
    if (! *sp) {
#line 445
      goto while_break;
    }
    {
#line 446
    tmp = strlen((char const   *)*sp);
#line 446
    tmp___0 = memmem((void const   *)buf, (size_t )l, (void const   *)*sp, tmp);
    }
#line 446
    if (tmp___0) {
#line 447
      return ((int )(sp - lp));
    } else {
#line 449
      sp ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 450
  return (-1);
}
}
#line 456
static int wgc(pxyconn_t *c , char *buf , int l ) ;
#line 456 "/home/wheatley/newnew/temp/proxycheck-0.49a/pxy.c"
static char const   * const  wgabort[4]  = {      (char const   */* const  */)"sername",      (char const   */* const  */)"ogin:",      (char const   */* const  */)"assword:",      (char const   */* const  */)((void *)0)};
#line 453 "/home/wheatley/newnew/temp/proxycheck-0.49a/pxy.c"
static int wgc(pxyconn_t *c , char *buf , int l ) 
{ 
  int tmp ;

  {
  {
#line 462
  tmp = checklist((char const   *)buf, l, wgabort);
  }
#line 462
  if (tmp < 0) {
#line 463
    return (0);
  }
  {
#line 464
  pxyaction(c, 2);
  }
#line 465
  return (1);
}
}
#line 468
static void wgh(pxyconn_t *c , int e ) ;
#line 470 "/home/wheatley/newnew/temp/proxycheck-0.49a/pxy.c"
static void wgh_tmo(pxyconn_t *c ) 
{ 


  {
  {
#line 471
  wgh(c, -1);
  }
#line 472
  return;
}
}
#line 504 "/home/wheatley/newnew/temp/proxycheck-0.49a/pxy.c"
static char const   * const  wggo[10]  = 
#line 504
  {      (char const   */* const  */)"cisco>",      (char const   */* const  */)"MNGTR>",      (char const   */* const  */)"WinGate>",      (char const   */* const  */)"host[:port]:", 
        (char const   */* const  */)"host_name:port",      (char const   */* const  */)"SpoonProxy>",      (char const   */* const  */)"tn-gw",      (char const   */* const  */)"telnet>", 
        (char const   */* const  */)"CCProxy Telnet>",      (char const   */* const  */)((void *)0)};
#line 474 "/home/wheatley/newnew/temp/proxycheck-0.49a/pxy.c"
static void wgh(pxyconn_t *c , int e ) 
{ 
  int l ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char const   *d ;
  int tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  char *tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;

  {
#line 483
  if (! c->pxystate) {
    {
#line 484
    tmp = pxyreadnext(c, 0, & l, 3);
    }
#line 484
    if (tmp < 0) {
#line 485
      return;
    }
    {
#line 486
    c->pxystate = 1;
#line 487
    tmp___0 = pxyreqiot(c, 1, & wgh, pxytimeout / 8, & wgh_tmo);
    }
#line 487
    if (tmp___0) {
#line 487
      if (! l) {
#line 489
        return;
      } else {
        {
#line 487
        tmp___1 = pxysave(c, pxybuf, (unsigned int )l, 0U);
        }
#line 487
        if (! tmp___1) {
#line 489
          return;
        }
      }
    } else {
#line 489
      return;
    }
  }
#line 491
  if (c->pxystate == 1) {
#line 492
    if (e < 0) {
      {
#line 494
      tmp___2 = inet_ntoa(c->dstaddr);
#line 494
      l = sprintf((char */* __restrict  */)(pxybuf), (char const   */* __restrict  */)"%s:%d\r\n",
                  tmp___2, (int )c->dstport);
      }
#line 495
      if ((int )c->pxyport == 23) {
        {
#line 496
        tmp___3 = inet_ntoa(c->dstaddr);
#line 496
        tmp___4 = sprintf((char */* __restrict  */)(pxybuf + l), (char const   */* __restrict  */)"telnet %s %d\r\n",
                          tmp___3, (int )c->dstport);
#line 496
        l += tmp___4;
        }
      }
      {
#line 498
      tmp___5 = pxywrite(c, (char const   *)(pxybuf), l, 3);
      }
#line 498
      if (tmp___5) {
        {
#line 498
        tmp___6 = pxyrenew(c, 0, (void (*)(pxyconn_t * ))((void *)0));
        }
#line 498
        if (tmp___6) {
#line 499
          c->pxystate = 2;
        }
      }
    } else {
      {
#line 501
      tmp___20 = pxyreadnext(c, 0, & l, 3);
      }
#line 501
      if (tmp___20 < 0) {
#line 502
        return;
      } else {
        {
#line 501
        tmp___21 = wgc(c, pxybuf, l);
        }
#line 501
        if (tmp___21) {
#line 502
          return;
        } else {
          {
#line 517
          tmp___7 = checklist((char const   *)(pxybuf), l, wggo);
          }
          {
#line 520
          if (tmp___7 == 2) {
#line 520
            goto case_2;
          }
#line 520
          if (tmp___7 == 1) {
#line 520
            goto case_2;
          }
#line 520
          if (tmp___7 == 0) {
#line 520
            goto case_2;
          }
#line 526
          if (tmp___7 == 4) {
#line 526
            goto case_4;
          }
#line 526
          if (tmp___7 == 3) {
#line 526
            goto case_4;
          }
#line 531
          if (tmp___7 == 5) {
#line 531
            goto case_5;
          }
#line 538
          if (tmp___7 == 7) {
#line 538
            goto case_7;
          }
#line 538
          if (tmp___7 == 6) {
#line 538
            goto case_7;
          }
#line 544
          if (tmp___7 == 8) {
#line 544
            goto case_8;
          }
#line 550
          goto switch_default;
          case_2: /* CIL Label */ 
          case_1: /* CIL Label */ 
          case_0: /* CIL Label */ 
          {
#line 521
          tmp___8 = inet_ntoa(c->dstaddr);
#line 521
          tmp___9 = pxyprintf(c, 3, "%s:%d\r\n", tmp___8, (int )c->dstport);
          }
#line 521
          if (! tmp___9) {
#line 522
            return;
          }
#line 523
          d = "host:port (wingate)";
#line 524
          goto switch_break;
          case_4: /* CIL Label */ 
          case_3: /* CIL Label */ 
          {
#line 527
          tmp___10 = inet_ntoa(c->dstaddr);
#line 527
          tmp___11 = pxyprintf(c, 3, "%s:%d\r\n", tmp___10, (int )c->dstport);
          }
#line 527
          if (! tmp___11) {
#line 528
            return;
          }
#line 529
          d = "host:port (telnet gateway)";
#line 530
          goto switch_break;
          case_5: /* CIL Label */ 
          {
#line 532
          tmp___12 = inet_ntoa(c->dstaddr);
#line 532
          tmp___13 = pxyprintf(c, 3, "%s %d\r\n", tmp___12, (int )c->dstport);
          }
#line 532
          if (! tmp___13) {
#line 534
            return;
          }
#line 535
          d = "host port (SpoonProxy)";
#line 536
          goto switch_break;
          case_7: /* CIL Label */ 
          case_6: /* CIL Label */ 
          {
#line 539
          tmp___14 = inet_ntoa(c->dstaddr);
#line 539
          tmp___15 = pxyprintf(c, 3, "telnet %s %d\r\n", tmp___14, (int )c->dstport);
          }
#line 539
          if (! tmp___15) {
#line 541
            return;
          }
#line 542
          d = "telnet host port (telnet gateway)";
#line 543
          goto switch_break;
          case_8: /* CIL Label */ 
          {
#line 545
          tmp___16 = inet_ntoa(c->dstaddr);
#line 545
          tmp___17 = pxyprintf(c, 3, "open %s %d\r\n", tmp___16, (int )c->dstport);
          }
#line 545
          if (! tmp___17) {
#line 547
            return;
          }
#line 548
          d = "open host port (CCProxy)";
#line 549
          goto switch_break;
          switch_default: /* CIL Label */ 
#line 551
          return;
          switch_break: /* CIL Label */ ;
          }
          {
#line 553
          tmp___18 = pxysave(c, pxybuf, (unsigned int )l, 0U);
          }
#line 553
          if (tmp___18) {
            {
#line 553
            tmp___19 = pxyrenew(c, 0, (void (*)(pxyconn_t * ))((void *)0));
            }
#line 553
            if (tmp___19) {
#line 554
              c->pxystate = 2;
            }
          }
          {
#line 555
          c->detail = strdup(d);
          }
        }
      }
    }
  } else {
    {
#line 559
    pxyaction(c, 0);
    }
  }
#line 560
  return;
}
}
#line 562 "/home/wheatley/newnew/temp/proxycheck-0.49a/pxy.c"
static void fuh(pxyconn_t *c , int e  __attribute__((__unused__)) ) 
{ 
  int l ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *a ;
  char *e___0 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 573
  if (! c->pxystate) {
    {
#line 574
    tmp = pxyreadnext(c, 0, & l, 3);
    }
#line 574
    if (tmp < 0) {
#line 575
      return;
    }
    {
#line 576
    c->pxystate = 1;
#line 577
    tmp___0 = pxyreqiot(c, 1, & fuh, pxytimeout / 2, (void (*)(pxyconn_t * ))((void *)0));
    }
#line 577
    if (tmp___0) {
#line 577
      if (! l) {
#line 579
        return;
      } else {
        {
#line 577
        tmp___1 = pxysave(c, pxybuf, (unsigned int )l, 0U);
        }
#line 577
        if (! tmp___1) {
#line 579
          return;
        }
      }
    } else {
#line 579
      return;
    }
  }
#line 581
  if (c->pxystate == 1) {
    {
#line 582
    tmp___6 = pxyreadnext(c, 1, & l, 3);
    }
#line 582
    if (tmp___6 > 0) {
#line 582
      if (l > 4) {
        {
#line 583
        tmp___5 = memcmp((void const   *)(pxybuf), (void const   *)"220 ", (size_t )4);
        }
#line 583
        if (tmp___5 == 0) {
#line 585
          pxybuf[l] = (char )'\000';
#line 586
          a = pxybuf + 4;
#line 587
          if ((int )*a >= 65) {
#line 587
            if (! ((int )*a <= 90)) {
#line 587
              goto _L___0;
            }
          } else
          _L___0: /* CIL Label */ 
#line 587
          if ((int )*a >= 97) {
#line 587
            if (! ((int )*a <= 122)) {
#line 587
              goto _L;
            }
          } else {
            _L: /* CIL Label */ 
            {
#line 588
            while (1) {
              while_continue: /* CIL Label */ ;
#line 588
              if (*a) {
#line 588
                if ((int )*a != 32) {
#line 588
                  if ((int )*a != 10) {
#line 588
                    if (! ((int )*a != 13)) {
#line 588
                      goto while_break;
                    }
                  } else {
#line 588
                    goto while_break;
                  }
                } else {
#line 588
                  goto while_break;
                }
              } else {
#line 588
                goto while_break;
              }
#line 588
              a ++;
            }
            while_break: /* CIL Label */ ;
            }
            {
#line 589
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 589
              if (! ((int )*a == 32)) {
#line 589
                goto while_break___0;
              }
#line 589
              a ++;
            }
            while_break___0: /* CIL Label */ ;
            }
          }
#line 591
          e___0 = a;
          {
#line 592
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 592
            if (*e___0) {
#line 592
              if ((int )*e___0 >= 32) {
#line 592
                if (! ((int )*e___0 != 127)) {
#line 592
                  goto while_break___1;
                }
              } else {
#line 592
                goto while_break___1;
              }
            } else {
#line 592
              goto while_break___1;
            }
#line 592
            e___0 ++;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 593
          if ((unsigned long )a != (unsigned long )e___0) {
#line 594
            if (e___0 - a > 6L) {
              {
#line 594
              tmp___2 = memcmp((void const   *)(e___0 - 6), (void const   *)" ready",
                               (size_t )6);
              }
#line 594
              if (tmp___2 == 0) {
#line 595
                e___0 -= 6;
              }
            }
#line 596
            if (e___0 - a > 70L) {
#line 596
              *(a + 65) = (char )'\000';
            } else {
#line 597
              *e___0 = (char )'\000';
            }
            {
#line 598
            pxyinfo((pxyconn_t const   *)c, 2, "Proxy-agent: %s", a);
#line 599
            c->detail = strdup((char const   *)a);
            }
          }
          {
#line 601
          pxysave(c, (char *)((void *)0), 0U, 0U);
#line 602
          tmp___3 = inet_ntoa(c->dstaddr);
#line 602
          tmp___4 = pxyprintf(c, 3, "USER dummy@%s:%d\r\n", tmp___3, (int )c->dstport);
          }
#line 602
          if (tmp___4) {
            {
#line 604
            pxyaction(c, 0);
            }
          }
        } else {
          {
#line 607
          pxyinfo((pxyconn_t const   *)c, 2, "seems not to be FTP proxy");
#line 609
          pxyaction(c, 2);
          }
        }
      }
    }
  }
#line 613
  return;
}
}
#line 617 "/home/wheatley/newnew/temp/proxycheck-0.49a/pxy.c"
pxyproto_t const   pxyprotos[8]  = 
#line 617
  {      {"socks5", "s5", "socks5", "SOCKS5", 0, & s5h, (int (*)(pxyconn_t *c , char *buf ,
                                                             int l ))((void *)0)}, 
        {"socks4",
      "s4", "socks4", "SOCKS4", 0, & s4h, (int (*)(pxyconn_t *c , char *buf , int l ))((void *)0)}, 
        {"wingate",
      "wg", "wingate", "WINGATE", 2, & wgh, & wgc}, 
        {"http-connect", "hc", "http", "HTTP CONNECT", 1, & hch, & hcc}, 
        {"http-post", "ho", "http", "HTTP POST", 1, & hxh, & hxc}, 
        {"http-put", "hu", "http", "HTTP PUT", 1, & hxh, & hxc}, 
        {"ftp-user", "fu", "ftp", "FTP USER", 3, & fuh, (int (*)(pxyconn_t *c , char *buf ,
                                                              int l ))((void *)0)}, 
        {(char const   *)0,
      (char const   *)0, (char const   *)0, (char const   *)0, 0, (void (*)(pxyconn_t * ,
                                                                            int  ))0,
      (int (*)(pxyconn_t *c , char *buf , int l ))0}};
#line 636 "/home/wheatley/newnew/temp/proxycheck-0.49a/pxy.c"
static ipport_t const   htc[11]  = 
#line 636
  {      (ipport_t const   )80,      (ipport_t const   )81,      (ipport_t const   )1075,      (ipport_t const   )3128, 
        (ipport_t const   )4480,      (ipport_t const   )6588,      (ipport_t const   )8000,      (ipport_t const   )8080, 
        (ipport_t const   )8081,      (ipport_t const   )8090,      (ipport_t const   )0};
#line 636 "/home/wheatley/newnew/temp/proxycheck-0.49a/pxy.c"
static ipport_t const   hta[7]  = {      (ipport_t const   )7033,      (ipport_t const   )8085,      (ipport_t const   )8095,      (ipport_t const   )8100, 
        (ipport_t const   )8105,      (ipport_t const   )8110,      (ipport_t const   )0};
#line 636 "/home/wheatley/newnew/temp/proxycheck-0.49a/pxy.c"
static ipport_t const   spp[3]  = {      (ipport_t const   )1080,      (ipport_t const   )1075,      (ipport_t const   )0};
#line 636 "/home/wheatley/newnew/temp/proxycheck-0.49a/pxy.c"
static ipport_t const   wgp[2]  = {      (ipport_t const   )23,      (ipport_t const   )0};
#line 636 "/home/wheatley/newnew/temp/proxycheck-0.49a/pxy.c"
static ipport_t const   fup[2]  = {      (ipport_t const   )21,      (ipport_t const   )0};
#line 636 "/home/wheatley/newnew/temp/proxycheck-0.49a/pxy.c"
static ipport_t const   p1813[2]  = {      (ipport_t const   )1813,      (ipport_t const   )0};
#line 636 "/home/wheatley/newnew/temp/proxycheck-0.49a/pxy.c"
static ipport_t const   p5490[2]  = {      (ipport_t const   )5490,      (ipport_t const   )0};
#line 646 "/home/wheatley/newnew/temp/proxycheck-0.49a/pxy.c"
pxyprobe_t const   pxyprobes[13]  = 
#line 646
  {      {pxyprotos + 0, spp, 0}, 
        {pxyprotos + 1, spp, 0}, 
        {pxyprotos + 3, htc, 0}, 
        {pxyprotos + 3, p5490, 0}, 
        {pxyprotos + 3, hta, 1}, 
        {pxyprotos + 4, htc, 1}, 
        {pxyprotos + 2, wgp, 2}, 
        {pxyprotos + 4, hta, 2}, 
        {pxyprotos + 0, p1813, 2}, 
        {pxyprotos + 5, htc, 3}, 
        {pxyprotos + 6, fup, 3}, 
        {pxyprotos + 5, hta, 4}, 
        {(pxyproto_t const   *)0, (ipport_t const   *)0, 0}};
