/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 26 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/lexi.h"
enum rwcodes {
    rw_none = 0,
    rw_operator = 1,
    rw_break = 2,
    rw_switch = 3,
    rw_case = 4,
    rw_struct_like = 5,
    rw_enum = 6,
    rw_decl = 7,
    rw_sp_paren = 8,
    rw_sp_nparen = 9,
    rw_sp_else = 10,
    rw_sizeof = 11,
    rw_return = 12
} ;
#line 26 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/lexi.h"
typedef enum rwcodes rwcodes_ty;
#line 43
enum codes {
    code_eof = 0,
    newline = 1,
    lparen = 2,
    rparen = 3,
    start_token = 4,
    unary_op = 5,
    binary_op = 6,
    postop = 7,
    question = 8,
    casestmt = 9,
    colon = 10,
    doublecolon = 11,
    semicolon = 12,
    lbrace = 13,
    rbrace = 14,
    ident = 15,
    overloaded = 16,
    cpp_operator = 17,
    comma = 18,
    comment = 19,
    cplus_comment = 20,
    swstmt = 21,
    preesc = 22,
    form_feed = 23,
    decl = 24,
    sp_paren = 25,
    sp_nparen = 26,
    sp_else = 27,
    ifstmt = 28,
    elseifstmt = 29,
    whilestmt = 30,
    forstmt = 31,
    stmt = 32,
    stmtl = 33,
    elselit = 34,
    dolit = 35,
    dohead = 36,
    dostmt = 37,
    ifhead = 38,
    elsehead = 39,
    struct_delim = 40,
    attribute = 41,
    number_of_codes = 42
} ;
#line 43 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/lexi.h"
typedef enum codes codes_ty;
#line 101 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/indent.h"
typedef unsigned char BOOLEAN;
#line 113
enum bb_code {
    bb_none = 0,
    bb_comma = 1,
    bb_embedded_comment_start = 2,
    bb_embedded_comment_end = 3,
    bb_proc_call = 4,
    bb_dec_ind = 5,
    bb_unary_op = 6,
    bb_binary_op = 7,
    bb_before_boolean_binary_op = 8,
    bb_after_boolean_binary_op = 9,
    bb_after_equal_sign = 10,
    bb_comparisation = 11,
    bb_question = 12,
    bb_colon = 13,
    bb_label = 14,
    bb_semicolon = 15,
    bb_lbrace = 16,
    bb_rbrace = 17,
    bb_overloaded = 18,
    bb_const_qualifier = 19,
    bb_ident = 20,
    bb_attribute = 21,
    bb_struct_delim = 22,
    bb_operator2 = 23,
    bb_operator4 = 24,
    bb_operator5 = 25,
    bb_operator6 = 26,
    bb_doublecolon = 27,
    bb_cast = 28
} ;
#line 113 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/indent.h"
typedef enum bb_code bb_code_ty;
#line 246 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/indent.h"
struct user_options_st {
   int verbose ;
   int use_tabs ;
   int tabsize ;
   int use_stdout ;
   int space_sp_semicolon ;
   int swallow_optional_blanklines ;
   int star_comment_cont ;
   int struct_brace_indent ;
   int space_after_while ;
   int space_after_if ;
   int space_after_for ;
   int procnames_start_line ;
   int parentheses_space ;
   int preserve_mtime ;
   int paren_indent ;
   int proc_calls_space ;
   int leave_preproc_space ;
   int force_preproc_width ;
   int lineup_to_parens ;
   int honour_newlines ;
   int format_comments ;
   int format_col1_comments ;
   int extra_expression_indent ;
   int ljust_decl ;
   int cast_space ;
   int cuddle_else ;
   int cuddle_do_while ;
   int comment_delimiter_on_blankline ;
   int blank_after_sizeof ;
   int break_function_decl_args ;
   int break_function_decl_args_end ;
   int leave_comma ;
   int break_before_boolean_operator ;
   int blanklines_before_blockcomments ;
   int blanklines_after_declarations ;
   int blanklines_after_procs ;
   int blanklines_after_declarations_at_proctop ;
   int blanklines_around_conditional_compilation ;
   int comment_max_col ;
   int max_col ;
   int label_offset ;
   int ind_size ;
   int indent_parameters ;
   int decl_indent ;
   int unindent_displace ;
   int else_endif_col ;
   int case_indent ;
   int continuation_indent ;
   int decl_com_ind ;
   int case_brace_indent ;
   int c_plus_plus ;
   int com_ind ;
   int braces_on_struct_decl_line ;
   int braces_on_func_def_line ;
   int btype_2 ;
   int brace_indent ;
   int expect_output_file ;
};
#line 246 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/indent.h"
typedef struct user_options_st user_options_ty;
#line 356 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/indent.h"
struct parser_state {
   struct parser_state *next ;
   codes_ty last_token ;
   codes_ty *p_stack ;
   int p_stack_size ;
   int *il ;
   rwcodes_ty last_rw ;
   int last_rw_depth ;
   int *cstk ;
   int tos ;
   int box_com ;
   int cast_mask ;
   int noncast_mask ;
   int sizeof_mask ;
   int block_init ;
   int block_init_level ;
   int last_nl ;
   int last_saw_nl ;
   int saw_double_colon ;
   int broken_at_non_nl ;
   int in_or_st ;
   int col_1 ;
   int com_col ;
   int dec_nest ;
   int decl_on_line ;
   int i_l_follow ;
   BOOLEAN in_decl ;
   int in_stmt ;
   int in_parameter_declaration ;
   int ind_level ;
   int ind_stmt ;
   int last_u_d ;
   int p_l_follow ;
   int paren_level ;
   int paren_depth ;
   short *paren_indents ;
   int paren_indents_size ;
   int pcase ;
   int search_brace ;
   int use_ff ;
   int want_blank ;
   bb_code_ty can_break ;
   int its_a_keyword ;
   int sizeof_keyword ;
   char *procname ;
   char *procname_end ;
   char *classname ;
   char *classname_end ;
   int just_saw_decl ;
   int matching_brace_on_same_line ;
};
#line 356 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/indent.h"
typedef struct parser_state parser_state_ty;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 37 "/usr/include/utime.h"
struct utimbuf {
   __time_t actime ;
   __time_t modtime ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 106 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/indent.h"
struct file_buffer {
   char *name ;
   unsigned long size ;
   char *data ;
};
#line 106 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/indent.h"
typedef struct file_buffer file_buffer_ty;
#line 53 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/backup.h"
enum __anonenum_backup_mode_ty_31 {
    unknown = 0,
    none = 1,
    simple = 2,
    numbered_existing = 3,
    numbered = 4
} ;
#line 53 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/backup.h"
typedef enum __anonenum_backup_mode_ty_31 backup_mode_ty;
#line 63 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/backup.h"
struct __anonstruct_version_control_values_ty_32 {
   backup_mode_ty value ;
   char *name ;
};
#line 63 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/backup.h"
typedef struct __anonstruct_version_control_values_ty_32 version_control_values_ty;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 200 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/indent.h"
struct buf {
   char *ptr ;
   char *end ;
   int size ;
   int len ;
   int start_column ;
   int column ;
};
#line 200 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/indent.h"
typedef struct buf buf_ty;
#line 91
enum exit_values {
    total_success = 0,
    invocation_error = 1,
    indent_error = 2,
    indent_punt = 3,
    indent_fatal = 4,
    system_error = 5
} ;
#line 91 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/indent.h"
typedef enum exit_values exit_values_ty;
#line 14 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/output.h"
struct buf_break_st {
   struct buf_break_st *next ;
   struct buf_break_st *prev ;
   int offset ;
   char *corresponds_to ;
   int target_col ;
   int first_level ;
   int level ;
   int col ;
   int priority_code_length ;
   bb_code_ty priority_code ;
   int priority_newline ;
   int priority ;
};
#line 14 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/output.h"
typedef struct buf_break_st buf_break_st_ty;
#line 66 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/lexi.c"
struct __anonstruct_templ_ty_11 {
   char *rwd ;
   rwcodes_ty rwcode ;
};
#line 66 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/lexi.c"
typedef struct __anonstruct_templ_ty_11 templ_ty;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 98 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 104 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
enum __anonenum_profile_ty_26 {
    PRO_BOOL = 0,
    PRO_INT = 1,
    PRO_IGN = 2,
    PRO_KEY = 3,
    PRO_SETTINGS = 4,
    PRO_PRSTRING = 5,
    PRO_FUNCTION = 6
} ;
#line 104 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
typedef enum __anonenum_profile_ty_26 profile_ty;
#line 119
enum __anonenum_on_or_off_ty_27 {
    ONOFF_NA = 0,
    OFF = 1,
    ON = 2
} ;
#line 119 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
typedef enum __anonenum_on_or_off_ty_27 on_or_off_ty;
#line 207 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
struct __anonstruct_pro_ty_28 {
   char *p_name ;
   profile_ty p_type ;
   int p_default ;
   on_or_off_ty p_special ;
   int *p_obj ;
   int *p_explicit ;
};
#line 207 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
typedef struct __anonstruct_pro_ty_28 pro_ty;
#line 478 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
struct long_option_conversion {
   char *long_name ;
   char *short_name ;
};
#line 478 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
typedef struct long_option_conversion long_option_conversion_ty;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 170 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/indent.h"
char *s_lab ;
#line 171
char *e_lab ;
#line 175
char *s_code ;
#line 178
char *e_code ;
#line 181
char *combuf ;
#line 182
char *s_com ;
#line 183
char *e_com ;
#line 184
char *l_com ;
#line 186
char *buf_ptr ;
#line 188
char *buf_end ;
#line 191
char *token ;
#line 231
int prefix_blankline_requested ;
#line 323
user_options_ty settings ;
#line 328
int else_or_endif ;
#line 338
int com_lines ;
#line 342
BOOLEAN had_eof ;
#line 343
int line_no ;
#line 484
parser_state_ty *parser_state_tos ;
#line 65 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/code_io.h"
extern char *skip_horiz_space(char const   *p ) ;
#line 69
extern int current_column(void) ;
#line 70
void fill_buffer(void) ;
#line 71
extern void skip_buffered_space(void) ;
#line 40 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/output.h"
int compute_code_target(int paren_targ ) ;
#line 43
int compute_label_target(void) ;
#line 45
int count_columns(int column , char *bp , int stop_char ) ;
#line 54
extern void dump_line(int force_nl , int *paren_targ , BOOLEAN *pbreak_line ) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/comments.h"
extern void print_comment(int *paren_targ , BOOLEAN *pbreak_line ) ;
#line 36 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/globs.h"
extern char *xrealloc(char *ptr , unsigned int size ) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/parse.h"
extern int inc_pstack(void) ;
#line 87 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/comments.c"
extern void print_comment(int *paren_targ , BOOLEAN *pbreak_line ) 
{ 
  int column ;
  int format ;
  codes_ty comment_type ;
  int start_column ;
  int found_column ;
  int first_comment_line ;
  int right_margin ;
  int boxed_comment ;
  int stars ;
  int blankline_delims ;
  int paragraph_break ;
  int merge_blank_comment_lines ;
  int two_contiguous_comments ;
  int save_length ;
  char *save_ptr ;
  char *text_on_line ;
  char *line_break_ptr ;
  char *start_delim ;
  char *line_preamble ;
  int line_preamble_length ;
  int visible_preamble ;
  int suppress_cdb ;
  size_t tmp ;
  int comment_lines_count ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int nsize ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int target ;
  int tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *p ;
  char *tmp___15 ;
  int nsize___0 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  int tab_width ;
  char *tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;

  {
  {
#line 105
  two_contiguous_comments = 0;
#line 106
  save_length = 0;
#line 107
  save_ptr = (char *)((void *)0);
#line 108
  text_on_line = (char *)((void *)0);
#line 109
  line_break_ptr = (char *)((void *)0);
#line 110
  start_delim = (char *)((void *)0);
#line 112
  line_preamble = (char *)((void *)0);
#line 115
  suppress_cdb = 0;
#line 122
  inc_pstack();
  }
#line 127
  if ((int )*(token + 1) == 47) {
#line 129
    comment_type = (codes_ty )20;
  } else {
#line 133
    comment_type = (codes_ty )19;
  }
#line 142
  if ((unsigned int )comment_type == 20U) {
    {
#line 144
    start_delim = (char *)"//";
#line 145
    line_preamble = (char *)"// ";
#line 146
    tmp = strlen((char const   *)line_preamble);
#line 146
    line_preamble_length = (int )tmp;
#line 147
    visible_preamble = 1;
#line 148
    boxed_comment = 0;
#line 149
    stars = 0;
#line 150
    blankline_delims = 0;
    }
  } else
#line 152
  if ((int )*buf_ptr == 42) {
#line 152
    goto _L;
  } else
#line 152
  if ((int )*buf_ptr == 45) {
#line 152
    goto _L;
  } else
#line 152
  if ((int )*buf_ptr == 61) {
#line 152
    goto _L;
  } else
#line 152
  if ((int )*buf_ptr == 95) {
#line 152
    goto _L;
  } else
#line 152
  if (parser_state_tos->col_1) {
#line 152
    if (! settings.format_col1_comments) {
      _L: /* CIL Label */ 
      {
#line 157
      comment_lines_count = 1;
#line 158
      stars = 0;
#line 159
      boxed_comment = 0;
#line 160
      blankline_delims = 0;
#line 161
      line_preamble_length = 0;
#line 162
      visible_preamble = 0;
#line 164
      tmp___0 = current_column();
#line 164
      start_column = tmp___0 - 2;
#line 165
      found_column = start_column;
#line 166
      parser_state_tos->box_com = 1;
#line 167
      parser_state_tos->com_col = found_column;
      }
#line 169
      if (settings.blanklines_before_blockcomments) {
#line 171
        prefix_blankline_requested = 1;
      }
#line 174
      tmp___1 = e_com;
#line 174
      e_com ++;
#line 174
      *tmp___1 = (char )'/';
#line 175
      tmp___2 = e_com;
#line 175
      e_com ++;
#line 175
      *tmp___2 = (char )'*';
      {
#line 177
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 179
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 181
          if ((int )*buf_ptr == 10) {
#line 183
            line_no ++;
          }
#line 186
          tmp___3 = e_com;
#line 186
          e_com ++;
#line 186
          tmp___4 = buf_ptr;
#line 186
          buf_ptr ++;
#line 186
          *tmp___3 = *tmp___4;
#line 187
          if ((unsigned long )e_com >= (unsigned long )l_com) {
            {
#line 187
            nsize = (int )((l_com - s_com) + 400L);
#line 187
            tmp___5 = xrealloc(combuf, (unsigned int )nsize);
#line 187
            combuf = tmp___5;
#line 187
            e_com = (combuf + (e_com - s_com)) + 1;
#line 187
            l_com = (combuf + nsize) - 5;
#line 187
            s_com = combuf + 1;
            }
          }
#line 179
          if ((int )*buf_ptr != 42) {
#line 179
            if (! ((unsigned long )buf_ptr < (unsigned long )buf_end)) {
#line 179
              goto while_break___0;
            }
          } else {
#line 179
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
#line 193
        if ((int )*buf_ptr == 42) {
#line 193
          if ((int )*(buf_ptr + 1) == 47) {
#line 195
            if ((unsigned long )buf_ptr == (unsigned long )buf_end) {
              {
#line 197
              fill_buffer();
              }
            }
#line 200
            buf_ptr += 2;
#line 202
            if ((unsigned long )buf_ptr == (unsigned long )buf_end) {
              {
#line 204
              fill_buffer();
              }
            }
#line 207
            tmp___6 = e_com;
#line 207
            e_com ++;
#line 207
            *tmp___6 = (char )'*';
#line 208
            tmp___7 = e_com;
#line 208
            e_com ++;
#line 208
            *tmp___7 = (char )'/';
#line 209
            *e_com = (char )'\000';
#line 210
            (parser_state_tos->tos) --;
#line 218
            if (comment_lines_count > 1) {
#line 220
              parser_state_tos->com_col = 1;
            } else {
#line 224
              parser_state_tos->com_col = found_column;
            }
#line 227
            return;
          }
        }
#line 232
        if ((unsigned long )buf_ptr == (unsigned long )buf_end) {
#line 234
          if ((int )*(buf_ptr - 1) == 10) {
            {
#line 236
            e_com --;
#line 236
            *e_com = (char )'\000';
#line 237
            dump_line(1, paren_targ, pbreak_line);
#line 238
            comment_lines_count ++;
#line 239
            parser_state_tos->com_col = 1;
            }
          }
          {
#line 242
          fill_buffer();
          }
#line 244
          if (had_eof) {
#line 246
            tmp___8 = e_com;
#line 246
            e_com ++;
#line 246
            *tmp___8 = (char )'\000';
#line 247
            (parser_state_tos->tos) --;
#line 248
            parser_state_tos->com_col = start_column;
#line 249
            return;
          }
        }
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 152
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 256
    start_delim = (char *)"/*";
#line 257
    line_preamble = (char *)0;
#line 258
    line_preamble_length = 0;
#line 259
    visible_preamble = 0;
#line 260
    boxed_comment = 0;
#line 261
    stars = settings.star_comment_cont;
#line 262
    blankline_delims = settings.comment_delimiter_on_blankline;
  }
  {
#line 265
  paragraph_break = 0;
#line 266
  merge_blank_comment_lines = 0;
#line 267
  first_comment_line = com_lines;
#line 268
  right_margin = settings.comment_max_col;
#line 273
  tmp___9 = current_column();
#line 273
  found_column = tmp___9 - 2;
  }
#line 275
  if ((unsigned long )s_lab == (unsigned long )e_lab) {
#line 275
    if ((unsigned long )s_code == (unsigned long )e_code) {
#line 279
      if (parser_state_tos->col_1) {
#line 279
        if (! settings.format_col1_comments) {
#line 281
          format = settings.format_col1_comments;
#line 282
          start_column = 1;
        } else {
#line 279
          goto _L___2;
        }
      } else {
        _L___2: /* CIL Label */ 
#line 286
        format = settings.format_comments;
#line 288
        if (parser_state_tos->ind_level <= 0) {
#line 288
          if (! parser_state_tos->in_stmt) {
#line 292
            start_column = found_column;
          } else
#line 288
          if (parser_state_tos->in_decl) {
#line 288
            if (parser_state_tos->paren_level == 0) {
#line 292
              start_column = found_column;
            } else {
#line 288
              goto _L___1;
            }
          } else {
#line 288
            goto _L___1;
          }
        } else {
          _L___1: /* CIL Label */ 
          {
#line 297
          tmp___10 = compute_code_target(*paren_targ);
#line 297
          start_column = tmp___10 - settings.unindent_displace;
          }
#line 299
          if (start_column < 0) {
#line 301
            start_column = 1;
          }
        }
      }
    } else {
#line 275
      goto _L___3;
    }
  } else {
    _L___3: /* CIL Label */ 
#line 311
    suppress_cdb = 1;
#line 315
    if (parser_state_tos->decl_on_line) {
#line 317
      target = settings.decl_com_ind;
    } else
#line 319
    if (else_or_endif) {
#line 321
      target = settings.else_endif_col;
    } else {
#line 325
      target = settings.com_ind;
    }
#line 331
    if ((unsigned long )s_code != (unsigned long )e_code) {
      {
#line 333
      tmp___11 = compute_code_target(*paren_targ);
#line 333
      start_column = count_columns(tmp___11, s_code, '\000');
      }
    } else {
      {
#line 339
      tmp___12 = compute_label_target();
#line 339
      start_column = count_columns(tmp___12, s_lab, '\000');
      }
    }
#line 342
    if (start_column < target) {
#line 344
      start_column = target;
    } else
#line 351
    if (else_or_endif) {
#line 353
      start_column ++;
#line 354
      else_or_endif = 0;
    } else {
#line 358
      start_column += settings.tabsize - (start_column - 1) % settings.tabsize;
    }
#line 362
    format = settings.format_comments;
  }
#line 365
  if (! line_preamble) {
#line 367
    line_preamble_length = 3;
#line 369
    if (stars) {
#line 371
      line_preamble = (char *)" * ";
#line 372
      visible_preamble = 1;
    } else {
#line 376
      line_preamble = (char *)"   ";
#line 377
      visible_preamble = 0;
    }
  }
#line 384
  if (two_contiguous_comments) {
#line 384
    parser_state_tos->com_col = 1;
  } else {
#line 384
    parser_state_tos->com_col = start_column;
  }
#line 385
  parser_state_tos->box_com = boxed_comment;
#line 390
  tmp___13 = e_com;
#line 390
  e_com ++;
#line 390
  *tmp___13 = *start_delim;
#line 391
  tmp___14 = e_com;
#line 391
  e_com ++;
#line 391
  *tmp___14 = *(start_delim + 1);
#line 392
  column = start_column + 2;
#line 396
  if (blankline_delims) {
#line 396
    if (! suppress_cdb) {
      {
#line 398
      p = buf_ptr;
#line 400
      *e_com = (char )'\000';
#line 401
      dump_line(1, paren_targ, pbreak_line);
#line 406
      p = skip_horiz_space((char const   *)p);
      }
#line 408
      if ((int )*p == 10) {
#line 410
        buf_ptr = p + 1;
      } else
#line 412
      if (format) {
#line 414
        buf_ptr = p;
      }
#line 421
      if ((unsigned long )buf_ptr >= (unsigned long )buf_end) {
        {
#line 423
        fill_buffer();
        }
      }
#line 426
      column = start_column;
#line 427
      goto begin_line;
    } else {
#line 396
      goto _L___4;
    }
  } else
  _L___4: /* CIL Label */ 
#line 429
  if (format) {
    {
#line 431
    tmp___15 = e_com;
#line 431
    e_com ++;
#line 431
    *tmp___15 = (char )' ';
#line 432
    column = start_column + 3;
#line 434
    skip_buffered_space();
    }
  }
  {
#line 443
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 443
    if (! (! had_eof)) {
#line 443
      goto while_break___1;
    }
    {
#line 447
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 447
      if (! (! had_eof)) {
#line 447
        goto while_break___2;
      }
#line 449
      if ((unsigned long )e_com >= (unsigned long )l_com) {
        {
#line 449
        nsize___0 = (int )((l_com - s_com) + 400L);
#line 449
        tmp___16 = xrealloc(combuf, (unsigned int )nsize___0);
#line 449
        combuf = tmp___16;
#line 449
        e_com = (combuf + (e_com - s_com)) + 1;
#line 449
        l_com = (combuf + nsize___0) - 5;
#line 449
        s_com = combuf + 1;
        }
      }
      {
#line 454
      if ((int )*buf_ptr == 9) {
#line 454
        goto case_9;
      }
#line 454
      if ((int )*buf_ptr == 32) {
#line 454
        goto case_9;
      }
#line 495
      if ((int )*buf_ptr == 10) {
#line 495
        goto case_10;
      }
#line 574
      if ((int )*buf_ptr == 42) {
#line 574
        goto case_42;
      }
#line 677
      goto switch_default;
      case_9: /* CIL Label */ 
      case_32: /* CIL Label */ 
#line 459
      if (format) {
#line 459
        if ((unsigned long )line_break_ptr < (unsigned long )text_on_line) {
#line 461
          line_break_ptr = e_com;
        }
      }
#line 464
      if (format) {
#line 468
        if ((unsigned long )e_com == (unsigned long )s_com) {
#line 471
          tmp___17 = e_com;
#line 471
          e_com ++;
#line 471
          *tmp___17 = (char )' ';
#line 472
          column ++;
        } else
#line 468
        if ((int )*(e_com + -1) != 32) {
#line 471
          tmp___17 = e_com;
#line 471
          e_com ++;
#line 471
          *tmp___17 = (char )' ';
#line 472
          column ++;
        } else
#line 468
        if ((unsigned long )(e_com - 1) == (unsigned long )s_com) {
#line 471
          tmp___17 = e_com;
#line 471
          e_com ++;
#line 471
          *tmp___17 = (char )' ';
#line 472
          column ++;
        } else
#line 468
        if ((int )*(e_com + -2) == 46) {
#line 471
          tmp___17 = e_com;
#line 471
          e_com ++;
#line 471
          *tmp___17 = (char )' ';
#line 472
          column ++;
        }
      } else
#line 475
      if ((int )*buf_ptr == 32) {
#line 477
        tmp___18 = e_com;
#line 477
        e_com ++;
#line 477
        *tmp___18 = (char )' ';
#line 478
        column ++;
      } else {
#line 485
        tab_width = settings.tabsize - (((column + found_column) - start_column) - 1) % settings.tabsize;
#line 487
        column += tab_width;
        {
#line 488
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 488
          tmp___20 = tab_width;
#line 488
          tab_width --;
#line 488
          if (! tmp___20) {
#line 488
            goto while_break___3;
          }
#line 490
          tmp___19 = e_com;
#line 490
          e_com ++;
#line 490
          *tmp___19 = (char )' ';
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 493
      goto switch_break;
      case_10: /* CIL Label */ 
#line 497
      if ((unsigned int )comment_type == 20U) {
        cplus_exit: 
#line 500
        (parser_state_tos->tos) --;
#line 501
        if (two_contiguous_comments) {
#line 501
          parser_state_tos->com_col = 1;
        } else {
#line 501
          parser_state_tos->com_col = start_column;
        }
#line 502
        parser_state_tos->box_com = boxed_comment;
#line 503
        *e_com = (char)0;
#line 504
        return;
      }
#line 507
      if (format) {
#line 512
        if ((int )*buf_ptr == 10) {
#line 514
          line_no ++;
        }
#line 517
        buf_ptr ++;
#line 518
        if ((unsigned long )buf_ptr >= (unsigned long )buf_end) {
          {
#line 520
          fill_buffer();
          }
        }
#line 525
        if ((unsigned long )e_com > (unsigned long )line_break_ptr) {
#line 525
          if ((unsigned long )text_on_line < (unsigned long )line_break_ptr) {
#line 528
            e_com = line_break_ptr;
          }
        }
        {
#line 534
        skip_buffered_space();
        }
#line 536
        if ((int )*buf_ptr == 10) {
#line 538
          paragraph_break = 1;
#line 539
          goto end_line;
        } else
#line 536
        if (! text_on_line) {
#line 538
          paragraph_break = 1;
#line 539
          goto end_line;
        }
#line 543
        if (! boxed_comment) {
          {
#line 543
          tmp___21 = current_column();
          }
#line 543
          if (tmp___21 == found_column + 1) {
#line 543
            if ((int )*(buf_ptr + 0) == 42) {
#line 543
              if ((int )*(buf_ptr + 1) != 47) {
#line 546
                buf_ptr ++;
#line 546
                if ((unsigned long )buf_ptr >= (unsigned long )buf_end) {
                  {
#line 548
                  fill_buffer();
                  }
                }
#line 551
                if ((int )*buf_ptr == 32) {
#line 551
                  buf_ptr ++;
#line 551
                  if ((unsigned long )buf_ptr >= (unsigned long )buf_end) {
                    {
#line 553
                    fill_buffer();
                    }
                  }
                }
              }
            }
          }
        }
#line 560
        if ((int )*(e_com + -1) != 32) {
#line 562
          line_break_ptr = e_com;
#line 563
          tmp___22 = e_com;
#line 563
          e_com ++;
#line 563
          *tmp___22 = (char )' ';
#line 564
          column ++;
        }
#line 567
        goto while_continue___2;
      }
#line 572
      goto end_line;
      case_42: /* CIL Label */ 
#line 576
      if ((unsigned int )comment_type == 19U) {
#line 578
        if ((int )*(buf_ptr + 1) == 47) {
#line 584
          if (! boxed_comment) {
#line 586
            if (text_on_line) {
#line 588
              if (blankline_delims) {
#line 588
                if (! suppress_cdb) {
                  {
#line 590
                  *e_com = (char )'\000';
#line 591
                  dump_line(1, paren_targ, pbreak_line);
#line 592
                  tmp___23 = e_com;
#line 592
                  e_com ++;
#line 592
                  *tmp___23 = (char )' ';
                  }
                } else {
#line 588
                  goto _L___5;
                }
              } else
              _L___5: /* CIL Label */ 
#line 597
              if ((int )*(e_com - 1) != 32) {
#line 597
                if ((int )*(e_com - 1) != 9) {
#line 599
                  tmp___24 = e_com;
#line 599
                  e_com ++;
#line 599
                  *tmp___24 = (char )' ';
                }
              }
            } else
#line 603
            if ((unsigned long )s_com == (unsigned long )e_com) {
#line 609
              e_com = s_com;
#line 610
              tmp___25 = e_com;
#line 610
              e_com ++;
#line 610
              *tmp___25 = (char )' ';
            } else
#line 603
            if ((int )*s_com != 47) {
#line 609
              e_com = s_com;
#line 610
              tmp___25 = e_com;
#line 610
              e_com ++;
#line 610
              *tmp___25 = (char )' ';
            } else
#line 619
            if ((int )*(e_com - 1) != 32) {
#line 619
              if ((int )*(e_com - 1) != 9) {
#line 621
                tmp___26 = e_com;
#line 621
                e_com ++;
#line 621
                *tmp___26 = (char )' ';
              }
            }
          }
          {
#line 627
          tmp___27 = e_com;
#line 627
          e_com ++;
#line 627
          *tmp___27 = (char )'*';
#line 628
          tmp___28 = e_com;
#line 628
          e_com ++;
#line 628
          *tmp___28 = (char )'/';
#line 629
          *e_com = (char )'\000';
#line 636
          buf_ptr += 2;
#line 638
          buf_ptr = skip_horiz_space((char const   *)buf_ptr);
          }
#line 640
          if ((unsigned long )buf_ptr >= (unsigned long )buf_end) {
            {
#line 642
            fill_buffer();
            }
          }
#line 645
          (parser_state_tos->tos) --;
#line 646
          if (two_contiguous_comments) {
#line 646
            parser_state_tos->com_col = 1;
          } else {
#line 646
            parser_state_tos->com_col = start_column;
          }
#line 647
          parser_state_tos->box_com = boxed_comment;
#line 648
          return;
        }
#line 656
        if (first_comment_line == com_lines - 1) {
#line 656
          if ((unsigned long )e_com == (unsigned long )(s_com + line_preamble_length)) {
#line 660
            column -= line_preamble_length - 1;
#line 661
            line_preamble = (char *)" ";
#line 662
            line_preamble_length = 1;
#line 663
            boxed_comment = 1;
#line 664
            format = 0;
#line 665
            blankline_delims = 0;
#line 666
            *s_com = (char )' ';
#line 667
            *(s_com + 1) = (char )'*';
#line 668
            e_com = s_com + 2;
#line 668
            text_on_line = e_com;
#line 669
            column ++;
#line 670
            goto switch_break;
          }
        }
      }
      switch_default: /* CIL Label */ 
#line 679
      text_on_line = e_com;
#line 680
      tmp___29 = e_com;
#line 680
      e_com ++;
#line 680
      *tmp___29 = *buf_ptr;
#line 681
      column ++;
#line 682
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 688
      if (format) {
#line 688
        if (column > right_margin) {
#line 688
          if (line_break_ptr) {
#line 690
            if ((unsigned long )line_break_ptr < (unsigned long )(e_com - 1)) {
#line 695
              *line_break_ptr = (char )'\000';
#line 696
              save_ptr = line_break_ptr + 1;
#line 697
              save_length = (int )(e_com - save_ptr);
#line 698
              e_com = line_break_ptr;
#line 702
              if (column - save_length > right_margin) {
#line 704
                right_margin = column - save_length;
              }
            } else {
#line 711
              if ((unsigned int )comment_type == 20U) {
                {
#line 713
                buf_ptr = skip_horiz_space((char const   *)buf_ptr);
#line 715
                buf_ptr --;
                }
#line 716
                if ((int )*buf_ptr == 10) {
#line 718
                  goto cplus_exit;
                }
              } else {
                {
#line 723
                while (1) {
                  while_continue___4: /* CIL Label */ ;
#line 723
                  if (! ((int )*buf_ptr == 9)) {
#line 723
                    if (! ((int )*buf_ptr == 32)) {
#line 723
                      if (! ((int )*buf_ptr == 10)) {
#line 723
                        goto while_break___4;
                      }
                    }
                  }
#line 727
                  if ((int )*buf_ptr == 10) {
#line 729
                    line_no ++;
                  }
#line 732
                  buf_ptr ++;
#line 734
                  if ((unsigned long )buf_ptr >= (unsigned long )buf_end) {
                    {
#line 736
                    fill_buffer();
                    }
                  }
                }
                while_break___4: /* CIL Label */ ;
                }
#line 740
                buf_ptr --;
              }
#line 743
              *e_com = (char )'\000';
            }
#line 745
            goto end_line;
          }
        }
      }
#line 748
      if ((int )*buf_ptr == 10) {
#line 750
        line_no ++;
      }
#line 753
      buf_ptr ++;
#line 755
      if ((unsigned long )buf_ptr == (unsigned long )buf_end) {
        {
#line 757
        fill_buffer();
        }
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    end_line: 
#line 764
    if (! text_on_line) {
#line 764
      if (! visible_preamble) {
#line 764
        if (! (first_comment_line == com_lines)) {
#line 766
          e_com = s_com;
        }
      }
    }
    {
#line 769
    *e_com = (char )'\000';
#line 770
    dump_line(1, paren_targ, pbreak_line);
#line 774
    prefix_blankline_requested = 0;
    }
#line 780
    if (paragraph_break) {
#line 782
      if (merge_blank_comment_lines) {
        {
#line 784
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 784
          if (! ((int )*buf_ptr == 10)) {
#line 784
            if (! ((int )*buf_ptr == 32)) {
#line 784
              if (! ((int )*buf_ptr == 9)) {
#line 784
                goto while_break___5;
              }
            }
          }
#line 788
          if ((int )*buf_ptr == 10) {
#line 790
            line_no ++;
          }
#line 793
          buf_ptr ++;
#line 793
          if ((unsigned long )buf_ptr >= (unsigned long )buf_end) {
            {
#line 795
            fill_buffer();
            }
          }
        }
        while_break___5: /* CIL Label */ ;
        }
      }
#line 800
      paragraph_break = 0;
    } else {
#line 807
      if ((int )*buf_ptr == 10) {
#line 809
        line_no ++;
      }
#line 812
      buf_ptr ++;
#line 814
      if ((unsigned long )buf_ptr >= (unsigned long )buf_end) {
        {
#line 816
        fill_buffer();
        }
      }
    }
    begin_line: 
#line 821
    if (had_eof) {
#line 823
      goto while_break___1;
    }
#line 832
    if (line_preamble) {
      {
#line 834
      memcpy((void */* __restrict  */)e_com, (void const   */* __restrict  */)line_preamble,
             (size_t )line_preamble_length);
#line 835
      e_com += line_preamble_length;
#line 836
      column = start_column + line_preamble_length;
      }
    } else {
#line 840
      column = start_column;
    }
#line 843
    line_break_ptr = (char *)0;
#line 849
    if (save_ptr) {
      {
#line 851
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 851
        if ((int )*save_ptr == 32) {
#line 851
          goto _L___6;
        } else
#line 851
        if ((int )*save_ptr == 9) {
          _L___6: /* CIL Label */ 
#line 851
          if (! save_length) {
#line 851
            goto while_break___6;
          }
        } else {
#line 851
          goto while_break___6;
        }
#line 853
        save_ptr ++;
#line 854
        save_length --;
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 857
      memcpy((void */* __restrict  */)e_com, (void const   */* __restrict  */)save_ptr,
             (size_t )save_length);
#line 858
      text_on_line = e_com;
#line 859
      e_com += save_length;
#line 864
      column += save_length;
#line 865
      save_ptr = (char *)0;
#line 866
      save_length = 0;
      }
    } else {
      {
#line 870
      skip_buffered_space();
#line 872
      text_on_line = (char *)0;
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 876
  (parser_state_tos->tos) --;
#line 877
  if (two_contiguous_comments) {
#line 877
    parser_state_tos->com_col = 1;
  } else {
#line 877
    parser_state_tos->com_col = start_column;
  }
#line 878
  parser_state_tos->box_com = boxed_comment;
#line 879
  return;
}
}
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 45 "/usr/include/utime.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) utime)(char const   *__file ,
                                                                                            struct utimbuf  const  *__file_times ) ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 162
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 39 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) gettext)(char const   *__msgid )  __attribute__((__format_arg__(1))) ;
#line 33 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/globs.h"
extern char *xmalloc(unsigned int size ) ;
#line 40
extern void fatal(char const   *string , char const   *a0 ) ;
#line 44
extern void message(char *kind , char *string , unsigned int *a0 , unsigned int *a1 ) ;
#line 73 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/backup.h"
backup_mode_ty version_control_value(void) ;
#line 79
void initialize_backups(void) ;
#line 86
void make_backup(file_buffer_ty *file , struct stat  const  *file_stats ) ;
#line 182 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/backup.c"
static char *simple_backup_suffix  =    (char *)"~";
#line 187 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/backup.c"
backup_mode_ty version_control  =    (backup_mode_ty )0;
#line 188 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/backup.c"
int version_width  =    1;
#line 195 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/backup.c"
static char *simple_backup_name(char *pathname ) 
{ 
  char *backup_name ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 200
  tmp = strlen((char const   *)pathname);
#line 200
  tmp___0 = strlen((char const   *)simple_backup_suffix);
#line 200
  backup_name = xmalloc((unsigned int )((tmp + tmp___0) + 2UL));
#line 201
  sprintf((char */* __restrict  */)backup_name, (char const   */* __restrict  */)"%s%s",
          pathname, simple_backup_suffix);
  }
#line 202
  return (backup_name);
}
}
#line 211 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/backup.c"
static int version_number(char *base , char *direntry , int base_length ) 
{ 
  int version ;
  char *p ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
  {
#line 217
  p = (char *)((void *)0);
#line 219
  version = 0;
#line 221
  tmp___0 = strncmp((char const   *)base, (char const   *)direntry, (size_t )base_length);
  }
#line 221
  if (! tmp___0) {
#line 221
    if (((int )*(direntry + (base_length + 2)) & -128) == 0) {
      {
#line 221
      tmp___1 = __ctype_b_loc();
      }
#line 221
      if ((int const   )*(*tmp___1 + (int )*(direntry + (base_length + 2))) & 2048) {
#line 223
        p = direntry + (base_length + 2);
        {
#line 223
        while (1) {
          while_continue: /* CIL Label */ ;
#line 223
          if (((int )*p & -128) == 0) {
            {
#line 223
            tmp = __ctype_b_loc();
            }
#line 223
            if (! ((int const   )*(*tmp + (int )*p) & 2048)) {
#line 223
              goto while_break;
            }
          } else {
#line 223
            goto while_break;
          }
#line 225
          version = (version * 10 + (int )*p) - 48;
#line 223
          p ++;
        }
        while_break: /* CIL Label */ ;
        }
#line 228
        if ((int )*(p + 0) != 126) {
#line 230
          version = 0;
        } else
#line 228
        if (*(p + 1)) {
#line 230
          version = 0;
        }
      }
    }
  }
#line 234
  return (version);
}
}
#line 243 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/backup.c"
static int highest_version(char *filename , char *dirname ) 
{ 
  DIR *dirp ;
  DIR *tmp ;
  struct dirent *dp ;
  int highestVersion ;
  int this_version ;
  int file_name_length ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 247
  tmp = opendir((char const   *)dirname);
#line 247
  dirp = tmp;
#line 248
  dp = (struct dirent *)((void *)0);
  }
#line 251
  if (! dirp) {
#line 253
    highestVersion = 0;
  } else {
    {
#line 258
    tmp___0 = strlen((char const   *)filename);
#line 258
    file_name_length = (int )tmp___0;
#line 260
    highestVersion = 0;
    }
    {
#line 262
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 262
      dp = readdir(dirp);
      }
#line 262
      if (! ((unsigned long )dp != (unsigned long )((struct dirent *)0))) {
#line 262
        goto while_break;
      }
      {
#line 264
      tmp___1 = strlen((char const   *)(dp->d_name));
      }
#line 264
      if (tmp___1 <= (size_t )(file_name_length + 2)) {
#line 266
        goto while_continue;
      }
      {
#line 270
      this_version = version_number(filename, dp->d_name, file_name_length);
      }
#line 272
      if (this_version > highestVersion) {
#line 274
        highestVersion = this_version;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 278
    closedir(dirp);
    }
  }
#line 281
  return (highestVersion);
}
}
#line 290 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/backup.c"
static int max_version(char *pathname ) 
{ 
  char *p ;
  char *filename ;
  int pathlen ;
  size_t tmp ;
  int version ;
  int dirlen ;
  char *dirname ;

  {
  {
#line 295
  tmp = strlen((char const   *)pathname);
#line 295
  pathlen = (int )tmp;
#line 298
  p = (pathname + pathlen) - 1;
  }
  {
#line 300
  while (1) {
    while_continue: /* CIL Label */ ;
#line 300
    if ((unsigned long )p > (unsigned long )pathname) {
#line 300
      if (! ((int )*p != 47)) {
#line 300
        goto while_break;
      }
    } else {
#line 300
      goto while_break;
    }
#line 302
    p --;
  }
  while_break: /* CIL Label */ ;
  }
#line 305
  if ((int )*p == 47) {
    {
#line 307
    dirlen = (int )(p - pathname);
#line 310
    filename = p + 1;
#line 311
    dirname = xmalloc((unsigned int )(dirlen + 1));
#line 312
    strncpy((char */* __restrict  */)dirname, (char const   */* __restrict  */)pathname,
            (size_t )dirlen);
#line 313
    *(dirname + dirlen) = (char )'\000';
#line 314
    version = highest_version(filename, dirname);
#line 315
    free((void *)dirname);
    }
  } else {
    {
#line 319
    filename = pathname;
#line 320
    version = highest_version(filename, (char *)".");
    }
  }
#line 323
  return (version);
}
}
#line 332 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/backup.c"
static char *generate_backup_filename(backup_mode_ty versionControl , char *pathname ) 
{ 
  int last_numbered_version ;
  char *backup_name ;
  size_t tmp ;

  {
#line 339
  if ((unsigned int )versionControl == 1U) {
#line 341
    backup_name = (char *)((void *)0);
  } else
#line 345
  if ((unsigned int )versionControl == 2U) {
    {
#line 347
    backup_name = simple_backup_name(pathname);
    }
  } else {
    {
#line 351
    last_numbered_version = max_version(pathname);
    }
#line 353
    if ((unsigned int )versionControl == 3U) {
#line 353
      if (last_numbered_version == 0) {
        {
#line 355
        backup_name = simple_backup_name(pathname);
        }
      } else {
#line 353
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 359
      last_numbered_version ++;
#line 360
      tmp = strlen((char const   *)pathname);
#line 360
      backup_name = xmalloc((unsigned int )(tmp + 16UL));
      }
#line 362
      if (backup_name) {
        {
#line 364
        sprintf((char */* __restrict  */)backup_name, (char const   */* __restrict  */)"%s.~%0*d~",
                pathname, version_width, last_numbered_version);
        }
      }
    }
  }
#line 371
  return (backup_name);
}
}
#line 376 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/backup.c"
static version_control_values_ty values[8]  = 
#line 376
  {      {(backup_mode_ty )1, (char *)"never"}, 
        {(backup_mode_ty )1, (char *)"none"}, 
        {(backup_mode_ty )2, (char *)"simple"}, 
        {(backup_mode_ty )3, (char *)"existing"}, 
        {(backup_mode_ty )3, (char *)"nil"}, 
        {(backup_mode_ty )4, (char *)"numbered"}, 
        {(backup_mode_ty )4, (char *)"t"}, 
        {(backup_mode_ty )0, (char *)0}};
#line 395 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/backup.c"
backup_mode_ty version_control_value(void) 
{ 
  char *version ;
  char *tmp ;
  version_control_values_ty *v ;
  backup_mode_ty ret ;
  int tmp___0 ;

  {
  {
#line 397
  tmp = getenv("VERSION_CONTROL");
#line 397
  version = tmp;
#line 399
  ret = (backup_mode_ty )0;
  }
#line 401
  if ((unsigned long )version == (unsigned long )((void *)0)) {
#line 403
    ret = (backup_mode_ty )3;
  } else
#line 401
  if ((int )*version == 0) {
#line 403
    ret = (backup_mode_ty )3;
  } else {
#line 407
    v = & values[0];
    {
#line 409
    while (1) {
      while_continue: /* CIL Label */ ;
#line 409
      if (! v->name) {
#line 409
        goto while_break;
      }
      {
#line 411
      tmp___0 = strcmp((char const   *)version, (char const   *)v->name);
      }
#line 411
      if (tmp___0 == 0) {
#line 413
        ret = v->value;
#line 414
        goto while_break;
      } else {
#line 418
        v ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 423
  return (ret);
}
}
#line 431 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/backup.c"
static void set_version_width(void) 
{ 
  char *v ;
  char *tmp ;
  unsigned short const   **tmp___0 ;

  {
  {
#line 433
  tmp = getenv("VERSION_WIDTH");
#line 433
  v = tmp;
  }
#line 435
  if (v) {
#line 435
    if (((int )*v & -128) == 0) {
      {
#line 435
      tmp___0 = __ctype_b_loc();
      }
#line 435
      if ((int const   )*(*tmp___0 + (int )*v) & 2048) {
        {
#line 437
        version_width = atoi((char const   *)v);
        }
      }
    }
  }
#line 440
  if (version_width > 16) {
#line 442
    version_width = 16;
  }
#line 444
  return;
}
}
#line 450 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/backup.c"
void initialize_backups(void) 
{ 
  char *v ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 452
  tmp = getenv("SIMPLE_BACKUP_SUFFIX");
#line 452
  v = tmp;
  }
#line 454
  if (v) {
#line 454
    if (*v) {
#line 456
      simple_backup_suffix = v;
    }
  }
  {
#line 462
  version_control = version_control_value();
  }
#line 464
  if ((unsigned int )version_control == 0U) {
    {
#line 466
    tmp___0 = gettext("indent:  Strange version-control value\n");
#line 466
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0);
#line 467
    tmp___1 = gettext("indent:  Using numbered-existing\n");
#line 467
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1);
#line 468
    version_control = (backup_mode_ty )3;
    }
  }
  {
#line 472
  set_version_width();
  }
#line 473
  return;
}
}
#line 481 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/backup.c"
void make_backup(file_buffer_ty *file , struct stat  const  *file_stats ) 
{ 
  FILE *bf ;
  char *backup_filename ;
  unsigned int size ;
  char *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  struct utimbuf buf ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
#line 489
  if (! ((unsigned int )version_control == 1U)) {
    {
#line 494
    backup_filename = generate_backup_filename(version_control, file->name);
    }
#line 496
    if (! backup_filename) {
      {
#line 498
      tmp = gettext("indent: Can\'t make backup filename of %s\n");
#line 498
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
              file->name);
#line 499
      exit(5);
      }
    }
    {
#line 502
    bf = fopen((char const   */* __restrict  */)backup_filename, (char const   */* __restrict  */)"w");
    }
#line 504
    if (! bf) {
      {
#line 506
      tmp___0 = gettext("Can\'t open backup file %s");
#line 506
      fatal((char const   *)tmp___0, (char const   *)backup_filename);
      }
    }
    {
#line 509
    tmp___1 = fwrite((void const   */* __restrict  */)file->data, file->size, (size_t )1,
                     (FILE */* __restrict  */)bf);
#line 509
    size = (unsigned int )tmp___1;
    }
#line 511
    if (size != 1U) {
      {
#line 513
      tmp___2 = gettext("Can\'t write to backup file %s");
#line 513
      fatal((char const   *)tmp___2, (char const   *)backup_filename);
      }
    }
    {
#line 516
    fclose(bf);
#line 521
    buf.actime = time((time_t *)((void *)0));
#line 522
    buf.modtime = (__time_t )file_stats->st_mtim.tv_sec;
#line 524
    tmp___5 = utime((char const   *)backup_filename, (struct utimbuf  const  *)(& buf));
    }
#line 524
    if (tmp___5 != 0) {
      {
#line 526
      tmp___3 = gettext("Can\'t preserve modification time on backup file %s");
#line 526
      tmp___4 = gettext("Warning");
#line 526
      message(tmp___4, tmp___3, (unsigned int *)backup_filename, (unsigned int *)0);
      }
    }
    {
#line 531
    free((void *)backup_filename);
    }
  }
#line 533
  return;
}
}
#line 434 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 214 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 161 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/indent.h"
char *in_prog_pos ;
#line 164
char *cur_line ;
#line 197
file_buffer_ty *current_input ;
#line 222
buf_ty save_com ;
#line 224
char *bp_save ;
#line 226
char *be_save ;
#line 67 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/code_io.h"
extern file_buffer_ty *read_file(char *filename , struct stat *file_stats ) ;
#line 68
file_buffer_ty *read_stdin(void) ;
#line 72 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/output.h"
extern void inhibit_indenting(BOOLEAN flag ) ;
#line 81 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/code_io.c"
char *in_prog_pos  =    (char *)((void *)0);
#line 82 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/code_io.c"
char *buf_ptr  =    (char *)((void *)0);
#line 83 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/code_io.c"
char *buf_end  =    (char *)((void *)0);
#line 84 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/code_io.c"
BOOLEAN had_eof  =    (BOOLEAN )0;
#line 85 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/code_io.c"
char *cur_line  =    (char *)((void *)0);
#line 91 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/code_io.c"
extern char *skip_horiz_space(char const   *p ) 
{ 


  {
  {
#line 94
  while (1) {
    while_continue: /* CIL Label */ ;
#line 94
    if (! ((int const   )*p == 32)) {
#line 94
      if (! ((int const   )*p == 9)) {
#line 94
        goto while_break;
      }
    }
#line 96
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 99
  return ((char *)p);
}
}
#line 104 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/code_io.c"
extern void skip_buffered_space(void) 
{ 


  {
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
#line 106
    if (! ((int )*buf_ptr == 32)) {
#line 106
      if (! ((int )*buf_ptr == 9)) {
#line 106
        goto while_break;
      }
    }
#line 109
    buf_ptr ++;
#line 111
    if ((unsigned long )buf_ptr >= (unsigned long )buf_end) {
      {
#line 113
      fill_buffer();
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 116
  return;
}
}
#line 122 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/code_io.c"
static BOOLEAN is_comment_start(char const   *p ) 
{ 
  BOOLEAN ret ;

  {
#line 126
  if ((int const   )*p == 47) {
#line 126
    if ((int const   )*(p + 1) == 42) {
#line 129
      ret = (BOOLEAN )1;
    } else
#line 126
    if ((int const   )*(p + 1) == 47) {
#line 129
      ret = (BOOLEAN )1;
    } else {
#line 133
      ret = (BOOLEAN )0;
    }
  } else {
#line 133
    ret = (BOOLEAN )0;
  }
#line 136
  return (ret);
}
}
#line 183 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/code_io.c"
extern int current_column(void) 
{ 
  char *p ;
  int column ;

  {
#line 191
  if ((unsigned long )buf_ptr >= (unsigned long )save_com.ptr) {
#line 191
    if ((unsigned long )buf_ptr <= (unsigned long )(save_com.ptr + save_com.len)) {
#line 193
      p = save_com.ptr;
#line 194
      column = save_com.start_column;
    } else {
#line 198
      p = cur_line;
#line 199
      column = 1;
    }
  } else {
#line 198
    p = cur_line;
#line 199
    column = 1;
  }
  {
#line 202
  while (1) {
    while_continue: /* CIL Label */ ;
#line 202
    if (! ((unsigned long )p < (unsigned long )buf_ptr)) {
#line 202
      goto while_break;
    }
    {
#line 207
    if ((int )*p == 12) {
#line 207
      goto case_12;
    }
#line 207
    if ((int )*p == 10) {
#line 207
      goto case_12;
    }
#line 211
    if ((int )*p == 9) {
#line 211
      goto case_9;
    }
#line 215
    if ((int )*p == 8) {
#line 215
      goto case_8;
    }
#line 219
    goto switch_default;
    case_12: /* CIL Label */ 
    case_10: /* CIL Label */ 
#line 208
    column = 1;
#line 209
    goto switch_break;
    case_9: /* CIL Label */ 
#line 212
    column += settings.tabsize - (column - 1) % settings.tabsize;
#line 213
    goto switch_break;
    case_8: /* CIL Label */ 
#line 216
    column --;
#line 217
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 220
    column ++;
#line 221
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 224
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 227
  return (column);
}
}
#line 247 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/code_io.c"
static file_buffer_ty fileptr  =    {(char *)((void *)0), 0UL, (char *)0};
#line 243 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/code_io.c"
extern file_buffer_ty *read_file(char *filename , struct stat *file_stats ) 
{ 
  unsigned int size ;
  int namelen ;
  size_t tmp ;
  int fd ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  ssize_t tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;

  {
  {
#line 257
  tmp = strlen((char const   *)filename);
#line 257
  namelen = (int )tmp;
#line 258
  tmp___0 = open((char const   *)filename, 0, 511);
#line 258
  fd = tmp___0;
  }
#line 260
  if (fd < 0) {
    {
#line 262
    tmp___1 = gettext("Can\'t open input file %s");
#line 262
    fatal((char const   *)tmp___1, (char const   *)filename);
    }
  }
  {
#line 265
  tmp___3 = fstat(fd, file_stats);
  }
#line 265
  if (tmp___3 < 0) {
    {
#line 267
    tmp___2 = gettext("Can\'t stat input file %s");
#line 267
    fatal((char const   *)tmp___2, (char const   *)filename);
    }
  }
#line 270
  if (file_stats->st_size == 0L) {
    {
#line 272
    tmp___4 = gettext("Zero-length file %s");
#line 272
    tmp___5 = gettext("Error");
#line 272
    message(tmp___5, tmp___4, (unsigned int *)filename, (unsigned int *)0);
    }
  }
#line 276
  if (sizeof(int ) == 2UL) {
#line 278
    if (file_stats->st_size < 0L) {
      {
#line 280
      tmp___6 = gettext("File %s is too big to read");
#line 280
      fatal((char const   *)tmp___6, (char const   *)filename);
      }
    } else
#line 278
    if (file_stats->st_size > 65534L) {
      {
#line 280
      tmp___6 = gettext("File %s is too big to read");
#line 280
      fatal((char const   *)tmp___6, (char const   *)filename);
      }
    }
  } else
#line 286
  if (file_stats->st_size < 0L) {
    {
#line 288
    tmp___7 = gettext("System problem reading file %s");
#line 288
    fatal((char const   *)tmp___7, (char const   *)filename);
    }
  }
#line 292
  fileptr.size = (unsigned long )file_stats->st_size;
#line 294
  if ((unsigned long )fileptr.data != (unsigned long )((char *)0)) {
    {
#line 296
    tmp___8 = xrealloc(fileptr.data, (unsigned int )file_stats->st_size + 2U);
#line 296
    fileptr.data = tmp___8;
    }
  } else {
    {
#line 303
    tmp___9 = xmalloc((unsigned int )file_stats->st_size + 2U);
#line 303
    fileptr.data = tmp___9;
    }
  }
  {
#line 308
  tmp___10 = read(fd, (void *)fileptr.data, fileptr.size);
#line 308
  size = (unsigned int )tmp___10;
  }
#line 310
  if (size == 4294967295U) {
    {
#line 312
    tmp___11 = gettext("Error reading input file %s");
#line 312
    fatal((char const   *)tmp___11, (char const   *)filename);
    }
  }
  {
#line 315
  tmp___13 = close(fd);
  }
#line 315
  if (tmp___13 < 0) {
    {
#line 317
    tmp___12 = gettext("Error closing input file %s");
#line 317
    fatal((char const   *)tmp___12, (char const   *)filename);
    }
  }
#line 325
  if ((unsigned long )size < fileptr.size) {
#line 327
    fileptr.size = (unsigned long )size;
  }
#line 330
  if ((unsigned long )fileptr.name != (unsigned long )((void *)0)) {
    {
#line 332
    tmp___14 = xrealloc(fileptr.name, (unsigned int )namelen + 1U);
#line 332
    fileptr.name = tmp___14;
    }
  } else {
    {
#line 336
    tmp___15 = xmalloc((unsigned int )(namelen + 1));
#line 336
    fileptr.name = tmp___15;
    }
  }
  {
#line 339
  strncpy((char */* __restrict  */)fileptr.name, (char const   */* __restrict  */)filename,
          (size_t )namelen);
#line 340
  *(fileptr.name + namelen) = (char )'\000';
  }
#line 342
  if ((int )*(fileptr.data + (fileptr.size - 1UL)) != 10) {
#line 344
    *(fileptr.data + fileptr.size) = (char )'\n';
#line 345
    (fileptr.size) ++;
  }
#line 348
  *(fileptr.data + fileptr.size) = (char )'\000';
#line 350
  return (& fileptr);
}
}
#line 367 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/code_io.c"
static file_buffer_ty stdinptr  =    {(char *)((void *)0), 0UL, (char *)0};
#line 365 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/code_io.c"
file_buffer_ty *read_stdin(void) 
{ 
  unsigned int size ;
  int ch ;
  char *p ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 369
  size = 122880U;
#line 370
  ch = -1;
#line 371
  p = (char *)((void *)0);
#line 373
  if ((unsigned long )stdinptr.data != (unsigned long )((char *)0)) {
    {
#line 375
    free((void *)stdinptr.data);
    }
  }
  {
#line 378
  tmp = xmalloc(size + 1U);
#line 378
  stdinptr.data = tmp;
#line 379
  stdinptr.size = 0UL;
#line 381
  p = stdinptr.data;
  }
  {
#line 383
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 385
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 385
      if (! (stdinptr.size < (unsigned long )size)) {
#line 385
        goto while_break___0;
      }
      {
#line 387
      ch = _IO_getc(stdin);
      }
#line 389
      if (ch == -1) {
#line 391
        goto while_break___0;
      }
#line 394
      tmp___0 = p;
#line 394
      p ++;
#line 394
      *tmp___0 = (char )ch;
#line 395
      (stdinptr.size) ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 398
    if (ch != -1) {
      {
#line 400
      size += 16384U;
#line 401
      stdinptr.data = xrealloc(stdinptr.data, size);
#line 402
      p = stdinptr.data + stdinptr.size;
      }
    }
#line 383
    if (! (ch != -1)) {
#line 383
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 406
  stdinptr.name = (char *)"Standard Input";
#line 408
  *(stdinptr.data + stdinptr.size) = (char )'\000';
#line 410
  return (& stdinptr);
}
}
#line 430 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/code_io.c"
void fill_buffer(void) 
{ 
  char *p ;
  BOOLEAN finished_a_line ;
  int tmp ;
  BOOLEAN tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 432
  p = (char *)((void *)0);
#line 433
  finished_a_line = (BOOLEAN )0;
#line 439
  if ((unsigned long )bp_save != (unsigned long )((char *)0)) {
#line 441
    buf_ptr = bp_save;
#line 442
    buf_end = be_save;
#line 443
    be_save = (char *)0;
#line 443
    bp_save = be_save;
#line 447
    if ((unsigned long )buf_ptr < (unsigned long )buf_end) {
#line 449
      return;
    }
  }
#line 453
  if ((int )*in_prog_pos == 0) {
#line 455
    buf_ptr = in_prog_pos;
#line 456
    cur_line = buf_ptr;
#line 457
    had_eof = (BOOLEAN )1;
  } else {
#line 465
    cur_line = in_prog_pos;
#line 466
    p = cur_line;
#line 467
    finished_a_line = (BOOLEAN )0;
    {
#line 469
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 471
      p = skip_horiz_space((char const   *)p);
#line 476
      tmp___0 = is_comment_start((char const   *)p);
      }
#line 476
      if (tmp___0) {
        {
#line 478
        p += 2;
#line 480
        p = skip_horiz_space((char const   *)p);
#line 484
        tmp = strncmp((char const   *)p, "*INDENT-OFF*", (size_t )12);
        }
#line 484
        if (tmp == 0) {
          {
#line 486
          inhibit_indenting((BOOLEAN )1);
          }
        }
      }
      {
#line 490
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 490
        if ((int )*p != 0) {
#line 490
          if (! ((int )*p != 10)) {
#line 490
            goto while_break___0;
          }
        } else {
#line 490
          goto while_break___0;
        }
#line 492
        p ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 497
      if ((int )*p == 10) {
#line 499
        finished_a_line = (BOOLEAN )1;
#line 500
        in_prog_pos = p + 1;
      } else
#line 505
      if ((unsigned long )((unsigned int )(p - current_input->data)) < current_input->size) {
        {
#line 507
        tmp___1 = gettext("File %s contains NULL-characters: cannot proceed\n");
#line 507
        tmp___2 = gettext("Error");
#line 507
        message(tmp___2, tmp___1, (unsigned int *)current_input->name, (unsigned int *)0);
#line 508
        exit(1);
#line 509
        p ++;
        }
      } else {
#line 515
        in_prog_pos = p;
#line 516
        finished_a_line = (BOOLEAN )1;
      }
#line 469
      if (! (! finished_a_line)) {
#line 469
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 520
    buf_ptr = cur_line;
#line 521
    buf_end = in_prog_pos;
  }
#line 523
  return;
}
}
#line 169 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/indent.h"
char *labbuf ;
#line 172
char *l_lab ;
#line 174
char *codebuf ;
#line 179
char *l_code ;
#line 239
int break_comma ;
#line 329
int di_stack_alloc ;
#line 330
int *di_stack ;
#line 51 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/parse.h"
extern void parse_lparen_in_decl(void) ;
#line 52
extern exit_values_ty parse(codes_ty tk ) ;
#line 53
extern void init_parser(void) ;
#line 54
extern void reset_parser(void) ;
#line 55
extern void reduce(void) ;
#line 52 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/parse.c"
parser_state_ty *parser_state_tos  =    (parser_state_ty *)((void *)0);
#line 61 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/parse.c"
extern void init_parser(void) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
  {
#line 63
  tmp = xmalloc((unsigned int )sizeof(parser_state_ty ));
#line 63
  parser_state_tos = (parser_state_ty *)tmp;
#line 66
  parser_state_tos->p_stack_size = 2;
#line 67
  tmp___0 = xmalloc((unsigned int )(2UL * sizeof(codes_ty )));
#line 67
  parser_state_tos->p_stack = (codes_ty *)tmp___0;
#line 68
  tmp___1 = xmalloc((unsigned int )(2UL * sizeof(int )));
#line 68
  parser_state_tos->il = (int *)tmp___1;
#line 69
  tmp___2 = xmalloc((unsigned int )(2UL * sizeof(int )));
#line 69
  parser_state_tos->cstk = (int *)tmp___2;
#line 70
  parser_state_tos->paren_indents_size = 8;
#line 71
  tmp___3 = xmalloc((unsigned int )((unsigned long )parser_state_tos->paren_indents_size * sizeof(short )));
#line 71
  parser_state_tos->paren_indents = (short *)tmp___3;
#line 76
  tmp___4 = xmalloc(1000U);
#line 76
  combuf = tmp___4;
#line 77
  tmp___5 = xmalloc(1000U);
#line 77
  labbuf = tmp___5;
#line 78
  tmp___6 = xmalloc(1000U);
#line 78
  codebuf = tmp___6;
#line 80
  save_com.size = 1000;
#line 81
  save_com.ptr = xmalloc((unsigned int )save_com.size);
#line 81
  save_com.end = save_com.ptr;
#line 82
  save_com.column = 0;
#line 82
  save_com.len = save_com.column;
#line 84
  di_stack_alloc = 2;
#line 85
  tmp___7 = xmalloc((unsigned int )((unsigned long )di_stack_alloc * sizeof(*di_stack)));
#line 85
  di_stack = (int *)tmp___7;
  }
#line 86
  return;
}
}
#line 92 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/parse.c"
extern void reset_parser(void) 
{ 
  char tmp ;
  char tmp___0 ;
  char tmp___1 ;
  char tmp___2 ;

  {
#line 94
  parser_state_tos->next = (struct parser_state *)0;
#line 95
  parser_state_tos->tos = 0;
#line 96
  *(parser_state_tos->p_stack + 0) = (codes_ty )32;
#line 97
  parser_state_tos->last_nl = 1;
#line 99
  parser_state_tos->last_token = (codes_ty )4;
#line 100
  parser_state_tos->last_saw_nl = 0;
#line 101
  parser_state_tos->broken_at_non_nl = 0;
#line 102
  parser_state_tos->box_com = 0;
#line 103
  parser_state_tos->cast_mask = 0;
#line 104
  parser_state_tos->noncast_mask = 0;
#line 105
  parser_state_tos->sizeof_mask = 0;
#line 106
  parser_state_tos->block_init = 0;
#line 107
  parser_state_tos->block_init_level = 0;
#line 108
  parser_state_tos->col_1 = 0;
#line 109
  parser_state_tos->com_col = 0;
#line 110
  parser_state_tos->dec_nest = 0;
#line 111
  parser_state_tos->i_l_follow = 0;
#line 112
  parser_state_tos->ind_level = 0;
#line 113
  parser_state_tos->last_u_d = 0;
#line 114
  parser_state_tos->p_l_follow = 0;
#line 115
  parser_state_tos->paren_level = 0;
#line 116
  parser_state_tos->paren_depth = 0;
#line 117
  parser_state_tos->search_brace = 0;
#line 118
  parser_state_tos->use_ff = 0;
#line 119
  parser_state_tos->its_a_keyword = 0;
#line 120
  parser_state_tos->sizeof_keyword = 0;
#line 121
  parser_state_tos->in_parameter_declaration = 0;
#line 122
  parser_state_tos->just_saw_decl = 0;
#line 123
  parser_state_tos->in_decl = (BOOLEAN )0;
#line 124
  parser_state_tos->decl_on_line = 0;
#line 125
  parser_state_tos->in_or_st = 0;
#line 126
  parser_state_tos->want_blank = 0;
#line 127
  parser_state_tos->in_stmt = 0;
#line 128
  parser_state_tos->ind_stmt = 0;
#line 129
  parser_state_tos->procname = (char *)"\000";
#line 130
  parser_state_tos->procname_end = (char *)"\000";
#line 131
  parser_state_tos->classname = (char *)"\000";
#line 132
  parser_state_tos->classname_end = (char *)"\000";
#line 133
  parser_state_tos->pcase = 0;
#line 134
  parser_state_tos->dec_nest = 0;
#line 135
  parser_state_tos->can_break = (bb_code_ty )0;
#line 136
  parser_state_tos->saw_double_colon = 0;
#line 138
  *(parser_state_tos->il + 0) = 0;
#line 139
  *(parser_state_tos->cstk + 0) = 0;
#line 141
  save_com.column = 0;
#line 141
  save_com.len = save_com.column;
#line 143
  *(di_stack + parser_state_tos->dec_nest) = 0;
#line 145
  l_com = (combuf + 1000) - 5;
#line 146
  l_lab = (labbuf + 1000) - 5;
#line 147
  l_code = (codebuf + 1000) - 5;
#line 148
  tmp___0 = (char )' ';
#line 148
  *(labbuf + 0) = tmp___0;
#line 148
  tmp = tmp___0;
#line 148
  *(codebuf + 0) = tmp;
#line 148
  *(combuf + 0) = tmp;
#line 149
  tmp___2 = (char )'\000';
#line 149
  *(labbuf + 1) = tmp___2;
#line 149
  tmp___1 = tmp___2;
#line 149
  *(codebuf + 1) = tmp___1;
#line 149
  *(combuf + 1) = tmp___1;
#line 151
  else_or_endif = 0;
#line 152
  e_lab = labbuf + 1;
#line 152
  s_lab = e_lab;
#line 153
  e_code = codebuf + 1;
#line 153
  s_code = e_code;
#line 154
  e_com = combuf + 1;
#line 154
  s_com = e_com;
#line 156
  line_no = 1;
#line 157
  had_eof = (BOOLEAN )0;
#line 158
  break_comma = 0;
#line 159
  bp_save = (char *)0;
#line 160
  be_save = (char *)0;
#line 162
  if (settings.tabsize <= 0) {
#line 164
    settings.tabsize = 1;
  }
#line 167
  prefix_blankline_requested = 0;
#line 168
  return;
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/parse.c"
extern int inc_pstack(void) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 177
  (parser_state_tos->tos) ++;
#line 177
  if (parser_state_tos->tos >= parser_state_tos->p_stack_size) {
    {
#line 179
    parser_state_tos->p_stack_size *= 2;
#line 180
    tmp = xrealloc((char *)parser_state_tos->p_stack, (unsigned int )((unsigned long )parser_state_tos->p_stack_size * sizeof(codes_ty )));
#line 180
    parser_state_tos->p_stack = (codes_ty *)tmp;
#line 183
    tmp___0 = xrealloc((char *)parser_state_tos->il, (unsigned int )((unsigned long )parser_state_tos->p_stack_size * sizeof(int )));
#line 183
    parser_state_tos->il = (int *)tmp___0;
#line 185
    tmp___1 = xrealloc((char *)parser_state_tos->cstk, (unsigned int )((unsigned long )parser_state_tos->p_stack_size * sizeof(int )));
#line 185
    parser_state_tos->cstk = (int *)tmp___1;
    }
  }
#line 189
  *(parser_state_tos->cstk + parser_state_tos->tos) = *(parser_state_tos->cstk + (parser_state_tos->tos - 1));
#line 190
  return (parser_state_tos->tos);
}
}
#line 260 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/parse.c"
extern exit_values_ty parse(codes_ty tk ) 
{ 
  int i ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 279
  while (1) {
    while_continue: /* CIL Label */ ;
#line 279
    if ((unsigned int )*(parser_state_tos->p_stack + parser_state_tos->tos) == 38U) {
#line 279
      if (! ((unsigned int )tk != 34U)) {
#line 279
        goto while_break;
      }
    } else {
#line 279
      goto while_break;
    }
    {
#line 286
    *(parser_state_tos->p_stack + parser_state_tos->tos) = (codes_ty )32;
#line 287
    reduce();
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 295
  if ((unsigned int )tk == 24U) {
#line 295
    goto case_24;
  }
#line 331
  if ((unsigned int )tk == 28U) {
#line 331
    goto case_28;
  }
#line 339
  if ((unsigned int )tk == 9U) {
#line 339
    goto case_9;
  }
#line 339
  if ((unsigned int )tk == 31U) {
#line 339
    goto case_9;
  }
#line 339
  if ((unsigned int )tk == 35U) {
#line 339
    goto case_9;
  }
#line 354
  if ((unsigned int )tk == 13U) {
#line 354
    goto case_13;
  }
#line 420
  if ((unsigned int )tk == 30U) {
#line 420
    goto case_30;
  }
#line 443
  if ((unsigned int )tk == 34U) {
#line 443
    goto case_34;
  }
#line 463
  if ((unsigned int )tk == 14U) {
#line 463
    goto case_14;
  }
#line 477
  if ((unsigned int )tk == 21U) {
#line 477
    goto case_21;
  }
#line 497
  if ((unsigned int )tk == 12U) {
#line 497
    goto case_12;
  }
#line 514
  goto switch_default;
  case_24: /* CIL Label */ 
#line 297
  parser_state_tos->search_brace = settings.braces_on_struct_decl_line;
#line 301
  if ((unsigned int )*(parser_state_tos->p_stack + parser_state_tos->tos) != 24U) {
#line 301
    if (parser_state_tos->block_init == 0) {
      {
#line 306
      break_comma = 1;
#line 308
      inc_pstack();
#line 309
      *(parser_state_tos->p_stack + parser_state_tos->tos) = (codes_ty )24;
#line 310
      *(parser_state_tos->il + parser_state_tos->tos) = parser_state_tos->i_l_follow;
      }
#line 312
      if (settings.ljust_decl) {
#line 315
        parser_state_tos->ind_level = 0;
#line 316
        i = parser_state_tos->tos - 1;
        {
#line 316
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 316
          if (! (i > 0)) {
#line 316
            goto while_break___0;
          }
#line 318
          if ((unsigned int )*(parser_state_tos->p_stack + i) == 24U) {
#line 322
            parser_state_tos->ind_level += settings.ind_size;
          }
#line 316
          i --;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 326
        parser_state_tos->i_l_follow = parser_state_tos->ind_level;
      }
    }
  }
#line 329
  goto switch_break;
  case_28: /* CIL Label */ 
#line 332
  if ((unsigned int )*(parser_state_tos->p_stack + parser_state_tos->tos) == 39U) {
#line 334
    parser_state_tos->i_l_follow = *(parser_state_tos->il + parser_state_tos->tos);
  }
  case_9: /* CIL Label */ 
  case_31: /* CIL Label */ 
  case_35: /* CIL Label */ 
  {
#line 340
  inc_pstack();
#line 341
  *(parser_state_tos->p_stack + parser_state_tos->tos) = tk;
#line 342
  parser_state_tos->ind_level = parser_state_tos->i_l_follow;
#line 343
  *(parser_state_tos->il + parser_state_tos->tos) = parser_state_tos->ind_level;
  }
#line 345
  if ((unsigned int )tk != 9U) {
#line 347
    parser_state_tos->i_l_follow += settings.ind_size;
  }
#line 351
  parser_state_tos->search_brace = settings.btype_2;
#line 352
  goto switch_break;
  case_13: /* CIL Label */ 
#line 355
  break_comma = 0;
#line 356
  if ((unsigned int )*(parser_state_tos->p_stack + parser_state_tos->tos) == 32U) {
#line 360
    parser_state_tos->i_l_follow += settings.ind_size;
  } else
#line 356
  if ((unsigned int )*(parser_state_tos->p_stack + parser_state_tos->tos) == 33U) {
#line 360
    parser_state_tos->i_l_follow += settings.ind_size;
  } else
#line 362
  if ((unsigned int )*(parser_state_tos->p_stack + parser_state_tos->tos) == 24U) {
#line 364
    parser_state_tos->i_l_follow += settings.ind_size;
#line 366
    if ((unsigned int )parser_state_tos->last_rw == 5U) {
#line 366
      goto _L___0;
    } else
#line 366
    if ((unsigned int )parser_state_tos->last_rw == 6U) {
      _L___0: /* CIL Label */ 
#line 366
      if (parser_state_tos->block_init != 1) {
#line 366
        goto _L;
      } else
#line 366
      if (parser_state_tos->block_init_level == 0) {
        _L: /* CIL Label */ 
#line 366
        if ((unsigned int )parser_state_tos->last_token != 3U) {
#line 366
          if (! settings.braces_on_struct_decl_line) {
#line 373
            parser_state_tos->ind_level += settings.struct_brace_indent;
#line 374
            parser_state_tos->i_l_follow += settings.struct_brace_indent;
          }
        }
      }
    }
  } else
#line 377
  if ((unsigned int )*(parser_state_tos->p_stack + parser_state_tos->tos) == 9U) {
#line 379
    parser_state_tos->ind_level += settings.case_brace_indent - settings.ind_size;
#line 380
    parser_state_tos->i_l_follow += settings.case_brace_indent;
  } else {
#line 387
    if ((unsigned long )s_code == (unsigned long )e_code) {
#line 389
      parser_state_tos->ind_level -= settings.ind_size;
    }
#line 396
    if (! settings.btype_2) {
#line 398
      parser_state_tos->ind_level += settings.brace_indent;
#line 399
      parser_state_tos->i_l_follow += settings.brace_indent;
    }
#line 402
    if ((unsigned int )*(parser_state_tos->p_stack + parser_state_tos->tos) == 21U) {
#line 404
      parser_state_tos->i_l_follow += settings.case_indent;
    }
  }
  {
#line 408
  inc_pstack();
#line 409
  *(parser_state_tos->p_stack + parser_state_tos->tos) = (codes_ty )13;
#line 410
  *(parser_state_tos->il + parser_state_tos->tos) = parser_state_tos->ind_level;
#line 412
  inc_pstack();
#line 413
  *(parser_state_tos->p_stack + parser_state_tos->tos) = (codes_ty )32;
#line 417
  *(parser_state_tos->il + parser_state_tos->tos) = parser_state_tos->i_l_follow;
  }
#line 418
  goto switch_break;
  case_30: /* CIL Label */ 
#line 421
  if ((unsigned int )*(parser_state_tos->p_stack + parser_state_tos->tos) == 36U) {
    {
#line 424
    parser_state_tos->i_l_follow = *(parser_state_tos->il + parser_state_tos->tos);
#line 425
    parser_state_tos->ind_level = *(parser_state_tos->il + parser_state_tos->tos);
#line 426
    inc_pstack();
#line 427
    *(parser_state_tos->p_stack + parser_state_tos->tos) = (codes_ty )30;
#line 429
    parser_state_tos->ind_level = parser_state_tos->i_l_follow;
#line 430
    *(parser_state_tos->il + parser_state_tos->tos) = parser_state_tos->i_l_follow;
    }
  } else {
    {
#line 434
    inc_pstack();
#line 435
    *(parser_state_tos->p_stack + parser_state_tos->tos) = (codes_ty )30;
#line 436
    *(parser_state_tos->il + parser_state_tos->tos) = parser_state_tos->i_l_follow;
#line 437
    parser_state_tos->i_l_follow += settings.ind_size;
#line 438
    parser_state_tos->search_brace = settings.btype_2;
    }
  }
#line 441
  goto switch_break;
  case_34: /* CIL Label */ 
#line 445
  if ((unsigned int )*(parser_state_tos->p_stack + parser_state_tos->tos) != 38U) {
    {
#line 447
    tmp = gettext("Unmatched \'else\'");
#line 447
    tmp___0 = gettext("Error");
#line 447
    message(tmp___0, tmp, (unsigned int *)0, (unsigned int *)0);
    }
  } else {
#line 452
    parser_state_tos->ind_level = *(parser_state_tos->il + parser_state_tos->tos);
#line 455
    parser_state_tos->i_l_follow = parser_state_tos->ind_level + settings.ind_size;
#line 457
    *(parser_state_tos->p_stack + parser_state_tos->tos) = (codes_ty )39;
#line 459
    parser_state_tos->search_brace = 1;
  }
#line 461
  goto switch_break;
  case_14: /* CIL Label */ 
#line 465
  if ((unsigned int )*(parser_state_tos->p_stack + (parser_state_tos->tos - 1)) == 13U) {
#line 467
    (parser_state_tos->tos) --;
#line 467
    parser_state_tos->i_l_follow = *(parser_state_tos->il + parser_state_tos->tos);
#line 468
    parser_state_tos->ind_level = parser_state_tos->i_l_follow;
#line 469
    *(parser_state_tos->p_stack + parser_state_tos->tos) = (codes_ty )32;
  } else {
    {
#line 473
    tmp___1 = gettext("Stmt nesting error.");
#line 473
    tmp___2 = gettext("Error");
#line 473
    message(tmp___2, tmp___1, (unsigned int *)0, (unsigned int *)0);
    }
  }
#line 475
  goto switch_break;
  case_21: /* CIL Label */ 
  {
#line 478
  inc_pstack();
#line 479
  *(parser_state_tos->p_stack + parser_state_tos->tos) = (codes_ty )21;
#line 480
  *(parser_state_tos->cstk + parser_state_tos->tos) = settings.case_indent + parser_state_tos->i_l_follow;
  }
#line 481
  if (! settings.btype_2) {
#line 483
    *(parser_state_tos->cstk + parser_state_tos->tos) += settings.brace_indent;
  }
#line 487
  *(parser_state_tos->il + parser_state_tos->tos) = parser_state_tos->i_l_follow;
#line 493
  parser_state_tos->i_l_follow += settings.ind_size;
#line 494
  parser_state_tos->search_brace = settings.btype_2;
#line 495
  goto switch_break;
  case_12: /* CIL Label */ 
#line 498
  break_comma = 0;
#line 501
  if ((unsigned int )*(parser_state_tos->p_stack + parser_state_tos->tos) == 37U) {
#line 503
    *(parser_state_tos->p_stack + parser_state_tos->tos) = (codes_ty )32;
  } else {
    {
#line 507
    inc_pstack();
#line 508
    *(parser_state_tos->p_stack + parser_state_tos->tos) = (codes_ty )32;
#line 509
    *(parser_state_tos->il + parser_state_tos->tos) = parser_state_tos->ind_level;
    }
  }
#line 511
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 515
  tmp___3 = gettext("Unknown code to parser");
#line 515
  fatal((char const   *)tmp___3, (char const   *)0);
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 518
  reduce();
  }
#line 538
  return ((exit_values_ty )0);
}
}
#line 575 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/parse.c"
extern void reduce(void) 
{ 
  int i ;

  {
  {
#line 579
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 585
    if ((unsigned int )*(parser_state_tos->p_stack + parser_state_tos->tos) == 32U) {
#line 585
      goto case_32;
    }
#line 639
    if ((unsigned int )*(parser_state_tos->p_stack + parser_state_tos->tos) == 30U) {
#line 639
      goto case_30___0;
    }
#line 649
    goto switch_default___0;
    case_32: /* CIL Label */ 
    {
#line 589
    if ((unsigned int )*(parser_state_tos->p_stack + (parser_state_tos->tos - 1)) == 33U) {
#line 589
      goto case_33;
    }
#line 589
    if ((unsigned int )*(parser_state_tos->p_stack + (parser_state_tos->tos - 1)) == 32U) {
#line 589
      goto case_33;
    }
#line 594
    if ((unsigned int )*(parser_state_tos->p_stack + (parser_state_tos->tos - 1)) == 35U) {
#line 594
      goto case_35;
    }
#line 599
    if ((unsigned int )*(parser_state_tos->p_stack + (parser_state_tos->tos - 1)) == 28U) {
#line 599
      goto case_28;
    }
#line 627
    if ((unsigned int )*(parser_state_tos->p_stack + (parser_state_tos->tos - 1)) == 30U) {
#line 627
      goto case_30;
    }
#line 627
    if ((unsigned int )*(parser_state_tos->p_stack + (parser_state_tos->tos - 1)) == 9U) {
#line 627
      goto case_30;
    }
#line 627
    if ((unsigned int )*(parser_state_tos->p_stack + (parser_state_tos->tos - 1)) == 31U) {
#line 627
      goto case_30;
    }
#line 627
    if ((unsigned int )*(parser_state_tos->p_stack + (parser_state_tos->tos - 1)) == 39U) {
#line 627
      goto case_30;
    }
#line 627
    if ((unsigned int )*(parser_state_tos->p_stack + (parser_state_tos->tos - 1)) == 24U) {
#line 627
      goto case_30;
    }
#line 627
    if ((unsigned int )*(parser_state_tos->p_stack + (parser_state_tos->tos - 1)) == 21U) {
#line 627
      goto case_30;
    }
#line 633
    goto switch_default;
    case_33: /* CIL Label */ 
    case_32___0: /* CIL Label */ 
#line 591
    (parser_state_tos->tos) --;
#line 591
    *(parser_state_tos->p_stack + parser_state_tos->tos) = (codes_ty )33;
#line 592
    goto switch_break___0;
    case_35: /* CIL Label */ 
#line 595
    (parser_state_tos->tos) --;
#line 595
    *(parser_state_tos->p_stack + parser_state_tos->tos) = (codes_ty )36;
#line 596
    parser_state_tos->i_l_follow = *(parser_state_tos->il + parser_state_tos->tos);
#line 597
    goto switch_break___0;
    case_28: /* CIL Label */ 
#line 601
    (parser_state_tos->tos) --;
#line 601
    *(parser_state_tos->p_stack + parser_state_tos->tos) = (codes_ty )38;
#line 602
    i = parser_state_tos->tos - 1;
    {
#line 602
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 602
      if ((unsigned int )*(parser_state_tos->p_stack + i) != 32U) {
#line 602
        if ((unsigned int )*(parser_state_tos->p_stack + i) != 33U) {
#line 602
          if (! ((unsigned int )*(parser_state_tos->p_stack + i) != 13U)) {
#line 602
            goto while_break___0;
          }
        } else {
#line 602
          goto while_break___0;
        }
      } else {
#line 602
        goto while_break___0;
      }
#line 602
      i --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 610
    parser_state_tos->i_l_follow = *(parser_state_tos->il + i);
#line 616
    goto switch_break___0;
    case_30: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_31: /* CIL Label */ 
    case_39: /* CIL Label */ 
    case_24: /* CIL Label */ 
    case_21: /* CIL Label */ 
#line 629
    (parser_state_tos->tos) --;
#line 629
    *(parser_state_tos->p_stack + parser_state_tos->tos) = (codes_ty )32;
#line 630
    parser_state_tos->i_l_follow = *(parser_state_tos->il + parser_state_tos->tos);
#line 631
    goto switch_break___0;
    switch_default: /* CIL Label */ 
#line 634
    return;
    switch_break___0: /* CIL Label */ ;
    }
#line 637
    goto switch_break;
    case_30___0: /* CIL Label */ 
#line 640
    if ((unsigned int )*(parser_state_tos->p_stack + (parser_state_tos->tos - 1)) == 36U) {
#line 643
      (parser_state_tos->tos) --;
#line 643
      *(parser_state_tos->p_stack + parser_state_tos->tos) = (codes_ty )37;
#line 644
      goto switch_break;
    } else {
#line 647
      return;
    }
    switch_default___0: /* CIL Label */ 
#line 650
    return;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 662 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/parse.c"
extern void parse_lparen_in_decl(void) 
{ 


  {
  {
#line 664
  inc_pstack();
#line 665
  *(parser_state_tos->p_stack + parser_state_tos->tos) = (codes_ty )32;
#line 666
  *(parser_state_tos->il + parser_state_tos->tos) = parser_state_tos->ind_level;
#line 668
  reduce();
  }
#line 669
  return;
}
}
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 124 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) setlocale)(int __category ,
                                                                                  char const   *__locale ) ;
#line 82 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) textdomain)(char const   *__domainname ) ;
#line 86
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) bindtextdomain)(char const   *__domainname ,
                                                                                       char const   *__dirname ) ;
#line 106 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/lexi.h"
extern codes_ty lexi(void) ;
#line 153 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/indent.h"
char *in_name ;
#line 155
char *in_prog ;
#line 167
unsigned long in_prog_size ;
#line 176
char *s_code_corresponds_to ;
#line 196
int squest ;
#line 222 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/indent.h"
buf_ty save_com  ;
#line 230
int n_real_blanklines ;
#line 232 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/indent.h"
codes_ty prefix_blankline_requested_code  ;
#line 235
int postfix_blankline_requested ;
#line 236 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/indent.h"
codes_ty postfix_blankline_requested_code  ;
#line 326
int embedded_comment_on_line ;
#line 334
int code_lines ;
#line 336
int out_lines ;
#line 345
int paren_target ;
#line 46 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.h"
void set_defaults(void) ;
#line 47
void set_defaults_after(void) ;
#line 49
extern int set_option(char const   *option , char const   *param , int explicit ,
                      char const   *option_source ) ;
#line 55
char *set_profile(void) ;
#line 32 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/output.h"
buf_break_st_ty *buf_break ;
#line 37
void clear_buf_break_list(BOOLEAN *pbreak_line ) ;
#line 50
void set_buf_break(bb_code_ty code , int paren_targ ) ;
#line 59
extern void flush_output(void) ;
#line 61
void open_output(char const   *filename , char const   *mode ) ;
#line 65
extern void reopen_output_trunc(char const   *filename ) ;
#line 68
extern void close_output(struct stat *file_stats , char const   *filename ) ;
#line 75
int output_line_length(void) ;
#line 7 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/handletoken.h"
extern void handle_the_token(codes_ty const   type_code , BOOLEAN *scase , BOOLEAN *force_nl ,
                             BOOLEAN *sp_sw , BOOLEAN *flushed_nl , codes_ty *hd_type ,
                             int *dec_ind , BOOLEAN *last_token_ends_sp , exit_values_ty *file_exit_value ,
                             bb_code_ty const   can_break , BOOLEAN *last_else , BOOLEAN is_procname_definition ,
                             BOOLEAN *pbreak_line ) ;
#line 22
extern void check_code_size(void) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/handletoken.h"
__inline static void need_chars(buf_ty *bp , int needed ) 
{ 
  int current_size ;
  char *tmp ;

  {
#line 32
  current_size = (int )(bp->end - bp->ptr);
#line 34
  if (current_size + needed >= bp->size) {
    {
#line 36
    bp->size = (int )((((unsigned long )(current_size + needed) + 1024UL) - 1UL) & 0xfffffffffffffc00UL);
#line 37
    bp->ptr = xrealloc(bp->ptr, (unsigned int )bp->size);
    }
#line 38
    if ((unsigned long )bp->ptr == (unsigned long )((void *)0)) {
      {
#line 40
      tmp = gettext("Ran out of memory");
#line 40
      fatal((char const   *)tmp, (char const   *)0);
      }
    }
#line 43
    bp->end = bp->ptr + current_size;
  }
#line 45
  return;
}
}
#line 90 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/indent.c"
char *labbuf  =    (char *)((void *)0);
#line 91 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/indent.c"
char *s_lab  =    (char *)((void *)0);
#line 92 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/indent.c"
char *e_lab  =    (char *)((void *)0);
#line 93 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/indent.c"
char *l_lab  =    (char *)((void *)0);
#line 94 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/indent.c"
char *codebuf  =    (char *)((void *)0);
#line 95 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/indent.c"
char *s_code  =    (char *)((void *)0);
#line 96 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/indent.c"
char *e_code  =    (char *)((void *)0);
#line 97 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/indent.c"
char *l_code  =    (char *)((void *)0);
#line 98 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/indent.c"
char *combuf  =    (char *)((void *)0);
#line 99 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/indent.c"
char *s_com  =    (char *)((void *)0);
#line 100 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/indent.c"
char *e_com  =    (char *)((void *)0);
#line 101 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/indent.c"
char *l_com  =    (char *)((void *)0);
#line 102 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/indent.c"
char *s_code_corresponds_to  =    (char *)((void *)0);
#line 104 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/indent.c"
char *bp_save  =    (char *)((void *)0);
#line 105 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/indent.c"
char *be_save  =    (char *)((void *)0);
#line 106 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/indent.c"
int code_lines  =    0;
#line 107 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/indent.c"
int line_no  =    0;
#line 108 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/indent.c"
int break_comma  =    0;
#line 109 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/indent.c"
int n_real_blanklines  =    0;
#line 110 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/indent.c"
int prefix_blankline_requested  =    0;
#line 112 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/indent.c"
int postfix_blankline_requested  =    0;
#line 114 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/indent.c"
char *in_name  =    (char *)0;
#line 115 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/indent.c"
file_buffer_ty *current_input  =    (file_buffer_ty *)0;
#line 116 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/indent.c"
int embedded_comment_on_line  =    0;
#line 117 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/indent.c"
int else_or_endif  =    0;
#line 118 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/indent.c"
int *di_stack  =    (int *)((void *)0);
#line 119 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/indent.c"
int di_stack_alloc  =    0;
#line 120 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/indent.c"
int squest  =    0;
#line 122 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/indent.c"
unsigned long in_prog_size  =    0UL;
#line 123 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/indent.c"
char *in_prog  =    (char *)((void *)0);
#line 128 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/indent.c"
int paren_target  =    0;
#line 138 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/indent.c"
static void sw_buffer(void) 
{ 


  {
  {
#line 140
  parser_state_tos->search_brace = 0;
#line 141
  bp_save = buf_ptr;
#line 142
  be_save = buf_end;
#line 143
  buf_ptr = save_com.ptr;
#line 144
  need_chars(& save_com, 1);
#line 145
  buf_end = save_com.end;
#line 146
  save_com.end = save_com.ptr;
  }
#line 147
  return;
}
}
#line 153 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/indent.c"
static BOOLEAN search_brace(codes_ty *type_code , BOOLEAN *force_nl , BOOLEAN *flushed_nl ,
                            BOOLEAN *last_else , BOOLEAN *is_procname_definition ,
                            BOOLEAN *pbreak_line ) 
{ 
  char *p ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  int just_saw_nl ;
  int tmp___16 ;

  {
  {
#line 161
  while (1) {
    while_continue: /* CIL Label */ ;
#line 161
    if (! parser_state_tos->search_brace) {
#line 161
      goto while_break;
    }
    {
#line 170
    if ((unsigned int )*type_code == 1U) {
#line 170
      goto case_1;
    }
#line 174
    if ((unsigned int )*type_code == 23U) {
#line 174
      goto case_23;
    }
#line 177
    if ((unsigned int )*type_code == 13U) {
#line 177
      goto case_13;
    }
#line 234
    if ((unsigned int )*type_code == 19U) {
#line 234
      goto case_19;
    }
#line 308
    goto switch_default;
    case_1: /* CIL Label */ 
#line 171
    line_no ++;
#line 172
    *flushed_nl = (BOOLEAN )1;
#line 173
    goto switch_break;
    case_23: /* CIL Label */ 
#line 175
    goto switch_break;
    case_13: /* CIL Label */ 
#line 180
    if ((unsigned long )save_com.end == (unsigned long )save_com.ptr) {
#line 182
      parser_state_tos->search_brace = 0;
#line 183
      return ((BOOLEAN )1);
    }
#line 188
    if (settings.btype_2) {
#line 188
      if ((unsigned int )parser_state_tos->last_token != 14U) {
#line 191
        if ((unsigned int )parser_state_tos->last_token == 27U) {
#line 191
          if ((unsigned long )save_com.end > (unsigned long )(save_com.ptr + 4)) {
#line 191
            if ((int )*(save_com.end + -2) == 42) {
#line 191
              if ((int )*(save_com.end + -1) == 47) {
#line 191
                if ((int )*(save_com.ptr + 2) == 47) {
#line 191
                  if ((int )*(save_com.ptr + 3) == 42) {
#line 200
                    p = save_com.ptr + 4;
                    {
#line 200
                    while (1) {
                      while_continue___0: /* CIL Label */ ;
#line 200
                      if ((int )*p != 10) {
#line 200
                        if (! ((unsigned long )p < (unsigned long )(save_com.end + -2))) {
#line 200
                          goto while_break___0;
                        }
                      } else {
#line 200
                        goto while_break___0;
                      }
#line 200
                      p ++;
                    }
                    while_break___0: /* CIL Label */ ;
                    }
#line 205
                    if ((int )*p != 10) {
#line 207
                      tmp = save_com.end;
#line 207
                      (save_com.end) ++;
#line 207
                      *tmp = (char )'\n';
                    }
                  }
                }
              }
            }
          }
        }
        {
#line 213
        *(save_com.ptr + 0) = (char )'{';
#line 214
        save_com.len = 1;
#line 215
        save_com.column = current_column();
        }
      } else {
#line 188
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 224
      tmp___0 = save_com.end;
#line 224
      (save_com.end) ++;
#line 224
      *tmp___0 = (char )'\n';
#line 225
      tmp___1 = save_com.end;
#line 225
      (save_com.end) ++;
#line 225
      *tmp___1 = (char )'{';
#line 226
      save_com.len += 2;
    }
    {
#line 231
    sw_buffer();
    }
#line 232
    goto switch_break;
    case_19: /* CIL Label */ 
#line 238
    if (! *flushed_nl) {
#line 238
      goto _L___0;
    } else
#line 238
    if ((unsigned long )save_com.end != (unsigned long )save_com.ptr) {
      _L___0: /* CIL Label */ 
      {
#line 240
      need_chars(& save_com, 10);
      }
#line 242
      if ((unsigned long )save_com.end == (unsigned long )save_com.ptr) {
        {
#line 247
        save_com.start_column = current_column();
#line 248
        tmp___2 = (char )' ';
#line 248
        *(save_com.ptr + 1) = tmp___2;
#line 248
        *(save_com.ptr + 0) = tmp___2;
#line 249
        save_com.end = save_com.ptr + 2;
#line 250
        save_com.len = 2;
#line 251
        save_com.column = current_column();
        }
      } else {
#line 255
        tmp___3 = save_com.end;
#line 255
        (save_com.end) ++;
#line 255
        *tmp___3 = (char )'\n';
#line 257
        tmp___4 = save_com.end;
#line 257
        (save_com.end) ++;
#line 257
        *tmp___4 = (char )' ';
#line 258
        save_com.len += 2;
#line 259
        line_no --;
      }
#line 262
      tmp___5 = save_com.end;
#line 262
      (save_com.end) ++;
#line 262
      *tmp___5 = (char )'/';
#line 263
      tmp___6 = save_com.end;
#line 263
      (save_com.end) ++;
#line 263
      *tmp___6 = (char )'*';
      {
#line 265
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 274
        need_chars(& save_com, 2);
#line 275
        tmp___7 = buf_ptr;
#line 275
        buf_ptr ++;
#line 275
        *(save_com.end) = *tmp___7;
#line 276
        (save_com.len) ++;
        }
#line 278
        if ((unsigned long )buf_ptr >= (unsigned long )buf_end) {
          {
#line 280
          fill_buffer();
          }
#line 282
          if (had_eof) {
            {
#line 284
            tmp___8 = gettext("EOF encountered in comment");
#line 284
            tmp___9 = gettext("Error");
#line 284
            message(tmp___9, tmp___8, (unsigned int *)0, (unsigned int *)0);
            }
#line 285
            return ((BOOLEAN )3);
          }
        }
#line 289
        tmp___10 = save_com.end;
#line 289
        (save_com.end) ++;
#line 289
        if ((int )*tmp___10 == 42) {
#line 289
          if ((int )*buf_ptr == 47) {
#line 291
            goto while_break___1;
          }
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 295
      tmp___11 = save_com.end;
#line 295
      (save_com.end) ++;
#line 295
      *tmp___11 = (char )'/';
#line 296
      (save_com.len) ++;
#line 298
      buf_ptr ++;
#line 298
      if ((unsigned long )buf_ptr >= (unsigned long )buf_end) {
        {
#line 300
        fill_buffer();
        }
      }
#line 303
      goto switch_break;
    }
    switch_default: /* CIL Label */ 
#line 312
    if ((unsigned int )*type_code == 25U) {
#line 312
      if ((int )*token == 105) {
#line 312
        if (*last_else) {
#line 317
          *force_nl = (BOOLEAN )0;
        } else {
#line 312
          goto _L___4;
        }
      } else {
#line 312
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
#line 312
    if ((unsigned int )*type_code == 27U) {
#line 312
      if ((unsigned long )e_code != (unsigned long )s_code) {
#line 312
        if ((int )*(e_code + -1) == 125) {
#line 317
          *force_nl = (BOOLEAN )0;
        } else {
#line 312
          goto _L___2;
        }
      } else {
#line 312
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 319
    if (*flushed_nl) {
#line 321
      *force_nl = (BOOLEAN )1;
    }
#line 328
    if ((unsigned long )save_com.end == (unsigned long )save_com.ptr) {
#line 332
      parser_state_tos->search_brace = 0;
#line 333
      return ((BOOLEAN )1);
    }
#line 336
    if (*force_nl) {
      {
#line 338
      *force_nl = (BOOLEAN )0;
#line 339
      line_no --;
#line 340
      need_chars(& save_com, 2);
#line 341
      tmp___12 = save_com.end;
#line 341
      (save_com.end) ++;
#line 341
      *tmp___12 = (char )'\n';
#line 342
      (save_com.len) ++;
      }
#line 343
      if (settings.verbose) {
#line 343
        if (! *flushed_nl) {
          {
#line 345
          tmp___13 = gettext("Line broken");
#line 345
          tmp___14 = gettext("Warning");
#line 345
          message(tmp___14, tmp___13, (unsigned int *)0, (unsigned int *)0);
          }
        }
      }
#line 348
      *flushed_nl = (BOOLEAN )0;
    }
    {
#line 353
    tmp___15 = save_com.end;
#line 353
    (save_com.end) ++;
#line 353
    *tmp___15 = (char )' ';
#line 354
    (save_com.len) ++;
#line 355
    buf_ptr = token;
#line 362
    parser_state_tos->procname = (char *)"\000";
#line 363
    parser_state_tos->procname_end = (char *)"\000";
#line 364
    parser_state_tos->classname = (char *)"\000";
#line 365
    parser_state_tos->classname_end = (char *)"\000";
#line 370
    sw_buffer();
    }
#line 371
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 374
    if ((unsigned int )*type_code != 0U) {
#line 376
      just_saw_nl = 0;
#line 378
      if ((unsigned int )*type_code == 1U) {
#line 380
        just_saw_nl = 1;
      }
      {
#line 383
      *type_code = lexi();
      }
#line 385
      if ((unsigned int )*type_code == 1U) {
#line 385
        if (just_saw_nl == 1) {
          {
#line 389
          dump_line(1, & paren_target, pbreak_line);
#line 390
          *flushed_nl = (BOOLEAN )1;
          }
        } else {
#line 385
          goto _L___5;
        }
      } else
      _L___5: /* CIL Label */ 
#line 385
      if ((unsigned int )*type_code == 19U) {
#line 385
        if (parser_state_tos->last_saw_nl) {
#line 385
          if ((unsigned int )parser_state_tos->last_token != 27U) {
            {
#line 389
            dump_line(1, & paren_target, pbreak_line);
#line 390
            *flushed_nl = (BOOLEAN )1;
            }
          }
        }
      }
#line 393
      if ((int )*(parser_state_tos->procname + 0) != 0) {
#line 393
        if (parser_state_tos->in_parameter_declaration) {
#line 393
          tmp___16 = 1;
        } else {
#line 393
          tmp___16 = 0;
        }
      } else {
#line 393
        tmp___16 = 0;
      }
#line 393
      *is_procname_definition = (BOOLEAN )tmp___16;
    }
#line 397
    if ((unsigned int )*type_code == 15U) {
#line 397
      if (*flushed_nl) {
#line 397
        if (! settings.procnames_start_line) {
#line 397
          if (parser_state_tos->in_decl) {
#line 397
            if ((int )*(parser_state_tos->procname + 0) != 0) {
#line 402
              *flushed_nl = (BOOLEAN )0;
            }
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 406
  *last_else = (BOOLEAN )0;
#line 408
  return ((BOOLEAN )1);
}
}
#line 415 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/indent.c"
static exit_values_ty indent_main_loop(BOOLEAN *pbreak_line ) 
{ 
  codes_ty hd_type ;
  char *t_ptr ;
  codes_ty type_code ;
  exit_values_ty file_exit_value ;
  int dec_ind ;
  BOOLEAN scase ;
  BOOLEAN flushed_nl ;
  BOOLEAN sp_sw ;
  BOOLEAN force_nl ;
  BOOLEAN last_token_ends_sp ;
  BOOLEAN last_else ;
  BOOLEAN is_procname_definition ;
  bb_code_ty can_break ;
  int tmp ;
  int tmp___0 ;
  BOOLEAN tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;

  {
#line 418
  hd_type = (codes_ty )0;
#line 419
  t_ptr = (char *)((void *)0);
#line 420
  type_code = (codes_ty )4;
#line 421
  file_exit_value = (exit_values_ty )0;
#line 422
  dec_ind = 0;
#line 424
  scase = (BOOLEAN )0;
#line 429
  sp_sw = (BOOLEAN )0;
#line 431
  force_nl = (BOOLEAN )0;
#line 440
  last_token_ends_sp = (BOOLEAN )0;
#line 442
  last_else = (BOOLEAN )0;
  {
#line 444
  while (1) {
    while_continue: /* CIL Label */ ;
#line 450
    can_break = (bb_code_ty )0;
#line 452
    if ((unsigned int )type_code != 1U) {
#line 454
      can_break = parser_state_tos->can_break;
    }
    {
#line 457
    parser_state_tos->last_saw_nl = 0;
#line 458
    parser_state_tos->can_break = (bb_code_ty )0;
#line 460
    type_code = lexi();
    }
#line 471
    if (settings.max_col > 0) {
#line 471
      if ((unsigned long )buf_break != (unsigned long )((void *)0)) {
#line 471
        if ((unsigned int )parser_state_tos->last_token == 15U) {
#line 471
          if ((unsigned int )type_code != 18U) {
#line 471
            if ((unsigned int )type_code != 12U) {
#line 471
              if ((unsigned int )type_code != 1U) {
#line 471
                if ((unsigned int )type_code != 23U) {
#line 471
                  if ((unsigned int )type_code != 3U) {
#line 471
                    if ((unsigned int )type_code != 40U) {
#line 471
                      goto _L;
                    } else {
#line 471
                      goto _L___5;
                    }
                  } else {
#line 471
                    goto _L___5;
                  }
                } else {
#line 471
                  goto _L___5;
                }
              } else {
#line 471
                goto _L___5;
              }
            } else {
#line 471
              goto _L___5;
            }
          } else {
#line 471
            goto _L___5;
          }
        } else
        _L___5: /* CIL Label */ 
#line 471
        if ((unsigned int )parser_state_tos->last_token == 3U) {
#line 471
          if ((unsigned int )type_code != 18U) {
#line 471
            if ((unsigned int )type_code != 3U) {
              _L: /* CIL Label */ 
              {
#line 471
              tmp = output_line_length();
              }
#line 471
              if (tmp > settings.max_col) {
#line 485
                *pbreak_line = (BOOLEAN )1;
              }
            }
          }
        }
      }
    }
#line 488
    if ((int )last_token_ends_sp > 0) {
#line 490
      last_token_ends_sp = (BOOLEAN )((int )last_token_ends_sp - 1);
    }
#line 493
    if ((int )*(parser_state_tos->procname + 0) != 0) {
#line 493
      if (parser_state_tos->in_parameter_declaration) {
#line 493
        tmp___0 = 1;
      } else {
#line 493
        goto _L___6;
      }
    } else
    _L___6: /* CIL Label */ 
#line 493
    if ((int )*(parser_state_tos->classname + 0) != 0) {
#line 493
      tmp___0 = 1;
    } else {
#line 493
      tmp___0 = 0;
    }
    {
#line 493
    is_procname_definition = (BOOLEAN )tmp___0;
#line 503
    flushed_nl = (BOOLEAN )0;
#line 505
    tmp___1 = search_brace(& type_code, & force_nl, & flushed_nl, & last_else, & is_procname_definition,
                           pbreak_line);
    }
#line 505
    if (! tmp___1) {
#line 509
      return ((exit_values_ty )3);
    }
#line 512
    if ((unsigned int )type_code == 0U) {
#line 515
      if ((unsigned long )s_lab != (unsigned long )e_lab) {
        {
#line 517
        dump_line(1, & paren_target, pbreak_line);
        }
      } else
#line 515
      if ((unsigned long )s_code != (unsigned long )e_code) {
        {
#line 517
        dump_line(1, & paren_target, pbreak_line);
        }
      } else
#line 515
      if ((unsigned long )s_com != (unsigned long )e_com) {
        {
#line 517
        dump_line(1, & paren_target, pbreak_line);
        }
      }
#line 520
      if (parser_state_tos->tos > 1) {
        {
#line 522
        tmp___2 = gettext("Unexpected end of file");
#line 522
        tmp___3 = gettext("Error");
#line 522
        message(tmp___3, tmp___2, (unsigned int *)0, (unsigned int *)0);
#line 523
        file_exit_value = (exit_values_ty )2;
        }
      }
#line 526
      if (settings.verbose) {
        {
#line 528
        tmp___4 = gettext("There were %d non-blank output lines and %d comments\n");
#line 528
        printf((char const   */* __restrict  */)tmp___4, out_lines, com_lines);
        }
#line 530
        if (com_lines > 0) {
#line 530
          if (code_lines > 0) {
            {
#line 532
            tmp___5 = gettext("(Lines with comments)/(Lines with code): %6.3f\n");
#line 532
            printf((char const   */* __restrict  */)tmp___5, (1.0 * (double )com_lines) / (double )code_lines);
            }
          }
        }
      }
      {
#line 536
      flush_output();
      }
#line 538
      return (file_exit_value);
    }
#line 541
    if ((unsigned int )type_code != 19U) {
#line 541
      if ((unsigned int )type_code != 20U) {
#line 541
        if ((unsigned int )type_code != 1U) {
#line 541
          if ((unsigned int )type_code != 22U) {
#line 541
            if ((unsigned int )type_code != 23U) {
#line 547
              if (force_nl) {
#line 547
                if ((unsigned int )type_code != 12U) {
#line 547
                  if ((unsigned int )type_code != 13U) {
#line 547
                    goto _L___7;
                  } else
#line 547
                  if (! parser_state_tos->in_decl) {
#line 547
                    if (! settings.btype_2) {
#line 547
                      goto _L___7;
                    } else {
#line 547
                      goto _L___9;
                    }
                  } else
                  _L___9: /* CIL Label */ 
#line 547
                  if (parser_state_tos->in_decl) {
#line 547
                    if (! settings.braces_on_struct_decl_line) {
#line 547
                      goto _L___7;
                    } else {
#line 547
                      goto _L___8;
                    }
                  } else
                  _L___8: /* CIL Label */ 
#line 547
                  if ((unsigned int )parser_state_tos->last_token == 14U) {
                    _L___7: /* CIL Label */ 
#line 554
                    if (settings.verbose) {
#line 554
                      if (! flushed_nl) {
                        {
#line 556
                        tmp___6 = gettext("Line broken 2");
#line 556
                        tmp___7 = gettext("Warning");
#line 556
                        message(tmp___7, tmp___6, (unsigned int *)0, (unsigned int *)0);
                        }
                      }
                    }
                    {
#line 559
                    flushed_nl = (BOOLEAN )0;
#line 560
                    dump_line(1, & paren_target, pbreak_line);
#line 561
                    parser_state_tos->want_blank = 0;
#line 562
                    force_nl = (BOOLEAN )0;
                    }
                  }
                }
              }
#line 565
              parser_state_tos->in_stmt = 1;
#line 569
              if ((unsigned long )s_com != (unsigned long )e_com) {
#line 579
                if ((unsigned long )e_code != (unsigned long )s_code) {
                  {
#line 581
                  set_buf_break((bb_code_ty )2, paren_target);
#line 582
                  tmp___8 = e_code;
#line 582
                  e_code ++;
#line 582
                  *tmp___8 = (char )' ';
#line 583
                  embedded_comment_on_line = 2;
                  }
                } else {
#line 587
                  embedded_comment_on_line = 1;
                }
#line 590
                t_ptr = s_com;
                {
#line 590
                while (1) {
                  while_continue___0: /* CIL Label */ ;
#line 590
                  if (! *t_ptr) {
#line 590
                    goto while_break___0;
                  }
                  {
#line 592
                  check_code_size();
#line 593
                  tmp___9 = e_code;
#line 593
                  e_code ++;
#line 593
                  *tmp___9 = *t_ptr;
#line 590
                  t_ptr ++;
                  }
                }
                while_break___0: /* CIL Label */ ;
                }
                {
#line 596
                set_buf_break((bb_code_ty )3, paren_target);
#line 597
                tmp___10 = e_code;
#line 597
                e_code ++;
#line 597
                *tmp___10 = (char )' ';
#line 598
                *e_code = (char )'\000';
#line 599
                parser_state_tos->want_blank = 0;
#line 600
                e_com = s_com;
                }
              }
            } else {
#line 541
              goto _L___14;
            }
          } else {
#line 541
            goto _L___14;
          }
        } else {
#line 541
          goto _L___14;
        }
      } else {
#line 541
        goto _L___14;
      }
    } else
    _L___14: /* CIL Label */ 
#line 603
    if ((unsigned int )type_code != 19U) {
#line 603
      if ((unsigned int )type_code != 20U) {
#line 603
        if (settings.break_function_decl_args) {
#line 603
          if (! ((unsigned int )parser_state_tos->last_token == 18U)) {
#line 603
            goto _L___10;
          }
        } else
        _L___10: /* CIL Label */ 
#line 603
        if ((unsigned int )parser_state_tos->last_token == 18U) {
#line 603
          if (! (! settings.leave_comma)) {
#line 615
            force_nl = (BOOLEAN )0;
          }
        } else {
#line 615
          force_nl = (BOOLEAN )0;
        }
      }
    }
    {
#line 624
    check_code_size();
#line 628
    handle_the_token((codes_ty const   )type_code, & scase, & force_nl, & sp_sw, & flushed_nl,
                     & hd_type, & dec_ind, & last_token_ends_sp, & file_exit_value,
                     (bb_code_ty const   )can_break, & last_else, is_procname_definition,
                     pbreak_line);
#line 633
    *e_code = (char )'\000';
    }
#line 635
    if ((unsigned int )type_code != 19U) {
#line 635
      if ((unsigned int )type_code != 20U) {
#line 635
        if ((unsigned int )type_code != 1U) {
#line 635
          if ((unsigned int )type_code != 22U) {
#line 635
            if ((unsigned int )type_code != 23U) {
#line 641
              parser_state_tos->last_token = type_code;
            }
          }
        }
      }
    }
#line 652
    if (settings.max_col > 0) {
#line 652
      if ((unsigned long )buf_break != (unsigned long )((void *)0)) {
#line 654
        if ((unsigned int )type_code == 6U) {
#line 654
          goto _L___15;
        } else
#line 654
        if ((unsigned int )type_code == 7U) {
#line 654
          goto _L___15;
        } else
#line 654
        if ((unsigned int )type_code == 8U) {
#line 654
          goto _L___15;
        } else
#line 654
        if ((unsigned int )type_code == 10U) {
#line 654
          if (scase) {
#line 654
            goto _L___15;
          } else
#line 654
          if (squest <= 0) {
#line 654
            goto _L___15;
          } else {
#line 654
            goto _L___17;
          }
        } else
        _L___17: /* CIL Label */ 
#line 654
        if ((unsigned int )type_code == 12U) {
#line 654
          goto _L___15;
        } else
#line 654
        if ((unsigned int )type_code == 26U) {
#line 654
          goto _L___15;
        } else
#line 654
        if ((unsigned int )type_code == 27U) {
#line 654
          goto _L___15;
        } else
#line 654
        if ((unsigned int )type_code == 15U) {
#line 654
          if ((int )*token == 34) {
#line 654
            goto _L___15;
          } else {
#line 654
            goto _L___16;
          }
        } else
        _L___16: /* CIL Label */ 
#line 654
        if ((unsigned int )type_code == 40U) {
#line 654
          goto _L___15;
        } else
#line 654
        if ((unsigned int )type_code == 18U) {
          _L___15: /* CIL Label */ 
          {
#line 654
          tmp___11 = output_line_length();
          }
#line 654
          if (tmp___11 > settings.max_col) {
#line 666
            *pbreak_line = (BOOLEAN )1;
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 677 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/indent.c"
static exit_values_ty indent(file_buffer_ty *this_file ) 
{ 
  BOOLEAN break_line ;
  int tmp ;
  exit_values_ty tmp___0 ;

  {
  {
#line 680
  break_line = (BOOLEAN )0;
#line 682
  in_prog = this_file->data;
#line 683
  in_prog_pos = this_file->data;
#line 684
  in_prog_size = this_file->size;
#line 685
  squest = 0;
#line 686
  n_real_blanklines = 0;
#line 687
  postfix_blankline_requested = 0;
#line 689
  clear_buf_break_list(& break_line);
  }
#line 691
  if (settings.decl_com_ind <= 0) {
#line 693
    if (settings.ljust_decl) {
#line 693
      if (settings.com_ind <= 10) {
#line 693
        tmp = 2;
      } else {
#line 693
        tmp = settings.com_ind - 8;
      }
#line 693
      settings.decl_com_ind = tmp;
    } else {
#line 693
      settings.decl_com_ind = settings.com_ind;
    }
  }
#line 698
  if (settings.continuation_indent == 0) {
#line 700
    settings.continuation_indent = settings.ind_size;
  }
#line 703
  if (settings.paren_indent == -1) {
#line 705
    settings.paren_indent = settings.continuation_indent;
  }
#line 708
  if (settings.case_brace_indent == -1) {
#line 710
    settings.case_brace_indent = settings.ind_size;
  }
  {
#line 713
  fill_buffer();
#line 715
  tmp___0 = indent_main_loop(& break_line);
  }
#line 715
  return (tmp___0);
}
}
#line 723 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/indent.c"
static char *handle_profile(int argc , char **argv ) 
{ 
  int i ;
  char *profile_pathname ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 728
  profile_pathname = (char *)((void *)0);
#line 730
  i = 1;
  {
#line 730
  while (1) {
    while_continue: /* CIL Label */ ;
#line 730
    if (! (i < argc)) {
#line 730
      goto while_break;
    }
    {
#line 732
    tmp = strcmp((char const   *)*(argv + i), "-npro");
    }
#line 732
    if (tmp == 0) {
#line 736
      goto while_break;
    } else {
      {
#line 732
      tmp___0 = strcmp((char const   *)*(argv + i), "--ignore-profile");
      }
#line 732
      if (tmp___0 == 0) {
#line 736
        goto while_break;
      } else {
        {
#line 732
        tmp___1 = strcmp((char const   *)*(argv + i), "+ignore-profile");
        }
#line 732
        if (tmp___1 == 0) {
#line 736
          goto while_break;
        }
      }
    }
#line 730
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 740
  if (i >= argc) {
    {
#line 742
    profile_pathname = set_profile();
    }
  }
#line 745
  return (profile_pathname);
}
}
#line 752 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/indent.c"
static char *out_name  =    (char *)0;
#line 753 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/indent.c"
static int input_files  =    0;
#line 754 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/indent.c"
static char **in_file_names  =    (char **)((void *)0);
#line 755 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/indent.c"
static int max_input_files  =    128;
#line 761 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/indent.c"
static exit_values_ty process_args(int argc , char **argv , BOOLEAN *using_stdin ) 
{ 
  int i ;
  exit_values_ty exit_status ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 767
  exit_status = (exit_values_ty )0;
#line 769
  i = 1;
  {
#line 769
  while (1) {
    while_continue: /* CIL Label */ ;
#line 769
    if (! (i < argc)) {
#line 769
      goto while_break;
    }
#line 771
    if ((int )*(*(argv + i)) != 45) {
#line 771
      if ((int )*(*(argv + i)) != 43) {
#line 773
        if (settings.expect_output_file == 1) {
#line 775
          if ((unsigned long )out_name != (unsigned long )((char *)0)) {
            {
#line 777
            tmp = gettext("indent: only one output file (2nd was %s)\n");
#line 777
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
                    *(argv + i));
#line 780
            exit_status = (exit_values_ty )1;
            }
#line 781
            goto while_break;
          }
#line 784
          if (input_files > 1) {
            {
#line 786
            tmp___0 = gettext("indent: only one input file when output file is specified\n");
#line 786
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0);
#line 788
            exit_status = (exit_values_ty )1;
            }
#line 789
            goto while_break;
          }
#line 792
          out_name = *(argv + i);
#line 793
          settings.expect_output_file = 0;
#line 794
          goto __Cont;
        } else {
#line 798
          if (*using_stdin) {
            {
#line 800
            tmp___1 = gettext("indent: can\'t have filenames when specifying standard input\n");
#line 800
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1);
#line 802
            exit_status = (exit_values_ty )1;
            }
#line 803
            goto while_break;
          }
#line 806
          input_files ++;
#line 808
          if (input_files > 1) {
#line 810
            if ((unsigned long )out_name != (unsigned long )((char *)0)) {
              {
#line 812
              tmp___2 = gettext("indent: only one input file when output file is specified\n");
#line 812
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___2);
#line 814
              exit_status = (exit_values_ty )1;
              }
#line 815
              goto while_break;
            }
#line 818
            if (settings.use_stdout != 0) {
              {
#line 820
              tmp___3 = gettext("indent: only one input file when stdout is used\n");
#line 820
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___3);
#line 822
              exit_status = (exit_values_ty )1;
              }
#line 823
              goto while_break;
            }
#line 826
            if (input_files > max_input_files) {
              {
#line 828
              max_input_files = 2 * max_input_files;
#line 829
              tmp___4 = xrealloc((char *)in_file_names, (unsigned int )((unsigned long )max_input_files * sizeof(char *)));
#line 829
              in_file_names = (char **)tmp___4;
              }
            }
          }
#line 836
          *(in_file_names + (input_files - 1)) = *(argv + i);
        }
      } else {
#line 771
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 843
      tmp___9 = strcmp((char const   *)*(argv + i), "-");
      }
#line 843
      if (tmp___9 == 0) {
#line 845
        if (input_files > 0) {
          {
#line 847
          tmp___5 = gettext("indent: can\'t have filenames when specifying standard input\n");
#line 847
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___5);
#line 849
          exit_status = (exit_values_ty )1;
          }
#line 850
          goto while_break;
        }
#line 853
        *using_stdin = (BOOLEAN )1;
      } else {
        {
#line 857
        tmp___6 = gettext("command line");
        }
#line 857
        if (i < argc) {
#line 857
          tmp___7 = *(argv + (i + 1));
        } else {
#line 857
          tmp___7 = (char *)0;
        }
        {
#line 857
        tmp___8 = set_option((char const   *)*(argv + i), (char const   *)tmp___7,
                             1, (char const   *)tmp___6);
#line 857
        i += tmp___8;
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 769
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 862
  return (exit_status);
}
}
#line 869 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/indent.c"
static exit_values_ty indent_multiple_files(void) 
{ 
  exit_values_ty exit_status ;
  int i ;
  exit_values_ty status ;
  struct stat file_stats ;

  {
#line 871
  exit_status = (exit_values_ty )0;
#line 877
  i = 0;
  {
#line 877
  while (1) {
    while_continue: /* CIL Label */ ;
#line 877
    if (! input_files) {
#line 877
      goto while_break;
    }
    {
#line 882
    in_name = *(in_file_names + i);
#line 883
    out_name = *(in_file_names + i);
#line 884
    current_input = read_file(*(in_file_names + i), & file_stats);
#line 886
    open_output((char const   *)out_name, "r+");
#line 888
    make_backup(current_input, (struct stat  const  *)(& file_stats));
#line 892
    reopen_output_trunc((char const   *)out_name);
#line 894
    reset_parser();
#line 895
    status = indent(current_input);
    }
#line 897
    if ((unsigned int )status > (unsigned int )exit_status) {
#line 899
      exit_status = status;
    }
#line 902
    if (settings.preserve_mtime) {
      {
#line 904
      close_output(& file_stats, (char const   *)out_name);
      }
    } else {
      {
#line 908
      close_output((struct stat *)((void *)0), (char const   *)out_name);
      }
    }
#line 877
    i ++;
#line 877
    input_files --;
  }
  while_break: /* CIL Label */ ;
  }
#line 912
  return (exit_status);
}
}
#line 920 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/indent.c"
static exit_values_ty indent_single_file(BOOLEAN using_stdin ) 
{ 
  exit_values_ty exit_status ;
  struct stat file_stats ;

  {
#line 922
  exit_status = (exit_values_ty )0;
#line 925
  if (input_files == 0) {
    {
#line 927
    input_files = 1;
#line 928
    *(in_file_names + 0) = (char *)"Standard input";
#line 929
    in_name = *(in_file_names + 0);
#line 930
    current_input = read_stdin();
    }
  } else
#line 925
  if (using_stdin) {
    {
#line 927
    input_files = 1;
#line 928
    *(in_file_names + 0) = (char *)"Standard input";
#line 929
    in_name = *(in_file_names + 0);
#line 930
    current_input = read_stdin();
    }
  } else {
    {
#line 936
    in_name = *(in_file_names + 0);
#line 937
    current_input = read_file(*(in_file_names + 0), & file_stats);
    }
#line 939
    if (! out_name) {
#line 939
      if (! settings.use_stdout) {
        {
#line 941
        out_name = *(in_file_names + 0);
#line 942
        make_backup(current_input, (struct stat  const  *)(& file_stats));
        }
      }
    }
  }
#line 949
  if (settings.use_stdout) {
    {
#line 951
    open_output((char const   *)((void *)0), (char const   *)((void *)0));
    }
  } else
#line 949
  if (! out_name) {
    {
#line 951
    open_output((char const   *)((void *)0), (char const   *)((void *)0));
    }
  } else {
    {
#line 955
    open_output((char const   *)out_name, "w");
    }
  }
  {
#line 958
  reset_parser();
#line 960
  exit_status = indent(current_input);
  }
#line 962
  if (input_files > 0) {
#line 962
    if (! using_stdin) {
#line 962
      if (settings.preserve_mtime) {
        {
#line 964
        close_output(& file_stats, (char const   *)out_name);
        }
      } else {
        {
#line 968
        close_output((struct stat *)((void *)0), (char const   *)out_name);
        }
      }
    } else {
      {
#line 968
      close_output((struct stat *)((void *)0), (char const   *)out_name);
      }
    }
  } else {
    {
#line 968
    close_output((struct stat *)((void *)0), (char const   *)out_name);
    }
  }
#line 971
  return (exit_status);
}
}
#line 979 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/indent.c"
static exit_values_ty indent_all(BOOLEAN using_stdin ) 
{ 
  exit_values_ty exit_status ;

  {
#line 982
  exit_status = (exit_values_ty )0;
#line 984
  if (input_files > 1) {
    {
#line 986
    exit_status = indent_multiple_files();
    }
  } else {
    {
#line 992
    exit_status = indent_single_file(using_stdin);
    }
  }
#line 996
  return (exit_status);
}
}
#line 1003 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/indent.c"
int main(int argc , char **argv ) 
{ 
  char *profile_pathname ;
  BOOLEAN using_stdin ;
  exit_values_ty exit_status ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 1007
  profile_pathname = (char *)0;
#line 1008
  using_stdin = (BOOLEAN )0;
#line 1012
  setlocale(6, "");
#line 1014
  bindtextdomain("indent", "/usr/local/share/locale");
#line 1015
  textdomain("indent");
#line 1032
  init_parser();
#line 1033
  initialize_backups();
#line 1034
  exit_status = (exit_values_ty )0;
#line 1036
  input_files = 0;
#line 1037
  tmp = xmalloc((unsigned int )((unsigned long )max_input_files * sizeof(char *)));
#line 1037
  in_file_names = (char **)tmp;
#line 1039
  set_defaults();
#line 1041
  profile_pathname = handle_profile(argc, argv);
#line 1043
  exit_status = process_args(argc, argv, & using_stdin);
  }
#line 1045
  if ((unsigned int )exit_status == 0U) {
#line 1047
    if (settings.verbose) {
#line 1047
      if (profile_pathname) {
        {
#line 1049
        tmp___0 = gettext("Read profile %s\n");
#line 1049
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
                profile_pathname);
        }
      }
    }
    {
#line 1052
    set_defaults_after();
#line 1054
    exit_status = indent_all(using_stdin);
    }
  }
#line 1057
  return ((int )exit_status);
}
}
#line 69 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 102 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/lexi.h"
extern void addkey(char *key , rwcodes_ty val ) ;
#line 191 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/indent.h"
char *token  ;
#line 194 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/indent.h"
char *token_end  ;
#line 73 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/lexi.c"
static templ_ty *user_specials  =    (templ_ty *)0;
#line 76 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/lexi.c"
static unsigned int user_specials_max  =    0U;
#line 79 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/lexi.c"
static unsigned int user_specials_idx  =    0U;
#line 81 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/lexi.c"
char chartype[256]  = 
#line 81
  {      (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)3,      (char)0,      (char)0, 
        (char)1,      (char)3,      (char)3,      (char)0, 
        (char)0,      (char)0,      (char)3,      (char)3, 
        (char)0,      (char)3,      (char)0,      (char)3, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)0,      (char)0, 
        (char)3,      (char)3,      (char)3,      (char)3, 
        (char)0,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)0, 
        (char)0,      (char)0,      (char)3,      (char)1, 
        (char)0,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)0, 
        (char)3,      (char)0,      (char)3,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0};
#line 202
__inline templ_ty *is_reserved(char const   *str , unsigned int len ) ;
#line 52 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/gperf.c"
__inline static unsigned int hash(char const   *str , unsigned int len ) ;
#line 52 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/gperf.c"
static unsigned char asso_values[256]  = 
#line 52
  {      (unsigned char)42,      (unsigned char)42,      (unsigned char)42,      (unsigned char)42, 
        (unsigned char)42,      (unsigned char)42,      (unsigned char)42,      (unsigned char)42, 
        (unsigned char)42,      (unsigned char)42,      (unsigned char)42,      (unsigned char)42, 
        (unsigned char)42,      (unsigned char)42,      (unsigned char)42,      (unsigned char)42, 
        (unsigned char)42,      (unsigned char)42,      (unsigned char)42,      (unsigned char)42, 
        (unsigned char)42,      (unsigned char)42,      (unsigned char)42,      (unsigned char)42, 
        (unsigned char)42,      (unsigned char)42,      (unsigned char)42,      (unsigned char)42, 
        (unsigned char)42,      (unsigned char)42,      (unsigned char)42,      (unsigned char)42, 
        (unsigned char)42,      (unsigned char)42,      (unsigned char)42,      (unsigned char)42, 
        (unsigned char)42,      (unsigned char)42,      (unsigned char)42,      (unsigned char)42, 
        (unsigned char)42,      (unsigned char)42,      (unsigned char)42,      (unsigned char)42, 
        (unsigned char)42,      (unsigned char)42,      (unsigned char)42,      (unsigned char)42, 
        (unsigned char)42,      (unsigned char)42,      (unsigned char)42,      (unsigned char)42, 
        (unsigned char)42,      (unsigned char)42,      (unsigned char)42,      (unsigned char)42, 
        (unsigned char)42,      (unsigned char)42,      (unsigned char)42,      (unsigned char)42, 
        (unsigned char)42,      (unsigned char)42,      (unsigned char)42,      (unsigned char)42, 
        (unsigned char)42,      (unsigned char)42,      (unsigned char)42,      (unsigned char)42, 
        (unsigned char)42,      (unsigned char)42,      (unsigned char)42,      (unsigned char)42, 
        (unsigned char)42,      (unsigned char)42,      (unsigned char)42,      (unsigned char)42, 
        (unsigned char)42,      (unsigned char)42,      (unsigned char)42,      (unsigned char)42, 
        (unsigned char)42,      (unsigned char)42,      (unsigned char)42,      (unsigned char)42, 
        (unsigned char)42,      (unsigned char)42,      (unsigned char)42,      (unsigned char)42, 
        (unsigned char)42,      (unsigned char)42,      (unsigned char)42,      (unsigned char)42, 
        (unsigned char)42,      (unsigned char)42,      (unsigned char)42,      (unsigned char)15, 
        (unsigned char)42,      (unsigned char)12,      (unsigned char)42,      (unsigned char)42, 
        (unsigned char)42,      (unsigned char)9,      (unsigned char)25,      (unsigned char)9, 
        (unsigned char)8,      (unsigned char)7,      (unsigned char)42,      (unsigned char)42, 
        (unsigned char)0,      (unsigned char)42,      (unsigned char)5,      (unsigned char)1, 
        (unsigned char)13,      (unsigned char)42,      (unsigned char)15,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)16,      (unsigned char)42,      (unsigned char)18, 
        (unsigned char)24,      (unsigned char)12,      (unsigned char)15,      (unsigned char)42, 
        (unsigned char)42,      (unsigned char)42,      (unsigned char)42,      (unsigned char)42, 
        (unsigned char)42,      (unsigned char)42,      (unsigned char)42,      (unsigned char)42, 
        (unsigned char)42,      (unsigned char)42,      (unsigned char)42,      (unsigned char)42, 
        (unsigned char)42,      (unsigned char)42,      (unsigned char)42,      (unsigned char)42, 
        (unsigned char)42,      (unsigned char)42,      (unsigned char)42,      (unsigned char)42, 
        (unsigned char)42,      (unsigned char)42,      (unsigned char)42,      (unsigned char)42, 
        (unsigned char)42,      (unsigned char)42,      (unsigned char)42,      (unsigned char)42, 
        (unsigned char)42,      (unsigned char)42,      (unsigned char)42,      (unsigned char)42, 
        (unsigned char)42,      (unsigned char)42,      (unsigned char)42,      (unsigned char)42, 
        (unsigned char)42,      (unsigned char)42,      (unsigned char)42,      (unsigned char)42, 
        (unsigned char)42,      (unsigned char)42,      (unsigned char)42,      (unsigned char)42, 
        (unsigned char)42,      (unsigned char)42,      (unsigned char)42,      (unsigned char)42, 
        (unsigned char)42,      (unsigned char)42,      (unsigned char)42,      (unsigned char)42, 
        (unsigned char)42,      (unsigned char)42,      (unsigned char)42,      (unsigned char)42, 
        (unsigned char)42,      (unsigned char)42,      (unsigned char)42,      (unsigned char)42, 
        (unsigned char)42,      (unsigned char)42,      (unsigned char)42,      (unsigned char)42, 
        (unsigned char)42,      (unsigned char)42,      (unsigned char)42,      (unsigned char)42, 
        (unsigned char)42,      (unsigned char)42,      (unsigned char)42,      (unsigned char)42, 
        (unsigned char)42,      (unsigned char)42,      (unsigned char)42,      (unsigned char)42, 
        (unsigned char)42,      (unsigned char)42,      (unsigned char)42,      (unsigned char)42, 
        (unsigned char)42,      (unsigned char)42,      (unsigned char)42,      (unsigned char)42, 
        (unsigned char)42,      (unsigned char)42,      (unsigned char)42,      (unsigned char)42, 
        (unsigned char)42,      (unsigned char)42,      (unsigned char)42,      (unsigned char)42, 
        (unsigned char)42,      (unsigned char)42,      (unsigned char)42,      (unsigned char)42, 
        (unsigned char)42,      (unsigned char)42,      (unsigned char)42,      (unsigned char)42, 
        (unsigned char)42,      (unsigned char)42,      (unsigned char)42,      (unsigned char)42, 
        (unsigned char)42,      (unsigned char)42,      (unsigned char)42,      (unsigned char)42, 
        (unsigned char)42,      (unsigned char)42,      (unsigned char)42,      (unsigned char)42, 
        (unsigned char)42,      (unsigned char)42,      (unsigned char)42,      (unsigned char)42, 
        (unsigned char)42,      (unsigned char)42,      (unsigned char)42,      (unsigned char)42, 
        (unsigned char)42,      (unsigned char)42,      (unsigned char)42,      (unsigned char)42, 
        (unsigned char)42,      (unsigned char)42,      (unsigned char)42,      (unsigned char)42, 
        (unsigned char)42,      (unsigned char)42,      (unsigned char)42,      (unsigned char)42};
#line 41 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/gperf.c"
__inline static unsigned int hash(char const   *str , unsigned int len ) 
{ 
  register int hval ;

  {
#line 81
  hval = (int )len;
  {
#line 88
  if (hval == 2) {
#line 88
    goto case_2;
  }
#line 85
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 86
  hval += (int )asso_values[(unsigned char )*(str + 2)];
  case_2: /* CIL Label */ 
#line 89
  hval += (int )asso_values[(unsigned char )*(str + 1)];
#line 90
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 92
  return ((unsigned int )hval);
}
}
#line 103 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/gperf.c"
static unsigned char lengthtable[32]  = 
#line 103
  {      (unsigned char)2,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)6,      (unsigned char)3,      (unsigned char)8,      (unsigned char)4, 
        (unsigned char)5,      (unsigned char)4,      (unsigned char)8,      (unsigned char)5, 
        (unsigned char)6,      (unsigned char)4,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)5,      (unsigned char)6,      (unsigned char)6, 
        (unsigned char)6,      (unsigned char)4,      (unsigned char)4,      (unsigned char)8, 
        (unsigned char)2,      (unsigned char)6,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)6,      (unsigned char)7,      (unsigned char)6,      (unsigned char)7};
#line 109 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/gperf.c"
static templ_ty wordlist[32]  = 
#line 109
  {      {(char *)"do", (rwcodes_ty )9}, 
        {(char *)"else", (rwcodes_ty )10}, 
        {(char *)"goto", (rwcodes_ty )2}, 
        {(char *)"float", (rwcodes_ty )7}, 
        {(char *)"global", (rwcodes_ty )7}, 
        {(char *)"int", (rwcodes_ty )7}, 
        {(char *)"volatile", (rwcodes_ty )7}, 
        {(char *)"long", (rwcodes_ty )7}, 
        {(char *)"const", (rwcodes_ty )7}, 
        {(char *)"void", (rwcodes_ty )7}, 
        {(char *)"unsigned", (rwcodes_ty )7}, 
        {(char *)"short", (rwcodes_ty )7}, 
        {(char *)"return", (rwcodes_ty )12}, 
        {(char *)"case", (rwcodes_ty )4}, 
        {(char *)"union", (rwcodes_ty )5}, 
        {(char *)"static", (rwcodes_ty )7}, 
        {(char *)"for", (rwcodes_ty )8}, 
        {(char *)"while", (rwcodes_ty )8}, 
        {(char *)"struct", (rwcodes_ty )5}, 
        {(char *)"signed", (rwcodes_ty )7}, 
        {(char *)"double", (rwcodes_ty )7}, 
        {(char *)"char", (rwcodes_ty )7}, 
        {(char *)"enum", (rwcodes_ty )6}, 
        {(char *)"register", (rwcodes_ty )7}, 
        {(char *)"if", (rwcodes_ty )8}, 
        {(char *)"sizeof", (rwcodes_ty )11}, 
        {(char *)"break", (rwcodes_ty )2}, 
        {(char *)"extern", (rwcodes_ty )7}, 
        {(char *)"switch", (rwcodes_ty )3}, 
        {(char *)"typedef", (rwcodes_ty )7}, 
        {(char *)"va_dcl", (rwcodes_ty )7}, 
        {(char *)"default", (rwcodes_ty )4}};
#line 12 "indent.gperf"
static short lookup[42]  = 
#line 12 "indent.gperf"
  {      (short)-1,      (short)-1,      (short)-1,      (short)0, 
        (short)1,      (short)2,      (short)3,      (short)4, 
        (short)5,      (short)6,      (short)7,      (short)8, 
        (short)9,      (short)10,      (short)11,      (short)12, 
        (short)13,      (short)14,      (short)15,      (short)16, 
        (short)17,      (short)18,      (short)19,      (short)20, 
        (short)21,      (short)22,      (short)23,      (short)24, 
        (short)25,      (short)26,      (short)27,      (short)28, 
        (short)29,      (short)30,      (short)-1,      (short)-1, 
        (short)-1,      (short)-1,      (short)-1,      (short)-1, 
        (short)-1,      (short)31};
#line 96 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/gperf.c"
__inline templ_ty *is_reserved(char const   *str , unsigned int len ) 
{ 
  register int key ;
  unsigned int tmp ;
  register int index___0 ;
  register char const   *s ;
  int tmp___0 ;

  {
#line 19
  if (len <= 8U) {
#line 19
    if (len >= 2U) {
      {
#line 21 "indent.gperf"
      tmp = hash(str, len);
#line 21
      key = (int )tmp;
      }
#line 23
      if (key <= 41) {
#line 23
        if (key >= 0) {
#line 25
          index___0 = (int )lookup[key];
#line 27
          if (index___0 >= 0) {
#line 29
            if (len == (unsigned int )lengthtable[index___0]) {
#line 31
              s = (char const   *)wordlist[index___0].rwd;
#line 33
              if ((int const   )*str == (int const   )*s) {
                {
#line 33
                tmp___0 = memcmp((void const   *)(str + 1), (void const   *)(s + 1),
                                 (size_t )(len - 1U));
                }
#line 33
                if (! tmp___0) {
#line 34
                  return (& wordlist[index___0]);
                }
              }
            }
          }
        }
      }
    }
  }
#line 39
  return ((templ_ty *)0);
}
}
#line 216 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/lexi.c"
__inline templ_ty *is_reserved_cc(char const   *str , unsigned int len ) ;
#line 52 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/gperf-cc.c"
__inline static unsigned int hash_cc(char const   *str , unsigned int len ) ;
#line 52 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/gperf-cc.c"
static unsigned char asso_values___0[256]  = 
#line 52
  {      (unsigned char)58,      (unsigned char)58,      (unsigned char)58,      (unsigned char)58, 
        (unsigned char)58,      (unsigned char)58,      (unsigned char)58,      (unsigned char)58, 
        (unsigned char)58,      (unsigned char)58,      (unsigned char)58,      (unsigned char)58, 
        (unsigned char)58,      (unsigned char)58,      (unsigned char)58,      (unsigned char)58, 
        (unsigned char)58,      (unsigned char)58,      (unsigned char)58,      (unsigned char)58, 
        (unsigned char)58,      (unsigned char)58,      (unsigned char)58,      (unsigned char)58, 
        (unsigned char)58,      (unsigned char)58,      (unsigned char)58,      (unsigned char)58, 
        (unsigned char)58,      (unsigned char)58,      (unsigned char)58,      (unsigned char)58, 
        (unsigned char)58,      (unsigned char)58,      (unsigned char)58,      (unsigned char)58, 
        (unsigned char)58,      (unsigned char)58,      (unsigned char)58,      (unsigned char)58, 
        (unsigned char)58,      (unsigned char)58,      (unsigned char)58,      (unsigned char)58, 
        (unsigned char)58,      (unsigned char)58,      (unsigned char)58,      (unsigned char)58, 
        (unsigned char)58,      (unsigned char)58,      (unsigned char)58,      (unsigned char)58, 
        (unsigned char)58,      (unsigned char)58,      (unsigned char)58,      (unsigned char)58, 
        (unsigned char)58,      (unsigned char)58,      (unsigned char)58,      (unsigned char)58, 
        (unsigned char)58,      (unsigned char)58,      (unsigned char)58,      (unsigned char)58, 
        (unsigned char)58,      (unsigned char)58,      (unsigned char)58,      (unsigned char)58, 
        (unsigned char)58,      (unsigned char)58,      (unsigned char)58,      (unsigned char)58, 
        (unsigned char)58,      (unsigned char)58,      (unsigned char)58,      (unsigned char)58, 
        (unsigned char)58,      (unsigned char)58,      (unsigned char)58,      (unsigned char)58, 
        (unsigned char)58,      (unsigned char)58,      (unsigned char)58,      (unsigned char)58, 
        (unsigned char)58,      (unsigned char)58,      (unsigned char)58,      (unsigned char)58, 
        (unsigned char)58,      (unsigned char)58,      (unsigned char)58,      (unsigned char)58, 
        (unsigned char)58,      (unsigned char)58,      (unsigned char)58,      (unsigned char)10, 
        (unsigned char)58,      (unsigned char)10,      (unsigned char)28,      (unsigned char)11, 
        (unsigned char)25,      (unsigned char)15,      (unsigned char)25,      (unsigned char)5, 
        (unsigned char)30,      (unsigned char)1,      (unsigned char)58,      (unsigned char)58, 
        (unsigned char)5,      (unsigned char)37,      (unsigned char)22,      (unsigned char)12, 
        (unsigned char)34,      (unsigned char)58,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)0,      (unsigned char)18,      (unsigned char)34,      (unsigned char)27, 
        (unsigned char)58,      (unsigned char)58,      (unsigned char)25,      (unsigned char)58, 
        (unsigned char)58,      (unsigned char)58,      (unsigned char)58,      (unsigned char)58, 
        (unsigned char)58,      (unsigned char)58,      (unsigned char)58,      (unsigned char)58, 
        (unsigned char)58,      (unsigned char)58,      (unsigned char)58,      (unsigned char)58, 
        (unsigned char)58,      (unsigned char)58,      (unsigned char)58,      (unsigned char)58, 
        (unsigned char)58,      (unsigned char)58,      (unsigned char)58,      (unsigned char)58, 
        (unsigned char)58,      (unsigned char)58,      (unsigned char)58,      (unsigned char)58, 
        (unsigned char)58,      (unsigned char)58,      (unsigned char)58,      (unsigned char)58, 
        (unsigned char)58,      (unsigned char)58,      (unsigned char)58,      (unsigned char)58, 
        (unsigned char)58,      (unsigned char)58,      (unsigned char)58,      (unsigned char)58, 
        (unsigned char)58,      (unsigned char)58,      (unsigned char)58,      (unsigned char)58, 
        (unsigned char)58,      (unsigned char)58,      (unsigned char)58,      (unsigned char)58, 
        (unsigned char)58,      (unsigned char)58,      (unsigned char)58,      (unsigned char)58, 
        (unsigned char)58,      (unsigned char)58,      (unsigned char)58,      (unsigned char)58, 
        (unsigned char)58,      (unsigned char)58,      (unsigned char)58,      (unsigned char)58, 
        (unsigned char)58,      (unsigned char)58,      (unsigned char)58,      (unsigned char)58, 
        (unsigned char)58,      (unsigned char)58,      (unsigned char)58,      (unsigned char)58, 
        (unsigned char)58,      (unsigned char)58,      (unsigned char)58,      (unsigned char)58, 
        (unsigned char)58,      (unsigned char)58,      (unsigned char)58,      (unsigned char)58, 
        (unsigned char)58,      (unsigned char)58,      (unsigned char)58,      (unsigned char)58, 
        (unsigned char)58,      (unsigned char)58,      (unsigned char)58,      (unsigned char)58, 
        (unsigned char)58,      (unsigned char)58,      (unsigned char)58,      (unsigned char)58, 
        (unsigned char)58,      (unsigned char)58,      (unsigned char)58,      (unsigned char)58, 
        (unsigned char)58,      (unsigned char)58,      (unsigned char)58,      (unsigned char)58, 
        (unsigned char)58,      (unsigned char)58,      (unsigned char)58,      (unsigned char)58, 
        (unsigned char)58,      (unsigned char)58,      (unsigned char)58,      (unsigned char)58, 
        (unsigned char)58,      (unsigned char)58,      (unsigned char)58,      (unsigned char)58, 
        (unsigned char)58,      (unsigned char)58,      (unsigned char)58,      (unsigned char)58, 
        (unsigned char)58,      (unsigned char)58,      (unsigned char)58,      (unsigned char)58, 
        (unsigned char)58,      (unsigned char)58,      (unsigned char)58,      (unsigned char)58, 
        (unsigned char)58,      (unsigned char)58,      (unsigned char)58,      (unsigned char)58, 
        (unsigned char)58,      (unsigned char)58,      (unsigned char)58,      (unsigned char)58, 
        (unsigned char)58,      (unsigned char)58,      (unsigned char)58,      (unsigned char)58, 
        (unsigned char)58,      (unsigned char)58,      (unsigned char)58,      (unsigned char)58};
#line 41 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/gperf-cc.c"
__inline static unsigned int hash_cc(char const   *str , unsigned int len ) 
{ 
  register int hval ;

  {
#line 81
  hval = (int )len;
  {
#line 89
  if (hval == 1) {
#line 89
    goto case_1;
  }
#line 89
  if (hval == 2) {
#line 89
    goto case_1;
  }
#line 85
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 86
  hval += (int )asso_values___0[(unsigned char )*(str + 2)];
  case_1: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 90
  hval += (int )asso_values___0[(unsigned char )*(str + 0)];
#line 91
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 93
  return ((unsigned int )hval);
}
}
#line 104 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/gperf-cc.c"
static unsigned char lengthtable___0[48]  = 
#line 104
  {      (unsigned char)2,      (unsigned char)3,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)6,      (unsigned char)6,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)8,      (unsigned char)5, 
        (unsigned char)9,      (unsigned char)4,      (unsigned char)6,      (unsigned char)5, 
        (unsigned char)6,      (unsigned char)4,      (unsigned char)6,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)2,      (unsigned char)7, 
        (unsigned char)8,      (unsigned char)3,      (unsigned char)4,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)8,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)4,      (unsigned char)6, 
        (unsigned char)7,      (unsigned char)5,      (unsigned char)7,      (unsigned char)4, 
        (unsigned char)8,      (unsigned char)6,      (unsigned char)8,      (unsigned char)5, 
        (unsigned char)6,      (unsigned char)6,      (unsigned char)3,      (unsigned char)7};
#line 111 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/gperf-cc.c"
static templ_ty wordlist___0[48]  = 
#line 111
  {      {(char *)"if", (rwcodes_ty )8}, 
        {(char *)"int", (rwcodes_ty )7}, 
        {(char *)"throw", (rwcodes_ty )12}, 
        {(char *)"return", (rwcodes_ty )12}, 
        {(char *)"goto", (rwcodes_ty )2}, 
        {(char *)"switch", (rwcodes_ty )3}, 
        {(char *)"struct", (rwcodes_ty )5}, 
        {(char *)"inline", (rwcodes_ty )7}, 
        {(char *)"sigof", (rwcodes_ty )11}, 
        {(char *)"signed", (rwcodes_ty )7}, 
        {(char *)"register", (rwcodes_ty )7}, 
        {(char *)"catch", (rwcodes_ty )8}, 
        {(char *)"signature", (rwcodes_ty )5}, 
        {(char *)"case", (rwcodes_ty )4}, 
        {(char *)"static", (rwcodes_ty )7}, 
        {(char *)"short", (rwcodes_ty )7}, 
        {(char *)"extern", (rwcodes_ty )7}, 
        {(char *)"else", (rwcodes_ty )10}, 
        {(char *)"global", (rwcodes_ty )7}, 
        {(char *)"union", (rwcodes_ty )5}, 
        {(char *)"char", (rwcodes_ty )7}, 
        {(char *)"class", (rwcodes_ty )5}, 
        {(char *)"do", (rwcodes_ty )9}, 
        {(char *)"classof", (rwcodes_ty )11}, 
        {(char *)"unsigned", (rwcodes_ty )7}, 
        {(char *)"for", (rwcodes_ty )8}, 
        {(char *)"long", (rwcodes_ty )7}, 
        {(char *)"friend", (rwcodes_ty )7}, 
        {(char *)"while", (rwcodes_ty )8}, 
        {(char *)"sizeof", (rwcodes_ty )11}, 
        {(char *)"operator", (rwcodes_ty )1}, 
        {(char *)"delete", (rwcodes_ty )12}, 
        {(char *)"enum", (rwcodes_ty )6}, 
        {(char *)"const", (rwcodes_ty )7}, 
        {(char *)"void", (rwcodes_ty )7}, 
        {(char *)"typeof", (rwcodes_ty )11}, 
        {(char *)"typedef", (rwcodes_ty )7}, 
        {(char *)"float", (rwcodes_ty )7}, 
        {(char *)"virtual", (rwcodes_ty )7}, 
        {(char *)"bool", (rwcodes_ty )7}, 
        {(char *)"template", (rwcodes_ty )7}, 
        {(char *)"headof", (rwcodes_ty )11}, 
        {(char *)"volatile", (rwcodes_ty )7}, 
        {(char *)"break", (rwcodes_ty )2}, 
        {(char *)"double", (rwcodes_ty )7}, 
        {(char *)"va_dcl", (rwcodes_ty )7}, 
        {(char *)"new", (rwcodes_ty )12}, 
        {(char *)"default", (rwcodes_ty )4}};
#line 12 "indent-cc.gperf"
static short lookup___0[58]  = 
#line 12 "indent-cc.gperf"
  {      (short)-1,      (short)-1,      (short)-1,      (short)0, 
        (short)1,      (short)-1,      (short)-1,      (short)2, 
        (short)3,      (short)4,      (short)5,      (short)6, 
        (short)7,      (short)8,      (short)9,      (short)10, 
        (short)11,      (short)12,      (short)13,      (short)14, 
        (short)15,      (short)16,      (short)17,      (short)18, 
        (short)19,      (short)20,      (short)21,      (short)22, 
        (short)23,      (short)24,      (short)25,      (short)26, 
        (short)27,      (short)28,      (short)29,      (short)30, 
        (short)31,      (short)32,      (short)33,      (short)34, 
        (short)35,      (short)36,      (short)37,      (short)38, 
        (short)39,      (short)40,      (short)41,      (short)42, 
        (short)43,      (short)44,      (short)45,      (short)-1, 
        (short)46,      (short)-1,      (short)-1,      (short)-1, 
        (short)-1,      (short)47};
#line 97 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/gperf-cc.c"
__inline templ_ty *is_reserved_cc(char const   *str , unsigned int len ) 
{ 
  register int key ;
  unsigned int tmp ;
  register int index___0 ;
  register char const   *s ;
  int tmp___0 ;

  {
#line 21
  if (len <= 9U) {
#line 21
    if (len >= 2U) {
      {
#line 23 "indent-cc.gperf"
      tmp = hash_cc(str, len);
#line 23
      key = (int )tmp;
      }
#line 25
      if (key <= 57) {
#line 25
        if (key >= 0) {
#line 27
          index___0 = (int )lookup___0[key];
#line 29
          if (index___0 >= 0) {
#line 31
            if (len == (unsigned int )lengthtable___0[index___0]) {
#line 33
              s = (char const   *)wordlist___0[index___0].rwd;
#line 35
              if ((int const   )*str == (int const   )*s) {
                {
#line 35
                tmp___0 = memcmp((void const   *)(str + 1), (void const   *)(s + 1),
                                 (size_t )(len - 1U));
                }
#line 35
                if (! tmp___0) {
#line 36
                  return (& wordlist___0[index___0]);
                }
              }
            }
          }
        }
      }
    }
  }
#line 41
  return ((templ_ty *)0);
}
}
#line 230 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/lexi.c"
static codes_ty last_code  =    (codes_ty )0;
#line 231 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/lexi.c"
static int l_struct  =    0;
#line 232 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/lexi.c"
static int l_enum  =    0;
#line 236 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/lexi.c"
static int count  =    0;
#line 226 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/lexi.c"
extern codes_ty lexi(void) 
{ 
  int unary_delim ;
  codes_ty code ;
  char qchar ;
  templ_ty *p ;
  int seendot ;
  int seenexp ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *q ;
  char *r ;
  char *tmp___5 ;
  char *tmp___6 ;
  codes_ty value ;
  char *tp ;
  int paren_count ;
  unsigned short const   **tmp___7 ;
  int tmp___8 ;
  unsigned short const   **tmp___9 ;
  unsigned short const   **tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *p___0 ;
  unsigned short const   **tmp___17 ;
  char *tmp___18 ;

  {
#line 228
  unary_delim = 0;
#line 238
  count ++;
#line 243
  parser_state_tos->col_1 = parser_state_tos->last_nl;
#line 244
  parser_state_tos->last_saw_nl = parser_state_tos->last_nl;
#line 245
  parser_state_tos->last_nl = 0;
#line 247
  if ((unsigned long )buf_ptr >= (unsigned long )buf_end) {
    {
#line 249
    fill_buffer();
    }
  }
#line 252
  if ((int )*buf_ptr == 32) {
    {
#line 254
    parser_state_tos->col_1 = 0;
#line 256
    skip_buffered_space();
    }
  } else
#line 252
  if ((int )*buf_ptr == 9) {
    {
#line 254
    parser_state_tos->col_1 = 0;
#line 256
    skip_buffered_space();
    }
  }
#line 265
  token = buf_ptr;
#line 269
  if ((int )*(buf_ptr + 0) == 76) {
#line 269
    if ((int )*(buf_ptr + 1) == 34) {
#line 269
      goto _L___19;
    } else
#line 269
    if ((int )*(buf_ptr + 1) == 39) {
      _L___19: /* CIL Label */ 
#line 269
      if ((int )*(buf_ptr + 0) == 46) {
        {
#line 269
        tmp___10 = __ctype_b_loc();
        }
#line 269
        if ((int const   )*(*tmp___10 + (int )*(buf_ptr + 1)) & 2048) {
          _L___16: /* CIL Label */ 
          {
#line 277
          tmp___1 = __ctype_b_loc();
          }
#line 277
          if ((int const   )*(*tmp___1 + (int )*buf_ptr) & 2048) {
#line 277
            goto _L___2;
          } else
#line 277
          if ((int )*(buf_ptr + 0) == 46) {
            {
#line 277
            tmp___2 = __ctype_b_loc();
            }
#line 277
            if ((int const   )*(*tmp___2 + (int )*(buf_ptr + 1)) & 2048) {
              _L___2: /* CIL Label */ 
#line 280
              seendot = 0;
#line 280
              seenexp = 0;
#line 282
              if ((int )*buf_ptr == 48) {
#line 282
                if ((int )*(buf_ptr + 1) == 120) {
#line 282
                  goto _L___1;
                } else
#line 282
                if ((int )*(buf_ptr + 1) == 88) {
                  _L___1: /* CIL Label */ 
#line 284
                  buf_ptr += 2;
                  {
#line 285
                  while (1) {
                    while_continue: /* CIL Label */ ;
                    {
#line 285
                    tmp = __ctype_b_loc();
                    }
#line 285
                    if (! ((int const   )*(*tmp + (int )*buf_ptr) & 4096)) {
#line 285
                      goto while_break;
                    }
#line 287
                    buf_ptr ++;
                  }
                  while_break: /* CIL Label */ ;
                  }
                } else {
#line 282
                  goto _L___0;
                }
              } else {
                _L___0: /* CIL Label */ 
                {
#line 292
                while (1) {
                  while_continue___0: /* CIL Label */ ;
#line 294
                  if ((int )*buf_ptr == 46) {
#line 296
                    if (seendot) {
#line 298
                      goto while_break___0;
                    } else {
#line 302
                      seendot ++;
                    }
                  }
                  {
#line 306
                  buf_ptr ++;
#line 308
                  tmp___0 = __ctype_b_loc();
                  }
#line 308
                  if (! ((int const   )*(*tmp___0 + (int )*buf_ptr) & 2048)) {
#line 308
                    if ((int )*buf_ptr != 46) {
#line 310
                      if ((int )*buf_ptr != 69) {
#line 310
                        if ((int )*buf_ptr != 101) {
#line 312
                          goto while_break___0;
                        } else {
#line 310
                          goto _L;
                        }
                      } else
                      _L: /* CIL Label */ 
#line 310
                      if (seenexp) {
#line 312
                        goto while_break___0;
                      } else {
#line 316
                        seenexp ++;
#line 317
                        seendot ++;
#line 318
                        buf_ptr ++;
#line 320
                        if ((int )*buf_ptr == 43) {
#line 322
                          buf_ptr ++;
                        } else
#line 320
                        if ((int )*buf_ptr == 45) {
#line 322
                          buf_ptr ++;
                        }
                      }
                    }
                  }
                }
                while_break___0: /* CIL Label */ ;
                }
              }
#line 329
              if ((int )*buf_ptr == 70) {
#line 331
                buf_ptr ++;
              } else
#line 329
              if ((int )*buf_ptr == 102) {
#line 331
                buf_ptr ++;
              } else
#line 329
              if ((int )*buf_ptr == 105) {
#line 331
                buf_ptr ++;
              } else
#line 329
              if ((int )*buf_ptr == 106) {
#line 331
                buf_ptr ++;
              } else {
                {
#line 335
                while (1) {
                  while_continue___1: /* CIL Label */ ;
#line 335
                  if (! ((int )*buf_ptr == 85)) {
#line 335
                    if (! ((int )*buf_ptr == 117)) {
#line 335
                      if (! ((int )*buf_ptr == 76)) {
#line 335
                        if (! ((int )*buf_ptr == 108)) {
#line 335
                          goto while_break___1;
                        }
                      }
                    }
                  }
#line 337
                  buf_ptr ++;
                }
                while_break___1: /* CIL Label */ ;
                }
              }
            } else {
#line 277
              goto _L___3;
            }
          } else {
            _L___3: /* CIL Label */ 
            {
#line 342
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 342
              if (! ((int )chartype[255 & (int )*buf_ptr] == 1)) {
#line 342
                goto while_break___2;
              }
#line 344
              buf_ptr ++;
#line 346
              if ((unsigned long )buf_ptr >= (unsigned long )buf_end) {
                {
#line 348
                fill_buffer();
                }
              }
            }
            while_break___2: /* CIL Label */ ;
            }
          }
#line 352
          token_end = buf_ptr;
#line 354
          if (token_end - token == 13L) {
            {
#line 354
            tmp___3 = strncmp((char const   *)token, "__attribute__", (size_t )13);
            }
#line 354
            if (! tmp___3) {
#line 356
              last_code = (codes_ty )24;
#line 357
              parser_state_tos->last_u_d = 1;
#line 358
              return ((codes_ty )41);
            }
          }
          {
#line 361
          skip_buffered_space();
          }
#line 365
          if (token_end - token == 8L) {
            {
#line 365
            tmp___4 = strncmp((char const   *)token, "operator", (size_t )8);
            }
#line 365
            if (! tmp___4) {
              {
#line 367
              while (1) {
                while_continue___3: /* CIL Label */ ;
#line 367
                if (! ((int )chartype[255 & (int )*buf_ptr] == 3)) {
#line 367
                  goto while_break___3;
                }
#line 369
                buf_ptr ++;
#line 371
                if ((unsigned long )buf_ptr >= (unsigned long )buf_end) {
                  {
#line 373
                  fill_buffer();
                  }
                }
              }
              while_break___3: /* CIL Label */ ;
              }
              {
#line 377
              token_end = buf_ptr;
#line 379
              skip_buffered_space();
              }
            }
          }
#line 383
          parser_state_tos->its_a_keyword = 0;
#line 384
          parser_state_tos->sizeof_keyword = 0;
#line 388
          if (l_struct) {
#line 390
            l_struct = 0;
#line 391
            last_code = (codes_ty )15;
#line 392
            parser_state_tos->last_u_d = 1;
#line 394
            if ((unsigned int )parser_state_tos->last_token == 17U) {
#line 396
              return ((codes_ty )16);
            }
#line 398
            return ((codes_ty )24);
          }
#line 403
          parser_state_tos->last_u_d = 0;
#line 404
          last_code = (codes_ty )15;
#line 408
          if (settings.c_plus_plus) {
            {
#line 410
            p = is_reserved_cc((char const   *)token, (unsigned int )(token_end - token));
            }
          } else {
            {
#line 414
            p = is_reserved((char const   *)token, (unsigned int )(token_end - token));
            }
          }
#line 417
          if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 417
            if ((unsigned long )user_specials != (unsigned long )((templ_ty *)0)) {
#line 419
              p = user_specials + 0;
              {
#line 419
              while (1) {
                while_continue___4: /* CIL Label */ ;
#line 419
                if (! ((unsigned long )p < (unsigned long )((user_specials + 0) + user_specials_idx))) {
#line 419
                  goto while_break___4;
                }
#line 421
                q = token;
#line 422
                r = p->rwd;
                {
#line 428
                while (1) {
                  while_continue___5: /* CIL Label */ ;
#line 433
                  if ((unsigned long )q >= (unsigned long )token_end) {
#line 433
                    if (! *r) {
#line 435
                      goto found_keyword;
                    }
                  }
#line 441
                  if ((unsigned long )q >= (unsigned long )token_end) {
#line 443
                    goto while_break___5;
                  } else
#line 441
                  if (! *r) {
#line 443
                    goto while_break___5;
                  }
#line 449
                  tmp___5 = q;
#line 449
                  q ++;
#line 449
                  tmp___6 = r;
#line 449
                  r ++;
#line 449
                  if ((int )*tmp___5 != (int )*tmp___6) {
#line 451
                    goto while_break___5;
                  }
                }
                while_break___5: /* CIL Label */ ;
                }
#line 419
                p ++;
              }
              while_break___4: /* CIL Label */ ;
              }
#line 458
              p = (templ_ty *)((void *)0);
            }
          }
          found_keyword: 
#line 463
          if (p) {
#line 467
            value = (codes_ty )15;
#line 468
            parser_state_tos->its_a_keyword = 1;
#line 469
            parser_state_tos->last_u_d = 1;
#line 470
            parser_state_tos->last_rw = p->rwcode;
#line 471
            parser_state_tos->last_rw_depth = parser_state_tos->paren_depth;
            {
#line 475
            if ((unsigned int )p->rwcode == 1U) {
#line 475
              goto case_1;
            }
#line 479
            if ((unsigned int )p->rwcode == 3U) {
#line 479
              goto case_3;
            }
#line 482
            if ((unsigned int )p->rwcode == 4U) {
#line 482
              goto case_4;
            }
#line 485
            if ((unsigned int )p->rwcode == 6U) {
#line 485
              goto case_6;
            }
#line 488
            if ((unsigned int )p->rwcode == 5U) {
#line 488
              goto case_5;
            }
#line 501
            if ((unsigned int )p->rwcode == 7U) {
#line 501
              goto case_7;
            }
#line 514
            if ((unsigned int )p->rwcode == 8U) {
#line 514
              goto case_8;
            }
#line 523
            if ((unsigned int )p->rwcode == 9U) {
#line 523
              goto case_9;
            }
#line 527
            if ((unsigned int )p->rwcode == 10U) {
#line 527
              goto case_10;
            }
#line 531
            if ((unsigned int )p->rwcode == 11U) {
#line 531
              goto case_11;
            }
#line 538
            goto switch_default;
            case_1: /* CIL Label */ 
#line 476
            value = (codes_ty )17;
#line 477
            parser_state_tos->in_parameter_declaration = 1;
#line 478
            goto switch_break;
            case_3: /* CIL Label */ 
#line 480
            value = (codes_ty )21;
#line 481
            goto switch_break;
            case_4: /* CIL Label */ 
#line 483
            value = (codes_ty )9;
#line 484
            goto switch_break;
            case_6: /* CIL Label */ 
#line 486
            l_enum = 1;
            case_5: /* CIL Label */ 
#line 489
            if (parser_state_tos->p_l_follow) {
#line 489
              if (! (parser_state_tos->noncast_mask & (1 << parser_state_tos->p_l_follow))) {
#line 493
                parser_state_tos->cast_mask |= 1 << parser_state_tos->p_l_follow;
#line 494
                goto switch_break;
              }
            }
#line 497
            l_struct = 1;
            case_7: /* CIL Label */ 
#line 502
            if (parser_state_tos->p_l_follow) {
#line 502
              if (! (parser_state_tos->noncast_mask & (1 << parser_state_tos->p_l_follow))) {
#line 506
                parser_state_tos->cast_mask |= 1 << parser_state_tos->p_l_follow;
#line 507
                goto switch_break;
              }
            }
#line 510
            last_code = (codes_ty )24;
#line 511
            value = (codes_ty )24;
#line 512
            goto switch_break;
            case_8: /* CIL Label */ 
#line 515
            value = (codes_ty )25;
#line 516
            if ((int )*token == 105) {
#line 516
              if ((unsigned int )parser_state_tos->last_token == 27U) {
#line 518
                parser_state_tos->i_l_follow -= settings.ind_size;
              }
            }
#line 521
            goto switch_break;
            case_9: /* CIL Label */ 
#line 524
            value = (codes_ty )26;
#line 525
            goto switch_break;
            case_10: /* CIL Label */ 
#line 528
            value = (codes_ty )27;
#line 529
            goto switch_break;
            case_11: /* CIL Label */ 
#line 532
            parser_state_tos->sizeof_keyword = 1;
#line 533
            value = (codes_ty )15;
#line 534
            goto switch_break;
            switch_default: /* CIL Label */ 
#line 540
            value = (codes_ty )15;
            switch_break: /* CIL Label */ ;
            }
#line 543
            if ((unsigned int )parser_state_tos->last_token == 17U) {
#line 545
              return ((codes_ty )16);
            }
#line 548
            return (value);
          } else
#line 550
          if ((int )*buf_ptr == 40) {
#line 550
            if (parser_state_tos->tos <= 1) {
#line 550
              if (parser_state_tos->ind_level == 0) {
#line 550
                if (parser_state_tos->paren_depth == 0) {
#line 558
                  paren_count = 1;
#line 567
                  if ((unsigned int )parser_state_tos->last_token == 15U) {
#line 567
                    if (parser_state_tos->last_saw_nl) {
#line 569
                      parser_state_tos->in_decl = (BOOLEAN )1;
                    }
                  }
#line 574
                  tp = buf_ptr + 1;
                  {
#line 574
                  while (1) {
                    while_continue___6: /* CIL Label */ ;
#line 574
                    if (paren_count > 0) {
#line 574
                      if (! ((unsigned long )tp < (unsigned long )(in_prog + in_prog_size))) {
#line 574
                        goto while_break___6;
                      }
                    } else {
#line 574
                      goto while_break___6;
                    }
#line 576
                    if ((int )*tp == 40) {
#line 578
                      paren_count ++;
                    }
#line 581
                    if ((int )*tp == 41) {
#line 583
                      paren_count --;
                    }
#line 589
                    if ((int )*tp == 59) {
#line 591
                      goto not_proc;
                    }
#line 574
                    tp ++;
                  }
                  while_break___6: /* CIL Label */ ;
                  }
#line 595
                  if (paren_count == 0) {
#line 597
                    parser_state_tos->procname = token;
#line 598
                    parser_state_tos->procname_end = token_end;
                    {
#line 600
                    while (1) {
                      while_continue___7: /* CIL Label */ ;
                      {
#line 600
                      tmp___7 = __ctype_b_loc();
                      }
#line 600
                      if (! ((int const   )*(*tmp___7 + (int )*tp) & 8192)) {
#line 600
                        goto while_break___7;
                      }
#line 602
                      tp ++;
                    }
                    while_break___7: /* CIL Label */ ;
                    }
#line 605
                    if ((int )*tp == 95) {
#line 605
                      if ((in_prog + in_prog_size) - tp >= 13L) {
                        {
#line 605
                        tmp___8 = strncmp((char const   *)tp, "__attribute__", (size_t )13);
                        }
#line 605
                        if (tmp___8) {
#line 605
                          goto _L___5;
                        }
                      } else {
#line 605
                        goto _L___5;
                      }
                    } else
                    _L___5: /* CIL Label */ 
#line 619
                    if ((int )*tp != 59) {
#line 619
                      if ((int )*tp != 44) {
#line 619
                        if ((int )*tp != 40) {
#line 619
                          if ((int )*tp != 61) {
#line 621
                            parser_state_tos->in_parameter_declaration = 1;
                          }
                        }
                      }
                    }
                  }
                  not_proc: ;
                } else {
#line 550
                  goto _L___15;
                }
              } else {
#line 550
                goto _L___15;
              }
            } else {
#line 550
              goto _L___15;
            }
          } else
          _L___15: /* CIL Label */ 
#line 628
          if ((int )*buf_ptr == 58) {
#line 628
            if ((int )*(buf_ptr + 1) == 58) {
#line 628
              if (parser_state_tos->tos <= 1) {
#line 628
                if (parser_state_tos->ind_level == 0) {
#line 628
                  if (parser_state_tos->paren_depth == 0) {
#line 633
                    parser_state_tos->classname = token;
#line 634
                    parser_state_tos->classname_end = token_end;
                  } else {
#line 628
                    goto _L___12;
                  }
                } else {
#line 628
                  goto _L___12;
                }
              } else {
#line 628
                goto _L___12;
              }
            } else {
#line 628
              goto _L___12;
            }
          } else
          _L___12: /* CIL Label */ 
#line 641
          if ((int )*buf_ptr == 42) {
#line 641
            if ((int )*(buf_ptr + 1) != 61) {
#line 641
              goto _L___7;
            } else {
#line 641
              goto _L___8;
            }
          } else {
            _L___8: /* CIL Label */ 
            {
#line 641
            tmp___9 = __ctype_b_loc();
            }
#line 641
            if ((int const   )*(*tmp___9 + (int )*buf_ptr) & 1024) {
#line 641
              goto _L___7;
            } else
#line 641
            if ((int )*buf_ptr == 95) {
              _L___7: /* CIL Label */ 
#line 641
              if (! parser_state_tos->p_l_follow) {
#line 641
                if (! parser_state_tos->block_init) {
#line 641
                  if ((unsigned int )parser_state_tos->last_token == 3U) {
#line 641
                    goto _L___6;
                  } else
#line 641
                  if ((unsigned int )parser_state_tos->last_token == 12U) {
#line 641
                    goto _L___6;
                  } else
#line 641
                  if ((unsigned int )parser_state_tos->last_token == 14U) {
#line 641
                    goto _L___6;
                  } else
#line 641
                  if ((unsigned int )parser_state_tos->last_token == 24U) {
#line 641
                    goto _L___6;
                  } else
#line 641
                  if ((unsigned int )parser_state_tos->last_token == 13U) {
#line 641
                    goto _L___6;
                  } else
#line 641
                  if ((unsigned int )parser_state_tos->last_token == 4U) {
                    _L___6: /* CIL Label */ 
#line 651
                    parser_state_tos->its_a_keyword = 1;
#line 652
                    parser_state_tos->last_u_d = 1;
#line 653
                    last_code = (codes_ty )24;
#line 655
                    if ((unsigned int )parser_state_tos->last_token == 17U) {
#line 657
                      return ((codes_ty )16);
                    }
#line 660
                    return ((codes_ty )24);
                  }
                }
              }
            }
          }
#line 667
          if ((unsigned int )last_code == 24U) {
#line 671
            parser_state_tos->last_u_d = 1;
          }
#line 674
          last_code = (codes_ty )15;
#line 676
          if ((unsigned int )parser_state_tos->last_token == 17U) {
#line 678
            return ((codes_ty )16);
          }
#line 681
          return ((codes_ty )15);
        }
      }
    } else {
#line 269
      goto _L___18;
    }
  } else
  _L___18: /* CIL Label */ 
#line 269
  if ((int )chartype[255 & (int )*buf_ptr] == 1) {
#line 269
    goto _L___16;
  } else {
#line 269
    goto _L___19;
  }
#line 688
  token_end = buf_ptr + 1;
#line 696
  buf_ptr ++;
#line 696
  if ((unsigned long )buf_ptr >= (unsigned long )buf_end) {
    {
#line 698
    fill_buffer();
    }
  }
#line 703
  if ((int )*token == 92) {
#line 703
    if ((int )*(buf_ptr + 0) == 10) {
#line 705
      token = buf_ptr;
#line 707
      buf_ptr ++;
#line 707
      if ((unsigned long )buf_ptr >= (unsigned long )buf_end) {
        {
#line 709
        fill_buffer();
        }
      }
    }
  }
  {
#line 715
  if ((int )*token == 0) {
#line 715
    goto case_0;
  }
#line 719
  if ((int )*token == 10) {
#line 719
    goto case_10___0;
  }
#line 727
  if ((int )*token == 76) {
#line 727
    goto case_76;
  }
#line 740
  if ((int )*token == 34) {
#line 740
    goto case_34;
  }
#line 740
  if ((int )*token == 39) {
#line 740
    goto case_34;
  }
#line 804
  if ((int )*token == 40) {
#line 804
    goto case_40;
  }
#line 810
  if ((int )*token == 91) {
#line 810
    goto case_91;
  }
#line 820
  if ((int )*token == 41) {
#line 820
    goto case_41;
  }
#line 825
  if ((int )*token == 93) {
#line 825
    goto case_93;
  }
#line 834
  if ((int )*token == 35) {
#line 834
    goto case_35;
  }
#line 851
  if ((int )*token == 63) {
#line 851
    goto case_63;
  }
#line 856
  if ((int )*token == 58) {
#line 856
    goto case_58;
  }
#line 883
  if ((int )*token == 59) {
#line 883
    goto case_59;
  }
#line 889
  if ((int )*token == 123) {
#line 889
    goto case_123;
  }
#line 920
  if ((int )*token == 125) {
#line 920
    goto case_125;
  }
#line 927
  if ((int )*token == 12) {
#line 927
    goto case_12;
  }
#line 934
  if ((int )*token == 44) {
#line 934
    goto case_44;
  }
#line 939
  if ((int )*token == 46) {
#line 939
    goto case_46;
  }
#line 977
  if ((int )*token == 43) {
#line 977
    goto case_43;
  }
#line 977
  if ((int )*token == 45) {
#line 977
    goto case_43;
  }
#line 1019
  if ((int )*token == 61) {
#line 1019
    goto case_61;
  }
#line 1060
  if ((int )*token == 33) {
#line 1060
    goto case_33;
  }
#line 1060
  if ((int )*token == 60) {
#line 1060
    goto case_33;
  }
#line 1060
  if ((int )*token == 62) {
#line 1060
    goto case_33;
  }
#line 1088
  goto switch_default___0;
  case_0: /* CIL Label */ 
#line 716
  code = (codes_ty )0;
#line 717
  goto switch_break___0;
  case_10___0: /* CIL Label */ 
#line 720
  parser_state_tos->matching_brace_on_same_line = -1;
#line 721
  unary_delim = parser_state_tos->last_u_d;
#line 722
  parser_state_tos->last_nl = 1;
#line 723
  code = (codes_ty )1;
#line 724
  goto switch_break___0;
  case_76: /* CIL Label */ 
#line 728
  if ((int )*(buf_ptr + 0) != 34) {
#line 728
    if ((int )*(buf_ptr + 0) != 39) {
#line 730
      token_end = buf_ptr;
#line 731
      code = (codes_ty )15;
#line 732
      goto switch_break___0;
    }
  }
#line 735
  qchar = *(buf_ptr + 0);
#line 736
  buf_ptr ++;
#line 737
  goto handle_string;
  case_34: /* CIL Label */ 
  case_39: /* CIL Label */ 
#line 741
  qchar = *token;
  handle_string: 
  {
#line 749
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 749
    if ((int )*buf_ptr != (int )qchar) {
#line 749
      if (! ((int )*buf_ptr != 0)) {
#line 749
        goto while_break___8;
      }
    } else {
#line 749
      goto while_break___8;
    }
#line 751
    if ((int )*buf_ptr == 10) {
#line 753
      line_no ++;
    }
#line 756
    if ((int )*buf_ptr == 92) {
#line 758
      buf_ptr ++;
#line 760
      if ((unsigned long )buf_ptr >= (unsigned long )buf_end) {
        {
#line 762
        fill_buffer();
        }
      }
#line 765
      if ((int )*buf_ptr == 10) {
#line 767
        line_no ++;
      }
#line 770
      if ((int )*buf_ptr == 0) {
#line 772
        goto while_break___8;
      }
    }
#line 776
    buf_ptr ++;
#line 778
    if ((unsigned long )buf_ptr >= (unsigned long )buf_end) {
      {
#line 780
      fill_buffer();
      }
    }
  }
  while_break___8: /* CIL Label */ ;
  }
#line 784
  if ((int )*buf_ptr == 10) {
#line 784
    goto _L___20;
  } else
#line 784
  if ((int )*buf_ptr == 0) {
    _L___20: /* CIL Label */ 
#line 786
    if ((int )qchar == 39) {
      {
#line 786
      tmp___11 = gettext("Unterminated character constant");
#line 786
      tmp___13 = tmp___11;
      }
    } else {
      {
#line 786
      tmp___12 = gettext("Unterminated string constant");
#line 786
      tmp___13 = tmp___12;
      }
    }
    {
#line 786
    tmp___14 = gettext("Warning");
#line 786
    message(tmp___14, tmp___13, (unsigned int *)0, (unsigned int *)0);
    }
  } else {
#line 792
    buf_ptr ++;
#line 794
    if ((unsigned long )buf_ptr >= (unsigned long )buf_end) {
      {
#line 796
      fill_buffer();
      }
    }
  }
#line 800
  token_end = buf_ptr;
#line 801
  code = (codes_ty )15;
#line 802
  goto switch_break___0;
  case_40: /* CIL Label */ 
#line 805
  l_enum = 0;
#line 806
  unary_delim = 1;
#line 807
  code = (codes_ty )2;
#line 808
  goto switch_break___0;
  case_91: /* CIL Label */ 
#line 811
  if (parser_state_tos->in_or_st) {
#line 813
    (parser_state_tos->in_or_st) ++;
  }
#line 816
  unary_delim = 1;
#line 817
  code = (codes_ty )2;
#line 818
  goto switch_break___0;
  case_41: /* CIL Label */ 
#line 821
  l_enum = 0;
#line 822
  code = (codes_ty )3;
#line 823
  goto switch_break___0;
  case_93: /* CIL Label */ 
#line 826
  if (parser_state_tos->in_or_st > 1) {
#line 828
    (parser_state_tos->in_or_st) --;
  }
#line 831
  code = (codes_ty )3;
#line 832
  goto switch_break___0;
  case_35: /* CIL Label */ 
#line 835
  unary_delim = parser_state_tos->last_u_d;
#line 836
  code = (codes_ty )22;
  {
#line 840
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 840
    if ((int )*buf_ptr == 32) {
#line 840
      if (! ((unsigned long )buf_ptr < (unsigned long )buf_end)) {
#line 840
        goto while_break___9;
      }
    } else {
#line 840
      goto while_break___9;
    }
#line 842
    buf_ptr ++;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 845
  if (settings.leave_preproc_space) {
#line 847
    token_end = buf_ptr;
  }
#line 849
  goto switch_break___0;
  case_63: /* CIL Label */ 
#line 852
  unary_delim = 1;
#line 853
  code = (codes_ty )8;
#line 854
  goto switch_break___0;
  case_58: /* CIL Label */ 
#line 859
  if ((int )*buf_ptr == 58) {
#line 861
    code = (codes_ty )11;
#line 862
    buf_ptr ++;
#line 863
    token_end = buf_ptr;
#line 864
    goto switch_break___0;
  }
#line 867
  code = (codes_ty )10;
#line 868
  unary_delim = 1;
#line 869
  if (squest) {
#line 869
    if ((int )*e_com != 32) {
#line 871
      if ((unsigned long )e_code == (unsigned long )s_code) {
#line 873
        parser_state_tos->want_blank = 0;
      } else {
#line 878
        parser_state_tos->want_blank = 1;
      }
    }
  }
#line 881
  goto switch_break___0;
  case_59: /* CIL Label */ 
#line 884
  l_enum = 0;
#line 885
  unary_delim = 1;
#line 886
  code = (codes_ty )12;
#line 887
  goto switch_break___0;
  case_123: /* CIL Label */ 
#line 890
  if (parser_state_tos->matching_brace_on_same_line < 0) {
#line 892
    parser_state_tos->matching_brace_on_same_line = 1;
  } else {
#line 896
    (parser_state_tos->matching_brace_on_same_line) ++;
  }
#line 899
  if (l_enum) {
#line 911
    parser_state_tos->block_init = 2;
#line 912
    parser_state_tos->block_init_level = 0;
#line 913
    l_enum = 0;
  }
#line 916
  unary_delim = 1;
#line 917
  code = (codes_ty )13;
#line 918
  goto switch_break___0;
  case_125: /* CIL Label */ 
#line 921
  (parser_state_tos->matching_brace_on_same_line) --;
#line 922
  l_enum = 0;
#line 923
  unary_delim = 1;
#line 924
  code = (codes_ty )14;
#line 925
  goto switch_break___0;
  case_12: /* CIL Label */ 
#line 928
  unary_delim = parser_state_tos->last_u_d;
#line 929
  parser_state_tos->last_nl = 1;
#line 931
  code = (codes_ty )23;
#line 932
  goto switch_break___0;
  case_44: /* CIL Label */ 
#line 935
  unary_delim = 1;
#line 936
  code = (codes_ty )18;
#line 937
  goto switch_break___0;
  case_46: /* CIL Label */ 
#line 940
  if ((int )*(buf_ptr + 0) == 46) {
#line 940
    if ((int )*(buf_ptr + 1) == 46) {
#line 945
      buf_ptr += 2;
#line 945
      if ((unsigned long )buf_ptr >= (unsigned long )buf_end) {
        {
#line 947
        fill_buffer();
        }
      }
#line 950
      unary_delim = 1;
#line 951
      token_end = buf_ptr;
#line 953
      if (parser_state_tos->in_decl) {
#line 956
        code = (codes_ty )24;
      } else {
#line 960
        code = (codes_ty )6;
      }
    } else {
#line 940
      goto _L___21;
    }
  } else {
    _L___21: /* CIL Label */ 
#line 965
    unary_delim = 0;
#line 966
    code = (codes_ty )40;
#line 968
    if ((int )*buf_ptr == 42) {
#line 970
      buf_ptr ++;
#line 971
      token_end = buf_ptr;
    }
  }
#line 974
  goto switch_break___0;
  case_43: /* CIL Label */ 
  case_45: /* CIL Label */ 
#line 978
  if (parser_state_tos->last_u_d) {
#line 978
    code = (codes_ty )5;
  } else {
#line 978
    code = (codes_ty )6;
  }
#line 979
  unary_delim = 1;
#line 981
  if ((int )*buf_ptr == (int )*(token + 0)) {
#line 984
    buf_ptr ++;
#line 986
    if ((unsigned int )last_code == 15U) {
#line 986
      goto _L___22;
    } else
#line 986
    if ((unsigned int )last_code == 3U) {
      _L___22: /* CIL Label */ 
#line 988
      if (parser_state_tos->last_u_d) {
#line 988
        code = (codes_ty )5;
      } else {
#line 988
        code = (codes_ty )7;
      }
#line 990
      unary_delim = 0;
    }
  } else
#line 993
  if ((int )*buf_ptr == 61) {
#line 996
    buf_ptr ++;
  } else
#line 998
  if ((int )*buf_ptr == 62) {
#line 1001
    buf_ptr ++;
#line 1002
    code = (codes_ty )40;
#line 1005
    if ((int )*buf_ptr == 42) {
#line 1007
      buf_ptr ++;
    }
  }
#line 1015
  token_end = buf_ptr;
#line 1016
  goto switch_break___0;
  case_61: /* CIL Label */ 
#line 1020
  if (parser_state_tos->in_or_st) {
#line 1020
    if ((unsigned int )parser_state_tos->last_token != 17U) {
#line 1023
      parser_state_tos->block_init = 1;
#line 1024
      parser_state_tos->block_init_level = 0;
    }
  }
#line 1027
  if ((int )*buf_ptr == 61) {
#line 1029
    buf_ptr ++;
  } else
#line 1031
  if ((int )*buf_ptr == 45) {
    {
#line 1044
    tmp___15 = gettext("old style assignment ambiguity in \"=%c\".  Assuming \"= %c\"\n");
#line 1044
    tmp___16 = gettext("Warning");
#line 1044
    message(tmp___16, tmp___15, (unsigned int *)((unsigned long )*((unsigned char *)buf_ptr)),
            (unsigned int *)((unsigned long )*((unsigned char *)buf_ptr)));
    }
  } else
#line 1031
  if ((int )*buf_ptr == 43) {
    {
#line 1044
    tmp___15 = gettext("old style assignment ambiguity in \"=%c\".  Assuming \"= %c\"\n");
#line 1044
    tmp___16 = gettext("Warning");
#line 1044
    message(tmp___16, tmp___15, (unsigned int *)((unsigned long )*((unsigned char *)buf_ptr)),
            (unsigned int *)((unsigned long )*((unsigned char *)buf_ptr)));
    }
  } else
#line 1031
  if ((int )*buf_ptr == 42) {
    {
#line 1044
    tmp___15 = gettext("old style assignment ambiguity in \"=%c\".  Assuming \"= %c\"\n");
#line 1044
    tmp___16 = gettext("Warning");
#line 1044
    message(tmp___16, tmp___15, (unsigned int *)((unsigned long )*((unsigned char *)buf_ptr)),
            (unsigned int *)((unsigned long )*((unsigned char *)buf_ptr)));
    }
  } else
#line 1031
  if ((int )*buf_ptr == 38) {
    {
#line 1044
    tmp___15 = gettext("old style assignment ambiguity in \"=%c\".  Assuming \"= %c\"\n");
#line 1044
    tmp___16 = gettext("Warning");
#line 1044
    message(tmp___16, tmp___15, (unsigned int *)((unsigned long )*((unsigned char *)buf_ptr)),
            (unsigned int *)((unsigned long )*((unsigned char *)buf_ptr)));
    }
  }
#line 1052
  code = (codes_ty )6;
#line 1053
  unary_delim = 1;
#line 1054
  token_end = buf_ptr;
#line 1055
  goto switch_break___0;
  case_33: /* CIL Label */ 
  case_60: /* CIL Label */ 
  case_62: /* CIL Label */ 
  {
#line 1067
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 1067
    if (! ((int )*buf_ptr == 62)) {
#line 1067
      if (! ((int )*buf_ptr == 60)) {
#line 1067
        if (! ((int )*buf_ptr == 61)) {
#line 1067
          if (settings.c_plus_plus) {
#line 1067
            if (! ((int )*buf_ptr == 63)) {
#line 1067
              goto while_break___10;
            }
          } else {
#line 1067
            goto while_break___10;
          }
        }
      }
    }
#line 1069
    buf_ptr ++;
#line 1069
    if ((unsigned long )buf_ptr >= (unsigned long )buf_end) {
      {
#line 1071
      fill_buffer();
      }
    }
#line 1074
    if ((int )*buf_ptr == 61) {
#line 1076
      buf_ptr ++;
#line 1076
      if ((unsigned long )buf_ptr >= (unsigned long )buf_end) {
        {
#line 1078
        fill_buffer();
        }
      }
    }
  }
  while_break___10: /* CIL Label */ ;
  }
#line 1083
  if (parser_state_tos->last_u_d) {
#line 1083
    code = (codes_ty )5;
  } else {
#line 1083
    code = (codes_ty )6;
  }
#line 1084
  unary_delim = 1;
#line 1085
  token_end = buf_ptr;
#line 1086
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 1089
  if ((int )*(token + 0) == 47) {
#line 1089
    if ((int )*buf_ptr == 42) {
#line 1089
      goto _L___24;
    } else
#line 1089
    if ((int )*buf_ptr == 47) {
      _L___24: /* CIL Label */ 
#line 1093
      if ((int )*buf_ptr == 42) {
#line 1095
        code = (codes_ty )19;
      } else {
#line 1099
        code = (codes_ty )20;
      }
#line 1102
      buf_ptr ++;
#line 1102
      if ((unsigned long )buf_ptr >= (unsigned long )buf_end) {
        {
#line 1104
        fill_buffer();
        }
      }
#line 1107
      if ((unsigned int )code == 19U) {
#line 1110
        p___0 = buf_ptr;
        {
#line 1112
        while (1) {
          while_continue___11: /* CIL Label */ ;
          {
#line 1112
          tmp___17 = __ctype_b_loc();
#line 1112
          tmp___18 = p___0;
#line 1112
          p___0 ++;
          }
#line 1112
          if (! ((int const   )*(*tmp___17 + (int )*tmp___18) & 256)) {
#line 1112
            goto while_break___11;
          }
        }
        while_break___11: /* CIL Label */ ;
        }
#line 1119
        if ((unsigned long )p___0 < (unsigned long )buf_end) {
#line 1119
          if ((int )*(p___0 + -1) == 42) {
#line 1119
            if ((int )*p___0 == 47) {
#line 1121
              buf_ptr = p___0 + 1;
#line 1122
              code = (codes_ty )15;
#line 1123
              parser_state_tos->want_blank = 1;
            }
          }
        }
      }
#line 1127
      unary_delim = parser_state_tos->last_u_d;
    } else {
#line 1089
      goto _L___23;
    }
  } else
  _L___23: /* CIL Label */ 
#line 1129
  if ((unsigned int )parser_state_tos->last_token == 17U) {
#line 1132
    code = (codes_ty )16;
#line 1133
    last_code = (codes_ty )16;
  } else {
    {
#line 1137
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 1137
      if (! ((int )*(buf_ptr - 1) == (int )*buf_ptr)) {
#line 1137
        if (! ((int )*buf_ptr == 61)) {
#line 1137
          goto while_break___12;
        }
      }
#line 1140
      buf_ptr ++;
#line 1140
      if ((unsigned long )buf_ptr >= (unsigned long )buf_end) {
        {
#line 1142
        fill_buffer();
        }
      }
    }
    while_break___12: /* CIL Label */ ;
    }
#line 1145
    if (parser_state_tos->last_u_d) {
#line 1145
      code = (codes_ty )5;
    } else {
#line 1145
      code = (codes_ty )6;
    }
#line 1146
    unary_delim = 1;
  }
#line 1149
  token_end = buf_ptr;
  switch_break___0: /* CIL Label */ ;
  }
#line 1153
  if ((unsigned int )code != 1U) {
#line 1155
    l_struct = 0;
#line 1156
    last_code = code;
  }
#line 1159
  if ((unsigned long )buf_ptr >= (unsigned long )buf_end) {
    {
#line 1161
    fill_buffer();
    }
  }
#line 1164
  parser_state_tos->last_u_d = unary_delim;
#line 1166
  if ((unsigned int )parser_state_tos->last_token == 17U) {
#line 1168
    return ((codes_ty )16);
  }
#line 1171
  return (code);
}
}
#line 1178 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/lexi.c"
extern void addkey(char *key , rwcodes_ty val ) 
{ 
  templ_ty *p ;
  char *tmp ;
  char *tmp___0 ;
  unsigned int tmp___1 ;
  size_t tmp___2 ;
  templ_ty *tmp___3 ;
  size_t tmp___4 ;
  templ_ty *tmp___5 ;

  {
#line 1185
  if (settings.c_plus_plus) {
    {
#line 1185
    tmp___2 = strlen((char const   *)key);
#line 1185
    tmp___3 = is_reserved_cc((char const   *)key, (unsigned int )tmp___2);
    }
#line 1185
    if (! ((unsigned long )tmp___3 != (unsigned long )((templ_ty *)0))) {
#line 1185
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1185
  if (! settings.c_plus_plus) {
    {
#line 1185
    tmp___4 = strlen((char const   *)key);
#line 1185
    tmp___5 = is_reserved((char const   *)key, (unsigned int )tmp___4);
    }
#line 1185
    if (! ((unsigned long )tmp___5 != (unsigned long )((templ_ty *)0))) {
#line 1185
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 1191
    if ((unsigned long )user_specials == (unsigned long )((templ_ty *)0)) {
      {
#line 1193
      tmp = xmalloc((unsigned int )(5UL * sizeof(templ_ty )));
#line 1193
      user_specials = (templ_ty *)tmp;
#line 1194
      user_specials_max = 5U;
#line 1195
      user_specials_idx = 0U;
      }
    } else
#line 1197
    if (user_specials_idx == user_specials_max) {
      {
#line 1199
      user_specials_max += 5U;
#line 1200
      tmp___0 = xrealloc((char *)user_specials, (unsigned int )((unsigned long )user_specials_max * sizeof(templ_ty )));
#line 1200
      user_specials = (templ_ty *)tmp___0;
      }
    }
#line 1207
    tmp___1 = user_specials_idx;
#line 1207
    user_specials_idx ++;
#line 1207
    p = user_specials + tmp___1;
#line 1208
    p->rwd = key;
#line 1209
    p->rwcode = val;
  }
#line 1211
  return;
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 371 "/usr/include/stdio.h"
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 26 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/utils.h"
extern void DieError(int errval , char const   *fmt  , ...) ;
#line 32 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/utils.c"
extern void DieError(int errval , char const   *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 38
  __builtin_va_start(ap, fmt);
#line 40
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
           ap);
#line 42
  __builtin_va_end(ap);
#line 44
  exit(errval);
  }
}
}
#line 515 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/output.h"
int buf_break_used ;
#line 73 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/handletoken.c"
extern void check_code_size(void) 
{ 
  int nsize ;
  char *tmp ;

  {
#line 75
  if ((unsigned long )e_code >= (unsigned long )l_code) {
    {
#line 77
    nsize = (int )((l_code - s_code) + 400L);
#line 78
    tmp = xrealloc(codebuf, (unsigned int )nsize);
#line 78
    codebuf = tmp;
#line 79
    e_code = (codebuf + (e_code - s_code)) + 1;
#line 80
    l_code = (codebuf + nsize) - 5;
#line 81
    s_code = codebuf + 1;
    }
  }
#line 83
  return;
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/handletoken.c"
static void check_lab_size(void) 
{ 
  int nsize ;
  char *tmp ;

  {
#line 91
  if ((unsigned long )e_lab >= (unsigned long )l_lab) {
    {
#line 93
    nsize = (int )((l_lab - s_lab) + 400L);
#line 94
    tmp = xrealloc(labbuf, (unsigned int )nsize);
#line 94
    labbuf = tmp;
#line 95
    e_lab = (labbuf + (e_lab - s_lab)) + 1;
#line 96
    l_lab = (labbuf + nsize) - 5;
#line 97
    s_lab = labbuf + 1;
    }
  }
#line 99
  return;
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/handletoken.c"
static void copy_id(codes_ty const   type_code , BOOLEAN *force_nl , exit_values_ty *file_exit_value ,
                    bb_code_ty const   can_break ) 
{ 
  char *t_ptr ;
  char *tmp ;
  char *tmp___0 ;
  exit_values_ty tmp___1 ;
  int tmp___2 ;

  {
#line 113
  if (parser_state_tos->want_blank) {
    {
#line 115
    set_buf_break((bb_code_ty )20, paren_target);
#line 116
    tmp = e_code;
#line 116
    e_code ++;
#line 116
    *tmp = (char )' ';
    }
  } else
#line 118
  if (can_break) {
    {
#line 120
    set_buf_break((bb_code_ty )can_break, paren_target);
    }
  }
#line 126
  if ((unsigned long )s_code == (unsigned long )e_code) {
#line 128
    s_code_corresponds_to = token;
  }
#line 131
  t_ptr = token;
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;
#line 131
    if (! ((unsigned long )t_ptr < (unsigned long )token_end)) {
#line 131
      goto while_break;
    }
    {
#line 133
    check_code_size();
#line 134
    tmp___0 = e_code;
#line 134
    e_code ++;
#line 134
    *tmp___0 = *t_ptr;
#line 131
    t_ptr ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 137
  *e_code = (char )'\000';
#line 139
  parser_state_tos->want_blank = 1;
#line 143
  if ((unsigned int const   )type_code == 25U) {
#line 143
    if (! settings.space_after_if) {
#line 143
      if ((int )*token == 105) {
#line 148
        parser_state_tos->want_blank = 0;
      } else {
#line 143
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 143
    if (! settings.space_after_for) {
#line 143
      if ((int )*token == 102) {
#line 148
        parser_state_tos->want_blank = 0;
      } else {
#line 143
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 143
    if (! settings.space_after_while) {
#line 143
      if ((int )*token == 119) {
#line 148
        parser_state_tos->want_blank = 0;
      }
    }
  }
#line 154
  if (token_end - token == 1L) {
#line 154
    if ((int )*token == 95) {
#line 158
      parser_state_tos->want_blank = 0;
    } else {
#line 154
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 154
  if (token_end - token == 2L) {
#line 154
    if ((int )*token == 78) {
#line 154
      if ((int )*(token + 1) == 95) {
#line 158
        parser_state_tos->want_blank = 0;
      }
    }
  }
#line 164
  if (token_end - token == 6L) {
    {
#line 164
    tmp___2 = strncmp((char const   *)token, "va_dcl", (size_t )6);
    }
#line 164
    if (tmp___2 == 0) {
#line 166
      parser_state_tos->in_or_st = 0;
#line 167
      (parser_state_tos->just_saw_decl) --;
#line 168
      parser_state_tos->in_decl = (BOOLEAN )0;
      {
#line 170
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 172
        tmp___1 = parse((codes_ty )12);
        }
#line 172
        if ((unsigned int )tmp___1 != 0U) {
#line 174
          *file_exit_value = (exit_values_ty )2;
        }
#line 170
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 178
      *force_nl = (BOOLEAN )1;
    }
  }
#line 180
  return;
}
}
#line 186 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/handletoken.c"
static void handle_token_form_feed(BOOLEAN *pbreak_line ) 
{ 


  {
  {
#line 189
  parser_state_tos->use_ff = 1;
#line 191
  dump_line(1, & paren_target, pbreak_line);
#line 192
  parser_state_tos->want_blank = 0;
  }
#line 193
  return;
}
}
#line 199 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/handletoken.c"
static void handle_token_newline(BOOLEAN *force_nl , BOOLEAN *pbreak_line ) 
{ 


  {
#line 204
  if ((unsigned long )s_lab != (unsigned long )e_lab) {
#line 204
    if ((int )*s_lab == 35) {
      {
#line 206
      dump_line(1, & paren_target, pbreak_line);
      }
#line 208
      if ((unsigned long )s_code == (unsigned long )e_code) {
#line 210
        parser_state_tos->want_blank = 0;
      }
#line 213
      *force_nl = (BOOLEAN )0;
    } else {
#line 204
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
#line 217
  if ((unsigned int )parser_state_tos->last_token != 18U) {
#line 217
    goto _L___2;
  } else
#line 217
  if (! settings.leave_comma) {
#line 217
    goto _L___2;
  } else
#line 217
  if (! break_comma) {
#line 217
    goto _L___2;
  } else
#line 217
  if (parser_state_tos->p_l_follow > 0) {
#line 217
    goto _L___2;
  } else
#line 217
  if (parser_state_tos->block_init) {
#line 217
    goto _L___2;
  } else
#line 217
  if ((unsigned long )s_com != (unsigned long )e_com) {
    _L___2: /* CIL Label */ 
#line 217
    if ((unsigned int )parser_state_tos->last_token != 14U) {
#line 217
      goto _L___1;
    } else
#line 217
    if (settings.braces_on_struct_decl_line) {
#line 217
      if (! parser_state_tos->in_decl) {
#line 217
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
#line 231
      if (! settings.procnames_start_line) {
#line 231
        if ((unsigned long )s_lab == (unsigned long )e_lab) {
#line 231
          if ((unsigned int )parser_state_tos->last_token != 2U) {
#line 231
            if ((unsigned int )parser_state_tos->last_token != 12U) {
#line 231
              if ((unsigned int )parser_state_tos->last_token != 18U) {
#line 231
                if ((unsigned int )parser_state_tos->last_rw == 7U) {
#line 231
                  if (parser_state_tos->last_rw_depth == 0) {
#line 231
                    if (! parser_state_tos->block_init) {
#line 231
                      if (parser_state_tos->in_decl) {
#line 245
                        if ((unsigned long )e_code > (unsigned long )s_code) {
#line 245
                          if (! ((int )*(e_code + -1) == 42)) {
#line 248
                            parser_state_tos->want_blank = 1;
                          }
                        } else {
#line 248
                          parser_state_tos->want_blank = 1;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
#line 252
      if (! parser_state_tos->in_stmt) {
#line 252
        goto _L;
      } else
#line 252
      if ((unsigned long )s_com != (unsigned long )e_com) {
#line 252
        goto _L;
      } else
#line 252
      if (embedded_comment_on_line) {
        _L: /* CIL Label */ 
        {
#line 256
        dump_line(1, & paren_target, pbreak_line);
        }
#line 258
        if ((unsigned long )s_code == (unsigned long )e_code) {
#line 260
          parser_state_tos->want_blank = 0;
        }
#line 263
        *force_nl = (BOOLEAN )0;
      }
    }
  }
#line 271
  else_or_endif = 0;
#line 272
  line_no ++;
#line 273
  return;
}
}
#line 279 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/handletoken.c"
static void handle_token_lparen(BOOLEAN *force_nl , BOOLEAN *sp_sw , int *dec_ind ,
                                BOOLEAN *pbreak_line ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
#line 297
  if ((int )*token == 123) {
#line 297
    if ((unsigned long )s_code != (unsigned long )e_code) {
      {
#line 301
      dump_line(1, & paren_target, pbreak_line);
#line 305
      parser_state_tos->want_blank = 0;
      }
    } else
#line 297
    if ((unsigned long )s_com != (unsigned long )e_com) {
      {
#line 301
      dump_line(1, & paren_target, pbreak_line);
#line 305
      parser_state_tos->want_blank = 0;
      }
    } else
#line 297
    if ((unsigned long )s_lab != (unsigned long )e_lab) {
      {
#line 301
      dump_line(1, & paren_target, pbreak_line);
#line 305
      parser_state_tos->want_blank = 0;
      }
    }
  }
#line 310
  (parser_state_tos->p_l_follow) ++;
#line 312
  if (parser_state_tos->p_l_follow >= parser_state_tos->paren_indents_size) {
    {
#line 314
    parser_state_tos->paren_indents_size *= 2;
#line 315
    tmp = xrealloc((char *)parser_state_tos->paren_indents, (unsigned int )((unsigned long )parser_state_tos->paren_indents_size * sizeof(short )));
#line 315
    parser_state_tos->paren_indents = (short *)tmp;
    }
  }
#line 321
  (parser_state_tos->paren_depth) ++;
#line 323
  if (parser_state_tos->want_blank) {
#line 323
    if ((int )*token != 91) {
#line 323
      if ((unsigned int )parser_state_tos->last_token != 15U) {
        {
#line 330
        set_buf_break((bb_code_ty )4, paren_target);
#line 331
        tmp___0 = e_code;
#line 331
        e_code ++;
#line 331
        *tmp___0 = (char )' ';
#line 332
        *e_code = (char )'\000';
        }
      } else
#line 323
      if (settings.proc_calls_space) {
        {
#line 330
        set_buf_break((bb_code_ty )4, paren_target);
#line 331
        tmp___0 = e_code;
#line 331
        e_code ++;
#line 331
        *tmp___0 = (char )' ';
#line 332
        *e_code = (char )'\000';
        }
      } else
#line 323
      if (parser_state_tos->its_a_keyword) {
#line 323
        if (! parser_state_tos->sizeof_keyword) {
          {
#line 330
          set_buf_break((bb_code_ty )4, paren_target);
#line 331
          tmp___0 = e_code;
#line 331
          e_code ++;
#line 331
          *tmp___0 = (char )' ';
#line 332
          *e_code = (char )'\000';
          }
        } else
#line 323
        if (settings.blank_after_sizeof) {
          {
#line 330
          set_buf_break((bb_code_ty )4, paren_target);
#line 331
          tmp___0 = e_code;
#line 331
          e_code ++;
#line 331
          *tmp___0 = (char )' ';
#line 332
          *e_code = (char )'\000';
          }
        } else {
          {
#line 336
          set_buf_break((bb_code_ty )4, paren_target);
          }
        }
      } else {
        {
#line 336
        set_buf_break((bb_code_ty )4, paren_target);
        }
      }
    } else {
      {
#line 336
      set_buf_break((bb_code_ty )4, paren_target);
      }
    }
  } else {
    {
#line 336
    set_buf_break((bb_code_ty )4, paren_target);
    }
  }
#line 339
  if (parser_state_tos->in_decl) {
#line 339
    if (! parser_state_tos->block_init) {
#line 341
      if ((int )*token != 91) {
#line 341
        if (! buf_break_used) {
          {
#line 343
          while (1) {
            while_continue: /* CIL Label */ ;
#line 343
            if (! (e_code - s_code < (long )*dec_ind)) {
#line 343
              goto while_break;
            }
            {
#line 345
            check_code_size();
#line 346
            set_buf_break((bb_code_ty )5, paren_target);
#line 347
            tmp___1 = e_code;
#line 347
            e_code ++;
#line 347
            *tmp___1 = (char )' ';
            }
          }
          while_break: /* CIL Label */ ;
          }
#line 350
          tmp___2 = e_code;
#line 350
          e_code ++;
#line 350
          *tmp___2 = *(token + 0);
#line 351
          parser_state_tos->ind_stmt = 0;
        } else {
#line 355
          tmp___3 = e_code;
#line 355
          e_code ++;
#line 355
          *tmp___3 = *(token + 0);
        }
      } else {
#line 355
        tmp___3 = e_code;
#line 355
        e_code ++;
#line 355
        *tmp___3 = *(token + 0);
      }
    } else {
#line 360
      tmp___4 = e_code;
#line 360
      e_code ++;
#line 360
      *tmp___4 = *(token + 0);
    }
  } else {
#line 360
    tmp___4 = e_code;
#line 360
    e_code ++;
#line 360
    *tmp___4 = *(token + 0);
  }
#line 363
  if (settings.parentheses_space) {
#line 363
    if ((int )*token != 91) {
#line 365
      tmp___5 = e_code;
#line 365
      e_code ++;
#line 365
      *tmp___5 = (char )' ';
    }
  }
#line 368
  *(parser_state_tos->paren_indents + (parser_state_tos->p_l_follow - 1)) = (short )(e_code - s_code);
#line 371
  if (*sp_sw) {
#line 371
    if (parser_state_tos->p_l_follow == 1) {
#line 371
      if (settings.extra_expression_indent) {
#line 371
        if ((int )*(parser_state_tos->paren_indents + 0) < 2 * settings.ind_size) {
#line 375
          *(parser_state_tos->paren_indents + 0) = (short )(2 * settings.ind_size);
        }
      }
    }
  }
#line 378
  parser_state_tos->want_blank = 0;
#line 380
  if (parser_state_tos->in_or_st == 1) {
#line 380
    if ((int )*token == 40) {
      {
#line 386
      parse_lparen_in_decl();
#line 390
      parser_state_tos->in_or_st = 0;
      }
    }
  }
#line 397
  if ((int )*token == 40) {
#line 397
    if (settings.break_function_decl_args) {
#line 397
      if (parser_state_tos->in_stmt) {
#line 397
        if (parser_state_tos->in_decl) {
#line 397
          if (parser_state_tos->paren_depth == 1) {
            {
#line 403
            dump_line(1, & paren_target, pbreak_line);
#line 404
            *force_nl = (BOOLEAN )0;
#line 406
            paren_target = parser_state_tos->paren_depth * settings.ind_size + 1;
#line 407
            *(parser_state_tos->paren_indents + (parser_state_tos->p_l_follow - 1)) = (short )(- paren_target);
            }
          }
        }
      }
    }
  }
#line 410
  if (parser_state_tos->sizeof_keyword) {
#line 412
    parser_state_tos->sizeof_mask |= 1 << parser_state_tos->p_l_follow;
  }
#line 418
  if ((unsigned int )parser_state_tos->last_token == 24U) {
#line 422
    parser_state_tos->noncast_mask |= 1 << parser_state_tos->p_l_follow;
  } else
#line 418
  if ((unsigned int )parser_state_tos->last_token == 15U) {
#line 418
    if ((unsigned int )parser_state_tos->last_rw != 12U) {
#line 422
      parser_state_tos->noncast_mask |= 1 << parser_state_tos->p_l_follow;
    } else {
#line 427
      parser_state_tos->noncast_mask &= ~ (1 << parser_state_tos->p_l_follow);
    }
  } else {
#line 427
    parser_state_tos->noncast_mask &= ~ (1 << parser_state_tos->p_l_follow);
  }
#line 430
  return;
}
}
#line 436 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/handletoken.c"
static void handle_token_rparen(BOOLEAN *force_nl , BOOLEAN *sp_sw , codes_ty *hd_type ,
                                BOOLEAN *last_token_ends_sp , exit_values_ty *file_exit_value ,
                                BOOLEAN *pbreak_line ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  int level ;
  char *tmp___1 ;
  char *tmp___2 ;
  exit_values_ty tmp___3 ;

  {
#line 445
  (parser_state_tos->paren_depth) --;
#line 451
  if ((int )*token == 41) {
#line 451
    if (settings.break_function_decl_args_end) {
#line 451
      if (! parser_state_tos->in_or_st) {
#line 451
        if (parser_state_tos->in_stmt) {
#line 451
          if (parser_state_tos->in_decl) {
#line 451
            if (parser_state_tos->paren_depth == 0) {
#line 458
              if ((unsigned long )s_code != (unsigned long )e_code) {
                {
#line 460
                dump_line(1, & paren_target, pbreak_line);
                }
              } else
#line 458
              if ((unsigned long )s_lab != (unsigned long )e_lab) {
                {
#line 460
                dump_line(1, & paren_target, pbreak_line);
                }
              } else
#line 458
              if ((unsigned long )s_com != (unsigned long )e_com) {
                {
#line 460
                dump_line(1, & paren_target, pbreak_line);
                }
              }
#line 463
              paren_target = parser_state_tos->paren_depth * settings.ind_size;
#line 464
              *(parser_state_tos->paren_indents + (parser_state_tos->p_l_follow - 1)) = (short )paren_target;
#line 465
              parser_state_tos->ind_stmt = 0;
            }
          }
        }
      }
    }
  }
#line 469
  if ((parser_state_tos->cast_mask & (1 << parser_state_tos->p_l_follow)) & ~ parser_state_tos->sizeof_mask) {
#line 473
    parser_state_tos->last_u_d = 1;
#line 474
    parser_state_tos->cast_mask &= (1 << parser_state_tos->p_l_follow) - 1;
#line 476
    if (! parser_state_tos->cast_mask) {
#line 476
      if (settings.cast_space) {
#line 478
        parser_state_tos->want_blank = 1;
      } else {
#line 482
        parser_state_tos->want_blank = 0;
#line 483
        parser_state_tos->can_break = (bb_code_ty )28;
      }
    } else {
#line 482
      parser_state_tos->want_blank = 0;
#line 483
      parser_state_tos->can_break = (bb_code_ty )28;
    }
  } else
#line 486
  if (parser_state_tos->in_decl) {
#line 486
    if (! parser_state_tos->block_init) {
#line 486
      if (parser_state_tos->paren_depth == 0) {
#line 490
        parser_state_tos->want_blank = 1;
      }
    }
  }
#line 497
  parser_state_tos->sizeof_mask &= (1 << parser_state_tos->p_l_follow) - 1;
#line 500
  (parser_state_tos->p_l_follow) --;
#line 500
  if (parser_state_tos->p_l_follow < 0) {
    {
#line 502
    parser_state_tos->p_l_follow = 0;
#line 503
    tmp = gettext("Extra %c");
#line 503
    tmp___0 = gettext("Warning");
#line 503
    message(tmp___0, tmp, (unsigned int *)((unsigned long )*((unsigned char *)token)),
            (unsigned int *)0);
    }
  }
#line 509
  if ((unsigned long )e_code == (unsigned long )s_code) {
#line 511
    level = parser_state_tos->p_l_follow;
#line 513
    parser_state_tos->paren_level = level;
#line 514
    if (level > 0) {
#line 516
      paren_target = - ((int )*(parser_state_tos->paren_indents + (level - 1)));
    } else {
#line 520
      paren_target = 0;
    }
  }
#line 524
  if (settings.parentheses_space) {
#line 524
    if ((int )*token != 93) {
#line 526
      tmp___1 = e_code;
#line 526
      e_code ++;
#line 526
      *tmp___1 = (char )' ';
    }
  }
#line 529
  tmp___2 = e_code;
#line 529
  e_code ++;
#line 529
  *tmp___2 = *(token + 0);
#line 533
  if (*sp_sw) {
#line 533
    if (parser_state_tos->p_l_follow == 0) {
#line 541
      if ((unsigned int )*(parser_state_tos->p_stack + parser_state_tos->tos) != 36U) {
#line 543
        *last_token_ends_sp = (BOOLEAN )2;
      }
      {
#line 546
      *sp_sw = (BOOLEAN )0;
#line 547
      *force_nl = (BOOLEAN )1;
#line 548
      parser_state_tos->last_u_d = 1;
#line 551
      parser_state_tos->in_stmt = 0;
#line 555
      tmp___3 = parse(*hd_type);
      }
#line 555
      if ((unsigned int )tmp___3 != 0U) {
#line 557
        *file_exit_value = (exit_values_ty )2;
      }
    }
  }
#line 565
  parser_state_tos->search_brace = settings.btype_2;
#line 566
  return;
}
}
#line 572 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/handletoken.c"
static void handle_token_unary_op(int *dec_ind , bb_code_ty const   can_break ) 
{ 
  char *t_ptr ;
  char *tmp ;
  char *res ;
  char *res_end ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 578
  if (parser_state_tos->want_blank) {
    {
#line 580
    set_buf_break((bb_code_ty )6, paren_target);
#line 581
    tmp = e_code;
#line 581
    e_code ++;
#line 581
    *tmp = (char )' ';
#line 582
    *e_code = (char )'\000';
    }
  } else
#line 584
  if (can_break) {
    {
#line 586
    set_buf_break((bb_code_ty )can_break, paren_target);
    }
  }
#line 594
  res = token;
#line 595
  res_end = token_end;
#line 600
  if (parser_state_tos->paren_depth == 0) {
#line 600
    if (parser_state_tos->in_decl) {
#line 600
      if (! buf_break_used) {
#line 600
        if (! parser_state_tos->block_init) {
          {
#line 604
          while (1) {
            while_continue: /* CIL Label */ ;
#line 604
            if (! (e_code - s_code < (long )*dec_ind - (token_end - token))) {
#line 604
              goto while_break;
            }
            {
#line 606
            check_code_size();
#line 607
            set_buf_break((bb_code_ty )5, paren_target);
#line 608
            tmp___0 = e_code;
#line 608
            e_code ++;
#line 608
            *tmp___0 = (char )' ';
            }
          }
          while_break: /* CIL Label */ ;
          }
#line 611
          parser_state_tos->ind_stmt = 0;
        } else {
#line 600
          goto _L___1;
        }
      } else {
#line 600
        goto _L___1;
      }
    } else {
#line 600
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 617
  if ((unsigned int )parser_state_tos->last_token == 5U) {
#line 617
    if ((unsigned long )e_code > (unsigned long )s_code) {
#line 617
      if ((int )*(e_code - 1) == (int )*res) {
#line 621
        tmp___1 = e_code;
#line 621
        e_code ++;
#line 621
        *tmp___1 = (char )' ';
      }
    }
  }
#line 625
  t_ptr = res;
  {
#line 625
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 625
    if (! ((unsigned long )t_ptr < (unsigned long )res_end)) {
#line 625
      goto while_break___0;
    }
    {
#line 627
    check_code_size();
#line 628
    tmp___2 = e_code;
#line 628
    e_code ++;
#line 628
    *tmp___2 = *t_ptr;
#line 625
    t_ptr ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 631
  *e_code = (char )'\000';
#line 634
  parser_state_tos->want_blank = 0;
#line 635
  return;
}
}
#line 641 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/handletoken.c"
static void handle_token_binary_op(bb_code_ty const   can_break ) 
{ 
  char *t_ptr ;
  char *tmp ;
  char *res ;
  char *res_end ;
  char *tmp___0 ;

  {
#line 646
  if (parser_state_tos->want_blank) {
    {
#line 649
    set_buf_break((bb_code_ty )7, paren_target);
#line 650
    tmp = e_code;
#line 650
    e_code ++;
#line 650
    *tmp = (char )' ';
#line 651
    *e_code = (char )'\000';
    }
  } else
#line 646
  if ((unsigned long )e_code > (unsigned long )s_code) {
#line 646
    if ((int )*e_code != 32) {
      {
#line 649
      set_buf_break((bb_code_ty )7, paren_target);
#line 650
      tmp = e_code;
#line 650
      e_code ++;
#line 650
      *tmp = (char )' ';
#line 651
      *e_code = (char )'\000';
      }
    } else {
#line 646
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 653
  if (can_break) {
    {
#line 655
    set_buf_break((bb_code_ty )can_break, paren_target);
    }
  }
#line 663
  res = token;
#line 664
  res_end = token_end;
#line 666
  t_ptr = res;
  {
#line 666
  while (1) {
    while_continue: /* CIL Label */ ;
#line 666
    if (! ((unsigned long )t_ptr < (unsigned long )res_end)) {
#line 666
      goto while_break;
    }
    {
#line 668
    check_code_size();
#line 669
    tmp___0 = e_code;
#line 669
    e_code ++;
#line 669
    *tmp___0 = *t_ptr;
#line 666
    t_ptr ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 674
  if ((int )*token == 61) {
#line 676
    parser_state_tos->in_decl = (BOOLEAN )0;
  }
#line 681
  parser_state_tos->want_blank = 1;
#line 682
  return;
}
}
#line 688 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/handletoken.c"
static void handle_token_postop(void) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
#line 690
  tmp = e_code;
#line 690
  e_code ++;
#line 690
  *tmp = *(token + 0);
#line 691
  tmp___0 = e_code;
#line 691
  e_code ++;
#line 691
  *tmp___0 = *(token + 1);
#line 692
  parser_state_tos->want_blank = 1;
#line 693
  return;
}
}
#line 699 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/handletoken.c"
static void handle_token_question(bb_code_ty const   can_break ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
#line 702
  squest ++;
#line 706
  if (parser_state_tos->want_blank) {
    {
#line 708
    set_buf_break((bb_code_ty )12, paren_target);
#line 709
    tmp = e_code;
#line 709
    e_code ++;
#line 709
    *tmp = (char )' ';
    }
  } else
#line 711
  if (can_break) {
    {
#line 713
    set_buf_break((bb_code_ty )can_break, paren_target);
    }
  }
#line 720
  tmp___0 = e_code;
#line 720
  e_code ++;
#line 720
  *tmp___0 = (char )'?';
#line 721
  parser_state_tos->want_blank = 1;
#line 722
  *e_code = (char )'\000';
#line 723
  return;
}
}
#line 729 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/handletoken.c"
static void handle_token_casestmt(BOOLEAN *scase , exit_values_ty *file_exit_value ) 
{ 
  exit_values_ty tmp ;

  {
#line 733
  *scase = (BOOLEAN )1;
  {
#line 735
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 737
    tmp = parse((codes_ty )9);
    }
#line 737
    if ((unsigned int )tmp != 0U) {
#line 739
      *file_exit_value = (exit_values_ty )2;
    }
#line 735
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 743
  return;
}
}
#line 749 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/handletoken.c"
static void handle_token_colon(BOOLEAN *scase , BOOLEAN *force_nl , int *dec_ind ,
                               bb_code_ty const   can_break , BOOLEAN *pbreak_line ) 
{ 
  char *t_ptr ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *p1 ;
  char *p2 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  unsigned short const   **tmp___5 ;
  int tmp___6 ;
  unsigned short const   **tmp___7 ;
  int tmp___8 ;
  unsigned short const   **tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;

  {
#line 758
  if (squest > 0) {
#line 762
    squest --;
#line 763
    if (parser_state_tos->want_blank) {
      {
#line 765
      set_buf_break((bb_code_ty )13, paren_target);
#line 766
      tmp = e_code;
#line 766
      e_code ++;
#line 766
      *tmp = (char )' ';
      }
    } else
#line 768
    if (can_break) {
      {
#line 770
      set_buf_break((bb_code_ty )can_break, paren_target);
      }
    }
#line 777
    tmp___0 = e_code;
#line 777
    e_code ++;
#line 777
    *tmp___0 = (char )':';
#line 778
    *e_code = (char )'\000';
#line 779
    parser_state_tos->want_blank = 1;
  } else {
#line 796
    if (parser_state_tos->in_decl) {
#line 798
      if (e_code - s_code > 6L) {
        {
#line 798
        tmp___4 = strncmp((char const   *)(buf_ptr + -8), "private:", (size_t )8);
        }
#line 798
        if (tmp___4) {
#line 798
          goto _L___4;
        } else {
          {
#line 798
          tmp___5 = __ctype_b_loc();
          }
#line 798
          if ((int const   )*(*tmp___5 + (int )*buf_ptr) & 2048) {
#line 798
            goto _L___4;
          } else
          _L___0: /* CIL Label */ 
#line 812
          if ((int )*s_code == 32) {
#line 824
            p1 = s_code;
#line 825
            p2 = s_code + *dec_ind;
            {
#line 827
            while (1) {
              while_continue: /* CIL Label */ ;
#line 827
              if (! ((unsigned long )p2 < (unsigned long )e_code)) {
#line 827
                goto while_break;
              }
#line 829
              tmp___2 = p1;
#line 829
              p1 ++;
#line 829
              tmp___3 = p2;
#line 829
              p2 ++;
#line 829
              *tmp___2 = *tmp___3;
            }
            while_break: /* CIL Label */ ;
            }
#line 832
            e_code -= *dec_ind;
#line 833
            *e_code = (char )'\000';
          }
        }
      } else
      _L___4: /* CIL Label */ 
#line 798
      if (e_code - s_code > 8L) {
        {
#line 798
        tmp___6 = strncmp((char const   *)(buf_ptr + -10), "protected:", (size_t )10);
        }
#line 798
        if (tmp___6) {
#line 798
          goto _L___2;
        } else {
          {
#line 798
          tmp___7 = __ctype_b_loc();
          }
#line 798
          if ((int const   )*(*tmp___7 + (int )*buf_ptr) & 2048) {
#line 798
            goto _L___2;
          } else {
#line 798
            goto _L___0;
          }
        }
      } else
      _L___2: /* CIL Label */ 
#line 798
      if (e_code - s_code > 5L) {
        {
#line 798
        tmp___8 = strncmp((char const   *)(buf_ptr + -7), "public:", (size_t )7);
        }
#line 798
        if (tmp___8) {
#line 808
          tmp___1 = e_code;
#line 808
          e_code ++;
#line 808
          *tmp___1 = (char )':';
#line 809
          parser_state_tos->want_blank = 0;
#line 810
          return;
        } else {
          {
#line 798
          tmp___9 = __ctype_b_loc();
          }
#line 798
          if ((int const   )*(*tmp___9 + (int )*buf_ptr) & 2048) {
#line 808
            tmp___1 = e_code;
#line 808
            e_code ++;
#line 808
            *tmp___1 = (char )':';
#line 809
            parser_state_tos->want_blank = 0;
#line 810
            return;
          } else {
#line 798
            goto _L___0;
          }
        }
      } else {
#line 808
        tmp___1 = e_code;
#line 808
        e_code ++;
#line 808
        *tmp___1 = (char )':';
#line 809
        parser_state_tos->want_blank = 0;
#line 810
        return;
      }
    }
#line 841
    parser_state_tos->in_stmt = 0;
#line 843
    t_ptr = s_code;
    {
#line 843
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 843
      if (! *t_ptr) {
#line 843
        goto while_break___0;
      }
      {
#line 845
      check_lab_size();
#line 846
      tmp___10 = e_lab;
#line 846
      e_lab ++;
#line 846
      *tmp___10 = *t_ptr;
#line 843
      t_ptr ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 849
    e_code = s_code;
#line 850
    clear_buf_break_list(pbreak_line);
#line 855
    tmp___11 = e_lab;
#line 855
    e_lab ++;
#line 855
    *tmp___11 = (char )':';
#line 856
    set_buf_break((bb_code_ty )14, paren_target);
#line 857
    tmp___12 = e_lab;
#line 857
    e_lab ++;
#line 857
    *tmp___12 = (char )' ';
#line 858
    *e_lab = (char )'\000';
#line 864
    tmp___13 = (int )*scase;
#line 864
    parser_state_tos->pcase = tmp___13;
#line 864
    *force_nl = (BOOLEAN )tmp___13;
#line 865
    *scase = (BOOLEAN )0;
#line 866
    parser_state_tos->want_blank = 0;
    }
  }
#line 868
  return;
}
}
#line 874 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/handletoken.c"
static void handle_token_doublecolon(void) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
#line 876
  tmp = e_code;
#line 876
  e_code ++;
#line 876
  *tmp = (char )':';
#line 877
  tmp___0 = e_code;
#line 877
  e_code ++;
#line 877
  *tmp___0 = (char )':';
#line 878
  parser_state_tos->want_blank = 0;
#line 879
  parser_state_tos->can_break = (bb_code_ty )27;
#line 880
  parser_state_tos->last_u_d = 1;
#line 881
  parser_state_tos->saw_double_colon = 1;
#line 882
  return;
}
}
#line 888 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/handletoken.c"
static void handle_token_semicolon(BOOLEAN *scase , BOOLEAN *force_nl , BOOLEAN *sp_sw ,
                                   int *dec_ind , BOOLEAN *last_token_ends_sp , exit_values_ty *file_exit_value ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  exit_values_ty tmp___2 ;

  {
#line 896
  parser_state_tos->in_or_st = 0;
#line 897
  parser_state_tos->saw_double_colon = 0;
#line 898
  *scase = (BOOLEAN )0;
#line 899
  squest = 0;
#line 908
  parser_state_tos->cast_mask = 0;
#line 909
  parser_state_tos->sizeof_mask = 0;
#line 910
  parser_state_tos->block_init = 0;
#line 911
  parser_state_tos->block_init_level = 0;
#line 912
  (parser_state_tos->just_saw_decl) --;
#line 914
  if (parser_state_tos->in_decl) {
#line 914
    if ((unsigned long )s_code == (unsigned long )e_code) {
#line 914
      if (! buf_break_used) {
#line 914
        if (! parser_state_tos->block_init) {
          {
#line 918
          while (1) {
            while_continue: /* CIL Label */ ;
#line 918
            if (! (e_code - s_code < (long )(*dec_ind - 1))) {
#line 918
              goto while_break;
            }
            {
#line 920
            check_code_size();
#line 921
            set_buf_break((bb_code_ty )5, paren_target);
#line 922
            tmp = e_code;
#line 922
            e_code ++;
#line 922
            *tmp = (char )' ';
            }
          }
          while_break: /* CIL Label */ ;
          }
#line 925
          parser_state_tos->ind_stmt = 0;
        }
      }
    }
  }
#line 928
  *e_code = (char )'\000';
#line 933
  if (parser_state_tos->dec_nest > 0) {
#line 933
    parser_state_tos->in_decl = (BOOLEAN )1;
  } else {
#line 933
    parser_state_tos->in_decl = (BOOLEAN )0;
  }
#line 939
  if (*last_token_ends_sp) {
#line 939
    if (settings.space_sp_semicolon) {
#line 941
      tmp___0 = e_code;
#line 941
      e_code ++;
#line 941
      *tmp___0 = (char )' ';
    }
  }
#line 944
  tmp___1 = e_code;
#line 944
  e_code ++;
#line 944
  *tmp___1 = (char )';';
#line 945
  *e_code = (char )'\000';
#line 946
  parser_state_tos->want_blank = 1;
#line 950
  parser_state_tos->in_stmt = parser_state_tos->p_l_follow > 0;
#line 952
  if (! *sp_sw) {
    {
#line 954
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 956
      tmp___2 = parse((codes_ty )12);
      }
#line 956
      if ((unsigned int )tmp___2 != 0U) {
#line 958
        *file_exit_value = (exit_values_ty )2;
      }
#line 954
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 962
    *force_nl = (BOOLEAN )1;
  }
#line 964
  return;
}
}
#line 970 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/handletoken.c"
static void handle_token_lbrace(BOOLEAN *force_nl , int *dec_ind , exit_values_ty *file_exit_value ,
                                BOOLEAN *pbreak_line ) 
{ 
  char *p ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  exit_values_ty tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
#line 976
  parser_state_tos->saw_double_colon = 0;
#line 978
  if (! parser_state_tos->block_init) {
#line 980
    *force_nl = (BOOLEAN )1;
#line 982
    parser_state_tos->in_stmt = 0;
  } else {
#line 988
    p = buf_ptr;
    {
#line 990
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 992
      p = skip_horiz_space((char const   *)p);
      }
#line 994
      if ((int )*p == 10) {
#line 996
        parser_state_tos->in_stmt = 0;
#line 997
        goto while_break;
      } else
#line 994
      if ((int )*p == 47) {
#line 994
        if ((int )*(p + 1) == 47) {
#line 996
          parser_state_tos->in_stmt = 0;
#line 997
          goto while_break;
        } else {
#line 994
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 999
      if ((int )*p == 47) {
#line 999
        if ((int )*(p + 1) == 42) {
#line 1001
          p += 2;
          {
#line 1004
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 1004
            if (*p) {
#line 1004
              if ((int )*p != 10) {
#line 1004
                if (! ((int )*p != 42)) {
#line 1004
                  if (! ((int )*(p + 1) != 47)) {
#line 1004
                    goto while_break___0;
                  }
                }
              } else {
#line 1004
                goto while_break___0;
              }
            } else {
#line 1004
              goto while_break___0;
            }
#line 1006
            p ++;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 1009
          if (! *p) {
#line 1011
            parser_state_tos->in_stmt = 0;
#line 1012
            goto while_break;
          } else
#line 1009
          if ((int )*p == 10) {
#line 1011
            parser_state_tos->in_stmt = 0;
#line 1012
            goto while_break;
          }
#line 1014
          p += 2;
#line 1016
          if (! *p) {
#line 1018
            goto while_break;
          }
        } else {
#line 1023
          goto while_break;
        }
      } else {
#line 1023
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 1028
    if (parser_state_tos->block_init_level <= 0) {
#line 1030
      parser_state_tos->block_init_level = 1;
    } else {
#line 1034
      (parser_state_tos->block_init_level) ++;
    }
  }
#line 1038
  if ((unsigned long )s_code != (unsigned long )e_code) {
#line 1038
    if (parser_state_tos->block_init != 1) {
#line 1040
      if (! parser_state_tos->in_decl) {
#line 1040
        if (! settings.btype_2) {
          {
#line 1045
          dump_line(1, & paren_target, pbreak_line);
#line 1046
          parser_state_tos->want_blank = 0;
          }
        } else {
#line 1040
          goto _L___2;
        }
      } else
      _L___2: /* CIL Label */ 
#line 1040
      if (parser_state_tos->in_decl) {
#line 1040
        if (! settings.braces_on_struct_decl_line) {
#line 1040
          if (! settings.braces_on_func_def_line) {
            {
#line 1045
            dump_line(1, & paren_target, pbreak_line);
#line 1046
            parser_state_tos->want_blank = 0;
            }
          } else {
#line 1040
            goto _L___1;
          }
        } else {
#line 1040
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 1050
      if (parser_state_tos->in_parameter_declaration) {
#line 1050
        if (! parser_state_tos->in_or_st) {
#line 1053
          parser_state_tos->i_l_follow = 0;
#line 1055
          if (! settings.braces_on_func_def_line) {
            {
#line 1057
            dump_line(1, & paren_target, pbreak_line);
            }
          } else {
#line 1061
            tmp = e_code;
#line 1061
            e_code ++;
#line 1061
            *tmp = (char )' ';
          }
#line 1064
          parser_state_tos->want_blank = 0;
        } else {
#line 1068
          parser_state_tos->want_blank = 1;
        }
      } else {
#line 1068
        parser_state_tos->want_blank = 1;
      }
    }
  }
#line 1073
  if (parser_state_tos->in_parameter_declaration) {
#line 1075
    prefix_blankline_requested = 0;
  }
#line 1078
  if ((unsigned long )s_code == (unsigned long )e_code) {
#line 1080
    parser_state_tos->ind_stmt = 0;
  }
#line 1084
  if (parser_state_tos->in_decl) {
#line 1084
    if (parser_state_tos->in_or_st) {
#line 1088
      if (parser_state_tos->dec_nest >= di_stack_alloc) {
        {
#line 1090
        di_stack_alloc *= 2;
#line 1091
        tmp___0 = xrealloc((char *)di_stack, (unsigned int )((unsigned long )di_stack_alloc * sizeof(*di_stack)));
#line 1091
        di_stack = (int *)tmp___0;
        }
      }
#line 1096
      tmp___1 = parser_state_tos->dec_nest;
#line 1096
      (parser_state_tos->dec_nest) ++;
#line 1096
      *(di_stack + tmp___1) = *dec_ind;
    } else {
#line 1100
      parser_state_tos->in_decl = (BOOLEAN )0;
#line 1101
      parser_state_tos->decl_on_line = 0;
#line 1108
      parser_state_tos->in_parameter_declaration = 0;
    }
  } else {
#line 1100
    parser_state_tos->in_decl = (BOOLEAN )0;
#line 1101
    parser_state_tos->decl_on_line = 0;
#line 1108
    parser_state_tos->in_parameter_declaration = 0;
  }
#line 1111
  *dec_ind = 0;
#line 1117
  parser_state_tos->in_or_st = 0;
  {
#line 1119
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 1121
    tmp___2 = parse((codes_ty )13);
    }
#line 1121
    if ((unsigned int )tmp___2 != 0U) {
#line 1123
      *file_exit_value = (exit_values_ty )2;
    }
#line 1119
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1127
  set_buf_break((bb_code_ty )16, paren_target);
  }
#line 1129
  if (parser_state_tos->want_blank) {
#line 1129
    if ((unsigned long )s_code != (unsigned long )e_code) {
#line 1133
      tmp___3 = e_code;
#line 1133
      e_code ++;
#line 1133
      *tmp___3 = (char )' ';
    }
  }
#line 1136
  parser_state_tos->want_blank = 0;
#line 1137
  tmp___4 = e_code;
#line 1137
  e_code ++;
#line 1137
  *tmp___4 = (char )'{';
#line 1138
  *e_code = (char )'\000';
#line 1140
  parser_state_tos->just_saw_decl = 0;
#line 1142
  if (parser_state_tos->block_init) {
#line 1142
    if (parser_state_tos->block_init_level >= 2) {
#line 1148
      (parser_state_tos->p_l_follow) ++;
#line 1148
      if (parser_state_tos->p_l_follow >= parser_state_tos->paren_indents_size) {
        {
#line 1151
        parser_state_tos->paren_indents_size *= 2;
#line 1152
        tmp___5 = xrealloc((char *)parser_state_tos->paren_indents, (unsigned int )((unsigned long )parser_state_tos->paren_indents_size * sizeof(short )));
#line 1152
        parser_state_tos->paren_indents = (short *)tmp___5;
        }
      }
#line 1159
      (parser_state_tos->paren_depth) ++;
#line 1160
      *(parser_state_tos->paren_indents + (parser_state_tos->p_l_follow - 1)) = (short )(e_code - s_code);
    } else {
#line 1142
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
#line 1163
  if (parser_state_tos->block_init) {
#line 1163
    if (parser_state_tos->block_init_level == 1) {
#line 1168
      parser_state_tos->want_blank = 1;
    }
  }
#line 1174
  return;
}
}
#line 1180 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/handletoken.c"
static void handle_token_rbrace(BOOLEAN *force_nl , int *dec_ind , exit_values_ty *file_exit_value ,
                                BOOLEAN *pbreak_line ) 
{ 
  exit_values_ty tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  exit_values_ty tmp___5 ;
  int tmp___6 ;

  {
#line 1187
  if ((unsigned int )*(parser_state_tos->p_stack + parser_state_tos->tos) == 24U) {
#line 1187
    if (! parser_state_tos->block_init) {
#line 1187
      goto _L;
    } else {
#line 1187
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1187
  if ((unsigned int )*(parser_state_tos->p_stack + parser_state_tos->tos) == 9U) {
    _L: /* CIL Label */ 
    {
#line 1192
    tmp = parse((codes_ty )12);
    }
#line 1192
    if ((unsigned int )tmp != 0U) {
#line 1194
      *file_exit_value = (exit_values_ty )2;
    }
  }
#line 1198
  parser_state_tos->just_saw_decl = 0;
#line 1199
  parser_state_tos->ind_stmt = 0;
#line 1200
  parser_state_tos->in_stmt = 0;
#line 1202
  tmp___1 = parser_state_tos->block_init_level;
#line 1202
  (parser_state_tos->block_init_level) --;
#line 1202
  if (tmp___1 == 1) {
#line 1202
    if ((unsigned long )s_code != (unsigned long )e_code) {
#line 1208
      if (parser_state_tos->matching_brace_on_same_line < 0) {
        {
#line 1213
        dump_line(1, & paren_target, pbreak_line);
        }
      } else {
        {
#line 1218
        set_buf_break((bb_code_ty )17, paren_target);
#line 1219
        tmp___0 = e_code;
#line 1219
        e_code ++;
#line 1219
        *tmp___0 = (char )' ';
        }
      }
    }
  }
#line 1223
  tmp___2 = e_code;
#line 1223
  e_code ++;
#line 1223
  *tmp___2 = (char )'}';
#line 1224
  parser_state_tos->want_blank = 1;
#line 1226
  if (parser_state_tos->block_init) {
#line 1226
    if (parser_state_tos->block_init_level > 0) {
#line 1231
      (parser_state_tos->paren_depth) --;
#line 1233
      (parser_state_tos->p_l_follow) --;
#line 1233
      if (parser_state_tos->p_l_follow < 0) {
        {
#line 1235
        parser_state_tos->p_l_follow = 0;
#line 1236
        tmp___3 = gettext("Extra %c");
#line 1236
        tmp___4 = gettext("Warning");
#line 1236
        message(tmp___4, tmp___3, (unsigned int *)((unsigned long )*((unsigned char *)token)),
                (unsigned int *)0);
        }
      }
    } else {
#line 1226
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 1240
  if (parser_state_tos->dec_nest > 0) {
#line 1245
    (parser_state_tos->dec_nest) --;
#line 1245
    *dec_ind = *(di_stack + parser_state_tos->dec_nest);
#line 1247
    if (parser_state_tos->dec_nest == 0) {
#line 1247
      if (! parser_state_tos->in_parameter_declaration) {
#line 1250
        parser_state_tos->just_saw_decl = 2;
      }
    }
#line 1253
    parser_state_tos->in_decl = (BOOLEAN )1;
  }
  {
#line 1260
  prefix_blankline_requested = 0;
#line 1262
  tmp___5 = parse((codes_ty )14);
  }
#line 1262
  if ((unsigned int )tmp___5 != 0U) {
#line 1264
    *file_exit_value = (exit_values_ty )2;
  }
#line 1267
  if (settings.cuddle_else) {
#line 1267
    if ((unsigned int )*(parser_state_tos->p_stack + parser_state_tos->tos) == 38U) {
#line 1267
      tmp___6 = 1;
    } else {
#line 1267
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 1267
  if (settings.cuddle_do_while) {
#line 1267
    if ((unsigned int )*(parser_state_tos->p_stack + parser_state_tos->tos) == 36U) {
#line 1267
      tmp___6 = 1;
    } else {
#line 1267
      tmp___6 = 0;
    }
  } else {
#line 1267
    tmp___6 = 0;
  }
#line 1267
  parser_state_tos->search_brace = tmp___6;
#line 1273
  if ((unsigned int )*(parser_state_tos->p_stack + parser_state_tos->tos) == 33U) {
#line 1275
    if ((unsigned int )parser_state_tos->last_rw != 5U) {
#line 1275
      if ((unsigned int )parser_state_tos->last_rw != 6U) {
#line 1275
        if ((unsigned int )parser_state_tos->last_rw != 7U) {
#line 1279
          *force_nl = (BOOLEAN )1;
        }
      }
    }
  }
#line 1294
  if ((unsigned int )*(parser_state_tos->p_stack + parser_state_tos->tos) == 38U) {
#line 1298
    *force_nl = (BOOLEAN )1;
  } else
#line 1294
  if ((unsigned int )*(parser_state_tos->p_stack + parser_state_tos->tos) == 36U) {
#line 1294
    if (! settings.cuddle_do_while) {
#line 1294
      if (! settings.btype_2) {
#line 1298
        *force_nl = (BOOLEAN )1;
      }
    }
  }
#line 1301
  if (! parser_state_tos->in_decl) {
#line 1301
    if (parser_state_tos->tos <= 0) {
#line 1301
      if (settings.blanklines_after_procs) {
#line 1301
        if (parser_state_tos->dec_nest <= 0) {
#line 1304
          postfix_blankline_requested = 1;
#line 1305
          if (parser_state_tos->in_decl) {
#line 1305
            postfix_blankline_requested_code = (codes_ty )24;
          } else {
#line 1305
            postfix_blankline_requested_code = (codes_ty )14;
          }
        }
      }
    }
  }
#line 1308
  return;
}
}
#line 1314 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/handletoken.c"
static void handle_token_swstmt(BOOLEAN *sp_sw , codes_ty *hd_type ) 
{ 


  {
#line 1319
  *sp_sw = (BOOLEAN )1;
#line 1320
  *hd_type = (codes_ty )21;
#line 1322
  parser_state_tos->in_decl = (BOOLEAN )0;
#line 1323
  return;
}
}
#line 1329 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/handletoken.c"
static void handle_token_sp_paren(BOOLEAN *sp_sw , codes_ty *hd_type ) 
{ 
  int tmp ;

  {
#line 1334
  *sp_sw = (BOOLEAN )1;
#line 1337
  if ((int )*token == 105) {
#line 1337
    *hd_type = (codes_ty )28;
  } else {
#line 1337
    if ((int )*token == 119) {
#line 1337
      tmp = 30;
    } else {
#line 1337
      tmp = 31;
    }
#line 1337
    *hd_type = (codes_ty )tmp;
  }
#line 1339
  return;
}
}
#line 1345 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/handletoken.c"
static void handle_token_nparen(BOOLEAN *force_nl , exit_values_ty *file_exit_value ,
                                BOOLEAN *last_else , BOOLEAN *pbreak_line ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  exit_values_ty tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  exit_values_ty tmp___4 ;

  {
#line 1351
  parser_state_tos->in_stmt = 0;
#line 1352
  if ((int )*token == 101) {
#line 1354
    if ((unsigned long )e_code != (unsigned long )s_code) {
#line 1354
      if (! settings.cuddle_else) {
#line 1354
        goto _L;
      } else
#line 1354
      if ((int )*(e_code + -1) != 125) {
        _L: /* CIL Label */ 
#line 1356
        if (settings.verbose) {
          {
#line 1358
          tmp = gettext("Line broken");
#line 1358
          tmp___0 = gettext("Warning");
#line 1358
          message(tmp___0, tmp, (unsigned int *)0, (unsigned int *)0);
          }
        }
        {
#line 1361
        dump_line(1, & paren_target, pbreak_line);
#line 1362
        parser_state_tos->want_blank = 0;
        }
      }
    }
    {
#line 1367
    *force_nl = (BOOLEAN )1;
#line 1369
    *last_else = (BOOLEAN )1;
#line 1371
    tmp___1 = parse((codes_ty )34);
    }
#line 1371
    if ((unsigned int )tmp___1 != 0U) {
#line 1373
      *file_exit_value = (exit_values_ty )2;
    }
  } else {
#line 1378
    if ((unsigned long )e_code != (unsigned long )s_code) {
#line 1382
      if (settings.verbose) {
        {
#line 1384
        tmp___2 = gettext("Line broken");
#line 1384
        tmp___3 = gettext("Warning");
#line 1384
        message(tmp___3, tmp___2, (unsigned int *)0, (unsigned int *)0);
        }
      }
      {
#line 1387
      dump_line(1, & paren_target, pbreak_line);
#line 1388
      parser_state_tos->want_blank = 0;
      }
    }
    {
#line 1391
    *force_nl = (BOOLEAN )1;
#line 1393
    *last_else = (BOOLEAN )0;
#line 1395
    tmp___4 = parse((codes_ty )35);
    }
#line 1395
    if ((unsigned int )tmp___4 != 0U) {
#line 1397
      *file_exit_value = (exit_values_ty )2;
    }
  }
#line 1400
  return;
}
}
#line 1406 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/handletoken.c"
static void handle_token_overloaded(bb_code_ty const   can_break ) 
{ 
  char *t_ptr ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 1411
  if (parser_state_tos->want_blank) {
    {
#line 1413
    set_buf_break((bb_code_ty )18, paren_target);
#line 1414
    tmp = e_code;
#line 1414
    e_code ++;
#line 1414
    *tmp = (char )' ';
    }
  } else
#line 1416
  if (can_break) {
    {
#line 1418
    set_buf_break((bb_code_ty )can_break, paren_target);
    }
  }
#line 1425
  parser_state_tos->want_blank = 1;
#line 1427
  t_ptr = token;
  {
#line 1427
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1427
    if (! ((unsigned long )t_ptr < (unsigned long )token_end)) {
#line 1427
      goto while_break;
    }
    {
#line 1429
    check_code_size();
#line 1430
    tmp___0 = e_code;
#line 1430
    e_code ++;
#line 1430
    *tmp___0 = *t_ptr;
#line 1427
    t_ptr ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1433
  *e_code = (char )'\000';
#line 1434
  return;
}
}
#line 1440 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/handletoken.c"
static void handle_token_decl(int *dec_ind , exit_values_ty *file_exit_value , BOOLEAN *pbreak_line ) 
{ 
  char *t_ptr ;
  char *tmp ;
  char *tmp___0 ;
  exit_values_ty tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1452
  if ((unsigned int )parser_state_tos->last_token == 3U) {
#line 1452
    if (parser_state_tos->in_parameter_declaration) {
#line 1452
      if (parser_state_tos->saw_double_colon) {
        {
#line 1452
        tmp___3 = strncmp((char const   *)token, "const", (size_t )5);
        }
#line 1452
        if (tmp___3) {
#line 1452
          goto _L___1;
        } else {
          {
#line 1458
          set_buf_break((bb_code_ty )19, paren_target);
#line 1459
          tmp = e_code;
#line 1459
          e_code ++;
#line 1459
          *tmp = (char )' ';
#line 1461
          t_ptr = token;
          }
          {
#line 1461
          while (1) {
            while_continue: /* CIL Label */ ;
#line 1461
            if (! ((unsigned long )t_ptr < (unsigned long )token_end)) {
#line 1461
              goto while_break;
            }
            {
#line 1463
            check_code_size();
#line 1464
            tmp___0 = e_code;
#line 1464
            e_code ++;
#line 1464
            *tmp___0 = *t_ptr;
#line 1461
            t_ptr ++;
            }
          }
          while_break: /* CIL Label */ ;
          }
#line 1467
          *e_code = (char )'\000';
        }
      } else {
#line 1452
        goto _L___1;
      }
    } else {
#line 1452
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
#line 1472
    if (! parser_state_tos->sizeof_mask) {
      {
#line 1474
      tmp___1 = parse((codes_ty )24);
      }
#line 1474
      if ((unsigned int )tmp___1 != 0U) {
#line 1476
        *file_exit_value = (exit_values_ty )2;
      }
    }
#line 1480
    if ((unsigned int )parser_state_tos->last_token == 3U) {
#line 1480
      if (parser_state_tos->tos <= 1) {
#line 1483
        parser_state_tos->in_parameter_declaration = 1;
#line 1485
        if ((unsigned long )s_code != (unsigned long )e_code) {
          {
#line 1487
          dump_line(1, & paren_target, pbreak_line);
#line 1488
          parser_state_tos->want_blank = 0;
          }
        }
      }
    }
#line 1492
    if (parser_state_tos->in_parameter_declaration) {
#line 1492
      if (parser_state_tos->dec_nest == 0) {
#line 1492
        if (parser_state_tos->p_l_follow == 0) {
#line 1496
          tmp___2 = settings.indent_parameters;
#line 1496
          parser_state_tos->i_l_follow = tmp___2;
#line 1496
          parser_state_tos->ind_level = tmp___2;
#line 1499
          parser_state_tos->ind_stmt = 0;
        }
      }
    }
#line 1505
    if (! parser_state_tos->paren_depth) {
#line 1507
      parser_state_tos->in_or_st = 1;
    }
#line 1510
    if (! parser_state_tos->sizeof_mask) {
#line 1512
      parser_state_tos->in_decl = (BOOLEAN )1;
#line 1513
      parser_state_tos->decl_on_line = 1;
#line 1515
      if (parser_state_tos->dec_nest <= 0) {
#line 1517
        parser_state_tos->just_saw_decl = 2;
      }
    }
#line 1553
    if (settings.decl_indent > 0) {
#line 1553
      *dec_ind = settings.decl_indent;
    } else {
#line 1553
      *dec_ind = (int )((token_end - token) + 1L);
    }
  }
#line 1556
  return;
}
}
#line 1562 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/handletoken.c"
static void handle_token_ident(BOOLEAN *force_nl , BOOLEAN *sp_sw , codes_ty *hd_type ,
                               int *dec_ind , exit_values_ty *file_exit_value , bb_code_ty const   can_break ,
                               BOOLEAN is_procname_definition , BOOLEAN *pbreak_line ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  exit_values_ty tmp___1 ;

  {
#line 1575
  if (parser_state_tos->in_decl) {
#line 1575
    if (parser_state_tos->p_l_follow == 0) {
#line 1575
      if ((unsigned int )parser_state_tos->last_token != 14U) {
#line 1579
        if (parser_state_tos->want_blank) {
          {
#line 1581
          set_buf_break((bb_code_ty )20, paren_target);
#line 1582
          tmp = e_code;
#line 1582
          e_code ++;
#line 1582
          *tmp = (char )' ';
#line 1583
          *e_code = (char )'\000';
          }
        } else
#line 1585
        if (can_break) {
          {
#line 1587
          set_buf_break((bb_code_ty )can_break, paren_target);
          }
        }
#line 1594
        parser_state_tos->want_blank = 0;
#line 1596
        if ((int )is_procname_definition == 0) {
#line 1596
          goto _L;
        } else
#line 1596
        if (! settings.procnames_start_line) {
#line 1596
          if ((unsigned long )s_code != (unsigned long )e_code) {
            _L: /* CIL Label */ 
#line 1599
            if (! parser_state_tos->block_init) {
#line 1599
              if (! buf_break_used) {
#line 1601
                if (is_procname_definition) {
#line 1603
                  *dec_ind = 0;
                }
                {
#line 1606
                while (1) {
                  while_continue: /* CIL Label */ ;
#line 1606
                  if (! (e_code - s_code < (long )*dec_ind)) {
#line 1606
                    goto while_break;
                  }
                  {
#line 1608
                  check_code_size();
#line 1609
                  set_buf_break((bb_code_ty )5, paren_target);
#line 1610
                  tmp___0 = e_code;
#line 1610
                  e_code ++;
#line 1610
                  *tmp___0 = (char )' ';
                  }
                }
                while_break: /* CIL Label */ ;
                }
#line 1613
                *e_code = (char )'\000';
#line 1614
                parser_state_tos->ind_stmt = 0;
              }
            }
          } else {
#line 1596
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
#line 1619
          if ((unsigned long )s_code != (unsigned long )e_code) {
#line 1619
            if ((unsigned int )parser_state_tos->last_token != 11U) {
              {
#line 1622
              dump_line(1, & paren_target, pbreak_line);
              }
            }
          }
#line 1625
          *dec_ind = 0;
#line 1626
          parser_state_tos->want_blank = 0;
        }
      } else {
#line 1575
        goto _L___2;
      }
    } else {
#line 1575
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 1629
  if (*sp_sw) {
#line 1629
    if (parser_state_tos->p_l_follow == 0) {
      {
#line 1631
      *sp_sw = (BOOLEAN )0;
#line 1632
      *force_nl = (BOOLEAN )1;
#line 1633
      parser_state_tos->last_u_d = 1;
#line 1634
      parser_state_tos->in_stmt = 0;
#line 1636
      tmp___1 = parse(*hd_type);
      }
#line 1636
      if ((unsigned int )tmp___1 != 0U) {
#line 1638
        *file_exit_value = (exit_values_ty )2;
      }
    }
  }
#line 1645
  return;
}
}
#line 1651 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/handletoken.c"
static void handle_token_struct_delim(void) 
{ 
  char *t_ptr ;
  char *tmp ;

  {
#line 1654
  t_ptr = token;
  {
#line 1654
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1654
    if (! ((unsigned long )t_ptr < (unsigned long )token_end)) {
#line 1654
      goto while_break;
    }
    {
#line 1656
    check_code_size();
#line 1657
    tmp = e_code;
#line 1657
    e_code ++;
#line 1657
    *tmp = *t_ptr;
#line 1654
    t_ptr ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1660
  parser_state_tos->want_blank = 0;
#line 1662
  parser_state_tos->can_break = (bb_code_ty )22;
#line 1663
  return;
}
}
#line 1669 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/handletoken.c"
static void handle_token_comma(BOOLEAN *force_nl , int *dec_ind , BOOLEAN is_procname_definition ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
#line 1674
  parser_state_tos->want_blank = 1;
#line 1676
  if (parser_state_tos->paren_depth == 0) {
#line 1676
    if (parser_state_tos->in_decl) {
#line 1676
      if (! buf_break_used) {
#line 1676
        if ((int )is_procname_definition == 0) {
#line 1676
          if (! parser_state_tos->block_init) {
            {
#line 1681
            while (1) {
              while_continue: /* CIL Label */ ;
#line 1681
              if (! (e_code - s_code < (long )(*dec_ind - 1))) {
#line 1681
                goto while_break;
              }
              {
#line 1683
              check_code_size();
#line 1684
              set_buf_break((bb_code_ty )5, paren_target);
#line 1685
              tmp = e_code;
#line 1685
              e_code ++;
#line 1685
              *tmp = (char )' ';
              }
            }
            while_break: /* CIL Label */ ;
            }
#line 1688
            parser_state_tos->ind_stmt = 0;
          }
        }
      }
    }
  }
#line 1691
  tmp___0 = e_code;
#line 1691
  e_code ++;
#line 1691
  *tmp___0 = (char )',';
#line 1693
  if (parser_state_tos->p_l_follow == 0) {
#line 1695
    if (parser_state_tos->block_init_level <= 0) {
#line 1697
      parser_state_tos->block_init = 0;
    }
#line 1704
    if (break_comma) {
#line 1704
      if (! settings.leave_comma) {
#line 1706
        *force_nl = (BOOLEAN )1;
      }
    }
  }
#line 1710
  if (parser_state_tos->block_init) {
#line 1712
    parser_state_tos->in_stmt = 0;
  }
#line 1718
  if (settings.break_function_decl_args) {
#line 1718
    if (! parser_state_tos->in_or_st) {
#line 1718
      if (parser_state_tos->in_stmt) {
#line 1718
        if (parser_state_tos->in_decl) {
#line 1722
          *force_nl = (BOOLEAN )1;
        }
      }
    }
  }
#line 1725
  return;
}
}
#line 1732 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/handletoken.c"
static void handle_token_preesc(exit_values_ty *file_exit_value , BOOLEAN *pbreak_line ) 
{ 
  char *t_ptr ;
  char *p ;
  int in_comment ;
  int in_cplus_comment ;
  int com_start ;
  char quote ;
  int com_end ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  parser_state_ty *new ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  int tmp___20 ;
  codes_ty *tos_p_stack ;
  int *tos_il ;
  int *tos_cstk ;
  short *tos_paren_indents ;
  parser_state_ty *second ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  parser_state_ty *second___0 ;
  char *tmp___25 ;
  char *tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;

  {
#line 1739
  if ((unsigned long )s_com != (unsigned long )e_com) {
    {
#line 1741
    dump_line(1, & paren_target, pbreak_line);
    }
  } else
#line 1739
  if ((unsigned long )s_lab != (unsigned long )e_lab) {
    {
#line 1741
    dump_line(1, & paren_target, pbreak_line);
    }
  } else
#line 1739
  if ((unsigned long )s_code != (unsigned long )e_code) {
    {
#line 1741
    dump_line(1, & paren_target, pbreak_line);
    }
  }
#line 1745
  in_comment = 0;
#line 1746
  in_cplus_comment = 0;
#line 1747
  com_start = 0;
#line 1748
  quote = (char)0;
#line 1749
  com_end = 0;
#line 1756
  t_ptr = token;
  {
#line 1756
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1756
    if (! ((unsigned long )t_ptr < (unsigned long )token_end)) {
#line 1756
      goto while_break;
    }
    {
#line 1758
    check_lab_size();
#line 1759
    tmp = e_lab;
#line 1759
    e_lab ++;
#line 1759
    *tmp = *t_ptr;
#line 1756
    t_ptr ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1762
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1762
    if (! had_eof) {
#line 1762
      if (! ((int )*buf_ptr != 10)) {
#line 1762
        if (! in_comment) {
#line 1762
          goto while_break___0;
        }
      }
    } else {
#line 1762
      goto while_break___0;
    }
    {
#line 1764
    check_lab_size();
#line 1765
    tmp___0 = buf_ptr;
#line 1765
    buf_ptr ++;
#line 1765
    *e_lab = *tmp___0;
    }
#line 1767
    if ((unsigned long )buf_ptr >= (unsigned long )buf_end) {
      {
#line 1769
      fill_buffer();
      }
    }
#line 1772
    tmp___1 = e_lab;
#line 1772
    e_lab ++;
    {
#line 1774
    if ((int )*tmp___1 == 92) {
#line 1774
      goto case_92;
    }
#line 1785
    if ((int )*tmp___1 == 47) {
#line 1785
      goto case_47;
    }
#line 1815
    if ((int )*tmp___1 == 39) {
#line 1815
      goto case_39;
    }
#line 1815
    if ((int )*tmp___1 == 34) {
#line 1815
      goto case_39;
    }
#line 1831
    if ((int )*tmp___1 == 42) {
#line 1831
      goto case_42;
    }
#line 1772
    goto switch_break;
    case_92: /* CIL Label */ 
#line 1775
    if (! in_comment) {
#line 1775
      if (! in_cplus_comment) {
#line 1777
        tmp___2 = e_lab;
#line 1777
        e_lab ++;
#line 1777
        tmp___3 = buf_ptr;
#line 1777
        buf_ptr ++;
#line 1777
        *tmp___2 = *tmp___3;
#line 1778
        if ((unsigned long )buf_ptr >= (unsigned long )buf_end) {
          {
#line 1780
          fill_buffer();
          }
        }
      }
    }
#line 1783
    goto switch_break;
    case_47: /* CIL Label */ 
#line 1786
    if ((int )*buf_ptr == 42) {
#line 1786
      goto _L;
    } else
#line 1786
    if ((int )*buf_ptr == 47) {
      _L: /* CIL Label */ 
#line 1786
      if (! in_comment) {
#line 1786
        if (! in_cplus_comment) {
#line 1786
          if (! quote) {
            {
#line 1790
            tmp___4 = current_column();
#line 1790
            save_com.column = tmp___4 - 1;
            }
#line 1792
            if ((int )*buf_ptr == 47) {
#line 1794
              in_cplus_comment = 1;
            } else {
#line 1798
              in_comment = 1;
            }
#line 1801
            tmp___5 = e_lab;
#line 1801
            e_lab ++;
#line 1801
            tmp___6 = buf_ptr;
#line 1801
            buf_ptr ++;
#line 1801
            *tmp___5 = *tmp___6;
#line 1802
            com_start = (int )((e_lab - s_lab) - 2L);
#line 1807
            if ((unsigned long )save_com.ptr == (unsigned long )save_com.end) {
              {
#line 1809
              tmp___7 = current_column();
#line 1809
              save_com.start_column = tmp___7 - 2;
              }
            }
          }
        }
      }
    }
#line 1812
    goto switch_break;
    case_39: /* CIL Label */ 
    case_34: /* CIL Label */ 
#line 1816
    if (! quote) {
#line 1818
      quote = *(e_lab + -1);
    } else
#line 1820
    if ((int )*(e_lab + -1) == (int )quote) {
#line 1822
      quote = (char)0;
    }
#line 1829
    goto switch_break;
    case_42: /* CIL Label */ 
#line 1832
    if ((int )*buf_ptr == 47) {
#line 1832
      if (in_comment) {
#line 1834
        in_comment = 0;
#line 1835
        tmp___8 = e_lab;
#line 1835
        e_lab ++;
#line 1835
        tmp___9 = buf_ptr;
#line 1835
        buf_ptr ++;
#line 1835
        *tmp___8 = *tmp___9;
#line 1836
        com_end = (int )(e_lab - s_lab);
      }
    }
#line 1838
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1842
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1842
    if ((unsigned long )e_lab > (unsigned long )s_lab) {
#line 1842
      if (! ((int )*(e_lab + -1) == 32)) {
#line 1842
        if (! ((int )*(e_lab + -1) == 9)) {
#line 1842
          goto while_break___1;
        }
      }
    } else {
#line 1842
      goto while_break___1;
    }
#line 1844
    e_lab --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1848
  if (in_cplus_comment) {
#line 1850
    in_cplus_comment = 0;
#line 1851
    tmp___10 = e_lab;
#line 1851
    e_lab ++;
#line 1851
    tmp___11 = buf_ptr;
#line 1851
    buf_ptr ++;
#line 1851
    *tmp___10 = *tmp___11;
#line 1852
    com_end = (int )(e_lab - s_lab);
  }
#line 1855
  if (e_lab - s_lab == (long )com_end) {
#line 1855
    if ((unsigned long )bp_save == (unsigned long )((char *)0)) {
#line 1859
      if ((unsigned long )save_com.end != (unsigned long )save_com.ptr) {
        {
#line 1861
        need_chars(& save_com, 2);
#line 1862
        tmp___12 = save_com.end;
#line 1862
        (save_com.end) ++;
#line 1862
        *tmp___12 = (char )'\n';
#line 1864
        tmp___13 = save_com.end;
#line 1864
        (save_com.end) ++;
#line 1864
        *tmp___13 = (char )' ';
#line 1865
        save_com.len += 2;
#line 1866
        line_no --;
        }
      }
      {
#line 1869
      need_chars(& save_com, (com_end - com_start) + 1);
#line 1870
      strncpy((char */* __restrict  */)save_com.end, (char const   */* __restrict  */)(s_lab + com_start),
              (size_t )(com_end - com_start));
#line 1872
      *(save_com.end + (com_end - com_start)) = (char )'\000';
#line 1873
      save_com.end += com_end - com_start;
#line 1874
      save_com.len += com_end - com_start;
#line 1876
      e_lab = s_lab + com_start;
      }
      {
#line 1878
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1878
        if ((unsigned long )e_lab > (unsigned long )s_lab) {
#line 1878
          if (! ((int )*(e_lab + -1) == 32)) {
#line 1878
            if (! ((int )*(e_lab + -1) == 9)) {
#line 1878
              goto while_break___2;
            }
          }
        } else {
#line 1878
          goto while_break___2;
        }
#line 1881
        e_lab --;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 1888
      bp_save = buf_ptr;
#line 1889
      be_save = buf_end;
#line 1890
      buf_ptr = save_com.ptr;
#line 1891
      need_chars(& save_com, 1);
#line 1892
      buf_end = save_com.end;
#line 1893
      save_com.end = save_com.ptr;
      }
    }
  }
  {
#line 1896
  *e_lab = (char )'\000';
#line 1897
  parser_state_tos->pcase = 0;
#line 1900
  p = s_lab + 1;
#line 1902
  p = skip_horiz_space((char const   *)p);
#line 1904
  tmp___30 = strncmp((char const   *)p, "if", (size_t )2);
  }
#line 1904
  if (tmp___30 == 0) {
#line 1906
    if (settings.blanklines_around_conditional_compilation) {
#line 1908
      prefix_blankline_requested ++;
#line 1909
      prefix_blankline_requested_code = (codes_ty )22;
      {
#line 1911
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1911
        tmp___14 = in_prog_pos;
#line 1911
        in_prog_pos ++;
#line 1911
        if (! ((int )*tmp___14 == 10)) {
#line 1911
          goto while_break___3;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 1915
      in_prog_pos --;
    }
    {
#line 1926
    tmp___15 = xmalloc((unsigned int )sizeof(parser_state_ty ));
#line 1926
    new = (parser_state_ty *)tmp___15;
#line 1928
    memcpy((void */* __restrict  */)new, (void const   */* __restrict  */)parser_state_tos,
           sizeof(parser_state_ty ));
#line 1934
    tmp___16 = xmalloc((unsigned int )((unsigned long )parser_state_tos->p_stack_size * sizeof(codes_ty )));
#line 1934
    new->p_stack = (codes_ty *)tmp___16;
#line 1938
    memcpy((void */* __restrict  */)new->p_stack, (void const   */* __restrict  */)parser_state_tos->p_stack,
           (unsigned long )parser_state_tos->p_stack_size * sizeof(codes_ty ));
#line 1942
    tmp___17 = xmalloc((unsigned int )((unsigned long )parser_state_tos->p_stack_size * sizeof(int )));
#line 1942
    new->il = (int *)tmp___17;
#line 1946
    memcpy((void */* __restrict  */)new->il, (void const   */* __restrict  */)parser_state_tos->il,
           (unsigned long )parser_state_tos->p_stack_size * sizeof(int ));
#line 1950
    tmp___18 = xmalloc((unsigned int )((unsigned long )parser_state_tos->p_stack_size * sizeof(int )));
#line 1950
    new->cstk = (int *)tmp___18;
#line 1954
    memcpy((void */* __restrict  */)new->cstk, (void const   */* __restrict  */)parser_state_tos->cstk,
           (unsigned long )parser_state_tos->p_stack_size * sizeof(int ));
#line 1958
    tmp___19 = xmalloc((unsigned int )((unsigned long )parser_state_tos->paren_indents_size * sizeof(short )));
#line 1958
    new->paren_indents = (short *)tmp___19;
#line 1961
    memcpy((void */* __restrict  */)new->paren_indents, (void const   */* __restrict  */)parser_state_tos->paren_indents,
           (unsigned long )parser_state_tos->paren_indents_size * sizeof(short ));
#line 1966
    new->next = parser_state_tos;
#line 1967
    parser_state_tos = new;
    }
  } else {
    {
#line 1971
    tmp___28 = strncmp((char const   *)p, "else", (size_t )4);
    }
#line 1971
    if (tmp___28 == 0) {
#line 1971
      goto _L___0;
    } else {
      {
#line 1971
      tmp___29 = strncmp((char const   *)p, "elif", (size_t )4);
      }
#line 1971
      if (tmp___29 == 0) {
        _L___0: /* CIL Label */ 
        {
#line 1981
        tmp___20 = strncmp((char const   *)p, "else", (size_t )4);
#line 1981
        else_or_endif = tmp___20 == 0;
#line 1982
        prefix_blankline_requested = 0;
        }
#line 1984
        if (parser_state_tos->next) {
          {
#line 1989
          tos_p_stack = parser_state_tos->p_stack;
#line 1990
          tos_il = parser_state_tos->il;
#line 1991
          tos_cstk = parser_state_tos->cstk;
#line 1992
          tos_paren_indents = parser_state_tos->paren_indents;
#line 1994
          second = parser_state_tos->next;
#line 1996
          memcpy((void */* __restrict  */)parser_state_tos, (void const   */* __restrict  */)second,
                 sizeof(parser_state_ty ));
#line 1998
          parser_state_tos->next = second;
#line 2007
          parser_state_tos->p_stack = tos_p_stack;
#line 2008
          memcpy((void */* __restrict  */)parser_state_tos->p_stack, (void const   */* __restrict  */)(parser_state_tos->next)->p_stack,
                 (unsigned long )parser_state_tos->p_stack_size * sizeof(codes_ty ));
#line 2013
          parser_state_tos->il = tos_il;
#line 2014
          memcpy((void */* __restrict  */)parser_state_tos->il, (void const   */* __restrict  */)(parser_state_tos->next)->il,
                 (unsigned long )parser_state_tos->p_stack_size * sizeof(int ));
#line 2019
          parser_state_tos->cstk = tos_cstk;
#line 2020
          memcpy((void */* __restrict  */)parser_state_tos->cstk, (void const   */* __restrict  */)(parser_state_tos->next)->cstk,
                 (unsigned long )parser_state_tos->p_stack_size * sizeof(int ));
#line 2025
          parser_state_tos->paren_indents = tos_paren_indents;
#line 2026
          memcpy((void */* __restrict  */)parser_state_tos->paren_indents, (void const   */* __restrict  */)(parser_state_tos->next)->paren_indents,
                 (unsigned long )parser_state_tos->paren_indents_size * sizeof(short ));
          }
        } else {
#line 2033
          if (else_or_endif) {
            {
#line 2033
            tmp___21 = gettext("Unmatched #else");
#line 2033
            tmp___23 = tmp___21;
            }
          } else {
            {
#line 2033
            tmp___22 = gettext("Unmatched #elif");
#line 2033
            tmp___23 = tmp___22;
            }
          }
          {
#line 2033
          tmp___24 = gettext("Error");
#line 2033
          message(tmp___24, tmp___23, (unsigned int *)0, (unsigned int *)0);
#line 2035
          *file_exit_value = (exit_values_ty )2;
          }
        }
      } else {
        {
#line 2038
        tmp___27 = strncmp((char const   *)p, "endif", (size_t )5);
        }
#line 2038
        if (tmp___27 == 0) {
#line 2040
          else_or_endif = 1;
#line 2041
          prefix_blankline_requested = 0;
#line 2048
          if (parser_state_tos->next) {
            {
#line 2050
            second___0 = parser_state_tos->next;
#line 2052
            parser_state_tos->next = second___0->next;
#line 2053
            free((void *)second___0->p_stack);
#line 2054
            free((void *)second___0->il);
#line 2055
            free((void *)second___0->cstk);
#line 2056
            free((void *)second___0->paren_indents);
#line 2057
            free((void *)second___0);
            }
          } else {
            {
#line 2061
            tmp___25 = gettext("Unmatched #endif");
#line 2061
            tmp___26 = gettext("Error");
#line 2061
            message(tmp___26, tmp___25, (unsigned int *)0, (unsigned int *)0);
#line 2062
            *file_exit_value = (exit_values_ty )2;
            }
          }
#line 2065
          if (settings.blanklines_around_conditional_compilation) {
#line 2067
            postfix_blankline_requested ++;
#line 2068
            postfix_blankline_requested_code = (codes_ty )22;
#line 2069
            n_real_blanklines = 0;
          }
        }
      }
    }
  }
#line 2080
  if (else_or_endif) {
#line 2080
    if ((unsigned int )prefix_blankline_requested_code == 24U) {
#line 2082
      prefix_blankline_requested = 0;
    }
  }
#line 2090
  if ((unsigned int )parser_state_tos->last_token == 18U) {
#line 2090
    if (parser_state_tos->p_l_follow <= 0) {
#line 2090
      if (settings.leave_comma) {
#line 2090
        if (! parser_state_tos->block_init) {
#line 2090
          if (break_comma) {
#line 2090
            if ((unsigned long )s_com == (unsigned long )e_com) {
              {
#line 2096
              dump_line(1, & paren_target, pbreak_line);
#line 2097
              parser_state_tos->want_blank = 0;
              }
            }
          }
        }
      }
    }
  }
#line 2100
  return;
}
}
#line 2107 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/handletoken.c"
static void handle_token_comment(BOOLEAN *force_nl , BOOLEAN *flushed_nl , BOOLEAN *pbreak_line ) 
{ 


  {
#line 2112
  if (parser_state_tos->last_saw_nl) {
#line 2112
    if ((unsigned long )s_code != (unsigned long )e_code) {
      {
#line 2114
      *flushed_nl = (BOOLEAN )0;
#line 2115
      dump_line(1, & paren_target, pbreak_line);
#line 2116
      parser_state_tos->want_blank = 0;
#line 2117
      *force_nl = (BOOLEAN )0;
      }
    }
  }
  {
#line 2119
  print_comment(& paren_target, pbreak_line);
  }
#line 2120
  return;
}
}
#line 2127 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/handletoken.c"
static void handle_token_attribute(void) 
{ 
  char *t_ptr ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 2131
  if ((unsigned long )s_code != (unsigned long )e_code) {
    {
#line 2133
    set_buf_break((bb_code_ty )21, paren_target);
#line 2134
    tmp = e_code;
#line 2134
    e_code ++;
#line 2134
    *tmp = (char )' ';
    }
  }
#line 2137
  t_ptr = token;
  {
#line 2137
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2137
    if (! ((unsigned long )t_ptr < (unsigned long )token_end)) {
#line 2137
      goto while_break;
    }
    {
#line 2139
    check_code_size();
#line 2140
    tmp___0 = e_code;
#line 2140
    e_code ++;
#line 2140
    *tmp___0 = *t_ptr;
#line 2137
    t_ptr ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2143
  parser_state_tos->in_decl = (BOOLEAN )0;
#line 2144
  parser_state_tos->want_blank = 1;
#line 2145
  return;
}
}
#line 2152 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/handletoken.c"
extern void handle_the_token(codes_ty const   type_code , BOOLEAN *scase , BOOLEAN *force_nl ,
                             BOOLEAN *sp_sw , BOOLEAN *flushed_nl , codes_ty *hd_type ,
                             int *dec_ind , BOOLEAN *last_token_ends_sp , exit_values_ty *file_exit_value ,
                             bb_code_ty const   can_break , BOOLEAN *last_else , BOOLEAN is_procname_definition ,
                             BOOLEAN *pbreak_line ) 
{ 


  {
  {
#line 2169
  if ((unsigned int const   )type_code == 23U) {
#line 2169
    goto case_23;
  }
#line 2173
  if ((unsigned int const   )type_code == 1U) {
#line 2173
    goto case_1;
  }
#line 2177
  if ((unsigned int const   )type_code == 2U) {
#line 2177
    goto case_2;
  }
#line 2181
  if ((unsigned int const   )type_code == 3U) {
#line 2181
    goto case_3;
  }
#line 2186
  if ((unsigned int const   )type_code == 5U) {
#line 2186
    goto case_5;
  }
#line 2191
  if ((unsigned int const   )type_code == 6U) {
#line 2191
    goto case_6;
  }
#line 2196
  if ((unsigned int const   )type_code == 7U) {
#line 2196
    goto case_7;
  }
#line 2201
  if ((unsigned int const   )type_code == 8U) {
#line 2201
    goto case_8;
  }
#line 2206
  if ((unsigned int const   )type_code == 9U) {
#line 2206
    goto case_9;
  }
#line 2213
  if ((unsigned int const   )type_code == 10U) {
#line 2213
    goto case_10;
  }
#line 2219
  if ((unsigned int const   )type_code == 11U) {
#line 2219
    goto case_11;
  }
#line 2224
  if ((unsigned int const   )type_code == 12U) {
#line 2224
    goto case_12;
  }
#line 2230
  if ((unsigned int const   )type_code == 13U) {
#line 2230
    goto case_13;
  }
#line 2236
  if ((unsigned int const   )type_code == 14U) {
#line 2236
    goto case_14;
  }
#line 2243
  if ((unsigned int const   )type_code == 21U) {
#line 2243
    goto case_21;
  }
#line 2249
  if ((unsigned int const   )type_code == 25U) {
#line 2249
    goto case_25;
  }
#line 2257
  if ((unsigned int const   )type_code == 26U) {
#line 2257
    goto case_26;
  }
#line 2257
  if ((unsigned int const   )type_code == 27U) {
#line 2257
    goto case_26;
  }
#line 2264
  if ((unsigned int const   )type_code == 16U) {
#line 2264
    goto case_16;
  }
#line 2275
  if ((unsigned int const   )type_code == 24U) {
#line 2275
    goto case_24;
  }
#line 2286
  if ((unsigned int const   )type_code == 15U) {
#line 2286
    goto case_15;
  }
#line 2286
  if ((unsigned int const   )type_code == 17U) {
#line 2286
    goto case_15;
  }
#line 2297
  if ((unsigned int const   )type_code == 40U) {
#line 2297
    goto case_40;
  }
#line 2301
  if ((unsigned int const   )type_code == 18U) {
#line 2301
    goto case_18;
  }
#line 2306
  if ((unsigned int const   )type_code == 22U) {
#line 2306
    goto case_22;
  }
#line 2313
  if ((unsigned int const   )type_code == 20U) {
#line 2313
    goto case_20;
  }
#line 2313
  if ((unsigned int const   )type_code == 19U) {
#line 2313
    goto case_20;
  }
#line 2320
  if ((unsigned int const   )type_code == 41U) {
#line 2320
    goto case_41;
  }
#line 2324
  goto switch_default;
  case_23: /* CIL Label */ 
  {
#line 2170
  handle_token_form_feed(pbreak_line);
  }
#line 2171
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 2174
  handle_token_newline(force_nl, pbreak_line);
  }
#line 2175
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 2178
  handle_token_lparen(force_nl, sp_sw, dec_ind, pbreak_line);
  }
#line 2179
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 2182
  handle_token_rparen(force_nl, sp_sw, hd_type, last_token_ends_sp, file_exit_value,
                      pbreak_line);
  }
#line 2184
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 2188
  handle_token_unary_op(dec_ind, can_break);
  }
#line 2189
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 2193
  handle_token_binary_op(can_break);
  }
#line 2194
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 2198
  handle_token_postop();
  }
#line 2199
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 2203
  handle_token_question(can_break);
  }
#line 2204
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 2208
  handle_token_casestmt(scase, file_exit_value);
#line 2209
  copy_id(type_code, force_nl, file_exit_value, can_break);
  }
#line 2211
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 2215
  handle_token_colon(scase, force_nl, dec_ind, can_break, pbreak_line);
  }
#line 2217
  goto switch_break;
  case_11: /* CIL Label */ 
  {
#line 2221
  handle_token_doublecolon();
  }
#line 2222
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 2226
  handle_token_semicolon(scase, force_nl, sp_sw, dec_ind, last_token_ends_sp, file_exit_value);
  }
#line 2228
  goto switch_break;
  case_13: /* CIL Label */ 
  {
#line 2232
  handle_token_lbrace(force_nl, dec_ind, file_exit_value, pbreak_line);
  }
#line 2234
  goto switch_break;
  case_14: /* CIL Label */ 
  {
#line 2238
  handle_token_rbrace(force_nl, dec_ind, file_exit_value, pbreak_line);
  }
#line 2241
  goto switch_break;
  case_21: /* CIL Label */ 
  {
#line 2245
  handle_token_swstmt(sp_sw, hd_type);
#line 2246
  copy_id(type_code, force_nl, file_exit_value, can_break);
  }
#line 2247
  goto switch_break;
  case_25: /* CIL Label */ 
  {
#line 2251
  handle_token_sp_paren(sp_sw, hd_type);
#line 2252
  copy_id(type_code, force_nl, file_exit_value, can_break);
  }
#line 2253
  goto switch_break;
  case_26: /* CIL Label */ 
  case_27: /* CIL Label */ 
  {
#line 2259
  handle_token_nparen(force_nl, file_exit_value, last_else, pbreak_line);
#line 2261
  copy_id(type_code, force_nl, file_exit_value, can_break);
  }
#line 2262
  goto switch_break;
  case_16: /* CIL Label */ 
  {
#line 2272
  handle_token_overloaded(can_break);
  }
#line 2273
  goto switch_break;
  case_24: /* CIL Label */ 
  {
#line 2278
  handle_token_decl(dec_ind, file_exit_value, pbreak_line);
#line 2281
  copy_id(type_code, force_nl, file_exit_value, can_break);
  }
#line 2282
  goto switch_break;
  case_15: /* CIL Label */ 
  case_17: /* CIL Label */ 
  {
#line 2288
  handle_token_ident(force_nl, sp_sw, hd_type, dec_ind, file_exit_value, can_break,
                     is_procname_definition, pbreak_line);
#line 2293
  copy_id(type_code, force_nl, file_exit_value, can_break);
  }
#line 2295
  goto switch_break;
  case_40: /* CIL Label */ 
  {
#line 2298
  handle_token_struct_delim();
  }
#line 2299
  goto switch_break;
  case_18: /* CIL Label */ 
  {
#line 2302
  handle_token_comma(force_nl, dec_ind, is_procname_definition);
  }
#line 2304
  goto switch_break;
  case_22: /* CIL Label */ 
  {
#line 2308
  handle_token_preesc(file_exit_value, pbreak_line);
  }
#line 2310
  goto switch_break;
  case_20: /* CIL Label */ 
  case_19: /* CIL Label */ 
  {
#line 2315
  handle_token_comment(force_nl, flushed_nl, pbreak_line);
  }
#line 2317
  goto switch_break;
  case_41: /* CIL Label */ 
  {
#line 2321
  handle_token_attribute();
  }
#line 2322
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 2325
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 2327
  return;
}
}
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 129 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
static int exp_T  =    0;
#line 130 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
static int exp_bacc  =    0;
#line 131 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
static int exp_badp  =    0;
#line 132 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
static int exp_bad  =    0;
#line 133 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
static int exp_bap  =    0;
#line 134 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
static int exp_bbb  =    0;
#line 135 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
static int exp_bbo  =    0;
#line 136 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
static int exp_bc  =    0;
#line 137 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
static int exp_bl  =    0;
#line 138 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
static int exp_blf  =    0;
#line 139 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
static int exp_bli  =    0;
#line 140 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
static int exp_bls  =    0;
#line 141 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
static int exp_bs  =    0;
#line 142 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
static int exp_c  =    0;
#line 143 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
static int exp_cbi  =    0;
#line 144 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
static int exp_cdb  =    0;
#line 145 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
static int exp_cd  =    0;
#line 146 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
static int exp_cdw  =    0;
#line 147 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
static int exp_ce  =    0;
#line 148 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
static int exp_ci  =    0;
#line 149 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
static int exp_cli  =    0;
#line 150 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
static int exp_cp  =    0;
#line 151 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
static int exp_cpp  =    0;
#line 152 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
static int exp_cs  =    0;
#line 153 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
static int exp_d  =    0;
#line 154 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
static int exp_bfda  =    0;
#line 155 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
static int exp_bfde  =    0;
#line 156 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
static int exp_di  =    0;
#line 157 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
static int exp_dj  =    0;
#line 158 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
static int exp_eei  =    0;
#line 159 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
static int exp_fc1  =    0;
#line 160 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
static int exp_fca  =    0;
#line 161 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
static int exp_gnu  =    0;
#line 162 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
static int exp_hnl  =    0;
#line 163 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
static int exp_i  =    0;
#line 164 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
static int exp_il  =    0;
#line 165 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
static int exp_ip  =    0;
#line 166 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
static int exp_kr  =    0;
#line 167 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
static int exp_l  =    0;
#line 168 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
static int exp_lc  =    0;
#line 169 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
static int exp_linux  =    0;
#line 170 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
static int exp_lp  =    0;
#line 171 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
static int exp_lps  =    0;
#line 172 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
static int exp_nip  =    0;
#line 173 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
static int exp_o  =    0;
#line 174 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
static int exp_orig  =    0;
#line 175 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
static int exp_pcs  =    0;
#line 176 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
static int exp_pi  =    0;
#line 177 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
static int exp_pmt  =    0;
#line 178 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
static int exp_pro  =    0;
#line 179 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
static int exp_prs  =    0;
#line 180 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
static int exp_psl  =    0;
#line 181 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
static int exp_ppi  =    0;
#line 182 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
static int exp_sai  =    0;
#line 183 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
static int exp_saf  =    0;
#line 184 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
static int exp_saw  =    0;
#line 185 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
static int exp_sbi  =    0;
#line 186 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
static int exp_sc  =    0;
#line 187 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
static int exp_sob  =    0;
#line 188 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
static int exp_ss  =    0;
#line 189 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
static int exp_st  =    0;
#line 190 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
static int exp_ts  =    0;
#line 191 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
static int exp_ut  =    0;
#line 192 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
static int exp_v  =    0;
#line 193 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
static int exp_version  =    0;
#line 200 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
user_options_ty settings  = 
#line 200
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0};
#line 238
static void usage(void) ;
#line 363 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
pro_ty const   pro[103]  = 
#line 363
  {      {(char *)"version", (profile_ty )5, 0, (on_or_off_ty )0, (int *)"2.2.11", & exp_version}, 
        {(char *)"v",
      (profile_ty )0, 0, (on_or_off_ty )2, & settings.verbose, & exp_v}, 
        {(char *)"ut", (profile_ty )0, 1, (on_or_off_ty )2, & settings.use_tabs, & exp_ut}, 
        {(char *)"ts",
      (profile_ty )1, 8, (on_or_off_ty )0, & settings.tabsize, & exp_ts}, 
        {(char *)"st", (profile_ty )0, 0, (on_or_off_ty )2, & settings.use_stdout, & exp_st}, 
        {(char *)"ss",
      (profile_ty )0, 0, (on_or_off_ty )2, & settings.space_sp_semicolon, & exp_ss}, 
        {(char *)"sob",
      (profile_ty )0, 0, (on_or_off_ty )2, & settings.swallow_optional_blanklines,
      & exp_sob}, 
        {(char *)"sc", (profile_ty )0, 0, (on_or_off_ty )2, & settings.star_comment_cont,
      & exp_sc}, 
        {(char *)"sbi", (profile_ty )1, 0, (on_or_off_ty )0, & settings.struct_brace_indent,
      & exp_sbi}, 
        {(char *)"saw", (profile_ty )0, 1, (on_or_off_ty )2, & settings.space_after_while,
      & exp_saw}, 
        {(char *)"sai", (profile_ty )0, 1, (on_or_off_ty )2, & settings.space_after_if,
      & exp_sai}, 
        {(char *)"saf", (profile_ty )0, 1, (on_or_off_ty )2, & settings.space_after_for,
      & exp_saf}, 
        {(char *)"psl", (profile_ty )0, 1, (on_or_off_ty )2, & settings.procnames_start_line,
      & exp_psl}, 
        {(char *)"prs", (profile_ty )0, 0, (on_or_off_ty )2, & settings.parentheses_space,
      & exp_prs}, 
        {(char *)"pmt", (profile_ty )0, 0, (on_or_off_ty )2, & settings.preserve_mtime,
      & exp_pmt}, 
        {(char *)"pi", (profile_ty )1, -1, (on_or_off_ty )0, & settings.paren_indent,
      & exp_pi}, 
        {(char *)"pcs", (profile_ty )0, 1, (on_or_off_ty )2, & settings.proc_calls_space,
      & exp_pcs}, 
        {(char *)"orig", (profile_ty )4, 0, (on_or_off_ty )0, (int *)"-nbap\000-nbad\000-bbo\000-hnl\000-bc\000-br\000-brs\000-c33\000-cd33\000-cdb\000-ce\000-ci4\000-cli0\000-cp33\000-di16\000-fc1\000-fca\000-i4\000-l75\000-lp\000-npcs\000-nprs\000-psl\000-sc\000-sai\000-saf\000-saw\000-nsob\000-nss\000-ts8\000",
      & exp_orig}, 
        {(char *)"o", (profile_ty )0, 0, (on_or_off_ty )2, & settings.expect_output_file,
      & exp_o}, 
        {(char *)"nv", (profile_ty )0, 0, (on_or_off_ty )1, & settings.verbose, & exp_v}, 
        {(char *)"nut",
      (profile_ty )0, 1, (on_or_off_ty )1, & settings.use_tabs, & exp_ut}, 
        {(char *)"nss", (profile_ty )0, 0, (on_or_off_ty )1, & settings.space_sp_semicolon,
      & exp_ss}, 
        {(char *)"nsob", (profile_ty )0, 0, (on_or_off_ty )1, & settings.swallow_optional_blanklines,
      & exp_sob}, 
        {(char *)"nsc", (profile_ty )0, 0, (on_or_off_ty )1, & settings.star_comment_cont,
      & exp_sc}, 
        {(char *)"nsaw", (profile_ty )0, 1, (on_or_off_ty )1, & settings.space_after_while,
      & exp_saw}, 
        {(char *)"nsai", (profile_ty )0, 1, (on_or_off_ty )1, & settings.space_after_if,
      & exp_sai}, 
        {(char *)"nsaf", (profile_ty )0, 1, (on_or_off_ty )1, & settings.space_after_for,
      & exp_saf}, 
        {(char *)"npsl", (profile_ty )0, 1, (on_or_off_ty )1, & settings.procnames_start_line,
      & exp_psl}, 
        {(char *)"nprs", (profile_ty )0, 0, (on_or_off_ty )1, & settings.parentheses_space,
      & exp_prs}, 
        {(char *)"npro", (profile_ty )2, 0, (on_or_off_ty )0, (int *)0, & exp_pro}, 
        {(char *)"npmt", (profile_ty )0, 0, (on_or_off_ty )1, & settings.preserve_mtime,
      & exp_pmt}, 
        {(char *)"npcs", (profile_ty )0, 1, (on_or_off_ty )1, & settings.proc_calls_space,
      & exp_pcs}, 
        {(char *)"nlps", (profile_ty )0, 0, (on_or_off_ty )1, & settings.leave_preproc_space,
      & exp_lps}, 
        {(char *)"nlp", (profile_ty )0, 1, (on_or_off_ty )1, & settings.lineup_to_parens,
      & exp_lp}, 
        {(char *)"nip", (profile_ty )4, 0, (on_or_off_ty )0, (int *)"-ip0\000", & exp_nip}, 
        {(char *)"nhnl",
      (profile_ty )0, 1, (on_or_off_ty )1, & settings.honour_newlines, & exp_hnl}, 
        {(char *)"nfca",
      (profile_ty )0, 0, (on_or_off_ty )1, & settings.format_comments, & exp_fca}, 
        {(char *)"nfc1",
      (profile_ty )0, 0, (on_or_off_ty )1, & settings.format_col1_comments, & exp_fc1}, 
        {(char *)"neei",
      (profile_ty )0, 0, (on_or_off_ty )1, & settings.extra_expression_indent, & exp_eei}, 
        {(char *)"ndj",
      (profile_ty )0, 0, (on_or_off_ty )1, & settings.ljust_decl, & exp_dj}, 
        {(char *)"ncs", (profile_ty )0, 1, (on_or_off_ty )1, & settings.cast_space, & exp_cs}, 
        {(char *)"nce",
      (profile_ty )0, 0, (on_or_off_ty )1, & settings.cuddle_else, & exp_ce}, 
        {(char *)"ncdw", (profile_ty )0, 0, (on_or_off_ty )1, & settings.cuddle_do_while,
      & exp_cdw}, 
        {(char *)"ncdb", (profile_ty )0, 0, (on_or_off_ty )1, & settings.comment_delimiter_on_blankline,
      & exp_cdb}, 
        {(char *)"nbs", (profile_ty )0, 0, (on_or_off_ty )1, & settings.blank_after_sizeof,
      & exp_bs}, 
        {(char *)"nbfda", (profile_ty )0, 0, (on_or_off_ty )1, & settings.break_function_decl_args,
      & exp_bfda}, 
        {(char *)"nbfde", (profile_ty )0, 0, (on_or_off_ty )1, & settings.break_function_decl_args_end,
      & exp_bfde}, 
        {(char *)"nbc", (profile_ty )0, 1, (on_or_off_ty )2, & settings.leave_comma,
      & exp_bc}, 
        {(char *)"nbbo", (profile_ty )0, 1, (on_or_off_ty )1, & settings.break_before_boolean_operator,
      & exp_bbo}, 
        {(char *)"nbbb", (profile_ty )0, 0, (on_or_off_ty )1, & settings.blanklines_before_blockcomments,
      & exp_bbb}, 
        {(char *)"nbap", (profile_ty )0, 1, (on_or_off_ty )1, & settings.blanklines_after_procs,
      & exp_bap}, 
        {(char *)"nbadp", (profile_ty )0, 0, (on_or_off_ty )1, & settings.blanklines_after_declarations_at_proctop,
      & exp_badp}, 
        {(char *)"nbad", (profile_ty )0, 0, (on_or_off_ty )1, & settings.blanklines_after_declarations,
      & exp_bad}, 
        {(char *)"nbacc", (profile_ty )0, 0, (on_or_off_ty )1, & settings.blanklines_around_conditional_compilation,
      & exp_bacc}, 
        {(char *)"linux", (profile_ty )4, 0, (on_or_off_ty )0, (int *)"-nbad\000-bap\000-nbc\000-bbo\000-hnl\000-br\000-brs\000-c33\000-cd33\000-ncdb\000-ce\000-ci4\000-cli0\000-d0\000-di1\000-nfc1\000-i8\000-ip0\000-l80\000-lp\000-npcs\000-nprs\000-npsl\000-sai\000-saf\000-saw\000-ncs\000-nsc\000-sob\000-nfca\000-cp33\000-ss\000-ts8\000-il1\000",
      & exp_linux}, 
        {(char *)"lps", (profile_ty )0, 0, (on_or_off_ty )2, & settings.leave_preproc_space,
      & exp_lps}, 
        {(char *)"lp", (profile_ty )0, 1, (on_or_off_ty )2, & settings.lineup_to_parens,
      & exp_lp}, 
        {(char *)"lc", (profile_ty )1, 78, (on_or_off_ty )0, & settings.comment_max_col,
      & exp_lc}, 
        {(char *)"l", (profile_ty )1, 78, (on_or_off_ty )0, & settings.max_col, & exp_l}, 
        {(char *)"kr",
      (profile_ty )4, 0, (on_or_off_ty )0, (int *)"-nbad\000-bap\000-nbc\000-bbo\000-hnl\000-br\000-brs\000-c33\000-cd33\000-ncdb\000-ce\000-ci4\000-cli0\000-d0\000-di1\000-nfc1\000-i4\000-ip0\000-l75\000-lp\000-npcs\000-nprs\000-npsl\000-sai\000-saf\000-saw\000-cs\000-nsc\000-nsob\000-nfca\000-cp33\000-nss\000",
      & exp_kr}, 
        {(char *)"il", (profile_ty )1, -2, (on_or_off_ty )0, & settings.label_offset,
      & exp_il}, 
        {(char *)"ip", (profile_ty )1, 5, (on_or_off_ty )0, & settings.indent_parameters,
      & exp_ip}, 
        {(char *)"i", (profile_ty )1, 2, (on_or_off_ty )0, & settings.ind_size, & exp_i}, 
        {(char *)"hnl",
      (profile_ty )0, 1, (on_or_off_ty )2, & settings.honour_newlines, & exp_hnl}, 
        {(char *)"h",
      (profile_ty )6, 0, (on_or_off_ty )0, (int *)(& usage), & exp_version}, 
        {(char *)"gnu", (profile_ty )4, 0, (on_or_off_ty )0, (int *)"-nbad\000-bap\000-bbo\000-hnl\000-nbc\000-bl\000-bls\000-ncdb\000-cs\000-nce\000-di2\000-ndj\000-nfc1\000-i2\000-ip5\000-lp\000-pcs\000-nprs\000-psl\000-nsc\000-sai\000-saf\000-saw\000-nsob\000-bli2\000-cp1\000-nfca\000",
      & exp_gnu}, 
        {(char *)"fca", (profile_ty )0, 0, (on_or_off_ty )2, & settings.format_comments,
      & exp_fca}, 
        {(char *)"fc1", (profile_ty )0, 0, (on_or_off_ty )2, & settings.format_col1_comments,
      & exp_fc1}, 
        {(char *)"eei", (profile_ty )0, 0, (on_or_off_ty )2, & settings.extra_expression_indent,
      & exp_eei}, 
        {(char *)"dj", (profile_ty )0, 0, (on_or_off_ty )2, & settings.ljust_decl, & exp_dj}, 
        {(char *)"di",
      (profile_ty )1, 2, (on_or_off_ty )0, & settings.decl_indent, & exp_di}, 
        {(char *)"d", (profile_ty )1, 0, (on_or_off_ty )0, & settings.unindent_displace,
      & exp_d}, 
        {(char *)"cs", (profile_ty )0, 1, (on_or_off_ty )2, & settings.cast_space, & exp_cs}, 
        {(char *)"cp",
      (profile_ty )1, 1, (on_or_off_ty )0, & settings.else_endif_col, & exp_cp}, 
        {(char *)"cli", (profile_ty )1, 0, (on_or_off_ty )0, & settings.case_indent,
      & exp_cli}, 
        {(char *)"ci", (profile_ty )1, 0, (on_or_off_ty )0, & settings.continuation_indent,
      & exp_ci}, 
        {(char *)"ce", (profile_ty )0, 0, (on_or_off_ty )2, & settings.cuddle_else, & exp_ce}, 
        {(char *)"cdw",
      (profile_ty )0, 0, (on_or_off_ty )2, & settings.cuddle_do_while, & exp_cdw}, 
        {(char *)"cdb",
      (profile_ty )0, 0, (on_or_off_ty )2, & settings.comment_delimiter_on_blankline,
      & exp_cdb}, 
        {(char *)"cd", (profile_ty )1, 33, (on_or_off_ty )0, & settings.decl_com_ind,
      & exp_cd}, 
        {(char *)"cbi", (profile_ty )1, -1, (on_or_off_ty )0, & settings.case_brace_indent,
      & exp_cbi}, 
        {(char *)"c++", (profile_ty )0, 0, (on_or_off_ty )2, & settings.c_plus_plus,
      & exp_cpp}, 
        {(char *)"c", (profile_ty )1, 33, (on_or_off_ty )0, & settings.com_ind, & exp_c}, 
        {(char *)"bs",
      (profile_ty )0, 0, (on_or_off_ty )2, & settings.blank_after_sizeof, & exp_bs}, 
        {(char *)"brs",
      (profile_ty )0, 0, (on_or_off_ty )2, & settings.braces_on_struct_decl_line,
      & exp_bls}, 
        {(char *)"bls", (profile_ty )0, 0, (on_or_off_ty )1, & settings.braces_on_struct_decl_line,
      & exp_bls}, 
        {(char *)"brf", (profile_ty )0, 0, (on_or_off_ty )2, & settings.braces_on_func_def_line,
      & exp_blf}, 
        {(char *)"blf", (profile_ty )0, 0, (on_or_off_ty )1, & settings.braces_on_func_def_line,
      & exp_blf}, 
        {(char *)"bli", (profile_ty )1, 2, (on_or_off_ty )0, & settings.brace_indent,
      & exp_bli}, 
        {(char *)"br", (profile_ty )0, 0, (on_or_off_ty )2, & settings.btype_2, & exp_bl}, 
        {(char *)"bl",
      (profile_ty )0, 0, (on_or_off_ty )1, & settings.btype_2, & exp_bl}, 
        {(char *)"bfda", (profile_ty )0, 0, (on_or_off_ty )2, & settings.break_function_decl_args,
      & exp_bfda}, 
        {(char *)"bfde", (profile_ty )0, 0, (on_or_off_ty )2, & settings.break_function_decl_args_end,
      & exp_bfde}, 
        {(char *)"bc", (profile_ty )0, 1, (on_or_off_ty )1, & settings.leave_comma, & exp_bc}, 
        {(char *)"bbo",
      (profile_ty )0, 1, (on_or_off_ty )2, & settings.break_before_boolean_operator,
      & exp_bbo}, 
        {(char *)"bbb", (profile_ty )0, 0, (on_or_off_ty )2, & settings.blanklines_before_blockcomments,
      & exp_bbb}, 
        {(char *)"bap", (profile_ty )0, 1, (on_or_off_ty )2, & settings.blanklines_after_procs,
      & exp_bap}, 
        {(char *)"badp", (profile_ty )0, 0, (on_or_off_ty )2, & settings.blanklines_after_declarations_at_proctop,
      & exp_badp}, 
        {(char *)"bad", (profile_ty )0, 0, (on_or_off_ty )2, & settings.blanklines_after_declarations,
      & exp_bad}, 
        {(char *)"bacc", (profile_ty )0, 0, (on_or_off_ty )2, & settings.blanklines_around_conditional_compilation,
      & exp_bacc}, 
        {(char *)"T", (profile_ty )3, 0, (on_or_off_ty )0, (int *)0, & exp_T}, 
        {(char *)"ppi", (profile_ty )1, 0, (on_or_off_ty )0, & settings.force_preproc_width,
      & exp_ppi}, 
        {(char *)0, (profile_ty )2, 0, (on_or_off_ty )0, (int *)0, (int *)0}};
#line 484 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
long_option_conversion_ty const   option_conversions[114]  = 
#line 484
  {      {(char *)"version", (char *)"version"}, 
        {(char *)"verbose", (char *)"v"}, 
        {(char *)"usage", (char *)"h"}, 
        {(char *)"use-tabs", (char *)"ut"}, 
        {(char *)"tab-size", (char *)"ts"}, 
        {(char *)"swallow-optional-blank-lines", (char *)"sob"}, 
        {(char *)"struct-brace-indentation", (char *)"sbi"}, 
        {(char *)"start-left-side-of-comments", (char *)"sc"}, 
        {(char *)"standard-output", (char *)"st"}, 
        {(char *)"space-special-semicolon", (char *)"ss"}, 
        {(char *)"space-after-while", (char *)"saw"}, 
        {(char *)"space-after-procedure-calls", (char *)"pcs"}, 
        {(char *)"space-after-parentheses", (char *)"prs"}, 
        {(char *)"space-after-if", (char *)"sai"}, 
        {(char *)"space-after-for", (char *)"saf"}, 
        {(char *)"space-after-cast", (char *)"cs"}, 
        {(char *)"remove-preprocessor-space", (char *)"nlps"}, 
        {(char *)"procnames-start-lines", (char *)"psl"}, 
        {(char *)"preserve-mtime", (char *)"pmt"}, 
        {(char *)"paren-indentation", (char *)"pi"}, 
        {(char *)"parameter-indentation", (char *)"ip"}, 
        {(char *)"output-file", (char *)"o"}, 
        {(char *)"output", (char *)"o"}, 
        {(char *)"original-style", (char *)"orig"}, 
        {(char *)"original", (char *)"orig"}, 
        {(char *)"no-verbosity", (char *)"nv"}, 
        {(char *)"no-tabs", (char *)"nut"}, 
        {(char *)"no-space-after-while", (char *)"nsaw"}, 
        {(char *)"no-space-after-parentheses", (char *)"nprs"}, 
        {(char *)"no-space-after-if", (char *)"nsai"}, 
        {(char *)"no-space-after-function-call-names", (char *)"npcs"}, 
        {(char *)"no-space-after-for", (char *)"nsaf"}, 
        {(char *)"no-space-after-cast", (char *)"ncs"}, 
        {(char *)"no-space-after-casts", (char *)"ncs"}, 
        {(char *)"no-parameter-indentation", (char *)"nip"}, 
        {(char *)"no-extra-expression-indentation", (char *)"neei"}, 
        {(char *)"no-comment-delimiters-on-blank-lines", (char *)"ncdb"}, 
        {(char *)"no-blank-lines-before-block-comments", (char *)"nbbb"}, 
        {(char *)"no-blank-lines-after-procedures", (char *)"nbap"}, 
        {(char *)"no-blank-lines-after-procedure-declarations", (char *)"nbadp"}, 
        {(char *)"no-blank-lines-after-ifdefs", (char *)"nbacc"}, 
        {(char *)"no-blank-lines-after-declarations", (char *)"nbad"}, 
        {(char *)"no-blank-lines-after-commas", (char *)"nbc"}, 
        {(char *)"no-blank-before-sizeof", (char *)"nbs"}, 
        {(char *)"no-Bill-Shannon", (char *)"nbs"}, 
        {(char *)"label-offset", (char *)"il"}, 
        {(char *)"line-length", (char *)"l"}, 
        {(char *)"line-comments-indentation", (char *)"d"}, 
        {(char *)"linux-style", (char *)"linux"}, 
        {(char *)"left-justify-declarations", (char *)"dj"}, 
        {(char *)"leave-preprocessor-space", (char *)"lps"}, 
        {(char *)"leave-optional-blank-lines", (char *)"nsob"}, 
        {(char *)"kernighan-and-ritchie-style", (char *)"kr"}, 
        {(char *)"kernighan-and-ritchie", (char *)"kr"}, 
        {(char *)"k-and-r-style", (char *)"kr"}, 
        {(char *)"indent-label", (char *)"il"}, 
        {(char *)"indentation-level", (char *)"i"}, 
        {(char *)"indent-level", (char *)"i"}, 
        {(char *)"ignore-profile", (char *)"npro"}, 
        {(char *)"ignore-newlines", (char *)"nhnl"}, 
        {(char *)"honour-newlines", (char *)"hnl"}, 
        {(char *)"help", (char *)"h"}, 
        {(char *)"gnu-style", (char *)"gnu"}, 
        {(char *)"format-first-column-comments", (char *)"fc1"}, 
        {(char *)"format-all-comments", (char *)"fca"}, 
        {(char *)"extra-expression-indentation", (char *)"eei"}, 
        {(char *)"else-endif-column", (char *)"cp"}, 
        {(char *)"dont-star-comments", (char *)"nsc"}, 
        {(char *)"dont-space-special-semicolon", (char *)"nss"}, 
        {(char *)"dont-line-up-parentheses", (char *)"nlp"}, 
        {(char *)"dont-left-justify-declarations", (char *)"ndj"}, 
        {(char *)"dont-indent-parameters", (char *)"nip"}, 
        {(char *)"dont-format-first-column-comments", (char *)"nfc1"}, 
        {(char *)"dont-format-comments", (char *)"nfca"}, 
        {(char *)"dont-cuddle-else", (char *)"nce"}, 
        {(char *)"dont-cuddle-do-while", (char *)"ncdw"}, 
        {(char *)"dont-break-procedure-type", (char *)"npsl"}, 
        {(char *)"dont-break-function-decl-args", (char *)"nbfda"}, 
        {(char *)"dont-break-function-decl-args-end", (char *)"nbfde"}, 
        {(char *)"declaration-indentation", (char *)"di"}, 
        {(char *)"declaration-comment-column", (char *)"cd"}, 
        {(char *)"cuddle-else", (char *)"ce"}, 
        {(char *)"cuddle-do-while", (char *)"cdw"}, 
        {(char *)"continue-at-parentheses", (char *)"lp"}, 
        {(char *)"continuation-indentation", (char *)"ci"}, 
        {(char *)"comment-line-length", (char *)"lc"}, 
        {(char *)"comment-indentation", (char *)"c"}, 
        {(char *)"comment-delimiters-on-blank-lines", (char *)"cdb"}, 
        {(char *)"case-indentation", (char *)"cli"}, 
        {(char *)"case-brace-indentation", (char *)"cbi"}, 
        {(char *)"c-plus-plus", (char *)"c++"}, 
        {(char *)"break-function-decl-args", (char *)"bfda"}, 
        {(char *)"break-function-decl-args-end", (char *)"bfde"}, 
        {(char *)"break-before-boolean-operator", (char *)"bbo"}, 
        {(char *)"break-after-boolean-operator", (char *)"nbbo"}, 
        {(char *)"braces-on-struct-decl-line", (char *)"brs"}, 
        {(char *)"braces-on-func-def-line", (char *)"brf"}, 
        {(char *)"braces-on-if-line", (char *)"br"}, 
        {(char *)"braces-after-struct-decl-line", (char *)"bls"}, 
        {(char *)"braces-after-func-def-line", (char *)"blf"}, 
        {(char *)"braces-after-if-line", (char *)"bl"}, 
        {(char *)"brace-indent", (char *)"bli"}, 
        {(char *)"blank-lines-before-block-comments", (char *)"bbb"}, 
        {(char *)"blank-lines-after-procedures", (char *)"bap"}, 
        {(char *)"blank-lines-after-procedure-declarations", (char *)"badp"}, 
        {(char *)"blank-lines-after-ifdefs", (char *)"bacc"}, 
        {(char *)"blank-lines-after-declarations", (char *)"bad"}, 
        {(char *)"blank-lines-after-commas", (char *)"bc"}, 
        {(char *)"blank-before-sizeof", (char *)"bs"}, 
        {(char *)"berkeley-style", (char *)"orig"}, 
        {(char *)"berkeley", (char *)"orig"}, 
        {(char *)"Bill-Shannon", (char *)"bs"}, 
        {(char *)"preprocessor-indentation", (char *)"ppi"}, 
        {(char *)0, (char *)0}};
#line 609 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
static void usage(void) 
{ 
  char *tmp ;

  {
  {
#line 611
  tmp = gettext("usage: indent file [-o outfile ] [ options ]\n       indent file1 file2 ... fileN [ options ]\n");
#line 611
  DieError(1, (char const   *)tmp);
  }
#line 612
  return;
}
}
#line 620 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
static BOOLEAN eqin(char const   *s1 , char const   *s2 , char const   **start_param ) 
{ 
  BOOLEAN ret ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 625
  ret = (BOOLEAN )1;
  {
#line 627
  while (1) {
    while_continue: /* CIL Label */ ;
#line 627
    if (! *s1) {
#line 627
      goto while_break;
    }
#line 629
    tmp = s1;
#line 629
    s1 ++;
#line 629
    tmp___0 = s2;
#line 629
    s2 ++;
#line 629
    if ((int const   )*tmp != (int const   )*tmp___0) {
#line 631
      ret = (BOOLEAN )0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 635
  *start_param = s2;
#line 636
  return (ret);
}
}
#line 643 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
void set_defaults(void) 
{ 
  pro_ty const   *p ;

  {
#line 647
  p = pro;
  {
#line 647
  while (1) {
    while_continue: /* CIL Label */ ;
#line 647
    if (! p->p_name) {
#line 647
      goto while_break;
    }
#line 649
    if ((unsigned int const   )p->p_type == 0U) {
#line 649
      if ((unsigned int const   )p->p_special == 2U) {
#line 652
        *(p->p_obj) = (int )p->p_default;
      } else {
#line 649
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 649
    if ((unsigned int const   )p->p_type == 1U) {
#line 652
      *(p->p_obj) = (int )p->p_default;
    }
#line 647
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 655
  return;
}
}
#line 661 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
void set_defaults_after(void) 
{ 


  {
#line 663
  if (! exp_lc) {
#line 665
    settings.comment_max_col = settings.max_col;
  }
#line 667
  return;
}
}
#line 673 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
static void arg_missing(char const   *option , char const   *option_source ) 
{ 
  char *tmp ;

  {
  {
#line 677
  tmp = gettext("%s: missing argument to parameter %s\n");
#line 677
  DieError(1, (char const   *)tmp, option_source, option);
  }
#line 680
  return;
}
}
#line 690
static int option_prefix(char const   *arg ) ;
#line 690 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
static char *option_prefixes[4]  = {      (char *)"--",      (char *)"-",      (char *)"+",      (char *)0};
#line 687 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
static int option_prefix(char const   *arg ) 
{ 
  char **prefixes ;
  char *this_prefix ;
  char const   *argp ;
  int ret ;

  {
#line 699
  prefixes = option_prefixes;
#line 700
  this_prefix = *prefixes;
#line 701
  argp = arg;
#line 702
  ret = 0;
  {
#line 704
  while (1) {
    while_continue: /* CIL Label */ ;
#line 706
    this_prefix = *prefixes;
#line 707
    argp = arg;
    {
#line 709
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 709
      if (! ((int )*this_prefix == (int )*argp)) {
#line 709
        goto while_break___0;
      }
#line 711
      this_prefix ++;
#line 712
      argp ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 715
    if ((int )*this_prefix == 0) {
#line 717
      ret = (int )(this_prefix - *prefixes);
#line 718
      goto while_break;
    }
#line 704
    prefixes ++;
#line 704
    if (! *prefixes) {
#line 704
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 723
  return (ret);
}
}
#line 737 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
extern int set_option(char const   *option , char const   *param , int explicit ,
                      char const   *option_source ) 
{ 
  pro_ty const   *p ;
  char const   *param_start ;
  int option_length ;
  int tmp ;
  int val ;
  BOOLEAN found ;
  BOOLEAN tmp___0 ;
  long_option_conversion_ty const   *o ;
  BOOLEAN tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *t ;
  char *tmp___6 ;
  char *str ;
  size_t tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  unsigned short const   **tmp___10 ;
  unsigned short const   **tmp___11 ;
  char *tmp___12 ;

  {
  {
#line 743
  p = pro;
#line 744
  param_start = (char const   *)((void *)0);
#line 745
  tmp = option_prefix(option);
#line 745
  option_length = tmp;
#line 746
  val = 0;
#line 747
  found = (BOOLEAN )0;
  }
#line 749
  if (option_length > 0) {
#line 751
    if (option_length == 1) {
#line 751
      if ((int const   )*option == 45) {
#line 754
        option ++;
#line 756
        p = pro;
        {
#line 756
        while (1) {
          while_continue: /* CIL Label */ ;
#line 756
          if (! p->p_name) {
#line 756
            goto while_break;
          }
#line 758
          if ((int )*(p->p_name) == (int )*option) {
            {
#line 758
            tmp___0 = eqin((char const   *)p->p_name, option, & param_start);
            }
#line 758
            if (tmp___0) {
#line 761
              found = (BOOLEAN )1;
#line 762
              goto while_break;
            }
          }
#line 756
          p ++;
        }
        while_break: /* CIL Label */ ;
        }
      } else {
#line 751
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 769
      o = option_conversions;
#line 771
      option += option_length;
      {
#line 773
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 773
        if (! o->short_name) {
#line 773
          goto while_break___0;
        }
        {
#line 775
        tmp___1 = eqin((char const   *)o->long_name, option, & param_start);
        }
#line 775
        if (tmp___1) {
#line 777
          goto while_break___0;
        }
#line 780
        o ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 786
      if (o->short_name) {
#line 788
        p = pro;
        {
#line 788
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 788
          if (! p->p_name) {
#line 788
            goto while_break___1;
          }
          {
#line 790
          tmp___2 = strcmp((char const   *)p->p_name, (char const   *)o->short_name);
          }
#line 790
          if (! tmp___2) {
#line 792
            found = (BOOLEAN )1;
#line 793
            goto while_break___1;
          }
#line 788
          p ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
    }
  }
#line 800
  if (! found) {
    {
#line 802
    tmp___3 = gettext("%s: unknown option \"%s\"\n");
#line 802
    DieError(1, (char const   *)tmp___3, option_source, option - 1);
    }
  } else {
#line 810
    if (settings.verbose) {
      {
#line 812
      tmp___4 = gettext("option: %s\n");
#line 812
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___4,
              p->p_name);
      }
    }
#line 815
    if (explicit) {
#line 815
      goto _L___0;
    } else
#line 815
    if (! *(p->p_explicit)) {
      _L___0: /* CIL Label */ 
#line 817
      if (explicit) {
#line 819
        *(p->p_explicit) = 1;
      }
      {
#line 825
      if ((unsigned int const   )p->p_type == 5U) {
#line 825
        goto case_5;
      }
#line 832
      if ((unsigned int const   )p->p_type == 6U) {
#line 832
        goto case_6;
      }
#line 836
      if ((unsigned int const   )p->p_type == 4U) {
#line 836
        goto case_4;
      }
#line 854
      if ((unsigned int const   )p->p_type == 2U) {
#line 854
        goto case_2;
      }
#line 857
      if ((unsigned int const   )p->p_type == 3U) {
#line 857
        goto case_3;
      }
#line 879
      if ((unsigned int const   )p->p_type == 0U) {
#line 879
        goto case_0;
      }
#line 891
      if ((unsigned int const   )p->p_type == 1U) {
#line 891
        goto case_1;
      }
#line 919
      goto switch_default;
      case_5: /* CIL Label */ 
      {
#line 828
      tmp___5 = gettext("GNU indent %s\n");
#line 828
      printf((char const   */* __restrict  */)tmp___5, (char *)p->p_obj);
#line 829
      exit(1);
      }
#line 830
      goto switch_break;
      case_6: /* CIL Label */ 
      {
#line 833
      (*((void (*)(void))p->p_obj))();
      }
#line 834
      goto switch_break;
      case_4: /* CIL Label */ 
#line 840
      t = (char *)p->p_obj;
      {
#line 842
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 844
        set_option((char const   *)t, (char const   *)0, 0, option_source);
        }
        {
#line 847
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 847
          tmp___6 = t;
#line 847
          t ++;
#line 847
          if (! *tmp___6) {
#line 847
            goto while_break___3;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
#line 842
        if (! *t) {
#line 842
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 852
      goto switch_break;
      case_2: /* CIL Label */ 
#line 855
      goto switch_break;
      case_3: /* CIL Label */ 
#line 861
      if ((int const   )*param_start == 0) {
#line 863
        param_start = param;
#line 863
        if (param_start) {
#line 869
          val = 1;
        } else {
          {
#line 865
          arg_missing(option, option_source);
          }
        }
      }
      {
#line 873
      tmp___7 = strlen(param_start);
#line 873
      tmp___8 = xmalloc((unsigned int )(tmp___7 + 1UL));
#line 873
      str = tmp___8;
#line 874
      strcpy((char */* __restrict  */)str, (char const   */* __restrict  */)param_start);
#line 875
      addkey(str, (rwcodes_ty )7);
      }
#line 877
      goto switch_break;
      case_0: /* CIL Label */ 
#line 880
      if ((unsigned int const   )p->p_special == 1U) {
#line 882
        *(p->p_obj) = 0;
      } else {
#line 886
        *(p->p_obj) = 1;
      }
#line 889
      goto switch_break;
      case_1: /* CIL Label */ 
#line 892
      if ((int const   )*param_start == 0) {
#line 894
        param_start = param;
#line 896
        if ((unsigned long )param_start == (unsigned long )((void *)0)) {
          {
#line 898
          arg_missing(option, option_source);
          }
        } else {
#line 902
          val = 1;
        }
      }
      {
#line 906
      tmp___10 = __ctype_b_loc();
      }
#line 906
      if ((int const   )*(*tmp___10 + (int )*param_start) & 2048) {
        {
#line 908
        *(p->p_obj) = atoi(param_start);
        }
      } else
#line 906
      if ((int const   )*param_start == 45) {
        {
#line 906
        tmp___11 = __ctype_b_loc();
        }
#line 906
        if ((int const   )*(*tmp___11 + (int )*(param_start + 1)) & 2048) {
          {
#line 908
          *(p->p_obj) = atoi(param_start);
          }
        } else {
          {
#line 912
          tmp___9 = gettext("%s: option ``%s\'\' requires a numeric parameter\n");
#line 912
          DieError(1, (char const   *)tmp___9, option_source, option - 1);
          }
        }
      } else {
        {
#line 912
        tmp___9 = gettext("%s: option ``%s\'\' requires a numeric parameter\n");
#line 912
        DieError(1, (char const   *)tmp___9, option_source, option - 1);
        }
      }
#line 917
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 920
      tmp___12 = gettext("set_option: internal error: p_type %d\n");
#line 920
      DieError(1, (char const   *)tmp___12, (int )p->p_type);
      }
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 927
  return (val);
}
}
#line 935 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
static int skip_cpp_comment(FILE *f ) 
{ 
  int i ;

  {
  {
#line 941
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 943
    i = _IO_getc(f);
    }
#line 941
    if (i != -1) {
#line 941
      if (! (i != 10)) {
#line 941
        goto while_break;
      }
    } else {
#line 941
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 946
  if (i == 10) {
    {
#line 948
    i = _IO_getc(f);
    }
  }
#line 951
  return (i);
}
}
#line 960 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
static int skip_c_comment(FILE *f ) 
{ 
  int i ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 963
  tmp = _IO_getc(f);
#line 963
  i = tmp;
  }
  {
#line 965
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 969
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 969
      if (i != -1) {
#line 969
        if (! (i != 42)) {
#line 969
          goto while_break___0;
        }
      } else {
#line 969
        goto while_break___0;
      }
      {
#line 971
      i = _IO_getc(f);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 975
    if (i == -1) {
      {
#line 977
      tmp___0 = gettext("Profile contains an unterminated comment");
#line 977
      tmp___1 = gettext("Warning");
#line 977
      message(tmp___1, tmp___0, (unsigned int *)0, (unsigned int *)0);
      }
#line 978
      goto while_break;
    }
    {
#line 982
    i = _IO_getc(f);
    }
#line 965
    if (! (i != 47)) {
#line 965
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 987
  if (i != -1) {
    {
#line 989
    i = _IO_getc(f);
    }
  }
#line 992
  return (i);
}
}
#line 1001 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
static int skip_comment(FILE *f ) 
{ 
  int i ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 1004
  tmp = _IO_getc(f);
#line 1004
  i = tmp;
  }
  {
#line 1008
  if (i == 47) {
#line 1008
    goto case_47;
  }
#line 1011
  if (i == 42) {
#line 1011
    goto case_42;
  }
#line 1014
  goto switch_default;
  case_47: /* CIL Label */ 
  {
#line 1009
  i = skip_cpp_comment(f);
  }
#line 1010
  goto switch_break;
  case_42: /* CIL Label */ 
  {
#line 1012
  i = skip_c_comment(f);
  }
#line 1013
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1015
  tmp___0 = gettext("Profile contains unpalatable characters");
#line 1015
  tmp___1 = gettext("Warning");
#line 1015
  message(tmp___1, tmp___0, (unsigned int *)0, (unsigned int *)0);
  }
  switch_break: /* CIL Label */ ;
  }
#line 1018
  return (i);
}
}
#line 1026 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
static int skip_spaces(FILE *f , int first ) 
{ 
  int i ;

  {
#line 1030
  i = first;
  {
#line 1032
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1032
    if (i <= 32) {
#line 1032
      if (! (i != -1)) {
#line 1032
        goto while_break;
      }
    } else {
#line 1032
      goto while_break;
    }
    {
#line 1035
    i = _IO_getc(f);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1038
  return (i);
}
}
#line 1046 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
static int read_string(FILE *f , char *buff , int first ) 
{ 
  int i ;
  char *p ;
  char *tmp ;

  {
#line 1051
  i = first;
#line 1052
  p = buff;
  {
#line 1054
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1054
    if (i != -1) {
#line 1054
      if (i > 32) {
#line 1054
        if (i != 47) {
#line 1054
          if (! ((unsigned long )p < (unsigned long )(buff + 8192))) {
#line 1054
            goto while_break;
          }
        } else {
#line 1054
          goto while_break;
        }
      } else {
#line 1054
        goto while_break;
      }
    } else {
#line 1054
      goto while_break;
    }
    {
#line 1059
    tmp = p;
#line 1059
    p ++;
#line 1059
    *tmp = (char )i;
#line 1060
    i = _IO_getc(f);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1063
  *p = (char )'\000';
#line 1065
  return (i);
}
}
#line 1072 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
static void scan_profile(FILE *f , char const   *option_source ) 
{ 
  char b0[8192] ;
  char b1[8192] ;
  char *current ;
  int i ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1078
  current = b0;
#line 1080
  tmp = skip_spaces(f, ' ');
#line 1080
  i = tmp;
  }
  {
#line 1082
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1082
    if (! (i != -1)) {
#line 1082
      goto while_break;
    }
#line 1084
    if (i == 47) {
      {
#line 1087
      i = skip_comment(f);
      }
    } else {
      {
#line 1091
      i = read_string(f, current, i);
      }
#line 1095
      if ((unsigned long )current == (unsigned long )(b0)) {
#line 1098
        current = b1;
      } else {
        {
#line 1100
        tmp___0 = set_option((char const   *)(b0), (char const   *)(b1), 1, option_source);
        }
#line 1100
        if (tmp___0 == 1) {
#line 1106
          current = b0;
        } else {
          {
#line 1115
          strcpy((char */* __restrict  */)(b0), (char const   */* __restrict  */)(b1));
#line 1116
          current = b1;
          }
        }
      }
    }
    {
#line 1121
    i = skip_spaces(f, i);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1124
  if ((unsigned long )current != (unsigned long )(b0)) {
    {
#line 1126
    set_option((char const   *)(b0), (char const   *)((void *)0), 1, option_source);
    }
  }
#line 1128
  return;
}
}
#line 1173 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
static char prof[12]  = 
#line 1173
  {      (char )'.',      (char )'i',      (char )'n',      (char )'d', 
        (char )'e',      (char )'n',      (char )'t',      (char )'.', 
        (char )'p',      (char )'r',      (char )'o',      (char )'\000'};
#line 1169 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/args.c"
char *set_profile(void) 
{ 
  FILE *f ;
  char *fname ;
  char *homedir ;
  char const   *envname ;
  char *tmp ;
  char *tmp___0 ;
  int len ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;

  {
  {
#line 1171
  f = (FILE *)((void *)0);
#line 1172
  fname = (char *)((void *)0);
#line 1174
  homedir = (char *)((void *)0);
#line 1175
  tmp = getenv("INDENT_PROFILE");
#line 1175
  envname = (char const   *)tmp;
  }
#line 1177
  if ((unsigned long )envname != (unsigned long )((void *)0)) {
    {
#line 1179
    f = fopen((char const   */* __restrict  */)envname, (char const   */* __restrict  */)"r");
    }
#line 1181
    if ((unsigned long )f == (unsigned long )((void *)0)) {
      {
#line 1183
      tmp___0 = gettext("File named by environment variable %s does not exist or is not readable");
#line 1183
      fatal((char const   *)tmp___0, "INDENT_PROFILE");
      }
    } else {
      {
#line 1188
      scan_profile(f, envname);
#line 1190
      fclose(f);
#line 1192
      fname = strdup(envname);
      }
    }
  } else {
    {
#line 1197
    f = fopen((char const   */* __restrict  */)".indent.pro", (char const   */* __restrict  */)"r");
    }
#line 1199
    if ((unsigned long )f != (unsigned long )((void *)0)) {
      {
#line 1201
      tmp___1 = strlen(".indent.pro");
#line 1201
      len = (int )(tmp___1 + 3UL);
#line 1203
      scan_profile(f, ".indent.pro");
#line 1204
      fclose(f);
#line 1206
      fname = xmalloc((unsigned int )len);
#line 1207
      strcpy((char */* __restrict  */)fname, (char const   */* __restrict  */)"./");
#line 1208
      strcat((char */* __restrict  */)fname, (char const   */* __restrict  */)".indent.pro");
      }
    } else {
      {
#line 1212
      homedir = getenv("HOME");
      }
#line 1214
      if (homedir) {
        {
#line 1216
        tmp___2 = strlen((char const   *)homedir);
#line 1216
        tmp___3 = strlen("%s/%s");
#line 1216
        fname = xmalloc((unsigned int )((tmp___2 + tmp___3) + sizeof(prof)));
#line 1217
        sprintf((char */* __restrict  */)fname, (char const   */* __restrict  */)"%s/%s",
                homedir, prof);
#line 1219
        f = fopen((char const   */* __restrict  */)fname, (char const   */* __restrict  */)"r");
        }
#line 1219
        if ((unsigned long )f != (unsigned long )((void *)0)) {
          {
#line 1221
          scan_profile(f, (char const   *)fname);
#line 1222
          fclose(f);
          }
        } else {
          {
#line 1226
          free((void *)fname);
#line 1227
          fname = (char *)((void *)0);
          }
        }
      }
    }
  }
#line 1233
  return (fname);
}
}
#line 846 "/usr/include/stdio.h"
extern void perror(char const   *__s ) ;
#line 41 "/usr/include/malloc.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 49
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/globs.c"
extern char *xmalloc(unsigned int size ) 
{ 
  char *val ;
  void *tmp ;
  char *tmp___0 ;

  {
  {
#line 45
  tmp = calloc((size_t )1, (size_t )size);
#line 45
  val = (char *)tmp;
  }
#line 47
  if (! val) {
    {
#line 49
    tmp___0 = gettext("indent: Virtual memory exhausted.\n");
#line 49
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0);
#line 50
    exit(5);
    }
  }
#line 59
  return (val);
}
}
#line 66 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/globs.c"
extern char *xrealloc(char *ptr , unsigned int size ) 
{ 
  char *val ;
  void *tmp ;
  char *tmp___0 ;

  {
  {
#line 70
  tmp = realloc((void *)ptr, (size_t )size);
#line 70
  val = (char *)tmp;
  }
#line 72
  if (! val) {
    {
#line 74
    tmp___0 = gettext("indent: Virtual memory exhausted.\n");
#line 74
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0);
#line 75
    exit(5);
    }
  }
#line 78
  return (val);
}
}
#line 85 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/globs.c"
extern void message(char *kind , char *string , unsigned int *a0 , unsigned int *a1 ) 
{ 
  char *tmp ;

  {
#line 91
  if (kind) {
    {
#line 93
    tmp = gettext("indent: %s:%d: %s:");
#line 93
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
            in_name, line_no, kind);
    }
  }
  {
#line 96
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)string,
          a0, a1);
#line 97
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
  }
#line 98
  return;
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/globs.c"
extern void fatal(char const   *string , char const   *a0 ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 109
  tmp = gettext("indent: Fatal Error: ");
#line 109
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp);
#line 110
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)string,
          a0);
#line 111
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 117
  tmp___1 = __errno_location();
  }
#line 117
  if (*tmp___1) {
    {
#line 119
    tmp___0 = gettext("indent: System Error: ");
#line 119
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0);
#line 120
    perror((char const   *)0);
    }
  }
  {
#line 123
  exit(4);
  }
}
}
#line 435 "/usr/include/libio.h"
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 278
extern FILE *freopen(char const   * __restrict  __filename , char const   * __restrict  __modes ,
                     FILE * __restrict  __stream ) ;
#line 50 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/output.h"
int prev_target_col_break ;
#line 74 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/output.c"
static FILE *output  =    (FILE *)((void *)0);
#line 75 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/output.c"
static BOOLEAN inhibited  =    (BOOLEAN )0;
#line 76 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/output.c"
static buf_break_st_ty *buf_break_list  =    (buf_break_st_ty *)((void *)0);
#line 81 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/output.c"
buf_break_st_ty *buf_break  =    (buf_break_st_ty *)((void *)0);
#line 83 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/output.c"
int out_lines  =    0;
#line 84 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/output.c"
int com_lines  =    0;
#line 86 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/output.c"
int prev_target_col_break  =    0;
#line 87 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/output.c"
int buf_break_used  =    0;
#line 88 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/output.c"
int preproc_indent  =    0;
#line 109 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/output.c"
static int first_level  ;
#line 105 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/output.c"
static BOOLEAN better_break(buf_break_st_ty *b1 , buf_break_st_ty const   *b2 ) 
{ 
  BOOLEAN is_better ;
  int only_parens_till_b2 ;
  char *p ;

  {
#line 112
  if (! b2) {
#line 114
    first_level = b1->level;
#line 115
    b1->first_level = first_level;
#line 116
    is_better = (BOOLEAN )1;
  } else {
#line 120
    if (b2->target_col >= b2->col + 1) {
#line 122
      is_better = (BOOLEAN )1;
    } else
#line 124
    if (settings.honour_newlines) {
#line 124
      if (b2->priority_newline) {
#line 126
        is_better = (BOOLEAN )0;
      } else {
#line 124
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 128
    if (settings.honour_newlines) {
#line 128
      if (b1->priority_newline) {
#line 130
        is_better = (BOOLEAN )1;
      } else {
#line 128
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 134
      only_parens_till_b2 = 0;
#line 136
      is_better = (BOOLEAN )(b1->priority > (int )b2->priority);
#line 138
      if (is_better) {
#line 142
        p = s_code + b2->offset;
        {
#line 142
        while (1) {
          while_continue: /* CIL Label */ ;
#line 142
          if (! ((unsigned long )p >= (unsigned long )s_code)) {
#line 142
            goto while_break;
          }
#line 144
          if ((int )*p == 33) {
#line 146
            p --;
          }
#line 149
          if ((int )*p != 40) {
#line 151
            goto while_break;
          }
#line 142
          p --;
        }
        while_break: /* CIL Label */ ;
        }
#line 155
        if ((unsigned long )p < (unsigned long )s_code) {
#line 157
          only_parens_till_b2 = 1;
        }
      }
#line 161
      if (settings.lineup_to_parens) {
#line 161
        if (b1->level > first_level + 1) {
#line 161
          if (only_parens_till_b2) {
#line 161
            if (! (b1->target_col <= (int )(b2->col + (int const   )(1 + 2 * b1->level)))) {
#line 161
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 161
          if (b1->level > (int )b2->level) {
#line 166
            is_better = (BOOLEAN )0;
          }
        }
      }
    }
#line 170
    if (is_better) {
#line 172
      b1->first_level = first_level;
    }
  }
#line 176
  return (is_better);
}
}
#line 198 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/output.c"
static void set_priority(buf_break_st_ty *bb ) 
{ 


  {
#line 201
  bb->priority = bb->priority_code_length;
  {
#line 205
  if ((unsigned int )bb->priority_code == 15U) {
#line 205
    goto case_15;
  }
#line 208
  if ((unsigned int )bb->priority_code == 8U) {
#line 208
    goto case_8;
  }
#line 211
  if ((unsigned int )bb->priority_code == 9U) {
#line 211
    goto case_9;
  }
#line 222
  if ((unsigned int )bb->priority_code == 10U) {
#line 222
    goto case_10;
  }
#line 225
  if ((unsigned int )bb->priority_code == 21U) {
#line 225
    goto case_21;
  }
#line 228
  if ((unsigned int )bb->priority_code == 1U) {
#line 228
    goto case_1;
  }
#line 231
  if ((unsigned int )bb->priority_code == 11U) {
#line 231
    goto case_11;
  }
#line 234
  if ((unsigned int )bb->priority_code == 4U) {
#line 234
    goto case_4;
  }
#line 237
  if ((unsigned int )bb->priority_code == 26U) {
#line 237
    goto case_26;
  }
#line 240
  if ((unsigned int )bb->priority_code == 25U) {
#line 240
    goto case_25;
  }
#line 243
  if ((unsigned int )bb->priority_code == 24U) {
#line 243
    goto case_24;
  }
#line 246
  if ((unsigned int )bb->priority_code == 23U) {
#line 246
    goto case_23;
  }
#line 249
  if ((unsigned int )bb->priority_code == 27U) {
#line 249
    goto case_27;
  }
#line 252
  goto switch_default;
  case_15: /* CIL Label */ 
#line 206
  bb->priority += 6000;
#line 207
  goto switch_break;
  case_8: /* CIL Label */ 
#line 209
  bb->priority += 5000;
#line 210
  goto switch_break;
  case_9: /* CIL Label */ 
#line 212
  if (bb->priority_code_length > 2) {
#line 214
    bb->priority += 5000;
  }
#line 217
  if (settings.break_before_boolean_operator) {
#line 219
    bb->priority -= 3;
  }
#line 221
  goto switch_break;
  case_10: /* CIL Label */ 
#line 223
  bb->priority += 4000;
#line 224
  goto switch_break;
  case_21: /* CIL Label */ 
#line 226
  bb->priority += 3000;
#line 227
  goto switch_break;
  case_1: /* CIL Label */ 
#line 229
  bb->priority += 2000;
#line 230
  goto switch_break;
  case_11: /* CIL Label */ 
#line 232
  bb->priority += 1000;
#line 233
  goto switch_break;
  case_4: /* CIL Label */ 
#line 235
  bb->priority -= 1000;
#line 236
  goto switch_break;
  case_26: /* CIL Label */ 
#line 238
  bb->priority += 600;
#line 239
  goto switch_break;
  case_25: /* CIL Label */ 
#line 241
  bb->priority += 500;
#line 242
  goto switch_break;
  case_24: /* CIL Label */ 
#line 244
  bb->priority += 400;
#line 245
  goto switch_break;
  case_23: /* CIL Label */ 
#line 247
  bb->priority += 200;
#line 248
  goto switch_break;
  case_27: /* CIL Label */ 
#line 250
  bb->priority += 100;
#line 251
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 253
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 255
  return;
}
}
#line 262 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/output.c"
void set_buf_break(bb_code_ty code , int paren_targ ) 
{ 
  int target_col ;
  int level ;
  int code_target ;
  int tmp ;
  buf_break_st_ty *bb ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  buf_break_st_ty *obb ;
  BOOLEAN tmp___3 ;

  {
  {
#line 267
  tmp = compute_code_target(paren_targ);
#line 267
  code_target = tmp;
#line 276
  target_col = parser_state_tos->i_l_follow + 1;
  }
#line 281
  if ((int )*token == 123) {
#line 283
    target_col -= settings.ind_size;
  }
#line 289
  level = parser_state_tos->p_l_follow;
#line 294
  if ((int )*token == 40) {
#line 296
    level --;
  } else
#line 294
  if ((int )*token == 91) {
#line 296
    level --;
  }
#line 301
  if (*(parser_state_tos->procname + 0)) {
#line 301
    if ((unsigned long )token == (unsigned long )parser_state_tos->procname) {
#line 304
      target_col = 1;
    } else {
#line 301
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 306
  if (level == 0) {
#line 308
    if (parser_state_tos->in_stmt) {
#line 310
      target_col += settings.continuation_indent;
    }
  } else
#line 313
  if (! settings.lineup_to_parens) {
#line 315
    target_col += settings.continuation_indent + settings.paren_indent * (level - 1);
  } else
#line 320
  if ((int )*(parser_state_tos->paren_indents + (level - 1)) < 0) {
#line 322
    target_col = - ((int )*(parser_state_tos->paren_indents + (level - 1)));
  } else {
#line 326
    target_col = code_target + (int )*(parser_state_tos->paren_indents + (level - 1));
  }
  {
#line 332
  tmp___0 = xmalloc((unsigned int )sizeof(buf_break_st_ty ));
#line 332
  bb = (buf_break_st_ty *)tmp___0;
#line 333
  bb->offset = (int )(e_code - s_code);
#line 334
  bb->level = level;
#line 335
  bb->target_col = target_col;
#line 336
  bb->corresponds_to = token;
#line 337
  *e_code = (char)0;
#line 338
  tmp___1 = count_columns(code_target, s_code, '\000');
#line 338
  bb->col = tmp___1 - 1;
#line 342
  bb->priority_code_length = (int )(e_code - s_code);
  }
#line 343
  if (parser_state_tos->last_saw_nl) {
#line 343
    if (! parser_state_tos->broken_at_non_nl) {
#line 343
      tmp___2 = 1;
    } else {
#line 343
      tmp___2 = 0;
    }
  } else {
#line 343
    tmp___2 = 0;
  }
#line 343
  bb->priority_newline = tmp___2;
#line 346
  if (buf_break) {
#line 348
    bb->first_level = buf_break->first_level;
  }
  {
#line 353
  if ((unsigned int )parser_state_tos->last_token == 6U) {
#line 353
    goto case_6;
  }
#line 404
  if ((unsigned int )parser_state_tos->last_token == 18U) {
#line 404
    goto case_18;
  }
#line 407
  goto switch_default;
  case_6: /* CIL Label */ 
#line 354
  if (e_code - s_code >= 3L) {
#line 354
    if ((int )*(e_code + -3) == 32) {
#line 354
      if ((int )*(e_code + -1) == 38) {
#line 354
        if ((int )*(e_code + -2) == 38) {
#line 359
          bb->priority_code = (bb_code_ty )9;
        } else {
#line 354
          goto _L___8;
        }
      } else
      _L___8: /* CIL Label */ 
#line 354
      if ((int )*(e_code + -1) == 124) {
#line 354
        if ((int )*(e_code + -2) == 124) {
#line 359
          bb->priority_code = (bb_code_ty )9;
        } else {
#line 354
          goto _L___9;
        }
      } else {
#line 354
        goto _L___9;
      }
    } else {
#line 354
      goto _L___9;
    }
  } else
  _L___9: /* CIL Label */ 
#line 361
  if (e_code - s_code >= 2L) {
#line 361
    if ((int )*(e_code + -1) == 61) {
#line 361
      if ((int )*(e_code + -2) == 32) {
#line 373
        bb->priority_code = (bb_code_ty )10;
      } else
#line 361
      if (e_code - s_code >= 3L) {
#line 361
        if ((int )*(e_code + -3) == 32) {
#line 361
          if ((int )*(e_code + -2) == 37) {
#line 373
            bb->priority_code = (bb_code_ty )10;
          } else
#line 361
          if ((int )*(e_code + -2) == 94) {
#line 373
            bb->priority_code = (bb_code_ty )10;
          } else
#line 361
          if ((int )*(e_code + -2) == 38) {
#line 373
            bb->priority_code = (bb_code_ty )10;
          } else
#line 361
          if ((int )*(e_code + -2) == 42) {
#line 373
            bb->priority_code = (bb_code_ty )10;
          } else
#line 361
          if ((int )*(e_code + -2) == 45) {
#line 373
            bb->priority_code = (bb_code_ty )10;
          } else
#line 361
          if ((int )*(e_code + -2) == 43) {
#line 373
            bb->priority_code = (bb_code_ty )10;
          } else
#line 361
          if ((int )*(e_code + -2) == 124) {
#line 373
            bb->priority_code = (bb_code_ty )10;
          } else {
#line 361
            goto _L___6;
          }
        } else {
#line 361
          goto _L___6;
        }
      } else {
#line 361
        goto _L___6;
      }
    } else {
#line 361
      goto _L___6;
    }
  } else
  _L___6: /* CIL Label */ 
#line 375
  if (e_code - s_code >= 2L) {
#line 375
    if ((int )*(e_code + -2) == 32) {
#line 375
      if ((int )*(e_code + -1) == 60) {
#line 387
        bb->priority_code = (bb_code_ty )11;
      } else
#line 375
      if ((int )*(e_code + -1) == 62) {
#line 387
        bb->priority_code = (bb_code_ty )11;
      } else {
#line 375
        goto _L___4;
      }
    } else {
#line 375
      goto _L___4;
    }
  } else
  _L___4: /* CIL Label */ 
#line 375
  if (e_code - s_code >= 3L) {
#line 375
    if ((int )*(e_code + -3) == 32) {
#line 375
      if ((int )*(e_code + -1) == 61) {
#line 375
        if ((int )*(e_code + -2) == 61) {
#line 387
          bb->priority_code = (bb_code_ty )11;
        } else
#line 375
        if ((int )*(e_code + -2) == 33) {
#line 387
          bb->priority_code = (bb_code_ty )11;
        } else
#line 375
        if ((int )*(e_code + -2) == 60) {
#line 387
          bb->priority_code = (bb_code_ty )11;
        } else
#line 375
        if ((int )*(e_code + -2) == 62) {
#line 387
          bb->priority_code = (bb_code_ty )11;
        } else {
#line 375
          goto _L___2;
        }
      } else {
#line 375
        goto _L___2;
      }
    } else {
#line 375
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 389
  if ((int )*(e_code + -1) == 43) {
#line 392
    bb->priority_code = (bb_code_ty )26;
  } else
#line 389
  if ((int )*(e_code + -1) == 45) {
#line 392
    bb->priority_code = (bb_code_ty )26;
  } else
#line 394
  if ((int )*(e_code + -1) == 42) {
#line 396
    bb->priority_code = (bb_code_ty )25;
  } else
#line 394
  if ((int )*(e_code + -1) == 47) {
#line 396
    bb->priority_code = (bb_code_ty )25;
  } else
#line 394
  if ((int )*(e_code + -1) == 37) {
#line 396
    bb->priority_code = (bb_code_ty )25;
  } else {
#line 400
    bb->priority_code = (bb_code_ty )7;
  }
#line 403
  goto switch_break;
  case_18: /* CIL Label */ 
#line 405
  bb->priority_code = (bb_code_ty )1;
#line 406
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 408
  if ((unsigned int )code == 7U) {
#line 408
    if ((int )*token == 38) {
#line 408
      goto _L___12;
    } else
#line 408
    if ((int )*token == 124) {
      _L___12: /* CIL Label */ 
#line 408
      if ((int )*token == (int )*(token + 1)) {
#line 413
        bb->priority_code = (bb_code_ty )8;
      } else {
#line 408
        goto _L___11;
      }
    } else {
#line 408
      goto _L___11;
    }
  } else
  _L___11: /* CIL Label */ 
#line 415
  if ((int )*(e_code + -1) == 59) {
#line 417
    bb->priority_code = (bb_code_ty )15;
  } else {
#line 421
    bb->priority_code = code;
#line 422
    if ((unsigned int )code == 22U) {
#line 424
      if ((int )*(e_code + -1) == 42) {
#line 426
        bb->priority_code = (bb_code_ty )24;
      } else {
#line 430
        bb->priority_code = (bb_code_ty )23;
      }
    }
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 435
  set_priority(bb);
  }
#line 439
  if (buf_break_list) {
#line 441
    buf_break_list->next = bb;
  }
#line 444
  bb->prev = buf_break_list;
#line 445
  bb->next = (struct buf_break_st *)((void *)0);
#line 446
  buf_break_list = bb;
#line 448
  if (! buf_break) {
#line 448
    goto _L___13;
  } else
#line 448
  if (bb->col <= settings.max_col) {
    _L___13: /* CIL Label */ 
    {
#line 450
    tmp___3 = better_break(bb, (buf_break_st_ty const   *)buf_break);
    }
#line 450
    if (tmp___3) {
#line 454
      buf_break = bb;
#line 456
      bb = bb->prev;
      {
#line 456
      while (1) {
        while_continue: /* CIL Label */ ;
#line 456
        if (! bb) {
#line 456
          goto while_break;
        }
        {
#line 458
        obb = bb;
#line 460
        bb = bb->prev;
#line 461
        free((void *)obb);
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 464
      buf_break->prev = (struct buf_break_st *)((void *)0);
    }
  }
#line 467
  return;
}
}
#line 473 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/output.c"
void clear_buf_break_list(BOOLEAN *pbreak_line ) 
{ 
  buf_break_st_ty *bb ;
  buf_break_st_ty *obb ;

  {
#line 478
  bb = buf_break_list;
  {
#line 478
  while (1) {
    while_continue: /* CIL Label */ ;
#line 478
    if (! bb) {
#line 478
      goto while_break;
    }
    {
#line 480
    obb = bb;
#line 482
    bb = bb->prev;
#line 483
    free((void *)obb);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 486
  buf_break_list = (buf_break_st_ty *)((void *)0);
#line 486
  buf_break = buf_break_list;
#line 487
  *pbreak_line = (BOOLEAN )0;
#line 488
  return;
}
}
#line 502 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/output.c"
static void set_next_buf_break(int prev_code_target , int new_code_target , int offset ,
                               BOOLEAN *pbreak_line ) 
{ 
  buf_break_st_ty *bb ;
  buf_break_st_ty *obb ;
  BOOLEAN tmp ;

  {
  {
#line 510
  better_break(buf_break, (buf_break_st_ty const   *)((void *)0));
  }
#line 512
  if ((unsigned long )buf_break_list == (unsigned long )buf_break) {
    {
#line 514
    clear_buf_break_list(pbreak_line);
    }
  } else {
#line 519
    bb = buf_break_list;
    {
#line 519
    while (1) {
      while_continue: /* CIL Label */ ;
#line 519
      if (! bb) {
#line 519
        goto while_break;
      }
#line 521
      if (bb->target_col > buf_break->target_col) {
#line 521
        if (settings.lineup_to_parens) {
#line 523
          bb->target_col -= (prev_code_target + offset) - new_code_target;
        }
      }
#line 526
      bb->col -= (prev_code_target + offset) - new_code_target;
#line 527
      bb->offset -= offset;
#line 528
      bb->priority_code_length -= offset;
#line 529
      bb->first_level = buf_break->first_level;
#line 531
      if (! buf_break->priority_newline) {
#line 533
        bb->priority_newline = 0;
      }
      {
#line 536
      set_priority(bb);
      }
#line 538
      if ((unsigned long )bb->prev == (unsigned long )buf_break) {
#line 540
        goto while_break;
      }
#line 519
      bb = bb->prev;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 544
    free((void *)buf_break);
#line 548
    buf_break = bb;
#line 552
    buf_break->prev = (struct buf_break_st *)((void *)0);
#line 556
    bb = buf_break;
    }
    {
#line 556
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 556
      if (! bb) {
#line 556
        goto while_break___0;
      }
#line 558
      if (bb->col > settings.max_col) {
#line 560
        goto __Cont;
      }
      {
#line 563
      tmp = better_break(bb, (buf_break_st_ty const   *)buf_break);
      }
#line 563
      if (tmp) {
#line 566
        buf_break = bb;
#line 568
        bb = bb->prev;
        {
#line 568
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 568
          if (! bb) {
#line 568
            goto while_break___1;
          }
          {
#line 570
          obb = bb;
#line 572
          bb = bb->prev;
#line 573
          free((void *)obb);
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 575
        bb = buf_break;
#line 576
        buf_break->prev = (struct buf_break_st *)((void *)0);
      }
      __Cont: /* CIL Label */ 
#line 556
      bb = bb->next;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 580
  return;
}
}
#line 592 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/output.c"
static int pad_output(int currentColumn , int target_column ) 
{ 
  int offset ;

  {
#line 596
  if (currentColumn < target_column) {
#line 598
    if (settings.use_tabs) {
#line 598
      if (settings.tabsize > 1) {
#line 600
        offset = settings.tabsize - (currentColumn - 1) % settings.tabsize;
        {
#line 602
        while (1) {
          while_continue: /* CIL Label */ ;
#line 602
          if (! (currentColumn + offset <= target_column)) {
#line 602
            goto while_break;
          }
          {
#line 604
          _IO_putc('\t', output);
#line 605
          currentColumn += offset;
#line 606
          offset = settings.tabsize;
          }
        }
        while_break: /* CIL Label */ ;
        }
      }
    }
    {
#line 610
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 610
      if (! (currentColumn < target_column)) {
#line 610
        goto while_break___0;
      }
      {
#line 612
      _IO_putc(' ', output);
#line 613
      currentColumn ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 617
  return (currentColumn);
}
}
#line 626 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/output.c"
static void output_substring(FILE *file , char const   *begin , char const   *end ) 
{ 
  char const   *p ;

  {
#line 633
  p = begin;
  {
#line 633
  while (1) {
    while_continue: /* CIL Label */ ;
#line 633
    if (! ((unsigned long )p < (unsigned long )end)) {
#line 633
      goto while_break;
    }
    {
#line 635
    _IO_putc((int )*p, file);
#line 633
    p ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 637
  return;
}
}
#line 648 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/output.c"
static int dump_line_label(void) 
{ 
  int cur_col ;
  int tmp ;
  int preproc_postcrement ;
  char *p ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *s ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
#line 654
  while (1) {
    while_continue: /* CIL Label */ ;
#line 654
    if ((unsigned long )e_lab > (unsigned long )s_lab) {
#line 654
      if (! ((int )*(e_lab + -1) == 32)) {
#line 654
        if (! ((int )*(e_lab + -1) == 9)) {
#line 654
          goto while_break;
        }
      }
    } else {
#line 654
      goto while_break;
    }
#line 657
    e_lab --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 660
  tmp = compute_label_target();
#line 660
  cur_col = pad_output(1, tmp);
  }
#line 665
  if (settings.force_preproc_width > 0) {
#line 665
    if ((int )*(s_lab + 0) == 35) {
#line 669
      p = s_lab + 1;
      {
#line 671
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 671
        if (! ((int )*p == 32)) {
#line 671
          goto while_break___0;
        }
#line 673
        p ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 676
      preproc_postcrement = settings.force_preproc_width;
#line 678
      tmp___4 = strncmp((char const   *)p, "else", (size_t )4);
      }
#line 678
      if (tmp___4 == 0) {
#line 680
        preproc_indent -= settings.force_preproc_width;
      } else {
        {
#line 682
        tmp___2 = strncmp((char const   *)p, "if", (size_t )2);
        }
#line 682
        if (! (tmp___2 == 0)) {
          {
#line 682
          tmp___3 = strncmp((char const   *)p, "ifdef", (size_t )5);
          }
#line 682
          if (! (tmp___3 == 0)) {
            {
#line 686
            tmp___1 = strncmp((char const   *)p, "elif", (size_t )4);
            }
#line 686
            if (tmp___1 == 0) {
#line 688
              preproc_indent -= settings.force_preproc_width;
            } else {
              {
#line 690
              tmp___0 = strncmp((char const   *)p, "endif", (size_t )5);
              }
#line 690
              if (tmp___0 == 0) {
#line 692
                preproc_indent -= settings.force_preproc_width;
#line 693
                preproc_postcrement = 0;
              } else {
#line 697
                preproc_postcrement = 0;
              }
            }
          }
        }
      }
#line 700
      if (preproc_indent == 0) {
        {
#line 702
        fprintf((FILE */* __restrict  */)output, (char const   */* __restrict  */)"#");
        }
      } else {
        {
#line 706
        fprintf((FILE */* __restrict  */)output, (char const   */* __restrict  */)"#%*s",
                preproc_indent, " ");
        }
      }
      {
#line 709
      fprintf((FILE */* __restrict  */)output, (char const   */* __restrict  */)"%.*s",
              (int )(e_lab - p), p);
#line 711
      cur_col = count_columns((cur_col + preproc_indent) + 1, p, '\000');
#line 712
      preproc_indent += preproc_postcrement;
      }
    } else {
#line 665
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 714
  if ((int )*(s_lab + 0) == 35) {
    {
#line 714
    tmp___6 = strncmp((char const   *)(s_lab + 1), "else", (size_t )4);
    }
#line 714
    if (tmp___6 == 0) {
#line 714
      goto _L___0;
    } else {
      {
#line 714
      tmp___7 = strncmp((char const   *)(s_lab + 1), "endif", (size_t )5);
      }
#line 714
      if (tmp___7 == 0) {
        _L___0: /* CIL Label */ 
#line 720
        s = s_lab;
#line 722
        if ((int )*(e_lab + -1) == 10) {
#line 724
          e_lab --;
        }
        {
#line 727
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 729
          tmp___5 = s;
#line 729
          s ++;
#line 729
          _IO_putc((int )*tmp___5, output);
#line 730
          cur_col ++;
          }
#line 727
          if ((unsigned long )s < (unsigned long )e_lab) {
#line 727
            if (97 <= (int )*s) {
#line 727
              if (! ((int )*s <= 122)) {
#line 727
                goto while_break___1;
              }
            } else {
#line 727
              goto while_break___1;
            }
          } else {
#line 727
            goto while_break___1;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 733
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 733
          if ((int )*s == 32) {
#line 733
            goto _L;
          } else
#line 733
          if ((int )*s == 9) {
            _L: /* CIL Label */ 
#line 733
            if (! ((unsigned long )s < (unsigned long )e_lab)) {
#line 733
              goto while_break___2;
            }
          } else {
#line 733
            goto while_break___2;
          }
#line 735
          s ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 738
        if ((unsigned long )s < (unsigned long )e_lab) {
#line 740
          if (settings.tabsize > 1) {
            {
#line 742
            cur_col = pad_output(cur_col, (cur_col + settings.tabsize) - (cur_col - 1) % settings.tabsize);
            }
          } else {
            {
#line 747
            cur_col = pad_output(cur_col, cur_col + 2);
            }
          }
#line 750
          if ((int )*(s + 0) == 47) {
#line 750
            if ((int )*(s + 1) == 42) {
              {
#line 752
              fprintf((FILE */* __restrict  */)output, (char const   */* __restrict  */)"%.*s",
                      (int )(e_lab - s), s);
              }
            } else
#line 750
            if ((int )*(s + 1) == 47) {
              {
#line 752
              fprintf((FILE */* __restrict  */)output, (char const   */* __restrict  */)"%.*s",
                      (int )(e_lab - s), s);
              }
            } else {
              {
#line 756
              fprintf((FILE */* __restrict  */)output, (char const   */* __restrict  */)"/* %.*s */",
                      (int )(e_lab - s), s);
              }
            }
          } else {
            {
#line 756
            fprintf((FILE */* __restrict  */)output, (char const   */* __restrict  */)"/* %.*s */",
                    (int )(e_lab - s), s);
            }
          }
        }
      } else {
        {
#line 765
        fprintf((FILE */* __restrict  */)output, (char const   */* __restrict  */)"%.*s",
                (int )(e_lab - s_lab), s_lab);
#line 766
        cur_col = count_columns(cur_col, s_lab, '\000');
        }
      }
    }
  } else {
    {
#line 765
    fprintf((FILE */* __restrict  */)output, (char const   */* __restrict  */)"%.*s",
            (int )(e_lab - s_lab), s_lab);
#line 766
    cur_col = count_columns(cur_col, s_lab, '\000');
    }
  }
#line 769
  return (cur_col);
}
}
#line 776 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/output.c"
static int count_parens(char const   *string ) 
{ 
  int paren_level ;

  {
#line 779
  paren_level = 0;
  {
#line 781
  while (1) {
    while_continue: /* CIL Label */ ;
#line 781
    if (! *string) {
#line 781
      goto while_break;
    }
    {
#line 786
    if ((int const   )*string == 91) {
#line 786
      goto case_91;
    }
#line 786
    if ((int const   )*string == 40) {
#line 786
      goto case_91;
    }
#line 790
    if ((int const   )*string == 93) {
#line 790
      goto case_93;
    }
#line 790
    if ((int const   )*string == 41) {
#line 790
      goto case_93;
    }
#line 793
    goto switch_default;
    case_91: /* CIL Label */ 
    case_40: /* CIL Label */ 
#line 787
    paren_level ++;
#line 788
    goto switch_break;
    case_93: /* CIL Label */ 
    case_41: /* CIL Label */ 
#line 791
    paren_level --;
#line 792
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 794
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 797
    string ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 800
  return (paren_level);
}
}
#line 807 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/output.c"
static void dump_line_code(int *pcur_col , int *pnot_truncated , int paren_targ ,
                           BOOLEAN *pbreak_line , int target_col_break ) 
{ 
  int paren_level ;
  int i ;
  int target_col ;
  int offset ;
  int len ;
  char c ;
  char *ptr ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 814
  paren_level = 0;
#line 816
  if ((unsigned long )s_code != (unsigned long )e_code) {
#line 819
    target_col = 0;
#line 825
    if (embedded_comment_on_line == 1) {
#line 827
      target_col = parser_state_tos->com_col;
    } else
#line 829
    if (target_col_break != -1) {
#line 831
      target_col = target_col_break;
    } else {
      {
#line 835
      target_col = compute_code_target(paren_targ);
      }
    }
#line 838
    if (paren_level > 0) {
#line 840
      target_col += (int )*(parser_state_tos->paren_indents + ((parser_state_tos->p_l_follow + paren_level) - 1));
    }
#line 847
    if ((unsigned int )parser_state_tos->last_token == 2U) {
#line 849
      *(parser_state_tos->paren_indents + (parser_state_tos->p_l_follow - 1)) = (short )((int )*(parser_state_tos->paren_indents + (parser_state_tos->p_l_follow - 1)) + (settings.ind_size - 1));
    }
    {
#line 853
    *pcur_col = pad_output(*pcur_col, target_col);
    }
#line 855
    if (*pbreak_line) {
#line 855
      if ((unsigned long )s_com == (unsigned long )e_com) {
#line 855
        if (buf_break->target_col <= buf_break->col) {
#line 861
          ptr = s_code + buf_break->offset;
#line 863
          if ((int )*ptr != 32) {
#line 865
            ptr --;
          }
#line 872
          offset = (int )((ptr - s_code) + 1L);
#line 874
          i = 0;
          {
#line 874
          while (1) {
            while_continue: /* CIL Label */ ;
#line 874
            if (! (i < parser_state_tos->p_l_follow)) {
#line 874
              goto while_break;
            }
#line 876
            if ((int )*(parser_state_tos->paren_indents + i) >= 0) {
#line 878
              if ((long )*(parser_state_tos->paren_indents + i) < ptr - s_code) {
#line 880
                *(parser_state_tos->paren_indents + i) = (short )(- ((int )*(parser_state_tos->paren_indents + i) + target_col));
              } else {
#line 885
                *(parser_state_tos->paren_indents + i) = (short )((int )*(parser_state_tos->paren_indents + i) - offset);
              }
            }
#line 874
            i ++;
          }
          while_break: /* CIL Label */ ;
          }
#line 890
          i = parser_state_tos->p_l_follow;
          {
#line 890
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 890
            if (! (i < parser_state_tos->paren_indents_size)) {
#line 890
              goto while_break___0;
            }
#line 893
            if ((long )*(parser_state_tos->paren_indents + i) >= ptr - s_code) {
#line 895
              *(parser_state_tos->paren_indents + i) = (short )((int )*(parser_state_tos->paren_indents + i) - offset);
            }
#line 890
            i ++;
          }
          while_break___0: /* CIL Label */ ;
          }
          {
#line 899
          output_substring(output, (char const   *)s_code, (char const   *)(s_code + buf_break->offset));
#line 901
          c = *(s_code + buf_break->offset);
#line 903
          *(s_code + buf_break->offset) = (char )'\000';
#line 905
          *pcur_col = count_columns(*pcur_col, s_code, '\000');
#line 907
          tmp = count_parens((char const   *)s_code);
#line 907
          paren_level += tmp;
#line 909
          *(s_code + buf_break->offset) = c;
#line 911
          *pnot_truncated = 0;
#line 913
          len = (int )((e_code - ptr) - 1L);
#line 914
          memmove((void *)s_code, (void const   *)(ptr + 1), (size_t )len);
#line 916
          e_code = s_code + len;
#line 924
          *e_code = (char )'\000';
#line 925
          s_code_corresponds_to = buf_break->corresponds_to;
#line 926
          prev_target_col_break = buf_break->target_col;
          }
#line 928
          if (! buf_break->priority_newline) {
#line 930
            parser_state_tos->broken_at_non_nl = 1;
          }
          {
#line 933
          set_next_buf_break(target_col, buf_break->target_col, offset, pbreak_line);
#line 936
          buf_break_used = 1;
          }
#line 938
          if ((unsigned long )buf_break != (unsigned long )((void *)0)) {
            {
#line 938
            tmp___0 = output_line_length();
            }
#line 938
            if (tmp___0 > settings.max_col) {
#line 938
              tmp___1 = 1;
            } else {
#line 938
              tmp___1 = 0;
            }
          } else {
#line 938
            tmp___1 = 0;
          }
#line 938
          *pbreak_line = (BOOLEAN )tmp___1;
        } else {
#line 855
          goto _L___0;
        }
      } else {
#line 855
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 943
      i = 0;
      {
#line 943
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 943
        if (! (i < parser_state_tos->p_l_follow)) {
#line 943
          goto while_break___1;
        }
#line 945
        if ((int )*(parser_state_tos->paren_indents + i) >= 0) {
#line 947
          *(parser_state_tos->paren_indents + i) = (short )(- ((int )*(parser_state_tos->paren_indents + i) + target_col));
        }
#line 943
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 953
      output_substring(output, (char const   *)s_code, (char const   *)e_code);
#line 955
      *pcur_col = count_columns(*pcur_col, s_code, '\000');
#line 956
      clear_buf_break_list(pbreak_line);
      }
    }
  }
#line 959
  return;
}
}
#line 972 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/output.c"
extern void dump_line(int force_nl , int *paren_targ , BOOLEAN *pbreak_line ) 
{ 
  int cur_col ;
  int not_truncated ;
  int target_col_break ;
  int target ;
  char *com_st ;
  char *p ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
#line 978
  not_truncated = 1;
#line 979
  target_col_break = -1;
#line 981
  if (buf_break_used) {
#line 983
    buf_break_used = 0;
#line 984
    target_col_break = prev_target_col_break;
  } else
#line 986
  if (force_nl) {
#line 988
    parser_state_tos->broken_at_non_nl = 0;
  }
#line 992
  if (*(parser_state_tos->procname + 0)) {
#line 992
    if (! *(parser_state_tos->classname + 0)) {
#line 992
      if ((unsigned long )s_code_corresponds_to == (unsigned long )parser_state_tos->procname) {
#line 995
        parser_state_tos->procname = (char *)"\000";
      } else {
#line 992
        goto _L___0;
      }
    } else {
#line 992
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 997
  if (*(parser_state_tos->procname + 0)) {
#line 997
    if (*(parser_state_tos->classname + 0)) {
#line 997
      if ((unsigned long )s_code_corresponds_to == (unsigned long )parser_state_tos->classname) {
#line 1000
        parser_state_tos->procname = (char *)"\000";
#line 1001
        parser_state_tos->classname = (char *)"\000";
      }
    }
  }
#line 1006
  if ((unsigned long )s_code == (unsigned long )e_code) {
#line 1006
    if ((unsigned long )s_lab == (unsigned long )e_lab) {
#line 1006
      if ((unsigned long )s_com == (unsigned long )e_com) {
#line 1011
        if (parser_state_tos->use_ff) {
          {
#line 1013
          _IO_putc('\f', output);
#line 1014
          parser_state_tos->use_ff = 0;
          }
        } else {
#line 1018
          n_real_blanklines ++;
        }
      } else {
#line 1006
        goto _L___3;
      }
    } else {
#line 1006
      goto _L___3;
    }
  } else {
    _L___3: /* CIL Label */ 
#line 1023
    if (prefix_blankline_requested) {
#line 1023
      if (n_real_blanklines == 0) {
#line 1025
        if ((unsigned int )prefix_blankline_requested_code != 24U) {
#line 1028
          n_real_blanklines = 1;
        } else
#line 1025
        if (! parser_state_tos->decl_on_line) {
#line 1028
          n_real_blanklines = 1;
        }
      } else {
#line 1023
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 1031
    if (settings.swallow_optional_blanklines) {
#line 1031
      if (n_real_blanklines > 1) {
#line 1033
        n_real_blanklines = 1;
      }
    }
    {
#line 1036
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1036
      n_real_blanklines --;
#line 1036
      if (! (n_real_blanklines >= 0)) {
#line 1036
        goto while_break;
      }
      {
#line 1038
      _IO_putc('\n', output);
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 1041
    n_real_blanklines = 0;
#line 1043
    if ((unsigned long )e_lab != (unsigned long )s_lab) {
#line 1045
      code_lines ++;
    } else
#line 1043
    if ((unsigned long )e_code != (unsigned long )s_code) {
#line 1045
      code_lines ++;
    }
#line 1048
    if ((unsigned long )e_lab != (unsigned long )s_lab) {
      {
#line 1050
      cur_col = dump_line_label();
      }
    } else {
#line 1054
      cur_col = 1;
    }
#line 1057
    parser_state_tos->pcase = 0;
    {
#line 1060
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1060
      if ((int )*(e_code - 1) == 32) {
#line 1060
        if (! ((unsigned long )e_code > (unsigned long )s_code)) {
#line 1060
          goto while_break___0;
        }
      } else {
#line 1060
        goto while_break___0;
      }
#line 1062
      e_code --;
#line 1062
      *e_code = (char )'\000';
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1065
    dump_line_code(& cur_col, & not_truncated, *paren_targ, pbreak_line, target_col_break);
    }
#line 1068
    if ((unsigned long )s_com != (unsigned long )e_com) {
#line 1072
      target = parser_state_tos->com_col;
#line 1073
      com_st = s_com;
#line 1075
      if (cur_col > target) {
        {
#line 1077
        _IO_putc('\n', output);
#line 1078
        cur_col = 1;
#line 1079
        out_lines ++;
        }
      }
      {
#line 1082
      cur_col = pad_output(cur_col, target);
#line 1083
      fwrite((void const   */* __restrict  */)com_st, (size_t )(e_com - com_st), (size_t )1,
             (FILE */* __restrict  */)output);
#line 1084
      cur_col = (int )((long )cur_col + (e_com - com_st));
#line 1085
      com_lines ++;
      }
    } else
#line 1088
    if (embedded_comment_on_line) {
#line 1090
      com_lines ++;
    }
#line 1093
    embedded_comment_on_line = 0;
#line 1095
    if (parser_state_tos->use_ff) {
      {
#line 1097
      _IO_putc('\f', output);
#line 1098
      parser_state_tos->use_ff = 0;
      }
    } else {
      {
#line 1102
      _IO_putc('\n', output);
      }
    }
#line 1105
    out_lines ++;
#line 1107
    if (parser_state_tos->just_saw_decl == 1) {
#line 1107
      if (settings.blanklines_after_declarations) {
#line 1110
        prefix_blankline_requested = 1;
#line 1111
        prefix_blankline_requested_code = (codes_ty )24;
#line 1112
        parser_state_tos->just_saw_decl = 0;
      } else {
#line 1116
        prefix_blankline_requested = postfix_blankline_requested;
#line 1117
        prefix_blankline_requested_code = postfix_blankline_requested_code;
      }
    } else {
#line 1116
      prefix_blankline_requested = postfix_blankline_requested;
#line 1117
      prefix_blankline_requested_code = postfix_blankline_requested_code;
    }
#line 1119
    postfix_blankline_requested = 0;
  }
#line 1126
  parser_state_tos->decl_on_line = (int )parser_state_tos->in_decl;
#line 1130
  parser_state_tos->ind_stmt = parser_state_tos->in_stmt;
#line 1132
  e_lab = s_lab;
#line 1133
  *s_lab = (char )'\000';
#line 1135
  if (not_truncated) {
#line 1137
    e_code = s_code;
#line 1138
    *s_code = (char )'\000';
#line 1139
    s_code_corresponds_to = (char *)((void *)0);
  }
#line 1142
  e_com = s_com;
#line 1144
  *s_com = (char )'\000';
#line 1146
  parser_state_tos->ind_level = parser_state_tos->i_l_follow;
#line 1147
  parser_state_tos->paren_level = parser_state_tos->p_l_follow;
#line 1149
  if (parser_state_tos->paren_level > 0) {
#line 1156
    if (! not_truncated) {
#line 1156
      if ((int )*s_code == 40) {
#line 1156
        goto _L___4;
      } else
#line 1156
      if ((int )*s_code == 91) {
        _L___4: /* CIL Label */ 
#line 1156
        if (parser_state_tos->paren_level >= 2) {
#line 1159
          *paren_targ = - ((int )*(parser_state_tos->paren_indents + (parser_state_tos->paren_level - 2)));
        } else {
#line 1163
          *paren_targ = - ((int )*(parser_state_tos->paren_indents + (parser_state_tos->paren_level - 1)));
        }
      } else {
#line 1163
        *paren_targ = - ((int )*(parser_state_tos->paren_indents + (parser_state_tos->paren_level - 1)));
      }
    } else {
#line 1163
      *paren_targ = - ((int )*(parser_state_tos->paren_indents + (parser_state_tos->paren_level - 1)));
    }
  } else {
#line 1168
    *paren_targ = 0;
  }
#line 1171
  if (inhibited) {
#line 1173
    p = cur_line;
    {
#line 1175
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1175
      n_real_blanklines --;
#line 1175
      if (! (n_real_blanklines >= 0)) {
#line 1175
        goto while_break___1;
      }
      {
#line 1177
      _IO_putc('\n', output);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1180
    n_real_blanklines = 0;
    {
#line 1182
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 1184
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1184
        if ((int )*p != 0) {
#line 1184
          if (! ((int )*p != 10)) {
#line 1184
            goto while_break___3;
          }
        } else {
#line 1184
          goto while_break___3;
        }
        {
#line 1186
        tmp = p;
#line 1186
        p ++;
#line 1186
        _IO_putc((int )*tmp, output);
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 1189
      if ((int )*p == 0) {
#line 1189
        if ((unsigned long )(p - current_input->data) == current_input->size) {
#line 1192
          in_prog_pos = p;
#line 1193
          buf_end = p;
#line 1194
          buf_ptr = p;
#line 1195
          had_eof = (BOOLEAN )1;
#line 1196
          return;
        }
      }
#line 1199
      if ((int )*p == 10) {
#line 1201
        cur_line = p + 1;
#line 1202
        line_no ++;
      }
      {
#line 1205
      tmp___0 = p;
#line 1205
      p ++;
#line 1205
      _IO_putc((int )*tmp___0, output);
      }
      {
#line 1206
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1206
        if (! ((int )*p == 32)) {
#line 1206
          if (! ((int )*p == 9)) {
#line 1206
            goto while_break___4;
          }
        }
        {
#line 1208
        _IO_putc((int )*p, output);
#line 1209
        p ++;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
#line 1212
      if ((int )*p == 47) {
#line 1212
        if ((int )*(p + 1) == 42) {
#line 1212
          goto _L___6;
        } else
#line 1212
        if ((int )*(p + 1) == 47) {
          _L___6: /* CIL Label */ 
          {
#line 1217
          tmp___1 = p;
#line 1217
          p ++;
#line 1217
          _IO_putc((int )*tmp___1, output);
#line 1218
          tmp___2 = p;
#line 1218
          p ++;
#line 1218
          _IO_putc((int )*tmp___2, output);
          }
          {
#line 1220
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 1220
            if (! ((int )*p == 32)) {
#line 1220
              if (! ((int )*p == 9)) {
#line 1220
                goto while_break___5;
              }
            }
            {
#line 1222
            _IO_putc((int )*p, output);
#line 1223
            p ++;
            }
          }
          while_break___5: /* CIL Label */ ;
          }
          {
#line 1226
          tmp___5 = strncmp((char const   *)p, "*INDENT-ON*", (size_t )11);
          }
#line 1226
          if (! tmp___5) {
            {
#line 1228
            while (1) {
              while_continue___6: /* CIL Label */ ;
              {
#line 1230
              while (1) {
                while_continue___7: /* CIL Label */ ;
#line 1230
                if ((int )*p != 0) {
#line 1230
                  if (! ((int )*p != 10)) {
#line 1230
                    goto while_break___7;
                  }
                } else {
#line 1230
                  goto while_break___7;
                }
                {
#line 1232
                tmp___3 = p;
#line 1232
                p ++;
#line 1232
                _IO_putc((int )*tmp___3, output);
                }
              }
              while_break___7: /* CIL Label */ ;
              }
#line 1235
              if ((int )*p == 0) {
#line 1235
                if ((unsigned long )(p - current_input->data) == current_input->size) {
#line 1239
                  in_prog_pos = p;
#line 1240
                  buf_end = p;
#line 1241
                  buf_ptr = p;
#line 1242
                  had_eof = (BOOLEAN )1;
#line 1243
                  return;
                } else {
#line 1235
                  goto _L___5;
                }
              } else {
                _L___5: /* CIL Label */ 
#line 1247
                if ((int )*p == 10) {
#line 1249
                  inhibited = (BOOLEAN )0;
#line 1250
                  cur_line = p + 1;
#line 1251
                  line_no ++;
                }
                {
#line 1254
                tmp___4 = p;
#line 1254
                p ++;
#line 1254
                _IO_putc((int )*tmp___4, output);
                }
              }
#line 1228
              if (! inhibited) {
#line 1228
                goto while_break___6;
              }
            }
            while_break___6: /* CIL Label */ ;
            }
          }
        }
      }
#line 1182
      if (! inhibited) {
#line 1182
        goto while_break___2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 1261
    in_prog_pos = cur_line;
#line 1262
    buf_end = cur_line;
#line 1263
    buf_ptr = cur_line;
#line 1265
    fill_buffer();
    }
  }
#line 1269
  if (buf_break_used) {
#line 1269
    if ((unsigned long )s_code != (unsigned long )e_code) {
#line 1269
      if (force_nl) {
        {
#line 1271
        prefix_blankline_requested = 0;
#line 1272
        dump_line(1, paren_targ, pbreak_line);
        }
      }
    }
  }
#line 1275
  return;
}
}
#line 1287 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/output.c"
extern void flush_output(void) 
{ 


  {
  {
#line 1289
  fflush(output);
  }
#line 1290
  return;
}
}
#line 1301 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/output.c"
void open_output(char const   *filename , char const   *mode ) 
{ 
  char *tmp ;

  {
#line 1305
  if ((unsigned long )filename == (unsigned long )((void *)0)) {
#line 1307
    output = stdout;
  } else {
    {
#line 1311
    output = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)mode);
    }
#line 1313
    if ((unsigned long )output == (unsigned long )((void *)0)) {
      {
#line 1315
      tmp = gettext("indent: can\'t create %s\n");
#line 1315
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
              filename);
#line 1316
      exit(4);
      }
    }
  }
#line 1319
  return;
}
}
#line 1330 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/output.c"
extern void reopen_output_trunc(char const   *filename ) 
{ 


  {
  {
#line 1333
  output = freopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"w",
                   (FILE */* __restrict  */)output);
  }
#line 1335
  return;
}
}
#line 1346 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/output.c"
extern void close_output(struct stat *file_stats , char const   *filename ) 
{ 
  char *tmp ;
  struct utimbuf buf ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1350
  if ((unsigned long )output != (unsigned long )stdout) {
    {
#line 1352
    tmp___3 = fclose(output);
    }
#line 1352
    if (tmp___3 != 0) {
      {
#line 1354
      tmp = gettext("Can\'t close output file %s");
#line 1354
      fatal((char const   *)tmp, filename);
      }
    } else
#line 1359
    if ((unsigned long )file_stats != (unsigned long )((void *)0)) {
      {
#line 1363
      buf.actime = time((time_t *)((void *)0));
#line 1364
      buf.modtime = file_stats->st_mtim.tv_sec;
#line 1365
      tmp___2 = utime(filename, (struct utimbuf  const  *)(& buf));
      }
#line 1365
      if (tmp___2 != 0) {
        {
#line 1367
        tmp___0 = gettext("Can\'t preserve modification time on output file %s");
#line 1367
        tmp___1 = gettext("Warning");
#line 1367
        message(tmp___1, tmp___0, (unsigned int *)filename, (unsigned int *)0);
        }
      }
    }
  }
#line 1374
  return;
}
}
#line 1380 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/output.c"
extern void inhibit_indenting(BOOLEAN flag ) 
{ 


  {
#line 1383
  inhibited = flag;
#line 1384
  return;
}
}
#line 1390 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/output.c"
int compute_code_target(int paren_targ ) 
{ 
  int target_col ;

  {
#line 1395
  if (buf_break_used) {
#line 1397
    return (prev_target_col_break);
  }
#line 1400
  if (*(parser_state_tos->procname + 0)) {
#line 1400
    if ((unsigned long )s_code_corresponds_to == (unsigned long )parser_state_tos->procname) {
#line 1403
      target_col = 1;
#line 1405
      if (! parser_state_tos->paren_level) {
#line 1407
        return (target_col);
      }
    } else {
#line 1412
      target_col = parser_state_tos->ind_level + 1;
    }
  } else {
#line 1412
    target_col = parser_state_tos->ind_level + 1;
  }
#line 1415
  if (! parser_state_tos->paren_level) {
#line 1417
    if (parser_state_tos->ind_stmt) {
#line 1419
      target_col += settings.continuation_indent;
    }
#line 1422
    return (target_col);
  }
#line 1425
  if (! settings.lineup_to_parens) {
#line 1427
    return ((target_col + settings.continuation_indent) + settings.paren_indent * (parser_state_tos->paren_level - 1));
  }
#line 1431
  return (paren_targ);
}
}
#line 1438 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/output.c"
int count_columns(int column , char *bp , int stop_char ) 
{ 
  char *tmp ;

  {
  {
#line 1443
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1443
    if ((int )*bp != stop_char) {
#line 1443
      if (! ((int )*bp != 0)) {
#line 1443
        goto while_break;
      }
    } else {
#line 1443
      goto while_break;
    }
#line 1445
    tmp = bp;
#line 1445
    bp ++;
    {
#line 1448
    if ((int )*tmp == 12) {
#line 1448
      goto case_12;
    }
#line 1448
    if ((int )*tmp == 10) {
#line 1448
      goto case_12;
    }
#line 1451
    if ((int )*tmp == 9) {
#line 1451
      goto case_9;
    }
#line 1454
    if ((int )*tmp == 8) {
#line 1454
      goto case_8;
    }
#line 1465
    goto switch_default;
    case_12: /* CIL Label */ 
    case_10: /* CIL Label */ 
#line 1449
    column = 1;
#line 1450
    goto switch_break;
    case_9: /* CIL Label */ 
#line 1452
    column += settings.tabsize - (column - 1) % settings.tabsize;
#line 1453
    goto switch_break;
    case_8: /* CIL Label */ 
#line 1455
    column --;
#line 1456
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1466
    column ++;
#line 1467
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1471
  return (column);
}
}
#line 1478 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/output.c"
int compute_label_target(void) 
{ 


  {
#line 1483
  if ((int )*s_lab == 35) {
#line 1485
    return (1);
  }
#line 1488
  if (parser_state_tos->pcase) {
#line 1490
    return (*(parser_state_tos->cstk + parser_state_tos->tos) + 1);
  }
#line 1493
  if (settings.c_plus_plus) {
#line 1493
    if (parser_state_tos->in_decl) {
#line 1496
      return (1);
    } else {
#line 1493
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1498
  if (settings.label_offset < 0) {
#line 1500
    return ((parser_state_tos->ind_level + settings.label_offset) + 1);
  } else {
#line 1504
    return (settings.label_offset + 1);
  }
}
}
#line 1512 "/home/june/repo/benchmarks/collector/temp/indent-2.2.11/src/output.c"
int output_line_length(void) 
{ 
  int code_length ;
  int com_length ;
  int length ;
  int tmp ;
  int tmp___0 ;
  int code_col ;
  int tmp___1 ;
  int tmp___2 ;
  int com_col ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 1514
  code_length = 0;
#line 1515
  com_length = 0;
#line 1518
  if ((unsigned long )s_lab == (unsigned long )e_lab) {
#line 1520
    length = 0;
  } else {
    {
#line 1524
    tmp = compute_label_target();
#line 1524
    tmp___0 = count_columns(tmp, s_lab, '\n');
#line 1524
    length = tmp___0 - 1;
    }
  }
#line 1527
  if ((unsigned long )s_code != (unsigned long )e_code) {
    {
#line 1529
    tmp___1 = compute_code_target(paren_target);
#line 1529
    code_col = tmp___1;
#line 1531
    tmp___2 = count_columns(code_col, s_code, '\n');
#line 1531
    code_length = tmp___2 - code_col;
    }
  }
#line 1534
  if ((unsigned long )s_com != (unsigned long )e_com) {
    {
#line 1536
    com_col = parser_state_tos->com_col;
#line 1538
    tmp___3 = count_columns(com_col, s_com, '\n');
#line 1538
    com_length = tmp___3 - com_col;
    }
  }
#line 1541
  if (code_length != 0) {
    {
#line 1543
    tmp___4 = compute_code_target(paren_target);
#line 1543
    length += (tmp___4 - 1) + code_length;
    }
#line 1545
    if (embedded_comment_on_line) {
#line 1547
      length += com_length;
    }
  }
#line 1551
  return (length);
}
}
