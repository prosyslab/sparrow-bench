/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 32 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __u_int;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 35 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_int u_int;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 200 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned char u_int8_t;
#line 202 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned int u_int32_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 39 "/usr/include/linux/hdlc/ioctl.h"
struct __anonstruct_sync_serial_settings_75 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
};
#line 39 "/usr/include/linux/hdlc/ioctl.h"
typedef struct __anonstruct_sync_serial_settings_75 sync_serial_settings;
#line 45 "/usr/include/linux/hdlc/ioctl.h"
struct __anonstruct_te1_settings_76 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
   unsigned int slot_map ;
};
#line 45 "/usr/include/linux/hdlc/ioctl.h"
typedef struct __anonstruct_te1_settings_76 te1_settings;
#line 52 "/usr/include/linux/hdlc/ioctl.h"
struct __anonstruct_raw_hdlc_proto_77 {
   unsigned short encoding ;
   unsigned short parity ;
};
#line 52 "/usr/include/linux/hdlc/ioctl.h"
typedef struct __anonstruct_raw_hdlc_proto_77 raw_hdlc_proto;
#line 57 "/usr/include/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_78 {
   unsigned int t391 ;
   unsigned int t392 ;
   unsigned int n391 ;
   unsigned int n392 ;
   unsigned int n393 ;
   unsigned short lmi ;
   unsigned short dce ;
};
#line 57 "/usr/include/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_78 fr_proto;
#line 67 "/usr/include/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_79 {
   unsigned int dlci ;
};
#line 67 "/usr/include/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_79 fr_proto_pvc;
#line 71 "/usr/include/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_info_80 {
   unsigned int dlci ;
   char master[16] ;
};
#line 71 "/usr/include/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_info_80 fr_proto_pvc_info;
#line 76 "/usr/include/linux/hdlc/ioctl.h"
struct __anonstruct_cisco_proto_81 {
   unsigned int interval ;
   unsigned int timeout ;
};
#line 76 "/usr/include/linux/hdlc/ioctl.h"
typedef struct __anonstruct_cisco_proto_81 cisco_proto;
#line 143 "/usr/include/linux/if.h"
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};
#line 153 "/usr/include/linux/if.h"
union __anonunion_ifs_ifsu_84 {
   raw_hdlc_proto *raw_hdlc ;
   cisco_proto *cisco ;
   fr_proto *fr ;
   fr_proto_pvc *fr_pvc ;
   fr_proto_pvc_info *fr_pvc_info ;
   sync_serial_settings *sync ;
   te1_settings *te1 ;
};
#line 153 "/usr/include/linux/if.h"
struct if_settings {
   unsigned int type ;
   unsigned int size ;
   union __anonunion_ifs_ifsu_84 ifs_ifsu ;
};
#line 177 "/usr/include/linux/if.h"
union __anonunion_ifr_ifrn_85 {
   char ifrn_name[16] ;
};
#line 177 "/usr/include/linux/if.h"
union __anonunion_ifr_ifru_86 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16] ;
   char ifru_newname[16] ;
   void *ifru_data ;
   struct if_settings ifru_settings ;
};
#line 177 "/usr/include/linux/if.h"
struct ifreq {
   union __anonunion_ifr_ifrn_85 ifr_ifrn ;
   union __anonunion_ifr_ifru_86 ifr_ifru ;
};
#line 105 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.h"
struct tuntap_dev {
   int fd ;
   u_int8_t mac_addr[6] ;
   u_int32_t ip_addr ;
   u_int32_t device_mask ;
   u_int mtu ;
};
#line 105 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.h"
typedef struct tuntap_dev tuntap_dev;
#line 172 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.h"
typedef char macstr_t[32];
#line 131 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/lzoconf.h"
typedef unsigned long lzo_uint;
#line 144 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/lzoconf.h"
typedef unsigned int lzo_uint32;
#line 195 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/lzoconf.h"
typedef int lzo_bool;
#line 267
struct lzo_callback_t;
#line 268 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/lzoconf.h"
typedef struct lzo_callback_t lzo_callback_t;
#line 281 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/lzoconf.h"
struct lzo_callback_t {
   void *(*nalloc)(lzo_callback_t *self , lzo_uint items , lzo_uint size ) ;
   void (*nfree)(lzo_callback_t *self , void *ptr ) ;
   void (*nprogress)(lzo_callback_t * , lzo_uint  , lzo_uint  , int  ) ;
   void *user1 ;
   lzo_uint user2 ;
   lzo_uint user3 ;
};
#line 2447 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/minilzo.c"
union __anonunion_u_5 {
   unsigned char c[2UL * sizeof(lzo_uint )] ;
   lzo_uint l[2] ;
};
#line 30 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __u_char;
#line 31 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __u_short;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 33 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_char u_char;
#line 34 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_short u_short;
#line 201 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned short u_int16_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 33 "/usr/include/x86_64-linux-gnu/bits/socket.h"
typedef __socklen_t socklen_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 136 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.h"
enum packet_type {
    packet_unreliable_data = 0,
    packet_reliable_data = 1,
    packet_ping = 2,
    packet_pong = 3
} ;
#line 144 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.h"
union __anonunion_addr_type_94 {
   u_int8_t v6_addr[16] ;
   u_int32_t v4_addr ;
};
#line 144 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.h"
struct peer_addr {
   u_int8_t family ;
   u_int16_t port ;
   union __anonunion_addr_type_94 addr_type ;
};
#line 153 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.h"
struct n2n_packet_header {
   u_int8_t version ;
   u_int8_t msg_type ;
   u_int8_t ttl ;
   u_int8_t sent_by_supernode ;
   char community_name[16] ;
   char src_mac[6] ;
   char dst_mac[6] ;
   struct peer_addr public_ip ;
   struct peer_addr private_ip ;
   enum packet_type pkt_type ;
   u_int32_t sequence_id ;
   u_int32_t crc ;
};
#line 169 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.h"
typedef char ipstr_t[32];
#line 174 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.h"
struct n2n_sock_info {
   int sock ;
   char is_udp_socket ;
};
#line 180 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.h"
typedef struct n2n_sock_info n2n_sock_info_t;
#line 182 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.h"
struct peer_info {
   char community_name[16] ;
   char mac_addr[6] ;
   struct peer_addr public_ip ;
   struct peer_addr private_ip ;
   time_t last_seen ;
   struct peer_info *next ;
   n2n_sock_info_t sinfo ;
};
#line 364 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/lzoconf.h"
union __anonunion_lzo_align_t_97 {
   void *vp ;
   unsigned char *bp ;
   lzo_uint32 u32 ;
   long l ;
};
#line 364 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/lzoconf.h"
typedef union __anonunion_lzo_align_t_97 lzo_align_t;
#line 100 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/twofish.h"
struct __anonstruct_header_24 {
   u_int32_t salt ;
   u_int8_t length[4] ;
   u_int8_t magic[8] ;
};
#line 100 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/twofish.h"
struct __anonstruct_TWOFISH_23 {
   u_int32_t sBox[1024] ;
   u_int32_t subKeys[40] ;
   u_int8_t key[32] ;
   u_int8_t *output ;
   u_int8_t qBlockPlain[16] ;
   u_int8_t qBlockCrypt[16] ;
   u_int8_t prevCipher[16] ;
   struct __anonstruct_header_24 header ;
   int qBlockDefined ;
   int dontflush ;
};
#line 100 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/twofish.h"
typedef struct __anonstruct_TWOFISH_23 TWOFISH;
#line 2447 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/minilzo.c"
union __anonunion_u_5___0 {
   unsigned char c[2UL * sizeof(lzo_uint )] ;
   lzo_uint l[2] ;
};
#line 717 "/usr/include/stdlib.h"
extern int system(char const   *__command ) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 846
extern void perror(char const   *__s ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 34 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) in_addr_t ( __attribute__((__leaf__)) inet_addr)(char const   *__cp ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 244 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.h"
void traceEvent(int eventTraceLevel , char *file , int line , char *format  , ...) ;
#line 245
int tuntap_open(tuntap_dev *device , char *dev , char *device_ip , char *device_mask ,
                char const   *device_mac , int mtu ) ;
#line 247
int tuntap_read(struct tuntap_dev *tuntap , unsigned char *buf , int len ) ;
#line 248
int tuntap_write(struct tuntap_dev *tuntap , unsigned char *buf , int len ) ;
#line 249
void tuntap_close(struct tuntap_dev *tuntap ) ;
#line 259
char *macaddr_str(char const   *mac , char *buf , int buf_len ) ;
#line 22 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/tuntap_linux.c"
static void read_mac(char *ifname , char *mac_addr ) 
{ 
  int _sock ;
  int res ;
  struct ifreq ifr ;
  macstr_t mac_addr_buf ;
  char *tmp ;

  {
  {
#line 27
  memset((void *)(& ifr), 0, sizeof(struct ifreq ));
#line 30
  _sock = socket(2, 2, 0);
#line 31
  strcpy((char */* __restrict  */)(ifr.ifr_ifrn.ifrn_name), (char const   */* __restrict  */)ifname);
#line 32
  res = ioctl(_sock, 35111UL, & ifr);
  }
#line 33
  if (res < 0) {
    {
#line 34
    perror("Get hw addr");
    }
  } else {
    {
#line 36
    memcpy((void */* __restrict  */)mac_addr, (void const   */* __restrict  */)(ifr.ifr_ifru.ifru_hwaddr.sa_data),
           (size_t )6);
    }
  }
  {
#line 38
  tmp = macaddr_str((char const   *)mac_addr, mac_addr_buf, (int )sizeof(mac_addr_buf));
#line 38
  traceEvent(2, (char *)"/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/tuntap_linux.c",
             38, (char *)"Interface %s has MAC %s", ifname, tmp);
#line 41
  close(_sock);
  }
#line 42
  return;
}
}
#line 61 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/tuntap_linux.c"
int tuntap_open(tuntap_dev *device , char *dev , char *device_ip , char *device_mask ,
                char const   *device_mac , int mtu ) 
{ 
  char *tuntap_device ;
  char buf[128] ;
  struct ifreq ifr ;
  int rc ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 67
  tuntap_device = (char *)"/dev/net/tun";
#line 73
  device->fd = open((char const   *)tuntap_device, 2);
  }
#line 74
  if (device->fd < 0) {
    {
#line 75
    tmp = __errno_location();
#line 75
    tmp___0 = __errno_location();
#line 75
    tmp___1 = strerror(*tmp___0);
#line 75
    printf((char const   */* __restrict  */)"ERROR: ioctl() [%s][%d]\n", tmp___1,
           *tmp);
    }
#line 76
    return (-1);
  }
  {
#line 79
  memset((void *)(& ifr), 0, sizeof(ifr));
#line 80
  ifr.ifr_ifru.ifru_flags = (short)4098;
#line 81
  strncpy((char */* __restrict  */)(ifr.ifr_ifrn.ifrn_name), (char const   */* __restrict  */)dev,
          (size_t )16);
#line 82
  rc = ioctl(device->fd, (unsigned long )(((1U << 30) | (unsigned int )(84 << 8)) | 202U) | (sizeof(int ) << 16),
             (void *)(& ifr));
  }
#line 84
  if (rc < 0) {
    {
#line 85
    tmp___2 = __errno_location();
#line 85
    tmp___3 = strerror(*tmp___2);
#line 85
    traceEvent(0, (char *)"/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/tuntap_linux.c",
               85, (char *)"ioctl() [%s][%d]\n", tmp___3, rc);
#line 86
    close(device->fd);
    }
#line 87
    return (-1);
  }
#line 90
  if (device_mac) {
    {
#line 93
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"/sbin/ifconfig %s hw ether %s",
             ifr.ifr_ifrn.ifrn_name, device_mac);
#line 95
    system((char const   *)(buf));
#line 96
    traceEvent(3, (char *)"/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/tuntap_linux.c",
               96, (char *)"Setting MAC: %s", buf);
    }
  }
  {
#line 99
  snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"/sbin/ifconfig %s %s netmask %s mtu %d up",
           ifr.ifr_ifrn.ifrn_name, device_ip, device_mask, mtu);
#line 101
  system((char const   *)(buf));
#line 102
  traceEvent(3, (char *)"/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/tuntap_linux.c",
             102, (char *)"Bringing up: %s", buf);
#line 104
  device->ip_addr = inet_addr((char const   *)device_ip);
#line 105
  device->device_mask = inet_addr((char const   *)device_mask);
#line 106
  read_mac(dev, (char *)(device->mac_addr));
  }
#line 107
  return (device->fd);
}
}
#line 110 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/tuntap_linux.c"
int tuntap_read(struct tuntap_dev *tuntap , unsigned char *buf , int len ) 
{ 
  ssize_t tmp ;

  {
  {
#line 111
  tmp = read(tuntap->fd, (void *)buf, (size_t )len);
  }
#line 111
  return ((int )tmp);
}
}
#line 114 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/tuntap_linux.c"
int tuntap_write(struct tuntap_dev *tuntap , unsigned char *buf , int len ) 
{ 
  ssize_t tmp ;

  {
  {
#line 115
  tmp = write(tuntap->fd, (void const   *)buf, (size_t )len);
  }
#line 115
  return ((int )tmp);
}
}
#line 118 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/tuntap_linux.c"
void tuntap_close(struct tuntap_dev *tuntap ) 
{ 


  {
  {
#line 119
  close(tuntap->fd);
  }
#line 120
  return;
}
}
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
#line 333 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/lzoconf.h"
int __lzo_init_v2(unsigned int v , int s1 , int s2 , int s3 , int s4 , int s5 , int s6 ,
                  int s7 , int s8 , int s9 ) ;
#line 336
unsigned int lzo_version(void) ;
#line 337
char const   *lzo_version_string(void) ;
#line 338
char const   *lzo_version_date(void) ;
#line 339
char const   *_lzo_version_string(void) ;
#line 340
char const   *_lzo_version_date(void) ;
#line 343
int lzo_memcmp(void const   *s1 , void const   *s2 , lzo_uint len ) ;
#line 345
void *lzo_memcpy(void *dest , void const   *src , lzo_uint len ) ;
#line 347
void *lzo_memmove(void *dest , void const   *src , lzo_uint len ) ;
#line 349
void *lzo_memset(void *s , int c , lzo_uint len ) ;
#line 353
lzo_uint32 lzo_adler32(lzo_uint32 adler , unsigned char const   *buf , lzo_uint len ) ;
#line 361
int _lzo_config_check(void) ;
#line 367
unsigned int __lzo_align_gap(void const   *ptr , lzo_uint size ) ;
#line 83 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/minilzo.h"
int lzo1x_1_compress(unsigned char const   *in , lzo_uint in_len , unsigned char *out ,
                     lzo_uint *out_len , void *wrkmem___1 ) ;
#line 89
int lzo1x_decompress(unsigned char const   *in , lzo_uint in_len , unsigned char *out ,
                     lzo_uint *out_len , void *wrkmem___1 ) ;
#line 95
int lzo1x_decompress_safe(unsigned char const   *in , lzo_uint in_len , unsigned char *out ,
                          lzo_uint *out_len , void *wrkmem___1 ) ;
#line 50 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 2082 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/minilzo.c"
int __lzo_init_done ;
#line 2083
char const   __lzo_copyright[5] ;
#line 2084
unsigned char const   *lzo_copyright(void) ;
#line 2126
size_t __lzo_ptr_linear(void const   *ptr ) ;
#line 2183 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/minilzo.c"
size_t __lzo_ptr_linear(void const   *ptr ) 
{ 
  size_t p ;

  {
#line 2194
  p = (size_t )ptr;
#line 2197
  return (p);
}
}
#line 2200 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/minilzo.c"
unsigned int __lzo_align_gap(void const   *ptr , lzo_uint size ) 
{ 
  size_t p ;
  size_t n ;

  {
  {
#line 2208
  p = __lzo_ptr_linear(ptr);
#line 2209
  n = (((p + size) - 1UL) / size) * size - p;
  }
#line 2215
  return ((unsigned int )n);
}
}
#line 2224 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/minilzo.c"
char const   __lzo_copyright[5]  = {      (char const   )'2',      (char const   )'.',      (char const   )'0',      (char const   )'3', 
        (char const   )'\000'};
#line 2238 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/minilzo.c"
unsigned char const   *lzo_copyright(void) 
{ 


  {
#line 2244
  return ((unsigned char const   *)(__lzo_copyright));
}
}
#line 2248 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/minilzo.c"
unsigned int lzo_version(void) 
{ 


  {
#line 2251
  return (8240U);
}
}
#line 2254 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/minilzo.c"
char const   *lzo_version_string(void) 
{ 


  {
#line 2257
  return ("2.03");
}
}
#line 2260 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/minilzo.c"
char const   *lzo_version_date(void) 
{ 


  {
#line 2263
  return ("Apr 30 2008");
}
}
#line 2266 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/minilzo.c"
char const   *_lzo_version_string(void) 
{ 


  {
#line 2269
  return ("2.03");
}
}
#line 2272 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/minilzo.c"
char const   *_lzo_version_date(void) 
{ 


  {
#line 2275
  return ("Apr 30 2008");
}
}
#line 2287 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/minilzo.c"
lzo_uint32 lzo_adler32(lzo_uint32 adler , unsigned char const   *buf , lzo_uint len ) 
{ 
  lzo_uint32 s1 ;
  lzo_uint32 s2 ;
  unsigned int k ;
  unsigned char const   *tmp ;

  {
#line 2290
  s1 = adler & 65535U;
#line 2291
  s2 = (adler >> 16) & 65535U;
#line 2294
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 2295
    return ((lzo_uint32 )1);
  }
  {
#line 2297
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2297
    if (! (len > 0UL)) {
#line 2297
      goto while_break;
    }
#line 2299
    if (len < 5552UL) {
#line 2299
      k = (unsigned int )len;
    } else {
#line 2299
      k = 5552U;
    }
#line 2300
    len -= (lzo_uint )k;
#line 2301
    if (k >= 16U) {
      {
#line 2301
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2303
        s1 += (lzo_uint32 )*(buf + 0);
#line 2303
        s2 += s1;
#line 2303
        s1 += (lzo_uint32 )*(buf + 1);
#line 2303
        s2 += s1;
#line 2303
        s1 += (lzo_uint32 )*(buf + 2);
#line 2303
        s2 += s1;
#line 2303
        s1 += (lzo_uint32 )*(buf + 3);
#line 2303
        s2 += s1;
#line 2303
        s1 += (lzo_uint32 )*(buf + 4);
#line 2303
        s2 += s1;
#line 2303
        s1 += (lzo_uint32 )*(buf + 5);
#line 2303
        s2 += s1;
#line 2303
        s1 += (lzo_uint32 )*(buf + 6);
#line 2303
        s2 += s1;
#line 2303
        s1 += (lzo_uint32 )*(buf + 7);
#line 2303
        s2 += s1;
#line 2303
        s1 += (lzo_uint32 )*(buf + 8);
#line 2303
        s2 += s1;
#line 2303
        s1 += (lzo_uint32 )*(buf + 9);
#line 2303
        s2 += s1;
#line 2303
        s1 += (lzo_uint32 )*(buf + 10);
#line 2303
        s2 += s1;
#line 2303
        s1 += (lzo_uint32 )*(buf + 11);
#line 2303
        s2 += s1;
#line 2303
        s1 += (lzo_uint32 )*(buf + 12);
#line 2303
        s2 += s1;
#line 2303
        s1 += (lzo_uint32 )*(buf + 13);
#line 2303
        s2 += s1;
#line 2303
        s1 += (lzo_uint32 )*(buf + 14);
#line 2303
        s2 += s1;
#line 2303
        s1 += (lzo_uint32 )*(buf + 15);
#line 2303
        s2 += s1;
#line 2304
        buf += 16;
#line 2305
        k -= 16U;
#line 2301
        if (! (k >= 16U)) {
#line 2301
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 2307
    if (k != 0U) {
      {
#line 2307
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2309
        tmp = buf;
#line 2309
        buf ++;
#line 2309
        s1 += (lzo_uint32 )*tmp;
#line 2310
        s2 += s1;
#line 2307
        k --;
#line 2307
        if (! (k > 0U)) {
#line 2307
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 2312
    s1 %= 65521U;
#line 2313
    s2 %= 65521U;
  }
  while_break: /* CIL Label */ ;
  }
#line 2315
  return ((s2 << 16) | s1);
}
}
#line 2344 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/minilzo.c"
int lzo_memcmp(void const   *s1 , void const   *s2 , lzo_uint len ) 
{ 
  int tmp ;

  {
  {
#line 2358
  tmp = memcmp(s1, s2, len);
  }
#line 2358
  return (tmp);
}
}
#line 2361 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/minilzo.c"
void *lzo_memcpy(void *dest , void const   *src , lzo_uint len ) 
{ 
  void *tmp ;

  {
  {
#line 2373
  tmp = memcpy((void */* __restrict  */)dest, (void const   */* __restrict  */)src,
               len);
  }
#line 2373
  return (tmp);
}
}
#line 2376 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/minilzo.c"
void *lzo_memmove(void *dest , void const   *src , lzo_uint len ) 
{ 
  void *tmp ;

  {
  {
#line 2399
  tmp = memmove(dest, src, len);
  }
#line 2399
  return (tmp);
}
}
#line 2402 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/minilzo.c"
void *lzo_memset(void *s , int c , lzo_uint len ) 
{ 
  void *tmp ;

  {
  {
#line 2411
  tmp = memset(s, c, len);
  }
#line 2411
  return (tmp);
}
}
#line 2443 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/minilzo.c"
int _lzo_config_check(void) 
{ 
  lzo_bool r ;
  union __anonunion_u_5 u ;
  size_t p ;
  int tmp ;

  {
#line 2446
  r = 1;
#line 2456
  u.l[1] = (lzo_uint )0;
#line 2456
  u.l[0] = u.l[1];
#line 2456
  u.c[0] = (unsigned char)128;
#line 2457
  r &= u.l[0] == 128UL;
#line 2460
  p = (size_t )((void const   *)(& u.c[0]));
#line 2461
  u.l[1] = (lzo_uint )0;
#line 2461
  u.l[0] = u.l[1];
#line 2462
  r &= (int const   )*((unsigned short const   *)(p + 1UL)) == 0;
#line 2465
  p = (size_t )((void const   *)(& u.c[0]));
#line 2466
  u.l[1] = (lzo_uint )0;
#line 2466
  u.l[0] = u.l[1];
#line 2467
  r &= *((lzo_uint32 const   *)(p + 1UL)) == 0U;
#line 2472
  if (r == 1) {
#line 2472
    tmp = 0;
  } else {
#line 2472
    tmp = -1;
  }
#line 2472
  return (tmp);
}
}
#line 2475 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/minilzo.c"
int __lzo_init_done  =    0;
#line 2477 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/minilzo.c"
int __lzo_init_v2(unsigned int v , int s1 , int s2 , int s3 , int s4 , int s5 , int s6 ,
                  int s7 , int s8 , int s9 ) 
{ 
  int r ;
  int tmp ;

  {
#line 2492
  __lzo_init_done = 1;
#line 2494
  if (v == 0U) {
#line 2495
    return (-1);
  }
#line 2497
  if (s1 == -1) {
#line 2497
    goto _L___6;
  } else
#line 2497
  if (s1 == (int )sizeof(short )) {
    _L___6: /* CIL Label */ 
#line 2497
    if (s2 == -1) {
#line 2497
      goto _L___5;
    } else
#line 2497
    if (s2 == (int )sizeof(int )) {
      _L___5: /* CIL Label */ 
#line 2497
      if (s3 == -1) {
#line 2497
        goto _L___4;
      } else
#line 2497
      if (s3 == (int )sizeof(long )) {
        _L___4: /* CIL Label */ 
#line 2497
        if (s4 == -1) {
#line 2497
          goto _L___3;
        } else
#line 2497
        if (s4 == (int )sizeof(lzo_uint32 )) {
          _L___3: /* CIL Label */ 
#line 2497
          if (s5 == -1) {
#line 2497
            goto _L___2;
          } else
#line 2497
          if (s5 == (int )sizeof(lzo_uint )) {
            _L___2: /* CIL Label */ 
#line 2497
            if (s6 == -1) {
#line 2497
              goto _L___1;
            } else
#line 2497
            if (s6 == (int )((unsigned int )sizeof(unsigned char *))) {
              _L___1: /* CIL Label */ 
#line 2497
              if (s7 == -1) {
#line 2497
                goto _L___0;
              } else
#line 2497
              if (s7 == (int )sizeof(char *)) {
                _L___0: /* CIL Label */ 
#line 2497
                if (s8 == -1) {
#line 2497
                  goto _L;
                } else
#line 2497
                if (s8 == (int )sizeof(void *)) {
                  _L: /* CIL Label */ 
#line 2497
                  if (s9 == -1) {
#line 2497
                    tmp = 1;
                  } else
#line 2497
                  if (s9 == (int )sizeof(lzo_callback_t )) {
#line 2497
                    tmp = 1;
                  } else {
#line 2497
                    tmp = 0;
                  }
                } else {
#line 2497
                  tmp = 0;
                }
              } else {
#line 2497
                tmp = 0;
              }
            } else {
#line 2497
              tmp = 0;
            }
          } else {
#line 2497
            tmp = 0;
          }
        } else {
#line 2497
          tmp = 0;
        }
      } else {
#line 2497
        tmp = 0;
      }
    } else {
#line 2497
      tmp = 0;
    }
  } else {
#line 2497
    tmp = 0;
  }
#line 2497
  r = tmp;
#line 2506
  if (! r) {
#line 2507
    return (-1);
  }
  {
#line 2509
  r = _lzo_config_check();
  }
#line 2510
  if (r != 0) {
#line 2511
    return (r);
  }
#line 2513
  return (r);
}
}
#line 2822 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/minilzo.c"
static lzo_uint ( __attribute__((__noinline__)) _lzo1x_1_do_compress)(unsigned char const   *in ,
                                                                      lzo_uint in_len ,
                                                                      unsigned char *out ,
                                                                      lzo_uint *out_len ,
                                                                      void *wrkmem___1 ) 
{ 
  register unsigned char const   *ip ;
  unsigned char *op ;
  unsigned char const   *in_end ;
  unsigned char const   *ip_end ;
  unsigned char const   *ii ;
  unsigned char const   **dict ;
  register unsigned char const   *m_pos ;
  lzo_uint m_off ;
  lzo_uint m_len ;
  lzo_uint dindex ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  register lzo_uint t ;
  unsigned char *tmp___3 ;
  register lzo_uint tt ;
  unsigned char *tmp___4 ;
  unsigned char *tmp___5 ;
  unsigned char *tmp___6 ;
  unsigned char *tmp___7 ;
  unsigned char const   *tmp___8 ;
  unsigned char *tmp___9 ;
  unsigned char *tmp___10 ;
  unsigned char *tmp___11 ;
  unsigned char *tmp___12 ;
  unsigned char const   *end ;
  unsigned char const   *m ;
  unsigned char *tmp___13 ;
  unsigned char *tmp___14 ;
  unsigned char *tmp___15 ;
  unsigned char *tmp___16 ;
  unsigned char *tmp___17 ;
  unsigned char *tmp___18 ;
  unsigned char *tmp___19 ;
  unsigned char *tmp___20 ;
  unsigned char const   *tmp___21 ;
  unsigned char const   *tmp___22 ;
  unsigned char const   *tmp___23 ;
  unsigned char const   *tmp___24 ;
  unsigned char const   *tmp___25 ;
  unsigned char const   *tmp___26 ;
  long tmp___27 ;

  {
#line 2829
  in_end = in + in_len;
#line 2830
  ip_end = ((in + in_len) - 8) - 5;
#line 2832
  dict = (unsigned char const   **)wrkmem___1;
#line 2834
  op = out;
#line 2835
  ip = in;
#line 2836
  ii = ip;
#line 2838
  ip += 4;
  {
#line 2839
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2846
    dindex = (33UL * (((((((lzo_uint )*((ip + 1) + 2) << 6) ^ (unsigned long )*((ip + 1) + 1)) << 5) ^ (unsigned long )*((ip + 1) + 0)) << 5) ^ (unsigned long )*(ip + 0)) >> 5) & (unsigned long )((1U << 14) - 1U);
#line 2847
    m_pos = *(dict + dindex);
#line 2848
    m_pos = ip - ((size_t )ip - (size_t )m_pos);
#line 2848
    if ((size_t )m_pos < (size_t )in) {
#line 2848
      tmp = 1;
    } else {
#line 2848
      m_off = (size_t )ip - (size_t )m_pos;
#line 2848
      if (m_off <= 0UL) {
#line 2848
        tmp = 1;
      } else
#line 2848
      if (m_off > 49151UL) {
#line 2848
        tmp = 1;
      } else {
#line 2848
        tmp = 0;
      }
    }
#line 2848
    if (tmp) {
#line 2849
      goto literal;
    }
#line 2851
    if (m_off <= 2048UL) {
#line 2852
      goto try_match;
    } else
#line 2851
    if ((int const   )*(m_pos + 3) == (int const   )*(ip + 3)) {
#line 2852
      goto try_match;
    }
#line 2853
    dindex = (dindex & (unsigned long )(((1U << 14) - 1U) & 2047U)) ^ (unsigned long )(((((1U << 14) - 1U) >> 1) + 1U) | 31U);
#line 2855
    m_pos = *(dict + dindex);
#line 2856
    m_pos = ip - ((size_t )ip - (size_t )m_pos);
#line 2856
    if ((size_t )m_pos < (size_t )in) {
#line 2856
      tmp___0 = 1;
    } else {
#line 2856
      m_off = (size_t )ip - (size_t )m_pos;
#line 2856
      if (m_off <= 0UL) {
#line 2856
        tmp___0 = 1;
      } else
#line 2856
      if (m_off > 49151UL) {
#line 2856
        tmp___0 = 1;
      } else {
#line 2856
        tmp___0 = 0;
      }
    }
#line 2856
    if (tmp___0) {
#line 2857
      goto literal;
    }
#line 2858
    if (m_off <= 2048UL) {
#line 2859
      goto try_match;
    } else
#line 2858
    if ((int const   )*(m_pos + 3) == (int const   )*(ip + 3)) {
#line 2859
      goto try_match;
    }
#line 2860
    goto literal;
    try_match: 
#line 2864
    if (! ((int const   )*((unsigned short const   *)m_pos) != (int const   )*((unsigned short const   *)ip))) {
      {
#line 2872
      tmp___1 = __builtin_expect((long )(! (! ((int const   )*(m_pos + 2) == (int const   )*(ip + 2)))),
                                 1L);
      }
#line 2872
      if (tmp___1) {
#line 2887
        goto match;
      }
    }
    literal: 
    {
#line 2915
    *(dict + dindex) = ip;
#line 2916
    ip ++;
#line 2917
    tmp___2 = __builtin_expect((long )(! (! ((unsigned long )ip >= (unsigned long )ip_end))),
                               0L);
    }
#line 2917
    if (tmp___2) {
#line 2918
      goto while_break;
    }
#line 2919
    goto __Cont;
    match: 
#line 2922
    *(dict + dindex) = ip;
#line 2923
    if ((lzo_uint )(ip - ii) > 0UL) {
#line 2925
      t = (lzo_uint )(ip - ii);
#line 2927
      if (t <= 3UL) {
#line 2930
        *(op + -2) = (unsigned char )((int )*(op + -2) | (int )((unsigned char )t));
      } else
#line 2932
      if (t <= 18UL) {
#line 2933
        tmp___3 = op;
#line 2933
        op ++;
#line 2933
        *tmp___3 = (unsigned char )(t - 3UL);
      } else {
#line 2936
        tt = t - 18UL;
#line 2938
        tmp___4 = op;
#line 2938
        op ++;
#line 2938
        *tmp___4 = (unsigned char)0;
        {
#line 2939
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 2939
          if (! (tt > 255UL)) {
#line 2939
            goto while_break___0;
          }
#line 2941
          tt -= 255UL;
#line 2942
          tmp___5 = op;
#line 2942
          op ++;
#line 2942
          *tmp___5 = (unsigned char)0;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 2945
        tmp___6 = op;
#line 2945
        op ++;
#line 2945
        *tmp___6 = (unsigned char )tt;
      }
      {
#line 2947
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2947
        tmp___7 = op;
#line 2947
        op ++;
#line 2947
        tmp___8 = ii;
#line 2947
        ii ++;
#line 2947
        *tmp___7 = (unsigned char )*tmp___8;
#line 2947
        t --;
#line 2947
        if (! (t > 0UL)) {
#line 2947
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 2951
    ip += 3;
#line 2952
    tmp___21 = ip;
#line 2952
    ip ++;
#line 2952
    if ((int const   )*(m_pos + 3) != (int const   )*tmp___21) {
#line 2952
      goto _L;
    } else {
#line 2952
      tmp___22 = ip;
#line 2952
      ip ++;
#line 2952
      if ((int const   )*(m_pos + 4) != (int const   )*tmp___22) {
#line 2952
        goto _L;
      } else {
#line 2952
        tmp___23 = ip;
#line 2952
        ip ++;
#line 2952
        if ((int const   )*(m_pos + 5) != (int const   )*tmp___23) {
#line 2952
          goto _L;
        } else {
#line 2952
          tmp___24 = ip;
#line 2952
          ip ++;
#line 2952
          if ((int const   )*(m_pos + 6) != (int const   )*tmp___24) {
#line 2952
            goto _L;
          } else {
#line 2952
            tmp___25 = ip;
#line 2952
            ip ++;
#line 2952
            if ((int const   )*(m_pos + 7) != (int const   )*tmp___25) {
#line 2952
              goto _L;
            } else {
#line 2952
              tmp___26 = ip;
#line 2952
              ip ++;
#line 2952
              if ((int const   )*(m_pos + 8) != (int const   )*tmp___26) {
                _L: /* CIL Label */ 
#line 2960
                ip --;
#line 2961
                m_len = (lzo_uint )(ip - ii);
#line 2964
                if (m_off <= 2048UL) {
#line 2966
                  m_off --;
#line 2968
                  tmp___9 = op;
#line 2968
                  op ++;
#line 2968
                  *tmp___9 = (unsigned char )(((m_len - 1UL) << 5) | ((m_off & 7UL) << 2));
#line 2969
                  tmp___10 = op;
#line 2969
                  op ++;
#line 2969
                  *tmp___10 = (unsigned char )(m_off >> 3);
                } else
#line 2975
                if (m_off <= 16384UL) {
#line 2977
                  m_off --;
#line 2978
                  tmp___11 = op;
#line 2978
                  op ++;
#line 2978
                  *tmp___11 = (unsigned char )(32UL | (m_len - 2UL));
#line 2979
                  goto m3_m4_offset;
                } else {
#line 2984
                  m_off -= 16384UL;
#line 2986
                  tmp___12 = op;
#line 2986
                  op ++;
#line 2986
                  *tmp___12 = (unsigned char )((16UL | ((m_off & 16384UL) >> 11)) | (m_len - 2UL));
#line 2988
                  goto m3_m4_offset;
                }
              } else {
#line 2997
                end = in_end;
#line 2998
                m = (m_pos + 8) + 1;
                {
#line 2999
                while (1) {
                  while_continue___2: /* CIL Label */ ;
#line 2999
                  if ((unsigned long )ip < (unsigned long )end) {
#line 2999
                    if (! ((int const   )*m == (int const   )*ip)) {
#line 2999
                      goto while_break___2;
                    }
                  } else {
#line 2999
                    goto while_break___2;
                  }
#line 3000
                  m ++;
#line 3000
                  ip ++;
                }
                while_break___2: /* CIL Label */ ;
                }
#line 3001
                m_len = (lzo_uint )(ip - ii);
#line 3005
                if (m_off <= 16384UL) {
#line 3007
                  m_off --;
#line 3008
                  if (m_len <= 33UL) {
#line 3009
                    tmp___13 = op;
#line 3009
                    op ++;
#line 3009
                    *tmp___13 = (unsigned char )(32UL | (m_len - 2UL));
                  } else {
#line 3012
                    m_len -= 33UL;
#line 3013
                    tmp___14 = op;
#line 3013
                    op ++;
#line 3013
                    *tmp___14 = (unsigned char)32;
#line 3014
                    goto m3_m4_len;
                  }
                } else {
#line 3022
                  m_off -= 16384UL;
#line 3024
                  if (m_len <= 9UL) {
#line 3025
                    tmp___15 = op;
#line 3025
                    op ++;
#line 3025
                    *tmp___15 = (unsigned char )((16UL | ((m_off & 16384UL) >> 11)) | (m_len - 2UL));
                  } else {
#line 3029
                    m_len -= 9UL;
#line 3030
                    tmp___16 = op;
#line 3030
                    op ++;
#line 3030
                    *tmp___16 = (unsigned char )(16UL | ((m_off & 16384UL) >> 11));
                    m3_m4_len: 
                    {
#line 3032
                    while (1) {
                      while_continue___3: /* CIL Label */ ;
#line 3032
                      if (! (m_len > 255UL)) {
#line 3032
                        goto while_break___3;
                      }
#line 3034
                      m_len -= 255UL;
#line 3035
                      tmp___17 = op;
#line 3035
                      op ++;
#line 3035
                      *tmp___17 = (unsigned char)0;
                    }
                    while_break___3: /* CIL Label */ ;
                    }
#line 3038
                    tmp___18 = op;
#line 3038
                    op ++;
#line 3038
                    *tmp___18 = (unsigned char )m_len;
                  }
                }
                m3_m4_offset: 
#line 3043
                tmp___19 = op;
#line 3043
                op ++;
#line 3043
                *tmp___19 = (unsigned char )((m_off & 63UL) << 2);
#line 3044
                tmp___20 = op;
#line 3044
                op ++;
#line 3044
                *tmp___20 = (unsigned char )(m_off >> 6);
              }
            }
          }
        }
      }
    }
    {
#line 3050
    ii = ip;
#line 3051
    tmp___27 = __builtin_expect((long )(! (! ((unsigned long )ip >= (unsigned long )ip_end))),
                                0L);
    }
#line 3051
    if (tmp___27) {
#line 3052
      goto while_break;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 3055
  *out_len = (lzo_uint )(op - out);
#line 3056
  return ((lzo_uint )(in_end - ii));
}
}
#line 3059 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/minilzo.c"
int lzo1x_1_compress(unsigned char const   *in , lzo_uint in_len , unsigned char *out ,
                     lzo_uint *out_len , void *wrkmem___1 ) 
{ 
  unsigned char *op ;
  lzo_uint t ;
  long tmp ;
  unsigned char const   *ii ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  lzo_uint tt ;
  unsigned char *tmp___2 ;
  unsigned char *tmp___3 ;
  unsigned char *tmp___4 ;
  unsigned char *tmp___5 ;
  unsigned char const   *tmp___6 ;
  unsigned char *tmp___7 ;
  unsigned char *tmp___8 ;
  unsigned char *tmp___9 ;

  {
  {
#line 3064
  op = out;
#line 3067
  tmp = __builtin_expect((long )(! (! (in_len <= 13UL))), 0L);
  }
#line 3067
  if (tmp) {
#line 3068
    t = in_len;
  } else {
    {
#line 3071
    t = _lzo1x_1_do_compress(in, in_len, op, out_len, wrkmem___1);
#line 3072
    op += *out_len;
    }
  }
#line 3075
  if (t > 0UL) {
#line 3077
    ii = (in + in_len) - t;
#line 3079
    if ((unsigned long )op == (unsigned long )out) {
#line 3079
      if (t <= 238UL) {
#line 3080
        tmp___0 = op;
#line 3080
        op ++;
#line 3080
        *tmp___0 = (unsigned char )(17UL + t);
      } else {
#line 3079
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 3081
    if (t <= 3UL) {
#line 3082
      *(op + -2) = (unsigned char )((int )*(op + -2) | (int )((unsigned char )t));
    } else
#line 3083
    if (t <= 18UL) {
#line 3084
      tmp___1 = op;
#line 3084
      op ++;
#line 3084
      *tmp___1 = (unsigned char )(t - 3UL);
    } else {
#line 3087
      tt = t - 18UL;
#line 3089
      tmp___2 = op;
#line 3089
      op ++;
#line 3089
      *tmp___2 = (unsigned char)0;
      {
#line 3090
      while (1) {
        while_continue: /* CIL Label */ ;
#line 3090
        if (! (tt > 255UL)) {
#line 3090
          goto while_break;
        }
#line 3092
        tt -= 255UL;
#line 3093
        tmp___3 = op;
#line 3093
        op ++;
#line 3093
        *tmp___3 = (unsigned char)0;
      }
      while_break: /* CIL Label */ ;
      }
#line 3096
      tmp___4 = op;
#line 3096
      op ++;
#line 3096
      *tmp___4 = (unsigned char )tt;
    }
    {
#line 3098
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3098
      tmp___5 = op;
#line 3098
      op ++;
#line 3098
      tmp___6 = ii;
#line 3098
      ii ++;
#line 3098
      *tmp___5 = (unsigned char )*tmp___6;
#line 3098
      t --;
#line 3098
      if (! (t > 0UL)) {
#line 3098
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 3101
  tmp___7 = op;
#line 3101
  op ++;
#line 3101
  *tmp___7 = (unsigned char)17;
#line 3102
  tmp___8 = op;
#line 3102
  op ++;
#line 3102
  *tmp___8 = (unsigned char)0;
#line 3103
  tmp___9 = op;
#line 3103
  op ++;
#line 3103
  *tmp___9 = (unsigned char)0;
#line 3105
  *out_len = (lzo_uint )(op - out);
#line 3106
  return (0);
}
}
#line 3219 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/minilzo.c"
int lzo1x_decompress(unsigned char const   *in , lzo_uint in_len , unsigned char *out ,
                     lzo_uint *out_len , void *wrkmem___1 ) 
{ 
  register unsigned char *op ;
  register unsigned char const   *ip ;
  register lzo_uint t ;
  register unsigned char const   *m_pos ;
  unsigned char const   *ip_end ;
  unsigned char const   *tmp ;
  unsigned char *tmp___0 ;
  unsigned char const   *tmp___1 ;
  unsigned char const   *tmp___2 ;
  unsigned char const   *tmp___3 ;
  unsigned char *tmp___4 ;
  unsigned char const   *tmp___5 ;
  unsigned char *tmp___6 ;
  unsigned char const   *tmp___7 ;
  unsigned char const   *tmp___8 ;
  unsigned char const   *tmp___9 ;
  unsigned char *tmp___10 ;
  unsigned char const   *tmp___11 ;
  unsigned char *tmp___12 ;
  unsigned char const   *tmp___13 ;
  unsigned char *tmp___14 ;
  unsigned char const   *tmp___15 ;
  unsigned char const   *tmp___16 ;
  unsigned char const   *tmp___17 ;
  unsigned char const   *tmp___18 ;
  unsigned char *tmp___19 ;
  unsigned char const   *tmp___20 ;
  unsigned char *tmp___21 ;
  unsigned char *tmp___22 ;
  unsigned char const   *tmp___23 ;
  unsigned char *tmp___24 ;
  unsigned char const   *tmp___25 ;
  unsigned char *tmp___26 ;
  unsigned char const   *tmp___27 ;
  unsigned char *tmp___28 ;
  unsigned char const   *tmp___29 ;
  unsigned char *tmp___30 ;
  unsigned char const   *tmp___31 ;
  unsigned char *tmp___32 ;
  unsigned char const   *tmp___33 ;
  unsigned char *tmp___34 ;
  unsigned char const   *tmp___35 ;
  unsigned char const   *tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;

  {
#line 3235
  ip_end = in + in_len;
#line 3262
  *out_len = (lzo_uint )0;
#line 3264
  op = out;
#line 3265
  ip = in;
#line 3267
  if ((int const   )*ip > 17) {
#line 3269
    tmp = ip;
#line 3269
    ip ++;
#line 3269
    t = (lzo_uint )((int const   )*tmp - 17);
#line 3270
    if (t < 4UL) {
#line 3271
      goto match_next;
    }
    {
#line 3273
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3273
      tmp___0 = op;
#line 3273
      op ++;
#line 3273
      tmp___1 = ip;
#line 3273
      ip ++;
#line 3273
      *tmp___0 = (unsigned char )*tmp___1;
#line 3273
      t --;
#line 3273
      if (! (t > 0UL)) {
#line 3273
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 3274
    goto first_literal_run;
  }
  {
#line 3277
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3279
    tmp___2 = ip;
#line 3279
    ip ++;
#line 3279
    t = (lzo_uint )*tmp___2;
#line 3280
    if (t >= 16UL) {
#line 3281
      goto match;
    }
#line 3282
    if (t == 0UL) {
      {
#line 3285
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 3285
        if (! ((int const   )*ip == 0)) {
#line 3285
          goto while_break___1;
        }
#line 3287
        t += 255UL;
#line 3288
        ip ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 3291
      tmp___3 = ip;
#line 3291
      ip ++;
#line 3291
      t += (lzo_uint )(15 + (int )*tmp___3);
    }
#line 3299
    *((lzo_uint32 *)op) = (lzo_uint32 )*((lzo_uint32 const   *)ip);
#line 3300
    op += 4;
#line 3300
    ip += 4;
#line 3301
    t --;
#line 3301
    if (t > 0UL) {
#line 3303
      if (t >= 4UL) {
        {
#line 3305
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 3306
          *((lzo_uint32 *)op) = (lzo_uint32 )*((lzo_uint32 const   *)ip);
#line 3307
          op += 4;
#line 3307
          ip += 4;
#line 3307
          t -= 4UL;
#line 3305
          if (! (t >= 4UL)) {
#line 3305
            goto while_break___2;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
#line 3309
        if (t > 0UL) {
          {
#line 3309
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 3309
            tmp___4 = op;
#line 3309
            op ++;
#line 3309
            tmp___5 = ip;
#line 3309
            ip ++;
#line 3309
            *tmp___4 = (unsigned char )*tmp___5;
#line 3309
            t --;
#line 3309
            if (! (t > 0UL)) {
#line 3309
              goto while_break___3;
            }
          }
          while_break___3: /* CIL Label */ ;
          }
        }
      } else {
        {
#line 3312
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 3312
          tmp___6 = op;
#line 3312
          op ++;
#line 3312
          tmp___7 = ip;
#line 3312
          ip ++;
#line 3312
          *tmp___6 = (unsigned char )*tmp___7;
#line 3312
          t --;
#line 3312
          if (! (t > 0UL)) {
#line 3312
            goto while_break___4;
          }
        }
        while_break___4: /* CIL Label */ ;
        }
      }
    }
    first_literal_run: 
#line 3328
    tmp___8 = ip;
#line 3328
    ip ++;
#line 3328
    t = (lzo_uint )*tmp___8;
#line 3329
    if (t >= 16UL) {
#line 3330
      goto match;
    }
#line 3346
    m_pos = (unsigned char const   *)(op - 2049);
#line 3347
    m_pos -= t >> 2;
#line 3348
    tmp___9 = ip;
#line 3348
    ip ++;
#line 3348
    m_pos -= (int const   )*tmp___9 << 2;
#line 3351
    tmp___10 = op;
#line 3351
    op ++;
#line 3351
    tmp___11 = m_pos;
#line 3351
    m_pos ++;
#line 3351
    *tmp___10 = (unsigned char )*tmp___11;
#line 3351
    tmp___12 = op;
#line 3351
    op ++;
#line 3351
    tmp___13 = m_pos;
#line 3351
    m_pos ++;
#line 3351
    *tmp___12 = (unsigned char )*tmp___13;
#line 3351
    tmp___14 = op;
#line 3351
    op ++;
#line 3351
    *tmp___14 = (unsigned char )*m_pos;
#line 3353
    goto match_done;
    {
#line 3355
    while (1) {
      while_continue___5: /* CIL Label */ ;
      match: 
#line 3357
      if (t >= 64UL) {
#line 3379
        m_pos = (unsigned char const   *)(op - 1);
#line 3380
        m_pos -= (t >> 2) & 7UL;
#line 3381
        tmp___15 = ip;
#line 3381
        ip ++;
#line 3381
        m_pos -= (int const   )*tmp___15 << 3;
#line 3382
        t = (t >> 5) - 1UL;
#line 3407
        goto copy_match;
      } else
#line 3410
      if (t >= 32UL) {
#line 3412
        t &= 31UL;
#line 3413
        if (t == 0UL) {
          {
#line 3416
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 3416
            if (! ((int const   )*ip == 0)) {
#line 3416
              goto while_break___6;
            }
#line 3418
            t += 255UL;
#line 3419
            ip ++;
          }
          while_break___6: /* CIL Label */ ;
          }
#line 3422
          tmp___16 = ip;
#line 3422
          ip ++;
#line 3422
          t += (lzo_uint )(31 + (int )*tmp___16);
        }
#line 3439
        m_pos = (unsigned char const   *)(op - 1);
#line 3440
        m_pos -= (int const   )*((unsigned short const   *)ip) >> 2;
#line 3446
        ip += 2;
      } else
#line 3448
      if (t >= 16UL) {
#line 3453
        m_pos = (unsigned char const   *)op;
#line 3454
        m_pos -= (t & 8UL) << 11;
#line 3456
        t &= 7UL;
#line 3457
        if (t == 0UL) {
          {
#line 3460
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 3460
            if (! ((int const   )*ip == 0)) {
#line 3460
              goto while_break___7;
            }
#line 3462
            t += 255UL;
#line 3463
            ip ++;
          }
          while_break___7: /* CIL Label */ ;
          }
#line 3466
          tmp___17 = ip;
#line 3466
          ip ++;
#line 3466
          t += (lzo_uint )(7 + (int )*tmp___17);
        }
#line 3485
        m_pos -= (int const   )*((unsigned short const   *)ip) >> 2;
#line 3489
        ip += 2;
#line 3490
        if ((unsigned long )m_pos == (unsigned long )op) {
#line 3491
          goto eof_found;
        }
#line 3492
        m_pos -= 16384;
      } else {
#line 3515
        m_pos = (unsigned char const   *)(op - 1);
#line 3516
        m_pos -= t >> 2;
#line 3517
        tmp___18 = ip;
#line 3517
        ip ++;
#line 3517
        m_pos -= (int const   )*tmp___18 << 2;
#line 3520
        tmp___19 = op;
#line 3520
        op ++;
#line 3520
        tmp___20 = m_pos;
#line 3520
        m_pos ++;
#line 3520
        *tmp___19 = (unsigned char )*tmp___20;
#line 3520
        tmp___21 = op;
#line 3520
        op ++;
#line 3520
        *tmp___21 = (unsigned char )*m_pos;
#line 3522
        goto match_done;
      }
#line 3539
      if (t >= 6UL) {
#line 3539
        if (op - (unsigned char *)m_pos >= 4L) {
#line 3542
          *((lzo_uint32 *)op) = (lzo_uint32 )*((lzo_uint32 const   *)m_pos);
#line 3543
          op += 4;
#line 3543
          m_pos += 4;
#line 3543
          t -= 2UL;
          {
#line 3544
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 3545
            *((lzo_uint32 *)op) = (lzo_uint32 )*((lzo_uint32 const   *)m_pos);
#line 3546
            op += 4;
#line 3546
            m_pos += 4;
#line 3546
            t -= 4UL;
#line 3544
            if (! (t >= 4UL)) {
#line 3544
              goto while_break___8;
            }
          }
          while_break___8: /* CIL Label */ ;
          }
#line 3548
          if (t > 0UL) {
            {
#line 3548
            while (1) {
              while_continue___9: /* CIL Label */ ;
#line 3548
              tmp___22 = op;
#line 3548
              op ++;
#line 3548
              tmp___23 = m_pos;
#line 3548
              m_pos ++;
#line 3548
              *tmp___22 = (unsigned char )*tmp___23;
#line 3548
              t --;
#line 3548
              if (! (t > 0UL)) {
#line 3548
                goto while_break___9;
              }
            }
            while_break___9: /* CIL Label */ ;
            }
          }
        } else {
#line 3539
          goto copy_match;
        }
      } else {
        copy_match: 
#line 3554
        tmp___24 = op;
#line 3554
        op ++;
#line 3554
        tmp___25 = m_pos;
#line 3554
        m_pos ++;
#line 3554
        *tmp___24 = (unsigned char )*tmp___25;
#line 3554
        tmp___26 = op;
#line 3554
        op ++;
#line 3554
        tmp___27 = m_pos;
#line 3554
        m_pos ++;
#line 3554
        *tmp___26 = (unsigned char )*tmp___27;
        {
#line 3555
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 3555
          tmp___28 = op;
#line 3555
          op ++;
#line 3555
          tmp___29 = m_pos;
#line 3555
          m_pos ++;
#line 3555
          *tmp___28 = (unsigned char )*tmp___29;
#line 3555
          t --;
#line 3555
          if (! (t > 0UL)) {
#line 3555
            goto while_break___10;
          }
        }
        while_break___10: /* CIL Label */ ;
        }
      }
      match_done: 
#line 3564
      t = (lzo_uint )((int const   )*(ip + -2) & 3);
#line 3566
      if (t == 0UL) {
#line 3567
        goto while_break___5;
      }
      match_next: 
#line 3574
      tmp___30 = op;
#line 3574
      op ++;
#line 3574
      tmp___31 = ip;
#line 3574
      ip ++;
#line 3574
      *tmp___30 = (unsigned char )*tmp___31;
#line 3575
      if (t > 1UL) {
#line 3575
        tmp___32 = op;
#line 3575
        op ++;
#line 3575
        tmp___33 = ip;
#line 3575
        ip ++;
#line 3575
        *tmp___32 = (unsigned char )*tmp___33;
#line 3575
        if (t > 2UL) {
#line 3575
          tmp___34 = op;
#line 3575
          op ++;
#line 3575
          tmp___35 = ip;
#line 3575
          ip ++;
#line 3575
          *tmp___34 = (unsigned char )*tmp___35;
        }
      }
#line 3577
      tmp___36 = ip;
#line 3577
      ip ++;
#line 3577
      t = (lzo_uint )*tmp___36;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  eof_found: 
#line 3588
  *out_len = (lzo_uint )(op - out);
#line 3589
  if ((unsigned long )ip == (unsigned long )ip_end) {
#line 3589
    tmp___38 = 0;
  } else {
#line 3589
    if ((unsigned long )ip < (unsigned long )ip_end) {
#line 3589
      tmp___37 = -8;
    } else {
#line 3589
      tmp___37 = -4;
    }
#line 3589
    tmp___38 = tmp___37;
  }
#line 3589
  return (tmp___38);
}
}
#line 3717 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/minilzo.c"
int lzo1x_decompress_safe(unsigned char const   *in , lzo_uint in_len , unsigned char *out ,
                          lzo_uint *out_len , void *wrkmem___1 ) 
{ 
  register unsigned char *op ;
  register unsigned char const   *ip ;
  register lzo_uint t ;
  register unsigned char const   *m_pos ;
  unsigned char const   *ip_end ;
  unsigned char *op_end ;
  unsigned char const   *tmp ;
  unsigned char *tmp___0 ;
  unsigned char const   *tmp___1 ;
  unsigned char const   *tmp___2 ;
  unsigned char const   *tmp___3 ;
  unsigned char *tmp___4 ;
  unsigned char const   *tmp___5 ;
  unsigned char *tmp___6 ;
  unsigned char const   *tmp___7 ;
  unsigned char const   *tmp___8 ;
  unsigned char const   *tmp___9 ;
  unsigned char *tmp___10 ;
  unsigned char const   *tmp___11 ;
  unsigned char *tmp___12 ;
  unsigned char const   *tmp___13 ;
  unsigned char *tmp___14 ;
  unsigned char const   *tmp___15 ;
  unsigned char const   *tmp___16 ;
  unsigned char const   *tmp___17 ;
  unsigned char const   *tmp___18 ;
  unsigned char *tmp___19 ;
  unsigned char const   *tmp___20 ;
  unsigned char *tmp___21 ;
  unsigned char *tmp___22 ;
  unsigned char const   *tmp___23 ;
  unsigned char *tmp___24 ;
  unsigned char const   *tmp___25 ;
  unsigned char *tmp___26 ;
  unsigned char const   *tmp___27 ;
  unsigned char *tmp___28 ;
  unsigned char const   *tmp___29 ;
  unsigned char *tmp___30 ;
  unsigned char const   *tmp___31 ;
  unsigned char *tmp___32 ;
  unsigned char const   *tmp___33 ;
  unsigned char *tmp___34 ;
  unsigned char const   *tmp___35 ;
  unsigned char const   *tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;

  {
#line 3733
  ip_end = in + in_len;
#line 3735
  op_end = out + *out_len;
#line 3760
  *out_len = (lzo_uint )0;
#line 3762
  op = out;
#line 3763
  ip = in;
#line 3765
  if ((int const   )*ip > 17) {
#line 3767
    tmp = ip;
#line 3767
    ip ++;
#line 3767
    t = (lzo_uint )((int const   )*tmp - 17);
#line 3768
    if (t < 4UL) {
#line 3769
      goto match_next;
    }
#line 3770
    if ((lzo_uint )(op_end - op) < t) {
#line 3770
      goto output_overrun;
    }
#line 3770
    if ((lzo_uint )(ip_end - ip) < t + 1UL) {
#line 3770
      goto input_overrun;
    }
    {
#line 3771
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3771
      tmp___0 = op;
#line 3771
      op ++;
#line 3771
      tmp___1 = ip;
#line 3771
      ip ++;
#line 3771
      *tmp___0 = (unsigned char )*tmp___1;
#line 3771
      t --;
#line 3771
      if (! (t > 0UL)) {
#line 3771
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 3772
    goto first_literal_run;
  }
  {
#line 3775
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3775
    if (! ((unsigned long )ip < (unsigned long )ip_end)) {
#line 3775
      goto while_break___0;
    }
#line 3777
    tmp___2 = ip;
#line 3777
    ip ++;
#line 3777
    t = (lzo_uint )*tmp___2;
#line 3778
    if (t >= 16UL) {
#line 3779
      goto match;
    }
#line 3780
    if (t == 0UL) {
#line 3782
      if ((lzo_uint )(ip_end - ip) < 1UL) {
#line 3782
        goto input_overrun;
      }
      {
#line 3783
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 3783
        if (! ((int const   )*ip == 0)) {
#line 3783
          goto while_break___1;
        }
#line 3785
        t += 255UL;
#line 3786
        ip ++;
#line 3787
        if ((lzo_uint )(ip_end - ip) < 1UL) {
#line 3787
          goto input_overrun;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 3789
      tmp___3 = ip;
#line 3789
      ip ++;
#line 3789
      t += (lzo_uint )(15 + (int )*tmp___3);
    }
#line 3791
    if ((lzo_uint )(op_end - op) < t + 3UL) {
#line 3791
      goto output_overrun;
    }
#line 3791
    if ((lzo_uint )(ip_end - ip) < t + 4UL) {
#line 3791
      goto input_overrun;
    }
#line 3797
    *((lzo_uint32 *)op) = (lzo_uint32 )*((lzo_uint32 const   *)ip);
#line 3798
    op += 4;
#line 3798
    ip += 4;
#line 3799
    t --;
#line 3799
    if (t > 0UL) {
#line 3801
      if (t >= 4UL) {
        {
#line 3803
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 3804
          *((lzo_uint32 *)op) = (lzo_uint32 )*((lzo_uint32 const   *)ip);
#line 3805
          op += 4;
#line 3805
          ip += 4;
#line 3805
          t -= 4UL;
#line 3803
          if (! (t >= 4UL)) {
#line 3803
            goto while_break___2;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
#line 3807
        if (t > 0UL) {
          {
#line 3807
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 3807
            tmp___4 = op;
#line 3807
            op ++;
#line 3807
            tmp___5 = ip;
#line 3807
            ip ++;
#line 3807
            *tmp___4 = (unsigned char )*tmp___5;
#line 3807
            t --;
#line 3807
            if (! (t > 0UL)) {
#line 3807
              goto while_break___3;
            }
          }
          while_break___3: /* CIL Label */ ;
          }
        }
      } else {
        {
#line 3810
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 3810
          tmp___6 = op;
#line 3810
          op ++;
#line 3810
          tmp___7 = ip;
#line 3810
          ip ++;
#line 3810
          *tmp___6 = (unsigned char )*tmp___7;
#line 3810
          t --;
#line 3810
          if (! (t > 0UL)) {
#line 3810
            goto while_break___4;
          }
        }
        while_break___4: /* CIL Label */ ;
        }
      }
    }
    first_literal_run: 
#line 3826
    tmp___8 = ip;
#line 3826
    ip ++;
#line 3826
    t = (lzo_uint )*tmp___8;
#line 3827
    if (t >= 16UL) {
#line 3828
      goto match;
    }
#line 3844
    m_pos = (unsigned char const   *)(op - 2049);
#line 3845
    m_pos -= t >> 2;
#line 3846
    tmp___9 = ip;
#line 3846
    ip ++;
#line 3846
    m_pos -= (int const   )*tmp___9 << 2;
#line 3848
    if ((unsigned long )m_pos < (unsigned long )out) {
#line 3848
      goto lookbehind_overrun;
    } else
#line 3848
    if ((unsigned long )m_pos >= (unsigned long )op) {
#line 3848
      goto lookbehind_overrun;
    }
#line 3848
    if ((lzo_uint )(op_end - op) < 3UL) {
#line 3848
      goto output_overrun;
    }
#line 3849
    tmp___10 = op;
#line 3849
    op ++;
#line 3849
    tmp___11 = m_pos;
#line 3849
    m_pos ++;
#line 3849
    *tmp___10 = (unsigned char )*tmp___11;
#line 3849
    tmp___12 = op;
#line 3849
    op ++;
#line 3849
    tmp___13 = m_pos;
#line 3849
    m_pos ++;
#line 3849
    *tmp___12 = (unsigned char )*tmp___13;
#line 3849
    tmp___14 = op;
#line 3849
    op ++;
#line 3849
    *tmp___14 = (unsigned char )*m_pos;
#line 3851
    goto match_done;
    {
#line 3853
    while (1) {
      while_continue___5: /* CIL Label */ ;
      match: 
#line 3855
      if (t >= 64UL) {
#line 3877
        m_pos = (unsigned char const   *)(op - 1);
#line 3878
        m_pos -= (t >> 2) & 7UL;
#line 3879
        tmp___15 = ip;
#line 3879
        ip ++;
#line 3879
        m_pos -= (int const   )*tmp___15 << 3;
#line 3880
        t = (t >> 5) - 1UL;
#line 3904
        if ((unsigned long )m_pos < (unsigned long )out) {
#line 3904
          goto lookbehind_overrun;
        } else
#line 3904
        if ((unsigned long )m_pos >= (unsigned long )op) {
#line 3904
          goto lookbehind_overrun;
        }
#line 3904
        if ((lzo_uint )(op_end - op) < (t + 3UL) - 1UL) {
#line 3904
          goto output_overrun;
        }
#line 3905
        goto copy_match;
      } else
#line 3908
      if (t >= 32UL) {
#line 3910
        t &= 31UL;
#line 3911
        if (t == 0UL) {
#line 3913
          if ((lzo_uint )(ip_end - ip) < 1UL) {
#line 3913
            goto input_overrun;
          }
          {
#line 3914
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 3914
            if (! ((int const   )*ip == 0)) {
#line 3914
              goto while_break___6;
            }
#line 3916
            t += 255UL;
#line 3917
            ip ++;
#line 3918
            if ((lzo_uint )(ip_end - ip) < 1UL) {
#line 3918
              goto input_overrun;
            }
          }
          while_break___6: /* CIL Label */ ;
          }
#line 3920
          tmp___16 = ip;
#line 3920
          ip ++;
#line 3920
          t += (lzo_uint )(31 + (int )*tmp___16);
        }
#line 3937
        m_pos = (unsigned char const   *)(op - 1);
#line 3938
        m_pos -= (int const   )*((unsigned short const   *)ip) >> 2;
#line 3944
        ip += 2;
      } else
#line 3946
      if (t >= 16UL) {
#line 3951
        m_pos = (unsigned char const   *)op;
#line 3952
        m_pos -= (t & 8UL) << 11;
#line 3954
        t &= 7UL;
#line 3955
        if (t == 0UL) {
#line 3957
          if ((lzo_uint )(ip_end - ip) < 1UL) {
#line 3957
            goto input_overrun;
          }
          {
#line 3958
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 3958
            if (! ((int const   )*ip == 0)) {
#line 3958
              goto while_break___7;
            }
#line 3960
            t += 255UL;
#line 3961
            ip ++;
#line 3962
            if ((lzo_uint )(ip_end - ip) < 1UL) {
#line 3962
              goto input_overrun;
            }
          }
          while_break___7: /* CIL Label */ ;
          }
#line 3964
          tmp___17 = ip;
#line 3964
          ip ++;
#line 3964
          t += (lzo_uint )(7 + (int )*tmp___17);
        }
#line 3983
        m_pos -= (int const   )*((unsigned short const   *)ip) >> 2;
#line 3987
        ip += 2;
#line 3988
        if ((unsigned long )m_pos == (unsigned long )op) {
#line 3989
          goto eof_found;
        }
#line 3990
        m_pos -= 16384;
      } else {
#line 4013
        m_pos = (unsigned char const   *)(op - 1);
#line 4014
        m_pos -= t >> 2;
#line 4015
        tmp___18 = ip;
#line 4015
        ip ++;
#line 4015
        m_pos -= (int const   )*tmp___18 << 2;
#line 4017
        if ((unsigned long )m_pos < (unsigned long )out) {
#line 4017
          goto lookbehind_overrun;
        } else
#line 4017
        if ((unsigned long )m_pos >= (unsigned long )op) {
#line 4017
          goto lookbehind_overrun;
        }
#line 4017
        if ((lzo_uint )(op_end - op) < 2UL) {
#line 4017
          goto output_overrun;
        }
#line 4018
        tmp___19 = op;
#line 4018
        op ++;
#line 4018
        tmp___20 = m_pos;
#line 4018
        m_pos ++;
#line 4018
        *tmp___19 = (unsigned char )*tmp___20;
#line 4018
        tmp___21 = op;
#line 4018
        op ++;
#line 4018
        *tmp___21 = (unsigned char )*m_pos;
#line 4020
        goto match_done;
      }
#line 4030
      if ((unsigned long )m_pos < (unsigned long )out) {
#line 4030
        goto lookbehind_overrun;
      } else
#line 4030
      if ((unsigned long )m_pos >= (unsigned long )op) {
#line 4030
        goto lookbehind_overrun;
      }
#line 4030
      if ((lzo_uint )(op_end - op) < (t + 3UL) - 1UL) {
#line 4030
        goto output_overrun;
      }
#line 4037
      if (t >= 6UL) {
#line 4037
        if (op - (unsigned char *)m_pos >= 4L) {
#line 4040
          *((lzo_uint32 *)op) = (lzo_uint32 )*((lzo_uint32 const   *)m_pos);
#line 4041
          op += 4;
#line 4041
          m_pos += 4;
#line 4041
          t -= 2UL;
          {
#line 4042
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 4043
            *((lzo_uint32 *)op) = (lzo_uint32 )*((lzo_uint32 const   *)m_pos);
#line 4044
            op += 4;
#line 4044
            m_pos += 4;
#line 4044
            t -= 4UL;
#line 4042
            if (! (t >= 4UL)) {
#line 4042
              goto while_break___8;
            }
          }
          while_break___8: /* CIL Label */ ;
          }
#line 4046
          if (t > 0UL) {
            {
#line 4046
            while (1) {
              while_continue___9: /* CIL Label */ ;
#line 4046
              tmp___22 = op;
#line 4046
              op ++;
#line 4046
              tmp___23 = m_pos;
#line 4046
              m_pos ++;
#line 4046
              *tmp___22 = (unsigned char )*tmp___23;
#line 4046
              t --;
#line 4046
              if (! (t > 0UL)) {
#line 4046
                goto while_break___9;
              }
            }
            while_break___9: /* CIL Label */ ;
            }
          }
        } else {
#line 4037
          goto copy_match;
        }
      } else {
        copy_match: 
#line 4052
        tmp___24 = op;
#line 4052
        op ++;
#line 4052
        tmp___25 = m_pos;
#line 4052
        m_pos ++;
#line 4052
        *tmp___24 = (unsigned char )*tmp___25;
#line 4052
        tmp___26 = op;
#line 4052
        op ++;
#line 4052
        tmp___27 = m_pos;
#line 4052
        m_pos ++;
#line 4052
        *tmp___26 = (unsigned char )*tmp___27;
        {
#line 4053
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 4053
          tmp___28 = op;
#line 4053
          op ++;
#line 4053
          tmp___29 = m_pos;
#line 4053
          m_pos ++;
#line 4053
          *tmp___28 = (unsigned char )*tmp___29;
#line 4053
          t --;
#line 4053
          if (! (t > 0UL)) {
#line 4053
            goto while_break___10;
          }
        }
        while_break___10: /* CIL Label */ ;
        }
      }
      match_done: 
#line 4062
      t = (lzo_uint )((int const   )*(ip + -2) & 3);
#line 4064
      if (t == 0UL) {
#line 4065
        goto while_break___5;
      }
      match_next: ;
#line 4068
      if ((lzo_uint )(op_end - op) < t) {
#line 4068
        goto output_overrun;
      }
#line 4068
      if ((lzo_uint )(ip_end - ip) < t + 1UL) {
#line 4068
        goto input_overrun;
      }
#line 4072
      tmp___30 = op;
#line 4072
      op ++;
#line 4072
      tmp___31 = ip;
#line 4072
      ip ++;
#line 4072
      *tmp___30 = (unsigned char )*tmp___31;
#line 4073
      if (t > 1UL) {
#line 4073
        tmp___32 = op;
#line 4073
        op ++;
#line 4073
        tmp___33 = ip;
#line 4073
        ip ++;
#line 4073
        *tmp___32 = (unsigned char )*tmp___33;
#line 4073
        if (t > 2UL) {
#line 4073
          tmp___34 = op;
#line 4073
          op ++;
#line 4073
          tmp___35 = ip;
#line 4073
          ip ++;
#line 4073
          *tmp___34 = (unsigned char )*tmp___35;
        }
      }
#line 4075
      tmp___36 = ip;
#line 4075
      ip ++;
#line 4075
      t = (lzo_uint )*tmp___36;
#line 3853
      if (! ((unsigned long )ip < (unsigned long )ip_end)) {
#line 3853
        goto while_break___5;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 4080
  *out_len = (lzo_uint )(op - out);
#line 4081
  return (-7);
  eof_found: 
#line 4086
  *out_len = (lzo_uint )(op - out);
#line 4087
  if ((unsigned long )ip == (unsigned long )ip_end) {
#line 4087
    tmp___38 = 0;
  } else {
#line 4087
    if ((unsigned long )ip < (unsigned long )ip_end) {
#line 4087
      tmp___37 = -8;
    } else {
#line 4087
      tmp___37 = -4;
    }
#line 4087
    tmp___38 = tmp___37;
  }
#line 4087
  return (tmp___38);
  input_overrun: 
#line 4092
  *out_len = (lzo_uint )(op - out);
#line 4093
  return (-4);
  output_overrun: 
#line 4098
  *out_len = (lzo_uint )(op - out);
#line 4099
  return (-5);
  lookbehind_overrun: 
#line 4104
  *out_len = (lzo_uint )(op - out);
#line 4105
  return (-6);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 205
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) strftime)(char * __restrict  __s ,
                                                                                  size_t __maxsize ,
                                                                                  char const   * __restrict  __format ,
                                                                                  struct tm  const  * __restrict  __tp ) ;
#line 243
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 183
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 123 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  *__addr ,
                                                                           socklen_t __len ) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getsockname)(int __fd ,
                                                                                  struct sockaddr * __restrict  __addr ,
                                                                                  socklen_t * __restrict  __len ) ;
#line 137
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 149
extern ssize_t send(int __fd , void const   *__buf , size_t __n , int __flags ) ;
#line 156
extern ssize_t recv(int __fd , void *__buf , size_t __n , int __flags ) ;
#line 163
extern ssize_t sendto(int __fd , void const   *__buf , size_t __n , int __flags ,
                      struct sockaddr  const  *__addr , socklen_t __addr_len ) ;
#line 174
extern ssize_t recvfrom(int __fd , void * __restrict  __buf , size_t __n , int __flags ,
                        struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 226
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void const   *__optval ,
                                                                                 socklen_t __optlen ) ;
#line 233
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) listen)(int __fd ,
                                                                             int __n ) ;
#line 374 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) ntohl)(uint32_t __netlong )  __attribute__((__const__)) ;
#line 375
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) ntohs)(uint16_t __netshort )  __attribute__((__const__)) ;
#line 379
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 390
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 181 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 190
extern void ( /* format attribute */  syslog)(int __pri , char const   *__fmt  , ...) ;
#line 399 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 162 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.h"
int marshall_n2n_packet_header(u_int8_t *buf , struct n2n_packet_header  const  *hdr ) ;
#line 163
int unmarshall_n2n_packet_header(struct n2n_packet_header *hdr , u_int8_t const   *buf ) ;
#line 229
int traceLevel ;
#line 230
char broadcast_addr[6] ;
#line 231
char multicast_addr[6] ;
#line 234
extern void sockaddr_in2peer_addr(struct sockaddr_in *in , struct peer_addr *out ) ;
#line 235
extern void peer_addr2sockaddr_in(struct peer_addr  const  *in , struct sockaddr_in *out ) ;
#line 238
void send_ack(n2n_sock_info_t *sinfo , u_int16_t last_rcvd_seq_id , struct n2n_packet_header *header ,
              struct peer_addr *remote_peer , char *src_mac ) ;
#line 251
int open_socket(int local_port , int udp_sock , int server_mode ) ;
#line 252
int connect_socket(int sock_fd , struct peer_addr *_dest ) ;
#line 254
void send_packet(n2n_sock_info_t *sinfo , char *packet , size_t *packet_len , struct peer_addr  const  *remote_peer ,
                 u_int8_t compress_data ) ;
#line 258
char *intoa(u_int32_t addr , char *buf , u_short buf_len ) ;
#line 260
extern int str2mac(u_int8_t *outmac , char const   *s ) ;
#line 261
void fill_standard_header_fields(n2n_sock_info_t *sinfo , struct n2n_packet_header *hdr ,
                                 char *src_mac ) ;
#line 265
u_int receive_data(n2n_sock_info_t *sinfo , char *packet , size_t packet_len , struct peer_addr *from ,
                   u_int8_t *discarded_pkt , char *tun_mac_addr , u_int8_t decompress_data ,
                   struct n2n_packet_header *hdr ) ;
#line 270
u_int reliable_sendto(n2n_sock_info_t *sinfo , char *packet , size_t *packet_len ,
                      struct peer_addr  const  *to , u_int8_t compress_data ) ;
#line 273
u_int unreliable_sendto(n2n_sock_info_t *sinfo , char *packet , size_t *packet_len ,
                        struct peer_addr  const  *to , u_int8_t compress_data ) ;
#line 276
u_int send_data(n2n_sock_info_t *sinfo , char *packet , size_t *packet_len , struct peer_addr  const  *to ,
                u_int8_t compress_data ) ;
#line 279
u_int8_t is_multi_broadcast(char *dest_mac ) ;
#line 280
char *msg_type2str(u_short msg_type ) ;
#line 281
void hexdump(char *buf , u_int len ) ;
#line 283
void print_n2n_version(void) ;
#line 287
struct peer_info *find_peer_by_mac(struct peer_info *list , char const   *mac ) ;
#line 289
void peer_list_add(struct peer_info **list , struct peer_info *new ) ;
#line 291
size_t peer_list_size(struct peer_info  const  *list ) ;
#line 292
size_t purge_peer_list(struct peer_info **peer_list , time_t purge_before ) ;
#line 294
size_t purge_expired_registrations(struct peer_info **peer_list ) ;
#line 297
char const   *version ;
#line 297
char const   *osName ;
#line 297
char const   *buildDate ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 39 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.c"
char broadcast_addr[6]  = {      (char)-1,      (char)-1,      (char)-1,      (char)-1, 
        (char)-1,      (char)-1};
#line 40 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.c"
char multicast_addr[6]  = {      (char)1,      (char)0,      (char)5,      (char)0, 
        (char)0,      (char)0};
#line 44 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.c"
static void print_header(char const   *msg , struct n2n_packet_header  const  *hdr ) 
{ 
  ipstr_t buf ;
  ipstr_t buf2 ;
  uint16_t tmp ;
  uint32_t tmp___0 ;
  char *tmp___1 ;
  uint16_t tmp___2 ;
  uint32_t tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 49
  tmp = ntohs((uint16_t )hdr->private_ip.port);
#line 49
  tmp___0 = ntohl((uint32_t )hdr->private_ip.addr_type.v4_addr);
#line 49
  tmp___1 = intoa(tmp___0, buf2, (u_short )sizeof(buf2));
#line 49
  tmp___2 = ntohs((uint16_t )hdr->public_ip.port);
#line 49
  tmp___3 = ntohl((uint32_t )hdr->public_ip.addr_type.v4_addr);
#line 49
  tmp___4 = intoa(tmp___3, buf, (u_short )sizeof(buf));
#line 49
  traceEvent(3, (char *)"/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.c", 49,
             (char *)"%s hdr: public_ip=(%d)%s:%d, private_ip=(%d)%s:%d", msg, (int const   )hdr->public_ip.family,
             tmp___4, (int )tmp___2, (int const   )hdr->private_ip.family, tmp___1,
             (int )tmp);
  }
#line 57
  return;
}
}
#line 61 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.c"
extern void sockaddr_in2peer_addr(struct sockaddr_in *in , struct peer_addr *out ) 
{ 


  {
#line 62
  out->family = (u_int8_t )in->sin_family;
#line 63
  out->port = in->sin_port;
#line 64
  out->addr_type.v4_addr = in->sin_addr.s_addr;
#line 65
  return;
}
}
#line 69 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.c"
extern void peer_addr2sockaddr_in(struct peer_addr  const  *in , struct sockaddr_in *out ) 
{ 


  {
#line 70
  out->sin_family = (sa_family_t )in->family;
#line 71
  out->sin_port = (in_port_t )in->port;
#line 72
  out->sin_addr.s_addr = (in_addr_t )in->addr_type.v4_addr;
#line 73
  return;
}
}
#line 77 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.c"
static int marshall_peer_addr(u_int8_t *buf , size_t *offset , struct peer_addr  const  *s ) 
{ 


  {
  {
#line 83
  memcpy((void */* __restrict  */)(buf + *offset), (void const   */* __restrict  */)s,
         sizeof(struct peer_addr ));
#line 84
  *offset += sizeof(struct peer_addr );
  }
#line 86
  return ((int )sizeof(struct peer_addr ));
}
}
#line 91 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.c"
static int marshall_uint32(u_int8_t *buf , size_t *offset , u_int32_t val ) 
{ 


  {
#line 94
  *(buf + *offset) = (u_int8_t )((val >> 24) & 255U);
#line 95
  *(buf + (*offset + 1UL)) = (u_int8_t )((val >> 16) & 255U);
#line 96
  *(buf + (*offset + 2UL)) = (u_int8_t )((val >> 8) & 255U);
#line 97
  *(buf + (*offset + 3UL)) = (u_int8_t )(val & 255U);
#line 99
  *offset += 4UL;
#line 100
  return (4);
}
}
#line 105 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.c"
int marshall_n2n_packet_header(u_int8_t *buf , struct n2n_packet_header  const  *hdr ) 
{ 
  size_t offset ;

  {
  {
#line 107
  offset = (size_t )0;
#line 109
  print_header("Marshalling ", hdr);
#line 111
  *(buf + offset) = (u_int8_t )hdr->version;
#line 112
  offset ++;
#line 114
  *(buf + offset) = (u_int8_t )hdr->msg_type;
#line 115
  offset ++;
#line 117
  *(buf + offset) = (u_int8_t )hdr->ttl;
#line 118
  offset ++;
#line 120
  *(buf + offset) = (u_int8_t )hdr->sent_by_supernode;
#line 121
  offset ++;
#line 123
  memcpy((void */* __restrict  */)(buf + offset), (void const   */* __restrict  */)(hdr->community_name),
         (size_t )16);
#line 124
  offset += 16UL;
#line 126
  memcpy((void */* __restrict  */)(buf + offset), (void const   */* __restrict  */)(hdr->src_mac),
         (size_t )6);
#line 127
  offset += 6UL;
#line 129
  memcpy((void */* __restrict  */)(buf + offset), (void const   */* __restrict  */)(hdr->dst_mac),
         (size_t )6);
#line 130
  offset += 6UL;
#line 132
  marshall_peer_addr(buf, & offset, & hdr->public_ip);
#line 133
  marshall_peer_addr(buf, & offset, & hdr->private_ip);
#line 135
  *(buf + offset) = (u_int8_t )((unsigned int const   )hdr->pkt_type & 255U);
#line 136
  offset ++;
#line 138
  marshall_uint32(buf, & offset, (u_int32_t )hdr->sequence_id);
#line 139
  marshall_uint32(buf, & offset, (u_int32_t )hdr->crc);
  }
#line 141
  return ((int )offset);
}
}
#line 146 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.c"
static int unmarshall_peer_addr(struct peer_addr *s , size_t *offset , u_int8_t const   *buf ) 
{ 


  {
  {
#line 150
  memcpy((void */* __restrict  */)s, (void const   */* __restrict  */)(buf + *offset),
         sizeof(struct peer_addr ));
#line 151
  *offset += sizeof(struct peer_addr );
  }
#line 152
  return ((int )sizeof(struct peer_addr ));
}
}
#line 157 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.c"
static int unmarshall_uint32(u_int32_t *val , size_t *offset , u_int8_t const   *buf ) 
{ 


  {
#line 160
  *val = (u_int32_t )(((int const   )*(buf + *offset) & 255) << 24);
#line 161
  *val |= (unsigned int )(((int const   )*(buf + (*offset + 1UL)) & 255) << 16);
#line 162
  *val |= (unsigned int )(((int const   )*(buf + (*offset + 2UL)) & 255) << 8);
#line 163
  *val |= (unsigned int )((int const   )*(buf + (*offset + 3UL)) & 255);
#line 165
  *offset += 4UL;
#line 166
  return (4);
}
}
#line 171 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.c"
int unmarshall_n2n_packet_header(struct n2n_packet_header *hdr , u_int8_t const   *buf ) 
{ 
  size_t offset ;

  {
  {
#line 173
  offset = (size_t )0;
#line 175
  hdr->version = (u_int8_t )*(buf + offset);
#line 176
  offset ++;
#line 178
  hdr->msg_type = (u_int8_t )*(buf + offset);
#line 179
  offset ++;
#line 181
  hdr->ttl = (u_int8_t )*(buf + offset);
#line 182
  offset ++;
#line 184
  hdr->sent_by_supernode = (u_int8_t )*(buf + offset);
#line 185
  offset ++;
#line 187
  memcpy((void */* __restrict  */)(hdr->community_name), (void const   */* __restrict  */)(buf + offset),
         (size_t )16);
#line 188
  offset += 16UL;
#line 190
  memcpy((void */* __restrict  */)(hdr->src_mac), (void const   */* __restrict  */)(buf + offset),
         (size_t )6);
#line 191
  offset += 6UL;
#line 193
  memcpy((void */* __restrict  */)(hdr->dst_mac), (void const   */* __restrict  */)(buf + offset),
         (size_t )6);
#line 194
  offset += 6UL;
#line 196
  unmarshall_peer_addr(& hdr->public_ip, & offset, buf);
#line 197
  unmarshall_peer_addr(& hdr->private_ip, & offset, buf);
#line 199
  hdr->pkt_type = (enum packet_type )((int const   )*(buf + offset) & 255);
#line 200
  offset ++;
#line 202
  unmarshall_uint32(& hdr->sequence_id, & offset, buf);
#line 203
  unmarshall_uint32(& hdr->crc, & offset, buf);
#line 205
  print_header("Unmarshalled ", (struct n2n_packet_header  const  *)hdr);
  }
#line 207
  return ((int )offset);
}
}
#line 212 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.c"
int open_socket(int local_port , int udp_sock , int server_mode ) 
{ 
  int sock_fd ;
  struct sockaddr_in local_address ;
  int sockopt ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;

  {
#line 215
  sockopt = 1;
#line 217
  if (udp_sock) {
#line 217
    tmp___1 = 2;
  } else {
#line 217
    tmp___1 = 1;
  }
  {
#line 217
  sock_fd = socket(2, tmp___1, 0);
  }
#line 217
  if (sock_fd < 0) {
    {
#line 218
    tmp = __errno_location();
#line 218
    tmp___0 = strerror(*tmp);
#line 218
    traceEvent(0, (char *)"/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.c", 218,
               (char *)"Unable to create socket [%s][%d]\n", tmp___0, sock_fd);
    }
#line 220
    return (-1);
  }
  {
#line 227
  setsockopt(sock_fd, 1, 2, (void const   *)((char *)(& sockopt)), (socklen_t )sizeof(sockopt));
#line 229
  memset((void *)(& local_address), 0, sizeof(local_address));
#line 230
  local_address.sin_family = (sa_family_t )2;
#line 231
  local_address.sin_port = htons((uint16_t )local_port);
#line 232
  local_address.sin_addr.s_addr = (in_addr_t )0;
#line 233
  tmp___4 = bind(sock_fd, (struct sockaddr  const  *)((struct sockaddr *)(& local_address)),
                 (socklen_t )sizeof(local_address));
  }
#line 233
  if (tmp___4 == -1) {
    {
#line 234
    tmp___2 = __errno_location();
#line 234
    tmp___3 = strerror(*tmp___2);
#line 234
    traceEvent(0, (char *)"/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.c", 234,
               (char *)"Bind error [%s]\n", tmp___3);
    }
#line 235
    return (-1);
  }
#line 238
  if (! udp_sock) {
#line 238
    if (server_mode) {
      {
#line 239
      tmp___7 = listen(sock_fd, 255);
      }
#line 239
      if (tmp___7 == -1) {
        {
#line 240
        tmp___5 = __errno_location();
#line 240
        tmp___6 = strerror(*tmp___5);
#line 240
        traceEvent(0, (char *)"/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.c",
                   240, (char *)"Listen error [%s]\n", tmp___6);
        }
#line 241
        return (-1);
      }
    }
  }
#line 245
  return (sock_fd);
}
}
#line 250 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.c"
int connect_socket(int sock_fd , struct peer_addr *_dest ) 
{ 
  char *http_header ;
  int len ;
  int rc ;
  struct sockaddr_in dest ;
  int *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  ssize_t tmp___2 ;
  int tmp___3 ;

  {
  {
#line 255
  peer_addr2sockaddr_in((struct peer_addr  const  *)_dest, & dest);
#line 258
  rc = connect(sock_fd, (struct sockaddr  const  *)((struct sockaddr *)(& dest)),
               (socklen_t )sizeof(struct sockaddr_in ));
  }
#line 260
  if (rc == -1) {
    {
#line 261
    tmp = __errno_location();
#line 261
    tmp___0 = strerror(*tmp);
#line 261
    traceEvent(1, (char *)"/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.c", 261,
               (char *)"connect() error [%s]\n", tmp___0);
    }
#line 262
    return (-1);
  }
  {
#line 266
  http_header = (char *)"GET / HTTP/1.0\r\n\r\n";
#line 267
  tmp___1 = strlen((char const   *)http_header);
#line 267
  len = (int )tmp___1;
#line 268
  tmp___2 = send(sock_fd, (void const   *)http_header, (size_t )len, 0);
#line 268
  rc = (int )tmp___2;
  }
#line 270
  if (rc == len) {
#line 270
    tmp___3 = 0;
  } else {
#line 270
    tmp___3 = -1;
  }
#line 270
  return (tmp___3);
}
}
#line 276 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.c"
void send_packet(n2n_sock_info_t *sinfo , char *packet , size_t *packet_len , struct peer_addr  const  *remote_peer ,
                 u_int8_t compress_data ) 
{ 
  int data_sent_len ;
  u_int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 281
  tmp = unreliable_sendto(sinfo, packet, packet_len, remote_peer, compress_data);
#line 281
  data_sent_len = (int )tmp;
  }
#line 284
  if ((size_t )data_sent_len != *packet_len) {
    {
#line 285
    tmp___0 = __errno_location();
#line 285
    tmp___1 = strerror(*tmp___0);
#line 285
    traceEvent(1, (char *)"/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.c", 285,
               (char *)"sendto() [sent=%d][attempted_to_send=%d] [%s]\n", data_sent_len,
               *packet_len, tmp___1);
    }
  }
#line 288
  return;
}
}
#line 292 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.c"
int traceLevel  =    2;
#line 293 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.c"
int useSyslog  =    0;
#line 293 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.c"
int syslog_opened  =    0;
#line 296 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.c"
void traceEvent(int eventTraceLevel , char *file , int line , char *format  , ...) 
{ 
  va_list va_ap ;
  char buf[2048] ;
  char out_buf[640] ;
  char theDate[32] ;
  char *extra_msg ;
  time_t theTime ;
  time_t tmp ;
  struct tm *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
#line 299
  if (eventTraceLevel <= traceLevel) {
    {
#line 303
    extra_msg = (char *)"";
#line 304
    tmp = time((time_t *)((void *)0));
#line 304
    theTime = tmp;
#line 315
    memset((void *)(buf), 0, sizeof(buf));
#line 316
    tmp___0 = localtime((time_t const   *)(& theTime));
#line 316
    strftime((char */* __restrict  */)(theDate), (size_t )32, (char const   */* __restrict  */)"%d/%b/%Y %H:%M:%S",
             (struct tm  const  */* __restrict  */)tmp___0);
#line 318
    __builtin_va_start(va_ap, format);
#line 319
    vsnprintf((char */* __restrict  */)(buf), sizeof(buf) - 1UL, (char const   */* __restrict  */)format,
              va_ap);
#line 320
    __builtin_va_end(va_ap);
    }
#line 322
    if (eventTraceLevel == 0) {
#line 323
      extra_msg = (char *)"ERROR: ";
    } else
#line 324
    if (eventTraceLevel == 1) {
#line 325
      extra_msg = (char *)"WARNING: ";
    }
    {
#line 327
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 327
      tmp___2 = strlen((char const   *)(buf));
      }
#line 327
      if (! ((int )buf[tmp___2 - 1UL] == 10)) {
#line 327
        goto while_break;
      }
      {
#line 327
      tmp___1 = strlen((char const   *)(buf));
#line 327
      buf[tmp___1 - 1UL] = (char )'\000';
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 330
    if (useSyslog) {
#line 331
      if (! syslog_opened) {
        {
#line 332
        openlog("n2n", 1, 3 << 3);
#line 333
        syslog_opened = 1;
        }
      }
      {
#line 336
      snprintf((char */* __restrict  */)(out_buf), sizeof(out_buf), (char const   */* __restrict  */)"%s%s",
               extra_msg, buf);
#line 337
      syslog(6, "%s", out_buf);
      }
    } else {
      {
#line 339
      snprintf((char */* __restrict  */)(out_buf), sizeof(out_buf), (char const   */* __restrict  */)"%s [%11s:%4d] %s%s",
               theDate, file, line, extra_msg, buf);
#line 340
      printf((char const   */* __restrict  */)"%s\n", out_buf);
#line 341
      fflush(stdout);
      }
    }
  }
#line 352
  return;
}
}
#line 357 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.c"
char *intoa(u_int32_t addr , char *buf , u_short buf_len ) 
{ 
  char *cp ;
  char *retStr ;
  u_int byte ;
  int n ;

  {
#line 362
  cp = buf + buf_len;
#line 363
  cp --;
#line 363
  *cp = (char )'\000';
#line 365
  n = 4;
  {
#line 366
  while (1) {
    while_continue: /* CIL Label */ ;
#line 367
    byte = addr & 255U;
#line 368
    cp --;
#line 368
    *cp = (char )(byte % 10U + 48U);
#line 369
    byte /= 10U;
#line 370
    if (byte > 0U) {
#line 371
      cp --;
#line 371
      *cp = (char )(byte % 10U + 48U);
#line 372
      byte /= 10U;
#line 373
      if (byte > 0U) {
#line 374
        cp --;
#line 374
        *cp = (char )(byte + 48U);
      }
    }
#line 376
    cp --;
#line 376
    *cp = (char )'.';
#line 377
    addr >>= 8;
#line 366
    n --;
#line 366
    if (! (n > 0)) {
#line 366
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 381
  retStr = cp + 1;
#line 383
  return (retStr);
}
}
#line 388 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.c"
char *macaddr_str(char const   *mac , char *buf , int buf_len ) 
{ 


  {
  {
#line 389
  snprintf((char */* __restrict  */)buf, (size_t )buf_len, (char const   */* __restrict  */)"%02X:%02X:%02X:%02X:%02X:%02X",
           (int const   )*(mac + 0) & 255, (int const   )*(mac + 1) & 255, (int const   )*(mac + 2) & 255,
           (int const   )*(mac + 3) & 255, (int const   )*(mac + 4) & 255, (int const   )*(mac + 5) & 255);
  }
#line 392
  return (buf);
}
}
#line 397 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.c"
void fill_standard_header_fields(n2n_sock_info_t *sinfo , struct n2n_packet_header *hdr ,
                                 char *src_mac ) 
{ 
  socklen_t len ;

  {
  {
#line 399
  len = (socklen_t )sizeof(hdr->private_ip);
#line 400
  memset((void *)hdr, 0, sizeof(struct n2n_packet_header ));
#line 401
  hdr->version = (u_int8_t )1;
#line 402
  hdr->crc = (u_int32_t )0;
  }
#line 403
  if ((unsigned long )src_mac != (unsigned long )((void *)0)) {
    {
#line 403
    memcpy((void */* __restrict  */)(hdr->src_mac), (void const   */* __restrict  */)src_mac,
           (size_t )6);
    }
  }
  {
#line 404
  getsockname(sinfo->sock, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& hdr->private_ip)),
              (socklen_t */* __restrict  */)(& len));
#line 405
  hdr->public_ip.family = (u_int8_t )2;
  }
#line 406
  return;
}
}
#line 410 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.c"
void send_ack(n2n_sock_info_t *sinfo , u_int16_t last_rcvd_seq_id , struct n2n_packet_header *header ,
              struct peer_addr *remote_peer , char *src_mac ) 
{ 
  struct n2n_packet_header hdr ;
  u_int8_t pkt[sizeof(struct n2n_packet_header )] ;
  size_t len ;
  size_t len2 ;
  int compress_data ;
  int tmp ;

  {
  {
#line 419
  len = sizeof(hdr);
#line 421
  compress_data = 1;
#line 423
  fill_standard_header_fields(sinfo, & hdr, src_mac);
#line 424
  hdr.msg_type = (u_int8_t )5;
#line 425
  hdr.sequence_id = (u_int32_t )last_rcvd_seq_id;
#line 426
  memcpy((void */* __restrict  */)(hdr.community_name), (void const   */* __restrict  */)(header->community_name),
         (size_t )16);
#line 428
  tmp = marshall_n2n_packet_header(pkt, (struct n2n_packet_header  const  *)(& hdr));
#line 428
  len2 = (size_t )tmp;
  }
#line 429
  if (! (len2 == len)) {
    {
#line 429
    __assert_fail("len2 == len", "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.c",
                  429U, "send_ack");
    }
  }
  {
#line 431
  send_packet(sinfo, (char *)(pkt), & len, (struct peer_addr  const  *)remote_peer,
              (u_int8_t )compress_data);
  }
#line 432
  return;
}
}
#line 436 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.c"
u_int8_t is_multi_broadcast(char *dest_mac ) 
{ 
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 437
  tmp___2 = memcmp((void const   *)(broadcast_addr), (void const   *)dest_mac, (size_t )6);
  }
#line 437
  if (tmp___2) {
    {
#line 437
    tmp___3 = memcmp((void const   *)(multicast_addr), (void const   *)dest_mac, (size_t )3);
    }
#line 437
    if (tmp___3) {
#line 437
      tmp___1 = 0;
    } else {
#line 437
      tmp___1 = 1;
    }
  } else {
#line 437
    tmp___1 = 1;
  }
#line 437
  return ((u_int8_t )tmp___1);
}
}
#line 445 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.c"
u_int receive_data(n2n_sock_info_t *sinfo , char *packet , size_t packet_len , struct peer_addr *from ,
                   u_int8_t *discarded_pkt , char *tun_mac_addr , u_int8_t decompress_data ,
                   struct n2n_packet_header *hdr ) 
{ 
  socklen_t fromlen ;
  int len ;
  char *payload ;
  char *pkt_type ;
  macstr_t src_mac_buf ;
  macstr_t dst_mac_buf ;
  ipstr_t ip_buf ;
  ipstr_t from_ip_buf ;
  struct sockaddr_in _from ;
  ssize_t tmp ;
  ssize_t tmp___0 ;
  ssize_t tmp___1 ;
  char decompressed[2048] ;
  int rc ;
  lzo_uint decompressed_len ;
  size_t insize ;
  char *tmp___2 ;
  uint16_t tmp___3 ;
  uint32_t tmp___4 ;
  char *tmp___5 ;
  uint16_t tmp___6 ;
  uint32_t tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;

  {
#line 450
  fromlen = (socklen_t )sizeof(struct sockaddr_in );
#line 458
  if (sinfo->is_udp_socket) {
    {
#line 460
    tmp = recvfrom(sinfo->sock, (void */* __restrict  */)packet, packet_len, 0, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& _from)),
                   (socklen_t */* __restrict  */)(& fromlen));
#line 460
    len = (int )tmp;
#line 461
    sockaddr_in2peer_addr(& _from, from);
    }
  } else {
    {
#line 463
    tmp___0 = recv(sinfo->sock, (void *)packet, (size_t )4, 0);
#line 463
    len = (int )tmp___0;
    }
#line 464
    if (len == 4) {
      {
#line 465
      *(packet + 4) = (char )'\000';
#line 466
      len = atoi((char const   *)packet);
#line 467
      tmp___1 = recv(sinfo->sock, (void *)packet, (size_t )len, 0);
#line 467
      len = (int )tmp___1;
      }
    } else {
      {
#line 469
      traceEvent(1, (char *)"/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.c",
                 469, (char *)"Unable to receive n2n packet length");
      }
#line 470
      return ((u_int )-1);
    }
  }
  {
#line 474
  unmarshall_n2n_packet_header(hdr, (u_int8_t const   *)((u_int8_t *)packet));
#line 476
  payload = packet + sizeof(struct n2n_packet_header );
  }
#line 478
  if (len < 0) {
#line 484
    return ((u_int )0);
  } else
#line 485
  if (len > 32) {
#line 489
    decompressed_len = (lzo_uint )2048;
#line 490
    insize = (unsigned long )len - sizeof(struct n2n_packet_header );
#line 492
    if (decompress_data) {
      {
#line 493
      rc = lzo1x_decompress_safe((unsigned char const   *)((u_char *)(packet + sizeof(struct n2n_packet_header ))),
                                 insize, (u_char *)(decompressed), & decompressed_len,
                                 (void *)0);
      }
#line 497
      if (rc == 0) {
        {
#line 499
        traceEvent(3, (char *)"/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.c",
                   499, (char *)"%u bytes decompressed into %u", insize, decompressed_len);
        }
      } else {
        {
#line 503
        traceEvent(1, (char *)"/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.c",
                   503, (char *)"Failed to decompress %u byte packet. LZO error=%d",
                   insize, rc);
        }
#line 504
        return ((u_int )-1);
      }
#line 507
      if (packet_len > decompressed_len) {
        {
#line 508
        memcpy((void */* __restrict  */)(packet + sizeof(struct n2n_packet_header )),
               (void const   */* __restrict  */)(decompressed), decompressed_len);
#line 509
        len = (int )(decompressed_len + sizeof(struct n2n_packet_header ));
        }
      } else {
        {
#line 511
        traceEvent(1, (char *)"/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.c",
                   511, (char *)"Uncompressed packet is too large [decompressed_len=%d]",
                   decompressed_len);
        }
#line 513
        return ((u_int )0);
      }
    }
#line 517
    *discarded_pkt = (u_int8_t )0;
#line 519
    if (! hdr->sent_by_supernode) {
      {
#line 520
      memcpy((void */* __restrict  */)(packet + (unsigned long )(& ((struct n2n_packet_header *)0)->public_ip)),
             (void const   */* __restrict  */)from, sizeof(struct sockaddr_in ));
      }
    }
    {
#line 524
    if ((unsigned int )hdr->pkt_type == 0U) {
#line 524
      goto case_0;
    }
#line 527
    if ((unsigned int )hdr->pkt_type == 1U) {
#line 527
      goto case_1;
    }
#line 530
    if ((unsigned int )hdr->pkt_type == 2U) {
#line 530
      goto case_2;
    }
#line 533
    if ((unsigned int )hdr->pkt_type == 3U) {
#line 533
      goto case_3;
    }
#line 536
    goto switch_default;
    case_0: /* CIL Label */ 
#line 525
    pkt_type = (char *)"unreliable data";
#line 526
    goto switch_break;
    case_1: /* CIL Label */ 
#line 528
    pkt_type = (char *)"reliable data";
#line 529
    goto switch_break;
    case_2: /* CIL Label */ 
#line 531
    pkt_type = (char *)"ping";
#line 532
    goto switch_break;
    case_3: /* CIL Label */ 
#line 534
    pkt_type = (char *)"pong";
#line 535
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 537
    pkt_type = (char *)"???";
    switch_break: /* CIL Label */ ;
    }
    {
#line 540
    tmp___2 = msg_type2str((u_short )hdr->msg_type);
#line 540
    tmp___3 = ntohs(from->port);
#line 540
    tmp___4 = ntohl(from->addr_type.v4_addr);
#line 540
    tmp___5 = intoa(tmp___4, from_ip_buf, (u_short )sizeof(from_ip_buf));
#line 540
    traceEvent(3, (char *)"/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.c", 540,
               (char *)"+++ Received %s packet [rcvd_from=%s:%d][msg_type=%s][seq_id=%d]",
               pkt_type, tmp___5, (int )tmp___3, tmp___2, hdr->sequence_id);
#line 545
    tmp___6 = ntohs(hdr->public_ip.port);
#line 545
    tmp___7 = ntohl(hdr->public_ip.addr_type.v4_addr);
#line 545
    tmp___8 = intoa(tmp___7, ip_buf, (u_short )sizeof(ip_buf));
#line 545
    tmp___9 = macaddr_str((char const   *)(hdr->dst_mac), dst_mac_buf, (int )sizeof(dst_mac_buf));
#line 545
    tmp___10 = macaddr_str((char const   *)(hdr->src_mac), src_mac_buf, (int )sizeof(src_mac_buf));
#line 545
    traceEvent(3, (char *)"/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.c", 545,
               (char *)"    [src_mac=%s][dst_mac=%s][original_sender=%s:%d]", tmp___10,
               tmp___9, tmp___8, (int )tmp___6);
    }
  } else {
    {
#line 560
    tmp___11 = __errno_location();
#line 560
    tmp___12 = strerror(*tmp___11);
#line 560
    traceEvent(1, (char *)"/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.c", 560,
               (char *)"Receive error [%s] or pkt too short [len=%d]\n", tmp___12,
               len);
    }
  }
#line 563
  return ((u_int )len);
}
}
#line 603 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.c"
static lzo_align_t wrkmem[((unsigned long )((lzo_uint32 )(16384L * (long )((unsigned int )sizeof(unsigned char *)))) + (sizeof(lzo_align_t ) - 1UL)) / sizeof(lzo_align_t )]  ;
#line 607 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.c"
u_int send_data(n2n_sock_info_t *sinfo , char *packet , size_t *packet_len , struct peer_addr  const  *to ,
                u_int8_t compress_data ) 
{ 
  char compressed[1650] ;
  int rc ;
  lzo_uint compressed_len ;
  struct sockaddr_in destsock ;
  ssize_t tmp ;
  char send_len[5] ;
  ssize_t tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  ssize_t tmp___4 ;
  ssize_t tmp___5 ;
  char send_len___0[5] ;
  ssize_t tmp___6 ;
  ssize_t tmp___7 ;
  ipstr_t ip_buf ;
  uint16_t tmp___8 ;
  uint32_t tmp___9 ;
  char *tmp___10 ;

  {
#line 612
  compressed_len = (lzo_uint )0;
#line 615
  if (*packet_len < sizeof(struct n2n_packet_header )) {
    {
#line 616
    traceEvent(1, (char *)"/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.c", 616,
               (char *)"The packet about to be sent is too short [len=%d]\n", *packet_len);
    }
#line 617
    return ((u_int )-1);
  }
  {
#line 620
  memcpy((void */* __restrict  */)(compressed), (void const   */* __restrict  */)packet,
         sizeof(struct n2n_packet_header ));
#line 622
  peer_addr2sockaddr_in(to, & destsock);
  }
#line 624
  if (compress_data) {
    {
#line 625
    rc = lzo1x_1_compress((unsigned char const   *)((u_char *)(packet + sizeof(struct n2n_packet_header ))),
                          *packet_len - sizeof(struct n2n_packet_header ), (u_char *)(& compressed[sizeof(struct n2n_packet_header )]),
                          & compressed_len, (void *)(wrkmem));
    }
#line 630
    if (0UL == compressed_len) {
      {
#line 632
      traceEvent(1, (char *)"/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.c",
                 632, (char *)"failed to compress %u bytes.", *packet_len - sizeof(struct n2n_packet_header ));
      }
#line 633
      return ((u_int )-1);
    }
    {
#line 636
    compressed_len += sizeof(struct n2n_packet_header );
#line 638
    traceEvent(3, (char *)"/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.c", 638,
               (char *)"%u bytes compressed into %u", *packet_len, compressed_len);
    }
#line 641
    if (sinfo->is_udp_socket) {
      {
#line 642
      tmp = sendto(sinfo->sock, (void const   *)(compressed), compressed_len, 0, (struct sockaddr  const  *)((struct sockaddr *)(& destsock)),
                   (socklen_t )sizeof(struct sockaddr_in ));
#line 642
      rc = (int )tmp;
      }
    } else {
      {
#line 648
      snprintf((char */* __restrict  */)(send_len), sizeof(send_len), (char const   */* __restrict  */)"%04d",
               (int )compressed_len);
#line 649
      tmp___0 = send(sinfo->sock, (void const   *)(send_len), (size_t )4, 0);
#line 649
      rc = (int )tmp___0;
      }
#line 649
      if (rc != 4) {
#line 650
        return ((u_int )-1);
      }
      {
#line 651
      tmp___4 = send(sinfo->sock, (void const   *)(compressed), compressed_len, 0);
#line 651
      rc = (int )tmp___4;
      }
#line 651
      if ((lzo_uint )rc != compressed_len) {
        {
#line 652
        tmp___1 = __errno_location();
#line 652
        tmp___2 = strerror(*tmp___1);
#line 652
        tmp___3 = __errno_location();
#line 652
        traceEvent(1, (char *)"/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.c",
                   652, (char *)"send error [%d][%s]", *tmp___3, tmp___2);
        }
      }
    }
  } else {
#line 657
    compressed_len = *packet_len;
#line 658
    if (sinfo->is_udp_socket) {
      {
#line 659
      tmp___5 = sendto(sinfo->sock, (void const   *)packet, compressed_len, 0, (struct sockaddr  const  *)((struct sockaddr *)(& destsock)),
                       (socklen_t )sizeof(struct sockaddr_in ));
#line 659
      rc = (int )tmp___5;
      }
    } else {
      {
#line 665
      snprintf((char */* __restrict  */)(send_len___0), sizeof(send_len___0), (char const   */* __restrict  */)"%04d",
               (int )compressed_len);
#line 666
      tmp___6 = send(sinfo->sock, (void const   *)(send_len___0), (size_t )4, 0);
#line 666
      rc = (int )tmp___6;
      }
#line 666
      if (rc != 4) {
#line 667
        return ((u_int )-1);
      }
      {
#line 668
      tmp___7 = send(sinfo->sock, (void const   *)(compressed), compressed_len, 0);
#line 668
      rc = (int )tmp___7;
      }
    }
#line 671
    if (rc == -1) {
      {
#line 674
      tmp___8 = ntohs((uint16_t )to->port);
#line 674
      tmp___9 = ntohl((uint32_t )to->addr_type.v4_addr);
#line 674
      tmp___10 = intoa(tmp___9, ip_buf, (u_short )sizeof(ip_buf));
#line 674
      traceEvent(1, (char *)"/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.c",
                 674, (char *)"sendto() failed while attempting to send data to %s:%d",
                 tmp___10, (int )tmp___8);
      }
    }
  }
#line 680
  if (rc >= 0) {
    {
#line 681
    traceEvent(3, (char *)"/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.c", 681,
               (char *)"### Tx N2N Msg -> network");
    }
  }
#line 684
  if ((lzo_uint )rc == compressed_len) {
#line 685
    return ((u_int )*packet_len);
  } else {
#line 687
    return ((u_int )rc);
  }
}
}
#line 692 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.c"
u_int reliable_sendto(n2n_sock_info_t *sinfo , char *packet , size_t *packet_len ,
                      struct peer_addr  const  *to , u_int8_t compress_data ) 
{ 
  struct n2n_packet_header hdr_storage ;
  struct n2n_packet_header *hdr ;
  macstr_t src_mac_buf ;
  macstr_t dst_mac_buf ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  u_int tmp___2 ;

  {
  {
#line 697
  hdr = & hdr_storage;
#line 702
  unmarshall_n2n_packet_header(hdr, (u_int8_t const   *)((u_int8_t *)packet));
#line 705
  hdr->sequence_id = (u_int32_t )0;
#line 706
  hdr->pkt_type = (enum packet_type )1;
#line 708
  tmp = macaddr_str((char const   *)packet, dst_mac_buf, (int )sizeof(dst_mac_buf));
#line 708
  tmp___0 = macaddr_str((char const   *)(packet + 6), src_mac_buf, (int )sizeof(src_mac_buf));
#line 708
  tmp___1 = msg_type2str((u_short )hdr->msg_type);
#line 708
  traceEvent(3, (char *)"/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.c", 708,
             (char *)"Sent reliable packet [msg_type=%s][seq_id=%d][src_mac=%s][dst_mac=%s]",
             tmp___1, hdr->sequence_id, tmp___0, tmp);
#line 713
  marshall_n2n_packet_header((u_int8_t *)packet, (struct n2n_packet_header  const  *)hdr);
#line 715
  tmp___2 = send_data(sinfo, packet, packet_len, to, compress_data);
  }
#line 715
  return (tmp___2);
}
}
#line 722 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.c"
u_int unreliable_sendto(n2n_sock_info_t *sinfo , char *packet , size_t *packet_len ,
                        struct peer_addr  const  *to , u_int8_t compress_data ) 
{ 
  struct n2n_packet_header hdr_storage ;
  struct n2n_packet_header *hdr ;
  macstr_t src_mac_buf ;
  macstr_t dst_mac_buf ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  u_int tmp___2 ;

  {
  {
#line 726
  hdr = & hdr_storage;
#line 731
  unmarshall_n2n_packet_header(hdr, (u_int8_t const   *)((u_int8_t *)packet));
#line 733
  hdr->sequence_id = (u_int32_t )0;
#line 734
  hdr->pkt_type = (enum packet_type )0;
#line 736
  tmp = macaddr_str((char const   *)(hdr->dst_mac), dst_mac_buf, (int )sizeof(dst_mac_buf));
#line 736
  tmp___0 = macaddr_str((char const   *)(hdr->src_mac), src_mac_buf, (int )sizeof(src_mac_buf));
#line 736
  tmp___1 = msg_type2str((u_short )hdr->msg_type);
#line 736
  traceEvent(3, (char *)"/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.c", 736,
             (char *)"Sent unreliable packet [msg_type=%s][seq_id=%d][src_mac=%s][dst_mac=%s]",
             tmp___1, hdr->sequence_id, tmp___0, tmp);
#line 741
  marshall_n2n_packet_header((u_int8_t *)packet, (struct n2n_packet_header  const  *)hdr);
#line 743
  tmp___2 = send_data(sinfo, packet, packet_len, to, compress_data);
  }
#line 743
  return (tmp___2);
}
}
#line 748 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.c"
char *msg_type2str(u_short msg_type ) 
{ 


  {
  {
#line 750
  if ((int )msg_type == 1) {
#line 750
    goto case_1;
  }
#line 751
  if ((int )msg_type == 2) {
#line 751
    goto case_2;
  }
#line 752
  if ((int )msg_type == 3) {
#line 752
    goto case_3;
  }
#line 753
  if ((int )msg_type == 4) {
#line 753
    goto case_4;
  }
#line 754
  if ((int )msg_type == 5) {
#line 754
    goto case_5;
  }
#line 749
  goto switch_break;
  case_1: /* CIL Label */ 
#line 750
  return ((char *)"MSG_TYPE_REGISTER");
  case_2: /* CIL Label */ 
#line 751
  return ((char *)"MSG_TYPE_DEREGISTER");
  case_3: /* CIL Label */ 
#line 752
  return ((char *)"MSG_TYPE_PACKET");
  case_4: /* CIL Label */ 
#line 753
  return ((char *)"MSG_TYPE_REGISTER_ACK");
  case_5: /* CIL Label */ 
#line 754
  return ((char *)"MSG_TYPE_ACK_RESPONSE");
  switch_break: /* CIL Label */ ;
  }
#line 757
  return ((char *)"???");
}
}
#line 762 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.c"
void hexdump(char *buf , u_int len ) 
{ 
  u_int i ;

  {
#line 765
  i = (u_int )0;
  {
#line 765
  while (1) {
    while_continue: /* CIL Label */ ;
#line 765
    if (! (i < len)) {
#line 765
      goto while_break;
    }
#line 766
    if (i > 0U) {
#line 766
      if (i % 16U == 0U) {
        {
#line 766
        printf((char const   */* __restrict  */)"\n");
        }
      }
    }
    {
#line 767
    printf((char const   */* __restrict  */)"%02X ", (int )*(buf + i) & 255);
#line 765
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 770
  printf((char const   */* __restrict  */)"\n");
  }
#line 771
  return;
}
}
#line 775 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.c"
void print_n2n_version(void) 
{ 


  {
  {
#line 776
  printf((char const   */* __restrict  */)"Welcome to n2n v.%s for %s\nBuilt on %s\nCopyright 2007-08 - http://www.ntop.org\n\n",
         version, osName, buildDate);
  }
#line 780
  return;
}
}
#line 791 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.c"
struct peer_info *find_peer_by_mac(struct peer_info *list , char const   *mac ) 
{ 
  int tmp ;

  {
  {
#line 793
  while (1) {
    while_continue: /* CIL Label */ ;
#line 793
    if (! ((unsigned long )list != (unsigned long )((void *)0))) {
#line 793
      goto while_break;
    }
    {
#line 795
    tmp = memcmp((void const   *)mac, (void const   *)(list->mac_addr), (size_t )6);
    }
#line 795
    if (0 == tmp) {
#line 797
      return (list);
    }
#line 799
    list = list->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 802
  return ((struct peer_info *)((void *)0));
}
}
#line 809 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.c"
size_t peer_list_size(struct peer_info  const  *list ) 
{ 
  size_t retval ;

  {
#line 811
  retval = (size_t )0;
  {
#line 813
  while (1) {
    while_continue: /* CIL Label */ ;
#line 813
    if (! list) {
#line 813
      goto while_break;
    }
#line 815
    retval ++;
#line 816
    list = (struct peer_info  const  *)list->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 819
  return (retval);
}
}
#line 827 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.c"
void peer_list_add(struct peer_info **list , struct peer_info *new ) 
{ 


  {
  {
#line 830
  new->next = *list;
#line 831
  new->last_seen = time((time_t *)((void *)0));
#line 832
  *list = new;
  }
#line 833
  return;
}
}
#line 837 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.c"
static time_t last_purge  =    (time_t )0;
#line 836 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.c"
size_t purge_expired_registrations(struct peer_info **peer_list ) 
{ 
  time_t now ;
  time_t tmp ;
  size_t num_reg ;

  {
  {
#line 838
  tmp = time((time_t *)((void *)0));
#line 838
  now = tmp;
#line 839
  num_reg = (size_t )0;
  }
#line 841
  if (now - last_purge < 60L) {
#line 841
    return ((size_t )0);
  }
  {
#line 843
  traceEvent(3, (char *)"/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.c", 843,
             (char *)"Purging old registrations");
#line 845
  num_reg = purge_peer_list(peer_list, now - 300L);
#line 847
  last_purge = now;
#line 848
  traceEvent(3, (char *)"/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.c", 848,
             (char *)"Remove %ld registrations", num_reg);
  }
#line 850
  return (num_reg);
}
}
#line 854 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.c"
size_t purge_peer_list(struct peer_info **peer_list , time_t purge_before ) 
{ 
  struct peer_info *scan ;
  struct peer_info *prev ;
  size_t retval ;
  struct peer_info *next ;

  {
#line 859
  retval = (size_t )0;
#line 861
  scan = *peer_list;
#line 862
  prev = (struct peer_info *)((void *)0);
  {
#line 863
  while (1) {
    while_continue: /* CIL Label */ ;
#line 863
    if (! ((unsigned long )scan != (unsigned long )((void *)0))) {
#line 863
      goto while_break;
    }
#line 865
    if (scan->last_seen < purge_before) {
#line 867
      next = scan->next;
#line 869
      if ((unsigned long )prev == (unsigned long )((void *)0)) {
#line 871
        *peer_list = next;
      } else {
#line 875
        prev->next = next;
      }
      {
#line 878
      retval ++;
#line 879
      free((void *)scan);
#line 880
      scan = next;
      }
    } else {
#line 884
      prev = scan;
#line 885
      scan = scan->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 889
  return (retval);
}
}
#line 892 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.c"
static u_int8_t hex2byte(char const   *s ) 
{ 
  char tmp[3] ;
  long tmp___0 ;

  {
  {
#line 895
  tmp[0] = (char )*(s + 0);
#line 896
  tmp[1] = (char )*(s + 1);
#line 897
  tmp[2] = (char)0;
#line 899
  tmp___0 = strtol((char const   */* __restrict  */)s, (char **/* __restrict  */)((void *)0),
                   16);
  }
#line 899
  return ((u_int8_t )tmp___0);
}
}
#line 902 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.c"
extern int str2mac(u_int8_t *outmac , char const   *s ) 
{ 
  size_t i ;

  {
  {
#line 909
  *outmac = hex2byte(s);
#line 910
  outmac ++;
#line 911
  s += 2;
#line 913
  i = (size_t )1;
  }
  {
#line 913
  while (1) {
    while_continue: /* CIL Label */ ;
#line 913
    if (! (i < 6UL)) {
#line 913
      goto while_break;
    }
    {
#line 915
    s ++;
#line 916
    *outmac = hex2byte(s);
#line 917
    outmac ++;
#line 918
    s += 2;
#line 913
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 921
  return (0);
}
}
#line 1 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/version.c"
char const   *version  =    "1.3.2";
#line 2 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/version.c"
char const   *osName  =    "x86_64";
#line 3 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/version.c"
char const   *buildDate  =    "03/03/16 \354\230\244\355\233\204 06\354\213\234 04\353\266\204 14\354\264\210";
#line 374 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rand)(void) ;
#line 376
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srand)(unsigned int __seed ) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 124 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 138 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/twofish.h"
TWOFISH *TwoFishInit(u_int8_t const   *userkey , u_int32_t keysize ) ;
#line 148
void TwoFishDestroy(TWOFISH *tfdata ) ;
#line 161
void *TwoFishAlloc(u_int32_t len , int binhex , int decrypt , TWOFISH *tfdata ) ;
#line 172
void TwoFishFree(TWOFISH *tfdata ) ;
#line 185
void TwoFishSetOutput(u_int8_t *outp , TWOFISH *tfdata ) ;
#line 199
u_int32_t TwoFishEncryptRaw(u_int8_t *in , u_int8_t *out , u_int32_t len , TWOFISH *tfdata ) ;
#line 212
u_int32_t TwoFishDecryptRaw(u_int8_t *in , u_int8_t *out , u_int32_t len , TWOFISH *tfdata ) ;
#line 234
u_int32_t TwoFishEncrypt(u_int8_t *in , u_int8_t **out , long len , int binhex , TWOFISH *tfdata ) ;
#line 256
u_int32_t TwoFishDecrypt(u_int8_t *in , u_int8_t **out , long len , int binhex , TWOFISH *tfdata ) ;
#line 261
u_int8_t TwoFish__b(u_int32_t x , int n ) ;
#line 262
void _TwoFish_BinHex(u_int8_t *buf , u_int32_t len , int bintohex ) ;
#line 263
u_int32_t _TwoFish_CryptRawCBC(u_int8_t *in , u_int8_t *out , u_int32_t len , int decrypt ,
                               TWOFISH *tfdata ) ;
#line 264
u_int32_t _TwoFish_CryptRaw16(u_int8_t *in , u_int8_t *out , u_int32_t len , int decrypt ,
                              TWOFISH *tfdata ) ;
#line 265
u_int32_t _TwoFish_CryptRaw(u_int8_t *in , u_int8_t *out , u_int32_t len , int decrypt ,
                            TWOFISH *tfdata ) ;
#line 266
void _TwoFish_PrecomputeMDSmatrix(void) ;
#line 267
void _TwoFish_MakeSubKeys(TWOFISH *tfdata ) ;
#line 268
void _TwoFish_qBlockPush(u_int8_t *p , u_int8_t *c , TWOFISH *tfdata ) ;
#line 269
void _TwoFish_qBlockPop(u_int8_t *p , u_int8_t *c , TWOFISH *tfdata ) ;
#line 270
void _TwoFish_ResetCBC(TWOFISH *tfdata ) ;
#line 271
void _TwoFish_FlushOutput(u_int8_t *b , u_int32_t len , TWOFISH *tfdata ) ;
#line 272
void _TwoFish_BlockCrypt(u_int8_t *in , u_int8_t *out , u_int32_t size , int decrypt ,
                         TWOFISH *tfdata ) ;
#line 273
void _TwoFish_BlockCrypt16(u_int8_t *in , u_int8_t *out , int decrypt , TWOFISH *tfdata ) ;
#line 274
u_int32_t _TwoFish_RS_MDS_Encode(u_int32_t k0 , u_int32_t k1 ) ;
#line 275
u_int32_t _TwoFish_F32(u_int32_t k64Cnt , u_int32_t x , u_int32_t *k32 ) ;
#line 276
u_int32_t _TwoFish_Fe320(u_int32_t *lsBox , u_int32_t x ) ;
#line 277
u_int32_t _TwoFish_Fe323(u_int32_t *lsBox , u_int32_t x ) ;
#line 278
u_int32_t _TwoFish_Fe32(u_int32_t *lsBox , u_int32_t x , u_int32_t R ) ;
#line 46 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/twofish.c"
int TwoFish_srand  =    1;
#line 50 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/twofish.c"
static u_int8_t const   TwoFish_P[2][256]  = { {        (u_int8_t const   )169,        (u_int8_t const   )103,        (u_int8_t const   )179,        (u_int8_t const   )232, 
            (u_int8_t const   )4,        (u_int8_t const   )253,        (u_int8_t const   )163,        (u_int8_t const   )118, 
            (u_int8_t const   )154,        (u_int8_t const   )146,        (u_int8_t const   )128,        (u_int8_t const   )120, 
            (u_int8_t const   )228,        (u_int8_t const   )221,        (u_int8_t const   )209,        (u_int8_t const   )56, 
            (u_int8_t const   )13,        (u_int8_t const   )198,        (u_int8_t const   )53,        (u_int8_t const   )152, 
            (u_int8_t const   )24,        (u_int8_t const   )247,        (u_int8_t const   )236,        (u_int8_t const   )108, 
            (u_int8_t const   )67,        (u_int8_t const   )117,        (u_int8_t const   )55,        (u_int8_t const   )38, 
            (u_int8_t const   )250,        (u_int8_t const   )19,        (u_int8_t const   )148,        (u_int8_t const   )72, 
            (u_int8_t const   )242,        (u_int8_t const   )208,        (u_int8_t const   )139,        (u_int8_t const   )48, 
            (u_int8_t const   )132,        (u_int8_t const   )84,        (u_int8_t const   )223,        (u_int8_t const   )35, 
            (u_int8_t const   )25,        (u_int8_t const   )91,        (u_int8_t const   )61,        (u_int8_t const   )89, 
            (u_int8_t const   )243,        (u_int8_t const   )174,        (u_int8_t const   )162,        (u_int8_t const   )130, 
            (u_int8_t const   )99,        (u_int8_t const   )1,        (u_int8_t const   )131,        (u_int8_t const   )46, 
            (u_int8_t const   )217,        (u_int8_t const   )81,        (u_int8_t const   )155,        (u_int8_t const   )124, 
            (u_int8_t const   )166,        (u_int8_t const   )235,        (u_int8_t const   )165,        (u_int8_t const   )190, 
            (u_int8_t const   )22,        (u_int8_t const   )12,        (u_int8_t const   )227,        (u_int8_t const   )97, 
            (u_int8_t const   )192,        (u_int8_t const   )140,        (u_int8_t const   )58,        (u_int8_t const   )245, 
            (u_int8_t const   )115,        (u_int8_t const   )44,        (u_int8_t const   )37,        (u_int8_t const   )11, 
            (u_int8_t const   )187,        (u_int8_t const   )78,        (u_int8_t const   )137,        (u_int8_t const   )107, 
            (u_int8_t const   )83,        (u_int8_t const   )106,        (u_int8_t const   )180,        (u_int8_t const   )241, 
            (u_int8_t const   )225,        (u_int8_t const   )230,        (u_int8_t const   )189,        (u_int8_t const   )69, 
            (u_int8_t const   )226,        (u_int8_t const   )244,        (u_int8_t const   )182,        (u_int8_t const   )102, 
            (u_int8_t const   )204,        (u_int8_t const   )149,        (u_int8_t const   )3,        (u_int8_t const   )86, 
            (u_int8_t const   )212,        (u_int8_t const   )28,        (u_int8_t const   )30,        (u_int8_t const   )215, 
            (u_int8_t const   )251,        (u_int8_t const   )195,        (u_int8_t const   )142,        (u_int8_t const   )181, 
            (u_int8_t const   )233,        (u_int8_t const   )207,        (u_int8_t const   )191,        (u_int8_t const   )186, 
            (u_int8_t const   )234,        (u_int8_t const   )119,        (u_int8_t const   )57,        (u_int8_t const   )175, 
            (u_int8_t const   )51,        (u_int8_t const   )201,        (u_int8_t const   )98,        (u_int8_t const   )113, 
            (u_int8_t const   )129,        (u_int8_t const   )121,        (u_int8_t const   )9,        (u_int8_t const   )173, 
            (u_int8_t const   )36,        (u_int8_t const   )205,        (u_int8_t const   )249,        (u_int8_t const   )216, 
            (u_int8_t const   )229,        (u_int8_t const   )197,        (u_int8_t const   )185,        (u_int8_t const   )77, 
            (u_int8_t const   )68,        (u_int8_t const   )8,        (u_int8_t const   )134,        (u_int8_t const   )231, 
            (u_int8_t const   )161,        (u_int8_t const   )29,        (u_int8_t const   )170,        (u_int8_t const   )237, 
            (u_int8_t const   )6,        (u_int8_t const   )112,        (u_int8_t const   )178,        (u_int8_t const   )210, 
            (u_int8_t const   )65,        (u_int8_t const   )123,        (u_int8_t const   )160,        (u_int8_t const   )17, 
            (u_int8_t const   )49,        (u_int8_t const   )194,        (u_int8_t const   )39,        (u_int8_t const   )144, 
            (u_int8_t const   )32,        (u_int8_t const   )246,        (u_int8_t const   )96,        (u_int8_t const   )255, 
            (u_int8_t const   )150,        (u_int8_t const   )92,        (u_int8_t const   )177,        (u_int8_t const   )171, 
            (u_int8_t const   )158,        (u_int8_t const   )156,        (u_int8_t const   )82,        (u_int8_t const   )27, 
            (u_int8_t const   )95,        (u_int8_t const   )147,        (u_int8_t const   )10,        (u_int8_t const   )239, 
            (u_int8_t const   )145,        (u_int8_t const   )133,        (u_int8_t const   )73,        (u_int8_t const   )238, 
            (u_int8_t const   )45,        (u_int8_t const   )79,        (u_int8_t const   )143,        (u_int8_t const   )59, 
            (u_int8_t const   )71,        (u_int8_t const   )135,        (u_int8_t const   )109,        (u_int8_t const   )70, 
            (u_int8_t const   )214,        (u_int8_t const   )62,        (u_int8_t const   )105,        (u_int8_t const   )100, 
            (u_int8_t const   )42,        (u_int8_t const   )206,        (u_int8_t const   )203,        (u_int8_t const   )47, 
            (u_int8_t const   )252,        (u_int8_t const   )151,        (u_int8_t const   )5,        (u_int8_t const   )122, 
            (u_int8_t const   )172,        (u_int8_t const   )127,        (u_int8_t const   )213,        (u_int8_t const   )26, 
            (u_int8_t const   )75,        (u_int8_t const   )14,        (u_int8_t const   )167,        (u_int8_t const   )90, 
            (u_int8_t const   )40,        (u_int8_t const   )20,        (u_int8_t const   )63,        (u_int8_t const   )41, 
            (u_int8_t const   )136,        (u_int8_t const   )60,        (u_int8_t const   )76,        (u_int8_t const   )2, 
            (u_int8_t const   )184,        (u_int8_t const   )218,        (u_int8_t const   )176,        (u_int8_t const   )23, 
            (u_int8_t const   )85,        (u_int8_t const   )31,        (u_int8_t const   )138,        (u_int8_t const   )125, 
            (u_int8_t const   )87,        (u_int8_t const   )199,        (u_int8_t const   )141,        (u_int8_t const   )116, 
            (u_int8_t const   )183,        (u_int8_t const   )196,        (u_int8_t const   )159,        (u_int8_t const   )114, 
            (u_int8_t const   )126,        (u_int8_t const   )21,        (u_int8_t const   )34,        (u_int8_t const   )18, 
            (u_int8_t const   )88,        (u_int8_t const   )7,        (u_int8_t const   )153,        (u_int8_t const   )52, 
            (u_int8_t const   )110,        (u_int8_t const   )80,        (u_int8_t const   )222,        (u_int8_t const   )104, 
            (u_int8_t const   )101,        (u_int8_t const   )188,        (u_int8_t const   )219,        (u_int8_t const   )248, 
            (u_int8_t const   )200,        (u_int8_t const   )168,        (u_int8_t const   )43,        (u_int8_t const   )64, 
            (u_int8_t const   )220,        (u_int8_t const   )254,        (u_int8_t const   )50,        (u_int8_t const   )164, 
            (u_int8_t const   )202,        (u_int8_t const   )16,        (u_int8_t const   )33,        (u_int8_t const   )240, 
            (u_int8_t const   )211,        (u_int8_t const   )93,        (u_int8_t const   )15,        (u_int8_t const   )0, 
            (u_int8_t const   )111,        (u_int8_t const   )157,        (u_int8_t const   )54,        (u_int8_t const   )66, 
            (u_int8_t const   )74,        (u_int8_t const   )94,        (u_int8_t const   )193,        (u_int8_t const   )224}, 
   {        (u_int8_t const   )117,        (u_int8_t const   )243,        (u_int8_t const   )198,        (u_int8_t const   )244, 
            (u_int8_t const   )219,        (u_int8_t const   )123,        (u_int8_t const   )251,        (u_int8_t const   )200, 
            (u_int8_t const   )74,        (u_int8_t const   )211,        (u_int8_t const   )230,        (u_int8_t const   )107, 
            (u_int8_t const   )69,        (u_int8_t const   )125,        (u_int8_t const   )232,        (u_int8_t const   )75, 
            (u_int8_t const   )214,        (u_int8_t const   )50,        (u_int8_t const   )216,        (u_int8_t const   )253, 
            (u_int8_t const   )55,        (u_int8_t const   )113,        (u_int8_t const   )241,        (u_int8_t const   )225, 
            (u_int8_t const   )48,        (u_int8_t const   )15,        (u_int8_t const   )248,        (u_int8_t const   )27, 
            (u_int8_t const   )135,        (u_int8_t const   )250,        (u_int8_t const   )6,        (u_int8_t const   )63, 
            (u_int8_t const   )94,        (u_int8_t const   )186,        (u_int8_t const   )174,        (u_int8_t const   )91, 
            (u_int8_t const   )138,        (u_int8_t const   )0,        (u_int8_t const   )188,        (u_int8_t const   )157, 
            (u_int8_t const   )109,        (u_int8_t const   )193,        (u_int8_t const   )177,        (u_int8_t const   )14, 
            (u_int8_t const   )128,        (u_int8_t const   )93,        (u_int8_t const   )210,        (u_int8_t const   )213, 
            (u_int8_t const   )160,        (u_int8_t const   )132,        (u_int8_t const   )7,        (u_int8_t const   )20, 
            (u_int8_t const   )181,        (u_int8_t const   )144,        (u_int8_t const   )44,        (u_int8_t const   )163, 
            (u_int8_t const   )178,        (u_int8_t const   )115,        (u_int8_t const   )76,        (u_int8_t const   )84, 
            (u_int8_t const   )146,        (u_int8_t const   )116,        (u_int8_t const   )54,        (u_int8_t const   )81, 
            (u_int8_t const   )56,        (u_int8_t const   )176,        (u_int8_t const   )189,        (u_int8_t const   )90, 
            (u_int8_t const   )252,        (u_int8_t const   )96,        (u_int8_t const   )98,        (u_int8_t const   )150, 
            (u_int8_t const   )108,        (u_int8_t const   )66,        (u_int8_t const   )247,        (u_int8_t const   )16, 
            (u_int8_t const   )124,        (u_int8_t const   )40,        (u_int8_t const   )39,        (u_int8_t const   )140, 
            (u_int8_t const   )19,        (u_int8_t const   )149,        (u_int8_t const   )156,        (u_int8_t const   )199, 
            (u_int8_t const   )36,        (u_int8_t const   )70,        (u_int8_t const   )59,        (u_int8_t const   )112, 
            (u_int8_t const   )202,        (u_int8_t const   )227,        (u_int8_t const   )133,        (u_int8_t const   )203, 
            (u_int8_t const   )17,        (u_int8_t const   )208,        (u_int8_t const   )147,        (u_int8_t const   )184, 
            (u_int8_t const   )166,        (u_int8_t const   )131,        (u_int8_t const   )32,        (u_int8_t const   )255, 
            (u_int8_t const   )159,        (u_int8_t const   )119,        (u_int8_t const   )195,        (u_int8_t const   )204, 
            (u_int8_t const   )3,        (u_int8_t const   )111,        (u_int8_t const   )8,        (u_int8_t const   )191, 
            (u_int8_t const   )64,        (u_int8_t const   )231,        (u_int8_t const   )43,        (u_int8_t const   )226, 
            (u_int8_t const   )121,        (u_int8_t const   )12,        (u_int8_t const   )170,        (u_int8_t const   )130, 
            (u_int8_t const   )65,        (u_int8_t const   )58,        (u_int8_t const   )234,        (u_int8_t const   )185, 
            (u_int8_t const   )228,        (u_int8_t const   )154,        (u_int8_t const   )164,        (u_int8_t const   )151, 
            (u_int8_t const   )126,        (u_int8_t const   )218,        (u_int8_t const   )122,        (u_int8_t const   )23, 
            (u_int8_t const   )102,        (u_int8_t const   )148,        (u_int8_t const   )161,        (u_int8_t const   )29, 
            (u_int8_t const   )61,        (u_int8_t const   )240,        (u_int8_t const   )222,        (u_int8_t const   )179, 
            (u_int8_t const   )11,        (u_int8_t const   )114,        (u_int8_t const   )167,        (u_int8_t const   )28, 
            (u_int8_t const   )239,        (u_int8_t const   )209,        (u_int8_t const   )83,        (u_int8_t const   )62, 
            (u_int8_t const   )143,        (u_int8_t const   )51,        (u_int8_t const   )38,        (u_int8_t const   )95, 
            (u_int8_t const   )236,        (u_int8_t const   )118,        (u_int8_t const   )42,        (u_int8_t const   )73, 
            (u_int8_t const   )129,        (u_int8_t const   )136,        (u_int8_t const   )238,        (u_int8_t const   )33, 
            (u_int8_t const   )196,        (u_int8_t const   )26,        (u_int8_t const   )235,        (u_int8_t const   )217, 
            (u_int8_t const   )197,        (u_int8_t const   )57,        (u_int8_t const   )153,        (u_int8_t const   )205, 
            (u_int8_t const   )173,        (u_int8_t const   )49,        (u_int8_t const   )139,        (u_int8_t const   )1, 
            (u_int8_t const   )24,        (u_int8_t const   )35,        (u_int8_t const   )221,        (u_int8_t const   )31, 
            (u_int8_t const   )78,        (u_int8_t const   )45,        (u_int8_t const   )249,        (u_int8_t const   )72, 
            (u_int8_t const   )79,        (u_int8_t const   )242,        (u_int8_t const   )101,        (u_int8_t const   )142, 
            (u_int8_t const   )120,        (u_int8_t const   )92,        (u_int8_t const   )88,        (u_int8_t const   )25, 
            (u_int8_t const   )141,        (u_int8_t const   )229,        (u_int8_t const   )152,        (u_int8_t const   )87, 
            (u_int8_t const   )103,        (u_int8_t const   )127,        (u_int8_t const   )5,        (u_int8_t const   )100, 
            (u_int8_t const   )175,        (u_int8_t const   )99,        (u_int8_t const   )182,        (u_int8_t const   )254, 
            (u_int8_t const   )245,        (u_int8_t const   )183,        (u_int8_t const   )60,        (u_int8_t const   )165, 
            (u_int8_t const   )206,        (u_int8_t const   )233,        (u_int8_t const   )104,        (u_int8_t const   )68, 
            (u_int8_t const   )224,        (u_int8_t const   )77,        (u_int8_t const   )67,        (u_int8_t const   )105, 
            (u_int8_t const   )41,        (u_int8_t const   )46,        (u_int8_t const   )172,        (u_int8_t const   )21, 
            (u_int8_t const   )89,        (u_int8_t const   )168,        (u_int8_t const   )10,        (u_int8_t const   )158, 
            (u_int8_t const   )110,        (u_int8_t const   )71,        (u_int8_t const   )223,        (u_int8_t const   )52, 
            (u_int8_t const   )53,        (u_int8_t const   )106,        (u_int8_t const   )207,        (u_int8_t const   )220, 
            (u_int8_t const   )34,        (u_int8_t const   )201,        (u_int8_t const   )192,        (u_int8_t const   )155, 
            (u_int8_t const   )137,        (u_int8_t const   )212,        (u_int8_t const   )237,        (u_int8_t const   )171, 
            (u_int8_t const   )18,        (u_int8_t const   )162,        (u_int8_t const   )13,        (u_int8_t const   )82, 
            (u_int8_t const   )187,        (u_int8_t const   )2,        (u_int8_t const   )47,        (u_int8_t const   )169, 
            (u_int8_t const   )215,        (u_int8_t const   )97,        (u_int8_t const   )30,        (u_int8_t const   )180, 
            (u_int8_t const   )80,        (u_int8_t const   )4,        (u_int8_t const   )246,        (u_int8_t const   )194, 
            (u_int8_t const   )22,        (u_int8_t const   )37,        (u_int8_t const   )134,        (u_int8_t const   )86, 
            (u_int8_t const   )85,        (u_int8_t const   )9,        (u_int8_t const   )190,        (u_int8_t const   )145}};
#line 102 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/twofish.c"
static int TwoFish_MDSready  =    0;
#line 103 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/twofish.c"
static u_int32_t TwoFish_MDS[4][256]  ;
#line 121 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/twofish.c"
u_int8_t TwoFish__b(u_int32_t x , int n ) 
{ 
  int tmp ;

  {
#line 122
  n &= 3;
  {
#line 123
  while (1) {
    while_continue: /* CIL Label */ ;
#line 123
    tmp = n;
#line 123
    n --;
#line 123
    if (! (tmp > 0)) {
#line 123
      goto while_break;
    }
#line 124
    x >>= 8;
  }
  while_break: /* CIL Label */ ;
  }
#line 125
  return ((u_int8_t )x);
}
}
#line 141 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/twofish.c"
TWOFISH *TwoFishInit(u_int8_t const   *userkey , u_int32_t keysize ) 
{ 
  TWOFISH *tfdata ;
  int i ;
  int x ;
  int m ;
  u_int8_t tkey[72] ;
  void *tmp ;
  int tmp___0 ;
  time_t tmp___1 ;

  {
  {
#line 146
  memset((void *)(tkey), 0, (size_t )72);
#line 147
  tmp = malloc(sizeof(TWOFISH ));
#line 147
  tfdata = (TWOFISH *)tmp;
  }
#line 148
  if ((unsigned long )tfdata != (unsigned long )((void *)0)) {
#line 152
    if (keysize > 0U) {
      {
#line 154
      memcpy((void */* __restrict  */)(tkey), (void const   */* __restrict  */)userkey,
             (size_t )keysize);
      }
    } else {
      {
#line 158
      memcpy((void */* __restrict  */)(tkey), (void const   */* __restrict  */)"SnortHas2FishEncryptionRoutines!",
             (size_t )32);
      }
    }
#line 162
    i = 0;
#line 162
    x = 0;
#line 162
    m = (int )keysize;
    {
#line 162
    while (1) {
      while_continue: /* CIL Label */ ;
#line 162
      if (! (i < 32)) {
#line 162
        goto while_break;
      }
#line 164
      tmp___0 = x;
#line 164
      x ++;
#line 164
      tfdata->key[i] = tkey[tmp___0];
#line 165
      if (x == m) {
#line 166
        x = 0;
      }
#line 162
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 169
    if (! TwoFish_MDSready) {
      {
#line 170
      _TwoFish_PrecomputeMDSmatrix();
      }
    }
    {
#line 171
    _TwoFish_MakeSubKeys(tfdata);
#line 172
    _TwoFish_ResetCBC(tfdata);
#line 173
    tfdata->output = (u_int8_t *)((void *)0);
#line 174
    tfdata->dontflush = 0;
    }
#line 175
    if (TwoFish_srand) {
      {
#line 177
      TwoFish_srand = 0;
#line 180
      tmp___1 = time((time_t *)((void *)0));
#line 180
      srand((unsigned int )tmp___1);
      }
    }
  }
#line 183
  return (tfdata);
}
}
#line 187 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/twofish.c"
void TwoFishDestroy(TWOFISH *tfdata ) 
{ 


  {
#line 188
  if ((unsigned long )tfdata != (unsigned long )((void *)0)) {
    {
#line 189
    free((void *)tfdata);
    }
  }
#line 190
  return;
}
}
#line 194 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/twofish.c"
u_int32_t _TwoFish_CryptRawCBC(u_int8_t *in , u_int8_t *out , u_int32_t len , int decrypt ,
                               TWOFISH *tfdata ) 
{ 
  u_int32_t rl ;

  {
#line 197
  rl = len;
  {
#line 198
  while (1) {
    while_continue: /* CIL Label */ ;
#line 198
    if (! (len > 16U)) {
#line 198
      goto while_break;
    }
    {
#line 199
    _TwoFish_BlockCrypt(in, out, (u_int32_t )16, decrypt, tfdata);
#line 200
    in += 16;
#line 201
    out += 16;
#line 202
    len -= 16U;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 204
  if (len > 0U) {
    {
#line 205
    _TwoFish_BlockCrypt(in, out, len, decrypt, tfdata);
    }
  }
#line 206
  if (tfdata->qBlockDefined) {
#line 206
    if (! tfdata->dontflush) {
      {
#line 207
      _TwoFish_FlushOutput(tfdata->qBlockCrypt, (u_int32_t )16, tfdata);
      }
    }
  }
#line 209
  return (rl);
}
}
#line 213 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/twofish.c"
u_int32_t _TwoFish_CryptRaw16(u_int8_t *in , u_int8_t *out , u_int32_t len , int decrypt ,
                              TWOFISH *tfdata ) 
{ 


  {
  {
#line 215
  memcpy((void */* __restrict  */)(tfdata->qBlockPlain), (void const   */* __restrict  */)in,
         (size_t )len);
#line 216
  _TwoFish_BlockCrypt16(tfdata->qBlockPlain, tfdata->qBlockCrypt, decrypt, tfdata);
#line 217
  memcpy((void */* __restrict  */)out, (void const   */* __restrict  */)(tfdata->qBlockCrypt),
         (size_t )16);
  }
#line 218
  return ((u_int32_t )16);
}
}
#line 222 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/twofish.c"
u_int32_t _TwoFish_CryptRaw(u_int8_t *in , u_int8_t *out , u_int32_t len , int decrypt ,
                            TWOFISH *tfdata ) 
{ 
  u_int32_t tmp ;
  u_int32_t tmp___0 ;

  {
#line 224
  if ((unsigned long )in != (unsigned long )((void *)0)) {
#line 224
    if ((unsigned long )out != (unsigned long )((void *)0)) {
#line 224
      if (len > 0U) {
#line 224
        if ((unsigned long )tfdata != (unsigned long )((void *)0)) {
#line 225
          if (len > 16U) {
            {
#line 226
            tmp = _TwoFish_CryptRawCBC(in, out, len, decrypt, tfdata);
            }
#line 226
            return (tmp);
          } else {
            {
#line 228
            tmp___0 = _TwoFish_CryptRaw16(in, out, len, decrypt, tfdata);
            }
#line 228
            return (tmp___0);
          }
        }
      }
    }
  }
#line 230
  return ((u_int32_t )0);
}
}
#line 246 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/twofish.c"
u_int32_t TwoFishEncryptRaw(u_int8_t *in , u_int8_t *out , u_int32_t len , TWOFISH *tfdata ) 
{ 
  u_int32_t tmp ;

  {
  {
#line 250
  _TwoFish_ResetCBC(tfdata);
#line 251
  tfdata->output = out;
#line 252
  tmp = _TwoFish_CryptRaw(in, out, len, 0, tfdata);
  }
#line 252
  return (tmp);
}
}
#line 267 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/twofish.c"
u_int32_t TwoFishDecryptRaw(u_int8_t *in , u_int8_t *out , u_int32_t len , TWOFISH *tfdata ) 
{ 
  u_int32_t tmp ;

  {
  {
#line 271
  _TwoFish_ResetCBC(tfdata);
#line 272
  tfdata->output = out;
#line 273
  tmp = _TwoFish_CryptRaw(in, out, len, 1, tfdata);
  }
#line 273
  return (tmp);
}
}
#line 285 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/twofish.c"
void TwoFishFree(TWOFISH *tfdata ) 
{ 


  {
#line 286
  if ((unsigned long )tfdata->output != (unsigned long )((void *)0)) {
    {
#line 287
    free((void *)tfdata->output);
#line 288
    tfdata->output = (u_int8_t *)((void *)0);
    }
  }
#line 290
  return;
}
}
#line 303 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/twofish.c"
void TwoFishSetOutput(u_int8_t *outp , TWOFISH *tfdata ) 
{ 


  {
#line 304
  tfdata->output = outp;
#line 305
  return;
}
}
#line 318 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/twofish.c"
void *TwoFishAlloc(u_int32_t len , int binhex , int decrypt , TWOFISH *tfdata ) 
{ 
  void *tmp ;

  {
#line 321
  if (decrypt) {
#line 322
    if (binhex) {
#line 323
      len /= 2U;
    }
#line 324
    len -= 16U;
  } else {
#line 327
    len += 16U;
#line 328
    if (binhex) {
#line 329
      len *= 2U;
    }
  }
  {
#line 331
  tmp = malloc((size_t )(len + 16U));
#line 331
  tfdata->output = (u_int8_t *)tmp;
  }
#line 333
  return ((void *)tfdata->output);
}
}
#line 337 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/twofish.c"
void _TwoFish_BinHex(u_int8_t *buf , u_int32_t len , int bintohex ) 
{ 
  u_int8_t *pi ;
  u_int8_t *po ;
  u_int8_t c ;
  u_int8_t *tmp ;
  u_int8_t *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 340
  if (bintohex) {
#line 341
    pi = (buf + len) - 1;
#line 341
    po = (buf + 2U * len) - 1;
    {
#line 341
    while (1) {
      while_continue: /* CIL Label */ ;
#line 341
      if (! (len > 0U)) {
#line 341
        goto while_break;
      }
#line 342
      c = *pi;
#line 343
      c = (u_int8_t )((int )c & 15);
#line 344
      if ((int )c > 9) {
#line 345
        c = (u_int8_t )((int )c + 87);
      } else {
#line 347
        c = (u_int8_t )((int )c + 48);
      }
#line 348
      tmp = po;
#line 348
      po --;
#line 348
      *tmp = c;
#line 349
      c = *pi;
#line 350
      c = (u_int8_t )((int )c >> 4);
#line 351
      c = (u_int8_t )((int )c & 15);
#line 352
      if ((int )c > 9) {
#line 353
        c = (u_int8_t )((int )c + 87);
      } else {
#line 355
        c = (u_int8_t )((int )c + 48);
      }
#line 356
      *po = c;
#line 341
      pi --;
#line 341
      po --;
#line 341
      len --;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 360
    pi = buf;
#line 360
    po = buf;
    {
#line 360
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 360
      if (! (len > 0U)) {
#line 360
        goto while_break___0;
      }
      {
#line 361
      tmp___0 = pi;
#line 361
      pi ++;
#line 361
      tmp___1 = tolower((int )*tmp___0);
#line 361
      c = (u_int8_t )(tmp___1 - 48);
      }
#line 362
      if ((int )c > 9) {
#line 363
        c = (u_int8_t )((int )c - 39);
      }
      {
#line 364
      *po = (u_int8_t )((int )c << 4);
#line 365
      tmp___2 = tolower((int )*pi);
#line 365
      c = (u_int8_t )(tmp___2 - 48);
      }
#line 366
      if ((int )c > 9) {
#line 367
        c = (u_int8_t )((int )c - 39);
      }
#line 368
      *po = (u_int8_t )((int )*po | (int )c);
#line 360
      pi ++;
#line 360
      po ++;
#line 360
      len -= 2U;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 371
  return;
}
}
#line 394 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/twofish.c"
u_int32_t TwoFishEncrypt(u_int8_t *in , u_int8_t **out , long len , int binhex , TWOFISH *tfdata ) 
{ 
  u_int32_t ilen ;
  u_int32_t olen ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  u_int32_t tmp___2 ;

  {
#line 410
  ilen = (u_int32_t )len;
#line 412
  if ((unsigned long )in != (unsigned long )((void *)0)) {
#line 412
    if ((unsigned long )out != (unsigned long )((void *)0)) {
#line 412
      if (ilen > 0U) {
#line 412
        if ((unsigned long )tfdata != (unsigned long )((void *)0)) {
#line 413
          if ((unsigned long )*out == (unsigned long )((void *)0)) {
            {
#line 414
            tmp = TwoFishAlloc(ilen, binhex, 0, tfdata);
#line 414
            *out = (u_int8_t *)tmp;
            }
          }
#line 415
          if ((unsigned long )*out != (unsigned long )((void *)0)) {
            {
#line 416
            tfdata->output = *out;
#line 417
            tmp___0 = rand();
#line 417
            tmp___1 = rand();
#line 417
            tfdata->header.salt = (u_int32_t )(tmp___0 * 65536 + tmp___1);
#line 418
            tfdata->header.length[0] = (u_int8_t )ilen;
#line 419
            tfdata->header.length[1] = (u_int8_t )(ilen >> 8);
#line 420
            tfdata->header.length[2] = (u_int8_t )(ilen >> 16);
#line 421
            tfdata->header.length[3] = (u_int8_t )(ilen >> 24);
#line 422
            memcpy((void */* __restrict  */)(tfdata->header.magic), (void const   */* __restrict  */)"TwoFish",
                   (size_t )8);
#line 423
            olen = (u_int32_t )16;
#line 424
            _TwoFish_ResetCBC(tfdata);
#line 425
            _TwoFish_BlockCrypt((u_int8_t *)(& tfdata->header), *out, olen, 0, tfdata);
#line 426
            tmp___2 = _TwoFish_CryptRawCBC(in, *out + 16, ilen, 0, tfdata);
#line 426
            olen += tmp___2;
            }
#line 427
            if (binhex) {
              {
#line 428
              _TwoFish_BinHex(*out, olen, 1);
#line 429
              olen *= 2U;
              }
            }
#line 431
            tfdata->output = *out;
#line 432
            return (olen);
          }
        }
      }
    }
  }
#line 435
  return ((u_int32_t )0);
}
}
#line 458 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/twofish.c"
u_int32_t TwoFishDecrypt(u_int8_t *in , u_int8_t **out , long len , int binhex , TWOFISH *tfdata ) 
{ 
  u_int32_t ilen ;
  u_int32_t elen ;
  u_int32_t olen ;
  u_int8_t cmagic[8] ;
  u_int8_t *tbuf ;
  void *tmp ;
  void *tmp___0 ;
  u_int32_t tmp___1 ;

  {
#line 464
  cmagic[0] = (u_int8_t )'T';
#line 464
  cmagic[1] = (u_int8_t )'w';
#line 464
  cmagic[2] = (u_int8_t )'o';
#line 464
  cmagic[3] = (u_int8_t )'F';
#line 464
  cmagic[4] = (u_int8_t )'i';
#line 464
  cmagic[5] = (u_int8_t )'s';
#line 464
  cmagic[6] = (u_int8_t )'h';
#line 464
  cmagic[7] = (u_int8_t )'\000';
#line 477
  ilen = (u_int32_t )len;
#line 479
  if ((unsigned long )in != (unsigned long )((void *)0)) {
#line 479
    if ((unsigned long )out != (unsigned long )((void *)0)) {
#line 479
      if (ilen > 0U) {
#line 479
        if ((unsigned long )tfdata != (unsigned long )((void *)0)) {
#line 480
          if ((unsigned long )*out == (unsigned long )((void *)0)) {
            {
#line 481
            tmp = TwoFishAlloc(ilen, binhex, 1, tfdata);
#line 481
            *out = (u_int8_t *)tmp;
            }
          }
#line 482
          if ((unsigned long )*out != (unsigned long )((void *)0)) {
#line 483
            if (binhex) {
              {
#line 484
              _TwoFish_BinHex(in, ilen, 0);
#line 485
              ilen /= 2U;
              }
            }
            {
#line 487
            _TwoFish_ResetCBC(tfdata);
#line 489
            tmp___0 = malloc((size_t )(ilen + 16U));
#line 489
            tbuf = (u_int8_t *)tmp___0;
            }
#line 490
            if ((unsigned long )tbuf == (unsigned long )((void *)0)) {
#line 491
              return ((u_int32_t )0);
            }
            {
#line 492
            tfdata->output = tbuf;
#line 494
            tmp___1 = _TwoFish_CryptRawCBC(in, tbuf, ilen, 1, tfdata);
#line 494
            olen = tmp___1 - 16U;
#line 495
            memcpy((void */* __restrict  */)(& tfdata->header), (void const   */* __restrict  */)tbuf,
                   (size_t )16);
#line 496
            tfdata->output = *out;
#line 497
            elen = (u_int32_t )0;
            }
            {
#line 497
            while (1) {
              while_continue: /* CIL Label */ ;
#line 497
              if (! (elen < 8U)) {
#line 497
                goto while_break;
              }
#line 498
              if ((int )tfdata->header.magic[elen] != (int )cmagic[elen]) {
#line 499
                goto while_break;
              }
#line 497
              elen ++;
            }
            while_break: /* CIL Label */ ;
            }
#line 500
            if (elen == 8U) {
#line 501
              elen = (u_int32_t )((((int )tfdata->header.length[0] | ((int )tfdata->header.length[1] << 8)) | ((int )tfdata->header.length[2] << 16)) | ((int )tfdata->header.length[3] << 24));
#line 505
              if (elen > olen) {
#line 506
                elen = olen;
              }
              {
#line 507
              memcpy((void */* __restrict  */)*out, (void const   */* __restrict  */)(tbuf + 16),
                     (size_t )elen);
#line 508
              free((void *)tbuf);
              }
#line 509
              return (elen);
            }
            {
#line 511
            free((void *)tbuf);
            }
          }
        }
      }
    }
  }
#line 514
  return ((u_int32_t )0);
}
}
#line 517 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/twofish.c"
void _TwoFish_PrecomputeMDSmatrix(void) 
{ 
  u_int32_t m1[2] ;
  u_int32_t mX[2] ;
  u_int32_t mY[2] ;
  u_int32_t i ;
  u_int32_t j ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 523
  i = (u_int32_t )0;
  {
#line 523
  while (1) {
    while_continue: /* CIL Label */ ;
#line 523
    if (! (i < 256U)) {
#line 523
      goto while_break;
    }
#line 524
    j = (u_int32_t )((int const   )TwoFish_P[0][i] & 255);
#line 525
    m1[0] = j;
#line 526
    if (j & 2U) {
#line 526
      tmp = 180;
    } else {
#line 526
      tmp = 0;
    }
#line 526
    if (j & 1U) {
#line 526
      tmp___0 = 90;
    } else {
#line 526
      tmp___0 = 0;
    }
#line 526
    mX[0] = (j ^ (((j >> 2) ^ (unsigned int )tmp) ^ (unsigned int )tmp___0)) & 255U;
#line 527
    if (j & 1U) {
#line 527
      tmp___1 = 180;
    } else {
#line 527
      tmp___1 = 0;
    }
#line 527
    if (j & 2U) {
#line 527
      tmp___2 = 180;
    } else {
#line 527
      tmp___2 = 0;
    }
#line 527
    if (j & 1U) {
#line 527
      tmp___3 = 90;
    } else {
#line 527
      tmp___3 = 0;
    }
#line 527
    mY[0] = ((j ^ ((j >> 1) ^ (unsigned int )tmp___1)) ^ (((j >> 2) ^ (unsigned int )tmp___2) ^ (unsigned int )tmp___3)) & 255U;
#line 529
    j = (u_int32_t )((int const   )TwoFish_P[1][i] & 255);
#line 530
    m1[1] = j;
#line 531
    if (j & 2U) {
#line 531
      tmp___4 = 180;
    } else {
#line 531
      tmp___4 = 0;
    }
#line 531
    if (j & 1U) {
#line 531
      tmp___5 = 90;
    } else {
#line 531
      tmp___5 = 0;
    }
#line 531
    mX[1] = (j ^ (((j >> 2) ^ (unsigned int )tmp___4) ^ (unsigned int )tmp___5)) & 255U;
#line 532
    if (j & 1U) {
#line 532
      tmp___6 = 180;
    } else {
#line 532
      tmp___6 = 0;
    }
#line 532
    if (j & 2U) {
#line 532
      tmp___7 = 180;
    } else {
#line 532
      tmp___7 = 0;
    }
#line 532
    if (j & 1U) {
#line 532
      tmp___8 = 90;
    } else {
#line 532
      tmp___8 = 0;
    }
#line 532
    mY[1] = ((j ^ ((j >> 1) ^ (unsigned int )tmp___6)) ^ (((j >> 2) ^ (unsigned int )tmp___7) ^ (unsigned int )tmp___8)) & 255U;
#line 534
    TwoFish_MDS[0][i] = ((m1[1] | (mX[1] << 8)) | (mY[1] << 16)) | (mY[1] << 24);
#line 538
    TwoFish_MDS[1][i] = ((mY[0] | (mY[0] << 8)) | (mX[0] << 16)) | (m1[0] << 24);
#line 542
    TwoFish_MDS[2][i] = ((mX[1] | (mY[1] << 8)) | (m1[1] << 16)) | (mY[1] << 24);
#line 546
    TwoFish_MDS[3][i] = ((mX[0] | (m1[0] << 8)) | (mY[0] << 16)) | (mX[0] << 24);
#line 523
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 551
  TwoFish_MDSready = 1;
#line 552
  return;
}
}
#line 555 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/twofish.c"
void _TwoFish_MakeSubKeys(TWOFISH *tfdata ) 
{ 
  u_int32_t k64Cnt ;
  u_int32_t k32e[4] ;
  u_int32_t k32o[4] ;
  u_int32_t sBoxKey[4] ;
  u_int32_t offset ;
  u_int32_t i ;
  u_int32_t j ;
  u_int32_t A ;
  u_int32_t B ;
  u_int32_t q ;
  u_int32_t k0 ;
  u_int32_t k1 ;
  u_int32_t k2 ;
  u_int32_t k3 ;
  u_int32_t b0 ;
  u_int32_t b1 ;
  u_int32_t b2 ;
  u_int32_t b3 ;
  u_int32_t tmp ;
  u_int32_t tmp___0 ;
  u_int32_t tmp___1 ;
  u_int32_t tmp___2 ;
  u_int32_t tmp___3 ;
  u_int32_t tmp___4 ;
  u_int32_t tmp___5 ;
  u_int32_t tmp___6 ;
  u_int32_t tmp___7 ;
  u_int32_t tmp___8 ;
  u_int8_t tmp___9 ;
  u_int8_t tmp___10 ;
  u_int8_t tmp___11 ;
  u_int8_t tmp___12 ;
  u_int8_t tmp___13 ;
  u_int8_t tmp___14 ;
  u_int8_t tmp___15 ;
  u_int8_t tmp___16 ;
  u_int8_t tmp___17 ;
  u_int8_t tmp___18 ;
  u_int8_t tmp___19 ;
  u_int8_t tmp___20 ;
  u_int8_t tmp___21 ;
  u_int8_t tmp___22 ;
  u_int8_t tmp___23 ;
  u_int8_t tmp___24 ;
  u_int8_t tmp___25 ;
  u_int8_t tmp___26 ;
  u_int8_t tmp___27 ;
  u_int8_t tmp___28 ;

  {
#line 556
  k64Cnt = (u_int32_t )4;
#line 561
  q = (u_int32_t )0;
#line 569
  offset = (u_int32_t )0;
#line 569
  i = (u_int32_t )0;
#line 569
  j = k64Cnt - 1U;
  {
#line 569
  while (1) {
    while_continue: /* CIL Label */ ;
#line 569
    if (i < 4U) {
#line 569
      if (! (offset < 32U)) {
#line 569
        goto while_break;
      }
    } else {
#line 569
      goto while_break;
    }
    {
#line 570
    tmp = offset;
#line 570
    offset ++;
#line 570
    k32e[i] = (u_int32_t )tfdata->key[tmp];
#line 571
    tmp___0 = offset;
#line 571
    offset ++;
#line 571
    k32e[i] |= (unsigned int )((int )tfdata->key[tmp___0] << 8);
#line 572
    tmp___1 = offset;
#line 572
    offset ++;
#line 572
    k32e[i] |= (unsigned int )((int )tfdata->key[tmp___1] << 16);
#line 573
    tmp___2 = offset;
#line 573
    offset ++;
#line 573
    k32e[i] |= (unsigned int )((int )tfdata->key[tmp___2] << 24);
#line 574
    tmp___3 = offset;
#line 574
    offset ++;
#line 574
    k32o[i] = (u_int32_t )tfdata->key[tmp___3];
#line 575
    tmp___4 = offset;
#line 575
    offset ++;
#line 575
    k32o[i] |= (unsigned int )((int )tfdata->key[tmp___4] << 8);
#line 576
    tmp___5 = offset;
#line 576
    offset ++;
#line 576
    k32o[i] |= (unsigned int )((int )tfdata->key[tmp___5] << 16);
#line 577
    tmp___6 = offset;
#line 577
    offset ++;
#line 577
    k32o[i] |= (unsigned int )((int )tfdata->key[tmp___6] << 24);
#line 578
    sBoxKey[j] = _TwoFish_RS_MDS_Encode(k32e[i], k32o[i]);
#line 569
    i ++;
#line 569
    j --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 583
  i = (u_int32_t )0;
  {
#line 584
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 584
    if (! (i < 40U)) {
#line 584
      goto while_break___0;
    }
    {
#line 585
    A = _TwoFish_F32(k64Cnt, q, k32e);
#line 586
    q += 16843009U;
#line 588
    B = _TwoFish_F32(k64Cnt, q, k32o);
#line 589
    q += 16843009U;
#line 591
    B = (B << 8) | (B >> 24);
#line 593
    A += B;
#line 594
    tmp___7 = i;
#line 594
    i ++;
#line 594
    tfdata->subKeys[tmp___7] = A;
#line 596
    A += B;
#line 597
    tmp___8 = i;
#line 597
    i ++;
#line 597
    tfdata->subKeys[tmp___8] = (A << 9) | (A >> 23);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 601
  k0 = sBoxKey[0];
#line 602
  k1 = sBoxKey[1];
#line 603
  k2 = sBoxKey[2];
#line 604
  k3 = sBoxKey[3];
#line 606
  i = (u_int32_t )0;
  {
#line 606
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 606
    if (! (i < 256U)) {
#line 606
      goto while_break___1;
    }
#line 607
    b3 = i;
#line 607
    b2 = b3;
#line 607
    b1 = b2;
#line 607
    b0 = b1;
    {
#line 609
    if ((k64Cnt & 3U) == 1U) {
#line 609
      goto case_1;
    }
#line 615
    if ((k64Cnt & 3U) == 0U) {
#line 615
      goto case_0;
    }
#line 620
    if ((k64Cnt & 3U) == 3U) {
#line 620
      goto case_3;
    }
#line 625
    if ((k64Cnt & 3U) == 2U) {
#line 625
      goto case_2;
    }
#line 608
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 610
    tmp___9 = TwoFish__b(k0, 0);
#line 610
    tfdata->sBox[2U * i] = TwoFish_MDS[0][(int const   )TwoFish_P[0][b0] ^ (int const   )tmp___9];
#line 611
    tmp___10 = TwoFish__b(k0, 1);
#line 611
    tfdata->sBox[2U * i + 1U] = TwoFish_MDS[1][(int const   )TwoFish_P[0][b1] ^ (int const   )tmp___10];
#line 612
    tmp___11 = TwoFish__b(k0, 2);
#line 612
    tfdata->sBox[512U + 2U * i] = TwoFish_MDS[2][(int const   )TwoFish_P[1][b2] ^ (int const   )tmp___11];
#line 613
    tmp___12 = TwoFish__b(k0, 3);
#line 613
    tfdata->sBox[(512U + 2U * i) + 1U] = TwoFish_MDS[3][(int const   )TwoFish_P[1][b3] ^ (int const   )tmp___12];
    }
#line 614
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 616
    tmp___13 = TwoFish__b(k3, 0);
#line 616
    b0 = (u_int32_t )((int const   )TwoFish_P[1][b0] ^ (int const   )tmp___13);
#line 617
    tmp___14 = TwoFish__b(k3, 1);
#line 617
    b1 = (u_int32_t )((int const   )TwoFish_P[0][b1] ^ (int const   )tmp___14);
#line 618
    tmp___15 = TwoFish__b(k3, 2);
#line 618
    b2 = (u_int32_t )((int const   )TwoFish_P[0][b2] ^ (int const   )tmp___15);
#line 619
    tmp___16 = TwoFish__b(k3, 3);
#line 619
    b3 = (u_int32_t )((int const   )TwoFish_P[1][b3] ^ (int const   )tmp___16);
    }
    case_3: /* CIL Label */ 
    {
#line 621
    tmp___17 = TwoFish__b(k2, 0);
#line 621
    b0 = (u_int32_t )((int const   )TwoFish_P[1][b0] ^ (int const   )tmp___17);
#line 622
    tmp___18 = TwoFish__b(k2, 1);
#line 622
    b1 = (u_int32_t )((int const   )TwoFish_P[1][b1] ^ (int const   )tmp___18);
#line 623
    tmp___19 = TwoFish__b(k2, 2);
#line 623
    b2 = (u_int32_t )((int const   )TwoFish_P[0][b2] ^ (int const   )tmp___19);
#line 624
    tmp___20 = TwoFish__b(k2, 3);
#line 624
    b3 = (u_int32_t )((int const   )TwoFish_P[0][b3] ^ (int const   )tmp___20);
    }
    case_2: /* CIL Label */ 
    {
#line 626
    tmp___21 = TwoFish__b(k1, 0);
#line 626
    tmp___22 = TwoFish__b(k0, 0);
#line 626
    tfdata->sBox[2U * i] = TwoFish_MDS[0][(int const   )TwoFish_P[0][(int const   )TwoFish_P[0][b0] ^ (int const   )tmp___21] ^ (int const   )tmp___22];
#line 630
    tmp___23 = TwoFish__b(k1, 1);
#line 630
    tmp___24 = TwoFish__b(k0, 1);
#line 630
    tfdata->sBox[2U * i + 1U] = TwoFish_MDS[1][(int const   )TwoFish_P[0][(int const   )TwoFish_P[1][b1] ^ (int const   )tmp___23] ^ (int const   )tmp___24];
#line 634
    tmp___25 = TwoFish__b(k1, 2);
#line 634
    tmp___26 = TwoFish__b(k0, 2);
#line 634
    tfdata->sBox[512U + 2U * i] = TwoFish_MDS[2][(int const   )TwoFish_P[1][(int const   )TwoFish_P[0][b2] ^ (int const   )tmp___25] ^ (int const   )tmp___26];
#line 638
    tmp___27 = TwoFish__b(k1, 3);
#line 638
    tmp___28 = TwoFish__b(k0, 3);
#line 638
    tfdata->sBox[(512U + 2U * i) + 1U] = TwoFish_MDS[3][(int const   )TwoFish_P[1][(int const   )TwoFish_P[1][b3] ^ (int const   )tmp___27] ^ (int const   )tmp___28];
    }
    switch_break: /* CIL Label */ ;
    }
#line 606
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 643
  return;
}
}
#line 670 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/twofish.c"
void _TwoFish_BlockCrypt(u_int8_t *in , u_int8_t *out , u_int32_t size , int decrypt ,
                         TWOFISH *tfdata ) 
{ 
  u_int8_t PnMinusOne[16] ;
  u_int8_t CnMinusOne[16] ;
  u_int8_t CBCplusCprime[16] ;
  u_int8_t Pn[16] ;
  u_int8_t *p ;
  u_int8_t *pout ;
  u_int32_t i ;

  {
#line 679
  if (size == 16U) {
#line 682
    if (! decrypt) {
#line 682
      if (tfdata->qBlockDefined) {
#line 683
        p = in;
#line 683
        i = (u_int32_t )0;
        {
#line 683
        while (1) {
          while_continue: /* CIL Label */ ;
#line 683
          if (! (i < 16U)) {
#line 683
            goto while_break;
          }
#line 684
          Pn[i] = (u_int8_t )((int )*p ^ (int )tfdata->qBlockCrypt[i]);
#line 683
          i ++;
#line 683
          p ++;
        }
        while_break: /* CIL Label */ ;
        }
      } else {
        {
#line 687
        memcpy((void */* __restrict  */)(Pn), (void const   */* __restrict  */)in,
               (size_t )16);
        }
      }
    } else {
      {
#line 687
      memcpy((void */* __restrict  */)(Pn), (void const   */* __restrict  */)in, (size_t )16);
      }
    }
    {
#line 690
    _TwoFish_BlockCrypt16(Pn, out, decrypt, tfdata);
    }
#line 694
    if (decrypt) {
#line 694
      if (tfdata->qBlockDefined) {
#line 695
        p = out;
#line 695
        i = (u_int32_t )0;
        {
#line 695
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 695
          if (! (i < 16U)) {
#line 695
            goto while_break___0;
          }
#line 696
          *p = (u_int8_t )((int )*p ^ (int )tfdata->qBlockPlain[i]);
#line 695
          i ++;
#line 695
          p ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
    {
#line 701
    _TwoFish_qBlockPush(Pn, out, tfdata);
    }
  } else {
#line 708
    if (decrypt) {
      {
#line 713
      _TwoFish_qBlockPop(CnMinusOne, PnMinusOne, tfdata);
#line 714
      _TwoFish_BlockCrypt16(CnMinusOne, CBCplusCprime, decrypt, tfdata);
#line 718
      p = in;
#line 718
      pout = out;
#line 718
      i = (u_int32_t )0;
      }
      {
#line 718
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 718
        if (! (i < size)) {
#line 718
          goto while_break___1;
        }
#line 719
        *pout = (u_int8_t )((int )*p ^ (int )CBCplusCprime[i]);
#line 718
        i ++;
#line 718
        p ++;
#line 718
        pout ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 724
      p = in;
#line 724
      i = (u_int32_t )0;
      {
#line 724
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 724
        if (! (i < size)) {
#line 724
          goto while_break___2;
        }
#line 725
        CnMinusOne[i] = *p;
#line 724
        i ++;
#line 724
        p ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 726
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 726
        if (! (i < 16U)) {
#line 726
          goto while_break___3;
        }
#line 727
        CnMinusOne[i] = CBCplusCprime[i];
#line 726
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 730
      _TwoFish_BlockCrypt16(CnMinusOne, PnMinusOne, decrypt, tfdata);
#line 732
      i = (u_int32_t )0;
      }
      {
#line 732
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 732
        if (! (i < 16U)) {
#line 732
          goto while_break___4;
        }
#line 733
        PnMinusOne[i] = (u_int8_t )((int )PnMinusOne[i] ^ (int )tfdata->prevCipher[i]);
#line 732
        i ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 736
      _TwoFish_qBlockPush(CnMinusOne, PnMinusOne, tfdata);
#line 737
      _TwoFish_FlushOutput(tfdata->qBlockCrypt, (u_int32_t )16, tfdata);
#line 738
      _TwoFish_FlushOutput(out, size, tfdata);
      }
    } else {
      {
#line 741
      _TwoFish_qBlockPop(PnMinusOne, CnMinusOne, tfdata);
#line 742
      memset((void *)(Pn), 0, (size_t )16);
#line 743
      memcpy((void */* __restrict  */)(Pn), (void const   */* __restrict  */)in, (size_t )size);
#line 744
      i = (u_int32_t )0;
      }
      {
#line 744
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 744
        if (! (i < 16U)) {
#line 744
          goto while_break___5;
        }
#line 745
        Pn[i] = (u_int8_t )((int )Pn[i] ^ (int )CnMinusOne[i]);
#line 744
        i ++;
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 746
      _TwoFish_BlockCrypt16(Pn, out, decrypt, tfdata);
#line 747
      _TwoFish_qBlockPush(Pn, out, tfdata);
#line 748
      _TwoFish_FlushOutput(tfdata->qBlockCrypt, (u_int32_t )16, tfdata);
#line 749
      _TwoFish_FlushOutput(CnMinusOne, size, tfdata);
      }
    }
#line 751
    tfdata->qBlockDefined = 0;
  }
#line 753
  return;
}
}
#line 755 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/twofish.c"
void _TwoFish_qBlockPush(u_int8_t *p , u_int8_t *c , TWOFISH *tfdata ) 
{ 


  {
#line 756
  if (tfdata->qBlockDefined) {
    {
#line 757
    _TwoFish_FlushOutput(tfdata->qBlockCrypt, (u_int32_t )16, tfdata);
    }
  }
  {
#line 758
  memcpy((void */* __restrict  */)(tfdata->prevCipher), (void const   */* __restrict  */)(tfdata->qBlockPlain),
         (size_t )16);
#line 759
  memcpy((void */* __restrict  */)(tfdata->qBlockPlain), (void const   */* __restrict  */)p,
         (size_t )16);
#line 760
  memcpy((void */* __restrict  */)(tfdata->qBlockCrypt), (void const   */* __restrict  */)c,
         (size_t )16);
#line 761
  tfdata->qBlockDefined = 1;
  }
#line 762
  return;
}
}
#line 764 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/twofish.c"
void _TwoFish_qBlockPop(u_int8_t *p , u_int8_t *c , TWOFISH *tfdata ) 
{ 


  {
  {
#line 765
  memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)(tfdata->qBlockPlain),
         (size_t )16);
#line 766
  memcpy((void */* __restrict  */)c, (void const   */* __restrict  */)(tfdata->qBlockCrypt),
         (size_t )16);
#line 767
  tfdata->qBlockDefined = 0;
  }
#line 768
  return;
}
}
#line 771 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/twofish.c"
void _TwoFish_ResetCBC(TWOFISH *tfdata ) 
{ 


  {
  {
#line 772
  tfdata->qBlockDefined = 0;
#line 773
  memset((void *)(tfdata->qBlockPlain), 0, (size_t )16);
  }
#line 774
  return;
}
}
#line 776 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/twofish.c"
void _TwoFish_FlushOutput(u_int8_t *b , u_int32_t len , TWOFISH *tfdata ) 
{ 
  u_int32_t i ;
  u_int8_t *tmp ;
  u_int8_t *tmp___0 ;

  {
#line 779
  i = (u_int32_t )0;
  {
#line 779
  while (1) {
    while_continue: /* CIL Label */ ;
#line 779
    if (i < len) {
#line 779
      if (! (! tfdata->dontflush)) {
#line 779
        goto while_break;
      }
    } else {
#line 779
      goto while_break;
    }
#line 780
    tmp = tfdata->output;
#line 780
    (tfdata->output) ++;
#line 780
    tmp___0 = b;
#line 780
    b ++;
#line 780
    *tmp = *tmp___0;
#line 779
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 781
  tfdata->dontflush = 0;
#line 782
  return;
}
}
#line 784 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/twofish.c"
void _TwoFish_BlockCrypt16(u_int8_t *in , u_int8_t *out , int decrypt , TWOFISH *tfdata ) 
{ 
  u_int32_t x0 ;
  u_int32_t x1 ;
  u_int32_t x2 ;
  u_int32_t x3 ;
  u_int32_t k ;
  u_int32_t t0 ;
  u_int32_t t1 ;
  u_int32_t R ;
  u_int8_t *tmp ;
  u_int8_t *tmp___0 ;
  u_int8_t *tmp___1 ;
  u_int8_t *tmp___2 ;
  u_int8_t *tmp___3 ;
  u_int8_t *tmp___4 ;
  u_int8_t *tmp___5 ;
  u_int8_t *tmp___6 ;
  u_int8_t *tmp___7 ;
  u_int8_t *tmp___8 ;
  u_int8_t *tmp___9 ;
  u_int8_t *tmp___10 ;
  u_int8_t *tmp___11 ;
  u_int8_t *tmp___12 ;
  u_int8_t *tmp___13 ;
  u_int8_t *tmp___14 ;
  u_int32_t tmp___15 ;
  u_int32_t tmp___16 ;
  u_int32_t tmp___17 ;
  u_int32_t tmp___18 ;
  u_int32_t tmp___19 ;
  u_int32_t tmp___20 ;
  u_int32_t tmp___21 ;
  u_int32_t tmp___22 ;
  u_int8_t *tmp___23 ;
  u_int8_t *tmp___24 ;
  u_int8_t *tmp___25 ;
  u_int8_t *tmp___26 ;
  u_int8_t *tmp___27 ;
  u_int8_t *tmp___28 ;
  u_int8_t *tmp___29 ;
  u_int8_t *tmp___30 ;
  u_int8_t *tmp___31 ;
  u_int8_t *tmp___32 ;
  u_int8_t *tmp___33 ;
  u_int8_t *tmp___34 ;
  u_int8_t *tmp___35 ;
  u_int8_t *tmp___36 ;
  u_int8_t *tmp___37 ;
  u_int8_t *tmp___38 ;

  {
#line 789
  tmp = in;
#line 789
  in ++;
#line 789
  x0 = (u_int32_t )*tmp;
#line 790
  tmp___0 = in;
#line 790
  in ++;
#line 790
  x0 |= (unsigned int )((int )*tmp___0 << 8);
#line 791
  tmp___1 = in;
#line 791
  in ++;
#line 791
  x0 |= (unsigned int )((int )*tmp___1 << 16);
#line 792
  tmp___2 = in;
#line 792
  in ++;
#line 792
  x0 |= (unsigned int )((int )*tmp___2 << 24);
#line 793
  tmp___3 = in;
#line 793
  in ++;
#line 793
  x1 = (u_int32_t )*tmp___3;
#line 794
  tmp___4 = in;
#line 794
  in ++;
#line 794
  x1 |= (unsigned int )((int )*tmp___4 << 8);
#line 795
  tmp___5 = in;
#line 795
  in ++;
#line 795
  x1 |= (unsigned int )((int )*tmp___5 << 16);
#line 796
  tmp___6 = in;
#line 796
  in ++;
#line 796
  x1 |= (unsigned int )((int )*tmp___6 << 24);
#line 797
  tmp___7 = in;
#line 797
  in ++;
#line 797
  x2 = (u_int32_t )*tmp___7;
#line 798
  tmp___8 = in;
#line 798
  in ++;
#line 798
  x2 |= (unsigned int )((int )*tmp___8 << 8);
#line 799
  tmp___9 = in;
#line 799
  in ++;
#line 799
  x2 |= (unsigned int )((int )*tmp___9 << 16);
#line 800
  tmp___10 = in;
#line 800
  in ++;
#line 800
  x2 |= (unsigned int )((int )*tmp___10 << 24);
#line 801
  tmp___11 = in;
#line 801
  in ++;
#line 801
  x3 = (u_int32_t )*tmp___11;
#line 802
  tmp___12 = in;
#line 802
  in ++;
#line 802
  x3 |= (unsigned int )((int )*tmp___12 << 8);
#line 803
  tmp___13 = in;
#line 803
  in ++;
#line 803
  x3 |= (unsigned int )((int )*tmp___13 << 16);
#line 804
  tmp___14 = in;
#line 804
  in ++;
#line 804
  x3 |= (unsigned int )((int )*tmp___14 << 24);
#line 806
  if (decrypt) {
#line 807
    x0 ^= tfdata->subKeys[4];
#line 808
    x1 ^= tfdata->subKeys[5];
#line 809
    x2 ^= tfdata->subKeys[6];
#line 810
    x3 ^= tfdata->subKeys[7];
#line 812
    k = (u_int32_t )39;
#line 813
    R = (u_int32_t )0;
    {
#line 813
    while (1) {
      while_continue: /* CIL Label */ ;
#line 813
      if (! (R < 16U)) {
#line 813
        goto while_break;
      }
      {
#line 814
      t0 = _TwoFish_Fe320(tfdata->sBox, x0);
#line 815
      t1 = _TwoFish_Fe323(tfdata->sBox, x1);
#line 816
      tmp___15 = k;
#line 816
      k --;
#line 816
      x3 ^= (t0 + (t1 << 1)) + tfdata->subKeys[tmp___15];
#line 817
      x3 = (x3 >> 1) | (x3 << 31);
#line 818
      x2 = (x2 << 1) | (x2 >> 31);
#line 819
      tmp___16 = k;
#line 819
      k --;
#line 819
      x2 ^= (t0 + t1) + tfdata->subKeys[tmp___16];
#line 821
      t0 = _TwoFish_Fe320(tfdata->sBox, x2);
#line 822
      t1 = _TwoFish_Fe323(tfdata->sBox, x3);
#line 823
      tmp___17 = k;
#line 823
      k --;
#line 823
      x1 ^= (t0 + (t1 << 1)) + tfdata->subKeys[tmp___17];
#line 824
      x1 = (x1 >> 1) | (x1 << 31);
#line 825
      x0 = (x0 << 1) | (x0 >> 31);
#line 826
      tmp___18 = k;
#line 826
      k --;
#line 826
      x0 ^= (t0 + t1) + tfdata->subKeys[tmp___18];
#line 813
      R += 2U;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 829
    x2 ^= tfdata->subKeys[0];
#line 830
    x3 ^= tfdata->subKeys[1];
#line 831
    x0 ^= tfdata->subKeys[2];
#line 832
    x1 ^= tfdata->subKeys[3];
  } else {
#line 835
    x0 ^= tfdata->subKeys[0];
#line 836
    x1 ^= tfdata->subKeys[1];
#line 837
    x2 ^= tfdata->subKeys[2];
#line 838
    x3 ^= tfdata->subKeys[3];
#line 840
    k = (u_int32_t )8;
#line 841
    R = (u_int32_t )0;
    {
#line 841
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 841
      if (! (R < 16U)) {
#line 841
        goto while_break___0;
      }
      {
#line 842
      t0 = _TwoFish_Fe320(tfdata->sBox, x0);
#line 843
      t1 = _TwoFish_Fe323(tfdata->sBox, x1);
#line 844
      tmp___19 = k;
#line 844
      k ++;
#line 844
      x2 ^= (t0 + t1) + tfdata->subKeys[tmp___19];
#line 845
      x2 = (x2 >> 1) | (x2 << 31);
#line 846
      x3 = (x3 << 1) | (x3 >> 31);
#line 847
      tmp___20 = k;
#line 847
      k ++;
#line 847
      x3 ^= (t0 + (t1 << 1)) + tfdata->subKeys[tmp___20];
#line 849
      t0 = _TwoFish_Fe320(tfdata->sBox, x2);
#line 850
      t1 = _TwoFish_Fe323(tfdata->sBox, x3);
#line 851
      tmp___21 = k;
#line 851
      k ++;
#line 851
      x0 ^= (t0 + t1) + tfdata->subKeys[tmp___21];
#line 852
      x0 = (x0 >> 1) | (x0 << 31);
#line 853
      x1 = (x1 << 1) | (x1 >> 31);
#line 854
      tmp___22 = k;
#line 854
      k ++;
#line 854
      x1 ^= (t0 + (t1 << 1)) + tfdata->subKeys[tmp___22];
#line 841
      R += 2U;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 857
    x2 ^= tfdata->subKeys[4];
#line 858
    x3 ^= tfdata->subKeys[5];
#line 859
    x0 ^= tfdata->subKeys[6];
#line 860
    x1 ^= tfdata->subKeys[7];
  }
#line 863
  tmp___23 = out;
#line 863
  out ++;
#line 863
  *tmp___23 = (u_int8_t )x2;
#line 864
  tmp___24 = out;
#line 864
  out ++;
#line 864
  *tmp___24 = (u_int8_t )(x2 >> 8);
#line 865
  tmp___25 = out;
#line 865
  out ++;
#line 865
  *tmp___25 = (u_int8_t )(x2 >> 16);
#line 866
  tmp___26 = out;
#line 866
  out ++;
#line 866
  *tmp___26 = (u_int8_t )(x2 >> 24);
#line 868
  tmp___27 = out;
#line 868
  out ++;
#line 868
  *tmp___27 = (u_int8_t )x3;
#line 869
  tmp___28 = out;
#line 869
  out ++;
#line 869
  *tmp___28 = (u_int8_t )(x3 >> 8);
#line 870
  tmp___29 = out;
#line 870
  out ++;
#line 870
  *tmp___29 = (u_int8_t )(x3 >> 16);
#line 871
  tmp___30 = out;
#line 871
  out ++;
#line 871
  *tmp___30 = (u_int8_t )(x3 >> 24);
#line 873
  tmp___31 = out;
#line 873
  out ++;
#line 873
  *tmp___31 = (u_int8_t )x0;
#line 874
  tmp___32 = out;
#line 874
  out ++;
#line 874
  *tmp___32 = (u_int8_t )(x0 >> 8);
#line 875
  tmp___33 = out;
#line 875
  out ++;
#line 875
  *tmp___33 = (u_int8_t )(x0 >> 16);
#line 876
  tmp___34 = out;
#line 876
  out ++;
#line 876
  *tmp___34 = (u_int8_t )(x0 >> 24);
#line 878
  tmp___35 = out;
#line 878
  out ++;
#line 878
  *tmp___35 = (u_int8_t )x1;
#line 879
  tmp___36 = out;
#line 879
  out ++;
#line 879
  *tmp___36 = (u_int8_t )(x1 >> 8);
#line 880
  tmp___37 = out;
#line 880
  out ++;
#line 880
  *tmp___37 = (u_int8_t )(x1 >> 16);
#line 881
  tmp___38 = out;
#line 881
  out ++;
#line 881
  *tmp___38 = (u_int8_t )(x1 >> 24);
#line 882
  return;
}
}
#line 892 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/twofish.c"
u_int32_t _TwoFish_RS_MDS_Encode(u_int32_t k0 , u_int32_t k1 ) 
{ 
  u_int32_t i ;
  u_int32_t r ;
  u_int8_t b ;
  u_int32_t g2 ;
  int tmp ;
  u_int32_t g3 ;
  int tmp___0 ;
  u_int8_t b___0 ;
  u_int32_t g2___0 ;
  int tmp___1 ;
  u_int32_t g3___0 ;
  int tmp___2 ;

  {
#line 895
  r = k1;
#line 895
  i = (u_int32_t )0;
  {
#line 895
  while (1) {
    while_continue: /* CIL Label */ ;
#line 895
    if (! (i < 4U)) {
#line 895
      goto while_break;
    }
#line 896
    b = (u_int8_t )(r >> 24);
#line 896
    if ((int )b & 128) {
#line 896
      tmp = 333;
    } else {
#line 896
      tmp = 0;
    }
#line 896
    g2 = (u_int32_t )((((int )b << 1) ^ tmp) & 255);
#line 896
    if ((int )b & 1) {
#line 896
      tmp___0 = 333 >> 1;
    } else {
#line 896
      tmp___0 = 0;
    }
#line 896
    g3 = (unsigned int )((((int )b >> 1) & 127) ^ tmp___0) ^ g2;
#line 896
    r = ((((r << 8) ^ (g3 << 24)) ^ (g2 << 16)) ^ (g3 << 8)) ^ (unsigned int )b;
#line 895
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 897
  r ^= k0;
#line 898
  i = (u_int32_t )0;
  {
#line 898
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 898
    if (! (i < 4U)) {
#line 898
      goto while_break___0;
    }
#line 899
    b___0 = (u_int8_t )(r >> 24);
#line 899
    if ((int )b___0 & 128) {
#line 899
      tmp___1 = 333;
    } else {
#line 899
      tmp___1 = 0;
    }
#line 899
    g2___0 = (u_int32_t )((((int )b___0 << 1) ^ tmp___1) & 255);
#line 899
    if ((int )b___0 & 1) {
#line 899
      tmp___2 = 333 >> 1;
    } else {
#line 899
      tmp___2 = 0;
    }
#line 899
    g3___0 = (unsigned int )((((int )b___0 >> 1) & 127) ^ tmp___2) ^ g2___0;
#line 899
    r = ((((r << 8) ^ (g3___0 << 24)) ^ (g2___0 << 16)) ^ (g3___0 << 8)) ^ (unsigned int )b___0;
#line 898
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 901
  return (r);
}
}
#line 904 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/twofish.c"
u_int32_t _TwoFish_F32(u_int32_t k64Cnt , u_int32_t x , u_int32_t *k32 ) 
{ 
  u_int8_t b0 ;
  u_int8_t b1 ;
  u_int8_t b2 ;
  u_int8_t b3 ;
  u_int32_t k0 ;
  u_int32_t k1 ;
  u_int32_t k2 ;
  u_int32_t k3 ;
  u_int32_t result ;
  u_int8_t tmp ;
  u_int8_t tmp___0 ;
  u_int8_t tmp___1 ;
  u_int8_t tmp___2 ;
  u_int8_t tmp___3 ;
  u_int8_t tmp___4 ;
  u_int8_t tmp___5 ;
  u_int8_t tmp___6 ;
  u_int8_t tmp___7 ;
  u_int8_t tmp___8 ;
  u_int8_t tmp___9 ;
  u_int8_t tmp___10 ;
  u_int8_t tmp___11 ;
  u_int8_t tmp___12 ;
  u_int8_t tmp___13 ;
  u_int8_t tmp___14 ;
  u_int8_t tmp___15 ;
  u_int8_t tmp___16 ;
  u_int8_t tmp___17 ;
  u_int8_t tmp___18 ;

  {
  {
#line 906
  result = (u_int32_t )0;
#line 908
  b0 = TwoFish__b(x, 0);
#line 909
  b1 = TwoFish__b(x, 1);
#line 910
  b2 = TwoFish__b(x, 2);
#line 911
  b3 = TwoFish__b(x, 3);
#line 912
  k0 = *(k32 + 0);
#line 913
  k1 = *(k32 + 1);
#line 914
  k2 = *(k32 + 2);
#line 915
  k3 = *(k32 + 3);
  }
  {
#line 918
  if ((k64Cnt & 3U) == 1U) {
#line 918
    goto case_1;
  }
#line 925
  if ((k64Cnt & 3U) == 0U) {
#line 925
    goto case_0;
  }
#line 931
  if ((k64Cnt & 3U) == 3U) {
#line 931
    goto case_3;
  }
#line 936
  if ((k64Cnt & 3U) == 2U) {
#line 936
    goto case_2;
  }
#line 917
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 919
  tmp = TwoFish__b(k0, 0);
#line 919
  tmp___0 = TwoFish__b(k0, 1);
#line 919
  tmp___1 = TwoFish__b(k0, 2);
#line 919
  tmp___2 = TwoFish__b(k0, 3);
#line 919
  result = ((TwoFish_MDS[0][((int const   )TwoFish_P[0][b0] & 255) ^ (int const   )tmp] ^ TwoFish_MDS[1][((int const   )TwoFish_P[0][b1] & 255) ^ (int const   )tmp___0]) ^ TwoFish_MDS[2][((int const   )TwoFish_P[1][b2] & 255) ^ (int const   )tmp___1]) ^ TwoFish_MDS[3][((int const   )TwoFish_P[1][b3] & 255) ^ (int const   )tmp___2];
  }
#line 924
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 926
  tmp___3 = TwoFish__b(k3, 0);
#line 926
  b0 = (u_int8_t )(((int const   )TwoFish_P[1][b0] & 255) ^ (int const   )tmp___3);
#line 927
  tmp___4 = TwoFish__b(k3, 1);
#line 927
  b1 = (u_int8_t )(((int const   )TwoFish_P[0][b1] & 255) ^ (int const   )tmp___4);
#line 928
  tmp___5 = TwoFish__b(k3, 2);
#line 928
  b2 = (u_int8_t )(((int const   )TwoFish_P[0][b2] & 255) ^ (int const   )tmp___5);
#line 929
  tmp___6 = TwoFish__b(k3, 3);
#line 929
  b3 = (u_int8_t )(((int const   )TwoFish_P[1][b3] & 255) ^ (int const   )tmp___6);
  }
  case_3: /* CIL Label */ 
  {
#line 932
  tmp___7 = TwoFish__b(k2, 0);
#line 932
  b0 = (u_int8_t )(((int const   )TwoFish_P[1][b0] & 255) ^ (int const   )tmp___7);
#line 933
  tmp___8 = TwoFish__b(k2, 1);
#line 933
  b1 = (u_int8_t )(((int const   )TwoFish_P[1][b1] & 255) ^ (int const   )tmp___8);
#line 934
  tmp___9 = TwoFish__b(k2, 2);
#line 934
  b2 = (u_int8_t )(((int const   )TwoFish_P[0][b2] & 255) ^ (int const   )tmp___9);
#line 935
  tmp___10 = TwoFish__b(k2, 3);
#line 935
  b3 = (u_int8_t )(((int const   )TwoFish_P[0][b3] & 255) ^ (int const   )tmp___10);
  }
  case_2: /* CIL Label */ 
  {
#line 937
  tmp___11 = TwoFish__b(k1, 0);
#line 937
  tmp___12 = TwoFish__b(k0, 0);
#line 937
  tmp___13 = TwoFish__b(k1, 1);
#line 937
  tmp___14 = TwoFish__b(k0, 1);
#line 937
  tmp___15 = TwoFish__b(k1, 2);
#line 937
  tmp___16 = TwoFish__b(k0, 2);
#line 937
  tmp___17 = TwoFish__b(k1, 3);
#line 937
  tmp___18 = TwoFish__b(k0, 3);
#line 937
  result = ((TwoFish_MDS[0][((int const   )TwoFish_P[0][((int const   )TwoFish_P[0][b0] & 255) ^ (int const   )tmp___11] & 255) ^ (int const   )tmp___12] ^ TwoFish_MDS[1][((int const   )TwoFish_P[0][((int const   )TwoFish_P[1][b1] & 255) ^ (int const   )tmp___13] & 255) ^ (int const   )tmp___14]) ^ TwoFish_MDS[2][((int const   )TwoFish_P[1][((int const   )TwoFish_P[0][b2] & 255) ^ (int const   )tmp___15] & 255) ^ (int const   )tmp___16]) ^ TwoFish_MDS[3][((int const   )TwoFish_P[1][((int const   )TwoFish_P[1][b3] & 255) ^ (int const   )tmp___17] & 255) ^ (int const   )tmp___18];
  }
#line 942
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 944
  return (result);
}
}
#line 947 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/twofish.c"
u_int32_t _TwoFish_Fe320(u_int32_t *lsBox , u_int32_t x ) 
{ 
  u_int8_t tmp ;
  u_int8_t tmp___0 ;
  u_int8_t tmp___1 ;
  u_int8_t tmp___2 ;

  {
  {
#line 948
  tmp = TwoFish__b(x, 0);
#line 948
  tmp___0 = TwoFish__b(x, 1);
#line 948
  tmp___1 = TwoFish__b(x, 2);
#line 948
  tmp___2 = TwoFish__b(x, 3);
  }
#line 948
  return (((*(lsBox + ((int )tmp << 1)) ^ *(lsBox + (((int )tmp___0 << 1) | 1))) ^ *(lsBox + (512 + ((int )tmp___1 << 1)))) ^ *(lsBox + (512 + (((int )tmp___2 << 1) | 1))));
}
}
#line 954 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/twofish.c"
u_int32_t _TwoFish_Fe323(u_int32_t *lsBox , u_int32_t x ) 
{ 
  u_int8_t tmp ;
  u_int8_t tmp___0 ;
  u_int8_t tmp___1 ;
  u_int8_t tmp___2 ;

  {
  {
#line 955
  tmp = TwoFish__b(x, 3);
#line 955
  tmp___0 = TwoFish__b(x, 0);
#line 955
  tmp___1 = TwoFish__b(x, 1);
#line 955
  tmp___2 = TwoFish__b(x, 2);
  }
#line 955
  return (((*(lsBox + ((int )tmp << 1)) ^ *(lsBox + (((int )tmp___0 << 1) | 1))) ^ *(lsBox + (512 + ((int )tmp___1 << 1)))) ^ *(lsBox + (512 + (((int )tmp___2 << 1) | 1))));
}
}
#line 961 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/twofish.c"
u_int32_t _TwoFish_Fe32(u_int32_t *lsBox , u_int32_t x , u_int32_t R ) 
{ 
  u_int8_t tmp ;
  u_int8_t tmp___0 ;
  u_int8_t tmp___1 ;
  u_int8_t tmp___2 ;

  {
  {
#line 962
  tmp = TwoFish__b(x, (int )R);
#line 962
  tmp___0 = TwoFish__b(x, (int )(R + 1U));
#line 962
  tmp___1 = TwoFish__b(x, (int )(R + 2U));
#line 962
  tmp___2 = TwoFish__b(x, (int )(R + 3U));
  }
#line 962
  return (((*(lsBox + 2 * (int )tmp) ^ *(lsBox + (2 * (int )tmp___0 + 1))) ^ *(lsBox + (512 + 2 * (int )tmp___1))) ^ *(lsBox + ((512 + 2 * (int )tmp___2) + 1)));
}
}
#line 22 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/tuntap_linux.c"
static void read_mac___0(char *ifname , char *mac_addr ) 
{ 
  int _sock ;
  int res ;
  struct ifreq ifr ;
  macstr_t mac_addr_buf ;
  char *tmp ;

  {
  {
#line 27
  memset((void *)(& ifr), 0, sizeof(struct ifreq ));
#line 30
  _sock = socket(2, 2, 0);
#line 31
  strcpy((char */* __restrict  */)(ifr.ifr_ifrn.ifrn_name), (char const   */* __restrict  */)ifname);
#line 32
  res = ioctl(_sock, 35111UL, & ifr);
  }
#line 33
  if (res < 0) {
    {
#line 34
    perror("Get hw addr");
    }
  } else {
    {
#line 36
    memcpy((void */* __restrict  */)mac_addr, (void const   */* __restrict  */)(ifr.ifr_ifru.ifru_hwaddr.sa_data),
           (size_t )6);
    }
  }
  {
#line 38
  tmp = macaddr_str((char const   *)mac_addr, mac_addr_buf, (int )sizeof(mac_addr_buf));
#line 38
  traceEvent(2, (char *)"/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/tuntap_linux.c",
             38, (char *)"Interface %s has MAC %s", ifname, tmp);
#line 41
  close(_sock);
  }
#line 42
  return;
}
}
#line 2822 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/minilzo.c"
static lzo_uint ( __attribute__((__noinline__)) _lzo1x_1_do_compress___0)(unsigned char const   *in ,
                                                                          lzo_uint in_len ,
                                                                          unsigned char *out ,
                                                                          lzo_uint *out_len ,
                                                                          void *wrkmem___1 ) 
{ 
  register unsigned char const   *ip ;
  unsigned char *op ;
  unsigned char const   *in_end ;
  unsigned char const   *ip_end ;
  unsigned char const   *ii ;
  unsigned char const   **dict ;
  register unsigned char const   *m_pos ;
  lzo_uint m_off ;
  lzo_uint m_len ;
  lzo_uint dindex ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  register lzo_uint t ;
  unsigned char *tmp___3 ;
  register lzo_uint tt ;
  unsigned char *tmp___4 ;
  unsigned char *tmp___5 ;
  unsigned char *tmp___6 ;
  unsigned char *tmp___7 ;
  unsigned char const   *tmp___8 ;
  unsigned char *tmp___9 ;
  unsigned char *tmp___10 ;
  unsigned char *tmp___11 ;
  unsigned char *tmp___12 ;
  unsigned char const   *end ;
  unsigned char const   *m ;
  unsigned char *tmp___13 ;
  unsigned char *tmp___14 ;
  unsigned char *tmp___15 ;
  unsigned char *tmp___16 ;
  unsigned char *tmp___17 ;
  unsigned char *tmp___18 ;
  unsigned char *tmp___19 ;
  unsigned char *tmp___20 ;
  unsigned char const   *tmp___21 ;
  unsigned char const   *tmp___22 ;
  unsigned char const   *tmp___23 ;
  unsigned char const   *tmp___24 ;
  unsigned char const   *tmp___25 ;
  unsigned char const   *tmp___26 ;
  long tmp___27 ;

  {
#line 2829
  in_end = in + in_len;
#line 2830
  ip_end = ((in + in_len) - 8) - 5;
#line 2832
  dict = (unsigned char const   **)wrkmem___1;
#line 2834
  op = out;
#line 2835
  ip = in;
#line 2836
  ii = ip;
#line 2838
  ip += 4;
  {
#line 2839
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2846
    dindex = (33UL * (((((((lzo_uint )*((ip + 1) + 2) << 6) ^ (unsigned long )*((ip + 1) + 1)) << 5) ^ (unsigned long )*((ip + 1) + 0)) << 5) ^ (unsigned long )*(ip + 0)) >> 5) & (unsigned long )((1U << 14) - 1U);
#line 2847
    m_pos = *(dict + dindex);
#line 2848
    m_pos = ip - ((size_t )ip - (size_t )m_pos);
#line 2848
    if ((size_t )m_pos < (size_t )in) {
#line 2848
      tmp = 1;
    } else {
#line 2848
      m_off = (size_t )ip - (size_t )m_pos;
#line 2848
      if (m_off <= 0UL) {
#line 2848
        tmp = 1;
      } else
#line 2848
      if (m_off > 49151UL) {
#line 2848
        tmp = 1;
      } else {
#line 2848
        tmp = 0;
      }
    }
#line 2848
    if (tmp) {
#line 2849
      goto literal;
    }
#line 2851
    if (m_off <= 2048UL) {
#line 2852
      goto try_match;
    } else
#line 2851
    if ((int const   )*(m_pos + 3) == (int const   )*(ip + 3)) {
#line 2852
      goto try_match;
    }
#line 2853
    dindex = (dindex & (unsigned long )(((1U << 14) - 1U) & 2047U)) ^ (unsigned long )(((((1U << 14) - 1U) >> 1) + 1U) | 31U);
#line 2855
    m_pos = *(dict + dindex);
#line 2856
    m_pos = ip - ((size_t )ip - (size_t )m_pos);
#line 2856
    if ((size_t )m_pos < (size_t )in) {
#line 2856
      tmp___0 = 1;
    } else {
#line 2856
      m_off = (size_t )ip - (size_t )m_pos;
#line 2856
      if (m_off <= 0UL) {
#line 2856
        tmp___0 = 1;
      } else
#line 2856
      if (m_off > 49151UL) {
#line 2856
        tmp___0 = 1;
      } else {
#line 2856
        tmp___0 = 0;
      }
    }
#line 2856
    if (tmp___0) {
#line 2857
      goto literal;
    }
#line 2858
    if (m_off <= 2048UL) {
#line 2859
      goto try_match;
    } else
#line 2858
    if ((int const   )*(m_pos + 3) == (int const   )*(ip + 3)) {
#line 2859
      goto try_match;
    }
#line 2860
    goto literal;
    try_match: 
#line 2864
    if (! ((int const   )*((unsigned short const   *)m_pos) != (int const   )*((unsigned short const   *)ip))) {
      {
#line 2872
      tmp___1 = __builtin_expect((long )(! (! ((int const   )*(m_pos + 2) == (int const   )*(ip + 2)))),
                                 1L);
      }
#line 2872
      if (tmp___1) {
#line 2887
        goto match;
      }
    }
    literal: 
    {
#line 2915
    *(dict + dindex) = ip;
#line 2916
    ip ++;
#line 2917
    tmp___2 = __builtin_expect((long )(! (! ((unsigned long )ip >= (unsigned long )ip_end))),
                               0L);
    }
#line 2917
    if (tmp___2) {
#line 2918
      goto while_break;
    }
#line 2919
    goto __Cont;
    match: 
#line 2922
    *(dict + dindex) = ip;
#line 2923
    if ((lzo_uint )(ip - ii) > 0UL) {
#line 2925
      t = (lzo_uint )(ip - ii);
#line 2927
      if (t <= 3UL) {
#line 2930
        *(op + -2) = (unsigned char )((int )*(op + -2) | (int )((unsigned char )t));
      } else
#line 2932
      if (t <= 18UL) {
#line 2933
        tmp___3 = op;
#line 2933
        op ++;
#line 2933
        *tmp___3 = (unsigned char )(t - 3UL);
      } else {
#line 2936
        tt = t - 18UL;
#line 2938
        tmp___4 = op;
#line 2938
        op ++;
#line 2938
        *tmp___4 = (unsigned char)0;
        {
#line 2939
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 2939
          if (! (tt > 255UL)) {
#line 2939
            goto while_break___0;
          }
#line 2941
          tt -= 255UL;
#line 2942
          tmp___5 = op;
#line 2942
          op ++;
#line 2942
          *tmp___5 = (unsigned char)0;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 2945
        tmp___6 = op;
#line 2945
        op ++;
#line 2945
        *tmp___6 = (unsigned char )tt;
      }
      {
#line 2947
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2947
        tmp___7 = op;
#line 2947
        op ++;
#line 2947
        tmp___8 = ii;
#line 2947
        ii ++;
#line 2947
        *tmp___7 = (unsigned char )*tmp___8;
#line 2947
        t --;
#line 2947
        if (! (t > 0UL)) {
#line 2947
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 2951
    ip += 3;
#line 2952
    tmp___21 = ip;
#line 2952
    ip ++;
#line 2952
    if ((int const   )*(m_pos + 3) != (int const   )*tmp___21) {
#line 2952
      goto _L;
    } else {
#line 2952
      tmp___22 = ip;
#line 2952
      ip ++;
#line 2952
      if ((int const   )*(m_pos + 4) != (int const   )*tmp___22) {
#line 2952
        goto _L;
      } else {
#line 2952
        tmp___23 = ip;
#line 2952
        ip ++;
#line 2952
        if ((int const   )*(m_pos + 5) != (int const   )*tmp___23) {
#line 2952
          goto _L;
        } else {
#line 2952
          tmp___24 = ip;
#line 2952
          ip ++;
#line 2952
          if ((int const   )*(m_pos + 6) != (int const   )*tmp___24) {
#line 2952
            goto _L;
          } else {
#line 2952
            tmp___25 = ip;
#line 2952
            ip ++;
#line 2952
            if ((int const   )*(m_pos + 7) != (int const   )*tmp___25) {
#line 2952
              goto _L;
            } else {
#line 2952
              tmp___26 = ip;
#line 2952
              ip ++;
#line 2952
              if ((int const   )*(m_pos + 8) != (int const   )*tmp___26) {
                _L: /* CIL Label */ 
#line 2960
                ip --;
#line 2961
                m_len = (lzo_uint )(ip - ii);
#line 2964
                if (m_off <= 2048UL) {
#line 2966
                  m_off --;
#line 2968
                  tmp___9 = op;
#line 2968
                  op ++;
#line 2968
                  *tmp___9 = (unsigned char )(((m_len - 1UL) << 5) | ((m_off & 7UL) << 2));
#line 2969
                  tmp___10 = op;
#line 2969
                  op ++;
#line 2969
                  *tmp___10 = (unsigned char )(m_off >> 3);
                } else
#line 2975
                if (m_off <= 16384UL) {
#line 2977
                  m_off --;
#line 2978
                  tmp___11 = op;
#line 2978
                  op ++;
#line 2978
                  *tmp___11 = (unsigned char )(32UL | (m_len - 2UL));
#line 2979
                  goto m3_m4_offset;
                } else {
#line 2984
                  m_off -= 16384UL;
#line 2986
                  tmp___12 = op;
#line 2986
                  op ++;
#line 2986
                  *tmp___12 = (unsigned char )((16UL | ((m_off & 16384UL) >> 11)) | (m_len - 2UL));
#line 2988
                  goto m3_m4_offset;
                }
              } else {
#line 2997
                end = in_end;
#line 2998
                m = (m_pos + 8) + 1;
                {
#line 2999
                while (1) {
                  while_continue___2: /* CIL Label */ ;
#line 2999
                  if ((unsigned long )ip < (unsigned long )end) {
#line 2999
                    if (! ((int const   )*m == (int const   )*ip)) {
#line 2999
                      goto while_break___2;
                    }
                  } else {
#line 2999
                    goto while_break___2;
                  }
#line 3000
                  m ++;
#line 3000
                  ip ++;
                }
                while_break___2: /* CIL Label */ ;
                }
#line 3001
                m_len = (lzo_uint )(ip - ii);
#line 3005
                if (m_off <= 16384UL) {
#line 3007
                  m_off --;
#line 3008
                  if (m_len <= 33UL) {
#line 3009
                    tmp___13 = op;
#line 3009
                    op ++;
#line 3009
                    *tmp___13 = (unsigned char )(32UL | (m_len - 2UL));
                  } else {
#line 3012
                    m_len -= 33UL;
#line 3013
                    tmp___14 = op;
#line 3013
                    op ++;
#line 3013
                    *tmp___14 = (unsigned char)32;
#line 3014
                    goto m3_m4_len;
                  }
                } else {
#line 3022
                  m_off -= 16384UL;
#line 3024
                  if (m_len <= 9UL) {
#line 3025
                    tmp___15 = op;
#line 3025
                    op ++;
#line 3025
                    *tmp___15 = (unsigned char )((16UL | ((m_off & 16384UL) >> 11)) | (m_len - 2UL));
                  } else {
#line 3029
                    m_len -= 9UL;
#line 3030
                    tmp___16 = op;
#line 3030
                    op ++;
#line 3030
                    *tmp___16 = (unsigned char )(16UL | ((m_off & 16384UL) >> 11));
                    m3_m4_len: 
                    {
#line 3032
                    while (1) {
                      while_continue___3: /* CIL Label */ ;
#line 3032
                      if (! (m_len > 255UL)) {
#line 3032
                        goto while_break___3;
                      }
#line 3034
                      m_len -= 255UL;
#line 3035
                      tmp___17 = op;
#line 3035
                      op ++;
#line 3035
                      *tmp___17 = (unsigned char)0;
                    }
                    while_break___3: /* CIL Label */ ;
                    }
#line 3038
                    tmp___18 = op;
#line 3038
                    op ++;
#line 3038
                    *tmp___18 = (unsigned char )m_len;
                  }
                }
                m3_m4_offset: 
#line 3043
                tmp___19 = op;
#line 3043
                op ++;
#line 3043
                *tmp___19 = (unsigned char )((m_off & 63UL) << 2);
#line 3044
                tmp___20 = op;
#line 3044
                op ++;
#line 3044
                *tmp___20 = (unsigned char )(m_off >> 6);
              }
            }
          }
        }
      }
    }
    {
#line 3050
    ii = ip;
#line 3051
    tmp___27 = __builtin_expect((long )(! (! ((unsigned long )ip >= (unsigned long )ip_end))),
                                0L);
    }
#line 3051
    if (tmp___27) {
#line 3052
      goto while_break;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 3055
  *out_len = (lzo_uint )(op - out);
#line 3056
  return ((lzo_uint )(in_end - ii));
}
}
#line 44 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.c"
static void print_header___0(char const   *msg , struct n2n_packet_header  const  *hdr ) 
{ 
  ipstr_t buf ;
  ipstr_t buf2 ;
  uint16_t tmp ;
  uint32_t tmp___0 ;
  char *tmp___1 ;
  uint16_t tmp___2 ;
  uint32_t tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 49
  tmp = ntohs((uint16_t )hdr->private_ip.port);
#line 49
  tmp___0 = ntohl((uint32_t )hdr->private_ip.addr_type.v4_addr);
#line 49
  tmp___1 = intoa(tmp___0, buf2, (u_short )sizeof(buf2));
#line 49
  tmp___2 = ntohs((uint16_t )hdr->public_ip.port);
#line 49
  tmp___3 = ntohl((uint32_t )hdr->public_ip.addr_type.v4_addr);
#line 49
  tmp___4 = intoa(tmp___3, buf, (u_short )sizeof(buf));
#line 49
  traceEvent(3, (char *)"/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.c", 49,
             (char *)"%s hdr: public_ip=(%d)%s:%d, private_ip=(%d)%s:%d", msg, (int const   )hdr->public_ip.family,
             tmp___4, (int )tmp___2, (int const   )hdr->private_ip.family, tmp___1,
             (int )tmp);
  }
#line 57
  return;
}
}
#line 77 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.c"
static int marshall_peer_addr___0(u_int8_t *buf , size_t *offset , struct peer_addr  const  *s ) 
{ 


  {
  {
#line 83
  memcpy((void */* __restrict  */)(buf + *offset), (void const   */* __restrict  */)s,
         sizeof(struct peer_addr ));
#line 84
  *offset += sizeof(struct peer_addr );
  }
#line 86
  return ((int )sizeof(struct peer_addr ));
}
}
#line 91 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.c"
static int marshall_uint32___0(u_int8_t *buf , size_t *offset , u_int32_t val ) 
{ 


  {
#line 94
  *(buf + *offset) = (u_int8_t )((val >> 24) & 255U);
#line 95
  *(buf + (*offset + 1UL)) = (u_int8_t )((val >> 16) & 255U);
#line 96
  *(buf + (*offset + 2UL)) = (u_int8_t )((val >> 8) & 255U);
#line 97
  *(buf + (*offset + 3UL)) = (u_int8_t )(val & 255U);
#line 99
  *offset += 4UL;
#line 100
  return (4);
}
}
#line 146 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.c"
static int unmarshall_peer_addr___0(struct peer_addr *s , size_t *offset , u_int8_t const   *buf ) 
{ 


  {
  {
#line 150
  memcpy((void */* __restrict  */)s, (void const   */* __restrict  */)(buf + *offset),
         sizeof(struct peer_addr ));
#line 151
  *offset += sizeof(struct peer_addr );
  }
#line 152
  return ((int )sizeof(struct peer_addr ));
}
}
#line 157 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.c"
static int unmarshall_uint32___0(u_int32_t *val , size_t *offset , u_int8_t const   *buf ) 
{ 


  {
#line 160
  *val = (u_int32_t )(((int const   )*(buf + *offset) & 255) << 24);
#line 161
  *val |= (unsigned int )(((int const   )*(buf + (*offset + 1UL)) & 255) << 16);
#line 162
  *val |= (unsigned int )(((int const   )*(buf + (*offset + 2UL)) & 255) << 8);
#line 163
  *val |= (unsigned int )((int const   )*(buf + (*offset + 3UL)) & 255);
#line 165
  *offset += 4UL;
#line 166
  return (4);
}
}
#line 603 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.c"
static lzo_align_t wrkmem___0[((unsigned long )((lzo_uint32 )(16384L * (long )((unsigned int )sizeof(unsigned char *)))) + (sizeof(lzo_align_t ) - 1UL)) / sizeof(lzo_align_t )]  ;
#line 837 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.c"
static time_t last_purge___0  =    (time_t )0;
#line 892 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/n2n.c"
static u_int8_t hex2byte___0(char const   *s ) 
{ 
  char tmp[3] ;
  long tmp___0 ;

  {
  {
#line 895
  tmp[0] = (char )*(s + 0);
#line 896
  tmp[1] = (char )*(s + 1);
#line 897
  tmp[2] = (char)0;
#line 899
  tmp___0 = strtol((char const   */* __restrict  */)s, (char **/* __restrict  */)((void *)0),
                   16);
  }
#line 899
  return ((u_int8_t )tmp___0);
}
}
#line 50 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/twofish.c"
static u_int8_t const   TwoFish_P___0[2][256]  = { {        (u_int8_t const   )169,        (u_int8_t const   )103,        (u_int8_t const   )179,        (u_int8_t const   )232, 
            (u_int8_t const   )4,        (u_int8_t const   )253,        (u_int8_t const   )163,        (u_int8_t const   )118, 
            (u_int8_t const   )154,        (u_int8_t const   )146,        (u_int8_t const   )128,        (u_int8_t const   )120, 
            (u_int8_t const   )228,        (u_int8_t const   )221,        (u_int8_t const   )209,        (u_int8_t const   )56, 
            (u_int8_t const   )13,        (u_int8_t const   )198,        (u_int8_t const   )53,        (u_int8_t const   )152, 
            (u_int8_t const   )24,        (u_int8_t const   )247,        (u_int8_t const   )236,        (u_int8_t const   )108, 
            (u_int8_t const   )67,        (u_int8_t const   )117,        (u_int8_t const   )55,        (u_int8_t const   )38, 
            (u_int8_t const   )250,        (u_int8_t const   )19,        (u_int8_t const   )148,        (u_int8_t const   )72, 
            (u_int8_t const   )242,        (u_int8_t const   )208,        (u_int8_t const   )139,        (u_int8_t const   )48, 
            (u_int8_t const   )132,        (u_int8_t const   )84,        (u_int8_t const   )223,        (u_int8_t const   )35, 
            (u_int8_t const   )25,        (u_int8_t const   )91,        (u_int8_t const   )61,        (u_int8_t const   )89, 
            (u_int8_t const   )243,        (u_int8_t const   )174,        (u_int8_t const   )162,        (u_int8_t const   )130, 
            (u_int8_t const   )99,        (u_int8_t const   )1,        (u_int8_t const   )131,        (u_int8_t const   )46, 
            (u_int8_t const   )217,        (u_int8_t const   )81,        (u_int8_t const   )155,        (u_int8_t const   )124, 
            (u_int8_t const   )166,        (u_int8_t const   )235,        (u_int8_t const   )165,        (u_int8_t const   )190, 
            (u_int8_t const   )22,        (u_int8_t const   )12,        (u_int8_t const   )227,        (u_int8_t const   )97, 
            (u_int8_t const   )192,        (u_int8_t const   )140,        (u_int8_t const   )58,        (u_int8_t const   )245, 
            (u_int8_t const   )115,        (u_int8_t const   )44,        (u_int8_t const   )37,        (u_int8_t const   )11, 
            (u_int8_t const   )187,        (u_int8_t const   )78,        (u_int8_t const   )137,        (u_int8_t const   )107, 
            (u_int8_t const   )83,        (u_int8_t const   )106,        (u_int8_t const   )180,        (u_int8_t const   )241, 
            (u_int8_t const   )225,        (u_int8_t const   )230,        (u_int8_t const   )189,        (u_int8_t const   )69, 
            (u_int8_t const   )226,        (u_int8_t const   )244,        (u_int8_t const   )182,        (u_int8_t const   )102, 
            (u_int8_t const   )204,        (u_int8_t const   )149,        (u_int8_t const   )3,        (u_int8_t const   )86, 
            (u_int8_t const   )212,        (u_int8_t const   )28,        (u_int8_t const   )30,        (u_int8_t const   )215, 
            (u_int8_t const   )251,        (u_int8_t const   )195,        (u_int8_t const   )142,        (u_int8_t const   )181, 
            (u_int8_t const   )233,        (u_int8_t const   )207,        (u_int8_t const   )191,        (u_int8_t const   )186, 
            (u_int8_t const   )234,        (u_int8_t const   )119,        (u_int8_t const   )57,        (u_int8_t const   )175, 
            (u_int8_t const   )51,        (u_int8_t const   )201,        (u_int8_t const   )98,        (u_int8_t const   )113, 
            (u_int8_t const   )129,        (u_int8_t const   )121,        (u_int8_t const   )9,        (u_int8_t const   )173, 
            (u_int8_t const   )36,        (u_int8_t const   )205,        (u_int8_t const   )249,        (u_int8_t const   )216, 
            (u_int8_t const   )229,        (u_int8_t const   )197,        (u_int8_t const   )185,        (u_int8_t const   )77, 
            (u_int8_t const   )68,        (u_int8_t const   )8,        (u_int8_t const   )134,        (u_int8_t const   )231, 
            (u_int8_t const   )161,        (u_int8_t const   )29,        (u_int8_t const   )170,        (u_int8_t const   )237, 
            (u_int8_t const   )6,        (u_int8_t const   )112,        (u_int8_t const   )178,        (u_int8_t const   )210, 
            (u_int8_t const   )65,        (u_int8_t const   )123,        (u_int8_t const   )160,        (u_int8_t const   )17, 
            (u_int8_t const   )49,        (u_int8_t const   )194,        (u_int8_t const   )39,        (u_int8_t const   )144, 
            (u_int8_t const   )32,        (u_int8_t const   )246,        (u_int8_t const   )96,        (u_int8_t const   )255, 
            (u_int8_t const   )150,        (u_int8_t const   )92,        (u_int8_t const   )177,        (u_int8_t const   )171, 
            (u_int8_t const   )158,        (u_int8_t const   )156,        (u_int8_t const   )82,        (u_int8_t const   )27, 
            (u_int8_t const   )95,        (u_int8_t const   )147,        (u_int8_t const   )10,        (u_int8_t const   )239, 
            (u_int8_t const   )145,        (u_int8_t const   )133,        (u_int8_t const   )73,        (u_int8_t const   )238, 
            (u_int8_t const   )45,        (u_int8_t const   )79,        (u_int8_t const   )143,        (u_int8_t const   )59, 
            (u_int8_t const   )71,        (u_int8_t const   )135,        (u_int8_t const   )109,        (u_int8_t const   )70, 
            (u_int8_t const   )214,        (u_int8_t const   )62,        (u_int8_t const   )105,        (u_int8_t const   )100, 
            (u_int8_t const   )42,        (u_int8_t const   )206,        (u_int8_t const   )203,        (u_int8_t const   )47, 
            (u_int8_t const   )252,        (u_int8_t const   )151,        (u_int8_t const   )5,        (u_int8_t const   )122, 
            (u_int8_t const   )172,        (u_int8_t const   )127,        (u_int8_t const   )213,        (u_int8_t const   )26, 
            (u_int8_t const   )75,        (u_int8_t const   )14,        (u_int8_t const   )167,        (u_int8_t const   )90, 
            (u_int8_t const   )40,        (u_int8_t const   )20,        (u_int8_t const   )63,        (u_int8_t const   )41, 
            (u_int8_t const   )136,        (u_int8_t const   )60,        (u_int8_t const   )76,        (u_int8_t const   )2, 
            (u_int8_t const   )184,        (u_int8_t const   )218,        (u_int8_t const   )176,        (u_int8_t const   )23, 
            (u_int8_t const   )85,        (u_int8_t const   )31,        (u_int8_t const   )138,        (u_int8_t const   )125, 
            (u_int8_t const   )87,        (u_int8_t const   )199,        (u_int8_t const   )141,        (u_int8_t const   )116, 
            (u_int8_t const   )183,        (u_int8_t const   )196,        (u_int8_t const   )159,        (u_int8_t const   )114, 
            (u_int8_t const   )126,        (u_int8_t const   )21,        (u_int8_t const   )34,        (u_int8_t const   )18, 
            (u_int8_t const   )88,        (u_int8_t const   )7,        (u_int8_t const   )153,        (u_int8_t const   )52, 
            (u_int8_t const   )110,        (u_int8_t const   )80,        (u_int8_t const   )222,        (u_int8_t const   )104, 
            (u_int8_t const   )101,        (u_int8_t const   )188,        (u_int8_t const   )219,        (u_int8_t const   )248, 
            (u_int8_t const   )200,        (u_int8_t const   )168,        (u_int8_t const   )43,        (u_int8_t const   )64, 
            (u_int8_t const   )220,        (u_int8_t const   )254,        (u_int8_t const   )50,        (u_int8_t const   )164, 
            (u_int8_t const   )202,        (u_int8_t const   )16,        (u_int8_t const   )33,        (u_int8_t const   )240, 
            (u_int8_t const   )211,        (u_int8_t const   )93,        (u_int8_t const   )15,        (u_int8_t const   )0, 
            (u_int8_t const   )111,        (u_int8_t const   )157,        (u_int8_t const   )54,        (u_int8_t const   )66, 
            (u_int8_t const   )74,        (u_int8_t const   )94,        (u_int8_t const   )193,        (u_int8_t const   )224}, 
   {        (u_int8_t const   )117,        (u_int8_t const   )243,        (u_int8_t const   )198,        (u_int8_t const   )244, 
            (u_int8_t const   )219,        (u_int8_t const   )123,        (u_int8_t const   )251,        (u_int8_t const   )200, 
            (u_int8_t const   )74,        (u_int8_t const   )211,        (u_int8_t const   )230,        (u_int8_t const   )107, 
            (u_int8_t const   )69,        (u_int8_t const   )125,        (u_int8_t const   )232,        (u_int8_t const   )75, 
            (u_int8_t const   )214,        (u_int8_t const   )50,        (u_int8_t const   )216,        (u_int8_t const   )253, 
            (u_int8_t const   )55,        (u_int8_t const   )113,        (u_int8_t const   )241,        (u_int8_t const   )225, 
            (u_int8_t const   )48,        (u_int8_t const   )15,        (u_int8_t const   )248,        (u_int8_t const   )27, 
            (u_int8_t const   )135,        (u_int8_t const   )250,        (u_int8_t const   )6,        (u_int8_t const   )63, 
            (u_int8_t const   )94,        (u_int8_t const   )186,        (u_int8_t const   )174,        (u_int8_t const   )91, 
            (u_int8_t const   )138,        (u_int8_t const   )0,        (u_int8_t const   )188,        (u_int8_t const   )157, 
            (u_int8_t const   )109,        (u_int8_t const   )193,        (u_int8_t const   )177,        (u_int8_t const   )14, 
            (u_int8_t const   )128,        (u_int8_t const   )93,        (u_int8_t const   )210,        (u_int8_t const   )213, 
            (u_int8_t const   )160,        (u_int8_t const   )132,        (u_int8_t const   )7,        (u_int8_t const   )20, 
            (u_int8_t const   )181,        (u_int8_t const   )144,        (u_int8_t const   )44,        (u_int8_t const   )163, 
            (u_int8_t const   )178,        (u_int8_t const   )115,        (u_int8_t const   )76,        (u_int8_t const   )84, 
            (u_int8_t const   )146,        (u_int8_t const   )116,        (u_int8_t const   )54,        (u_int8_t const   )81, 
            (u_int8_t const   )56,        (u_int8_t const   )176,        (u_int8_t const   )189,        (u_int8_t const   )90, 
            (u_int8_t const   )252,        (u_int8_t const   )96,        (u_int8_t const   )98,        (u_int8_t const   )150, 
            (u_int8_t const   )108,        (u_int8_t const   )66,        (u_int8_t const   )247,        (u_int8_t const   )16, 
            (u_int8_t const   )124,        (u_int8_t const   )40,        (u_int8_t const   )39,        (u_int8_t const   )140, 
            (u_int8_t const   )19,        (u_int8_t const   )149,        (u_int8_t const   )156,        (u_int8_t const   )199, 
            (u_int8_t const   )36,        (u_int8_t const   )70,        (u_int8_t const   )59,        (u_int8_t const   )112, 
            (u_int8_t const   )202,        (u_int8_t const   )227,        (u_int8_t const   )133,        (u_int8_t const   )203, 
            (u_int8_t const   )17,        (u_int8_t const   )208,        (u_int8_t const   )147,        (u_int8_t const   )184, 
            (u_int8_t const   )166,        (u_int8_t const   )131,        (u_int8_t const   )32,        (u_int8_t const   )255, 
            (u_int8_t const   )159,        (u_int8_t const   )119,        (u_int8_t const   )195,        (u_int8_t const   )204, 
            (u_int8_t const   )3,        (u_int8_t const   )111,        (u_int8_t const   )8,        (u_int8_t const   )191, 
            (u_int8_t const   )64,        (u_int8_t const   )231,        (u_int8_t const   )43,        (u_int8_t const   )226, 
            (u_int8_t const   )121,        (u_int8_t const   )12,        (u_int8_t const   )170,        (u_int8_t const   )130, 
            (u_int8_t const   )65,        (u_int8_t const   )58,        (u_int8_t const   )234,        (u_int8_t const   )185, 
            (u_int8_t const   )228,        (u_int8_t const   )154,        (u_int8_t const   )164,        (u_int8_t const   )151, 
            (u_int8_t const   )126,        (u_int8_t const   )218,        (u_int8_t const   )122,        (u_int8_t const   )23, 
            (u_int8_t const   )102,        (u_int8_t const   )148,        (u_int8_t const   )161,        (u_int8_t const   )29, 
            (u_int8_t const   )61,        (u_int8_t const   )240,        (u_int8_t const   )222,        (u_int8_t const   )179, 
            (u_int8_t const   )11,        (u_int8_t const   )114,        (u_int8_t const   )167,        (u_int8_t const   )28, 
            (u_int8_t const   )239,        (u_int8_t const   )209,        (u_int8_t const   )83,        (u_int8_t const   )62, 
            (u_int8_t const   )143,        (u_int8_t const   )51,        (u_int8_t const   )38,        (u_int8_t const   )95, 
            (u_int8_t const   )236,        (u_int8_t const   )118,        (u_int8_t const   )42,        (u_int8_t const   )73, 
            (u_int8_t const   )129,        (u_int8_t const   )136,        (u_int8_t const   )238,        (u_int8_t const   )33, 
            (u_int8_t const   )196,        (u_int8_t const   )26,        (u_int8_t const   )235,        (u_int8_t const   )217, 
            (u_int8_t const   )197,        (u_int8_t const   )57,        (u_int8_t const   )153,        (u_int8_t const   )205, 
            (u_int8_t const   )173,        (u_int8_t const   )49,        (u_int8_t const   )139,        (u_int8_t const   )1, 
            (u_int8_t const   )24,        (u_int8_t const   )35,        (u_int8_t const   )221,        (u_int8_t const   )31, 
            (u_int8_t const   )78,        (u_int8_t const   )45,        (u_int8_t const   )249,        (u_int8_t const   )72, 
            (u_int8_t const   )79,        (u_int8_t const   )242,        (u_int8_t const   )101,        (u_int8_t const   )142, 
            (u_int8_t const   )120,        (u_int8_t const   )92,        (u_int8_t const   )88,        (u_int8_t const   )25, 
            (u_int8_t const   )141,        (u_int8_t const   )229,        (u_int8_t const   )152,        (u_int8_t const   )87, 
            (u_int8_t const   )103,        (u_int8_t const   )127,        (u_int8_t const   )5,        (u_int8_t const   )100, 
            (u_int8_t const   )175,        (u_int8_t const   )99,        (u_int8_t const   )182,        (u_int8_t const   )254, 
            (u_int8_t const   )245,        (u_int8_t const   )183,        (u_int8_t const   )60,        (u_int8_t const   )165, 
            (u_int8_t const   )206,        (u_int8_t const   )233,        (u_int8_t const   )104,        (u_int8_t const   )68, 
            (u_int8_t const   )224,        (u_int8_t const   )77,        (u_int8_t const   )67,        (u_int8_t const   )105, 
            (u_int8_t const   )41,        (u_int8_t const   )46,        (u_int8_t const   )172,        (u_int8_t const   )21, 
            (u_int8_t const   )89,        (u_int8_t const   )168,        (u_int8_t const   )10,        (u_int8_t const   )158, 
            (u_int8_t const   )110,        (u_int8_t const   )71,        (u_int8_t const   )223,        (u_int8_t const   )52, 
            (u_int8_t const   )53,        (u_int8_t const   )106,        (u_int8_t const   )207,        (u_int8_t const   )220, 
            (u_int8_t const   )34,        (u_int8_t const   )201,        (u_int8_t const   )192,        (u_int8_t const   )155, 
            (u_int8_t const   )137,        (u_int8_t const   )212,        (u_int8_t const   )237,        (u_int8_t const   )171, 
            (u_int8_t const   )18,        (u_int8_t const   )162,        (u_int8_t const   )13,        (u_int8_t const   )82, 
            (u_int8_t const   )187,        (u_int8_t const   )2,        (u_int8_t const   )47,        (u_int8_t const   )169, 
            (u_int8_t const   )215,        (u_int8_t const   )97,        (u_int8_t const   )30,        (u_int8_t const   )180, 
            (u_int8_t const   )80,        (u_int8_t const   )4,        (u_int8_t const   )246,        (u_int8_t const   )194, 
            (u_int8_t const   )22,        (u_int8_t const   )37,        (u_int8_t const   )134,        (u_int8_t const   )86, 
            (u_int8_t const   )85,        (u_int8_t const   )9,        (u_int8_t const   )190,        (u_int8_t const   )145}};
#line 102 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/twofish.c"
static int TwoFish_MDSready___0  =    0;
#line 103 "/home/wheatley/newnew/temp/n2n-1.3.1~svn3789/twofish.c"
static u_int32_t TwoFish_MDS___0[4][256]  ;
