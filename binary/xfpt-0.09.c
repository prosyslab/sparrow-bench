/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 98 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 32 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/mytypes.h"
typedef int BOOL;
#line 33 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/mytypes.h"
typedef unsigned char uschar;
#line 13 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/structs.h"
struct istackstr {
   struct istackstr *prev ;
   int linenumber ;
   FILE *file ;
   uschar filename[256] ;
};
#line 13 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/structs.h"
typedef struct istackstr istackstr;
#line 44 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/structs.h"
struct argstr {
   struct argstr *next ;
   uschar *string ;
};
#line 44 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/structs.h"
typedef struct argstr argstr;
#line 51 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/structs.h"
struct macrodef {
   struct macrodef *next ;
   argstr *lines ;
   argstr *args ;
   uschar *name ;
   int namelength ;
};
#line 51 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/structs.h"
typedef struct macrodef macrodef;
#line 61 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/structs.h"
struct macroexe {
   struct macroexe *prev ;
   macrodef *macro ;
   argstr *args ;
   argstr *nextline ;
};
#line 61 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/structs.h"
typedef struct macroexe macroexe;
#line 35 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/error.c"
struct __anonstruct_error_struct_29 {
   char ec ;
   char const   *text ;
};
#line 35 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/error.c"
typedef struct __anonstruct_error_struct_29 error_struct;
#line 34 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/structs.h"
struct pushstr {
   struct pushstr *next ;
   int letter ;
   int check ;
   uschar *macname ;
   uschar string[1] ;
};
#line 34 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/structs.h"
typedef struct pushstr pushstr;
#line 22 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/structs.h"
struct flagstr {
   struct flagstr *next ;
   int length1 ;
   uschar *flag1 ;
   uschar *rep1 ;
   int length2 ;
   uschar *flag2 ;
   uschar *rep2 ;
};
#line 22 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/structs.h"
typedef struct flagstr flagstr;
#line 70 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/structs.h"
struct tree_node {
   struct tree_node *left ;
   struct tree_node *right ;
   uschar *data ;
   uschar balance ;
   uschar name[1] ;
};
#line 70 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/structs.h"
typedef struct tree_node tree_node;
#line 738 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/dot.c"
struct dirstr {
   uschar *name ;
   int length ;
   void (*function)(uschar * ) ;
   BOOL onearg ;
   BOOL okinline ;
};
#line 738 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/dot.c"
typedef struct dirstr dirstr;
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 21 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/globals.h"
int from_type[20] ;
#line 22
int from_type_ptr ;
#line 25
istackstr *istack ;
#line 34
macroexe *macrocurrent ;
#line 47
int return_code ;
#line 50
BOOL suppress_warnings ;
#line 11 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/functions.h"
void error(int n  , ...) ;
#line 26 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/error.c"
static int error_count  =    0;
#line 27 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/error.c"
static int warning_count  =    0;
#line 41 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/error.c"
static error_struct error_data[29]  = 
#line 41
  {      {(char)4, "failed to open %s: %s"}, 
        {(char)4, "malloc failed: requested %d bytes"}, 
        {(char)2, "unknown directive line: %s"}, 
        {(char)2, "missing semicolon after \"&%.*s\""}, 
        {(char)2, "unexpected character \"%c\" after \"&#\""}, 
        {(char)2, "\"layout\", \"text\", \"xml\", or \"off\" expected, but \"%s\" found"}, 
        {(char)2,
      "unknown flag \"&%c\""}, 
        {(char)2, "missing closing flag %s"}, 
        {(char)2, "flag nesting error: \"%s\" expected before \"%s\""}, 
        {(char)2, "a flag must begin with \"&\""}, 
        {(char)2, "a flag must contain more than just \"&\""}, 
        {(char)2, "malformed directive\n   %s"}, 
        {(char)2, "line stack is empty"}, 
        {(char)2, "missing %s at end of file"}, 
        {(char)2, "a macro must be given a name"}, 
        {(char)2, "%s is permitted only inside a macro"}, 
        {(char)2, "unexpected %s"}, 
        {(char)2, "bad macro argument substitution: \"%c\" follows \"%s\""}, 
        {(char)2, "relative macro argument not in \"eacharg\" section"}, 
        {(char)1, "extra characters at end of directive\n   %s %s\n   %.*s%.*s"}, 
        {(char)4, "string too long for internal buffer (%d > %d)"}, 
        {(char)2, "entity \"%s\" has already been defined"}, 
        {(char)2, "\"%s\" is not permitted in an inline macro call"}, 
        {(char)2, "unknown macro \"%.*s\" in inline macro call"}, 
        {(char)2, "missing closing parenthesis in inline macro call:\n   %s"}, 
        {(char)2, "ampersand found at end of line or string - ignored"}, 
        {(char)2, "\"begin\" or \"end\" expected, but \"%s\" found"}, 
        {(char)2, "\".nest begin\" too deeply nested"}, 
        {(char)2, "\".nest end\" incorrectly nested"}};
#line 101 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/error.c"
void error(int n  , ...) 
{ 
  int ec ;
  int i ;
  macroexe *me ;
  istackstr *fe ;
  va_list ap ;

  {
  {
#line 108
  __builtin_va_start(ap, n);
  }
#line 110
  if (n > 28) {
    {
#line 112
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"** Unknown error number %d\n",
            n);
#line 113
    ec = 4;
    }
  } else {
#line 117
    ec = (int )error_data[n].ec;
#line 118
    if (ec == 1) {
#line 120
      if (suppress_warnings) {
#line 120
        return;
      }
      {
#line 121
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"** Warning: ");
      }
    } else
#line 123
    if (ec > 1) {
      {
#line 124
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"** Error: ");
      }
    }
    {
#line 125
    vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)error_data[n].text,
             ap);
#line 126
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
  }
  {
#line 129
  __builtin_va_end(ap);
#line 131
  me = macrocurrent;
#line 132
  fe = istack;
#line 134
  i = from_type_ptr;
  }
  {
#line 134
  while (1) {
    while_continue: /* CIL Label */ ;
#line 134
    if (! (i >= 0)) {
#line 134
      goto while_break;
    }
#line 136
    if (from_type[i] == 1) {
      {
#line 138
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"   Processing macro %s\n",
              (me->macro)->name);
#line 139
      me = me->prev;
      }
    } else
#line 143
    if ((unsigned long )fe != (unsigned long )((void *)0)) {
      {
#line 145
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"   Detected near line %d of %s\n",
              fe->linenumber, fe->filename);
#line 147
      fe = fe->prev;
      }
    } else {
      {
#line 151
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"   Detected near end of file\n");
      }
    }
#line 134
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 156
  if (ec == 1) {
#line 158
    warning_count ++;
#line 159
    if (warning_count > 40) {
      {
#line 161
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"** Too many warnings - subsequent ones suppressed\n");
#line 162
      suppress_warnings = 1;
      }
    }
  } else
#line 166
  if (ec > 1) {
#line 168
    return_code = 1;
#line 169
    error_count ++;
#line 170
    if (error_count > 40) {
      {
#line 172
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"** Too many errors\n");
#line 173
      ec = 3;
      }
    }
  }
#line 177
  if (ec >= 3) {
    {
#line 179
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"** xfpt abandoned\n");
#line 180
    exit(1);
    }
  }
  {
#line 183
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
  }
#line 184
  return;
}
}
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 15 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/globals.h"
uschar *xfpt_share ;
#line 16
uschar *xfpt_version ;
#line 24
uschar *inbuffer ;
#line 26
istackstr *istackbase ;
#line 28
int literal_state ;
#line 30
int nest_level ;
#line 31
int nest_literal_stack[4] ;
#line 40
FILE *outfile ;
#line 43
uschar *parabuffer ;
#line 45
pushstr *pushed ;
#line 10 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/functions.h"
void dot_process(uschar *p ) ;
#line 12
void literal_process(uschar *p ) ;
#line 15
void *misc_malloc(int size ) ;
#line 19
void para_process(uschar *p ) ;
#line 21
uschar *read_nextline(void) ;
#line 22
uschar *read_paragraph(uschar *p , int *nest_info ) ;
#line 18 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/xfpt.c"
static uschar *xfpt_filename  =    (uschar *)((void *)0);
#line 19 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/xfpt.c"
static uschar *out_filename  =    (uschar *)((void *)0);
#line 28 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/xfpt.c"
static void usage(void) 
{ 


  {
  {
#line 31
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: xfpt [-help]\n            [-o <output-file>]\n            [-S <share-directory>]\n            [-v]\n            [input-file]\n");
  }
#line 37
  return;
}
}
#line 50 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/xfpt.c"
static BOOL xfpt_decode_arg(int argc , char **argv ) 
{ 
  int i ;
  uschar *arg ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  uschar *p ;
  int len ;
  size_t tmp___4 ;
  void *tmp___5 ;
  char *tmp___6 ;

  {
#line 54
  i = 1;
  {
#line 54
  while (1) {
    while_continue: /* CIL Label */ ;
#line 54
    if (! (i < argc)) {
#line 54
      goto while_break;
    }
#line 56
    arg = (unsigned char *)*(argv + i);
#line 57
    if ((int )*arg != 45) {
#line 57
      goto while_break;
    }
    {
#line 58
    tmp___3 = strcmp((char const   *)arg, "-o");
    }
#line 58
    if (tmp___3 == 0) {
#line 60
      i ++;
#line 60
      out_filename = (unsigned char *)*(argv + i);
#line 61
      if ((unsigned long )out_filename == (unsigned long )((void *)0)) {
        {
#line 61
        usage();
        }
#line 61
        return (0);
      }
    } else {
      {
#line 63
      tmp___2 = strcmp((char const   *)arg, "-S");
      }
#line 63
      if (tmp___2 == 0) {
#line 65
        i ++;
#line 65
        xfpt_share = (unsigned char *)*(argv + i);
#line 66
        if ((unsigned long )xfpt_share == (unsigned long )((void *)0)) {
          {
#line 66
          usage();
          }
#line 66
          return (0);
        }
      } else {
        {
#line 68
        tmp___0 = strcmp((char const   *)arg, "-help");
        }
#line 68
        if (tmp___0 == 0) {
          {
#line 70
          usage();
          }
#line 71
          return (0);
        } else {
          {
#line 68
          tmp___1 = strcmp((char const   *)arg, "--help");
          }
#line 68
          if (tmp___1 == 0) {
            {
#line 70
            usage();
            }
#line 71
            return (0);
          } else {
            {
#line 73
            tmp = strcmp((char const   *)arg, "-v");
            }
#line 73
            if (tmp == 0) {
              {
#line 75
              fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"xpft version %s\n",
                      xfpt_version);
#line 76
              exit(0);
              }
            } else {
              {
#line 80
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"xfpt: unknown option \"%s\"\n",
                      arg);
#line 81
              usage();
              }
#line 82
              return (0);
            }
          }
        }
      }
    }
#line 54
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 88
  if (argc > i + 1) {
    {
#line 90
    usage();
    }
#line 91
    return (0);
  }
#line 97
  xfpt_filename = (unsigned char *)*(argv + i);
#line 98
  if ((unsigned long )xfpt_filename != (unsigned long )((void *)0)) {
#line 98
    if ((unsigned long )out_filename == (unsigned long )((void *)0)) {
      {
#line 101
      tmp___4 = strlen((char const   *)xfpt_filename);
#line 101
      len = (int )tmp___4;
#line 102
      tmp___5 = misc_malloc(len + 5);
#line 102
      out_filename = (uschar *)tmp___5;
#line 103
      strcpy((char */* __restrict  */)((char *)out_filename), (char const   */* __restrict  */)((char const   *)xfpt_filename));
#line 104
      tmp___6 = strrchr((char const   *)out_filename, '.');
#line 104
      p = (unsigned char *)tmp___6;
      }
#line 104
      if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 104
        len = (int )(p - out_filename);
      }
      {
#line 105
      strcpy((char */* __restrict  */)((char *)(out_filename + len)), (char const   */* __restrict  */)".xml");
      }
    }
  }
#line 108
  return (1);
}
}
#line 117 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/xfpt.c"
int main(int argc , char **argv ) 
{ 
  BOOL para_unfinished[4] ;
  int warnpop ;
  uschar *p ;
  uschar *q ;
  BOOL tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  unsigned short const   **tmp___8 ;
  int nest_info ;
  int tmp___9 ;
  char const   *tmp___10 ;
  int tmp___11 ;

  {
  {
#line 121
  warnpop = 0;
#line 124
  tmp = xfpt_decode_arg(argc, argv);
  }
#line 124
  if (! tmp) {
#line 124
    return (1);
  }
  {
#line 126
  tmp___0 = misc_malloc(1024);
#line 126
  inbuffer = (uschar *)tmp___0;
#line 127
  tmp___1 = misc_malloc(10000);
#line 127
  parabuffer = (uschar *)tmp___1;
#line 131
  tmp___2 = misc_malloc((int )sizeof(istackstr ));
#line 131
  istack = (istackstr *)tmp___2;
#line 131
  istackbase = istack;
#line 132
  istack->prev = (struct istackstr *)((void *)0);
#line 133
  istack->linenumber = 0;
#line 135
  from_type_ptr = 0;
#line 136
  from_type[from_type_ptr] = 0;
  }
#line 138
  if ((unsigned long )xfpt_filename == (unsigned long )((void *)0)) {
    {
#line 140
    istack->file = stdin;
#line 141
    strcpy((char */* __restrict  */)((char *)(istack->filename)), (char const   */* __restrict  */)((char const   *)((unsigned char *)"(stdin)")));
    }
  } else {
    {
#line 145
    strcpy((char */* __restrict  */)((char *)(istack->filename)), (char const   */* __restrict  */)((char const   *)xfpt_filename));
#line 146
    istack->file = fopen((char const   */* __restrict  */)((char const   *)xfpt_filename),
                         (char const   */* __restrict  */)"rb");
    }
#line 147
    if ((unsigned long )istack->file == (unsigned long )((void *)0)) {
      {
#line 148
      tmp___3 = __errno_location();
#line 148
      tmp___4 = strerror(*tmp___3);
#line 148
      error(0, istack->filename, tmp___4);
      }
    }
  }
#line 153
  if ((unsigned long )out_filename == (unsigned long )((void *)0)) {
#line 155
    outfile = stdout;
  } else {
    {
#line 153
    tmp___7 = strcmp((char const   *)out_filename, "-");
    }
#line 153
    if (tmp___7 == 0) {
#line 155
      outfile = stdout;
    } else {
      {
#line 159
      outfile = fopen((char const   */* __restrict  */)((char const   *)out_filename),
                      (char const   */* __restrict  */)"wb");
      }
#line 160
      if ((unsigned long )outfile == (unsigned long )((void *)0)) {
        {
#line 161
        tmp___5 = __errno_location();
#line 161
        tmp___6 = strerror(*tmp___5);
#line 161
        error(0, out_filename, tmp___6);
        }
      }
    }
  }
#line 166
  nest_level = 0;
#line 167
  para_unfinished[0] = 0;
  {
#line 169
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 169
    p = read_nextline();
    }
#line 169
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 169
      goto while_break;
    }
#line 171
    if ((int )*p == 46) {
      {
#line 171
      dot_process(p);
      }
    } else {
      {
#line 173
      if (literal_state == 1) {
#line 173
        goto case_1;
      }
#line 177
      if (literal_state == 2) {
#line 177
        goto case_2;
      }
#line 181
      if (literal_state == 3) {
#line 181
        goto case_3;
      }
#line 185
      goto switch_default;
      case_1: /* CIL Label */ 
      {
#line 174
      para_process(p);
      }
#line 175
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 178
      literal_process(p);
      }
#line 179
      goto switch_break;
      case_3: /* CIL Label */ 
      {
#line 182
      fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"%s",
              (char *)p);
      }
#line 183
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 187
      q = p;
      {
#line 188
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 188
        tmp___8 = __ctype_b_loc();
        }
#line 188
        if (! ((int const   )*(*tmp___8 + (int )*q) & 8192)) {
#line 188
          goto while_break___0;
        }
#line 188
        q ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 189
      if ((int )*q != 0) {
        {
#line 192
        p = read_paragraph(p, & nest_info);
        }
#line 193
        if (! para_unfinished[nest_level]) {
          {
#line 195
          fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"<");
#line 196
          para_process((unsigned char *)"para&xfpt.rev;");
#line 197
          fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)">\n");
          }
        }
        {
#line 200
        para_process(p);
        }
#line 201
        if (nest_info == 1) {
#line 203
          if (nest_level >= 3) {
            {
#line 203
            error(27);
            }
          } else {
#line 205
            nest_literal_stack[nest_level] = literal_state;
#line 206
            tmp___9 = nest_level;
#line 206
            nest_level ++;
#line 206
            para_unfinished[tmp___9] = 1;
          }
        } else {
          {
#line 209
          fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"</para>\n");
          }
        }
#line 211
        para_unfinished[nest_level] = 0;
#line 213
        if (nest_info == 2) {
#line 215
          if (nest_level <= 0) {
            {
#line 215
            error(28);
            }
          } else {
#line 216
            nest_level --;
#line 216
            literal_state = nest_literal_stack[nest_level];
          }
        }
      }
#line 219
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 225
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 225
    if (! ((unsigned long )pushed != (unsigned long )((void *)0))) {
#line 225
      goto while_break___1;
    }
#line 227
    if (! suppress_warnings) {
#line 229
      if (pushed->check != 0) {
#line 231
        tmp___11 = warnpop;
#line 231
        warnpop ++;
#line 231
        if (tmp___11 == 0) {
#line 232
          if ((unsigned long )xfpt_filename == (unsigned long )((void *)0)) {
#line 232
            tmp___10 = "(stdin)";
          } else {
#line 232
            tmp___10 = (char const   *)((char *)xfpt_filename);
          }
          {
#line 232
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"** Warning: one or more items were left unclosed at the end of processing.\n   The numbers are the lines in the original file %s from where\n   the items were generated:\n",
                  tmp___10);
          }
        }
#line 237
        if ((unsigned long )pushed->macname == (unsigned long )((void *)0)) {
          {
#line 238
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%d: %s\n",
                  pushed->check, pushed->string);
          }
        } else {
          {
#line 240
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%d: .%s\n",
                  pushed->check, pushed->macname);
          }
        }
#line 242
        if (warnpop > 10) {
          {
#line 244
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"... too many to list\n");
#line 245
          suppress_warnings = 1;
          }
        }
      }
    }
    {
#line 249
    para_process(pushed->string);
#line 250
    fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"\n");
#line 251
    pushed = pushed->next;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 254
  fclose(outfile);
  }
#line 256
  return (return_code);
}
}
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 483 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 18 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/globals.h"
tree_node *entities ;
#line 20
flagstr *flaglist ;
#line 32
uschar *next_line ;
#line 35
macrodef *macrolist ;
#line 37
argstr *macro_argbase ;
#line 38
argstr *macro_starteach ;
#line 42
int para_inline_macro ;
#line 44
int popto ;
#line 48
uschar *revision ;
#line 13 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/functions.h"
uschar *misc_copystring(uschar *p , int length ) ;
#line 14
void misc_detrail(uschar *p ) ;
#line 16
uschar *misc_readitem(uschar *p , uschar *term , int *lptr , uschar *buffer , int blength ) ;
#line 17
uschar *misc_readstring(uschar *p , int *lptr , uschar *buffer , int blength ) ;
#line 25
int tree_insertnode(tree_node **treebase , tree_node *node ) ;
#line 18 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/dot.c"
static uschar *circumflexes  =    (unsigned char *)"^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^";
#line 20 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/dot.c"
static uschar *spaces  =    (unsigned char *)"                                                                         ";
#line 22 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/dot.c"
static uschar *thisdir  =    (uschar *)((void *)0);
#line 36 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/dot.c"
static int readnumber(uschar *p ) 
{ 
  int n ;
  unsigned short const   **tmp ;
  uschar *tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
  {
#line 39
  n = 0;
#line 40
  tmp = __ctype_b_loc();
  }
#line 40
  if (! ((int const   )*(*tmp + (int )*p) & 2048)) {
    {
#line 40
    error(11, thisdir);
    }
#line 40
    return (-1);
  }
  {
#line 41
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 41
    tmp___1 = __ctype_b_loc();
    }
#line 41
    if (! ((int const   )*(*tmp___1 + (int )*p) & 2048)) {
#line 41
      goto while_break;
    }
#line 41
    tmp___0 = p;
#line 41
    p ++;
#line 41
    n = (n * 10 + (int )*tmp___0) - 48;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 42
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 42
    tmp___2 = __ctype_b_loc();
    }
#line 42
    if (! ((int const   )*(*tmp___2 + (int )*p) & 8192)) {
#line 42
      goto while_break___0;
    }
#line 42
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 43
  if ((int )*p != 0) {
    {
#line 43
    error(11, thisdir);
    }
#line 43
    return (-1);
  }
#line 44
  return (n);
}
}
#line 63 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/dot.c"
static void skipto(uschar *s , uschar *t ) 
{ 
  int nest ;
  int slength ;
  size_t tmp ;
  int tlength ;
  size_t tmp___0 ;
  BOOL done ;
  uschar *p ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  unsigned short const   **tmp___6 ;
  macroexe *temp ;

  {
  {
#line 66
  nest = -1;
#line 67
  tmp = strlen((char const   *)s);
#line 67
  slength = (int )tmp;
#line 68
  tmp___0 = strlen((char const   *)t);
#line 68
  tlength = (int )tmp___0;
#line 69
  done = (unsigned long )macrocurrent->nextline == (unsigned long )((void *)0);
  }
  {
#line 70
  while (1) {
    while_continue: /* CIL Label */ ;
#line 70
    if (! (! done)) {
#line 70
      goto while_break;
    }
    {
#line 72
    p = (macrocurrent->nextline)->string;
#line 73
    tmp___1 = strncmp((char const   *)p, (char const   *)t, (size_t )tlength);
    }
#line 73
    if (tmp___1 == 0) {
#line 73
      if ((int )*(p + tlength) == 0) {
#line 73
        goto _L;
      } else {
        {
#line 73
        tmp___2 = __ctype_b_loc();
        }
#line 73
        if ((int const   )*(*tmp___2 + (int )*(p + tlength)) & 8192) {
          _L: /* CIL Label */ 
#line 73
          tmp___3 = nest;
#line 73
          nest --;
#line 73
          if (tmp___3 <= 0) {
#line 73
            tmp___4 = 1;
          } else {
#line 73
            tmp___4 = 0;
          }
        } else {
#line 73
          tmp___4 = 0;
        }
      }
    } else {
#line 73
      tmp___4 = 0;
    }
    {
#line 73
    done = tmp___4;
#line 76
    tmp___5 = strncmp((char const   *)p, (char const   *)s, (size_t )slength);
    }
#line 76
    if (tmp___5 == 0) {
#line 76
      if ((int )*(p + slength) == 0) {
#line 77
        nest ++;
      } else {
        {
#line 76
        tmp___6 = __ctype_b_loc();
        }
#line 76
        if ((int const   )*(*tmp___6 + (int )*(p + slength)) & 8192) {
#line 77
          nest ++;
        }
      }
    }
#line 78
    macrocurrent->nextline = (macrocurrent->nextline)->next;
#line 79
    if ((unsigned long )macrocurrent->nextline == (unsigned long )((void *)0)) {
      {
#line 81
      temp = macrocurrent;
#line 82
      macrocurrent = macrocurrent->prev;
#line 83
      free((void *)temp);
#line 84
      from_type_ptr --;
      }
#line 85
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 88
  return;
}
}
#line 107 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/dot.c"
static void do_arg(uschar *p ) 
{ 
  BOOL mustexist ;
  argstr *arg ;
  int i ;
  int argn ;
  int tmp ;

  {
#line 110
  mustexist = 1;
#line 114
  if (from_type[from_type_ptr] != 1) {
    {
#line 114
    error(15, (unsigned char *)".arg");
    }
#line 114
    return;
  }
#line 116
  if ((int )*p == 45) {
#line 118
    mustexist = 0;
#line 119
    p ++;
  }
  {
#line 122
  argn = readnumber(p);
  }
#line 123
  if (argn < 0) {
#line 123
    return;
  }
#line 125
  arg = macrocurrent->args;
#line 126
  i = 1;
  {
#line 126
  while (1) {
    while_continue: /* CIL Label */ ;
#line 126
    if ((unsigned long )arg != (unsigned long )((void *)0)) {
#line 126
      if (! (i < argn)) {
#line 126
        goto while_break;
      }
    } else {
#line 126
      goto while_break;
    }
#line 126
    arg = arg->next;
#line 126
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 128
  if ((unsigned long )arg != (unsigned long )((void *)0)) {
#line 128
    if ((int )*(arg->string + 0) != 0) {
#line 128
      tmp = 1;
    } else {
#line 128
      tmp = 0;
    }
  } else {
#line 128
    tmp = 0;
  }
#line 128
  if (mustexist != tmp) {
    {
#line 129
    skipto((unsigned char *)".arg", (unsigned char *)".endarg");
    }
  }
#line 130
  return;
}
}
#line 145 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/dot.c"
static void do_eacharg(uschar *p ) 
{ 
  argstr *arg ;
  int argn ;
  int i ;
  int tmp ;

  {
#line 151
  if (from_type[from_type_ptr] != 1) {
    {
#line 151
    error(15, (unsigned char *)".eacharg");
    }
#line 151
    return;
  }
#line 153
  if ((int )*p == 0) {
#line 153
    argn = 1;
  } else {
    {
#line 153
    tmp = readnumber(p);
#line 153
    argn = tmp;
    }
  }
#line 154
  if (argn < 0) {
#line 154
    return;
  }
#line 156
  arg = macrocurrent->args;
#line 157
  i = 1;
  {
#line 157
  while (1) {
    while_continue: /* CIL Label */ ;
#line 157
    if ((unsigned long )arg != (unsigned long )((void *)0)) {
#line 157
      if (! (i < argn)) {
#line 157
        goto while_break;
      }
    } else {
#line 157
      goto while_break;
    }
#line 157
    arg = arg->next;
#line 157
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 162
  if ((unsigned long )arg == (unsigned long )((void *)0)) {
    {
#line 162
    skipto((unsigned char *)"eacharg", (unsigned char *)".endeach");
    }
  } else {
#line 164
    macro_argbase = arg;
#line 165
    macro_starteach = macrocurrent->nextline;
  }
#line 167
  return;
}
}
#line 181 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/dot.c"
static void do_echo(uschar *p ) 
{ 


  {
  {
#line 184
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          p);
  }
#line 185
  return;
}
}
#line 200 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/dot.c"
static void do_endarg(uschar *p ) 
{ 
  size_t tmp ;

  {
#line 203
  if (from_type[from_type_ptr] != 1) {
    {
#line 203
    error(15, (unsigned char *)".endarg");
    }
#line 203
    return;
  }
#line 204
  if ((int )*p != 0) {
    {
#line 204
    tmp = strlen((char const   *)p);
#line 204
    error(19, ".endarg", p, 8, spaces, (int )tmp, circumflexes);
    }
  }
#line 205
  return;
}
}
#line 221 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/dot.c"
static void do_endeach(uschar *p ) 
{ 
  int count ;
  int tmp ;
  int tmp___0 ;

  {
#line 226
  if (from_type[from_type_ptr] != 1) {
    {
#line 226
    error(15, (unsigned char *)".endeach");
    }
#line 226
    return;
  }
#line 228
  if ((int )*p == 0) {
#line 228
    count = 1;
  } else {
    {
#line 228
    tmp = readnumber(p);
#line 228
    count = tmp;
    }
  }
#line 229
  if (count < 0) {
#line 229
    return;
  }
  {
#line 231
  while (1) {
    while_continue: /* CIL Label */ ;
#line 231
    tmp___0 = count;
#line 231
    count --;
#line 231
    if (tmp___0 > 0) {
#line 231
      if (! ((unsigned long )macro_argbase != (unsigned long )((void *)0))) {
#line 231
        goto while_break;
      }
    } else {
#line 231
      goto while_break;
    }
#line 232
    macro_argbase = macro_argbase->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 234
  if ((unsigned long )macro_argbase == (unsigned long )((void *)0)) {
#line 234
    macro_starteach = (argstr *)((void *)0);
  } else {
#line 235
    macrocurrent->nextline = macro_starteach;
  }
#line 236
  return;
}
}
#line 252 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/dot.c"
static void do_endinliteral(uschar *p ) 
{ 
  size_t tmp ;

  {
#line 255
  if (from_type[from_type_ptr] != 1) {
    {
#line 255
    error(15, (unsigned char *)".endinliteral");
    }
#line 255
    return;
  }
#line 256
  if ((int )*p != 0) {
    {
#line 256
    tmp = strlen((char const   *)p);
#line 256
    error(19, ".endinliteral", p, 8, spaces, (int )tmp, circumflexes);
    }
  }
#line 257
  return;
}
}
#line 278 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/dot.c"
static void do_flag(uschar *p ) 
{ 
  uschar *pp ;
  uschar *q ;
  int length ;
  int term ;
  flagstr *f ;
  flagstr **ff ;
  void *tmp ;
  uschar *tmp___0 ;
  unsigned short const   **tmp___1 ;
  size_t tmp___2 ;
  unsigned short const   **tmp___3 ;
  uschar *tmp___4 ;
  unsigned short const   **tmp___5 ;
  unsigned short const   **tmp___6 ;

  {
  {
#line 285
  tmp = misc_malloc((int )sizeof(flagstr ));
#line 285
  f = (flagstr *)tmp;
#line 289
  tmp___0 = p;
#line 289
  p ++;
  }
#line 289
  if ((int )*tmp___0 != 38) {
    {
#line 289
    error(9);
    }
#line 289
    return;
  }
#line 291
  pp = p;
  {
#line 291
  while (1) {
    while_continue: /* CIL Label */ ;
#line 291
    if ((int )*pp != 0) {
      {
#line 291
      tmp___1 = __ctype_b_loc();
      }
#line 291
      if ((int const   )*(*tmp___1 + (int )*pp) & 8192) {
#line 291
        goto while_break;
      }
    } else {
#line 291
      goto while_break;
    }
#line 291
    pp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 292
  length = (int )(pp - p);
#line 293
  if (length == 0) {
    {
#line 293
    error(10);
    }
#line 293
    return;
  }
  {
#line 295
  f->length1 = length;
#line 296
  f->flag1 = misc_copystring(p, length);
#line 301
  tmp___2 = strlen((char const   *)pp);
#line 301
  q = pp + (int )tmp___2;
#line 302
  q --;
  }
#line 302
  if ((int )*q != 34) {
#line 302
    if ((int )*q != 39) {
      {
#line 302
      error(11, thisdir);
      }
#line 302
      return;
    }
  }
#line 304
  term = (int )*q;
  {
#line 305
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 305
    q --;
#line 305
    if (! ((unsigned long )q > (unsigned long )pp)) {
#line 305
      goto while_break___0;
    }
#line 307
    if ((int )*q == term) {
#line 307
      if ((int )*(q + -1) == term) {
#line 307
        q --;
      } else {
#line 307
        goto while_break___0;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 310
  if ((unsigned long )q <= (unsigned long )pp) {
    {
#line 310
    error(11, thisdir);
    }
#line 310
    return;
  }
  {
#line 315
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 315
    tmp___3 = __ctype_b_loc();
    }
#line 315
    if (! ((int const   )*(*tmp___3 + (int )*pp) & 8192)) {
#line 315
      goto while_break___1;
    }
#line 315
    pp ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 316
  if ((unsigned long )pp == (unsigned long )q) {
    {
#line 318
    f->rep1 = misc_readstring(q, (int *)((void *)0), (uschar *)((void *)0), 0);
#line 319
    f->length2 = 0;
#line 320
    tmp___4 = (uschar *)((void *)0);
#line 320
    f->rep2 = tmp___4;
#line 320
    f->flag2 = tmp___4;
    }
  } else {
    {
#line 327
    f->rep2 = misc_readstring(q, (int *)((void *)0), (uschar *)((void *)0), 0);
#line 328
    p = pp;
    }
    {
#line 329
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 329
      if ((int )*pp != 0) {
        {
#line 329
        tmp___5 = __ctype_b_loc();
        }
#line 329
        if ((int const   )*(*tmp___5 + (int )*pp) & 8192) {
#line 329
          goto while_break___2;
        }
      } else {
#line 329
        goto while_break___2;
      }
#line 329
      pp ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 330
    length = (int )(pp - p);
#line 331
    if (length == 0) {
      {
#line 331
      error(10);
      }
#line 331
      return;
    }
    {
#line 332
    f->length2 = length;
#line 333
    f->flag2 = misc_copystring(p, length);
    }
    {
#line 334
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 334
      tmp___6 = __ctype_b_loc();
      }
#line 334
      if (! ((int const   )*(*tmp___6 + (int )*pp) & 8192)) {
#line 334
        goto while_break___3;
      }
#line 334
      pp ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 335
    if ((int )*pp != 34) {
#line 335
      if ((int )*pp != 39) {
        {
#line 335
        error(11, thisdir);
        }
#line 335
        return;
      }
    }
    {
#line 336
    f->rep1 = misc_readstring(pp, & length, (uschar *)((void *)0), 0);
    }
#line 337
    if ((unsigned long )(pp + length) >= (unsigned long )q) {
      {
#line 337
      error(11, thisdir);
      }
#line 337
      return;
    }
  }
#line 343
  ff = & flaglist;
  {
#line 344
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 344
    if ((unsigned long )*ff != (unsigned long )((void *)0)) {
#line 344
      if (! (f->length1 < (*ff)->length1)) {
#line 344
        goto while_break___4;
      }
    } else {
#line 344
      goto while_break___4;
    }
#line 344
    ff = & (*ff)->next;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 345
  f->next = *ff;
#line 346
  *ff = f;
#line 347
  return;
}
}
#line 361 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/dot.c"
static void do_include(uschar *p ) 
{ 
  istackstr *ist ;
  void *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 366
  tmp = misc_malloc((int )sizeof(istackstr ));
#line 366
  ist = (istackstr *)tmp;
#line 367
  ist->prev = istack;
#line 368
  istack = ist;
#line 369
  ist->linenumber = 0;
#line 371
  tmp___0 = strchr((char const   *)p, '/');
  }
#line 371
  if ((unsigned long )((unsigned char *)tmp___0) != (unsigned long )((void *)0)) {
    {
#line 371
    strcpy((char */* __restrict  */)((char *)(ist->filename)), (char const   */* __restrict  */)((char const   *)p));
    }
  } else {
    {
#line 372
    sprintf((char */* __restrict  */)((char *)(ist->filename)), (char const   */* __restrict  */)"%s/%s",
            xfpt_share, p);
    }
  }
  {
#line 374
  ist->file = fopen((char const   */* __restrict  */)((char const   *)(ist->filename)),
                    (char const   */* __restrict  */)"rb");
  }
#line 375
  if ((unsigned long )ist->file == (unsigned long )((void *)0)) {
    {
#line 375
    tmp___1 = __errno_location();
#line 375
    tmp___2 = strerror(*tmp___1);
#line 375
    error(0, ist->filename, tmp___2);
    }
  }
#line 377
  from_type_ptr ++;
#line 377
  from_type[from_type_ptr] = 0;
#line 378
  return;
}
}
#line 394 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/dot.c"
static void do_inliteral(uschar *p ) 
{ 
  int state ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 397
  state = -1;
#line 398
  if (from_type[from_type_ptr] != 1) {
    {
#line 398
    error(15, (unsigned char *)".inliteral");
    }
#line 398
    return;
  }
  {
#line 399
  tmp___2 = strcmp((char const   *)p, "layout");
  }
#line 399
  if (tmp___2 == 0) {
#line 399
    state = 1;
  } else {
    {
#line 400
    tmp___1 = strcmp((char const   *)p, "text");
    }
#line 400
    if (tmp___1 == 0) {
#line 400
      state = 2;
    } else {
      {
#line 401
      tmp___0 = strcmp((char const   *)p, "off");
      }
#line 401
      if (tmp___0 == 0) {
#line 401
        state = 0;
      } else {
        {
#line 402
        tmp = strcmp((char const   *)p, "xml");
        }
#line 402
        if (tmp == 0) {
#line 402
          state = 3;
        } else {
          {
#line 403
          error(5, p);
          }
        }
      }
    }
  }
#line 404
  if (literal_state != state) {
    {
#line 404
    skipto((unsigned char *)"inliteral", (unsigned char *)".endinliteral");
    }
  }
#line 405
  return;
}
}
#line 419 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/dot.c"
static void do_literal(uschar *p ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 422
  tmp___2 = strcmp((char const   *)p, "layout");
  }
#line 422
  if (tmp___2 == 0) {
#line 422
    literal_state = 1;
  } else {
    {
#line 423
    tmp___1 = strcmp((char const   *)p, "text");
    }
#line 423
    if (tmp___1 == 0) {
#line 423
      literal_state = 2;
    } else {
      {
#line 424
      tmp___0 = strcmp((char const   *)p, "off");
      }
#line 424
      if (tmp___0 == 0) {
#line 424
        literal_state = 0;
      } else {
        {
#line 425
        tmp = strcmp((char const   *)p, "xml");
        }
#line 425
        if (tmp == 0) {
#line 425
          literal_state = 3;
        } else {
          {
#line 426
          error(5, p);
          }
        }
      }
    }
  }
#line 427
  return;
}
}
#line 441 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/dot.c"
static void do_macro(uschar *p ) 
{ 
  int length ;
  int nest ;
  argstr **pp ;
  macrodef *md ;
  void *tmp ;
  size_t tmp___0 ;
  argstr *tmp___1 ;
  argstr *as ;
  void *tmp___2 ;
  argstr *as___0 ;
  uschar *line ;
  uschar *tmp___3 ;
  unsigned short const   **tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;
  size_t tmp___8 ;
  void *tmp___9 ;

  {
  {
#line 445
  nest = 0;
#line 447
  tmp = misc_malloc((int )sizeof(macrodef ));
#line 447
  md = (macrodef *)tmp;
#line 449
  md->name = misc_readitem(p, (uschar *)((void *)0), & length, (uschar *)((void *)0),
                           0);
#line 450
  tmp___0 = strlen((char const   *)md->name);
#line 450
  md->namelength = (int )tmp___0;
#line 451
  p += length;
  }
#line 453
  if (length == 0) {
    {
#line 455
    error(14);
    }
#line 456
    return;
  }
#line 459
  tmp___1 = (argstr *)((void *)0);
#line 459
  md->args = tmp___1;
#line 459
  md->lines = tmp___1;
#line 460
  md->next = macrolist;
#line 461
  macrolist = md;
#line 463
  pp = & md->args;
  {
#line 464
  while (1) {
    while_continue: /* CIL Label */ ;
#line 464
    if (! ((int )*p != 0)) {
#line 464
      goto while_break;
    }
    {
#line 466
    tmp___2 = misc_malloc((int )sizeof(argstr ));
#line 466
    as = (argstr *)tmp___2;
#line 467
    as->next = (struct argstr *)((void *)0);
#line 468
    *pp = as;
#line 469
    pp = & as->next;
#line 470
    as->string = misc_readitem(p, (uschar *)((void *)0), & length, (uschar *)((void *)0),
                               0);
#line 471
    p += length;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 474
  pp = & md->lines;
  {
#line 475
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 478
    tmp___3 = read_nextline();
#line 478
    line = tmp___3;
    }
#line 479
    if ((unsigned long )line == (unsigned long )((void *)0)) {
      {
#line 479
      error(13, ".endmacro");
      }
#line 479
      return;
    }
    {
#line 481
    tmp___6 = strncmp((char const   *)line, ".macro ", (size_t )7);
    }
#line 481
    if (tmp___6 == 0) {
#line 481
      nest ++;
    } else {
      {
#line 482
      tmp___5 = strncmp((char const   *)line, ".endmacro", (size_t )9);
      }
#line 482
      if (tmp___5 == 0) {
        {
#line 484
        tmp___4 = __ctype_b_loc();
        }
#line 484
        if ((int const   )*(*tmp___4 + (int )*(line + 9)) & 8192) {
#line 484
          goto _L;
        } else
#line 484
        if ((int )*(line + 9) == 10) {
          _L: /* CIL Label */ 
#line 485
          nest --;
#line 485
          if (nest < 0) {
#line 485
            goto while_break___0;
          }
        }
      }
    }
    {
#line 488
    tmp___7 = misc_malloc((int )sizeof(argstr ));
#line 488
    as___0 = (argstr *)tmp___7;
#line 489
    as___0->next = (struct argstr *)((void *)0);
#line 490
    *pp = as___0;
#line 491
    pp = & as___0->next;
#line 492
    tmp___8 = strlen((char const   *)line);
#line 492
    as___0->string = misc_copystring(line, (int )tmp___8);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 498
  if ((unsigned long )md->lines == (unsigned long )((void *)0)) {
    {
#line 500
    tmp___9 = misc_malloc((int )sizeof(argstr ));
#line 500
    md->lines = (argstr *)tmp___9;
#line 501
    (md->lines)->next = (struct argstr *)((void *)0);
#line 502
    (md->lines)->string = misc_copystring((unsigned char *)". Dummy line\n", 13);
    }
  }
#line 504
  return;
}
}
#line 520 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/dot.c"
static void do_nest(uschar *p ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 523
  tmp___1 = strcmp((char const   *)p, "begin");
  }
#line 523
  if (tmp___1 == 0) {
#line 525
    if (nest_level >= 3) {
      {
#line 525
      error(27);
      }
    } else {
#line 527
      tmp = nest_level;
#line 527
      nest_level ++;
#line 527
      nest_literal_stack[tmp] = literal_state;
#line 528
      literal_state = 0;
    }
  } else {
    {
#line 531
    tmp___0 = strcmp((char const   *)p, "end");
    }
#line 531
    if (tmp___0 == 0) {
#line 533
      if (nest_level <= 0) {
        {
#line 533
        error(28);
        }
      } else {
#line 534
        nest_level --;
#line 534
        literal_state = nest_literal_stack[nest_level];
      }
    } else {
      {
#line 536
      error(26, p);
      }
    }
  }
#line 537
  return;
}
}
#line 556 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/dot.c"
static uschar nonlbuffer[1024]  ;
#line 553 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/dot.c"
static void do_nonl(uschar *p ) 
{ 
  int len ;
  size_t tmp ;

  {
  {
#line 557
  tmp = strlen((char const   *)p);
#line 557
  len = (int )tmp + 1;
  }
#line 558
  if (len > 1024) {
#line 558
    len = 1024;
  }
  {
#line 559
  strncpy((char */* __restrict  */)((char *)(nonlbuffer)), (char const   */* __restrict  */)((char const   *)p),
          (size_t )len);
#line 560
  next_line = nonlbuffer;
  }
#line 561
  return;
}
}
#line 577 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/dot.c"
static void do_pop(uschar *p ) 
{ 
  pushstr *ps ;
  unsigned short const   **tmp ;

  {
#line 582
  if ((int )*p == 0) {
#line 584
    popto = 0;
#line 585
    return;
  }
  {
#line 588
  tmp = __ctype_b_loc();
  }
#line 588
  if ((int const   )*(*tmp + (int )*p) & 256) {
#line 588
    if ((int )*(p + 1) != 0) {
      {
#line 588
      error(11, thisdir);
      }
#line 588
      return;
    }
  } else {
    {
#line 588
    error(11, thisdir);
    }
#line 588
    return;
  }
#line 590
  ps = pushed;
  {
#line 590
  while (1) {
    while_continue: /* CIL Label */ ;
#line 590
    if (! ((unsigned long )ps != (unsigned long )((void *)0))) {
#line 590
      goto while_break;
    }
#line 591
    if (ps->letter == (int )*p) {
#line 591
      goto while_break;
    }
#line 590
    ps = ps->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 593
  if ((unsigned long )ps != (unsigned long )((void *)0)) {
#line 593
    popto = (int )*p;
  }
#line 594
  return;
}
}
#line 613 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/dot.c"
static void do_push(uschar *p ) 
{ 
  int length ;
  int letter ;
  int check ;
  pushstr *ps ;
  uschar *macname ;
  uschar *porig ;
  uschar buffer[1024] ;
  uschar *tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  uschar *s ;
  uschar *tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  int tmp___6 ;
  unsigned short const   **tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  void *tmp___10 ;

  {
  {
#line 617
  letter = 0;
#line 618
  check = 0;
#line 620
  macname = (uschar *)((void *)0);
#line 621
  porig = p;
#line 624
  tmp___1 = __ctype_b_loc();
  }
#line 624
  if ((int const   )*(*tmp___1 + (int )*p) & 256) {
#line 624
    if ((int )*(p + 1) == 0) {
#line 624
      goto _L;
    } else {
      {
#line 624
      tmp___2 = __ctype_b_loc();
      }
#line 624
      if ((int const   )*(*tmp___2 + (int )*(p + 1)) & 8192) {
        _L: /* CIL Label */ 
#line 626
        tmp = p;
#line 626
        p ++;
#line 626
        letter = (int )*tmp;
        {
#line 627
        while (1) {
          while_continue: /* CIL Label */ ;
          {
#line 627
          tmp___0 = __ctype_b_loc();
          }
#line 627
          if (! ((int const   )*(*tmp___0 + (int )*p) & 8192)) {
#line 627
            goto while_break;
          }
#line 627
          p ++;
        }
        while_break: /* CIL Label */ ;
        }
      }
    }
  }
#line 630
  if ((int )*p == 34) {
    {
#line 632
    tmp___3 = misc_readitem(p, (uschar *)((void *)0), & length, buffer, 1024);
#line 632
    s = tmp___3;
#line 633
    p += length;
    }
    {
#line 634
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 634
      tmp___4 = __ctype_b_loc();
      }
#line 634
      if (! ((int const   )*(*tmp___4 + (int )*p) & 8192)) {
#line 634
        goto while_break___0;
      }
#line 634
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 635
    tmp___6 = strncmp((char const   *)p, "check", (size_t )5);
    }
#line 635
    if (tmp___6 == 0) {
#line 635
      if ((int )*(p + 5) == 0) {
#line 635
        goto _L___0;
      } else {
        {
#line 635
        tmp___7 = __ctype_b_loc();
        }
#line 635
        if ((int const   )*(*tmp___7 + (int )*(p + 5)) & 8192) {
          _L___0: /* CIL Label */ 
#line 637
          p += 5;
          {
#line 638
          while (1) {
            while_continue___1: /* CIL Label */ ;
            {
#line 638
            tmp___5 = __ctype_b_loc();
            }
#line 638
            if (! ((int const   )*(*tmp___5 + (int )*p) & 8192)) {
#line 638
              goto while_break___1;
            }
#line 638
            p ++;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 639
          check = istackbase->linenumber;
#line 640
          if (from_type[from_type_ptr] == 1) {
#line 641
            macname = (macrocurrent->macro)->name;
          }
        }
      }
    }
#line 643
    if ((int )*p != 0) {
      {
#line 643
      tmp___8 = strlen((char const   *)p);
#line 643
      error(19, ".push", porig, (p - porig) + 6L, spaces, (int )tmp___8, circumflexes);
      }
    }
#line 645
    p = s;
  }
  {
#line 648
  tmp___9 = strlen((char const   *)p);
#line 648
  length = (int )tmp___9;
#line 649
  tmp___10 = misc_malloc((int )(sizeof(pushstr ) + (unsigned long )length));
#line 649
  ps = (pushstr *)tmp___10;
#line 650
  ps->letter = letter;
#line 651
  ps->check = check;
#line 652
  ps->macname = macname;
#line 653
  memcpy((void */* __restrict  */)(ps->string), (void const   */* __restrict  */)p,
         (size_t )length);
#line 654
  ps->string[length] = (uschar )0;
#line 655
  ps->next = pushed;
#line 656
  pushed = ps;
  }
#line 657
  return;
}
}
#line 673 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/dot.c"
static void do_revision(uschar *p ) 
{ 
  size_t tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 676
  if ((unsigned long )revision != (unsigned long )((void *)0)) {
    {
#line 678
    free((void *)revision);
#line 679
    revision = (uschar *)((void *)0);
    }
  }
#line 682
  if ((int )*p != 0) {
    {
#line 682
    tmp___1 = strcmp((char const   *)p, "off");
    }
#line 682
    if (tmp___1 != 0) {
      {
#line 684
      tmp = strlen((char const   *)p);
#line 684
      tmp___0 = misc_malloc((int )tmp + 1);
#line 684
      revision = (uschar *)tmp___0;
#line 685
      strcpy((char */* __restrict  */)((char *)revision), (char const   */* __restrict  */)((char const   *)p));
      }
    }
  }
#line 687
  return;
}
}
#line 702 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/dot.c"
static void do_set(uschar *p ) 
{ 
  int length ;
  tree_node *t ;
  uschar *porig ;
  uschar buffer[1024] ;
  uschar *name ;
  uschar *tmp ;
  unsigned short const   **tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  unsigned short const   **tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;

  {
  {
#line 707
  porig = p;
#line 709
  tmp = misc_readitem(p, (uschar *)((void *)0), & length, buffer, 1024);
#line 709
  name = tmp;
#line 711
  p += length;
  }
  {
#line 712
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 712
    tmp___0 = __ctype_b_loc();
    }
#line 712
    if (! ((int const   )*(*tmp___0 + (int )*p) & 8192)) {
#line 712
      goto while_break;
    }
#line 712
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 714
  tmp___1 = strlen((char const   *)name);
#line 714
  tmp___2 = misc_malloc((int )(sizeof(tree_node ) + (unsigned long )((int )tmp___1)));
#line 714
  t = (tree_node *)tmp___2;
#line 715
  strcpy((char */* __restrict  */)((char *)(t->name)), (char const   */* __restrict  */)((char const   *)name));
#line 717
  t->data = misc_readitem(p, (uschar *)((void *)0), & length, (uschar *)((void *)0),
                          0);
#line 719
  p += length;
  }
  {
#line 720
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 720
    tmp___3 = __ctype_b_loc();
    }
#line 720
    if (! ((int const   )*(*tmp___3 + (int )*p) & 8192)) {
#line 720
      goto while_break___0;
    }
#line 720
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 721
  if ((int )*p != 0) {
    {
#line 721
    tmp___4 = strlen((char const   *)p);
#line 721
    error(19, ".set", porig, (p - porig) + 5L, spaces, (int )tmp___4, circumflexes);
    }
  }
  {
#line 724
  tmp___5 = tree_insertnode(& entities, t);
  }
#line 724
  if (! tmp___5) {
    {
#line 724
    error(21, name);
    }
  }
#line 725
  return;
}
}
#line 747 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/dot.c"
static dirstr dirs[17]  = 
#line 747
  {      {(unsigned char *)".arg", 4, & do_arg, 1, 1}, 
        {(unsigned char *)".eacharg", 8, & do_eacharg, 1, 1}, 
        {(unsigned char *)".echo", 5, & do_echo, 1, 0}, 
        {(unsigned char *)".endarg", 7, & do_endarg, 0, 1}, 
        {(unsigned char *)".endeach", 8, & do_endeach, 1, 1}, 
        {(unsigned char *)".endinliteral", 13, & do_endinliteral, 0, 1}, 
        {(unsigned char *)".flag", 5, & do_flag, 0, 0}, 
        {(unsigned char *)".include", 8, & do_include, 1, 0}, 
        {(unsigned char *)".inliteral", 10, & do_inliteral, 1, 1}, 
        {(unsigned char *)".literal", 8, & do_literal, 1, 0}, 
        {(unsigned char *)".macro", 6, & do_macro, 0, 0}, 
        {(unsigned char *)".nest", 5, & do_nest, 1, 0}, 
        {(unsigned char *)".nonl", 5, & do_nonl, 1, 0}, 
        {(unsigned char *)".pop", 4, & do_pop, 1, 0}, 
        {(unsigned char *)".push", 5, & do_push, 0, 0}, 
        {(unsigned char *)".revision", 9, & do_revision, 1, 0}, 
        {(unsigned char *)".set", 4, & do_set, 0, 0}};
#line 767 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/dot.c"
static int cmdcount  =    (int )(sizeof(dirs) / sizeof(dirstr ));
#line 782 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/dot.c"
void dot_process(uschar *p ) 
{ 
  macrodef *md ;
  macroexe *me ;
  argstr **pp ;
  int top ;
  int bot ;
  int length ;
  unsigned short const   **tmp ;
  int c ;
  int mid ;
  dirstr *dir ;
  uschar buffer[1024] ;
  unsigned short const   **tmp___0 ;
  int alength ;
  uschar *s ;
  uschar *tmp___1 ;
  size_t tmp___2 ;
  unsigned short const   **tmp___3 ;
  int tmp___4 ;
  unsigned short const   **tmp___5 ;
  void *tmp___6 ;
  unsigned short const   **tmp___7 ;
  argstr *as ;
  void *tmp___8 ;

  {
  {
#line 790
  thisdir = p;
#line 792
  misc_detrail(p);
  }
#line 794
  if ((int )*(p + 1) == 0) {
#line 794
    return;
  } else {
    {
#line 794
    tmp = __ctype_b_loc();
    }
#line 794
    if ((int const   )*(*tmp + (int )*(p + 1)) & 8192) {
#line 794
      return;
    }
  }
#line 798
  bot = 0;
#line 799
  top = cmdcount;
  {
#line 801
  while (1) {
    while_continue: /* CIL Label */ ;
#line 801
    if (! (top > bot)) {
#line 801
      goto while_break;
    }
    {
#line 804
    mid = (top + bot) / 2;
#line 805
    dir = dirs + mid;
#line 807
    length = dir->length;
#line 808
    c = strncmp((char const   *)p, (char const   *)dir->name, (size_t )length);
    }
#line 814
    if (c == 0) {
#line 814
      if ((int )*(p + length) == 0) {
#line 814
        goto _L;
      } else {
        {
#line 814
        tmp___3 = __ctype_b_loc();
        }
#line 814
        if ((int const   )*(*tmp___3 + (int )*(p + length)) & 8192) {
          _L: /* CIL Label */ 
#line 817
          p += length;
          {
#line 818
          while (1) {
            while_continue___0: /* CIL Label */ ;
            {
#line 818
            tmp___0 = __ctype_b_loc();
            }
#line 818
            if (! ((int const   )*(*tmp___0 + (int )*p) & 8192)) {
#line 818
              goto while_break___0;
            }
#line 818
            p ++;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 820
          if (dir->onearg) {
            {
#line 823
            tmp___1 = misc_readitem(p, (uschar *)((void *)0), & alength, buffer, 1024);
#line 823
            s = tmp___1;
            }
#line 824
            if ((int )*(p + alength) != 0) {
              {
#line 825
              tmp___2 = strlen((char const   *)p);
#line 825
              error(19, dir->name, p, (alength + length) + 1, spaces, (int )tmp___2 - alength,
                    circumflexes);
              }
            }
#line 827
            p = s;
          }
#line 832
          if (para_inline_macro == 0) {
            {
#line 832
            (*(dir->function))(p);
            }
          } else
#line 832
          if (dir->okinline) {
            {
#line 832
            (*(dir->function))(p);
            }
          } else {
            {
#line 833
            error(22, dir->name);
            }
          }
#line 835
          return;
        }
      }
    }
#line 840
    if (c < 0) {
#line 840
      top = mid;
    } else {
#line 840
      bot = mid + 1;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 846
  if (para_inline_macro > 0) {
    {
#line 848
    error(22, p);
    }
#line 849
    return;
  }
#line 852
  md = macrolist;
  {
#line 852
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 852
    if (! ((unsigned long )md != (unsigned long )((void *)0))) {
#line 852
      goto while_break___1;
    }
    {
#line 854
    length = md->namelength;
#line 855
    tmp___4 = strncmp((char const   *)(p + 1), (char const   *)md->name, (size_t )length);
    }
#line 855
    if (tmp___4 == 0) {
#line 855
      if ((int )*(p + (length + 1)) == 0) {
#line 858
        p += length + 1;
#line 859
        goto while_break___1;
      } else {
        {
#line 855
        tmp___5 = __ctype_b_loc();
        }
#line 855
        if ((int const   )*(*tmp___5 + (int )*(p + (length + 1))) & 8192) {
#line 858
          p += length + 1;
#line 859
          goto while_break___1;
        }
      }
    }
#line 852
    md = md->next;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 866
  if ((unsigned long )md == (unsigned long )((void *)0)) {
    {
#line 871
    if (literal_state == 3) {
#line 871
      goto case_3;
    }
#line 871
    if (literal_state == 2) {
#line 871
      goto case_3;
    }
#line 875
    goto switch_default;
    case_3: /* CIL Label */ 
    case_2: /* CIL Label */ 
    {
#line 872
    fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"%s\n",
            (char *)p);
    }
#line 873
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 876
    error(2, p);
    }
#line 877
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 879
    return;
  }
  {
#line 884
  tmp___6 = misc_malloc((int )sizeof(macroexe ));
#line 884
  me = (macroexe *)tmp___6;
#line 885
  me->prev = macrocurrent;
#line 886
  macrocurrent = me;
#line 887
  me->macro = md;
#line 888
  me->nextline = md->lines;
#line 889
  from_type_ptr ++;
#line 889
  from_type[from_type_ptr] = 1;
#line 891
  me->args = (argstr *)((void *)0);
#line 892
  pp = & me->args;
  }
  {
#line 894
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 894
    tmp___7 = __ctype_b_loc();
    }
#line 894
    if (! ((int const   )*(*tmp___7 + (int )*p) & 8192)) {
#line 894
      goto while_break___2;
    }
#line 894
    p ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 895
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 895
    if (! ((int )*p != 0)) {
#line 895
      goto while_break___3;
    }
    {
#line 897
    tmp___8 = misc_malloc((int )sizeof(argstr ));
#line 897
    as = (argstr *)tmp___8;
#line 898
    as->next = (struct argstr *)((void *)0);
#line 899
    *pp = as;
#line 900
    pp = & as->next;
#line 901
    as->string = misc_readitem(p, (uschar *)((void *)0), & length, (uschar *)((void *)0),
                               0);
#line 902
    p += length;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 904
  return;
}
}
#line 573 "/usr/include/stdio.h"
extern int fputc(int __c , FILE *__stream ) ;
#line 23 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/functions.h"
void read_process_macroline(uschar *p , uschar *b ) ;
#line 26
tree_node *tree_search(tree_node *p , uschar *name ) ;
#line 28 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/para.c"
static uschar *para_macro_process(uschar *p , uschar *q ) 
{ 
  int length ;
  argstr **pp ;
  macrodef *md ;
  macroexe *me ;
  int tmp ;
  void *tmp___0 ;
  unsigned short const   **tmp___1 ;
  argstr *as ;
  void *tmp___2 ;
  unsigned short const   **tmp___3 ;
  uschar buffer[1024] ;
  uschar *qq ;
  size_t tmp___4 ;
  unsigned short const   **tmp___5 ;
  macroexe *temp ;

  {
#line 31
  length = (int )(q - p);
#line 36
  md = macrolist;
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
#line 36
    if (! ((unsigned long )md != (unsigned long )((void *)0))) {
#line 36
      goto while_break;
    }
#line 38
    if (length == md->namelength) {
      {
#line 38
      tmp = strncmp((char const   *)p, (char const   *)md->name, (size_t )length);
      }
#line 38
      if (tmp == 0) {
#line 38
        goto while_break;
      }
    }
#line 36
    md = md->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 41
  if ((unsigned long )md == (unsigned long )((void *)0)) {
    {
#line 43
    error(23, length, p);
#line 44
    fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"&");
    }
#line 45
    return (p);
  }
  {
#line 51
  tmp___0 = misc_malloc((int )sizeof(macroexe ));
#line 51
  me = (macroexe *)tmp___0;
#line 52
  me->prev = macrocurrent;
#line 53
  macrocurrent = me;
#line 54
  me->macro = md;
#line 55
  me->nextline = md->lines;
#line 56
  from_type_ptr ++;
#line 56
  from_type[from_type_ptr] = 1;
#line 58
  me->args = (argstr *)((void *)0);
#line 59
  pp = & me->args;
  }
  {
#line 61
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 61
    tmp___1 = __ctype_b_loc();
#line 61
    q ++;
    }
#line 61
    if (! ((int const   )*(*tmp___1 + (int )*q) & 8192)) {
#line 61
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 62
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 62
    if ((int )*q != 0) {
#line 62
      if (! ((int )*q != 41)) {
#line 62
        goto while_break___1;
      }
    } else {
#line 62
      goto while_break___1;
    }
    {
#line 64
    tmp___2 = misc_malloc((int )sizeof(argstr ));
#line 64
    as = (argstr *)tmp___2;
#line 65
    as->next = (struct argstr *)((void *)0);
#line 66
    *pp = as;
#line 67
    pp = & as->next;
#line 68
    as->string = misc_readitem(q, (unsigned char *)",)", & length, (uschar *)((void *)0),
                               0);
#line 69
    q += length;
    }
#line 70
    if ((int )*q == 44) {
      {
#line 70
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 70
        tmp___3 = __ctype_b_loc();
#line 70
        q ++;
        }
#line 70
        if (! ((int const   )*(*tmp___3 + (int )*q) & 8192)) {
#line 70
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 73
  if ((int )*q != 41) {
    {
#line 75
    error(24, p);
#line 76
    fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"&");
    }
#line 77
    return (p);
  }
#line 85
  para_inline_macro ++;
  {
#line 87
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 91
    read_process_macroline((macrocurrent->nextline)->string, buffer);
    }
#line 97
    if ((int )buffer[0] == 46) {
      {
#line 99
      dot_process(buffer);
      }
#line 100
      if ((unsigned long )macrocurrent != (unsigned long )me) {
#line 100
        goto while_break___3;
      }
    } else {
      {
#line 107
      tmp___4 = strlen((char const   *)(buffer));
#line 107
      qq = buffer + (int )tmp___4;
      }
      {
#line 108
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 108
        if ((unsigned long )qq > (unsigned long )(buffer)) {
          {
#line 108
          tmp___5 = __ctype_b_loc();
          }
#line 108
          if (! ((int const   )*(*tmp___5 + (int )*(qq + -1)) & 8192)) {
#line 108
            goto while_break___4;
          }
        } else {
#line 108
          goto while_break___4;
        }
#line 108
        qq --;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 109
      *qq = (uschar )0;
#line 110
      para_process(buffer);
      }
    }
#line 116
    macrocurrent->nextline = (macrocurrent->nextline)->next;
#line 117
    if ((unsigned long )macrocurrent->nextline == (unsigned long )((void *)0)) {
      {
#line 119
      temp = macrocurrent;
#line 120
      macrocurrent = macrocurrent->prev;
#line 121
      free((void *)temp);
#line 122
      from_type_ptr --;
      }
#line 123
      goto while_break___3;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 130
  para_inline_macro --;
#line 131
  return (q + 1);
}
}
#line 152 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/para.c"
static void check_literal(uschar *s , BOOL *b ) 
{ 
  char *tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;
  int tmp___2 ;
  unsigned short const   **tmp___3 ;
  int t ;
  uschar *tmp___4 ;
  uschar *tmp___5 ;

  {
  {
#line 155
  while (1) {
    while_continue: /* CIL Label */ ;
#line 155
    if (! ((int )*s != 0)) {
#line 155
      goto while_break;
    }
    {
#line 157
    tmp = strchr((char const   *)s, '<');
#line 157
    s = (unsigned char *)tmp;
    }
#line 158
    if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 158
      return;
    }
    {
#line 160
    tmp___2 = strncmp((char const   *)s, "<literal", (size_t )8);
    }
#line 160
    if (tmp___2 == 0) {
#line 160
      if ((int )*(s + 8) == 62) {
#line 161
        *b = 1;
      } else {
        {
#line 160
        tmp___3 = __ctype_b_loc();
        }
#line 160
        if ((int const   )*(*tmp___3 + (int )*(s + 8)) & 8192) {
#line 161
          *b = 1;
        } else {
#line 160
          goto _L;
        }
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 162
      tmp___0 = strncmp((char const   *)s, "</literal", (size_t )9);
      }
#line 162
      if (tmp___0 == 0) {
#line 162
        if ((int )*(s + 9) == 62) {
#line 163
          *b = 0;
        } else {
          {
#line 162
          tmp___1 = __ctype_b_loc();
          }
#line 162
          if ((int const   )*(*tmp___1 + (int )*(s + 9)) & 8192) {
#line 163
            *b = 0;
          }
        }
      }
    }
    {
#line 165
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 165
      if ((int )*s != 0) {
#line 165
        if (! ((int )*s != 62)) {
#line 165
          goto while_break___0;
        }
      } else {
#line 165
        goto while_break___0;
      }
#line 167
      if ((int )*s == 34) {
#line 167
        goto _L___0;
      } else
#line 167
      if ((int )*s == 39) {
        _L___0: /* CIL Label */ 
#line 169
        tmp___4 = s;
#line 169
        s ++;
#line 169
        t = (int )*tmp___4;
        {
#line 170
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 170
          if ((int )*s != 0) {
#line 170
            if (! ((int )*s != t)) {
#line 170
              goto while_break___1;
            }
          } else {
#line 170
            goto while_break___1;
          }
#line 170
          s ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 171
        if ((int )*s == 0) {
#line 171
          return;
        }
      }
#line 173
      s ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 176
    tmp___5 = s;
#line 176
    s ++;
#line 176
    if ((int )*tmp___5 == 0) {
#line 176
      return;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 178
  return;
}
}
#line 194 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/para.c"
void para_process(uschar *p ) 
{ 
  flagstr *f ;
  flagstr *fstack[40] ;
  int fstackcount ;
  BOOL inliteraltext ;
  int c ;
  int i ;
  int j ;
  int tmp ;
  uschar *tmp___0 ;
  int entlen ;
  uschar *q ;
  unsigned short const   **tmp___1 ;
  tree_node *t ;
  int tmp___2 ;
  unsigned short const   **tmp___3 ;
  uschar *q___0 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  unsigned short const   **tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 199
  fstackcount = 0;
#line 200
  inliteraltext = 0;
  {
#line 202
  while (1) {
    while_continue: /* CIL Label */ ;
#line 202
    if (! ((int )*p != 0)) {
#line 202
      goto while_break;
    }
#line 209
    i = fstackcount - 1;
    {
#line 209
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 209
      if (! (i >= 0)) {
#line 209
        goto while_break___0;
      }
      {
#line 211
      f = fstack[i];
#line 212
      tmp = strncmp((char const   *)f->flag2, (char const   *)p, (size_t )f->length2);
      }
#line 212
      if (tmp == 0) {
#line 215
        j = i + 1;
        {
#line 215
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 215
          if (! (j < fstackcount)) {
#line 215
            goto while_break___1;
          }
          {
#line 216
          error(8, (fstack[j])->flag2, f->flag2);
#line 215
          j ++;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 217
        fstackcount = i;
#line 218
        fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"%s",
                (char *)f->rep2);
#line 219
        check_literal(f->rep2, & inliteraltext);
#line 220
        p += f->length2;
#line 221
        i = fstackcount;
        }
#line 222
        goto __Cont;
      }
      __Cont: /* CIL Label */ 
#line 209
      i --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 229
    if ((int )*p == 0) {
#line 229
      goto while_break;
    }
#line 235
    tmp___0 = p;
#line 235
    p ++;
#line 235
    c = (int )*tmp___0;
#line 236
    if (c == 60) {
      {
#line 236
      fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"&lt;");
      }
#line 236
      goto while_continue;
    }
#line 237
    if (c == 62) {
      {
#line 237
      fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"&gt;");
      }
#line 237
      goto while_continue;
    }
#line 239
    if (! inliteraltext) {
#line 241
      if (c == 96) {
        {
#line 243
        fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"&#x2018;");
        }
#line 244
        goto while_continue;
      }
#line 247
      if (c == 39) {
        {
#line 249
        fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"&#x2019;");
        }
#line 250
        goto while_continue;
      }
    }
#line 254
    if (c != 38) {
      {
#line 254
      fputc(c, outfile);
      }
#line 254
      goto while_continue;
    }
#line 258
    if ((int )*p == 0) {
      {
#line 260
      error(25);
      }
#line 261
      goto while_continue;
    } else
#line 258
    if ((int )*p == 10) {
      {
#line 260
      error(25);
      }
#line 261
      goto while_continue;
    }
    {
#line 267
    tmp___3 = __ctype_b_loc();
    }
#line 267
    if ((int const   )*(*tmp___3 + (int )*p) & 1024) {
#line 270
      q = p + 1;
      {
#line 271
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 271
        tmp___1 = __ctype_b_loc();
        }
#line 271
        if (! ((int const   )*(*tmp___1 + (int )*q) & 8)) {
#line 271
          if (! ((int )*q == 46)) {
#line 271
            goto while_break___2;
          }
        }
#line 271
        q ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 276
      if ((int )*q == 40) {
        {
#line 278
        p = para_macro_process(p, q);
        }
#line 279
        goto while_continue;
      }
#line 288
      entlen = (int )(q - p);
#line 290
      if ((int )*q != 59) {
        {
#line 292
        error(3, entlen, p);
#line 293
        fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"&");
        }
#line 294
        goto while_continue;
      }
      {
#line 299
      tmp___2 = strncmp((char const   *)p, "xfpt.rev", (size_t )entlen);
      }
#line 299
      if (tmp___2 == 0) {
#line 301
        if ((unsigned long )revision != (unsigned long )((void *)0)) {
#line 301
          if ((int )*revision != 0) {
            {
#line 302
            fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)" revisionflag=\"%s\"",
                    revision);
            }
          }
        }
      } else {
        {
#line 310
        *q = (uschar )0;
#line 311
        t = tree_search(entities, p);
#line 312
        *q = (uschar )';';
        }
#line 313
        if ((unsigned long )t != (unsigned long )((void *)0)) {
          {
#line 314
          fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"%s",
                  (char *)t->data);
          }
        } else {
          {
#line 316
          fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"&%.*s;",
                  entlen, p);
          }
        }
      }
#line 319
      if ((int )*q == 59) {
#line 319
        q ++;
      }
#line 320
      p = q;
#line 321
      goto while_continue;
    }
#line 327
    if ((int )*p == 35) {
      {
#line 329
      q___0 = p + 1;
#line 330
      tmp___6 = __ctype_b_loc();
      }
#line 330
      if ((int const   )*(*tmp___6 + (int )*q___0) & 2048) {
#line 332
        q___0 ++;
        {
#line 332
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 332
          tmp___4 = __ctype_b_loc();
          }
#line 332
          if (! ((int const   )*(*tmp___4 + (int )*q___0) & 2048)) {
#line 332
            goto while_break___3;
          }
#line 332
          q___0 ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 333
        if ((int )*q___0 == 59) {
          {
#line 335
          fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"&%.*s",
                  q___0 - p, p);
#line 336
          p = q___0;
          }
#line 337
          goto while_continue;
        }
      } else
#line 341
      if ((int )*q___0 == 120) {
#line 343
        q___0 ++;
        {
#line 343
        while (1) {
          while_continue___4: /* CIL Label */ ;
          {
#line 343
          tmp___5 = __ctype_b_loc();
          }
#line 343
          if (! ((int const   )*(*tmp___5 + (int )*q___0) & 4096)) {
#line 343
            goto while_break___4;
          }
#line 343
          q___0 ++;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 344
        if ((int )*q___0 == 59) {
          {
#line 346
          fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"&%.*s",
                  q___0 - p, p);
#line 347
          p = q___0;
          }
#line 348
          goto while_continue;
        }
      }
    }
#line 355
    f = flaglist;
    {
#line 355
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 355
      if (! ((unsigned long )f != (unsigned long )((void *)0))) {
#line 355
        goto while_break___5;
      }
      {
#line 356
      tmp___7 = strncmp((char const   *)p, (char const   *)f->flag1, (size_t )f->length1);
      }
#line 356
      if (tmp___7 == 0) {
#line 356
        goto while_break___5;
      }
#line 355
      f = f->next;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 358
    if ((unsigned long )f == (unsigned long )((void *)0)) {
      {
#line 360
      error(6, (int )*p);
#line 361
      fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"&amp;");
      }
#line 362
      goto while_continue;
    }
#line 368
    if (f->length2 != 0) {
#line 368
      tmp___8 = fstackcount;
#line 368
      fstackcount ++;
#line 368
      fstack[tmp___8] = f;
    }
    {
#line 369
    fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"%s",
            (char *)f->rep1);
#line 370
    check_literal(f->rep1, & inliteraltext);
#line 371
    p += f->length1;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 377
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 377
    if (! (fstackcount > 0)) {
#line 377
      goto while_break___6;
    }
    {
#line 379
    fstackcount --;
#line 379
    f = fstack[fstackcount];
#line 380
    error(7, f->flag2);
    }
  }
  while_break___6: /* CIL Label */ ;
  }
#line 382
  return;
}
}
#line 25 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/literal.c"
void literal_process(uschar *p ) 
{ 
  int c ;
  uschar *tmp ;

  {
  {
#line 28
  while (1) {
    while_continue: /* CIL Label */ ;
#line 28
    if (! ((int )*p != 0)) {
#line 28
      goto while_break;
    }
#line 30
    tmp = p;
#line 30
    p ++;
#line 30
    c = (int )*tmp;
#line 31
    if (c == 38) {
      {
#line 31
      fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"&amp;");
      }
    } else
#line 32
    if (c == 60) {
      {
#line 32
      fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"&lt;");
      }
    } else
#line 33
    if (c == 62) {
      {
#line 33
      fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"&gt;");
      }
    } else {
      {
#line 34
      fputc(c, outfile);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 36
  return;
}
}
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 25 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/misc.c"
void misc_detrail(uschar *p ) 
{ 
  uschar *q ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;

  {
  {
#line 28
  tmp = strlen((char const   *)p);
#line 28
  q = p + (int )tmp;
  }
  {
#line 29
  while (1) {
    while_continue: /* CIL Label */ ;
#line 29
    if ((unsigned long )q > (unsigned long )p) {
      {
#line 29
      tmp___0 = __ctype_b_loc();
      }
#line 29
      if (! ((int const   )*(*tmp___0 + (int )*(q + -1)) & 8192)) {
#line 29
        goto while_break;
      }
    } else {
#line 29
      goto while_break;
    }
#line 29
    q --;
  }
  while_break: /* CIL Label */ ;
  }
#line 30
  *q = (uschar )0;
#line 31
  return;
}
}
#line 44 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/misc.c"
void *misc_malloc(int size ) 
{ 
  void *yield ;
  void *tmp ;

  {
  {
#line 47
  tmp = malloc((size_t )size);
#line 47
  yield = tmp;
  }
#line 48
  if ((unsigned long )yield == (unsigned long )((void *)0)) {
    {
#line 48
    error(1, size);
    }
  }
#line 49
  return (yield);
}
}
#line 65 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/misc.c"
uschar *misc_copystring(uschar *p , int length ) 
{ 
  uschar *yield ;
  void *tmp ;

  {
  {
#line 68
  tmp = misc_malloc(length + 1);
#line 68
  yield = (uschar *)tmp;
#line 69
  memcpy((void */* __restrict  */)yield, (void const   */* __restrict  */)p, (size_t )length);
#line 70
  *(yield + length) = (uschar )0;
  }
#line 71
  return (yield);
}
}
#line 95 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/misc.c"
uschar *misc_readstring(uschar *p , int *lptr , uschar *buffer , int blength ) 
{ 
  int term ;
  int length ;
  uschar *pp ;
  uschar *yield ;
  void *tmp ;
  uschar *tmp___0 ;

  {
#line 98
  term = (int )*p;
#line 102
  pp = p + 1;
  {
#line 102
  while (1) {
    while_continue: /* CIL Label */ ;
#line 104
    if ((int )*pp == 0) {
#line 104
      goto while_break;
    }
#line 105
    if ((int )*pp == term) {
#line 105
      if ((int )*(pp + 1) != term) {
#line 105
        goto while_break;
      }
#line 105
      pp ++;
    }
#line 102
    pp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 108
  length = (int )(pp - p);
#line 109
  if ((unsigned long )lptr != (unsigned long )((void *)0)) {
#line 109
    *lptr = length + 1;
  }
#line 111
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
    {
#line 113
    tmp = misc_malloc(length + 1);
#line 113
    pp = (uschar *)tmp;
#line 113
    yield = pp;
    }
  } else {
#line 117
    if (length + 1 > blength) {
      {
#line 117
      error(20, length + 1, blength);
      }
    }
#line 118
    pp = buffer;
#line 118
    yield = pp;
  }
#line 121
  p ++;
  {
#line 121
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 123
    if ((int )*p == 0) {
#line 123
      goto while_break___0;
    }
#line 124
    if ((int )*p == term) {
#line 124
      if ((int )*(p + 1) != term) {
#line 124
        goto while_break___0;
      }
#line 124
      p ++;
    }
#line 125
    tmp___0 = pp;
#line 125
    pp ++;
#line 125
    *tmp___0 = *p;
#line 121
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 128
  *pp = (uschar )0;
#line 130
  return (yield);
}
}
#line 153 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/misc.c"
uschar *misc_readitem(uschar *p , uschar *term , int *lptr , uschar *buffer , int blength ) 
{ 
  uschar *yield ;
  int length ;
  uschar *pp ;
  unsigned short const   **tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
#line 159
  if ((int )*p == 34) {
    {
#line 161
    yield = misc_readstring(p, & length, buffer, blength);
#line 162
    p += length;
    }
  } else
#line 159
  if ((int )*p == 39) {
    {
#line 161
    yield = misc_readstring(p, & length, buffer, blength);
#line 162
    p += length;
    }
  } else {
#line 167
    pp = p;
#line 168
    if ((unsigned long )term == (unsigned long )((void *)0)) {
      {
#line 169
      while (1) {
        while_continue: /* CIL Label */ ;
#line 169
        if ((int )*p != 0) {
          {
#line 169
          tmp = __ctype_b_loc();
          }
#line 169
          if ((int const   )*(*tmp + (int )*p) & 8192) {
#line 169
            goto while_break;
          }
        } else {
#line 169
          goto while_break;
        }
#line 169
        p ++;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
      {
#line 171
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 171
        tmp___0 = strchr((char const   *)term, (int )*p);
        }
#line 171
        if (! ((unsigned long )((unsigned char *)tmp___0) == (unsigned long )((void *)0))) {
#line 171
          goto while_break___0;
        }
#line 171
        p ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 173
    length = (int )(p - pp);
#line 174
    if ((unsigned long )buffer == (unsigned long )((void *)0)) {
      {
#line 176
      tmp___1 = misc_malloc(length + 1);
#line 176
      yield = (uschar *)tmp___1;
      }
    } else {
#line 180
      if (length + 1 > blength) {
        {
#line 180
        error(20, length + 1, blength);
        }
      }
#line 181
      yield = buffer;
    }
    {
#line 183
    memcpy((void */* __restrict  */)yield, (void const   */* __restrict  */)pp, (size_t )length);
#line 184
    *(yield + length) = (uschar )0;
    }
  }
  {
#line 187
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 187
    tmp___2 = __ctype_b_loc();
    }
#line 187
    if (! ((int const   )*(*tmp___2 + (int )*p) & 8192)) {
#line 187
      goto while_break___1;
    }
#line 189
    p ++;
#line 190
    length ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 193
  if ((unsigned long )lptr != (unsigned long )((void *)0)) {
#line 193
    *lptr = length;
  }
#line 194
  return (yield);
}
}
#line 622 "/usr/include/stdio.h"
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 50 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 31 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/read.c"
void read_process_macroline(uschar *p , uschar *b ) 
{ 
  int optend ;
  int i ;
  int argn ;
  argstr *argbase ;
  argstr *arg ;
  uschar *tmp ;
  uschar *tmp___0 ;
  uschar *tmp___1 ;
  uschar *tmp___2 ;
  uschar *tmp___3 ;
  uschar *tmp___4 ;
  uschar *tmp___5 ;
  uschar *tmp___6 ;
  uschar *tmp___7 ;
  uschar *tmp___8 ;
  unsigned short const   **tmp___9 ;
  unsigned short const   **tmp___10 ;
  uschar *tmp___11 ;
  uschar *tmp___12 ;
  uschar *tmp___13 ;
  unsigned short const   **tmp___14 ;
  unsigned short const   **tmp___15 ;
  int tmp___16 ;

  {
#line 34
  optend = 0;
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
#line 36
    if (! ((int )*p != 0)) {
#line 36
      goto while_break;
    }
#line 39
    argn = 0;
#line 45
    if ((int )*p == optend) {
#line 47
      optend = 0;
#line 48
      p ++;
#line 49
      goto while_continue;
    }
#line 54
    if ((int )*p != 36) {
#line 54
      tmp = b;
#line 54
      b ++;
#line 54
      tmp___0 = p;
#line 54
      p ++;
#line 54
      *tmp = *tmp___0;
#line 54
      goto while_continue;
    }
#line 58
    if ((int )*(p + 1) == 36) {
#line 58
      p ++;
#line 58
      tmp___1 = b;
#line 58
      b ++;
#line 58
      tmp___2 = p;
#line 58
      p ++;
#line 58
      *tmp___1 = *tmp___2;
#line 58
      goto while_continue;
    }
#line 64
    if ((int )*(p + 1) == 43) {
#line 66
      p ++;
#line 67
      if ((unsigned long )macro_argbase == (unsigned long )((void *)0)) {
        {
#line 69
        error(18);
#line 70
        tmp___3 = b;
#line 70
        b ++;
#line 70
        *tmp___3 = (uschar )'+';
#line 71
        tmp___4 = b;
#line 71
        b ++;
#line 71
        tmp___5 = p;
#line 71
        p ++;
#line 71
        *tmp___4 = *tmp___5;
        }
#line 72
        goto while_continue;
      }
#line 74
      argbase = macro_argbase;
    } else {
#line 76
      argbase = macrocurrent->args;
    }
#line 80
    if ((int )*(p + 1) == 61) {
      {
#line 82
      p ++;
#line 83
      tmp___9 = __ctype_b_loc();
      }
#line 83
      if (! ((int const   )*(*tmp___9 + (int )*(p + 1)) & 2048)) {
        {
#line 85
        error(17, (int )*(p + 1), "$=");
#line 86
        tmp___6 = b;
#line 86
        b ++;
#line 86
        *tmp___6 = (uschar )'$';
#line 87
        tmp___7 = b;
#line 87
        b ++;
#line 87
        tmp___8 = p;
#line 87
        p ++;
#line 87
        *tmp___7 = *tmp___8;
        }
#line 88
        goto while_continue;
      }
      {
#line 90
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 90
        tmp___10 = __ctype_b_loc();
#line 90
        p ++;
        }
#line 90
        if (! ((int const   )*(*tmp___10 + (int )*p) & 2048)) {
#line 90
          goto while_break___0;
        }
#line 90
        argn = (argn * 10 + (int )*p) - 48;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 92
      tmp___11 = p;
#line 92
      p ++;
#line 92
      optend = (int )*tmp___11;
#line 94
      arg = argbase;
#line 95
      i = 1;
      {
#line 95
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 95
        if (! (i < argn)) {
#line 95
          goto while_break___1;
        }
#line 97
        if ((unsigned long )arg == (unsigned long )((void *)0)) {
#line 97
          goto while_break___1;
        }
#line 98
        arg = arg->next;
#line 95
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 101
      if ((unsigned long )arg == (unsigned long )((void *)0)) {
#line 101
        goto _L;
      } else
#line 101
      if ((int )*(arg->string + 0) == 0) {
        _L: /* CIL Label */ 
        {
#line 103
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 103
          if ((int )*p != 0) {
#line 103
            if (! ((int )*p != optend)) {
#line 103
              goto while_break___2;
            }
          } else {
#line 103
            goto while_break___2;
          }
#line 103
          p ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 104
        if ((int )*p == optend) {
#line 104
          p ++;
        }
      }
#line 107
      goto while_continue;
    }
    {
#line 112
    tmp___14 = __ctype_b_loc();
    }
#line 112
    if (! ((int const   )*(*tmp___14 + (int )*(p + 1)) & 2048)) {
      {
#line 114
      error(17, (int )*(p + 1), "$");
#line 115
      tmp___12 = b;
#line 115
      b ++;
#line 115
      tmp___13 = p;
#line 115
      p ++;
#line 115
      *tmp___12 = *tmp___13;
      }
#line 116
      goto while_continue;
    }
    {
#line 119
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 119
      tmp___15 = __ctype_b_loc();
#line 119
      p ++;
      }
#line 119
      if (! ((int const   )*(*tmp___15 + (int )*p) & 2048)) {
#line 119
        goto while_break___3;
      }
#line 119
      argn = (argn * 10 + (int )*p) - 48;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 123
    if (argn == 0) {
#line 125
      goto while_continue;
    }
#line 130
    arg = argbase;
#line 131
    i = 1;
    {
#line 131
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 131
      if (! (i < argn)) {
#line 131
        goto while_break___4;
      }
#line 133
      if ((unsigned long )arg == (unsigned long )((void *)0)) {
#line 133
        goto while_break___4;
      }
#line 134
      arg = arg->next;
#line 131
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 140
    if ((unsigned long )arg == (unsigned long )((void *)0)) {
#line 140
      if ((unsigned long )argbase == (unsigned long )macrocurrent->args) {
#line 142
        arg = (macrocurrent->macro)->args;
#line 143
        i = 1;
        {
#line 143
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 143
          if (! (i < argn)) {
#line 143
            goto while_break___5;
          }
#line 145
          if ((unsigned long )arg == (unsigned long )((void *)0)) {
#line 145
            goto while_break___5;
          }
#line 146
          arg = arg->next;
#line 143
          i ++;
        }
        while_break___5: /* CIL Label */ ;
        }
      }
    }
#line 152
    if ((unsigned long )arg != (unsigned long )((void *)0)) {
      {
#line 152
      tmp___16 = sprintf((char */* __restrict  */)((char *)b), (char const   */* __restrict  */)"%s",
                         arg->string);
#line 152
      b += tmp___16;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 155
  *b = (uschar )0;
#line 156
  return;
}
}
#line 181 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/read.c"
uschar *read_nextline(void) 
{ 
  int len ;
  uschar *p ;
  uschar *q ;
  uschar *yield ;
  pushstr *ps ;
  pushstr *ps___0 ;
  macroexe *temp ;
  istackstr *prev ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;

  {
#line 189
  if ((unsigned long )next_line != (unsigned long )((void *)0)) {
#line 191
    yield = next_line;
#line 192
    next_line = (uschar *)((void *)0);
#line 193
    return (yield);
  }
#line 198
  if (popto == 0) {
#line 200
    ps = pushed;
#line 201
    if ((unsigned long )ps == (unsigned long )((void *)0)) {
      {
#line 201
      error(12);
      }
    } else {
      {
#line 203
      popto = -1;
#line 204
      sprintf((char */* __restrict  */)((char *)inbuffer), (char const   */* __restrict  */)"%s\n",
              ps->string);
#line 205
      pushed = ps->next;
#line 206
      free((void *)ps);
      }
#line 207
      return (inbuffer);
    }
  }
#line 216
  if (popto > 0) {
#line 218
    ps___0 = pushed;
#line 219
    if (ps___0->letter == popto) {
#line 219
      popto = -1;
    }
    {
#line 220
    sprintf((char */* __restrict  */)((char *)inbuffer), (char const   */* __restrict  */)"%s\n",
            ps___0->string);
#line 221
    pushed = ps___0->next;
#line 222
    free((void *)ps___0);
    }
#line 223
    return (inbuffer);
  }
#line 230
  if (from_type_ptr < 0) {
#line 230
    return ((uschar *)((void *)0));
  }
  {
#line 232
  while (1) {
    while_continue: /* CIL Label */ ;
#line 234
    if (from_type[from_type_ptr] == 1) {
#line 236
      if ((unsigned long )macrocurrent->nextline == (unsigned long )((void *)0)) {
        {
#line 238
        temp = macrocurrent;
#line 239
        macrocurrent = macrocurrent->prev;
#line 240
        free((void *)temp);
        }
      } else {
        {
#line 244
        read_process_macroline((macrocurrent->nextline)->string, inbuffer);
#line 245
        macrocurrent->nextline = (macrocurrent->nextline)->next;
        }
#line 246
        goto while_break;
      }
    } else {
      {
#line 255
      tmp___4 = fgets((char */* __restrict  */)((char *)inbuffer), 1024, (FILE */* __restrict  */)istack->file);
      }
#line 255
      if ((unsigned long )((unsigned char *)tmp___4) == (unsigned long )((void *)0)) {
        {
#line 257
        prev = istack->prev;
#line 258
        fclose(istack->file);
#line 259
        free((void *)istack);
#line 260
        istack = prev;
        }
      } else {
        {
#line 264
        (istack->linenumber) ++;
#line 266
        q = inbuffer;
#line 267
        tmp = strlen((char const   *)q);
#line 267
        len = (int )tmp;
        }
        {
#line 269
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 271
          p = q + len;
          {
#line 272
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 272
            if ((unsigned long )p > (unsigned long )q) {
              {
#line 272
              tmp___0 = __ctype_b_loc();
              }
#line 272
              if (! ((int const   )*(*tmp___0 + (int )*(p + -1)) & 8192)) {
#line 272
                goto while_break___1;
              }
            } else {
#line 272
              goto while_break___1;
            }
#line 272
            p --;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 274
          if (p - q < 3L) {
#line 274
            goto while_break___0;
          } else {
            {
#line 274
            tmp___1 = strncmp((char const   *)(p - 3), "&&&", (size_t )3);
            }
#line 274
            if (tmp___1 != 0) {
#line 274
              goto while_break___0;
            }
          }
#line 276
          q = p - 3;
#line 277
          *q = (uschar )0;
#line 279
          if ((unsigned long )istack == (unsigned long )((void *)0)) {
#line 281
            goto while_break___0;
          } else {
            {
#line 279
            tmp___2 = fgets((char */* __restrict  */)((char *)q), (int )(1024L - (q - inbuffer)),
                            (FILE */* __restrict  */)istack->file);
            }
#line 279
            if ((unsigned long )((unsigned char *)tmp___2) == (unsigned long )((void *)0)) {
#line 281
              goto while_break___0;
            }
          }
#line 283
          (istack->linenumber) ++;
#line 284
          p = q;
          {
#line 285
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 285
            if (! ((int )*p == 32)) {
#line 285
              if (! ((int )*p == 9)) {
#line 285
                goto while_break___2;
              }
            }
#line 285
            p ++;
          }
          while_break___2: /* CIL Label */ ;
          }
          {
#line 286
          tmp___3 = strlen((char const   *)p);
#line 286
          len = (int )tmp___3;
          }
#line 287
          if ((unsigned long )p > (unsigned long )q) {
            {
#line 287
            memmove((void *)q, (void const   *)p, (size_t )(len + 1));
            }
          }
        }
        while_break___0: /* CIL Label */ ;
        }
#line 290
        goto while_break;
      }
    }
#line 299
    from_type_ptr --;
#line 299
    if (from_type_ptr < 0) {
#line 299
      return ((uschar *)((void *)0));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 302
  return (inbuffer);
}
}
#line 332 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/read.c"
uschar *read_paragraph(uschar *p , int *nest_info ) 
{ 
  uschar *q ;
  int length ;
  size_t tmp ;
  uschar *s ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;
  size_t tmp___2 ;
  unsigned short const   **tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;

  {
  {
#line 335
  q = parabuffer;
#line 336
  tmp = strlen((char const   *)p);
#line 336
  length = (int )tmp;
#line 338
  memcpy((void */* __restrict  */)q, (void const   */* __restrict  */)p, (size_t )length);
#line 339
  q += length;
#line 341
  *nest_info = 0;
  }
  {
#line 343
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 347
    p = read_nextline();
    }
#line 347
    if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 347
      goto while_break;
    }
    {
#line 349
    tmp___0 = strncmp((char const   *)p, ".literal ", (size_t )9);
    }
#line 349
    if (tmp___0 == 0) {
#line 351
      next_line = p;
#line 352
      goto while_break;
    }
    {
#line 355
    tmp___6 = strncmp((char const   *)p, ".nest ", (size_t )6);
    }
#line 355
    if (tmp___6 == 0) {
#line 357
      p += 6;
      {
#line 358
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 358
        tmp___1 = __ctype_b_loc();
        }
#line 358
        if (! ((int const   )*(*tmp___1 + (int )*p) & 8192)) {
#line 358
          goto while_break___0;
        }
#line 358
        p ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 359
      tmp___2 = strlen((char const   *)p);
#line 359
      s = p + (int )tmp___2;
      }
      {
#line 360
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 360
        if ((unsigned long )s > (unsigned long )p) {
          {
#line 360
          tmp___3 = __ctype_b_loc();
          }
#line 360
          if (! ((int const   )*(*tmp___3 + (int )*(s + -1)) & 8192)) {
#line 360
            goto while_break___1;
          }
        } else {
#line 360
          goto while_break___1;
        }
#line 360
        s --;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 361
      *s = (uschar )0;
#line 362
      tmp___5 = strcmp((char const   *)p, "begin");
      }
#line 362
      if (tmp___5 == 0) {
#line 362
        *nest_info = 1;
      } else {
        {
#line 363
        tmp___4 = strcmp((char const   *)p, "end");
        }
#line 363
        if (tmp___4 == 0) {
#line 363
          *nest_info = 2;
        } else {
          {
#line 364
          error(26, p);
          }
        }
      }
#line 365
      goto while_break;
    } else
#line 368
    if ((int )*p == 46) {
      {
#line 370
      dot_process(p);
      }
#line 371
      goto __Cont;
    }
#line 376
    s = p;
    {
#line 376
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 376
      if (! ((int )*s == 32)) {
#line 376
        if (! ((int )*s == 9)) {
#line 376
          goto while_break___2;
        }
      }
#line 376
      s ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 377
    if ((int )*s == 10) {
#line 377
      goto while_break;
    }
    {
#line 379
    tmp___7 = strlen((char const   *)p);
#line 379
    length = (int )tmp___7;
#line 380
    memcpy((void */* __restrict  */)q, (void const   */* __restrict  */)p, (size_t )length);
#line 381
    q += length;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 384
  *q = (uschar )0;
#line 385
  return (parabuffer);
}
}
#line 49 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/tree.c"
int tree_insertnode(tree_node **treebase , tree_node *node ) 
{ 
  tree_node *p ;
  tree_node **q ;
  tree_node *r ;
  tree_node *s ;
  tree_node **t ;
  int a ;
  struct tree_node *tmp ;
  int c ;
  int tmp___0 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___5 ;

  {
#line 52
  p = *treebase;
#line 56
  tmp = (struct tree_node *)((void *)0);
#line 56
  node->right = tmp;
#line 56
  node->left = tmp;
#line 57
  node->balance = (uschar )0;
#line 61
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 63
    *treebase = node;
#line 64
    return (1);
  }
#line 71
  q = treebase;
#line 72
  t = q;
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 78
    tmp___0 = strcmp((char const   *)(node->name), (char const   *)(p->name));
#line 78
    c = tmp___0;
    }
#line 79
    if (c == 0) {
#line 79
      return (0);
    }
#line 84
    if (c > 0) {
#line 84
      q = & p->right;
    } else {
#line 84
      q = & p->left;
    }
#line 85
    p = *q;
#line 86
    if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 86
      goto while_break;
    }
#line 91
    if ((int )p->balance != 0) {
#line 91
      t = q;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 97
  *q = node;
#line 102
  s = *t;
#line 103
  tmp___2 = strcmp((char const   *)(node->name), (char const   *)(s->name));
  }
#line 103
  if (tmp___2 > 0) {
#line 103
    r = s->right;
  } else {
#line 103
    r = s->left;
  }
#line 107
  p = r;
  {
#line 109
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 109
    if (! ((unsigned long )p != (unsigned long )node)) {
#line 109
      goto while_break___0;
    }
    {
#line 111
    tmp___3 = strcmp((char const   *)(node->name), (char const   *)(p->name));
    }
#line 111
    if (tmp___3 < 0) {
#line 113
      p->balance = (uschar )1;
#line 114
      p = p->left;
    } else {
#line 118
      p->balance = (uschar )2;
#line 119
      p = p->right;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 125
  tmp___5 = strcmp((char const   *)(node->name), (char const   *)(s->name));
  }
#line 125
  if (tmp___5 < 0) {
#line 125
    a = 1;
  } else {
#line 125
    a = 2;
  }
#line 127
  if ((int )s->balance == 0) {
#line 127
    s->balance = (uschar )a;
  } else
#line 128
  if ((int )s->balance != (int )((uschar )a)) {
#line 128
    s->balance = (uschar )0;
  } else {
#line 133
    if ((int )r->balance == (int )((uschar )a)) {
#line 135
      p = r;
#line 136
      if (a == 2) {
#line 138
        s->right = r->left;
#line 139
        r->left = s;
      } else {
#line 143
        s->left = r->right;
#line 144
        r->right = s;
      }
#line 146
      s->balance = (uschar )0;
#line 147
      r->balance = (uschar )0;
    } else {
#line 157
      if (a == 2) {
#line 159
        if ((unsigned long )r->left == (unsigned long )((void *)0)) {
#line 159
          return (1);
        }
#line 160
        p = r->left;
#line 161
        r->left = p->right;
#line 162
        p->right = r;
#line 163
        s->right = p->left;
#line 164
        p->left = s;
      } else {
#line 168
        if ((unsigned long )r->right == (unsigned long )((void *)0)) {
#line 168
          return (1);
        }
#line 169
        p = r->right;
#line 170
        r->right = p->left;
#line 171
        p->left = r;
#line 172
        s->left = p->right;
#line 173
        p->right = s;
      }
#line 176
      if ((int )p->balance == (int )((uschar )a)) {
#line 176
        s->balance = (uschar )(a ^ 3);
      } else {
#line 176
        s->balance = (uschar )0;
      }
#line 177
      if ((int )p->balance == (int )((uschar )(a ^ 3))) {
#line 177
        r->balance = (uschar )a;
      } else {
#line 177
        r->balance = (uschar )0;
      }
#line 178
      p->balance = (uschar )0;
    }
#line 183
    *t = p;
  }
#line 186
  return (1);
}
}
#line 203 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/tree.c"
tree_node *tree_search(tree_node *p , uschar *name ) 
{ 
  int c ;
  int tmp ;

  {
  {
#line 206
  while (1) {
    while_continue: /* CIL Label */ ;
#line 206
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 206
      goto while_break;
    }
    {
#line 208
    tmp = strcmp((char const   *)name, (char const   *)(p->name));
#line 208
    c = tmp;
    }
#line 209
    if (c == 0) {
#line 209
      return (p);
    }
#line 210
    if (c < 0) {
#line 210
      p = p->left;
    } else {
#line 210
      p = p->right;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 212
  return ((tree_node *)((void *)0));
}
}
#line 21 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/globals.h"
int from_type[20]  ;
#line 31 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/globals.h"
int nest_literal_stack[4]  ;
#line 13 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/globals.c"
uschar *xfpt_share  =    (unsigned char *)"/usr/local/share/xfpt";
#line 14 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/globals.c"
uschar *xfpt_version  =    (unsigned char *)"0.09 16-May-2012";
#line 16 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/globals.c"
tree_node *entities  =    (tree_node *)((void *)0);
#line 18 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/globals.c"
flagstr *flaglist  =    (flagstr *)((void *)0);
#line 20 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/globals.c"
int from_type_ptr  =    0;
#line 22 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/globals.c"
uschar *inbuffer  =    (uschar *)((void *)0);
#line 23 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/globals.c"
istackstr *istack  =    (istackstr *)((void *)0);
#line 24 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/globals.c"
istackstr *istackbase  =    (istackstr *)((void *)0);
#line 26 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/globals.c"
int literal_state  =    0;
#line 28 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/globals.c"
int nest_level  =    0;
#line 30 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/globals.c"
uschar *next_line  =    (uschar *)((void *)0);
#line 32 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/globals.c"
macroexe *macrocurrent  =    (macroexe *)((void *)0);
#line 33 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/globals.c"
macrodef *macrolist  =    (macrodef *)((void *)0);
#line 35 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/globals.c"
argstr *macro_argbase  =    (argstr *)((void *)0);
#line 36 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/globals.c"
argstr *macro_starteach  =    (argstr *)((void *)0);
#line 38 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/globals.c"
FILE *outfile  =    (FILE *)((void *)0);
#line 40 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/globals.c"
int para_inline_macro  =    0;
#line 41 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/globals.c"
uschar *parabuffer  =    (uschar *)((void *)0);
#line 42 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/globals.c"
int popto  =    -1;
#line 43 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/globals.c"
pushstr *pushed  =    (pushstr *)((void *)0);
#line 45 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/globals.c"
int return_code  =    0;
#line 46 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/globals.c"
uschar *revision  =    (uschar *)((void *)0);
#line 48 "/home/june/repo/benchmarks/collector2/temp/xfpt-0.09/src/globals.c"
BOOL suppress_warnings  =    0;
