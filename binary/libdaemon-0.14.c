/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 70 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __mode_t mode_t;
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_15 {
   __fd_mask fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_15 fd_set;
#line 35 "/usr/include/x86_64-linux-gnu/bits/fcntl.h"
struct flock {
   short l_type ;
   short l_whence ;
   __off_t l_start ;
   __off_t l_len ;
   __pid_t l_pid ;
};
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 205 "/home/june/repo/benchmarks/collector/temp/libdaemon-0.14/libdaemon/dexec.c"
union __anonunion_54 {
   int __in ;
   int __i ;
};
#line 211 "/home/june/repo/benchmarks/collector/temp/libdaemon-0.14/libdaemon/dexec.c"
union __anonunion_55 {
   int __in ;
   int __i ;
};
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 38 "/home/june/repo/benchmarks/collector/temp/libdaemon-0.14/libdaemon/dlog.h"
enum daemon_log_flags {
    DAEMON_LOG_SYSLOG = 1,
    DAEMON_LOG_STDERR = 2,
    DAEMON_LOG_STDOUT = 4,
    DAEMON_LOG_AUTO = 8
} ;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_2 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_2 __sigset_t;
#line 37 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __sigset_t sigset_t;
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef union sigval sigval_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef __clock_t __sigchld_clock_t;
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__kill_19 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__timer_20 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__rt_21 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigchld_22 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __sigchld_clock_t si_utime ;
   __sigchld_clock_t si_stime ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigfault_23 {
   void *si_addr ;
   short si_addr_lsb ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigpoll_24 {
   long si_band ;
   int si_fd ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigsys_25 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union __anonunion__sifields_18 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_19 _kill ;
   struct __anonstruct__timer_20 _timer ;
   struct __anonstruct__rt_21 _rt ;
   struct __anonstruct__sigchld_22 _sigchld ;
   struct __anonstruct__sigfault_23 _sigfault ;
   struct __anonstruct__sigpoll_24 _sigpoll ;
   struct __anonstruct__sigsys_25 _sigsys ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct_siginfo_t_17 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_18 _sifields ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef struct __anonstruct_siginfo_t_17 siginfo_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion___sigaction_handler_37 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_37 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 136 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __rlim_t;
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 31 "/usr/include/x86_64-linux-gnu/bits/resource.h"
enum __rlimit_resource {
    RLIMIT_CPU = 0,
    RLIMIT_FSIZE = 1,
    RLIMIT_DATA = 2,
    RLIMIT_STACK = 3,
    RLIMIT_CORE = 4,
    __RLIMIT_RSS = 5,
    RLIMIT_NOFILE = 7,
    __RLIMIT_OFILE = 7,
    RLIMIT_AS = 9,
    __RLIMIT_NPROC = 6,
    __RLIMIT_MEMLOCK = 8,
    __RLIMIT_LOCKS = 10,
    __RLIMIT_SIGPENDING = 11,
    __RLIMIT_MSGQUEUE = 12,
    __RLIMIT_NICE = 13,
    __RLIMIT_RTPRIO = 14,
    __RLIMIT_RTTIME = 15,
    __RLIMIT_NLIMITS = 16,
    __RLIM_NLIMITS = 16
} ;
#line 131 "/usr/include/x86_64-linux-gnu/bits/resource.h"
typedef __rlim_t rlim_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/resource.h"
struct rlimit {
   rlim_t rlim_cur ;
   rlim_t rlim_max ;
};
#line 38 "/usr/include/x86_64-linux-gnu/sys/resource.h"
typedef enum __rlimit_resource __rlimit_resource_t;
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 205 "/home/june/repo/benchmarks/collector/temp/libdaemon-0.14/libdaemon/dexec.c"
union __anonunion_54___0 {
   int __in ;
   int __i ;
};
#line 211 "/home/june/repo/benchmarks/collector/temp/libdaemon-0.14/libdaemon/dexec.c"
union __anonunion_55___0 {
   int __in ;
   int __i ;
};
#line 386 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 405
extern  __attribute__((__nothrow__)) int ( /* format attribute */  asprintf)(char ** __restrict  __ptr ,
                                                                             char const   * __restrict  __fmt 
                                                                             , ...) ;
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 483 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 127 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                           int __sig ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 285
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strcspn)(char const   *__s ,
                                                                                                   char const   *__reject )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 312 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) __mode_t ( __attribute__((__leaf__)) umask)(__mode_t __mask ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 146
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 44 "/home/june/repo/benchmarks/collector/temp/libdaemon-0.14/libdaemon/dpid.h"
char const   *daemon_pid_file_ident ;
#line 50
char const   *(*daemon_pid_file_proc)(void) ;
#line 56
char const   *daemon_pid_file_proc_default(void) ;
#line 61
int daemon_pid_file_create(void) ;
#line 66
int daemon_pid_file_remove(void) ;
#line 71
pid_t daemon_pid_file_is_running(void) ;
#line 77
int daemon_pid_file_kill(int s ) ;
#line 95
int daemon_pid_file_kill_wait(int s , int m ) ;
#line 66 "/home/june/repo/benchmarks/collector/temp/libdaemon-0.14/libdaemon/dlog.h"
void ( /* format attribute */  daemon_log)(int prio , char const   *template  , ...) ;
#line 53 "/home/june/repo/benchmarks/collector/temp/libdaemon-0.14/libdaemon/dpid.c"
char const   *daemon_pid_file_ident  =    (char const   *)((void *)0);
#line 54 "/home/june/repo/benchmarks/collector/temp/libdaemon-0.14/libdaemon/dpid.c"
char const   *(*daemon_pid_file_proc)(void)  =    & daemon_pid_file_proc_default;
#line 58 "/home/june/repo/benchmarks/collector/temp/libdaemon-0.14/libdaemon/dpid.c"
static char *fn  =    (char *)((void *)0);
#line 56 "/home/june/repo/benchmarks/collector/temp/libdaemon-0.14/libdaemon/dpid.c"
char const   *daemon_pid_file_proc_default(void) 
{ 
  char const   *tmp ;

  {
  {
#line 59
  free((void *)fn);
  }
#line 60
  if (daemon_pid_file_ident) {
#line 60
    tmp = daemon_pid_file_ident;
  } else {
#line 60
    tmp = "unknown";
  }
  {
#line 60
  asprintf((char **/* __restrict  */)(& fn), (char const   */* __restrict  */)"%s/%s.pid",
           "/usr/local/var/run", tmp);
  }
#line 66
  return ((char const   *)fn);
}
}
#line 69 "/home/june/repo/benchmarks/collector/temp/libdaemon-0.14/libdaemon/dpid.c"
static int lock_file(int fd , int enable ) 
{ 
  struct flock f ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 72
  memset((void *)(& f), 0, sizeof(f));
  }
#line 73
  if (enable) {
#line 73
    f.l_type = (short)1;
  } else {
#line 73
    f.l_type = (short)2;
  }
  {
#line 74
  f.l_whence = (short)0;
#line 75
  f.l_start = (__off_t )0;
#line 76
  f.l_len = (__off_t )0;
#line 78
  tmp___3 = fcntl(fd, 7, & f);
  }
#line 78
  if (tmp___3 < 0) {
#line 80
    if (enable) {
      {
#line 80
      tmp___0 = __errno_location();
      }
#line 80
      if (*tmp___0 == 9) {
        {
#line 81
        f.l_type = (short)0;
#line 83
        tmp = fcntl(fd, 7, & f);
        }
#line 83
        if (tmp >= 0) {
#line 84
          return (0);
        }
      }
    }
    {
#line 87
    tmp___1 = __errno_location();
#line 87
    tmp___2 = strerror(*tmp___1);
#line 87
    daemon_log(4, "fcntl(F_SETLKW) failed: %s", tmp___2);
    }
#line 88
    return (-1);
  }
#line 91
  return (0);
}
}
#line 96 "/home/june/repo/benchmarks/collector/temp/libdaemon-0.14/libdaemon/dpid.c"
static char txt[256]  ;
#line 94 "/home/june/repo/benchmarks/collector/temp/libdaemon-0.14/libdaemon/dpid.c"
pid_t daemon_pid_file_is_running(void) 
{ 
  char const   *fn___1 ;
  int fd ;
  int locked ;
  pid_t ret ;
  pid_t pid ;
  ssize_t l ;
  long lpid ;
  char *e ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  int saved_errno ;
  int *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  size_t tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  int *tmp___10 ;
  int saved_errno___0 ;
  int *tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  int *tmp___14 ;
  int tmp___15 ;
  int *tmp___16 ;
  int saved_errno___1 ;
  int *tmp___17 ;
  int *tmp___18 ;

  {
  {
#line 97
  fd = -1;
#line 97
  locked = -1;
#line 98
  ret = -1;
#line 101
  e = (char *)((void *)0);
#line 103
  fn___1 = (*daemon_pid_file_proc)();
  }
#line 103
  if (! fn___1) {
    {
#line 104
    tmp = __errno_location();
#line 104
    *tmp = 22;
    }
#line 105
    goto finish;
  }
  {
#line 108
  fd = open(fn___1, 2, 420);
  }
#line 108
  if (fd < 0) {
    {
#line 109
    fd = open(fn___1, 0, 420);
    }
#line 109
    if (fd < 0) {
      {
#line 110
      tmp___2 = __errno_location();
      }
#line 110
      if (*tmp___2 != 2) {
        {
#line 111
        tmp___0 = __errno_location();
#line 111
        tmp___1 = strerror(*tmp___0);
#line 111
        daemon_log(4, "Failed to open PID file: %s", tmp___1);
        }
      }
#line 113
      goto finish;
    }
  }
  {
#line 117
  locked = lock_file(fd, 1);
  }
#line 117
  if (locked < 0) {
#line 118
    goto finish;
  }
  {
#line 120
  l = read(fd, (void *)(txt), sizeof(txt) - 1UL);
  }
#line 120
  if (l < 0L) {
    {
#line 121
    tmp___3 = __errno_location();
#line 121
    saved_errno = *tmp___3;
#line 122
    tmp___4 = __errno_location();
#line 122
    tmp___5 = strerror(*tmp___4);
#line 122
    daemon_log(4, "read(): %s", tmp___5);
#line 123
    unlink(fn___1);
#line 124
    tmp___6 = __errno_location();
#line 124
    *tmp___6 = saved_errno;
    }
#line 125
    goto finish;
  }
  {
#line 128
  txt[l] = (char)0;
#line 129
  tmp___7 = strcspn((char const   *)(txt), "\r\n");
#line 129
  txt[tmp___7] = (char)0;
#line 131
  tmp___8 = __errno_location();
#line 131
  *tmp___8 = 0;
#line 132
  lpid = strtol((char const   */* __restrict  */)(txt), (char **/* __restrict  */)(& e),
                10);
#line 133
  pid = (pid_t )lpid;
#line 135
  tmp___10 = __errno_location();
  }
#line 135
  if (*tmp___10 != 0) {
    {
#line 136
    daemon_log(4, "PID file corrupt, removing. (%s)", fn___1);
#line 137
    unlink(fn___1);
#line 138
    tmp___9 = __errno_location();
#line 138
    *tmp___9 = 22;
    }
#line 139
    goto finish;
  } else
#line 135
  if (! e) {
    {
#line 136
    daemon_log(4, "PID file corrupt, removing. (%s)", fn___1);
#line 137
    unlink(fn___1);
#line 138
    tmp___9 = __errno_location();
#line 138
    *tmp___9 = 22;
    }
#line 139
    goto finish;
  } else
#line 135
  if (*e) {
    {
#line 136
    daemon_log(4, "PID file corrupt, removing. (%s)", fn___1);
#line 137
    unlink(fn___1);
#line 138
    tmp___9 = __errno_location();
#line 138
    *tmp___9 = 22;
    }
#line 139
    goto finish;
  } else
#line 135
  if ((long )pid != lpid) {
    {
#line 136
    daemon_log(4, "PID file corrupt, removing. (%s)", fn___1);
#line 137
    unlink(fn___1);
#line 138
    tmp___9 = __errno_location();
#line 138
    *tmp___9 = 22;
    }
#line 139
    goto finish;
  }
  {
#line 142
  tmp___15 = kill(pid, 0);
  }
#line 142
  if (tmp___15 != 0) {
    {
#line 142
    tmp___16 = __errno_location();
    }
#line 142
    if (*tmp___16 != 1) {
      {
#line 143
      tmp___11 = __errno_location();
#line 143
      saved_errno___0 = *tmp___11;
#line 144
      tmp___12 = __errno_location();
#line 144
      tmp___13 = strerror(*tmp___12);
#line 144
      daemon_log(4, "Process %lu died: %s; trying to remove PID file. (%s)", (unsigned long )pid,
                 tmp___13, fn___1);
#line 145
      unlink(fn___1);
#line 146
      tmp___14 = __errno_location();
#line 146
      *tmp___14 = saved_errno___0;
      }
#line 147
      goto finish;
    }
  }
#line 150
  ret = pid;
  finish: 
#line 154
  if (fd >= 0) {
    {
#line 155
    tmp___17 = __errno_location();
#line 155
    saved_errno___1 = *tmp___17;
    }
#line 156
    if (locked >= 0) {
      {
#line 157
      lock_file(fd, 0);
      }
    }
    {
#line 158
    close(fd);
#line 159
    tmp___18 = __errno_location();
#line 159
    *tmp___18 = saved_errno___1;
    }
  }
#line 162
  return (ret);
}
}
#line 165 "/home/june/repo/benchmarks/collector/temp/libdaemon-0.14/libdaemon/dpid.c"
int daemon_pid_file_kill(int s ) 
{ 
  pid_t pid ;
  int tmp ;

  {
  {
#line 168
  pid = daemon_pid_file_is_running();
  }
#line 168
  if (pid == -1) {
#line 169
    return (-1);
  }
  {
#line 171
  tmp = kill(pid, s);
  }
#line 171
  if (tmp < 0) {
#line 172
    return (-1);
  }
#line 174
  return (0);
}
}
#line 177 "/home/june/repo/benchmarks/collector/temp/libdaemon-0.14/libdaemon/dpid.c"
int daemon_pid_file_kill_wait(int s , int m ) 
{ 
  pid_t pid ;
  time_t t ;
  int tmp ;
  time_t tmp___0 ;
  int r ;
  struct timeval tv ;
  int *tmp___1 ;
  time_t tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 181
  pid = daemon_pid_file_is_running();
  }
#line 181
  if (pid < 0) {
#line 182
    return (-1);
  }
  {
#line 184
  tmp = kill(pid, s);
  }
#line 184
  if (tmp < 0) {
#line 185
    return (-1);
  }
  {
#line 187
  tmp___0 = time((time_t *)((void *)0));
#line 187
  t = tmp___0 + (time_t )m;
  }
  {
#line 189
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 191
    tv.tv_sec = (__time_t )0;
#line 191
    tv.tv_usec = (__suseconds_t )100000;
#line 193
    tmp___2 = time((time_t *)((void *)0));
    }
#line 193
    if (tmp___2 > t) {
      {
#line 194
      tmp___1 = __errno_location();
#line 194
      *tmp___1 = 62;
      }
#line 195
      return (-1);
    }
    {
#line 198
    r = kill(pid, 0);
    }
#line 198
    if (r < 0) {
      {
#line 198
      tmp___3 = __errno_location();
      }
#line 198
      if (*tmp___3 != 3) {
#line 199
        return (-1);
      }
    }
#line 201
    if (r) {
#line 202
      return (0);
    }
    {
#line 204
    tmp___4 = select(0, (fd_set */* __restrict  */)((void *)0), (fd_set */* __restrict  */)((void *)0),
                     (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
    }
#line 204
    if (tmp___4 < 0) {
#line 205
      return (-1);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 209 "/home/june/repo/benchmarks/collector/temp/libdaemon-0.14/libdaemon/dpid.c"
int daemon_pid_file_create(void) 
{ 
  char const   *fn___1 ;
  int fd ;
  int ret ;
  int locked ;
  char t[64] ;
  ssize_t l ;
  mode_t u ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int saved_errno ;
  int *tmp___2 ;
  int *tmp___3 ;
  __pid_t tmp___4 ;
  size_t tmp___5 ;
  int saved_errno___0 ;
  int *tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int *tmp___9 ;
  ssize_t tmp___10 ;
  int saved_errno___1 ;
  int *tmp___11 ;
  int *tmp___12 ;

  {
  {
#line 211
  fd = -1;
#line 212
  ret = -1;
#line 213
  locked = -1;
#line 218
  u = umask((__mode_t )18);
#line 220
  fn___1 = (*daemon_pid_file_proc)();
  }
#line 220
  if (! fn___1) {
    {
#line 221
    tmp = __errno_location();
#line 221
    *tmp = 22;
    }
#line 222
    goto finish;
  }
  {
#line 225
  fd = open(fn___1, 194, 420);
  }
#line 225
  if (fd < 0) {
    {
#line 226
    tmp___0 = __errno_location();
#line 226
    tmp___1 = strerror(*tmp___0);
#line 226
    daemon_log(3, "open(%s): %s", fn___1, tmp___1);
    }
#line 227
    goto finish;
  }
  {
#line 230
  locked = lock_file(fd, 1);
  }
#line 230
  if (locked < 0) {
    {
#line 231
    tmp___2 = __errno_location();
#line 231
    saved_errno = *tmp___2;
#line 232
    unlink(fn___1);
#line 233
    tmp___3 = __errno_location();
#line 233
    *tmp___3 = saved_errno;
    }
#line 234
    goto finish;
  }
  {
#line 237
  tmp___4 = getpid();
#line 237
  snprintf((char */* __restrict  */)(t), sizeof(t), (char const   */* __restrict  */)"%lu\n",
           (unsigned long )tmp___4);
#line 239
  tmp___5 = strlen((char const   *)(t));
#line 239
  l = (ssize_t )tmp___5;
#line 240
  tmp___10 = write(fd, (void const   *)(t), (size_t )l);
  }
#line 240
  if (tmp___10 != l) {
    {
#line 241
    tmp___6 = __errno_location();
#line 241
    saved_errno___0 = *tmp___6;
#line 242
    tmp___7 = __errno_location();
#line 242
    tmp___8 = strerror(*tmp___7);
#line 242
    daemon_log(4, "write(): %s", tmp___8);
#line 243
    unlink(fn___1);
#line 244
    tmp___9 = __errno_location();
#line 244
    *tmp___9 = saved_errno___0;
    }
#line 245
    goto finish;
  }
#line 248
  ret = 0;
  finish: 
#line 252
  if (fd >= 0) {
    {
#line 253
    tmp___11 = __errno_location();
#line 253
    saved_errno___1 = *tmp___11;
    }
#line 255
    if (locked >= 0) {
      {
#line 256
      lock_file(fd, 0);
      }
    }
    {
#line 258
    close(fd);
#line 259
    tmp___12 = __errno_location();
#line 259
    *tmp___12 = saved_errno___1;
    }
  }
  {
#line 262
  umask(u);
  }
#line 264
  return (ret);
}
}
#line 267 "/home/june/repo/benchmarks/collector/temp/libdaemon-0.14/libdaemon/dpid.c"
int daemon_pid_file_remove(void) 
{ 
  char const   *fn___1 ;
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 270
  fn___1 = (*daemon_pid_file_proc)();
  }
#line 270
  if (! fn___1) {
    {
#line 271
    tmp = __errno_location();
#line 271
    *tmp = 22;
    }
#line 272
    return (-1);
  }
  {
#line 275
  tmp___0 = unlink(fn___1);
  }
#line 275
  return (tmp___0);
}
}
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 417 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pipe)(int *__pipedes ) ;
#line 497
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 563
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execv)(char const   *__path ,
                                                                                              char * const  *__argv ) ;
#line 603
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 125 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 62 "/home/june/repo/benchmarks/collector/temp/libdaemon-0.14/libdaemon/dsignal.h"
int daemon_signal_next(void) ;
#line 69
int daemon_signal_fd(void) ;
#line 112 "/home/june/repo/benchmarks/collector/temp/libdaemon-0.14/libdaemon/dfork.h"
int daemon_close_all(int except_fd  , ...) ;
#line 130
int daemon_unblock_sigs(int except  , ...) ;
#line 148
int daemon_reset_sigs(int except  , ...) ;
#line 63 "/home/june/repo/benchmarks/collector/temp/libdaemon-0.14/libdaemon/dexec.h"
int daemon_exec(char const   *dir , int *ret , char const   *prog  , ...)  __attribute__((__sentinel__)) ;
#line 73
int daemon_execv(char const   *dir , int *ret , char const   *prog , va_list ap ) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/libdaemon-0.14/libdaemon/dexec.c"
static char buf[256]  ;
#line 46 "/home/june/repo/benchmarks/collector/temp/libdaemon-0.14/libdaemon/dexec.c"
int daemon_execv(char const   *dir , int *ret , char const   *prog , va_list ap ) 
{ 
  pid_t pid ;
  int p[2] ;
  unsigned int n ;
  int sigfd ;
  int r ;
  fd_set fds ;
  int saved_errno ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  char *args[64] ;
  int i ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  int *tmp___17 ;
  char *tmp___18 ;
  int __d0 ;
  int __d1 ;
  fd_set qfds ;
  int *tmp___19 ;
  int *tmp___20 ;
  char *tmp___21 ;
  int *tmp___22 ;
  int *tmp___23 ;
  int tmp___24 ;
  char c ;
  ssize_t tmp___25 ;
  int sig ;
  int *tmp___26 ;
  int *tmp___27 ;
  int *tmp___28 ;
  int *tmp___29 ;
  char *tmp___30 ;
  int *tmp___31 ;
  union __anonunion_54 __constr_expr_0 ;
  union __anonunion_55 __constr_expr_1 ;
  __pid_t tmp___32 ;

  {
  {
#line 49
  n = 0U;
#line 55
  tmp = daemon_signal_fd();
  }
#line 55
  if (! (tmp >= 0)) {
    {
#line 55
    __assert_fail("daemon_signal_fd() >= 0", "/home/june/repo/benchmarks/collector/temp/libdaemon-0.14/libdaemon/dexec.c",
                  55U, "daemon_execv");
    }
  }
  {
#line 57
  tmp___2 = pipe((int *)(p));
  }
#line 57
  if (tmp___2 < 0) {
    {
#line 58
    tmp___0 = __errno_location();
#line 58
    tmp___1 = strerror(*tmp___0);
#line 58
    daemon_log(3, "pipe() failed: %s", tmp___1);
    }
#line 59
    return (-1);
  }
  {
#line 62
  pid = fork();
  }
#line 62
  if (pid < 0) {
    {
#line 63
    tmp___3 = __errno_location();
#line 63
    tmp___4 = strerror(*tmp___3);
#line 63
    daemon_log(3, "fork() failed: %s", tmp___4);
#line 65
    tmp___5 = __errno_location();
#line 65
    saved_errno = *tmp___5;
#line 66
    close(p[0]);
#line 67
    close(p[1]);
#line 68
    tmp___6 = __errno_location();
#line 68
    *tmp___6 = saved_errno;
    }
#line 70
    return (-1);
  } else
#line 72
  if (pid == 0) {
#line 76
    if (p[1] != 1) {
      {
#line 77
      tmp___9 = dup2(p[1], 1);
      }
#line 77
      if (tmp___9 < 0) {
        {
#line 78
        tmp___7 = __errno_location();
#line 78
        tmp___8 = strerror(*tmp___7);
#line 78
        daemon_log(3, "dup2: %s", tmp___8);
        }
#line 79
        goto fail;
      }
    }
#line 82
    if (p[1] != 2) {
      {
#line 83
      tmp___12 = dup2(p[1], 2);
      }
#line 83
      if (tmp___12 < 0) {
        {
#line 84
        tmp___10 = __errno_location();
#line 84
        tmp___11 = strerror(*tmp___10);
#line 84
        daemon_log(3, "dup2: %s", tmp___11);
        }
#line 85
        goto fail;
      }
    }
#line 89
    if (p[0] > 2) {
      {
#line 90
      close(p[0]);
      }
    }
#line 92
    if (p[1] > 2) {
      {
#line 93
      close(p[1]);
      }
    }
    {
#line 95
    close(0);
#line 97
    tmp___13 = open("/dev/null", 0);
    }
#line 97
    if (tmp___13 != 0) {
      {
#line 98
      daemon_log(3, "Unable to open /dev/null as STDIN");
      }
#line 99
      goto fail;
    }
    {
#line 102
    daemon_close_all(-1);
#line 103
    daemon_reset_sigs(-1);
#line 104
    daemon_unblock_sigs(-1);
#line 106
    umask((__mode_t )18);
    }
#line 108
    if (dir) {
      {
#line 108
      tmp___14 = chdir(dir);
      }
#line 108
      if (tmp___14 < 0) {
        {
#line 109
        daemon_log(4, "Failed to change to directory \'%s\'", dir);
#line 110
        chdir("/");
        }
      }
    }
#line 113
    i = 0;
    {
#line 113
    while (1) {
      while_continue: /* CIL Label */ ;
#line 113
      if (! (i < 63)) {
#line 113
        goto while_break;
      }
      {
#line 114
      tmp___16 = __builtin_va_arg(ap, char *);
#line 114
      tmp___15 = tmp___16;
#line 114
      args[i] = tmp___15;
      }
#line 114
      if (! tmp___15) {
#line 115
        goto while_break;
      }
#line 113
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 116
    args[i] = (char *)((void *)0);
#line 118
    execv(prog, (char * const  *)(args));
#line 120
    tmp___17 = __errno_location();
#line 120
    tmp___18 = strerror(*tmp___17);
#line 120
    daemon_log(3, "execv(%s) failed: %s", prog, tmp___18);
    }
    fail: 
    {
#line 124
    _exit(1);
    }
  }
  {
#line 127
  close(p[1]);
  }
  {
#line 129
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 129
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& fds.fds_bits[0]): "memory");
#line 129
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 130
  fds.fds_bits[p[0] / (8 * (int )sizeof(__fd_mask ))] |= 1L << p[0] % (8 * (int )sizeof(__fd_mask ));
#line 131
  sigfd = daemon_signal_fd();
#line 132
  fds.fds_bits[sigfd / (8 * (int )sizeof(__fd_mask ))] |= 1L << sigfd % (8 * (int )sizeof(__fd_mask ));
#line 134
  n = 0U;
  }
  {
#line 136
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 137
    qfds = fds;
#line 139
    tmp___24 = select(1024, (fd_set */* __restrict  */)(& qfds), (fd_set */* __restrict  */)((void *)0),
                      (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)((void *)0));
    }
#line 139
    if (tmp___24 < 0) {
      {
#line 141
      tmp___19 = __errno_location();
      }
#line 141
      if (*tmp___19 == 4) {
#line 142
        goto __Cont;
      }
      {
#line 144
      tmp___20 = __errno_location();
#line 144
      tmp___21 = strerror(*tmp___20);
#line 144
      daemon_log(3, "select() failed: %s", tmp___21);
#line 146
      tmp___22 = __errno_location();
#line 146
      saved_errno = *tmp___22;
#line 147
      close(p[0]);
#line 148
      tmp___23 = __errno_location();
#line 148
      *tmp___23 = saved_errno;
      }
#line 149
      return (-1);
    }
#line 152
    if ((qfds.fds_bits[p[0] / (8 * (int )sizeof(__fd_mask ))] & (1L << p[0] % (8 * (int )sizeof(__fd_mask )))) != 0L) {
      {
#line 155
      tmp___25 = read(p[0], (void *)(& c), (size_t )1);
      }
#line 155
      if (tmp___25 != 1L) {
#line 156
        goto while_break___1;
      }
#line 158
      buf[n] = c;
#line 160
      if ((int )c == 10) {
#line 160
        goto _L;
      } else
#line 160
      if ((unsigned long )n >= sizeof(buf) - 2UL) {
        _L: /* CIL Label */ 
#line 161
        if ((int )c != 10) {
#line 161
          n ++;
        }
#line 162
        buf[n] = (char)0;
#line 164
        if (buf[0]) {
          {
#line 165
          daemon_log(6, "client: %s", buf);
          }
        }
#line 167
        n = 0U;
      } else {
#line 169
        n ++;
      }
    }
#line 172
    if ((qfds.fds_bits[sigfd / (8 * (int )sizeof(__fd_mask ))] & (1L << sigfd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
      {
#line 175
      sig = daemon_signal_next();
      }
#line 175
      if (sig < 0) {
        {
#line 176
        tmp___26 = __errno_location();
#line 176
        saved_errno = *tmp___26;
#line 177
        close(p[0]);
#line 178
        tmp___27 = __errno_location();
#line 178
        *tmp___27 = saved_errno;
        }
#line 179
        return (-1);
      }
#line 182
      if (sig != 17) {
        {
#line 183
        daemon_log(4, "Killing child.");
#line 184
        kill(pid, 15);
        }
      }
    }
    __Cont: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 189
  if (n > 0U) {
    {
#line 190
    buf[n] = (char)0;
#line 191
    daemon_log(4, "client: %s", buf);
    }
  }
  {
#line 194
  close(p[0]);
  }
  {
#line 196
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 197
    tmp___32 = waitpid(pid, & r, 0);
    }
#line 197
    if (tmp___32 < 0) {
      {
#line 199
      tmp___28 = __errno_location();
      }
#line 199
      if (*tmp___28 == 4) {
#line 200
        goto __Cont___0;
      }
      {
#line 202
      tmp___29 = __errno_location();
#line 202
      tmp___30 = strerror(*tmp___29);
#line 202
      daemon_log(3, "waitpid(): %s", tmp___30);
      }
#line 203
      return (-1);
    } else {
#line 205
      __constr_expr_0.__in = r;
#line 205
      if (! ((__constr_expr_0.__i & 127) == 0)) {
        {
#line 206
        tmp___31 = __errno_location();
#line 206
        *tmp___31 = 125;
        }
#line 207
        return (-1);
      }
#line 210
      if (ret) {
#line 211
        __constr_expr_1.__in = r;
#line 211
        *ret = (__constr_expr_1.__i & 65280) >> 8;
      }
#line 213
      return (0);
    }
    __Cont___0: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
}
}
#line 218
int daemon_exec(char const   *dir , int *ret , char const   *prog  , ...)  __attribute__((__sentinel__)) ;
#line 218 "/home/june/repo/benchmarks/collector/temp/libdaemon-0.14/libdaemon/dexec.c"
int daemon_exec(char const   *dir , int *ret , char const   *prog  , ...) 
{ 
  va_list ap ;
  int r ;

  {
  {
#line 222
  __builtin_va_start(ap, prog);
#line 223
  r = daemon_execv(dir, ret, prog, ap);
#line 224
  __builtin_va_end(ap);
  }
#line 226
  return (r);
}
}
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 263 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 181 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 200
extern void ( /* format attribute */  vsyslog)(int __pri , char const   *__fmt , __gnuc_va_list __ap ) ;
#line 49 "/home/june/repo/benchmarks/collector/temp/libdaemon-0.14/libdaemon/dlog.h"
enum daemon_log_flags daemon_log_use ;
#line 53
char const   *daemon_log_ident ;
#line 78
void daemon_logv(int prio , char const   *template , va_list arglist ) ;
#line 86
char *daemon_ident_from_argv0(char *argv0 ) ;
#line 108
void daemon_set_verbosity(int verbosity_prio ) ;
#line 32 "/home/june/repo/benchmarks/collector/temp/libdaemon-0.14/libdaemon/dlog.c"
enum daemon_log_flags daemon_log_use  =    (enum daemon_log_flags )10;
#line 33 "/home/june/repo/benchmarks/collector/temp/libdaemon-0.14/libdaemon/dlog.c"
char const   *daemon_log_ident  =    (char const   *)((void *)0);
#line 35 "/home/june/repo/benchmarks/collector/temp/libdaemon-0.14/libdaemon/dlog.c"
static int daemon_verbosity_level  =    6;
#line 37 "/home/june/repo/benchmarks/collector/temp/libdaemon-0.14/libdaemon/dlog.c"
void daemon_set_verbosity(int verbosity_prio ) 
{ 


  {
#line 40
  if (verbosity_prio > 0) {
#line 40
    if ((verbosity_prio & 7) != 7) {
      {
#line 41
      daemon_log(3, "The value %d is not a valid priority value", verbosity_prio);
      }
    }
  }
#line 43
  daemon_verbosity_level = verbosity_prio & 7;
#line 44
  return;
}
}
#line 46 "/home/june/repo/benchmarks/collector/temp/libdaemon-0.14/libdaemon/dlog.c"
void daemon_logv(int prio , char const   *template , va_list arglist ) 
{ 
  int saved_errno ;
  int *tmp ;
  char const   *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 49
  tmp = __errno_location();
#line 49
  saved_errno = *tmp;
  }
#line 51
  if ((unsigned int )daemon_log_use & 1U) {
#line 52
    if (daemon_log_ident) {
#line 52
      tmp___0 = daemon_log_ident;
    } else {
#line 52
      tmp___0 = "UNKNOWN";
    }
    {
#line 52
    openlog(tmp___0, 1, 3 << 3);
#line 53
    vsyslog(prio | (3 << 3), template, arglist);
    }
  }
#line 56
  if (prio > daemon_verbosity_level) {
#line 57
    goto end_daemon_logv;
  }
#line 59
  if ((unsigned int )daemon_log_use & 2U) {
    {
#line 60
    vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)template,
             arglist);
#line 61
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
  }
#line 64
  if ((unsigned int )daemon_log_use & 4U) {
    {
#line 65
    vfprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)template,
             arglist);
#line 66
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\n");
    }
  }
  end_daemon_logv: 
  {
#line 70
  tmp___1 = __errno_location();
#line 70
  *tmp___1 = saved_errno;
  }
#line 71
  return;
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/libdaemon-0.14/libdaemon/dlog.c"
void ( /* format attribute */  daemon_log)(int prio , char const   *template  , ...) 
{ 
  va_list arglist ;

  {
  {
#line 76
  __builtin_va_start(arglist, template);
#line 77
  daemon_logv(prio, template, arglist);
#line 78
  __builtin_va_end(arglist);
  }
#line 79
  return;
}
}
#line 81 "/home/june/repo/benchmarks/collector/temp/libdaemon-0.14/libdaemon/dlog.c"
char *daemon_ident_from_argv0(char *argv0 ) 
{ 
  char *p ;

  {
  {
#line 84
  p = strrchr((char const   *)argv0, '/');
  }
#line 84
  if (p) {
#line 85
    return (p + 1);
  }
#line 87
  return (argv0);
}
}
#line 564 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strsignal)(int __sig ) ;
#line 215 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigemptyset)(sigset_t *__set ) ;
#line 221
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigaddset)(sigset_t *__set ,
                                                                                                int __signo ) ;
#line 248
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigprocmask)(int __how ,
                                                                                  sigset_t const   * __restrict  __set ,
                                                                                  sigset_t * __restrict  __oset ) ;
#line 259
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigaction)(int __sig ,
                                                                                struct sigaction  const  * __restrict  __act ,
                                                                                struct sigaction * __restrict  __oact ) ;
#line 45 "/home/june/repo/benchmarks/collector/temp/libdaemon-0.14/libdaemon/dsignal.h"
int daemon_signal_init(int s  , ...) ;
#line 51
int daemon_signal_install(int s ) ;
#line 55
void daemon_signal_done(void) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/libdaemon-0.14/libdaemon/dnonblock.h"
int daemon_nonblock(int fd , int b ) ;
#line 36 "/home/june/repo/benchmarks/collector/temp/libdaemon-0.14/libdaemon/dsignal.c"
static int _signal_pipe[2]  = {      -1,      -1};
#line 38 "/home/june/repo/benchmarks/collector/temp/libdaemon-0.14/libdaemon/dsignal.c"
static void _sigfunc(int s ) 
{ 
  int saved_errno ;
  int *tmp ;
  int *tmp___0 ;

  {
  {
#line 39
  tmp = __errno_location();
#line 39
  saved_errno = *tmp;
#line 40
  write(_signal_pipe[1], (void const   *)(& s), sizeof(s));
#line 41
  tmp___0 = __errno_location();
#line 41
  *tmp___0 = saved_errno;
  }
#line 42
  return;
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/libdaemon-0.14/libdaemon/dsignal.c"
static int _init(void) 
{ 
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 46
  if (_signal_pipe[0] < 0) {
#line 46
    goto _L;
  } else
#line 46
  if (_signal_pipe[1] < 0) {
    _L: /* CIL Label */ 
    {
#line 47
    tmp___1 = pipe((int *)(_signal_pipe));
    }
#line 47
    if (tmp___1 < 0) {
      {
#line 48
      tmp = __errno_location();
#line 48
      tmp___0 = strerror(*tmp);
#line 48
      daemon_log(3, "pipe(): %s", tmp___0);
      }
#line 49
      return (-1);
    }
    {
#line 52
    tmp___2 = daemon_nonblock(_signal_pipe[0], 1);
    }
#line 52
    if (tmp___2 < 0) {
      {
#line 53
      daemon_signal_done();
      }
#line 54
      return (-1);
    } else {
      {
#line 52
      tmp___3 = daemon_nonblock(_signal_pipe[1], 1);
      }
#line 52
      if (tmp___3 < 0) {
        {
#line 53
        daemon_signal_done();
        }
#line 54
        return (-1);
      }
    }
  }
#line 58
  return (0);
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/libdaemon-0.14/libdaemon/dsignal.c"
int daemon_signal_install(int s ) 
{ 
  sigset_t ss ;
  struct sigaction sa ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;

  {
  {
#line 65
  tmp = _init();
  }
#line 65
  if (tmp < 0) {
#line 66
    return (-1);
  }
  {
#line 68
  tmp___2 = sigemptyset(& ss);
  }
#line 68
  if (tmp___2 < 0) {
    {
#line 69
    tmp___0 = __errno_location();
#line 69
    tmp___1 = strerror(*tmp___0);
#line 69
    daemon_log(3, "sigemptyset(): %s", tmp___1);
    }
#line 70
    return (-1);
  }
  {
#line 73
  tmp___5 = sigaddset(& ss, s);
  }
#line 73
  if (tmp___5 < 0) {
    {
#line 74
    tmp___3 = __errno_location();
#line 74
    tmp___4 = strerror(*tmp___3);
#line 74
    daemon_log(3, "sigaddset(): %s", tmp___4);
    }
#line 75
    return (-1);
  }
  {
#line 78
  tmp___8 = sigprocmask(1, (sigset_t const   */* __restrict  */)(& ss), (sigset_t */* __restrict  */)((void *)0));
  }
#line 78
  if (tmp___8 < 0) {
    {
#line 79
    tmp___6 = __errno_location();
#line 79
    tmp___7 = strerror(*tmp___6);
#line 79
    daemon_log(3, "sigprocmask(): %s", tmp___7);
    }
#line 80
    return (-1);
  }
  {
#line 83
  memset((void *)(& sa), 0, sizeof(sa));
#line 84
  sa.__sigaction_handler.sa_handler = & _sigfunc;
#line 85
  sigemptyset(& sa.sa_mask);
#line 86
  sa.sa_flags = 268435456;
#line 88
  tmp___12 = sigaction(s, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
  }
#line 88
  if (tmp___12 < 0) {
    {
#line 89
    tmp___9 = __errno_location();
#line 89
    tmp___10 = strerror(*tmp___9);
#line 89
    tmp___11 = strsignal(s);
#line 89
    daemon_log(3, "sigaction(%s, ...) failed: %s", tmp___11, tmp___10);
    }
#line 90
    return (-1);
  }
#line 93
  return (0);
}
}
#line 96 "/home/june/repo/benchmarks/collector/temp/libdaemon-0.14/libdaemon/dsignal.c"
int daemon_signal_init(int s  , ...) 
{ 
  int sig ;
  int r ;
  va_list ap ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 97
  r = 0;
#line 100
  tmp = _init();
  }
#line 100
  if (tmp < 0) {
#line 101
    return (-1);
  }
  {
#line 103
  __builtin_va_start(ap, s);
#line 105
  sig = s;
  }
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
#line 106
    if (! (sig > 0)) {
#line 106
      goto while_break;
    }
    {
#line 107
    r = daemon_signal_install(sig);
    }
#line 107
    if (r < 0) {
#line 108
      goto while_break;
    }
    {
#line 110
    tmp___0 = __builtin_va_arg(ap, int );
#line 110
    sig = tmp___0;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 113
  __builtin_va_end(ap);
  }
#line 115
  return (r);
}
}
#line 118 "/home/june/repo/benchmarks/collector/temp/libdaemon-0.14/libdaemon/dsignal.c"
void daemon_signal_done(void) 
{ 
  int saved_errno ;
  int *tmp ;
  int *tmp___0 ;

  {
  {
#line 119
  tmp = __errno_location();
#line 119
  saved_errno = *tmp;
  }
#line 121
  if (_signal_pipe[0] != -1) {
    {
#line 122
    close(_signal_pipe[0]);
    }
  }
#line 124
  if (_signal_pipe[1] != -1) {
    {
#line 125
    close(_signal_pipe[1]);
    }
  }
  {
#line 127
  _signal_pipe[1] = -1;
#line 127
  _signal_pipe[0] = _signal_pipe[1];
#line 129
  tmp___0 = __errno_location();
#line 129
  *tmp___0 = saved_errno;
  }
#line 130
  return;
}
}
#line 132 "/home/june/repo/benchmarks/collector/temp/libdaemon-0.14/libdaemon/dsignal.c"
int daemon_signal_next(void) 
{ 
  int s ;
  ssize_t r ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 136
  r = read(_signal_pipe[0], (void *)(& s), sizeof(s));
  }
#line 136
  if ((unsigned long )r == sizeof(s)) {
#line 137
    return (s);
  }
#line 139
  if (r < 0L) {
    {
#line 141
    tmp___1 = __errno_location();
    }
#line 141
    if (*tmp___1 == 11) {
#line 142
      return (0);
    } else {
      {
#line 144
      tmp = __errno_location();
#line 144
      tmp___0 = strerror(*tmp);
#line 144
      daemon_log(3, "read(signal_pipe[0], ...): %s", tmp___0);
      }
#line 145
      return (-1);
    }
  }
  {
#line 149
  daemon_log(3, "Short read() on signal pipe.");
  }
#line 150
  return (-1);
}
}
#line 153 "/home/june/repo/benchmarks/collector/temp/libdaemon-0.14/libdaemon/dsignal.c"
int daemon_signal_fd(void) 
{ 


  {
#line 154
  return (_signal_pipe[0]);
}
}
#line 531 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup)(int __fd ) ;
#line 619
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) sysconf)(int __name ) ;
#line 667
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) setsid)(void) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 50 "/usr/include/x86_64-linux-gnu/sys/resource.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getrlimit)(__rlimit_resource_t __resource ,
                                                                                struct rlimit *__rlimits ) ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 162
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 223
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) dirfd)(DIR *__dirp ) ;
#line 63 "/home/june/repo/benchmarks/collector/temp/libdaemon-0.14/libdaemon/dfork.h"
pid_t daemon_fork(void) ;
#line 71
int daemon_retval_init(void) ;
#line 80
void daemon_retval_done(void) ;
#line 91
int daemon_retval_wait(int timeout ) ;
#line 100
int daemon_retval_send(int i ) ;
#line 118
int daemon_close_allv(int const   *except_fds ) ;
#line 136
int daemon_unblock_sigsv(int const   *except ) ;
#line 154
int daemon_reset_sigsv(int const   *except ) ;
#line 53 "/home/june/repo/benchmarks/collector/temp/libdaemon-0.14/libdaemon/dfork.c"
static int _daemon_retval_pipe[2]  = {      -1,      -1};
#line 55 "/home/june/repo/benchmarks/collector/temp/libdaemon-0.14/libdaemon/dfork.c"
static int _null_open(int f , int fd ) 
{ 
  int fd2 ;
  int tmp ;

  {
  {
#line 58
  fd2 = open("/dev/null", f);
  }
#line 58
  if (fd2 < 0) {
#line 59
    return (-1);
  }
#line 61
  if (fd2 == fd) {
#line 62
    return (fd);
  }
  {
#line 64
  tmp = dup2(fd2, fd);
  }
#line 64
  if (tmp < 0) {
#line 65
    return (-1);
  }
  {
#line 67
  close(fd2);
  }
#line 68
  return (fd);
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/libdaemon-0.14/libdaemon/dfork.c"
static ssize_t atomic_read(int fd , void *d , size_t l ) 
{ 
  ssize_t t ;
  ssize_t r ;
  ssize_t tmp ;

  {
#line 72
  t = (ssize_t )0;
  {
#line 74
  while (1) {
    while_continue: /* CIL Label */ ;
#line 74
    if (! (l > 0UL)) {
#line 74
      goto while_break;
    }
    {
#line 77
    r = read(fd, d, l);
    }
#line 77
    if (r <= 0L) {
#line 79
      if (r < 0L) {
#line 80
        if (t > 0L) {
#line 80
          tmp = t;
        } else {
#line 80
          tmp = (ssize_t )-1;
        }
#line 80
        return (tmp);
      } else {
#line 82
        return (t);
      }
    }
#line 85
    t += r;
#line 86
    d = (void *)((char *)d + r);
#line 87
    l -= (size_t )r;
  }
  while_break: /* CIL Label */ ;
  }
#line 90
  return (t);
}
}
#line 93 "/home/june/repo/benchmarks/collector/temp/libdaemon-0.14/libdaemon/dfork.c"
static ssize_t atomic_write(int fd , void const   *d , size_t l ) 
{ 
  ssize_t t ;
  ssize_t r ;
  ssize_t tmp ;

  {
#line 94
  t = (ssize_t )0;
  {
#line 96
  while (1) {
    while_continue: /* CIL Label */ ;
#line 96
    if (! (l > 0UL)) {
#line 96
      goto while_break;
    }
    {
#line 99
    r = write(fd, d, l);
    }
#line 99
    if (r <= 0L) {
#line 101
      if (r < 0L) {
#line 102
        if (t > 0L) {
#line 102
          tmp = t;
        } else {
#line 102
          tmp = (ssize_t )-1;
        }
#line 102
        return (tmp);
      } else {
#line 104
        return (t);
      }
    }
#line 107
    t += r;
#line 108
    d = (void const   *)((char const   *)d + r);
#line 109
    l -= (size_t )r;
  }
  while_break: /* CIL Label */ ;
  }
#line 112
  return (t);
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/libdaemon-0.14/libdaemon/dfork.c"
static int move_fd_up(int *fd ) 
{ 
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 116
  if (! fd) {
    {
#line 116
    __assert_fail("fd", "/home/june/repo/benchmarks/collector/temp/libdaemon-0.14/libdaemon/dfork.c",
                  116U, "move_fd_up");
    }
  }
  {
#line 118
  while (1) {
    while_continue: /* CIL Label */ ;
#line 118
    if (! (*fd <= 2)) {
#line 118
      goto while_break;
    }
    {
#line 119
    tmp___1 = dup(*fd);
#line 119
    *fd = tmp___1;
    }
#line 119
    if (tmp___1 < 0) {
      {
#line 120
      tmp = __errno_location();
#line 120
      tmp___0 = strerror(*tmp);
#line 120
      daemon_log(3, "dup(): %s", tmp___0);
      }
#line 121
      return (-1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 125
  return (0);
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/libdaemon-0.14/libdaemon/dfork.c"
static void sigchld(int s ) 
{ 


  {
#line 129
  return;
}
}
#line 131 "/home/june/repo/benchmarks/collector/temp/libdaemon-0.14/libdaemon/dfork.c"
pid_t daemon_fork(void) 
{ 
  pid_t pid ;
  int pipe_fds[2] ;
  struct sigaction sa_old ;
  struct sigaction sa_new ;
  sigset_t ss_old ;
  sigset_t ss_new ;
  int saved_errno ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int *tmp___10 ;
  int *tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  int *tmp___15 ;
  int *tmp___16 ;
  int tmp___17 ;
  int *tmp___18 ;
  char *tmp___19 ;
  int *tmp___20 ;
  int *tmp___21 ;
  pid_t dpid ;
  int *tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int *tmp___28 ;
  char *tmp___29 ;
  int tmp___30 ;
  int *tmp___31 ;
  char *tmp___32 ;
  int tmp___33 ;
  int *tmp___34 ;
  char *tmp___35 ;
  int tmp___36 ;
  int *tmp___37 ;
  char *tmp___38 ;
  __pid_t tmp___39 ;
  int *tmp___40 ;
  char *tmp___41 ;
  int tmp___42 ;
  int *tmp___43 ;
  char *tmp___44 ;
  int *tmp___45 ;
  char *tmp___46 ;
  int tmp___47 ;
  int *tmp___48 ;
  char *tmp___49 ;
  int tmp___50 ;
  int *tmp___51 ;
  char *tmp___52 ;
  __sighandler_t tmp___53 ;
  int *tmp___54 ;
  char *tmp___55 ;
  __sighandler_t tmp___56 ;
  int *tmp___57 ;
  char *tmp___58 ;
  __sighandler_t tmp___59 ;
  int *tmp___60 ;
  char *tmp___61 ;
  ssize_t tmp___62 ;
  int *tmp___63 ;
  char *tmp___64 ;
  int tmp___65 ;
  int *tmp___66 ;
  char *tmp___67 ;
  ssize_t tmp___68 ;
  pid_t dpid___0 ;
  int *tmp___69 ;
  int *tmp___70 ;
  __pid_t tmp___71 ;
  int *tmp___72 ;
  int *tmp___73 ;
  ssize_t tmp___74 ;
  int *tmp___75 ;
  int *tmp___76 ;

  {
  {
#line 133
  pipe_fds[0] = -1;
#line 133
  pipe_fds[1] = -1;
#line 138
  memset((void *)(& sa_new), 0, sizeof(sa_new));
#line 139
  sa_new.__sigaction_handler.sa_handler = & sigchld;
#line 140
  sa_new.sa_flags = 268435456;
#line 142
  tmp___1 = sigemptyset(& ss_new);
  }
#line 142
  if (tmp___1 < 0) {
    {
#line 143
    tmp = __errno_location();
#line 143
    tmp___0 = strerror(*tmp);
#line 143
    daemon_log(3, "sigemptyset() failed: %s", tmp___0);
    }
#line 144
    return (-1);
  }
  {
#line 147
  tmp___4 = sigaddset(& ss_new, 17);
  }
#line 147
  if (tmp___4 < 0) {
    {
#line 148
    tmp___2 = __errno_location();
#line 148
    tmp___3 = strerror(*tmp___2);
#line 148
    daemon_log(3, "sigaddset() failed: %s", tmp___3);
    }
#line 149
    return (-1);
  }
  {
#line 152
  tmp___7 = sigaction(17, (struct sigaction  const  */* __restrict  */)(& sa_new),
                      (struct sigaction */* __restrict  */)(& sa_old));
  }
#line 152
  if (tmp___7 < 0) {
    {
#line 153
    tmp___5 = __errno_location();
#line 153
    tmp___6 = strerror(*tmp___5);
#line 153
    daemon_log(3, "sigaction() failed: %s", tmp___6);
    }
#line 154
    return (-1);
  }
  {
#line 157
  tmp___12 = sigprocmask(1, (sigset_t const   */* __restrict  */)(& ss_new), (sigset_t */* __restrict  */)(& ss_old));
  }
#line 157
  if (tmp___12 < 0) {
    {
#line 158
    tmp___8 = __errno_location();
#line 158
    tmp___9 = strerror(*tmp___8);
#line 158
    daemon_log(3, "sigprocmask() failed: %s", tmp___9);
#line 160
    tmp___10 = __errno_location();
#line 160
    saved_errno = *tmp___10;
#line 161
    sigaction(17, (struct sigaction  const  */* __restrict  */)(& sa_old), (struct sigaction */* __restrict  */)((void *)0));
#line 162
    tmp___11 = __errno_location();
#line 162
    *tmp___11 = saved_errno;
    }
#line 164
    return (-1);
  }
  {
#line 167
  tmp___17 = pipe((int *)(pipe_fds));
  }
#line 167
  if (tmp___17 < 0) {
    {
#line 168
    tmp___13 = __errno_location();
#line 168
    tmp___14 = strerror(*tmp___13);
#line 168
    daemon_log(3, "pipe() failed: %s", tmp___14);
#line 170
    tmp___15 = __errno_location();
#line 170
    saved_errno = *tmp___15;
#line 171
    sigaction(17, (struct sigaction  const  */* __restrict  */)(& sa_old), (struct sigaction */* __restrict  */)((void *)0));
#line 172
    sigprocmask(2, (sigset_t const   */* __restrict  */)(& ss_old), (sigset_t */* __restrict  */)((void *)0));
#line 173
    tmp___16 = __errno_location();
#line 173
    *tmp___16 = saved_errno;
    }
#line 175
    return (-1);
  }
  {
#line 178
  pid = fork();
  }
#line 178
  if (pid < 0) {
    {
#line 179
    tmp___18 = __errno_location();
#line 179
    tmp___19 = strerror(*tmp___18);
#line 179
    daemon_log(3, "First fork() failed: %s", tmp___19);
#line 181
    tmp___20 = __errno_location();
#line 181
    saved_errno = *tmp___20;
#line 182
    close(pipe_fds[0]);
#line 183
    close(pipe_fds[1]);
#line 184
    sigaction(17, (struct sigaction  const  */* __restrict  */)(& sa_old), (struct sigaction */* __restrict  */)((void *)0));
#line 185
    sigprocmask(2, (sigset_t const   */* __restrict  */)(& ss_old), (sigset_t */* __restrict  */)((void *)0));
#line 186
    tmp___21 = __errno_location();
#line 186
    *tmp___21 = saved_errno;
    }
#line 188
    return (-1);
  } else
#line 190
  if (pid == 0) {
#line 197
    if ((unsigned int )daemon_log_use & 8U) {
#line 198
      daemon_log_use = (enum daemon_log_flags )1;
    }
    {
#line 200
    tmp___24 = close(pipe_fds[0]);
    }
#line 200
    if (tmp___24 < 0) {
      {
#line 201
      tmp___22 = __errno_location();
#line 201
      tmp___23 = strerror(*tmp___22);
#line 201
      daemon_log(3, "close() failed: %s", tmp___23);
      }
#line 202
      goto fail;
    }
    {
#line 206
    tmp___25 = move_fd_up(& pipe_fds[1]);
    }
#line 206
    if (tmp___25 < 0) {
#line 207
      goto fail;
    }
#line 209
    if (_daemon_retval_pipe[0] >= 0) {
      {
#line 209
      tmp___26 = move_fd_up(& _daemon_retval_pipe[0]);
      }
#line 209
      if (tmp___26 < 0) {
#line 210
        goto fail;
      }
    }
#line 211
    if (_daemon_retval_pipe[1] >= 0) {
      {
#line 211
      tmp___27 = move_fd_up(& _daemon_retval_pipe[1]);
      }
#line 211
      if (tmp___27 < 0) {
#line 212
        goto fail;
      }
    }
    {
#line 214
    tmp___30 = _null_open(0, 0);
    }
#line 214
    if (tmp___30 < 0) {
      {
#line 215
      tmp___28 = __errno_location();
#line 215
      tmp___29 = strerror(*tmp___28);
#line 215
      daemon_log(3, "Failed to open /dev/null for STDIN: %s", tmp___29);
      }
#line 216
      goto fail;
    }
    {
#line 219
    tmp___33 = _null_open(1, 1);
    }
#line 219
    if (tmp___33 < 0) {
      {
#line 220
      tmp___31 = __errno_location();
#line 220
      tmp___32 = strerror(*tmp___31);
#line 220
      daemon_log(3, "Failed to open /dev/null for STDOUT: %s", tmp___32);
      }
#line 221
      goto fail;
    }
    {
#line 224
    tmp___36 = _null_open(1, 2);
    }
#line 224
    if (tmp___36 < 0) {
      {
#line 225
      tmp___34 = __errno_location();
#line 225
      tmp___35 = strerror(*tmp___34);
#line 225
      daemon_log(3, "Failed to open /dev/null for STDERR: %s", tmp___35);
      }
#line 226
      goto fail;
    }
    {
#line 233
    tmp___39 = setsid();
    }
#line 233
    if (tmp___39 < 0) {
      {
#line 234
      tmp___37 = __errno_location();
#line 234
      tmp___38 = strerror(*tmp___37);
#line 234
      daemon_log(3, "setsid() failed: %s", tmp___38);
      }
#line 235
      goto fail;
    }
    {
#line 238
    umask((__mode_t )63);
#line 240
    tmp___42 = chdir("/");
    }
#line 240
    if (tmp___42 < 0) {
      {
#line 241
      tmp___40 = __errno_location();
#line 241
      tmp___41 = strerror(*tmp___40);
#line 241
      daemon_log(3, "chdir() failed: %s", tmp___41);
      }
#line 242
      goto fail;
    }
    {
#line 245
    pid = fork();
    }
#line 245
    if (pid < 0) {
      {
#line 246
      tmp___43 = __errno_location();
#line 246
      tmp___44 = strerror(*tmp___43);
#line 246
      daemon_log(3, "Second fork() failed: %s", tmp___44);
      }
#line 247
      goto fail;
    } else
#line 249
    if (pid == 0) {
      {
#line 257
      tmp___47 = sigaction(17, (struct sigaction  const  */* __restrict  */)(& sa_old),
                           (struct sigaction */* __restrict  */)((void *)0));
      }
#line 257
      if (tmp___47 < 0) {
        {
#line 258
        tmp___45 = __errno_location();
#line 258
        tmp___46 = strerror(*tmp___45);
#line 258
        daemon_log(3, "close() failed: %s", tmp___46);
        }
#line 259
        goto fail;
      }
      {
#line 262
      tmp___50 = sigprocmask(2, (sigset_t const   */* __restrict  */)(& ss_old), (sigset_t */* __restrict  */)((void *)0));
      }
#line 262
      if (tmp___50 < 0) {
        {
#line 263
        tmp___48 = __errno_location();
#line 263
        tmp___49 = strerror(*tmp___48);
#line 263
        daemon_log(3, "sigprocmask() failed: %s", tmp___49);
        }
#line 264
        goto fail;
      }
      {
#line 267
      tmp___53 = signal(22, (void (*)(int  ))1);
      }
#line 267
      if ((unsigned long )tmp___53 == (unsigned long )((void (*)(int  ))-1)) {
        {
#line 268
        tmp___51 = __errno_location();
#line 268
        tmp___52 = strerror(*tmp___51);
#line 268
        daemon_log(3, "signal(SIGTTOU, SIG_IGN) failed: %s", tmp___52);
        }
#line 269
        goto fail;
      }
      {
#line 272
      tmp___56 = signal(21, (void (*)(int  ))1);
      }
#line 272
      if ((unsigned long )tmp___56 == (unsigned long )((void (*)(int  ))-1)) {
        {
#line 273
        tmp___54 = __errno_location();
#line 273
        tmp___55 = strerror(*tmp___54);
#line 273
        daemon_log(3, "signal(SIGTTIN, SIG_IGN) failed: %s", tmp___55);
        }
#line 274
        goto fail;
      }
      {
#line 277
      tmp___59 = signal(20, (void (*)(int  ))1);
      }
#line 277
      if ((unsigned long )tmp___59 == (unsigned long )((void (*)(int  ))-1)) {
        {
#line 278
        tmp___57 = __errno_location();
#line 278
        tmp___58 = strerror(*tmp___57);
#line 278
        daemon_log(3, "signal(SIGTSTP, SIG_IGN) failed: %s", tmp___58);
        }
#line 279
        goto fail;
      }
      {
#line 282
      dpid = getpid();
#line 283
      tmp___62 = atomic_write(pipe_fds[1], (void const   *)(& dpid), sizeof(dpid));
      }
#line 283
      if ((unsigned long )tmp___62 != sizeof(dpid)) {
        {
#line 284
        tmp___60 = __errno_location();
#line 284
        tmp___61 = strerror(*tmp___60);
#line 284
        daemon_log(3, "write() failed: %s", tmp___61);
        }
#line 285
        goto fail;
      }
      {
#line 288
      tmp___65 = close(pipe_fds[1]);
      }
#line 288
      if (tmp___65 < 0) {
        {
#line 289
        tmp___63 = __errno_location();
#line 289
        tmp___64 = strerror(*tmp___63);
#line 289
        daemon_log(3, "close() failed: %s", tmp___64);
        }
#line 290
        goto fail;
      }
#line 293
      return (0);
    } else {
      {
#line 297
      close(pipe_fds[1]);
#line 298
      _exit(0);
      }
    }
    fail: 
    {
#line 302
    dpid = -1;
#line 304
    tmp___68 = atomic_write(pipe_fds[1], (void const   *)(& dpid), sizeof(dpid));
    }
#line 304
    if ((unsigned long )tmp___68 != sizeof(dpid)) {
      {
#line 305
      tmp___66 = __errno_location();
#line 305
      tmp___67 = strerror(*tmp___66);
#line 305
      daemon_log(3, "Failed to write error PID: %s", tmp___67);
      }
    }
    {
#line 307
    close(pipe_fds[1]);
#line 308
    _exit(0);
    }
  } else {
    {
#line 314
    close(pipe_fds[1]);
#line 316
    tmp___71 = waitpid(pid, (int *)((void *)0), 2);
    }
#line 316
    if (tmp___71 < 0) {
      {
#line 317
      tmp___69 = __errno_location();
#line 317
      saved_errno = *tmp___69;
#line 318
      close(pipe_fds[0]);
#line 319
      sigaction(17, (struct sigaction  const  */* __restrict  */)(& sa_old), (struct sigaction */* __restrict  */)((void *)0));
#line 320
      sigprocmask(2, (sigset_t const   */* __restrict  */)(& ss_old), (sigset_t */* __restrict  */)((void *)0));
#line 321
      tmp___70 = __errno_location();
#line 321
      *tmp___70 = saved_errno;
      }
#line 322
      return (-1);
    }
    {
#line 325
    sigprocmask(2, (sigset_t const   */* __restrict  */)(& ss_old), (sigset_t */* __restrict  */)((void *)0));
#line 326
    sigaction(17, (struct sigaction  const  */* __restrict  */)(& sa_old), (struct sigaction */* __restrict  */)((void *)0));
#line 328
    tmp___74 = atomic_read(pipe_fds[0], (void *)(& dpid___0), sizeof(dpid___0));
    }
#line 328
    if ((unsigned long )tmp___74 != sizeof(dpid___0)) {
      {
#line 329
      daemon_log(3, "Failed to read daemon PID.");
#line 330
      dpid___0 = -1;
#line 331
      tmp___72 = __errno_location();
#line 331
      *tmp___72 = 22;
      }
    } else
#line 332
    if (dpid___0 == -1) {
      {
#line 333
      tmp___73 = __errno_location();
#line 333
      *tmp___73 = 5;
      }
    }
    {
#line 335
    tmp___75 = __errno_location();
#line 335
    saved_errno = *tmp___75;
#line 336
    close(pipe_fds[0]);
#line 337
    tmp___76 = __errno_location();
#line 337
    *tmp___76 = saved_errno;
    }
#line 339
    return (dpid___0);
  }
}
}
#line 343 "/home/june/repo/benchmarks/collector/temp/libdaemon-0.14/libdaemon/dfork.c"
int daemon_retval_init(void) 
{ 
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 345
  if (_daemon_retval_pipe[0] < 0) {
#line 345
    goto _L;
  } else
#line 345
  if (_daemon_retval_pipe[1] < 0) {
    _L: /* CIL Label */ 
    {
#line 347
    tmp___1 = pipe((int *)(_daemon_retval_pipe));
    }
#line 347
    if (tmp___1 < 0) {
      {
#line 348
      tmp = __errno_location();
#line 348
      tmp___0 = strerror(*tmp);
#line 348
      daemon_log(3, "pipe(): %s", tmp___0);
      }
#line 349
      return (-1);
    }
  }
#line 353
  return (0);
}
}
#line 356 "/home/june/repo/benchmarks/collector/temp/libdaemon-0.14/libdaemon/dfork.c"
void daemon_retval_done(void) 
{ 
  int saved_errno ;
  int *tmp ;
  int *tmp___0 ;

  {
  {
#line 357
  tmp = __errno_location();
#line 357
  saved_errno = *tmp;
  }
#line 359
  if (_daemon_retval_pipe[0] >= 0) {
    {
#line 360
    close(_daemon_retval_pipe[0]);
    }
  }
#line 362
  if (_daemon_retval_pipe[1] >= 0) {
    {
#line 363
    close(_daemon_retval_pipe[1]);
    }
  }
  {
#line 365
  _daemon_retval_pipe[1] = -1;
#line 365
  _daemon_retval_pipe[0] = _daemon_retval_pipe[1];
#line 367
  tmp___0 = __errno_location();
#line 367
  *tmp___0 = saved_errno;
  }
#line 368
  return;
}
}
#line 370 "/home/june/repo/benchmarks/collector/temp/libdaemon-0.14/libdaemon/dfork.c"
int daemon_retval_send(int i ) 
{ 
  ssize_t r ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;

  {
#line 373
  if (_daemon_retval_pipe[1] < 0) {
    {
#line 374
    tmp = __errno_location();
#line 374
    *tmp = 22;
    }
#line 375
    return (-1);
  }
  {
#line 378
  r = atomic_write(_daemon_retval_pipe[1], (void const   *)(& i), sizeof(i));
#line 380
  daemon_retval_done();
  }
#line 382
  if ((unsigned long )r != sizeof(i)) {
#line 384
    if (r < 0L) {
      {
#line 385
      tmp___0 = __errno_location();
#line 385
      tmp___1 = strerror(*tmp___0);
#line 385
      daemon_log(3, "write() failed while writing return value to pipe: %s", tmp___1);
      }
    } else {
      {
#line 387
      daemon_log(3, "write() too short while writing return value from pipe");
#line 388
      tmp___2 = __errno_location();
#line 388
      *tmp___2 = 22;
      }
    }
#line 391
    return (-1);
  }
#line 394
  return (0);
}
}
#line 397 "/home/june/repo/benchmarks/collector/temp/libdaemon-0.14/libdaemon/dfork.c"
int daemon_retval_wait(int timeout ) 
{ 
  ssize_t r ;
  int i ;
  struct timeval tv ;
  int s ;
  fd_set fds ;
  int __d0 ;
  int __d1 ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;

  {
#line 401
  if (timeout > 0) {
#line 406
    tv.tv_sec = (__time_t )timeout;
#line 407
    tv.tv_usec = (__suseconds_t )0;
    {
#line 409
    while (1) {
      while_continue: /* CIL Label */ ;
#line 409
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& fds.fds_bits[0]): "memory");
#line 409
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 410
    fds.fds_bits[_daemon_retval_pipe[0] / (8 * (int )sizeof(__fd_mask ))] |= 1L << _daemon_retval_pipe[0] % (8 * (int )sizeof(__fd_mask ));
#line 412
    s = select(1024, (fd_set */* __restrict  */)(& fds), (fd_set */* __restrict  */)0,
               (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)(& tv));
    }
#line 412
    if (s != 1) {
#line 414
      if (s < 0) {
        {
#line 415
        tmp = __errno_location();
#line 415
        tmp___0 = strerror(*tmp);
#line 415
        daemon_log(3, "select() failed while waiting for return value: %s", tmp___0);
        }
      } else {
        {
#line 417
        tmp___1 = __errno_location();
#line 417
        *tmp___1 = 110;
#line 418
        daemon_log(3, "Timeout reached while wating for return value");
        }
      }
#line 421
      return (-1);
    }
  }
  {
#line 425
  r = atomic_read(_daemon_retval_pipe[0], (void *)(& i), sizeof(i));
  }
#line 425
  if ((unsigned long )r != sizeof(i)) {
#line 427
    if (r < 0L) {
      {
#line 428
      tmp___2 = __errno_location();
#line 428
      tmp___3 = strerror(*tmp___2);
#line 428
      daemon_log(3, "read() failed while reading return value from pipe: %s", tmp___3);
      }
    } else
#line 429
    if (r == 0L) {
      {
#line 430
      daemon_log(3, "read() failed with EOF while reading return value from pipe.");
#line 431
      tmp___4 = __errno_location();
#line 431
      *tmp___4 = 22;
      }
    } else
#line 432
    if (r > 0L) {
      {
#line 433
      daemon_log(3, "read() too short while reading return value from pipe.");
#line 434
      tmp___5 = __errno_location();
#line 434
      *tmp___5 = 22;
      }
    }
#line 437
    return (-1);
  }
  {
#line 440
  daemon_retval_done();
  }
#line 442
  return (i);
}
}
#line 445 "/home/june/repo/benchmarks/collector/temp/libdaemon-0.14/libdaemon/dfork.c"
int daemon_close_all(int except_fd  , ...) 
{ 
  va_list ap ;
  int n ;
  int i ;
  int r ;
  int *p ;
  int saved_errno ;
  int tmp___0 ;
  void *tmp___1 ;
  int fd ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;

  {
  {
#line 447
  n = 0;
#line 451
  __builtin_va_start(ap, except_fd);
  }
#line 453
  if (except_fd >= 0) {
#line 454
    n = 1;
    {
#line 454
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 454
      tmp___0 = __builtin_va_arg(ap, int );
      }
#line 454
      if (! (tmp___0 >= 0)) {
#line 454
        goto while_break;
      }
#line 454
      n ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 457
  __builtin_va_end(ap);
#line 459
  tmp___1 = malloc(sizeof(int ) * (unsigned long )(n + 1));
#line 459
  p = (int *)tmp___1;
  }
#line 459
  if (! p) {
#line 460
    return (-1);
  }
  {
#line 462
  __builtin_va_start(ap, except_fd);
#line 464
  i = 0;
  }
#line 465
  if (except_fd >= 0) {
#line 467
    tmp___2 = i;
#line 467
    i ++;
#line 467
    *(p + tmp___2) = except_fd;
    {
#line 469
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 469
      tmp___4 = __builtin_va_arg(ap, int );
#line 469
      fd = tmp___4;
      }
#line 469
      if (! (fd >= 0)) {
#line 469
        goto while_break___0;
      }
#line 470
      tmp___3 = i;
#line 470
      i ++;
#line 470
      *(p + tmp___3) = fd;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 472
  *(p + i) = -1;
#line 474
  __builtin_va_end(ap);
#line 476
  r = daemon_close_allv((int const   *)p);
#line 478
  tmp___5 = __errno_location();
#line 478
  saved_errno = *tmp___5;
#line 479
  free((void *)p);
#line 480
  tmp___6 = __errno_location();
#line 480
  *tmp___6 = saved_errno;
  }
#line 482
  return (r);
}
}
#line 486 "/home/june/repo/benchmarks/collector/temp/libdaemon-0.14/libdaemon/dfork.c"
int daemon_close_allv(int const   *except_fds ) 
{ 
  struct rlimit rl ;
  int fd ;
  int maxfd ;
  int saved_errno ;
  DIR *d ;
  struct dirent *de ;
  int found ;
  long l ;
  char *e ;
  int i ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  long tmp___7 ;
  int tmp___8 ;
  int i___0 ;
  int found___0 ;
  int tmp___9 ;
  int *tmp___10 ;

  {
  {
#line 495
  d = opendir("/proc/self/fd");
  }
#line 495
  if (d) {
    {
#line 499
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 499
      de = readdir(d);
      }
#line 499
      if (! de) {
#line 499
        goto while_break;
      }
#line 502
      e = (char *)((void *)0);
#line 505
      if ((int )de->d_name[0] == 46) {
#line 506
        goto while_continue;
      }
      {
#line 508
      tmp = __errno_location();
#line 508
      *tmp = 0;
#line 509
      l = strtol((char const   */* __restrict  */)(de->d_name), (char **/* __restrict  */)(& e),
                 10);
#line 510
      tmp___1 = __errno_location();
      }
#line 510
      if (*tmp___1 != 0) {
        {
#line 511
        closedir(d);
#line 512
        tmp___0 = __errno_location();
#line 512
        *tmp___0 = 22;
        }
#line 513
        return (-1);
      } else
#line 510
      if (! e) {
        {
#line 511
        closedir(d);
#line 512
        tmp___0 = __errno_location();
#line 512
        *tmp___0 = 22;
        }
#line 513
        return (-1);
      } else
#line 510
      if (*e) {
        {
#line 511
        closedir(d);
#line 512
        tmp___0 = __errno_location();
#line 512
        *tmp___0 = 22;
        }
#line 513
        return (-1);
      }
#line 516
      fd = (int )l;
#line 518
      if ((long )fd != l) {
        {
#line 519
        closedir(d);
#line 520
        tmp___2 = __errno_location();
#line 520
        *tmp___2 = 22;
        }
#line 521
        return (-1);
      }
#line 524
      if (fd < 3) {
#line 525
        goto while_continue;
      }
      {
#line 527
      tmp___3 = dirfd(d);
      }
#line 527
      if (fd == tmp___3) {
#line 528
        goto while_continue;
      }
#line 530
      if (fd == _daemon_retval_pipe[1]) {
#line 531
        goto while_continue;
      }
#line 533
      found = 0;
#line 534
      i = 0;
      {
#line 534
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 534
        if (! (*(except_fds + i) >= 0)) {
#line 534
          goto while_break___0;
        }
#line 535
        if (*(except_fds + i) == (int const   )fd) {
#line 536
          found = 1;
#line 537
          goto while_break___0;
        }
#line 534
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 540
      if (found) {
#line 541
        goto while_continue;
      }
      {
#line 543
      tmp___6 = close(fd);
      }
#line 543
      if (tmp___6 < 0) {
        {
#line 544
        tmp___4 = __errno_location();
#line 544
        saved_errno = *tmp___4;
#line 545
        closedir(d);
#line 546
        tmp___5 = __errno_location();
#line 546
        *tmp___5 = saved_errno;
        }
#line 548
        return (-1);
      }
#line 551
      if (fd == _daemon_retval_pipe[0]) {
#line 552
        _daemon_retval_pipe[0] = -1;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 555
    closedir(d);
    }
#line 556
    return (0);
  }
  {
#line 561
  tmp___8 = getrlimit((__rlimit_resource_t )7, & rl);
  }
#line 561
  if (tmp___8 > 0) {
#line 562
    maxfd = (int )rl.rlim_max;
  } else {
    {
#line 564
    tmp___7 = sysconf(4);
#line 564
    maxfd = (int )tmp___7;
    }
  }
#line 566
  fd = 3;
  {
#line 566
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 566
    if (! (fd < maxfd)) {
#line 566
      goto while_break___1;
    }
#line 569
    if (fd == _daemon_retval_pipe[1]) {
#line 570
      goto __Cont;
    }
#line 572
    found___0 = 0;
#line 573
    i___0 = 0;
    {
#line 573
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 573
      if (! (*(except_fds + i___0) >= 0)) {
#line 573
        goto while_break___2;
      }
#line 574
      if (*(except_fds + i___0) == (int const   )fd) {
#line 575
        found___0 = 1;
#line 576
        goto while_break___2;
      }
#line 573
      i___0 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 579
    if (found___0) {
#line 580
      goto __Cont;
    }
    {
#line 582
    tmp___9 = close(fd);
    }
#line 582
    if (tmp___9 < 0) {
      {
#line 582
      tmp___10 = __errno_location();
      }
#line 582
      if (*tmp___10 != 9) {
#line 583
        return (-1);
      }
    }
#line 585
    if (fd == _daemon_retval_pipe[0]) {
#line 586
      _daemon_retval_pipe[0] = -1;
    }
    __Cont: /* CIL Label */ 
#line 566
    fd ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 589
  return (0);
}
}
#line 592 "/home/june/repo/benchmarks/collector/temp/libdaemon-0.14/libdaemon/dfork.c"
int daemon_unblock_sigs(int except  , ...) 
{ 
  va_list ap ;
  int n ;
  int i ;
  int r ;
  int *p ;
  int saved_errno ;
  int tmp___0 ;
  void *tmp___1 ;
  int sig ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;

  {
  {
#line 594
  n = 0;
#line 598
  __builtin_va_start(ap, except);
  }
#line 600
  if (except >= 1) {
#line 601
    n = 1;
    {
#line 601
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 601
      tmp___0 = __builtin_va_arg(ap, int );
      }
#line 601
      if (! (tmp___0 >= 0)) {
#line 601
        goto while_break;
      }
#line 601
      n ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 604
  __builtin_va_end(ap);
#line 606
  tmp___1 = malloc(sizeof(int ) * (unsigned long )(n + 1));
#line 606
  p = (int *)tmp___1;
  }
#line 606
  if (! p) {
#line 607
    return (-1);
  }
  {
#line 609
  __builtin_va_start(ap, except);
#line 611
  i = 0;
  }
#line 612
  if (except >= 1) {
#line 614
    tmp___2 = i;
#line 614
    i ++;
#line 614
    *(p + tmp___2) = except;
    {
#line 616
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 616
      tmp___4 = __builtin_va_arg(ap, int );
#line 616
      sig = tmp___4;
      }
#line 616
      if (! (sig >= 0)) {
#line 616
        goto while_break___0;
      }
#line 617
      tmp___3 = i;
#line 617
      i ++;
#line 617
      *(p + tmp___3) = sig;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 619
  *(p + i) = -1;
#line 621
  __builtin_va_end(ap);
#line 623
  r = daemon_unblock_sigsv((int const   *)p);
#line 625
  tmp___5 = __errno_location();
#line 625
  saved_errno = *tmp___5;
#line 626
  free((void *)p);
#line 627
  tmp___6 = __errno_location();
#line 627
  *tmp___6 = saved_errno;
  }
#line 629
  return (r);
}
}
#line 632 "/home/june/repo/benchmarks/collector/temp/libdaemon-0.14/libdaemon/dfork.c"
int daemon_unblock_sigsv(int const   *except ) 
{ 
  int i ;
  sigset_t ss ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 636
  tmp = sigemptyset(& ss);
  }
#line 636
  if (tmp < 0) {
#line 637
    return (-1);
  }
#line 639
  i = 0;
  {
#line 639
  while (1) {
    while_continue: /* CIL Label */ ;
#line 639
    if (! (*(except + i) > 0)) {
#line 639
      goto while_break;
    }
    {
#line 640
    tmp___0 = sigaddset(& ss, (int )*(except + i));
    }
#line 640
    if (tmp___0 < 0) {
#line 641
      return (-1);
    }
#line 639
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 643
  tmp___1 = sigprocmask(2, (sigset_t const   */* __restrict  */)(& ss), (sigset_t */* __restrict  */)((void *)0));
  }
#line 643
  return (tmp___1);
}
}
#line 646 "/home/june/repo/benchmarks/collector/temp/libdaemon-0.14/libdaemon/dfork.c"
int daemon_reset_sigs(int except  , ...) 
{ 
  va_list ap ;
  int n ;
  int i ;
  int r ;
  int *p ;
  int saved_errno ;
  int tmp___0 ;
  void *tmp___1 ;
  int sig ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;

  {
  {
#line 648
  n = 0;
#line 652
  __builtin_va_start(ap, except);
  }
#line 654
  if (except >= 1) {
#line 655
    n = 1;
    {
#line 655
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 655
      tmp___0 = __builtin_va_arg(ap, int );
      }
#line 655
      if (! (tmp___0 >= 0)) {
#line 655
        goto while_break;
      }
#line 655
      n ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 658
  __builtin_va_end(ap);
#line 660
  tmp___1 = malloc(sizeof(int ) * (unsigned long )(n + 1));
#line 660
  p = (int *)tmp___1;
  }
#line 660
  if (! p) {
#line 661
    return (-1);
  }
  {
#line 663
  __builtin_va_start(ap, except);
#line 665
  i = 0;
  }
#line 666
  if (except >= 1) {
#line 668
    tmp___2 = i;
#line 668
    i ++;
#line 668
    *(p + tmp___2) = except;
    {
#line 670
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 670
      tmp___4 = __builtin_va_arg(ap, int );
#line 670
      sig = tmp___4;
      }
#line 670
      if (! (sig >= 0)) {
#line 670
        goto while_break___0;
      }
#line 671
      tmp___3 = i;
#line 671
      i ++;
#line 671
      *(p + tmp___3) = sig;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 673
  *(p + i) = -1;
#line 675
  __builtin_va_end(ap);
#line 677
  r = daemon_reset_sigsv((int const   *)p);
#line 679
  tmp___5 = __errno_location();
#line 679
  saved_errno = *tmp___5;
#line 680
  free((void *)p);
#line 681
  tmp___6 = __errno_location();
#line 681
  *tmp___6 = saved_errno;
  }
#line 683
  return (r);
}
}
#line 686 "/home/june/repo/benchmarks/collector/temp/libdaemon-0.14/libdaemon/dfork.c"
int daemon_reset_sigsv(int const   *except ) 
{ 
  int sig ;
  int reset ;
  int i ;
  struct sigaction sa ;
  int *tmp ;
  int tmp___0 ;

  {
#line 689
  sig = 1;
  {
#line 689
  while (1) {
    while_continue: /* CIL Label */ ;
#line 689
    if (! (sig < 65)) {
#line 689
      goto while_break;
    }
#line 690
    reset = 1;
    {
#line 694
    if (sig == 19) {
#line 694
      goto case_19;
    }
#line 694
    if (sig == 9) {
#line 694
      goto case_19;
    }
#line 698
    goto switch_default;
    case_19: /* CIL Label */ 
    case_9: /* CIL Label */ 
#line 695
    reset = 0;
#line 696
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 701
    i = 0;
    {
#line 701
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 701
      if (! (*(except + i) > 0)) {
#line 701
        goto while_break___0;
      }
#line 702
      if (sig == (int )*(except + i)) {
#line 703
        reset = 0;
#line 704
        goto while_break___0;
      }
#line 701
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    switch_break: /* CIL Label */ ;
    }
#line 710
    if (reset) {
      {
#line 713
      memset((void *)(& sa), 0, sizeof(sa));
#line 714
      sa.__sigaction_handler.sa_handler = (void (*)(int  ))0;
#line 718
      tmp___0 = sigaction(sig, (struct sigaction  const  */* __restrict  */)(& sa),
                          (struct sigaction */* __restrict  */)((void *)0));
      }
#line 718
      if (tmp___0 < 0) {
        {
#line 719
        tmp = __errno_location();
        }
#line 719
        if (*tmp != 22) {
#line 720
          return (-1);
        }
      }
    }
#line 689
    sig ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 724
  return (0);
}
}
#line 29 "/home/june/repo/benchmarks/collector/temp/libdaemon-0.14/libdaemon/dnonblock.c"
int daemon_nonblock(int fd , int b ) 
{ 
  int a ;
  int c ;
  int tmp ;

  {
  {
#line 32
  a = fcntl(fd, 3);
  }
#line 32
  if (a < 0) {
#line 33
    return (-1);
  }
#line 35
  if (b) {
#line 36
    c = a | 2048;
  } else {
#line 38
    c = a & -2049;
  }
#line 40
  if (c == a) {
#line 41
    return (0);
  }
  {
#line 43
  tmp = fcntl(fd, 4, c);
  }
#line 43
  return (tmp);
}
}
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/libdaemon-0.14/examples/testd.c"
int main(int argc , char **argv ) 
{ 
  pid_t pid ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  int ret ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int ret___0 ;
  int *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  int fd ;
  int quit ;
  fd_set fds ;
  int *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  int *tmp___17 ;
  char *tmp___18 ;
  int tmp___19 ;
  int *tmp___20 ;
  char *tmp___21 ;
  int tmp___22 ;
  int __d0 ;
  int __d1 ;
  fd_set fds2 ;
  int *tmp___23 ;
  int *tmp___24 ;
  char *tmp___25 ;
  int tmp___26 ;
  int sig ;
  int *tmp___27 ;
  char *tmp___28 ;

  {
  {
#line 39
  tmp___1 = daemon_reset_sigs(-1);
  }
#line 39
  if (tmp___1 < 0) {
    {
#line 40
    tmp = __errno_location();
#line 40
    tmp___0 = strerror(*tmp);
#line 40
    daemon_log(3, "Failed to reset all signal handlers: %s", tmp___0);
    }
#line 41
    return (1);
  }
  {
#line 45
  tmp___4 = daemon_unblock_sigs(-1);
  }
#line 45
  if (tmp___4 < 0) {
    {
#line 46
    tmp___2 = __errno_location();
#line 46
    tmp___3 = strerror(*tmp___2);
#line 46
    daemon_log(3, "Failed to unblock all signals: %s", tmp___3);
    }
#line 47
    return (1);
  }
  {
#line 51
  tmp___5 = daemon_ident_from_argv0(*(argv + 0));
#line 51
  daemon_log_ident = (char const   *)tmp___5;
#line 51
  daemon_pid_file_ident = daemon_log_ident;
  }
#line 54
  if (argc >= 2) {
    {
#line 54
    tmp___9 = strcmp((char const   *)*(argv + 1), "-k");
    }
#line 54
    if (! tmp___9) {
      {
#line 60
      ret = daemon_pid_file_kill_wait(15, 5);
      }
#line 60
      if (ret < 0) {
        {
#line 61
        tmp___6 = __errno_location();
#line 61
        tmp___7 = strerror(*tmp___6);
#line 61
        daemon_log(4, "Failed to kill daemon: %s", tmp___7);
        }
      }
#line 63
      if (ret < 0) {
#line 63
        tmp___8 = 1;
      } else {
#line 63
        tmp___8 = 0;
      }
#line 63
      return (tmp___8);
    }
  }
  {
#line 67
  pid = daemon_pid_file_is_running();
  }
#line 67
  if (pid >= 0) {
    {
#line 68
    daemon_log(3, "Daemon already running on PID file %u", pid);
    }
#line 69
    return (1);
  }
  {
#line 73
  tmp___10 = daemon_retval_init();
  }
#line 73
  if (tmp___10 < 0) {
    {
#line 74
    daemon_log(3, "Failed to create pipe.");
    }
#line 75
    return (1);
  }
  {
#line 79
  pid = daemon_fork();
  }
#line 79
  if (pid < 0) {
    {
#line 82
    daemon_retval_done();
    }
#line 83
    return (1);
  } else
#line 85
  if (pid) {
    {
#line 89
    ret___0 = daemon_retval_wait(20);
    }
#line 89
    if (ret___0 < 0) {
      {
#line 90
      tmp___11 = __errno_location();
#line 90
      tmp___12 = strerror(*tmp___11);
#line 90
      daemon_log(3, "Could not recieve return value from daemon process: %s", tmp___12);
      }
#line 91
      return (255);
    }
#line 94
    if (ret___0 != 0) {
#line 94
      tmp___13 = 3;
    } else {
#line 94
      tmp___13 = 6;
    }
    {
#line 94
    daemon_log(tmp___13, "Daemon returned %i as return value.", ret___0);
    }
#line 95
    return (ret___0);
  } else {
    {
#line 98
    quit = 0;
#line 102
    tmp___16 = daemon_close_all(-1);
    }
#line 102
    if (tmp___16 < 0) {
      {
#line 103
      tmp___14 = __errno_location();
#line 103
      tmp___15 = strerror(*tmp___14);
#line 103
      daemon_log(3, "Failed to close all file descriptors: %s", tmp___15);
#line 106
      daemon_retval_send(1);
      }
#line 107
      goto finish;
    }
    {
#line 111
    tmp___19 = daemon_pid_file_create();
    }
#line 111
    if (tmp___19 < 0) {
      {
#line 112
      tmp___17 = __errno_location();
#line 112
      tmp___18 = strerror(*tmp___17);
#line 112
      daemon_log(3, "Could not create PID file (%s).", tmp___18);
#line 113
      daemon_retval_send(2);
      }
#line 114
      goto finish;
    }
    {
#line 118
    tmp___22 = daemon_signal_init(2, 15, 3, 1, 0);
    }
#line 118
    if (tmp___22 < 0) {
      {
#line 119
      tmp___20 = __errno_location();
#line 119
      tmp___21 = strerror(*tmp___20);
#line 119
      daemon_log(3, "Could not register signal handlers (%s).", tmp___21);
#line 120
      daemon_retval_send(3);
      }
#line 121
      goto finish;
    }
    {
#line 128
    daemon_retval_send(0);
#line 130
    daemon_log(6, "Sucessfully started");
    }
    {
#line 133
    while (1) {
      while_continue: /* CIL Label */ ;
#line 133
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& fds.fds_bits[0]): "memory");
#line 133
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 134
    fd = daemon_signal_fd();
#line 135
    fds.fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << fd % (8 * (int )sizeof(__fd_mask ));
    }
    {
#line 137
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 137
      if (! (! quit)) {
#line 137
        goto while_break___0;
      }
      {
#line 138
      fds2 = fds;
#line 141
      tmp___26 = select(1024, (fd_set */* __restrict  */)(& fds2), (fd_set */* __restrict  */)0,
                        (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)0);
      }
#line 141
      if (tmp___26 < 0) {
        {
#line 144
        tmp___23 = __errno_location();
        }
#line 144
        if (*tmp___23 == 4) {
#line 145
          goto while_continue___0;
        }
        {
#line 147
        tmp___24 = __errno_location();
#line 147
        tmp___25 = strerror(*tmp___24);
#line 147
        daemon_log(3, "select(): %s", tmp___25);
        }
#line 148
        goto while_break___0;
      }
#line 152
      if ((fds2.fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] & (1L << fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 156
        sig = daemon_signal_next();
        }
#line 156
        if (sig <= 0) {
          {
#line 157
          tmp___27 = __errno_location();
#line 157
          tmp___28 = strerror(*tmp___27);
#line 157
          daemon_log(3, "daemon_signal_next() failed: %s", tmp___28);
          }
#line 158
          goto while_break___0;
        }
        {
#line 166
        if (sig == 15) {
#line 166
          goto case_15;
        }
#line 166
        if (sig == 3) {
#line 166
          goto case_15;
        }
#line 166
        if (sig == 2) {
#line 166
          goto case_15;
        }
#line 171
        if (sig == 1) {
#line 171
          goto case_1;
        }
#line 162
        goto switch_break;
        case_15: /* CIL Label */ 
        case_3: /* CIL Label */ 
        case_2: /* CIL Label */ 
        {
#line 167
        daemon_log(4, "Got SIGINT, SIGQUIT or SIGTERM.");
#line 168
        quit = 1;
        }
#line 169
        goto switch_break;
        case_1: /* CIL Label */ 
        {
#line 172
        daemon_log(6, "Got a HUP");
#line 173
        daemon_exec("/", (int *)((void *)0), "/bin/ls", "ls", (char *)((void *)0));
        }
#line 174
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    finish: 
    {
#line 182
    daemon_log(6, "Exiting...");
#line 183
    daemon_retval_send(255);
#line 184
    daemon_signal_done();
#line 185
    daemon_pid_file_remove();
    }
#line 187
    return (0);
  }
}
}
#line 50 "/home/june/repo/benchmarks/collector/temp/libdaemon-0.14/libdaemon/dexec.c"
static char buf___0[256]  ;
#line 35 "/home/june/repo/benchmarks/collector/temp/libdaemon-0.14/libdaemon/dlog.c"
static int daemon_verbosity_level___0  =    6;
#line 53 "/home/june/repo/benchmarks/collector/temp/libdaemon-0.14/libdaemon/dfork.c"
static int _daemon_retval_pipe___0[2]  = {      -1,      -1};
#line 55 "/home/june/repo/benchmarks/collector/temp/libdaemon-0.14/libdaemon/dfork.c"
static int _null_open___0(int f , int fd ) 
{ 
  int fd2 ;
  int tmp ;

  {
  {
#line 58
  fd2 = open("/dev/null", f);
  }
#line 58
  if (fd2 < 0) {
#line 59
    return (-1);
  }
#line 61
  if (fd2 == fd) {
#line 62
    return (fd);
  }
  {
#line 64
  tmp = dup2(fd2, fd);
  }
#line 64
  if (tmp < 0) {
#line 65
    return (-1);
  }
  {
#line 67
  close(fd2);
  }
#line 68
  return (fd);
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/libdaemon-0.14/libdaemon/dfork.c"
static ssize_t atomic_read___0(int fd , void *d , size_t l ) 
{ 
  ssize_t t ;
  ssize_t r ;
  ssize_t tmp ;

  {
#line 72
  t = (ssize_t )0;
  {
#line 74
  while (1) {
    while_continue: /* CIL Label */ ;
#line 74
    if (! (l > 0UL)) {
#line 74
      goto while_break;
    }
    {
#line 77
    r = read(fd, d, l);
    }
#line 77
    if (r <= 0L) {
#line 79
      if (r < 0L) {
#line 80
        if (t > 0L) {
#line 80
          tmp = t;
        } else {
#line 80
          tmp = (ssize_t )-1;
        }
#line 80
        return (tmp);
      } else {
#line 82
        return (t);
      }
    }
#line 85
    t += r;
#line 86
    d = (void *)((char *)d + r);
#line 87
    l -= (size_t )r;
  }
  while_break: /* CIL Label */ ;
  }
#line 90
  return (t);
}
}
#line 93 "/home/june/repo/benchmarks/collector/temp/libdaemon-0.14/libdaemon/dfork.c"
static ssize_t atomic_write___0(int fd , void const   *d , size_t l ) 
{ 
  ssize_t t ;
  ssize_t r ;
  ssize_t tmp ;

  {
#line 94
  t = (ssize_t )0;
  {
#line 96
  while (1) {
    while_continue: /* CIL Label */ ;
#line 96
    if (! (l > 0UL)) {
#line 96
      goto while_break;
    }
    {
#line 99
    r = write(fd, d, l);
    }
#line 99
    if (r <= 0L) {
#line 101
      if (r < 0L) {
#line 102
        if (t > 0L) {
#line 102
          tmp = t;
        } else {
#line 102
          tmp = (ssize_t )-1;
        }
#line 102
        return (tmp);
      } else {
#line 104
        return (t);
      }
    }
#line 107
    t += r;
#line 108
    d = (void const   *)((char const   *)d + r);
#line 109
    l -= (size_t )r;
  }
  while_break: /* CIL Label */ ;
  }
#line 112
  return (t);
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/libdaemon-0.14/libdaemon/dfork.c"
static int move_fd_up___0(int *fd ) 
{ 
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 116
  if (! fd) {
    {
#line 116
    __assert_fail("fd", "/home/june/repo/benchmarks/collector/temp/libdaemon-0.14/libdaemon/dfork.c",
                  116U, "move_fd_up");
    }
  }
  {
#line 118
  while (1) {
    while_continue: /* CIL Label */ ;
#line 118
    if (! (*fd <= 2)) {
#line 118
      goto while_break;
    }
    {
#line 119
    tmp___1 = dup(*fd);
#line 119
    *fd = tmp___1;
    }
#line 119
    if (tmp___1 < 0) {
      {
#line 120
      tmp = __errno_location();
#line 120
      tmp___0 = strerror(*tmp);
#line 120
      daemon_log(3, "dup(): %s", tmp___0);
      }
#line 121
      return (-1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 125
  return (0);
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/libdaemon-0.14/libdaemon/dfork.c"
static void sigchld___0(int s ) 
{ 


  {
#line 129
  return;
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/libdaemon-0.14/libdaemon/dpid.c"
static char *fn___0  =    (char *)((void *)0);
#line 69 "/home/june/repo/benchmarks/collector/temp/libdaemon-0.14/libdaemon/dpid.c"
static int lock_file___0(int fd , int enable ) 
{ 
  struct flock f ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 72
  memset((void *)(& f), 0, sizeof(f));
  }
#line 73
  if (enable) {
#line 73
    f.l_type = (short)1;
  } else {
#line 73
    f.l_type = (short)2;
  }
  {
#line 74
  f.l_whence = (short)0;
#line 75
  f.l_start = (__off_t )0;
#line 76
  f.l_len = (__off_t )0;
#line 78
  tmp___3 = fcntl(fd, 7, & f);
  }
#line 78
  if (tmp___3 < 0) {
#line 80
    if (enable) {
      {
#line 80
      tmp___0 = __errno_location();
      }
#line 80
      if (*tmp___0 == 9) {
        {
#line 81
        f.l_type = (short)0;
#line 83
        tmp = fcntl(fd, 7, & f);
        }
#line 83
        if (tmp >= 0) {
#line 84
          return (0);
        }
      }
    }
    {
#line 87
    tmp___1 = __errno_location();
#line 87
    tmp___2 = strerror(*tmp___1);
#line 87
    daemon_log(4, "fcntl(F_SETLKW) failed: %s", tmp___2);
    }
#line 88
    return (-1);
  }
#line 91
  return (0);
}
}
#line 96 "/home/june/repo/benchmarks/collector/temp/libdaemon-0.14/libdaemon/dpid.c"
static char txt___0[256]  ;
#line 36 "/home/june/repo/benchmarks/collector/temp/libdaemon-0.14/libdaemon/dsignal.c"
static int _signal_pipe___0[2]  = {      -1,      -1};
#line 38 "/home/june/repo/benchmarks/collector/temp/libdaemon-0.14/libdaemon/dsignal.c"
static void _sigfunc___0(int s ) 
{ 
  int saved_errno ;
  int *tmp ;
  int *tmp___0 ;

  {
  {
#line 39
  tmp = __errno_location();
#line 39
  saved_errno = *tmp;
#line 40
  write(_signal_pipe___0[1], (void const   *)(& s), sizeof(s));
#line 41
  tmp___0 = __errno_location();
#line 41
  *tmp___0 = saved_errno;
  }
#line 42
  return;
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/libdaemon-0.14/libdaemon/dsignal.c"
static int _init___0(void) 
{ 
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 46
  if (_signal_pipe___0[0] < 0) {
#line 46
    goto _L;
  } else
#line 46
  if (_signal_pipe___0[1] < 0) {
    _L: /* CIL Label */ 
    {
#line 47
    tmp___1 = pipe((int *)(_signal_pipe___0));
    }
#line 47
    if (tmp___1 < 0) {
      {
#line 48
      tmp = __errno_location();
#line 48
      tmp___0 = strerror(*tmp);
#line 48
      daemon_log(3, "pipe(): %s", tmp___0);
      }
#line 49
      return (-1);
    }
    {
#line 52
    tmp___2 = daemon_nonblock(_signal_pipe___0[0], 1);
    }
#line 52
    if (tmp___2 < 0) {
      {
#line 53
      daemon_signal_done();
      }
#line 54
      return (-1);
    } else {
      {
#line 52
      tmp___3 = daemon_nonblock(_signal_pipe___0[1], 1);
      }
#line 52
      if (tmp___3 < 0) {
        {
#line 53
        daemon_signal_done();
        }
#line 54
        return (-1);
      }
    }
  }
#line 58
  return (0);
}
}
