/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_3 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_3 fd_set;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 33 "/usr/include/x86_64-linux-gnu/bits/socket.h"
typedef __socklen_t socklen_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 29 "/usr/include/x86_64-linux-gnu/sys/un.h"
struct sockaddr_un {
   sa_family_t sun_family ;
   char sun_path[108] ;
};
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 46 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/sock_any.h"
union _sockaddr_any {
   struct sockaddr a ;
   struct sockaddr_un un ;
   struct sockaddr_in in ;
};
#line 46 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/sock_any.h"
struct sockaddr_any {
   union _sockaddr_any s ;
   size_t namelen ;
};
#line 44 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/smtppass.h"
struct spctx;
#line 65 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/smtppass.h"
struct spio {
   int fd ;
   char const   *name ;
   time_t last_action ;
   char peername[4096] ;
   char localname[4096] ;
   char line[4224] ;
   char *_nx ;
   size_t _ln ;
};
#line 65 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/smtppass.h"
typedef struct spio spio_t;
#line 121 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/smtppass.h"
struct spctx {
   unsigned int id ;
   spio_t client ;
   spio_t server ;
   FILE *cachefile ;
   char cachename[4096] ;
   char logline[768] ;
   char *sender ;
   char *recipients ;
   char *xforwardaddr ;
   char *xforwardhelo ;
   int _crlf ;
};
#line 121 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/smtppass.h"
typedef struct spctx spctx_t;
#line 44 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/sppriv.h"
struct spstate {
   int debug_level ;
   int max_threads ;
   struct timeval timeout ;
   int keepalives ;
   int transparent ;
   int xclient ;
   char const   *directory ;
   char const   *user ;
   char const   *pidfile ;
   char const   *header ;
   struct sockaddr_any outaddr ;
   char const   *outname ;
   struct sockaddr_any listenaddr ;
   char const   *listenname ;
   char const   *name ;
   int quit ;
   int daemonized ;
   char *_p ;
};
#line 44 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/sppriv.h"
typedef struct spstate spstate_t;
#line 567 "/usr/include/netdb.h"
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 80 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uid_t uid_t;
#line 60 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned long pthread_t;
#line 63 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
#line 69 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union pthread_attr_t pthread_attr_t;
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef struct __pthread_internal_list __pthread_list_t;
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_mutex_t_4 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutex_t_4 pthread_mutex_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_mutexattr_t_5 {
   char __size[4] ;
   int __align ;
};
#line 129 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutexattr_t_5 pthread_mutexattr_t;
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 76 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/smtppass.c"
struct spthread {
   pthread_t tid ;
   int fd ;
};
#line 76 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/smtppass.c"
typedef struct spthread spthread_t;
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 67 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/clamsmtpd.c"
struct clstate {
   struct sockaddr_any clamaddr ;
   char const   *clamname ;
   char const   *directory ;
   char const   *virusaction ;
   int action ;
   int quarantine ;
   int debug_files ;
   char const   *header ;
};
#line 67 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/clamsmtpd.c"
typedef struct clstate clstate_t;
#line 81 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/clamsmtpd.c"
struct clctx {
   spctx_t sp ;
   spio_t clam ;
};
#line 81 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/clamsmtpd.c"
typedef struct clctx clctx_t;
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getsockname)(int __fd ,
                                                                                  struct sockaddr * __restrict  __addr ,
                                                                                  socklen_t * __restrict  __len ) ;
#line 137
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 141
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getpeername)(int __fd ,
                                                                                  struct sockaddr * __restrict  __addr ,
                                                                                  socklen_t * __restrict  __len ) ;
#line 226
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void const   *__optval ,
                                                                                 socklen_t __optlen ) ;
#line 261
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) shutdown)(int __fd ,
                                                                               int __how ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 390 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 88 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/compat.h"
size_t strlcpy(char *dst , char const   *src , size_t siz ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 50
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 96
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memchr)(void const   *__s ,
                                                                                               int __c ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 285
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strcspn)(char const   *__s ,
                                                                                                   char const   *__reject )  __attribute__((__pure__)) ;
#line 289
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strspn)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 83 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/sock_any.h"
int sock_any_ntop(struct sockaddr_any  const  *any , char *addr , size_t addrlen ,
                  int opts ) ;
#line 47 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/stringx.h"
char *trim_start(char const   *data ) ;
#line 83 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/smtppass.h"
void spio_init(spio_t *io , char const   *name ) ;
#line 86
void spio_attach(struct spctx *ctx , spio_t *io , int fd , struct sockaddr_any *peer ) ;
#line 89
int spio_connect(struct spctx *ctx , spio_t *io , struct sockaddr_any  const  *sany ,
                 char const   *addrname ) ;
#line 90
void spio_disconnect(struct spctx *ctx , spio_t *io ) ;
#line 98
int spio_read_line(struct spctx *ctx , spio_t *io , int opts ) ;
#line 102
int spio_write_data(struct spctx *ctx , spio_t *io , char const   *data ) ;
#line 103
int spio_write_dataf(struct spctx *ctx , spio_t *io , char const   *fmt  , ...) ;
#line 104
int spio_write_data_raw(struct spctx *ctx , spio_t *io , unsigned char const   *buf ,
                        int len ) ;
#line 107
void spio_read_junk(struct spctx *ctx , spio_t *io ) ;
#line 110
unsigned int spio_select(struct spctx *ctx  , ...) ;
#line 163
int sp_is_quit(void) ;
#line 238
void sp_message(spctx_t *ctx , int level , char const   *msg  , ...) ;
#line 239
void sp_messagex(spctx_t *ctx , int level , char const   *msg  , ...) ;
#line 73 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/sppriv.h"
spstate_t g_state ;
#line 70 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/spio.c"
static void close_raw(int *fd ) 
{ 


  {
  {
#line 73
  shutdown(*fd, 2);
#line 74
  close(*fd);
#line 75
  *fd = -1;
  }
#line 76
  return;
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/spio.c"
static void log_io_data(spctx_t *ctx , spio_t *io , char const   *data , int read___0 ) 
{ 
  char buf[80] ;
  int pos ;
  int len ;
  size_t tmp ;
  size_t tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;

  {
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 87
    tmp = strspn(data, "\r\n");
#line 87
    data += tmp;
    }
#line 89
    if (! *data) {
#line 90
      goto while_break;
    }
    {
#line 92
    tmp___0 = strcspn(data, "\r\n");
#line 92
    pos = (int )tmp___0;
    }
#line 94
    if (pos < 79) {
#line 94
      len = pos;
    } else {
#line 94
      len = 79;
    }
    {
#line 95
    memcpy((void */* __restrict  */)(buf), (void const   */* __restrict  */)data,
           (size_t )len);
#line 96
    buf[len] = (char)0;
    }
#line 98
    if (read___0) {
#line 98
      tmp___1 = " < ";
    } else {
#line 98
      tmp___1 = " > ";
    }
#line 98
    if (io->name) {
#line 98
      tmp___2 = io->name;
    } else {
#line 98
      tmp___2 = "???   ";
    }
    {
#line 98
    sp_messagex(ctx, 7, "%s%s%s", tmp___2, tmp___1, buf);
#line 101
    data += pos;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 103
  return;
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/spio.c"
void spio_init(spio_t *io , char const   *name ) 
{ 


  {
  {
#line 108
  memset((void *)io, 0, sizeof(*io));
#line 109
  io->name = name;
#line 110
  io->fd = -1;
  }
#line 111
  return;
}
}
#line 113 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/spio.c"
void spio_attach(struct spctx *ctx , spio_t *io , int fd , struct sockaddr_any *peer ) 
{ 
  struct sockaddr_any peeraddr ;
  struct sockaddr_any locaddr ;
  char const   *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 118
  io->fd = fd;
#line 121
  memset((void *)(& locaddr), 0, sizeof(locaddr));
#line 122
  locaddr.namelen = sizeof(locaddr);
#line 124
  tmp___1 = getsockname(fd, (struct sockaddr */* __restrict  */)(& locaddr.s.a), (socklen_t */* __restrict  */)(& locaddr.namelen));
  }
#line 124
  if (tmp___1 == -1) {
#line 124
    goto _L;
  } else {
    {
#line 124
    tmp___2 = sock_any_ntop((struct sockaddr_any  const  *)(& locaddr), io->localname,
                            (size_t )4096, 16777216);
    }
#line 124
    if (tmp___2 == -1) {
      _L: /* CIL Label */ 
      {
#line 127
      tmp___0 = __errno_location();
      }
#line 127
      if (*tmp___0 != 97) {
#line 128
        if (io->name) {
#line 128
          tmp = io->name;
        } else {
#line 128
          tmp = "???   ";
        }
        {
#line 128
        sp_message(ctx, 4, "%s: couldn\'t get socket address", tmp);
        }
      }
      {
#line 129
      strlcpy(io->localname, "UNKNOWN", (size_t )4096);
      }
    }
  }
#line 133
  if ((unsigned long )peer == (unsigned long )((void *)0)) {
#line 134
    peer = & peeraddr;
  }
  {
#line 136
  memset((void *)peer, 0, sizeof(*peer));
#line 137
  peer->namelen = sizeof(*peer);
#line 139
  tmp___5 = getpeername(fd, (struct sockaddr */* __restrict  */)(& peer->s.a), (socklen_t */* __restrict  */)(& peer->namelen));
  }
#line 139
  if (tmp___5 == -1) {
#line 139
    goto _L___0;
  } else {
    {
#line 139
    tmp___6 = sock_any_ntop((struct sockaddr_any  const  *)peer, io->peername, (size_t )4096,
                            16777216);
    }
#line 139
    if (tmp___6 == -1) {
      _L___0: /* CIL Label */ 
      {
#line 142
      tmp___4 = __errno_location();
      }
#line 142
      if (*tmp___4 != 97) {
#line 143
        if (io->name) {
#line 143
          tmp___3 = io->name;
        } else {
#line 143
          tmp___3 = "???   ";
        }
        {
#line 143
        sp_message(ctx, 4, "%s: couldn\'t get peer address", tmp___3);
        }
      }
      {
#line 144
      strlcpy(io->peername, "UNKNOWN", (size_t )4096);
      }
    }
  }
#line 148
  io->line[0] = (char)0;
#line 149
  io->_nx = (char *)((void *)0);
#line 150
  io->_ln = (size_t )0;
#line 151
  return;
}
}
#line 153 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/spio.c"
int spio_connect(struct spctx *ctx , spio_t *io , struct sockaddr_any  const  *sany ,
                 char const   *addrname ) 
{ 
  int ret ;
  int fd ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;

  {
  {
#line 156
  ret = 0;
#line 162
  fd = socket((int )sany->s.a.sa_family, 1, 0);
  }
#line 162
  if (fd == -1) {
#line 163
    ret = -1;
#line 163
    goto cleanup;
  }
  {
#line 165
  tmp___0 = setsockopt(fd, 1, 20, (void const   *)(& g_state.timeout), (socklen_t )sizeof(g_state.timeout));
  }
#line 165
  if (tmp___0 == -1) {
#line 165
    goto _L;
  } else {
    {
#line 165
    tmp___1 = setsockopt(fd, 1, 21, (void const   *)(& g_state.timeout), (socklen_t )sizeof(g_state.timeout));
    }
#line 165
    if (tmp___1 == -1) {
      _L: /* CIL Label */ 
#line 167
      if (io->name) {
#line 167
        tmp = io->name;
      } else {
#line 167
        tmp = "???   ";
      }
      {
#line 167
      sp_messagex(ctx, 7, "%s: couldn\'t set timeouts on connection", tmp);
      }
    }
  }
  {
#line 169
  tmp___2 = fcntl(fd, 1, 0);
#line 169
  fcntl(fd, 2, tmp___2 | 1);
#line 171
  tmp___3 = connect(fd, & sany->s.a, (socklen_t )sany->namelen);
  }
#line 171
  if (tmp___3 == -1) {
    {
#line 173
    close_raw(& fd);
#line 174
    ret = -1;
    }
#line 174
    goto cleanup;
  }
  {
#line 177
  spio_attach(ctx, io, fd, (struct sockaddr_any *)((void *)0));
  }
  cleanup: 
#line 180
  if (ret < 0) {
#line 182
    if (io) {
#line 182
      if (io->fd != -1) {
        {
#line 183
        close_raw(& io->fd);
        }
      }
    }
#line 185
    if (io->name) {
#line 185
      tmp___4 = io->name;
    } else {
#line 185
      tmp___4 = "???   ";
    }
    {
#line 185
    sp_message(ctx, 3, "%s: couldn\'t connect to: %s", tmp___4, addrname);
    }
#line 186
    return (-1);
  }
#line 190
  if (io->name) {
#line 190
    tmp___5 = io->name;
  } else {
#line 190
    tmp___5 = "???   ";
  }
  {
#line 190
  sp_messagex(ctx, 7, "%s connected to: %s", tmp___5, io->peername);
  }
#line 191
  return (0);
}
}
#line 194 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/spio.c"
void spio_disconnect(struct spctx *ctx , spio_t *io ) 
{ 
  char const   *tmp ;

  {
#line 198
  if (io) {
#line 198
    if (io->fd != -1) {
      {
#line 200
      close_raw(& io->fd);
      }
#line 201
      if (io->name) {
#line 201
        tmp = io->name;
      } else {
#line 201
        tmp = "???   ";
      }
      {
#line 201
      sp_messagex(ctx, 7, "%s connection closed", tmp);
      }
    }
  }
#line 203
  return;
}
}
#line 205 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/spio.c"
unsigned int spio_select(struct spctx *ctx  , ...) 
{ 
  fd_set mask ;
  spio_t *io ;
  int ret ;
  int have ;
  int i ;
  va_list ap ;
  struct timeval timeout ;
  int __d0 ;
  int __d1 ;
  spio_t *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  spio_t *tmp___3 ;

  {
#line 209
  ret = 0;
#line 210
  have = 0;
#line 211
  i = 0;
  {
#line 216
  while (1) {
    while_continue: /* CIL Label */ ;
#line 216
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& mask.__fds_bits[0]): "memory");
#line 216
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 218
  __builtin_va_start(ap, ctx);
  }
  {
#line 220
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 220
    tmp = __builtin_va_arg(ap, spio_t *);
#line 220
    io = tmp;
    }
#line 220
    if (! ((unsigned long )io != (unsigned long )((void *)0))) {
#line 220
      goto while_break___0;
    }
#line 222
    if (io) {
#line 222
      if (io->fd != -1) {
#line 225
        if ((unsigned long )i > sizeof(int ) * 8UL - 2UL) {
#line 226
          goto while_break___0;
        }
#line 229
        if (io->_ln > 0UL) {
#line 230
          ret |= 1 << i;
        }
#line 233
        mask.__fds_bits[io->fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << io->fd % (8 * (int )sizeof(__fd_mask ));
#line 234
        have = 1;
      }
    }
#line 237
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 240
  __builtin_va_end(ap);
  }
#line 243
  if (ret != 0) {
#line 244
    return ((unsigned int )ret);
  }
#line 247
  if (! have) {
#line 248
    return ((unsigned int )(~ 0));
  }
  {
#line 250
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 253
    memcpy((void */* __restrict  */)(& timeout), (void const   */* __restrict  */)(& g_state.timeout),
           sizeof(timeout));
#line 256
    tmp___0 = select(1024, (fd_set */* __restrict  */)(& mask), (fd_set */* __restrict  */)((void *)0),
                     (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& timeout));
    }
    {
#line 258
    if (tmp___0 == 0) {
#line 258
      goto case_0;
    }
#line 262
    if (tmp___0 == -1) {
#line 262
      goto case_neg_1;
    }
#line 256
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 259
    sp_messagex(ctx, 3, "network operation timed out");
    }
#line 260
    return ((unsigned int )(~ 0));
    case_neg_1: /* CIL Label */ 
    {
#line 263
    tmp___2 = __errno_location();
    }
#line 263
    if (*tmp___2 == 4) {
      {
#line 265
      tmp___1 = sp_is_quit();
      }
#line 265
      if (! tmp___1) {
#line 266
        goto __Cont;
      }
    } else {
      {
#line 270
      sp_message(ctx, 3, "couldn\'t select on sockets");
      }
    }
#line 272
    return ((unsigned int )(~ 0));
    switch_break: /* CIL Label */ ;
    }
#line 275
    goto while_break___1;
    __Cont: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 279
  i = 0;
#line 281
  __builtin_va_start(ap, ctx);
  }
  {
#line 283
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 283
    tmp___3 = __builtin_va_arg(ap, spio_t *);
#line 283
    io = tmp___3;
    }
#line 283
    if (! ((unsigned long )io != (unsigned long )((void *)0))) {
#line 283
      goto while_break___2;
    }
#line 285
    if (io) {
#line 285
      if (io->fd != -1) {
#line 288
        if ((unsigned long )i > sizeof(int ) * 8UL - 2UL) {
#line 289
          goto while_break___2;
        }
        {
#line 292
        io->last_action = time((time_t *)((void *)0));
        }
#line 295
        if ((mask.__fds_bits[io->fd / (8 * (int )sizeof(__fd_mask ))] & (1L << io->fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 296
          ret |= 1 << i;
        }
      }
    }
#line 299
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 302
  __builtin_va_end(ap);
  }
#line 304
  return ((unsigned int )ret);
}
}
#line 307 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/spio.c"
int read_raw(spctx_t *ctx , spio_t *io , int opts ) 
{ 
  int len ;
  int x ;
  int count ;
  char *at ;
  char *p ;
  void *tmp ;
  ssize_t tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  void *tmp___8 ;

  {
#line 323
  count = 0;
#line 324
  io->line[0] = (char)0;
#line 327
  if (io->_nx) {
#line 327
    if (io->_ln > 0UL) {
      {
#line 334
      tmp = memchr((void const   *)io->_nx, '\n', io->_ln);
#line 334
      p = (char *)tmp;
      }
#line 334
      if ((unsigned long )p != (unsigned long )((void *)0)) {
        {
#line 337
        x = (int )((p - io->_nx) + 1L);
#line 339
        memmove((void *)(io->line), (void const   *)io->_nx, (size_t )x);
#line 342
        io->line[x] = (char)0;
#line 345
        io->_ln -= (size_t )x;
#line 346
        io->_nx += x;
#line 349
        count += x;
        }
#line 350
        return (count);
      }
      {
#line 354
      memmove((void *)(io->line), (void const   *)io->_nx, io->_ln);
#line 355
      count = (int )((size_t )count + io->_ln);
#line 358
      len = (int )((4224UL - io->_ln) - 1UL);
#line 359
      at = io->line + io->_ln;
      }
    } else {
#line 366
      len = 4223;
#line 367
      at = io->line;
    }
  } else {
#line 366
    len = 4223;
#line 367
    at = io->line;
  }
  {
#line 370
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 374
    tmp___0 = read(io->fd, (void *)at, sizeof(char ) * (unsigned long )len);
#line 374
    x = (int )tmp___0;
    }
#line 376
    if (x == -1) {
      {
#line 378
      tmp___2 = __errno_location();
      }
#line 378
      if (*tmp___2 == 4) {
        {
#line 381
        tmp___1 = sp_is_quit();
        }
#line 381
        if (tmp___1) {
#line 382
          return (-1);
        }
#line 385
        goto __Cont;
      }
      {
#line 388
      tmp___7 = __errno_location();
      }
#line 388
      if (*tmp___7 == 104) {
#line 389
        if (io->name) {
#line 389
          tmp___3 = io->name;
        } else {
#line 389
          tmp___3 = "???   ";
        }
        {
#line 389
        sp_messagex(ctx, 7, "%s: connection disconnected by peer", tmp___3);
        }
      } else {
        {
#line 390
        tmp___6 = __errno_location();
        }
#line 390
        if (*tmp___6 == 11) {
#line 391
          if (io->name) {
#line 391
            tmp___4 = io->name;
          } else {
#line 391
            tmp___4 = "???   ";
          }
          {
#line 391
          sp_messagex(ctx, 4, "%s: network read operation timed out", tmp___4);
          }
        } else {
#line 393
          if (io->name) {
#line 393
            tmp___5 = io->name;
          } else {
#line 393
            tmp___5 = "???   ";
          }
          {
#line 393
          sp_message(ctx, 3, "%s: couldn\'t read data from socket", tmp___5);
          }
        }
      }
      {
#line 400
      close_raw(& io->fd);
      }
#line 402
      return (-1);
    } else
#line 406
    if (x == 0) {
#line 409
      io->_nx = (char *)((void *)0);
#line 410
      io->_ln = (size_t )0;
#line 412
      return (count);
    }
    {
#line 416
    io->last_action = time((time_t *)((void *)0));
#line 419
    tmp___8 = memchr((void const   *)at, '\n', (size_t )x);
#line 419
    p = (char *)tmp___8;
    }
#line 420
    if ((unsigned long )p != (unsigned long )((void *)0)) {
      {
#line 422
      p ++;
#line 423
      count = (int )((long )count + (p - at));
#line 426
      len = (int )((long )x - (p - at));
#line 427
      memmove((void *)(p + 1), (void const   *)p, (size_t )len);
#line 428
      *p = (char)0;
#line 431
      io->_nx = p + 1;
#line 432
      io->_ln = (size_t )len;
      }
#line 434
      return (count);
    }
#line 438
    at += x;
#line 439
    len -= x;
#line 440
    count += x;
#line 442
    if (len <= 0) {
#line 445
      if (opts & 2) {
#line 455
        at = (io->line + 4224) - 128;
#line 456
        len = 128;
#line 459
        goto __Cont;
      }
#line 462
      io->_nx = (char *)((void *)0);
#line 463
      io->_ln = (size_t )0;
#line 466
      io->line[4224] = (char)0;
#line 469
      return (count);
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 474 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/spio.c"
int spio_read_line(struct spctx *ctx , spio_t *io , int opts ) 
{ 
  int x ;
  int l ;
  char *t ;
  char const   *tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
#line 481
  if (io) {
#line 481
    if (! (io->fd != -1)) {
#line 481
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 483
    if (io->name) {
#line 483
      tmp = io->name;
    } else {
#line 483
      tmp = "???   ";
    }
    {
#line 483
    sp_messagex(ctx, 4, "%s: tried to read from a closed connection", tmp);
    }
#line 484
    return (0);
  }
  {
#line 487
  x = read_raw(ctx, io, opts);
  }
#line 489
  if (x > 0) {
#line 491
    if (opts & 1) {
#line 493
      t = io->line;
      {
#line 495
      while (1) {
        while_continue: /* CIL Label */ ;
#line 495
        if (*t) {
          {
#line 495
          tmp___0 = __ctype_b_loc();
          }
#line 495
          if (! ((int const   )*(*tmp___0 + (int )*t) & 8192)) {
#line 495
            goto while_break;
          }
        } else {
#line 495
          goto while_break;
        }
#line 496
        t ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 499
      l = (int )(t - io->line);
#line 500
      memmove((void *)(io->line), (void const   *)t, (size_t )((x + 1) - l));
#line 501
      x -= l;
#line 504
      t = io->line + x;
      }
      {
#line 506
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 506
        if ((unsigned long )t > (unsigned long )(io->line)) {
          {
#line 506
          tmp___1 = __ctype_b_loc();
          }
#line 506
          if (! ((int const   )*(*tmp___1 + (int )*(t - 1)) & 8192)) {
#line 506
            goto while_break___0;
          }
        } else {
#line 506
          goto while_break___0;
        }
#line 508
        t --;
#line 508
        *t = (char)0;
#line 509
        x --;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 513
    if (! (opts & 4)) {
      {
#line 514
      log_io_data(ctx, io, (char const   *)(io->line), 1);
      }
    }
  }
#line 517
  return (x);
}
}
#line 520 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/spio.c"
int spio_write_data(struct spctx *ctx , spio_t *io , char const   *data ) 
{ 
  int len ;
  size_t tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 522
  tmp = strlen(data);
#line 522
  len = (int )tmp;
  }
#line 525
  if (io) {
#line 525
    if (! (io->fd != -1)) {
#line 525
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 527
    if (io->name) {
#line 527
      tmp___0 = io->name;
    } else {
#line 527
      tmp___0 = "???   ";
    }
    {
#line 527
    sp_message(ctx, 3, "%s: connection closed. can\'t write data", tmp___0);
    }
#line 528
    return (-1);
  }
  {
#line 531
  log_io_data(ctx, io, data, 0);
#line 532
  tmp___1 = spio_write_data_raw(ctx, io, (unsigned char const   *)((unsigned char *)data),
                                len);
  }
#line 532
  return (tmp___1);
}
}
#line 535 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/spio.c"
int spio_write_dataf(struct spctx *ctx , spio_t *io , char const   *fmt  , ...) 
{ 
  char buf[4224] ;
  va_list ap ;
  int tmp ;

  {
  {
#line 541
  buf[0] = (char)0;
#line 543
  __builtin_va_start(ap, fmt);
#line 544
  vsnprintf((char */* __restrict  */)(buf), (size_t )4224, (char const   */* __restrict  */)fmt,
            ap);
#line 545
  __builtin_va_end(ap);
#line 547
  buf[4223] = (char)0;
#line 549
  tmp = spio_write_data(ctx, io, (char const   *)(buf));
  }
#line 549
  return (tmp);
}
}
#line 552 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/spio.c"
int spio_write_data_raw(struct spctx *ctx , spio_t *io , unsigned char const   *buf ,
                        int len ) 
{ 
  int r ;
  ssize_t tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  int *tmp___4 ;

  {
#line 558
  if (io->fd == -1) {
#line 559
    return (0);
  }
  {
#line 561
  io->last_action = time((time_t *)((void *)0));
  }
  {
#line 563
  while (1) {
    while_continue: /* CIL Label */ ;
#line 563
    if (! (len > 0)) {
#line 563
      goto while_break;
    }
    {
#line 565
    tmp = write(io->fd, (void const   *)buf, (size_t )len);
#line 565
    r = (int )tmp;
    }
#line 567
    if (r > 0) {
#line 569
      buf += r;
#line 570
      len -= r;
    } else
#line 573
    if (r == -1) {
      {
#line 575
      tmp___1 = __errno_location();
      }
#line 575
      if (*tmp___1 == 4) {
        {
#line 578
        tmp___0 = sp_is_quit();
        }
#line 578
        if (tmp___0) {
#line 579
          return (-1);
        }
#line 582
        goto while_continue;
      }
      {
#line 590
      close_raw(& io->fd);
#line 592
      tmp___4 = __errno_location();
      }
#line 592
      if (*tmp___4 == 11) {
#line 593
        if (io->name) {
#line 593
          tmp___2 = io->name;
        } else {
#line 593
          tmp___2 = "???   ";
        }
        {
#line 593
        sp_messagex(ctx, 4, "%s: network write operation timed out", tmp___2);
        }
      } else {
#line 595
        if (io->name) {
#line 595
          tmp___3 = io->name;
        } else {
#line 595
          tmp___3 = "???   ";
        }
        {
#line 595
        sp_message(ctx, 3, "%s: couldn\'t write data to socket", tmp___3);
        }
      }
#line 597
      return (-1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 601
  return (0);
}
}
#line 604 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/spio.c"
void spio_read_junk(struct spctx *ctx , spio_t *io ) 
{ 
  char buf[16] ;
  char const   *t ;
  int said ;
  int l ;
  int tmp ;
  ssize_t tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;

  {
#line 608
  said = 0;
#line 615
  io->_ln = (size_t )0;
#line 616
  io->_nx = (char *)0;
#line 618
  if (io) {
#line 618
    if (! (io->fd != -1)) {
#line 619
      return;
    }
  } else {
#line 619
    return;
  }
  {
#line 622
  tmp = fcntl(io->fd, 3, 0);
#line 622
  fcntl(io->fd, 4, tmp | 2048);
  }
  {
#line 624
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 626
    tmp___0 = read(io->fd, (void *)(buf), sizeof(buf) - 1UL);
#line 626
    l = (int )tmp___0;
    }
#line 627
    if (l <= 0) {
#line 628
      goto while_break;
    }
    {
#line 630
    io->last_action = time((time_t *)((void *)0));
#line 632
    buf[l] = (char)0;
#line 633
    tmp___1 = trim_start((char const   *)(buf));
#line 633
    t = (char const   *)tmp___1;
    }
#line 635
    if (! said) {
#line 635
      if (*t) {
#line 637
        if (io->name) {
#line 637
          tmp___2 = io->name;
        } else {
#line 637
          tmp___2 = "???   ";
        }
        {
#line 637
        sp_messagex(ctx, 7, "%s: received junk data from daemon", tmp___2);
#line 638
        said = 1;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 642
  tmp___3 = fcntl(io->fd, 3, 0);
#line 642
  fcntl(io->fd, 4, tmp___3 & -2049);
  }
#line 643
  return;
}
}
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 375 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) ntohs)(uint16_t __netshort )  __attribute__((__const__)) ;
#line 377
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) htonl)(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 379
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 662 "/usr/include/netdb.h"
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
#line 668
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) freeaddrinfo)(struct addrinfo *__ai ) ;
#line 69 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 140
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 386 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 67 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/sock_any.h"
int sock_any_pton(char const   *addr , struct sockaddr_any *any , int opts ) ;
#line 88
int sock_any_cmp(struct sockaddr_any  const  *a1 , struct sockaddr_any  const  *a2 ,
                 int opts ) ;
#line 58 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) inet_pton)(int __af ,
                                                                                char const   * __restrict  __cp ,
                                                                                void * __restrict  __buf ) ;
#line 64
extern  __attribute__((__nothrow__)) char const   *( __attribute__((__leaf__)) inet_ntop)(int __af ,
                                                                                          void const   * __restrict  __cp ,
                                                                                          char * __restrict  __buf ,
                                                                                          socklen_t __len ) ;
#line 55 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/sock_any.c"
int sock_any_pton(char const   *addr , struct sockaddr_any *any , int opts ) 
{ 
  size_t l ;
  char buf[256] ;
  char *t ;
  char *t2 ;
  int defport ;
  int port ;
  long tmp ;
  int port___0 ;
  long tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  struct addrinfo *res ;
  int port___1 ;
  unsigned short const   **tmp___5 ;
  size_t tmp___6 ;
  long tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  uint16_t tmp___10 ;

  {
  {
#line 61
  defport = opts & 65535;
#line 63
  memset((void *)any, 0, sizeof(*any));
  }
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 72
    port = 0;
#line 74
    l = strspn(addr, "0123456789");
    }
#line 75
    if (l < 1UL) {
#line 76
      goto while_break;
    } else
#line 75
    if (l > 5UL) {
#line 76
      goto while_break;
    } else
#line 75
    if ((int const   )*(addr + l) != 0) {
#line 76
      goto while_break;
    }
    {
#line 78
    tmp = strtol((char const   */* __restrict  */)addr, (char **/* __restrict  */)(& t2),
                 10);
#line 78
    port = (int )tmp;
    }
#line 79
    if (*t2) {
#line 80
      goto while_break;
    } else
#line 79
    if (port <= 0) {
#line 80
      goto while_break;
    } else
#line 79
    if (port >= 65536) {
#line 80
      goto while_break;
    }
    {
#line 82
    any->s.in.sin_port = htons((uint16_t )port);
#line 90
    any->s.in.sin_family = (sa_family_t )2;
    }
#line 93
    if (opts & 1048576) {
      {
#line 100
      any->s.in.sin_addr.s_addr = htonl((in_addr_t )2130706433);
      }
    }
#line 108
    any->namelen = sizeof(any->s.in);
#line 109
    return (2);
#line 66
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 114
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 121
    port___0 = 0;
#line 122
    t = (char *)((void *)0);
#line 124
    l = strlen(addr);
    }
#line 125
    if (l < 3UL) {
#line 126
      goto while_break___0;
    } else
#line 125
    if (l > 21UL) {
#line 126
      goto while_break___0;
    }
    {
#line 128
    strcpy((char */* __restrict  */)(buf), (char const   */* __restrict  */)addr);
#line 131
    l = strspn((char const   *)(buf), "0123456789.");
    }
#line 132
    if (l < 3UL) {
#line 133
      goto while_break___0;
    }
#line 136
    if ((int )buf[l] != 0) {
#line 136
      if ((int )buf[l] != 58) {
#line 137
        goto while_break___0;
      }
    }
#line 140
    if ((int )buf[l] != 0) {
#line 142
      t = (buf + l) + 1;
#line 143
      buf[l] = (char)0;
    }
#line 146
    if (t) {
      {
#line 148
      tmp___0 = strtol((char const   */* __restrict  */)t, (char **/* __restrict  */)(& t2),
                       10);
#line 148
      port___0 = (int )tmp___0;
      }
#line 149
      if (*t2) {
#line 150
        goto while_break___0;
      } else
#line 149
      if (port___0 <= 0) {
#line 150
        goto while_break___0;
      } else
#line 149
      if (port___0 >= 65536) {
#line 150
        goto while_break___0;
      }
    }
#line 153
    any->s.in.sin_family = (sa_family_t )2;
#line 154
    if (port___0 <= 0) {
#line 154
      tmp___1 = defport;
    } else {
#line 154
      tmp___1 = port___0;
    }
    {
#line 154
    any->s.in.sin_port = htons((unsigned short )tmp___1);
#line 156
    tmp___2 = inet_pton(2, (char const   */* __restrict  */)(buf), (void */* __restrict  */)(& any->s.in.sin_addr));
    }
#line 156
    if (tmp___2 <= 0) {
#line 157
      goto while_break___0;
    }
#line 159
    any->namelen = sizeof(any->s.in);
#line 160
    return (2);
#line 114
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 226
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 229
    tmp___3 = strchr(addr, ':');
    }
#line 229
    if (tmp___3) {
#line 230
      goto while_break___1;
    } else {
      {
#line 229
      tmp___4 = strchr(addr, '/');
      }
#line 229
      if (! tmp___4) {
#line 230
        goto while_break___1;
      }
    }
    {
#line 232
    l = strlen(addr);
    }
#line 233
    if (l >= sizeof(any->s.un.sun_path)) {
#line 234
      goto while_break___1;
    }
    {
#line 236
    any->s.un.sun_family = (sa_family_t )1;
#line 237
    strcpy((char */* __restrict  */)(any->s.un.sun_path), (char const   */* __restrict  */)addr);
#line 239
    any->namelen = sizeof(any->s.un) - (sizeof(any->s.un.sun_path) - l);
    }
#line 240
    return (1);
#line 226
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 245
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 248
    port___1 = 0;
#line 249
    t = (char *)((void *)0);
#line 251
    l = strlen(addr);
    }
#line 252
    if (l >= 255UL) {
#line 253
      goto while_break___2;
    } else {
      {
#line 252
      tmp___5 = __ctype_b_loc();
      }
#line 252
      if (! ((int const   )*(*tmp___5 + (int )*(addr + 0)) & 1024)) {
#line 253
        goto while_break___2;
      }
    }
    {
#line 256
    tmp___6 = strcspn(addr, " /\\");
    }
#line 256
    if (tmp___6 != l) {
#line 257
      goto while_break___2;
    }
    {
#line 259
    strcpy((char */* __restrict  */)(buf), (char const   */* __restrict  */)addr);
#line 262
    t = strchr((char const   *)(buf), ':');
    }
#line 263
    if (t) {
#line 265
      *t = (char)0;
#line 266
      t ++;
    }
#line 269
    if (t) {
      {
#line 271
      tmp___7 = strtol((char const   */* __restrict  */)t, (char **/* __restrict  */)(& t2),
                       10);
#line 271
      port___1 = (int )tmp___7;
      }
#line 272
      if (*t2) {
#line 273
        goto while_break___2;
      } else
#line 272
      if (port___1 <= 0) {
#line 273
        goto while_break___2;
      } else
#line 272
      if (port___1 >= 65536) {
#line 273
        goto while_break___2;
      }
    }
    {
#line 277
    tmp___8 = getaddrinfo((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)((void *)0),
                          (struct addrinfo  const  */* __restrict  */)((void *)0),
                          (struct addrinfo **/* __restrict  */)(& res));
    }
#line 277
    if (tmp___8 != 0) {
#line 278
      goto while_break___2;
    } else
#line 277
    if (! res) {
#line 278
      goto while_break___2;
    }
    {
#line 280
    memcpy((void */* __restrict  */)(& any->s.a), (void const   */* __restrict  */)res->ai_addr,
           sizeof(struct sockaddr ));
#line 281
    any->namelen = (size_t )res->ai_addrlen;
#line 282
    freeaddrinfo(res);
    }
#line 284
    if (port___1 <= 0) {
#line 284
      tmp___9 = defport;
    } else {
#line 284
      tmp___9 = port___1;
    }
    {
#line 284
    tmp___10 = htons((unsigned short )tmp___9);
#line 284
    port___1 = (int )tmp___10;
    }
    {
#line 288
    if ((int )any->s.a.sa_family == 2) {
#line 288
      goto case_2;
    }
#line 286
    goto switch_break;
    case_2: /* CIL Label */ 
#line 289
    any->s.in.sin_port = (in_port_t )port___1;
#line 290
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 298
    return ((int )any->s.a.sa_family);
#line 245
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 302
  return (-1);
}
}
#line 305 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/sock_any.c"
int sock_any_ntop(struct sockaddr_any  const  *any , char *addr , size_t addrlen ,
                  int opts ) 
{ 
  int len ;
  int port ;
  size_t tmp ;
  int *tmp___0 ;
  char const   *tmp___1 ;
  uint16_t tmp___2 ;
  int *tmp___3 ;
  size_t tmp___4 ;

  {
#line 307
  len = 0;
#line 308
  port = 0;
  {
#line 312
  if ((int const   )any->s.a.sa_family == 1) {
#line 312
    goto case_1;
  }
#line 323
  if ((int const   )any->s.a.sa_family == 2) {
#line 323
    goto case_2;
  }
#line 337
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 313
  tmp = strlen((char const   *)(any->s.un.sun_path));
#line 313
  len = (int )tmp;
  }
#line 314
  if (addrlen < (size_t )(len + 1)) {
    {
#line 316
    tmp___0 = __errno_location();
#line 316
    *tmp___0 = 28;
    }
#line 317
    return (-1);
  }
  {
#line 320
  strcpy((char */* __restrict  */)addr, (char const   */* __restrict  */)(any->s.un.sun_path));
  }
#line 321
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 324
  tmp___1 = inet_ntop((int )any->s.a.sa_family, (void const   */* __restrict  */)(& any->s.in.sin_addr),
                      (char */* __restrict  */)addr, (socklen_t )addrlen);
  }
#line 324
  if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
#line 325
    return (-1);
  }
  {
#line 326
  tmp___2 = ntohs((uint16_t )any->s.in.sin_port);
#line 326
  port = (int )tmp___2;
  }
#line 327
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 338
  tmp___3 = __errno_location();
#line 338
  *tmp___3 = 97;
  }
#line 339
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 342
  if (! (opts & 16777216)) {
#line 342
    if (port != 0) {
      {
#line 344
      strncat((char */* __restrict  */)addr, (char const   */* __restrict  */)":",
              addrlen);
#line 345
      *(addr + (addrlen - 1UL)) = (char)0;
#line 347
      tmp___4 = strlen((char const   *)addr);
#line 347
      len = (int )tmp___4;
#line 348
      addr += len;
#line 349
      addrlen -= (size_t )len;
#line 351
      snprintf((char */* __restrict  */)addr, addrlen, (char const   */* __restrict  */)"%d",
               port);
      }
    }
  }
#line 354
  return (0);
}
}
#line 357 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/sock_any.c"
int sock_any_cmp(struct sockaddr_any  const  *a1 , struct sockaddr_any  const  *a2 ,
                 int opts ) 
{ 
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;

  {
#line 359
  if ((int const   )a1->s.a.sa_family != (int const   )a2->s.a.sa_family) {
#line 360
    return (-1);
  }
  {
#line 364
  if ((int const   )a1->s.a.sa_family == 1) {
#line 364
    goto case_1;
  }
#line 367
  if ((int const   )a1->s.a.sa_family == 2) {
#line 367
    goto case_2;
  }
#line 381
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 365
  tmp = strcmp((char const   *)(a1->s.un.sun_path), (char const   *)(a2->s.un.sun_path));
  }
#line 365
  return (tmp);
  case_2: /* CIL Label */ 
  {
#line 368
  tmp___0 = memcmp((void const   *)(& a1->s.in.sin_addr), (void const   *)(& a2->s.in.sin_addr),
                   sizeof(a2->s.in.sin_addr));
  }
#line 368
  if (tmp___0 != 0) {
#line 369
    return (-1);
  }
#line 370
  if (! opts) {
#line 370
    if ((int const   )a1->s.in.sin_port != (int const   )a2->s.in.sin_port) {
#line 371
      return (-1);
    }
  }
#line 372
  return (0);
  switch_default: /* CIL Label */ 
  {
#line 382
  tmp___1 = __errno_location();
#line 382
  *tmp___1 = 97;
  }
#line 383
  return (-1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 123 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  * __restrict  __addr ,
                                                                           socklen_t __len ) ;
#line 233
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) listen)(int __fd ,
                                                                             int __n ) ;
#line 243
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                           int __sig ) ;
#line 347
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) siginterrupt)(int __sig ,
                                                                                   int __interrupt ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 584
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) setenv)(char const   *__name ,
                                                                                             char const   *__value ,
                                                                                             int __replace ) ;
#line 620
extern int ( __attribute__((__nonnull__(1))) mkstemp)(char *__template ) ;
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 306
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 678
extern __ssize_t getline(char ** __restrict  __lineptr , size_t * __restrict  __n ,
                         FILE * __restrict  __stream ) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 749
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 754
extern long ftell(FILE *__stream ) ;
#line 830
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 628 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 678
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) geteuid)(void) ;
#line 700
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setuid)(__uid_t __uid ) ;
#line 705
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setreuid)(__uid_t __ruid ,
                                                                               __uid_t __euid ) ;
#line 717
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setgid)(__gid_t __gid ) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 937
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) daemon)(int __nochdir ,
                                                                             int __noclose ) ;
#line 181 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 200
extern void ( /* format attribute */  vsyslog)(int __pri , char const   *__fmt , __gnuc_va_list __ap ) ;
#line 110 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 116
extern struct passwd *getpwnam(char const   *__name ) ;
#line 254 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime_r)(time_t const   * __restrict  __timer ,
                                                                                         struct tm * __restrict  __tp ) ;
#line 272
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) asctime_r)(struct tm  const  * __restrict  __tp ,
                                                                                  char * __restrict  __buf ) ;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 373
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcasestr)(char const   *__haystack ,
                                                                                                     char const   *__needle )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 60 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/compat.h"
void *reallocf(void *ptr , size_t size ) ;
#line 244 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t * __restrict  __newthread ,
                                                                                             pthread_attr_t const   * __restrict  __attr ,
                                                                                             void *(*__start_routine)(void * ) ,
                                                                                             void * __restrict  __arg ) ;
#line 261
extern int pthread_join(pthread_t __th , void **__thread_return ) ;
#line 286
extern  __attribute__((__nothrow__)) pthread_t ( __attribute__((__leaf__)) pthread_self)(void)  __attribute__((__const__)) ;
#line 760
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutex_init)(pthread_mutex_t *__mutex ,
                                                                                                         pthread_mutexattr_t const   *__mutexattr ) ;
#line 765
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutex_destroy)(pthread_mutex_t *__mutex ) ;
#line 773
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex ) ;
#line 784
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex ) ;
#line 817
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutexattr_init)(pthread_mutexattr_t *__attr ) ;
#line 821
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutexattr_destroy)(pthread_mutexattr_t *__attr ) ;
#line 844
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutexattr_settype)(pthread_mutexattr_t *__attr ,
                                                                                                                int __kind ) ;
#line 84 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/compat.h"
size_t strlcat(char *dst , char const   *src , size_t siz ) ;
#line 40 "/usr/include/err.h"
extern void ( /* format attribute */  warnx)(char const   *__format  , ...) ;
#line 42
extern void ( /* format attribute */  vwarnx)(char const   *__format , __gnuc_va_list  ) ;
#line 46
extern  __attribute__((__noreturn__)) void ( /* format attribute */  err)(int __status ,
                                                                          char const   *__format 
                                                                          , ...) ;
#line 50
extern  __attribute__((__noreturn__)) void ( /* format attribute */  errx)(int __status ,
                                                                           char const   *__format 
                                                                           , ...) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/stringx.h"
int check_first_word(char const   *line , char const   *word , int len , char *delims ) ;
#line 43
int is_first_word(char const   *line , char const   *word , int len ) ;
#line 45
int is_blank_line(char const   *line ) ;
#line 48
char *trim_end(char *data ) ;
#line 49
char *trim_space(char *data ) ;
#line 51
int strtob(char const   *str ) ;
#line 145 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/smtppass.h"
void sp_init(char const   *name ) ;
#line 151
int sp_run(char const   *configfile , char const   *pidfile , int dbg_level ) ;
#line 157
void sp_quit(void) ;
#line 169
void sp_done(void) ;
#line 189
void sp_add_log(spctx_t *ctx , char *prefix , char *line ) ;
#line 198
int sp_read_data(spctx_t *ctx , char const   **data ) ;
#line 206
int sp_write_data(spctx_t *ctx , char const   *buf , int len ) ;
#line 212
int sp_cache_data(spctx_t *ctx ) ;
#line 218
int sp_done_data(spctx_t *ctx , char const   *headertmpl ) ;
#line 224
int sp_fail_data(spctx_t *ctx , char const   *smtp_status ) ;
#line 231
void sp_setup_forked(spctx_t *ctx , int file ) ;
#line 245
void sp_lock(void) ;
#line 246
void sp_unlock(void) ;
#line 259
spctx_t *cb_new_context(void) ;
#line 260
void cb_del_context(spctx_t *sp ) ;
#line 272
int cb_check_data(spctx_t *sp ) ;
#line 280
int cb_parse_option(char const   *name , char const   *value ) ;
#line 73 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/sppriv.h"
spstate_t g_state  ;
#line 188 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/smtppass.c"
unsigned int g_unique_id  =    1048576U;
#line 189 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/smtppass.c"
pthread_mutex_t g_mutex  ;
#line 190 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/smtppass.c"
pthread_mutexattr_t g_mtxattr  ;
#line 196
static void on_quit(int signal___0 ) ;
#line 197
static void drop_privileges(void) ;
#line 198
static void pid_file(int write___0 ) ;
#line 199
static void connection_loop(int sock ) ;
#line 200
static void *thread_main(void *arg ) ;
#line 201
static int smtp_passthru(spctx_t *ctx ) ;
#line 202
static int make_connections(spctx_t *ctx , int client ) ;
#line 203
static int read_server_response(spctx_t *ctx ) ;
#line 204
static int parse_config_file(char const   *configfile ) ;
#line 205
static char *parse_address(char *line ) ;
#line 206
static char *parse_xforward(char *line , char const   *part ) ;
#line 207
static char const   *get_successful_rsp(char const   *line , int *cont ) ;
#line 208
static void do_server_noop(spctx_t *ctx ) ;
#line 211
int sp_parse_option(char const   *name , char const   *value ) ;
#line 217 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/smtppass.c"
void sp_init(char const   *name ) 
{ 
  int r ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 223
  memset((void *)(& g_state), 0, sizeof(g_state));
#line 225
  sp_message((spctx_t *)((void *)0), 7, "%s (%s)", name, "1.10");
#line 228
  g_state.debug_level = -1;
#line 229
  g_state.max_threads = 64;
#line 230
  g_state.timeout.tv_sec = (__time_t )180;
#line 231
  g_state.keepalives = 0;
#line 232
  g_state.directory = "/tmp/";
#line 233
  g_state.name = name;
#line 236
  r = sp_parse_option("Listen", "10025");
#line 240
  tmp = pthread_mutexattr_init(& g_mtxattr);
  }
#line 240
  if (tmp != 0) {
    {
#line 245
    errx(1, "threading problem. can\'t create mutex or condition var");
    }
  } else {
    {
#line 240
    tmp___0 = pthread_mutexattr_settype(& g_mtxattr, 2);
    }
#line 240
    if (tmp___0) {
      {
#line 245
      errx(1, "threading problem. can\'t create mutex or condition var");
      }
    } else {
      {
#line 240
      tmp___1 = pthread_mutex_init(& g_mutex, (pthread_mutexattr_t const   *)(& g_mtxattr));
      }
#line 240
      if (tmp___1 != 0) {
        {
#line 245
        errx(1, "threading problem. can\'t create mutex or condition var");
        }
      }
    }
  }
#line 246
  return;
}
}
#line 248 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/smtppass.c"
int sp_run(char const   *configfile , char const   *pidfile , int dbg_level ) 
{ 
  int sock ;
  int true ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 251
  true = 1;
#line 256
  if (! (dbg_level == -1)) {
#line 256
    if (! (dbg_level <= 7)) {
      {
#line 257
      errx(2, "invalid debug log level (must be between 1 and 4)");
      }
    }
  }
  {
#line 258
  g_state.debug_level = dbg_level;
#line 259
  g_state.pidfile = pidfile;
#line 262
  tmp = parse_config_file(configfile);
  }
#line 262
  if (tmp == -1) {
    {
#line 270
    warnx("configuration file not found: %s", configfile);
    }
  }
#line 274
  if ((unsigned long )g_state.outname == (unsigned long )((void *)0)) {
#line 274
    if (! g_state.transparent) {
      {
#line 275
      errx(2, "no OutAddress specified.");
      }
    } else {
#line 274
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 278
  if ((unsigned long )g_state.outname != (unsigned long )((void *)0)) {
#line 278
    if (g_state.transparent) {
      {
#line 279
      warnx("the OutAddress option will be ignored when TransparentProxy is enabled");
      }
    }
  }
  {
#line 281
  sp_messagex((spctx_t *)((void *)0), 7, "starting up (%s)...", "1.10");
#line 284
  drop_privileges();
  }
#line 287
  if (g_state.debug_level == -1) {
    {
#line 290
    tmp___0 = daemon(0, 0);
    }
#line 290
    if (tmp___0 == -1) {
      {
#line 292
      sp_message((spctx_t *)((void *)0), 3, "couldn\'t run as daemon");
#line 293
      exit(1);
      }
    }
    {
#line 296
    sp_messagex((spctx_t *)((void *)0), 7, "running as a daemon");
#line 297
    g_state.daemonized = 1;
#line 300
    openlog(g_state.name, 0, 2 << 3);
    }
  }
  {
#line 304
  signal(13, (void (*)(int  ))1);
#line 305
  signal(1, (void (*)(int  ))1);
#line 306
  signal(2, & on_quit);
#line 307
  signal(15, & on_quit);
#line 309
  siginterrupt(2, 1);
#line 310
  siginterrupt(15, 1);
#line 313
  sock = socket((int )g_state.listenaddr.s.a.sa_family, 1, 0);
  }
#line 314
  if (sock < 0) {
    {
#line 316
    sp_message((spctx_t *)((void *)0), 2, "couldn\'t open socket");
#line 317
    exit(1);
    }
  }
  {
#line 320
  tmp___1 = fcntl(sock, 1, 0);
#line 320
  fcntl(sock, 2, tmp___1 | 1);
#line 321
  setsockopt(sock, 1, 2, (void const   *)((void *)(& true)), (socklen_t )sizeof(true));
  }
#line 324
  if ((int )g_state.listenaddr.s.a.sa_family == 1) {
    {
#line 325
    unlink(g_state.listenname);
    }
  }
  {
#line 327
  tmp___2 = bind(sock, (struct sockaddr  const  */* __restrict  */)(& g_state.listenaddr.s.a),
                 (socklen_t )g_state.listenaddr.namelen);
  }
#line 327
  if (tmp___2 != 0) {
    {
#line 329
    sp_message((spctx_t *)((void *)0), 2, "couldn\'t bind to address: %s", g_state.listenname);
#line 330
    exit(1);
    }
  }
  {
#line 333
  sp_messagex((spctx_t *)((void *)0), 7, "created socket: %s", g_state.listenname);
#line 336
  tmp___3 = listen(sock, 5);
  }
#line 336
  if (tmp___3 != 0) {
    {
#line 338
    sp_message((spctx_t *)((void *)0), 2, "couldn\'t listen on socket");
#line 339
    exit(1);
    }
  }
  {
#line 342
  pid_file(1);
#line 344
  sp_messagex((spctx_t *)((void *)0), 7, "accepting connections");
#line 346
  connection_loop(sock);
#line 348
  pid_file(0);
#line 351
  close(sock);
#line 353
  sp_messagex((spctx_t *)((void *)0), 7, "stopped processing");
  }
#line 354
  return (0);
}
}
#line 357 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/smtppass.c"
void sp_quit(void) 
{ 
  __pid_t tmp ;

  {
  {
#line 360
  tmp = getpid();
#line 360
  kill(tmp, 15);
  }
#line 361
  return;
}
}
#line 363 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/smtppass.c"
int sp_is_quit(void) 
{ 
  int tmp ;

  {
#line 365
  if (g_state.quit) {
#line 365
    tmp = 1;
  } else {
#line 365
    tmp = 0;
  }
#line 365
  return (tmp);
}
}
#line 368 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/smtppass.c"
void sp_done(void) 
{ 


  {
  {
#line 371
  pthread_mutex_destroy(& g_mutex);
#line 372
  pthread_mutexattr_destroy(& g_mtxattr);
  }
#line 374
  if (g_state._p) {
    {
#line 375
    free((void *)g_state._p);
    }
  }
  {
#line 377
  memset((void *)(& g_state), 0, sizeof(g_state));
  }
#line 378
  return;
}
}
#line 380 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/smtppass.c"
static void on_quit(int signal___0 ) 
{ 


  {
#line 382
  g_state.quit = 1;
#line 383
  return;
}
}
#line 385 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/smtppass.c"
static void drop_privileges(void) 
{ 
  char *t ;
  struct passwd *pw ;
  uid_t uid ;
  __uid_t tmp ;
  long tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  __uid_t tmp___4 ;

  {
#line 391
  if (g_state.user) {
    {
#line 393
    tmp = geteuid();
    }
#line 393
    if (tmp != 0U) {
      {
#line 395
      sp_messagex((spctx_t *)((void *)0), 4, "must be started as root to switch to user: %s",
                  g_state.user);
      }
#line 396
      return;
    }
    {
#line 399
    tmp___0 = strtol((char const   */* __restrict  */)g_state.user, (char **/* __restrict  */)(& t),
                     10);
#line 399
    uid = (uid_t )tmp___0;
    }
#line 400
    if (! *(t + 0)) {
      {
#line 401
      pw = getpwuid(uid);
      }
    } else {
      {
#line 403
      pw = getpwnam(g_state.user);
      }
    }
#line 405
    if ((unsigned long )pw == (unsigned long )((void *)0)) {
      {
#line 406
      errx(1, "couldn\'t look up user: %s", g_state.user);
      }
    }
    {
#line 408
    tmp___1 = setgid(pw->pw_gid);
    }
#line 408
    if (tmp___1 == -1) {
      {
#line 410
      err(1, "unable to switch to user: %s (uid %d, gid %d)", g_state.user, pw->pw_uid,
          pw->pw_gid);
      }
    } else {
      {
#line 408
      tmp___2 = setuid(pw->pw_uid);
      }
#line 408
      if (tmp___2 == -1) {
        {
#line 410
        err(1, "unable to switch to user: %s (uid %d, gid %d)", g_state.user, pw->pw_uid,
            pw->pw_gid);
        }
      }
    }
    {
#line 413
    tmp___3 = setreuid((__uid_t )-1, (__uid_t )0);
    }
#line 413
    if (tmp___3 == 0) {
      {
#line 414
      err(1, "unable to completely drop privileges");
      }
    }
    {
#line 416
    sp_messagex((spctx_t *)((void *)0), 7, "switched to user %s (uid %d, gid %d)",
                g_state.user, pw->pw_uid, pw->pw_gid);
    }
  }
  {
#line 419
  tmp___4 = geteuid();
  }
#line 419
  if (tmp___4 == 0U) {
    {
#line 420
    sp_messagex((spctx_t *)((void *)0), 4, "running as root is NOT recommended");
    }
  }
#line 421
  return;
}
}
#line 424 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/smtppass.c"
static void pid_file(int write___0 ) 
{ 
  FILE *f ;
  FILE *tmp ;
  __pid_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 426
  if (! g_state.pidfile) {
#line 427
    return;
  }
#line 429
  if (write___0) {
    {
#line 431
    tmp = fopen((char const   */* __restrict  */)g_state.pidfile, (char const   */* __restrict  */)"w");
#line 431
    f = tmp;
    }
#line 432
    if ((unsigned long )f == (unsigned long )((void *)0)) {
      {
#line 434
      sp_message((spctx_t *)((void *)0), 3, "couldn\'t open pid file: %s", g_state.pidfile);
      }
    } else {
      {
#line 438
      tmp___0 = getpid();
#line 438
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%d\n",
              tmp___0);
#line 440
      tmp___1 = ferror(f);
      }
#line 440
      if (tmp___1) {
        {
#line 441
        sp_message((spctx_t *)((void *)0), 3, "couldn\'t write to pid file: %s", g_state.pidfile);
        }
      }
      {
#line 442
      tmp___2 = fclose(f);
      }
#line 442
      if (tmp___2 == -1) {
        {
#line 443
        sp_message((spctx_t *)((void *)0), 3, "couldn\'t write to pid file: %s", g_state.pidfile);
        }
      }
    }
    {
#line 447
    sp_messagex((spctx_t *)((void *)0), 7, "wrote pid file: %s", g_state.pidfile);
    }
  } else {
    {
#line 452
    unlink(g_state.pidfile);
#line 453
    sp_messagex((spctx_t *)((void *)0), 7, "removed pid file: %s", g_state.pidfile);
    }
  }
#line 455
  return;
}
}
#line 457 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/smtppass.c"
static void connection_loop(int sock ) 
{ 
  spthread_t *threads ;
  int fd ;
  int i ;
  int x ;
  int r ;
  void *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;

  {
  {
#line 459
  threads = (spthread_t *)((void *)0);
#line 463
  tmp = calloc((size_t )g_state.max_threads, sizeof(spthread_t ));
#line 463
  threads = (spthread_t *)tmp;
  }
#line 464
  if (! threads) {
    {
#line 466
    sp_messagex((spctx_t *)((void *)0), 2, "out of memory");
    }
#line 467
    return;
  }
  {
#line 471
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 471
    tmp___6 = sp_is_quit();
    }
#line 471
    if (tmp___6) {
#line 471
      goto while_break;
    }
    {
#line 473
    fd = accept(sock, (struct sockaddr */* __restrict  */)((void *)0), (socklen_t */* __restrict  */)((void *)0));
    }
#line 474
    if (fd == -1) {
      {
#line 476
      tmp___0 = __errno_location();
      }
      {
#line 479
      if (*tmp___0 == 11) {
#line 479
        goto case_11;
      }
#line 479
      if (*tmp___0 == 4) {
#line 479
        goto case_11;
      }
#line 482
      if (*tmp___0 == 103) {
#line 482
        goto case_103;
      }
#line 486
      goto switch_default;
      case_11: /* CIL Label */ 
      case_4: /* CIL Label */ 
#line 480
      goto switch_break;
      case_103: /* CIL Label */ 
      {
#line 483
      sp_message((spctx_t *)((void *)0), 3, "couldn\'t accept a connection");
      }
#line 484
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 487
      sp_message((spctx_t *)((void *)0), 3, "couldn\'t accept a connection");
      }
#line 488
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
      {
#line 491
      tmp___1 = sp_is_quit();
      }
#line 491
      if (tmp___1) {
#line 492
        goto while_break;
      }
#line 494
      goto while_continue;
    }
    {
#line 498
    tmp___2 = setsockopt(fd, 1, 20, (void const   *)(& g_state.timeout), (socklen_t )sizeof(g_state.timeout));
    }
#line 498
    if (tmp___2 < 0) {
      {
#line 500
      sp_message((spctx_t *)((void *)0), 7, "couldn\'t set timeouts on incoming connection");
      }
    } else {
      {
#line 498
      tmp___3 = setsockopt(fd, 1, 21, (void const   *)(& g_state.timeout), (socklen_t )sizeof(g_state.timeout));
      }
#line 498
      if (tmp___3 < 0) {
        {
#line 500
        sp_message((spctx_t *)((void *)0), 7, "couldn\'t set timeouts on incoming connection");
        }
      }
    }
    {
#line 502
    tmp___4 = fcntl(fd, 1, 0);
#line 502
    fcntl(fd, 2, tmp___4 | 1);
#line 505
    i = 0;
    }
    {
#line 505
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 505
      if (! (i < g_state.max_threads)) {
#line 505
        goto while_break___0;
      }
#line 508
      if ((threads + i)->tid != 0UL) {
        {
#line 510
        sp_lock();
#line 511
        x = (threads + i)->fd;
#line 512
        sp_unlock();
        }
#line 514
        if (x == -1) {
          {
#line 516
          sp_messagex((spctx_t *)((void *)0), 7, "cleaning up completed thread");
#line 517
          pthread_join((threads + i)->tid, (void **)((void *)0));
#line 518
          (threads + i)->tid = (pthread_t )0;
          }
        }
      }
#line 530
      if (fd != -1) {
#line 530
        if ((threads + i)->tid == 0UL) {
          {
#line 532
          (threads + i)->fd = fd;
#line 533
          r = pthread_create((pthread_t */* __restrict  */)(& (threads + i)->tid),
                             (pthread_attr_t const   */* __restrict  */)((void *)0),
                             & thread_main, (void */* __restrict  */)((void *)(threads + i)));
          }
#line 535
          if (r != 0) {
            {
#line 537
            tmp___5 = __errno_location();
#line 537
            *tmp___5 = r;
#line 538
            sp_message((spctx_t *)((void *)0), 3, "couldn\'t create thread");
#line 540
            write(fd, (void const   *)"421 Local Error, cannot start thread\r\n",
                  (sizeof("421 Local Error, cannot start thread\r\n") - 1UL) / sizeof(char ));
#line 541
            shutdown(fd, 2);
#line 542
            close(fd);
#line 543
            fd = -1;
            }
#line 544
            goto while_break___0;
          }
          {
#line 547
          sp_messagex((spctx_t *)((void *)0), 7, "created thread for connection");
#line 548
          fd = -1;
          }
#line 549
          goto while_break___0;
        }
      }
#line 505
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 554
    if (fd != -1) {
      {
#line 556
      sp_messagex((spctx_t *)((void *)0), 3, "too many connections open (max %d). sent busy response",
                  g_state.max_threads);
#line 557
      write(fd, (void const   *)"421 Server busy, too many connections\r\n", (sizeof("421 Server busy, too many connections\r\n") - 1UL) / sizeof(char ));
#line 558
      shutdown(fd, 2);
#line 559
      close(fd);
#line 560
      fd = -1;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 564
  sp_messagex((spctx_t *)((void *)0), 7, "waiting for threads to quit");
#line 567
  i = 0;
  }
  {
#line 567
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 567
    if (! (i < g_state.max_threads)) {
#line 567
      goto while_break___1;
    }
#line 570
    if ((threads + i)->tid != 0UL) {
#line 572
      if ((threads + i)->fd != -1) {
        {
#line 574
        sp_lock();
#line 575
        fd = (threads + i)->fd;
#line 576
        (threads + i)->fd = -1;
#line 577
        sp_unlock();
#line 579
        shutdown(fd, 2);
#line 580
        close(fd);
        }
      }
      {
#line 583
      sp_messagex((spctx_t *)((void *)0), 7, "cleaning up completed thread");
#line 584
      pthread_join((threads + i)->tid, (void **)((void *)0));
#line 585
      (threads + i)->tid = (pthread_t )0;
      }
    }
#line 567
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 589
  free((void *)threads);
  }
#line 590
  return;
}
}
#line 592 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/smtppass.c"
static spctx_t *init_thread(int fd ) 
{ 
  spctx_t *ctx ;
  unsigned int tmp ;
  pthread_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 596
  ctx = cb_new_context();
  }
#line 597
  if (ctx) {
    {
#line 599
    memset((void *)ctx, 0, sizeof(*ctx));
#line 601
    spio_init(& ctx->server, "SERVER");
#line 602
    spio_init(& ctx->client, "CLIENT");
#line 604
    sp_lock();
#line 606
    tmp = g_unique_id;
#line 606
    g_unique_id ++;
#line 606
    ctx->id = tmp;
    }
#line 609
    if (g_unique_id == 0U) {
#line 610
      g_unique_id ++;
    }
    {
#line 611
    sp_unlock();
#line 613
    tmp___0 = pthread_self();
#line 613
    sp_messagex(ctx, 7, "processing %d on thread %x", fd, (int )tmp___0);
#line 616
    tmp___1 = make_connections(ctx, fd);
    }
#line 616
    if (tmp___1 == -1) {
      {
#line 618
      cb_del_context(ctx);
#line 619
      ctx = (spctx_t *)((void *)0);
      }
    }
  }
#line 623
  return (ctx);
}
}
#line 626 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/smtppass.c"
static void cleanup_context(spctx_t *ctx ) 
{ 


  {
#line 630
  if (ctx->cachefile) {
    {
#line 632
    fclose(ctx->cachefile);
#line 633
    ctx->cachefile = (FILE *)((void *)0);
    }
  }
#line 636
  if (ctx->cachename[0]) {
    {
#line 638
    unlink((char const   *)(ctx->cachename));
#line 639
    ctx->cachename[0] = (char)0;
    }
  }
#line 642
  if (ctx->recipients) {
    {
#line 644
    free((void *)ctx->recipients);
#line 645
    ctx->recipients = (char *)((void *)0);
    }
  }
#line 648
  if (ctx->sender) {
    {
#line 650
    free((void *)ctx->sender);
#line 651
    ctx->sender = (char *)((void *)0);
    }
  }
#line 654
  if (ctx->xforwardaddr) {
    {
#line 656
    free((void *)ctx->xforwardaddr);
#line 657
    ctx->xforwardaddr = (char *)((void *)0);
    }
  }
#line 660
  if (ctx->xforwardhelo) {
    {
#line 662
    free((void *)ctx->xforwardhelo);
#line 663
    ctx->xforwardhelo = (char *)((void *)0);
    }
  }
#line 666
  ctx->logline[0] = (char)0;
#line 667
  return;
}
}
#line 670 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/smtppass.c"
static void done_thread(spctx_t *ctx ) 
{ 


  {
  {
#line 674
  spio_disconnect(ctx, & ctx->client);
#line 675
  spio_disconnect(ctx, & ctx->server);
#line 678
  cleanup_context(ctx);
#line 679
  cb_del_context(ctx);
  }
#line 680
  return;
}
}
#line 682 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/smtppass.c"
static void *thread_main(void *arg ) 
{ 
  spthread_t *thread ;
  spctx_t *ctx ;
  int processing ;
  int ret ;
  int fd ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 684
  thread = (spthread_t *)arg;
#line 685
  ctx = (spctx_t *)((void *)0);
#line 686
  processing = 0;
#line 687
  ret = 0;
#line 692
  siginterrupt(2, 1);
#line 693
  siginterrupt(15, 1);
#line 695
  sp_lock();
#line 697
  fd = thread->fd;
#line 698
  sp_unlock();
#line 701
  tmp = sp_is_quit();
  }
#line 701
  if (tmp) {
    {
#line 704
    close(fd);
#line 707
    ret = -1;
    }
#line 707
    goto cleanup;
  } else {
    {
#line 701
    ctx = init_thread(fd);
    }
#line 701
    if ((unsigned long )ctx == (unsigned long )((void *)0)) {
      {
#line 704
      close(fd);
#line 707
      ret = -1;
      }
#line 707
      goto cleanup;
    }
  }
  {
#line 711
  processing = 1;
#line 712
  ret = smtp_passthru(ctx);
  }
  cleanup: 
#line 716
  if (ctx) {
#line 719
    if (! processing) {
#line 719
      if (ret == -1) {
#line 719
        if (& ctx->client) {
#line 719
          if (ctx->client.fd != -1) {
            {
#line 720
            spio_write_data(ctx, & ctx->client, "421 Local Error, cannot start thread\r\n");
            }
          }
        }
      }
    }
    {
#line 722
    done_thread(ctx);
    }
  }
  {
#line 726
  sp_lock();
#line 727
  thread->fd = -1;
#line 728
  sp_unlock();
  }
#line 730
  if (ret == 0) {
#line 730
    tmp___0 = 0;
  } else {
#line 730
    tmp___0 = 1;
  }
#line 730
  return ((void *)tmp___0);
}
}
#line 733 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/smtppass.c"
static int make_connections(spctx_t *ctx , int client ) 
{ 
  struct sockaddr_any peeraddr ;
  struct sockaddr_any addr ;
  struct sockaddr_any *outaddr ;
  char buf[4096] ;
  char const   *outname ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 744
  spio_attach(ctx, & ctx->client, client, & peeraddr);
#line 745
  sp_messagex(ctx, 6, "accepted connection from: %s", ctx->client.peername);
#line 748
  outaddr = & g_state.outaddr;
#line 749
  outname = g_state.outname;
  }
#line 752
  if (g_state.transparent) {
    {
#line 754
    memset((void *)(& addr), 0, sizeof(addr));
#line 755
    addr.namelen = sizeof(addr);
#line 760
    tmp = getsockname(ctx->client.fd, (struct sockaddr */* __restrict  */)(& addr.s.a),
                      (socklen_t */* __restrict  */)(& addr.namelen));
    }
#line 760
    if (tmp == -1) {
      {
#line 763
      sp_message(ctx, 3, "couldn\'t get source address for transparent proxying");
      }
#line 764
      return (-1);
    }
    {
#line 768
    tmp___0 = sock_any_cmp((struct sockaddr_any  const  *)(& addr), (struct sockaddr_any  const  *)(& peeraddr),
                           16777216);
    }
#line 768
    if (tmp___0 == 0) {
      {
#line 770
      sp_messagex(ctx, 3, "loop detected in transparent proxying");
      }
#line 771
      return (-1);
    }
#line 774
    outaddr = & addr;
  } else
#line 778
  if ((int )outaddr->s.a.sa_family == 2) {
#line 778
    if (outaddr->s.in.sin_addr.s_addr == 0U) {
      {
#line 782
      memcpy((void */* __restrict  */)(& addr), (void const   */* __restrict  */)(& g_state.outaddr),
             sizeof(addr));
#line 783
      memcpy((void */* __restrict  */)(& addr.s.in.sin_addr), (void const   */* __restrict  */)(& peeraddr.s.in.sin_addr),
             sizeof(addr.s.in.sin_addr));
#line 784
      outaddr = & addr;
      }
    } else {
#line 778
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 802
    tmp___1 = sock_any_pton(g_state.outname, & addr, 25);
    }
#line 802
    if (tmp___1 != -1) {
      {
#line 803
      memcpy((void */* __restrict  */)(& g_state.outaddr), (void const   */* __restrict  */)(& addr),
             sizeof(g_state.outaddr));
      }
    } else {
      {
#line 805
      sp_messagex(ctx, 4, "couldn\'t resolve OutAddress: %s", g_state.outname);
      }
    }
  }
#line 809
  if ((unsigned long )outaddr != (unsigned long )(& g_state.outaddr)) {
    {
#line 811
    tmp___2 = sock_any_ntop((struct sockaddr_any  const  *)outaddr, buf, (size_t )4096,
                            0);
    }
#line 811
    if (tmp___2 != -1) {
#line 812
      outname = (char const   *)(buf);
    } else {
#line 814
      outname = "unknown";
    }
  }
  {
#line 818
  tmp___3 = spio_connect(ctx, & ctx->server, (struct sockaddr_any  const  *)outaddr,
                         outname);
  }
#line 818
  if (tmp___3 == -1) {
#line 819
    return (-1);
  }
#line 821
  return (0);
}
}
#line 828 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/smtppass.c"
static int smtp_passthru(spctx_t *ctx ) 
{ 
  char *t ;
  char const   *p ;
  int r ;
  int cont ;
  int ret ;
  unsigned int mask ;
  int neterror ;
  int first_rsp ;
  int filter_host ;
  int xclient_sup ;
  int xclient_sent ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  char const   *tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  char *tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  size_t tmp___29 ;
  void *tmp___30 ;
  size_t tmp___31 ;
  size_t tmp___32 ;
  void *tmp___33 ;
  size_t tmp___34 ;
  void *tmp___35 ;
  size_t tmp___36 ;
  void *tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;

  {
#line 832
  ret = 0;
#line 834
  neterror = 0;
#line 836
  first_rsp = 1;
#line 837
  filter_host = 0;
#line 840
  xclient_sup = 0;
#line 841
  xclient_sent = 0;
  {
#line 849
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 849
    tmp___41 = sp_is_quit();
    }
#line 849
    if (tmp___41) {
#line 849
      goto while_break;
    }
    {
#line 851
    mask = spio_select(ctx, & ctx->client, & ctx->server, (void *)0);
    }
#line 853
    if (mask == 4294967295U) {
#line 855
      neterror = 1;
#line 856
      ret = -1;
#line 856
      goto cleanup;
    }
#line 860
    if (mask & 1U) {
      {
#line 862
      r = spio_read_line(ctx, & ctx->client, 2);
      }
#line 862
      if (r == -1) {
#line 863
        ret = -1;
#line 863
        goto cleanup;
      }
#line 866
      if (r == 0) {
#line 867
        ret = 0;
#line 867
        goto cleanup;
      }
#line 870
      if (r >= 4222) {
        {
#line 872
        tmp = spio_write_data(ctx, & ctx->client, "500 Line too long\r\n");
        }
#line 872
        if (tmp == -1) {
#line 873
          ret = -1;
#line 873
          goto cleanup;
        }
#line 875
        goto while_continue;
      }
#line 879
      filter_host = 0;
#line 885
      if (xclient_sup) {
#line 885
        if (! xclient_sent) {
#line 885
          if (g_state.xclient) {
            {
#line 887
            sp_messagex(ctx, 7, "sending XCLIENT");
#line 889
            tmp___0 = spio_write_dataf(ctx, & ctx->server, "XCLIENT ADDR=%s\r\n",
                                       ctx->client.peername);
            }
#line 889
            if (tmp___0 == -1) {
#line 890
              ret = -1;
#line 890
              goto cleanup;
            }
            {
#line 892
            tmp___1 = read_server_response(ctx);
            }
#line 892
            if (tmp___1 == -1) {
#line 893
              ret = -1;
#line 893
              goto cleanup;
            }
            {
#line 895
            tmp___2 = get_successful_rsp((char const   *)(ctx->server.line), (int *)((void *)0));
            }
#line 895
            if (! tmp___2) {
              {
#line 896
              sp_messagex(ctx, 4, "server didn\'t accept XCLIENT");
              }
            }
#line 898
            xclient_sent = 1;
          }
        }
      }
      {
#line 902
      tmp___12 = is_first_word((char const   *)(ctx->client.line), "DATA", (int )((sizeof("DATA") - 1UL) / sizeof(char )));
      }
#line 902
      if (tmp___12) {
        {
#line 905
        tmp___3 = spio_write_data(ctx, & ctx->client, "354 Start mail input; end with <CRLF>.<CRLF>\r\n");
        }
#line 905
        if (tmp___3 == -1) {
#line 906
          ret = -1;
#line 906
          goto cleanup;
        }
        {
#line 913
        tmp___4 = cb_check_data(ctx);
        }
#line 913
        if (tmp___4 == -1) {
#line 914
          ret = -1;
#line 914
          goto cleanup;
        }
        {
#line 917
        sp_messagex(ctx, 6, "%s", ctx->logline);
#line 920
        cleanup_context(ctx);
        }
#line 923
        goto while_continue;
      } else {
        {
#line 930
        tmp___11 = is_first_word((char const   *)(ctx->client.line), "EHLO", (int )((sizeof("EHLO") - 1UL) / sizeof(char )));
        }
#line 930
        if (tmp___11) {
#line 933
          filter_host = 1;
        } else {
          {
#line 941
          tmp___10 = is_first_word((char const   *)(ctx->client.line), "HELO", (int )((sizeof("HELO") - 1UL) / sizeof(char )));
          }
#line 941
          if (tmp___10) {
            {
#line 943
            sp_messagex(ctx, 7, "XCLIENT support assumed");
#line 944
            xclient_sup = 1;
#line 947
            filter_host = 1;
            }
          } else {
            {
#line 955
            tmp___8 = is_first_word((char const   *)(ctx->client.line), "STARTTLS",
                                    (int )((sizeof("STARTTLS") - 1UL) / sizeof(char )));
            }
#line 955
            if (tmp___8) {
#line 955
              goto _L;
            } else {
              {
#line 955
              tmp___9 = is_first_word((char const   *)(ctx->client.line), "BDAT",
                                      (int )((sizeof("BDAT") - 1UL) / sizeof(char )));
              }
#line 955
              if (tmp___9) {
                _L: /* CIL Label */ 
                {
#line 958
                sp_messagex(ctx, 7, "ESMTP feature not supported");
#line 960
                tmp___5 = spio_write_data(ctx, & ctx->client, "502 Command not implemented\r\n");
                }
#line 960
                if (tmp___5 == -1) {
#line 961
                  ret = -1;
#line 961
                  goto cleanup;
                }
#line 964
                goto while_continue;
              } else {
                {
#line 972
                tmp___7 = is_first_word((char const   *)(ctx->client.line), "XCLIENT",
                                        (int )((sizeof("XCLIENT") - 1UL) / sizeof(char )));
                }
#line 972
                if (tmp___7) {
                  {
#line 974
                  sp_messagex(ctx, 4, "client attempted use of privileged XCLIENT feature");
#line 976
                  tmp___6 = spio_write_data(ctx, & ctx->client, "554 Insufficient authorization\r\n");
                  }
#line 976
                  if (tmp___6 == -1) {
#line 977
                    ret = -1;
#line 977
                    goto cleanup;
                  }
#line 980
                  goto while_continue;
                }
              }
            }
          }
        }
      }
      {
#line 984
      tmp___13 = spio_write_data(ctx, & ctx->server, (char const   *)(ctx->client.line));
      }
#line 984
      if (tmp___13 == -1) {
#line 985
        ret = -1;
#line 985
        goto cleanup;
      }
#line 987
      goto while_continue;
    }
#line 991
    if (mask & 2U) {
      {
#line 993
      r = spio_read_line(ctx, & ctx->server, 2);
      }
#line 993
      if (r == -1) {
#line 994
        ret = -1;
#line 994
        goto cleanup;
      }
#line 996
      if (r == 0) {
#line 997
        ret = 0;
#line 997
        goto cleanup;
      }
#line 999
      if (r >= 4222) {
        {
#line 1000
        sp_messagex(ctx, 4, "SMTP response line too long. discarded extra");
        }
      }
#line 1014
      if (first_rsp) {
        {
#line 1016
        first_rsp = 0;
#line 1018
        tmp___15 = is_first_word((char const   *)(ctx->server.line), "220", (int )((sizeof("220") - 1UL) / sizeof(char )));
        }
#line 1018
        if (tmp___15) {
          {
#line 1020
          sp_messagex(ctx, 7, "intercepting initial response");
#line 1022
          tmp___14 = spio_write_data(ctx, & ctx->client, "220 smtp.passthru\r\n");
          }
#line 1022
          if (tmp___14 == -1) {
#line 1023
            ret = -1;
#line 1023
            goto cleanup;
          }
#line 1026
          goto while_continue;
        }
      }
      {
#line 1030
      p = get_successful_rsp((char const   *)(ctx->server.line), & cont);
      }
#line 1030
      if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 1037
        if (filter_host) {
          {
#line 1041
          filter_host = 0;
#line 1043
          sp_messagex(ctx, 7, "intercepting host response");
          }
#line 1045
          if (cont) {
#line 1045
            tmp___16 = "250-smtp.passthru\r\n";
          } else {
#line 1045
            tmp___16 = "250 smtp.passthru\r\n";
          }
          {
#line 1045
          tmp___17 = spio_write_data(ctx, & ctx->client, tmp___16);
          }
#line 1045
          if (tmp___17 == -1) {
#line 1047
            ret = -1;
#line 1047
            goto cleanup;
          }
          {
#line 1050
          cleanup_context(ctx);
          }
#line 1052
          goto while_continue;
        }
        {
#line 1059
        tmp___28 = is_first_word((char const   *)(ctx->client.line), "EHLO", (int )((sizeof("EHLO") - 1UL) / sizeof(char )));
        }
#line 1059
        if (tmp___28) {
          {
#line 1065
          tmp___18 = is_first_word(p, "XCLIENT", (int )((sizeof("XCLIENT") - 1UL) / sizeof(char )));
          }
#line 1065
          if (tmp___18) {
            {
#line 1067
            sp_messagex(ctx, 7, "XCLIENT supported");
#line 1068
            xclient_sup = 1;
            }
          }
          {
#line 1071
          tmp___21 = is_first_word(p, "PIPELINING", (int )((sizeof("PIPELINING") - 1UL) / sizeof(char )));
          }
#line 1071
          if (tmp___21) {
#line 1071
            goto _L___0;
          } else {
            {
#line 1071
            tmp___22 = is_first_word(p, "STARTTLS", (int )((sizeof("STARTTLS") - 1UL) / sizeof(char )));
            }
#line 1071
            if (tmp___22) {
#line 1071
              goto _L___0;
            } else {
              {
#line 1071
              tmp___23 = is_first_word(p, "CHUNKING", (int )((sizeof("CHUNKING") - 1UL) / sizeof(char )));
              }
#line 1071
              if (tmp___23) {
#line 1071
                goto _L___0;
              } else {
                {
#line 1071
                tmp___24 = is_first_word(p, "BINARYMIME", (int )((sizeof("BINARYMIME") - 1UL) / sizeof(char )));
                }
#line 1071
                if (tmp___24) {
#line 1071
                  goto _L___0;
                } else {
                  {
#line 1071
                  tmp___25 = is_first_word(p, "CHECKPOINT", (int )((sizeof("CHECKPOINT") - 1UL) / sizeof(char )));
                  }
#line 1071
                  if (tmp___25) {
#line 1071
                    goto _L___0;
                  } else {
                    {
#line 1071
                    tmp___26 = is_first_word(p, "XCLIENT", (int )((sizeof("XCLIENT") - 1UL) / sizeof(char )));
                    }
#line 1071
                    if (tmp___26) {
#line 1071
                      goto _L___0;
                    } else {
                      {
#line 1071
                      tmp___27 = is_first_word(p, "XEXCH50", (int )((sizeof("XEXCH50") - 1UL) / sizeof(char )));
                      }
#line 1071
                      if (tmp___27) {
                        _L___0: /* CIL Label */ 
                        {
#line 1079
                        tmp___19 = trim_space((char *)p);
#line 1079
                        sp_messagex(ctx, 7, "filtered ESMTP feature: %s", tmp___19);
                        }
#line 1085
                        if (! cont) {
                          {
#line 1087
                          tmp___20 = spio_write_data(ctx, & ctx->client, "250 XFILTERED\r\n");
                          }
#line 1087
                          if (tmp___20 == -1) {
#line 1088
                            ret = -1;
#line 1088
                            goto cleanup;
                          }
                        }
#line 1091
                        goto while_continue;
                      }
                    }
                  }
                }
              }
            }
          }
        }
        {
#line 1096
        r = check_first_word((char const   *)(ctx->client.line), "MAIL FROM", (int )((sizeof("MAIL FROM") - 1UL) / sizeof(char )),
                             (char *)"\r\n\t :");
        }
#line 1096
        if (r > 0) {
          {
#line 1098
          t = parse_address(ctx->client.line + r);
#line 1099
          sp_add_log(ctx, (char *)"from=", t);
#line 1102
          tmp___29 = strlen((char const   *)t);
#line 1102
          tmp___30 = reallocf((void *)ctx->sender, tmp___29 + 1UL);
#line 1102
          ctx->sender = (char *)tmp___30;
          }
#line 1103
          if (ctx->sender) {
            {
#line 1104
            strcpy((char */* __restrict  */)ctx->sender, (char const   */* __restrict  */)t);
            }
          }
        } else {
          {
#line 1108
          r = check_first_word((char const   *)(ctx->client.line), "RCPT TO", (int )((sizeof("RCPT TO") - 1UL) / sizeof(char )),
                               (char *)"\r\n\t :");
          }
#line 1108
          if (r > 0) {
            {
#line 1110
            t = parse_address(ctx->client.line + r);
#line 1111
            sp_add_log(ctx, (char *)"to=", t);
            }
#line 1114
            if (ctx->recipients) {
              {
#line 1114
              tmp___31 = strlen((char const   *)ctx->recipients);
#line 1114
              r = (int )tmp___31;
              }
            } else {
#line 1114
              r = 0;
            }
            {
#line 1115
            tmp___32 = strlen((char const   *)t);
#line 1115
            tmp___33 = reallocf((void *)ctx->recipients, ((size_t )r + tmp___32) + 2UL);
#line 1115
            ctx->recipients = (char *)tmp___33;
            }
#line 1116
            if (ctx->recipients) {
#line 1119
              if (r != 0) {
                {
#line 1120
                strcat((char */* __restrict  */)ctx->recipients, (char const   */* __restrict  */)"\n");
                }
              } else {
#line 1122
                *(ctx->recipients + 0) = (char)0;
              }
              {
#line 1124
              strcat((char */* __restrict  */)ctx->recipients, (char const   */* __restrict  */)t);
              }
            }
          } else {
            {
#line 1133
            tmp___39 = is_first_word((char const   *)(ctx->client.line), "XFORWARD",
                                     (int )((sizeof("XFORWARD") - 1UL) / sizeof(char )));
            }
#line 1133
            if (tmp___39) {
              {
#line 1135
              t = parse_xforward(ctx->client.line + (sizeof("XFORWARD") - 1UL) / sizeof(char ),
                                 "ADDR");
              }
#line 1135
              if (t) {
                {
#line 1137
                tmp___34 = strlen((char const   *)t);
#line 1137
                tmp___35 = reallocf((void *)ctx->xforwardaddr, tmp___34 + 1UL);
#line 1137
                ctx->xforwardaddr = (char *)tmp___35;
                }
#line 1138
                if (ctx->xforwardaddr) {
                  {
#line 1139
                  strcpy((char */* __restrict  */)ctx->xforwardaddr, (char const   */* __restrict  */)t);
                  }
                }
              }
              {
#line 1142
              t = parse_xforward(ctx->client.line + (sizeof("XFORWARD") - 1UL) / sizeof(char ),
                                 "HELO");
              }
#line 1142
              if (t) {
                {
#line 1144
                tmp___36 = strlen((char const   *)t);
#line 1144
                tmp___37 = reallocf((void *)ctx->xforwardhelo, tmp___36 + 1UL);
#line 1144
                ctx->xforwardhelo = (char *)tmp___37;
                }
#line 1145
                if (ctx->xforwardhelo) {
                  {
#line 1146
                  strcpy((char */* __restrict  */)ctx->xforwardhelo, (char const   */* __restrict  */)t);
                  }
                }
              }
            } else {
              {
#line 1152
              tmp___38 = is_first_word((char const   *)(ctx->client.line), "RSET",
                                       (int )((sizeof("RSET") - 1UL) / sizeof(char )));
              }
#line 1152
              if (tmp___38) {
                {
#line 1154
                cleanup_context(ctx);
                }
              }
            }
          }
        }
      }
      {
#line 1158
      tmp___40 = spio_write_data(ctx, & ctx->client, (char const   *)(ctx->server.line));
      }
#line 1158
      if (tmp___40 == -1) {
#line 1159
        ret = -1;
#line 1159
        goto cleanup;
      }
#line 1161
      goto while_continue;
    }
  }
  while_break: /* CIL Label */ ;
  }
  cleanup: 
#line 1167
  if (! neterror) {
#line 1167
    if (ret == -1) {
#line 1167
      if (& ctx->client) {
#line 1167
        if (ctx->client.fd != -1) {
          {
#line 1168
          spio_write_data(ctx, & ctx->client, "451 Local Error\r\n");
          }
        }
      }
    }
  }
#line 1170
  return (ret);
}
}
#line 1177 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/smtppass.c"
static char *parse_address(char *line ) 
{ 
  char *t ;
  int tmp ;
  char *tmp___0 ;

  {
  {
#line 1180
  line = trim_start((char const   *)line);
#line 1187
  tmp = strncmp((char const   *)line, "<>", (size_t )2);
  }
#line 1187
  if (tmp == 0) {
#line 1188
    return ((char *)"<>");
  }
#line 1190
  if ((int )*(line + 0) == 60) {
    {
#line 1192
    t = strchr((char const   *)line, '>');
    }
#line 1192
    if ((unsigned long )t != (unsigned long )((void *)0)) {
#line 1194
      *t = (char)0;
#line 1195
      line ++;
#line 1196
      return (line);
    }
  }
  {
#line 1200
  tmp___0 = trim_end(line);
  }
#line 1200
  return (tmp___0);
}
}
#line 1203 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/smtppass.c"
static char *parse_xforward(char *line , char const   *part ) 
{ 
  char *t ;
  char *e ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 1208
  t = strcasestr((char const   *)line, part);
  }
#line 1209
  if (! t) {
#line 1210
    return ((char *)((void *)0));
  }
  {
#line 1213
  tmp = strlen(part);
#line 1213
  t = trim_start((char const   *)(t + tmp));
  }
#line 1214
  if ((int )*t != 61) {
#line 1215
    return ((char *)((void *)0));
  }
  {
#line 1216
  t = trim_start((char const   *)(t + 1));
  }
#line 1217
  if (! *t) {
#line 1218
    return ((char *)((void *)0));
  }
#line 1221
  if ((int )*t == 91) {
    {
#line 1223
    t ++;
#line 1224
    e = strchr((char const   *)t, ']');
    }
  } else {
    {
#line 1228
    tmp___0 = strcspn((char const   *)t, " \t");
#line 1228
    e = t + tmp___0;
    }
  }
#line 1231
  if (! e) {
#line 1232
    return ((char *)((void *)0));
  }
#line 1233
  *e = (char)0;
#line 1234
  return (t);
}
}
#line 1237 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/smtppass.c"
static char const   *get_successful_rsp(char const   *line , int *cont ) 
{ 
  char *tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
  {
#line 1244
  tmp = trim_start(line);
#line 1244
  line = (char const   *)tmp;
  }
#line 1246
  if ((int const   )*(line + 0) == 50) {
    {
#line 1246
    tmp___0 = __ctype_b_loc();
    }
#line 1246
    if ((int const   )*(*tmp___0 + (int )*(line + 1)) & 2048) {
      {
#line 1246
      tmp___1 = __ctype_b_loc();
      }
#line 1246
      if ((int const   )*(*tmp___1 + (int )*(line + 2)) & 2048) {
#line 1246
        if ((int const   )*(line + 3) == 32) {
#line 1246
          goto _L;
        } else
#line 1246
        if ((int const   )*(line + 3) == 45) {
          _L: /* CIL Label */ 
#line 1249
          if (cont) {
#line 1250
            *cont = (int const   )*(line + 3) == 45;
          }
#line 1251
          return (line + 4);
        }
      }
    }
  }
#line 1254
  return ((char const   *)((void *)0));
}
}
#line 1257 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/smtppass.c"
void sp_add_log(spctx_t *ctx , char *prefix , char *line ) 
{ 
  char *t ;
  int l ;
  size_t tmp ;
  int x ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 1259
  t = ctx->logline;
#line 1260
  tmp = strlen((char const   *)t);
#line 1260
  l = (int )tmp;
#line 1266
  tmp___0 = strlen((char const   *)prefix);
#line 1266
  tmp___1 = strlen((char const   *)line);
#line 1266
  x = (int )(((2UL + tmp___0) + tmp___1) + 1UL);
  }
#line 1268
  if (l + x >= 768) {
#line 1269
    l = 768 - x;
  }
#line 1271
  t += l;
#line 1272
  l = 768 - l;
#line 1274
  *t = (char)0;
#line 1276
  if ((int )ctx->logline[0] != 0) {
    {
#line 1277
    strlcat(t, ", ", (size_t )l);
    }
  }
  {
#line 1279
  strlcat(t, (char const   *)prefix, (size_t )l);
#line 1282
  line = trim_start((char const   *)line);
#line 1284
  strlcat(t, (char const   *)line, (size_t )l);
#line 1287
  trim_end(t);
  }
#line 1288
  return;
}
}
#line 1290 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/smtppass.c"
int sp_read_data(spctx_t *ctx , char const   **data ) 
{ 
  int r ;
  time_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1297
  *data = (char const   *)((void *)0);
#line 1299
  r = spio_read_line(ctx, & ctx->client, 4);
  }
  {
#line 1301
  if (r == 0) {
#line 1301
    goto case_0;
  }
#line 1304
  if (r == -1) {
#line 1304
    goto case_neg_1;
  }
#line 1299
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 1302
  sp_messagex(ctx, 3, "unexpected end of data from client");
  }
#line 1303
  return (-1);
  case_neg_1: /* CIL Label */ 
#line 1306
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 1309
  if (g_state.keepalives > 0) {
    {
#line 1316
    tmp = time((time_t *)((void *)0));
    }
#line 1316
    if (ctx->server.last_action + (time_t )g_state.keepalives < tmp) {
      {
#line 1317
      do_server_noop(ctx);
      }
    }
  }
#line 1320
  if (ctx->_crlf) {
    {
#line 1320
    tmp___0 = strcmp((char const   *)(ctx->client.line), ".\r\n");
    }
#line 1320
    if (tmp___0 == 0) {
#line 1321
      return (0);
    }
  }
  {
#line 1324
  tmp___1 = strcmp("\r\n", (char const   *)(ctx->client.line + ((unsigned long )r - (sizeof("\r\n") - 1UL) / sizeof(char ))));
#line 1324
  ctx->_crlf = tmp___1 == 0;
#line 1325
  *data = (char const   *)(ctx->client.line);
  }
#line 1326
  return (r);
}
}
#line 1329 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/smtppass.c"
int sp_write_data(spctx_t *ctx , char const   *buf , int len ) 
{ 
  int r ;
  int tmp ;
  int tfd ;
  FILE *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1331
  r = 0;
#line 1336
  if (! buf) {
#line 1338
    if (ctx->cachefile) {
      {
#line 1340
      tmp = fclose(ctx->cachefile);
      }
#line 1340
      if (tmp == -1) {
        {
#line 1342
        sp_message(ctx, 3, "couldn\'t write to cache file: %s", ctx->cachename);
#line 1343
        r = -1;
        }
      }
#line 1346
      ctx->cachefile = (FILE *)((void *)0);
    }
#line 1349
    return (r);
  }
#line 1353
  if (! ctx->cachefile) {
#line 1358
    if (ctx->cachename[0]) {
      {
#line 1359
      unlink((char const   *)(ctx->cachename));
      }
    }
    {
#line 1361
    snprintf((char */* __restrict  */)(ctx->cachename), (size_t )4096, (char const   */* __restrict  */)"%s/%s.XXXXXX",
             g_state.directory, g_state.name);
#line 1364
    tfd = mkstemp(ctx->cachename);
    }
#line 1364
    if (tfd == -1) {
#line 1364
      goto _L;
    } else {
      {
#line 1364
      tmp___0 = fdopen(tfd, "w");
#line 1364
      ctx->cachefile = tmp___0;
      }
#line 1364
      if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
        _L: /* CIL Label */ 
#line 1367
        if (tfd != -1) {
          {
#line 1368
          close(tfd);
          }
        }
        {
#line 1370
        sp_message(ctx, 3, "couldn\'t open cache file");
        }
#line 1371
        return (-1);
      }
    }
    {
#line 1374
    tmp___1 = fcntl(tfd, 1, 0);
#line 1374
    fcntl(tfd, 2, tmp___1 | 1);
#line 1375
    sp_messagex(ctx, 7, "created cache file: %s", ctx->cachename);
    }
  }
  {
#line 1378
  fwrite((void const   */* __restrict  */)buf, (size_t )1, (size_t )len, (FILE */* __restrict  */)ctx->cachefile);
#line 1380
  tmp___2 = ferror(ctx->cachefile);
  }
#line 1380
  if (tmp___2) {
    {
#line 1382
    sp_message(ctx, 3, "couldn\'t write to cache file: %s", ctx->cachename);
    }
#line 1383
    return (-1);
  }
#line 1386
  return (len);
}
}
#line 1389 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/smtppass.c"
int sp_cache_data(spctx_t *ctx ) 
{ 
  int r ;
  int count ;
  char const   *data ;
  int tmp ;

  {
#line 1391
  count = 0;
  {
#line 1394
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1394
    r = sp_read_data(ctx, & data);
    }
#line 1394
    if (! (r != 0)) {
#line 1394
      goto while_break;
    }
#line 1396
    if (r < 0) {
#line 1397
      return (-1);
    }
    {
#line 1399
    count += r;
#line 1401
    r = sp_write_data(ctx, data, r);
    }
#line 1401
    if (r < 0) {
#line 1402
      return (-1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1406
  tmp = sp_write_data(ctx, (char const   *)((void *)0), 0);
  }
#line 1406
  if (tmp < 0) {
#line 1407
    return (-1);
  }
  {
#line 1409
  sp_messagex(ctx, 7, "wrote %d bytes to cache", count);
  }
#line 1410
  return (count);
}
}
#line 1414 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/smtppass.c"
static void make_date(spctx_t *ctx , char *date ) 
{ 
  size_t date_len ;
  struct tm t2 ;
  time_t t ;
  time_t tmp ;
  struct tm *tmp___0 ;
  char *tmp___1 ;
  time_t timezone___0 ;
  char const   *tzname___0[2] ;
  int tmp___2 ;

  {
  {
#line 1421
  tmp = time(& t);
  }
#line 1421
  if (tmp == -1L) {
    {
#line 1425
    sp_message(ctx, 4, "unable to get date for header");
#line 1426
    *(date + 0) = (char)0;
    }
#line 1427
    return;
  } else {
    {
#line 1421
    tmp___0 = localtime_r((time_t const   */* __restrict  */)(& t), (struct tm */* __restrict  */)(& t2));
    }
#line 1421
    if (tmp___0) {
      {
#line 1421
      tmp___1 = asctime_r((struct tm  const  */* __restrict  */)(& t2), (char */* __restrict  */)date);
      }
#line 1421
      if (! tmp___1) {
        {
#line 1425
        sp_message(ctx, 4, "unable to get date for header");
#line 1426
        *(date + 0) = (char)0;
        }
#line 1427
        return;
      }
    } else {
      {
#line 1425
      sp_message(ctx, 4, "unable to get date for header");
#line 1426
      *(date + 0) = (char)0;
      }
#line 1427
      return;
    }
  }
  {
#line 1430
  trim_end(date);
#line 1431
  date_len = strlen((char const   *)date);
#line 1435
  timezone___0 = t2.tm_gmtoff;
#line 1436
  tzname___0[0] = t2.tm_zone;
#line 1436
  tzname___0[1] = t2.tm_zone;
  }
#line 1438
  if (t2.tm_isdst) {
#line 1438
    tmp___2 = 1;
  } else {
#line 1438
    tmp___2 = 0;
  }
  {
#line 1438
  snprintf((char */* __restrict  */)(date + date_len), 64UL - date_len, (char const   */* __restrict  */)" %+03d%02d (%s)",
           (int )(timezone___0 / 3600L), (int )(timezone___0 % 3600L), tzname___0[tmp___2]);
#line 1475
  *(date + 63) = (char)0;
  }
#line 1476
  return;
}
}
#line 1479 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/smtppass.c"
static int make_header(spctx_t *ctx , char const   *format_str , char *header ) 
{ 
  char date[64] ;
  int remaining ;
  int l ;
  char const   *f ;
  char *p ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
#line 1486
  date[0] = (char)0;
#line 1487
  remaining = 1023;
#line 1488
  p = header;
#line 1491
  f = format_str;
  {
#line 1491
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1491
    if (*f) {
#line 1491
      if (! (remaining > 0)) {
#line 1491
        goto while_break;
      }
    } else {
#line 1491
      goto while_break;
    }
#line 1494
    if ((int const   )*(f + 0) == 92) {
#line 1494
      if ((int const   )*(f + 1) != 0) {
#line 1496
        f ++;
        {
#line 1498
        if ((int const   )*f == 114) {
#line 1498
          goto case_114;
        }
#line 1501
        if ((int const   )*f == 110) {
#line 1501
          goto case_110;
        }
#line 1504
        if ((int const   )*f == 116) {
#line 1504
          goto case_116;
        }
#line 1507
        goto switch_default;
        case_114: /* CIL Label */ 
#line 1499
        *p = (char )'\r';
#line 1500
        goto switch_break;
        case_110: /* CIL Label */ 
#line 1502
        *p = (char )'\n';
#line 1503
        goto switch_break;
        case_116: /* CIL Label */ 
#line 1505
        *p = (char )'\t';
#line 1506
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 1508
        *p = (char )*f;
#line 1509
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
#line 1512
        p ++;
#line 1513
        remaining --;
      } else {
#line 1494
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1522
    if ((int const   )*(f + 0) == 37) {
#line 1522
      if ((int const   )*(f + 1) != 0) {
#line 1524
        f ++;
        {
#line 1526
        if ((int const   )*f == 105) {
#line 1526
          goto case_105;
        }
#line 1532
        if ((int const   )*f == 108) {
#line 1532
          goto case_108;
        }
#line 1538
        if ((int const   )*f == 100) {
#line 1538
          goto case_100;
        }
#line 1546
        if ((int const   )*f == 37) {
#line 1546
          goto case_37;
        }
#line 1550
        goto switch_default___0;
        case_105: /* CIL Label */ 
        {
#line 1527
        tmp = strlen((char const   *)(ctx->client.peername));
#line 1527
        l = (int )tmp;
#line 1528
        strncpy((char */* __restrict  */)p, (char const   */* __restrict  */)(ctx->client.peername),
                (size_t )remaining);
#line 1529
        remaining -= l;
#line 1530
        p += l;
        }
#line 1531
        goto switch_break___0;
        case_108: /* CIL Label */ 
        {
#line 1533
        tmp___0 = strlen((char const   *)(ctx->client.localname));
#line 1533
        l = (int )tmp___0;
#line 1534
        strncpy((char */* __restrict  */)p, (char const   */* __restrict  */)(ctx->client.localname),
                (size_t )remaining);
#line 1535
        remaining -= l;
#line 1536
        p += l;
        }
#line 1537
        goto switch_break___0;
        case_100: /* CIL Label */ 
#line 1539
        if ((int )date[0] == 0) {
          {
#line 1540
          make_date(ctx, date);
          }
        }
        {
#line 1541
        tmp___1 = strlen((char const   *)(date));
#line 1541
        l = (int )tmp___1;
#line 1542
        strncpy((char */* __restrict  */)p, (char const   */* __restrict  */)(date),
                (size_t )remaining);
#line 1543
        remaining -= l;
#line 1544
        p += l;
        }
#line 1545
        goto switch_break___0;
        case_37: /* CIL Label */ 
#line 1547
        *p = (char )'%';
#line 1548
        p ++;
#line 1549
        goto switch_break___0;
        switch_default___0: /* CIL Label */ 
        {
#line 1551
        sp_messagex(ctx, 4, "invalid header symbol: %%%c", (int const   )*f);
        }
#line 1552
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
      } else {
#line 1558
        tmp___2 = p;
#line 1558
        p ++;
#line 1558
        *tmp___2 = (char )*f;
#line 1559
        remaining --;
      }
    } else {
#line 1558
      tmp___2 = p;
#line 1558
      p ++;
#line 1558
      *tmp___2 = (char )*f;
#line 1559
      remaining --;
    }
#line 1491
    f ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1563
  if ((unsigned long )(p + 1) < (unsigned long )(header + 1024)) {
#line 1564
    *(p + 1) = (char)0;
  }
#line 1565
  *(header + 1023) = (char)0;
#line 1566
  l = (int )(p - header);
#line 1567
  if (l >= 1024) {
#line 1567
    tmp___3 = 1023;
  } else {
#line 1567
    tmp___3 = l;
  }
#line 1567
  return (tmp___3);
}
}
#line 1570 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/smtppass.c"
int sp_done_data(spctx_t *ctx , char const   *headertmpl ) 
{ 
  FILE *file ;
  int ret ;
  char *line ;
  char header[1024] ;
  unsigned int tmp ;
  size_t header_len ;
  size_t line_len ;
  int header_prepend ;
  ssize_t rc ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;

  {
#line 1572
  file = (FILE *)0;
#line 1573
  ret = 0;
#line 1575
  header[0] = (char )'\000';
#line 1575
  tmp = 1U;
  {
#line 1575
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1575
    if (tmp >= 1024U) {
#line 1575
      goto while_break;
    }
#line 1575
    header[tmp] = (char)0;
#line 1575
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1577
  header_prepend = 0;
#line 1583
  memset((void *)(header), 0, sizeof(header));
#line 1586
  line_len = (size_t )4224;
#line 1587
  tmp___0 = malloc(line_len);
#line 1587
  line = (char *)tmp___0;
  }
#line 1587
  if ((unsigned long )line == (unsigned long )((void *)0)) {
#line 1588
    ret = -1;
#line 1588
    goto cleanup;
  }
  {
#line 1591
  file = fopen((char const   */* __restrict  */)(ctx->cachename), (char const   */* __restrict  */)"r");
  }
#line 1592
  if ((unsigned long )file == (unsigned long )((void *)0)) {
    {
#line 1594
    sp_message(ctx, 3, "couldn\'t open cache file: %s", ctx->cachename);
#line 1595
    ret = -1;
    }
#line 1595
    goto cleanup;
  }
  {
#line 1599
  tmp___1 = spio_write_data(ctx, & ctx->server, "DATA\r\n");
  }
#line 1599
  if (tmp___1 == -1) {
#line 1600
    ret = -1;
#line 1600
    goto cleanup;
  }
  {
#line 1602
  tmp___2 = read_server_response(ctx);
  }
#line 1602
  if (tmp___2 == -1) {
#line 1603
    ret = -1;
#line 1603
    goto cleanup;
  }
  {
#line 1606
  tmp___4 = is_first_word((char const   *)(ctx->server.line), "354", (int )((sizeof("354") - 1UL) / sizeof(char )));
  }
#line 1606
  if (! tmp___4) {
    {
#line 1608
    tmp___3 = spio_write_data(ctx, & ctx->client, (char const   *)(ctx->server.line));
    }
#line 1608
    if (tmp___3 == -1) {
#line 1609
      ret = -1;
#line 1609
      goto cleanup;
    }
    {
#line 1611
    sp_messagex(ctx, 7, "server refused data transfer");
#line 1613
    ret = 0;
    }
#line 1613
    goto cleanup;
  }
  {
#line 1616
  sp_messagex(ctx, 7, "sending from cache file: %s", ctx->cachename);
  }
#line 1618
  if (headertmpl) {
    {
#line 1620
    tmp___5 = make_header(ctx, headertmpl, header);
#line 1620
    header_len = (size_t )tmp___5;
#line 1621
    tmp___6 = is_first_word("Received:", (char const   *)(header), (int )((sizeof("Received:") - 1UL) / sizeof(char )));
    }
#line 1621
    if (tmp___6) {
#line 1622
      header_prepend = 1;
    }
  }
#line 1627
  if ((int )header[0] != 0) {
#line 1627
    if (header_prepend) {
      {
#line 1629
      tmp___7 = spio_write_data_raw(ctx, & ctx->server, (unsigned char const   *)((unsigned char *)(header)),
                                    (int )header_len);
      }
#line 1629
      if (tmp___7 == -1) {
#line 1631
        ret = -1;
#line 1631
        goto cleanup;
      } else {
        {
#line 1629
        tmp___8 = spio_write_data_raw(ctx, & ctx->server, (unsigned char const   *)((unsigned char *)"\r\n"),
                                      (int )((sizeof("\r\n") - 1UL) / sizeof(char )));
        }
#line 1629
        if (tmp___8 == -1) {
#line 1631
          ret = -1;
#line 1631
          goto cleanup;
        }
      }
#line 1632
      header[0] = (char )'\000';
    }
  }
  {
#line 1636
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1636
    rc = getline((char **/* __restrict  */)(& line), (size_t */* __restrict  */)(& line_len),
                 (FILE */* __restrict  */)file);
    }
#line 1636
    if (! (rc != -1L)) {
#line 1636
      goto while_break___0;
    }
    {
#line 1644
    tmp___9 = strcmp((char const   *)line, ".\r\n");
    }
#line 1644
    if (tmp___9 == 0) {
      {
#line 1645
      strncpy((char */* __restrict  */)line, (char const   */* __restrict  */)". \r\n",
              (size_t )4224);
      }
    }
#line 1647
    if ((int )header[0] != 0) {
      {
#line 1653
      tmp___12 = is_blank_line((char const   *)line);
      }
#line 1653
      if (tmp___12) {
        {
#line 1655
        tmp___10 = spio_write_data_raw(ctx, & ctx->server, (unsigned char const   *)((unsigned char *)(header)),
                                       (int )header_len);
        }
#line 1655
        if (tmp___10 == -1) {
#line 1657
          ret = -1;
#line 1657
          goto cleanup;
        } else {
          {
#line 1655
          tmp___11 = spio_write_data_raw(ctx, & ctx->server, (unsigned char const   *)((unsigned char *)"\r\n"),
                                         (int )((sizeof("\r\n") - 1UL) / sizeof(char )));
          }
#line 1655
          if (tmp___11 == -1) {
#line 1657
            ret = -1;
#line 1657
            goto cleanup;
          }
        }
#line 1658
        header[0] = (char )'\000';
      }
    }
    {
#line 1662
    tmp___13 = spio_write_data_raw(ctx, & ctx->server, (unsigned char const   *)((unsigned char *)line),
                                   (int )rc);
    }
#line 1662
    if (tmp___13 == -1) {
#line 1663
      ret = -1;
#line 1663
      goto cleanup;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1666
  tmp___14 = ferror(file);
  }
#line 1666
  if (tmp___14) {
    {
#line 1667
    sp_message(ctx, 3, "error reading cache file: %s", ctx->cachename);
    }
  }
  {
#line 1669
  tmp___15 = ferror(file);
  }
#line 1669
  if (tmp___15) {
    {
#line 1672
    spio_write_data(ctx, & ctx->client, "451 Local Error\r\n");
#line 1673
    ret = -1;
    }
#line 1673
    goto cleanup;
  } else {
    {
#line 1669
    tmp___16 = spio_write_data(ctx, & ctx->server, ".\r\n");
    }
#line 1669
    if (tmp___16 == -1) {
      {
#line 1672
      spio_write_data(ctx, & ctx->client, "451 Local Error\r\n");
#line 1673
      ret = -1;
      }
#line 1673
      goto cleanup;
    }
  }
  {
#line 1676
  sp_messagex(ctx, 7, "sent email data");
#line 1679
  tmp___17 = read_server_response(ctx);
  }
#line 1679
  if (tmp___17 == -1) {
#line 1680
    ret = -1;
#line 1680
    goto cleanup;
  }
  {
#line 1682
  tmp___18 = spio_write_data(ctx, & ctx->client, (char const   *)(ctx->server.line));
  }
#line 1682
  if (tmp___18 == -1) {
#line 1683
    ret = -1;
#line 1683
    goto cleanup;
  }
  cleanup: 
#line 1687
  if (line) {
    {
#line 1688
    free((void *)line);
    }
  }
#line 1689
  if (file) {
    {
#line 1690
    fclose(file);
    }
  }
#line 1692
  return (ret);
}
}
#line 1695 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/smtppass.c"
int sp_fail_data(spctx_t *ctx , char const   *smtp_status ) 
{ 
  char buf[((256UL + (sizeof("550 Content Rejected; ") - 1UL) / sizeof(char )) + (sizeof("\r\n") - 1UL) / sizeof(char )) + 1UL] ;
  char *t ;
  int len ;
  int x ;
  int pref ;
  int crlf ;
  long tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 1698
  t = (char *)((void *)0);
#line 1700
  pref = 0;
#line 1701
  crlf = 0;
#line 1703
  if ((unsigned long )smtp_status == (unsigned long )((void *)0)) {
#line 1704
    smtp_status = "451 Local Error\r\n";
  }
  {
#line 1706
  tmp = strtol((char const   */* __restrict  */)smtp_status, (char **/* __restrict  */)(& t),
               10);
#line 1706
  x = (int )tmp;
#line 1707
  tmp___0 = strlen(smtp_status);
#line 1707
  len = (int )tmp___0;
  }
#line 1710
  if (x == 0) {
#line 1711
    pref = 1;
  } else
#line 1710
  if ((unsigned long )t != (unsigned long )(smtp_status + 3)) {
#line 1711
    pref = 1;
  }
  {
#line 1714
  tmp___1 = strcmp(smtp_status + ((unsigned long )len - (sizeof("\r\n") - 1UL) / sizeof(char )),
                   "\r\n");
  }
#line 1714
  if (tmp___1 != 0) {
#line 1715
    crlf = 1;
  }
#line 1717
  if (pref) {
#line 1717
    goto _L;
  } else
#line 1717
  if (crlf) {
    _L: /* CIL Label */ 
#line 1720
    if (crlf) {
#line 1720
      tmp___2 = "\r\n";
    } else {
#line 1720
      tmp___2 = "";
    }
#line 1720
    if (pref) {
#line 1720
      tmp___3 = "550 Content Rejected; ";
    } else {
#line 1720
      tmp___3 = "";
    }
    {
#line 1720
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s%.256s%s",
             tmp___3, smtp_status, tmp___2);
#line 1722
    buf[sizeof(buf) - 1UL] = (char)0;
#line 1723
    smtp_status = (char const   *)(buf);
    }
  }
  {
#line 1726
  tmp___4 = spio_write_data(ctx, & ctx->client, smtp_status);
  }
#line 1726
  if (tmp___4 == -1) {
#line 1727
    return (-1);
  }
  {
#line 1730
  tmp___5 = spio_write_data(ctx, & ctx->server, "RSET\r\n");
  }
#line 1730
  if (tmp___5 == -1) {
#line 1732
    return (-1);
  } else {
    {
#line 1730
    tmp___6 = read_server_response(ctx);
    }
#line 1730
    if (tmp___6 == -1) {
#line 1732
      return (-1);
    }
  }
#line 1734
  return (0);
}
}
#line 1737 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/smtppass.c"
static int read_server_response(spctx_t *ctx ) 
{ 
  int r ;

  {
  {
#line 1742
  r = spio_read_line(ctx, & ctx->server, 2);
  }
#line 1742
  if (r == -1) {
#line 1743
    return (-1);
  }
#line 1745
  if (r == 0) {
    {
#line 1747
    sp_messagex(ctx, 3, "server disconnected unexpectedly");
#line 1750
    spio_write_data(ctx, & ctx->client, "451 Local Error\r\n");
    }
#line 1751
    return (0);
  }
#line 1754
  if (r >= 4222) {
    {
#line 1755
    sp_messagex(ctx, 4, "SMTP response line too long. discarded extra");
    }
  }
#line 1757
  return (0);
}
}
#line 1760 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/smtppass.c"
static void do_server_noop(spctx_t *ctx ) 
{ 
  int tmp ;

  {
#line 1762
  if (& ctx->server) {
#line 1762
    if (ctx->server.fd != -1) {
      {
#line 1764
      tmp = spio_write_data(ctx, & ctx->server, "NOOP\r\n");
      }
#line 1764
      if (tmp != -1) {
        {
#line 1765
        spio_read_line(ctx, & ctx->server, 2);
        }
      }
    }
  }
#line 1767
  return;
}
}
#line 1769 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/smtppass.c"
void sp_setup_forked(spctx_t *ctx , int file ) 
{ 


  {
  {
#line 1772
  signal(13, (void (*)(int  ))0);
#line 1773
  signal(1, (void (*)(int  ))0);
#line 1774
  signal(2, (void (*)(int  ))0);
#line 1775
  signal(15, (void (*)(int  ))0);
#line 1777
  siginterrupt(2, 0);
#line 1778
  siginterrupt(15, 0);
  }
#line 1780
  if (ctx->sender) {
    {
#line 1781
    setenv("SENDER", (char const   *)ctx->sender, 1);
    }
  }
#line 1783
  if (ctx->recipients) {
    {
#line 1784
    setenv("RECIPIENTS", (char const   *)ctx->recipients, 1);
    }
  }
#line 1786
  if (file) {
#line 1786
    if (ctx->cachename[0]) {
      {
#line 1787
      setenv("EMAIL", (char const   *)(ctx->cachename), 1);
      }
    }
  }
#line 1789
  if (& ctx->client) {
#line 1789
    if (ctx->client.fd != -1) {
      {
#line 1790
      setenv("CLIENT", (char const   *)(ctx->client.peername), 1);
      }
    }
  }
#line 1792
  if (ctx->xforwardaddr) {
    {
#line 1793
    setenv("REMOTE", (char const   *)ctx->xforwardaddr, 1);
    }
  }
#line 1795
  if (ctx->xforwardhelo) {
    {
#line 1796
    setenv("REMOTE_HELO", (char const   *)ctx->xforwardhelo, 1);
    }
  }
#line 1798
  if (& ctx->server) {
#line 1798
    if (ctx->server.fd != -1) {
      {
#line 1799
      setenv("SERVER", (char const   *)(ctx->server.peername), 1);
      }
    }
  }
  {
#line 1801
  setenv("TMPDIR", g_state.directory, 1);
  }
#line 1802
  return;
}
}
#line 1809 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/smtppass.c"
char const   kMsgDelimiter[3]  = {      (char const   )':',      (char const   )' ',      (char const   )'\000'};
#line 1812 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/smtppass.c"
static void vmessage(spctx_t *ctx , int level , int err___0 , char const   *msg ,
                     va_list ap ) 
{ 
  char buf[1024] ;
  int e ;
  int *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 1816
  tmp = __errno_location();
#line 1816
  e = *tmp;
  }
#line 1818
  if (g_state.daemonized) {
#line 1820
    if (level >= 7) {
#line 1821
      return;
    }
  } else
#line 1825
  if (g_state.debug_level < level) {
#line 1826
    return;
  }
#line 1831
  if (ctx) {
#line 1832
    if (err___0) {
#line 1832
      tmp___0 = ": ";
    } else {
#line 1832
      tmp___0 = "";
    }
    {
#line 1832
    snprintf((char */* __restrict  */)(buf), (size_t )1024, (char const   */* __restrict  */)"%06X: %s%s",
             ctx->id, msg, tmp___0);
    }
  } else {
#line 1834
    if (err___0) {
#line 1834
      tmp___1 = ": ";
    } else {
#line 1834
      tmp___1 = "";
    }
    {
#line 1834
    snprintf((char */* __restrict  */)(buf), (size_t )1024, (char const   */* __restrict  */)"%s%s",
             msg, tmp___1);
    }
  }
#line 1836
  if (err___0) {
    {
#line 1842
    sp_lock();
#line 1843
    tmp___2 = strerror(e);
#line 1843
    strncat((char */* __restrict  */)(buf), (char const   */* __restrict  */)tmp___2,
            (size_t )1024);
#line 1844
    sp_unlock();
    }
  }
#line 1848
  buf[1023] = (char)0;
#line 1851
  if (g_state.daemonized) {
    {
#line 1852
    vsyslog(level, (char const   *)(buf), ap);
    }
  } else {
    {
#line 1854
    vwarnx((char const   *)(buf), ap);
    }
  }
#line 1855
  return;
}
}
#line 1857 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/smtppass.c"
void sp_messagex(spctx_t *ctx , int level , char const   *msg  , ...) 
{ 
  va_list ap ;

  {
  {
#line 1861
  __builtin_va_start(ap, msg);
#line 1862
  vmessage(ctx, level, 0, msg, ap);
#line 1863
  __builtin_va_end(ap);
  }
#line 1864
  return;
}
}
#line 1866 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/smtppass.c"
void sp_message(spctx_t *ctx , int level , char const   *msg  , ...) 
{ 
  va_list ap ;

  {
  {
#line 1870
  __builtin_va_start(ap, msg);
#line 1871
  vmessage(ctx, level, 1, msg, ap);
#line 1872
  __builtin_va_end(ap);
  }
#line 1873
  return;
}
}
#line 1880 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/smtppass.c"
void sp_lock(void) 
{ 
  int r ;
  int *tmp ;

  {
  {
#line 1898
  r = pthread_mutex_lock(& g_mutex);
  }
#line 1902
  if (r != 0) {
    {
#line 1904
    tmp = __errno_location();
#line 1904
    *tmp = r;
#line 1905
    sp_message((spctx_t *)((void *)0), 2, "threading problem. couldn\'t lock mutex");
    }
  }
#line 1914
  return;
}
}
#line 1916 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/smtppass.c"
void sp_unlock(void) 
{ 
  int r ;
  int tmp ;
  int *tmp___0 ;

  {
  {
#line 1918
  tmp = pthread_mutex_unlock(& g_mutex);
#line 1918
  r = tmp;
  }
#line 1919
  if (r != 0) {
    {
#line 1921
    tmp___0 = __errno_location();
#line 1921
    *tmp___0 = r;
#line 1922
    sp_message((spctx_t *)((void *)0), 2, "threading problem. couldn\'t unlock mutex");
    }
  }
#line 1924
  return;
}
}
#line 1930 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/smtppass.c"
int sp_parse_option(char const   *name , char const   *value ) 
{ 
  char *t ;
  int ret ;
  long tmp ;
  long tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;

  {
  {
#line 1933
  ret = 0;
#line 1935
  tmp___15 = strcasecmp("MaxConnections", name);
  }
#line 1935
  if (tmp___15 == 0) {
    {
#line 1937
    tmp = strtol((char const   */* __restrict  */)value, (char **/* __restrict  */)(& t),
                 10);
#line 1937
    g_state.max_threads = (int )tmp;
    }
#line 1938
    if (*t) {
      {
#line 1939
      errx(2, "invalid setting: MaxConnections (must be between 1 and 1024)");
      }
    } else
#line 1938
    if (g_state.max_threads <= 1) {
      {
#line 1939
      errx(2, "invalid setting: MaxConnections (must be between 1 and 1024)");
      }
    } else
#line 1938
    if (g_state.max_threads >= 1024) {
      {
#line 1939
      errx(2, "invalid setting: MaxConnections (must be between 1 and 1024)");
      }
    }
#line 1940
    ret = 1;
  } else {
    {
#line 1943
    tmp___14 = strcasecmp("TimeOut", name);
    }
#line 1943
    if (tmp___14 == 0) {
      {
#line 1945
      g_state.timeout.tv_sec = strtol((char const   */* __restrict  */)value, (char **/* __restrict  */)(& t),
                                      10);
      }
#line 1946
      if (*t) {
        {
#line 1947
        errx(2, "invalid setting: TimeOut");
        }
      } else
#line 1946
      if (g_state.timeout.tv_sec <= 0L) {
        {
#line 1947
        errx(2, "invalid setting: TimeOut");
        }
      }
#line 1948
      ret = 1;
    } else {
      {
#line 1951
      tmp___13 = strcasecmp("KeepAlives", name);
      }
#line 1951
      if (tmp___13 == 0) {
        {
#line 1953
        tmp___0 = strtol((char const   */* __restrict  */)value, (char **/* __restrict  */)(& t),
                         10);
#line 1953
        g_state.keepalives = (int )tmp___0;
        }
#line 1954
        if (*t) {
          {
#line 1955
          errx(2, "invalid setting: KeepAlives");
          }
        } else
#line 1954
        if (g_state.keepalives < 0) {
          {
#line 1955
          errx(2, "invalid setting: KeepAlives");
          }
        }
#line 1956
        ret = 1;
      } else {
        {
#line 1959
        tmp___12 = strcasecmp("XClient", name);
        }
#line 1959
        if (tmp___12 == 0) {
          {
#line 1961
          g_state.xclient = strtob(value);
          }
#line 1961
          if (g_state.xclient == -1) {
            {
#line 1962
            errx(2, "invalid value for XClient");
            }
          }
#line 1963
          ret = 1;
        } else {
          {
#line 1966
          tmp___11 = strcasecmp("OutAddress", name);
          }
#line 1966
          if (tmp___11 == 0) {
            {
#line 1968
            tmp___1 = sock_any_pton(value, & g_state.outaddr, 25);
            }
#line 1968
            if (tmp___1 == -1) {
              {
#line 1969
              errx(2, "invalid OutAddress socket name or ip: %s", value);
              }
            }
#line 1970
            g_state.outname = value;
#line 1971
            ret = 1;
          } else {
            {
#line 1974
            tmp___10 = strcasecmp("Listen", name);
            }
#line 1974
            if (tmp___10 == 0) {
              {
#line 1976
              tmp___2 = sock_any_pton(value, & g_state.listenaddr, 10025);
              }
#line 1976
              if (tmp___2 == -1) {
                {
#line 1977
                errx(2, "invalid Listen socket name or ip: %s", value);
                }
              }
#line 1978
              g_state.listenname = value;
#line 1979
              ret = 1;
            } else {
              {
#line 1982
              tmp___9 = strcasecmp("TransparentProxy", name);
              }
#line 1982
              if (tmp___9 == 0) {
                {
#line 1984
                g_state.transparent = strtob(value);
                }
#line 1984
                if (g_state.transparent == -1) {
                  {
#line 1985
                  errx(2, "invalid value for TransparentProxy");
                  }
                }
#line 1986
                ret = 1;
              } else {
                {
#line 1989
                tmp___8 = strcasecmp("TempDirectory", name);
                }
#line 1989
                if (tmp___8 == 0) {
                  {
#line 1991
                  tmp___3 = strlen(value);
                  }
#line 1991
                  if (tmp___3 == 0UL) {
                    {
#line 1992
                    errx(2, "invalid setting: TempDirectory");
                    }
                  }
#line 1993
                  g_state.directory = value;
#line 1994
                  ret = 1;
                } else {
                  {
#line 1997
                  tmp___7 = strcasecmp("User", name);
                  }
#line 1997
                  if (tmp___7 == 0) {
                    {
#line 1999
                    tmp___4 = strlen(value);
                    }
#line 1999
                    if (tmp___4 == 0UL) {
                      {
#line 2000
                      errx(2, "invalid setting: User");
                      }
                    }
#line 2001
                    g_state.user = value;
#line 2002
                    ret = 1;
                  } else {
                    {
#line 2005
                    tmp___6 = strcasecmp("PidFile", name);
                    }
#line 2005
                    if (tmp___6 == 0) {
#line 2007
                      if ((unsigned long )g_state.pidfile != (unsigned long )((void *)0)) {
                        {
#line 2008
                        sp_messagex((spctx_t *)((void *)0), 4, "ignoring pid file specified on the command line. ");
                        }
                      }
                      {
#line 2010
                      tmp___5 = strlen(value);
                      }
#line 2010
                      if (tmp___5 == 0UL) {
#line 2011
                        g_state.pidfile = (char const   *)((void *)0);
                      } else {
#line 2013
                        g_state.pidfile = value;
                      }
#line 2014
                      ret = 1;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  {
#line 2018
  tmp___16 = cb_parse_option(name, value);
  }
#line 2018
  if (tmp___16 == 1) {
#line 2019
    ret = 1;
  }
#line 2021
  return (ret);
}
}
#line 2024 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/smtppass.c"
static int parse_config_file(char const   *configfile ) 
{ 
  FILE *f ;
  long len ;
  char *p ;
  char *t ;
  char *n ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;

  {
  {
#line 2026
  f = (FILE *)((void *)0);
#line 2035
  f = fopen((char const   */* __restrict  */)configfile, (char const   */* __restrict  */)"r");
  }
#line 2036
  if ((unsigned long )f == (unsigned long )((void *)0)) {
    {
#line 2039
    tmp = __errno_location();
    }
#line 2039
    if (*tmp == 2) {
#line 2040
      return (-1);
    } else {
      {
#line 2039
      tmp___0 = __errno_location();
      }
#line 2039
      if (*tmp___0 == 20) {
#line 2040
        return (-1);
      } else {
        {
#line 2042
        err(1, "couldn\'t open config file: %s", configfile);
        }
      }
    }
  }
  {
#line 2046
  tmp___1 = fseek(f, 0L, 2);
  }
#line 2046
  if (tmp___1 == -1) {
    {
#line 2047
    err(1, "couldn\'t seek config file: %s", configfile);
    }
  } else {
    {
#line 2046
    len = ftell(f);
    }
#line 2046
    if (len == -1L) {
      {
#line 2047
      err(1, "couldn\'t seek config file: %s", configfile);
      }
    } else {
      {
#line 2046
      tmp___2 = fseek(f, 0L, 0);
      }
#line 2046
      if (tmp___2 == -1) {
        {
#line 2047
        err(1, "couldn\'t seek config file: %s", configfile);
        }
      }
    }
  }
  {
#line 2049
  tmp___3 = malloc((size_t )(len + 2L));
#line 2049
  g_state._p = (char *)tmp___3;
  }
#line 2049
  if ((unsigned long )g_state._p == (unsigned long )((void *)0)) {
    {
#line 2050
    errx(1, "out of memory");
    }
  }
  {
#line 2053
  tmp___4 = fread((void */* __restrict  */)g_state._p, (size_t )1, (size_t )len, (FILE */* __restrict  */)f);
  }
#line 2053
  if (tmp___4 != (size_t )len) {
    {
#line 2054
    err(1, "couldn\'t read config file: %s", configfile);
    }
  }
  {
#line 2056
  fclose(f);
#line 2057
  sp_messagex((spctx_t *)((void *)0), 7, "read config file: %s", configfile);
#line 2060
  p = g_state._p;
#line 2061
  *(p + len) = (char )'\n';
#line 2062
  *(p + (len + 1L)) = (char)0;
#line 2064
  n = g_state._p;
  }
  {
#line 2067
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2067
    t = strchr((char const   *)n, '\n');
    }
#line 2067
    if (! ((unsigned long )t != (unsigned long )((void *)0))) {
#line 2067
      goto while_break;
    }
    {
#line 2069
    *t = (char)0;
#line 2070
    p = n;
#line 2071
    n = t + 1;
#line 2073
    p = trim_start((char const   *)p);
    }
#line 2076
    if ((int )*p == 0) {
#line 2077
      goto while_continue;
    } else
#line 2076
    if ((int )*p == 35) {
#line 2077
      goto while_continue;
    }
    {
#line 2080
    t = strchr((char const   *)p, ':');
    }
#line 2081
    if ((unsigned long )t == (unsigned long )((void *)0)) {
      {
#line 2082
      errx(2, "invalid config line: %s", p);
      }
    }
    {
#line 2085
    *t = (char)0;
#line 2086
    t ++;
#line 2088
    t = trim_space(t);
#line 2089
    p = trim_space(p);
#line 2092
    tmp___5 = sp_parse_option((char const   *)p, (char const   *)t);
    }
#line 2092
    if (tmp___5 == 0) {
      {
#line 2095
      errx(2, "invalid config line: %s", p);
      }
    }
    {
#line 2097
    sp_messagex((spctx_t *)((void *)0), 7, "parsed option: %s: %s", p, t);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2100
  return (0);
}
}
#line 125 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 573 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execl)(char const   *__path ,
                                                                                              char const   *__arg 
                                                                                              , ...) ;
#line 603
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 790
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) link)(char const   *__from ,
                                                                                             char const   *__to ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 606 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) mktemp)(char *__template ) ;
#line 44 "../common/stringx.h"
int is_last_word(char const   *line , char const   *word , int len ) ;
#line 148 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/clamsmtpd.c"
clstate_t g_clstate  ;
#line 154
static void usage(void) ;
#line 155
static int connect_clam(clctx_t *ctx ) ;
#line 156
static int disconnect_clam(clctx_t *ctx ) ;
#line 157
static int virus_action(clctx_t *ctx , char const   *virus ) ;
#line 158
static int clam_scan_file(clctx_t *ctx , char const   **virus ) ;
#line 169 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/clamsmtpd.c"
char **__argv  ;
#line 172 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/clamsmtpd.c"
int main(int argc , char **argv ) 
{ 
  char const   *configfile ;
  char const   *pidfile ;
  int dbg_level ;
  int warnargs ;
  int ch ;
  int r ;
  char *t ;
  long tmp ;

  {
  {
#line 174
  configfile = "/usr/local/etc/clamsmtpd.conf";
#line 175
  pidfile = (char const   *)((void *)0);
#line 176
  dbg_level = -1;
#line 177
  warnargs = 0;
#line 178
  ch = 0;
#line 183
  __argv = argv;
#line 187
  memset((void *)(& g_clstate), 0, sizeof(g_clstate));
#line 188
  g_clstate.directory = "/tmp/";
#line 191
  r = cb_parse_option("ClamAddress", "/var/run/clamav/clamd");
#line 194
  sp_init("clamsmtpd");
#line 197
  sp_parse_option("Header", "X-Virus-Scanned: ClamAV using ClamSMTP");
  }
  {
#line 205
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 205
    ch = getopt(argc, (char * const  *)argv, "bc:d:D:f:h:l:m:p:qt:v");
    }
#line 205
    if (! (ch != -1)) {
#line 205
      goto while_break;
    }
    {
#line 210
    if (ch == 98) {
#line 210
      goto case_98;
    }
#line 218
    if (ch == 99) {
#line 218
      goto case_99;
    }
#line 226
    if (ch == 100) {
#line 226
      goto case_100;
    }
#line 234
    if (ch == 68) {
#line 234
      goto case_68;
    }
#line 242
    if (ch == 102) {
#line 242
      goto case_102;
    }
#line 247
    if (ch == 104) {
#line 247
      goto case_104;
    }
#line 255
    if (ch == 108) {
#line 255
      goto case_108;
    }
#line 263
    if (ch == 109) {
#line 263
      goto case_109;
    }
#line 271
    if (ch == 112) {
#line 271
      goto case_112;
    }
#line 276
    if (ch == 116) {
#line 276
      goto case_116;
    }
#line 284
    if (ch == 113) {
#line 284
      goto case_113;
    }
#line 292
    if (ch == 118) {
#line 292
      goto case_118;
    }
#line 299
    if (ch == 88) {
#line 299
      goto case_88;
    }
#line 308
    goto switch_default;
    case_98: /* CIL Label */ 
    {
#line 211
    r = cb_parse_option("Bounce", "on");
    }
#line 211
    if (r < 0) {
      {
#line 212
      usage();
      }
    }
#line 214
    warnargs = 1;
#line 215
    goto switch_break;
    case_99: /* CIL Label */ 
    {
#line 219
    r = cb_parse_option("ClamAddress", "on");
    }
#line 219
    if (r < 0) {
      {
#line 220
      usage();
      }
    }
#line 222
    warnargs = 1;
#line 223
    goto switch_break;
    case_100: /* CIL Label */ 
    {
#line 227
    tmp = strtol((char const   */* __restrict  */)optarg, (char **/* __restrict  */)(& t),
                 10);
#line 227
    dbg_level = (int )tmp;
    }
#line 228
    if (*t) {
      {
#line 229
      errx(1, "invalid debug log level");
      }
    }
#line 230
    dbg_level += 3;
#line 231
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 235
    r = sp_parse_option("TempDirectory", (char const   *)optarg);
    }
#line 235
    if (r < 0) {
      {
#line 236
      usage();
      }
    }
#line 238
    warnargs = 1;
#line 239
    goto switch_break;
    case_102: /* CIL Label */ 
#line 243
    configfile = (char const   *)optarg;
#line 244
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 248
    r = cb_parse_option("Header", (char const   *)optarg);
    }
#line 248
    if (r < 0) {
      {
#line 249
      usage();
      }
    }
#line 251
    warnargs = 1;
#line 252
    goto switch_break;
    case_108: /* CIL Label */ 
    {
#line 256
    r = sp_parse_option("Listen", (char const   *)optarg);
    }
#line 256
    if (r < 0) {
      {
#line 257
      usage();
      }
    }
#line 259
    warnargs = 1;
#line 260
    goto switch_break;
    case_109: /* CIL Label */ 
    {
#line 264
    r = sp_parse_option("MaxConnections", (char const   *)optarg);
    }
#line 264
    if (r < 0) {
      {
#line 265
      usage();
      }
    }
#line 267
    warnargs = 1;
#line 268
    goto switch_break;
    case_112: /* CIL Label */ 
#line 272
    pidfile = (char const   *)optarg;
#line 273
    goto switch_break;
    case_116: /* CIL Label */ 
    {
#line 277
    r = sp_parse_option("TimeOut", (char const   *)optarg);
    }
#line 277
    if (r < 0) {
      {
#line 278
      usage();
      }
    }
#line 280
    warnargs = 1;
#line 281
    goto switch_break;
    case_113: /* CIL Label */ 
    {
#line 285
    r = cb_parse_option("Quarantine", "on");
    }
#line 285
    if (r < 0) {
      {
#line 286
      usage();
      }
    }
#line 288
    warnargs = 1;
#line 289
    goto switch_break;
    case_118: /* CIL Label */ 
    {
#line 293
    printf((char const   */* __restrict  */)"clamsmtpd (version %s)\n", "1.10");
#line 294
    printf((char const   */* __restrict  */)"          (config: %s)\n", "/usr/local/etc/clamsmtpd.conf");
#line 295
    exit(0);
    }
#line 296
    goto switch_break;
    case_88: /* CIL Label */ 
    {
#line 300
    r = cb_parse_option("DebugFiles", "on");
    }
#line 300
    if (r < 0) {
      {
#line 301
      usage();
      }
    }
#line 303
    warnargs = 1;
#line 304
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 309
    usage();
    }
#line 310
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 314
  argc -= optind;
#line 315
  argv += optind;
#line 317
  if (argc > 1) {
    {
#line 318
    usage();
    }
  }
#line 319
  if (argc == 1) {
    {
#line 322
    r = sp_parse_option("OutAddress", (char const   *)*(argv + 0));
    }
#line 322
    if (r < 0) {
      {
#line 323
      usage();
      }
    }
#line 325
    warnargs = 1;
  }
#line 328
  if (warnargs) {
    {
#line 329
    warnx("please use configuration file instead of command-line flags: %s", configfile);
    }
  }
  {
#line 331
  r = sp_run(configfile, pidfile, dbg_level);
#line 333
  sp_done();
  }
#line 335
  return (r);
}
}
#line 338 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/clamsmtpd.c"
static void usage(void) 
{ 


  {
  {
#line 340
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"usage: clamsmtpd [-d debuglevel] [-f configfile] [-p pidfile]\n");
#line 341
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"       clamsmtpd -v\n");
#line 342
  exit(2);
  }
}
}
#line 349 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/clamsmtpd.c"
int cb_check_data(spctx_t *sp ) 
{ 
  int r ;
  char const   *virus ;
  clctx_t *ctx ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 351
  r = 0;
#line 353
  ctx = (clctx_t *)sp;
#line 356
  r = sp_cache_data(sp);
  }
#line 356
  if (r > 0) {
#line 359
    if (& ctx->clam) {
#line 359
      if (! (ctx->clam.fd != -1)) {
        {
#line 360
        r = connect_clam(ctx);
        }
      }
    } else {
      {
#line 360
      r = connect_clam(ctx);
      }
    }
#line 362
    if (r != -1) {
      {
#line 363
      r = clam_scan_file(ctx, & virus);
      }
    }
  }
  {
#line 373
  if (r == -1) {
#line 373
    goto case_neg_1;
  }
#line 382
  if (r == 0) {
#line 382
    goto case_0;
  }
#line 393
  if (r == 1) {
#line 393
    goto case_1;
  }
#line 418
  goto switch_default___0;
  case_neg_1: /* CIL Label */ 
  {
#line 374
  tmp = sp_fail_data(sp, (char const   *)((void *)0));
  }
#line 374
  if (tmp == -1) {
#line 375
    return (-1);
  }
#line 376
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 383
  tmp___0 = sp_done_data(sp, g_clstate.header);
  }
#line 383
  if (tmp___0 == -1) {
#line 384
    return (-1);
  }
#line 385
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 395
  virus_action(ctx, virus);
  }
  {
#line 399
  if (g_clstate.action == 0) {
#line 399
    goto case_0___0;
  }
#line 403
  if (g_clstate.action == 1) {
#line 403
    goto case_1___0;
  }
#line 407
  if (g_clstate.action == 2) {
#line 407
    goto case_2;
  }
#line 411
  goto switch_default;
  case_0___0: /* CIL Label */ 
  {
#line 400
  tmp___1 = sp_fail_data(sp, "250 Virus Detected; Discarded Email\r\n");
  }
#line 400
  if (tmp___1 == -1) {
#line 401
    return (-1);
  }
#line 402
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
  {
#line 404
  tmp___2 = sp_fail_data(sp, "550 Virus Detected; Content Rejected\r\n");
  }
#line 404
  if (tmp___2 == -1) {
#line 405
    return (-1);
  }
#line 406
  goto switch_break___0;
  case_2: /* CIL Label */ 
  {
#line 408
  tmp___3 = sp_done_data(sp, "X-Virus-Infected: Virus Detected!");
  }
#line 408
  if (tmp___3 == -1) {
#line 409
    return (-1);
  }
#line 410
  goto switch_break___0;
  switch_default: /* CIL Label */ ;
#line 413
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 416
  goto switch_break;
  switch_default___0: /* CIL Label */ ;
#line 420
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 423
  return (0);
}
}
#line 426 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/clamsmtpd.c"
int cb_parse_option(char const   *name , char const   *value ) 
{ 
  int tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  int bounce ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;

  {
  {
#line 428
  tmp___16 = strcasecmp("ClamAddress", name);
  }
#line 428
  if (tmp___16 == 0) {
    {
#line 430
    tmp = sock_any_pton(value, & g_clstate.clamaddr, 1048576);
    }
#line 430
    if (tmp == -1) {
      {
#line 431
      errx(2, "invalid ClamAddress socket name: %s", value);
      }
    }
#line 432
    g_clstate.clamname = value;
#line 433
    return (1);
  } else {
    {
#line 437
    tmp___15 = strcasecmp("ScanHeader", name);
    }
#line 437
    if (tmp___15 == 0) {
      {
#line 439
      warnx("please use \"Header\" option instead of \"ScanHeader\"");
#line 440
      tmp___0 = trim_start(value);
#line 440
      g_clstate.header = (char const   *)tmp___0;
#line 441
      tmp___1 = strlen(g_clstate.header);
      }
#line 441
      if (tmp___1 == 0UL) {
#line 442
        g_clstate.header = (char const   *)((void *)0);
      }
    } else {
      {
#line 445
      tmp___14 = strcasecmp("Header", name);
      }
#line 445
      if (tmp___14 == 0) {
        {
#line 447
        tmp___2 = trim_start(value);
#line 447
        g_clstate.header = (char const   *)tmp___2;
#line 448
        tmp___3 = strlen(g_clstate.header);
        }
#line 448
        if (tmp___3 == 0UL) {
#line 449
          g_clstate.header = (char const   *)((void *)0);
        }
#line 450
        return (1);
      } else {
        {
#line 453
        tmp___13 = strcasecmp("TempDirectory", name);
        }
#line 453
        if (tmp___13 == 0) {
#line 455
          g_clstate.directory = value;
#line 456
          return (1);
        } else {
          {
#line 460
          tmp___12 = strcasecmp("Bounce", name);
          }
#line 460
          if (tmp___12 == 0) {
            {
#line 462
            tmp___4 = strtob(value);
#line 462
            bounce = tmp___4;
            }
#line 463
            if (bounce == -1) {
              {
#line 464
              errx(2, "invalid value for Bounce");
              }
            }
#line 465
            if (bounce) {
#line 466
              g_clstate.action = 1;
            }
            {
#line 467
            warnx("please use \"Action\" option instead of \"Bounce\"");
            }
#line 468
            return (1);
          } else {
            {
#line 471
            tmp___11 = strcasecmp("Action", name);
            }
#line 471
            if (tmp___11 == 0) {
              {
#line 473
              tmp___7 = strcasecmp("bounce", value);
              }
#line 473
              if (tmp___7 == 0) {
#line 474
                g_clstate.action = 1;
              } else {
                {
#line 475
                tmp___6 = strcasecmp("drop", value);
                }
#line 475
                if (tmp___6 == 0) {
#line 476
                  g_clstate.action = 0;
                } else {
                  {
#line 477
                  tmp___5 = strcasecmp("pass", value);
                  }
#line 477
                  if (tmp___5 == 0) {
#line 478
                    g_clstate.action = 2;
                  } else {
                    {
#line 480
                    errx(2, "invalid value for Action");
                    }
                  }
                }
              }
#line 481
              return (1);
            } else {
              {
#line 484
              tmp___10 = strcasecmp("Quarantine", name);
              }
#line 484
              if (tmp___10 == 0) {
                {
#line 486
                g_clstate.quarantine = strtob(value);
                }
#line 486
                if (g_clstate.quarantine == -1) {
                  {
#line 487
                  errx(2, "invalid value for Quarantine");
                  }
                }
#line 488
                return (1);
              } else {
                {
#line 491
                tmp___9 = strcasecmp("DebugFiles", name);
                }
#line 491
                if (tmp___9 == 0) {
                  {
#line 493
                  g_clstate.debug_files = strtob(value);
                  }
#line 493
                  if (g_clstate.debug_files == -1) {
                    {
#line 494
                    errx(2, "invalid value for DebugFiles");
                    }
                  }
#line 495
                  return (1);
                } else {
                  {
#line 498
                  tmp___8 = strcasecmp("VirusAction", name);
                  }
#line 498
                  if (tmp___8 == 0) {
#line 500
                    g_clstate.virusaction = value;
#line 501
                    return (1);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 504
  return (0);
}
}
#line 507 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/clamsmtpd.c"
spctx_t *cb_new_context(void) 
{ 
  clctx_t *ctx ;
  void *tmp ;

  {
  {
#line 509
  tmp = calloc((size_t )1, sizeof(clctx_t ));
#line 509
  ctx = (clctx_t *)tmp;
  }
#line 510
  if (! ctx) {
    {
#line 512
    sp_messagex((spctx_t *)((void *)0), 2, "out of memory");
    }
#line 513
    return ((spctx_t *)((void *)0));
  }
  {
#line 517
  spio_init(& ctx->clam, "CLAMAV");
  }
#line 518
  return (& ctx->sp);
}
}
#line 521 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/clamsmtpd.c"
void cb_del_context(spctx_t *sp ) 
{ 
  clctx_t *ctx ;
  int x ;
  __pid_t tmp ;

  {
  {
#line 523
  ctx = (clctx_t *)sp;
#line 527
  disconnect_clam(ctx);
#line 528
  free((void *)ctx);
  }
#line 530
  if (g_clstate.virusaction) {
    {
#line 533
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 533
      tmp = waitpid(-1, & x, 1);
      }
#line 533
      if (! (tmp > 0)) {
#line 533
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 536
  return;
}
}
#line 542 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/clamsmtpd.c"
static int connect_clam(clctx_t *ctx ) 
{ 
  int ret ;
  spctx_t *sp ;
  int tmp ;

  {
  {
#line 544
  ret = 0;
#line 545
  sp = & ctx->sp;
#line 550
  tmp = spio_connect(sp, & ctx->clam, (struct sockaddr_any  const  *)(& g_clstate.clamaddr),
                     g_clstate.clamname);
  }
#line 550
  if (tmp == -1) {
#line 551
    ret = -1;
#line 551
    goto cleanup;
  }
  {
#line 553
  spio_read_junk(sp, & ctx->clam);
  }
  cleanup: 
#line 577
  if (ret < 0) {
#line 577
    if (& ctx->clam) {
#line 577
      if (ctx->clam.fd != -1) {
        {
#line 578
        spio_disconnect(sp, & ctx->clam);
        }
      }
    }
  }
#line 580
  return (ret);
}
}
#line 583 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/clamsmtpd.c"
static int disconnect_clam(clctx_t *ctx ) 
{ 
  spctx_t *sp ;

  {
#line 585
  sp = & ctx->sp;
#line 587
  if (& ctx->clam) {
#line 587
    if (! (ctx->clam.fd != -1)) {
#line 588
      return (0);
    }
  } else {
#line 588
    return (0);
  }
  {
#line 595
  spio_disconnect(sp, & ctx->clam);
  }
#line 596
  return (0);
}
}
#line 599 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/clamsmtpd.c"
static int clam_scan_file(clctx_t *ctx , char const   **virus ) 
{ 
  int len ;
  int x ;
  int ret ;
  char *line ;
  spctx_t *sp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 602
  ret = 0;
#line 604
  sp = & ctx->sp;
#line 607
  if (& ctx->clam) {
#line 607
    if (! (ctx->clam.fd != -1)) {
#line 607
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 609
    tmp = connect_clam(ctx);
    }
#line 609
    if (tmp == -1) {
#line 610
      ret = -1;
#line 610
      goto cleanup;
    }
  }
  {
#line 615
  *virus = (char const   *)((void *)0);
#line 620
  line = ctx->clam.line;
#line 621
  strcpy((char */* __restrict  */)line, (char const   */* __restrict  */)"SCAN ");
#line 622
  strcat((char */* __restrict  */)line, (char const   */* __restrict  */)(sp->cachename));
#line 623
  strcat((char */* __restrict  */)line, (char const   */* __restrict  */)"\n");
#line 625
  tmp___0 = spio_write_data(sp, & ctx->clam, (char const   *)line);
  }
#line 625
  if (tmp___0 == -1) {
#line 626
    ret = -1;
#line 626
    goto cleanup;
  }
  {
#line 628
  len = spio_read_line(sp, & ctx->clam, 3);
  }
#line 629
  if (len == 0) {
    {
#line 631
    sp_messagex(sp, 3, "clamd disconnected unexpectedly");
#line 632
    ret = -1;
    }
#line 632
    goto cleanup;
  }
  {
#line 635
  tmp___1 = is_last_word((char const   *)line, "OK", (int )((sizeof("OK") - 1UL) / sizeof(char )));
  }
#line 635
  if (tmp___1) {
    {
#line 637
    sp_add_log(sp, (char *)"status=", (char *)"CLEAN");
#line 638
    sp_messagex(sp, 7, "no virus");
#line 639
    ret = 0;
    }
#line 639
    goto cleanup;
  }
  {
#line 648
  tmp___3 = is_last_word((char const   *)line, "FOUND", (int )((sizeof("FOUND") - 1UL) / sizeof(char )));
  }
#line 648
  if (tmp___3) {
    {
#line 650
    tmp___2 = strlen((char const   *)(sp->cachename));
#line 650
    x = (int )tmp___2;
    }
#line 653
    if ((unsigned long )len > (unsigned long )x + (sizeof("FOUND") - 1UL) / sizeof(char )) {
      {
#line 656
      *(line + ((unsigned long )len - (sizeof("FOUND") - 1UL) / sizeof(char ))) = (char)0;
#line 659
      line += x + 1;
#line 661
      line = trim_space(line);
#line 663
      sp_messagex(sp, 7, "found virus: %s", line);
#line 664
      sp_add_log(sp, (char *)"status=VIRUS:", line);
#line 665
      *virus = (char const   *)line;
      }
    } else {
      {
#line 670
      sp_messagex(sp, 4, "couldn\'t parse virus name from clamd response: %s", line);
#line 671
      sp_add_log(sp, (char *)"status=", (char *)"VIRUS");
#line 672
      *virus = "Unparsable.Virus.Name";
      }
    }
#line 675
    ret = 1;
#line 675
    goto cleanup;
  }
  {
#line 678
  tmp___4 = is_last_word((char const   *)line, "ERROR", (int )((sizeof("ERROR") - 1UL) / sizeof(char )));
  }
#line 678
  if (tmp___4) {
    {
#line 680
    sp_messagex(sp, 3, "clamav error: %s", line);
#line 681
    sp_add_log(sp, (char *)"status=", (char *)"CLAMAV-ERROR");
#line 682
    ret = -1;
    }
#line 682
    goto cleanup;
  }
  {
#line 685
  sp_add_log(sp, (char *)"status=", (char *)"CLAMAV-ERROR");
#line 686
  sp_messagex(sp, 3, "unexepected response from clamd: %s", line);
#line 687
  ret = -1;
  }
#line 687
  goto cleanup;
  cleanup: 
  {
#line 691
  disconnect_clam(ctx);
  }
#line 694
  return (ret);
}
}
#line 701 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/clamsmtpd.c"
static int virus_action(clctx_t *ctx , char const   *virus ) 
{ 
  char qfilename[4096] ;
  spctx_t *sp ;
  char *t ;
  int i ;
  pid_t pid ;
  size_t tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  __pid_t tmp___4 ;

  {
#line 704
  sp = & ctx->sp;
#line 709
  if (g_clstate.quarantine) {
    {
#line 711
    strlcpy(qfilename, g_clstate.directory, (size_t )4096);
#line 712
    tmp = strlen((char const   *)(qfilename));
    }
#line 712
    if ((int )qfilename[tmp - 1UL] != 47) {
      {
#line 713
      strlcat(qfilename, "/", (size_t )4096);
      }
    }
    {
#line 714
    strlcat(qfilename, "virus.", (size_t )4096);
#line 717
    tmp___0 = strlen((char const   *)(qfilename));
#line 717
    t = qfilename + tmp___0;
    }
    {
#line 724
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 727
      *t = (char)0;
#line 728
      strlcat(qfilename, "XXXXXX", (size_t )4096);
#line 730
      tmp___1 = mktemp(qfilename);
      }
#line 730
      if (! tmp___1) {
        {
#line 732
        sp_message(sp, 3, "couldn\'t create quarantine file name");
        }
#line 733
        return (-1);
      }
      {
#line 737
      tmp___3 = link((char const   *)(sp->cachename), (char const   *)(qfilename));
      }
#line 737
      if (tmp___3 == -1) {
        {
#line 740
        tmp___2 = __errno_location();
        }
#line 740
        if (*tmp___2 == 17) {
          {
#line 742
          sp_message(sp, 4, "race condition when quarantining virus file: %s", qfilename);
          }
#line 743
          goto __Cont;
        }
        {
#line 746
        sp_message(sp, 3, "couldn\'t quarantine virus file");
        }
#line 747
        return (-1);
      }
#line 750
      goto while_break;
      __Cont: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 753
    sp_messagex(sp, 6, "quarantined virus file as: %s", qfilename);
    }
  }
#line 756
  if ((unsigned long )g_clstate.virusaction != (unsigned long )((void *)0)) {
    {
#line 759
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 759
      tmp___4 = waitpid(-1, & i, 1);
      }
#line 759
      if (! (tmp___4 > 0)) {
#line 759
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 762
    sp_messagex(sp, 7, "executing virus action: %s", g_clstate.virusaction);
#line 764
    pid = fork();
    }
    {
#line 766
    if (pid == -1) {
#line 766
      goto case_neg_1;
    }
#line 771
    if (pid == 0) {
#line 771
      goto case_0;
    }
#line 764
    goto switch_break;
    case_neg_1: /* CIL Label */ 
    {
#line 767
    sp_message(sp, 3, "couldn\'t fork for virus action");
    }
#line 768
    return (-1);
    case_0: /* CIL Label */ 
#line 773
    i = 0;
    {
#line 773
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 773
      if (! (i <= 2)) {
#line 773
        goto while_break___1;
      }
      {
#line 774
      close(i);
#line 773
      i ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 777
    sp_setup_forked(sp, 0);
    }
#line 780
    if (g_clstate.quarantine) {
      {
#line 781
      setenv("EMAIL", (char const   *)(qfilename), 1);
      }
    }
#line 783
    if (virus) {
      {
#line 784
      setenv("VIRUS", virus, 1);
      }
    }
    {
#line 787
    execl("/bin/sh", "sh", "-c", g_clstate.virusaction, (void *)0);
#line 791
    _exit(1);
    }
#line 792
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 796
  return (0);
}
}
#line 120 "/usr/include/strings.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncasecmp)(char const   *__s1 ,
                                                                                                    char const   *__s2 ,
                                                                                                    size_t __n )  __attribute__((__pure__)) ;
#line 55 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/stringx.c"
int is_first_word(char const   *line , char const   *word , int len ) 
{ 
  unsigned short const   **tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;
  int tmp___2 ;

  {
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
#line 61
    if (*line) {
      {
#line 61
      tmp = __ctype_b_loc();
      }
#line 61
      if (! ((int const   )*(*tmp + (int )*line) & 8192)) {
#line 61
        goto while_break;
      }
    } else {
#line 61
      goto while_break;
    }
#line 62
    line ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 64
  tmp___0 = strncasecmp(line, word, (size_t )len);
  }
#line 64
  if (tmp___0 != 0) {
#line 65
    return (0);
  }
#line 67
  line += len;
#line 68
  if (! *line) {
#line 68
    tmp___2 = 1;
  } else {
    {
#line 68
    tmp___1 = __ctype_b_loc();
    }
#line 68
    if ((int const   )*(*tmp___1 + (int )*line) & 8192) {
#line 68
      tmp___2 = 1;
    } else {
#line 68
      tmp___2 = 0;
    }
  }
#line 68
  return (tmp___2);
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/stringx.c"
int check_first_word(char const   *line , char const   *word , int len , char *delims ) 
{ 
  char const   *t ;
  int found ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  long tmp___2 ;

  {
#line 74
  found = 0;
#line 80
  t = line;
  {
#line 82
  while (1) {
    while_continue: /* CIL Label */ ;
#line 82
    if (*t) {
      {
#line 82
      tmp = strchr((char const   *)delims, (int )*t);
      }
#line 82
      if (! tmp) {
#line 82
        goto while_break;
      }
    } else {
#line 82
      goto while_break;
    }
#line 83
    t ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 85
  tmp___0 = strncasecmp(t, word, (size_t )len);
  }
#line 85
  if (tmp___0 != 0) {
#line 86
    return (0);
  }
#line 88
  t += len;
  {
#line 90
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 90
    if (*t) {
      {
#line 90
      tmp___1 = strchr((char const   *)delims, (int )*t);
      }
#line 90
      if (! tmp___1) {
#line 90
        goto while_break___0;
      }
    } else {
#line 90
      goto while_break___0;
    }
#line 92
    found = 1;
#line 93
    t ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 96
  if (! *t) {
#line 96
    tmp___2 = t - line;
  } else
#line 96
  if (found) {
#line 96
    tmp___2 = t - line;
  } else {
#line 96
    tmp___2 = 0L;
  }
#line 96
  return ((int )tmp___2);
}
}
#line 99 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/stringx.c"
int is_last_word(char const   *line , char const   *word , int len ) 
{ 
  char const   *t ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;

  {
  {
#line 107
  tmp = strlen(line);
#line 107
  t = line + tmp;
  }
  {
#line 109
  while (1) {
    while_continue: /* CIL Label */ ;
#line 109
    if ((unsigned long )t > (unsigned long )line) {
      {
#line 109
      tmp___0 = __ctype_b_loc();
      }
#line 109
      if (! ((int const   )*(*tmp___0 + (int )*(t - 1)) & 8192)) {
#line 109
        goto while_break;
      }
    } else {
#line 109
      goto while_break;
    }
#line 110
    t --;
  }
  while_break: /* CIL Label */ ;
  }
#line 112
  if ((unsigned long )(t - len) < (unsigned long )line) {
#line 113
    return (0);
  }
  {
#line 115
  tmp___1 = strncasecmp(t - len, word, (size_t )len);
  }
#line 115
  return (tmp___1 == 0);
}
}
#line 118 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/stringx.c"
int is_blank_line(char const   *line ) 
{ 
  unsigned short const   **tmp ;

  {
#line 121
  if (! *line) {
#line 122
    return (1);
  }
  {
#line 124
  while (1) {
    while_continue: /* CIL Label */ ;
#line 124
    if (*line) {
      {
#line 124
      tmp = __ctype_b_loc();
      }
#line 124
      if (! ((int const   )*(*tmp + (int )*line) & 8192)) {
#line 124
        goto while_break;
      }
    } else {
#line 124
      goto while_break;
    }
#line 125
    line ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 127
  return ((int const   )*line == 0);
}
}
#line 130 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/stringx.c"
char *trim_start(char const   *data ) 
{ 
  unsigned short const   **tmp ;

  {
  {
#line 132
  while (1) {
    while_continue: /* CIL Label */ ;
#line 132
    if (*data) {
      {
#line 132
      tmp = __ctype_b_loc();
      }
#line 132
      if (! ((int const   )*(*tmp + (int )*data) & 8192)) {
#line 132
        goto while_break;
      }
    } else {
#line 132
      goto while_break;
    }
#line 133
    data ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 134
  return ((char *)data);
}
}
#line 137 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/stringx.c"
char *trim_end(char *data ) 
{ 
  char *t ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;

  {
  {
#line 139
  tmp = strlen((char const   *)data);
#line 139
  t = data + tmp;
  }
  {
#line 141
  while (1) {
    while_continue: /* CIL Label */ ;
#line 141
    if ((unsigned long )t > (unsigned long )data) {
      {
#line 141
      tmp___0 = __ctype_b_loc();
      }
#line 141
      if (! ((int const   )*(*tmp___0 + (int )*(t - 1)) & 8192)) {
#line 141
        goto while_break;
      }
    } else {
#line 141
      goto while_break;
    }
#line 143
    t --;
#line 144
    *t = (char)0;
  }
  while_break: /* CIL Label */ ;
  }
#line 147
  return (data);
}
}
#line 150 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/stringx.c"
char *trim_space(char *data ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 152
  tmp = trim_start((char const   *)data);
#line 152
  data = tmp;
#line 153
  tmp___0 = trim_end(data);
  }
#line 153
  return (tmp___0);
}
}
#line 157 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/stringx.c"
int strtob(char const   *str ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 159
  tmp = strcasecmp(str, "0");
  }
#line 159
  if (tmp == 0) {
#line 164
    return (0);
  } else {
    {
#line 159
    tmp___0 = strcasecmp(str, "no");
    }
#line 159
    if (tmp___0 == 0) {
#line 164
      return (0);
    } else {
      {
#line 159
      tmp___1 = strcasecmp(str, "false");
      }
#line 159
      if (tmp___1 == 0) {
#line 164
        return (0);
      } else {
        {
#line 159
        tmp___2 = strcasecmp(str, "f");
        }
#line 159
        if (tmp___2 == 0) {
#line 164
          return (0);
        } else {
          {
#line 159
          tmp___3 = strcasecmp(str, "off");
          }
#line 159
          if (tmp___3 == 0) {
#line 164
            return (0);
          }
        }
      }
    }
  }
  {
#line 166
  tmp___4 = strcasecmp(str, "1");
  }
#line 166
  if (tmp___4 == 0) {
#line 171
    return (1);
  } else {
    {
#line 166
    tmp___5 = strcasecmp(str, "yes");
    }
#line 166
    if (tmp___5 == 0) {
#line 171
      return (1);
    } else {
      {
#line 166
      tmp___6 = strcasecmp(str, "true");
      }
#line 166
      if (tmp___6 == 0) {
#line 171
        return (1);
      } else {
        {
#line 166
        tmp___7 = strcasecmp(str, "t");
        }
#line 166
        if (tmp___7 == 0) {
#line 171
          return (1);
        } else {
          {
#line 166
          tmp___8 = strcasecmp(str, "on");
          }
#line 166
          if (tmp___8 == 0) {
#line 171
            return (1);
          }
        }
      }
    }
  }
#line 173
  return (-1);
}
}
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 76 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/compat.h"
char *strlwr(char *s ) ;
#line 80
char *strupr(char *s ) ;
#line 124 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 76 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/compat.c"
void *reallocf(void *ptr , size_t size ) 
{ 
  void *ret ;
  void *tmp ;

  {
  {
#line 78
  tmp = realloc(ptr, size);
#line 78
  ret = tmp;
  }
#line 80
  if (! ret) {
#line 80
    if (size) {
      {
#line 81
      free(ptr);
      }
    }
  }
#line 83
  return (ret);
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/compat.c"
char *strlwr(char *s ) 
{ 
  char *t ;
  int tmp ;

  {
#line 91
  t = s;
  {
#line 92
  while (1) {
    while_continue: /* CIL Label */ ;
#line 92
    if (! *t) {
#line 92
      goto while_break;
    }
    {
#line 94
    tmp = tolower((int )*t);
#line 94
    *t = (char )tmp;
#line 95
    t ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 97
  return (s);
}
}
#line 102 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/compat.c"
char *strupr(char *s ) 
{ 
  char *t ;
  int tmp ;

  {
#line 104
  t = s;
  {
#line 105
  while (1) {
    while_continue: /* CIL Label */ ;
#line 105
    if (! *t) {
#line 105
      goto while_break;
    }
    {
#line 107
    tmp = toupper((int )*t);
#line 107
    *t = (char )tmp;
#line 108
    t ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 110
  return (s);
}
}
#line 116 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/compat.c"
size_t strlcpy(char *dst , char const   *src , size_t siz ) 
{ 
  char *d ;
  char const   *s ;
  size_t n ;
  char *tmp ;
  char tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;

  {
#line 118
  d = dst;
#line 119
  s = src;
#line 120
  n = siz;
#line 123
  if (n != 0UL) {
#line 123
    n --;
#line 123
    if (n != 0UL) {
      {
#line 125
      while (1) {
        while_continue: /* CIL Label */ ;
#line 127
        tmp = d;
#line 127
        d ++;
#line 127
        tmp___1 = s;
#line 127
        s ++;
#line 127
        tmp___0 = (char )*tmp___1;
#line 127
        *tmp = tmp___0;
#line 127
        if ((int )tmp___0 == 0) {
#line 128
          goto while_break;
        }
#line 125
        n --;
#line 125
        if (! (n != 0UL)) {
#line 125
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 134
  if (n == 0UL) {
#line 136
    if (siz != 0UL) {
#line 137
      *d = (char )'\000';
    }
    {
#line 138
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 138
      tmp___2 = s;
#line 138
      s ++;
#line 138
      if (! *tmp___2) {
#line 138
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 142
  return ((size_t )((s - src) - 1L));
}
}
#line 149 "/home/june/repo/benchmarks/collector/temp/clamsmtp-1.10/src/../common/compat.c"
size_t strlcat(char *dst , char const   *src , size_t siz ) 
{ 
  char *d ;
  char const   *s ;
  size_t n ;
  size_t dlen ;
  size_t tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;

  {
#line 151
  d = dst;
#line 152
  s = src;
#line 153
  n = siz;
  {
#line 157
  while (1) {
    while_continue: /* CIL Label */ ;
#line 157
    tmp = n;
#line 157
    n --;
#line 157
    if (tmp != 0UL) {
#line 157
      if (! ((int )*d != 0)) {
#line 157
        goto while_break;
      }
    } else {
#line 157
      goto while_break;
    }
#line 158
    d ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 159
  dlen = (size_t )(d - dst);
#line 160
  n = siz - dlen;
#line 162
  if (n == 0UL) {
    {
#line 163
    tmp___0 = strlen(s);
    }
#line 163
    return (dlen + tmp___0);
  }
  {
#line 164
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 164
    if (! ((int const   )*s != 0)) {
#line 164
      goto while_break___0;
    }
#line 166
    if (n != 1UL) {
#line 168
      tmp___1 = d;
#line 168
      d ++;
#line 168
      *tmp___1 = (char )*s;
#line 169
      n --;
    }
#line 172
    s ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 175
  *d = (char )'\000';
#line 177
  return (dlen + (size_t )(s - src));
}
}
