/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 27 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/htp.h"
typedef unsigned int BOOL;
#line 34 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/htp.h"
typedef unsigned long DWORD;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 152 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned int uint;
#line 17 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/image.h"
struct tagIMAGEFILE {
   char *name ;
   FILE *file ;
   uint imageType ;
};
#line 17 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/image.h"
typedef struct tagIMAGEFILE IMAGEFILE;
#line 20 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/image.c"
struct tagIMAGEURL {
   char *url ;
   char *path ;
   struct tagIMAGEURL *next ;
};
#line 20 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/image.c"
typedef struct tagIMAGEURL IMAGEURL;
#line 130 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/image.c"
struct __anonstruct_ImageOps_31 {
   BOOL (*checkFormat)(FILE *file ) ;
   BOOL (*readDimensions)(FILE *file , DWORD *height , DWORD *width ) ;
};
#line 130 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/image.c"
typedef struct __anonstruct_ImageOps_31 ImageOps;
#line 33 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/htp.h"
typedef unsigned short WORD;
#line 150 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned long ulong;
#line 23 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/html.h"
struct tagHTML_ATTRIBUTE {
   char *name ;
   char *value ;
   int quotes ;
   char *whitespace ;
   struct tagHTML_ATTRIBUTE *next ;
};
#line 23 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/html.h"
typedef struct tagHTML_ATTRIBUTE HTML_ATTRIBUTE;
#line 32 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/html.h"
struct tagHTML_MARKUP {
   char *tag ;
   BOOL single ;
   char *whitespace ;
   HTML_ATTRIBUTE *attrib ;
};
#line 32 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/html.h"
typedef struct tagHTML_MARKUP HTML_MARKUP;
#line 18 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/textfile.h"
struct tagFILEINFO {
   FILE *file ;
   uint pendingSpaces ;
   BOOL emptyLine ;
   WORD flags ;
};
#line 18 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/textfile.h"
typedef struct tagFILEINFO TEXTFILE;
#line 28 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/streams.h"
struct tagSTREAMBUFFER {
   char *buffer ;
   ulong offset ;
   ulong length ;
};
#line 28 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/streams.h"
typedef struct tagSTREAMBUFFER STREAMBUFFER;
#line 34 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/streams.h"
union __anonunion_u_30 {
   TEXTFILE textfile ;
   STREAMBUFFER buffer ;
};
#line 34 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/streams.h"
struct tagSTREAM {
   uint sflags ;
   uint lineNumber ;
   char const   *name ;
   BOOL hasUnread ;
   char unread ;
   union __anonunion_u_30 u ;
};
#line 34 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/streams.h"
typedef struct tagSTREAM STREAM;
#line 32 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/varstore.h"
struct tagVARIABLE {
   struct tagVARIABLE *left ;
   struct tagVARIABLE *right ;
   char *name ;
   void *value ;
   uint type ;
   uint flag ;
   void *param ;
   void (*destructor)(char const   *name , void *value , uint type , uint flag , void *param ) ;
};
#line 32 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/varstore.h"
typedef struct tagVARIABLE VARIABLE;
#line 50 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/varstore.h"
struct tagVARSTORE {
   struct tagVARSTORE *parent ;
   struct tagVARSTORE *child ;
   VARIABLE *root ;
   BOOL isGlobal ;
};
#line 50 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/varstore.h"
typedef struct tagVARSTORE VARSTORE;
#line 87 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/defs.h"
struct tagTASK {
   STREAM *infile ;
   STREAM *outfile ;
   VARSTORE *varstore ;
   char const   *sourceFilename ;
   uint conditionalLevel ;
   uint conditionalLine[32] ;
};
#line 87 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/defs.h"
typedef struct tagTASK TASK;
#line 32 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/htp.h"
typedef unsigned char BYTE;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 149 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/htp.h"
struct tagFIND_TOKEN {
   char const   *tokens ;
   char *lastChar ;
   char *nextStart ;
};
#line 149 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/htp.h"
typedef struct tagFIND_TOKEN FIND_TOKEN;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 101 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/defs.h"
struct tagMARKUP_PROCESSORS {
   char const   *tag ;
   uint markupType ;
   uint (*markupFunc)(TASK *task , HTML_MARKUP *htmlMarkup , char **newPlaintext ) ;
};
#line 101 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/defs.h"
typedef struct tagMARKUP_PROCESSORS MARKUP_PROCESSORS;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 107 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/option.c"
struct __anonstruct_opt_31 {
   char *name ;
   uint index ;
   uint value ;
};
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 399 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 538
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncasecmp)(char const   *__s1 ,
                                                                                                    char const   *__s2 ,
                                                                                                    size_t __n )  __attribute__((__pure__)) ;
#line 24 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/image.h"
BOOL OpenImageFile(char const   *filename , IMAGEFILE *imageFile ) ;
#line 25
void CloseImageFile(IMAGEFILE *imageFile ) ;
#line 26
BOOL GetImageDimensions(IMAGEFILE *imageFile , DWORD *width , DWORD *height ) ;
#line 33
BOOL ExistsImageUrl(char const   *url ) ;
#line 34
BOOL StoreImageUrl(char const   *url , char *path ) ;
#line 35
BOOL RemoveImageUrl(char const   *url ) ;
#line 134 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/htp.h"
char *StringCopy(char *dest , char const   *src , uint size ) ;
#line 135
char *ConvertDirDelimiter(char const   *pathname ) ;
#line 138
char *DuplicateString(char const   *src ) ;
#line 15 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/gif.h"
BOOL GifFormatFound(FILE *file ) ;
#line 18
BOOL GifReadDimensions(FILE *file , DWORD *height , DWORD *width ) ;
#line 15 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/jpeg.h"
BOOL JpegFormatFound(FILE *file ) ;
#line 18
BOOL JpegReadDimensions(FILE *file , DWORD *height , DWORD *width ) ;
#line 16 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/png.h"
BOOL PngFormatFound(FILE *file ) ;
#line 19
BOOL PngReadDimensions(FILE *file , DWORD *height , DWORD *width ) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/image.c"
static IMAGEURL *imageurl_store  =    (IMAGEURL *)((void *)0);
#line 29 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/image.c"
IMAGEURL *FindImageUrl(char const   *url ) 
{ 
  IMAGEURL *urls ;
  int tmp ;

  {
#line 31
  urls = imageurl_store;
  {
#line 32
  while (1) {
    while_continue: /* CIL Label */ ;
#line 32
    if (! ((unsigned long )urls != (unsigned long )((void *)0))) {
#line 32
      goto while_break;
    }
    {
#line 33
    tmp = strcasecmp(url, (char const   *)urls->url);
    }
#line 33
    if (tmp == 0) {
#line 34
      return (urls);
    }
#line 36
    urls = urls->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 38
  return ((IMAGEURL *)((void *)0));
}
}
#line 41 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/image.c"
BOOL ExistsImageUrl(char const   *url ) 
{ 


  {
#line 43
  return ((BOOL )((unsigned long )(& FindImageUrl) != (unsigned long )((void *)0)));
}
}
#line 47 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/image.c"
BOOL StoreImageUrl(char const   *url , char *path ) 
{ 
  IMAGEURL *urls ;
  void *tmp ;
  char *tmp___0 ;

  {
  {
#line 50
  urls = FindImageUrl(url);
  }
#line 51
  if ((unsigned long )urls == (unsigned long )((void *)0)) {
    {
#line 52
    tmp = malloc(sizeof(IMAGEURL ));
#line 52
    urls = (IMAGEURL *)tmp;
    }
#line 52
    if ((unsigned long )urls == (unsigned long )((void *)0)) {
#line 55
      return ((BOOL )0);
    }
    {
#line 57
    tmp___0 = DuplicateString(url);
#line 57
    urls->url = tmp___0;
    }
#line 57
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
      {
#line 59
      free((void *)urls);
      }
#line 61
      return ((BOOL )0);
    }
#line 63
    urls->next = imageurl_store;
#line 64
    imageurl_store = urls;
  } else {
    {
#line 66
    free((void *)urls->path);
    }
  }
#line 68
  urls->path = path;
#line 69
  return ((BOOL )1);
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/image.c"
BOOL RemoveImageUrl(char const   *url ) 
{ 
  IMAGEURL *urls ;
  IMAGEURL **prev ;
  int tmp ;

  {
#line 75
  prev = & imageurl_store;
#line 76
  urls = imageurl_store;
  {
#line 77
  while (1) {
    while_continue: /* CIL Label */ ;
#line 77
    if (! ((unsigned long )urls != (unsigned long )((void *)0))) {
#line 77
      goto while_break;
    }
    {
#line 78
    tmp = strcasecmp(url, (char const   *)urls->url);
    }
#line 78
    if (tmp == 0) {
#line 79
      goto while_break;
    }
#line 81
    prev = & urls->next;
#line 82
    urls = urls->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 84
  if ((unsigned long )urls == (unsigned long )((void *)0)) {
#line 86
    return ((BOOL )0);
  }
  {
#line 88
  *prev = urls->next;
#line 90
  free((void *)urls->url);
#line 91
  free((void *)urls->path);
#line 92
  free((void *)urls);
  }
#line 93
  return ((BOOL )1);
}
}
#line 98 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/image.c"
char *GetPathFor(IMAGEURL *imageurl , char const   *src ) 
{ 
  uint urlsize ;
  uint srcsize ;
  uint pathsize ;
  uint suffixsize ;
  uint length ;
  char *filename ;
  char *suffix ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;

  {
  {
#line 103
  tmp = strlen((char const   *)imageurl->url);
#line 103
  urlsize = (uint )tmp;
#line 104
  tmp___0 = strlen(src);
#line 104
  srcsize = (uint )tmp___0;
  }
#line 105
  if (srcsize < urlsize) {
#line 106
    return ((char *)((void *)0));
  }
  {
#line 108
  tmp___1 = strncasecmp((char const   *)imageurl->url, src, (size_t )urlsize);
  }
#line 108
  if (tmp___1 != 0) {
#line 109
    return ((char *)((void *)0));
  }
  {
#line 111
  tmp___2 = strlen((char const   *)imageurl->path);
#line 111
  pathsize = (uint )tmp___2;
#line 112
  suffix = ConvertDirDelimiter(src + urlsize);
#line 113
  tmp___3 = strlen((char const   *)suffix);
#line 113
  suffixsize = (uint )tmp___3;
#line 114
  length = pathsize + suffixsize;
#line 116
  tmp___4 = malloc((size_t )(length + 1U));
#line 116
  filename = (char *)tmp___4;
  }
#line 116
  if ((unsigned long )filename == (unsigned long )((void *)0)) {
#line 118
    return ((char *)((void *)0));
  }
  {
#line 120
  StringCopy(filename, (char const   *)imageurl->path, pathsize + 1U);
#line 121
  StringCopy(filename + pathsize, (char const   *)suffix, suffixsize + 1U);
#line 122
  *(filename + length) = (char)0;
#line 124
  free((void *)suffix);
  }
#line 125
  return (filename);
}
}
#line 135 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/image.c"
ImageOps ops[3]  = {      {& GifFormatFound, & GifReadDimensions}, 
        {& JpegFormatFound, & JpegReadDimensions}, 
        {& PngFormatFound, & PngReadDimensions}};
#line 144 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/image.c"
BOOL OpenImageFile(char const   *filename , IMAGEFILE *imageFile ) 
{ 
  uint type ;
  IMAGEURL *imageurl ;
  char *tmp ;
  char *tmp___0 ;
  BOOL tmp___1 ;

  {
#line 150
  imageFile->name = (char *)((void *)0);
#line 153
  imageurl = imageurl_store;
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if (! imageurl) {
#line 154
      goto while_break;
    }
    {
#line 156
    tmp = GetPathFor(imageurl, filename);
#line 156
    imageFile->name = tmp;
    }
#line 156
    if (tmp) {
#line 157
      goto while_break;
    }
#line 159
    imageurl = imageurl->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 162
  if ((unsigned long )imageFile->name == (unsigned long )((void *)0)) {
    {
#line 163
    tmp___0 = ConvertDirDelimiter(filename);
#line 163
    imageFile->name = tmp___0;
    }
#line 163
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 166
      return ((BOOL )0);
    }
  }
  {
#line 170
  imageFile->file = fopen((char const   */* __restrict  */)imageFile->name, (char const   */* __restrict  */)"rb");
  }
#line 171
  if ((unsigned long )imageFile->file == (unsigned long )((void *)0)) {
    {
#line 173
    free((void *)imageFile->name);
    }
#line 174
    return ((BOOL )0);
  }
#line 180
  type = (uint )0;
  {
#line 180
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 180
    if (! ((unsigned long )type < sizeof(ops) / sizeof(ImageOps ))) {
#line 180
      goto while_break___0;
    }
    {
#line 181
    tmp___1 = (*(ops[type].checkFormat))(imageFile->file);
    }
#line 181
    if (tmp___1) {
#line 182
      goto while_break___0;
    }
#line 180
    type ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 188
  imageFile->imageType = type;
#line 189
  return ((BOOL )1);
}
}
#line 192 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/image.c"
void CloseImageFile(IMAGEFILE *imageFile ) 
{ 


  {
  {
#line 198
  free((void *)imageFile->name);
#line 199
  fclose(imageFile->file);
#line 201
  imageFile->name = (char *)((void *)0);
#line 202
  imageFile->file = (FILE *)((void *)0);
  }
#line 203
  return;
}
}
#line 205 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/image.c"
BOOL GetImageDimensions(IMAGEFILE *imageFile , DWORD *width , DWORD *height ) 
{ 
  BOOL tmp ;

  {
#line 212
  if ((unsigned long )imageFile->imageType == sizeof(ops) / sizeof(ImageOps )) {
#line 213
    return ((BOOL )0);
  }
  {
#line 215
  tmp = (*(ops[imageFile->imageType].readDimensions))(imageFile->file, height, width);
  }
#line 215
  return (tmp);
}
}
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 56 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/html.h"
BOOL MarkupToPlaintext(HTML_MARKUP *htmlMarkup , char **plaintext ) ;
#line 59
void DestroyMarkupStruct(HTML_MARKUP *htmlMarkup ) ;
#line 61
BOOL UnlinkBoolAttributeInMarkup(HTML_MARKUP *htmlMarkup , char const   *name ) ;
#line 64
HTML_ATTRIBUTE *UnlinkAttributeInMarkup(HTML_MARKUP *htmlMarkup , char const   *name ) ;
#line 47 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/streams.h"
BOOL CreateBufferWriter(STREAM *stream , char const   *name ) ;
#line 49
BOOL FlushBufferWriter(STREAM *stream ) ;
#line 53
void CloseStream(STREAM *stream ) ;
#line 56
BOOL GetStreamChar(STREAM *stream , char *c ) ;
#line 57
BOOL UnreadStreamChar(STREAM *stream , char c ) ;
#line 61
BOOL StreamPrintF(STREAM *stream , char const   *format  , ...) ;
#line 106 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/varstore.h"
BOOL StoreVariable(VARSTORE *varstore , char const   *name , void *value , uint type ,
                   uint flag , void *param , void (*destructor)(char const   *name ,
                                                                void *value , uint type ,
                                                                uint flag , void *param ) ) ;
#line 118
BOOL RemoveVariable(VARSTORE *varstore , char const   *name ) ;
#line 130
uint GetVariableType(VARSTORE *varstore , char const   *name ) ;
#line 31 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/msg.h"
void HtpMsg(uint level , STREAM *textFile , char const   *format  , ...) ;
#line 141 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/defs.h"
char htpOpenMarkup ;
#line 142
char htpCloseMarkup ;
#line 23 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/def-proc.h"
void BlockDestructor(char const   *name , void *value , uint type , uint flags , void *param ) ;
#line 25
BOOL ReadBlockToFile(TASK *task , BOOL expand , char const   *tag , STREAM *blockFile ) ;
#line 27
BOOL ReadinBlock(TASK *task , HTML_MARKUP *htmlMarkup , STREAM *blockStream ) ;
#line 29
uint BlockProcessor(TASK *task , HTML_MARKUP *htmlMarkup , char **newPlaintext ) ;
#line 31
uint UndefProcessor(TASK *task , HTML_MARKUP *htmlMarkup , char **newPlaintext ) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/htp-files.h"
BOOL ReadHtmlMarkup(STREAM *infile , STREAM *outfile , uint *markupType , HTML_MARKUP *htmlMarkup ) ;
#line 29 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/macro.h"
uint ExpandAll(TASK *task , HTML_MARKUP *htmlMarkup , char **newPlaintextPtr , uint markupType ) ;
#line 25 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/def-proc.c"
void BlockDestructor(char const   *name , void *value , uint type , uint flags , void *param ) 
{ 
  STREAM *stream ;

  {
  {
#line 28
  stream = (STREAM *)value;
#line 29
  name = name;
#line 30
  type = type;
#line 31
  flags = flags;
#line 33
  CloseStream(stream);
#line 34
  free((void *)stream);
  }
#line 37
  if ((unsigned long )param != (unsigned long )((void *)0)) {
    {
#line 39
    free(param);
    }
  }
#line 41
  return;
}
}
#line 49 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/def-proc.c"
static uint blockDepth  =    (uint )0;
#line 43 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/def-proc.c"
BOOL ReadBlockToFile(TASK *task , BOOL expand , char const   *tag , STREAM *blockFile ) 
{ 
  char *plaintext ;
  char ch ;
  HTML_MARKUP newHtml ;
  BOOL result ;
  uint markupType ;
  STREAM *oldOutFile ;
  uint markupResult ;
  char const   *tmp ;
  BOOL tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  BOOL tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 54
  if (expand) {
#line 54
    tmp = "expanded";
  } else {
#line 54
    tmp = "raw";
  }
  {
#line 54
  HtpMsg((uint )0, task->infile, "reading %s block to memory", tmp);
#line 57
  oldOutFile = task->outfile;
#line 58
  task->outfile = blockFile;
#line 61
  tmp___0 = GetStreamChar(task->infile, & ch);
  }
#line 61
  if (tmp___0) {
#line 61
    if ((int )ch != 10) {
      {
#line 63
      UnreadStreamChar(task->infile, ch);
      }
    }
  }
  {
#line 66
  tmp___1 = DuplicateString((task->infile)->name);
#line 66
  (task->outfile)->name = (char const   *)tmp___1;
#line 67
  (task->outfile)->lineNumber = (task->infile)->lineNumber;
  }
  {
#line 72
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 74
    result = ReadHtmlMarkup(task->infile, blockFile, & markupType, & newHtml);
    }
#line 76
    if (result == 4294967295U) {
#line 78
      task->outfile = oldOutFile;
#line 79
      return ((BOOL )0);
    } else
#line 81
    if (result == 0U) {
      {
#line 84
      HtpMsg((uint )2, task->infile, "EOF encountered before %s in line %d was closed",
             tag, (task->outfile)->lineNumber);
#line 87
      task->outfile = oldOutFile;
      }
#line 88
      return ((BOOL )0);
    }
#line 91
    if (markupType & 2U) {
#line 91
      if (blockDepth == 0U) {
#line 91
        if ((int )*(newHtml.tag + 0) == 47) {
          {
#line 91
          tmp___2 = strcasecmp(tag, (char const   *)(newHtml.tag + 1));
          }
#line 91
          if (tmp___2 == 0) {
            {
#line 96
            DestroyMarkupStruct(& newHtml);
            }
#line 97
            goto while_break;
          }
        }
      }
    }
#line 100
    plaintext = (char *)((void *)0);
#line 101
    if (expand) {
      {
#line 103
      markupResult = ExpandAll(task, & newHtml, & plaintext, markupType);
      }
    } else {
#line 108
      if (markupType & 2U) {
        {
#line 111
        tmp___4 = strcasecmp(tag, (char const   *)newHtml.tag);
        }
#line 111
        if (tmp___4 == 0) {
#line 114
          blockDepth ++;
        } else
#line 116
        if ((int )*(newHtml.tag + 0) == 47) {
          {
#line 116
          tmp___3 = strcasecmp(tag, (char const   *)(newHtml.tag + 1));
          }
#line 116
          if (tmp___3 == 0) {
#line 120
            blockDepth --;
          }
        }
      }
      {
#line 128
      tmp___5 = MarkupToPlaintext(& newHtml, & plaintext);
      }
#line 128
      if (tmp___5 == 0U) {
        {
#line 130
        HtpMsg((uint )2, task->infile, "unable to build plain text from markup (out of memory?)");
#line 132
        task->outfile = oldOutFile;
        }
#line 133
        return ((uint )-1);
      }
#line 135
      markupResult = (uint )0;
    }
    {
#line 140
    if (markupResult == 0U) {
#line 140
      goto case_0;
    }
#line 151
    if (markupResult == 1U) {
#line 151
      goto case_1;
    }
#line 151
    if (markupResult == 3U) {
#line 151
      goto case_1;
    }
#line 158
    if (markupResult == 2U) {
#line 158
      goto case_2;
    }
#line 164
    if (markupResult == 4294967295U) {
#line 164
      goto case_4294967295;
    }
#line 172
    goto switch_default;
    case_0: /* CIL Label */ 
#line 144
    if (markupType & 2U) {
#line 144
      tmp___6 = (int )htpCloseMarkup;
    } else {
#line 144
      tmp___6 = '>';
    }
#line 144
    if (markupType & 2U) {
#line 144
      tmp___7 = (int )htpOpenMarkup;
    } else {
#line 144
      tmp___7 = '<';
    }
    {
#line 144
    StreamPrintF(blockFile, "%c%s%c", tmp___7, plaintext, tmp___6);
    }
#line 148
    goto switch_break;
    case_1: /* CIL Label */ 
    case_3: /* CIL Label */ 
    {
#line 154
    StreamPrintF(blockFile, "%s", plaintext);
    }
#line 156
    goto switch_break;
    case_2: /* CIL Label */ ;
#line 162
    goto switch_break;
    case_4294967295: /* CIL Label */ 
    {
#line 167
    free((void *)plaintext);
#line 168
    task->outfile = oldOutFile;
    }
#line 169
    return ((BOOL )0);
    switch_default: /* CIL Label */ 
    {
#line 174
    free((void *)plaintext);
#line 175
    printf((char const   */* __restrict  */)"%s: serious internal error\n", "htp");
#line 176
    exit(1);
    }
    switch_break: /* CIL Label */ ;
    }
    {
#line 181
    DestroyMarkupStruct(& newHtml);
    }
#line 184
    if (plaintext) {
      {
#line 185
      free((void *)plaintext);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 188
  task->outfile = oldOutFile;
#line 189
  return ((BOOL )1);
}
}
#line 192 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/def-proc.c"
BOOL ReadinBlock(TASK *task , HTML_MARKUP *htmlMarkup , STREAM *blockStream ) 
{ 
  BOOL expand ;
  BOOL tmp ;
  BOOL tmp___0 ;
  BOOL tmp___1 ;

  {
  {
#line 193
  tmp = UnlinkBoolAttributeInMarkup(htmlMarkup, "EXPAND");
#line 193
  expand = tmp;
  }
#line 195
  if ((unsigned long )htmlMarkup->attrib != (unsigned long )((void *)0)) {
    {
#line 196
    HtpMsg((uint )1, task->infile, "Unhandled %s attribute in %s markup", (htmlMarkup->attrib)->name,
           htmlMarkup->tag);
    }
  }
  {
#line 202
  tmp___0 = CreateBufferWriter(blockStream, (char const   *)htmlMarkup->tag);
  }
#line 202
  if (tmp___0 == 0U) {
    {
#line 204
    HtpMsg((uint )2, task->infile, "unable to create stream for %s macro", htmlMarkup->tag);
    }
#line 206
    return ((BOOL )0);
  }
  {
#line 209
  tmp___1 = ReadBlockToFile(task, expand, (char const   *)htmlMarkup->tag, blockStream);
  }
#line 209
  if (tmp___1 == 0U) {
    {
#line 210
    CloseStream(blockStream);
#line 211
    free((void *)blockStream);
    }
#line 212
    return ((BOOL )0);
  }
  {
#line 214
  FlushBufferWriter(blockStream);
  }
#line 215
  return ((BOOL )1);
}
}
#line 218 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/def-proc.c"
uint BlockProcessor(TASK *task , HTML_MARKUP *htmlMarkup , char **newPlaintext ) 
{ 
  char *defName ;
  char *param ;
  STREAM *stream ;
  BOOL blockMacro ;
  uint macroType ;
  VARSTORE *varstore ;
  HTML_ATTRIBUTE *attrib ;
  int tmp ;
  int tmp___0 ;
  BOOL tmp___1 ;
  void *tmp___2 ;
  BOOL tmp___3 ;
  BOOL tmp___4 ;

  {
  {
#line 227
  newPlaintext = newPlaintext;
#line 233
  tmp___0 = strcasecmp((char const   *)htmlMarkup->tag, "BLOCK");
  }
#line 233
  if (tmp___0 == 0) {
#line 235
    blockMacro = (BOOL )1;
#line 236
    macroType = (uint )2;
#line 238
    param = (char *)((void *)0);
  } else {
    {
#line 242
    blockMacro = (BOOL )0;
#line 243
    tmp = strcasecmp((char const   *)htmlMarkup->tag, "BLOCKDEF");
    }
#line 243
    if (tmp == 0) {
#line 245
      macroType = (uint )6;
    } else {
#line 250
      macroType = (uint )5;
    }
    {
#line 254
    attrib = UnlinkAttributeInMarkup(htmlMarkup, "OPTION");
    }
#line 255
    if ((unsigned long )attrib != (unsigned long )((void *)0)) {
      {
#line 256
      free((void *)attrib->name);
#line 257
      param = attrib->value;
      }
#line 258
      if (attrib->whitespace) {
        {
#line 259
        free((void *)attrib->whitespace);
        }
      }
      {
#line 260
      free((void *)attrib);
      }
    } else {
#line 264
      param = (char *)((void *)0);
    }
  }
  {
#line 269
  attrib = UnlinkAttributeInMarkup(htmlMarkup, "NAME");
  }
#line 270
  if ((unsigned long )attrib != (unsigned long )((void *)0)) {
#line 270
    if ((unsigned long )attrib->value != (unsigned long )((void *)0)) {
      {
#line 273
      free((void *)attrib->name);
#line 274
      defName = attrib->value;
      }
#line 275
      if (attrib->whitespace) {
        {
#line 276
        free((void *)attrib->whitespace);
        }
      }
      {
#line 277
      free((void *)attrib);
      }
    } else {
#line 270
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 283
    if ((unsigned long )attrib == (unsigned long )((void *)0)) {
#line 284
      attrib = htmlMarkup->attrib;
#line 285
      if ((unsigned long )attrib == (unsigned long )((void *)0)) {
        {
#line 287
        HtpMsg((uint )2, task->infile, "%s markup without name", htmlMarkup->tag);
        }
#line 289
        return ((uint )-1);
      }
#line 291
      htmlMarkup->attrib = attrib->next;
    }
#line 294
    defName = attrib->name;
#line 295
    if (attrib->whitespace) {
      {
#line 296
      free((void *)attrib->whitespace);
      }
    }
#line 297
    if ((unsigned long )attrib->value != (unsigned long )((void *)0)) {
#line 297
      goto _L;
    } else
#line 297
    if ((unsigned long )htmlMarkup->attrib != (unsigned long )((void *)0)) {
      _L: /* CIL Label */ 
      {
#line 299
      HtpMsg((uint )2, task->infile, "bad %s markup", htmlMarkup->tag);
      }
#line 301
      if ((unsigned long )attrib->value != (unsigned long )((void *)0)) {
        {
#line 302
        free((void *)attrib->value);
        }
      }
      {
#line 303
      free((void *)attrib);
      }
#line 304
      return ((uint )-1);
    }
    {
#line 306
    free((void *)attrib);
    }
#line 309
    if (! blockMacro) {
      {
#line 311
      HtpMsg((uint )2, task->infile, "%s requires NAME attribute", htmlMarkup->tag);
      }
#line 313
      return ((uint )-1);
    }
  }
  {
#line 318
  varstore = task->varstore;
#line 319
  tmp___1 = UnlinkBoolAttributeInMarkup(htmlMarkup, "GLOBAL");
  }
#line 319
  if (tmp___1) {
    {
#line 320
    while (1) {
      while_continue: /* CIL Label */ ;
#line 320
      if (! (! varstore->isGlobal)) {
#line 320
        goto while_break;
      }
#line 321
      varstore = varstore->parent;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 324
  tmp___2 = malloc(sizeof(STREAM ));
#line 324
  stream = (STREAM *)tmp___2;
#line 325
  tmp___3 = ReadinBlock(task, htmlMarkup, stream);
  }
#line 325
  if (! tmp___3) {
    {
#line 327
    free((void *)defName);
    }
#line 328
    if ((unsigned long )param != (unsigned long )((void *)0)) {
      {
#line 329
      free((void *)param);
      }
    }
#line 330
    return ((uint )-1);
  }
  {
#line 333
  tmp___4 = StoreVariable(varstore, (char const   *)defName, (void *)stream, macroType,
                          (uint )4, (void *)param, & BlockDestructor);
  }
#line 333
  if (tmp___4 == 0U) {
    {
#line 336
    HtpMsg((uint )2, task->infile, "unable to store macro information (out of memory?)");
#line 338
    free((void *)defName);
    }
#line 339
    if ((unsigned long )param != (unsigned long )((void *)0)) {
      {
#line 340
      free((void *)param);
      }
    }
#line 341
    return ((uint )-1);
  }
#line 344
  return ((uint )2);
}
}
#line 348 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/def-proc.c"
uint UndefProcessor(TASK *task , HTML_MARKUP *htmlMarkup , char **newPlaintext ) 
{ 
  HTML_ATTRIBUTE *attrib ;
  uint type ;

  {
#line 353
  newPlaintext = newPlaintext;
#line 355
  attrib = htmlMarkup->attrib;
#line 358
  if ((unsigned long )htmlMarkup->attrib == (unsigned long )((void *)0)) {
    {
#line 360
    HtpMsg((uint )2, task->infile, "UNDEF requires at least one name");
    }
#line 361
    return ((uint )-1);
  }
  {
#line 365
  while (1) {
    while_continue: /* CIL Label */ ;
#line 365
    if (! ((unsigned long )attrib != (unsigned long )((void *)0))) {
#line 365
      goto while_break;
    }
    {
#line 368
    type = GetVariableType(task->varstore, (char const   *)attrib->name);
    }
#line 369
    if (type == 5U) {
      {
#line 371
      RemoveVariable(task->varstore, (char const   *)attrib->name);
#line 372
      HtpMsg((uint )0, task->infile, "metatag \"%s\" removed", attrib->name);
      }
    } else
#line 369
    if (type == 6U) {
      {
#line 371
      RemoveVariable(task->varstore, (char const   *)attrib->name);
#line 372
      HtpMsg((uint )0, task->infile, "metatag \"%s\" removed", attrib->name);
      }
    } else {
      {
#line 377
      HtpMsg((uint )2, task->infile, "metatag \"%s\" never defined", attrib->name);
      }
#line 380
      return ((uint )-1);
    }
#line 382
    attrib = attrib->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 385
  return ((uint )2);
}
}
#line 709 "/usr/include/stdio.h"
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 749
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 69 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 17 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/png.c"
BOOL PngFormatFound(FILE *file ) 
{ 
  BYTE header[8] ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 22
  tmp = fseek(file, 0L, 0);
  }
#line 22
  if (tmp != 0) {
#line 25
    return ((BOOL )0);
  }
  {
#line 29
  tmp___0 = fread((void */* __restrict  */)(header), (size_t )1, (size_t )8, (FILE */* __restrict  */)file);
  }
#line 29
  if (tmp___0 != 8UL) {
#line 32
    return ((BOOL )0);
  }
  {
#line 36
  tmp___4 = memcmp((void const   *)(header), (void const   *)"\211PNG\r\n\032\n",
                   (size_t )8);
  }
#line 36
  if (tmp___4 == 0) {
    {
#line 38
    tmp___1 = fseek(file, 12L, 0);
    }
#line 38
    if (tmp___1 != 0) {
#line 41
      return ((BOOL )0);
    }
    {
#line 44
    tmp___2 = fread((void */* __restrict  */)(header), (size_t )1, (size_t )4, (FILE */* __restrict  */)file);
    }
#line 44
    if (tmp___2 != 4UL) {
#line 47
      return ((BOOL )0);
    }
    {
#line 50
    tmp___3 = memcmp((void const   *)(header), (void const   *)"IHDR", (size_t )4);
    }
#line 50
    if (tmp___3 == 0) {
#line 53
      return ((BOOL )1);
    }
  }
#line 58
  return ((BOOL )0);
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/png.c"
BOOL PngReadDimensions(FILE *file , DWORD *height , DWORD *width ) 
{ 
  BYTE buff[8] ;
  int tmp ;
  size_t tmp___0 ;

  {
  {
#line 70
  tmp = fseek(file, 16L, 0);
  }
#line 70
  if (tmp != 0) {
#line 73
    return ((BOOL )0);
  }
  {
#line 79
  tmp___0 = fread((void */* __restrict  */)(buff), (size_t )1, (size_t )8, (FILE */* __restrict  */)file);
  }
#line 79
  if (tmp___0 != 8UL) {
#line 81
    return ((BOOL )0);
  }
#line 83
  *width = ((((DWORD )buff[0] << 24) | ((DWORD )buff[1] << 16)) | ((DWORD )buff[2] << 8)) | (DWORD )buff[3];
#line 84
  *height = ((((DWORD )buff[4] << 24) | ((DWORD )buff[5] << 16)) | ((DWORD )buff[6] << 8)) | (DWORD )buff[7];
#line 86
  return ((BOOL )1);
}
}
#line 306 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 531
extern int fgetc(FILE *__stream ) ;
#line 573
extern int fputc(int __c , FILE *__stream ) ;
#line 36 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/textfile.h"
BOOL OpenFile(char const   *filename , char const   *openFlags , TEXTFILE *textFile ) ;
#line 37
BOOL OpenFD(int filedes , char const   *openFlags , TEXTFILE *textFile ) ;
#line 38
void CloseFile(TEXTFILE *textFile ) ;
#line 42
BOOL GetFileChar(TEXTFILE *textFile , char *ch ) ;
#line 43
BOOL PutFileString(TEXTFILE *textFile , char const   *str ) ;
#line 40 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/option.h"
uint *currentOptions ;
#line 17 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/textfile.c"
BOOL OpenFile(char const   *filename , char const   *openFlags , TEXTFILE *textFile ) 
{ 
  char *os_filename ;

  {
  {
#line 28
  os_filename = ConvertDirDelimiter(filename);
  }
#line 28
  if ((unsigned long )os_filename == (unsigned long )((void *)0)) {
#line 31
    return ((BOOL )0);
  }
  {
#line 35
  textFile->emptyLine = (BOOL )1;
#line 36
  textFile->pendingSpaces = (uint )0;
#line 37
  textFile->flags = (WORD )0;
#line 38
  textFile->file = fopen((char const   */* __restrict  */)os_filename, (char const   */* __restrict  */)openFlags);
#line 39
  free((void *)os_filename);
  }
#line 41
  if ((unsigned long )textFile->file == (unsigned long )((void *)0)) {
#line 44
    return ((BOOL )0);
  }
#line 47
  return ((BOOL )1);
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/textfile.c"
BOOL OpenFD(int filedes , char const   *openFlags , TEXTFILE *textFile ) 
{ 


  {
  {
#line 57
  textFile->emptyLine = (BOOL )1;
#line 58
  textFile->pendingSpaces = (uint )0;
#line 59
  textFile->flags = (WORD )0;
#line 60
  textFile->file = fdopen(filedes, openFlags);
  }
#line 62
  if ((unsigned long )textFile->file == (unsigned long )((void *)0)) {
#line 65
    return ((BOOL )0);
  }
#line 68
  return ((BOOL )1);
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/textfile.c"
void CloseFile(TEXTFILE *textFile ) 
{ 


  {
  {
#line 76
  fclose(textFile->file);
#line 77
  textFile->file = (FILE *)((void *)0);
  }
#line 78
  return;
}
}
#line 80 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/textfile.c"
BOOL GetFileChar(TEXTFILE *textFile , char *ch ) 
{ 
  int getCh ;

  {
  {
#line 88
  getCh = fgetc(textFile->file);
  }
#line 88
  if (getCh == -1) {
#line 90
    return ((BOOL )0);
  }
#line 93
  *ch = (char )getCh;
#line 94
  return ((BOOL )1);
}
}
#line 97 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/textfile.c"
BOOL PutFileString(TEXTFILE *textFile , char const   *str ) 
{ 
  char ch ;
  uint pendingSpaces ;
  uint condensing ;
  BOOL emptyLine ;
  char const   *tmp ;

  {
#line 107
  if (((int )textFile->flags & 2) != 0) {
#line 107
    condensing = (uint )0;
  } else {
#line 107
    condensing = *(currentOptions + 4);
  }
#line 110
  emptyLine = textFile->emptyLine;
#line 111
  pendingSpaces = textFile->pendingSpaces;
  {
#line 113
  while (1) {
    while_continue: /* CIL Label */ ;
#line 113
    tmp = str;
#line 113
    str ++;
#line 113
    ch = (char )*tmp;
#line 113
    if (! ((int )ch != 0)) {
#line 113
      goto while_break;
    }
#line 114
    if ((int )ch == 13) {
#line 115
      goto while_continue;
    }
#line 117
    if ((int )ch == 32) {
#line 119
      pendingSpaces ++;
#line 120
      goto while_continue;
    }
#line 123
    if ((int )ch == 10) {
#line 127
      if (condensing == 1U) {
#line 132
        pendingSpaces ++;
#line 133
        goto while_continue;
      }
#line 136
      if (condensing == 2U) {
#line 139
        pendingSpaces = (uint )0;
#line 142
        if (emptyLine) {
#line 143
          goto while_continue;
        }
      }
#line 146
      emptyLine = (BOOL )1;
    } else {
#line 150
      emptyLine = (BOOL )0;
    }
    {
#line 153
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 153
      if (! (pendingSpaces > 0U)) {
#line 153
        goto while_break___0;
      }
      {
#line 154
      fputc(' ', textFile->file);
#line 155
      pendingSpaces --;
      }
#line 156
      if (condensing == 1U) {
#line 157
        pendingSpaces = (uint )0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 160
    fputc((int )ch, textFile->file);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 162
  textFile->emptyLine = emptyLine;
#line 163
  textFile->pendingSpaces = pendingSpaces;
#line 164
  return ((BOOL )1);
}
}
#line 564 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 80 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/varstore.h"
BOOL InitializeVariableStore(VARSTORE *varstore ) ;
#line 85
void DestroyVariableStore(VARSTORE *varstore ) ;
#line 93
void PushVariableStoreContext(VARSTORE *parent , VARSTORE *varstore ) ;
#line 94
VARSTORE *PopVariableStoreContext(VARSTORE *varstore ) ;
#line 112
BOOL VariableExists(VARSTORE *varstore , char const   *name ) ;
#line 128
void *GetVariableValue(VARSTORE *varstore , char const   *name ) ;
#line 129
BOOL UpdateVariableValue(VARSTORE *varstore , char const   *name , void *value ) ;
#line 131
uint GetVariableFlag(VARSTORE *varstore , char const   *name ) ;
#line 132
void *GetVariableParam(VARSTORE *varstore , char const   *name ) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/varstore.c"
static VARIABLE *VariableSplay(char const   *name , VARIABLE **root ) 
{ 
  VARIABLE N ;
  VARIABLE *t ;
  VARIABLE *l ;
  VARIABLE *r ;
  VARIABLE *result ;
  int cmp ;
  VARIABLE *y ;
  VARIABLE *y___0 ;

  {
#line 39
  t = *root;
#line 40
  if ((unsigned long )t == (unsigned long )((void *)0)) {
#line 41
    return (t);
  }
  {
#line 44
  cmp = strcasecmp(name, (char const   *)t->name);
  }
#line 45
  if (cmp == 0) {
#line 46
    return (t);
  }
#line 49
  result = (VARIABLE *)((void *)0);
#line 50
  N.right = (struct tagVARIABLE *)((void *)0);
#line 50
  N.left = N.right;
#line 51
  r = & N;
#line 51
  l = r;
  {
#line 53
  while (1) {
    while_continue: /* CIL Label */ ;
#line 57
    if (cmp < 0) {
#line 58
      if ((unsigned long )t->left == (unsigned long )((void *)0)) {
#line 59
        goto while_break;
      }
      {
#line 61
      cmp = strcasecmp(name, (char const   *)(t->left)->name);
      }
#line 62
      if (cmp < 0) {
#line 64
        y = t->left;
#line 65
        t->left = y->right;
#line 66
        y->right = t;
#line 67
        t = y;
#line 72
        if ((unsigned long )t->left == (unsigned long )((void *)0)) {
#line 73
          goto while_break;
        }
        {
#line 74
        cmp = strcasecmp(name, (char const   *)(t->left)->name);
        }
      }
#line 77
      r->left = t;
#line 78
      r = t;
#line 79
      t = t->left;
    } else
#line 80
    if (cmp > 0) {
#line 81
      if ((unsigned long )t->right == (unsigned long )((void *)0)) {
#line 82
        goto while_break;
      }
      {
#line 84
      cmp = strcasecmp(name, (char const   *)(t->right)->name);
      }
#line 85
      if (cmp > 0) {
#line 87
        y___0 = t->right;
#line 88
        t->right = y___0->left;
#line 89
        y___0->left = t;
#line 90
        t = y___0;
#line 95
        if ((unsigned long )t->right == (unsigned long )((void *)0)) {
#line 96
          goto while_break;
        }
        {
#line 97
        cmp = strcasecmp(name, (char const   *)(t->right)->name);
        }
      }
#line 99
      l->right = t;
#line 100
      l = t;
#line 101
      t = t->right;
    } else {
#line 105
      result = t;
#line 106
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 109
  l->right = t->left;
#line 110
  r->left = t->right;
#line 111
  t->left = N.right;
#line 112
  t->right = N.left;
#line 113
  *root = t;
#line 114
  return (result);
}
}
#line 117 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/varstore.c"
BOOL InitializeVariableStore(VARSTORE *varstore ) 
{ 


  {
#line 122
  varstore->parent = (struct tagVARSTORE *)((void *)0);
#line 123
  varstore->root = (VARIABLE *)((void *)0);
#line 124
  varstore->child = (struct tagVARSTORE *)((void *)0);
#line 125
  varstore->isGlobal = (BOOL )0;
#line 127
  return ((BOOL )1);
}
}
#line 133 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/varstore.c"
static void DestroyVariable(VARIABLE *variable ) 
{ 


  {
#line 136
  if ((unsigned long )variable->destructor != (unsigned long )((void *)0)) {
    {
#line 138
    (*(variable->destructor))((char const   *)variable->name, variable->value, variable->type,
                              variable->flag, variable->param);
    }
  }
#line 142
  if (variable->flag & 4U) {
    {
#line 143
    free((void *)variable->name);
    }
  }
#line 145
  if (variable->flag & 2U) {
    {
#line 146
    free(variable->value);
    }
  }
#line 148
  return;
}
}
#line 150 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/varstore.c"
static void ClearVariableTree(VARIABLE *t ) 
{ 


  {
#line 152
  if ((unsigned long )t == (unsigned long )((void *)0)) {
#line 153
    return;
  }
  {
#line 155
  ClearVariableTree(t->left);
#line 156
  ClearVariableTree(t->right);
#line 157
  DestroyVariable(t);
#line 158
  free((void *)t);
  }
#line 159
  return;
}
}
#line 161 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/varstore.c"
void DestroyVariableStore(VARSTORE *varstore ) 
{ 


  {
#line 167
  if ((unsigned long )varstore->parent != (unsigned long )((void *)0)) {
#line 169
    (varstore->parent)->child = (struct tagVARSTORE *)((void *)0);
#line 170
    varstore->parent = (struct tagVARSTORE *)((void *)0);
  }
  {
#line 174
  ClearVariableTree(varstore->root);
#line 175
  varstore->root = (VARIABLE *)((void *)0);
  }
#line 176
  return;
}
}
#line 178 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/varstore.c"
static VARIABLE *FindVariable(VARSTORE *varstore , char const   *name ) 
{ 
  VARIABLE *ptr ;

  {
  {
#line 189
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 190
    ptr = VariableSplay(name, & varstore->root);
    }
#line 191
    if (ptr) {
#line 192
      return (ptr);
    }
#line 195
    varstore = varstore->parent;
#line 189
    if (! ((unsigned long )varstore != (unsigned long )((void *)0))) {
#line 189
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 198
  return ((VARIABLE *)((void *)0));
}
}
#line 201 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/varstore.c"
void *GetVariableValue(VARSTORE *varstore , char const   *name ) 
{ 
  char *value ;
  VARIABLE *variable ;

  {
#line 206
  if ((unsigned long )name != (unsigned long )((void *)0)) {
    {
#line 208
    variable = FindVariable(varstore, name);
    }
#line 208
    if ((unsigned long )variable != (unsigned long )((void *)0)) {
#line 210
      return (variable->value);
    }
    {
#line 212
    value = getenv(name);
    }
#line 212
    if ((unsigned long )value != (unsigned long )((void *)0)) {
#line 214
      return ((void *)value);
    }
  }
#line 218
  return ((void *)0);
}
}
#line 221 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/varstore.c"
BOOL StoreVariable(VARSTORE *varstore , char const   *name , void *value , uint type ,
                   uint flag , void *param , void (*destructor)(char const   *name ,
                                                                void *value , uint type ,
                                                                uint flag , void *param ) ) 
{ 
  VARIABLE *variable ;
  void *tmp ;
  struct tagVARIABLE *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 230
  variable = VariableSplay(name, & varstore->root);
  }
#line 232
  if (variable) {
    {
#line 235
    DestroyVariable(variable);
    }
  } else {
    {
#line 240
    tmp = malloc(sizeof(VARIABLE ));
#line 240
    variable = (VARIABLE *)tmp;
    }
#line 240
    if ((unsigned long )variable == (unsigned long )((void *)0)) {
#line 243
      return ((BOOL )0);
    }
#line 245
    if ((unsigned long )varstore->root == (unsigned long )((void *)0)) {
#line 246
      tmp___0 = (struct tagVARIABLE *)((void *)0);
#line 246
      variable->right = tmp___0;
#line 246
      variable->left = tmp___0;
    } else {
      {
#line 247
      tmp___1 = strcasecmp(name, (char const   *)(varstore->root)->name);
      }
#line 247
      if (tmp___1 < 0) {
#line 248
        variable->left = (varstore->root)->left;
#line 249
        variable->right = varstore->root;
#line 250
        (varstore->root)->left = (struct tagVARIABLE *)((void *)0);
      } else {
#line 252
        variable->right = (varstore->root)->right;
#line 253
        variable->left = varstore->root;
#line 254
        (varstore->root)->right = (struct tagVARIABLE *)((void *)0);
      }
    }
#line 256
    varstore->root = variable;
  }
#line 260
  variable->name = (char *)name;
#line 261
  variable->value = value;
#line 264
  variable->type = type;
#line 265
  variable->flag = flag;
#line 266
  variable->param = param;
#line 267
  variable->destructor = destructor;
#line 269
  return ((BOOL )1);
}
}
#line 275 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/varstore.c"
BOOL UpdateVariableValue(VARSTORE *varstore , char const   *name , void *value ) 
{ 
  VARIABLE *variable ;

  {
  {
#line 282
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 283
    variable = VariableSplay(name, & varstore->root);
    }
#line 284
    if (variable) {
#line 285
      goto while_break;
    }
#line 288
    if (varstore->isGlobal) {
#line 289
      goto while_break;
    }
#line 290
    varstore = varstore->parent;
#line 282
    if (! ((unsigned long )varstore != (unsigned long )((void *)0))) {
#line 282
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 293
  if ((unsigned long )variable == (unsigned long )((void *)0)) {
#line 294
    return ((BOOL )0);
  }
#line 297
  if ((unsigned long )variable->value != (unsigned long )((void *)0)) {
#line 297
    if (variable->flag & 2U) {
      {
#line 299
      free(variable->value);
      }
    }
  }
#line 301
  variable->value = value;
#line 302
  variable->flag |= 2U;
#line 303
  variable->flag &= 4294967287U;
#line 304
  return ((BOOL )1);
}
}
#line 307 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/varstore.c"
uint GetVariableType(VARSTORE *varstore , char const   *name ) 
{ 
  VARIABLE *variable ;
  char *tmp ;

  {
#line 311
  if ((unsigned long )name != (unsigned long )((void *)0)) {
    {
#line 313
    variable = FindVariable(varstore, name);
    }
#line 313
    if ((unsigned long )variable != (unsigned long )((void *)0)) {
#line 315
      return (variable->type);
    }
    {
#line 317
    tmp = getenv(name);
    }
#line 317
    if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 319
      return ((uint )1);
    }
  }
#line 323
  return ((uint )-1);
}
}
#line 326 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/varstore.c"
uint GetVariableFlag(VARSTORE *varstore , char const   *name ) 
{ 
  VARIABLE *variable ;

  {
#line 330
  if ((unsigned long )name != (unsigned long )((void *)0)) {
    {
#line 332
    variable = FindVariable(varstore, name);
    }
#line 332
    if ((unsigned long )variable != (unsigned long )((void *)0)) {
#line 334
      return (variable->flag);
    }
  }
#line 338
  return ((uint )-1);
}
}
#line 341 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/varstore.c"
BOOL RemoveVariable(VARSTORE *varstore , char const   *name ) 
{ 
  VARIABLE *ptr ;
  BOOL tmp ;

  {
  {
#line 348
  ptr = VariableSplay(name, & varstore->root);
  }
#line 349
  if (ptr) {
#line 352
    if ((unsigned long )ptr->left == (unsigned long )((void *)0)) {
#line 354
      varstore->root = ptr->right;
    } else {
      {
#line 358
      VariableSplay(name, & ptr->left);
#line 359
      varstore->root = ptr->left;
#line 360
      (varstore->root)->right = ptr->right;
      }
    }
    {
#line 363
    DestroyVariable(ptr);
#line 365
    free((void *)ptr);
    }
#line 366
    return ((BOOL )1);
  }
#line 370
  if ((unsigned long )varstore->parent != (unsigned long )((void *)0)) {
    {
#line 372
    tmp = RemoveVariable(varstore->parent, name);
    }
#line 372
    return (tmp);
  }
#line 375
  return ((BOOL )0);
}
}
#line 378 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/varstore.c"
BOOL VariableExists(VARSTORE *varstore , char const   *name ) 
{ 
  VARIABLE *tmp ;
  char *tmp___0 ;

  {
  {
#line 380
  tmp = FindVariable(varstore, name);
  }
#line 380
  if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 381
    return ((BOOL )1);
  }
  {
#line 383
  tmp___0 = getenv(name);
  }
#line 383
  if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 384
    return ((BOOL )1);
  }
#line 386
  return ((BOOL )0);
}
}
#line 389 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/varstore.c"
void *GetVariableParam(VARSTORE *varstore , char const   *name ) 
{ 
  VARIABLE *var ;

  {
#line 393
  if ((unsigned long )name != (unsigned long )((void *)0)) {
    {
#line 395
    var = FindVariable(varstore, name);
    }
#line 395
    if ((unsigned long )var != (unsigned long )((void *)0)) {
#line 397
      return (var->param);
    }
  }
#line 401
  return ((void *)0);
}
}
#line 404 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/varstore.c"
void PushVariableStoreContext(VARSTORE *parent , VARSTORE *varstore ) 
{ 


  {
#line 411
  parent->child = varstore;
#line 412
  varstore->parent = parent;
#line 413
  varstore->child = (struct tagVARSTORE *)((void *)0);
#line 414
  return;
}
}
#line 416 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/varstore.c"
VARSTORE *PopVariableStoreContext(VARSTORE *varstore ) 
{ 


  {
#line 422
  (varstore->parent)->child = (struct tagVARSTORE *)((void *)0);
#line 423
  varstore->parent = (struct tagVARSTORE *)((void *)0);
#line 425
  return (varstore);
}
}
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 315
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strpbrk)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 128 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/htp.h"
uint MarkupType(char delim ) ;
#line 136
BOOL FileExists(char const   *pathname ) ;
#line 137
char const   *FindFilename(char const   *pathname ) ;
#line 139
char *DuplicateSubString(char const   *src , int len ) ;
#line 156
char *StringFirstToken(FIND_TOKEN *findToken , char *string , char const   *tokens ) ;
#line 157
char *StringNextToken(FIND_TOKEN *findToken ) ;
#line 26 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/util.c"
uint MarkupType(char delim ) 
{ 
  uint markupType ;

  {
#line 30
  markupType = (uint )0;
#line 32
  if ((int )delim == 60) {
#line 34
    markupType |= 1U;
  } else
#line 32
  if ((int )delim == 62) {
#line 34
    markupType |= 1U;
  }
#line 37
  if ((int )delim == (int )htpOpenMarkup) {
#line 39
    markupType |= 2U;
  } else
#line 37
  if ((int )delim == (int )htpCloseMarkup) {
#line 39
    markupType |= 2U;
  }
#line 42
  return (markupType);
}
}
#line 127 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/util.c"
char const   *FindFilename(char const   *pathname ) 
{ 
  char const   *filePtr ;
  uint len ;
  size_t tmp ;
  char *tmp___0 ;

  {
#line 133
  if ((unsigned long )pathname == (unsigned long )((void *)0)) {
#line 135
    return ((char const   *)((void *)0));
  }
  {
#line 138
  tmp = strlen(pathname);
#line 138
  len = (uint )tmp;
  }
#line 139
  if (len == 0U) {
#line 141
    return (pathname);
  }
#line 144
  filePtr = (pathname + len) - 1;
  {
#line 145
  while (1) {
    while_continue: /* CIL Label */ ;
#line 145
    if (! ((unsigned long )filePtr != (unsigned long )pathname)) {
#line 145
      goto while_break;
    }
    {
#line 147
    tmp___0 = strchr("/\\", (int )*filePtr);
    }
#line 147
    if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 153
      return (filePtr + 1);
    }
#line 156
    filePtr --;
  }
  while_break: /* CIL Label */ ;
  }
#line 159
  return (pathname);
}
}
#line 168 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/util.c"
char *StringCopy(char *dest , char const   *src , uint size ) 
{ 


  {
  {
#line 173
  strncpy((char */* __restrict  */)dest, (char const   */* __restrict  */)src, (size_t )size);
#line 174
  *(dest + (size - 1U)) = (char)0;
  }
#line 176
  return (dest);
}
}
#line 183 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/util.c"
char *StringFirstToken(FIND_TOKEN *findToken , char *string , char const   *tokens ) 
{ 
  char *ptr ;
  size_t tmp ;

  {
  {
#line 190
  findToken->tokens = tokens;
#line 191
  tmp = strlen((char const   *)string);
#line 191
  findToken->lastChar = string + tmp;
#line 192
  findToken->nextStart = findToken->lastChar;
  }
#line 194
  if ((unsigned long )tokens == (unsigned long )((void *)0)) {
#line 196
    return (string);
  }
  {
#line 199
  ptr = strpbrk((char const   *)string, tokens);
  }
#line 199
  if ((unsigned long )ptr != (unsigned long )((void *)0)) {
#line 201
    *ptr = (char)0;
#line 202
    findToken->nextStart = ptr;
  }
#line 205
  return (string);
}
}
#line 208 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/util.c"
char *StringNextToken(FIND_TOKEN *findToken ) 
{ 
  char *ptr ;
  char *start ;

  {
#line 216
  ptr = findToken->nextStart;
#line 219
  if ((unsigned long )ptr == (unsigned long )findToken->lastChar) {
#line 221
    return ((char *)((void *)0));
  }
  {
#line 225
  ptr ++;
#line 226
  start = ptr;
#line 229
  ptr = strpbrk((char const   *)ptr, findToken->tokens);
  }
#line 229
  if ((unsigned long )ptr != (unsigned long )((void *)0)) {
#line 231
    *ptr = (char)0;
#line 232
    findToken->nextStart = ptr;
  } else {
#line 236
    findToken->nextStart = findToken->lastChar;
  }
#line 239
  return (start);
}
}
#line 247 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/util.c"
char *DuplicateString(char const   *src ) 
{ 
  char *new ;
  uint size ;
  size_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 254
  tmp = strlen(src);
#line 254
  size = (uint )(tmp + 1UL);
#line 257
  tmp___0 = malloc((size_t )size);
#line 257
  new = (char *)tmp___0;
  }
#line 257
  if ((unsigned long )new == (unsigned long )((void *)0)) {
#line 259
    return ((char *)((void *)0));
  }
  {
#line 263
  tmp___1 = memcpy((void */* __restrict  */)new, (void const   */* __restrict  */)src,
                   (size_t )size);
  }
#line 263
  return ((char *)tmp___1);
}
}
#line 270 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/util.c"
char *DuplicateSubString(char const   *src , int len ) 
{ 
  char *new ;
  uint size ;
  void *tmp ;

  {
  {
#line 277
  size = (uint )(len + 1);
#line 280
  tmp = malloc((size_t )size);
#line 280
  new = (char *)tmp;
  }
#line 280
  if ((unsigned long )new == (unsigned long )((void *)0)) {
#line 282
    return ((char *)((void *)0));
  }
  {
#line 286
  memcpy((void */* __restrict  */)new, (void const   */* __restrict  */)src, (size_t )len);
#line 287
  *(new + len) = (char)0;
  }
#line 288
  return (new);
}
}
#line 296 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/util.c"
char *ConvertDirDelimiter(char const   *pathname ) 
{ 
  char *newPathname ;
  char *strptr ;
  char *tmp ;

  {
#line 301
  if ((unsigned long )pathname == (unsigned long )((void *)0)) {
#line 303
    return ((char *)((void *)0));
  }
  {
#line 307
  newPathname = DuplicateString(pathname);
  }
#line 307
  if ((unsigned long )newPathname == (unsigned long )((void *)0)) {
#line 309
    return ((char *)((void *)0));
  }
#line 314
  strptr = newPathname;
  {
#line 315
  while (1) {
    while_continue: /* CIL Label */ ;
#line 315
    if (! ((int )*strptr != 0)) {
#line 315
      goto while_break;
    }
    {
#line 317
    tmp = strchr("\\", (int )*strptr);
    }
#line 317
    if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 319
      *strptr = (char )'/';
    }
#line 321
    strptr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 324
  return (newPathname);
}
}
#line 330 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/util.c"
BOOL FileExists(char const   *pathname ) 
{ 
  struct stat dummy ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 334
  tmp___1 = stat((char const   */* __restrict  */)pathname, (struct stat */* __restrict  */)(& dummy));
  }
#line 334
  if (tmp___1 == 0) {
#line 334
    tmp___0 = 1;
  } else {
#line 334
    tmp___0 = 0;
  }
#line 334
  return ((BOOL )tmp___0);
}
}
#line 21 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/ver.h"
void DisplayHeader(void) ;
#line 22
void usage(void) ;
#line 19 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/ver.c"
void DisplayHeader(void) 
{ 


  {
  {
#line 21
  printf((char const   */* __restrict  */)"\n%s %s - HTML pre-processor\n", "htp",
         "1.16");
#line 22
  printf((char const   */* __restrict  */)"Copyright (c) 1995-96 Jim Nelson\n");
#line 23
  printf((char const   */* __restrict  */)"Copyright (c) 2002-03 Jochen Hoenicke under Artistic License\n");
#line 24
  printf((char const   */* __restrict  */)"[%s]\n\n", "Linux/Posix");
  }
#line 25
  return;
}
}
#line 27 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/ver.c"
void usage(void) 
{ 


  {
  {
#line 29
  printf((char const   */* __restrict  */)"Original author, Jim Nelson.\n");
#line 30
  printf((char const   */* __restrict  */)"email:\thtp-discuss@lists.sourceforge.net\n");
#line 31
  printf((char const   */* __restrict  */)"WWW:\thttp://htp.sourceforge.net/\n\n");
#line 32
  printf((char const   */* __restrict  */)"usage: %s [options] <source HTML file> <reformatted HTML file>\n",
         "htp");
#line 34
  printf((char const   */* __restrict  */)"       %s [options] @<response file>\n",
         "htp");
#line 35
  printf((char const   */* __restrict  */)"       %s [options] @\n", "htp");
#line 36
  printf((char const   */* __restrict  */)"\nSee on-line reference for full details.\n");
#line 37
  printf((char const   */* __restrict  */)"\nThis is software is released unter the Artistic License.\n");
  }
#line 38
  return;
}
}
#line 386 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 19 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/set-proc.h"
uint SetProcessor(TASK *task , HTML_MARKUP *htmlMarkup , char **newPlaintext ) ;
#line 21
uint UnsetProcessor(TASK *task , HTML_MARKUP *htmlMarkup , char **newPlaintext ) ;
#line 24
uint IncProcessor(TASK *task , HTML_MARKUP *htmlMarkup , char **newPlaintext ) ;
#line 19 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/set-proc.c"
uint SetProcessor(TASK *task , HTML_MARKUP *htmlMarkup , char **newPlaintext ) 
{ 
  char *name ;
  char *value ;
  uint flag ;
  HTML_ATTRIBUTE *attrib ;
  VARSTORE *varstore ;
  BOOL tmp ;
  BOOL tmp___0 ;

  {
  {
#line 27
  newPlaintext = newPlaintext;
#line 29
  varstore = task->varstore;
#line 30
  tmp = UnlinkBoolAttributeInMarkup(htmlMarkup, "GLOBAL");
  }
#line 30
  if (tmp) {
    {
#line 31
    while (1) {
      while_continue: /* CIL Label */ ;
#line 31
      if (! (! varstore->isGlobal)) {
#line 31
        goto while_break;
      }
#line 32
      varstore = varstore->parent;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 36
  if ((unsigned long )htmlMarkup->attrib == (unsigned long )((void *)0)) {
    {
#line 38
    HtpMsg((uint )2, task->infile, "incomplete macro declaration");
    }
#line 39
    return ((uint )-1);
  }
  {
#line 43
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 43
    attrib = htmlMarkup->attrib;
#line 43
    if (! ((unsigned long )attrib != (unsigned long )((void *)0))) {
#line 43
      goto while_break___0;
    }
#line 45
    name = attrib->name;
#line 46
    value = attrib->value;
#line 48
    flag = (uint )6;
#line 49
    if (! value) {
#line 50
      value = (char *)"";
#line 51
      flag &= 4294967293U;
    }
    {
#line 55
    tmp___0 = StoreVariable(varstore, (char const   *)name, (void *)value, (uint )1,
                            flag, (void *)0, (void (*)(char const   *name , void *value ,
                                                       uint type , uint flag , void *param ))((void *)0));
    }
#line 55
    if (tmp___0 == 0U) {
      {
#line 59
      HtpMsg((uint )2, task->infile, "unable to store macro \"%s\" (out of memory?)",
             name);
      }
#line 62
      return ((uint )-1);
    }
    {
#line 65
    HtpMsg((uint )0, task->infile, "macro \"%s\" assigned value \"%s\"", name, value);
    }
#line 68
    if (attrib->whitespace) {
      {
#line 69
      free((void *)attrib->whitespace);
      }
    }
    {
#line 71
    htmlMarkup->attrib = attrib->next;
#line 72
    free((void *)attrib);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 75
  return ((uint )2);
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/set-proc.c"
uint UnsetProcessor(TASK *task , HTML_MARKUP *htmlMarkup , char **newPlaintext ) 
{ 
  HTML_ATTRIBUTE *attrib ;
  uint type ;

  {
#line 83
  newPlaintext = newPlaintext;
#line 85
  attrib = htmlMarkup->attrib;
#line 88
  if ((unsigned long )attrib == (unsigned long )((void *)0)) {
    {
#line 90
    HtpMsg((uint )2, task->infile, "UNDEF requires at least one name");
    }
#line 91
    return ((uint )-1);
  }
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;
#line 95
    if (! ((unsigned long )attrib != (unsigned long )((void *)0))) {
#line 95
      goto while_break;
    }
    {
#line 98
    type = GetVariableType(task->varstore, (char const   *)attrib->name);
    }
#line 99
    if (type == 1U) {
      {
#line 101
      RemoveVariable(task->varstore, (char const   *)attrib->name);
      }
    } else
#line 99
    if (type == 2U) {
      {
#line 101
      RemoveVariable(task->varstore, (char const   *)attrib->name);
      }
    } else {
      {
#line 105
      HtpMsg((uint )2, task->infile, "No macro \"%s\" to unset", attrib->name);
      }
#line 107
      return ((uint )-1);
    }
    {
#line 110
    HtpMsg((uint )0, task->infile, "macro \"%s\" unset", attrib->name);
#line 111
    attrib = attrib->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 113
  return ((uint )2);
}
}
#line 117 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/set-proc.c"
uint IncProcessor(TASK *task , HTML_MARKUP *htmlMarkup , char **newPlaintext ) 
{ 
  char const   *expansion ;
  char valueStr[32] ;
  int value ;
  HTML_ATTRIBUTE *attrib ;
  VARSTORE *varstore ;
  BOOL tmp ;
  BOOL tmp___0 ;
  uint tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  BOOL tmp___5 ;

  {
  {
#line 125
  varstore = task->varstore;
#line 126
  tmp = UnlinkBoolAttributeInMarkup(htmlMarkup, "GLOBAL");
  }
#line 126
  if (tmp) {
    {
#line 127
    while (1) {
      while_continue: /* CIL Label */ ;
#line 127
      if (! (! varstore->isGlobal)) {
#line 127
        goto while_break;
      }
#line 128
      varstore = varstore->parent;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 131
  attrib = htmlMarkup->attrib;
  {
#line 132
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 132
    if (! ((unsigned long )attrib != (unsigned long )((void *)0))) {
#line 132
      goto while_break___0;
    }
    {
#line 135
    tmp___0 = VariableExists(task->varstore, (char const   *)attrib->name);
    }
#line 135
    if (tmp___0 != 1U) {
      {
#line 138
      HtpMsg((uint )2, task->infile, "unrecognized macro name \"%s\"", attrib->name);
      }
#line 140
      return ((uint )-1);
    }
    {
#line 144
    tmp___1 = GetVariableType(task->varstore, (char const   *)attrib->name);
    }
#line 144
    if (tmp___1 != 1U) {
      {
#line 146
      HtpMsg((uint )2, task->infile, "\"%s\" is not a set macro.", attrib->name);
      }
#line 149
      return ((uint )-1);
    }
    {
#line 153
    tmp___2 = GetVariableValue(varstore, (char const   *)attrib->name);
#line 153
    expansion = (char const   *)tmp___2;
    }
#line 155
    if ((unsigned long )expansion == (unsigned long )((void *)0)) {
      {
#line 157
      HtpMsg((uint )1, task->infile, "no value for macro \"%s\"", attrib->name);
      }
#line 159
      return ((uint )-1);
    }
    {
#line 161
    value = atoi(expansion);
    }
#line 162
    if ((unsigned long )attrib->value != (unsigned long )((void *)0)) {
      {
#line 163
      tmp___3 = atoi((char const   *)attrib->value);
#line 163
      value += tmp___3;
      }
    } else {
#line 165
      value ++;
    }
    {
#line 167
    snprintf((char */* __restrict  */)(valueStr), (size_t )32, (char const   */* __restrict  */)"%i",
             value);
#line 169
    tmp___4 = DuplicateString((char const   *)(valueStr));
#line 169
    tmp___5 = UpdateVariableValue(task->varstore, (char const   *)attrib->name, (void *)tmp___4);
    }
#line 169
    if (tmp___5 == 0U) {
      {
#line 171
      HtpMsg((uint )1, task->infile, "new value %s for macro \"%s\" could not be stored.",
             valueStr, attrib->name);
      }
#line 174
      return ((uint )-1);
    }
    {
#line 176
    HtpMsg((uint )0, task->infile, "incrementing macro \"%s\" to %s", attrib->name,
           valueStr);
#line 178
    attrib = attrib->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 180
  return ((uint )2);
}
}
#line 178 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) remove)(char const   *__filename ) ;
#line 717 "/usr/include/stdlib.h"
extern int system(char const   *__command ) ;
#line 205 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) strftime)(char * __restrict  __s ,
                                                                                  size_t __maxsize ,
                                                                                  char const   * __restrict  __format ,
                                                                                  struct tm  const  * __restrict  __tp ) ;
#line 243
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 417
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pipe)(int *__pipedes ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 545
extern char **environ ;
#line 551
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execve)(char const   *__path ,
                                                                                               char * const  *__argv ,
                                                                                               char * const  *__envp ) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 52 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/html.h"
void DestroyAttribute(HTML_ATTRIBUTE *htmlAttribute ) ;
#line 62
char const   *MarkupAttributeValue(HTML_MARKUP *htmlMarkup , char const   *name ) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/streams.h"
BOOL CreateFileReader(STREAM *stream , char const   *filename ) ;
#line 51
BOOL CreateFDReader(STREAM *stream , char const   *filename , int filedes ) ;
#line 52
BOOL CreateFileWriter(STREAM *stream , char const   *filename , BOOL append ) ;
#line 113 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/defs.h"
char const   *VAR_TEMPLATE_NAME ;
#line 118
BOOL ProcessTask(TASK *task ) ;
#line 160
char searchPath[1024] ;
#line 43 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/htp-files.h"
BOOL SearchForFile(char const   *filename , char *fullPathname , uint size ) ;
#line 30 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/file-proc.h"
uint FileProcessor(TASK *task , HTML_MARKUP *htmlMarkup , char **newPlaintext ) ;
#line 31
uint OutputProcessor(TASK *task , HTML_MARKUP *htmlMarkup , char **newPlaintext ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 125 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/file-proc.c"
uint ExternalFileProcessor(TASK *task , HTML_MARKUP *htmlMarkup , char const   *externalName ,
                           char **newPlaintext ) 
{ 
  struct stat fileStat ;
  struct tm *fileTime ;
  HTML_ATTRIBUTE *attrib ;
  int tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  uint precision ;
  HTML_ATTRIBUTE *pattrib ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char const   *value ;

  {
  {
#line 39
  tmp = stat((char const   */* __restrict  */)externalName, (struct stat */* __restrict  */)(& fileStat));
  }
#line 39
  if (tmp != 0) {
    {
#line 41
    HtpMsg((uint )2, task->infile, "unable to retrieve file information on \"%s\"",
           externalName);
    }
#line 43
    return ((uint )-1);
  }
  {
#line 47
  tmp___1 = malloc((size_t )128);
#line 47
  tmp___0 = (char *)tmp___1;
#line 47
  *newPlaintext = tmp___0;
  }
#line 47
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
    {
#line 49
    HtpMsg((uint )2, task->infile, "unable to allocate memory for expansion");
    }
#line 50
    return ((uint )-1);
  }
  {
#line 54
  attrib = UnlinkAttributeInMarkup(htmlMarkup, "SIZE");
  }
#line 54
  if ((unsigned long )attrib != (unsigned long )((void *)0)) {
    {
#line 60
    precision = (uint )0;
#line 61
    pattrib = UnlinkAttributeInMarkup(htmlMarkup, "PRECISION");
    }
#line 61
    if ((unsigned long )pattrib != (unsigned long )((void *)0)) {
#line 63
      if ((unsigned long )pattrib->value != (unsigned long )((void *)0)) {
        {
#line 65
        tmp___2 = atoi((char const   *)pattrib->value);
#line 65
        precision = (uint )tmp___2;
        }
      } else {
        {
#line 69
        HtpMsg((uint )1, task->infile, "precision attribute needs a value");
        }
      }
      {
#line 72
      DestroyAttribute(pattrib);
#line 73
      free((void *)pattrib);
      }
    }
#line 77
    if ((unsigned long )attrib->value == (unsigned long )((void *)0)) {
      {
#line 80
      snprintf((char */* __restrict  */)*newPlaintext, (size_t )128, (char const   */* __restrict  */)"%lu",
               fileStat.st_size);
      }
    } else {
      {
#line 77
      tmp___6 = strcasecmp((char const   *)attrib->value, "BYTE");
      }
#line 77
      if (tmp___6 == 0) {
        {
#line 80
        snprintf((char */* __restrict  */)*newPlaintext, (size_t )128, (char const   */* __restrict  */)"%lu",
                 fileStat.st_size);
        }
      } else {
        {
#line 83
        tmp___5 = strcasecmp((char const   *)attrib->value, "KBYTE");
        }
#line 83
        if (tmp___5 == 0) {
          {
#line 85
          snprintf((char */* __restrict  */)*newPlaintext, (size_t )128, (char const   */* __restrict  */)"%.*f",
                   (int )precision, (double )fileStat.st_size / (double )1024L);
          }
        } else {
          {
#line 89
          tmp___4 = strcasecmp((char const   *)attrib->value, "MBYTE");
          }
#line 89
          if (tmp___4 == 0) {
            {
#line 91
            snprintf((char */* __restrict  */)*newPlaintext, (size_t )128, (char const   */* __restrict  */)"%.*f",
                     (int )precision, (double )fileStat.st_size / (double )1048576L);
            }
          } else {
            {
#line 95
            tmp___3 = strcasecmp((char const   *)attrib->value, "GBYTE");
            }
#line 95
            if (tmp___3 == 0) {
              {
#line 97
              snprintf((char */* __restrict  */)*newPlaintext, (size_t )128, (char const   */* __restrict  */)"%.*f",
                       (int )precision, (double )fileStat.st_size / (double )1073741824L);
              }
            } else {
              {
#line 104
              HtpMsg((uint )2, task->infile, "unknown SIZE specifier");
#line 105
              DestroyAttribute(attrib);
#line 106
              free((void *)attrib);
#line 107
              free((void *)*newPlaintext);
#line 108
              *newPlaintext = (char *)((void *)0);
              }
#line 109
              return ((uint )-1);
            }
          }
        }
      }
    }
    {
#line 111
    DestroyAttribute(attrib);
#line 112
    free((void *)attrib);
    }
  } else {
    {
#line 114
    attrib = UnlinkAttributeInMarkup(htmlMarkup, "TIME");
    }
#line 114
    if ((unsigned long )attrib != (unsigned long )((void *)0)) {
      {
#line 119
      fileTime = localtime((time_t const   *)(& fileStat.st_mtim.tv_sec));
#line 123
      value = MarkupAttributeValue(htmlMarkup, "TIME");
      }
#line 123
      if ((unsigned long )value != (unsigned long )((void *)0)) {
        {
#line 125
        strftime((char */* __restrict  */)*newPlaintext, (size_t )128, (char const   */* __restrict  */)value,
                 (struct tm  const  */* __restrict  */)fileTime);
        }
      } else {
        {
#line 129
        strftime((char */* __restrict  */)*newPlaintext, (size_t )128, (char const   */* __restrict  */)"%I:%M:%S %p",
                 (struct tm  const  */* __restrict  */)fileTime);
        }
      }
      {
#line 131
      DestroyAttribute(attrib);
#line 132
      free((void *)attrib);
      }
    } else {
      {
#line 134
      attrib = UnlinkAttributeInMarkup(htmlMarkup, "DATE");
      }
#line 134
      if ((unsigned long )attrib != (unsigned long )((void *)0)) {
        {
#line 137
        fileTime = localtime((time_t const   *)(& fileStat.st_mtim.tv_sec));
        }
#line 141
        if ((unsigned long )attrib->value != (unsigned long )((void *)0)) {
          {
#line 143
          strftime((char */* __restrict  */)*newPlaintext, (size_t )128, (char const   */* __restrict  */)attrib->value,
                   (struct tm  const  */* __restrict  */)fileTime);
          }
        } else {
          {
#line 148
          strftime((char */* __restrict  */)*newPlaintext, (size_t )128, (char const   */* __restrict  */)"%a %b %d, %Y",
                   (struct tm  const  */* __restrict  */)fileTime);
          }
        }
        {
#line 151
        DestroyAttribute(attrib);
#line 152
        free((void *)attrib);
        }
      } else {
        {
#line 157
        free((void *)*newPlaintext);
#line 158
        *newPlaintext = (char *)((void *)0);
#line 160
        HtpMsg((uint )2, task->infile, "invalid FILE tag");
        }
#line 161
        return ((uint )-1);
      }
    }
  }
#line 165
  return ((uint )3);
}
}
#line 168 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/file-proc.c"
uint FileExecuteProcessor(TASK *task , HTML_ATTRIBUTE *attrib , HTML_MARKUP *htmlMarkup ) 
{ 
  char const   *cmdline ;
  char const   *output ;
  HTML_ATTRIBUTE *outputAttrib ;
  BOOL redirect ;
  BOOL ignoreError ;
  STREAM infile ;
  TASK newTask ;
  BOOL result ;
  int exitCode ;
  pid_t pid ;
  int pipefds[2] ;
  char *argv[4] ;
  BOOL tmp ;
  int *tmp___0 ;
  __pid_t tmp___1 ;
  BOOL tmp___2 ;
  uint tmp___3 ;

  {
  {
#line 181
  result = (BOOL )1;
#line 187
  cmdline = (char const   *)attrib->value;
#line 189
  redirect = UnlinkBoolAttributeInMarkup(htmlMarkup, "REDIRECT");
#line 190
  ignoreError = UnlinkBoolAttributeInMarkup(htmlMarkup, "NOERROR");
#line 191
  outputAttrib = UnlinkAttributeInMarkup(htmlMarkup, "OUTPUT");
  }
#line 192
  if ((unsigned long )outputAttrib != (unsigned long )((void *)0)) {
#line 193
    output = (char const   *)outputAttrib->value;
  } else {
#line 195
    output = (char const   *)((void *)0);
  }
#line 198
  if ((unsigned long )output == (unsigned long )((void *)0)) {
#line 198
    if (redirect == 0U) {
      {
#line 200
      HtpMsg((uint )2, task->infile, "Either REDIRECT or OUTPUT must be specified for FILE EXECUTE");
      }
#line 201
      return ((uint )-1);
    }
  }
#line 204
  if ((unsigned long )output != (unsigned long )((void *)0)) {
#line 204
    if (redirect == 1U) {
      {
#line 206
      HtpMsg((uint )2, task->infile, "REDIRECT and OUTPUT cannot both be specified for FILE EXECUTE");
#line 207
      DestroyAttribute(outputAttrib);
#line 208
      free((void *)outputAttrib);
      }
#line 209
      return ((uint )-1);
    }
  }
  {
#line 212
  HtpMsg((uint )0, task->infile, "Executing command \"%s\" ...", cmdline);
  }
#line 237
  if (redirect) {
    {
#line 242
    pipe((int *)(pipefds));
#line 243
    pid = fork();
    }
#line 244
    if (pid == 0) {
#line 247
      if (redirect) {
        {
#line 248
        dup2(pipefds[1], 1);
#line 249
        close(pipefds[0]);
#line 250
        close(pipefds[1]);
        }
      }
      {
#line 253
      argv[0] = (char *)"sh";
#line 254
      argv[1] = (char *)"-c";
#line 255
      argv[2] = (char *)cmdline;
#line 256
      argv[3] = (char *)((void *)0);
#line 257
      execve("/bin/sh", (char * const  *)(argv), (char * const  *)environ);
#line 258
      exit(127);
      }
    } else {
      {
#line 260
      close(pipefds[1]);
      }
    }
#line 262
    if (pid == -1) {
#line 263
      exitCode = -1;
    } else {
      {
#line 265
      tmp = CreateFDReader(& infile, "stdout", pipefds[0]);
      }
#line 265
      if (tmp == 0U) {
        {
#line 267
        HtpMsg((uint )2, task->infile, "unable to open execute result file");
        }
#line 268
        return ((uint )-1);
      }
      {
#line 272
      newTask.infile = & infile;
#line 273
      newTask.outfile = task->outfile;
#line 274
      newTask.varstore = task->varstore;
#line 275
      newTask.sourceFilename = task->sourceFilename;
#line 278
      result = ProcessTask(& newTask);
      }
#line 280
      if (! result) {
        {
#line 284
        HtpMsg((uint )2, task->infile, "... in output from \'%s\'", cmdline);
        }
      }
      {
#line 288
      CloseStream(& infile);
      }
      {
#line 291
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 291
        tmp___1 = waitpid(pid, & exitCode, 0);
        }
#line 291
        if (! (tmp___1 == -1)) {
#line 291
          goto while_break;
        }
        {
#line 292
        tmp___0 = __errno_location();
        }
#line 292
        if (*tmp___0 != 4) {
#line 293
          exitCode = -1;
#line 294
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
  } else {
    {
#line 300
    exitCode = system(cmdline);
    }
  }
#line 305
  if (exitCode != 0) {
#line 305
    if (ignoreError == 0U) {
      {
#line 308
      HtpMsg((uint )2, task->infile, "Command \"%s\" exited with an error code of %u",
             cmdline, exitCode);
      }
#line 312
      if ((unsigned long )output != (unsigned long )((void *)0)) {
        {
#line 313
        remove(output);
        }
      }
#line 315
      if ((unsigned long )outputAttrib != (unsigned long )((void *)0)) {
        {
#line 316
        DestroyAttribute(outputAttrib);
#line 317
        free((void *)outputAttrib);
        }
      }
#line 319
      return ((uint )-1);
    }
  }
#line 322
  if ((unsigned long )output != (unsigned long )((void *)0)) {
    {
#line 326
    tmp___2 = CreateFileReader(& infile, output);
    }
#line 326
    if (tmp___2 == 0U) {
      {
#line 328
      HtpMsg((uint )2, task->infile, "unable to open execute result file");
      }
#line 329
      return ((uint )-1);
    }
    {
#line 333
    newTask.infile = & infile;
#line 334
    newTask.outfile = task->outfile;
#line 335
    newTask.varstore = task->varstore;
#line 336
    newTask.sourceFilename = task->sourceFilename;
#line 339
    result = ProcessTask(& newTask);
    }
#line 341
    if (! result) {
      {
#line 345
      HtpMsg((uint )2, task->infile, "... in output from \'%s\'", cmdline);
      }
    }
    {
#line 350
    CloseStream(& infile);
#line 351
    remove(output);
    }
#line 353
    if ((unsigned long )outputAttrib != (unsigned long )((void *)0)) {
      {
#line 354
      DestroyAttribute(outputAttrib);
#line 355
      free((void *)outputAttrib);
      }
    }
  }
#line 358
  if (result == 1U) {
#line 358
    tmp___3 = (uint )2;
  } else {
#line 358
    tmp___3 = (uint )-1;
  }
#line 358
  return (tmp___3);
}
}
#line 361 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/file-proc.c"
uint FileTemplateProcessor(TASK *task , HTML_ATTRIBUTE *attrib ) 
{ 
  BOOL tmp ;

  {
  {
#line 371
  tmp = StoreVariable(task->varstore, VAR_TEMPLATE_NAME, (void *)attrib->value, (uint )3,
                      (uint )2, (void *)0, (void (*)(char const   *name , void *value ,
                                                     uint type , uint flag , void *param ))((void *)0));
  }
#line 371
  if (tmp == 0U) {
    {
#line 375
    HtpMsg((uint )2, task->infile, "unable to store template filename for post-processing (out of memory?)");
    }
#line 377
    return ((uint )-1);
  }
#line 381
  attrib->value = (char *)((void *)0);
#line 383
  return ((uint )2);
}
}
#line 386 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/file-proc.c"
uint FileIncludeProcessor(TASK *task , char const   *filename , HTML_MARKUP *htmlMarkup ) 
{ 
  STREAM incfile ;
  BOOL result ;
  TASK newTask ;
  char fullPathname[256] ;
  VARSTORE varstore ;
  VARSTORE *topVarstore ;
  uint flag ;
  BOOL tmp ;
  BOOL tmp___0 ;
  BOOL tmp___1 ;
  HTML_ATTRIBUTE *attrib ;
  BOOL tmp___2 ;
  BOOL tmp___3 ;
  uint tmp___4 ;

  {
  {
#line 398
  tmp___1 = CreateFileReader(& incfile, filename);
  }
#line 398
  if (tmp___1 == 0U) {
    {
#line 401
    tmp = SearchForFile(filename, fullPathname, (uint )256);
    }
#line 401
    if (tmp == 0U) {
      {
#line 404
      HtpMsg((uint )2, task->infile, "unable to open include file \"%s\"", filename);
      }
#line 406
      return ((uint )-1);
    }
    {
#line 409
    tmp___0 = CreateFileReader(& incfile, (char const   *)(fullPathname));
    }
#line 409
    if (tmp___0 == 0U) {
      {
#line 411
      HtpMsg((uint )2, task->infile, "unable to open include file \"%s\"", fullPathname);
      }
#line 413
      return ((uint )-1);
    }
  } else {
    {
#line 418
    StringCopy(fullPathname, filename, (uint )256);
    }
  }
#line 423
  if ((unsigned long )htmlMarkup->attrib != (unsigned long )((void *)0)) {
    {
#line 426
    tmp___2 = InitializeVariableStore(& varstore);
    }
#line 426
    if (tmp___2 == 0U) {
      {
#line 428
      HtpMsg((uint )2, task->infile, "unable to initialize context for include file");
#line 429
      CloseStream(& incfile);
      }
#line 430
      return ((uint )-1);
    }
    {
#line 434
    while (1) {
      while_continue: /* CIL Label */ ;
#line 434
      if (! ((unsigned long )htmlMarkup->attrib != (unsigned long )((void *)0))) {
#line 434
        goto while_break;
      }
#line 436
      attrib = htmlMarkup->attrib;
#line 439
      flag = (uint )6;
#line 440
      if (! attrib->value) {
#line 441
        attrib->value = (char *)"";
#line 442
        flag &= 4294967293U;
      }
      {
#line 445
      tmp___3 = StoreVariable(& varstore, (char const   *)attrib->name, (void *)attrib->value,
                              (uint )1, (flag | 4U) | 2U, (void *)0, (void (*)(char const   *name ,
                                                                               void *value ,
                                                                               uint type ,
                                                                               uint flag ,
                                                                               void *param ))((void *)0));
      }
#line 445
      if (tmp___3 == 0U) {
        {
#line 450
        HtpMsg((uint )2, task->infile, "unable to add variable to context for include file");
#line 452
        CloseStream(& incfile);
#line 453
        DestroyVariableStore(& varstore);
        }
#line 454
        return ((uint )-1);
      }
#line 456
      if (attrib->whitespace) {
        {
#line 457
        free((void *)attrib->whitespace);
        }
      }
      {
#line 460
      htmlMarkup->attrib = attrib->next;
#line 461
      free((void *)attrib);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 465
    PushVariableStoreContext(task->varstore, & varstore);
#line 466
    topVarstore = & varstore;
    }
  } else {
#line 470
    topVarstore = task->varstore;
  }
  {
#line 474
  newTask.infile = & incfile;
#line 475
  newTask.outfile = task->outfile;
#line 476
  newTask.varstore = topVarstore;
#line 477
  newTask.sourceFilename = task->sourceFilename;
#line 480
  HtpMsg((uint )0, task->infile, "including file \"%s\"", fullPathname);
#line 483
  result = ProcessTask(& newTask);
  }
#line 484
  if (! result) {
    {
#line 488
    HtpMsg((uint )2, task->infile, "... in file included here");
    }
  }
#line 492
  if ((unsigned long )topVarstore == (unsigned long )(& varstore)) {
    {
#line 495
    PopVariableStoreContext(topVarstore);
#line 496
    DestroyVariableStore(& varstore);
    }
  }
  {
#line 499
  CloseStream(& incfile);
  }
#line 503
  if (result == 1U) {
#line 503
    tmp___4 = (uint )2;
  } else {
#line 503
    tmp___4 = (uint )-1;
  }
#line 503
  return (tmp___4);
}
}
#line 506 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/file-proc.c"
uint FileProcessor(TASK *task , HTML_MARKUP *htmlMarkup , char **newPlaintext ) 
{ 
  HTML_ATTRIBUTE *attrib ;
  BOOL result ;

  {
  {
#line 511
  attrib = UnlinkAttributeInMarkup(htmlMarkup, "EXECUTE");
  }
#line 511
  if ((unsigned long )attrib != (unsigned long )((void *)0)) {
    {
#line 513
    result = FileExecuteProcessor(task, attrib, htmlMarkup);
#line 514
    DestroyAttribute(attrib);
#line 515
    free((void *)attrib);
    }
  } else {
    {
#line 517
    attrib = UnlinkAttributeInMarkup(htmlMarkup, "TEMPLATE");
    }
#line 517
    if ((unsigned long )attrib != (unsigned long )((void *)0)) {
      {
#line 519
      result = FileTemplateProcessor(task, attrib);
#line 520
      DestroyAttribute(attrib);
#line 521
      free((void *)attrib);
      }
    } else {
      {
#line 524
      attrib = UnlinkAttributeInMarkup(htmlMarkup, "INCLUDE");
      }
#line 524
      if ((unsigned long )attrib != (unsigned long )((void *)0)) {
        {
#line 526
        result = FileIncludeProcessor(task, (char const   *)attrib->value, htmlMarkup);
#line 527
        DestroyAttribute(attrib);
#line 528
        free((void *)attrib);
        }
      } else {
        {
#line 531
        attrib = UnlinkAttributeInMarkup(htmlMarkup, "SEARCH");
        }
#line 531
        if ((unsigned long )attrib != (unsigned long )((void *)0)) {
#line 534
          if ((unsigned long )attrib->value != (unsigned long )((void *)0)) {
            {
#line 536
            StringCopy(searchPath, (char const   *)attrib->value, (uint )1024);
            }
          } else {
#line 541
            searchPath[0] = (char)0;
          }
          {
#line 543
          result = (BOOL )2;
#line 545
          DestroyAttribute(attrib);
#line 546
          free((void *)attrib);
          }
        } else {
          {
#line 548
          attrib = UnlinkAttributeInMarkup(htmlMarkup, "NAME");
          }
#line 548
          if ((unsigned long )attrib != (unsigned long )((void *)0)) {
#line 554
            if ((unsigned long )attrib->value != (unsigned long )((void *)0)) {
              {
#line 556
              result = ExternalFileProcessor(task, htmlMarkup, (char const   *)attrib->value,
                                             newPlaintext);
              }
            } else {
              {
#line 562
              *newPlaintext = DuplicateString((task->outfile)->name);
#line 563
              HtpMsg((uint )0, task->outfile, "adding output filename");
#line 564
              result = (BOOL )3;
              }
            }
            {
#line 566
            DestroyAttribute(attrib);
#line 567
            free((void *)attrib);
            }
          } else {
            {
#line 574
            result = ExternalFileProcessor(task, htmlMarkup, task->sourceFilename,
                                           newPlaintext);
            }
          }
        }
      }
    }
  }
#line 578
  if (result != 4294967295U) {
#line 578
    if ((unsigned long )htmlMarkup->attrib != (unsigned long )((void *)0)) {
      {
#line 580
      HtpMsg((uint )1, task->infile, "Unhandled %s attribute in %s markup", (htmlMarkup->attrib)->name,
             htmlMarkup->tag);
      }
    }
  }
#line 586
  return (result);
}
}
#line 589 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/file-proc.c"
uint OutputProcessor(TASK *task , HTML_MARKUP *htmlMarkup , char **newPlaintext ) 
{ 
  STREAM outputfile ;
  HTML_ATTRIBUTE *attrib ;
  BOOL append ;
  BOOL expand ;
  BOOL result ;
  BOOL tmp ;
  uint tmp___0 ;

  {
  {
#line 595
  newPlaintext = newPlaintext;
#line 598
  attrib = UnlinkAttributeInMarkup(htmlMarkup, "FILE");
  }
#line 598
  if ((unsigned long )attrib == (unsigned long )((void *)0)) {
    {
#line 600
    HtpMsg((uint )2, task->infile, "output filename not specified");
    }
#line 601
    return ((uint )-1);
  }
  {
#line 603
  append = UnlinkBoolAttributeInMarkup(htmlMarkup, "APPEND");
#line 604
  expand = UnlinkBoolAttributeInMarkup(htmlMarkup, "EXPAND");
  }
#line 606
  if ((unsigned long )htmlMarkup->attrib != (unsigned long )((void *)0)) {
    {
#line 607
    HtpMsg((uint )1, task->infile, "Unhandled %s attribute in %s markup", (htmlMarkup->attrib)->name,
           htmlMarkup->tag);
    }
  }
  {
#line 613
  tmp = CreateFileWriter(& outputfile, (char const   *)attrib->value, append);
  }
#line 613
  if (tmp == 0U) {
    {
#line 615
    HtpMsg((uint )2, task->infile, "unable to open output file \"%s\"", attrib->value);
    }
#line 617
    return ((uint )-1);
  }
  {
#line 619
  DestroyAttribute(attrib);
#line 620
  free((void *)attrib);
#line 622
  result = ReadBlockToFile(task, expand, (char const   *)htmlMarkup->tag, & outputfile);
#line 623
  free((void *)((char *)outputfile.name));
#line 624
  CloseStream(& outputfile);
  }
#line 626
  if (result == 0U) {
#line 626
    tmp___0 = (uint )-1;
  } else {
#line 626
    tmp___0 = (uint )2;
  }
#line 626
  return (tmp___0);
}
}
#line 48 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/streams.h"
BOOL CreateBufferReader(STREAM *stream , STREAM *writeStream ) ;
#line 60
BOOL PutStreamString(STREAM *stream , char const   *str ) ;
#line 20 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/use-proc.h"
uint UseProcessor(TASK *task , HTML_MARKUP *htmlMarkup , char **newPlaintext ) ;
#line 19 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/use-proc.c"
uint UseProcessor(TASK *task , HTML_MARKUP *htmlMarkup , char **newPlaintext ) 
{ 
  char const   *name ;
  HTML_ATTRIBUTE *nameAttrib ;
  char const   *value ;
  STREAM incfile ;
  BOOL noexpand ;
  int result ;
  uint type ;
  VARSTORE varstore ;
  VARSTORE *topVarstore ;
  int tmp ;
  BOOL tmp___0 ;
  BOOL tmp___1 ;
  void *tmp___2 ;
  TASK newTask ;
  STREAM *blockFile ;
  void *tmp___3 ;
  char const   *tmp___4 ;
  BOOL tmp___5 ;
  BOOL tmp___6 ;
  uint tmp___7 ;

  {
#line 31
  nameAttrib = htmlMarkup->attrib;
#line 32
  if ((unsigned long )nameAttrib == (unsigned long )((void *)0)) {
    {
#line 34
    HtpMsg((uint )2, task->infile, "USE markup without parameter");
    }
#line 35
    return ((uint )-1);
  }
#line 37
  if (nameAttrib->value) {
    {
#line 38
    tmp = strcasecmp((char const   *)nameAttrib->name, "NAME");
    }
#line 38
    if (tmp == 0) {
      {
#line 39
      HtpMsg((uint )1, task->infile, "deprecated USE syntax, see manual");
#line 41
      name = (char const   *)nameAttrib->value;
      }
    } else {
      {
#line 43
      HtpMsg((uint )2, task->infile, "illegal USE markup");
      }
#line 44
      return ((uint )-1);
    }
  } else {
#line 47
    name = (char const   *)nameAttrib->name;
  }
  {
#line 49
  htmlMarkup->attrib = nameAttrib->next;
#line 52
  noexpand = UnlinkBoolAttributeInMarkup(htmlMarkup, "NOEXPAND");
#line 55
  type = GetVariableType(task->varstore, name);
  }
#line 58
  if (type != 1U) {
#line 58
    if (type != 2U) {
      {
#line 60
      HtpMsg((uint )2, task->infile, "macro %s has not been declared", name);
#line 62
      DestroyAttribute(nameAttrib);
#line 63
      free((void *)nameAttrib);
      }
#line 64
      return ((uint )-1);
    }
  }
#line 69
  if ((unsigned long )htmlMarkup->attrib != (unsigned long )((void *)0)) {
#line 71
    if (type == 1U) {
      {
#line 74
      HtpMsg((uint )2, task->infile, "macro parameters can only be used for BLOCK macros");
#line 75
      DestroyAttribute(nameAttrib);
#line 76
      free((void *)nameAttrib);
      }
#line 77
      return ((uint )-1);
    }
    {
#line 81
    tmp___0 = InitializeVariableStore(& varstore);
    }
#line 81
    if (tmp___0 == 0U) {
      {
#line 83
      HtpMsg((uint )2, task->infile, "unable to initialize local context for macro");
#line 84
      DestroyAttribute(nameAttrib);
#line 85
      free((void *)nameAttrib);
      }
#line 86
      return ((uint )-1);
    }
    {
#line 90
    while (1) {
      while_continue: /* CIL Label */ ;
#line 90
      if (! ((unsigned long )htmlMarkup->attrib != (unsigned long )((void *)0))) {
#line 90
        goto while_break;
      }
      {
#line 95
      tmp___1 = StoreVariable(& varstore, (char const   *)(htmlMarkup->attrib)->name,
                              (void *)(htmlMarkup->attrib)->value, (uint )1, (uint )0,
                              (void *)0, (void (*)(char const   *name , void *value ,
                                                   uint type , uint flag , void *param ))((void *)0));
      }
#line 95
      if (tmp___1 == 0U) {
        {
#line 99
        HtpMsg((uint )2, task->infile, "unable to add variable to block\'s local context");
#line 100
        DestroyVariableStore(& varstore);
#line 101
        DestroyAttribute(nameAttrib);
#line 102
        free((void *)nameAttrib);
        }
#line 103
        return ((uint )-1);
      }
#line 105
      htmlMarkup->attrib = (htmlMarkup->attrib)->next;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 109
    PushVariableStoreContext(task->varstore, & varstore);
#line 110
    topVarstore = & varstore;
    }
  } else {
#line 114
    topVarstore = task->varstore;
  }
#line 117
  if (type == 1U) {
    {
#line 120
    tmp___2 = GetVariableValue(task->varstore, name);
#line 120
    value = (char const   *)tmp___2;
    }
#line 124
    if ((unsigned long )value == (unsigned long )((void *)0)) {
      {
#line 126
      DestroyAttribute(nameAttrib);
#line 127
      free((void *)nameAttrib);
      }
#line 128
      return ((uint )2);
    }
    {
#line 131
    HtpMsg((uint )0, task->infile, "dereferencing macro \"%s\"", name);
#line 133
    PutStreamString(task->outfile, value);
#line 134
    DestroyAttribute(nameAttrib);
#line 135
    free((void *)nameAttrib);
    }
#line 136
    return ((uint )2);
  } else {
    {
#line 145
    tmp___3 = GetVariableValue(task->varstore, name);
#line 145
    blockFile = (STREAM *)tmp___3;
    }
#line 150
    if (noexpand) {
#line 150
      tmp___4 = " with noexpand";
    } else {
#line 150
      tmp___4 = "";
    }
    {
#line 150
    HtpMsg((uint )0, task->infile, "dereferencing block macro \"%s\"%s", name, tmp___4);
    }
#line 151
    if (noexpand) {
      {
#line 153
      PutStreamString(task->outfile, (char const   *)blockFile->u.buffer.buffer);
#line 154
      DestroyAttribute(nameAttrib);
#line 155
      free((void *)nameAttrib);
      }
#line 156
      return ((uint )2);
    }
    {
#line 159
    tmp___5 = CreateBufferReader(& incfile, blockFile);
#line 159
    result = (int )tmp___5;
#line 163
    newTask.infile = & incfile;
#line 164
    newTask.outfile = task->outfile;
#line 165
    newTask.sourceFilename = task->sourceFilename;
#line 169
    newTask.varstore = topVarstore;
#line 172
    tmp___6 = ProcessTask(& newTask);
#line 172
    result = (int )tmp___6;
    }
#line 173
    if (! result) {
      {
#line 177
      HtpMsg((uint )2, task->infile, "... in block macro \"%s\"", name);
      }
    }
#line 182
    if ((unsigned long )topVarstore == (unsigned long )(& varstore)) {
      {
#line 185
      PopVariableStoreContext(& varstore);
#line 186
      DestroyVariableStore(& varstore);
      }
    }
    {
#line 189
    CloseStream(& incfile);
#line 193
    DestroyAttribute(nameAttrib);
#line 194
    free((void *)nameAttrib);
    }
#line 195
    if (result == 1) {
#line 195
      tmp___7 = (uint )2;
    } else {
#line 195
      tmp___7 = (uint )-1;
    }
#line 195
    return (tmp___7);
  }
}
}
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 60 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/html.h"
BOOL IsMarkupTag(HTML_MARKUP *htmlMarkup , char const   *tag ) ;
#line 19 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/bool-proc.h"
uint BooleanProcessor(TASK *task , HTML_MARKUP *htmlMarkup , char **newPlaintext ) ;
#line 21 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/bool-proc.c"
static BOOL EvaluateIfTag(TASK *task , HTML_MARKUP *htmlMarkup ) 
{ 
  BOOL condTrue ;
  BOOL notTagFound ;
  HTML_ATTRIBUTE *attrib ;
  char const   *value ;
  uint type ;
  void *tmp ;
  int tmp___1 ;

  {
  {
#line 31
  notTagFound = UnlinkBoolAttributeInMarkup(htmlMarkup, "NOT");
  }
#line 34
  if ((unsigned long )htmlMarkup->attrib == (unsigned long )((void *)0)) {
    {
#line 36
    HtpMsg((uint )2, task->infile, "no conditional to test");
    }
#line 37
    return ((uint )-1);
  }
#line 40
  if ((unsigned long )(htmlMarkup->attrib)->next != (unsigned long )((void *)0)) {
    {
#line 42
    HtpMsg((uint )2, task->infile, "too many items in conditional expression");
    }
#line 44
    return ((uint )-1);
  }
  {
#line 47
  attrib = htmlMarkup->attrib;
#line 50
  type = GetVariableType(task->varstore, (char const   *)attrib->name);
  }
#line 53
  if ((unsigned long )attrib->value == (unsigned long )((void *)0)) {
#line 55
    if (type != 4294967295U) {
#line 55
      condTrue = (BOOL )1;
    } else {
#line 55
      condTrue = (BOOL )0;
    }
  } else
#line 60
  if (type == 1U) {
    {
#line 63
    tmp = GetVariableValue(task->varstore, (char const   *)attrib->name);
#line 63
    value = (char const   *)tmp;
    }
#line 64
    if (value) {
      {
#line 64
      tmp___1 = strcmp(value, (char const   *)attrib->value);
      }
#line 64
      if (tmp___1 == 0) {
#line 64
        condTrue = (BOOL )1;
      } else {
#line 64
        condTrue = (BOOL )0;
      }
    } else {
#line 64
      condTrue = (BOOL )0;
    }
  } else {
#line 70
    condTrue = (BOOL )0;
  }
#line 75
  return ((BOOL )(condTrue != notTagFound));
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/bool-proc.c"
static BOOL DiscardConditionalBlock(TASK *task , BOOL takeElseBlock ) 
{ 
  HTML_MARKUP htmlMarkup ;
  BOOL result ;
  uint embeddedConditionals ;
  uint markupType ;
  char ch ;
  BOOL tmp ;
  BOOL tmp___0 ;
  BOOL tmp___1 ;
  BOOL tmp___2 ;
  BOOL tmp___3 ;
  BOOL tmp___4 ;

  {
#line 87
  embeddedConditionals = (uint )0;
  {
#line 88
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 90
    result = ReadHtmlMarkup(task->infile, (STREAM *)((void *)0), & markupType, & htmlMarkup);
    }
#line 91
    if (result == 4294967295U) {
#line 93
      return ((BOOL )0);
    } else
#line 95
    if (result == 0U) {
      {
#line 98
      HtpMsg((uint )2, task->infile, "Missing </IF> for <IF> in line %d", task->conditionalLine[task->conditionalLevel - 1U]);
      }
#line 101
      return ((BOOL )0);
    }
    {
#line 105
    tmp___4 = IsMarkupTag(& htmlMarkup, "IF");
    }
#line 105
    if (tmp___4) {
#line 107
      embeddedConditionals ++;
    } else {
      {
#line 109
      tmp___3 = IsMarkupTag(& htmlMarkup, "/IF");
      }
#line 109
      if (tmp___3) {
#line 112
        if (embeddedConditionals == 0U) {
          {
#line 114
          DestroyMarkupStruct(& htmlMarkup);
#line 115
          (task->conditionalLevel) --;
          }
#line 116
          goto while_break;
        }
#line 118
        embeddedConditionals --;
      } else
#line 120
      if (embeddedConditionals == 0U) {
#line 120
        if (takeElseBlock) {
          {
#line 123
          tmp___0 = IsMarkupTag(& htmlMarkup, "ELSE");
          }
#line 123
          if (tmp___0) {
#line 123
            goto _L;
          } else {
            {
#line 123
            tmp___1 = IsMarkupTag(& htmlMarkup, "ELSEIF");
            }
#line 123
            if (tmp___1) {
              {
#line 123
              tmp___2 = EvaluateIfTag(task, & htmlMarkup);
              }
#line 123
              if (tmp___2 == 1U) {
                _L: /* CIL Label */ 
                {
#line 127
                DestroyMarkupStruct(& htmlMarkup);
#line 130
                tmp = GetStreamChar(task->infile, & ch);
                }
#line 130
                if (tmp) {
#line 130
                  if ((int )ch != 10) {
                    {
#line 132
                    UnreadStreamChar(task->infile, ch);
                    }
                  }
                }
#line 134
                goto while_break;
              }
            }
          }
        }
      }
    }
    {
#line 139
    DestroyMarkupStruct(& htmlMarkup);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 142
  return ((BOOL )1);
}
}
#line 146 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/bool-proc.c"
uint BooleanProcessor(TASK *task , HTML_MARKUP *htmlMarkup , char **newPlaintext ) 
{ 
  char ch ;
  BOOL tmp ;
  uint tmp___0 ;
  BOOL tmp___1 ;
  BOOL tmp___2 ;
  BOOL tmp___3 ;
  BOOL tmp___4 ;
  BOOL tmp___5 ;
  BOOL tmp___6 ;
  BOOL tmp___7 ;

  {
#line 149
  newPlaintext = newPlaintext;
#line 152
  if (task->conditionalLevel == 0U) {
    {
#line 152
    tmp = IsMarkupTag(htmlMarkup, "IF");
    }
#line 152
    if (! tmp) {
      {
#line 155
      HtpMsg((uint )2, task->infile, "<%s> without matching IF tag", htmlMarkup->tag);
      }
#line 157
      return ((uint )-1);
    }
  }
  {
#line 160
  tmp___7 = IsMarkupTag(htmlMarkup, "IF");
  }
#line 160
  if (tmp___7) {
#line 162
    if (task->conditionalLevel >= 32U) {
      {
#line 164
      HtpMsg((uint )2, task->infile, "Too many nested <IF> tags");
      }
#line 165
      return ((uint )-1);
    }
    {
#line 167
    tmp___0 = task->conditionalLevel;
#line 167
    (task->conditionalLevel) ++;
#line 167
    task->conditionalLine[tmp___0] = (task->infile)->lineNumber;
#line 170
    tmp___3 = EvaluateIfTag(task, htmlMarkup);
    }
#line 170
    if (tmp___3 == 0U) {
      {
#line 177
      tmp___1 = DiscardConditionalBlock(task, (BOOL )1);
      }
#line 177
      if (tmp___1 == 0U) {
#line 179
        return ((uint )-1);
      }
    } else {
      {
#line 185
      tmp___2 = GetStreamChar(task->infile, & ch);
      }
#line 185
      if (tmp___2) {
#line 185
        if ((int )ch != 10) {
          {
#line 187
          UnreadStreamChar(task->infile, ch);
          }
        }
      }
    }
  } else {
    {
#line 191
    tmp___5 = IsMarkupTag(htmlMarkup, "ELSE");
    }
#line 191
    if (tmp___5) {
#line 191
      goto _L;
    } else {
      {
#line 191
      tmp___6 = IsMarkupTag(htmlMarkup, "ELSEIF");
      }
#line 191
      if (tmp___6) {
        _L: /* CIL Label */ 
        {
#line 197
        tmp___4 = DiscardConditionalBlock(task, (BOOL )0);
        }
#line 197
        if (tmp___4 == 0U) {
#line 199
          return ((uint )-1);
        }
      } else {
#line 206
        (task->conditionalLevel) --;
      }
    }
  }
#line 209
  return ((uint )2);
}
}
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 497 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 511
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) getcwd)(char *__buf ,
                                                                               size_t __size ) ;
#line 46 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/streams.h"
BOOL CreateNullWriter(STREAM *stream ) ;
#line 58
unsigned int GetStreamBlock(STREAM *stream , char *buffer , uint size , char *delim ) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/defs.h"
char const   *DEFAULT_RESPONSE_FILE ;
#line 24 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/htp-files.h"
BOOL HtpDefaultFilename(char *filename , uint size ) ;
#line 54
BOOL FullyCheckDependencies(char const   *in , char const   *out ) ;
#line 43 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/option.h"
BOOL InitializeGlobalOption(void) ;
#line 44
void DestroyGlobalOption(void) ;
#line 48
BOOL InitializeLocalOption(void) ;
#line 49
void DestroyLocalOption(void) ;
#line 53
BOOL ParseToken(TASK *task , char const   *string ) ;
#line 23 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/htp.c"
static char globalFilename[256]  ;
#line 24 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/htp.c"
static char projectFilename[256]  ;
#line 30 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/htp.c"
BOOL ProcessTask(TASK *task ) 
{ 
  char *newPlaintext ;
  uint markupResult ;
  HTML_MARKUP htmlMarkup ;
  BOOL result ;
  uint markupType ;
  int tmp ;
  int tmp___0 ;

  {
#line 43
  task->conditionalLevel = (uint )0;
  {
#line 45
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 47
    result = ReadHtmlMarkup(task->infile, task->outfile, & markupType, & htmlMarkup);
    }
#line 49
    if (result == 4294967295U) {
#line 52
      return ((BOOL )0);
    } else
#line 54
    if (result == 0U) {
#line 57
      goto while_break;
    }
    {
#line 60
    newPlaintext = (char *)((void *)0);
#line 61
    markupResult = ExpandAll(task, & htmlMarkup, & newPlaintext, markupType);
#line 64
    DestroyMarkupStruct(& htmlMarkup);
    }
    {
#line 68
    if (markupResult == 0U) {
#line 68
      goto case_0;
    }
#line 78
    if (markupResult == 1U) {
#line 78
      goto case_1;
    }
#line 78
    if (markupResult == 3U) {
#line 78
      goto case_1;
    }
#line 85
    if (markupResult == 2U) {
#line 85
      goto case_2;
    }
#line 91
    if (markupResult == 4294967295U) {
#line 91
      goto case_4294967295;
    }
#line 98
    goto switch_default;
    case_0: /* CIL Label */ 
#line 71
    if (markupType & 2U) {
#line 71
      tmp = (int )htpCloseMarkup;
    } else {
#line 71
      tmp = '>';
    }
#line 71
    if (markupType & 2U) {
#line 71
      tmp___0 = (int )htpOpenMarkup;
    } else {
#line 71
      tmp___0 = '<';
    }
    {
#line 71
    StreamPrintF(task->outfile, "%c%s%c", tmp___0, newPlaintext, tmp);
    }
#line 75
    goto switch_break;
    case_1: /* CIL Label */ 
    case_3: /* CIL Label */ 
    {
#line 81
    PutStreamString(task->outfile, (char const   *)newPlaintext);
    }
#line 83
    goto switch_break;
    case_2: /* CIL Label */ ;
#line 89
    goto switch_break;
    case_4294967295: /* CIL Label */ 
    {
#line 94
    free((void *)newPlaintext);
    }
#line 95
    return ((BOOL )0);
    switch_default: /* CIL Label */ 
    {
#line 100
    free((void *)newPlaintext);
#line 101
    printf((char const   */* __restrict  */)"%s: serious internal error\n", "htp");
#line 102
    exit(1);
    }
    switch_break: /* CIL Label */ ;
    }
#line 107
    if (newPlaintext) {
      {
#line 109
      free((void *)newPlaintext);
#line 110
      newPlaintext = (char *)((void *)0);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 114
  if (task->conditionalLevel > 0U) {
    {
#line 116
    HtpMsg((uint )2, task->infile, "Missing </IF> for <IF> in line %d", task->conditionalLine[task->conditionalLevel - 1U]);
    }
  }
#line 120
  return ((BOOL )1);
}
}
#line 136 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/htp.c"
static VARSTORE fileVarStore  ;
#line 123 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/htp.c"
BOOL ProcessFileByName(VARSTORE *parentVarStore , char const   *in , char const   *out ) 
{ 
  STREAM infile ;
  STREAM outfile ;
  TASK task ;
  BOOL result ;
  char const   *templateFile ;
  BOOL tmp ;
  BOOL tmp___0 ;
  BOOL tmp___1 ;
  void *tmp___2 ;
  BOOL tmp___3 ;
  BOOL tmp___4 ;

  {
#line 143
  result = (BOOL )1;
#line 146
  if ((int )globalFilename[0] != 0) {
    {
#line 148
    result = FullyCheckDependencies((char const   *)(globalFilename), out);
    }
  }
#line 151
  if (result == 1U) {
#line 151
    if ((int )projectFilename[0] != 0) {
      {
#line 153
      result = FullyCheckDependencies((char const   *)(projectFilename), out);
      }
    }
  }
#line 158
  if (result == 1U) {
    {
#line 160
    result = FullyCheckDependencies(in, out);
    }
  }
#line 164
  if (result == 1U) {
    {
#line 168
    printf((char const   */* __restrict  */)"%s: File \"%s\" is completely up to date.\n",
           "htp", out);
    }
#line 170
    return ((BOOL )1);
  }
  {
#line 176
  InitializeVariableStore(& fileVarStore);
#line 177
  PushVariableStoreContext(parentVarStore, & fileVarStore);
#line 178
  fileVarStore.isGlobal = (BOOL )1;
#line 181
  tmp = CreateFileWriter(& outfile, out, (BOOL )0);
  }
#line 181
  if (tmp == 0U) {
    {
#line 183
    printf((char const   */* __restrict  */)"%s: unable to open file \"%s\" for writing\n",
           "htp", out);
#line 184
    DestroyVariableStore(& fileVarStore);
    }
#line 185
    return ((BOOL )0);
  }
  {
#line 188
  tmp___0 = CreateFileReader(& infile, in);
  }
#line 188
  if (tmp___0 == 0U) {
    {
#line 190
    printf((char const   */* __restrict  */)"%s: unable to open file \"%s\" for reading\n",
           "htp", in);
#line 192
    CloseStream(& outfile);
#line 193
    DestroyVariableStore(& fileVarStore);
    }
#line 194
    return ((BOOL )0);
  }
  {
#line 197
  tmp___1 = InitializeLocalOption();
  }
#line 197
  if (tmp___1 == 0U) {
    {
#line 199
    printf((char const   */* __restrict  */)"%s: unable to initialize local option store\n",
           "htp");
#line 201
    CloseStream(& infile);
#line 202
    CloseStream(& outfile);
#line 203
    DestroyVariableStore(& fileVarStore);
    }
#line 204
    return ((BOOL )0);
  }
  {
#line 208
  task.infile = & infile;
#line 209
  task.outfile = & outfile;
#line 210
  task.varstore = & fileVarStore;
#line 211
  task.sourceFilename = in;
#line 212
  StoreVariable(& fileVarStore, "_htpfile_in", (void *)in, (uint )1, (uint )0, (void *)0,
                (void (*)(char const   *name , void *value , uint type , uint flag ,
                          void *param ))((void *)0));
#line 214
  StoreVariable(& fileVarStore, "_htpfile_out", (void *)out, (uint )1, (uint )0, (void *)0,
                (void (*)(char const   *name , void *value , uint type , uint flag ,
                          void *param ))((void *)0));
#line 216
  printf((char const   */* __restrict  */)"%s: Processing file \"%s\" to output file \"%s\" ...\n",
         "htp", in, out);
#line 219
  result = ProcessTask(& task);
#line 222
  CloseStream(& infile);
  }
#line 225
  if (result == 1U) {
    {
#line 225
    tmp___4 = VariableExists(& fileVarStore, VAR_TEMPLATE_NAME);
    }
#line 225
    if (tmp___4) {
      {
#line 228
      tmp___2 = GetVariableValue(& fileVarStore, VAR_TEMPLATE_NAME);
#line 228
      templateFile = (char const   *)tmp___2;
#line 230
      tmp___3 = CreateFileReader(& infile, templateFile);
      }
#line 230
      if (tmp___3 == 0U) {
        {
#line 232
        printf((char const   */* __restrict  */)"%s: unable to open template file \"%s\"\n",
               "htp", templateFile);
#line 235
        CloseStream(& outfile);
#line 236
        DestroyLocalOption();
#line 237
        DestroyVariableStore(& fileVarStore);
        }
#line 239
        return ((BOOL )0);
      }
      {
#line 242
      task.infile = & infile;
#line 243
      task.outfile = & outfile;
#line 244
      task.varstore = & fileVarStore;
#line 245
      task.sourceFilename = in;
#line 247
      printf((char const   */* __restrict  */)"%s: Processing template file \"%s\" ...\n",
             "htp", templateFile);
#line 250
      result = ProcessTask(& task);
#line 251
      CloseStream(& infile);
      }
    }
  }
#line 254
  if (result == 1U) {
    {
#line 256
    printf((char const   */* __restrict  */)"%s: final output file \"%s\" successfully created\n\n",
           "htp", outfile.name);
    }
  } else {
    {
#line 261
    printf((char const   */* __restrict  */)"\n%s: error encountered, file \"%s\" not completed\n\n",
           "htp", outfile.name);
    }
  }
  {
#line 265
  CloseStream(& outfile);
  }
#line 268
  if (result != 1U) {
#line 270
    if ((*(currentOptions + 3) == 1U) == 0) {
      {
#line 273
      remove(out);
      }
    }
  }
  {
#line 278
  DestroyLocalOption();
#line 281
  DestroyVariableStore(& fileVarStore);
  }
#line 283
  return (result);
}
}
#line 286 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/htp.c"
BOOL ProcessDefaultFile(VARSTORE *varstore , char const   *file ) 
{ 
  TASK defTask ;
  STREAM infile ;
  STREAM outfile ;
  BOOL result ;
  BOOL tmp ;

  {
  {
#line 293
  tmp = CreateFileReader(& infile, file);
  }
#line 293
  if (tmp == 0U) {
    {
#line 295
    printf((char const   */* __restrict  */)"%s: unable to open default project file \"%s\"\n",
           "htp", file);
    }
#line 297
    return ((BOOL )0);
  }
  {
#line 301
  CreateNullWriter(& outfile);
#line 305
  defTask.infile = & infile;
#line 306
  defTask.outfile = & outfile;
#line 307
  defTask.varstore = varstore;
#line 308
  defTask.sourceFilename = file;
#line 310
  printf((char const   */* __restrict  */)"%s: Processing default file \"%s\" ... \n",
         "htp", file);
#line 313
  result = ProcessTask(& defTask);
#line 315
  CloseStream(& infile);
#line 316
  CloseStream(& outfile);
  }
#line 318
  return (result);
}
}
#line 321 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/htp.c"
BOOL ProcessResponseFile(VARSTORE *parentVarStore , char const   *resp ) 
{ 
  char textline[128] ;
  char defResp[256] ;
  char newDirectory[256] ;
  char oldDirectory[256] ;
  STREAM respfile ;
  int result ;
  char *in ;
  char *out ;
  char *ptr ;
  BOOL useNewDir ;
  BOOL respFileOpen ;
  FIND_TOKEN findToken ;
  uint numread ;
  char nl_bitmap[3] ;
  VARSTORE projectVarStore ;
  size_t tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  BOOL tmp___2 ;
  char tempFilename[256] ;
  BOOL tmp___3 ;
  BOOL tmp___4 ;

  {
  {
#line 341
  nl_bitmap[0] = (char )'\n';
#line 342
  nl_bitmap[1] = (char )'\n';
#line 343
  nl_bitmap[2] = (char )'\n';
#line 344
  useNewDir = (BOOL )0;
#line 346
  tmp___0 = strlen(resp);
#line 346
  tmp___1 = strchr("/\\", (int )*(resp + (tmp___0 - 1UL)));
  }
#line 346
  if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
    {
#line 355
    strcpy((char */* __restrict  */)(newDirectory), (char const   */* __restrict  */)resp);
#line 356
    tmp = strlen((char const   *)(newDirectory));
#line 356
    newDirectory[tmp - 1UL] = (char)0;
#line 359
    strcpy((char */* __restrict  */)(defResp), (char const   */* __restrict  */)(newDirectory));
#line 360
    strcat((char */* __restrict  */)(defResp), (char const   */* __restrict  */)"/");
#line 361
    strcat((char */* __restrict  */)(defResp), (char const   */* __restrict  */)DEFAULT_RESPONSE_FILE);
#line 363
    useNewDir = (BOOL )1;
#line 365
    respFileOpen = CreateFileReader(& respfile, (char const   *)(defResp));
    }
  } else {
    {
#line 369
    respFileOpen = CreateFileReader(& respfile, resp);
    }
  }
#line 372
  if (respFileOpen == 0U) {
    {
#line 374
    printf((char const   */* __restrict  */)"%s: unable to open \"%s\" as a response file\n",
           "htp", resp);
    }
#line 376
    return ((BOOL )0);
  }
  {
#line 379
  printf((char const   */* __restrict  */)"%s: Processing response file \"%s\" ...\n",
         "htp", respfile.name);
  }
#line 384
  if (useNewDir) {
    {
#line 386
    getcwd(oldDirectory, sizeof(oldDirectory));
#line 387
    chdir((char const   *)(newDirectory));
    }
  }
  {
#line 391
  InitializeVariableStore(& projectVarStore);
#line 392
  PushVariableStoreContext(parentVarStore, & projectVarStore);
#line 393
  projectVarStore.isGlobal = (BOOL )1;
#line 396
  tmp___2 = FileExists("htp.def");
  }
#line 396
  if (tmp___2) {
    {
#line 398
    StringCopy(projectFilename, "htp.def", (uint )256);
#line 399
    ProcessDefaultFile(& projectVarStore, (char const   *)(projectFilename));
    }
  } else {
#line 403
    projectFilename[0] = (char)0;
  }
#line 406
  result = 1;
  {
#line 407
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 409
    numread = GetStreamBlock(& respfile, textline, (uint )sizeof(textline), (char *)(nl_bitmap));
    }
#line 411
    if (numread == 0U) {
#line 414
      goto while_break;
    }
#line 417
    if ((int )textline[numread - 1U] == 10) {
#line 418
      textline[numread - 1U] = (char)0;
    }
    {
#line 420
    in = (char *)((void *)0);
#line 421
    out = (char *)((void *)0);
#line 425
    ptr = StringFirstToken(& findToken, textline, " \t");
    }
    {
#line 426
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 426
      if (! ((unsigned long )ptr != (unsigned long )((void *)0))) {
#line 426
        goto while_break___0;
      }
#line 429
      if ((int )*ptr == 32) {
        {
#line 431
        ptr = StringNextToken(& findToken);
        }
#line 432
        goto while_continue___0;
      } else
#line 429
      if ((int )*ptr == 9) {
        {
#line 431
        ptr = StringNextToken(& findToken);
        }
#line 432
        goto while_continue___0;
      } else
#line 429
      if (! *ptr) {
        {
#line 431
        ptr = StringNextToken(& findToken);
        }
#line 432
        goto while_continue___0;
      }
#line 437
      if ((int )*ptr == 45) {
        {
#line 439
        ParseToken((TASK *)((void *)0), (char const   *)(ptr + 1));
        }
      } else
#line 437
      if ((int )*ptr == 47) {
        {
#line 439
        ParseToken((TASK *)((void *)0), (char const   *)(ptr + 1));
        }
      } else
#line 441
      if ((int )*ptr == 59) {
#line 444
        goto while_break___0;
      } else
#line 446
      if ((unsigned long )in == (unsigned long )((void *)0)) {
#line 448
        in = ptr;
      } else
#line 450
      if ((unsigned long )out == (unsigned long )((void *)0)) {
#line 452
        out = ptr;
      } else {
        {
#line 457
        HtpMsg((uint )1, & respfile, "extra option \"%s\" specified in response file, ignoring",
               ptr);
        }
      }
      {
#line 462
      ptr = StringNextToken(& findToken);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 465
    if ((unsigned long )in == (unsigned long )((void *)0)) {
#line 466
      goto __Cont;
    }
#line 468
    if ((unsigned long )out == (unsigned long )((void *)0)) {
      {
#line 471
      StringCopy(tempFilename, (char const   *)(projectFilename), (uint )256);
#line 476
      PopVariableStoreContext(& projectVarStore);
#line 477
      tmp___3 = ProcessResponseFile(parentVarStore, (char const   *)in);
#line 477
      result = (int )tmp___3;
#line 478
      PushVariableStoreContext(parentVarStore, & projectVarStore);
#line 481
      StringCopy(projectFilename, (char const   *)(tempFilename), (uint )256);
      }
    } else
#line 483
    if ((unsigned long )in != (unsigned long )((void *)0)) {
#line 483
      if ((unsigned long )out != (unsigned long )((void *)0)) {
        {
#line 486
        tmp___4 = ProcessFileByName(& projectVarStore, (char const   *)in, (char const   *)out);
#line 486
        result = (int )tmp___4;
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 407
    if (! (result == 1)) {
#line 407
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 491
  DestroyVariableStore(& projectVarStore);
#line 493
  CloseStream(& respfile);
  }
#line 496
  if (useNewDir) {
    {
#line 498
    chdir((char const   *)(oldDirectory));
    }
  }
#line 501
  return ((BOOL )result);
}
}
#line 504 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/htp.c"
int main(int argc , char **argv ) 
{ 
  int result ;
  uint ctr ;
  char *in ;
  char *out ;
  char *resp ;
  VARSTORE globalVarStore ;
  BOOL tmp ;
  BOOL tmp___0 ;
  BOOL tmp___1 ;
  BOOL tmp___2 ;
  BOOL tmp___3 ;
  BOOL tmp___4 ;
  int tmp___5 ;

  {
  {
#line 519
  DisplayHeader();
  }
#line 521
  if (argc == 1) {
    {
#line 523
    usage();
    }
#line 524
    return (1);
  }
  {
#line 540
  tmp = InitializeGlobalOption();
  }
#line 540
  if (tmp == 0U) {
    {
#line 542
    printf((char const   */* __restrict  */)"%s: fatal error, unable to initialize internal options\n",
           "htp");
    }
#line 544
    return (1);
  }
#line 547
  in = (char *)((void *)0);
#line 548
  out = (char *)((void *)0);
#line 549
  resp = (char *)((void *)0);
#line 552
  ctr = (uint )1;
  {
#line 552
  while (1) {
    while_continue: /* CIL Label */ ;
#line 552
    if (! (ctr < (uint )argc)) {
#line 552
      goto while_break;
    }
#line 554
    if ((int )*(*(argv + ctr)) == 45) {
      {
#line 557
      ParseToken((TASK *)((void *)0), (char const   *)(*(argv + ctr) + 1));
      }
    } else
#line 554
    if ((int )*(*(argv + ctr)) == 47) {
      {
#line 557
      ParseToken((TASK *)((void *)0), (char const   *)(*(argv + ctr) + 1));
      }
    } else
#line 559
    if ((int )*(*(argv + ctr)) == 64) {
#line 562
      resp = *(argv + ctr) + 1;
#line 563
      if ((int )*resp == 0) {
#line 565
        resp = (char *)DEFAULT_RESPONSE_FILE;
      }
    } else
#line 568
    if ((unsigned long )in == (unsigned long )((void *)0)) {
#line 571
      in = *(argv + ctr);
    } else
#line 573
    if ((unsigned long )out == (unsigned long )((void *)0)) {
#line 576
      out = *(argv + ctr);
    } else {
      {
#line 580
      printf((char const   */* __restrict  */)"%s: unknown argument \"%s\" specified\n",
             "htp", *(argv + ctr));
      }
#line 582
      return (1);
    }
#line 552
    ctr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 586
  if ((*(currentOptions + 5) == 1U) == 1) {
    {
#line 588
    usage();
    }
#line 589
    return (1);
  }
#line 592
  if ((unsigned long )in == (unsigned long )((void *)0)) {
#line 592
    goto _L;
  } else
#line 592
  if ((unsigned long )out == (unsigned long )((void *)0)) {
    _L: /* CIL Label */ 
#line 592
    if ((unsigned long )resp == (unsigned long )((void *)0)) {
      {
#line 594
      usage();
      }
#line 595
      return (1);
    }
  }
  {
#line 599
  tmp___0 = InitializeVariableStore(& globalVarStore);
  }
#line 599
  if (tmp___0 != 1U) {
    {
#line 601
    printf((char const   */* __restrict  */)"%s: unable to initialize global variable store (out of memory?)\n",
           "htp");
    }
#line 603
    return (1);
  }
  {
#line 605
  globalVarStore.isGlobal = (BOOL )1;
#line 608
  StoreVariable(& globalVarStore, "_htp_version", (void *)"1.16", (uint )1, (uint )0,
                (void *)0, (void (*)(char const   *name , void *value , uint type ,
                                     uint flag , void *param ))((void *)0));
#line 614
  tmp___1 = HtpDefaultFilename(globalFilename, (uint )256);
  }
#line 614
  if (tmp___1) {
    {
#line 616
    ProcessDefaultFile(& globalVarStore, (char const   *)(globalFilename));
    }
  } else {
#line 620
    globalFilename[0] = (char)0;
  }
#line 625
  if ((unsigned long )resp != (unsigned long )((void *)0)) {
    {
#line 627
    tmp___2 = ProcessResponseFile(& globalVarStore, (char const   *)resp);
#line 627
    result = (int )tmp___2;
    }
  } else {
    {
#line 632
    tmp___3 = FileExists("htp.def");
    }
#line 632
    if (tmp___3) {
      {
#line 634
      StringCopy(projectFilename, "htp.def", (uint )256);
#line 635
      ProcessDefaultFile(& globalVarStore, (char const   *)(projectFilename));
      }
    } else {
#line 639
      projectFilename[0] = (char)0;
    }
    {
#line 641
    tmp___4 = ProcessFileByName(& globalVarStore, (char const   *)in, (char const   *)out);
#line 641
    result = (int )tmp___4;
    }
  }
  {
#line 649
  DestroyVariableStore(& globalVarStore);
#line 652
  DestroyGlobalOption();
  }
#line 660
  if (result == 1) {
#line 660
    tmp___5 = 0;
  } else {
#line 660
    tmp___5 = 1;
  }
#line 660
  return (tmp___5);
}
}
#line 19 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/defs.c"
char const   *DEFAULT_RESPONSE_FILE  =    "htp.rsp";
#line 26 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/defs.c"
char const   *VAR_TEMPLATE_NAME  =    "__!TEMPLATE FILE~";
#line 45 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/defs.c"
char htpOpenMarkup  =    (char )'<';
#line 46 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/defs.c"
char htpCloseMarkup  =    (char )'>';
#line 51 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/defs.c"
char searchPath[1024]  = {      (char)0};
#line 15 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/gif.c"
BOOL GifFormatFound(FILE *file ) 
{ 
  BYTE header[8] ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 20
  tmp = fseek(file, 0L, 0);
  }
#line 20
  if (tmp != 0) {
#line 23
    return ((BOOL )0);
  }
  {
#line 27
  tmp___0 = fread((void */* __restrict  */)(header), (size_t )1, (size_t )6, (FILE */* __restrict  */)file);
  }
#line 27
  if (tmp___0 != 6UL) {
#line 30
    return ((BOOL )0);
  }
  {
#line 34
  tmp___1 = memcmp((void const   *)(header), (void const   *)"GIF87a", (size_t )6);
  }
#line 34
  if (tmp___1 == 0) {
#line 36
    return ((BOOL )1);
  } else {
    {
#line 34
    tmp___2 = memcmp((void const   *)(header), (void const   *)"GIF89a", (size_t )6);
    }
#line 34
    if (tmp___2 == 0) {
#line 36
      return ((BOOL )1);
    }
  }
#line 40
  return ((BOOL )0);
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/gif.c"
BOOL GifReadDimensions(FILE *file , DWORD *height , DWORD *width ) 
{ 
  BYTE buff[4] ;
  int tmp ;
  size_t tmp___0 ;

  {
  {
#line 48
  tmp = fseek(file, 6L, 0);
  }
#line 48
  if (tmp != 0) {
#line 51
    return ((BOOL )0);
  }
  {
#line 55
  tmp___0 = fread((void */* __restrict  */)(buff), (size_t )1, (size_t )4, (FILE */* __restrict  */)file);
  }
#line 55
  if (tmp___0 != 4UL) {
#line 58
    return ((BOOL )0);
  }
#line 63
  *width = (DWORD )(((int )((WORD )buff[1]) << 8) | (int )((WORD )buff[0]));
#line 64
  *height = (DWORD )(((int )((WORD )buff[3]) << 8) | (int )((WORD )buff[2]));
#line 65
  return ((BOOL )1);
}
}
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 569 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) stpcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 49 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/html.h"
BOOL ChangeAttributeName(HTML_ATTRIBUTE *htmlAttribute , char *name ) ;
#line 50
BOOL ChangeAttributeValue(HTML_ATTRIBUTE *htmlAttribute , char *value , int quotes ) ;
#line 63
BOOL ChangeMarkupTag(HTML_MARKUP *htmlMarkup , char *tag ) ;
#line 19 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/macro.h"
BOOL ExpandMacrosInString(TASK *task , char const   *text , char **newText , int *quotes ,
                          unsigned int *changed ) ;
#line 23
BOOL ExpandMacros(TASK *task , HTML_MARKUP *htmlMarkup ) ;
#line 27
uint ExpandMetatag(TASK *task , HTML_MARKUP *htmlMarkup ) ;
#line 54 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/option.h"
uint OptionProcessor(TASK *task , HTML_MARKUP *htmlMarkup , char **newPlaintext ) ;
#line 19 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/image-proc.h"
uint ImageProcessor(TASK *task , HTML_MARKUP *htmlMarkup , char **newPlaintext ) ;
#line 21
uint AltTextProcessor(TASK *task , HTML_MARKUP *htmlMarkup , char **newPlaintext ) ;
#line 23
uint ImageUrlProcessor(TASK *task , HTML_MARKUP *htmlMarkup , char **newPlaintext ) ;
#line 19 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/misc-proc.h"
uint HeadProcessor(TASK *task , HTML_MARKUP *htmlMarkup , char **newPlaintext ) ;
#line 20
uint QuoteProcessor(TASK *task , HTML_MARKUP *htmlMarkup , char **newPlaintext ) ;
#line 22
uint HtpCommentProcessor(TASK *task , HTML_MARKUP *htmlMarkup , char **newPlaintext ) ;
#line 24
uint ConditionalWarning(TASK *task , HTML_MARKUP *htmlMarkup , char **newPlaintext ) ;
#line 26
uint PreProcessor(TASK *task , HTML_MARKUP *htmlMarkup , char **newPlaintext ) ;
#line 19 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/while-proc.h"
uint WhileProcessor(TASK *task , HTML_MARKUP *htmlMarkup , char **newPlaintext ) ;
#line 33 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/macro.c"
static MARKUP_PROCESSORS markupProcessor[26]  = 
#line 33 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/macro.c"
  {      {"IMG", (uint )1, & ImageProcessor}, 
        {"OPT", (uint )2, & OptionProcessor}, 
        {"FILE", (uint )2, & FileProcessor}, 
        {"INC", (uint )2, & IncProcessor}, 
        {"SET", (uint )2, & SetProcessor}, 
        {"BLOCK", (uint )2, & BlockProcessor}, 
        {"BLOCKDEF", (uint )2, & BlockProcessor}, 
        {"USE", (uint )2, & UseProcessor}, 
        {"IF", (uint )2, & BooleanProcessor}, 
        {"/IF", (uint )2, & BooleanProcessor}, 
        {"IFNOT", (uint )2, & ConditionalWarning}, 
        {"ELSE", (uint )2, & BooleanProcessor}, 
        {"ELSEIF", (uint )2, & BooleanProcessor}, 
        {"/HEAD", (uint )1, & HeadProcessor}, 
        {"UNSET", (uint )2, & UnsetProcessor}, 
        {"PRE", (uint )1, & PreProcessor}, 
        {"/PRE", (uint )1, & PreProcessor}, 
        {"ALTTEXT", (uint )2, & AltTextProcessor}, 
        {"DEF", (uint )2, & BlockProcessor}, 
        {"OUTPUT", (uint )2, & OutputProcessor}, 
        {"UNDEF", (uint )2, & UndefProcessor}, 
        {"WHILE", (uint )2, & WhileProcessor}, 
        {"/WHILE", (uint )2, & WhileProcessor}, 
        {"!---", (uint )2, & HtpCommentProcessor}, 
        {"QUOTE", (uint )2, & QuoteProcessor}, 
        {"IMAGEURL", (uint )2, & ImageUrlProcessor}};
#line 67 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/macro.c"
static BOOL FindMatchingBrace(TASK *task , char const   **text ) 
{ 
  char const   *textPtr ;
  int braceLevel ;

  {
#line 71
  textPtr = *text;
#line 76
  textPtr ++;
#line 77
  braceLevel = 0;
  {
#line 78
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 80
    if ((int const   )*textPtr == 0) {
#line 80
      goto case_0;
    }
#line 84
    if ((int const   )*textPtr == 125) {
#line 84
      goto case_125;
    }
#line 92
    if ((int const   )*textPtr == 123) {
#line 92
      goto case_123;
    }
#line 79
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 81
    HtpMsg((uint )2, task->infile, "ending brace not found in macro name");
    }
#line 82
    return ((BOOL )0);
    case_125: /* CIL Label */ 
#line 85
    if (! braceLevel) {
#line 86
      *text = textPtr + 1;
#line 87
      return ((BOOL )1);
    }
#line 89
    braceLevel --;
#line 90
    goto switch_break;
    case_123: /* CIL Label */ 
#line 93
    braceLevel ++;
#line 94
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 97
    textPtr ++;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 101 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/macro.c"
BOOL ExpandMacrosInString(TASK *task , char const   *text , char **newText , int *quotes ,
                          unsigned int *changed ) 
{ 
  char const   *expansion ;
  char *macro ;
  char *newMacro ;
  char const   *textPtr ;
  uint expansionLength ;
  uint skipped ;
  uint textLength ;
  int singletonMacro ;
  int dummy ;
  BOOL macroChanged ;
  BOOL destAlloced ;
  char *destText ;
  uint destTextSize ;
  uint copiedSoFar ;
  size_t tmp ;
  int len ;
  BOOL tmp___0 ;
  unsigned short const   **tmp___1 ;
  int len___0 ;
  int tmp___2 ;
  unsigned short const   **tmp___3 ;
  uint type ;
  BOOL tmp___4 ;
  BOOL tmp___5 ;
  STREAM *blockFile ;
  void *tmp___6 ;
  void *tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;
  void *tmp___10 ;
  char *tmp___11 ;

  {
  {
#line 122
  tmp = strlen(text);
#line 122
  textLength = (uint )tmp;
#line 123
  destText = (char *)text;
#line 124
  destTextSize = textLength + 1U;
#line 125
  destAlloced = (BOOL )0;
#line 127
  *changed = 0U;
#line 128
  *newText = destText;
#line 132
  singletonMacro = 1;
  }
  {
#line 135
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 135
    tmp___11 = strchr(text, '$');
#line 135
    textPtr = (char const   *)tmp___11;
    }
#line 135
    if (! ((unsigned long )textPtr != (unsigned long )((void *)0))) {
#line 135
      goto while_break;
    }
#line 138
    if ((unsigned long )textPtr > (unsigned long )text) {
#line 139
      len = (int )(textPtr - text);
#line 140
      if (destAlloced) {
        {
#line 141
        memcpy((void */* __restrict  */)destText, (void const   */* __restrict  */)text,
               (size_t )len);
        }
      }
#line 143
      singletonMacro = 0;
#line 144
      text += len;
#line 145
      textLength -= (uint )len;
#line 146
      destText += len;
    }
#line 150
    text ++;
#line 151
    textLength --;
#line 157
    if ((int const   )*text == 123) {
      {
#line 159
      textPtr = text;
#line 160
      tmp___0 = FindMatchingBrace(task, & textPtr);
      }
#line 160
      if (! tmp___0) {
#line 161
        if (destAlloced) {
          {
#line 162
          free((void *)*newText);
          }
        }
#line 164
        *newText = (char *)((void *)0);
#line 166
        return ((BOOL )0);
      }
      {
#line 168
      macro = DuplicateSubString(text + 1, (int )((textPtr - text) - 2L));
      }
    } else {
      {
#line 170
      tmp___3 = __ctype_b_loc();
      }
#line 170
      if ((int const   )*(*tmp___3 + (int )*text) & 8) {
#line 170
        goto _L;
      } else
#line 170
      if ((int const   )*text == 95) {
#line 170
        goto _L;
      } else
#line 170
      if ((int const   )*text == 45) {
        _L: /* CIL Label */ 
#line 175
        textPtr = text + 1;
        {
#line 176
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 176
          tmp___1 = __ctype_b_loc();
          }
#line 176
          if (! ((int const   )*(*tmp___1 + (int )*textPtr) & 8)) {
#line 176
            if (! ((int const   )*textPtr == 95)) {
#line 176
              if (! ((int const   )*textPtr == 45)) {
#line 176
                goto while_break___0;
              }
            }
          }
#line 177
          textPtr ++;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 178
        macro = DuplicateSubString(text, (int )(textPtr - text));
        }
      } else {
#line 184
        if ((int const   )*text == 0) {
#line 184
          tmp___2 = 0;
        } else {
#line 184
          tmp___2 = 1;
        }
        {
#line 184
        len___0 = tmp___2;
#line 185
        textPtr = text + len___0;
#line 186
        macro = DuplicateSubString(text, len___0);
        }
      }
    }
    {
#line 190
    skipped = (uint )(textPtr - text);
#line 191
    text = textPtr;
#line 192
    textLength -= skipped;
#line 194
    tmp___9 = strcmp((char const   *)macro, "$");
    }
#line 194
    if (tmp___9 == 0) {
#line 197
      expansion = "$";
#line 198
      expansionLength = (uint )1;
    } else {
      {
#line 205
      tmp___4 = ExpandMacrosInString(task, (char const   *)macro, & newMacro, & dummy,
                                     & macroChanged);
      }
#line 205
      if (! tmp___4) {
        {
#line 207
        free((void *)macro);
        }
#line 208
        if (destAlloced) {
          {
#line 209
          free((void *)*newText);
          }
        }
#line 211
        *newText = (char *)((void *)0);
#line 212
        return ((BOOL )0);
      }
#line 215
      if (macroChanged) {
        {
#line 216
        free((void *)macro);
#line 217
        macro = newMacro;
        }
      }
      {
#line 221
      tmp___5 = VariableExists(task->varstore, (char const   *)macro);
      }
#line 221
      if (tmp___5 != 1U) {
        {
#line 223
        HtpMsg((uint )2, task->infile, "unrecognized macro name \"%s\"", macro);
#line 225
        free((void *)macro);
        }
#line 226
        if (destAlloced) {
          {
#line 227
          free((void *)*newText);
          }
        }
#line 229
        *newText = (char *)((void *)0);
#line 231
        return ((BOOL )0);
      }
      {
#line 234
      type = GetVariableType(task->varstore, (char const   *)macro);
      }
#line 236
      if (type == 2U) {
        {
#line 238
        tmp___6 = GetVariableValue(task->varstore, (char const   *)macro);
#line 238
        blockFile = (STREAM *)tmp___6;
#line 242
        expansion = (char const   *)blockFile->u.buffer.buffer;
#line 243
        expansionLength = (uint )blockFile->u.buffer.offset;
        }
      } else
#line 245
      if (type == 1U) {
        {
#line 248
        tmp___7 = GetVariableValue(task->varstore, (char const   *)macro);
#line 248
        expansion = (char const   *)tmp___7;
        }
#line 249
        if ((unsigned long )expansion == (unsigned long )((void *)0)) {
#line 250
          expansion = "";
        }
        {
#line 251
        tmp___8 = strlen(expansion);
#line 251
        expansionLength = (uint )tmp___8;
        }
      } else {
#line 255
        if (destAlloced) {
          {
#line 256
          free((void *)*newText);
          }
        }
        {
#line 258
        *newText = (char *)((void *)0);
#line 260
        HtpMsg((uint )2, task->infile, "macro \"%s\" is a meta-tag", macro);
#line 262
        free((void *)macro);
        }
#line 263
        return ((BOOL )0);
      }
      {
#line 266
      HtpMsg((uint )0, task->infile, "expanding macro \"%s\" to \"%s\"", macro, expansion);
      }
    }
    {
#line 269
    free((void *)macro);
#line 271
    destTextSize += (expansionLength - skipped) - 1U;
    }
#line 273
    if (expansionLength > skipped) {
#line 273
      goto _L___0;
    } else
#line 273
    if (! destAlloced) {
      _L___0: /* CIL Label */ 
      {
#line 274
      copiedSoFar = (uint )(destText - *newText);
#line 275
      tmp___10 = malloc((size_t )destTextSize);
#line 275
      destText = (char *)tmp___10;
      }
#line 276
      if ((unsigned long )destText == (unsigned long )((void *)0)) {
#line 277
        if (destAlloced) {
          {
#line 278
          free((void *)*newText);
          }
        }
        {
#line 280
        *newText = (char *)((void *)0);
#line 282
        HtpMsg((uint )2, task->infile, "Out of memory");
        }
#line 283
        return ((BOOL )0);
      }
      {
#line 286
      memcpy((void */* __restrict  */)destText, (void const   */* __restrict  */)*newText,
             (size_t )copiedSoFar);
      }
#line 287
      if (destAlloced) {
        {
#line 288
        free((void *)*newText);
        }
      }
#line 291
      *newText = destText;
#line 292
      destText += copiedSoFar;
#line 293
      destAlloced = (BOOL )1;
    }
    {
#line 297
    memcpy((void */* __restrict  */)destText, (void const   */* __restrict  */)expansion,
           (size_t )expansionLength);
#line 298
    destText += expansionLength;
#line 301
    *changed = 1U;
    }
#line 303
    if (singletonMacro) {
#line 303
      if (! textLength) {
#line 306
        *quotes = 1;
#line 307
        *destText = (char)0;
#line 308
        return ((BOOL )1);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 314
  if (destAlloced) {
    {
#line 315
    memcpy((void */* __restrict  */)destText, (void const   */* __restrict  */)text,
           (size_t )textLength);
#line 316
    destText += textLength;
#line 317
    *destText = (char)0;
    }
  }
#line 319
  return ((BOOL )1);
}
}
#line 322 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/macro.c"
BOOL ExpandMacros(TASK *task , HTML_MARKUP *htmlMarkup ) 
{ 
  HTML_ATTRIBUTE *attrib ;
  char *newName ;
  char *newValue ;
  char *newTag ;
  int quotes ;
  BOOL changed ;
  BOOL tmp ;
  int tmp___0 ;
  int tmp___1 ;
  BOOL tmp___2 ;
  BOOL tmp___3 ;

  {
#line 333
  if ((unsigned long )htmlMarkup->tag != (unsigned long )((void *)0)) {
    {
#line 335
    tmp = ExpandMacrosInString(task, (char const   *)htmlMarkup->tag, & newTag, & quotes,
                               & changed);
    }
#line 335
    if (tmp != 1U) {
#line 338
      return ((BOOL )0);
    }
#line 341
    if (changed) {
      {
#line 343
      ChangeMarkupTag(htmlMarkup, newTag);
      }
    }
  }
  {
#line 347
  tmp___0 = strcasecmp((char const   *)htmlMarkup->tag, "WHILE");
  }
#line 347
  if (tmp___0 == 0) {
#line 349
    return ((BOOL )1);
  } else {
    {
#line 347
    tmp___1 = strcasecmp((char const   *)htmlMarkup->tag, "!---");
    }
#line 347
    if (tmp___1 == 0) {
#line 349
      return ((BOOL )1);
    }
  }
#line 353
  attrib = htmlMarkup->attrib;
  {
#line 354
  while (1) {
    while_continue: /* CIL Label */ ;
#line 354
    if (! ((unsigned long )attrib != (unsigned long )((void *)0))) {
#line 354
      goto while_break;
    }
#line 356
    if ((unsigned long )attrib->name != (unsigned long )((void *)0)) {
      {
#line 358
      tmp___2 = ExpandMacrosInString(task, (char const   *)attrib->name, & newName,
                                     & quotes, & changed);
      }
#line 358
      if (! tmp___2) {
#line 361
        return ((BOOL )0);
      }
#line 364
      if (changed) {
        {
#line 366
        ChangeAttributeName(attrib, newName);
        }
      }
    }
#line 371
    if ((unsigned long )attrib->value != (unsigned long )((void *)0)) {
      {
#line 373
      quotes = attrib->quotes;
#line 374
      tmp___3 = ExpandMacrosInString(task, (char const   *)attrib->value, & newValue,
                                     & quotes, & changed);
      }
#line 374
      if (! tmp___3) {
#line 377
        return ((BOOL )0);
      }
#line 380
      if (changed) {
        {
#line 382
        ChangeAttributeValue(attrib, newValue, quotes);
        }
      }
    }
#line 385
    attrib = attrib->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 388
  return ((BOOL )1);
}
}
#line 392 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/macro.c"
uint ExpandMetatag(TASK *task , HTML_MARKUP *htmlMarkup ) 
{ 
  char const   *options ;
  char *optionCopy ;
  FIND_TOKEN findToken ;
  char *optionPtr ;
  HTML_ATTRIBUTE *attrib ;
  VARSTORE defVarstore ;
  uint flag ;
  char *value ;
  char const   *defName ;
  STREAM *blockStream ;
  STREAM *defStream ;
  STREAM defFile ;
  TASK newTask ;
  BOOL result ;
  BOOL hasWildcard ;
  uint macroType ;
  BOOL tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  BOOL tmp___2 ;
  char *name ;
  char *tmp___3 ;
  BOOL tmp___4 ;
  int tmp___5 ;
  uint wildcardLength ;
  char *wildcards ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  char *ptr ;
  void *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  BOOL tmp___15 ;
  void *tmp___16 ;
  BOOL tmp___17 ;
  BOOL tmp___18 ;
  char const   *tmp___19 ;
  char const   *tmp___20 ;
  BOOL tmp___21 ;
  char const   *tmp___22 ;

  {
  {
#line 412
  tmp = VariableExists(task->varstore, (char const   *)htmlMarkup->tag);
  }
#line 412
  if (tmp == 0U) {
#line 415
    return ((uint )0);
  }
  {
#line 419
  macroType = GetVariableType(task->varstore, (char const   *)htmlMarkup->tag);
  }
#line 421
  if (macroType != 5U) {
#line 421
    if (macroType != 6U) {
#line 424
      return ((uint )0);
    }
  }
  {
#line 428
  defName = (char const   *)htmlMarkup->tag;
#line 431
  tmp___0 = GetVariableValue(task->varstore, defName);
#line 431
  defStream = (STREAM *)tmp___0;
  }
#line 431
  if ((unsigned long )defStream == (unsigned long )((void *)0)) {
    {
#line 435
    HtpMsg((uint )2, task->infile, "DEF macro \"%s\" was not store properly", defName);
    }
#line 437
    return ((uint )-1);
  }
  {
#line 441
  tmp___1 = GetVariableParam(task->varstore, defName);
#line 441
  options = (char const   *)tmp___1;
#line 444
  InitializeVariableStore(& defVarstore);
  }
#line 447
  if ((unsigned long )options != (unsigned long )((void *)0)) {
    {
#line 449
    optionCopy = DuplicateString(options);
    }
#line 449
    if ((unsigned long )optionCopy == (unsigned long )((void *)0)) {
      {
#line 451
      HtpMsg((uint )2, task->infile, "Unable to duplicate option macro (out of memory?)");
#line 452
      DestroyVariableStore(& defVarstore);
      }
#line 453
      return ((uint )-1);
    }
    {
#line 456
    hasWildcard = (BOOL )0;
#line 459
    optionPtr = StringFirstToken(& findToken, optionCopy, " ");
    }
    {
#line 460
    while (1) {
      while_continue: /* CIL Label */ ;
#line 460
      if (! ((unsigned long )optionPtr != (unsigned long )((void *)0))) {
#line 460
        goto while_break;
      }
#line 463
      if ((int )*optionPtr == 0) {
#line 464
        goto while_continue;
      }
      {
#line 465
      tmp___5 = strcmp((char const   *)optionPtr, "*");
      }
#line 465
      if (tmp___5 == 0) {
#line 467
        hasWildcard = (BOOL )1;
      } else {
        {
#line 469
        attrib = UnlinkAttributeInMarkup(htmlMarkup, (char const   *)optionPtr);
        }
#line 469
        if ((unsigned long )attrib != (unsigned long )((void *)0)) {
#line 476
          flag = (uint )6;
#line 477
          value = attrib->value;
#line 478
          if ((unsigned long )value == (unsigned long )((void *)0)) {
#line 479
            value = (char *)"";
#line 480
            flag &= 4294967293U;
          }
          {
#line 483
          tmp___2 = StoreVariable(& defVarstore, (char const   *)attrib->name, (void *)attrib->value,
                                  (uint )1, flag, (void *)0, (void (*)(char const   *name ,
                                                                       void *value ,
                                                                       uint type ,
                                                                       uint flag ,
                                                                       void *param ))((void *)0));
          }
#line 483
          if (tmp___2 == 0U) {
            {
#line 487
            HtpMsg((uint )2, task->infile, "Unable to store local macro for metatag");
#line 489
            DestroyVariableStore(& defVarstore);
#line 490
            DestroyAttribute(attrib);
#line 491
            free((void *)attrib);
#line 492
            free((void *)optionCopy);
            }
#line 493
            return ((uint )-1);
          }
#line 495
          if (attrib->whitespace) {
            {
#line 496
            free((void *)attrib->whitespace);
            }
          }
          {
#line 497
          free((void *)attrib);
          }
        } else {
          {
#line 501
          tmp___3 = DuplicateString((char const   *)optionPtr);
#line 501
          name = tmp___3;
#line 506
          tmp___4 = StoreVariable(& defVarstore, (char const   *)name, (void *)0,
                                  (uint )-1, (uint )12, (void *)0, (void (*)(char const   *name ,
                                                                             void *value ,
                                                                             uint type ,
                                                                             uint flag ,
                                                                             void *param ))((void *)0));
          }
#line 506
          if (tmp___4 == 0U) {
            {
#line 511
            HtpMsg((uint )2, task->infile, "Unable to store local macro for metatag");
#line 513
            DestroyVariableStore(& defVarstore);
#line 514
            free((void *)name);
#line 515
            free((void *)optionCopy);
            }
#line 516
            return ((uint )-1);
          }
        }
      }
      {
#line 519
      optionPtr = StringNextToken(& findToken);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 521
    free((void *)optionCopy);
    }
#line 523
    if (hasWildcard) {
#line 525
      wildcardLength = (uint )0;
#line 529
      attrib = htmlMarkup->attrib;
      {
#line 530
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 530
        if (! ((unsigned long )attrib != (unsigned long )((void *)0))) {
#line 530
          goto while_break___0;
        }
        {
#line 532
        tmp___6 = strlen((char const   *)attrib->name);
#line 532
        tmp___7 = strlen((char const   *)attrib->value);
#line 532
        wildcardLength = (uint )((size_t )wildcardLength + ((tmp___6 + tmp___7) + 2UL));
        }
#line 534
        if (attrib->quotes) {
#line 535
          wildcardLength += 2U;
        }
#line 536
        attrib = attrib->next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 539
      if (wildcardLength > 0U) {
        {
#line 543
        tmp___8 = malloc((size_t )wildcardLength);
#line 543
        wildcards = (char *)tmp___8;
#line 544
        ptr = wildcards;
        }
        {
#line 545
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 545
          attrib = htmlMarkup->attrib;
#line 545
          if (! ((unsigned long )attrib != (unsigned long )((void *)0))) {
#line 545
            goto while_break___1;
          }
          {
#line 546
          ptr = stpcpy((char */* __restrict  */)ptr, (char const   */* __restrict  */)attrib->name);
#line 547
          tmp___9 = ptr;
#line 547
          ptr ++;
#line 547
          *tmp___9 = (char )'=';
          }
#line 548
          if (attrib->quotes == 1) {
#line 549
            tmp___10 = ptr;
#line 549
            ptr ++;
#line 549
            *tmp___10 = (char )'\"';
          } else
#line 550
          if (attrib->quotes == 2) {
#line 551
            tmp___11 = ptr;
#line 551
            ptr ++;
#line 551
            *tmp___11 = (char )'\'';
          }
          {
#line 552
          ptr = stpcpy((char */* __restrict  */)ptr, (char const   */* __restrict  */)attrib->value);
          }
#line 553
          if (attrib->quotes == 1) {
#line 554
            tmp___12 = ptr;
#line 554
            ptr ++;
#line 554
            *tmp___12 = (char )'\"';
          } else
#line 555
          if (attrib->quotes == 2) {
#line 556
            tmp___13 = ptr;
#line 556
            ptr ++;
#line 556
            *tmp___13 = (char )'\'';
          }
          {
#line 557
          tmp___14 = ptr;
#line 557
          ptr ++;
#line 557
          *tmp___14 = (char )' ';
#line 558
          htmlMarkup->attrib = attrib->next;
#line 559
          DestroyAttribute(attrib);
#line 560
          free((void *)attrib);
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 563
        *(ptr - 1) = (char)0;
#line 564
        flag = (uint )2;
      } else {
#line 566
        wildcards = (char *)"";
#line 567
        flag = (uint )0;
      }
      {
#line 570
      tmp___15 = StoreVariable(& defVarstore, "*", (void *)wildcards, (uint )1, flag,
                               (void *)0, (void (*)(char const   *name , void *value ,
                                                    uint type , uint flag , void *param ))((void *)0));
      }
#line 570
      if (tmp___15 == 0U) {
        {
#line 574
        HtpMsg((uint )2, task->infile, "Unable to store local macro for metatag");
#line 576
        DestroyVariableStore(& defVarstore);
        }
#line 577
        if (flag & 2U) {
          {
#line 578
          free((void *)wildcards);
          }
        }
#line 579
        return ((uint )-1);
      }
    }
  }
#line 586
  if (macroType == 6U) {
    {
#line 588
    tmp___16 = malloc(sizeof(STREAM ));
#line 588
    blockStream = (STREAM *)tmp___16;
#line 589
    tmp___17 = ReadinBlock(task, htmlMarkup, blockStream);
    }
#line 589
    if (! tmp___17) {
      {
#line 591
      DestroyVariableStore(& defVarstore);
      }
#line 592
      return ((uint )-1);
    }
    {
#line 596
    tmp___18 = StoreVariable(& defVarstore, "BLOCK", (void *)blockStream, (uint )2,
                             (uint )0, (void *)0, & BlockDestructor);
    }
#line 596
    if (tmp___18 == 0U) {
      {
#line 600
      HtpMsg((uint )2, task->infile, "unable to store macro information (out of memory?)");
#line 602
      DestroyVariableStore(& defVarstore);
      }
#line 603
      return ((uint )-1);
    }
  }
#line 607
  if ((unsigned long )htmlMarkup->attrib != (unsigned long )((void *)0)) {
#line 608
    if (macroType == 6U) {
#line 608
      tmp___19 = "blockdef";
    } else {
#line 608
      tmp___19 = "def";
    }
    {
#line 608
    HtpMsg((uint )2, task->infile, "%s metatag \"%s\" does not accept a parameter named \"%s\"",
           tmp___19, defName, (htmlMarkup->attrib)->name);
#line 612
    DestroyVariableStore(& defVarstore);
    }
#line 613
    return ((uint )-1);
  }
  {
#line 619
  tmp___21 = CreateBufferReader(& defFile, defStream);
  }
#line 619
  if (tmp___21 == 0U) {
#line 621
    if (macroType == 6U) {
#line 621
      tmp___20 = "blockdef";
    } else {
#line 621
      tmp___20 = "def";
    }
    {
#line 621
    HtpMsg((uint )2, task->infile, "unable to open block for %s metatag \"%s\"", tmp___20,
           defName);
#line 625
    DestroyVariableStore(& defVarstore);
    }
#line 626
    return ((uint )-1);
  }
#line 629
  if (macroType == 6U) {
#line 629
    tmp___22 = "blockdef";
  } else {
#line 629
    tmp___22 = "def";
  }
  {
#line 629
  HtpMsg((uint )0, task->infile, "dereferencing %s metatag \"%s\"", tmp___22, defName);
#line 634
  newTask.infile = & defFile;
#line 635
  newTask.outfile = task->outfile;
#line 636
  newTask.sourceFilename = task->sourceFilename;
  }
#line 638
  if ((unsigned long )options != (unsigned long )((void *)0)) {
    {
#line 640
    PushVariableStoreContext(task->varstore, & defVarstore);
#line 641
    newTask.varstore = & defVarstore;
    }
  } else
#line 638
  if (macroType == 6U) {
    {
#line 640
    PushVariableStoreContext(task->varstore, & defVarstore);
#line 641
    newTask.varstore = & defVarstore;
    }
  } else {
#line 643
    newTask.varstore = task->varstore;
  }
  {
#line 648
  result = ProcessTask(& newTask);
  }
#line 651
  if ((unsigned long )newTask.varstore == (unsigned long )(& defVarstore)) {
    {
#line 654
    PopVariableStoreContext(& defVarstore);
    }
  }
  {
#line 658
  DestroyVariableStore(& defVarstore);
#line 660
  CloseStream(& defFile);
  }
#line 662
  if (! result) {
    {
#line 666
    HtpMsg((uint )2, task->infile, "... in metatag \"%s\"", defName);
    }
#line 668
    return ((uint )-1);
  }
#line 671
  return ((uint )2);
}
}
#line 675 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/macro.c"
uint ExpandAll(TASK *task , HTML_MARKUP *htmlMarkup , char **newPlaintextPtr , uint markupType ) 
{ 
  uint ctr ;
  uint markupResult ;
  BOOL tmp ;
  BOOL tmp___0 ;
  BOOL tmp___1 ;

  {
  {
#line 681
  tmp = ExpandMacros(task, htmlMarkup);
  }
#line 681
  if (tmp == 0U) {
#line 684
    return ((uint )-1);
  }
  {
#line 691
  markupResult = ExpandMetatag(task, htmlMarkup);
  }
#line 691
  if (markupResult == 0U) {
#line 695
    ctr = (uint )0;
    {
#line 695
    while (1) {
      while_continue: /* CIL Label */ ;
#line 695
      if (! ((unsigned long )ctr < sizeof(markupProcessor) / sizeof(markupProcessor[0]))) {
#line 695
        goto while_break;
      }
#line 697
      if (markupProcessor[ctr].markupType & markupType) {
        {
#line 699
        tmp___0 = IsMarkupTag(htmlMarkup, markupProcessor[ctr].tag);
        }
#line 699
        if (tmp___0) {
          {
#line 703
          markupResult = (*(markupProcessor[ctr].markupFunc))(task, htmlMarkup, newPlaintextPtr);
          }
#line 706
          goto while_break;
        }
      }
#line 695
      ctr ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 714
  if (markupResult != 3U) {
#line 714
    if (markupResult != 2U) {
      {
#line 716
      tmp___1 = MarkupToPlaintext(htmlMarkup, newPlaintextPtr);
      }
#line 716
      if (tmp___1 == 0U) {
        {
#line 718
        HtpMsg((uint )2, task->infile, "unable to build plain text from markup (out of memory?)");
        }
#line 719
        return ((uint )-1);
      }
    }
  }
#line 723
  return (markupResult);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 390 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 18 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/msg.c"
char const   *severitySymbol[3]  = {      "[-]",      "[*]",      "[!]"};
#line 25 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/msg.c"
void HtpMsg(uint level , STREAM *textFile , char const   *format  , ...) 
{ 
  va_list argptr ;
  char *str ;
  void *tmp ;

  {
#line 31
  if (level < *(currentOptions + 1)) {
#line 33
    return;
  }
  {
#line 38
  tmp = malloc((size_t )1024);
#line 38
  str = (char *)tmp;
  }
#line 38
  if ((unsigned long )str == (unsigned long )((void *)0)) {
#line 40
    return;
  }
  {
#line 44
  __builtin_va_start(argptr, format);
#line 45
  vsnprintf((char */* __restrict  */)str, (size_t )1024, (char const   */* __restrict  */)format,
            argptr);
#line 46
  __builtin_va_end(argptr);
#line 49
  printf((char const   */* __restrict  */)"%s ", severitySymbol[level]);
  }
#line 50
  if ((unsigned long )textFile != (unsigned long )((void *)0)) {
    {
#line 52
    printf((char const   */* __restrict  */)"%s line %d: ", textFile->name, textFile->lineNumber);
    }
  }
  {
#line 54
  printf((char const   */* __restrict  */)"%s\n", str);
#line 57
  free((void *)str);
  }
#line 58
  return;
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/jpeg.c"
BOOL JpegReadByte(FILE *file , BYTE *b ) 
{ 
  int i ;

  {
  {
#line 47
  i = fgetc(file);
  }
#line 47
  if (i == -1) {
#line 48
    return ((BOOL )0);
  }
#line 50
  *b = (BYTE )i;
#line 52
  return ((BOOL )1);
}
}
#line 55 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/jpeg.c"
BOOL JpegFirstMarker(FILE *file ) 
{ 
  BYTE flag ;
  BYTE marker ;
  int tmp ;
  BOOL tmp___0 ;
  BOOL tmp___1 ;

  {
  {
#line 61
  tmp = fseek(file, 0L, 0);
  }
#line 61
  if (tmp != 0) {
    {
#line 63
    HtpMsg((uint )1, (STREAM *)((void *)0), "unable to seek to start of JFIF file");
    }
#line 64
    return ((BOOL )0);
  }
  {
#line 68
  tmp___0 = JpegReadByte(file, & flag);
  }
#line 68
  if (tmp___0 == 0U) {
#line 70
    return ((BOOL )0);
  }
  {
#line 73
  tmp___1 = JpegReadByte(file, & marker);
  }
#line 73
  if (tmp___1 == 0U) {
#line 75
    return ((BOOL )0);
  }
#line 79
  if ((int )flag != 255) {
#line 81
    return ((BOOL )0);
  } else
#line 79
  if ((int )marker != 216) {
#line 81
    return ((BOOL )0);
  }
#line 84
  return ((BOOL )1);
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/jpeg.c"
BOOL JpegNextMarker(FILE *file , BYTE *marker , WORD *size ) 
{ 
  BYTE flag ;
  BYTE buff[2] ;
  int bytesread ;
  BOOL tmp ;
  BOOL tmp___0 ;
  size_t tmp___1 ;

  {
#line 91
  bytesread = 0;
  {
#line 94
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 96
    tmp = JpegReadByte(file, & flag);
    }
#line 96
    if (tmp == 0U) {
#line 97
      return ((BOOL )0);
    }
#line 98
    bytesread ++;
#line 94
    if (! ((int )flag != 255)) {
#line 94
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 102
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 102
    if (! ((int )flag == 255)) {
#line 102
      goto while_break___0;
    }
    {
#line 103
    tmp___0 = JpegReadByte(file, & flag);
    }
#line 103
    if (tmp___0 == 0U) {
#line 104
      return ((BOOL )0);
    }
#line 105
    bytesread ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 107
  *marker = flag;
#line 109
  if (bytesread > 2) {
    {
#line 110
    HtpMsg((uint )1, (STREAM *)((void *)0), "Skipped %d bytes of garbage in JFIF file",
           bytesread - 2);
    }
  }
  {
#line 114
  tmp___1 = fread((void */* __restrict  */)(buff), (size_t )1, (size_t )2, (FILE */* __restrict  */)file);
  }
#line 114
  if (tmp___1 != 2UL) {
#line 116
    return ((BOOL )0);
  }
#line 119
  *size = (WORD )(((int )((WORD )buff[0]) << 8) | (int )((WORD )buff[1]));
#line 122
  return ((BOOL )1);
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/jpeg.c"
BOOL JpegFormatFound(FILE *file ) 
{ 
  BYTE marker ;
  WORD size ;
  char signature[8] ;
  BOOL tmp ;
  BOOL tmp___0 ;
  size_t tmp___1 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 131
  tmp = JpegFirstMarker(file);
  }
#line 131
  if (tmp == 0U) {
#line 133
    return ((BOOL )0);
  }
  {
#line 136
  tmp___0 = JpegNextMarker(file, & marker, & size);
  }
#line 136
  if (tmp___0 == 0U) {
#line 138
    return ((BOOL )0);
  }
#line 142
  if ((int )marker != 224) {
#line 144
    return ((BOOL )0);
  }
  {
#line 150
  tmp___1 = fread((void */* __restrict  */)(signature), (size_t )1, (size_t )5, (FILE */* __restrict  */)file);
  }
#line 150
  if (tmp___1 != 5UL) {
    {
#line 152
    HtpMsg((uint )1, (STREAM *)((void *)0), "unable to read JFIF signature from file");
    }
#line 153
    return ((BOOL )0);
  }
  {
#line 157
  tmp___4 = strcmp((char const   *)(signature), "JFIF");
  }
#line 157
  if (tmp___4 == 0) {
#line 157
    tmp___3 = 1;
  } else {
#line 157
    tmp___3 = 0;
  }
#line 157
  return ((BOOL )tmp___3);
}
}
#line 160 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/jpeg.c"
BOOL JpegReadDimensions(FILE *file , DWORD *height , DWORD *width ) 
{ 
  BYTE marker ;
  BYTE buff[5] ;
  WORD size ;
  BOOL tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  BOOL tmp___2 ;

  {
  {
#line 166
  tmp = JpegFirstMarker(file);
  }
#line 166
  if (tmp == 0U) {
#line 168
    return ((BOOL )0);
  }
  {
#line 173
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 173
    tmp___2 = JpegNextMarker(file, & marker, & size);
    }
#line 173
    if (! (tmp___2 == 1U)) {
#line 173
      goto while_break;
    }
#line 176
    if ((int )marker == 218) {
      {
#line 178
      HtpMsg((uint )1, (STREAM *)((void *)0), "JFIF SOS marker found before SOF marker");
      }
#line 179
      goto while_break;
    }
    {
#line 196
    if ((int )marker == 207) {
#line 196
      goto case_207;
    }
#line 196
    if ((int )marker == 206) {
#line 196
      goto case_207;
    }
#line 196
    if ((int )marker == 205) {
#line 196
      goto case_207;
    }
#line 196
    if ((int )marker == 203) {
#line 196
      goto case_207;
    }
#line 196
    if ((int )marker == 202) {
#line 196
      goto case_207;
    }
#line 196
    if ((int )marker == 201) {
#line 196
      goto case_207;
    }
#line 196
    if ((int )marker == 199) {
#line 196
      goto case_207;
    }
#line 196
    if ((int )marker == 198) {
#line 196
      goto case_207;
    }
#line 196
    if ((int )marker == 197) {
#line 196
      goto case_207;
    }
#line 196
    if ((int )marker == 195) {
#line 196
      goto case_207;
    }
#line 196
    if ((int )marker == 194) {
#line 196
      goto case_207;
    }
#line 196
    if ((int )marker == 193) {
#line 196
      goto case_207;
    }
#line 196
    if ((int )marker == 192) {
#line 196
      goto case_207;
    }
#line 212
    goto switch_default;
    case_207: /* CIL Label */ 
    case_206: /* CIL Label */ 
    case_205: /* CIL Label */ 
    case_203: /* CIL Label */ 
    case_202: /* CIL Label */ 
    case_201: /* CIL Label */ 
    case_199: /* CIL Label */ 
    case_198: /* CIL Label */ 
    case_197: /* CIL Label */ 
    case_195: /* CIL Label */ 
    case_194: /* CIL Label */ 
    case_193: /* CIL Label */ 
    case_192: /* CIL Label */ 
    {
#line 200
    tmp___0 = fread((void */* __restrict  */)(buff), (size_t )1, (size_t )5, (FILE */* __restrict  */)file);
    }
#line 200
    if (tmp___0 != 5UL) {
      {
#line 202
      HtpMsg((uint )1, (STREAM *)((void *)0), "unable to read dimensions from JFIF file");
      }
#line 204
      return ((BOOL )0);
    }
#line 208
    *height = (DWORD )(((int )((WORD )buff[1]) << 8) | (int )((WORD )buff[2]));
#line 209
    *width = (DWORD )(((int )((WORD )buff[3]) << 8) | (int )((WORD )buff[4]));
#line 210
    return ((BOOL )1);
    switch_default: /* CIL Label */ 
    {
#line 213
    tmp___1 = fseek(file, (long )((int )size - 2), 1);
    }
#line 213
    if (tmp___1 != 0) {
      {
#line 215
      HtpMsg((uint )1, (STREAM *)((void *)0), "unable to seek past JFIF block");
      }
#line 216
      return ((BOOL )0);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 221
  HtpMsg((uint )1, (STREAM *)((void *)0), "JFIF SOF marker not found");
  }
#line 224
  return ((BOOL )0);
}
}
#line 147 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 45 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/html.h"
char const   *FindWhitespace(char const   *str ) ;
#line 46
char const   *FindNonWhitespace(char const   *str ) ;
#line 55
BOOL PlaintextToMarkup(char const   *plaintext , HTML_MARKUP *htmlMarkup ) ;
#line 57
BOOL AddAttributeToMarkup(HTML_MARKUP *htmlMarkup , char const   *name , char const   *value ,
                          int quotedValue ) ;
#line 16 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/html.c"
char const   *FindWhitespace(char const   *str ) 
{ 
  unsigned short const   **tmp ;

  {
  {
#line 20
  while (1) {
    while_continue: /* CIL Label */ ;
#line 20
    if (! ((int const   )*str != 0)) {
#line 20
      goto while_break;
    }
    {
#line 22
    tmp = __ctype_b_loc();
    }
#line 22
    if ((int const   )*(*tmp + (int )*str) & 8192) {
#line 24
      goto while_break;
    }
#line 26
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 29
  return (str);
}
}
#line 32 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/html.c"
char const   *FindNonWhitespace(char const   *str ) 
{ 
  unsigned short const   **tmp ;

  {
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
#line 36
    if (! ((int const   )*str != 0)) {
#line 36
      goto while_break;
    }
    {
#line 38
    tmp = __ctype_b_loc();
    }
#line 38
    if (! ((int const   )*(*tmp + (int )*str) & 8192)) {
#line 40
      goto while_break;
    }
#line 42
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 45
  return (str);
}
}
#line 52 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/html.c"
static BOOL MakeAttribute(HTML_ATTRIBUTE *htmlAttribute , char const   *name , char const   *value ,
                          int quotes ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 59
  tmp = DuplicateString(name);
#line 59
  htmlAttribute->name = tmp;
  }
#line 59
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 61
    return ((BOOL )0);
  }
#line 65
  if ((unsigned long )value != (unsigned long )((void *)0)) {
    {
#line 67
    tmp___0 = DuplicateString(value);
#line 67
    htmlAttribute->value = tmp___0;
    }
#line 67
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
      {
#line 69
      free((void *)htmlAttribute->name);
#line 70
      htmlAttribute->name = (char *)((void *)0);
      }
#line 71
      return ((BOOL )0);
    }
  } else {
#line 76
    htmlAttribute->value = (char *)((void *)0);
  }
#line 80
  htmlAttribute->quotes = quotes;
#line 81
  htmlAttribute->whitespace = (char *)((void *)0);
#line 83
  return ((BOOL )1);
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/html.c"
BOOL ChangeAttributeName(HTML_ATTRIBUTE *htmlAttribute , char *name ) 
{ 


  {
#line 91
  if ((unsigned long )htmlAttribute->name != (unsigned long )((void *)0)) {
    {
#line 93
    free((void *)htmlAttribute->name);
#line 94
    htmlAttribute->name = (char *)((void *)0);
    }
  }
#line 97
  htmlAttribute->name = name;
#line 99
  return ((BOOL )1);
}
}
#line 102 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/html.c"
BOOL ChangeAttributeValue(HTML_ATTRIBUTE *htmlAttribute , char *value , int quotes ) 
{ 


  {
#line 108
  if ((unsigned long )htmlAttribute->value != (unsigned long )((void *)0)) {
    {
#line 110
    free((void *)htmlAttribute->value);
#line 111
    htmlAttribute->value = (char *)((void *)0);
    }
  }
#line 114
  htmlAttribute->value = value;
#line 115
  htmlAttribute->quotes = quotes;
#line 117
  return ((BOOL )1);
}
}
#line 120 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/html.c"
void DestroyAttribute(HTML_ATTRIBUTE *htmlAttribute ) 
{ 


  {
  {
#line 126
  free((void *)htmlAttribute->name);
#line 127
  htmlAttribute->name = (char *)((void *)0);
  }
#line 129
  if ((unsigned long )htmlAttribute->value != (unsigned long )((void *)0)) {
    {
#line 131
    free((void *)htmlAttribute->value);
#line 132
    htmlAttribute->value = (char *)((void *)0);
    }
  }
#line 135
  if ((unsigned long )htmlAttribute->whitespace != (unsigned long )((void *)0)) {
    {
#line 137
    free((void *)htmlAttribute->whitespace);
#line 138
    htmlAttribute->whitespace = (char *)((void *)0);
    }
  }
#line 140
  return;
}
}
#line 156 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/html.c"
BOOL PlaintextToMarkup(char const   *plaintext , HTML_MARKUP *htmlMarkup ) 
{ 
  char const   *plainPtr ;
  char const   *start ;
  HTML_ATTRIBUTE **attribLink ;
  HTML_ATTRIBUTE *attrib ;
  char *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  unsigned short const   **tmp___4 ;
  char quote ;

  {
#line 165
  if ((int const   )*(plaintext + 0) == 0) {
#line 168
    return ((BOOL )0);
  }
  {
#line 171
  plainPtr = plaintext;
#line 174
  htmlMarkup->tag = (char *)((void *)0);
#line 175
  htmlMarkup->single = (BOOL )0;
#line 176
  htmlMarkup->attrib = (HTML_ATTRIBUTE *)((void *)0);
#line 177
  attribLink = & htmlMarkup->attrib;
#line 183
  plainPtr = FindNonWhitespace(plainPtr);
  }
#line 184
  if ((int const   )*plainPtr == 0) {
#line 186
    return ((BOOL )1);
  }
  {
#line 190
  start = plainPtr;
#line 193
  plainPtr = FindWhitespace(plainPtr);
#line 196
  tmp = DuplicateSubString(start, (int )(plainPtr - start));
#line 196
  htmlMarkup->tag = tmp;
  }
#line 196
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 199
    return ((BOOL )0);
  }
  {
#line 203
  start = plainPtr;
#line 204
  plainPtr = FindNonWhitespace(plainPtr);
#line 205
  htmlMarkup->whitespace = DuplicateSubString(start, (int )(plainPtr - start));
#line 208
  tmp___1 = strncmp((char const   *)htmlMarkup->tag, "!--", (size_t )3);
  }
#line 208
  if (tmp___1) {
#line 208
    if ((int )*(htmlMarkup->tag + 0) == 63) {
      _L: /* CIL Label */ 
#line 211
      if ((int const   )*plainPtr == 0) {
#line 212
        return ((BOOL )1);
      }
      {
#line 213
      tmp___0 = malloc(sizeof(HTML_ATTRIBUTE ));
#line 213
      attrib = (HTML_ATTRIBUTE *)tmp___0;
#line 213
      *attribLink = attrib;
      }
#line 214
      if ((unsigned long )attrib == (unsigned long )((void *)0)) {
        {
#line 217
        DestroyMarkupStruct(htmlMarkup);
        }
#line 218
        return ((BOOL )0);
      }
      {
#line 220
      attrib->name = DuplicateString(plainPtr);
#line 221
      attrib->value = (char *)((void *)0);
#line 222
      attrib->whitespace = (char *)((void *)0);
#line 223
      attrib->quotes = 0;
#line 224
      attrib->next = (struct tagHTML_ATTRIBUTE *)((void *)0);
      }
#line 225
      return ((BOOL )1);
    }
  } else {
#line 208
    goto _L;
  }
  {
#line 230
  while (1) {
    while_continue: /* CIL Label */ ;
#line 230
    if (! ((int const   )*plainPtr != 0)) {
#line 230
      goto while_break;
    }
    {
#line 233
    tmp___2 = strcmp(plainPtr, "/");
    }
#line 233
    if (tmp___2 == 0) {
#line 234
      htmlMarkup->single = (BOOL )1;
#line 235
      goto while_break;
    }
    {
#line 238
    tmp___3 = malloc(sizeof(HTML_ATTRIBUTE ));
#line 238
    attrib = (HTML_ATTRIBUTE *)tmp___3;
#line 238
    *attribLink = attrib;
    }
#line 239
    if ((unsigned long )attrib == (unsigned long )((void *)0)) {
      {
#line 242
      DestroyMarkupStruct(htmlMarkup);
      }
#line 243
      return ((BOOL )0);
    }
#line 248
    start = plainPtr;
    {
#line 249
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 249
      if ((int const   )*plainPtr != 0) {
#line 249
        if ((int const   )*plainPtr != 61) {
          {
#line 249
          tmp___4 = __ctype_b_loc();
          }
#line 249
          if ((int const   )*(*tmp___4 + (int )*plainPtr) & 8192) {
#line 249
            goto while_break___0;
          }
        } else {
#line 249
          goto while_break___0;
        }
      } else {
#line 249
        goto while_break___0;
      }
#line 253
      plainPtr ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 255
    attrib->name = DuplicateSubString(start, (int )(plainPtr - start));
#line 256
    attrib->value = (char *)((void *)0);
#line 257
    attrib->quotes = 0;
#line 258
    attrib->next = (struct tagHTML_ATTRIBUTE *)((void *)0);
#line 259
    attrib->whitespace = (char *)((void *)0);
#line 260
    attribLink = & attrib->next;
    }
#line 262
    if ((int const   )*plainPtr == 61) {
#line 264
      plainPtr ++;
#line 266
      if ((int const   )*plainPtr == 34) {
#line 266
        goto _L___0;
      } else
#line 266
      if ((int const   )*plainPtr == 39) {
        _L___0: /* CIL Label */ 
#line 269
        quote = (char )*plainPtr;
#line 270
        if ((int )quote == 34) {
#line 270
          attrib->quotes = 1;
        } else {
#line 270
          attrib->quotes = 2;
        }
#line 271
        plainPtr ++;
#line 272
        start = plainPtr;
        {
#line 274
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 274
          if (! ((int const   )*plainPtr != (int const   )quote)) {
#line 274
            goto while_break___1;
          }
#line 280
          if ((int const   )*plainPtr == 0) {
            {
#line 282
            DestroyMarkupStruct(htmlMarkup);
            }
#line 283
            return ((BOOL )0);
          }
#line 285
          plainPtr ++;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 287
        attrib->value = DuplicateSubString(start, (int )(plainPtr - start));
#line 288
        plainPtr ++;
        }
      } else {
        {
#line 292
        start = plainPtr;
#line 293
        plainPtr = FindWhitespace(plainPtr);
#line 294
        attrib->value = DuplicateSubString(start, (int )(plainPtr - start));
        }
      }
    }
    {
#line 299
    start = plainPtr;
#line 300
    plainPtr = FindNonWhitespace(plainPtr);
#line 301
    attrib->whitespace = DuplicateSubString(start, (int )(plainPtr - start));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 304
  return ((BOOL )1);
}
}
#line 307 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/html.c"
BOOL AddAttributeToMarkup(HTML_MARKUP *htmlMarkup , char const   *name , char const   *value ,
                          int quotedValue ) 
{ 
  HTML_ATTRIBUTE **attribPtr ;
  HTML_ATTRIBUTE *attrib ;
  void *tmp ;
  BOOL tmp___0 ;

  {
  {
#line 314
  tmp = malloc(sizeof(HTML_ATTRIBUTE ));
#line 314
  attrib = (HTML_ATTRIBUTE *)tmp;
  }
#line 315
  if ((unsigned long )attrib == (unsigned long )((void *)0)) {
#line 318
    return ((BOOL )0);
  }
  {
#line 321
  tmp___0 = MakeAttribute(attrib, name, value, quotedValue);
  }
#line 321
  if (! tmp___0) {
    {
#line 323
    free((void *)attrib);
    }
#line 325
    return ((BOOL )0);
  }
#line 328
  attribPtr = & htmlMarkup->attrib;
  {
#line 329
  while (1) {
    while_continue: /* CIL Label */ ;
#line 329
    if (! ((unsigned long )*attribPtr != (unsigned long )((void *)0))) {
#line 329
      goto while_break;
    }
#line 330
    attribPtr = & (*attribPtr)->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 332
  *attribPtr = attrib;
#line 333
  attrib->next = (struct tagHTML_ATTRIBUTE *)((void *)0);
#line 335
  return ((BOOL )1);
}
}
#line 338 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/html.c"
void DestroyMarkupStruct(HTML_MARKUP *htmlMarkup ) 
{ 
  HTML_ATTRIBUTE *attrib ;
  HTML_ATTRIBUTE *next ;

  {
#line 347
  if ((unsigned long )htmlMarkup->tag != (unsigned long )((void *)0)) {
    {
#line 349
    free((void *)htmlMarkup->tag);
#line 350
    htmlMarkup->tag = (char *)((void *)0);
    }
  }
#line 353
  attrib = htmlMarkup->attrib;
#line 354
  htmlMarkup->attrib = (HTML_ATTRIBUTE *)((void *)0);
#line 356
  if ((unsigned long )htmlMarkup->whitespace != (unsigned long )((void *)0)) {
    {
#line 358
    free((void *)htmlMarkup->whitespace);
#line 359
    htmlMarkup->whitespace = (char *)((void *)0);
    }
  }
  {
#line 363
  while (1) {
    while_continue: /* CIL Label */ ;
#line 363
    if (! ((unsigned long )attrib != (unsigned long )((void *)0))) {
#line 363
      goto while_break;
    }
    {
#line 364
    next = attrib->next;
#line 365
    DestroyAttribute(attrib);
#line 366
    free((void *)attrib);
#line 367
    attrib = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 369
  return;
}
}
#line 371 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/html.c"
BOOL IsMarkupTag(HTML_MARKUP *htmlMarkup , char const   *tag ) 
{ 
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 376
  tmp___1 = strcasecmp((char const   *)htmlMarkup->tag, tag);
  }
#line 376
  if (tmp___1 == 0) {
#line 376
    tmp___0 = 1;
  } else {
#line 376
    tmp___0 = 0;
  }
#line 376
  return ((BOOL )tmp___0);
}
}
#line 379 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/html.c"
BOOL MarkupToPlaintext(HTML_MARKUP *htmlMarkup , char **plaintext ) 
{ 
  HTML_ATTRIBUTE *htmlAttribute ;
  uint size ;
  uint attrSize ;
  uint maxAttrSize ;
  uint wslen ;
  char *buffer ;
  char *bufferPtr ;
  size_t tmp ;
  size_t tmp___0 ;
  char *quotes ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  char *quotes___0 ;

  {
#line 393
  maxAttrSize = (uint )0;
#line 396
  if ((unsigned long )htmlMarkup->whitespace != (unsigned long )((void *)0)) {
    {
#line 396
    tmp = strlen((char const   *)htmlMarkup->whitespace);
#line 396
    wslen = (uint )tmp;
    }
  } else {
#line 396
    wslen = (uint )0;
  }
#line 399
  if (wslen == 0U) {
#line 399
    if (htmlMarkup->attrib) {
#line 400
      wslen = (uint )1;
    } else
#line 399
    if (htmlMarkup->single) {
#line 400
      wslen = (uint )1;
    }
  }
  {
#line 403
  tmp___0 = strlen((char const   *)htmlMarkup->tag);
#line 403
  size = (uint )((tmp___0 + (size_t )wslen) + 1UL);
#line 404
  htmlAttribute = htmlMarkup->attrib;
  }
  {
#line 405
  while (1) {
    while_continue: /* CIL Label */ ;
#line 405
    if (! ((unsigned long )htmlAttribute != (unsigned long )((void *)0))) {
#line 405
      goto while_break;
    }
#line 406
    quotes = (char *)"";
#line 411
    if ((unsigned long )htmlAttribute->whitespace != (unsigned long )((void *)0)) {
      {
#line 411
      tmp___1 = strlen((char const   *)htmlAttribute->whitespace);
#line 411
      wslen = (uint )tmp___1;
      }
    } else {
#line 411
      wslen = (uint )0;
    }
#line 415
    if (wslen == 0U) {
#line 415
      if (htmlAttribute->next) {
#line 417
        wslen = (uint )1;
      } else
#line 415
      if (htmlMarkup->single) {
#line 417
        wslen = (uint )1;
      }
    }
    {
#line 419
    tmp___2 = strlen((char const   *)htmlAttribute->name);
#line 419
    attrSize = (uint )(tmp___2 + (size_t )wslen);
    }
    {
#line 423
    if (htmlAttribute->quotes == 1) {
#line 423
      goto case_1;
    }
#line 426
    if (htmlAttribute->quotes == 2) {
#line 426
      goto case_2;
    }
#line 421
    goto switch_break;
    case_1: /* CIL Label */ 
#line 424
    quotes = (char *)"\"";
#line 425
    goto switch_break;
    case_2: /* CIL Label */ 
#line 427
    quotes = (char *)"\'";
#line 428
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 432
    if ((unsigned long )htmlAttribute->value != (unsigned long )((void *)0)) {
      {
#line 435
      tmp___3 = strlen((char const   *)htmlAttribute->value);
#line 435
      attrSize = (uint )((size_t )attrSize + (tmp___3 + 1UL));
#line 438
      tmp___4 = strlen((char const   *)quotes);
#line 438
      attrSize = (uint )((size_t )attrSize + 2UL * tmp___4);
      }
    }
#line 442
    attrSize ++;
#line 444
    size += attrSize;
#line 445
    if (maxAttrSize < attrSize) {
#line 447
      maxAttrSize = attrSize;
    }
#line 449
    htmlAttribute = htmlAttribute->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 451
  if (htmlMarkup->single) {
#line 452
    size ++;
  }
  {
#line 455
  tmp___5 = malloc((size_t )size);
#line 455
  buffer = (char *)tmp___5;
  }
#line 455
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
#line 458
    return ((BOOL )0);
  }
  {
#line 462
  bufferPtr = stpcpy((char */* __restrict  */)buffer, (char const   */* __restrict  */)htmlMarkup->tag);
  }
#line 464
  if ((unsigned long )htmlMarkup->whitespace == (unsigned long )((void *)0)) {
#line 464
    goto _L;
  } else
#line 464
  if ((int )*(htmlMarkup->whitespace + 0) == 0) {
    _L: /* CIL Label */ 
#line 468
    if (htmlMarkup->attrib) {
      {
#line 469
      bufferPtr = stpcpy((char */* __restrict  */)bufferPtr, (char const   */* __restrict  */)" ");
      }
    } else
#line 468
    if (htmlMarkup->single) {
      {
#line 469
      bufferPtr = stpcpy((char */* __restrict  */)bufferPtr, (char const   */* __restrict  */)" ");
      }
    }
  } else {
    {
#line 472
    bufferPtr = stpcpy((char */* __restrict  */)bufferPtr, (char const   */* __restrict  */)htmlMarkup->whitespace);
    }
  }
#line 475
  htmlAttribute = htmlMarkup->attrib;
  {
#line 476
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 476
    if (! ((unsigned long )htmlAttribute != (unsigned long )((void *)0))) {
#line 476
      goto while_break___0;
    }
#line 478
    quotes___0 = (char *)"";
    {
#line 486
    if (htmlAttribute->quotes == 1) {
#line 486
      goto case_1___0;
    }
#line 489
    if (htmlAttribute->quotes == 2) {
#line 489
      goto case_2___0;
    }
#line 484
    goto switch_break___0;
    case_1___0: /* CIL Label */ 
#line 487
    quotes___0 = (char *)"\"";
#line 488
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
#line 490
    quotes___0 = (char *)"\'";
#line 491
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
    {
#line 494
    bufferPtr = stpcpy((char */* __restrict  */)bufferPtr, (char const   */* __restrict  */)htmlAttribute->name);
    }
#line 496
    if ((unsigned long )htmlAttribute->value != (unsigned long )((void *)0)) {
      {
#line 498
      bufferPtr = stpcpy((char */* __restrict  */)bufferPtr, (char const   */* __restrict  */)"=");
#line 499
      bufferPtr = stpcpy((char */* __restrict  */)bufferPtr, (char const   */* __restrict  */)quotes___0);
#line 500
      bufferPtr = stpcpy((char */* __restrict  */)bufferPtr, (char const   */* __restrict  */)htmlAttribute->value);
#line 501
      bufferPtr = stpcpy((char */* __restrict  */)bufferPtr, (char const   */* __restrict  */)quotes___0);
      }
    }
#line 504
    if ((unsigned long )htmlAttribute->whitespace == (unsigned long )((void *)0)) {
#line 504
      goto _L___0;
    } else
#line 504
    if ((int )*(htmlAttribute->whitespace + 0) == 0) {
      _L___0: /* CIL Label */ 
#line 508
      if (htmlAttribute->next) {
        {
#line 509
        bufferPtr = stpcpy((char */* __restrict  */)bufferPtr, (char const   */* __restrict  */)" ");
        }
      } else
#line 508
      if (htmlMarkup->single) {
        {
#line 509
        bufferPtr = stpcpy((char */* __restrict  */)bufferPtr, (char const   */* __restrict  */)" ");
        }
      }
    } else {
      {
#line 512
      bufferPtr = stpcpy((char */* __restrict  */)bufferPtr, (char const   */* __restrict  */)htmlAttribute->whitespace);
      }
    }
#line 515
    htmlAttribute = htmlAttribute->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 519
  if (htmlMarkup->single == 1U) {
    {
#line 520
    bufferPtr = stpcpy((char */* __restrict  */)bufferPtr, (char const   */* __restrict  */)"/");
    }
  }
#line 524
  *plaintext = buffer;
#line 526
  return ((BOOL )1);
}
}
#line 529 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/html.c"
HTML_ATTRIBUTE **FindMarkupAttribute(HTML_MARKUP *htmlMarkup , char const   *name ) 
{ 
  HTML_ATTRIBUTE **attribPtr ;
  int tmp ;

  {
#line 536
  attribPtr = & htmlMarkup->attrib;
  {
#line 537
  while (1) {
    while_continue: /* CIL Label */ ;
#line 537
    if (! ((unsigned long )*attribPtr != (unsigned long )((void *)0))) {
#line 537
      goto while_break;
    }
    {
#line 538
    tmp = strcasecmp((char const   *)(*attribPtr)->name, name);
    }
#line 538
    if (tmp == 0) {
#line 539
      return (attribPtr);
    }
#line 540
    attribPtr = & (*attribPtr)->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 542
  return ((HTML_ATTRIBUTE **)((void *)0));
}
}
#line 545 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/html.c"
char const   *MarkupAttributeValue(HTML_MARKUP *htmlMarkup , char const   *name ) 
{ 
  HTML_ATTRIBUTE **attribPtr ;

  {
  {
#line 551
  attribPtr = FindMarkupAttribute(htmlMarkup, name);
  }
#line 551
  if ((unsigned long )attribPtr == (unsigned long )((void *)0)) {
#line 553
    return ((char const   *)((void *)0));
  }
#line 559
  return ((char const   *)(*attribPtr)->value);
}
}
#line 562 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/html.c"
BOOL ChangeMarkupTag(HTML_MARKUP *htmlMarkup , char *tag ) 
{ 


  {
#line 567
  if ((unsigned long )htmlMarkup->tag != (unsigned long )((void *)0)) {
    {
#line 569
    free((void *)htmlMarkup->tag);
    }
  }
#line 572
  htmlMarkup->tag = tag;
#line 574
  return ((BOOL )1);
}
}
#line 577 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/html.c"
HTML_ATTRIBUTE *UnlinkAttributeInMarkup(HTML_MARKUP *htmlMarkup , char const   *name ) 
{ 
  HTML_ATTRIBUTE **attribPtr ;
  HTML_ATTRIBUTE *attrib ;

  {
  {
#line 584
  attribPtr = FindMarkupAttribute(htmlMarkup, name);
  }
#line 584
  if ((unsigned long )attribPtr == (unsigned long )((void *)0)) {
#line 586
    return ((HTML_ATTRIBUTE *)((void *)0));
  }
#line 589
  attrib = *attribPtr;
#line 590
  *attribPtr = attrib->next;
#line 591
  attrib->next = (struct tagHTML_ATTRIBUTE *)((void *)0);
#line 593
  return (attrib);
}
}
#line 596 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/html.c"
BOOL UnlinkBoolAttributeInMarkup(HTML_MARKUP *htmlMarkup , char const   *name ) 
{ 
  HTML_ATTRIBUTE **attribPtr ;
  HTML_ATTRIBUTE *attrib ;

  {
  {
#line 602
  attribPtr = FindMarkupAttribute(htmlMarkup, name);
  }
#line 602
  if ((unsigned long )attribPtr == (unsigned long )((void *)0)) {
#line 604
    return ((BOOL )0);
  }
#line 607
  attrib = *attribPtr;
#line 610
  if ((unsigned long )attrib->value != (unsigned long )((void *)0)) {
#line 611
    return ((BOOL )0);
  }
  {
#line 613
  *attribPtr = attrib->next;
#line 614
  attrib->next = (struct tagHTML_ATTRIBUTE *)((void *)0);
#line 615
  free((void *)attrib->name);
  }
#line 616
  if (attrib->whitespace) {
    {
#line 617
    free((void *)attrib->whitespace);
    }
  }
  {
#line 618
  free((void *)attrib);
  }
#line 620
  return ((BOOL )1);
}
}
#line 140 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 40 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/option.h"
uint *currentOptions  ;
#line 16 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/option.c"
static uint globalOptions[8]  ;
#line 17 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/option.c"
static uint localOptions[8]  ;
#line 23 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/option.c"
char const   *option_msg_index[8]  = 
#line 23
  {      "image pre-processing",      (char const   *)((void *)0),      "dependency checking",      "precious output", 
        "condensed output",      (char const   *)((void *)0),      "markup delimiter",      "use XML-style generator tag"};
#line 34 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/option.c"
char const   *option_msg_value[6]  = {      "turned OFF",      "turned ON",      "turned to SEMI",      "set to \"<\"", 
        "set to \"[\"",      "set to \"{\""};
#line 43 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/option.c"
BOOL SetOption(TASK *task , uint index___0 , uint value ) 
{ 


  {
#line 45
  if ((unsigned long )task != (unsigned long )((void *)0)) {
#line 45
    if ((unsigned long )option_msg_index[index___0] != (unsigned long )((void *)0)) {
      {
#line 46
      HtpMsg((uint )0, task->infile, "%s %s", option_msg_index[index___0], option_msg_value[value]);
      }
    }
  }
#line 50
  *(currentOptions + index___0) = value;
#line 52
  if (index___0 == 6U) {
    {
#line 56
    if (value == 3U) {
#line 56
      goto case_3;
    }
#line 60
    if (value == 5U) {
#line 60
      goto case_5;
    }
#line 64
    if (value == 4U) {
#line 64
      goto case_4;
    }
#line 54
    goto switch_break;
    case_3: /* CIL Label */ 
#line 57
    htpOpenMarkup = (char )'<';
#line 58
    htpCloseMarkup = (char )'>';
#line 59
    goto switch_break;
    case_5: /* CIL Label */ 
#line 61
    htpOpenMarkup = (char )'{';
#line 62
    htpCloseMarkup = (char )'}';
#line 63
    goto switch_break;
    case_4: /* CIL Label */ 
#line 65
    htpOpenMarkup = (char )'[';
#line 66
    htpCloseMarkup = (char )']';
#line 67
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 70
  return ((BOOL )1);
}
}
#line 74 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/option.c"
BOOL InitializeGlobalOption(void) 
{ 


  {
#line 77
  globalOptions[0] = (uint )1;
#line 78
  globalOptions[1] = (uint )0;
#line 79
  globalOptions[2] = (uint )1;
#line 80
  globalOptions[3] = (uint )0;
#line 81
  globalOptions[4] = (uint )2;
#line 82
  globalOptions[5] = (uint )0;
#line 83
  globalOptions[6] = (uint )3;
#line 84
  globalOptions[7] = (uint )0;
#line 85
  currentOptions = globalOptions;
#line 87
  return ((BOOL )1);
}
}
#line 90 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/option.c"
void DestroyGlobalOption(void) 
{ 


  {
#line 92
  return;
}
}
#line 94 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/option.c"
BOOL InitializeLocalOption(void) 
{ 


  {
  {
#line 96
  memcpy((void */* __restrict  */)(localOptions), (void const   */* __restrict  */)(globalOptions),
         sizeof(globalOptions));
#line 97
  currentOptions = localOptions;
  }
#line 98
  return ((BOOL )1);
}
}
#line 101 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/option.c"
void DestroyLocalOption(void) 
{ 


  {
#line 103
  return;
}
}
#line 107 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/option.c"
static struct __anonstruct_opt_31  const  opt[19]  = 
#line 107
  {      {(char *)"IMGXY", (uint )0, (uint )1}, 
        {(char *)"NOIMGXY", (uint )0, (uint )0}, 
        {(char *)"VERBOSE", (uint )1, (uint )0}, 
        {(char *)"QUIET", (uint )1, (uint )1}, 
        {(char *)"DEPEND", (uint )2, (uint )1}, 
        {(char *)"NODEPEND", (uint )2, (uint )0}, 
        {(char *)"PRECIOUS", (uint )3, (uint )1}, 
        {(char *)"NOPRECIOUS", (uint )3, (uint )0}, 
        {(char *)"CONDENSE", (uint )4, (uint )1}, 
        {(char *)"SEMICONDENSE", (uint )4, (uint )2}, 
        {(char *)"NOCONDENSE", (uint )4, (uint )0}, 
        {(char *)"DELIM=HTML", (uint )6, (uint )3}, 
        {(char *)"DELIM=SQUARE", (uint )6, (uint )4}, 
        {(char *)"DELIM=CURLY", (uint )6, (uint )5}, 
        {(char *)"XML", (uint )7, (uint )1}, 
        {(char *)"XML=FALSE", (uint )7, (uint )0}, 
        {(char *)"?", (uint )5, (uint )1}, 
        {(char *)"H", (uint )5, (uint )1}, 
        {(char *)"-HELP", (uint )5, (uint )1}};
#line 105 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/option.c"
BOOL ParseToken(TASK *task , char const   *string ) 
{ 
  int i ;
  BOOL tmp ;
  int tmp___0 ;
  STREAM *tmp___1 ;

  {
#line 133
  i = 0;
  {
#line 133
  while (1) {
    while_continue: /* CIL Label */ ;
#line 133
    if (! ((unsigned long )i < sizeof(opt) / sizeof(opt[0]))) {
#line 133
      goto while_break;
    }
    {
#line 134
    tmp___0 = strcasecmp((char const   *)opt[i].name, string);
    }
#line 134
    if (tmp___0 == 0) {
      {
#line 135
      tmp = SetOption(task, (uint )opt[i].index, (uint )opt[i].value);
      }
#line 135
      return (tmp);
    }
#line 133
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 139
  if ((unsigned long )task != (unsigned long )((void *)0)) {
#line 139
    tmp___1 = task->infile;
  } else {
#line 139
    tmp___1 = (STREAM *)((void *)0);
  }
  {
#line 139
  HtpMsg((uint )1, tmp___1, "unknown option \"%s\" specified", string);
  }
#line 141
  return ((BOOL )1);
}
}
#line 144 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/option.c"
uint OptionProcessor(TASK *task , HTML_MARKUP *htmlMarkup , char **newPlaintext ) 
{ 
  char buff[32] ;
  char *token ;
  HTML_ATTRIBUTE *attrib ;
  BOOL tmp ;

  {
#line 150
  newPlaintext = newPlaintext;
#line 155
  attrib = htmlMarkup->attrib;
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
#line 156
    if (! ((unsigned long )attrib != (unsigned long )((void *)0))) {
#line 156
      goto while_break;
    }
#line 158
    token = attrib->name;
#line 159
    if ((unsigned long )attrib->value != (unsigned long )((void *)0)) {
      {
#line 161
      StringCopy(buff, (char const   *)token, (uint )sizeof(buff));
#line 162
      strncat((char */* __restrict  */)(buff), (char const   */* __restrict  */)"=",
              sizeof(buff) - 1UL);
#line 163
      strncat((char */* __restrict  */)(buff), (char const   */* __restrict  */)attrib->value,
              sizeof(buff) - 1UL);
#line 164
      token = buff;
      }
    }
    {
#line 167
    tmp = ParseToken(task, (char const   *)token);
    }
#line 167
    if (tmp == 0U) {
#line 169
      return ((uint )-1);
    }
#line 171
    attrib = attrib->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 174
  return ((uint )2);
}
}
#line 23 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/image-proc.c"
uint ImageProcessor(TASK *task , HTML_MARKUP *htmlMarkup , char **newPlaintext ) 
{ 
  char str[32] ;
  IMAGEFILE imageFile ;
  DWORD width ;
  DWORD height ;
  char const   *imgSource ;
  char const   *imgFilename ;
  char const   *imgText ;
  char altFilename[40] ;
  void *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  BOOL tmp___3 ;
  BOOL tmp___4 ;

  {
  {
#line 33
  newPlaintext = newPlaintext;
#line 36
  imgSource = MarkupAttributeValue(htmlMarkup, "SRC");
  }
#line 37
  if ((unsigned long )imgSource == (unsigned long )((void *)0)) {
    {
#line 39
    HtpMsg((uint )1, task->infile, "image SRC not specified, skipping");
    }
#line 40
    return ((uint )0);
  }
  {
#line 45
  tmp___0 = MarkupAttributeValue(htmlMarkup, "ALT");
  }
#line 45
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
    {
#line 48
    imgFilename = FindFilename(imgSource);
#line 49
    strcpy((char */* __restrict  */)(altFilename), (char const   */* __restrict  */)"_htpalt_");
#line 50
    StringCopy(altFilename + 8, imgFilename, (uint )32);
#line 53
    tmp = GetVariableValue(task->varstore, (char const   *)(altFilename));
#line 53
    imgText = (char const   *)tmp;
    }
#line 54
    if ((unsigned long )imgText != (unsigned long )((void *)0)) {
      {
#line 55
      AddAttributeToMarkup(htmlMarkup, "alt", imgText, 1);
#line 56
      HtpMsg((uint )0, task->infile, "ALT text \"%s\" added to IMG \"%s\"", imgText,
             imgSource);
      }
    }
  }
#line 62
  if ((*(currentOptions + 0) == 1U) == 0) {
#line 64
    return ((uint )0);
  }
  {
#line 69
  tmp___1 = MarkupAttributeValue(htmlMarkup, "HEIGHT");
  }
#line 69
  if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
#line 72
    return ((uint )0);
  } else {
    {
#line 69
    tmp___2 = MarkupAttributeValue(htmlMarkup, "WIDTH");
    }
#line 69
    if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
#line 72
      return ((uint )0);
    }
  }
  {
#line 76
  tmp___3 = OpenImageFile(imgSource, & imageFile);
  }
#line 76
  if (tmp___3 == 0U) {
    {
#line 78
    HtpMsg((uint )1, task->infile, "unable to open image file \"%s\"", imgSource);
    }
#line 80
    return ((uint )0);
  }
  {
#line 83
  tmp___4 = GetImageDimensions(& imageFile, & width, & height);
  }
#line 83
  if (tmp___4 == 0U) {
    {
#line 85
    HtpMsg((uint )1, task->infile, "unable to determine image file \"%s\" dimensions",
           imgSource);
    }
  } else {
    {
#line 91
    snprintf((char */* __restrict  */)(str), (size_t )32, (char const   */* __restrict  */)"%lu",
             width);
#line 92
    AddAttributeToMarkup(htmlMarkup, "width", (char const   *)(str), 1);
#line 93
    snprintf((char */* __restrict  */)(str), (size_t )32, (char const   */* __restrict  */)"%lu",
             height);
#line 94
    AddAttributeToMarkup(htmlMarkup, "height", (char const   *)(str), 1);
#line 97
    HtpMsg((uint )0, task->outfile, "image file \"%s\" dimensions (%u x %u) added",
           imgSource, width, height);
    }
  }
  {
#line 101
  CloseImageFile(& imageFile);
  }
#line 104
  return ((uint )0);
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/image-proc.c"
uint AltTextProcessor(TASK *task , HTML_MARKUP *htmlMarkup , char **newPlaintext ) 
{ 
  char const   *imgName ;
  char const   *imgText ;
  char *altNameCopy ;
  char *imgTextCopy ;
  char altName[40] ;
  BOOL tmp ;

  {
  {
#line 114
  newPlaintext = newPlaintext;
#line 117
  imgName = MarkupAttributeValue(htmlMarkup, "NAME");
  }
#line 120
  if ((unsigned long )imgName == (unsigned long )((void *)0)) {
    {
#line 122
    HtpMsg((uint )2, task->infile, "ALTTEXT requires a nonempty NAME attribute");
    }
#line 124
    return ((uint )-1);
  }
  {
#line 126
  imgText = MarkupAttributeValue(htmlMarkup, "TEXT");
#line 128
  strcpy((char */* __restrict  */)(altName), (char const   */* __restrict  */)"_htpalt_");
#line 129
  StringCopy(altName + 8, imgName, (uint )32);
  }
#line 132
  if ((unsigned long )imgText == (unsigned long )((void *)0)) {
    {
#line 135
    tmp = RemoveVariable(task->varstore, (char const   *)(altName));
    }
#line 135
    if (tmp == 1U) {
      {
#line 137
      HtpMsg((uint )0, task->infile, "ALT text for image \"%s\" removed", imgName);
      }
    } else {
      {
#line 142
      HtpMsg((uint )1, task->infile, "attempted to delete image text not already defined");
      }
    }
#line 145
    return ((uint )2);
  }
  {
#line 148
  altNameCopy = DuplicateString((char const   *)(altName));
  }
#line 148
  if ((unsigned long )altNameCopy == (unsigned long )((void *)0)) {
#line 148
    goto _L;
  } else {
    {
#line 148
    imgTextCopy = DuplicateString(imgText);
    }
#line 148
    if ((unsigned long )imgTextCopy == (unsigned long )((void *)0)) {
      _L: /* CIL Label */ 
      {
#line 150
      HtpMsg((uint )2, task->infile, "Can\'t duplicate text, out of Memory.");
      }
#line 152
      if ((unsigned long )altNameCopy != (unsigned long )((void *)0)) {
        {
#line 153
        free((void *)altNameCopy);
        }
      }
#line 154
      return ((uint )-1);
    }
  }
  {
#line 157
  StoreVariable(task->varstore, (char const   *)altNameCopy, (void *)imgTextCopy,
                (uint )4, (uint )6, (void *)0, (void (*)(char const   *name , void *value ,
                                                         uint type , uint flag , void *param ))((void *)0));
#line 162
  HtpMsg((uint )0, task->infile, "ALT text for image \"%s\" set to \"%s\"", imgName,
         imgText);
  }
#line 165
  return ((uint )2);
}
}
#line 168 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/image-proc.c"
uint ImageUrlProcessor(TASK *task , HTML_MARKUP *htmlMarkup , char **newPlaintext ) 
{ 
  char const   *url ;
  char const   *path ;
  char *pathCopy ;
  BOOL tmp ;

  {
  {
#line 173
  newPlaintext = newPlaintext;
#line 176
  url = MarkupAttributeValue(htmlMarkup, "URL");
  }
#line 179
  if ((unsigned long )url == (unsigned long )((void *)0)) {
    {
#line 181
    HtpMsg((uint )2, task->infile, "IMAGEURL requires a nonempty URL attribute");
    }
#line 183
    return ((uint )-1);
  }
  {
#line 185
  path = MarkupAttributeValue(htmlMarkup, "PATH");
  }
#line 188
  if ((unsigned long )path == (unsigned long )((void *)0)) {
    {
#line 190
    tmp = RemoveImageUrl(url);
    }
#line 190
    if (tmp) {
      {
#line 191
      HtpMsg((uint )0, task->infile, "path for image URL \"%s\" removed", url);
      }
    } else {
      {
#line 196
      HtpMsg((uint )1, task->infile, "attempted to delete URL path not already defined");
      }
    }
#line 199
    return ((uint )2);
  }
  {
#line 202
  pathCopy = ConvertDirDelimiter(path);
  }
#line 202
  if ((unsigned long )pathCopy == (unsigned long )((void *)0)) {
    {
#line 203
    HtpMsg((uint )2, task->infile, "Can\'t duplicate path, out of Memory.");
    }
#line 205
    return ((uint )-1);
  }
  {
#line 208
  StoreImageUrl(url, pathCopy);
#line 210
  HtpMsg((uint )0, task->infile, "path for URL \"%s\" set to \"%s\"", url, path);
  }
#line 213
  return ((uint )2);
}
}
#line 63 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/streams.h"
void ForceLinefeeds(STREAM *stream , BOOL forced ) ;
#line 19 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/misc-proc.c"
uint HeadProcessor(TASK *task , HTML_MARKUP *htmlMarkup , char **newPlaintext ) 
{ 


  {
  {
#line 21
  htmlMarkup = htmlMarkup;
#line 22
  newPlaintext = newPlaintext;
#line 26
  StreamPrintF(task->outfile, "<meta name=\"Generator\" content=\"%s %s\"", "htp",
               "1.16");
  }
#line 29
  if (*(currentOptions + 7) == 1U) {
    {
#line 30
    StreamPrintF(task->outfile, " />\n");
    }
  } else {
    {
#line 32
    StreamPrintF(task->outfile, ">\n");
    }
  }
#line 34
  return ((uint )0);
}
}
#line 38 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/misc-proc.c"
uint HtpCommentProcessor(TASK *task , HTML_MARKUP *htmlMarkup , char **newPlaintext ) 
{ 


  {
#line 40
  task = task;
#line 41
  htmlMarkup = htmlMarkup;
#line 42
  newPlaintext = newPlaintext;
#line 44
  return ((uint )2);
}
}
#line 47 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/misc-proc.c"
uint QuoteProcessor(TASK *task , HTML_MARKUP *htmlMarkup , char **newPlaintext ) 
{ 
  HTML_ATTRIBUTE *attrib ;

  {
#line 50
  task = task;
#line 51
  newPlaintext = newPlaintext;
#line 53
  attrib = htmlMarkup->attrib;
#line 54
  if ((unsigned long )attrib == (unsigned long )((void *)0)) {
    {
#line 55
    HtpMsg((uint )2, task->infile, "improper QUOTE syntax");
    }
#line 56
    return ((uint )-1);
  } else
#line 54
  if ((unsigned long )attrib->value != (unsigned long )((void *)0)) {
    {
#line 55
    HtpMsg((uint )2, task->infile, "improper QUOTE syntax");
    }
#line 56
    return ((uint )-1);
  }
  {
#line 58
  free((void *)htmlMarkup->tag);
  }
#line 59
  if (htmlMarkup->whitespace) {
    {
#line 60
    free((void *)htmlMarkup->whitespace);
    }
  }
  {
#line 61
  htmlMarkup->tag = attrib->name;
#line 62
  htmlMarkup->whitespace = attrib->whitespace;
#line 63
  htmlMarkup->attrib = attrib->next;
#line 64
  free((void *)attrib);
  }
#line 66
  return ((uint )0);
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/misc-proc.c"
uint ConditionalWarning(TASK *task , HTML_MARKUP *htmlMarkup , char **newPlaintext ) 
{ 


  {
  {
#line 73
  htmlMarkup = htmlMarkup;
#line 74
  newPlaintext = newPlaintext;
#line 76
  HtpMsg((uint )2, task->infile, "IFNOT tag no longer recognized; use IF NOT instead");
  }
#line 77
  return ((uint )-1);
}
}
#line 82 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/misc-proc.c"
uint PreProcessor(TASK *task , HTML_MARKUP *htmlMarkup , char **newPlaintext ) 
{ 
  BOOL tmp ;
  BOOL tmp___0 ;

  {
  {
#line 84
  htmlMarkup = htmlMarkup;
#line 85
  newPlaintext = newPlaintext;
#line 88
  tmp___0 = IsMarkupTag(htmlMarkup, "PRE");
  }
#line 88
  if (tmp___0) {
    {
#line 90
    ForceLinefeeds(task->outfile, (BOOL )1);
    }
  } else {
    {
#line 92
    tmp = IsMarkupTag(htmlMarkup, "/PRE");
    }
#line 92
    if (tmp) {
      {
#line 94
      ForceLinefeeds(task->outfile, (BOOL )0);
      }
    }
  }
#line 96
  return ((uint )0);
}
}
#line 828 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 15 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/streams.c"
BOOL CreateNullWriter(STREAM *stream ) 
{ 


  {
#line 16
  stream->sflags = (uint )2;
#line 17
  stream->name = "NULL";
#line 18
  stream->lineNumber = (uint )1;
#line 19
  return ((BOOL )1);
}
}
#line 22 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/streams.c"
BOOL CreateBufferWriter(STREAM *stream , char const   *name ) 
{ 
  void *tmp ;

  {
  {
#line 23
  stream->sflags = (uint )1;
#line 24
  stream->u.buffer.length = (ulong )128;
#line 25
  tmp = malloc(stream->u.buffer.length);
#line 25
  stream->u.buffer.buffer = (char *)tmp;
#line 26
  stream->u.buffer.offset = (ulong )0;
  }
#line 28
  if ((unsigned long )stream->u.buffer.buffer == (unsigned long )((void *)0)) {
    {
#line 30
    HtpMsg((uint )2, (STREAM *)((void *)0), "unable to allocate stream buffer");
    }
#line 31
    return ((BOOL )0);
  }
#line 33
  return ((BOOL )1);
}
}
#line 36 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/streams.c"
BOOL CreateBufferReader(STREAM *stream , STREAM *writeStream ) 
{ 


  {
#line 38
  if (writeStream->sflags != 1U) {
    {
#line 40
    HtpMsg((uint )2, (STREAM *)((void *)0), "CreateBufferReader: wrong buffer type");
    }
#line 41
    return ((BOOL )0);
  }
#line 43
  stream->sflags = (uint )5;
#line 44
  stream->name = writeStream->name;
#line 45
  stream->lineNumber = writeStream->lineNumber;
#line 46
  stream->u.buffer.length = writeStream->u.buffer.offset;
#line 47
  stream->u.buffer.buffer = writeStream->u.buffer.buffer;
#line 48
  stream->u.buffer.offset = (ulong )0;
#line 49
  stream->hasUnread = (BOOL )0;
#line 50
  return ((BOOL )1);
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/streams.c"
BOOL FlushBufferWriter(STREAM *stream ) 
{ 
  char *str ;
  void *tmp ;

  {
#line 56
  if (stream->sflags != 1U) {
    {
#line 58
    HtpMsg((uint )2, (STREAM *)((void *)0), "CreateBufferReader: wrong buffer type");
    }
#line 59
    return ((BOOL )0);
  }
  {
#line 61
  tmp = malloc(stream->u.buffer.offset + 1UL);
#line 61
  str = (char *)tmp;
#line 62
  memcpy((void */* __restrict  */)str, (void const   */* __restrict  */)stream->u.buffer.buffer,
         stream->u.buffer.offset);
#line 63
  *(str + stream->u.buffer.offset) = (char)0;
#line 64
  free((void *)stream->u.buffer.buffer);
#line 65
  stream->u.buffer.buffer = str;
  }
#line 66
  return ((BOOL )1);
}
}
#line 69 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/streams.c"
BOOL CreateFileReader(STREAM *stream , char const   *filename ) 
{ 
  BOOL tmp ;

  {
  {
#line 71
  stream->sflags = (uint )4;
#line 72
  stream->name = filename;
#line 73
  stream->lineNumber = (uint )1;
#line 74
  stream->hasUnread = (BOOL )0;
#line 75
  tmp = OpenFile(filename, "r", & stream->u.textfile);
  }
#line 75
  return (tmp);
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/streams.c"
BOOL CreateFDReader(STREAM *stream , char const   *filename , int filedes ) 
{ 
  BOOL tmp ;

  {
  {
#line 80
  stream->sflags = (uint )4;
#line 81
  stream->name = filename;
#line 82
  stream->lineNumber = (uint )1;
#line 83
  stream->hasUnread = (BOOL )0;
#line 84
  tmp = OpenFD(filedes, "r", & stream->u.textfile);
  }
#line 84
  return (tmp);
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/streams.c"
BOOL CreateFileWriter(STREAM *stream , char const   *filename , BOOL append ) 
{ 
  char const   *tmp ;
  BOOL tmp___0 ;

  {
#line 89
  stream->sflags = (uint )0;
#line 90
  stream->name = filename;
#line 91
  stream->lineNumber = (uint )1;
#line 92
  if (append) {
#line 92
    tmp = "a";
  } else {
#line 92
    tmp = "w";
  }
  {
#line 92
  tmp___0 = OpenFile(filename, tmp, & stream->u.textfile);
  }
#line 92
  return (tmp___0);
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/streams.c"
void CloseStream(STREAM *stream ) 
{ 


  {
#line 97
  if (stream->sflags & 1U) {
#line 98
    if (! (stream->sflags & 4U)) {
      {
#line 99
      free((void *)stream->u.buffer.buffer);
#line 100
      free((void *)stream->name);
      }
    }
  } else
#line 102
  if (! (stream->sflags & 2U)) {
    {
#line 105
    CloseFile(& stream->u.textfile);
    }
  }
#line 107
  return;
}
}
#line 110 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/streams.c"
BOOL GetStreamChar(STREAM *stream , char *c ) 
{ 
  ulong tmp ;
  BOOL result ;
  BOOL tmp___0 ;

  {
#line 116
  if (stream->hasUnread) {
#line 118
    *c = stream->unread;
#line 119
    stream->hasUnread = (BOOL )0;
#line 120
    return ((BOOL )1);
  }
#line 123
  if (stream->sflags & 1U) {
#line 126
    if (stream->u.buffer.length <= stream->u.buffer.offset) {
#line 127
      return ((BOOL )0);
    }
#line 129
    tmp = stream->u.buffer.offset;
#line 129
    (stream->u.buffer.offset) ++;
#line 129
    *c = *(stream->u.buffer.buffer + tmp);
#line 130
    if ((int )*c == 10) {
#line 131
      (stream->lineNumber) ++;
    }
#line 132
    return ((BOOL )1);
  } else {
    {
#line 135
    tmp___0 = GetFileChar(& stream->u.textfile, c);
#line 135
    result = tmp___0;
    }
#line 136
    if ((int )*c == 10) {
#line 137
      (stream->lineNumber) ++;
    }
#line 138
    return (result);
  }
}
}
#line 142 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/streams.c"
BOOL UnreadStreamChar(STREAM *stream , char c ) 
{ 


  {
#line 149
  stream->hasUnread = (BOOL )1;
#line 150
  stream->unread = c;
#line 151
  return ((BOOL )1);
}
}
#line 154 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/streams.c"
unsigned int GetStreamBlock(STREAM *stream , char *buffer , uint size , char *delim ) 
{ 
  char *ptr ;
  char ch ;
  int read___0 ;
  char *tmp ;
  char *end ;
  char *start ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  BOOL tmp___3 ;
  uint tmp___4 ;

  {
#line 157
  read___0 = 0;
#line 163
  if (stream->hasUnread) {
#line 165
    tmp = buffer;
#line 165
    buffer ++;
#line 165
    ch = stream->unread;
#line 165
    *tmp = ch;
#line 166
    size --;
#line 167
    stream->hasUnread = (BOOL )0;
#line 168
    if ((int )ch == (int )*(delim + 0)) {
#line 170
      return (1U);
    } else
#line 168
    if ((int )ch == (int )*(delim + 1)) {
#line 170
      return (1U);
    }
#line 171
    read___0 = 1;
  }
#line 174
  if (stream->sflags & 1U) {
#line 176
    end = stream->u.buffer.buffer + stream->u.buffer.length;
#line 177
    start = stream->u.buffer.buffer + stream->u.buffer.offset;
#line 180
    if ((unsigned long )start >= (unsigned long )end) {
#line 181
      return (0U);
    }
#line 185
    size --;
#line 186
    if ((unsigned long )(start + size) < (unsigned long )end) {
#line 187
      end = start + size;
    }
#line 190
    ptr = start;
    {
#line 191
    while (1) {
      while_continue: /* CIL Label */ ;
#line 191
      if (! ((unsigned long )ptr < (unsigned long )end)) {
#line 191
        goto while_break;
      }
#line 193
      tmp___0 = buffer;
#line 193
      buffer ++;
#line 193
      tmp___1 = ptr;
#line 193
      ptr ++;
#line 193
      ch = *tmp___1;
#line 193
      *tmp___0 = ch;
#line 194
      if ((int )ch == 10) {
#line 195
        (stream->lineNumber) ++;
      }
#line 196
      if ((int )ch == (int )*(delim + 0)) {
#line 199
        goto while_break;
      } else
#line 196
      if ((int )ch == (int )*(delim + 1)) {
#line 199
        goto while_break;
      } else
#line 196
      if ((int )ch == (int )*(delim + 2)) {
#line 199
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 201
    *buffer = (char)0;
#line 202
    stream->u.buffer.offset += (ulong )(ptr - start);
#line 203
    return ((unsigned int )((ptr + read___0) - start));
  } else {
    {
#line 207
    tmp___2 = feof(stream->u.textfile.file);
    }
#line 207
    if (tmp___2) {
#line 208
      return (0U);
    }
#line 210
    ptr = buffer;
    {
#line 213
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 213
      tmp___4 = size;
#line 213
      size --;
#line 213
      if (! (tmp___4 > 1U)) {
#line 213
        goto while_break___0;
      }
      {
#line 215
      tmp___3 = GetFileChar(& stream->u.textfile, ptr);
      }
#line 215
      if (tmp___3 == 0U) {
#line 217
        goto while_break___0;
      }
#line 219
      ch = *ptr;
#line 221
      if ((int )ch == 10) {
#line 223
        (stream->lineNumber) ++;
      }
#line 226
      ptr ++;
#line 227
      if ((int )ch == (int )*(delim + 0)) {
#line 230
        goto while_break___0;
      } else
#line 227
      if ((int )ch == (int )*(delim + 1)) {
#line 230
        goto while_break___0;
      } else
#line 227
      if ((int )ch == (int )*(delim + 2)) {
#line 230
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 232
    *ptr = (char)0;
#line 233
    return ((unsigned int )((ptr + read___0) - buffer));
  }
}
}
#line 237 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/streams.c"
BOOL PutStreamString(STREAM *stream , char const   *str ) 
{ 
  ulong len ;
  size_t tmp ;
  ulong free___0 ;
  char *newbuffer ;
  void *tmp___0 ;
  BOOL tmp___1 ;

  {
#line 242
  if (stream->sflags & 1U) {
    {
#line 244
    tmp = strlen(str);
#line 244
    len = tmp;
#line 245
    free___0 = stream->u.buffer.length - stream->u.buffer.offset;
    }
#line 247
    if (len > free___0) {
      {
#line 249
      while (1) {
        while_continue: /* CIL Label */ ;
#line 249
        if (! (len > free___0)) {
#line 249
          goto while_break;
        }
#line 250
        free___0 += stream->u.buffer.length;
#line 251
        stream->u.buffer.length *= 2UL;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 253
      tmp___0 = realloc((void *)stream->u.buffer.buffer, stream->u.buffer.length);
#line 253
      newbuffer = (char *)tmp___0;
      }
#line 255
      if ((unsigned long )newbuffer == (unsigned long )((void *)0)) {
        {
#line 257
        HtpMsg((uint )2, (STREAM *)((void *)0), "unable to grow stream buffers");
        }
#line 258
        return ((BOOL )0);
      }
#line 260
      stream->u.buffer.buffer = newbuffer;
    }
    {
#line 262
    memcpy((void */* __restrict  */)(stream->u.buffer.buffer + stream->u.buffer.offset),
           (void const   */* __restrict  */)str, len);
#line 263
    stream->u.buffer.offset += len;
    }
#line 264
    return ((BOOL )1);
  } else
#line 265
  if (stream->sflags & 2U) {
#line 266
    return ((BOOL )1);
  } else {
    {
#line 268
    tmp___1 = PutFileString(& stream->u.textfile, str);
    }
#line 268
    return (tmp___1);
  }
}
}
#line 272 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/streams.c"
BOOL StreamPrintF(STREAM *stream , char const   *format  , ...) 
{ 
  va_list argptr ;
  char buffer[4096L] ;
  char *str ;
  int len ;
  void *tmp ;
  BOOL tmp___0 ;

  {
  {
#line 278
  str = buffer;
#line 283
  __builtin_va_start(argptr, format);
#line 284
  len = vsnprintf((char */* __restrict  */)str, sizeof(buffer), (char const   */* __restrict  */)format,
                  argptr);
#line 285
  __builtin_va_end(argptr);
  }
#line 287
  if ((unsigned long )len > sizeof(buffer) - 1UL) {
    {
#line 288
    tmp = malloc((size_t )(len + 1));
#line 288
    str = (char *)tmp;
#line 289
    __builtin_va_start(argptr, format);
#line 290
    len = vsnprintf((char */* __restrict  */)str, (size_t )(len + 1), (char const   */* __restrict  */)format,
                    argptr);
#line 291
    __builtin_va_end(argptr);
    }
  }
  {
#line 294
  tmp___0 = PutStreamString(stream, (char const   *)str);
#line 294
  len = (int )tmp___0;
  }
#line 296
  if ((unsigned long )str != (unsigned long )(buffer)) {
    {
#line 297
    free((void *)str);
    }
  }
#line 299
  return ((BOOL )len);
}
}
#line 303 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/streams.c"
void ForceLinefeeds(STREAM *stream , BOOL forced ) 
{ 


  {
#line 305
  if (! (stream->sflags & 3U)) {
#line 307
    if (forced) {
#line 308
      stream->u.textfile.flags = (WORD )((int )stream->u.textfile.flags | 2);
    } else {
#line 310
      stream->u.textfile.flags = (WORD )((int )stream->u.textfile.flags & -3);
    }
  }
#line 312
  return;
}
}
#line 519 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atexit)(void (*__func)(void) ) ;
#line 25 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/htp-files.c"
BOOL HtpDefaultFilename(char *filename , uint size ) 
{ 
  char *defFile ;
  BOOL tmp ;

  {
  {
#line 31
  defFile = getenv("HTPDEF");
  }
#line 31
  if ((unsigned long )defFile == (unsigned long )((void *)0)) {
#line 33
    return ((BOOL )0);
  }
  {
#line 37
  tmp = FileExists((char const   *)defFile);
  }
#line 37
  if (tmp == 0U) {
#line 39
    return ((BOOL )0);
  }
  {
#line 43
  StringCopy(filename, (char const   *)defFile, size);
  }
#line 45
  return ((BOOL )1);
}
}
#line 57 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/htp-files.c"
BOOL IsTargetUpdated(char const   *dependency , char const   *target ) 
{ 
  struct stat dependStat ;
  struct stat targetStat ;
  char *dependName ;
  char *targetName ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 68
  if ((*(currentOptions + 2) == 1U) == 0) {
#line 70
    return ((BOOL )0);
  }
  {
#line 74
  dependName = ConvertDirDelimiter(dependency);
  }
#line 74
  if ((unsigned long )dependName == (unsigned long )((void *)0)) {
#line 76
    return ((uint )-1);
  }
  {
#line 79
  targetName = ConvertDirDelimiter(target);
  }
#line 79
  if ((unsigned long )targetName == (unsigned long )((void *)0)) {
    {
#line 81
    free((void *)dependName);
    }
#line 82
    return ((uint )-1);
  }
  {
#line 86
  tmp = stat((char const   */* __restrict  */)dependName, (struct stat */* __restrict  */)(& dependStat));
  }
#line 86
  if (tmp != 0) {
    {
#line 89
    free((void *)dependName);
#line 90
    free((void *)targetName);
    }
#line 92
    return ((uint )-1);
  }
  {
#line 96
  tmp___0 = stat((char const   */* __restrict  */)targetName, (struct stat */* __restrict  */)(& targetStat));
  }
#line 96
  if (tmp___0 != 0) {
    {
#line 99
    free((void *)dependName);
#line 100
    free((void *)targetName);
    }
#line 102
    return ((BOOL )0);
  }
  {
#line 105
  free((void *)dependName);
#line 106
  free((void *)targetName);
  }
#line 109
  if (dependStat.st_mtim.tv_sec <= targetStat.st_mtim.tv_sec) {
#line 109
    tmp___1 = 1;
  } else {
#line 109
    tmp___1 = 0;
  }
#line 109
  return ((BOOL )tmp___1);
}
}
#line 117 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/htp-files.c"
BOOL SearchForFile(char const   *filename , char *fullPathname , uint size ) 
{ 
  char *searchPathCopy ;
  char *ptr ;
  char *convertedName ;
  FIND_TOKEN findToken ;
  size_t tmp ;
  char *tmp___0 ;
  BOOL tmp___1 ;

  {
#line 125
  if ((int )searchPath[0] == 0) {
#line 127
    return ((BOOL )0);
  }
  {
#line 131
  searchPathCopy = DuplicateString((char const   *)(searchPath));
  }
#line 131
  if ((unsigned long )searchPathCopy == (unsigned long )((void *)0)) {
    {
#line 133
    printf((char const   */* __restrict  */)"%s: unable to allocate temporary buffer for include path (out of memory?)\n",
           "htp");
    }
#line 135
    return ((BOOL )0);
  }
  {
#line 139
  ptr = StringFirstToken(& findToken, searchPathCopy, ";");
  }
  {
#line 140
  while (1) {
    while_continue: /* CIL Label */ ;
#line 140
    if (! ((unsigned long )ptr != (unsigned long )((void *)0))) {
#line 140
      goto while_break;
    }
    {
#line 142
    StringCopy(fullPathname, (char const   *)ptr, size);
#line 145
    tmp = strlen((char const   *)fullPathname);
#line 145
    tmp___0 = strchr("/\\", (int )*(fullPathname + (tmp - 1UL)));
    }
#line 145
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
      {
#line 147
      strncat((char */* __restrict  */)fullPathname, (char const   */* __restrict  */)"/",
              (size_t )size);
      }
    }
    {
#line 151
    strncat((char */* __restrict  */)fullPathname, (char const   */* __restrict  */)filename,
            (size_t )size);
#line 155
    convertedName = ConvertDirDelimiter((char const   *)fullPathname);
#line 158
    tmp___1 = FileExists((char const   *)convertedName);
    }
#line 158
    if (tmp___1 == 1U) {
      {
#line 161
      StringCopy(fullPathname, (char const   *)convertedName, size);
#line 163
      free((void *)searchPathCopy);
#line 164
      free((void *)convertedName);
      }
#line 166
      return ((BOOL )1);
    }
    {
#line 169
    free((void *)convertedName);
#line 170
    convertedName = (char *)((void *)0);
#line 172
    ptr = StringNextToken(& findToken);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 176
  free((void *)searchPathCopy);
  }
#line 178
  return ((BOOL )0);
}
}
#line 181 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/htp-files.c"
static char *markupBuffer  =    (char *)((void *)0);
#line 182 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/htp-files.c"
static uint markupSize  =    (uint )0;
#line 184 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/htp-files.c"
static void FreeMarkupBuffer(void) 
{ 


  {
  {
#line 185
  free((void *)markupBuffer);
#line 186
  markupBuffer = (char *)((void *)0);
  }
#line 187
  return;
}
}
#line 194 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/htp-files.c"
BOOL ReadHtmlMarkup(STREAM *infile , STREAM *outfile , uint *markupType , HTML_MARKUP *htmlMarkup ) 
{ 
  char ch ;
  uint ctr ;
  char inQuotes ;
  uint startLine ;
  uint numread ;
  char open_markup[3] ;
  char tag_specials[3] ;
  void *tmp ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  uint tmp___5 ;
  char *newmarkupBuffer ;
  void *tmp___6 ;
  BOOL tmp___7 ;

  {
#line 205
  open_markup[0] = (char )'<';
#line 206
  open_markup[1] = htpOpenMarkup;
#line 207
  open_markup[2] = htpOpenMarkup;
#line 209
  tag_specials[1] = (char )'\"';
#line 210
  tag_specials[2] = (char )'\'';
#line 230
  if ((unsigned long )markupBuffer == (unsigned long )((void *)0)) {
    {
#line 232
    tmp = malloc((size_t )2048);
#line 232
    markupBuffer = (char *)tmp;
    }
#line 232
    if ((unsigned long )markupBuffer == (unsigned long )((void *)0)) {
      {
#line 234
      HtpMsg((uint )2, (STREAM *)((void *)0), "unable to allocate memory to read HTML file");
      }
#line 236
      return ((uint )-1);
    }
    {
#line 239
    markupSize = (uint )2048;
#line 240
    atexit(& FreeMarkupBuffer);
    }
  }
  {
#line 243
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 245
    numread = GetStreamBlock(infile, markupBuffer, markupSize, (char *)(open_markup));
    }
#line 247
    if (numread == 0U) {
#line 252
      return ((BOOL )0);
    }
#line 255
    if ((int )*(markupBuffer + (numread - 1U)) == 60) {
#line 255
      goto _L;
    } else
#line 255
    if ((int )*(markupBuffer + (numread - 1U)) == (int )htpOpenMarkup) {
      _L: /* CIL Label */ 
      {
#line 258
      *markupType = MarkupType(*(markupBuffer + (numread - 1U)));
      }
#line 259
      if (numread > 1U) {
#line 259
        if ((unsigned long )outfile != (unsigned long )((void *)0)) {
          {
#line 261
          *(markupBuffer + (numread - 1U)) = (char)0;
#line 262
          StreamPrintF(outfile, "%s", markupBuffer);
          }
        }
      }
#line 264
      goto while_break;
    }
#line 270
    if ((unsigned long )outfile != (unsigned long )((void *)0)) {
      {
#line 271
      StreamPrintF(outfile, "%s", markupBuffer);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 276
  ctr = (uint )0;
#line 277
  inQuotes = (char)0;
#line 278
  startLine = infile->lineNumber;
#line 279
  if (*markupType & 2U) {
#line 279
    tag_specials[0] = htpCloseMarkup;
  } else {
#line 279
    tag_specials[0] = (char )'>';
  }
  {
#line 280
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 282
    numread = GetStreamBlock(infile, markupBuffer + ctr, markupSize - ctr, (char *)(tag_specials));
    }
#line 284
    if (numread == 0U) {
      {
#line 288
      infile->lineNumber = startLine;
#line 289
      HtpMsg((uint )2, infile, "markup tag is never closed", startLine);
      }
#line 292
      return ((uint )-1);
    }
#line 295
    ctr += numread;
#line 296
    ch = *(markupBuffer + (ctr - 1U));
#line 297
    if ((int )ch == 62) {
#line 297
      goto _L___0;
    } else
#line 297
    if ((int )ch == (int )htpCloseMarkup) {
      _L___0: /* CIL Label */ 
      {
#line 297
      tmp___5 = MarkupType(ch);
      }
#line 297
      if (tmp___5 == *markupType) {
        {
#line 303
        tmp___4 = strncmp((char const   *)markupBuffer, "!--", (size_t )3);
        }
#line 303
        if (tmp___4 == 0) {
          {
#line 303
          tmp___1 = strncmp((char const   *)((markupBuffer + ctr) - 3), "--", (size_t )2);
#line 303
          tmp___3 = tmp___1 == 0;
          }
        } else {
#line 303
          if ((int )*(markupBuffer + 0) == 63) {
#line 303
            tmp___2 = (int )*(markupBuffer + (ctr - 2U)) == 63;
          } else {
#line 303
            tmp___2 = (int )inQuotes == 0;
          }
#line 303
          tmp___3 = tmp___2;
        }
#line 303
        if (tmp___3) {
#line 313
          *(markupBuffer + (ctr - 1U)) = (char)0;
#line 314
          goto while_break___0;
        }
      }
    }
#line 320
    if (inQuotes) {
#line 322
      if ((int )ch == (int )inQuotes) {
#line 323
        inQuotes = (char)0;
      }
    } else
#line 325
    if ((int )ch == 39) {
#line 327
      inQuotes = ch;
    } else
#line 325
    if ((int )ch == 34) {
#line 327
      inQuotes = ch;
    }
#line 331
    if (ctr >= markupSize - 1U) {
      {
#line 333
      tmp___6 = realloc((void *)markupBuffer, (size_t )(markupSize + 2048U));
#line 333
      newmarkupBuffer = (char *)tmp___6;
      }
#line 335
      if ((unsigned long )newmarkupBuffer == (unsigned long )((void *)0)) {
        {
#line 338
        HtpMsg((uint )2, (STREAM *)((void *)0), "unable to reallocate memory for reading HTML file");
        }
#line 340
        return ((uint )-1);
      }
#line 343
      markupBuffer = newmarkupBuffer;
#line 344
      markupSize += 2048U;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 348
  tmp___7 = PlaintextToMarkup((char const   *)markupBuffer, htmlMarkup);
  }
#line 348
  if (tmp___7 == 0U) {
    {
#line 350
    HtpMsg((uint )2, infile, "could not parse markup tag (out of memory?)");
    }
#line 352
    return ((uint )-1);
  }
#line 355
  return ((BOOL )1);
}
}
#line 358 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/htp-files.c"
BOOL FullyCheckDependencies(char const   *in , char const   *out ) 
{ 
  BOOL result ;
  STREAM infile ;
  char title[128] ;
  HTML_MARKUP markup ;
  char const   *includeFile ;
  char const   *imageFile ;
  BOOL readResult ;
  BOOL checkResult ;
  uint markupType ;
  BOOL tmp ;
  char const   *tmp___0 ;
  BOOL tmp___1 ;
  BOOL tmp___2 ;
  BOOL tmp___3 ;
  BOOL tmp___4 ;
  BOOL tmp___5 ;

  {
#line 373
  if ((*(currentOptions + 2) == 1U) == 0) {
#line 376
    return ((BOOL )0);
  }
  {
#line 380
  result = IsTargetUpdated(in, out);
  }
#line 381
  if (result == 4294967295U) {
    {
#line 383
    printf((char const   */* __restrict  */)"%s: unable to get file information for file \"%s\"\n",
           "htp", in);
    }
#line 385
    return ((uint )-1);
  } else
#line 387
  if (result == 0U) {
#line 390
    return ((BOOL )0);
  }
  {
#line 397
  snprintf((char */* __restrict  */)(title), (size_t )128, (char const   */* __restrict  */)"Dependency check for %s",
           in);
#line 398
  tmp = CreateFileReader(& infile, in);
  }
#line 398
  if (tmp == 0U) {
    {
#line 400
    printf((char const   */* __restrict  */)"%s: unable to open file \"%s\" for reading while checking dependencies\n",
           "htp", in);
    }
#line 402
    return ((uint )-1);
  }
#line 404
  infile.name = (char const   *)(title);
#line 407
  checkResult = (BOOL )1;
  {
#line 410
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 410
    readResult = ReadHtmlMarkup(& infile, (STREAM *)((void *)0), & markupType, & markup);
    }
#line 410
    if (! (readResult != 0U)) {
#line 410
      goto while_break;
    }
#line 413
    if (readResult == 4294967295U) {
#line 416
      checkResult = (uint )-1;
#line 417
      goto while_break;
    }
#line 421
    if ((markupType & 2U) == 0U) {
      {
#line 423
      DestroyMarkupStruct(& markup);
      }
#line 424
      goto while_continue;
    }
    {
#line 428
    includeFile = (char const   *)((void *)0);
#line 429
    imageFile = (char const   *)((void *)0);
#line 430
    tmp___4 = IsMarkupTag(& markup, "FILE");
    }
#line 430
    if (tmp___4) {
      {
#line 432
      tmp___0 = MarkupAttributeValue(& markup, "EXECUTE");
      }
#line 432
      if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
        {
#line 436
        result = (BOOL )0;
#line 437
        DestroyMarkupStruct(& markup);
        }
#line 438
        goto while_break;
      }
      {
#line 440
      includeFile = MarkupAttributeValue(& markup, "INCLUDE");
      }
#line 441
      if ((unsigned long )includeFile == (unsigned long )((void *)0)) {
        {
#line 443
        includeFile = MarkupAttributeValue(& markup, "TEMPLATE");
        }
      }
    } else {
      {
#line 446
      tmp___3 = IsMarkupTag(& markup, "IMG");
      }
#line 446
      if (tmp___3) {
        {
#line 448
        imageFile = MarkupAttributeValue(& markup, "SRC");
        }
      } else {
        {
#line 450
        tmp___2 = IsMarkupTag(& markup, "OPT");
        }
#line 450
        if (tmp___2) {
          {
#line 452
          tmp___1 = UnlinkBoolAttributeInMarkup(& markup, "NODEPEND");
          }
#line 452
          if (tmp___1) {
            {
#line 460
            checkResult = (BOOL )0;
#line 461
            DestroyMarkupStruct(& markup);
            }
#line 462
            goto while_break;
          }
        }
      }
    }
#line 468
    result = (BOOL )1;
#line 471
    if ((unsigned long )includeFile != (unsigned long )((void *)0)) {
      {
#line 475
      result = FullyCheckDependencies(includeFile, out);
      }
    } else
#line 477
    if ((unsigned long )imageFile != (unsigned long )((void *)0)) {
      {
#line 480
      tmp___5 = FileExists(imageFile);
      }
#line 480
      if (tmp___5) {
        {
#line 482
        result = IsTargetUpdated(imageFile, out);
        }
      }
    }
    {
#line 487
    DestroyMarkupStruct(& markup);
    }
#line 489
    if (result != 1U) {
#line 493
      checkResult = result;
#line 494
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 502
  CloseStream(& infile);
  }
#line 504
  return (checkResult);
}
}
#line 133 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/snprintf.c"
void dummy_snprintf(void) ;
#line 134 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/snprintf.c"
void dummy_snprintf(void) 
{ 


  {
#line 134
  return;
}
}
#line 21 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/while-proc.c"
BOOL ConditionValue(TASK *task , HTML_ATTRIBUTE *attrib , BOOL notTagFound ) 
{ 
  char *name ;
  int quotes ;
  BOOL changed ;
  BOOL condTrue ;
  char const   *value ;
  char *attribValue ;
  uint type ;
  BOOL tmp ;
  void *tmp___0 ;
  BOOL tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 31
  tmp = ExpandMacrosInString(task, (char const   *)attrib->name, & name, & quotes,
                             & changed);
  }
#line 31
  if (! tmp) {
#line 33
    return ((uint )-1);
  }
  {
#line 36
  HtpMsg((uint )0, task->infile, "while loop check %s", name);
#line 38
  tmp___0 = GetVariableValue(task->varstore, (char const   *)name);
#line 38
  value = (char const   *)tmp___0;
  }
#line 38
  if ((unsigned long )value != (unsigned long )((void *)0)) {
    {
#line 40
    type = GetVariableType(task->varstore, (char const   *)name);
    }
  } else {
#line 44
    type = (uint )1;
  }
#line 47
  if (changed) {
    {
#line 48
    free((void *)name);
    }
  }
#line 51
  if ((unsigned long )attrib->value == (unsigned long )((void *)0)) {
#line 53
    if ((unsigned long )value != (unsigned long )((void *)0)) {
#line 53
      condTrue = (BOOL )1;
    } else {
#line 53
      condTrue = (BOOL )0;
    }
  } else
#line 58
  if (type == 1U) {
    {
#line 61
    tmp___1 = ExpandMacrosInString(task, (char const   *)attrib->value, & attribValue,
                                   & quotes, & changed);
    }
#line 61
    if (! tmp___1) {
#line 64
      return ((uint )-1);
    }
#line 67
    if ((unsigned long )value != (unsigned long )((void *)0)) {
      {
#line 67
      tmp___2 = strcmp(value, (char const   *)attribValue);
      }
#line 67
      if (tmp___2 == 0) {
#line 67
        tmp___3 = 1;
      } else {
#line 67
        tmp___3 = 0;
      }
    } else {
#line 67
      tmp___3 = 0;
    }
#line 67
    condTrue = (BOOL )tmp___3;
#line 69
    if (changed) {
      {
#line 70
      free((void *)attribValue);
      }
    }
  } else {
#line 75
    condTrue = (BOOL )0;
  }
#line 80
  if (notTagFound == 1U) {
#line 82
    if (condTrue == 1U) {
#line 82
      condTrue = (BOOL )0;
    } else {
#line 82
      condTrue = (BOOL )1;
    }
  }
#line 85
  return (condTrue);
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/while-proc.c"
BOOL ProcessWhileBlock(TASK *task , STREAM *blockStream ) 
{ 
  TASK newTask ;
  BOOL result ;

  {
  {
#line 94
  HtpMsg((uint )0, task->infile, "expanding WHILE loop");
#line 97
  newTask.infile = blockStream;
#line 98
  newTask.outfile = task->outfile;
#line 99
  newTask.sourceFilename = task->sourceFilename;
#line 100
  newTask.varstore = task->varstore;
#line 103
  result = ProcessTask(& newTask);
#line 104
  CloseStream(blockStream);
  }
#line 106
  return (result);
}
}
#line 111 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/while-proc.c"
static uint whileLevel  =    (uint )0;
#line 109 "/home/june/repo/benchmarks/collector/temp/htp-1.16/src/while-proc.c"
uint WhileProcessor(TASK *task , HTML_MARKUP *htmlMarkup , char **newPlaintext ) 
{ 
  BOOL condTrue ;
  BOOL notTagFound ;
  STREAM blockFile ;
  STREAM inFile ;
  HTML_ATTRIBUTE *attrib ;
  BOOL tmp ;
  BOOL tmp___0 ;
  BOOL tmp___1 ;
  BOOL tmp___2 ;

  {
#line 118
  newPlaintext = newPlaintext;
#line 120
  condTrue = (BOOL )0;
#line 123
  if (whileLevel == 0U) {
    {
#line 125
    tmp = IsMarkupTag(htmlMarkup, "/WHILE");
    }
#line 125
    if (tmp) {
      {
#line 127
      HtpMsg((uint )2, task->infile, "while block must start with WHILE tag");
      }
#line 128
      return ((uint )-1);
    }
  }
  {
#line 132
  tmp___2 = IsMarkupTag(htmlMarkup, "WHILE");
  }
#line 132
  if (tmp___2) {
    {
#line 134
    whileLevel ++;
#line 138
    notTagFound = UnlinkBoolAttributeInMarkup(htmlMarkup, "NOT");
#line 141
    attrib = htmlMarkup->attrib;
    }
#line 142
    if ((unsigned long )attrib == (unsigned long )((void *)0)) {
      {
#line 144
      HtpMsg((uint )2, task->infile, "no conditional to test");
      }
#line 145
      return ((uint )-1);
    }
#line 148
    if ((unsigned long )attrib->next != (unsigned long )((void *)0)) {
      {
#line 150
      HtpMsg((uint )2, task->infile, "too many items in conditional expression");
      }
#line 151
      return ((uint )-1);
    }
    {
#line 153
    htmlMarkup->attrib = (HTML_ATTRIBUTE *)((void *)0);
#line 155
    condTrue = ConditionValue(task, attrib, notTagFound);
    }
#line 156
    if (condTrue == 4294967295U) {
      {
#line 157
      DestroyAttribute(attrib);
#line 158
      free((void *)attrib);
      }
#line 159
      return ((uint )-1);
    }
    {
#line 162
    tmp___0 = ReadinBlock(task, htmlMarkup, & blockFile);
    }
#line 162
    if (tmp___0 == 0U) {
      {
#line 164
      DestroyAttribute(attrib);
#line 165
      free((void *)attrib);
      }
#line 166
      return ((uint )-1);
    }
    {
#line 169
    while (1) {
      while_continue: /* CIL Label */ ;
#line 169
      if (! condTrue) {
#line 169
        goto while_break;
      }
      {
#line 171
      CreateBufferReader(& inFile, & blockFile);
#line 172
      tmp___1 = ProcessWhileBlock(task, & inFile);
      }
#line 172
      if (! tmp___1) {
        {
#line 173
        CloseStream(& blockFile);
#line 174
        DestroyAttribute(attrib);
#line 175
        free((void *)attrib);
        }
#line 176
        return ((uint )-1);
      }
      {
#line 180
      condTrue = ConditionValue(task, attrib, notTagFound);
      }
#line 181
      if (condTrue == 4294967295U) {
        {
#line 182
        CloseStream(& blockFile);
#line 183
        DestroyAttribute(attrib);
#line 184
        free((void *)attrib);
        }
#line 185
        return ((uint )-1);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 189
    CloseStream(& blockFile);
#line 190
    DestroyAttribute(attrib);
#line 191
    free((void *)attrib);
    }
#line 192
    return ((uint )2);
  } else {
#line 199
    whileLevel --;
  }
#line 202
  return ((uint )2);
}
}
