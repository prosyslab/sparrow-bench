/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 55 "/usr/include/stdint.h"
typedef unsigned long uint64_t;
#line 32 "/usr/include/elf.h"
typedef uint16_t Elf64_Half;
#line 37 "/usr/include/elf.h"
typedef uint32_t Elf64_Word;
#line 43 "/usr/include/elf.h"
typedef uint64_t Elf64_Xword;
#line 48 "/usr/include/elf.h"
typedef uint64_t Elf64_Addr;
#line 52 "/usr/include/elf.h"
typedef uint64_t Elf64_Off;
#line 56 "/usr/include/elf.h"
typedef uint16_t Elf64_Section;
#line 85 "/usr/include/elf.h"
struct __anonstruct_Elf64_Ehdr_39 {
   unsigned char e_ident[16] ;
   Elf64_Half e_type ;
   Elf64_Half e_machine ;
   Elf64_Word e_version ;
   Elf64_Addr e_entry ;
   Elf64_Off e_phoff ;
   Elf64_Off e_shoff ;
   Elf64_Word e_flags ;
   Elf64_Half e_ehsize ;
   Elf64_Half e_phentsize ;
   Elf64_Half e_phnum ;
   Elf64_Half e_shentsize ;
   Elf64_Half e_shnum ;
   Elf64_Half e_shstrndx ;
};
#line 85 "/usr/include/elf.h"
typedef struct __anonstruct_Elf64_Ehdr_39 Elf64_Ehdr;
#line 286 "/usr/include/elf.h"
struct __anonstruct_Elf64_Shdr_41 {
   Elf64_Word sh_name ;
   Elf64_Word sh_type ;
   Elf64_Xword sh_flags ;
   Elf64_Addr sh_addr ;
   Elf64_Off sh_offset ;
   Elf64_Xword sh_size ;
   Elf64_Word sh_link ;
   Elf64_Word sh_info ;
   Elf64_Xword sh_addralign ;
   Elf64_Xword sh_entsize ;
};
#line 286 "/usr/include/elf.h"
typedef struct __anonstruct_Elf64_Shdr_41 Elf64_Shdr;
#line 391 "/usr/include/elf.h"
struct __anonstruct_Elf64_Sym_43 {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Section st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};
#line 391 "/usr/include/elf.h"
typedef struct __anonstruct_Elf64_Sym_43 Elf64_Sym;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 75 "/home/june/repo/benchmarks/collector/temp/elfrc-0.7/elfrc.c"
enum __anonenum_type_96 {
    TEXT = 0,
    BINARY = 1
} ;
#line 75
enum __anonenum_ignore_97 {
    FALSE = 0,
    TRUE = 1
} ;
#line 75 "/home/june/repo/benchmarks/collector/temp/elfrc-0.7/elfrc.c"
struct Resource {
   enum __anonenum_type_96 type ;
   char *symbol ;
   unsigned int symbolSize ;
   char *filename ;
   unsigned int size ;
   enum __anonenum_ignore_97 ignore ;
   unsigned int payloadOffset ;
   unsigned int strtabOffset ;
   struct Resource *next ;
};
#line 622
enum __anonenum_state_98 {
    ReadType = 0,
    ReadSymbol = 1,
    ReadFilename = 2
} ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 374 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rand)(void) ;
#line 376
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srand)(unsigned int __seed ) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 140
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 348
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2), __leaf__)) strtok)(char * __restrict  __s ,
                                                                                               char const   * __restrict  __delim ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 511
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) getcwd)(char *__buf ,
                                                                               size_t __size ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 75 "/home/june/repo/benchmarks/collector/temp/elfrc-0.7/elfrc.c"
struct Resource *resources  =    (struct Resource *)0;
#line 87 "/home/june/repo/benchmarks/collector/temp/elfrc-0.7/elfrc.c"
int verbosity  =    0;
#line 93 "/home/june/repo/benchmarks/collector/temp/elfrc-0.7/elfrc.c"
static char const   commentData[70]  = 
#line 93
  {      (char const   )'C',      (char const   )'r',      (char const   )'e',      (char const   )'a', 
        (char const   )'t',      (char const   )'e',      (char const   )'d',      (char const   )' ', 
        (char const   )'b',      (char const   )'y',      (char const   )' ',      (char const   )'e', 
        (char const   )'l',      (char const   )'f',      (char const   )'r',      (char const   )'c', 
        (char const   )' ',      (char const   )'0',      (char const   )'.',      (char const   )'7', 
        (char const   )' ',      (char const   )'C',      (char const   )'o',      (char const   )'p', 
        (char const   )'y',      (char const   )'r',      (char const   )'i',      (char const   )'g', 
        (char const   )'h',      (char const   )'t',      (char const   )' ',      (char const   )'(', 
        (char const   )'C',      (char const   )')',      (char const   )' ',      (char const   )'2', 
        (char const   )'0',      (char const   )'0',      (char const   )'6',      (char const   )' ', 
        (char const   )'F',      (char const   )'r',      (char const   )'e',      (char const   )'r', 
        (char const   )'i',      (char const   )'c',      (char const   )'h',      (char const   )' ', 
        (char const   )'R',      (char const   )'a',      (char const   )'a',      (char const   )'b', 
        (char const   )'e',      (char const   )' ',      (char const   )'<',      (char const   )'r', 
        (char const   )'a',      (char const   )'a',      (char const   )'b',      (char const   )'e', 
        (char const   )'@',      (char const   )'k',      (char const   )'d',      (char const   )'e', 
        (char const   )'.',      (char const   )'o',      (char const   )'r',      (char const   )'g', 
        (char const   )'>',      (char const   )'\000'};
#line 97 "/home/june/repo/benchmarks/collector/temp/elfrc-0.7/elfrc.c"
static char const   shstrtabData[61]  = 
#line 97
  {      (char const   )'\000',      (char const   )'.',      (char const   )'t',      (char const   )'e', 
        (char const   )'x',      (char const   )'t',      (char const   )'\000',      (char const   )'.', 
        (char const   )'d',      (char const   )'a',      (char const   )'t',      (char const   )'a', 
        (char const   )'\000',      (char const   )'.',      (char const   )'b',      (char const   )'s', 
        (char const   )'s',      (char const   )'\000',      (char const   )'.',      (char const   )'r', 
        (char const   )'o',      (char const   )'d',      (char const   )'a',      (char const   )'t', 
        (char const   )'a',      (char const   )'\000',      (char const   )'.',      (char const   )'c', 
        (char const   )'o',      (char const   )'m',      (char const   )'m',      (char const   )'e', 
        (char const   )'n',      (char const   )'t',      (char const   )'\000',      (char const   )'.', 
        (char const   )'s',      (char const   )'h',      (char const   )'s',      (char const   )'t', 
        (char const   )'r',      (char const   )'t',      (char const   )'a',      (char const   )'b', 
        (char const   )'\000',      (char const   )'.',      (char const   )'s',      (char const   )'y', 
        (char const   )'m',      (char const   )'t',      (char const   )'a',      (char const   )'b', 
        (char const   )'\000',      (char const   )'.',      (char const   )'s',      (char const   )'t', 
        (char const   )'r',      (char const   )'t',      (char const   )'a',      (char const   )'b', 
        (char const   )'\000'};
#line 108 "/home/june/repo/benchmarks/collector/temp/elfrc-0.7/elfrc.c"
static Elf64_Sym const   symtabData[7]  = {      {(Elf64_Word )0, (unsigned char)0, (unsigned char)0, (Elf64_Section )0, (Elf64_Addr )0,
      (Elf64_Xword )0}, 
        {(Elf64_Word )0, (unsigned char)0, (unsigned char)0, (Elf64_Section )4, (Elf64_Addr )0,
      (Elf64_Xword )65521}, 
        {(Elf64_Word )0, (unsigned char)0, (unsigned char)0, (Elf64_Section )3, (Elf64_Addr )0,
      (Elf64_Xword )1}, 
        {(Elf64_Word )0, (unsigned char)0, (unsigned char)0, (Elf64_Section )3, (Elf64_Addr )0,
      (Elf64_Xword )2}, 
        {(Elf64_Word )0, (unsigned char)0, (unsigned char)0, (Elf64_Section )3, (Elf64_Addr )0,
      (Elf64_Xword )3}, 
        {(Elf64_Word )0, (unsigned char)0, (unsigned char)0, (Elf64_Section )3, (Elf64_Addr )0,
      (Elf64_Xword )4}, 
        {(Elf64_Word )0, (unsigned char)0, (unsigned char)0, (Elf64_Section )3, (Elf64_Addr )0,
      (Elf64_Xword )5}};
#line 182 "/home/june/repo/benchmarks/collector/temp/elfrc-0.7/elfrc.c"
static Elf64_Ehdr hdr  = 
#line 182
     {{(unsigned char)127, (unsigned char )'E', (unsigned char )'L', (unsigned char )'F',
     (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0}, (Elf64_Half )1, (Elf64_Half )0, (Elf64_Word )1,
    (Elf64_Addr )0, (Elf64_Off )0, sizeof(hdr), (Elf64_Word )0, (Elf64_Half )sizeof(hdr),
    (Elf64_Half )0, (Elf64_Half )0, (Elf64_Half )sizeof(Elf64_Shdr ), (Elf64_Half )9,
    (Elf64_Half )6};
#line 206 "/home/june/repo/benchmarks/collector/temp/elfrc-0.7/elfrc.c"
static struct __anonstruct_Elf64_Shdr_41  const  nullHeader  = 
#line 206
     {(Elf64_Word )0, (Elf64_Word )0, (Elf64_Xword )0, (Elf64_Addr )0, (Elf64_Off )0,
    (Elf64_Xword )0, (Elf64_Word )0, (Elf64_Word )0, (Elf64_Xword )0, (Elf64_Xword )0};
#line 219 "/home/june/repo/benchmarks/collector/temp/elfrc-0.7/elfrc.c"
static struct __anonstruct_Elf64_Shdr_41  const  textHeader  = 
#line 219
     {(Elf64_Word )1, (Elf64_Word )1, (Elf64_Xword )((1 << 1) | (1 << 2)), (Elf64_Addr )0,
    (Elf64_Off )0, (Elf64_Xword )0, (Elf64_Word )0, (Elf64_Word )0, (Elf64_Xword )4,
    (Elf64_Xword )0};
#line 232 "/home/june/repo/benchmarks/collector/temp/elfrc-0.7/elfrc.c"
static struct __anonstruct_Elf64_Shdr_41  const  dataHeader  = 
#line 232
     {(Elf64_Word )7, (Elf64_Word )1, (Elf64_Xword )((1 << 1) | 1), (Elf64_Addr )0,
    (Elf64_Off )0, (Elf64_Xword )0, (Elf64_Word )0, (Elf64_Word )0, (Elf64_Xword )4,
    (Elf64_Xword )0};
#line 245 "/home/june/repo/benchmarks/collector/temp/elfrc-0.7/elfrc.c"
static struct __anonstruct_Elf64_Shdr_41  const  bssHeader  = 
#line 245
     {(Elf64_Word )13, (Elf64_Word )8, (Elf64_Xword )((1 << 1) | 1), (Elf64_Addr )0,
    (Elf64_Off )0, (Elf64_Xword )0, (Elf64_Word )0, (Elf64_Word )0, (Elf64_Xword )4,
    (Elf64_Xword )0};
#line 258 "/home/june/repo/benchmarks/collector/temp/elfrc-0.7/elfrc.c"
static Elf64_Shdr rodataHeader  = 
#line 258
     {(Elf64_Word )18, (Elf64_Word )1, (Elf64_Xword )(1 << 1), (Elf64_Addr )0, ((sizeof(Elf64_Ehdr ) + sizeof(Elf64_Shdr ) * 9UL) + sizeof(commentData)) + sizeof(shstrtabData),
    (Elf64_Xword )0, (Elf64_Word )0, (Elf64_Word )0, (Elf64_Xword )0, (Elf64_Xword )0};
#line 274 "/home/june/repo/benchmarks/collector/temp/elfrc-0.7/elfrc.c"
static Elf64_Shdr commentHeader  = 
#line 274
     {(Elf64_Word )26, (Elf64_Word )1, (Elf64_Xword )0, (Elf64_Addr )0, sizeof(Elf64_Ehdr ) + sizeof(Elf64_Shdr ) * 9UL,
    sizeof(commentData), (Elf64_Word )0, (Elf64_Word )0, (Elf64_Xword )1, (Elf64_Xword )0};
#line 287 "/home/june/repo/benchmarks/collector/temp/elfrc-0.7/elfrc.c"
static Elf64_Shdr shstrtabHeader  = 
#line 287
     {(Elf64_Word )35, (Elf64_Word )3, (Elf64_Xword )0, (Elf64_Addr )0, (sizeof(Elf64_Ehdr ) + sizeof(Elf64_Shdr ) * 9UL) + sizeof(commentData),
    sizeof(shstrtabData), (Elf64_Word )0, (Elf64_Word )0, (Elf64_Xword )1, (Elf64_Xword )0};
#line 301 "/home/june/repo/benchmarks/collector/temp/elfrc-0.7/elfrc.c"
static Elf64_Shdr symtabHeader  = 
#line 301
     {(Elf64_Word )45, (Elf64_Word )2, (Elf64_Xword )0, (Elf64_Addr )0, ((sizeof(Elf64_Ehdr ) + sizeof(Elf64_Shdr ) * 9UL) + sizeof(commentData)) + sizeof(shstrtabData),
    (Elf64_Xword )0, (Elf64_Word )8, (Elf64_Word )7, (Elf64_Xword )4, sizeof(symtabData[0])};
#line 316 "/home/june/repo/benchmarks/collector/temp/elfrc-0.7/elfrc.c"
static Elf64_Shdr strtabHeader  = 
#line 316
     {(Elf64_Word )53, (Elf64_Word )3, (Elf64_Xword )0, (Elf64_Addr )0, ((sizeof(Elf64_Ehdr ) + sizeof(Elf64_Shdr ) * 9UL) + sizeof(commentData)) + sizeof(shstrtabData),
    (Elf64_Xword )0, (Elf64_Word )0, (Elf64_Word )0, (Elf64_Xword )1, (Elf64_Xword )0};
#line 332 "/home/june/repo/benchmarks/collector/temp/elfrc-0.7/elfrc.c"
static int copyFileToFD(char const   *src , int dst ) 
{ 
  int fd ;
  char buffer[8192] ;
  ssize_t nread ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  ssize_t tmp___3 ;
  int tmp___4 ;

  {
#line 338
  if (verbosity > 0) {
    {
#line 339
    printf((char const   */* __restrict  */)"Merging %s into object file\n", src);
    }
  }
  {
#line 341
  fd = open(src, 0);
  }
#line 341
  if (fd == -1) {
    {
#line 342
    tmp = __errno_location();
#line 342
    tmp___0 = strerror(*tmp);
#line 342
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed to open %s for reading: %s\n",
            src, tmp___0);
    }
#line 343
    return (-1);
  }
  {
#line 346
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 347
    nread = read(fd, (void *)(buffer), sizeof(buffer));
    }
#line 347
    if (nread == -1L) {
      {
#line 348
      tmp___1 = __errno_location();
#line 348
      tmp___2 = strerror(*tmp___1);
#line 348
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed to read from %s: %s\n",
              src, tmp___2);
#line 349
      close(fd);
      }
#line 350
      return (-1);
    }
    {
#line 353
    tmp___3 = write(dst, (void const   *)(buffer), (size_t )nread);
    }
#line 353
    if (tmp___3 == -1L) {
      {
#line 354
      close(fd);
      }
#line 355
      return (-1);
    }
#line 346
    if (! ((unsigned long )nread == sizeof(buffer))) {
#line 346
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 359
  tmp___4 = close(fd);
  }
#line 359
  return (tmp___4);
}
}
#line 362 "/home/june/repo/benchmarks/collector/temp/elfrc-0.7/elfrc.c"
static unsigned int padding(unsigned int size ) 
{ 


  {
#line 364
  if ((Elf64_Xword )size == rodataHeader.sh_addralign) {
#line 365
    return (0U);
  }
#line 366
  return ((unsigned int )(((rodataHeader.sh_addralign - 1UL) & (unsigned long )(~ size)) + 1UL));
}
}
#line 369 "/home/june/repo/benchmarks/collector/temp/elfrc-0.7/elfrc.c"
static int writeSymbols(int fd ) 
{ 
  struct Resource *it ;
  Elf64_Sym sym ;
  int *tmp ;
  char *tmp___0 ;
  ssize_t tmp___1 ;

  {
#line 374
  it = resources;
  {
#line 374
  while (1) {
    while_continue: /* CIL Label */ ;
#line 374
    if (! ((unsigned long )it != (unsigned long )((struct Resource *)0))) {
#line 374
      goto while_break;
    }
#line 375
    if ((unsigned int )it->ignore == 1U) {
#line 376
      goto __Cont;
    }
    {
#line 379
    sym.st_name = it->strtabOffset;
#line 381
    sym.st_value = (Elf64_Addr )it->payloadOffset;
#line 383
    sym.st_size = (Elf64_Xword )it->size;
#line 385
    sym.st_info = (unsigned char )((1 << 4) + 1);
#line 387
    sym.st_other = (unsigned char)0;
#line 389
    sym.st_shndx = (Elf64_Section )4;
#line 391
    tmp___1 = write(fd, (void const   *)(& sym), sizeof(sym));
    }
#line 391
    if (tmp___1 == -1L) {
      {
#line 392
      tmp = __errno_location();
#line 392
      tmp___0 = strerror(*tmp);
#line 392
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed to write symbols: %s\n",
              tmp___0);
      }
#line 393
      return (-1);
    }
    __Cont: /* CIL Label */ 
#line 374
    it = it->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 397
  return (0);
}
}
#line 400 "/home/june/repo/benchmarks/collector/temp/elfrc-0.7/elfrc.c"
static int writeStringTable(int fd ) 
{ 
  struct Resource *it ;
  int *tmp ;
  char *tmp___0 ;
  ssize_t tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  ssize_t tmp___4 ;

  {
  {
#line 404
  tmp___1 = write(fd, (void const   *)"\000", (size_t )1);
  }
#line 404
  if (tmp___1 == -1L) {
    {
#line 405
    tmp = __errno_location();
#line 405
    tmp___0 = strerror(*tmp);
#line 405
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed to write string table: %s\n",
            tmp___0);
    }
#line 406
    return (-1);
  }
#line 409
  it = resources;
  {
#line 409
  while (1) {
    while_continue: /* CIL Label */ ;
#line 409
    if (! ((unsigned long )it != (unsigned long )((struct Resource *)0))) {
#line 409
      goto while_break;
    }
#line 410
    if ((unsigned int )it->ignore == 1U) {
#line 411
      goto __Cont;
    }
    {
#line 412
    tmp___4 = write(fd, (void const   *)it->symbol, (size_t )it->symbolSize);
    }
#line 412
    if (tmp___4 == -1L) {
      {
#line 413
      tmp___2 = __errno_location();
#line 413
      tmp___3 = strerror(*tmp___2);
#line 413
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed to write string table: %s\n",
              tmp___3);
      }
#line 414
      return (-1);
    }
    __Cont: /* CIL Label */ 
#line 409
    it = it->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 418
  return (0);
}
}
#line 421 "/home/june/repo/benchmarks/collector/temp/elfrc-0.7/elfrc.c"
static int patchHeaders(char const   *pathToSelf ) 
{ 
  int maxalign ;
  int align ;
  int payloadSize ;
  int symtabSize ;
  int strtabSize ;
  int fd ;
  Elf64_Ehdr ownhdr ;
  struct Resource *it ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  ssize_t tmp___3 ;
  unsigned int tmp___4 ;

  {
  {
#line 423
  maxalign = 1;
#line 431
  fd = open(pathToSelf, 0);
  }
#line 431
  if (fd == -1) {
    {
#line 432
    tmp = __errno_location();
#line 432
    tmp___0 = strerror(*tmp);
#line 432
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed to open %s for reading: %s\n",
            pathToSelf, tmp___0);
    }
#line 433
    return (-1);
  }
  {
#line 435
  tmp___3 = read(fd, (void *)(& ownhdr), sizeof(ownhdr));
  }
#line 435
  if (tmp___3 == -1L) {
    {
#line 436
    tmp___1 = __errno_location();
#line 436
    tmp___2 = strerror(*tmp___1);
#line 436
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed to read from %s: %s\n",
            pathToSelf, tmp___2);
    }
#line 437
    return (-1);
  }
  {
#line 439
  close(fd);
#line 443
  hdr.e_machine = ownhdr.e_machine;
#line 444
  hdr.e_ident[7] = ownhdr.e_ident[7];
#line 445
  hdr.e_ident[8] = ownhdr.e_ident[8];
#line 446
  hdr.e_flags = ownhdr.e_flags;
#line 449
  it = resources;
  }
  {
#line 449
  while (1) {
    while_continue: /* CIL Label */ ;
#line 449
    if (! ((unsigned long )it != (unsigned long )((struct Resource *)0))) {
#line 449
      goto while_break;
    }
#line 450
    align = 1;
    {
#line 451
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 451
      if ((unsigned long )align < sizeof(void *) * 8UL) {
#line 451
        if (! (it->size > (unsigned int )align)) {
#line 451
          goto while_break___0;
        }
      } else {
#line 451
        goto while_break___0;
      }
#line 452
      align <<= 1;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 453
    if (align > maxalign) {
#line 454
      maxalign = align;
    }
#line 449
    it = it->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 458
  rodataHeader.sh_addralign = (Elf64_Xword )maxalign;
#line 463
  payloadSize = 0;
#line 464
  symtabSize = (int )sizeof(symtabData);
#line 465
  strtabSize = 1;
#line 466
  it = resources;
  {
#line 466
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 466
    if (! ((unsigned long )it != (unsigned long )((struct Resource *)0))) {
#line 466
      goto while_break___1;
    }
#line 467
    it->payloadOffset = (unsigned int )payloadSize;
#line 468
    payloadSize = (int )((unsigned int )payloadSize + it->size);
#line 469
    symtabSize = (int )((unsigned long )symtabSize + sizeof(symtabData[0]));
#line 470
    it->strtabOffset = (unsigned int )strtabSize;
#line 471
    strtabSize = (int )((unsigned int )strtabSize + it->symbolSize);
#line 472
    if ((unsigned long )it->next != (unsigned long )((struct Resource *)0)) {
      {
#line 473
      tmp___4 = padding(it->size);
#line 473
      payloadSize = (int )((unsigned int )payloadSize + tmp___4);
      }
    }
#line 466
    it = it->next;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 478
  rodataHeader.sh_size = (Elf64_Xword )payloadSize;
#line 479
  rodataHeader.sh_offset += (Elf64_Off )(symtabSize + strtabSize);
#line 480
  symtabHeader.sh_size = (Elf64_Xword )symtabSize;
#line 481
  strtabHeader.sh_offset += (Elf64_Off )symtabSize;
#line 482
  strtabHeader.sh_size = (Elf64_Xword )strtabSize;
#line 484
  return (0);
}
}
#line 487 "/home/june/repo/benchmarks/collector/temp/elfrc-0.7/elfrc.c"
static int writeFiles(int fd ) 
{ 
  int i ;
  int npad ;
  struct Resource *it ;
  unsigned int tmp ;
  int tmp___0 ;

  {
#line 491
  it = resources;
#line 493
  it = resources;
  {
#line 493
  while (1) {
    while_continue: /* CIL Label */ ;
#line 493
    if (! ((unsigned long )it != (unsigned long )((struct Resource *)0))) {
#line 493
      goto while_break;
    }
    {
#line 494
    tmp___0 = copyFileToFD((char const   *)it->filename, fd);
    }
#line 494
    if (tmp___0 == -1) {
#line 495
      it->ignore = (enum __anonenum_ignore_97 )1;
    } else {
#line 497
      it->ignore = (enum __anonenum_ignore_97 )0;
#line 501
      if ((unsigned int )it->type == 0U) {
        {
#line 502
        write(fd, (void const   *)"\000", (size_t )1);
        }
      }
#line 504
      if (it->next) {
        {
#line 506
        tmp = padding(it->size);
#line 506
        npad = (int )tmp;
#line 507
        i = 0;
        }
        {
#line 507
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 507
          if (! (i < npad)) {
#line 507
            goto while_break___0;
          }
          {
#line 508
          write(fd, (void const   *)"\000", (size_t )1);
#line 507
          i ++;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
#line 493
    it = it->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 513
  return (0);
}
}
#line 516 "/home/june/repo/benchmarks/collector/temp/elfrc-0.7/elfrc.c"
static int writeELFRelocatable(char const   *fn ) 
{ 
  int fd ;
  int *tmp ;
  char *tmp___0 ;
  ssize_t tmp___1 ;
  ssize_t tmp___2 ;
  ssize_t tmp___3 ;
  ssize_t tmp___4 ;
  ssize_t tmp___5 ;
  ssize_t tmp___6 ;
  ssize_t tmp___7 ;
  ssize_t tmp___8 ;
  ssize_t tmp___9 ;
  ssize_t tmp___10 ;
  ssize_t tmp___11 ;
  ssize_t tmp___12 ;
  ssize_t tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int *tmp___17 ;
  char *tmp___18 ;
  int tmp___19 ;

  {
#line 520
  if (! fn) {
#line 521
    return (0);
  }
#line 523
  if (verbosity > 0) {
    {
#line 524
    printf((char const   */* __restrict  */)"Writing ELF relocatable file %s\n", fn);
    }
  }
  {
#line 526
  fd = open(fn, 577, 420);
  }
#line 526
  if (fd == -1) {
    {
#line 527
    tmp = __errno_location();
#line 527
    tmp___0 = strerror(*tmp);
#line 527
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed to open %s for writing: %s\n",
            fn, tmp___0);
    }
#line 528
    return (-1);
  }
  {
#line 537
  tmp___1 = write(fd, (void const   *)(& hdr), sizeof(hdr));
  }
#line 537
  if (tmp___1 == -1L) {
    {
#line 537
    close(fd);
    }
#line 537
    return (-1);
  }
  {
#line 539
  tmp___2 = write(fd, (void const   *)(& nullHeader), sizeof(nullHeader));
  }
#line 539
  if (tmp___2 == -1L) {
    {
#line 539
    close(fd);
    }
#line 539
    return (-1);
  }
  {
#line 540
  tmp___3 = write(fd, (void const   *)(& textHeader), sizeof(textHeader));
  }
#line 540
  if (tmp___3 == -1L) {
    {
#line 540
    close(fd);
    }
#line 540
    return (-1);
  }
  {
#line 541
  tmp___4 = write(fd, (void const   *)(& dataHeader), sizeof(dataHeader));
  }
#line 541
  if (tmp___4 == -1L) {
    {
#line 541
    close(fd);
    }
#line 541
    return (-1);
  }
  {
#line 542
  tmp___5 = write(fd, (void const   *)(& bssHeader), sizeof(bssHeader));
  }
#line 542
  if (tmp___5 == -1L) {
    {
#line 542
    close(fd);
    }
#line 542
    return (-1);
  }
  {
#line 543
  tmp___6 = write(fd, (void const   *)(& rodataHeader), sizeof(rodataHeader));
  }
#line 543
  if (tmp___6 == -1L) {
    {
#line 543
    close(fd);
    }
#line 543
    return (-1);
  }
  {
#line 544
  tmp___7 = write(fd, (void const   *)(& commentHeader), sizeof(commentHeader));
  }
#line 544
  if (tmp___7 == -1L) {
    {
#line 544
    close(fd);
    }
#line 544
    return (-1);
  }
  {
#line 545
  tmp___8 = write(fd, (void const   *)(& shstrtabHeader), sizeof(shstrtabHeader));
  }
#line 545
  if (tmp___8 == -1L) {
    {
#line 545
    close(fd);
    }
#line 545
    return (-1);
  }
  {
#line 546
  tmp___9 = write(fd, (void const   *)(& symtabHeader), sizeof(symtabHeader));
  }
#line 546
  if (tmp___9 == -1L) {
    {
#line 546
    close(fd);
    }
#line 546
    return (-1);
  }
  {
#line 547
  tmp___10 = write(fd, (void const   *)(& strtabHeader), sizeof(strtabHeader));
  }
#line 547
  if (tmp___10 == -1L) {
    {
#line 547
    close(fd);
    }
#line 547
    return (-1);
  }
  {
#line 549
  tmp___11 = write(fd, (void const   *)(& commentData), sizeof(commentData));
  }
#line 549
  if (tmp___11 == -1L) {
    {
#line 549
    close(fd);
    }
#line 549
    return (-1);
  }
  {
#line 550
  tmp___12 = write(fd, (void const   *)(& shstrtabData), sizeof(shstrtabData));
  }
#line 550
  if (tmp___12 == -1L) {
    {
#line 550
    close(fd);
    }
#line 550
    return (-1);
  }
  {
#line 552
  tmp___13 = write(fd, (void const   *)(& symtabData), sizeof(symtabData));
  }
#line 552
  if (tmp___13 == -1L) {
    {
#line 552
    close(fd);
    }
#line 552
    return (-1);
  }
  {
#line 553
  tmp___14 = writeSymbols(fd);
  }
#line 553
  if (tmp___14 == -1) {
    {
#line 554
    close(fd);
    }
#line 555
    return (-1);
  }
  {
#line 558
  tmp___15 = writeStringTable(fd);
  }
#line 558
  if (tmp___15 == -1) {
    {
#line 559
    close(fd);
    }
#line 560
    return (-1);
  }
  {
#line 563
  tmp___16 = writeFiles(fd);
  }
#line 563
  if (tmp___16 == -1) {
    {
#line 564
    close(fd);
    }
#line 565
    return (-1);
  }
  {
#line 570
  tmp___19 = close(fd);
  }
#line 570
  if (tmp___19 == -1) {
    {
#line 571
    tmp___17 = __errno_location();
#line 571
    tmp___18 = strerror(*tmp___17);
#line 571
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed to close file %s: %s\n",
            fn, tmp___18);
    }
#line 572
    return (-1);
  }
#line 575
  return (0);
}
}
#line 578 "/home/june/repo/benchmarks/collector/temp/elfrc-0.7/elfrc.c"
static void registerResource(int type , char const   *symbol , char const   *fn ,
                             unsigned int filesize ) 
{ 
  struct Resource *it ;
  struct Resource *res ;
  void *tmp ;
  size_t tmp___0 ;

  {
  {
#line 583
  it = (struct Resource *)0;
#line 584
  tmp = malloc(sizeof(struct Resource ));
#line 584
  res = (struct Resource *)tmp;
#line 585
  res->type = (enum __anonenum_type_96 )type;
#line 586
  res->symbol = strdup(symbol);
#line 587
  tmp___0 = strlen((char const   *)res->symbol);
#line 587
  res->symbolSize = (unsigned int )(tmp___0 + 1UL);
#line 588
  res->filename = strdup(fn);
#line 589
  res->size = filesize;
  }
#line 590
  if (type == 0) {
#line 591
    (res->size) ++;
  }
#line 592
  res->next = (struct Resource *)0;
#line 594
  if (! resources) {
#line 595
    resources = res;
  } else {
#line 597
    it = resources;
    {
#line 597
    while (1) {
      while_continue: /* CIL Label */ ;
#line 597
      if (! ((unsigned long )it->next != (unsigned long )((struct Resource *)0))) {
#line 597
        goto while_break;
      }
#line 597
      it = it->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 599
    it->next = res;
  }
#line 602
  if (verbosity > 0) {
    {
#line 603
    printf((char const   */* __restrict  */)"Registered resurce %s (type %d) => %s (%d bytes)\n",
           symbol, type, fn, filesize);
    }
  }
#line 605
  return;
}
}
#line 607 "/home/june/repo/benchmarks/collector/temp/elfrc-0.7/elfrc.c"
static void freeResourceList(void) 
{ 
  struct Resource *it ;
  struct Resource *next ;

  {
#line 609
  it = resources;
  {
#line 611
  while (1) {
    while_continue: /* CIL Label */ ;
#line 611
    if (! ((unsigned long )it != (unsigned long )((struct Resource *)0))) {
#line 611
      goto while_break;
    }
    {
#line 612
    free((void *)it->symbol);
#line 613
    free((void *)it->filename);
#line 614
    next = it->next;
#line 615
    free((void *)it);
#line 616
    it = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 618
  return;
}
}
#line 622
static int parseResourceFileData(char const   *buffer , size_t len ) ;
#line 622 "/home/june/repo/benchmarks/collector/temp/elfrc-0.7/elfrc.c"
static enum __anonenum_state_98 state  =    (enum __anonenum_state_98 )0;
#line 623 "/home/june/repo/benchmarks/collector/temp/elfrc-0.7/elfrc.c"
static char curType[32]  ;
#line 624
static int parseResourceFileData(char const   *buffer , size_t len ) ;
#line 624 "/home/june/repo/benchmarks/collector/temp/elfrc-0.7/elfrc.c"
static unsigned int curTypeLen  =    0U;
#line 625 "/home/june/repo/benchmarks/collector/temp/elfrc-0.7/elfrc.c"
static char curSymbol[256]  ;
#line 626
static int parseResourceFileData(char const   *buffer , size_t len ) ;
#line 626 "/home/june/repo/benchmarks/collector/temp/elfrc-0.7/elfrc.c"
static unsigned int curSymbolLen  =    0U;
#line 627 "/home/june/repo/benchmarks/collector/temp/elfrc-0.7/elfrc.c"
static char curFilename[4096]  ;
#line 628
static int parseResourceFileData(char const   *buffer , size_t len ) ;
#line 628 "/home/june/repo/benchmarks/collector/temp/elfrc-0.7/elfrc.c"
static unsigned int curFilenameLen  =    0U;
#line 629 "/home/june/repo/benchmarks/collector/temp/elfrc-0.7/elfrc.c"
static unsigned int lineno  ;
#line 620 "/home/june/repo/benchmarks/collector/temp/elfrc-0.7/elfrc.c"
static int parseResourceFileData(char const   *buffer , size_t len ) 
{ 
  struct stat sb ;
  char const   *it ;
  int type ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  unsigned int tmp___13 ;

  {
#line 632
  type = 0;
#line 635
  if (! buffer) {
    {
#line 637
    if ((unsigned int )state == 0U) {
#line 637
      goto case_0;
    }
#line 640
    if ((unsigned int )state == 1U) {
#line 640
      goto case_1;
    }
#line 643
    if ((unsigned int )state == 2U) {
#line 643
      goto case_2;
    }
#line 636
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 638
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Unexpected end of resource file; expected symbol name.\n");
    }
#line 639
    return (-1);
    case_1: /* CIL Label */ 
    {
#line 641
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Unexpected end of resource file; expected file name.\n");
    }
#line 642
    return (-1);
    case_2: /* CIL Label */ 
    {
#line 644
    curFilename[curFilenameLen] = (char )'\000';
#line 646
    tmp___1 = stat((char const   */* __restrict  */)(curFilename), (struct stat */* __restrict  */)(& sb));
    }
#line 646
    if (tmp___1 == -1) {
      {
#line 647
      tmp = __errno_location();
#line 647
      tmp___0 = strerror(*tmp);
#line 647
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error in line %d of resource file: failed to access %s: %s\n",
              lineno, curFilename, tmp___0);
      }
#line 649
      return (-1);
    }
    {
#line 652
    tmp___3 = strcmp((char const   *)(curType), "text");
    }
#line 652
    if (tmp___3 == 0) {
#line 653
      type = 0;
    } else {
      {
#line 654
      tmp___2 = strcmp((char const   *)(curType), "binary");
      }
#line 654
      if (tmp___2 == 0) {
#line 655
        type = 1;
      }
    }
    {
#line 656
    registerResource(type, (char const   *)(curSymbol), (char const   *)(curFilename),
                     (unsigned int )sb.st_size);
    }
#line 657
    return (0);
    switch_break: /* CIL Label */ ;
    }
  }
#line 661
  it = buffer;
  {
#line 661
  while (1) {
    while_continue: /* CIL Label */ ;
#line 661
    if (! ((unsigned long )it < (unsigned long )(buffer + len))) {
#line 661
      goto while_break;
    }
    {
#line 663
    if ((unsigned int )state == 0U) {
#line 663
      goto case_0___0;
    }
#line 690
    if ((unsigned int )state == 1U) {
#line 690
      goto case_1___0;
    }
#line 710
    if ((unsigned int )state == 2U) {
#line 710
      goto case_2___0;
    }
#line 662
    goto switch_break___0;
    case_0___0: /* CIL Label */ 
#line 664
    if ((int const   )*it == 9) {
      {
#line 665
      curType[curTypeLen] = (char )'\000';
#line 666
      tmp___4 = strcmp((char const   *)(curType), "text");
      }
#line 666
      if (tmp___4 != 0) {
        {
#line 666
        tmp___5 = strcmp((char const   *)(curType), "binary");
        }
#line 666
        if (tmp___5 != 0) {
          {
#line 668
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: Unknown resource type \'%s\' in line %d of resource file; assuming \'binary\'.\n",
                  curType, lineno);
#line 671
          strncpy((char */* __restrict  */)(curType), (char const   */* __restrict  */)"binary",
                  sizeof(curType));
          }
        }
      }
#line 673
      state = (enum __anonenum_state_98 )1;
#line 674
      curSymbolLen = 0U;
    } else
#line 675
    if ((int const   )*it == 10) {
      {
#line 676
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error in line %d of resource file: expected tab and symbol name, got newline\n",
              lineno);
      }
#line 679
      return (-1);
    } else
#line 680
    if ((unsigned long )curTypeLen < sizeof(curType)) {
#line 681
      tmp___6 = curTypeLen;
#line 681
      curTypeLen ++;
#line 681
      curType[tmp___6] = (char )*it;
    } else {
      {
#line 683
      curType[curTypeLen - 1U] = (char )'\000';
#line 684
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error in line %d of resource file: resource type \'%s\' is too long\n",
              lineno, curType);
      }
#line 687
      return (-1);
    }
#line 689
    goto switch_break___0;
    case_1___0: /* CIL Label */ 
#line 691
    if ((int const   )*it == 9) {
#line 692
      curSymbol[curSymbolLen] = (char )'\000';
#line 693
      state = (enum __anonenum_state_98 )2;
#line 694
      curFilenameLen = 0U;
    } else
#line 695
    if ((int const   )*it == 10) {
      {
#line 696
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error in line %d of resource file: expected tab and filename, got newline\n",
              lineno);
      }
#line 699
      return (-1);
    } else
#line 700
    if ((unsigned long )curSymbolLen < sizeof(curSymbol)) {
#line 701
      tmp___7 = curSymbolLen;
#line 701
      curSymbolLen ++;
#line 701
      curSymbol[tmp___7] = (char )*it;
    } else {
      {
#line 703
      curSymbol[curSymbolLen - 1U] = (char )'\000';
#line 704
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error in line %d of resource file: symbol \'%s\' is too long\n",
              lineno, curSymbol);
      }
#line 707
      return (-1);
    }
#line 709
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
#line 711
    if ((int const   )*it == 10) {
      {
#line 712
      curFilename[curFilenameLen] = (char )'\000';
#line 714
      tmp___10 = stat((char const   */* __restrict  */)(curFilename), (struct stat */* __restrict  */)(& sb));
      }
#line 714
      if (tmp___10 == -1) {
        {
#line 715
        tmp___8 = __errno_location();
#line 715
        tmp___9 = strerror(*tmp___8);
#line 715
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error in line %d of resource file: failed to access %s: %s\n",
                lineno, curFilename, tmp___9);
        }
#line 717
        return (-1);
      }
      {
#line 720
      tmp___12 = strcmp((char const   *)(curType), "text");
      }
#line 720
      if (tmp___12 == 0) {
#line 721
        type = 0;
      } else {
        {
#line 722
        tmp___11 = strcmp((char const   *)(curType), "binary");
        }
#line 722
        if (tmp___11 == 0) {
#line 723
          type = 1;
        }
      }
      {
#line 724
      registerResource(type, (char const   *)(curSymbol), (char const   *)(curFilename),
                       (unsigned int )sb.st_size);
#line 726
      state = (enum __anonenum_state_98 )0;
#line 727
      curTypeLen = 0U;
#line 728
      lineno ++;
      }
    } else
#line 729
    if ((unsigned long )curFilenameLen < sizeof(curFilename)) {
#line 730
      tmp___13 = curFilenameLen;
#line 730
      curFilenameLen ++;
#line 730
      curFilename[tmp___13] = (char )*it;
    } else {
      {
#line 732
      curFilename[curFilenameLen - 1U] = (char )'\000';
#line 733
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error in line %d of resource file: file name \'%s\' is too long\n",
              lineno, curFilename);
      }
#line 736
      return (-1);
    }
#line 738
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 661
    it ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 742
  return (0);
}
}
#line 745 "/home/june/repo/benchmarks/collector/temp/elfrc-0.7/elfrc.c"
static int loadResources(char const   *fn ) 
{ 
  int fd ;
  char buffer[1024] ;
  ssize_t nread ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 751
  if (verbosity > 0) {
    {
#line 752
    printf((char const   */* __restrict  */)"Loading resource configuration from %s\n",
           fn);
    }
  }
#line 754
  if (! fn) {
#line 755
    fd = 0;
  } else {
    {
#line 754
    tmp___1 = strcmp(fn, "-");
    }
#line 754
    if (tmp___1 == 0) {
#line 755
      fd = 0;
    } else {
      {
#line 756
      fd = open(fn, 0);
      }
#line 756
      if (fd == -1) {
        {
#line 757
        tmp = __errno_location();
#line 757
        tmp___0 = strerror(*tmp);
#line 757
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed to open %s for reading: %s\n",
                fn, tmp___0);
        }
#line 758
        return (-1);
      }
    }
  }
  {
#line 761
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 762
    nread = read(fd, (void *)(buffer), sizeof(buffer));
    }
#line 762
    if (nread == -1L) {
      {
#line 763
      tmp___2 = __errno_location();
#line 763
      tmp___3 = strerror(*tmp___2);
#line 763
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed to read from %s: %s\n",
              fn, tmp___3);
#line 764
      close(fd);
      }
#line 765
      return (-1);
    }
    {
#line 768
    tmp___4 = parseResourceFileData((char const   *)(buffer), (size_t )nread);
    }
#line 768
    if (tmp___4 == -1) {
      {
#line 769
      close(fd);
      }
#line 770
      return (-1);
    }
#line 761
    if (! ((unsigned long )nread == sizeof(buffer))) {
#line 761
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 774
  parseResourceFileData((char const   *)0, (size_t )0);
#line 776
  tmp___5 = close(fd);
  }
#line 776
  return (tmp___5);
}
}
#line 779 "/home/june/repo/benchmarks/collector/temp/elfrc-0.7/elfrc.c"
static int writeCHeader(char const   *fn ) 
{ 
  FILE *fd ;
  struct Resource *it ;
  char includeGuard[19] ;
  int i ;
  int *tmp ;
  char *tmp___0 ;
  time_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 786
  if (! fn) {
#line 787
    return (0);
  }
#line 789
  if (verbosity > 0) {
    {
#line 790
    printf((char const   */* __restrict  */)"Writing header file %s\n", fn);
    }
  }
  {
#line 792
  fd = fopen((char const   */* __restrict  */)fn, (char const   */* __restrict  */)"w+");
  }
#line 792
  if ((unsigned long )fd == (unsigned long )((void *)0)) {
    {
#line 793
    tmp = __errno_location();
#line 793
    tmp___0 = strerror(*tmp);
#line 793
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed to open %s for writing: %s\n",
            fn, tmp___0);
    }
#line 795
    return (-1);
  }
  {
#line 799
  tmp___1 = time((time_t *)((void *)0));
#line 799
  srand((unsigned int )tmp___1);
#line 800
  includeGuard[0] = (char )'H';
#line 801
  includeGuard[1] = (char )'_';
#line 802
  i = 2;
  }
  {
#line 802
  while (1) {
    while_continue: /* CIL Label */ ;
#line 802
    if (! ((unsigned long )i < sizeof(includeGuard))) {
#line 802
      goto while_break;
    }
    {
#line 803
    tmp___2 = rand();
#line 803
    includeGuard[i] = (char )(48 + tmp___2 % 10);
#line 802
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 804
  includeGuard[18] = (char )'\000';
#line 807
  fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"#ifndef %s\n#define %s\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n",
          includeGuard, includeGuard);
#line 816
  fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"/* Automatically generated by elfrc 0.7. Do not modify by hand. */\n");
#line 820
  it = resources;
  }
  {
#line 820
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 820
    if (! ((unsigned long )it != (unsigned long )((struct Resource *)0))) {
#line 820
      goto while_break___0;
    }
    {
#line 821
    fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"\n/* %s */\nextern const char %s[%d];\n",
            it->filename, it->symbol, it->size);
#line 820
    it = it->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 828
  fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"\n#ifdef __cplusplus\n} /* extern \"C\" */\n#endif\n\n#endif /* %s */\n",
          includeGuard);
#line 836
  tmp___3 = fclose(fd);
  }
#line 836
  return (tmp___3);
}
}
#line 839 "/home/june/repo/benchmarks/collector/temp/elfrc-0.7/elfrc.c"
static void usage(void) 
{ 


  {
  {
#line 841
  printf((char const   */* __restrict  */)"elfrc 0.7 - a resource compiler for ELF systems\n");
#line 842
  printf((char const   */* __restrict  */)"Copyright (C) 2006 Frerich Raabe <raabe@kde.org>\n");
#line 843
  printf((char const   */* __restrict  */)"usage: elfrc [-o <filename>] [-h <filename>] [-v] [resfile]\n");
  }
#line 844
  return;
}
}
#line 848 "/home/june/repo/benchmarks/collector/temp/elfrc-0.7/elfrc.c"
static char self[4096]  ;
#line 846 "/home/june/repo/benchmarks/collector/temp/elfrc-0.7/elfrc.c"
static char const   *findPathToSelf(char const   *invocation ) 
{ 
  char *path ;
  char *it ;
  struct stat sb ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
#line 853
  if ((int const   )*(invocation + 0) == 47) {
    {
#line 854
    strncpy((char */* __restrict  */)(self), (char const   */* __restrict  */)invocation,
            sizeof(self));
    }
#line 855
    return ((char const   *)(self));
  } else {
    {
#line 858
    tmp___2 = strchr(invocation, '/');
    }
#line 858
    if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
      {
#line 859
      getcwd(self, sizeof(self));
#line 860
      tmp = strlen((char const   *)(self));
#line 860
      strncat((char */* __restrict  */)(self), (char const   */* __restrict  */)"/",
              (sizeof(self) - tmp) - 1UL);
#line 861
      tmp___0 = strlen((char const   *)(self));
#line 861
      strncat((char */* __restrict  */)(self), (char const   */* __restrict  */)invocation,
              (sizeof(self) - tmp___0) - 1UL);
      }
#line 862
      return ((char const   *)(self));
    } else {
      {
#line 865
      path = getenv("PATH");
      }
#line 865
      if ((unsigned long )path != (unsigned long )((void *)0)) {
        {
#line 866
        it = strtok((char */* __restrict  */)path, (char const   */* __restrict  */)":");
        }
        {
#line 866
        while (1) {
          while_continue: /* CIL Label */ ;
#line 866
          if (! ((unsigned long )it != (unsigned long )((void *)0))) {
#line 866
            goto while_break;
          }
          {
#line 867
          snprintf((char */* __restrict  */)(self), sizeof(self), (char const   */* __restrict  */)"%s/%s",
                   it, invocation);
#line 868
          tmp___1 = stat((char const   */* __restrict  */)(self), (struct stat */* __restrict  */)(& sb));
          }
#line 868
          if (tmp___1 == -1) {
#line 869
            goto __Cont;
          }
#line 872
          if ((sb.st_mode & 61440U) == 32768U) {
#line 873
            return ((char const   *)(self));
          }
          __Cont: /* CIL Label */ 
          {
#line 866
          it = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)":");
          }
        }
        while_break: /* CIL Label */ ;
        }
      }
    }
  }
#line 878
  return ((char const   *)0);
}
}
#line 881 "/home/june/repo/benchmarks/collector/temp/elfrc-0.7/elfrc.c"
int main(int argc , char **argv ) 
{ 
  char const   *invocation ;
  char const   *pathToSelf ;
  char *objectOutput ;
  char *headerOutput ;
  signed char ch ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 883
  invocation = (char const   *)*(argv + 0);
#line 884
  pathToSelf = (char const   *)0;
#line 885
  objectOutput = (char *)0;
#line 886
  headerOutput = (char *)0;
#line 887
  ch = (signed char)0;
  {
#line 889
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 889
    tmp = getopt(argc, (char * const  *)argv, "o:h:v?");
#line 889
    ch = (signed char )tmp;
    }
#line 889
    if (! ((int )ch != -1)) {
#line 889
      goto while_break;
    }
    {
#line 891
    if ((int )ch == 111) {
#line 891
      goto case_111;
    }
#line 894
    if ((int )ch == 104) {
#line 894
      goto case_104;
    }
#line 897
    if ((int )ch == 118) {
#line 897
      goto case_118;
    }
#line 901
    goto switch_default;
    case_111: /* CIL Label */ 
#line 892
    objectOutput = optarg;
#line 893
    goto switch_break;
    case_104: /* CIL Label */ 
#line 895
    headerOutput = optarg;
#line 896
    goto switch_break;
    case_118: /* CIL Label */ 
#line 898
    verbosity ++;
#line 899
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 902
    usage();
    }
#line 903
    return (0);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 907
  argc -= optind;
#line 908
  argv += optind;
#line 910
  if (! objectOutput) {
#line 910
    if (! headerOutput) {
      {
#line 911
      usage();
#line 912
      printf((char const   */* __restrict  */)"No output chosen. Try -o and/or -h.\n");
      }
#line 913
      return (-1);
    }
  }
  {
#line 916
  pathToSelf = findPathToSelf(invocation);
  }
#line 916
  if ((unsigned long )pathToSelf == (unsigned long )((void *)0)) {
    {
#line 917
    printf((char const   */* __restrict  */)"Failed to determine path to myself.");
#line 918
    printf((char const   */* __restrict  */)"Try invoking with absolute path.");
    }
#line 919
    return (-1);
  }
  {
#line 922
  tmp___0 = loadResources((char const   *)*(argv + 0));
  }
#line 922
  if (tmp___0 == -1) {
#line 923
    return (-1);
  }
  {
#line 925
  tmp___1 = patchHeaders(pathToSelf);
  }
#line 925
  if (tmp___1 == -1) {
#line 926
    return (-1);
  }
  {
#line 928
  tmp___2 = writeELFRelocatable((char const   *)objectOutput);
  }
#line 928
  if (tmp___2 == -1) {
#line 929
    return (-1);
  }
  {
#line 931
  tmp___3 = writeCHeader((char const   *)headerOutput);
  }
#line 931
  if (tmp___3 == -1) {
#line 932
    return (-1);
  }
  {
#line 934
  freeResourceList();
  }
#line 936
  return (0);
}
}
