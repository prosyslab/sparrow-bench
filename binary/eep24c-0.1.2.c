/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 36 "/home/june/repo/benchmarks/collector/temp/eep24c-0.1.2/intelhex.h"
struct __anonstruct_inteldata_25 {
   unsigned char recdata[256] ;
   unsigned int offset ;
   unsigned int reclen ;
   FILE *file ;
   int eof_found ;
};
#line 36 "/home/june/repo/benchmarks/collector/temp/eep24c-0.1.2/intelhex.h"
typedef struct __anonstruct_inteldata_25 inteldata;
#line 49 "/home/june/repo/benchmarks/collector/temp/eep24c-0.1.2/parport.h"
struct parport {
   long base_address ;
   unsigned int last_write ;
};
#line 49 "/home/june/repo/benchmarks/collector/temp/eep24c-0.1.2/parport.h"
typedef struct parport parport_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 25 "/home/june/repo/benchmarks/collector/temp/eep24c-0.1.2/memory.h"
struct memory {
   unsigned long size ;
   int *data ;
};
#line 25 "/home/june/repo/benchmarks/collector/temp/eep24c-0.1.2/memory.h"
typedef struct memory memory_t;
#line 32 "/home/june/repo/benchmarks/collector/temp/eep24c-0.1.2/eeprom.h"
struct __anonstruct_eeprom_t_1 {
   parport_t *pp ;
   int access_mode ;
   unsigned long write_size ;
   unsigned int addr_size ;
   unsigned long read_size ;
   unsigned long total_size ;
   unsigned char inv_page ;
};
#line 32 "/home/june/repo/benchmarks/collector/temp/eep24c-0.1.2/eeprom.h"
typedef struct __anonstruct_eeprom_t_1 eeprom_t;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 137 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 515 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 48 "/home/june/repo/benchmarks/collector/temp/eep24c-0.1.2/intelhex.h"
int intelhex_fileopen(inteldata *id , char *filename , int mode ) ;
#line 50
int intelhex_fileclose(inteldata *id ) ;
#line 58
int intelhex_readline(inteldata *id ) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/eep24c-0.1.2/ihex2txt.c"
int main(int argc , char **argv ) 
{ 
  inteldata ihex ;
  int i ;
  FILE *f ;
  char l[780] ;
  char ll[4] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 36
  if (argc == 2) {
    {
#line 37
    tmp = strcmp((char const   *)*(argv + 1), "--help");
    }
#line 37
    if (tmp) {
      {
#line 42
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ihex2txt is free software with ABSOLUTELY NO WARRANTY. \nCopyright (c) 2002 - Pedro Zorzenon Neto.\nihex2txt: converts Intelhex file to simple text format\nUsage: ihex2txt inputfilename.hex outputfilename.txt\nWarning: outputfilename.txt will be overwritten.\n");
      }
#line 48
      return (1);
    } else {
      {
#line 37
      tmp___0 = strcmp((char const   *)*(argv + 1), "-h");
      }
#line 37
      if (tmp___0) {
        {
#line 42
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ihex2txt is free software with ABSOLUTELY NO WARRANTY. \nCopyright (c) 2002 - Pedro Zorzenon Neto.\nihex2txt: converts Intelhex file to simple text format\nUsage: ihex2txt inputfilename.hex outputfilename.txt\nWarning: outputfilename.txt will be overwritten.\n");
        }
#line 48
        return (1);
      } else {
        {
#line 37
        tmp___1 = strcmp((char const   *)*(argv + 1), "-?");
        }
#line 37
        if (tmp___1) {
          {
#line 42
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ihex2txt is free software with ABSOLUTELY NO WARRANTY. \nCopyright (c) 2002 - Pedro Zorzenon Neto.\nihex2txt: converts Intelhex file to simple text format\nUsage: ihex2txt inputfilename.hex outputfilename.txt\nWarning: outputfilename.txt will be overwritten.\n");
          }
#line 48
          return (1);
        } else {
          {
#line 37
          tmp___2 = strcmp((char const   *)*(argv + 1), "--usage");
          }
#line 37
          if (tmp___2) {
            {
#line 42
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ihex2txt is free software with ABSOLUTELY NO WARRANTY. \nCopyright (c) 2002 - Pedro Zorzenon Neto.\nihex2txt: converts Intelhex file to simple text format\nUsage: ihex2txt inputfilename.hex outputfilename.txt\nWarning: outputfilename.txt will be overwritten.\n");
            }
#line 48
            return (1);
          } else {
            {
#line 37
            tmp___3 = strcmp((char const   *)*(argv + 1), "/?");
            }
#line 37
            if (tmp___3) {
              {
#line 42
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ihex2txt is free software with ABSOLUTELY NO WARRANTY. \nCopyright (c) 2002 - Pedro Zorzenon Neto.\nihex2txt: converts Intelhex file to simple text format\nUsage: ihex2txt inputfilename.hex outputfilename.txt\nWarning: outputfilename.txt will be overwritten.\n");
              }
#line 48
              return (1);
            }
          }
        }
      }
    }
  }
#line 52
  if (argc != 3) {
    {
#line 53
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Try: ihex2txt --help\n");
    }
#line 54
    return (1);
  }
  {
#line 57
  intelhex_fileopen(& ihex, *(argv + 1), 1);
#line 58
  f = fopen((char const   */* __restrict  */)*(argv + 2), (char const   */* __restrict  */)"w");
  }
#line 59
  if ((unsigned long )f == (unsigned long )((void *)0)) {
    {
#line 60
    perror("Error opening output file");
#line 61
    intelhex_fileclose(& ihex);
#line 62
    abort();
    }
  }
  {
#line 65
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 65
    tmp___4 = intelhex_readline(& ihex);
    }
#line 65
    if (! (tmp___4 == 1)) {
#line 65
      goto while_break;
    }
    {
#line 66
    sprintf((char */* __restrict  */)(l), (char const   */* __restrict  */)"%04X",
            ihex.offset);
#line 67
    i = 0;
    }
    {
#line 67
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 67
      if (! ((unsigned int )i < ihex.reclen)) {
#line 67
        goto while_break___0;
      }
      {
#line 68
      sprintf((char */* __restrict  */)(ll), (char const   */* __restrict  */)" %02X",
              (int )ihex.recdata[i]);
#line 69
      strcat((char */* __restrict  */)(l), (char const   */* __restrict  */)(ll));
#line 67
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 71
    strcat((char */* __restrict  */)(l), (char const   */* __restrict  */)"\n");
#line 72
    fputs((char const   */* __restrict  */)(l), (FILE */* __restrict  */)f);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 74
  intelhex_fileclose(& ihex);
#line 75
  fclose(f);
  }
#line 77
  return (0);
}
}
#line 622 "/usr/include/stdio.h"
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 65 "/home/june/repo/benchmarks/collector/temp/eep24c-0.1.2/intelhex.h"
int intelhex_writeline(inteldata *id ) ;
#line 68
void intelhex_writeeof(inteldata *id ) ;
#line 187 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 399 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 32 "/home/june/repo/benchmarks/collector/temp/eep24c-0.1.2/intelhex.c"
int intelhex_fileopen(inteldata *id , char *filename , int mode ) 
{ 


  {
#line 37
  if (mode == 0) {
    {
#line 38
    id->file = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"w");
    }
#line 39
    if ((unsigned long )id->file == (unsigned long )((void *)0)) {
      {
#line 40
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"File create error\n");
#line 41
      abort();
      }
    }
#line 42
    id->eof_found = 0;
#line 43
    return (1);
  }
  {
#line 45
  id->file = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 46
  if ((unsigned long )id->file == (unsigned long )((void *)0)) {
    {
#line 47
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error when opening the file \'%s\' for reading.\n",
            filename);
#line 48
    abort();
    }
  }
#line 49
  id->eof_found = 0;
#line 50
  return (1);
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/eep24c-0.1.2/intelhex.c"
int intelhex_fileclose(inteldata *id ) 
{ 
  int tmp ;

  {
  {
#line 54
  tmp = fclose(id->file);
  }
#line 54
  return (tmp);
}
}
#line 57 "/home/june/repo/benchmarks/collector/temp/eep24c-0.1.2/intelhex.c"
int intelhex_readline(inteldata *id ) 
{ 
  char line[526] ;
  char conv[5] ;
  int rectype ;
  int chksum ;
  int linelen ;
  int reccount ;
  int i ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  unsigned long tmp___6 ;

  {
#line 67
  if (id->eof_found == 1) {
#line 67
    return (0);
  }
  {
#line 68
  tmp = feof(id->file);
  }
#line 68
  if (tmp) {
    {
#line 69
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error in intelhex file - eof_record not found\n");
    }
#line 70
    return (2);
  }
  {
#line 73
  fgets((char */* __restrict  */)(line), 525, (FILE */* __restrict  */)id->file);
#line 76
  tmp___0 = strlen((char const   *)(line));
#line 76
  linelen = (int )tmp___0;
  }
#line 77
  if ((int )line[linelen - 2] == 13) {
    {
#line 79
    line[linelen - 2] = line[linelen - 1];
#line 80
    line[linelen - 1] = (char)0;
#line 81
    tmp___1 = strlen((char const   *)(line));
#line 81
    linelen = (int )tmp___1;
    }
  }
#line 83
  if ((int )line[linelen - 1] != 10) {
    {
#line 84
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error in intelhex file - linefeed not found at end of line\n");
    }
#line 85
    return (3);
  }
#line 88
  if ((int )line[0] != 58) {
    {
#line 89
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error in intelhex file - \':\' missing\n");
    }
#line 89
    return (4);
  }
#line 92
  if (linelen < 12) {
    {
#line 93
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error in intelhex file - less than 11 characters in a line\n");
    }
#line 94
    return (5);
  }
#line 97
  conv[2] = (char)0;
#line 97
  chksum = 0;
#line 98
  i = 1;
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if (! (i < linelen - 1)) {
#line 98
      goto while_break;
    }
    {
#line 99
    conv[0] = line[i];
#line 99
    conv[1] = line[i + 1];
#line 100
    tmp___2 = strtoul((char const   */* __restrict  */)(conv), (char **/* __restrict  */)((char **)((void *)0)),
                      16);
#line 100
    chksum += (int )tmp___2;
#line 98
    i += 2;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 101
  if (chksum % 256) {
    {
#line 102
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error in intelhex file - bad chksum\n");
    }
#line 102
    return (6);
  }
  {
#line 105
  conv[2] = (char)0;
#line 105
  i = 1;
#line 106
  conv[0] = line[i];
#line 106
  conv[1] = line[i + 1];
#line 106
  i += 2;
#line 107
  tmp___3 = strtoul((char const   */* __restrict  */)(conv), (char **/* __restrict  */)((char **)((void *)0)),
                    16);
#line 107
  id->reclen = (unsigned int )((int )tmp___3);
  }
#line 110
  if (id->reclen * 2U + 12U != (unsigned int )linelen) {
    {
#line 111
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error in intelhex file - number of characters doesn\'t match reclength\n");
    }
#line 112
    return (7);
  }
  {
#line 115
  conv[4] = (char)0;
#line 115
  conv[0] = line[i];
#line 115
  conv[1] = line[i + 1];
#line 116
  conv[2] = line[i + 2];
#line 116
  conv[3] = line[i + 3];
#line 116
  i += 4;
#line 117
  tmp___4 = strtoul((char const   */* __restrict  */)(conv), (char **/* __restrict  */)((char **)((void *)0)),
                    16);
#line 117
  id->offset = (unsigned int )((int )tmp___4);
#line 120
  conv[2] = (char)0;
#line 120
  conv[0] = line[i];
#line 120
  conv[1] = line[i + 1];
#line 120
  i += 2;
#line 121
  tmp___5 = strtoul((char const   */* __restrict  */)(conv), (char **/* __restrict  */)((char **)((void *)0)),
                    16);
#line 121
  rectype = (int )tmp___5;
  }
#line 124
  if (rectype == 1) {
#line 125
    id->eof_found = 1;
#line 126
    return (0);
  }
#line 129
  if (rectype != 0) {
    {
#line 130
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error in intelhex file - this program only accepts rectype 00(data) or 01(eof)\n");
    }
#line 131
    return (8);
  }
#line 134
  reccount = 0;
  {
#line 134
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 134
    if (! ((unsigned int )reccount < id->reclen)) {
#line 134
      goto while_break___0;
    }
    {
#line 135
    conv[0] = line[i];
#line 135
    conv[1] = line[i + 1];
#line 135
    i += 2;
#line 136
    tmp___6 = strtoul((char const   */* __restrict  */)(conv), (char **/* __restrict  */)((char **)((void *)0)),
                      16);
#line 136
    id->recdata[reccount] = (unsigned char )((int )tmp___6);
#line 134
    reccount ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 137
  return (1);
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/eep24c-0.1.2/intelhex.c"
int intelhex_writeline(inteldata *id ) 
{ 
  unsigned int chksum ;
  int reccount ;

  {
#line 143
  if (id->reclen == 0U) {
    {
#line 144
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error in intelhex file - offset/reclen invalid when writing file\n");
    }
#line 145
    return (0);
  } else
#line 143
  if (id->reclen > 255U) {
    {
#line 144
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error in intelhex file - offset/reclen invalid when writing file\n");
    }
#line 145
    return (0);
  } else
#line 143
  if (id->offset < 0U) {
    {
#line 144
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error in intelhex file - offset/reclen invalid when writing file\n");
    }
#line 145
    return (0);
  } else
#line 143
  if (id->offset > 65535U) {
    {
#line 144
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error in intelhex file - offset/reclen invalid when writing file\n");
    }
#line 145
    return (0);
  }
  {
#line 147
  fprintf((FILE */* __restrict  */)id->file, (char const   */* __restrict  */)":%02X%04X00",
          id->reclen, id->offset);
#line 148
  chksum = id->reclen;
#line 149
  chksum += id->offset % 256U;
#line 150
  chksum += id->offset / 256U;
#line 152
  reccount = 0;
  }
  {
#line 152
  while (1) {
    while_continue: /* CIL Label */ ;
#line 152
    if (! ((unsigned int )reccount < id->reclen)) {
#line 152
      goto while_break;
    }
    {
#line 153
    fprintf((FILE */* __restrict  */)id->file, (char const   */* __restrict  */)"%02X",
            (int )id->recdata[reccount]);
#line 154
    chksum += (unsigned int )id->recdata[reccount];
#line 152
    reccount ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 156
  chksum = 256U - chksum % 256U;
#line 157
  if (chksum == 256U) {
#line 157
    chksum = 0U;
  }
  {
#line 158
  fprintf((FILE */* __restrict  */)id->file, (char const   */* __restrict  */)"%02X",
          chksum);
#line 159
  fprintf((FILE */* __restrict  */)id->file, (char const   */* __restrict  */)"\n");
  }
#line 160
  return (1);
}
}
#line 163 "/home/june/repo/benchmarks/collector/temp/eep24c-0.1.2/intelhex.c"
void intelhex_writeeof(inteldata *id ) 
{ 


  {
  {
#line 164
  fprintf((FILE */* __restrict  */)id->file, (char const   */* __restrict  */)":00000001FF\n");
  }
#line 165
  return;
}
}
#line 348 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2), __leaf__)) strtok)(char * __restrict  __s ,
                                                                                               char const   * __restrict  __delim ) ;
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 54 "/home/june/repo/benchmarks/collector/temp/eep24c-0.1.2/parport.h"
parport_t *parport_init(long base_address ) ;
#line 55
void parport_destroy(parport_t *self ) ;
#line 57
int parport_readbit(parport_t *self , int bit ) ;
#line 58
unsigned int parport_readbyte(parport_t *self ) ;
#line 60
void parport_writebit(parport_t *self , int bit , unsigned int value ) ;
#line 61
void parport_writebyte(parport_t *self , unsigned int value ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 32 "/usr/include/x86_64-linux-gnu/sys/io.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioperm)(unsigned long __from ,
                                                                             unsigned long __num ,
                                                                             int __turn_on ) ;
#line 42 "/usr/include/x86_64-linux-gnu/sys/io.h"
__inline static unsigned char inb(unsigned short __port ) 
{ 
  unsigned char _v ;

  {
#line 47
  __asm__  volatile   ("inb %w1,%0": "=a" (_v): "Nd" (__port));
#line 48
  return (_v);
}
}
#line 95 "/usr/include/x86_64-linux-gnu/sys/io.h"
__inline static void outb(unsigned char __value , unsigned short __port ) 
{ 


  {
#line 98
  __asm__  volatile   ("outb %b0,%w1": : "a" (__value), "Nd" (__port));
#line 99
  return;
}
}
#line 678 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) geteuid)(void) ;
#line 40 "/home/june/repo/benchmarks/collector/temp/eep24c-0.1.2/parport.c"
parport_t *parport_init(long base_address ) 
{ 
  parport_t *self ;
  void *tmp ;
  __uid_t tmp___0 ;

  {
  {
#line 43
  tmp = malloc(sizeof(parport_t ));
#line 43
  self = (parport_t *)tmp;
  }
#line 44
  if (! ((unsigned long )self != (unsigned long )((void *)0))) {
    {
#line 44
    __assert_fail("self!=((void *)0)", "/home/june/repo/benchmarks/collector/temp/eep24c-0.1.2/parport.c",
                  44U, "parport_init");
    }
  }
  {
#line 45
  self->base_address = base_address;
#line 46
  self->last_write = (unsigned int )(~ 0);
#line 48
  tmp___0 = geteuid();
  }
#line 48
  if (tmp___0 != 0U) {
    {
#line 49
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR: this programs needs root permisions to access parallel port. Please use root user to run or setuid bit.\n");
#line 50
    abort();
    }
  }
  {
#line 52
  ioperm((unsigned long )self->base_address, 3UL, 1);
  }
#line 54
  return (self);
}
}
#line 57 "/home/june/repo/benchmarks/collector/temp/eep24c-0.1.2/parport.c"
void parport_destroy(parport_t *self ) 
{ 


  {
#line 58
  if ((unsigned long )self != (unsigned long )((void *)0)) {
    {
#line 60
    ioperm((unsigned long )self->base_address, 3UL, 0);
#line 62
    free((void *)self);
    }
  }
#line 64
  return;
}
}
#line 66 "/home/june/repo/benchmarks/collector/temp/eep24c-0.1.2/parport.c"
int parport_readbit(parport_t *self , int bit ) 
{ 
  int i ;
  unsigned int tmp ;

  {
  {
#line 68
  tmp = parport_readbyte(self);
#line 68
  i = (int )tmp;
  }
#line 69
  if (i & (1 << bit)) {
#line 70
    return (1);
  }
#line 71
  return (0);
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/eep24c-0.1.2/parport.c"
unsigned int parport_readbyte(parport_t *self ) 
{ 
  unsigned char tmp ;

  {
  {
#line 75
  tmp = inb((unsigned short )(self->base_address + 1L));
  }
#line 75
  return ((unsigned int )tmp);
}
}
#line 82 "/home/june/repo/benchmarks/collector/temp/eep24c-0.1.2/parport.c"
void parport_writebit(parport_t *self , int bit , unsigned int value ) 
{ 
  int i ;

  {
#line 84
  i = (int )self->last_write;
#line 85
  if (value) {
#line 86
    i |= 1 << bit;
  } else {
#line 88
    i &= ~ (1 << bit);
  }
  {
#line 90
  parport_writebyte(self, (unsigned int )i);
  }
#line 91
  return;
}
}
#line 93 "/home/june/repo/benchmarks/collector/temp/eep24c-0.1.2/parport.c"
void parport_writebyte(parport_t *self , unsigned int value ) 
{ 


  {
#line 95
  if ((value & 255U) != (self->last_write & 255U)) {
    {
#line 96
    outb((unsigned char )(value & 255U), (unsigned short )self->base_address);
    }
  }
#line 97
  if ((value & 3840U) != (self->last_write & 3840U)) {
    {
#line 98
    outb((unsigned char )((value >> 8) & 15U), (unsigned short )(self->base_address + 2L));
    }
  }
#line 106
  self->last_write = value;
#line 107
  return;
}
}
#line 27 "/home/june/repo/benchmarks/collector/temp/eep24c-0.1.2/mcdelay.h"
void microdelay_init(unsigned int multiply_factor ) ;
#line 28
void microdelay(unsigned int microsec ) ;
#line 43 "/home/june/repo/benchmarks/collector/temp/eep24c-0.1.2/mcdelay.c"
int old_port_value  ;
#line 44 "/home/june/repo/benchmarks/collector/temp/eep24c-0.1.2/mcdelay.c"
unsigned int m_f  ;
#line 46 "/home/june/repo/benchmarks/collector/temp/eep24c-0.1.2/mcdelay.c"
void microdelay_init(unsigned int multiply_factor ) 
{ 
  __uid_t tmp ;
  unsigned char tmp___0 ;

  {
  {
#line 53
  tmp = geteuid();
  }
#line 53
  if (tmp != 0U) {
    {
#line 54
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR: this programs needs root permisions to access parallel port. Please use root user to run or setuid bit.\n");
#line 55
    abort();
    }
  }
  {
#line 57
  ioperm(128UL, 1UL, 1);
#line 58
  tmp___0 = inb((unsigned short)128);
#line 58
  old_port_value = (int )tmp___0;
#line 60
  m_f = multiply_factor;
  }
#line 61
  return;
}
}
#line 63 "/home/june/repo/benchmarks/collector/temp/eep24c-0.1.2/mcdelay.c"
void microdelay(unsigned int microsec ) 
{ 
  unsigned long i ;

  {
#line 65
  i = (unsigned long )(m_f * microsec);
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 66
    if (! i) {
#line 66
      goto while_break;
    }
    {
#line 71
    outb((unsigned char )old_port_value, (unsigned short)128);
#line 73
    i --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 75
  return;
}
}
#line 33 "/home/june/repo/benchmarks/collector/temp/eep24c-0.1.2/memory.h"
int memory_read(memory_t *self , unsigned int addr ) ;
#line 34
void memory_write(memory_t *self , unsigned int addr , int value ) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/eep24c-0.1.2/eeprom.h"
eeprom_t *eeprom_init(unsigned long parallel_port_address , unsigned long write_size ,
                      unsigned int addr_size , unsigned long read_size , unsigned long total_size ,
                      unsigned char inv_page , unsigned int microdelay_factor ) ;
#line 65
void eeprom_destroy(eeprom_t *self ) ;
#line 68
int eeprom_fullread(eeprom_t *self , memory_t *mem ) ;
#line 69
int eeprom_fullwrite(eeprom_t *self , memory_t *mem ) ;
#line 70
void eeprom_power(eeprom_t *self , int poweron ) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 39 "/home/june/repo/benchmarks/collector/temp/eep24c-0.1.2/eeprom.c"
void exit_error(eeprom_t *eep , int status , char *s ) ;
#line 40
void eeprom_startbit(eeprom_t *self ) ;
#line 41
void eeprom_stopbit(eeprom_t *self ) ;
#line 42
void eeprom_writebit(eeprom_t *self , int value ) ;
#line 43
int eeprom_readbit(eeprom_t *self ) ;
#line 44
int eeprom_controlbyte(eeprom_t *self , int page , int readmode ) ;
#line 45
int eeprom_getbyte(eeprom_t *self ) ;
#line 46
void eeprom_sendbyte(eeprom_t *self , int value ) ;
#line 48 "/home/june/repo/benchmarks/collector/temp/eep24c-0.1.2/eeprom.c"
void exit_error(eeprom_t *eep , int status , char *s ) 
{ 


  {
  {
#line 49
  eeprom_destroy(eep);
#line 50
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          s);
#line 51
  exit(status);
  }
}
}
#line 54 "/home/june/repo/benchmarks/collector/temp/eep24c-0.1.2/eeprom.c"
eeprom_t *eeprom_init(unsigned long parallel_port_address , unsigned long write_size ,
                      unsigned int addr_size , unsigned long read_size , unsigned long total_size ,
                      unsigned char inv_page , unsigned int microdelay_factor ) 
{ 
  eeprom_t *self ;
  void *tmp ;

  {
  {
#line 62
  microdelay_init(microdelay_factor);
#line 63
  tmp = malloc(sizeof(eeprom_t ));
#line 63
  self = (eeprom_t *)tmp;
  }
#line 64
  if (! ((unsigned long )self != (unsigned long )((void *)0))) {
    {
#line 64
    __assert_fail("self!=((void *)0)", "/home/june/repo/benchmarks/collector/temp/eep24c-0.1.2/eeprom.c",
                  64U, "eeprom_init");
    }
  }
  {
#line 65
  self->pp = parport_init((long )parallel_port_address);
#line 66
  self->write_size = write_size;
#line 67
  self->addr_size = addr_size;
#line 68
  self->read_size = read_size;
#line 69
  self->total_size = total_size;
#line 70
  self->inv_page = inv_page;
#line 73
  eeprom_power(self, 0);
  }
#line 75
  return (self);
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/eep24c-0.1.2/eeprom.c"
void eeprom_destroy(eeprom_t *self ) 
{ 


  {
#line 79
  if ((unsigned long )self != (unsigned long )((void *)0)) {
    {
#line 80
    eeprom_power(self, 0);
#line 81
    parport_destroy(self->pp);
#line 82
    free((void *)self);
    }
  }
#line 84
  return;
}
}
#line 94 "/home/june/repo/benchmarks/collector/temp/eep24c-0.1.2/eeprom.c"
int eeprom_fullread(eeprom_t *self , memory_t *mem ) 
{ 
  int i ;
  int addr ;
  int total_pages ;
  int current_page ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 95
  addr = 0;
#line 96
  total_pages = 0;
#line 97
  current_page = 0;
#line 99
  eeprom_power(self, 1);
#line 101
  total_pages = (int )(self->total_size / self->read_size);
#line 102
  current_page = 0;
  }
  {
#line 102
  while (1) {
    while_continue: /* CIL Label */ ;
#line 102
    if (! (current_page < total_pages)) {
#line 102
      goto while_break;
    }
    {
#line 105
    tmp = eeprom_controlbyte(self, current_page, 0);
    }
#line 105
    if (tmp == 0) {
      {
#line 106
      exit_error(self, 32, (char *)"read error - control byte failed");
      }
    }
#line 107
    i = 0;
    {
#line 107
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 107
      if (! ((unsigned int )i < self->addr_size)) {
#line 107
        goto while_break___0;
      }
      {
#line 108
      eeprom_sendbyte(self, 0);
#line 109
      tmp___0 = eeprom_readbit(self);
      }
#line 109
      if (tmp___0 != 0) {
        {
#line 110
        exit_error(self, 33, (char *)"read error - ACK not received");
        }
      }
#line 107
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 114
    eeprom_controlbyte(self, current_page, 1);
#line 115
    addr = 0;
    }
    {
#line 115
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 115
      if (! ((unsigned long )addr < self->read_size)) {
#line 115
        goto while_break___1;
      }
#line 116
      if (addr != 0) {
        {
#line 117
        eeprom_writebit(self, 0);
        }
      }
      {
#line 119
      tmp___1 = eeprom_getbyte(self);
#line 119
      memory_write(mem, (unsigned int )((unsigned long )addr + self->read_size * (unsigned long )current_page),
                   tmp___1);
#line 115
      addr ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 123
    tmp___2 = eeprom_readbit(self);
    }
#line 123
    if (tmp___2 == 0) {
      {
#line 124
      exit_error(self, 34, (char *)"read error - NOACK not received");
      }
    }
    {
#line 126
    eeprom_stopbit(self);
#line 128
    i = 0;
    }
    {
#line 128
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 128
      if (! (i < 16)) {
#line 128
        goto while_break___2;
      }
      {
#line 129
      parport_writebit(self->pp, 0, 1U);
#line 130
      microdelay(25U);
#line 131
      parport_writebit(self->pp, 0, 0U);
#line 132
      microdelay(25U);
#line 128
      i ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 102
    current_page ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 136
  eeprom_power(self, 0);
  }
#line 137
  return (1);
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/eep24c-0.1.2/eeprom.c"
int eeprom_fullwrite(eeprom_t *self , memory_t *mem ) 
{ 
  int i ;
  int addr ;
  int total_pages ;
  int current_page ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int timeout ;
  int ack ;
  int i___0 ;
  int tmp___2 ;

  {
  {
#line 144
  total_pages = 0;
#line 145
  current_page = 0;
#line 147
  eeprom_power(self, 1);
#line 149
  total_pages = (int )(self->total_size / self->read_size);
#line 151
  current_page = 0;
  }
  {
#line 151
  while (1) {
    while_continue: /* CIL Label */ ;
#line 151
    if (! (current_page < total_pages)) {
#line 151
      goto while_break;
    }
#line 153
    addr = 0;
    {
#line 153
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 153
      if (! ((unsigned long )addr < self->read_size)) {
#line 153
        goto while_break___0;
      }
      {
#line 155
      tmp = eeprom_controlbyte(self, current_page, 0);
      }
#line 155
      if (tmp == 0) {
        {
#line 156
        exit_error(self, 48, (char *)"write error - control byte failed");
        }
      }
#line 159
      i = (int )(self->addr_size - 1U);
      {
#line 159
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 159
        if (! (i >= 0)) {
#line 159
          goto while_break___1;
        }
        {
#line 160
        eeprom_sendbyte(self, 255 & (addr >> i * 8));
#line 161
        tmp___0 = eeprom_readbit(self);
        }
#line 161
        if (tmp___0 != 0) {
          {
#line 162
          exit_error(self, 49, (char *)"write error - ACK not received");
          }
        }
#line 159
        i --;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 165
      i = addr;
      {
#line 165
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 165
        if (! ((unsigned long )i < (unsigned long )addr + self->write_size)) {
#line 165
          goto while_break___2;
        }
        {
#line 166
        tmp___1 = memory_read(mem, (unsigned int )((unsigned long )i + self->read_size * (unsigned long )current_page));
#line 166
        eeprom_sendbyte(self, tmp___1);
#line 169
        eeprom_writebit(self, 0);
#line 165
        i ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 172
      eeprom_stopbit(self);
#line 176
      timeout = 10000;
#line 176
      ack = 0;
      }
      {
#line 177
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 177
        if (timeout > 0) {
#line 177
          if (! (ack == 0)) {
#line 177
            goto while_break___3;
          }
        } else {
#line 177
          goto while_break___3;
        }
        {
#line 178
        timeout --;
#line 179
        tmp___2 = eeprom_controlbyte(self, 0, 1);
        }
#line 179
        if (tmp___2) {
#line 180
          ack = 1;
        }
        {
#line 181
        eeprom_stopbit(self);
#line 182
        i___0 = 0;
        }
        {
#line 182
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 182
          if (! (i___0 < 80)) {
#line 182
            goto while_break___4;
          }
          {
#line 183
          parport_writebit(self->pp, 0, 1U);
#line 184
          microdelay(25U);
#line 185
          parport_writebit(self->pp, 0, 0U);
#line 186
          microdelay(25U);
          }
#line 187
          if (i___0 == 40) {
            {
#line 188
            eeprom_stopbit(self);
            }
          }
#line 182
          i___0 ++;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 191
      if (ack == 0) {
        {
#line 192
        exit_error(self, 50, (char *)"write error - ACK pooling not received");
        }
      }
#line 153
      addr = (int )((unsigned long )addr + self->write_size);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 151
    current_page ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 197
  eeprom_power(self, 0);
  }
#line 199
  return (1);
}
}
#line 203 "/home/june/repo/benchmarks/collector/temp/eep24c-0.1.2/eeprom.c"
void eeprom_power(eeprom_t *self , int poweron ) 
{ 
  int i ;

  {
#line 204
  if (poweron) {
    {
#line 207
    parport_writebyte(self->pp, 255U);
#line 208
    parport_writebit(self->pp, 1, 0U);
#line 209
    microdelay(250000U);
#line 211
    i = 0;
    }
    {
#line 211
    while (1) {
      while_continue: /* CIL Label */ ;
#line 211
      if (! (i < 256)) {
#line 211
        goto while_break;
      }
      {
#line 212
      parport_writebit(self->pp, 0, 1U);
#line 213
      microdelay(25U);
#line 214
      parport_writebit(self->pp, 0, 0U);
#line 215
      microdelay(25U);
#line 211
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 219
    parport_writebyte(self->pp, 0U);
#line 220
    parport_writebit(self->pp, 1, 1U);
    }
  }
#line 222
  return;
}
}
#line 224 "/home/june/repo/benchmarks/collector/temp/eep24c-0.1.2/eeprom.c"
void eeprom_startbit(eeprom_t *self ) 
{ 


  {
  {
#line 226
  parport_writebit(self->pp, 0, 1U);
#line 227
  microdelay(25U);
#line 228
  parport_writebit(self->pp, 1, 1U);
#line 229
  microdelay(25U);
#line 230
  parport_writebit(self->pp, 0, 0U);
#line 231
  microdelay(25U);
#line 232
  parport_writebit(self->pp, 1, 0U);
#line 233
  microdelay(25U);
  }
#line 234
  return;
}
}
#line 236 "/home/june/repo/benchmarks/collector/temp/eep24c-0.1.2/eeprom.c"
void eeprom_stopbit(eeprom_t *self ) 
{ 


  {
  {
#line 238
  parport_writebit(self->pp, 1, 1U);
#line 239
  microdelay(25U);
#line 240
  parport_writebit(self->pp, 0, 1U);
#line 241
  microdelay(25U);
#line 242
  parport_writebit(self->pp, 1, 0U);
#line 243
  microdelay(25U);
#line 244
  parport_writebit(self->pp, 0, 0U);
#line 245
  microdelay(25U);
  }
#line 246
  return;
}
}
#line 248 "/home/june/repo/benchmarks/collector/temp/eep24c-0.1.2/eeprom.c"
void eeprom_writebit(eeprom_t *self , int value ) 
{ 


  {
#line 249
  if (value) {
    {
#line 250
    parport_writebit(self->pp, 0, 1U);
#line 251
    microdelay(25U);
#line 252
    parport_writebit(self->pp, 0, 0U);
#line 253
    microdelay(25U);
    }
  } else {
    {
#line 255
    parport_writebit(self->pp, 1, 1U);
#line 256
    microdelay(25U);
#line 257
    parport_writebit(self->pp, 0, 1U);
#line 258
    microdelay(25U);
#line 259
    parport_writebit(self->pp, 0, 0U);
#line 260
    microdelay(25U);
#line 261
    parport_writebit(self->pp, 1, 0U);
#line 262
    microdelay(25U);
    }
  }
#line 264
  return;
}
}
#line 266 "/home/june/repo/benchmarks/collector/temp/eep24c-0.1.2/eeprom.c"
int eeprom_readbit(eeprom_t *self ) 
{ 
  int i ;

  {
  {
#line 268
  parport_writebit(self->pp, 0, 1U);
#line 269
  microdelay(25U);
#line 270
  i = parport_readbit(self->pp, 3);
#line 271
  microdelay(25U);
#line 272
  parport_writebit(self->pp, 0, 0U);
#line 273
  microdelay(25U);
  }
#line 274
  return (i);
}
}
#line 277 "/home/june/repo/benchmarks/collector/temp/eep24c-0.1.2/eeprom.c"
int eeprom_controlbyte(eeprom_t *self , int page , int readmode ) 
{ 
  int tmp ;

  {
  {
#line 278
  eeprom_startbit(self);
#line 281
  eeprom_writebit(self, 1);
#line 282
  eeprom_writebit(self, 0);
#line 283
  eeprom_writebit(self, 1);
#line 284
  eeprom_writebit(self, 0);
  }
#line 287
  if ((int )self->inv_page != 0) {
    {
#line 288
    eeprom_writebit(self, page & 1);
#line 289
    eeprom_writebit(self, page & 2);
#line 290
    eeprom_writebit(self, page & 4);
    }
  } else {
    {
#line 292
    eeprom_writebit(self, page & 4);
#line 293
    eeprom_writebit(self, page & 2);
#line 294
    eeprom_writebit(self, page & 1);
    }
  }
  {
#line 297
  eeprom_writebit(self, readmode);
#line 300
  tmp = eeprom_readbit(self);
  }
#line 300
  if (tmp != 0) {
#line 300
    return (0);
  }
#line 301
  return (1);
}
}
#line 304 "/home/june/repo/benchmarks/collector/temp/eep24c-0.1.2/eeprom.c"
int eeprom_getbyte(eeprom_t *self ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 305
  i = 0;
#line 306
  tmp = eeprom_readbit(self);
#line 306
  i |= tmp << 7;
#line 307
  tmp___0 = eeprom_readbit(self);
#line 307
  i |= tmp___0 << 6;
#line 308
  tmp___1 = eeprom_readbit(self);
#line 308
  i |= tmp___1 << 5;
#line 309
  tmp___2 = eeprom_readbit(self);
#line 309
  i |= tmp___2 << 4;
#line 310
  tmp___3 = eeprom_readbit(self);
#line 310
  i |= tmp___3 << 3;
#line 311
  tmp___4 = eeprom_readbit(self);
#line 311
  i |= tmp___4 << 2;
#line 312
  tmp___5 = eeprom_readbit(self);
#line 312
  i |= tmp___5 << 1;
#line 313
  tmp___6 = eeprom_readbit(self);
#line 313
  i |= tmp___6;
  }
#line 314
  return (i);
}
}
#line 317 "/home/june/repo/benchmarks/collector/temp/eep24c-0.1.2/eeprom.c"
void eeprom_sendbyte(eeprom_t *self , int value ) 
{ 


  {
  {
#line 318
  eeprom_writebit(self, value & 128);
#line 319
  eeprom_writebit(self, value & 64);
#line 320
  eeprom_writebit(self, value & 32);
#line 321
  eeprom_writebit(self, value & 16);
#line 322
  eeprom_writebit(self, value & 8);
#line 323
  eeprom_writebit(self, value & 4);
#line 324
  eeprom_writebit(self, value & 2);
#line 325
  eeprom_writebit(self, value & 1);
  }
#line 326
  return;
}
}
#line 30 "/home/june/repo/benchmarks/collector/temp/eep24c-0.1.2/memory.h"
memory_t *memory_init(unsigned long size ) ;
#line 31
void memory_destroy(memory_t *self ) ;
#line 32
void memory_fill(memory_t *self , int value ) ;
#line 35
int memory_compare(memory_t *mem1 , memory_t *mem2 ) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/eep24c-0.1.2/memory.c"
memory_t *memory_init(unsigned long size ) 
{ 
  memory_t *self ;
  int *data ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 31
  tmp = malloc(sizeof(memory_t *));
#line 31
  self = (memory_t *)tmp;
  }
#line 32
  if (! ((unsigned long )self != (unsigned long )((void *)0))) {
    {
#line 32
    __assert_fail("self!=((void *)0)", "/home/june/repo/benchmarks/collector/temp/eep24c-0.1.2/memory.c",
                  32U, "memory_init");
    }
  }
#line 33
  if (! (size > 0UL)) {
    {
#line 33
    __assert_fail("size>0", "/home/june/repo/benchmarks/collector/temp/eep24c-0.1.2/memory.c",
                  33U, "memory_init");
    }
  }
  {
#line 34
  tmp___0 = malloc(sizeof(int ) * size);
#line 34
  data = (int *)tmp___0;
  }
#line 35
  if (! ((unsigned long )data != (unsigned long )((void *)0))) {
    {
#line 35
    __assert_fail("data!=((void *)0)", "/home/june/repo/benchmarks/collector/temp/eep24c-0.1.2/memory.c",
                  35U, "memory_init");
    }
  }
#line 36
  self->size = size;
#line 37
  self->data = data;
#line 38
  return (self);
}
}
#line 41 "/home/june/repo/benchmarks/collector/temp/eep24c-0.1.2/memory.c"
void memory_destroy(memory_t *self ) 
{ 


  {
#line 42
  if ((unsigned long )self != (unsigned long )((void *)0)) {
#line 43
    if ((unsigned long )self->data != (unsigned long )((void *)0)) {
      {
#line 44
      free((void *)self->data);
      }
    }
    {
#line 46
    free((void *)self);
    }
  }
#line 48
  return;
}
}
#line 50 "/home/june/repo/benchmarks/collector/temp/eep24c-0.1.2/memory.c"
void memory_fill(memory_t *self , int value ) 
{ 
  int i ;

  {
#line 52
  i = 0;
  {
#line 52
  while (1) {
    while_continue: /* CIL Label */ ;
#line 52
    if (! ((unsigned long )i < self->size)) {
#line 52
      goto while_break;
    }
#line 53
    *(self->data + i) = value;
#line 52
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 55
  return;
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/eep24c-0.1.2/memory.c"
int memory_read(memory_t *self , unsigned int addr ) 
{ 


  {
#line 59
  if (! (self->size > (unsigned long )addr)) {
    {
#line 59
    __assert_fail("self->size > addr", "/home/june/repo/benchmarks/collector/temp/eep24c-0.1.2/memory.c",
                  59U, "memory_read");
    }
  }
#line 60
  return (*(self->data + addr));
}
}
#line 63 "/home/june/repo/benchmarks/collector/temp/eep24c-0.1.2/memory.c"
void memory_write(memory_t *self , unsigned int addr , int value ) 
{ 


  {
#line 64
  if (! (self->size > (unsigned long )addr)) {
    {
#line 64
    __assert_fail("self->size > addr", "/home/june/repo/benchmarks/collector/temp/eep24c-0.1.2/memory.c",
                  64U, "memory_write");
    }
  }
#line 65
  *(self->data + addr) = value;
#line 66
  return;
}
}
#line 68 "/home/june/repo/benchmarks/collector/temp/eep24c-0.1.2/memory.c"
int memory_compare(memory_t *mem1 , memory_t *mem2 ) 
{ 
  unsigned int i ;

  {
#line 70
  if (mem1->size != mem2->size) {
#line 71
    return (0);
  }
#line 72
  i = 0U;
  {
#line 72
  while (1) {
    while_continue: /* CIL Label */ ;
#line 72
    if (! ((unsigned long )i < mem1->size)) {
#line 72
      goto while_break;
    }
#line 73
    if (*(mem1->data + i) != *(mem2->data + i)) {
#line 74
      return (0);
    }
#line 72
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 77
  return (1);
}
}
#line 147 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 30 "/home/june/repo/benchmarks/collector/temp/eep24c-0.1.2/conf.c"
unsigned long parport_baseaddress(void) 
{ 
  FILE *f ;
  char l[1024] ;
  unsigned long pp ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 33
  pp = 0UL;
#line 48
  f = fopen((char const   */* __restrict  */)"/etc/eep24c/eep24c.cfg", (char const   */* __restrict  */)"r");
  }
#line 49
  if ((unsigned long )f == (unsigned long )((void *)0)) {
    {
#line 50
    perror("could not open configuration file /etc/eep24c/eep24c.cfg");
#line 51
    abort();
    }
  }
  {
#line 56
  fgets((char */* __restrict  */)(l), 1023, (FILE */* __restrict  */)f);
  }
  {
#line 57
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 57
    tmp___0 = feof(f);
    }
#line 57
    if (! (tmp___0 == 0)) {
#line 57
      goto while_break;
    }
    {
#line 58
    tmp = strncmp((char const   *)(l), "parport_address", (size_t )15);
    }
#line 58
    if (tmp == 0) {
      {
#line 59
      pp = strtoul((char const   */* __restrict  */)(l + 15), (char **/* __restrict  */)((void *)0),
                   16);
      }
    }
    {
#line 61
    fgets((char */* __restrict  */)(l), 1023, (FILE */* __restrict  */)f);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 64
  if (pp == 0UL) {
    {
#line 65
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"did not understand config file.\nconfiguration must have a line similar with the line below:\nparport_address 378\n");
#line 68
    abort();
    }
  }
#line 70
  return (pp);
}
}
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 38 "/home/june/repo/benchmarks/collector/temp/eep24c-0.1.2/eep24c.c"
int mem_to_ihex(char *filename , memory_t *mem ) ;
#line 39
int ihex_to_mem(char *filename , memory_t *mem ) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/eep24c-0.1.2/eep24c.c"
int mem_to_ihex(char *filename , memory_t *mem ) 
{ 
  inteldata ihex ;
  int reclen ;
  unsigned int size ;
  unsigned int i ;
  unsigned int j ;
  int tmp ;

  {
#line 43
  reclen = 16;
#line 46
  size = (unsigned int )mem->size;
#line 48
  if (! (size % (unsigned int )reclen == 0U)) {
    {
#line 48
    __assert_fail("(size%reclen) == 0", "/home/june/repo/benchmarks/collector/temp/eep24c-0.1.2/eep24c.c",
                  48U, "mem_to_ihex");
    }
  }
  {
#line 50
  intelhex_fileopen(& ihex, filename, 0);
#line 51
  ihex.reclen = (unsigned int )reclen;
#line 52
  i = 0U;
  }
  {
#line 52
  while (1) {
    while_continue: /* CIL Label */ ;
#line 52
    if (! (i < size)) {
#line 52
      goto while_break;
    }
#line 53
    ihex.offset = i;
#line 54
    j = 0U;
    {
#line 54
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 54
      if (! (j < (unsigned int )reclen)) {
#line 54
        goto while_break___0;
      }
      {
#line 55
      tmp = memory_read(mem, i + j);
#line 55
      ihex.recdata[j] = (unsigned char )tmp;
#line 54
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 57
    intelhex_writeline(& ihex);
#line 52
    i += (unsigned int )reclen;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 59
  intelhex_writeeof(& ihex);
#line 60
  intelhex_fileclose(& ihex);
  }
#line 61
  return (1);
}
}
#line 64 "/home/june/repo/benchmarks/collector/temp/eep24c-0.1.2/eep24c.c"
int ihex_to_mem(char *filename , memory_t *mem ) 
{ 
  inteldata ihex ;
  int i ;
  int tmp ;

  {
  {
#line 67
  intelhex_fileopen(& ihex, filename, 1);
  }
  {
#line 68
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 68
    tmp = intelhex_readline(& ihex);
    }
#line 68
    if (! (tmp == 1)) {
#line 68
      goto while_break;
    }
#line 69
    i = 0;
    {
#line 69
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 69
      if (! ((unsigned int )i < ihex.reclen)) {
#line 69
        goto while_break___0;
      }
      {
#line 70
      memory_write(mem, ihex.offset + (unsigned int )i, (int )ihex.recdata[i]);
#line 69
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 73
  intelhex_fileclose(& ihex);
  }
#line 74
  return (1);
}
}
