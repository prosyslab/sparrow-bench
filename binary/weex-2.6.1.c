/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 10 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/shhopt.h"
enum __anonenum_optArgType_26 {
    OPT_END = 0,
    OPT_FLAG = 1,
    OPT_STRING = 2,
    OPT_INT = 3,
    OPT_UINT = 4,
    OPT_LONG = 5,
    OPT_ULONG = 6
} ;
#line 10 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/shhopt.h"
typedef enum __anonenum_optArgType_26 optArgType;
#line 23 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/shhopt.h"
struct __anonstruct_optStruct_27 {
   char shortName ;
   char *longName ;
   optArgType type ;
   void *arg ;
   int flags ;
};
#line 23 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/shhopt.h"
typedef struct __anonstruct_optStruct_27 optStruct;
#line 66 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/ftplib.h"
struct NetBuf;
#line 66 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/ftplib.h"
typedef struct NetBuf netbuf;
#line 83 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/parsecfg.h"
struct cfglist;
#line 83 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/parsecfg.h"
typedef struct cfglist *cfgListPtr;
#line 84 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/parsecfg.h"
struct cfglist {
   char *str ;
   cfgListPtr next ;
};
#line 84 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/parsecfg.h"
typedef struct cfglist cfgList;
#line 43 "/usr/include/regex.h"
typedef unsigned long reg_syntax_t;
#line 368 "/usr/include/regex.h"
struct re_pattern_buffer {
   unsigned char *__buffer ;
   unsigned long __allocated ;
   unsigned long __used ;
   reg_syntax_t __syntax ;
   char *__fastmap ;
   unsigned char *__translate ;
   size_t re_nsub ;
   unsigned int __can_be_null : 1 ;
   unsigned int __regs_allocated : 2 ;
   unsigned int __fastmap_accurate : 1 ;
   unsigned int __no_sub : 1 ;
   unsigned int __not_bol : 1 ;
   unsigned int __not_eol : 1 ;
   unsigned int __newline_anchor : 1 ;
};
#line 434 "/usr/include/regex.h"
typedef struct re_pattern_buffer regex_t;
#line 437 "/usr/include/regex.h"
typedef int regoff_t;
#line 463 "/usr/include/regex.h"
struct __anonstruct_regmatch_t_22 {
   regoff_t rm_so ;
   regoff_t rm_eo ;
};
#line 463 "/usr/include/regex.h"
typedef struct __anonstruct_regmatch_t_22 regmatch_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 41 "/usr/include/fcntl.h"
typedef __mode_t mode_t;
#line 60 "/usr/include/fcntl.h"
typedef __pid_t pid_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 47 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/parsecfg.h"
enum __anonenum_cfgFileType_29 {
    CFG_SIMPLE = 0,
    CFG_INI = 1
} ;
#line 47 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/parsecfg.h"
typedef enum __anonenum_cfgFileType_29 cfgFileType;
#line 53
enum __anonenum_cfgValueType_30 {
    CFG_END = 0,
    CFG_BOOL = 1,
    CFG_STRING = 2,
    CFG_INT = 3,
    CFG_UINT = 4,
    CFG_LONG = 5,
    CFG_ULONG = 6,
    CFG_STRING_LIST = 7
} ;
#line 53 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/parsecfg.h"
typedef enum __anonenum_cfgValueType_30 cfgValueType;
#line 77 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/parsecfg.h"
struct __anonstruct_cfgStruct_33 {
   char *parameterName ;
   cfgValueType type ;
   void *value ;
};
#line 77 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/parsecfg.h"
typedef struct __anonstruct_cfgStruct_33 cfgStruct;
#line 31
enum __anonenum_cfgErrorCode_25 {
    CFG_NO_ERROR = 0,
    CFG_OPEN_FAIL = 1,
    CFG_CREATE_FAIL = 2,
    CFG_SYNTAX_ERROR = 3,
    CFG_WRONG_PARAMETER = 4,
    CFG_INTERNAL_ERROR = 5,
    CFG_INVALID_NUMBER = 6,
    CFG_OUT_OF_RANGE = 7,
    CFG_MEM_ALLOC_FAIL = 8,
    CFG_BOOL_ERROR = 9,
    CFG_USED_SECTION = 10,
    CFG_NO_CLOSING_BRACE = 11
} ;
#line 31 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/parsecfg.h"
typedef enum __anonenum_cfgErrorCode_25 cfgErrorCode;
#line 64
enum __anonenum_cfgKeywordValue_28 {
    CFG_PARAMETER = 0,
    CFG_VALUE = 1,
    CFG_SECTION = 2
} ;
#line 64 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/parsecfg.h"
typedef enum __anonenum_cfgKeywordValue_28 cfgKeywordValue;
#line 70
enum __anonenum_cfgQuote_29 {
    CFG_NO_QUOTE = 0,
    CFG_SINGLE_QUOTE = 1,
    CFG_DOUBLE_QUOTE = 2
} ;
#line 70 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/parsecfg.h"
typedef enum __anonenum_cfgQuote_29 cfgQuote;
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 45 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/variable.h"
enum __anonenum_LocalOrRemote_33 {
    LOCAL = 0,
    REMOTE = 1
} ;
#line 45 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/variable.h"
typedef enum __anonenum_LocalOrRemote_33 LocalOrRemote;
#line 65 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/variable.h"
struct __anonstruct_FileData_37 {
   char *name ;
   long date ;
   long time ;
   int isdir ;
};
#line 65 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/variable.h"
typedef struct __anonstruct_FileData_37 FileData;
#line 53 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/variable.h"
struct __anonstruct_Cache_33 {
   char *name ;
   long date ;
   long time ;
};
#line 53 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/variable.h"
typedef struct __anonstruct_Cache_33 Cache;
#line 59 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/variable.h"
struct __anonstruct_Cache_dir_34 {
   char *name ;
   int max_file ;
   Cache *ptr ;
};
#line 59 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/variable.h"
typedef struct __anonstruct_Cache_dir_34 Cache_dir;
#line 49
enum __anonenum_Message_13 {
    CONNECT = 0,
    DISCONNECT = 1,
    ENTER = 2,
    LEAVE = 3,
    ASCII_SEND = 4,
    BINARY_SEND = 5,
    CHMOD = 6,
    REMOVE = 7,
    MKDIR = 8,
    ASCII_LOWER_SEND = 9,
    BINARY_LOWER_SEND = 10,
    PROCESS = 11
} ;
#line 49 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/variable.h"
typedef enum __anonenum_Message_13 Message;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 220 "/usr/include/unistd.h"
typedef __ssize_t ssize_t;
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_28 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_28 fd_set;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 379 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct linger {
   int l_onoff ;
   int l_linger ;
};
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 100 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 257 "/usr/include/netdb.h"
struct servent {
   char *s_name ;
   char **s_aliases ;
   int s_port ;
   char *s_proto ;
};
#line 94 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/ftplib.c"
struct NetBuf {
   char *cput ;
   char *cget ;
   int handle ;
   int cavail ;
   int cleft ;
   char *buf ;
   int dir ;
   netbuf *ctrl ;
   int cmode ;
   struct timeval idletime ;
   int (*idlecb)(netbuf *nControl , int xfered , void *arg ) ;
   void *idlearg ;
   int xfered ;
   int cbbytes ;
   int xfered1 ;
   char response[256] ;
};
#line 653 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/ftplib.c"
union __anonunion_sin_47 {
   struct sockaddr sa ;
   struct sockaddr_in in ;
};
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 379
extern  __attribute__((__nothrow__)) int vsprintf(char * __restrict  __s , char const   * __restrict  __format ,
                                                  __gnuc_va_list __arg ) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 50 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 124 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 44 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) dgettext)(char const   *__domainname ,
                                                                                 char const   *__msgid )  __attribute__((__format_arg__(2))) ;
#line 30 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/strlib.h"
void *str_malloc(size_t size ) ;
#line 31
void *str_realloc(void *ptr , size_t size ) ;
#line 32
char *str_dup(char const   *str ) ;
#line 33
char *str_ndup(char const   *str , size_t n ) ;
#line 34
char *str_dup_printf(char const   *format  , ...) ;
#line 35
char *str_concat(char const   *string1  , ...) ;
#line 36
size_t printf_string_upper_bound(char const   *format , va_list args ) ;
#line 37
char *str_fgets(FILE *fp ) ;
#line 38
int str_skip_fgets(FILE *fp ) ;
#line 39
char *str_tolower(char *str ) ;
#line 59 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/strlib.c"
void *str_malloc(size_t size ) 
{ 
  void *ptr ;
  char *tmp ;

  {
  {
#line 63
  ptr = malloc(size);
  }
#line 64
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
    {
#line 65
    tmp = dgettext("weex", "Cannot allocate memory.\n");
#line 65
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp);
#line 66
    exit(1);
    }
  }
#line 68
  return (ptr);
}
}
#line 79 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/strlib.c"
void *str_realloc(void *ptr , size_t size ) 
{ 
  void *new_ptr ;
  char *tmp ;

  {
  {
#line 83
  new_ptr = realloc(ptr, size);
  }
#line 84
  if ((unsigned long )new_ptr == (unsigned long )((void *)0)) {
    {
#line 85
    tmp = dgettext("weex", "Cannot allocate memory.\n");
#line 85
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp);
#line 86
    exit(1);
    }
  }
#line 88
  return (new_ptr);
}
}
#line 98 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/strlib.c"
char *str_dup(char const   *str ) 
{ 
  char *ptr ;
  size_t tmp ;
  void *tmp___0 ;

  {
#line 102
  if ((unsigned long )str != (unsigned long )((void *)0)) {
    {
#line 103
    tmp = strlen(str);
#line 103
    tmp___0 = str_malloc(tmp + 1UL);
#line 103
    ptr = (char *)tmp___0;
#line 104
    strcpy((char */* __restrict  */)ptr, (char const   */* __restrict  */)str);
    }
  } else {
#line 106
    ptr = (char *)((void *)0);
  }
#line 108
  return (ptr);
}
}
#line 119 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/strlib.c"
char *str_ndup(char const   *str , size_t n ) 
{ 
  char *ptr ;
  void *tmp ;

  {
#line 123
  if ((unsigned long )str != (unsigned long )((void *)0)) {
    {
#line 124
    tmp = str_malloc(n + 1UL);
#line 124
    ptr = (char *)tmp;
#line 125
    strncpy((char */* __restrict  */)ptr, (char const   */* __restrict  */)str, n);
#line 126
    *(ptr + n) = (char )'\000';
    }
  } else {
#line 128
    ptr = (char *)((void *)0);
  }
#line 130
  return (ptr);
}
}
#line 140 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/strlib.c"
char *str_concat(char const   *string1  , ...) 
{ 
  va_list ap ;
  char *ptr ;
  char *temp ;
  int size ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;

  {
#line 146
  if ((unsigned long )string1 == (unsigned long )((void *)0)) {
#line 147
    return ((char *)((void *)0));
  }
  {
#line 149
  __builtin_va_start(ap, string1);
#line 150
  tmp = strlen(string1);
#line 150
  size = (int )(tmp + 1UL);
#line 151
  tmp___0 = str_malloc((size_t )size);
#line 151
  ptr = (char *)tmp___0;
#line 152
  strcpy((char */* __restrict  */)ptr, (char const   */* __restrict  */)string1);
  }
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 154
    tmp___3 = __builtin_va_arg(ap, char *);
#line 154
    temp = tmp___3;
    }
#line 154
    if (! ((unsigned long )temp != (unsigned long )((void *)0))) {
#line 154
      goto while_break;
    }
    {
#line 155
    tmp___1 = strlen((char const   *)temp);
#line 155
    size = (int )((size_t )size + tmp___1);
#line 156
    tmp___2 = str_realloc((void *)ptr, (size_t )size);
#line 156
    ptr = (char *)tmp___2;
#line 157
    strcat((char */* __restrict  */)ptr, (char const   */* __restrict  */)temp);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 159
  __builtin_va_end(ap);
  }
#line 160
  return (ptr);
}
}
#line 170 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/strlib.c"
char *str_dup_printf(char const   *format  , ...) 
{ 
  va_list ap1 ;
  va_list ap2 ;
  char *ptr ;
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 175
  __builtin_va_start(ap1, format);
#line 176
  memmove((void *)ap2, (void const   *)ap1, sizeof(va_list ));
#line 177
  tmp = printf_string_upper_bound(format, ap1);
#line 177
  tmp___0 = str_malloc(tmp);
#line 177
  ptr = (char *)tmp___0;
#line 178
  vsprintf((char */* __restrict  */)ptr, (char const   */* __restrict  */)format,
           ap2);
#line 179
  __builtin_va_end(ap2);
  }
#line 181
  return (ptr);
}
}
#line 194 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/strlib.c"
size_t printf_string_upper_bound(char const   *format , va_list args ) 
{ 
  unsigned int len ;
  int long_int ;
  int extra_long ;
  char c ;
  char const   *tmp ;
  int done ;
  char const   *tmp___0 ;
  char *string_arg ;
  int tmp___2 ;
  long tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  long tmp___7 ;
  int tmp___9 ;
  int tmp___10 ;
  long tmp___12 ;
  double tmp___14 ;
  int tmp___15 ;
  int tmp___17 ;
  void *tmp___19 ;

  {
#line 196
  len = 1U;
  {
#line 198
  while (1) {
    while_continue: /* CIL Label */ ;
#line 198
    if (! *format) {
#line 198
      goto while_break;
    }
#line 200
    long_int = 0;
#line 201
    extra_long = 0;
#line 204
    tmp = format;
#line 204
    format ++;
#line 204
    c = (char )*tmp;
#line 206
    if ((int )c == 37) {
#line 208
      done = 0;
      {
#line 210
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 210
        if (*format) {
#line 210
          if (! (! done)) {
#line 210
            goto while_break___0;
          }
        } else {
#line 210
          goto while_break___0;
        }
#line 212
        tmp___0 = format;
#line 212
        format ++;
        {
#line 216
        if ((int const   )*tmp___0 == 42) {
#line 216
          goto case_42;
        }
#line 227
        if ((int const   )*tmp___0 == 57) {
#line 227
          goto case_57;
        }
#line 227
        if ((int const   )*tmp___0 == 56) {
#line 227
          goto case_57;
        }
#line 227
        if ((int const   )*tmp___0 == 55) {
#line 227
          goto case_57;
        }
#line 227
        if ((int const   )*tmp___0 == 54) {
#line 227
          goto case_57;
        }
#line 227
        if ((int const   )*tmp___0 == 53) {
#line 227
          goto case_57;
        }
#line 227
        if ((int const   )*tmp___0 == 52) {
#line 227
          goto case_57;
        }
#line 227
        if ((int const   )*tmp___0 == 51) {
#line 227
          goto case_57;
        }
#line 227
        if ((int const   )*tmp___0 == 50) {
#line 227
          goto case_57;
        }
#line 227
        if ((int const   )*tmp___0 == 49) {
#line 227
          goto case_57;
        }
#line 234
        if ((int const   )*tmp___0 == 104) {
#line 234
          goto case_104;
        }
#line 239
        if ((int const   )*tmp___0 == 108) {
#line 239
          goto case_108;
        }
#line 246
        if ((int const   )*tmp___0 == 76) {
#line 246
          goto case_76;
        }
#line 246
        if ((int const   )*tmp___0 == 113) {
#line 246
          goto case_76;
        }
#line 250
        if ((int const   )*tmp___0 == 115) {
#line 250
          goto case_115;
        }
#line 266
        if ((int const   )*tmp___0 == 88) {
#line 266
          goto case_88;
        }
#line 266
        if ((int const   )*tmp___0 == 120) {
#line 266
          goto case_88;
        }
#line 266
        if ((int const   )*tmp___0 == 117) {
#line 266
          goto case_88;
        }
#line 266
        if ((int const   )*tmp___0 == 111) {
#line 266
          goto case_88;
        }
#line 266
        if ((int const   )*tmp___0 == 105) {
#line 266
          goto case_88;
        }
#line 266
        if ((int const   )*tmp___0 == 100) {
#line 266
          goto case_88;
        }
#line 283
        if ((int const   )*tmp___0 == 85) {
#line 283
          goto case_85;
        }
#line 283
        if ((int const   )*tmp___0 == 79) {
#line 283
          goto case_85;
        }
#line 283
        if ((int const   )*tmp___0 == 68) {
#line 283
          goto case_85;
        }
#line 291
        if ((int const   )*tmp___0 == 103) {
#line 291
          goto case_103;
        }
#line 291
        if ((int const   )*tmp___0 == 102) {
#line 291
          goto case_103;
        }
#line 291
        if ((int const   )*tmp___0 == 69) {
#line 291
          goto case_103;
        }
#line 291
        if ((int const   )*tmp___0 == 101) {
#line 291
          goto case_103;
        }
#line 301
        if ((int const   )*tmp___0 == 99) {
#line 301
          goto case_99;
        }
#line 307
        if ((int const   )*tmp___0 == 110) {
#line 307
          goto case_110;
        }
#line 307
        if ((int const   )*tmp___0 == 112) {
#line 307
          goto case_110;
        }
#line 312
        if ((int const   )*tmp___0 == 37) {
#line 312
          goto case_37;
        }
#line 316
        goto switch_default;
        case_42: /* CIL Label */ 
        {
#line 217
        tmp___2 = __builtin_va_arg(args, int );
#line 217
        len += (unsigned int )tmp___2;
        }
#line 218
        goto switch_break;
        case_57: /* CIL Label */ 
        case_56: /* CIL Label */ 
        case_55: /* CIL Label */ 
        case_54: /* CIL Label */ 
        case_53: /* CIL Label */ 
        case_52: /* CIL Label */ 
        case_51: /* CIL Label */ 
        case_50: /* CIL Label */ 
        case_49: /* CIL Label */ 
        {
#line 231
        format --;
#line 232
        tmp___3 = strtol((char const   */* __restrict  */)format, (char **/* __restrict  */)((char **)(& format)),
                         10);
#line 232
        len = (unsigned int )((long )len + tmp___3);
        }
#line 233
        goto switch_break;
        case_104: /* CIL Label */ 
#line 238
        goto switch_break;
        case_108: /* CIL Label */ 
#line 240
        if (long_int) {
#line 241
          extra_long = 1;
        } else {
#line 243
          long_int = 1;
        }
#line 244
        goto switch_break;
        case_76: /* CIL Label */ 
        case_113: /* CIL Label */ 
#line 247
        long_int = 1;
#line 248
        extra_long = 1;
#line 249
        goto switch_break;
        case_115: /* CIL Label */ 
        {
#line 251
        tmp___4 = __builtin_va_arg(args, char *);
#line 251
        string_arg = tmp___4;
        }
#line 252
        if (string_arg) {
          {
#line 253
          tmp___5 = strlen((char const   *)string_arg);
#line 253
          len = (unsigned int )((size_t )len + tmp___5);
          }
        } else {
#line 257
          len += 16U;
        }
#line 259
        done = 1;
#line 260
        goto switch_break;
        case_88: /* CIL Label */ 
        case_120: /* CIL Label */ 
        case_117: /* CIL Label */ 
        case_111: /* CIL Label */ 
        case_105: /* CIL Label */ 
        case_100: /* CIL Label */ 
#line 273
        if (long_int) {
          {
#line 274
          tmp___7 = __builtin_va_arg(args, long );
          }
        } else {
          {
#line 276
          tmp___9 = __builtin_va_arg(args, int );
          }
        }
#line 278
        if (extra_long) {
#line 278
          tmp___10 = 64;
        } else {
#line 278
          tmp___10 = 32;
        }
#line 278
        len += (unsigned int )tmp___10;
#line 279
        done = 1;
#line 280
        goto switch_break;
        case_85: /* CIL Label */ 
        case_79: /* CIL Label */ 
        case_68: /* CIL Label */ 
        {
#line 284
        tmp___12 = __builtin_va_arg(args, long );
#line 285
        len += 32U;
#line 286
        done = 1;
        }
#line 287
        goto switch_break;
        case_103: /* CIL Label */ 
        case_102: /* CIL Label */ 
        case_69: /* CIL Label */ 
        case_101: /* CIL Label */ 
        {
#line 297
        tmp___14 = __builtin_va_arg(args, double );
        }
#line 298
        if (extra_long) {
#line 298
          tmp___15 = 64;
        } else {
#line 298
          tmp___15 = 32;
        }
#line 298
        len += (unsigned int )tmp___15;
#line 299
        done = 1;
#line 300
        goto switch_break;
        case_99: /* CIL Label */ 
        {
#line 302
        tmp___17 = __builtin_va_arg(args, int );
#line 303
        len ++;
#line 304
        done = 1;
        }
#line 305
        goto switch_break;
        case_110: /* CIL Label */ 
        case_112: /* CIL Label */ 
        {
#line 308
        tmp___19 = __builtin_va_arg(args, void *);
#line 309
        len += 32U;
#line 310
        done = 1;
        }
#line 311
        goto switch_break;
        case_37: /* CIL Label */ 
#line 313
        len ++;
#line 314
        done = 1;
#line 315
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 318
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 323
      len ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 326
  return ((size_t )len);
}
}
#line 336 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/strlib.c"
char *str_fgets(FILE *fp ) 
{ 
  char *ptr ;
  char temp[128] ;
  int i ;
  void *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 342
  tmp = str_malloc((size_t )1);
#line 342
  ptr = (char *)tmp;
#line 343
  *ptr = (char )'\000';
#line 344
  i = 0;
  }
  {
#line 344
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 345
    tmp___0 = fgets((char */* __restrict  */)(temp), 128, (FILE */* __restrict  */)fp);
    }
#line 345
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
      {
#line 346
      free((void *)ptr);
      }
#line 347
      return ((char *)((void *)0));
    }
    {
#line 349
    tmp___1 = str_realloc((void *)ptr, (size_t )(127 * (i + 1) + 1));
#line 349
    ptr = (char *)tmp___1;
#line 350
    strcat((char */* __restrict  */)ptr, (char const   */* __restrict  */)(temp));
#line 351
    tmp___3 = strchr((char const   *)(temp), '\n');
    }
#line 351
    if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
      {
#line 352
      tmp___2 = strchr((char const   *)ptr, '\n');
#line 352
      *tmp___2 = (char )'\000';
      }
#line 353
      return (ptr);
    }
#line 344
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 365 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/strlib.c"
int str_skip_fgets(FILE *fp ) 
{ 
  char temp[128] ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 368
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 369
    tmp = fgets((char */* __restrict  */)(temp), 128, (FILE */* __restrict  */)fp);
    }
#line 369
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 370
      return (-1);
    }
    {
#line 372
    tmp___0 = strchr((char const   *)(temp), '\n');
    }
#line 372
    if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 373
      return (0);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 385 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/strlib.c"
char *str_tolower(char *str ) 
{ 
  char *temp ;
  int i ;
  int tmp ;
  size_t tmp___0 ;

  {
  {
#line 390
  temp = str_dup((char const   *)str);
#line 391
  i = 0;
  }
  {
#line 391
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 391
    tmp___0 = strlen((char const   *)temp);
    }
#line 391
    if (! ((size_t )i < tmp___0)) {
#line 391
      goto while_break;
    }
    {
#line 392
    tmp = tolower((int )*(temp + i));
#line 392
    *(temp + i) = (char )tmp;
#line 391
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 394
  return (temp);
}
}
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 187 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 33 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/shhopt.h"
void optSetFatalFunc(void (*f)(char const   *  , ...) ) ;
#line 34
void optParseOptions(int *argc , char **argv , optStruct *opt , int allowNegNum ) ;
#line 38 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/shhopt.c"
static void optFatalFunc(char const   *format  , ...) ;
#line 39 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/shhopt.c"
static void (*optFatal)(char const   *format  , ...)  =    & optFatalFunc;
#line 55 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/shhopt.c"
static void optFatalFunc(char const   *format  , ...) 
{ 
  va_list ap ;

  {
  {
#line 60
  fflush(stdout);
#line 61
  __builtin_va_start(ap, format);
#line 62
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)format,
           ap);
#line 63
  __builtin_va_end(ap);
#line 64
  exit(99);
  }
}
}
#line 79 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/shhopt.c"
static int optStructCount(optStruct *opt ) 
{ 
  int ret___0 ;

  {
#line 82
  ret___0 = 0;
  {
#line 84
  while (1) {
    while_continue: /* CIL Label */ ;
#line 84
    if (! ((unsigned int )(opt + ret___0)->type != 0U)) {
#line 84
      goto while_break;
    }
#line 85
    ret___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 86
  return (ret___0);
}
}
#line 103 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/shhopt.c"
static int optMatch(optStruct *opt , char const   *s , int lng ) 
{ 
  int nopt ;
  int q ;
  int matchlen ;
  char const   *p ;
  size_t tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 106
  matchlen = 0;
#line 109
  nopt = optStructCount(opt);
  }
#line 110
  if (lng) {
    {
#line 111
    tmp___0 = strchr(s, '=');
#line 111
    p = (char const   *)tmp___0;
    }
#line 111
    if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 112
      matchlen = (int )(p - s);
    } else {
      {
#line 114
      tmp = strlen(s);
#line 114
      matchlen = (int )tmp;
      }
    }
  }
#line 116
  q = 0;
  {
#line 116
  while (1) {
    while_continue: /* CIL Label */ ;
#line 116
    if (! (q < nopt)) {
#line 116
      goto while_break;
    }
#line 117
    if (lng) {
#line 118
      if (! (opt + q)->longName) {
#line 119
        goto __Cont;
      }
      {
#line 120
      tmp___1 = strncmp(s, (char const   *)(opt + q)->longName, (size_t )matchlen);
      }
#line 120
      if (tmp___1 == 0) {
#line 121
        return (q);
      }
    } else {
#line 123
      if (! (opt + q)->shortName) {
#line 124
        goto __Cont;
      }
#line 125
      if ((int const   )*s == (int const   )(opt + q)->shortName) {
#line 126
        return (q);
      }
    }
    __Cont: /* CIL Label */ 
#line 116
    q ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 129
  return (-1);
}
}
#line 145 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/shhopt.c"
static char ret[31]  ;
#line 142 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/shhopt.c"
static char *optString(optStruct *opt , int lng ) 
{ 


  {
#line 147
  if (lng) {
    {
#line 148
    strcpy((char */* __restrict  */)(ret), (char const   */* __restrict  */)"--");
#line 149
    strncpy((char */* __restrict  */)(ret + 2), (char const   */* __restrict  */)opt->longName,
            (size_t )28);
    }
  } else {
#line 151
    ret[0] = (char )'-';
#line 152
    ret[1] = opt->shortName;
#line 153
    ret[2] = (char )'\000';
  }
#line 155
  return (ret);
}
}
#line 167 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/shhopt.c"
static int optNeedsArgument(optStruct *opt ) 
{ 
  int tmp ;

  {
#line 170
  if ((unsigned int )opt->type == 2U) {
#line 170
    tmp = 1;
  } else
#line 170
  if ((unsigned int )opt->type == 3U) {
#line 170
    tmp = 1;
  } else
#line 170
  if ((unsigned int )opt->type == 4U) {
#line 170
    tmp = 1;
  } else
#line 170
  if ((unsigned int )opt->type == 5U) {
#line 170
    tmp = 1;
  } else
#line 170
  if ((unsigned int )opt->type == 6U) {
#line 170
    tmp = 1;
  } else {
#line 170
    tmp = 0;
  }
#line 170
  return (tmp);
}
}
#line 189 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/shhopt.c"
static void argvRemove(int *argc , char **argv , int i ) 
{ 
  int tmp ;

  {
#line 192
  if (i >= *argc) {
#line 193
    return;
  }
  {
#line 194
  while (1) {
    while_continue: /* CIL Label */ ;
#line 194
    tmp = i;
#line 194
    i ++;
#line 194
    if (! (tmp < *argc)) {
#line 194
      goto while_break;
    }
#line 195
    *(argv + (i - 1)) = *(argv + i);
  }
  while_break: /* CIL Label */ ;
  }
#line 196
  (*argc) --;
#line 197
  return;
}
}
#line 210 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/shhopt.c"
void optExecute(optStruct *opt , char *arg , int lng ) 
{ 
  long tmp ;
  char *e ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  unsigned long tmp___4 ;
  char *e___0 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int *tmp___8 ;

  {
  {
#line 214
  if ((unsigned int )opt->type == 1U) {
#line 214
    goto case_1;
  }
#line 221
  if ((unsigned int )opt->type == 2U) {
#line 221
    goto case_2;
  }
#line 229
  if ((unsigned int )opt->type == 5U) {
#line 229
    goto case_5;
  }
#line 229
  if ((unsigned int )opt->type == 3U) {
#line 229
    goto case_5;
  }
#line 255
  if ((unsigned int )opt->type == 6U) {
#line 255
    goto case_6;
  }
#line 255
  if ((unsigned int )opt->type == 4U) {
#line 255
    goto case_6;
  }
#line 280
  goto switch_default;
  case_1: /* CIL Label */ 
#line 215
  if (opt->flags & 1) {
    {
#line 216
    (*((void (*)(void))opt->arg))();
    }
  } else {
#line 218
    *((int *)opt->arg) = 1;
  }
#line 219
  goto switch_break;
  case_2: /* CIL Label */ 
#line 222
  if (opt->flags & 1) {
    {
#line 223
    (*((void (*)(char * ))opt->arg))(arg);
    }
  } else {
#line 225
    *((char **)opt->arg) = arg;
  }
#line 226
  goto switch_break;
  case_5: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 233
  tmp = strtol((char const   */* __restrict  */)arg, (char **/* __restrict  */)(& e),
               10);
  }
#line 234
  if (*e) {
    {
#line 235
    tmp___0 = dgettext("weex", "invalid number `%s\'\n");
#line 235
    (*optFatal)((char const   *)tmp___0, arg);
    }
  }
  {
#line 236
  tmp___3 = __errno_location();
  }
#line 236
  if (*tmp___3 == 34) {
    {
#line 238
    tmp___1 = optString(opt, lng);
#line 238
    tmp___2 = dgettext("weex", "number `%s\' to `%s\' out of range\n");
#line 238
    (*optFatal)((char const   *)tmp___2, arg, tmp___1);
    }
  } else
#line 236
  if ((unsigned int )opt->type == 3U) {
#line 236
    if (tmp > 2147483647L) {
      {
#line 238
      tmp___1 = optString(opt, lng);
#line 238
      tmp___2 = dgettext("weex", "number `%s\' to `%s\' out of range\n");
#line 238
      (*optFatal)((char const   *)tmp___2, arg, tmp___1);
      }
    } else
#line 236
    if (tmp < (-0x7FFFFFFF-1)) {
      {
#line 238
      tmp___1 = optString(opt, lng);
#line 238
      tmp___2 = dgettext("weex", "number `%s\' to `%s\' out of range\n");
#line 238
      (*optFatal)((char const   *)tmp___2, arg, tmp___1);
      }
    }
  }
#line 240
  if ((unsigned int )opt->type == 3U) {
#line 241
    if (opt->flags & 1) {
      {
#line 242
      (*((void (*)(int  ))opt->arg))((int )tmp);
      }
    } else {
#line 244
      *((int *)opt->arg) = (int )tmp;
    }
  } else
#line 246
  if (opt->flags & 1) {
    {
#line 247
    (*((void (*)(long  ))opt->arg))(tmp);
    }
  } else {
#line 249
    *((long *)opt->arg) = tmp;
  }
#line 251
  goto switch_break;
  case_6: /* CIL Label */ 
  case_4: /* CIL Label */ 
  {
#line 259
  tmp___4 = strtoul((char const   */* __restrict  */)arg, (char **/* __restrict  */)(& e___0),
                    10);
  }
#line 260
  if (*e___0) {
    {
#line 261
    tmp___5 = dgettext("weex", "invalid number `%s\'\n");
#line 261
    (*optFatal)((char const   *)tmp___5, arg);
    }
  }
  {
#line 262
  tmp___8 = __errno_location();
  }
#line 262
  if (*tmp___8 == 34) {
    {
#line 264
    tmp___6 = optString(opt, lng);
#line 264
    tmp___7 = dgettext("weex", "number `%s\' to `%s\' out of range\n");
#line 264
    (*optFatal)((char const   *)tmp___7, arg, tmp___6);
    }
  } else
#line 262
  if ((unsigned int )opt->type == 4U) {
#line 262
    if (tmp___4 > 4294967295UL) {
      {
#line 264
      tmp___6 = optString(opt, lng);
#line 264
      tmp___7 = dgettext("weex", "number `%s\' to `%s\' out of range\n");
#line 264
      (*optFatal)((char const   *)tmp___7, arg, tmp___6);
      }
    }
  }
#line 266
  if ((unsigned int )opt->type == 4U) {
#line 267
    if (opt->flags & 1) {
      {
#line 268
      (*((void (*)(unsigned int  ))opt->arg))((unsigned int )tmp___4);
      }
    } else {
#line 270
      *((unsigned int *)opt->arg) = (unsigned int )tmp___4;
    }
  } else
#line 272
  if (opt->flags & 1) {
    {
#line 273
    (*((void (*)(unsigned long  ))opt->arg))(tmp___4);
    }
  } else {
#line 275
    *((unsigned long *)opt->arg) = tmp___4;
  }
#line 277
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 281
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 283
  return;
}
}
#line 300 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/shhopt.c"
void optSetFatalFunc(void (*f)(char const   *  , ...) ) 
{ 


  {
#line 303
  optFatal = f;
#line 304
  return;
}
}
#line 338 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/shhopt.c"
void optParseOptions(int *argc , char **argv , optStruct *opt , int allowNegNum ) 
{ 
  int ai ;
  int optarg ;
  int mi ;
  int done ;
  char *arg ;
  char *o ;
  char *p ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  unsigned short const   **tmp___11 ;

  {
#line 352
  ai = 0;
  {
#line 352
  while (1) {
    while_continue: /* CIL Label */ ;
#line 352
    if (! (ai < *argc)) {
#line 352
      goto while_break;
    }
    {
#line 357
    tmp = strcmp((char const   *)*(argv + ai), "--");
    }
#line 357
    if (tmp == 0) {
      {
#line 358
      argvRemove(argc, argv, ai);
      }
#line 359
      goto while_break;
    }
#line 362
    if (allowNegNum) {
#line 362
      if ((int )*(*(argv + ai) + 0) == 45) {
        {
#line 362
        tmp___11 = __ctype_b_loc();
        }
#line 362
        if ((int const   )*(*tmp___11 + (int )*(*(argv + ai) + 1)) & 2048) {
#line 363
          ai ++;
#line 364
          goto __Cont;
        } else {
#line 362
          goto _L___0;
        }
      } else {
#line 362
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      {
#line 365
      tmp___10 = strncmp((char const   *)*(argv + ai), "--", (size_t )2);
      }
#line 365
      if (tmp___10 == 0) {
        {
#line 368
        mi = optMatch(opt, (char const   *)(*(argv + ai) + 2), 1);
        }
#line 368
        if (mi < 0) {
          {
#line 369
          tmp___0 = dgettext("weex", "unrecognized option `%s\'\n");
#line 369
          (*optFatal)((char const   *)tmp___0, *(argv + ai));
          }
        }
        {
#line 372
        arg = (char *)((void *)0);
#line 373
        p = strchr((char const   *)*(argv + ai), '=');
        }
#line 373
        if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 374
          arg = p + 1;
        }
        {
#line 377
        optarg = -1;
#line 378
        tmp___5 = optNeedsArgument(opt + mi);
        }
#line 378
        if (tmp___5) {
#line 380
          if (! arg) {
#line 381
            optarg = ai + 1;
#line 381
            if (optarg == *argc) {
              {
#line 382
              tmp___1 = optString(opt + mi, 1);
#line 382
              tmp___2 = dgettext("weex", "option `%s\' requires an argument\n");
#line 382
              (*optFatal)((char const   *)tmp___2, tmp___1);
              }
            }
#line 384
            arg = *(argv + optarg);
          }
        } else
#line 387
        if (arg) {
          {
#line 388
          tmp___3 = optString(opt + mi, 1);
#line 388
          tmp___4 = dgettext("weex", "option `%s\' doesn\'t allow an argument\n");
#line 388
          (*optFatal)((char const   *)tmp___4, tmp___3);
          }
        }
        {
#line 392
        optExecute(opt + mi, arg, 1);
        }
#line 394
        if (optarg >= 0) {
          {
#line 395
          argvRemove(argc, argv, ai);
          }
        }
        {
#line 396
        argvRemove(argc, argv, ai);
        }
      } else
#line 397
      if ((int )*(*(argv + ai)) == 45) {
#line 399
        if ((int )*(*(argv + ai) + 1) == 0) {
#line 400
          ai ++;
#line 401
          goto __Cont;
        }
#line 404
        o = *(argv + ai) + 1;
#line 405
        done = 0;
#line 406
        optarg = -1;
        {
#line 407
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 407
          if (*o) {
#line 407
            if (! (! done)) {
#line 407
              goto while_break___0;
            }
          } else {
#line 407
            goto while_break___0;
          }
          {
#line 409
          mi = optMatch(opt, (char const   *)o, 0);
          }
#line 409
          if (mi < 0) {
            {
#line 410
            tmp___6 = dgettext("weex", "unrecognized option `-%c\'\n");
#line 410
            (*optFatal)((char const   *)tmp___6, (int )*o);
            }
          }
          {
#line 413
          optarg = -1;
#line 414
          arg = (char *)((void *)0);
#line 415
          tmp___9 = optNeedsArgument(opt + mi);
          }
#line 415
          if (tmp___9) {
#line 417
            arg = o + 1;
#line 418
            if (! *arg) {
#line 419
              optarg = ai + 1;
#line 419
              if (optarg == *argc) {
                {
#line 420
                tmp___7 = optString(opt + mi, 0);
#line 420
                tmp___8 = dgettext("weex", "option `%s\' requires an argument\n");
#line 420
                (*optFatal)((char const   *)tmp___8, tmp___7);
                }
              }
#line 422
              arg = *(argv + optarg);
            }
#line 424
            done = 1;
          }
          {
#line 427
          optExecute(opt + mi, arg, 0);
#line 428
          o ++;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
#line 431
        if (optarg >= 0) {
          {
#line 432
          argvRemove(argc, argv, ai);
          }
        }
        {
#line 433
        argvRemove(argc, argv, ai);
        }
      } else {
#line 436
        ai ++;
      }
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 439
  return;
}
}
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 564 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 124 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) setlocale)(int __category ,
                                                                                  char const   *__locale ) ;
#line 82 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) textdomain)(char const   *__domainname ) ;
#line 86
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) bindtextdomain)(char const   *__domainname ,
                                                                                       char const   *__dirname ) ;
#line 71 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/ftplib.h"
netbuf *DefaultNetbuf  ;
#line 92
int ftplib_debug ;
#line 96 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/parsecfg.h"
char *cfgSectionNumberToName(int num ) ;
#line 73 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/variable.h"
netbuf *ftp_buf  ;
#line 75 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/variable.h"
int host_number  ;
#line 76 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/variable.h"
char *current_dir[2]  ;
#line 77 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/variable.h"
int is_cache_existent  ;
#line 80 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/variable.h"
int opt_silent  ;
#line 81 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/variable.h"
int opt_force  ;
#line 82 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/variable.h"
int opt_monochrome  ;
#line 83 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/variable.h"
int opt_test  ;
#line 84 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/variable.h"
int rebuild_cache  ;
#line 87 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/variable.h"
char **host_name  ;
#line 88 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/variable.h"
char **login_name  ;
#line 89 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/variable.h"
char **authorization_name  ;
#line 90 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/variable.h"
char **password  ;
#line 91 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/variable.h"
char **src_dir  ;
#line 92 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/variable.h"
char **dest_dir  ;
#line 93 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/variable.h"
cfgList **ignore_local_dir  ;
#line 94 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/variable.h"
cfgList **ignore_local_file  ;
#line 95 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/variable.h"
cfgList **ignore_remote_dir  ;
#line 96 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/variable.h"
cfgList **ignore_remote_file  ;
#line 97 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/variable.h"
cfgList **keep_remote_dir  ;
#line 98 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/variable.h"
cfgList **ascii_file  ;
#line 99 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/variable.h"
char **change_permission  ;
#line 100 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/variable.h"
cfgList **change_permission_dir  ;
#line 101 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/variable.h"
cfgList **preserve_permission_dir  ;
#line 102 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/variable.h"
int *conv_to_lower  ;
#line 103 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/variable.h"
int *overwrite_ok  ;
#line 104 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/variable.h"
int *rename_ok  ;
#line 105 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/variable.h"
int *record_log  ;
#line 106 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/variable.h"
int *cfg_silent  ;
#line 107 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/variable.h"
int *cfg_force  ;
#line 108 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/variable.h"
int *cfg_monochrome  ;
#line 109 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/variable.h"
int *ftp_passive  ;
#line 110 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/variable.h"
int *nest_spaces  ;
#line 111 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/variable.h"
int *log_detail_level  ;
#line 112 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/variable.h"
int *max_retry_to_send  ;
#line 113 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/variable.h"
int *show_hidden_file  ;
#line 114 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/variable.h"
int *follow_symlinks  ;
#line 115 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/variable.h"
int *chdir_at_connection  ;
#line 31 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/proto.h"
void put_usage(void) ;
#line 32
void put_version(void) ;
#line 33
void put_config(int max_hosts ) ;
#line 38
void make_weex_directory(void) ;
#line 39
char *config_location(void) ;
#line 40
int read_config(void) ;
#line 41
void check_permission(char *file ) ;
#line 55
void ftp_main(int argc , char **argv , int max_hosts ) ;
#line 43 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/weex.c"
int main(int argc , char **argv ) 
{ 
  int max_hosts ;
  int put_config_flag ;
  optStruct opt[10] ;

  {
  {
#line 46
  put_config_flag = 0;
#line 47
  opt[0].shortName = (char )'h';
#line 47
  opt[0].longName = (char *)"help";
#line 47
  opt[0].type = (optArgType )1;
#line 47
  opt[0].arg = (void *)(& put_usage);
#line 47
  opt[0].flags = 1;
#line 47
  opt[1].shortName = (char )'V';
#line 47
  opt[1].longName = (char *)"version";
#line 47
  opt[1].type = (optArgType )1;
#line 47
  opt[1].arg = (void *)(& put_version);
#line 47
  opt[1].flags = 1;
#line 47
  opt[2].shortName = (char )'s';
#line 47
  opt[2].longName = (char *)"silent";
#line 47
  opt[2].type = (optArgType )1;
#line 47
  opt[2].arg = (void *)(& opt_silent);
#line 47
  opt[2].flags = 0;
#line 47
  opt[3].shortName = (char )'f';
#line 47
  opt[3].longName = (char *)"force";
#line 47
  opt[3].type = (optArgType )1;
#line 47
  opt[3].arg = (void *)(& opt_force);
#line 47
  opt[3].flags = 0;
#line 47
  opt[4].shortName = (char )'m';
#line 47
  opt[4].longName = (char *)"monochrome";
#line 47
  opt[4].type = (optArgType )1;
#line 47
  opt[4].arg = (void *)(& opt_monochrome);
#line 47
  opt[4].flags = 0;
#line 47
  opt[5].shortName = (char )'t';
#line 47
  opt[5].longName = (char *)"test";
#line 47
  opt[5].type = (optArgType )1;
#line 47
  opt[5].arg = (void *)(& opt_test);
#line 47
  opt[5].flags = 0;
#line 47
  opt[6].shortName = (char )'r';
#line 47
  opt[6].longName = (char *)"rebuild-cache";
#line 47
  opt[6].type = (optArgType )1;
#line 47
  opt[6].arg = (void *)(& rebuild_cache);
#line 47
  opt[6].flags = 0;
#line 47
  opt[7].shortName = (char )'d';
#line 47
  opt[7].longName = (char *)"debug-config";
#line 47
  opt[7].type = (optArgType )1;
#line 47
  opt[7].arg = (void *)(& put_config_flag);
#line 47
  opt[7].flags = 0;
#line 47
  opt[8].shortName = (char )'D';
#line 47
  opt[8].longName = (char *)"debug-ftplib";
#line 47
  opt[8].type = (optArgType )1;
#line 47
  opt[8].arg = (void *)(& ftplib_debug);
#line 47
  opt[8].flags = 0;
#line 47
  opt[9].shortName = (char)0;
#line 47
  opt[9].longName = (char *)0;
#line 47
  opt[9].type = (optArgType )0;
#line 47
  opt[9].arg = (void *)0;
#line 47
  opt[9].flags = 0;
#line 62
  setlocale(6, "");
#line 63
  bindtextdomain("weex", "/usr/local/share/locale");
#line 64
  textdomain("weex");
#line 67
  make_weex_directory();
#line 69
  optParseOptions(& argc, argv, opt, 0);
#line 71
  ftplib_debug *= 3;
  }
#line 72
  if (put_config_flag) {
    {
#line 73
    max_hosts = read_config();
#line 74
    put_config(max_hosts);
#line 75
    exit(0);
    }
  }
#line 78
  if (argc < 2) {
    {
#line 79
    put_usage();
    }
  }
  {
#line 82
  max_hosts = read_config();
#line 84
  ftp_main(argc, argv, max_hosts);
  }
#line 86
  return (0);
}
}
#line 96 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/weex.c"
void put_usage(void) 
{ 
  char *temp ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 100
  temp = config_location();
  }
#line 101
  if ((unsigned long )temp == (unsigned long )((void *)0)) {
    {
#line 102
    tmp = getenv("HOME");
#line 102
    tmp___0 = dgettext("weex", "Warning! Configuration file `%s/.weex/weexrc\' does not exist.\n\n");
#line 102
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
            tmp);
    }
  } else {
    {
#line 104
    check_permission(temp);
    }
  }
  {
#line 107
  tmp___1 = dgettext("weex", "Fast Webpage Exchanger Ver %s Copyright (C) 1999-2000 Yuuki NINOMIYA\n\nThis is free software with ABSOLUTELY NO WARRANTY.\nFor details please see the file COPYING.\n\nusage: weex [OPTIONS] HOST...\n\noptions:\n  -h | --help           display this help and exit\n  -s | --silent         suppress normal non-error messages\n  -f | --force          force sending all files\n  -m | --monochrome     output messages in monochrome\n  -t | --test           not modify remote files\n  -r | --rebuild-cache  rebuild cache file\n  -d | --debug-config   display configuration of each hosts\n  -D | --debug-ftplib   output debugging information for ftplib\n  -V | --version        display version information and exit\n\n");
#line 107
  printf((char const   */* __restrict  */)tmp___1, "2.6.1");
#line 125
  exit(0);
  }
}
}
#line 135 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/weex.c"
void put_version(void) 
{ 
  char *temp ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 139
  temp = config_location();
  }
#line 140
  if ((unsigned long )temp == (unsigned long )((void *)0)) {
    {
#line 141
    tmp = getenv("HOME");
#line 141
    tmp___0 = dgettext("weex", "Warning! Configuration file `%s/.weex/weexrc\' does not exist.\n\n");
#line 141
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
            tmp);
    }
  } else {
    {
#line 143
    check_permission(temp);
    }
  }
  {
#line 146
  tmp___1 = dgettext("weex", "Fast Webpage Exchanger Ver %s Copyright (C) 1999-2000 Yuuki NINOMIYA\n");
#line 146
  printf((char const   */* __restrict  */)tmp___1, "2.6.1");
#line 147
  exit(0);
  }
}
}
#line 157 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/weex.c"
void put_config(int max_hosts ) 
{ 
  int i ;
  cfgList *l ;
  char *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;
  char const   *tmp___14 ;
  char const   *tmp___15 ;

  {
#line 162
  i = 0;
  {
#line 162
  while (1) {
    while_continue: /* CIL Label */ ;
#line 162
    if (! (i < max_hosts)) {
#line 162
      goto while_break;
    }
    {
#line 163
    tmp = cfgSectionNumberToName(i);
#line 163
    printf((char const   */* __restrict  */)"[%s]\n", tmp);
    }
#line 164
    if ((unsigned long )*(host_name + i) == (unsigned long )((void *)0)) {
#line 164
      tmp___0 = "(NULL)";
    } else {
#line 164
      tmp___0 = (char const   *)*(host_name + i);
    }
    {
#line 164
    printf((char const   */* __restrict  */)"HostName               %s\n", tmp___0);
    }
#line 165
    if ((unsigned long )*(login_name + i) == (unsigned long )((void *)0)) {
#line 165
      tmp___1 = "(NULL)";
    } else {
#line 165
      tmp___1 = (char const   *)*(login_name + i);
    }
    {
#line 165
    printf((char const   */* __restrict  */)"LoginName              %s\n", tmp___1);
    }
#line 166
    if ((unsigned long )*(password + i) == (unsigned long )((void *)0)) {
#line 166
      tmp___2 = "(NULL)";
    } else {
#line 166
      tmp___2 = (char const   *)*(password + i);
    }
    {
#line 166
    printf((char const   */* __restrict  */)"Password               %s\n", tmp___2);
    }
#line 167
    if ((unsigned long )*(authorization_name + i) == (unsigned long )((void *)0)) {
#line 167
      tmp___3 = "(NULL)";
    } else {
#line 167
      tmp___3 = (char const   *)*(authorization_name + i);
    }
    {
#line 167
    printf((char const   */* __restrict  */)"AuthorizationName      %s\n", tmp___3);
    }
#line 168
    if ((unsigned long )*(src_dir + i) == (unsigned long )((void *)0)) {
#line 168
      tmp___4 = "(NULL)";
    } else {
#line 168
      tmp___4 = (char const   *)*(src_dir + i);
    }
    {
#line 168
    printf((char const   */* __restrict  */)"SrcDir                 %s\n", tmp___4);
    }
#line 169
    if ((unsigned long )*(dest_dir + i) == (unsigned long )((void *)0)) {
#line 169
      tmp___5 = "(NULL)";
    } else {
#line 169
      tmp___5 = (char const   *)*(dest_dir + i);
    }
    {
#line 169
    printf((char const   */* __restrict  */)"DestDir                %s\n", tmp___5);
    }
#line 170
    if ((unsigned long )*(ignore_local_dir + i) != (unsigned long )((void *)0)) {
#line 171
      l = *(ignore_local_dir + i);
      {
#line 171
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 171
        if (! ((unsigned long )l != (unsigned long )((void *)0))) {
#line 171
          goto while_break___0;
        }
        {
#line 172
        printf((char const   */* __restrict  */)"IgnoreLocalDir         %s\n", l->str);
#line 171
        l = l->next;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
      {
#line 175
      printf((char const   */* __restrict  */)"IgnoreLocalDir         (NULL)\n");
      }
    }
#line 177
    if ((unsigned long )*(ignore_local_file + i) != (unsigned long )((void *)0)) {
#line 178
      l = *(ignore_local_file + i);
      {
#line 178
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 178
        if (! ((unsigned long )l != (unsigned long )((void *)0))) {
#line 178
          goto while_break___1;
        }
        {
#line 179
        printf((char const   */* __restrict  */)"IgnoreLocalFile        %s\n", l->str);
#line 178
        l = l->next;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {
      {
#line 182
      printf((char const   */* __restrict  */)"IgnoreLocalFile        (NULL)\n");
      }
    }
#line 184
    if ((unsigned long )*(ignore_remote_dir + i) != (unsigned long )((void *)0)) {
#line 185
      l = *(ignore_remote_dir + i);
      {
#line 185
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 185
        if (! ((unsigned long )l != (unsigned long )((void *)0))) {
#line 185
          goto while_break___2;
        }
        {
#line 186
        printf((char const   */* __restrict  */)"IgnoreRemoteDir        %s\n", l->str);
#line 185
        l = l->next;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    } else {
      {
#line 189
      printf((char const   */* __restrict  */)"IgnoreRemoteDir        (NULL)\n");
      }
    }
#line 191
    if ((unsigned long )*(ignore_remote_file + i) != (unsigned long )((void *)0)) {
#line 192
      l = *(ignore_remote_file + i);
      {
#line 192
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 192
        if (! ((unsigned long )l != (unsigned long )((void *)0))) {
#line 192
          goto while_break___3;
        }
        {
#line 193
        printf((char const   */* __restrict  */)"IgnoreRemoteFile       %s\n", l->str);
#line 192
        l = l->next;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
    } else {
      {
#line 196
      printf((char const   */* __restrict  */)"IgnoreRemoteFile       (NULL)\n");
      }
    }
#line 198
    if ((unsigned long )*(ascii_file + i) != (unsigned long )((void *)0)) {
#line 199
      l = *(ascii_file + i);
      {
#line 199
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 199
        if (! ((unsigned long )l != (unsigned long )((void *)0))) {
#line 199
          goto while_break___4;
        }
        {
#line 200
        printf((char const   */* __restrict  */)"AsciiFile              %s\n", l->str);
#line 199
        l = l->next;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
    } else {
      {
#line 203
      printf((char const   */* __restrict  */)"AsciiFile              (NULL)\n");
      }
    }
#line 205
    if ((unsigned long )*(keep_remote_dir + i) != (unsigned long )((void *)0)) {
#line 206
      l = *(keep_remote_dir + i);
      {
#line 206
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 206
        if (! ((unsigned long )l != (unsigned long )((void *)0))) {
#line 206
          goto while_break___5;
        }
        {
#line 207
        printf((char const   */* __restrict  */)"KeepRemoteDir          %s\n", l->str);
#line 206
        l = l->next;
        }
      }
      while_break___5: /* CIL Label */ ;
      }
    } else {
      {
#line 210
      printf((char const   */* __restrict  */)"KeepRemoteDir          (NULL)\n");
      }
    }
#line 212
    if ((unsigned long )*(change_permission_dir + i) != (unsigned long )((void *)0)) {
#line 213
      l = *(change_permission_dir + i);
      {
#line 213
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 213
        if (! ((unsigned long )l != (unsigned long )((void *)0))) {
#line 213
          goto while_break___6;
        }
        {
#line 214
        printf((char const   */* __restrict  */)"ChangePermissionDir    %s\n", l->str);
#line 213
        l = l->next;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
    } else {
      {
#line 217
      printf((char const   */* __restrict  */)"ChangePermissionDir    (NULL)\n");
      }
    }
#line 219
    if ((unsigned long )*(change_permission + i) == (unsigned long )((void *)0)) {
#line 219
      tmp___6 = "(NULL)";
    } else {
#line 219
      tmp___6 = (char const   *)*(change_permission + i);
    }
    {
#line 219
    printf((char const   */* __restrict  */)"ChangePermission       %s\n", tmp___6);
    }
#line 220
    if ((unsigned long )*(preserve_permission_dir + i) != (unsigned long )((void *)0)) {
#line 221
      l = *(preserve_permission_dir + i);
      {
#line 221
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 221
        if (! ((unsigned long )l != (unsigned long )((void *)0))) {
#line 221
          goto while_break___7;
        }
        {
#line 222
        printf((char const   */* __restrict  */)"PreservePermissionDir  %s\n", l->str);
#line 221
        l = l->next;
        }
      }
      while_break___7: /* CIL Label */ ;
      }
    } else {
      {
#line 225
      printf((char const   */* __restrict  */)"PreservePermissionDir  (NULL)\n");
      }
    }
#line 227
    if (*(conv_to_lower + i)) {
#line 227
      tmp___7 = "True";
    } else {
#line 227
      tmp___7 = "False";
    }
    {
#line 227
    printf((char const   */* __restrict  */)"ConvToLower            %s\n", tmp___7);
    }
#line 228
    if (*(overwrite_ok + i)) {
#line 228
      tmp___8 = "True";
    } else {
#line 228
      tmp___8 = "False";
    }
    {
#line 228
    printf((char const   */* __restrict  */)"OverwriteOK            %s\n", tmp___8);
    }
#line 229
    if (*(rename_ok + i)) {
#line 229
      tmp___9 = "True";
    } else {
#line 229
      tmp___9 = "False";
    }
    {
#line 229
    printf((char const   */* __restrict  */)"RenameOK               %s\n", tmp___9);
    }
#line 230
    if (*(record_log + i)) {
#line 230
      tmp___10 = "True";
    } else {
#line 230
      tmp___10 = "False";
    }
    {
#line 230
    printf((char const   */* __restrict  */)"RecordLog              %s\n", tmp___10);
    }
#line 231
    if (*(cfg_silent + i)) {
#line 231
      tmp___11 = "True";
    } else {
#line 231
      tmp___11 = "False";
    }
    {
#line 231
    printf((char const   */* __restrict  */)"Silent                 %s\n", tmp___11);
    }
#line 232
    if (*(cfg_force + i)) {
#line 232
      tmp___12 = "True";
    } else {
#line 232
      tmp___12 = "False";
    }
    {
#line 232
    printf((char const   */* __restrict  */)"Force                  %s\n", tmp___12);
    }
#line 233
    if (*(cfg_monochrome + i)) {
#line 233
      tmp___13 = "True";
    } else {
#line 233
      tmp___13 = "False";
    }
    {
#line 233
    printf((char const   */* __restrict  */)"Monochrome             %s\n", tmp___13);
    }
#line 234
    if (*(ftp_passive + i)) {
#line 234
      tmp___14 = "True";
    } else {
#line 234
      tmp___14 = "False";
    }
    {
#line 234
    printf((char const   */* __restrict  */)"FtpPassive             %s\n", tmp___14);
    }
#line 235
    if (*(show_hidden_file + i)) {
#line 235
      tmp___15 = "True";
    } else {
#line 235
      tmp___15 = "False";
    }
    {
#line 235
    printf((char const   */* __restrict  */)"ShowHiddenFile         %s\n", tmp___15);
#line 236
    printf((char const   */* __restrict  */)"NestSpaces             %d\n", *(nest_spaces + i));
#line 237
    printf((char const   */* __restrict  */)"LogDetailLevel         %d\n", *(log_detail_level + i));
#line 238
    printf((char const   */* __restrict  */)"MaxRetryToSend         %d\n\n", *(max_retry_to_send + i));
#line 162
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 240
  return;
}
}
#line 150 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 573 "/usr/include/regex.h"
extern int regcomp(regex_t * __restrict  __preg , char const   * __restrict  __pattern ,
                   int __cflags ) ;
#line 577
extern int regexec(regex_t const   * __restrict  __preg , char const   * __restrict  __string ,
                   size_t __nmatch , regmatch_t * __restrict  __pmatch , int __eflags ) ;
#line 585
extern void regfree(regex_t *__preg ) ;
#line 108 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/proto.h"
long n_atol(char *str , int n ) ;
#line 109
int cmp_file_with_wildcard(char *real_name , char *wild_name ) ;
#line 110
char *cnvregexp(char *str ) ;
#line 49 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/sub.c"
long n_atol(char *str , int n ) 
{ 
  char *temp ;
  long result ;
  void *tmp ;

  {
  {
#line 54
  tmp = str_malloc((size_t )(n + 1));
#line 54
  temp = (char *)tmp;
#line 55
  strncpy((char */* __restrict  */)temp, (char const   */* __restrict  */)str, (size_t )n);
#line 56
  *(temp + n) = (char )'\000';
#line 58
  result = atol((char const   *)temp);
#line 60
  free((void *)temp);
  }
#line 61
  return (result);
}
}
#line 72 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/sub.c"
int cmp_file_with_wildcard(char *real_name , char *wild_name ) 
{ 
  char *temp ;
  regex_t re ;
  int res ;
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 78
  temp = cnvregexp(wild_name);
#line 80
  tmp___0 = regcomp((regex_t */* __restrict  */)(& re), (char const   */* __restrict  */)temp,
                    1);
  }
#line 80
  if (tmp___0 != 0) {
    {
#line 81
    tmp = dgettext("weex", "Invalid wildcard `%s\'.\n");
#line 81
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
            wild_name);
#line 82
    exit(1);
    }
  }
  {
#line 84
  res = regexec((regex_t const   */* __restrict  */)(& re), (char const   */* __restrict  */)real_name,
                (size_t )0, (regmatch_t */* __restrict  */)((void *)0), 0);
#line 85
  regfree(& re);
#line 86
  free((void *)temp);
  }
#line 87
  if (res == 0) {
#line 88
    return (0);
  } else {
#line 90
    return (-1);
  }
}
}
#line 101 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/sub.c"
char *cnvregexp(char *str ) 
{ 
  char *cp ;
  char *pattern ;
  int i ;
  int flag ;
  size_t tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  void *tmp___14 ;

  {
  {
#line 105
  flag = 0;
#line 107
  tmp = strlen((char const   *)str);
#line 107
  tmp___0 = str_malloc((1UL + tmp * 2UL) + 3UL);
#line 107
  pattern = (char *)tmp___0;
#line 108
  i = 0;
#line 109
  tmp___1 = i;
#line 109
  i ++;
#line 109
  *(pattern + tmp___1) = (char )'^';
#line 110
  cp = str;
  }
  {
#line 110
  while (1) {
    while_continue: /* CIL Label */ ;
#line 110
    if (! *cp) {
#line 110
      goto while_break;
    }
#line 111
    if (flag) {
#line 112
      if ((int )*cp == 93) {
#line 112
        flag = 0;
      }
#line 113
      tmp___2 = i;
#line 113
      i ++;
#line 113
      *(pattern + tmp___2) = *cp;
#line 114
      goto __Cont;
    }
    {
#line 117
    if ((int )*cp == 92) {
#line 117
      goto case_92;
    }
#line 122
    if ((int )*cp == 63) {
#line 122
      goto case_63;
    }
#line 125
    if ((int )*cp == 42) {
#line 125
      goto case_42;
    }
#line 129
    if ((int )*cp == 91) {
#line 129
      goto case_91;
    }
#line 135
    if ((int )*cp == 46) {
#line 135
      goto case_46;
    }
#line 135
    if ((int )*cp == 36) {
#line 135
      goto case_46;
    }
#line 135
    if ((int )*cp == 94) {
#line 135
      goto case_46;
    }
#line 137
    goto switch_default;
    case_92: /* CIL Label */ 
#line 118
    if (! *(cp + 1)) {
#line 118
      goto switch_break;
    }
#line 119
    tmp___3 = i;
#line 119
    i ++;
#line 119
    tmp___4 = cp;
#line 119
    cp ++;
#line 119
    *(pattern + tmp___3) = *tmp___4;
#line 120
    tmp___5 = i;
#line 120
    i ++;
#line 120
    *(pattern + tmp___5) = *cp;
#line 121
    goto switch_break;
    case_63: /* CIL Label */ 
#line 123
    tmp___6 = i;
#line 123
    i ++;
#line 123
    *(pattern + tmp___6) = (char )'.';
#line 124
    goto switch_break;
    case_42: /* CIL Label */ 
#line 126
    tmp___7 = i;
#line 126
    i ++;
#line 126
    *(pattern + tmp___7) = (char )'.';
#line 127
    tmp___8 = i;
#line 127
    i ++;
#line 127
    *(pattern + tmp___8) = (char )'*';
#line 128
    goto switch_break;
    case_91: /* CIL Label */ 
#line 130
    flag = 1;
#line 131
    tmp___9 = i;
#line 131
    i ++;
#line 131
    *(pattern + tmp___9) = *cp;
#line 132
    goto switch_break;
    case_46: /* CIL Label */ 
    case_36: /* CIL Label */ 
    case_94: /* CIL Label */ 
#line 136
    tmp___10 = i;
#line 136
    i ++;
#line 136
    *(pattern + tmp___10) = (char )'\\';
    switch_default: /* CIL Label */ 
#line 138
    tmp___11 = i;
#line 138
    i ++;
#line 138
    *(pattern + tmp___11) = *cp;
#line 139
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 110
    cp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 142
  tmp___12 = i;
#line 142
  i ++;
#line 142
  *(pattern + tmp___12) = (char )'$';
#line 143
  tmp___13 = i;
#line 143
  i ++;
#line 143
  *(pattern + tmp___13) = (char )'\000';
#line 144
  tmp___14 = str_realloc((void *)pattern, (size_t )i);
#line 144
  pattern = (char *)tmp___14;
  }
#line 146
  return (pattern);
}
}
#line 178 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) remove)(char const   *__filename ) ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 192 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) creat)(char const   *__file , mode_t __mode ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 243
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 287 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *__name ,
                                                                                             int __type ) ;
#line 353
extern int close(int __fd ) ;
#line 444
extern unsigned int sleep(unsigned int __seconds ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 879
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gethostname)(char *__name ,
                                                                                                  size_t __len ) ;
#line 115 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/proto.h"
void log_init(void) ;
#line 116
FILE *log_open(void) ;
#line 117
void log_close(FILE *fp ) ;
#line 118
void log_write(char *str ) ;
#line 119
void log_flush(void) ;
#line 41 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/log.c"
static char **log_str  ;
#line 42 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/log.c"
static int max_log  ;
#line 43 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/log.c"
static char weex_host[64]  ;
#line 44 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/log.c"
static pid_t weex_pid  ;
#line 53 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/log.c"
void log_init(void) 
{ 
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 55
  weex_pid = getpid();
#line 56
  tmp___0 = gethostname(weex_host, (size_t )63);
  }
#line 56
  if (tmp___0 == -1) {
    {
#line 57
    tmp = dgettext("weex", "Cannot get a host name. Proceed anyway.\n");
#line 57
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp);
#line 58
    strcpy((char */* __restrict  */)(weex_host), (char const   */* __restrict  */)"unknown");
    }
  }
#line 60
  log_str = (char **)((void *)0);
#line 61
  max_log = 0;
#line 62
  return;
}
}
#line 71 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/log.c"
FILE *log_open(void) 
{ 
  char *log_file ;
  char *lock_file ;
  FILE *fp ;
  int fd ;
  int i ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 77
  i = 0;
#line 79
  tmp = getenv("HOME");
#line 79
  log_file = str_concat((char const   *)tmp, "/.weex/weex.log", (void *)0);
#line 80
  tmp___0 = getenv("HOME");
#line 80
  lock_file = str_concat((char const   *)tmp___0, "/.weex/.lock", (void *)0);
  }
  {
#line 82
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 82
    tmp___4 = access((char const   *)lock_file, 0);
    }
#line 82
    if (! (tmp___4 == 0)) {
#line 82
      goto while_break;
    }
#line 83
    i ++;
#line 84
    if (i > 120) {
      {
#line 85
      tmp___1 = dgettext("weex", "Stopped.\n");
#line 85
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1);
#line 86
      exit(1);
      }
    }
#line 88
    if (i % 12 == 0) {
      {
#line 89
      tmp___2 = dgettext("weex", "Log file `%s\' seems to be always locked.\nRemove lock file `%s\'.\n");
#line 89
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___2,
              log_file, lock_file);
      }
    } else {
      {
#line 91
      tmp___3 = dgettext("weex", "Another weex is using log file `%s\'. Just a moment.\n");
#line 91
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___3,
              log_file);
      }
    }
    {
#line 93
    sleep(5U);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 96
  fd = creat((char const   *)lock_file, (mode_t )((384 | (256 >> 3)) | ((256 >> 3) >> 3)));
  }
#line 97
  if (fd == -1) {
    {
#line 98
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot create lock file `%s\'.\n",
            lock_file);
#line 99
    exit(1);
    }
  }
  {
#line 101
  close(fd);
#line 103
  fp = fopen((char const   */* __restrict  */)log_file, (char const   */* __restrict  */)"a");
  }
#line 104
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 105
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot open log file `%s\'.\n",
            log_file);
#line 106
    remove((char const   *)lock_file);
    }
  }
  {
#line 109
  free((void *)lock_file);
#line 110
  free((void *)log_file);
  }
#line 112
  return (fp);
}
}
#line 122 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/log.c"
void log_close(FILE *fp ) 
{ 
  char *lock_file ;
  char *tmp ;

  {
  {
#line 126
  tmp = getenv("HOME");
#line 126
  lock_file = str_concat((char const   *)tmp, "/.weex/.lock", (void *)0);
#line 128
  fclose(fp);
#line 129
  remove((char const   *)lock_file);
#line 131
  free((void *)lock_file);
  }
#line 132
  return;
}
}
#line 142 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/log.c"
void log_write(char *str ) 
{ 
  struct tm *nowtime ;
  time_t t ;
  char *month_str[12] ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 146
  month_str[0] = (char *)"Jan";
#line 146
  month_str[1] = (char *)"Feb";
#line 146
  month_str[2] = (char *)"Mar";
#line 146
  month_str[3] = (char *)"Apr";
#line 146
  month_str[4] = (char *)"May";
#line 146
  month_str[5] = (char *)"Jun";
#line 146
  month_str[6] = (char *)"Jul";
#line 146
  month_str[7] = (char *)"Aug";
#line 146
  month_str[8] = (char *)"Sep";
#line 146
  month_str[9] = (char *)"Oct";
#line 146
  month_str[10] = (char *)"Nov";
#line 146
  month_str[11] = (char *)"Dec";
#line 161
  t = time((time_t *)((void *)0));
#line 162
  nowtime = localtime((time_t const   *)(& t));
#line 164
  max_log ++;
#line 165
  tmp = str_realloc((void *)log_str, (unsigned long )max_log * sizeof(*log_str));
#line 165
  log_str = (char **)tmp;
#line 166
  tmp___0 = dgettext("weex", (char const   *)month_str[nowtime->tm_mon]);
#line 166
  tmp___1 = dgettext("weex", "%s %2d %02d:%02d:%02d %s weex[%d]: %s\n");
#line 166
  *(log_str + (max_log - 1)) = str_dup_printf((char const   *)tmp___1, tmp___0, nowtime->tm_mday,
                                              nowtime->tm_hour, nowtime->tm_min, nowtime->tm_sec,
                                              weex_host, weex_pid, str);
  }
#line 167
  return;
}
}
#line 175 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/log.c"
void log_flush(void) 
{ 
  FILE *fp ;
  int i ;

  {
#line 180
  if (! *(record_log + host_number)) {
#line 181
    return;
  }
  {
#line 184
  fp = log_open();
#line 185
  i = 0;
  }
  {
#line 185
  while (1) {
    while_continue: /* CIL Label */ ;
#line 185
    if (! (i < max_log)) {
#line 185
      goto while_break;
    }
    {
#line 186
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s", *(log_str + i));
#line 187
    free((void *)*(log_str + i));
#line 185
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 189
  free((void *)log_str);
#line 191
  log_close(fp);
  }
#line 192
  return;
}
}
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 321
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) mkdir)(char const   *__path ,
                                                                                            __mode_t __mode ) ;
#line 92 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/parsecfg.h"
int cfgParse(char *file , cfgStruct *cfg , cfgFileType type ) ;
#line 95
int cfgSectionNameToNumber(char const   *name ) ;
#line 42 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/proto.h"
void set_default(int max_hosts ) ;
#line 43
void set_str_default(int host , int default_num , char **str_pointer ) ;
#line 44
void set_list_default(int host , int default_num , cfgList **list_pointer ) ;
#line 45
void set_bool_default(int host , int default_num , int bool_default , int *bool_pointer ) ;
#line 46
void set_int_default(int host , int default_num , int default_val , int *int_pointer ) ;
#line 47
void str_attach_slash_to_trailing(int host , char **str_pointer ) ;
#line 48
void list_attach_slash_to_trailing(int host , cfgList **list_pointer ) ;
#line 49
void absolutize_path(int host , char *base_dir , cfgList **list_absolute_path ) ;
#line 50
void absolutize_file(int host , char *base_dir , cfgList **list_absolute_file ) ;
#line 39 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/config.c"
static cfgStruct weex_config[30]  = 
#line 39 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/config.c"
  {      {(char *)"HostName", (cfgValueType )2, (void *)(& host_name)}, 
        {(char *)"LoginName", (cfgValueType )2, (void *)(& login_name)}, 
        {(char *)"AuthorizationName", (cfgValueType )2, (void *)(& authorization_name)}, 
        {(char *)"Password",
      (cfgValueType )2, (void *)(& password)}, 
        {(char *)"SrcDir", (cfgValueType )2, (void *)(& src_dir)}, 
        {(char *)"DestDir", (cfgValueType )2, (void *)(& dest_dir)}, 
        {(char *)"IgnoreLocalDir", (cfgValueType )7, (void *)(& ignore_local_dir)}, 
        {(char *)"IgnoreLocalFile", (cfgValueType )7, (void *)(& ignore_local_file)}, 
        {(char *)"IgnoreRemoteDir",
      (cfgValueType )7, (void *)(& ignore_remote_dir)}, 
        {(char *)"IgnoreRemoteFile", (cfgValueType )7, (void *)(& ignore_remote_file)}, 
        {(char *)"KeepRemoteDir",
      (cfgValueType )7, (void *)(& keep_remote_dir)}, 
        {(char *)"AsciiFile", (cfgValueType )7, (void *)(& ascii_file)}, 
        {(char *)"ChangePermission", (cfgValueType )2, (void *)(& change_permission)}, 
        {(char *)"ChangePermissionDir",
      (cfgValueType )7, (void *)(& change_permission_dir)}, 
        {(char *)"PreservePermissionDir", (cfgValueType )7, (void *)(& preserve_permission_dir)}, 
        {(char *)"ConvToLower",
      (cfgValueType )1, (void *)(& conv_to_lower)}, 
        {(char *)"OverwriteOK", (cfgValueType )1, (void *)(& overwrite_ok)}, 
        {(char *)"RenameOK", (cfgValueType )1, (void *)(& rename_ok)}, 
        {(char *)"RecordLog", (cfgValueType )1, (void *)(& record_log)}, 
        {(char *)"Silent", (cfgValueType )1, (void *)(& cfg_silent)}, 
        {(char *)"Force", (cfgValueType )1, (void *)(& cfg_force)}, 
        {(char *)"Monochrome", (cfgValueType )1, (void *)(& cfg_monochrome)}, 
        {(char *)"FtpPassive", (cfgValueType )1, (void *)(& ftp_passive)}, 
        {(char *)"ShowHiddenFile", (cfgValueType )1, (void *)(& show_hidden_file)}, 
        {(char *)"FollowSymlinks", (cfgValueType )1, (void *)(& follow_symlinks)}, 
        {(char *)"ChdirAtConnection", (cfgValueType )1, (void *)(& chdir_at_connection)}, 
        {(char *)"NestSpaces",
      (cfgValueType )3, (void *)(& nest_spaces)}, 
        {(char *)"LogDetailLevel", (cfgValueType )3, (void *)(& log_detail_level)}, 
        {(char *)"MaxRetryToSend", (cfgValueType )3, (void *)(& max_retry_to_send)}, 
        {(char *)((void *)0), (cfgValueType )0, (void *)0}};
#line 81 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/config.c"
char *config_location(void) 
{ 
  char *temp ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 85
  tmp = getenv("HOME");
#line 85
  temp = str_concat((char const   *)tmp, "/.weex/weexrc", (void *)0);
#line 86
  tmp___2 = access((char const   *)temp, 0);
  }
#line 86
  if (tmp___2 != 0) {
    {
#line 87
    free((void *)temp);
#line 88
    tmp___0 = getenv("HOME");
#line 88
    temp = str_concat((char const   *)tmp___0, "/.weexrc", (void *)0);
#line 89
    tmp___1 = access((char const   *)temp, 0);
    }
#line 89
    if (tmp___1 != 0) {
      {
#line 90
      free((void *)temp);
      }
#line 91
      return ((char *)((void *)0));
    }
  }
#line 94
  return (temp);
}
}
#line 104 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/config.c"
int read_config(void) 
{ 
  char *temp ;
  int max_hosts ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 109
  temp = config_location();
  }
#line 110
  if ((unsigned long )temp == (unsigned long )((void *)0)) {
    {
#line 111
    tmp = getenv("HOME");
#line 111
    tmp___0 = dgettext("weex", "Configuration file `%s/.weex/weexrc\' does not exist.\n");
#line 111
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
            tmp);
#line 112
    exit(1);
    }
  }
  {
#line 114
  max_hosts = cfgParse(temp, weex_config, (cfgFileType )1);
  }
#line 116
  if (max_hosts == 0) {
    {
#line 117
    tmp___1 = dgettext("weex", "There is no section in configuration file.\n");
#line 117
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1);
#line 118
    exit(1);
    }
  }
  {
#line 121
  set_default(max_hosts);
#line 122
  check_permission(temp);
#line 123
  free((void *)temp);
  }
#line 125
  return (max_hosts);
}
}
#line 135 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/config.c"
void make_weex_directory(void) 
{ 
  char *temp ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 139
  tmp = getenv("HOME");
#line 139
  temp = str_concat((char const   *)tmp, "/.weex", (void *)0);
#line 140
  tmp___3 = access((char const   *)temp, 0);
  }
#line 140
  if (tmp___3 != 0) {
    {
#line 141
    tmp___1 = mkdir((char const   *)temp, (__mode_t )493);
    }
#line 141
    if (tmp___1 != 0) {
      {
#line 142
      tmp___0 = dgettext("weex", "Cannot make directory `%s\'.\n");
#line 142
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
              temp);
#line 143
      exit(1);
      }
    }
    {
#line 145
    tmp___2 = dgettext("weex", "Created directory `%s\'.\n");
#line 145
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___2,
            temp);
    }
  }
  {
#line 147
  free((void *)temp);
  }
#line 148
  return;
}
}
#line 157 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/config.c"
void check_permission(char *file ) 
{ 
  struct stat s ;
  mode_t mode ;
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 162
  tmp___0 = stat((char const   */* __restrict  */)file, (struct stat */* __restrict  */)(& s));
  }
#line 162
  if (tmp___0 != 0) {
    {
#line 163
    tmp = dgettext("weex", "Cannot get file status: `%s\'\n");
#line 163
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
            file);
#line 164
    exit(1);
    }
  }
#line 167
  mode = s.st_mode & 319U;
#line 168
  if (mode != 256U) {
    {
#line 169
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning! Set `%s\' permissions to 600.\n\n",
            file);
    }
  }
#line 171
  return;
}
}
#line 180 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/config.c"
void set_default(int max_hosts ) 
{ 
  int i ;
  int default_num ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 185
  default_num = cfgSectionNameToNumber("default");
  }
#line 186
  if (default_num == -1) {
    {
#line 187
    tmp = dgettext("weex", "A `default\' section is required.\n");
#line 187
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp);
#line 188
    exit(1);
    }
  }
#line 190
  i = 0;
  {
#line 190
  while (1) {
    while_continue: /* CIL Label */ ;
#line 190
    if (! (i < max_hosts)) {
#line 190
      goto while_break;
    }
    {
#line 191
    set_str_default(i, default_num, login_name);
#line 192
    set_str_default(i, default_num, authorization_name);
#line 193
    set_str_default(i, default_num, password);
#line 194
    set_str_default(i, default_num, src_dir);
#line 195
    set_str_default(i, default_num, dest_dir);
#line 196
    set_str_default(i, default_num, change_permission);
#line 198
    set_list_default(i, default_num, ignore_local_dir);
#line 199
    set_list_default(i, default_num, ignore_local_file);
#line 200
    set_list_default(i, default_num, ignore_remote_dir);
#line 201
    set_list_default(i, default_num, ignore_remote_file);
#line 202
    set_list_default(i, default_num, keep_remote_dir);
#line 203
    set_list_default(i, default_num, ascii_file);
#line 204
    set_list_default(i, default_num, change_permission_dir);
#line 205
    set_list_default(i, default_num, preserve_permission_dir);
#line 207
    set_bool_default(i, default_num, 0, conv_to_lower);
#line 208
    set_bool_default(i, default_num, 0, cfg_silent);
#line 209
    set_bool_default(i, default_num, 0, cfg_force);
#line 210
    set_bool_default(i, default_num, 0, cfg_monochrome);
#line 211
    set_bool_default(i, default_num, 0, show_hidden_file);
#line 212
    set_bool_default(i, default_num, 0, follow_symlinks);
#line 213
    set_bool_default(i, default_num, 0, rename_ok);
#line 215
    set_bool_default(i, default_num, 1, overwrite_ok);
#line 216
    set_bool_default(i, default_num, 1, record_log);
#line 217
    set_bool_default(i, default_num, 1, ftp_passive);
#line 218
    set_bool_default(i, default_num, 1, chdir_at_connection);
#line 220
    set_int_default(i, default_num, 4, nest_spaces);
#line 221
    set_int_default(i, default_num, 1, log_detail_level);
#line 222
    set_int_default(i, default_num, 8, max_retry_to_send);
#line 225
    str_attach_slash_to_trailing(i, src_dir);
#line 226
    str_attach_slash_to_trailing(i, dest_dir);
#line 227
    list_attach_slash_to_trailing(i, ignore_local_dir);
#line 228
    list_attach_slash_to_trailing(i, ignore_remote_dir);
#line 229
    list_attach_slash_to_trailing(i, keep_remote_dir);
#line 230
    list_attach_slash_to_trailing(i, change_permission_dir);
#line 231
    list_attach_slash_to_trailing(i, preserve_permission_dir);
#line 234
    absolutize_path(i, *(src_dir + i), ignore_local_dir);
#line 235
    absolutize_path(i, *(dest_dir + i), ignore_remote_dir);
#line 236
    absolutize_path(i, *(dest_dir + i), keep_remote_dir);
#line 237
    absolutize_path(i, *(src_dir + i), change_permission_dir);
#line 238
    absolutize_path(i, *(src_dir + i), preserve_permission_dir);
#line 239
    absolutize_file(i, *(src_dir + i), ignore_local_file);
#line 240
    absolutize_file(i, *(dest_dir + i), ignore_remote_file);
#line 241
    absolutize_file(i, *(src_dir + i), ascii_file);
    }
#line 244
    if ((unsigned long )*(change_permission_dir + i) != (unsigned long )((void *)0)) {
#line 244
      if ((unsigned long )*(change_permission + i) == (unsigned long )((void *)0)) {
        {
#line 245
        tmp___0 = dgettext("weex", "When you set ChangePermissionDir, you must configure ChangePermission.\n");
#line 245
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0);
#line 246
        exit(1);
        }
      }
    }
#line 190
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 249
  return;
}
}
#line 260 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/config.c"
void set_str_default(int host , int default_num , char **str_pointer ) 
{ 


  {
#line 262
  if ((unsigned long )*(str_pointer + host) == (unsigned long )((void *)0)) {
    {
#line 263
    *(str_pointer + host) = str_dup((char const   *)*(str_pointer + default_num));
    }
  }
#line 265
  return;
}
}
#line 276 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/config.c"
void set_list_default(int host , int default_num , cfgList **list_pointer ) 
{ 
  cfgList *head ;
  cfgList *src ;
  cfgList *dest ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 282
  src = *(list_pointer + default_num);
#line 284
  if ((unsigned long )*(list_pointer + host) != (unsigned long )((void *)0)) {
#line 285
    return;
  } else
#line 284
  if ((unsigned long )src == (unsigned long )((void *)0)) {
#line 285
    return;
  }
  {
#line 288
  tmp = str_malloc(sizeof(cfgList ));
#line 288
  dest = (cfgList *)tmp;
#line 288
  head = dest;
#line 289
  dest->str = str_dup((char const   *)src->str);
#line 291
  src = src->next;
  }
  {
#line 291
  while (1) {
    while_continue: /* CIL Label */ ;
#line 291
    if (! ((unsigned long )src != (unsigned long )((void *)0))) {
#line 291
      goto while_break;
    }
    {
#line 292
    tmp___0 = str_malloc(sizeof(cfgList ));
#line 292
    dest->next = (cfgListPtr )tmp___0;
#line 293
    dest = dest->next;
#line 294
    dest->str = str_dup((char const   *)src->str);
#line 291
    src = src->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 296
  dest->next = (cfgListPtr )((void *)0);
#line 298
  *(list_pointer + host) = head;
#line 299
  return;
}
}
#line 312 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/config.c"
void set_bool_default(int host , int default_num , int bool_default , int *bool_pointer ) 
{ 


  {
#line 314
  if (*(bool_pointer + host) == -1) {
#line 315
    if (*(bool_pointer + default_num) == -1) {
#line 315
      *(bool_pointer + host) = bool_default;
    } else {
#line 315
      *(bool_pointer + host) = *(bool_pointer + default_num);
    }
  }
#line 317
  return;
}
}
#line 331 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/config.c"
void set_int_default(int host , int default_num , int default_val , int *int_pointer ) 
{ 


  {
#line 333
  if (*(int_pointer + host) == 0) {
#line 334
    if (*(int_pointer + default_num) == 0) {
#line 335
      *(int_pointer + host) = default_val;
    } else
#line 337
    if (*(int_pointer + host) < 0) {
#line 337
      *(int_pointer + host) = 0;
    } else {
#line 337
      *(int_pointer + host) = *(int_pointer + default_num);
    }
  }
#line 340
  return;
}
}
#line 350 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/config.c"
void str_attach_slash_to_trailing(int host , char **str_pointer ) 
{ 
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;

  {
#line 352
  if ((unsigned long )*(str_pointer + host) == (unsigned long )((void *)0)) {
#line 353
    return;
  }
  {
#line 355
  tmp___1 = strlen((char const   *)*(str_pointer + host));
  }
#line 355
  if ((int )*((*(str_pointer + host) + tmp___1) - 1) != 47) {
    {
#line 356
    tmp = strlen((char const   *)*(str_pointer + host));
#line 356
    tmp___0 = str_realloc((void *)*(str_pointer + host), tmp + 2UL);
#line 356
    *(str_pointer + host) = (char *)tmp___0;
#line 357
    strcat((char */* __restrict  */)*(str_pointer + host), (char const   */* __restrict  */)"/");
    }
  }
#line 359
  return;
}
}
#line 369 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/config.c"
void list_attach_slash_to_trailing(int host , cfgList **list_pointer ) 
{ 
  cfgList *l ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;

  {
#line 373
  l = *(list_pointer + host);
#line 374
  if ((unsigned long )l == (unsigned long )((void *)0)) {
#line 375
    return;
  } else
#line 374
  if ((unsigned long )l->str == (unsigned long )((void *)0)) {
#line 375
    return;
  }
  {
#line 377
  while (1) {
    while_continue: /* CIL Label */ ;
#line 377
    if (! ((unsigned long )l != (unsigned long )((void *)0))) {
#line 377
      goto while_break;
    }
    {
#line 378
    tmp___1 = strlen((char const   *)l->str);
    }
#line 378
    if ((int )*((l->str + tmp___1) - 1) != 47) {
      {
#line 379
      tmp = strlen((char const   *)l->str);
#line 379
      tmp___0 = str_realloc((void *)l->str, tmp + 2UL);
#line 379
      l->str = (char *)tmp___0;
#line 380
      strcat((char */* __restrict  */)l->str, (char const   */* __restrict  */)"/");
      }
    }
#line 377
    l = l->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 383
  return;
}
}
#line 394 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/config.c"
void absolutize_path(int host , char *base_dir , cfgList **list_absolute_path ) 
{ 
  cfgList *l ;
  char *temp ;
  int tmp ;

  {
#line 399
  l = *(list_absolute_path + host);
#line 400
  if ((unsigned long )l == (unsigned long )((void *)0)) {
#line 401
    return;
  } else
#line 400
  if ((unsigned long )l->str == (unsigned long )((void *)0)) {
#line 401
    return;
  }
  {
#line 403
  while (1) {
    while_continue: /* CIL Label */ ;
#line 403
    if (! ((unsigned long )l != (unsigned long )((void *)0))) {
#line 403
      goto while_break;
    }
    {
#line 404
    tmp = strcmp((char const   *)l->str, "./");
    }
#line 404
    if (tmp == 0) {
      {
#line 405
      temp = l->str;
#line 406
      l->str = str_dup((char const   *)base_dir);
#line 407
      free((void *)temp);
      }
    } else
#line 408
    if ((int )*(l->str) != 47) {
      {
#line 409
      temp = l->str;
#line 410
      l->str = str_concat((char const   *)base_dir, temp, (void *)0);
#line 411
      free((void *)temp);
      }
    }
#line 403
    l = l->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 414
  return;
}
}
#line 425 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/config.c"
void absolutize_file(int host , char *base_dir , cfgList **list_absolute_file ) 
{ 
  cfgList *l ;
  char *temp ;
  char *tmp ;
  int tmp___0 ;

  {
#line 430
  if ((unsigned long )*(list_absolute_file + host) == (unsigned long )((void *)0)) {
#line 431
    return;
  }
#line 433
  l = *(list_absolute_file + host);
  {
#line 433
  while (1) {
    while_continue: /* CIL Label */ ;
#line 433
    if (! ((unsigned long )l != (unsigned long )((void *)0))) {
#line 433
      goto while_break;
    }
    {
#line 434
    tmp = strchr((char const   *)l->str, '/');
    }
#line 434
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 435
      goto __Cont;
    }
#line 437
    if ((int )*(l->str) != 47) {
      {
#line 438
      temp = l->str;
#line 439
      tmp___0 = strncmp((char const   *)temp, "./", (size_t )2);
      }
#line 439
      if (tmp___0 == 0) {
        {
#line 440
        l->str = str_concat((char const   *)base_dir, temp + 2, (void *)0);
        }
      } else {
        {
#line 442
        l->str = str_concat((char const   *)base_dir, temp, (void *)0);
        }
      }
      {
#line 444
      free((void *)temp);
      }
    }
    __Cont: /* CIL Label */ 
#line 433
    l = l->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 447
  return;
}
}
#line 828 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 534 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 91 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/parsecfg.h"
void cfgSetFatalFunc(void (*f)(cfgErrorCode  , char * , int  , char * ) ) ;
#line 93
void cfgDump(char *file , cfgStruct *cfg , cfgFileType type , int max_section ) ;
#line 94
int fetchVarFromCfgFile(char *file , char *parameter_name , void *result_value , cfgValueType value_type ,
                        cfgFileType file_type , int section_num , char *section_name ) ;
#line 38 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/parsecfg.c"
void cfgFatalFunc(cfgErrorCode error_code , char *file , int line , char *str ) ;
#line 39 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/parsecfg.c"
void (*cfgFatal)(cfgErrorCode  , char * , int  , char * )  =    & cfgFatalFunc;
#line 41
int parse_simple(char *file , FILE *fp , char *ptr , cfgStruct *cfg , int *line ) ;
#line 42
void parse_values_between_braces(char *file , FILE *fp , char *parameter , cfgStruct *cfg ,
                                 int *line , cfgFileType type , int section , char *parameter_buf ,
                                 int parameter_line ) ;
#line 43
char *parse_word(char *ptr , char **word , cfgKeywordValue word_type ) ;
#line 44
int store_value(cfgStruct *cfg , char *parameter , char *value , cfgFileType type ,
                int section ) ;
#line 45
int parse_ini(char *file , FILE *fp , char *ptr , cfgStruct *cfg , int *line , int *section ) ;
#line 46
int alloc_for_new_section(cfgStruct *cfg , int *section ) ;
#line 48
char *get_single_line_without_first_spaces(FILE *fp , char **gotstr , int *line ) ;
#line 49
char *rm_first_spaces(char *ptr ) ;
#line 50
char *dynamic_fgets(FILE *fp ) ;
#line 52
void dump_simple(FILE *fp , cfgStruct *cfg , cfgFileType type ) ;
#line 53
void dump_ini(FILE *fp , cfgStruct *cfg , cfgFileType type , int max ) ;
#line 54
void single_or_double_quote(char *str , char *ret___0 ) ;
#line 56
int fetch_simple(char *file , FILE *fp , char *parameter_name , void *result_value ,
                 cfgValueType value_type ) ;
#line 57
int fetch_ini(char *file , FILE *fp , char *parameter_name , void *result_value ,
              cfgValueType value_type , int section_num , char *section_name ) ;
#line 62 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/parsecfg.c"
static char **parsecfg_section_name  =    (char **)((void *)0);
#line 63 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/parsecfg.c"
static int parsecfg_maximum_section  ;
#line 76 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/parsecfg.c"
void cfgSetFatalFunc(void (*f)(cfgErrorCode  , char * , int  , char * ) ) 
{ 


  {
#line 78
  cfgFatal = f;
#line 79
  return;
}
}
#line 93 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/parsecfg.c"
int cfgParse(char *file , cfgStruct *cfg , cfgFileType type ) 
{ 
  char *line_buf ;
  char *ptr ;
  int line ;
  FILE *fp ;
  int error_code ;
  int max_cfg ;

  {
  {
#line 97
  line = 0;
#line 100
  max_cfg = -1;
#line 102
  fp = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"r");
  }
#line 103
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 104
    (*cfgFatal)((cfgErrorCode )1, file, 0, (char *)((void *)0));
    }
  }
  {
#line 107
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 107
    ptr = get_single_line_without_first_spaces(fp, & line_buf, & line);
    }
#line 107
    if (! ((unsigned long )ptr != (unsigned long )((void *)0))) {
#line 107
      goto while_break;
    }
    {
#line 109
    if ((unsigned int )type == 0U) {
#line 109
      goto case_0;
    }
#line 115
    if ((unsigned int )type == 1U) {
#line 115
      goto case_1;
    }
#line 121
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 110
    error_code = parse_simple(file, fp, ptr, cfg, & line);
    }
#line 110
    if (error_code != 0) {
      {
#line 112
      (*cfgFatal)((cfgErrorCode )error_code, file, line, line_buf);
      }
    }
#line 114
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 116
    error_code = parse_ini(file, fp, ptr, cfg, & line, & max_cfg);
    }
#line 116
    if (error_code != 0) {
      {
#line 117
      fclose(fp);
#line 118
      (*cfgFatal)((cfgErrorCode )error_code, file, line, line_buf);
      }
    }
#line 120
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 122
    fclose(fp);
#line 123
    (*cfgFatal)((cfgErrorCode )5, file, 0, (char *)((void *)0));
    }
    switch_break: /* CIL Label */ ;
    }
    {
#line 125
    free((void *)line_buf);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 127
  fclose(fp);
#line 128
  parsecfg_maximum_section = max_cfg + 1;
  }
#line 129
  return (parsecfg_maximum_section);
}
}
#line 145 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/parsecfg.c"
void cfgDump(char *file , cfgStruct *cfg , cfgFileType type , int max_section ) 
{ 
  FILE *fp ;

  {
  {
#line 149
  fp = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"w");
  }
#line 150
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 151
    (*cfgFatal)((cfgErrorCode )2, file, 0, (char *)((void *)0));
    }
  }
  {
#line 155
  if ((unsigned int )type == 0U) {
#line 155
    goto case_0;
  }
#line 158
  if ((unsigned int )type == 1U) {
#line 158
    goto case_1;
  }
#line 161
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 156
  dump_simple(fp, cfg, type);
  }
#line 157
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 159
  dump_ini(fp, cfg, type, max_section);
  }
#line 160
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 162
  fclose(fp);
#line 163
  (*cfgFatal)((cfgErrorCode )5, file, 0, (char *)((void *)0));
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 166
  fclose(fp);
  }
#line 167
  return;
}
}
#line 184 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/parsecfg.c"
int fetchVarFromCfgFile(char *file , char *parameter_name , void *result_value , cfgValueType value_type ,
                        cfgFileType file_type , int section_num , char *section_name ) 
{ 
  FILE *fp ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 188
  fp = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"r");
  }
#line 189
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 190
    (*cfgFatal)((cfgErrorCode )1, file, 0, (char *)((void *)0));
    }
  }
  {
#line 194
  if ((unsigned int )file_type == 0U) {
#line 194
    goto case_0;
  }
#line 200
  if ((unsigned int )file_type == 1U) {
#line 200
    goto case_1;
  }
#line 206
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 195
  tmp = fetch_simple(file, fp, parameter_name, result_value, value_type);
  }
#line 195
  if (tmp == 0) {
    {
#line 196
    fclose(fp);
    }
#line 197
    return (0);
  }
#line 199
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 201
  tmp___0 = fetch_ini(file, fp, parameter_name, result_value, value_type, section_num,
                      section_name);
  }
#line 201
  if (tmp___0 == 0) {
    {
#line 202
    fclose(fp);
    }
#line 203
    return (0);
  }
#line 205
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 207
  fclose(fp);
#line 208
  (*cfgFatal)((cfgErrorCode )5, file, 0, (char *)((void *)0));
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 210
  fclose(fp);
  }
#line 211
  return (-1);
}
}
#line 222 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/parsecfg.c"
int cfgSectionNameToNumber(char const   *name ) 
{ 
  int i ;
  int tmp ;

  {
#line 226
  i = 0;
  {
#line 226
  while (1) {
    while_continue: /* CIL Label */ ;
#line 226
    if (! (i < parsecfg_maximum_section)) {
#line 226
      goto while_break;
    }
    {
#line 227
    tmp = strcasecmp(name, (char const   *)*(parsecfg_section_name + i));
    }
#line 227
    if (tmp == 0) {
#line 228
      return (i);
    }
#line 226
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 231
  return (-1);
}
}
#line 242 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/parsecfg.c"
char *cfgSectionNumberToName(int num ) 
{ 


  {
#line 244
  if (num > parsecfg_maximum_section - 1) {
#line 245
    return ((char *)((void *)0));
  } else
#line 244
  if (num < 0) {
#line 245
    return ((char *)((void *)0));
  }
#line 247
  return (*(parsecfg_section_name + num));
}
}
#line 264 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/parsecfg.c"
void cfgFatalFunc(cfgErrorCode error_code , char *file , int line , char *str ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;

  {
  {
#line 267
  if ((unsigned int )error_code == 1U) {
#line 267
    goto case_1;
  }
#line 270
  if ((unsigned int )error_code == 2U) {
#line 270
    goto case_2;
  }
#line 273
  if ((unsigned int )error_code == 3U) {
#line 273
    goto case_3;
  }
#line 276
  if ((unsigned int )error_code == 4U) {
#line 276
    goto case_4;
  }
#line 279
  if ((unsigned int )error_code == 5U) {
#line 279
    goto case_5;
  }
#line 282
  if ((unsigned int )error_code == 6U) {
#line 282
    goto case_6;
  }
#line 285
  if ((unsigned int )error_code == 7U) {
#line 285
    goto case_7;
  }
#line 288
  if ((unsigned int )error_code == 8U) {
#line 288
    goto case_8;
  }
#line 291
  if ((unsigned int )error_code == 9U) {
#line 291
    goto case_9;
  }
#line 294
  if ((unsigned int )error_code == 10U) {
#line 294
    goto case_10;
  }
#line 297
  if ((unsigned int )error_code == 11U) {
#line 297
    goto case_11;
  }
#line 300
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 268
  tmp = dgettext("weex", "Configuration file `%s\' is not found.\n");
#line 268
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp, file);
  }
#line 269
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 271
  tmp___0 = dgettext("weex", "Creating configuration file `%s\' fails.\n");
#line 271
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
          file);
  }
#line 272
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 274
  tmp___1 = dgettext("weex", "%s(%d): %s\nSyntax error\n");
#line 274
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1,
          file, line, str);
  }
#line 275
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 277
  tmp___2 = dgettext("weex", "%s(%d): %s\nUnrecognized parameter\n");
#line 277
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___2,
          file, line, str);
  }
#line 278
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 280
  tmp___3 = dgettext("weex", "%s(%d): %s\nInternal error\n");
#line 280
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___3,
          file, line, str);
  }
#line 281
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 283
  tmp___4 = dgettext("weex", "%s(%d): %s\nInvalid number\n");
#line 283
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___4,
          file, line, str);
  }
#line 284
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 286
  tmp___5 = dgettext("weex", "%s(%d): %s\nOut of range\n");
#line 286
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___5,
          file, line, str);
  }
#line 287
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 289
  tmp___6 = dgettext("weex", "%s(%d): %s\nCannot allocate memory.\n");
#line 289
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___6,
          file, line, str);
  }
#line 290
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 292
  tmp___7 = dgettext("weex", "%s(%d): %s\nIt must be specified TRUE or FALSE.\n");
#line 292
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___7,
          file, line, str);
  }
#line 293
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 295
  tmp___8 = dgettext("weex", "%s(%d): %s\nThe section name is already used.\n");
#line 295
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___8,
          file, line, str);
  }
#line 296
  goto switch_break;
  case_11: /* CIL Label */ 
  {
#line 298
  tmp___9 = dgettext("weex", "%s(%d)\nThere is no closing brace.\n");
#line 298
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___9,
          file, line);
  }
#line 299
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 301
  tmp___10 = dgettext("weex", "%s(%d): %s\nUnexplained error\n");
#line 301
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___10,
          file, line, str);
  }
#line 302
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 304
  exit(1);
  }
}
}
#line 318 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/parsecfg.c"
int parse_simple(char *file , FILE *fp , char *ptr , cfgStruct *cfg , int *line ) 
{ 
  char *parameter ;
  char *parameter_buf ;
  int parameter_line ;
  char *value ;
  int error_code ;

  {
  {
#line 326
  parameter_buf = ptr;
#line 327
  parameter_line = *line;
#line 329
  ptr = parse_word(ptr, & parameter, (cfgKeywordValue )0);
  }
#line 329
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
#line 330
    return (3);
  }
#line 332
  if ((int )*ptr == 123) {
    {
#line 333
    ptr = rm_first_spaces(ptr + 1);
    }
#line 334
    if ((int )*ptr != 0) {
#line 334
      if ((int )*ptr != 35) {
#line 335
        return (3);
      }
    }
    {
#line 337
    parse_values_between_braces(file, fp, parameter, cfg, line, (cfgFileType )0, 0,
                                parameter_buf, parameter_line);
    }
  } else {
    {
#line 339
    ptr = parse_word(ptr, & value, (cfgKeywordValue )1);
    }
#line 339
    if ((unsigned long )ptr == (unsigned long )((void *)0)) {
#line 340
      return (3);
    }
    {
#line 342
    error_code = store_value(cfg, parameter, value, (cfgFileType )0, 0);
    }
#line 342
    if (error_code != 0) {
#line 343
      return (error_code);
    }
    {
#line 345
    free((void *)parameter);
#line 346
    free((void *)value);
    }
  }
#line 348
  return (0);
}
}
#line 364 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/parsecfg.c"
char *parse_word(char *ptr , char **word , cfgKeywordValue word_type ) 
{ 
  int len ;
  cfgQuote quote_flag ;
  char *tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 366
  len = 0;
  {
#line 370
  if ((int )*ptr == 34) {
#line 370
    goto case_34;
  }
#line 374
  if ((int )*ptr == 39) {
#line 374
    goto case_39;
  }
#line 378
  goto switch_default;
  case_34: /* CIL Label */ 
#line 371
  quote_flag = (cfgQuote )2;
#line 372
  ptr ++;
#line 373
  goto switch_break;
  case_39: /* CIL Label */ 
#line 375
  quote_flag = (cfgQuote )1;
#line 376
  ptr ++;
#line 377
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 379
  quote_flag = (cfgQuote )0;
#line 380
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 383
  while (1) {
    while_continue: /* CIL Label */ ;
#line 384
    if ((unsigned int )quote_flag == 0U) {
#line 385
      if ((int )*(ptr + len) == 32) {
#line 388
        goto while_break;
      } else
#line 385
      if ((int )*(ptr + len) == 9) {
#line 388
        goto while_break;
      } else
#line 385
      if ((int )*(ptr + len) == 0) {
#line 388
        goto while_break;
      } else
#line 385
      if ((int )*(ptr + len) == 35) {
#line 388
        goto while_break;
      } else
#line 385
      if ((int )*(ptr + len) == 61) {
#line 385
        if ((unsigned int )word_type == 0U) {
#line 388
          goto while_break;
        } else {
#line 385
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 385
      if ((int )*(ptr + len) == 93) {
#line 385
        if ((unsigned int )word_type == 2U) {
#line 388
          goto while_break;
        }
      }
    } else
#line 390
    if ((unsigned int )quote_flag == 2U) {
#line 391
      if ((int )*(ptr + len) == 34) {
#line 392
        goto while_break;
      }
    } else
#line 394
    if ((unsigned int )quote_flag == 1U) {
#line 395
      if ((int )*(ptr + len) == 39) {
#line 396
        goto while_break;
      }
    }
#line 399
    if ((int )*(ptr + len) == 0) {
#line 400
      return ((char *)((void *)0));
    }
#line 402
    len ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 404
  tmp___0 = malloc((size_t )(len + 1));
#line 404
  tmp = (char *)tmp___0;
#line 404
  *word = tmp;
  }
#line 404
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {
#line 405
    cfgFatalFunc((cfgErrorCode )8, (char *)"unknown", 0, (char *)"");
    }
  }
  {
#line 407
  strncpy((char */* __restrict  */)*word, (char const   */* __restrict  */)ptr, (size_t )len);
#line 408
  *(*word + len) = (char )'\000';
  }
#line 410
  if ((unsigned int )quote_flag == 0U) {
#line 410
    tmp___1 = 0;
  } else {
#line 410
    tmp___1 = 1;
  }
  {
#line 410
  ptr += len + tmp___1;
#line 412
  ptr = rm_first_spaces(ptr);
  }
  {
#line 415
  if ((unsigned int )word_type == 0U) {
#line 415
    goto case_0;
  }
#line 422
  if ((unsigned int )word_type == 1U) {
#line 422
    goto case_1;
  }
#line 427
  if ((unsigned int )word_type == 2U) {
#line 427
    goto case_2;
  }
#line 432
  goto switch_default___0;
  case_0: /* CIL Label */ 
#line 416
  if ((int )*ptr != 61) {
#line 417
    return ((char *)((void *)0));
  }
  {
#line 419
  ptr ++;
#line 420
  ptr = rm_first_spaces(ptr);
  }
#line 421
  goto switch_break___0;
  case_1: /* CIL Label */ 
#line 423
  if ((int )*ptr != 0) {
#line 423
    if ((int )*ptr != 35) {
#line 424
      return ((char *)((void *)0));
    }
  }
#line 426
  goto switch_break___0;
  case_2: /* CIL Label */ 
#line 428
  if ((int )*ptr != 93) {
#line 429
    return ((char *)((void *)0));
  }
#line 431
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 433
  return ((char *)((void *)0));
  switch_break___0: /* CIL Label */ ;
  }
#line 435
  return (ptr);
}
}
#line 449 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/parsecfg.c"
int store_value(cfgStruct *cfg , char *parameter , char *value , cfgFileType type ,
                int section ) 
{ 
  int num ;
  long tmp ;
  unsigned long utmp ;
  char *endptr ;
  char *strptr ;
  cfgList *listptr ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  size_t tmp___11 ;
  void *tmp___12 ;
  int *tmp___13 ;
  int *tmp___14 ;
  int *tmp___15 ;
  int *tmp___16 ;
  cfgListPtr tmp___17 ;
  void *tmp___18 ;
  void *tmp___19 ;
  size_t tmp___20 ;
  void *tmp___21 ;
  int tmp___22 ;

  {
#line 459
  num = 0;
  {
#line 459
  while (1) {
    while_continue: /* CIL Label */ ;
#line 459
    if (! ((unsigned int )(cfg + num)->type != 0U)) {
#line 459
      goto while_break;
    }
    {
#line 460
    tmp___22 = strcasecmp((char const   *)parameter, (char const   *)(cfg + num)->parameterName);
    }
#line 460
    if (tmp___22 == 0) {
      {
#line 461
      tmp___0 = __errno_location();
#line 461
      *tmp___0 = 0;
      }
      {
#line 463
      if ((unsigned int )(cfg + num)->type == 1U) {
#line 463
        goto case_1;
      }
#line 489
      if ((unsigned int )(cfg + num)->type == 2U) {
#line 489
        goto case_2;
      }
#line 501
      if ((unsigned int )(cfg + num)->type == 3U) {
#line 501
        goto case_3;
      }
#line 516
      if ((unsigned int )(cfg + num)->type == 4U) {
#line 516
        goto case_4;
      }
#line 531
      if ((unsigned int )(cfg + num)->type == 5U) {
#line 531
        goto case_5;
      }
#line 546
      if ((unsigned int )(cfg + num)->type == 6U) {
#line 546
        goto case_6;
      }
#line 561
      if ((unsigned int )(cfg + num)->type == 7U) {
#line 561
        goto case_7;
      }
#line 592
      goto switch_default;
      case_1: /* CIL Label */ 
      {
#line 464
      tmp___6 = strcasecmp((char const   *)value, "TRUE");
      }
#line 464
      if (tmp___6 == 0) {
#line 464
        goto _L___0;
      } else {
        {
#line 464
        tmp___7 = strcasecmp((char const   *)value, "YES");
        }
#line 464
        if (tmp___7 == 0) {
#line 464
          goto _L___0;
        } else {
          {
#line 464
          tmp___8 = strcasecmp((char const   *)value, "T");
          }
#line 464
          if (tmp___8 == 0) {
#line 464
            goto _L___0;
          } else {
            {
#line 464
            tmp___9 = strcasecmp((char const   *)value, "Y");
            }
#line 464
            if (tmp___9 == 0) {
#line 464
              goto _L___0;
            } else {
              {
#line 464
              tmp___10 = strcasecmp((char const   *)value, "1");
              }
#line 464
              if (tmp___10 == 0) {
                _L___0: /* CIL Label */ 
#line 469
                if ((unsigned int )type == 1U) {
#line 470
                  *(*((int **)(cfg + num)->value) + section) = 1;
                } else {
#line 472
                  *((int *)(cfg + num)->value) = 1;
                }
#line 474
                return (0);
              } else {
                {
#line 475
                tmp___1 = strcasecmp((char const   *)value, "FALSE");
                }
#line 475
                if (tmp___1 == 0) {
#line 475
                  goto _L;
                } else {
                  {
#line 475
                  tmp___2 = strcasecmp((char const   *)value, "NO");
                  }
#line 475
                  if (tmp___2 == 0) {
#line 475
                    goto _L;
                  } else {
                    {
#line 475
                    tmp___3 = strcasecmp((char const   *)value, "F");
                    }
#line 475
                    if (tmp___3 == 0) {
#line 475
                      goto _L;
                    } else {
                      {
#line 475
                      tmp___4 = strcasecmp((char const   *)value, "N");
                      }
#line 475
                      if (tmp___4 == 0) {
#line 475
                        goto _L;
                      } else {
                        {
#line 475
                        tmp___5 = strcasecmp((char const   *)value, "0");
                        }
#line 475
                        if (tmp___5 == 0) {
                          _L: /* CIL Label */ 
#line 480
                          if ((unsigned int )type == 1U) {
#line 481
                            *(*((int **)(cfg + num)->value) + section) = 0;
                          } else {
#line 483
                            *((int *)(cfg + num)->value) = 0;
                          }
#line 485
                          return (0);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
#line 487
      return (9);
      case_2: /* CIL Label */ 
      {
#line 490
      tmp___11 = strlen((char const   *)value);
#line 490
      tmp___12 = malloc(tmp___11 + 1UL);
#line 490
      strptr = (char *)tmp___12;
      }
#line 490
      if ((unsigned long )strptr == (unsigned long )((void *)0)) {
#line 491
        return (8);
      }
      {
#line 493
      strcpy((char */* __restrict  */)strptr, (char const   */* __restrict  */)value);
      }
#line 494
      if ((unsigned int )type == 1U) {
#line 495
        *(*((char ***)(cfg + num)->value) + section) = strptr;
      } else {
#line 497
        *((char **)(cfg + num)->value) = strptr;
      }
#line 499
      return (0);
      case_3: /* CIL Label */ 
      {
#line 502
      tmp = strtol((char const   */* __restrict  */)value, (char **/* __restrict  */)(& endptr),
                   10);
      }
#line 503
      if (*endptr) {
#line 504
        return (6);
      }
      {
#line 506
      tmp___13 = __errno_location();
      }
#line 506
      if (*tmp___13 == 34) {
#line 507
        return (7);
      } else
#line 506
      if (tmp > 2147483647L) {
#line 507
        return (7);
      } else
#line 506
      if (tmp < (-0x7FFFFFFF-1)) {
#line 507
        return (7);
      }
#line 509
      if ((unsigned int )type == 1U) {
#line 510
        *(*((int **)(cfg + num)->value) + section) = (int )tmp;
      } else {
#line 512
        *((int *)(cfg + num)->value) = (int )tmp;
      }
#line 514
      return (0);
      case_4: /* CIL Label */ 
      {
#line 517
      utmp = strtoul((char const   */* __restrict  */)value, (char **/* __restrict  */)(& endptr),
                     10);
      }
#line 518
      if (*endptr) {
#line 519
        return (6);
      }
      {
#line 521
      tmp___14 = __errno_location();
      }
#line 521
      if (*tmp___14 == 34) {
#line 522
        return (7);
      } else
#line 521
      if (tmp > 4294967295L) {
#line 522
        return (7);
      }
#line 524
      if ((unsigned int )type == 1U) {
#line 525
        *(*((unsigned int **)(cfg + num)->value) + section) = (unsigned int )utmp;
      } else {
#line 527
        *((unsigned int *)(cfg + num)->value) = (unsigned int )utmp;
      }
#line 529
      return (0);
      case_5: /* CIL Label */ 
      {
#line 532
      tmp = strtol((char const   */* __restrict  */)value, (char **/* __restrict  */)(& endptr),
                   10);
      }
#line 533
      if (*endptr) {
#line 534
        return (6);
      }
      {
#line 536
      tmp___15 = __errno_location();
      }
#line 536
      if (*tmp___15 == 34) {
#line 537
        return (7);
      }
#line 539
      if ((unsigned int )type == 1U) {
#line 540
        *(*((long **)(cfg + num)->value) + section) = tmp;
      } else {
#line 542
        *((long *)(cfg + num)->value) = tmp;
      }
#line 544
      return (0);
      case_6: /* CIL Label */ 
      {
#line 547
      utmp = strtoul((char const   */* __restrict  */)value, (char **/* __restrict  */)(& endptr),
                     10);
      }
#line 548
      if (*endptr) {
#line 549
        return (6);
      }
      {
#line 551
      tmp___16 = __errno_location();
      }
#line 551
      if (*tmp___16 == 34) {
#line 552
        return (7);
      }
#line 554
      if ((unsigned int )type == 1U) {
#line 555
        *(*((unsigned long **)(cfg + num)->value) + section) = utmp;
      } else {
#line 557
        *((unsigned long *)(cfg + num)->value) = utmp;
      }
#line 559
      return (0);
      case_7: /* CIL Label */ 
#line 562
      if ((unsigned int )type == 1U) {
#line 563
        listptr = *(*((cfgList ***)(cfg + num)->value) + section);
      } else {
#line 565
        listptr = *((cfgList **)(cfg + num)->value);
      }
#line 567
      if ((unsigned long )listptr != (unsigned long )((void *)0)) {
        {
#line 568
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 568
          if (! ((unsigned long )listptr->next != (unsigned long )((void *)0))) {
#line 568
            goto while_break___0;
          }
#line 569
          listptr = listptr->next;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 571
        tmp___18 = malloc(sizeof(cfgList ));
#line 571
        tmp___17 = (cfgListPtr )tmp___18;
#line 571
        listptr->next = tmp___17;
#line 571
        listptr = tmp___17;
        }
#line 571
        if ((unsigned long )listptr == (unsigned long )((void *)0)) {
#line 572
          return (8);
        }
      } else {
        {
#line 575
        tmp___19 = malloc(sizeof(cfgList ));
#line 575
        listptr = (cfgList *)tmp___19;
        }
#line 575
        if ((unsigned long )listptr == (unsigned long )((void *)0)) {
#line 576
          return (8);
        }
#line 578
        if ((unsigned int )type == 1U) {
#line 579
          *(*((cfgList ***)(cfg + num)->value) + section) = listptr;
        } else {
#line 581
          *((cfgList **)(cfg + num)->value) = listptr;
        }
      }
      {
#line 584
      tmp___20 = strlen((char const   *)value);
#line 584
      tmp___21 = malloc(tmp___20 + 1UL);
#line 584
      strptr = (char *)tmp___21;
      }
#line 584
      if ((unsigned long )strptr == (unsigned long )((void *)0)) {
#line 585
        return (8);
      }
      {
#line 587
      strcpy((char */* __restrict  */)strptr, (char const   */* __restrict  */)value);
#line 588
      listptr->str = strptr;
#line 589
      listptr->next = (cfgListPtr )((void *)0);
      }
#line 590
      return (0);
      switch_default: /* CIL Label */ 
#line 593
      return (5);
      switch_break: /* CIL Label */ ;
      }
    }
#line 459
    num ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 597
  return (4);
}
}
#line 615 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/parsecfg.c"
void parse_values_between_braces(char *file , FILE *fp , char *parameter , cfgStruct *cfg ,
                                 int *line , cfgFileType type , int section , char *parameter_buf ,
                                 int parameter_line ) 
{ 
  char *line_buf ;
  char *value ;
  char *ptr ;
  int error_code ;
  char *tmp ;

  {
  {
#line 622
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 622
    ptr = get_single_line_without_first_spaces(fp, & line_buf, line);
    }
#line 622
    if (! ((unsigned long )ptr != (unsigned long )((void *)0))) {
#line 622
      goto while_break;
    }
#line 623
    if ((int )*ptr == 125) {
      {
#line 624
      ptr = rm_first_spaces(ptr + 1);
      }
#line 625
      if ((int )*ptr != 0) {
#line 625
        if ((int )*ptr != 35) {
          {
#line 626
          fclose(fp);
#line 627
          (*cfgFatal)((cfgErrorCode )3, file, *line, line_buf);
          }
        }
      }
      {
#line 629
      free((void *)line_buf);
      }
#line 630
      return;
    }
    {
#line 632
    tmp = parse_word(ptr, & value, (cfgKeywordValue )1);
    }
#line 632
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
      {
#line 633
      fclose(fp);
#line 634
      (*cfgFatal)((cfgErrorCode )3, file, *line, line_buf);
      }
    }
    {
#line 636
    error_code = store_value(cfg, parameter, value, type, section);
    }
#line 636
    if (error_code != 0) {
      {
#line 637
      fclose(fp);
      }
#line 638
      if (error_code == 4) {
        {
#line 639
        (*cfgFatal)((cfgErrorCode )error_code, file, parameter_line, parameter_buf);
        }
      }
      {
#line 641
      (*cfgFatal)((cfgErrorCode )error_code, file, *line, line_buf);
      }
    }
    {
#line 643
    free((void *)line_buf);
#line 644
    free((void *)value);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 646
  fclose(fp);
#line 647
  (*cfgFatal)((cfgErrorCode )11, file, *line, (char *)((void *)0));
  }
#line 648
  return;
}
}
#line 662 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/parsecfg.c"
int parse_ini(char *file , FILE *fp , char *ptr , cfgStruct *cfg , int *line , int *section ) 
{ 
  char *parameter ;
  char *parameter_buf ;
  int parameter_line ;
  char *value ;
  int error_code ;
  int i ;
  void *tmp ;
  int tmp___0 ;

  {
#line 671
  if ((int )*ptr == 91) {
    {
#line 672
    error_code = alloc_for_new_section(cfg, section);
    }
#line 672
    if (error_code != 0) {
#line 673
      return (error_code);
    }
    {
#line 675
    ptr = rm_first_spaces(ptr + 1);
#line 677
    tmp = realloc((void *)parsecfg_section_name, sizeof(char *) * (unsigned long )(*section + 1));
#line 677
    parsecfg_section_name = (char **)tmp;
#line 679
    ptr = parse_word(ptr, parsecfg_section_name + *section, (cfgKeywordValue )2);
    }
#line 679
    if ((unsigned long )ptr == (unsigned long )((void *)0)) {
#line 680
      return (3);
    }
#line 682
    i = 0;
    {
#line 682
    while (1) {
      while_continue: /* CIL Label */ ;
#line 682
      if (! (i < *section)) {
#line 682
        goto while_break;
      }
      {
#line 683
      tmp___0 = strcasecmp((char const   *)*(parsecfg_section_name + *section), (char const   *)*(parsecfg_section_name + i));
      }
#line 683
      if (tmp___0 == 0) {
#line 684
        return (10);
      }
#line 682
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 687
    ptr = rm_first_spaces(ptr + 1);
    }
#line 688
    if ((int )*ptr != 0) {
#line 688
      if ((int )*ptr != 35) {
#line 689
        return (3);
      }
    }
#line 691
    return (0);
  } else
#line 692
  if (*section == -1) {
#line 693
    return (3);
  }
  {
#line 696
  parameter_buf = ptr;
#line 697
  parameter_line = *line;
#line 699
  ptr = parse_word(ptr, & parameter, (cfgKeywordValue )0);
  }
#line 699
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
#line 700
    return (3);
  }
#line 702
  if ((int )*ptr == 123) {
    {
#line 703
    ptr = rm_first_spaces(ptr + 1);
    }
#line 704
    if ((int )*ptr != 0) {
#line 704
      if ((int )*ptr != 35) {
#line 705
        return (3);
      }
    }
    {
#line 707
    parse_values_between_braces(file, fp, parameter, cfg, line, (cfgFileType )1, *section,
                                parameter_buf, parameter_line);
    }
  } else {
    {
#line 709
    ptr = parse_word(ptr, & value, (cfgKeywordValue )1);
    }
#line 709
    if ((unsigned long )ptr == (unsigned long )((void *)0)) {
#line 710
      return (3);
    }
    {
#line 712
    error_code = store_value(cfg, parameter, value, (cfgFileType )1, *section);
    }
#line 712
    if (error_code != 0) {
#line 713
      return (error_code);
    }
    {
#line 715
    free((void *)parameter);
#line 716
    free((void *)value);
    }
  }
#line 718
  return (0);
}
}
#line 729 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/parsecfg.c"
int alloc_for_new_section(cfgStruct *cfg , int *section ) 
{ 
  int num ;
  void *ptr ;

  {
#line 734
  (*section) ++;
#line 735
  num = 0;
  {
#line 735
  while (1) {
    while_continue: /* CIL Label */ ;
#line 735
    if (! ((unsigned int )(cfg + num)->type != 0U)) {
#line 735
      goto while_break;
    }
    {
#line 739
    if ((unsigned int )(cfg + num)->type == 4U) {
#line 739
      goto case_4;
    }
#line 739
    if ((unsigned int )(cfg + num)->type == 3U) {
#line 739
      goto case_4;
    }
#line 739
    if ((unsigned int )(cfg + num)->type == 1U) {
#line 739
      goto case_4;
    }
#line 755
    if ((unsigned int )(cfg + num)->type == 6U) {
#line 755
      goto case_6;
    }
#line 755
    if ((unsigned int )(cfg + num)->type == 5U) {
#line 755
      goto case_6;
    }
#line 766
    if ((unsigned int )(cfg + num)->type == 2U) {
#line 766
      goto case_2;
    }
#line 777
    if ((unsigned int )(cfg + num)->type == 7U) {
#line 777
      goto case_7;
    }
#line 788
    goto switch_default;
    case_4: /* CIL Label */ 
    case_3: /* CIL Label */ 
    case_1: /* CIL Label */ 
#line 740
    if (*section == 0) {
#line 741
      *((int **)(cfg + num)->value) = (int *)((void *)0);
    }
    {
#line 743
    ptr = realloc((void *)*((int **)(cfg + num)->value), sizeof(int ) * (unsigned long )(*section + 1));
    }
#line 743
    if ((unsigned long )ptr == (unsigned long )((void *)0)) {
#line 744
      return (8);
    }
#line 746
    *((int **)(cfg + num)->value) = (int *)ptr;
#line 747
    if ((unsigned int )(cfg + num)->type == 1U) {
#line 748
      *(*((int **)(cfg + num)->value) + *section) = -1;
    } else {
#line 750
      *(*((int **)(cfg + num)->value) + *section) = 0;
    }
#line 752
    goto switch_break;
    case_6: /* CIL Label */ 
    case_5: /* CIL Label */ 
#line 756
    if (*section == 0) {
#line 757
      *((long **)(cfg + num)->value) = (long *)((void *)0);
    }
    {
#line 759
    ptr = realloc((void *)*((long **)(cfg + num)->value), sizeof(long ) * (unsigned long )(*section + 1));
    }
#line 759
    if ((unsigned long )ptr == (unsigned long )((void *)0)) {
#line 760
      return (8);
    }
#line 762
    *((long **)(cfg + num)->value) = (long *)ptr;
#line 763
    *(*((long **)(cfg + num)->value) + *section) = 0L;
#line 764
    goto switch_break;
    case_2: /* CIL Label */ 
#line 767
    if (*section == 0) {
#line 768
      *((char ***)(cfg + num)->value) = (char **)((void *)0);
    }
    {
#line 770
    ptr = realloc((void *)*((char ***)(cfg + num)->value), sizeof(char *) * (unsigned long )(*section + 1));
    }
#line 770
    if ((unsigned long )ptr == (unsigned long )((void *)0)) {
#line 771
      return (8);
    }
#line 773
    *((char ***)(cfg + num)->value) = (char **)ptr;
#line 774
    *(*((char ***)(cfg + num)->value) + *section) = (char *)((void *)0);
#line 775
    goto switch_break;
    case_7: /* CIL Label */ 
#line 778
    if (*section == 0) {
#line 779
      *((cfgList ***)(cfg + num)->value) = (cfgList **)((void *)0);
    }
    {
#line 781
    ptr = realloc((void *)*((cfgList ***)(cfg + num)->value), sizeof(cfgList *) * (unsigned long )(*section + 1));
    }
#line 781
    if ((unsigned long )ptr == (unsigned long )((void *)0)) {
#line 782
      return (8);
    }
#line 784
    *((cfgList ***)(cfg + num)->value) = (cfgList **)ptr;
#line 785
    *(*((cfgList ***)(cfg + num)->value) + *section) = (cfgList *)((void *)0);
#line 786
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 789
    return (5);
    switch_break: /* CIL Label */ ;
    }
#line 735
    num ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 792
  return (0);
}
}
#line 802 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/parsecfg.c"
char *rm_first_spaces(char *ptr ) 
{ 


  {
  {
#line 804
  while (1) {
    while_continue: /* CIL Label */ ;
#line 804
    if (! ((int )*ptr == 32)) {
#line 804
      if (! ((int )*ptr == 9)) {
#line 804
        goto while_break;
      }
    }
#line 805
    ptr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 807
  return (ptr);
}
}
#line 820 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/parsecfg.c"
char *get_single_line_without_first_spaces(FILE *fp , char **gotstr , int *line ) 
{ 
  char *ptr ;
  char *tmp ;

  {
  {
#line 824
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 825
    tmp = dynamic_fgets(fp);
#line 825
    *gotstr = tmp;
    }
#line 825
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 826
      return ((char *)((void *)0));
    }
    {
#line 828
    (*line) ++;
#line 829
    ptr = rm_first_spaces(*gotstr);
    }
#line 830
    if ((int )*ptr != 35) {
#line 830
      if ((int )*ptr != 0) {
#line 831
        return (ptr);
      }
    }
    {
#line 833
    free((void *)*gotstr);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 844 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/parsecfg.c"
char *dynamic_fgets(FILE *fp ) 
{ 
  char *ptr ;
  char temp[128] ;
  int i ;
  void *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 850
  tmp = malloc((size_t )1);
#line 850
  ptr = (char *)tmp;
  }
#line 851
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
    {
#line 852
    fclose(fp);
#line 853
    cfgFatalFunc((cfgErrorCode )8, (char *)"unknown", 0, (char *)"");
    }
  }
#line 855
  *ptr = (char )'\000';
#line 856
  i = 0;
  {
#line 856
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 857
    tmp___0 = fgets((char */* __restrict  */)(temp), 128, (FILE */* __restrict  */)fp);
    }
#line 857
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
      {
#line 858
      free((void *)ptr);
      }
#line 859
      return ((char *)((void *)0));
    }
    {
#line 861
    tmp___1 = realloc((void *)ptr, (size_t )(127 * (i + 1) + 1));
#line 861
    ptr = (char *)tmp___1;
    }
#line 862
    if ((unsigned long )ptr == (unsigned long )((void *)0)) {
      {
#line 863
      fclose(fp);
#line 864
      cfgFatalFunc((cfgErrorCode )8, (char *)"unknown", 0, (char *)"");
      }
    }
    {
#line 866
    strcat((char */* __restrict  */)ptr, (char const   */* __restrict  */)(temp));
#line 867
    tmp___3 = strchr((char const   *)(temp), '\n');
    }
#line 867
    if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
      {
#line 868
      tmp___2 = strchr((char const   *)ptr, '\n');
#line 868
      *tmp___2 = (char )'\000';
      }
#line 869
      return (ptr);
    }
    {
#line 871
    tmp___4 = feof(fp);
    }
#line 871
    if (tmp___4 != 0) {
#line 872
      return (ptr);
    }
#line 856
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 878 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/parsecfg.c"
void dump_simple(FILE *fp , cfgStruct *cfg , cfgFileType type ) 
{ 
  int i ;
  char c[2] ;
  cfgList *l ;
  char const   *tmp ;

  {
#line 884
  i = 0;
  {
#line 884
  while (1) {
    while_continue: /* CIL Label */ ;
#line 884
    if (! ((unsigned int )(cfg + i)->type != 0U)) {
#line 884
      goto while_break;
    }
    {
#line 886
    if ((unsigned int )(cfg + i)->type == 1U) {
#line 886
      goto case_1;
    }
#line 889
    if ((unsigned int )(cfg + i)->type == 3U) {
#line 889
      goto case_3;
    }
#line 892
    if ((unsigned int )(cfg + i)->type == 4U) {
#line 892
      goto case_4;
    }
#line 895
    if ((unsigned int )(cfg + i)->type == 5U) {
#line 895
      goto case_5;
    }
#line 898
    if ((unsigned int )(cfg + i)->type == 6U) {
#line 898
      goto case_6;
    }
#line 901
    if ((unsigned int )(cfg + i)->type == 2U) {
#line 901
      goto case_2;
    }
#line 905
    if ((unsigned int )(cfg + i)->type == 7U) {
#line 905
      goto case_7;
    }
#line 912
    goto switch_default;
    case_1: /* CIL Label */ 
#line 887
    if (*((int *)(cfg + i)->value)) {
#line 887
      tmp = "True";
    } else {
#line 887
      tmp = "False";
    }
    {
#line 887
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s\t= %s\n",
            (cfg + i)->parameterName, tmp);
    }
#line 888
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 890
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s\t= %d\n",
            (cfg + i)->parameterName, *((int *)(cfg + i)->value));
    }
#line 891
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 893
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s\t= %u\n",
            (cfg + i)->parameterName, *((unsigned int *)(cfg + i)->value));
    }
#line 894
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 896
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s\t= %ld\n",
            (cfg + i)->parameterName, *((long *)(cfg + i)->value));
    }
#line 897
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 899
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s\t= %lu\n",
            (cfg + i)->parameterName, *((unsigned long *)(cfg + i)->value));
    }
#line 900
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 902
    single_or_double_quote(*((char **)(cfg + i)->value), c);
#line 903
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s\t= %s%s%s\n",
            (cfg + i)->parameterName, c, *((char **)(cfg + i)->value), c);
    }
#line 904
    goto switch_break;
    case_7: /* CIL Label */ 
#line 906
    l = *((cfgList **)(cfg + i)->value);
    {
#line 906
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 906
      if (! ((unsigned long )l != (unsigned long )((void *)0))) {
#line 906
        goto while_break___0;
      }
      {
#line 907
      single_or_double_quote(l->str, c);
#line 908
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s\t= %s%s%s\n",
              (cfg + i)->parameterName, c, l->str, c);
#line 906
      l = l->next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 910
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 913
    fclose(fp);
#line 914
    (*cfgFatal)((cfgErrorCode )5, (char *)"?", 0, (char *)((void *)0));
    }
    switch_break: /* CIL Label */ ;
    }
#line 884
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 917
  return;
}
}
#line 920 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/parsecfg.c"
void dump_ini(FILE *fp , cfgStruct *cfg , cfgFileType type , int max ) 
{ 
  int i ;
  int j ;
  char c[2] ;
  cfgList *l ;
  char *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 926
  j = 0;
  {
#line 926
  while (1) {
    while_continue: /* CIL Label */ ;
#line 926
    if (! (j < max)) {
#line 926
      goto while_break;
    }
    {
#line 927
    tmp = cfgSectionNumberToName(j);
#line 927
    single_or_double_quote(tmp, c);
#line 928
    tmp___0 = cfgSectionNumberToName(j);
#line 928
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"[%s%s%s]\n",
            c, tmp___0, c);
#line 930
    i = 0;
    }
    {
#line 930
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 930
      if (! ((unsigned int )(cfg + i)->type != 0U)) {
#line 930
        goto while_break___0;
      }
      {
#line 932
      if ((unsigned int )(cfg + i)->type == 1U) {
#line 932
        goto case_1;
      }
#line 935
      if ((unsigned int )(cfg + i)->type == 3U) {
#line 935
        goto case_3;
      }
#line 938
      if ((unsigned int )(cfg + i)->type == 4U) {
#line 938
        goto case_4;
      }
#line 941
      if ((unsigned int )(cfg + i)->type == 5U) {
#line 941
        goto case_5;
      }
#line 944
      if ((unsigned int )(cfg + i)->type == 6U) {
#line 944
        goto case_6;
      }
#line 947
      if ((unsigned int )(cfg + i)->type == 2U) {
#line 947
        goto case_2;
      }
#line 951
      if ((unsigned int )(cfg + i)->type == 7U) {
#line 951
        goto case_7;
      }
#line 958
      goto switch_default;
      case_1: /* CIL Label */ 
#line 933
      if (*(*((int **)(cfg + i)->value) + j)) {
#line 933
        tmp___1 = "True";
      } else {
#line 933
        tmp___1 = "False";
      }
      {
#line 933
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s\t= %s\n",
              (cfg + i)->parameterName, tmp___1);
      }
#line 934
      goto switch_break;
      case_3: /* CIL Label */ 
      {
#line 936
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s\t= %d\n",
              (cfg + i)->parameterName, *(*((int **)(cfg + i)->value) + j));
      }
#line 937
      goto switch_break;
      case_4: /* CIL Label */ 
      {
#line 939
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s\t= %u\n",
              (cfg + i)->parameterName, *(*((unsigned int **)(cfg + i)->value) + j));
      }
#line 940
      goto switch_break;
      case_5: /* CIL Label */ 
      {
#line 942
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s\t= %ld\n",
              (cfg + i)->parameterName, *(*((long **)(cfg + i)->value) + j));
      }
#line 943
      goto switch_break;
      case_6: /* CIL Label */ 
      {
#line 945
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s\t= %lu\n",
              (cfg + i)->parameterName, *(*((unsigned long **)(cfg + i)->value) + j));
      }
#line 946
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 948
      single_or_double_quote(*(*((char ***)(cfg + i)->value) + j), c);
#line 949
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s\t= %s%s%s\n",
              (cfg + i)->parameterName, c, *(*((char ***)(cfg + i)->value) + j), c);
      }
#line 950
      goto switch_break;
      case_7: /* CIL Label */ 
#line 952
      l = *(*((cfgList ***)(cfg + i)->value) + j);
      {
#line 952
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 952
        if (! ((unsigned long )l != (unsigned long )((void *)0))) {
#line 952
          goto while_break___1;
        }
        {
#line 953
        single_or_double_quote(l->str, c);
#line 954
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s\t= %s%s%s\n",
                (cfg + i)->parameterName, c, l->str, c);
#line 952
        l = l->next;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 956
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 959
      fclose(fp);
#line 960
      (*cfgFatal)((cfgErrorCode )5, (char *)"?", 0, (char *)((void *)0));
      }
      switch_break: /* CIL Label */ ;
      }
#line 930
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 963
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\n");
#line 926
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 965
  return;
}
}
#line 968 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/parsecfg.c"
void single_or_double_quote(char *str , char *ret___0 ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 970
  *(ret___0 + 1) = (char )'\000';
#line 972
  tmp___3 = strchr((char const   *)str, '\"');
  }
#line 972
  if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
#line 973
    *(ret___0 + 0) = (char )'\'';
  } else {
    {
#line 974
    tmp = strchr((char const   *)str, '\'');
    }
#line 974
    if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 976
      *(ret___0 + 0) = (char )'\"';
    } else {
      {
#line 974
      tmp___0 = strchr((char const   *)str, '#');
      }
#line 974
      if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 976
        *(ret___0 + 0) = (char )'\"';
      } else {
        {
#line 974
        tmp___1 = strchr((char const   *)str, '\t');
        }
#line 974
        if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
#line 976
          *(ret___0 + 0) = (char )'\"';
        } else {
          {
#line 974
          tmp___2 = strchr((char const   *)str, ' ');
          }
#line 974
          if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
#line 976
            *(ret___0 + 0) = (char )'\"';
          } else {
#line 978
            *(ret___0 + 0) = (char )'\000';
          }
        }
      }
    }
  }
#line 980
  return;
}
}
#line 983 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/parsecfg.c"
int fetch_simple(char *file , FILE *fp , char *parameter_name , void *result_value ,
                 cfgValueType value_type ) 
{ 
  int store_flag ;
  int error_code ;
  int line ;
  char *line_buf ;
  char *ptr ;
  char *read_parameter ;
  char *read_value ;
  cfgStruct fetch_cfg[2] ;
  int tmp ;

  {
#line 985
  store_flag = -1;
#line 992
  fetch_cfg[0].parameterName = parameter_name;
#line 992
  fetch_cfg[0].type = value_type;
#line 992
  fetch_cfg[0].value = result_value;
#line 992
  fetch_cfg[1].parameterName = (char *)((void *)0);
#line 992
  fetch_cfg[1].type = (cfgValueType )0;
#line 992
  fetch_cfg[1].value = (void *)0;
  {
#line 997
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 997
    ptr = get_single_line_without_first_spaces(fp, & line_buf, & line);
    }
#line 997
    if (! ((unsigned long )ptr != (unsigned long )((void *)0))) {
#line 997
      goto while_break;
    }
    {
#line 998
    ptr = parse_word(ptr, & read_parameter, (cfgKeywordValue )0);
    }
#line 998
    if ((unsigned long )ptr == (unsigned long )((void *)0)) {
      {
#line 999
      fclose(fp);
#line 1000
      (*cfgFatal)((cfgErrorCode )3, file, line, line_buf);
      }
    }
    {
#line 1002
    tmp = strcasecmp((char const   *)read_parameter, (char const   *)parameter_name);
    }
#line 1002
    if (tmp == 0) {
#line 1003
      if ((int )*ptr == 123) {
        {
#line 1004
        ptr = rm_first_spaces(ptr + 1);
        }
#line 1005
        if ((int )*ptr != 0) {
#line 1005
          if ((int )*ptr != 35) {
            {
#line 1006
            fclose(fp);
#line 1007
            (*cfgFatal)((cfgErrorCode )3, file, line, line_buf);
            }
          }
        }
        {
#line 1009
        parse_values_between_braces(file, fp, parameter_name, fetch_cfg, & line, (cfgFileType )0,
                                    0, line_buf, line);
        }
      } else {
        {
#line 1011
        ptr = parse_word(ptr, & read_value, (cfgKeywordValue )1);
        }
#line 1011
        if ((unsigned long )ptr == (unsigned long )((void *)0)) {
          {
#line 1012
          fclose(fp);
#line 1013
          (*cfgFatal)((cfgErrorCode )3, file, line, line_buf);
          }
        }
        {
#line 1015
        error_code = store_value(fetch_cfg, parameter_name, read_value, (cfgFileType )0,
                                 0);
        }
#line 1015
        if (error_code != 0) {
          {
#line 1016
          fclose(fp);
#line 1017
          (*cfgFatal)((cfgErrorCode )error_code, file, line, line_buf);
          }
        }
        {
#line 1019
        free((void *)read_value);
        }
      }
#line 1021
      store_flag = 0;
    } else
#line 1023
    if ((int )*ptr == 123) {
      {
#line 1024
      ptr = rm_first_spaces(ptr + 1);
      }
#line 1025
      if ((int )*ptr != 0) {
#line 1025
        if ((int )*ptr != 35) {
          {
#line 1026
          fclose(fp);
#line 1027
          (*cfgFatal)((cfgErrorCode )3, file, line, line_buf);
          }
        }
      }
      {
#line 1029
      free((void *)line_buf);
      }
      {
#line 1030
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 1030
        ptr = get_single_line_without_first_spaces(fp, & line_buf, & line);
        }
#line 1030
        if (! ((unsigned long )ptr != (unsigned long )((void *)0))) {
#line 1030
          goto while_break___0;
        }
#line 1031
        if ((int )*ptr == 125) {
          {
#line 1032
          ptr = rm_first_spaces(ptr + 1);
          }
#line 1033
          if ((int )*ptr != 0) {
#line 1033
            if ((int )*ptr != 35) {
              {
#line 1034
              fclose(fp);
#line 1035
              (*cfgFatal)((cfgErrorCode )3, file, line, line_buf);
              }
            }
          }
#line 1037
          goto while_break___0;
        }
        {
#line 1039
        free((void *)line_buf);
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 1043
    free((void *)read_parameter);
#line 1044
    free((void *)line_buf);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1046
  return (store_flag);
}
}
#line 1050 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/parsecfg.c"
int fetch_ini(char *file , FILE *fp , char *parameter_name , void *result_value ,
              cfgValueType value_type , int section_num , char *section_name ) 
{ 
  int store_flag ;
  int section_flag ;
  int error_code ;
  int line ;
  char *line_buf ;
  char *ptr ;
  char *read_parameter ;
  char *read_value ;
  char *read_section_name ;
  int current_section_number ;
  cfgStruct fetch_cfg[2] ;
  int tmp ;
  int tmp___0 ;

  {
#line 1052
  store_flag = -1;
#line 1053
  section_flag = -1;
#line 1061
  current_section_number = 0;
#line 1063
  fetch_cfg[0].parameterName = parameter_name;
#line 1063
  fetch_cfg[0].type = value_type;
#line 1063
  fetch_cfg[0].value = result_value;
#line 1063
  fetch_cfg[1].parameterName = (char *)((void *)0);
#line 1063
  fetch_cfg[1].type = (cfgValueType )0;
#line 1063
  fetch_cfg[1].value = (void *)0;
  {
#line 1068
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1068
    ptr = get_single_line_without_first_spaces(fp, & line_buf, & line);
    }
#line 1068
    if (! ((unsigned long )ptr != (unsigned long )((void *)0))) {
#line 1068
      goto while_break;
    }
#line 1069
    if ((int )*ptr == 91) {
#line 1070
      if (section_flag == 0) {
#line 1071
        return (store_flag);
      }
      {
#line 1073
      ptr = rm_first_spaces(ptr + 1);
#line 1074
      ptr = parse_word(ptr, & read_section_name, (cfgKeywordValue )2);
      }
#line 1074
      if ((unsigned long )ptr == (unsigned long )((void *)0)) {
#line 1075
        return (3);
      }
      {
#line 1077
      ptr = rm_first_spaces(ptr + 1);
      }
#line 1078
      if ((int )*ptr != 0) {
#line 1078
        if ((int )*ptr != 35) {
#line 1079
          return (3);
        }
      }
#line 1081
      current_section_number ++;
#line 1082
      if (section_num > 0) {
#line 1082
        if (current_section_number == section_num) {
#line 1083
          section_flag = 0;
#line 1084
          goto while_continue;
        } else {
#line 1082
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 1082
      if (section_num <= 0) {
        {
#line 1082
        tmp = strcasecmp((char const   *)read_section_name, (char const   *)section_name);
        }
#line 1082
        if (tmp == 0) {
#line 1083
          section_flag = 0;
#line 1084
          goto while_continue;
        }
      }
    }
#line 1087
    if (section_flag == -1) {
#line 1088
      goto while_continue;
    }
    {
#line 1091
    ptr = parse_word(ptr, & read_parameter, (cfgKeywordValue )0);
    }
#line 1091
    if ((unsigned long )ptr == (unsigned long )((void *)0)) {
      {
#line 1092
      fclose(fp);
#line 1093
      (*cfgFatal)((cfgErrorCode )3, file, line, line_buf);
      }
    }
    {
#line 1095
    tmp___0 = strcasecmp((char const   *)read_parameter, (char const   *)parameter_name);
    }
#line 1095
    if (tmp___0 == 0) {
#line 1096
      if ((int )*ptr == 123) {
        {
#line 1097
        ptr = rm_first_spaces(ptr + 1);
        }
#line 1098
        if ((int )*ptr != 0) {
#line 1098
          if ((int )*ptr != 35) {
            {
#line 1099
            fclose(fp);
#line 1100
            (*cfgFatal)((cfgErrorCode )3, file, line, line_buf);
            }
          }
        }
        {
#line 1102
        parse_values_between_braces(file, fp, parameter_name, fetch_cfg, & line, (cfgFileType )0,
                                    0, line_buf, line);
        }
      } else {
        {
#line 1104
        ptr = parse_word(ptr, & read_value, (cfgKeywordValue )1);
        }
#line 1104
        if ((unsigned long )ptr == (unsigned long )((void *)0)) {
          {
#line 1105
          fclose(fp);
#line 1106
          (*cfgFatal)((cfgErrorCode )3, file, line, line_buf);
          }
        }
        {
#line 1108
        error_code = store_value(fetch_cfg, parameter_name, read_value, (cfgFileType )0,
                                 0);
        }
#line 1108
        if (error_code != 0) {
          {
#line 1109
          fclose(fp);
#line 1110
          (*cfgFatal)((cfgErrorCode )error_code, file, line, line_buf);
          }
        }
        {
#line 1112
        free((void *)read_value);
        }
      }
#line 1114
      store_flag = 0;
    } else
#line 1116
    if ((int )*ptr == 123) {
      {
#line 1117
      ptr = rm_first_spaces(ptr + 1);
      }
#line 1118
      if ((int )*ptr != 0) {
#line 1118
        if ((int )*ptr != 35) {
          {
#line 1119
          fclose(fp);
#line 1120
          (*cfgFatal)((cfgErrorCode )3, file, line, line_buf);
          }
        }
      }
      {
#line 1122
      free((void *)line_buf);
      }
      {
#line 1123
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 1123
        ptr = get_single_line_without_first_spaces(fp, & line_buf, & line);
        }
#line 1123
        if (! ((unsigned long )ptr != (unsigned long )((void *)0))) {
#line 1123
          goto while_break___0;
        }
#line 1124
        if ((int )*ptr == 125) {
          {
#line 1125
          ptr = rm_first_spaces(ptr + 1);
          }
#line 1126
          if ((int )*ptr != 0) {
#line 1126
            if ((int )*ptr != 35) {
              {
#line 1127
              fclose(fp);
#line 1128
              (*cfgFatal)((cfgErrorCode )3, file, line, line_buf);
              }
            }
          }
#line 1130
          goto while_break___0;
        }
        {
#line 1132
        free((void *)line_buf);
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 1136
    free((void *)read_parameter);
#line 1137
    free((void *)line_buf);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1139
  return (store_flag);
}
}
#line 306 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 620 "/usr/include/stdlib.h"
extern int ( __attribute__((__nonnull__(1))) mkstemp)(char *__template ) ;
#line 734
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) realpath)(char const   * __restrict  __name ,
                                                                                 char * __restrict  __resolved ) ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 162
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 342 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 348
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2), __leaf__)) strtok)(char * __restrict  __s ,
                                                                                               char const   * __restrict  __delim ) ;
#line 239 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) gmtime)(time_t const   *__timer ) ;
#line 263 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) lstat)(char const   * __restrict  __file ,
                                                                                              struct stat * __restrict  __buf ) ;
#line 108 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/ftplib.h"
int FtpChdir(char const   *path , netbuf *nControl ) ;
#line 113
int FtpDir(char const   *outputfile , char const   *path , netbuf *nControl ) ;
#line 115
int FtpModDate(char const   *path , char *dt , int max , netbuf *nControl ) ;
#line 62 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/proto.h"
void change_dir_actually(LocalOrRemote side ) ;
#line 63
void ftp_disconnect(void) ;
#line 77
int get_cache(char *file_name , long *date , long *time___0 ) ;
#line 78
void update_cache(char *file_name , long date , long time___0 ) ;
#line 94
int get_local_file_data(FileData **local_data ) ;
#line 95
int get_remote_file_data(FileData **remote_data ) ;
#line 96
void free_file_data(FileData *file_data , int max_file_data ) ;
#line 97
int parse_file_and_filetype(char *str , char **file ) ;
#line 98
int is_ignore_file(char *file_name , LocalOrRemote side ) ;
#line 99
int is_ignore_dir(char *dir_name , LocalOrRemote side ) ;
#line 100
int is_ascii_file(char *file_name ) ;
#line 101
int is_change_permission_dir(void) ;
#line 102
int is_preserve_permission_dir(void) ;
#line 103
int is_keep_remote_dir(void) ;
#line 50 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/filedata.c"
int get_local_file_data(FileData **local_data ) 
{ 
  DIR *dir ;
  struct dirent *ent ;
  struct stat file_stat ;
  struct tm *ftime ;
  char time_temp[10] ;
  char date_temp[10] ;
  int isdir ;
  int file_num ;
  int i ;
  int tmp ;
  int tmp___0 ;
  char realfname[4096] ;
  char *temp ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  char *temp___0 ;
  char *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;

  {
  {
#line 59
  file_num = 0;
#line 62
  dir = opendir(".");
  }
  {
#line 63
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 63
    ent = readdir(dir);
    }
#line 63
    if (! ((unsigned long )ent != (unsigned long )((void *)0))) {
#line 63
      goto while_break;
    }
    {
#line 64
    tmp = strcmp((char const   *)(ent->d_name), ".");
    }
#line 64
    if (tmp == 0) {
#line 65
      goto while_continue;
    } else {
      {
#line 64
      tmp___0 = strcmp((char const   *)(ent->d_name), "..");
      }
#line 64
      if (tmp___0 == 0) {
#line 65
        goto while_continue;
      }
    }
    {
#line 67
    lstat((char const   */* __restrict  */)(ent->d_name), (struct stat */* __restrict  */)(& file_stat));
    }
#line 70
    if (*(follow_symlinks + host_number)) {
#line 70
      if ((file_stat.st_mode & 40960U) == 40960U) {
        {
#line 74
        tmp___3 = realpath((char const   */* __restrict  */)(ent->d_name), (char */* __restrict  */)(realfname));
        }
#line 74
        if ((unsigned long )tmp___3 == (unsigned long )((void *)0)) {
          {
#line 77
          tmp___1 = dgettext("weex", "Cannot expand symbolic link `%s\'. Ignore this file.\n");
#line 77
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1,
                  ent->d_name);
#line 78
          tmp___2 = dgettext("weex", "Expanding symbolic link failed: %s");
#line 78
          temp = str_dup_printf((char const   *)tmp___2, ent->d_name);
#line 79
          log_write(temp);
#line 80
          free((void *)temp);
          }
#line 81
          goto while_continue;
        }
        {
#line 83
        stat((char const   */* __restrict  */)(realfname), (struct stat */* __restrict  */)(& file_stat));
        }
      }
    }
    {
#line 86
    isdir = (file_stat.st_mode & 16384U) == 16384U;
#line 87
    ftime = gmtime((time_t const   *)(& file_stat.st_mtim.tv_sec));
    }
#line 89
    if (isdir) {
      {
#line 90
      tmp___4 = is_ignore_dir(ent->d_name, (LocalOrRemote )0);
      }
#line 90
      if (tmp___4) {
#line 92
        goto while_continue;
      }
    } else {
      {
#line 95
      tmp___5 = is_ignore_file(ent->d_name, (LocalOrRemote )0);
      }
#line 95
      if (tmp___5) {
#line 97
        goto while_continue;
      }
    }
    {
#line 101
    sprintf((char */* __restrict  */)(date_temp), (char const   */* __restrict  */)"%04d%02d%02d",
            1900 + ftime->tm_year, ftime->tm_mon + 1, ftime->tm_mday);
#line 102
    sprintf((char */* __restrict  */)(time_temp), (char const   */* __restrict  */)"%02d%02d%02d",
            ftime->tm_hour, ftime->tm_min, ftime->tm_sec);
#line 104
    tmp___6 = str_realloc((void *)*local_data, sizeof(*(*local_data)) * (unsigned long )(file_num + 1));
#line 104
    *local_data = (FileData *)tmp___6;
#line 105
    (*local_data + file_num)->date = atol((char const   *)(date_temp));
#line 106
    (*local_data + file_num)->time = atol((char const   *)(time_temp));
#line 107
    (*local_data + file_num)->isdir = isdir;
#line 108
    (*local_data + file_num)->name = str_dup((char const   *)(ent->d_name));
    }
#line 112
    if (*(conv_to_lower + host_number)) {
#line 113
      i = 0;
      {
#line 113
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 113
        if (! (i < file_num)) {
#line 113
          goto while_break___0;
        }
        {
#line 114
        tmp___9 = strcasecmp((char const   *)(*local_data + file_num)->name, (char const   *)(*local_data + i)->name);
        }
#line 114
        if (tmp___9 == 0) {
          {
#line 117
          tmp___7 = dgettext("weex", "ConvToLower causes a conflict between `%s\' and `%s\'. Proceed anyway.\n");
#line 117
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___7,
                  (*local_data + i)->name, (*local_data + file_num)->name);
#line 119
          tmp___8 = dgettext("weex", "Confliction by ConvToLower: %s");
#line 119
          temp___0 = str_dup_printf((char const   *)tmp___8, (*local_data + i)->name);
#line 120
          log_write(temp___0);
#line 121
          free((void *)temp___0);
          }
        }
#line 113
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 126
    file_num ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 128
  closedir(dir);
  }
#line 129
  return (file_num);
}
}
#line 139 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/filedata.c"
int get_remote_file_data(FileData **remote_data ) 
{ 
  char list_temp[32] ;
  int fd ;
  FILE *fp ;
  char *fgets_temp ;
  char *file_name ;
  long date ;
  long time___0 ;
  char mod_temp[20] ;
  char dir_flag ;
  char *temp ;
  int *add_cache_num ;
  int add_cache_files ;
  int file_num ;
  int i ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  void *tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  void *tmp___18 ;
  char *tmp___19 ;
  int tmp___20 ;

  {
  {
#line 150
  add_cache_num = (int *)((void *)0);
#line 151
  add_cache_files = 0;
#line 152
  file_num = 0;
#line 155
  tmp = strcmp((char const   *)current_dir[1], (char const   *)*(dest_dir + host_number));
  }
#line 155
  if (tmp != 0) {
    {
#line 156
    change_dir_actually((LocalOrRemote )1);
    }
  }
  {
#line 158
  strcpy((char */* __restrict  */)(list_temp), (char const   */* __restrict  */)"/tmp/weexXXXXXX");
#line 159
  fd = mkstemp(list_temp);
  }
#line 160
  if (fd == -1) {
    {
#line 161
    tmp___0 = dgettext("weex", "Cannot create a unique file name.\n");
#line 161
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0);
#line 162
    ftp_disconnect();
#line 163
    exit(1);
    }
  }
#line 166
  if (*(show_hidden_file + host_number)) {
    {
#line 166
    tmp___3 = FtpDir((char const   *)(list_temp), "-a", ftp_buf);
    }
#line 166
    if (tmp___3 == 0) {
#line 166
      goto _L;
    } else {
#line 166
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 166
  if (! *(show_hidden_file + host_number)) {
    {
#line 166
    tmp___4 = FtpDir((char const   *)(list_temp), (char const   *)((void *)0), ftp_buf);
    }
#line 166
    if (tmp___4 == 0) {
      _L: /* CIL Label */ 
      {
#line 168
      tmp___1 = dgettext("weex", "Cannot get remote directory list.\n");
#line 168
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1);
#line 169
      tmp___2 = dgettext("weex", "Getting remote directory list failed");
#line 169
      log_write(tmp___2);
#line 170
      ftp_disconnect();
#line 171
      exit(1);
      }
    }
  }
  {
#line 173
  fp = fdopen(fd, "r");
  }
#line 174
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 175
    tmp___5 = dgettext("weex", "Cannot open `%s\'.\n");
#line 175
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___5,
            list_temp);
#line 176
    ftp_disconnect();
#line 177
    exit(1);
    }
  }
  {
#line 180
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 180
    fgets_temp = str_fgets(fp);
    }
#line 180
    if (! ((unsigned long )fgets_temp != (unsigned long )((void *)0))) {
#line 180
      goto while_break;
    }
    {
#line 181
    tmp___6 = strncmp((char const   *)fgets_temp, "total", (size_t )5);
    }
#line 181
    if (tmp___6 == 0) {
      {
#line 182
      free((void *)fgets_temp);
      }
#line 183
      goto while_continue;
    }
    {
#line 188
    tmp___7 = parse_file_and_filetype(fgets_temp, & file_name);
#line 188
    dir_flag = (char )tmp___7;
#line 190
    free((void *)fgets_temp);
    }
#line 196
    if ((int )dir_flag == 108) {
      {
#line 198
      tmp___9 = FtpChdir((char const   *)file_name, ftp_buf);
      }
#line 198
      if (tmp___9) {
#line 198
        dir_flag = (char )'d';
      } else {
#line 198
        dir_flag = (char )'-';
      }
      {
#line 199
      FtpChdir((char const   *)current_dir[1], ftp_buf);
      }
    }
    {
#line 203
    tmp___10 = strcmp((char const   *)file_name, ".");
    }
#line 203
    if (tmp___10 == 0) {
      {
#line 208
      free((void *)file_name);
      }
#line 209
      goto while_continue;
    } else {
      {
#line 203
      tmp___11 = strcmp((char const   *)file_name, "..");
      }
#line 203
      if (tmp___11 == 0) {
        {
#line 208
        free((void *)file_name);
        }
#line 209
        goto while_continue;
      } else
#line 203
      if ((int )dir_flag == 100) {
        {
#line 203
        tmp___12 = is_ignore_dir(file_name, (LocalOrRemote )1);
        }
#line 203
        if (tmp___12) {
          {
#line 208
          free((void *)file_name);
          }
#line 209
          goto while_continue;
        } else {
#line 203
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 203
      if ((int )dir_flag != 100) {
        {
#line 203
        tmp___13 = is_ignore_file(file_name, (LocalOrRemote )1);
        }
#line 203
        if (tmp___13) {
          {
#line 208
          free((void *)file_name);
          }
#line 209
          goto while_continue;
        }
      }
    }
#line 212
    time___0 = 0L;
#line 212
    date = time___0;
#line 213
    if ((int )dir_flag != 100) {
#line 214
      if (*(conv_to_lower + host_number)) {
        {
#line 215
        temp = str_tolower(file_name);
#line 217
        free((void *)file_name);
#line 218
        file_name = temp;
        }
      }
      {
#line 220
      tmp___17 = get_cache(file_name, & date, & time___0);
      }
#line 220
      if (tmp___17 == -1) {
        {
#line 222
        tmp___16 = FtpModDate((char const   *)file_name, mod_temp, 20, ftp_buf);
        }
#line 222
        if (tmp___16 == 1) {
          {
#line 223
          date = n_atol(mod_temp, 8);
#line 224
          time___0 = n_atol(mod_temp + 8, 6);
#line 225
          tmp___14 = str_realloc((void *)add_cache_num, sizeof(*add_cache_num) * (unsigned long )(add_cache_files + 1));
#line 225
          add_cache_num = (int *)tmp___14;
#line 226
          tmp___15 = add_cache_files;
#line 226
          add_cache_files ++;
#line 226
          *(add_cache_num + tmp___15) = file_num;
          }
        }
      }
    }
    {
#line 232
    tmp___18 = str_realloc((void *)*remote_data, sizeof(*(*remote_data)) * (unsigned long )(file_num + 1));
#line 232
    *remote_data = (FileData *)tmp___18;
#line 233
    (*remote_data + file_num)->date = date;
#line 234
    (*remote_data + file_num)->time = time___0;
#line 235
    (*remote_data + file_num)->isdir = (int )dir_flag == 100;
#line 236
    (*remote_data + file_num)->name = file_name;
#line 240
    file_num ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 243
  i = 0;
  {
#line 243
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 243
    if (! (i < add_cache_files)) {
#line 243
      goto while_break___0;
    }
    {
#line 244
    update_cache((*remote_data + *(add_cache_num + i))->name, (*remote_data + *(add_cache_num + i))->date,
                 (*remote_data + *(add_cache_num + i))->time);
#line 243
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 248
  fclose(fp);
#line 249
  tmp___20 = remove((char const   *)(list_temp));
  }
#line 249
  if (tmp___20 == -1) {
    {
#line 250
    tmp___19 = dgettext("weex", "Cannot remove `%s\'.\n");
#line 250
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___19,
            list_temp);
#line 251
    ftp_disconnect();
#line 252
    exit(1);
    }
  }
  {
#line 254
  free((void *)add_cache_num);
  }
#line 256
  return (file_num);
}
}
#line 267 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/filedata.c"
void free_file_data(FileData *file_data , int max_file_data ) 
{ 
  int i ;

  {
#line 271
  i = 0;
  {
#line 271
  while (1) {
    while_continue: /* CIL Label */ ;
#line 271
    if (! (i < max_file_data)) {
#line 271
      goto while_break;
    }
    {
#line 272
    free((void *)(file_data + i)->name);
#line 271
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 274
  free((void *)file_data);
  }
#line 275
  return;
}
}
#line 288 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/filedata.c"
int parse_file_and_filetype(char *str , char **file ) 
{ 
  char dir_flag ;
  int i ;
  char *ptr ;
  char *lnktmp ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  unsigned short const   **tmp___6 ;
  unsigned short const   **tmp___7 ;
  unsigned short const   **tmp___8 ;
  unsigned short const   **tmp___9 ;
  unsigned short const   **tmp___10 ;
  size_t tmp___11 ;

  {
  {
#line 295
  ptr = strtok((char */* __restrict  */)str, (char const   */* __restrict  */)" ");
  }
#line 296
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
    {
#line 297
    tmp = dgettext("weex", "Cannot get the remote directory list correctly.\n");
#line 297
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp);
#line 298
    ftp_disconnect();
#line 299
    exit(1);
    }
  }
  {
#line 301
  tmp___9 = __ctype_b_loc();
  }
#line 301
  if ((int const   )*(*tmp___9 + (int )*ptr) & 2048) {
    {
#line 301
    tmp___10 = __ctype_b_loc();
    }
#line 301
    if ((int const   )*(*tmp___10 + (int )*(ptr + 1)) & 2048) {
#line 301
      if ((int )*(ptr + 2) == 45) {
#line 302
        i = 0;
        {
#line 302
        while (1) {
          while_continue: /* CIL Label */ ;
#line 302
          if (! (i < 2)) {
#line 302
            goto while_break;
          }
          {
#line 303
          ptr = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" ");
          }
#line 303
          if ((unsigned long )ptr == (unsigned long )((void *)0)) {
            {
#line 304
            tmp___0 = dgettext("weex", "Cannot get the remote directory list correctly.\n");
#line 304
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0);
#line 305
            ftp_disconnect();
#line 306
            exit(1);
            }
          }
#line 302
          i ++;
        }
        while_break: /* CIL Label */ ;
        }
        {
#line 309
        tmp___2 = strcmp((char const   *)ptr, "<DIR>");
        }
#line 309
        if (tmp___2 == 0) {
#line 309
          dir_flag = (char )'d';
        } else {
#line 309
          dir_flag = (char )'-';
        }
      } else {
#line 301
        goto _L___2;
      }
    } else {
#line 301
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ 
#line 311
    dir_flag = *(str + 0);
#line 313
    i = 0;
    {
#line 313
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 313
      if (! (i < 7)) {
#line 313
        goto while_break___0;
      }
      {
#line 314
      ptr = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" ");
      }
#line 314
      if ((unsigned long )ptr == (unsigned long )((void *)0)) {
        {
#line 315
        tmp___3 = dgettext("weex", "Cannot get the remote directory list correctly.\n");
#line 315
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___3);
#line 316
        ftp_disconnect();
#line 317
        exit(1);
        }
      }
#line 319
      if (i == 0) {
        {
#line 319
        tmp___4 = strcmp((char const   *)ptr, "folder");
        }
#line 319
        if (tmp___4 == 0) {
#line 322
          i ++;
        } else {
#line 319
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 319
      if (i == 1) {
        {
#line 319
        tmp___5 = strcmp((char const   *)ptr, "0000/0000");
        }
#line 319
        if (tmp___5 == 0) {
#line 322
          i ++;
        } else {
#line 319
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 319
      if (i == 3) {
        {
#line 319
        tmp___6 = __ctype_b_loc();
        }
#line 319
        if ((int const   )*(*tmp___6 + (int )*ptr) & 256) {
          {
#line 319
          tmp___7 = __ctype_b_loc();
          }
#line 319
          if ((int const   )*(*tmp___7 + (int )*(ptr + 1)) & 512) {
            {
#line 319
            tmp___8 = __ctype_b_loc();
            }
#line 319
            if ((int const   )*(*tmp___8 + (int )*(ptr + 2)) & 512) {
#line 319
              if ((int )*(ptr + 3) == 0) {
#line 322
                i ++;
              }
            }
          }
        }
      }
#line 313
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 326
  tmp___11 = strlen((char const   *)ptr);
#line 326
  ptr = (ptr + tmp___11) + 1;
#line 327
  lnktmp = strstr((char const   *)ptr, " -> ");
  }
#line 327
  if ((unsigned long )lnktmp != (unsigned long )((void *)0)) {
#line 328
    *lnktmp = (char )'\000';
  }
  {
#line 333
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 333
    if (! ((int )*ptr == 32)) {
#line 333
      goto while_break___1;
    }
#line 334
    ptr ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 337
  *file = str_dup((char const   *)ptr);
  }
#line 339
  return ((int )dir_flag);
}
}
#line 350 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/filedata.c"
int is_ignore_dir(char *dir_name , LocalOrRemote side ) 
{ 
  cfgList *l ;
  char *temp ;
  int tmp ;
  int tmp___0 ;

  {
#line 355
  if ((unsigned int )side == 0U) {
#line 355
    if ((unsigned long )*(ignore_local_dir + host_number) == (unsigned long )((void *)0)) {
#line 356
      return (0);
    } else {
#line 355
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 355
  if ((unsigned int )side == 1U) {
#line 355
    if ((unsigned long )*(ignore_remote_dir + host_number) == (unsigned long )((void *)0)) {
#line 356
      return (0);
    }
  }
  {
#line 358
  temp = str_concat((char const   *)current_dir[side], dir_name, "/", (void *)0);
  }
#line 359
  if ((unsigned int )side == 0U) {
#line 360
    l = *(ignore_local_dir + host_number);
    {
#line 360
    while (1) {
      while_continue: /* CIL Label */ ;
#line 360
      if (! ((unsigned long )l != (unsigned long )((void *)0))) {
#line 360
        goto while_break;
      }
      {
#line 361
      tmp = cmp_file_with_wildcard(temp, l->str);
      }
#line 361
      if (tmp == 0) {
        {
#line 362
        free((void *)temp);
        }
#line 363
        return (1);
      }
#line 360
      l = l->next;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 366
  if ((unsigned int )side == 1U) {
#line 367
    l = *(ignore_remote_dir + host_number);
    {
#line 367
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 367
      if (! ((unsigned long )l != (unsigned long )((void *)0))) {
#line 367
        goto while_break___0;
      }
      {
#line 368
      tmp___0 = cmp_file_with_wildcard(temp, l->str);
      }
#line 368
      if (tmp___0 == 0) {
        {
#line 369
        free((void *)temp);
        }
#line 370
        return (1);
      }
#line 367
      l = l->next;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 374
  free((void *)temp);
  }
#line 375
  return (0);
}
}
#line 386 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/filedata.c"
int is_ignore_file(char *file_name , LocalOrRemote side ) 
{ 
  cfgList *l ;
  char *temp ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;

  {
#line 391
  if ((unsigned int )side == 0U) {
#line 391
    if ((unsigned long )*(ignore_local_file + host_number) == (unsigned long )((void *)0)) {
#line 392
      return (0);
    } else {
#line 391
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 391
  if ((unsigned int )side == 1U) {
#line 391
    if ((unsigned long )*(ignore_remote_file + host_number) == (unsigned long )((void *)0)) {
#line 392
      return (0);
    }
  }
  {
#line 394
  temp = str_concat((char const   *)current_dir[side], file_name, (void *)0);
  }
#line 395
  if ((unsigned int )side == 0U) {
#line 396
    l = *(ignore_local_file + host_number);
    {
#line 396
    while (1) {
      while_continue: /* CIL Label */ ;
#line 396
      if (! ((unsigned long )l != (unsigned long )((void *)0))) {
#line 396
        goto while_break;
      }
      {
#line 397
      tmp___1 = strchr((char const   *)l->str, '/');
      }
#line 397
      if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
        {
#line 398
        tmp = cmp_file_with_wildcard(file_name, l->str);
        }
#line 398
        if (tmp == 0) {
          {
#line 399
          free((void *)temp);
          }
#line 400
          return (1);
        }
      } else {
        {
#line 403
        tmp___0 = cmp_file_with_wildcard(temp, l->str);
        }
#line 403
        if (tmp___0 == 0) {
          {
#line 404
          free((void *)temp);
          }
#line 405
          return (1);
        }
      }
#line 396
      l = l->next;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 409
  if ((unsigned int )side == 1U) {
#line 410
    l = *(ignore_remote_file + host_number);
    {
#line 410
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 410
      if (! ((unsigned long )l != (unsigned long )((void *)0))) {
#line 410
        goto while_break___0;
      }
      {
#line 411
      tmp___4 = strchr((char const   *)l->str, '/');
      }
#line 411
      if ((unsigned long )tmp___4 == (unsigned long )((void *)0)) {
        {
#line 412
        tmp___2 = cmp_file_with_wildcard(file_name, l->str);
        }
#line 412
        if (tmp___2 == 0) {
          {
#line 413
          free((void *)temp);
          }
#line 414
          return (1);
        }
      } else {
        {
#line 417
        tmp___3 = cmp_file_with_wildcard(temp, l->str);
        }
#line 417
        if (tmp___3 == 0) {
          {
#line 418
          free((void *)temp);
          }
#line 419
          return (1);
        }
      }
#line 410
      l = l->next;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 424
  free((void *)temp);
  }
#line 425
  return (0);
}
}
#line 435 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/filedata.c"
int is_ascii_file(char *file_name ) 
{ 
  cfgList *l ;
  char *temp ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
#line 440
  if ((unsigned long )*(ascii_file + host_number) == (unsigned long )((void *)0)) {
#line 441
    return (0);
  }
  {
#line 443
  temp = str_concat((char const   *)current_dir[0], file_name, (void *)0);
#line 444
  l = *(ascii_file + host_number);
  }
  {
#line 444
  while (1) {
    while_continue: /* CIL Label */ ;
#line 444
    if (! ((unsigned long )l != (unsigned long )((void *)0))) {
#line 444
      goto while_break;
    }
    {
#line 445
    tmp___1 = strchr((char const   *)l->str, '/');
    }
#line 445
    if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
      {
#line 446
      tmp = cmp_file_with_wildcard(file_name, l->str);
      }
#line 446
      if (tmp == 0) {
        {
#line 447
        free((void *)temp);
        }
#line 448
        return (1);
      }
    } else {
      {
#line 451
      tmp___0 = cmp_file_with_wildcard(temp, l->str);
      }
#line 451
      if (tmp___0 == 0) {
        {
#line 452
        free((void *)temp);
        }
#line 453
        return (1);
      }
    }
#line 444
    l = l->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 457
  free((void *)temp);
  }
#line 458
  return (0);
}
}
#line 467 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/filedata.c"
int is_change_permission_dir(void) 
{ 
  cfgList *l ;
  int tmp ;

  {
#line 471
  if ((unsigned long )*(change_permission_dir + host_number) == (unsigned long )((void *)0)) {
#line 472
    return (0);
  }
#line 474
  l = *(change_permission_dir + host_number);
  {
#line 474
  while (1) {
    while_continue: /* CIL Label */ ;
#line 474
    if (! ((unsigned long )l != (unsigned long )((void *)0))) {
#line 474
      goto while_break;
    }
    {
#line 475
    tmp = cmp_file_with_wildcard(current_dir[0], l->str);
    }
#line 475
    if (tmp == 0) {
#line 476
      return (1);
    }
#line 474
    l = l->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 479
  return (0);
}
}
#line 488 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/filedata.c"
int is_preserve_permission_dir(void) 
{ 
  cfgList *l ;
  int tmp ;

  {
#line 492
  if ((unsigned long )*(preserve_permission_dir + host_number) == (unsigned long )((void *)0)) {
#line 493
    return (0);
  }
#line 495
  l = *(preserve_permission_dir + host_number);
  {
#line 495
  while (1) {
    while_continue: /* CIL Label */ ;
#line 495
    if (! ((unsigned long )l != (unsigned long )((void *)0))) {
#line 495
      goto while_break;
    }
    {
#line 496
    tmp = cmp_file_with_wildcard(current_dir[0], l->str);
    }
#line 496
    if (tmp == 0) {
#line 497
      return (1);
    }
#line 495
    l = l->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 500
  return (0);
}
}
#line 509 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/filedata.c"
int is_keep_remote_dir(void) 
{ 
  cfgList *l ;
  int tmp ;

  {
#line 513
  if ((unsigned long )*(keep_remote_dir + host_number) == (unsigned long )((void *)0)) {
#line 514
    return (0);
  }
#line 516
  l = *(keep_remote_dir + host_number);
  {
#line 516
  while (1) {
    while_continue: /* CIL Label */ ;
#line 516
    if (! ((unsigned long )l != (unsigned long )((void *)0))) {
#line 516
      goto while_break;
    }
    {
#line 517
    tmp = cmp_file_with_wildcard(current_dir[1], l->str);
    }
#line 517
    if (tmp == 0) {
#line 518
      return (1);
    }
#line 516
    l = l->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 521
  return (0);
}
}
#line 76 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/proto.h"
void load_cache(void) ;
#line 79
void del_cache(char *file_name ) ;
#line 80
void del_cache_dir(char *dir_name ) ;
#line 81
void save_cache(void) ;
#line 82
void update_cache_directory(char *dir ) ;
#line 83
int find_cache_dir(char *name ) ;
#line 84
int get_remote_file_data_from_cache(FileData **remote_data ) ;
#line 36 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/cache.c"
static Cache_dir *cache_dir  ;
#line 37 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/cache.c"
static int max_cache_dir  ;
#line 44 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/cache.c"
void load_cache(void) 
{ 
  char *temp ;
  FILE *fp ;
  char *read_temp ;
  Cache *cache ;
  int max_cache_file ;
  char *date ;
  char *time___0 ;
  char *name ;
  int i ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  int tmp___10 ;

  {
  {
#line 55
  cache_dir = (Cache_dir *)((void *)0);
#line 56
  max_cache_dir = 0;
#line 56
  max_cache_file = max_cache_dir;
#line 57
  is_cache_existent = 0;
#line 59
  tmp = cfgSectionNumberToName(host_number);
#line 59
  tmp___0 = getenv("HOME");
#line 59
  temp = str_concat((char const   *)tmp___0, "/.weex/weex.cache.", tmp, (void *)0);
  }
#line 61
  if (rebuild_cache) {
    {
#line 62
    tmp___1 = dgettext("weex", "Rebuilding cache file `%s\'.\n");
#line 62
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1,
            temp);
#line 63
    free((void *)temp);
    }
#line 64
    return;
  }
  {
#line 67
  fp = fopen((char const   */* __restrict  */)temp, (char const   */* __restrict  */)"r");
  }
#line 68
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 69
    tmp___2 = dgettext("weex", "Cache file `%s\' does not exist.");
#line 69
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___2,
            temp);
    }
#line 70
    if (! opt_test) {
      {
#line 71
      tmp___3 = dgettext("weex", " Creating a new one.\n");
#line 71
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___3);
      }
    } else {
      {
#line 73
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    }
    {
#line 75
    free((void *)temp);
    }
#line 76
    return;
  }
#line 79
  i = 0;
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 79
    read_temp = str_fgets(fp);
    }
#line 79
    if (! ((unsigned long )read_temp != (unsigned long )((void *)0))) {
#line 79
      goto while_break;
    }
    {
#line 80
    date = strtok((char */* __restrict  */)read_temp, (char const   */* __restrict  */)" ");
#line 81
    time___0 = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" ");
    }
#line 82
    if ((unsigned long )date == (unsigned long )((void *)0)) {
      {
#line 83
      tmp___4 = dgettext("weex", "Cache file `%s\' is broken at line %d.\n");
#line 83
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___4,
              temp, i + 1);
#line 84
      exit(1);
      }
    } else
#line 82
    if ((unsigned long )time___0 == (unsigned long )((void *)0)) {
      {
#line 83
      tmp___4 = dgettext("weex", "Cache file `%s\' is broken at line %d.\n");
#line 83
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___4,
              temp, i + 1);
#line 84
      exit(1);
      }
    }
    {
#line 87
    tmp___5 = strlen((char const   *)time___0);
#line 87
    name = (time___0 + tmp___5) + 1;
    }
#line 88
    if ((unsigned long )name == (unsigned long )((void *)0)) {
      {
#line 89
      tmp___6 = dgettext("weex", "Cache file `%s\' is broken at line %d.\n");
#line 89
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___6,
              temp, i + 1);
#line 90
      exit(1);
      }
    } else
#line 88
    if (i == 0) {
      {
#line 88
      tmp___7 = strcmp((char const   *)date, "00000000");
      }
#line 88
      if (tmp___7 != 0) {
        {
#line 89
        tmp___6 = dgettext("weex", "Cache file `%s\' is broken at line %d.\n");
#line 89
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___6,
                temp, i + 1);
#line 90
        exit(1);
        }
      }
    }
    {
#line 92
    tmp___10 = strcmp((char const   *)date, "00000000");
    }
#line 92
    if (tmp___10 == 0) {
      {
#line 93
      tmp___8 = str_realloc((void *)cache_dir, (unsigned long )(max_cache_dir + 1) * sizeof(*cache_dir));
#line 93
      cache_dir = (Cache_dir *)tmp___8;
#line 94
      (cache_dir + max_cache_dir)->name = str_dup((char const   *)name);
#line 95
      (cache_dir + max_cache_dir)->ptr = (Cache *)((void *)0);
      }
#line 96
      if (max_cache_dir > 0) {
#line 97
        (cache_dir + (max_cache_dir - 1))->max_file = max_cache_file;
      }
#line 99
      max_cache_dir ++;
#line 100
      max_cache_file = 0;
    } else {
      {
#line 102
      tmp___9 = str_realloc((void *)(cache_dir + (max_cache_dir - 1))->ptr, (unsigned long )(max_cache_file + 1) * sizeof(*((cache_dir + (max_cache_dir - 1))->ptr)));
#line 102
      (cache_dir + (max_cache_dir - 1))->ptr = (Cache *)tmp___9;
#line 103
      cache = (cache_dir + (max_cache_dir - 1))->ptr;
#line 105
      (cache + max_cache_file)->name = str_dup((char const   *)name);
#line 106
      (cache + max_cache_file)->date = atol((char const   *)date);
#line 107
      (cache + max_cache_file)->time = atol((char const   *)time___0);
#line 108
      max_cache_file ++;
      }
    }
    {
#line 110
    free((void *)read_temp);
#line 79
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 112
  if (max_cache_dir > 0) {
#line 113
    (cache_dir + (max_cache_dir - 1))->max_file = max_cache_file;
  }
  {
#line 115
  fclose(fp);
#line 116
  free((void *)temp);
#line 117
  is_cache_existent = 1;
  }
#line 118
  return;
}
}
#line 129 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/cache.c"
Cache *find_cache(char *file_name ) 
{ 
  int i ;
  int cache_dir_num ;
  Cache *cache ;
  int tmp ;

  {
  {
#line 135
  cache_dir_num = find_cache_dir(current_dir[1]);
  }
#line 136
  if (cache_dir_num < 0) {
#line 137
    return ((Cache *)((void *)0));
  }
#line 140
  cache = (cache_dir + cache_dir_num)->ptr;
#line 141
  if ((unsigned long )cache == (unsigned long )((void *)0)) {
#line 142
    return ((Cache *)((void *)0));
  }
#line 145
  i = 0;
  {
#line 145
  while (1) {
    while_continue: /* CIL Label */ ;
#line 145
    if (! (i < (cache_dir + cache_dir_num)->max_file)) {
#line 145
      goto while_break;
    }
#line 146
    if ((unsigned long )(cache + i)->name != (unsigned long )((void *)0)) {
      {
#line 146
      tmp = strcmp((char const   *)(cache + i)->name, (char const   *)file_name);
      }
#line 146
      if (tmp == 0) {
#line 147
        return (cache + i);
      }
    }
#line 145
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 151
  return ((Cache *)((void *)0));
}
}
#line 163 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/cache.c"
int get_cache(char *file_name , long *date , long *time___0 ) 
{ 
  Cache *cache ;

  {
  {
#line 167
  cache = find_cache(file_name);
  }
#line 168
  if ((unsigned long )cache != (unsigned long )((void *)0)) {
#line 169
    *date = cache->date;
#line 170
    *time___0 = cache->time;
#line 171
    return (0);
  }
#line 173
  return (-1);
}
}
#line 185 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/cache.c"
void update_cache(char *file_name , long date , long time___0 ) 
{ 
  Cache *cache ;
  int cache_dir_num ;
  int max_cache_file ;
  char *tmp ;
  void *tmp___0 ;

  {
  {
#line 191
  cache = find_cache(file_name);
  }
#line 192
  if ((unsigned long )cache != (unsigned long )((void *)0)) {
#line 193
    cache->date = date;
#line 194
    cache->time = time___0;
#line 195
    return;
  }
  {
#line 198
  cache_dir_num = find_cache_dir(current_dir[1]);
  }
#line 199
  if (cache_dir_num < 0) {
    {
#line 200
    tmp = dgettext("weex", "Internal error: cache facility is broken.\n");
#line 200
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp);
#line 201
    exit(1);
    }
  }
  {
#line 203
  max_cache_file = (cache_dir + cache_dir_num)->max_file;
#line 204
  tmp___0 = str_realloc((void *)(cache_dir + cache_dir_num)->ptr, (unsigned long )(max_cache_file + 1) * sizeof(*((cache_dir + cache_dir_num)->ptr)));
#line 204
  (cache_dir + cache_dir_num)->ptr = (Cache *)tmp___0;
#line 205
  cache = (cache_dir + cache_dir_num)->ptr;
#line 206
  (cache + max_cache_file)->name = str_dup((char const   *)file_name);
#line 207
  (cache + max_cache_file)->date = date;
#line 208
  (cache + max_cache_file)->time = time___0;
#line 209
  ((cache_dir + cache_dir_num)->max_file) ++;
  }
#line 210
  return;
}
}
#line 218 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/cache.c"
void del_cache(char *file_name ) 
{ 
  Cache *cache ;

  {
  {
#line 222
  cache = find_cache(file_name);
  }
#line 223
  if ((unsigned long )cache != (unsigned long )((void *)0)) {
    {
#line 224
    free((void *)cache->name);
#line 225
    cache->name = (char *)((void *)0);
    }
  }
#line 227
  return;
}
}
#line 230 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/cache.c"
void del_cache_dir(char *dir_name ) 
{ 
  int cache_dir_num ;
  char *temp ;

  {
  {
#line 235
  temp = str_concat((char const   *)current_dir[1], dir_name, "/", (void *)0);
#line 236
  cache_dir_num = find_cache_dir(temp);
#line 237
  free((void *)temp);
  }
#line 239
  if (cache_dir_num >= 0) {
    {
#line 240
    free((void *)(cache_dir + cache_dir_num)->name);
#line 241
    (cache_dir + cache_dir_num)->name = (char *)((void *)0);
    }
  }
#line 243
  return;
}
}
#line 246 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/cache.c"
void update_cache_directory(char *dir ) 
{ 
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 248
  tmp___0 = find_cache_dir(dir);
  }
#line 248
  if (tmp___0 < 0) {
    {
#line 249
    tmp = str_realloc((void *)cache_dir, sizeof(*cache_dir) * (unsigned long )(max_cache_dir + 1));
#line 249
    cache_dir = (Cache_dir *)tmp;
#line 250
    (cache_dir + max_cache_dir)->name = str_dup((char const   *)dir);
#line 251
    (cache_dir + max_cache_dir)->max_file = 0;
#line 252
    (cache_dir + max_cache_dir)->ptr = (Cache *)((void *)0);
#line 253
    max_cache_dir ++;
    }
  }
#line 255
  return;
}
}
#line 258 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/cache.c"
int find_cache_dir(char *name ) 
{ 
  int i ;
  int tmp ;

  {
#line 262
  i = 0;
  {
#line 262
  while (1) {
    while_continue: /* CIL Label */ ;
#line 262
    if (! (i < max_cache_dir)) {
#line 262
      goto while_break;
    }
#line 263
    if ((unsigned long )(cache_dir + i)->name != (unsigned long )((void *)0)) {
      {
#line 263
      tmp = strcmp((char const   *)(cache_dir + i)->name, (char const   *)name);
      }
#line 263
      if (tmp == 0) {
#line 264
        return (i);
      }
    }
#line 262
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 267
  return (-1);
}
}
#line 276 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/cache.c"
void save_cache(void) 
{ 
  char *temp ;
  FILE *fp ;
  Cache *cache ;
  int i ;
  int j ;
  int freecache ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 283
  freecache = 0;
#line 285
  tmp = cfgSectionNumberToName(host_number);
#line 285
  tmp___0 = getenv("HOME");
#line 285
  temp = str_concat((char const   *)tmp___0, "/.weex/weex.cache.", tmp, (void *)0);
#line 286
  fp = fopen((char const   */* __restrict  */)temp, (char const   */* __restrict  */)"w");
  }
#line 287
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 288
    tmp___1 = dgettext("weex", "Cannot create cache file `%s\'.\n");
#line 288
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1,
            temp);
#line 289
    exit(1);
    }
  }
#line 292
  i = 0;
  {
#line 292
  while (1) {
    while_continue: /* CIL Label */ ;
#line 292
    if (! (i < max_cache_dir)) {
#line 292
      goto while_break;
    }
#line 293
    if ((unsigned long )(cache_dir + i)->name == (unsigned long )((void *)0)) {
#line 294
      goto __Cont;
    }
    {
#line 296
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"00000000 000000 %s\n",
            (cache_dir + i)->name);
    }
#line 298
    if ((unsigned long )(cache_dir + i)->ptr != (unsigned long )((void *)0)) {
#line 299
      cache = (cache_dir + i)->ptr;
#line 300
      j = 0;
      {
#line 300
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 300
        if (! (j < (cache_dir + i)->max_file)) {
#line 300
          goto while_break___0;
        }
#line 301
        if ((unsigned long )(cache + j)->name == (unsigned long )((void *)0)) {
#line 302
          goto __Cont___0;
        }
        {
#line 304
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%08ld %06ld %s\n",
                (cache + j)->date, (cache + j)->time, (cache + j)->name);
        }
#line 305
        if (freecache) {
          {
#line 305
          free((void *)(cache + j)->name);
          }
        }
        __Cont___0: /* CIL Label */ 
#line 300
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 307
      if (freecache) {
        {
#line 307
        free((void *)cache);
        }
      }
    }
#line 309
    if (freecache) {
      {
#line 309
      free((void *)(cache_dir + i)->name);
      }
    }
    __Cont: /* CIL Label */ 
#line 292
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 312
  fclose(fp);
#line 313
  free((void *)temp);
  }
#line 314
  if (freecache) {
    {
#line 314
    free((void *)cache_dir);
    }
  }
#line 315
  return;
}
}
#line 318 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/cache.c"
int get_remote_file_data_from_cache(FileData **remote_data ) 
{ 
  int cache_dir_num ;
  Cache *cache ;
  int i ;
  int cache_max_file ;
  int tmp ;
  void *tmp___0 ;

  {
  {
#line 325
  update_cache_directory(current_dir[1]);
  }
#line 327
  if (! is_cache_existent) {
    {
#line 328
    tmp = get_remote_file_data(remote_data);
    }
#line 328
    return (tmp);
  }
  {
#line 330
  cache_dir_num = find_cache_dir(current_dir[1]);
#line 332
  cache_max_file = (cache_dir + cache_dir_num)->max_file;
#line 334
  tmp___0 = str_malloc(sizeof(*(*remote_data)) * (unsigned long )cache_max_file);
#line 334
  *remote_data = (FileData *)tmp___0;
#line 335
  cache = (cache_dir + cache_dir_num)->ptr;
#line 336
  i = 0;
  }
  {
#line 336
  while (1) {
    while_continue: /* CIL Label */ ;
#line 336
    if (! (i < cache_max_file)) {
#line 336
      goto while_break;
    }
    {
#line 337
    (*remote_data + i)->date = (cache + i)->date;
#line 338
    (*remote_data + i)->time = (cache + i)->time;
#line 339
    (*remote_data + i)->isdir = (cache + i)->date == 99999999L;
#line 340
    (*remote_data + i)->name = str_dup((char const   *)(cache + i)->name);
#line 336
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 342
  return (cache_max_file);
}
}
#line 89 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/proto.h"
void put_mes(Message mes , int nest  , ...) ;
#line 34 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/message.c"
static char *mes_color[12]  = 
#line 34 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/message.c"
  {      (char *)"\033[33m",      (char *)"\033[33m",      (char *)"\033[36m",      (char *)"\033[36m", 
        (char *)"\033[32m",      (char *)"\033[35m",      (char *)"\033[33m",      (char *)"\033[31m", 
        (char *)"\033[34m",      (char *)"\033[32m",      (char *)"\033[35m",      (char *)"\033[0m"};
#line 49 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/message.c"
static char *process_mes[12]  = 
#line 49
  {      (char *)"Connect    : ",      (char *)"Disconnect : ",      (char *)"Entering   : ",      (char *)"Leaving    : ", 
        (char *)"Sending    : ",      (char *)"Sending    : ",      (char *)"Changing   : ",      (char *)"Removing   : ", 
        (char *)"Making Dir : ",      (char *)"Sending    : ",      (char *)"Sending    : ",      (char *)"Processing : "};
#line 73 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/message.c"
void put_mes(Message mes , int nest  , ...) 
{ 
  int mono_flag ;
  va_list ap ;
  int i ;
  int j ;
  char *temp ;
  int tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char const   *tmp___9 ;

  {
#line 80
  if (*(cfg_silent + host_number)) {
#line 81
    return;
  } else
#line 80
  if (opt_silent) {
#line 81
    return;
  }
#line 84
  if (*(cfg_monochrome + host_number)) {
#line 84
    tmp = 1;
  } else
#line 84
  if (opt_monochrome) {
#line 84
    tmp = 1;
  } else {
#line 84
    tmp = 0;
  }
#line 84
  mono_flag = tmp;
#line 86
  if (mono_flag) {
#line 86
    tmp___0 = "";
  } else {
#line 86
    tmp___0 = (char const   *)mes_color[mes];
  }
  {
#line 86
  tmp___1 = dgettext("weex", (char const   *)process_mes[mes]);
#line 86
  printf((char const   */* __restrict  */)"%s%s", tmp___1, tmp___0);
#line 87
  i = 0;
  }
  {
#line 87
  while (1) {
    while_continue: /* CIL Label */ ;
#line 87
    if (! (i < nest)) {
#line 87
      goto while_break;
    }
#line 88
    j = 0;
    {
#line 88
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 88
      if (! (j < *(nest_spaces + host_number))) {
#line 88
        goto while_break___0;
      }
      {
#line 89
      printf((char const   */* __restrict  */)" ");
#line 88
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 87
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 92
  __builtin_va_start(ap, nest);
  }
#line 93
  if ((unsigned int )mes == 9U) {
#line 93
    goto _L;
  } else
#line 93
  if ((unsigned int )mes == 10U) {
    _L: /* CIL Label */ 
    {
#line 94
    tmp___3 = __builtin_va_arg(ap, char *);
#line 94
    printf((char const   */* __restrict  */)tmp___3);
    }
#line 95
    if (mono_flag) {
#line 95
      tmp___4 = "";
    } else {
#line 95
      tmp___4 = "\033[0m";
    }
    {
#line 95
    printf((char const   */* __restrict  */)"%s", tmp___4);
#line 96
    printf((char const   */* __restrict  */)" -> ");
    }
#line 97
    if (mono_flag) {
#line 97
      tmp___5 = "";
    } else {
#line 97
      tmp___5 = (char const   *)mes_color[mes];
    }
    {
#line 97
    printf((char const   */* __restrict  */)"%s", tmp___5);
#line 98
    tmp___7 = __builtin_va_arg(ap, char *);
#line 98
    printf((char const   */* __restrict  */)tmp___7);
    }
  } else {
    {
#line 100
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 100
      tmp___8 = __builtin_va_arg(ap, char *);
#line 100
      temp = tmp___8;
      }
#line 100
      if (! ((unsigned long )temp != (unsigned long )((void *)0))) {
#line 100
        goto while_break___1;
      }
      {
#line 101
      printf((char const   */* __restrict  */)"%s", temp);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 104
  __builtin_va_end(ap);
  }
#line 105
  if (mono_flag) {
#line 105
    tmp___9 = "";
  } else {
#line 105
    tmp___9 = "\033[0m";
  }
  {
#line 105
  printf((char const   */* __restrict  */)"%s\n", tmp___9);
  }
#line 106
  return;
}
}
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 263 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 497 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 948
extern char *( __attribute__((__nonnull__(1))) getpass)(char const   *__prompt ) ;
#line 93 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/ftplib.h"
void FtpInit(void) ;
#line 95
int FtpConnect(char const   *host , netbuf **nControl ) ;
#line 97
int FtpLogin(char const   *user , char const   *pass , netbuf *nControl ) ;
#line 98
int FtpAuthorize(char const   *user , netbuf *nControl ) ;
#line 107
int FtpMkdir(char const   *path , netbuf *nControl ) ;
#line 110
int FtpRmdir(char const   *path , netbuf *nControl ) ;
#line 118
int FtpPut(char const   *inputfile , char const   *path , char mode , netbuf *nControl ) ;
#line 120
int FtpRename(char const   *src , char const   *dst , netbuf *nControl ) ;
#line 121
int FtpChmod(char const   *file , char const   *mode , netbuf *nControl ) ;
#line 122
int FtpDelete(char const   *fnm , netbuf *nControl ) ;
#line 123
void FtpQuit(netbuf *nControl ) ;
#line 56 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/proto.h"
int ftp_connect_init(void) ;
#line 57
int argv_to_host_num(char *arg ) ;
#line 58
int ftp_connect(void) ;
#line 59
int ftp_login(void) ;
#line 60
void change_dir(char *path , LocalOrRemote side ) ;
#line 61
void up_dir(LocalOrRemote side ) ;
#line 64
void ftp_recursive_search(void) ;
#line 65
void remove_files_on_remote_only(int max_local_file , int max_remote_file , FileData *local_data ,
                                 FileData *remote_data , int dir_nest___0 , int *dir_removed_file ) ;
#line 66
int get_equivalent_remote_number(char *local_name , int max_remote_file , FileData *remote_data ) ;
#line 67
int get_equivalent_local_number(char *remote_name , int max_local_file , FileData *local_data ) ;
#line 68
void ftp_enter(char *dir_name , int remote_isdir , int dir_nest___0 , int remote_num ,
               int *dir_removed_file ) ;
#line 69
void ftp_remove(char *file_name , int dir_nest___0 , int *dir_removed_file ) ;
#line 70
void remove_remote_dir(char *dir_name , int dir_nest___0 , int *dir_removed_file ) ;
#line 71
void ftp_mkdir(char *dir_name ) ;
#line 40 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/ftpmain.c"
static int total_sent_file  ;
#line 41 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/ftpmain.c"
static int total_removed_file  ;
#line 52 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/ftpmain.c"
void ftp_main(int argc , char **argv , int max_hosts ) 
{ 
  int i ;
  char *temp ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 57
  FtpInit();
#line 59
  i = 0;
  }
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;
#line 59
    if (! (i < argc - 1)) {
#line 59
      goto while_break;
    }
    {
#line 60
    host_number = argv_to_host_num(*(argv + (i + 1)));
    }
#line 62
    if (argc - 1 > 1) {
      {
#line 63
      tmp = cfgSectionNumberToName(host_number);
#line 63
      put_mes((Message )11, 0, tmp, (void *)0);
      }
    }
    {
#line 66
    tmp___0 = ftp_connect_init();
    }
#line 66
    if (tmp___0 == -1) {
      {
#line 67
      log_flush();
      }
#line 68
      goto __Cont;
    }
    {
#line 70
    total_removed_file = 0;
#line 70
    total_sent_file = total_removed_file;
#line 71
    ftp_recursive_search();
#line 73
    put_mes((Message )3, 0, *(dest_dir + host_number), (void *)0);
#line 74
    tmp___1 = dgettext("weex", "Complete: sent %d file(s), removed %d file(s)");
#line 74
    temp = str_dup_printf((char const   *)tmp___1, total_sent_file, total_removed_file);
#line 75
    log_write(temp);
#line 76
    free((void *)temp);
#line 77
    ftp_disconnect();
    }
#line 78
    if (! opt_test) {
      {
#line 79
      save_cache();
      }
    }
    __Cont: /* CIL Label */ 
#line 59
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 82
  return;
}
}
#line 91 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/ftpmain.c"
int argv_to_host_num(char *arg ) 
{ 
  int num ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
  {
#line 95
  tmp = atoi((char const   *)arg);
#line 95
  num = tmp - 1;
  }
#line 96
  if (num == -1) {
    {
#line 97
    num = cfgSectionNameToNumber((char const   *)arg);
    }
#line 98
    if (num == -1) {
      {
#line 99
      tmp___0 = dgettext("weex", "Specified host (section) name `%s\' is undefined.\n");
#line 99
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
              arg);
#line 100
      exit(1);
      }
    }
  } else {
    {
#line 103
    tmp___2 = cfgSectionNumberToName(num);
    }
#line 103
    if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
      {
#line 104
      tmp___1 = dgettext("weex", "Specified host (section) number `%s\' is undefined.\n");
#line 104
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1,
              arg);
#line 105
      exit(1);
      }
    }
  }
  {
#line 108
  tmp___4 = cfgSectionNumberToName(num);
#line 108
  tmp___5 = strcasecmp("default", (char const   *)tmp___4);
  }
#line 108
  if (tmp___5 == 0) {
    {
#line 109
    tmp___3 = dgettext("weex", "Cannot specify a default configuration.\n");
#line 109
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___3);
#line 110
    exit(1);
    }
  }
#line 113
  return (num);
}
}
#line 123 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/ftpmain.c"
int ftp_connect_init(void) 
{ 
  char *temp ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 127
  log_init();
#line 129
  put_mes((Message )0, 0, *(host_name + host_number), (void *)0);
#line 130
  tmp = ftp_connect();
  }
#line 130
  if (tmp == -1) {
#line 131
    return (-1);
  }
  {
#line 133
  tmp___0 = ftp_login();
  }
#line 133
  if (tmp___0 == -1) {
#line 134
    return (-1);
  }
  {
#line 137
  load_cache();
#line 139
  current_dir[0] = (char *)((void *)0);
  }
#line 140
  if ((unsigned long )*(src_dir + host_number) == (unsigned long )((void *)0)) {
    {
#line 141
    tmp___1 = dgettext("weex", "The source directory (SrcDir) is not configured.\n");
#line 141
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1);
#line 142
    exit(1);
    }
  }
  {
#line 144
  change_dir(*(src_dir + host_number), (LocalOrRemote )0);
#line 146
  current_dir[1] = (char *)((void *)0);
  }
#line 147
  if ((unsigned long )*(dest_dir + host_number) == (unsigned long )((void *)0)) {
    {
#line 148
    tmp___2 = dgettext("weex", "The destination directory (DestDir) is not configured.\n");
#line 148
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___2);
#line 149
    exit(1);
    }
  }
  {
#line 152
  change_dir(*(dest_dir + host_number), (LocalOrRemote )1);
  }
#line 153
  if (*(chdir_at_connection + host_number)) {
#line 154
    if (! is_cache_existent) {
      {
#line 155
      temp = str_dup((char const   *)*(dest_dir + host_number));
#line 156
      tmp___4 = strcmp((char const   *)temp, "/");
      }
#line 156
      if (tmp___4 != 0) {
        {
#line 157
        tmp___3 = strlen((char const   *)temp);
#line 157
        *(temp + (tmp___3 - 1UL)) = (char )'\000';
        }
      }
      {
#line 159
      tmp___6 = FtpChdir((char const   *)temp, ftp_buf);
      }
#line 159
      if (tmp___6 == 0) {
        {
#line 160
        tmp___5 = FtpMkdir((char const   *)temp, ftp_buf);
        }
#line 160
        if (tmp___5 == 1) {
          {
#line 161
          put_mes((Message )8, 0, *(dest_dir + host_number), (void *)0);
          }
        }
        {
#line 163
        FtpChdir((char const   *)temp, ftp_buf);
        }
      }
      {
#line 165
      free((void *)temp);
      }
    } else {
      {
#line 167
      change_dir_actually((LocalOrRemote )1);
      }
    }
  }
  {
#line 170
  put_mes((Message )2, 0, *(dest_dir + host_number), (void *)0);
  }
#line 172
  return (0);
}
}
#line 182 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/ftpmain.c"
int ftp_connect(void) 
{ 
  char *temp ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
#line 186
  if ((unsigned long )*(host_name + host_number) == (unsigned long )((void *)0)) {
    {
#line 187
    tmp = dgettext("weex", "The host name is not configured.\n");
#line 187
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp);
#line 188
    exit(1);
    }
  }
  {
#line 190
  tmp___3 = FtpConnect((char const   *)*(host_name + host_number), & ftp_buf);
  }
#line 190
  if (! tmp___3) {
    {
#line 191
    tmp___0 = dgettext("weex", "Cannot connect host `%s\'.\n\n");
#line 191
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
            *(host_name + host_number));
#line 192
    tmp___1 = cfgSectionNumberToName(host_number);
#line 192
    tmp___2 = dgettext("weex", "Connection failed: %s (%s)");
#line 192
    temp = str_dup_printf((char const   *)tmp___2, *(host_name + host_number), tmp___1);
#line 193
    log_write(temp);
#line 194
    free((void *)temp);
    }
#line 195
    return (-1);
  }
  {
#line 197
  tmp___4 = cfgSectionNumberToName(host_number);
#line 197
  tmp___5 = dgettext("weex", "Connected: %s (%s)");
#line 197
  temp = str_dup_printf((char const   *)tmp___5, *(host_name + host_number), tmp___4);
#line 198
  log_write(temp);
#line 199
  free((void *)temp);
  }
#line 201
  return (0);
}
}
#line 210 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/ftpmain.c"
void ftp_disconnect(void) 
{ 
  char *temp ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 214
  put_mes((Message )1, 0, *(host_name + host_number), (void *)0);
  }
#line 216
  if (! *(cfg_silent + host_number)) {
#line 216
    if (! opt_silent) {
      {
#line 217
      printf((char const   */* __restrict  */)"\n");
      }
    }
  }
  {
#line 220
  FtpQuit(ftp_buf);
#line 221
  free((void *)current_dir[0]);
#line 222
  free((void *)current_dir[1]);
#line 224
  tmp = cfgSectionNumberToName(host_number);
#line 224
  tmp___0 = dgettext("weex", "Disconnected: %s (%s)");
#line 224
  temp = str_dup_printf((char const   *)tmp___0, *(host_name + host_number), tmp);
#line 225
  log_write(temp);
#line 226
  free((void *)temp);
#line 228
  log_flush();
  }
#line 229
  return;
}
}
#line 238 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/ftpmain.c"
int ftp_login(void) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *temp ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;

  {
#line 240
  if ((unsigned long )*(login_name + host_number) == (unsigned long )((void *)0)) {
    {
#line 241
    tmp = dgettext("weex", "The login name is not configured.\n");
#line 241
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp);
#line 242
    exit(1);
    }
  }
#line 244
  if ((unsigned long )*(password + host_number) == (unsigned long )((void *)0)) {
    {
#line 247
    tmp___0 = dgettext("weex", "No password specified in configuration file for `%s\'. Asking ...\n");
#line 247
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
            *(host_name + host_number));
#line 248
    tmp___1 = dgettext("weex", "Password:");
#line 248
    tmp___2 = getpass((char const   *)tmp___1);
#line 248
    *(password + host_number) = str_dup((char const   *)tmp___2);
    }
  }
  {
#line 250
  tmp___6 = FtpLogin((char const   *)*(login_name + host_number), (char const   *)*(password + host_number),
                     ftp_buf);
  }
#line 250
  if (! tmp___6) {
    {
#line 253
    tmp___3 = dgettext("weex", "Login failed. Check your ID and password.\n\n");
#line 253
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___3);
#line 254
    tmp___4 = cfgSectionNumberToName(host_number);
#line 254
    tmp___5 = dgettext("weex", "Login failed: %s (%s)");
#line 254
    temp = str_dup_printf((char const   *)tmp___5, *(host_name + host_number), tmp___4);
#line 255
    log_write(temp);
#line 256
    free((void *)temp);
    }
#line 257
    return (-1);
  }
#line 259
  if (*(authorization_name + host_number)) {
    {
#line 260
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 260
      tmp___8 = FtpAuthorize((char const   *)*(authorization_name + host_number),
                             ftp_buf);
      }
#line 260
      if (tmp___8) {
#line 260
        goto while_break;
      }
      {
#line 261
      tmp___7 = dgettext("weex", "Authorization failed; try again\n\n");
#line 261
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___7);
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 264
  return (0);
}
}
#line 275 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/ftpmain.c"
void change_dir(char *path , LocalOrRemote side ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
#line 277
  if ((unsigned long )current_dir[side] == (unsigned long )((void *)0)) {
    {
#line 278
    current_dir[side] = str_dup((char const   *)path);
    }
  } else {
    {
#line 280
    tmp = strlen((char const   *)current_dir[side]);
#line 280
    tmp___0 = strlen((char const   *)path);
#line 280
    tmp___1 = str_realloc((void *)current_dir[side], (tmp + tmp___0) + 2UL);
#line 280
    current_dir[side] = (char *)tmp___1;
#line 281
    strcat((char */* __restrict  */)current_dir[side], (char const   */* __restrict  */)path);
#line 282
    strcat((char */* __restrict  */)current_dir[side], (char const   */* __restrict  */)"/");
    }
  }
#line 285
  if ((unsigned int )side == 0U) {
    {
#line 286
    change_dir_actually((LocalOrRemote )0);
    }
  }
#line 288
  return;
}
}
#line 297 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/ftpmain.c"
void up_dir(LocalOrRemote side ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 299
  tmp = strrchr((char const   *)current_dir[side], '/');
#line 299
  *tmp = (char )'\000';
#line 300
  tmp___0 = strrchr((char const   *)current_dir[side], '/');
#line 300
  *(tmp___0 + 1) = (char )'\000';
#line 301
  tmp___1 = strlen((char const   *)current_dir[side]);
#line 301
  tmp___2 = str_realloc((void *)current_dir[side], tmp___1 + 1UL);
#line 301
  current_dir[side] = (char *)tmp___2;
  }
#line 303
  if ((unsigned int )side == 0U) {
    {
#line 304
    change_dir_actually((LocalOrRemote )0);
    }
  }
#line 306
  return;
}
}
#line 309 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/ftpmain.c"
void change_dir_actually(LocalOrRemote side ) 
{ 
  char *temp ;
  size_t tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
  {
#line 313
  temp = str_dup((char const   *)current_dir[side]);
#line 314
  tmp___0 = strcmp((char const   *)temp, "/");
  }
#line 314
  if (tmp___0 != 0) {
    {
#line 315
    tmp = strlen((char const   *)temp);
#line 315
    *(temp + (tmp - 1UL)) = (char )'\000';
    }
  }
#line 317
  if ((unsigned int )side == 0U) {
    {
#line 317
    tmp___9 = chdir((char const   *)temp);
    }
#line 317
    if (tmp___9 == -1) {
#line 317
      goto _L;
    } else {
#line 317
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 317
  if ((unsigned int )side == 1U) {
    {
#line 317
    tmp___10 = FtpChdir((char const   *)temp, ftp_buf);
    }
#line 317
    if (tmp___10 == 0) {
      _L: /* CIL Label */ 
      {
#line 318
      free((void *)temp);
      }
#line 319
      if ((unsigned int )side == 0U) {
        {
#line 319
        tmp___1 = dgettext("weex", "local");
#line 319
        tmp___3 = tmp___1;
        }
      } else {
        {
#line 319
        tmp___2 = dgettext("weex", "remote");
#line 319
        tmp___3 = tmp___2;
        }
      }
      {
#line 319
      tmp___4 = dgettext("weex", "Cannot change %s current working directory to `%s\'.\n");
#line 319
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___4,
              tmp___3, current_dir[side]);
      }
#line 320
      if ((unsigned int )side == 0U) {
        {
#line 320
        tmp___5 = dgettext("weex", "local");
#line 320
        tmp___7 = tmp___5;
        }
      } else {
        {
#line 320
        tmp___6 = dgettext("weex", "remote");
#line 320
        tmp___7 = tmp___6;
        }
      }
      {
#line 320
      tmp___8 = dgettext("weex", "Changing %s current working directory failed: %s");
#line 320
      temp = str_dup_printf((char const   *)tmp___8, tmp___7, current_dir[side]);
#line 321
      log_write(temp);
#line 322
      free((void *)temp);
#line 323
      ftp_disconnect();
#line 324
      exit(1);
      }
    }
  }
  {
#line 326
  free((void *)temp);
  }
#line 327
  return;
}
}
#line 337 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/ftpmain.c"
static int dir_nest  =    1;
#line 335 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/ftpmain.c"
void ftp_recursive_search(void) 
{ 
  FileData *local_data ;
  FileData *remote_data ;
  int max_local_file ;
  int max_remote_file ;
  char *file_name ;
  int remote_num ;
  int trans_mode ;
  int i ;
  int j ;
  int opt_silent_bak ;
  char *temp ;
  char *put_temp ;
  char *mode_temp ;
  int dir_sent_file ;
  int dir_removed_file ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int success ;
  char *tmp___3 ;
  struct stat local_file_stat ;
  int tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *put_temp2 ;
  char *tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  char *tmp___19 ;

  {
  {
#line 338
  local_data = (FileData *)((void *)0);
#line 339
  remote_data = (FileData *)((void *)0);
#line 349
  mode_temp = (char *)((void *)0);
#line 350
  dir_sent_file = 0;
#line 351
  dir_removed_file = 0;
#line 353
  max_local_file = get_local_file_data(& local_data);
#line 354
  max_remote_file = get_remote_file_data_from_cache(& remote_data);
#line 356
  i = 0;
  }
  {
#line 356
  while (1) {
    while_continue: /* CIL Label */ ;
#line 356
    if (! (i < max_local_file)) {
#line 356
      goto while_break;
    }
#line 357
    if (*(conv_to_lower + host_number)) {
      {
#line 358
      file_name = str_tolower((local_data + i)->name);
      }
    } else {
#line 360
      file_name = (local_data + i)->name;
    }
    {
#line 362
    remote_num = get_equivalent_remote_number(file_name, max_remote_file, remote_data);
    }
#line 364
    if ((local_data + i)->isdir) {
      {
#line 365
      change_dir(file_name, (LocalOrRemote )0);
      }
#line 366
      if (remote_num == -1) {
#line 366
        tmp = 0;
      } else {
#line 366
        tmp = (remote_data + remote_num)->isdir;
      }
      {
#line 366
      ftp_enter(file_name, tmp, dir_nest, remote_num, & dir_removed_file);
#line 368
      dir_nest ++;
#line 369
      ftp_recursive_search();
#line 370
      dir_nest --;
#line 372
      put_mes((Message )3, dir_nest, current_dir[1], (void *)0);
#line 373
      up_dir((LocalOrRemote )0);
#line 374
      up_dir((LocalOrRemote )1);
      }
#line 375
      if (*(conv_to_lower + host_number)) {
        {
#line 376
        free((void *)file_name);
        }
      }
#line 378
      goto __Cont;
    } else
#line 379
    if (remote_num != -1) {
#line 379
      if ((remote_data + remote_num)->isdir) {
        {
#line 381
        remove_remote_dir(file_name, dir_nest, & dir_removed_file);
        }
      }
    }
#line 384
    if (opt_force) {
#line 384
      goto _L___0;
    } else
#line 384
    if (*(cfg_force + host_number)) {
#line 384
      goto _L___0;
    } else
#line 384
    if (remote_num == -1) {
#line 384
      goto _L___0;
    } else
#line 384
    if ((remote_data + remote_num)->isdir) {
#line 384
      goto _L___0;
    } else
#line 384
    if ((local_data + i)->date > (remote_data + remote_num)->date) {
#line 384
      goto _L___0;
    } else
#line 384
    if ((local_data + i)->date == (remote_data + remote_num)->date) {
#line 384
      if ((local_data + i)->time > (remote_data + remote_num)->time) {
        _L___0: /* CIL Label */ 
#line 389
        if (! *(overwrite_ok + host_number)) {
#line 389
          if (! *(rename_ok + host_number)) {
            {
#line 390
            ftp_remove(file_name, dir_nest, & dir_removed_file);
            }
          }
        }
        {
#line 392
        tmp___2 = is_ascii_file(file_name);
        }
#line 392
        if (tmp___2) {
#line 393
          trans_mode = 'A';
#line 394
          if (*(conv_to_lower + host_number)) {
            {
#line 394
            tmp___0 = strcmp((char const   *)(local_data + i)->name, (char const   *)file_name);
            }
#line 394
            if (tmp___0 != 0) {
              {
#line 395
              put_mes((Message )9, dir_nest, (local_data + i)->name, file_name, (void *)0);
              }
            } else {
              {
#line 397
              put_mes((Message )4, dir_nest, file_name, (void *)0);
              }
            }
          } else {
            {
#line 397
            put_mes((Message )4, dir_nest, file_name, (void *)0);
            }
          }
        } else {
#line 400
          trans_mode = 'I';
#line 401
          if (*(conv_to_lower + host_number)) {
            {
#line 401
            tmp___1 = strcmp((char const   *)(local_data + i)->name, (char const   *)file_name);
            }
#line 401
            if (tmp___1 != 0) {
              {
#line 402
              put_mes((Message )10, dir_nest, (local_data + i)->name, file_name, (void *)0);
              }
            } else {
              {
#line 404
              put_mes((Message )5, dir_nest, file_name, (void *)0);
              }
            }
          } else {
            {
#line 404
            put_mes((Message )5, dir_nest, file_name, (void *)0);
            }
          }
        }
#line 407
        if (! opt_test) {
#line 408
          success = 0;
#line 409
          opt_silent_bak = opt_silent;
#line 410
          if (*(cfg_silent + host_number)) {
#line 411
            opt_silent = 1;
          }
#line 413
          if (*(rename_ok + host_number)) {
            {
#line 414
            put_temp = str_concat((char const   *)current_dir[1], "weex.tmp", (void *)0);
            }
          } else {
            {
#line 416
            put_temp = str_concat((char const   *)current_dir[1], file_name, (void *)0);
            }
          }
#line 418
          j = 0;
          {
#line 418
          while (1) {
            while_continue___0: /* CIL Label */ ;
            {
#line 419
            tmp___11 = FtpPut((char const   *)(local_data + i)->name, (char const   *)put_temp,
                              (char )trans_mode, ftp_buf);
            }
#line 419
            if (tmp___11 == 1) {
#line 420
              if (*(log_detail_level + host_number) >= 3) {
                {
#line 421
                tmp___3 = dgettext("weex", "Sent: %s%s");
#line 421
                temp = str_dup_printf((char const   *)tmp___3, current_dir[1], file_name);
#line 422
                log_write(temp);
#line 423
                free((void *)temp);
                }
              }
              {
#line 425
              dir_sent_file ++;
#line 426
              update_cache(file_name, (local_data + i)->date, (local_data + i)->time);
#line 428
              save_cache();
#line 430
              tmp___5 = is_change_permission_dir();
              }
#line 430
              if (tmp___5) {
                {
#line 431
                mode_temp = str_dup((char const   *)*(change_permission + host_number));
                }
              } else {
                {
#line 432
                tmp___4 = is_preserve_permission_dir();
                }
#line 432
                if (tmp___4) {
                  {
#line 435
                  stat((char const   */* __restrict  */)file_name, (struct stat */* __restrict  */)(& local_file_stat));
#line 436
                  mode_temp = str_dup_printf("%o", local_file_stat.st_mode & 511U);
                  }
                }
              }
              {
#line 439
              tmp___9 = is_preserve_permission_dir();
              }
#line 439
              if (tmp___9) {
#line 439
                goto _L;
              } else {
                {
#line 439
                tmp___10 = is_change_permission_dir();
                }
#line 439
                if (tmp___10) {
                  _L: /* CIL Label */ 
                  {
#line 440
                  put_mes((Message )6, dir_nest, file_name, (void *)0);
#line 441
                  tmp___8 = FtpChmod((char const   *)put_temp, (char const   *)mode_temp,
                                     ftp_buf);
                  }
#line 441
                  if (tmp___8 == 0) {
                    {
#line 442
                    tmp___6 = dgettext("weex", "Cannot change the access permissions of `%s%s\' to `%s\'.\n");
#line 442
                    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___6,
                            current_dir[1], file_name, *(change_permission + host_number));
#line 443
                    tmp___7 = dgettext("weex", "Changing the access permissions failed: %s%s");
#line 443
                    temp = str_dup_printf((char const   *)tmp___7, current_dir[1],
                                          file_name);
#line 444
                    log_write(temp);
#line 445
                    free((void *)temp);
                    }
                  }
                  {
#line 447
                  free((void *)mode_temp);
                  }
                }
              }
#line 449
              success = 1;
#line 450
              goto while_break___0;
            }
#line 452
            if (j >= *(max_retry_to_send + host_number)) {
              {
#line 453
              tmp___12 = dgettext("weex", "Cannot send file `%s%s\'.\n");
#line 453
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___12,
                      current_dir[1], file_name);
#line 454
              tmp___13 = dgettext("weex", "Sending failed: %s%s");
#line 454
              temp = str_dup_printf((char const   *)tmp___13, current_dir[1], file_name);
#line 455
              log_write(temp);
#line 456
              free((void *)temp);
              }
#line 458
              goto while_break___0;
            }
            {
#line 460
            tmp___14 = dgettext("weex", "Retry to send: %s%s");
#line 460
            temp = str_dup_printf((char const   *)tmp___14, current_dir[1], file_name);
#line 461
            log_write(temp);
#line 462
            free((void *)temp);
#line 463
            tmp___15 = dgettext("weex", "Retrying...\n");
#line 463
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___15);
#line 418
            j ++;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
#line 465
          if (success) {
#line 465
            if (*(rename_ok + host_number)) {
#line 467
              if (! *(overwrite_ok + host_number)) {
                {
#line 468
                ftp_remove(file_name, dir_nest, & dir_removed_file);
                }
              }
              {
#line 470
              put_temp2 = str_concat((char const   *)current_dir[1], file_name, (void *)0);
#line 471
              tmp___18 = FtpRename((char const   *)put_temp, (char const   *)put_temp2,
                                   ftp_buf);
              }
#line 471
              if (! tmp___18) {
                {
#line 472
                tmp___16 = dgettext("weex", "Cannot rename temporary file to `%s%s\'.\n");
#line 472
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___16,
                        current_dir[1], file_name);
#line 473
                tmp___17 = dgettext("weex", "Sending failed: %s%s");
#line 473
                temp = str_dup_printf((char const   *)tmp___17, current_dir[1], file_name);
#line 474
                log_write(temp);
#line 475
                free((void *)temp);
                }
              }
              {
#line 477
              free((void *)put_temp2);
              }
            }
          }
          {
#line 479
          free((void *)put_temp);
#line 480
          opt_silent = opt_silent_bak;
          }
        }
      }
    }
#line 483
    if (*(conv_to_lower + host_number)) {
      {
#line 484
      free((void *)file_name);
      }
    }
    __Cont: /* CIL Label */ 
#line 356
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 487
  remove_files_on_remote_only(max_local_file, max_remote_file, local_data, remote_data,
                              dir_nest, & dir_removed_file);
#line 489
  free_file_data(local_data, max_local_file);
#line 490
  free_file_data(remote_data, max_remote_file);
#line 492
  total_sent_file += dir_sent_file;
#line 493
  total_removed_file += dir_removed_file;
  }
#line 495
  if (*(log_detail_level + host_number) >= 2) {
    {
#line 496
    tmp___19 = dgettext("weex", "%s : sent %d file(s), removed %d file(s)");
#line 496
    temp = str_dup_printf((char const   *)tmp___19, current_dir[1], dir_sent_file,
                          dir_removed_file);
#line 497
    log_write(temp);
#line 498
    free((void *)temp);
    }
  }
#line 500
  return;
}
}
#line 514 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/ftpmain.c"
void remove_files_on_remote_only(int max_local_file , int max_remote_file , FileData *local_data ,
                                 FileData *remote_data , int dir_nest___0 , int *dir_removed_file ) 
{ 
  int i ;
  int local_num ;
  char *file_name ;

  {
#line 520
  i = 0;
  {
#line 520
  while (1) {
    while_continue: /* CIL Label */ ;
#line 520
    if (! (i < max_remote_file)) {
#line 520
      goto while_break;
    }
    {
#line 521
    file_name = (remote_data + i)->name;
#line 522
    local_num = get_equivalent_local_number(file_name, max_local_file, local_data);
    }
#line 523
    if (local_num == -1) {
#line 524
      if ((remote_data + i)->isdir) {
        {
#line 525
        remove_remote_dir(file_name, dir_nest___0, dir_removed_file);
        }
      } else {
        {
#line 527
        ftp_remove(file_name, dir_nest___0, dir_removed_file);
        }
      }
    }
#line 520
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 531
  return;
}
}
#line 543 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/ftpmain.c"
int get_equivalent_remote_number(char *local_name , int max_remote_file , FileData *remote_data ) 
{ 
  int i ;
  int tmp ;

  {
#line 547
  i = 0;
  {
#line 547
  while (1) {
    while_continue: /* CIL Label */ ;
#line 547
    if (! (i < max_remote_file)) {
#line 547
      goto while_break;
    }
    {
#line 548
    tmp = strcmp((char const   *)local_name, (char const   *)(remote_data + i)->name);
    }
#line 548
    if (tmp == 0) {
#line 549
      return (i);
    }
#line 547
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 552
  return (-1);
}
}
#line 565 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/ftpmain.c"
int get_equivalent_local_number(char *remote_name , int max_local_file , FileData *local_data ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
#line 569
  i = 0;
  {
#line 569
  while (1) {
    while_continue: /* CIL Label */ ;
#line 569
    if (! (i < max_local_file)) {
#line 569
      goto while_break;
    }
#line 570
    if (*(conv_to_lower + host_number)) {
      {
#line 571
      tmp = strcasecmp((char const   *)remote_name, (char const   *)(local_data + i)->name);
      }
#line 571
      if (tmp == 0) {
#line 572
        return (i);
      }
    } else {
      {
#line 575
      tmp___0 = strcmp((char const   *)remote_name, (char const   *)(local_data + i)->name);
      }
#line 575
      if (tmp___0 == 0) {
#line 576
        return (i);
      }
    }
#line 569
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 580
  return (-1);
}
}
#line 594 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/ftpmain.c"
void ftp_enter(char *dir_name , int remote_isdir , int dir_nest___0 , int remote_num ,
               int *dir_removed_file ) 
{ 


  {
#line 596
  if (remote_num == -1) {
    {
#line 597
    put_mes((Message )8, dir_nest___0, current_dir[1], dir_name, "/", (void *)0);
#line 600
    ftp_mkdir(dir_name);
    }
  } else
#line 601
  if (! remote_isdir) {
    {
#line 602
    ftp_remove(dir_name, dir_nest___0, dir_removed_file);
#line 604
    put_mes((Message )8, dir_nest___0, current_dir[1], dir_name, "/", (void *)0);
#line 607
    ftp_mkdir(dir_name);
    }
  }
  {
#line 610
  put_mes((Message )2, dir_nest___0, current_dir[1], dir_name, "/", (void *)0);
#line 612
  update_cache(dir_name, 99999999L, 999999L);
#line 614
  change_dir(dir_name, (LocalOrRemote )1);
  }
#line 615
  return;
}
}
#line 626 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/ftpmain.c"
void ftp_remove(char *file_name , int dir_nest___0 , int *dir_removed_file ) 
{ 
  char *temp ;
  char *del_temp ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 631
  tmp = is_keep_remote_dir();
  }
#line 631
  if (tmp) {
#line 632
    return;
  }
  {
#line 634
  put_mes((Message )7, dir_nest___0, file_name, (void *)0);
  }
#line 635
  if (opt_test) {
#line 636
    return;
  }
  {
#line 638
  del_temp = str_concat((char const   *)current_dir[1], file_name, (void *)0);
#line 639
  tmp___3 = FtpDelete((char const   *)del_temp, ftp_buf);
  }
#line 639
  if (tmp___3 == 0) {
    {
#line 640
    tmp___0 = dgettext("weex", "Cannot remove remote file `%s%s\'.\n");
#line 640
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
            current_dir[1], file_name);
#line 641
    tmp___1 = dgettext("weex", "Removing failed: %s%s");
#line 641
    temp = str_dup_printf((char const   *)tmp___1, current_dir[1], file_name);
#line 642
    log_write(temp);
#line 643
    free((void *)temp);
    }
  } else {
#line 645
    if (*(log_detail_level + host_number) >= 3) {
      {
#line 646
      tmp___2 = dgettext("weex", "Removed: %s%s");
#line 646
      temp = str_dup_printf((char const   *)tmp___2, current_dir[1], file_name);
#line 647
      log_write(temp);
#line 648
      free((void *)temp);
      }
    }
    {
#line 650
    (*dir_removed_file) ++;
#line 651
    del_cache(file_name);
    }
  }
  {
#line 653
  free((void *)del_temp);
  }
#line 654
  return;
}
}
#line 665 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/ftpmain.c"
void remove_remote_dir(char *dir_name , int dir_nest___0 , int *dir_removed_file ) 
{ 
  FileData *remote_data ;
  int max_remote_file ;
  char *file_name ;
  int i ;
  char *rm_temp ;
  int tmp ;
  char *temp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 667
  remote_data = (FileData *)((void *)0);
#line 673
  put_mes((Message )2, dir_nest___0, current_dir[1], dir_name, "/", (void *)0);
#line 674
  change_dir(dir_name, (LocalOrRemote )1);
#line 676
  tmp = is_keep_remote_dir();
  }
#line 676
  if (tmp) {
    {
#line 677
    put_mes((Message )3, dir_nest___0, current_dir[1], (void *)0);
#line 678
    up_dir((LocalOrRemote )1);
    }
#line 679
    return;
  }
  {
#line 682
  dir_nest___0 ++;
#line 684
  max_remote_file = get_remote_file_data_from_cache(& remote_data);
#line 685
  i = 0;
  }
  {
#line 685
  while (1) {
    while_continue: /* CIL Label */ ;
#line 685
    if (! (i < max_remote_file)) {
#line 685
      goto while_break;
    }
#line 686
    file_name = (remote_data + i)->name;
#line 687
    if ((remote_data + i)->isdir) {
      {
#line 688
      remove_remote_dir(file_name, dir_nest___0, dir_removed_file);
      }
    } else {
      {
#line 690
      ftp_remove(file_name, dir_nest___0, dir_removed_file);
      }
    }
#line 685
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 694
  dir_nest___0 --;
#line 695
  put_mes((Message )3, dir_nest___0, current_dir[1], (void *)0);
#line 696
  up_dir((LocalOrRemote )1);
#line 697
  put_mes((Message )7, dir_nest___0, current_dir[1], dir_name, "/", (void *)0);
  }
#line 698
  if (opt_test) {
#line 699
    return;
  }
#line 701
  if (! is_cache_existent) {
    {
#line 702
    change_dir_actually((LocalOrRemote )1);
    }
  }
  {
#line 704
  rm_temp = str_concat((char const   *)current_dir[1], dir_name, (void *)0);
#line 705
  tmp___2 = FtpRmdir((char const   *)rm_temp, ftp_buf);
  }
#line 705
  if (tmp___2 == 0) {
    {
#line 708
    tmp___0 = dgettext("weex", "Cannot remove remote directory `%s%s/\'.\n");
#line 708
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
            current_dir[1], dir_name);
#line 709
    tmp___1 = dgettext("weex", "Removing failed: %s%s/");
#line 709
    temp = str_dup_printf((char const   *)tmp___1, current_dir[1], dir_name);
#line 710
    log_write(temp);
#line 711
    free((void *)temp);
    }
  } else {
    {
#line 713
    del_cache(dir_name);
#line 714
    del_cache_dir(dir_name);
    }
  }
  {
#line 716
  free((void *)rm_temp);
  }
#line 717
  return;
}
}
#line 726 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/ftpmain.c"
void ftp_mkdir(char *dir_name ) 
{ 
  char *temp ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 730
  if (opt_test) {
#line 731
    return;
  }
  {
#line 733
  temp = str_concat((char const   *)current_dir[1], dir_name, (void *)0);
#line 734
  tmp___1 = FtpMkdir((char const   *)temp, ftp_buf);
  }
#line 734
  if (tmp___1 == 0) {
    {
#line 735
    free((void *)temp);
#line 736
    tmp = dgettext("weex", "Cannot make remote directory `%s%s/\'.\n");
#line 736
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
            current_dir[1], dir_name);
#line 737
    tmp___0 = dgettext("weex", "Making directory failed: %s%s/");
#line 737
    temp = str_dup_printf((char const   *)tmp___0, current_dir[1], dir_name);
#line 738
    log_write(temp);
#line 739
    free((void *)temp);
#line 740
    ftp_disconnect();
#line 741
    exit(1);
    }
  }
  {
#line 743
  free((void *)temp);
  }
#line 744
  return;
}
}
#line 94 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/ftplib.h"
char *FtpLastResponse(netbuf *nControl ) ;
#line 96
int FtpOptions(int opt , long val , netbuf *nControl ) ;
#line 99
int FtpAccess(char const   *path , int typ , int mode , netbuf *nControl , netbuf **nData ) ;
#line 101
int FtpRead(void *buf , int max , netbuf *nData ) ;
#line 102
int FtpWrite(void *buf , int len , netbuf *nData ) ;
#line 103
int FtpClose(netbuf *nData ) ;
#line 104
int FtpClose2(netbuf *nData ) ;
#line 105
int FtpSite(char const   *cmd , netbuf *nControl ) ;
#line 106
int FtpSysType(char *buf , int max , netbuf *nControl ) ;
#line 109
int FtpCDUp(netbuf *nControl ) ;
#line 111
int FtpPwd(char *path , int max , netbuf *nControl ) ;
#line 112
int FtpNlst(char const   *outputfile , char const   *path , netbuf *nControl ) ;
#line 114
int FtpSize(char const   *path , int *size , char mode , netbuf *nControl ) ;
#line 116
int FtpGet(char const   *outputfile , char const   *path , char mode , netbuf *nControl ) ;
#line 360 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 468 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 58
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memccpy)(void * __restrict  __dest ,
                                                                                                  void const   * __restrict  __src ,
                                                                                                  int __c ,
                                                                                                  size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 123
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  *__addr ,
                                                                           socklen_t __len ) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getsockname)(int __fd ,
                                                                                  struct sockaddr * __restrict  __addr ,
                                                                                  socklen_t * __restrict  __len ) ;
#line 137
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 226
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void const   *__optval ,
                                                                                 socklen_t __optlen ) ;
#line 233
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) listen)(int __fd ,
                                                                             int __n ) ;
#line 243
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 261
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) shutdown)(int __fd ,
                                                                               int __how ) ;
#line 379 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 144 "/usr/include/netdb.h"
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 290
extern struct servent *getservbyname(char const   *__name , char const   *__proto ) ;
#line 34 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) in_addr_t ( __attribute__((__leaf__)) inet_addr)(char const   *__cp ) ;
#line 118 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/ftplib.c"
char *version  =    (char *)"ftplib Release 3.1 6/xx/98, copyright 1996, 1997, 1998 Thomas Pfau";
#line 121 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/ftplib.c"
int ftplib_debug  =    0;
#line 174 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/ftplib.c"
static int socket_wait(netbuf *ctl ) 
{ 
  fd_set fd ;
  fd_set *rfd ;
  fd_set *wfd ;
  struct timeval tv ;
  int rv ;
  int __d0 ;
  int __d1 ;
  int *tmp ;
  char *tmp___0 ;

  {
#line 176
  rfd = (fd_set *)((void *)0);
#line 176
  wfd = (fd_set *)((void *)0);
#line 178
  rv = 0;
#line 179
  if (ctl->dir == 0) {
#line 180
    return (1);
  } else
#line 179
  if ((unsigned long )ctl->idlecb == (unsigned long )((void *)0)) {
#line 180
    return (1);
  }
#line 181
  if (ctl->dir == 2) {
#line 182
    wfd = & fd;
  } else {
#line 184
    rfd = & fd;
  }
  {
#line 185
  while (1) {
    while_continue: /* CIL Label */ ;
#line 185
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& fd.__fds_bits[0]): "memory");
#line 185
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 186
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 188
    fd.__fds_bits[ctl->handle / (8 * (int )sizeof(__fd_mask ))] |= 1L << ctl->handle % (8 * (int )sizeof(__fd_mask ));
#line 189
    tv = ctl->idletime;
#line 190
    rv = select(ctl->handle + 1, (fd_set */* __restrict  */)rfd, (fd_set */* __restrict  */)wfd,
                (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
    }
#line 191
    if (rv == -1) {
      {
#line 193
      rv = 0;
#line 194
      tmp = __errno_location();
#line 194
      tmp___0 = strerror(*tmp);
#line 194
      strncpy((char */* __restrict  */)((ctl->ctrl)->response), (char const   */* __restrict  */)tmp___0,
              sizeof((ctl->ctrl)->response));
      }
#line 196
      goto while_break___0;
    } else
#line 198
    if (rv > 0) {
#line 200
      rv = 1;
#line 201
      goto while_break___0;
    }
    {
#line 186
    rv = (*(ctl->idlecb))(ctl, ctl->xfered, ctl->idlearg);
    }
#line 186
    if (! rv) {
#line 186
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 205
  return (rv);
}
}
#line 213 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/ftplib.c"
static int readline(char *buf , int max , netbuf *ctl ) 
{ 
  int x ;
  int retval ;
  char *end ;
  char *bp ;
  int eof ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  ssize_t tmp___5 ;

  {
#line 215
  retval = 0;
#line 216
  bp = buf;
#line 217
  eof = 0;
#line 219
  if (ctl->dir != 0) {
#line 219
    if (ctl->dir != 1) {
#line 220
      return (-1);
    }
  }
#line 221
  if (max == 0) {
#line 222
    return (0);
  }
  {
#line 223
  while (1) {
    while_continue: /* CIL Label */ ;
#line 225
    if (ctl->cavail > 0) {
#line 227
      if (max >= ctl->cavail) {
#line 227
        x = ctl->cavail;
      } else {
#line 227
        x = max - 1;
      }
      {
#line 228
      tmp = memccpy((void */* __restrict  */)bp, (void const   */* __restrict  */)ctl->cget,
                    '\n', (size_t )x);
#line 228
      end = (char *)tmp;
      }
#line 229
      if ((unsigned long )end != (unsigned long )((void *)0)) {
#line 230
        x = (int )(end - bp);
      }
#line 231
      retval += x;
#line 232
      bp += x;
#line 233
      *bp = (char )'\000';
#line 234
      max -= x;
#line 235
      ctl->cget += x;
#line 236
      ctl->cavail -= x;
#line 237
      if ((unsigned long )end != (unsigned long )((void *)0)) {
        {
#line 239
        bp -= 2;
#line 240
        tmp___2 = strcmp((char const   *)bp, "\r\n");
        }
#line 240
        if (tmp___2 == 0) {
#line 242
          tmp___0 = bp;
#line 242
          bp ++;
#line 242
          *tmp___0 = (char )'\n';
#line 243
          tmp___1 = bp;
#line 243
          bp ++;
#line 243
          *tmp___1 = (char )'\000';
#line 244
          retval --;
        }
#line 246
        goto while_break;
      }
    }
#line 249
    if (max == 1) {
#line 251
      *buf = (char )'\000';
#line 252
      goto while_break;
    }
#line 254
    if ((unsigned long )ctl->cput == (unsigned long )ctl->cget) {
#line 256
      tmp___3 = ctl->buf;
#line 256
      ctl->cget = tmp___3;
#line 256
      ctl->cput = tmp___3;
#line 257
      ctl->cavail = 0;
#line 258
      ctl->cleft = 8192;
    }
#line 260
    if (eof) {
#line 262
      if (retval == 0) {
#line 263
        retval = -1;
      }
#line 264
      goto while_break;
    }
    {
#line 266
    tmp___4 = socket_wait(ctl);
    }
#line 266
    if (! tmp___4) {
#line 267
      return (retval);
    }
    {
#line 268
    tmp___5 = read(ctl->handle, (void *)ctl->cput, (size_t )ctl->cleft);
#line 268
    x = (int )tmp___5;
    }
#line 268
    if (x == -1) {
#line 271
      retval = -1;
#line 272
      goto while_break;
    }
#line 274
    if (x == 0) {
#line 275
      eof = 1;
    }
#line 276
    ctl->cleft -= x;
#line 277
    ctl->cavail += x;
#line 278
    ctl->cput += x;
  }
  while_break: /* CIL Label */ ;
  }
#line 281
  return (retval);
}
}
#line 289 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/ftplib.c"
static int writeline(char *buf , int len , netbuf *nData ) 
{ 
  int x ;
  int nb ;
  int w ;
  char *ubp ;
  char *nbp ;
  char lc ;
  int tmp ;
  ssize_t tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  ssize_t tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  ssize_t tmp___9 ;
  int *tmp___10 ;

  {
#line 291
  nb = 0;
#line 292
  ubp = buf;
#line 293
  lc = (char)0;
#line 295
  if (nData->dir != 2) {
#line 296
    return (-1);
  }
#line 297
  nbp = nData->buf;
#line 298
  x = 0;
  {
#line 298
  while (1) {
    while_continue: /* CIL Label */ ;
#line 298
    if (! (x < len)) {
#line 298
      goto while_break;
    }
#line 300
    if ((int )*ubp == 10) {
#line 300
      if ((int )lc != 13) {
#line 302
        if (nb == 8192) {
          {
#line 304
          tmp = socket_wait(nData);
          }
#line 304
          if (! tmp) {
#line 305
            return (x);
          }
          {
#line 306
          tmp___0 = write(nData->handle, (void const   *)nbp, (size_t )8192);
#line 306
          w = (int )tmp___0;
          }
#line 307
          if (w != 8192) {
            {
#line 309
            tmp___1 = __errno_location();
#line 309
            printf((char const   */* __restrict  */)"net_write(1) returned %d, errno = %d\n",
                   w, *tmp___1);
            }
#line 310
            return (-1);
          }
#line 312
          nb = 0;
        }
#line 314
        tmp___2 = nb;
#line 314
        nb ++;
#line 314
        *(nbp + tmp___2) = (char )'\r';
      }
    }
#line 316
    if (nb == 8192) {
      {
#line 318
      tmp___3 = socket_wait(nData);
      }
#line 318
      if (! tmp___3) {
#line 319
        return (x);
      }
      {
#line 320
      tmp___4 = write(nData->handle, (void const   *)nbp, (size_t )8192);
#line 320
      w = (int )tmp___4;
      }
#line 321
      if (w != 8192) {
        {
#line 323
        tmp___5 = __errno_location();
#line 323
        printf((char const   */* __restrict  */)"net_write(2) returned %d, errno = %d\n",
               w, *tmp___5);
        }
#line 324
        return (-1);
      }
#line 326
      nb = 0;
    }
#line 328
    tmp___6 = nb;
#line 328
    nb ++;
#line 328
    tmp___7 = ubp;
#line 328
    ubp ++;
#line 328
    lc = *tmp___7;
#line 328
    *(nbp + tmp___6) = lc;
#line 298
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 330
  if (nb) {
    {
#line 332
    tmp___8 = socket_wait(nData);
    }
#line 332
    if (! tmp___8) {
#line 333
      return (x);
    }
    {
#line 334
    tmp___9 = write(nData->handle, (void const   *)nbp, (size_t )nb);
#line 334
    w = (int )tmp___9;
    }
#line 335
    if (w != nb) {
      {
#line 337
      tmp___10 = __errno_location();
#line 337
      printf((char const   */* __restrict  */)"net_write(3) returned %d, errno = %d\n",
             w, *tmp___10);
      }
#line 338
      return (-1);
    }
  }
#line 341
  return (len);
}
}
#line 350 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/ftplib.c"
static int readresp(char c , netbuf *nControl ) 
{ 
  char match[5] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 353
  tmp = readline(nControl->response, 256, nControl);
  }
#line 353
  if (tmp == -1) {
#line 356
    return (0);
  }
#line 358
  if (ftplib_debug > 1) {
    {
#line 359
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
            nControl->response);
    }
  }
#line 360
  if ((int )nControl->response[3] == 45) {
    {
#line 362
    strncpy((char */* __restrict  */)(match), (char const   */* __restrict  */)(nControl->response),
            (size_t )3);
#line 363
    match[3] = (char )' ';
#line 364
    match[4] = (char )'\000';
    }
    {
#line 365
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 367
      tmp___0 = readline(nControl->response, 256, nControl);
      }
#line 367
      if (tmp___0 == -1) {
#line 370
        return (0);
      }
#line 372
      if (ftplib_debug > 1) {
        {
#line 373
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
                nControl->response);
        }
      }
      {
#line 365
      tmp___1 = strncmp((char const   *)(nControl->response), (char const   *)(match),
                        (size_t )4);
      }
#line 365
      if (! tmp___1) {
#line 365
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 377
  if ((int )nControl->response[0] == (int )c) {
#line 378
    return (1);
  }
#line 379
  return (0);
}
}
#line 385 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/ftplib.c"
void FtpInit(void) 
{ 


  {
#line 395
  return;
}
}
#line 400 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/ftplib.c"
char *FtpLastResponse(netbuf *nControl ) 
{ 


  {
#line 402
  if (nControl) {
#line 402
    if (nControl->dir == 0) {
#line 403
      return (nControl->response);
    }
  }
#line 404
  return ((char *)((void *)0));
}
}
#line 412 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/ftplib.c"
int FtpConnect(char const   *host , netbuf **nControl ) 
{ 
  int sControl ;
  struct sockaddr_in sin ;
  struct hostent *phe ;
  struct servent *pse ;
  int on ;
  netbuf *ctrl ;
  char *lhost ;
  char *pnum ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  __suseconds_t tmp___7 ;
  int tmp___8 ;

  {
  {
#line 418
  on = 1;
#line 423
  memset((void *)(& sin), 0, sizeof(sin));
#line 424
  sin.sin_family = (sa_family_t )2;
#line 425
  tmp = strncmp(host, "ftp://", (size_t )6);
  }
#line 425
  if (tmp == 0) {
    {
#line 426
    lhost = strdup(host + 6);
    }
  } else {
    {
#line 428
    lhost = strdup(host);
    }
  }
  {
#line 430
  pnum = strchr((char const   *)lhost, ':');
  }
#line 431
  if ((unsigned long )pnum == (unsigned long )((void *)0)) {
    {
#line 436
    pse = getservbyname("ftp", "tcp");
    }
#line 436
    if ((unsigned long )pse == (unsigned long )((void *)0)) {
#line 439
      return (0);
    }
#line 441
    sin.sin_port = (in_port_t )pse->s_port;
  } else {
    {
#line 446
    tmp___0 = pnum;
#line 446
    pnum ++;
#line 446
    *tmp___0 = (char )'\000';
#line 447
    tmp___2 = __ctype_b_loc();
    }
#line 447
    if ((int const   )*(*tmp___2 + (int )*pnum) & 2048) {
      {
#line 448
      tmp___1 = atoi((char const   *)pnum);
#line 448
      sin.sin_port = htons((uint16_t )tmp___1);
      }
    } else {
      {
#line 451
      pse = getservbyname((char const   *)pnum, "tcp");
      }
#line 451
      if ((unsigned long )pse == (unsigned long )((void *)0)) {
#line 454
        return (0);
      }
#line 456
      sin.sin_port = (in_port_t )pse->s_port;
    }
  }
  {
#line 459
  sin.sin_addr.s_addr = inet_addr((char const   *)lhost);
  }
#line 459
  if (sin.sin_addr.s_addr == 4294967295U) {
    {
#line 461
    phe = gethostbyname((char const   *)lhost);
    }
#line 461
    if ((unsigned long )phe == (unsigned long )((void *)0)) {
#line 464
      return (0);
    }
    {
#line 466
    memcpy((void */* __restrict  */)((char *)(& sin.sin_addr)), (void const   */* __restrict  */)*(phe->h_addr_list + 0),
           (size_t )phe->h_length);
    }
  }
  {
#line 468
  free((void *)lhost);
#line 469
  sControl = socket(2, 1, 6);
  }
#line 470
  if (sControl == -1) {
#line 473
    return (0);
  }
  {
#line 475
  tmp___3 = setsockopt(sControl, 1, 2, (void const   *)((void *)(& on)), (socklen_t )sizeof(on));
  }
#line 475
  if (tmp___3 == -1) {
    {
#line 479
    close(sControl);
    }
#line 480
    return (0);
  }
  {
#line 482
  tmp___4 = connect(sControl, (struct sockaddr  const  *)((struct sockaddr *)(& sin)),
                    (socklen_t )sizeof(sin));
  }
#line 482
  if (tmp___4 == -1) {
    {
#line 485
    close(sControl);
    }
#line 486
    return (0);
  }
  {
#line 488
  tmp___5 = calloc((size_t )1, sizeof(netbuf ));
#line 488
  ctrl = (netbuf *)tmp___5;
  }
#line 489
  if ((unsigned long )ctrl == (unsigned long )((void *)0)) {
    {
#line 492
    close(sControl);
    }
#line 493
    return (0);
  }
  {
#line 495
  tmp___6 = malloc((size_t )8192);
#line 495
  ctrl->buf = (char *)tmp___6;
  }
#line 496
  if ((unsigned long )ctrl->buf == (unsigned long )((void *)0)) {
    {
#line 499
    close(sControl);
#line 500
    free((void *)ctrl);
    }
#line 501
    return (0);
  }
#line 503
  ctrl->handle = sControl;
#line 504
  ctrl->dir = 0;
#line 505
  ctrl->ctrl = (netbuf *)((void *)0);
#line 506
  if (*(ftp_passive + host_number)) {
#line 507
    ctrl->cmode = 1;
  } else {
#line 509
    ctrl->cmode = 2;
  }
  {
#line 511
  ctrl->idlecb = (int (*)(netbuf *nControl , int xfered , void *arg ))((void *)0);
#line 512
  tmp___7 = (__suseconds_t )0;
#line 512
  ctrl->idletime.tv_usec = tmp___7;
#line 512
  ctrl->idletime.tv_sec = tmp___7;
#line 513
  ctrl->idlearg = (void *)0;
#line 514
  ctrl->xfered = 0;
#line 515
  ctrl->xfered1 = 0;
#line 516
  ctrl->cbbytes = 0;
#line 517
  tmp___8 = readresp((char )'2', ctrl);
  }
#line 517
  if (tmp___8 == 0) {
    {
#line 519
    close(sControl);
#line 520
    free((void *)ctrl->buf);
#line 521
    free((void *)ctrl);
    }
#line 522
    return (0);
  }
#line 524
  *nControl = ctrl;
#line 525
  return (1);
}
}
#line 533 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/ftplib.c"
int FtpOptions(int opt , long val , netbuf *nControl ) 
{ 
  int v ;
  int rv ;

  {
#line 535
  rv = 0;
  {
#line 538
  if (opt == 1) {
#line 538
    goto case_1;
  }
#line 546
  if (opt == 2) {
#line 546
    goto case_2;
  }
#line 550
  if (opt == 3) {
#line 550
    goto case_3;
  }
#line 556
  if (opt == 4) {
#line 556
    goto case_4;
  }
#line 560
  if (opt == 5) {
#line 560
    goto case_5;
  }
#line 536
  goto switch_break;
  case_1: /* CIL Label */ 
#line 539
  v = (int )val;
#line 540
  if (v == 1) {
#line 542
    nControl->cmode = v;
#line 543
    rv = 1;
  } else
#line 540
  if (v == 2) {
#line 542
    nControl->cmode = v;
#line 543
    rv = 1;
  }
#line 545
  goto switch_break;
  case_2: /* CIL Label */ 
#line 547
  nControl->idlecb = (int (*)(netbuf *nControl , int xfered , void *arg ))val;
#line 548
  rv = 1;
#line 549
  goto switch_break;
  case_3: /* CIL Label */ 
#line 551
  v = (int )val;
#line 552
  rv = 1;
#line 553
  nControl->idletime.tv_sec = (__time_t )(v / 1000);
#line 554
  nControl->idletime.tv_usec = (__suseconds_t )((v % 1000) * 1000);
#line 555
  goto switch_break;
  case_4: /* CIL Label */ 
#line 557
  rv = 1;
#line 558
  nControl->idlearg = (void *)val;
#line 559
  goto switch_break;
  case_5: /* CIL Label */ 
#line 561
  rv = 1;
#line 562
  nControl->cbbytes = (int )val;
#line 563
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 565
  return (rv);
}
}
#line 573 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/ftplib.c"
static int FtpSendCmd(char const   *cmd , char expresp , netbuf *nControl ) 
{ 
  char buf[256] ;
  size_t tmp ;
  size_t tmp___0 ;
  ssize_t tmp___1 ;
  int tmp___2 ;

  {
#line 576
  if (nControl->dir != 0) {
#line 577
    return (0);
  }
#line 578
  if (ftplib_debug > 2) {
    {
#line 579
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
            cmd);
    }
  }
  {
#line 580
  tmp = strlen(cmd);
  }
#line 580
  if (tmp + 3UL > sizeof(buf)) {
#line 581
    return (0);
  }
  {
#line 582
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%s\r\n",
          cmd);
#line 583
  tmp___0 = strlen((char const   *)(buf));
#line 583
  tmp___1 = write(nControl->handle, (void const   *)(buf), tmp___0);
  }
#line 583
  if (tmp___1 <= 0L) {
#line 586
    return (0);
  }
  {
#line 588
  tmp___2 = readresp(expresp, nControl);
  }
#line 588
  return (tmp___2);
}
}
#line 596 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/ftplib.c"
int FtpLogin(char const   *user , char const   *pass , netbuf *nControl ) 
{ 
  char tempbuf[64] ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 600
  tmp = strlen(user);
  }
#line 600
  if (tmp + 7UL > sizeof(tempbuf)) {
#line 602
    return (0);
  } else {
    {
#line 600
    tmp___0 = strlen(pass);
    }
#line 600
    if (tmp___0 + 7UL > sizeof(tempbuf)) {
#line 602
      return (0);
    }
  }
  {
#line 603
  sprintf((char */* __restrict  */)(tempbuf), (char const   */* __restrict  */)"USER %s",
          user);
#line 604
  tmp___1 = FtpSendCmd((char const   *)(tempbuf), (char )'3', nControl);
  }
#line 604
  if (! tmp___1) {
#line 606
    if ((int )nControl->response[0] == 50) {
#line 607
      return (1);
    }
#line 608
    return (0);
  }
  {
#line 610
  sprintf((char */* __restrict  */)(tempbuf), (char const   */* __restrict  */)"PASS %s",
          pass);
#line 611
  tmp___2 = FtpSendCmd((char const   *)(tempbuf), (char )'2', nControl);
  }
#line 611
  return (tmp___2);
}
}
#line 618 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/ftplib.c"
int FtpAuthorize(char const   *user , netbuf *nControl ) 
{ 
  char tempbuf[64] ;
  char respbuf[32] ;
  char *newline ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 623
  tmp = strlen(user);
  }
#line 623
  if (tmp + 12UL > sizeof(tempbuf)) {
#line 624
    return (0);
  }
  {
#line 625
  sprintf((char */* __restrict  */)(tempbuf), (char const   */* __restrict  */)"AUTHORIZE %s",
          user);
#line 626
  tmp___0 = FtpSendCmd((char const   *)(tempbuf), (char )'3', nControl);
  }
#line 626
  if (! tmp___0) {
#line 628
    if ((int )nControl->response[0] == 50) {
#line 629
      return (1);
    }
#line 630
    return (0);
  }
  {
#line 632
  fputs((char const   */* __restrict  */)(nControl->response), (FILE */* __restrict  */)stderr);
#line 633
  respbuf[0] = (char )'\000';
#line 634
  fgets((char */* __restrict  */)(respbuf), (int )sizeof(respbuf), (FILE */* __restrict  */)stdin);
#line 635
  newline = strchr((char const   *)(respbuf), '\n');
  }
#line 636
  if (newline) {
#line 636
    *newline = (char )'\000';
  }
  {
#line 637
  sprintf((char */* __restrict  */)(tempbuf), (char const   */* __restrict  */)"RESPONSE %s",
          respbuf);
#line 638
  tmp___1 = FtpSendCmd((char const   *)(tempbuf), (char )'2', nControl);
  }
#line 638
  if (! tmp___1) {
    {
#line 639
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
            nControl->response);
    }
#line 640
    return (0);
  }
#line 642
  return (1);
}
}
#line 650 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/ftplib.c"
static int FtpOpenPort(netbuf *nControl , netbuf **nData , int mode , int dir ) 
{ 
  int sData ;
  union __anonunion_sin_47 sin ;
  struct linger lng ;
  unsigned int l ;
  int on ;
  netbuf *ctrl ;
  char *cp ;
  unsigned int v[6] ;
  char buf[256] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;
  char *tmp___9 ;
  void *tmp___10 ;

  {
#line 657
  lng.l_onoff = 0;
#line 657
  lng.l_linger = 0;
#line 659
  on = 1;
#line 665
  if (nControl->dir != 0) {
#line 666
    return (-1);
  }
#line 667
  if (dir != 1) {
#line 667
    if (dir != 2) {
      {
#line 669
      sprintf((char */* __restrict  */)(nControl->response), (char const   */* __restrict  */)"Invalid direction %d\n",
              dir);
      }
#line 670
      return (-1);
    }
  }
#line 672
  if (mode != 65) {
#line 672
    if (mode != 73) {
      {
#line 674
      sprintf((char */* __restrict  */)(nControl->response), (char const   */* __restrict  */)"Invalid mode %c\n",
              mode);
      }
#line 675
      return (-1);
    }
  }
#line 677
  l = (unsigned int )sizeof(sin);
#line 678
  if (nControl->cmode == 1) {
    {
#line 680
    memset((void *)(& sin), 0, (size_t )l);
#line 681
    sin.in.sin_family = (sa_family_t )2;
#line 682
    tmp = FtpSendCmd("PASV", (char )'2', nControl);
    }
#line 682
    if (! tmp) {
#line 683
      return (-1);
    }
    {
#line 684
    cp = strchr((char const   *)(nControl->response), '(');
    }
#line 685
    if ((unsigned long )cp == (unsigned long )((void *)0)) {
#line 686
      return (-1);
    }
    {
#line 687
    cp ++;
#line 688
    sscanf((char const   */* __restrict  */)cp, (char const   */* __restrict  */)"%u,%u,%u,%u,%u,%u",
           & v[2], & v[3], & v[4], & v[5], & v[0], & v[1]);
#line 689
    sin.sa.sa_data[2] = (char )v[2];
#line 690
    sin.sa.sa_data[3] = (char )v[3];
#line 691
    sin.sa.sa_data[4] = (char )v[4];
#line 692
    sin.sa.sa_data[5] = (char )v[5];
#line 693
    sin.sa.sa_data[0] = (char )v[0];
#line 694
    sin.sa.sa_data[1] = (char )v[1];
    }
  } else {
    {
#line 698
    tmp___0 = getsockname(nControl->handle, (struct sockaddr */* __restrict  */)(& sin.sa),
                          (socklen_t */* __restrict  */)(& l));
    }
#line 698
    if (tmp___0 < 0) {
#line 701
      return (0);
    }
  }
  {
#line 704
  sData = socket(2, 1, 6);
  }
#line 705
  if (sData == -1) {
#line 708
    return (-1);
  }
  {
#line 710
  tmp___1 = setsockopt(sData, 1, 2, (void const   *)((void *)(& on)), (socklen_t )sizeof(on));
  }
#line 710
  if (tmp___1 == -1) {
    {
#line 714
    close(sData);
    }
#line 715
    return (-1);
  }
  {
#line 717
  tmp___2 = setsockopt(sData, 1, 13, (void const   *)((void *)(& lng)), (socklen_t )sizeof(lng));
  }
#line 717
  if (tmp___2 == -1) {
    {
#line 721
    close(sData);
    }
#line 722
    return (-1);
  }
#line 724
  if (nControl->cmode == 1) {
    {
#line 726
    tmp___3 = connect(sData, (struct sockaddr  const  *)(& sin.sa), (socklen_t )sizeof(sin.sa));
    }
#line 726
    if (tmp___3 == -1) {
      {
#line 729
      close(sData);
      }
#line 730
      return (-1);
    }
  } else {
    {
#line 735
    sin.in.sin_port = (in_port_t )0;
#line 736
    tmp___4 = bind(sData, (struct sockaddr  const  *)(& sin.sa), (socklen_t )sizeof(sin));
    }
#line 736
    if (tmp___4 == -1) {
      {
#line 739
      close(sData);
      }
#line 740
      return (0);
    }
    {
#line 742
    tmp___5 = listen(sData, 1);
    }
#line 742
    if (tmp___5 < 0) {
      {
#line 745
      close(sData);
      }
#line 746
      return (0);
    }
    {
#line 748
    tmp___6 = getsockname(sData, (struct sockaddr */* __restrict  */)(& sin.sa), (socklen_t */* __restrict  */)(& l));
    }
#line 748
    if (tmp___6 < 0) {
#line 749
      return (0);
    }
    {
#line 750
    sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"PORT %d,%d,%d,%d,%d,%d",
            (int )((unsigned char )sin.sa.sa_data[2]), (int )((unsigned char )sin.sa.sa_data[3]),
            (int )((unsigned char )sin.sa.sa_data[4]), (int )((unsigned char )sin.sa.sa_data[5]),
            (int )((unsigned char )sin.sa.sa_data[0]), (int )((unsigned char )sin.sa.sa_data[1]));
#line 757
    tmp___7 = FtpSendCmd((char const   *)(buf), (char )'2', nControl);
    }
#line 757
    if (! tmp___7) {
      {
#line 759
      close(sData);
      }
#line 760
      return (0);
    }
  }
  {
#line 763
  tmp___8 = calloc((size_t )1, sizeof(netbuf ));
#line 763
  ctrl = (netbuf *)tmp___8;
  }
#line 764
  if ((unsigned long )ctrl == (unsigned long )((void *)0)) {
    {
#line 767
    close(sData);
    }
#line 768
    return (-1);
  }
#line 770
  if (mode == 65) {
    {
#line 770
    tmp___10 = malloc((size_t )8192);
#line 770
    tmp___9 = (char *)tmp___10;
#line 770
    ctrl->buf = tmp___9;
    }
#line 770
    if ((unsigned long )tmp___9 == (unsigned long )((void *)0)) {
      {
#line 773
      close(sData);
#line 774
      free((void *)ctrl);
      }
#line 775
      return (-1);
    }
  }
#line 777
  ctrl->handle = sData;
#line 778
  ctrl->dir = dir;
#line 779
  if (nControl->cmode == 1) {
#line 779
    ctrl->ctrl = nControl;
  } else {
#line 779
    ctrl->ctrl = (netbuf *)((void *)0);
  }
#line 780
  ctrl->idletime = nControl->idletime;
#line 781
  ctrl->idlearg = nControl->idlearg;
#line 782
  ctrl->xfered = 0;
#line 783
  ctrl->xfered1 = 0;
#line 784
  ctrl->cbbytes = nControl->cbbytes;
#line 785
  if (ctrl->idletime.tv_sec | ctrl->idletime.tv_usec) {
#line 786
    ctrl->idlecb = nControl->idlecb;
  } else {
#line 788
    ctrl->idlecb = (int (*)(netbuf *nControl , int xfered , void *arg ))((void *)0);
  }
#line 789
  *nData = ctrl;
#line 790
  return (1);
}
}
#line 798 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/ftplib.c"
static int FtpAcceptConnection(netbuf *nData , netbuf *nControl ) 
{ 
  int sData ;
  struct sockaddr addr ;
  unsigned int l ;
  int i ;
  struct timeval tv ;
  fd_set mask ;
  int rv ;
  int __d0 ;
  int __d1 ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;

  {
#line 806
  rv = 0;
  {
#line 808
  while (1) {
    while_continue: /* CIL Label */ ;
#line 808
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& mask.__fds_bits[0]): "memory");
#line 808
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 809
  mask.__fds_bits[nControl->handle / (8 * (int )sizeof(__fd_mask ))] |= 1L << nControl->handle % (8 * (int )sizeof(__fd_mask ));
#line 810
  mask.__fds_bits[nData->handle / (8 * (int )sizeof(__fd_mask ))] |= 1L << nData->handle % (8 * (int )sizeof(__fd_mask ));
#line 811
  tv.tv_usec = (__suseconds_t )0;
#line 812
  tv.tv_sec = (__time_t )30;
#line 813
  i = nControl->handle;
#line 814
  if (i < nData->handle) {
#line 815
    i = nData->handle;
  }
  {
#line 816
  i = select(i + 1, (fd_set */* __restrict  */)(& mask), (fd_set */* __restrict  */)((void *)0),
             (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
  }
#line 817
  if (i == -1) {
    {
#line 819
    tmp = __errno_location();
#line 819
    tmp___0 = strerror(*tmp);
#line 819
    strncpy((char */* __restrict  */)(nControl->response), (char const   */* __restrict  */)tmp___0,
            sizeof(nControl->response));
#line 821
    close(nData->handle);
#line 822
    nData->handle = 0;
#line 823
    rv = 0;
    }
  } else
#line 825
  if (i == 0) {
    {
#line 827
    strcpy((char */* __restrict  */)(nControl->response), (char const   */* __restrict  */)"timed out waiting for connection");
#line 828
    close(nData->handle);
#line 829
    nData->handle = 0;
#line 830
    rv = 0;
    }
  } else
#line 834
  if ((mask.__fds_bits[nData->handle / (8 * (int )sizeof(__fd_mask ))] & (1L << nData->handle % (8 * (int )sizeof(__fd_mask )))) != 0L) {
    {
#line 836
    l = (unsigned int )sizeof(addr);
#line 837
    sData = accept(nData->handle, (struct sockaddr */* __restrict  */)(& addr), (socklen_t */* __restrict  */)(& l));
#line 838
    tmp___1 = __errno_location();
#line 838
    i = *tmp___1;
#line 839
    close(nData->handle);
    }
#line 840
    if (sData > 0) {
#line 842
      rv = 1;
#line 843
      nData->handle = sData;
#line 844
      nData->ctrl = nControl;
    } else {
      {
#line 848
      tmp___2 = strerror(i);
#line 848
      strncpy((char */* __restrict  */)(nControl->response), (char const   */* __restrict  */)tmp___2,
              sizeof(nControl->response));
#line 850
      nData->handle = 0;
#line 851
      rv = 0;
      }
    }
  } else
#line 854
  if ((mask.__fds_bits[nControl->handle / (8 * (int )sizeof(__fd_mask ))] & (1L << nControl->handle % (8 * (int )sizeof(__fd_mask )))) != 0L) {
    {
#line 856
    close(nData->handle);
#line 857
    nData->handle = 0;
#line 858
    readresp((char )'2', nControl);
#line 859
    rv = 0;
    }
  }
#line 862
  return (rv);
}
}
#line 870 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/ftplib.c"
int FtpAccess(char const   *path , int typ , int mode , netbuf *nControl , netbuf **nData ) 
{ 
  char buf[256] ;
  int dir ;
  int tmp ;
  int i ;
  size_t tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 875
  if ((unsigned long )path == (unsigned long )((void *)0)) {
#line 875
    if (typ == 4) {
      {
#line 878
      sprintf((char */* __restrict  */)(nControl->response), (char const   */* __restrict  */)"Missing path argument for file transfer\n");
      }
#line 880
      return (0);
    } else
#line 875
    if (typ == 3) {
      {
#line 878
      sprintf((char */* __restrict  */)(nControl->response), (char const   */* __restrict  */)"Missing path argument for file transfer\n");
      }
#line 880
      return (0);
    }
  }
  {
#line 882
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"TYPE %c",
          mode);
#line 883
  tmp = FtpSendCmd((char const   *)(buf), (char )'2', nControl);
  }
#line 883
  if (! tmp) {
#line 884
    return (0);
  }
  {
#line 887
  if (typ == 1) {
#line 887
    goto case_1;
  }
#line 891
  if (typ == 2) {
#line 891
    goto case_2;
  }
#line 895
  if (typ == 3) {
#line 895
    goto case_3;
  }
#line 899
  if (typ == 4) {
#line 899
    goto case_4;
  }
#line 903
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 888
  strcpy((char */* __restrict  */)(buf), (char const   */* __restrict  */)"NLST");
#line 889
  dir = 1;
  }
#line 890
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 892
  strcpy((char */* __restrict  */)(buf), (char const   */* __restrict  */)"LIST");
#line 893
  dir = 1;
  }
#line 894
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 896
  strcpy((char */* __restrict  */)(buf), (char const   */* __restrict  */)"RETR");
#line 897
  dir = 1;
  }
#line 898
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 900
  strcpy((char */* __restrict  */)(buf), (char const   */* __restrict  */)"STOR");
#line 901
  dir = 2;
  }
#line 902
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 904
  sprintf((char */* __restrict  */)(nControl->response), (char const   */* __restrict  */)"Invalid open type %d\n",
          typ);
  }
#line 905
  return (0);
  switch_break: /* CIL Label */ ;
  }
#line 907
  if ((unsigned long )path != (unsigned long )((void *)0)) {
    {
#line 909
    tmp___0 = strlen((char const   *)(buf));
#line 909
    i = (int )tmp___0;
#line 910
    tmp___1 = i;
#line 910
    i ++;
#line 910
    buf[tmp___1] = (char )' ';
#line 911
    tmp___2 = strlen(path);
    }
#line 911
    if (tmp___2 + (size_t )i >= sizeof(buf)) {
#line 912
      return (0);
    }
    {
#line 913
    strcpy((char */* __restrict  */)(& buf[i]), (char const   */* __restrict  */)path);
    }
  }
  {
#line 915
  tmp___3 = FtpOpenPort(nControl, nData, mode, dir);
  }
#line 915
  if (tmp___3 == -1) {
#line 916
    return (0);
  }
  {
#line 917
  tmp___4 = FtpSendCmd((char const   *)(buf), (char )'1', nControl);
  }
#line 917
  if (! tmp___4) {
    {
#line 919
    FtpClose2(*nData);
#line 920
    *nData = (netbuf *)((void *)0);
    }
#line 921
    return (0);
  }
#line 923
  if (nControl->cmode == 2) {
    {
#line 925
    tmp___5 = FtpAcceptConnection(*nData, nControl);
    }
#line 925
    if (! tmp___5) {
      {
#line 927
      FtpClose(*nData);
#line 928
      *nData = (netbuf *)((void *)0);
      }
#line 929
      return (0);
    }
  }
#line 932
  return (1);
}
}
#line 938 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/ftplib.c"
int FtpRead(void *buf , int max , netbuf *nData ) 
{ 
  int i ;
  ssize_t tmp ;

  {
#line 941
  if (nData->dir != 1) {
#line 942
    return (0);
  }
#line 943
  if (nData->buf) {
    {
#line 944
    i = readline((char *)buf, max, nData);
    }
  } else {
    {
#line 947
    socket_wait(nData);
#line 948
    tmp = read(nData->handle, buf, (size_t )max);
#line 948
    i = (int )tmp;
    }
  }
#line 950
  nData->xfered += i;
#line 951
  if (nData->idlecb) {
#line 951
    if (nData->cbbytes) {
#line 953
      nData->xfered1 += i;
#line 954
      if (nData->xfered1 > nData->cbbytes) {
        {
#line 956
        (*(nData->idlecb))(nData, nData->xfered, nData->idlearg);
#line 957
        nData->xfered1 = 0;
        }
      }
    }
  }
#line 960
  return (i);
}
}
#line 966 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/ftplib.c"
int FtpWrite(void *buf , int len , netbuf *nData ) 
{ 
  int i ;
  ssize_t tmp ;

  {
#line 969
  if (nData->dir != 2) {
#line 970
    return (0);
  }
#line 971
  if (nData->buf) {
    {
#line 972
    i = writeline((char *)buf, len, nData);
    }
  } else {
    {
#line 975
    socket_wait(nData);
#line 976
    tmp = write(nData->handle, (void const   *)buf, (size_t )len);
#line 976
    i = (int )tmp;
    }
  }
#line 978
  nData->xfered += i;
#line 979
  if (nData->idlecb) {
#line 979
    if (nData->cbbytes) {
#line 981
      nData->xfered1 += i;
#line 982
      if (nData->xfered1 > nData->cbbytes) {
        {
#line 984
        (*(nData->idlecb))(nData, nData->xfered, nData->idlearg);
#line 985
        nData->xfered1 = 0;
        }
      }
    }
  }
#line 988
  return (i);
}
}
#line 994 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/ftplib.c"
int FtpClose(netbuf *nData ) 
{ 
  netbuf *ctrl ;
  int tmp ;

  {
#line 997
  if (nData->dir == 2) {
#line 999
    if ((unsigned long )nData->buf != (unsigned long )((void *)0)) {
      {
#line 1000
      writeline((char *)((void *)0), 0, nData);
      }
    }
  } else
#line 1002
  if (nData->dir != 1) {
#line 1003
    return (0);
  }
#line 1004
  if (nData->buf) {
    {
#line 1005
    free((void *)nData->buf);
    }
  }
  {
#line 1006
  shutdown(nData->handle, 2);
#line 1007
  close(nData->handle);
#line 1008
  ctrl = nData->ctrl;
#line 1009
  free((void *)nData);
  }
#line 1010
  if (ctrl) {
    {
#line 1011
    tmp = readresp((char )'2', ctrl);
    }
#line 1011
    return (tmp);
  }
#line 1012
  return (1);
}
}
#line 1018 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/ftplib.c"
int FtpClose2(netbuf *nData ) 
{ 
  netbuf *ctrl ;

  {
#line 1021
  if (nData->dir == 2) {
#line 1023
    if ((unsigned long )nData->buf != (unsigned long )((void *)0)) {
      {
#line 1024
      writeline((char *)((void *)0), 0, nData);
      }
    }
  } else
#line 1026
  if (nData->dir != 1) {
#line 1027
    return (0);
  }
#line 1028
  if (nData->buf) {
    {
#line 1029
    free((void *)nData->buf);
    }
  }
  {
#line 1030
  shutdown(nData->handle, 2);
#line 1031
  close(nData->handle);
#line 1032
  ctrl = nData->ctrl;
#line 1033
  free((void *)nData);
  }
#line 1034
  if (ctrl) {
#line 1035
    return (0);
  }
#line 1036
  return (1);
}
}
#line 1044 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/ftplib.c"
int FtpSite(char const   *cmd , netbuf *nControl ) 
{ 
  char buf[256] ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 1048
  tmp = strlen(cmd);
  }
#line 1048
  if (tmp + 7UL > sizeof(buf)) {
#line 1049
    return (0);
  }
  {
#line 1050
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"SITE %s",
          cmd);
#line 1051
  tmp___0 = FtpSendCmd((char const   *)(buf), (char )'2', nControl);
  }
#line 1051
  if (! tmp___0) {
#line 1052
    return (0);
  }
#line 1053
  return (1);
}
}
#line 1065 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/ftplib.c"
int FtpSysType(char *buf , int max , netbuf *nControl ) 
{ 
  int l ;
  char *b ;
  char *s ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 1067
  l = max;
#line 1068
  b = buf;
#line 1070
  tmp = FtpSendCmd("SYST", (char )'2', nControl);
  }
#line 1070
  if (! tmp) {
#line 1071
    return (0);
  }
#line 1072
  s = & nControl->response[4];
  {
#line 1073
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1073
    l --;
#line 1073
    if (l) {
#line 1073
      if (! ((int )*s != 32)) {
#line 1073
        goto while_break;
      }
    } else {
#line 1073
      goto while_break;
    }
#line 1074
    tmp___0 = b;
#line 1074
    b ++;
#line 1074
    tmp___1 = s;
#line 1074
    s ++;
#line 1074
    *tmp___0 = *tmp___1;
  }
  while_break: /* CIL Label */ ;
  }
#line 1075
  tmp___2 = b;
#line 1075
  b ++;
#line 1075
  *tmp___2 = (char )'\000';
#line 1076
  return (1);
}
}
#line 1084 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/ftplib.c"
int FtpMkdir(char const   *path , netbuf *nControl ) 
{ 
  char buf[256] ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 1088
  tmp = strlen(path);
  }
#line 1088
  if (tmp + 6UL > sizeof(buf)) {
#line 1089
    return (0);
  }
  {
#line 1090
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"MKD %s",
          path);
#line 1091
  tmp___0 = FtpSendCmd((char const   *)(buf), (char )'2', nControl);
  }
#line 1091
  if (! tmp___0) {
#line 1092
    return (0);
  }
#line 1093
  return (1);
}
}
#line 1101 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/ftplib.c"
int FtpChdir(char const   *path , netbuf *nControl ) 
{ 
  char buf[256] ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 1105
  tmp = strlen(path);
  }
#line 1105
  if (tmp + 6UL > sizeof(buf)) {
#line 1106
    return (0);
  }
  {
#line 1107
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"CWD %s",
          path);
#line 1108
  tmp___0 = FtpSendCmd((char const   *)(buf), (char )'2', nControl);
  }
#line 1108
  if (! tmp___0) {
#line 1109
    return (0);
  }
#line 1110
  return (1);
}
}
#line 1118 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/ftplib.c"
int FtpCDUp(netbuf *nControl ) 
{ 
  int tmp ;

  {
  {
#line 1120
  tmp = FtpSendCmd("CDUP", (char )'2', nControl);
  }
#line 1120
  if (! tmp) {
#line 1121
    return (0);
  }
#line 1122
  return (1);
}
}
#line 1130 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/ftplib.c"
int FtpRmdir(char const   *path , netbuf *nControl ) 
{ 
  char buf[256] ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 1134
  tmp = strlen(path);
  }
#line 1134
  if (tmp + 6UL > sizeof(buf)) {
#line 1135
    return (0);
  }
  {
#line 1136
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"RMD %s",
          path);
#line 1137
  tmp___0 = FtpSendCmd((char const   *)(buf), (char )'2', nControl);
  }
#line 1137
  if (! tmp___0) {
#line 1138
    return (0);
  }
#line 1139
  return (1);
}
}
#line 1147 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/ftplib.c"
int FtpPwd(char *path , int max , netbuf *nControl ) 
{ 
  int l ;
  char *b ;
  char *s ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 1149
  l = max;
#line 1150
  b = path;
#line 1152
  tmp = FtpSendCmd("PWD", (char )'2', nControl);
  }
#line 1152
  if (! tmp) {
#line 1153
    return (0);
  }
  {
#line 1154
  s = strchr((char const   *)(nControl->response), '\"');
  }
#line 1155
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 1156
    return (0);
  }
#line 1157
  s ++;
  {
#line 1158
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1158
    l --;
#line 1158
    if (l) {
#line 1158
      if (*s) {
#line 1158
        if (! ((int )*s != 34)) {
#line 1158
          goto while_break;
        }
      } else {
#line 1158
        goto while_break;
      }
    } else {
#line 1158
      goto while_break;
    }
#line 1159
    tmp___0 = b;
#line 1159
    b ++;
#line 1159
    tmp___1 = s;
#line 1159
    s ++;
#line 1159
    *tmp___0 = *tmp___1;
  }
  while_break: /* CIL Label */ ;
  }
#line 1160
  tmp___2 = b;
#line 1160
  b ++;
#line 1160
  *tmp___2 = (char )'\000';
#line 1161
  return (1);
}
}
#line 1169 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/ftplib.c"
static int FtpXfer(char const   *localfile , char const   *path , netbuf *nControl ,
                   int typ , int mode ) 
{ 
  int l ;
  int c ;
  char *dbuf ;
  FILE *local ;
  netbuf *nData ;
  struct stat sbuf ;
  long sent_size ;
  long file_size ;
  int i ;
  long rate ;
  int progress_flag ;
  int res ;
  char const   *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  char *tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;

  {
#line 1174
  local = (FILE *)((void *)0);
#line 1181
  progress_flag = 0;
#line 1184
  if ((unsigned long )localfile != (unsigned long )((void *)0)) {
#line 1186
    if (typ == 4) {
#line 1186
      tmp = "r";
    } else {
#line 1186
      tmp = "w";
    }
    {
#line 1186
    local = fopen((char const   */* __restrict  */)localfile, (char const   */* __restrict  */)tmp);
    }
#line 1187
    if ((unsigned long )local == (unsigned long )((void *)0)) {
      {
#line 1189
      tmp___0 = __errno_location();
#line 1189
      tmp___1 = strerror(*tmp___0);
#line 1189
      strncpy((char */* __restrict  */)(nControl->response), (char const   */* __restrict  */)tmp___1,
              sizeof(nControl->response));
      }
#line 1191
      return (0);
    } else {
      {
#line 1187
      tmp___2 = stat((char const   */* __restrict  */)localfile, (struct stat */* __restrict  */)(& sbuf));
      }
#line 1187
      if (tmp___2 == -1) {
        {
#line 1189
        tmp___0 = __errno_location();
#line 1189
        tmp___1 = strerror(*tmp___0);
#line 1189
        strncpy((char */* __restrict  */)(nControl->response), (char const   */* __restrict  */)tmp___1,
                sizeof(nControl->response));
        }
#line 1191
        return (0);
      }
    }
  }
#line 1194
  if ((unsigned long )local == (unsigned long )((void *)0)) {
#line 1195
    if (typ == 4) {
#line 1195
      local = stdin;
    } else {
#line 1195
      local = stdout;
    }
  }
  {
#line 1196
  tmp___3 = FtpAccess(path, typ, mode, nControl, & nData);
  }
#line 1196
  if (! tmp___3) {
#line 1197
    return (0);
  }
  {
#line 1198
  tmp___4 = malloc((size_t )8192);
#line 1198
  dbuf = (char *)tmp___4;
  }
#line 1199
  if (typ == 4) {
#line 1201
    sent_size = 0L;
#line 1202
    file_size = sbuf.st_size;
    {
#line 1203
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1203
      tmp___6 = fread((void */* __restrict  */)dbuf, (size_t )1, (size_t )8192, (FILE */* __restrict  */)local);
#line 1203
      l = (int )tmp___6;
      }
#line 1203
      if (! (l > 0)) {
#line 1203
        goto while_break;
      }
      {
#line 1204
      c = FtpWrite((void *)dbuf, l, nData);
      }
#line 1204
      if (c < l) {
        {
#line 1205
        printf((char const   */* __restrict  */)"short write: passed %d, wrote %d\n",
               l, c);
#line 1207
        FtpClose(nData);
        }
#line 1208
        return (0);
      }
#line 1210
      if (opt_silent) {
#line 1211
        goto while_continue;
      }
#line 1213
      sent_size += (long )c;
#line 1214
      if (sent_size >= 8192L) {
#line 1215
        progress_flag = 1;
#line 1216
        if (sent_size > 20000000L) {
#line 1217
          rate = sent_size / (file_size / 100L);
        } else {
#line 1219
          rate = (sent_size * 100L) / file_size;
        }
        {
#line 1221
        tmp___5 = dgettext("weex", "           : %ld/%ld (%ld%%) [ ");
#line 1221
        printf((char const   */* __restrict  */)tmp___5, sent_size, file_size, rate);
#line 1222
        i = 0;
        }
        {
#line 1222
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1222
          if (! ((long )i < rate / 5L)) {
#line 1222
            goto while_break___0;
          }
          {
#line 1223
          printf((char const   */* __restrict  */)"*");
#line 1222
          i ++;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
#line 1225
        i = 0;
        {
#line 1225
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1225
          if (! ((long )i < 20L - rate / 5L)) {
#line 1225
            goto while_break___1;
          }
          {
#line 1226
          printf((char const   */* __restrict  */)"-");
#line 1225
          i ++;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 1228
        printf((char const   */* __restrict  */)" ]\r");
#line 1229
        fflush(stdout);
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 1235
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 1235
      l = FtpRead((void *)dbuf, 8192, nData);
      }
#line 1235
      if (! (l > 0)) {
#line 1235
        goto while_break___2;
      }
      {
#line 1236
      tmp___7 = fwrite((void const   */* __restrict  */)dbuf, (size_t )1, (size_t )l,
                       (FILE */* __restrict  */)local);
      }
#line 1236
      if (tmp___7 <= 0UL) {
#line 1239
        goto while_break___2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  {
#line 1242
  free((void *)dbuf);
#line 1243
  fflush(local);
  }
#line 1244
  if ((unsigned long )localfile != (unsigned long )((void *)0)) {
    {
#line 1245
    fclose(local);
    }
  }
  {
#line 1247
  res = FtpClose(nData);
  }
#line 1248
  if (progress_flag) {
    {
#line 1249
    printf((char const   */* __restrict  */)"\033[2K");
#line 1250
    fflush(stdout);
    }
  }
#line 1252
  return (res);
}
}
#line 1260 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/ftplib.c"
int FtpNlst(char const   *outputfile , char const   *path , netbuf *nControl ) 
{ 
  int tmp ;

  {
  {
#line 1263
  tmp = FtpXfer(outputfile, path, nControl, 1, 'A');
  }
#line 1263
  return (tmp);
}
}
#line 1271 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/ftplib.c"
int FtpDir(char const   *outputfile , char const   *path , netbuf *nControl ) 
{ 
  int tmp ;

  {
  {
#line 1273
  tmp = FtpXfer(outputfile, path, nControl, 2, 'A');
  }
#line 1273
  return (tmp);
}
}
#line 1281 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/ftplib.c"
int FtpSize(char const   *path , int *size , char mode , netbuf *nControl ) 
{ 
  char cmd[256] ;
  int resp ;
  int sz ;
  int rv ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 1284
  rv = 1;
#line 1286
  tmp = strlen(path);
  }
#line 1286
  if (tmp + 7UL > sizeof(cmd)) {
#line 1287
    return (0);
  }
  {
#line 1288
  sprintf((char */* __restrict  */)(cmd), (char const   */* __restrict  */)"TYPE %c",
          (int )mode);
#line 1289
  tmp___0 = FtpSendCmd((char const   *)(cmd), (char )'2', nControl);
  }
#line 1289
  if (! tmp___0) {
#line 1290
    return (0);
  }
  {
#line 1291
  sprintf((char */* __restrict  */)(cmd), (char const   */* __restrict  */)"SIZE %s",
          path);
#line 1292
  tmp___2 = FtpSendCmd((char const   *)(cmd), (char )'2', nControl);
  }
#line 1292
  if (tmp___2) {
    {
#line 1296
    tmp___1 = sscanf((char const   */* __restrict  */)(nControl->response), (char const   */* __restrict  */)"%d %d",
                     & resp, & sz);
    }
#line 1296
    if (tmp___1 == 2) {
#line 1297
      *size = sz;
    } else {
#line 1299
      rv = 0;
    }
  } else {
#line 1293
    rv = 0;
  }
#line 1301
  return (rv);
}
}
#line 1309 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/ftplib.c"
int FtpModDate(char const   *path , char *dt , int max , netbuf *nControl ) 
{ 
  char buf[256] ;
  int rv ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 1312
  rv = 1;
#line 1314
  tmp = strlen(path);
  }
#line 1314
  if (tmp + 7UL > sizeof(buf)) {
#line 1315
    return (0);
  }
  {
#line 1316
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"MDTM %s",
          path);
#line 1317
  tmp___0 = FtpSendCmd((char const   *)(buf), (char )'2', nControl);
  }
#line 1317
  if (tmp___0) {
    {
#line 1320
    strncpy((char */* __restrict  */)dt, (char const   */* __restrict  */)(& nControl->response[4]),
            (size_t )max);
    }
  } else {
#line 1318
    rv = 0;
  }
#line 1321
  return (rv);
}
}
#line 1329 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/ftplib.c"
int FtpGet(char const   *outputfile , char const   *path , char mode , netbuf *nControl ) 
{ 
  int tmp ;

  {
  {
#line 1332
  tmp = FtpXfer(outputfile, path, nControl, 3, (int )mode);
  }
#line 1332
  return (tmp);
}
}
#line 1340 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/ftplib.c"
int FtpPut(char const   *inputfile , char const   *path , char mode , netbuf *nControl ) 
{ 
  int tmp ;

  {
  {
#line 1343
  tmp = FtpXfer(inputfile, path, nControl, 4, (int )mode);
  }
#line 1343
  return (tmp);
}
}
#line 1351 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/ftplib.c"
int FtpRename(char const   *src , char const   *dst , netbuf *nControl ) 
{ 
  char cmd[256] ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 1355
  tmp = strlen(src);
  }
#line 1355
  if (tmp + 7UL > sizeof(cmd)) {
#line 1357
    return (0);
  } else {
    {
#line 1355
    tmp___0 = strlen(dst);
    }
#line 1355
    if (tmp___0 + 7UL > sizeof(cmd)) {
#line 1357
      return (0);
    }
  }
  {
#line 1358
  sprintf((char */* __restrict  */)(cmd), (char const   */* __restrict  */)"RNFR %s",
          src);
#line 1359
  tmp___1 = FtpSendCmd((char const   *)(cmd), (char )'3', nControl);
  }
#line 1359
  if (! tmp___1) {
#line 1360
    return (0);
  }
  {
#line 1361
  sprintf((char */* __restrict  */)(cmd), (char const   */* __restrict  */)"RNTO %s",
          dst);
#line 1362
  tmp___2 = FtpSendCmd((char const   *)(cmd), (char )'2', nControl);
  }
#line 1362
  if (! tmp___2) {
#line 1363
    return (0);
  }
#line 1364
  return (1);
}
}
#line 1372 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/ftplib.c"
int FtpChmod(char const   *file , char const   *mode , netbuf *nControl ) 
{ 
  char cmd[256] ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1376
  tmp = strlen(file);
  }
#line 1376
  if (tmp + 23UL > sizeof(cmd)) {
#line 1377
    return (0);
  }
  {
#line 1378
  tmp___0 = strlen(mode);
  }
#line 1378
  if (tmp___0 != 3UL) {
#line 1379
    return (0);
  }
  {
#line 1380
  sprintf((char */* __restrict  */)(cmd), (char const   */* __restrict  */)"SITE chmod %s %s",
          mode, file);
#line 1381
  tmp___1 = FtpSendCmd((char const   *)(cmd), (char )'2', nControl);
  }
#line 1381
  if (! tmp___1) {
#line 1382
    return (0);
  }
#line 1383
  return (1);
}
}
#line 1391 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/ftplib.c"
int FtpDelete(char const   *fnm , netbuf *nControl ) 
{ 
  char cmd[256] ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 1395
  tmp = strlen(fnm);
  }
#line 1395
  if (tmp + 7UL > sizeof(cmd)) {
#line 1396
    return (0);
  }
  {
#line 1397
  sprintf((char */* __restrict  */)(cmd), (char const   */* __restrict  */)"DELE %s",
          fnm);
#line 1398
  tmp___0 = FtpSendCmd((char const   *)(cmd), (char )'2', nControl);
  }
#line 1398
  if (! tmp___0) {
#line 1399
    return (0);
  }
#line 1400
  return (1);
}
}
#line 1408 "/home/june/repo/benchmarks/collector2/temp/weex-2.6.1/src/ftplib.c"
void FtpQuit(netbuf *nControl ) 
{ 


  {
#line 1410
  if (nControl->dir != 0) {
#line 1411
    return;
  }
  {
#line 1412
  FtpSendCmd("QUIT", (char )'2', nControl);
#line 1413
  close(nControl->handle);
#line 1414
  free((void *)nControl->buf);
#line 1415
  free((void *)nControl);
  }
#line 1416
  return;
}
}
