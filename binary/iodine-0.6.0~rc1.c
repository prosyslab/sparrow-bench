/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 48 "/usr/include/arpa/nameser_compat.h"
struct __anonstruct_HEADER_50 {
   unsigned int id : 16 ;
   unsigned int rd : 1 ;
   unsigned int tc : 1 ;
   unsigned int aa : 1 ;
   unsigned int opcode : 4 ;
   unsigned int qr : 1 ;
   unsigned int rcode : 4 ;
   unsigned int cd : 1 ;
   unsigned int ad : 1 ;
   unsigned int unused : 1 ;
   unsigned int ra : 1 ;
   unsigned int qdcount : 16 ;
   unsigned int ancount : 16 ;
   unsigned int nscount : 16 ;
   unsigned int arcount : 16 ;
};
#line 48 "/usr/include/arpa/nameser_compat.h"
typedef struct __anonstruct_HEADER_50 HEADER;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 90 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/common.h"
struct query {
   char name[256] ;
   unsigned short type ;
   unsigned short rcode ;
   unsigned short id ;
   struct in_addr destination ;
   struct sockaddr from ;
   int fromlen ;
   unsigned short id2 ;
   struct sockaddr from2 ;
   int fromlen2 ;
};
#line 22 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/dns.h"
enum __anonenum_qr_t_58 {
    QR_QUERY = 0,
    QR_ANSWER = 1
} ;
#line 22 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/dns.h"
typedef enum __anonenum_qr_t_58 qr_t;
#line 27 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/encoding.h"
struct encoder {
   char name[8] ;
   int (*encode)(char * , size_t * , void const   * , size_t  ) ;
   int (*decode)(void * , size_t * , char const   * , size_t  ) ;
   int (*places_dots)(void) ;
   int (*eats_dots)(void) ;
   int (*blocksize_raw)(void) ;
   int (*blocksize_encoded)(void) ;
};
#line 63 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/md5.h"
typedef unsigned char md5_byte_t;
#line 64 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/md5.h"
typedef unsigned int md5_word_t;
#line 67 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/md5.h"
struct md5_state_s {
   md5_word_t count[2] ;
   md5_word_t abcd[4] ;
   md5_byte_t buf[64] ;
};
#line 67 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/md5.h"
typedef struct md5_state_s md5_state_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 23 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned char cc_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int speed_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int tcflag_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/termios.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 183 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef char *__caddr_t;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 111 "/usr/include/net/if.h"
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};
#line 126 "/usr/include/net/if.h"
union __anonunion_ifr_ifrn_37 {
   char ifrn_name[16] ;
};
#line 126 "/usr/include/net/if.h"
union __anonunion_ifr_ifru_38 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16] ;
   char ifru_newname[16] ;
   __caddr_t ifru_data ;
};
#line 126 "/usr/include/net/if.h"
struct ifreq {
   union __anonunion_ifr_ifrn_37 ifr_ifrn ;
   union __anonunion_ifr_ifru_38 ifr_ifru ;
};
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 65 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __gid_t gid_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 103 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/common.h"
enum connection {
    CONN_RAW_UDP = 0,
    CONN_DNS_NULL = 1,
    CONN_MAX = 2
} ;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_15 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_15 fd_set;
#line 368 "/usr/include/x86_64-linux-gnu/zconf.h"
typedef unsigned char Byte;
#line 371 "/usr/include/x86_64-linux-gnu/zconf.h"
typedef unsigned long uLong;
#line 377 "/usr/include/x86_64-linux-gnu/zconf.h"
typedef Byte Bytef;
#line 382 "/usr/include/x86_64-linux-gnu/zconf.h"
typedef uLong uLongf;
#line 100 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 80 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/common.h"
struct packet {
   int len ;
   int sentlen ;
   int offset ;
   char data[65536] ;
   char seqno ;
   char fragment ;
};
#line 30 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/fw_query.h"
struct fw_query {
   struct sockaddr addr ;
   int addrlen ;
   unsigned short id ;
};
#line 39 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/user.h"
struct _user {
   char id ;
   int active ;
   int disabled ;
   time_t last_pkt ;
   int seed ;
   in_addr_t tun_ip ;
   struct in_addr host ;
   struct query q ;
   struct query q_sendrealsoon ;
   int q_sendrealsoon_new ;
   struct packet inpacket ;
   struct packet outpacket ;
   int outfragresent ;
   struct encoder *encoder ;
   char downenc ;
   int out_acked_seqno ;
   int out_acked_fragment ;
   int fragsize ;
   enum connection conn ;
   int lazy ;
   unsigned char qmemping_cmc[120] ;
   unsigned short qmemping_type[30] ;
   int qmemping_lastfilled ;
   unsigned char qmemdata_cmc[60] ;
   unsigned short qmemdata_type[15] ;
   int qmemdata_lastfilled ;
   struct packet outpacketq[4] ;
   int outpacketq_nexttouse ;
   int outpacketq_filled ;
   struct query dnscache_q[4] ;
   char dnscache_answer[4][4096] ;
   int dnscache_answerlen[4] ;
   int dnscache_lastfilled ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __u_short;
#line 34 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_short u_short;
#line 116 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __caddr_t caddr_t;
#line 200 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned char u_int8_t;
#line 43 "/usr/include/x86_64-linux-gnu/bits/uio.h"
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
#line 224 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct msghdr {
   void *msg_name ;
   socklen_t msg_namelen ;
   struct iovec *msg_iov ;
   size_t msg_iovlen ;
   void *msg_control ;
   size_t msg_controllen ;
   int msg_flags ;
};
#line 242 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct cmsghdr {
   size_t cmsg_len ;
   int cmsg_level ;
   int cmsg_type ;
   unsigned char __cmsg_data[] ;
};
#line 127 "/usr/include/x86_64-linux-gnu/bits/in.h"
struct in_pktinfo {
   int ipi_ifindex ;
   struct in_addr ipi_spec_dst ;
   struct in_addr ipi_addr ;
};
#line 107 "/usr/include/netinet/ip.h"
struct ip {
   unsigned int ip_hl : 4 ;
   unsigned int ip_v : 4 ;
   u_int8_t ip_tos ;
   u_short ip_len ;
   u_short ip_id ;
   u_short ip_off ;
   u_int8_t ip_ttl ;
   u_int8_t ip_p ;
   u_short ip_sum ;
   struct in_addr ip_src ;
   struct in_addr ip_dst ;
};
#line 594 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/iodined.c"
enum __anonenum_version_ack_t_61 {
    VERSION_ACK = 0,
    VERSION_NACK = 1,
    VERSION_FULL = 2
} ;
#line 594 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/iodined.c"
typedef enum __anonenum_version_ack_t_61 version_ack_t;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 375 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) ntohs)(uint16_t __netshort )  __attribute__((__const__)) ;
#line 379
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 40 "/usr/include/err.h"
extern void ( /* format attribute */  warnx)(char const   *__format  , ...) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/dns.h"
int dnsc_use_edns0 ;
#line 29
int dns_encode(char *buf , size_t buflen , struct query *q , qr_t qr , char *data ,
               size_t datalen ) ;
#line 30
int dns_encode_ns_response(char *buf , size_t buflen , struct query *q , char *topdomain___1 ) ;
#line 31
int dns_encode_a_response(char *buf , size_t buflen , struct query *q ) ;
#line 32
unsigned short dns_get_id(char *packet , size_t packetlen ) ;
#line 33
int dns_decode(char *buf , size_t buflen , struct query *q , qr_t qr , char *packet ,
               size_t packetlen ) ;
#line 20 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/read.h"
int readname(char *packet , int packetlen , char **src , char *dst , size_t length ) ;
#line 21
int readshort(char *packet , char **src , short *dst ) ;
#line 22
int readlong(char *packet , char **src , uint32_t *dst ) ;
#line 23
int readdata(char *packet , char **src , char *dst , size_t len ) ;
#line 24
int readtxtbin(char *packet , char **src , size_t srcremain , char *dst , size_t dstremain ) ;
#line 26
int putname(char **buf , size_t buflen , char const   *host ) ;
#line 27
int putbyte(char **dst , unsigned char value ) ;
#line 28
int putshort(char **dst , unsigned short value ) ;
#line 29
int putlong(char **dst , uint32_t value ) ;
#line 30
int putdata(char **dst , char *data , size_t len ) ;
#line 31
int puttxtbin(char **buf , size_t bufremain , char *from , size_t fromremain ) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/dns.c"
int dnsc_use_edns0  =    1;
#line 46 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/dns.c"
int dns_encode(char *buf , size_t buflen , struct query *q , qr_t qr , char *data ,
               size_t datalen ) 
{ 
  HEADER *header ;
  short name ;
  char *p ;
  int len ;
  int ancnt ;
  uint16_t tmp ;
  uint16_t tmp___0 ;
  char *startp ;
  int namelen ;
  char *mxdata ;
  char *startp___0 ;
  int namelen___0 ;
  size_t tmp___1 ;
  char *startp___1 ;
  int txtlen ;
  uint16_t tmp___2 ;
  uint16_t tmp___3 ;
  uint16_t tmp___4 ;

  {
#line 55
  if (buflen < sizeof(HEADER )) {
#line 56
    return (0);
  }
  {
#line 58
  memset((void *)buf, 0, buflen);
#line 60
  header = (HEADER *)buf;
#line 62
  tmp = htons(q->id);
#line 62
  header->id = (unsigned int )tmp;
#line 63
  header->qr = (unsigned int )((unsigned int )qr == 1U);
#line 64
  header->opcode = 0U;
#line 65
  header->aa = (unsigned int )((unsigned int )qr == 1U);
#line 66
  header->tc = 0U;
#line 67
  header->rd = (unsigned int )((unsigned int )qr == 0U);
#line 68
  header->ra = 0U;
#line 70
  p = buf + sizeof(HEADER );
  }
  {
#line 73
  if ((unsigned int )qr == 1U) {
#line 73
    goto case_1;
  }
#line 191
  if ((unsigned int )qr == 0U) {
#line 191
    goto case_0;
  }
#line 72
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 74
  tmp___0 = htons((uint16_t )1);
#line 74
  header->qdcount = (unsigned int )tmp___0;
#line 76
  name = (short )(49152L | ((p - buf) & 16383L));
#line 79
  putname(& p, buflen - (size_t )(p - buf), (char const   *)(q->name));
  }
#line 81
  if (buflen - (size_t )(p - buf) < 4UL) {
#line 81
    return (0);
  }
  {
#line 82
  putshort(& p, q->type);
#line 83
  putshort(& p, (unsigned short)1);
  }
#line 87
  if ((int )q->type == 5) {
#line 87
    goto _L___0;
  } else
#line 87
  if ((int )q->type == 1) {
    _L___0: /* CIL Label */ 
#line 93
    if (buflen - (size_t )(p - buf) < 10UL) {
#line 93
      return (0);
    }
    {
#line 94
    putshort(& p, (unsigned short )name);
    }
#line 95
    if ((int )q->type == 1) {
      {
#line 97
      putshort(& p, (unsigned short)5);
      }
    } else {
      {
#line 99
      putshort(& p, q->type);
      }
    }
    {
#line 100
    putshort(& p, (unsigned short)1);
#line 101
    putlong(& p, (uint32_t )0);
#line 103
    startp = p;
#line 104
    p += 2;
#line 105
    putname(& p, buflen - (size_t )(p - buf), (char const   *)data);
    }
#line 106
    if (buflen - (size_t )(p - buf) < 0UL) {
#line 106
      return (0);
    }
    {
#line 107
    namelen = (int )(p - startp);
#line 108
    namelen -= 2;
#line 109
    putshort(& startp, (unsigned short )namelen);
#line 110
    ancnt = 1;
    }
  } else
#line 111
  if ((int )q->type == 15) {
#line 111
    goto _L;
  } else
#line 111
  if ((int )q->type == 33) {
    _L: /* CIL Label */ 
#line 117
    mxdata = data;
#line 121
    ancnt = 1;
    {
#line 122
    while (1) {
      while_continue: /* CIL Label */ ;
#line 123
      if (buflen - (size_t )(p - buf) < 10UL) {
#line 123
        return (0);
      }
      {
#line 124
      putshort(& p, (unsigned short )name);
#line 125
      putshort(& p, q->type);
#line 126
      putshort(& p, (unsigned short)1);
#line 127
      putlong(& p, (uint32_t )0);
#line 129
      startp___0 = p;
#line 130
      p += 2;
      }
#line 131
      if (buflen - (size_t )(p - buf) < 2UL) {
#line 131
        return (0);
      }
      {
#line 132
      putshort(& p, (unsigned short )(10 * ancnt));
      }
#line 134
      if ((int )q->type == 33) {
#line 136
        if (buflen - (size_t )(p - buf) < 4UL) {
#line 136
          return (0);
        }
        {
#line 137
        putshort(& p, (unsigned short)10);
#line 138
        putshort(& p, (unsigned short)5060);
        }
      }
      {
#line 141
      putname(& p, buflen - (size_t )(p - buf), (char const   *)mxdata);
      }
#line 142
      if (buflen - (size_t )(p - buf) < 0UL) {
#line 142
        return (0);
      }
      {
#line 143
      namelen___0 = (int )(p - startp___0);
#line 144
      namelen___0 -= 2;
#line 145
      putshort(& startp___0, (unsigned short )namelen___0);
#line 147
      tmp___1 = strlen((char const   *)mxdata);
#line 147
      mxdata = (mxdata + tmp___1) + 1;
      }
#line 148
      if ((int )*mxdata == 0) {
#line 149
        goto while_break;
      }
#line 151
      ancnt ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 153
  if ((int )q->type == 16) {
#line 158
    if (buflen - (size_t )(p - buf) < 10UL) {
#line 158
      return (0);
    }
    {
#line 159
    putshort(& p, (unsigned short )name);
#line 160
    putshort(& p, q->type);
#line 161
    putshort(& p, (unsigned short)1);
#line 162
    putlong(& p, (uint32_t )0);
#line 164
    startp___1 = p;
#line 165
    p += 2;
#line 166
    puttxtbin(& p, buflen - (size_t )(p - buf), data, datalen);
    }
#line 167
    if (buflen - (size_t )(p - buf) < 0UL) {
#line 167
      return (0);
    }
    {
#line 168
    txtlen = (int )(p - startp___1);
#line 169
    txtlen -= 2;
#line 170
    putshort(& startp___1, (unsigned short )txtlen);
#line 171
    ancnt = 1;
    }
  } else {
#line 175
    if (buflen - (size_t )(p - buf) < 10UL) {
#line 175
      return (0);
    }
    {
#line 176
    putshort(& p, (unsigned short )name);
#line 177
    putshort(& p, q->type);
#line 178
    putshort(& p, (unsigned short)1);
#line 179
    putlong(& p, (uint32_t )0);
    }
#line 181
    if (datalen < buflen - (size_t )(p - buf)) {
#line 181
      datalen = datalen;
    } else {
#line 181
      datalen = buflen - (size_t )(p - buf);
    }
#line 182
    if (buflen - (size_t )(p - buf) < 2UL) {
#line 182
      return (0);
    }
    {
#line 183
    putshort(& p, (unsigned short )datalen);
    }
#line 184
    if (buflen - (size_t )(p - buf) < datalen) {
#line 184
      return (0);
    }
    {
#line 185
    putdata(& p, data, datalen);
    }
#line 186
    if (buflen - (size_t )(p - buf) < 0UL) {
#line 186
      return (0);
    }
#line 187
    ancnt = 1;
  }
  {
#line 189
  tmp___2 = htons((uint16_t )ancnt);
#line 189
  header->ancount = (unsigned int )tmp___2;
  }
#line 190
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 194
  tmp___3 = htons((uint16_t )1);
#line 194
  header->qdcount = (unsigned int )tmp___3;
  }
#line 196
  if (datalen < buflen - (size_t )(p - buf)) {
#line 196
    datalen = datalen;
  } else {
#line 196
    datalen = buflen - (size_t )(p - buf);
  }
  {
#line 197
  putname(& p, datalen, (char const   *)data);
  }
#line 199
  if (buflen - (size_t )(p - buf) < 4UL) {
#line 199
    return (0);
  }
  {
#line 200
  putshort(& p, q->type);
#line 201
  putshort(& p, (unsigned short)1);
  }
#line 205
  if (dnsc_use_edns0) {
    {
#line 206
    tmp___4 = htons((uint16_t )1);
#line 206
    header->arcount = (unsigned int )tmp___4;
    }
#line 208
    if (buflen - (size_t )(p - buf) < 11UL) {
#line 208
      return (0);
    }
    {
#line 209
    putbyte(& p, (unsigned char)0);
#line 210
    putshort(& p, (unsigned short)41);
#line 211
    putshort(& p, (unsigned short)4096);
#line 212
    putshort(& p, (unsigned short)0);
#line 213
    putshort(& p, (unsigned short)32768);
#line 214
    putshort(& p, (unsigned short)0);
    }
  }
#line 218
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 221
  len = (int )(p - buf);
#line 223
  return (len);
}
}
#line 226 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/dns.c"
int dns_encode_ns_response(char *buf , size_t buflen , struct query *q , char *topdomain___1 ) 
{ 
  HEADER *header ;
  int len ;
  short name ;
  short topname ;
  short nsname ;
  char *ipp ;
  int domain_len ;
  char *p ;
  uint16_t tmp ;
  uint16_t tmp___0 ;
  uint16_t tmp___1 ;
  uint16_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;

  {
#line 240
  if (buflen < sizeof(HEADER )) {
#line 241
    return (0);
  }
  {
#line 243
  memset((void *)buf, 0, buflen);
#line 245
  header = (HEADER *)buf;
#line 247
  tmp = htons(q->id);
#line 247
  header->id = (unsigned int )tmp;
#line 248
  header->qr = 1U;
#line 249
  header->opcode = 0U;
#line 250
  header->aa = 1U;
#line 251
  header->tc = 0U;
#line 252
  header->rd = 0U;
#line 253
  header->ra = 0U;
#line 255
  p = buf + sizeof(HEADER );
#line 257
  tmp___0 = htons((uint16_t )1);
#line 257
  header->qdcount = (unsigned int )tmp___0;
#line 258
  tmp___1 = htons((uint16_t )1);
#line 258
  header->ancount = (unsigned int )tmp___1;
#line 259
  tmp___2 = htons((uint16_t )1);
#line 259
  header->arcount = (unsigned int )tmp___2;
#line 262
  name = (short )(49152L | ((p - buf) & 16383L));
#line 264
  tmp___3 = strlen((char const   *)(q->name));
#line 264
  tmp___4 = strlen((char const   *)topdomain___1);
#line 264
  domain_len = (int )(tmp___3 - tmp___4);
  }
#line 265
  if (domain_len < 0) {
#line 266
    return (-1);
  } else
#line 265
  if (domain_len == 1) {
#line 266
    return (-1);
  }
  {
#line 267
  tmp___5 = strcasecmp((char const   *)(q->name + domain_len), (char const   *)topdomain___1);
  }
#line 267
  if (tmp___5) {
#line 268
    return (-1);
  }
#line 269
  if (domain_len >= 1) {
#line 269
    if ((int )q->name[domain_len - 1] != 46) {
#line 270
      return (-1);
    }
  }
  {
#line 274
  topname = (short )(49152L | (((p - buf) + (long )domain_len) & 16383L));
#line 277
  putname(& p, buflen - (size_t )(p - buf), (char const   *)(q->name));
  }
#line 278
  if (buflen - (size_t )(p - buf) < 4UL) {
#line 278
    return (0);
  }
  {
#line 279
  putshort(& p, q->type);
#line 280
  putshort(& p, (unsigned short)1);
  }
#line 283
  if (buflen - (size_t )(p - buf) < 12UL) {
#line 283
    return (0);
  }
  {
#line 284
  putshort(& p, (unsigned short )name);
#line 285
  putshort(& p, q->type);
#line 286
  putshort(& p, (unsigned short)1);
#line 287
  putlong(& p, (uint32_t )3600);
#line 288
  putshort(& p, (unsigned short)5);
#line 291
  nsname = (short )(49152L | ((p - buf) & 16383L));
  }
#line 292
  if (buflen - (size_t )(p - buf) < 5UL) {
#line 292
    return (0);
  }
  {
#line 293
  putbyte(& p, (unsigned char)2);
#line 294
  putbyte(& p, (unsigned char )'n');
#line 295
  putbyte(& p, (unsigned char )'s');
#line 296
  putshort(& p, (unsigned short )topname);
  }
#line 299
  if (buflen - (size_t )(p - buf) < 12UL) {
#line 299
    return (0);
  }
  {
#line 300
  putshort(& p, (unsigned short )nsname);
#line 301
  putshort(& p, (unsigned short)1);
#line 302
  putshort(& p, (unsigned short)1);
#line 303
  putlong(& p, (uint32_t )3600);
#line 304
  putshort(& p, (unsigned short)4);
#line 307
  ipp = (char *)(& q->destination);
  }
#line 308
  if (buflen - (size_t )(p - buf) < 4UL) {
#line 308
    return (0);
  }
  {
#line 309
  tmp___6 = ipp;
#line 309
  ipp ++;
#line 309
  putbyte(& p, (unsigned char )*tmp___6);
#line 310
  tmp___7 = ipp;
#line 310
  ipp ++;
#line 310
  putbyte(& p, (unsigned char )*tmp___7);
#line 311
  tmp___8 = ipp;
#line 311
  ipp ++;
#line 311
  putbyte(& p, (unsigned char )*tmp___8);
#line 312
  putbyte(& p, (unsigned char )*ipp);
#line 314
  len = (int )(p - buf);
  }
#line 315
  return (len);
}
}
#line 318 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/dns.c"
int dns_encode_a_response(char *buf , size_t buflen , struct query *q ) 
{ 
  HEADER *header ;
  int len ;
  short name ;
  char *ipp ;
  char *p ;
  uint16_t tmp ;
  uint16_t tmp___0 ;
  uint16_t tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 329
  if (buflen < sizeof(HEADER )) {
#line 330
    return (0);
  }
  {
#line 332
  memset((void *)buf, 0, buflen);
#line 334
  header = (HEADER *)buf;
#line 336
  tmp = htons(q->id);
#line 336
  header->id = (unsigned int )tmp;
#line 337
  header->qr = 1U;
#line 338
  header->opcode = 0U;
#line 339
  header->aa = 1U;
#line 340
  header->tc = 0U;
#line 341
  header->rd = 0U;
#line 342
  header->ra = 0U;
#line 344
  p = buf + sizeof(HEADER );
#line 346
  tmp___0 = htons((uint16_t )1);
#line 346
  header->qdcount = (unsigned int )tmp___0;
#line 347
  tmp___1 = htons((uint16_t )1);
#line 347
  header->ancount = (unsigned int )tmp___1;
#line 350
  name = (short )(49152L | ((p - buf) & 16383L));
#line 353
  putname(& p, buflen - (size_t )(p - buf), (char const   *)(q->name));
  }
#line 354
  if (buflen - (size_t )(p - buf) < 4UL) {
#line 354
    return (0);
  }
  {
#line 355
  putshort(& p, q->type);
#line 356
  putshort(& p, (unsigned short)1);
  }
#line 359
  if (buflen - (size_t )(p - buf) < 12UL) {
#line 359
    return (0);
  }
  {
#line 360
  putshort(& p, (unsigned short )name);
#line 361
  putshort(& p, q->type);
#line 362
  putshort(& p, (unsigned short)1);
#line 363
  putlong(& p, (uint32_t )3600);
#line 364
  putshort(& p, (unsigned short)4);
#line 367
  ipp = (char *)(& q->destination);
  }
#line 368
  if (buflen - (size_t )(p - buf) < 4UL) {
#line 368
    return (0);
  }
  {
#line 369
  tmp___2 = ipp;
#line 369
  ipp ++;
#line 369
  putbyte(& p, (unsigned char )*tmp___2);
#line 370
  tmp___3 = ipp;
#line 370
  ipp ++;
#line 370
  putbyte(& p, (unsigned char )*tmp___3);
#line 371
  tmp___4 = ipp;
#line 371
  ipp ++;
#line 371
  putbyte(& p, (unsigned char )*tmp___4);
#line 372
  putbyte(& p, (unsigned char )*ipp);
#line 374
  len = (int )(p - buf);
  }
#line 375
  return (len);
}
}
#line 380 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/dns.c"
unsigned short dns_get_id(char *packet , size_t packetlen ) 
{ 
  HEADER *header ;
  uint16_t tmp ;

  {
#line 384
  header = (HEADER *)packet;
#line 386
  if (packetlen < sizeof(HEADER )) {
#line 387
    return ((unsigned short)0);
  }
  {
#line 389
  tmp = ntohs((uint16_t )header->id);
  }
#line 389
  return (tmp);
}
}
#line 394 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/dns.c"
int dns_decode(char *buf , size_t buflen , struct query *q , qr_t qr , char *packet ,
               size_t packetlen ) 
{ 
  char name[256] ;
  char rdata[4096] ;
  HEADER *header ;
  short qdcount ;
  short ancount ;
  uint32_t ttl ;
  short class ;
  short type ;
  char *data ;
  short rlen ;
  int id ;
  int rv ;
  uint16_t tmp ;
  uint16_t tmp___0 ;
  uint16_t tmp___1 ;
  size_t tmp___2 ;
  char names[250][256] ;
  char *rdatastart ;
  short pref ;
  int i ;
  int offset ;
  int l ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;

  {
#line 410
  q->id2 = (unsigned short)0;
#line 411
  rv = 0;
#line 412
  header = (HEADER *)packet;
#line 415
  if (packetlen < sizeof(HEADER )) {
#line 416
    return (0);
  }
#line 418
  if (header->qr != (unsigned int )qr) {
    {
#line 419
    warnx("header->qr does not match the requested qr");
    }
#line 420
    return (-1);
  }
  {
#line 423
  data = packet + sizeof(HEADER );
#line 424
  tmp = ntohs((uint16_t )header->qdcount);
#line 424
  qdcount = (short )tmp;
#line 425
  tmp___0 = ntohs((uint16_t )header->ancount);
#line 425
  ancount = (short )tmp___0;
#line 427
  tmp___1 = ntohs((uint16_t )header->id);
#line 427
  id = (int )tmp___1;
#line 428
  id &= 65535;
#line 430
  rlen = (short)0;
  }
#line 432
  if ((unsigned long )q != (unsigned long )((void *)0)) {
#line 433
    q->rcode = (unsigned short )header->rcode;
  }
  {
#line 436
  if ((unsigned int )qr == 1U) {
#line 436
    goto case_1;
  }
#line 581
  if ((unsigned int )qr == 0U) {
#line 581
    goto case_0;
  }
#line 435
  goto switch_break;
  case_1: /* CIL Label */ 
#line 437
  if ((int )qdcount < 1) {
#line 439
    return (-1);
  }
#line 442
  if ((unsigned long )q != (unsigned long )((void *)0)) {
#line 443
    q->id = (unsigned short )id;
  }
  {
#line 446
  readname(packet, (int )packetlen, & data, name, sizeof(name));
  }
#line 447
  if (packetlen - (size_t )(data - packet) < 4UL) {
#line 447
    return (0);
  }
  {
#line 448
  readshort(packet, & data, & type);
#line 449
  readshort(packet, & data, & class);
  }
#line 452
  if ((unsigned long )q != (unsigned long )((void *)0)) {
#line 454
    q->name[0] = name[0];
#line 455
    q->name[1] = (char )'\000';
  }
#line 458
  if ((int )ancount < 1) {
#line 462
    return (-1);
  }
#line 466
  if ((int )type == 10) {
    {
#line 468
    readname(packet, (int )packetlen, & data, name, sizeof(name));
    }
#line 469
    if (packetlen - (size_t )(data - packet) < 10UL) {
#line 469
      return (0);
    }
    {
#line 470
    readshort(packet, & data, & type);
#line 471
    readshort(packet, & data, & class);
#line 472
    readlong(packet, & data, & ttl);
#line 473
    readshort(packet, & data, & rlen);
    }
#line 475
    if ((unsigned long )rlen < sizeof(rdata)) {
#line 475
      rv = (int )rlen;
    } else {
#line 475
      rv = (int )sizeof(rdata);
    }
    {
#line 476
    rv = readdata(packet, & data, rdata, (size_t )rv);
    }
#line 477
    if (rv >= 2) {
#line 477
      if (buf) {
#line 478
        if ((size_t )rv < buflen) {
#line 478
          rv = rv;
        } else {
#line 478
          rv = (int )buflen;
        }
        {
#line 479
        memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)(rdata),
               (size_t )rv);
        }
      } else {
#line 481
        rv = 0;
      }
    } else {
#line 481
      rv = 0;
    }
  } else
#line 484
  if ((int )type == 1) {
#line 484
    goto _L___2;
  } else
#line 484
  if ((int )type == 5) {
    _L___2: /* CIL Label */ 
#line 484
    if (buf) {
      {
#line 486
      readname(packet, (int )packetlen, & data, name, sizeof(name));
      }
#line 487
      if (packetlen - (size_t )(data - packet) < 10UL) {
#line 487
        return (0);
      }
      {
#line 488
      readshort(packet, & data, & type);
#line 489
      readshort(packet, & data, & class);
#line 490
      readlong(packet, & data, & ttl);
#line 491
      readshort(packet, & data, & rlen);
#line 493
      memset((void *)(name), 0, sizeof(name));
#line 494
      readname(packet, (int )packetlen, & data, name, sizeof(name) - 1UL);
#line 495
      name[sizeof(name) - 1UL] = (char )'\000';
#line 496
      strncpy((char */* __restrict  */)buf, (char const   */* __restrict  */)(name),
              buflen);
#line 497
      *(buf + (buflen - 1UL)) = (char )'\000';
#line 498
      tmp___2 = strlen((char const   *)buf);
#line 498
      rv = (int )tmp___2;
      }
    } else {
#line 484
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 500
  if ((int )type == 15) {
#line 500
    goto _L___0;
  } else
#line 500
  if ((int )type == 33) {
    _L___0: /* CIL Label */ 
#line 500
    if (buf) {
      {
#line 512
      memset((void *)(names), 0, sizeof(names));
#line 514
      i = 0;
      }
      {
#line 514
      while (1) {
        while_continue: /* CIL Label */ ;
#line 514
        if (! (i < (int )ancount)) {
#line 514
          goto while_break;
        }
        {
#line 515
        readname(packet, (int )packetlen, & data, name, sizeof(name));
        }
#line 516
        if (packetlen - (size_t )(data - packet) < 12UL) {
#line 516
          return (0);
        }
        {
#line 517
        readshort(packet, & data, & type);
#line 518
        readshort(packet, & data, & class);
#line 519
        readlong(packet, & data, & ttl);
#line 520
        readshort(packet, & data, & rlen);
#line 521
        rdatastart = data;
#line 522
        readshort(packet, & data, & pref);
        }
#line 524
        if ((int )type == 33) {
#line 526
          data += 4;
#line 527
          if (packetlen - (size_t )(data - packet) < 0UL) {
#line 527
            return (0);
          }
        }
#line 530
        if ((int )pref % 10 == 0) {
#line 530
          if ((int )pref >= 10) {
#line 530
            if ((int )pref < 2500) {
              {
#line 532
              readname(packet, (int )packetlen, & data, names[(int )pref / 10 - 1],
                       (size_t )255);
#line 535
              names[(int )pref / 10 - 1][255] = (char )'\000';
              }
            }
          }
        }
#line 539
        data = rdatastart + (int )rlen;
#line 540
        if (packetlen - (size_t )(data - packet) < 0UL) {
#line 540
          return (0);
        }
#line 514
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 544
      offset = 0;
#line 545
      i = 0;
      {
#line 546
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 546
        if (! ((int )names[i][0] != 0)) {
#line 546
          goto while_break___0;
        }
        {
#line 547
        tmp___6 = strlen((char const   *)(names[i]));
        }
#line 547
        if (tmp___6 < (buflen - (size_t )offset) - 2UL) {
          {
#line 547
          tmp___4 = strlen((char const   *)(names[i]));
#line 547
          tmp___5 = tmp___4;
          }
        } else {
#line 547
          tmp___5 = (buflen - (size_t )offset) - 2UL;
        }
#line 547
        l = (int )tmp___5;
#line 548
        if (l <= 0) {
#line 549
          goto while_break___0;
        }
        {
#line 550
        memcpy((void */* __restrict  */)(buf + offset), (void const   */* __restrict  */)(names[i]),
               (size_t )l);
#line 551
        offset += l;
#line 552
        *(buf + offset) = (char )'\000';
#line 553
        offset ++;
#line 554
        i ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 556
      *(buf + offset) = (char )'\000';
#line 557
      rv = offset;
    } else {
#line 500
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 559
  if ((int )type == 16) {
#line 559
    if (buf) {
      {
#line 561
      readname(packet, (int )packetlen, & data, name, sizeof(name));
      }
#line 562
      if (packetlen - (size_t )(data - packet) < 10UL) {
#line 562
        return (0);
      }
      {
#line 563
      readshort(packet, & data, & type);
#line 564
      readshort(packet, & data, & class);
#line 565
      readlong(packet, & data, & ttl);
#line 566
      readshort(packet, & data, & rlen);
#line 568
      rv = readtxtbin(packet, & data, (size_t )rlen, rdata, sizeof(rdata));
      }
#line 569
      if (rv >= 1) {
#line 570
        if ((size_t )rv < buflen) {
#line 570
          rv = rv;
        } else {
#line 570
          rv = (int )buflen;
        }
        {
#line 571
        memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)(rdata),
               (size_t )rv);
        }
      } else {
#line 573
        rv = 0;
      }
    }
  }
#line 578
  if ((unsigned long )q != (unsigned long )((void *)0)) {
#line 579
    q->type = (unsigned short )type;
  }
#line 580
  goto switch_break;
  case_0: /* CIL Label */ 
#line 582
  if ((int )qdcount < 1) {
    {
#line 583
    warnx("no question section in name query");
    }
#line 584
    return (-1);
  }
  {
#line 587
  memset((void *)(name), 0, sizeof(name));
#line 588
  readname(packet, (int )packetlen, & data, name, sizeof(name) - 1UL);
#line 589
  name[sizeof(name) - 1UL] = (char )'\000';
  }
#line 590
  if (packetlen - (size_t )(data - packet) < 4UL) {
#line 590
    return (0);
  }
  {
#line 591
  readshort(packet, & data, & type);
#line 592
  readshort(packet, & data, & class);
  }
#line 594
  if ((unsigned long )q == (unsigned long )((void *)0)) {
#line 595
    rv = 0;
#line 596
    goto switch_break;
  }
  {
#line 599
  strncpy((char */* __restrict  */)(q->name), (char const   */* __restrict  */)(name),
          sizeof(q->name));
#line 600
  q->name[sizeof(q->name) - 1UL] = (char )'\000';
#line 601
  q->type = (unsigned short )type;
#line 602
  q->id = (unsigned short )id;
#line 604
  tmp___7 = strlen((char const   *)(q->name));
#line 604
  rv = (int )tmp___7;
  }
#line 605
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 608
  return (rv);
}
}
#line 20 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base32.h"
struct encoder *get_base32_encoder(void) ;
#line 22
int b32_5to8(int in ) ;
#line 23
int b32_8to5(int in ) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base32.c"
static char const   cb32[33]  = 
#line 28 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base32.c"
  {      (char const   )'a',      (char const   )'b',      (char const   )'c',      (char const   )'d', 
        (char const   )'e',      (char const   )'f',      (char const   )'g',      (char const   )'h', 
        (char const   )'i',      (char const   )'j',      (char const   )'k',      (char const   )'l', 
        (char const   )'m',      (char const   )'n',      (char const   )'o',      (char const   )'p', 
        (char const   )'q',      (char const   )'r',      (char const   )'s',      (char const   )'t', 
        (char const   )'u',      (char const   )'v',      (char const   )'w',      (char const   )'x', 
        (char const   )'y',      (char const   )'z',      (char const   )'0',      (char const   )'1', 
        (char const   )'2',      (char const   )'3',      (char const   )'4',      (char const   )'5', 
        (char const   )'\000'};
#line 30 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base32.c"
static char const   cb32_ucase[33]  = 
#line 30
  {      (char const   )'A',      (char const   )'B',      (char const   )'C',      (char const   )'D', 
        (char const   )'E',      (char const   )'F',      (char const   )'G',      (char const   )'H', 
        (char const   )'I',      (char const   )'J',      (char const   )'K',      (char const   )'L', 
        (char const   )'M',      (char const   )'N',      (char const   )'O',      (char const   )'P', 
        (char const   )'Q',      (char const   )'R',      (char const   )'S',      (char const   )'T', 
        (char const   )'U',      (char const   )'V',      (char const   )'W',      (char const   )'X', 
        (char const   )'Y',      (char const   )'Z',      (char const   )'0',      (char const   )'1', 
        (char const   )'2',      (char const   )'3',      (char const   )'4',      (char const   )'5', 
        (char const   )'\000'};
#line 32 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base32.c"
static unsigned char rev32[256]  ;
#line 33 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base32.c"
static int reverse_init  =    0;
#line 35
static int base32_encode(char *buf , size_t *buflen , void const   *data , size_t size ) ;
#line 36
static int base32_decode(void *buf , size_t *buflen , char const   *str , size_t slen ) ;
#line 37
static int base32_handles_dots(void) ;
#line 38
static int base32_blksize_raw(void) ;
#line 39
static int base32_blksize_enc(void) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base32.c"
static struct encoder base32_encoder  =    {{(char )'B', (char )'a', (char )'s', (char )'e', (char )'3', (char )'2', (char )'\000'},
    & base32_encode, & base32_decode, & base32_handles_dots, & base32_handles_dots,
    & base32_blksize_raw, & base32_blksize_enc};
#line 52 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base32.c"
struct encoder *get_base32_encoder(void) 
{ 


  {
#line 55
  return (& base32_encoder);
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base32.c"
static int base32_handles_dots(void) 
{ 


  {
#line 61
  return (0);
}
}
#line 64 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base32.c"
static int base32_blksize_raw(void) 
{ 


  {
#line 67
  return (5);
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base32.c"
static int base32_blksize_enc(void) 
{ 


  {
#line 73
  return (8);
}
}
#line 76 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base32.c"
__inline static void base32_reverse_init(void) 
{ 
  int i ;
  unsigned char c ;

  {
#line 82
  if (! reverse_init) {
    {
#line 83
    memset((void *)(rev32), 0, (size_t )256);
#line 84
    i = 0;
    }
    {
#line 84
    while (1) {
      while_continue: /* CIL Label */ ;
#line 84
      if (! (i < 32)) {
#line 84
        goto while_break;
      }
#line 85
      c = (unsigned char )cb32[i];
#line 86
      rev32[(int )c] = (unsigned char )i;
#line 87
      c = (unsigned char )cb32_ucase[i];
#line 88
      rev32[(int )c] = (unsigned char )i;
#line 84
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 90
    reverse_init = 1;
  }
#line 92
  return;
}
}
#line 94 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base32.c"
int b32_5to8(int in ) 
{ 


  {
#line 97
  return ((int )cb32[in & 31]);
}
}
#line 100 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base32.c"
int b32_8to5(int in ) 
{ 


  {
  {
#line 103
  base32_reverse_init();
  }
#line 104
  return ((int )rev32[in]);
}
}
#line 107 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base32.c"
static int base32_encode(char *buf , size_t *buflen , void const   *data , size_t size ) 
{ 
  unsigned char *udata ;
  int iout ;
  int iin ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 119
  udata = (unsigned char *)data;
#line 120
  iout = 0;
#line 121
  iin = 0;
  {
#line 127
  while (1) {
    while_continue: /* CIL Label */ ;
#line 128
    if ((size_t )iout >= *buflen) {
#line 129
      goto while_break;
    } else
#line 128
    if ((size_t )iin >= size) {
#line 129
      goto while_break;
    }
#line 130
    *(buf + iout) = (char )cb32[((int )*(udata + iin) & 248) >> 3];
#line 131
    iout ++;
#line 133
    if ((size_t )iout >= *buflen) {
#line 134
      iout --;
#line 135
      goto while_break;
    } else
#line 133
    if ((size_t )iin >= size) {
#line 134
      iout --;
#line 135
      goto while_break;
    }
#line 137
    if ((size_t )(iin + 1) < size) {
#line 137
      tmp = ((int )*(udata + (iin + 1)) & 192) >> 6;
    } else {
#line 137
      tmp = 0;
    }
#line 137
    *(buf + iout) = (char )cb32[(((int )*(udata + iin) & 7) << 2) | tmp];
#line 140
    iin ++;
#line 141
    iout ++;
#line 143
    if ((size_t )iout >= *buflen) {
#line 144
      goto while_break;
    } else
#line 143
    if ((size_t )iin >= size) {
#line 144
      goto while_break;
    }
#line 145
    *(buf + iout) = (char )cb32[((int )*(udata + iin) & 62) >> 1];
#line 146
    iout ++;
#line 148
    if ((size_t )iout >= *buflen) {
#line 149
      iout --;
#line 150
      goto while_break;
    } else
#line 148
    if ((size_t )iin >= size) {
#line 149
      iout --;
#line 150
      goto while_break;
    }
#line 152
    if ((size_t )(iin + 1) < size) {
#line 152
      tmp___0 = ((int )*(udata + (iin + 1)) & 240) >> 4;
    } else {
#line 152
      tmp___0 = 0;
    }
#line 152
    *(buf + iout) = (char )cb32[(((int )*(udata + iin) & 1) << 4) | tmp___0];
#line 155
    iin ++;
#line 156
    iout ++;
#line 158
    if ((size_t )iout >= *buflen) {
#line 159
      goto while_break;
    } else
#line 158
    if ((size_t )iin >= size) {
#line 159
      goto while_break;
    }
#line 160
    if ((size_t )(iin + 1) < size) {
#line 160
      tmp___1 = ((int )*(udata + (iin + 1)) & 128) >> 7;
    } else {
#line 160
      tmp___1 = 0;
    }
#line 160
    *(buf + iout) = (char )cb32[(((int )*(udata + iin) & 15) << 1) | tmp___1];
#line 163
    iin ++;
#line 164
    iout ++;
#line 166
    if ((size_t )iout >= *buflen) {
#line 167
      goto while_break;
    } else
#line 166
    if ((size_t )iin >= size) {
#line 167
      goto while_break;
    }
#line 168
    *(buf + iout) = (char )cb32[((int )*(udata + iin) & 124) >> 2];
#line 169
    iout ++;
#line 171
    if ((size_t )iout >= *buflen) {
#line 172
      iout --;
#line 173
      goto while_break;
    } else
#line 171
    if ((size_t )iin >= size) {
#line 172
      iout --;
#line 173
      goto while_break;
    }
#line 175
    if ((size_t )(iin + 1) < size) {
#line 175
      tmp___2 = ((int )*(udata + (iin + 1)) & 224) >> 5;
    } else {
#line 175
      tmp___2 = 0;
    }
#line 175
    *(buf + iout) = (char )cb32[(((int )*(udata + iin) & 3) << 3) | tmp___2];
#line 178
    iin ++;
#line 179
    iout ++;
#line 181
    if ((size_t )iout >= *buflen) {
#line 182
      goto while_break;
    } else
#line 181
    if ((size_t )iin >= size) {
#line 182
      goto while_break;
    }
#line 183
    *(buf + iout) = (char )cb32[(int )*(udata + iin) & 31];
#line 184
    iin ++;
#line 185
    iout ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 188
  *(buf + iout) = (char )'\000';
#line 191
  *buflen = (size_t )iin;
#line 193
  return (iout);
}
}
#line 198 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base32.c"
static int base32_decode(void *buf , size_t *buflen , char const   *str , size_t slen ) 
{ 
  unsigned char *ubuf ;
  int iout ;
  int iin ;

  {
  {
#line 212
  ubuf = (unsigned char *)buf;
#line 213
  iout = 0;
#line 214
  iin = 0;
#line 216
  base32_reverse_init();
  }
  {
#line 221
  while (1) {
    while_continue: /* CIL Label */ ;
#line 222
    if ((size_t )iout >= *buflen) {
#line 224
      goto while_break;
    } else
#line 222
    if ((size_t )(iin + 1) >= slen) {
#line 224
      goto while_break;
    } else
#line 222
    if ((int const   )*(str + iin) == 0) {
#line 224
      goto while_break;
    } else
#line 222
    if ((int const   )*(str + (iin + 1)) == 0) {
#line 224
      goto while_break;
    }
#line 225
    *(ubuf + iout) = (unsigned char )((((int )rev32[(int )*(str + iin)] & 31) << 3) | (((int )rev32[(int )*(str + (iin + 1))] & 28) >> 2));
#line 227
    iin ++;
#line 228
    iout ++;
#line 230
    if ((size_t )iout >= *buflen) {
#line 233
      goto while_break;
    } else
#line 230
    if ((size_t )(iin + 2) >= slen) {
#line 233
      goto while_break;
    } else
#line 230
    if ((int const   )*(str + iin) == 0) {
#line 233
      goto while_break;
    } else
#line 230
    if ((int const   )*(str + (iin + 1)) == 0) {
#line 233
      goto while_break;
    } else
#line 230
    if ((int const   )*(str + (iin + 2)) == 0) {
#line 233
      goto while_break;
    }
#line 234
    *(ubuf + iout) = (unsigned char )(((((int )rev32[(int )*(str + iin)] & 3) << 6) | (((int )rev32[(int )*(str + (iin + 1))] & 31) << 1)) | (((int )rev32[(int )*(str + (iin + 2))] & 16) >> 4));
#line 237
    iin += 2;
#line 238
    iout ++;
#line 240
    if ((size_t )iout >= *buflen) {
#line 242
      goto while_break;
    } else
#line 240
    if ((size_t )(iin + 1) >= slen) {
#line 242
      goto while_break;
    } else
#line 240
    if ((int const   )*(str + iin) == 0) {
#line 242
      goto while_break;
    } else
#line 240
    if ((int const   )*(str + (iin + 1)) == 0) {
#line 242
      goto while_break;
    }
#line 243
    *(ubuf + iout) = (unsigned char )((((int )rev32[(int )*(str + iin)] & 15) << 4) | (((int )rev32[(int )*(str + (iin + 1))] & 30) >> 1));
#line 245
    iin ++;
#line 246
    iout ++;
#line 248
    if ((size_t )iout >= *buflen) {
#line 251
      goto while_break;
    } else
#line 248
    if ((size_t )(iin + 2) >= slen) {
#line 251
      goto while_break;
    } else
#line 248
    if ((int const   )*(str + iin) == 0) {
#line 251
      goto while_break;
    } else
#line 248
    if ((int const   )*(str + (iin + 1)) == 0) {
#line 251
      goto while_break;
    } else
#line 248
    if ((int const   )*(str + (iin + 2)) == 0) {
#line 251
      goto while_break;
    }
#line 252
    *(ubuf + iout) = (unsigned char )(((((int )rev32[(int )*(str + iin)] & 1) << 7) | (((int )rev32[(int )*(str + (iin + 1))] & 31) << 2)) | (((int )rev32[(int )*(str + (iin + 2))] & 24) >> 3));
#line 255
    iin += 2;
#line 256
    iout ++;
#line 258
    if ((size_t )iout >= *buflen) {
#line 260
      goto while_break;
    } else
#line 258
    if ((size_t )(iin + 1) >= slen) {
#line 260
      goto while_break;
    } else
#line 258
    if ((int const   )*(str + iin) == 0) {
#line 260
      goto while_break;
    } else
#line 258
    if ((int const   )*(str + (iin + 1)) == 0) {
#line 260
      goto while_break;
    }
#line 261
    *(ubuf + iout) = (unsigned char )((((int )rev32[(int )*(str + iin)] & 7) << 5) | ((int )rev32[(int )*(str + (iin + 1))] & 31));
#line 263
    iin += 2;
#line 264
    iout ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 267
  *(ubuf + iout) = (unsigned char )'\000';
#line 269
  return (iout);
}
}
#line 176 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 348
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2), __leaf__)) strtok)(char * __restrict  __s ,
                                                                                               char const   * __restrict  __delim ) ;
#line 483 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 21 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/read.c"
static int readname_loop(char *packet , int packetlen , char **src , char *dst , size_t length ,
                         size_t loop ) 
{ 
  char *dummy ;
  char *s ;
  char *d ;
  int len ;
  int offset ;
  char c ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 31
  if (loop <= 0UL) {
#line 32
    return (0);
  }
#line 34
  len = 0;
#line 35
  s = *src;
#line 36
  d = dst;
  {
#line 37
  while (1) {
    while_continue: /* CIL Label */ ;
#line 37
    if (*s) {
#line 37
      if (! ((size_t )len < length - 2UL)) {
#line 37
        goto while_break;
      }
    } else {
#line 37
      goto while_break;
    }
#line 38
    tmp = s;
#line 38
    s ++;
#line 38
    c = *tmp;
#line 41
    if (((int )c & 192) == 192) {
#line 42
      offset = (((int )*(s + -1) & 63) << 8) | ((int )*(s + 0) & 255);
#line 43
      if (offset > packetlen) {
#line 44
        if (len == 0) {
#line 46
          return (0);
        } else {
#line 49
          goto while_break;
        }
      }
      {
#line 52
      dummy = packet + offset;
#line 53
      tmp___0 = readname_loop(packet, packetlen, & dummy, d, length - (size_t )len,
                              loop - 1UL);
#line 53
      len += tmp___0;
      }
#line 54
      goto end;
    }
    {
#line 57
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 57
      if (c) {
#line 57
        if (! ((size_t )len < length - 1UL)) {
#line 57
          goto while_break___0;
        }
      } else {
#line 57
        goto while_break___0;
      }
#line 58
      tmp___1 = d;
#line 58
      d ++;
#line 58
      tmp___2 = s;
#line 58
      s ++;
#line 58
      *tmp___1 = *tmp___2;
#line 59
      len ++;
#line 61
      c = (char )((int )c - 1);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 64
    if ((size_t )len >= length - 1UL) {
#line 65
      goto while_break;
    }
#line 68
    if ((int )*s != 0) {
#line 69
      tmp___3 = d;
#line 69
      d ++;
#line 69
      *tmp___3 = (char )'.';
#line 70
      len ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 73
  tmp___4 = len;
#line 73
  len ++;
#line 73
  *(dst + tmp___4) = (char )'\000';
  end: 
#line 76
  *src = s + 1;
#line 77
  return (len);
}
}
#line 80 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/read.c"
int readname(char *packet , int packetlen , char **src , char *dst , size_t length ) 
{ 
  int tmp ;

  {
  {
#line 83
  tmp = readname_loop(packet, packetlen, src, dst, length, (size_t )10);
  }
#line 83
  return (tmp);
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/read.c"
int readshort(char *packet , char **src , short *dst ) 
{ 
  unsigned char *p ;

  {
#line 91
  p = (unsigned char *)*src;
#line 92
  *dst = (short )(((int )*(p + 0) << 8) | (int )*(p + 1));
#line 94
  *src += sizeof(short );
#line 95
  return ((int )sizeof(short ));
}
}
#line 98 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/read.c"
int readlong(char *packet , char **src , uint32_t *dst ) 
{ 
  unsigned char *p ;

  {
#line 104
  p = (unsigned char *)*src;
#line 106
  *dst = ((((uint32_t )*(p + 0) << 24) | ((uint32_t )*(p + 1) << 16)) | ((uint32_t )*(p + 2) << 8)) | (uint32_t )*(p + 3);
#line 111
  *src += sizeof(uint32_t );
#line 112
  return ((int )sizeof(uint32_t ));
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/read.c"
int readdata(char *packet , char **src , char *dst , size_t len ) 
{ 


  {
#line 118
  if (len < 0UL) {
#line 119
    return (0);
  }
  {
#line 121
  memcpy((void */* __restrict  */)dst, (void const   */* __restrict  */)*src, len);
#line 123
  *src += len;
  }
#line 125
  return ((int )len);
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/read.c"
int readtxtbin(char *packet , char **src , size_t srcremain , char *dst , size_t dstremain ) 
{ 
  unsigned char *uc ;
  int tocopy ;
  int dstused ;

  {
#line 133
  dstused = 0;
  {
#line 135
  while (1) {
    while_continue: /* CIL Label */ ;
#line 135
    if (! (srcremain > 0UL)) {
#line 135
      goto while_break;
    }
#line 137
    uc = (unsigned char *)*src;
#line 138
    tocopy = (int )*uc;
#line 139
    (*src) ++;
#line 140
    srcremain --;
#line 142
    if ((size_t )tocopy > srcremain) {
#line 143
      return (0);
    }
#line 144
    if ((size_t )tocopy > dstremain) {
#line 145
      return (0);
    }
    {
#line 147
    memcpy((void */* __restrict  */)dst, (void const   */* __restrict  */)*src, (size_t )tocopy);
#line 148
    dst += tocopy;
#line 149
    *src += tocopy;
#line 150
    srcremain -= (size_t )tocopy;
#line 151
    dstremain -= (size_t )tocopy;
#line 152
    dstused += tocopy;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 154
  return (dstused);
}
}
#line 157 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/read.c"
int putname(char **buf , size_t buflen , char const   *host ) 
{ 
  char *word ;
  int left ;
  char *h ;
  char *p ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  char *tmp___6 ;

  {
  {
#line 165
  h = strdup(host);
#line 166
  left = (int )buflen;
#line 167
  p = *buf;
#line 169
  word = strtok((char */* __restrict  */)h, (char const   */* __restrict  */)".");
  }
  {
#line 170
  while (1) {
    while_continue: /* CIL Label */ ;
#line 170
    if (! word) {
#line 170
      goto while_break;
    }
    {
#line 171
    tmp = strlen((char const   *)word);
    }
#line 171
    if (tmp > 63UL) {
      {
#line 172
      free((void *)h);
      }
#line 173
      return (-1);
    } else {
      {
#line 171
      tmp___0 = strlen((char const   *)word);
      }
#line 171
      if (tmp___0 > (size_t )left) {
        {
#line 172
        free((void *)h);
        }
#line 173
        return (-1);
      }
    }
    {
#line 176
    tmp___1 = strlen((char const   *)word);
#line 176
    left = (int )((size_t )left - (tmp___1 + 1UL));
#line 177
    tmp___2 = p;
#line 177
    p ++;
#line 177
    tmp___3 = strlen((char const   *)word);
#line 177
    *tmp___2 = (char )tmp___3;
#line 178
    tmp___4 = strlen((char const   *)word);
#line 178
    memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)word, tmp___4);
#line 179
    tmp___5 = strlen((char const   *)word);
#line 179
    p += tmp___5;
#line 181
    word = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)".");
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 184
  tmp___6 = p;
#line 184
  p ++;
#line 184
  *tmp___6 = (char)0;
#line 186
  free((void *)h);
#line 188
  *buf = p;
  }
#line 189
  return ((int )(buflen - (size_t )left));
}
}
#line 192 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/read.c"
int putbyte(char **dst , unsigned char value ) 
{ 


  {
#line 195
  *(*dst) = (char )value;
#line 196
  (*dst) ++;
#line 198
  return ((int )sizeof(char ));
}
}
#line 201 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/read.c"
int putshort(char **dst , unsigned short value ) 
{ 
  unsigned char *p ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;

  {
#line 206
  p = (unsigned char *)*dst;
#line 208
  tmp = p;
#line 208
  p ++;
#line 208
  *tmp = (unsigned char )((int )value >> 8);
#line 209
  tmp___0 = p;
#line 209
  p ++;
#line 209
  *tmp___0 = (unsigned char )value;
#line 211
  *dst = (char *)p;
#line 212
  return ((int )sizeof(short ));
}
}
#line 215 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/read.c"
int putlong(char **dst , uint32_t value ) 
{ 
  unsigned char *p ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;

  {
#line 221
  p = (unsigned char *)*dst;
#line 223
  tmp = p;
#line 223
  p ++;
#line 223
  *tmp = (unsigned char )(value >> 24);
#line 224
  tmp___0 = p;
#line 224
  p ++;
#line 224
  *tmp___0 = (unsigned char )(value >> 16);
#line 225
  tmp___1 = p;
#line 225
  p ++;
#line 225
  *tmp___1 = (unsigned char )(value >> 8);
#line 226
  tmp___2 = p;
#line 226
  p ++;
#line 226
  *tmp___2 = (unsigned char )value;
#line 228
  *dst = (char *)p;
#line 229
  return ((int )sizeof(uint32_t ));
}
}
#line 232 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/read.c"
int putdata(char **dst , char *data , size_t len ) 
{ 


  {
#line 235
  if (len < 0UL) {
#line 236
    return (0);
  }
  {
#line 238
  memcpy((void */* __restrict  */)*dst, (void const   */* __restrict  */)data, len);
#line 240
  *dst += len;
  }
#line 241
  return ((int )len);
}
}
#line 244 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/read.c"
int puttxtbin(char **buf , size_t bufremain , char *from , size_t fromremain ) 
{ 
  unsigned char uc ;
  unsigned char *ucp ;
  char *cp ;
  int tocopy ;
  int bufused ;

  {
#line 248
  ucp = & uc;
#line 249
  cp = (char *)ucp;
#line 251
  bufused = 0;
  {
#line 253
  while (1) {
    while_continue: /* CIL Label */ ;
#line 253
    if (! (fromremain > 0UL)) {
#line 253
      goto while_break;
    }
#line 255
    tocopy = (int )fromremain;
#line 256
    if (tocopy > 252) {
#line 257
      tocopy = 252;
    }
#line 258
    if ((size_t )(tocopy + 1) > bufremain) {
#line 259
      return (-1);
    }
    {
#line 261
    uc = (unsigned char )tocopy;
#line 262
    *(*buf) = *cp;
#line 263
    (*buf) ++;
#line 264
    bufremain --;
#line 265
    bufused ++;
#line 267
    memcpy((void */* __restrict  */)*buf, (void const   */* __restrict  */)from, (size_t )tocopy);
#line 268
    *buf += tocopy;
#line 269
    from += tocopy;
#line 270
    bufremain -= (size_t )tocopy;
#line 271
    fromremain -= (size_t )tocopy;
#line 272
    bufused += tocopy;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 274
  return (bufused);
}
}
#line 20 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base64.h"
struct encoder *get_base64_encoder(void) ;
#line 30 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base64.c"
static char const   cb64[65]  = 
#line 30 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base64.c"
  {      (char const   )'a',      (char const   )'b',      (char const   )'c',      (char const   )'d', 
        (char const   )'e',      (char const   )'f',      (char const   )'g',      (char const   )'h', 
        (char const   )'i',      (char const   )'j',      (char const   )'k',      (char const   )'l', 
        (char const   )'m',      (char const   )'n',      (char const   )'o',      (char const   )'p', 
        (char const   )'q',      (char const   )'r',      (char const   )'s',      (char const   )'t', 
        (char const   )'u',      (char const   )'v',      (char const   )'w',      (char const   )'x', 
        (char const   )'y',      (char const   )'z',      (char const   )'A',      (char const   )'B', 
        (char const   )'C',      (char const   )'D',      (char const   )'E',      (char const   )'F', 
        (char const   )'G',      (char const   )'H',      (char const   )'I',      (char const   )'J', 
        (char const   )'K',      (char const   )'L',      (char const   )'M',      (char const   )'N', 
        (char const   )'O',      (char const   )'P',      (char const   )'Q',      (char const   )'R', 
        (char const   )'S',      (char const   )'T',      (char const   )'U',      (char const   )'V', 
        (char const   )'W',      (char const   )'X',      (char const   )'Y',      (char const   )'Z', 
        (char const   )'-',      (char const   )'0',      (char const   )'1',      (char const   )'2', 
        (char const   )'3',      (char const   )'4',      (char const   )'5',      (char const   )'6', 
        (char const   )'7',      (char const   )'8',      (char const   )'9',      (char const   )'+', 
        (char const   )'\000'};
#line 32 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base64.c"
static unsigned char rev64[256]  ;
#line 33 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base64.c"
static int reverse_init___0  =    0;
#line 35
static int base64_encode(char *buf , size_t *buflen , void const   *data , size_t size ) ;
#line 36
static int base64_decode(void *buf , size_t *buflen , char const   *str , size_t slen ) ;
#line 37
static int base64_handles_dots(void) ;
#line 38
static int base64_blksize_raw(void) ;
#line 39
static int base64_blksize_enc(void) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base64.c"
static struct encoder base64_encoder  =    {{(char )'B', (char )'a', (char )'s', (char )'e', (char )'6', (char )'4', (char )'\000'},
    & base64_encode, & base64_decode, & base64_handles_dots, & base64_handles_dots,
    & base64_blksize_raw, & base64_blksize_enc};
#line 52 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base64.c"
struct encoder *get_base64_encoder(void) 
{ 


  {
#line 55
  return (& base64_encoder);
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base64.c"
static int base64_handles_dots(void) 
{ 


  {
#line 61
  return (0);
}
}
#line 64 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base64.c"
static int base64_blksize_raw(void) 
{ 


  {
#line 67
  return (3);
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base64.c"
static int base64_blksize_enc(void) 
{ 


  {
#line 73
  return (4);
}
}
#line 76 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base64.c"
__inline static void base64_reverse_init(void) 
{ 
  int i ;
  unsigned char c ;

  {
#line 82
  if (! reverse_init___0) {
    {
#line 83
    memset((void *)(rev64), 0, (size_t )256);
#line 84
    i = 0;
    }
    {
#line 84
    while (1) {
      while_continue: /* CIL Label */ ;
#line 84
      if (! (i < 64)) {
#line 84
        goto while_break;
      }
#line 85
      c = (unsigned char )cb64[i];
#line 86
      rev64[(int )c] = (unsigned char )i;
#line 84
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 88
    reverse_init___0 = 1;
  }
#line 90
  return;
}
}
#line 92 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base64.c"
static int base64_encode(char *buf , size_t *buflen , void const   *data , size_t size ) 
{ 
  unsigned char *udata ;
  int iout ;
  int iin ;
  int tmp ;
  int tmp___0 ;

  {
#line 104
  udata = (unsigned char *)data;
#line 105
  iout = 0;
#line 106
  iin = 0;
  {
#line 112
  while (1) {
    while_continue: /* CIL Label */ ;
#line 113
    if ((size_t )iout >= *buflen) {
#line 114
      goto while_break;
    } else
#line 113
    if ((size_t )iin >= size) {
#line 114
      goto while_break;
    }
#line 115
    *(buf + iout) = (char )cb64[((int )*(udata + iin) & 252) >> 2];
#line 116
    iout ++;
#line 118
    if ((size_t )iout >= *buflen) {
#line 119
      iout --;
#line 120
      goto while_break;
    } else
#line 118
    if ((size_t )iin >= size) {
#line 119
      iout --;
#line 120
      goto while_break;
    }
#line 122
    if ((size_t )(iin + 1) < size) {
#line 122
      tmp = ((int )*(udata + (iin + 1)) & 240) >> 4;
    } else {
#line 122
      tmp = 0;
    }
#line 122
    *(buf + iout) = (char )cb64[(((int )*(udata + iin) & 3) << 4) | tmp];
#line 125
    iin ++;
#line 126
    iout ++;
#line 128
    if ((size_t )iout >= *buflen) {
#line 129
      goto while_break;
    } else
#line 128
    if ((size_t )iin >= size) {
#line 129
      goto while_break;
    }
#line 130
    if ((size_t )(iin + 1) < size) {
#line 130
      tmp___0 = ((int )*(udata + (iin + 1)) & 192) >> 6;
    } else {
#line 130
      tmp___0 = 0;
    }
#line 130
    *(buf + iout) = (char )cb64[(((int )*(udata + iin) & 15) << 2) | tmp___0];
#line 133
    iin ++;
#line 134
    iout ++;
#line 136
    if ((size_t )iout >= *buflen) {
#line 137
      goto while_break;
    } else
#line 136
    if ((size_t )iin >= size) {
#line 137
      goto while_break;
    }
#line 138
    *(buf + iout) = (char )cb64[(int )*(udata + iin) & 63];
#line 139
    iin ++;
#line 140
    iout ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 143
  *(buf + iout) = (char )'\000';
#line 146
  *buflen = (size_t )iin;
#line 148
  return (iout);
}
}
#line 153 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base64.c"
static int base64_decode(void *buf , size_t *buflen , char const   *str , size_t slen ) 
{ 
  unsigned char *ubuf ;
  int iout ;
  int iin ;

  {
  {
#line 167
  ubuf = (unsigned char *)buf;
#line 168
  iout = 0;
#line 169
  iin = 0;
#line 171
  base64_reverse_init();
  }
  {
#line 176
  while (1) {
    while_continue: /* CIL Label */ ;
#line 177
    if ((size_t )iout >= *buflen) {
#line 179
      goto while_break;
    } else
#line 177
    if ((size_t )(iin + 1) >= slen) {
#line 179
      goto while_break;
    } else
#line 177
    if ((int const   )*(str + iin) == 0) {
#line 179
      goto while_break;
    } else
#line 177
    if ((int const   )*(str + (iin + 1)) == 0) {
#line 179
      goto while_break;
    }
#line 180
    *(ubuf + iout) = (unsigned char )((((int )rev64[(int )*(str + iin)] & 63) << 2) | (((int )rev64[(int )*(str + (iin + 1))] & 48) >> 4));
#line 182
    iin ++;
#line 183
    iout ++;
#line 185
    if ((size_t )iout >= *buflen) {
#line 187
      goto while_break;
    } else
#line 185
    if ((size_t )(iin + 1) >= slen) {
#line 187
      goto while_break;
    } else
#line 185
    if ((int const   )*(str + iin) == 0) {
#line 187
      goto while_break;
    } else
#line 185
    if ((int const   )*(str + (iin + 1)) == 0) {
#line 187
      goto while_break;
    }
#line 188
    *(ubuf + iout) = (unsigned char )((((int )rev64[(int )*(str + iin)] & 15) << 4) | (((int )rev64[(int )*(str + (iin + 1))] & 60) >> 2));
#line 190
    iin ++;
#line 191
    iout ++;
#line 193
    if ((size_t )iout >= *buflen) {
#line 195
      goto while_break;
    } else
#line 193
    if ((size_t )(iin + 1) >= slen) {
#line 195
      goto while_break;
    } else
#line 193
    if ((int const   )*(str + iin) == 0) {
#line 195
      goto while_break;
    } else
#line 193
    if ((int const   )*(str + (iin + 1)) == 0) {
#line 195
      goto while_break;
    }
#line 196
    *(ubuf + iout) = (unsigned char )((((int )rev64[(int )*(str + iin)] & 3) << 6) | ((int )rev64[(int )*(str + (iin + 1))] & 63));
#line 198
    iin += 2;
#line 199
    iout ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 202
  *(ubuf + iout) = (unsigned char )'\000';
#line 204
  return (iout);
}
}
#line 20 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base128.h"
struct encoder *get_base128_encoder(void) ;
#line 45 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base128.c"
static unsigned char const   cb128[129]  = 
#line 45 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base128.c"
  {      (unsigned char const   )'a',      (unsigned char const   )'b',      (unsigned char const   )'c',      (unsigned char const   )'d', 
        (unsigned char const   )'e',      (unsigned char const   )'f',      (unsigned char const   )'g',      (unsigned char const   )'h', 
        (unsigned char const   )'i',      (unsigned char const   )'j',      (unsigned char const   )'k',      (unsigned char const   )'l', 
        (unsigned char const   )'m',      (unsigned char const   )'n',      (unsigned char const   )'o',      (unsigned char const   )'p', 
        (unsigned char const   )'q',      (unsigned char const   )'r',      (unsigned char const   )'s',      (unsigned char const   )'t', 
        (unsigned char const   )'u',      (unsigned char const   )'v',      (unsigned char const   )'w',      (unsigned char const   )'x', 
        (unsigned char const   )'y',      (unsigned char const   )'z',      (unsigned char const   )'A',      (unsigned char const   )'B', 
        (unsigned char const   )'C',      (unsigned char const   )'D',      (unsigned char const   )'E',      (unsigned char const   )'F', 
        (unsigned char const   )'G',      (unsigned char const   )'H',      (unsigned char const   )'I',      (unsigned char const   )'J', 
        (unsigned char const   )'K',      (unsigned char const   )'L',      (unsigned char const   )'M',      (unsigned char const   )'N', 
        (unsigned char const   )'O',      (unsigned char const   )'P',      (unsigned char const   )'Q',      (unsigned char const   )'R', 
        (unsigned char const   )'S',      (unsigned char const   )'T',      (unsigned char const   )'U',      (unsigned char const   )'V', 
        (unsigned char const   )'W',      (unsigned char const   )'X',      (unsigned char const   )'Y',      (unsigned char const   )'Z', 
        (unsigned char const   )'0',      (unsigned char const   )'1',      (unsigned char const   )'2',      (unsigned char const   )'3', 
        (unsigned char const   )'4',      (unsigned char const   )'5',      (unsigned char const   )'6',      (unsigned char const   )'7', 
        (unsigned char const   )'8',      (unsigned char const   )'9',      (unsigned char const   )'\274',      (unsigned char const   )'\275', 
        (unsigned char const   )'\276',      (unsigned char const   )'\277',      (unsigned char const   )'\300',      (unsigned char const   )'\301', 
        (unsigned char const   )'\302',      (unsigned char const   )'\303',      (unsigned char const   )'\304',      (unsigned char const   )'\305', 
        (unsigned char const   )'\306',      (unsigned char const   )'\307',      (unsigned char const   )'\310',      (unsigned char const   )'\311', 
        (unsigned char const   )'\312',      (unsigned char const   )'\313',      (unsigned char const   )'\314',      (unsigned char const   )'\315', 
        (unsigned char const   )'\316',      (unsigned char const   )'\317',      (unsigned char const   )'\320',      (unsigned char const   )'\321', 
        (unsigned char const   )'\322',      (unsigned char const   )'\323',      (unsigned char const   )'\324',      (unsigned char const   )'\325', 
        (unsigned char const   )'\326',      (unsigned char const   )'\327',      (unsigned char const   )'\330',      (unsigned char const   )'\331', 
        (unsigned char const   )'\332',      (unsigned char const   )'\333',      (unsigned char const   )'\334',      (unsigned char const   )'\335', 
        (unsigned char const   )'\336',      (unsigned char const   )'\337',      (unsigned char const   )'\340',      (unsigned char const   )'\341', 
        (unsigned char const   )'\342',      (unsigned char const   )'\343',      (unsigned char const   )'\344',      (unsigned char const   )'\345', 
        (unsigned char const   )'\346',      (unsigned char const   )'\347',      (unsigned char const   )'\350',      (unsigned char const   )'\351', 
        (unsigned char const   )'\352',      (unsigned char const   )'\353',      (unsigned char const   )'\354',      (unsigned char const   )'\355', 
        (unsigned char const   )'\356',      (unsigned char const   )'\357',      (unsigned char const   )'\360',      (unsigned char const   )'\361', 
        (unsigned char const   )'\362',      (unsigned char const   )'\363',      (unsigned char const   )'\364',      (unsigned char const   )'\365', 
        (unsigned char const   )'\366',      (unsigned char const   )'\367',      (unsigned char const   )'\370',      (unsigned char const   )'\371', 
        (unsigned char const   )'\372',      (unsigned char const   )'\373',      (unsigned char const   )'\374',      (unsigned char const   )'\375', 
        (unsigned char const   )'\000'};
#line 52 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base128.c"
static unsigned char rev128[256]  ;
#line 53 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base128.c"
static int reverse_init___1  =    0;
#line 55
static int base128_encode(char *buf , size_t *buflen , void const   *data , size_t size ) ;
#line 56
static int base128_decode(void *buf , size_t *buflen , char const   *str , size_t slen ) ;
#line 57
static int base128_handles_dots(void) ;
#line 58
static int base128_blksize_raw(void) ;
#line 59
static int base128_blksize_enc(void) ;
#line 61 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base128.c"
static struct encoder base128_encoder  =    {{(char )'B', (char )'a', (char )'s', (char )'e', (char )'1', (char )'2', (char )'8',
     (char )'\000'}, & base128_encode, & base128_decode, & base128_handles_dots, & base128_handles_dots,
    & base128_blksize_raw, & base128_blksize_enc};
#line 72 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base128.c"
struct encoder *get_base128_encoder(void) 
{ 


  {
#line 75
  return (& base128_encoder);
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base128.c"
static int base128_handles_dots(void) 
{ 


  {
#line 81
  return (0);
}
}
#line 84 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base128.c"
static int base128_blksize_raw(void) 
{ 


  {
#line 87
  return (7);
}
}
#line 90 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base128.c"
static int base128_blksize_enc(void) 
{ 


  {
#line 93
  return (8);
}
}
#line 96 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base128.c"
__inline static void base128_reverse_init(void) 
{ 
  int i ;
  unsigned char c ;

  {
#line 102
  if (! reverse_init___1) {
    {
#line 103
    memset((void *)(rev128), 0, (size_t )256);
#line 104
    i = 0;
    }
    {
#line 104
    while (1) {
      while_continue: /* CIL Label */ ;
#line 104
      if (! (i < 128)) {
#line 104
        goto while_break;
      }
#line 105
      c = (unsigned char )cb128[i];
#line 106
      rev128[(int )c] = (unsigned char )i;
#line 104
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 108
    reverse_init___1 = 1;
  }
#line 110
  return;
}
}
#line 112 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base128.c"
static int base128_encode(char *buf , size_t *buflen , void const   *data , size_t size ) 
{ 
  unsigned char *ubuf ;
  unsigned char *udata ;
  int iout ;
  int iin ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 124
  ubuf = (unsigned char *)buf;
#line 125
  udata = (unsigned char *)data;
#line 126
  iout = 0;
#line 127
  iin = 0;
  {
#line 133
  while (1) {
    while_continue: /* CIL Label */ ;
#line 134
    if ((size_t )iout >= *buflen) {
#line 135
      goto while_break;
    } else
#line 134
    if ((size_t )iin >= size) {
#line 135
      goto while_break;
    }
#line 136
    *(ubuf + iout) = (unsigned char )cb128[((int )*(udata + iin) & 254) >> 1];
#line 137
    iout ++;
#line 139
    if ((size_t )iout >= *buflen) {
#line 140
      iout --;
#line 141
      goto while_break;
    } else
#line 139
    if ((size_t )iin >= size) {
#line 140
      iout --;
#line 141
      goto while_break;
    }
#line 143
    if ((size_t )(iin + 1) < size) {
#line 143
      tmp = ((int )*(udata + (iin + 1)) & 252) >> 2;
    } else {
#line 143
      tmp = 0;
    }
#line 143
    *(ubuf + iout) = (unsigned char )cb128[(((int )*(udata + iin) & 1) << 6) | tmp];
#line 146
    iin ++;
#line 147
    iout ++;
#line 149
    if ((size_t )iout >= *buflen) {
#line 150
      goto while_break;
    } else
#line 149
    if ((size_t )iin >= size) {
#line 150
      goto while_break;
    }
#line 151
    if ((size_t )(iin + 1) < size) {
#line 151
      tmp___0 = ((int )*(udata + (iin + 1)) & 248) >> 3;
    } else {
#line 151
      tmp___0 = 0;
    }
#line 151
    *(ubuf + iout) = (unsigned char )cb128[(((int )*(udata + iin) & 3) << 5) | tmp___0];
#line 154
    iin ++;
#line 155
    iout ++;
#line 157
    if ((size_t )iout >= *buflen) {
#line 158
      goto while_break;
    } else
#line 157
    if ((size_t )iin >= size) {
#line 158
      goto while_break;
    }
#line 159
    if ((size_t )(iin + 1) < size) {
#line 159
      tmp___1 = ((int )*(udata + (iin + 1)) & 240) >> 4;
    } else {
#line 159
      tmp___1 = 0;
    }
#line 159
    *(ubuf + iout) = (unsigned char )cb128[(((int )*(udata + iin) & 7) << 4) | tmp___1];
#line 162
    iin ++;
#line 163
    iout ++;
#line 165
    if ((size_t )iout >= *buflen) {
#line 166
      goto while_break;
    } else
#line 165
    if ((size_t )iin >= size) {
#line 166
      goto while_break;
    }
#line 167
    if ((size_t )(iin + 1) < size) {
#line 167
      tmp___2 = ((int )*(udata + (iin + 1)) & 224) >> 5;
    } else {
#line 167
      tmp___2 = 0;
    }
#line 167
    *(ubuf + iout) = (unsigned char )cb128[(((int )*(udata + iin) & 15) << 3) | tmp___2];
#line 170
    iin ++;
#line 171
    iout ++;
#line 173
    if ((size_t )iout >= *buflen) {
#line 174
      goto while_break;
    } else
#line 173
    if ((size_t )iin >= size) {
#line 174
      goto while_break;
    }
#line 175
    if ((size_t )(iin + 1) < size) {
#line 175
      tmp___3 = ((int )*(udata + (iin + 1)) & 192) >> 6;
    } else {
#line 175
      tmp___3 = 0;
    }
#line 175
    *(ubuf + iout) = (unsigned char )cb128[(((int )*(udata + iin) & 31) << 2) | tmp___3];
#line 178
    iin ++;
#line 179
    iout ++;
#line 181
    if ((size_t )iout >= *buflen) {
#line 182
      goto while_break;
    } else
#line 181
    if ((size_t )iin >= size) {
#line 182
      goto while_break;
    }
#line 183
    if ((size_t )(iin + 1) < size) {
#line 183
      tmp___4 = ((int )*(udata + (iin + 1)) & 128) >> 7;
    } else {
#line 183
      tmp___4 = 0;
    }
#line 183
    *(ubuf + iout) = (unsigned char )cb128[(((int )*(udata + iin) & 63) << 1) | tmp___4];
#line 186
    iin ++;
#line 187
    iout ++;
#line 189
    if ((size_t )iout >= *buflen) {
#line 190
      goto while_break;
    } else
#line 189
    if ((size_t )iin >= size) {
#line 190
      goto while_break;
    }
#line 191
    *(ubuf + iout) = (unsigned char )cb128[(int )*(udata + iin) & 127];
#line 192
    iin ++;
#line 193
    iout ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 196
  *(ubuf + iout) = (unsigned char )'\000';
#line 199
  *buflen = (size_t )iin;
#line 201
  return (iout);
}
}
#line 206 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base128.c"
static int base128_decode(void *buf , size_t *buflen , char const   *str , size_t slen ) 
{ 
  unsigned char *ustr ;
  unsigned char *ubuf ;
  int iout ;
  int iin ;

  {
  {
#line 220
  ustr = (unsigned char *)str;
#line 221
  ubuf = (unsigned char *)buf;
#line 222
  iout = 0;
#line 223
  iin = 0;
#line 225
  base128_reverse_init();
  }
  {
#line 230
  while (1) {
    while_continue: /* CIL Label */ ;
#line 231
    if ((size_t )iout >= *buflen) {
#line 233
      goto while_break;
    } else
#line 231
    if ((size_t )(iin + 1) >= slen) {
#line 233
      goto while_break;
    } else
#line 231
    if ((int const   )*(str + iin) == 0) {
#line 233
      goto while_break;
    } else
#line 231
    if ((int const   )*(str + (iin + 1)) == 0) {
#line 233
      goto while_break;
    }
#line 234
    *(ubuf + iout) = (unsigned char )((((int )rev128[(int )*(ustr + iin)] & 127) << 1) | (((int )rev128[(int )*(ustr + (iin + 1))] & 64) >> 6));
#line 236
    iin ++;
#line 237
    iout ++;
#line 239
    if ((size_t )iout >= *buflen) {
#line 241
      goto while_break;
    } else
#line 239
    if ((size_t )(iin + 1) >= slen) {
#line 241
      goto while_break;
    } else
#line 239
    if ((int const   )*(str + iin) == 0) {
#line 241
      goto while_break;
    } else
#line 239
    if ((int const   )*(str + (iin + 1)) == 0) {
#line 241
      goto while_break;
    }
#line 242
    *(ubuf + iout) = (unsigned char )((((int )rev128[(int )*(ustr + iin)] & 63) << 2) | (((int )rev128[(int )*(ustr + (iin + 1))] & 96) >> 5));
#line 244
    iin ++;
#line 245
    iout ++;
#line 247
    if ((size_t )iout >= *buflen) {
#line 249
      goto while_break;
    } else
#line 247
    if ((size_t )(iin + 1) >= slen) {
#line 249
      goto while_break;
    } else
#line 247
    if ((int const   )*(str + iin) == 0) {
#line 249
      goto while_break;
    } else
#line 247
    if ((int const   )*(str + (iin + 1)) == 0) {
#line 249
      goto while_break;
    }
#line 250
    *(ubuf + iout) = (unsigned char )((((int )rev128[(int )*(ustr + iin)] & 31) << 3) | (((int )rev128[(int )*(ustr + (iin + 1))] & 112) >> 4));
#line 252
    iin ++;
#line 253
    iout ++;
#line 255
    if ((size_t )iout >= *buflen) {
#line 257
      goto while_break;
    } else
#line 255
    if ((size_t )(iin + 1) >= slen) {
#line 257
      goto while_break;
    } else
#line 255
    if ((int const   )*(str + iin) == 0) {
#line 257
      goto while_break;
    } else
#line 255
    if ((int const   )*(str + (iin + 1)) == 0) {
#line 257
      goto while_break;
    }
#line 258
    *(ubuf + iout) = (unsigned char )((((int )rev128[(int )*(ustr + iin)] & 15) << 4) | (((int )rev128[(int )*(ustr + (iin + 1))] & 120) >> 3));
#line 260
    iin ++;
#line 261
    iout ++;
#line 263
    if ((size_t )iout >= *buflen) {
#line 265
      goto while_break;
    } else
#line 263
    if ((size_t )(iin + 1) >= slen) {
#line 265
      goto while_break;
    } else
#line 263
    if ((int const   )*(str + iin) == 0) {
#line 265
      goto while_break;
    } else
#line 263
    if ((int const   )*(str + (iin + 1)) == 0) {
#line 265
      goto while_break;
    }
#line 266
    *(ubuf + iout) = (unsigned char )((((int )rev128[(int )*(ustr + iin)] & 7) << 5) | (((int )rev128[(int )*(ustr + (iin + 1))] & 124) >> 2));
#line 268
    iin ++;
#line 269
    iout ++;
#line 271
    if ((size_t )iout >= *buflen) {
#line 273
      goto while_break;
    } else
#line 271
    if ((size_t )(iin + 1) >= slen) {
#line 273
      goto while_break;
    } else
#line 271
    if ((int const   )*(str + iin) == 0) {
#line 273
      goto while_break;
    } else
#line 271
    if ((int const   )*(str + (iin + 1)) == 0) {
#line 273
      goto while_break;
    }
#line 274
    *(ubuf + iout) = (unsigned char )((((int )rev128[(int )*(ustr + iin)] & 3) << 6) | (((int )rev128[(int )*(ustr + (iin + 1))] & 126) >> 1));
#line 276
    iin ++;
#line 277
    iout ++;
#line 279
    if ((size_t )iout >= *buflen) {
#line 281
      goto while_break;
    } else
#line 279
    if ((size_t )(iin + 1) >= slen) {
#line 281
      goto while_break;
    } else
#line 279
    if ((int const   )*(str + iin) == 0) {
#line 281
      goto while_break;
    } else
#line 279
    if ((int const   )*(str + (iin + 1)) == 0) {
#line 281
      goto while_break;
    }
#line 282
    *(ubuf + iout) = (unsigned char )((((int )rev128[(int )*(ustr + iin)] & 1) << 7) | ((int )rev128[(int )*(ustr + (iin + 1))] & 127));
#line 284
    iin += 2;
#line 285
    iout ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 288
  *(ubuf + iout) = (unsigned char )'\000';
#line 290
  return (iout);
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/encoding.h"
int build_hostname(char *buf , size_t buflen , char const   *data , size_t const   datalen ,
                   char const   *topdomain___1 , struct encoder *encoder , int maxlen ) ;
#line 38
int unpack_data(char *buf , size_t buflen , char *data , size_t datalen , struct encoder *enc ) ;
#line 39
int inline_dotify(char *buf , size_t buflen ) ;
#line 40
int inline_undotify(char *buf , size_t len ) ;
#line 21 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/encoding.c"
int build_hostname(char *buf , size_t buflen , char const   *data , size_t const   datalen ,
                   char const   *topdomain___1 , struct encoder *encoder , int maxlen ) 
{ 
  int encsize ;
  size_t space ;
  char *b ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;

  {
#line 30
  if ((size_t )maxlen < buflen) {
#line 30
    tmp = (size_t )maxlen;
  } else {
#line 30
    tmp = buflen;
  }
  {
#line 30
  tmp___0 = strlen(topdomain___1);
#line 30
  space = (tmp - tmp___0) - 8UL;
#line 33
  tmp___1 = (*(encoder->places_dots))();
  }
#line 33
  if (! tmp___1) {
#line 34
    space -= space / 57UL;
  }
  {
#line 36
  memset((void *)buf, 0, buflen);
#line 38
  encsize = (*(encoder->encode))(buf, & space, (void const   *)data, (size_t )datalen);
#line 40
  tmp___2 = (*(encoder->places_dots))();
  }
#line 40
  if (! tmp___2) {
    {
#line 41
    inline_dotify(buf, buflen);
    }
  }
  {
#line 43
  b = buf;
#line 44
  tmp___3 = strlen((char const   *)buf);
#line 44
  b += tmp___3;
#line 47
  b --;
  }
#line 48
  if ((int )*b != 46) {
#line 49
    b ++;
#line 49
    *b = (char )'.';
  }
  {
#line 50
  b ++;
#line 53
  tmp___4 = strlen(topdomain___1);
#line 53
  strncpy((char */* __restrict  */)b, (char const   */* __restrict  */)topdomain___1,
          tmp___4 + 1UL);
  }
#line 55
  return ((int )space);
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/encoding.c"
int unpack_data(char *buf , size_t buflen , char *data , size_t datalen , struct encoder *enc ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 61
  tmp___0 = (*(enc->eats_dots))();
  }
#line 61
  if (! tmp___0) {
    {
#line 62
    tmp = inline_undotify(data, datalen);
#line 62
    datalen = (size_t )tmp;
    }
  }
  {
#line 63
  tmp___1 = (*(enc->decode))((void *)buf, & buflen, (char const   *)data, datalen);
  }
#line 63
  return (tmp___1);
}
}
#line 66 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/encoding.c"
int inline_dotify(char *buf , size_t buflen ) 
{ 
  unsigned int dots ;
  unsigned int pos ;
  unsigned int total ;
  char *reader ;
  char *writer ;
  size_t tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 74
  tmp = strlen((char const   *)buf);
#line 74
  total = (unsigned int )tmp;
#line 75
  dots = total / 57U;
#line 77
  writer = buf;
#line 78
  writer += total;
#line 79
  writer += dots;
#line 81
  total += dots;
#line 82
  tmp___0 = strlen((char const   *)buf);
  }
#line 82
  if (tmp___0 + (size_t )dots > buflen) {
#line 83
    writer = buf;
#line 84
    writer += buflen;
#line 85
    total = (unsigned int )buflen;
  }
#line 88
  reader = writer - dots;
#line 89
  pos = (unsigned int )(reader - buf) + 1U;
  {
#line 91
  while (1) {
    while_continue: /* CIL Label */ ;
#line 91
    if (! dots) {
#line 91
      goto while_break;
    }
#line 92
    tmp___1 = writer;
#line 92
    writer --;
#line 92
    tmp___2 = reader;
#line 92
    reader --;
#line 92
    *tmp___1 = *tmp___2;
#line 93
    pos --;
#line 94
    if (pos % 57U == 0U) {
#line 95
      tmp___3 = writer;
#line 95
      writer --;
#line 95
      *tmp___3 = (char )'.';
#line 96
      dots --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 101
  return ((int )total);
}
}
#line 104 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/encoding.c"
int inline_undotify(char *buf , size_t len ) 
{ 
  unsigned int pos ;
  unsigned int dots ;
  char *reader ;
  char *writer ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 111
  writer = buf;
#line 112
  reader = writer;
#line 114
  pos = 0U;
#line 115
  dots = 0U;
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
#line 117
    if (! ((size_t )pos < len)) {
#line 117
      goto while_break;
    }
#line 118
    if ((int )*reader == 46) {
#line 119
      reader ++;
#line 120
      pos ++;
#line 121
      dots ++;
#line 122
      goto while_continue;
    }
#line 124
    tmp = writer;
#line 124
    writer ++;
#line 124
    tmp___0 = reader;
#line 124
    reader ++;
#line 124
    *tmp = *tmp___0;
#line 125
    pos ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 129
  return ((int )(len - (size_t )dots));
}
}
#line 79 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/md5.h"
void md5_init(md5_state_t *pms ) ;
#line 82
void md5_append(md5_state_t *pms , md5_byte_t const   *data , int nbytes ) ;
#line 85
void md5_finish(md5_state_t *pms , md5_byte_t *digest ) ;
#line 154 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/md5.c"
static void md5_process(md5_state_t *pms , md5_byte_t const   *data ) ;
#line 154 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/md5.c"
static int const   w  =    (int const   )1;
#line 131 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/md5.c"
static void md5_process(md5_state_t *pms , md5_byte_t const   *data ) 
{ 
  md5_word_t a ;
  md5_word_t b ;
  md5_word_t c ;
  md5_word_t d ;
  md5_word_t t ;
  md5_word_t xbuf[16] ;
  md5_word_t const   *X ;
  md5_byte_t const   *xp ;
  int i ;

  {
#line 134
  a = pms->abcd[0];
#line 134
  b = pms->abcd[1];
#line 134
  c = pms->abcd[2];
#line 134
  d = pms->abcd[3];
#line 156
  if (*((md5_byte_t const   *)(& w))) {
#line 164
    if (! ((data - (md5_byte_t const   *)0) & 3L)) {
#line 166
      X = (md5_word_t const   *)data;
    } else {
      {
#line 169
      memcpy((void */* __restrict  */)(xbuf), (void const   */* __restrict  */)data,
             (size_t )64);
#line 170
      X = (md5_word_t const   *)(xbuf);
      }
    }
  } else {
#line 183
    xp = data;
#line 187
    X = (md5_word_t const   *)(xbuf);
#line 191
    i = 0;
    {
#line 191
    while (1) {
      while_continue: /* CIL Label */ ;
#line 191
      if (! (i < 16)) {
#line 191
        goto while_break;
      }
#line 192
      xbuf[i] = (md5_word_t )((((int const   )*(xp + 0) + ((int const   )*(xp + 1) << 8)) + ((int const   )*(xp + 2) << 16)) + ((int const   )*(xp + 3) << 24));
#line 191
      i ++;
#line 191
      xp += 4;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 207
  t = ((a + ((b & c) | (~ b & d))) + (md5_word_t )*(X + 0)) + 3614090360U;
#line 207
  a = ((t << 7) | (t >> 25)) + b;
#line 208
  t = ((d + ((a & b) | (~ a & c))) + (md5_word_t )*(X + 1)) + 3905402710U;
#line 208
  d = ((t << 12) | (t >> 20)) + a;
#line 209
  t = ((c + ((d & a) | (~ d & b))) + (md5_word_t )*(X + 2)) + 606105819U;
#line 209
  c = ((t << 17) | (t >> 15)) + d;
#line 210
  t = ((b + ((c & d) | (~ c & a))) + (md5_word_t )*(X + 3)) + 3250441966U;
#line 210
  b = ((t << 22) | (t >> 10)) + c;
#line 211
  t = ((a + ((b & c) | (~ b & d))) + (md5_word_t )*(X + 4)) + 4118548399U;
#line 211
  a = ((t << 7) | (t >> 25)) + b;
#line 212
  t = ((d + ((a & b) | (~ a & c))) + (md5_word_t )*(X + 5)) + 1200080426U;
#line 212
  d = ((t << 12) | (t >> 20)) + a;
#line 213
  t = ((c + ((d & a) | (~ d & b))) + (md5_word_t )*(X + 6)) + 2821735955U;
#line 213
  c = ((t << 17) | (t >> 15)) + d;
#line 214
  t = ((b + ((c & d) | (~ c & a))) + (md5_word_t )*(X + 7)) + 4249261313U;
#line 214
  b = ((t << 22) | (t >> 10)) + c;
#line 215
  t = ((a + ((b & c) | (~ b & d))) + (md5_word_t )*(X + 8)) + 1770035416U;
#line 215
  a = ((t << 7) | (t >> 25)) + b;
#line 216
  t = ((d + ((a & b) | (~ a & c))) + (md5_word_t )*(X + 9)) + 2336552879U;
#line 216
  d = ((t << 12) | (t >> 20)) + a;
#line 217
  t = ((c + ((d & a) | (~ d & b))) + (md5_word_t )*(X + 10)) + 4294925233U;
#line 217
  c = ((t << 17) | (t >> 15)) + d;
#line 218
  t = ((b + ((c & d) | (~ c & a))) + (md5_word_t )*(X + 11)) + 2304563134U;
#line 218
  b = ((t << 22) | (t >> 10)) + c;
#line 219
  t = ((a + ((b & c) | (~ b & d))) + (md5_word_t )*(X + 12)) + 1804603682U;
#line 219
  a = ((t << 7) | (t >> 25)) + b;
#line 220
  t = ((d + ((a & b) | (~ a & c))) + (md5_word_t )*(X + 13)) + 4254626195U;
#line 220
  d = ((t << 12) | (t >> 20)) + a;
#line 221
  t = ((c + ((d & a) | (~ d & b))) + (md5_word_t )*(X + 14)) + 2792965006U;
#line 221
  c = ((t << 17) | (t >> 15)) + d;
#line 222
  t = ((b + ((c & d) | (~ c & a))) + (md5_word_t )*(X + 15)) + 1236535329U;
#line 222
  b = ((t << 22) | (t >> 10)) + c;
#line 233
  t = ((a + ((b & d) | (c & ~ d))) + (md5_word_t )*(X + 1)) + 4129170786U;
#line 233
  a = ((t << 5) | (t >> 27)) + b;
#line 234
  t = ((d + ((a & c) | (b & ~ c))) + (md5_word_t )*(X + 6)) + 3225465664U;
#line 234
  d = ((t << 9) | (t >> 23)) + a;
#line 235
  t = ((c + ((d & b) | (a & ~ b))) + (md5_word_t )*(X + 11)) + 643717713U;
#line 235
  c = ((t << 14) | (t >> 18)) + d;
#line 236
  t = ((b + ((c & a) | (d & ~ a))) + (md5_word_t )*(X + 0)) + 3921069994U;
#line 236
  b = ((t << 20) | (t >> 12)) + c;
#line 237
  t = ((a + ((b & d) | (c & ~ d))) + (md5_word_t )*(X + 5)) + 3593408605U;
#line 237
  a = ((t << 5) | (t >> 27)) + b;
#line 238
  t = ((d + ((a & c) | (b & ~ c))) + (md5_word_t )*(X + 10)) + 38016083U;
#line 238
  d = ((t << 9) | (t >> 23)) + a;
#line 239
  t = ((c + ((d & b) | (a & ~ b))) + (md5_word_t )*(X + 15)) + 3634488961U;
#line 239
  c = ((t << 14) | (t >> 18)) + d;
#line 240
  t = ((b + ((c & a) | (d & ~ a))) + (md5_word_t )*(X + 4)) + 3889429448U;
#line 240
  b = ((t << 20) | (t >> 12)) + c;
#line 241
  t = ((a + ((b & d) | (c & ~ d))) + (md5_word_t )*(X + 9)) + 568446438U;
#line 241
  a = ((t << 5) | (t >> 27)) + b;
#line 242
  t = ((d + ((a & c) | (b & ~ c))) + (md5_word_t )*(X + 14)) + 3275163606U;
#line 242
  d = ((t << 9) | (t >> 23)) + a;
#line 243
  t = ((c + ((d & b) | (a & ~ b))) + (md5_word_t )*(X + 3)) + 4107603335U;
#line 243
  c = ((t << 14) | (t >> 18)) + d;
#line 244
  t = ((b + ((c & a) | (d & ~ a))) + (md5_word_t )*(X + 8)) + 1163531501U;
#line 244
  b = ((t << 20) | (t >> 12)) + c;
#line 245
  t = ((a + ((b & d) | (c & ~ d))) + (md5_word_t )*(X + 13)) + 2850285829U;
#line 245
  a = ((t << 5) | (t >> 27)) + b;
#line 246
  t = ((d + ((a & c) | (b & ~ c))) + (md5_word_t )*(X + 2)) + 4243563512U;
#line 246
  d = ((t << 9) | (t >> 23)) + a;
#line 247
  t = ((c + ((d & b) | (a & ~ b))) + (md5_word_t )*(X + 7)) + 1735328473U;
#line 247
  c = ((t << 14) | (t >> 18)) + d;
#line 248
  t = ((b + ((c & a) | (d & ~ a))) + (md5_word_t )*(X + 12)) + 2368359562U;
#line 248
  b = ((t << 20) | (t >> 12)) + c;
#line 259
  t = ((a + ((b ^ c) ^ d)) + (md5_word_t )*(X + 5)) + 4294588738U;
#line 259
  a = ((t << 4) | (t >> 28)) + b;
#line 260
  t = ((d + ((a ^ b) ^ c)) + (md5_word_t )*(X + 8)) + 2272392833U;
#line 260
  d = ((t << 11) | (t >> 21)) + a;
#line 261
  t = ((c + ((d ^ a) ^ b)) + (md5_word_t )*(X + 11)) + 1839030562U;
#line 261
  c = ((t << 16) | (t >> 16)) + d;
#line 262
  t = ((b + ((c ^ d) ^ a)) + (md5_word_t )*(X + 14)) + 4259657740U;
#line 262
  b = ((t << 23) | (t >> 9)) + c;
#line 263
  t = ((a + ((b ^ c) ^ d)) + (md5_word_t )*(X + 1)) + 2763975236U;
#line 263
  a = ((t << 4) | (t >> 28)) + b;
#line 264
  t = ((d + ((a ^ b) ^ c)) + (md5_word_t )*(X + 4)) + 1272893353U;
#line 264
  d = ((t << 11) | (t >> 21)) + a;
#line 265
  t = ((c + ((d ^ a) ^ b)) + (md5_word_t )*(X + 7)) + 4139469664U;
#line 265
  c = ((t << 16) | (t >> 16)) + d;
#line 266
  t = ((b + ((c ^ d) ^ a)) + (md5_word_t )*(X + 10)) + 3200236656U;
#line 266
  b = ((t << 23) | (t >> 9)) + c;
#line 267
  t = ((a + ((b ^ c) ^ d)) + (md5_word_t )*(X + 13)) + 681279174U;
#line 267
  a = ((t << 4) | (t >> 28)) + b;
#line 268
  t = ((d + ((a ^ b) ^ c)) + (md5_word_t )*(X + 0)) + 3936430074U;
#line 268
  d = ((t << 11) | (t >> 21)) + a;
#line 269
  t = ((c + ((d ^ a) ^ b)) + (md5_word_t )*(X + 3)) + 3572445317U;
#line 269
  c = ((t << 16) | (t >> 16)) + d;
#line 270
  t = ((b + ((c ^ d) ^ a)) + (md5_word_t )*(X + 6)) + 76029189U;
#line 270
  b = ((t << 23) | (t >> 9)) + c;
#line 271
  t = ((a + ((b ^ c) ^ d)) + (md5_word_t )*(X + 9)) + 3654602809U;
#line 271
  a = ((t << 4) | (t >> 28)) + b;
#line 272
  t = ((d + ((a ^ b) ^ c)) + (md5_word_t )*(X + 12)) + 3873151461U;
#line 272
  d = ((t << 11) | (t >> 21)) + a;
#line 273
  t = ((c + ((d ^ a) ^ b)) + (md5_word_t )*(X + 15)) + 530742520U;
#line 273
  c = ((t << 16) | (t >> 16)) + d;
#line 274
  t = ((b + ((c ^ d) ^ a)) + (md5_word_t )*(X + 2)) + 3299628645U;
#line 274
  b = ((t << 23) | (t >> 9)) + c;
#line 285
  t = ((a + (c ^ (b | ~ d))) + (md5_word_t )*(X + 0)) + 4096336452U;
#line 285
  a = ((t << 6) | (t >> 26)) + b;
#line 286
  t = ((d + (b ^ (a | ~ c))) + (md5_word_t )*(X + 7)) + 1126891415U;
#line 286
  d = ((t << 10) | (t >> 22)) + a;
#line 287
  t = ((c + (a ^ (d | ~ b))) + (md5_word_t )*(X + 14)) + 2878612391U;
#line 287
  c = ((t << 15) | (t >> 17)) + d;
#line 288
  t = ((b + (d ^ (c | ~ a))) + (md5_word_t )*(X + 5)) + 4237533241U;
#line 288
  b = ((t << 21) | (t >> 11)) + c;
#line 289
  t = ((a + (c ^ (b | ~ d))) + (md5_word_t )*(X + 12)) + 1700485571U;
#line 289
  a = ((t << 6) | (t >> 26)) + b;
#line 290
  t = ((d + (b ^ (a | ~ c))) + (md5_word_t )*(X + 3)) + 2399980690U;
#line 290
  d = ((t << 10) | (t >> 22)) + a;
#line 291
  t = ((c + (a ^ (d | ~ b))) + (md5_word_t )*(X + 10)) + 4293915773U;
#line 291
  c = ((t << 15) | (t >> 17)) + d;
#line 292
  t = ((b + (d ^ (c | ~ a))) + (md5_word_t )*(X + 1)) + 2240044497U;
#line 292
  b = ((t << 21) | (t >> 11)) + c;
#line 293
  t = ((a + (c ^ (b | ~ d))) + (md5_word_t )*(X + 8)) + 1873313359U;
#line 293
  a = ((t << 6) | (t >> 26)) + b;
#line 294
  t = ((d + (b ^ (a | ~ c))) + (md5_word_t )*(X + 15)) + 4264355552U;
#line 294
  d = ((t << 10) | (t >> 22)) + a;
#line 295
  t = ((c + (a ^ (d | ~ b))) + (md5_word_t )*(X + 6)) + 2734768916U;
#line 295
  c = ((t << 15) | (t >> 17)) + d;
#line 296
  t = ((b + (d ^ (c | ~ a))) + (md5_word_t )*(X + 13)) + 1309151649U;
#line 296
  b = ((t << 21) | (t >> 11)) + c;
#line 297
  t = ((a + (c ^ (b | ~ d))) + (md5_word_t )*(X + 4)) + 4149444226U;
#line 297
  a = ((t << 6) | (t >> 26)) + b;
#line 298
  t = ((d + (b ^ (a | ~ c))) + (md5_word_t )*(X + 11)) + 3174756917U;
#line 298
  d = ((t << 10) | (t >> 22)) + a;
#line 299
  t = ((c + (a ^ (d | ~ b))) + (md5_word_t )*(X + 2)) + 718787259U;
#line 299
  c = ((t << 15) | (t >> 17)) + d;
#line 300
  t = ((b + (d ^ (c | ~ a))) + (md5_word_t )*(X + 9)) + 3951481745U;
#line 300
  b = ((t << 21) | (t >> 11)) + c;
#line 306
  pms->abcd[0] += a;
#line 307
  pms->abcd[1] += b;
#line 308
  pms->abcd[2] += c;
#line 309
  pms->abcd[3] += d;
#line 310
  return;
}
}
#line 312 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/md5.c"
void md5_init(md5_state_t *pms ) 
{ 
  md5_word_t tmp ;

  {
#line 315
  tmp = (md5_word_t )0;
#line 315
  pms->count[1] = tmp;
#line 315
  pms->count[0] = tmp;
#line 316
  pms->abcd[0] = (md5_word_t )1732584193;
#line 317
  pms->abcd[1] = 4023233417U;
#line 318
  pms->abcd[2] = 2562383102U;
#line 319
  pms->abcd[3] = (md5_word_t )271733878;
#line 320
  return;
}
}
#line 322 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/md5.c"
void md5_append(md5_state_t *pms , md5_byte_t const   *data , int nbytes ) 
{ 
  md5_byte_t const   *p ;
  int left ;
  int offset ;
  md5_word_t nbits ;
  int copy ;
  int tmp ;

  {
#line 325
  p = data;
#line 326
  left = nbytes;
#line 327
  offset = (int )((pms->count[0] >> 3) & 63U);
#line 328
  nbits = (md5_word_t )(nbytes << 3);
#line 330
  if (nbytes <= 0) {
#line 331
    return;
  }
#line 334
  pms->count[1] += (md5_word_t )(nbytes >> 29);
#line 335
  pms->count[0] += nbits;
#line 336
  if (pms->count[0] < nbits) {
#line 337
    (pms->count[1]) ++;
  }
#line 340
  if (offset) {
#line 341
    if (offset + nbytes > 64) {
#line 341
      tmp = 64 - offset;
    } else {
#line 341
      tmp = nbytes;
    }
    {
#line 341
    copy = tmp;
#line 343
    memcpy((void */* __restrict  */)(pms->buf + offset), (void const   */* __restrict  */)p,
           (size_t )copy);
    }
#line 344
    if (offset + copy < 64) {
#line 345
      return;
    }
    {
#line 346
    p += copy;
#line 347
    left -= copy;
#line 348
    md5_process(pms, (md5_byte_t const   *)(pms->buf));
    }
  }
  {
#line 352
  while (1) {
    while_continue: /* CIL Label */ ;
#line 352
    if (! (left >= 64)) {
#line 352
      goto while_break;
    }
    {
#line 353
    md5_process(pms, p);
#line 352
    p += 64;
#line 352
    left -= 64;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 356
  if (left) {
    {
#line 357
    memcpy((void */* __restrict  */)(pms->buf), (void const   */* __restrict  */)p,
           (size_t )left);
    }
  }
#line 358
  return;
}
}
#line 363 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/md5.c"
static md5_byte_t const   pad[64]  = 
#line 363
  {      (md5_byte_t const   )128,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0};
#line 360 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/md5.c"
void md5_finish(md5_state_t *pms , md5_byte_t *digest ) 
{ 
  md5_byte_t data[8] ;
  int i ;

  {
#line 373
  i = 0;
  {
#line 373
  while (1) {
    while_continue: /* CIL Label */ ;
#line 373
    if (! (i < 8)) {
#line 373
      goto while_break;
    }
#line 374
    data[i] = (md5_byte_t )(pms->count[i >> 2] >> ((i & 3) << 3));
#line 373
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 376
  md5_append(pms, pad, (int )(((55U - (pms->count[0] >> 3)) & 63U) + 1U));
#line 378
  md5_append(pms, (md5_byte_t const   *)(data), 8);
#line 379
  i = 0;
  }
  {
#line 379
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 379
    if (! (i < 16)) {
#line 379
      goto while_break___0;
    }
#line 380
    *(digest + i) = (md5_byte_t )(pms->abcd[i >> 2] >> ((i & 3) << 3));
#line 379
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 381
  return;
}
}
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 46 "/usr/include/err.h"
extern  __attribute__((__noreturn__)) void ( /* format attribute */  err)(int __status ,
                                                                          char const   *__format 
                                                                          , ...) ;
#line 23 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/util.c"
static char addr[16]  ;
#line 20 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/util.c"
char *get_resolvconf_addr(void) 
{ 
  char *rv ;
  char buf[80] ;
  FILE *fp ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 29
  rv = (char *)((void *)0);
#line 31
  fp = fopen((char const   */* __restrict  */)"/etc/resolv.conf", (char const   */* __restrict  */)"r");
  }
#line 31
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 32
    err(1, "/etc/resolv.conf");
    }
  }
  {
#line 34
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 34
    tmp___0 = feof(fp);
    }
#line 34
    if (! (tmp___0 == 0)) {
#line 34
      goto while_break;
    }
    {
#line 35
    fgets((char */* __restrict  */)(buf), (int )sizeof(buf), (FILE */* __restrict  */)fp);
#line 37
    tmp = sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"nameserver %15s",
                 addr);
    }
#line 37
    if (tmp == 1) {
#line 38
      rv = addr;
#line 39
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 43
  fclose(fp);
  }
#line 67
  return (rv);
}
}
#line 312 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) __mode_t ( __attribute__((__leaf__)) umask)(__mode_t __mask ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 431
extern int scanf(char const   * __restrict  __format  , ...)  __asm__("__isoc99_scanf")  ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 432
extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) alarm)(unsigned int __seconds ) ;
#line 497
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 675
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 678
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) geteuid)(void) ;
#line 700
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setuid)(__uid_t __uid ) ;
#line 710
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) seteuid)(__uid_t __uid ) ;
#line 937
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) daemon)(int __nochdir ,
                                                                             int __noclose ) ;
#line 944
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chroot)(char const   *__path ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 66 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcgetattr)(int __fd ,
                                                                                struct termios *__termios_p ) ;
#line 70
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcsetattr)(int __fd ,
                                                                                int __optional_actions ,
                                                                                struct termios  const  *__termios_p ) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 123
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  *__addr ,
                                                                           socklen_t __len ) ;
#line 226
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void const   *__optval ,
                                                                                 socklen_t __optlen ) ;
#line 190 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void ( /* format attribute */  syslog)(int __pri , char const   *__fmt  , ...) ;
#line 32 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/common.h"
unsigned char const   raw_header[4] ;
#line 109
void check_superuser(void (*usage_fn)(void) ) ;
#line 110
int open_dns(int localport , in_addr_t listen_ip ) ;
#line 111
void close_dns(int fd ) ;
#line 113
void do_chroot(char *newroot ) ;
#line 114
void do_setcon(char *context ) ;
#line 115
void do_detach(void) ;
#line 116
void do_pidfile(char *pidfile ) ;
#line 118
void read_password(char *buf , size_t len ) ;
#line 120
int check_topdomain(char *str ) ;
#line 131
int recent_seqno(int ourseqno , int gotseqno ) ;
#line 54 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/common.c"
unsigned char const   raw_header[4]  = {      (unsigned char const   )16,      (unsigned char const   )209,      (unsigned char const   )158,      (unsigned char const   )0};
#line 102 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/common.c"
void check_superuser(void (*usage_fn)(void) ) 
{ 
  __uid_t tmp ;

  {
  {
#line 106
  tmp = geteuid();
  }
#line 106
  if (tmp != 0U) {
    {
#line 107
    warnx("Run as root and you\'ll be happy.\n");
#line 108
    (*usage_fn)();
    }
  }
#line 112
  return;
}
}
#line 114 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/common.c"
int open_dns(int localport , in_addr_t listen_ip ) 
{ 
  struct sockaddr_in addr___0 ;
  int flag ;
  int fd ;
  int tmp ;

  {
  {
#line 118
  flag = 1;
#line 121
  memset((void *)(& addr___0), 0, sizeof(addr___0));
#line 122
  addr___0.sin_family = (sa_family_t )2;
#line 123
  addr___0.sin_port = htons((uint16_t )localport);
#line 125
  addr___0.sin_addr.s_addr = listen_ip;
#line 127
  fd = socket(2, 2, 17);
  }
#line 127
  if (fd < 0) {
    {
#line 128
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"got fd %d\n",
            fd);
#line 129
    err(1, "socket");
    }
  }
  {
#line 132
  flag = 1;
#line 134
  setsockopt(fd, 1, 15, (void const   *)(& flag), (socklen_t )sizeof(flag));
#line 136
  setsockopt(fd, 1, 2, (void const   *)(& flag), (socklen_t )sizeof(flag));
#line 140
  setsockopt(fd, 0, 8, (void const   *)(& flag), (socklen_t )sizeof(flag));
#line 145
  flag = 2;
#line 146
  setsockopt(fd, 0, 10, (void const   *)(& flag), (socklen_t )sizeof(flag));
#line 149
  tmp = bind(fd, (struct sockaddr  const  *)((struct sockaddr *)(& addr___0)), (socklen_t )sizeof(addr___0));
  }
#line 149
  if (tmp < 0) {
    {
#line 150
    err(1, "bind");
    }
  }
  {
#line 152
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Opened UDP socket\n");
  }
#line 154
  return (fd);
}
}
#line 157 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/common.c"
void close_dns(int fd ) 
{ 


  {
  {
#line 160
  close(fd);
  }
#line 161
  return;
}
}
#line 163 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/common.c"
void do_chroot(char *newroot ) 
{ 
  int tmp ;
  int tmp___0 ;
  __uid_t tmp___1 ;
  __uid_t tmp___2 ;

  {
  {
#line 167
  tmp = chroot((char const   *)newroot);
  }
#line 167
  if (tmp != 0) {
    {
#line 168
    err(1, "%s", newroot);
    }
  } else {
    {
#line 167
    tmp___0 = chdir("/");
    }
#line 167
    if (tmp___0 != 0) {
      {
#line 168
      err(1, "%s", newroot);
      }
    }
  }
  {
#line 170
  tmp___1 = geteuid();
#line 170
  seteuid(tmp___1);
#line 171
  tmp___2 = getuid();
#line 171
  setuid(tmp___2);
  }
#line 175
  return;
}
}
#line 177 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/common.c"
void do_setcon(char *context ) 
{ 


  {
  {
#line 184
  warnx("No SELinux support built in");
  }
#line 186
  return;
}
}
#line 188 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/common.c"
void do_pidfile(char *pidfile ) 
{ 
  FILE *file ;
  __pid_t tmp ;

  {
  {
#line 194
  file = fopen((char const   */* __restrict  */)pidfile, (char const   */* __restrict  */)"w");
  }
#line 194
  if ((unsigned long )file == (unsigned long )((void *)0)) {
    {
#line 195
    syslog(3, "Cannot write pidfile to %s, exiting", pidfile);
#line 196
    err(1, "do_pidfile: Can not write pidfile to %s", pidfile);
    }
  } else {
    {
#line 198
    tmp = getpid();
#line 198
    fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"%d\n",
            tmp);
#line 199
    fclose(file);
    }
  }
#line 204
  return;
}
}
#line 206 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/common.c"
void do_detach(void) 
{ 


  {
  {
#line 210
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Detaching from terminal...\n");
#line 211
  daemon(0, 0);
#line 212
  umask((__mode_t )0);
#line 213
  alarm(0U);
  }
#line 217
  return;
}
}
#line 219 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/common.c"
void read_password(char *buf , size_t len ) 
{ 
  char pwd[80] ;
  struct termios old ;
  struct termios tp ;

  {
  {
#line 227
  tcgetattr(0, & tp);
#line 228
  old = tp;
#line 230
  tp.c_lflag &= 4294967287U;
#line 231
  tcsetattr(0, 0, (struct termios  const  *)(& tp));
#line 236
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Enter password: ");
#line 237
  fflush(stderr);
#line 239
  scanf((char const   */* __restrict  */)"%79s", pwd);
#line 252
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 255
  tcsetattr(0, 0, (struct termios  const  *)(& old));
#line 258
  strncpy((char */* __restrict  */)buf, (char const   */* __restrict  */)(pwd), len);
#line 259
  *(buf + (len - 1UL)) = (char )'\000';
  }
#line 260
  return;
}
}
#line 262 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/common.c"
int check_topdomain(char *str ) 
{ 
  int i ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  size_t tmp___1 ;

  {
#line 267
  if ((int )*(str + 0) == 46) {
#line 268
    return (1);
  }
#line 270
  i = 0;
  {
#line 270
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 270
    tmp___1 = strlen((char const   *)str);
    }
#line 270
    if (! ((size_t )i < tmp___1)) {
#line 270
      goto while_break;
    }
    {
#line 271
    tmp = __ctype_b_loc();
    }
#line 271
    if (! ((int const   )*(*tmp + (int )*(str + i)) & 1024)) {
      {
#line 271
      tmp___0 = __ctype_b_loc();
      }
#line 271
      if ((int const   )*(*tmp___0 + (int )*(str + i)) & 2048) {
#line 272
        goto __Cont;
      } else
#line 271
      if ((int )*(str + i) == 45) {
#line 272
        goto __Cont;
      } else
#line 271
      if ((int )*(str + i) == 46) {
#line 272
        goto __Cont;
      } else {
#line 274
        return (1);
      }
    }
    __Cont: /* CIL Label */ 
#line 270
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 276
  return (0);
}
}
#line 337 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/common.c"
int recent_seqno(int ourseqno , int gotseqno ) 
{ 
  int i ;

  {
#line 343
  i = 0;
  {
#line 343
  while (1) {
    while_continue: /* CIL Label */ ;
#line 343
    if (! (i < 4)) {
#line 343
      goto while_break;
    }
#line 344
    if (ourseqno < 0) {
#line 345
      ourseqno = 7;
    }
#line 346
    if (gotseqno == ourseqno) {
#line 347
      return (1);
    }
#line 343
    i ++;
#line 343
    ourseqno --;
  }
  while_break: /* CIL Label */ ;
  }
#line 349
  return (0);
}
}
#line 21 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base64u.h"
struct encoder *get_base64u_encoder(void) ;
#line 31 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base64u.c"
static char const   cb64___0[65]  = 
#line 31 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base64u.c"
  {      (char const   )'a',      (char const   )'b',      (char const   )'c',      (char const   )'d', 
        (char const   )'e',      (char const   )'f',      (char const   )'g',      (char const   )'h', 
        (char const   )'i',      (char const   )'j',      (char const   )'k',      (char const   )'l', 
        (char const   )'m',      (char const   )'n',      (char const   )'o',      (char const   )'p', 
        (char const   )'q',      (char const   )'r',      (char const   )'s',      (char const   )'t', 
        (char const   )'u',      (char const   )'v',      (char const   )'w',      (char const   )'x', 
        (char const   )'y',      (char const   )'z',      (char const   )'A',      (char const   )'B', 
        (char const   )'C',      (char const   )'D',      (char const   )'E',      (char const   )'F', 
        (char const   )'G',      (char const   )'H',      (char const   )'I',      (char const   )'J', 
        (char const   )'K',      (char const   )'L',      (char const   )'M',      (char const   )'N', 
        (char const   )'O',      (char const   )'P',      (char const   )'Q',      (char const   )'R', 
        (char const   )'S',      (char const   )'T',      (char const   )'U',      (char const   )'V', 
        (char const   )'W',      (char const   )'X',      (char const   )'Y',      (char const   )'Z', 
        (char const   )'-',      (char const   )'0',      (char const   )'1',      (char const   )'2', 
        (char const   )'3',      (char const   )'4',      (char const   )'5',      (char const   )'6', 
        (char const   )'7',      (char const   )'8',      (char const   )'9',      (char const   )'_', 
        (char const   )'\000'};
#line 33 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base64u.c"
static unsigned char rev64___0[256]  ;
#line 34 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base64u.c"
static int reverse_init___2  =    0;
#line 36
static int base64u_encode(char *buf , size_t *buflen , void const   *data , size_t size ) ;
#line 37
static int base64u_decode(void *buf , size_t *buflen , char const   *str , size_t slen ) ;
#line 38
static int base64u_handles_dots(void) ;
#line 39
static int base64u_blksize_raw(void) ;
#line 40
static int base64u_blksize_enc(void) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base64u.c"
static struct encoder base64u_encoder  =    {{(char )'B', (char )'a', (char )'s', (char )'e', (char )'6', (char )'4', (char )'u',
     (char )'\000'}, & base64u_encode, & base64u_decode, & base64u_handles_dots, & base64u_handles_dots,
    & base64u_blksize_raw, & base64u_blksize_enc};
#line 53 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base64u.c"
struct encoder *get_base64u_encoder(void) 
{ 


  {
#line 56
  return (& base64u_encoder);
}
}
#line 59 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base64u.c"
static int base64u_handles_dots(void) 
{ 


  {
#line 62
  return (0);
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base64u.c"
static int base64u_blksize_raw(void) 
{ 


  {
#line 68
  return (3);
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base64u.c"
static int base64u_blksize_enc(void) 
{ 


  {
#line 74
  return (4);
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base64u.c"
__inline static void base64u_reverse_init(void) 
{ 
  int i ;
  unsigned char c ;

  {
#line 83
  if (! reverse_init___2) {
    {
#line 84
    memset((void *)(rev64___0), 0, (size_t )256);
#line 85
    i = 0;
    }
    {
#line 85
    while (1) {
      while_continue: /* CIL Label */ ;
#line 85
      if (! (i < 64)) {
#line 85
        goto while_break;
      }
#line 86
      c = (unsigned char )cb64___0[i];
#line 87
      rev64___0[(int )c] = (unsigned char )i;
#line 85
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 89
    reverse_init___2 = 1;
  }
#line 91
  return;
}
}
#line 93 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base64u.c"
static int base64u_encode(char *buf , size_t *buflen , void const   *data , size_t size ) 
{ 
  unsigned char *udata ;
  int iout ;
  int iin ;
  int tmp ;
  int tmp___0 ;

  {
#line 105
  udata = (unsigned char *)data;
#line 106
  iout = 0;
#line 107
  iin = 0;
  {
#line 113
  while (1) {
    while_continue: /* CIL Label */ ;
#line 114
    if ((size_t )iout >= *buflen) {
#line 115
      goto while_break;
    } else
#line 114
    if ((size_t )iin >= size) {
#line 115
      goto while_break;
    }
#line 116
    *(buf + iout) = (char )cb64___0[((int )*(udata + iin) & 252) >> 2];
#line 117
    iout ++;
#line 119
    if ((size_t )iout >= *buflen) {
#line 120
      iout --;
#line 121
      goto while_break;
    } else
#line 119
    if ((size_t )iin >= size) {
#line 120
      iout --;
#line 121
      goto while_break;
    }
#line 123
    if ((size_t )(iin + 1) < size) {
#line 123
      tmp = ((int )*(udata + (iin + 1)) & 240) >> 4;
    } else {
#line 123
      tmp = 0;
    }
#line 123
    *(buf + iout) = (char )cb64___0[(((int )*(udata + iin) & 3) << 4) | tmp];
#line 126
    iin ++;
#line 127
    iout ++;
#line 129
    if ((size_t )iout >= *buflen) {
#line 130
      goto while_break;
    } else
#line 129
    if ((size_t )iin >= size) {
#line 130
      goto while_break;
    }
#line 131
    if ((size_t )(iin + 1) < size) {
#line 131
      tmp___0 = ((int )*(udata + (iin + 1)) & 192) >> 6;
    } else {
#line 131
      tmp___0 = 0;
    }
#line 131
    *(buf + iout) = (char )cb64___0[(((int )*(udata + iin) & 15) << 2) | tmp___0];
#line 134
    iin ++;
#line 135
    iout ++;
#line 137
    if ((size_t )iout >= *buflen) {
#line 138
      goto while_break;
    } else
#line 137
    if ((size_t )iin >= size) {
#line 138
      goto while_break;
    }
#line 139
    *(buf + iout) = (char )cb64___0[(int )*(udata + iin) & 63];
#line 140
    iin ++;
#line 141
    iout ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 144
  *(buf + iout) = (char )'\000';
#line 147
  *buflen = (size_t )iin;
#line 149
  return (iout);
}
}
#line 154 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base64u.c"
static int base64u_decode(void *buf , size_t *buflen , char const   *str , size_t slen ) 
{ 
  unsigned char *ubuf ;
  int iout ;
  int iin ;

  {
  {
#line 168
  ubuf = (unsigned char *)buf;
#line 169
  iout = 0;
#line 170
  iin = 0;
#line 172
  base64u_reverse_init();
  }
  {
#line 177
  while (1) {
    while_continue: /* CIL Label */ ;
#line 178
    if ((size_t )iout >= *buflen) {
#line 180
      goto while_break;
    } else
#line 178
    if ((size_t )(iin + 1) >= slen) {
#line 180
      goto while_break;
    } else
#line 178
    if ((int const   )*(str + iin) == 0) {
#line 180
      goto while_break;
    } else
#line 178
    if ((int const   )*(str + (iin + 1)) == 0) {
#line 180
      goto while_break;
    }
#line 181
    *(ubuf + iout) = (unsigned char )((((int )rev64___0[(int )*(str + iin)] & 63) << 2) | (((int )rev64___0[(int )*(str + (iin + 1))] & 48) >> 4));
#line 183
    iin ++;
#line 184
    iout ++;
#line 186
    if ((size_t )iout >= *buflen) {
#line 188
      goto while_break;
    } else
#line 186
    if ((size_t )(iin + 1) >= slen) {
#line 188
      goto while_break;
    } else
#line 186
    if ((int const   )*(str + iin) == 0) {
#line 188
      goto while_break;
    } else
#line 186
    if ((int const   )*(str + (iin + 1)) == 0) {
#line 188
      goto while_break;
    }
#line 189
    *(ubuf + iout) = (unsigned char )((((int )rev64___0[(int )*(str + iin)] & 15) << 4) | (((int )rev64___0[(int )*(str + (iin + 1))] & 60) >> 2));
#line 191
    iin ++;
#line 192
    iout ++;
#line 194
    if ((size_t )iout >= *buflen) {
#line 196
      goto while_break;
    } else
#line 194
    if ((size_t )(iin + 1) >= slen) {
#line 196
      goto while_break;
    } else
#line 194
    if ((int const   )*(str + iin) == 0) {
#line 196
      goto while_break;
    } else
#line 194
    if ((int const   )*(str + (iin + 1)) == 0) {
#line 196
      goto while_break;
    }
#line 197
    *(ubuf + iout) = (unsigned char )((((int )rev64___0[(int )*(str + iin)] & 3) << 6) | ((int )rev64___0[(int )*(str + (iin + 1))] & 63));
#line 199
    iin += 2;
#line 200
    iout ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 203
  *(ubuf + iout) = (unsigned char )'\000';
#line 205
  return (iout);
}
}
#line 374 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) ntohl)(uint32_t __netlong )  __attribute__((__const__)) ;
#line 377
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) htonl)(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 31 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/login.c"
void login_calculate(char *buf , int buflen , char const   *pass , int seed ) 
{ 
  unsigned char temp[32] ;
  md5_state_t ctx ;
  int *ix ;
  int i ;
  int k ;
  uint32_t tmp ;
  int *tmp___0 ;
  uint32_t tmp___1 ;

  {
#line 40
  if (buflen < 16) {
#line 41
    return;
  }
  {
#line 43
  memcpy((void */* __restrict  */)(temp), (void const   */* __restrict  */)pass, (size_t )32);
#line 44
  ix = (int *)(temp);
#line 46
  i = 0;
  }
  {
#line 46
  while (1) {
    while_continue: /* CIL Label */ ;
#line 46
    if (! (i < 8)) {
#line 46
      goto while_break;
    }
    {
#line 47
    tmp = ntohl((uint32_t )*ix);
#line 47
    k = (int )tmp;
#line 48
    k ^= seed;
#line 49
    tmp___0 = ix;
#line 49
    ix ++;
#line 49
    tmp___1 = htonl((uint32_t )k);
#line 49
    *tmp___0 = (int )tmp___1;
#line 46
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 52
  md5_init(& ctx);
#line 53
  md5_append(& ctx, (md5_byte_t const   *)(temp), 32);
#line 54
  md5_finish(& ctx, (md5_byte_t *)((unsigned char *)buf));
  }
#line 56
  return;
}
}
#line 386 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 717 "/usr/include/stdlib.h"
extern int system(char const   *__command ) ;
#line 360 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 413 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 34 "/usr/include/err.h"
extern void ( /* format attribute */  warn)(char const   *__format  , ...) ;
#line 34 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) in_addr_t ( __attribute__((__leaf__)) inet_addr)(char const   *__cp ) ;
#line 53
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) inet_ntoa)(struct in_addr __in ) ;
#line 20 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/tun.h"
int open_tun(char const   *tun_device ) ;
#line 21
void close_tun(int tun_fd ) ;
#line 22
int write_tun(int tun_fd , char *data , size_t len ) ;
#line 23
ssize_t read_tun(int tun_fd , char *buf , size_t len ) ;
#line 24
int tun_setip(char const   *ip , char const   *remoteip , int netbits ) ;
#line 25
int tun_setmtu(unsigned int const   mtu ) ;
#line 59 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/tun.c"
char if_name[250]  ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 68 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/tun.c"
int open_tun(char const   *tun_device ) 
{ 
  int i ;
  int tun_fd ;
  struct ifreq ifreq ;
  char *tunnel___0 ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int *tmp___8 ;

  {
  {
#line 74
  tunnel___0 = (char *)"/dev/net/tun";
#line 76
  tun_fd = open((char const   *)tunnel___0, 2);
  }
#line 76
  if (tun_fd < 0) {
    {
#line 77
    tmp = __errno_location();
#line 77
    tmp___0 = strerror(*tmp);
#line 77
    warn("open_tun: %s: %s", tunnel___0, tmp___0);
    }
#line 78
    return (-1);
  }
  {
#line 81
  memset((void *)(& ifreq), 0, sizeof(ifreq));
#line 83
  ifreq.ifr_ifru.ifru_flags = (short)1;
  }
#line 85
  if ((unsigned long )tun_device != (unsigned long )((void *)0)) {
    {
#line 86
    strncpy((char */* __restrict  */)(ifreq.ifr_ifrn.ifrn_name), (char const   */* __restrict  */)tun_device,
            (size_t )16);
#line 87
    ifreq.ifr_ifrn.ifrn_name[15] = (char )'\000';
#line 88
    strncpy((char */* __restrict  */)(if_name), (char const   */* __restrict  */)tun_device,
            sizeof(if_name));
#line 89
    if_name[sizeof(if_name) - 1UL] = (char )'\000';
#line 91
    tmp___1 = ioctl(tun_fd, (unsigned long )(((1U << 30) | (unsigned int )(84 << 8)) | 202U) | (sizeof(int ) << 16),
                    (void *)(& ifreq));
    }
#line 91
    if (tmp___1 != -1) {
      {
#line 92
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Opened %s\n",
              ifreq.ifr_ifrn.ifrn_name);
      }
#line 93
      return (tun_fd);
    }
    {
#line 96
    tmp___4 = __errno_location();
    }
#line 96
    if (*tmp___4 != 16) {
      {
#line 97
      tmp___2 = __errno_location();
#line 97
      tmp___3 = strerror(*tmp___2);
#line 97
      warn("open_tun: ioctl[TUNSETIFF]: %s", tmp___3);
      }
#line 98
      return (-1);
    }
  } else {
#line 101
    i = 0;
    {
#line 101
    while (1) {
      while_continue: /* CIL Label */ ;
#line 101
      if (! (i < 50)) {
#line 101
        goto while_break;
      }
      {
#line 102
      snprintf((char */* __restrict  */)(ifreq.ifr_ifrn.ifrn_name), (size_t )16, (char const   */* __restrict  */)"dns%d",
               i);
#line 104
      tmp___5 = ioctl(tun_fd, (unsigned long )(((1U << 30) | (unsigned int )(84 << 8)) | 202U) | (sizeof(int ) << 16),
                      (void *)(& ifreq));
      }
#line 104
      if (tmp___5 != -1) {
        {
#line 105
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Opened %s\n",
                ifreq.ifr_ifrn.ifrn_name);
#line 106
        snprintf((char */* __restrict  */)(if_name), sizeof(if_name), (char const   */* __restrict  */)"dns%d",
                 i);
        }
#line 107
        return (tun_fd);
      }
      {
#line 110
      tmp___8 = __errno_location();
      }
#line 110
      if (*tmp___8 != 16) {
        {
#line 111
        tmp___6 = __errno_location();
#line 111
        tmp___7 = strerror(*tmp___6);
#line 111
        warn("open_tun: ioctl[TUNSETIFF]: %s", tmp___7);
        }
#line 112
        return (-1);
      }
#line 101
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 116
    warn("open_tun: Couldn\'t set interface name");
    }
  }
  {
#line 118
  warn("error when opening tun");
  }
#line 119
  return (-1);
}
}
#line 350 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/tun.c"
void close_tun(int tun_fd ) 
{ 


  {
#line 353
  if (tun_fd >= 0) {
    {
#line 354
    close(tun_fd);
    }
  }
#line 355
  return;
}
}
#line 357 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/tun.c"
int write_tun(int tun_fd , char *data , size_t len ) 
{ 
  ssize_t tmp ;

  {
  {
#line 365
  *(data + 0) = (char)0;
#line 366
  *(data + 1) = (char)0;
#line 367
  *(data + 2) = (char)8;
#line 368
  *(data + 3) = (char)0;
#line 378
  tmp = write(tun_fd, (void const   *)data, len);
  }
#line 378
  if ((size_t )tmp != len) {
    {
#line 379
    warn("write_tun");
    }
#line 380
    return (1);
  }
#line 401
  return (0);
}
}
#line 404 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/tun.c"
ssize_t read_tun(int tun_fd , char *buf , size_t len ) 
{ 
  ssize_t tmp ;

  {
  {
#line 424
  tmp = read(tun_fd, (void *)buf, len);
  }
#line 424
  return (tmp);
}
}
#line 428 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/tun.c"
int tun_setip(char const   *ip , char const   *remoteip , int netbits ) 
{ 
  char cmdline[512] ;
  int netmask___0 ;
  struct in_addr net ;
  int i ;
  in_addr_t tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 445
  netmask___0 = 0;
#line 446
  i = 0;
  {
#line 446
  while (1) {
    while_continue: /* CIL Label */ ;
#line 446
    if (! (i < netbits)) {
#line 446
      goto while_break;
    }
#line 447
    netmask___0 = (netmask___0 << 1) | 1;
#line 446
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 449
  netmask___0 <<= 32 - netbits;
#line 450
  net.s_addr = htonl((uint32_t )netmask___0);
#line 452
  tmp = inet_addr(ip);
  }
#line 452
  if (tmp == 4294967295U) {
    {
#line 453
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid IP: %s!\n",
            ip);
    }
#line 454
    return (1);
  }
  {
#line 457
  tmp___0 = inet_ntoa(net);
#line 457
  snprintf((char */* __restrict  */)(cmdline), sizeof(cmdline), (char const   */* __restrict  */)"/sbin/ifconfig %s %s %s netmask %s",
           if_name, ip, ip, tmp___0);
#line 468
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Setting IP of %s to %s\n",
          if_name, ip);
#line 480
  tmp___1 = system((char const   *)(cmdline));
  }
#line 480
  return (tmp___1);
}
}
#line 517 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/tun.c"
int tun_setmtu(unsigned int const   mtu ) 
{ 
  char cmdline[512] ;
  int tmp ;

  {
#line 523
  if (mtu > 200U) {
#line 523
    if (mtu <= 1500U) {
      {
#line 524
      snprintf((char */* __restrict  */)(cmdline), sizeof(cmdline), (char const   */* __restrict  */)"/sbin/ifconfig %s mtu %u",
               if_name, mtu);
#line 529
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Setting MTU of %s to %u\n",
              if_name, mtu);
#line 530
      tmp = system((char const   *)(cmdline));
      }
#line 530
      return (tmp);
    } else {
      {
#line 532
      warn("MTU out of range: %u\n", mtu);
      }
    }
  } else {
    {
#line 532
    warn("MTU out of range: %u\n", mtu);
    }
  }
#line 535
  return (1);
}
}
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 376
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srand)(unsigned int __seed ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 717 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setgid)(__gid_t __gid ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 180 "/usr/include/grp.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setgroups)(size_t __n ,
                                                                                __gid_t const   *__groups ) ;
#line 116 "/usr/include/pwd.h"
extern struct passwd *getpwnam(char const   *__name ) ;
#line 20 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.h"
void client_init(void) ;
#line 21
void client_stop(void) ;
#line 23
enum connection client_get_conn(void) ;
#line 24
char const   *client_get_raw_addr(void) ;
#line 26
void client_set_nameserver(char const   *cp , int port ) ;
#line 27
void client_set_topdomain(char const   *cp ) ;
#line 28
void client_set_password(char const   *cp ) ;
#line 29
void set_qtype(char *qtype ) ;
#line 31
void set_downenc(char *encoding ) ;
#line 32
void client_set_selecttimeout(int select_timeout ) ;
#line 33
void client_set_lazymode(int lazy_mode ) ;
#line 34
void client_set_hostname_maxlen(int i ) ;
#line 36
int client_handshake(int dns_fd , int raw_mode , int autodetect_frag_size , int fragsize ) ;
#line 37
int client_tunnel(int tun_fd , int dns_fd ) ;
#line 53 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/iodine.c"
static void sighandler(int sig ) 
{ 


  {
  {
#line 56
  client_stop();
  }
#line 57
  return;
}
}
#line 61
extern char *__progname ;
#line 59 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/iodine.c"
static void usage(void) 
{ 


  {
  {
#line 63
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: %s [-v] [-h] [-f] [-r] [-u user] [-t chrootdir] [-d device] [-P password] [-m maxfragsize] [-M maxlen] [-T type] [-O enc] [-L 0|1] [-I sec] [-z context] [-F pidfile] [nameserver] topdomain\n",
          __progname);
#line 66
  exit(2);
  }
}
}
#line 69 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/iodine.c"
static void help(void) 
{ 


  {
  {
#line 73
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"iodine IP over DNS tunneling client\n");
#line 74
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: %s [-v] [-h] [-f] [-r] [-u user] [-t chrootdir] [-d device] [-P password] [-m maxfragsize] [-M maxlen] [-T type] [-O enc] [-L 0|1] [-I sec] [-z context] [-F pidfile] [nameserver] topdomain\n",
          __progname);
#line 77
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Options to try if connection doesn\'t work:\n");
#line 78
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -T force dns type: NULL, TXT, SRV, MX, CNAME, A (default: autodetect)\n");
#line 79
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -O force downstream encoding for -T other than NULL: Base32, Base64, Base64u,\n");
#line 80
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"     Base128, or (only for TXT:) Raw  (default: autodetect)\n");
#line 81
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -I max interval between requests (default 4 sec) to prevent DNS timeouts\n");
#line 82
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -L 1: use lazy mode for low-latency (default). 0: don\'t (implies -I1)\n");
#line 83
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -m max size of downstream fragments (default: autodetect)\n");
#line 84
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -M max size of upstream hostnames (~100-255, default: 255)\n");
#line 85
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -r to skip raw UDP mode attempt\n");
#line 86
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -P password used for authentication (max 32 chars will be used)\n");
#line 87
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Other options:\n");
#line 88
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -v to print version info and exit\n");
#line 89
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -h to print this help and exit\n");
#line 90
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -f to keep running in foreground\n");
#line 91
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -u name to drop privileges and run as user \'name\'\n");
#line 92
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -t dir to chroot to directory dir\n");
#line 93
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -d device to set tunnel device name\n");
#line 94
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -z context, to apply specified SELinux context after initialization\n");
#line 95
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -F pidfile to write pid to a file\n");
#line 96
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"nameserver is the IP number/hostname of the relaying nameserver. if absent, /etc/resolv.conf is used\n");
#line 97
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"topdomain is the FQDN that is delegated to the tunnel endpoint.\n");
#line 99
  exit(0);
  }
}
}
#line 102 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/iodine.c"
static void version(void) 
{ 


  {
  {
#line 104
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"iodine IP over DNS tunneling client\n");
#line 105
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"version: 0.6.0-rc1 from 2010-02-13\n");
#line 107
  exit(0);
  }
}
}
#line 110 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/iodine.c"
int main(int argc , char **argv ) 
{ 
  char *nameserv_addr ;
  char *topdomain___1 ;
  struct passwd *pw ;
  char *username ;
  char password___1[33] ;
  int foreground ;
  char *newroot ;
  char *context ;
  char *device ;
  char *pidfile ;
  int choice ;
  int tun_fd ;
  int dns_fd ;
  int max_downstream_frag_size ;
  int autodetect_frag_size ;
  int retval ;
  int raw_mode ;
  int lazymode___0 ;
  int selecttimeout___0 ;
  int hostname_maxlen___0 ;
  time_t tmp ;
  time_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  char const   *tmp___8 ;
  enum connection tmp___9 ;
  gid_t gids[1] ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
  {
#line 136
  nameserv_addr = (char *)((void *)0);
#line 137
  topdomain___1 = (char *)((void *)0);
#line 139
  pw = (struct passwd *)((void *)0);
#line 141
  username = (char *)((void *)0);
#line 142
  memset((void *)(password___1), 0, (size_t )33);
#line 143
  tmp = time((time_t *)((void *)0));
#line 143
  srand((unsigned int )tmp);
#line 144
  foreground = 0;
#line 145
  newroot = (char *)((void *)0);
#line 146
  context = (char *)((void *)0);
#line 147
  device = (char *)((void *)0);
#line 148
  pidfile = (char *)((void *)0);
#line 150
  autodetect_frag_size = 1;
#line 151
  max_downstream_frag_size = 3072;
#line 152
  retval = 0;
#line 153
  raw_mode = 1;
#line 154
  lazymode___0 = 1;
#line 155
  selecttimeout___0 = 4;
#line 156
  hostname_maxlen___0 = 255;
#line 162
  tmp___0 = time((time_t *)((void *)0));
#line 162
  srand((unsigned int )tmp___0);
#line 163
  client_init();
  }
  {
#line 173
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 173
    choice = getopt(argc, (char * const  *)argv, "vfhru:t:d:P:m:M:F:T:O:L:I:");
    }
#line 173
    if (! (choice != -1)) {
#line 173
      goto while_break;
    }
    {
#line 175
    if (choice == 118) {
#line 175
      goto case_118;
    }
#line 179
    if (choice == 102) {
#line 179
      goto case_102;
    }
#line 182
    if (choice == 104) {
#line 182
      goto case_104;
    }
#line 186
    if (choice == 114) {
#line 186
      goto case_114;
    }
#line 189
    if (choice == 117) {
#line 189
      goto case_117;
    }
#line 192
    if (choice == 116) {
#line 192
      goto case_116;
    }
#line 195
    if (choice == 100) {
#line 195
      goto case_100;
    }
#line 198
    if (choice == 80) {
#line 198
      goto case_80;
    }
#line 205
    if (choice == 109) {
#line 205
      goto case_109;
    }
#line 209
    if (choice == 77) {
#line 209
      goto case_77;
    }
#line 216
    if (choice == 122) {
#line 216
      goto case_122;
    }
#line 219
    if (choice == 70) {
#line 219
      goto case_70;
    }
#line 222
    if (choice == 84) {
#line 222
      goto case_84;
    }
#line 225
    if (choice == 79) {
#line 225
      goto case_79;
    }
#line 228
    if (choice == 76) {
#line 228
      goto case_76;
    }
#line 237
    if (choice == 73) {
#line 237
      goto case_73;
    }
#line 242
    goto switch_default;
    case_118: /* CIL Label */ 
    {
#line 176
    version();
    }
#line 178
    goto switch_break;
    case_102: /* CIL Label */ 
#line 180
    foreground = 1;
#line 181
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 183
    help();
    }
#line 185
    goto switch_break;
    case_114: /* CIL Label */ 
#line 187
    raw_mode = 0;
#line 188
    goto switch_break;
    case_117: /* CIL Label */ 
#line 190
    username = optarg;
#line 191
    goto switch_break;
    case_116: /* CIL Label */ 
#line 193
    newroot = optarg;
#line 194
    goto switch_break;
    case_100: /* CIL Label */ 
#line 196
    device = optarg;
#line 197
    goto switch_break;
    case_80: /* CIL Label */ 
    {
#line 199
    strncpy((char */* __restrict  */)(password___1), (char const   */* __restrict  */)optarg,
            sizeof(password___1));
#line 200
    password___1[sizeof(password___1) - 1UL] = (char)0;
#line 203
    tmp___1 = strlen((char const   *)optarg);
#line 203
    memset((void *)optarg, 0, tmp___1);
    }
#line 204
    goto switch_break;
    case_109: /* CIL Label */ 
    {
#line 206
    autodetect_frag_size = 0;
#line 207
    max_downstream_frag_size = atoi((char const   *)optarg);
    }
#line 208
    goto switch_break;
    case_77: /* CIL Label */ 
    {
#line 210
    hostname_maxlen___0 = atoi((char const   *)optarg);
    }
#line 211
    if (hostname_maxlen___0 > 255) {
#line 212
      hostname_maxlen___0 = 255;
    }
#line 213
    if (hostname_maxlen___0 < 10) {
#line 214
      hostname_maxlen___0 = 10;
    }
#line 215
    goto switch_break;
    case_122: /* CIL Label */ 
#line 217
    context = optarg;
#line 218
    goto switch_break;
    case_70: /* CIL Label */ 
#line 220
    pidfile = optarg;
#line 221
    goto switch_break;
    case_84: /* CIL Label */ 
    {
#line 223
    set_qtype(optarg);
    }
#line 224
    goto switch_break;
    case_79: /* CIL Label */ 
    {
#line 226
    set_downenc(optarg);
    }
#line 227
    goto switch_break;
    case_76: /* CIL Label */ 
    {
#line 229
    lazymode___0 = atoi((char const   *)optarg);
    }
#line 230
    if (lazymode___0 > 1) {
#line 231
      lazymode___0 = 1;
    }
#line 232
    if (lazymode___0 < 0) {
#line 233
      lazymode___0 = 0;
    }
#line 234
    if (! lazymode___0) {
#line 235
      selecttimeout___0 = 1;
    }
#line 236
    goto switch_break;
    case_73: /* CIL Label */ 
    {
#line 238
    selecttimeout___0 = atoi((char const   *)optarg);
    }
#line 239
    if (selecttimeout___0 < 1) {
#line 240
      selecttimeout___0 = 1;
    }
#line 241
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 243
    usage();
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 248
  check_superuser(& usage);
#line 250
  argc -= optind;
#line 251
  argv += optind;
  }
  {
#line 254
  if (argc == 1) {
#line 254
    goto case_1;
  }
#line 258
  if (argc == 2) {
#line 258
    goto case_2;
  }
#line 262
  goto switch_default___0;
  case_1: /* CIL Label */ 
  {
#line 255
  nameserv_addr = get_resolvconf_addr();
#line 256
  topdomain___1 = strdup((char const   *)*(argv + 0));
  }
#line 257
  goto switch_break___0;
  case_2: /* CIL Label */ 
  {
#line 259
  nameserv_addr = *(argv + 0);
#line 260
  topdomain___1 = strdup((char const   *)*(argv + 1));
  }
#line 261
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
  {
#line 263
  usage();
  }
  switch_break___0: /* CIL Label */ ;
  }
#line 267
  if (max_downstream_frag_size < 1) {
    {
#line 268
    warnx("Use a max frag size between 1 and 65535 bytes.\n");
#line 269
    usage();
    }
  } else
#line 267
  if (max_downstream_frag_size > 65535) {
    {
#line 268
    warnx("Use a max frag size between 1 and 65535 bytes.\n");
#line 269
    usage();
    }
  }
#line 273
  if (nameserv_addr) {
    {
#line 274
    client_set_nameserver((char const   *)nameserv_addr, 53);
    }
  } else {
    {
#line 276
    warnx("No nameserver found - not connected to any network?\n");
#line 277
    usage();
    }
  }
  {
#line 281
  tmp___3 = strlen((char const   *)topdomain___1);
  }
#line 281
  if (tmp___3 <= 128UL) {
    {
#line 282
    tmp___2 = check_topdomain(topdomain___1);
    }
#line 282
    if (tmp___2) {
      {
#line 283
      warnx("Topdomain contains invalid characters.\n");
#line 284
      usage();
      }
    }
  } else {
    {
#line 288
    warnx("Use a topdomain max 128 chars long.\n");
#line 289
    usage();
    }
  }
  {
#line 293
  client_set_selecttimeout(selecttimeout___0);
#line 294
  client_set_lazymode(lazymode___0);
#line 295
  client_set_topdomain((char const   *)topdomain___1);
#line 296
  client_set_hostname_maxlen(hostname_maxlen___0);
  }
#line 298
  if ((unsigned long )username != (unsigned long )((void *)0)) {
    {
#line 300
    pw = getpwnam((char const   *)username);
    }
#line 300
    if ((unsigned long )pw == (unsigned long )((void *)0)) {
      {
#line 301
      warnx("User %s does not exist!\n", username);
#line 302
      usage();
      }
    }
  }
  {
#line 308
  tmp___6 = strlen((char const   *)(password___1));
  }
#line 308
  if (tmp___6 == 0UL) {
    {
#line 309
    tmp___5 = getenv("IODINE_PASS");
    }
#line 309
    if ((unsigned long )((void *)0) != (unsigned long )tmp___5) {
      {
#line 310
      tmp___4 = getenv("IODINE_PASS");
#line 310
      snprintf((char */* __restrict  */)(password___1), sizeof(password___1), (char const   */* __restrict  */)"%s",
               tmp___4);
      }
    } else {
      {
#line 312
      read_password(password___1, sizeof(password___1));
      }
    }
  }
  {
#line 315
  client_set_password((char const   *)(password___1));
#line 317
  tun_fd = open_tun((char const   *)device);
  }
#line 317
  if (tun_fd == -1) {
#line 318
    retval = 1;
#line 319
    goto cleanup1;
  }
  {
#line 321
  dns_fd = open_dns(0, (in_addr_t )0);
  }
#line 321
  if (dns_fd == -1) {
#line 322
    retval = 1;
#line 323
    goto cleanup2;
  }
  {
#line 326
  signal(2, & sighandler);
#line 327
  signal(15, & sighandler);
#line 329
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Sending DNS queries for %s to %s\n",
          topdomain___1, nameserv_addr);
#line 332
  tmp___7 = client_handshake(dns_fd, raw_mode, autodetect_frag_size, max_downstream_frag_size);
  }
#line 332
  if (tmp___7) {
#line 333
    retval = 1;
#line 334
    goto cleanup2;
  }
  {
#line 337
  tmp___9 = client_get_conn();
  }
#line 337
  if ((unsigned int )tmp___9 == 0U) {
    {
#line 338
    tmp___8 = client_get_raw_addr();
#line 338
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Sending raw traffic directly to %s\n",
            tmp___8);
    }
  }
  {
#line 341
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Connection setup complete, transmitting data.\n");
  }
#line 343
  if (foreground == 0) {
    {
#line 344
    do_detach();
    }
  }
#line 346
  if ((unsigned long )pidfile != (unsigned long )((void *)0)) {
    {
#line 347
    do_pidfile(pidfile);
    }
  }
#line 349
  if ((unsigned long )newroot != (unsigned long )((void *)0)) {
    {
#line 350
    do_chroot(newroot);
    }
  }
#line 352
  if ((unsigned long )username != (unsigned long )((void *)0)) {
    {
#line 355
    gids[0] = pw->pw_gid;
#line 356
    tmp___10 = setgroups((size_t )1, (__gid_t const   *)(gids));
    }
#line 356
    if (tmp___10 < 0) {
      {
#line 357
      warnx("Could not switch to user %s!\n", username);
#line 358
      usage();
      }
    } else {
      {
#line 356
      tmp___11 = setgid(pw->pw_gid);
      }
#line 356
      if (tmp___11 < 0) {
        {
#line 357
        warnx("Could not switch to user %s!\n", username);
#line 358
        usage();
        }
      } else {
        {
#line 356
        tmp___12 = setuid(pw->pw_uid);
        }
#line 356
        if (tmp___12 < 0) {
          {
#line 357
          warnx("Could not switch to user %s!\n", username);
#line 358
          usage();
          }
        }
      }
    }
  }
#line 364
  if ((unsigned long )context != (unsigned long )((void *)0)) {
    {
#line 365
    do_setcon(context);
    }
  }
  {
#line 367
  client_tunnel(tun_fd, dns_fd);
  }
  cleanup2: 
  {
#line 370
  close_dns(dns_fd);
#line 371
  close_tun(tun_fd);
  }
  cleanup1: 
#line 374
  return (retval);
}
}
#line 124 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 374 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rand)(void) ;
#line 69 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 140
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 444 "/usr/include/unistd.h"
extern unsigned int sleep(unsigned int __seconds ) ;
#line 1174 "/usr/include/zlib.h"
extern int compress2(Bytef *dest , uLongf *destLen , Bytef const   *source , uLong sourceLen ,
                     int level ) ;
#line 1197
extern int uncompress(Bytef *dest , uLongf *destLen , Bytef const   *source , uLong sourceLen ) ;
#line 156 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern ssize_t recv(int __fd , void *__buf , size_t __n , int __flags ) ;
#line 163
extern ssize_t sendto(int __fd , void const   *__buf , size_t __n , int __flags ,
                      struct sockaddr  const  *__addr , socklen_t __addr_len ) ;
#line 174
extern ssize_t recvfrom(int __fd , void * __restrict  __buf , size_t __n , int __flags ,
                        struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 61 "/usr/include/netdb.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __h_errno_location)(void)  __attribute__((__const__)) ;
#line 95
extern  __attribute__((__nothrow__)) char const   *( __attribute__((__leaf__)) hstrerror)(int __err_num ) ;
#line 144
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 50 "/usr/include/err.h"
extern  __attribute__((__noreturn__)) void ( /* format attribute */  errx)(int __status ,
                                                                           char const   *__format 
                                                                           , ...) ;
#line 73 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) inet_aton)(char const   *__cp ,
                                                                                struct in_addr *__inp ) ;
#line 30 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.h"
char *get_qtype(void) ;
#line 56 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
static void handshake_lazyoff(int dns_fd ) ;
#line 58 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
static int running  ;
#line 59 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
static char const   *password  ;
#line 61 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
static struct sockaddr_in nameserv  ;
#line 62 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
static struct sockaddr_in raw_serv  ;
#line 63 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
static char const   *topdomain  ;
#line 65 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
static uint16_t rand_seed  ;
#line 68 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
static struct packet outpkt  ;
#line 69 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
static struct packet inpkt  ;
#line 70 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
int outchunkresent  =    0;
#line 73 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
static char userid  ;
#line 74 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
static char userid_char  ;
#line 75 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
static char userid_char2  ;
#line 78 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
static uint16_t chunkid  ;
#line 79 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
static uint16_t chunkid_prev  ;
#line 80 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
static uint16_t chunkid_prev2  ;
#line 83 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
static struct encoder *b32  ;
#line 85 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
static struct encoder *b64  ;
#line 86 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
static struct encoder *b64u  ;
#line 87 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
static struct encoder *b128  ;
#line 91 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
static struct encoder *dataenc  ;
#line 94 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
static char downenc  =    (char )' ';
#line 97 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
static unsigned short do_qtype  =    (unsigned short)65432;
#line 100 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
static enum connection conn  ;
#line 102 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
static int selecttimeout  ;
#line 103 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
static int lazymode  ;
#line 104 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
static long send_ping_soon  ;
#line 105 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
static time_t lastdownstreamtime  ;
#line 106 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
static long send_query_sendcnt  =    -1L;
#line 107 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
static long send_query_recvcnt  =    0L;
#line 108 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
static int hostname_maxlen  =    255;
#line 110 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
void client_init(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 113
  running = 1;
#line 114
  b32 = get_base32_encoder();
#line 115
  b64 = get_base64_encoder();
#line 116
  b64u = get_base64u_encoder();
#line 117
  b128 = get_base128_encoder();
#line 118
  dataenc = get_base32_encoder();
#line 119
  tmp = rand();
#line 119
  rand_seed = (uint16_t )((unsigned int )tmp & 65535U);
#line 120
  send_ping_soon = 1L;
#line 121
  conn = (enum connection )1;
#line 123
  tmp___0 = rand();
#line 123
  chunkid = (uint16_t )((unsigned int )tmp___0 & 65535U);
#line 124
  chunkid_prev = (uint16_t )0;
#line 125
  chunkid_prev2 = (uint16_t )0;
#line 127
  outpkt.len = 0;
#line 128
  outpkt.seqno = (char)0;
#line 129
  outpkt.fragment = (char)0;
#line 130
  outchunkresent = 0;
#line 131
  inpkt.len = 0;
#line 132
  inpkt.seqno = (char)0;
#line 133
  inpkt.fragment = (char)0;
  }
#line 134
  return;
}
}
#line 136 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
void client_stop(void) 
{ 


  {
#line 139
  running = 0;
#line 140
  return;
}
}
#line 142 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
enum connection client_get_conn(void) 
{ 


  {
#line 145
  return (conn);
}
}
#line 148 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
void client_set_nameserver(char const   *cp , int port ) 
{ 
  struct in_addr addr___0 ;
  struct hostent *host ;
  char const   *err___0 ;
  int i ;
  int tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 153
  tmp___3 = inet_aton(cp, & addr___0);
  }
#line 153
  if (tmp___3 != 1) {
    {
#line 157
    host = gethostbyname(cp);
    }
#line 158
    if ((unsigned long )host != (unsigned long )((void *)0)) {
      {
#line 158
      tmp___1 = __h_errno_location();
      }
#line 158
      if (*tmp___1 > 0) {
#line 159
        i = 0;
        {
#line 160
        while (1) {
          while_continue: /* CIL Label */ ;
#line 160
          if (! ((unsigned long )*(host->h_addr_list + i) != (unsigned long )((char *)0))) {
#line 160
            goto while_break;
          }
          {
#line 161
          tmp = i;
#line 161
          i ++;
#line 161
          addr___0 = *((struct in_addr *)*(host->h_addr_list + tmp));
#line 162
          tmp___0 = inet_ntoa(addr___0);
#line 162
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Resolved %s to %s\n",
                  cp, tmp___0);
          }
#line 163
          goto setaddr;
        }
        while_break: /* CIL Label */ ;
        }
      }
    }
    {
#line 167
    tmp___2 = __h_errno_location();
#line 167
    err___0 = hstrerror(*tmp___2);
#line 184
    errx(1, "error resolving nameserver \'%s\': %s", cp, err___0);
    }
  }
  setaddr: 
  {
#line 188
  memset((void *)(& nameserv), 0, sizeof(nameserv));
#line 189
  nameserv.sin_family = (sa_family_t )2;
#line 190
  nameserv.sin_port = htons((uint16_t )port);
#line 191
  nameserv.sin_addr = addr___0;
  }
#line 192
  return;
}
}
#line 194 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
void client_set_topdomain(char const   *cp ) 
{ 


  {
#line 197
  topdomain = cp;
#line 198
  return;
}
}
#line 200 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
void client_set_password(char const   *cp ) 
{ 


  {
#line 203
  password = cp;
#line 204
  return;
}
}
#line 206 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
void set_qtype(char *qtype ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 209
  tmp___4 = strcasecmp((char const   *)qtype, "NULL");
  }
#line 209
  if (tmp___4) {
    {
#line 211
    tmp___3 = strcasecmp((char const   *)qtype, "CNAME");
    }
#line 211
    if (tmp___3) {
      {
#line 213
      tmp___2 = strcasecmp((char const   *)qtype, "A");
      }
#line 213
      if (tmp___2) {
        {
#line 215
        tmp___1 = strcasecmp((char const   *)qtype, "MX");
        }
#line 215
        if (tmp___1) {
          {
#line 217
          tmp___0 = strcasecmp((char const   *)qtype, "SRV");
          }
#line 217
          if (tmp___0) {
            {
#line 219
            tmp = strcasecmp((char const   *)qtype, "TXT");
            }
#line 219
            if (! tmp) {
#line 220
              do_qtype = (unsigned short)16;
            }
          } else {
#line 218
            do_qtype = (unsigned short)33;
          }
        } else {
#line 216
          do_qtype = (unsigned short)15;
        }
      } else {
#line 214
        do_qtype = (unsigned short)1;
      }
    } else {
#line 212
      do_qtype = (unsigned short)5;
    }
  } else {
#line 210
    do_qtype = (unsigned short)10;
  }
#line 221
  return;
}
}
#line 223 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
char *get_qtype(void) 
{ 
  char *c ;

  {
#line 226
  c = (char *)"UNDEFINED";
#line 228
  if ((int )do_qtype == 10) {
#line 228
    c = (char *)"NULL";
  } else
#line 229
  if ((int )do_qtype == 5) {
#line 229
    c = (char *)"CNAME";
  } else
#line 230
  if ((int )do_qtype == 1) {
#line 230
    c = (char *)"A";
  } else
#line 231
  if ((int )do_qtype == 15) {
#line 231
    c = (char *)"MX";
  } else
#line 232
  if ((int )do_qtype == 33) {
#line 232
    c = (char *)"SRV";
  } else
#line 233
  if ((int )do_qtype == 16) {
#line 233
    c = (char *)"TXT";
  }
#line 235
  return (c);
}
}
#line 238 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
void set_downenc(char *encoding ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 241
  tmp___3 = strcasecmp((char const   *)encoding, "base32");
  }
#line 241
  if (tmp___3) {
    {
#line 243
    tmp___2 = strcasecmp((char const   *)encoding, "base64");
    }
#line 243
    if (tmp___2) {
      {
#line 245
      tmp___1 = strcasecmp((char const   *)encoding, "base64u");
      }
#line 245
      if (tmp___1) {
        {
#line 247
        tmp___0 = strcasecmp((char const   *)encoding, "base128");
        }
#line 247
        if (tmp___0) {
          {
#line 249
          tmp = strcasecmp((char const   *)encoding, "raw");
          }
#line 249
          if (! tmp) {
#line 250
            downenc = (char )'R';
          }
        } else {
#line 248
          downenc = (char )'V';
        }
      } else {
#line 246
        downenc = (char )'U';
      }
    } else {
#line 244
      downenc = (char )'S';
    }
  } else {
#line 242
    downenc = (char )'T';
  }
#line 251
  return;
}
}
#line 253 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
void client_set_selecttimeout(int select_timeout ) 
{ 


  {
#line 256
  selecttimeout = select_timeout;
#line 257
  return;
}
}
#line 259 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
void client_set_lazymode(int lazy_mode ) 
{ 


  {
#line 262
  lazymode = lazy_mode;
#line 263
  return;
}
}
#line 265 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
void client_set_hostname_maxlen(int i ) 
{ 


  {
#line 268
  if (i <= 255) {
#line 269
    hostname_maxlen = i;
  }
#line 270
  return;
}
}
#line 272 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
char const   *client_get_raw_addr(void) 
{ 
  char *tmp ;

  {
  {
#line 275
  tmp = inet_ntoa(raw_serv.sin_addr);
  }
#line 275
  return ((char const   *)tmp);
}
}
#line 278 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
static void send_query(int fd , char *hostname ) 
{ 
  char packet[4096] ;
  struct query q ;
  size_t len ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 285
  chunkid_prev2 = chunkid_prev;
#line 286
  chunkid_prev = chunkid;
#line 287
  chunkid = (uint16_t )((int )chunkid + 7727);
#line 288
  if ((int )chunkid == 0) {
#line 290
    chunkid = (uint16_t )7727;
  }
  {
#line 292
  q.id = chunkid;
#line 293
  q.type = do_qtype;
#line 295
  tmp = strlen((char const   *)hostname);
#line 295
  tmp___0 = dns_encode(packet, sizeof(packet), & q, (qr_t )0, hostname, tmp);
#line 295
  len = (size_t )tmp___0;
  }
#line 296
  if (len < 1UL) {
    {
#line 297
    warnx("dns_encode doesn\'t fit");
    }
#line 298
    return;
  }
  {
#line 305
  sendto(fd, (void const   *)(packet), len, 0, (struct sockaddr  const  *)((struct sockaddr *)(& nameserv)),
         (socklen_t )sizeof(nameserv));
  }
#line 317
  if (send_query_sendcnt >= 0L) {
#line 317
    if (send_query_sendcnt < 100L) {
#line 317
      if (lazymode) {
#line 318
        send_query_sendcnt ++;
#line 320
        if (send_query_sendcnt > 6L) {
#line 320
          if (send_query_recvcnt <= 0L) {
#line 320
            goto _L;
          } else {
#line 320
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 320
        if (send_query_sendcnt > 10L) {
#line 320
          if (4L * send_query_recvcnt < send_query_sendcnt) {
            _L: /* CIL Label */ 
#line 323
            if (selecttimeout > 1) {
              {
#line 324
              warnx("Receiving too few answers. Setting interval to 1 (-I1)");
#line 325
              selecttimeout = 1;
#line 327
              send_query_sendcnt = 0L;
#line 328
              send_query_recvcnt = 0L;
              }
            } else
#line 329
            if (lazymode) {
              {
#line 330
              warnx("Receiving too few answers. Will try to switch lazy mode off, but that may not always work any more. Start with -L0 next time on this network.");
#line 331
              lazymode = 0;
#line 332
              selecttimeout = 1;
#line 333
              handshake_lazyoff(fd);
              }
            }
          }
        }
      }
    }
  }
#line 337
  return;
}
}
#line 339 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
static void send_raw(int fd , char *buf , int buflen , int user , int cmd ) 
{ 
  char packet[4096] ;
  int len ;

  {
#line 345
  if (sizeof(packet) - 4UL < (unsigned long )buflen) {
#line 345
    len = (int )(sizeof(packet) - 4UL);
  } else {
#line 345
    len = buflen;
  }
  {
#line 347
  memcpy((void */* __restrict  */)(packet), (void const   */* __restrict  */)(raw_header),
         (size_t )4);
  }
#line 348
  if (len) {
    {
#line 349
    memcpy((void */* __restrict  */)(& packet[4]), (void const   */* __restrict  */)buf,
           (size_t )len);
    }
  }
  {
#line 352
  len += 4;
#line 353
  packet[3] = (char )(cmd | (user & 15));
#line 355
  sendto(fd, (void const   *)(packet), (size_t )len, 0, (struct sockaddr  const  *)((struct sockaddr *)(& raw_serv)),
         (socklen_t )sizeof(raw_serv));
  }
#line 356
  return;
}
}
#line 358 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
static void send_raw_data(int dns_fd ) 
{ 


  {
  {
#line 361
  send_raw(dns_fd, outpkt.data, outpkt.len, (int )userid, 32);
#line 362
  outpkt.len = 0;
  }
#line 363
  return;
}
}
#line 366 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
static void send_packet(int fd , char cmd , char const   *data , size_t const   datalen ) 
{ 
  char buf[4096] ;

  {
  {
#line 371
  buf[0] = cmd;
#line 373
  build_hostname(buf + 1, sizeof(buf) - 1UL, data, datalen, topdomain, b32, hostname_maxlen);
#line 375
  send_query(fd, buf);
  }
#line 376
  return;
}
}
#line 378 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
__inline static int is_sending(void) 
{ 


  {
#line 381
  return (outpkt.len != 0);
}
}
#line 391
static void send_chunk(int fd ) ;
#line 391 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
static int datacmc  =    0;
#line 384 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
static void send_chunk(int fd ) 
{ 
  char buf[4096] ;
  int avail ;
  int code ;
  char *p ;
  char *datacmcchars ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 392
  datacmcchars = (char *)"abcdefghijklmnopqrstuvwxyz0123456789";
#line 394
  p = outpkt.data;
#line 395
  p += outpkt.offset;
#line 396
  avail = outpkt.len - outpkt.offset;
#line 399
  outpkt.sentlen = build_hostname(buf + 5, sizeof(buf) - 5UL, (char const   *)p, (size_t const   )avail,
                                  topdomain, dataenc, hostname_maxlen);
#line 404
  buf[0] = userid_char;
#line 406
  code = (((int )outpkt.seqno & 7) << 2) | (((int )outpkt.fragment & 15) >> 2);
#line 407
  tmp = b32_5to8(code);
#line 407
  buf[1] = (char )tmp;
#line 409
  code = (((int )outpkt.fragment & 3) << 3) | ((int )inpkt.seqno & 7);
#line 410
  tmp___0 = b32_5to8(code);
#line 410
  buf[2] = (char )tmp___0;
#line 412
  code = (((int )inpkt.fragment & 15) << 1) | (outpkt.sentlen == avail);
#line 413
  tmp___1 = b32_5to8(code);
#line 413
  buf[3] = (char )tmp___1;
#line 415
  buf[4] = *(datacmcchars + datacmc);
#line 416
  datacmc ++;
  }
#line 417
  if (datacmc >= 36) {
#line 418
    datacmc = 0;
  }
  {
#line 426
  send_query(fd, buf);
  }
#line 427
  return;
}
}
#line 429 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
static void send_ping(int fd ) 
{ 
  char data[4] ;

  {
#line 432
  if ((unsigned int )conn == 1U) {
    {
#line 435
    data[0] = userid;
#line 436
    data[1] = (char )((((int )inpkt.seqno & 7) << 4) | ((int )inpkt.fragment & 15));
#line 437
    data[2] = (char )(((int )rand_seed >> 8) & 255);
#line 438
    data[3] = (char )((int )rand_seed & 255);
#line 440
    rand_seed = (uint16_t )((int )rand_seed + 1);
#line 447
    send_packet(fd, (char )'p', (char const   *)(data), (size_t const   )sizeof(data));
    }
  } else {
    {
#line 449
    send_raw(fd, (char *)((void *)0), 0, (int )userid, 48);
    }
  }
#line 451
  return;
}
}
#line 453 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
static void write_dns_error(struct query *q , int ignore_some_errors ) 
{ 


  {
#line 464
  if (! q) {
#line 464
    return;
  }
  {
#line 467
  if ((int )q->rcode == 0) {
#line 467
    goto case_0;
  }
#line 471
  if ((int )q->rcode == 1) {
#line 471
    goto case_1;
  }
#line 474
  if ((int )q->rcode == 2) {
#line 474
    goto case_2;
  }
#line 478
  if ((int )q->rcode == 3) {
#line 478
    goto case_3;
  }
#line 481
  if ((int )q->rcode == 4) {
#line 481
    goto case_4;
  }
#line 484
  if ((int )q->rcode == 5) {
#line 484
    goto case_5;
  }
#line 487
  goto switch_default;
  case_0: /* CIL Label */ 
#line 468
  if (! ignore_some_errors) {
    {
#line 469
    warnx("Got reply without error, but also without question and/or answer");
    }
  }
#line 470
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 472
  warnx("Got FORMERR as reply: server does not understand our request");
  }
#line 473
  goto switch_break;
  case_2: /* CIL Label */ 
#line 475
  if (! ignore_some_errors) {
    {
#line 476
    warnx("Got SERVFAIL as reply: server failed or recursion timeout");
    }
  }
#line 477
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 479
  warnx("Got NXDOMAIN as reply: domain does not exist");
  }
#line 480
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 482
  warnx("Got NOTIMP as reply: server does not support our request");
  }
#line 483
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 485
  warnx("Got REFUSED as reply");
  }
#line 486
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 488
  warnx("Got RCODE %u as reply", (int )q->rcode);
  }
#line 489
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 491
  return;
}
}
#line 493 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
static int dns_namedec(char *outdata , int outdatalen , char *buf , int buflen ) 
{ 
  size_t outdatalenu ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 502
  outdatalenu = (size_t )outdatalen;
  {
#line 506
  if ((int )*(buf + 0) == 72) {
#line 506
    goto case_72;
  }
#line 506
  if ((int )*(buf + 0) == 104) {
#line 506
    goto case_72;
  }
#line 516
  if ((int )*(buf + 0) == 73) {
#line 516
    goto case_73;
  }
#line 516
  if ((int )*(buf + 0) == 105) {
#line 516
    goto case_73;
  }
#line 526
  if ((int )*(buf + 0) == 74) {
#line 526
    goto case_74;
  }
#line 526
  if ((int )*(buf + 0) == 106) {
#line 526
    goto case_74;
  }
#line 536
  if ((int )*(buf + 0) == 75) {
#line 536
    goto case_75;
  }
#line 536
  if ((int )*(buf + 0) == 107) {
#line 536
    goto case_75;
  }
#line 546
  if ((int )*(buf + 0) == 84) {
#line 546
    goto case_84;
  }
#line 546
  if ((int )*(buf + 0) == 116) {
#line 546
    goto case_84;
  }
#line 553
  if ((int )*(buf + 0) == 83) {
#line 553
    goto case_83;
  }
#line 553
  if ((int )*(buf + 0) == 115) {
#line 553
    goto case_83;
  }
#line 560
  if ((int )*(buf + 0) == 85) {
#line 560
    goto case_85;
  }
#line 560
  if ((int )*(buf + 0) == 117) {
#line 560
    goto case_85;
  }
#line 567
  if ((int )*(buf + 0) == 86) {
#line 567
    goto case_86;
  }
#line 567
  if ((int )*(buf + 0) == 118) {
#line 567
    goto case_86;
  }
#line 574
  if ((int )*(buf + 0) == 82) {
#line 574
    goto case_82;
  }
#line 574
  if ((int )*(buf + 0) == 114) {
#line 574
    goto case_82;
  }
#line 581
  goto switch_default;
  case_72: /* CIL Label */ 
  case_104: /* CIL Label */ 
#line 508
  if (buflen < 5) {
#line 509
    return (0);
  }
  {
#line 512
  tmp = unpack_data(outdata, (size_t )outdatalen, buf + 1, (size_t )(buflen - 4),
                    b32);
  }
#line 512
  return (tmp);
  case_73: /* CIL Label */ 
  case_105: /* CIL Label */ 
#line 518
  if (buflen < 5) {
#line 519
    return (0);
  }
  {
#line 522
  tmp___0 = unpack_data(outdata, (size_t )outdatalen, buf + 1, (size_t )(buflen - 4),
                        b64);
  }
#line 522
  return (tmp___0);
  case_74: /* CIL Label */ 
  case_106: /* CIL Label */ 
#line 528
  if (buflen < 5) {
#line 529
    return (0);
  }
  {
#line 532
  tmp___1 = unpack_data(outdata, (size_t )outdatalen, buf + 1, (size_t )(buflen - 4),
                        b64u);
  }
#line 532
  return (tmp___1);
  case_75: /* CIL Label */ 
  case_107: /* CIL Label */ 
#line 538
  if (buflen < 5) {
#line 539
    return (0);
  }
  {
#line 542
  tmp___2 = unpack_data(outdata, (size_t )outdatalen, buf + 1, (size_t )(buflen - 4),
                        b128);
  }
#line 542
  return (tmp___2);
  case_84: /* CIL Label */ 
  case_116: /* CIL Label */ 
#line 547
  if (buflen < 2) {
#line 548
    return (0);
  }
  {
#line 550
  tmp___3 = (*(b32->decode))((void *)outdata, & outdatalenu, (char const   *)(buf + 1),
                             (size_t )(buflen - 1));
  }
#line 550
  return (tmp___3);
  case_83: /* CIL Label */ 
  case_115: /* CIL Label */ 
#line 554
  if (buflen < 2) {
#line 555
    return (0);
  }
  {
#line 557
  tmp___4 = (*(b64->decode))((void *)outdata, & outdatalenu, (char const   *)(buf + 1),
                             (size_t )(buflen - 1));
  }
#line 557
  return (tmp___4);
  case_85: /* CIL Label */ 
  case_117: /* CIL Label */ 
#line 561
  if (buflen < 2) {
#line 562
    return (0);
  }
  {
#line 564
  tmp___5 = (*(b64u->decode))((void *)outdata, & outdatalenu, (char const   *)(buf + 1),
                              (size_t )(buflen - 1));
  }
#line 564
  return (tmp___5);
  case_86: /* CIL Label */ 
  case_118: /* CIL Label */ 
#line 568
  if (buflen < 2) {
#line 569
    return (0);
  }
  {
#line 571
  tmp___6 = (*(b128->decode))((void *)outdata, & outdatalenu, (char const   *)(buf + 1),
                              (size_t )(buflen - 1));
  }
#line 571
  return (tmp___6);
  case_82: /* CIL Label */ 
  case_114: /* CIL Label */ 
#line 576
  buflen --;
#line 577
  if (buflen < outdatalen) {
#line 577
    buflen = buflen;
  } else {
#line 577
    buflen = outdatalen;
  }
  {
#line 578
  memcpy((void */* __restrict  */)outdata, (void const   */* __restrict  */)(buf + 1),
         (size_t )buflen);
  }
#line 579
  return (buflen);
  switch_default: /* CIL Label */ 
  {
#line 582
  warnx("Received unsupported encoding");
  }
#line 583
  return (0);
  switch_break: /* CIL Label */ ;
  }
#line 587
  return (0);
}
}
#line 590 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
static int read_dns_withq(int dns_fd , int tun_fd , char *buf , int buflen , struct query *q ) 
{ 
  struct sockaddr_in from ;
  char data[65536] ;
  socklen_t addrlen ;
  int r ;
  ssize_t tmp ;
  int rv ;
  int buftotal ;
  int bufoffset ;
  int dataoffset ;
  int thispartlen ;
  int dataspace ;
  int datanew ;
  size_t tmp___0 ;
  unsigned long datalen ;
  char buf___0[65536] ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 604
  addrlen = (socklen_t )sizeof(struct sockaddr );
#line 605
  tmp = recvfrom(dns_fd, (void */* __restrict  */)(data), sizeof(data), 0, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& from)),
                 (socklen_t */* __restrict  */)(& addrlen));
#line 605
  r = (int )tmp;
  }
#line 605
  if (r < 0) {
    {
#line 607
    warn("recvfrom");
    }
#line 608
    return (-1);
  }
#line 611
  if ((unsigned int )conn == 1U) {
#line 613
    if (r <= 0) {
#line 615
      return (0);
    }
    {
#line 617
    rv = dns_decode(buf, (size_t )buflen, q, (qr_t )1, data, (size_t )r);
    }
#line 618
    if (rv <= 0) {
#line 619
      return (rv);
    }
#line 621
    if ((int )q->type == 5) {
#line 621
      goto _L___0;
    } else
#line 621
    if ((int )q->type == 16) {
      _L___0: /* CIL Label */ 
      {
#line 633
      rv = dns_namedec(data, (int )sizeof(data), buf, rv);
      }
#line 635
      if (rv < buflen) {
#line 635
        rv = rv;
      } else {
#line 635
        rv = buflen;
      }
#line 636
      if (rv > 0) {
        {
#line 637
        memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)(data),
               (size_t )rv);
        }
      }
    } else
#line 639
    if ((int )q->type == 15) {
#line 639
      goto _L;
    } else
#line 639
    if ((int )q->type == 33) {
      _L: /* CIL Label */ 
#line 641
      buftotal = rv;
#line 642
      bufoffset = 0;
#line 643
      dataoffset = 0;
      {
#line 646
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 647
        tmp___0 = strlen((char const   *)buf);
#line 647
        thispartlen = (int )tmp___0;
        }
#line 648
        if (thispartlen < buftotal - bufoffset) {
#line 648
          thispartlen = thispartlen;
        } else {
#line 648
          thispartlen = buftotal - bufoffset;
        }
#line 649
        dataspace = (int )(sizeof(data) - (unsigned long )dataoffset);
#line 650
        if (thispartlen <= 0) {
#line 651
          goto while_break;
        } else
#line 650
        if (dataspace <= 0) {
#line 651
          goto while_break;
        }
        {
#line 653
        datanew = dns_namedec(data + dataoffset, dataspace, buf + bufoffset, thispartlen);
        }
#line 655
        if (datanew <= 0) {
#line 656
          goto while_break;
        }
#line 658
        bufoffset += thispartlen + 1;
#line 659
        dataoffset += datanew;
      }
      while_break: /* CIL Label */ ;
      }
#line 661
      rv = dataoffset;
#line 662
      if (rv < buflen) {
#line 662
        rv = rv;
      } else {
#line 662
        rv = buflen;
      }
#line 663
      if (rv > 0) {
        {
#line 664
        memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)(data),
               (size_t )rv);
        }
      }
    }
#line 667
    return (rv);
  } else {
#line 673
    if (r < 4) {
#line 673
      return (0);
    }
    {
#line 675
    tmp___1 = memcmp((void const   *)(data), (void const   *)(raw_header), (size_t )3);
    }
#line 675
    if (tmp___1) {
#line 675
      return (0);
    }
#line 677
    if (((int )data[3] & 15) != (int )userid) {
#line 677
      return (0);
    }
#line 679
    if (((int )data[3] & 240) == 32) {
      {
#line 681
      lastdownstreamtime = time((time_t *)((void *)0));
      }
    } else
#line 679
    if (((int )data[3] & 240) == 48) {
      {
#line 681
      lastdownstreamtime = time((time_t *)((void *)0));
      }
    }
#line 684
    if (((int )data[3] & 240) != 32) {
#line 684
      return (0);
    }
    {
#line 686
    r -= 4;
#line 687
    datalen = sizeof(buf___0);
#line 688
    tmp___2 = uncompress((uint8_t *)(buf___0), & datalen, (Bytef const   *)((uint8_t *)(& data[4])),
                         (uLong )r);
    }
#line 688
    if (tmp___2 == 0) {
      {
#line 689
      write_tun(tun_fd, buf___0, datalen);
      }
    }
#line 693
    return (0);
  }
}
}
#line 697 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
static int handshake_waitdns(int dns_fd , char *buf , int buflen , char c1 , char c2 ,
                             int timeout ) 
{ 
  struct query q ;
  int r ;
  int rv ;
  fd_set fds ;
  struct timeval tv ;
  int __d0 ;
  int __d1 ;

  {
  {
#line 716
  while (1) {
    while_continue: /* CIL Label */ ;
#line 717
    tv.tv_sec = (__time_t )timeout;
#line 718
    tv.tv_usec = (__suseconds_t )0;
    {
#line 719
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 719
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& fds.__fds_bits[0]): "memory");
#line 719
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 720
    fds.__fds_bits[dns_fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << dns_fd % (8 * (int )sizeof(__fd_mask ));
#line 721
    r = select(dns_fd + 1, (fd_set */* __restrict  */)(& fds), (fd_set */* __restrict  */)((void *)0),
               (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
    }
#line 723
    if (r < 0) {
#line 724
      return (-1);
    }
#line 725
    if (r == 0) {
#line 726
      return (-3);
    }
    {
#line 728
    q.id = (unsigned short)0;
#line 729
    q.name[0] = (char )'\000';
#line 730
    rv = read_dns_withq(dns_fd, 0, buf, buflen, & q);
    }
#line 732
    if ((int )q.id != (int )chunkid) {
#line 736
      goto while_continue;
    } else
#line 732
    if ((int )q.name[0] != (int )c1) {
#line 732
      if ((int )q.name[0] != (int )c2) {
#line 736
        goto while_continue;
      }
    }
#line 747
    if (rv < 0) {
#line 747
      if ((int )q.rcode == 0) {
#line 747
        if ((int )q.name[0] == 89) {
          {
#line 750
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Got empty reply. This nameserver may not be resolving recursively, use another.\n");
#line 751
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Try \"iodine [options] ns.%s %s\" first, it might just work.\n",
                  topdomain, topdomain);
          }
#line 753
          return (-2);
        } else
#line 747
        if ((int )q.name[0] == 121) {
          {
#line 750
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Got empty reply. This nameserver may not be resolving recursively, use another.\n");
#line 751
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Try \"iodine [options] ns.%s %s\" first, it might just work.\n",
                  topdomain, topdomain);
          }
#line 753
          return (-2);
        } else
#line 747
        if ((int )q.name[0] == 86) {
          {
#line 750
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Got empty reply. This nameserver may not be resolving recursively, use another.\n");
#line 751
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Try \"iodine [options] ns.%s %s\" first, it might just work.\n",
                  topdomain, topdomain);
          }
#line 753
          return (-2);
        } else
#line 747
        if ((int )q.name[0] == 118) {
          {
#line 750
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Got empty reply. This nameserver may not be resolving recursively, use another.\n");
#line 751
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Try \"iodine [options] ns.%s %s\" first, it might just work.\n",
                  topdomain, topdomain);
          }
#line 753
          return (-2);
        }
      }
    }
#line 765
    if (rv < 0) {
#line 765
      if ((int )q.rcode == 2) {
        {
#line 766
        sleep(1U);
        }
      }
    }
#line 768
    if (rv < 0) {
      {
#line 769
      write_dns_error(& q, 1);
      }
#line 770
      return (-2);
    }
#line 773
    return (rv);
  }
  while_break: /* CIL Label */ ;
  }
#line 777
  return (-1);
}
}
#line 780 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
static int tunnel_tun(int tun_fd , int dns_fd ) 
{ 
  unsigned long outlen ;
  unsigned long inlen ;
  char out[65536] ;
  char in[65536] ;
  ssize_t read___0 ;
  int tmp ;
  unsigned long tmp___0 ;

  {
  {
#line 789
  read___0 = read_tun(tun_fd, in, sizeof(in));
  }
#line 789
  if (read___0 <= 0L) {
#line 790
    return (-1);
  }
  {
#line 794
  tmp = is_sending();
  }
#line 794
  if (tmp) {
#line 795
    return (-1);
  }
  {
#line 797
  outlen = sizeof(out);
#line 798
  inlen = (unsigned long )read___0;
#line 799
  compress2((uint8_t *)(out), & outlen, (Bytef const   *)((uint8_t *)(in)), inlen,
            9);
  }
#line 801
  if (outlen < sizeof(outpkt.data)) {
#line 801
    tmp___0 = outlen;
  } else {
#line 801
    tmp___0 = sizeof(outpkt.data);
  }
  {
#line 801
  memcpy((void */* __restrict  */)(outpkt.data), (void const   */* __restrict  */)(out),
         tmp___0);
#line 802
  outpkt.sentlen = 0;
#line 803
  outpkt.offset = 0;
#line 804
  outpkt.seqno = (char )(((int )outpkt.seqno + 1) & 7);
#line 805
  outpkt.len = (int )outlen;
#line 806
  outpkt.fragment = (char)0;
#line 807
  outchunkresent = 0;
  }
#line 809
  if ((unsigned int )conn == 1U) {
    {
#line 810
    send_chunk(dns_fd);
#line 812
    send_ping_soon = 0L;
    }
  } else {
    {
#line 814
    send_raw_data(dns_fd);
    }
  }
#line 817
  return ((int )read___0);
}
}
#line 823
static int tunnel_dns(int tun_fd , int dns_fd ) ;
#line 823 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
static long packrecv  =    0L;
#line 824 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
static long packrecv_oos  =    0L;
#line 825 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
static long packrecv_servfail  =    0L;
#line 820 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
static int tunnel_dns(int tun_fd , int dns_fd ) 
{ 
  int up_ack_seqno ;
  int up_ack_fragment ;
  int new_down_seqno ;
  int new_down_fragment ;
  struct query q ;
  unsigned long datalen ;
  char buf[65536] ;
  int read___0 ;
  int send_something_now ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 834
  send_something_now = 0;
#line 836
  memset((void *)(q.name), 0, sizeof(q.name));
#line 837
  read___0 = read_dns_withq(dns_fd, tun_fd, buf, (int )sizeof(buf), & q);
  }
#line 839
  if ((unsigned int )conn != 1U) {
#line 840
    return (1);
  }
#line 852
  if ((int )q.name[0] != 80) {
#line 852
    if ((int )q.name[0] != 112) {
#line 852
      if ((int )q.name[0] != (int )userid_char) {
#line 852
        if ((int )q.name[0] != (int )userid_char2) {
#line 854
          send_ping_soon = 700L;
#line 855
          return (-1);
        }
      }
    }
  }
#line 858
  if (read___0 < 2) {
#line 862
    if (read___0 < 0) {
      {
#line 863
      write_dns_error(& q, 0);
      }
    }
#line 865
    if (read___0 < 0) {
#line 865
      if ((int )q.rcode == 2) {
#line 865
        if (lazymode) {
#line 865
          if (selecttimeout > 1) {
#line 867
            if (packrecv < 500L) {
#line 867
              if (packrecv_servfail < 4L) {
                {
#line 868
                packrecv_servfail ++;
#line 869
                warnx("Hmm, that\'s %ld. Your data should still go through...", packrecv_servfail);
                }
              } else {
#line 867
                goto _L___0;
              }
            } else
            _L___0: /* CIL Label */ 
#line 870
            if (packrecv < 500L) {
#line 870
              if (packrecv_servfail == 4L) {
                {
#line 871
                packrecv_servfail ++;
#line 872
                warnx("I think %ld is too many. Setting interval to 1 to hopefully reduce SERVFAILs. But just ignore them if data still comes through. (Use -I1 next time on this network.)",
                      packrecv_servfail);
#line 873
                selecttimeout = 1;
#line 874
                send_query_sendcnt = 0L;
#line 875
                send_query_recvcnt = 0L;
                }
              } else {
#line 870
                goto _L;
              }
            } else
            _L: /* CIL Label */ 
#line 876
            if (packrecv >= 500L) {
#line 876
              if (packrecv_servfail > 0L) {
                {
#line 877
                warnx("(Sorry, stopped counting; try -I1 if you experience hiccups.)");
#line 878
                packrecv_servfail = 0L;
                }
              }
            }
          }
        }
      }
    }
#line 891
    send_ping_soon = 900L;
#line 892
    return (-1);
  }
#line 895
  if (read___0 == 5) {
    {
#line 895
    tmp = strncmp("BADIP", (char const   *)(buf), (size_t )5);
    }
#line 895
    if (! tmp) {
      {
#line 896
      warnx("BADIP: Server rejected sender IP address (maybe iodined -c will help), or server kicked us due to timeout. Will exit if no downstream data is received in 60 seconds.");
      }
#line 897
      return (-1);
    }
  }
#line 900
  if (send_ping_soon) {
#line 901
    send_something_now = 1;
#line 902
    send_ping_soon = 0L;
  }
#line 908
  new_down_seqno = ((int )buf[1] >> 5) & 7;
#line 909
  new_down_fragment = ((int )buf[1] >> 1) & 15;
#line 910
  up_ack_seqno = ((int )buf[0] >> 4) & 7;
#line 911
  up_ack_fragment = (int )buf[0] & 15;
#line 921
  if (read___0 > 2) {
#line 921
    if (new_down_seqno != (int )inpkt.seqno) {
      {
#line 921
      tmp___0 = recent_seqno((int )inpkt.seqno, new_down_seqno);
      }
#line 921
      if (tmp___0) {
#line 931
        read___0 = 2;
#line 932
        send_ping_soon = 500L;
      }
    }
  }
#line 936
  if (! (packrecv & 16777216L)) {
#line 937
    packrecv ++;
  }
#line 938
  send_query_recvcnt ++;
#line 947
  if ((int )q.id != (int )chunkid) {
#line 947
    if ((int )q.id != (int )chunkid_prev) {
#line 947
      if ((int )q.id != (int )chunkid_prev2) {
#line 948
        packrecv_oos ++;
#line 952
        if (lazymode) {
#line 952
          if (packrecv < 1000L) {
#line 952
            if (packrecv_oos == 5L) {
#line 953
              if (selecttimeout > 1) {
                {
#line 954
                warnx("Hmm, getting some out-of-sequence DNS replies. Setting interval to 1 (use -I1 next time on this network). If data traffic still has large hiccups, try if -L0 works better.");
                }
              } else {
                {
#line 956
                warnx("Hmm, getting some out-of-sequence DNS replies. If data traffic often has large hiccups, try running with -L0 .");
                }
              }
#line 957
              selecttimeout = 1;
#line 958
              send_query_sendcnt = 0L;
#line 959
              send_query_recvcnt = 0L;
            }
          }
        }
#line 962
        if (send_something_now) {
          {
#line 963
          send_ping(dns_fd);
#line 964
          send_ping_soon = 0L;
          }
        }
#line 966
        return (-1);
      }
    }
  }
  {
#line 973
  lastdownstreamtime = time((time_t *)((void *)0));
  }
#line 979
  if ((int )q.id == (int )chunkid) {
#line 979
    if (lazymode) {
#line 980
      if (! send_ping_soon) {
#line 981
        send_ping_soon = 900L;
      } else
#line 980
      if (send_ping_soon > 900L) {
#line 981
        send_ping_soon = 900L;
      }
    }
  }
#line 984
  if (read___0 == 2) {
#line 984
    if (new_down_seqno != (int )inpkt.seqno) {
      {
#line 984
      tmp___1 = recent_seqno((int )inpkt.seqno, new_down_seqno);
      }
#line 984
      if (! tmp___1) {
#line 992
        inpkt.seqno = (char )new_down_seqno;
#line 993
        inpkt.fragment = (char )new_down_fragment;
#line 994
        inpkt.len = 0;
#line 995
        send_ping_soon = 500L;
      }
    }
  }
  {
#line 998
  while (1) {
    while_continue: /* CIL Label */ ;
#line 998
    if (! (read___0 > 2)) {
#line 998
      goto while_break;
    }
#line 1001
    if (new_down_seqno != (int )inpkt.seqno) {
#line 1004
      inpkt.seqno = (char )new_down_seqno;
#line 1005
      inpkt.fragment = (char )new_down_fragment;
#line 1006
      inpkt.len = 0;
    } else
#line 1007
    if ((int )inpkt.fragment == 0) {
#line 1007
      if (new_down_fragment == 0) {
#line 1007
        if (! (inpkt.len == 0)) {
#line 1007
          goto _L___2;
        }
      } else {
#line 1007
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 1014
    if (new_down_fragment <= (int )inpkt.fragment) {
#line 1018
      send_ping_soon = 500L;
#line 1019
      goto while_break;
    } else
#line 1020
    if (new_down_fragment > (int )inpkt.fragment + 1) {
#line 1025
      send_ping_soon = 500L;
#line 1026
      goto while_break;
    }
#line 1028
    inpkt.fragment = (char )new_down_fragment;
#line 1030
    if ((unsigned long )(read___0 - 2) < sizeof(inpkt.data) - (unsigned long )inpkt.len) {
#line 1030
      datalen = (unsigned long )(read___0 - 2);
    } else {
#line 1030
      datalen = sizeof(inpkt.data) - (unsigned long )inpkt.len;
    }
    {
#line 1035
    memcpy((void */* __restrict  */)(& inpkt.data[inpkt.len]), (void const   */* __restrict  */)(& buf[2]),
           datalen);
#line 1036
    inpkt.len = (int )((unsigned long )inpkt.len + datalen);
    }
#line 1038
    if ((int )buf[1] & 1) {
      {
#line 1041
      datalen = sizeof(buf);
#line 1042
      tmp___2 = uncompress((uint8_t *)(buf), & datalen, (Bytef const   *)((uint8_t *)(inpkt.data)),
                           (uLong )inpkt.len);
      }
#line 1042
      if (tmp___2 == 0) {
        {
#line 1043
        write_tun(tun_fd, buf, datalen);
        }
      }
#line 1045
      inpkt.len = 0;
    }
#line 1051
    if (inpkt.len == 0) {
#line 1055
      send_ping_soon = 5L;
    } else {
#line 1058
      send_something_now = 1;
    }
#line 1061
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1069
  tmp___3 = is_sending();
  }
#line 1069
  if (tmp___3) {
#line 1077
    if (up_ack_seqno == (int )outpkt.seqno) {
#line 1077
      if (up_ack_fragment == (int )outpkt.fragment) {
#line 1081
        outpkt.offset += outpkt.sentlen;
#line 1082
        if (outpkt.offset >= outpkt.len) {
#line 1084
          outpkt.offset = 0;
#line 1085
          outpkt.len = 0;
#line 1086
          outpkt.sentlen = 0;
#line 1087
          outchunkresent = 0;
#line 1098
          if (! send_ping_soon) {
#line 1099
            send_ping_soon = 20L;
          } else
#line 1098
          if (send_ping_soon > 20L) {
#line 1099
            send_ping_soon = 20L;
          }
        } else {
          {
#line 1102
          outpkt.fragment = (char )((int )outpkt.fragment + 1);
#line 1103
          outchunkresent = 0;
#line 1104
          send_chunk(dns_fd);
#line 1105
          send_ping_soon = 0L;
#line 1106
          send_something_now = 0;
          }
        }
      }
    }
  }
#line 1117
  if (send_something_now) {
    {
#line 1118
    send_ping(dns_fd);
#line 1119
    send_ping_soon = 0L;
    }
  }
#line 1122
  return (read___0);
}
}
#line 1125 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
int client_tunnel(int tun_fd , int dns_fd ) 
{ 
  struct timeval tv ;
  fd_set fds ;
  int rv ;
  int i ;
  int tmp ;
  int __d0 ;
  int __d1 ;
  int tmp___0 ;
  int tmp___1 ;
  time_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 1133
  rv = 0;
#line 1134
  lastdownstreamtime = time((time_t *)((void *)0));
#line 1135
  send_query_sendcnt = 0L;
  }
  {
#line 1137
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1137
    if (! running) {
#line 1137
      goto while_break;
    }
    {
#line 1138
    tv.tv_sec = (__time_t )selecttimeout;
#line 1139
    tv.tv_usec = (__suseconds_t )0;
#line 1141
    tmp = is_sending();
    }
#line 1141
    if (tmp) {
#line 1143
      tv.tv_sec = (__time_t )1;
#line 1144
      tv.tv_usec = (__suseconds_t )0;
    }
#line 1147
    if (send_ping_soon) {
#line 1148
      tv.tv_sec = (__time_t )0;
#line 1149
      tv.tv_usec = send_ping_soon * 1000L;
    }
    {
#line 1152
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1152
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& fds.__fds_bits[0]): "memory");
#line 1152
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1153
    tmp___0 = is_sending();
    }
#line 1153
    if (tmp___0) {
#line 1153
      if (outchunkresent >= 2) {
#line 1160
        fds.__fds_bits[tun_fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << tun_fd % (8 * (int )sizeof(__fd_mask ));
      }
    } else {
#line 1160
      fds.__fds_bits[tun_fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << tun_fd % (8 * (int )sizeof(__fd_mask ));
    }
#line 1162
    fds.__fds_bits[dns_fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << dns_fd % (8 * (int )sizeof(__fd_mask ));
#line 1164
    if (tun_fd > dns_fd) {
#line 1164
      tmp___1 = tun_fd;
    } else {
#line 1164
      tmp___1 = dns_fd;
    }
    {
#line 1164
    i = select(tmp___1 + 1, (fd_set */* __restrict  */)(& fds), (fd_set */* __restrict  */)((void *)0),
               (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
#line 1166
    tmp___2 = time((time_t *)((void *)0));
    }
#line 1166
    if (lastdownstreamtime + 60L < tmp___2) {
      {
#line 1167
      warnx("No downstream data received in 60 seconds, shutting down.");
#line 1168
      running = 0;
      }
    }
#line 1171
    if (running == 0) {
#line 1172
      goto while_break;
    }
#line 1174
    if (i < 0) {
      {
#line 1175
      err(1, "select");
      }
    }
#line 1177
    if (i == 0) {
      {
#line 1179
      tmp___3 = is_sending();
      }
#line 1179
      if (tmp___3) {
#line 1188
        if (outchunkresent < 3) {
          {
#line 1189
          outchunkresent ++;
#line 1190
          send_chunk(dns_fd);
          }
        } else {
          {
#line 1192
          outpkt.offset = 0;
#line 1193
          outpkt.len = 0;
#line 1194
          outpkt.sentlen = 0;
#line 1195
          outchunkresent = 0;
#line 1197
          send_ping(dns_fd);
          }
        }
      } else {
        {
#line 1200
        send_ping(dns_fd);
        }
      }
#line 1202
      send_ping_soon = 0L;
    } else {
#line 1206
      if ((fds.__fds_bits[tun_fd / (8 * (int )sizeof(__fd_mask ))] & (1L << tun_fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 1207
        tmp___4 = tunnel_tun(tun_fd, dns_fd);
        }
#line 1207
        if (tmp___4 <= 0) {
#line 1208
          goto while_continue;
        }
      }
#line 1214
      if ((fds.__fds_bits[dns_fd / (8 * (int )sizeof(__fd_mask ))] & (1L << dns_fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 1215
        tmp___5 = tunnel_dns(tun_fd, dns_fd);
        }
#line 1215
        if (tmp___5 <= 0) {
#line 1216
          goto while_continue;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1221
  return (rv);
}
}
#line 1224 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
static void send_login(int fd , char *login , int len ) 
{ 
  char data[19] ;
  int tmp ;

  {
  {
#line 1229
  memset((void *)(data), 0, sizeof(data));
#line 1230
  data[0] = userid;
  }
#line 1231
  if (len < 16) {
#line 1231
    tmp = len;
  } else {
#line 1231
    tmp = 16;
  }
  {
#line 1231
  memcpy((void */* __restrict  */)(& data[1]), (void const   */* __restrict  */)login,
         (size_t )tmp);
#line 1233
  data[17] = (char )(((int )rand_seed >> 8) & 255);
#line 1234
  data[18] = (char )((int )rand_seed & 255);
#line 1236
  rand_seed = (uint16_t )((int )rand_seed + 1);
#line 1238
  send_packet(fd, (char )'l', (char const   *)(data), (size_t const   )sizeof(data));
  }
#line 1239
  return;
}
}
#line 1241 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
static void send_fragsize_probe(int fd , int fragsize ) 
{ 
  char probedata[256] ;
  char buf[4096] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1251
  if (1 > ((int )rand_seed & 255)) {
#line 1251
    tmp = 1;
  } else {
#line 1251
    tmp = (int )rand_seed & 255;
  }
  {
#line 1251
  memset((void *)(probedata), tmp, sizeof(probedata));
  }
#line 1252
  if (1 > (((int )rand_seed >> 8) & 255)) {
#line 1252
    probedata[1] = (char)1;
  } else {
#line 1252
    probedata[1] = (char )(((int )rand_seed >> 8) & 255);
  }
  {
#line 1253
  rand_seed = (uint16_t )((int )rand_seed + 1);
#line 1256
  build_hostname(buf + 5, sizeof(buf) - 5UL, (char const   *)(probedata), (size_t const   )sizeof(probedata),
                 topdomain, dataenc, hostname_maxlen);
#line 1259
  fragsize &= 2047;
#line 1261
  buf[0] = (char )'r';
#line 1262
  tmp___0 = b32_5to8(((int )userid << 1) | ((fragsize >> 10) & 1));
#line 1262
  buf[1] = (char )tmp___0;
#line 1263
  tmp___1 = b32_5to8((fragsize >> 5) & 31);
#line 1263
  buf[2] = (char )tmp___1;
#line 1264
  tmp___2 = b32_5to8(fragsize & 31);
#line 1264
  buf[3] = (char )tmp___2;
#line 1265
  buf[4] = (char )'d';
#line 1267
  send_query(fd, buf);
  }
#line 1268
  return;
}
}
#line 1270 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
static void send_set_downstream_fragsize(int fd , int fragsize ) 
{ 
  char data[5] ;

  {
  {
#line 1275
  data[0] = userid;
#line 1276
  data[1] = (char )((fragsize & 65280) >> 8);
#line 1277
  data[2] = (char )(fragsize & 255);
#line 1278
  data[3] = (char )(((int )rand_seed >> 8) & 255);
#line 1279
  data[4] = (char )((int )rand_seed & 255);
#line 1281
  rand_seed = (uint16_t )((int )rand_seed + 1);
#line 1283
  send_packet(fd, (char )'n', (char const   *)(data), (size_t const   )sizeof(data));
  }
#line 1284
  return;
}
}
#line 1286 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
static void send_version(int fd , uint32_t version___1 ) 
{ 
  char data[6] ;

  {
  {
#line 1291
  data[0] = (char )((version___1 >> 24) & 255U);
#line 1292
  data[1] = (char )((version___1 >> 16) & 255U);
#line 1293
  data[2] = (char )((version___1 >> 8) & 255U);
#line 1294
  data[3] = (char )(version___1 & 255U);
#line 1296
  data[4] = (char )(((int )rand_seed >> 8) & 255);
#line 1297
  data[5] = (char )((int )rand_seed & 255);
#line 1299
  rand_seed = (uint16_t )((int )rand_seed + 1);
#line 1301
  send_packet(fd, (char )'v', (char const   *)(data), (size_t const   )sizeof(data));
  }
#line 1302
  return;
}
}
#line 1304 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
static void send_ip_request(int fd , int userid___0 ) 
{ 
  char buf[512] ;
  unsigned int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;

  {
#line 1307
  buf[0] = (char )'i';
#line 1307
  buf[1] = (char )'_';
#line 1307
  buf[2] = (char )'_';
#line 1307
  buf[3] = (char )'_';
#line 1307
  buf[4] = (char )'_';
#line 1307
  buf[5] = (char )'.';
#line 1307
  buf[6] = (char )'\000';
#line 1307
  tmp = 7U;
  {
#line 1307
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1307
    if (tmp >= 512U) {
#line 1307
      goto while_break;
    }
#line 1307
    buf[tmp] = (char)0;
#line 1307
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1308
  tmp___0 = b32_5to8(userid___0);
#line 1308
  buf[1] = (char )tmp___0;
#line 1310
  tmp___1 = b32_5to8(((int )rand_seed >> 10) & 31);
#line 1310
  buf[2] = (char )tmp___1;
#line 1311
  tmp___2 = b32_5to8(((int )rand_seed >> 5) & 31);
#line 1311
  buf[3] = (char )tmp___2;
#line 1312
  tmp___3 = b32_5to8((int )rand_seed & 31);
#line 1312
  buf[4] = (char )tmp___3;
#line 1313
  rand_seed = (uint16_t )((int )rand_seed + 1);
#line 1315
  tmp___4 = strlen((char const   *)(buf));
#line 1315
  strncat((char */* __restrict  */)(buf), (char const   */* __restrict  */)topdomain,
          512UL - tmp___4);
#line 1316
  send_query(fd, buf);
  }
#line 1317
  return;
}
}
#line 1319 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
static void send_raw_udp_login(int dns_fd , int userid___0 , int seed ) 
{ 
  char buf[16] ;

  {
  {
#line 1323
  login_calculate(buf, 16, password, seed + 1);
#line 1325
  send_raw(dns_fd, buf, (int )sizeof(buf), userid___0, 16);
  }
#line 1326
  return;
}
}
#line 1328 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
static void send_upenctest(int fd , char *s ) 
{ 
  char buf[512] ;
  unsigned int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;

  {
#line 1332
  buf[0] = (char )'z';
#line 1332
  buf[1] = (char )'_';
#line 1332
  buf[2] = (char )'_';
#line 1332
  buf[3] = (char )'_';
#line 1332
  buf[4] = (char )'\000';
#line 1332
  tmp = 5U;
  {
#line 1332
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1332
    if (tmp >= 512U) {
#line 1332
      goto while_break;
    }
#line 1332
    buf[tmp] = (char)0;
#line 1332
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1334
  tmp___0 = b32_5to8(((int )rand_seed >> 10) & 31);
#line 1334
  buf[1] = (char )tmp___0;
#line 1335
  tmp___1 = b32_5to8(((int )rand_seed >> 5) & 31);
#line 1335
  buf[2] = (char )tmp___1;
#line 1336
  tmp___2 = b32_5to8((int )rand_seed & 31);
#line 1336
  buf[3] = (char )tmp___2;
#line 1337
  rand_seed = (uint16_t )((int )rand_seed + 1);
#line 1339
  strncat((char */* __restrict  */)(buf), (char const   */* __restrict  */)s, (size_t )512);
#line 1340
  strncat((char */* __restrict  */)(buf), (char const   */* __restrict  */)".", (size_t )512);
#line 1341
  tmp___3 = strlen((char const   *)(buf));
#line 1341
  strncat((char */* __restrict  */)(buf), (char const   */* __restrict  */)topdomain,
          512UL - tmp___3);
#line 1342
  send_query(fd, buf);
  }
#line 1343
  return;
}
}
#line 1345 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
static void send_downenctest(int fd , char downenc___0 , int variant , char *s , int slen ) 
{ 
  char buf[512] ;
  unsigned int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;

  {
#line 1349
  buf[0] = (char )'y';
#line 1349
  buf[1] = (char )'_';
#line 1349
  buf[2] = (char )'_';
#line 1349
  buf[3] = (char )'_';
#line 1349
  buf[4] = (char )'_';
#line 1349
  buf[5] = (char )'_';
#line 1349
  buf[6] = (char )'.';
#line 1349
  buf[7] = (char )'\000';
#line 1349
  tmp = 8U;
  {
#line 1349
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1349
    if (tmp >= 512U) {
#line 1349
      goto while_break;
    }
#line 1349
    buf[tmp] = (char)0;
#line 1349
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1351
  tmp___0 = tolower((int )downenc___0);
#line 1351
  buf[1] = (char )tmp___0;
#line 1352
  tmp___1 = b32_5to8(variant);
#line 1352
  buf[2] = (char )tmp___1;
#line 1354
  tmp___2 = b32_5to8(((int )rand_seed >> 10) & 31);
#line 1354
  buf[3] = (char )tmp___2;
#line 1355
  tmp___3 = b32_5to8(((int )rand_seed >> 5) & 31);
#line 1355
  buf[4] = (char )tmp___3;
#line 1356
  tmp___4 = b32_5to8((int )rand_seed & 31);
#line 1356
  buf[5] = (char )tmp___4;
#line 1357
  rand_seed = (uint16_t )((int )rand_seed + 1);
#line 1359
  tmp___5 = strlen((char const   *)(buf));
#line 1359
  strncat((char */* __restrict  */)(buf), (char const   */* __restrict  */)topdomain,
          512UL - tmp___5);
#line 1360
  send_query(fd, buf);
  }
#line 1361
  return;
}
}
#line 1363 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
static void send_codec_switch(int fd , int userid___0 , int bits ) 
{ 
  char buf[512] ;
  unsigned int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;

  {
#line 1366
  buf[0] = (char )'s';
#line 1366
  buf[1] = (char )'_';
#line 1366
  buf[2] = (char )'_';
#line 1366
  buf[3] = (char )'_';
#line 1366
  buf[4] = (char )'_';
#line 1366
  buf[5] = (char )'_';
#line 1366
  buf[6] = (char )'.';
#line 1366
  buf[7] = (char )'\000';
#line 1366
  tmp = 8U;
  {
#line 1366
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1366
    if (tmp >= 512U) {
#line 1366
      goto while_break;
    }
#line 1366
    buf[tmp] = (char)0;
#line 1366
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1367
  tmp___0 = b32_5to8(userid___0);
#line 1367
  buf[1] = (char )tmp___0;
#line 1368
  tmp___1 = b32_5to8(bits);
#line 1368
  buf[2] = (char )tmp___1;
#line 1370
  tmp___2 = b32_5to8(((int )rand_seed >> 10) & 31);
#line 1370
  buf[3] = (char )tmp___2;
#line 1371
  tmp___3 = b32_5to8(((int )rand_seed >> 5) & 31);
#line 1371
  buf[4] = (char )tmp___3;
#line 1372
  tmp___4 = b32_5to8((int )rand_seed & 31);
#line 1372
  buf[5] = (char )tmp___4;
#line 1373
  rand_seed = (uint16_t )((int )rand_seed + 1);
#line 1375
  tmp___5 = strlen((char const   *)(buf));
#line 1375
  strncat((char */* __restrict  */)(buf), (char const   */* __restrict  */)topdomain,
          512UL - tmp___5);
#line 1376
  send_query(fd, buf);
  }
#line 1377
  return;
}
}
#line 1380 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
static void send_downenc_switch(int fd , int userid___0 ) 
{ 
  char buf[512] ;
  unsigned int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;

  {
#line 1383
  buf[0] = (char )'o';
#line 1383
  buf[1] = (char )'_';
#line 1383
  buf[2] = (char )'_';
#line 1383
  buf[3] = (char )'_';
#line 1383
  buf[4] = (char )'_';
#line 1383
  buf[5] = (char )'_';
#line 1383
  buf[6] = (char )'.';
#line 1383
  buf[7] = (char )'\000';
#line 1383
  tmp = 8U;
  {
#line 1383
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1383
    if (tmp >= 512U) {
#line 1383
      goto while_break;
    }
#line 1383
    buf[tmp] = (char)0;
#line 1383
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1384
  tmp___0 = b32_5to8(userid___0);
#line 1384
  buf[1] = (char )tmp___0;
#line 1385
  tmp___1 = tolower((int )downenc);
#line 1385
  buf[2] = (char )tmp___1;
#line 1387
  tmp___2 = b32_5to8(((int )rand_seed >> 10) & 31);
#line 1387
  buf[3] = (char )tmp___2;
#line 1388
  tmp___3 = b32_5to8(((int )rand_seed >> 5) & 31);
#line 1388
  buf[4] = (char )tmp___3;
#line 1389
  tmp___4 = b32_5to8((int )rand_seed & 31);
#line 1389
  buf[5] = (char )tmp___4;
#line 1390
  rand_seed = (uint16_t )((int )rand_seed + 1);
#line 1392
  tmp___5 = strlen((char const   *)(buf));
#line 1392
  strncat((char */* __restrict  */)(buf), (char const   */* __restrict  */)topdomain,
          512UL - tmp___5);
#line 1393
  send_query(fd, buf);
  }
#line 1394
  return;
}
}
#line 1396 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
static void send_lazy_switch(int fd , int userid___0 ) 
{ 
  char buf[512] ;
  unsigned int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;

  {
#line 1399
  buf[0] = (char )'o';
#line 1399
  buf[1] = (char )'_';
#line 1399
  buf[2] = (char )'_';
#line 1399
  buf[3] = (char )'_';
#line 1399
  buf[4] = (char )'_';
#line 1399
  buf[5] = (char )'_';
#line 1399
  buf[6] = (char )'.';
#line 1399
  buf[7] = (char )'\000';
#line 1399
  tmp = 8U;
  {
#line 1399
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1399
    if (tmp >= 512U) {
#line 1399
      goto while_break;
    }
#line 1399
    buf[tmp] = (char)0;
#line 1399
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1400
  tmp___0 = b32_5to8(userid___0);
#line 1400
  buf[1] = (char )tmp___0;
  }
#line 1402
  if (lazymode) {
#line 1403
    buf[2] = (char )'l';
  } else {
#line 1405
    buf[2] = (char )'i';
  }
  {
#line 1407
  tmp___1 = b32_5to8(((int )rand_seed >> 10) & 31);
#line 1407
  buf[3] = (char )tmp___1;
#line 1408
  tmp___2 = b32_5to8(((int )rand_seed >> 5) & 31);
#line 1408
  buf[4] = (char )tmp___2;
#line 1409
  tmp___3 = b32_5to8((int )rand_seed & 31);
#line 1409
  buf[5] = (char )tmp___3;
#line 1410
  rand_seed = (uint16_t )((int )rand_seed + 1);
#line 1412
  tmp___4 = strlen((char const   *)(buf));
#line 1412
  strncat((char */* __restrict  */)(buf), (char const   */* __restrict  */)topdomain,
          512UL - tmp___4);
#line 1413
  send_query(fd, buf);
  }
#line 1414
  return;
}
}
#line 1416 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
static int handshake_version(int dns_fd , int *seed ) 
{ 
  char hex[17] ;
  char hex2[17] ;
  char in[4096] ;
  uint32_t payload ;
  int i ;
  int read___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1419
  hex[0] = (char )'0';
#line 1419
  hex[1] = (char )'1';
#line 1419
  hex[2] = (char )'2';
#line 1419
  hex[3] = (char )'3';
#line 1419
  hex[4] = (char )'4';
#line 1419
  hex[5] = (char )'5';
#line 1419
  hex[6] = (char )'6';
#line 1419
  hex[7] = (char )'7';
#line 1419
  hex[8] = (char )'8';
#line 1419
  hex[9] = (char )'9';
#line 1419
  hex[10] = (char )'a';
#line 1419
  hex[11] = (char )'b';
#line 1419
  hex[12] = (char )'c';
#line 1419
  hex[13] = (char )'d';
#line 1419
  hex[14] = (char )'e';
#line 1419
  hex[15] = (char )'f';
#line 1419
  hex[16] = (char )'\000';
#line 1420
  hex2[0] = (char )'0';
#line 1420
  hex2[1] = (char )'1';
#line 1420
  hex2[2] = (char )'2';
#line 1420
  hex2[3] = (char )'3';
#line 1420
  hex2[4] = (char )'4';
#line 1420
  hex2[5] = (char )'5';
#line 1420
  hex2[6] = (char )'6';
#line 1420
  hex2[7] = (char )'7';
#line 1420
  hex2[8] = (char )'8';
#line 1420
  hex2[9] = (char )'9';
#line 1420
  hex2[10] = (char )'A';
#line 1420
  hex2[11] = (char )'B';
#line 1420
  hex2[12] = (char )'C';
#line 1420
  hex2[13] = (char )'D';
#line 1420
  hex2[14] = (char )'E';
#line 1420
  hex2[15] = (char )'F';
#line 1420
  hex2[16] = (char )'\000';
#line 1426
  i = 0;
  {
#line 1426
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1426
    if (running) {
#line 1426
      if (! (i < 5)) {
#line 1426
        goto while_break;
      }
    } else {
#line 1426
      goto while_break;
    }
    {
#line 1428
    send_version(dns_fd, (uint32_t )1282);
#line 1430
    read___0 = handshake_waitdns(dns_fd, in, (int )sizeof(in), (char )'v', (char )'V',
                                 i + 1);
    }
#line 1433
    if (read___0 >= 9) {
      {
#line 1434
      payload = (uint32_t )((((((int )in[4] & 255) << 24) | (((int )in[5] & 255) << 16)) | (((int )in[6] & 255) << 8)) | ((int )in[7] & 255));
#line 1439
      tmp___1 = strncmp("VACK", (char const   *)(in), (size_t )4);
      }
#line 1439
      if (tmp___1 == 0) {
        {
#line 1440
        *seed = (int )payload;
#line 1441
        userid = in[8];
#line 1442
        userid_char = hex[(int )userid & 15];
#line 1443
        userid_char2 = hex2[(int )userid & 15];
#line 1445
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Version ok, both using protocol v 0x%08x. You are user #%d\n",
                1282, (int )userid);
        }
#line 1446
        return (0);
      } else {
        {
#line 1447
        tmp___0 = strncmp("VNAK", (char const   *)(in), (size_t )4);
        }
#line 1447
        if (tmp___0 == 0) {
          {
#line 1448
          warnx("You use protocol v 0x%08x, server uses v 0x%08x. Giving up", 1282,
                payload);
          }
#line 1450
          return (1);
        } else {
          {
#line 1451
          tmp = strncmp("VFUL", (char const   *)(in), (size_t )4);
          }
#line 1451
          if (tmp == 0) {
            {
#line 1452
            warnx("Server full, all %d slots are taken. Try again later", payload);
            }
#line 1453
            return (1);
          }
        }
      }
    } else
#line 1455
    if (read___0 > 0) {
      {
#line 1456
      warnx("did not receive proper login challenge");
      }
    }
    {
#line 1459
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Retrying version check...\n");
#line 1426
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1461
  warnx("couldn\'t connect to server (maybe other -T options will work)");
  }
#line 1462
  return (1);
}
}
#line 1465 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
static int handshake_login(int dns_fd , int seed ) 
{ 
  char in[4096] ;
  char login[16] ;
  char server[65] ;
  char client[65] ;
  int mtu ;
  int i ;
  int read___0 ;
  int netmask___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 1476
  login_calculate(login, 16, password, seed);
#line 1478
  i = 0;
  }
  {
#line 1478
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1478
    if (running) {
#line 1478
      if (! (i < 5)) {
#line 1478
        goto while_break;
      }
    } else {
#line 1478
      goto while_break;
    }
    {
#line 1480
    send_login(dns_fd, login, 16);
#line 1482
    read___0 = handshake_waitdns(dns_fd, in, (int )sizeof(in), (char )'l', (char )'L',
                                 i + 1);
    }
#line 1485
    if (read___0 > 0) {
      {
#line 1487
      tmp___2 = strncmp("LNAK", (char const   *)(in), (size_t )4);
      }
#line 1487
      if (tmp___2 == 0) {
        {
#line 1488
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad password\n");
        }
#line 1489
        return (1);
      } else {
        {
#line 1490
        tmp___1 = sscanf((char const   */* __restrict  */)(in), (char const   */* __restrict  */)"%64[^-]-%64[^-]-%d-%d",
                         server, client, & mtu, & netmask___0);
        }
#line 1490
        if (tmp___1 == 4) {
          {
#line 1493
          server[64] = (char)0;
#line 1494
          client[64] = (char)0;
#line 1495
          tmp = tun_setip((char const   *)(client), (char const   *)(server), netmask___0);
          }
#line 1495
          if (tmp == 0) {
            {
#line 1495
            tmp___0 = tun_setmtu((unsigned int const   )mtu);
            }
#line 1495
            if (tmp___0 == 0) {
              {
#line 1498
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Server tunnel IP is %s\n",
                      server);
              }
#line 1499
              return (0);
            } else {
              {
#line 1501
              errx(4, "Failed to set IP and MTU");
              }
            }
          } else {
            {
#line 1501
            errx(4, "Failed to set IP and MTU");
            }
          }
        } else {
          {
#line 1504
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Received bad handshake\n");
          }
        }
      }
    }
    {
#line 1509
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Retrying login...\n");
#line 1478
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1511
  warnx("couldn\'t login to server");
  }
#line 1512
  return (1);
}
}
#line 1515 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
static int handshake_raw_udp(int dns_fd , int seed ) 
{ 
  struct timeval tv ;
  char in[4096] ;
  fd_set fds ;
  int i ;
  int r ;
  int len ;
  unsigned int remoteaddr ;
  struct in_addr server ;
  char *tmp ;
  int __d0 ;
  int __d1 ;
  ssize_t tmp___0 ;
  char hash[16] ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 1524
  remoteaddr = 0U;
#line 1527
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Testing raw UDP data to the server (skip with -r)");
#line 1528
  i = 0;
  }
  {
#line 1528
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1528
    if (running) {
#line 1528
      if (! (i < 3)) {
#line 1528
        goto while_break;
      }
    } else {
#line 1528
      goto while_break;
    }
    {
#line 1530
    send_ip_request(dns_fd, (int )userid);
#line 1532
    len = handshake_waitdns(dns_fd, in, (int )sizeof(in), (char )'i', (char )'I',
                            i + 1);
    }
#line 1535
    if (len == 5) {
#line 1535
      if ((int )in[0] == 73) {
        {
#line 1537
        remoteaddr = (unsigned int )((int )in[1] & 255);
#line 1538
        remoteaddr <<= 8;
#line 1539
        remoteaddr |= (unsigned int )((int )in[2] & 255);
#line 1540
        remoteaddr <<= 8;
#line 1541
        remoteaddr |= (unsigned int )((int )in[3] & 255);
#line 1542
        remoteaddr <<= 8;
#line 1543
        remoteaddr |= (unsigned int )((int )in[4] & 255);
#line 1544
        server.s_addr = ntohl(remoteaddr);
        }
#line 1545
        goto while_break;
      }
    }
    {
#line 1549
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)".");
#line 1550
    fflush(stderr);
#line 1528
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1552
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
  }
#line 1553
  if (! running) {
#line 1554
    return (0);
  }
#line 1556
  if (! remoteaddr) {
    {
#line 1557
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed to get raw server IP, will use DNS mode.\n");
    }
#line 1558
    return (0);
  }
  {
#line 1560
  tmp = inet_ntoa(server);
#line 1560
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Server is at %s, trying raw login: ",
          tmp);
#line 1561
  fflush(stderr);
#line 1564
  memset((void *)(& raw_serv), 0, sizeof(raw_serv));
#line 1565
  raw_serv.sin_family = (sa_family_t )2;
#line 1566
  raw_serv.sin_port = htons((uint16_t )53);
#line 1567
  raw_serv.sin_addr = server;
#line 1572
  i = 0;
  }
  {
#line 1572
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1572
    if (running) {
#line 1572
      if (! (i < 4)) {
#line 1572
        goto while_break___0;
      }
    } else {
#line 1572
      goto while_break___0;
    }
    {
#line 1573
    tv.tv_sec = (__time_t )(i + 1);
#line 1574
    tv.tv_usec = (__suseconds_t )0;
#line 1576
    send_raw_udp_login(dns_fd, (int )userid, seed);
    }
    {
#line 1578
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1578
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& fds.__fds_bits[0]): "memory");
#line 1578
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1579
    fds.__fds_bits[dns_fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << dns_fd % (8 * (int )sizeof(__fd_mask ));
#line 1581
    r = select(dns_fd + 1, (fd_set */* __restrict  */)(& fds), (fd_set */* __restrict  */)((void *)0),
               (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
    }
#line 1583
    if (r > 0) {
      {
#line 1585
      tmp___0 = recv(dns_fd, (void *)(in), sizeof(in), 0);
#line 1585
      len = (int )tmp___0;
      }
#line 1586
      if (len >= 20) {
        {
#line 1588
        login_calculate(hash, 16, password, seed - 1);
#line 1589
        tmp___1 = memcmp((void const   *)(in), (void const   *)(raw_header), (size_t )3);
        }
#line 1589
        if (tmp___1 == 0) {
#line 1589
          if (((int )in[3] & 240) == 16) {
            {
#line 1589
            tmp___2 = memcmp((void const   *)(& in[4]), (void const   *)(hash), sizeof(hash));
            }
#line 1589
            if (tmp___2 == 0) {
              {
#line 1593
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"OK\n");
              }
#line 1594
              return (1);
            }
          }
        }
      }
    }
    {
#line 1598
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)".");
#line 1599
    fflush(stderr);
#line 1572
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1602
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"failed\n");
  }
#line 1603
  return (0);
}
}
#line 1606 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
static int handshake_upenctest(int dns_fd , char *s ) 
{ 
  char in[4096] ;
  unsigned char *uin ;
  unsigned char *us ;
  int i ;
  int read___0 ;
  int slen ;
  size_t tmp ;
  int k ;

  {
  {
#line 1616
  uin = (unsigned char *)(in);
#line 1617
  us = (unsigned char *)s;
#line 1622
  tmp = strlen((char const   *)s);
#line 1622
  slen = (int )tmp;
#line 1623
  i = 0;
  }
  {
#line 1623
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1623
    if (running) {
#line 1623
      if (! (i < 3)) {
#line 1623
        goto while_break;
      }
    } else {
#line 1623
      goto while_break;
    }
    {
#line 1625
    send_upenctest(dns_fd, s);
#line 1627
    read___0 = handshake_waitdns(dns_fd, in, (int )sizeof(in), (char )'z', (char )'Z',
                                 i + 1);
    }
#line 1629
    if (read___0 == -2) {
#line 1630
      return (0);
    }
#line 1632
    if (read___0 > 0) {
#line 1632
      if (read___0 < slen + 4) {
#line 1633
        return (0);
      }
    }
#line 1635
    if (read___0 > 0) {
#line 1645
      if ((int )in[4] == 65) {
        {
#line 1646
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"DNS queries get changed to uppercase, keeping upstream codec Base32\n");
        }
#line 1647
        return (-1);
      }
#line 1649
      if ((int )in[5] == 97) {
        {
#line 1650
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"DNS queries get changed to lowercase, keeping upstream codec Base32\n");
        }
#line 1651
        return (-1);
      }
#line 1654
      k = 0;
      {
#line 1654
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1654
        if (! (k < slen)) {
#line 1654
          goto while_break___0;
        }
#line 1655
        if ((int )in[k + 4] != (int )*(s + k)) {
#line 1657
          if ((int )in[k + 4] >= 32) {
#line 1657
            if ((int )in[k + 4] <= 126) {
#line 1657
              if ((int )*(s + k) >= 32) {
#line 1657
                if ((int )*(s + k) <= 126) {
                  {
#line 1659
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"DNS query char \'%c\' gets changed into \'%c\'\n",
                          (int )*(s + k), (int )in[k + 4]);
                  }
                } else {
                  {
#line 1662
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"DNS query char 0x%02X gets changed into 0x%02X\n",
                          (unsigned int )*(us + k), (unsigned int )*(uin + (k + 4)));
                  }
                }
              } else {
                {
#line 1662
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"DNS query char 0x%02X gets changed into 0x%02X\n",
                        (unsigned int )*(us + k), (unsigned int )*(uin + (k + 4)));
                }
              }
            } else {
              {
#line 1662
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"DNS query char 0x%02X gets changed into 0x%02X\n",
                      (unsigned int )*(us + k), (unsigned int )*(uin + (k + 4)));
              }
            }
          } else {
            {
#line 1662
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"DNS query char 0x%02X gets changed into 0x%02X\n",
                    (unsigned int )*(us + k), (unsigned int )*(uin + (k + 4)));
            }
          }
#line 1666
          return (0);
        }
#line 1654
        k ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1670
      return (1);
    }
    {
#line 1673
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Retrying upstream codec test...\n");
#line 1623
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1676
  if (! running) {
#line 1677
    return (-1);
  }
#line 1680
  return (0);
}
}
#line 1683 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
static int handshake_upenc_autodetect(int dns_fd ) 
{ 
  char *pat64 ;
  char *pat64u ;
  char *pat128a ;
  char *pat128b ;
  char *pat128c ;
  char *pat128d ;
  char *pat128e ;
  int res ;

  {
#line 1699
  pat64 = (char *)"aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ+0129-";
#line 1700
  pat64u = (char *)"aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ_0129-";
#line 1701
  pat128a = (char *)"aA-Aaahhh-Drink-mal-ein-J\344germeister-";
#line 1702
  pat128b = (char *)"aA-La-fl\373te-na\357ve-fran\347aise-est-retir\351-\340-Cr\350te";
#line 1703
  pat128c = (char *)"aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ";
#line 1704
  pat128d = (char *)"aA0123456789\274\275\276\277\300\301\302\303\304\305\306\307\310\311\312\313\314\315\316\317";
#line 1706
  pat128e = (char *)"aA\320\321\322\323\324\325\326\327\330\331\332\333\334\335\336\337\340\341\342\343\344\345\346\347\350\351\352\353\354\355\356\357\360\361\362\363\364\365\366\367\370\371\372\373\374\375";
  {
#line 1713
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1714
    res = handshake_upenctest(dns_fd, pat128a);
    }
#line 1715
    if (res < 0) {
#line 1717
      return (0);
    } else
#line 1718
    if (res == 0) {
#line 1720
      goto while_break;
    }
    {
#line 1723
    res = handshake_upenctest(dns_fd, pat128b);
    }
#line 1724
    if (res < 0) {
#line 1725
      return (0);
    } else
#line 1726
    if (res == 0) {
#line 1727
      goto while_break;
    }
    {
#line 1731
    res = handshake_upenctest(dns_fd, pat128c);
    }
#line 1732
    if (res < 0) {
#line 1733
      return (0);
    } else
#line 1734
    if (res == 0) {
#line 1735
      goto while_break;
    }
    {
#line 1737
    res = handshake_upenctest(dns_fd, pat128d);
    }
#line 1738
    if (res < 0) {
#line 1739
      return (0);
    } else
#line 1740
    if (res == 0) {
#line 1741
      goto while_break;
    }
    {
#line 1743
    res = handshake_upenctest(dns_fd, pat128e);
    }
#line 1744
    if (res < 0) {
#line 1745
      return (0);
    } else
#line 1746
    if (res == 0) {
#line 1747
      goto while_break;
    }
#line 1750
    return (3);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1754
  res = handshake_upenctest(dns_fd, pat64);
  }
#line 1755
  if (res < 0) {
#line 1757
    return (0);
  } else
#line 1758
  if (res > 0) {
#line 1760
    return (1);
  }
  {
#line 1764
  res = handshake_upenctest(dns_fd, pat64u);
  }
#line 1765
  if (res < 0) {
#line 1767
    return (0);
  } else
#line 1768
  if (res > 0) {
#line 1770
    return (2);
  }
  {
#line 1774
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Keeping upstream codec Base32\n");
  }
#line 1775
  return (0);
}
}
#line 1778 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
static int handshake_downenctest(int dns_fd , char trycodec ) 
{ 
  char in[4096] ;
  int i ;
  int read___0 ;
  char *s ;
  int slen ;
  int k ;

  {
#line 1788
  s = (char *)"\000\000\000\000\377\377\377\377UUUU\252\252\252\252\201c\310\322\307|\262\027_O\316\311I-R!a\251q %\263\006s\346\330D0yPW\277";
#line 1789
  slen = 48;
#line 1791
  i = 0;
  {
#line 1791
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1791
    if (running) {
#line 1791
      if (! (i < 3)) {
#line 1791
        goto while_break;
      }
    } else {
#line 1791
      goto while_break;
    }
    {
#line 1793
    send_downenctest(dns_fd, trycodec, 1, (char *)((void *)0), 0);
#line 1795
    read___0 = handshake_waitdns(dns_fd, in, (int )sizeof(in), (char )'y', (char )'Y',
                                 i + 1);
    }
#line 1797
    if (read___0 == -2) {
#line 1798
      return (0);
    }
#line 1800
    if (read___0 > 0) {
#line 1800
      if (read___0 != slen) {
#line 1801
        return (0);
      }
    }
#line 1803
    if (read___0 > 0) {
#line 1805
      k = 0;
      {
#line 1805
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1805
        if (! (k < slen)) {
#line 1805
          goto while_break___0;
        }
#line 1806
        if ((int )in[k] != (int )*(s + k)) {
#line 1808
          return (0);
        }
#line 1805
        k ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1812
      return (1);
    }
    {
#line 1815
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Retrying downstream codec test...\n");
#line 1791
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1819
  return (0);
}
}
#line 1822 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
static char handshake_downenc_autodetect(int dns_fd ) 
{ 
  int base64ok ;
  int base64uok ;
  int base128ok ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1826
  base64ok = 0;
#line 1827
  base64uok = 0;
#line 1828
  base128ok = 0;
#line 1830
  if ((int )do_qtype == 10) {
    {
#line 1832
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"No alternative downstream codec available, using default (Raw)\n");
    }
#line 1833
    return ((char )' ');
  }
  {
#line 1836
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Autodetecting downstream codec (use -O to override)\n");
#line 1839
  tmp___0 = handshake_downenctest(dns_fd, (char )'S');
  }
#line 1839
  if (tmp___0) {
#line 1840
    base64ok = 1;
  } else
#line 1841
  if (running) {
    {
#line 1841
    tmp = handshake_downenctest(dns_fd, (char )'U');
    }
#line 1841
    if (tmp) {
#line 1842
      base64uok = 1;
    }
  }
#line 1845
  if (running) {
#line 1845
    if (base64ok) {
#line 1845
      goto _L;
    } else
#line 1845
    if (base64uok) {
      _L: /* CIL Label */ 
      {
#line 1846
      tmp___1 = handshake_downenctest(dns_fd, (char )'V');
      }
#line 1846
      if (tmp___1) {
#line 1847
        base128ok = 1;
      }
    }
  }
#line 1851
  if (running) {
#line 1851
    if (base128ok) {
#line 1851
      if ((int )do_qtype == 16) {
        {
#line 1852
        tmp___2 = handshake_downenctest(dns_fd, (char )'R');
        }
#line 1852
        if (tmp___2) {
#line 1853
          return ((char )'R');
        }
      }
    }
  }
#line 1856
  if (! running) {
#line 1857
    return ((char )' ');
  }
#line 1859
  if (base128ok) {
#line 1860
    return ((char )'V');
  }
#line 1861
  if (base64ok) {
#line 1862
    return ((char )'S');
  }
#line 1863
  if (base64uok) {
#line 1864
    return ((char )'U');
  }
  {
#line 1866
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"No advanced downstream codecs seem to work, using default (Base32)\n");
  }
#line 1867
  return ((char )' ');
}
}
#line 1870 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
static int handshake_qtypetest(int dns_fd , int timeout ) 
{ 
  char in[4096] ;
  int read___0 ;
  char *s ;
  int slen ;
  int trycodec ;
  int k ;

  {
#line 1879
  s = (char *)"\000\000\000\000\377\377\377\377UUUU\252\252\252\252\201c\310\322\307|\262\027_O\316\311I-R!a\251q %\263\006s\346\330D0yPW\277";
#line 1880
  slen = 48;
#line 1884
  if ((int )do_qtype == 10) {
#line 1885
    trycodec = 'R';
  } else {
#line 1887
    trycodec = 'T';
  }
  {
#line 1892
  send_downenctest(dns_fd, (char )trycodec, 1, (char *)((void *)0), 0);
#line 1894
  read___0 = handshake_waitdns(dns_fd, in, (int )sizeof(in), (char )'y', (char )'Y',
                               timeout);
  }
#line 1896
  if (read___0 != slen) {
#line 1897
    return (0);
  }
#line 1899
  k = 0;
  {
#line 1899
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1899
    if (! (k < slen)) {
#line 1899
      goto while_break;
    }
#line 1900
    if ((int )in[k] != (int )*(s + k)) {
#line 1902
      return (0);
    }
#line 1899
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1907
  return (1);
}
}
#line 1910 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
static int handshake_qtype_numcvt(int num ) 
{ 


  {
  {
#line 1914
  if (num == 0) {
#line 1914
    goto case_0;
  }
#line 1915
  if (num == 1) {
#line 1915
    goto case_1;
  }
#line 1916
  if (num == 2) {
#line 1916
    goto case_2;
  }
#line 1917
  if (num == 3) {
#line 1917
    goto case_3;
  }
#line 1918
  if (num == 4) {
#line 1918
    goto case_4;
  }
#line 1919
  if (num == 5) {
#line 1919
    goto case_5;
  }
#line 1913
  goto switch_break;
  case_0: /* CIL Label */ 
#line 1914
  return (10);
  case_1: /* CIL Label */ 
#line 1915
  return (16);
  case_2: /* CIL Label */ 
#line 1916
  return (33);
  case_3: /* CIL Label */ 
#line 1917
  return (15);
  case_4: /* CIL Label */ 
#line 1918
  return (5);
  case_5: /* CIL Label */ 
#line 1919
  return (1);
  switch_break: /* CIL Label */ ;
  }
#line 1921
  return (65432);
}
}
#line 1924 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
static int handshake_qtype_autodetect(int dns_fd ) 
{ 
  int highestworking ;
  int timeout ;
  int qtypenum ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1931
  highestworking = 100;
#line 1935
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Autodetecting DNS query type (use -T to override)");
#line 1936
  fflush(stderr);
#line 1948
  timeout = 1;
  }
  {
#line 1948
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1948
    if (running) {
#line 1948
      if (! (timeout <= 3)) {
#line 1948
        goto while_break;
      }
    } else {
#line 1948
      goto while_break;
    }
#line 1949
    qtypenum = 0;
    {
#line 1949
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1949
      if (running) {
#line 1949
        if (! (qtypenum < highestworking)) {
#line 1949
          goto while_break___0;
        }
      } else {
#line 1949
        goto while_break___0;
      }
      {
#line 1950
      tmp = handshake_qtype_numcvt(qtypenum);
#line 1950
      do_qtype = (unsigned short )tmp;
      }
#line 1951
      if ((int )do_qtype == 65432) {
#line 1952
        goto while_break___0;
      }
      {
#line 1954
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)".");
#line 1955
      fflush(stderr);
#line 1957
      tmp___0 = handshake_qtypetest(dns_fd, timeout);
      }
#line 1957
      if (tmp___0) {
#line 1959
        highestworking = qtypenum;
#line 1964
        goto while_break___0;
      }
#line 1949
      qtypenum ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1969
    if (highestworking == 0) {
#line 1971
      goto while_break;
    }
#line 1948
    timeout ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1974
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
  }
#line 1976
  if (! running) {
    {
#line 1977
    warnx("Stopped while autodetecting DNS query type (try setting manually with -T)");
    }
#line 1978
    return (1);
  }
  {
#line 1982
  tmp___1 = handshake_qtype_numcvt(highestworking);
#line 1982
  do_qtype = (unsigned short )tmp___1;
  }
#line 1984
  if ((int )do_qtype == 65432) {
    {
#line 1986
    warnx("No suitable DNS query type found. Are you connected to a network?");
#line 1987
    warnx("If you expect very long roundtrip delays, use -T explicitly.");
#line 1988
    warnx("(Also, connecting to an \"ancient\" version of iodined won\'t work.)");
    }
#line 1989
    return (1);
  }
#line 1993
  return (0);
}
}
#line 1996 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
static int handshake_edns0_check(int dns_fd ) 
{ 
  char in[4096] ;
  int i ;
  int read___0 ;
  char *s ;
  int slen ;
  char trycodec ;
  int k ;

  {
#line 2006
  s = (char *)"\000\000\000\000\377\377\377\377UUUU\252\252\252\252\201c\310\322\307|\262\027_O\316\311I-R!a\251q %\263\006s\346\330D0yPW\277";
#line 2007
  slen = 48;
#line 2010
  if ((int )do_qtype == 10) {
#line 2011
    trycodec = (char )'R';
  } else {
#line 2013
    trycodec = (char )'T';
  }
#line 2015
  i = 0;
  {
#line 2015
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2015
    if (running) {
#line 2015
      if (! (i < 3)) {
#line 2015
        goto while_break;
      }
    } else {
#line 2015
      goto while_break;
    }
    {
#line 2017
    send_downenctest(dns_fd, trycodec, 1, (char *)((void *)0), 0);
#line 2019
    read___0 = handshake_waitdns(dns_fd, in, (int )sizeof(in), (char )'y', (char )'Y',
                                 i + 1);
    }
#line 2021
    if (read___0 == -2) {
#line 2022
      return (0);
    }
#line 2024
    if (read___0 > 0) {
#line 2024
      if (read___0 != slen) {
#line 2025
        return (0);
      }
    }
#line 2027
    if (read___0 > 0) {
#line 2029
      k = 0;
      {
#line 2029
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2029
        if (! (k < slen)) {
#line 2029
          goto while_break___0;
        }
#line 2030
        if ((int )in[k] != (int )*(s + k)) {
#line 2032
          return (0);
        }
#line 2029
        k ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 2036
      return (1);
    }
    {
#line 2039
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Retrying EDNS0 support test...\n");
#line 2015
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2043
  return (0);
}
}
#line 2046 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
static void handshake_switch_codec(int dns_fd , int bits ) 
{ 
  char in[4096] ;
  int i ;
  int read___0 ;
  struct encoder *tempenc ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 2054
  if (bits == 5) {
    {
#line 2055
    tempenc = get_base32_encoder();
    }
  } else
#line 2056
  if (bits == 6) {
    {
#line 2057
    tempenc = get_base64_encoder();
    }
  } else
#line 2058
  if (bits == 26) {
    {
#line 2059
    tempenc = get_base64u_encoder();
    }
  } else
#line 2060
  if (bits == 7) {
    {
#line 2061
    tempenc = get_base128_encoder();
    }
  } else {
#line 2062
    return;
  }
  {
#line 2064
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Switching upstream to codec %s\n",
          tempenc->name);
#line 2066
  i = 0;
  }
  {
#line 2066
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2066
    if (running) {
#line 2066
      if (! (i < 5)) {
#line 2066
        goto while_break;
      }
    } else {
#line 2066
      goto while_break;
    }
    {
#line 2068
    send_codec_switch(dns_fd, (int )userid, bits);
#line 2070
    read___0 = handshake_waitdns(dns_fd, in, (int )sizeof(in), (char )'s', (char )'S',
                                 i + 1);
    }
#line 2073
    if (read___0 > 0) {
      {
#line 2074
      tmp___1 = strncmp("BADLEN", (char const   *)(in), (size_t )6);
      }
#line 2074
      if (tmp___1 == 0) {
        {
#line 2075
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Server got bad message length. ");
        }
#line 2076
        goto codec_revert;
      } else {
        {
#line 2077
        tmp___0 = strncmp("BADIP", (char const   *)(in), (size_t )5);
        }
#line 2077
        if (tmp___0 == 0) {
          {
#line 2078
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Server rejected sender IP address. ");
          }
#line 2079
          goto codec_revert;
        } else {
          {
#line 2080
          tmp = strncmp("BADCODEC", (char const   *)(in), (size_t )8);
          }
#line 2080
          if (tmp == 0) {
            {
#line 2081
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Server rejected the selected codec. ");
            }
#line 2082
            goto codec_revert;
          }
        }
      }
      {
#line 2084
      in[read___0] = (char)0;
#line 2085
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Server switched upstream to codec %s\n",
              in);
#line 2086
      dataenc = tempenc;
      }
#line 2087
      return;
    }
    {
#line 2091
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Retrying codec switch...\n");
#line 2066
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2093
  if (! running) {
#line 2094
    return;
  }
  {
#line 2096
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"No reply from server on codec switch. ");
  }
  codec_revert: 
  {
#line 2099
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Falling back to upstream codec %s\n",
          dataenc->name);
  }
#line 2100
  return;
}
}
#line 2102 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
static void handshake_switch_downenc(int dns_fd ) 
{ 
  char in[4096] ;
  int i ;
  int read___0 ;
  char *dname ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 2110
  dname = (char *)"Base32";
#line 2111
  if ((int )downenc == 83) {
#line 2112
    dname = (char *)"Base64";
  } else
#line 2113
  if ((int )downenc == 85) {
#line 2114
    dname = (char *)"Base64u";
  } else
#line 2115
  if ((int )downenc == 86) {
#line 2116
    dname = (char *)"Base128";
  } else
#line 2117
  if ((int )downenc == 82) {
#line 2118
    dname = (char *)"Raw";
  }
  {
#line 2120
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Switching downstream to codec %s\n",
          dname);
#line 2121
  i = 0;
  }
  {
#line 2121
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2121
    if (running) {
#line 2121
      if (! (i < 5)) {
#line 2121
        goto while_break;
      }
    } else {
#line 2121
      goto while_break;
    }
    {
#line 2123
    send_downenc_switch(dns_fd, (int )userid);
#line 2125
    read___0 = handshake_waitdns(dns_fd, in, (int )sizeof(in), (char )'o', (char )'O',
                                 i + 1);
    }
#line 2128
    if (read___0 > 0) {
      {
#line 2129
      tmp___1 = strncmp("BADLEN", (char const   *)(in), (size_t )6);
      }
#line 2129
      if (tmp___1 == 0) {
        {
#line 2130
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Server got bad message length. ");
        }
#line 2131
        goto codec_revert;
      } else {
        {
#line 2132
        tmp___0 = strncmp("BADIP", (char const   *)(in), (size_t )5);
        }
#line 2132
        if (tmp___0 == 0) {
          {
#line 2133
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Server rejected sender IP address. ");
          }
#line 2134
          goto codec_revert;
        } else {
          {
#line 2135
          tmp = strncmp("BADCODEC", (char const   *)(in), (size_t )8);
          }
#line 2135
          if (tmp == 0) {
            {
#line 2136
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Server rejected the selected codec. ");
            }
#line 2137
            goto codec_revert;
          }
        }
      }
      {
#line 2139
      in[read___0] = (char)0;
#line 2140
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Server switched downstream to codec %s\n",
              in);
      }
#line 2141
      return;
    }
    {
#line 2145
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Retrying codec switch...\n");
#line 2121
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2147
  if (! running) {
#line 2148
    return;
  }
  {
#line 2150
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"No reply from server on codec switch. ");
  }
  codec_revert: 
  {
#line 2153
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Falling back to downstream codec Base32\n");
  }
#line 2154
  return;
}
}
#line 2156 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
static void handshake_try_lazy(int dns_fd ) 
{ 
  char in[4096] ;
  int i ;
  int read___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 2163
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Switching to lazy mode for low-latency\n");
#line 2164
  i = 0;
  }
  {
#line 2164
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2164
    if (running) {
#line 2164
      if (! (i < 5)) {
#line 2164
        goto while_break;
      }
    } else {
#line 2164
      goto while_break;
    }
    {
#line 2166
    send_lazy_switch(dns_fd, (int )userid);
#line 2168
    read___0 = handshake_waitdns(dns_fd, in, (int )sizeof(in), (char )'o', (char )'O',
                                 i + 1);
    }
#line 2171
    if (read___0 > 0) {
      {
#line 2172
      tmp___2 = strncmp("BADLEN", (char const   *)(in), (size_t )6);
      }
#line 2172
      if (tmp___2 == 0) {
        {
#line 2173
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Server got bad message length. ");
        }
#line 2174
        goto codec_revert;
      } else {
        {
#line 2175
        tmp___1 = strncmp("BADIP", (char const   *)(in), (size_t )5);
        }
#line 2175
        if (tmp___1 == 0) {
          {
#line 2176
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Server rejected sender IP address. ");
          }
#line 2177
          goto codec_revert;
        } else {
          {
#line 2178
          tmp___0 = strncmp("BADCODEC", (char const   *)(in), (size_t )8);
          }
#line 2178
          if (tmp___0 == 0) {
            {
#line 2179
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Server rejected lazy mode. ");
            }
#line 2180
            goto codec_revert;
          } else {
            {
#line 2181
            tmp = strncmp("Lazy", (char const   *)(in), (size_t )4);
            }
#line 2181
            if (tmp == 0) {
              {
#line 2182
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Server switched to lazy mode\n");
#line 2183
              lazymode = 1;
              }
#line 2184
              return;
            }
          }
        }
      }
    }
    {
#line 2189
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Retrying lazy mode switch...\n");
#line 2164
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2191
  if (! running) {
#line 2192
    return;
  }
  {
#line 2194
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"No reply from server on lazy switch. ");
  }
  codec_revert: 
  {
#line 2197
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Falling back to legacy mode\n");
#line 2198
  lazymode = 0;
#line 2199
  selecttimeout = 1;
  }
#line 2200
  return;
}
}
#line 2202 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
static void handshake_lazyoff(int dns_fd ) 
{ 
  char in[4096] ;
  int i ;
  int read___0 ;
  int tmp ;

  {
#line 2210
  i = 0;
  {
#line 2210
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2210
    if (running) {
#line 2210
      if (! (i < 5)) {
#line 2210
        goto while_break;
      }
    } else {
#line 2210
      goto while_break;
    }
    {
#line 2212
    send_lazy_switch(dns_fd, (int )userid);
#line 2214
    read___0 = handshake_waitdns(dns_fd, in, (int )sizeof(in), (char )'o', (char )'O',
                                 1);
    }
#line 2217
    if (read___0 == 9) {
      {
#line 2217
      tmp = strncmp("Immediate", (char const   *)(in), (size_t )9);
      }
#line 2217
      if (tmp == 0) {
        {
#line 2218
        warnx("Server switched back to legacy mode.\n");
#line 2219
        lazymode = 0;
#line 2220
        selecttimeout = 1;
        }
#line 2221
        return;
      }
    }
#line 2210
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2225
  if (! running) {
#line 2226
    return;
  }
  {
#line 2228
  warnx("No reply from server on legacy mode switch.\n");
  }
#line 2229
  return;
}
}
#line 2231 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
static int fragsize_check(char *in , int read___0 , int proposed_fragsize , int *max_fragsize ) 
{ 
  int acked_fragsize ;
  int okay ;
  int i ;
  unsigned int v ;
  int tmp ;

  {
#line 2235
  acked_fragsize = (((int )*(in + 0) & 255) << 8) | ((int )*(in + 1) & 255);
#line 2240
  if (read___0 >= 5) {
    {
#line 2240
    tmp = strncmp("BADIP", (char const   *)in, (size_t )5);
    }
#line 2240
    if (tmp == 0) {
      {
#line 2241
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"got BADIP (Try iodined -c)..\n");
#line 2242
      fflush(stderr);
      }
#line 2243
      return (0);
    }
  }
#line 2246
  if (acked_fragsize != proposed_fragsize) {
#line 2251
    return (0);
  }
#line 2254
  if (read___0 != proposed_fragsize) {
#line 2259
    return (1);
  }
#line 2267
  if (((int )*(in + 2) & 255) != 107) {
    {
#line 2268
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 2269
    warnx("corruption at byte 2, this won\'t work. Try -O Base32, or other -T options.");
#line 2270
    *max_fragsize = -1;
    }
#line 2271
    return (1);
  }
#line 2275
  okay = 1;
#line 2276
  v = (unsigned int )((int )*(in + 3) & 255);
#line 2279
  i = 3;
  {
#line 2279
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2279
    if (! (i < read___0)) {
#line 2279
      goto while_break;
    }
#line 2280
    if ((unsigned int )((int )*(in + i) & 255) != v) {
#line 2281
      okay = 0;
#line 2282
      goto while_break;
    }
#line 2279
    i ++;
#line 2279
    v = (v + 107U) & 255U;
  }
  while_break: /* CIL Label */ ;
  }
#line 2285
  if (okay) {
    {
#line 2286
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%d ok.. ",
            acked_fragsize);
#line 2287
    fflush(stderr);
#line 2288
    *max_fragsize = acked_fragsize;
    }
#line 2289
    return (1);
  } else {
#line 2291
    if ((int )downenc != 32) {
#line 2291
      if ((int )downenc != 84) {
        {
#line 2292
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%d corrupted at %d.. (Try -O Base32)\n",
                acked_fragsize, i);
        }
      } else {
        {
#line 2294
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%d corrupted at %d.. ",
                acked_fragsize, i);
        }
      }
    } else {
      {
#line 2294
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%d corrupted at %d.. ",
              acked_fragsize, i);
      }
    }
    {
#line 2296
    fflush(stderr);
    }
#line 2297
    return (1);
  }
#line 2302
  return (1);
}
}
#line 2306 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
static int handshake_autoprobe_fragsize(int dns_fd ) 
{ 
  char in[4096] ;
  int i ;
  int read___0 ;
  int proposed_fragsize ;
  int range ;
  int max_fragsize ;
  int tmp ;

  {
  {
#line 2312
  proposed_fragsize = 768;
#line 2313
  range = 768;
#line 2316
  max_fragsize = 0;
#line 2317
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Autoprobing max downstream fragment size... (skip with -m fragsize)\n");
  }
  {
#line 2318
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2318
    if (running) {
#line 2318
      if (range > 0) {
#line 2318
        if (! (range >= 8)) {
#line 2318
          if (! (max_fragsize < 300)) {
#line 2318
            goto while_break;
          }
        }
      } else {
#line 2318
        goto while_break;
      }
    } else {
#line 2318
      goto while_break;
    }
#line 2320
    i = 0;
    {
#line 2320
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2320
      if (running) {
#line 2320
        if (! (i < 3)) {
#line 2320
          goto while_break___0;
        }
      } else {
#line 2320
        goto while_break___0;
      }
      {
#line 2322
      send_fragsize_probe(dns_fd, proposed_fragsize);
#line 2324
      read___0 = handshake_waitdns(dns_fd, in, (int )sizeof(in), (char )'r', (char )'R',
                                   1);
      }
#line 2327
      if (read___0 > 0) {
        {
#line 2329
        tmp = fragsize_check(in, read___0, proposed_fragsize, & max_fragsize);
        }
#line 2329
        if (tmp == 1) {
#line 2330
          goto while_break___0;
        }
      }
      {
#line 2334
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)".");
#line 2335
      fflush(stderr);
#line 2320
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2337
    if (max_fragsize < 0) {
#line 2338
      goto while_break;
    }
#line 2340
    range >>= 1;
#line 2341
    if (max_fragsize == proposed_fragsize) {
#line 2343
      proposed_fragsize += range;
    } else {
      {
#line 2346
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%d not ok.. ",
              proposed_fragsize);
#line 2347
      fflush(stderr);
#line 2348
      proposed_fragsize -= range;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2351
  if (! running) {
    {
#line 2352
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 2353
    warnx("stopped while autodetecting fragment size (Try setting manually with -m)");
    }
#line 2354
    return (0);
  }
#line 2356
  if (max_fragsize <= 2) {
    {
#line 2360
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 2361
    warnx("found no accepted fragment size.");
#line 2362
    warnx("try setting -M to 200 or lower, or try other -T or -O options.");
    }
#line 2363
    return (0);
  }
  {
#line 2366
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"will use %d-2=%d\n",
          max_fragsize, max_fragsize - 2);
  }
#line 2369
  if (max_fragsize < 82) {
    {
#line 2370
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Note: this probably won\'t work well.\n");
#line 2371
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Try setting -M to 200 or lower, or try other DNS types (-T option).\n");
    }
  } else
#line 2372
  if (max_fragsize < 202) {
#line 2372
    if ((int )do_qtype == 10) {
      {
#line 2375
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Note: this isn\'t very much.\n");
#line 2376
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Try setting -M to 200 or lower, or try other DNS types (-T option).\n");
      }
    } else
#line 2372
    if ((int )do_qtype == 16) {
      {
#line 2375
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Note: this isn\'t very much.\n");
#line 2376
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Try setting -M to 200 or lower, or try other DNS types (-T option).\n");
      }
    } else
#line 2372
    if ((int )do_qtype == 33) {
      {
#line 2375
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Note: this isn\'t very much.\n");
#line 2376
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Try setting -M to 200 or lower, or try other DNS types (-T option).\n");
      }
    } else
#line 2372
    if ((int )do_qtype == 15) {
      {
#line 2375
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Note: this isn\'t very much.\n");
#line 2376
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Try setting -M to 200 or lower, or try other DNS types (-T option).\n");
      }
    }
  }
#line 2379
  return (max_fragsize - 2);
}
}
#line 2382 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
static void handshake_set_fragsize(int dns_fd , int fragsize ) 
{ 
  char in[4096] ;
  int i ;
  int read___0 ;
  int accepted_fragsize ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 2389
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Setting downstream fragment size to max %d...\n",
          fragsize);
#line 2390
  i = 0;
  }
  {
#line 2390
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2390
    if (running) {
#line 2390
      if (! (i < 5)) {
#line 2390
        goto while_break;
      }
    } else {
#line 2390
      goto while_break;
    }
    {
#line 2392
    send_set_downstream_fragsize(dns_fd, fragsize);
#line 2394
    read___0 = handshake_waitdns(dns_fd, in, (int )sizeof(in), (char )'n', (char )'N',
                                 i + 1);
    }
#line 2397
    if (read___0 > 0) {
      {
#line 2400
      tmp___0 = strncmp("BADFRAG", (char const   *)(in), (size_t )7);
      }
#line 2400
      if (tmp___0 == 0) {
        {
#line 2401
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Server rejected fragsize. Keeping default.");
        }
#line 2402
        return;
      } else {
        {
#line 2403
        tmp = strncmp("BADIP", (char const   *)(in), (size_t )5);
        }
#line 2403
        if (tmp == 0) {
          {
#line 2404
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Server rejected sender IP address.\n");
          }
#line 2405
          return;
        }
      }
#line 2408
      accepted_fragsize = (((int )in[0] & 255) << 8) | ((int )in[1] & 255);
#line 2409
      return;
    }
    {
#line 2413
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Retrying set fragsize...\n");
#line 2390
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2415
  if (! running) {
#line 2416
    return;
  }
  {
#line 2418
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"No reply from server when setting fragsize. Keeping default.\n");
  }
#line 2419
  return;
}
}
#line 2421 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/client.c"
int client_handshake(int dns_fd , int raw_mode , int autodetect_frag_size , int fragsize ) 
{ 
  int seed ;
  int upcodec ;
  int r ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 2428
  dnsc_use_edns0 = 0;
#line 2431
  if ((int )do_qtype == 65432) {
    {
#line 2432
    r = handshake_qtype_autodetect(dns_fd);
    }
#line 2433
    if (r) {
#line 2434
      return (r);
    }
  }
  {
#line 2438
  tmp = get_qtype();
#line 2438
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Using DNS type %s queries\n",
          tmp);
#line 2440
  r = handshake_version(dns_fd, & seed);
  }
#line 2441
  if (r) {
#line 2442
    return (r);
  }
  {
#line 2445
  r = handshake_login(dns_fd, seed);
  }
#line 2446
  if (r) {
#line 2447
    return (r);
  }
#line 2450
  if (raw_mode) {
    {
#line 2450
    tmp___1 = handshake_raw_udp(dns_fd, seed);
    }
#line 2450
    if (tmp___1) {
#line 2451
      conn = (enum connection )0;
#line 2452
      selecttimeout = 20;
    } else {
#line 2450
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 2454
    if (raw_mode == 0) {
      {
#line 2455
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Skipping raw mode\n");
      }
    }
    {
#line 2458
    dnsc_use_edns0 = 1;
#line 2459
    tmp___0 = handshake_edns0_check(dns_fd);
    }
#line 2459
    if (tmp___0) {
#line 2459
      if (running) {
        {
#line 2460
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Using EDNS0 extension\n");
        }
      } else {
#line 2459
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 2461
    if (! running) {
#line 2462
      return (-1);
    } else {
      {
#line 2464
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"DNS relay does not support EDNS0 extension\n");
#line 2465
      dnsc_use_edns0 = 0;
      }
    }
    {
#line 2468
    upcodec = handshake_upenc_autodetect(dns_fd);
    }
#line 2469
    if (! running) {
#line 2470
      return (-1);
    }
#line 2472
    if (upcodec == 1) {
      {
#line 2473
      handshake_switch_codec(dns_fd, 6);
      }
    } else
#line 2474
    if (upcodec == 2) {
      {
#line 2475
      handshake_switch_codec(dns_fd, 26);
      }
    } else
#line 2476
    if (upcodec == 3) {
      {
#line 2477
      handshake_switch_codec(dns_fd, 7);
      }
    }
#line 2479
    if (! running) {
#line 2480
      return (-1);
    }
#line 2482
    if ((int )downenc == 32) {
      {
#line 2483
      downenc = handshake_downenc_autodetect(dns_fd);
      }
    }
#line 2485
    if (! running) {
#line 2486
      return (-1);
    }
#line 2488
    if ((int )downenc != 32) {
      {
#line 2489
      handshake_switch_downenc(dns_fd);
      }
    }
#line 2491
    if (! running) {
#line 2492
      return (-1);
    }
#line 2494
    if (lazymode) {
      {
#line 2495
      handshake_try_lazy(dns_fd);
      }
    }
#line 2497
    if (! running) {
#line 2498
      return (-1);
    }
#line 2500
    if (autodetect_frag_size) {
      {
#line 2501
      fragsize = handshake_autoprobe_fragsize(dns_fd);
      }
#line 2502
      if (! fragsize) {
#line 2503
        return (1);
      }
    }
    {
#line 2507
    handshake_set_fragsize(dns_fd, fragsize);
    }
#line 2508
    if (! running) {
#line 2509
      return (-1);
    }
  }
#line 2512
  return (0);
}
}
#line 28 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base32.c"
static char const   cb32___0[33]  = 
#line 28 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base32.c"
  {      (char const   )'a',      (char const   )'b',      (char const   )'c',      (char const   )'d', 
        (char const   )'e',      (char const   )'f',      (char const   )'g',      (char const   )'h', 
        (char const   )'i',      (char const   )'j',      (char const   )'k',      (char const   )'l', 
        (char const   )'m',      (char const   )'n',      (char const   )'o',      (char const   )'p', 
        (char const   )'q',      (char const   )'r',      (char const   )'s',      (char const   )'t', 
        (char const   )'u',      (char const   )'v',      (char const   )'w',      (char const   )'x', 
        (char const   )'y',      (char const   )'z',      (char const   )'0',      (char const   )'1', 
        (char const   )'2',      (char const   )'3',      (char const   )'4',      (char const   )'5', 
        (char const   )'\000'};
#line 30 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base32.c"
static char const   cb32_ucase___0[33]  = 
#line 30
  {      (char const   )'A',      (char const   )'B',      (char const   )'C',      (char const   )'D', 
        (char const   )'E',      (char const   )'F',      (char const   )'G',      (char const   )'H', 
        (char const   )'I',      (char const   )'J',      (char const   )'K',      (char const   )'L', 
        (char const   )'M',      (char const   )'N',      (char const   )'O',      (char const   )'P', 
        (char const   )'Q',      (char const   )'R',      (char const   )'S',      (char const   )'T', 
        (char const   )'U',      (char const   )'V',      (char const   )'W',      (char const   )'X', 
        (char const   )'Y',      (char const   )'Z',      (char const   )'0',      (char const   )'1', 
        (char const   )'2',      (char const   )'3',      (char const   )'4',      (char const   )'5', 
        (char const   )'\000'};
#line 32 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base32.c"
static unsigned char rev32___0[256]  ;
#line 33 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base32.c"
static int reverse_init___3  =    0;
#line 35
static int base32_encode___0(char *buf , size_t *buflen , void const   *data , size_t size ) ;
#line 36
static int base32_decode___0(void *buf , size_t *buflen , char const   *str , size_t slen ) ;
#line 37
static int base32_handles_dots___0(void) ;
#line 38
static int base32_blksize_raw___0(void) ;
#line 39
static int base32_blksize_enc___0(void) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base32.c"
static struct encoder base32_encoder___0  =    {{(char )'B', (char )'a', (char )'s', (char )'e', (char )'3', (char )'2', (char )'\000'},
    & base32_encode___0, & base32_decode___0, & base32_handles_dots___0, & base32_handles_dots___0,
    & base32_blksize_raw___0, & base32_blksize_enc___0};
#line 58 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base32.c"
static int base32_handles_dots___0(void) 
{ 


  {
#line 61
  return (0);
}
}
#line 64 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base32.c"
static int base32_blksize_raw___0(void) 
{ 


  {
#line 67
  return (5);
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base32.c"
static int base32_blksize_enc___0(void) 
{ 


  {
#line 73
  return (8);
}
}
#line 76 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base32.c"
__inline static void base32_reverse_init___0(void) 
{ 
  int i ;
  unsigned char c ;

  {
#line 82
  if (! reverse_init___3) {
    {
#line 83
    memset((void *)(rev32___0), 0, (size_t )256);
#line 84
    i = 0;
    }
    {
#line 84
    while (1) {
      while_continue: /* CIL Label */ ;
#line 84
      if (! (i < 32)) {
#line 84
        goto while_break;
      }
#line 85
      c = (unsigned char )cb32___0[i];
#line 86
      rev32___0[(int )c] = (unsigned char )i;
#line 87
      c = (unsigned char )cb32_ucase___0[i];
#line 88
      rev32___0[(int )c] = (unsigned char )i;
#line 84
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 90
    reverse_init___3 = 1;
  }
#line 92
  return;
}
}
#line 107 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base32.c"
static int base32_encode___0(char *buf , size_t *buflen , void const   *data , size_t size ) 
{ 
  unsigned char *udata ;
  int iout ;
  int iin ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 119
  udata = (unsigned char *)data;
#line 120
  iout = 0;
#line 121
  iin = 0;
  {
#line 127
  while (1) {
    while_continue: /* CIL Label */ ;
#line 128
    if ((size_t )iout >= *buflen) {
#line 129
      goto while_break;
    } else
#line 128
    if ((size_t )iin >= size) {
#line 129
      goto while_break;
    }
#line 130
    *(buf + iout) = (char )cb32___0[((int )*(udata + iin) & 248) >> 3];
#line 131
    iout ++;
#line 133
    if ((size_t )iout >= *buflen) {
#line 134
      iout --;
#line 135
      goto while_break;
    } else
#line 133
    if ((size_t )iin >= size) {
#line 134
      iout --;
#line 135
      goto while_break;
    }
#line 137
    if ((size_t )(iin + 1) < size) {
#line 137
      tmp = ((int )*(udata + (iin + 1)) & 192) >> 6;
    } else {
#line 137
      tmp = 0;
    }
#line 137
    *(buf + iout) = (char )cb32___0[(((int )*(udata + iin) & 7) << 2) | tmp];
#line 140
    iin ++;
#line 141
    iout ++;
#line 143
    if ((size_t )iout >= *buflen) {
#line 144
      goto while_break;
    } else
#line 143
    if ((size_t )iin >= size) {
#line 144
      goto while_break;
    }
#line 145
    *(buf + iout) = (char )cb32___0[((int )*(udata + iin) & 62) >> 1];
#line 146
    iout ++;
#line 148
    if ((size_t )iout >= *buflen) {
#line 149
      iout --;
#line 150
      goto while_break;
    } else
#line 148
    if ((size_t )iin >= size) {
#line 149
      iout --;
#line 150
      goto while_break;
    }
#line 152
    if ((size_t )(iin + 1) < size) {
#line 152
      tmp___0 = ((int )*(udata + (iin + 1)) & 240) >> 4;
    } else {
#line 152
      tmp___0 = 0;
    }
#line 152
    *(buf + iout) = (char )cb32___0[(((int )*(udata + iin) & 1) << 4) | tmp___0];
#line 155
    iin ++;
#line 156
    iout ++;
#line 158
    if ((size_t )iout >= *buflen) {
#line 159
      goto while_break;
    } else
#line 158
    if ((size_t )iin >= size) {
#line 159
      goto while_break;
    }
#line 160
    if ((size_t )(iin + 1) < size) {
#line 160
      tmp___1 = ((int )*(udata + (iin + 1)) & 128) >> 7;
    } else {
#line 160
      tmp___1 = 0;
    }
#line 160
    *(buf + iout) = (char )cb32___0[(((int )*(udata + iin) & 15) << 1) | tmp___1];
#line 163
    iin ++;
#line 164
    iout ++;
#line 166
    if ((size_t )iout >= *buflen) {
#line 167
      goto while_break;
    } else
#line 166
    if ((size_t )iin >= size) {
#line 167
      goto while_break;
    }
#line 168
    *(buf + iout) = (char )cb32___0[((int )*(udata + iin) & 124) >> 2];
#line 169
    iout ++;
#line 171
    if ((size_t )iout >= *buflen) {
#line 172
      iout --;
#line 173
      goto while_break;
    } else
#line 171
    if ((size_t )iin >= size) {
#line 172
      iout --;
#line 173
      goto while_break;
    }
#line 175
    if ((size_t )(iin + 1) < size) {
#line 175
      tmp___2 = ((int )*(udata + (iin + 1)) & 224) >> 5;
    } else {
#line 175
      tmp___2 = 0;
    }
#line 175
    *(buf + iout) = (char )cb32___0[(((int )*(udata + iin) & 3) << 3) | tmp___2];
#line 178
    iin ++;
#line 179
    iout ++;
#line 181
    if ((size_t )iout >= *buflen) {
#line 182
      goto while_break;
    } else
#line 181
    if ((size_t )iin >= size) {
#line 182
      goto while_break;
    }
#line 183
    *(buf + iout) = (char )cb32___0[(int )*(udata + iin) & 31];
#line 184
    iin ++;
#line 185
    iout ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 188
  *(buf + iout) = (char )'\000';
#line 191
  *buflen = (size_t )iin;
#line 193
  return (iout);
}
}
#line 198 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base32.c"
static int base32_decode___0(void *buf , size_t *buflen , char const   *str , size_t slen ) 
{ 
  unsigned char *ubuf ;
  int iout ;
  int iin ;

  {
  {
#line 212
  ubuf = (unsigned char *)buf;
#line 213
  iout = 0;
#line 214
  iin = 0;
#line 216
  base32_reverse_init___0();
  }
  {
#line 221
  while (1) {
    while_continue: /* CIL Label */ ;
#line 222
    if ((size_t )iout >= *buflen) {
#line 224
      goto while_break;
    } else
#line 222
    if ((size_t )(iin + 1) >= slen) {
#line 224
      goto while_break;
    } else
#line 222
    if ((int const   )*(str + iin) == 0) {
#line 224
      goto while_break;
    } else
#line 222
    if ((int const   )*(str + (iin + 1)) == 0) {
#line 224
      goto while_break;
    }
#line 225
    *(ubuf + iout) = (unsigned char )((((int )rev32___0[(int )*(str + iin)] & 31) << 3) | (((int )rev32___0[(int )*(str + (iin + 1))] & 28) >> 2));
#line 227
    iin ++;
#line 228
    iout ++;
#line 230
    if ((size_t )iout >= *buflen) {
#line 233
      goto while_break;
    } else
#line 230
    if ((size_t )(iin + 2) >= slen) {
#line 233
      goto while_break;
    } else
#line 230
    if ((int const   )*(str + iin) == 0) {
#line 233
      goto while_break;
    } else
#line 230
    if ((int const   )*(str + (iin + 1)) == 0) {
#line 233
      goto while_break;
    } else
#line 230
    if ((int const   )*(str + (iin + 2)) == 0) {
#line 233
      goto while_break;
    }
#line 234
    *(ubuf + iout) = (unsigned char )(((((int )rev32___0[(int )*(str + iin)] & 3) << 6) | (((int )rev32___0[(int )*(str + (iin + 1))] & 31) << 1)) | (((int )rev32___0[(int )*(str + (iin + 2))] & 16) >> 4));
#line 237
    iin += 2;
#line 238
    iout ++;
#line 240
    if ((size_t )iout >= *buflen) {
#line 242
      goto while_break;
    } else
#line 240
    if ((size_t )(iin + 1) >= slen) {
#line 242
      goto while_break;
    } else
#line 240
    if ((int const   )*(str + iin) == 0) {
#line 242
      goto while_break;
    } else
#line 240
    if ((int const   )*(str + (iin + 1)) == 0) {
#line 242
      goto while_break;
    }
#line 243
    *(ubuf + iout) = (unsigned char )((((int )rev32___0[(int )*(str + iin)] & 15) << 4) | (((int )rev32___0[(int )*(str + (iin + 1))] & 30) >> 1));
#line 245
    iin ++;
#line 246
    iout ++;
#line 248
    if ((size_t )iout >= *buflen) {
#line 251
      goto while_break;
    } else
#line 248
    if ((size_t )(iin + 2) >= slen) {
#line 251
      goto while_break;
    } else
#line 248
    if ((int const   )*(str + iin) == 0) {
#line 251
      goto while_break;
    } else
#line 248
    if ((int const   )*(str + (iin + 1)) == 0) {
#line 251
      goto while_break;
    } else
#line 248
    if ((int const   )*(str + (iin + 2)) == 0) {
#line 251
      goto while_break;
    }
#line 252
    *(ubuf + iout) = (unsigned char )(((((int )rev32___0[(int )*(str + iin)] & 1) << 7) | (((int )rev32___0[(int )*(str + (iin + 1))] & 31) << 2)) | (((int )rev32___0[(int )*(str + (iin + 2))] & 24) >> 3));
#line 255
    iin += 2;
#line 256
    iout ++;
#line 258
    if ((size_t )iout >= *buflen) {
#line 260
      goto while_break;
    } else
#line 258
    if ((size_t )(iin + 1) >= slen) {
#line 260
      goto while_break;
    } else
#line 258
    if ((int const   )*(str + iin) == 0) {
#line 260
      goto while_break;
    } else
#line 258
    if ((int const   )*(str + (iin + 1)) == 0) {
#line 260
      goto while_break;
    }
#line 261
    *(ubuf + iout) = (unsigned char )((((int )rev32___0[(int )*(str + iin)] & 7) << 5) | ((int )rev32___0[(int )*(str + (iin + 1))] & 31));
#line 263
    iin += 2;
#line 264
    iout ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 267
  *(ubuf + iout) = (unsigned char )'\000';
#line 269
  return (iout);
}
}
#line 36 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/fw_query.h"
void fw_query_init(void) ;
#line 37
void fw_query_put(struct fw_query *fw_query ) ;
#line 38
void fw_query_get(unsigned short query_id , struct fw_query **fw_query ) ;
#line 20 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/fw_query.c"
static struct fw_query fwq[16]  ;
#line 21 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/fw_query.c"
static int fwq_ix  ;
#line 23 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/fw_query.c"
void fw_query_init(void) 
{ 


  {
  {
#line 25
  memset((void *)(fwq), 0, sizeof(struct fw_query ) * 16UL);
#line 26
  fwq_ix = 0;
  }
#line 27
  return;
}
}
#line 29 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/fw_query.c"
void fw_query_put(struct fw_query *fw_query ) 
{ 


  {
  {
#line 31
  memcpy((void */* __restrict  */)(& fwq[fwq_ix]), (void const   */* __restrict  */)fw_query,
         sizeof(struct fw_query ));
#line 33
  fwq_ix ++;
  }
#line 34
  if (fwq_ix >= 16) {
#line 35
    fwq_ix = 0;
  }
#line 36
  return;
}
}
#line 38 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/fw_query.c"
void fw_query_get(unsigned short query_id , struct fw_query **fw_query ) 
{ 
  int i ;

  {
#line 42
  *fw_query = (struct fw_query *)((void *)0);
#line 43
  i = 0;
  {
#line 43
  while (1) {
    while_continue: /* CIL Label */ ;
#line 43
    if (! (i < 16)) {
#line 43
      goto while_break;
    }
#line 44
    if ((int )fwq[i].id == (int )query_id) {
#line 45
      *fw_query = & fwq[i];
#line 46
      return;
    }
#line 43
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 49
  return;
}
}
#line 79 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/user.h"
struct _user users[16]  ;
#line 81
int init_users(in_addr_t my_ip___0 , int netbits ) ;
#line 82
char const   *users_get_first_ip(void) ;
#line 83
int users_waiting_on_reply(void) ;
#line 84
int find_user_by_ip(uint32_t ip ) ;
#line 85
int all_users_waiting_to_send(void) ;
#line 86
int find_available_user(void) ;
#line 87
void user_switch_codec(int userid___0 , struct encoder *enc ) ;
#line 88
void user_set_conn_type(int userid___0 , enum connection c ) ;
#line 38 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/user.c"
int init_users(in_addr_t my_ip___0 , int netbits ) 
{ 
  int i ;
  int skip ;
  char newip[16] ;
  int created_users___0 ;
  int maxusers ;
  in_addr_t netmask___0 ;
  struct in_addr net ;
  struct in_addr ipstart ;
  in_addr_t ip ;
  in_addr_t tmp ;
  in_addr_t tmp___0 ;
  int tmp___1 ;

  {
#line 42
  skip = 0;
#line 44
  created_users___0 = 0;
#line 48
  netmask___0 = (in_addr_t )0;
#line 52
  i = 0;
  {
#line 52
  while (1) {
    while_continue: /* CIL Label */ ;
#line 52
    if (! (i < netbits)) {
#line 52
      goto while_break;
    }
#line 53
    netmask___0 = (netmask___0 << 1) | 1U;
#line 52
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 55
  netmask___0 <<= 32 - netbits;
#line 56
  net.s_addr = htonl(netmask___0);
#line 57
  ipstart.s_addr = my_ip___0 & net.s_addr;
#line 59
  maxusers = (1 << (32 - netbits)) - 3;
#line 61
  memset((void *)(users), 0, 16UL * sizeof(struct _user ));
#line 62
  i = 0;
  }
  {
#line 62
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 62
    if (! (i < 16)) {
#line 62
      goto while_break___0;
    }
    {
#line 64
    users[i].id = (char )i;
#line 65
    snprintf((char */* __restrict  */)(newip), sizeof(newip), (char const   */* __restrict  */)"0.0.0.%d",
             (i + skip) + 1);
#line 66
    tmp = inet_addr((char const   *)(newip));
#line 66
    ip = ipstart.s_addr + tmp;
    }
#line 67
    if (ip == my_ip___0) {
#line 67
      if (skip == 0) {
        {
#line 69
        skip ++;
#line 70
        snprintf((char */* __restrict  */)(newip), sizeof(newip), (char const   */* __restrict  */)"0.0.0.%d",
                 (i + skip) + 1);
#line 71
        tmp___0 = inet_addr((char const   *)(newip));
#line 71
        ip = ipstart.s_addr + tmp___0;
        }
      }
    }
#line 73
    users[i].tun_ip = ip;
#line 74
    net.s_addr = ip;
#line 75
    tmp___1 = maxusers;
#line 75
    maxusers --;
#line 75
    if (tmp___1 < 1) {
#line 76
      users[i].disabled = 1;
    } else {
#line 78
      users[i].disabled = 0;
#line 79
      created_users___0 ++;
    }
#line 81
    users[i].active = 0;
#line 62
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 85
  return (created_users___0);
}
}
#line 88 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/user.c"
char const   *users_get_first_ip(void) 
{ 
  struct in_addr ip ;
  char *tmp ;

  {
  {
#line 92
  ip.s_addr = users[0].tun_ip;
#line 93
  tmp = inet_ntoa(ip);
  }
#line 93
  return ((char const   *)tmp);
}
}
#line 96 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/user.c"
int users_waiting_on_reply(void) 
{ 
  int ret ;
  int i ;
  time_t tmp ;

  {
#line 102
  ret = 0;
#line 103
  i = 0;
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
#line 103
    if (! (i < 16)) {
#line 103
      goto while_break;
    }
#line 104
    if (users[i].active) {
#line 104
      if (! users[i].disabled) {
        {
#line 104
        tmp = time((time_t *)((void *)0));
        }
#line 104
        if (users[i].last_pkt + 60L > tmp) {
#line 104
          if ((int )users[i].q.id != 0) {
#line 104
            if ((unsigned int )users[i].conn == 1U) {
#line 107
              ret ++;
            }
          }
        }
      }
    }
#line 103
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 111
  return (ret);
}
}
#line 114 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/user.c"
int find_user_by_ip(uint32_t ip ) 
{ 
  int ret ;
  int i ;
  time_t tmp ;

  {
#line 120
  ret = -1;
#line 121
  i = 0;
  {
#line 121
  while (1) {
    while_continue: /* CIL Label */ ;
#line 121
    if (! (i < 16)) {
#line 121
      goto while_break;
    }
#line 122
    if (users[i].active) {
#line 122
      if (! users[i].disabled) {
        {
#line 122
        tmp = time((time_t *)((void *)0));
        }
#line 122
        if (users[i].last_pkt + 60L > tmp) {
#line 122
          if (ip == users[i].tun_ip) {
#line 125
            ret = i;
#line 126
            goto while_break;
          }
        }
      }
    }
#line 121
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 129
  return (ret);
}
}
#line 132 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/user.c"
int all_users_waiting_to_send(void) 
{ 
  time_t now ;
  int ret ;
  int i ;

  {
  {
#line 144
  ret = 1;
#line 145
  now = time((time_t *)((void *)0));
#line 146
  i = 0;
  }
  {
#line 146
  while (1) {
    while_continue: /* CIL Label */ ;
#line 146
    if (! (i < 16)) {
#line 146
      goto while_break;
    }
#line 147
    if (users[i].active) {
#line 147
      if (! users[i].disabled) {
#line 147
        if (users[i].last_pkt + 60L > now) {
#line 147
          if ((unsigned int )users[i].conn == 0U) {
#line 158
            ret = 0;
#line 159
            goto while_break;
          } else
#line 147
          if ((unsigned int )users[i].conn == 1U) {
#line 147
            if (users[i].outpacketq_filled < 1) {
#line 158
              ret = 0;
#line 159
              goto while_break;
            }
          }
        }
      }
    }
#line 146
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 162
  return (ret);
}
}
#line 165 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/user.c"
int find_available_user(void) 
{ 
  int ret ;
  int i ;
  time_t tmp ;

  {
#line 168
  ret = -1;
#line 170
  i = 0;
  {
#line 170
  while (1) {
    while_continue: /* CIL Label */ ;
#line 170
    if (! (i < 16)) {
#line 170
      goto while_break;
    }
#line 172
    if (! users[i].active) {
#line 172
      goto _L;
    } else {
      {
#line 172
      tmp = time((time_t *)((void *)0));
      }
#line 172
      if (users[i].last_pkt + 60L < tmp) {
        _L: /* CIL Label */ 
#line 172
        if (! users[i].disabled) {
          {
#line 173
          users[i].active = 1;
#line 174
          users[i].last_pkt = time((time_t *)((void *)0));
#line 175
          users[i].fragsize = 4096;
#line 176
          users[i].conn = (enum connection )1;
#line 177
          ret = i;
          }
#line 178
          goto while_break;
        }
      }
    }
#line 170
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 181
  return (ret);
}
}
#line 184 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/user.c"
void user_switch_codec(int userid___0 , struct encoder *enc ) 
{ 


  {
#line 187
  if (userid___0 < 0) {
#line 188
    return;
  } else
#line 187
  if (userid___0 >= 16) {
#line 188
    return;
  }
#line 190
  users[userid___0].encoder = enc;
#line 191
  return;
}
}
#line 193 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/user.c"
void user_set_conn_type(int userid___0 , enum connection c ) 
{ 


  {
#line 196
  if (userid___0 < 0) {
#line 197
    return;
  } else
#line 196
  if (userid___0 >= 16) {
#line 197
    return;
  }
#line 199
  if ((unsigned int )c < 0U) {
#line 200
    return;
  } else
#line 199
  if ((unsigned int )c >= 2U) {
#line 200
    return;
  }
#line 202
  users[userid___0].conn = c;
#line 203
  return;
}
}
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 272 "/usr/include/x86_64-linux-gnu/bits/socket.h"
extern  __attribute__((__nothrow__)) struct cmsghdr *( __attribute__((__leaf__)) __cmsg_nxthdr)(struct msghdr *__mhdr ,
                                                                                                struct cmsghdr *__cmsg ) ;
#line 202 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern ssize_t recvmsg(int __fd , struct msghdr *__message , int __flags ) ;
#line 181 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 69 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/iodined.c"
static int running___0  =    1;
#line 70 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/iodined.c"
static char *topdomain___0  ;
#line 71 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/iodined.c"
static char password___0[33]  ;
#line 72 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/iodined.c"
static struct encoder *b32___0  ;
#line 73 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/iodined.c"
static struct encoder *b64___0  ;
#line 74 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/iodined.c"
static struct encoder *b64u___0  ;
#line 75 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/iodined.c"
static struct encoder *b128___0  ;
#line 76 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/iodined.c"
static int created_users  ;
#line 78 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/iodined.c"
static int check_ip  ;
#line 79 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/iodined.c"
static int my_mtu  ;
#line 80 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/iodined.c"
static in_addr_t my_ip  ;
#line 81 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/iodined.c"
static int netmask  ;
#line 83 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/iodined.c"
static in_addr_t ns_ip  ;
#line 85 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/iodined.c"
static int bind_port  ;
#line 86 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/iodined.c"
static int debug  ;
#line 92
static int read_dns(int fd , int tun_fd , struct query *q ) ;
#line 93
static void write_dns(int fd , struct query *q , char *data , int datalen , char downenc___0 ) ;
#line 94
static void handle_full_packet(int tun_fd , int dns_fd , int userid___0 ) ;
#line 96 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/iodined.c"
static void sigint(int sig ) 
{ 


  {
#line 99
  running___0 = 0;
#line 100
  return;
}
}
#line 119 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/iodined.c"
static int check_user_and_ip(int userid___0 , struct query *q ) 
{ 
  struct sockaddr_in *tempin ;
  time_t tmp ;
  int tmp___0 ;

  {
#line 126
  if (userid___0 < 0) {
#line 127
    return (1);
  } else
#line 126
  if (userid___0 >= created_users) {
#line 127
    return (1);
  }
#line 129
  if (! users[userid___0].active) {
#line 130
    return (1);
  } else
#line 129
  if (users[userid___0].disabled) {
#line 130
    return (1);
  }
  {
#line 132
  tmp = time((time_t *)((void *)0));
  }
#line 132
  if (users[userid___0].last_pkt + 60L < tmp) {
#line 133
    return (1);
  }
#line 137
  if (! check_ip) {
#line 138
    return (0);
  }
  {
#line 141
  tempin = (struct sockaddr_in *)(& q->from);
#line 142
  tmp___0 = memcmp((void const   *)(& users[userid___0].host), (void const   *)(& tempin->sin_addr),
                   sizeof(struct in_addr ));
  }
#line 142
  return (tmp___0);
}
}
#line 145 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/iodined.c"
static void send_raw___0(int fd , char *buf , int buflen , int user , int cmd , struct query *q ) 
{ 
  char packet[4096] ;
  int len ;
  struct sockaddr_in *tempin ;
  char *tmp ;

  {
#line 151
  if (sizeof(packet) - 4UL < (unsigned long )buflen) {
#line 151
    len = (int )(sizeof(packet) - 4UL);
  } else {
#line 151
    len = buflen;
  }
  {
#line 153
  memcpy((void */* __restrict  */)(packet), (void const   */* __restrict  */)(raw_header),
         (size_t )4);
  }
#line 154
  if (len) {
    {
#line 155
    memcpy((void */* __restrict  */)(& packet[4]), (void const   */* __restrict  */)buf,
           (size_t )len);
    }
  }
#line 158
  len += 4;
#line 159
  packet[3] = (char )(cmd | (user & 15));
#line 161
  if (debug >= 2) {
    {
#line 163
    tempin = (struct sockaddr_in *)(& q->from);
#line 164
    tmp = inet_ntoa(tempin->sin_addr);
#line 164
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"TX-raw: client %s, cmd %d, %d bytes\n",
            tmp, cmd, len);
    }
  }
  {
#line 168
  sendto(fd, (void const   *)(packet), (size_t )len, 0, (struct sockaddr  const  *)(& q->from),
         (socklen_t )q->fromlen);
  }
#line 169
  return;
}
}
#line 172 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/iodined.c"
static void start_new_outpacket(int userid___0 , char *data , int datalen ) 
{ 


  {
#line 177
  if ((unsigned long )datalen < sizeof(users[userid___0].outpacket.data)) {
#line 177
    datalen = datalen;
  } else {
#line 177
    datalen = (int )sizeof(users[userid___0].outpacket.data);
  }
  {
#line 178
  memcpy((void */* __restrict  */)(users[userid___0].outpacket.data), (void const   */* __restrict  */)data,
         (size_t )datalen);
#line 179
  users[userid___0].outpacket.len = datalen;
#line 180
  users[userid___0].outpacket.offset = 0;
#line 181
  users[userid___0].outpacket.sentlen = 0;
#line 182
  users[userid___0].outpacket.seqno = (char )(((int )users[userid___0].outpacket.seqno + 1) & 7);
#line 183
  users[userid___0].outpacket.fragment = (char)0;
#line 184
  users[userid___0].outfragresent = 0;
  }
#line 185
  return;
}
}
#line 189 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/iodined.c"
static int save_to_outpacketq(int userid___0 , char *data , int datalen ) 
{ 
  int fill ;

  {
#line 196
  if (users[userid___0].outpacketq_filled >= 4) {
#line 198
    return (0);
  }
#line 200
  fill = users[userid___0].outpacketq_nexttouse + users[userid___0].outpacketq_filled;
#line 202
  if (fill >= 4) {
#line 203
    fill -= 4;
  }
#line 205
  if ((unsigned long )datalen < sizeof(users[userid___0].outpacketq[fill].data)) {
#line 205
    datalen = datalen;
  } else {
#line 205
    datalen = (int )sizeof(users[userid___0].outpacketq[fill].data);
  }
  {
#line 206
  memcpy((void */* __restrict  */)(users[userid___0].outpacketq[fill].data), (void const   */* __restrict  */)data,
         (size_t )datalen);
#line 207
  users[userid___0].outpacketq[fill].len = datalen;
#line 209
  (users[userid___0].outpacketq_filled) ++;
  }
#line 211
  if (debug >= 3) {
    {
#line 212
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    Qstore, now %d\n",
            users[userid___0].outpacketq_filled);
    }
  }
#line 215
  return (1);
}
}
#line 218 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/iodined.c"
static int get_from_outpacketq(int userid___0 ) 
{ 
  int use ;

  {
#line 225
  if (users[userid___0].outpacketq_filled <= 0) {
#line 227
    return (0);
  }
  {
#line 229
  use = users[userid___0].outpacketq_nexttouse;
#line 231
  start_new_outpacket(userid___0, users[userid___0].outpacketq[use].data, users[userid___0].outpacketq[use].len);
#line 234
  use ++;
  }
#line 235
  if (use >= 4) {
#line 236
    use = 0;
  }
#line 237
  users[userid___0].outpacketq_nexttouse = use;
#line 238
  (users[userid___0].outpacketq_filled) --;
#line 240
  if (debug >= 3) {
    {
#line 241
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    Qget, now %d\n",
            users[userid___0].outpacketq_filled);
    }
  }
#line 244
  return (1);
}
}
#line 266 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/iodined.c"
static void save_to_dnscache(int userid___0 , struct query *q , char *answer , int answerlen ) 
{ 
  int fill ;

  {
#line 272
  if ((unsigned long )answerlen > sizeof(users[userid___0].dnscache_answer[fill])) {
#line 273
    return;
  }
#line 275
  fill = users[userid___0].dnscache_lastfilled + 1;
#line 276
  if (fill >= 4) {
#line 277
    fill = 0;
  }
  {
#line 279
  memcpy((void */* __restrict  */)(& users[userid___0].dnscache_q[fill]), (void const   */* __restrict  */)q,
         sizeof(struct query ));
#line 280
  memcpy((void */* __restrict  */)(users[userid___0].dnscache_answer[fill]), (void const   */* __restrict  */)answer,
         (size_t )answerlen);
#line 281
  users[userid___0].dnscache_answerlen[fill] = answerlen;
#line 283
  users[userid___0].dnscache_lastfilled = fill;
  }
#line 284
  return;
}
}
#line 286 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/iodined.c"
static int answer_from_dnscache(int dns_fd , int userid___0 , struct query *q ) 
{ 
  int i ;
  int use ;
  int tmp ;

  {
#line 295
  i = 0;
  {
#line 295
  while (1) {
    while_continue: /* CIL Label */ ;
#line 295
    if (! (i < 4)) {
#line 295
      goto while_break;
    }
#line 297
    use = users[userid___0].dnscache_lastfilled - i;
#line 298
    if (use < 0) {
#line 299
      use += 4;
    }
#line 301
    if ((int )users[userid___0].dnscache_q[use].id == 0) {
#line 302
      goto __Cont;
    }
#line 303
    if (users[userid___0].dnscache_answerlen[use] <= 0) {
#line 304
      goto __Cont;
    }
#line 306
    if ((int )users[userid___0].dnscache_q[use].type != (int )q->type) {
#line 308
      goto __Cont;
    } else {
      {
#line 306
      tmp = strcmp((char const   *)(users[userid___0].dnscache_q[use].name), (char const   *)(q->name));
      }
#line 306
      if (tmp) {
#line 308
        goto __Cont;
      }
    }
#line 311
    if (debug >= 1) {
      {
#line 312
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"OUT  user %d %s from dnscache\n",
              userid___0, q->name);
      }
    }
    {
#line 314
    write_dns(dns_fd, q, users[userid___0].dnscache_answer[use], users[userid___0].dnscache_answerlen[use],
              users[userid___0].downenc);
#line 318
    q->id = (unsigned short)0;
    }
#line 319
    return (1);
    __Cont: /* CIL Label */ 
#line 295
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 323
  return (0);
}
}
#line 328 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/iodined.c"
__inline static void save_to_qmem(unsigned char *qmem_cmc , unsigned short *qmem_type ,
                                  int qmem_len , int *qmem_lastfilled , unsigned char *cmc_to_add ,
                                  unsigned short type_to_add ) 
{ 
  int fill ;

  {
#line 336
  fill = *qmem_lastfilled + 1;
#line 337
  if (fill >= qmem_len) {
#line 338
    fill = 0;
  }
  {
#line 340
  memcpy((void */* __restrict  */)(qmem_cmc + fill * 4), (void const   */* __restrict  */)cmc_to_add,
         (size_t )4);
#line 341
  *(qmem_type + fill) = type_to_add;
#line 342
  *qmem_lastfilled = fill;
  }
#line 343
  return;
}
}
#line 345 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/iodined.c"
__inline static void save_to_qmem_pingordata(int userid___0 , struct query *q ) 
{ 
  char cmc[8] ;
  int i ;
  size_t cmcsize ;
  char *cp ;
  char *tmp ;
  size_t tmp___0 ;

  {
#line 358
  if ((int )q->name[0] == 80) {
#line 358
    goto _L;
  } else
#line 358
  if ((int )q->name[0] == 112) {
    _L: /* CIL Label */ 
    {
#line 361
    cmcsize = sizeof(cmc);
#line 362
    tmp = strchr((char const   *)(q->name), '.');
#line 362
    cp = tmp;
    }
#line 364
    if ((unsigned long )cp == (unsigned long )((void *)0)) {
#line 365
      return;
    }
    {
#line 369
    i = (*(b32___0->decode))((void *)(cmc), & cmcsize, (char const   *)(q->name + 1),
                             (size_t )((cp - q->name) - 1L));
    }
#line 371
    if (i < 4) {
#line 372
      return;
    }
    {
#line 374
    save_to_qmem(users[userid___0].qmemping_cmc, users[userid___0].qmemping_type,
                 30, & users[userid___0].qmemping_lastfilled, (unsigned char *)((void *)(cmc)),
                 q->type);
    }
  } else {
    {
#line 380
    tmp___0 = strlen((char const   *)(q->name));
    }
#line 380
    if (tmp___0 < 5UL) {
#line 381
      return;
    }
#line 388
    i = 0;
    {
#line 388
    while (1) {
      while_continue: /* CIL Label */ ;
#line 388
      if (! (i < 4)) {
#line 388
        goto while_break;
      }
#line 389
      if ((int )q->name[i + 1] >= 65) {
#line 389
        if ((int )q->name[i + 1] <= 90) {
#line 390
          cmc[i] = (char )((int )q->name[i + 1] + 32);
        } else {
#line 392
          cmc[i] = q->name[i + 1];
        }
      } else {
#line 392
        cmc[i] = q->name[i + 1];
      }
#line 388
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 394
    save_to_qmem(users[userid___0].qmemdata_cmc, users[userid___0].qmemdata_type,
                 15, & users[userid___0].qmemdata_lastfilled, (unsigned char *)((void *)(cmc)),
                 q->type);
    }
  }
#line 399
  return;
}
}
#line 401 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/iodined.c"
static int answer_from_qmem(int dns_fd , struct query *q , unsigned char *qmem_cmc ,
                            unsigned short *qmem_type , int qmem_len , unsigned char *cmc_to_check ) 
{ 
  int i ;
  int tmp ;

  {
#line 411
  i = 0;
  {
#line 411
  while (1) {
    while_continue: /* CIL Label */ ;
#line 411
    if (! (i < qmem_len)) {
#line 411
      goto while_break;
    }
#line 413
    if ((int )*(qmem_type + i) == 65432) {
#line 414
      goto __Cont;
    }
#line 415
    if ((int )*(qmem_type + i) != (int )q->type) {
#line 416
      goto __Cont;
    }
    {
#line 417
    tmp = memcmp((void const   *)(qmem_cmc + i * 4), (void const   *)cmc_to_check,
                 (size_t )4);
    }
#line 417
    if (tmp) {
#line 418
      goto __Cont;
    }
#line 421
    if (debug >= 1) {
      {
#line 422
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"OUT  from qmem for %s == duplicate, sending illegal reply\n",
              q->name);
      }
    }
    {
#line 424
    write_dns(dns_fd, q, (char *)"x", 1, (char )'T');
#line 426
    q->id = (unsigned short)0;
    }
#line 427
    return (1);
    __Cont: /* CIL Label */ 
#line 411
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 431
  return (0);
}
}
#line 434 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/iodined.c"
__inline static int answer_from_qmem_data(int dns_fd , int userid___0 , struct query *q ) 
{ 
  char cmc[4] ;
  int i ;
  int tmp ;

  {
#line 441
  i = 0;
  {
#line 441
  while (1) {
    while_continue: /* CIL Label */ ;
#line 441
    if (! (i < 4)) {
#line 441
      goto while_break;
    }
#line 442
    if ((int )q->name[i + 1] >= 65) {
#line 442
      if ((int )q->name[i + 1] <= 90) {
#line 443
        cmc[i] = (char )((int )q->name[i + 1] + 32);
      } else {
#line 445
        cmc[i] = q->name[i + 1];
      }
    } else {
#line 445
      cmc[i] = q->name[i + 1];
    }
#line 441
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 447
  tmp = answer_from_qmem(dns_fd, q, users[userid___0].qmemdata_cmc, users[userid___0].qmemdata_type,
                         15, (unsigned char *)((void *)(cmc)));
  }
#line 447
  return (tmp);
}
}
#line 452 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/iodined.c"
static int send_chunk_or_dataless(int dns_fd , int userid___0 , struct query *q ) 
{ 
  char pkt[4096] ;
  int datalen ;
  int last ;
  int tmp ;

  {
#line 465
  datalen = 0;
#line 466
  last = 0;
#line 469
  if (users[userid___0].outpacket.len > 0) {
#line 469
    if (users[userid___0].outfragresent > 5) {
      {
#line 471
      users[userid___0].outpacket.len = 0;
#line 472
      users[userid___0].outpacket.offset = 0;
#line 473
      users[userid___0].outpacket.sentlen = 0;
#line 474
      users[userid___0].outfragresent = 0;
#line 478
      get_from_outpacketq(userid___0);
      }
    }
  }
#line 482
  if (users[userid___0].outpacket.len > 0) {
#line 483
    if (users[userid___0].fragsize < users[userid___0].outpacket.len - users[userid___0].outpacket.offset) {
#line 483
      datalen = users[userid___0].fragsize;
    } else {
#line 483
      datalen = users[userid___0].outpacket.len - users[userid___0].outpacket.offset;
    }
#line 484
    if ((unsigned long )datalen < sizeof(pkt) - 2UL) {
#line 484
      datalen = datalen;
    } else {
#line 484
      datalen = (int )(sizeof(pkt) - 2UL);
    }
    {
#line 486
    memcpy((void */* __restrict  */)(& pkt[2]), (void const   */* __restrict  */)(users[userid___0].outpacket.data + users[userid___0].outpacket.offset),
           (size_t )datalen);
#line 487
    users[userid___0].outpacket.sentlen = datalen;
#line 488
    last = users[userid___0].outpacket.len == users[userid___0].outpacket.offset + datalen;
#line 490
    (users[userid___0].outfragresent) ++;
    }
  }
#line 496
  pkt[0] = (char )(((1 << 7) | (((int )users[userid___0].inpacket.seqno & 7) << 4)) | ((int )users[userid___0].inpacket.fragment & 15));
#line 499
  pkt[1] = (char )(((((int )users[userid___0].outpacket.seqno & 7) << 5) | (((int )users[userid___0].outpacket.fragment & 15) << 1)) | (last & 1));
#line 502
  if (debug >= 1) {
    {
#line 503
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"OUT  pkt seq# %d, frag %d (last=%d), offset %d, fragsize %d, total %d, to user %d\n",
            (int )users[userid___0].outpacket.seqno & 7, (int )users[userid___0].outpacket.fragment & 15,
            last, users[userid___0].outpacket.offset, datalen, users[userid___0].outpacket.len,
            userid___0);
    }
  }
  {
#line 507
  write_dns(dns_fd, q, pkt, datalen + 2, users[userid___0].downenc);
  }
#line 509
  if ((int )q->id2 != 0) {
    {
#line 510
    q->id = q->id2;
#line 511
    q->fromlen = q->fromlen2;
#line 512
    memcpy((void */* __restrict  */)(& q->from), (void const   */* __restrict  */)(& q->from2),
           (size_t )q->fromlen2);
    }
#line 513
    if (debug >= 1) {
      {
#line 514
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"OUT  again to last duplicate\n");
      }
    }
    {
#line 515
    write_dns(dns_fd, q, pkt, datalen + 2, users[userid___0].downenc);
    }
  }
  {
#line 518
  save_to_qmem_pingordata(userid___0, q);
#line 521
  save_to_dnscache(userid___0, q, pkt, datalen + 2);
#line 524
  q->id = (unsigned short)0;
  }
#line 526
  if (datalen > 0) {
#line 526
    if (datalen == users[userid___0].outpacket.len) {
      {
#line 528
      users[userid___0].outpacket.len = 0;
#line 529
      users[userid___0].outpacket.offset = 0;
#line 530
      users[userid___0].outpacket.sentlen = 0;
#line 531
      users[userid___0].outfragresent = 0;
#line 535
      tmp = get_from_outpacketq(userid___0);
      }
#line 535
      if (tmp == 1) {
#line 536
        if (debug >= 3) {
          {
#line 537
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    Chunk & fromqueue: callagain\n");
          }
        }
#line 538
        return (1);
      }
    }
  }
#line 543
  return (0);
}
}
#line 546 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/iodined.c"
static int tunnel_tun___0(int tun_fd , int dns_fd ) 
{ 
  unsigned long outlen ;
  struct ip *header ;
  char out[65536] ;
  char in[65536] ;
  int userid___0 ;
  int read___0 ;
  ssize_t tmp ;

  {
  {
#line 556
  tmp = read_tun(tun_fd, in, sizeof(in));
#line 556
  read___0 = (int )tmp;
  }
#line 556
  if (read___0 <= 0) {
#line 557
    return (0);
  }
  {
#line 560
  header = (struct ip *)(in + 4);
#line 561
  userid___0 = find_user_by_ip(header->ip_dst.s_addr);
  }
#line 562
  if (userid___0 < 0) {
#line 563
    return (0);
  }
  {
#line 565
  outlen = sizeof(out);
#line 566
  compress2((uint8_t *)(out), & outlen, (Bytef const   *)((uint8_t *)(in)), (uLong )read___0,
            9);
  }
#line 568
  if ((unsigned int )users[userid___0].conn == 1U) {
#line 573
    if (users[userid___0].outpacket.len > 0) {
      {
#line 574
      save_to_outpacketq(userid___0, out, (int )outlen);
      }
#line 575
      return (0);
    }
    {
#line 579
    start_new_outpacket(userid___0, out, (int )outlen);
    }
#line 582
    if ((int )users[userid___0].q_sendrealsoon.id != 0) {
      {
#line 583
      send_chunk_or_dataless(dns_fd, userid___0, & users[userid___0].q_sendrealsoon);
      }
    } else
#line 584
    if ((int )users[userid___0].q.id != 0) {
      {
#line 585
      send_chunk_or_dataless(dns_fd, userid___0, & users[userid___0].q);
      }
    }
#line 587
    return ((int )outlen);
  } else {
    {
#line 589
    send_raw___0(dns_fd, out, (int )outlen, userid___0, 32, & users[userid___0].q);
    }
#line 590
    return ((int )outlen);
  }
}
}
#line 600 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/iodined.c"
static void send_version_response(int fd , version_ack_t ack , uint32_t payload ,
                                  int userid___0 , struct query *q ) 
{ 
  char out[9] ;

  {
  {
#line 606
  if ((unsigned int )ack == 0U) {
#line 606
    goto case_0;
  }
#line 609
  if ((unsigned int )ack == 1U) {
#line 609
    goto case_1;
  }
#line 612
  if ((unsigned int )ack == 2U) {
#line 612
    goto case_2;
  }
#line 605
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 607
  strncpy((char */* __restrict  */)(out), (char const   */* __restrict  */)"VACK",
          sizeof(out));
  }
#line 608
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 610
  strncpy((char */* __restrict  */)(out), (char const   */* __restrict  */)"VNAK",
          sizeof(out));
  }
#line 611
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 613
  strncpy((char */* __restrict  */)(out), (char const   */* __restrict  */)"VFUL",
          sizeof(out));
  }
#line 614
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 617
  out[4] = (char )((payload >> 24) & 255U);
#line 618
  out[5] = (char )((payload >> 16) & 255U);
#line 619
  out[6] = (char )((payload >> 8) & 255U);
#line 620
  out[7] = (char )(payload & 255U);
#line 621
  out[8] = (char )(userid___0 & 255);
#line 623
  write_dns(fd, q, out, (int )sizeof(out), users[userid___0].downenc);
  }
#line 624
  return;
}
}
#line 626 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/iodined.c"
static void process_downstream_ack(int userid___0 , int down_seq , int down_frag ) 
{ 


  {
#line 633
  if (users[userid___0].outpacket.len <= 0) {
#line 635
    return;
  }
#line 637
  if ((int )users[userid___0].outpacket.seqno != down_seq) {
#line 641
    return;
  } else
#line 637
  if ((int )users[userid___0].outpacket.fragment != down_frag) {
#line 641
    return;
  }
#line 644
  users[userid___0].outpacket.offset += users[userid___0].outpacket.sentlen;
#line 645
  users[userid___0].outpacket.sentlen = 0;
#line 646
  users[userid___0].outpacket.fragment = (char )((int )users[userid___0].outpacket.fragment + 1);
#line 647
  users[userid___0].outfragresent = 0;
#line 650
  if (users[userid___0].outpacket.offset >= users[userid___0].outpacket.len) {
    {
#line 651
    users[userid___0].outpacket.len = 0;
#line 652
    users[userid___0].outpacket.offset = 0;
#line 653
    users[userid___0].outpacket.fragment = (char )((int )users[userid___0].outpacket.fragment - 1);
#line 659
    get_from_outpacketq(userid___0);
    }
  }
#line 662
  return;
}
}
#line 664 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/iodined.c"
static void handle_null_request(int tun_fd , int dns_fd , struct query *q , int domain_len ) 
{ 
  struct in_addr tempip ;
  char in[512] ;
  char logindata[16] ;
  char out[65536] ;
  char unpacked[65536] ;
  char *tmp[2] ;
  int userid___0 ;
  int read___0 ;
  unsigned long tmp___0 ;
  int version___1 ;
  int i ;
  struct sockaddr_in *tempin ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  in_addr_t replyaddr ;
  unsigned int addr___0 ;
  char reply[5] ;
  int tmp___10 ;
  int codec ;
  struct encoder *enc ;
  int tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  int tmp___16 ;
  int i___0 ;
  char *datap ;
  int datalen ;
  int req_frag_size ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  char buf[2048] ;
  int i___1 ;
  unsigned int v ;
  int tmp___22 ;
  int max_frag_size ;
  int tmp___23 ;
  int dn_seq ;
  int dn_frag ;
  int didsend ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int up_seq ;
  int up_frag ;
  int dn_seq___0 ;
  int dn_frag___0 ;
  int lastfrag ;
  int upstream_ok ;
  int didsend___0 ;
  int code ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;

  {
#line 676
  userid___0 = -1;
#line 679
  if (domain_len < 2) {
#line 680
    return;
  }
#line 682
  if ((unsigned long )domain_len < sizeof(in)) {
#line 682
    tmp___0 = (unsigned long )domain_len;
  } else {
#line 682
    tmp___0 = sizeof(in);
  }
  {
#line 682
  memcpy((void */* __restrict  */)(in), (void const   */* __restrict  */)(q->name),
         tmp___0);
  }
#line 684
  if ((int )in[0] == 86) {
#line 684
    goto _L___20;
  } else
#line 684
  if ((int )in[0] == 118) {
    _L___20: /* CIL Label */ 
    {
#line 685
    version___1 = 0;
#line 687
    read___0 = unpack_data(unpacked, sizeof(unpacked), & in[1], (size_t )(domain_len - 1),
                           b32___0);
    }
#line 689
    if (read___0 > 4) {
#line 691
      version___1 = (((((int )unpacked[0] & 255) << 24) | (((int )unpacked[1] & 255) << 16)) | (((int )unpacked[2] & 255) << 8)) | ((int )unpacked[3] & 255);
    }
#line 697
    if (version___1 == 1282) {
      {
#line 698
      userid___0 = find_available_user();
      }
#line 699
      if (userid___0 >= 0) {
        {
#line 703
        users[userid___0].seed = rand();
#line 705
        tempin = (struct sockaddr_in *)(& q->from);
#line 706
        memcpy((void */* __restrict  */)(& users[userid___0].host), (void const   */* __restrict  */)(& tempin->sin_addr),
               sizeof(struct in_addr ));
#line 708
        memcpy((void */* __restrict  */)(& users[userid___0].q), (void const   */* __restrict  */)q,
               sizeof(struct query ));
#line 709
        users[userid___0].encoder = get_base32_encoder();
#line 710
        users[userid___0].downenc = (char )'T';
#line 711
        send_version_response(dns_fd, (version_ack_t )0, (uint32_t )users[userid___0].seed,
                              userid___0, q);
#line 712
        tmp___1 = inet_ntoa(tempin->sin_addr);
#line 712
        syslog(6, "accepted version for user #%d from %s", userid___0, tmp___1);
#line 714
        users[userid___0].q.id = (unsigned short)0;
#line 715
        users[userid___0].q.id2 = (unsigned short)0;
#line 716
        users[userid___0].q_sendrealsoon.id = (unsigned short)0;
#line 717
        users[userid___0].q_sendrealsoon.id2 = (unsigned short)0;
#line 718
        users[userid___0].q_sendrealsoon_new = 0;
#line 719
        users[userid___0].outpacket.len = 0;
#line 720
        users[userid___0].outpacket.offset = 0;
#line 721
        users[userid___0].outpacket.sentlen = 0;
#line 722
        users[userid___0].outpacket.seqno = (char)0;
#line 723
        users[userid___0].outpacket.fragment = (char)0;
#line 724
        users[userid___0].outfragresent = 0;
#line 725
        users[userid___0].inpacket.len = 0;
#line 726
        users[userid___0].inpacket.offset = 0;
#line 727
        users[userid___0].inpacket.seqno = (char)0;
#line 728
        users[userid___0].inpacket.fragment = (char)0;
#line 729
        users[userid___0].fragsize = 100;
#line 730
        users[userid___0].conn = (enum connection )1;
#line 731
        users[userid___0].lazy = 0;
#line 733
        users[userid___0].outpacketq_nexttouse = 0;
#line 734
        users[userid___0].outpacketq_filled = 0;
#line 738
        i = 0;
        }
        {
#line 738
        while (1) {
          while_continue: /* CIL Label */ ;
#line 738
          if (! (i < 4)) {
#line 738
            goto while_break;
          }
#line 739
          users[userid___0].dnscache_q[i].id = (unsigned short)0;
#line 740
          users[userid___0].dnscache_answerlen[i] = 0;
#line 738
          i ++;
        }
        while_break: /* CIL Label */ ;
        }
#line 743
        users[userid___0].dnscache_lastfilled = 0;
#line 745
        i = 0;
        {
#line 745
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 745
          if (! (i < 30)) {
#line 745
            goto while_break___0;
          }
#line 746
          users[userid___0].qmemping_type[i] = (unsigned short)65432;
#line 745
          i ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 747
        users[userid___0].qmemping_lastfilled = 0;
#line 748
        i = 0;
        {
#line 748
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 748
          if (! (i < 15)) {
#line 748
            goto while_break___1;
          }
#line 749
          users[userid___0].qmemdata_type[i] = (unsigned short)65432;
#line 748
          i ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 750
        users[userid___0].qmemdata_lastfilled = 0;
      } else {
        {
#line 753
        send_version_response(dns_fd, (version_ack_t )2, (uint32_t )created_users,
                              0, q);
#line 754
        tmp___2 = inet_ntoa(((struct sockaddr_in *)(& q->from))->sin_addr);
#line 754
        syslog(6, "dropped user from %s, server full", tmp___2);
        }
      }
    } else {
      {
#line 758
      send_version_response(dns_fd, (version_ack_t )1, (uint32_t )1282, 0, q);
#line 759
      tmp___3 = inet_ntoa(((struct sockaddr_in *)(& q->from))->sin_addr);
#line 759
      syslog(6, "dropped user from %s, sent bad version %08X", tmp___3, version___1);
      }
    }
#line 762
    return;
  } else
#line 763
  if ((int )in[0] == 76) {
#line 763
    goto _L___19;
  } else
#line 763
  if ((int )in[0] == 108) {
    _L___19: /* CIL Label */ 
    {
#line 764
    read___0 = unpack_data(unpacked, sizeof(unpacked), & in[1], (size_t )(domain_len - 1),
                           b32___0);
    }
#line 765
    if (read___0 < 17) {
      {
#line 766
      write_dns(dns_fd, q, (char *)"BADLEN", 6, (char )'T');
      }
#line 767
      return;
    }
    {
#line 771
    userid___0 = (int )unpacked[0];
#line 773
    tmp___9 = check_user_and_ip(userid___0, q);
    }
#line 773
    if (tmp___9 != 0) {
      {
#line 774
      write_dns(dns_fd, q, (char *)"BADIP", 5, (char )'T');
#line 775
      tmp___4 = inet_ntoa(((struct sockaddr_in *)(& q->from))->sin_addr);
#line 775
      syslog(4, "dropped login request from user #%d from unexpected source %s", userid___0,
             tmp___4);
      }
#line 777
      return;
    } else {
      {
#line 779
      users[userid___0].last_pkt = time((time_t *)((void *)0));
#line 780
      login_calculate(logindata, 16, (char const   *)(password___0), users[userid___0].seed);
      }
#line 782
      if (read___0 >= 18) {
        {
#line 782
        tmp___8 = memcmp((void const   *)(logindata), (void const   *)(unpacked + 1),
                         (size_t )16);
        }
#line 782
        if (tmp___8 == 0) {
          {
#line 785
          tempip.s_addr = my_ip;
#line 786
          tmp___5 = inet_ntoa(tempip);
#line 786
          tmp[0] = strdup((char const   *)tmp___5);
#line 787
          tempip.s_addr = users[userid___0].tun_ip;
#line 788
          tmp___6 = inet_ntoa(tempip);
#line 788
          tmp[1] = strdup((char const   *)tmp___6);
#line 790
          read___0 = snprintf((char */* __restrict  */)(out), sizeof(out), (char const   */* __restrict  */)"%s-%s-%d-%d",
                              tmp[0], tmp[1], my_mtu, netmask);
#line 793
          write_dns(dns_fd, q, out, read___0, users[userid___0].downenc);
#line 794
          q->id = (unsigned short)0;
#line 795
          syslog(5, "accepted password from user #%d, given IP %s", userid___0, tmp[1]);
#line 797
          free((void *)tmp[1]);
#line 798
          free((void *)tmp[0]);
          }
        } else {
          {
#line 800
          write_dns(dns_fd, q, (char *)"LNAK", 4, (char )'T');
#line 801
          tmp___7 = inet_ntoa(((struct sockaddr_in *)(& q->from))->sin_addr);
#line 801
          syslog(4, "rejected login request from user #%d from %s, bad password",
                 userid___0, tmp___7);
          }
        }
      } else {
        {
#line 800
        write_dns(dns_fd, q, (char *)"LNAK", 4, (char )'T');
#line 801
        tmp___7 = inet_ntoa(((struct sockaddr_in *)(& q->from))->sin_addr);
#line 801
        syslog(4, "rejected login request from user #%d from %s, bad password", userid___0,
               tmp___7);
        }
      }
    }
#line 805
    return;
  } else
#line 806
  if ((int )in[0] == 73) {
#line 806
    goto _L___18;
  } else
#line 806
  if ((int )in[0] == 105) {
    _L___18: /* CIL Label */ 
    {
#line 812
    userid___0 = b32_8to5((int )in[1]);
#line 813
    tmp___10 = check_user_and_ip(userid___0, q);
    }
#line 813
    if (tmp___10 != 0) {
      {
#line 814
      write_dns(dns_fd, q, (char *)"BADIP", 5, (char )'T');
      }
#line 815
      return;
    }
#line 818
    if (ns_ip != 0U) {
#line 820
      replyaddr = ns_ip;
    } else {
      {
#line 823
      memcpy((void */* __restrict  */)(& replyaddr), (void const   */* __restrict  */)(& q->destination.s_addr),
             sizeof(in_addr_t ));
      }
    }
    {
#line 826
    addr___0 = htonl(replyaddr);
#line 827
    reply[0] = (char )'I';
#line 828
    reply[1] = (char )((addr___0 >> 24) & 255U);
#line 829
    reply[2] = (char )((addr___0 >> 16) & 255U);
#line 830
    reply[3] = (char )((addr___0 >> 8) & 255U);
#line 831
    reply[4] = (char )(addr___0 & 255U);
#line 832
    write_dns(dns_fd, q, reply, (int )sizeof(reply), (char )'T');
    }
  } else
#line 833
  if ((int )in[0] == 90) {
    {
#line 838
    write_dns(dns_fd, q, in, domain_len, (char )'T');
    }
#line 839
    return;
  } else
#line 833
  if ((int )in[0] == 122) {
    {
#line 838
    write_dns(dns_fd, q, in, domain_len, (char )'T');
    }
#line 839
    return;
  } else
#line 840
  if ((int )in[0] == 83) {
#line 840
    goto _L___17;
  } else
#line 840
  if ((int )in[0] == 115) {
    _L___17: /* CIL Label */ 
#line 843
    if (domain_len < 3) {
      {
#line 844
      write_dns(dns_fd, q, (char *)"BADLEN", 6, (char )'T');
      }
#line 845
      return;
    }
    {
#line 848
    userid___0 = b32_8to5((int )in[1]);
#line 850
    tmp___11 = check_user_and_ip(userid___0, q);
    }
#line 850
    if (tmp___11 != 0) {
      {
#line 851
      write_dns(dns_fd, q, (char *)"BADIP", 5, (char )'T');
      }
#line 852
      return;
    }
    {
#line 855
    codec = b32_8to5((int )in[2]);
    }
    {
#line 858
    if (codec == 5) {
#line 858
      goto case_5;
    }
#line 863
    if (codec == 6) {
#line 863
      goto case_6;
    }
#line 868
    if (codec == 26) {
#line 868
      goto case_26;
    }
#line 873
    if (codec == 7) {
#line 873
      goto case_7;
    }
#line 878
    goto switch_default;
    case_5: /* CIL Label */ 
    {
#line 859
    enc = get_base32_encoder();
#line 860
    user_switch_codec(userid___0, enc);
#line 861
    tmp___12 = strlen((char const   *)(enc->name));
#line 861
    write_dns(dns_fd, q, enc->name, (int )tmp___12, users[userid___0].downenc);
    }
#line 862
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 864
    enc = get_base64_encoder();
#line 865
    user_switch_codec(userid___0, enc);
#line 866
    tmp___13 = strlen((char const   *)(enc->name));
#line 866
    write_dns(dns_fd, q, enc->name, (int )tmp___13, users[userid___0].downenc);
    }
#line 867
    goto switch_break;
    case_26: /* CIL Label */ 
    {
#line 869
    enc = get_base64u_encoder();
#line 870
    user_switch_codec(userid___0, enc);
#line 871
    tmp___14 = strlen((char const   *)(enc->name));
#line 871
    write_dns(dns_fd, q, enc->name, (int )tmp___14, users[userid___0].downenc);
    }
#line 872
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 874
    enc = get_base128_encoder();
#line 875
    user_switch_codec(userid___0, enc);
#line 876
    tmp___15 = strlen((char const   *)(enc->name));
#line 876
    write_dns(dns_fd, q, enc->name, (int )tmp___15, users[userid___0].downenc);
    }
#line 877
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 879
    write_dns(dns_fd, q, (char *)"BADCODEC", 8, users[userid___0].downenc);
    }
#line 880
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 882
    return;
  } else
#line 883
  if ((int )in[0] == 79) {
#line 883
    goto _L___16;
  } else
#line 883
  if ((int )in[0] == 111) {
    _L___16: /* CIL Label */ 
#line 884
    if (domain_len < 3) {
      {
#line 885
      write_dns(dns_fd, q, (char *)"BADLEN", 6, (char )'T');
      }
#line 886
      return;
    }
    {
#line 889
    userid___0 = b32_8to5((int )in[1]);
#line 891
    tmp___16 = check_user_and_ip(userid___0, q);
    }
#line 891
    if (tmp___16 != 0) {
      {
#line 892
      write_dns(dns_fd, q, (char *)"BADIP", 5, (char )'T');
      }
#line 893
      return;
    }
    {
#line 898
    if ((int )in[2] == 116) {
#line 898
      goto case_116;
    }
#line 898
    if ((int )in[2] == 84) {
#line 898
      goto case_116;
    }
#line 903
    if ((int )in[2] == 115) {
#line 903
      goto case_115;
    }
#line 903
    if ((int )in[2] == 83) {
#line 903
      goto case_115;
    }
#line 908
    if ((int )in[2] == 117) {
#line 908
      goto case_117;
    }
#line 908
    if ((int )in[2] == 85) {
#line 908
      goto case_117;
    }
#line 913
    if ((int )in[2] == 118) {
#line 913
      goto case_118;
    }
#line 913
    if ((int )in[2] == 86) {
#line 913
      goto case_118;
    }
#line 918
    if ((int )in[2] == 114) {
#line 918
      goto case_114;
    }
#line 918
    if ((int )in[2] == 82) {
#line 918
      goto case_114;
    }
#line 923
    if ((int )in[2] == 108) {
#line 923
      goto case_108;
    }
#line 923
    if ((int )in[2] == 76) {
#line 923
      goto case_108;
    }
#line 928
    if ((int )in[2] == 105) {
#line 928
      goto case_105;
    }
#line 928
    if ((int )in[2] == 73) {
#line 928
      goto case_105;
    }
#line 932
    goto switch_default___0;
    case_116: /* CIL Label */ 
    case_84: /* CIL Label */ 
    {
#line 899
    users[userid___0].downenc = (char )'T';
#line 900
    write_dns(dns_fd, q, (char *)"Base32", 6, users[userid___0].downenc);
    }
#line 901
    goto switch_break___0;
    case_115: /* CIL Label */ 
    case_83: /* CIL Label */ 
    {
#line 904
    users[userid___0].downenc = (char )'S';
#line 905
    write_dns(dns_fd, q, (char *)"Base64", 6, users[userid___0].downenc);
    }
#line 906
    goto switch_break___0;
    case_117: /* CIL Label */ 
    case_85: /* CIL Label */ 
    {
#line 909
    users[userid___0].downenc = (char )'U';
#line 910
    write_dns(dns_fd, q, (char *)"Base64u", 7, users[userid___0].downenc);
    }
#line 911
    goto switch_break___0;
    case_118: /* CIL Label */ 
    case_86: /* CIL Label */ 
    {
#line 914
    users[userid___0].downenc = (char )'V';
#line 915
    write_dns(dns_fd, q, (char *)"Base128", 7, users[userid___0].downenc);
    }
#line 916
    goto switch_break___0;
    case_114: /* CIL Label */ 
    case_82: /* CIL Label */ 
    {
#line 919
    users[userid___0].downenc = (char )'R';
#line 920
    write_dns(dns_fd, q, (char *)"Raw", 3, users[userid___0].downenc);
    }
#line 921
    goto switch_break___0;
    case_108: /* CIL Label */ 
    case_76: /* CIL Label */ 
    {
#line 924
    users[userid___0].lazy = 1;
#line 925
    write_dns(dns_fd, q, (char *)"Lazy", 4, users[userid___0].downenc);
    }
#line 926
    goto switch_break___0;
    case_105: /* CIL Label */ 
    case_73: /* CIL Label */ 
    {
#line 929
    users[userid___0].lazy = 0;
#line 930
    write_dns(dns_fd, q, (char *)"Immediate", 9, users[userid___0].downenc);
    }
#line 931
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 933
    write_dns(dns_fd, q, (char *)"BADCODEC", 8, users[userid___0].downenc);
    }
#line 934
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 936
    return;
  } else
#line 937
  if ((int )in[0] == 89) {
#line 937
    goto _L___15;
  } else
#line 937
  if ((int )in[0] == 121) {
    _L___15: /* CIL Label */ 
#line 942
    if (domain_len < 6) {
      {
#line 943
      write_dns(dns_fd, q, (char *)"BADLEN", 6, (char )'T');
      }
#line 944
      return;
    }
    {
#line 947
    i___0 = b32_8to5((int )in[2]);
    }
    {
#line 950
    if (i___0 == 1) {
#line 950
      goto case_1;
    }
#line 954
    goto switch_default___1;
    case_1: /* CIL Label */ 
#line 951
    datap = (char *)"\000\000\000\000\377\377\377\377UUUU\252\252\252\252\201c\310\322\307|\262\027_O\316\311I-R!a\251q %\263\006s\346\330D0yPW\277";
#line 952
    datalen = 48;
#line 953
    goto switch_break___1;
    switch_default___1: /* CIL Label */ 
    {
#line 955
    write_dns(dns_fd, q, (char *)"BADLEN", 6, (char )'T');
    }
#line 956
    return;
    switch_break___1: /* CIL Label */ ;
    }
    {
#line 961
    if ((int )in[1] == 116) {
#line 961
      goto case_116___0;
    }
#line 961
    if ((int )in[1] == 84) {
#line 961
      goto case_116___0;
    }
#line 970
    if ((int )in[1] == 115) {
#line 970
      goto case_115___0;
    }
#line 970
    if ((int )in[1] == 83) {
#line 970
      goto case_115___0;
    }
#line 979
    if ((int )in[1] == 117) {
#line 979
      goto case_117___0;
    }
#line 979
    if ((int )in[1] == 85) {
#line 979
      goto case_117___0;
    }
#line 988
    if ((int )in[1] == 118) {
#line 988
      goto case_118___0;
    }
#line 988
    if ((int )in[1] == 86) {
#line 988
      goto case_118___0;
    }
#line 997
    if ((int )in[1] == 114) {
#line 997
      goto case_114___0;
    }
#line 997
    if ((int )in[1] == 82) {
#line 997
      goto case_114___0;
    }
#line 959
    goto switch_break___2;
    case_116___0: /* CIL Label */ 
    case_84___0: /* CIL Label */ 
#line 962
    if ((int )q->type == 16) {
      {
#line 965
      write_dns(dns_fd, q, datap, datalen, (char )'T');
      }
#line 966
      return;
    } else
#line 962
    if ((int )q->type == 33) {
      {
#line 965
      write_dns(dns_fd, q, datap, datalen, (char )'T');
      }
#line 966
      return;
    } else
#line 962
    if ((int )q->type == 15) {
      {
#line 965
      write_dns(dns_fd, q, datap, datalen, (char )'T');
      }
#line 966
      return;
    } else
#line 962
    if ((int )q->type == 5) {
      {
#line 965
      write_dns(dns_fd, q, datap, datalen, (char )'T');
      }
#line 966
      return;
    } else
#line 962
    if ((int )q->type == 1) {
      {
#line 965
      write_dns(dns_fd, q, datap, datalen, (char )'T');
      }
#line 966
      return;
    }
#line 968
    goto switch_break___2;
    case_115___0: /* CIL Label */ 
    case_83___0: /* CIL Label */ 
#line 971
    if ((int )q->type == 16) {
      {
#line 974
      write_dns(dns_fd, q, datap, datalen, (char )'S');
      }
#line 975
      return;
    } else
#line 971
    if ((int )q->type == 33) {
      {
#line 974
      write_dns(dns_fd, q, datap, datalen, (char )'S');
      }
#line 975
      return;
    } else
#line 971
    if ((int )q->type == 15) {
      {
#line 974
      write_dns(dns_fd, q, datap, datalen, (char )'S');
      }
#line 975
      return;
    } else
#line 971
    if ((int )q->type == 5) {
      {
#line 974
      write_dns(dns_fd, q, datap, datalen, (char )'S');
      }
#line 975
      return;
    } else
#line 971
    if ((int )q->type == 1) {
      {
#line 974
      write_dns(dns_fd, q, datap, datalen, (char )'S');
      }
#line 975
      return;
    }
#line 977
    goto switch_break___2;
    case_117___0: /* CIL Label */ 
    case_85___0: /* CIL Label */ 
#line 980
    if ((int )q->type == 16) {
      {
#line 983
      write_dns(dns_fd, q, datap, datalen, (char )'U');
      }
#line 984
      return;
    } else
#line 980
    if ((int )q->type == 33) {
      {
#line 983
      write_dns(dns_fd, q, datap, datalen, (char )'U');
      }
#line 984
      return;
    } else
#line 980
    if ((int )q->type == 15) {
      {
#line 983
      write_dns(dns_fd, q, datap, datalen, (char )'U');
      }
#line 984
      return;
    } else
#line 980
    if ((int )q->type == 5) {
      {
#line 983
      write_dns(dns_fd, q, datap, datalen, (char )'U');
      }
#line 984
      return;
    } else
#line 980
    if ((int )q->type == 1) {
      {
#line 983
      write_dns(dns_fd, q, datap, datalen, (char )'U');
      }
#line 984
      return;
    }
#line 986
    goto switch_break___2;
    case_118___0: /* CIL Label */ 
    case_86___0: /* CIL Label */ 
#line 989
    if ((int )q->type == 16) {
      {
#line 992
      write_dns(dns_fd, q, datap, datalen, (char )'V');
      }
#line 993
      return;
    } else
#line 989
    if ((int )q->type == 33) {
      {
#line 992
      write_dns(dns_fd, q, datap, datalen, (char )'V');
      }
#line 993
      return;
    } else
#line 989
    if ((int )q->type == 15) {
      {
#line 992
      write_dns(dns_fd, q, datap, datalen, (char )'V');
      }
#line 993
      return;
    } else
#line 989
    if ((int )q->type == 5) {
      {
#line 992
      write_dns(dns_fd, q, datap, datalen, (char )'V');
      }
#line 993
      return;
    } else
#line 989
    if ((int )q->type == 1) {
      {
#line 992
      write_dns(dns_fd, q, datap, datalen, (char )'V');
      }
#line 993
      return;
    }
#line 995
    goto switch_break___2;
    case_114___0: /* CIL Label */ 
    case_82___0: /* CIL Label */ 
#line 998
    if ((int )q->type == 10) {
      {
#line 999
      write_dns(dns_fd, q, datap, datalen, (char )'R');
      }
#line 1000
      return;
    } else
#line 998
    if ((int )q->type == 16) {
      {
#line 999
      write_dns(dns_fd, q, datap, datalen, (char )'R');
      }
#line 1000
      return;
    }
#line 1002
    goto switch_break___2;
    switch_break___2: /* CIL Label */ ;
    }
    {
#line 1006
    write_dns(dns_fd, q, (char *)"BADCODEC", 8, (char )'T');
    }
#line 1007
    return;
  } else
#line 1009
  if ((int )in[0] == 82) {
#line 1009
    goto _L___14;
  } else
#line 1009
  if ((int )in[0] == 114) {
    _L___14: /* CIL Label */ 
#line 1012
    if (domain_len < 16) {
      {
#line 1013
      write_dns(dns_fd, q, (char *)"BADLEN", 6, (char )'T');
      }
#line 1014
      return;
    }
    {
#line 1018
    tmp___17 = b32_8to5((int )in[1]);
#line 1018
    userid___0 = (tmp___17 >> 1) & 15;
#line 1019
    tmp___18 = check_user_and_ip(userid___0, q);
    }
#line 1019
    if (tmp___18 != 0) {
      {
#line 1020
      write_dns(dns_fd, q, (char *)"BADIP", 5, (char )'T');
      }
#line 1021
      return;
    }
    {
#line 1024
    tmp___19 = b32_8to5((int )in[1]);
#line 1024
    tmp___20 = b32_8to5((int )in[2]);
#line 1024
    tmp___21 = b32_8to5((int )in[3]);
#line 1024
    req_frag_size = (((tmp___19 & 1) << 10) | ((tmp___20 & 31) << 5)) | (tmp___21 & 31);
    }
#line 1025
    if (req_frag_size < 2) {
      {
#line 1026
      write_dns(dns_fd, q, (char *)"BADFRAG", 7, users[userid___0].downenc);
      }
    } else
#line 1025
    if (req_frag_size > 2047) {
      {
#line 1026
      write_dns(dns_fd, q, (char *)"BADFRAG", 7, users[userid___0].downenc);
      }
    } else {
      {
#line 1030
      tmp___22 = rand();
#line 1030
      v = (unsigned int )tmp___22 & 255U;
#line 1032
      memset((void *)(buf), 0, sizeof(buf));
#line 1033
      buf[0] = (char )((req_frag_size >> 8) & 255);
#line 1034
      buf[1] = (char )(req_frag_size & 255);
#line 1036
      buf[2] = (char)107;
#line 1037
      i___1 = 3;
      }
      {
#line 1037
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1037
        if (! (i___1 < 2048)) {
#line 1037
          goto while_break___2;
        }
#line 1038
        buf[i___1] = (char )v;
#line 1037
        i___1 ++;
#line 1037
        v = (v + 107U) & 255U;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 1039
      write_dns(dns_fd, q, buf, req_frag_size, users[userid___0].downenc);
      }
    }
#line 1041
    return;
  } else
#line 1042
  if ((int )in[0] == 78) {
#line 1042
    goto _L___13;
  } else
#line 1042
  if ((int )in[0] == 110) {
    _L___13: /* CIL Label */ 
    {
#line 1045
    read___0 = unpack_data(unpacked, sizeof(unpacked), & in[1], (size_t )(domain_len - 1),
                           b32___0);
    }
#line 1047
    if (read___0 < 3) {
      {
#line 1048
      write_dns(dns_fd, q, (char *)"BADLEN", 6, (char )'T');
      }
#line 1049
      return;
    }
    {
#line 1053
    userid___0 = (int )unpacked[0];
#line 1054
    tmp___23 = check_user_and_ip(userid___0, q);
    }
#line 1054
    if (tmp___23 != 0) {
      {
#line 1055
      write_dns(dns_fd, q, (char *)"BADIP", 5, (char )'T');
      }
#line 1056
      return;
    }
#line 1059
    max_frag_size = (((int )unpacked[1] & 255) << 8) | ((int )unpacked[2] & 255);
#line 1060
    if (max_frag_size < 2) {
      {
#line 1061
      write_dns(dns_fd, q, (char *)"BADFRAG", 7, users[userid___0].downenc);
      }
    } else {
      {
#line 1063
      users[userid___0].fragsize = max_frag_size;
#line 1064
      write_dns(dns_fd, q, & unpacked[1], 2, users[userid___0].downenc);
      }
    }
#line 1066
    return;
  } else
#line 1067
  if ((int )in[0] == 80) {
#line 1067
    goto _L___12;
  } else
#line 1067
  if ((int )in[0] == 112) {
    _L___12: /* CIL Label */ 
#line 1070
    didsend = 0;
#line 1078
    if ((int )q->id == 0) {
#line 1079
      return;
    }
    {
#line 1081
    read___0 = unpack_data(unpacked, sizeof(unpacked), & in[1], (size_t )(domain_len - 1),
                           b32___0);
    }
#line 1082
    if (read___0 < 4) {
#line 1083
      return;
    }
    {
#line 1086
    userid___0 = (int )unpacked[0];
#line 1087
    tmp___24 = check_user_and_ip(userid___0, q);
    }
#line 1087
    if (tmp___24 != 0) {
      {
#line 1088
      write_dns(dns_fd, q, (char *)"BADIP", 5, (char )'T');
      }
#line 1089
      return;
    }
    {
#line 1094
    tmp___25 = answer_from_dnscache(dns_fd, userid___0, q);
    }
#line 1094
    if (tmp___25) {
#line 1095
      return;
    }
    {
#line 1099
    tmp___26 = answer_from_qmem(dns_fd, q, users[userid___0].qmemping_cmc, users[userid___0].qmemping_type,
                                30, (unsigned char *)((void *)(unpacked)));
    }
#line 1099
    if (tmp___26) {
#line 1102
      return;
    }
#line 1106
    if ((int )users[userid___0].q.id != 0) {
#line 1106
      if ((int )q->type == (int )users[userid___0].q.type) {
        {
#line 1106
        tmp___27 = strcmp((char const   *)(q->name), (char const   *)(users[userid___0].q.name));
        }
#line 1106
        if (! tmp___27) {
#line 1106
          if (users[userid___0].lazy) {
#line 1116
            if (debug >= 2) {
              {
#line 1117
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"PING pkt from user %d = dupe from impatient DNS server, remembering\n",
                      userid___0);
              }
            }
            {
#line 1120
            users[userid___0].q.id2 = q->id;
#line 1121
            users[userid___0].q.fromlen2 = q->fromlen;
#line 1122
            memcpy((void */* __restrict  */)(& users[userid___0].q.from2), (void const   */* __restrict  */)(& q->from),
                   (size_t )q->fromlen);
            }
#line 1123
            return;
          }
        }
      }
    }
#line 1126
    if ((int )users[userid___0].q_sendrealsoon.id != 0) {
#line 1126
      if ((int )q->type == (int )users[userid___0].q_sendrealsoon.type) {
        {
#line 1126
        tmp___28 = strcmp((char const   *)(q->name), (char const   *)(users[userid___0].q_sendrealsoon.name));
        }
#line 1126
        if (! tmp___28) {
#line 1131
          if (debug >= 2) {
            {
#line 1132
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"PING pkt from user %d = dupe from impatient DNS server, remembering\n",
                    userid___0);
            }
          }
          {
#line 1135
          users[userid___0].q_sendrealsoon.id2 = q->id;
#line 1136
          users[userid___0].q_sendrealsoon.fromlen2 = q->fromlen;
#line 1137
          memcpy((void */* __restrict  */)(& users[userid___0].q_sendrealsoon.from2),
                 (void const   */* __restrict  */)(& q->from), (size_t )q->fromlen);
          }
#line 1139
          return;
        }
      }
    }
#line 1142
    dn_seq = (int )unpacked[1] >> 4;
#line 1143
    dn_frag = (int )unpacked[1] & 15;
#line 1145
    if (debug >= 1) {
      {
#line 1146
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"PING pkt from user %d, ack for downstream %d/%d\n",
              userid___0, dn_seq, dn_frag);
      }
    }
    {
#line 1150
    process_downstream_ack(userid___0, dn_seq, dn_frag);
    }
#line 1152
    if (debug >= 3) {
      {
#line 1153
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"PINGret (if any) will ack upstream %d/%d\n",
              (int )users[userid___0].inpacket.seqno, (int )users[userid___0].inpacket.fragment);
      }
    }
#line 1160
    if ((int )users[userid___0].q_sendrealsoon.id != 0) {
      {
#line 1161
      send_chunk_or_dataless(dns_fd, userid___0, & users[userid___0].q_sendrealsoon);
      }
    }
#line 1169
    if ((int )users[userid___0].q.id != 0) {
      {
#line 1170
      didsend = 1;
#line 1171
      tmp___29 = send_chunk_or_dataless(dns_fd, userid___0, & users[userid___0].q);
      }
#line 1171
      if (tmp___29 == 1) {
#line 1173
        didsend = 0;
      }
    }
    {
#line 1177
    memcpy((void */* __restrict  */)(& users[userid___0].q), (void const   */* __restrict  */)q,
           sizeof(struct query ));
#line 1178
    users[userid___0].last_pkt = time((time_t *)((void *)0));
    }
#line 1183
    if (! didsend) {
#line 1183
      if (users[userid___0].outpacket.len > 0) {
        {
#line 1185
        send_chunk_or_dataless(dns_fd, userid___0, & users[userid___0].q);
        }
      } else {
#line 1183
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1183
    if (! users[userid___0].lazy) {
      {
#line 1185
      send_chunk_or_dataless(dns_fd, userid___0, & users[userid___0].q);
      }
    }
  } else
#line 1187
  if ((int )in[0] >= 48) {
#line 1187
    if ((int )in[0] <= 57) {
#line 1187
      goto _L___9;
    } else {
#line 1187
      goto _L___11;
    }
  } else
  _L___11: /* CIL Label */ 
#line 1187
  if ((int )in[0] >= 97) {
#line 1187
    if ((int )in[0] <= 102) {
#line 1187
      goto _L___9;
    } else {
#line 1187
      goto _L___10;
    }
  } else
  _L___10: /* CIL Label */ 
#line 1187
  if ((int )in[0] >= 65) {
#line 1187
    if ((int )in[0] <= 70) {
      _L___9: /* CIL Label */ 
#line 1191
      upstream_ok = 1;
#line 1192
      didsend___0 = 0;
#line 1193
      code = -1;
#line 1196
      if (domain_len < 6) {
#line 1197
        return;
      }
#line 1205
      if ((int )q->id == 0) {
#line 1206
        return;
      }
#line 1208
      if ((int )in[0] >= 48) {
#line 1208
        if ((int )in[0] <= 57) {
#line 1209
          code = (int )in[0] - 48;
        }
      }
#line 1210
      if ((int )in[0] >= 97) {
#line 1210
        if ((int )in[0] <= 102) {
#line 1211
          code = ((int )in[0] - 97) + 10;
        }
      }
#line 1212
      if ((int )in[0] >= 65) {
#line 1212
        if ((int )in[0] <= 70) {
#line 1213
          code = ((int )in[0] - 65) + 10;
        }
      }
      {
#line 1215
      userid___0 = code;
#line 1217
      tmp___30 = check_user_and_ip(userid___0, q);
      }
#line 1217
      if (tmp___30 != 0) {
        {
#line 1218
        write_dns(dns_fd, q, (char *)"BADIP", 5, (char )'T');
        }
#line 1219
        return;
      }
      {
#line 1224
      tmp___31 = answer_from_dnscache(dns_fd, userid___0, q);
      }
#line 1224
      if (tmp___31) {
#line 1225
        return;
      }
      {
#line 1229
      tmp___32 = answer_from_qmem_data(dns_fd, userid___0, q);
      }
#line 1229
      if (tmp___32) {
#line 1230
        return;
      }
#line 1234
      if ((int )users[userid___0].q.id != 0) {
#line 1234
        if ((int )q->type == (int )users[userid___0].q.type) {
          {
#line 1234
          tmp___33 = strcmp((char const   *)(q->name), (char const   *)(users[userid___0].q.name));
          }
#line 1234
          if (! tmp___33) {
#line 1234
            if (users[userid___0].lazy) {
#line 1244
              if (debug >= 2) {
                {
#line 1245
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"IN   pkt from user %d = dupe from impatient DNS server, remembering\n",
                        userid___0);
                }
              }
              {
#line 1248
              users[userid___0].q.id2 = q->id;
#line 1249
              users[userid___0].q.fromlen2 = q->fromlen;
#line 1250
              memcpy((void */* __restrict  */)(& users[userid___0].q.from2), (void const   */* __restrict  */)(& q->from),
                     (size_t )q->fromlen);
              }
#line 1251
              return;
            }
          }
        }
      }
#line 1254
      if ((int )users[userid___0].q_sendrealsoon.id != 0) {
#line 1254
        if ((int )q->type == (int )users[userid___0].q_sendrealsoon.type) {
          {
#line 1254
          tmp___34 = strcmp((char const   *)(q->name), (char const   *)(users[userid___0].q_sendrealsoon.name));
          }
#line 1254
          if (! tmp___34) {
#line 1259
            if (debug >= 2) {
              {
#line 1260
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"IN   pkt from user %d = dupe from impatient DNS server, remembering\n",
                      userid___0);
              }
            }
            {
#line 1263
            users[userid___0].q_sendrealsoon.id2 = q->id;
#line 1264
            users[userid___0].q_sendrealsoon.fromlen2 = q->fromlen;
#line 1265
            memcpy((void */* __restrict  */)(& users[userid___0].q_sendrealsoon.from2),
                   (void const   */* __restrict  */)(& q->from), (size_t )q->fromlen);
            }
#line 1267
            return;
          }
        }
      }
      {
#line 1272
      tmp___35 = b32_8to5((int )in[1]);
#line 1272
      up_seq = (tmp___35 >> 2) & 7;
#line 1273
      tmp___36 = b32_8to5((int )in[1]);
#line 1273
      tmp___37 = b32_8to5((int )in[2]);
#line 1273
      up_frag = ((tmp___36 & 3) << 2) | ((tmp___37 >> 3) & 3);
#line 1274
      tmp___38 = b32_8to5((int )in[2]);
#line 1274
      dn_seq___0 = tmp___38 & 7;
#line 1275
      tmp___39 = b32_8to5((int )in[3]);
#line 1275
      dn_frag___0 = tmp___39 >> 1;
#line 1276
      tmp___40 = b32_8to5((int )in[3]);
#line 1276
      lastfrag = tmp___40 & 1;
#line 1278
      process_downstream_ack(userid___0, dn_seq___0, dn_frag___0);
      }
#line 1280
      if (up_seq == (int )users[userid___0].inpacket.seqno) {
#line 1280
        if (up_frag <= (int )users[userid___0].inpacket.fragment) {
#line 1289
          if (debug >= 1) {
            {
#line 1290
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"IN   pkt seq# %d, frag %d, dropped duplicate frag\n",
                    up_seq, up_frag);
            }
          }
#line 1293
          upstream_ok = 0;
        } else {
#line 1280
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 1295
      if (up_seq != (int )users[userid___0].inpacket.seqno) {
        {
#line 1295
        tmp___41 = recent_seqno((int )users[userid___0].inpacket.seqno, up_seq);
        }
#line 1295
        if (tmp___41) {
#line 1299
          if (debug >= 1) {
            {
#line 1300
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"IN   pkt seq# %d, frag %d, dropped duplicate recent seqno\n",
                    up_seq, up_frag);
            }
          }
#line 1303
          upstream_ok = 0;
        } else {
#line 1295
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 1305
      if (up_seq != (int )users[userid___0].inpacket.seqno) {
#line 1308
        users[userid___0].inpacket.seqno = (char )up_seq;
#line 1309
        users[userid___0].inpacket.fragment = (char )up_frag;
#line 1310
        users[userid___0].inpacket.len = 0;
#line 1311
        users[userid___0].inpacket.offset = 0;
      } else {
#line 1315
        users[userid___0].inpacket.fragment = (char )up_frag;
      }
#line 1318
      if (debug >= 3) {
        {
#line 1319
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"INpack with upstream %d/%d, we are going to ack upstream %d/%d\n",
                up_seq, up_frag, (int )users[userid___0].inpacket.seqno, (int )users[userid___0].inpacket.fragment);
        }
      }
#line 1324
      if (upstream_ok) {
        {
#line 1326
        read___0 = unpack_data(unpacked, sizeof(unpacked), & in[5], (size_t )(domain_len - 5),
                               users[userid___0].encoder);
        }
#line 1330
        if ((unsigned long )read___0 < sizeof(users[userid___0].inpacket.data) - (unsigned long )users[userid___0].inpacket.offset) {
#line 1330
          read___0 = read___0;
        } else {
#line 1330
          read___0 = (int )(sizeof(users[userid___0].inpacket.data) - (unsigned long )users[userid___0].inpacket.offset);
        }
        {
#line 1331
        memcpy((void */* __restrict  */)(users[userid___0].inpacket.data + users[userid___0].inpacket.offset),
               (void const   */* __restrict  */)(unpacked), (size_t )read___0);
#line 1332
        users[userid___0].inpacket.len += read___0;
#line 1333
        users[userid___0].inpacket.offset += read___0;
        }
#line 1335
        if (debug >= 1) {
          {
#line 1336
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"IN   pkt seq# %d, frag %d (last=%d), fragsize %d, total %d, from user %d\n",
                  up_seq, up_frag, lastfrag, read___0, users[userid___0].inpacket.len,
                  userid___0);
          }
        }
      }
#line 1341
      if (upstream_ok) {
#line 1341
        if (lastfrag) {
          {
#line 1342
          handle_full_packet(tun_fd, dns_fd, userid___0);
          }
        }
      }
#line 1348
      if ((int )users[userid___0].q_sendrealsoon.id != 0) {
        {
#line 1349
        didsend___0 = 1;
#line 1350
        tmp___42 = send_chunk_or_dataless(dns_fd, userid___0, & users[userid___0].q_sendrealsoon);
        }
#line 1350
        if (tmp___42 == 1) {
#line 1352
          didsend___0 = 0;
        }
      }
#line 1368
      if ((int )users[userid___0].q.id != 0) {
#line 1369
        if (users[userid___0].outpacket.len > 0) {
#line 1369
          if (! didsend___0) {
#line 1369
            goto _L___2;
          } else {
#line 1369
            goto _L___6;
          }
        } else
        _L___6: /* CIL Label */ 
#line 1369
        if (upstream_ok) {
#line 1369
          if (! lastfrag) {
#line 1369
            if (! didsend___0) {
#line 1369
              goto _L___2;
            } else {
#line 1369
              goto _L___5;
            }
          } else {
#line 1369
            goto _L___5;
          }
        } else
        _L___5: /* CIL Label */ 
#line 1369
        if (! upstream_ok) {
#line 1369
          if (! didsend___0) {
#line 1369
            goto _L___2;
          } else {
#line 1369
            goto _L___3;
          }
        } else
        _L___3: /* CIL Label */ 
#line 1369
        if (! users[userid___0].lazy) {
          _L___2: /* CIL Label */ 
          {
#line 1373
          didsend___0 = 1;
#line 1374
          tmp___43 = send_chunk_or_dataless(dns_fd, userid___0, & users[userid___0].q);
          }
#line 1374
          if (tmp___43 == 1) {
#line 1376
            didsend___0 = 0;
          }
        } else {
          {
#line 1378
          memcpy((void */* __restrict  */)(& users[userid___0].q_sendrealsoon), (void const   */* __restrict  */)(& users[userid___0].q),
                 sizeof(struct query ));
#line 1381
          users[userid___0].q_sendrealsoon_new = 1;
#line 1382
          users[userid___0].q.id = (unsigned short)0;
#line 1383
          didsend___0 = 1;
          }
        }
      }
      {
#line 1388
      memcpy((void */* __restrict  */)(& users[userid___0].q), (void const   */* __restrict  */)q,
             sizeof(struct query ));
#line 1389
      users[userid___0].last_pkt = time((time_t *)((void *)0));
      }
#line 1404
      if (users[userid___0].outpacket.len > 0) {
#line 1404
        if (! didsend___0) {
          {
#line 1405
          send_chunk_or_dataless(dns_fd, userid___0, & users[userid___0].q);
          }
        } else {
#line 1404
          goto _L___8;
        }
      } else
      _L___8: /* CIL Label */ 
#line 1406
      if (! didsend___0) {
#line 1406
        goto _L___7;
      } else
#line 1406
      if (! users[userid___0].lazy) {
        _L___7: /* CIL Label */ 
#line 1407
        if (upstream_ok) {
#line 1407
          if (lastfrag) {
            {
#line 1408
            memcpy((void */* __restrict  */)(& users[userid___0].q_sendrealsoon),
                   (void const   */* __restrict  */)(& users[userid___0].q), sizeof(struct query ));
#line 1411
            users[userid___0].q_sendrealsoon_new = 1;
#line 1412
            users[userid___0].q.id = (unsigned short)0;
            }
          } else {
            {
#line 1414
            send_chunk_or_dataless(dns_fd, userid___0, & users[userid___0].q);
            }
          }
        } else {
          {
#line 1414
          send_chunk_or_dataless(dns_fd, userid___0, & users[userid___0].q);
          }
        }
      }
    }
  }
#line 1418
  return;
}
}
#line 1420 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/iodined.c"
static void handle_ns_request(int dns_fd , struct query *q ) 
{ 
  char buf[65536] ;
  int len ;
  struct sockaddr_in *tempin ;
  char *tmp ;
  ssize_t tmp___0 ;

  {
#line 1427
  if (ns_ip != 0U) {
    {
#line 1430
    memcpy((void */* __restrict  */)(& q->destination.s_addr), (void const   */* __restrict  */)(& ns_ip),
           sizeof(in_addr_t ));
    }
  }
  {
#line 1433
  len = dns_encode_ns_response(buf, sizeof(buf), q, topdomain___0);
  }
#line 1434
  if (len < 1) {
    {
#line 1435
    warnx("dns_encode_ns_response doesn\'t fit");
    }
#line 1436
    return;
  }
#line 1439
  if (debug >= 2) {
    {
#line 1441
    tempin = (struct sockaddr_in *)(& q->from);
#line 1442
    tmp = inet_ntoa(tempin->sin_addr);
#line 1442
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"TX: client %s, type %d, name %s, %d bytes NS reply\n",
            tmp, (int )q->type, q->name, len);
    }
  }
  {
#line 1445
  tmp___0 = sendto(dns_fd, (void const   *)(buf), (size_t )len, 0, (struct sockaddr  const  *)(& q->from),
                   (socklen_t )q->fromlen);
  }
#line 1445
  if (tmp___0 <= 0L) {
    {
#line 1446
    warn("ns reply send error");
    }
  }
#line 1448
  return;
}
}
#line 1450 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/iodined.c"
static void handle_a_request(int dns_fd , struct query *q , int fakeip ) 
{ 
  char buf[65536] ;
  int len ;
  in_addr_t ip ;
  in_addr_t tmp ;
  struct sockaddr_in *tempin ;
  char *tmp___0 ;
  ssize_t tmp___1 ;

  {
#line 1457
  if (fakeip) {
    {
#line 1458
    tmp = inet_addr("127.0.0.1");
#line 1458
    ip = tmp;
#line 1459
    memcpy((void */* __restrict  */)(& q->destination.s_addr), (void const   */* __restrict  */)(& ip),
           sizeof(in_addr_t ));
    }
  } else
#line 1461
  if (ns_ip != 0U) {
    {
#line 1464
    memcpy((void */* __restrict  */)(& q->destination.s_addr), (void const   */* __restrict  */)(& ns_ip),
           sizeof(in_addr_t ));
    }
  }
  {
#line 1467
  len = dns_encode_a_response(buf, sizeof(buf), q);
  }
#line 1468
  if (len < 1) {
    {
#line 1469
    warnx("dns_encode_a_response doesn\'t fit");
    }
#line 1470
    return;
  }
#line 1473
  if (debug >= 2) {
    {
#line 1475
    tempin = (struct sockaddr_in *)(& q->from);
#line 1476
    tmp___0 = inet_ntoa(tempin->sin_addr);
#line 1476
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"TX: client %s, type %d, name %s, %d bytes A reply\n",
            tmp___0, (int )q->type, q->name, len);
    }
  }
  {
#line 1479
  tmp___1 = sendto(dns_fd, (void const   *)(buf), (size_t )len, 0, (struct sockaddr  const  *)(& q->from),
                   (socklen_t )q->fromlen);
  }
#line 1479
  if (tmp___1 <= 0L) {
    {
#line 1480
    warn("a reply send error");
    }
  }
#line 1482
  return;
}
}
#line 1484 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/iodined.c"
static void forward_query(int bind_fd , struct query *q ) 
{ 
  char buf[65536] ;
  int len ;
  struct fw_query fwq___0 ;
  struct sockaddr_in *myaddr ;
  in_addr_t newaddr ;
  size_t tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 1493
  tmp = strlen((char const   *)(q->name));
#line 1493
  len = dns_encode(buf, sizeof(buf), q, (qr_t )0, q->name, tmp);
  }
#line 1494
  if (len < 1) {
    {
#line 1495
    warnx("dns_encode doesn\'t fit");
    }
#line 1496
    return;
  }
  {
#line 1500
  memcpy((void */* __restrict  */)(& fwq___0.addr), (void const   */* __restrict  */)(& q->from),
         (size_t )q->fromlen);
#line 1501
  fwq___0.addrlen = q->fromlen;
#line 1502
  fwq___0.id = q->id;
#line 1503
  fw_query_put(& fwq___0);
#line 1505
  newaddr = inet_addr("127.0.0.1");
#line 1506
  myaddr = (struct sockaddr_in *)(& q->from);
#line 1507
  memcpy((void */* __restrict  */)(& myaddr->sin_addr), (void const   */* __restrict  */)(& newaddr),
         sizeof(in_addr_t ));
#line 1508
  myaddr->sin_port = htons((uint16_t )bind_port);
  }
#line 1510
  if (debug >= 2) {
    {
#line 1511
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"TX: NS reply \n");
    }
  }
  {
#line 1514
  tmp___0 = sendto(bind_fd, (void const   *)(buf), (size_t )len, 0, (struct sockaddr  const  *)(& q->from),
                   (socklen_t )q->fromlen);
  }
#line 1514
  if (tmp___0 <= 0L) {
    {
#line 1515
    warn("forward query error");
    }
  }
#line 1517
  return;
}
}
#line 1519 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/iodined.c"
static int tunnel_bind(int bind_fd , int dns_fd ) 
{ 
  char packet[65536] ;
  struct sockaddr_in from ;
  socklen_t fromlen ;
  struct fw_query *query ;
  unsigned short id ;
  int r ;
  ssize_t tmp ;
  struct sockaddr_in *in ;
  char *tmp___0 ;
  ssize_t tmp___1 ;

  {
  {
#line 1529
  fromlen = (socklen_t )sizeof(struct sockaddr );
#line 1530
  tmp = recvfrom(bind_fd, (void */* __restrict  */)(packet), sizeof(packet), 0, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& from)),
                 (socklen_t */* __restrict  */)(& fromlen));
#line 1530
  r = (int )tmp;
  }
#line 1533
  if (r <= 0) {
#line 1534
    return (0);
  }
  {
#line 1536
  id = dns_get_id(packet, (size_t )r);
  }
#line 1538
  if (debug >= 2) {
    {
#line 1539
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"RX: Got response on query %u from DNS\n",
            (int )id & 65535);
    }
  }
  {
#line 1543
  fw_query_get(id, & query);
  }
#line 1544
  if (! query) {
#line 1544
    if (debug >= 2) {
      {
#line 1545
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Lost sender of id %u, dropping reply\n",
              (int )id & 65535);
      }
#line 1546
      return (0);
    }
  }
#line 1549
  if (debug >= 2) {
    {
#line 1551
    in = (struct sockaddr_in *)(& query->addr);
#line 1552
    tmp___0 = inet_ntoa(in->sin_addr);
#line 1552
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"TX: client %s id %u, %d bytes\n",
            tmp___0, (int )id & 65535, r);
    }
  }
  {
#line 1556
  tmp___1 = sendto(dns_fd, (void const   *)(packet), (size_t )r, 0, (struct sockaddr  const  *)(& query->addr),
                   (socklen_t )query->addrlen);
  }
#line 1556
  if (tmp___1 <= 0L) {
    {
#line 1558
    warn("forward reply error");
    }
  }
#line 1561
  return (0);
}
}
#line 1564 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/iodined.c"
static int tunnel_dns___0(int tun_fd , int dns_fd , int bind_fd ) 
{ 
  struct query q ;
  int read___0 ;
  int domain_len ;
  int inside_topdomain ;
  struct sockaddr_in *tempin ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
  {
#line 1570
  inside_topdomain = 0;
#line 1572
  read___0 = read_dns(dns_fd, tun_fd, & q);
  }
#line 1572
  if (read___0 <= 0) {
#line 1573
    return (0);
  }
#line 1575
  if (debug >= 2) {
    {
#line 1577
    tempin = (struct sockaddr_in *)(& q.from);
#line 1578
    tmp = inet_ntoa(tempin->sin_addr);
#line 1578
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"RX: client %s, type %d, name %s\n",
            tmp, (int )q.type, q.name);
    }
  }
  {
#line 1582
  tmp___0 = strlen((char const   *)(q.name));
#line 1582
  tmp___1 = strlen((char const   *)topdomain___0);
#line 1582
  domain_len = (int )(tmp___0 - tmp___1);
  }
#line 1583
  if (domain_len >= 0) {
    {
#line 1583
    tmp___2 = strcasecmp((char const   *)(q.name + domain_len), (char const   *)topdomain___0);
    }
#line 1583
    if (! tmp___2) {
#line 1584
      inside_topdomain = 1;
    }
  }
#line 1586
  if (domain_len >= 1) {
#line 1586
    if ((int )q.name[domain_len - 1] != 46) {
#line 1587
      inside_topdomain = 0;
    }
  }
#line 1589
  if (inside_topdomain) {
#line 1594
    if (domain_len == 3) {
#line 1594
      if ((int )q.type == 1) {
#line 1594
        if ((int )q.name[0] == 110) {
#line 1594
          goto _L___0;
        } else
#line 1594
        if ((int )q.name[0] == 78) {
          _L___0: /* CIL Label */ 
#line 1594
          if ((int )q.name[1] == 115) {
#line 1594
            goto _L;
          } else
#line 1594
          if ((int )q.name[1] == 83) {
            _L: /* CIL Label */ 
#line 1594
            if ((int )q.name[2] == 46) {
              {
#line 1598
              handle_a_request(dns_fd, & q, 0);
              }
#line 1599
              return (0);
            }
          }
        }
      }
    }
#line 1604
    if (domain_len == 4) {
#line 1604
      if ((int )q.type == 1) {
#line 1604
        if ((int )q.name[0] == 119) {
#line 1604
          goto _L___3;
        } else
#line 1604
        if ((int )q.name[0] == 87) {
          _L___3: /* CIL Label */ 
#line 1604
          if ((int )q.name[1] == 119) {
#line 1604
            goto _L___2;
          } else
#line 1604
          if ((int )q.name[1] == 87) {
            _L___2: /* CIL Label */ 
#line 1604
            if ((int )q.name[2] == 119) {
#line 1604
              goto _L___1;
            } else
#line 1604
            if ((int )q.name[2] == 87) {
              _L___1: /* CIL Label */ 
#line 1604
              if ((int )q.name[3] == 46) {
                {
#line 1609
                handle_a_request(dns_fd, & q, 1);
                }
#line 1610
                return (0);
              }
            }
          }
        }
      }
    }
    {
#line 1619
    if ((int )q.type == 16) {
#line 1619
      goto case_16;
    }
#line 1619
    if ((int )q.type == 33) {
#line 1619
      goto case_16;
    }
#line 1619
    if ((int )q.type == 15) {
#line 1619
      goto case_16;
    }
#line 1619
    if ((int )q.type == 1) {
#line 1619
      goto case_16;
    }
#line 1619
    if ((int )q.type == 5) {
#line 1619
      goto case_16;
    }
#line 1619
    if ((int )q.type == 10) {
#line 1619
      goto case_16;
    }
#line 1623
    if ((int )q.type == 2) {
#line 1623
      goto case_2;
    }
#line 1626
    goto switch_default;
    case_16: /* CIL Label */ 
    case_33: /* CIL Label */ 
    case_15: /* CIL Label */ 
    case_1: /* CIL Label */ 
    case_5: /* CIL Label */ 
    case_10: /* CIL Label */ 
    {
#line 1621
    handle_null_request(tun_fd, dns_fd, & q, domain_len);
    }
#line 1622
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 1624
    handle_ns_request(dns_fd, & q);
    }
#line 1625
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1627
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  } else
#line 1631
  if (bind_fd) {
    {
#line 1632
    forward_query(bind_fd, & q);
    }
  }
#line 1635
  return (0);
}
}
#line 1638 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/iodined.c"
static int tunnel(int tun_fd , int dns_fd , int bind_fd ) 
{ 
  struct timeval tv ;
  fd_set fds ;
  int i ;
  int userid___0 ;
  int maxfd ;
  time_t tmp ;
  int __d0 ;
  int __d1 ;
  int tmp___0 ;
  time_t tmp___1 ;

  {
  {
#line 1646
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1646
    if (! running___0) {
#line 1646
      goto while_break;
    }
#line 1648
    tv.tv_sec = (__time_t )10;
#line 1649
    tv.tv_usec = (__suseconds_t )0;
#line 1658
    userid___0 = 0;
    {
#line 1658
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1658
      if (! (userid___0 < 16)) {
#line 1658
        goto while_break___0;
      }
#line 1659
      if (users[userid___0].active) {
#line 1659
        if (! users[userid___0].disabled) {
          {
#line 1659
          tmp = time((time_t *)((void *)0));
          }
#line 1659
          if (users[userid___0].last_pkt + 60L > tmp) {
#line 1661
            users[userid___0].q_sendrealsoon_new = 0;
#line 1662
            if ((int )users[userid___0].q_sendrealsoon.id != 0) {
#line 1663
              tv.tv_sec = (__time_t )0;
#line 1664
              tv.tv_usec = (__suseconds_t )20000;
            }
          }
        }
      }
#line 1658
      userid___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1669
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1669
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& fds.__fds_bits[0]): "memory");
#line 1669
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1671
    fds.__fds_bits[dns_fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << dns_fd % (8 * (int )sizeof(__fd_mask ));
#line 1672
    maxfd = dns_fd;
#line 1674
    if (bind_fd) {
#line 1676
      fds.__fds_bits[bind_fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << bind_fd % (8 * (int )sizeof(__fd_mask ));
#line 1677
      if (bind_fd > maxfd) {
#line 1677
        maxfd = bind_fd;
      } else {
#line 1677
        maxfd = maxfd;
      }
    }
    {
#line 1682
    tmp___0 = all_users_waiting_to_send();
    }
#line 1682
    if (! tmp___0) {
#line 1683
      fds.__fds_bits[tun_fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << tun_fd % (8 * (int )sizeof(__fd_mask ));
#line 1684
      if (tun_fd > maxfd) {
#line 1684
        maxfd = tun_fd;
      } else {
#line 1684
        maxfd = maxfd;
      }
    }
    {
#line 1687
    i = select(maxfd + 1, (fd_set */* __restrict  */)(& fds), (fd_set */* __restrict  */)((void *)0),
               (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
    }
#line 1689
    if (i < 0) {
#line 1690
      if (running___0) {
        {
#line 1691
        warn("select");
        }
      }
#line 1692
      return (1);
    }
#line 1695
    if (! (i == 0)) {
#line 1698
      if ((fds.__fds_bits[tun_fd / (8 * (int )sizeof(__fd_mask ))] & (1L << tun_fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 1699
        tunnel_tun___0(tun_fd, dns_fd);
        }
      }
#line 1701
      if ((fds.__fds_bits[dns_fd / (8 * (int )sizeof(__fd_mask ))] & (1L << dns_fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 1702
        tunnel_dns___0(tun_fd, dns_fd, bind_fd);
        }
      }
#line 1704
      if ((fds.__fds_bits[bind_fd / (8 * (int )sizeof(__fd_mask ))] & (1L << bind_fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 1705
        tunnel_bind(bind_fd, dns_fd);
        }
      }
    }
#line 1710
    userid___0 = 0;
    {
#line 1710
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1710
      if (! (userid___0 < 16)) {
#line 1710
        goto while_break___2;
      }
#line 1711
      if (users[userid___0].active) {
#line 1711
        if (! users[userid___0].disabled) {
          {
#line 1711
          tmp___1 = time((time_t *)((void *)0));
          }
#line 1711
          if (users[userid___0].last_pkt + 60L > tmp___1) {
#line 1711
            if ((int )users[userid___0].q_sendrealsoon.id != 0) {
#line 1711
              if ((unsigned int )users[userid___0].conn == 1U) {
#line 1711
                if (! users[userid___0].q_sendrealsoon_new) {
                  {
#line 1716
                  send_chunk_or_dataless(dns_fd, userid___0, & users[userid___0].q_sendrealsoon);
                  }
                }
              }
            }
          }
        }
      }
#line 1710
      userid___0 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1719
  return (0);
}
}
#line 1722 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/iodined.c"
static void handle_full_packet(int tun_fd , int dns_fd , int userid___0 ) 
{ 
  unsigned long outlen ;
  char out[65536] ;
  int touser ;
  int ret ;
  struct ip *hdr ;

  {
  {
#line 1730
  outlen = sizeof(out);
#line 1731
  ret = uncompress((uint8_t *)(out), & outlen, (Bytef const   *)((uint8_t *)(users[userid___0].inpacket.data)),
                   (uLong )users[userid___0].inpacket.len);
  }
#line 1734
  if (ret == 0) {
    {
#line 1737
    hdr = (struct ip *)(out + 4);
#line 1738
    touser = find_user_by_ip(hdr->ip_dst.s_addr);
    }
#line 1740
    if (touser == -1) {
      {
#line 1742
      write_tun(tun_fd, out, outlen);
      }
    } else
#line 1746
    if ((unsigned int )users[touser].conn == 1U) {
#line 1747
      if (users[touser].outpacket.len == 0) {
        {
#line 1748
        start_new_outpacket(touser, users[userid___0].inpacket.data, users[userid___0].inpacket.len);
        }
#line 1753
        if ((int )users[touser].q_sendrealsoon.id != 0) {
          {
#line 1754
          send_chunk_or_dataless(dns_fd, touser, & users[touser].q_sendrealsoon);
          }
        } else
#line 1755
        if ((int )users[touser].q.id != 0) {
          {
#line 1756
          send_chunk_or_dataless(dns_fd, touser, & users[touser].q);
          }
        }
      } else {
        {
#line 1759
        save_to_outpacketq(touser, users[userid___0].inpacket.data, users[userid___0].inpacket.len);
        }
      }
    } else {
      {
#line 1765
      send_raw___0(dns_fd, users[userid___0].inpacket.data, users[userid___0].inpacket.len,
                   touser, 32, & users[touser].q);
      }
    }
  } else
#line 1772
  if (debug >= 1) {
    {
#line 1773
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Discarded data, uncompress() result: %d\n",
            ret);
    }
  }
#line 1777
  users[userid___0].inpacket.len = 0;
#line 1778
  users[userid___0].inpacket.offset = 0;
#line 1779
  return;
}
}
#line 1781 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/iodined.c"
static void handle_raw_login(char *packet , int len , struct query *q , int fd , int userid___0 ) 
{ 
  char myhash[16] ;
  time_t tmp ;
  struct sockaddr_in *tempin ;
  int tmp___0 ;

  {
#line 1786
  if (len < 16) {
#line 1786
    return;
  }
#line 1790
  if (userid___0 < 0) {
#line 1790
    return;
  } else
#line 1790
  if (userid___0 >= created_users) {
#line 1790
    return;
  }
#line 1791
  if (! users[userid___0].active) {
#line 1791
    return;
  } else
#line 1791
  if (users[userid___0].disabled) {
#line 1791
    return;
  }
  {
#line 1792
  tmp = time((time_t *)((void *)0));
  }
#line 1792
  if (users[userid___0].last_pkt + 60L < tmp) {
#line 1792
    return;
  }
#line 1794
  if (debug >= 1) {
    {
#line 1795
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"IN   login raw, len %d, from user %d\n",
            len, userid___0);
    }
  }
  {
#line 1800
  login_calculate(myhash, 16, (char const   *)(password___0), users[userid___0].seed + 1);
#line 1801
  tmp___0 = memcmp((void const   *)packet, (void const   *)(myhash), (size_t )16);
  }
#line 1801
  if (tmp___0 == 0) {
    {
#line 1805
    users[userid___0].last_pkt = time((time_t *)((void *)0));
#line 1806
    memcpy((void */* __restrict  */)(& users[userid___0].q), (void const   */* __restrict  */)q,
           sizeof(struct query ));
#line 1809
    tempin = (struct sockaddr_in *)(& q->from);
#line 1810
    memcpy((void */* __restrict  */)(& users[userid___0].host), (void const   */* __restrict  */)(& tempin->sin_addr),
           sizeof(struct in_addr ));
#line 1813
    user_set_conn_type(userid___0, (enum connection )0);
#line 1814
    login_calculate(myhash, 16, (char const   *)(password___0), users[userid___0].seed - 1);
#line 1815
    send_raw___0(fd, myhash, 16, userid___0, 16, q);
    }
  }
#line 1817
  return;
}
}
#line 1819 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/iodined.c"
static void handle_raw_data(char *packet , int len , struct query *q , int dns_fd ,
                            int tun_fd , int userid___0 ) 
{ 
  int tmp ;

  {
  {
#line 1822
  tmp = check_user_and_ip(userid___0, q);
  }
#line 1822
  if (tmp != 0) {
#line 1823
    return;
  }
  {
#line 1827
  users[userid___0].last_pkt = time((time_t *)((void *)0));
#line 1828
  memcpy((void */* __restrict  */)(& users[userid___0].q), (void const   */* __restrict  */)q,
         sizeof(struct query ));
#line 1831
  users[userid___0].inpacket.offset = 0;
#line 1832
  memcpy((void */* __restrict  */)(users[userid___0].inpacket.data), (void const   */* __restrict  */)packet,
         (size_t )len);
#line 1833
  users[userid___0].inpacket.len = len;
  }
#line 1835
  if (debug >= 1) {
    {
#line 1836
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"IN   pkt raw, total %d, from user %d\n",
            users[userid___0].inpacket.len, userid___0);
    }
  }
  {
#line 1840
  handle_full_packet(tun_fd, dns_fd, userid___0);
  }
#line 1841
  return;
}
}
#line 1843 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/iodined.c"
static void handle_raw_ping(struct query *q , int dns_fd , int userid___0 ) 
{ 
  int tmp ;

  {
  {
#line 1846
  tmp = check_user_and_ip(userid___0, q);
  }
#line 1846
  if (tmp != 0) {
#line 1847
    return;
  }
  {
#line 1851
  users[userid___0].last_pkt = time((time_t *)((void *)0));
#line 1852
  memcpy((void */* __restrict  */)(& users[userid___0].q), (void const   */* __restrict  */)q,
         sizeof(struct query ));
  }
#line 1854
  if (debug >= 1) {
    {
#line 1855
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"IN   ping raw, from user %d\n",
            userid___0);
    }
  }
  {
#line 1859
  send_raw___0(dns_fd, (char *)((void *)0), 0, userid___0, 48, q);
  }
#line 1860
  return;
}
}
#line 1862 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/iodined.c"
static int raw_decode(char *packet , int len , struct query *q , int dns_fd , int tun_fd ) 
{ 
  int raw_user ;
  int tmp ;

  {
#line 1868
  if (len < 4) {
#line 1868
    return (0);
  }
  {
#line 1870
  tmp = memcmp((void const   *)packet, (void const   *)(raw_header), (size_t )3);
  }
#line 1870
  if (tmp) {
#line 1870
    return (0);
  }
#line 1872
  raw_user = (int )*(packet + 3) & 15;
  {
#line 1874
  if (((int )*(packet + 3) & 240) == 16) {
#line 1874
    goto case_16;
  }
#line 1878
  if (((int )*(packet + 3) & 240) == 32) {
#line 1878
    goto case_32;
  }
#line 1882
  if (((int )*(packet + 3) & 240) == 48) {
#line 1882
    goto case_48;
  }
#line 1886
  goto switch_default;
  case_16: /* CIL Label */ 
  {
#line 1876
  handle_raw_login(packet + 4, len - 4, q, dns_fd, raw_user);
  }
#line 1877
  goto switch_break;
  case_32: /* CIL Label */ 
  {
#line 1880
  handle_raw_data(packet + 4, len - 4, q, dns_fd, tun_fd, raw_user);
  }
#line 1881
  goto switch_break;
  case_48: /* CIL Label */ 
  {
#line 1884
  handle_raw_ping(q, dns_fd, raw_user);
  }
#line 1885
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1887
  warnx("Unhandled raw command %02X from user %d", (int )*(packet + 3) & 240, raw_user);
  }
#line 1888
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1890
  return (1);
}
}
#line 1893 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/iodined.c"
static int read_dns(int fd , int tun_fd , struct query *q ) 
{ 
  struct sockaddr_in from ;
  socklen_t addrlen ;
  char packet[65536] ;
  int r ;
  char address[96] ;
  struct msghdr msg ;
  struct iovec iov ;
  struct cmsghdr *cmsg ;
  ssize_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 1906
  addrlen = (socklen_t )sizeof(struct sockaddr );
#line 1907
  iov.iov_base = (void *)(packet);
#line 1908
  iov.iov_len = sizeof(packet);
#line 1910
  msg.msg_name = (void *)((caddr_t )(& from));
#line 1911
  msg.msg_namelen = addrlen;
#line 1912
  msg.msg_iov = & iov;
#line 1913
  msg.msg_iovlen = (size_t )1;
#line 1914
  msg.msg_control = (void *)(address);
#line 1915
  msg.msg_controllen = sizeof(address);
#line 1916
  msg.msg_flags = 0;
#line 1918
  tmp = recvmsg(fd, & msg, 0);
#line 1918
  r = (int )tmp;
  }
#line 1924
  if (r > 0) {
    {
#line 1925
    memcpy((void */* __restrict  */)(& q->from), (void const   */* __restrict  */)((struct sockaddr *)(& from)),
           (size_t )addrlen);
#line 1926
    q->fromlen = (int )addrlen;
#line 1929
    tmp___0 = raw_decode(packet, r, q, fd, tun_fd);
    }
#line 1929
    if (tmp___0) {
#line 1930
      return (0);
    }
    {
#line 1932
    tmp___1 = dns_decode((char *)((void *)0), (size_t )0, q, (qr_t )0, packet, (size_t )r);
    }
#line 1932
    if (tmp___1 < 0) {
#line 1933
      return (0);
    }
#line 1937
    if (msg.msg_controllen >= sizeof(struct cmsghdr )) {
#line 1937
      cmsg = (struct cmsghdr *)msg.msg_control;
    } else {
#line 1937
      cmsg = (struct cmsghdr *)0;
    }
    {
#line 1937
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1937
      if (! ((unsigned long )cmsg != (unsigned long )((void *)0))) {
#line 1937
        goto while_break;
      }
#line 1940
      if (cmsg->cmsg_level == 0) {
#line 1940
        if (cmsg->cmsg_type == 8) {
#line 1943
          q->destination = ((struct in_pktinfo *)(cmsg->__cmsg_data))->ipi_addr;
#line 1944
          goto while_break;
        }
      }
      {
#line 1937
      cmsg = __cmsg_nxthdr(& msg, cmsg);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1949
    tmp___2 = strlen((char const   *)(q->name));
    }
#line 1949
    return ((int )tmp___2);
  } else
#line 1950
  if (r < 0) {
    {
#line 1952
    warn("read dns");
    }
  }
#line 1955
  return (0);
}
}
#line 1962
static size_t write_dns_nameenc(char *buf , size_t buflen , char *data , int datalen ,
                                char downenc___0 ) ;
#line 1962 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/iodined.c"
static int td1  =    0;
#line 1963 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/iodined.c"
static int td2  =    0;
#line 1958 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/iodined.c"
static size_t write_dns_nameenc(char *buf , size_t buflen , char *data , int datalen ,
                                char downenc___0 ) 
{ 
  size_t space ;
  char *b ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;

  {
#line 1968
  td1 += 3;
#line 1969
  td2 += 7;
#line 1970
  if (td1 >= 26) {
#line 1970
    td1 -= 26;
  }
#line 1971
  if (td2 >= 25) {
#line 1971
    td2 -= 25;
  }
#line 1977
  if (255UL < buflen) {
#line 1977
    tmp = (size_t )255;
  } else {
#line 1977
    tmp = buflen;
  }
  {
#line 1977
  space = (tmp - 4UL) - 2UL;
#line 1980
  memset((void *)buf, 0, sizeof(buf));
  }
#line 1982
  if ((int )downenc___0 == 83) {
    {
#line 1983
    *(buf + 0) = (char )'i';
#line 1984
    tmp___0 = (*(b64___0->places_dots))();
    }
#line 1984
    if (! tmp___0) {
#line 1985
      space -= space / 57UL;
    }
    {
#line 1986
    (*(b64___0->encode))(buf + 1, & space, (void const   *)data, (size_t )datalen);
#line 1987
    tmp___1 = (*(b64___0->places_dots))();
    }
#line 1987
    if (! tmp___1) {
      {
#line 1988
      inline_dotify(buf, buflen);
      }
    }
  } else
#line 1989
  if ((int )downenc___0 == 85) {
    {
#line 1990
    *(buf + 0) = (char )'j';
#line 1991
    tmp___2 = (*(b64u___0->places_dots))();
    }
#line 1991
    if (! tmp___2) {
#line 1992
      space -= space / 57UL;
    }
    {
#line 1993
    (*(b64u___0->encode))(buf + 1, & space, (void const   *)data, (size_t )datalen);
#line 1994
    tmp___3 = (*(b64u___0->places_dots))();
    }
#line 1994
    if (! tmp___3) {
      {
#line 1995
      inline_dotify(buf, buflen);
      }
    }
  } else
#line 1996
  if ((int )downenc___0 == 86) {
    {
#line 1997
    *(buf + 0) = (char )'k';
#line 1998
    tmp___4 = (*(b128___0->places_dots))();
    }
#line 1998
    if (! tmp___4) {
#line 1999
      space -= space / 57UL;
    }
    {
#line 2000
    (*(b128___0->encode))(buf + 1, & space, (void const   *)data, (size_t )datalen);
#line 2001
    tmp___5 = (*(b128___0->places_dots))();
    }
#line 2001
    if (! tmp___5) {
      {
#line 2002
      inline_dotify(buf, buflen);
      }
    }
  } else {
    {
#line 2004
    *(buf + 0) = (char )'h';
#line 2005
    tmp___6 = (*(b32___0->places_dots))();
    }
#line 2005
    if (! tmp___6) {
#line 2006
      space -= space / 57UL;
    }
    {
#line 2007
    (*(b32___0->encode))(buf + 1, & space, (void const   *)data, (size_t )datalen);
#line 2008
    tmp___7 = (*(b32___0->places_dots))();
    }
#line 2008
    if (! tmp___7) {
      {
#line 2009
      inline_dotify(buf, buflen);
      }
    }
  }
  {
#line 2013
  b = buf;
#line 2014
  tmp___8 = strlen((char const   *)buf);
#line 2014
  b += tmp___8 - 1UL;
  }
#line 2015
  if ((int )*b != 46) {
#line 2016
    b ++;
#line 2016
    *b = (char )'.';
  }
#line 2017
  b ++;
#line 2019
  *b = (char )(97 + td1);
#line 2020
  b ++;
#line 2021
  *b = (char )(97 + td2);
#line 2022
  b ++;
#line 2023
  *b = (char )'\000';
#line 2025
  return (space);
}
}
#line 2028 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/iodined.c"
static void write_dns(int fd , struct query *q , char *data , int datalen , char downenc___0 ) 
{ 
  char buf[65536] ;
  int len ;
  char cnamebuf[1024] ;
  char mxbuf[65536] ;
  char *b ;
  int offset ;
  int res ;
  size_t tmp ;
  size_t tmp___0 ;
  char txtbuf[65536] ;
  size_t space ;
  struct sockaddr_in *tempin ;
  char *tmp___1 ;

  {
#line 2032
  len = 0;
#line 2034
  if ((int )q->type == 5) {
    {
#line 2037
    write_dns_nameenc(cnamebuf, sizeof(cnamebuf), data, datalen, downenc___0);
#line 2040
    len = dns_encode(buf, sizeof(buf), q, (qr_t )1, cnamebuf, sizeof(cnamebuf));
    }
  } else
#line 2034
  if ((int )q->type == 1) {
    {
#line 2037
    write_dns_nameenc(cnamebuf, sizeof(cnamebuf), data, datalen, downenc___0);
#line 2040
    len = dns_encode(buf, sizeof(buf), q, (qr_t )1, cnamebuf, sizeof(cnamebuf));
    }
  } else
#line 2042
  if ((int )q->type == 15) {
#line 2042
    goto _L;
  } else
#line 2042
  if ((int )q->type == 33) {
    _L: /* CIL Label */ 
#line 2044
    b = mxbuf;
#line 2045
    offset = 0;
    {
#line 2048
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 2049
      tmp = write_dns_nameenc(b, sizeof(mxbuf) - (unsigned long )(b - mxbuf), data + offset,
                              datalen - offset, downenc___0);
#line 2049
      res = (int )tmp;
      }
#line 2052
      if (res < 1) {
#line 2054
        b ++;
#line 2055
        goto while_break;
      }
      {
#line 2058
      tmp___0 = strlen((char const   *)b);
#line 2058
      b = (b + tmp___0) + 1;
#line 2060
      offset += res;
      }
#line 2061
      if (offset >= datalen) {
#line 2062
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 2066
    *b = (char )'\000';
#line 2068
    len = dns_encode(buf, sizeof(buf), q, (qr_t )1, mxbuf, sizeof(mxbuf));
    }
  } else
#line 2070
  if ((int )q->type == 16) {
    {
#line 2073
    space = sizeof(txtbuf) - 1UL;
#line 2075
    memset((void *)(txtbuf), 0, sizeof(txtbuf));
    }
#line 2077
    if ((int )downenc___0 == 83) {
      {
#line 2078
      txtbuf[0] = (char )'s';
#line 2079
      len = (*(b64___0->encode))(txtbuf + 1, & space, (void const   *)data, (size_t )datalen);
      }
    } else
#line 2081
    if ((int )downenc___0 == 85) {
      {
#line 2082
      txtbuf[0] = (char )'u';
#line 2083
      len = (*(b64u___0->encode))(txtbuf + 1, & space, (void const   *)data, (size_t )datalen);
      }
    } else
#line 2085
    if ((int )downenc___0 == 86) {
      {
#line 2086
      txtbuf[0] = (char )'v';
#line 2087
      len = (*(b128___0->encode))(txtbuf + 1, & space, (void const   *)data, (size_t )datalen);
      }
    } else
#line 2089
    if ((int )downenc___0 == 82) {
#line 2090
      txtbuf[0] = (char )'r';
#line 2091
      if ((unsigned long )datalen < sizeof(txtbuf) - 1UL) {
#line 2091
        len = datalen;
      } else {
#line 2091
        len = (int )(sizeof(txtbuf) - 1UL);
      }
      {
#line 2092
      memcpy((void */* __restrict  */)(txtbuf + 1), (void const   */* __restrict  */)data,
             (size_t )len);
      }
    } else {
      {
#line 2094
      txtbuf[0] = (char )'t';
#line 2095
      len = (*(b32___0->encode))(txtbuf + 1, & space, (void const   *)data, (size_t )datalen);
      }
    }
    {
#line 2097
    len = dns_encode(buf, sizeof(buf), q, (qr_t )1, txtbuf, (size_t )(len + 1));
    }
  } else {
    {
#line 2100
    len = dns_encode(buf, sizeof(buf), q, (qr_t )1, data, (size_t )datalen);
    }
  }
#line 2103
  if (len < 1) {
    {
#line 2104
    warnx("dns_encode doesn\'t fit");
    }
#line 2105
    return;
  }
#line 2108
  if (debug >= 2) {
    {
#line 2110
    tempin = (struct sockaddr_in *)(& q->from);
#line 2111
    tmp___1 = inet_ntoa(tempin->sin_addr);
#line 2111
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"TX: client %s, type %d, name %s, %d bytes data\n",
            tmp___1, (int )q->type, q->name, datalen);
    }
  }
  {
#line 2115
  sendto(fd, (void const   *)(buf), (size_t )len, 0, (struct sockaddr  const  *)(& q->from),
         (socklen_t )q->fromlen);
  }
#line 2116
  return;
}
}
#line 2118 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/iodined.c"
static void usage___0(void) 
{ 


  {
  {
#line 2122
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: %s [-v] [-h] [-c] [-s] [-f] [-D] [-u user] [-t chrootdir] [-d device] [-m mtu] [-z context] [-l ip address to listen on] [-p port] [-n external ip] [-b dnsport] [-P password] [-F pidfile] tunnel_ip[/netmask] topdomain\n",
          __progname);
#line 2127
  exit(2);
  }
}
}
#line 2130 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/iodined.c"
static void help___0(void) 
{ 


  {
  {
#line 2134
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"iodine IP over DNS tunneling server\n");
#line 2135
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: %s [-v] [-h] [-c] [-s] [-f] [-D] [-u user] [-t chrootdir] [-d device] [-m mtu] [-z context] [-l ip address to listen on] [-p port] [-n external ip] [-b dnsport] [-P password] [-F pidfile] tunnel_ip[/netmask] topdomain\n",
          __progname);
#line 2139
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -v to print version info and exit\n");
#line 2140
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -h to print this help and exit\n");
#line 2141
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -c to disable check of client IP/port on each request\n");
#line 2142
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -s to skip creating and configuring the tun device, which then has to be created manually\n");
#line 2144
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -f to keep running in foreground\n");
#line 2145
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -D to increase debug level\n");
#line 2146
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"     (using -DD in UTF-8 terminal: \"LC_ALL=C luit iodined -DD ...\")\n");
#line 2147
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -u name to drop privileges and run as user \'name\'\n");
#line 2148
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -t dir to chroot to directory dir\n");
#line 2149
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -d device to set tunnel device name\n");
#line 2150
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -m mtu to set tunnel device mtu\n");
#line 2151
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -z context to apply SELinux context after initialization\n");
#line 2152
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -l ip address to listen on for incoming dns traffic (default 0.0.0.0)\n");
#line 2154
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -p port to listen on for incoming dns traffic (default 53)\n");
#line 2155
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -n ip to respond with to NS queries\n");
#line 2156
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -b port to forward normal DNS queries to (on localhost)\n");
#line 2157
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -P password used for authentication (max 32 chars will be used)\n");
#line 2158
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -F pidfile to write pid to a file\n");
#line 2159
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"tunnel_ip is the IP number of the local tunnel interface.\n");
#line 2160
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"   /netmask sets the size of the tunnel network.\n");
#line 2161
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"topdomain is the FQDN that is delegated to this server.\n");
#line 2162
  exit(0);
  }
}
}
#line 2165 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/iodined.c"
static void version___0(void) 
{ 


  {
  {
#line 2167
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"iodine IP over DNS tunneling server\n");
#line 2168
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"version: 0.6.0-rc1 from 2010-02-13\n");
#line 2169
  exit(0);
  }
}
}
#line 21 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/read.c"
static int readname_loop___0(char *packet , int packetlen , char **src , char *dst ,
                             size_t length , size_t loop ) 
{ 
  char *dummy ;
  char *s ;
  char *d ;
  int len ;
  int offset ;
  char c ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 31
  if (loop <= 0UL) {
#line 32
    return (0);
  }
#line 34
  len = 0;
#line 35
  s = *src;
#line 36
  d = dst;
  {
#line 37
  while (1) {
    while_continue: /* CIL Label */ ;
#line 37
    if (*s) {
#line 37
      if (! ((size_t )len < length - 2UL)) {
#line 37
        goto while_break;
      }
    } else {
#line 37
      goto while_break;
    }
#line 38
    tmp = s;
#line 38
    s ++;
#line 38
    c = *tmp;
#line 41
    if (((int )c & 192) == 192) {
#line 42
      offset = (((int )*(s + -1) & 63) << 8) | ((int )*(s + 0) & 255);
#line 43
      if (offset > packetlen) {
#line 44
        if (len == 0) {
#line 46
          return (0);
        } else {
#line 49
          goto while_break;
        }
      }
      {
#line 52
      dummy = packet + offset;
#line 53
      tmp___0 = readname_loop___0(packet, packetlen, & dummy, d, length - (size_t )len,
                                  loop - 1UL);
#line 53
      len += tmp___0;
      }
#line 54
      goto end;
    }
    {
#line 57
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 57
      if (c) {
#line 57
        if (! ((size_t )len < length - 1UL)) {
#line 57
          goto while_break___0;
        }
      } else {
#line 57
        goto while_break___0;
      }
#line 58
      tmp___1 = d;
#line 58
      d ++;
#line 58
      tmp___2 = s;
#line 58
      s ++;
#line 58
      *tmp___1 = *tmp___2;
#line 59
      len ++;
#line 61
      c = (char )((int )c - 1);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 64
    if ((size_t )len >= length - 1UL) {
#line 65
      goto while_break;
    }
#line 68
    if ((int )*s != 0) {
#line 69
      tmp___3 = d;
#line 69
      d ++;
#line 69
      *tmp___3 = (char )'.';
#line 70
      len ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 73
  tmp___4 = len;
#line 73
  len ++;
#line 73
  *(dst + tmp___4) = (char )'\000';
  end: 
#line 76
  *src = s + 1;
#line 77
  return (len);
}
}
#line 30 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base64.c"
static char const   cb64___1[65]  = 
#line 30 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base64.c"
  {      (char const   )'a',      (char const   )'b',      (char const   )'c',      (char const   )'d', 
        (char const   )'e',      (char const   )'f',      (char const   )'g',      (char const   )'h', 
        (char const   )'i',      (char const   )'j',      (char const   )'k',      (char const   )'l', 
        (char const   )'m',      (char const   )'n',      (char const   )'o',      (char const   )'p', 
        (char const   )'q',      (char const   )'r',      (char const   )'s',      (char const   )'t', 
        (char const   )'u',      (char const   )'v',      (char const   )'w',      (char const   )'x', 
        (char const   )'y',      (char const   )'z',      (char const   )'A',      (char const   )'B', 
        (char const   )'C',      (char const   )'D',      (char const   )'E',      (char const   )'F', 
        (char const   )'G',      (char const   )'H',      (char const   )'I',      (char const   )'J', 
        (char const   )'K',      (char const   )'L',      (char const   )'M',      (char const   )'N', 
        (char const   )'O',      (char const   )'P',      (char const   )'Q',      (char const   )'R', 
        (char const   )'S',      (char const   )'T',      (char const   )'U',      (char const   )'V', 
        (char const   )'W',      (char const   )'X',      (char const   )'Y',      (char const   )'Z', 
        (char const   )'-',      (char const   )'0',      (char const   )'1',      (char const   )'2', 
        (char const   )'3',      (char const   )'4',      (char const   )'5',      (char const   )'6', 
        (char const   )'7',      (char const   )'8',      (char const   )'9',      (char const   )'+', 
        (char const   )'\000'};
#line 32 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base64.c"
static unsigned char rev64___1[256]  ;
#line 33 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base64.c"
static int reverse_init___4  =    0;
#line 35
static int base64_encode___0(char *buf , size_t *buflen , void const   *data , size_t size ) ;
#line 36
static int base64_decode___0(void *buf , size_t *buflen , char const   *str , size_t slen ) ;
#line 37
static int base64_handles_dots___0(void) ;
#line 38
static int base64_blksize_raw___0(void) ;
#line 39
static int base64_blksize_enc___0(void) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base64.c"
static struct encoder base64_encoder___0  =    {{(char )'B', (char )'a', (char )'s', (char )'e', (char )'6', (char )'4', (char )'\000'},
    & base64_encode___0, & base64_decode___0, & base64_handles_dots___0, & base64_handles_dots___0,
    & base64_blksize_raw___0, & base64_blksize_enc___0};
#line 58 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base64.c"
static int base64_handles_dots___0(void) 
{ 


  {
#line 61
  return (0);
}
}
#line 64 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base64.c"
static int base64_blksize_raw___0(void) 
{ 


  {
#line 67
  return (3);
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base64.c"
static int base64_blksize_enc___0(void) 
{ 


  {
#line 73
  return (4);
}
}
#line 76 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base64.c"
__inline static void base64_reverse_init___0(void) 
{ 
  int i ;
  unsigned char c ;

  {
#line 82
  if (! reverse_init___4) {
    {
#line 83
    memset((void *)(rev64___1), 0, (size_t )256);
#line 84
    i = 0;
    }
    {
#line 84
    while (1) {
      while_continue: /* CIL Label */ ;
#line 84
      if (! (i < 64)) {
#line 84
        goto while_break;
      }
#line 85
      c = (unsigned char )cb64___1[i];
#line 86
      rev64___1[(int )c] = (unsigned char )i;
#line 84
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 88
    reverse_init___4 = 1;
  }
#line 90
  return;
}
}
#line 92 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base64.c"
static int base64_encode___0(char *buf , size_t *buflen , void const   *data , size_t size ) 
{ 
  unsigned char *udata ;
  int iout ;
  int iin ;
  int tmp ;
  int tmp___0 ;

  {
#line 104
  udata = (unsigned char *)data;
#line 105
  iout = 0;
#line 106
  iin = 0;
  {
#line 112
  while (1) {
    while_continue: /* CIL Label */ ;
#line 113
    if ((size_t )iout >= *buflen) {
#line 114
      goto while_break;
    } else
#line 113
    if ((size_t )iin >= size) {
#line 114
      goto while_break;
    }
#line 115
    *(buf + iout) = (char )cb64___1[((int )*(udata + iin) & 252) >> 2];
#line 116
    iout ++;
#line 118
    if ((size_t )iout >= *buflen) {
#line 119
      iout --;
#line 120
      goto while_break;
    } else
#line 118
    if ((size_t )iin >= size) {
#line 119
      iout --;
#line 120
      goto while_break;
    }
#line 122
    if ((size_t )(iin + 1) < size) {
#line 122
      tmp = ((int )*(udata + (iin + 1)) & 240) >> 4;
    } else {
#line 122
      tmp = 0;
    }
#line 122
    *(buf + iout) = (char )cb64___1[(((int )*(udata + iin) & 3) << 4) | tmp];
#line 125
    iin ++;
#line 126
    iout ++;
#line 128
    if ((size_t )iout >= *buflen) {
#line 129
      goto while_break;
    } else
#line 128
    if ((size_t )iin >= size) {
#line 129
      goto while_break;
    }
#line 130
    if ((size_t )(iin + 1) < size) {
#line 130
      tmp___0 = ((int )*(udata + (iin + 1)) & 192) >> 6;
    } else {
#line 130
      tmp___0 = 0;
    }
#line 130
    *(buf + iout) = (char )cb64___1[(((int )*(udata + iin) & 15) << 2) | tmp___0];
#line 133
    iin ++;
#line 134
    iout ++;
#line 136
    if ((size_t )iout >= *buflen) {
#line 137
      goto while_break;
    } else
#line 136
    if ((size_t )iin >= size) {
#line 137
      goto while_break;
    }
#line 138
    *(buf + iout) = (char )cb64___1[(int )*(udata + iin) & 63];
#line 139
    iin ++;
#line 140
    iout ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 143
  *(buf + iout) = (char )'\000';
#line 146
  *buflen = (size_t )iin;
#line 148
  return (iout);
}
}
#line 153 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base64.c"
static int base64_decode___0(void *buf , size_t *buflen , char const   *str , size_t slen ) 
{ 
  unsigned char *ubuf ;
  int iout ;
  int iin ;

  {
  {
#line 167
  ubuf = (unsigned char *)buf;
#line 168
  iout = 0;
#line 169
  iin = 0;
#line 171
  base64_reverse_init___0();
  }
  {
#line 176
  while (1) {
    while_continue: /* CIL Label */ ;
#line 177
    if ((size_t )iout >= *buflen) {
#line 179
      goto while_break;
    } else
#line 177
    if ((size_t )(iin + 1) >= slen) {
#line 179
      goto while_break;
    } else
#line 177
    if ((int const   )*(str + iin) == 0) {
#line 179
      goto while_break;
    } else
#line 177
    if ((int const   )*(str + (iin + 1)) == 0) {
#line 179
      goto while_break;
    }
#line 180
    *(ubuf + iout) = (unsigned char )((((int )rev64___1[(int )*(str + iin)] & 63) << 2) | (((int )rev64___1[(int )*(str + (iin + 1))] & 48) >> 4));
#line 182
    iin ++;
#line 183
    iout ++;
#line 185
    if ((size_t )iout >= *buflen) {
#line 187
      goto while_break;
    } else
#line 185
    if ((size_t )(iin + 1) >= slen) {
#line 187
      goto while_break;
    } else
#line 185
    if ((int const   )*(str + iin) == 0) {
#line 187
      goto while_break;
    } else
#line 185
    if ((int const   )*(str + (iin + 1)) == 0) {
#line 187
      goto while_break;
    }
#line 188
    *(ubuf + iout) = (unsigned char )((((int )rev64___1[(int )*(str + iin)] & 15) << 4) | (((int )rev64___1[(int )*(str + (iin + 1))] & 60) >> 2));
#line 190
    iin ++;
#line 191
    iout ++;
#line 193
    if ((size_t )iout >= *buflen) {
#line 195
      goto while_break;
    } else
#line 193
    if ((size_t )(iin + 1) >= slen) {
#line 195
      goto while_break;
    } else
#line 193
    if ((int const   )*(str + iin) == 0) {
#line 195
      goto while_break;
    } else
#line 193
    if ((int const   )*(str + (iin + 1)) == 0) {
#line 195
      goto while_break;
    }
#line 196
    *(ubuf + iout) = (unsigned char )((((int )rev64___1[(int )*(str + iin)] & 3) << 6) | ((int )rev64___1[(int )*(str + (iin + 1))] & 63));
#line 198
    iin += 2;
#line 199
    iout ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 202
  *(ubuf + iout) = (unsigned char )'\000';
#line 204
  return (iout);
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base128.c"
static unsigned char const   cb128___0[129]  = 
#line 45 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base128.c"
  {      (unsigned char const   )'a',      (unsigned char const   )'b',      (unsigned char const   )'c',      (unsigned char const   )'d', 
        (unsigned char const   )'e',      (unsigned char const   )'f',      (unsigned char const   )'g',      (unsigned char const   )'h', 
        (unsigned char const   )'i',      (unsigned char const   )'j',      (unsigned char const   )'k',      (unsigned char const   )'l', 
        (unsigned char const   )'m',      (unsigned char const   )'n',      (unsigned char const   )'o',      (unsigned char const   )'p', 
        (unsigned char const   )'q',      (unsigned char const   )'r',      (unsigned char const   )'s',      (unsigned char const   )'t', 
        (unsigned char const   )'u',      (unsigned char const   )'v',      (unsigned char const   )'w',      (unsigned char const   )'x', 
        (unsigned char const   )'y',      (unsigned char const   )'z',      (unsigned char const   )'A',      (unsigned char const   )'B', 
        (unsigned char const   )'C',      (unsigned char const   )'D',      (unsigned char const   )'E',      (unsigned char const   )'F', 
        (unsigned char const   )'G',      (unsigned char const   )'H',      (unsigned char const   )'I',      (unsigned char const   )'J', 
        (unsigned char const   )'K',      (unsigned char const   )'L',      (unsigned char const   )'M',      (unsigned char const   )'N', 
        (unsigned char const   )'O',      (unsigned char const   )'P',      (unsigned char const   )'Q',      (unsigned char const   )'R', 
        (unsigned char const   )'S',      (unsigned char const   )'T',      (unsigned char const   )'U',      (unsigned char const   )'V', 
        (unsigned char const   )'W',      (unsigned char const   )'X',      (unsigned char const   )'Y',      (unsigned char const   )'Z', 
        (unsigned char const   )'0',      (unsigned char const   )'1',      (unsigned char const   )'2',      (unsigned char const   )'3', 
        (unsigned char const   )'4',      (unsigned char const   )'5',      (unsigned char const   )'6',      (unsigned char const   )'7', 
        (unsigned char const   )'8',      (unsigned char const   )'9',      (unsigned char const   )'\274',      (unsigned char const   )'\275', 
        (unsigned char const   )'\276',      (unsigned char const   )'\277',      (unsigned char const   )'\300',      (unsigned char const   )'\301', 
        (unsigned char const   )'\302',      (unsigned char const   )'\303',      (unsigned char const   )'\304',      (unsigned char const   )'\305', 
        (unsigned char const   )'\306',      (unsigned char const   )'\307',      (unsigned char const   )'\310',      (unsigned char const   )'\311', 
        (unsigned char const   )'\312',      (unsigned char const   )'\313',      (unsigned char const   )'\314',      (unsigned char const   )'\315', 
        (unsigned char const   )'\316',      (unsigned char const   )'\317',      (unsigned char const   )'\320',      (unsigned char const   )'\321', 
        (unsigned char const   )'\322',      (unsigned char const   )'\323',      (unsigned char const   )'\324',      (unsigned char const   )'\325', 
        (unsigned char const   )'\326',      (unsigned char const   )'\327',      (unsigned char const   )'\330',      (unsigned char const   )'\331', 
        (unsigned char const   )'\332',      (unsigned char const   )'\333',      (unsigned char const   )'\334',      (unsigned char const   )'\335', 
        (unsigned char const   )'\336',      (unsigned char const   )'\337',      (unsigned char const   )'\340',      (unsigned char const   )'\341', 
        (unsigned char const   )'\342',      (unsigned char const   )'\343',      (unsigned char const   )'\344',      (unsigned char const   )'\345', 
        (unsigned char const   )'\346',      (unsigned char const   )'\347',      (unsigned char const   )'\350',      (unsigned char const   )'\351', 
        (unsigned char const   )'\352',      (unsigned char const   )'\353',      (unsigned char const   )'\354',      (unsigned char const   )'\355', 
        (unsigned char const   )'\356',      (unsigned char const   )'\357',      (unsigned char const   )'\360',      (unsigned char const   )'\361', 
        (unsigned char const   )'\362',      (unsigned char const   )'\363',      (unsigned char const   )'\364',      (unsigned char const   )'\365', 
        (unsigned char const   )'\366',      (unsigned char const   )'\367',      (unsigned char const   )'\370',      (unsigned char const   )'\371', 
        (unsigned char const   )'\372',      (unsigned char const   )'\373',      (unsigned char const   )'\374',      (unsigned char const   )'\375', 
        (unsigned char const   )'\000'};
#line 52 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base128.c"
static unsigned char rev128___0[256]  ;
#line 53 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base128.c"
static int reverse_init___5  =    0;
#line 55
static int base128_encode___0(char *buf , size_t *buflen , void const   *data , size_t size ) ;
#line 56
static int base128_decode___0(void *buf , size_t *buflen , char const   *str , size_t slen ) ;
#line 57
static int base128_handles_dots___0(void) ;
#line 58
static int base128_blksize_raw___0(void) ;
#line 59
static int base128_blksize_enc___0(void) ;
#line 61 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base128.c"
static struct encoder base128_encoder___0  =    {{(char )'B', (char )'a', (char )'s', (char )'e', (char )'1', (char )'2', (char )'8',
     (char )'\000'}, & base128_encode___0, & base128_decode___0, & base128_handles_dots___0,
    & base128_handles_dots___0, & base128_blksize_raw___0, & base128_blksize_enc___0};
#line 78 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base128.c"
static int base128_handles_dots___0(void) 
{ 


  {
#line 81
  return (0);
}
}
#line 84 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base128.c"
static int base128_blksize_raw___0(void) 
{ 


  {
#line 87
  return (7);
}
}
#line 90 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base128.c"
static int base128_blksize_enc___0(void) 
{ 


  {
#line 93
  return (8);
}
}
#line 96 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base128.c"
__inline static void base128_reverse_init___0(void) 
{ 
  int i ;
  unsigned char c ;

  {
#line 102
  if (! reverse_init___5) {
    {
#line 103
    memset((void *)(rev128___0), 0, (size_t )256);
#line 104
    i = 0;
    }
    {
#line 104
    while (1) {
      while_continue: /* CIL Label */ ;
#line 104
      if (! (i < 128)) {
#line 104
        goto while_break;
      }
#line 105
      c = (unsigned char )cb128___0[i];
#line 106
      rev128___0[(int )c] = (unsigned char )i;
#line 104
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 108
    reverse_init___5 = 1;
  }
#line 110
  return;
}
}
#line 112 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base128.c"
static int base128_encode___0(char *buf , size_t *buflen , void const   *data , size_t size ) 
{ 
  unsigned char *ubuf ;
  unsigned char *udata ;
  int iout ;
  int iin ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 124
  ubuf = (unsigned char *)buf;
#line 125
  udata = (unsigned char *)data;
#line 126
  iout = 0;
#line 127
  iin = 0;
  {
#line 133
  while (1) {
    while_continue: /* CIL Label */ ;
#line 134
    if ((size_t )iout >= *buflen) {
#line 135
      goto while_break;
    } else
#line 134
    if ((size_t )iin >= size) {
#line 135
      goto while_break;
    }
#line 136
    *(ubuf + iout) = (unsigned char )cb128___0[((int )*(udata + iin) & 254) >> 1];
#line 137
    iout ++;
#line 139
    if ((size_t )iout >= *buflen) {
#line 140
      iout --;
#line 141
      goto while_break;
    } else
#line 139
    if ((size_t )iin >= size) {
#line 140
      iout --;
#line 141
      goto while_break;
    }
#line 143
    if ((size_t )(iin + 1) < size) {
#line 143
      tmp = ((int )*(udata + (iin + 1)) & 252) >> 2;
    } else {
#line 143
      tmp = 0;
    }
#line 143
    *(ubuf + iout) = (unsigned char )cb128___0[(((int )*(udata + iin) & 1) << 6) | tmp];
#line 146
    iin ++;
#line 147
    iout ++;
#line 149
    if ((size_t )iout >= *buflen) {
#line 150
      goto while_break;
    } else
#line 149
    if ((size_t )iin >= size) {
#line 150
      goto while_break;
    }
#line 151
    if ((size_t )(iin + 1) < size) {
#line 151
      tmp___0 = ((int )*(udata + (iin + 1)) & 248) >> 3;
    } else {
#line 151
      tmp___0 = 0;
    }
#line 151
    *(ubuf + iout) = (unsigned char )cb128___0[(((int )*(udata + iin) & 3) << 5) | tmp___0];
#line 154
    iin ++;
#line 155
    iout ++;
#line 157
    if ((size_t )iout >= *buflen) {
#line 158
      goto while_break;
    } else
#line 157
    if ((size_t )iin >= size) {
#line 158
      goto while_break;
    }
#line 159
    if ((size_t )(iin + 1) < size) {
#line 159
      tmp___1 = ((int )*(udata + (iin + 1)) & 240) >> 4;
    } else {
#line 159
      tmp___1 = 0;
    }
#line 159
    *(ubuf + iout) = (unsigned char )cb128___0[(((int )*(udata + iin) & 7) << 4) | tmp___1];
#line 162
    iin ++;
#line 163
    iout ++;
#line 165
    if ((size_t )iout >= *buflen) {
#line 166
      goto while_break;
    } else
#line 165
    if ((size_t )iin >= size) {
#line 166
      goto while_break;
    }
#line 167
    if ((size_t )(iin + 1) < size) {
#line 167
      tmp___2 = ((int )*(udata + (iin + 1)) & 224) >> 5;
    } else {
#line 167
      tmp___2 = 0;
    }
#line 167
    *(ubuf + iout) = (unsigned char )cb128___0[(((int )*(udata + iin) & 15) << 3) | tmp___2];
#line 170
    iin ++;
#line 171
    iout ++;
#line 173
    if ((size_t )iout >= *buflen) {
#line 174
      goto while_break;
    } else
#line 173
    if ((size_t )iin >= size) {
#line 174
      goto while_break;
    }
#line 175
    if ((size_t )(iin + 1) < size) {
#line 175
      tmp___3 = ((int )*(udata + (iin + 1)) & 192) >> 6;
    } else {
#line 175
      tmp___3 = 0;
    }
#line 175
    *(ubuf + iout) = (unsigned char )cb128___0[(((int )*(udata + iin) & 31) << 2) | tmp___3];
#line 178
    iin ++;
#line 179
    iout ++;
#line 181
    if ((size_t )iout >= *buflen) {
#line 182
      goto while_break;
    } else
#line 181
    if ((size_t )iin >= size) {
#line 182
      goto while_break;
    }
#line 183
    if ((size_t )(iin + 1) < size) {
#line 183
      tmp___4 = ((int )*(udata + (iin + 1)) & 128) >> 7;
    } else {
#line 183
      tmp___4 = 0;
    }
#line 183
    *(ubuf + iout) = (unsigned char )cb128___0[(((int )*(udata + iin) & 63) << 1) | tmp___4];
#line 186
    iin ++;
#line 187
    iout ++;
#line 189
    if ((size_t )iout >= *buflen) {
#line 190
      goto while_break;
    } else
#line 189
    if ((size_t )iin >= size) {
#line 190
      goto while_break;
    }
#line 191
    *(ubuf + iout) = (unsigned char )cb128___0[(int )*(udata + iin) & 127];
#line 192
    iin ++;
#line 193
    iout ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 196
  *(ubuf + iout) = (unsigned char )'\000';
#line 199
  *buflen = (size_t )iin;
#line 201
  return (iout);
}
}
#line 206 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base128.c"
static int base128_decode___0(void *buf , size_t *buflen , char const   *str , size_t slen ) 
{ 
  unsigned char *ustr ;
  unsigned char *ubuf ;
  int iout ;
  int iin ;

  {
  {
#line 220
  ustr = (unsigned char *)str;
#line 221
  ubuf = (unsigned char *)buf;
#line 222
  iout = 0;
#line 223
  iin = 0;
#line 225
  base128_reverse_init___0();
  }
  {
#line 230
  while (1) {
    while_continue: /* CIL Label */ ;
#line 231
    if ((size_t )iout >= *buflen) {
#line 233
      goto while_break;
    } else
#line 231
    if ((size_t )(iin + 1) >= slen) {
#line 233
      goto while_break;
    } else
#line 231
    if ((int const   )*(str + iin) == 0) {
#line 233
      goto while_break;
    } else
#line 231
    if ((int const   )*(str + (iin + 1)) == 0) {
#line 233
      goto while_break;
    }
#line 234
    *(ubuf + iout) = (unsigned char )((((int )rev128___0[(int )*(ustr + iin)] & 127) << 1) | (((int )rev128___0[(int )*(ustr + (iin + 1))] & 64) >> 6));
#line 236
    iin ++;
#line 237
    iout ++;
#line 239
    if ((size_t )iout >= *buflen) {
#line 241
      goto while_break;
    } else
#line 239
    if ((size_t )(iin + 1) >= slen) {
#line 241
      goto while_break;
    } else
#line 239
    if ((int const   )*(str + iin) == 0) {
#line 241
      goto while_break;
    } else
#line 239
    if ((int const   )*(str + (iin + 1)) == 0) {
#line 241
      goto while_break;
    }
#line 242
    *(ubuf + iout) = (unsigned char )((((int )rev128___0[(int )*(ustr + iin)] & 63) << 2) | (((int )rev128___0[(int )*(ustr + (iin + 1))] & 96) >> 5));
#line 244
    iin ++;
#line 245
    iout ++;
#line 247
    if ((size_t )iout >= *buflen) {
#line 249
      goto while_break;
    } else
#line 247
    if ((size_t )(iin + 1) >= slen) {
#line 249
      goto while_break;
    } else
#line 247
    if ((int const   )*(str + iin) == 0) {
#line 249
      goto while_break;
    } else
#line 247
    if ((int const   )*(str + (iin + 1)) == 0) {
#line 249
      goto while_break;
    }
#line 250
    *(ubuf + iout) = (unsigned char )((((int )rev128___0[(int )*(ustr + iin)] & 31) << 3) | (((int )rev128___0[(int )*(ustr + (iin + 1))] & 112) >> 4));
#line 252
    iin ++;
#line 253
    iout ++;
#line 255
    if ((size_t )iout >= *buflen) {
#line 257
      goto while_break;
    } else
#line 255
    if ((size_t )(iin + 1) >= slen) {
#line 257
      goto while_break;
    } else
#line 255
    if ((int const   )*(str + iin) == 0) {
#line 257
      goto while_break;
    } else
#line 255
    if ((int const   )*(str + (iin + 1)) == 0) {
#line 257
      goto while_break;
    }
#line 258
    *(ubuf + iout) = (unsigned char )((((int )rev128___0[(int )*(ustr + iin)] & 15) << 4) | (((int )rev128___0[(int )*(ustr + (iin + 1))] & 120) >> 3));
#line 260
    iin ++;
#line 261
    iout ++;
#line 263
    if ((size_t )iout >= *buflen) {
#line 265
      goto while_break;
    } else
#line 263
    if ((size_t )(iin + 1) >= slen) {
#line 265
      goto while_break;
    } else
#line 263
    if ((int const   )*(str + iin) == 0) {
#line 265
      goto while_break;
    } else
#line 263
    if ((int const   )*(str + (iin + 1)) == 0) {
#line 265
      goto while_break;
    }
#line 266
    *(ubuf + iout) = (unsigned char )((((int )rev128___0[(int )*(ustr + iin)] & 7) << 5) | (((int )rev128___0[(int )*(ustr + (iin + 1))] & 124) >> 2));
#line 268
    iin ++;
#line 269
    iout ++;
#line 271
    if ((size_t )iout >= *buflen) {
#line 273
      goto while_break;
    } else
#line 271
    if ((size_t )(iin + 1) >= slen) {
#line 273
      goto while_break;
    } else
#line 271
    if ((int const   )*(str + iin) == 0) {
#line 273
      goto while_break;
    } else
#line 271
    if ((int const   )*(str + (iin + 1)) == 0) {
#line 273
      goto while_break;
    }
#line 274
    *(ubuf + iout) = (unsigned char )((((int )rev128___0[(int )*(ustr + iin)] & 3) << 6) | (((int )rev128___0[(int )*(ustr + (iin + 1))] & 126) >> 1));
#line 276
    iin ++;
#line 277
    iout ++;
#line 279
    if ((size_t )iout >= *buflen) {
#line 281
      goto while_break;
    } else
#line 279
    if ((size_t )(iin + 1) >= slen) {
#line 281
      goto while_break;
    } else
#line 279
    if ((int const   )*(str + iin) == 0) {
#line 281
      goto while_break;
    } else
#line 279
    if ((int const   )*(str + (iin + 1)) == 0) {
#line 281
      goto while_break;
    }
#line 282
    *(ubuf + iout) = (unsigned char )((((int )rev128___0[(int )*(ustr + iin)] & 1) << 7) | ((int )rev128___0[(int )*(ustr + (iin + 1))] & 127));
#line 284
    iin += 2;
#line 285
    iout ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 288
  *(ubuf + iout) = (unsigned char )'\000';
#line 290
  return (iout);
}
}
#line 154 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/md5.c"
static void md5_process___0(md5_state_t *pms , md5_byte_t const   *data ) ;
#line 154 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/md5.c"
static int const   w___0  =    (int const   )1;
#line 131 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/md5.c"
static void md5_process___0(md5_state_t *pms , md5_byte_t const   *data ) 
{ 
  md5_word_t a ;
  md5_word_t b ;
  md5_word_t c ;
  md5_word_t d ;
  md5_word_t t ;
  md5_word_t xbuf[16] ;
  md5_word_t const   *X ;
  md5_byte_t const   *xp ;
  int i ;

  {
#line 134
  a = pms->abcd[0];
#line 134
  b = pms->abcd[1];
#line 134
  c = pms->abcd[2];
#line 134
  d = pms->abcd[3];
#line 156
  if (*((md5_byte_t const   *)(& w___0))) {
#line 164
    if (! ((data - (md5_byte_t const   *)0) & 3L)) {
#line 166
      X = (md5_word_t const   *)data;
    } else {
      {
#line 169
      memcpy((void */* __restrict  */)(xbuf), (void const   */* __restrict  */)data,
             (size_t )64);
#line 170
      X = (md5_word_t const   *)(xbuf);
      }
    }
  } else {
#line 183
    xp = data;
#line 187
    X = (md5_word_t const   *)(xbuf);
#line 191
    i = 0;
    {
#line 191
    while (1) {
      while_continue: /* CIL Label */ ;
#line 191
      if (! (i < 16)) {
#line 191
        goto while_break;
      }
#line 192
      xbuf[i] = (md5_word_t )((((int const   )*(xp + 0) + ((int const   )*(xp + 1) << 8)) + ((int const   )*(xp + 2) << 16)) + ((int const   )*(xp + 3) << 24));
#line 191
      i ++;
#line 191
      xp += 4;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 207
  t = ((a + ((b & c) | (~ b & d))) + (md5_word_t )*(X + 0)) + 3614090360U;
#line 207
  a = ((t << 7) | (t >> 25)) + b;
#line 208
  t = ((d + ((a & b) | (~ a & c))) + (md5_word_t )*(X + 1)) + 3905402710U;
#line 208
  d = ((t << 12) | (t >> 20)) + a;
#line 209
  t = ((c + ((d & a) | (~ d & b))) + (md5_word_t )*(X + 2)) + 606105819U;
#line 209
  c = ((t << 17) | (t >> 15)) + d;
#line 210
  t = ((b + ((c & d) | (~ c & a))) + (md5_word_t )*(X + 3)) + 3250441966U;
#line 210
  b = ((t << 22) | (t >> 10)) + c;
#line 211
  t = ((a + ((b & c) | (~ b & d))) + (md5_word_t )*(X + 4)) + 4118548399U;
#line 211
  a = ((t << 7) | (t >> 25)) + b;
#line 212
  t = ((d + ((a & b) | (~ a & c))) + (md5_word_t )*(X + 5)) + 1200080426U;
#line 212
  d = ((t << 12) | (t >> 20)) + a;
#line 213
  t = ((c + ((d & a) | (~ d & b))) + (md5_word_t )*(X + 6)) + 2821735955U;
#line 213
  c = ((t << 17) | (t >> 15)) + d;
#line 214
  t = ((b + ((c & d) | (~ c & a))) + (md5_word_t )*(X + 7)) + 4249261313U;
#line 214
  b = ((t << 22) | (t >> 10)) + c;
#line 215
  t = ((a + ((b & c) | (~ b & d))) + (md5_word_t )*(X + 8)) + 1770035416U;
#line 215
  a = ((t << 7) | (t >> 25)) + b;
#line 216
  t = ((d + ((a & b) | (~ a & c))) + (md5_word_t )*(X + 9)) + 2336552879U;
#line 216
  d = ((t << 12) | (t >> 20)) + a;
#line 217
  t = ((c + ((d & a) | (~ d & b))) + (md5_word_t )*(X + 10)) + 4294925233U;
#line 217
  c = ((t << 17) | (t >> 15)) + d;
#line 218
  t = ((b + ((c & d) | (~ c & a))) + (md5_word_t )*(X + 11)) + 2304563134U;
#line 218
  b = ((t << 22) | (t >> 10)) + c;
#line 219
  t = ((a + ((b & c) | (~ b & d))) + (md5_word_t )*(X + 12)) + 1804603682U;
#line 219
  a = ((t << 7) | (t >> 25)) + b;
#line 220
  t = ((d + ((a & b) | (~ a & c))) + (md5_word_t )*(X + 13)) + 4254626195U;
#line 220
  d = ((t << 12) | (t >> 20)) + a;
#line 221
  t = ((c + ((d & a) | (~ d & b))) + (md5_word_t )*(X + 14)) + 2792965006U;
#line 221
  c = ((t << 17) | (t >> 15)) + d;
#line 222
  t = ((b + ((c & d) | (~ c & a))) + (md5_word_t )*(X + 15)) + 1236535329U;
#line 222
  b = ((t << 22) | (t >> 10)) + c;
#line 233
  t = ((a + ((b & d) | (c & ~ d))) + (md5_word_t )*(X + 1)) + 4129170786U;
#line 233
  a = ((t << 5) | (t >> 27)) + b;
#line 234
  t = ((d + ((a & c) | (b & ~ c))) + (md5_word_t )*(X + 6)) + 3225465664U;
#line 234
  d = ((t << 9) | (t >> 23)) + a;
#line 235
  t = ((c + ((d & b) | (a & ~ b))) + (md5_word_t )*(X + 11)) + 643717713U;
#line 235
  c = ((t << 14) | (t >> 18)) + d;
#line 236
  t = ((b + ((c & a) | (d & ~ a))) + (md5_word_t )*(X + 0)) + 3921069994U;
#line 236
  b = ((t << 20) | (t >> 12)) + c;
#line 237
  t = ((a + ((b & d) | (c & ~ d))) + (md5_word_t )*(X + 5)) + 3593408605U;
#line 237
  a = ((t << 5) | (t >> 27)) + b;
#line 238
  t = ((d + ((a & c) | (b & ~ c))) + (md5_word_t )*(X + 10)) + 38016083U;
#line 238
  d = ((t << 9) | (t >> 23)) + a;
#line 239
  t = ((c + ((d & b) | (a & ~ b))) + (md5_word_t )*(X + 15)) + 3634488961U;
#line 239
  c = ((t << 14) | (t >> 18)) + d;
#line 240
  t = ((b + ((c & a) | (d & ~ a))) + (md5_word_t )*(X + 4)) + 3889429448U;
#line 240
  b = ((t << 20) | (t >> 12)) + c;
#line 241
  t = ((a + ((b & d) | (c & ~ d))) + (md5_word_t )*(X + 9)) + 568446438U;
#line 241
  a = ((t << 5) | (t >> 27)) + b;
#line 242
  t = ((d + ((a & c) | (b & ~ c))) + (md5_word_t )*(X + 14)) + 3275163606U;
#line 242
  d = ((t << 9) | (t >> 23)) + a;
#line 243
  t = ((c + ((d & b) | (a & ~ b))) + (md5_word_t )*(X + 3)) + 4107603335U;
#line 243
  c = ((t << 14) | (t >> 18)) + d;
#line 244
  t = ((b + ((c & a) | (d & ~ a))) + (md5_word_t )*(X + 8)) + 1163531501U;
#line 244
  b = ((t << 20) | (t >> 12)) + c;
#line 245
  t = ((a + ((b & d) | (c & ~ d))) + (md5_word_t )*(X + 13)) + 2850285829U;
#line 245
  a = ((t << 5) | (t >> 27)) + b;
#line 246
  t = ((d + ((a & c) | (b & ~ c))) + (md5_word_t )*(X + 2)) + 4243563512U;
#line 246
  d = ((t << 9) | (t >> 23)) + a;
#line 247
  t = ((c + ((d & b) | (a & ~ b))) + (md5_word_t )*(X + 7)) + 1735328473U;
#line 247
  c = ((t << 14) | (t >> 18)) + d;
#line 248
  t = ((b + ((c & a) | (d & ~ a))) + (md5_word_t )*(X + 12)) + 2368359562U;
#line 248
  b = ((t << 20) | (t >> 12)) + c;
#line 259
  t = ((a + ((b ^ c) ^ d)) + (md5_word_t )*(X + 5)) + 4294588738U;
#line 259
  a = ((t << 4) | (t >> 28)) + b;
#line 260
  t = ((d + ((a ^ b) ^ c)) + (md5_word_t )*(X + 8)) + 2272392833U;
#line 260
  d = ((t << 11) | (t >> 21)) + a;
#line 261
  t = ((c + ((d ^ a) ^ b)) + (md5_word_t )*(X + 11)) + 1839030562U;
#line 261
  c = ((t << 16) | (t >> 16)) + d;
#line 262
  t = ((b + ((c ^ d) ^ a)) + (md5_word_t )*(X + 14)) + 4259657740U;
#line 262
  b = ((t << 23) | (t >> 9)) + c;
#line 263
  t = ((a + ((b ^ c) ^ d)) + (md5_word_t )*(X + 1)) + 2763975236U;
#line 263
  a = ((t << 4) | (t >> 28)) + b;
#line 264
  t = ((d + ((a ^ b) ^ c)) + (md5_word_t )*(X + 4)) + 1272893353U;
#line 264
  d = ((t << 11) | (t >> 21)) + a;
#line 265
  t = ((c + ((d ^ a) ^ b)) + (md5_word_t )*(X + 7)) + 4139469664U;
#line 265
  c = ((t << 16) | (t >> 16)) + d;
#line 266
  t = ((b + ((c ^ d) ^ a)) + (md5_word_t )*(X + 10)) + 3200236656U;
#line 266
  b = ((t << 23) | (t >> 9)) + c;
#line 267
  t = ((a + ((b ^ c) ^ d)) + (md5_word_t )*(X + 13)) + 681279174U;
#line 267
  a = ((t << 4) | (t >> 28)) + b;
#line 268
  t = ((d + ((a ^ b) ^ c)) + (md5_word_t )*(X + 0)) + 3936430074U;
#line 268
  d = ((t << 11) | (t >> 21)) + a;
#line 269
  t = ((c + ((d ^ a) ^ b)) + (md5_word_t )*(X + 3)) + 3572445317U;
#line 269
  c = ((t << 16) | (t >> 16)) + d;
#line 270
  t = ((b + ((c ^ d) ^ a)) + (md5_word_t )*(X + 6)) + 76029189U;
#line 270
  b = ((t << 23) | (t >> 9)) + c;
#line 271
  t = ((a + ((b ^ c) ^ d)) + (md5_word_t )*(X + 9)) + 3654602809U;
#line 271
  a = ((t << 4) | (t >> 28)) + b;
#line 272
  t = ((d + ((a ^ b) ^ c)) + (md5_word_t )*(X + 12)) + 3873151461U;
#line 272
  d = ((t << 11) | (t >> 21)) + a;
#line 273
  t = ((c + ((d ^ a) ^ b)) + (md5_word_t )*(X + 15)) + 530742520U;
#line 273
  c = ((t << 16) | (t >> 16)) + d;
#line 274
  t = ((b + ((c ^ d) ^ a)) + (md5_word_t )*(X + 2)) + 3299628645U;
#line 274
  b = ((t << 23) | (t >> 9)) + c;
#line 285
  t = ((a + (c ^ (b | ~ d))) + (md5_word_t )*(X + 0)) + 4096336452U;
#line 285
  a = ((t << 6) | (t >> 26)) + b;
#line 286
  t = ((d + (b ^ (a | ~ c))) + (md5_word_t )*(X + 7)) + 1126891415U;
#line 286
  d = ((t << 10) | (t >> 22)) + a;
#line 287
  t = ((c + (a ^ (d | ~ b))) + (md5_word_t )*(X + 14)) + 2878612391U;
#line 287
  c = ((t << 15) | (t >> 17)) + d;
#line 288
  t = ((b + (d ^ (c | ~ a))) + (md5_word_t )*(X + 5)) + 4237533241U;
#line 288
  b = ((t << 21) | (t >> 11)) + c;
#line 289
  t = ((a + (c ^ (b | ~ d))) + (md5_word_t )*(X + 12)) + 1700485571U;
#line 289
  a = ((t << 6) | (t >> 26)) + b;
#line 290
  t = ((d + (b ^ (a | ~ c))) + (md5_word_t )*(X + 3)) + 2399980690U;
#line 290
  d = ((t << 10) | (t >> 22)) + a;
#line 291
  t = ((c + (a ^ (d | ~ b))) + (md5_word_t )*(X + 10)) + 4293915773U;
#line 291
  c = ((t << 15) | (t >> 17)) + d;
#line 292
  t = ((b + (d ^ (c | ~ a))) + (md5_word_t )*(X + 1)) + 2240044497U;
#line 292
  b = ((t << 21) | (t >> 11)) + c;
#line 293
  t = ((a + (c ^ (b | ~ d))) + (md5_word_t )*(X + 8)) + 1873313359U;
#line 293
  a = ((t << 6) | (t >> 26)) + b;
#line 294
  t = ((d + (b ^ (a | ~ c))) + (md5_word_t )*(X + 15)) + 4264355552U;
#line 294
  d = ((t << 10) | (t >> 22)) + a;
#line 295
  t = ((c + (a ^ (d | ~ b))) + (md5_word_t )*(X + 6)) + 2734768916U;
#line 295
  c = ((t << 15) | (t >> 17)) + d;
#line 296
  t = ((b + (d ^ (c | ~ a))) + (md5_word_t )*(X + 13)) + 1309151649U;
#line 296
  b = ((t << 21) | (t >> 11)) + c;
#line 297
  t = ((a + (c ^ (b | ~ d))) + (md5_word_t )*(X + 4)) + 4149444226U;
#line 297
  a = ((t << 6) | (t >> 26)) + b;
#line 298
  t = ((d + (b ^ (a | ~ c))) + (md5_word_t )*(X + 11)) + 3174756917U;
#line 298
  d = ((t << 10) | (t >> 22)) + a;
#line 299
  t = ((c + (a ^ (d | ~ b))) + (md5_word_t )*(X + 2)) + 718787259U;
#line 299
  c = ((t << 15) | (t >> 17)) + d;
#line 300
  t = ((b + (d ^ (c | ~ a))) + (md5_word_t )*(X + 9)) + 3951481745U;
#line 300
  b = ((t << 21) | (t >> 11)) + c;
#line 306
  pms->abcd[0] += a;
#line 307
  pms->abcd[1] += b;
#line 308
  pms->abcd[2] += c;
#line 309
  pms->abcd[3] += d;
#line 310
  return;
}
}
#line 363 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/md5.c"
static md5_byte_t const   pad___0[64]  = 
#line 363
  {      (md5_byte_t const   )128,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0};
#line 31 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base64u.c"
static char const   cb64___2[65]  = 
#line 31 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base64u.c"
  {      (char const   )'a',      (char const   )'b',      (char const   )'c',      (char const   )'d', 
        (char const   )'e',      (char const   )'f',      (char const   )'g',      (char const   )'h', 
        (char const   )'i',      (char const   )'j',      (char const   )'k',      (char const   )'l', 
        (char const   )'m',      (char const   )'n',      (char const   )'o',      (char const   )'p', 
        (char const   )'q',      (char const   )'r',      (char const   )'s',      (char const   )'t', 
        (char const   )'u',      (char const   )'v',      (char const   )'w',      (char const   )'x', 
        (char const   )'y',      (char const   )'z',      (char const   )'A',      (char const   )'B', 
        (char const   )'C',      (char const   )'D',      (char const   )'E',      (char const   )'F', 
        (char const   )'G',      (char const   )'H',      (char const   )'I',      (char const   )'J', 
        (char const   )'K',      (char const   )'L',      (char const   )'M',      (char const   )'N', 
        (char const   )'O',      (char const   )'P',      (char const   )'Q',      (char const   )'R', 
        (char const   )'S',      (char const   )'T',      (char const   )'U',      (char const   )'V', 
        (char const   )'W',      (char const   )'X',      (char const   )'Y',      (char const   )'Z', 
        (char const   )'-',      (char const   )'0',      (char const   )'1',      (char const   )'2', 
        (char const   )'3',      (char const   )'4',      (char const   )'5',      (char const   )'6', 
        (char const   )'7',      (char const   )'8',      (char const   )'9',      (char const   )'_', 
        (char const   )'\000'};
#line 33 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base64u.c"
static unsigned char rev64___2[256]  ;
#line 34 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base64u.c"
static int reverse_init___6  =    0;
#line 36
static int base64u_encode___0(char *buf , size_t *buflen , void const   *data , size_t size ) ;
#line 37
static int base64u_decode___0(void *buf , size_t *buflen , char const   *str , size_t slen ) ;
#line 38
static int base64u_handles_dots___0(void) ;
#line 39
static int base64u_blksize_raw___0(void) ;
#line 40
static int base64u_blksize_enc___0(void) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base64u.c"
static struct encoder base64u_encoder___0  =    {{(char )'B', (char )'a', (char )'s', (char )'e', (char )'6', (char )'4', (char )'u',
     (char )'\000'}, & base64u_encode___0, & base64u_decode___0, & base64u_handles_dots___0,
    & base64u_handles_dots___0, & base64u_blksize_raw___0, & base64u_blksize_enc___0};
#line 59 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base64u.c"
static int base64u_handles_dots___0(void) 
{ 


  {
#line 62
  return (0);
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base64u.c"
static int base64u_blksize_raw___0(void) 
{ 


  {
#line 68
  return (3);
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base64u.c"
static int base64u_blksize_enc___0(void) 
{ 


  {
#line 74
  return (4);
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base64u.c"
__inline static void base64u_reverse_init___0(void) 
{ 
  int i ;
  unsigned char c ;

  {
#line 83
  if (! reverse_init___6) {
    {
#line 84
    memset((void *)(rev64___2), 0, (size_t )256);
#line 85
    i = 0;
    }
    {
#line 85
    while (1) {
      while_continue: /* CIL Label */ ;
#line 85
      if (! (i < 64)) {
#line 85
        goto while_break;
      }
#line 86
      c = (unsigned char )cb64___2[i];
#line 87
      rev64___2[(int )c] = (unsigned char )i;
#line 85
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 89
    reverse_init___6 = 1;
  }
#line 91
  return;
}
}
#line 93 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base64u.c"
static int base64u_encode___0(char *buf , size_t *buflen , void const   *data , size_t size ) 
{ 
  unsigned char *udata ;
  int iout ;
  int iin ;
  int tmp ;
  int tmp___0 ;

  {
#line 105
  udata = (unsigned char *)data;
#line 106
  iout = 0;
#line 107
  iin = 0;
  {
#line 113
  while (1) {
    while_continue: /* CIL Label */ ;
#line 114
    if ((size_t )iout >= *buflen) {
#line 115
      goto while_break;
    } else
#line 114
    if ((size_t )iin >= size) {
#line 115
      goto while_break;
    }
#line 116
    *(buf + iout) = (char )cb64___2[((int )*(udata + iin) & 252) >> 2];
#line 117
    iout ++;
#line 119
    if ((size_t )iout >= *buflen) {
#line 120
      iout --;
#line 121
      goto while_break;
    } else
#line 119
    if ((size_t )iin >= size) {
#line 120
      iout --;
#line 121
      goto while_break;
    }
#line 123
    if ((size_t )(iin + 1) < size) {
#line 123
      tmp = ((int )*(udata + (iin + 1)) & 240) >> 4;
    } else {
#line 123
      tmp = 0;
    }
#line 123
    *(buf + iout) = (char )cb64___2[(((int )*(udata + iin) & 3) << 4) | tmp];
#line 126
    iin ++;
#line 127
    iout ++;
#line 129
    if ((size_t )iout >= *buflen) {
#line 130
      goto while_break;
    } else
#line 129
    if ((size_t )iin >= size) {
#line 130
      goto while_break;
    }
#line 131
    if ((size_t )(iin + 1) < size) {
#line 131
      tmp___0 = ((int )*(udata + (iin + 1)) & 192) >> 6;
    } else {
#line 131
      tmp___0 = 0;
    }
#line 131
    *(buf + iout) = (char )cb64___2[(((int )*(udata + iin) & 15) << 2) | tmp___0];
#line 134
    iin ++;
#line 135
    iout ++;
#line 137
    if ((size_t )iout >= *buflen) {
#line 138
      goto while_break;
    } else
#line 137
    if ((size_t )iin >= size) {
#line 138
      goto while_break;
    }
#line 139
    *(buf + iout) = (char )cb64___2[(int )*(udata + iin) & 63];
#line 140
    iin ++;
#line 141
    iout ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 144
  *(buf + iout) = (char )'\000';
#line 147
  *buflen = (size_t )iin;
#line 149
  return (iout);
}
}
#line 154 "/home/june/repo/benchmarks/collector/temp/iodine-0.6.0~rc1/src/base64u.c"
static int base64u_decode___0(void *buf , size_t *buflen , char const   *str , size_t slen ) 
{ 
  unsigned char *ubuf ;
  int iout ;
  int iin ;

  {
  {
#line 168
  ubuf = (unsigned char *)buf;
#line 169
  iout = 0;
#line 170
  iin = 0;
#line 172
  base64u_reverse_init___0();
  }
  {
#line 177
  while (1) {
    while_continue: /* CIL Label */ ;
#line 178
    if ((size_t )iout >= *buflen) {
#line 180
      goto while_break;
    } else
#line 178
    if ((size_t )(iin + 1) >= slen) {
#line 180
      goto while_break;
    } else
#line 178
    if ((int const   )*(str + iin) == 0) {
#line 180
      goto while_break;
    } else
#line 178
    if ((int const   )*(str + (iin + 1)) == 0) {
#line 180
      goto while_break;
    }
#line 181
    *(ubuf + iout) = (unsigned char )((((int )rev64___2[(int )*(str + iin)] & 63) << 2) | (((int )rev64___2[(int )*(str + (iin + 1))] & 48) >> 4));
#line 183
    iin ++;
#line 184
    iout ++;
#line 186
    if ((size_t )iout >= *buflen) {
#line 188
      goto while_break;
    } else
#line 186
    if ((size_t )(iin + 1) >= slen) {
#line 188
      goto while_break;
    } else
#line 186
    if ((int const   )*(str + iin) == 0) {
#line 188
      goto while_break;
    } else
#line 186
    if ((int const   )*(str + (iin + 1)) == 0) {
#line 188
      goto while_break;
    }
#line 189
    *(ubuf + iout) = (unsigned char )((((int )rev64___2[(int )*(str + iin)] & 15) << 4) | (((int )rev64___2[(int )*(str + (iin + 1))] & 60) >> 2));
#line 191
    iin ++;
#line 192
    iout ++;
#line 194
    if ((size_t )iout >= *buflen) {
#line 196
      goto while_break;
    } else
#line 194
    if ((size_t )(iin + 1) >= slen) {
#line 196
      goto while_break;
    } else
#line 194
    if ((int const   )*(str + iin) == 0) {
#line 196
      goto while_break;
    } else
#line 194
    if ((int const   )*(str + (iin + 1)) == 0) {
#line 196
      goto while_break;
    }
#line 197
    *(ubuf + iout) = (unsigned char )((((int )rev64___2[(int )*(str + iin)] & 3) << 6) | ((int )rev64___2[(int )*(str + (iin + 1))] & 63));
#line 199
    iin += 2;
#line 200
    iout ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 203
  *(ubuf + iout) = (unsigned char )'\000';
#line 205
  return (iout);
}
}
