/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 183 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef char *__caddr_t;
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 107 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct itimerval {
   struct timeval it_interval ;
   struct timeval it_value ;
};
#line 120 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef int __itimer_which_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 116 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __caddr_t caddr_t;
#line 66 "/usr/include/X11/X.h"
typedef unsigned long XID;
#line 74 "/usr/include/X11/X.h"
typedef unsigned long Atom;
#line 76 "/usr/include/X11/X.h"
typedef unsigned long VisualID;
#line 77 "/usr/include/X11/X.h"
typedef unsigned long Time;
#line 96 "/usr/include/X11/X.h"
typedef XID Window;
#line 97 "/usr/include/X11/X.h"
typedef XID Drawable;
#line 100 "/usr/include/X11/X.h"
typedef XID Font;
#line 102 "/usr/include/X11/X.h"
typedef XID Pixmap;
#line 103 "/usr/include/X11/X.h"
typedef XID Cursor;
#line 104 "/usr/include/X11/X.h"
typedef XID Colormap;
#line 106 "/usr/include/X11/X.h"
typedef XID KeySym;
#line 92 "/usr/include/X11/Xlib.h"
typedef char *XPointer;
#line 160 "/usr/include/X11/Xlib.h"
struct _XExtData {
   int number ;
   struct _XExtData *next ;
   int (*free_private)(struct _XExtData *extension ) ;
   XPointer private_data ;
};
#line 160 "/usr/include/X11/Xlib.h"
typedef struct _XExtData XExtData;
#line 193 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGCValues_51 {
   int function ;
   unsigned long plane_mask ;
   unsigned long foreground ;
   unsigned long background ;
   int line_width ;
   int line_style ;
   int cap_style ;
   int join_style ;
   int fill_style ;
   int fill_rule ;
   int arc_mode ;
   Pixmap tile ;
   Pixmap stipple ;
   int ts_x_origin ;
   int ts_y_origin ;
   Font font ;
   int subwindow_mode ;
   int graphics_exposures ;
   int clip_x_origin ;
   int clip_y_origin ;
   Pixmap clip_mask ;
   int dash_offset ;
   char dashes ;
};
#line 193 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGCValues_51 XGCValues;
#line 226
struct _XGC;
#line 226 "/usr/include/X11/Xlib.h"
typedef struct _XGC *GC;
#line 239 "/usr/include/X11/Xlib.h"
struct __anonstruct_Visual_52 {
   XExtData *ext_data ;
   VisualID visualid ;
   int class ;
   unsigned long red_mask ;
   unsigned long green_mask ;
   unsigned long blue_mask ;
   int bits_per_rgb ;
   int map_entries ;
};
#line 239 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_Visual_52 Visual;
#line 255 "/usr/include/X11/Xlib.h"
struct __anonstruct_Depth_53 {
   int depth ;
   int nvisuals ;
   Visual *visuals ;
};
#line 255 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_Depth_53 Depth;
#line 267
struct _XDisplay;
#line 269 "/usr/include/X11/Xlib.h"
struct __anonstruct_Screen_54 {
   XExtData *ext_data ;
   struct _XDisplay *display ;
   Window root ;
   int width ;
   int height ;
   int mwidth ;
   int mheight ;
   int ndepths ;
   Depth *depths ;
   int root_depth ;
   Visual *root_visual ;
   GC default_gc ;
   Colormap cmap ;
   unsigned long white_pixel ;
   unsigned long black_pixel ;
   int max_maps ;
   int min_maps ;
   int backing_store ;
   int save_unders ;
   long root_input_mask ;
};
#line 269 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_Screen_54 Screen;
#line 292 "/usr/include/X11/Xlib.h"
struct __anonstruct_ScreenFormat_55 {
   XExtData *ext_data ;
   int depth ;
   int bits_per_pixel ;
   int scanline_pad ;
};
#line 292 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_ScreenFormat_55 ScreenFormat;
#line 302 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSetWindowAttributes_56 {
   Pixmap background_pixmap ;
   unsigned long background_pixel ;
   Pixmap border_pixmap ;
   unsigned long border_pixel ;
   int bit_gravity ;
   int win_gravity ;
   int backing_store ;
   unsigned long backing_planes ;
   unsigned long backing_pixel ;
   int save_under ;
   long event_mask ;
   long do_not_propagate_mask ;
   int override_redirect ;
   Colormap colormap ;
   Cursor cursor ;
};
#line 302 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSetWindowAttributes_56 XSetWindowAttributes;
#line 422 "/usr/include/X11/Xlib.h"
struct __anonstruct_XColor_61 {
   unsigned long pixel ;
   unsigned short red ;
   unsigned short green ;
   unsigned short blue ;
   char flags ;
   char pad ;
};
#line 422 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XColor_61 XColor;
#line 438 "/usr/include/X11/Xlib.h"
struct __anonstruct_XPoint_63 {
   short x ;
   short y ;
};
#line 438 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XPoint_63 XPoint;
#line 499 "/usr/include/X11/Xlib.h"
typedef struct _XDisplay Display;
#line 502
struct _XPrivate;
#line 503
struct _XrmHashBucketRec;
#line 505 "/usr/include/X11/Xlib.h"
struct __anonstruct__XPrivDisplay_70 {
   XExtData *ext_data ;
   struct _XPrivate *private1 ;
   int fd ;
   int private2 ;
   int proto_major_version ;
   int proto_minor_version ;
   char *vendor ;
   XID private3 ;
   XID private4 ;
   XID private5 ;
   int private6 ;
   XID (*resource_alloc)(struct _XDisplay * ) ;
   int byte_order ;
   int bitmap_unit ;
   int bitmap_pad ;
   int bitmap_bit_order ;
   int nformats ;
   ScreenFormat *pixmap_format ;
   int private8 ;
   int release ;
   struct _XPrivate *private9 ;
   struct _XPrivate *private10 ;
   int qlen ;
   unsigned long last_request_read ;
   unsigned long request ;
   XPointer private11 ;
   XPointer private12 ;
   XPointer private13 ;
   XPointer private14 ;
   unsigned int max_request_size ;
   struct _XrmHashBucketRec *db ;
   int (*private15)(struct _XDisplay * ) ;
   char *display_name ;
   int default_screen ;
   int nscreens ;
   Screen *screens ;
   unsigned long motion_buffer ;
   unsigned long private16 ;
   int min_keycode ;
   int max_keycode ;
   XPointer private17 ;
   XPointer private18 ;
   int private19 ;
   char *xdefaults ;
};
#line 505 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct__XPrivDisplay_70 *_XPrivDisplay;
#line 569 "/usr/include/X11/Xlib.h"
struct __anonstruct_XKeyEvent_71 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   unsigned int state ;
   unsigned int keycode ;
   int same_screen ;
};
#line 569 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XKeyEvent_71 XKeyEvent;
#line 587 "/usr/include/X11/Xlib.h"
struct __anonstruct_XButtonEvent_72 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   unsigned int state ;
   unsigned int button ;
   int same_screen ;
};
#line 587 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XButtonEvent_72 XButtonEvent;
#line 605 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMotionEvent_73 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   unsigned int state ;
   char is_hint ;
   int same_screen ;
};
#line 605 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMotionEvent_73 XMotionEvent;
#line 622 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCrossingEvent_74 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   int mode ;
   int detail ;
   int same_screen ;
   int focus ;
   unsigned int state ;
};
#line 622 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCrossingEvent_74 XCrossingEvent;
#line 646 "/usr/include/X11/Xlib.h"
struct __anonstruct_XFocusChangeEvent_75 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int mode ;
   int detail ;
};
#line 646 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XFocusChangeEvent_75 XFocusChangeEvent;
#line 665 "/usr/include/X11/Xlib.h"
struct __anonstruct_XKeymapEvent_76 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   char key_vector[32] ;
};
#line 665 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XKeymapEvent_76 XKeymapEvent;
#line 674 "/usr/include/X11/Xlib.h"
struct __anonstruct_XExposeEvent_77 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int count ;
};
#line 674 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XExposeEvent_77 XExposeEvent;
#line 685 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGraphicsExposeEvent_78 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Drawable drawable ;
   int x ;
   int y ;
   int width ;
   int height ;
   int count ;
   int major_code ;
   int minor_code ;
};
#line 685 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGraphicsExposeEvent_78 XGraphicsExposeEvent;
#line 698 "/usr/include/X11/Xlib.h"
struct __anonstruct_XNoExposeEvent_79 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Drawable drawable ;
   int major_code ;
   int minor_code ;
};
#line 698 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XNoExposeEvent_79 XNoExposeEvent;
#line 708 "/usr/include/X11/Xlib.h"
struct __anonstruct_XVisibilityEvent_80 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int state ;
};
#line 708 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XVisibilityEvent_80 XVisibilityEvent;
#line 717 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCreateWindowEvent_81 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   int override_redirect ;
};
#line 717 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCreateWindowEvent_81 XCreateWindowEvent;
#line 730 "/usr/include/X11/Xlib.h"
struct __anonstruct_XDestroyWindowEvent_82 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
};
#line 730 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XDestroyWindowEvent_82 XDestroyWindowEvent;
#line 739 "/usr/include/X11/Xlib.h"
struct __anonstruct_XUnmapEvent_83 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int from_configure ;
};
#line 739 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XUnmapEvent_83 XUnmapEvent;
#line 749 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMapEvent_84 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int override_redirect ;
};
#line 749 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMapEvent_84 XMapEvent;
#line 759 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMapRequestEvent_85 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
};
#line 759 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMapRequestEvent_85 XMapRequestEvent;
#line 768 "/usr/include/X11/Xlib.h"
struct __anonstruct_XReparentEvent_86 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   Window parent ;
   int x ;
   int y ;
   int override_redirect ;
};
#line 768 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XReparentEvent_86 XReparentEvent;
#line 780 "/usr/include/X11/Xlib.h"
struct __anonstruct_XConfigureEvent_87 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   Window above ;
   int override_redirect ;
};
#line 780 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XConfigureEvent_87 XConfigureEvent;
#line 794 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGravityEvent_88 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int x ;
   int y ;
};
#line 794 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGravityEvent_88 XGravityEvent;
#line 804 "/usr/include/X11/Xlib.h"
struct __anonstruct_XResizeRequestEvent_89 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int width ;
   int height ;
};
#line 804 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XResizeRequestEvent_89 XResizeRequestEvent;
#line 813 "/usr/include/X11/Xlib.h"
struct __anonstruct_XConfigureRequestEvent_90 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   Window above ;
   int detail ;
   unsigned long value_mask ;
};
#line 813 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XConfigureRequestEvent_90 XConfigureRequestEvent;
#line 828 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCirculateEvent_91 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int place ;
};
#line 828 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCirculateEvent_91 XCirculateEvent;
#line 838 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCirculateRequestEvent_92 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
   int place ;
};
#line 838 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCirculateRequestEvent_92 XCirculateRequestEvent;
#line 848 "/usr/include/X11/Xlib.h"
struct __anonstruct_XPropertyEvent_93 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Atom atom ;
   Time time ;
   int state ;
};
#line 848 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XPropertyEvent_93 XPropertyEvent;
#line 859 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSelectionClearEvent_94 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Atom selection ;
   Time time ;
};
#line 859 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSelectionClearEvent_94 XSelectionClearEvent;
#line 869 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSelectionRequestEvent_95 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window owner ;
   Window requestor ;
   Atom selection ;
   Atom target ;
   Atom property ;
   Time time ;
};
#line 869 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSelectionRequestEvent_95 XSelectionRequestEvent;
#line 882 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSelectionEvent_96 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window requestor ;
   Atom selection ;
   Atom target ;
   Atom property ;
   Time time ;
};
#line 882 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSelectionEvent_96 XSelectionEvent;
#line 894 "/usr/include/X11/Xlib.h"
struct __anonstruct_XColormapEvent_97 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Colormap colormap ;
   int new ;
   int state ;
};
#line 894 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XColormapEvent_97 XColormapEvent;
#line 909 "/usr/include/X11/Xlib.h"
union __anonunion_data_99 {
   char b[20] ;
   short s[10] ;
   long l[5] ;
};
#line 909 "/usr/include/X11/Xlib.h"
struct __anonstruct_XClientMessageEvent_98 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Atom message_type ;
   int format ;
   union __anonunion_data_99 data ;
};
#line 909 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XClientMessageEvent_98 XClientMessageEvent;
#line 924 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMappingEvent_100 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int request ;
   int first_keycode ;
   int count ;
};
#line 924 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMappingEvent_100 XMappingEvent;
#line 936 "/usr/include/X11/Xlib.h"
struct __anonstruct_XErrorEvent_101 {
   int type ;
   Display *display ;
   XID resourceid ;
   unsigned long serial ;
   unsigned char error_code ;
   unsigned char request_code ;
   unsigned char minor_code ;
};
#line 936 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XErrorEvent_101 XErrorEvent;
#line 946 "/usr/include/X11/Xlib.h"
struct __anonstruct_XAnyEvent_102 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
};
#line 946 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XAnyEvent_102 XAnyEvent;
#line 960 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGenericEvent_103 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   int extension ;
   int evtype ;
};
#line 960 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGenericEvent_103 XGenericEvent;
#line 970 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGenericEventCookie_104 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   int extension ;
   int evtype ;
   unsigned int cookie ;
   void *data ;
};
#line 970 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGenericEventCookie_104 XGenericEventCookie;
#line 985 "/usr/include/X11/Xlib.h"
union _XEvent {
   int type ;
   XAnyEvent xany ;
   XKeyEvent xkey ;
   XButtonEvent xbutton ;
   XMotionEvent xmotion ;
   XCrossingEvent xcrossing ;
   XFocusChangeEvent xfocus ;
   XExposeEvent xexpose ;
   XGraphicsExposeEvent xgraphicsexpose ;
   XNoExposeEvent xnoexpose ;
   XVisibilityEvent xvisibility ;
   XCreateWindowEvent xcreatewindow ;
   XDestroyWindowEvent xdestroywindow ;
   XUnmapEvent xunmap ;
   XMapEvent xmap ;
   XMapRequestEvent xmaprequest ;
   XReparentEvent xreparent ;
   XConfigureEvent xconfigure ;
   XGravityEvent xgravity ;
   XResizeRequestEvent xresizerequest ;
   XConfigureRequestEvent xconfigurerequest ;
   XCirculateEvent xcirculate ;
   XCirculateRequestEvent xcirculaterequest ;
   XPropertyEvent xproperty ;
   XSelectionClearEvent xselectionclear ;
   XSelectionRequestEvent xselectionrequest ;
   XSelectionEvent xselection ;
   XColormapEvent xcolormap ;
   XClientMessageEvent xclient ;
   XMappingEvent xmapping ;
   XErrorEvent xerror ;
   XKeymapEvent xkeymap ;
   XGenericEvent xgeneric ;
   XGenericEventCookie xcookie ;
   long pad[24] ;
};
#line 985 "/usr/include/X11/Xlib.h"
typedef union _XEvent XEvent;
#line 1029 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCharStruct_105 {
   short lbearing ;
   short rbearing ;
   short width ;
   short ascent ;
   short descent ;
   unsigned short attributes ;
};
#line 1029 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCharStruct_105 XCharStruct;
#line 1042 "/usr/include/X11/Xlib.h"
struct __anonstruct_XFontProp_106 {
   Atom name ;
   unsigned long card32 ;
};
#line 1042 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XFontProp_106 XFontProp;
#line 1047 "/usr/include/X11/Xlib.h"
struct __anonstruct_XFontStruct_107 {
   XExtData *ext_data ;
   Font fid ;
   unsigned int direction ;
   unsigned int min_char_or_byte2 ;
   unsigned int max_char_or_byte2 ;
   unsigned int min_byte1 ;
   unsigned int max_byte1 ;
   int all_chars_exist ;
   unsigned int default_char ;
   int n_properties ;
   XFontProp *properties ;
   XCharStruct min_bounds ;
   XCharStruct max_bounds ;
   XCharStruct *per_char ;
   int ascent ;
   int descent ;
};
#line 1047 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XFontStruct_107 XFontStruct;
#line 160 "/usr/include/X11/Xresource.h"
struct __anonstruct_XrmValue_130 {
   unsigned int size ;
   XPointer addr ;
};
#line 160 "/usr/include/X11/Xresource.h"
typedef struct __anonstruct_XrmValue_130 XrmValue;
#line 175 "/usr/include/X11/Xresource.h"
typedef struct _XrmHashBucketRec *XrmDatabase;
#line 326
enum __anonenum_XrmOptionKind_131 {
    XrmoptionNoArg = 0,
    XrmoptionIsArg = 1,
    XrmoptionStickyArg = 2,
    XrmoptionSepArg = 3,
    XrmoptionResArg = 4,
    XrmoptionSkipArg = 5,
    XrmoptionSkipLine = 6,
    XrmoptionSkipNArgs = 7
} ;
#line 326 "/usr/include/X11/Xresource.h"
typedef enum __anonenum_XrmOptionKind_131 XrmOptionKind;
#line 338 "/usr/include/X11/Xresource.h"
struct __anonstruct_XrmOptionDescRec_132 {
   char *option ;
   char *specifier ;
   XrmOptionKind argKind ;
   XPointer value ;
};
#line 338 "/usr/include/X11/Xresource.h"
typedef struct __anonstruct_XrmOptionDescRec_132 XrmOptionDescRec;
#line 338 "/usr/include/X11/Xresource.h"
typedef struct __anonstruct_XrmOptionDescRec_132 *XrmOptionDescList;
#line 81 "/usr/include/X11/Xutil.h"
struct __anonstruct_min_aspect_134 {
   int x ;
   int y ;
};
#line 81 "/usr/include/X11/Xutil.h"
struct __anonstruct_XSizeHints_133 {
   long flags ;
   int x ;
   int y ;
   int width ;
   int height ;
   int min_width ;
   int min_height ;
   int max_width ;
   int max_height ;
   int width_inc ;
   int height_inc ;
   struct __anonstruct_min_aspect_134 min_aspect ;
   struct __anonstruct_min_aspect_134 max_aspect ;
   int base_width ;
   int base_height ;
   int win_gravity ;
};
#line 81 "/usr/include/X11/Xutil.h"
typedef struct __anonstruct_XSizeHints_133 XSizeHints;
#line 163 "/usr/include/X11/Xutil.h"
struct __anonstruct_XTextProperty_136 {
   unsigned char *value ;
   Atom encoding ;
   int format ;
   unsigned long nitems ;
};
#line 163 "/usr/include/X11/Xutil.h"
typedef struct __anonstruct_XTextProperty_136 XTextProperty;
#line 231 "/usr/include/X11/Xutil.h"
struct _XComposeStatus {
   XPointer compose_ptr ;
   int chars_matched ;
};
#line 231 "/usr/include/X11/Xutil.h"
typedef struct _XComposeStatus XComposeStatus;
#line 62 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.h"
struct _maxload {
   int num ;
   float load ;
   long time ;
};
#line 62 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.h"
typedef struct _maxload _maxload;
#line 69 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.h"
struct _use {
   char *path ;
   char *dev ;
   char *type ;
   long blocks ;
   long bfree ;
};
#line 69 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.h"
typedef struct _use Diskusage;
#line 77 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.h"
struct _muse {
   char *muse ;
   char *suse ;
   long shared ;
   long cached ;
   long swaptotal ;
   long swapfree ;
   long memtotal ;
   long memfree ;
};
#line 77 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.h"
typedef struct _muse Memusage;
#line 48 "/usr/include/x86_64-linux-gnu/sys/utsname.h"
struct utsname {
   char sysname[65] ;
   char nodename[65] ;
   char release[65] ;
   char version[65] ;
   char machine[65] ;
   char __domainname[65] ;
};
#line 134 "/usr/include/x86_64-linux-gnu/bits/types.h"
struct __anonstruct___fsid_t_1 {
   int __val[2] ;
};
#line 134 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef struct __anonstruct___fsid_t_1 __fsid_t;
#line 162 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsblkcnt_t;
#line 166 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsfilcnt_t;
#line 170 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __fsword_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/statfs.h"
struct statfs {
   __fsword_t f_type ;
   __fsword_t f_bsize ;
   __fsblkcnt_t f_blocks ;
   __fsblkcnt_t f_bfree ;
   __fsblkcnt_t f_bavail ;
   __fsfilcnt_t f_files ;
   __fsfilcnt_t f_ffree ;
   __fsid_t f_fsid ;
   __fsword_t f_namelen ;
   __fsword_t f_frsize ;
   __fsword_t f_flags ;
   __fsword_t f_spare[4] ;
};
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __useconds_t;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 131 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setitimer)(__itimer_which_t __which ,
                                                                                struct itimerval  const  * __restrict  __new ,
                                                                                struct itimerval * __restrict  __old ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 50 "/usr/include/strings.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1), __leaf__)) bzero)(void *__s ,
                                                                                             size_t __n ) ;
#line 120
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncasecmp)(char const   *__s1 ,
                                                                                                    char const   *__s2 ,
                                                                                                    size_t __n )  __attribute__((__pure__)) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 1406 "/usr/include/X11/Xlib.h"
extern XFontStruct *XLoadQueryFont(Display * , char const   * ) ;
#line 1495
extern Display *XOpenDisplay(char const   * ) ;
#line 1499
extern void XrmInitialize(void) ;
#line 1570
extern Cursor XCreatePixmapCursor(Display * , Pixmap  , Pixmap  , XColor * , XColor * ,
                                  unsigned int  , unsigned int  ) ;
#line 1596
extern GC XCreateGC(Display * , Drawable  , unsigned long  , XGCValues * ) ;
#line 1609
extern Pixmap XCreatePixmap(Display * , Drawable  , unsigned int  , unsigned int  ,
                            unsigned int  ) ;
#line 1633
extern Window XCreateSimpleWindow(Display * , Window  , int  , int  , unsigned int  ,
                                  unsigned int  , unsigned int  , unsigned long  ,
                                  unsigned long  ) ;
#line 1731
extern char *XResourceManagerString(Display * ) ;
#line 1970
extern int XAllocColor(Display * , Colormap  , XColor * ) ;
#line 2097
extern int XChangeWindowAttributes(Display * , Window  , unsigned long  , XSetWindowAttributes * ) ;
#line 2121
extern int XCheckTypedEvent(Display * , int  , XEvent * ) ;
#line 2157
extern int XClearArea(Display * , Window  , int  , int  , unsigned int  , unsigned int  ,
                      int  ) ;
#line 2167
extern int XClearWindow(Display * , Window  ) ;
#line 2354
extern int XDrawLine(Display * , Drawable  , GC  , int  , int  , int  , int  ) ;
#line 2364
extern int XDrawLines(Display * , Drawable  , GC  , XPoint * , int  , int  ) ;
#line 2416
extern int XDrawString(Display * , Drawable  , GC  , int  , int  , char const   * ,
                       int  ) ;
#line 2491
extern int XFillPolygon(Display * , Drawable  , GC  , XPoint * , int  , int  , int  ) ;
#line 2501
extern int XFillRectangle(Display * , Drawable  , GC  , int  , int  , unsigned int  ,
                          unsigned int  ) ;
#line 2573
extern int XFreeGC(Display * , GC  ) ;
#line 2582
extern int XFreePixmap(Display * , Pixmap  ) ;
#line 2632
extern int XGetGeometry(Display * , Drawable  , Window * , int * , int * , unsigned int * ,
                        unsigned int * , unsigned int * , unsigned int * ) ;
#line 2803
extern int XLowerWindow(Display * , Window  ) ;
#line 2818
extern int XMapWindow(Display * , Window  ) ;
#line 2846
extern int XMoveWindow(Display * , Window  , int  , int  ) ;
#line 2853
extern int XNextEvent(Display * , XEvent * ) ;
#line 2862
extern int XParseColor(Display * , Colormap  , char const   * , XColor * ) ;
#line 2869
extern int XParseGeometry(char const   * , int * , int * , unsigned int * , unsigned int * ) ;
#line 2995
extern int XQueryPointer(Display * , Window  , Window * , Window * , int * , int * ,
                         int * , int * , unsigned int * ) ;
#line 3038
extern int XRaiseWindow(Display * , Window  ) ;
#line 3111
extern int XResizeWindow(Display * , Window  , unsigned int  , unsigned int  ) ;
#line 3141
extern int XSelectInput(Display * , Window  , long  ) ;
#line 3239
extern int XSetForeground(Display * , GC  , unsigned long  ) ;
#line 3263
extern int XSetInputFocus(Display * , Window  , int  , Time  ) ;
#line 3421
extern int XSync(Display * , int  ) ;
#line 3446
extern int XTextWidth(XFontStruct * , char const   * , int  ) ;
#line 3458
extern int XTranslateCoordinates(Display * , Window  , Window  , int  , int  , int * ,
                                 int * , Window * ) ;
#line 223 "/usr/include/X11/Xresource.h"
extern int XrmGetResource(XrmDatabase  , char const   * , char const   * , char ** ,
                          XrmValue * ) ;
#line 276
extern XrmDatabase XrmGetStringDatabase(char const   * ) ;
#line 285
extern void XrmMergeDatabases(XrmDatabase  , XrmDatabase * ) ;
#line 346
extern void XrmParseCommand(XrmDatabase * , XrmOptionDescList  , int  , char const   * ,
                            int * , char ** ) ;
#line 534 "/usr/include/X11/Xutil.h"
extern int XLookupString(XKeyEvent * , char * , int  , KeySym * , XComposeStatus * ) ;
#line 653
extern void XSetWMName(Display * , Window  , XTextProperty * ) ;
#line 659
extern void XSetWMNormalHints(Display * , Window  , XSizeHints * ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 29 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.h"
int dosync  ;
#line 30 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.h"
char hostname[25]  ;
#line 31 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.h"
GC gc  ;
#line 31 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.h"
GC rgc  ;
#line 31 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.h"
GC ggc  ;
#line 31 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.h"
GC ygc  ;
#line 31 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.h"
GC blgc  ;
#line 31 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.h"
GC ptextgc  ;
#line 32 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.h"
GC tgc  ;
#line 32 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.h"
GC bgc  ;
#line 32 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.h"
GC bkgc  ;
#line 33 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.h"
GC popgc  ;
#line 33 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.h"
GC poptgc  ;
#line 33 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.h"
GC popbgc  ;
#line 34 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.h"
GC warngc  ;
#line 34 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.h"
GC hlgc  ;
#line 34 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.h"
GC metergc  ;
#line 35 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.h"
Display *disp  ;
#line 36 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.h"
Window win  ;
#line 36 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.h"
Window popup  ;
#line 36 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.h"
Window root  ;
#line 36 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.h"
Window info  ;
#line 37 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.h"
XFontStruct *pfont  ;
#line 37 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.h"
XFontStruct *font2  ;
#line 37 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.h"
XFontStruct *font  ;
#line 38 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.h"
int screen  ;
#line 38 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.h"
int depth  ;
#line 39 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.h"
int fontheight  ;
#line 40 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.h"
unsigned int width  ;
#line 40 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.h"
unsigned int height  ;
#line 40 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.h"
unsigned int pw  ;
#line 40 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.h"
unsigned int ph  ;
#line 41 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.h"
unsigned int pwidth  ;
#line 41 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.h"
unsigned int pheight  ;
#line 42 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.h"
unsigned int rwidth  ;
#line 42 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.h"
unsigned int rheight  ;
#line 43 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.h"
double load  ;
#line 43 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.h"
double avg  ;
#line 43 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.h"
double davg  ;
#line 44 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.h"
int processes  ;
#line 45 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.h"
int warnpct  ;
#line 46 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.h"
int menuhl  ;
#line 47 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.h"
int shrinkpopup  ;
#line 50 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.h"
unsigned int yel  ;
#line 51 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.h"
XColor popbg  ;
#line 54
void Doinit(char *label ) ;
#line 54
void GetLoadPoint(double *avg___0 , double *oavg , double *davg___0 , int *numps ) ;
#line 54
void Getgeom(Window win___0 , int *x , int *y , unsigned int *width___0 , unsigned int *h ) ;
#line 54
void ShowInfo(int which ) ;
#line 55
void GetDiskUsage(void) ;
#line 55
void draw_popup(int highlight ) ;
#line 55
void do_popup(void) ;
#line 55
void do_popdown(void) ;
#line 56
void dobevels(Window win___0 , int x , int y , int w , int h , GC top , GC bot ) ;
#line 56
void infodown(void) ;
#line 57
char *commanum(long num ) ;
#line 58
Window MakePopup(int x , int y , unsigned int w , unsigned int h , unsigned int background ,
                 int bw ) ;
#line 88 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.h"
Memusage memory  ;
#line 90 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.h"
Diskusage usages[20]  ;
#line 91 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.h"
_maxload maxload  ;
#line 28 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.c"
void do_loop(int force ) ;
#line 28
void drawhostname(void) ;
#line 28
void usage(char **argv ) ;
#line 29
void loop(void) ;
#line 29
void dosizecursor(int w , int h , char sep , XColor *col ) ;
#line 30
void drawnum(float ld ) ;
#line 30
void raiseit(void) ;
#line 33 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.c"
double oldload  =    (double )0;
#line 34 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.c"
int blockheight  =    2;
#line 36 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.c"
float oldnum  =    (float )0;
#line 37 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.c"
int showmax  =    1;
#line 38 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.c"
int diskwarn  =    0;
#line 43 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.c"
static int olduse[20]  ;
#line 44 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.c"
int warn_disk  =    0;
#line 45 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.c"
int override  =    0;
#line 46 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.c"
int nogeom  =    0;
#line 47 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.c"
int loadheight  ;
#line 48 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.c"
struct itimerval timval  ;
#line 50 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.c"
static XrmOptionDescRec opts[19]  = 
#line 50
  {      {(char *)"-geometry", (char *)".geometry", (XrmOptionKind )3, (caddr_t )((void *)0)}, 
        {(char *)"-display",
      (char *)".display", (XrmOptionKind )3, (caddr_t )((void *)0)}, 
        {(char *)"-numfont", (char *)".numfont", (XrmOptionKind )3, (caddr_t )((void *)0)}, 
        {(char *)"-labelfont",
      (char *)".labelfont", (XrmOptionKind )3, (caddr_t )((void *)0)}, 
        {(char *)"-label", (char *)".label", (XrmOptionKind )3, (caddr_t )((void *)0)}, 
        {(char *)"-popupfont",
      (char *)".popupfont", (XrmOptionKind )3, (caddr_t )((void *)0)}, 
        {(char *)"-popupbg", (char *)".popupbg", (XrmOptionKind )3, (caddr_t )((void *)0)}, 
        {(char *)"-popupfg",
      (char *)".popupfg", (XrmOptionKind )3, (caddr_t )((void *)0)}, 
        {(char *)"-name", (char *)".name", (XrmOptionKind )3, (caddr_t )((void *)0)}, 
        {(char *)"-warn",
      (char *)".warn", (XrmOptionKind )3, (caddr_t )((void *)0)}, 
        {(char *)"-disk", (char *)".disk", (XrmOptionKind )0, (caddr_t )"True"}, 
        {(char *)"-warnbg", (char *)".warnbg", (XrmOptionKind )3, (caddr_t )((void *)0)}, 
        {(char *)"-meter",
      (char *)".meter", (XrmOptionKind )3, (caddr_t )((void *)0)}, 
        {(char *)"-override", (char *)".override", (XrmOptionKind )0, (caddr_t )"True"}, 
        {(char *)"-sync",
      (char *)".sync", (XrmOptionKind )0, (caddr_t )"True"}, 
        {(char *)"-noshrink", (char *)".noshrink", (XrmOptionKind )0, (caddr_t )"True"}, 
        {(char *)"-nogeom",
      (char *)".nogeom", (XrmOptionKind )0, (caddr_t )"True"}, 
        {(char *)"-bh", (char *)".bh", (XrmOptionKind )3, (caddr_t )((void *)0)}, 
        {(char *)"-parent", (char *)".parent", (XrmOptionKind )3, (caddr_t )((void *)0)}};
#line 71 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.c"
XrmDatabase rdb  ;
#line 71 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.c"
XrmDatabase srvdb  ;
#line 71 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.c"
XrmDatabase cmdb  ;
#line 72 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.c"
XrmValue val  ;
#line 73 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.c"
char *str_type[50]  ;
#line 73 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.c"
char buffer[50]  ;
#line 75 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.c"
int main(int argc , char **argv ) 
{ 
  XColor red ;
  XColor green ;
  XColor yellow ;
  XColor blue ;
  XColor grey ;
  XColor top ;
  XColor bot ;
  XColor popt ;
  XColor popb ;
  XColor popfg ;
  XColor warnbg ;
  XColor meter ;
  unsigned long mask ;
  Colormap cmap ;
  XGCValues vals ;
  Window parent ;
  XTextProperty prop ;
  XEvent event ;
  char buf___2 ;
  char *display ;
  char *labelfont ;
  char *namefont ;
  char *popupfont ;
  char *label ;
  char *name ;
  XSizeHints hints ;
  int oy ;
  int gstatus ;
  unsigned int x ;
  unsigned int y ;
  int highlighted ;
  int moving ;
  int resizing ;
  int px ;
  int py ;
  Window rr ;
  Window cr ;
  XSetWindowAttributes wattr ;
  int rx ;
  int ry ;
  int wx ;
  int wy ;
  unsigned int mr ;
  void *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;
  void *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  void *tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  void *tmp___33 ;
  void *tmp___34 ;
  void *tmp___35 ;
  void *tmp___36 ;
  void *tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;

  {
  {
#line 86
  display = (char *)((void *)0);
#line 91
  oy = 65535;
#line 91
  gstatus = 0;
#line 92
  x = 0U;
#line 92
  y = 0U;
#line 93
  highlighted = 0;
#line 94
  moving = 0;
#line 95
  resizing = 0;
#line 96
  px = 0;
#line 97
  py = 0;
#line 103
  popupfont = (char *)((void *)0);
#line 103
  name = popupfont;
#line 103
  label = name;
#line 103
  namefont = label;
#line 103
  labelfont = namefont;
#line 104
  warnpct = 90;
#line 105
  menuhl = 0;
#line 106
  shrinkpopup = 1;
#line 117
  bzero((void *)(& hints), sizeof(hints));
#line 119
  XrmInitialize();
#line 120
  XrmParseCommand(& cmdb, opts, 19, "loadmeter", & argc, argv);
#line 122
  tmp___0 = XrmGetResource(cmdb, "loadmeter.display", "Loadmeter.display", str_type,
                           & val);
  }
#line 122
  if (tmp___0) {
    {
#line 124
    tmp = malloc((size_t )(val.size + 1U));
#line 124
    display = (char *)tmp;
#line 125
    strncpy((char */* __restrict  */)display, (char const   */* __restrict  */)val.addr,
            (size_t )val.size);
    }
  }
  {
#line 129
  disp = XOpenDisplay((char const   *)display);
  }
#line 130
  if ((unsigned long )disp == (unsigned long )((void *)0)) {
    {
#line 132
    printf((char const   */* __restrict  */)"Cannot open display!\n");
#line 133
    exit(0);
    }
  }
  {
#line 136
  screen = ((_XPrivDisplay )disp)->default_screen;
#line 137
  cmap = (((_XPrivDisplay )disp)->screens + screen)->cmap;
#line 138
  rwidth = (unsigned int )(((_XPrivDisplay )disp)->screens + screen)->width;
#line 139
  rheight = (unsigned int )(((_XPrivDisplay )disp)->screens + screen)->height;
#line 140
  root = (((_XPrivDisplay )disp)->screens + ((_XPrivDisplay )disp)->default_screen)->root;
#line 141
  depth = (((_XPrivDisplay )disp)->screens + screen)->root_depth;
#line 143
  tmp___2 = XResourceManagerString(disp);
  }
#line 143
  if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
    {
#line 145
    tmp___1 = XResourceManagerString(disp);
#line 145
    srvdb = XrmGetStringDatabase((char const   *)tmp___1);
    }
  }
#line 147
  if ((unsigned long )srvdb != (unsigned long )((void *)0)) {
    {
#line 148
    XrmMergeDatabases(srvdb, & rdb);
    }
  }
  {
#line 149
  XrmMergeDatabases(cmdb, & rdb);
#line 151
  tmp___3 = XrmGetResource(rdb, "loadmeter.geometry", "Loadmeter.geometry", str_type,
                           & val);
  }
#line 151
  if (tmp___3) {
    {
#line 153
    strncpy((char */* __restrict  */)(buffer), (char const   */* __restrict  */)val.addr,
            (size_t )((int )val.size));
#line 154
    gstatus = XParseGeometry((char const   *)(buffer), (int *)(& x), (int *)(& y),
                             & width, & height);
    }
#line 155
    if (gstatus & 1) {
#line 156
      hints.flags = 1L;
    } else
#line 155
    if (gstatus & 2) {
#line 156
      hints.flags = 1L;
    }
#line 157
    if (gstatus & 4) {
#line 158
      hints.flags |= 1L << 1;
    } else
#line 157
    if (gstatus & 8) {
#line 158
      hints.flags |= 1L << 1;
    }
  }
  {
#line 160
  tmp___5 = XrmGetResource(rdb, "loadmeter.numfont", "Loadmeter.numfont", str_type,
                           & val);
  }
#line 160
  if (tmp___5) {
    {
#line 162
    tmp___4 = malloc((size_t )(val.size + 1U));
#line 162
    labelfont = (char *)tmp___4;
#line 163
    strncpy((char */* __restrict  */)labelfont, (char const   */* __restrict  */)val.addr,
            (size_t )val.size);
    }
  }
  {
#line 165
  tmp___7 = XrmGetResource(rdb, "loadmeter.labelfont", "Loadmeter.labelfont", str_type,
                           & val);
  }
#line 165
  if (tmp___7) {
    {
#line 167
    tmp___6 = malloc((size_t )(val.size + 1U));
#line 167
    namefont = (char *)tmp___6;
#line 168
    strncpy((char */* __restrict  */)namefont, (char const   */* __restrict  */)val.addr,
            (size_t )val.size);
    }
  }
  {
#line 170
  tmp___9 = XrmGetResource(rdb, "loadmeter.popupfont", "Loadmeter.popupfont", str_type,
                           & val);
  }
#line 170
  if (tmp___9) {
    {
#line 172
    tmp___8 = malloc((size_t )(val.size + 1U));
#line 172
    popupfont = (char *)tmp___8;
#line 173
    strncpy((char */* __restrict  */)popupfont, (char const   */* __restrict  */)val.addr,
            (size_t )val.size);
    }
  }
  {
#line 175
  tmp___11 = XrmGetResource(rdb, "loadmeter.label", "Loadmeter.label", str_type, & val);
  }
#line 175
  if (tmp___11) {
    {
#line 177
    tmp___10 = malloc((size_t )(val.size + 1U));
#line 177
    label = (char *)tmp___10;
#line 178
    strncpy((char */* __restrict  */)label, (char const   */* __restrict  */)val.addr,
            (size_t )val.size);
    }
  }
  {
#line 180
  tmp___13 = XrmGetResource(rdb, "loadmeter.parent", "Loadmeter.parent", str_type,
                            & val);
  }
#line 180
  if (tmp___13) {
    {
#line 182
    tmp___12 = sscanf((char const   */* __restrict  */)val.addr, (char const   */* __restrict  */)"%i",
                      (unsigned int *)(& parent));
    }
#line 182
    if (tmp___12 == 0) {
#line 183
      parent = (Window )0;
    }
  } else {
#line 184
    parent = (Window )0;
  }
  {
#line 186
  tmp___15 = XrmGetResource(rdb, "loadmeter.popupbg", "Loadmeter.popupbg", str_type,
                            & val);
  }
#line 186
  if (tmp___15) {
    {
#line 188
    tmp___14 = XParseColor(disp, cmap, (char const   *)val.addr, & popbg);
    }
#line 188
    if (tmp___14 == 0) {
      {
#line 190
      printf((char const   */* __restrict  */)"Can\'t allocate popup bg!\n");
#line 191
      exit(1);
      }
    }
  } else {
    {
#line 195
    XParseColor(disp, cmap, "grey30", & popbg);
    }
  }
  {
#line 197
  tmp___16 = XrmGetResource(rdb, "loadmeter.meter", "Loadmeter.meter", str_type, & val);
  }
#line 197
  if (tmp___16) {
    {
#line 198
    XParseColor(disp, cmap, (char const   *)val.addr, & meter);
    }
  } else {
    {
#line 200
    XParseColor(disp, cmap, "red2", & meter);
    }
  }
  {
#line 202
  tmp___17 = XrmGetResource(rdb, "loadmeter.popupfg", "Loadmeter.popupfg", str_type,
                            & val);
  }
#line 202
  if (tmp___17) {
    {
#line 203
    XParseColor(disp, cmap, (char const   *)val.addr, & popfg);
    }
  } else {
    {
#line 205
    XParseColor(disp, cmap, "yellow", & popfg);
    }
  }
  {
#line 207
  tmp___18 = XrmGetResource(rdb, "loadmeter.warnbg", "Loadmeter.warnbg", str_type,
                            & val);
  }
#line 207
  if (tmp___18) {
    {
#line 208
    XParseColor(disp, cmap, (char const   *)val.addr, & warnbg);
    }
  } else {
    {
#line 210
    XParseColor(disp, cmap, "seagreen4", & warnbg);
    }
  }
  {
#line 212
  tmp___20 = XrmGetResource(rdb, "loadmeter.name", "Loadmeter.name", str_type, & val);
  }
#line 212
  if (tmp___20) {
    {
#line 214
    tmp___19 = malloc((size_t )(val.size + 1U));
#line 214
    name = (char *)tmp___19;
#line 215
    strncpy((char */* __restrict  */)name, (char const   */* __restrict  */)val.addr,
            (size_t )val.size);
    }
  }
  {
#line 217
  tmp___21 = XrmGetResource(rdb, "loadmeter.warn", "Loadmeter.warn", str_type, & val);
  }
#line 217
  if (tmp___21) {
    {
#line 218
    warnpct = atoi((char const   *)val.addr);
    }
  }
  {
#line 219
  tmp___23 = XrmGetResource(rdb, "loadmeter.override", "Loadmeter.override", str_type,
                            & val);
  }
#line 219
  if (tmp___23) {
    {
#line 221
    tmp___22 = strncasecmp("true", (char const   *)val.addr, (size_t )val.size);
    }
#line 221
    if (! tmp___22) {
#line 222
      override = 1;
    }
#line 223
    if (override) {
#line 223
      if (parent != 0UL) {
        {
#line 224
        usage(argv);
        }
      }
    }
  }
  {
#line 226
  tmp___25 = XrmGetResource(rdb, "loadmeter.sync", "Loadmeter.sync", str_type, & val);
  }
#line 226
  if (tmp___25) {
    {
#line 227
    tmp___24 = strncasecmp("true", (char const   *)val.addr, (size_t )val.size);
    }
#line 227
    if (! tmp___24) {
#line 228
      dosync = 1;
    }
  }
  {
#line 229
  tmp___27 = XrmGetResource(rdb, "loadmeter.nogeom", "Loadmeter.nogeom", str_type,
                            & val);
  }
#line 229
  if (tmp___27) {
    {
#line 230
    tmp___26 = strncasecmp("true", (char const   *)val.addr, (size_t )val.size);
    }
#line 230
    if (! tmp___26) {
#line 231
      nogeom = 1;
    }
  }
  {
#line 232
  tmp___29 = XrmGetResource(rdb, "loadmeter.noshrink", "Loadmeter.noshrink", str_type,
                            & val);
  }
#line 232
  if (tmp___29) {
    {
#line 233
    tmp___28 = strncasecmp("true", (char const   *)val.addr, (size_t )val.size);
    }
#line 233
    if (! tmp___28) {
#line 234
      shrinkpopup = 0;
    }
  }
  {
#line 235
  tmp___31 = XrmGetResource(rdb, "loadmeter.disk", "Loadmeter.disk", str_type, & val);
  }
#line 235
  if (tmp___31) {
    {
#line 236
    tmp___30 = strncasecmp("true", (char const   *)val.addr, (size_t )val.size);
    }
#line 236
    if (! tmp___30) {
#line 237
      diskwarn = 1;
    }
  }
  {
#line 238
  tmp___32 = XrmGetResource(rdb, "loadmeter.bh", "Loadmeter.bh", str_type, & val);
  }
#line 238
  if (tmp___32) {
    {
#line 239
    blockheight = atoi((char const   *)val.addr);
    }
  }
#line 241
  if (argc != 1) {
    {
#line 242
    usage(argv);
    }
  }
#line 245
  if (! (gstatus & 4)) {
#line 246
    width = 40U;
  }
#line 247
  if (! (gstatus & 8)) {
#line 248
    height = 100U;
  }
#line 250
  if (! (gstatus & 1)) {
#line 251
    x = 1U;
  } else
#line 252
  if (gstatus & 16) {
#line 253
    x = (rwidth + x) - width;
  }
#line 254
  if (! (gstatus & 2)) {
#line 255
    y = 1U;
  } else
#line 256
  if (gstatus & 32) {
#line 257
    y = (rheight + y) - height;
  }
  {
#line 259
  hints.x = (int )x;
#line 260
  hints.y = (int )y;
#line 261
  hints.min_width = 25;
#line 262
  hints.min_height = 75;
#line 263
  hints.flags |= 1L << 4;
#line 266
  bzero((void *)(& red), sizeof(red));
#line 267
  bzero((void *)(& green), sizeof(green));
#line 268
  bzero((void *)(& yellow), sizeof(yellow));
#line 269
  bzero((void *)(& blue), sizeof(blue));
  }
#line 270
  if (depth != 1) {
#line 272
    yellow.red = (unsigned short)65535;
#line 272
    yellow.green = yellow.red;
#line 272
    green.green = yellow.green;
#line 272
    red.red = green.green;
#line 273
    grey.blue = (unsigned short)18724;
#line 273
    grey.green = grey.blue;
#line 273
    grey.red = grey.green;
#line 274
    blue.red = (unsigned short)14563;
#line 274
    blue.green = (unsigned short)42649;
#line 274
    blue.blue = (unsigned short)65535;
  } else {
#line 278
    blue.blue = (unsigned short)0;
#line 278
    blue.green = blue.blue;
#line 278
    blue.red = blue.green;
#line 278
    yellow.red = blue.red;
#line 278
    yellow.green = yellow.red;
#line 278
    green.green = yellow.green;
#line 278
    red.red = green.green;
#line 280
    grey.blue = (unsigned short)65535;
#line 280
    grey.green = grey.blue;
#line 280
    grey.red = grey.green;
  }
  {
#line 283
  XAllocColor(disp, cmap, & yellow);
#line 284
  XAllocColor(disp, cmap, & red);
#line 285
  XAllocColor(disp, cmap, & green);
#line 288
  XAllocColor(disp, cmap, & grey);
#line 289
  bot.red = (unsigned short )((int )grey.red / 2);
#line 290
  bot.green = (unsigned short )((int )grey.green / 2);
#line 291
  bot.blue = (unsigned short )((int )grey.blue / 2);
#line 292
  top.red = (unsigned short )((int )grey.red * 2);
#line 293
  top.green = (unsigned short )((int )grey.green * 2);
#line 294
  top.blue = (unsigned short )((int )grey.blue * 2);
  }
#line 295
  if (depth == 1) {
#line 296
    bot.blue = (unsigned short)0;
#line 296
    bot.green = bot.blue;
#line 296
    bot.red = bot.green;
#line 297
    top.blue = (unsigned short)0;
#line 297
    top.green = top.blue;
#line 297
    top.red = top.green;
#line 298
    popbg.green = (unsigned short)65535;
#line 298
    popbg.blue = popbg.green;
#line 298
    popbg.red = popbg.blue;
#line 299
    popfg.green = (unsigned short)0;
#line 299
    popfg.blue = popfg.green;
#line 299
    popfg.red = popfg.blue;
#line 300
    warnbg.green = (unsigned short)65535;
#line 300
    warnbg.blue = warnbg.green;
#line 300
    warnbg.red = warnbg.blue;
  }
  {
#line 302
  XAllocColor(disp, cmap, & top);
#line 303
  XAllocColor(disp, cmap, & bot);
#line 304
  XAllocColor(disp, cmap, & blue);
#line 305
  XAllocColor(disp, cmap, & popbg);
#line 306
  XAllocColor(disp, cmap, & popfg);
#line 307
  XAllocColor(disp, cmap, & warnbg);
#line 308
  popb.red = (unsigned short )((int )popbg.red / 2);
#line 309
  popb.blue = (unsigned short )((int )popbg.blue / 2);
#line 310
  popb.green = (unsigned short )((int )popbg.green / 2);
#line 311
  popt.red = (unsigned short )((int )popbg.red * 2);
#line 312
  popt.blue = (unsigned short )((int )popbg.blue * 2);
#line 313
  popt.green = (unsigned short )((int )popbg.green * 2);
  }
#line 314
  if (depth == 1) {
#line 315
    popt.blue = (unsigned short)0;
#line 315
    popt.green = popt.blue;
#line 315
    popt.red = popt.green;
#line 316
    popb.blue = (unsigned short)0;
#line 316
    popb.green = popb.blue;
#line 316
    popb.red = popb.green;
#line 317
    meter.blue = (unsigned short)0;
#line 317
    meter.green = meter.blue;
#line 317
    meter.red = meter.green;
  }
  {
#line 319
  XAllocColor(disp, cmap, & popt);
#line 320
  XAllocColor(disp, cmap, & popb);
#line 321
  XAllocColor(disp, cmap, & meter);
#line 323
  Doinit(label);
  }
#line 325
  if (parent == 0UL) {
#line 326
    parent = root;
  }
#line 329
  if (! override) {
    {
#line 330
    win = XCreateSimpleWindow(disp, parent, (int )x, (int )y, width, height, 0U, grey.pixel,
                              grey.pixel);
    }
  } else {
    {
#line 333
    win = MakePopup(x, y, width, height, grey.pixel, 0);
    }
  }
  {
#line 336
  XSetWMNormalHints(disp, win, & hints);
  }
#line 338
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 339
    prop.value = (unsigned char *)"Loadmeter";
  } else {
#line 341
    prop.value = (unsigned char *)name;
  }
  {
#line 342
  prop.encoding = (Atom )31;
#line 343
  prop.format = 8;
#line 344
  prop.nitems = strlen((char const   *)prop.value);
#line 345
  XSetWMName(disp, win, & prop);
#line 348
  mask = (unsigned long )(1L << 2);
#line 349
  vals.foreground = red.pixel;
#line 350
  rgc = XCreateGC(disp, win, mask, & vals);
  }
#line 353
  if ((unsigned long )namefont == (unsigned long )((void *)0)) {
    {
#line 355
    tmp___33 = malloc((size_t )80);
#line 355
    namefont = (char *)tmp___33;
#line 356
    strcpy((char */* __restrict  */)namefont, (char const   */* __restrict  */)"-schumacher-clean-medium-r-*-*-7-*-*-*-*-*-*-*");
    }
  }
  {
#line 358
  font = XLoadQueryFont(disp, (char const   *)namefont);
  }
#line 359
  if ((unsigned long )font == (unsigned long )((void *)0)) {
    {
#line 361
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t load font %s!\n",
            namefont);
#line 362
    exit(1);
    }
  }
#line 364
  fontheight = (int )font->max_bounds.ascent + (int )font->max_bounds.descent;
#line 367
  if ((unsigned long )labelfont == (unsigned long )((void *)0)) {
    {
#line 369
    tmp___34 = malloc((size_t )80);
#line 369
    labelfont = (char *)tmp___34;
#line 370
    strcpy((char */* __restrict  */)labelfont, (char const   */* __restrict  */)"6x10");
    }
  }
  {
#line 372
  font2 = XLoadQueryFont(disp, (char const   *)labelfont);
  }
#line 373
  if ((unsigned long )font2 == (unsigned long )((void *)0)) {
    {
#line 375
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t load font %s!\n",
            labelfont);
#line 376
    exit(1);
    }
  }
  {
#line 378
  loadheight = ((int )font2->max_bounds.ascent + (int )font2->max_bounds.descent) + 2;
#line 380
  mask |= (unsigned long )(1L << 14);
#line 381
  vals.font = font2->fid;
#line 382
  vals.foreground = green.pixel;
#line 383
  ggc = XCreateGC(disp, win, mask, & vals);
#line 385
  vals.font = font->fid;
#line 386
  vals.foreground = yellow.pixel;
#line 387
  vals.background = (((_XPrivDisplay )disp)->screens + ((_XPrivDisplay )disp)->default_screen)->black_pixel;
#line 388
  mask |= (unsigned long )(1L << 3);
#line 389
  yel = (unsigned int )yellow.pixel;
#line 390
  ygc = XCreateGC(disp, win, mask, & vals);
#line 392
  vals.foreground = popbg.pixel;
#line 393
  vals.background = popbg.pixel;
#line 394
  popgc = XCreateGC(disp, win, mask, & vals);
#line 395
  vals.foreground = popt.pixel;
#line 396
  poptgc = XCreateGC(disp, win, mask, & vals);
#line 397
  vals.foreground = popb.pixel;
#line 398
  popbgc = XCreateGC(disp, win, mask, & vals);
#line 400
  vals.foreground = warnbg.pixel;
#line 401
  warngc = XCreateGC(disp, win, mask, & vals);
#line 402
  vals.foreground = meter.pixel;
#line 403
  metergc = XCreateGC(disp, win, mask, & vals);
#line 405
  vals.foreground = top.pixel;
#line 406
  tgc = XCreateGC(disp, win, mask, & vals);
#line 407
  vals.foreground = bot.pixel;
#line 408
  bgc = XCreateGC(disp, win, mask, & vals);
#line 409
  vals.foreground = blue.pixel;
#line 410
  blgc = XCreateGC(disp, win, mask, & vals);
#line 411
  vals.foreground = (((_XPrivDisplay )disp)->screens + ((_XPrivDisplay )disp)->default_screen)->black_pixel;
  }
#line 412
  if ((unsigned long )popupfont == (unsigned long )((void *)0)) {
    {
#line 414
    tmp___35 = malloc((size_t )80);
#line 414
    popupfont = (char *)tmp___35;
#line 415
    strcpy((char */* __restrict  */)popupfont, (char const   */* __restrict  */)"-misc-fixed-medium-r-*-*-10-*-*-*-*-*-*-*");
    }
  }
  {
#line 417
  pfont = XLoadQueryFont(disp, (char const   *)popupfont);
  }
#line 418
  if ((unsigned long )pfont == (unsigned long )((void *)0)) {
    {
#line 420
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t load font %s!\n",
            popupfont);
#line 421
    exit(1);
    }
  }
  {
#line 423
  vals.font = pfont->fid;
#line 424
  vals.foreground = popfg.pixel;
#line 425
  ptextgc = XCreateGC(disp, win, mask, & vals);
#line 427
  vals.foreground = (((_XPrivDisplay )disp)->screens + ((_XPrivDisplay )disp)->default_screen)->black_pixel;
#line 428
  bkgc = XCreateGC(disp, win, mask, & vals);
#line 431
  XMapWindow(disp, win);
#line 432
  XSelectInput(disp, win, ((((((1L << 15) | (1L << 2)) | (1L << 17)) | (1L << 3)) | (1L << 6)) | 1L) | (1L << 4));
#line 436
  signal(14, (void (*)(int  ))(& loop));
#line 437
  signal(10, (void (*)(int  ))(& raiseit));
#line 438
  maxload.time = time((time_t *)((void *)0));
#line 439
  timval.it_value.tv_sec = (__time_t )0;
#line 440
  timval.it_value.tv_usec = (__suseconds_t )500000;
#line 442
  do_loop(1);
#line 443
  dobevels(win, 0, 0, width, height, tgc, bgc);
#line 445
  mask = 0UL;
  }
  {
#line 445
  while (1) {
    while_continue: /* CIL Label */ ;
#line 445
    if (! (mask < 20UL)) {
#line 445
      goto while_break;
    }
#line 447
    usages[mask].path = (char *)0;
#line 448
    usages[mask].dev = (char *)0;
#line 449
    usages[mask].type = (char *)0;
#line 450
    usages[mask].blocks = 0L;
#line 445
    mask ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 452
  tmp___36 = malloc((size_t )80);
#line 452
  memory.muse = (char *)tmp___36;
#line 453
  tmp___37 = malloc((size_t )80);
#line 453
  memory.suse = (char *)tmp___37;
  }
  {
#line 457
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 459
    setitimer(0, (struct itimerval  const  */* __restrict  */)(& timval), (struct itimerval */* __restrict  */)0);
#line 460
    XNextEvent(disp, & event);
    }
    {
#line 463
    if (event.type == 22) {
#line 463
      goto case_22;
    }
#line 467
    if (event.type == 12) {
#line 467
      goto case_12;
    }
#line 473
    if (event.type == 2) {
#line 473
      goto case_2;
    }
#line 479
    if (event.type == 4) {
#line 479
      goto case_4;
    }
#line 534
    if (event.type == 5) {
#line 534
      goto case_5;
    }
#line 545
    if (event.type == 6) {
#line 545
      goto case_6;
    }
#line 461
    goto switch_break;
    case_22: /* CIL Label */ 
#line 465
    width = (unsigned int )event.xconfigure.width;
#line 466
    height = (unsigned int )event.xconfigure.height;
    case_12: /* CIL Label */ 
    {
#line 470
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 470
      tmp___38 = XCheckTypedEvent(disp, 12, & event);
      }
#line 470
      if (! tmp___38) {
#line 470
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 471
    dobevels(win, 0, 0, width, height, tgc, bgc);
    }
#line 472
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 475
    XLookupString(& event.xkey, & buf___2, 1, (KeySym *)((void *)0), (XComposeStatus *)((void *)0));
    }
#line 476
    if ((int )buf___2 == 27) {
      {
#line 477
      exit(0);
      }
    }
#line 478
    goto while_continue___0;
    case_4: /* CIL Label */ 
    {
#line 481
    XSetInputFocus(disp, win, 0, (Time )0L);
    }
#line 482
    if (event.xbutton.button == 2U) {
#line 488
      if (override) {
#line 488
        goto _L;
      } else
#line 488
      if (parent != root) {
        _L: /* CIL Label */ 
#line 488
        if (event.xbutton.state == (unsigned int )(1 << 2)) {
          {
#line 489
          XQueryPointer(disp, win, & rr, & cr, & rx, & ry, & px, & py, & mr);
#line 490
          XRaiseWindow(disp, win);
#line 491
          moving = 1;
          }
        } else {
          {
#line 494
          maxload.load = (float )0;
#line 495
          maxload.num = 0;
#line 496
          maxload.time = time((time_t *)((void *)0));
#line 497
          do_popdown();
          }
        }
      } else {
        {
#line 494
        maxload.load = (float )0;
#line 495
        maxload.num = 0;
#line 496
        maxload.time = time((time_t *)((void *)0));
#line 497
        do_popdown();
        }
      }
    } else
#line 500
    if (event.xbutton.button == 3U) {
#line 506
      if (override) {
#line 506
        goto _L___0;
      } else
#line 506
      if (parent != root) {
        _L___0: /* CIL Label */ 
#line 506
        if (event.xbutton.state == (unsigned int )(1 << 2)) {
          {
#line 507
          XQueryPointer(disp, win, & rr, & cr, & rx, & ry, & px, & py, & mr);
#line 508
          XRaiseWindow(disp, win);
#line 509
          resizing = 1;
          }
        } else {
          {
#line 513
          showmax = 1 - showmax;
#line 514
          do_popdown();
          }
        }
      } else {
        {
#line 513
        showmax = 1 - showmax;
#line 514
        do_popdown();
        }
      }
    } else {
#line 522
      rx = 0;
      {
#line 522
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 522
        if (! (rx < 20)) {
#line 522
          goto while_break___2;
        }
#line 523
        if (olduse[rx] == 1) {
#line 524
          olduse[rx] = 3;
        }
#line 522
        rx ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 526
      if (override) {
#line 526
        if (parent == root) {
#line 526
          if (event.xbutton.state == (unsigned int )(1 << 2)) {
            {
#line 527
            XLowerWindow(disp, win);
            }
#line 528
            goto while_continue___0;
          }
        }
      }
      {
#line 530
      menuhl = 0;
#line 531
      do_popup();
      }
    }
#line 533
    goto while_continue___0;
    case_5: /* CIL Label */ 
    {
#line 538
    do_popdown();
#line 539
    menuhl = 0;
#line 539
    resizing = menuhl;
#line 539
    moving = resizing;
#line 540
    mask = (unsigned long )(1L << 14);
#line 541
    wattr.cursor = (Cursor )0;
#line 542
    XChangeWindowAttributes(disp, win, mask, & wattr);
#line 543
    oy = 65535;
    }
#line 544
    goto switch_break;
    case_6: /* CIL Label */ 
#line 549
    if (popup == 0UL) {
      {
#line 552
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 552
        tmp___39 = XCheckTypedEvent(disp, 6, & event);
        }
#line 552
        if (! tmp___39) {
#line 552
          goto while_break___3;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 553
      if (moving) {
        {
#line 555
        XQueryPointer(disp, parent, & rr, & cr, & rx, & ry, & wx, & wy, & mr);
#line 556
        dosizecursor(wx - px, wy - py, (char )'+', & yellow);
#line 557
        XMoveWindow(disp, win, wx - px, wy - py);
        }
      } else
#line 559
      if (resizing) {
        {
#line 560
        XQueryPointer(disp, win, & rr, & cr, & rx, & ry, & wx, & wy, & mr);
        }
#line 561
        if (wx < 25) {
#line 561
          wx = 25;
        }
#line 562
        if (wy < 75) {
#line 562
          wy = 75;
        }
        {
#line 563
        dosizecursor(wx, wy, (char )'x', & yellow);
#line 564
        XResizeWindow(disp, win, (unsigned int )wx, (unsigned int )wy);
        }
      }
#line 566
      goto while_continue___0;
    }
#line 568
    x = (unsigned int )((int )pfont->max_bounds.ascent + (int )pfont->max_bounds.descent);
#line 569
    if (event.xany.window == popup) {
#line 569
      if ((unsigned int )event.xmotion.y <= pheight) {
#line 569
        if ((unsigned int )event.xmotion.x <= pwidth) {
#line 569
          if (event.xmotion.y >= 0) {
#line 569
            if (event.xmotion.x >= 0) {
#line 573
              if (event.xmotion.y < 2) {
#line 574
                event.xmotion.y = 2;
              }
#line 575
              y = (unsigned int )(event.xmotion.y - 2) / x - 1U;
#line 576
              menuhl = 1;
#line 577
              if (y == (unsigned int )oy) {
#line 578
                goto while_continue___0;
              }
              {
#line 579
              ShowInfo(y);
#line 580
              draw_popup(y);
#line 581
              highlighted = 1;
#line 582
              oy = (int )y;
              }
            } else {
#line 569
              goto _L___4;
            }
          } else {
#line 569
            goto _L___4;
          }
        } else {
#line 569
          goto _L___4;
        }
      } else {
#line 569
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
#line 584
    if (highlighted) {
      {
#line 586
      highlighted = 0;
#line 587
      menuhl = 0;
#line 588
      oy = 65535;
#line 589
      infodown();
#line 590
      XClearWindow(disp, popup);
#line 591
      draw_popup(0);
      }
    }
#line 593
    goto while_continue___0;
    switch_break: /* CIL Label */ ;
    }
    {
#line 597
    do_loop(1);
#line 598
    XSync(disp, 0);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
}
}
#line 602 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.c"
void usage(char **argv ) 
{ 


  {
  {
#line 604
  printf((char const   */* __restrict  */)"Loadmeter v1.20 (c)1998 Ben Buxton (bb@zip.com.au)\n");
#line 605
  printf((char const   */* __restrict  */)"Usage: %s [-disp display] [-geom geometry] [-name name]\n",
         *(argv + 0));
#line 606
  printf((char const   */* __restrict  */)"          [-numfont font] [-labelfont font] [-label label] [-disk]\n");
#line 607
  printf((char const   */* __restrict  */)"          [-popupfont font] [-popupbg bg] [-popupfg fg] [-name name]\n");
#line 608
  printf((char const   */* __restrict  */)"          [-warn pct] [-warnbg bg] [-meter colour] [-override]\n");
#line 609
  printf((char const   */* __restrict  */)"          [-sync] [-bh blockheight] [-parent window] [-noshrink]\n");
#line 610
  printf((char const   */* __restrict  */)"          [-nogeom]\n");
#line 611
  exit(1);
  }
}
}
#line 621 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.c"
static int avgb  ;
#line 621 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.c"
static int oavgb  ;
#line 615 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.c"
void do_loop(int force ) 
{ 
  int numblocks ;
  int totblocks ;
  int where ;
  int x ;
  int y ;
  int y2 ;
  int mark ;
  int mark2 ;
  int wd ;

  {
  {
#line 624
  GetLoadPoint(& load, & avg, & davg, & processes);
#line 625
  totblocks = (int )(((height - (unsigned int )loadheight) - 3U) / (unsigned int )(blockheight + 1));
#line 628
  numblocks = (int )((double )(totblocks / 3) * load);
  }
#line 630
  if (load != oldload) {
    {
#line 631
    drawnum(load);
    }
  } else
#line 630
  if (force) {
    {
#line 631
    drawnum(load);
    }
  }
#line 632
  oldload = load;
#line 633
  avgb = (int )((double )(totblocks / 3) * avg);
#line 635
  if (oldnum == (float )numblocks) {
#line 635
    if (avgb == oavgb) {
#line 635
      if (! force) {
#line 636
        return;
      }
    }
  }
#line 638
  if (numblocks > totblocks) {
#line 639
    numblocks = totblocks;
  }
#line 641
  if (load > (double )maxload.load) {
#line 641
    goto _L;
  } else
#line 641
  if (numblocks > maxload.num) {
    _L: /* CIL Label */ 
#line 641
    if (showmax == 1) {
      {
#line 643
      maxload.num = numblocks;
#line 644
      maxload.load = (float )load;
#line 645
      maxload.time = time((time_t *)((void *)0));
      }
    }
  }
  {
#line 647
  oldnum = (float )numblocks;
#line 648
  oavgb = avgb;
#line 649
  XClearArea(disp, win, 1, loadheight, width - 2U, (height - (unsigned int )loadheight) - 2U,
             0);
#line 651
  where = 0;
  }
  {
#line 651
  while (1) {
    while_continue: /* CIL Label */ ;
#line 651
    if (! (where < totblocks)) {
#line 651
      goto while_break;
    }
#line 653
    x = 4;
#line 654
    y = (int )((((height - (unsigned int )blockheight) - (unsigned int )where) - 2U) - (unsigned int )(where * blockheight));
#line 656
    if (where < totblocks / 3) {
#line 657
      gc = ggc;
    } else
#line 658
    if (where < blockheight * (totblocks / 3)) {
#line 659
      gc = ygc;
    } else {
#line 661
      gc = rgc;
    }
#line 663
    if (where > numblocks) {
#line 665
      if (depth == 1) {
#line 666
        gc = popgc;
      } else {
#line 668
        gc = bgc;
      }
    }
    {
#line 671
    XFillRectangle(disp, win, gc, x, y, width - 8U, (unsigned int )blockheight);
#line 651
    where ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 674
  mark = (int )((height - 2U) - (unsigned int )((totblocks / 3) * (blockheight + 1)));
#line 675
  XDrawLine(disp, win, tgc, 1, mark, (int )(width - 2U), mark);
#line 676
  mark2 = (int )((height - 2U) - (unsigned int )((2 * (totblocks / 3)) * (blockheight + 1)));
#line 677
  XDrawLine(disp, win, tgc, 1, mark2, (int )(width - 2U), mark2);
#line 678
  wd = 0;
  }
  {
#line 678
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 678
    if (! (wd < 20)) {
#line 678
      goto while_break___0;
    }
#line 679
    if (olduse[wd] == 1) {
      {
#line 680
      XDrawString(disp, win, rgc, 7, (int )((height - (unsigned int )mark) / 2U + (unsigned int )mark),
                  "disk", 4);
      }
    } else
#line 679
    if (olduse[wd] == 2) {
      {
#line 680
      XDrawString(disp, win, rgc, 7, (int )((height - (unsigned int )mark) / 2U + (unsigned int )mark),
                  "disk", 4);
      }
    }
#line 678
    wd ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 682
  y = (int )((((height - (unsigned int )blockheight) - (unsigned int )maxload.num) - 2U) - (unsigned int )(maxload.num * blockheight));
#line 683
  if (showmax == 1) {
    {
#line 684
    XDrawLine(disp, win, rgc, 1, y, (int )(width / 5U), y);
    }
  }
  {
#line 685
  y2 = (int )(((height - (unsigned int )blockheight) - 2U) - (unsigned int )(avgb * (blockheight + 1)));
#line 686
  XDrawLine(disp, win, blgc, (int )((4U * width) / 5U), y2, (int )(width - 2U), y2);
#line 688
  drawhostname();
#line 689
  XSync(disp, 0);
  }
#line 690
  return;
}
}
#line 693 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.c"
void raiseit(void) 
{ 


  {
  {
#line 695
  signal(10, (void (*)(int  ))(& raiseit));
#line 696
  XRaiseWindow(disp, win);
#line 697
  do_loop(1);
  }
#line 698
  return;
}
}
#line 701 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.c"
void drawhostname(void) 
{ 
  int which ;
  int y ;
  size_t tmp ;

  {
#line 704
  y = loadheight * 2;
#line 705
  which = 0;
  {
#line 705
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 705
    tmp = strlen((char const   *)(hostname));
    }
#line 705
    if (! ((size_t )which < tmp)) {
#line 705
      goto while_break;
    }
    {
#line 707
    XDrawString(disp, win, ygc, (int )(width / 2U - 2U), y, (char const   *)(& hostname[which]),
                1);
#line 708
    y += fontheight;
#line 705
    which ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 710
  return;
}
}
#line 718 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.c"
static int inv  =    0;
#line 714 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.c"
void loop(void) 
{ 
  int which ;
  int force ;
  float pct ;

  {
#line 717
  force = 0;
#line 721
  if (diskwarn) {
#line 721
    if (inv > 9) {
      {
#line 722
      inv = 0;
#line 723
      GetDiskUsage();
#line 724
      which = 0;
      }
      {
#line 725
      while (1) {
        while_continue: /* CIL Label */ ;
#line 725
        if ((unsigned long )usages[which].path != (unsigned long )((char *)0)) {
#line 725
          if (! (which < 20)) {
#line 725
            goto while_break;
          }
        } else {
#line 725
          goto while_break;
        }
#line 726
        pct = ((float )(usages[which].blocks - usages[which].bfree) * (float )100) / (float )usages[which].blocks;
#line 727
        if (pct >= (float )warnpct) {
#line 728
          if (olduse[which] != 0) {
#line 729
            which ++;
#line 730
            goto while_continue;
          }
#line 732
          olduse[which] = 1;
#line 733
          warn_disk = 1;
#line 734
          force = 1;
        } else {
#line 736
          olduse[which] = 0;
        }
#line 737
        which ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
  {
#line 740
  do_loop(force);
#line 741
  signal(14, (void (*)(int  ))(& loop));
#line 742
  setitimer(0, (struct itimerval  const  */* __restrict  */)(& timval), (struct itimerval */* __restrict  */)0);
#line 743
  inv ++;
  }
#line 744
  return;
}
}
#line 747 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.c"
void drawnum(float ld ) 
{ 
  char loadstring[9] ;
  int x ;
  int tmp ;

  {
  {
#line 753
  tmp = XTextWidth(font2, (char const   *)(loadstring), 4);
#line 753
  x = (int )((width - (unsigned int )tmp) / 2U + 1U);
#line 754
  XClearArea(disp, win, 2, 2, width - 3U, (unsigned int )loadheight, 0);
#line 755
  sprintf((char */* __restrict  */)(loadstring), (char const   */* __restrict  */)"%f",
          (double )ld);
#line 756
  XDrawString(disp, win, ggc, x, loadheight, (char const   *)(loadstring), 4);
  }
#line 757
  return;
}
}
#line 763 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.c"
void dosizecursor(int w , int h , char sep , XColor *col ) 
{ 
  int width___0 ;
  int height___0 ;
  Pixmap pix ;
  Pixmap mask ;
  GC gc___0 ;
  XGCValues gcv ;
  XSetWindowAttributes wattr ;
  unsigned long msk ;
  char geom[15] ;
  XPoint points[3] ;
  size_t tmp ;
  int tmp___0 ;
  size_t tmp___1 ;

  {
#line 774
  if (nogeom) {
#line 775
    return;
  }
  {
#line 776
  sprintf((char */* __restrict  */)(geom), (char const   */* __restrict  */)"%d%c%d",
          w, (int )sep, h);
#line 780
  tmp = strlen((char const   *)(geom));
#line 780
  tmp___0 = XTextWidth(pfont, (char const   *)(geom), (int )tmp);
#line 780
  width___0 = tmp___0 + 7;
#line 781
  height___0 = ((int )pfont->max_bounds.ascent + (int )pfont->max_bounds.descent) + 2;
#line 782
  pix = XCreatePixmap(disp, root, (unsigned int )width___0, (unsigned int )height___0,
                      1U);
#line 783
  mask = XCreatePixmap(disp, root, (unsigned int )width___0, (unsigned int )height___0,
                       1U);
#line 785
  msk = (unsigned long )((1L << 2) | (1L << 14));
#line 786
  gcv.foreground = 0UL;
#line 787
  gcv.font = pfont->fid;
#line 788
  gc___0 = XCreateGC(disp, pix, msk, & gcv);
#line 790
  XFillRectangle(disp, mask, gc___0, 0, 0, (unsigned int )width___0, (unsigned int )height___0);
#line 791
  XFillRectangle(disp, pix, gc___0, 0, 0, (unsigned int )width___0, (unsigned int )height___0);
#line 793
  XSetForeground(disp, gc___0, 1UL);
#line 794
  points[0].y = (short)0;
#line 794
  points[0].x = points[0].y;
#line 795
  points[2].x = (short)2;
#line 795
  points[1].y = points[2].x;
#line 796
  points[2].y = (short)5;
#line 796
  points[1].x = points[2].y;
#line 797
  XFillPolygon(disp, mask, gc___0, points, 3, 2, 0);
#line 798
  tmp___1 = strlen((char const   *)(geom));
#line 798
  XDrawString(disp, mask, gc___0, 6, height___0 - 1, (char const   *)(geom), (int )tmp___1);
#line 800
  wattr.cursor = XCreatePixmapCursor(disp, pix, mask, col, col, 0U, 0U);
#line 801
  msk = (unsigned long )(1L << 14);
#line 802
  XChangeWindowAttributes(disp, win, msk, & wattr);
#line 804
  XFreePixmap(disp, pix);
#line 805
  XFreePixmap(disp, mask);
#line 806
  XFreeGC(disp, gc___0);
  }
#line 807
  return;
}
}
#line 812 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.c"
void Getgeom(Window win___0 , int *x , int *y , unsigned int *width___0 , unsigned int *h ) 
{ 
  int xr ;
  int yr ;
  unsigned int bwr ;
  unsigned int dr ;
  Window rr ;

  {
  {
#line 819
  XGetGeometry(disp, win___0, & rr, & xr, & yr, width___0, h, & bwr, & dr);
#line 820
  XTranslateCoordinates(disp, win___0, root, 0, 0, x, y, & rr);
  }
#line 821
  return;
}
}
#line 824 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.c"
void dobevels(Window win___0 , int x , int y , int w , int h , GC top , GC bot ) 
{ 
  XPoint points1[3] ;
  XPoint points2[3] ;

  {
  {
#line 830
  points1[1].x = (short )x;
#line 830
  points1[0].x = points1[1].x;
#line 831
  points1[2].y = (short )y;
#line 831
  points1[1].y = points1[2].y;
#line 832
  points1[0].y = (short )((y + h) - 1);
#line 833
  points1[2].x = (short )((x + w) - 1);
#line 835
  points2[0].x = (short )x;
#line 836
  points2[1].y = (short )((y + h) - 1);
#line 836
  points2[0].y = points2[1].y;
#line 837
  points2[2].x = (short )((x + w) - 1);
#line 837
  points2[1].x = points2[2].x;
#line 838
  points2[2].y = (short )(y + 1);
#line 839
  XDrawLines(disp, win___0, top, points1, 3, 0);
#line 840
  XDrawLines(disp, win___0, bot, points2, 3, 0);
  }
#line 841
  return;
}
}
#line 854 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.c"
static char *string  ;
#line 851 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.c"
char *commanum(long num ) 
{ 
  int i ;
  int z ;
  int ln ;
  char *number ;
  void *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 852
  i = 0;
#line 852
  z = 0;
#line 857
  tmp = malloc((size_t )64);
#line 857
  number = (char *)tmp;
#line 858
  sprintf((char */* __restrict  */)number, (char const   */* __restrict  */)"%ld",
          num);
#line 859
  tmp___0 = strlen((char const   *)number);
#line 859
  ln = (int )tmp___0;
  }
#line 860
  if (! string) {
    {
#line 861
    tmp___1 = malloc((size_t )64);
#line 861
    string = (char *)tmp___1;
    }
  }
#line 862
  if (ln < 4) {
    {
#line 863
    sprintf((char */* __restrict  */)string, (char const   */* __restrict  */)"%ld",
            num);
#line 864
    free((void *)number);
    }
#line 865
    return (string);
  }
#line 867
  i = 0;
  {
#line 867
  while (1) {
    while_continue: /* CIL Label */ ;
#line 867
    if (! (i < ln)) {
#line 867
      goto while_break;
    }
#line 868
    if ((ln - i) % 3 == 0) {
#line 868
      if (i < ln - 1) {
#line 868
        if (i > 0) {
#line 869
          tmp___2 = z;
#line 869
          z ++;
#line 869
          *(string + tmp___2) = (char )',';
        }
      }
    }
#line 870
    tmp___3 = z;
#line 870
    z ++;
#line 870
    *(string + tmp___3) = *(number + i);
#line 867
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 872
  tmp___4 = z;
#line 872
  z ++;
#line 872
  *(string + tmp___4) = (char )'\000';
#line 873
  free((void *)number);
  }
#line 874
  return (string);
}
}
#line 81 "/usr/include/x86_64-linux-gnu/sys/utsname.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) uname)(struct utsname *__name ) ;
#line 31 "/usr/include/x86_64-linux-gnu/sys/statfs.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) statfs)(char const   *__file ,
                                                                                               struct statfs *__buf ) ;
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 425
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...)  __asm__("__isoc99_fscanf")  ;
#line 137 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 334 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                __off_t __offset ,
                                                                                int __whence ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 972
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) sync)(void) ;
#line 54 "/home/wheatley/newnew/temp/loadmeter-1.20/loadmeter.h"
void GetUptime(char *ut ) ;
#line 55
void GetMemInfo(void) ;
#line 21 "/home/wheatley/newnew/temp/loadmeter-1.20/getinfo.c"
int fd  ;
#line 21 "/home/wheatley/newnew/temp/loadmeter-1.20/getinfo.c"
int ud  ;
#line 23 "/home/wheatley/newnew/temp/loadmeter-1.20/getinfo.c"
void Doinit(char *label ) 
{ 
  struct utsname *host ;
  void *tmp ;

  {
  {
#line 70
  fd = open("/proc/loadavg", 0);
#line 71
  ud = open("/proc/uptime", 0);
  }
#line 74
  if ((unsigned long )label == (unsigned long )((void *)0)) {
    {
#line 76
    tmp = malloc(sizeof(struct utsname ));
#line 76
    host = (struct utsname *)tmp;
#line 77
    uname(host);
#line 78
    strcpy((char */* __restrict  */)(hostname), (char const   */* __restrict  */)(host->nodename));
#line 79
    free((void *)host);
    }
  } else {
    {
#line 82
    strcpy((char */* __restrict  */)(hostname), (char const   */* __restrict  */)label);
    }
  }
#line 83
  return;
}
}
#line 86 "/home/wheatley/newnew/temp/loadmeter-1.20/getinfo.c"
void GetLoadPoint(double *avg___0 , double *oavg , double *davg___0 , int *numps ) 
{ 
  char buf___2[25] ;
  int crap ;

  {
  {
#line 107
  lseek(fd, (__off_t )0, 0);
#line 108
  read(fd, (void *)(buf___2), sizeof(buf___2) - 1UL);
#line 109
  sscanf((char const   */* __restrict  */)(buf___2), (char const   */* __restrict  */)"%lf %lf %lf %d/%d",
         avg___0, oavg, davg___0, & crap, numps);
  }
#line 111
  return;
}
}
#line 116 "/home/wheatley/newnew/temp/loadmeter-1.20/getinfo.c"
static char buf[35]  ;
#line 114 "/home/wheatley/newnew/temp/loadmeter-1.20/getinfo.c"
void GetUptime(char *ut ) 
{ 
  double uptime ;
  int hr ;
  int min ;
  int num ;
  char *plural ;

  {
  {
#line 118
  hr = 0;
#line 118
  min = 0;
#line 119
  plural = (char *)"";
#line 125
  bzero((void *)ut, (size_t )20);
#line 126
  lseek(ud, (__off_t )0, 0);
#line 128
  read(ud, (void *)(buf), sizeof(buf) - 1UL);
#line 129
  sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"%lf",
         & uptime);
#line 131
  sprintf((char */* __restrict  */)ut, (char const   */* __restrict  */)"%s up ",
          hostname);
  }
#line 133
  if (uptime > (double )86400) {
#line 135
    num = (int )uptime / 86400;
#line 137
    if (num > 1) {
#line 138
      plural = (char *)"s";
    }
    {
#line 139
    sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%d day%s, ",
            num, plural);
#line 140
    uptime -= (double )(num * 86400);
#line 141
    strcat((char */* __restrict  */)ut, (char const   */* __restrict  */)(buf));
    }
  }
#line 143
  if (uptime > (double )3600) {
#line 145
    hr = (int )uptime / 3600;
#line 146
    uptime -= (double )(hr * 3600);
  }
#line 148
  min = (int )uptime / 60;
#line 149
  if (hr > 0) {
    {
#line 150
    sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%d:%02d",
            hr, min);
    }
  } else {
    {
#line 152
    sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%02d min",
            min);
    }
  }
  {
#line 153
  strcat((char */* __restrict  */)ut, (char const   */* __restrict  */)(buf));
  }
#line 154
  return;
}
}
#line 156 "/home/wheatley/newnew/temp/loadmeter-1.20/getinfo.c"
void GetMemInfo(void) 
{ 
  FILE *meminfo ;
  char *what ;
  long use ;
  long stot ;
  long sfree ;
  long mtot ;
  long mfree ;
  long mcache ;
  long mbuf ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  long tmp___7 ;

  {
  {
#line 161
  use = 0L;
#line 163
  stot = 0L;
#line 163
  sfree = 0L;
#line 163
  mtot = 0L;
#line 163
  mfree = 0L;
#line 163
  mcache = 0L;
#line 163
  mbuf = 0L;
#line 193
  meminfo = fopen((char const   */* __restrict  */)"/proc/meminfo", (char const   */* __restrict  */)"r");
#line 194
  tmp = malloc((size_t )25);
#line 194
  what = (char *)tmp;
  }
  {
#line 195
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 195
    tmp___6 = fscanf((FILE */* __restrict  */)meminfo, (char const   */* __restrict  */)"%s %ld",
                     what, & use);
    }
#line 195
    if (! (tmp___6 != -1)) {
#line 195
      goto while_break;
    }
    {
#line 197
    tmp___5 = strncmp((char const   *)what, "SwapTotal", (size_t )9);
    }
#line 197
    if (tmp___5 == 0) {
#line 198
      stot = use;
    } else {
      {
#line 199
      tmp___4 = strncmp((char const   *)what, "SwapFree", (size_t )8);
      }
#line 199
      if (tmp___4 == 0) {
#line 200
        sfree = use;
      } else {
        {
#line 201
        tmp___3 = strncmp((char const   *)what, "MemTotal", (size_t )8);
        }
#line 201
        if (tmp___3 == 0) {
#line 202
          mtot = use;
        } else {
          {
#line 203
          tmp___2 = strncmp((char const   *)what, "MemFree", (size_t )7);
          }
#line 203
          if (tmp___2 == 0) {
#line 204
            mfree = use;
          } else {
            {
#line 205
            tmp___1 = strncmp((char const   *)what, "MemShared", (size_t )8);
            }
#line 205
            if (tmp___1 == 0) {
#line 206
              mbuf = use;
            } else {
              {
#line 207
              tmp___0 = strcmp((char const   *)what, "Cached:");
              }
#line 207
              if (tmp___0 == 0) {
#line 208
                mcache = use;
              }
            }
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 211
  memory.swaptotal = stot;
#line 212
  memory.swapfree = sfree;
#line 213
  memory.memtotal = mtot;
#line 214
  memory.memfree = mfree;
#line 215
  memory.cached = mcache;
#line 216
  memory.shared = mbuf;
#line 217
  sprintf((char */* __restrict  */)memory.muse, (char const   */* __restrict  */)"Memory used: %ld%%",
          (((mtot - mfree) - mcache) * 100L) / mtot);
  }
#line 218
  if (stot) {
#line 218
    tmp___7 = ((stot - sfree) * 100L) / stot;
  } else {
#line 218
    tmp___7 = 0L;
  }
  {
#line 218
  sprintf((char */* __restrict  */)memory.suse, (char const   */* __restrict  */)"Swap used:   %ld%%",
          tmp___7);
#line 220
  free((void *)what);
#line 221
  fclose(meminfo);
  }
#line 223
  return;
}
}
#line 225 "/home/wheatley/newnew/temp/loadmeter-1.20/getinfo.c"
static void safefree(void **ptr ) 
{ 


  {
#line 227
  if ((unsigned long )*ptr != (unsigned long )((void *)0)) {
    {
#line 229
    free(*ptr);
#line 230
    *ptr = (void *)0;
    }
  }
#line 232
  return;
}
}
#line 248 "/home/wheatley/newnew/temp/loadmeter-1.20/getinfo.c"
static time_t tm  =    (time_t )0;
#line 239 "/home/wheatley/newnew/temp/loadmeter-1.20/getinfo.c"
void GetDiskUsage(void) 
{ 
  FILE *mtab ;
  struct statfs buf___2 ;
  int which ;
  char dev[256] ;
  char path[256] ;
  char type[256] ;
  time_t tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 258
  tmp = time((time_t *)((void *)0));
  }
#line 258
  if (tmp - tm < 10L) {
#line 259
    return;
  }
  {
#line 260
  mtab = fopen((char const   */* __restrict  */)"/proc/mounts", (char const   */* __restrict  */)"r");
  }
#line 261
  if ((unsigned long )mtab == (unsigned long )((void *)0)) {
    {
#line 263
    printf((char const   */* __restrict  */)"Cannot open %s!\n", "/proc/mounts");
#line 264
    exit(1);
    }
  }
#line 266
  if (dosync) {
    {
#line 267
    sync();
    }
  }
#line 268
  which = 0;
  {
#line 268
  while (1) {
    while_continue: /* CIL Label */ ;
#line 268
    if (! (which < 20)) {
#line 268
      goto while_break;
    }
    {
#line 270
    safefree((void **)(& usages[which].path));
#line 271
    safefree((void **)(& usages[which].dev));
#line 272
    safefree((void **)(& usages[which].type));
#line 268
    which ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 275
  which = 0;
  {
#line 277
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 277
    tmp___4 = fscanf((FILE */* __restrict  */)mtab, (char const   */* __restrict  */)"%s %s %s ",
                     dev, path, type);
    }
#line 277
    if (! (tmp___4 != -1)) {
#line 277
      goto while_break___0;
    }
    {
#line 283
    tmp___0 = strcmp((char const   *)(type), "proc");
    }
#line 283
    if (tmp___0 == 0) {
#line 284
      goto while_continue___0;
    }
    {
#line 285
    tmp___1 = strchr((char const   *)(dev), '/');
    }
#line 285
    if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
      {
#line 285
      tmp___2 = strcmp((char const   *)(dev), "rootfs");
      }
#line 285
      if (tmp___2 != 0) {
#line 286
        goto while_continue___0;
      }
    }
    {
#line 288
    tmp___3 = statfs((char const   *)(path), & buf___2);
    }
#line 288
    if (tmp___3 != 0) {
#line 292
      goto while_continue___0;
    }
#line 293
    if (which >= 20) {
      {
#line 294
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"More than %d filesystems - ignoring the rest.\n(Edit MAXFILESYSTEMS in loadmeter.h to fix)\n",
              20);
      }
#line 295
      goto while_break___0;
    }
    {
#line 297
    usages[which].path = strdup((char const   *)(path));
#line 298
    usages[which].dev = strdup((char const   *)(dev));
#line 299
    usages[which].type = strdup((char const   *)(type));
#line 301
    usages[which].blocks = (long )(((float )buf___2.f_blocks * (float )buf___2.f_bsize) / (float )1024);
#line 302
    usages[which].bfree = (long )(((float )buf___2.f_bavail * (float )buf___2.f_bsize) / (float )1024);
#line 310
    which ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 312
  usages[which].blocks = 0L;
#line 313
  usages[which].path = (char *)((void *)0);
#line 314
  tm = time((time_t *)((void *)0));
#line 315
  fclose(mtab);
  }
#line 316
  return;
}
}
#line 1648 "/usr/include/X11/Xlib.h"
extern Window XCreateWindow(Display * , Window  , int  , int  , unsigned int  , unsigned int  ,
                            unsigned int  , int  , unsigned int  , Visual * , unsigned long  ,
                            XSetWindowAttributes * ) ;
#line 2255
extern int XDestroyWindow(Display * , Window  ) ;
#line 2741
extern int XGrabPointer(Display * , Window  , int  , unsigned int  , int  , int  ,
                        Window  , Cursor  , Time  ) ;
#line 3493
extern int XUngrabPointer(Display * , Time  ) ;
#line 460 "/usr/include/unistd.h"
extern int usleep(__useconds_t __useconds ) ;
#line 3 "/home/wheatley/newnew/temp/loadmeter-1.20/popup.c"
void checkgeom(int *x , int *y , int *w , int *h ) ;
#line 3
void Meminfo(int which ) ;
#line 4 "/home/wheatley/newnew/temp/loadmeter-1.20/popup.c"
static char *utime  =    (char *)((void *)0);
#line 5 "/home/wheatley/newnew/temp/loadmeter-1.20/popup.c"
int omask  =    65535;
#line 6 "/home/wheatley/newnew/temp/loadmeter-1.20/popup.c"
int longest  ;
#line 16 "/home/wheatley/newnew/temp/loadmeter-1.20/popup.c"
static char *buf___0  =    (char *)((void *)0);
#line 17 "/home/wheatley/newnew/temp/loadmeter-1.20/popup.c"
static char *lbuf  =    (char *)((void *)0);
#line 13 "/home/wheatley/newnew/temp/loadmeter-1.20/popup.c"
void do_popup(void) 
{ 
  unsigned int wr ;
  unsigned int h ;
  unsigned int w ;
  int which ;
  int numfs ;
  int ht ;
  int x ;
  int y ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;
  size_t tmp___10 ;
  int tmp___11 ;

  {
#line 18
  numfs = 0;
#line 20
  if (popup != 0UL) {
    {
#line 21
    XDestroyWindow(disp, popup);
    }
  }
#line 22
  if ((unsigned long )utime == (unsigned long )((void *)0)) {
    {
#line 23
    tmp = malloc((size_t )64);
#line 23
    utime = (char *)tmp;
    }
  }
#line 24
  if ((unsigned long )buf___0 == (unsigned long )((void *)0)) {
    {
#line 25
    tmp___0 = malloc((size_t )64);
#line 25
    buf___0 = (char *)tmp___0;
    }
  }
#line 26
  if ((unsigned long )lbuf == (unsigned long )((void *)0)) {
    {
#line 27
    tmp___1 = malloc((size_t )64);
#line 27
    lbuf = (char *)tmp___1;
    }
  }
  {
#line 28
  GetUptime(utime);
#line 29
  GetDiskUsage();
#line 30
  GetMemInfo();
#line 31
  sprintf((char */* __restrict  */)lbuf, (char const   */* __restrict  */)"%.2f %.2f %.2f",
          load, avg, davg);
#line 32
  tmp___2 = strlen((char const   *)lbuf);
#line 32
  longest = (int )tmp___2;
#line 33
  tmp___3 = XTextWidth(pfont, (char const   *)lbuf, longest);
#line 33
  pwidth = (unsigned int )(tmp___3 + 5);
#line 35
  which = 0;
  }
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
#line 36
    if ((unsigned long )usages[which].path != (unsigned long )((void *)0)) {
#line 36
      if (! (which < 20)) {
#line 36
        goto while_break;
      }
    } else {
#line 36
      goto while_break;
    }
    {
#line 37
    numfs ++;
#line 38
    sprintf((char */* __restrict  */)buf___0, (char const   */* __restrict  */)"%s: %.1f%%",
            usages[which].path, (double )(((float )(usages[which].blocks - usages[which].bfree) * (float )100) / (float )usages[which].blocks));
#line 41
    tmp___4 = strlen((char const   *)buf___0);
#line 41
    ht = (int )tmp___4;
#line 42
    tmp___5 = XTextWidth(pfont, (char const   *)buf___0, ht);
#line 42
    wr = (unsigned int )(tmp___5 + 5);
    }
#line 43
    if (wr > pwidth) {
#line 44
      pwidth = wr;
    }
#line 45
    if (ht > longest) {
#line 46
      longest = ht;
    }
#line 47
    which ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 49
  tmp___6 = strlen((char const   *)memory.suse);
#line 49
  tmp___7 = XTextWidth(pfont, (char const   *)memory.suse, (int )tmp___6);
#line 49
  wr = (unsigned int )(tmp___7 + 5);
  }
#line 50
  if (wr > pwidth) {
#line 51
    pwidth = wr;
  }
  {
#line 52
  tmp___8 = strlen((char const   *)memory.muse);
#line 52
  tmp___9 = XTextWidth(pfont, (char const   *)memory.muse, (int )tmp___8);
#line 52
  wr = (unsigned int )(tmp___9 + 5);
  }
#line 53
  if (wr > pwidth) {
#line 54
    pwidth = wr;
  }
  {
#line 55
  tmp___10 = strlen((char const   *)utime);
#line 55
  ht = (int )tmp___10;
#line 56
  tmp___11 = XTextWidth(pfont, (char const   *)utime, ht);
#line 56
  wr = (unsigned int )(tmp___11 + 5);
  }
#line 57
  if (wr > pwidth) {
#line 58
    pwidth = wr;
  }
#line 59
  if (ht > longest) {
#line 60
    longest = ht;
  }
  {
#line 61
  ht = (int )pfont->max_bounds.ascent + (int )pfont->max_bounds.descent;
#line 62
  pheight = (unsigned int )((numfs + 4) * ht + 9);
#line 64
  Getgeom(win, & x, & y, & w, & h);
#line 65
  pw = pwidth;
#line 66
  ph = pheight;
#line 67
  y = (int )((unsigned int )y + (h + 1U));
#line 69
  checkgeom(& x, & y, & pwidth, & pheight);
#line 70
  popup = MakePopup(x, y, pwidth, pheight, popbg.pixel, 0);
#line 72
  XGrabPointer(disp, popup, 1, (unsigned int )((1L << 3) | (1L << 6)), 1, 1, (Window )0L,
               (Cursor )0L, (Time )0L);
#line 74
  draw_popup(0);
  }
#line 75
  return;
}
}
#line 81 "/home/wheatley/newnew/temp/loadmeter-1.20/popup.c"
static char buf___1[128]  ;
#line 81 "/home/wheatley/newnew/temp/loadmeter-1.20/popup.c"
static char lbuf___0[64]  ;
#line 81 "/home/wheatley/newnew/temp/loadmeter-1.20/popup.c"
static char bf[8]  ;
#line 82 "/home/wheatley/newnew/temp/loadmeter-1.20/popup.c"
static int hprev  =    0;
#line 77 "/home/wheatley/newnew/temp/loadmeter-1.20/popup.c"
void draw_popup(int highlight ) 
{ 
  int yt ;
  int ln ;
  int ht ;
  int x ;
  int wr ;
  int which ;
  float pct ;
  size_t tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;

  {
  {
#line 79
  which = 0;
#line 85
  tmp = strlen((char const   *)utime);
#line 85
  tmp___0 = XTextWidth(pfont, (char const   *)utime, (int )tmp);
#line 85
  wr = tmp___0 + 5;
#line 86
  yt = (int )pfont->max_bounds.ascent + 1;
#line 87
  ht = (int )pfont->max_bounds.ascent + (int )pfont->max_bounds.descent;
#line 89
  x = (int )(pwidth / 2U - (unsigned int )((wr - 5) / 2));
#line 90
  tmp___1 = strlen((char const   *)utime);
#line 90
  XDrawString(disp, popup, ptextgc, x + 1, yt, (char const   *)utime, (int )tmp___1);
#line 91
  yt += (int )pfont->max_bounds.descent;
#line 93
  XClearArea(disp, popup, 1, yt, pwidth - 2U, (unsigned int )yt, 0);
#line 94
  yt += (int )pfont->max_bounds.ascent + 1;
#line 95
  sprintf((char */* __restrict  */)(lbuf___0), (char const   */* __restrict  */)"%.2f %.2f %.2f",
          load, avg, davg);
#line 96
  tmp___2 = strlen((char const   *)(lbuf___0));
#line 96
  wr = XTextWidth(pfont, (char const   *)(lbuf___0), (int )tmp___2);
#line 97
  x = (int )(pwidth / 2U - (unsigned int )((wr - 5) / 2));
#line 98
  tmp___3 = strlen((char const   *)(lbuf___0));
#line 98
  XDrawString(disp, popup, ptextgc, x + 1, yt, (char const   *)(lbuf___0), (int )tmp___3);
#line 100
  yt += (int )pfont->max_bounds.descent + 1;
#line 101
  XDrawLine(disp, popup, popbgc, 1, yt, (int )(pwidth - 1U), yt);
#line 102
  XDrawLine(disp, popup, poptgc, 1, yt + 1, (int )(pwidth - 1U), yt + 1);
#line 103
  yt += 2;
  }
  {
#line 105
  while (1) {
    while_continue: /* CIL Label */ ;
#line 105
    if ((unsigned long )usages[which].path != (unsigned long )((void *)0)) {
#line 105
      if (! (which < 20)) {
#line 105
        goto while_break;
      }
    } else {
#line 105
      goto while_break;
    }
    {
#line 107
    pct = ((float )(usages[which].blocks - usages[which].bfree) * (float )100) / (float )usages[which].blocks;
#line 108
    sprintf((char */* __restrict  */)(bf), (char const   */* __restrict  */)"%.1f%%",
            (double )pct);
#line 109
    ln = 0;
    }
    {
#line 109
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 109
      if (! ((int )bf[ln] != 0)) {
#line 109
        goto while_break___0;
      }
#line 109
      ln ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 110
    tmp___4 = strlen((char const   *)usages[which].path);
#line 110
    ln = (int )((size_t )ln + (tmp___4 + 2UL));
#line 111
    wr = 0;
    }
    {
#line 111
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 111
      if (! (wr < longest - ln)) {
#line 111
        goto while_break___1;
      }
#line 112
      lbuf___0[wr] = (char )' ';
#line 111
      wr ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 113
    lbuf___0[wr] = (char )'\000';
#line 114
    sprintf((char */* __restrict  */)(buf___1), (char const   */* __restrict  */)"%s:%s%s",
            usages[which].path, lbuf___0, bf);
    }
#line 116
    if (hprev == which + 1) {
#line 116
      if (menuhl) {
        {
#line 117
        XFillRectangle(disp, popup, popgc, 1, yt, pwidth - 2U, (unsigned int )ht);
        }
      } else {
#line 116
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 118
    if (hprev != 0) {
#line 118
      if (highlight != which + 1) {
#line 118
        if (menuhl) {
#line 120
          yt += (int )pfont->max_bounds.ascent;
#line 121
          yt += (int )pfont->max_bounds.descent;
#line 122
          which ++;
#line 123
          goto while_continue;
        }
      }
    }
#line 125
    if (pct >= (float )warnpct) {
      {
#line 126
      XFillRectangle(disp, popup, warngc, 1, yt, pwidth - 2U, (unsigned int )ht);
      }
    }
#line 127
    if (highlight == which + 1) {
      {
#line 128
      dobevels(popup, 1, yt, pwidth - 2U, ht, poptgc, popbgc);
      }
    }
    {
#line 130
    yt += (int )pfont->max_bounds.ascent;
#line 131
    tmp___5 = strlen((char const   *)(buf___1));
#line 131
    XDrawString(disp, popup, ptextgc, 4, yt, (char const   *)(buf___1), (int )tmp___5);
#line 132
    yt += (int )pfont->max_bounds.descent;
#line 133
    which ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 135
  if (hprev < which) {
#line 135
    if (highlight <= which) {
#line 135
      if (highlight != 0) {
#line 137
        hprev = highlight;
#line 138
        return;
      }
    }
  }
  {
#line 141
  XDrawLine(disp, popup, popbgc, 0, yt, (int )pwidth, yt);
#line 142
  XDrawLine(disp, popup, poptgc, 0, yt + 1, (int )pwidth, yt + 1);
#line 143
  yt += ht + 1;
#line 144
  tmp___6 = strlen((char const   *)memory.muse);
#line 144
  XDrawString(disp, popup, ptextgc, 4, yt, (char const   *)memory.muse, (int )tmp___6);
#line 145
  yt += ht;
#line 146
  tmp___7 = strlen((char const   *)memory.suse);
#line 146
  XDrawString(disp, popup, ptextgc, 4, yt, (char const   *)memory.suse, (int )tmp___7);
#line 148
  dobevels(popup, 0, 0, pwidth, pheight, poptgc, popbgc);
#line 149
  hprev = highlight;
#line 150
  XSync(disp, 0);
  }
#line 151
  return;
}
}
#line 154 "/home/wheatley/newnew/temp/loadmeter-1.20/popup.c"
void do_popdown(void) 
{ 
  int h ;

  {
#line 157
  if (popup == 0UL) {
#line 158
    return;
  }
  {
#line 159
  XUngrabPointer(disp, (Time )0L);
  }
#line 160
  if (info != 0UL) {
    {
#line 161
    XDestroyWindow(disp, info);
    }
  }
#line 162
  info = (Window )0;
#line 164
  h = (int )ph;
  {
#line 164
  while (1) {
    while_continue: /* CIL Label */ ;
#line 164
    if (! (h > 0)) {
#line 164
      goto while_break;
    }
#line 166
    if (! shrinkpopup) {
#line 167
      goto while_break;
    }
    {
#line 169
    XResizeWindow(disp, popup, pw, (unsigned int )h);
#line 170
    XSync(disp, 0);
#line 171
    usleep((__useconds_t )5000);
#line 164
    h -= 8;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 173
  XDestroyWindow(disp, popup);
#line 174
  popup = (Window )0;
  }
#line 175
  return;
}
}
#line 181 "/home/wheatley/newnew/temp/loadmeter-1.20/popup.c"
Window MakePopup(int x , int y , unsigned int w , unsigned int h , unsigned int background ,
                 int bw ) 
{ 
  unsigned long valuemask ;
  XSetWindowAttributes attributes ;
  Window win___0 ;

  {
  {
#line 187
  valuemask = (unsigned long )((((1L << 6) | (1L << 10)) | (1L << 9)) | (1L << 1));
#line 188
  attributes.save_under = 1;
#line 189
  attributes.override_redirect = 1;
#line 190
  attributes.background_pixel = (unsigned long )background;
#line 191
  attributes.backing_store = 1;
#line 192
  win___0 = XCreateWindow(disp, root, x, y, w, h, (unsigned int )bw, 0, 0U, (Visual *)0L,
                          valuemask, & attributes);
#line 195
  XMapWindow(disp, win___0);
  }
#line 196
  return (win___0);
}
}
#line 200 "/home/wheatley/newnew/temp/loadmeter-1.20/popup.c"
void ShowInfo(int which ) 
{ 
  int mask ;
  int wd ;
  unsigned int width___0 ;
  unsigned int height___0 ;
  unsigned int x ;
  unsigned int y ;
  int xr ;
  int yr ;
  int wr ;
  int hr ;
  int ow ;
  int h ;
  float pct ;
  char buf___2[8][50] ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;

  {
#line 209
  mask = 0;
  {
#line 209
  while (1) {
    while_continue: /* CIL Label */ ;
#line 209
    if ((unsigned long )usages[mask].path != (unsigned long )((void *)0)) {
#line 209
      if (! (mask < 20)) {
#line 209
        goto while_break;
      }
    } else {
#line 209
      goto while_break;
    }
#line 210
    if (which == mask + 1) {
#line 211
      goto while_break;
    }
#line 209
    mask ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 213
  if ((unsigned long )usages[mask].path == (unsigned long )((void *)0)) {
#line 215
    if (which < mask) {
      {
#line 217
      infodown();
      }
#line 218
      return;
    } else
#line 215
    if (which < 1) {
      {
#line 217
      infodown();
      }
#line 218
      return;
    } else {
      {
#line 220
      Meminfo(mask + 1);
      }
#line 221
      return;
    }
  }
  {
#line 224
  infodown();
#line 226
  height___0 = (unsigned int )(((int )pfont->max_bounds.ascent + (int )pfont->max_bounds.descent) * 9 + 7);
#line 228
  pct = ((float )(usages[mask].blocks - usages[mask].bfree) * (float )100) / (float )usages[mask].blocks;
#line 230
  sprintf((char */* __restrict  */)(buf___2[0]), (char const   */* __restrict  */)"Filesystem info for");
#line 231
  sprintf((char */* __restrict  */)(buf___2[2]), (char const   */* __restrict  */)"Device: %s",
          usages[mask].dev);
#line 232
  sprintf((char */* __restrict  */)(buf___2[3]), (char const   */* __restrict  */)"Type:   %s",
          usages[mask].type);
#line 233
  sprintf((char */* __restrict  */)(buf___2[1]), (char const   */* __restrict  */)"%s",
          usages[mask].path);
#line 234
  tmp = commanum(usages[mask].blocks);
#line 234
  sprintf((char */* __restrict  */)(buf___2[4]), (char const   */* __restrict  */)"Total:  %s Kb",
          tmp);
#line 235
  tmp___0 = commanum(usages[mask].blocks - usages[mask].bfree);
#line 235
  sprintf((char */* __restrict  */)(buf___2[5]), (char const   */* __restrict  */)"Used:   %s Kb",
          tmp___0);
#line 236
  tmp___1 = commanum(usages[mask].bfree);
#line 236
  sprintf((char */* __restrict  */)(buf___2[6]), (char const   */* __restrict  */)"Free:   %s Kb",
          tmp___1);
#line 237
  sprintf((char */* __restrict  */)(buf___2[7]), (char const   */* __restrict  */)"Capacity: %.1f%%",
          (double )pct);
#line 240
  width___0 = 0U;
#line 240
  ow = (int )width___0;
#line 241
  mask = 0;
  }
  {
#line 241
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 241
    if (! (mask < 7)) {
#line 241
      goto while_break___0;
    }
    {
#line 243
    tmp___2 = strlen((char const   *)(buf___2[mask]));
#line 243
    wd = (int )tmp___2;
    }
#line 244
    if (wd > ow) {
      {
#line 246
      tmp___3 = XTextWidth(pfont, (char const   *)(buf___2[mask]), wd);
#line 246
      width___0 = (unsigned int )(tmp___3 + 5);
#line 247
      ow = wd;
      }
    }
#line 241
    mask ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 251
  Getgeom(popup, & xr, & yr, & wr, & hr);
#line 252
  x = (unsigned int )((xr + wr) - 10);
#line 253
  y = (unsigned int )((yr + (which + 1) * ((int )pfont->max_bounds.ascent + (int )pfont->max_bounds.descent)) + 4);
#line 255
  checkgeom(& x, & y, & width___0, & height___0);
#line 256
  info = MakePopup((int )x, (int )y, width___0, height___0, (unsigned int )popbg.pixel,
                   0);
#line 258
  y = (unsigned int )((int )pfont->max_bounds.ascent + 1);
#line 259
  tmp___4 = strlen((char const   *)(buf___2[0]));
#line 259
  tmp___5 = XTextWidth(pfont, (char const   *)(buf___2[0]), (int )tmp___4);
#line 259
  wd = (int )(width___0 / 2U - (unsigned int )(tmp___5 / 2));
#line 260
  tmp___6 = strlen((char const   *)(buf___2[0]));
#line 260
  XDrawString(disp, info, ptextgc, wd + 1, (int )y, (char const   *)(buf___2[0]),
              (int )tmp___6);
#line 261
  y += (unsigned int )(((int )pfont->max_bounds.descent + (int )pfont->max_bounds.ascent) + 1);
#line 262
  tmp___7 = strlen((char const   *)(buf___2[1]));
#line 262
  tmp___8 = XTextWidth(pfont, (char const   *)(buf___2[1]), (int )tmp___7);
#line 262
  wd = (int )(width___0 / 2U - (unsigned int )(tmp___8 / 2));
#line 263
  tmp___9 = strlen((char const   *)(buf___2[1]));
#line 263
  XDrawString(disp, info, ptextgc, wd + 1, (int )y, (char const   *)(buf___2[1]),
              (int )tmp___9);
#line 264
  y += (unsigned int )((int )pfont->max_bounds.descent + 1);
#line 265
  XDrawLine(disp, info, popbgc, 0, (int )y, (int )width___0, (int )y);
#line 266
  XDrawLine(disp, info, poptgc, 0, (int )(y + 1U), (int )width___0, (int )(y + 1U));
#line 267
  y += (unsigned int )((int )pfont->max_bounds.ascent + 2);
#line 269
  mask = 2;
  }
  {
#line 269
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 269
    if (! (mask < 8)) {
#line 269
      goto while_break___1;
    }
    {
#line 271
    tmp___10 = strlen((char const   *)(buf___2[mask]));
#line 271
    XDrawString(disp, info, ptextgc, 3, (int )y, (char const   *)(buf___2[mask]),
                (int )tmp___10);
#line 273
    y += (unsigned int )((int )pfont->max_bounds.ascent + (int )pfont->max_bounds.descent);
#line 269
    mask ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 276
  y ++;
#line 277
  wd = (int )(width___0 / 2U - ((3U * width___0) / 4U) / 2U);
#line 278
  h = ((int )pfont->max_bounds.ascent + (int )pfont->max_bounds.descent) - 1;
#line 279
  ow = (int )((3U * width___0) / 4U);
#line 280
  wr = XTextWidth(pfont, "E", 1);
#line 282
  XDrawString(disp, info, ptextgc, (wd - wr) - 1, (int )y, "E", 1);
#line 283
  dobevels(info, wd, y - (unsigned int )pfont->max_bounds.ascent, ow, h, popbgc, poptgc);
#line 285
  XFillRectangle(disp, info, metergc, wd + 1, (int )((y + 1U) - (unsigned int )pfont->max_bounds.ascent),
                 (unsigned int )(((float )ow * pct) / (float )100), (unsigned int )(h - 2));
#line 287
  XDrawString(disp, info, ptextgc, (wd + ow) + 2, (int )y, "F", 1);
#line 288
  dobevels(info, 0, 0, width___0, height___0, poptgc, popbgc);
#line 289
  XSync(disp, 0);
  }
#line 290
  return;
}
}
#line 293 "/home/wheatley/newnew/temp/loadmeter-1.20/popup.c"
void infodown(void) 
{ 


  {
#line 295
  if (info == 0UL) {
#line 296
    return;
  }
  {
#line 297
  XDestroyWindow(disp, info);
#line 298
  omask = 65535;
#line 299
  info = (Window )0;
  }
#line 300
  return;
}
}
#line 306 "/home/wheatley/newnew/temp/loadmeter-1.20/popup.c"
void checkgeom(int *x , int *y , int *w , int *h ) 
{ 


  {
#line 309
  if ((unsigned int )(*x + *w) > rwidth) {
#line 310
    *x = (int )(rwidth - (unsigned int )*w);
  }
#line 311
  if ((unsigned int )(*y + *h) > rheight) {
#line 312
    *y = (int )(rheight - (unsigned int )*h);
  }
#line 313
  return;
}
}
#line 316 "/home/wheatley/newnew/temp/loadmeter-1.20/popup.c"
void Meminfo(int which ) 
{ 
  int x ;
  int y ;
  int height___0 ;
  int width___0 ;
  char buf___2[7][25] ;
  int ow ;
  int mask ;
  int wd ;
  int xr ;
  int yr ;
  int wr ;
  int hr ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  int tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;

  {
#line 329
  if (omask == which + 1) {
#line 329
    if (info != 0UL) {
#line 330
      return;
    } else {
      {
#line 332
      infodown();
      }
    }
  } else {
    {
#line 332
    infodown();
    }
  }
  {
#line 333
  height___0 = ((int )pfont->max_bounds.ascent + (int )pfont->max_bounds.descent) * 7 + 6;
#line 334
  sprintf((char */* __restrict  */)(buf___2[0]), (char const   */* __restrict  */)"Memory info");
#line 335
  tmp = commanum(memory.memtotal);
#line 335
  sprintf((char */* __restrict  */)(buf___2[1]), (char const   */* __restrict  */)"Mem Total:  %s Kb",
          tmp);
#line 336
  tmp___0 = commanum(memory.memfree);
#line 336
  sprintf((char */* __restrict  */)(buf___2[2]), (char const   */* __restrict  */)"Mem Free:   %s Kb",
          tmp___0);
#line 338
  tmp___1 = commanum(memory.shared);
#line 338
  sprintf((char */* __restrict  */)(buf___2[3]), (char const   */* __restrict  */)"Mem Shared: %s Kb",
          tmp___1);
#line 339
  tmp___2 = commanum(memory.cached);
#line 339
  sprintf((char */* __restrict  */)(buf___2[4]), (char const   */* __restrict  */)"Cached:     %s Kb",
          tmp___2);
#line 343
  tmp___3 = commanum(memory.swaptotal);
#line 343
  sprintf((char */* __restrict  */)(buf___2[5]), (char const   */* __restrict  */)"Swap Total: %s Kb",
          tmp___3);
#line 344
  tmp___4 = commanum(memory.swapfree);
#line 344
  sprintf((char */* __restrict  */)(buf___2[6]), (char const   */* __restrict  */)"Swap Free:  %s Kb",
          tmp___4);
#line 346
  width___0 = 0;
#line 346
  ow = width___0;
#line 347
  mask = 0;
  }
  {
#line 347
  while (1) {
    while_continue: /* CIL Label */ ;
#line 347
    if (! (mask < 6)) {
#line 347
      goto while_break;
    }
    {
#line 349
    tmp___5 = strlen((char const   *)(buf___2[mask]));
#line 349
    wd = (int )tmp___5;
    }
#line 350
    if (wd > ow) {
      {
#line 352
      tmp___6 = XTextWidth(pfont, (char const   *)(buf___2[mask]), wd);
#line 352
      width___0 = tmp___6 + 5;
#line 353
      ow = wd;
      }
    }
#line 347
    mask ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 357
  Getgeom(popup, & xr, & yr, & wr, & hr);
#line 358
  x = (xr + wr) - 10;
#line 359
  y = (yr + (which + 1) * ((int )pfont->max_bounds.ascent + (int )pfont->max_bounds.descent)) + 5;
#line 361
  checkgeom(& x, & y, & width___0, & height___0);
#line 362
  info = MakePopup(x, y, (unsigned int )width___0, (unsigned int )height___0, (unsigned int )popbg.pixel,
                   0);
#line 364
  y = (int )pfont->max_bounds.ascent + 1;
#line 365
  tmp___7 = strlen((char const   *)(buf___2[0]));
#line 365
  tmp___8 = XTextWidth(pfont, (char const   *)(buf___2[0]), (int )tmp___7);
#line 365
  wd = width___0 / 2 - tmp___8 / 2;
#line 366
  tmp___9 = strlen((char const   *)(buf___2[0]));
#line 366
  XDrawString(disp, info, ptextgc, wd + 1, y, (char const   *)(buf___2[0]), (int )tmp___9);
#line 367
  y += ((int )pfont->max_bounds.descent + (int )pfont->max_bounds.ascent) + 1;
#line 368
  tmp___10 = strlen((char const   *)(buf___2[1]));
#line 368
  tmp___11 = XTextWidth(pfont, (char const   *)(buf___2[1]), (int )tmp___10);
#line 368
  wd = width___0 / 2 - tmp___11 / 2;
#line 369
  tmp___12 = strlen((char const   *)(buf___2[1]));
#line 369
  XDrawString(disp, info, ptextgc, wd + 1, y, (char const   *)(buf___2[1]), (int )tmp___12);
#line 370
  y += (int )pfont->max_bounds.descent + 1;
#line 371
  XDrawLine(disp, info, popbgc, 0, y, width___0, y);
#line 372
  XDrawLine(disp, info, poptgc, 0, y + 1, width___0, y + 1);
#line 373
  y += (int )pfont->max_bounds.ascent + 2;
#line 375
  mask = 2;
  }
  {
#line 375
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 375
    if (! (mask < 8)) {
#line 375
      goto while_break___0;
    }
#line 377
    if ((int )buf___2[mask][0] == 0) {
#line 378
      goto __Cont;
    }
    {
#line 379
    tmp___13 = strlen((char const   *)(buf___2[mask]));
#line 379
    XDrawString(disp, info, ptextgc, 3, y, (char const   *)(buf___2[mask]), (int )tmp___13);
#line 381
    y += (int )pfont->max_bounds.ascent + (int )pfont->max_bounds.descent;
    }
    __Cont: /* CIL Label */ 
#line 375
    mask ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 383
  XSync(disp, 0);
#line 384
  dobevels(info, 0, 0, width___0, height___0, poptgc, popbgc);
#line 385
  omask = which + 1;
  }
#line 386
  return;
}
}
