/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 44 "/usr/include/x86_64-linux-gnu/sys/stat.h"
typedef __dev_t dev_t;
#line 55 "/usr/include/x86_64-linux-gnu/sys/stat.h"
typedef __ino_t ino_t;
#line 9 "/home/june/repo/benchmarks/collector2/temp/whichman-2.4/statduplcheck.c"
struct stat_info {
   dev_t st_dev ;
   ino_t st_ino ;
};
#line 70 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __mode_t mode_t;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 162
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 7 "/home/june/repo/benchmarks/collector2/temp/whichman-2.4/levdist.h"
int levdist(char const   *iword , char const   *ipattern , int limit , int casesensitive___1 ) ;
#line 8
int stdtolerance(char const   *searchpat ) ;
#line 6 "/home/june/repo/benchmarks/collector2/temp/whichman-2.4/statduplcheck.h"
int is_statduplicate(struct stat  const  *st ) ;
#line 8
void free_statduplicates(void) ;
#line 16 "/home/june/repo/benchmarks/collector2/temp/whichman-2.4/ftwhich.c"
static void help(void) ;
#line 17
static char **splitpath(void) ;
#line 18
static int checkftype(char *path , char *filename ) ;
#line 19
static void matchfilename(char *path , char *key ) ;
#line 20
static int streq(char const   *a , char const   *b ) ;
#line 23 "/home/june/repo/benchmarks/collector2/temp/whichman-2.4/ftwhich.c"
static int printdist  =    0;
#line 24 "/home/june/repo/benchmarks/collector2/temp/whichman-2.4/ftwhich.c"
static int casesensitive  =    0;
#line 25 "/home/june/repo/benchmarks/collector2/temp/whichman-2.4/ftwhich.c"
static int nomatchfound  =    1;
#line 30 "/home/june/repo/benchmarks/collector2/temp/whichman-2.4/ftwhich.c"
static int matchlimit  =    -2;
#line 33 "/home/june/repo/benchmarks/collector2/temp/whichman-2.4/ftwhich.c"
int main(int argc , char **argv ) 
{ 
  char searchkey[257] ;
  char **pathcomp___1 ;
  int optnum ;
  char *c ;
  char *oarg ;
  unsigned short const   **tmp___0 ;

  {
#line 40
  if (argc < 2) {
    {
#line 40
    help();
    }
  }
#line 50
  optnum = argc;
  {
#line 51
  while (1) {
    while_continue: /* CIL Label */ ;
#line 51
    optnum --;
#line 51
    if (! (optnum > 0)) {
#line 51
      goto while_break;
    }
#line 52
    argv ++;
#line 53
    c = *argv;
#line 54
    if ((int )*c != 45) {
#line 55
      argv --;
#line 56
      goto while_break;
    }
#line 58
    c ++;
#line 59
    if ((int )*c == 45) {
#line 59
      if ((int )*(c + 1) == 0) {
#line 63
        optnum --;
#line 64
        goto while_break;
      }
    }
    {
#line 66
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 66
      if (! *c) {
#line 66
        goto while_break___0;
      }
      {
#line 68
      if ((int )*c == 104) {
#line 68
        goto case_104;
      }
#line 71
      if ((int )*c == 112) {
#line 71
        goto case_112;
      }
#line 74
      if ((int )*c == 73) {
#line 74
        goto case_73;
      }
#line 77
      if ((int )*c == 116) {
#line 77
        goto case_116;
      }
#line 88
      goto switch_default;
      case_104: /* CIL Label */ 
      {
#line 69
      help();
      }
      case_112: /* CIL Label */ 
#line 72
      printdist = 1;
#line 73
      c ++;
#line 73
      goto switch_break;
      case_73: /* CIL Label */ 
#line 75
      casesensitive = 1;
#line 76
      c ++;
#line 76
      goto switch_break;
      case_116: /* CIL Label */ 
#line 80
      oarg = c + 1;
#line 82
      if ((int )*(c + 1) == 0) {
#line 83
        optnum --;
#line 83
        if (optnum) {
#line 83
          argv ++;
#line 83
          oarg = *argv;
        }
      }
      {
#line 85
      matchlimit = atoi((char const   *)oarg);
      }
#line 86
      if (matchlimit > 255) {
#line 86
        matchlimit = 255;
      } else
#line 86
      if (matchlimit < 0) {
#line 86
        matchlimit = 255;
      }
#line 87
      *c = (char)0;
#line 87
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 89
      tmp___0 = __ctype_b_loc();
      }
#line 89
      if ((int const   )*(*tmp___0 + (int )*c) & 2048) {
#line 90
        if (matchlimit != -1) {
          {
#line 92
          matchlimit = atoi((char const   *)c);
          }
#line 93
          if (matchlimit > 255) {
#line 93
            matchlimit = 255;
          } else
#line 93
          if (matchlimit < 0) {
#line 93
            matchlimit = 255;
          }
        }
      } else {
        {
#line 96
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR: No such option. Use -h to get help.\n");
#line 97
        exit(1);
        }
      }
#line 99
      *c = (char)0;
      switch_break: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 103
  if (optnum < 0) {
#line 103
    optnum = 0;
  }
#line 113
  if (optnum != 1) {
    {
#line 115
    help();
    }
  }
  {
#line 118
  strncpy((char */* __restrict  */)(searchkey), (char const   */* __restrict  */)*(argv + 1),
          (size_t )256);
  }
#line 119
  if (matchlimit == -2) {
    {
#line 121
    matchlimit = stdtolerance((char const   *)(searchkey));
    }
  }
  {
#line 124
  pathcomp___1 = splitpath();
  }
  {
#line 125
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 125
    if (! *pathcomp___1) {
#line 125
      goto while_break___1;
    }
    {
#line 126
    matchfilename(*pathcomp___1, searchkey);
#line 127
    pathcomp___1 ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 130
  free_statduplicates();
  }
#line 132
  return (nomatchfound);
}
}
#line 145 "/home/june/repo/benchmarks/collector2/temp/whichman-2.4/ftwhich.c"
static char fullpath[500]  ;
#line 142 "/home/june/repo/benchmarks/collector2/temp/whichman-2.4/ftwhich.c"
static int checkftype(char *path , char *filename ) 
{ 
  struct stat stbuf___1 ;
  int i ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 148
  i = 0;
  {
#line 149
  while (1) {
    while_continue: /* CIL Label */ ;
#line 149
    if (*path) {
#line 149
      if (! (i < 493)) {
#line 149
        goto while_break;
      }
    } else {
#line 149
      goto while_break;
    }
#line 150
    fullpath[i] = *path;
#line 151
    i ++;
#line 151
    path ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 153
  if ((int )fullpath[i - 1] != 47) {
#line 154
    fullpath[i] = (char )'/';
#line 155
    i ++;
  }
  {
#line 157
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 157
    if (*filename) {
#line 157
      if (! (i < 499)) {
#line 157
        goto while_break___0;
      }
    } else {
#line 157
      goto while_break___0;
    }
#line 158
    fullpath[i] = *filename;
#line 159
    i ++;
#line 159
    filename ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 161
  fullpath[i] = (char )'\000';
#line 163
  tmp___0 = stat((char const   */* __restrict  */)(fullpath), (struct stat */* __restrict  */)(& stbuf___1));
  }
#line 163
  if (tmp___0 != 0) {
#line 163
    return (0);
  }
#line 165
  if ((stbuf___1.st_mode & 32768U) == 0U) {
#line 165
    return (0);
  }
#line 167
  if (stbuf___1.st_mode & 64U) {
#line 167
    goto _L;
  } else
#line 167
  if (stbuf___1.st_mode & (unsigned int )(64 >> 3)) {
#line 167
    goto _L;
  } else
#line 167
  if (stbuf___1.st_mode & (unsigned int )((64 >> 3) >> 3)) {
    _L: /* CIL Label */ 
    {
#line 169
    tmp___1 = is_statduplicate((struct stat  const  *)(& stbuf___1));
    }
#line 169
    if (tmp___1) {
#line 169
      return (0);
    }
  }
#line 170
  return (1);
}
}
#line 177 "/home/june/repo/benchmarks/collector2/temp/whichman-2.4/ftwhich.c"
static void matchfilename(char *path , char *key ) 
{ 
  int dist ;
  DIR *dp ;
  struct dirent *entry ;
  int tmp___0 ;

  {
  {
#line 182
  dp = opendir((char const   *)path);
  }
#line 182
  if ((unsigned long )dp != (unsigned long )((void *)0)) {
    {
#line 183
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 183
      entry = readdir(dp);
      }
#line 183
      if (! ((unsigned long )entry != (unsigned long )((void *)0))) {
#line 183
        goto while_break;
      }
#line 185
      if ((int )entry->d_name[0] == 46) {
#line 185
        goto while_continue;
      }
      {
#line 186
      dist = levdist((char const   *)(entry->d_name), (char const   *)key, matchlimit,
                     casesensitive);
      }
#line 187
      if (dist != -1) {
        {
#line 187
        tmp___0 = checkftype(path, entry->d_name);
        }
#line 187
        if (tmp___0) {
#line 188
          if (printdist) {
            {
#line 188
            printf((char const   */* __restrict  */)"%03d ", dist);
            }
          }
          {
#line 189
          printf((char const   */* __restrict  */)"%s/%s\n", path, entry->d_name);
#line 190
          nomatchfound = 0;
          }
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 193
    closedir(dp);
    }
  }
#line 195
  return;
}
}
#line 207 "/home/june/repo/benchmarks/collector2/temp/whichman-2.4/ftwhich.c"
static char **pathcomp  ;
#line 203 "/home/june/repo/benchmarks/collector2/temp/whichman-2.4/ftwhich.c"
static char **splitpath(void) 
{ 
  char *spath ;
  char *cspath ;
  int i ;
  int notseen ;
  char *start ;
  int compind ;
  int complen ;
  char *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 208
  i = 0;
#line 209
  notseen = 1;
#line 211
  compind = 0;
#line 212
  complen = 1;
#line 214
  tmp___0 = getenv("PATH");
#line 214
  spath = tmp___0;
  }
#line 215
  if ((unsigned long )spath == (unsigned long )((void *)0)) {
    {
#line 216
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: PATH not defined, using /bin:/usr/bin\n");
#line 217
    spath = (char *)"/bin:/usr/bin";
    }
  } else
#line 215
  if ((int )*spath == 0) {
    {
#line 216
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: PATH not defined, using /bin:/usr/bin\n");
#line 217
    spath = (char *)"/bin:/usr/bin";
    }
  }
  {
#line 220
  tmp___1 = strlen((char const   *)spath);
#line 220
  tmp___2 = malloc(tmp___1 + 2UL);
#line 220
  cspath = (char *)tmp___2;
#line 221
  strcpy((char */* __restrict  */)cspath, (char const   */* __restrict  */)spath);
#line 222
  start = cspath;
  }
  {
#line 225
  while (1) {
    while_continue: /* CIL Label */ ;
#line 225
    if (! *cspath) {
#line 225
      goto while_break;
    }
#line 226
    if ((int )*cspath == 58) {
#line 226
      i ++;
    }
#line 227
    cspath ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 229
  i += 3;
#line 230
  tmp___3 = malloc(sizeof(char *) * (unsigned long )i);
#line 230
  pathcomp = (char **)tmp___3;
#line 232
  cspath = start;
#line 233
  *(pathcomp + compind) = cspath;
  }
  {
#line 234
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 234
    if (! *cspath) {
#line 234
      goto while_break___0;
    }
#line 235
    if ((int )*cspath == 58) {
#line 236
      *cspath = (char )'\000';
#line 237
      if (complen > 1) {
#line 240
        i = 0;
#line 240
        notseen = 1;
        {
#line 241
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 241
          if (notseen) {
#line 241
            if (! (i < compind)) {
#line 241
              goto while_break___1;
            }
          } else {
#line 241
            goto while_break___1;
          }
          {
#line 242
          tmp___4 = streq((char const   *)*(pathcomp + compind), (char const   *)*(pathcomp + i));
          }
#line 242
          if (tmp___4) {
#line 243
            notseen = 0;
          }
#line 245
          i ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 247
        if (notseen) {
#line 247
          compind ++;
        }
      }
#line 251
      if (complen > 2) {
#line 251
        if ((int )*(cspath - 1) == 47) {
#line 251
          *(cspath - 1) = (char )'\000';
        }
      }
#line 252
      *(pathcomp + compind) = cspath + 1;
#line 253
      complen = 0;
    }
#line 255
    cspath ++;
#line 256
    complen ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 258
  if (complen < 2) {
#line 261
    *(pathcomp + compind) = (char *)((void *)0);
  } else {
#line 265
    i = 0;
#line 265
    notseen = 1;
    {
#line 266
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 266
      if (notseen) {
#line 266
        if (! (i < compind)) {
#line 266
          goto while_break___2;
        }
      } else {
#line 266
        goto while_break___2;
      }
      {
#line 267
      tmp___5 = streq((char const   *)*(pathcomp + compind), (char const   *)*(pathcomp + i));
      }
#line 267
      if (tmp___5) {
#line 268
        notseen = 0;
      }
#line 270
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 272
    if (notseen) {
#line 272
      compind ++;
    }
#line 273
    *(pathcomp + compind) = (char *)((void *)0);
  }
#line 275
  return (pathcomp + 0);
}
}
#line 278 "/home/june/repo/benchmarks/collector2/temp/whichman-2.4/ftwhich.c"
static int streq(char const   *a , char const   *b ) 
{ 


  {
  {
#line 279
  while (1) {
    while_continue: /* CIL Label */ ;
#line 279
    if (*a) {
#line 279
      if (! *b) {
#line 279
        goto while_break;
      }
    } else {
#line 279
      goto while_break;
    }
#line 280
    if ((int const   )*a != (int const   )*b) {
#line 280
      return (0);
    }
#line 281
    a ++;
#line 281
    b ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 284
  if (*a) {
#line 284
    return (0);
  } else
#line 284
  if (*b) {
#line 284
    return (0);
  }
#line 285
  return (1);
}
}
#line 290 "/home/june/repo/benchmarks/collector2/temp/whichman-2.4/ftwhich.c"
static void help(void) 
{ 


  {
  {
#line 292
  printf((char const   */* __restrict  */)"ftwhich -- fault tolerant approximate search command for programs\n\nUSAGE:  ftwhich [-#hIp][-t#] [--] program-name\n\nSupported wildcards: * -- any arbitrary number of character\n                     ? -- one character\n\nOPTIONS: -h  this help\n         -I  search case sensitive (default is case in-sensitive)\n         -p  print the actual distance (tolerance) value in front of the\n             file name.\n         -#  set fault tolerance level to # (integer in the range 0-255)\n             It specifies the maximum distance. This is the number of\n             errors permitted for finding the approximate match.\n         -t# same as -# for backward compatibility\n\nWith no option specified search is fault tolerant using a tolerance\nlevel of: (string length of searchpattern - number of wildcards)/6 +1\n");
#line 310
  printf((char const   */* __restrict  */)"%s\n", "@(#)Version: 2.3");
#line 311
  exit(0);
  }
}
}
#line 7 "/home/june/repo/benchmarks/collector2/temp/whichman-2.4/statduplcheck.h"
int is_fileduplicate(char const   *dir , char const   *name ) ;
#line 53 "/usr/include/malloc.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 137 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 129 "/usr/include/search.h"
extern void *tsearch(void const   *__key , void **__rootp , int (*__compar)(void const   * ,
                                                                            void const   * ) ) ;
#line 158
extern void tdestroy(void *__root , void (*__freefct)(void *__nodep ) ) ;
#line 14 "/home/june/repo/benchmarks/collector2/temp/whichman-2.4/statduplcheck.c"
static void *info_root  =    (void *)0;
#line 17 "/home/june/repo/benchmarks/collector2/temp/whichman-2.4/statduplcheck.c"
static int stat_info_compare(void const   *si1 , void const   *si2 ) 
{ 
  int res ;

  {
#line 21
  res = (int )(((struct stat_info *)si1)->st_dev - ((struct stat_info *)si2)->st_dev);
#line 22
  if (! res) {
#line 23
    res = (int )(((struct stat_info *)si1)->st_ino - ((struct stat_info *)si2)->st_ino);
  }
#line 24
  return (res);
}
}
#line 28 "/home/june/repo/benchmarks/collector2/temp/whichman-2.4/statduplcheck.c"
static struct stat_info *stinfo  =    (struct stat_info *)((void *)0);
#line 27 "/home/june/repo/benchmarks/collector2/temp/whichman-2.4/statduplcheck.c"
int is_statduplicate(struct stat  const  *st ) 
{ 
  struct stat_info **res ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 31
  if (! stinfo) {
    {
#line 32
    tmp___0 = malloc(sizeof(*stinfo));
#line 32
    stinfo = (struct stat_info *)tmp___0;
    }
#line 34
    if (! stinfo) {
      {
#line 35
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cannot allocate memory\n");
#line 36
      exit(1);
      }
    }
  }
  {
#line 41
  stinfo->st_dev = (dev_t )st->st_dev;
#line 42
  stinfo->st_ino = (ino_t )st->st_ino;
#line 44
  tmp___1 = tsearch((void const   *)stinfo, & info_root, & stat_info_compare);
#line 44
  res = (struct stat_info **)tmp___1;
  }
#line 44
  if (! res) {
    {
#line 45
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cannot allocate memory\n");
#line 46
    exit(1);
    }
  }
#line 49
  if ((unsigned long )*res == (unsigned long )stinfo) {
#line 51
    stinfo = (struct stat_info *)((void *)0);
#line 52
    return (0);
  }
#line 55
  return (1);
}
}
#line 59 "/home/june/repo/benchmarks/collector2/temp/whichman-2.4/statduplcheck.c"
static struct stat stbuf  ;
#line 60 "/home/june/repo/benchmarks/collector2/temp/whichman-2.4/statduplcheck.c"
static char fullpath___0[255]  ;
#line 58 "/home/june/repo/benchmarks/collector2/temp/whichman-2.4/statduplcheck.c"
int is_fileduplicate(char const   *dir , char const   *name ) 
{ 
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 62
  tmp___0 = strlen(dir);
#line 62
  tmp___1 = strlen(name);
  }
#line 62
  if ((tmp___0 + tmp___1) + 2UL > sizeof(fullpath___0)) {
#line 62
    return (-1);
  }
  {
#line 63
  strcpy((char */* __restrict  */)(fullpath___0), (char const   */* __restrict  */)dir);
#line 64
  strcat((char */* __restrict  */)(fullpath___0), (char const   */* __restrict  */)"/");
#line 65
  strcat((char */* __restrict  */)(fullpath___0), (char const   */* __restrict  */)name);
#line 67
  tmp___2 = stat((char const   */* __restrict  */)(fullpath___0), (struct stat */* __restrict  */)(& stbuf));
  }
#line 67
  if (tmp___2 != 0) {
#line 67
    return (-1);
  }
  {
#line 69
  tmp___3 = is_statduplicate((struct stat  const  *)(& stbuf));
  }
#line 69
  return (tmp___3);
}
}
#line 73 "/home/june/repo/benchmarks/collector2/temp/whichman-2.4/statduplcheck.c"
void free_statduplicates(void) 
{ 


  {
#line 75
  if (! info_root) {
#line 75
    return;
  }
  {
#line 77
  tdestroy(info_root, (void (*)(void *__nodep ))(& free));
#line 78
  info_root = (void *)0;
  }
#line 80
  return;
}
}
#line 124 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 9 "/home/june/repo/benchmarks/collector2/temp/whichman-2.4/levdist.h"
int lowercaseword(char *lowword , char const   *word , int maxlen , int casesensitive___1 ) ;
#line 65 "/home/june/repo/benchmarks/collector2/temp/whichman-2.4/levdist.c"
int stdtolerance(char const   *searchpat ) 
{ 
  int len ;

  {
#line 67
  len = 0;
  {
#line 68
  while (1) {
    while_continue: /* CIL Label */ ;
#line 68
    if (*searchpat) {
#line 68
      if (! (len < 200)) {
#line 68
        goto while_break;
      }
    } else {
#line 68
      goto while_break;
    }
#line 69
    if ((int const   )*searchpat == 63) {
#line 70
      searchpat ++;
#line 71
      goto while_continue;
    } else
#line 69
    if ((int const   )*searchpat == 42) {
#line 70
      searchpat ++;
#line 71
      goto while_continue;
    }
#line 73
    searchpat ++;
#line 74
    len ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 76
  len = len / 6 + 1;
#line 77
  return (len);
}
}
#line 84 "/home/june/repo/benchmarks/collector2/temp/whichman-2.4/levdist.c"
int lowercaseword(char *lowword , char const   *word , int maxlen , int casesensitive___1 ) 
{ 
  int len ;
  int tmp___0 ;

  {
#line 86
  len = 0;
  {
#line 87
  while (1) {
    while_continue: /* CIL Label */ ;
#line 87
    if (*word) {
#line 87
      if (! (len < maxlen - 1)) {
#line 87
        goto while_break;
      }
    } else {
#line 87
      goto while_break;
    }
#line 88
    if (casesensitive___1) {
#line 89
      *lowword = (char )*word;
    } else {
      {
#line 91
      tmp___0 = tolower((int )*word);
#line 91
      *lowword = (char )tmp___0;
      }
    }
#line 93
    word ++;
#line 93
    lowword ++;
#line 94
    len ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 96
  *lowword = (char)0;
#line 97
  return (len);
}
}
#line 102 "/home/june/repo/benchmarks/collector2/temp/whichman-2.4/levdist.c"
__inline int minimum(int a , int b , int c ) 
{ 


  {
#line 104
  if (a < b) {
#line 104
    b = a;
  }
#line 105
  if (b < c) {
#line 105
    c = b;
  }
#line 106
  return (c);
}
}
#line 116 "/home/june/repo/benchmarks/collector2/temp/whichman-2.4/levdist.c"
int levdist(char const   *iword , char const   *ipattern , int limit , int casesensitive___1 ) 
{ 
  int dmin ;
  int p ;
  int pp ;
  int q ;
  int lpat ;
  int lwrd ;
  int d1 ;
  int d2 ;
  int i ;
  int j ;
  char c ;
  char word[256] ;
  char pattern[256] ;
  int dstprof[256] ;

  {
#line 121
  if (! *iword) {
#line 121
    return (-1);
  }
#line 122
  if (! *ipattern) {
#line 122
    return (-1);
  }
  {
#line 124
  lwrd = lowercaseword(word, iword, 256, casesensitive___1);
#line 125
  lpat = lowercaseword(pattern, ipattern, 256, casesensitive___1);
  }
#line 130
  if ((int )pattern[0] == 42) {
#line 132
    j = 0;
    {
#line 132
    while (1) {
      while_continue: /* CIL Label */ ;
#line 132
      if (! (j <= lwrd)) {
#line 132
        goto while_break;
      }
#line 133
      dstprof[j] = 0;
#line 132
      j ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 139
    dstprof[0] = 1;
#line 140
    if ((int )pattern[0] == 63) {
#line 140
      i = 0;
    } else {
#line 140
      i = 1;
    }
#line 141
    j = 0;
    {
#line 141
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 141
      if (! (j < lwrd)) {
#line 141
        goto while_break___0;
      }
#line 142
      if ((int )pattern[0] == (int )*(word + j)) {
#line 143
        i = 0;
      }
#line 145
      dstprof[j + 1] = j + i;
#line 141
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 154
  i = 1;
#line 155
  dmin = dstprof[1];
  {
#line 156
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 156
    if (i < lpat) {
#line 156
      if (! (dmin <= limit)) {
#line 156
        goto while_break___1;
      }
    } else {
#line 156
      goto while_break___1;
    }
#line 157
    c = *(pattern + i);
#line 158
    pp = 1;
#line 158
    q = 1;
#line 159
    if ((int )c == 42) {
#line 159
      pp = 0;
    } else
#line 159
    if ((int )c == 63) {
#line 159
      pp = 0;
    }
#line 160
    if ((int )c == 42) {
#line 160
      q = 0;
    }
#line 161
    d2 = dstprof[0];
#line 162
    dmin = d2 + q;
#line 163
    dstprof[0] = dmin;
#line 164
    i ++;
#line 165
    j = 1;
    {
#line 165
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 165
      if (! (j <= lwrd)) {
#line 165
        goto while_break___2;
      }
#line 166
      d1 = d2;
#line 167
      d2 = dstprof[j];
#line 168
      p = pp;
#line 169
      if ((int )c == (int )*((word + j) - 1)) {
#line 169
        p = 0;
      }
      {
#line 170
      dstprof[j] = minimum(d1 + p, d2 + q, dstprof[j - 1] + q);
      }
#line 171
      if (dstprof[j] < dmin) {
#line 172
        dmin = dstprof[j];
      }
#line 165
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 182
  if (dstprof[lwrd] <= limit) {
#line 185
    return (dstprof[lwrd]);
  }
#line 187
  return (-1);
}
}
#line 16 "/home/june/repo/benchmarks/collector2/temp/whichman-2.4/whichman.c"
static void help___0(void) ;
#line 17
static char **splitman(void) ;
#line 18
static int findmandir(char *manpathcomponent , char *key ) ;
#line 19
static void matchfilename___0(char *path , char *key ) ;
#line 20
static int stringmatch(char *s1 , char *s2 ) ;
#line 21
static int maybemandir(char const   *dirname ) ;
#line 22
static char *removemanextesions(char *manpagefilename ) ;
#line 23
static int streq___0(char const   *a , char const   *b ) ;
#line 26 "/home/june/repo/benchmarks/collector2/temp/whichman-2.4/whichman.c"
static int printdist___0  =    0;
#line 27 "/home/june/repo/benchmarks/collector2/temp/whichman-2.4/whichman.c"
static int casesensitive___0  =    0;
#line 28 "/home/june/repo/benchmarks/collector2/temp/whichman-2.4/whichman.c"
static int nomanfilefound  =    1;
#line 34 "/home/june/repo/benchmarks/collector2/temp/whichman-2.4/whichman.c"
static int searchmethod  =    -2;
#line 168 "/home/june/repo/benchmarks/collector2/temp/whichman-2.4/whichman.c"
static char manpath[1024]  ;
#line 164 "/home/june/repo/benchmarks/collector2/temp/whichman-2.4/whichman.c"
static int findmandir(char *manpathcomponent , char *key ) 
{ 
  char *manpathendptr ;
  int len ;
  struct stat stbuff ;
  DIR *dp ;
  struct dirent *entry ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 171
  len = 0;
#line 181
  manpathendptr = manpath;
#line 183
  if ((unsigned long )manpathcomponent == (unsigned long )((void *)0)) {
    {
#line 185
    tmp___0 = strlen((char const   *)(manpath));
#line 185
    manpathendptr += tmp___0;
    }
  } else {
    {
#line 191
    while (1) {
      while_continue: /* CIL Label */ ;
#line 191
      if (*manpathcomponent) {
#line 191
        if (! (len < 800)) {
#line 191
          goto while_break;
        }
      } else {
#line 191
        goto while_break;
      }
#line 192
      *manpathendptr = *manpathcomponent;
#line 193
      manpathcomponent ++;
#line 194
      manpathendptr ++;
#line 195
      len ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 197
    *manpathendptr = (char )'\000';
  }
  {
#line 199
  dp = opendir((char const   *)(manpath));
  }
#line 199
  if ((unsigned long )dp == (unsigned long )((void *)0)) {
#line 201
    return (0);
  }
#line 203
  if ((int )*(manpathendptr - 1) != 47) {
#line 204
    *manpathendptr = (char )'/';
#line 205
    manpathendptr ++;
#line 206
    *manpathendptr = (char )'\000';
  }
  {
#line 210
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 210
    entry = readdir(dp);
    }
#line 210
    if (! ((unsigned long )entry != (unsigned long )((void *)0))) {
#line 210
      goto while_break___0;
    }
#line 212
    if ((int )entry->d_name[0] == 46) {
#line 212
      goto while_continue___0;
    }
    {
#line 215
    strcpy((char */* __restrict  */)manpathendptr, (char const   */* __restrict  */)(entry->d_name));
#line 216
    tmp___2 = maybemandir((char const   *)(entry->d_name));
    }
#line 216
    if (tmp___2) {
      {
#line 221
      matchfilename___0(manpath, key);
      }
    } else {
      {
#line 226
      tmp___1 = stat((char const   */* __restrict  */)(manpath), (struct stat */* __restrict  */)(& stbuff));
      }
#line 226
      if (tmp___1 < 0) {
#line 226
        goto while_continue___0;
      }
#line 227
      if ((unsigned long )manpathcomponent != (unsigned long )((void *)0)) {
#line 227
        if ((stbuff.st_mode & 61440U) == 16384U) {
          {
#line 228
          strcpy((char */* __restrict  */)manpathendptr, (char const   */* __restrict  */)(entry->d_name));
#line 229
          findmandir((char *)((void *)0), key);
          }
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 233
  closedir(dp);
  }
#line 234
  return (0);
}
}
#line 242 "/home/june/repo/benchmarks/collector2/temp/whichman-2.4/whichman.c"
static void matchfilename___0(char *path , char *key ) 
{ 
  char *manname ;
  int d ;
  DIR *dp ;
  struct dirent *entry ;
  int tmp___0 ;

  {
  {
#line 248
  dp = opendir((char const   *)path);
  }
#line 248
  if ((unsigned long )dp != (unsigned long )((void *)0)) {
    {
#line 249
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 249
      entry = readdir(dp);
      }
#line 249
      if (! ((unsigned long )entry != (unsigned long )((void *)0))) {
#line 249
        goto while_break;
      }
#line 251
      if ((int )entry->d_name[0] == 46) {
#line 251
        goto while_continue;
      }
      {
#line 253
      manname = removemanextesions(entry->d_name);
#line 254
      d = stringmatch(manname, key);
      }
#line 255
      if (d != -1) {
        {
#line 255
        tmp___0 = is_fileduplicate((char const   *)path, (char const   *)(entry->d_name));
        }
#line 255
        if (! tmp___0) {
#line 256
          if (printdist___0) {
            {
#line 256
            printf((char const   */* __restrict  */)"%03d ", d);
            }
          }
          {
#line 257
          printf((char const   */* __restrict  */)"%s/%s\n", path, entry->d_name);
#line 258
          nomanfilefound = 0;
          }
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 261
    closedir(dp);
    }
  }
#line 263
  return;
}
}
#line 273 "/home/june/repo/benchmarks/collector2/temp/whichman-2.4/whichman.c"
static char man[4]  = {      (char )'m',      (char )'a',      (char )'n',      (char )'\000'};
#line 271 "/home/june/repo/benchmarks/collector2/temp/whichman-2.4/whichman.c"
static int maybemandir(char const   *dirname ) 
{ 
  int i ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
#line 274
  i = 0;
  {
#line 275
  while (1) {
    while_continue: /* CIL Label */ ;
#line 275
    if (*dirname) {
#line 275
      if (! (i < 3)) {
#line 275
        goto while_break;
      }
    } else {
#line 275
      goto while_break;
    }
#line 276
    if ((int const   )*dirname != (int const   )man[i]) {
#line 276
      return (0);
    }
#line 277
    dirname ++;
#line 278
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 280
  if (i != 3) {
#line 280
    return (0);
  }
  {
#line 281
  tmp___0 = __ctype_b_loc();
  }
#line 281
  if (((int const   )*(*tmp___0 + (int )*dirname) & 8) == 0) {
#line 281
    return (0);
  }
#line 282
  dirname ++;
#line 283
  if ((int const   )*dirname == 0) {
#line 283
    return (1);
  }
  {
#line 284
  tmp___1 = __ctype_b_loc();
  }
#line 284
  if (((int const   )*(*tmp___1 + (int )*dirname) & 8) == 0) {
#line 284
    return (0);
  }
#line 285
  return (1);
}
}
#line 302 "/home/june/repo/benchmarks/collector2/temp/whichman-2.4/whichman.c"
static int stringmatch(char *s1 , char *s2 ) 
{ 
  char c ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 305
  if (searchmethod == -1) {
    {
#line 307
    while (1) {
      while_continue: /* CIL Label */ ;
#line 307
      if (! *s1) {
#line 307
        goto while_break;
      }
#line 308
      c = *s1;
#line 309
      if (! casesensitive___0) {
        {
#line 309
        tmp___0 = tolower((int )*s1);
#line 309
        c = (char )tmp___0;
        }
      }
#line 310
      if ((int )c != (int )*s2) {
#line 311
        return (-1);
      }
#line 313
      s1 ++;
#line 313
      s2 ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 316
    if ((int )*s2 == 0) {
#line 316
      return (0);
    }
  } else {
    {
#line 319
    tmp___1 = levdist((char const   *)s1, (char const   *)s2, searchmethod, casesensitive___0);
    }
#line 319
    return (tmp___1);
  }
#line 321
  return (-1);
}
}
#line 339 "/home/june/repo/benchmarks/collector2/temp/whichman-2.4/whichman.c"
static char tmp[256]  ;
#line 336 "/home/june/repo/benchmarks/collector2/temp/whichman-2.4/whichman.c"
static char *removemanextesions(char *manpagefilename ) 
{ 
  char *rightdot ;
  int i ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 341
  i = 0;
#line 343
  rightdot = (char *)((void *)0);
  {
#line 344
  while (1) {
    while_continue: /* CIL Label */ ;
#line 344
    if (*manpagefilename) {
#line 344
      if (! (i < 255)) {
#line 344
        goto while_break;
      }
    } else {
#line 344
      goto while_break;
    }
#line 345
    tmp[i] = *manpagefilename;
#line 346
    if ((int )*manpagefilename == 46) {
#line 347
      rightdot = tmp + i;
    }
#line 349
    i ++;
#line 350
    manpagefilename ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 352
  tmp[i] = (char )'\000';
#line 353
  if ((unsigned long )rightdot == (unsigned long )((void *)0)) {
#line 356
    return (tmp);
  }
  {
#line 358
  tmp___0 = streq___0((char const   *)rightdot, ".gz");
  }
#line 358
  if (tmp___0) {
#line 359
    *rightdot = (char )'\000';
  }
  {
#line 361
  tmp___1 = streq___0((char const   *)rightdot, ".bz2");
  }
#line 361
  if (tmp___1) {
#line 362
    *rightdot = (char )'\000';
  }
  {
#line 364
  tmp___2 = streq___0((char const   *)rightdot, ".bz");
  }
#line 364
  if (tmp___2) {
#line 365
    *rightdot = (char )'\000';
  }
  {
#line 367
  tmp___3 = streq___0((char const   *)rightdot, ".Z");
  }
#line 367
  if (tmp___3) {
#line 368
    *rightdot = (char )'\000';
  }
#line 372
  manpagefilename = tmp;
#line 373
  rightdot = (char *)((void *)0);
  {
#line 374
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 374
    if (! *manpagefilename) {
#line 374
      goto while_break___0;
    }
#line 375
    if ((int )*manpagefilename == 46) {
#line 376
      rightdot = manpagefilename;
    }
#line 378
    manpagefilename ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 380
  if (rightdot) {
#line 382
    *rightdot = (char )'\000';
  }
#line 384
  return (tmp);
}
}
#line 396 "/home/june/repo/benchmarks/collector2/temp/whichman-2.4/whichman.c"
static char **pathcomp___0  ;
#line 392 "/home/june/repo/benchmarks/collector2/temp/whichman-2.4/whichman.c"
static char **splitman(void) 
{ 
  char *mpath ;
  char *cmpath ;
  int i ;
  int notseen ;
  char *start ;
  int compind ;
  int complen ;
  char *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 397
  i = 0;
#line 398
  notseen = 1;
#line 400
  compind = 0;
#line 401
  complen = 1;
#line 403
  tmp___0 = getenv("MANPATH");
#line 403
  mpath = tmp___0;
  }
#line 404
  if ((unsigned long )mpath == (unsigned long )((void *)0)) {
#line 406
    mpath = (char *)"/usr/share/man:/usr/man:/usr/X11R6/man:/usr/local/man";
  } else
#line 404
  if ((int )*mpath == 0) {
#line 406
    mpath = (char *)"/usr/share/man:/usr/man:/usr/X11R6/man:/usr/local/man";
  }
  {
#line 409
  tmp___1 = strlen((char const   *)mpath);
#line 409
  tmp___2 = malloc(sizeof(char ) * (tmp___1 + 2UL));
#line 409
  cmpath = (char *)tmp___2;
#line 410
  strcpy((char */* __restrict  */)cmpath, (char const   */* __restrict  */)mpath);
#line 411
  start = cmpath;
  }
  {
#line 414
  while (1) {
    while_continue: /* CIL Label */ ;
#line 414
    if (! *cmpath) {
#line 414
      goto while_break;
    }
#line 415
    if ((int )*cmpath == 58) {
#line 415
      i ++;
    }
#line 416
    cmpath ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 418
  i += 3;
#line 419
  tmp___3 = malloc(sizeof(char *) * (unsigned long )i);
#line 419
  pathcomp___0 = (char **)tmp___3;
#line 421
  cmpath = start;
#line 422
  *(pathcomp___0 + compind) = cmpath;
  }
  {
#line 423
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 423
    if (! *cmpath) {
#line 423
      goto while_break___0;
    }
#line 424
    if ((int )*cmpath == 58) {
#line 425
      *cmpath = (char )'\000';
#line 426
      if (complen > 1) {
#line 429
        i = 0;
#line 429
        notseen = 1;
        {
#line 430
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 430
          if (notseen) {
#line 430
            if (! (i < compind)) {
#line 430
              goto while_break___1;
            }
          } else {
#line 430
            goto while_break___1;
          }
          {
#line 431
          tmp___4 = streq___0((char const   *)*(pathcomp___0 + compind), (char const   *)*(pathcomp___0 + i));
          }
#line 431
          if (tmp___4) {
#line 432
            notseen = 0;
          }
#line 434
          i ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 436
        if (notseen) {
#line 436
          compind ++;
        }
      }
#line 440
      if (complen > 2) {
#line 440
        if ((int )*(cmpath - 1) == 47) {
#line 440
          *(cmpath - 1) = (char )'\000';
        }
      }
#line 441
      *(pathcomp___0 + compind) = cmpath + 1;
#line 442
      complen = 0;
    }
#line 444
    cmpath ++;
#line 445
    complen ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 447
  if (complen < 2) {
#line 450
    *(pathcomp___0 + compind) = (char *)((void *)0);
  } else {
#line 454
    i = 0;
#line 454
    notseen = 1;
    {
#line 455
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 455
      if (notseen) {
#line 455
        if (! (i < compind)) {
#line 455
          goto while_break___2;
        }
      } else {
#line 455
        goto while_break___2;
      }
      {
#line 456
      tmp___5 = streq___0((char const   *)*(pathcomp___0 + compind), (char const   *)*(pathcomp___0 + i));
      }
#line 456
      if (tmp___5) {
#line 457
        notseen = 0;
      }
#line 459
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 461
    if (notseen) {
#line 461
      compind ++;
    }
#line 462
    *(pathcomp___0 + compind) = (char *)((void *)0);
  }
#line 464
  return (pathcomp___0 + 0);
}
}
#line 468 "/home/june/repo/benchmarks/collector2/temp/whichman-2.4/whichman.c"
static int streq___0(char const   *a , char const   *b ) 
{ 


  {
  {
#line 469
  while (1) {
    while_continue: /* CIL Label */ ;
#line 469
    if (*a) {
#line 469
      if (! *b) {
#line 469
        goto while_break;
      }
    } else {
#line 469
      goto while_break;
    }
#line 470
    if ((int const   )*a != (int const   )*b) {
#line 470
      return (0);
    }
#line 471
    a ++;
#line 471
    b ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 474
  if (*a) {
#line 474
    return (0);
  } else
#line 474
  if (*b) {
#line 474
    return (0);
  }
#line 475
  return (1);
}
}
#line 480 "/home/june/repo/benchmarks/collector2/temp/whichman-2.4/whichman.c"
static void help___0(void) 
{ 


  {
  {
#line 482
  printf((char const   */* __restrict  */)"whichman -- fault tolerant approximate search command for man-pages\n\nUSAGE:  whichman [-#hIep][-t#] [--] man-page-name\n\nSupported wildcards: * -- any arbitrary number of character\n                     ? -- one character\n\nOPTIONS: -h  this help\n         -I  search case sensitive (default is case in-sensitive)\n         -e  do exact match (disables also the wildcards * and ?)\n         -p  print the actual distance (tolerance) value in front of the\n             man-page file name.\n         -#  set fault tolerance level to # (integer in the range 0-255)\n             It specifies the maximum distance. This is the number of\n             errors permitted for finding the approximate match.\n         -t# same as -# for backward compatibility\n\nWith no option specified search is fault tolerant using a tolerance\nlevel of: (string length of searchpattern - number of wildcards)/6 +1\n");
#line 501
  printf((char const   */* __restrict  */)"%s\n", "@(#)Version: 2.3");
#line 502
  exit(0);
  }
}
}
#line 14 "/home/june/repo/benchmarks/collector2/temp/whichman-2.4/statduplcheck.c"
static void *info_root___0  =    (void *)0;
#line 17 "/home/june/repo/benchmarks/collector2/temp/whichman-2.4/statduplcheck.c"
static int stat_info_compare___0(void const   *si1 , void const   *si2 ) 
{ 
  int res ;

  {
#line 21
  res = (int )(((struct stat_info *)si1)->st_dev - ((struct stat_info *)si2)->st_dev);
#line 22
  if (! res) {
#line 23
    res = (int )(((struct stat_info *)si1)->st_ino - ((struct stat_info *)si2)->st_ino);
  }
#line 24
  return (res);
}
}
#line 28 "/home/june/repo/benchmarks/collector2/temp/whichman-2.4/statduplcheck.c"
static struct stat_info *stinfo___0  =    (struct stat_info *)((void *)0);
#line 59 "/home/june/repo/benchmarks/collector2/temp/whichman-2.4/statduplcheck.c"
static struct stat stbuf___0  ;
#line 60 "/home/june/repo/benchmarks/collector2/temp/whichman-2.4/statduplcheck.c"
static char fullpath___1[255]  ;
#line 263 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) lstat)(char const   * __restrict  __file ,
                                                                                              struct stat * __restrict  __buf ) ;
#line 846 "/usr/include/stdio.h"
extern void perror(char const   *__s ) ;
#line 31 "/home/june/repo/benchmarks/collector2/temp/whichman-2.4/ftff.c"
static void help___1(void) ;
#line 34 "/home/june/repo/benchmarks/collector2/temp/whichman-2.4/ftff.c"
static char *search  ;
#line 35 "/home/june/repo/benchmarks/collector2/temp/whichman-2.4/ftff.c"
static char *fullpath___2  ;
#line 36 "/home/june/repo/benchmarks/collector2/temp/whichman-2.4/ftff.c"
static int tolerance  =    -1;
#line 37 "/home/june/repo/benchmarks/collector2/temp/whichman-2.4/ftff.c"
static int opt_p  =    0;
#line 38 "/home/june/repo/benchmarks/collector2/temp/whichman-2.4/ftff.c"
static int opt_q  =    0;
#line 39 "/home/june/repo/benchmarks/collector2/temp/whichman-2.4/ftff.c"
static int opt_F  =    0;
#line 40 "/home/june/repo/benchmarks/collector2/temp/whichman-2.4/ftff.c"
static int opt_I  =    0;
#line 41 "/home/june/repo/benchmarks/collector2/temp/whichman-2.4/ftff.c"
static int opt_f  =    0;
#line 47 "/home/june/repo/benchmarks/collector2/temp/whichman-2.4/ftff.c"
char *allocpath(void) 
{ 
  char *ptr ;
  void *tmp___0 ;

  {
  {
#line 50
  tmp___0 = malloc((size_t )1002);
#line 50
  ptr = (char *)tmp___0;
  }
#line 50
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
    {
#line 51
    perror("Error: malloc() failed");
#line 52
    exit(1);
    }
  }
#line 54
  return (ptr);
}
}
#line 57 "/home/june/repo/benchmarks/collector2/temp/whichman-2.4/ftff.c"
char filetype(struct stat buffer___0 ) 
{ 
  mode_t mode ;

  {
#line 74
  mode = buffer___0.st_mode;
  {
#line 77
  if ((mode & 61440U) == 4096U) {
#line 77
    goto case_4096;
  }
#line 81
  if ((mode & 61440U) == 16384U) {
#line 81
    goto case_16384;
  }
#line 85
  if ((mode & 61440U) == 40960U) {
#line 85
    goto case_40960;
  }
#line 89
  if ((mode & 61440U) == 49152U) {
#line 89
    goto case_49152;
  }
#line 92
  if ((mode & 61440U) == 32768U) {
#line 92
    goto case_32768;
  }
#line 75
  goto switch_break;
  case_4096: /* CIL Label */ 
#line 78
  return ((char )'|');
  case_16384: /* CIL Label */ 
#line 82
  return ((char )'/');
  case_40960: /* CIL Label */ 
#line 86
  return ((char )'@');
  case_49152: /* CIL Label */ 
#line 90
  return ((char )'=');
  case_32768: /* CIL Label */ 
#line 93
  if (mode & (unsigned int )((64 | (64 >> 3)) | ((64 >> 3) >> 3))) {
#line 94
    return ((char )'*');
  }
#line 96
  return ((char )' ');
  switch_break: /* CIL Label */ ;
  }
#line 99
  return ((char )' ');
}
}
#line 106 "/home/june/repo/benchmarks/collector2/temp/whichman-2.4/ftff.c"
int isnotdotdir(char *dir ) 
{ 
  int cnt ;

  {
#line 108
  cnt = 0;
  {
#line 109
  while (1) {
    while_continue: /* CIL Label */ ;
#line 109
    if (! *dir) {
#line 109
      goto while_break;
    }
#line 110
    if ((int )*dir != 46) {
#line 111
      return (1);
    }
#line 113
    if (cnt > 1) {
#line 114
      return (1);
    }
#line 116
    cnt ++;
#line 117
    dir ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 119
  return (0);
}
}
#line 136 "/home/june/repo/benchmarks/collector2/temp/whichman-2.4/ftff.c"
static struct stat buffer  ;
#line 142
int traversetree(char *object ) ;
#line 142 "/home/june/repo/benchmarks/collector2/temp/whichman-2.4/ftff.c"
static int result  =    1;
#line 133 "/home/june/repo/benchmarks/collector2/temp/whichman-2.4/ftff.c"
int traversetree(char *object ) 
{ 
  DIR *dp ;
  struct dirent *dirp ;
  char *ptr ;
  int d ;
  int len ;
  int tmp___0 ;
  char tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;

  {
  {
#line 146
  tmp___0 = lstat((char const   */* __restrict  */)fullpath___2, (struct stat */* __restrict  */)(& buffer));
  }
#line 146
  if (tmp___0 < 0) {
#line 147
    if (opt_q == 0) {
      {
#line 148
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: %s, ",
              fullpath___2);
#line 149
      perror("");
      }
    }
#line 151
    return (result);
  }
  {
#line 157
  tmp___2 = isnotdotdir(object);
  }
#line 157
  if (tmp___2) {
    {
#line 158
    d = levdist((char const   *)object, (char const   *)search, tolerance, opt_I);
    }
#line 159
    if (d != -1) {
#line 160
      if (opt_p) {
        {
#line 160
        printf((char const   */* __restrict  */)"%03d ", d);
        }
      }
      {
#line 161
      printf((char const   */* __restrict  */)"%s", fullpath___2);
      }
#line 162
      if (opt_F) {
        {
#line 163
        tmp___1 = filetype(buffer);
#line 163
        printf((char const   */* __restrict  */)"%c\n", (int )tmp___1);
        }
      } else {
        {
#line 165
        printf((char const   */* __restrict  */)"\n");
        }
      }
#line 167
      result = 0;
    }
  }
#line 170
  if (opt_f) {
#line 170
    if ((buffer.st_mode & 61440U) == 40960U) {
      {
#line 171
      tmp___3 = stat((char const   */* __restrict  */)fullpath___2, (struct stat */* __restrict  */)(& buffer));
      }
#line 171
      if (tmp___3 < 0) {
#line 172
        if (opt_q == 0) {
          {
#line 173
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: %s, ",
                  fullpath___2);
#line 174
          perror("");
          }
        }
#line 176
        return (result);
      }
    }
  }
#line 179
  if ((buffer.st_mode & 61440U) == 16384U) {
    {
#line 180
    dp = opendir((char const   *)fullpath___2);
    }
#line 180
    if ((unsigned long )((void *)0) == (unsigned long )dp) {
#line 181
      if (opt_q == 0) {
        {
#line 182
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: %s, ",
                fullpath___2);
#line 183
        perror("");
        }
      }
#line 185
      return (result);
    }
    {
#line 187
    tmp___4 = strlen((char const   *)fullpath___2);
#line 187
    len = (int )tmp___4;
#line 188
    ptr = fullpath___2 + len;
    }
#line 191
    if (len < 900) {
#line 192
      if ((int )*(ptr - 1) != 47) {
#line 196
        *ptr = (char )'/';
#line 197
        ptr ++;
      }
#line 199
      *ptr = (char )'\000';
      {
#line 200
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 200
        dirp = readdir(dp);
        }
#line 200
        if (! ((unsigned long )((void *)0) != (unsigned long )dirp)) {
#line 200
          goto while_break;
        }
        {
#line 201
        tmp___5 = isnotdotdir(dirp->d_name);
        }
#line 201
        if (tmp___5) {
          {
#line 205
          strcpy((char */* __restrict  */)ptr, (char const   */* __restrict  */)(dirp->d_name));
#line 206
          traversetree(dirp->d_name);
          }
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 209
      closedir(dp);
#line 211
      ptr --;
      }
    }
#line 213
    *ptr = (char )'\000';
  }
#line 215
  return (result);
}
}
#line 332 "/home/june/repo/benchmarks/collector2/temp/whichman-2.4/ftff.c"
static void help___1(void) 
{ 


  {
  {
#line 334
  printf((char const   */* __restrict  */)"ftff -- fault tolerant file find utility\n\nUSAGE: ftff [-#fFhIpq][-t#] [--] [start_dir] filename \n\nftff uses an approximate string matching algorithm to match the file names.\n\nSupported wildcards: * : any arbitrary number of character\n                     ? : one character\n\nOPTIONS: -f  follow symbolic links on directories.\n         -F  classify the file type like \"ls -F\".\n         -h  this help.\n         -I  search case sensitive (default is case in-sensitive)\n         -p  print the actual distance value in front of the file name.\n         -q  Quiet. Do not print a warning when a directory can not be read.\n         -#  set fault tolerance level to # (integer in the range 0-255) \n             This is the maximum number of permitted errors.\n         -t# same as -# for backward compatibility\n\nThe default start_dir is the current directory. The default fault tolerance\nis (string length of searchpattern - number of wildcards)/6 +1.\n");
#line 355
  printf((char const   */* __restrict  */)"%s\n", "@(#)Version: 2.3");
#line 356
  exit(0);
  }
}
}
