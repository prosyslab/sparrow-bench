/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 10 "/home/wheatley/newnew/temp/mixal-1.08/mix.h"
enum __anonenum_Flag_1 {
    false = 0,
    true = 1
} ;
#line 10 "/home/wheatley/newnew/temp/mixal-1.08/mix.h"
typedef enum __anonenum_Flag_1 Flag;
#line 29 "/home/wheatley/newnew/temp/mixal-1.08/cell.h"
typedef long Cell;
#line 30 "/home/wheatley/newnew/temp/mixal-1.08/cell.h"
typedef unsigned int Byte;
#line 96 "/home/wheatley/newnew/temp/mixal-1.08/cell.h"
typedef unsigned int Address;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 98 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 31 "/usr/include/x86_64-linux-gnu/bits/setjmp.h"
typedef long __jmp_buf[8];
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_2 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_2 __sigset_t;
#line 34 "/usr/include/setjmp.h"
struct __jmp_buf_tag {
   __jmp_buf __jmpbuf ;
   int __mask_was_saved ;
   __sigset_t __saved_mask ;
};
#line 48 "/usr/include/setjmp.h"
typedef struct __jmp_buf_tag jmp_buf[1];
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 277 "/home/wheatley/newnew/temp/mixal-1.08/run.c"
struct __anonstruct_op_table_26 {
   void (*action)(void) ;
   unsigned int clocks ;
};
#line 7 "/home/wheatley/newnew/temp/mixal-1.08/symbol.h"
struct AddressList {
   struct AddressList *next ;
   Address address ;
};
#line 7 "/home/wheatley/newnew/temp/mixal-1.08/symbol.h"
typedef struct AddressList *AddressList;
#line 14 "/home/wheatley/newnew/temp/mixal-1.08/symbol.h"
struct Symbol {
   struct Symbol *next ;
   char *name ;
   Flag defined ;
   Cell cell ;
   AddressList references ;
};
#line 14 "/home/wheatley/newnew/temp/mixal-1.08/symbol.h"
typedef struct Symbol *Symbol;
#line 152 "/home/wheatley/newnew/temp/mixal-1.08/parse.c"
typedef Cell BinOp(Cell  , Cell  );
#line 22 "/home/wheatley/newnew/temp/mixal-1.08/io.c"
enum DeviceType {
    tape = 0,
    disk = 1,
    card_in = 2,
    card_out = 3,
    printer = 4,
    console = 5
} ;
#line 25 "/home/wheatley/newnew/temp/mixal-1.08/io.c"
struct __anonstruct_devices_7 {
   enum DeviceType  const  type ;
   FILE *file ;
   long position ;
};
#line 44 "/home/wheatley/newnew/temp/mixal-1.08/io.c"
typedef void IOHandler(unsigned int  , Cell  , Address  );
#line 45 "/home/wheatley/newnew/temp/mixal-1.08/io.c"
typedef void IOCHandler(unsigned int  , Cell  );
#line 53 "/home/wheatley/newnew/temp/mixal-1.08/io.c"
struct Device_attributes {
   char const   *base_filename ;
   unsigned int block_size ;
   IOHandler *in_handler ;
   IOHandler *out_handler ;
   IOCHandler *ioc_handler ;
};
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 59 "/usr/include/time.h"
typedef __clock_t clock_t;
#line 60 "/home/wheatley/newnew/temp/mixal-1.08/driver.c"
struct OpDef {
   char const   *name ;
   void (*handler)(void) ;
   Byte C ;
   Byte F ;
   Flag is_extended ;
};
#line 60 "/home/wheatley/newnew/temp/mixal-1.08/driver.c"
typedef struct OpDef  const  OpDef;
#line 111 "/home/wheatley/newnew/temp/mixal-1.08/driver.c"
typedef void (*Handler)(void);
#line 136 "/home/wheatley/newnew/temp/mixal-1.08/driver.c"
typedef char const   *const_char_ptr;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 19 "/home/wheatley/newnew/temp/mixal-1.08/mix.h"
void warn(char const   *message  , ...) ;
#line 20
void error(char const   *message  , ...) ;
#line 8 "/home/wheatley/newnew/temp/mixal-1.08/cell.h"
void precompute_field_data(void) ;
#line 53
Cell ulong_to_cell(unsigned long n ) ;
#line 55
Byte make_field_spec(unsigned int L , unsigned int R ) ;
#line 56
void assert_valid_field(Cell field_spec ) ;
#line 59
Cell field(Byte F___0 , Cell cell ) ;
#line 60
Cell set_field(Cell value , Byte F___0 , Cell into ) ;
#line 62
Byte get_byte(unsigned int F___0 , Cell cell ) ;
#line 63
Cell set_byte(Byte value , unsigned int F___0 , Cell into ) ;
#line 65
Flag overflow ;
#line 67
Cell add(Cell x , Cell y ) ;
#line 68
Cell sub(Cell x , Cell y ) ;
#line 70
void multiply(Cell x , Cell y , Cell *high_word , Cell *low_word ) ;
#line 71
Cell mul(Cell x , Cell y ) ;
#line 73
void divide(Cell n1 , Cell n0 , Cell d , Cell *quotient , Cell *remainder ) ;
#line 74
Cell slash(Cell x , Cell y ) ;
#line 76
void shift_left(Cell A , Cell X , unsigned long count , Cell *pA , Cell *pX ) ;
#line 77
void shift_right(Cell A , Cell X , unsigned long count , Cell *pA , Cell *pX ) ;
#line 78
void shift_left_circular(Cell A , Cell X , unsigned int count , Cell *pA , Cell *pX ) ;
#line 92
void print_cell(Cell cell ) ;
#line 93
void unparse_cell(char *buffer , Cell cell ) ;
#line 98
Cell address_to_cell(Address addr ) ;
#line 99
Address cell_to_address(Cell cell ) ;
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 7 "/home/wheatley/newnew/temp/mixal-1.08/cell.c"
Cell ulong_to_cell(unsigned long n ) 
{ 


  {
#line 9
  if ((unsigned long )((1L << 30) - 1L) < n) {
    {
#line 10
    warn("Value out of range: %lu", n);
    }
#line 11
    return ((1L << 30) - 1L);
  } else {
#line 13
    return ((Cell )n);
  }
}
}
#line 18 "/home/wheatley/newnew/temp/mixal-1.08/cell.c"
Byte get_byte(unsigned int F___0 , Cell cell ) 
{ 
  Byte tmp ;
  Cell tmp___0 ;

  {
#line 20
  if (! (F___0 != 0U)) {
    {
#line 20
    __assert_fail("F != 0", "/home/wheatley/newnew/temp/mixal-1.08/cell.c", 20U, "get_byte");
    }
  }
  {
#line 21
  tmp = make_field_spec(F___0, F___0);
#line 21
  tmp___0 = field(tmp, cell);
  }
#line 21
  return ((Byte )tmp___0);
}
}
#line 24 "/home/wheatley/newnew/temp/mixal-1.08/cell.c"
Cell set_byte(Byte value , unsigned int F___0 , Cell into ) 
{ 
  Byte tmp ;
  Cell tmp___0 ;

  {
#line 26
  if (! (F___0 != 0U)) {
    {
#line 26
    __assert_fail("F != 0", "/home/wheatley/newnew/temp/mixal-1.08/cell.c", 26U, "set_byte");
    }
  }
  {
#line 27
  tmp = make_field_spec(F___0, F___0);
#line 27
  tmp___0 = set_field((Cell )value, tmp, into);
  }
#line 27
  return (tmp___0);
}
}
#line 30 "/home/wheatley/newnew/temp/mixal-1.08/cell.c"
static Flag bad_field[64]  ;
#line 31 "/home/wheatley/newnew/temp/mixal-1.08/cell.c"
static unsigned int shift[64]  ;
#line 32 "/home/wheatley/newnew/temp/mixal-1.08/cell.c"
static long mask[64]  ;
#line 34 "/home/wheatley/newnew/temp/mixal-1.08/cell.c"
Cell field(Byte F___0 , Cell cell ) 
{ 


  {
#line 36
  if (bad_field[F___0]) {
    {
#line 37
    error("Bad field spec: %02o", F___0);
    }
  }
#line 38
  if (F___0 < 8U) {
#line 39
    return (((cell & mask[F___0]) >> shift[F___0]) | (cell & (1L << 30)));
  } else {
#line 41
    return ((cell & mask[F___0]) >> shift[F___0]);
  }
}
}
#line 44 "/home/wheatley/newnew/temp/mixal-1.08/cell.c"
Cell set_field(Cell value , Byte F___0 , Cell into ) 
{ 
  long m ;

  {
#line 46
  m = mask[F___0];
#line 47
  if (bad_field[F___0]) {
    {
#line 48
    error("Bad field spec: %02o", F___0);
    }
  }
#line 49
  if (F___0 < 8U) {
#line 50
    return ((((into & ~ m) & ~ (1L << 30)) | ((value << shift[F___0]) & m)) | (value & (1L << 30)));
  } else {
#line 52
    return ((into & ~ m) | ((value << shift[F___0]) & m));
  }
}
}
#line 55 "/home/wheatley/newnew/temp/mixal-1.08/cell.c"
void precompute_field_data(void) 
{ 
  unsigned int L ;
  unsigned int R ;
  unsigned int F___0 ;
  int tmp ;
  unsigned int width ;
  unsigned int tmp___0 ;

  {
#line 58
  L = 0U;
  {
#line 58
  while (1) {
    while_continue: /* CIL Label */ ;
#line 58
    if (! (L < 8U)) {
#line 58
      goto while_break;
    }
#line 59
    R = 0U;
    {
#line 59
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 59
      if (! (R < 8U)) {
#line 59
        goto while_break___0;
      }
#line 60
      F___0 = 8U * L + R;
#line 61
      if (R < L) {
#line 61
        tmp = 1;
      } else
#line 61
      if (5U < R) {
#line 61
        tmp = 1;
      } else {
#line 61
        tmp = 0;
      }
#line 61
      bad_field[F___0] = (Flag )tmp;
#line 62
      if (bad_field[F___0]) {
#line 63
        shift[F___0] = 0U;
#line 63
        mask[F___0] = 0L;
      } else {
#line 65
        if (L == 0U) {
#line 65
          tmp___0 = 1U;
        } else {
#line 65
          tmp___0 = L;
        }
#line 65
        width = (R - tmp___0) + 1U;
#line 66
        shift[F___0] = 6U * (5U - R);
#line 67
        mask[F___0] = ((1L << 6U * width) - 1L) << shift[F___0];
      }
#line 59
      R ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 58
    L ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 70
  return;
}
}
#line 72 "/home/wheatley/newnew/temp/mixal-1.08/cell.c"
Byte make_field_spec(unsigned int L , unsigned int R ) 
{ 
  unsigned int F___0 ;

  {
#line 74
  F___0 = 8U * L + R;
#line 75
  if (! (! bad_field[F___0])) {
    {
#line 75
    __assert_fail("!bad_field[F]", "/home/wheatley/newnew/temp/mixal-1.08/cell.c",
                  75U, "make_field_spec");
    }
  }
#line 76
  return (F___0);
}
}
#line 79 "/home/wheatley/newnew/temp/mixal-1.08/cell.c"
void assert_valid_field(Cell field_spec ) 
{ 
  char buffer[12] ;

  {
#line 81
  if ((field_spec & (1L << 30)) != 0L) {
    {
#line 85
    unparse_cell(buffer, field_spec);
#line 86
    error("Invalid field specifier: %s", buffer);
    }
  } else
#line 81
  if (64L <= (field_spec & ((1L << 30) - 1L))) {
    {
#line 85
    unparse_cell(buffer, field_spec);
#line 86
    error("Invalid field specifier: %s", buffer);
    }
  } else
#line 81
  if (bad_field[(unsigned int )(field_spec & ((1L << 30) - 1L))]) {
    {
#line 85
    unparse_cell(buffer, field_spec);
#line 86
    error("Invalid field specifier: %s", buffer);
    }
  }
#line 88
  return;
}
}
#line 92 "/home/wheatley/newnew/temp/mixal-1.08/cell.c"
Flag overflow  =    (Flag )0;
#line 94 "/home/wheatley/newnew/temp/mixal-1.08/cell.c"
Cell add(Cell x , Cell y ) 
{ 
  long sum ;
  long magnitude_of_sum ;
  long diff ;
  long tmp ;

  {
#line 97
  if ((x & (1L << 30)) == (y & (1L << 30))) {
#line 98
    sum = (x & ((1L << 30) - 1L)) + (y & ((1L << 30) - 1L));
#line 99
    magnitude_of_sum = sum & ((1L << 30) - 1L);
#line 100
    if (magnitude_of_sum != sum) {
#line 100
      overflow = (Flag )1;
    }
#line 101
    return ((x & (1L << 30)) | magnitude_of_sum);
  } else {
#line 103
    diff = (x & ((1L << 30) - 1L)) - (y & ((1L << 30) - 1L));
#line 104
    if (diff < 0L) {
#line 104
      tmp = (y & (1L << 30)) | - diff;
    } else {
#line 104
      tmp = (x & (1L << 30)) | diff;
    }
#line 104
    return (tmp);
  }
}
}
#line 108 "/home/wheatley/newnew/temp/mixal-1.08/cell.c"
Cell sub(Cell x , Cell y ) 
{ 
  Cell tmp ;

  {
  {
#line 110
  tmp = add(x, y ^ (1L << 30));
  }
#line 110
  return (tmp);
}
}
#line 113 "/home/wheatley/newnew/temp/mixal-1.08/cell.c"
void multiply(Cell x , Cell y , Cell *high_word , Cell *low_word ) 
{ 
  unsigned long sign ;
  unsigned long x0 ;
  unsigned long x1 ;
  unsigned long x2 ;
  unsigned long y0 ;
  unsigned long y1 ;
  unsigned long y2 ;
  unsigned long partial0 ;
  unsigned long partial1 ;
  unsigned long partial2 ;
  unsigned long partial3 ;
  unsigned long partial4 ;
  unsigned long sum1 ;
  unsigned long carry1 ;
  unsigned long sum2 ;
  unsigned long carry2 ;
  unsigned long sum3 ;

  {
#line 115
  sign = (unsigned long )((x & (1L << 30)) ^ (y & (1L << 30)));
#line 122
  x0 = (unsigned long )(x & 1023L);
#line 123
  x1 = (unsigned long )((x & 1047552L) >> 10);
#line 124
  x2 = (unsigned long )((x & 1072693248L) >> 20);
#line 125
  y0 = (unsigned long )(y & 1023L);
#line 126
  y1 = (unsigned long )((y & 1047552L) >> 10);
#line 127
  y2 = (unsigned long )((y & 1072693248L) >> 20);
#line 139
  partial0 = x0 * y0;
#line 140
  partial1 = x0 * y1 + x1 * y0;
#line 141
  partial2 = (x0 * y2 + x1 * y1) + x2 * y0;
#line 142
  partial3 = x1 * y2 + x2 * y1;
#line 143
  partial4 = x2 * y2;
#line 146
  sum1 = partial0 + (partial1 << 10);
#line 147
  carry1 = (sum1 & 4293918720UL) >> 20;
#line 150
  sum2 = (partial2 + (partial3 << 10)) + carry1;
#line 151
  carry2 = (sum2 & 4293918720UL) >> 20;
#line 154
  sum3 = partial4 + carry2;
#line 156
  sum1 &= 1048575UL;
#line 157
  sum2 &= 1048575UL;
#line 162
  *low_word = (Cell )(sum1 | ((sum2 & 1023UL) << 20));
#line 163
  *low_word = (Cell )((unsigned long )*low_word | sign);
#line 164
  *high_word = (Cell )(((sum2 & 1047552UL) >> 10) | (sum3 << 10));
#line 165
  *high_word = (Cell )((unsigned long )*high_word | sign);
#line 167
  return;
}
}
#line 169 "/home/wheatley/newnew/temp/mixal-1.08/cell.c"
Cell mul(Cell x , Cell y ) 
{ 
  Cell lo ;
  Cell hi ;

  {
  {
#line 172
  multiply(x, y, & hi, & lo);
  }
#line 173
  if ((hi & ((1L << 30) - 1L)) != 0L) {
#line 173
    overflow = (Flag )1;
  }
#line 174
  return (lo);
}
}
#line 177 "/home/wheatley/newnew/temp/mixal-1.08/cell.c"
void divide(Cell n1 , Cell n0 , Cell d , Cell *quotient , Cell *remainder ) 
{ 
  long magn1 ;
  long magd ;
  Cell tmp ;
  Cell tmp___0 ;
  long q ;
  long r___0 ;
  unsigned int i ;

  {
#line 179
  magn1 = n1 & ((1L << 30) - 1L);
#line 180
  magd = d & ((1L << 30) - 1L);
#line 181
  if (magd == 0L) {
#line 182
    overflow = (Flag )1;
#line 183
    tmp = (Cell )0;
#line 183
    *remainder = tmp;
#line 183
    *quotient = tmp;
  } else
#line 184
  if (magn1 == 0L) {
#line 185
    *quotient = ((n1 & (1L << 30)) ^ (d & (1L << 30))) | (n0 & ((1L << 30) - 1L)) / magd;
#line 186
    *remainder = (n1 & (1L << 30)) | (n0 & ((1L << 30) - 1L)) % magd;
  } else
#line 187
  if (magd <= magn1) {
#line 188
    overflow = (Flag )1;
#line 189
    tmp___0 = (Cell )0;
#line 189
    *remainder = tmp___0;
#line 189
    *quotient = tmp___0;
  } else {
#line 191
    q = n0 & ((1L << 30) - 1L);
#line 192
    r___0 = magn1;
#line 194
    i = 30U;
    {
#line 194
    while (1) {
      while_continue: /* CIL Label */ ;
#line 194
      if (! (i != 0U)) {
#line 194
        goto while_break;
      }
#line 195
      r___0 <<= 1;
#line 196
      if (q & (1L << 29)) {
#line 197
        r___0 ++;
      }
#line 198
      q = (q << 1) & ((1L << 30) - 1L);
#line 199
      if (magd <= r___0) {
#line 200
        q ++;
#line 200
        r___0 -= magd;
      }
#line 194
      i --;
    }
    while_break: /* CIL Label */ ;
    }
#line 202
    *quotient = ((n1 & (1L << 30)) ^ (d & (1L << 30))) | q;
#line 203
    *remainder = (n1 & (1L << 30)) | r___0;
  }
#line 205
  return;
}
}
#line 207 "/home/wheatley/newnew/temp/mixal-1.08/cell.c"
Cell slash(Cell x , Cell y ) 
{ 
  Cell quotient ;
  Cell remainder ;

  {
  {
#line 210
  divide(x & (1L << 30), x, y, & quotient, & remainder);
  }
#line 211
  return (quotient);
}
}
#line 216 "/home/wheatley/newnew/temp/mixal-1.08/cell.c"
void shift_right(Cell A , Cell X , unsigned long count , Cell *pA , Cell *pX ) 
{ 


  {
#line 218
  *pX = X & (1L << 30);
#line 219
  *pA = A & (1L << 30);
#line 220
  if (count < 5UL) {
#line 221
    *pA |= (A & ((1L << 30) - 1L)) >> 6UL * count;
#line 222
    *pX |= (((1L << 30) - 1L) & ((X & ((1L << 30) - 1L)) >> 6UL * count)) & (A << (30UL - 6UL * count));
  } else
#line 224
  if (count < 10UL) {
#line 225
    *pX |= (A & ((1L << 30) - 1L)) >> (6UL * count - 30UL);
  }
#line 228
  return;
}
}
#line 230 "/home/wheatley/newnew/temp/mixal-1.08/cell.c"
void shift_left(Cell A , Cell X , unsigned long count , Cell *pA , Cell *pX ) 
{ 


  {
#line 232
  *pX = X & (1L << 30);
#line 233
  *pA = A & (1L << 30);
#line 234
  if (count < 5UL) {
#line 235
    *pX |= ((1L << 30) - 1L) & (X << 6UL * count);
#line 236
    *pA |= (((1L << 30) - 1L) & (A << 6UL * count)) & ((X & ((1L << 30) - 1L)) >> (30UL - 6UL * count));
  } else
#line 238
  if (count < 10UL) {
#line 239
    *pA |= ((1L << 30) - 1L) & (X << (6UL * count - 30UL));
  }
#line 242
  return;
}
}
#line 245 "/home/wheatley/newnew/temp/mixal-1.08/cell.c"
void shift_left_circular(Cell A , Cell X , unsigned int count , Cell *pA , Cell *pX ) 
{ 
  Cell A1 ;
  Cell tmp ;
  Cell X1 ;
  Cell tmp___0 ;
  unsigned int c ;
  unsigned int tmp___1 ;

  {
#line 247
  if (count < 5U) {
#line 247
    tmp = A;
  } else {
#line 247
    tmp = X;
  }
#line 247
  A1 = tmp;
#line 248
  if (count < 5U) {
#line 248
    tmp___0 = X;
  } else {
#line 248
    tmp___0 = A;
  }
#line 248
  X1 = tmp___0;
#line 249
  if (count < 5U) {
#line 249
    tmp___1 = count;
  } else {
#line 249
    tmp___1 = count - 5U;
  }
#line 249
  c = 6U * tmp___1;
#line 250
  *pX = (X & (1L << 30)) | ((((1L << 30) - 1L) & (X1 << c)) & ((A1 & ((1L << 30) - 1L)) >> (30U - c)));
#line 252
  *pA = (A & (1L << 30)) | ((((1L << 30) - 1L) & (A1 << c)) & ((X1 & ((1L << 30) - 1L)) >> (30U - c)));
#line 254
  return;
}
}
#line 258 "/home/wheatley/newnew/temp/mixal-1.08/cell.c"
void print_cell(Cell cell ) 
{ 
  char const   *tmp ;

  {
#line 260
  if ((cell & (1L << 30)) == 0L) {
#line 260
    tmp = " ";
  } else {
#line 260
    tmp = "-";
  }
  {
#line 260
  printf((char const   */* __restrict  */)"%s%010lo", tmp, cell & ((1L << 30) - 1L));
  }
#line 261
  return;
}
}
#line 263 "/home/wheatley/newnew/temp/mixal-1.08/cell.c"
void unparse_cell(char *buffer , Cell cell ) 
{ 
  char const   *tmp ;

  {
#line 265
  if ((cell & (1L << 30)) == 0L) {
#line 265
    tmp = " ";
  } else {
#line 265
    tmp = "-";
  }
  {
#line 265
  sprintf((char */* __restrict  */)buffer, (char const   */* __restrict  */)"%s%010lo",
          tmp, cell & ((1L << 30) - 1L));
  }
#line 266
  return;
}
}
#line 270 "/home/wheatley/newnew/temp/mixal-1.08/cell.c"
Cell address_to_cell(Address addr ) 
{ 


  {
#line 270
  return ((Cell )addr);
}
}
#line 272 "/home/wheatley/newnew/temp/mixal-1.08/cell.c"
Address cell_to_address(Cell cell ) 
{ 
  char buffer[12] ;

  {
#line 274
  if ((cell & (1L << 30)) != 0L) {
#line 274
    if ((cell & ((1L << 30) - 1L)) != 0L) {
      {
#line 277
      unparse_cell(buffer, cell);
#line 278
      error("Value is not an address: %s", buffer);
      }
#line 279
      return ((Address )0);
    } else {
#line 274
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 274
  if (4000L <= (cell & ((1L << 30) - 1L))) {
    {
#line 277
    unparse_cell(buffer, cell);
#line 278
    error("Value is not an address: %s", buffer);
    }
#line 279
    return ((Address )0);
  }
#line 281
  return ((Address )(cell & ((1L << 30) - 1L)));
}
}
#line 18 "/home/wheatley/newnew/temp/mixal-1.08/mix.h"
void install_error_handler(void (*handler)(char const   * , va_list  ) ) ;
#line 14 "/home/wheatley/newnew/temp/mixal-1.08/asm.h"
Address entry_point ;
#line 6 "/home/wheatley/newnew/temp/mixal-1.08/charset.h"
Byte C_char_to_mix(char c ) ;
#line 7 "/home/wheatley/newnew/temp/mixal-1.08/io.h"
void io_control(Byte device , Cell argument ) ;
#line 8
void do_input(Byte device , Cell argument , Address buffer ) ;
#line 9
void do_output(Byte device , Cell argument , Address buffer ) ;
#line 7 "/home/wheatley/newnew/temp/mixal-1.08/run.h"
Cell memory[4000]  ;
#line 9
void set_initial_state(void) ;
#line 10
void print_CPU_state(void) ;
#line 11
void run(void) ;
#line 63 "/usr/include/setjmp.h"
extern  __attribute__((__nothrow__)) int _setjmp(struct __jmp_buf_tag *__env ) ;
#line 74
extern  __attribute__((__nothrow__, __noreturn__)) void longjmp(struct __jmp_buf_tag *__env ,
                                                                int __val ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 13 "/home/wheatley/newnew/temp/mixal-1.08/run.c"
static void stop(char const   *message , va_list args ) 
{ 


  {
  {
#line 15
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"RUNTIME ERROR: ");
#line 16
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)message,
           args);
#line 17
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 18
  print_CPU_state();
#line 19
  exit(1);
  }
}
}
#line 24 "/home/wheatley/newnew/temp/mixal-1.08/run.c"
static unsigned long elapsed_time  =    0UL;
#line 33 "/home/wheatley/newnew/temp/mixal-1.08/run.c"
static Cell r[10]  ;
#line 35 "/home/wheatley/newnew/temp/mixal-1.08/run.c"
static int comparison_indicator  ;
#line 36 "/home/wheatley/newnew/temp/mixal-1.08/run.c"
static Address pc  ;
#line 38 "/home/wheatley/newnew/temp/mixal-1.08/run.c"
void set_initial_state(void) 
{ 
  unsigned int i ;

  {
#line 40
  overflow = (Flag )0;
#line 41
  comparison_indicator = 0;
#line 44
  i = 0U;
  {
#line 44
  while (1) {
    while_continue: /* CIL Label */ ;
#line 44
    if (! (i < 10U)) {
#line 44
      goto while_break;
    }
#line 45
    r[i] = (Cell )0;
#line 44
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 47
  pc = entry_point;
#line 48
  return;
}
}
#line 50 "/home/wheatley/newnew/temp/mixal-1.08/run.c"
void print_CPU_state(void) 
{ 
  unsigned int i ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;

  {
  {
#line 52
  printf((char const   */* __restrict  */)"A:");
#line 53
  print_cell(r[0]);
#line 54
  printf((char const   */* __restrict  */)"\t");
#line 57
  i = 1U;
  }
  {
#line 57
  while (1) {
    while_continue: /* CIL Label */ ;
#line 57
    if (! (i <= 6U)) {
#line 57
      goto while_break;
    }
#line 58
    if ((r[i] & (1L << 30)) != 0L) {
#line 58
      tmp = "-";
    } else {
#line 58
      tmp = " ";
    }
    {
#line 58
    printf((char const   */* __restrict  */)"I%u:%s%04lo  ", i, tmp, r[i] & ((1L << 30) - 1L));
#line 57
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 61
  printf((char const   */* __restrict  */)"\nX:");
#line 62
  print_cell(r[7]);
#line 63
  printf((char const   */* __restrict  */)"\t J: %04lo", r[8] & ((1L << 30) - 1L));
#line 64
  printf((char const   */* __restrict  */)"  PC: %04o", pc);
  }
#line 65
  if (overflow) {
#line 65
    tmp___0 = "overflow";
  } else {
#line 65
    tmp___0 = "";
  }
#line 65
  if (comparison_indicator < 0) {
#line 65
    tmp___2 = "less";
  } else {
#line 65
    if (comparison_indicator == 0) {
#line 65
      tmp___1 = "equal";
    } else {
#line 65
      tmp___1 = "greater";
    }
#line 65
    tmp___2 = tmp___1;
  }
  {
#line 65
  printf((char const   */* __restrict  */)"  Flags: %-7s %-8s", tmp___2, tmp___0);
#line 69
  printf((char const   */* __restrict  */)" %11lu elapsed\n", elapsed_time);
  }
#line 70
  return;
}
}
#line 76 "/home/wheatley/newnew/temp/mixal-1.08/run.c"
static jmp_buf escape_k  ;
#line 80 "/home/wheatley/newnew/temp/mixal-1.08/run.c"
static Byte C  ;
#line 81 "/home/wheatley/newnew/temp/mixal-1.08/run.c"
static Byte F  ;
#line 82 "/home/wheatley/newnew/temp/mixal-1.08/run.c"
static Cell M  ;
#line 84 "/home/wheatley/newnew/temp/mixal-1.08/run.c"
static Cell get_V(void) 
{ 
  Address tmp ;
  Cell tmp___0 ;

  {
  {
#line 86
  tmp = cell_to_address(M);
#line 86
  tmp___0 = field(F, memory[tmp]);
  }
#line 86
  return (tmp___0);
}
}
#line 91 "/home/wheatley/newnew/temp/mixal-1.08/run.c"
static void do_nop(void) 
{ 


  {
#line 91
  return;
}
}
#line 93 "/home/wheatley/newnew/temp/mixal-1.08/run.c"
static void do_add(void) 
{ 
  Cell tmp ;

  {
  {
#line 93
  tmp = get_V();
#line 93
  r[0] = add(r[0], tmp);
  }
#line 93
  return;
}
}
#line 94 "/home/wheatley/newnew/temp/mixal-1.08/run.c"
static void do_sub(void) 
{ 
  Cell tmp ;

  {
  {
#line 94
  tmp = get_V();
#line 94
  r[0] = sub(r[0], tmp);
  }
#line 94
  return;
}
}
#line 96 "/home/wheatley/newnew/temp/mixal-1.08/run.c"
static void do_mul(void) 
{ 
  Cell tmp ;

  {
  {
#line 96
  tmp = get_V();
#line 96
  multiply(r[0], tmp, & r[0], & r[7]);
  }
#line 96
  return;
}
}
#line 97 "/home/wheatley/newnew/temp/mixal-1.08/run.c"
static void do_div(void) 
{ 
  Cell tmp ;

  {
  {
#line 97
  tmp = get_V();
#line 97
  divide(r[0], r[7], tmp, & r[0], & r[7]);
  }
#line 97
  return;
}
}
#line 99 "/home/wheatley/newnew/temp/mixal-1.08/run.c"
static void do_special(void) 
{ 
  unsigned int i ;
  Cell num ;
  Cell ten ;
  Cell tmp ;
  Byte tmp___0 ;
  Cell tmp___1 ;
  Byte tmp___2 ;
  Cell tmp___3 ;
  unsigned long num___0 ;
  unsigned int z ;
  Byte tmp___4 ;
  unsigned int i___0 ;

  {
  {
#line 102
  if (F == 0U) {
#line 102
    goto case_0;
  }
#line 113
  if (F == 1U) {
#line 113
    goto case_1;
  }
#line 123
  if (F == 2U) {
#line 123
    goto case_2;
  }
#line 125
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 104
  num = (Cell )0;
#line 105
  tmp = ulong_to_cell(10UL);
#line 105
  ten = tmp;
#line 106
  i = 1U;
  }
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
#line 106
    if (! (i <= 5U)) {
#line 106
      goto while_break;
    }
    {
#line 107
    tmp___0 = get_byte(i, r[0]);
#line 107
    tmp___1 = mul(ten, num);
#line 107
    num = add(tmp___1, (Cell )(tmp___0 % 10U));
#line 106
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 108
  i = 1U;
  {
#line 108
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 108
    if (! (i <= 5U)) {
#line 108
      goto while_break___0;
    }
    {
#line 109
    tmp___2 = get_byte(i, r[7]);
#line 109
    tmp___3 = mul(ten, num);
#line 109
    num = add(tmp___3, (Cell )(tmp___2 % 10U));
#line 108
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 110
  if ((r[0] & (1L << 30)) != 0L) {
#line 110
    r[0] = num ^ (1L << 30);
  } else {
#line 110
    r[0] = num;
  }
#line 111
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 114
  num___0 = (unsigned long )(r[0] & ((1L << 30) - 1L));
#line 115
  tmp___4 = C_char_to_mix((char )'0');
#line 115
  z = tmp___4;
#line 117
  i___0 = 5U;
  }
  {
#line 117
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 117
    if (! (0U < i___0)) {
#line 117
      goto while_break___1;
    }
    {
#line 118
    r[7] = set_byte((Byte )((unsigned long )z + num___0 % 10UL), i___0, r[7]);
#line 117
    i___0 --;
#line 117
    num___0 /= 10UL;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 119
  i___0 = 5U;
  {
#line 119
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 119
    if (! (0U < i___0)) {
#line 119
      goto while_break___2;
    }
    {
#line 120
    r[0] = set_byte((Byte )((unsigned long )z + num___0 % 10UL), i___0, r[0]);
#line 119
    i___0 --;
#line 119
    num___0 /= 10UL;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 121
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 124
  longjmp((struct __jmp_buf_tag *)(escape_k), 1);
  }
  switch_default: /* CIL Label */ 
  {
#line 125
  error("Unknown extended opcode");
  }
  switch_break: /* CIL Label */ ;
  }
#line 127
  return;
}
}
#line 129 "/home/wheatley/newnew/temp/mixal-1.08/run.c"
static void do_shift(void) 
{ 
  Cell ignore ;
  unsigned long count ;
  unsigned int c ;

  {
#line 132
  count = (unsigned long )(M & ((1L << 30) - 1L));
#line 133
  if ((M & (1L << 30)) != 0L) {
#line 133
    if (count != 0UL) {
      {
#line 134
      error("Negative shift count");
      }
    }
  }
  {
#line 136
  if (F == 0U) {
#line 136
    goto case_0;
  }
#line 139
  if (F == 1U) {
#line 139
    goto case_1;
  }
#line 142
  if (F == 2U) {
#line 142
    goto case_2;
  }
#line 145
  if (F == 3U) {
#line 145
    goto case_3;
  }
#line 148
  if (F == 4U) {
#line 148
    goto case_4;
  }
#line 151
  if (F == 5U) {
#line 151
    goto case_5;
  }
#line 156
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 137
  shift_left((Cell )0, r[0], count, & ignore, & r[0]);
  }
#line 138
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 140
  shift_right(r[0], (Cell )0, count, & r[0], & ignore);
  }
#line 141
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 143
  shift_left(r[0], r[7], count, & r[0], & r[7]);
  }
#line 144
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 146
  shift_right(r[0], r[7], count, & r[0], & r[7]);
  }
#line 147
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 149
  shift_left_circular(r[0], r[7], (unsigned int )(count % 10UL), & r[0], & r[7]);
  }
#line 150
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 152
  c = (unsigned int )((10UL - count % 10UL) % 10UL);
#line 153
  shift_left_circular(r[0], r[7], c, & r[0], & r[7]);
  }
#line 154
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 156
  error("Unknown extended opcode");
  }
  switch_break: /* CIL Label */ ;
  }
#line 158
  return;
}
}
#line 160 "/home/wheatley/newnew/temp/mixal-1.08/run.c"
static void do_move(void) 
{ 
  Address from ;
  Address tmp ;
  Address to ;
  Address tmp___0 ;
  unsigned int count ;

  {
  {
#line 162
  tmp = cell_to_address(M);
#line 162
  from = tmp;
#line 163
  tmp___0 = cell_to_address(r[1]);
#line 163
  to = tmp___0;
#line 164
  count = F;
  }
  {
#line 165
  while (1) {
    while_continue: /* CIL Label */ ;
#line 165
    if (! (count != 0U)) {
#line 165
      goto while_break;
    }
#line 166
    if (4000U <= from + count) {
      {
#line 167
      error("Address out of range");
      }
    } else
#line 166
    if (4000U <= to + count) {
      {
#line 167
      error("Address out of range");
      }
    }
#line 168
    memory[to + count] = memory[from + count];
#line 169
    elapsed_time += 2UL;
#line 165
    count --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 171
  r[1] = address_to_cell(to + count);
  }
#line 172
  return;
}
}
#line 174 "/home/wheatley/newnew/temp/mixal-1.08/run.c"
static void do_lda(void) 
{ 


  {
  {
#line 174
  r[0] = get_V();
  }
#line 174
  return;
}
}
#line 175 "/home/wheatley/newnew/temp/mixal-1.08/run.c"
static void do_ldx(void) 
{ 


  {
  {
#line 175
  r[7] = get_V();
  }
#line 175
  return;
}
}
#line 176 "/home/wheatley/newnew/temp/mixal-1.08/run.c"
static void do_ldi(void) 
{ 
  Cell cell ;
  Cell tmp ;

  {
  {
#line 177
  tmp = get_V();
#line 177
  cell = tmp;
  }
#line 178
  if ((1L << 12) - 1L < (cell & ((1L << 30) - 1L))) {
    {
#line 179
    error("Magnitude too large for index register: %10o", cell & ((1L << 30) - 1L));
    }
  }
#line 180
  r[C & 7U] = cell;
#line 181
  return;
}
}
#line 183 "/home/wheatley/newnew/temp/mixal-1.08/run.c"
static void do_ldan(void) 
{ 
  Cell tmp ;

  {
  {
#line 183
  tmp = get_V();
#line 183
  r[0] = tmp ^ (1L << 30);
  }
#line 183
  return;
}
}
#line 184 "/home/wheatley/newnew/temp/mixal-1.08/run.c"
static void do_ldxn(void) 
{ 
  Cell tmp ;

  {
  {
#line 184
  tmp = get_V();
#line 184
  r[7] = tmp ^ (1L << 30);
  }
#line 184
  return;
}
}
#line 185 "/home/wheatley/newnew/temp/mixal-1.08/run.c"
static void do_ldin(void) 
{ 
  Cell cell ;
  Cell tmp ;

  {
  {
#line 186
  tmp = get_V();
#line 186
  cell = tmp;
  }
#line 187
  if ((1L << 12) - 1L < (cell & ((1L << 30) - 1L))) {
    {
#line 188
    error("Magnitude too large for index register: %10o", cell & ((1L << 30) - 1L));
    }
  }
#line 189
  r[C & 7U] = cell ^ (1L << 30);
#line 190
  return;
}
}
#line 192 "/home/wheatley/newnew/temp/mixal-1.08/run.c"
static void do_store(void) 
{ 
  Address a ;
  Address tmp ;

  {
  {
#line 194
  tmp = cell_to_address(M);
#line 194
  a = tmp;
#line 195
  memory[a] = set_field(r[C - 24U], F, memory[a]);
  }
#line 196
  return;
}
}
#line 198 "/home/wheatley/newnew/temp/mixal-1.08/run.c"
static void jump(void) 
{ 


  {
  {
#line 200
  r[8] = address_to_cell(pc);
#line 201
  pc = cell_to_address(M);
  }
#line 202
  return;
}
}
#line 204 "/home/wheatley/newnew/temp/mixal-1.08/run.c"
static void branch(unsigned int condition , int sign ) 
{ 


  {
  {
#line 207
  if (condition == 0U) {
#line 207
    goto case_0;
  }
#line 208
  if (condition == 1U) {
#line 208
    goto case_1;
  }
#line 209
  if (condition == 2U) {
#line 209
    goto case_2;
  }
#line 210
  if (condition == 3U) {
#line 210
    goto case_3;
  }
#line 211
  if (condition == 4U) {
#line 211
    goto case_4;
  }
#line 212
  if (condition == 5U) {
#line 212
    goto case_5;
  }
#line 213
  if (condition == 6U) {
#line 213
    goto case_6;
  }
#line 214
  if (condition == 7U) {
#line 214
    goto case_7;
  }
#line 215
  if (condition == 8U) {
#line 215
    goto case_8;
  }
#line 216
  if (condition == 9U) {
#line 216
    goto case_9;
  }
#line 217
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 207
  jump();
  }
#line 207
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 208
  pc = cell_to_address(M);
  }
#line 208
  goto switch_break;
  case_2: /* CIL Label */ 
#line 209
  if (overflow) {
    {
#line 209
    jump();
    }
  }
#line 209
  overflow = (Flag )0;
#line 209
  goto switch_break;
  case_3: /* CIL Label */ 
#line 210
  if (! overflow) {
    {
#line 210
    jump();
    }
  }
#line 210
  overflow = (Flag )0;
#line 210
  goto switch_break;
  case_4: /* CIL Label */ 
#line 211
  if (sign < 0) {
    {
#line 211
    jump();
    }
  }
#line 211
  goto switch_break;
  case_5: /* CIL Label */ 
#line 212
  if (sign == 0) {
    {
#line 212
    jump();
    }
  }
#line 212
  goto switch_break;
  case_6: /* CIL Label */ 
#line 213
  if (sign > 0) {
    {
#line 213
    jump();
    }
  }
#line 213
  goto switch_break;
  case_7: /* CIL Label */ 
#line 214
  if (sign >= 0) {
    {
#line 214
    jump();
    }
  }
#line 214
  goto switch_break;
  case_8: /* CIL Label */ 
#line 215
  if (sign != 0) {
    {
#line 215
    jump();
    }
  }
#line 215
  goto switch_break;
  case_9: /* CIL Label */ 
#line 216
  if (sign <= 0) {
    {
#line 216
    jump();
    }
  }
#line 216
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 217
  error("Bad branch condition");
  }
  switch_break: /* CIL Label */ ;
  }
#line 219
  return;
}
}
#line 221 "/home/wheatley/newnew/temp/mixal-1.08/run.c"
static void do_jump(void) 
{ 


  {
  {
#line 223
  branch(F, comparison_indicator);
  }
#line 224
  return;
}
}
#line 226 "/home/wheatley/newnew/temp/mixal-1.08/run.c"
static int sign_of_difference(Cell difference ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 228
  if ((difference & ((1L << 30) - 1L)) == 0L) {
#line 228
    tmp___0 = 0;
  } else {
#line 228
    if ((difference & (1L << 30)) != 0L) {
#line 228
      tmp = -1;
    } else {
#line 228
      tmp = 1;
    }
#line 228
    tmp___0 = tmp;
  }
#line 228
  return (tmp___0);
}
}
#line 231 "/home/wheatley/newnew/temp/mixal-1.08/run.c"
static void do_reg_branch(void) 
{ 
  int tmp ;

  {
  {
#line 233
  tmp = sign_of_difference(r[C & 7U]);
#line 233
  branch(F + 4U, tmp);
  }
#line 234
  return;
}
}
#line 236 "/home/wheatley/newnew/temp/mixal-1.08/run.c"
static void do_jbus(void) 
{ 


  {
#line 239
  return;
}
}
#line 241 "/home/wheatley/newnew/temp/mixal-1.08/run.c"
static void do_jred(void) 
{ 


  {
  {
#line 243
  jump();
  }
#line 244
  return;
}
}
#line 246 "/home/wheatley/newnew/temp/mixal-1.08/run.c"
static void do_ioc(void) 
{ 


  {
  {
#line 246
  io_control(F, M);
  }
#line 246
  return;
}
}
#line 247 "/home/wheatley/newnew/temp/mixal-1.08/run.c"
static void do_in(void) 
{ 
  Address tmp ;

  {
  {
#line 247
  tmp = cell_to_address(M);
#line 247
  do_input(F, r[7], tmp);
  }
#line 247
  return;
}
}
#line 248 "/home/wheatley/newnew/temp/mixal-1.08/run.c"
static void do_out(void) 
{ 
  Address tmp ;

  {
  {
#line 248
  tmp = cell_to_address(M);
#line 248
  do_output(F, r[7], tmp);
  }
#line 248
  return;
}
}
#line 250 "/home/wheatley/newnew/temp/mixal-1.08/run.c"
static void do_addr_op(void) 
{ 
  Cell cell ;
  unsigned int reg ;

  {
#line 253
  reg = C & 7U;
  {
#line 255
  if (F == 0U) {
#line 255
    goto case_0;
  }
#line 256
  if (F == 1U) {
#line 256
    goto case_1;
  }
#line 257
  if (F == 2U) {
#line 257
    goto case_2;
  }
#line 258
  if (F == 3U) {
#line 258
    goto case_3;
  }
#line 259
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 255
  cell = add(r[reg], M);
  }
#line 255
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 256
  cell = sub(r[reg], M);
  }
#line 256
  goto switch_break;
  case_2: /* CIL Label */ 
#line 257
  cell = M;
#line 257
  goto switch_break;
  case_3: /* CIL Label */ 
#line 258
  cell = M ^ (1L << 30);
#line 258
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 259
  error("Unknown extended opcode");
#line 259
  cell = (Cell )0;
  }
  switch_break: /* CIL Label */ ;
  }
#line 261
  if (reg - 1U < 6U) {
#line 262
    if ((1L << 12) - 1L < (cell & ((1L << 30) - 1L))) {
      {
#line 263
      error("Magnitude too large for index register: %10o", cell & ((1L << 30) - 1L));
      }
    }
  }
#line 265
  r[reg] = cell;
#line 266
  return;
}
}
#line 268 "/home/wheatley/newnew/temp/mixal-1.08/run.c"
static void do_compare(void) 
{ 
  Flag saved ;
  Cell difference ;
  Address tmp ;
  Cell tmp___0 ;
  Cell tmp___1 ;
  Cell tmp___2 ;

  {
  {
#line 270
  saved = overflow;
#line 271
  tmp = cell_to_address(M);
#line 271
  tmp___0 = field(F, memory[tmp]);
#line 271
  tmp___1 = field(F, r[C & 7U]);
#line 271
  tmp___2 = sub(tmp___1, tmp___0);
#line 271
  difference = tmp___2;
#line 273
  comparison_indicator = sign_of_difference(difference);
#line 274
  overflow = saved;
  }
#line 275
  return;
}
}
#line 277 "/home/wheatley/newnew/temp/mixal-1.08/run.c"
static struct __anonstruct_op_table_26  const  op_table[64]  = 
#line 277
  {      {& do_nop, 1U}, 
        {& do_add, 2U}, 
        {& do_sub, 2U}, 
        {& do_mul, 10U}, 
        {& do_div, 12U}, 
        {& do_special, 1U}, 
        {& do_shift, 2U}, 
        {& do_move, 1U}, 
        {& do_lda, 2U}, 
        {& do_ldi, 2U}, 
        {& do_ldi, 2U}, 
        {& do_ldi, 2U}, 
        {& do_ldi, 2U}, 
        {& do_ldi, 2U}, 
        {& do_ldi, 2U}, 
        {& do_ldx, 2U}, 
        {& do_ldan, 2U}, 
        {& do_ldin, 2U}, 
        {& do_ldin, 2U}, 
        {& do_ldin, 2U}, 
        {& do_ldin, 2U}, 
        {& do_ldin, 2U}, 
        {& do_ldin, 2U}, 
        {& do_ldxn, 2U}, 
        {& do_store, 2U}, 
        {& do_store, 2U}, 
        {& do_store, 2U}, 
        {& do_store, 2U}, 
        {& do_store, 2U}, 
        {& do_store, 2U}, 
        {& do_store, 2U}, 
        {& do_store, 2U}, 
        {& do_store, 2U}, 
        {& do_store, 2U}, 
        {& do_jbus, 1U}, 
        {& do_ioc, 1U}, 
        {& do_in, 1U}, 
        {& do_out, 1U}, 
        {& do_jred, 1U}, 
        {& do_jump, 1U}, 
        {& do_reg_branch, 1U}, 
        {& do_reg_branch, 1U}, 
        {& do_reg_branch, 1U}, 
        {& do_reg_branch, 1U}, 
        {& do_reg_branch, 1U}, 
        {& do_reg_branch, 1U}, 
        {& do_reg_branch, 1U}, 
        {& do_reg_branch, 1U}, 
        {& do_addr_op, 1U}, 
        {& do_addr_op, 1U}, 
        {& do_addr_op, 1U}, 
        {& do_addr_op, 1U}, 
        {& do_addr_op, 1U}, 
        {& do_addr_op, 1U}, 
        {& do_addr_op, 1U}, 
        {& do_addr_op, 1U}, 
        {& do_compare, 2U}, 
        {& do_compare, 2U}, 
        {& do_compare, 2U}, 
        {& do_compare, 2U}, 
        {& do_compare, 2U}, 
        {& do_compare, 2U}, 
        {& do_compare, 2U}, 
        {& do_compare, 2U}};
#line 354 "/home/wheatley/newnew/temp/mixal-1.08/run.c"
void run(void) 
{ 
  int tmp ;
  Byte I ;
  Cell temp_ ;
  Address tmp___0 ;
  Cell sign_ ;

  {
  {
#line 356
  install_error_handler(& stop);
#line 357
  tmp = _setjmp((struct __jmp_buf_tag *)(escape_k));
  }
#line 357
  if (tmp != 0) {
#line 358
    return;
  }
  {
#line 359
  while (1) {
    while_continue: /* CIL Label */ ;
#line 361
    if (4000U <= pc) {
      {
#line 362
      error("Program counter out of range: %4o", pc);
      }
    }
    {
#line 365
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 365
      tmp___0 = pc;
#line 365
      pc ++;
#line 365
      temp_ = memory[tmp___0];
#line 365
      sign_ = temp_ & (1L << 30);
#line 365
      C = (Byte )(temp_ & 63L);
#line 365
      temp_ >>= 6;
#line 365
      F = (Byte )(temp_ & 63L);
#line 365
      temp_ >>= 6;
#line 365
      I = (Byte )(temp_ & 63L);
#line 365
      M = sign_ | (4095L & (temp_ >> 6));
#line 365
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 366
    if (6U < I) {
      {
#line 367
      error("Invalid I-field: %u", I);
      }
    }
#line 368
    if (I != 0U) {
      {
#line 369
      M = add(M, r[I]);
      }
    }
    {
#line 370
    (*(op_table[C].action))();
#line 371
    elapsed_time += (unsigned long )op_table[C].clocks;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 5 "/home/wheatley/newnew/temp/mixal-1.08/charset.h"
char mix_to_C_char(Byte mix_char ) ;
#line 124 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 236 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 9 "/home/wheatley/newnew/temp/mixal-1.08/charset.c"
static char const   mix_chars[65]  = 
#line 9 "/home/wheatley/newnew/temp/mixal-1.08/charset.c"
  {      (char const   )' ',      (char const   )'a',      (char const   )'b',      (char const   )'c', 
        (char const   )'d',      (char const   )'e',      (char const   )'f',      (char const   )'g', 
        (char const   )'h',      (char const   )'i',      (char const   )'^',      (char const   )'j', 
        (char const   )'k',      (char const   )'l',      (char const   )'m',      (char const   )'n', 
        (char const   )'o',      (char const   )'p',      (char const   )'q',      (char const   )'r', 
        (char const   )'^',      (char const   )'^',      (char const   )'s',      (char const   )'t', 
        (char const   )'u',      (char const   )'v',      (char const   )'w',      (char const   )'x', 
        (char const   )'y',      (char const   )'z',      (char const   )'0',      (char const   )'1', 
        (char const   )'2',      (char const   )'3',      (char const   )'4',      (char const   )'5', 
        (char const   )'6',      (char const   )'7',      (char const   )'8',      (char const   )'9', 
        (char const   )'.',      (char const   )',',      (char const   )'(',      (char const   )')', 
        (char const   )'+',      (char const   )'-',      (char const   )'*',      (char const   )'/', 
        (char const   )'=',      (char const   )'$',      (char const   )'<',      (char const   )'>', 
        (char const   )'@',      (char const   )';',      (char const   )':',      (char const   )'\'', 
        (char const   )'?',      (char const   )'?',      (char const   )'?',      (char const   )'?', 
        (char const   )'?',      (char const   )'?',      (char const   )'?',      (char const   )'\000'};
#line 12 "/home/wheatley/newnew/temp/mixal-1.08/charset.c"
char mix_to_C_char(Byte mix_char ) 
{ 


  {
#line 14
  if (! ((unsigned long )mix_char < sizeof(mix_chars))) {
    {
#line 14
    __assert_fail("(unsigned)mix_char < sizeof mix_chars", "/home/wheatley/newnew/temp/mixal-1.08/charset.c",
                  14U, "mix_to_C_char");
    }
  }
#line 15
  return ((char )mix_chars[mix_char]);
}
}
#line 18 "/home/wheatley/newnew/temp/mixal-1.08/charset.c"
Byte C_char_to_mix(char c ) 
{ 
  char const   *s ;
  int tmp ;
  char *tmp___0 ;

  {
  {
#line 20
  tmp = tolower((int )c);
#line 20
  tmp___0 = strchr(mix_chars, tmp);
#line 20
  s = (char const   *)tmp___0;
  }
#line 21
  if (! s) {
#line 21
    return ((Byte )63);
  }
#line 22
  return ((Byte )(s - mix_chars));
}
}
#line 21 "/home/wheatley/newnew/temp/mixal-1.08/mix.h"
void fatal_error(char const   *message  , ...) ;
#line 9 "/home/wheatley/newnew/temp/mixal-1.08/asm.h"
Address here ;
#line 12
void asm_store_field(Address address , unsigned int L , unsigned int R , Cell cell ) ;
#line 17
void assemble(Cell cell ) ;
#line 32 "/home/wheatley/newnew/temp/mixal-1.08/symbol.h"
Symbol string_to_symbol(char const   *name ) ;
#line 34
Flag is_defined(Symbol symbol ) ;
#line 37
Cell symbol_value(Symbol symbol ) ;
#line 41
void forward_reference(Symbol symbol , Address address ) ;
#line 46
void define_symbol(Symbol symbol , Cell cell ) ;
#line 51
Symbol generate_future_sym(Cell value ) ;
#line 53
void resolve_generated_futures(void) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 150 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 48 "/home/wheatley/newnew/temp/mixal-1.08/symbol.c"
static void *allot(size_t size ) 
{ 
  void *result ;
  void *tmp ;

  {
  {
#line 50
  tmp = malloc(size);
#line 50
  result = tmp;
  }
#line 51
  if (! result) {
    {
#line 52
    fatal_error("Out of heap space");
    }
  }
#line 53
  return (result);
}
}
#line 56 "/home/wheatley/newnew/temp/mixal-1.08/symbol.c"
static int stricmp(char const   *s , char const   *t ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 58
  while (1) {
    while_continue: /* CIL Label */ ;
#line 58
    if (*s) {
#line 58
      if (! *t) {
#line 58
        goto while_break;
      }
    } else {
#line 58
      goto while_break;
    }
    {
#line 59
    tmp = tolower((int )*s);
#line 59
    tmp___0 = tolower((int )*t);
    }
#line 59
    if (tmp != tmp___0) {
#line 60
      return (1);
    } else {
#line 62
      s ++;
#line 62
      t ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 63
  tmp___1 = tolower((int )*s);
#line 63
  tmp___2 = tolower((int )*t);
  }
#line 63
  return (tmp___1 != tmp___2);
}
}
#line 68 "/home/wheatley/newnew/temp/mixal-1.08/symbol.c"
static Symbol symbol_table[17]  ;
#line 71 "/home/wheatley/newnew/temp/mixal-1.08/symbol.c"
static void for_each_symbol(void (*proc)(Symbol  ) ) 
{ 
  unsigned int i ;
  Symbol s ;

  {
#line 74
  i = 0U;
  {
#line 74
  while (1) {
    while_continue: /* CIL Label */ ;
#line 74
    if (! ((unsigned long )i < sizeof(symbol_table) / sizeof(symbol_table[0]))) {
#line 74
      goto while_break;
    }
#line 75
    s = symbol_table[i];
    {
#line 76
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 76
      if (! s) {
#line 76
        goto while_break___0;
      }
      {
#line 77
      (*proc)(s);
#line 76
      s = s->next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 74
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 79
  return;
}
}
#line 81 "/home/wheatley/newnew/temp/mixal-1.08/symbol.c"
static unsigned int hash(char const   *s ) 
{ 
  unsigned int h ;
  int tmp ;

  {
#line 83
  h = 0U;
  {
#line 84
  while (1) {
    while_continue: /* CIL Label */ ;
#line 84
    if (! *s) {
#line 84
      goto while_break;
    }
    {
#line 85
    tmp = toupper((int )*s);
#line 85
    h = ((h << 5) - h) + (unsigned int )tmp;
#line 84
    s ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 86
  return ((unsigned int )((unsigned long )h % (sizeof(symbol_table) / sizeof(symbol_table[0]))));
}
}
#line 89 "/home/wheatley/newnew/temp/mixal-1.08/symbol.c"
Symbol string_to_symbol(char const   *name ) 
{ 
  Symbol *bucket ;
  unsigned int tmp ;
  Symbol p ;
  int tmp___0 ;
  Symbol result ;
  void *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;

  {
  {
#line 91
  tmp = hash(name);
#line 91
  bucket = symbol_table + tmp;
#line 92
  p = *bucket;
  }
  {
#line 93
  while (1) {
    while_continue: /* CIL Label */ ;
#line 93
    if (! p) {
#line 93
      goto while_break;
    }
    {
#line 94
    tmp___0 = stricmp(name, (char const   *)p->name);
    }
#line 94
    if (tmp___0 == 0) {
#line 95
      return (p);
    }
#line 93
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 97
  tmp___1 = allot(sizeof(struct Symbol ));
#line 97
  result = (Symbol )tmp___1;
#line 98
  tmp___3 = strlen(name);
#line 98
  tmp___4 = allot(tmp___3 + 1UL);
#line 98
  tmp___2 = (char *)tmp___4;
#line 98
  result->name = tmp___2;
#line 98
  strcpy((char */* __restrict  */)tmp___2, (char const   */* __restrict  */)name);
#line 99
  result->defined = (Flag )0;
#line 100
  result->references = (AddressList )((void *)0);
#line 101
  result->next = *bucket;
#line 102
  result->cell = (Cell )0;
#line 103
  *bucket = result;
  }
#line 104
  return (result);
}
}
#line 108 "/home/wheatley/newnew/temp/mixal-1.08/symbol.c"
Flag is_defined(Symbol symbol ) 
{ 


  {
#line 108
  return (symbol->defined);
}
}
#line 110 "/home/wheatley/newnew/temp/mixal-1.08/symbol.c"
Cell symbol_value(Symbol symbol ) 
{ 


  {
#line 112
  if (! symbol->defined) {
    {
#line 112
    __assert_fail("symbol->defined", "/home/wheatley/newnew/temp/mixal-1.08/symbol.c",
                  112U, "symbol_value");
    }
  }
#line 113
  return (symbol->cell);
}
}
#line 116 "/home/wheatley/newnew/temp/mixal-1.08/symbol.c"
void forward_reference(Symbol symbol , Address address ) 
{ 
  AddressList refs ;
  void *tmp ;

  {
#line 118
  if (! (! symbol->defined)) {
    {
#line 118
    __assert_fail("!symbol->defined", "/home/wheatley/newnew/temp/mixal-1.08/symbol.c",
                  118U, "forward_reference");
    }
  }
  {
#line 120
  tmp = allot(sizeof(struct AddressList ));
#line 120
  refs = (AddressList )tmp;
#line 121
  refs->address = address;
#line 122
  refs->next = symbol->references;
#line 123
  symbol->references = refs;
  }
#line 125
  return;
}
}
#line 130 "/home/wheatley/newnew/temp/mixal-1.08/symbol.c"
static void resolve_references(Symbol symbol , Cell definition ) 
{ 
  AddressList refs ;
  AddressList rest ;

  {
#line 133
  if (! (! symbol->defined)) {
    {
#line 133
    __assert_fail("!symbol->defined", "/home/wheatley/newnew/temp/mixal-1.08/symbol.c",
                  133U, "resolve_references");
    }
  }
#line 134
  refs = symbol->references;
  {
#line 134
  while (1) {
    while_continue: /* CIL Label */ ;
#line 134
    if (! refs) {
#line 134
      goto while_break;
    }
    {
#line 135
    asm_store_field(refs->address, 0U, 2U, definition);
#line 136
    rest = refs->next;
#line 137
    free((void *)refs);
#line 134
    refs = rest;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 139
  return;
}
}
#line 141 "/home/wheatley/newnew/temp/mixal-1.08/symbol.c"
void define_symbol(Symbol symbol , Cell cell ) 
{ 
  char const   *name ;
  char c ;
  int tmp ;
  char new_name[3] ;
  Symbol nB ;
  Symbol nF ;
  unsigned short const   **tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 144
  name = (char const   *)symbol->name;
#line 145
  tmp___0 = __ctype_b_loc();
  }
#line 145
  if ((int const   )*(*tmp___0 + (int )*(name + 0)) & 2048) {
    {
#line 145
    tmp___1 = strlen(name);
    }
#line 145
    if (tmp___1 == 2UL) {
      {
#line 146
      tmp = toupper((int )*(name + 1));
#line 146
      c = (char )tmp;
      }
#line 147
      if ((int )c == 70) {
        {
#line 148
        error("Definition of local ref: %s", name);
        }
#line 149
        return;
      } else
#line 147
      if ((int )c == 66) {
        {
#line 148
        error("Definition of local ref: %s", name);
        }
#line 149
        return;
      } else
#line 150
      if ((int )c == 72) {
        {
#line 153
        strcpy((char */* __restrict  */)(new_name), (char const   */* __restrict  */)name);
#line 154
        new_name[1] = (char )'B';
#line 154
        nB = string_to_symbol((char const   *)(new_name));
#line 155
        nB->defined = (Flag )1;
#line 155
        nB->cell = cell;
#line 156
        new_name[1] = (char )'F';
#line 156
        nF = string_to_symbol((char const   *)(new_name));
#line 157
        resolve_references(nF, cell);
#line 158
        nF->defined = (Flag )0;
#line 158
        nF->references = (AddressList )((void *)0);
        }
#line 159
        return;
      }
    }
  }
#line 164
  if (symbol->defined) {
    {
#line 165
    warn("\'%s\' multiply-defined", symbol->name);
    }
  } else {
    {
#line 167
    resolve_references(symbol, cell);
    }
  }
#line 168
  symbol->defined = (Flag )1;
#line 168
  symbol->cell = cell;
#line 169
  return;
}
}
#line 171 "/home/wheatley/newnew/temp/mixal-1.08/symbol.c"
Symbol generate_future_sym(Cell value ) 
{ 
  char name[12] ;
  Symbol tmp ;

  {
  {
#line 174
  sprintf((char */* __restrict  */)(name), (char const   */* __restrict  */)"=%ld",
          value);
#line 175
  tmp = string_to_symbol((char const   *)(name));
  }
#line 175
  return (tmp);
}
}
#line 178 "/home/wheatley/newnew/temp/mixal-1.08/symbol.c"
static void resolve_if_dangling(Symbol symbol ) 
{ 
  Cell tmp ;
  long tmp___0 ;

  {
#line 180
  if (symbol->defined) {
#line 181
    return;
  }
#line 182
  if ((int )*(symbol->name + 0) == 61) {
    {
#line 183
    tmp = address_to_cell(here);
#line 183
    define_symbol(symbol, tmp);
#line 184
    tmp___0 = atol((char const   *)(symbol->name + 1));
#line 184
    assemble(tmp___0);
    }
  } else
#line 186
  if (symbol->references) {
    {
#line 187
    error("Unresolved reference: %s", symbol->name);
    }
  }
#line 190
  return;
}
}
#line 192 "/home/wheatley/newnew/temp/mixal-1.08/symbol.c"
void resolve_generated_futures(void) 
{ 


  {
  {
#line 194
  for_each_symbol(& resolve_if_dangling);
  }
#line 195
  return;
}
}
#line 9 "/home/wheatley/newnew/temp/mixal-1.08/parse.h"
void setup_scanner(char const   *s ) ;
#line 13
Cell parse_operand(Flag F_must_be_default___0 , Byte default_F___0 ) ;
#line 14
Cell parse_W(void) ;
#line 16
void done_parsing(void) ;
#line 187 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 289
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strspn)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 15 "/home/wheatley/newnew/temp/mixal-1.08/parse.c"
static char const   *the_string  ;
#line 15 "/home/wheatley/newnew/temp/mixal-1.08/parse.c"
static char const   *token_start  ;
#line 25 "/home/wheatley/newnew/temp/mixal-1.08/parse.c"
static char token  ;
#line 26 "/home/wheatley/newnew/temp/mixal-1.08/parse.c"
static Cell token_value  ;
#line 27 "/home/wheatley/newnew/temp/mixal-1.08/parse.c"
static Symbol token_symbol  ;
#line 30 "/home/wheatley/newnew/temp/mixal-1.08/parse.c"
static void advance(void) 
{ 
  char token_text[33] ;
  size_t length ;
  char const   *start ;
  unsigned short const   **tmp ;
  unsigned long tmp___0 ;
  Flag tmp___2 ;
  size_t tmp___3 ;
  char const   *end ;
  char *tmp___4 ;
  size_t tmp___5 ;
  unsigned int length___0 ;
  unsigned int i ;
  Byte tmp___6 ;
  char const   *tmp___7 ;
  unsigned short const   **tmp___8 ;
  unsigned short const   **tmp___9 ;

  {
  {
#line 33
  tmp___9 = __ctype_b_loc();
  }
#line 33
  if ((int const   )*(*tmp___9 + (int )*(the_string + 0)) & 8192) {
#line 34
    token = (char )'z';
  } else
#line 33
  if ((int const   )*(the_string + 0) == 0) {
#line 34
    token = (char )'z';
  } else {
    {
#line 35
    tmp___8 = __ctype_b_loc();
    }
#line 35
    if ((int const   )*(*tmp___8 + (int )*(the_string + 0)) & 8) {
#line 37
      start = the_string;
      {
#line 38
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 39
        the_string ++;
#line 38
        tmp = __ctype_b_loc();
        }
#line 38
        if (! ((int const   )*(*tmp + (int )*(the_string + 0)) & 8)) {
#line 38
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 41
      length = (size_t )(the_string - start);
#line 42
      if (sizeof(token_text) - 1UL < length) {
        {
#line 43
        warn("Atom truncated: %*.*s", length, length, start);
#line 44
        length = sizeof(token_text) - 1UL;
        }
      }
      {
#line 46
      memcpy((void */* __restrict  */)(token_text), (void const   */* __restrict  */)start,
             length);
#line 47
      token_text[length] = (char )'\000';
#line 48
      tmp___3 = strspn((char const   *)(token_text), "0123456789");
      }
#line 48
      if (tmp___3 == length) {
        {
#line 49
        token = (char )'0';
#line 50
        tmp___0 = strtoul((char const   */* __restrict  */)(token_text), (char **/* __restrict  */)((void *)0),
                          10);
#line 50
        token_value = ulong_to_cell(tmp___0);
        }
      } else {
        {
#line 52
        token_symbol = string_to_symbol((char const   *)(token_text));
#line 53
        tmp___2 = is_defined(token_symbol);
        }
#line 53
        if (tmp___2) {
#line 53
          token = (char )'d';
        } else {
#line 53
          token = (char )'f';
        }
      }
    } else
#line 55
    if ((int const   )*(the_string + 0) == 47) {
#line 55
      if ((int const   )*(the_string + 1) == 47) {
#line 56
        the_string += 2;
#line 57
        token = (char )'%';
      } else {
#line 55
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 58
    if ((int const   )*(the_string + 0) == 34) {
      {
#line 59
      token = (char )'0';
#line 60
      token_value = (Cell )0;
#line 61
      the_string ++;
#line 63
      tmp___4 = strchr(the_string, '\"');
#line 63
      end = (char const   *)tmp___4;
      }
#line 64
      if (! end) {
        {
#line 65
        error("Missing \'\"\'");
#line 66
        tmp___5 = strlen(the_string);
#line 66
        the_string += tmp___5;
        }
      } else {
#line 68
        length___0 = (unsigned int )(end - the_string);
#line 69
        if (5U < length___0) {
          {
#line 70
          warn("String doesn\'t fit in a machine word");
#line 71
          length___0 = 5U;
          }
        }
#line 75
        i = 0U;
        {
#line 75
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 75
          if (! (i < length___0)) {
#line 75
            goto while_break___0;
          }
          {
#line 76
          tmp___6 = C_char_to_mix((char )*(the_string + i));
#line 76
          token_value = set_byte(tmp___6, i + 1U, token_value);
#line 75
          i ++;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 80
      the_string = end + 1;
    } else {
#line 83
      tmp___7 = the_string;
#line 83
      the_string ++;
#line 83
      token = (char )*tmp___7;
    }
  }
#line 84
  return;
}
}
#line 86 "/home/wheatley/newnew/temp/mixal-1.08/parse.c"
static void expect(char expected_token ) 
{ 


  {
#line 88
  if ((int )token != (int )expected_token) {
    {
#line 89
    error("Expected \'%c\', not \'%*.*s\'", (int )expected_token, the_string - token_start,
          the_string - token_start, token_start);
    }
  }
  {
#line 92
  advance();
  }
#line 93
  return;
}
}
#line 95 "/home/wheatley/newnew/temp/mixal-1.08/parse.c"
void setup_scanner(char const   *s ) 
{ 


  {
  {
#line 97
  the_string = s;
#line 98
  advance();
  }
#line 99
  return;
}
}
#line 104 "/home/wheatley/newnew/temp/mixal-1.08/parse.c"
static Flag is_future(void) 
{ 
  int tmp ;

  {
#line 106
  if ((int )token == 102) {
#line 106
    tmp = 1;
  } else
#line 106
  if ((int )token == 61) {
#line 106
    tmp = 1;
  } else {
#line 106
    tmp = 0;
  }
#line 106
  return ((Flag )tmp);
}
}
#line 109 "/home/wheatley/newnew/temp/mixal-1.08/parse.c"
static Cell parse_future(void) 
{ 
  Symbol symbol ;
  Cell value ;

  {
#line 112
  if ((int )token == 102) {
    {
#line 113
    symbol = token_symbol;
#line 114
    advance();
    }
  } else {
    {
#line 117
    expect((char )'=');
#line 118
    value = parse_W();
#line 119
    expect((char )'=');
#line 120
    symbol = generate_future_sym(value);
    }
  }
  {
#line 122
  forward_reference(symbol, here);
  }
#line 123
  return ((Cell )0);
}
}
#line 127 "/home/wheatley/newnew/temp/mixal-1.08/parse.c"
static Flag is_atomic(void) 
{ 
  int tmp ;

  {
#line 129
  if ((int )token == 42) {
#line 129
    tmp = 1;
  } else
#line 129
  if ((int )token == 48) {
#line 129
    tmp = 1;
  } else
#line 129
  if ((int )token == 100) {
#line 129
    tmp = 1;
  } else {
#line 129
    tmp = 0;
  }
#line 129
  return ((Flag )tmp);
}
}
#line 132 "/home/wheatley/newnew/temp/mixal-1.08/parse.c"
static Cell parse_atomic(void) 
{ 
  Cell result ;

  {
  {
#line 136
  if ((int )token == 42) {
#line 136
    goto case_42;
  }
#line 137
  if ((int )token == 48) {
#line 137
    goto case_48;
  }
#line 138
  if ((int )token == 100) {
#line 138
    goto case_100;
  }
#line 139
  goto switch_default;
  case_42: /* CIL Label */ 
  {
#line 136
  result = address_to_cell(here);
  }
#line 136
  goto switch_break;
  case_48: /* CIL Label */ 
#line 137
  result = token_value;
#line 137
  goto switch_break;
  case_100: /* CIL Label */ 
  {
#line 138
  result = symbol_value(token_symbol);
  }
#line 138
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 140
  error("Expected an atomic value");
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 142
  advance();
  }
#line 143
  return (result);
}
}
#line 147 "/home/wheatley/newnew/temp/mixal-1.08/parse.c"
static Flag is_expr(void) 
{ 
  Flag tmp ;
  int tmp___0 ;

  {
#line 149
  if ((int )token == 43) {
#line 149
    tmp___0 = 1;
  } else
#line 149
  if ((int )token == 45) {
#line 149
    tmp___0 = 1;
  } else {
    {
#line 149
    tmp = is_atomic();
    }
#line 149
    if (tmp) {
#line 149
      tmp___0 = 1;
    } else {
#line 149
      tmp___0 = 0;
    }
  }
#line 149
  return ((Flag )tmp___0);
}
}
#line 156 "/home/wheatley/newnew/temp/mixal-1.08/parse.c"
static Cell colon(Cell L , Cell R ) 
{ 
  Cell tmp ;
  Cell tmp___0 ;
  Cell tmp___1 ;

  {
  {
#line 158
  tmp = ulong_to_cell(8UL);
#line 158
  tmp___0 = mul(tmp, L);
#line 158
  tmp___1 = add(tmp___0, R);
  }
#line 158
  return (tmp___1);
}
}
#line 161 "/home/wheatley/newnew/temp/mixal-1.08/parse.c"
static Cell double_slash(Cell x , Cell y ) 
{ 
  Cell quotient ;
  Cell remainder ;

  {
  {
#line 164
  divide(x, (Cell )0, y, & quotient, & remainder);
  }
#line 165
  return (quotient);
}
}
#line 179
static Cell parse_expr(void) ;
#line 179 "/home/wheatley/newnew/temp/mixal-1.08/parse.c"
static char const   ops[7]  = {      (char const   )'+',      (char const   )'-',      (char const   )'*',      (char const   )'/', 
        (char const   )'%',      (char const   )':',      (char const   )'\000'};
#line 180 "/home/wheatley/newnew/temp/mixal-1.08/parse.c"
static BinOp * const  handlers[6]  = {      (BinOp */* const  */)(& add),      (BinOp */* const  */)(& sub),      (BinOp */* const  */)(& mul),      (BinOp */* const  */)(& slash), 
        (BinOp */* const  */)(& double_slash),      (BinOp */* const  */)(& colon)};
#line 169 "/home/wheatley/newnew/temp/mixal-1.08/parse.c"
static Cell parse_expr(void) 
{ 
  Cell sign ;
  Cell tmp ;
  Cell cell ;
  Cell tmp___0 ;
  Cell tmp___1 ;
  char const   *s ;
  char *tmp___2 ;
  Cell tmp___3 ;

  {
  {
#line 171
  tmp = ulong_to_cell(1UL);
#line 171
  sign = tmp;
  }
#line 172
  if ((int )token == 43) {
#line 172
    goto _L;
  } else
#line 172
  if ((int )token == 45) {
    _L: /* CIL Label */ 
#line 173
    if ((int )token == 45) {
#line 174
      sign ^= 1L << 30;
    }
    {
#line 175
    advance();
    }
  }
  {
#line 177
  overflow = (Flag )0;
#line 182
  tmp___0 = parse_atomic();
#line 182
  tmp___1 = mul(sign, tmp___0);
#line 182
  cell = tmp___1;
  }
  {
#line 183
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 184
    tmp___2 = strchr(ops, (int )token);
#line 184
    s = (char const   *)tmp___2;
    }
#line 185
    if (s) {
      {
#line 186
      advance();
#line 187
      tmp___3 = parse_atomic();
#line 187
      cell = (*(handlers[s - ops]))(cell, tmp___3);
      }
    } else {
#line 189
      if (overflow) {
        {
#line 190
        warn("Overflow in evaluation of expression");
        }
      }
#line 191
      return (cell);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 198 "/home/wheatley/newnew/temp/mixal-1.08/parse.c"
static Cell parse_A(void) 
{ 
  Cell tmp ;
  Cell tmp___0 ;
  Flag tmp___1 ;
  Flag tmp___2 ;

  {
  {
#line 200
  tmp___2 = is_future();
  }
#line 200
  if (tmp___2) {
    {
#line 201
    tmp = parse_future();
    }
#line 201
    return (tmp);
  } else {
    {
#line 202
    tmp___1 = is_expr();
    }
#line 202
    if (tmp___1) {
      {
#line 203
      tmp___0 = parse_expr();
      }
#line 203
      return (tmp___0);
    } else {
#line 205
      return ((Cell )0);
    }
  }
}
}
#line 209 "/home/wheatley/newnew/temp/mixal-1.08/parse.c"
static Cell parse_F(Cell default_F___0 ) 
{ 
  Cell result ;

  {
#line 211
  if ((int )token == 40) {
    {
#line 213
    advance();
#line 214
    result = parse_expr();
#line 215
    expect((char )')');
    }
#line 216
    return (result);
  } else {
#line 218
    return (default_F___0);
  }
}
}
#line 222 "/home/wheatley/newnew/temp/mixal-1.08/parse.c"
static Cell parse_I(void) 
{ 
  Cell tmp ;

  {
#line 224
  if ((int )token == 44) {
    {
#line 225
    advance();
#line 226
    tmp = parse_expr();
    }
#line 226
    return (tmp);
  } else {
#line 228
    return ((Cell )0);
  }
}
}
#line 232 "/home/wheatley/newnew/temp/mixal-1.08/parse.c"
Cell parse_operand(Flag F_must_be_default___0 , Byte default_F___0 ) 
{ 
  Cell A ;
  Cell tmp ;
  Cell I ;
  Cell tmp___0 ;
  Cell F___0 ;
  Cell tmp___1 ;
  Byte tmp___2 ;
  Cell tmp___3 ;
  Byte tmp___4 ;
  Cell tmp___5 ;
  Byte tmp___6 ;
  Cell tmp___7 ;

  {
  {
#line 234
  tmp = parse_A();
#line 234
  A = tmp;
#line 235
  tmp___0 = parse_I();
#line 235
  I = tmp___0;
#line 236
  tmp___1 = parse_F((Cell )default_F___0);
#line 236
  F___0 = tmp___1;
  }
#line 237
  if (F_must_be_default___0) {
#line 237
    if (F___0 != (Cell )default_F___0) {
      {
#line 238
      error("Illegal operand to extended-opcode instruction");
      }
    }
  }
  {
#line 239
  tmp___2 = make_field_spec(4U, 4U);
#line 239
  tmp___3 = set_field(F___0, tmp___2, (Cell )0);
#line 239
  tmp___4 = make_field_spec(3U, 3U);
#line 239
  tmp___5 = set_field(I, tmp___4, tmp___3);
#line 239
  tmp___6 = make_field_spec(0U, 2U);
#line 239
  tmp___7 = set_field(A, tmp___6, tmp___5);
  }
#line 239
  return (tmp___7);
}
}
#line 245 "/home/wheatley/newnew/temp/mixal-1.08/parse.c"
Cell parse_W(void) 
{ 
  Cell result ;
  Cell expr ;
  Cell tmp ;
  Cell F___0 ;
  Cell tmp___0 ;

  {
#line 247
  result = (Cell )0;
  {
#line 248
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 249
    tmp = parse_expr();
#line 249
    expr = tmp;
#line 250
    tmp___0 = parse_F((Cell )5);
#line 250
    F___0 = tmp___0;
#line 251
    assert_valid_field(F___0);
#line 252
    result = set_field(expr, (Byte )F___0, result);
    }
#line 253
    if ((int )token != 44) {
#line 254
      goto while_break;
    }
    {
#line 255
    advance();
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 257
  return (result);
}
}
#line 260 "/home/wheatley/newnew/temp/mixal-1.08/parse.c"
void done_parsing(void) 
{ 


  {
#line 262
  if ((int )token != 122) {
    {
#line 263
    error("Bad syntax in operand field");
    }
  }
#line 264
  return;
}
}
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 531
extern int fgetc(FILE *__stream ) ;
#line 573
extern int fputc(int __c , FILE *__stream ) ;
#line 749
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 413 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 25 "/home/wheatley/newnew/temp/mixal-1.08/io.c"
static struct __anonstruct_devices_7 devices[20]  = 
#line 25 "/home/wheatley/newnew/temp/mixal-1.08/io.c"
  {      {(enum DeviceType  const  )0, (FILE *)0, 0L}, 
        {(enum DeviceType  const  )0, (FILE *)0, 0L}, 
        {(enum DeviceType  const  )0, (FILE *)0, 0L}, 
        {(enum DeviceType  const  )0, (FILE *)0, 0L}, 
        {(enum DeviceType  const  )0, (FILE *)0, 0L}, 
        {(enum DeviceType  const  )0, (FILE *)0, 0L}, 
        {(enum DeviceType  const  )0, (FILE *)0, 0L}, 
        {(enum DeviceType  const  )0, (FILE *)0, 0L}, 
        {(enum DeviceType  const  )1, (FILE *)0, 0L}, 
        {(enum DeviceType  const  )1, (FILE *)0, 0L}, 
        {(enum DeviceType  const  )1, (FILE *)0, 0L}, 
        {(enum DeviceType  const  )1, (FILE *)0, 0L}, 
        {(enum DeviceType  const  )1, (FILE *)0, 0L}, 
        {(enum DeviceType  const  )1, (FILE *)0, 0L}, 
        {(enum DeviceType  const  )1, (FILE *)0, 0L}, 
        {(enum DeviceType  const  )1, (FILE *)0, 0L}, 
        {(enum DeviceType  const  )2, (FILE *)0, 0L}, 
        {(enum DeviceType  const  )3, (FILE *)0, 0L}, 
        {(enum DeviceType  const  )4, (FILE *)0, 0L}, 
        {(enum DeviceType  const  )5, (FILE *)0, 0L}};
#line 47
static void tape_in(unsigned int device , Cell argument , Address buffer ) ;
#line 47
static void disk_in(unsigned int device , Cell argument , Address buffer ) ;
#line 47
static void text_in(unsigned int device , Cell argument , Address buffer ) ;
#line 47
static void console_in(unsigned int device , Cell argument , Address buffer ) ;
#line 47
static void no_in(unsigned int device , Cell argument , Address buffer ) ;
#line 48
static void tape_out(unsigned int device , Cell argument , Address buffer ) ;
#line 48
static void disk_out(unsigned int device , Cell argument , Address buffer ) ;
#line 48
static void text_out(unsigned int device , Cell argument , Address buffer ) ;
#line 48
static void console_out(unsigned int device , Cell argument , Address buffer ) ;
#line 48
static void no_out(unsigned int device , Cell argument , Address buffer ) ;
#line 49
static void tape_ioc(unsigned int device , Cell offset ) ;
#line 49
static void disk_ioc(unsigned int device , Cell offset ) ;
#line 49
static void no_ioc(unsigned int device , Cell argument ) ;
#line 49
static void printer_ioc(unsigned int device , Cell argument ) ;
#line 53 "/home/wheatley/newnew/temp/mixal-1.08/io.c"
static struct Device_attributes  const  methods[6]  = {      {"tape", 100U, & tape_in, & tape_out, & tape_ioc}, 
        {"disk", 100U, & disk_in, & disk_out, & disk_ioc}, 
        {(char const   *)((void *)0), 16U, & text_in, & no_out, & no_ioc}, 
        {(char const   *)((void *)0), 16U, & no_in, & text_out, & no_ioc}, 
        {(char const   *)((void *)0), 24U, & no_in, & text_out, & printer_ioc}, 
        {(char const   *)((void *)0), 14U, & console_in, & console_out, & no_ioc}};
#line 70 "/home/wheatley/newnew/temp/mixal-1.08/io.c"
static struct Device_attributes  const  *attributes(unsigned int device ) 
{ 


  {
#line 72
  return (& methods[devices[device].type]);
}
}
#line 75 "/home/wheatley/newnew/temp/mixal-1.08/io.c"
static unsigned int block_size(unsigned int device ) 
{ 
  struct Device_attributes  const  *tmp ;

  {
  {
#line 77
  tmp = attributes(device);
  }
#line 77
  return ((unsigned int )tmp->block_size);
}
}
#line 80 "/home/wheatley/newnew/temp/mixal-1.08/io.c"
static FILE *assigned_file(unsigned int device ) 
{ 


  {
  {
#line 84
  if ((unsigned int const   )devices[device].type == 2U) {
#line 84
    goto case_2;
  }
#line 86
  if ((unsigned int const   )devices[device].type == 4U) {
#line 86
    goto case_4;
  }
#line 86
  if ((unsigned int const   )devices[device].type == 3U) {
#line 86
    goto case_4;
  }
#line 88
  goto switch_default;
  case_2: /* CIL Label */ 
#line 85
  return (stdin);
#line 85
  goto switch_break;
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 87
  return (stdout);
#line 87
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 89
  return (devices[device].file);
  switch_break: /* CIL Label */ ;
  }
#line 91
  return ((FILE *)0);
}
}
#line 95 "/home/wheatley/newnew/temp/mixal-1.08/io.c"
static char filename[4096]  ;
#line 93 "/home/wheatley/newnew/temp/mixal-1.08/io.c"
static char *device_filename(Byte device ) 
{ 
  struct Device_attributes  const  *tmp ;

  {
  {
#line 96
  tmp = attributes(device);
#line 96
  sprintf((char */* __restrict  */)(filename), (char const   */* __restrict  */)"%s%02d",
          tmp->base_filename, device);
  }
#line 98
  return (filename);
}
}
#line 101 "/home/wheatley/newnew/temp/mixal-1.08/io.c"
static void ensure_open(Byte device ) 
{ 
  char const   *filename___0 ;
  char *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  FILE *tmp___2 ;
  FILE *tmp___3 ;
  struct Device_attributes  const  *tmp___4 ;
  FILE *tmp___5 ;

  {
#line 103
  if (sizeof(devices) / sizeof(devices[0]) <= (unsigned long )device) {
    {
#line 104
    error("Unknown device - %02o", device);
    }
  }
  {
#line 105
  tmp___5 = assigned_file(device);
  }
#line 105
  if (! tmp___5) {
    {
#line 106
    tmp___4 = attributes(device);
    }
#line 106
    if (tmp___4->base_filename) {
      {
#line 107
      tmp = device_filename(device);
#line 107
      filename___0 = (char const   *)tmp;
#line 108
      tmp___2 = fopen((char const   */* __restrict  */)filename___0, (char const   */* __restrict  */)"r+b");
#line 108
      devices[device].file = tmp___2;
      }
#line 108
      if (! tmp___2) {
        {
#line 108
        tmp___3 = fopen((char const   */* __restrict  */)filename___0, (char const   */* __restrict  */)"w+b");
#line 108
        devices[device].file = tmp___3;
        }
#line 108
        if (! tmp___3) {
          {
#line 110
          tmp___0 = __errno_location();
#line 110
          tmp___1 = strerror(*tmp___0);
#line 110
          error("%s: %s", filename___0, tmp___1);
          }
        }
      }
#line 111
      devices[device].position = 0L;
    } else {
      {
#line 113
      error("No file assigned to device %02o", device);
      }
    }
  }
#line 115
  return;
}
}
#line 117 "/home/wheatley/newnew/temp/mixal-1.08/io.c"
void io_control(Byte device , Cell argument ) 
{ 
  struct Device_attributes  const  *tmp ;

  {
  {
#line 119
  ensure_open(device);
#line 120
  tmp = attributes(device);
#line 120
  (*(tmp->ioc_handler))(device, argument);
  }
#line 121
  return;
}
}
#line 123 "/home/wheatley/newnew/temp/mixal-1.08/io.c"
void do_input(Byte device , Cell argument , Address buffer ) 
{ 
  struct Device_attributes  const  *tmp ;

  {
  {
#line 125
  ensure_open(device);
#line 126
  tmp = attributes(device);
#line 126
  (*(tmp->in_handler))(device, argument, buffer);
  }
#line 127
  return;
}
}
#line 129 "/home/wheatley/newnew/temp/mixal-1.08/io.c"
void do_output(Byte device , Cell argument , Address buffer ) 
{ 
  struct Device_attributes  const  *tmp ;

  {
  {
#line 131
  ensure_open(device);
#line 132
  tmp = attributes(device);
#line 132
  (*(tmp->out_handler))(device, argument, buffer);
  }
#line 133
  return;
}
}
#line 137 "/home/wheatley/newnew/temp/mixal-1.08/io.c"
static void no_ioc(unsigned int device , Cell argument ) 
{ 


  {
  {
#line 139
  error("IOC undefined for device %02o", device);
  }
#line 140
  return;
}
}
#line 142 "/home/wheatley/newnew/temp/mixal-1.08/io.c"
static void no_in(unsigned int device , Cell argument , Address buffer ) 
{ 


  {
  {
#line 144
  error("Input not allowed for device %02o", device);
  }
#line 145
  return;
}
}
#line 147 "/home/wheatley/newnew/temp/mixal-1.08/io.c"
static void no_out(unsigned int device , Cell argument , Address buffer ) 
{ 


  {
  {
#line 149
  error("Output not allowed for device %02o", device);
  }
#line 150
  return;
}
}
#line 159 "/home/wheatley/newnew/temp/mixal-1.08/io.c"
static void read_line(FILE *file , Address buffer , unsigned int size ) 
{ 
  unsigned int i ;
  unsigned int b ;
  Flag past_end ;
  Cell cell ;
  Byte mix_char ;
  int c ;
  int tmp ;

  {
#line 162
  past_end = (Flag )0;
#line 163
  i = 0U;
  {
#line 163
  while (1) {
    while_continue: /* CIL Label */ ;
#line 163
    if (! (i < size)) {
#line 163
      goto while_break;
    }
#line 164
    cell = (Cell )0;
#line 165
    if (4000U <= buffer + i) {
      {
#line 167
      error("Address out of range");
      }
    }
#line 168
    b = 1U;
    {
#line 168
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 168
      if (! (b <= 5U)) {
#line 168
        goto while_break___0;
      }
#line 170
      if (past_end) {
#line 171
        mix_char = (Byte )0;
      } else {
        {
#line 173
        tmp = fgetc(file);
#line 173
        c = tmp;
        }
#line 174
        if (c == 10) {
#line 175
          past_end = (Flag )1;
#line 175
          mix_char = (Byte )0;
        } else
#line 174
        if (c == -1) {
#line 175
          past_end = (Flag )1;
#line 175
          mix_char = (Byte )0;
        } else {
          {
#line 177
          mix_char = C_char_to_mix((char )c);
          }
        }
      }
      {
#line 179
      cell = set_byte(mix_char, b, cell);
#line 168
      b ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 181
    memory[buffer + i] = cell;
#line 163
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 183
  return;
}
}
#line 185 "/home/wheatley/newnew/temp/mixal-1.08/io.c"
static void write_cell(Cell cell , FILE *outfile , Flag text ) 
{ 
  unsigned int i ;
  int tmp ;
  Byte tmp___0 ;
  char tmp___1 ;

  {
#line 188
  if (! text) {
#line 189
    if ((cell & (1L << 30)) != 0L) {
#line 189
      tmp = '-';
    } else {
#line 189
      tmp = ' ';
    }
    {
#line 189
    fputc(tmp, outfile);
    }
  }
#line 190
  i = 1U;
  {
#line 190
  while (1) {
    while_continue: /* CIL Label */ ;
#line 190
    if (! (i <= 5U)) {
#line 190
      goto while_break;
    }
    {
#line 191
    tmp___0 = get_byte(i, cell);
#line 191
    tmp___1 = mix_to_C_char(tmp___0);
#line 191
    fputc((int )tmp___1, outfile);
#line 190
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 192
  return;
}
}
#line 194 "/home/wheatley/newnew/temp/mixal-1.08/io.c"
static void write_line(FILE *file , Address buffer , unsigned int size , Flag text ) 
{ 
  unsigned int i ;

  {
#line 197
  i = 0U;
  {
#line 197
  while (1) {
    while_continue: /* CIL Label */ ;
#line 197
    if (! (i < size)) {
#line 197
      goto while_break;
    }
#line 198
    if (4000U <= buffer + i) {
      {
#line 199
      error("Address out of range");
      }
    }
    {
#line 200
    write_cell(memory[buffer + i], file, text);
#line 197
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 202
  fputc('\n', file);
  }
#line 203
  return;
}
}
#line 205 "/home/wheatley/newnew/temp/mixal-1.08/io.c"
static void printer_ioc(unsigned int device , Cell argument ) 
{ 
  FILE *tmp ;

  {
#line 207
  if ((argument & ((1L << 30) - 1L)) != 0L) {
    {
#line 208
    error("IOC argument undefined for printer device %02o", device);
    }
  }
  {
#line 209
  tmp = assigned_file(device);
#line 209
  fputc('\f', tmp);
  }
#line 210
  return;
}
}
#line 212 "/home/wheatley/newnew/temp/mixal-1.08/io.c"
static void text_in(unsigned int device , Cell argument , Address buffer ) 
{ 
  unsigned int tmp ;
  FILE *tmp___0 ;

  {
  {
#line 214
  tmp = block_size(device);
#line 214
  tmp___0 = assigned_file(device);
#line 214
  read_line(tmp___0, buffer, tmp);
  }
#line 215
  return;
}
}
#line 217 "/home/wheatley/newnew/temp/mixal-1.08/io.c"
static void text_out(unsigned int device , Cell argument , Address buffer ) 
{ 
  unsigned int tmp ;
  FILE *tmp___0 ;

  {
  {
#line 219
  tmp = block_size(device);
#line 219
  tmp___0 = assigned_file(device);
#line 219
  write_line(tmp___0, buffer, tmp, (Flag )1);
  }
#line 220
  return;
}
}
#line 227 "/home/wheatley/newnew/temp/mixal-1.08/io.c"
static void set_file_position(Byte device , unsigned int block , Flag writing ) 
{ 
  int *tmp ;
  char *tmp___0 ;
  unsigned int tmp___1 ;
  FILE *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 229
  tmp___1 = block_size(device);
#line 229
  tmp___2 = assigned_file(device);
#line 229
  tmp___3 = fseek(tmp___2, (long )block * (long )(6U * tmp___1 + 1U), 0);
  }
#line 229
  if (tmp___3) {
    {
#line 232
    tmp = __errno_location();
#line 232
    tmp___0 = strerror(*tmp);
#line 232
    error("Device %02o: %s", device, tmp___0);
    }
  }
#line 233
  return;
}
}
#line 239 "/home/wheatley/newnew/temp/mixal-1.08/io.c"
static void read_block(Byte device , Address buffer ) 
{ 
  FILE *file ;
  FILE *tmp ;
  unsigned int size ;
  unsigned int tmp___0 ;
  unsigned int i ;
  unsigned int b ;
  int c ;
  Cell cell ;
  Byte tmp___1 ;

  {
  {
#line 241
  tmp = assigned_file(device);
#line 241
  file = tmp;
#line 242
  tmp___0 = block_size(device);
#line 242
  size = tmp___0;
#line 244
  i = 0U;
  }
  {
#line 244
  while (1) {
    while_continue: /* CIL Label */ ;
#line 244
    if (! (i < size)) {
#line 244
      goto while_break;
    }
#line 246
    cell = (Cell )0;
#line 247
    if (4000U <= buffer + i) {
      {
#line 248
      error("Address out of range -- read_block");
      }
    }
    {
#line 250
    c = fgetc(file);
    }
#line 251
    if (c == -1) {
      {
#line 252
      error("Unexpected EOF reading from device %02o", device);
      }
    } else
#line 253
    if (c == 45) {
#line 254
      cell ^= 1L << 30;
    }
#line 256
    b = 1U;
    {
#line 256
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 256
      if (! (b <= 5U)) {
#line 256
        goto while_break___0;
      }
      {
#line 257
      c = fgetc(file);
      }
#line 258
      if (c == -1) {
        {
#line 259
        error("Unexpected EOF reading from device %02o", device);
        }
      }
      {
#line 260
      tmp___1 = C_char_to_mix((char )c);
#line 260
      cell = set_byte(tmp___1, b, cell);
#line 256
      b ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 262
    memory[buffer + i] = cell;
#line 244
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 264
  fgetc(file);
  }
#line 265
  return;
}
}
#line 268 "/home/wheatley/newnew/temp/mixal-1.08/io.c"
static void write_block(Byte device , Address buffer ) 
{ 
  unsigned int tmp ;
  FILE *tmp___0 ;

  {
  {
#line 270
  tmp = block_size(device);
#line 270
  tmp___0 = assigned_file(device);
#line 270
  write_line(tmp___0, buffer, tmp, (Flag )0);
  }
#line 271
  return;
}
}
#line 275 "/home/wheatley/newnew/temp/mixal-1.08/io.c"
static void tape_ioc(unsigned int device , Cell offset ) 
{ 


  {
  {
#line 277
  error("Unimplemented");
  }
#line 278
  return;
}
}
#line 280 "/home/wheatley/newnew/temp/mixal-1.08/io.c"
static void tape_in(unsigned int device , Cell argument , Address buffer ) 
{ 


  {
  {
#line 282
  error("Unimplemented");
  }
#line 283
  return;
}
}
#line 285 "/home/wheatley/newnew/temp/mixal-1.08/io.c"
static void tape_out(unsigned int device , Cell argument , Address buffer ) 
{ 


  {
  {
#line 287
  error("Unimplemented");
  }
#line 288
  return;
}
}
#line 292 "/home/wheatley/newnew/temp/mixal-1.08/io.c"
static void disk_ioc(unsigned int device , Cell offset ) 
{ 


  {
#line 294
  if ((offset & ((1L << 30) - 1L)) != 0L) {
    {
#line 295
    error("IOC argument undefined for disk device %02o", device);
    }
  }
#line 296
  return;
}
}
#line 298 "/home/wheatley/newnew/temp/mixal-1.08/io.c"
static void disk_in(unsigned int device , Cell argument , Address buffer ) 
{ 
  unsigned int block_num ;
  Byte tmp ;
  Cell tmp___0 ;

  {
  {
#line 300
  tmp = make_field_spec(4U, 5U);
#line 300
  tmp___0 = field(tmp, argument);
#line 300
  block_num = (unsigned int )tmp___0;
#line 301
  set_file_position(device, block_num, (Flag )0);
#line 302
  read_block(device, buffer);
  }
#line 303
  return;
}
}
#line 305 "/home/wheatley/newnew/temp/mixal-1.08/io.c"
static void disk_out(unsigned int device , Cell argument , Address buffer ) 
{ 
  unsigned int block_num ;
  Byte tmp ;
  Cell tmp___0 ;

  {
  {
#line 307
  tmp = make_field_spec(4U, 5U);
#line 307
  tmp___0 = field(tmp, argument);
#line 307
  block_num = (unsigned int )tmp___0;
#line 308
  set_file_position(device, block_num, (Flag )1);
#line 309
  write_block(device, buffer);
  }
#line 310
  return;
}
}
#line 315 "/home/wheatley/newnew/temp/mixal-1.08/io.c"
static void console_in(unsigned int device , Cell argument , Address buffer ) 
{ 
  unsigned int tmp ;

  {
  {
#line 317
  tmp = block_size(device);
#line 317
  read_line(stdin, buffer, tmp);
  }
#line 318
  return;
}
}
#line 320 "/home/wheatley/newnew/temp/mixal-1.08/io.c"
static void console_out(unsigned int device , Cell argument , Address buffer ) 
{ 
  unsigned int tmp ;

  {
  {
#line 322
  tmp = block_size(device);
#line 322
  write_line(stdout, buffer, tmp, (Flag )1);
  }
#line 323
  return;
}
}
#line 11 "/home/wheatley/newnew/temp/mixal-1.08/asm.h"
Cell asm_fetch_field(Address address , unsigned int L , unsigned int R ) ;
#line 14 "/home/wheatley/newnew/temp/mixal-1.08/asm.h"
Address entry_point  ;
#line 15
void set_entry_point(Address address ) ;
#line 9 "/home/wheatley/newnew/temp/mixal-1.08/asm.c"
Address here  =    (Address )0;
#line 11 "/home/wheatley/newnew/temp/mixal-1.08/asm.c"
Cell asm_fetch_field(Address address , unsigned int L , unsigned int R ) 
{ 
  Byte tmp ;
  Cell tmp___0 ;

  {
#line 13
  if (! (address < 4000U)) {
    {
#line 13
    __assert_fail("address < 4000", "/home/wheatley/newnew/temp/mixal-1.08/asm.c",
                  13U, "asm_fetch_field");
    }
  }
  {
#line 14
  tmp = make_field_spec(L, R);
#line 14
  tmp___0 = field(tmp, memory[address]);
  }
#line 14
  return (tmp___0);
}
}
#line 19 "/home/wheatley/newnew/temp/mixal-1.08/asm.c"
void asm_store_field(Address address , unsigned int L , unsigned int R , Cell cell ) 
{ 
  Byte tmp ;

  {
#line 21
  if (! (address < 4000U)) {
    {
#line 21
    __assert_fail("address < 4000", "/home/wheatley/newnew/temp/mixal-1.08/asm.c",
                  21U, "asm_store_field");
    }
  }
  {
#line 27
  tmp = make_field_spec(L, R);
#line 27
  memory[address] = set_field(cell, tmp, memory[address]);
  }
#line 28
  return;
}
}
#line 30 "/home/wheatley/newnew/temp/mixal-1.08/asm.c"
void assemble(Cell cell ) 
{ 


  {
#line 37
  if (here < 4000U) {
#line 38
    memory[here] = cell;
  } else {
    {
#line 40
    error("Address out of range");
    }
  }
#line 41
  here ++;
#line 42
  return;
}
}
#line 46 "/home/wheatley/newnew/temp/mixal-1.08/asm.c"
void set_entry_point(Address address ) 
{ 


  {
#line 48
  if (! (address < 4000U)) {
    {
#line 48
    __assert_fail("address < 4000", "/home/wheatley/newnew/temp/mixal-1.08/asm.c",
                  48U, "set_entry_point");
    }
  }
#line 51
  entry_point = address;
#line 52
  return;
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 5 "/home/wheatley/newnew/temp/mixal-1.08/driver.h"
void assemble_line(char const   *line ) ;
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 830
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 189 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) clock_t ( __attribute__((__leaf__)) clock)(void) ;
#line 18 "/home/wheatley/newnew/temp/mixal-1.08/main.c"
static char const   *current_file  =    (char const   *)((void *)0);
#line 19 "/home/wheatley/newnew/temp/mixal-1.08/main.c"
static unsigned int line_number  ;
#line 20 "/home/wheatley/newnew/temp/mixal-1.08/main.c"
static unsigned int num_errors  =    0U;
#line 22 "/home/wheatley/newnew/temp/mixal-1.08/main.c"
void fatal_error(char const   *message  , ...) 
{ 
  va_list args ;

  {
#line 25
  if (current_file) {
    {
#line 26
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"FATAL ERROR (%s, line %u): ",
            current_file, line_number);
    }
  } else {
    {
#line 28
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"FATAL ERROR: ");
    }
  }
  {
#line 29
  __builtin_va_start(args, message);
#line 30
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)message,
           args);
#line 31
  __builtin_va_end(args);
#line 32
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 33
  exit(1);
  }
}
}
#line 36 "/home/wheatley/newnew/temp/mixal-1.08/main.c"
static void (*error_handler)(char const   * , va_list  )  =    (void (*)(char const   * , va_list  ))((void *)0);
#line 38 "/home/wheatley/newnew/temp/mixal-1.08/main.c"
void install_error_handler(void (*handler)(char const   * , va_list  ) ) 
{ 


  {
#line 40
  error_handler = handler;
#line 41
  return;
}
}
#line 43 "/home/wheatley/newnew/temp/mixal-1.08/main.c"
void error(char const   *message  , ...) 
{ 
  va_list args ;

  {
  {
#line 46
  num_errors ++;
#line 47
  __builtin_va_start(args, message);
  }
#line 48
  if (error_handler) {
    {
#line 49
    (*error_handler)(message, args);
    }
  } else {
    {
#line 51
    fatal_error("No error handler installed");
    }
  }
  {
#line 52
  __builtin_va_end(args);
  }
#line 53
  return;
}
}
#line 55 "/home/wheatley/newnew/temp/mixal-1.08/main.c"
void warn(char const   *message  , ...) 
{ 
  va_list args ;

  {
#line 58
  if (current_file) {
    {
#line 59
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"WARNING (%s, line %u): ",
            current_file, line_number);
    }
  } else {
    {
#line 61
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"WARNING: ");
    }
  }
  {
#line 62
  __builtin_va_start(args, message);
#line 63
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)message,
           args);
#line 64
  __builtin_va_end(args);
#line 65
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
  }
#line 66
  return;
}
}
#line 70 "/home/wheatley/newnew/temp/mixal-1.08/main.c"
static FILE *open_file(char const   *filename___0 , char const   *mode ) 
{ 
  struct _IO_FILE *tmp ;
  FILE *result ;
  FILE *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 72
  tmp___3 = strcmp(filename___0, "-");
  }
#line 72
  if (tmp___3 == 0) {
#line 73
    if (! ((int const   )*(mode + 0) == 114)) {
#line 73
      if (! ((int const   )*(mode + 0) == 119)) {
        {
#line 73
        __assert_fail("mode[0] == \'r\' || mode[0] == \'w\'", "/home/wheatley/newnew/temp/mixal-1.08/main.c",
                      73U, "open_file");
        }
      }
    }
#line 74
    if ((int const   )*(mode + 0) == 119) {
#line 74
      tmp = stdout;
    } else {
#line 74
      tmp = stdin;
    }
#line 74
    return (tmp);
  } else {
    {
#line 76
    tmp___0 = fopen((char const   */* __restrict  */)filename___0, (char const   */* __restrict  */)mode);
#line 76
    result = tmp___0;
    }
#line 77
    if (! result) {
      {
#line 78
      tmp___1 = __errno_location();
#line 78
      tmp___2 = strerror(*tmp___1);
#line 78
      fatal_error("%s: %s", filename___0, tmp___2);
      }
    }
#line 79
    return (result);
  }
}
}
#line 85 "/home/wheatley/newnew/temp/mixal-1.08/main.c"
static void assembler_error(char const   *message , va_list args ) 
{ 


  {
#line 87
  if (current_file) {
    {
#line 88
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR (%s, line %u): ",
            current_file, line_number);
    }
  } else {
    {
#line 90
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR: ");
    }
  }
  {
#line 91
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)message,
           args);
#line 92
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
  }
#line 93
  return;
}
}
#line 95 "/home/wheatley/newnew/temp/mixal-1.08/main.c"
static void assemble_file(char const   *filename___0 ) 
{ 
  FILE *infile ;
  FILE *tmp ;
  char line[257] ;
  char *tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;

  {
  {
#line 97
  tmp = open_file(filename___0, "r");
#line 97
  infile = tmp;
#line 99
  current_file = filename___0;
#line 99
  line_number = 0U;
  }
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 100
    tmp___4 = fgets((char */* __restrict  */)(line), (int )sizeof(line), (FILE */* __restrict  */)infile);
    }
#line 100
    if (! tmp___4) {
#line 100
      goto while_break;
    }
    {
#line 101
    line_number ++;
#line 102
    assemble_line((char const   *)(line));
#line 103
    tmp___3 = strlen((char const   *)(line));
    }
#line 103
    if ((int )line[tmp___3 - 1UL] != 10) {
      {
#line 104
      tmp___2 = fgets((char */* __restrict  */)(line), (int )sizeof(line), (FILE */* __restrict  */)infile);
      }
#line 104
      if (tmp___2) {
        {
#line 107
        error("Line length exceeds 256 characters");
        }
        {
#line 109
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 109
          tmp___1 = strlen((char const   *)(line));
          }
#line 109
          if (! ((int )line[tmp___1 - 1UL] != 10)) {
#line 109
            goto while_break___0;
          }
          {
#line 110
          tmp___0 = fgets((char */* __restrict  */)(line), (int )sizeof(line), (FILE */* __restrict  */)infile);
          }
#line 110
          if (! tmp___0) {
#line 111
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      } else {
#line 105
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 115
  tmp___7 = ferror(infile);
  }
#line 115
  if (tmp___7) {
    {
#line 116
    tmp___5 = __errno_location();
#line 116
    tmp___6 = strerror(*tmp___5);
#line 116
    error("%s: %s", filename___0, tmp___6);
    }
  }
  {
#line 117
  fclose(infile);
#line 118
  current_file = (char const   *)((void *)0);
  }
#line 119
  return;
}
}
#line 121 "/home/wheatley/newnew/temp/mixal-1.08/main.c"
int main(int argc , char **argv ) 
{ 
  int i ;
  clock_t finish ;
  clock_t start ;
  clock_t tmp ;

  {
  {
#line 123
  precompute_field_data();
#line 126
  install_error_handler(& assembler_error);
  }
#line 127
  if (argc == 1) {
    {
#line 128
    assemble_file("-");
    }
  } else {
#line 131
    i = 1;
    {
#line 131
    while (1) {
      while_continue: /* CIL Label */ ;
#line 131
      if (! (i < argc)) {
#line 131
        goto while_break;
      }
      {
#line 132
      assemble_file((char const   *)*(argv + i));
#line 131
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 134
  resolve_generated_futures();
  }
#line 135
  if (num_errors != 0U) {
    {
#line 136
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%u errors found\n",
            num_errors);
#line 137
    exit(1);
    }
  }
  {
#line 141
  set_initial_state();
#line 143
  tmp = clock();
#line 143
  start = tmp;
#line 144
  run();
#line 145
  finish = clock();
#line 146
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%g seconds elapsed\n",
          (double )((float )(finish - start) / (float )1000000L));
#line 149
  print_CPU_state();
  }
#line 150
  return (0);
}
}
#line 16 "/home/wheatley/newnew/temp/mixal-1.08/driver.c"
static char label[33]  ;
#line 18 "/home/wheatley/newnew/temp/mixal-1.08/driver.c"
static Byte the_C  ;
#line 18 "/home/wheatley/newnew/temp/mixal-1.08/driver.c"
static Byte default_F  ;
#line 19 "/home/wheatley/newnew/temp/mixal-1.08/driver.c"
static Flag F_must_be_default  ;
#line 24 "/home/wheatley/newnew/temp/mixal-1.08/driver.c"
static void do_opcode(void) 
{ 
  Cell tmp ;
  Cell tmp___0 ;

  {
  {
#line 26
  tmp = parse_operand(F_must_be_default, default_F);
#line 26
  tmp___0 = set_byte(the_C, 5U, tmp);
#line 26
  assemble(tmp___0);
  }
#line 27
  return;
}
}
#line 29 "/home/wheatley/newnew/temp/mixal-1.08/driver.c"
static void do_con(void) 
{ 
  Cell tmp ;

  {
  {
#line 31
  tmp = parse_W();
#line 31
  assemble(tmp);
  }
#line 32
  return;
}
}
#line 34 "/home/wheatley/newnew/temp/mixal-1.08/driver.c"
static void do_alf(void) 
{ 


  {
  {
#line 36
  error("Use CON instead of ALF");
  }
#line 37
  return;
}
}
#line 39 "/home/wheatley/newnew/temp/mixal-1.08/driver.c"
static void do_end(void) 
{ 
  Cell tmp ;
  Address tmp___0 ;

  {
  {
#line 41
  tmp = parse_W();
#line 41
  tmp___0 = cell_to_address(tmp);
#line 41
  set_entry_point(tmp___0);
  }
#line 42
  return;
}
}
#line 44 "/home/wheatley/newnew/temp/mixal-1.08/driver.c"
static void do_equ(void) 
{ 
  Cell tmp ;
  Symbol tmp___0 ;

  {
  {
#line 46
  tmp = parse_W();
#line 46
  tmp___0 = string_to_symbol((char const   *)(label));
#line 46
  define_symbol(tmp___0, tmp);
  }
#line 51
  return;
}
}
#line 53 "/home/wheatley/newnew/temp/mixal-1.08/driver.c"
static void do_orig(void) 
{ 
  Cell tmp ;

  {
  {
#line 55
  tmp = parse_W();
#line 55
  here = cell_to_address(tmp);
  }
#line 56
  return;
}
}
#line 71 "/home/wheatley/newnew/temp/mixal-1.08/driver.c"
static OpDef op_table___0[51]  = 
#line 71
  {      {"add", & do_opcode, (Byte )1, (Byte )5, (Flag )0}, 
        {"alf", & do_alf, (Byte )0, (Byte )0, (Flag )0}, 
        {"char", & do_opcode, (Byte )5, (Byte )1, (Flag )1}, 
        {"cmp-", & do_opcode, (Byte )56, (Byte )5, (Flag )0}, 
        {"con", & do_con, (Byte )0, (Byte )0, (Flag )0}, 
        {"dec-", & do_opcode, (Byte )48, (Byte )1, (Flag )1}, 
        {"div", & do_opcode, (Byte )4, (Byte )5, (Flag )0}, 
        {"end", & do_end, (Byte )0, (Byte )0, (Flag )0}, 
        {"enn-", & do_opcode, (Byte )48, (Byte )3, (Flag )1}, 
        {"ent-", & do_opcode, (Byte )48, (Byte )2, (Flag )1}, 
        {"equ", & do_equ, (Byte )0, (Byte )0, (Flag )0}, 
        {"hlt", & do_opcode, (Byte )5, (Byte )2, (Flag )1}, 
        {"in", & do_opcode, (Byte )36, (Byte )0, (Flag )0}, 
        {"inc-", & do_opcode, (Byte )48, (Byte )0, (Flag )1}, 
        {"ioc", & do_opcode, (Byte )35, (Byte )0, (Flag )0}, 
        {"j-n", & do_opcode, (Byte )40, (Byte )0, (Flag )1}, 
        {"j-nn", & do_opcode, (Byte )40, (Byte )3, (Flag )1}, 
        {"j-np", & do_opcode, (Byte )40, (Byte )5, (Flag )1}, 
        {"j-nz", & do_opcode, (Byte )40, (Byte )4, (Flag )1}, 
        {"j-p", & do_opcode, (Byte )40, (Byte )2, (Flag )1}, 
        {"j-z", & do_opcode, (Byte )40, (Byte )1, (Flag )1}, 
        {"jbus", & do_opcode, (Byte )34, (Byte )0, (Flag )0}, 
        {"je", & do_opcode, (Byte )39, (Byte )5, (Flag )1}, 
        {"jg", & do_opcode, (Byte )39, (Byte )6, (Flag )1}, 
        {"jge", & do_opcode, (Byte )39, (Byte )7, (Flag )1}, 
        {"jl", & do_opcode, (Byte )39, (Byte )4, (Flag )1}, 
        {"jle", & do_opcode, (Byte )39, (Byte )9, (Flag )1}, 
        {"jmp", & do_opcode, (Byte )39, (Byte )0, (Flag )1}, 
        {"jne", & do_opcode, (Byte )39, (Byte )8, (Flag )1}, 
        {"jnov", & do_opcode, (Byte )39, (Byte )3, (Flag )1}, 
        {"jov", & do_opcode, (Byte )39, (Byte )2, (Flag )1}, 
        {"jred", & do_opcode, (Byte )38, (Byte )0, (Flag )0}, 
        {"jsj", & do_opcode, (Byte )39, (Byte )1, (Flag )1}, 
        {"ld-", & do_opcode, (Byte )8, (Byte )5, (Flag )0}, 
        {"ld-n", & do_opcode, (Byte )16, (Byte )5, (Flag )0}, 
        {"move", & do_opcode, (Byte )7, (Byte )1, (Flag )0}, 
        {"mul", & do_opcode, (Byte )3, (Byte )5, (Flag )0}, 
        {"nop", & do_opcode, (Byte )0, (Byte )0, (Flag )0}, 
        {"num", & do_opcode, (Byte )5, (Byte )0, (Flag )1}, 
        {"orig", & do_orig, (Byte )0, (Byte )0, (Flag )0}, 
        {"out", & do_opcode, (Byte )37, (Byte )0, (Flag )0}, 
        {"sla", & do_opcode, (Byte )6, (Byte )0, (Flag )1}, 
        {"slax", & do_opcode, (Byte )6, (Byte )2, (Flag )1}, 
        {"slc", & do_opcode, (Byte )6, (Byte )4, (Flag )1}, 
        {"sra", & do_opcode, (Byte )6, (Byte )1, (Flag )1}, 
        {"srax", & do_opcode, (Byte )6, (Byte )3, (Flag )1}, 
        {"src", & do_opcode, (Byte )6, (Byte )5, (Flag )1}, 
        {"st-", & do_opcode, (Byte )24, (Byte )5, (Flag )0}, 
        {"stj", & do_opcode, (Byte )32, (Byte )2, (Flag )0}, 
        {"stz", & do_opcode, (Byte )33, (Byte )5, (Flag )0}, 
        {"sub", & do_opcode, (Byte )2, (Byte )5, (Flag )0}};
#line 79 "/home/wheatley/newnew/temp/mixal-1.08/driver.c"
static int delta_C  ;
#line 92
static int compare_mnemonics(char const   *datum , char const   *pattern ) ;
#line 92 "/home/wheatley/newnew/temp/mixal-1.08/driver.c"
static char const   legals[9]  = 
#line 92
  {      (char const   )'a',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'x', 
        (char const   )'\000'};
#line 86 "/home/wheatley/newnew/temp/mixal-1.08/driver.c"
static int compare_mnemonics(char const   *datum , char const   *pattern ) 
{ 
  unsigned int my_delta_C ;
  char d ;
  int tmp ;
  char const   *temp ;
  char *tmp___0 ;
  int result ;
  int tmp___1 ;

  {
#line 88
  my_delta_C = 0U;
  {
#line 89
  while (1) {
    while_continue: /* CIL Label */ ;
#line 89
    if (! *pattern) {
#line 89
      goto while_break;
    }
    {
#line 90
    tmp = tolower((int )*datum);
#line 90
    d = (char )tmp;
    }
#line 91
    if ((int const   )*pattern == 45) {
      {
#line 93
      tmp___0 = strchr(legals, (int )d);
#line 93
      temp = (char const   *)tmp___0;
      }
#line 94
      if (temp) {
#line 95
        my_delta_C = (unsigned int )(temp - legals);
      } else {
#line 97
        goto while_break;
      }
    } else
#line 98
    if (! ((int const   )*pattern == (int const   )d)) {
#line 101
      goto while_break;
    }
#line 89
    pattern ++;
#line 89
    datum ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 104
  tmp___1 = tolower((int )*datum);
#line 104
  result = tmp___1 - (int )*pattern;
  }
#line 105
  if (result == 0) {
#line 106
    delta_C = (int )my_delta_C;
  }
#line 107
  return (result);
}
}
#line 116 "/home/wheatley/newnew/temp/mixal-1.08/driver.c"
static Handler lookup_mnemonic(char const   *mnemonic ) 
{ 
  unsigned int i ;
  int tmp ;

  {
#line 119
  delta_C = 0;
#line 120
  i = 0U;
  {
#line 120
  while (1) {
    while_continue: /* CIL Label */ ;
#line 120
    if (! ((unsigned long )i < sizeof(op_table___0) / sizeof(op_table___0[0]))) {
#line 120
      goto while_break;
    }
    {
#line 121
    tmp = compare_mnemonics(mnemonic, (char const   *)op_table___0[i].name);
    }
#line 121
    if (tmp == 0) {
#line 122
      the_C = (Byte )(op_table___0[i].C + (Byte const   )delta_C);
#line 123
      default_F = (Byte )op_table___0[i].F;
#line 124
      F_must_be_default = (Flag )op_table___0[i].is_extended;
#line 125
      return ((Handler )op_table___0[i].handler);
    }
#line 120
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 128
  return ((Handler )((void *)0));
}
}
#line 131 "/home/wheatley/newnew/temp/mixal-1.08/driver.c"
static char const   *skip_blanks(char const   *s ) 
{ 
  size_t tmp ;

  {
  {
#line 133
  tmp = strspn(s, " \t");
  }
#line 133
  return (s + tmp);
}
}
#line 138 "/home/wheatley/newnew/temp/mixal-1.08/driver.c"
static void eat_identifier(char *buffer , const_char_ptr *s ) 
{ 
  char const   *scan ;
  size_t size ;
  size_t truncated_size ;
  unsigned short const   **tmp ;
  Flag alpha ;
  Flag non_alphanum ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
#line 140
  scan = (char const   *)buffer;
#line 143
  scan = *s;
  {
#line 143
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 143
    tmp = __ctype_b_loc();
    }
#line 143
    if ((int const   )*(*tmp + (int )*scan) & 8192) {
#line 143
      goto while_break;
    } else
#line 143
    if (! ((int const   )*scan != 0)) {
#line 143
      goto while_break;
    }
#line 143
    scan ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 145
  size = (size_t )(scan - *s);
#line 148
  alpha = (Flag )0;
#line 148
  non_alphanum = (Flag )0;
#line 149
  scan = *s;
  {
#line 149
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 149
    if (! ((unsigned long )scan < (unsigned long )(*s + size))) {
#line 149
      goto while_break___0;
    }
    {
#line 150
    tmp___1 = __ctype_b_loc();
    }
#line 150
    if ((int const   )*(*tmp___1 + (int )*scan) & 1024) {
#line 151
      alpha = (Flag )1;
    } else {
      {
#line 152
      tmp___0 = __ctype_b_loc();
      }
#line 152
      if (! ((int const   )*(*tmp___0 + (int )*scan) & 8)) {
#line 153
        non_alphanum = (Flag )1;
      }
    }
#line 149
    scan ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 155
  if (! alpha) {
#line 155
    if (size != 0UL) {
      {
#line 156
      error("Ill-formed label or mnemonic: %*.*s", size, size, *s);
#line 157
      *(buffer + 0) = (char )'\000';
#line 158
      *s += size;
      }
#line 159
      return;
    } else {
#line 155
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 155
  if (non_alphanum) {
    {
#line 156
    error("Ill-formed label or mnemonic: %*.*s", size, size, *s);
#line 157
    *(buffer + 0) = (char )'\000';
#line 158
    *s += size;
    }
#line 159
    return;
  }
#line 163
  if (32UL < size) {
    {
#line 164
    warn("Truncated long label or mnemonic: %*.*s", size, size, *s);
#line 165
    truncated_size = (size_t )32;
    }
  } else {
#line 167
    truncated_size = size;
  }
  {
#line 169
  memcpy((void */* __restrict  */)buffer, (void const   */* __restrict  */)*s, truncated_size);
#line 170
  *(buffer + truncated_size) = (char )'\000';
#line 171
  *s += size;
  }
#line 172
  return;
}
}
#line 174 "/home/wheatley/newnew/temp/mixal-1.08/driver.c"
void assemble_line(char const   *line ) 
{ 
  char mnemonic[33] ;
  char const   *scan ;
  char const   *tmp ;
  void (*handler)(void) ;
  Handler tmp___0 ;
  Cell tmp___1 ;
  Symbol tmp___2 ;

  {
  {
#line 177
  scan = line;
#line 179
  tmp = skip_blanks(scan);
  }
#line 179
  if ((int const   )*tmp == 42) {
#line 180
    return;
  }
  {
#line 182
  eat_identifier(label, & scan);
#line 183
  scan = skip_blanks(scan);
#line 184
  eat_identifier(mnemonic, & scan);
#line 185
  scan = skip_blanks(scan);
#line 186
  setup_scanner(scan);
#line 189
  tmp___0 = lookup_mnemonic((char const   *)(mnemonic));
#line 189
  handler = tmp___0;
  }
#line 190
  if ((unsigned long )handler != (unsigned long )(& do_equ)) {
#line 190
    if ((int )label[0] != 0) {
      {
#line 191
      tmp___1 = address_to_cell(here);
#line 191
      tmp___2 = string_to_symbol((char const   *)(label));
#line 191
      define_symbol(tmp___2, tmp___1);
      }
    }
  }
#line 192
  if (handler) {
    {
#line 193
    (*handler)();
#line 194
    done_parsing();
    }
  } else
#line 195
  if ((int )mnemonic[0] != 0) {
    {
#line 196
    error("Unknown instruction: %s", mnemonic);
    }
  }
#line 200
  return;
}
}
