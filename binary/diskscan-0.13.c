/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 55 "/usr/include/stdint.h"
typedef unsigned long uint64_t;
#line 10 "/home/june/repo/benchmarks/collector/temp/diskscan-0.13/include/diskscan.h"
enum scan_mode {
    SCAN_MODE_UNKNOWN = 0,
    SCAN_MODE_SEQ = 1,
    SCAN_MODE_RANDOM = 2
} ;
#line 16 "/home/june/repo/benchmarks/collector/temp/diskscan-0.13/include/diskscan.h"
struct latency_t {
   uint64_t start_sector ;
   uint64_t end_sector ;
   uint32_t latency_min_msec ;
   uint32_t latency_max_msec ;
   uint32_t latency_median_msec ;
};
#line 16 "/home/june/repo/benchmarks/collector/temp/diskscan-0.13/include/diskscan.h"
typedef struct latency_t latency_t;
#line 24
static uint64_t const   histogram_time[19] ;
#line 24
static uint64_t const   histogram_time[19] ;
#line 24 "/home/june/repo/benchmarks/collector/temp/diskscan-0.13/include/diskscan.h"
struct disk_t {
   int fd ;
   char path[128] ;
   char vendor[32] ;
   char model[32] ;
   char serial[32] ;
   uint64_t num_bytes ;
   uint64_t sector_size ;
   int run ;
   uint64_t num_errors ;
   uint64_t histogram[sizeof(histogram_time) / sizeof(histogram_time[0])] ;
   unsigned int latency_graph_len ;
   latency_t *latency_graph ;
};
#line 24 "/home/june/repo/benchmarks/collector/temp/diskscan-0.13/include/diskscan.h"
typedef struct disk_t disk_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_7 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_7 __sigset_t;
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef union sigval sigval_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef __clock_t __sigchld_clock_t;
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__kill_10 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__timer_11 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__rt_12 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigchld_13 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __sigchld_clock_t si_utime ;
   __sigchld_clock_t si_stime ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigfault_14 {
   void *si_addr ;
   short si_addr_lsb ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigpoll_15 {
   long si_band ;
   int si_fd ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigsys_16 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union __anonunion__sifields_9 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_10 _kill ;
   struct __anonstruct__timer_11 _timer ;
   struct __anonstruct__rt_12 _rt ;
   struct __anonstruct__sigchld_13 _sigchld ;
   struct __anonstruct__sigfault_14 _sigfault ;
   struct __anonstruct__sigpoll_15 _sigpoll ;
   struct __anonstruct__sigsys_16 _sigsys ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct_siginfo_t_8 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_9 _sifields ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef struct __anonstruct_siginfo_t_8 siginfo_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion___sigaction_handler_28 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_28 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 104 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 33 "/home/june/repo/benchmarks/collector/temp/diskscan-0.13/cli/cli.c"
struct options_t;
#line 33 "/home/june/repo/benchmarks/collector/temp/diskscan-0.13/cli/cli.c"
typedef struct options_t options_t;
#line 34 "/home/june/repo/benchmarks/collector/temp/diskscan-0.13/cli/cli.c"
struct options_t {
   char *disk_path ;
   int verbose ;
   int fix ;
   enum scan_mode mode ;
};
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 147 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __clockid_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 91 "/usr/include/time.h"
typedef __clockid_t clockid_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 38 "/home/june/repo/benchmarks/collector/temp/diskscan-0.13/lib/diskscan.c"
struct scan_state {
   uint32_t latency_bucket ;
   uint64_t latency_stride ;
   uint32_t latency_count ;
   uint32_t *latency ;
   void *data ;
};
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 24 "/home/june/repo/benchmarks/collector/temp/diskscan-0.13/include/diskscan.h"
static uint64_t const   histogram_time[19] ;
#line 4 "/home/june/repo/benchmarks/collector/temp/diskscan-0.13/include/verbose.h"
int verbose ;
#line 6
void verbose_out(char const   *fmt  , ...) ;
#line 8 "/home/june/repo/benchmarks/collector/temp/diskscan-0.13/include/diskscan.h"
static uint64_t const   histogram_time[19]  = 
#line 8 "/home/june/repo/benchmarks/collector/temp/diskscan-0.13/include/diskscan.h"
  {      (uint64_t const   )1,      (uint64_t const   )10,      (uint64_t const   )100,      (uint64_t const   )500, 
        (uint64_t const   )1000,      (uint64_t const   )2000,      (uint64_t const   )3000,      (uint64_t const   )4000, 
        (uint64_t const   )5000,      (uint64_t const   )6000,      (uint64_t const   )7000,      (uint64_t const   )8000, 
        (uint64_t const   )9000,      (uint64_t const   )10000,      (uint64_t const   )15000,      (uint64_t const   )20000, 
        (uint64_t const   )25000,      (uint64_t const   )30000,      (uint64_t const   )0xffffffffffffffffUL};
#line 40
int disk_open(disk_t *disk___0 , char const   *path , int fix , unsigned int latency_graph_len ) ;
#line 41
int disk_scan(disk_t *disk___0 , enum scan_mode mode ) ;
#line 42
int disk_close(disk_t *disk___0 ) ;
#line 43
void disk_scan_stop(disk_t *disk___0 ) ;
#line 45
enum scan_mode str_to_scan_mode(char const   *s ) ;
#line 48
void report_scan_success(disk_t *disk___0 , uint64_t offset_bytes , uint64_t data_size ,
                         uint64_t time___0 ) ;
#line 49
void report_scan_error(disk_t *disk___0 , uint64_t offset_bytes , uint64_t data_size ,
                       uint64_t time___0 ) ;
#line 50
void report_scan_done(disk_t *disk___0 ) ;
#line 5 "/home/june/repo/benchmarks/collector/temp/diskscan-0.13/include/version.h"
char *TAG ;
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 259 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigaction)(int __sig ,
                                                                                struct sigaction  const  * __restrict  __act ,
                                                                                struct sigaction * __restrict  __oact ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 173
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long)(int ___argc ,
                                                                                  char * const  *___argv ,
                                                                                  char const   *__shortopts ,
                                                                                  struct option  const  *__longopts ,
                                                                                  int *__longind ) ;
#line 31 "/home/june/repo/benchmarks/collector/temp/diskscan-0.13/cli/cli.c"
static disk_t disk  ;
#line 41 "/home/june/repo/benchmarks/collector/temp/diskscan-0.13/cli/cli.c"
void print_header(void) 
{ 


  {
  {
#line 43
  printf((char const   */* __restrict  */)"diskscan version %s\n\n", TAG);
  }
#line 44
  if (verbose > 0) {
    {
#line 44
    verbose_out("V: Verbosity set");
    }
  }
#line 45
  if (verbose > 1) {
    {
#line 45
    verbose_out("V: High verbosity set");
    }
  }
#line 46
  if (verbose > 2) {
    {
#line 46
    verbose_out("V: Very high verbosity set");
    }
  }
#line 47
  return;
}
}
#line 49 "/home/june/repo/benchmarks/collector/temp/diskscan-0.13/cli/cli.c"
int usage(void) 
{ 


  {
  {
#line 50
  printf((char const   */* __restrict  */)"diskscan version %s\n\n", TAG);
#line 51
  printf((char const   */* __restrict  */)"diskscan [options] /dev/sd\n");
#line 52
  printf((char const   */* __restrict  */)"Options:\n");
#line 53
  printf((char const   */* __restrict  */)"    -v, --verbose     - Increase verbosity, multiple uses for higher levels\n");
#line 54
  printf((char const   */* __restrict  */)"    -f, --fix         - Attempt to fix near failures, nothing can be done for unreadable sectors\n");
#line 55
  printf((char const   */* __restrict  */)"    -s, --scan <mode> - Scan in order (seq, random)\n");
#line 56
  printf((char const   */* __restrict  */)"\n");
  }
#line 57
  return (1);
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/diskscan-0.13/cli/cli.c"
void report_scan_success(disk_t *disk___0 , uint64_t offset_bytes , uint64_t data_size ,
                         uint64_t time___0 ) 
{ 


  {
#line 63
  return;
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/diskscan-0.13/cli/cli.c"
void report_scan_error(disk_t *disk___0 , uint64_t offset_bytes , uint64_t data_size ,
                       uint64_t time___0 ) 
{ 


  {
#line 67
  return;
}
}
#line 69 "/home/june/repo/benchmarks/collector/temp/diskscan-0.13/cli/cli.c"
static void print_latency(latency_t *latency_graph , unsigned int latency_graph_len ) 
{ 
  unsigned int i ;
  uint32_t height ;
  uint32_t min_val ;
  uint32_t max_val ;
  uint32_t height_interval ;
  int j ;
  uint32_t max_height ;
  uint32_t med_height ;
  uint32_t min_height ;

  {
#line 73
  height = (uint32_t )30;
#line 74
  min_val = (uint32_t )0;
#line 75
  max_val = (uint32_t )1;
#line 77
  i = 0U;
  {
#line 77
  while (1) {
    while_continue: /* CIL Label */ ;
#line 77
    if (! (i < latency_graph_len)) {
#line 77
      goto while_break;
    }
#line 78
    if (max_val < (latency_graph + i)->latency_max_msec) {
#line 79
      max_val = (latency_graph + i)->latency_max_msec;
    }
#line 77
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 82
  height_interval = ((max_val - min_val) + 1U) / (height - 3U);
#line 83
  if (height_interval == 0U) {
#line 84
    height_interval = (uint32_t )1;
  } else
#line 85
  if (height_interval > 10000U) {
#line 86
    height_interval = (uint32_t )10000;
  }
#line 89
  j = (int )height;
  {
#line 89
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 89
    if (! (j > 0)) {
#line 89
      goto while_break___0;
    }
#line 90
    if (j % 5 == 0) {
      {
#line 91
      printf((char const   */* __restrict  */)"%5u | ", (uint32_t )j * height_interval);
      }
    } else {
      {
#line 93
      printf((char const   */* __restrict  */)"      | ");
      }
    }
#line 95
    i = 0U;
    {
#line 95
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 95
      if (! (i < latency_graph_len)) {
#line 95
        goto while_break___1;
      }
#line 96
      max_height = (latency_graph + i)->latency_max_msec / height_interval + 1U;
#line 97
      med_height = (latency_graph + i)->latency_median_msec / height_interval + 1U;
#line 98
      min_height = (latency_graph + i)->latency_min_msec / height_interval + 1U;
#line 100
      if (max_height == med_height) {
#line 101
        max_height ++;
      }
#line 103
      if (med_height == min_height) {
#line 104
        med_height ++;
#line 105
        if (max_height == med_height) {
#line 106
          max_height ++;
        }
      }
#line 109
      if (max_height != (uint32_t )j) {
#line 109
        if (med_height != (uint32_t )j) {
#line 109
          if (min_height != (uint32_t )j) {
            {
#line 110
            printf((char const   */* __restrict  */)" ");
            }
#line 111
            goto __Cont;
          }
        }
      }
#line 114
      if (max_height == (uint32_t )j) {
        {
#line 115
        printf((char const   */* __restrict  */)"^");
        }
      } else
#line 116
      if (med_height == (uint32_t )j) {
        {
#line 117
        printf((char const   */* __restrict  */)"*");
        }
      } else {
        {
#line 119
        printf((char const   */* __restrict  */)"_");
        }
      }
      __Cont: /* CIL Label */ 
#line 95
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 121
    printf((char const   */* __restrict  */)"\n");
#line 89
    j --;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 123
  printf((char const   */* __restrict  */)"      +-");
#line 124
  i = 0U;
  }
  {
#line 124
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 124
    if (! (i < latency_graph_len)) {
#line 124
      goto while_break___2;
    }
    {
#line 125
    printf((char const   */* __restrict  */)"-");
#line 124
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 127
  printf((char const   */* __restrict  */)"\n");
  }
#line 129
  return;
}
}
#line 131 "/home/june/repo/benchmarks/collector/temp/diskscan-0.13/cli/cli.c"
void report_scan_done(disk_t *disk___0 ) 
{ 
  int hist_idx ;

  {
  {
#line 135
  printf((char const   */* __restrict  */)"Access time histogram:\n");
#line 136
  hist_idx = 0;
  }
  {
#line 136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 136
    if (! ((unsigned long )hist_idx < sizeof(disk___0->histogram) / sizeof(disk___0->histogram[0]))) {
#line 136
      goto while_break;
    }
#line 138
    if ((unsigned long )hist_idx != sizeof(disk___0->histogram) / sizeof(disk___0->histogram[0]) - 1UL) {
      {
#line 139
      printf((char const   */* __restrict  */)"%8lu: %lu\n", histogram_time[hist_idx],
             disk___0->histogram[hist_idx]);
      }
    } else {
      {
#line 141
      printf((char const   */* __restrict  */)"%8s: %lu\n", "above that", disk___0->histogram[hist_idx]);
      }
    }
#line 136
    hist_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 144
  print_latency(disk___0->latency_graph, disk___0->latency_graph_len);
  }
#line 145
  return;
}
}
#line 154
int parse_args(int argc , char **argv , options_t *opts ) ;
#line 154 "/home/june/repo/benchmarks/collector/temp/diskscan-0.13/cli/cli.c"
static struct option long_options[4]  = {      {"verbose", 0, (int *)0, 'v'}, 
        {"fix", 0, (int *)0, 'f'}, 
        {"scan", 1, (int *)0, 's'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 147 "/home/june/repo/benchmarks/collector/temp/diskscan-0.13/cli/cli.c"
int parse_args(int argc , char **argv , options_t *opts ) 
{ 
  int c ;
  int unknown ;
  int option_index ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 150
  unknown = 0;
  {
#line 152
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 153
    option_index = 0;
#line 161
    c = getopt_long(argc, (char * const  *)argv, "vfs:", (struct option  const  *)(long_options),
                    & option_index);
    }
#line 162
    if (c == -1) {
#line 163
      goto while_break;
    }
    {
#line 166
    if (c == 0) {
#line 166
      goto case_0;
    }
#line 169
    if (c == 118) {
#line 169
      goto case_118;
    }
#line 172
    if (c == 102) {
#line 172
      goto case_102;
    }
#line 175
    if (c == 115) {
#line 175
      goto case_115;
    }
#line 183
    goto switch_default;
    case_0: /* CIL Label */ 
#line 167
    goto switch_break;
    case_118: /* CIL Label */ 
#line 170
    (opts->verbose) ++;
#line 171
    goto switch_break;
    case_102: /* CIL Label */ 
#line 173
    opts->fix = 1;
#line 174
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 176
    opts->mode = str_to_scan_mode((char const   *)optarg);
    }
#line 177
    if ((unsigned int )opts->mode == 0U) {
      {
#line 178
      opts->mode = (enum scan_mode )1;
#line 179
      printf((char const   */* __restrict  */)"Unknown scan mode %s given, using sequential\n",
             optarg);
      }
    }
#line 181
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 184
    unknown = 1;
#line 185
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 189
  if (optind == argc) {
    {
#line 190
    printf((char const   */* __restrict  */)"No disk path provided to scan!\n");
#line 191
    tmp = usage();
    }
#line 191
    return (tmp);
  }
#line 193
  if (optind < argc - 1) {
    {
#line 194
    printf((char const   */* __restrict  */)"Too many disk paths provided to scan, can only scan one disk!\n");
#line 195
    tmp___0 = usage();
    }
#line 195
    return (tmp___0);
  }
#line 198
  if (unknown) {
    {
#line 199
    printf((char const   */* __restrict  */)"Unknown option provided");
#line 200
    tmp___1 = usage();
    }
#line 200
    return (tmp___1);
  }
#line 203
  opts->disk_path = *(argv + optind);
#line 204
  return (0);
}
}
#line 207 "/home/june/repo/benchmarks/collector/temp/diskscan-0.13/cli/cli.c"
int print_disk_info(disk_t *disk___0 ) 
{ 


  {
#line 209
  return (0);
}
}
#line 212 "/home/june/repo/benchmarks/collector/temp/diskscan-0.13/cli/cli.c"
static void diskscan_cli_signal(int signal___0 ) 
{ 


  {
  {
#line 214
  disk_scan_stop(& disk);
  }
#line 215
  return;
}
}
#line 217 "/home/june/repo/benchmarks/collector/temp/diskscan-0.13/cli/cli.c"
static void setup_signals(void) 
{ 
  struct sigaction act ;

  {
  {
#line 219
  act.__sigaction_handler.sa_handler = & diskscan_cli_signal;
#line 219
  act.sa_mask.__val[0] = 0UL;
#line 219
  act.sa_mask.__val[1] = 0UL;
#line 219
  act.sa_mask.__val[2] = 0UL;
#line 219
  act.sa_mask.__val[3] = 0UL;
#line 219
  act.sa_mask.__val[4] = 0UL;
#line 219
  act.sa_mask.__val[5] = 0UL;
#line 219
  act.sa_mask.__val[6] = 0UL;
#line 219
  act.sa_mask.__val[7] = 0UL;
#line 219
  act.sa_mask.__val[8] = 0UL;
#line 219
  act.sa_mask.__val[9] = 0UL;
#line 219
  act.sa_mask.__val[10] = 0UL;
#line 219
  act.sa_mask.__val[11] = 0UL;
#line 219
  act.sa_mask.__val[12] = 0UL;
#line 219
  act.sa_mask.__val[13] = 0UL;
#line 219
  act.sa_mask.__val[14] = 0UL;
#line 219
  act.sa_mask.__val[15] = 0UL;
#line 219
  act.sa_flags = 268435456;
#line 219
  act.sa_restorer = (void (*)(void))0;
#line 224
  sigaction(2, (struct sigaction  const  */* __restrict  */)(& act), (struct sigaction */* __restrict  */)((void *)0));
#line 225
  sigaction(15, (struct sigaction  const  */* __restrict  */)(& act), (struct sigaction */* __restrict  */)((void *)0));
  }
#line 226
  return;
}
}
#line 228 "/home/june/repo/benchmarks/collector/temp/diskscan-0.13/cli/cli.c"
int diskscan_cli(int argc , char **argv ) 
{ 
  options_t opts ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 230
  opts.disk_path = (char *)0;
#line 230
  opts.verbose = 0;
#line 230
  opts.fix = 0;
#line 230
  opts.mode = 0U;
#line 232
  tmp = parse_args(argc, argv, & opts);
  }
#line 232
  if (tmp) {
#line 233
    return (1);
  }
  {
#line 234
  verbose = opts.verbose;
#line 236
  print_header();
#line 238
  setup_signals();
#line 240
  tmp___0 = disk_open(& disk, (char const   *)opts.disk_path, opts.fix, 70U);
  }
#line 240
  if (tmp___0) {
#line 241
    return (1);
  }
  {
#line 243
  tmp___1 = print_disk_info(& disk);
  }
#line 243
  if (tmp___1) {
#line 244
    return (1);
  }
  {
#line 246
  tmp___2 = disk_scan(& disk, opts.mode);
  }
#line 246
  if (tmp___2) {
#line 247
    return (1);
  }
  {
#line 249
  disk_close(& disk);
  }
#line 250
  return (0);
}
}
#line 4 "/home/june/repo/benchmarks/collector/temp/diskscan-0.13/include/version.h"
char *COMMIT ;
#line 6
char *DATE ;
#line 2 "/home/june/repo/benchmarks/collector/temp/diskscan-0.13/version/version.c"
char *COMMIT  =    (char *)"1104c45d54254d7d9b35acbe53d2213f43a4f65e";
#line 3 "/home/june/repo/benchmarks/collector/temp/diskscan-0.13/version/version.c"
char *TAG  =    (char *)"unknown-1104c45";
#line 4 "/home/june/repo/benchmarks/collector/temp/diskscan-0.13/version/version.c"
char *DATE  =    (char *)"2013-10-07";
#line 4 "/home/june/repo/benchmarks/collector/temp/diskscan-0.13/include/verbose.h"
int verbose  ;
#line 23 "/home/june/repo/benchmarks/collector/temp/diskscan-0.13/diskscan.c"
int main(int argc , char **argv ) 
{ 
  int tmp ;

  {
  {
#line 25
  tmp = diskscan_cli(argc, argv);
  }
#line 25
  return (tmp);
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/diskscan-0.13/include/diskscan.h"
static uint64_t const   histogram_time___0[19] ;
#line 8 "/home/june/repo/benchmarks/collector/temp/diskscan-0.13/include/diskscan.h"
static uint64_t const   histogram_time___0[19]  = 
#line 8
  {      (uint64_t const   )1,      (uint64_t const   )10,      (uint64_t const   )100,      (uint64_t const   )500, 
        (uint64_t const   )1000,      (uint64_t const   )2000,      (uint64_t const   )3000,      (uint64_t const   )4000, 
        (uint64_t const   )5000,      (uint64_t const   )6000,      (uint64_t const   )7000,      (uint64_t const   )8000, 
        (uint64_t const   )9000,      (uint64_t const   )10000,      (uint64_t const   )15000,      (uint64_t const   )20000, 
        (uint64_t const   )25000,      (uint64_t const   )30000,      (uint64_t const   )0xffffffffffffffffUL};
#line 6 "/home/june/repo/benchmarks/collector/temp/diskscan-0.13/include/arch.h"
int get_block_device_size(int fd , uint64_t *size_bytes , uint64_t *sector_size ) ;
#line 36 "/home/june/repo/benchmarks/collector/temp/diskscan-0.13/include/median.h"
static uint32_t kth_smallest(uint32_t *a , int n , int k ) 
{ 
  register int i ;
  register int j ;
  register int l ;
  register int m ;
  register uint32_t x ;
  register uint32_t t ;

  {
#line 41
  l = 0;
#line 41
  m = n - 1;
  {
#line 42
  while (1) {
    while_continue: /* CIL Label */ ;
#line 42
    if (! (l < m)) {
#line 42
      goto while_break;
    }
#line 43
    x = *(a + k);
#line 44
    i = l;
#line 45
    j = m;
    {
#line 46
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 47
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 47
        if (! (*(a + i) < x)) {
#line 47
          goto while_break___1;
        }
#line 47
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 48
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 48
        if (! (x < *(a + j))) {
#line 48
          goto while_break___2;
        }
#line 48
        j --;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 49
      if (i <= j) {
#line 50
        t = *(a + i);
#line 50
        *(a + i) = *(a + j);
#line 50
        *(a + j) = t;
#line 51
        i ++;
#line 51
        j --;
      }
#line 46
      if (! (i <= j)) {
#line 46
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 54
    if (j < k) {
#line 54
      l = i;
    }
#line 55
    if (k < i) {
#line 55
      m = j;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 57
  return (*(a + k));
}
}
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 374 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rand)(void) ;
#line 376
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srand)(unsigned int __seed ) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 515
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 287 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *__name ,
                                                                                             int __type ) ;
#line 353
extern int close(int __fd ) ;
#line 388
extern ssize_t pread(int __fd , void *__buf , size_t __nbytes , __off64_t __offset )  __asm__("pread64")  ;
#line 391
extern ssize_t pwrite(int __fd , void const   *__buf , size_t __nbytes , __off64_t __offset )  __asm__("pwrite64")  ;
#line 149 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...)  __asm__("open64")  ;
#line 61 "/usr/include/x86_64-linux-gnu/sys/mman.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) mmap)(void *__addr ,
                                                                             size_t __len ,
                                                                             int __prot ,
                                                                             int __flags ,
                                                                             int __fd ,
                                                                             __off64_t __offset )  __asm__("mmap64")  ;
#line 76
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) munmap)(void *__addr ,
                                                                             size_t __len ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 342
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) clock_gettime)(clockid_t __clock_id ,
                                                                                    struct timespec *__tp ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 46 "/home/june/repo/benchmarks/collector/temp/diskscan-0.13/lib/diskscan.c"
enum scan_mode str_to_scan_mode(char const   *s ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 48
  tmp = strcasecmp(s, "seq");
  }
#line 48
  if (tmp == 0) {
#line 49
    return ((enum scan_mode )1);
  } else {
    {
#line 48
    tmp___0 = strcasecmp(s, "sequential");
    }
#line 48
    if (tmp___0 == 0) {
#line 49
      return ((enum scan_mode )1);
    }
  }
  {
#line 50
  tmp___1 = strcasecmp(s, "random");
  }
#line 50
  if (tmp___1 == 0) {
#line 51
    return ((enum scan_mode )2);
  }
#line 52
  return ((enum scan_mode )0);
}
}
#line 55 "/home/june/repo/benchmarks/collector/temp/diskscan-0.13/lib/diskscan.c"
int disk_open(disk_t *disk___0 , char const   *path , int fix , unsigned int latency_graph_len ) 
{ 
  int tmp ;
  int access_mode_flag ;
  int tmp___0 ;
  int tmp___1 ;
  int open_mode_flag ;
  int tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;

  {
  {
#line 57
  memset((void *)disk___0, 0, sizeof(*disk___0));
#line 59
  verbose_out("I: Validating path %s", path);
#line 60
  tmp = access(path, 0);
  }
#line 60
  if (tmp) {
    {
#line 61
    verbose_out("E: Disk path %s does not exist: %m", path);
    }
#line 62
    return (1);
  }
#line 65
  if (fix) {
#line 65
    tmp___0 = 6;
  } else {
#line 65
    tmp___0 = 4;
  }
  {
#line 65
  access_mode_flag = tmp___0;
#line 66
  tmp___1 = access(path, access_mode_flag);
  }
#line 66
  if (tmp___1) {
    {
#line 67
    verbose_out("E: Disk path %s is inaccessible: %m", path);
    }
#line 68
    return (1);
  }
#line 71
  if (fix) {
#line 71
    tmp___2 = 2;
  } else {
#line 71
    tmp___2 = 0;
  }
  {
#line 71
  open_mode_flag = tmp___2;
#line 72
  disk___0->fd = open(path, open_mode_flag | 16384);
  }
#line 73
  if (disk___0->fd < 0) {
    {
#line 74
    verbose_out("E: Failed to open path %s: %m", path);
    }
#line 75
    return (1);
  }
  {
#line 78
  tmp___3 = get_block_device_size(disk___0->fd, & disk___0->num_bytes, & disk___0->sector_size);
  }
#line 78
  if (tmp___3 < 0) {
    {
#line 79
    verbose_out("E: Can\'t get block device size information for path %s: %m", path);
    }
#line 80
    goto Error;
  }
#line 83
  if (disk___0->num_bytes == 0UL) {
    {
#line 84
    verbose_out("E: Invalid number of sectors");
    }
#line 85
    goto Error;
  }
#line 88
  if (disk___0->sector_size == 0UL) {
    {
#line 89
    verbose_out("E: Invalid sector size %d", disk___0->sector_size);
    }
#line 90
    goto Error;
  } else
#line 88
  if (disk___0->sector_size % 512UL != 0UL) {
    {
#line 89
    verbose_out("E: Invalid sector size %d", disk___0->sector_size);
    }
#line 90
    goto Error;
  }
  {
#line 100
  strncpy((char */* __restrict  */)(disk___0->path), (char const   */* __restrict  */)path,
          sizeof(disk___0->path));
#line 101
  disk___0->path[sizeof(disk___0->path) - 1UL] = (char)0;
#line 103
  disk___0->latency_graph_len = latency_graph_len;
#line 104
  tmp___4 = calloc((size_t )latency_graph_len, sizeof(latency_t ));
#line 104
  disk___0->latency_graph = (latency_t *)tmp___4;
  }
#line 105
  if ((unsigned long )disk___0->latency_graph == (unsigned long )((void *)0)) {
    {
#line 106
    verbose_out("E: Failed to allocate memory for latency graph data");
    }
#line 107
    goto Error;
  }
  {
#line 110
  verbose_out("I: Opened disk %s sector size %u num bytes %llu", path, disk___0->sector_size,
              disk___0->num_bytes);
  }
#line 111
  return (0);
  Error: 
  {
#line 114
  disk_close(disk___0);
  }
#line 115
  return (1);
}
}
#line 118 "/home/june/repo/benchmarks/collector/temp/diskscan-0.13/lib/diskscan.c"
int disk_close(disk_t *disk___0 ) 
{ 


  {
  {
#line 120
  verbose_out("I: Closed disk %s", disk___0->path);
#line 121
  close(disk___0->fd);
#line 122
  disk___0->fd = -1;
  }
#line 123
  if (disk___0->latency_graph) {
    {
#line 124
    free((void *)disk___0->latency_graph);
#line 125
    disk___0->latency_graph = (latency_t *)((void *)0);
    }
  }
#line 127
  return (0);
}
}
#line 130 "/home/june/repo/benchmarks/collector/temp/diskscan-0.13/lib/diskscan.c"
void disk_scan_stop(disk_t *disk___0 ) 
{ 


  {
#line 132
  disk___0->run = 0;
#line 133
  return;
}
}
#line 135 "/home/june/repo/benchmarks/collector/temp/diskscan-0.13/lib/diskscan.c"
static int decide_buffer_size(disk_t *disk___0 ) 
{ 


  {
#line 138
  return (65536);
}
}
#line 141 "/home/june/repo/benchmarks/collector/temp/diskscan-0.13/lib/diskscan.c"
static void *allocate_buffer(int buf_size ) 
{ 
  void *buf ;
  void *tmp ;

  {
  {
#line 143
  tmp = mmap((void *)0, (size_t )buf_size, 3, 34, -1, (__off64_t )0);
#line 143
  buf = tmp;
  }
#line 144
  if (! buf) {
#line 145
    return ((void *)0);
  }
#line 147
  return (buf);
}
}
#line 150 "/home/june/repo/benchmarks/collector/temp/diskscan-0.13/lib/diskscan.c"
static void free_buffer(void *buf , int buf_size ) 
{ 


  {
  {
#line 152
  munmap(buf, (size_t )buf_size);
  }
#line 153
  return;
}
}
#line 155 "/home/june/repo/benchmarks/collector/temp/diskscan-0.13/lib/diskscan.c"
static void latency_bucket_prepare(disk_t *disk___0 , struct scan_state *state , uint64_t offset ) 
{ 
  latency_t *l ;
  uint64_t start_sector ;

  {
#line 157
  if (! (state->latency_bucket < disk___0->latency_graph_len)) {
    {
#line 157
    __assert_fail("state->latency_bucket < disk->latency_graph_len", "/home/june/repo/benchmarks/collector/temp/diskscan-0.13/lib/diskscan.c",
                  157U, "latency_bucket_prepare");
    }
  }
#line 158
  l = disk___0->latency_graph + state->latency_bucket;
#line 159
  start_sector = offset / disk___0->sector_size;
#line 161
  if (verbose > 1) {
    {
#line 161
    verbose_out("V: bucket prepare bucket=%u", state->latency_bucket);
    }
  }
#line 163
  l->start_sector = start_sector;
#line 164
  l->latency_min_msec = 4294967295U;
#line 165
  state->latency_count = (uint32_t )0;
#line 166
  return;
}
}
#line 168 "/home/june/repo/benchmarks/collector/temp/diskscan-0.13/lib/diskscan.c"
static void latency_bucket_finish(disk_t *disk___0 , struct scan_state *state , uint64_t offset ) 
{ 
  latency_t *l ;
  uint64_t end_sector ;
  uint32_t tmp ;

  {
#line 170
  l = disk___0->latency_graph + state->latency_bucket;
#line 171
  end_sector = offset / disk___0->sector_size;
#line 173
  if (verbose > 1) {
    {
#line 173
    verbose_out("V: bucket finish bucket=%d", state->latency_bucket);
    }
  }
#line 175
  l->end_sector = end_sector;
#line 176
  if (state->latency_count & 1U) {
#line 176
    tmp = state->latency_count / 2U;
  } else {
#line 176
    tmp = state->latency_count / 2U - 1U;
  }
  {
#line 176
  l->latency_median_msec = kth_smallest(state->latency, (int )state->latency_count,
                                        (int )tmp);
#line 178
  state->latency_count = (uint32_t )0;
#line 179
  (state->latency_bucket) ++;
  }
#line 180
  return;
}
}
#line 182 "/home/june/repo/benchmarks/collector/temp/diskscan-0.13/lib/diskscan.c"
static void latency_bucket_add(disk_t *disk___0 , uint64_t latency , struct scan_state *state ) 
{ 
  latency_t *l ;
  uint32_t tmp ;

  {
#line 184
  l = disk___0->latency_graph + state->latency_bucket;
#line 186
  if (latency < (uint64_t )l->latency_min_msec) {
#line 187
    l->latency_min_msec = (uint32_t )latency;
  }
#line 188
  if ((uint64_t )l->latency_max_msec < latency) {
#line 189
    l->latency_max_msec = (uint32_t )latency;
  }
#line 192
  tmp = state->latency_count;
#line 192
  (state->latency_count) ++;
#line 192
  *(state->latency + tmp) = (uint32_t )latency;
#line 193
  return;
}
}
#line 195 "/home/june/repo/benchmarks/collector/temp/diskscan-0.13/lib/diskscan.c"
static void disk_scan_part(disk_t *disk___0 , uint64_t offset , void *data , int data_size ,
                           struct scan_state *state ) 
{ 
  ssize_t ret ;
  struct timespec t_start ;
  struct timespec t_end ;
  uint64_t t ;
  int s_errno ;
  int *tmp ;
  uint64_t t_msec ;
  int hist_idx ;
  int *tmp___0 ;

  {
  {
#line 202
  clock_gettime(1, & t_start);
#line 203
  ret = pread(disk___0->fd, data, (size_t )data_size, (__off64_t )offset);
#line 204
  clock_gettime(1, & t_end);
#line 206
  t = (uint64_t )(((t_end.tv_sec - t_start.tv_sec) * 1000000000L + t_end.tv_nsec) - t_start.tv_nsec);
  }
#line 209
  if (ret != (ssize_t )data_size) {
    {
#line 210
    tmp = __errno_location();
#line 210
    s_errno = *tmp;
#line 211
    verbose_out("E: Error when reading at offset %lu size %d read %d: %m", offset,
                data_size, ret);
#line 212
    report_scan_error(disk___0, offset, (uint64_t )data_size, t);
#line 213
    (disk___0->num_errors) ++;
    }
#line 215
    if (s_errno != 5) {
      {
#line 216
      abort();
      }
    }
  } else {
    {
#line 219
    report_scan_success(disk___0, offset, (uint64_t )data_size, t);
    }
  }
#line 222
  t_msec = t / 1000000UL;
#line 223
  hist_idx = 0;
  {
#line 224
  while (1) {
    while_continue: /* CIL Label */ ;
#line 224
    if (t_msec >= (uint64_t )histogram_time___0[hist_idx]) {
#line 224
      if (! ((unsigned long )hist_idx < sizeof(disk___0->histogram) / sizeof(disk___0->histogram[0]) - 1UL)) {
#line 224
        goto while_break;
      }
    } else {
#line 224
      goto while_break;
    }
#line 225
    hist_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 227
  (disk___0->histogram[hist_idx]) ++;
#line 229
  latency_bucket_add(disk___0, t_msec, state);
  }
#line 231
  if (t_msec > 1000UL) {
#line 232
    if (verbose > 0) {
      {
#line 232
      verbose_out("V: Scanning at offset %lu took %llu msec", offset, t_msec);
      }
    }
  }
#line 235
  if (t_msec > 3000UL) {
    {
#line 236
    verbose_out("I: Fixing region by rewriting, offset=%d size=%d", offset, data_size);
#line 237
    ret = pwrite(disk___0->fd, (void const   *)data, (size_t )data_size, (__off64_t )offset);
    }
#line 238
    if (ret != 0L) {
      {
#line 239
      tmp___0 = __errno_location();
#line 239
      verbose_out("E: Error while attempting to rewrite the data! errno=%d: %m", *tmp___0);
      }
    }
  }
#line 242
  return;
}
}
#line 244 "/home/june/repo/benchmarks/collector/temp/diskscan-0.13/lib/diskscan.c"
static uint64_t calc_latency_stride(disk_t *disk___0 ) 
{ 
  uint64_t num_sectors ;
  uint64_t stride_size ;

  {
#line 246
  num_sectors = disk___0->num_bytes / disk___0->sector_size;
#line 247
  stride_size = num_sectors / (uint64_t )disk___0->latency_graph_len;
#line 251
  return (stride_size + 1UL);
}
}
#line 254 "/home/june/repo/benchmarks/collector/temp/diskscan-0.13/lib/diskscan.c"
static uint32_t *calc_scan_order_seq(disk_t *disk___0 , uint64_t stride_size , int read_size_sectors ) 
{ 
  uint64_t num_reads ;
  uint32_t *order ;
  void *tmp ;
  uint64_t i ;

  {
  {
#line 256
  num_reads = stride_size / (uint64_t )read_size_sectors + 2UL;
#line 257
  tmp = malloc(sizeof(uint32_t ) * num_reads);
#line 257
  order = (uint32_t *)tmp;
#line 260
  i = (uint64_t )0;
  }
  {
#line 260
  while (1) {
    while_continue: /* CIL Label */ ;
#line 260
    if (! (i < num_reads)) {
#line 260
      goto while_break;
    }
#line 261
    *(order + i) = (uint32_t )((i * (uint64_t )read_size_sectors) * disk___0->sector_size);
#line 260
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 262
  *(order + i) = 4294967295U;
#line 264
  return (order);
}
}
#line 267 "/home/june/repo/benchmarks/collector/temp/diskscan-0.13/lib/diskscan.c"
static uint32_t *calc_scan_order_random(disk_t *disk___0 , uint64_t stride_size ,
                                        int read_size_sectors ) 
{ 
  uint64_t num_reads ;
  uint32_t *order ;
  void *tmp ;
  uint64_t i ;
  time_t tmp___0 ;
  int j ;
  int tmp___1 ;
  uint32_t tmp___2 ;

  {
  {
#line 269
  num_reads = stride_size / (uint64_t )read_size_sectors + 2UL;
#line 270
  tmp = malloc(sizeof(uint32_t ) * num_reads);
#line 270
  order = (uint32_t *)tmp;
#line 274
  i = (uint64_t )0;
  }
  {
#line 274
  while (1) {
    while_continue: /* CIL Label */ ;
#line 274
    if (! (i < num_reads - 1UL)) {
#line 274
      goto while_break;
    }
#line 275
    *(order + i) = (uint32_t )((i * (uint64_t )read_size_sectors) * disk___0->sector_size);
#line 274
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 276
  *(order + i) = 4294967295U;
#line 279
  tmp___0 = time((time_t *)((void *)0));
#line 279
  srand((unsigned int )tmp___0);
#line 280
  i = (uint64_t )0;
  }
  {
#line 280
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 280
    if (! (i < num_reads - 1UL)) {
#line 280
      goto while_break___0;
    }
    {
#line 281
    tmp___1 = rand();
#line 281
    j = (int )((unsigned long )tmp___1 % num_reads);
    }
#line 282
    if (i == (uint64_t )j) {
#line 283
      goto __Cont;
    }
#line 285
    tmp___2 = *(order + i);
#line 286
    *(order + i) = *(order + j);
#line 287
    *(order + j) = tmp___2;
    __Cont: /* CIL Label */ 
#line 280
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 290
  return (order);
}
}
#line 293 "/home/june/repo/benchmarks/collector/temp/diskscan-0.13/lib/diskscan.c"
static uint32_t *calc_scan_order(disk_t *disk___0 , enum scan_mode mode , uint64_t stride_size ,
                                 int read_size ) 
{ 
  int read_size_sectors ;
  uint32_t *tmp ;
  uint32_t *tmp___0 ;

  {
#line 295
  read_size_sectors = (int )((uint64_t )read_size / disk___0->sector_size);
#line 297
  if ((unsigned int )mode == 1U) {
    {
#line 298
    tmp = calc_scan_order_seq(disk___0, stride_size, read_size_sectors);
    }
#line 298
    return (tmp);
  } else
#line 299
  if ((unsigned int )mode == 2U) {
    {
#line 300
    tmp___0 = calc_scan_order_random(disk___0, stride_size, read_size_sectors);
    }
#line 300
    return (tmp___0);
  } else {
#line 302
    return ((uint32_t *)((void *)0));
  }
}
}
#line 305 "/home/june/repo/benchmarks/collector/temp/diskscan-0.13/lib/diskscan.c"
static void disk_scan_latency_stride(disk_t *disk___0 , struct scan_state *state ,
                                     uint64_t base_offset , uint64_t data_size , uint32_t *scan_order ) 
{ 
  unsigned int i ;
  uint64_t offset ;
  uint64_t remainder ;

  {
#line 309
  i = 0U;
  {
#line 309
  while (1) {
    while_continue: /* CIL Label */ ;
#line 309
    if (disk___0->run) {
#line 309
      if (! (*(scan_order + i) != 4294967295U)) {
#line 309
        goto while_break;
      }
    } else {
#line 309
      goto while_break;
    }
#line 310
    offset = base_offset + (uint64_t )*(scan_order + i);
#line 311
    if (verbose > 2) {
      {
#line 311
      verbose_out("V: Scanning at offset %llu index %u", offset, i);
      }
    }
#line 312
    remainder = (base_offset + state->latency_stride * disk___0->sector_size) - offset;
#line 313
    if (remainder < data_size) {
#line 314
      data_size = remainder;
#line 315
      if (verbose > 0) {
        {
#line 315
        verbose_out("V: Last part scanning size %d", data_size);
        }
      }
    }
    {
#line 317
    disk_scan_part(disk___0, offset, state->data, (int )data_size, state);
#line 309
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 319
  return;
}
}
#line 321 "/home/june/repo/benchmarks/collector/temp/diskscan-0.13/lib/diskscan.c"
int disk_scan(disk_t *disk___0 , enum scan_mode mode ) 
{ 
  int data_size ;
  int tmp ;
  void *data ;
  void *tmp___0 ;
  uint32_t *scan_order ;
  int result ;
  struct scan_state state ;
  uint64_t offset ;
  uint64_t disk_size_bytes ;
  uint64_t latency_stride ;
  uint64_t tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 323
  verbose_out("I: Scanning disk %s", disk___0->path);
#line 324
  disk___0->run = 1;
#line 325
  tmp = decide_buffer_size(disk___0);
#line 325
  data_size = tmp;
#line 326
  tmp___0 = allocate_buffer(data_size);
#line 326
  data = tmp___0;
#line 327
  scan_order = (uint32_t *)((void *)0);
#line 328
  result = 0;
#line 329
  state.latency_bucket = 0U;
#line 329
  state.latency_stride = 0UL;
#line 329
  state.latency_count = 0U;
#line 329
  state.latency = (uint32_t *)((void *)0);
#line 329
  state.data = (void *)0;
  }
#line 331
  if (verbose > 2) {
    {
#line 331
    verbose_out("V: Using buffer of size %d", data_size);
    }
  }
#line 333
  if ((unsigned long )data == (unsigned long )((void *)0)) {
    {
#line 334
    verbose_out("E: Failed to allocate data buffer: %m");
#line 335
    result = 1;
    }
#line 336
    goto Exit;
  }
  {
#line 340
  disk_size_bytes = disk___0->num_bytes;
#line 341
  tmp___1 = calc_latency_stride(disk___0);
#line 341
  latency_stride = tmp___1;
  }
#line 342
  if (verbose > 1) {
    {
#line 342
    verbose_out("V: latency stride is %llu", latency_stride);
    }
  }
  {
#line 344
  state.latency_bucket = (uint32_t )0;
#line 345
  state.latency_stride = latency_stride;
#line 346
  state.latency_count = (uint32_t )0;
#line 347
  tmp___2 = malloc(sizeof(uint32_t ) * latency_stride);
#line 347
  state.latency = (uint32_t *)tmp___2;
#line 348
  state.data = data;
#line 350
  scan_order = calc_scan_order(disk___0, mode, latency_stride, data_size);
  }
#line 351
  if (! scan_order) {
    {
#line 352
    result = 1;
#line 353
    verbose_out("E: Failed to generate scan order");
    }
#line 354
    goto Exit;
  }
#line 357
  offset = (uint64_t )0;
  {
#line 357
  while (1) {
    while_continue: /* CIL Label */ ;
#line 357
    if (disk___0->run) {
#line 357
      if (! (offset < disk_size_bytes)) {
#line 357
        goto while_break;
      }
    } else {
#line 357
      goto while_break;
    }
#line 358
    if (verbose > 1) {
      {
#line 358
      verbose_out("V: Scanning stride starting at %llu", offset);
      }
    }
    {
#line 359
    latency_bucket_prepare(disk___0, & state, offset);
#line 360
    disk_scan_latency_stride(disk___0, & state, offset, (uint64_t )data_size, scan_order);
#line 361
    latency_bucket_finish(disk___0, & state, offset + latency_stride * disk___0->sector_size);
#line 357
    offset += latency_stride * disk___0->sector_size;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 364
  if (! disk___0->run) {
    {
#line 365
    verbose_out("I: Disk scan interrupted");
    }
  }
  {
#line 367
  report_scan_done(disk___0);
  }
  Exit: 
  {
#line 370
  free((void *)scan_order);
#line 371
  free_buffer(data, data_size);
#line 372
  free((void *)state.latency);
#line 373
  disk___0->run = 0;
  }
#line 374
  return (result);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 377 "/usr/include/stdio.h"
extern int vprintf(char const   * __restrict  __format , __gnuc_va_list __arg ) ;
#line 25 "/home/june/repo/benchmarks/collector/temp/diskscan-0.13/cli/verbose.c"
void verbose_out(char const   *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 28
  __builtin_va_start(ap, fmt);
#line 29
  vprintf((char const   */* __restrict  */)fmt, ap);
#line 30
  __builtin_va_end(ap);
#line 31
  printf((char const   */* __restrict  */)"\n");
  }
#line 32
  return;
}
}
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 7 "/home/june/repo/benchmarks/collector/temp/diskscan-0.13/arch/arch.c"
int get_block_device_size(int fd , uint64_t *size_bytes , uint64_t *sector_size ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 9
  tmp = ioctl(fd, (unsigned long )(((2U << 30) | (unsigned int )(18 << 8)) | 114U) | (sizeof(size_t ) << 16),
              size_bytes);
  }
#line 9
  if (tmp < 0) {
#line 10
    return (-1);
  }
  {
#line 13
  tmp___0 = ioctl(fd, (unsigned long )((unsigned int )(18 << 8) | 104U), sector_size);
  }
#line 13
  if (tmp___0 < 0) {
#line 14
    return (-1);
  }
#line 17
  return (0);
}
}
