/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 152 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned int uint;
#line 39 "/home/june/collector/temp/bmf-0.9.4/config.h"
typedef char const   *cpchar;
#line 42
enum __anonenum_bool_t_31 {
    false = 0,
    true = 1
} ;
#line 42 "/home/june/collector/temp/bmf-0.9.4/config.h"
typedef enum __anonenum_bool_t_31 bool_t;
#line 49
enum __anonenum_mbox_t_32 {
    detect = 0,
    mbox = 1,
    maildir = 2
} ;
#line 49 "/home/june/collector/temp/bmf-0.9.4/config.h"
typedef enum __anonenum_mbox_t_32 mbox_t;
#line 18 "/home/june/collector/temp/bmf-0.9.4/str.h"
struct _str {
   char *p ;
   uint len ;
};
#line 18 "/home/june/collector/temp/bmf-0.9.4/str.h"
typedef struct _str str_t;
#line 13 "/home/june/collector/temp/bmf-0.9.4/lex.h"
enum __anonenum_toktype_t_33 {
    from = 0,
    eof = 1,
    word = 2
} ;
#line 13 "/home/june/collector/temp/bmf-0.9.4/lex.h"
typedef enum __anonenum_toktype_t_33 toktype_t;
#line 15 "/home/june/collector/temp/bmf-0.9.4/lex.h"
struct _tok {
   toktype_t tt ;
   char *p ;
   uint len ;
};
#line 15 "/home/june/collector/temp/bmf-0.9.4/lex.h"
typedef struct _tok tok_t;
#line 22
enum __anonenum_msgsec_t_34 {
    envelope = 0,
    hdrs = 1,
    body = 2
} ;
#line 22 "/home/june/collector/temp/bmf-0.9.4/lex.h"
typedef enum __anonenum_msgsec_t_34 msgsec_t;
#line 24 "/home/june/collector/temp/bmf-0.9.4/lex.h"
struct _lex {
   mbox_t mboxtype ;
   msgsec_t section ;
   uint pos ;
   uint bom ;
   uint eom ;
   uint lineend ;
   uint buflen ;
   char *pbuf ;
};
#line 24 "/home/june/collector/temp/bmf-0.9.4/lex.h"
typedef struct _lex lex_t;
#line 16 "/home/june/collector/temp/bmf-0.9.4/vec.h"
struct _vec {
   uint nalloc ;
   uint nitems ;
   str_t *pitems ;
};
#line 16 "/home/june/collector/temp/bmf-0.9.4/vec.h"
typedef struct _vec vec_t;
#line 23 "/home/june/collector/temp/bmf-0.9.4/vec.h"
struct _veciter {
   struct _vec *plist ;
   uint index ;
};
#line 23 "/home/june/collector/temp/bmf-0.9.4/vec.h"
typedef struct _veciter veciter_t;
#line 29 "/home/june/collector/temp/bmf-0.9.4/dbh.h"
struct _dbt;
#line 29 "/home/june/collector/temp/bmf-0.9.4/dbh.h"
typedef struct _dbt dbt_t;
#line 30 "/home/june/collector/temp/bmf-0.9.4/dbh.h"
struct _dbt {
   bool_t (*close)(dbt_t * ) ;
   bool_t (*mergeclose)(dbt_t * , vec_t * ) ;
   bool_t (*unmergeclose)(dbt_t * , vec_t * ) ;
   bool_t (*import)(dbt_t * , cpchar  ) ;
   bool_t (*export)(dbt_t * , cpchar  ) ;
   uint (*getmsgcount)(dbt_t * ) ;
   uint (*getcount)(dbt_t * , str_t * ) ;
};
#line 13 "/home/june/collector/temp/bmf-0.9.4/filt.h"
struct __anonstruct_discrim_t_36 {
   str_t key ;
   double prob ;
};
#line 13 "/home/june/collector/temp/bmf-0.9.4/filt.h"
typedef struct __anonstruct_discrim_t_36 discrim_t;
#line 19 "/home/june/collector/temp/bmf-0.9.4/filt.h"
struct __anonstruct_stats_t_37 {
   double spamicity ;
   uint keepers ;
   discrim_t *extrema ;
};
#line 19 "/home/june/collector/temp/bmf-0.9.4/filt.h"
typedef struct __anonstruct_stats_t_37 stats_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 14 "/home/june/collector/temp/bmf-0.9.4/dbh.h"
enum __anonenum_dbfmt_t_35 {
    db_text = 0,
    db_db = 1,
    db_mysql = 2
} ;
#line 14 "/home/june/collector/temp/bmf-0.9.4/dbh.h"
typedef enum __anonenum_dbfmt_t_35 dbfmt_t;
#line 42
struct _dbh;
#line 42 "/home/june/collector/temp/bmf-0.9.4/dbh.h"
typedef struct _dbh dbh_t;
#line 43 "/home/june/collector/temp/bmf-0.9.4/dbh.h"
struct _dbh {
   bool_t (*close)(dbh_t * ) ;
   dbt_t *(*opentable)(dbh_t * , cpchar  , bool_t  ) ;
};
#line 21 "/home/june/collector/temp/bmf-0.9.4/bmf.c"
enum __anonenum_runmode_t_38 {
    mode_test = 0,
    mode_normal = 1,
    mode_reg_s = 2,
    mode_reg_n = 3,
    mode_n_to_s = 4,
    mode_s_to_n = 5
} ;
#line 21 "/home/june/collector/temp/bmf-0.9.4/bmf.c"
typedef enum __anonenum_runmode_t_38 runmode_t;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 35 "/usr/include/x86_64-linux-gnu/bits/fcntl.h"
struct flock {
   short l_type ;
   short l_whence ;
   __off_t l_start ;
   __off_t l_len ;
   __pid_t l_pid ;
};
#line 22 "/home/june/collector/temp/bmf-0.9.4/dbh.h"
struct _rec {
   str_t w ;
   uint n ;
};
#line 22 "/home/june/collector/temp/bmf-0.9.4/dbh.h"
typedef struct _rec rec_t;
#line 13 "/home/june/collector/temp/bmf-0.9.4/dbtext.h"
struct _dbttext;
#line 13 "/home/june/collector/temp/bmf-0.9.4/dbtext.h"
typedef struct _dbttext dbttext_t;
#line 14 "/home/june/collector/temp/bmf-0.9.4/dbtext.h"
struct _dbttext {
   bool_t (*close)(dbttext_t * ) ;
   bool_t (*mergeclose)(dbttext_t * , vec_t * ) ;
   bool_t (*unmergeclose)(dbttext_t * , vec_t * ) ;
   bool_t (*import)(dbttext_t * , cpchar  ) ;
   bool_t (*export)(dbttext_t * , cpchar  ) ;
   uint (*getmsgcount)(dbttext_t * ) ;
   uint (*getcount)(dbttext_t * , str_t * ) ;
   int fd ;
   char *pbuf ;
   uint nmsgs ;
   uint nalloc ;
   uint nitems ;
   rec_t *pitems ;
};
#line 32
struct _dbhtext;
#line 32 "/home/june/collector/temp/bmf-0.9.4/dbtext.h"
typedef struct _dbhtext dbhtext_t;
#line 33 "/home/june/collector/temp/bmf-0.9.4/dbtext.h"
struct _dbhtext {
   bool_t (*close)(dbhtext_t * ) ;
   dbt_t *(*opentable)(dbhtext_t * , cpchar  , bool_t  ) ;
   char *dir ;
};
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 18 "/home/june/collector/temp/bmf-0.9.4/bmfconv.c"
enum __anonenum_dir_t_34 {
    none = 0,
    db2text = 1,
    text2db = 2
} ;
#line 18 "/home/june/collector/temp/bmf-0.9.4/bmfconv.c"
typedef enum __anonenum_dir_t_34 dir_t;
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 181 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) fabs)(double __x )  __attribute__((__const__)) ;
#line 366 "/usr/include/unistd.h"
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 16 "/home/june/collector/temp/bmf-0.9.4/str.h"
void strncpylwr(char *d , char const   *s , int n ) ;
#line 28
int str_casecmp(str_t const   *pthis , str_t const   *pother ) ;
#line 40 "/home/june/collector/temp/bmf-0.9.4/lex.h"
void lex_nexttoken(lex_t *pthis , tok_t *ptok ) ;
#line 34 "/home/june/collector/temp/bmf-0.9.4/vec.h"
void vec_addtail(vec_t *pthis , str_t *pstr ) ;
#line 38
void vec_first(vec_t *pthis , veciter_t *piter ) ;
#line 47
void veciter_destroy(veciter_t *pthis ) ;
#line 49
str_t *veciter_get(veciter_t *pthis ) ;
#line 53
bool_t veciter_next(veciter_t *pthis ) ;
#line 26 "/home/june/collector/temp/bmf-0.9.4/filt.h"
void statdump(stats_t *pstat , int fd ) ;
#line 27
void bayesfilt(dbt_t *pglist , dbt_t *pblist , vec_t *pmlist , stats_t *pstats ) ;
#line 29
bool_t bvec_loadmsg(vec_t *pthis , lex_t *plex , tok_t *ptok ) ;
#line 24 "/home/june/collector/temp/bmf-0.9.4/filt.c"
void statdump(stats_t *pstat , int fd ) 
{ 
  char iobuf[4096] ;
  char *p ;
  discrim_t *pp ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 30
  p = iobuf;
#line 31
  tmp = sprintf((char */* __restrict  */)(iobuf), (char const   */* __restrict  */)"# Spamicity: %f\n",
                pstat->spamicity);
#line 31
  p += tmp;
#line 33
  pp = pstat->extrema;
  }
  {
#line 33
  while (1) {
    while_continue: /* CIL Label */ ;
#line 33
    if (! ((unsigned long )pp < (unsigned long )(pstat->extrema + pstat->keepers))) {
#line 33
      goto while_break;
    }
#line 35
    if (pp->key.len) {
      {
#line 37
      strcpy((char */* __restrict  */)p, (char const   */* __restrict  */)"# \'");
#line 37
      p += 3;
#line 38
      strncpylwr(p, (char const   *)pp->key.p, (int )pp->key.len);
#line 38
      p += pp->key.len;
#line 39
      tmp___0 = snprintf((char */* __restrict  */)p, (size_t )28, (char const   */* __restrict  */)"\' -> %f\n",
                         pp->prob);
#line 39
      p += tmp___0;
      }
#line 40
      if ((unsigned long )((p + 20) + 32) > (unsigned long )(iobuf + 1)) {
        {
#line 42
        write(fd, (void const   *)(iobuf), (size_t )(p - iobuf));
#line 43
        p = iobuf;
        }
      }
    }
#line 33
    pp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 47
  if ((unsigned long )p != (unsigned long )(iobuf)) {
    {
#line 49
    write(fd, (void const   *)(iobuf), (size_t )(p - iobuf));
    }
  }
#line 51
  return;
}
}
#line 53 "/home/june/collector/temp/bmf-0.9.4/filt.c"
void bayesfilt(dbt_t *pglist , dbt_t *pblist , vec_t *pmlist , stats_t *pstats ) 
{ 
  veciter_t iter ;
  str_t *pword ;
  double prob ;
  double product ;
  double invproduct ;
  double dev ;
  double slotdev ;
  double hitdev ;
  discrim_t *pp ;
  discrim_t *hit ;
  double goodness ;
  uint tmp ;
  double spamness ;
  uint tmp___0 ;
  uint goodtotal ;
  uint tmp___1 ;
  uint spamtotal ;
  uint tmp___2 ;
  double goodprob ;
  double tmp___3 ;
  double tmp___4 ;
  double spamprob ;
  double tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  int tmp___8 ;

  {
#line 69
  pp = pstats->extrema;
  {
#line 69
  while (1) {
    while_continue: /* CIL Label */ ;
#line 69
    if (! ((unsigned long )pp < (unsigned long )(pstats->extrema + pstats->keepers))) {
#line 69
      goto while_break;
    }
#line 71
    pp->key.p = (char *)((void *)0);
#line 72
    pp->key.len = (uint )0;
#line 73
    pp->prob = (double )0.5f;
#line 69
    pp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 76
  vec_first(pmlist, & iter);
  }
  {
#line 77
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 77
    pword = veciter_get(& iter);
    }
#line 77
    if (! ((unsigned long )pword != (unsigned long )((void *)0))) {
#line 77
      goto while_break___0;
    }
    {
#line 79
    tmp = (*(pglist->getcount))(pglist, pword);
#line 79
    goodness = (double )tmp;
#line 80
    tmp___0 = (*(pblist->getcount))(pblist, pword);
#line 80
    spamness = (double )tmp___0;
#line 81
    tmp___1 = (*(pglist->getmsgcount))(pglist);
#line 81
    goodtotal = tmp___1;
#line 82
    tmp___2 = (*(pblist->getmsgcount))(pblist);
#line 82
    spamtotal = tmp___2;
    }
#line 84
    if (goodness + spamness < (double )5) {
#line 93
      prob = 0.4;
    } else {
#line 98
      if (goodtotal) {
#line 98
        if (1.0 < goodness / (double )goodtotal) {
#line 98
          tmp___3 = 1.0;
        } else {
#line 98
          tmp___3 = goodness / (double )goodtotal;
        }
#line 98
        tmp___4 = tmp___3;
      } else {
#line 98
        tmp___4 = 0.0;
      }
#line 98
      goodprob = tmp___4;
#line 99
      if (spamtotal) {
#line 99
        if (1.0 < spamness / (double )spamtotal) {
#line 99
          tmp___5 = 1.0;
        } else {
#line 99
          tmp___5 = spamness / (double )spamtotal;
        }
#line 99
        tmp___6 = tmp___5;
      } else {
#line 99
        tmp___6 = 0.0;
      }
#line 99
      spamprob = tmp___6;
#line 105
      prob = spamprob / (goodprob + spamprob);
#line 108
      if (prob < 0.01) {
#line 108
        prob = 0.01;
      } else {
#line 108
        if (prob > 0.99) {
#line 108
          tmp___7 = 0.99;
        } else {
#line 108
          tmp___7 = prob;
        }
#line 108
        prob = tmp___7;
      }
    }
    {
#line 112
    dev = fabs(prob - (double )0.5f);
#line 113
    hit = (discrim_t *)((void *)0);
#line 114
    hitdev = (double )0;
#line 115
    pp = pstats->extrema;
    }
    {
#line 115
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 115
      if (! ((unsigned long )pp < (unsigned long )(pstats->extrema + pstats->keepers))) {
#line 115
        goto while_break___1;
      }
#line 118
      if (pp->key.len > 0U) {
        {
#line 118
        tmp___8 = str_casecmp((str_t const   *)pword, (str_t const   *)(& pp->key));
        }
#line 118
        if (tmp___8 == 0) {
#line 120
          hit = (discrim_t *)((void *)0);
#line 121
          goto while_break___1;
        }
      }
      {
#line 124
      slotdev = fabs(pp->prob - (double )0.5f);
      }
#line 125
      if (dev > slotdev) {
#line 125
        if (dev > hitdev) {
#line 127
          hit = pp;
#line 128
          hitdev = slotdev;
        }
      }
#line 115
      pp ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 131
    if (hit) {
#line 133
      hit->prob = prob;
#line 134
      hit->key = *pword;
    }
    {
#line 137
    veciter_next(& iter);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 139
  veciter_destroy(& iter);
#line 145
  invproduct = (double )1.0f;
#line 145
  product = invproduct;
#line 146
  pp = pstats->extrema;
  }
  {
#line 146
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 146
    if (! ((unsigned long )pp < (unsigned long )(pstats->extrema + pstats->keepers))) {
#line 146
      goto while_break___2;
    }
#line 148
    if (pp->prob == (double )0) {
#line 150
      goto while_break___2;
    } else {
#line 154
      product *= pp->prob;
#line 155
      invproduct *= (double )1 - pp->prob;
    }
#line 146
    pp ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 158
  pstats->spamicity = product / (product + invproduct);
#line 159
  return;
}
}
#line 161 "/home/june/collector/temp/bmf-0.9.4/filt.c"
bool_t bvec_loadmsg(vec_t *pthis , lex_t *plex , tok_t *ptok ) 
{ 
  str_t w ;

  {
  {
#line 165
  lex_nexttoken(plex, ptok);
  }
  {
#line 166
  while (1) {
    while_continue: /* CIL Label */ ;
#line 166
    if ((unsigned int )ptok->tt != 1U) {
#line 166
      if (! ((unsigned int )ptok->tt != 0U)) {
#line 166
        goto while_break;
      }
    } else {
#line 166
      goto while_break;
    }
    {
#line 168
    w.p = ptok->p;
#line 169
    w.len = ptok->len;
#line 170
    vec_addtail(pthis, & w);
#line 171
    lex_nexttoken(plex, ptok);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 174
  return ((bool_t )1);
}
}
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 376
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srand)(unsigned int __seed ) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 519
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atexit)(void (*__func)(void) ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 176 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 13 "/home/june/collector/temp/bmf-0.9.4/dbg.h"
uint g_verbose ;
#line 15
void verbose(int level , char const   *fmt  , ...) ;
#line 18
void dump_alloc_heap(void) ;
#line 36 "/home/june/collector/temp/bmf-0.9.4/lex.h"
void lex_create(lex_t *pthis , mbox_t mboxtype ) ;
#line 37
void lex_destroy(lex_t *pthis ) ;
#line 39
bool_t lex_load(lex_t *pthis , int fd ) ;
#line 42
void lex_passthru(lex_t *pthis , bool_t is_spam , double hits ) ;
#line 30 "/home/june/collector/temp/bmf-0.9.4/vec.h"
void vec_create(vec_t *pthis ) ;
#line 31
void vec_destroy(vec_t *pthis ) ;
#line 44
void svec_sort(vec_t *pthis ) ;
#line 49 "/home/june/collector/temp/bmf-0.9.4/dbh.h"
dbh_t *dbh_open(dbfmt_t dbfmt , cpchar dbhost , cpchar dbname , cpchar dbuser , cpchar dbpass ) ;
#line 31 "/home/june/collector/temp/bmf-0.9.4/bmf.c"
static void usage(void) 
{ 


  {
  {
#line 33
  printf((char const   */* __restrict  */)"\nUsage: bmf [mode] [options]\n\nModes of operation (mutually exclusive; the last one specified is used):\n\t\tRegister message using historical data if no mode is specified.\n\t-n\tRegister message as non-spam.\n\t-s\tRegister message as spam.\n\t-N\tRegister message as non-spam and undo prior registration as spam.\n\t-S\tRegister message as spam and undo prior registration as non-spam.\n\t-t\tTest mode, print report and do not save results.\n\nOther options:\n\t-f fmt\tSpecify database format (text|db|mysql).\n\t-d db\tSpecify database or directory name.\n\t-i file\tSpecify file to read instead of stdin.\n\t-k n\tSpecify count of extrema to use (keepers), default is 15.\n\t-m type\t[DEPRECATED] Specify mail storage format (mbox|maildir)\n\t-p\tPassthrough mode, like SpamAssassin.\n\t-v\tIncrease verbosity level.\n\t-V\tShow version information and exit.\n\t-h\tShow this message and exit.\n\n");
#line 55
  exit(2);
  }
}
}
#line 58 "/home/june/collector/temp/bmf-0.9.4/bmf.c"
static void version(void) 
{ 


  {
  {
#line 60
  printf((char const   */* __restrict  */)"\nbmf version 0.9.4 - a Bayesian mail filter\nCopyright (c) 2002 Tom Marshall\n\nbmf comes with ABSOLUTELY NO WARRANTY.\nThis is free software.  You are welcome to redistribute it under the terms\nof the GNU General Public License.  See the file LICENSE in the source\ndistribution, or visit http://www.gnu.org/licenses/gpl.html\n\n");
#line 69
  exit(2);
  }
}
}
#line 72 "/home/june/collector/temp/bmf-0.9.4/bmf.c"
int main(int argc , char **argv ) 
{ 
  int ch ;
  dbfmt_t dbfmt ;
  char *dbname ;
  bool_t rdonly ;
  runmode_t mode ;
  mbox_t mboxtype ;
  bool_t do_passthru ;
  dbh_t *pdb ;
  dbt_t *pblist ;
  dbt_t *pglist ;
  dbt_t *ptable ;
  vec_t mlist ;
  stats_t stats ;
  lex_t lex ;
  tok_t tok ;
  bool_t is_spam ;
  int fd ;
  char *infile ;
  time_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  bool_t tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  bool_t tmp___12 ;
  bool_t tmp___13 ;
  bool_t tmp___14 ;
  bool_t tmp___15 ;
  bool_t tmp___16 ;
  bool_t tmp___17 ;
  bool_t tmp___18 ;
  int tmp___19 ;

  {
  {
#line 75
  dbfmt = (dbfmt_t )1;
#line 76
  dbname = (char *)((void *)0);
#line 79
  mode = (runmode_t )1;
#line 80
  mboxtype = (mbox_t )0;
#line 81
  do_passthru = (bool_t )0;
#line 93
  fd = 0;
#line 94
  infile = (char *)((void *)0);
#line 96
  tmp = time((time_t *)((void *)0));
#line 96
  srand((unsigned int )tmp);
#line 97
  atexit(& dump_alloc_heap);
#line 102
  dbfmt = (dbfmt_t )0;
#line 105
  stats.keepers = (uint )15;
  }
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 106
    ch = getopt(argc, (char * const  *)argv, "NSVd:f:i:hk:m:npstv");
    }
#line 106
    if (! (ch != -1)) {
#line 106
      goto while_break;
    }
    {
#line 110
    if (ch == 78) {
#line 110
      goto case_78;
    }
#line 113
    if (ch == 83) {
#line 113
      goto case_83;
    }
#line 116
    if (ch == 86) {
#line 116
      goto case_86;
    }
#line 119
    if (ch == 100) {
#line 119
      goto case_100;
    }
#line 123
    if (ch == 102) {
#line 123
      goto case_102;
    }
#line 141
    if (ch == 104) {
#line 141
      goto case_104;
    }
#line 144
    if (ch == 105) {
#line 144
      goto case_105;
    }
#line 148
    if (ch == 107) {
#line 148
      goto case_107;
    }
#line 151
    if (ch == 109) {
#line 151
      goto case_109;
    }
#line 165
    if (ch == 110) {
#line 165
      goto case_110;
    }
#line 168
    if (ch == 112) {
#line 168
      goto case_112;
    }
#line 171
    if (ch == 115) {
#line 171
      goto case_115;
    }
#line 174
    if (ch == 116) {
#line 174
      goto case_116;
    }
#line 177
    if (ch == 118) {
#line 177
      goto case_118;
    }
#line 181
    goto switch_default;
    case_78: /* CIL Label */ 
#line 111
    mode = (runmode_t )5;
#line 112
    goto switch_break;
    case_83: /* CIL Label */ 
#line 114
    mode = (runmode_t )4;
#line 115
    goto switch_break;
    case_86: /* CIL Label */ 
    {
#line 117
    version();
    }
#line 118
    goto switch_break;
    case_100: /* CIL Label */ 
    {
#line 120
    free((void *)dbname);
#line 121
    dbname = strdup((char const   *)optarg);
    }
#line 122
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 124
    tmp___2 = strcasecmp((char const   *)optarg, "text");
    }
#line 124
    if (tmp___2 == 0) {
#line 126
      dbfmt = (dbfmt_t )0;
    } else {
      {
#line 128
      tmp___1 = strcasecmp((char const   *)optarg, "db");
      }
#line 128
      if (tmp___1 == 0) {
#line 130
        dbfmt = (dbfmt_t )1;
      } else {
        {
#line 132
        tmp___0 = strcasecmp((char const   *)optarg, "mysql");
        }
#line 132
        if (tmp___0 == 0) {
#line 134
          dbfmt = (dbfmt_t )2;
        } else {
          {
#line 138
          usage();
          }
        }
      }
    }
#line 140
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 142
    usage();
    }
#line 143
    goto switch_break;
    case_105: /* CIL Label */ 
    {
#line 145
    free((void *)infile);
#line 146
    infile = strdup((char const   *)optarg);
    }
#line 147
    goto switch_break;
    case_107: /* CIL Label */ 
    {
#line 149
    tmp___3 = atoi((char const   *)optarg);
#line 149
    stats.keepers = (uint )tmp___3;
    }
#line 150
    goto switch_break;
    case_109: /* CIL Label */ 
    {
#line 152
    tmp___5 = strcasecmp((char const   *)optarg, "mbox");
    }
#line 152
    if (tmp___5 == 0) {
#line 154
      mboxtype = (mbox_t )1;
    } else {
      {
#line 156
      tmp___4 = strcasecmp((char const   *)optarg, "maildir");
      }
#line 156
      if (tmp___4 == 0) {
#line 158
        mboxtype = (mbox_t )2;
      } else {
        {
#line 162
        usage();
        }
      }
    }
#line 164
    goto switch_break;
    case_110: /* CIL Label */ 
#line 166
    mode = (runmode_t )3;
#line 167
    goto switch_break;
    case_112: /* CIL Label */ 
#line 169
    do_passthru = (bool_t )1;
#line 170
    goto switch_break;
    case_115: /* CIL Label */ 
#line 172
    mode = (runmode_t )2;
#line 173
    goto switch_break;
    case_116: /* CIL Label */ 
#line 175
    mode = (runmode_t )0;
#line 176
    goto switch_break;
    case_118: /* CIL Label */ 
    {
#line 178
    g_verbose ++;
#line 179
    verbose(1, "Verbose level now %u\n", g_verbose);
    }
#line 180
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 182
    usage();
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 185
  tmp___6 = malloc((unsigned long )stats.keepers * sizeof(discrim_t ));
#line 185
  stats.extrema = (discrim_t *)tmp___6;
  }
#line 187
  if ((unsigned long )infile != (unsigned long )((void *)0)) {
    {
#line 189
    fd = open((char const   *)infile, 0);
    }
#line 190
    if (fd == -1) {
      {
#line 192
      tmp___7 = __errno_location();
#line 192
      tmp___8 = strerror(*tmp___7);
#line 192
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: cannot open input file \'%s\': %s\n",
              *(argv + 0), infile, tmp___8);
#line 194
      exit(2);
      }
    }
  }
  {
#line 198
  pdb = dbh_open(dbfmt, "localhost", (cpchar )dbname, "username", "password");
  }
#line 199
  if ((unsigned long )pdb == (unsigned long )((void *)0)) {
    {
#line 201
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: cannot open database\n",
            *(argv + 0));
#line 202
    exit(2);
    }
  }
  {
#line 205
  lex_create(& lex, mboxtype);
#line 206
  tmp___9 = lex_load(& lex, fd);
  }
#line 206
  if (! tmp___9) {
    {
#line 208
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: cannot read input\n",
            *(argv + 0));
#line 209
    exit(2);
    }
  }
  {
#line 211
  lex_nexttoken(& lex, & tok);
  }
#line 212
  if ((unsigned int )tok.tt == 1U) {
    {
#line 214
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: no input available\n",
            *(argv + 0));
#line 215
    exit(2);
    }
  }
  {
#line 218
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 218
    if (! ((unsigned int )tok.tt != 1U)) {
#line 218
      goto while_break___0;
    }
#line 220
    if ((unsigned int )mboxtype == 1U) {
#line 220
      if ((unsigned int )tok.tt != 0U) {
        {
#line 222
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: input does not look like an mbox message\n",
                *(argv + 0));
#line 223
        exit(2);
        }
      }
    }
#line 226
    if ((unsigned int )mode == 0U) {
#line 226
      tmp___10 = 1;
    } else
#line 226
    if ((unsigned int )mode == 3U) {
#line 226
      tmp___10 = 1;
    } else {
#line 226
      tmp___10 = 0;
    }
    {
#line 226
    rdonly = (bool_t )tmp___10;
#line 227
    pblist = (*(pdb->opentable))(pdb, "spamlist", rdonly);
    }
#line 228
    if ((unsigned long )pblist == (unsigned long )((void *)0)) {
      {
#line 230
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: cannot open spamlist\n",
              *(argv + 0));
#line 231
      exit(2);
      }
    }
#line 234
    if ((unsigned int )mode == 0U) {
#line 234
      tmp___11 = 1;
    } else
#line 234
    if ((unsigned int )mode == 2U) {
#line 234
      tmp___11 = 1;
    } else {
#line 234
      tmp___11 = 0;
    }
    {
#line 234
    rdonly = (bool_t )tmp___11;
#line 235
    pglist = (*(pdb->opentable))(pdb, "goodlist", rdonly);
    }
#line 236
    if ((unsigned long )pglist == (unsigned long )((void *)0)) {
      {
#line 238
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: cannot open goodlist\n",
              *(argv + 0));
#line 239
      exit(2);
      }
    }
    {
#line 242
    vec_create(& mlist);
#line 243
    bvec_loadmsg(& mlist, & lex, & tok);
    }
    {
#line 247
    if ((unsigned int )mode == 0U) {
#line 247
      goto case_0;
    }
#line 251
    if ((unsigned int )mode == 1U) {
#line 251
      goto case_1;
    }
#line 262
    if ((unsigned int )mode == 2U) {
#line 262
      goto case_2;
    }
#line 272
    if ((unsigned int )mode == 3U) {
#line 272
      goto case_3;
    }
#line 282
    if ((unsigned int )mode == 4U) {
#line 282
      goto case_4;
    }
#line 293
    if ((unsigned int )mode == 5U) {
#line 293
      goto case_5;
    }
#line 304
    goto switch_default___0;
    case_0: /* CIL Label */ 
    {
#line 248
    bayesfilt(pglist, pblist, & mlist, & stats);
#line 249
    is_spam = (bool_t )(stats.spamicity > 0.9);
    }
#line 250
    goto switch_break___0;
    case_1: /* CIL Label */ 
    {
#line 252
    bayesfilt(pglist, pblist, & mlist, & stats);
#line 253
    is_spam = (bool_t )(stats.spamicity > 0.9);
    }
#line 254
    if (is_spam) {
#line 254
      ptable = pblist;
    } else {
#line 254
      ptable = pglist;
    }
    {
#line 255
    svec_sort(& mlist);
#line 256
    tmp___12 = (*(ptable->mergeclose))(ptable, & mlist);
    }
#line 256
    if (! tmp___12) {
      {
#line 258
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: cannot merge/save list\n",
              *(argv + 0));
#line 259
      exit(2);
      }
    }
#line 261
    goto switch_break___0;
    case_2: /* CIL Label */ 
    {
#line 263
    stats.spamicity = 1.0;
#line 264
    is_spam = (bool_t )1;
#line 265
    svec_sort(& mlist);
#line 266
    tmp___13 = (*(pblist->mergeclose))(pblist, & mlist);
    }
#line 266
    if (! tmp___13) {
      {
#line 268
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: cannot merge/save list\n",
              *(argv + 0));
#line 269
      exit(2);
      }
    }
#line 271
    goto switch_break___0;
    case_3: /* CIL Label */ 
    {
#line 273
    stats.spamicity = 0.0;
#line 274
    is_spam = (bool_t )0;
#line 275
    svec_sort(& mlist);
#line 276
    tmp___14 = (*(pglist->mergeclose))(pglist, & mlist);
    }
#line 276
    if (! tmp___14) {
      {
#line 278
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: cannot merge/save list\n",
              *(argv + 0));
#line 279
      exit(2);
      }
    }
#line 281
    goto switch_break___0;
    case_4: /* CIL Label */ 
    {
#line 283
    stats.spamicity = 1.0;
#line 284
    is_spam = (bool_t )1;
#line 285
    svec_sort(& mlist);
#line 286
    tmp___15 = (*(pblist->mergeclose))(pblist, & mlist);
    }
#line 286
    if (tmp___15) {
      {
#line 286
      tmp___16 = (*(pglist->unmergeclose))(pglist, & mlist);
      }
#line 286
      if (! tmp___16) {
        {
#line 289
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: cannot merge/save list\n",
                *(argv + 0));
#line 290
        exit(2);
        }
      }
    } else {
      {
#line 289
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: cannot merge/save list\n",
              *(argv + 0));
#line 290
      exit(2);
      }
    }
#line 292
    goto switch_break___0;
    case_5: /* CIL Label */ 
    {
#line 294
    stats.spamicity = 0.0;
#line 295
    is_spam = (bool_t )0;
#line 296
    svec_sort(& mlist);
#line 297
    tmp___17 = (*(pblist->unmergeclose))(pblist, & mlist);
    }
#line 297
    if (tmp___17) {
      {
#line 297
      tmp___18 = (*(pglist->mergeclose))(pglist, & mlist);
      }
#line 297
      if (! tmp___18) {
        {
#line 300
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: cannot merge/save list\n",
                *(argv + 0));
#line 301
        exit(2);
        }
      }
    } else {
      {
#line 300
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: cannot merge/save list\n",
              *(argv + 0));
#line 301
      exit(2);
      }
    }
#line 303
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 305
    usage();
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 308
    if ((unsigned int )mode == 0U) {
      {
#line 310
      statdump(& stats, 1);
      }
    }
#line 313
    if (do_passthru) {
      {
#line 315
      lex_passthru(& lex, is_spam, stats.spamicity);
      }
    }
    {
#line 318
    vec_destroy(& mlist);
#line 320
    (*(pglist->close))(pglist);
#line 321
    free((void *)pglist);
#line 322
    (*(pblist->close))(pblist);
#line 323
    free((void *)pblist);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 326
  lex_destroy(& lex);
#line 328
  (*(pdb->close))(pdb);
#line 329
  free((void *)pdb);
  }
#line 331
  if ((unsigned long )infile != (unsigned long )((void *)0)) {
    {
#line 333
    free((void *)infile);
#line 334
    close(fd);
    }
  }
  {
#line 336
  free((void *)stats.extrema);
  }
#line 338
  if (do_passthru) {
#line 338
    tmp___19 = 0;
  } else
#line 338
  if (is_spam) {
#line 338
    tmp___19 = 0;
  } else {
#line 338
    tmp___19 = 1;
  }
#line 338
  return (tmp___19);
}
}
#line 54 "/home/june/collector/temp/bmf-0.9.4/dbh.h"
uint db_getnewcount(veciter_t *piter ) ;
#line 41 "/home/june/collector/temp/bmf-0.9.4/dbtext.h"
dbh_t *dbtext_db_open(cpchar dbhost , cpchar dbname , cpchar dbuser , cpchar dbpass ) ;
#line 56 "/home/june/collector/temp/bmf-0.9.4/dbmysql.h"
dbh_t *dbmysql_db_open(cpchar dbhost , cpchar dbname , cpchar dbuser , cpchar dbpass ) ;
#line 29 "/home/june/collector/temp/bmf-0.9.4/dbh.c"
uint db_getnewcount(veciter_t *piter ) 
{ 
  str_t *pstr ;
  uint count ;
  veciter_t curiter ;
  str_t *pcurstr ;
  int tmp ;

  {
#line 36
  pstr = (piter->plist)->pitems + piter->index;
#line 37
  count = (uint )0;
#line 39
  curiter.plist = piter->plist;
#line 40
  curiter.index = piter->index;
#line 41
  pcurstr = (curiter.plist)->pitems + curiter.index;
  {
#line 43
  while (1) {
    while_continue: /* CIL Label */ ;
#line 43
    if (curiter.index < (curiter.plist)->nitems) {
      {
#line 43
      tmp = str_casecmp((str_t const   *)pstr, (str_t const   *)pcurstr);
      }
#line 43
      if (! (tmp == 0)) {
#line 43
        goto while_break;
      }
    } else {
#line 43
      goto while_break;
    }
#line 45
    piter->index = curiter.index;
#line 46
    if (4U < count + 1U) {
#line 46
      count = (uint )4;
    } else {
#line 46
      count ++;
    }
    {
#line 47
    veciter_next(& curiter);
#line 48
    pcurstr = (curiter.plist)->pitems + curiter.index;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 51
  return (count);
}
}
#line 64
dbh_t *dbdb_db_open(cpchar dbhost , cpchar dbname , cpchar dbuser , cpchar dbpass ) ;
#line 54 "/home/june/collector/temp/bmf-0.9.4/dbh.c"
dbh_t *dbh_open(dbfmt_t dbfmt , cpchar dbhost , cpchar dbname , cpchar dbuser , cpchar dbpass ) 
{ 
  dbh_t *pdb ;
  dbh_t *tmp ;
  int tmp___0 ;
  dbh_t *tmp___1 ;

  {
#line 56
  pdb = (dbh_t *)((void *)0);
  {
#line 60
  if ((unsigned int )dbfmt == 0U) {
#line 60
    goto case_0;
  }
#line 63
  if ((unsigned int )dbfmt == 1U) {
#line 63
    goto case_1;
  }
#line 66
  if ((unsigned int )dbfmt == 2U) {
#line 66
    goto case_2;
  }
#line 69
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 61
  tmp = dbtext_db_open(dbhost, dbname, dbuser, dbpass);
#line 61
  pdb = tmp;
  }
#line 62
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 64
  tmp___0 = (int )dbdb_db_open(dbhost, dbname, dbuser, dbpass);
#line 64
  pdb = (dbh_t *)tmp___0;
  }
#line 65
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 67
  tmp___1 = dbmysql_db_open(dbhost, dbname, dbuser, dbpass);
#line 67
  pdb = tmp___1;
  }
#line 68
  goto switch_break;
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 73
  return (pdb);
}
}
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 69 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 538
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncasecmp)(char const   *__s1 ,
                                                                                                    char const   *__s2 ,
                                                                                                    size_t __n )  __attribute__((__pure__)) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 360 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 17 "/home/june/collector/temp/bmf-0.9.4/lex.c"
static cpchar g_htmltags[152]  = 
#line 17 "/home/june/collector/temp/bmf-0.9.4/lex.c"
  {      "abbr",      "above",      "accesskey",      "acronym", 
        "align",      "alink",      "all",      "alt", 
        "applet",      "archive",      "axis",      "basefont", 
        "baseline",      "below",      "bgcolor",      "big", 
        "body",      "border",      "bottom",      "box", 
        "button",      "cellpadding",      "cellspacing",      "center", 
        "char",      "charoff",      "charset",      "circle", 
        "cite",      "class",      "classid",      "clear", 
        "codebase",      "codetype",      "color",      "cols", 
        "colspan",      "compact",      "content",      "coords", 
        "data",      "datetime",      "declare",      "default", 
        "defer",      "dfn",      "dir",      "disabled", 
        "face",      "font",      "frameborder",      "groups", 
        "head",      "headers",      "height",      "href", 
        "hreflang",      "hsides",      "hspace",      "http-equiv", 
        "iframe",      "img",      "input",      "ismap", 
        "justify",      "kbd",      "label",      "lang", 
        "language",      "left",      "lhs",      "link", 
        "longdesc",      "map",      "marginheight",      "marginwidth", 
        "media",      "meta",      "middle",      "multiple", 
        "name",      "nohref",      "none",      "noresize", 
        "noshade",      "nowrap",      "object",      "onblur", 
        "onchange",      "onclick",      "ondblclick",      "onfocus", 
        "onkeydown",      "onkeypress",      "onkeyup",      "onload", 
        "onmousedown",      "onmousemove",      "onmouseout",      "onmouseover", 
        "onmouseup",      "onselect",      "onunload",      "param", 
        "poly",      "profile",      "prompt",      "readonly", 
        "rect",      "rel",      "rev",      "rhs", 
        "right",      "rows",      "rowspan",      "rules", 
        "samp",      "scheme",      "scope",      "script", 
        "scrolling",      "select",      "selected",      "shape", 
        "size",      "small",      "span",      "src", 
        "standby",      "strike",      "strong",      "style", 
        "sub",      "summary",      "sup",      "tabindex", 
        "table",      "target",      "textarea",      "title", 
        "top",      "type",      "usemap",      "valign", 
        "value",      "valuetype",      "var",      "vlink", 
        "void",      "vsides",      "vspace",      "width"};
#line 172 "/home/june/collector/temp/bmf-0.9.4/lex.c"
static unsigned int const   g_nhtmltags  =    (uint const   )(sizeof(g_htmltags) / sizeof(cpchar ));
#line 174 "/home/june/collector/temp/bmf-0.9.4/lex.c"
static cpchar g_ignoredheaders[5]  = {      "Date:",      "Delivery-date:",      "Message-ID:",      "X-Sorted:", 
        "X-Spam-"};
#line 182 "/home/june/collector/temp/bmf-0.9.4/lex.c"
static unsigned int const   g_nignoredheaders  =    (uint const   )(sizeof(g_ignoredheaders) / sizeof(cpchar ));
#line 184 "/home/june/collector/temp/bmf-0.9.4/lex.c"
__inline static bool_t is_whitespace(int c ) 
{ 
  int tmp ;

  {
#line 186
  if (c == 32) {
#line 186
    tmp = 1;
  } else
#line 186
  if (c == 9) {
#line 186
    tmp = 1;
  } else
#line 186
  if (c == 13) {
#line 186
    tmp = 1;
  } else {
#line 186
    tmp = 0;
  }
#line 186
  return ((bool_t )tmp);
}
}
#line 189 "/home/june/collector/temp/bmf-0.9.4/lex.c"
__inline static bool_t is_base64char(int c ) 
{ 
  unsigned short const   **tmp ;
  int tmp___0 ;

  {
  {
#line 191
  tmp = __ctype_b_loc();
  }
#line 191
  if ((int const   )*(*tmp + c) & 8) {
#line 191
    tmp___0 = 1;
  } else
#line 191
  if (c == 47) {
#line 191
    tmp___0 = 1;
  } else
#line 191
  if (c == 43) {
#line 191
    tmp___0 = 1;
  } else {
#line 191
    tmp___0 = 0;
  }
#line 191
  return ((bool_t )tmp___0);
}
}
#line 194 "/home/june/collector/temp/bmf-0.9.4/lex.c"
__inline static bool_t is_wordmidchar(int c ) 
{ 
  unsigned short const   **tmp ;
  int tmp___0 ;

  {
  {
#line 196
  tmp = __ctype_b_loc();
  }
#line 196
  if ((int const   )*(*tmp + c) & 8) {
#line 196
    tmp___0 = 1;
  } else
#line 196
  if (c == 36) {
#line 196
    tmp___0 = 1;
  } else
#line 196
  if (c == 39) {
#line 196
    tmp___0 = 1;
  } else
#line 196
  if (c == 46) {
#line 196
    tmp___0 = 1;
  } else
#line 196
  if (c == 45) {
#line 196
    tmp___0 = 1;
  } else {
#line 196
    tmp___0 = 0;
  }
#line 196
  return ((bool_t )tmp___0);
}
}
#line 199 "/home/june/collector/temp/bmf-0.9.4/lex.c"
__inline static bool_t is_wordendchar(int c ) 
{ 
  unsigned short const   **tmp ;
  int tmp___0 ;

  {
  {
#line 201
  tmp = __ctype_b_loc();
  }
#line 201
  if ((int const   )*(*tmp + c) & 8) {
#line 201
    tmp___0 = 1;
  } else
#line 201
  if (c == 36) {
#line 201
    tmp___0 = 1;
  } else {
#line 201
    tmp___0 = 0;
  }
#line 201
  return ((bool_t )tmp___0);
}
}
#line 204 "/home/june/collector/temp/bmf-0.9.4/lex.c"
__inline static bool_t is_htmltag(cpchar p , uint len , uint *ptoklen ) 
{ 
  int lo ;
  int hi ;
  int mid ;
  int minlen ;
  int cmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  unsigned short const   **tmp___2 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  bool_t tmp___7 ;
  bool_t tmp___8 ;
  bool_t tmp___9 ;
  size_t tmp___10 ;

  {
#line 208
  *ptoklen = (uint )0;
#line 210
  hi = (int )(g_nhtmltags - 1U);
#line 211
  lo = -1;
  {
#line 212
  while (1) {
    while_continue: /* CIL Label */ ;
#line 212
    if (! (hi - lo > 1)) {
#line 212
      goto while_break;
    }
    {
#line 214
    mid = (hi + lo) / 2;
#line 215
    tmp___1 = strlen(g_htmltags[mid]);
    }
#line 215
    if (tmp___1 < (size_t )len) {
      {
#line 215
      tmp___0 = strlen(g_htmltags[mid]);
#line 215
      minlen = (int )tmp___0;
      }
    } else {
#line 215
      minlen = (int )len;
    }
    {
#line 216
    cmp = strncmp(g_htmltags[mid], p, (size_t )minlen);
    }
#line 217
    if (cmp > 0) {
#line 218
      hi = mid;
    } else
#line 217
    if (cmp == 0) {
#line 217
      if ((uint )minlen < len) {
        {
#line 217
        tmp___2 = __ctype_b_loc();
        }
#line 217
        if ((int const   )*(*tmp___2 + (int )*(p + minlen)) & 512) {
#line 220
          lo = mid;
        } else {
#line 218
          hi = mid;
        }
      } else {
#line 220
        lo = mid;
      }
    } else {
#line 220
      lo = mid;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 222
  tmp___5 = strlen(g_htmltags[hi]);
  }
#line 222
  if (tmp___5 < (size_t )len) {
    {
#line 222
    tmp___4 = strlen(g_htmltags[hi]);
#line 222
    minlen = (int )tmp___4;
    }
  } else {
#line 222
    minlen = (int )len;
  }
#line 223
  if (len == (uint )minlen) {
#line 225
    return ((bool_t )0);
  } else {
    {
#line 223
    tmp___6 = strncmp(g_htmltags[hi], p, (size_t )minlen);
    }
#line 223
    if (tmp___6 != 0) {
#line 225
      return ((bool_t )0);
    }
  }
  {
#line 229
  tmp___7 = is_wordendchar((int )*(p + minlen));
  }
#line 229
  if (tmp___7) {
#line 231
    return ((bool_t )0);
  }
  {
#line 233
  tmp___8 = is_wordmidchar((int )*(p + minlen));
  }
#line 233
  if (tmp___8) {
    {
#line 233
    tmp___9 = is_wordendchar((int )*(p + (minlen + 1)));
    }
#line 233
    if (tmp___9) {
#line 235
      return ((bool_t )0);
    }
  }
  {
#line 238
  tmp___10 = strlen(g_htmltags[hi]);
#line 238
  *ptoklen = (uint )tmp___10;
  }
#line 240
  return ((bool_t )1);
}
}
#line 243 "/home/june/collector/temp/bmf-0.9.4/lex.c"
__inline static bool_t is_htmlcomment(cpchar p , uint len , uint *ptoklen ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 245
  *ptoklen = (uint )0;
#line 247
  if (len >= 4U) {
    {
#line 247
    tmp = memcmp((void const   *)p, (void const   *)"<!--", (size_t )4);
    }
#line 247
    if (tmp == 0) {
#line 249
      *ptoklen = (uint )4;
#line 250
      return ((bool_t )1);
    }
  }
#line 252
  if (len >= 3U) {
    {
#line 252
    tmp___0 = memcmp((void const   *)p, (void const   *)"-->", (size_t )3);
    }
#line 252
    if (tmp___0 == 0) {
#line 254
      *ptoklen = (uint )3;
#line 255
      return ((bool_t )1);
    }
  }
#line 258
  return ((bool_t )0);
}
}
#line 261 "/home/june/collector/temp/bmf-0.9.4/lex.c"
__inline static bool_t is_base64(cpchar p , uint len , uint *ptoklen ) 
{ 
  bool_t tmp ;

  {
#line 263
  *ptoklen = (uint )0;
  {
#line 264
  while (1) {
    while_continue: /* CIL Label */ ;
#line 264
    if (! (len > 0U)) {
#line 264
      goto while_break;
    }
#line 266
    if ((int const   )*p != 10) {
#line 266
      if ((int const   )*p != 13) {
        {
#line 266
        tmp = is_base64char((int )*p);
        }
#line 266
        if (! tmp) {
#line 268
          return ((bool_t )0);
        }
      }
    }
#line 270
    p ++;
#line 271
    len --;
#line 272
    (*ptoklen) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 274
  return ((bool_t )1);
}
}
#line 277 "/home/june/collector/temp/bmf-0.9.4/lex.c"
__inline static bool_t is_mimeboundary(cpchar p , uint len , uint *ptoklen ) 
{ 
  bool_t tmp ;

  {
#line 279
  *ptoklen = (uint )0;
#line 281
  if (len < 3U) {
#line 283
    return ((bool_t )0);
  } else
#line 281
  if ((int const   )*(p + 0) != 45) {
#line 283
    return ((bool_t )0);
  } else
#line 281
  if ((int const   )*(p + 1) != 45) {
#line 283
    return ((bool_t )0);
  }
#line 285
  p += 2;
#line 286
  len -= 2U;
#line 287
  *ptoklen += 2U;
  {
#line 288
  while (1) {
    while_continue: /* CIL Label */ ;
#line 288
    if (! (len > 0U)) {
#line 288
      goto while_break;
    }
    {
#line 290
    tmp = is_whitespace((int )*p);
    }
#line 290
    if (tmp) {
#line 292
      return ((bool_t )0);
    }
#line 294
    if ((int const   )*p == 10) {
#line 296
      goto while_break;
    } else
#line 294
    if ((int const   )*p == 13) {
#line 296
      goto while_break;
    }
#line 298
    p ++;
#line 299
    len --;
#line 300
    (*ptoklen) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 302
  return ((bool_t )1);
}
}
#line 305 "/home/june/collector/temp/bmf-0.9.4/lex.c"
__inline static bool_t is_ipaddr(cpchar p , uint len , uint *ptoklen ) 
{ 
  uint noctets ;
  uint ndigits ;
  unsigned short const   **tmp ;

  {
#line 309
  *ptoklen = (uint )0;
#line 311
  noctets = (uint )0;
  {
#line 312
  while (1) {
    while_continue: /* CIL Label */ ;
#line 312
    if (len > 0U) {
#line 312
      if (! (noctets < 4U)) {
#line 312
        goto while_break;
      }
    } else {
#line 312
      goto while_break;
    }
#line 314
    ndigits = (uint )0;
    {
#line 315
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 315
      if (len > 0U) {
        {
#line 315
        tmp = __ctype_b_loc();
        }
#line 315
        if (! ((int const   )*(*tmp + (int )*p) & 2048)) {
#line 315
          goto while_break___0;
        }
      } else {
#line 315
        goto while_break___0;
      }
#line 317
      ndigits ++;
#line 318
      p ++;
#line 319
      len --;
#line 320
      (*ptoklen) ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 322
    if (ndigits == 0U) {
#line 324
      return ((bool_t )0);
    } else
#line 322
    if (ndigits > 3U) {
#line 324
      return ((bool_t )0);
    }
#line 326
    noctets ++;
#line 327
    if (noctets < 4U) {
#line 329
      if ((int const   )*p != 46) {
#line 331
        return ((bool_t )0);
      }
#line 333
      p ++;
#line 334
      len --;
#line 335
      (*ptoklen) ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 338
  if (noctets < 4U) {
#line 340
    return ((bool_t )0);
  }
#line 342
  return ((bool_t )1);
}
}
#line 345 "/home/june/collector/temp/bmf-0.9.4/lex.c"
__inline static bool_t is_word(cpchar p , uint len , uint *ptoklen ) 
{ 
  unsigned short const   **tmp ;
  bool_t tmp___0 ;
  bool_t tmp___1 ;

  {
#line 347
  if (len < 3U) {
#line 349
    return ((bool_t )0);
  }
  {
#line 351
  tmp = __ctype_b_loc();
  }
#line 351
  if (! ((int const   )*(*tmp + (int )*p) & 1024)) {
#line 351
    if (! ((int const   )*p == 36)) {
#line 353
      return ((bool_t )0);
    }
  }
#line 355
  *ptoklen = (uint )1;
#line 356
  p ++;
#line 357
  len --;
  {
#line 358
  while (1) {
    while_continue: /* CIL Label */ ;
#line 358
    if (! (len > 0U)) {
#line 358
      goto while_break;
    }
    {
#line 360
    tmp___0 = is_wordmidchar((int )*p);
    }
#line 360
    if (! tmp___0) {
#line 362
      goto while_break;
    }
#line 364
    (*ptoklen) ++;
#line 365
    p ++;
#line 366
    len --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 368
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 368
    if (*ptoklen >= 3U) {
      {
#line 368
      tmp___1 = is_wordendchar((int )*(p - 1));
      }
#line 368
      if (tmp___1) {
#line 368
        goto while_break___0;
      }
    } else {
#line 368
      goto while_break___0;
    }
#line 370
    (*ptoklen) --;
#line 371
    p --;
#line 372
    len ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 374
  if (*ptoklen < 3U) {
#line 376
    return ((bool_t )0);
  }
#line 379
  return ((bool_t )1);
}
}
#line 382 "/home/june/collector/temp/bmf-0.9.4/lex.c"
__inline static bool_t is_ignoredheader(cpchar p , uint len , uint *ptoklen ) 
{ 
  int lo ;
  int hi ;
  int mid ;
  int minlen ;
  int cmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;

  {
#line 386
  hi = (int )(g_nignoredheaders - 1U);
#line 387
  lo = -1;
  {
#line 388
  while (1) {
    while_continue: /* CIL Label */ ;
#line 388
    if (! (hi - lo > 1)) {
#line 388
      goto while_break;
    }
    {
#line 390
    mid = (hi + lo) / 2;
#line 391
    tmp___1 = strlen(g_ignoredheaders[mid]);
    }
#line 391
    if (tmp___1 < (size_t )len) {
      {
#line 391
      tmp___0 = strlen(g_ignoredheaders[mid]);
#line 391
      minlen = (int )tmp___0;
      }
    } else {
#line 391
      minlen = (int )len;
    }
    {
#line 392
    cmp = strncasecmp(g_ignoredheaders[mid], p, (size_t )minlen);
    }
#line 393
    if (cmp >= 0) {
#line 394
      hi = mid;
    } else {
#line 396
      lo = mid;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 398
  tmp___4 = strlen(g_ignoredheaders[hi]);
  }
#line 398
  if (tmp___4 < (size_t )len) {
    {
#line 398
    tmp___3 = strlen(g_ignoredheaders[hi]);
#line 398
    minlen = (int )tmp___3;
    }
  } else {
#line 398
    minlen = (int )len;
  }
#line 399
  if (len == (uint )minlen) {
#line 401
    return ((bool_t )0);
  } else {
    {
#line 399
    tmp___5 = strncasecmp(g_ignoredheaders[hi], p, (size_t )minlen);
    }
#line 399
    if (tmp___5 != 0) {
#line 401
      return ((bool_t )0);
    }
  }
#line 403
  *ptoklen = len;
#line 404
  return ((bool_t )1);
}
}
#line 407 "/home/june/collector/temp/bmf-0.9.4/lex.c"
__inline static bool_t is_mailerid(cpchar p , uint len , uint *ptoklen ) 
{ 
  int tmp ;

  {
#line 409
  if (len < 4U) {
#line 411
    return ((bool_t )0);
  } else {
    {
#line 409
    tmp = strncmp(p, "\tid ", (size_t )4);
    }
#line 409
    if (tmp != 0) {
#line 411
      return ((bool_t )0);
    }
  }
#line 413
  *ptoklen = len;
#line 414
  return ((bool_t )1);
}
}
#line 417 "/home/june/collector/temp/bmf-0.9.4/lex.c"
__inline static bool_t is_spamtext(cpchar p , uint len , uint *ptoklen ) 
{ 
  int tmp ;

  {
#line 419
  if (len < 5U) {
#line 421
    return ((bool_t )0);
  } else {
    {
#line 419
    tmp = strncmp(p, "SPAM:", (size_t )5);
    }
#line 419
    if (tmp != 0) {
#line 421
      return ((bool_t )0);
    }
  }
#line 423
  *ptoklen = len;
#line 424
  return ((bool_t )1);
}
}
#line 427 "/home/june/collector/temp/bmf-0.9.4/lex.c"
__inline static bool_t is_smtpid(cpchar p , uint len , uint *ptoklen ) 
{ 
  int tmp ;

  {
#line 429
  if (len < 8U) {
#line 431
    return ((bool_t )0);
  } else {
    {
#line 429
    tmp = strncmp(p, "SMTP id ", (size_t )8);
    }
#line 429
    if (tmp != 0) {
#line 431
      return ((bool_t )0);
    }
  }
#line 433
  *ptoklen = len;
#line 434
  return ((bool_t )1);
}
}
#line 437 "/home/june/collector/temp/bmf-0.9.4/lex.c"
__inline static bool_t is_boundaryequal(cpchar p , uint len , uint *ptoklen ) 
{ 
  int tmp ;

  {
#line 439
  if (len < 9U) {
#line 441
    return ((bool_t )0);
  } else {
    {
#line 439
    tmp = strncmp(p, "boundary=", (size_t )9);
    }
#line 439
    if (tmp != 0) {
#line 441
      return ((bool_t )0);
    }
  }
#line 443
  *ptoklen = len;
#line 444
  return ((bool_t )1);
}
}
#line 447 "/home/june/collector/temp/bmf-0.9.4/lex.c"
__inline static bool_t is_nameequal(cpchar p , uint len , uint *ptoklen ) 
{ 
  int tmp ;

  {
#line 449
  if (len < 6U) {
#line 451
    return ((bool_t )0);
  } else {
    {
#line 449
    tmp = strncmp(p, "name=\"", (size_t )6);
    }
#line 449
    if (tmp != 0) {
#line 451
      return ((bool_t )0);
    }
  }
#line 453
  *ptoklen = (uint )6;
#line 454
  return ((bool_t )1);
}
}
#line 457 "/home/june/collector/temp/bmf-0.9.4/lex.c"
__inline static bool_t is_filenameequal(cpchar p , uint len , uint *ptoklen ) 
{ 
  int tmp ;

  {
#line 459
  if (len < 10U) {
#line 461
    return ((bool_t )0);
  } else {
    {
#line 459
    tmp = strncmp(p, "filename=\"", (size_t )10);
    }
#line 459
    if (tmp != 0) {
#line 461
      return ((bool_t )0);
    }
  }
#line 463
  *ptoklen = (uint )10;
#line 464
  return ((bool_t )1);
}
}
#line 467 "/home/june/collector/temp/bmf-0.9.4/lex.c"
__inline static bool_t is_from(cpchar p , uint len , uint *ptoklen ) 
{ 
  int tmp ;

  {
#line 469
  if (len < 5U) {
#line 471
    return ((bool_t )0);
  } else {
    {
#line 469
    tmp = strncmp(p, "From ", (size_t )5);
    }
#line 469
    if (tmp != 0) {
#line 471
      return ((bool_t )0);
    }
  }
#line 473
  *ptoklen = (uint )5;
#line 474
  return ((bool_t )1);
}
}
#line 479 "/home/june/collector/temp/bmf-0.9.4/lex.c"
void lex_create(lex_t *pthis , mbox_t mboxtype ) 
{ 


  {
#line 481
  pthis->mboxtype = mboxtype;
#line 482
  pthis->section = (msgsec_t )0;
#line 483
  pthis->pos = (uint )0;
#line 484
  pthis->bom = (uint )0;
#line 485
  pthis->eom = (uint )0;
#line 486
  pthis->lineend = (uint )0;
#line 487
  pthis->buflen = (uint )0;
#line 488
  pthis->pbuf = (char *)((void *)0);
#line 489
  return;
}
}
#line 491 "/home/june/collector/temp/bmf-0.9.4/lex.c"
void lex_destroy(lex_t *pthis ) 
{ 


  {
  {
#line 493
  free((void *)pthis->pbuf);
  }
#line 494
  return;
}
}
#line 496 "/home/june/collector/temp/bmf-0.9.4/lex.c"
bool_t lex_load(lex_t *pthis , int fd ) 
{ 
  uint nalloc ;
  ssize_t nread ;
  void *tmp ;
  char *pnewbuf ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 501
  nalloc = (uint )4096;
#line 502
  tmp = malloc((size_t )4096);
#line 502
  pthis->pbuf = (char *)tmp;
  }
#line 503
  if ((unsigned long )pthis->pbuf == (unsigned long )((void *)0)) {
#line 505
    return ((bool_t )0);
  }
  {
#line 508
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 508
    nread = read(fd, (void *)(pthis->pbuf + pthis->buflen), (size_t )(nalloc - pthis->buflen));
    }
#line 508
    if (! (nread > 0L)) {
#line 508
      goto while_break;
    }
#line 510
    pthis->buflen = (uint )((ssize_t )pthis->buflen + nread);
#line 511
    if (pthis->buflen == nalloc) {
      {
#line 514
      nalloc += 4096U;
#line 515
      tmp___0 = realloc((void *)pthis->pbuf, (size_t )nalloc);
#line 515
      pnewbuf = (char *)tmp___0;
      }
#line 516
      if ((unsigned long )pnewbuf == (unsigned long )((void *)0)) {
        {
#line 518
        free((void *)pthis->pbuf);
#line 519
        pthis->pbuf = (char *)((void *)0);
        }
#line 520
        return ((bool_t )0);
      }
#line 522
      pthis->pbuf = pnewbuf;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 525
  if (nread < 0L) {
    {
#line 527
    free((void *)pthis->pbuf);
#line 528
    pthis->pbuf = (char *)((void *)0);
    }
#line 529
    return ((bool_t )0);
  }
#line 531
  if ((unsigned int )pthis->mboxtype == 0U) {
#line 533
    if (pthis->buflen > 5U) {
      {
#line 533
      tmp___1 = memcmp((void const   *)pthis->pbuf, (void const   *)"From ", (size_t )5);
      }
#line 533
      if (tmp___1 == 0) {
        {
#line 535
        verbose(1, "Input looks like an mbox\n");
#line 536
        pthis->mboxtype = (mbox_t )1;
        }
      } else {
        {
#line 540
        verbose(1, "Input looks like a maildir\n");
#line 541
        pthis->mboxtype = (mbox_t )2;
        }
      }
    } else {
      {
#line 540
      verbose(1, "Input looks like a maildir\n");
#line 541
      pthis->mboxtype = (mbox_t )2;
      }
    }
  }
#line 545
  return ((bool_t )1);
}
}
#line 548 "/home/june/collector/temp/bmf-0.9.4/lex.c"
static bool_t lex_nextline(lex_t *pthis ) 
{ 
  cpchar pbuf ;
  uint len ;
  uint toklen ;
  bool_t tmp ;
  bool_t tmp___0 ;
  bool_t tmp___1 ;
  bool_t tmp___2 ;
  bool_t tmp___3 ;

  {
  again: 
#line 556
  pthis->pos = pthis->lineend;
#line 557
  if (pthis->lineend == pthis->buflen) {
#line 559
    return ((bool_t )0);
  }
#line 562
  pbuf = (cpchar )(pthis->pbuf + pthis->pos);
#line 563
  len = (uint )0;
  {
#line 564
  while (1) {
    while_continue: /* CIL Label */ ;
#line 564
    if (pthis->pos + len < pthis->buflen) {
#line 564
      if (! ((int const   )*(pbuf + len) != 10)) {
#line 564
        goto while_break;
      }
    } else {
#line 564
      goto while_break;
    }
#line 566
    len ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 568
  if (pthis->pos + len < pthis->buflen) {
#line 570
    len ++;
  }
  {
#line 573
  pthis->lineend = pthis->pos + len;
#line 576
  tmp = is_base64(pbuf, len, & toklen);
  }
#line 576
  if (tmp) {
#line 583
    pthis->pos += toklen;
#line 584
    goto again;
  } else {
    {
#line 576
    tmp___0 = is_ignoredheader(pbuf, len, & toklen);
    }
#line 576
    if (tmp___0) {
#line 583
      pthis->pos += toklen;
#line 584
      goto again;
    } else {
      {
#line 576
      tmp___1 = is_mailerid(pbuf, len, & toklen);
      }
#line 576
      if (tmp___1) {
#line 583
        pthis->pos += toklen;
#line 584
        goto again;
      } else {
        {
#line 576
        tmp___2 = is_mimeboundary(pbuf, len, & toklen);
        }
#line 576
        if (tmp___2) {
#line 583
          pthis->pos += toklen;
#line 584
          goto again;
        } else {
          {
#line 576
          tmp___3 = is_spamtext(pbuf, len, & toklen);
          }
#line 576
          if (tmp___3) {
#line 583
            pthis->pos += toklen;
#line 584
            goto again;
          }
        }
      }
    }
  }
#line 587
  return ((bool_t )1);
}
}
#line 590 "/home/june/collector/temp/bmf-0.9.4/lex.c"
void lex_nexttoken(lex_t *pthis , tok_t *ptok ) 
{ 
  cpchar pbuf ;
  uint len ;
  uint toklen ;
  bool_t tmp ;
  bool_t tmp___0 ;
  bool_t tmp___1 ;
  bool_t tmp___2 ;
  bool_t tmp___3 ;
  bool_t tmp___4 ;
  bool_t tmp___5 ;
  bool_t tmp___6 ;
  bool_t tmp___7 ;
  bool_t tmp___8 ;
  bool_t tmp___9 ;

  {
#line 598
  if (pthis->pos == pthis->eom) {
#line 600
    pthis->bom = pthis->pos;
  }
  again: 
  {
#line 605
  while (1) {
    while_continue: /* CIL Label */ ;
#line 605
    if (pthis->pos != pthis->lineend) {
      {
#line 605
      tmp = is_whitespace((int )*(pthis->pbuf + pthis->pos));
      }
#line 605
      if (! tmp) {
#line 605
        goto while_break;
      }
    } else {
#line 605
      goto while_break;
    }
#line 607
    (pthis->pos) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 610
  pbuf = (cpchar )(pthis->pbuf + pthis->pos);
#line 611
  len = pthis->lineend - pthis->pos;
#line 615
  if (pthis->pos == pthis->lineend) {
    {
#line 617
    tmp___0 = lex_nextline(pthis);
    }
#line 617
    if (! tmp___0) {
#line 619
      pthis->eom = pthis->pos;
#line 620
      ptok->tt = (toktype_t )1;
#line 621
      return;
    }
#line 624
    pbuf = (cpchar )(pthis->pbuf + pthis->pos);
#line 625
    len = pthis->lineend - pthis->pos;
#line 627
    if ((unsigned int )pthis->mboxtype == 1U) {
      {
#line 629
      tmp___1 = is_from(pbuf, len, & toklen);
      }
#line 629
      if (tmp___1) {
#line 631
        pthis->eom = pthis->pos;
#line 632
        ptok->tt = (toktype_t )0;
#line 633
        ptok->p = pthis->pbuf + pthis->pos;
#line 634
        ptok->len = toklen;
#line 635
        pthis->pos += toklen;
#line 636
        return;
      }
    }
#line 640
    goto again;
  }
  {
#line 643
  tmp___2 = is_htmltag(pbuf, len, & toklen);
  }
#line 643
  if (tmp___2) {
#line 651
    pthis->pos += toklen;
#line 652
    goto again;
  } else {
    {
#line 643
    tmp___3 = is_htmlcomment(pbuf, len, & toklen);
    }
#line 643
    if (tmp___3) {
#line 651
      pthis->pos += toklen;
#line 652
      goto again;
    } else {
      {
#line 643
      tmp___4 = is_smtpid(pbuf, len, & toklen);
      }
#line 643
      if (tmp___4) {
#line 651
        pthis->pos += toklen;
#line 652
        goto again;
      } else {
        {
#line 643
        tmp___5 = is_boundaryequal(pbuf, len, & toklen);
        }
#line 643
        if (tmp___5) {
#line 651
          pthis->pos += toklen;
#line 652
          goto again;
        } else {
          {
#line 643
          tmp___6 = is_nameequal(pbuf, len, & toklen);
          }
#line 643
          if (tmp___6) {
#line 651
            pthis->pos += toklen;
#line 652
            goto again;
          } else {
            {
#line 643
            tmp___7 = is_filenameequal(pbuf, len, & toklen);
            }
#line 643
            if (tmp___7) {
#line 651
              pthis->pos += toklen;
#line 652
              goto again;
            }
          }
        }
      }
    }
  }
  {
#line 655
  tmp___8 = is_ipaddr(pbuf, len, & toklen);
  }
#line 655
  if (tmp___8) {
#line 657
    ptok->tt = (toktype_t )2;
#line 658
    ptok->p = pthis->pbuf + pthis->pos;
#line 659
    ptok->len = toklen;
#line 660
    pthis->pos += toklen;
#line 661
    return;
  }
  {
#line 663
  tmp___9 = is_word(pbuf, len, & toklen);
  }
#line 663
  if (tmp___9) {
#line 665
    ptok->tt = (toktype_t )2;
#line 666
    ptok->p = pthis->pbuf + pthis->pos;
#line 667
    ptok->len = toklen;
#line 668
    pthis->pos += toklen;
#line 669
    if (toklen > 20U) {
#line 671
      goto again;
    }
#line 673
    return;
  }
#line 677
  (pthis->pos) ++;
#line 678
  goto again;
}
}
#line 682 "/home/june/collector/temp/bmf-0.9.4/lex.c"
void lex_passthru(lex_t *pthis , bool_t is_spam , double hits ) 
{ 
  char szbuf[256] ;
  bool_t ign_header ;
  cpchar pbuf ;
  uint len ;
  int tmp ;
  size_t tmp___0 ;

  {
#line 685
  ign_header = (bool_t )0;
#line 690
  pthis->pos = pthis->bom;
#line 691
  if (is_spam) {
    {
#line 693
    sprintf((char */* __restrict  */)(szbuf), (char const   */* __restrict  */)"X-Spam-Status: Yes, hits=%f required=%f, tests=bmf\nX-Spam-Flag: YES\n",
            hits, 0.9);
    }
  } else {
    {
#line 699
    sprintf((char */* __restrict  */)(szbuf), (char const   */* __restrict  */)"X-Spam-Status: No, hits=%f required=%f\n",
            hits, 0.9);
    }
  }
  {
#line 704
  while (1) {
    while_continue: /* CIL Label */ ;
#line 704
    if (! (pthis->pos < pthis->eom)) {
#line 704
      goto while_break;
    }
#line 706
    pbuf = (cpchar )(pthis->pbuf + pthis->pos);
#line 707
    len = (uint )0;
    {
#line 708
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 708
      if (pthis->pos + len < pthis->buflen) {
#line 708
        if (! ((int const   )*(pbuf + len) != 10)) {
#line 708
          goto while_break___0;
        }
      } else {
#line 708
        goto while_break___0;
      }
#line 710
      len ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 712
    if (pthis->pos + len < pthis->buflen) {
#line 714
      len ++;
    }
#line 718
    if ((int const   )*(pbuf + 0) == 10) {
#line 721
      goto while_break;
    } else
#line 718
    if ((int const   )*(pbuf + 0) == 13) {
#line 718
      if ((int const   )*(pbuf + 1) == 10) {
#line 721
        goto while_break;
      }
    }
#line 725
    if (ign_header) {
#line 725
      if (! ((int const   )*(pbuf + 0) == 32)) {
#line 725
        if (! ((int const   )*(pbuf + 0) == 9)) {
#line 725
          goto _L;
        }
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 727
      tmp = strncasecmp(pbuf, "X-Spam-", (size_t )7);
      }
#line 727
      if (tmp == 0) {
#line 728
        ign_header = (bool_t )1;
      } else {
        {
#line 731
        write(1, (void const   *)pbuf, (size_t )len);
#line 732
        ign_header = (bool_t )0;
        }
      }
    }
#line 735
    pthis->pos += len;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 739
  tmp___0 = strlen((char const   *)(szbuf));
#line 739
  write(1, (void const   *)(szbuf), tmp___0);
  }
#line 742
  if (pthis->pos < pthis->eom) {
    {
#line 744
    write(1, (void const   *)(pthis->pbuf + pthis->pos), (size_t )(pthis->eom - pthis->pos));
    }
  }
#line 746
  pthis->bom = pthis->eom;
#line 747
  return;
}
}
#line 124 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 14 "/home/june/collector/temp/bmf-0.9.4/str.h"
void strlwr(char *s ) ;
#line 15
void strcpylwr(char *d , char const   *s ) ;
#line 24
void str_create(str_t *pstr ) ;
#line 25
void str_destroy(str_t *pstr ) ;
#line 27
int str_cmp(str_t const   *pthis , str_t const   *pother ) ;
#line 14 "/home/june/collector/temp/bmf-0.9.4/str.c"
void strlwr(char *s ) 
{ 
  int tmp ;

  {
  {
#line 16
  while (1) {
    while_continue: /* CIL Label */ ;
#line 16
    if (! ((int )*s != 0)) {
#line 16
      goto while_break;
    }
    {
#line 18
    tmp = tolower((int )*s);
#line 18
    *s = (char )tmp;
#line 19
    s ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 21
  return;
}
}
#line 23 "/home/june/collector/temp/bmf-0.9.4/str.c"
void strcpylwr(char *d , char const   *s ) 
{ 
  char *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 25
  while (1) {
    while_continue: /* CIL Label */ ;
#line 25
    if (! ((int const   )*s != 0)) {
#line 25
      goto while_break;
    }
    {
#line 27
    tmp = d;
#line 27
    d ++;
#line 27
    tmp___0 = s;
#line 27
    s ++;
#line 27
    tmp___1 = tolower((int )*tmp___0);
#line 27
    *tmp = (char )tmp___1;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 29
  return;
}
}
#line 31 "/home/june/collector/temp/bmf-0.9.4/str.c"
void strncpylwr(char *d , char const   *s , int n ) 
{ 
  char *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 33
  while (1) {
    while_continue: /* CIL Label */ ;
#line 33
    tmp___2 = n;
#line 33
    n --;
#line 33
    if (! tmp___2) {
#line 33
      goto while_break;
    }
    {
#line 35
    tmp = d;
#line 35
    d ++;
#line 35
    tmp___0 = s;
#line 35
    s ++;
#line 35
    tmp___1 = tolower((int )*tmp___0);
#line 35
    *tmp = (char )tmp___1;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 37
  return;
}
}
#line 39 "/home/june/collector/temp/bmf-0.9.4/str.c"
void str_create(str_t *pstr ) 
{ 


  {
#line 41
  pstr->p = (char *)((void *)0);
#line 42
  pstr->len = (uint )0;
#line 43
  return;
}
}
#line 45 "/home/june/collector/temp/bmf-0.9.4/str.c"
void str_destroy(str_t *pstr ) 
{ 


  {
#line 48
  return;
}
}
#line 50 "/home/june/collector/temp/bmf-0.9.4/str.c"
int str_cmp(str_t const   *pthis , str_t const   *pother ) 
{ 
  uint minlen ;
  uint tmp ;
  int cmp ;

  {
#line 52
  if (pthis->len < pother->len) {
#line 52
    tmp = pthis->len;
  } else {
#line 52
    tmp = pother->len;
  }
  {
#line 52
  minlen = (uint )tmp;
#line 56
  cmp = strncmp((char const   *)pthis->p, (char const   *)pother->p, (size_t )minlen);
  }
#line 58
  if (cmp == 0) {
#line 58
    if (pthis->len != pother->len) {
#line 60
      if (pthis->len < pother->len) {
#line 60
        cmp = -1;
      } else {
#line 60
        cmp = 1;
      }
    }
  }
#line 62
  return (cmp);
}
}
#line 65 "/home/june/collector/temp/bmf-0.9.4/str.c"
int str_casecmp(str_t const   *pthis , str_t const   *pother ) 
{ 
  uint minlen ;
  uint tmp ;
  int cmp ;

  {
#line 67
  if (pthis->len < pother->len) {
#line 67
    tmp = pthis->len;
  } else {
#line 67
    tmp = pother->len;
  }
  {
#line 67
  minlen = (uint )tmp;
#line 71
  cmp = strncasecmp((char const   *)pthis->p, (char const   *)pother->p, (size_t )minlen);
  }
#line 73
  if (cmp == 0) {
#line 73
    if (pthis->len != pother->len) {
#line 75
      if (pthis->len < pother->len) {
#line 75
        cmp = -1;
      } else {
#line 75
        cmp = 1;
      }
    }
  }
#line 77
  return (cmp);
}
}
#line 494 "/home/june/collector/temp/bmf-0.9.4/dbmysql.c"
dbh_t *dbmysql_db_open(cpchar dbhost , cpchar dbname , cpchar dbuser , cpchar dbpass ) 
{ 


  {
#line 496
  return ((dbh_t *)((void *)0));
}
}
#line 765 "/usr/include/stdlib.h"
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 50 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 33 "/home/june/collector/temp/bmf-0.9.4/vec.h"
void vec_addhead(vec_t *pthis , str_t *pstr ) ;
#line 35
void vec_delhead(vec_t *pthis ) ;
#line 36
void vec_deltail(vec_t *pthis ) ;
#line 39
void vec_last(vec_t *pthis , veciter_t *piter ) ;
#line 42
void svec_add(vec_t *pthis , str_t *pstr ) ;
#line 43
str_t *svec_find(vec_t *pthis , str_t *pstr ) ;
#line 50
bool_t veciter_equal(veciter_t *pthis , veciter_t *pthat ) ;
#line 51
bool_t veciter_hasitem(veciter_t *pthis ) ;
#line 52
bool_t veciter_prev(veciter_t *pthis ) ;
#line 54
void veciter_addafter(veciter_t *pthis , str_t *pstr ) ;
#line 55
void veciter_addbefore(veciter_t *pthis , str_t *pstr ) ;
#line 56
void veciter_del(veciter_t *pthis ) ;
#line 26 "/home/june/collector/temp/bmf-0.9.4/vec.c"
void vec_create(vec_t *pthis ) 
{ 
  void *tmp ;

  {
  {
#line 28
  pthis->nalloc = (uint )256;
#line 29
  pthis->nitems = (uint )0;
#line 30
  tmp = malloc(256UL * sizeof(str_t ));
#line 30
  pthis->pitems = (str_t *)tmp;
  }
#line 31
  return;
}
}
#line 33 "/home/june/collector/temp/bmf-0.9.4/vec.c"
void vec_destroy(vec_t *pthis ) 
{ 


  {
  {
#line 35
  free((void *)pthis->pitems);
  }
#line 36
  return;
}
}
#line 38 "/home/june/collector/temp/bmf-0.9.4/vec.c"
static void vec_setsize(vec_t *pthis , uint nsize ) 
{ 
  uint nnewalloc ;
  str_t *pnewitems ;
  uint n ;
  void *tmp ;

  {
#line 40
  if (nsize > pthis->nalloc) {
#line 46
    nnewalloc = pthis->nalloc * 2U;
#line 47
    if (nnewalloc < nsize) {
#line 47
      nnewalloc = nsize;
    }
    {
#line 48
    tmp = realloc((void *)pthis->pitems, (unsigned long )nnewalloc * sizeof(str_t ));
#line 48
    pnewitems = (str_t *)tmp;
    }
#line 49
    if ((unsigned long )pnewitems == (unsigned long )((void *)0)) {
      {
#line 51
      exit(2);
      }
    }
#line 53
    n = pthis->nitems;
    {
#line 53
    while (1) {
      while_continue: /* CIL Label */ ;
#line 53
      if (! (n < nsize)) {
#line 53
        goto while_break;
      }
      {
#line 55
      str_create(pnewitems + n);
#line 53
      n ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 57
    pthis->pitems = pnewitems;
#line 58
    pthis->nalloc = nnewalloc;
  }
#line 60
  return;
}
}
#line 62 "/home/june/collector/temp/bmf-0.9.4/vec.c"
void vec_addhead(vec_t *pthis , str_t *pstr ) 
{ 


  {
  {
#line 66
  vec_setsize(pthis, pthis->nitems + 1U);
#line 67
  memmove((void *)(pthis->pitems + 1), (void const   *)(pthis->pitems + 0), (unsigned long )pthis->nitems * sizeof(str_t ));
#line 68
  *(pthis->pitems + 0) = *pstr;
#line 69
  (pthis->nitems) ++;
  }
#line 70
  return;
}
}
#line 72 "/home/june/collector/temp/bmf-0.9.4/vec.c"
void vec_addtail(vec_t *pthis , str_t *pstr ) 
{ 


  {
  {
#line 76
  vec_setsize(pthis, pthis->nitems + 1U);
#line 77
  *(pthis->pitems + pthis->nitems) = *pstr;
#line 78
  (pthis->nitems) ++;
  }
#line 79
  return;
}
}
#line 81 "/home/june/collector/temp/bmf-0.9.4/vec.c"
void vec_delhead(vec_t *pthis ) 
{ 


  {
  {
#line 84
  (pthis->nitems) --;
#line 85
  memmove((void *)(pthis->pitems + 0), (void const   *)(pthis->pitems + 1), (unsigned long )pthis->nitems * sizeof(str_t ));
  }
#line 86
  return;
}
}
#line 88 "/home/june/collector/temp/bmf-0.9.4/vec.c"
void vec_deltail(vec_t *pthis ) 
{ 


  {
#line 91
  (pthis->nitems) --;
#line 92
  return;
}
}
#line 94 "/home/june/collector/temp/bmf-0.9.4/vec.c"
void vec_first(vec_t *pthis , veciter_t *piter ) 
{ 


  {
#line 96
  piter->plist = pthis;
#line 97
  piter->index = (uint )0;
#line 98
  return;
}
}
#line 100 "/home/june/collector/temp/bmf-0.9.4/vec.c"
void vec_last(vec_t *pthis , veciter_t *piter ) 
{ 


  {
#line 102
  piter->plist = pthis;
#line 103
  piter->index = pthis->nitems;
#line 104
  return;
}
}
#line 110 "/home/june/collector/temp/bmf-0.9.4/vec.c"
static int svec_compare(void const   *p1 , void const   *p2 ) 
{ 
  int tmp ;

  {
  {
#line 112
  tmp = str_casecmp((str_t const   *)p1, (str_t const   *)p2);
  }
#line 112
  return (tmp);
}
}
#line 115 "/home/june/collector/temp/bmf-0.9.4/vec.c"
void svec_add(vec_t *pthis , str_t *pstr ) 
{ 
  int lo ;
  int hi ;
  int mid ;
  veciter_t iter ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 120
  if (pthis->nitems == 0U) {
    {
#line 122
    vec_addtail(pthis, pstr);
    }
#line 123
    return;
  }
  {
#line 126
  tmp = str_casecmp((str_t const   *)pstr, (str_t const   *)(pthis->pitems + 0));
  }
#line 126
  if (tmp < 0) {
    {
#line 128
    vec_addhead(pthis, pstr);
    }
#line 129
    return;
  }
#line 132
  hi = (int )(pthis->nitems - 1U);
#line 133
  lo = -1;
  {
#line 134
  while (1) {
    while_continue: /* CIL Label */ ;
#line 134
    if (! (hi - lo > 1)) {
#line 134
      goto while_break;
    }
    {
#line 136
    mid = (hi + lo) / 2;
#line 137
    tmp___0 = str_casecmp((str_t const   *)pstr, (str_t const   *)(pthis->pitems + mid));
    }
#line 137
    if (tmp___0 <= 0) {
#line 138
      hi = mid;
    } else {
#line 140
      lo = mid;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 144
  iter.plist = pthis;
#line 145
  iter.index = (uint )hi;
#line 147
  tmp___1 = str_casecmp((str_t const   *)pstr, (str_t const   *)(pthis->pitems + hi));
  }
#line 147
  if (tmp___1 < 0) {
    {
#line 149
    veciter_addbefore(& iter, pstr);
    }
  } else {
    {
#line 153
    veciter_addafter(& iter, pstr);
    }
  }
#line 155
  return;
}
}
#line 157 "/home/june/collector/temp/bmf-0.9.4/vec.c"
str_t *svec_find(vec_t *pthis , str_t *pstr ) 
{ 
  int lo ;
  int hi ;
  int mid ;
  int tmp ;
  int tmp___0 ;

  {
#line 161
  if (pthis->nitems == 0U) {
#line 163
    return ((str_t *)((void *)0));
  }
#line 166
  hi = (int )(pthis->nitems - 1U);
#line 167
  lo = -1;
  {
#line 168
  while (1) {
    while_continue: /* CIL Label */ ;
#line 168
    if (! (hi - lo > 1)) {
#line 168
      goto while_break;
    }
    {
#line 170
    mid = (hi + lo) / 2;
#line 171
    tmp = str_casecmp((str_t const   *)pstr, (str_t const   *)(pthis->pitems + mid));
    }
#line 171
    if (tmp <= 0) {
#line 172
      hi = mid;
    } else {
#line 174
      lo = mid;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 178
  tmp___0 = str_casecmp((str_t const   *)pstr, (str_t const   *)(pthis->pitems + hi));
  }
#line 178
  if (tmp___0 != 0) {
#line 180
    return ((str_t *)((void *)0));
  }
#line 183
  return (pthis->pitems + hi);
}
}
#line 186 "/home/june/collector/temp/bmf-0.9.4/vec.c"
void svec_sort(vec_t *pthis ) 
{ 


  {
#line 188
  if (pthis->nitems > 1U) {
    {
#line 190
    qsort((void *)pthis->pitems, (size_t )pthis->nitems, sizeof(str_t ), & svec_compare);
    }
  }
#line 192
  return;
}
}
#line 198 "/home/june/collector/temp/bmf-0.9.4/vec.c"
void veciter_destroy(veciter_t *pthis ) 
{ 


  {
#line 201
  return;
}
}
#line 203 "/home/june/collector/temp/bmf-0.9.4/vec.c"
str_t *veciter_get(veciter_t *pthis ) 
{ 


  {
#line 205
  if ((unsigned long )pthis->plist == (unsigned long )((void *)0)) {
#line 207
    return ((str_t *)((void *)0));
  } else
#line 205
  if (pthis->index >= (pthis->plist)->nitems) {
#line 207
    return ((str_t *)((void *)0));
  }
#line 210
  return ((pthis->plist)->pitems + pthis->index);
}
}
#line 213 "/home/june/collector/temp/bmf-0.9.4/vec.c"
bool_t veciter_equal(veciter_t *pthis , veciter_t *pthat ) 
{ 


  {
#line 215
  if ((unsigned long )pthis->plist != (unsigned long )pthat->plist) {
#line 218
    return ((bool_t )0);
  } else
#line 215
  if (pthis->index != pthat->index) {
#line 218
    return ((bool_t )0);
  }
#line 221
  return ((bool_t )1);
}
}
#line 224 "/home/june/collector/temp/bmf-0.9.4/vec.c"
bool_t veciter_hasitem(veciter_t *pthis ) 
{ 


  {
#line 226
  if ((unsigned long )pthis->plist == (unsigned long )((void *)0)) {
#line 228
    return ((bool_t )0);
  } else
#line 226
  if (pthis->index >= (pthis->plist)->nitems) {
#line 228
    return ((bool_t )0);
  }
#line 230
  return ((bool_t )1);
}
}
#line 233 "/home/june/collector/temp/bmf-0.9.4/vec.c"
bool_t veciter_prev(veciter_t *pthis ) 
{ 


  {
#line 235
  if (pthis->index == 0U) {
#line 237
    return ((bool_t )0);
  }
#line 239
  (pthis->index) --;
#line 240
  return ((bool_t )1);
}
}
#line 243 "/home/june/collector/temp/bmf-0.9.4/vec.c"
bool_t veciter_next(veciter_t *pthis ) 
{ 


  {
#line 245
  (pthis->index) ++;
#line 246
  if (pthis->index == (pthis->plist)->nitems) {
#line 248
    return ((bool_t )0);
  }
#line 250
  return ((bool_t )1);
}
}
#line 253 "/home/june/collector/temp/bmf-0.9.4/vec.c"
void veciter_addafter(veciter_t *pthis , str_t *pstr ) 
{ 
  str_t *pitems ;

  {
  {
#line 257
  vec_setsize(pthis->plist, (pthis->plist)->nitems + 1U);
#line 259
  pitems = (pthis->plist)->pitems;
  }
#line 261
  if (pthis->index != (pthis->plist)->nitems - 1U) {
    {
#line 263
    memmove((void *)(pitems + (pthis->index + 2U)), (void const   *)(pitems + (pthis->index + 1U)),
            (unsigned long )(((pthis->plist)->nitems - pthis->index) - 1U) * sizeof(str_t ));
    }
  }
#line 267
  *(pitems + (pthis->index + 1U)) = *pstr;
#line 268
  ((pthis->plist)->nitems) ++;
#line 269
  return;
}
}
#line 271 "/home/june/collector/temp/bmf-0.9.4/vec.c"
void veciter_addbefore(veciter_t *pthis , str_t *pstr ) 
{ 
  str_t *pitems ;

  {
  {
#line 275
  vec_setsize(pthis->plist, (pthis->plist)->nitems + 1U);
#line 277
  pitems = (pthis->plist)->pitems;
#line 279
  memmove((void *)(pitems + (pthis->index + 1U)), (void const   *)(pitems + pthis->index),
          (unsigned long )((pthis->plist)->nitems - pthis->index) * sizeof(str_t ));
#line 282
  *(pitems + pthis->index) = *pstr;
#line 283
  ((pthis->plist)->nitems) ++;
  }
#line 284
  return;
}
}
#line 286 "/home/june/collector/temp/bmf-0.9.4/vec.c"
void veciter_del(veciter_t *pthis ) 
{ 
  str_t *pitems ;

  {
#line 291
  ((pthis->plist)->nitems) --;
#line 292
  if (pthis->index < (pthis->plist)->nitems) {
    {
#line 294
    pitems = (pthis->plist)->pitems;
#line 295
    memmove((void *)(pitems + pthis->index), (void const   *)(pitems + (pthis->index + 1U)),
            (unsigned long )((pthis->plist)->nitems - pthis->index) * sizeof(str_t ));
    }
  }
#line 298
  return;
}
}
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 433 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 846
extern void perror(char const   *__s ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 334 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                __off_t __offset ,
                                                                                int __whence ) ;
#line 1016
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ftruncate)(int __fd ,
                                                                                __off_t __length ) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 214
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 321
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) mkdir)(char const   *__path ,
                                                                                            __mode_t __mode ) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 42 "/home/june/collector/temp/bmf-0.9.4/dbtext.h"
bool_t dbtext_db_close(dbhtext_t *pthis ) ;
#line 43
dbt_t *dbtext_db_opentable(dbhtext_t *pthis , cpchar table , bool_t rdonly ) ;
#line 45
bool_t dbtext_table_close(dbttext_t *pthis ) ;
#line 46
bool_t dbtext_table_mergeclose(dbttext_t *pthis , vec_t *pmsg ) ;
#line 47
bool_t dbtext_table_unmergeclose(dbttext_t *pthis , vec_t *pmsg ) ;
#line 48
bool_t dbtext_table_import(dbttext_t *pthis , cpchar filename ) ;
#line 49
bool_t dbtext_table_export(dbttext_t *pthis , cpchar filename ) ;
#line 50
uint dbtext_table_getmsgcount(dbttext_t *pthis ) ;
#line 51
uint dbtext_table_getcount(dbttext_t *pthis , str_t *pword ) ;
#line 21 "/home/june/collector/temp/bmf-0.9.4/dbtext.c"
static void dbtext_table_setsize(dbttext_t *pthis , uint nsize ) 
{ 
  uint nnewalloc ;
  rec_t *pnewitems ;
  uint n ;
  void *tmp ;

  {
#line 23
  if (nsize > pthis->nalloc) {
#line 29
    nnewalloc = pthis->nalloc * 2U;
#line 30
    if (nnewalloc < nsize) {
#line 30
      nnewalloc = nsize;
    }
    {
#line 31
    tmp = realloc((void *)pthis->pitems, (unsigned long )nnewalloc * sizeof(rec_t ));
#line 31
    pnewitems = (rec_t *)tmp;
    }
#line 32
    if ((unsigned long )pnewitems == (unsigned long )((void *)0)) {
      {
#line 34
      exit(2);
      }
    }
#line 36
    n = pthis->nitems;
    {
#line 36
    while (1) {
      while_continue: /* CIL Label */ ;
#line 36
      if (! (n < nsize)) {
#line 36
        goto while_break;
      }
      {
#line 38
      str_create(& (pnewitems + n)->w);
#line 39
      (pnewitems + n)->n = (uint )0;
#line 36
      n ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 41
    pthis->pitems = pnewitems;
#line 42
    pthis->nalloc = nnewalloc;
  }
#line 44
  return;
}
}
#line 46 "/home/june/collector/temp/bmf-0.9.4/dbtext.c"
dbh_t *dbtext_db_open(cpchar dbhost , cpchar dbname , cpchar dbuser , cpchar dbpass ) 
{ 
  dbhtext_t *pthis ;
  uint dirlen ;
  cpchar phome ;
  struct stat st ;
  void *tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;

  {
  {
#line 54
  tmp = malloc(sizeof(dbhtext_t ));
#line 54
  pthis = (dbhtext_t *)tmp;
  }
#line 55
  if ((unsigned long )pthis == (unsigned long )((void *)0)) {
#line 57
    goto bail;
  }
#line 59
  pthis->close = & dbtext_db_close;
#line 60
  pthis->opentable = & dbtext_db_opentable;
#line 61
  if ((unsigned long )dbname != (unsigned long )((void *)0)) {
#line 61
    if ((int const   )*dbname != 0) {
      {
#line 63
      tmp___0 = strlen(dbname);
#line 63
      dirlen = (uint )tmp___0;
#line 64
      pthis->dir = strdup(dbname);
      }
#line 65
      if ((int )*(pthis->dir + (dirlen - 1U)) == 47) {
#line 67
        *(pthis->dir + (dirlen - 1U)) = (char )'\000';
      }
    } else {
#line 61
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 72
    tmp___1 = getenv("HOME");
#line 72
    phome = (cpchar )tmp___1;
    }
#line 73
    if ((unsigned long )phome == (unsigned long )((void *)0)) {
#line 75
      phome = ".";
    } else
#line 73
    if ((int const   )*phome == 0) {
#line 75
      phome = ".";
    }
    {
#line 77
    tmp___2 = strlen(phome);
#line 77
    tmp___3 = malloc((tmp___2 + 5UL) + 1UL);
#line 77
    pthis->dir = (char *)tmp___3;
    }
#line 78
    if ((unsigned long )pthis->dir == (unsigned long )((void *)0)) {
#line 80
      goto bail;
    }
    {
#line 82
    sprintf((char */* __restrict  */)pthis->dir, (char const   */* __restrict  */)"%s/.bmf",
            phome);
    }
  }
  {
#line 86
  tmp___6 = stat((char const   */* __restrict  */)pthis->dir, (struct stat */* __restrict  */)(& st));
  }
#line 86
  if (tmp___6 != 0) {
    {
#line 88
    tmp___5 = __errno_location();
    }
#line 88
    if (*tmp___5 == 2) {
      {
#line 90
      tmp___4 = mkdir((char const   *)pthis->dir, (__mode_t )448);
      }
#line 90
      if (tmp___4 != 0) {
#line 92
        goto bail;
      }
    } else {
#line 97
      goto bail;
    }
  } else
#line 102
  if (! ((st.st_mode & 61440U) == 16384U)) {
#line 104
    goto bail;
  }
#line 108
  return ((dbh_t *)pthis);
  bail: 
#line 111
  return ((dbh_t *)((void *)0));
}
}
#line 114 "/home/june/collector/temp/bmf-0.9.4/dbtext.c"
bool_t dbtext_db_close(dbhtext_t *pthis ) 
{ 


  {
  {
#line 116
  free((void *)pthis->dir);
#line 117
  pthis->dir = (char *)((void *)0);
  }
#line 118
  return ((bool_t )1);
}
}
#line 121 "/home/june/collector/temp/bmf-0.9.4/dbtext.c"
dbt_t *dbtext_db_opentable(dbhtext_t *pthis , cpchar table , bool_t rdonly ) 
{ 
  dbttext_t *ptable ;
  struct flock lock ;
  char *szpath ;
  int flags ;
  struct stat st ;
  char *pbegin ;
  char *pend ;
  rec_t r ;
  uint pos ;
  void *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  ssize_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  long tmp___8 ;
  uint tmp___9 ;

  {
#line 123
  ptable = (dbttext_t *)((void *)0);
#line 128
  szpath = (char *)((void *)0);
#line 137
  if ((unsigned long )pthis->dir == (unsigned long )((void *)0)) {
#line 139
    goto bail;
  }
  {
#line 142
  tmp = malloc(sizeof(dbttext_t ));
#line 142
  ptable = (dbttext_t *)tmp;
  }
#line 143
  if ((unsigned long )ptable == (unsigned long )((void *)0)) {
    {
#line 145
    perror("malloc()");
    }
#line 146
    goto bail;
  }
  {
#line 148
  ptable->close = & dbtext_table_close;
#line 149
  ptable->mergeclose = & dbtext_table_mergeclose;
#line 150
  ptable->unmergeclose = & dbtext_table_unmergeclose;
#line 151
  ptable->import = & dbtext_table_import;
#line 152
  ptable->export = & dbtext_table_export;
#line 153
  ptable->getmsgcount = & dbtext_table_getmsgcount;
#line 154
  ptable->getcount = & dbtext_table_getcount;
#line 155
  ptable->fd = -1;
#line 156
  ptable->pbuf = (char *)((void *)0);
#line 157
  ptable->nmsgs = (uint )0;
#line 158
  ptable->nalloc = (uint )0;
#line 159
  ptable->nitems = (uint )0;
#line 160
  ptable->pitems = (rec_t *)((void *)0);
#line 162
  tmp___0 = strlen((char const   *)pthis->dir);
#line 162
  tmp___1 = strlen(table);
#line 162
  tmp___2 = malloc((tmp___0 + tmp___1) + 6UL);
#line 162
  szpath = (char *)tmp___2;
  }
#line 163
  if ((unsigned long )szpath == (unsigned long )((void *)0)) {
#line 165
    goto bail;
  }
  {
#line 167
  sprintf((char */* __restrict  */)szpath, (char const   */* __restrict  */)"%s/%s.txt",
          pthis->dir, table);
  }
#line 168
  if (rdonly) {
#line 168
    flags = 64;
  } else {
#line 168
    flags = 66;
  }
  {
#line 169
  ptable->fd = open((char const   *)szpath, flags, 420);
  }
#line 170
  if (ptable->fd == -1) {
    {
#line 172
    perror("open()");
    }
#line 173
    goto bail;
  }
  {
#line 177
  memset((void *)(& lock), 0, sizeof(lock));
  }
#line 178
  if (rdonly) {
#line 178
    lock.l_type = (short)0;
  } else {
#line 178
    lock.l_type = (short)1;
  }
  {
#line 179
  lock.l_start = (__off_t )0;
#line 180
  lock.l_whence = (short)0;
#line 181
  lock.l_len = (__off_t )0;
#line 182
  fcntl(ptable->fd, 7, & lock);
#line 185
  tmp___3 = fstat(ptable->fd, & st);
  }
#line 185
  if (tmp___3 != 0) {
    {
#line 187
    perror("fstat()");
    }
#line 188
    goto bail_uc;
  }
#line 191
  if (st.st_size == 0L) {
#line 193
    return ((dbt_t *)ptable);
  }
  {
#line 196
  tmp___4 = malloc((size_t )st.st_size);
#line 196
  ptable->pbuf = (char *)tmp___4;
  }
#line 197
  if ((unsigned long )ptable->pbuf == (unsigned long )((void *)0)) {
    {
#line 199
    perror("malloc()");
    }
#line 200
    goto bail_uc;
  }
  {
#line 203
  tmp___5 = read(ptable->fd, (void *)ptable->pbuf, (size_t )st.st_size);
  }
#line 203
  if (tmp___5 != st.st_size) {
    {
#line 205
    perror("read()");
    }
#line 206
    goto bail_fuc;
  }
  {
#line 210
  tmp___6 = sscanf((char const   */* __restrict  */)ptable->pbuf, (char const   */* __restrict  */)"# bogofilter wordlist (format version A): %u\n",
                   & ptable->nmsgs);
  }
#line 210
  if (tmp___6 != 1) {
#line 212
    goto bail_fuc;
  }
#line 214
  pbegin = ptable->pbuf;
  {
#line 215
  while (1) {
    while_continue: /* CIL Label */ ;
#line 215
    if (! ((int )*pbegin != 10)) {
#line 215
      goto while_break;
    }
#line 215
    pbegin ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 216
  pbegin ++;
#line 218
  pos = (uint )0;
  {
#line 219
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 219
    if (! ((unsigned long )pbegin < (unsigned long )(ptable->pbuf + st.st_size))) {
#line 219
      goto while_break___0;
    }
#line 221
    pend = pbegin;
#line 222
    r.w.p = pbegin;
#line 223
    r.w.len = (uint )0;
#line 224
    r.n = (uint )0;
    {
#line 226
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 226
      if (! ((int )*pend != 10)) {
#line 226
        goto while_break___1;
      }
#line 228
      if ((unsigned long )pend >= (unsigned long )(ptable->pbuf + st.st_size)) {
#line 230
        goto bail_fuc;
      }
      {
#line 232
      tmp___7 = tolower((int )*pend);
#line 232
      *pend = (char )tmp___7;
      }
#line 233
      if ((int )*pend == 32) {
        {
#line 235
        r.w.len = (uint )(pend - pbegin);
#line 236
        tmp___8 = strtol((char const   */* __restrict  */)(pend + 1), (char **/* __restrict  */)((void *)0),
                         10);
#line 236
        r.n = (uint )tmp___8;
        }
      }
#line 238
      pend ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 240
    if ((unsigned long )pend > (unsigned long )pbegin) {
#line 240
      if ((int )*pbegin != 35) {
#line 240
        if ((int )*pbegin != 59) {
#line 242
          if (r.w.len == 0U) {
            {
#line 244
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"dbh_loadfile: bad file format\n");
            }
#line 245
            goto bail_fuc;
          } else
#line 242
          if (r.w.len > 20U) {
            {
#line 244
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"dbh_loadfile: bad file format\n");
            }
#line 245
            goto bail_fuc;
          }
          {
#line 247
          dbtext_table_setsize(ptable, pos + 1U);
#line 248
          tmp___9 = pos;
#line 248
          pos ++;
#line 248
          *(ptable->pitems + tmp___9) = r;
#line 249
          ptable->nitems = pos;
          }
        }
      }
    }
#line 251
    pbegin = pend + 1;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 254
  if (rdonly) {
    {
#line 257
    lock.l_type = (short)2;
#line 258
    fcntl(ptable->fd, 7, & lock);
#line 260
    close(ptable->fd);
#line 261
    ptable->fd = -1;
    }
  }
#line 264
  return ((dbt_t *)ptable);
  bail_fuc: 
  {
#line 267
  free((void *)ptable->pbuf);
  }
  bail_uc: 
  {
#line 271
  lock.l_type = (short)2;
#line 272
  fcntl(ptable->fd, 7, & lock);
#line 275
  close(ptable->fd);
#line 276
  ptable->fd = -1;
  }
  bail: 
#line 279
  if ((unsigned long )szpath != (unsigned long )((void *)0)) {
    {
#line 281
    free((void *)szpath);
    }
  }
  {
#line 283
  free((void *)ptable);
  }
#line 284
  return ((dbt_t *)((void *)0));
}
}
#line 287 "/home/june/collector/temp/bmf-0.9.4/dbtext.c"
bool_t dbtext_table_close(dbttext_t *pthis ) 
{ 
  struct flock lockall ;

  {
  {
#line 291
  free((void *)pthis->pbuf);
#line 292
  pthis->pbuf = (char *)((void *)0);
#line 293
  free((void *)pthis->pitems);
#line 294
  pthis->pitems = (rec_t *)((void *)0);
  }
#line 296
  if (pthis->fd != -1) {
    {
#line 299
    memset((void *)(& lockall), 0, sizeof(lockall));
#line 300
    lockall.l_type = (short)2;
#line 301
    lockall.l_start = (__off_t )0;
#line 302
    lockall.l_whence = (short)0;
#line 303
    lockall.l_len = (__off_t )0;
#line 304
    fcntl(pthis->fd, 7, & lockall);
#line 306
    close(pthis->fd);
#line 307
    pthis->fd = -1;
    }
  }
#line 310
  return ((bool_t )1);
}
}
#line 313 "/home/june/collector/temp/bmf-0.9.4/dbtext.c"
bool_t dbtext_table_mergeclose(dbttext_t *pthis , vec_t *pmsg ) 
{ 
  uint pos ;
  rec_t *prec ;
  veciter_t msgiter ;
  str_t *pmsgstr ;
  uint count ;
  char iobuf[4096] ;
  char *p ;
  int tmp ;
  int cmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  bool_t tmp___6 ;

  {
#line 325
  if (pthis->fd == -1) {
#line 327
    return ((bool_t )0);
  }
  {
#line 329
  ftruncate(pthis->fd, (__off_t )0);
#line 330
  lseek(pthis->fd, (__off_t )0, 0);
#line 332
  (pthis->nmsgs) ++;
#line 334
  p = iobuf;
#line 335
  tmp = sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)"# bogofilter wordlist (format version A): %u\n",
                pthis->nmsgs);
#line 335
  p += tmp;
#line 337
  vec_first(pmsg, & msgiter);
#line 338
  pmsgstr = veciter_get(& msgiter);
#line 340
  pos = (uint )0;
  }
  {
#line 341
  while (1) {
    while_continue: /* CIL Label */ ;
#line 341
    if (! (pos < pthis->nitems)) {
#line 341
      if (! ((unsigned long )pmsgstr != (unsigned long )((void *)0))) {
#line 341
        goto while_break;
      }
    }
#line 343
    cmp = 0;
#line 344
    prec = pthis->pitems + pos;
#line 345
    if ((unsigned long )pmsgstr != (unsigned long )((void *)0)) {
#line 345
      if (pos < pthis->nitems) {
        {
#line 347
        cmp = str_casecmp((str_t const   *)(& prec->w), (str_t const   *)pmsgstr);
        }
      } else {
#line 345
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 352
    if (pos < pthis->nitems) {
#line 352
      cmp = -1;
    } else {
#line 352
      cmp = 1;
    }
#line 354
    if (cmp < 0) {
      {
#line 359
      count = prec->n;
#line 360
      strncpylwr(p, (char const   *)prec->w.p, (int )prec->w.len);
#line 360
      p += prec->w.len;
#line 361
      tmp___0 = p;
#line 361
      p ++;
#line 361
      *tmp___0 = (char )' ';
#line 362
      tmp___1 = sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)"%u\n",
                        count);
#line 362
      p += tmp___1;
#line 364
      pos ++;
      }
    } else
#line 366
    if (cmp == 0) {
      {
#line 373
      count = db_getnewcount(& msgiter);
#line 374
      count += prec->n;
#line 375
      strncpylwr(p, (char const   *)prec->w.p, (int )prec->w.len);
#line 375
      p += prec->w.len;
#line 376
      tmp___2 = p;
#line 376
      p ++;
#line 376
      *tmp___2 = (char )' ';
#line 377
      tmp___3 = sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)"%u\n",
                        count);
#line 377
      p += tmp___3;
#line 379
      pos ++;
#line 380
      veciter_next(& msgiter);
#line 381
      pmsgstr = veciter_get(& msgiter);
      }
    } else {
      {
#line 388
      count = db_getnewcount(& msgiter);
#line 389
      strncpylwr(p, (char const   *)pmsgstr->p, (int )pmsgstr->len);
#line 389
      p += pmsgstr->len;
#line 390
      tmp___4 = p;
#line 390
      p ++;
#line 390
      *tmp___4 = (char )' ';
#line 391
      tmp___5 = sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)"%u\n",
                        count);
#line 391
      p += tmp___5;
#line 393
      veciter_next(& msgiter);
#line 394
      pmsgstr = veciter_get(& msgiter);
      }
    }
#line 397
    if ((unsigned long )(p + 52) > (unsigned long )(iobuf + 1)) {
      {
#line 399
      write(pthis->fd, (void const   *)(iobuf), (size_t )(p - iobuf));
#line 400
      p = iobuf;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 403
  if ((unsigned long )p != (unsigned long )(iobuf)) {
    {
#line 405
    write(pthis->fd, (void const   *)(iobuf), (size_t )(p - iobuf));
    }
  }
  {
#line 408
  veciter_destroy(& msgiter);
#line 409
  tmp___6 = dbtext_table_close(pthis);
  }
#line 409
  return (tmp___6);
}
}
#line 412 "/home/june/collector/temp/bmf-0.9.4/dbtext.c"
bool_t dbtext_table_unmergeclose(dbttext_t *pthis , vec_t *pmsg ) 
{ 
  uint pos ;
  rec_t *prec ;
  veciter_t msgiter ;
  str_t *pmsgstr ;
  uint count ;
  char iobuf[4096] ;
  char *p ;
  int tmp ;
  int cmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  bool_t tmp___6 ;

  {
#line 424
  if (pthis->fd == -1) {
#line 426
    return ((bool_t )0);
  }
  {
#line 428
  ftruncate(pthis->fd, (__off_t )0);
#line 429
  lseek(pthis->fd, (__off_t )0, 0);
#line 431
  (pthis->nmsgs) --;
#line 433
  p = iobuf;
#line 434
  tmp = sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)"# bogofilter wordlist (format version A): %u\n",
                pthis->nmsgs);
#line 434
  p += tmp;
#line 436
  vec_first(pmsg, & msgiter);
#line 437
  pmsgstr = veciter_get(& msgiter);
#line 439
  pos = (uint )0;
  }
  {
#line 440
  while (1) {
    while_continue: /* CIL Label */ ;
#line 440
    if (! (pos < pthis->nitems)) {
#line 440
      if (! ((unsigned long )pmsgstr != (unsigned long )((void *)0))) {
#line 440
        goto while_break;
      }
    }
#line 442
    cmp = 0;
#line 443
    prec = pthis->pitems + pos;
#line 444
    if ((unsigned long )pmsgstr != (unsigned long )((void *)0)) {
#line 444
      if (pos < pthis->nitems) {
        {
#line 446
        cmp = str_casecmp((str_t const   *)(& prec->w), (str_t const   *)pmsgstr);
        }
      } else {
#line 444
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 451
    if (pos < pthis->nitems) {
#line 451
      cmp = -1;
    } else {
#line 451
      cmp = 1;
    }
#line 453
    if (cmp < 0) {
      {
#line 458
      count = prec->n;
#line 459
      strncpylwr(p, (char const   *)prec->w.p, (int )prec->w.len);
#line 459
      p += prec->w.len;
#line 460
      tmp___0 = p;
#line 460
      p ++;
#line 460
      *tmp___0 = (char )' ';
#line 461
      tmp___1 = sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)"%u\n",
                        count);
#line 461
      p += tmp___1;
#line 463
      pos ++;
      }
    } else
#line 465
    if (cmp == 0) {
      {
#line 472
      count = db_getnewcount(& msgiter);
      }
#line 473
      if (prec->n > count) {
#line 473
        count = prec->n - count;
      } else {
#line 473
        count = (uint )0;
      }
      {
#line 474
      strncpylwr(p, (char const   *)prec->w.p, (int )prec->w.len);
#line 474
      p += prec->w.len;
#line 475
      tmp___2 = p;
#line 475
      p ++;
#line 475
      *tmp___2 = (char )' ';
#line 476
      tmp___3 = sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)"%u\n",
                        count);
#line 476
      p += tmp___3;
#line 478
      pos ++;
#line 479
      veciter_next(& msgiter);
#line 480
      pmsgstr = veciter_get(& msgiter);
      }
    } else {
      {
#line 487
      db_getnewcount(& msgiter);
#line 488
      count = (uint )0;
#line 489
      strncpylwr(p, (char const   *)pmsgstr->p, (int )pmsgstr->len);
#line 489
      p += pmsgstr->len;
#line 490
      tmp___4 = p;
#line 490
      p ++;
#line 490
      *tmp___4 = (char )' ';
#line 491
      tmp___5 = sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)"%u\n",
                        count);
#line 491
      p += tmp___5;
#line 493
      veciter_next(& msgiter);
#line 494
      pmsgstr = veciter_get(& msgiter);
      }
    }
#line 497
    if ((unsigned long )(p + 52) > (unsigned long )(iobuf + 1)) {
      {
#line 499
      write(pthis->fd, (void const   *)(iobuf), (size_t )(p - iobuf));
#line 500
      p = iobuf;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 503
  if ((unsigned long )p != (unsigned long )(iobuf)) {
    {
#line 505
    write(pthis->fd, (void const   *)(iobuf), (size_t )(p - iobuf));
    }
  }
  {
#line 508
  veciter_destroy(& msgiter);
#line 509
  tmp___6 = dbtext_table_close(pthis);
  }
#line 509
  return (tmp___6);
}
}
#line 512 "/home/june/collector/temp/bmf-0.9.4/dbtext.c"
bool_t dbtext_table_import(dbttext_t *pthis , cpchar filename ) 
{ 


  {
#line 514
  return ((bool_t )0);
}
}
#line 517 "/home/june/collector/temp/bmf-0.9.4/dbtext.c"
bool_t dbtext_table_export(dbttext_t *pthis , cpchar filename ) 
{ 


  {
#line 519
  return ((bool_t )0);
}
}
#line 522 "/home/june/collector/temp/bmf-0.9.4/dbtext.c"
uint dbtext_table_getmsgcount(dbttext_t *pthis ) 
{ 


  {
#line 524
  return (pthis->nmsgs);
}
}
#line 527 "/home/june/collector/temp/bmf-0.9.4/dbtext.c"
uint dbtext_table_getcount(dbttext_t *pthis , str_t *pword ) 
{ 
  int lo ;
  int hi ;
  int mid ;
  int tmp ;
  int tmp___0 ;

  {
#line 531
  if (pthis->nitems == 0U) {
#line 533
    return ((uint )0);
  }
#line 536
  hi = (int )(pthis->nitems - 1U);
#line 537
  lo = -1;
  {
#line 538
  while (1) {
    while_continue: /* CIL Label */ ;
#line 538
    if (! (hi - lo > 1)) {
#line 538
      goto while_break;
    }
    {
#line 540
    mid = (hi + lo) / 2;
#line 541
    tmp = str_casecmp((str_t const   *)pword, (str_t const   *)(& (pthis->pitems + mid)->w));
    }
#line 541
    if (tmp <= 0) {
#line 542
      hi = mid;
    } else {
#line 544
      lo = mid;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 548
  tmp___0 = str_casecmp((str_t const   *)pword, (str_t const   *)(& (pthis->pitems + hi)->w));
  }
#line 548
  if (tmp___0 != 0) {
#line 550
    return ((uint )0);
  }
#line 553
  return ((pthis->pitems + hi)->n);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
#line 390 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 17 "/home/june/collector/temp/bmf-0.9.4/dbg.h"
void dbgout(char const   *fmt  , ...) ;
#line 17 "/home/june/collector/temp/bmf-0.9.4/dbg.c"
uint g_verbose  =    (uint )0;
#line 19 "/home/june/collector/temp/bmf-0.9.4/dbg.c"
void verbose(int level , char const   *fmt  , ...) 
{ 
  char str[4096] ;
  va_list v ;

  {
#line 21
  if (g_verbose >= (uint )level) {
    {
#line 25
    __builtin_va_start(v, fmt);
#line 26
    vsnprintf((char */* __restrict  */)(str), sizeof(str) - 1UL, (char const   */* __restrict  */)fmt,
              v);
#line 27
    str[sizeof(str) - 1UL] = (char )'\000';
#line 29
    fputs((char const   */* __restrict  */)(str), (FILE */* __restrict  */)stderr);
    }
  }
#line 35
  return;
}
}
#line 292 "/home/june/collector/temp/bmf-0.9.4/dbg.c"
void dbgout(char const   *fmt  , ...) 
{ 


  {
#line 295
  return;
}
}
#line 297 "/home/june/collector/temp/bmf-0.9.4/dbg.c"
void dump_alloc_heap(void) 
{ 


  {
#line 300
  return;
}
}
#line 639 "/home/june/collector/temp/bmf-0.9.4/dbdb.c"
dbh_t *dbdb_db_open(cpchar dbhost , cpchar dbname , cpchar dbuser , cpchar dbpass ) 
{ 


  {
#line 641
  return ((dbh_t *)((void *)0));
}
}
#line 38 "/home/june/collector/temp/bmf-0.9.4/vec.c"
static void vec_setsize___0(vec_t *pthis , uint nsize ) 
{ 
  uint nnewalloc ;
  str_t *pnewitems ;
  uint n ;
  void *tmp ;

  {
#line 40
  if (nsize > pthis->nalloc) {
#line 46
    nnewalloc = pthis->nalloc * 2U;
#line 47
    if (nnewalloc < nsize) {
#line 47
      nnewalloc = nsize;
    }
    {
#line 48
    tmp = realloc((void *)pthis->pitems, (unsigned long )nnewalloc * sizeof(str_t ));
#line 48
    pnewitems = (str_t *)tmp;
    }
#line 49
    if ((unsigned long )pnewitems == (unsigned long )((void *)0)) {
      {
#line 51
      exit(2);
      }
    }
#line 53
    n = pthis->nitems;
    {
#line 53
    while (1) {
      while_continue: /* CIL Label */ ;
#line 53
      if (! (n < nsize)) {
#line 53
        goto while_break;
      }
      {
#line 55
      str_create(pnewitems + n);
#line 53
      n ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 57
    pthis->pitems = pnewitems;
#line 58
    pthis->nalloc = nnewalloc;
  }
#line 60
  return;
}
}
#line 110 "/home/june/collector/temp/bmf-0.9.4/vec.c"
static int svec_compare___0(void const   *p1 , void const   *p2 ) 
{ 
  int tmp ;

  {
  {
#line 112
  tmp = str_casecmp((str_t const   *)p1, (str_t const   *)p2);
  }
#line 112
  return (tmp);
}
}
#line 21 "/home/june/collector/temp/bmf-0.9.4/dbtext.c"
static void dbtext_table_setsize___0(dbttext_t *pthis , uint nsize ) 
{ 
  uint nnewalloc ;
  rec_t *pnewitems ;
  uint n ;
  void *tmp ;

  {
#line 23
  if (nsize > pthis->nalloc) {
#line 29
    nnewalloc = pthis->nalloc * 2U;
#line 30
    if (nnewalloc < nsize) {
#line 30
      nnewalloc = nsize;
    }
    {
#line 31
    tmp = realloc((void *)pthis->pitems, (unsigned long )nnewalloc * sizeof(rec_t ));
#line 31
    pnewitems = (rec_t *)tmp;
    }
#line 32
    if ((unsigned long )pnewitems == (unsigned long )((void *)0)) {
      {
#line 34
      exit(2);
      }
    }
#line 36
    n = pthis->nitems;
    {
#line 36
    while (1) {
      while_continue: /* CIL Label */ ;
#line 36
      if (! (n < nsize)) {
#line 36
        goto while_break;
      }
      {
#line 38
      str_create(& (pnewitems + n)->w);
#line 39
      (pnewitems + n)->n = (uint )0;
#line 36
      n ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 41
    pthis->pitems = pnewitems;
#line 42
    pthis->nalloc = nnewalloc;
  }
#line 44
  return;
}
}
#line 25 "/home/june/collector/temp/bmf-0.9.4/bmfconv.c"
static void usage___0(void) 
{ 


  {
  {
#line 27
  printf((char const   */* __restrict  */)"\nUsage: bmfconv [options]\n\t-f fmt\tSpecify database format (db|mysql).\n\t-d db\tSpecify database or directory name.\n\t-e\tExport  to  text files goodlist.txt and spamlist.txt.\n\t-i\tImport from text files goodlist.txt and spamlist.txt.\n\t-v\tShow version information and exit\n\t-h\tShow this message and exit\n\n");
#line 36
  exit(2);
  }
}
}
#line 39 "/home/june/collector/temp/bmf-0.9.4/bmfconv.c"
static void version___0(void) 
{ 


  {
  {
#line 41
  printf((char const   */* __restrict  */)"\nbmfconv version 0.9.4 - a Bayesian mail filter\nCopyright (c) 2002 Tom Marshall\n\nbmfconv comes with ABSOLUTELY NO WARRANTY.\nThis is free software.  You are welcome to redistribute it under the terms\nof the GNU General Public License.  See the file LICENSE in the source\ndistribution, or visit http://www.gnu.org/licenses/gpl.html\n\n");
#line 50
  exit(2);
  }
}
}
