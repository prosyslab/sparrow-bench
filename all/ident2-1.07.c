/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 66 "/home/june/repo/benchmarks/collector/temp/ident2-1.07/ident2.h"
enum Service_Type {
    NO_TYPE = 0,
    DAEMON = 1,
    INETD = 2
} ;
#line 104 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_13 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_13 __sigset_t;
#line 37 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __sigset_t sigset_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_14 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_14 fd_set;
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef union sigval sigval_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef __clock_t __sigchld_clock_t;
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__kill_27 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__timer_28 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__rt_29 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigchld_30 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __sigchld_clock_t si_utime ;
   __sigchld_clock_t si_stime ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigfault_31 {
   void *si_addr ;
   short si_addr_lsb ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigpoll_32 {
   long si_band ;
   int si_fd ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigsys_33 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union __anonunion__sifields_26 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_27 _kill ;
   struct __anonstruct__timer_28 _timer ;
   struct __anonstruct__rt_29 _rt ;
   struct __anonstruct__sigchld_30 _sigchld ;
   struct __anonstruct__sigfault_31 _sigfault ;
   struct __anonstruct__sigpoll_32 _sigpoll ;
   struct __anonstruct__sigsys_33 _sigsys ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct_siginfo_t_25 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_26 _sifields ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef struct __anonstruct_siginfo_t_25 siginfo_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion___sigaction_handler_45 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_45 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __u_short;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 34 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_short u_short;
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 80 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uid_t uid_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 91 "/home/june/repo/benchmarks/collector/temp/ident2-1.07/common.c"
struct cl_t {
   int sd ;
   uid_t uid ;
   unsigned short lp ;
   unsigned short rp ;
   struct sockaddr_in laddr ;
   struct sockaddr_in raddr ;
   struct passwd *pw ;
};
#line 91 "/home/june/repo/benchmarks/collector/temp/ident2-1.07/common.c"
typedef struct cl_t cl_t;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 695
extern int puts(char const   *__s ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 150
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 413 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 175 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void closelog(void) ;
#line 181
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 190
extern void ( /* format attribute */  syslog)(int __pri , char const   *__fmt  , ...) ;
#line 127 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getsockname)(int __fd ,
                                                                                  struct sockaddr * __restrict  __addr ,
                                                                                  socklen_t * __restrict  __len ) ;
#line 70 "/home/june/repo/benchmarks/collector/temp/ident2-1.07/ident2.h"
size_t Max_Connections  ;
#line 71 "/home/june/repo/benchmarks/collector/temp/ident2-1.07/ident2.h"
size_t Client_Timeout  ;
#line 73 "/home/june/repo/benchmarks/collector/temp/ident2-1.07/ident2.h"
enum Service_Type Service_Type  ;
#line 75 "/home/june/repo/benchmarks/collector/temp/ident2-1.07/ident2.h"
char Dont_Change_Uid  ;
#line 76 "/home/june/repo/benchmarks/collector/temp/ident2-1.07/ident2.h"
char Use_User_Ident  ;
#line 77 "/home/june/repo/benchmarks/collector/temp/ident2-1.07/ident2.h"
char Allow_NOIDENT  ;
#line 78 "/home/june/repo/benchmarks/collector/temp/ident2-1.07/ident2.h"
char *User_Ident_File  ;
#line 79 "/home/june/repo/benchmarks/collector/temp/ident2-1.07/ident2.h"
char Reply_Always_Random  ;
#line 81 "/home/june/repo/benchmarks/collector/temp/ident2-1.07/ident2.h"
unsigned short Ident_Port  ;
#line 99
void daemon_service(void) ;
#line 118
void child_service(int in , int out ) ;
#line 173 "/usr/include/getopt.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long)(int ___argc ,
                                                                                  char * const  *___argv ,
                                                                                  char const   *__shortopts ,
                                                                                  struct option  const  *__longopts ,
                                                                                  int *__longind ) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/ident2-1.07/ident2.c"
static int inetd_child(void) 
{ 
  struct sockaddr_in sin ;
  int sinsize ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 39
  sinsize = (int )sizeof(struct sockaddr_in );
#line 42
  tmp___2 = getsockname(0, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& sin)),
                        (socklen_t */* __restrict  */)(& sinsize));
  }
#line 42
  if (tmp___2 == -1) {
    {
#line 43
    tmp___1 = __errno_location();
    }
#line 43
    if (*tmp___1 == 88) {
#line 44
      return (0);
    } else {
      {
#line 46
      tmp = __errno_location();
#line 46
      tmp___0 = strerror(*tmp);
#line 46
      syslog(3, "getsockname: %s\n", tmp___0);
#line 47
      exit(-1);
      }
    }
  }
#line 50
  return (1);
}
}
#line 55 "/home/june/repo/benchmarks/collector/temp/ident2-1.07/ident2.c"
static void print_usage(void) 
{ 


  {
  {
#line 58
  printf((char const   */* __restrict  */)"Ident2 version %s, Copyright (C) 1999-2004 Michael Bacarella\n",
         "1.05-FINAL");
#line 59
  puts("Example command lines:");
#line 60
  puts("\t\tident2 -r\t\tsends random replies, always");
#line 61
  puts("\t\tident2 -i -y .reply\tallows user replies, which are read\n\t\t\t\t\tfrom the file ~/.reply");
#line 63
  puts("\t\tident2 -m 5 -o 10\tultra secure mode. no more than\n\t\t\t\t\t5 connections at once, each connection\n\t\t\t\t\tis killed after 10 seconds regardless.");
#line 66
  puts("\t\tident2 -s\t\tstop ident2 from trying to change it\'s\n\t\t\t\t\tuserid if it discovers that it\'s running\n\t\t\t\t\tas a root process.");
  }
#line 69
  return;
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/ident2-1.07/ident2.c"
static void print_license(void) 
{ 


  {
  {
#line 74
  printf((char const   */* __restrict  */)"Ident2 version %s, Copyright (C) 1999-2004 Michael Bacarella\n",
         "1.05-FINAL");
#line 75
  puts("ident2 is free software, and you are welcome to redistribute it\nunder certain conditions; ident2 comes with ABSOLUTELY NO WARRANTY;\nfor details, go to http://www.gnu.org/\n");
  }
#line 79
  return;
}
}
#line 81 "/home/june/repo/benchmarks/collector/temp/ident2-1.07/ident2.c"
static void print_help(void) 
{ 


  {
  {
#line 84
  printf((char const   */* __restrict  */)"Ident2 version %s, Copyright (C) 1999-2004 Michael Bacarella\n",
         "1.05-FINAL");
#line 86
  puts("usage: ident2 [options]\noptions:\n\nthese parameters apply to all incarnations of ident2\n\n\t-h\t--help\t\t\tthis command line information\n\t-u\t--usage\t\t\tshows example command lines\n\t-v\t--version\t\tshow version information\n\t-l\t--license\t\tshow licensing information\n\t-a\t--force-inetd\t\tforce inetd mode\n\t-d\t--force-daemon\t\tforce standalone daemon\n\t-i\t--use-user-ident\tallow user defined ident replies\n\t-y\t--user-reply-file\tfile in user\'s homedir for replies\n\t-n\t--allow-noident-file\tdon\'t reply if user has a ~/NOIDENT file\n\t-o\t--client-timeout\tclients timeout after this many secs\n\t-s\t--dont-change-uid\tdon\'t try to change uid (to nobody)\n\t-r\t--always-random\t\talways send a random reply\n\nthese parameters only apply to the daemon ident2\n\n\t-m\t--daemon-maxclients\taccept no more than this many clients\n\t-p\t--daemon-port\t\tbind this port, instead of \'auth\'\n");
  }
#line 136
  return;
}
}
#line 141 "/home/june/repo/benchmarks/collector/temp/ident2-1.07/ident2.c"
static void print_version(void) 
{ 


  {
  {
#line 144
  printf((char const   */* __restrict  */)"Ident2 version %s, maintainer %s\n\n",
         "1.05-FINAL", "mike@bacarella.com");
  }
#line 146
  return;
}
}
#line 159
static void command_line(int argc , char **argv ) ;
#line 159 "/home/june/repo/benchmarks/collector/temp/ident2-1.07/ident2.c"
static struct option long_options[15]  = 
#line 159
  {      {"allow-noident-file", 0, (int *)0, 'n'}, 
        {"help", 0, (int *)0, 'h'}, 
        {"usage", 0, (int *)0, 'u'}, 
        {"version", 0, (int *)0, 'v'}, 
        {"license", 0, (int *)0, 'l'}, 
        {"force-inetd", 0, (int *)0, 'a'}, 
        {"force-daemon", 0, (int *)0, 'd'}, 
        {"use-user-ident", 0, (int *)0, 'i'}, 
        {"dont-change-uid", 0, (int *)0, 's'}, 
        {"always-random", 0, (int *)0, 'r'}, 
        {"user-reply-file", 1, (int *)0, 'y'}, 
        {"client-timeout", 1, (int *)0, 'o'}, 
        {"daemon-maxclients", 1, (int *)0, 'm'}, 
        {"daemon-port", 1, (int *)0, 'p'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 149 "/home/june/repo/benchmarks/collector/temp/ident2-1.07/ident2.c"
static void command_line(int argc , char **argv ) 
{ 
  int c ;
  int option_index ;
  long tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 158
    option_index = 0;
#line 177
    c = getopt_long(argc, (char * const  *)argv, "nhuvrliady:o:ftTsm:p:", (struct option  const  *)(long_options),
                    & option_index);
    }
#line 179
    if (c == -1) {
#line 180
      goto while_break;
    }
    {
#line 186
    if (c == 110) {
#line 186
      goto case_110;
    }
#line 189
    if (c == 104) {
#line 189
      goto case_104;
    }
#line 192
    if (c == 117) {
#line 192
      goto case_117;
    }
#line 195
    if (c == 118) {
#line 195
      goto case_118;
    }
#line 198
    if (c == 108) {
#line 198
      goto case_108;
    }
#line 201
    if (c == 97) {
#line 201
      goto case_97;
    }
#line 204
    if (c == 100) {
#line 204
      goto case_100;
    }
#line 207
    if (c == 105) {
#line 207
      goto case_105;
    }
#line 210
    if (c == 115) {
#line 210
      goto case_115;
    }
#line 213
    if (c == 114) {
#line 213
      goto case_114;
    }
#line 216
    if (c == 121) {
#line 216
      goto case_121;
    }
#line 219
    if (c == 111) {
#line 219
      goto case_111;
    }
#line 226
    if (c == 109) {
#line 226
      goto case_109;
    }
#line 233
    if (c == 112) {
#line 233
      goto case_112;
    }
#line 241
    goto switch_default;
    case_110: /* CIL Label */ 
#line 187
    Allow_NOIDENT = (char)1;
#line 188
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 190
    print_help();
#line 191
    exit(0);
    }
    case_117: /* CIL Label */ 
    {
#line 193
    print_usage();
#line 194
    exit(0);
    }
    case_118: /* CIL Label */ 
    {
#line 196
    print_version();
#line 197
    exit(0);
    }
    case_108: /* CIL Label */ 
    {
#line 199
    print_license();
#line 200
    exit(0);
    }
    case_97: /* CIL Label */ 
#line 202
    Service_Type = (enum Service_Type )2;
#line 203
    goto switch_break;
    case_100: /* CIL Label */ 
#line 205
    Service_Type = (enum Service_Type )1;
#line 206
    goto switch_break;
    case_105: /* CIL Label */ 
#line 208
    Use_User_Ident = (char)1;
#line 209
    goto switch_break;
    case_115: /* CIL Label */ 
#line 211
    Dont_Change_Uid = (char)1;
#line 212
    goto switch_break;
    case_114: /* CIL Label */ 
#line 214
    Reply_Always_Random = (char)1;
#line 215
    goto switch_break;
    case_121: /* CIL Label */ 
#line 217
    User_Ident_File = optarg;
#line 218
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 220
    tmp = atol((char const   *)optarg);
#line 220
    Client_Timeout = (size_t )tmp;
    }
#line 220
    if (Client_Timeout == 0UL) {
      {
#line 221
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR: Ident2: bad value for arguement `o\'\n");
#line 223
      exit(1);
      }
    }
#line 225
    goto switch_break;
    case_109: /* CIL Label */ 
    {
#line 227
    tmp___0 = atol((char const   *)optarg);
#line 227
    Max_Connections = (size_t )tmp___0;
    }
#line 227
    if (Max_Connections == 0UL) {
      {
#line 228
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR: Ident2: bad value for arguement `m\'\n");
#line 230
      exit(1);
      }
    }
#line 232
    goto switch_break;
    case_112: /* CIL Label */ 
    {
#line 234
    tmp___1 = atoi((char const   *)optarg);
#line 234
    Ident_Port = (unsigned short )tmp___1;
    }
#line 234
    if ((int )Ident_Port == 0) {
      {
#line 235
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR: Ident2: bad value for arguement `p\'\n");
#line 237
      exit(1);
      }
    }
#line 239
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 243
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ident2: bad command line:\n\t``ident2 --help | more\'\' for help\n\t``ident2 --usage\'\' for some examples\n\n");
#line 251
    exit(1);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 254
  return;
}
}
#line 257 "/home/june/repo/benchmarks/collector/temp/ident2-1.07/ident2.c"
int main(int argc , char **argv ) 
{ 
  int tmp ;

  {
  {
#line 260
  Dont_Change_Uid = (char)0;
#line 260
  Reply_Always_Random = (char)0;
#line 260
  Use_User_Ident = (char)0;
#line 260
  Ident_Port = (unsigned short)113;
#line 260
  Service_Type = (enum Service_Type )0;
#line 260
  User_Ident_File = (char *)".ident";
#line 260
  Max_Connections = (size_t )25;
#line 260
  Client_Timeout = (size_t )20;
#line 261
  command_line(argc, argv);
  }
#line 265
  if ((unsigned int )Service_Type == 0U) {
    {
#line 266
    tmp = inetd_child();
    }
#line 266
    if (tmp) {
#line 267
      Service_Type = (enum Service_Type )2;
    } else {
#line 269
      Service_Type = (enum Service_Type )1;
    }
  }
#line 272
  if ((unsigned int )Service_Type == 2U) {
    {
#line 273
    openlog("in.ident2", 1, 4 << 3);
#line 274
    child_service(0, 1);
#line 275
    closelog();
    }
  } else {
    {
#line 278
    daemon_service();
    }
  }
#line 280
  return (0);
}
}
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 215 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigemptyset)(sigset_t *__set ) ;
#line 259
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigaction)(int __sig ,
                                                                                struct sigaction  const  * __restrict  __act ,
                                                                                struct sigaction * __restrict  __oact ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 667
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) setsid)(void) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 123
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  *__addr ,
                                                                           socklen_t __len ) ;
#line 233
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) listen)(int __fd ,
                                                                             int __n ) ;
#line 243
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 125 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 379 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 53 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) inet_ntoa)(struct in_addr __in ) ;
#line 111 "/home/june/repo/benchmarks/collector/temp/ident2-1.07/ident2.h"
int m_reduce_rights(void) ;
#line 112
int m_register_pid(void) ;
#line 117
void *xmalloc(size_t nb ) ;
#line 37 "/home/june/repo/benchmarks/collector/temp/ident2-1.07/daemon.c"
static int _go_daemon(void) 
{ 
  __pid_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 40
  tmp = fork();
  }
  {
#line 41
  if (tmp == 0) {
#line 41
    goto case_0;
  }
#line 46
  if (tmp == -1) {
#line 46
    goto case_neg_1;
  }
#line 49
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 42
  setsid();
#line 43
  m_register_pid();
#line 44
  m_reduce_rights();
  }
#line 45
  return (0);
  case_neg_1: /* CIL Label */ 
  {
#line 47
  tmp___0 = __errno_location();
#line 47
  tmp___1 = strerror(*tmp___0);
#line 47
  syslog(3, "d_core: error fork(): %s\n", tmp___1);
  }
#line 48
  return (-1);
  switch_default: /* CIL Label */ 
  {
#line 50
  exit(0);
  }
  switch_break: /* CIL Label */ ;
  }
}
}
#line 57 "/home/june/repo/benchmarks/collector/temp/ident2-1.07/daemon.c"
static void _reap_proc(pid_t *pv , size_t Max_Connections___0 ) 
{ 
  pid_t *p ;
  int r ;
  int s ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;

  {
#line 63
  p = pv;
  {
#line 63
  while (1) {
    while_continue: /* CIL Label */ ;
#line 63
    if (! ((unsigned long )p < (unsigned long )(pv + Max_Connections___0))) {
#line 63
      goto while_break;
    }
#line 64
    if (*p == 0) {
#line 65
      goto __Cont;
    }
    {
#line 67
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 67
      r = waitpid(*p, & s, 1);
      }
#line 67
      if (! (r == -1)) {
#line 67
        goto while_break___0;
      }
      {
#line 68
      tmp___1 = __errno_location();
      }
#line 68
      if (*tmp___1 != 4) {
        {
#line 69
        tmp = __errno_location();
#line 69
        tmp___0 = strerror(*tmp);
#line 69
        syslog(5, "warning: waitpid() error: %s", tmp___0);
        }
#line 72
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 74
    if (r == 0) {
#line 75
      goto __Cont;
    }
#line 76
    if (r > 0) {
#line 77
      *p = 0;
    }
    __Cont: /* CIL Label */ 
#line 63
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 79
  return;
}
}
#line 82 "/home/june/repo/benchmarks/collector/temp/ident2-1.07/daemon.c"
static void declient(int s ) 
{ 
  struct sockaddr sin ;
  int ss ;
  int tmp ;

  {
  {
#line 86
  ss = (int )sizeof(sin);
#line 87
  tmp = accept(s, (struct sockaddr */* __restrict  */)(& sin), (socklen_t */* __restrict  */)(& ss));
#line 87
  close(tmp);
  }
#line 88
  return;
}
}
#line 91 "/home/june/repo/benchmarks/collector/temp/ident2-1.07/daemon.c"
static void _sig_ign(int s ) 
{ 


  {
#line 91
  return;
}
}
#line 94 "/home/june/repo/benchmarks/collector/temp/ident2-1.07/daemon.c"
static int _accept_connect(int sv , struct sockaddr_in *sin ) 
{ 
  size_t sl ;
  int cl ;
  int *tmp ;

  {
#line 97
  sl = sizeof(struct sockaddr_in );
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 100
    cl = accept(sv, (struct sockaddr */* __restrict  */)((struct sockaddr *)sin),
                (socklen_t */* __restrict  */)(& sl));
    }
#line 100
    if (! (cl == -1)) {
#line 100
      goto while_break;
    }
    {
#line 101
    tmp = __errno_location();
    }
#line 101
    if (*tmp == 4) {
#line 102
      goto while_continue;
    }
#line 103
    return (-1);
  }
  while_break: /* CIL Label */ ;
  }
#line 105
  return (cl);
}
}
#line 117 "/home/june/repo/benchmarks/collector/temp/ident2-1.07/daemon.c"
static void d_core(int sv ) 
{ 
  struct sigaction sa ;
  struct sockaddr_in sin ;
  pid_t *pv ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  pid_t *p ;
  int cl ;
  fd_set rfd ;
  int __d0 ;
  int __d1 ;
  int *tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  pid_t tmp___13 ;

  {
  {
#line 124
  tmp___1 = _go_daemon();
  }
#line 124
  if (tmp___1 == -1) {
    {
#line 125
    tmp = __errno_location();
#line 125
    tmp___0 = strerror(*tmp);
#line 125
    syslog(3, "d_core: error fork(): %s\n", tmp___0);
    }
#line 126
    return;
  }
  {
#line 129
  tmp___2 = xmalloc(Max_Connections * sizeof(pid_t ));
#line 129
  pv = (pid_t *)tmp___2;
#line 130
  memset((void *)pv, 0, Max_Connections * sizeof(pid_t ));
#line 132
  sa.__sigaction_handler.sa_handler = & _sig_ign;
#line 133
  sigemptyset(& sa.sa_mask);
#line 134
  sa.sa_flags = 0;
#line 136
  tmp___5 = sigaction(17, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
  }
#line 136
  if (tmp___5 == -1) {
    {
#line 137
    tmp___3 = __errno_location();
#line 137
    tmp___4 = strerror(*tmp___3);
#line 137
    syslog(3, "error: registering SIGCHLD handler: %s", tmp___4);
    }
#line 139
    return;
  }
  {
#line 142
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 147
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 147
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& rfd.__fds_bits[0]): "memory");
#line 147
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 148
    rfd.__fds_bits[sv / (8 * (int )sizeof(__fd_mask ))] |= 1L << sv % (8 * (int )sizeof(__fd_mask ));
#line 150
    tmp___7 = select(sv + 1, (fd_set */* __restrict  */)(& rfd), (fd_set */* __restrict  */)((void *)0),
                     (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)((void *)0));
    }
#line 150
    if (tmp___7 == -1) {
      {
#line 151
      tmp___6 = __errno_location();
      }
#line 151
      if (*tmp___6 != 4) {
#line 152
        goto while_break;
      }
      {
#line 153
      _reap_proc(pv, Max_Connections);
      }
#line 154
      goto while_continue;
    }
#line 156
    if (! ((rfd.__fds_bits[sv / (8 * (int )sizeof(__fd_mask ))] & (1L << sv % (8 * (int )sizeof(__fd_mask )))) != 0L)) {
#line 157
      goto while_continue;
    }
#line 159
    p = pv;
    {
#line 159
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 159
      if (! ((unsigned long )p < (unsigned long )(pv + Max_Connections))) {
#line 159
        goto while_break___1;
      }
#line 160
      if (*p == 0) {
#line 161
        goto while_break___1;
      }
#line 159
      p ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 163
    if ((unsigned long )p == (unsigned long )(pv + Max_Connections)) {
      {
#line 164
      tmp___8 = inet_ntoa(sin.sin_addr);
#line 164
      syslog(6, "refusing %s: too many open connections", tmp___8);
#line 166
      declient(sv);
      }
    }
    {
#line 169
    cl = _accept_connect(sv, & sin);
    }
#line 169
    if (cl == -1) {
      {
#line 170
      tmp___9 = __errno_location();
#line 170
      tmp___10 = strerror(*tmp___9);
#line 170
      syslog(5, "warning: inconsistency error: select() and accept() disagree: %s",
             tmp___10);
      }
#line 173
      goto while_continue;
    }
    {
#line 176
    tmp___13 = fork();
#line 176
    *p = tmp___13;
    }
#line 176
    if (tmp___13 == -1) {
      {
#line 177
      tmp___11 = __errno_location();
#line 177
      tmp___12 = strerror(*tmp___11);
#line 177
      syslog(3, "warning: couldn\'t fork(): %s", tmp___12);
#line 179
      *p = 0;
      }
    } else
#line 180
    if (*p == 0) {
      {
#line 181
      child_service(cl, cl);
#line 182
      close(cl);
#line 183
      exit(0);
      }
    }
    {
#line 185
    close(cl);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 187
  return;
}
}
#line 190 "/home/june/repo/benchmarks/collector/temp/ident2-1.07/daemon.c"
void daemon_service(void) 
{ 
  int s ;
  struct sockaddr_in sin ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;

  {
  {
#line 195
  openlog("ident2", 1, 3 << 3);
#line 197
  s = socket(2, 1, 0);
  }
#line 197
  if (s == -1) {
    {
#line 198
    tmp = __errno_location();
#line 198
    tmp___0 = strerror(*tmp);
#line 198
    syslog(3, "error: socket(): %s", tmp___0);
    }
#line 199
    return;
  }
  {
#line 202
  sin.sin_family = (sa_family_t )2;
#line 203
  sin.sin_port = htons(Ident_Port);
#line 204
  sin.sin_addr.s_addr = (in_addr_t )0;
#line 206
  tmp___5 = bind(s, (struct sockaddr  const  *)((struct sockaddr *)(& sin)), (socklen_t )sizeof(sin));
  }
#line 206
  if (tmp___5 == -1) {
    {
#line 207
    tmp___1 = __errno_location();
#line 207
    tmp___2 = strerror(*tmp___1);
#line 207
    syslog(3, "error: binding to port %d: bind(): %s", (int )Ident_Port, tmp___2);
#line 209
    tmp___3 = __errno_location();
#line 209
    tmp___4 = strerror(*tmp___3);
#line 209
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error: binding to port %d: bind(): %s\n\n",
            (int )Ident_Port, tmp___4);
    }
#line 211
    return;
  }
  {
#line 214
  tmp___10 = listen(s, 15);
  }
#line 214
  if (tmp___10 == -1) {
    {
#line 215
    tmp___6 = __errno_location();
#line 215
    tmp___7 = strerror(*tmp___6);
#line 215
    syslog(3, "error: listening to port %d: listen(): %s", (int )Ident_Port, tmp___7);
#line 217
    tmp___8 = __errno_location();
#line 217
    tmp___9 = strerror(*tmp___8);
#line 217
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error: listening to port %d: listen(): %s\n",
            (int )Ident_Port, tmp___9);
    }
#line 219
    return;
  }
  {
#line 222
  fclose(stdin);
#line 223
  fclose(stderr);
#line 224
  fclose(stdout);
#line 226
  syslog(5, "identity services started [%s]", "1.05-FINAL");
#line 228
  d_core(s);
#line 230
  syslog(3, "error: identity services terminated on internal error: See last (few) message(s)");
#line 233
  closelog();
#line 234
  close(s);
  }
#line 235
  return;
}
}
#line 272 "/usr/include/stdio.h"
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 628 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 675
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 678
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) geteuid)(void) ;
#line 700
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setuid)(__uid_t __uid ) ;
#line 116 "/usr/include/pwd.h"
extern struct passwd *getpwnam(char const   *__name ) ;
#line 110 "/home/june/repo/benchmarks/collector/temp/ident2-1.07/ident2.h"
int m_get_uid(struct in_addr *laddr , u_short lp , struct in_addr *raddr , u_short rp ) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/ident2-1.07/machine.c"
int m_reduce_rights(void) 
{ 
  struct passwd *pw ;
  __uid_t tmp ;
  __uid_t tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
  {
#line 40
  tmp = geteuid();
  }
#line 40
  if (tmp) {
    {
#line 40
    tmp___0 = getuid();
    }
#line 40
    if (tmp___0) {
#line 42
      return (0);
    } else {
#line 40
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 40
  if ((int )Dont_Change_Uid == 1) {
#line 42
    return (0);
  }
  {
#line 44
  pw = getpwnam("nobody");
  }
#line 44
  if ((unsigned long )pw == (unsigned long )((void *)0)) {
    {
#line 45
    tmp___1 = __errno_location();
#line 45
    tmp___2 = strerror(*tmp___1);
#line 45
    syslog(3, "error: getpwnam(nobody): %s", tmp___2);
    }
#line 47
    return (-1);
  }
  {
#line 49
  tmp___5 = setuid(pw->pw_uid);
  }
#line 49
  if (tmp___5 == -1) {
    {
#line 50
    tmp___3 = __errno_location();
#line 50
    tmp___4 = strerror(*tmp___3);
#line 50
    syslog(3, "error: setuid(%d): %s", pw->pw_uid, tmp___4);
    }
#line 52
    return (-1);
  }
#line 54
  return (0);
}
}
#line 63 "/home/june/repo/benchmarks/collector/temp/ident2-1.07/machine.c"
int m_get_uid(struct in_addr *laddr , u_short lp , struct in_addr *raddr , u_short rp ) 
{ 
  FILE *fp ;
  char buf[150] ;
  int *tmp ;
  char *tmp___0 ;
  unsigned long local_addr ;
  unsigned long remote_addr ;
  unsigned long tx_queue ;
  unsigned long rx_queue ;
  unsigned long tm_when ;
  int sl ;
  int uid ;
  int retrnsmt ;
  int st ;
  int tr ;
  int local_port ;
  int remote_port ;
  int tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 70
  fp = fopen((char const   */* __restrict  */)"/proc/net/tcp", (char const   */* __restrict  */)"r");
  }
#line 70
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 71
    tmp = __errno_location();
#line 71
    tmp___0 = strerror(*tmp);
#line 71
    syslog(3, "error reading /proc/net/tcp: %s", tmp___0);
    }
#line 73
    return (-1);
  }
  {
#line 76
  fgets((char */* __restrict  */)(buf), 149, (FILE */* __restrict  */)fp);
  }
  {
#line 78
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 78
    tmp___2 = fgets((char */* __restrict  */)(buf), 149, (FILE */* __restrict  */)fp);
    }
#line 78
    if (! tmp___2) {
#line 78
      goto while_break;
    }
    {
#line 83
    tmp___1 = sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"%d: %lX:%x %lX:%x %x %lX:%lX %x:%lX %x %d",
                     & sl, & local_addr, & local_port, & remote_addr, & remote_port,
                     & st, & tx_queue, & rx_queue, & tr, & tm_when, & retrnsmt, & uid);
    }
#line 83
    if (tmp___1 == 12) {
#line 89
      if ((int )lp == local_port) {
#line 89
        if ((int )rp == remote_port) {
#line 89
          if (remote_addr == (unsigned long )raddr->s_addr) {
#line 91
            if ((unsigned long )laddr == (unsigned long )((void *)0)) {
              {
#line 92
              fclose(fp);
              }
#line 93
              return (uid);
            } else
#line 95
            if ((unsigned long )laddr->s_addr == local_addr) {
              {
#line 97
              fclose(fp);
              }
#line 98
              return (uid);
            }
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 103
  fclose(fp);
  }
#line 104
  return (-1);
}
}
#line 114 "/home/june/repo/benchmarks/collector/temp/ident2-1.07/machine.c"
int m_register_pid(void) 
{ 
  FILE *fp ;
  int *tmp ;
  char *tmp___0 ;
  __pid_t tmp___1 ;

  {
  {
#line 120
  fp = fopen((char const   */* __restrict  */)"/var/run/ident2.pid", (char const   */* __restrict  */)"w");
  }
#line 120
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 121
    tmp = __errno_location();
#line 121
    tmp___0 = strerror(*tmp);
#line 121
    syslog(4, "couldn\'t record pid in %s: %s -- automatic shutdown with system not available",
           "/var/run/ident2.pid", tmp___0);
    }
#line 124
    return (-1);
  }
  {
#line 126
  tmp___1 = getpid();
#line 126
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%u\n", tmp___1);
#line 127
  fclose(fp);
  }
#line 129
  return (0);
}
}
#line 386 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 374 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rand)(void) ;
#line 376
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srand)(unsigned int __seed ) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 236 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 348
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2), __leaf__)) strtok)(char * __restrict  __s ,
                                                                                               char const   * __restrict  __delim ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 287 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *__name ,
                                                                                             int __type ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 432
extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) alarm)(unsigned int __seconds ) ;
#line 110 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 141 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getpeername)(int __fd ,
                                                                                  struct sockaddr * __restrict  __addr ,
                                                                                  socklen_t * __restrict  __len ) ;
#line 119 "/home/june/repo/benchmarks/collector/temp/ident2-1.07/ident2.h"
void nexus(int sd , char *line ) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/ident2-1.07/common.c"
void *xmalloc(size_t nb ) 
{ 
  void *p ;
  void *tmp ;

  {
  {
#line 31
  tmp = malloc(nb);
#line 31
  p = tmp;
  }
#line 33
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 34
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ident2: terminating on memory allocation error\n");
#line 35
    syslog(3, "error: memory allocation error");
#line 36
    exit(1);
    }
  }
#line 38
  return (p);
}
}
#line 47 "/home/june/repo/benchmarks/collector/temp/ident2-1.07/common.c"
static int _getl(int d , char *begin , u_short len ) 
{ 
  char *p ;
  char *end ;
  ssize_t tmp ;
  char *tmp___0 ;

  {
#line 52
  end = begin + ((int )len - 1);
#line 53
  p = begin;
  {
#line 53
  while (1) {
    while_continue: /* CIL Label */ ;
#line 53
    if (! ((unsigned long )p < (unsigned long )end)) {
#line 53
      goto while_break;
    }
    {
#line 54
    tmp = read(d, (void *)p, (size_t )1);
    }
#line 54
    if (tmp != 1L) {
#line 55
      goto while_break;
    }
#line 56
    if ((int )*p == 10) {
#line 57
      goto while_break;
    }
#line 58
    if ((int )*p == 13) {
#line 59
      p --;
    }
#line 53
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 61
  tmp___0 = p;
#line 61
  p ++;
#line 61
  *tmp___0 = (char)0;
#line 62
  return ((int )(p - begin));
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/ident2-1.07/common.c"
void child_service(int in , int out ) 
{ 
  char buf[128] ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 75
  signal(14, (void (*)(int  ))(& exit));
#line 76
  alarm((unsigned int )Client_Timeout);
#line 78
  tmp___0 = m_reduce_rights();
  }
#line 78
  if (tmp___0 == -1) {
    {
#line 79
    syslog(3, "error: cannot reduce self\'s rights [m_reduce_rights()]");
    }
  } else {
    {
#line 82
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 82
      tmp = _getl(in, buf, (u_short )128);
      }
#line 82
      if (! (tmp != 0)) {
#line 82
        goto while_break;
      }
      {
#line 83
      nexus(out, buf);
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 85
  close(in);
  }
#line 86
  if (out != in) {
    {
#line 87
    close(out);
    }
  }
#line 88
  return;
}
}
#line 102 "/home/june/repo/benchmarks/collector/temp/ident2-1.07/common.c"
static void _clreply(cl_t *cl , char *rslt , char *info ) 
{ 
  char buf[129] ;
  size_t tmp ;

  {
  {
#line 107
  buf[128] = (char)0;
#line 109
  snprintf((char */* __restrict  */)(buf), (size_t )127, (char const   */* __restrict  */)"%d , %d : %s : %s\r\n",
           (int )cl->lp, (int )cl->rp, rslt, info);
#line 111
  tmp = strlen((char const   *)(buf));
#line 111
  write(cl->sd, (void const   *)(buf), tmp);
  }
#line 112
  return;
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/ident2-1.07/common.c"
static int _check_noident(cl_t *cl ) 
{ 
  char p[129] ;
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 120
  p[128] = (char)0;
#line 122
  snprintf((char */* __restrict  */)(p), (size_t )127, (char const   */* __restrict  */)"%s/%s",
           (cl->pw)->pw_dir, ".noident");
#line 124
  tmp___0 = access((char const   *)(p), 0);
  }
#line 124
  if (tmp___0 == 0) {
    {
#line 125
    _clreply(cl, (char *)"ERROR", (char *)"HIDDEN-USER");
#line 126
    tmp = inet_ntoa(cl->raddr.sin_addr);
#line 126
    syslog(6, "no reply to %s (query %d, %d) due to %s", tmp, (int )cl->lp, (int )cl->rp,
           p);
    }
#line 129
    return (0);
  }
#line 131
  return (-1);
}
}
#line 134 "/home/june/repo/benchmarks/collector/temp/ident2-1.07/common.c"
static int _check_user_ident(cl_t *cl ) 
{ 
  FILE *fp ;
  int retval ;
  char idfile[129] ;
  char *p ;
  char buf[4096] ;
  char rply[129] ;
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 138
  retval = -1;
#line 141
  idfile[128] = (char)0;
#line 142
  snprintf((char */* __restrict  */)(idfile), (size_t )127, (char const   */* __restrict  */)"%s/%s",
           (cl->pw)->pw_dir, User_Ident_File);
#line 145
  tmp___0 = access((char const   *)(idfile), 4);
  }
#line 145
  if (tmp___0 == 0) {
    {
#line 146
    fp = fopen((char const   */* __restrict  */)(idfile), (char const   */* __restrict  */)"r");
    }
#line 146
    if ((unsigned long )fp != (unsigned long )((void *)0)) {
      {
#line 149
      memset((void *)(buf), 0, (size_t )4096);
#line 150
      fgets((char */* __restrict  */)(buf), 4095, (FILE */* __restrict  */)fp);
#line 151
      strtok((char */* __restrict  */)(buf), (char const   */* __restrict  */)"\r\n");
#line 153
      p = strstr((char const   *)(buf), "ident ");
      }
#line 153
      if (p) {
        {
#line 155
        rply[128] = (char)0;
#line 157
        snprintf((char */* __restrict  */)(rply), (size_t )127, (char const   */* __restrict  */)"UNIX : %s",
                 p + 6);
#line 158
        _clreply(cl, (char *)"USERID", rply);
#line 160
        tmp = inet_ntoa(cl->raddr.sin_addr);
#line 160
        syslog(6, "sent reply `%s\' to query %s (%d, %d), uid = %d", p, tmp, (int )cl->lp,
               (int )cl->rp, cl->uid);
#line 164
        retval = 0;
        }
      }
      {
#line 166
      fclose(fp);
      }
    }
  }
#line 169
  return (retval);
}
}
#line 178 "/home/june/repo/benchmarks/collector/temp/ident2-1.07/common.c"
static void _send_random_reply(cl_t *cl ) 
{ 
  char randstr[7] ;
  char buf[129] ;
  size_t i ;
  time_t tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 185
  buf[128] = (char)0;
#line 187
  tmp = time((time_t *)((void *)0));
#line 187
  srand((unsigned int )tmp);
#line 188
  i = (size_t )0;
  }
  {
#line 188
  while (1) {
    while_continue: /* CIL Label */ ;
#line 188
    if (! (i < 6UL)) {
#line 188
      goto while_break;
    }
    {
#line 189
    tmp___0 = rand();
#line 189
    randstr[i] = (char )tmp___0;
    }
    {
#line 190
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 190
      if (! ((int )randstr[i] > 122)) {
#line 190
        goto while_break___0;
      }
#line 191
      randstr[i] = (char )((int )randstr[i] - 26);
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 192
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 192
      if (! ((int )randstr[i] < 97)) {
#line 192
        goto while_break___1;
      }
#line 193
      randstr[i] = (char )((int )randstr[i] + 26);
    }
    while_break___1: /* CIL Label */ ;
    }
#line 188
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 195
  randstr[6] = (char)0;
#line 197
  snprintf((char */* __restrict  */)(buf), (size_t )127, (char const   */* __restrict  */)"UNIX : %s",
           randstr);
#line 199
  _clreply(cl, (char *)"USERID", buf);
#line 200
  tmp___1 = inet_ntoa(cl->raddr.sin_addr);
#line 200
  syslog(6, "sent random reply for query %s (%d, %d)", tmp___1, (int )cl->lp, (int )cl->rp);
  }
#line 203
  return;
}
}
#line 209 "/home/june/repo/benchmarks/collector/temp/ident2-1.07/common.c"
static cl_t *_new_cl(int sd , char *line ) 
{ 
  int uid ;
  int ssiz ;
  cl_t *p ;
  cl_t cl ;
  char *s ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  void *tmp___11 ;

  {
  {
#line 212
  ssiz = (int )sizeof(struct sockaddr );
#line 216
  cl.sd = sd;
#line 217
  cl.rp = (unsigned short)0;
#line 217
  cl.lp = cl.rp;
#line 219
  s = strchr((char const   *)line, ',');
  }
#line 219
  if (! s) {
    {
#line 220
    _clreply(& cl, (char *)"ERROR", (char *)"INVALID-PORT");
    }
#line 221
    return ((cl_t *)((void *)0));
  }
  {
#line 223
  *s = (char)0;
#line 224
  tmp = atoi((char const   *)line);
#line 224
  cl.lp = (u_short )tmp;
#line 225
  tmp___0 = atoi((char const   *)(s + 1));
#line 225
  cl.rp = (u_short )tmp___0;
#line 227
  tmp___3 = getsockname(sd, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& cl.laddr)),
                        (socklen_t */* __restrict  */)(& ssiz));
  }
#line 227
  if (tmp___3 == -1) {
    {
#line 228
    tmp___1 = __errno_location();
#line 228
    tmp___2 = strerror(*tmp___1);
#line 228
    syslog(4, "warning: getsockname(): %s\n", tmp___2);
#line 230
    _clreply(& cl, (char *)"ERROR", (char *)"UNKNOWN-ERROR");
    }
#line 231
    return ((cl_t *)((void *)0));
  }
  {
#line 233
  tmp___6 = getpeername(sd, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& cl.raddr)),
                        (socklen_t */* __restrict  */)(& ssiz));
  }
#line 233
  if (tmp___6 == -1) {
    {
#line 234
    tmp___4 = __errno_location();
#line 234
    tmp___5 = strerror(*tmp___4);
#line 234
    syslog(4, "warning: getpeername(): %s\n", tmp___5);
#line 236
    _clreply(& cl, (char *)"ERROR", (char *)"UNKNOWN-ERROR");
    }
#line 237
    return ((cl_t *)((void *)0));
  }
#line 240
  if ((int )Reply_Always_Random == 1) {
    {
#line 241
    _send_random_reply(& cl);
    }
#line 242
    return ((cl_t *)((void *)0));
  }
  {
#line 245
  uid = m_get_uid(& cl.laddr.sin_addr, cl.lp, & cl.raddr.sin_addr, cl.rp);
  }
#line 246
  if (uid == -1) {
    {
#line 247
    tmp___7 = inet_ntoa(cl.raddr.sin_addr);
#line 247
    syslog(4, "warning: bad request: %d/%d, from %s", (int )cl.lp, (int )cl.rp, tmp___7);
#line 249
    _clreply(& cl, (char *)"ERROR", (char *)"NO-USER");
    }
#line 250
    return ((cl_t *)((void *)0));
  }
  {
#line 252
  cl.uid = (uid_t )uid;
#line 254
  cl.pw = getpwuid(cl.uid);
  }
#line 254
  if ((unsigned long )cl.pw == (unsigned long )((void *)0)) {
    {
#line 255
    tmp___8 = inet_ntoa(cl.raddr.sin_addr);
#line 255
    tmp___9 = __errno_location();
#line 255
    tmp___10 = strerror(*tmp___9);
#line 255
    syslog(3, "warning: cannot map %d to a username: %s requested by query %s (%d, %d)",
           cl.uid, tmp___10, tmp___8, (int )cl.lp, (int )cl.rp);
#line 259
    _clreply(& cl, (char *)"ERROR", (char *)"UNKNOWN-ERROR");
    }
#line 260
    return ((cl_t *)((void *)0));
  }
  {
#line 262
  tmp___11 = xmalloc(sizeof(cl_t ));
#line 262
  p = (cl_t *)tmp___11;
#line 263
  *p = cl;
  }
#line 265
  return (p);
}
}
#line 275 "/home/june/repo/benchmarks/collector/temp/ident2-1.07/common.c"
void nexus(int sd , char *line ) 
{ 
  cl_t *cl ;
  char buf[129] ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 281
  buf[128] = (char)0;
#line 283
  cl = _new_cl(sd, line);
  }
#line 283
  if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 284
    return;
  }
#line 288
  if ((int )Allow_NOIDENT == 1) {
    {
#line 289
    tmp = _check_noident(cl);
    }
#line 289
    if (! tmp) {
      {
#line 290
      free((void *)cl);
      }
#line 291
      return;
    }
  }
#line 294
  if ((int )Use_User_Ident == 1) {
    {
#line 295
    tmp___0 = _check_user_ident(cl);
    }
#line 295
    if (! tmp___0) {
      {
#line 296
      free((void *)cl);
      }
#line 297
      return;
    }
  }
  {
#line 300
  snprintf((char */* __restrict  */)(buf), (size_t )127, (char const   */* __restrict  */)"UNIX : %s",
           (cl->pw)->pw_name);
#line 302
  _clreply(cl, (char *)"USERID", buf);
#line 303
  tmp___1 = inet_ntoa(cl->raddr.sin_addr);
#line 303
  syslog(6, "sent reply `%s\' to query %s (%d, %d), uid = %d", (cl->pw)->pw_name,
         tmp___1, (int )cl->lp, (int )cl->rp, cl->uid);
#line 308
  free((void *)cl);
  }
#line 309
  return;
}
}
